
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/basic/door.c ===
#include <door.h>
#include <room.h>
#include <parse_command.h>
#include <dirs.h>
#define BEVERB ({ " is ", " are " })
#define PRONOUN ({ "it", "them" })
#define CLOSED        2
#define CLOSED_LOCKED 3
inherit "/std/basic/enchant";
inherit "/std/basic/hide_invis";
inherit "/std/basic/property";
inherit "/std/basic/close_lock";
inherit "/std/basic/trap";
inherit "/std/basic/id_match";
private int how_many;
private int one_way;
private string _lock_owner;
private string shrt;
private string lng;
private string my_id;
private string other_id;
private string *name;
private string *adjs;
private string *plu;
private string dest;
private string _door_name;
private object key;
private object my_room;
void create() {
   hide_invis::create();
   property::create();
   close_lock::create();
   name = ({ "door" });
   lng = "It's just a door.\n";
   shrt = "door";
   adjs = ({ });
   plu = ({ });
   add_property( "determinate", "the " );
   set_unlocked();
}
int query_how_many() {
    return how_many;
}
void set_how_many( int number ) {
  if(number)
    add_property("group object", 1);
  else
    remove_property("group object");
  how_many = number;
}
int query_one_way() {
    return one_way;
}
void set_one_way( int number ) {
    one_way = number;
}
string query_short() {
    return shrt;
}
void set_short( string words ) {
   string *bits;
   shrt = words;
   bits = explode( words, " " );
   bits += implode( map( bits, (: explode( $1, "-" ) :) ), (: $1 + $2 :) );
   bits = uniq_array( bits );
   name += ({ bits[ sizeof( bits ) - 1 ] });
   adjs += bits[ 0 .. sizeof( bits ) - 2 ];
   plu += ({ pluralize( bits[ sizeof( bits ) - 1 ] ) });
}
string query_door_name() {
    return _door_name;
}
void set_door_name( string word ) {
    _door_name = word;
}
void set_lock_owner(string owner) {
    _lock_owner = owner;
}
mixed query_lock_owner() {
    return _lock_owner;
}
string query_long() { return lng; }
void set_long( string word ) {lng = word;}
string query_my_id() { return my_id; }
void set_my_id( string word ) { my_id = word; }
string query_other_id() { return other_id; }
void set_other_id( string word ) { other_id = word; }
string *query_name() { return name; }
string *query_adjs() { return adjs; }
string *query_plu() { return plu; }
string query_dest() { return dest; }
void set_dest( string word ) { dest = word; }
object query_my_room() { return my_room; }
void init() {
   add_command( "knock", "on <direct:object>" );
   close_lock::init();
}
string query_determinate() { return "the "; }
string short() { return query_short(); }
string a_short() { return "$a_short:"+ file_name( this_object() ) +"$"; }
string one_short() { return "$one_short:"+ file_name( this_object() ) +"$"; }
string poss_short() { return "$poss_short:"+ file_name( this_object() ) +"$"; }
string the_short() { return "$the_short:"+ file_name( this_object() ) +"$"; }
string pretty_short() { return query_short(); }
string query_plural() { return pluralize( query_short() ); }
string pretty_plural() { return pluralize( query_short() ); }
string long() {
  return lng + ( ( this_player()->query_see_octarine() ) ? enchant_string() :
                 "" ) + long_status();
}
int drop() { return 1; }
int get() { return 1; }
void setup_door( string word, object mine, string his, mixed *args,
                 string type) {
   string *bits;
   my_id = word;
   my_room = mine;
   dest = his;
   switch(type) {
   case "window":
     if(word != "window")
       shrt = word + " window";
     else
       shrt = word;
     lng = "It's just the " + shrt + ".\n";
     name = ({ shrt, "window" });
     plu = ({ "windows" });
     break;
   default:
     if ( word[ 0 .. 5 ] == "enter " ) {
       if(SHORTEN[word[6..100]])
         name += ({ SHORTEN[word[6..100]] });
       shrt = word[ 6 .. 100 ] +" door";
       lng = "It's just the " + shrt + ".\n";
       name += ({ shrt });
       if(!args[D_SECRET ])
         plu = ({ "doors" });
     } else {
       if(SHORTEN[word])
         name += ({ SHORTEN[word] });
       shrt = word +" door";
       lng = "It's just the " + shrt + ".\n";
       name += ({ shrt });
       if(!args[D_SECRET ])
         plu = ({ "doors" });
     }
     break;
   }
   bits = explode( word, " " );
   name += ({ bits[ sizeof( bits ) - 1 ] });
   adjs +=  bits;
   plu += ({ pluralize( bits[ sizeof( bits ) - 1 ] ) });
   (!args[ D_CLOSED ]) ? set_closed() : set_open();
   (args[ D_LOCKED ]) ? set_locked() : set_unlocked();
   set_key(args[ D_KEY ] );
   set_difficulty(args[ D_DIFFICULTY ] );
   if ( args[ D_SECRET ] )
      add_hide_invis( "secret", 0, 200, 0 );
   if(sizeof(args) >= D_TRANSPARENT && args[D_TRANSPARENT])
     set_transparent();
   set_door_name(args[D_NAME]);
}
void add_alias( string word ) {
   string *bits;
   bits = explode( word, " " );
   name += ({ bits[ sizeof( bits ) - 1 ] });
   adjs +=  bits[ 0 .. sizeof( bits ) - 2 ];
   plu += ({ pluralize( bits[ sizeof( bits ) - 1 ] ) });
}
int force_other() {
  string door_name, direc;
  if(!find_object(dest)) {
    if(!load_object(dest))
      return 0;
    dest->query_door( my_room, _door_name );
  }
  if(!other_id) {
    door_name = my_room->call_door(my_id, "query_door_name");
    direc = dest->query_door(my_room, door_name);
    my_room->modify_exit( my_id, ({ "other", direc }) );
  }
  if(!other_id)
    return 0;
  return 1;
}
int do_open() {
  if(!::do_open())
    return 0;
  if(!force_other() && !one_way) {
    set_closed();
    return 0;
  }
  if(((string)my_room->query_property( "location" ) == "outside") &&
     (member_array(find_object(ROOM_HANDLER), previous_object(-1)) == -1))
    ROOM_HANDLER->add_door( this_object() );
  if(!one_way && find_object(dest)) {
    dest->modify_exit(other_id, ({ "closed", 0 }));
    if(this_player())
      dest->tell_door(other_id, (string)this_player()->a_short() +
                      " opens the $D.\n", 0);
    else
      dest->tell_door(other_id, "Someone opens the $D.\n", 0);
  }
  return 1;
}
int do_close() {
  if(!::do_close())
    return 0;
  if(!force_other() && !one_way) {
    set_open();
    return 0;
  }
  if(!one_way && find_object(dest)) {
    if(query_autolock()) {
      dest->modify_exit( other_id, ({ "closed", 1, "locked", 1 }) );
      dest->tell_door( other_id, "Someone closes the $D which "
                       "lock$s as $p close$s.\n", 0 );
    } else {
      dest->modify_exit( other_id, ({ "closed", 1 }) );
      dest->tell_door( other_id, "Someone closes the $D.\n", 0 );
    }
  }
  return 1;
}
int do_lock(object *obs) {
  if(!::do_lock(obs))
    return 0;
  if(!force_other() && !one_way) {
    set_unlocked();
    return 0;
  }
  if(!one_way && find_object(dest)) {
    dest->modify_exit(other_id, ({ "locked", 1 }));
    dest->tell_door(other_id, "Someone locks the $D.\n", 0);
  }
  return 1;
}
int do_unlock(object *obs) {
  if(!::do_unlock(obs))
    return 0;
  if(!force_other() && !one_way) {
    set_locked();
    return 0;
  }
  if(!one_way && find_object(dest)) {
    dest->modify_exit(other_id, ({ "locked", 0 }));
    dest->tell_door(other_id, "Someone unlocks the $D.\n", 0);
  }
  return 1;
}
int do_knock() {
  if(this_player()->query_property("dead"))
    return 0;
  if ( !other_id && !one_way ) {
    ROOM_HANDLER->check_door( ({ my_room, my_id }) );
    if ( !other_id )
      return 0;
  }
  if ( one_way )
    return 1;
  if(query_transparent())
    dest->tell_door(other_id, this_player()->a_short() +
                    " knocks on the $D.\n", 0);
  else
    dest->tell_door( other_id, "Someone knocks on the $D.\n", 0 );
  event(find_object(dest), "door_knock", this_player(), other_id);
  return 1;
}
int pick_unlock(object thing) {
  if (stringp(_lock_owner)) {
     if (pk_check(_lock_owner, thing, 1)) {
        return 0;
     }
  }
  if(!::pick_unlock(thing)) {
    return 0;
  }
  if(!force_other() && !one_way ) {
    set_locked();
    return 0;
  }
  if(!one_way && find_object(dest)) {
    dest->modify_exit( other_id, ({ "locked", 0 }) );
    dest->tell_door( other_id, "Someone unlocks the $D.\n", 0 );
  }
  return 1;
}
int pick_lock( object thing ) {
  if (stringp(_lock_owner)) {
     if (pk_check(_lock_owner, thing, 1)) {
        return 0;
     }
  }
  if(!::pick_lock(thing))
    return 0;
  if(!force_other() && !one_way ) {
    set_unlocked();
    return 0;
  }
  if(!one_way && find_object(dest)) {
    dest->modify_exit( other_id, ({ "locked", 1 }) );
    dest->tell_door( other_id, "Someone locks the $D.\n", 0 );
  }
  return 1;
}
string *parse_command_id_list() {
  return (this_player() ? name + ({ this_player()->find_rel(my_id) }) : name);
}
string *parse_command_adjectiv_id_list() { return adjs; }
string *parse_command_plural_id_list() { return plu; }
object query_parse_id( mixed *arr ) {
   if (arr[P_THING] == 0) {
      return this_object();
   }
   if (arr[P_THING] < 0) {
      arr[P_THING]++;
      if (arr[P_THING] != 0) {
         return 0;
      }
      arr[P_THING] = -10321;
      return this_object();
   }
   arr[P_THING]--;
   if (arr[P_THING] != 0) {
      return this_object();
   }
   arr[P_THING] = -10101;
   return this_object();
}
mixed parse_match_object( string* input,
                          object viewer,
                          class obj_match_context context )
{
   if (input[<1] == "all") {
      return 0;
   }
   return ::parse_match_object(input, viewer, context);
}
void dest_me() {
  destruct( this_object() );
}
void dwep() { destruct( this_object() ); }
void go_away() { call_out("dest_me", 0); }
int move() { return 1; }
int moving_open( object thing ) {
  if(!::do_open())
    return 0;
  if(!force_other() && !one_way) {
    set_closed();
    return 0;
  }
  if(!one_way && find_object(dest)) {
    dest->modify_exit(other_id, ({ "closed", 0 }));
    dest->tell_door(other_id, (string)thing->a_short() + " opens the $D.\n", 0);
  }
  tell_object( thing, "You open the "+ shrt +".\n" );
  tell_room( my_room, (string)thing->the_short() +
             " opens the "+ shrt +".\n", thing );
  return 1;
}
int moving_close( object thing ) {
  if(!::do_close())
    return 0;
  if(!force_other() && !one_way) {
    set_open();
    return 0;
  }
  if(!one_way && find_object(dest))
    if(query_autolock()) {
      dest->modify_exit( other_id, ({ "closed", 1, "locked", 1 }) );
      dest->tell_door(other_id, (string)thing->the_short() +
                      " closes the $D which lock$s as $p close$s.\n", thing );
    } else {
      dest->modify_exit( other_id, ({ "closed", 1 }) );
      if ( thing->short() )
        dest->tell_door( other_id, capitalize( (string)thing->the_short() ) +
                         " closes the $D.\n", thing );
    }
  if(query_autolock()) {
    tell_object( thing, "You close the "+
                 (string)dest->call_door( other_id, "query_short" ) +
                 " which locks as it closes.\n" );
    tell_room( my_room, (string)thing->the_short() +
               " closes the "+ shrt +" which locks as it closes.\n", thing );
  } else {
    tell_object( thing, "You close the "+
                 (string)dest->call_door( other_id, "query_short" ) +".\n" );
    tell_room( my_room, (string)thing->the_short() +
               " closes the "+ shrt +".\n", thing );
  }
  return 1;
}
int moving_unlock(object thing) {
  if(!::do_unlock(all_inventory(thing)))
    return 0;
  if(!one_way && find_object(dest))
    dest->modify_exit(other_id, ({ "locked", 0 }));
  tell_object(thing, "You unlock the "+ shrt +".\n");
  if (thing->short())
    tell_room( my_room, capitalize( (string)thing->the_short() ) +
               " unlocks the "+ shrt +".\n", thing );
  return 1;
}
int moving_lock(object thing) {
  if(!::do_lock(all_inventory(thing)))
    return 0;
  if(!one_way && find_object(dest))
    dest->modify_exit(other_id, ({ "locked", 1 }));
  tell_object( thing, "You lock the "+
               (string)dest->call_door( other_id, "query_short" ) +".\n" );
  if (thing->short())
    dest->tell_door( other_id, capitalize( (string)thing->the_short() ) +
                     " locks the $D.\n", thing );
  return 1;
}
void tell_door(string words, object thing) {
  tell_room(my_room, replace( words, ({
    "$D", shrt, "$p", PRONOUN[how_many], "$s", ({ "s", "" })[how_many] })),
            ({ thing }));
}
mixed *stats() {
  return property::stats() + close_lock::stats() +
         ({ ({ "lock owner", _lock_owner }),
            ({ "other id", other_id }),
            ({ "dest", dest }) });
}
string long_status() {
   string str;
   if (!query_stuck()) {
      if(query_how_many() > 0)
      {
        str = "They are";
      }
      else
      {
        str = "It is";
      }
      switch (query_closed_locked_status()) {
         case CLOSED_LOCKED :
            return str + " closed and locked.\n";
         case CLOSED :
            return str + " closed.\n";
         default :
            return str + " open.\n";
      }
   } else {
      return "";
   }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/basic/item.c ===
#define DEBUG 1;
#include <parse_command.h>
#include <obj_parser.h>
#define POSITION_SIZE 2
#define POSITION_DESC 0
#define POSITION_MULT 1
private mixed *_lng;
private string *_shrt;
private string *_adjs;
private string *_plu;
private string *_name;
#ifdef DEBUG
private string _creator_room;
#endif
private mapping _verb;
private mapping _plural;
private mapping _other_things;
private mapping _pattern;
private int *_cur_desc;
private mapping _gather;
private mapping _position_stuff;
private mapping _count;
void init() {
    string name;
    mixed rest;
    foreach (name, rest in _other_things) {
            this_player()->add_command(name, this_object(), _pattern[name]);
    }
}
#ifdef DEBUG
string query_creator_room() { return _creator_room; }
void print_stuff() {
    printf("lng = %O\nshrt = %O\nadjs = %O\nplu = %O\nname = %O\n" +
      "verb = %O\nplural = %O\nother_things = %O\npattern = %O\n" +
      "cur_desc = %O\ngather = %O\n", _lng, _shrt, _adjs, _plu, _name, _verb,
      _plural, _other_things, _pattern, _cur_desc, _gather);
}
#endif
void create() {
#ifdef DEBUG
    _creator_room = file_name(previous_object());
#endif
    _adjs = ({ });
    _lng = ({ "" });
    _shrt = ({ "" });
    _gather = ([ ]);
    _plu = ({ });
    _name = ({ });
    _verb = ([ ]);
    _plural = ([ ]);
    _pattern = ([ ]);
    _cur_desc = ({ });
    _count = ([ ]);
    _other_things = ([ "smell" : 0, "taste" : 0, "read" : 0 ]);
}
int query_visible( object thing ) { return 1; }
string hide_invis_string() { return ""; }
string *query_short_array() {
    string *ret;
    int i;
    ret = ({ });
    foreach (i in _cur_desc) {
        ret += ({ _shrt[i] });
    }
    return ret;
}
string short() {
    return query_multiple_short(query_short_array());
}
string pretty_short() {
    string *ret;
    ret = query_short_array();
    if (sizeof(ret)) {
        return query_multiple_short(ret);
    } else {
        return "something";
    }
}
string a_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:" + add_a( $1 ) + "$" :)), "");
}
string the_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:the " +  $1 + "$" :)), "");
}
string one_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:the " + $1 + "$" :)), "");
}
string poss_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:the " + $1 + "$" :)), "");
}
string query_read_short() {
    return "$name$";
}
string query_plural() {
    string *ret;
    int i;
    ret = ({ });
    foreach (i in _cur_desc) {
        ret += ({ pluralize(_shrt[i]) });
    }
    return query_multiple_short(ret);
}
string pretty_plural() {
    int i;
    foreach (i in _cur_desc) {
        return pluralize(_shrt[i]);
    }
    return 0;
}
string long( string name, int dark ) {
    int i;
    string *ret;
    ret = ({ });
    foreach (i in _cur_desc) {
        if ( !_lng[ i ] ) {
            continue;
        }
        if (functionp(_lng[ i ])) {
            ret += ({ evaluate(_lng[ i ]) });
        } else {
            ret += ({ _lng[ i ] });
        }
    }
    if ( !sizeof( ret ) ) {
        return "You don't think that the "+name+" is here.\n";
    }
    return implode( evaluate(ret), "\n")+"\n";
}
int *query_cur_desc() { return _cur_desc; }
mapping query_verbs() { return _verb; }
mapping query_plurals() { return _plural; }
string *query_lng() { return _lng; }
string *query_shrt() { return _shrt; }
mixed *query_gather() {
    mixed *g = ({ });
    int i;
    foreach (i in _cur_desc) {
        if (_gather[i]) {
            g += ({ _gather[i] });
        }
    }
    return g;
}
int drop() { return 1; }
int get() { return 1; }
int query_item(string str) { return _verb[str]; }
private void setup_bits_for_item(int index, mixed bits) {
    int i;
    string str;
    mixed pat;
    if (!pointerp(bits)) {
        _lng[index] = bits;
        return ;
    }
    _lng[index] = "You see nothing special.\n";
    for (i = 0; i < sizeof(bits); i += 2) {
        if ((arrayp( bits[i + 1] ) && sizeof( bits[i + 1] ) == 3) ||
          (sizeof( bits[i + 1] ) == 2 && functionp( bits[i + 1][0] ))) {
            pat = bits[i + 1][<1];
            if (!arrayp(pat)) {
                pat = ({ pat });
            }
        }
        else {
            pat = ({ "<direct:object>" });
        }
        if (!pointerp(bits[i])) {
            bits[i] = ({ bits[i] });
        }
        foreach (str in bits[i]) {
            if (str == "long") {
                _lng[index] = bits[i+1];
            } else if (str == "gather") {
                _gather[index] = bits[i+1];
            } else if (str == "item_count")  {
               if (!_count[index])  _count[index] = bits[i + 1];
            } else if (str == "position" ||
              str == "position multiple") {
                if (!_position_stuff)
                    _position_stuff = ([ ]);
                if (!_position_stuff[index]) {
                    _position_stuff[index] = allocate(POSITION_SIZE);
                }
                if (str == "position") {
                    _position_stuff[index][POSITION_DESC] = bits[i + 1];
                } else {
                    _position_stuff[index][POSITION_MULT] = bits[i + 1];
                }
            } else if (!_other_things[str]) {
                _pattern[str] = pat;
                _other_things[str] = ([ index : bits[i+1] ]);
            } else {
                if (member_array(pat, _pattern[str]) == -1) {
                    _pattern[str] += pat - (string *)_pattern[str];
                }
                _other_things[str][index]   = bits[i+1];
            }
        }
    }
}
private void remove_bits_for_item(int index) {
    string str;
    string adj;
    mixed value;
    int frog;
    int bing;
    int i;
    int j;
    map_delete(_gather, index);
    foreach (frog, bing in _gather) {
        if (frog > index) {
            map_delete(_gather, frog);
            _gather[frog - 1] = bing;
        }
    }
    if (_position_stuff) {
        map_delete(_position_stuff, index);
        foreach (frog, bing in _position_stuff) {
            if (frog > index) {
                map_delete(_position_stuff, frog);
                _position_stuff[frog - 1] = bing;
            }
        }
    }
    foreach (str, value in _other_things) {
        if (value) {
            map_delete(value, index);
            if (!sizeof(value)) {
                map_delete(_other_things, str);
                map_delete(_pattern, str);
            } else {
                foreach (frog, bing in value) {
                    if (frog > index) {
                        map_delete(value, frog);
                        value[frog - 1] = bing;
                    }
                }
            }
        }
    }
    foreach (str, value in _verb) {
        for (i = 0; i < sizeof(value); i += 2) {
            if (value[i + 1] > index) {
                value[i + 1] -= 1;
            } else if (value[i + 1] == index) {
                foreach (adj in value[i]) {
                    j = member_array(adj, _adjs);
                    if (j != -1) {
                        _adjs = _adjs[0..i - 1] + _adjs[i + 1..];
                    }
                }
                value = value[0.. i - 1] + value[i + 2..];
                i -= 2;
                j = member_array(str, _name);
                if (j != -1) {
                    _name = _name[0..j - 1] + _name[j + 1..];
                }
            }
        }
        _verb[str] = value;
    }
    foreach (str, value in _plural) {
        for (i = 0; i < sizeof(value); i += 2) {
            if (value[i + 1] > index) {
                value[i + 1] -= 1;
            } else if (value[i + 1] == index) {
                value = value[0.. i - 1] + value[i + 2..];
                i -= 2;
            }
        }
        _plural[str] = value;
    }
}
private void add_name_reference(int index, string name, int no_plural) {
    string *bits;
    string plural;
    string s;
    bits = explode(name, " ");
    s = bits[<1];
    if (member_array(s, _name) == -1) {
        _name += ({ s });
    }
    if (!_verb[s]) {
        _verb[s] = ({ bits[0..<2], index });
    } else {
        _verb[s] += ({ bits[0..<2], index });
    }
    if (!no_plural) {
        plural = pluralize(s);
        if (member_array(plural, _plu) == -1) {
            _plu += ({ plural });
        }
        if (!_plural[plural]) {
            _plural[plural] = ({ bits[0..<2], index });
        } else {
            _plural[plural] += ({ bits[0..<2], index });
        }
    }
    _adjs += bits[0..<2];
}
int setup_item(mixed nam, mixed long, int no_plural) {
    int index;
    string str;
    index = sizeof(_lng);
    if (pointerp(nam)) {
        if (sizeof(nam) > 0) {
            _shrt += ({ nam[0] });
            if (no_plural) {
                _plu += ({ "no plural" });
            } else {
                _plu += ({ pluralize(nam[0]) });
            }
        }
        foreach (str in nam) {
            add_name_reference(index, str, no_plural);
        }
    } else {
        _shrt += ({ nam });
        if (no_plural) {
            _plu += ({ "no plural" });
        } else {
            _plu += ({ pluralize(nam) });
        }
        add_name_reference(index, nam, no_plural);
    }
    _lng += ({ 0 });
    setup_bits_for_item(index, long);
    return index;
}
int modify_item_by_index(int index, mixed long) {
    if (index >= sizeof(_lng)) {
        return 0;
    }
    setup_bits_for_item(index, long);
    return 1;
}
int modify_item_by_name(string str, mixed long) {
    int index;
    index = member_array(str, _shrt);
    if (index == -1) {
        return 0;
    }
    return modify_item_by_index(index, long);
}
int modify_item(mixed str, mixed long) {
    if (stringp(str)) {
        return modify_item_by_name(str, long);
    }
    if (intp(str)) {
        return modify_item_by_index(str, long);
    }
    return 0;
}
int remove_item_by_index(int index) {
    if (index >= sizeof(_lng)) {
        return 0;
    }
    _shrt = _shrt[0..index - 1] + _shrt[index + 1..];
    _adjs = _adjs[0..index - 1] + _adjs[index + 1..];
    _lng = _lng[0..index - 1] + _lng[index + 1..];
    _plu = _plu[0..index - 1] + _plu[index + 1..];
    remove_bits_for_item(index);
}
int remove_item_by_name(string str) {
    int index;
    index = member_array(str, _shrt);
    if (index == -1) {
        return 0;
    }
    return remove_item_by_index(index);
}
int remove_item(mixed str) {
    if (stringp(str)) {
        return remove_item_by_name(str);
    }
    if (intp(str)) {
        return remove_item_by_index(str);
    }
    return 0;
}
string *parse_command_id_list() { return _name; }
string *parse_command_plural_id_list() { return _plu; }
string *parse_command_adjectiv_id_list() { return _adjs; }
object query_parse_id(mixed *arr)
{
    string *bits;
    mixed stuff;
    int i, j, match, all_match;
    bits = explode(arr[P_STR], " ");
    bits -= ({ "a", "an", "the" });
    if (arr[P_THING] == 0)
    {
        stuff = _plural[bits[<1]];
        if (!stuff) {
            stuff = _verb[bits[<1]];
            if (!stuff) {
                return 0;
            }
        }
        _cur_desc = ({ });
        all_match = 0;
        for (j = 0; j < sizeof(stuff); j += 2) {
            match = 1;
            for (i = 0; i < sizeof(bits) - 1; i++) {
                if (member_array(bits[i], stuff[j]) == -1) {
                    match = 0;
                    break;
                }
            }
            if (match) {
                all_match = 1;
                if (member_array(stuff[j+1], _cur_desc) == -1) {
                    _cur_desc += ({ stuff[j+1] });
                }
            }
        }
        if (all_match) {
            return this_object();
        } else {
            return 0;
        }
    }
    if (arr[P_THING] < 0) {
        stuff = _verb[bits[<1]];
        if (!stuff) {
            return 0;
        }
        for (j = 0; j < sizeof(stuff); j += 2) {
            match = 1;
            for (i = 0; i < sizeof(bits) - 1; i++) {
                if (member_array(bits[i], stuff[j]) == -1) {
                    match = 0;
                    break;
                }
            }
            if (++arr[P_THING] != 0) {
                continue;
            }
            if (match) {
                _cur_desc = ({ stuff[j+1] });
                arr[P_THING] = -10321;
                return this_object();
            }
        }
        return 0;
    }
    stuff = _plural[bits[<1]];
    if (!stuff) {
        stuff = _verb[bits[<1]];
        if (!stuff) {
            return 0;
        }
    }
    _cur_desc = ({ });
    for (j = 0; j < sizeof(stuff); j += 2) {
        match = 1;
        for (i=0;i<sizeof(bits)-1;i++) {
            if ( member_array( bits[ i ], stuff[ j ] ) == -1 ) {
                match = 0;
                break;
            }
        }
        if (match) {
            if (member_array(stuff[j+1], _cur_desc) == -1) {
                _cur_desc += ({ stuff[j+1] });
            }
            arr[P_THING]--;
            if (arr[P_THING] <= 0) {
                arr[P_THING] = -10786;
                return this_object();
            }
        }
    }
    return 0;
}
mixed* parse_match_object(string* input,
                          object player,
                          class obj_match_context context) {
   int *stuff;
   mixed *plural;
   mixed *sing;
   string *its, *thems;
   string item;
   int i;
   int j;
   int match;
   int ret;
   if (input[<1] == "here" && sizeof(input) > 1) {
      input = input[0..<2];
   }
   if ( this_object() == context->it &&
        input[<1] == "it" ) {
      sing = ({ });
      its = map(_cur_desc, (: explode(_shrt[$1], " ")[<1] :));
      foreach( item in its ) {
          if ( arrayp( _verb[ item ] ) ) {
             sing += ({ ({ item }), _verb[ item ][ 1 ] });
          }
      }
      plural = ({ });
   } else if( input[<1] == "them" &&
              context->plural &&
              member_array( this_object(), context->plural ) != -1) {
      plural = ({ });
      thems = map(_cur_desc, (: explode(_shrt[$1], " ")[<1] :));
      foreach( item in thems ) {
          if ( arrayp( _verb[ item ] ) ) {
             plural += ({ ({ item }), _verb[ item ][ 1 ] });
          }
      }
      sing = ({ });
   } else {
      plural = _plural[input[<1]];
      sing = _verb[input[<1]];
   }
   if (!sizeof(plural) && !sizeof(sing)) {
      return 0;
   }
   stuff = ({ });
   for (i = 0; i < sizeof(sing); i += 2) {
      match = 1;
      for (j = 0; j < sizeof(input) - 1; j++) {
         if (member_array(input[j], sing[i]) == -1) {
            match = 0;
            break;
         }
      }
      if (match) {
         if (member_array(sing[i+1], stuff) == -1) {
            stuff += ({ sing[i+1] });
            ret |= OBJ_PARSER_MATCH_SINGULAR;
         }
      }
   }
   for (i = 0; i < sizeof(plural); i += 2) {
      match = 1;
      for (j = 0; j < sizeof(input) - 1; j++) {
         if (member_array(input[j], plural[i]) == -1) {
            match = 0;
            break;
         }
      }
      if (match) {
         if (member_array(plural[i+1], stuff) == -1) {
            stuff += ({ plural[i+1] });
            ret |= OBJ_PARSER_MATCH_PLURAL;
         }
      }
   }
   if (sizeof(stuff)) {
       if (context->ordinal) {
          if (context->ordinal > sizeof(stuff)) {
             context->ordinal -= sizeof(stuff);
             return 0;
          }
          context->ignore_rest = 1;
          context->ordinal--;
          _cur_desc = stuff[context->ordinal..context->ordinal];
       } else if (context->number_included) {
          _cur_desc = stuff[0..context->number_included];
          context->number_included -= sizeof(stuff);
          if (context->number_included <= 0) {
             context->ignore_rest = 1;
          }
       } else if (ret & OBJ_PARSER_MATCH_PLURAL) {
          _cur_desc = stuff;
       } else {
          _cur_desc = stuff[0..0];
       }
       return ({ ret, ({ this_object() }) });
   } else {
      return 0;
   }
}
void dest_me() {
    destruct(this_object());
    return ;
}
void dwep() {
    destruct(this_object());
    return ;
}
int move() { return 1; }
int command_control(string command, object *indir, string id_arg,
  string ii_arg, string *args, string pattern) {
    int desc, size, num;
    mixed temp;
    if (!_other_things[command]) {
        return 0;
    }
    size = sizeof(_cur_desc);
    foreach (desc in _cur_desc) {
        temp = _other_things[command][desc];
        if (arrayp(temp)) {
            if (sizeof(temp) == 3 || (sizeof(temp) == 2 && !functionp(temp[0]))) {
                num += call_other(temp[0], temp[1], command, indir, id_arg,
                  ii_arg, args, pattern);
            }
            else {
                if (sizeof(temp) == 2 && functionp(temp[0])) {
                        num += evaluate(temp[0], command, indir, id_arg, ii_arg,
                            args, pattern);
                }
            }
        }
        else {
            if (functionp(temp)) {
                temp = evaluate(temp, command, indir, id_arg, ii_arg, args,
                    pattern);
            }
            if (stringp(temp)) {
                write(temp);
                num++;
                add_succeeded_mess(({ "", "$N $V $D.\n" }));
            }
            else {
                if ( intp( temp ) ) {
                    num += temp;
                }
            }
        }
    }
    return num;
}
mapping query_other_things() { return _other_things; }
mapping query_pattern() { return _pattern; }
string query_position_string(string pos) {
    int i;
    if (!_position_stuff) {
        return 0;
    }
    for (i = 0; i < sizeof(_cur_desc); i++) {
        if (_position_stuff[_cur_desc[i]]) {
            return _position_stuff[_cur_desc[i]][POSITION_DESC];
        }
    }
    return 0;
}
int query_position_multiple(string pos) {
    int i;
    if (!_position_stuff) {
        return 0;
    }
    for (i = 0; i < sizeof(_cur_desc); i++) {
        if (_position_stuff[_cur_desc[i]]) {
            return _position_stuff[_cur_desc[i]][POSITION_MULT];
        }
    }
    return 0;
}
mapping query_position_stuff() { return _position_stuff; }
int query_count()  {
   int i;
   int ret = 0;
   foreach (i in _cur_desc)  {
      ret += evaluate(_count[i]);
   }
   return ret;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/basic/twilight.c ===
#include <twilight.h>
#include <climate.h>
int last_updated;
mixed roomitems;
string *roomlong;
mixed roomchats;
object shadowed_obj;
void set_current_long();
string return_long( mixed desc );
void do_change();
void change( int time_now );
void create() {
  seteuid( (string)"/secure/master"->creator_file( file_name(
    this_object() ) ) );
}
void destruct_shadow( object thing ) {
  if( thing == this_object() )
    destruct( thing );
  else
    thing->destruct_shadow( thing );
}
void setup_shadow( object this_room ) {
  shadow( this_room, 1 );
  shadowed_obj = this_room;
  if( WEATHER_HANDLER->query_day() ) {
    call_out( "changing_to_day", 0, 1 );
    last_updated = DAY;
  } else {
    call_out( "changing_to_night", 0, 1 );
    last_updated = NIGHT;
  }
  roomitems = ({ ({ }), ({ }) });
  roomlong = allocate( 2 );
  roomlong = ({ 0, 0 });
  roomchats = allocate( 2 );
  WEATHER_HANDLER->weather_notify( this_room, NOTIFY_DAY );
}
void event_weather(int whats_changed) {
  if (WEATHER_HANDLER->query_day()) {
    if (last_updated == NIGHT)
      change( DAY );
  } else if (last_updated == DAY)
    change( NIGHT );
  shadowed_obj->event_weather( whats_changed );
}
void change( int time_now ) {
  int i;
  last_updated = time_now;
  set_current_long();
  for ( i = 0; i < sizeof( roomitems[ last_updated ] ); i += 2 )  {
    shadowed_obj->modify_item( roomitems[ last_updated ][ i ],
                               roomitems[ last_updated ][ i + 1 ] );
  }
  for ( i = 0; i < sizeof( roomitems[ 1 - last_updated ] ); i += 2 )  {
    if ( member_array( roomitems[ 1 - last_updated ][ i ],
                       roomitems[ last_updated ] ) == -1 )  {
      shadowed_obj->modify_item( roomitems[ 1 - last_updated ][ i ],
                                 "You can't see that now.\n" );
    }
  }
  shadowed_obj->stop_room_chats();
  if( sizeof(roomchats[last_updated]) )
    shadowed_obj->room_chat( roomchats[last_updated] );
  if( last_updated == DAY )
    shadowed_obj->changing_to_day( 0 );
  else
    shadowed_obj->changing_to_night( 0 );
}
void set_day_long( string str ) {
  roomlong[DAY] = str;
  set_current_long();
}
void set_night_long( string str ) {
  roomlong[NIGHT] = str;
  set_current_long();
}
void set_current_long() {
  if (roomlong[last_updated] != 0 && roomlong[last_updated] != "")
    shadowed_obj->set_long( roomlong[last_updated] );
}
varargs int add_day_item( mixed shorts, mixed desc, mixed no_plural ) {
  string the_item;
  if( pointerp( shorts ) )
    the_item = shorts[0];
  else
    the_item = shorts;
  roomitems[DAY] += ({ the_item, return_long( desc ) });
  if( last_updated == DAY )
    return this_object()->add_item( shorts, desc, no_plural );
  return 1;
}
varargs int add_night_item( mixed shorts, mixed desc, mixed no_plural ) {
  string the_item;
  if( pointerp( shorts ) )
    the_item = shorts[0];
  else
    the_item = shorts;
  roomitems[NIGHT] += ({ the_item, return_long( desc ) });
  if( last_updated == NIGHT )
    return shadowed_obj->add_item( shorts, desc, no_plural );
  return 1;
}
void room_day_chat( mixed *args ) {
  roomchats[DAY] = args;
  if( last_updated == DAY )
    shadowed_obj->room_chat( args );
}
void room_night_chat( mixed *args ) {
  roomchats[NIGHT] = args;
  if( last_updated == NIGHT )
    shadowed_obj->room_chat( args );
}
string return_long( mixed desc ) {
  int ma;
  if( !pointerp( desc ) )
    return (string)desc;
  ma = member_array( "long", desc );
  if( ma < 0 )
    return "Error: No long found.";
  return (string)desc[ma+1];
}
int query_time() { return last_updated; }
mixed query_roomitems() { return roomitems; }
string *query_roomlong() { return roomlong; }
mixed query_roomchats() { return roomchats; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/basic/situation_changer.c ===
#include <am_time.h>
#include <situations.h>
#define RANDOM(a,b) ("/obj/handlers/random_num.c"->random(a,b))
class situation_timing {
  mixed label;
  mixed duration;
  mixed when;
  int chance;
  int *endat;
  mixed background;
  mixed category;
  int it;
  mapping it_data;
}
nosave int offset;
nosave string *els;
nosave mixed *currentsits,*autosits;
nosave mapping sitdata;
nosave mapping sitwords;
nosave class situation_timing *sittiming;
nosave int chatmin=60,chatmax=120;
nosave object ownerroom;
nosave int automate=0;
nosave mixed cco;
varargs mixed change_situation( mixed label, mixed duration,
  mixed words, mixed handle );
object set_room(object room_o) {
  ownerroom=room_o;
  return this_object();
}
object query_room() { return ownerroom; }
void choose_words( mixed label, mixed choice )
{
  int i;
  class situation sit;
  string *wc;
  sit = sitdata[ label ];
  if (sizeof(sit->random_words)) {
    if (!sitwords) sitwords= ([ ]);
    if (intp(choice)) {
      wc=({ });
      for (i=0;i<sizeof(sit->random_words);i++) {
        wc+=({ "#"+(i+1),
          ((sit->random_words)[i])[
          RANDOM(sizeof((sit->random_words)[i]),choice+i*3347483647)] });
      }
      sitwords[label] = wc;
    }
    else
      sitwords[label] = choice;
  }
}
string *insert_words_chats(class situation sit, string *words) {
  string *outarray=({ });
  string s1;
  if (!sizeof(sit->chats)) return ({ });
  foreach (s1 in sit->chats) outarray+= ({ replace(s1,words) });
  return outarray;
}
mixed *insert_words_items(class situation sit, string *words) {
  mixed *outarray=({ });
  mixed ai,e0,e1;
  if (!sizeof(sit->add_items)) return ({ });
  foreach (ai in sit->add_items) {
    if (sizeof(ai)>=2) {
      e0=ai[0];
      if (arrayp(e0)) e0=explode(lower_case(replace(implode(e0,"|"),words)),"|");
      else e0=lower_case(replace(e0,words));
      e1=ai[1];
      if (arrayp(e1)) e1=explode(replace(implode(e1,"|"),words),"|");
      else e1=replace(e1,words);
      ai = ({ e0,e1 })+ai[2..];
    }
    outarray+= ({ ai });
  }
  return outarray;
}
int query_status() { return automate; }
int *query_current_situations() { return ({ currentsits, autosits }); }
mixed *query_sittiming() { return sittiming; }
mapping query_situations() { return sitdata; }
void dest_me() {
  destruct(this_object());
}
int clean_up( int parent ) {
  if (parent) {
    return 0;
  }
  return 1;
}
void add_situation( mixed label, class situation sit ) {
  if (!sizeof(sitdata)) {
    sitdata= ([ label : sit ]);
    sitwords= ([ ]);
  }
  else {
    sitdata+= ([ label : sit ]);
  }
}
void start_situation(mixed label, int do_start_mess) {
  class situation sdata;
  string *chats;
  mixed item,*items;
  object chatter;
  string *words;
  sdata=sitdata[ label ];
  words=sitwords[ label ];
  if (!currentsits) currentsits=({ label });
  else currentsits=currentsits+({ label });
  if (sizeof(sdata->extra_look)) {
    if (els && sizeof(els))
      els+=({ replace(sdata->extra_look,words) });
    else {
      els=({ replace(sdata->extra_look,words) });
      ownerroom->add_extra_look(this_object());
    }
  }
  if (do_start_mess && sizeof(sdata->start_mess))
    tell_room(ownerroom, replace(sdata->start_mess,words)+"\n");
  chats=insert_words_chats(sdata,words);
  if (chats && sizeof(chats)) {
    if (!(chatter=ownerroom->query_chatter())) {
      if (sdata->chat_rate) {
        ownerroom->room_chat( ({ chatmin,chatmax, ({ }) }),
                      clone_object("/std/room/basic/multichatter")  );
        chatter=ownerroom->query_chatter();
        chatter->setup_chatter( ownerroom,
        ({ (sdata->chat_rate)[0],(sdata->chat_rate)[1], chats }) );
      } else {
        ownerroom->room_chat( ({ chatmin,chatmax, chats }) );
        chatter=ownerroom->query_chatter();
      }
      chatter->check_chat();
    } else {
      if (sdata->chat_rate) {
        if (!(chatter->query_multichatter())) {
          mixed *args;
          args=(chatter->query_room_chats())[0..2];
          chatter->dest_me();
          ownerroom->room_chat( args,
                        clone_object("/std/room/basic/multichatter")  );
          chatter = ownerroom->query_chatter();
        }
        chatter->setup_chatter( ownerroom,
          ({ (sdata->chat_rate)[0],(sdata->chat_rate)[1], chats }) );
        chatter->check_chat();
      }
      else chatter->add_room_chats(chats);
    }
  }
  items=insert_words_items(sdata,words);
  if (sizeof(items)) {
    foreach(item in items) {
      ownerroom->add_item(item[0],item[1]);
    }
  }
  if (sdata->start_func) {
    (*(sdata->start_func))(label,do_start_mess,ownerroom);
  }
}
void end_situation(mixed label) {
  class situation sdata;
  string *chats;
  mixed item,*items;
  object chatter;
  string *words;
  sdata=sitdata[ label ];
  words=sitwords[ label ];
  if (currentsits) currentsits=currentsits-({ label });
  if (els && sizeof(sdata->extra_look)) {
    els-=({ replace(sdata->extra_look,words) });
    if (!sizeof(els)) ownerroom->remove_extra_look(this_object());
  }
  chats=insert_words_chats(sdata,words);
  if (chats && sizeof(chats) && (chatter=ownerroom->query_chatter())) {
    chatter->remove_room_chats(chats);
  }
  items=insert_words_items(sdata,words);
  if (sizeof(items)) {
    foreach(item in items) {
      if (arrayp(item[0]))
        ownerroom->remove_item((item[0])[0]);
      else
        ownerroom->remove_item(item[0]);
    }
  }
  if (sizeof(sdata->end_mess))
    tell_room(ownerroom,replace(sdata->end_mess,words)+"\n");
  if (sdata->end_func) {
    (*(sdata->end_func))(label,ownerroom);
  }
}
varargs mixed change_situation( mixed label, mixed duration,
     mixed words, mixed handle  ) {
  mixed frog,bing;
  mixed ending;
  if (!cco) cco=({ 1, 0 });
  if (!handle) {
    handle=member_array(0,cco[1..<1])+1;
    if (!handle) {
      cco+=({ 0 });
      handle=sizeof(cco)-1;
    }
  }
  cco[0]=handle;
  if (!duration) {
    if (arrayp(label)) frog=label[0];
    else frog=label;
    if (stringp(frog)) frog=explode(frog,",");
    else frog=({ frog });
    foreach(bing in frog) end_situation(bing);
    cco[handle]=0;
    return 0;
  }
  if (!arrayp(duration)) {
    if (arrayp(label)) {
      bing=duration/sizeof(label);
      duration=({ });
      foreach (frog in label) duration+=({ bing });
    }
    else duration=({ duration });
  }
  if (arrayp(label) && sizeof(label)>1 && sizeof(label)>sizeof(duration)) {
    frog=label[0];
    if (stringp(frog)) ending=explode(frog,",");
    else ending=({ frog });
    label=label[1..<1];
  }
  if (sizeof(duration)==1) {
    if (arrayp(label)) frog=label[0];
    else frog=label;
    if (stringp(frog)) frog=explode(frog,",");
    else frog=({ frog });
    if (ending) {
      ending-=frog;
      foreach(bing in ending) end_situation(bing);
    }
    if (currentsits) frog=frog-currentsits;
    foreach(bing in frog) {
      if (!sizeof(words)) choose_words( bing, time()*335423611 );
      else choose_words( bing, words );
      start_situation(bing,1);
    }
    if (duration[0]!=-1)
      cco[handle]=call_out("change_situation",duration[0],
                           label,0,words,handle);
    return handle;
  }
  if (arrayp(label)) frog=label[0];
  else frog=label;
  if (stringp(frog)) frog=explode(frog,",");
  else frog=({ frog });
  if (ending) {
    ending-=frog;
    foreach(bing in ending) end_situation(bing);
  }
  if (currentsits) frog=frog-currentsits;
  foreach(bing in frog) start_situation(bing,1);
  if (duration[0]!=-1)
    cco[handle]=
    call_out("change_situation",duration[0],
             label,duration[1..<1],words,handle);
  return handle;
}
int query_possible(class situation_timing sit, int it, int tod, int cnt)
{
  int possible;
  class situation_timing sit2;
  int cnt2,it2,tod2,possible2;
  if (functionp(sit->when)) possible=(*(sit->when))(tod);
  else possible=sit->when;
  possible=
    (possible&(1<<((AM_TIME_HANDLER)->query_am_hour(tod))))
    &&
    (RANDOM(1000,it*1147483647+cnt*2047483243) < sit->chance);
  if (possible && sit->category) {
    cnt2=0;
    foreach (sit2 in sittiming) {
      cnt2++;
      if (cnt2!=cnt && sit2->category == sit->category) {
	it2=(tod+offset+(cnt2*234231))/sit2->duration;
	tod2=it2*sit2->duration-offset-(cnt2*234231);
	if (functionp(sit2->when)) possible2=(*(sit2->when))(tod2);
	else possible2=sit2->when;
	possible2=
	  (possible2&(1<<((AM_TIME_HANDLER)->query_am_hour(tod2))))
	  &&
	  (RANDOM(1000,it2*1147483647+cnt2*2047483243) < sit2->chance);
	if (possible2 && (tod2<tod || (tod==tod2 && cnt2<cnt))) {
	  possible=0;
	  break;
	}
      }
    }
  }
  return possible;
}
void manage_situations() {
  class situation_timing sit;
  int t,t0,it,tod,cnt,possible,dt,tc,i;
  mixed label,lb;
  mixed *newsits;
  mixed *changes;
  mixed *background_on,*background_off;
  int ttmp,tstep;
  if (!automate) return;
  if (!sizeof(filter_array( all_inventory( ownerroom ),(: interactive($1) :)))) {
    automate=2;
    return;
  }
  t0=time()+offset;
  newsits=({});
  tstep=2147483648;
  background_on=({ });
  background_off=({ });
  cnt=0;
  foreach (sit in sittiming) {
    cnt++;
    t=t0+(cnt*234231);
    ttmp=sit->duration;
    it=t/ttmp;
    tod=it*ttmp-offset-(cnt*234231);
    possible=sit->it_data[ it ];
    if (undefinedp(possible)) {
      possible=query_possible(sit, it, tod, cnt);
      sit->it_data[ it ]=possible;
      if (!undefinedp(sit->it_data[ it-1 ]))
	map_delete(sit->it_data,it-1);
    } else {
    }
    if (possible) {
      if (sit->background) background_off+=explode(sit->background,",");
      if (arrayp(sit->label)) {
	dt=(t % ttmp);
	i=0;
	foreach (tc in sit->endat) {
	  if (tc>dt) break;
	  i++;
	}
	label=(sit->label)[i];
	ttmp=tc-dt;
      }
      else label=sit->label;
      if (stringp(label)) {
	label=explode(label,",");
	newsits=newsits+label;
	foreach(lb in label) choose_words(lb,it*1147483647+cnt*2047555777);
      }
      else {
	newsits=newsits+({ label });
	choose_words(label,it*1147483647+cnt*2047555777);
      }
    }
    else {
      if (sit->background) background_on+=explode(sit->background,",");
      possible=sit->it_data[ it+1 ];
      if (undefinedp(possible)) {
	possible=query_possible(sit, it+1, tod+sit->duration, cnt);
	sit->it_data[ it+1 ]=possible;
	if (!undefinedp(sit->it_data[ it-1 ]))
	  map_delete(sit->it_data,it-1);
      }
      if (possible)
	ttmp=ttmp-(t % ttmp);
      else
	ttmp=2*ttmp-(t % ttmp);
    }
    if (ttmp<tstep) tstep=ttmp;
  }
  call_out("manage_situations",tstep+1);
  newsits = newsits+(background_on-background_off);
  if (autosits && sizeof(autosits)) {
    changes=autosits-newsits;
    if (sizeof(changes)) {
      foreach(label in changes) end_situation(label);
      autosits=autosits-changes;
    }
    changes=newsits-autosits;
  }
  else changes=newsits;
  if (sizeof(changes)) {
    foreach(label in changes) start_situation(label,2-automate);
    if (autosits) autosits=autosits+changes;
    else autosits=changes;
  }
  automate=1;
}
void check_situations() {
  if (automate==2 && interactive(this_player())) manage_situations();
}
void make_seed(int xval, int yval) {
  offset=(xval*38547+yval*1232444311)>>2;
}
void automate_situation( mixed label, mixed duration, mixed when, mixed chance,
     mixed category ) {
  mixed chatargs,endat,background,labels;
  int i,d;
  string ook;
  if (!offset) {
    ook=file_name(ownerroom);
    if (!ook || ook=="") {
      write( "Bad file name" );
      return;
    }
    offset=1;
    foreach (i in ook) offset*=i;
    offset=(offset>>2)+1;
  }
  if (ownerroom->query_chatter()) {
    chatargs=(ownerroom->query_chatter())->query_room_chats();
    if (sizeof(chatargs)==3) {
      chatmin=chatargs[0];
      chatmax=chatargs[1];
    }
  }
  endat=({ });
  if (arrayp(duration)) {
    if (!arrayp(label) || sizeof(duration)!=sizeof(label)) {
      write("Duration must be an array of the same length as label");
      return;
    }
    d=0;
    labels=({ });
    for (i=0;i<sizeof(duration);i++) {
      if (duration[i]!=-1) {
	d+=duration[i];
        endat+=({ d });
	labels=labels+({ label[i] });
      }
      else {
	if (background) background=implode(explode(background,",")+({ label[i] }),",");
        else background=label[i];
      }
    }
  } else {
    labels=label;
    d=duration;
    if (arrayp(label)) {
      for (i=0;i<sizeof(label);i++) {
        endat+=({ ((i+1)*duration)/sizeof(label) });
      }
    } else {
      endat=({ duration });
    }
  }
  if (!sittiming)
    sittiming=
      ({ new(class situation_timing, label: labels, duration: d,
             when: when, chance: chance, endat: endat, background: background,
             category: category, it: 0, it_data: ([ ]) ) });
  else
    sittiming=sittiming+
      ({ new(class situation_timing, label: labels, duration: d,
             when: when, chance: chance, endat: endat, background: background,
             category: category, it: 0, it_data: ([ ]) ) });
  automate=2;
}
void shutdown_all_situations() {
  int label;
  mixed h;
  if (sizeof(cco)>1) {
    foreach (h in cco[1..<1]) {
       if (h) remove_call_out(h);
    }
  }
  cco=({ 0 });
  if (currentsits && sizeof(currentsits)) {
    foreach(label in currentsits) end_situation(label);
  }
  autosits=0;
  automate=0;
}
void shutdown_situation(int handle, mixed label) {
  mixed frog,bing;
  if (sizeof(cco)) {
    if (!handle) handle=cco[0];
    if (handle && cco[handle]) remove_call_out(cco[handle]);
    cco[handle]=0;
  }
  if (arrayp(label)) {
    frog=({ });
    foreach(bing in label) {
      if (stringp(bing)) frog+=explode(bing,",");
      else frog+=({ bing });
    }
  }
  else if (stringp(label)) label=explode(label,",");
  else label=({ label });
}
string extra_look() {
  if (!els || !sizeof(els)) {
    return "";
  }
  return implode(els,"  ")+"\n";
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/basic/situation_changer_handler.c ===
#include <situations.h>
inherit "/std/room/basic/situation_changer";
void add_situation( mixed label, class situation sit ) {
  if (!clonep()) ::add_situation( label, sit );
  else write("You can't add situations to a clone of this object.");
}
object set_room(object room_o) {
  if (clonep() ) {
    object base;
    base = find_object(base_name(this_object()));
    if (!base) {
      (base_name(this_object()))->parp();
      base = find_object(base_name(this_object()));
    }
    if (!(base->query_room())) {
      call_out( "dest_me", 2 );
      return room_o->set_situation_changer( base );
    }
    sitdata = base->query_situations();
  }
  return ::set_room( room_o );
}
void dest_me() {
  if (clonep()) ::dest_me();
  else if (sizeof(children(base_name(this_object())))==1) ::dest_me();
  return;
}
void create() {
  if (!clonep()) this_object()->setup_situations();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/basic/water.c ===
#include <armoury.h>
#include <position.h>
#include <room.h>
#include <tasks.h>
#define ANCHOR_PROP "anchor"
#define GILLS_PROP "gills"
#define FLOATING_PROP "floating"
#define LIVES_IN_WATER_PROP "lives in water"
#define SWIMMING_SKILL "other.movement.swimming"
#define OBJECT_WET_EFFECT "/std/effects/object/wet"
#define LIVING_WET_EFFECT "/std/effects/other/wetness"
#define SWIM_EFFECT "/std/effects/other/water_effect"
mixed query_property(string);
varargs mixed *query_dest_other(string);
varargs int add_property(string, mixed, int);
int modify_exit(mixed, mixed*);
string query_destination(string);
string *query_exits();
int set_water_light(int);
int query_my_light();
varargs string *query_dest_dir(object);
int lives_in_water( object ob );
varargs void soak(object, int);
object get_water();
int water_override(string);
int do_float();
int do_drift();
int do_swim();
int get_swim_enum(object);
int query_bottom();
int query_surface();
string get_exit_mess(object, string);
string get_enter_mess(object, string);
object query_above_room();
void update_water_light();
private string on_bottom = "lying on the bottom",
        non_float = "drifting nearby",
        floating = "floating nearby",
        sinking = "sinking nearby",
        s_in_mess = "$N sink$s $down$ from $F.",
        s_out_mess = "$N sink$s $down$.",
        f_in_mess = "$N float$s $up$ from $F.",
        f_out_mess = "$N float$s $up$.",
        c_in_mess = "$N $V$0=is,are$V$ swept in from $F by the current.",
        c_out_mess = "$N $V$0=is,are$V$ swept $T by the current.",
        up_dir = "up", down_dir = "down";
private int bottom = -1, surface = -1, clarity = 90, salinity = 0,
        turbulence = 100, update_light = 1, light_first_queried = 0,
        last_speech_volume = 0;
private mapping flows = ([ ]), exit_messes = ([ ]), enter_messes = ([ ]),
        origins = ([ ]);
string* query_default_search_description() {
   return ({
       "Funnily enough there is nothing interesting in the water.\n",
       "You search around and discover a whole bunch of water.\n",
       "You look up and down, left and right, then up and down again but "
       "all you can find is water.\n"
           });
}
mixed *query_default_position(object ob) {
  return ({SWIMMING, "%^BOLD%^You start to swim.%^RESET%^\n",
           "$C$"+ob->one_short()+" "
           "$V$0=starts,start$V$ to swim.\n"});
}
int is_allowed_position(string poss) {
  if (poss == SWIMMING) {
    return 1;
  }
  return 0;
}
void set_bottom_mess(string mess) {
  on_bottom = mess;
}
string query_bottom_mess() {
  return on_bottom;
}
void set_nonfloat_mess(string mess) {
   non_float = mess;
}
string query_nonfloat_mess() {
  return non_float;
}
void set_float_mess(string mess) {
  floating = mess;
}
string query_float_mess() {
  return floating;
}
void set_sinking_mess(string mess) {
  sinking = mess;
}
string query_sinking_mess() {
  return sinking;
}
void set_sink_in_mess(string mess) {
  s_in_mess = mess;
}
string query_sink_in_mess() {
  return replace(s_in_mess, ({"$down$", down_dir}));
}
void set_sink_out_mess(string mess) {
  s_out_mess = mess;
}
string query_sink_out_mess() {
  return replace(s_out_mess, ({"$down$", down_dir}));;
}
void set_float_in_mess(string mess) {
  f_in_mess = mess;
}
string query_float_in_mess() {
  return replace(f_in_mess, ({"$up$", up_dir}));
}
void set_float_out_mess(string mess) {
  f_out_mess = mess;
}
string query_float_out_mess() {
  return replace(f_out_mess, ({"$up$", up_dir}));
}
void set_sweep_in_mess(string mess) {
  c_in_mess = mess;
}
string query_sweep_in_mess() {
  return c_in_mess;
}
void set_sweep_out_mess(string mess) {
  c_out_mess = mess;
}
string query_sweep_out_mess() {
  return c_out_mess;
}
void set_up_dir(string dir) {
  up_dir = dir;
}
string query_up_dir() {
  return up_dir;
}
void set_down_dir(string dir) {
  down_dir = dir;
}
string query_down_dir() {
  return down_dir;
}
void set_bottom(int val) {
  bottom = val;
  if (bottom > 1 || bottom < -1) {
    bottom = 1;
  }
}
void set_surface(int val) {
  surface = val;
  if (surface > 1 || surface < -1) {
    surface = 1;
  }
}
void set_clarity(int how_clear) {
  clarity = how_clear;
  if (clarity > 100) {
    clarity = 100;
  }
  else if (clarity < 0) {
    clarity = 0;
  }
  if (!query_property("dark mess")) {
    if (clarity < 20) {
      add_property("dark mess", "The water here is very murky.");
    }
    else if (clarity < 50) {
      add_property("dark mess", "The water here is quite murky.");
    }
    else if (clarity < 80) {
      add_property("dark mess", "The water here is slightly murky.");
    }
  }
}
int query_clarity() {
  return clarity;
}
void set_turbidity(int how_murky) {
  set_clarity(100 - how_murky);
}
int query_turbidity() {
  return 100 - query_clarity();
}
void set_salinity(int how_salty) {
  salinity = how_salty;
  if (salinity > 100) {
    salinity = 100;
  }
  else if (salinity < 0) {
    salinity = 0;
  }
}
int query_salinity() {
  return salinity;
}
void set_turbulence(int how_turbulent) {
  turbulence = how_turbulent;
  if (turbulence < 0) {
    turbulence = 0;
  }
}
int query_turbulence() {
  return turbulence;
}
void set_use_surface_light(int val) {
  int surface_light;
  object above;
  update_light = 0;
  if (!val) {
    return;
  }
  above = query_above_room();
  if (!above) {
    set_water_light(0);
    return;
  }
  if (function_exists("query_day_light", above) ||
           above->water_surface_light_varies()) {
    update_light = 1;
    return;
  }
  if (function_exists("query_water_surface_light", above)) {
    surface_light = above->query_water_surface_light();
  }
  else {
    surface_light = above->query_my_light();
  }
  set_water_light(surface_light);
}
int query_water_surface_light() {
  update_water_light();
  return query_my_light()*query_clarity()/100;
}
int get_water_surface_light() {
  object above = query_above_room();
  if (!above) {
    return 0;
  }
  if (function_exists("query_water_surface_light", above)) {
    return above->query_water_surface_light();
  }
  return above->query_my_light();
}
void update_water_light() {
  if (!update_light) {
    return;
  }
  if (!light_first_queried) {
    set_use_surface_light(1);
    light_first_queried = 1;
    update_water_light();
    return;
  }
  set_water_light(get_water_surface_light());
}
void add_flow(string dir, int rate) {
  flows[dir] = rate;
}
void delete_flow(string dir) {
  map_delete(flows, dir);
}
mapping query_flows() {
  return copy(flows);
}
int query_flow(string dir) {
  return flows[dir];
}
int query_water_traction_bonus(object thing, int buoyancy) {
  if (buoyancy < 0) {
    buoyancy = -buoyancy;
    return buoyancy/3 + random(buoyancy/3);
  }
  return 0;
}
object query_above_room() {
  string destination = query_destination(up_dir);
  if (!destination) {
    return 0;
  }
  return load_object(destination);
}
object query_below_room() {
  string destination = query_destination(down_dir);
  if (!destination) {
    return 0;
  }
  return load_object(destination);
}
object query_surface_room() {
  object next;
  if (query_surface()) {
    return this_object();
  }
  next = query_above_room();
  if (next && next->query_water()) {
    return next->query_surface_room();
  }
  return 0;
}
object query_bottom_room() {
  object next;
  if (query_bottom()) {
    return this_object();
  }
  next = query_below_room();
  if (next && next->query_water()) {
    return next->query_bottom_room();
  }
  return 0;
}
void event_enter(object ob, string mess, object from)  {
  int effnum, buoyancy, *effects, *args;
  effects = ob->effects_matching(SWIM_EFFECT->query_classification());
  if (!effects || !sizeof(effects)) {
    if (from && !from->query_water() ) {
      if( !lives_in_water( ob ) )
        ob->add_effect(SWIM_EFFECT, 2);
    }
  }
  if ( !lives_in_water( ob ) ) {
      effnum = get_swim_enum(ob);
      args = ob->arg_of(effnum);
      if (living(ob) && query_surface() && !ob->query_property("dead") && from &&
               from->query_water() && !from->query_surface()) {
        if (args[1] < 150 || ob->query_property(GILLS_PROP)) {
          tell_object(ob, "You break the surface.\n");
        }
        else {
          tell_object(ob, "You break the surface and take a deep breath.\n");
        }
        if (args[1] != 0) {
          ob->set_arg_of(effnum, ({args[0], 0}));
        }
      }
  }
  if (!living(ob)) {
    buoyancy = SWIM_EFFECT->calc_buoyancy(ob);
    if (buoyancy < 0 && query_bottom()) {
      ob->add_property("there", on_bottom);
    }
    else if (buoyancy >= 0 && (buoyancy > ob->query_property(ANCHOR_PROP)
           || query_surface())) {
      ob->add_property("there", floating);
    }
    else if (buoyancy < 0 && buoyancy < -ob->query_property(ANCHOR_PROP)) {
      ob->add_property("there", sinking);
    }
    else {
      ob->add_property("there", non_float);
    }
  } else {
    ob->return_to_default_position();
  }
}
varargs void soak(object ob, int ignore_location) {
  int wetness = 0, *effects;
  object env, water, *things;
  env = ob;
  if (!ignore_location) {
    while (env && env = environment(env)) {
      if (env == this_object()) {
        break;
      }
      if ((env->query_closed() && env->query_waterproof()) ||
           env->query_dry_cargo()) {
        env = 0;
        break;
      }
    }
  }
  if (!env) {
    return;
  }
  if (ob->query_property(FLOATING_PROP) && query_surface()) {
    return;
  }
  if (living(ob)) {
    if (ob->query_property("dead") || lives_in_water( ob ) ) {
      return;
    }
    effects = ob->effects_matching(LIVING_WET_EFFECT->query_classification());
    if (effects && sizeof(effects)) {
      wetness = ob->arg_of(effects[0]);
    }
    wetness = ob->query_weight() - wetness;
    if (wetness > 0) {
      ob->add_effect(LIVING_WET_EFFECT, wetness);
    }
  }
  else if (ob->id("towel")) {
    effects = ob->effects_matching(OBJECT_WET_EFFECT->query_classification());
    if (effects && sizeof(effects)) {
      wetness = ob->arg_of(effects[0]);
    }
    wetness = 200*ob->query_weight() - wetness;
    if (wetness > 0) {
      ob->add_effect(OBJECT_WET_EFFECT, wetness);
    }
  }
  if (ob->query_max_volume() && !ob->query_closed() &&
           ob->query_max_volume() - ob->query_volume() > 0) {
    water = get_water();
    water->set_amount(ob->query_max_volume() - ob->query_volume());
    water->move(ob);
  }
  if (!(ob->query_closed() && ob->query_waterproof()) &&
           !ob->query_dry_cargo()) {
    things = all_inventory(ob);
    if (things && sizeof(things)) {
      map(things, (: soak($1, 1) :));
    }
  }
}
object get_water() {
  object water = ARMOURY->request_item("water");
  switch (query_clarity()) {
  case 0..20:
    water->set_short("very muddy water");
    water->add_adjective(({"very", "muddy"}));
    water->set_long("This is $amount_size$ of very muddy water.\n");
    return water;
  case 21..50:
    water->set_short("muddy water");
    water->add_adjective("muddy");
    water->set_long("This is $amount_size$ of muddy water.\n");
    return water;
  case 51..80:
    water->set_short("slightly muddy water");
    water->add_adjective(({"slightly", "muddy"}));
    water->set_long("This is $amount_size$ of slightly muddy water.\n");
  }
  switch (query_salinity()) {
  case 51..100:
    water->set_short("brine");
    water->add_alias("brine");
    water->set_long("This is $amount_size$ of very salty water.\n");
    return water;
  case 11..50:
    water->set_short("salty water");
    water->add_adjective("salty");
    water->set_long("This is $amount_size$ of salty water.\n");
  }
  return water;
}
int swim_exit(string dir, object ob, string mess) {
  int difficulty, buoyancy = 0, place, this_turb, gp_cost, effnum, *arg;
  string *places_to_go, *tm_messes;
  object destination;
  if (!living(ob) || ob->query_property("dead") || lives_in_water( ob ) ) {
    return 1;
  }
  effnum = get_swim_enum(ob);
  arg = ob->arg_of(effnum);
  if (-2 == arg[0]) {
    return 1;
  }
  difficulty = -flows[dir];
  buoyancy = SWIM_EFFECT->calc_buoyancy(ob);
  if (ob->query_weight()) {
    buoyancy /= ob->query_weight();
  }
  places_to_go = query_dest_dir();
  place = member_array(dir, places_to_go);
  if (-1 == place || !(destination = load_object(places_to_go[place+1]))) {
    return 0;
  }
  if (dir == up_dir) {
    difficulty -= buoyancy + 50;
  } else if (dir == down_dir) {
    difficulty += buoyancy - 50;
  } else if (buoyancy < 0) {
    difficulty -= buoyancy/5;
  } else {
    difficulty += buoyancy/5;
  }
  if (query_bottom() && (!destination->query_water() ||
           destination->query_bottom())) {
    difficulty -= query_water_traction_bonus(ob, buoyancy);
  }
  this_turb = random(query_turbulence());
  difficulty += this_turb;
  if (arg[0] == -1) {
    difficulty -= 50;
  }
  if (!destination->query_water()) {
    difficulty -= 50;
  }
  difficulty *= SWIM_EFFECT->swim_difficulty(ob);
  difficulty /= 100;
  if (difficulty <= 0) {
    return 1;
  }
  if (arg[0] != -1) {
    gp_cost = difficulty/20;
    if (gp_cost > 50) {
      gp_cost = 50;
    }
    else if (gp_cost < 1) {
      gp_cost = 1;
    }
    if (ob->query_specific_gp("other") < gp_cost) {
      tell_object(ob, "You're too "+({"fatigued", "tired", "weary",
           "exhausted"})[random(4)]+" to swim "+dir+" at the moment.\n");
      notify_fail("");
      return 0;
    }
  }
  ob->adjust_gp(-gp_cost);
  switch (TASKER->perform_task(ob, SWIMMING_SKILL, difficulty,
           TM_CONTINUOUS)) {
  case AWARD:
    tm_messes = ({"You move more surely as you glide through the water.",
                  "You discover a more efficient stroke.",
                  "You find a better way to streamline your body.",
                  "You find a more efficient swimming rhythm.",
                  "You begin to move more confidently through the water."});
    tell_object(ob, "%^YELLOW%^"+tm_messes[random(sizeof(tm_messes))]+
           "%^RESET%^\n");
  case SUCCEED:
    return 1;
  }
  notify_fail("");
  if (dir == up_dir && buoyancy < -50) {
    tell_object(ob, "You struggle to leave "+up_dir+" but, with the load "
           "you're carrying, you can't make any headway.\n");
    tell_room(this_object(), "$C$"+ob->one_short()+" "
           "$V$0=struggles,struggle$V$ to leave "+up_dir+", but can't make "
           "any headway.\n", ob);
    return 0;
  }
  if (dir == down_dir && buoyancy > 50) {
    tell_object(ob, "You struggle to leave "+down_dir+" but, with your "
           "buoyancy, you can't make any headway.\n");
    tell_room(this_object(), "$C$"+ob->one_short()+" "
           "$V$0=struggles,struggle$V$ to leave "+down_dir+", but can't make "
           "any headway.\n", ob);
    return 0;
  }
  if (flows[dir] < 0) {
    tell_object(ob, "You struggle to leave "+dir+", but you can't make any "
           "headway against the current.\n");
    tell_room(this_object(), "$C$"+ob->one_short()+" "
           "$V$0=struggles,struggle$V$ to leave "+dir+", but can't make any "
           "headway against the current.\n", ob);
    return 0;
  }
  if (this_turb > 0) {
    tell_object(ob, "You struggle to leave "+dir+", but you can't make any "
           "headway in the turbulent waters.\n");
    tell_room(this_object(), "$C$"+ob->one_short()+" "
           "$V$0=struggles,struggle$V$ to leave "+dir+", but can't make any "
           "headway.\n", ob);
    return 0;
  }
  tell_object(ob, "You struggle to leave "+dir+", but you can't make any "
           "headway.\n");
  tell_room(this_object(), "$C$"+ob->one_short()+" $V$0=struggles,struggle$V$ "
           "to leave "+dir+", but can't make any headway.\n", ob);
  return 0;
}
string query_death_reason() {
  return "drowning";
}
int add_exit(string direc, mixed dest, string type) {
    mixed *messy = query_dest_other(direc);
    if (messy && arrayp(messy[ROOM_ENTER]) && sizeof(messy[ROOM_ENTER]) == 2){
        origins[direc] = messy[ROOM_ENTER][1];
    }
    modify_exit(direc, ({"function", "swim_exit",
                       "exit mess", (: get_exit_mess($1, $(direc)) :),
                       "enter mess", (: get_enter_mess($1, $(direc)) :)}));
    if( direc == "down" ) {
        add_property("no burial", 1);
    }
}
string query_origin(string dir) {
  if (origins[dir]) {
    return origins[dir];
  }
  return "elsewhere";
}
void add_exit_mess(object ob, string mess) {
  exit_messes[file_name(ob)] = mess;
}
void add_enter_mess(object ob, string mess) {
  enter_messes[file_name(ob)] = mess;
}
string get_exit_mess(object ob, string direc) {
  string retval;
  if (retval = exit_messes[file_name(ob)]) {
    map_delete(exit_messes, file_name(ob));
    return retval;
  }
  return "$N $V$0=swims,swim$V$ $T.";
}
string get_enter_mess(object ob, string direc) {
  string retval;
  if (retval = enter_messes[file_name(ob)]) {
    map_delete(enter_messes, file_name(ob));
  }
  else if (direc == up_dir) {
    retval = "$N $V$0=swims,swim$V$ up from $F.";
  }
  else if (direc == down_dir) {
    retval = "$N $V$0=swims,swim$V$ down from $F.";
  }
  else {
    retval = "$N $V$0=swims,swim$V$ in from $F.";
  }
  retval = replace(retval, "$F", query_origin(direc));
  return retval;
}
void init()  {
  add_command("float", "", (: do_float() :));
  add_command("drift", "", (: do_drift() :));
  add_command("swim", "", (: do_swim() :));
}
string mangle_speech(string type, string words, mixed target) {
  int drown;
  string garbled = "";
  if (query_surface() || !this_player() ||
           this_player()->query_property("dead")) {
    return words;
  }
  switch (type) {
  case "whisper":
    drown = 20 + random(20);
    break;
  case "lsay":
  case "mock":
    drown = 80 + random(80);
    break;
  case "shout":
    drown = 120 + random(120);
    break;
  default:
    drown = 40 + random(40);
  }
  for (int inc = (strlen(words) / 10) + 1;inc > 0;--inc) {
    garbled += ({"blub", "glub", "gloog", "arrrble"})[random(4)]+" ... ";
  }
  if (drown > 70) {
    garbled = garbled[0..(strlen(garbled) - 6)]+"!";
  } else {
    garbled = garbled[0..(strlen(garbled) - 2)];
  }
  garbled = capitalize(garbled);
  last_speech_volume = drown;
  return garbled;
}
void event_person_say(object ob, string start, string mess, string lang,
           string accent) {
  int effnum, *args;
  if (!ob || ob->query_property("dead") || ob->query_property(GILLS_PROP) ||
      lives_in_water( ob ) || environment(ob) != this_object() || query_surface()) {
    last_speech_volume = 0;
    return;
  }
  if (!last_speech_volume) {
    last_speech_volume = 40 + random(40);
  }
  effnum = get_swim_enum(ob);
  args = ob->arg_of(effnum);
  args[1] += last_speech_volume;
  ob->set_arg_of(effnum, args);
  ob->adjust_tmp_con(-random((last_speech_volume / 50) + 1));
  switch (last_speech_volume) {
  case 0..30:
    tell_object(ob, "You inhale a bit of water.\n");
    break;
  case 31..80:
    tell_object(ob, "You inhale some water.\n");
    break;
  case 81..150:
    tell_object(ob, "You inhale a fair amount of water.\n");
    break;
  default:
    tell_object(ob, "You inhale about a lungful of water.\n");
  }
  last_speech_volume = 0;
}
int do_float()  {
  int *args, effnum = get_swim_enum(this_player());
  args = this_player()->arg_of(effnum);
  if (!args[0]) {
    if (sizeof(filter(query_flows(), (: $2 :)))) {
      add_failed_mess("You are already floating on the current.\n");
    }
    else {
      add_failed_mess("You are already floating freely.\n");
    }
    return 0;
  }
  this_player()->set_arg_of(effnum, ({0, args[1]}));
  if (sizeof(filter(query_flows(), (: $2 :)))) {
    add_succeeded_mess(({"You begin to float freely on the current.\n", ""}));
  }
  else {
    add_succeeded_mess(({"You begin to float freely.\n", ""}));
  }
  return 1;
}
int do_drift()  {
  int *args, effnum = get_swim_enum(this_player());
  args = this_player()->arg_of(effnum);
  if (!args[0]) {
    if (sizeof(filter(query_flows(), (: $2 :)))) {
      add_failed_mess("You are already drifting with the current.\n");
    }
    else {
      add_failed_mess("You are already drifting freely.\n");
    }
    return 0;
  }
  this_player()->set_arg_of(effnum, ({0, args[1]}));
  if (sizeof(filter(query_flows(), (: $2 :)))) {
    add_succeeded_mess(({"You begin to drift freely with the current.\n",
           ""}));
  }
  else {
    add_succeeded_mess(({"You begin to drift freely.\n", ""}));
  }
  return 1;
}
int do_swim()  {
  int *args, effnum = get_swim_enum(this_player());
  args = this_player()->arg_of(effnum);
  if (args[0]) {
    if (sizeof(filter(query_flows(), (: $2 :)))) {
      add_failed_mess("You are already swimming against the current.\n");
    }
    else {
      add_failed_mess("You are already swimming.\n");
    }
    return 0;
  }
  this_player()->set_arg_of(effnum, ({1, args[1]}));
  if (sizeof(filter(query_flows(), (: $2 :)))) {
    add_succeeded_mess(({"You begin to swim against the current.\n", ""}));
  }
  else {
    add_succeeded_mess(({"You begin to swim.\n", ""}));
  }
  return 1;
}
int get_swim_enum(object thing) {
  int *effects = thing->effects_matching(SWIM_EFFECT->query_classification());
  if (!effects || !sizeof(effects)) {
    thing->add_effect(SWIM_EFFECT, 1);
    effects = thing->effects_matching(SWIM_EFFECT->query_classification());
    call_out("soak", 1, thing);
  } else if (!random(50)) {
    call_out("soak", 1, thing);
  }
  return effects[0];
}
int query_bottom()  {
  if (bottom == -1) {
    return member_array(down_dir, query_exits()) == -1;
  }
  return bottom;
}
int query_surface() {
    if (surface == -1) {
        return member_array(up_dir, query_exits()) == -1;
    }
    return surface;
}
int query_underwater() {
  return !query_surface();
}
int query_water()  {
  return 1;
}
int lives_in_water( object ob ) {
  string race_ob = ob->query_race_ob();
  if ( !living( ob ) ) {
    return 0;
  }
  if(ob->query_property(LIVES_IN_WATER_PROP) ||
     ob->lives_in_water() ||
     (race_ob && race_ob->lives_in_water()))
    return 1;
  return 0;
}
string query_terrain_map_colour() { return "%^CYAN%^"; }
