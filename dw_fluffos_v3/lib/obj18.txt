
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/philosophies.c ===
#define SAVE_FILE "/save/philosophies"
#define SAVE_DIR "/save/philosophies/"
#define PHILOSOPHY_TYPE 0
#define PHILOSOPHY_BONUS 1
#define PHILOSOPHY_NEEDED 2
#define PHILOSOPHY_EFFECT 3
#define PHILOSOPHY_ARGUMENTS 4
nosave string current_person, current_philosophies;
mapping philosophies;
void create() {
  seteuid( (string)"/secure/master"->
           creator_file( file_name( this_object() ) ) );
   philosophies = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE :) );
}
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }
mapping query_philosophies() { return philosophies; }
string *query_philosophy_names() { return keys( philosophies ); }
int query_philosophy( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return 1;
}
void add_philosophy( string name, string type, int bonus, string needed,
      string effect ) {
   philosophies[ name ] = ({ type, bonus, needed, effect, ([ ]) });
   save_me();
}
void remove_philosophy( string name ) {
   if ( !philosophies[ name ] ) {
      return;
   }
   map_delete( philosophies, name );
   save_me();
}
string query_philosophy_type( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_TYPE ];
}
int query_philosophy_bonus( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_BONUS ];
}
string query_philosophy_needed( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_NEEDED ];
}
string query_philosophy_effect( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_EFFECT ];
}
mapping query_philosophy_all_arguments( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return copy( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ] );
}
mixed query_philosophy_argument( string name, string argument ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ];
}
void add_philosophy_argument( string name, string argument, mixed args ) {
   if ( !philosophies[ name ] ) {
      return;
   }
   if ( !undefinedp( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ] ) ) {
      return;
   }
   philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ] = args;
   save_me();
}
void remove_philosophy_argument( string name, string argument ) {
   if ( !philosophies[ name ] ) {
      return;
   }
   if ( undefinedp( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ] ) ) {
      return;
   }
   map_delete( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ], argument );
   save_me();
}
string *query_all_known( string person ) {
   string *oldstuff, *newstuff = ({}), key;
  if ( person != current_person ) {
     if(unguarded((: file_length, SAVE_DIR + person[0..0]+"/"+person :)) < 1) {
       current_philosophies = "";
     } else {
       current_philosophies = unguarded((:read_file,
         SAVE_DIR+person[0..0]+"/"+person:));
     }
  }
  oldstuff = explode(current_philosophies, "\n");
  foreach ( key in oldstuff ) {
     if ( member_array( key, newstuff ) == -1 ) {
          newstuff += ({ key });
      }
  }
  current_person = person;
  return newstuff;
}
int query_known( string person, string argument ) {
  if(person != current_person) {
    current_philosophies = "";
    if( unguarded( (: file_length,
		    SAVE_DIR + person[0..0]+"/"+person :) ) < 1 ) {
      current_person = person;
      return 0;
    }
    current_person = person;
    current_philosophies =
      unguarded( (: read_file, SAVE_DIR +  person[0..0]+"/"+person :) );
  }
  return (member_array(argument,explode(current_philosophies ,"\n")) != -1);
}
void add_known( string person, string argument ) {
   string *oldstuff, *newstuff = ({}), key;
   if ( !query_known( person, argument ) ) {
      if( !current_philosophies ) {
         current_philosophies = "";
      }
      current_philosophies += argument +"\n";
   }
   current_person = person;
   oldstuff = explode(current_philosophies, "\n");
   foreach ( key in oldstuff ) {
     if ( member_array( key, newstuff ) == -1 ) {
       newstuff += ({ key });
     }
   }
   unguarded( (: write_file, SAVE_DIR +  person[0..0]+"/"+person,
      current_philosophies, 1 :));
}
int remove_known( string person, string argument ) {
   string *oldstuff, *newstuff = ({}), key;
   if ( !this_player()->query_lord() &&
      this_player()->query_name() != "ringo" ) {
      tell_object(this_player(), "Lords only...\n");
      return 1;
   }
   oldstuff = query_all_known( person );
   current_person = person;
   current_philosophies = "";
   foreach ( key in oldstuff ) {
      if ( member_array( key, newstuff ) == -1 &&
        key != argument ) {
          newstuff += ({ key });
          current_philosophies += sprintf( "%s\n", key );
       }
   }
   unguarded( (: write_file, SAVE_DIR +  person[0..0]+"/"+person,
      current_philosophies, 1 :));
}
int reset_known( string person ) {
   if ( !this_player()->query_lord() &&
      this_player()->query_name() != "ringo" ) {
      tell_object(this_player(), "Lords only...\n");
      return 1;
   }
   current_person = person;
   current_philosophies = "";
   unguarded( (: write_file, SAVE_DIR +  person[0..0]+"/"+person,
      current_philosophies, 1 :));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/peopler.c ===
#include <peopler.h>
#define MULTIPLAYER "/obj/handlers/multiplayer"
string *de_names,
       *abbrev,
       *var_names;
void create() {
  de_names = DE_NAMES;
  abbrev = ABBREV;
  var_names = ({
      "dirs",
      "netstat",
      "people",
      "qpeople",
      "terms",
      "netdups",
    });
}
object *get_people(string str) {
  object *ob;
  int i;
  string s1;
  ob = users();
  for(i = 0; i<sizeof(ob); i++) {
    if (str && (sscanf(ob[i]->query_name(),str+"%s", s1) != 1)) {
      ob = ob[0..i - 1] + ob[i+1..];
      i--;
    }
  }
  return ob;
}
private string create_title(mixed *bits) {
  int i, pos;
  string str;
  str = "";
  for (i=0;i<sizeof(bits);i+=2) {
    if ((pos = (bits[i]&~MASK)) == STRING)
      str += bits[i+1];
    else
      if (strlen(de_names[pos]) > bits[i+1])
        str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"s", "");
      else
        switch (bits[i]&MASK) {
          case CENTER :
            str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"|s", de_names[pos]);
            break;
          case RIGHT :
            str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"s", de_names[pos]);
            break;
          default :
            str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"-s", de_names[pos]);
            break;
        }
  }
  return str;
}
private string review_thingy(mixed *bing) {
  int i;
  string str;
  str = "";
  for (i = 0; i < sizeof(bing); i += 2) {
    if (bing[i] == STRING) {
      str += bing[i+1];
    } else {
      switch (bing[i]&MASK) {
        case CENTER :
          str += "%|"+bing[i+1]+abbrev[bing[i]&~MASK];
          break;
        case RIGHT :
          str += "%"+bing[i+1]+abbrev[bing[i]&~MASK];
          break;
        default :
          str += "%-"+bing[i+1]+abbrev[bing[i]&~MASK];
          break;
      }
    }
  }
  return str;
}
private void print_entrys(object *obs, mixed *format, int with_dups,
                          string constraint) {
  int age, j;
  mixed g;
  string form, str, mess, *not_allowed;
  object ob, env, *dups;
  mapping per_ip;
  reset_eval_cost();
  if (with_dups) {
    per_ip = unique_mapping(obs, (: query_ip_number($1) :));
  }
  mess = sprintf("%s\n", create_title(format));
  foreach(ob in obs) {
    str = "";
    for (j=0;j<sizeof(format);j+=2) {
      switch (format[j]&MASK) {
        case RIGHT :
          form = "%"+format[j+1]+"."+format[j+1];
          break;
        case CENTER :
          form = "%|"+format[j+1]+"."+format[j+1];
          break;
        default :
          form = "%-"+format[j+1]+"."+format[j+1];
          break;
      }
      switch (format[j]&~MASK) {
        case STRING :
          str += format[j+1];
          break;
        case C_NAME :
          str += sprintf(form+"s", capitalize( (string)ob->query_name() ) );
          break;
        case GENDER :
          str += sprintf(form+"s", ob->query_gender_string());
          break;
        case NAME :
          str += sprintf(form+"s", (ob->query_in_editor()?"*":"")+
              ( ob->query_invis() ? "("+ (string)ob->query_name() +")" :
              (string)ob->query_name() ) );
          break;
        case GUILD :
          if(ob)
            str += sprintf(form+"s",
                           ((g=(object)ob->query_guild_ob())?
                            g->query_name():"No guild"));
          else
            str += sprintf(form+"s", "Broken guild");
          break;
        case LEVEL :
          str += sprintf(form+"s", ""+ ob->query_level());
          break;
        case ROWS :
          str += sprintf(form+"s", ""+ ob->query_rows());
          break;
        case COLS :
          str += sprintf(form+"s", ""+ ob->query_cols());
          break;
        case TERMINAL :
          str += sprintf(form+"s",
                         ((g = ob->query_term_name()) ?
                          g + (g == "network" ? " (" +
                               ob->query_cur_term() + ")" : "") : ""));
          break;
        case IP_NUMBER :
          str += sprintf(form+"s", query_ip_number(ob));
          break;
        case IP_NAME :
          str += sprintf(form+"s",
                           (query_ident(ob)?query_ident(ob)+"@":"")+
                           query_ip_name(ob));
          break;
        case TYPE :
          str += sprintf(form+"s", ob->query_object_type()+"");
          break;
        case AGE :
          age = (int)ob->query_time_on();
          if (age < -86400)
            str += sprintf(form+"s", (age/-86400)+"D");
          else if (age < -3600)
            str += sprintf(form+"s", (age/-3600)+"h");
          else if (age < -60)
            str += sprintf(form+"s", (age/-60)+"m");
          else
            str += sprintf(form+"s", (age/-1)+"s");
          break;
        case ROOM :
          env = environment(ob);
          str += sprintf(form+"s",env?file_name(env):"No environment");
          break;
        case EUID :
          env = environment(ob);
          str += sprintf(form+"s",env?geteuid(env):"No environment");
          break;
        case UID :
          env = environment(ob);
          str += sprintf(form+"s",env?getuid(env):"No environment");
          break;
        case CFILE :
          env = environment(ob);
          str += sprintf(form+"s",env?"/secure/master"->creator_file(env)
                         :"No environment");
          break;
        case CUR_DIR :
          str += sprintf(form+"s", (ob->query_current_path()?
                                    ob->query_current_path():"No dir"));
          break;
        case ND_ALLOWED :
          dups = per_ip[query_ip_number(ob)] - ({ ob });
          not_allowed = MULTIPLAYER->check_allowed(ob, dups);
          str += sprintf(form+"s", (sizeof(not_allowed) ?
                                    query_multiple_short(not_allowed) :
                                    ""));
          break;
      }
    }
    if(!constraint || strsrch(str, constraint) != -1)
      mess += sprintf("%s\n", str);
  }
  this_player()->more_string( mess );
}
int do_command(mixed *pattern, string constraint, function sort_func,
               int only_duplicates) {
   object *obs;
   object *tmpobs;
   int i;
   obs = get_people("");
   if (!sizeof(obs)) {
      notify_fail("Nobody seems to start with '" + constraint + "'.\n");
      return 0;
   }
   if (!sort_func) {
      sort_func = (: strcmp($1->query_name(), $2->query_name()) :);
   }
   obs = sort_array(obs, sort_func);
   if (only_duplicates) {
      tmpobs = ({ });
      for (i = 1; i <sizeof(obs); i++) {
         if (!evaluate(sort_func, obs[i - 1], obs[i])) {
            if (member_array(obs[i - 1], tmpobs) == -1) {
               tmpobs += obs[i - 1..i];
            } else {
               tmpobs += ({ obs[i] });
            }
         }
      }
      if (!sizeof(tmpobs)) {
         notify_fail("Unable to find any duplicates.\n");
         return 0;
      }
      obs = tmpobs;
   }
   print_entrys(obs, pattern, only_duplicates, constraint);
   return 1;
}
int review() {
  mixed *bing;
  bing = (mixed *)this_player()->query_property("people list");
  if (!bing)
    bing = P_DEFAULT;
  write("People : "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("qpeople list");
  if (!bing)
    bing = QP_DEFAULT;
  write("Qpeople: "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("netstat list");
  if (!bing)
    bing = N_DEFAULT;
  write("Netstat: "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("term list");
  if (!bing)
    bing = T_DEFAULT;
  write("Terms  : "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("dir list");
  if (!bing)
    bing = D_DEFAULT;
  write("Dirs   : "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("netdup list");
  if (!bing)
    bing = ND_DEFAULT;
  write("Netdups: "+review_thingy(bing)+"\n");
}
private mixed *create_review(string str) {
  string *bits, rest;
  int i, bing, width, tmp;
  mixed *ret;
  bits = explode("$"+str, "%");
  bits[0] = bits[0][1..];
  if (!strlen(bits[0]))
    ret = ({ });
  else
    ret = ({ STRING, bits[0] });
  for (i=1;i<sizeof(bits);i++) {
    bing = RIGHT;
    rest = bits[i];
    if (rest[0] == '|') {
      bing = CENTER;
      rest = rest[1..];
    } else if (rest[0] == '-') {
      bing = 0;
      rest = rest[1..];
    }
    if (sscanf(rest, "%d%s", width, rest) == 2) {
      tmp = member_array(rest[0..0], abbrev);
      if (tmp == -1) {
        write("Unknown thingy '"+rest[0..0]+"'\n");
        return 0;
      }
      ret += ({ tmp+bing, width });
      rest = rest[1..];
      if (strlen(rest))
        ret += ({ STRING, rest });
    } else {
      ret += ({ STRING, bits[i] });
    }
  }
  return ret;
}
private void list_matches() {
  int i;
  for (i=0;i<sizeof(de_names);i++) {
    if (i == STRING) continue;
    printf("%s: %s\n", abbrev[i], de_names[i]);
  }
}
int set_var(string str) {
  string name, type;
  mixed *bing;
  if (str == "help") {
    write("The non helpful help.\nThis is the list of things that go after "+
          "the %'s in the value.\n");
    list_matches();
    return 1;
  }
  if (!str || sscanf(str, "%s %s", name, type) != 2) {
    notify_fail("Syntax: "+query_verb()+" <var_name> <value>\n"+
                "        "+query_verb()+" help\n");
    return 0;
  }
  if (member_array(name, var_names) == -1) {
    notify_fail("You cannot set the var "+name+", it has to be one of "+
                implode(var_names[0..<2], ", ")+" or " + var_names[<1] +
                ".\n");
    return 0;
  }
  bing = create_review(type);
  if (!bing)
    return 1;
  this_player( 1 )->add_property( name +" list", bing );
  write("Ok, set var "+name+" to "+type+".\n");
  return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/cpi_handler.c ===
#define RESTORE_PATH "/save/cpi_indices/"
#define STOCK_EXCHANGE find_object( "/d/am/am/gomerchants" )
inherit "/std/object";
string material_name;
mapping prices;
void setup() {
  set_name( "board" );
  set_short( "price board" );
  set_long( "This is a large board with many small, wooden flaps attached "+
            "to it.  Painted onto the flaps are numbers and letters, and "+
            "the display is occasionally changed by means of a small imp "+
            "that seems to live inside somewhere.  The board lists the "+
            "purchasing prices of almost everything from gold and silk "+
            "to beef and chicken livers at various places where the "+
            "Merchants' Guild does business.\n" );
  add_adjective( "price" );
  set_main_plural( "price boards" );
  add_plural( "boards" );
  reset_get();
}
int look_up(string);
void init() {
  add_command("find", "<word'thing'>", (:look_up($4[0]):));
}
void imp_effect( string phrase ) {
  tell_room( STOCK_EXCHANGE, "A tiny door opens in the board, a warty imp "+
            "climbs out, clambers across the surface and "+ phrase +
            ".  The imp scowls a bit for the look of the thing, and then "+
            "disappears back inside the board.\n" );
}
void init_data( string word ) {
  material_name = word;
  prices = ([ ]);
}
int get_data_file( string word ) {
  if ( material_name != word ) {
    if ( file_size( RESTORE_PATH + word +".o" ) > 0 )
      unguarded((: restore_object, RESTORE_PATH + word :));
    else {
      init_data( word );
      return 0;
    }
  }
  return 1;
}
void save_data_file( string word ) {
  unguarded((: save_object, RESTORE_PATH + word :));
}
int query_price( string word1, string word2 ) {
   if ( !stringp( word1 ) )
      return 0;
   get_data_file( word1 );
   if ( !prices )
      return 0;
   return prices[ word2 ];
}
int add_price( string word1, string word2, int number ) {
  get_data_file( word1 );
  if ( prices[word2] != 0 ) return 0;
  prices += ([ word2 : number ]);
  imp_effect( "adds the price of "+ word1 +" in "+ word2 +" to the lists" );
  save_data_file( material_name );
  return 1;
}
int modify_price( string word1, string word2, int number ) {
  get_data_file( word1 );
  if ( prices[word2] == 0 ) return 0;
  prices[word2] = number;
  imp_effect( "updates the price of "+ word1 +" in "+ word2 );
  save_data_file( material_name );
  return 1;
}
int remove_price( string word1, string word2 ) {
  get_data_file( word1 );
  if ( prices[word2] == 0 ) return 0;
  prices = m_delete( prices, word2 );
  imp_effect( "removes the price of "+ word1 +" in "+ word2 +
              " from the lists" );
  save_data_file( material_name );
  return 1;
}
int look_up( string word ) {
  int i;
  get_data_file( word );
  if ( !m_sizeof( prices ) ) {
    notify_fail( "You can't find any prices for "+ word +" on the board.\n" );
    return 0;
  }
  if ( m_sizeof( prices ) == 1 ) {
    write( "The only price on the board for "+ word +" is "+
              m_values( prices )[0] +" in "+ m_indices( prices )[0] +".\n" );
  } else {
    write( "You find the following price list for "+ word +":\n\n" );
    for ( i = 1; i < m_sizeof( prices ); i++ ) {
      printf( "%6-s %7d %4|s %40-s \n", "", m_values( prices )[i], "in",
                m_indices( prices )[i] +"," );
    }
    printf( "%6-s %7d %4|s %40-s \n", "  and ", m_values( prices )[0], "in",
              m_indices( prices )[0] +"." );
  }
  return 1;
}
string *query_available_datatypes()
{
  return get_dir(RESTORE_PATH);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/taskmaster.c ===
#include <tasks.h>
#define TIME_PER_USER 1800
#define SAVE_FILES "/save/tasks/"
#define LOG_STATS 2
#undef LOGGING
mapping stats;
nosave int last_save;
nosave int last;
nosave string skill;
nosave mixed *control;
nosave int * critical_chances;
varargs mixed perform_task( object person, string skill, int difficulty,
                         int tm_type, int degree );
varargs mixed attempt_task( int difficulty, int bonus, int upper,
                            mixed extra, int degree );
varargs mixed attempt_task_e( int difficulty, int bonus, int upper,
                              int half, int degree );
int is_critical( int margin );
void create() {
   float a, b;
   seteuid( "Root" );
   critical_chances = allocate(100);
   a = 0.93260;
   b = 0.06978;
   for( int i = 0; i < 100; i++ ) {
      critical_chances[i] = a * exp( b * ( i + 1 ) );
   }
}
mapping query_stats( string s_name ) {
  if ( skill != s_name ) {
    skill = s_name;
    if ( file_size( SAVE_FILES + skill +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILES + skill :) );
    else
      stats = 0;
  }
  if ( !stats )
    stats = ([ ]);
  return copy( stats );
}
int query_last() { return last; }
mixed *query_control() { return control; }
void set_control( mixed *args ) { control = args; }
void reset_control() { control = 0; }
void award_made( string p_name, string o_name, string s_name, int level ) {
  user_event( "inform", p_name +" gains a level in "+ s_name +" from "+
              o_name + " at level " + level, "skill" );
#ifdef LOG_STATS
#if LOG_STATS == 1
  query_stats( s_name );
  if ( !stats[ level ] )
    stats[ level ] = ([ ]);
  stats[ level ][ explode( o_name, "#" )[ 0 ] ]++;
#else
  query_stats("summary");
  if(s_name[<7..] == ".points" || s_name[0..13] == "other.language")
    return;
  s_name = explode(s_name, ".")[0];
  if(!stats[s_name])
    stats[s_name] = ({ ({ 0 , 0 }),  ({ 0, 0 }),  ({ 0, 0 }) , ({0,0})});
  switch(level) {
  case 0..149:
    stats[s_name][0] = ({ stats[s_name][0][0], stats[s_name][0][1]+1 });
    break;
  case 150..299:
    stats[s_name][1] = ({ stats[s_name][1][0], stats[s_name][1][1]+1 });
    break;
  case 300..599:
    stats[s_name][2] = ({ stats[s_name][2][0], stats[s_name][2][1]+1 });
    break;
  default:
    stats[s_name][3] = ({ stats[s_name][3][0], stats[s_name][3][1]+1 });
    break;
  }
  if(last_save < time() - 300) {
    unguarded( (: save_object, SAVE_FILES + "summary" :) );
    last_save = time();
  }
#endif
#endif
}
#if LOG_STATS == 2
void skill_checked(string s_name, int level) {
  query_stats("summary");
  if(s_name[<7..] == ".points" || s_name[0..13] == "other.language")
    return;
  s_name = explode(s_name, ".")[0];
  if(!stats[s_name])
    stats[s_name] = ({ ({0,0}), ({0,0}), ({0,0}), ({0,0}), ({0,0}) });
  switch(level) {
  case 0..49:
    stats[s_name][0] = ({ stats[s_name][0][0]+1, stats[s_name][0][1] });
    break;
  case 50..149:
    stats[s_name][1] = ({ stats[s_name][1][0]+1, stats[s_name][1][1] });
    break;
  case 150..299:
    stats[s_name][2] = ({ stats[s_name][2][0]+1, stats[s_name][2][1] });
    break;
  case 300..599:
    stats[s_name][3] = ({ stats[s_name][3][0]+1, stats[s_name][3][1] });
    break;
  default:
    stats[s_name][4] = ({ stats[s_name][4][0]+1, stats[s_name][4][1] });
    break;
  }
  if(last_save < time() - 300) {
    unguarded( (: save_object, SAVE_FILES + "summary" :) );
    last_save = time();
  }
}
#endif
string *query_skill_files() {
  return unguarded( (: get_dir, SAVE_FILES +"*.o" :) );
}
void clear_skill_files() {
  string word;
  foreach ( word in unguarded( (: get_dir, SAVE_FILES +"*.o" :) ) )
    unguarded( (: rm, SAVE_FILES + word :) );
  skill = 0;
}
varargs mixed compare_skills( object offob, string offskill,
                              object defob, string defskill,
                              int modifier, int off_tm_type,
                              int def_tm_type, int degree )
{
  int offbonus, defbonus;
  int perc, chance;
  int success_margin, res, deg;
  if( !offob || !defob || !offskill || !defskill )
    return BARF;
  offbonus = offob->query_skill_bonus(offskill);
  defbonus = defob->query_skill_bonus(defskill);
  if( !defbonus ) {
    defbonus = 1;
  }
  if( !offbonus ) {
    offbonus = 1;
  }
  (offbonus > defbonus) ?
    perc = (50 * offbonus * offbonus) / (offbonus * defbonus) :
    perc = 100 - (50 * defbonus * defbonus) / (offbonus * defbonus);
  perc += modifier;
  if(perc > 99)
    perc = 99;
  if(perc < 1)
    perc = 1;
  chance = random(100);
  success_margin = perc - chance;
  if( success_margin > 0 ) {
    switch( perform_task( offob, offskill, defbonus-modifier,
                          off_tm_type, 0 ) )
    {
    case AWARD:
      res = OFFAWARD;
      break;
    default:
      res = OFFWIN;
    }
    if( degree ) {
      if( is_critical(success_margin) ) {
        deg = TASKER_CRITICAL;
      } else {
         if( success_margin < TASKER_MARGINAL_UPPER ) {
           deg = TASKER_MARGINAL;
         } else if( success_margin < TASKER_NORMAL_UPPER ) {
           deg = TASKER_NORMAL;
         } else {
           deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
    } else {
      return res;
    }
  } else {
    switch( perform_task( defob, defskill, offbonus-modifier,
                          def_tm_type, 0 ) ) {
    case AWARD:
      res = DEFAWARD;
      break;
    default:
      res = DEFWIN;
    }
    if( degree ) {
      if( is_critical(success_margin) ) {
        deg = TASKER_CRITICAL;
      } else {
         if( -success_margin < TASKER_MARGINAL_UPPER ) {
           deg = TASKER_MARGINAL;
         } else if( -success_margin < TASKER_NORMAL_UPPER ) {
           deg = TASKER_NORMAL;
         } else {
           deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
    } else {
      return res;
    }
  }
}
varargs mixed perform_task( object person, string skill, int difficulty,
                            int tm_type, int degree ) {
  mixed result;
  int bonus, upper;
  if( !person || !skill )
    return BARF;
  bonus = person->query_skill_bonus( skill );
  switch(tm_type) {
  case TM_FIXED:
    result = attempt_task( difficulty, bonus, 100, 0, degree );
    break;
  case TM_FREE:
    result = attempt_task( difficulty, bonus, 25, 0, degree );
    break;
  case TM_CONTINUOUS:
    result = attempt_task( difficulty, bonus, 50, 0, degree );
    break;
  case TM_COMMAND:
    if( explode( skill, "." )[0] == "covert" )
      result = attempt_task_e
  ( difficulty, bonus, 60, 40, degree );
    else
      result = attempt_task( difficulty, bonus, 100, 0, degree );
    break;
  case TM_RITUAL:
    result = attempt_task_e( difficulty, bonus, 50, 25, degree );
    break;
  case TM_SPELL:
    result = attempt_task_e( difficulty, bonus, 60, 40, degree );
    break;
  case TM_NONE:
    result = attempt_task_e(difficulty, bonus, 1, 0, degree);
    if(classp(result) && ( (class tasker_result)result )->result == AWARD) {
      result->result = SUCCEED;
    } else if( result == AWARD ) {
      result = SUCCEED;
    }
    break;
  default:
#ifdef LOGGING
    if(file_name(previous_object())[0..2] != "/w/")
      log_file("ATTEMPT_TASK",
               "%s Object %s using old perform_task [%d, %d]\n",
               ctime(time()), base_name(previous_object()), tm_type, degree );
#endif
    upper = tm_type;
    if ( !upper )
      upper = 100;
    result = attempt_task( difficulty, bonus, upper, 0, degree );
  }
  if(classp(result) && ( (class tasker_result)result )->result == AWARD ||
     result == AWARD) {
    if(person->advancement_restriction() ||
       !person->add_skill_level(skill, 1, previous_object())) {
      if(classp(result))
        result->result = SUCCEED;
      else
        result = SUCCEED;
    }
  }
  return result;
}
varargs mixed attempt_task( int difficulty, int bonus, int upper,
                            mixed extra, int degree )
{
   int margin, success_margin, deg, res;
   float tmp;
#ifdef LOGGING
   if( call_stack(2)[1] != "perform_task" &&
       base_name( previous_object() ) != "/std/effects/fighting/combat" &&
       file_name( previous_object() )[0..2] != "/w/" )
   {
     log_file("ATTEMPT_TASK", "%s Object %s is using old attempt_task "
              "[%O]\n",
              ctime( time() ), base_name( previous_object() ), call_stack(2) );
   }
#endif
#if LOG_STATS == 2
   if(pointerp(control) && control[1]) {
      skill_checked(control[1], control[0]->query_skill(control[1]));
   }
#endif
   if ( bonus < difficulty ) {
#ifdef DEBUG
      if(pointerp(control) && control[0]->query_name() == WATCH_PLAYER &&
         find_player(DEBUG))
      {
         tell_creator( DEBUG, "%^RED%^"
           + sprintf( "TM: %s Skill: %s [%d] [%d] Failed\n",
                      control[0]->query_name(), control[1], bonus, difficulty )
           + "%^RESET%^" );
      }
#endif
      if( degree ) {
         return new( class tasker_result,
                     result : FAIL,
                     degree : ( is_critical( -100 ) ?
                                TASKER_CRITICAL :
                                TASKER_EXCEPTIONAL ),
                     raw    : -100 );
      } else {
         return FAIL;
      }
   }
   if ( !extra )
      margin = 3 * sqrt( difficulty );
   else {
      if ( intp( extra ) )
         margin = extra;
      if ( pointerp( extra ) )
         margin = extra[ 0 ] + extra[ 1 ] * sqrt( difficulty );
   }
   if ( !margin )
      return BARF;
   if ( bonus > difficulty + margin ) {
#ifdef DEBUG
     if(pointerp(control) &&
        WATCH_PLAYER || control[0]->query_name() == WATCH_PLAYER &&
        find_player(DEBUG))
       tell_object(find_player(DEBUG), "%^RED%^" + sprintf("TM: %s Skill: %s [%d] [%d] [%d] Succeeded\n", control[0]->query_name(), control[1], bonus, difficulty, margin) + "%^RESET%^");
#endif
      if( degree ) {
         return new( class tasker_result,
                     result : SUCCEED,
                     degree : ( is_critical(100) ?
                                TASKER_CRITICAL :
                                TASKER_EXCEPTIONAL ),
                     raw    : 100 );
      } else {
         return SUCCEED;
      }
   }
   if(!margin)
     margin = 1;
   success_margin = ( ( 100 * ( bonus - difficulty ) ) / margin ) - random(100);
   if ( success_margin <= 0 ) {
#ifdef DEBUG
     if(pointerp(control) &&
        control[0]->query_name() == WATCH_PLAYER &&
        find_player(DEBUG))
       tell_object(find_player(DEBUG), "%^RED%^" + sprintf("TM: %s Skill: %s [%d] [%d] Failed (2)\n", control[0]->query_name(), control[1], bonus, difficulty) + "%^RESET%^");
#endif
      if( degree ) {
         if( is_critical(success_margin) ) {
            deg = TASKER_CRITICAL;
         } else {
            if( -success_margin < TASKER_MARGINAL_UPPER ) {
               deg = TASKER_MARGINAL;
            } else if( -success_margin < TASKER_NORMAL_UPPER ) {
               deg = TASKER_NORMAL;
            } else {
               deg = TASKER_EXCEPTIONAL;
            }
         }
         return new( class tasker_result,
                     result : FAIL,
                     degree : deg,
                     raw    : success_margin );
      } else {
         return FAIL;
      }
   }
   if ( pointerp( control ) ) {
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), "%^RED%^" +
                   sprintf("TM: %s Skill: %s [%d,%d] OU: %d ",
                           control[0]->query_name(),
                           control[1], bonus,
                           control[0]->query_skill(control[1]),
                           upper));
#endif
     upper = (int)control[ 0 ]->stat_modify(upper, control[ 1 ] );
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG),
                   sprintf("SU: %d ", upper));
#endif
     tmp = exp((control[0]->query_skill(control[1])-BASE) / DECAY);
     upper = to_int(upper / tmp) - MODIFIER;
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("LU: %d ", upper));
#endif
     if(upper < 0)
       upper = 0;
#ifdef DEBUG
      if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("FU: %d\n",
                                                 upper) + "%^RESET%^");
#endif
   }
#ifdef DEBUG
   else
     if(find_player(DEBUG))
       tell_object(find_player(DEBUG), sprintf("No control: %O\n",
                                                 previous_object(-1)));
#endif
     if(!margin)
        margin = 1;
   if( random(100) < ( upper * ( difficulty + margin - bonus ) ) / margin )
      res = AWARD;
   else
      res = SUCCEED;
   if( degree ) {
      if( is_critical(success_margin) ) {
         deg = TASKER_CRITICAL;
      } else {
         if( success_margin < TASKER_MARGINAL_UPPER ) {
            deg = TASKER_MARGINAL;
         } else if( success_margin < TASKER_NORMAL_UPPER ) {
            deg = TASKER_NORMAL;
         } else {
            deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
   } else {
      return res;
   }
}
varargs mixed attempt_task_e( int difficulty, int bonus, int upper,
                              int half, int degree )
{
   float fail_chance;
   float tmp;
   int success_margin, deg, res;
#ifdef LOGGING
   if(call_stack(2)[1] != "perform_task" &&
      base_name(previous_object()) != "/std/effects/fighting/combat" &&
      file_name(previous_object())[0..2] != "/w/") {
     log_file("ATTEMPT_TASK", "%s Object %s is using old attempt_task "
              "[%O]\n",
              ctime(time()), base_name(previous_object()), call_stack(2));
   }
#endif
#if LOG_STATS == 2
   if(pointerp(control) && control[1]) {
     skill_checked(control[1], control[0]->query_skill(control[1]));
   }
#endif
   if ( bonus < difficulty ) {
      if( degree ) {
         return new( class tasker_result,
                     result : FAIL,
                     degree : ( is_critical( -100 ) ?
                                TASKER_CRITICAL :
                                TASKER_EXCEPTIONAL ),
                     raw    : -100 );
      } else {
         return FAIL;
      }
   }
   if( !half )
      half = 6 * sqrt( difficulty );
   if( !half )
      half = 1;
   fail_chance = exp( ( -0.693 * ( bonus - difficulty ) ) / half );
   success_margin = ( random( 1000 ) - ( 1000 * fail_chance ) ) / 10;
   if ( success_margin < 0 ) {
      if( degree ) {
         if( is_critical(success_margin) ) {
            deg = TASKER_CRITICAL;
         } else {
            if( -success_margin < TASKER_MARGINAL_UPPER ) {
               deg = TASKER_MARGINAL;
            } else if( -success_margin < TASKER_NORMAL_UPPER ) {
               deg = TASKER_NORMAL;
            } else {
               deg = TASKER_EXCEPTIONAL;
            }
         }
         return new( class tasker_result,
                     result : FAIL,
                     degree : deg,
                     raw    : success_margin );
      } else {
         return FAIL;
      }
   }
   if ( pointerp( control ) ) {
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), "%^RED%^" +
                   sprintf("TM: %s Skill: %s [%d,%d] OU: %d ",
                           control[0]->query_name(),
                           control[1], bonus,
                           control[0]->query_skill(control[1]),
                           upper));
#endif
     upper = (int)control[ 0 ]->stat_modify( upper, control[ 1 ] );
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG),
                   sprintf("SU: %d ", upper));
#endif
     tmp = exp((control[0]->query_skill(control[1])-BASE) / DECAY);
     upper = to_int(upper / tmp) - E_MODIFIER;
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("LU: %d ", upper));
#endif
     if(upper < 0)
       upper = 0;
#ifdef DEBUG
      if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("FU: %d\n",
                                                 upper) + "%^RESET%^");
#endif
   }
   if ( random(1000) < ( upper * fail_chance * 10 )
    &&  bonus < difficulty + ( half * 5 ) ) {
      res = AWARD;
   } else {
      res = SUCCEED;
   }
   if( degree ) {
      if( is_critical(success_margin) ) {
         deg = TASKER_CRITICAL;
      } else {
         if( success_margin < TASKER_MARGINAL_UPPER ) {
            deg = TASKER_MARGINAL;
         } else if( success_margin < TASKER_NORMAL_UPPER ) {
            deg = TASKER_NORMAL;
         } else {
            deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
   } else {
      return res;
   }
}
int is_critical( int margin ) {
   if ( margin < 0 ) {
      margin *= -1;
   }
   if ( margin > 100 ) {
      margin = 100;
   }
   if ( margin == 0 ) {
      return 0;
   }
   return random(10000) < critical_chances[ margin - 1 ];
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/mime.c ===
#include <mime.h>
#define HEADER_NAME 1
#define HEADER_VAL  2
#define MUDMAIL     3
#define TOK_QP      4
#define TOK_QUOTE   5
#define TOK_OP      6
#define TOK_CP      7
#define TOK_LT      8
#define TOK_GT      9
#define TOK_SEP     10
#define TOK_AMP     11
#define SPECIAL     12
#define LWS         13
#define ATOM        14
#define COMMENT     15
#define EMAIL       16
#define QUOTE       17
private mixed *tokenize(string header_field) {
  int i, quoted, paren_count, angle_count;
  int *tokens, state;
  mixed *bits;
  bits = reg_assoc(header_field,
                   ({ "\\\\.", "\"", "\\(", "\\)", "<", ">",
                      ",", "@",
                      "[]()<>@,;:\\\\\".[]",
                      "(\n?[ \t])+",
                      "[!#-'*+/-9=?A-Z^-~-]+" }),
                   ({ TOK_QP, TOK_QUOTE, TOK_OP, TOK_CP, TOK_LT, TOK_GT,
                      TOK_SEP, TOK_AMP, SPECIAL, LWS, ATOM }));
  tokens = ({ 0 });
  for (i = 1; i < sizeof(bits[0]); i += 2) {
    switch(bits[1][i]) {
    case LWS:
      if (quoted) {
        tokens += ({ state, 0 });
      } else {
        tokens += ({ 0, 0 });
      }
      break;
    case TOK_QUOTE:
      quoted = !quoted;
      if (!state && quoted) {
        state = QUOTE;
      }
      tokens += ({ state, 0 });
      if (state == QUOTE && !quoted) {
        state = 0;
      }
      break;
    case TOK_OP:
      if (!quoted) {
        paren_count++;
        state = COMMENT;
      }
      tokens += ({ state, 0 });
      break;
    case TOK_CP:
      if (!quoted) {
        paren_count--;
        if (paren_count < 0) {
          printf("Unbalanced ')'\n");
          return ({ });
        }
      }
      tokens += ({ state, 0 });
      if (!paren_count) {
        state = 0;
      }
      break;
    case TOK_LT:
      tokens += ({ state, 0 });
      if (!(quoted || paren_count)) {
        angle_count++;
        state = EMAIL;
      }
      break;
    case TOK_GT:
      if (!(quoted || paren_count)) {
        angle_count--;
        if (angle_count != 0) {
          printf("Unbalanced '%c'\n", (angle_count < 0?'>':'<'));
          return ({ });
        }
        state = 0;
      }
      tokens += ({ state, 0 });
      break;
    default:
      if (!state) {
        tokens += ({ bits[1][i], 0 });
      } else {
        tokens += ({ state, 0 });
      }
      break;
    }
    if (paren_count < 0) {
      printf("Unbalanced ')'\n");
      return ({ });
    }
  }
  if (paren_count != 0) {
    printf("Unbalanced '%c'\n", (paren_count < 0?')':'('));
    return ({ });
  }
  bits += ({ tokens });
  return bits;
}
mixed *get_email_addrs(string arg) {
  string *addrs, *full_addrs;
  int i, idx, state;
  mixed *bits;
  if (!arg) {
    return ({ ({ }), ({ }) });
  }
  bits = tokenize(arg);
  if (!sizeof(bits)) {
    return ({ ({ }), ({ }) });
  }
  addrs = allocate(1);
  addrs[0] = "";
  full_addrs = allocate(1);
  full_addrs[0] = "";
  idx = 0;
  for (i = 1; i < sizeof(bits[2]); i += 2) {
    switch (bits[2][i]) {
    case TOK_SEP:
      idx++;
      addrs += ({ "" });
      full_addrs += ({ "" });
      break;
    case EMAIL:
      if (state != EMAIL) {
        addrs[idx] = bits[0][i];
        state = EMAIL;
      } else {
        addrs[idx] += bits[0][i];
      }
      full_addrs[idx] += bits[0][i];
      break;
    case COMMENT:
    case LWS:
    case 0:
      full_addrs[idx] += bits[0][i];
      break;
    default:
      addrs[idx] += bits[0][i];
      full_addrs[idx] += bits[0][i];
      break;
    }
  }
  return ({ addrs, full_addrs });
}
string rewrite_field(string header_field) {
  int i, idx, state;
  mixed *bits, *addrs, *indices;
  if (!header_field) {
    return "";
  }
  bits = tokenize(header_field);
  if (!sizeof(bits)) {
    return "";
  }
  addrs = allocate(1);
  addrs[0] = ({ });
  indices = allocate(1);
  indices[0] = ({ });
  idx = 0;
  for (i = 1; i < sizeof(bits[2]); i += 2) {
    switch (bits[2][i]) {
    case TOK_SEP:
      if (sizeof(addrs[idx]) && member_array(TOK_AMP, addrs[idx]) == -1) {
        if (bits[0][indices[idx][<1]] == "discworld") {
          bits[0][indices[idx][<1]] += "@discworld.imaginary.com";
        } else {
          bits[0][indices[idx][<1]] += ".discworld@discworld.imaginary.com";
        }
      }
      idx++;
      addrs += ({ ({ }) });
      indices += ({ ({ }) });
      break;
    case EMAIL:
      if (state != EMAIL) {
        addrs[idx] = ({ bits[1][i] });
        indices[idx] = ({ i });
        state = EMAIL;
      } else {
        addrs[idx] += ({ bits[1][i] });
        indices[idx] += ({ i });
      }
      break;
    case COMMENT:
    case LWS:
    case 0:
      break;
    default:
      addrs[idx] += ({ bits[1][i] });
      indices[idx] += ({ i });
      break;
    }
  }
  if (sizeof(addrs[<1]) && member_array(TOK_AMP, addrs[<1]) == -1) {
    if (bits[0][indices[<1][<1]] == "discworld") {
      bits[0][indices[<1][<1]] += "@discworld.imaginary.com";
    } else {
      bits[0][indices[<1][<1]] += ".discworld@discworld.imaginary.com";
    }
  }
  return implode(bits[0], "");
}
class mime_header parse_headers(string message) {
  string *bits, bit, cont, headers;
  int idx, len;
  class mime_header hdr;
  if ((idx = strsrch(message, "\n\n")) == -1) {
    return hdr;
  }
  headers = message[0..idx];
  hdr = new(class mime_header, header_m : ([]), header_k : ({}));
  bits = explode(headers, "\n") - ({ "", 0 });
  foreach (bit in bits[1..]) {
    if (cont && ((bit[0] == ' ') || (bit[0] == '\t'))) {
      hdr->header_m[cont] += "\n" + bit[1..];
      continue;
    }
    len = strlen(bit);
    if ((idx = strsrch(bit, ':')) == -1) {
      continue;
    }
    cont = bit[0..idx-1];
    if (undefinedp(hdr->header_m[lower_case(cont)])) {
      hdr->header_k += ({ cont });
    }
    cont = lower_case(cont);
    ++idx;
    while ((idx < len) && isspace(bit[idx])) {
      ++idx;
    }
    if (undefinedp(hdr->header_m[cont])) {
      hdr->header_m[cont] = bit[idx..];
    } else {
      hdr->header_m[cont] += sprintf(", %s", bit[idx..]);
    }
  }
  return hdr;
}
string rewrite_header(string message) {
  mixed *ra;
  int i;
  string header, field;
  if ((i = strsrch(message, "\n")) == -1) {
    return message;
  }
  message = message[i+1..];
  if ((i = strsrch(message, "\n\n")) == -1) {
    return message;
  }
  header = message[0..i];
  message = message[i+1..];
  ra = reg_assoc(header,
                 ({ "^[!-9;-~]+:", "((\n?[ \t])+[^\n]*(\n|$))+" }),
                 ({ HEADER_NAME, HEADER_VAL }));
  for (i = 1; i + 2 < sizeof(ra[0]); i += 2) {
    if (ra[1][i] == HEADER_NAME && ra[1][i+2] == HEADER_VAL) {
      switch(lower_case(ra[0][i])) {
      case "to:":
      case "from:":
      case "cc:":
      case "bcc:":
      case "reply-to:":
        field = rewrite_field(ra[0][i+2]);
        if (field != "") {
          ra[0][i+2] = field;
        }
        break;
      default:
        break;
      }
    }
  }
  return implode(ra[0], "") + message;
}
void dest_me() {
  destruct(this_object());
}
int cleanup(int inherited) {
  if (!inherited) {
    dest_me();
  }
  return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/newbiehelpers.c ===
#include <playerinfo.h>
#include <player_handler.h>
#include <mail.h>
#define PI_TYPE "misc"
#define SAVE_FILE "/save/newbiehelpers"
#define TO this_object()
#define TP this_player()
private mapping admin;
private mapping helpers;
private mapping applicants;
private int minimum_apply_age, minimum_vouch_age;
protected void log_message( string message );
protected void load_file();
protected void save_file();
void create() {
    admin = ([ ]);
    helpers = ([ ]);
    applicants = ([ ]);
    minimum_apply_age = 0;
    minimum_vouch_age = 0;
    load_file();
}
string query_list( object lister ) {
    string list_mess, person;
    if( !sizeof( admin ) ) {
        list_mess = "There are no newbie helpers admin at present.\n";
    }
    else {
        list_mess = "Current newbie helpers admin:\n";
        foreach( person in keys(admin) ) {
            list_mess += "    $C$" + person + "\n";
        }
    }
    list_mess += "\n";
    if( !sizeof( helpers ) ) {
        list_mess += "There are no newbie helpers at present.\n";
    }
    else {
        list_mess += "Current newbie helpers:\n";
        foreach( person in keys(helpers) ) {
            list_mess += "    $C$" + person + "\n";
        }
    }
    if( admin[lister->query_name()] ) {
        list_mess += "\n";
        if( !sizeof( applicants ) ) {
            list_mess += "There are no outstanding newbie helper "
                "applications at present.\n";
        }
        else {
            list_mess += "Current applications to newbie helpers:\n";
            foreach( person in keys(applicants) ) {
                list_mess += "    $C$" + person + "\n";
            }
        }
    }
    return list_mess;
}
private string helper_info( string name, object tp ) {
    string helper_mess, *vouches;
    helper_mess = "Details for $C$" + name + ":\n";
    helper_mess += "    Hired by $C$" + helpers[name]["employer"] +
        ", " + ctime(helpers[name]["time"]) + ".\n";
    if( helpers[name] ) {
        vouches = helpers[name]["vouches"];
        if( !vouches || !sizeof(vouches) ) {
            helper_mess += "    No vouches.\n";
        }
        else {
            helper_mess += "    Vouches were: " +
                query_multiple_short( map( vouches, (: "$C$" + $1 :) ) ) +
                ".\n";
        }
        if( !helpers[name]["guild"] || helpers[name]["guild"] == "unknown" ) {
            helper_mess += "    Guild: Unknown.\n";
        }
        else {
            helper_mess += "    Guild: " + helpers[name]["guild"] +
                ".\n";
        }
        if( !helpers[name]["nationality"] ||
            helpers[name]["nationality"] == "unknown" ) {
            helper_mess += "    Nationality: Unknown.\n";
        }
        else {
            helper_mess += "    Nationality: " + helpers[name]["nationality"]
                + ".\n";
        }
    }
    if( admin[name] ) {
        helper_mess += "    $C$" + name + " is a newbie helpers admin.\n";
    }
    return helper_mess;
}
private string applicant_info( string name, object tp ) {
    string app_mess, voucher;
    mapping vouches;
    app_mess = "Details for $C$" + name + ":\n";
    app_mess += "    Applied: " +
        ctime(applicants[name]["time"]) + ".\n";
    app_mess += "    Age: " + query_time_string(applicants[name]["age"],-1) +
        ".\n";
    app_mess += "    Guild: " + applicants[name]["guild"] + ".\n";
    app_mess += "    Nationality: " + applicants[name]["nationality"] + ".\n";
    vouches = applicants[name]["vouches"];
    if( !vouches || !sizeof(vouches) ) {
        app_mess += "    No vouches.\n";
    }
    else {
        app_mess += "    Vouches:\n";
        foreach( voucher in keys(vouches) ) {
            app_mess += "        $C$" + voucher + " (" +
                query_time_string(
                    applicants[name]["vouches"][voucher]["age"], -1
                ) + " old)\n";
        }
    }
    app_mess += "\n";
    app_mess += "    $C$" + name + "'s application:$I$8=\n\n";
    app_mess += applicants[name]["statement"] + "$I$0=\n\n";
    if( !vouches || !sizeof(vouches) ) {
        app_mess += "    No vouches.\n";
    }
    else {
        foreach( voucher in keys(vouches) ) {
            app_mess += "    Vouch by $C$" + voucher + " made " +
                ctime(applicants[name]["vouches"][voucher]["time"]) +
                ":$I$8=\n\n";
            app_mess += applicants[name]["vouches"][voucher]["statement"] +
                "$I$0=\n\n";
        }
    }
    if( admin[name] ) {
        app_mess += "    $C$" + name + " is a newbie helpers admin.\n";
    }
    return app_mess;
}
string query_check_player( object checker, string player ) {
    if( !helpers[player] && !admin[player] && !applicants[player] ) {
        return "$C$" + player + " is not registered with the newbie "
            "helpers handler.\n";
    }
    if( !admin[checker->query_name()] ) {
        return "You are not a member of newbiehelpers admin.\n";
    }
    TP->add_succeeded_mess(TO, "", ({ }) );
    if( helpers[player] ) {
        return helper_info( player, TP );
    }
    if( applicants[player] ) {
        return applicant_info( player, TP );
    }
    return "$C$" + player + " is just an admin.\n";
}
int add_helper( object adder, string player ) {
    string *player_vouches, player_guild, player_nationality, name;
    name = adder->query_name();
    if( !admin[name] ) {
        tell_object( TP, "You are not a member of newbiehelpers admin.\n" );
        return 0;
    }
    if( !PLAYER_HANDLER->test_user(player) ) {
        tell_object( TP, "There is no player $C$" + player + "!\n" );
        return 0;
    }
    if( helpers[player] ) {
        tell_object( TP, "$C$" + player + " is already a newbie "
            "helper.\n" );
        return 0;
    }
    if( applicants[player] ) {
        player_vouches = keys( applicants[player]["vouches"] );
        player_guild = applicants[player]["guild"];
        player_nationality = applicants[player]["nationality"];
        map_delete( applicants, player );
            AUTO_MAILER->auto_mail(player, name, "Your newbie helpers "
                "application", "", "Hello,\n\nI am pleased to inform you "
                "that your newbie helpers application was successful, and "
                "that you have now been hired as a newbie helper.  This was "
                "an automatic mail.\n\n$C$" + name, 0, 0);
    }
    else {
        player_vouches = ({ });
        player_guild = "unknown";
        player_nationality = "unknown";
    }
    helpers[player] = ([ ]);
    helpers[player]["time"] = time();
    helpers[player]["employer"] = name;
    helpers[player]["vouches"] = player_vouches;
    helpers[player]["guild"] = player_guild;
    helpers[player]["nationality"] = player_nationality;
    save_file();
    log_message( player + " added as a helper by " + name );
    if ( PLAYERINFO_HANDLER->add_entry( this_object(), player, PI_TYPE,
        "Added as a newbiehelper.", 0 ) ) {
        log_message( player + "'s playerinfo updated" );
    }
    else {
        log_message( player + "'s playerinfo NOT updated (an error "
            "occurred)" );
    }
    return 1;
}
string remove_helper( object remover, string player, string reason ) {
    string name;
    name = remover->query_name();
    if( !admin[name] ) {
        tell_object( TP, "You are not a member of newbiehelpers admin.\n" );
        return 0;
    }
    if( !helpers[player] ) {
        return "$C$" + player + " is not a newbie helper.\n";
    }
    map_delete( helpers, player );
    save_file();
    log_message( player + " removed as a helper by " + name + ", reason: " +
        reason );
    if ( PLAYERINFO_HANDLER->add_entry( this_object(), player, PI_TYPE,
        "Removed as a newbiehelper (" + reason + ").", 0 ) ) {
        log_message( player + "'s playerinfo updated" );
    }
    else {
        log_message( player + "'s playerinfo NOT updated (an error "
            "occurred)" );
    }
    return "You remove $C$" + player + "'s helper status.\n";
}
void submit_vouch(string statement, mixed args) {
    string name, player;
    object voucher;
    voucher = args[0];
    player = args[1];
    name = voucher->query_name();
    applicants[player]["vouches"][name] = ([ ]);
    applicants[player]["vouches"][name]["time"] = time();
    applicants[player]["vouches"][name]["age"] = -voucher->query_time_on();
    applicants[player]["vouches"][name]["statement"] = statement;
    save_file();
    log_message( name + " submits a vouch for " + player );
}
string no_vouch_reason( object voucher, string applicant ) {
    string name;
    name = voucher->query_name();
    if( !applicants[applicant] ) {
        return "$C$" + applicant + " isn't applying to be a newbie helper, "
            "so you can't vouch for them.\n";
    }
    if( applicants[applicant]["vouches"][name] ) {
        return "You already have already vouched for $C$" + applicant + " on "
            "this application, you cannot vouch again.\n";
    }
    if( applicant == name ) {
        return "You cannot vouch for yourself!\n";
    }
    if( -voucher->query_time_on() < minimum_vouch_age ) {
        return "You cannot vouch for $C$ " + applicant + " as you are too "
            "young to vouch.  You need to be " +
            query_time_string( minimum_vouch_age, -1 ) + " old before you "
            "can vouch on people's applications to be a newbie helper.\n";
    }
    return 0;
}
void submit_application(string statement, object player) {
    string name;
    name = player->query_name();
    applicants[name] = ([ ]);
    applicants[name]["time"] = time();
    applicants[name]["age"] = -player->query_time_on();
    applicants[name]["statement"] = statement;
    applicants[name]["vouches"] = ([ ]);
    applicants[name]["guild"] =
        (load_object(player->query_guild_ob()))->query_short();
    if( player->query_nationality() ) {
        applicants[name]["nationality"] = "$C$" +
            (load_object(player->query_nationality()))->query_name();
        }
    else {
        applicants[name]["nationality"] = "unknown";
    }
    save_file();
    log_message( name + " submits an application to newbiehelpers" );
}
string no_apply_reason( object player ) {
    string name;
    name = player->query_name();
    if( helpers[name] ) {
        return "You are already a newbie helper, why are you applying "
            "again?\n";
    }
    if( applicants[name] ) {
        return "You already have a newbie helper application open, you "
            "should wait to hear back about it.\n";
    }
    if( -player->query_time_on() < minimum_apply_age ) {
        return "You cannot apply to be a newbie helper as you are too "
            "young.  You need to be " +
            query_time_string( minimum_apply_age, -1 ) + " before you can "
            "apply to be a newbie helper.\n";
    }
    return 0;
}
void reject_application( object rejecter, string player, string reason,
    string mail ) {
    string name;
    name = rejecter->query_name();
    if( !admin[name] ) {
        return;
    }
    if( !applicants[player] ) {
        return;
    }
    AUTO_MAILER->auto_mail(player, name, "Your newbie helpers "
        "application", "", mail, 0, 0);
    map_delete( applicants, player );
    save_file();
    log_message( name + " rejects " + player + "'s application, reason: " +
        reason );
    if ( PLAYERINFO_HANDLER->add_entry( this_object(), player, PI_TYPE,
        "Rejected as a newbiehelper (" + reason + ").", 0 ) ) {
        log_message( player + "'s playerinfo updated" );
    }
    else {
        log_message( player + "'s playerinfo NOT updated (an error "
            "occurred)" );
    }
}
string no_reject_reason( object rejecter, string player ) {
    string name;
    name = rejecter->query_name();
    if( !admin[name] ) {
        return "You are not a member of newbiehelpers admin.\n";
    }
    if( !applicants[player] ) {
        return "$C$" + player + " isn't applying to be a newbie helper, so "
            "you can't reject them.\n";
    }
    return 0;
}
int query_helper( string name ) {
    if( helpers[name] ) {
        return 1;
    }
    else {
        return 0;
    }
}
int add_admin( string name ) {
    if( !admin[TP->query_name()] ) {
        return 0;
    }
    if( !admin[name] ) {
        admin[name] = 1;
        save_file();
        log_message( name + " added as admin by " + TP->query_name() );
        return 1;
    }
    else {
        return 0;
    }
}
int remove_admin( string name ) {
    if( !admin[TP->query_name()] ) {
        return 0;
    }
    if( !admin[name] ) {
        return 0;
    }
    else {
        map_delete(admin, name);
        save_file();
        log_message( name + " removed from admin by " + TP->query_name() );
        return 1;
    }
}
int query_admin( string name ) {
    if( admin[name] ) {
        return 1;
    }
    else {
        return 0;
    }
}
int query_can_chat( object who ) {
    if( query_helper( who->query_name() ) ||
        query_admin( who->query_name() ) ||
        who->query_creator() ) {
        return 1;
    }
    return 0;
}
string query_name() { return "Newbiehelpers Handler"; }
protected void log_message( string message ) {
    log_file("/log/NEWBIEHELPERS", ctime(time()) + ": " + message + "\n");
}
protected void save_file() {
    unguarded( (: save_object, SAVE_FILE, 1 :) );
}
protected void load_file() {
    if (file_size(SAVE_FILE + ".o") > 0)
        unguarded( (: restore_object, SAVE_FILE, 1 :) );
}
