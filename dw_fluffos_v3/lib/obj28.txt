
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/badge.j ===
#include <mail.h>

#define DOMAIN explode( theres[ i ], "/" )[ 1 ]
#define LORD capitalize( (string)( "/d/"+ DOMAIN +"/master" )->query_lord() )
#define MASTER "/secure/master"
#define HANDLER "/obj/handlers/playtesters"

inherit "/obj/armour";

mapping routes;

int access_mail(string str);
int list_destinations();
int list_transits();
int do_goto(string destination);

void setup() {
   set_name( "badge" );
   set_short( "blue badge" );
   add_adjective( "blue" );
   set_long( "This is a small blue badge.  It has a drawing of a womble on "
         "the front; it seems to be using a magnifying glass to examine "
         "something.  On the back is engraved a scroll with some words on "
         "it.\n" );
   setup_armour( 100 );
   set_damage_chance( 0 );
   set_type( "badge" );
   reset_drop();
/*
 * Please make sure that routes are placed correctly.
*  This is a _mapping_ !
*/
   routes = ([
      "/d/am/short/short11" : ({
         "/d/am/undercellar/upper_a",
      }),
      "/d/am/undercellar/upper_a" : ({
         "/d/am/short/short11",
      }),
      "/d/sur/PLAIN/n_caravan/n_cara20" : ({
          "/d/sur/sur-new/Skund/roads/entrance",
      }),
      "/d/sur/PLAIN/s_caravan/s_cara19" : ({
           "/d/sur/sur-new/Skund/roads/s_entrance",
      }),
      "/d/ram/foothills/foothills01" : ({
         "/d/sur/sur-new/Skund/roads/south_rd22",
      }),
      "/d/am/gates/least" : ({
         "/d/sur/sur-new/Sto_Plains/n_caravan/entrance",
      }),
      "/d/am/gates/hubwards" : ({
         "/d/sur/sur-new/Sto_Plains/s_caravan/entrance",
      }),
      "/d/am/am/lower_broadway" : ({
         "/d/sur/sur-new/Holywood/roads/road1",
      }),
      "/d/am/mackerel/alley" : ({
	 "/d/am/mackerel/wrestle/entrance",
      }),
      "/d/guilds/wizards/Ankh-Morpork/inside/stairs_ground" : ({
	 "/d/guilds/wizards/Ankh-Morpork/lecturehalls/lect1a",
      }),
   ]);
   set_read_mess( "This badge allows the bearer to move into certain areas "
         "to be playtested from certain entry locations (near to where the "
         "areas will be eventually connected).  To see the possible "
         "destinations from your current room, use the command "
         "\"destinations\", and to move into one of them, use the command "
         "\"goto <label>\" where <label> will be A, B, C, etc..  You can "
         "get a list of all transit points with \"transits\", although no "
         "guarantee is made that each item on this list will be "
         "recognisable.  Please report any problems with rooms not "
         "loading to the relevant domain Lord or Liaison(s)." );
} /* setup() */

void init() {
   string word;
   if ( !environment() )
      return;
   if ( !living( environment() ) )
      return;
   if ( !environment()->query_creator() ) {
      word = (string)environment()->query_name();
      if ( !HANDLER->query_playtester( word ) ) {
         tell_object( environment(), "You are not a playtester.  "
               "Your blue playtester's badge disappears.\n" );
         set_drop();
         move( "/room/rubbish" );
         return;
      }
      if ( HANDLER->query_senior_playtester( word ) ) {
         add_command( "mail", "", (: access_mail(0) :) );
         add_command( "mail", "<string>", (: access_mail($4[0]) :) );
      }
   }
   add_command("destinations", "", (: list_destinations() :) );
   add_command("transits", "", (: list_transits() :) );
   add_command("goto", "<string>", (: do_goto($4[0]) :) );
/* creator "goto" should take precidence */
} /* init() */

int access_mail( string words ) {
   return (int)MAIL_TRACK->mail( words );
} /* access_mail() */

int list_destinations() {
  int i;
  string here, *theres;
  object there;
  here = file_name( environment( this_player() ) );
  if ( !sizeof ( theres = routes[ here ] ) )
    return notify_fail( "You cannot use the badge to move from here.\n" );
  write( "From here you can use the badge to move to:\n" );
  for ( i = 0; i < sizeof( theres ); i++ ) {
    if ( !( there = find_object( theres[ i ] ) ) ) {
      if ( file_size( theres[ i ] +".c" ) < 0 ) {
/* might need to be check with MASTER using file_exists */
        write( sprintf( "%c: %s cannot be found; please contact %s.\n", 65 + i,
            theres[ i ], LORD ) );
        continue;
      }
      catch( theres[ i ]->force_load() );
      if ( !( there = find_object( theres[ i ] ) ) ) {
        write( sprintf( "%c: %s will not load, please contact %s.\n", 65 + i,
            theres[ i ], LORD ) );
        continue;
      }
    }
    write( sprintf( "%c: %s\n", 65 + i, (string)there->a_short() ) );
  }
  return 1;
} /* list_destinations() */

int list_transits() {
   int i;
   string *theres;
   object there;
   theres = keys( routes );
   if ( !sizeof( theres ) )
      return notify_fail( "There are no transit points at the moment.\n" );
   write( "You can use the badge to move from:\n" );
   for ( i = 0; i < sizeof( theres ); i++ ) {
    if ( !( there = find_object( theres[ i ] ) ) ) {
      if ( file_size( theres[ i ] +".c" ) < 0 ) {
/* might need to be check with MASTER using file_exists */
        write( sprintf( "%s cannot be found; please contact %s.\n",
            theres[ i ], LORD ) );
        continue;
      }
      catch( theres[ i ]->force_load() );
      if ( !( there = find_object( theres[ i ] ) ) ) {
        write( sprintf( "%s will not load, please contact %s.\n",
            theres[ i ], LORD ) );
        continue;
      }
    }
    write( sprintf( "   %s\n", (string)there->a_short() ) );
  }
  return 1;
} /* list_transits() */

int do_goto( string destination ) {
  int i;
  string here, *theres;
  object there;

  i = destination[ 0 ] - 65;
  if ( ( i < 0 ) || ( i > 25 ) ) {
    notify_fail( "The destination label needs to be a capital letter "+
        "between A and Z.\n" );
    return 0;
  }
  here = file_name( environment( this_player() ) );
  if ( !sizeof ( theres = routes[ here ] ) ) {
    notify_fail( "You cannot use the badge to move from here.\n" );
    return 0;
  }
   if ( i >= sizeof( theres ) )
      return notify_fail( "That is not a valid label from here.\n" );   
  if ( !( there = find_object( theres[ i ] ) ) ) {
    if ( file_size( theres[ i ] +".c" ) < 0 ) {
/* might need to be check with MASTER using file_exists */
      write( theres[ i ] +" cannot be found; please contact "+ LORD +".\n" );
      return 1;
    }
    catch( theres[ i ]->force_load() );
    if ( !( there = find_object( theres[ i ] ) ) ) {
      write( theres[ i ] +" will not load; please contact "+ LORD +".\n" );
      return 1;
    }
  }
  write( "Moving you to "+ (string)there->the_short() +"...\n" );
  this_player()->move_with_look( there, "$N appear$s in a gout of green fire.",
      "$N disappear$s in a puff of yellow smoke." );
  return 1;
} /* do_goto() */


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/plate.c ===
inherit "/std/surface";
void init() {
  this_player()->add_command( "eat", this_object(),
    "<indirect:object:direct-obs> {from|on} <direct:object:me>" );
  this_player()->add_command( "eat", this_object(),
    "from <direct:object:me>" );
}
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_long( "This is a nice plate for keeping food on.\n" );
  if ( ! do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
int do_eat( object *obs, string dir, string indir, mixed *args ) {
  object ob;
  object *food;
  if( sizeof( obs ) )
    food = copy( obs );
  else
    food = all_inventory();
  if( sizeof( food ) ) {
    food = filter( food, (: $1->query_edible() :) );
  } else {
    this_player()->add_failed_mess( this_object(),
      "There's nothing on $D\n", ({ }) );
    return 0;
  }
  if( !sizeof( food ) ) {
    if( sizeof( obs ) )
      this_player()->add_failed_mess( this_object(),
        "You can't eat $I on $D!\n", obs );
    else
      this_player()->add_failed_mess( this_object(),
        "There's nothing edible on $D\n", ({ }) );
    return 0;
  }
  foreach( ob in food ) {
    ob->do_eat();
  }
  return 1;
}
mapping query_static_auto_load() {
  return int_query_static_auto_load();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/paper_packet.c ===
inherit "/obj/baggage";
void setup() {
   set_name( "packet" );
   set_short( "waxed paper packet" );
   add_adjective( ({ "waxed", "paper" }) );
   set_main_plural( "waxed paper packets" );
   set_long( "This is a small packet, rather like an envelope, of thick "+
         "paper that has been waxed to make it more resilient.\n" );
   set_weight( 1 );
   set_value( 10 );
   set_max_weight( 3 );
   set_transparent();
   add_property("writeable", 1);
}
int test_add( object thing, int flag ) {
   string word;
   object *things;
   if ( !this_player() )
      return ::test_add( thing, flag );
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return ::test_add( thing, flag );
   word = (string)things[ 0 ]->query_medium_alias();
   if ( word == (string)thing->query_medium_alias() )
      return ::test_add( thing, flag );
   write( "You don't want to contaminate "+ ( stringp( word ) ?
         (string)things[ 0 ]->the_short() :
         (string)thing->the_short() ) +", do you?\n" );
   return 0;
}
object query_substance() {
   object *things;
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return 0;
   if ( !stringp( (string)things[ 0 ]->query_medium_alias() ) )
      return 0;
   return things[ 0 ];
}
string short( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::short( dark );
   return ::short( dark ) +" of "+ (string)thing->short( dark );
}
string query_plural( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::query_plural( dark );
   return ::query_plural( dark ) +" of "+ (string)thing->short( dark );
}
string *parse_command_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_id_list();
   return ::parse_command_id_list() +
         ({ ::short( 0 ) +" of "+ (string)thing->short( 0 ) });
}
string *parse_command_plural_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_plural_id_list();
   return ::parse_command_plural_id_list() +
         ({ ::query_plural( 0 ) +" of "+ (string)thing->short( 0 ) });
}
string *parse_command_adjectiv_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_adjectiv_id_list();
   return ::parse_command_adjectiv_id_list() +
         (string *)thing->parse_command_adjectiv_id_list() +
         (string *)thing->parse_command_id_list();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/golem_toe.c ===
inherit "/std/object";
void setup() {
    set_name( "toe" );
    set_short( "remains of a clay toe" );
    add_adjective( ({"remains", "of", "a", "clay"}) );
    set_long( "This looks part of a toe made of clay.\n" );
    set_main_plural( "remains of clay toes" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
    add_property( "determinate", "the " );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/animusser.c ===
#include <skills.h>
inherit "/std/object";
string *skill_names;
mapping new_skills, old_skills;
void setup() {
   set_name( "lever" );
   set_short( "blue lever" );
   add_adjective( "blue" );
   set_long( "This blue lever is apparently an animus recalculation "+
         "device.  You're not totally sure how you know this, but "+
         "there you are.  You could pull it to have your animus "+
         "recalculated, I suppose.\n" );
   reset_get();
   skill_names = ({ });
   new_skills = ([ ]);
   old_skills = ([ ]);
}
void init() {
   this_player()->add_command( "pull", this_object() );
}
int find_level( string skill ) {
   int i, sublevel, total;
   string *others;
   others = (string *)SKILL_OB->query_immediate_children( skill );
   if ( !sizeof( others ) )
      if ( undefinedp( old_skills[ skill ] ) )
         return (int)this_player()->query_skill( skill );
      else
         return old_skills[ skill ];
   for ( i = 0; i < sizeof( others ); i++ ) {
      sublevel = find_level( others[ i ] );
      total += sublevel;
      new_skills[ others[ i ] ] = sublevel;
      skill_names -= ({ others[ i ] });
   }
   return total / sizeof( others );
}
int do_pull() {
   int i, adjust;
   new_skills = ([ ]);
   old_skills = (mapping)this_player()->query_skills();
   skill_names = m_indices( old_skills );
   while ( sizeof( skill_names ) ) {
      new_skills[ skill_names[ 0 ] ] = find_level( skill_names[ 0 ] );
      skill_names = delete( skill_names, 0, 1 );
   }
   reset_eval_cost();
   skill_names = m_indices( old_skills );
   for ( i = 0; i < sizeof( skill_names ); i++ ) {
      adjust = new_skills[ skill_names[ i ] ] - old_skills[ skill_names[ i ] ];
      if ( adjust )
         write( "Adjusting "+ skill_names[ i ] +" by "+ adjust +".\n" );
   }
   this_player()->set_skills( new_skills + ([ ]) );
   return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/glass.c ===
inherit "/obj/vessel";
nosave string description, actual_drink, actual_glass_size;
void create() {
    do_setup++;
    ::create();
    do_setup--;
    set_name("glass");
    set_weight(1);
    set_value(400);
    set_stuck(1);
    set_leak_rate(0);
    set_material("glass");
    add_property("fragile", 200);
    if (!do_setup) {
        this_object()->setup();
    }
}
void make_glass(string drink, string glass_description, string glass_size,
   int amount, int has_contents)
{
    string *glass_adjectives;
    object contents;
    description = glass_description;
    actual_drink = drink;
    actual_glass_size = glass_size;
    glass_adjectives = explode( glass_size, " " )[0..<2];
    set_short( glass_size );
    set_long( (: this_object()->query_volume() ? description : "This is "
        "a dirty " + actual_glass_size + ", one that used to hold some "
        " " + actual_drink + ".\n" :) );
    glass_adjectives = explode( glass_size, " " );
    if (sizeof(glass_adjectives) > 1)
        add_alias(glass_adjectives[<1..]);
    else
        add_alias(glass_size);
    add_adjective(glass_adjectives);
    set_max_volume(amount);
    if (has_contents) {
        contents = clone_object("/obj/reagents/generic_liquid.ob");
        contents->set_name("drink");
        contents->set_short(drink);
        contents->set_long("This is some delicious looking " + drink + ".\n" );
        contents->add_adjectives(explode(drink, " ")[0..<2]);
        contents->add_alias( explode( drink, " " )[ sizeof(
           explode( drink, " " ) ) - 1 ] );
        contents->set_amount(amount);
        contents->move(this_object());
    }
}
mapping int_query_static_auto_load() {
    return ([
        "::": ::int_query_static_auto_load(),
        "description": description,
        "actual_drink" : actual_drink,
        "actual_glass_size" : actual_glass_size,
    ]);
}
void init_static_arg(mapping map) {
    if (map["::"])
        ::init_static_arg(map["::"]);
    if (!undefinedp(map["description"]))
        description = map["description"];
    if (!undefinedp(map["actual_drink"]))
        actual_drink = map["actual_drink"];
    if (!undefinedp(map["actual_glass_size"]))
        actual_glass_size = map["actual_glass_size"];
    set_long((: this_object()->query_volume() ? description : "This is "
        "a dirty " + actual_glass_size + ", one that used to hold some "
        "sort of " + actual_drink + ".\n" :));
}
mixed query_static_auto_load() {
    if (base_name(this_object()) == "/obj/misc/glass" )
        return int_query_static_auto_load();
    return ([ ]);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/fire_cracker.c ===
inherit "/std/object";
#define EFFECT "/w/dogbolter/cracker_eff"
#define DURATION 180
void setup() {
    set_name( "firecracker" );
    add_alias( "cracker" );
    add_adjective( "fire" );
    add_plural( "crackers" );
    set_short( "fire cracker" );
    set_long( "This is a large red fire cracker of Auriental manufacture"
      ".  It's the sort of thing that is thrown at weddings.  You may "
      "'light' it, and 'throw' it.\n" );
    set_weight( 2 );
    set_value( 500 );
    set_read_mess("ACME Firecracker", "agatean");
}
void explosion() {
    object victim;
    if( !environment() )
        return;
    if( living( environment() ) ) {
        victim = environment();
        tell_object( environment(), "%^BOLD%^%^RED%^$C$"+ the_short()
          +" explodes in your face!\nMeep meep!%^RESET%^\n" );
        environment()->add_effect (EFFECT, DURATION);
        if( environment( environment() ) ) {
            tell_room( environment( environment() ), "%^BOLD%^%^RED%^$C$"+
              the_short() +" explodes in "+
              environment()->the_short() +"'s face!\nMeep meep!%^RESET%^\n",
              environment() );
        }
    } else {
        tell_room( environment(), "%^BOLD%^%^RED%^$C$"+ the_short()
          +" explodes!%^RESET%^\n" );
    }
    move( "/room/rubbish" );
}
int do_light() {
    call_out( (: explosion :), 10 );
    add_succeeded_mess( "$N $V $D and smoke begins to pour out.\n",
      ({ }) );
    return 1;
}
int do_throw() {
    if( environment() && environment( environment() ) ) {
        add_succeeded_mess( "$N $V $D on the ground.\n", ({ }) );
        move( environment( environment() ) );
        return 1;
    } else {
        add_failed_mess( "There is no ground to $V $D on.  How very odd\n",
          ({ }) );
        return 0;
    }
}
void init() {
    add_command( "light", "<direct:object:me>", (: do_light :) );
    add_command( "throw", "<direct:object:me>", (: do_throw :) );
}
string query_death_reason() {
    return "being blown up by a fire cracker, in true Road Runner Style.\n"
    "%^BOLD%^Meep meep!%^RED%^";
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/board.c ===
#include <mail.h>
#include <board.h>;
inherit "/std/object";
string board_name;
mapping being_written;
int action_pri;
class info_written {
   string subject;
   int note_num;
}
int do_read_next();
int do_read_new();
int do_read(int num);
int do_followup(int num);
int do_reply(int num);
int do_eat(int num);
int do_post(string str);
void setup() {
   set_name("board");
   set_short("bulletin board");
   add_adjective("bulletin");
   set_main_plural("boards");
   reset_get();
   add_property("there", "mounted on one wall");
   add_property("survive fire", 1);
   add_help_file("board");
   board_name = "frog";
   being_written = ([ ]);
   action_pri = 0;
}
string query_plural() {
   mixed *stuff;
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   switch (sizeof(stuff)) {
   case 0:
      return pluralize(::short(0))+" [ Empty ]";
   case 1:
      return pluralize(::short(0))+" [ 1 note ]";
   }
   return pluralize(::short(0))+" [ "+sizeof(stuff)+" notes ]";
}
string short(int dark) {
   mixed *stuff;
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   switch (sizeof(stuff)) {
   case 0:
      return ::short(dark)+" [ Empty ]";
   case 1:
      return ::short(dark)+" [ 1 note ]";
   default:
      return ::short(dark)+" [ "+sizeof(stuff)+" notes ]";
   }
}
string the_date(int i) {
   return ctime(i)[4..9];
}
int do_subjects(string search) {
   int i, size;
   mixed *stuff;
   string ret;
   mapping news_rc;
   search = lower_case(search);
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   if (!sizeof(stuff)) {
      add_failed_mess("The board is completely empty.\n");
      return 0;
   }
   news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if (!news_rc) {
      news_rc = ([ ]);
   }
   ret = "";
   size = sizeof(stuff);
   for (i=0; i < size; i++) {
     if(search != "" && strsrch(lower_case(stuff[i][B_SUBJECT]), search) == -1)
       continue;
     if (news_rc[board_name] < stuff[i][B_TIME]) {
       ret += sprintf("N %2d: %-=*s\n", i+1,
                      (int)this_player()->query_cols()-6,
                      stuff[i][B_SUBJECT]+" ("+
                      stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
     } else {
       ret += sprintf("  %2d: %-=*s\n", i+1,
                      (int)this_player()->query_cols()-6,
                      stuff[i][B_SUBJECT]+" ("+
                      stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
     }
   }
   this_player()->set_finish_func(0);
   this_player()->more_string(ret);
   return 1;
}
string long(string str, int dark) {
   int i,newones, size;
   mixed *stuff;
   string ret;
   mapping news_rc;
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   ret = "A bulletin board ("+board_name+").\n";
   if (!sizeof(stuff)) {
      return ret+"The board is completely empty.\n";
   }
   news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if (!news_rc) {
      news_rc = ([ ]);
   }
   newones = 0;
   size = sizeof(stuff);
   for (i = 0; i < size; i++) {
      if (news_rc[board_name] < stuff[i][B_TIME]) {
         ret += sprintf("N %2d: %-=*s\n", i+1,
                     (int)this_player()->query_cols()-6,
                     stuff[i][B_SUBJECT]+" ("+
                     stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
         newones +=1;
      } else if (news_rc[board_name] < stuff[i][B_TIME]+(2*24*60*60)) {
         ret += sprintf("  %2d: %-=*s\n", i+1,
                     (int)this_player()->query_cols()-6,
                     stuff[i][B_SUBJECT]+" ("+
                     stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
      }
   }
   if (!newones) {
      ret += "\nNo new messages\n";
   }
   return ret;
}
void add_commands() {
   add_command("read", "[new]", (: do_read_new :));
   add_command("r", "[new]", (: do_read_new :));
   add_command("read", "<number>", (: do_read($4[0]) :));
   add_command("r", "<number>", (: do_read($4[0]) :));
   add_command("read", "next", (: do_read_next :));
   if (!this_player()->query_property("guest")) {
      add_command("post", "<string'subject'>", (: do_post($4[0]) :));
      add_command("note", "<string'subject'>", (: do_post($4[0]) :));
      add_command("eat", "<number'message number'>", (: do_eat($4[0]) :));
      add_command("followup", "<number'message number'>",
                  (: do_followup($4[0]) :));
      add_command("reply", "<number'message number'>", (: do_reply($4[0]) :));
   }
   add_command("subjects", "", (: do_subjects("") :));
   add_command("subjects", "<string'search'>", (: do_subjects($4[0]) :));
}
void init() {
  if (!present("board master", this_player())) {
    add_commands();
  }
}
void mark_mine(mixed *stuff, mapping news_rc) {
   int i;
   string their_name;
   i = sizeof(stuff)-1;
   their_name = this_player()->query_name();
   while (i > 0 && stuff[i][B_TIME] > news_rc[board_name])
      i--;
   while ((i+1) < sizeof(stuff) && lower_case(stuff[i+1][B_NAME]) == their_name)
      i++;
   if (i >= sizeof(stuff)) {
      news_rc[board_name] = stuff[sizeof(stuff)-1][B_TIME];
      return;
   }
   if (news_rc[board_name] > stuff[i][B_TIME])
      return;
   news_rc[board_name] = stuff[i][B_TIME];
}
int do_read_next()  {
   mapping  news_rc;
   mixed   *stuff;
   string   their_name, sub, next_sub;
   int      num, last_time;
   news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if (undefinedp(news_rc["last board"])  ||
       news_rc["last board"] != board_name)
   {
      add_failed_mess("You have not read a note on this board yet!\n");
      return 0;
   }
   stuff = BOARD_HAND->get_subjects(board_name);
   num = sizeof(stuff);
   their_name = this_player()->query_name();
write("last time: " + ctime(news_rc["last time"]) + "\n");
   last_time = news_rc["last time"];
   while (num  &&  stuff[num - 1][B_TIME] > last_time)  {
      num--;
   }
   sub = news_rc["last sub"];
   sscanf(sub, "Re:#%*d %s", sub);
   for (++num; num <= sizeof(stuff); num++)  {
      next_sub = stuff[num - 1][B_SUBJECT];
      sscanf(next_sub, "Re:#%*d %s", next_sub);
      if (next_sub == sub)  {
         return do_read(num);
      }
   }
   add_failed_mess("No further notes in the thread \"" + sub + "\".\n");
   return 0;
}
int do_read_new() {
   int num;
   string their_name;
   mapping news_rc;
   mixed *stuff;
   news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if (!news_rc) {
      news_rc = ([ ]);
   }
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   num = sizeof(stuff);
   their_name = (string)this_player()->query_name();
   while(num && (stuff[num - 1][B_TIME] > news_rc[board_name])) {
      num--;
   }
   while ((num < sizeof(stuff)) &&
          (lower_case(stuff[num][B_NAME]) == their_name)) {
      num++;
   }
   if (num == sizeof(stuff)) {
      add_failed_mess("No unread messages.\n");
      return 0;
   }
   num++;
   return do_read(num);
}
int do_read(int num) {
   mapping news_rc;
   mixed *stuff;
   news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if (!news_rc) {
      news_rc = ([ ]);
   }
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   if (num < 0) {
      num = sizeof(stuff) + num + 1;
   }
   if (num < 1 || (num > sizeof(stuff))) {
      add_failed_mess("No note of that number.\n");
      return 0;
   }
   num--;
   news_rc["last board"] = board_name;
   news_rc["last time"] = stuff[num][B_TIME];
   news_rc["last sub"] = stuff[num][B_SUBJECT];
   if (news_rc[board_name] < stuff[num][B_TIME]) {
      news_rc[board_name] = stuff[num][B_TIME];
   }
   BOARD_HAND->set_newsrc(this_player()->query_name(), news_rc);
   this_player()->more_string(sprintf("%s\nNote #%d by %s posted at %s%s\nTitle: "
                                     "\"%s\"\n\n%s",
                                     "%^BOLD%^",
                                     (num + 1),
                                     stuff[num][B_NAME],
                                     ctime(stuff[num][B_TIME]),
                                     "%^RESET%^",
                                     stuff[num]
                                     [B_SUBJECT][0..(int)this_player()->
                                                 query_cols() - 10],
                                     (string)BOARD_HAND->
                                       get_message(board_name, num)),
                             "[Note "+ (num + 1) +"]");
   add_succeeded_mess("", ({ }));
   return 1;
}
int do_post(string str) {
   class info_written bing;
   if (board_name=="announcements" && !this_player()->query_creator()) {
      add_failed_mess("Sorry. You can't post messages here.  "
            "It's for announcements "
            "from the creators only.  If you have a comment or flame, try "
            "the 'flame' board or the 'frog' board.  Bing\n");
      return 0;
   }
   if (!str) {
      return 0;
   }
   if (this_player()->query_sp() < BOARD_SOCIAL_POINT_COST) {
      add_failed_mess("You need " + BOARD_SOCIAL_POINT_COST +
                      " social points to post a note.\n");
      return 0;
   }
   if (!BOARD_HAND->test_can_write(board_name,
                                   this_object(),
                                   this_player()->query_name())) {
      add_failed_mess("You cannot write to this board.\n");
      return 0;
   }
   bing = new(class info_written);
   bing->subject = str;
   bing->note_num = 0;
   being_written[this_player()->query_name()] = bing;
   this_player()->do_edit(0, "end_of_thing");
   add_succeeded_mess(({ "", "$N looks like $r is "
                                        "contemplating a note.\n" }), ({ }) );
   return 1;
}
void end_of_thing(string body) {
  class info_written bing;
  if (body && body != "" &&
      being_written[this_player()->query_name()]) {
    if(board_name != "announcements")
      body = sprintf( "%-=78s", body ) + this_player()->append_signature();
    bing = (class info_written)being_written[ this_player()->query_name() ];
    if ( !BOARD_HAND->add_message( board_name,
         capitalize( (string)this_player()->query_name() ),
         bing->subject,
         body,
         bing->note_num ) ) {
      printf( "Error writing message.\n" );
    } else {
      printf("Message posted.\n");
      this_player()->adjust_sp(-50);
    }
  } else {
    printf( "No message posted.\n" );
  }
  map_delete(being_written, this_player()->query_name());
  return ;
}
int do_eat(int num) {
   if (!BOARD_HAND->delete_message(board_name, num-1)) {
      add_failed_mess("Failed to eat note.\n");
      return 0;
   }
   printf("You viciously tear off and eat note %d.\n", num);
   say( (string)this_player()->one_short() +
         " viciously tears off and eats note "+ num +".\n" );
   event( users(), "inform", (string)this_player()->query_name() +
         " eats a note off "+ board_name, "message", this_player() );
   return 1;
}
int do_followup(int num) {
   int i;
   mixed stuff;
   string s;
   class info_written bing;
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   if (num < 0) {
      num = sizeof(stuff) + num + 1;
   }
   if (num < 1 || num > sizeof(stuff)) {
      add_failed_mess("No note of that number.\n", ({ }));
      return 0;
   }
   if (this_player()->query_sp() < BOARD_SOCIAL_POINT_COST) {
      add_failed_mess("You need " + BOARD_SOCIAL_POINT_COST +
                      " social points to post a note.\n");
      return 0;
   }
   if (!stuff[num - 1][B_REPLY_TYPE] &&
       !BOARD_HAND->test_can_write(board_name,
                                   this_object(),
                                   this_player()->query_name())) {
      add_failed_mess("You cannot followup to this board.\n", ({ }));
      return 0;
   }
   bing = new(class info_written);
   if (sscanf(stuff[num - 1][B_SUBJECT], "Re:#%d %s", i, s) != 2) {
      bing->subject = "Re:#1 "+ stuff[num - 1][B_SUBJECT];
   } else {
      bing->subject = "Re:#"+ ( i + 1 ) +" "+ s;
   }
   bing->note_num = stuff[num - 1][B_NUM];
   being_written[(string)this_player()->query_name()] = bing;
   printf("Include original post? (y/[n]) ");
   input_to("include_post", 0, num - 1, stuff[num - 1]);
   add_succeeded_mess(({ "", "$N looks like $r is "
                                        "contemplating a note.\n" }), ({ }) );
   return 1;
}
void include_post(string str, int num, mixed *stuff) {
  if (!str || str == ""  || lower_case(str)[0] != 'y') {
    printf("No.\n");
    this_player()->do_edit(0, "end_of_thing");
    return;
  }
  if (this_player()->query_name() == "macchirton") {
    printf("No including notes for pointless and repeated abuse.\n");
    this_player()->do_edit(0, "end_of_thing");
    return;
  }
  this_player()->
    do_edit("On " + ctime(stuff[B_TIME]) + ", " + stuff[B_NAME] +
            " wrote:\n> " +
            replace_string(BOARD_HAND->get_message(board_name, num),
                                  "\n", "\n> ") + "\n", "end_of_thing");
}
int do_reply(int num) {
   mixed stuff;
   stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
   if (num < 1 || num > sizeof(stuff)) {
      add_failed_mess("No note of that number.\n", ({ }));
      return 0;
   }
   MAIL_TRACK->mail(stuff[num-1][B_NAME], stuff[num-1][B_SUBJECT]);
   add_succeeded_mess(({ "", "$N looks like $r is "
                                        "contemplating a note.\n" }), ({ }) );
   return 1;
}
void set_board_name(string str) { board_name = str; }
void set_datafile(string str) { board_name = str; }
int query_new_messages() {
   mixed *notes;
   mapping news_rc;
   news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if (!news_rc)
      news_rc = ([ ]);
   notes = (mixed *)BOARD_HAND->get_subjects(board_name);
   if (!sizeof(notes))
      return 0;
   return (notes[sizeof(notes)-1][B_TIME] > news_rc[board_name]);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/housing_creator.c ===
inherit "/std/object";
#include <housing.h>
#define ORIENTATION ({ "north", "northeast", "east", "southeast", "south", "southwest", "west", "northwest", "up" })
#define OPP_ORIENTATION ({ "south", "southwest", "west", "northwest", "north", "northeast", "east", "southeast", "down" })
#define PATH "/std/houses/"
int do_create(string type, string orientation, string location, string out,
              string region, string address, int overwrite,
              int test);
string list_plans();
void setup() {
  set_name("ball");
  set_short("small jade ball");
  add_adjective(({"small", "jade"}));
  set_long("This non-descript jade ball can be used to make player houses.\n");
  set_read_mess((: list_plans() :));
  set_weight(1);
  set_value(0);
  seteuid("Room");
}
void init() {
  this_player()->add_command("make", this_object(),
           "<word'floor plan'> <word'orientation'> "
           "<word'location'> <word'outside'> <word'region'> <string:quoted'address'>",
           (: do_create($4[0], $4[1], $4[2], $4[3], $4[4], $4[5], 0, 1) :) );
  this_player()->add_command("makereal", this_object(),
           "<word'floor plan'> <word'orientation'> "
           "<word'location'> <word'outside'> <word'region'> <string:quoted'address'>",
           (: do_create($4[0], $4[1], $4[2], $4[3], $4[4], $4[5], 0, 0) :) );
  this_player()->add_command("maketest", this_object(),
           "<word'floor plan'> <word'orientation'> "
           "<word'location'> <word'outside'> <word'region'> <string:quoted'address'>",
           (: do_create($4[0], $4[1], $4[2], $4[3], $4[4], $4[5], 1, 1) :) );
}
string list_plans() {
  string ret, str;
  string plan;
  ret = "To create a house use:\n"
    "  'make <floor plan> <orientation> <location> <outside> <region>\n"
    "        <address>' where:\n"
    "  'makereal <floor plan> <orientation> <location> <outside> <region>\n"
    "        <address>' where:\n"
    "  'makeforce <floor plan> <orientation> <location> <outside> <region>\n"
    "        <address>' where:\n"
    "  floor plan is one of the standard floor plans\n"
    "  orientation is its orientation (ie. the direction you enter it to)\n"
    "  location is the directory to write the houses files into\n"
    "  address is a the unique address for the house\n"
    "  region is the region of the house\n"
    "The 'makereal' command will add the house into the housing handler, "
    "the 'make' command will do a normal test make and the 'makeforce' "
    "will overwrite any existing housing files.\n\n"
    "Example:\n"
    "$I$5=   makereal twobedhouse south /d/am/fluff/housing OUT+room1 am \"12 Fluff Street\"\n\n$I$0="
    "The following floorplans are available:\n";
  str = "";
  foreach(plan in get_dir(PATH + "*")) {
    if(plan != "." && plan != ".." && file_size(PATH + plan) == -2 )
      str += plan + "\n";
  }
  ret += sprintf("%-#*s", this_player()->query_cols(), str);
  return ret;
}
int do_create(string type, string orientation, string location, string out,
              string region, string address, int overwrite,
              int test) {
  string room;
  string tmp;
  string fname;
  mapping files;
  mapping main_file;
  string number;
  int orient;
  int i;
  if(file_size(PATH+type) != -2) {
    return notify_fail("No such floor plan\n");
  }
  orient = member_array(orientation, ORIENTATION);
  if(orient == -1) {
    return notify_fail("No such orientation.\n");
  }
  if(file_size(location) != -2) {
    return notify_fail("No such location.\n");
  }
  if (address[0] < '0' || address[0] > '9') {
     add_failed_mess("Address must start with a number.\n");
     return 0;
  }
  i = 0;
  do {
     i++;
  } while (address[i] != ' ');
  number = address[0..i-1];
  address = address[i..];
  if (out[0] == '/') {
     if (out[<2..] == ".c") {
        out = out[0..<3];
     }
     out = "\"" + out + "\"";
  } else {
     if (member_array('+', out) == -1) {
        out = "PATH+\"" + out + "\"";
     }
  }
  files = ([ ]);
  main_file = ([ ]);
  if (type[<1] != 'M') {
     main_file[""] = 0;
  }
  foreach(room in get_dir(PATH+type+"

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/nroff_paper.c ===
inherit "/obj/misc/paper";
#include "nroff.h"
private nosave mixed *stuff = ({ });
string file_name = 0;
string language = 0;
void create() {
  seteuid(getuid());
  ::create();
}
void set_file_name(string fname) {
  file_name = fname;
}
string query_file_name() { return file_name; }
void set_language(string lang) { language = lang; }
string query_language() { return language; }
mixed *query_read_mess() {
  string str;
  if(sizeof(stuff) == 0) {
    if (file_name) {
      str = unguarded( (: NROFF_HAND->cat_file(file_name+"_nroff", 1) :) );
      if (!str) {
        unguarded((: NROFF_HAND->create_nroff(file_name, file_name+"_nroff") :));
        str = unguarded( (: NROFF_HAND->cat_file(file_name+"_nroff", 1) :) );
      }
      if(!str)
        return ::query_read_mess() +
          ({ ({ "Unable to nroff file.\n", 0, "common", 0 }) });
      if( language ) {
         return stuff = ({ ({ str, 0, language, 0 }) });
      }
      return stuff = ({ ({ str, 0, "common", 0 }) });
    }
  }
  return stuff + ::query_read_mess();
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   map["read mess"] = ::query_read_mess();
   return map;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/paper.c ===
#include <playtesters.h>
#define AUTO_LOAD_TAG "paper"
inherit "/std/object";
int do_uncrumple();
int do_crumple();
int do_eat();
private int _crumpled;
private string _old_short;
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_name( "paper" );
   set_short( "piece of writing paper" );
   add_adjective( ({ "piece of", "writing" }) );
   set_main_plural( "pieces of writing paper" );
   add_plural( "pieces of writing paper" );
   add_adjective(({ "piece", "pieces", "of", "writing" }));
   set_long( "This is a nice sheet of writing paper.\n" );
   set_value( 25 );
   set_weight( 0 );
   add_property( "writeable", 1 );
   add_property( "paper", 1 );
   set_max_size( 1000 );
   if ( !do_setup ) {
      this_object()->setup();
   }
}
void init() {
   if ( !this_player() ) {
       return;
   }
   add_command( "eat", "<direct:object>", (: do_eat :) );
   add_command( "crumple", "<direct:object>", (: do_crumple :) );
   add_command( "untangle", "<direct:object>", (: do_uncrumple :) );
   add_command( "uncrumple", "<direct:object>", (: do_uncrumple :) );
}
public int query_edible() {
    return 1;
}
public int query_paper() {
   return 1;
}
int do_crumple() {
   if (_crumpled) {
      add_failed_mess("$D is already crumpled.\n");
      return 0;
   }
   _old_short = query_short();
   call_out( (: set_short :), 1, "crumpled up " + query_short() );
   _crumpled = 1;
   return 1;
}
int do_uncrumple() {
    if (!_crumpled) {
        add_failed_mess("$D is already uncrumpled.\n");
        return 0;
    }
    call_out( (: set_short :), 1, _old_short );
   _crumpled = 0;
   return 1;
}
int do_eat() {
   string *flavours = ({ "red ink", "green ink", "black ink",
       "blue ink", "orange", "apple", "cinnamon", "banana",
       "monkey", "cabbage", "hat" });
   add_succeeded_mess( ({ "You open your mouth up widely and pop $D into "
      "your mouth.  After a moment's deliberation, you chew and consume "
      "$D.\n", "$N $V $D.\n" }) );
   call_out( (: tell_object( $1, $2 ) :), 1,
       this_player(), "Mmm! " +
       capitalize( flavours[random( sizeof( flavours ) ) ] ) +
       " flavoured!\n" );
   move( "/room/rubbish" );
   return 1;
}
string query_readable_message(object player, int ignore_labels) {
   if (!_crumpled) {
      return ::query_readable_message(player, ignore_labels);
   }
   return "Only bits of ink can be seen on the crumpled paper.\n";
}
string *parse_command_adjectiv_id_list() {
   if (_crumpled) {
      return ::parse_command_adjectiv_id_list() + ({ "crumpled", "up" });
   }
   return ::parse_command_adjectiv_id_list();
}
mapping query_dynamic_auto_load() {
    mapping map;
    map = ::query_dynamic_auto_load();
    add_auto_load_value( map, AUTO_LOAD_TAG, "crumpled", _crumpled );
    add_auto_load_value( map, AUTO_LOAD_TAG, "old short", _old_short );
    return map;
}
void init_dynamic_arg( mapping map, object ) {
    ::init_dynamic_arg(map);
    if (map) {
        _crumpled = query_auto_load_value( map, AUTO_LOAD_TAG, "crumpled" );
        _old_short = query_auto_load_value( map, AUTO_LOAD_TAG, "old short" );
        if ( map[ "paper - crumpled" ] ) {
            _crumpled = map[ "paper - crumpled" ];
        }
        if ( map[ "paper - short" ] ) {
            _old_short = map[ "paper - short" ];
        }
    }
}
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/misc/paper" )
      return ([ ]);
   return int_query_static_auto_load();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/lantern.c ===
inherit "/obj/lantern";
void setup() {
   fuel_left = 3600;
   is_lit    = 0;
   set_name( "lantern" );
   set_main_plural( "lanterns");
   set_short( "lantern" );
   add_help_file("torch");
   set_long(function() {
     string str;
     str = "This is a camping lantern, which smells of lamp oil.\n";
     if ( is_lit ) {
       return str + "The wick flickers inside spreading a dull "
         "glow.\n";
     }
     str += "The lantern is not lit, and ";
     if ( !fuel_left )
       return str + "is out of oil.\n";
     return str + "has some oil left in it.\n";
   } );
   set_weight( 60 );
   set_value( 150 );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/club_badge.c ===
#include <clubs.h>
#include <broadcaster.h>
inherit "/obj/clothing";
inherit "/std/basic/club_insignia";
protected int club_members(int online);
protected int do_recruit(object *players, string club);
protected int club_chat(string str, int emote);
protected int club_members(int online);
protected int club_info();
protected int do_history();
private string *extra_adjs;
void setup() {
   extra_adjs = ({ });
   set_name("badge");
   add_adjective("club");
   set_type("badge");
   set_short("club badge");
   setup_clothing(1000);
   set_damage_chance(5);
   set_long("The badge is a nice blue colour with a fringe "
            "like a bunny rabbit.\n");
   add_extra_look(this_object());
}
string extra_look() {
   string tmp_name;
   if (query_club() &&
       CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      tmp_name = replace(lower_case(query_club()), " ", "_");
      return "  You feel like the command '" + tmp_name + "' does something.\n";
   }
   return "\n";
}
void init() {
   club_insignia::init();
}
mapping query_dynamic_auto_load(mapping map) {
   map = clothing::query_dynamic_auto_load();
   map = club_insignia::query_dynamic_auto_load(map);
   map["verSion"] = 1;
   return map;
}
void init_dynamic_arg(mapping map) {
   if (map["verSion"] != 1) {
      clothing::init_dynamic_arg(map["::"]);
   } else {
      clothing::init_dynamic_arg(map);
   }
   club_insignia::init_dynamic_arg(map);
}
void set_club(string name) {
   if (!name) {
      extra_adjs = ({ });
      set_short("club badge");
   } else {
      if (CLUB_HANDLER->is_club(name)) {
         name = CLUB_HANDLER->query_club_name(name);
         extra_adjs = explode(lower_case(name), " ");
            set_short("club badge");
      }
   }
   ::set_club(name);
}
string *parse_command_adjectiv_id_list() {
   return ::parse_command_adjectiv_id_list() +
           extra_adjs;
}
mixed *stats()
{
  return clothing::stats() +
    club_insignia::stats();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/menu.c ===
inherit "/std/object";
#include <language.h>
object our_pub;
void create() {
  ::create();
  set_name("menu");
  set_long("This is a menu.\n");
  reset_get();
}
void set_pub(object pub) {
  our_pub = pub;
  add_read_mess(our_pub->read(), "printed letters", our_pub->query_language());
}
object query_pub() { return our_pub; }
void init() {
  this_player()->add_command( "list", this_object(), "" );
}
string query_readable_message(object player) {
   string lang;
   string mess;
   mess = our_pub->read();
   lang = our_pub->query_language();
   mess = LANGUAGES->garble_text(lang, mess, this_object(), player);
   return mess;
}
int do_list() {
  write(query_readable_message(this_player()));
  add_succeeded_mess(({ "", "$N read$s $D.\n" }));
  return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/golem_finger.c ===
inherit "/std/object";
void setup() {
    set_name( "fingertip" );
    set_short( "broken clay fingertip" );
    add_adjective( ({"broken", "clay"}) );
    set_long( "This looks like a crude fingertip made of clay.  It is broken "
       "in the middle.\n" );
    set_main_plural( "broken clay fingertips" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/wallpaper_glue.c ===
inherit "/obj/vessel";
#define VOLUME 5000
object add_glue();
void setup() {
    set_name("glue");
    set_short("pot of wallpapering glue");
    add_adjective( ({ "pot", "of", "wallpapering", "wallpaper" }) );
    add_alias("pot");
    add_plural("pots");
    set_max_volume(VOLUME);
    set_long("This is a small pot of wallpapering glue, essential "
        "for anybody who's going to be doing anything involving "
        "sticking paper to walls or playing mean tricks on their "
        "friends.\n");
    set_value(480);
    set_closed();
}
object add_glue() {
    object glue;
    glue = clone_object( "/obj/reagents/generic_liquid.ob" );
    glue->set_name( "glue" );
    glue->set_short( "sticky white wallpapering glue" );
    glue->add_adjective( ({ "sticky", "white", "wallpapering",
        "wallpaper"  }));
    glue->set_amount( VOLUME );
    glue->set_continuous();
    glue->set_long( "This is some thick and gloopy wallpapering glue.  "
        "Along with some wallpaper and a brush, you could probably "
        "do some fine home decorating.\n");
    glue->set_pile_name( "puddle" );
    glue->add_eat_effect( "/std/effects/ingested/poison", 10 );
    glue->move( this_object() );
    return glue;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/top_ten_tables.c ===
#include <top_ten_tables.h>
inherit "/std/object";
string generate_list( mixed *args );
string generate_table_message();
nosave string table_name;
nosave string language = "morporkian";
void setup() {
   table_name = 0;
   set_name( "table" );
   set_short( "top ten table" );
   set_long( "This is a perfectly rectangular wooden board, "
     "nailed to another piece of wood.\n" );
   add_adjective( ({ "top", "ten", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
   call_out( "setup_read_mess", 5 );
   call_out("dest_me", 30);
}
string query_table_name() { return table_name; }
void set_table_name( string word ) { table_name = word; }
void set_language( string lang ) {
  language = lang;
}
void setup_read_mess() {
   add_read_mess((: generate_table_message() :), 0, language, 0);
}
string generate_table_message() {
   string long;
   mixed *args;
   long = "\nHigh Score Table: ";
   args = (mixed *)TOP_TEN_HANDLER->query_ordered_table( table_name );
   if ( !table_name ) {
      long += "All Players";
      if ( !sizeof( args ) )
         return long +": There is no overall top ten at present.\n";
   } else {
      if ( file_size( "/std/guilds/"+ table_name +".c" ) < 0 )
         return "*Barf!* Can't find /std/guilds/"+ table_name +".\n";
      long += capitalize( (string)( "/std/guilds/"+ table_name )->
                     query_name() ) + "' Guild";
      if ( !sizeof( args ) )
         return long +": There is no top ten for this guild at present.\n";
   }
   return sprintf( "%|*s\n", table_name ? 40 : 50, long ) +
          sprintf( "%|*s\n", table_name ? 40 : 50, "Sorted by rating" ) +
          sprintf( "%|*s\n\n", table_name ? 40 : 50,
                   "-=- " + ctime(time()) + " -=-" ) +
          generate_list(args) + "\n";
}
string convert_age( int number ) {
   if ( number > 86400 )
      return ( number / 86400 ) +"D";
   if ( number > 3600 )
      return ( number / 3600 ) +"h";
   if ( number > 60 )
      return ( number / 60 ) +"m";
   return number +"s";
}
string generate_list( mixed *args ) {
   int i, number, sum;
   string format, list;
   if ( table_name )
      format = "  %2d. %-13s: level %4d  %5s";
   else
      format = "  %2d. %-23s: level %4d  %5s";
   format += "\n";
   list = "";
   number = sizeof( args );
   sum = 0;
   for ( i = 0; i < number; i++ )  {
      list += sprintf( format, i + 1, capitalize( args[ i ][ TOP_TEN_NAME ] ),
            args[ i ][ TOP_TEN_LEVEL ],
            convert_age( args[ i ][ TOP_TEN_AGE ] ) );
      if ( i > 0  &&  i < number - 1 )  {
         sum += args[i][TOP_TEN_RATING];
      }
   }
   return list;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/chicken_feather.c ===
inherit "/std/object";
void setup() {
 set_name("feather");
 set_short("chicken feather");
 set_main_plural("chicken feathers");
 add_adjective("chicken");
 add_plural("feathers");
 add_adjective("chicken");
 set_weight(1);
 set_long("This is a feather that was plucked from a chicken.\n");
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/ink_well.c ===
inherit "/obj/container";
void create() {
  ::create();
  set_name("well");
  add_adjective("ink");
  set_short("ink well");
  set_long("A nice, small ink well.\n");
  set_value( 500 );
  set_leak_rate(0);
  set_max_volume(250);
  set_volume(200);
  set_water_volume(200);
  set_ps_coord_quantity((int *)"/std/effects/other/ink"->query_coordinate(), 200);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/watch.c ===
inherit "/obj/clock";
int our_offset,
    their_offset,
    last_time,
    cur_alarm,
    offset_alarm,
    alarm;
mixed *alarms;
string *alarm_write,
       alarm_name;
object our_player;
varargs int get_text(string line);
void setup() {
  set_name("watch");
  add_adjective("demonic");
  add_alias("watch");
  set_main_plural("demonic watches");
  set_short("demonic watch");
  set_long("A small wrist attackable living quaters for a demon "+
           "the demon looks pretty harried about giveing out the "+
           "time all the time, and the pay is lousy..\n");
  set_value(20000);
  our_offset = 0;
  their_offset = 8;
  last_time = time();
  call_out("check_alarm",60);
  alarms = ({ });
}
void init() {
  add_command("time", "");
  add_command("gmt", "<word'offset'>", (:this_object()->set_gmt($4[0]):));
  add_command("use", "<direct:object>", (:this_object()->use():));
  this_player()->add_command("read", this_object());
}
int use(string arg) {
  if (!alarms)
    alarms = ({ });
  printf("%-=80s","You look into the watch and fiddle with several buttons, "+
                  "Finally a light lights up in the top corner say you have "+
                  "the security clearance to modify the settings.\n"+
                  "You can \"set\" an alarm \"remove\" an alarm \"list\" the "+
                  "set alarms. You can \"quit\" also.\n");
  write("What do you wish to do ? ");
  input_to("the_command");
  return 1;
}
int the_command(string arg) {
  string s1;
  int i;
  if (arg == "quit") {
    write("Thank you for using this wonderful watch.\n");
    return 1;
  }
  if (sscanf(arg,"set%s",s1)) {
    int hour, min;
    string name;
    if (sscanf(s1," %s %d:%d%s",name,hour,min,s1)!=4)
      write("Usage: set <name> <hour>:<min> [+]\n");
    else {
      if ((i=member_array(name,alarms))<0)
        alarms += ({ name, hour, min, 0 });
      else
        if (i%4)
          write("Oooooopps, you cannot use that name as an alarm\n");
        else {
          alarms[i+1] = hour;
          alarms[i+2] = min;
        }
      if (s1 == " +") {
        if (i==-1)
          i = sizeof(alarms)-4;
        cur_alarm = i;
        get_text();
        return 1;
      }
    }
  }
  if (sscanf(arg,"remove%s",s1)) {
    string frog;
    if (sscanf(s1," %s",frog)!=1)
      write("Usage: remove <name>\n");
    else
      if ((i=member_array(frog,alarms))<0)
        write("You must remove an existing alarm\n");
      else
        if (i%4)
          write("Ohhh dear.\n");
        else {
          alarms = delete(alarms,i);
          alarms = delete(alarms,i);
          alarms = delete(alarms,i);
          alarms = delete(alarms,i);
        }
  }
  if (sscanf(arg,"list%s",s1)) {
    string chicken;
    if (sscanf(s1," %s",chicken)!=1) {
      for (i=0;i<sizeof(alarms);i+=4) {
        write("Alarm "+alarms[i]+" is set for "+alarms[i+1]+":"+alarms[i+2]+"\n");
      }
    } else {
      if ((i=member_array(chicken,alarms))<0)
        write("That alarm does not exist.\n");
      else
        if (i%4)
          write("Bing basicly");
        else
          write("You have set alarm "+chicken+" to go off at "+alarms[i+1]+":"+
                 alarms[i+2]+"\n");
    }
  }
  return 1;
}
varargs int get_text(string line) {
   string text;
  if (!line) {
    text = "";
    write(sprintf("%-=80s","Please enter the text you wish to be displayed "+
          "when the alarm goes off (. to finish)"));
  } else if (line==".") {
    alarms[cur_alarm+3] = text+"\n";
    write("What do you wish to do ? ");
    input_to("the_command");
    return 1;
  } else
    text += line+"\n";
  write("] ");
  input_to("get_text");
  return 1;
}
mixed query_auto_load() {
  mixed ret;
  if (!alarms)
    alarms = ({ });
  ret = ({ their_offset, alarms });
  return ret;
}
void init_arg(mixed *arg) {
  their_offset = arg[0];
  alarms = arg[1];
  if (!alarms)
    alarms = ({ });
}
void check_alarm() {
   int the_time, offset, i;
   int tmp;
   the_time = time();
   offset = (the_time/(3600*24))*3600*24 - our_offset*3600;
   for (i=0;i<sizeof(alarms);i+=4) {
      tmp = offset + (alarms[i+1]-our_offset+their_offset)*3600 + alarms[i+2]*60;
      if (the_time>tmp && tmp>last_time) {
         alarm = 6;
         alarm_name = alarms[i];
         if (alarms[i+3])
         alarm_write = explode(alarms[i+3],"\n");
      else
         alarm_write = ({
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
         });
         offset_alarm = 0;
         set_heart_beat(1);
      }
   }
   last_time = the_time;
   call_out("check_alarm",60);
}
void heart_beat() {
   if (our_player)
     our_player->event_say(this_object(), "The watch goes: "+
                           alarm_write[offset_alarm++]+"\n");
   if (offset_alarm>sizeof(alarm_write))
     set_heart_beat(0);
}
int move(object ob) {
  int i;
  i = ::move(ob);
  our_player = environment();
  return i;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/grinder.c ===
#include <move_failures.h>
#define STATE_CHANGE "/obj/handlers/state_change"
inherit "/obj/container";
int test_add(object ob, int flag);
int do_grind( string what );
int do_empty(object *dest, string me, string him, string prep);
void set_max_grindable( int i );
int query_max_grindable();
string long_status();
private int _max_grind = 0;
void setup() {
  set_name( "grinder" );
  set_short( "food grinder" );
  add_adjective( "food" );
  set_main_plural( "food grinders" );
  set_long( "This is a mechanical contraption to grind food into small "
      "pieces.  There is a funnel-type piece at the top, a crank on one "
      "side and on the other a pipe where the ground food comes out and "
      "is caught in a small tray.\n" );
  set_value( 4000 );
  set_weight( 100 );
  set_max_weight( 100 );
}
void init() {
  this_player()->add_command( "grind", this_object(),
      "<string'object'> in <direct:object'" + query_short() + "'>",
      (: do_grind( $4[0] ) :) );
  add_command( "empty", "<direct:object>" );
}
int test_add(object ob, int flag) {
  object stuff = first_inventory();
  if (stuff) {
    add_failed_mess( "There is already some " + stuff->query_short()
      + " in the grinder.  You'll have to empty it first.\n");
    return 0;
  } else return 1;
}
int do_grind( string what ) {
  object *things, thing;
  object ground;
  object contents;
  things = match_objects_for_existence( what, ({ this_object(),
                                                 this_player() }) );
  if( !sizeof( things ) ) {
    add_failed_mess( "You must be holding something or put it in $D in "
                     "order to $V it.\n" );
    return -1;
  }
  thing = things[0];
  if( ( contents = first_inventory() ) && contents != thing ) {
    add_failed_mess( "$D isn't empty.\n" );
    return -1;
  }
  if( query_max_grindable() &&
      ( thing->query_amount() > query_max_grindable() ||
        thing->query_weight() > query_max_grindable() ) ) {
    add_failed_mess( "You cannot grind that much with $D at once.\n" );
    return -1;
  }
  ground = STATE_CHANGE->transform( thing, "grind" );
  if ( !objectp( ground ) ) {
    add_failed_mess( "You cannot $V $I in $D.\n", ({ thing }) );
    return -1;
  }
  thing->move( "/room/rubbish" );
  if( ground->move( this_object() ) != MOVE_OK ) {
    ground->move( environment( this_player() ) );
    add_succeeded_mess( "$N grind$s $I with $D, spilling it onto the " +
        ( environment( this_player() )->query_property( "location" ) ==
        "inside" ? "floor" : "ground" ) + ".\n" );
    return 1;
  }
  this_player()->add_succeeded_mess( this_object(), "$N grind$s $I "
    "in $D.\n", ({ thing }) );
  return 1;
}
int do_empty(object *dest, string me, string him, string prep) {
  object ground = first_inventory( this_object() );
  if( !ground ) {
    add_failed_mess( "There is nothing in $D.\n" );
    return 0;
  }
  if( ground->move( this_player() ) != MOVE_OK ) {
    ground->move( environment( this_player() ) );
    add_succeeded_mess( "$N $V $D onto the " +
        ( environment( this_player() )->query_property( "location" ) ==
        "inside" ? "floor" : "ground" ) + ".\n" );
    return 1;
  }
  return 1;
}
void set_max_grindable( int i ) { _max_grind = i; }
int query_max_grindable() { return _max_grind; }
string long_status() { return ""; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/notepad.ob ===
#  -*- LPC -*- #
#
# $Locker:  $
# $Id: notepad.ob,v 1.1 2001/10/17 20:28:30 siel Exp $
#
#
#

# by Siel

::#Class:: "/std/book.c"
::Name:: "notepad"
::Short:: "green notepad"
::Long:: "This is a small green notepad and has a sketch of a mosquito "
         "on its cover.\n"
::Adjective:: ({ "green" })
::Property:: "writeable", 1
::$set_no_pages::5
::Value::390


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/top_clubs.c ===
#include <top_ten_tables.h>
#include <clubs.h>
inherit "/std/object";
private string _lang = "morporkian";
string _long();
void setup() {
   set_name( "table" );
   set_short( "top club table" );
   set_long("This is a table listing those clubs that are most "
            "advanced in certain aspects.\n");
   add_adjective( ({ "top", "club", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
   call_out("setup_read_mess", 5);
}
void setup_read_mess() {
   add_read_mess((: _long() :), 0, _lang, 0);
}
void set_language(string lang) {
  _lang = lang;
}
string query_language() { return _lang; }
string club_name(string str) {
   if (!str) {
      return "Unknown";
   }
   return CLUB_HANDLER->query_club_name(str);
}
string _long() {
   mixed *stuff;
   string bing, str;
   string guild;
   string *g_sorted;
   mapping g_info;
   stuff = TOP_TEN_HANDLER->query_club_info();
   str = "The club with:\n"
         "The most members          : " +
         club_name(stuff[TOP_TEN_LARGEST_FAMILY])  + "\n"
         "The oldest average age    : " +
         club_name(stuff[TOP_TEN_OLDEST_FAMILY]) + "\n"
         "Most average quest points : " +
         club_name(stuff[TOP_TEN_MOST_QUEST_POINTS]) + "\n"
         "Most player killers       : " +
         club_name(stuff[TOP_TEN_MOST_PKS]) + "\n"
         "Largest single gender     : " +
         club_name(stuff[TOP_TEN_SINGLE_GENDER]) + "\n"
         "Oldest start DW time      : " +
         club_name(stuff[TOP_TEN_OLDEST_LOGONS]) + "\n"
         ;
   g_info = stuff[TOP_TEN_MOST_GUILD];
   g_sorted = sort_array(filter(keys(g_info), (: stringp($1) &&
                                                 file_size($1 + ".c") > 0 :)),
                         (: strcmp($1->query_name(), $2->query_name()) :));
   foreach (guild in g_sorted) {
      if (stringp(guild)) {
         bing = g_info[guild];
         str += sprintf("%-26s: %s\n",
               "Most " + (guild->query_name()),
               club_name(bing));
      }
   }
   str += "\nTo get onto the average list the club must have more than "
          "3 members that are not creators.\n";
   return str;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/top_ten_tables.ratings ===
#include <top_ten_tables.h>

inherit "/std/object";

nosave string table_name;

void setup() {
   table_name = 0;
   set_name( "table" );
   set_short( "top ten table" );
   add_adjective( ({ "top", "ten", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
} /* setup() */

string query_table_name() { return table_name; }

void set_table_name( string word ) { table_name = word; }

string convert_age( int number ) {
   if ( number > 86400 )
      return ( number / 86400 ) +"D";
   if ( number > 3600 )
      return ( number / 3600 ) +"h";
   if ( number > 60 )
      return ( number / 60 ) +"m";
   return number +"s";
} /* convert_age() */

string generate_list( mixed *args ) {
   int i, number;
   string format, list;
   if ( table_name )
      format = "  %2d. %-13s: rating %6d, level %4d  %5s";
   else
      format = "  %2d. %-23s: rating %6d, level %4d  %5s";
   format += "\n";
   list = "";
   number = sizeof( args );
   for ( i = 0; i < number; i++ )
      list += sprintf( format, i + 1, capitalize( args[ i ][ TOP_TEN_NAME ] ),
            args[ i ][ TOP_TEN_RATING ], args[ i ][ TOP_TEN_LEVEL ],
            convert_age( args[ i ][ TOP_TEN_AGE ] ) );
   return list;
} /* generate_list() */

string long( string words, int number ) {
   string long;
   mixed *args;
   long = "  High Score Table: ";
   args = (mixed *)TOP_TEN_HANDLER->query_ordered_table( table_name );
   if ( !table_name ) {
      long += "All Players";
      if ( !sizeof( args ) )
         return long +": There is no overall top ten at present.\n";
   } else {
      if ( file_size( "/std/guilds/"+ table_name +".c" ) < 0 )
         return "*Barf!* Can't find /std/guilds/"+ table_name +".\n";
      long += capitalize( (string)( "/std/guilds/"+ table_name )->query_name() )
            +"' Guild";
      if ( !sizeof( args ) )
         return long +": There is no top ten for this guild at present.\n";
   }
   long += " -=- "+ ctime( time() ) +"\n\n";
   return long + generate_list( args ) +"\n";
} /* long() */


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/wallpaper.c ===
inherit "/std/object";
private nosave string _design;
varargs int do_paper(string indirect, object pot);
void setup() {
    set_name( "wallpaper" );
    set_short( "roll of wallpaper" );
    set_main_plural( "rolls of wallpaper");
    add_adjective( ({ "roll", "of"}));
    add_plural_adjective("rolls");
    add_alias(({"paper"}));
    set_long( "This is a large roll of wallpaper, probably enough to "
        "cover a single wall completely.\n");
    set_value( 480 );
    set_weight( 10 );
}
void make_roll( string design ) {
    _design = design;
    set_short( "roll of " + _design + " wallpaper" );
    set_main_plural( "rolls of " + _design + " wallpaper");
    add_adjective( ({ _design })) ;
    set_long( "This is a large roll of " + _design + " wallpaper.  It "
        "looks like there's just enough of it to cover a single wall "
        "completely.  If you had some wallpaper glue you could probably "
        "paste it to the wall.\n");
}
void init() {
    this_player()->add_command("paste", this_object(),
       "<direct:object> to <indirect:object:here'cardinal direction'> using <indirect:object'pot'>", (: do_paper( $4[1], $1[1][0] ) :));
}
string query_paper_mess() {
    if( _design ) {
        return _design + " wallpaper";
    }
    else {
        return "strangely featureless wallpaper";
    }
}
varargs int do_paper(string indirect, object pot) {
    object *obs;
    if(!indirect && pot) {
        if(function_exists("what_to_paint", pot))
            printf(pot->what_to_paint());
        else
            printf("Help: paste " + pot->short() + " with wallpaper\n");
            return 1;
    }
    obs = match_objects_for_existence("glue", pot);
    if(pot->query_closed()) {
        this_player()->add_failed_mess(this_object(), "$I is "
            "closed.\n", ({ pot }));
        return 0;
    }
    if(!pot->query_volume(obs) || !sizeof(obs)) {
        this_player()->add_failed_mess(this_object(), "$I appears to "
            "be empty.\n", ({ pot }));
        return 0;
    }
    if(!sizeof(filter(this_player()->query_holding() - ({ 0 }),
        (: $1->id("brush") :)))) {
        this_player()->add_failed_mess(this_object(), "You must be holding a "
            "paint brush to paint the walls with glue.\n", ({ }));
        return 0;
    }
    if(!environment( this_player() )->test_occupier( this_player()->
        query_name() ) ) {
        this_player()->add_failed_mess(this_object(), "You don't own this "
            "house.\n", ({ }));
        return 0;
    }
    if(!function_exists("decorate_surface", environment(this_player()))) {
        this_player()->add_failed_mess(this_object(), "You can't $V the "
            "walls here.\n", ({ }));
        return 0;
    }
    if(!environment(this_player())->decorate_surface(indirect,
        "papered with " + query_paper_mess())) {
        this_player()->add_failed_mess(this_object(), "You can't $V the $D"
            " to the " + indirect + " using $I for some reason.\n",
            ({ pot }));
        return 0;
    }
    pot->remove_volume(pot->query_volume());
    this_object()->move("/room/rubbish");
    this_player()->add_succeeded_mess(this_object(), "$N $V $D to the " +
        indirect + ", dawbing it with paste from $I and pressing it firmly "
        "against the surface.\n", ({ pot }) );
    return 1;
}
mapping int_query_static_auto_load() {
    mapping tmp;
    tmp = ::int_query_static_auto_load();
    return ([ "::" : tmp,
              "design" : _design,
            ]);
}
mapping query_static_auto_load() {
    if ( base_name(this_object()) + ".c" == __FILE__ )
        return int_query_static_auto_load();
    return ([ ]);
}
void init_static_arg(mapping args) {
    if (args["::"])
    ::init_static_arg(args["::"]);
    if(!undefinedp(args["design"]))
        _design = args["design"];
    if(_design)
        make_roll(_design);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/detabber.c ===
inherit "/std/object";
void setup()
{   set_name("detabber");
    set_long("A long stick with absoulutely no tabs in it.\n"
             "Usage:  detab <filename>.\n");
}
void init()
{   this_player()->add_command("detab",this_object(),"<string>");
}
int do_detab(object *indirect_obs, string *dir_match, string indir_match, mixed *args, string pattern)
{
    string file;
    string tb;
    tb = sprintf("\t");
    file = read_file(args[0]);
    if(file)
        {file = replace_string(file,"\t","    ");
         write_file(args[0],file,1);
         return 1;
         }
    return 0;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/golem_corpse.c ===
#include <armoury.h>
inherit "/obj/container";
void make_fragments();
void setup() {
    set_name( "rubble" );
    set_short( "heap of clay rubble" );
    add_alias( ({"heap", "clay"}) );
    add_adjective( ({"heap of", "clay"}) );
    set_main_plural( "heaps of clay rubble" );
    add_plural( "heaps" );
    set_weight( 40000 );
    set_max_weight( 50000 );
    set_value( 0 );
    set_stuck( 1 );
    make_fragments();
    add_property( "no recycling", 1 );
}
void make_fragments() {
    int amount = random( 8 );
    int i;
    for( i = 1; i <= amount; i++ )
        switch( random( 11 ) ) {
           case 0..5:
               ARMOURY->request_item( "golem shard", 100 )->
                   move( this_object() );
               break;
           case 6..7:
               ARMOURY->request_item( "golem finger", 100 )->
                   move( this_object() );
               break;
           case 8..9:
               ARMOURY->request_item( "golem toe", 100 )->
                   move( this_object() );
               break;
           case 10:
               ARMOURY->request_item( "golem eye", 100 )->
                   move( this_object() );
               break;
        }
}
string long( string word, int dark ) {
    string inv = query_multiple_short( all_inventory( this_object() ) );
    string tmp = "";
    switch( sizeof( all_inventory( this_object() ) ) ) {
        case 0:
           break;
        case 1:
            tmp = "Something that looks like " + inv + " protrudes from it.  ";
            break;
        default:
            tmp = "It looks like " + inv + " are buried in it.  ";
    }
    return "This is a large heap of shattered clay.  " + tmp + "Whatever this "
        "was before, it is destroyed thouroughly and beyond any means of "
        "repair.\n";
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/football.c ===
inherit "/std/object";
string me, him;
void setup() {
     set_name("football");
     set_short("leather football");
     add_adjective("leather");
     add_alias("ball");
     set_long("This is a leather football, pumped up hard.  Looks like you could"
             " kick it to people.\n");
     set_weight(10);
     set_value(1);
     add_plural("footballs");
     add_plural("balls");
}
void init() {
  this_player()->add_command("kick", this_object(),
        "<direct:object:me> to <indirect:player>");
  add_command( "kickup", "<direct:object>" );
}
int do_kickup()  {
   write( "You kick the football into the air a few times, stopping it from "
   "hitting the floor by bouncing it off your knee, your chest and your feet."
   "  A rare display of skill!\n" );
tell_room( environment( this_player() ),
     this_player()->query_cap_name() + " expertly kicks the ball into the "
     "air, heads it back up, bounces it a few times on their chest and displays "
     "an uncanny level of skill.\n", this_player());
   return 1;
}
int do_kick(object *in_dir) {
  if (!sizeof(in_dir))
    return 0;
  if (move(in_dir[0])) {
    tell_object(in_dir[0], this_player()->query_cap_name()+" kicks "+
        this_object()->query_short()+" at you, but it falls on the floor.\n");
    tell_room(environment(in_dir[0]), "A leather football flies "
        "through the air, "+ in_dir[0]->query_name()+" tries to trap it "
        "but fails and it lands next to them.", ({ in_dir[0], this_player() }) );
    move(environment(in_dir[0]));
  } else {
    tell_object(in_dir[0], this_player()->query_cap_name()+" kicks a "
           "leather football at you.  It curls towards you at speed but you "
           "manage to " +
           ({ "trap it with your foot.",
           "bounce it off your chest and trap it underfoot.",
           "head it to the ground, juggle it a few times and eventually stand"
           " on it",
           "catch it. HANDBALL!",
           "look like the famous footballer Fele and trap it.",
           "trap it easily.  You should sign up for Ankh Morpork Wanderers."})
           [random (6) ]+"\n");
    tell_room(environment(in_dir[0]), "A leather football curls "
           "gracefully towards "+ in_dir[0]->query_cap_name()+", who "+
                "manages to "+
                ({ "trap it with their foot.",
           "bounce it off their chest and trap it underfoot.",
           "head it to the ground, juggle it a few times and eventually stands"
           " on it",
           "catches it. HANDBALL!",
           "look like the famous footballer Fele and trap it.",
           "trap it easily.  They should sign up for Ankh Morpork Wanderers."})
           [random (6) ]+
                "\n",
          ({ in_dir[0], this_player() }));
  }
  this_player()->add_succeeded(in_dir[0..0]);
  return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/talker.ob ===
#  -*- LPC -*- #
#
# $Locker:  $
# $Id: talker.ob,v 1.3 2003/03/05 09:49:14 runtime Exp $
#
#
#

::Name:: "stick"
::Short:: "small stick"
::Alias:: "talker"
::Long:: "This is a pretty ordinary-looking stick of
wood, carefully trimmed and sanded smooth.  "
::Adjective:: ({ "small", "talking" })
::Main plural:: "small sticks"
::$add_read_mess::"To use Krazzander's talking stick, simply \"chat\" into
it.  Further instructions on the \"talker\" are available on
request.", "small red letters", "morporkian", 0
::Value::200
::Weight::1
::$add_effect::"/std/effects/object/talker"


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/wearable_pet.c ===
#include <gossip.h>
#include <armoury.h>
#define CHAT_FREQ 200
inherit "/obj/monster";
inherit "/std/basic/wearable";
varargs int wear_remove_function(object);
void expand_mon_string( mixed str ) {
    object room;
    string *args, *stuff;
    if ( functionp( str ) ) {
        evaluate( str, this_object() );
    }
    if(strsrch(str, "$name$") > 0) {
        stuff = GOSSIP_HANDLER->query_random_gossip();
        str = replace(str, ({ "$name$", stuff[0],
            "$mess$", stuff[1] }));
    }
    str = expand_string(str, 0);
    switch( str[0] ) {
    case '#':
        args = explode(str[ 1..], ":");
        switch (sizeof(args)) {
        case 1 :
            call_other( this_object(), args[0] );
            return;
        case 2 :
            call_other( this_object(), args[0], args[1] );
            return;
        case 3 :
            call_other( this_object(), args[0], args[1], args[2] );
            return;
        case 4 :
            call_other( this_object(), args[0], args[1], args[2],
              args[3] );
            return;
        default :
            call_other( this_object(), args[0], args[1], args[2],
              args[3], args[4] );
            return;
        }
    case ':' :
        str = str[1..];
        break;
    case '\'' :
        str = "says " + str;
        break;
    case '"' :
        str = "says loudly " + str;
        break;
    }
    if(living(environment())) {
        room = environment(environment());
        str = capitalize(environment()->poss_short()) +" "
        + this_object()->query_short()  + " " + str;
        tell_room( room,  str +"\n" );
    } else {
        room = environment();
        str = "The " + this_object()->query_short() + " " + str;
        tell_room( room, expand_string( str, 0 ) +"\n" );
    }
}
int check_anyone_here() {
object holder, *people;
    if(!(::check_anyone_here()))
        if ( living(holder = environment(this_object())) ) {
            if(environment(holder) &&
                    sizeof(people = all_inventory(environment(holder))))
            if(sizeof(filter(people, (: userp($1) :))))
                return 1;
            else
                return 0;
    }
    return ::check_anyone_here();
}
varargs int wear_remove_function(object pet, object thing) {
    object *wearing;
    object worn;
    if(pet && thing) {
        wearing = this_player()->query_wearing();
        foreach(worn in wearing) {
            if( (worn != previous_object())
                && inherits("/obj/misc/wearable_pet", worn)) {
                previous_object()->init_command(sprintf("kill %O",worn));
            }
        }
    }
}
void create() {
    wearable::create();
    monster::create();
}
string long(string str, int dark) {
    return monster::long(str, dark);
}
void init_dynamic_arg(mapping map) {
    wearable::init_dynamic_arg(map);
    monster::init_dynamic_arg(map);
}
mapping query_dynamic_auto_load() {
    return
    wearable::query_dynamic_auto_load() +
    monster::query_dynamic_auto_load();
}
void init_static_arg(mapping map) {
    wearable::init_static_arg(map);
    monster::init_static_arg(map);
}
mixed query_static_auto_load() {
    wearable::query_static_auto_load() +
    monster::query_static_auto_load();
}
int query_value() {
    return query_base_value();
}
mixed stats() {
    return wearable::stats() + monster::stats();
}
void break_me() {
    do_death();
}
string cond_string() {
   health_string();
}
int adjust_cond( int i ) {
    adjust_hp( i );
}
varargs int adjust_hp( int number, object attacker, object weapon,
    string attack ) {
    if(::adjust_cond( number ))
      return ::adjust_hp( number, attacker, weapon, attack);
}
int set_max_hp( int number ) {
    set_max_cond(number);
    set_cond(number);
    set_damage_chance( 15 );
    set_lowest_cond(1);
    return ::set_max_hp(number);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/frisbee.c ===
inherit "/std/object";
string me, him;
void setup() {
  set_name("frisbee");
  set_short("black frisbee");
  add_adjective("black");
  set_long("This is a small black frisbee.  It looks like you could "
           "throw it to "
           "people.\n");
  add_property("feeding_frenzy", "frisbee");
  set_weight(10);
  set_value(200);
  set_main_plural("black frisbees");
  add_plural("frisbees");
}
void init() {
  this_player()->add_command("throw", this_object(),
                             "<direct:object:me> to <indirect:player>");
}
int do_throw(object *in_dir) {
  if (!sizeof(in_dir))
    return 0;
  if (move(in_dir[0])) {
    tell_object(in_dir[0], this_player()->one_short()+" throws "+
                this_object()->short()+" at you, but it falls on the floor.\n");
    tell_room(environment(in_dir[0]), "A frisbee arcs through the air, "+
              in_dir[0]->query_name()+" tries to catch it but fails and it "+
              "falls on the floor.\n", ({ in_dir[0], this_player() }) );
    move(environment(in_dir[0]));
  } else {
    tell_object(in_dir[0], this_player()->one_short()+" throws a frisbee "+
                "at you, you catch it... just.\n");
    tell_room(environment(in_dir[0]), in_dir[0]->one_short()+
          " fumbles the catch of the "+
          short(0)+" but manages to keep hold of it.\n",
          ({ in_dir[0], this_player() }));
  }
  this_player()->add_succeeded(in_dir[0..0]);
  return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/mailer_ob.c ===
inherit "/std/object";
int do_mail(string str);
void setup() {
  set_name("mailer");
  set_short( "mailer object" );
  set_long("It is a small black box with pictures of small red demons "
           "painted on "+
           "the front.  Though, some of them look suspicously like frogs.\n");
  set_weight(1);
  reset_drop();
}
void init() {
  add_command("mail", "", (: do_mail(0) :) );
  add_command("mail", "<string>", (: do_mail($4[0]) :) );
}
int do_mail(string str) {
  return (int)"/obj/handlers/mail_track"->mail(str);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/lock.c ===
inherit "/std/object";
#include <move_failures.h>
void create() {
  add_help_file("door_lock");
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void init() {
  this_player()->add_command("change", this_object(),
      "[lock in] <indirect:object:here'door or furniture'> for "
                             "<indirect:object:me'lock'>");
}
int do_change(mixed *in_dir, string direct, string indirect, mixed *args,
              string) {
  object lock;
  object ob;
  object item;
  object other;
  string other_id;
  item = in_dir[0][0];
  lock = in_dir[1][0];
  if(function_exists("query_my_room", item) &&
     (query_property("locktype") != "door"))
    return notify_fail("This lock is not suitable for a door.\n");
  if(item->query_furniture()) {
    switch(item->query_pick_skill()) {
    case "covert.lockpick.door":
      if(query_property("locktype") != "furniture")
        return notify_fail("This lock is not suitable for furniture.\n");
    case "covert.lockpick.safes":
      if(query_property("locktype") != "safe")
        return notify_fail("This lock is not suitable for safes.\n");
    }
  }
  if(function_exists("query_my_room", item) &&
     !function_exists("test_occupier", environment(this_player())))
    return notify_fail("You cannot change the locks here.\n");
  if(function_exists("test_occupier", environment(this_player())) &&
     !environment(this_player())->test_occupier(this_player()->query_name())
     && !this_player()->query_creator())
    return notify_fail("Sorry, only the owner of the house can change the "
                       "locks on items in the house.\n");
  if(!function_exists("pick_lock", item))
    return notify_fail("Sorry, that object can't take a lock.\n");
  if(!item->query_unlocked())
    return notify_fail("Sorry, the item must be unlocked in order to change "
                       "its lock.\n");
  if(!lock->query_property("key prop")) {
    this_player()->add_failed_mess(this_object(),
      "$I doesn't appear to have a key.\n", ({ lock }));
    return 0;
  }
  if(!lock->query_property("difficulty")) {
    this_player()->add_failed_mess(this_object(),
      "$I doesn't appear to have a difficulty.\n", ({ lock }));
    return 0;
  }
  item->set_key(lock->query_property("key prop"));
  item->set_difficulty(lock->query_property("difficulty"));
  item->set_lock_owner(environment(this_player())->query_owner());
  item->set_trap_armed(0);
  if(function_exists("query_my_room", item)) {
    other = load_object(item->query_dest());
    other_id = item->query_other_id();
    other->modify_exit(other_id, ({ "key", lock->query_property("key prop")}));
    other->modify_exit(other_id, ({ "difficulty",
                                      lock->query_property("difficulty")}));
    other->modify_exit(other_id, ({ "lock owner",
                                      environment(this_player())->query_owner()
                                      }));
    environment(this_player())->update_doors();
    other->update_doors();
    environment(this_player())->do_save();
    other->do_save();
  }
  ob = clone_object("/std/object");
  ob->set_name("lock");
  ob->set_short("busted lock");
  ob->add_adjective("busted");
  ob->set_main_plural("busted locks");
  ob->set_long("A broken door lock.\n");
  ob->set_value(0);
  ob->set_weight(lock->query_weight());
  ob->move(environment());
  if(lock->move("/room/rubbish") != MOVE_OK)
    lock->dest_me();
  this_player()->add_succeeded_mess(this_object(),
                                    "$N remove$s the existing, and now "
                                    "broken, lock from $I and replace$s it "
                                    "with the new one.\n", ({ item }));
  return 1;
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}
