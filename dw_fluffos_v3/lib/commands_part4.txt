
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/al_ias.c ===
#include <alias.h>
inherit "/cmds/base";
private nosave string gfilter;
string alias_string(mixed *al) {
   int i;
   int num;
   int *add_thing;
   string str;
   str = "";
   add_thing = ({ });
   for (i=0;i<sizeof(al);i++) {
      if (stringp(al[i])) {
         str += replace(al[i], ({";", "\\;"}));
      } else {
         num = al[i] & ALIAS_MASK;
         switch (al[i] - num) {
         case NEW_LINE  :
            str += ";";
            break;
         case ALL_ARGS  :
            str += "$*$";
            break;
         case ONE_ARG   :
            str += "$"+num+"$";
            break;
         case TO_ARG    :
            str += "$*"+num+"$";
            break;
         case FROM_ARG  :
            str += "$"+num+"*$";
            break;
         case ALL_ARG   :
            str += "$arg:"+al[++i]+"$";
            break;
         case ARG_THING :
            str += "$arg"+num+":"+al[++i]+"$";
            break;
         case ELSE_THING :
           str += "$else$";
           break;
         case ALL_IFARG :
            str += "$ifarg:";
            break;
         case IFARG_THING :
            str += "$ifarg"+num+":";
            break;
         case CURR_LOC :
            str += "$!$";
            break;
         case END_IF      :
            str += "$endif$";
            break;
         }
      }
   }
   return str;
}
int print_aliases(string filter, int sorted) {
   int i;
   int len;
   string str;
   string str1;
   string str2;
   string *tmp;
   string bing;
   mapping aliases;
   string ret;
   aliases = this_player()->query_aliases();
   if (!m_sizeof(aliases)) {
      notify_fail("None defined.\n");
      return 0;
   }
   str1 = "";
   str2 = "";
   tmp = m_indices(aliases);
   if (filter) {
      if (regexp(filter,
           "[\\[\\]\\(\\)\\*\\?\\+][\\[\\]\\(\\)\\*\\?\\+]+") ) {
         add_failed_mess("Bad pattern to alias.\n");
         return 0;
      }
      if (filter[0] == '*' || filter[0] == '+') {
         add_failed_mess("Cannot start a regular expression with a '*' or '+', "
                         "try: '.*' or '.+'.\n");
         return 0;
      }
      gfilter = "^" + filter;
      if (catch(tmp = filter_array(tmp, (: $1 && regexp($1, gfilter) :)))) {
         add_failed_mess("Bad pattern to alias (mismatched brackets?).\n");
         return 0;
      }
   }
   tmp = sort_array(tmp, 1);
   ret = "You currently have the following aliases:\n";
   for (i = 0; i < sizeof(tmp); i++) {
      if (!tmp[i]) {
         map_delete(aliases, 0);
         continue;
      }
      bing = alias_string(aliases[tmp[i]]);
      if (!bing) {
         bing = "Error in the alias!";
      }
      if (!tmp[i]) {
         tmp[i] = "icky";
      }
      if (strsrch(bing, "%^") != -1) {
         bing = replace_string(bing, "%^", "% ^");
         tmp[i] += " (colour replace)";
      }
      str = tmp[i] + ": " + bing;
      if (strlen(str) > 39 || sorted) {
         len = this_player()->query_cols() - strlen(tmp[i]) - 2;
         if (len < 0) {
            len = 10;
         }
         ret += sprintf("%s: %-=*s\n", tmp[i], len, bing);
      } else if (strlen(str) > 19) {
         str1 += str+"\n";
      } else {
         str2 += str+"\n";
      }
   }
   if (strlen(str1)) {
      ret += sprintf("%-#*s\n", this_player()->query_cols(), str1);
   }
   if (strlen(str2)) {
      ret += sprintf("%-#*s\n", this_player()->query_cols(), str2);
   }
   ret += sprintf("A total of %d aliases.\n", sizeof(tmp));
   this_player()->more_string(ret);
   return 1;
}
mixed *compile_alias(string str) {
   mixed *ret;
   int i;
   int space;
   string *frog;
   string s1;
   int tmp;
   int gumby;
   int nodollar;
   int ending_dollar;
   mixed *ifargs;
   str = replace(str, ({ "\\;", "$escaped$", ";", "$new_line$", " ", " " }));
   str = replace(str, "$escaped$", ";");
   if(str[sizeof(str)-1] == '$')
     ending_dollar = 1;
   frog = explode("&" + str + "&", "$");
   if (frog[0] == "&") {
      frog[0] = "";
   } else {
      frog[ 0 ] = frog[ 0 ][ 1 .. ];
   }
   s1 = frog[<1];
   if (s1 == "&") {
      frog = frog[0..<2];
   } else {
      frog[<1] = s1[0..<2];
   }
   ret = ({ frog[0] });
   ifargs = ({ });
   nodollar = 1;
   for (i = 1; i < sizeof(frog); i++) {
      switch (frog[i]) {
      case "new_line" :
         ret += ({ NEW_LINE });
         nodollar = 1;
         break;
      case "*" :
         ret += ({ ALL_ARGS });
         gumby = 1;
         nodollar = 1;
         break;
      case "!" :
         if (this_object()->query_creator()) {
            ret += ({ CURR_LOC });
            nodollar = 1;
         }
         break;
      case "else" :
         if (sizeof(ifargs)) {
            ret[ifargs[sizeof(ifargs)-1]] = sizeof(ret) -
               ifargs[sizeof(ifargs)-1]+1;
            ret += ({ ELSE_THING, 0, "" });
            ifargs[sizeof(ifargs)-1] = sizeof(ret)-2;
            nodollar = 1;
         }
         break;
      case "~" :
      case "endif" :
         if (sizeof(ifargs)) {
            ret += ({ END_IF });
            ret[ifargs[sizeof(ifargs)-1]] = sizeof(ret)-
               ifargs[sizeof(ifargs)-1];
            ifargs = delete(ifargs, sizeof(ifargs)-1, 1);
            nodollar = 1;
            space = 1;
         }
         break;
      default :
         if (frog[i][0..4] == "ifarg") {
            if (sscanf(frog[i], "ifarg%d:%s", tmp, s1) == 2) {
               if (tmp < 0) {
                  tmp = 0;
               }
               if (tmp > ALIAS_MASK) {
                  tmp = ALIAS_MASK;
               }
               ret += ({ IFARG_THING+ tmp, 0, "" });
               frog[i--] = s1;
               nodollar = 1;
               ifargs += ({ sizeof(ret)-2 });
               space = 0;
               gumby = 1;
            } else if (frog[i][5] == ':') {
               ret += ({ ALL_IFARG, 0, "" });
               frog[i] = frog[i][6..];
               nodollar = 1;
               ifargs += ({ sizeof(ret)-2 });
               space = 0;
               gumby = 1;
               i--;
            } else {
               if (sizeof(ret) && stringp(ret[sizeof(ret)-1]) && !space) {
                  ret[sizeof(ret)-1] += "$"+frog[i];
               } else if (nodollar) {
                  ret += ({ frog[i] });
                  nodollar = 0;
               } else {
                  ret += ({ "$"+frog[i] });
               }
            }
         } else if (frog[i][0..2] == "arg") {
            if (sscanf(frog[i], "arg%d:%s", tmp, s1) == 2) {
               if (tmp < 0) {
                  tmp = 0;
               }
               if (tmp > ALIAS_MASK) {
                  tmp = ALIAS_MASK;
               }
               ret += ({ ARG_THING+ tmp, s1, "" });
               nodollar = 1;
               gumby = 1;
            } else if (frog[i][3] == ':') {
               ret += ({ ALL_ARG, frog[i][4..100], "" });
               nodollar = 1;
               gumby = 1;
            } else {
               if (sizeof(ret) && stringp(ret[sizeof(ret)-1]) && !space) {
                  ret[sizeof(ret)-1] += "$"+frog[i];
               } else if (nodollar) {
                  ret += ({ frog[i] });
                  nodollar = 0;
               } else {
                  ret += ({ "$"+frog[i] });
               }
               gumby = 1;
               space = 0;
            }
         } else if (strlen(frog[i]) && frog[i][<1] == '*' &&
                    sscanf(frog[i], "%d%s*", tmp, s1) == 2 && s1 == "") {
            if (tmp < 0) {
               tmp = 0;
            }
            if (tmp > ALIAS_MASK) {
               tmp = ALIAS_MASK;
            }
            ret += ({ FROM_ARG + tmp });
            gumby = 1;
            nodollar = 1;
         } else if (strlen(frog[i]) && frog[i][0] == '*' &&
                    sscanf(frog[i][1..], "%d%s", tmp,s1) == 2 && s1 == "") {
           if (tmp < 0) {
             tmp = 0;
           }
           if (tmp > ALIAS_MASK) {
             tmp = ALIAS_MASK;
           }
           ret += ({ TO_ARG + tmp });
           gumby = 1;
           nodollar = 1;
         } else if (sscanf(frog[i], "%d%s", tmp, s1) == 2 && s1 == "" &&
                    (i < sizeof(frog)-1 || ending_dollar)) {
           if (tmp < 0) {
             tmp = 0;
           }
           if (tmp > ALIAS_MASK) {
             tmp = ALIAS_MASK;
           }
           ret += ({ ONE_ARG + tmp });
           gumby = 1;
           nodollar = 1;
         } else {
            if (!nodollar) {
               frog[i] = "$"+frog[i];
            }
            nodollar = 0;
            space = 0;
            if (strlen(frog[i]) && frog[i][<1] == '~') {
               if (sizeof(ifargs)) {
                  if (strlen(frog[i]) == 1) {
                     frog[i] = "";
                  } else {
                     frog[i] = frog[i][0..<2];
                  }
                  ret += ({ END_IF });
                  ret[ifargs[<1]] = sizeof(ret) - ifargs[<1];
                  ifargs = ifargs[0..<2];
                  nodollar = 1;
                  space = 1;
               }
            }
            if (sizeof(ret) && stringp(ret[<1]) && space != 2) {
               ret[<1] += frog[i];
            } else {
               ret += ({ frog[i] });
            }
            if (space) {
               space = 2;
            }
         }
      }
   }
   while (sizeof(ifargs)) {
      ret += ({ END_IF });
      ret[ifargs[sizeof(ifargs)-1]] = sizeof(ret)-
         ifargs[sizeof(ifargs)-1];
      ifargs = delete(ifargs, sizeof(ifargs)-1, 1);
   }
   if (!gumby) {
      if (sizeof(ret) && !stringp(ret[sizeof(ret)-1]) || space) {
         ret += ({ " ", ALL_ARGS });
      } else if(sizeof(ret)) {
         ret[sizeof(ret)-1] += " ";
         ret += ({ ALL_ARGS });
      }
   }
   return ret;
}
int print_some_aliases(string str, int every) {
   if (this_player()->is_alias(str) && !every) {
      printf("%s: %-=*s\n", str,
                (int)this_player()->query_cols() - strlen(str) -2,
                alias_string(this_player()->query_player_alias(str)));
      return 1;
   }
   return print_aliases(str, 0);
}
protected int alias(string name, string value) {
#ifdef DISALLOW_COLOUR
   if (strsrch(name, "%^") >= 0 || strsrch(value, "%^") >= 0) {
      notify_fail("Cannot add an alias with a colour escape "
                  "sequence (% ^).\n");
      return 0;
   }
#endif
   if (strsrch(value, "END_ALIAS") != -1) {
      add_failed_mess("You cannot use 'END_ALIAS' in an alias.\n");
      return 0;
   }
   name = implode(explode(name, " "), "");
   if (name == "unalias" || name == "alias" || name == "ealias")  {
      add_failed_mess("You can't alias the '" + name + "' command, because "
                      "otherwise, there would be Problems.\n");
      return 0;
   }
   if (!this_player()->is_alias(name)) {
      this_player()->add_player_alias(name, compile_alias(value));
      write("Added alias '" + name + "'.\n");
   } else {
      this_player()->add_player_alias(name, compile_alias(value));
      write("Changed alias '" + name + "'.\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({
         "", (: print_aliases("", 0) :),
         "sorted", (: print_aliases("", 1) :),
         "every <word'alias'>", (: print_some_aliases($4[0], 1) :),
         "<word'alias'>", (: print_some_aliases($4[0], 0) :),
         "<word'alias'> <string>", (: alias($4[0], $4[1]) :)
         });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/helper_s.c ===
#include <player_handler.h>
inherit "/cmds/base";
int cmd() {
    object *helpers;
    string mess;
    helpers = filter( users(), (: !$1->query_creator() &&
        $1->query_property( "newbie helper" ) &&
        !$1->query_login_ob() :) );
    switch( sizeof( helpers ) ) {
        case 0:
            add_failed_mess("There are no newbie helpers logged on at the "
                "moment.\n");
            return 0;
        case 1:
            if ( helpers[ 0 ] == this_player() ) {
                mess = "You are the only newbie helper logged on at the "
                    "moment.\n";
            }
            else {
                mess = helpers[ 0 ]->query_short() + " is the only newbie "
                    "helper logged on at the moment.\n";
            }
        break;
        default:
            mess = query_multiple_short( helpers->query_short() ) + " are "
                "newbie helpers.\n";
    }
    this_player()->add_succeeded_mess(this_object(), ({mess, ""}),
      ({ }));
    return 1;
}
int test_helper( string player_name ) {
    player_name = lower_case( player_name );
    if ( PLAYER_HANDLER->test_property( player_name, "newbie helper" ) ) {
        this_player()->add_succeeded_mess(this_object(), ({
          capitalize( player_name ) + " is a newbie helper.\n",
          ""}), ({ }));
        return 1;
    }
    add_failed_mess(capitalize( player_name ) +
        " is not a newbie helper.\n" );
    return 0;
}
mixed *query_patterns() {
    return ({ "", (: cmd :),
              "<string'name'>", (: test_helper( $4[ 0 ] ) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/position.c ===
#include <player.h>
#define MAXLEN 30
inherit "/cmds/base";
private string* _bad_words;
void create() {
   _bad_words = ({ "teach", "skill", "finger", "lesson", ":)", ";)",
                   "chainsaw", "0", "1", "2", "3", "4", "5", "6", "7", "8",
                   "9", ":", ";", ",", "'", "*", "%", "!",
                   "@", "~", "`", "#", "$", "^", "&", "(", ")",
                   "_", "-", "=", "+", "{", "}", "[", "]",
                   "<", ".", ">", "?", "/", "\\",
                   ":->", ":-)", ";-)", ";->", "\""});
}
int cmd( string new_pos ) {
  object player = this_player();
  string word, tmp;
  if (!new_pos) {
    write("You are " + player->query_position_short() + ".\n");
    return 1;
  }
  if ( strlen(new_pos) > MAXLEN ) {
    add_failed_mess("Sorry, your position cannot be more than " +
                        MAXLEN + " letters long.\n");
    return 0;
  }
  if ( player->query_sp() < SET_POSITION_COST ) {
    add_failed_mess( NO_POWER );
    return 0;
  }
  new_pos = replace_string(new_pos, "^", "");
  new_pos = replace_string(new_pos, "%", "");
  tmp = lower_case(new_pos);
  foreach(word in _bad_words) {
    if(strsrch(tmp, word) != -1) {
      add_failed_mess("You cannot bring yourself to set that position.\n");
      return 0;
    }
  }
  player->set_position( new_pos );
  player->adjust_sp( - SET_POSITION_COST );
  tell_object( player, "People will now see:\n" +
               player->query_cap_name() + " is " + new_pos + ".\n");
  return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
          "<string'new position'>", (: cmd( $4[0] ) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/pstatus.c ===
broken
#include <config.h>
#include <library.h>
#include <quest_handler.h>
#ifndef __DISTRIBUTION_LIB__
#include <deity.h>
#endif
#include <top_ten_tables.h>
#include <tune.h>
#include <skills.h>
inherit "/cmds/base";
string find_hp_string( int current, int max );
string find_gp_string( int current, int max );
string find_xp_string( int current );
string find_wimpy_string( int wimpy );
string find_surrender_string( int surr );
string find_align_string( object tp );
string find_death_string( int remaining );
int calc_percent( float x, float y );
int calc_xp_cost( string skill );
int cmd() {
   object me;
   me = this_player();
   if ( !"/obj/handlers/playtesters"->query_playtester( me->query_name() ) &&
        !me->query_creator() ) {
      return 1;
   }
   if (this_player()->query_property("dead")) {
      write( "You are just a disembodied spirit.  What use does a wispy thing "
             "like you have for a collection of meaningless numbers?\n" );
      return 1;
   }
   switch( me->query_verbose( "score" ) ) {
   case 1:
      printf( "%s.\n%s and %s.\n%s.\n%s.\n%s and %s.\n%s.\n%s.\n",
              "You are "+ me->query_cap_name() +" "+me->query_gtitle(),
              capitalize( find_hp_string( me->query_hp(), me->query_max_hp() ) ),
              find_gp_string( me->query_gp(), me->query_max_gp() ),
              capitalize( find_xp_string( me->query_xp() ) ),
              capitalize( find_align_string( me ) ),
              capitalize( find_wimpy_string( me->query_wimpy() ) ),
              find_surrender_string( me->query_surrender() ),
              "You are "+ me->burden_string(),
              find_death_string( me->query_max_deaths() - me->query_deaths() ) );
      return 1;
   default:
      printf( "%s and %s.\n%s.\n",
              capitalize( find_hp_string( me->query_hp(), me->query_max_hp() ) ),
              find_gp_string( me->query_gp(), me->query_max_gp() ),
              capitalize( find_xp_string( me->query_xp() ) ) );
      return 1;
   }
}
int cmd_stats() {
   object me;
   int stat;
   string ret;
   me = this_player();
   ret = "";
   if ( !"/obj/handlers/playtesters"->query_playtester( me->query_name() ) &&
        !me->query_creator() ) {
      return 1;
   }
   if ( stat = ( me->query_tmp_str() + me->query_bonus_str() ) ) {
      if ( stat > 0 ) {
         ret += "You feel stronger then usual.\n";
      } else {
         ret += "You feel weaker then usual.\n";
      }
   }
   if ( stat = ( me->query_tmp_int() + me->query_bonus_int() ) ) {
      if ( stat > 0 ) {
         ret += "You feel smarter then normal.\n";
      } else {
         ret += "You feel less smart then normal.\n";
      }
   }
   if ( stat = ( me->query_tmp_con() + me->query_bonus_con() ) ) {
      if ( stat > 0 ) {
         ret += "You feel more healthy then usual.\n";
      } else {
         ret += "You feel a bit sickly.\n";
      }
   }
   if ( stat = ( me->query_tmp_dex() + me->query_bonus_dex() ) ) {
      if ( stat > 0 ) {
         ret += "You feel more nimble then usual.\n";
      } else {
         ret += "You feel more clumsy than you normally do.\n";
      }
   }
   if ( stat = ( me->query_tmp_wis() + me->query_bonus_wis() ) ) {
      if ( stat > 0 ) {
         ret += "You feel mentally attuned.\n";
      } else {
         ret += "You feel a bit vague.\n";
      }
   }
   if ( !strlen( ret ) ) {
      ret += "You feel fine.\n";
   }
   printf( "%s", ret );
   return 1;
}
string find_hp_string( int current, int max ) {
   if ( this_player()->query_property( "dead" ) ) {
      return "you are dead\n";
   }
   switch( calc_percent( current, max ) ) {
   case 90..100:
      return "you are in perfect health";
   case 70..89:
      return "you are slightly wounded";
   case 50..69:
      return "you are moderately wounded";
   case 30..49:
      return "you are seriously wounded";
   case 15..29:
      return "you are critically wounded";
   case 6..14:
      return "you are fatally wounded";
   case 0..5:
      return "you are near death";
   default:
      return "you are broken";
   }
}
string find_gp_string( int current, int max ) {
   if ( this_player()->query_property( "dead" ) ) {
      return "you are dead\n";
   }
   switch( calc_percent( current, max ) ) {
   case 90..100:
      return "you are full of energy";
   case 70..89:
      return "you are enthusiastic";
   case 50..69:
      return "you are not quite so full of beans";
   case 30..49:
      return "you are weary";
   case 15..29:
      return "you are tired";
   case 6..14:
      return "you are exhausted";
   case 0..5:
      return "you are nearly unconscious";
   default:
      return "you are broken";
   }
}
string find_xp_string( int current ) {
   string *skills = ({ "magic", "faith", "fighting", "covert", "crafts" });
   int xptotal;
   foreach( string skill in skills ) {
      xptotal += calc_xp_cost( skill );
   }
   xptotal /= sizeof( skills );
   tell_creator( find_player( "terano" ), "%s: Current XP is: %d, Avg XP is %d, Ratio is: %d.\n",
                 this_player()->query_name(), current, xptotal, calc_percent( current, xptotal ) );
   switch( calc_percent( current, xptotal ) ) {
   case 0..20:
      return "you don't think you can learn much at the moment";
   case 21..59:
      return "by the luck of a coin, you might be able to learn something new";
   case 60..100:
      return "if you squeezed it, you could gain some insight";
   case 101..300:
      return "you might be able to learn something new, if you found the right teacher";
   case 301..400:
      return "a small amount could be learned with training";
   case 401..800:
      return "a bit of training might be in order";
   case 801..1200:
      return "you could very well learn something new from training";
   case 1201..1500:
      return "you could benefit from training";
   case 1501..2000:
      return "you feel like training might help";
   case 2001..2500:
      return "you should consider training your skills";
   case 2501..4000:
      return "your skills could be greatly improved with training";
   default:
      return "certainly a hearty training session is in order!";
   }
}
string find_wimpy_string( int wimpy ) {
   if ( wimpy ) {
      return "you will flee when "+ find_hp_string( wimpy, 100 );
   }
   return "you will not flee";
}
string find_surrender_string( int surr ) {
   if ( surr ) {
      return "you will surrender when "+ find_hp_string( surr, 100 );
   }
   return "you will not surrender";
}
string find_align_string( object tp ) {
   string ret = "";
   string word = tp->query_deity();
   ret = "";
   word = tp->query_deity();
   if ( !tp ) {
      return "";
   }
   ret += "you are ";
   ret += tp->align_string();
   if ( stringp( word ) ) {
      ret += " and in the service of ";
      ret += capitalize( word );
      ret += ", ";
#ifndef __DISTRIBUTION_LIB__
      ret += DEITY->query_title( word );
#endif
   }
   return ret;
}
string find_death_string( int remaining ) {
   if ( !this_player()->query_deaths() ) {
      return "Death has never visited you in a professional capacity";
   }
   switch ( remaining ) {
   case 0..0:
      return "Death has a special interest in your next appointment";
   case 1..3:
      return "Death is starting to lose patience with you";
   case 4..7:
      return "You and Death are on good terms";
   default:
      return "You have an \"arrangement\" with Death";
   }
}
int calc_xp_cost( string skill ) {
   int lvl;
   int my_lvl;
   int cost;
   int j;
   int total;
   int total2;
   int num = 1;
   my_lvl = this_player()->query_skill_bonus( skill, 1 );
   lvl = this_player()->query_skill(skill);
   cost = DEFAULT_COST;
   if( SKILL_OB->query_skill_cost(skill) > 0 ) {
      cost *= SKILL_OB->query_skill_cost(skill);
   }
   cost *= STD_COST/5;
   total2 = 0;
   total = 0;
   if ( !my_lvl ) {
      my_lvl = 1;
   }
   for ( j = 0; j < num; j++) {
      int k;
      k = 2 * this_player()->calc_bonus( lvl + j, skill, 1 ) / my_lvl + 1;
      total2 += cost * ( ( lvl + j ) / LEVEL_DIV + 1 ) * k * k / 2;
      if ( total > total2 ) {
         num = j;
         break;
      } else {
         total = total2;
      }
   }
   if (!total) {
      total = cost;
   }
   return total;
}
int calc_percent( float x, float y ) {
   return to_int( ( to_float( x ) / to_float( y ) ) * 100 );
}
mixed *query_patterns() {
   return ({ "", (: cmd() :), "stats", (: cmd_stats() :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/idle.c ===
inherit "/cmds/base";
int cmd(object who) {
  if (!interactive(who))
    write(who->query_cap_name() + " is net-dead.\n");
  else
    write(who->query_cap_name() + " has been idle for " +
          "/secure/finger"->time_elapsed_string(query_idle(who)) + ".\n");
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:player>", (: cmd($1[0]) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/ex_amine.c ===
inherit "/cmds/living/l_ook";
mixed *query_patterns() {
    return ({ "<string'direction'>", (: cmd_string($4[0]) :),
              "<indirect:object>", (: cmd_object($1, $4[0]) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/ea_lias.c ===
#include <alias.h>
inherit "/cmds/base";
mapping editing_alias;
void create() {
   editing_alias = ([ ]);
}
protected int edit_alias(string str, int new_flag) {
   string al;
   if (editing_alias[this_player()]) {
      add_failed_mess("You are already editing the '" +
                  editing_alias[this_player()] + "' alias.\n");
      return 0;
   }
   if (!this_player()->is_alias(str))  {
      if (!new_flag)  {
         add_failed_mess("No alias '"+str+"' defined.\n");
         return 0;
      }
   } else if (new_flag)  {
      add_failed_mess("You already have an alias called \"" + str + "\".");
      return 0;
   }
   editing_alias[this_player()] = str;
   if (new_flag)  al = "";
   else al = replace(ALIAS_CMD->alias_string(this_player()->
      query_player_alias(str)), ";", "\n");
   this_player()->do_edit(al, "finish_alias_edit", 0);
   return 1;
}
protected int edit_alias_copy(string alias, string new_alias) {
   string al;
   if (!this_player()->is_alias(alias)) {
      add_failed_mess("No alias '"+alias+"' defined.\n");
      return 0;
   }
   if (this_player()->is_alias(new_alias)) {
      add_failed_mess("The alias '"+new_alias+"' already exists.\n");
      return 0;
   }
   new_alias = replace_string(new_alias, "END_ALIAS", "NO YOU DONT");
   editing_alias[this_player()] = new_alias;
   al = replace(ALIAS_CMD->alias_string(this_player()->query_player_alias(alias)), ";", "\n");
   this_player()->do_edit(al, "finish_alias_edit", 0);
   return 1;
}
void finish_alias_edit(string str) {
   string alias;
   if (!editing_alias[this_player()]) {
      write("Oh dear.  We got terribly confused and forgot "
            "what you were trying to do.  Terribly sorry.\n");
      return ;
   }
   if (!str  ||  str == "") {
      write("Can't save an empty alias, sorry.\n");
      editing_alias[this_player()] = 0;
      return ;
   }
   str = replace(str, "\n", ";");
   alias = editing_alias[this_player()];
   if (!this_player()->is_alias(alias))
      printf("Added alias '%s'.\n", alias);
   else
      printf("Changed alias '%s'\n", alias);
   this_player()->add_player_alias(alias, ALIAS_CMD->compile_alias(str));
   map_delete(editing_alias, this_player());
   return ;
}
mixed *query_patterns() {
  return ({
    "<word'alias'>", (: edit_alias($4[0], 0) :),
    "new <word'alias'>", (: edit_alias($4[0], 1) :),
    "copy <word'alias'> to <word'new alias'>", (: edit_alias_copy($4[0], $4[1]) :),
      });
}
int clean_up()  {
   if (sizeof(editing_alias) == 0)
      ::clean_up();
   return 1;
}
void reset()  {
   if (sizeof(editing_alias) == 0)
      ::reset();
   return;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/unkeep.c ===
#define EFFECT "/std/effects/object/identity_hold"
inherit "/cmds/base";
int cmd( object *obs ) {
   object thing, *success;
   success = ({ });
   foreach (thing in obs)  {
      if (thing->query_keep())  {
         thing->reset_keep();
         success += ({ thing });
      }
   }
   if (!sizeof(success))  {
      write("You are not attempting to keep anything.\n");
   }
   else  {
      write("You will no longer attempt to keep " +
            query_multiple_short(success) + ".\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd( $1 ) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/hi_story.c ===
int cmd(string arg){
   return this_player()->print_history(arg);
}
mixed query_patterns() {
   return ({ "", (: cmd("") :),
               "<string'number|number,number'>", (: cmd($4[0]) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/bury.c ===
#include <move_failures.h>
#include <cmds/bury.h>
#include <playtesters.h>
inherit "/cmds/base";
#define TP this_player()
#define GP_INCREMENT 10
#define MAX_BURY_NUMBER 20
mixed cmd(object *obs) {
   string person;
   mixed effs, *xp;
   string* messages;
   object ob, tmp;
   object *sobs;
   object *fobs;
   object *too_many;
   int gp;
#ifdef PT
   if (!PLAYTESTER_HAND->query_playtester(this_player()->query_name()) &&
       !this_player()->query_creator()) {
      add_failed_mess("This command is in play testing at the moment.\n");
      return 0;
   }
#endif
   sobs = ({ });
   fobs = ({ });
   too_many = ({ });
   if (TP->query_property("dead")) {
      add_failed_mess("You are a disembodied spirit, how do you expect to bury "
                      "anything at all?\n");
      return 0;
   }
   if(sizeof(filter_array(TP->query_attacker_list(),
                          (: environment($1) == environment(this_player()) :)))) {
      add_failed_mess("You cannot bury items while in combat.\n");
      return 0;
   }
   if(environment(TP)->query_property("no burial")) {
      add_failed_mess("You cannot bury things here.\n");
      return 0;
   }
   fobs = filter(obs, (: !is_in_me_or_environment($1, this_player()) :));
   obs -= fobs;
   foreach (ob in obs) {
      if (sizeof(sobs) >= MAX_BURY_NUMBER) {
         too_many += ({ ob });
      } else if ((ob->query_owner() == this_player()->query_cap_name()) ||
                 ((ob->get() == MOVE_OK) ||
                  (ob->get() == MOVE_TOO_HEAVY)) &&
                 (ob->query_property("no burial") != 1) &&
                 !ob->ok_to_bury(this_player())) {
        if (ob->query_property("player") != 1 ||
            ob->query_owner() == this_player()->query_name()) {
            effs = ob->effects_matching("mudlib.owned.weapon");
            if(sizeof(effs)) {
               person = ob->arg_of(effs[0]);
               log_file("BURIAL", "%s: %s's %s buried by %s\n", ctime(time()),
                        person, ob->query_short(), TP->query_name());
            }
            environment(this_player())->add_effect(BURY_EFFECT, ob);
            sobs += ({ ob });
            if (ob->query_property("corpse bit") ||
                ob->query_property("money")) {
               gp--;
            } else if(base_name(ob) == "/obj/corpse" &&
                      !ob->query_property("already buried")) {
               gp += GP_INCREMENT;
               ob->add_property("already buried", 1);
               xp = ob->query_property("XP");
               if(xp && sizeof(xp) == 2) {
                 foreach(tmp in xp[0]) {
                   if(tmp)
                     tmp->adjust_xp(xp[1], 1);
                 }
               }
               ob->remove_property("XP");
            }
         } else {
            fobs += ({ ob });
         }
      } else {
         fobs += ({ ob });
      }
   }
   if (!sizeof(sobs)) {
      if (sizeof(fobs)) {
         if (member_array(TP, fobs) == -1) {
            add_failed_mess("You cannot bury " +
                            query_multiple_short(fobs)+".\n");
            return 0;
         } else {
            add_failed_mess("You cannot bury " +
                            query_multiple_short(fobs - ({TP}) +
                                                 ({"yourself"}))+
                            ".\n");
            return 0;
         }
      } else {
         add_failed_mess("You cannot find anything here to bury!\n");
         return 0;
      }
   }
   if (sizeof(too_many)) {
      write("You can only bury up to " + MAX_BURY_NUMBER +
            " items at a time, not burying " +
            query_multiple_short(too_many) + ".\n");
   }
   messages = environment(TP)->query_burial_message();
   if (messages) {
      write(replace_string(messages[0], "$objs$", query_multiple_short(sobs)));
      say(replace(messages[1], ({ "$N", TP->the_short(), "$objs$", query_multiple_short(sobs) })));
   } else if (environment(TP)->query_property("location") != "outside") {
      write("You tidy up the place, clearing away "+
            query_multiple_short(sobs)+".\n");
      say( (string)this_player()->one_short() +
           " tidies up the place, clearing away "+
           query_multiple_short( sobs ) +".\n" );
   } else {
      write("You bury "+query_multiple_short(sobs)+" deep within the earth.\n");
      say( (string)this_player()->one_short() +
           " buries "+ query_multiple_short( sobs ) +
           " deep within the ground.\n" );
   }
   TP->adjust_gp(gp);
   return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:object:here>", (: cmd($1) :),
            "",
            (: cmd(match_objects_for_existence("corpse", environment(TP))) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/countries.c ===
#define COUNTRIES_NO_SHOW_PROP "don't show on countries list"
mapping common_countries = ([
   "N/A" : ({ 0, "An unresolved address" }),
   "com" : ({ 0, "Commercial" }),
   "edu" : ({ 0, "Educational" }),
   "net" : ({ 0, "Network" }),
   "uk" : ({ 0, "United Kingdom" }),
   "au" : ({ 0, "Australia" })
   ]);
mapping all_countries = ([
   "ad" : ({ 0, "Andorra", }),
   "ae" : ({ 0, "United Arab Emirates" }),
   "af" : ({ 0, "Afghanistan" }),
   "ag" : ({ 0, "Antigua and Barbuda" }),
   "ai" : ({ 0, "Anguila" }),
   "al" : ({ 0, "Albania" }),
   "am" : ({ 0, "Armenia" }),
   "an" : ({ 0, "Netherlands Antilles" }),
   "ao" : ({ 0, "Angola" }),
   "aq" : ({ 0, "Antarctica" }),
   "ar" : ({ 0, "Argentina" }),
   "as" : ({ 0, "American Samoa" }),
   "at" : ({ 0, "Austria" }),
   "au" : ({ 0, "Australia" }),
   "aw" : ({ 0, "Aruba" }),
   "az" : ({ 0, "Azerbaijan" }),
   "ba" : ({ 0, "Bosnia and Herzegovina" }),
   "bb" : ({ 0, "Barbados" }),
   "bd" : ({ 0, "Bangladesh" }),
   "be" : ({ 0, "Belgium" }),
   "bf" : ({ 0, "Burkina Faso" }),
   "bg" : ({ 0, "Bulgaria" }),
   "bh" : ({ 0, "Bahrain" }),
   "bi" : ({ 0, "Burundi" }),
   "bj" : ({ 0, "Benin" }),
   "bm" : ({ 0, "Bermuda" }),
   "bn" : ({ 0, "Brunei Darussalam" }),
   "bo" : ({ 0, "Bolivia" }),
   "br" : ({ 0, "Brazil" }),
   "bs" : ({ 0, "Bahamas" }),
   "bt" : ({ 0, "Bhutan" }),
   "bv" : ({ 0, "Bouvet Island" }),
   "bw" : ({ 0, "Botswana" }),
   "by" : ({ 0, "Belarus" }),
   "bz" : ({ 0, "Belize" }),
   "ca" : ({ 0, "Canada" }),
   "cc" : ({ 0, "Cocos (Keeling) Islands" }),
   "cf" : ({ 0, "Central African Republic" }),
   "cg" : ({ 0, "Congo" }),
   "ch" : ({ 0, "Switzerland" }),
   "ci" : ({ 0, "Cote D'Ivoire (Ivory Coast)" }),
   "ck" : ({ 0, "Cook Island" }),
   "cl" : ({ 0, "Chile" }),
   "cm" : ({ 0, "Cameroon" }),
   "cn" : ({ 0, "China" }),
   "co" : ({ 0, "Colombia" }),
   "cr" : ({ 0, "Costa Rica" }),
   "cs" : ({ 0, "Czechoslovakia (former)" }),
   "cu" : ({ 0, "Cuba" }),
   "cv" : ({ 0, "Cape Verde" }),
   "cx" : ({ 0, "Christmas Island" }),
   "cy" : ({ 0, "Cyprus" }),
   "cz" : ({ 0, "Czech Republic" }),
   "de" : ({ 0, "Germany" }),
   "dk" : ({ 0, "Denmark" }),
   "dm" : ({ 0, "Dominica" }),
   "do" : ({ 0, "Dominican Republic" }),
   "dz" : ({ 0, "Algeria" }),
   "ec" : ({ 0, "Ecuador" }),
   "ee" : ({ 0, "Estonia" }),
   "eg" : ({ 0, "Egypt" }),
   "eh" : ({ 0, "Western Sahara" }),
   "er" : ({ 0, "Eritrea" }),
   "es" : ({ 0, "Spain" }),
   "et" : ({ 0, "Ethiopia" }),
   "fi" : ({ 0, "Finland" }),
   "fj" : ({ 0, "Fiji" }),
   "fk" : ({ 0, "Falkland Islands (Malvinas)" }),
   "fm" : ({ 0, "Micronesia" }),
   "fo" : ({ 0, "Faroe Islands" }),
   "fr" : ({ 0, "France" }),
   "fx" : ({ 0, "France, Metropolitan" }),
   "ga" : ({ 0, "Gabon" }),
   "gd" : ({ 0, "Grenada" }),
   "ge" : ({ 0, "Georgia" }),
   "gf" : ({ 0, "French Guiana" }),
   "gh" : ({ 0, "Ghana" }),
   "gi" : ({ 0, "Gibraltar" }),
   "gl" : ({ 0, "Greenland" }),
   "gm" : ({ 0, "Gambia" }),
   "gn" : ({ 0, "Guinea" }),
   "gp" : ({ 0, "Guadeloupe" }),
   "gq" : ({ 0, "Equatorial Guinea" }),
   "gr" : ({ 0, "Greece" }),
   "gs" : ({ 0, "S. Georgia and S. Sandwich Isls." }),
   "gt" : ({ 0, "Guatemala" }),
   "gu" : ({ 0, "Guam" }),
   "gw" : ({ 0, "Guinea-Bissau" }),
   "gy" : ({ 0, "Guyana" }),
   "hk" : ({ 0, "Hong Kong" }),
   "hm" : ({ 0, "Heard and McDonald Islands" }),
   "hn" : ({ 0, "Honduras" }),
   "hr" : ({ 0, "Croatia (Hrvatska)" }),
   "ht" : ({ 0, "Haiti" }),
   "hu" : ({ 0, "Hungary" }),
   "id" : ({ 0, "Indonesia" }),
   "ie" : ({ 0, "Ireland" }),
   "il" : ({ 0, "Israel" }),
   "in" : ({ 0, "India" }),
   "io" : ({ 0, "British Indian Ocean Territory" }),
   "iq" : ({ 0, "Iraq" }),
   "ir" : ({ 0, "Iran" }),
   "is" : ({ 0, "Iceland" }),
   "it" : ({ 0, "Italy" }),
   "jm" : ({ 0, "Jamaica" }),
   "jo" : ({ 0, "Jordan" }),
   "jp" : ({ 0, "Japan" }),
   "ke" : ({ 0, "Kenya" }),
   "kg" : ({ 0, "Kyrgyzstan" }),
   "kh" : ({ 0, "Cambodia" }),
   "ki" : ({ 0, "Kiribati" }),
   "km" : ({ 0, "Comoros" }),
   "kn" : ({ 0, "Saint Kitts and Nevis" }),
   "kp" : ({ 0, "Korea (North)" }),
   "kr" : ({ 0, "Korea (South)" }),
   "kw" : ({ 0, "Kuwait" }),
   "ky" : ({ 0, "Cayman Islands" }),
   "kz" : ({ 0, "Kazakhstan" }),
   "la" : ({ 0, "Laos" }),
   "lb" : ({ 0, "Lebanon" }),
   "lc" : ({ 0, "Saint Lucia" }),
   "li" : ({ 0, "Liechtenstein" }),
   "lk" : ({ 0, "Sri Lanka" }),
   "lr" : ({ 0, "Liberia" }),
   "ls" : ({ 0, "Lesotho" }),
   "lt" : ({ 0, "Lithuania" }),
   "lu" : ({ 0, "Luxembourg" }),
   "lv" : ({ 0, "Latvia" }),
   "ly" : ({ 0, "Libya" }),
   "ma" : ({ 0, "Morocco" }),
   "mc" : ({ 0, "Monaco" }),
   "md" : ({ 0, "Moldovia" }),
   "mg" : ({ 0, "Madagascar" }),
   "mh" : ({ 0, "Marshall Islands" }),
   "mk" : ({ 0, "Macedonia" }),
   "ml" : ({ 0, "Mali" }),
   "mm" : ({ 0, "Myanmar" }),
   "mn" : ({ 0, "Mongolia" }),
   "mo" : ({ 0, "Macau" }),
   "mp" : ({ 0, "Northern Mariana Islands" }),
   "mq" : ({ 0, "Martinique" }),
   "mr" : ({ 0, "Mauritania" }),
   "ms" : ({ 0, "Montserrat" }),
   "mt" : ({ 0, "Malta" }),
   "mu" : ({ 0, "Mauritius" }),
   "mv" : ({ 0, "Maldives" }),
   "mw" : ({ 0, "Malawi" }),
   "mx" : ({ 0, "Mexico" }),
   "my" : ({ 0, "Malaysia" }),
   "mz" : ({ 0, "Mozambique" }),
   "na" : ({ 0, "Namibia" }),
   "nc" : ({ 0, "New Caledonia" }),
   "ne" : ({ 0, "Niger" }),
   "nf" : ({ 0, "Norfolk Islands" }),
   "ng" : ({ 0, "Nigeria" }),
   "ni" : ({ 0, "Nicaragua" }),
   "nl" : ({ 0, "Netherlands" }),
   "no" : ({ 0, "Norway" }),
   "np" : ({ 0, "Nepal" }),
   "nr" : ({ 0, "Nauru" }),
   "nt" : ({ 0, "Neutral Zone" }),
   "nu" : ({ 0, "Niue" }),
   "nz" : ({ 0, "New Zealand (Aotearoa)" }),
   "om" : ({ 0, "Oman" }),
   "pa" : ({ 0, "Panama" }),
   "pe" : ({ 0, "Peru" }),
   "pf" : ({ 0, "French Polynesia" }),
   "pg" : ({ 0, "Papua New Guinea" }),
   "ph" : ({ 0, "Philippines" }),
   "pk" : ({ 0, "Pakistan" }),
   "pl" : ({ 0, "Poland" }),
   "pm" : ({ 0, "St. Pierre and Miquelon" }),
   "pn" : ({ 0, "Pitcairn" }),
   "pr" : ({ 0, "Puerto Rico" }),
   "pt" : ({ 0, "Portugal" }),
   "pw" : ({ 0, "Palau" }),
   "py" : ({ 0, "Paraguay" }),
   "qa" : ({ 0, "Qatar" }),
   "re" : ({ 0, "Reunion" }),
   "ro" : ({ 0, "Romania" }),
   "ru" : ({ 0, "Russian Federation" }),
   "rw" : ({ 0, "Rwanda" }),
   "sa" : ({ 0, "Saudi Arabia" }),
   "sb" : ({ 0, "Solomon Islands" }),
   "sc" : ({ 0, "Seychelles" }),
   "sd" : ({ 0, "Sudan" }),
   "se" : ({ 0, "Sweden" }),
   "sg" : ({ 0, "Singapore" }),
   "sh" : ({ 0, "St. Helena" }),
   "si" : ({ 0, "Slovenia" }),
   "sj" : ({ 0, "Svalbard and Jan Mayen Islands" }),
   "sk" : ({ 0, "Slovak Republic" }),
   "sl" : ({ 0, "Sierra Leone" }),
   "sm" : ({ 0, "San Marino" }),
   "sn" : ({ 0, "Senegal" }),
   "so" : ({ 0, "Somalia" }),
   "sr" : ({ 0, "Suriname" }),
   "st" : ({ 0, "Sao Tome and Principe" }),
   "su" : ({ 0, "USSR (former)" }),
   "sv" : ({ 0, "El Salvador" }),
   "sy" : ({ 0, "Syria" }),
   "sz" : ({ 0, "Swaziland" }),
   "tc" : ({ 0, "Turks and Caicos Islands" }),
   "td" : ({ 0, "Chad" }),
   "tf" : ({ 0, "French Southern Territories" }),
   "tg" : ({ 0, "Togo" }),
   "th" : ({ 0, "Thailand" }),
   "tj" : ({ 0, "Tajikistan" }),
   "tk" : ({ 0, "Tokelau" }),
   "tm" : ({ 0, "Turkmenistan" }),
   "tn" : ({ 0, "Tunisia" }),
   "to" : ({ 0, "Tonga" }),
   "tp" : ({ 0, "East Timor" }),
   "tr" : ({ 0, "Turkey" }),
   "tt" : ({ 0, "Trinidad and Tobago" }),
   "tv" : ({ 0, "Tuvalu" }),
   "tw" : ({ 0, "Taiwan" }),
   "tz" : ({ 0, "Tanzania" }),
   "ua" : ({ 0, "Ukraine" }),
   "ug" : ({ 0, "Uganda" }),
   "uk" : ({ 0, "United Kingdom" }),
   "um" : ({ 0, "US Minor Outlying Islands" }),
   "us" : ({ 0, "United States" }),
   "uy" : ({ 0, "Uruguay" }),
   "uz" : ({ 0, "Uzbekistan" }),
   "va" : ({ 0, "Vatican City State (Holy See)" }),
   "vc" : ({ 0, "Saint Vincent and the Grenadines" }),
   "ve" : ({ 0, "Venezuela" }),
   "vg" : ({ 0, "Virgin Islands (British)" }),
   "vi" : ({ 0, "Virgin Islands (U.S.)" }),
   "vn" : ({ 0, "Viet Nam" }),
   "vu" : ({ 0, "Vanuatu" }),
   "wf" : ({ 0, "Wallis and Futuna Islands" }),
   "ws" : ({ 0, "Samoa" }),
   "ye" : ({ 0, "Yemen" }),
   "yt" : ({ 0, "Mayotte" }),
   "yu" : ({ 0, "Yugoslavia" }),
   "za" : ({ 0, "South Africa" }),
   "zm" : ({ 0, "Zambia" }),
   "zr" : ({ 0, "Zaire" }),
   "zw" : ({ 0, "Zimbabwe" }),
   "com" : ({ 0, "Commercial" }),
   "edu" : ({ 0, "Educational" }),
   "gov" : ({ 0, "US Government" }),
   "int" : ({ 0, "International" }),
   "mil" : ({ 0, "US Military" }),
   "net" : ({ 0, "Network" }),
   "org" : ({ 0, "Non-Profit Organization" }),
   "arpa" : ({ 0, "Old Style Arpanet" }),
   "nato" : ({ 0, "NATO Field" })
   ]);
int cmd();
int handle_no_show( int hide );
string resolve_domain_suffix( object player );
int cmd() {
   int left, right, size;
   float percentage;
   object person, *users;
   string suffix, message, country;
   mixed *unsorted, *sorted, *data;
   mapping countries;
   countries = copy( common_countries );
   users = filter( users(), (: $1->query_visible( this_player() ) &&
      !$1->query_property( COUNTRIES_NO_SHOW_PROP ) :) );
   if( !size = sizeof( users ) ) {
      return notify_fail( "No visible players.\n" );
   }
   foreach( person in users ) {
      suffix = resolve_domain_suffix( person );
      if( undefinedp( countries[ suffix ] ) ) {
         if( undefinedp( all_countries[ suffix ] ) ) {
            countries[ "N/A" ][ 0 ] ++;
            continue;
         } else {
            common_countries += ([ suffix : all_countries[ suffix ] ]);
            countries += ([ suffix : copy( all_countries[ suffix ] ) ]);
         }
      }
      countries[ suffix ][ 0 ] ++;
   }
   unsorted = ({ });
   size -= countries[ "N/A" ][ 0 ];
   map_delete( countries, "N/A" );
   foreach( country, data in countries ) {
      if( !data[ 0 ] ) {
         map_delete( common_countries, country );
         continue;
      } else {
         data[ 1 ] += " (%^BOLD%^" + upper_case( country ) + "%^RESET%^)";
         unsorted += ({ data });
      }
   }
   sorted = sort_array( unsorted, -1 );
   message = "\nA total of %^BOLD%^" + query_num( size ) +
      "%^RESET%^ visible " + ( size != 1 ? "users" : "user" ) +
      " with resolvable addresses logged on:\n";
   left = this_player()->query_cols() / 3 * 2;
   left -= 3;
   right = this_player()->query_cols() - left;
   foreach( data in sorted ) {
      percentage = data[ 0 ] * 100.0 / size;
      message += sprintf( "   %-=*'.'s%*-=s\n",
      left, data[ 1 ],
      right, "  " + to_int( percentage + 0.5 ) + "%" );
   }
   this_player()->more_string( message );
   return 1;
}
string resolve_domain_suffix( object player ) {
   string addy, *host;
   addy = query_ip_name( player );
   if( !addy ) {
      return 0;
   }
   host = explode( lower_case( addy ), "." );
   return host[ sizeof( host ) - 1 ];
}
int handle_no_show( int hide ) {
   switch( hide ) {
      case 1:
         if( this_player()->query_property( COUNTRIES_NO_SHOW_PROP ) ) {
            tell_object( this_player(), "You are already hidden on the "
               "countries list.\n" );
            return 1;
         }
         this_player()->add_property( COUNTRIES_NO_SHOW_PROP, 1 );
         tell_object( this_player(), "You will no longer be included in "
            "the countries list.\n" );
         return 1;
      case 0:
         if( !this_player()->query_property( COUNTRIES_NO_SHOW_PROP ) ) {
            tell_object( this_player(), "You are already visible on "
               "the countries list.\n" );
            return 1;
         }
         this_player()->remove_property( COUNTRIES_NO_SHOW_PROP );
         tell_object( this_player(), "You will now be shown on the "
            "countries list.\n" );
         return 1;
      default:
         return notify_fail( "This shouldn't happen.\n" );
   }
}
mixed *query_patterns() {
   return ({ "", (: cmd() :),
             "hide", (: handle_no_show( 1 ) :),
             "show", (: handle_no_show( 0 ) :)
          });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/nickname.c ===
inherit "cmds/base";
int print_nicknames(mapping map_nicknames);
int add_nickname(string str, mapping map_nicknames);
int print_single_nickname(string str) {
  mapping map_nicknames;
  map_nicknames = previous_object()->query_nicknames();
  if (!map_nicknames) {
    map_nicknames = ([ ]);
  }
  str = lower_case(str);
  if(!map_nicknames[str]) {
    add_failed_mess("That nickname does not exist.\n");
    return 0;
  }
  write("Setting for nickname "+str+" is "+map_nicknames[str]+".\n");
  return 1;
}
int print_nicknames(int sorted) {
  int i;
  int cols;
  string str;
  string str_long;
  string str_middle;
  string str_small;
  string bit;
  string *tmp;
  mapping map_nicknames;
  map_nicknames = previous_object()->query_nicknames();
  bit = "";
  str_long = "";
  str_middle = "";
  str_small = "";
  if (!map_nicknames) {
    map_nicknames = ([ ]);
  }
  if (!sizeof(map_nicknames)) {
     write("You do not have any nicknames.\n");
     return 1;
  }
  tmp = sort_array(keys(map_nicknames), 1);
  cols = (int)this_player()->query_cols();
  for (i=0;i<sizeof(tmp);i++) {
    str = tmp[i]+": "+map_nicknames[tmp[i]]+"  ";
    if (strlen(str) > 39 || sorted) {
      str_long += sprintf(tmp[i]+": %-=*s\n", cols - strlen(tmp[i]), map_nicknames[tmp[i]]);
    } else if (strlen(str) > 19) {
      str_middle += str+"\n";
    } else {
      str_small += str+"\n";
    }
  }
  if (strlen(str_middle)) {
    str_long += sprintf("%-#*s\n", cols, str_middle);
  }
  if (strlen(str_small)) {
    str_long += sprintf("%-#*s\n", cols, str_small);
  }
  this_player()->more_string(str_long, "Nicknames");
  return 1;
}
int add_nickname(string s1, string s2) {
  mapping map_nicknames;
  s1 = lower_case(s1);
  s2 = lower_case(s2);
  if( member_array( s1, ({ "a", "an", "the" }) ) != -1 ) {
    add_failed_mess( "Using articles as nicknames confuses the parser.  "
                     "Choose another.\n" );
    return 0;
  }
  map_nicknames = previous_object()->query_nicknames();
  if (!map_nicknames) {
    map_nicknames = ([ ]);
  }
  if (!map_nicknames[s1]) {
    map_nicknames[s1] = s2;
    write("Added nickname "+s1+" for "+s2+".\n");
    return 1;
  }
  write("Changed nickname "+s1+" from "+map_nicknames[s1]+" to "+s2+".\n");
  map_nicknames[s1] = s2;
  this_player()->set_nicknames(map_nicknames);
  return 1;
}
mixed* query_patterns() {
   return ({ "", (: print_nicknames(0) :),
             "sorted", (: print_nicknames(1) :),
             "<string'nickname'>", (: print_single_nickname($4[0]) :),
             "<string'nickname'> <string'realname'>", (: add_nickname($4[0], $4[1]) :)
           });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/perm_it.c ===
inherit "/cmds/base";
int cmd( object player ) {
  object *corpses, corpse;
  int i;
  corpses = filter( children( "/obj/corpse" ),
                    (: $1 && $1->query_property("player" ) :) );
  corpses = filter( corpses,
                    (: $1 && $1->query_ownership() ==
                     $(this_player()->query_name()) :) );
  if( sizeof( corpses ) ) {
    foreach( corpse in corpses ){
      if(member_array(player->query_name(), corpse->query_permitted()) != -1) {
        i++;
      } else {
        corpse->give_permission( player->query_name() );
      }
    }
  } else {
    add_failed_mess("You don't seem to have a corpse!  Why not die and try "
                    "again?%^RESET%^\n");
    return 0;
  }
  if( i == sizeof( corpses ) ){
    write(capitalize(player->query_name()) + " is already permitted to "
          "remove items from your corpse.%^RESET%^\n" );
  } else {
    write(capitalize(player->query_name()) + " is now permitted to "
          "remove items from your corpse.%^RESET%^\n" );
    tell_object(player, "%^BOLD%^%^GREEN%^You now have permission to get "
                "items from " + this_player()->query_cap_name() +
                "'s corpse.%^RESET%^\n");
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:player>", (: cmd($1[0]) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/ear_muffs.c ===
#define TP this_player()
#include <player.h>
#include <newbiehelpers.h>
inherit "/cmds/base";
private string *_normal_types;
private string *_cre_types;
private string _player_format;
void create() {
   ::create();
   _normal_types = ({ "shout", "newbie", "cryer", "remote-soul",
         "multiple-soul", "multiple-tell",  "teach",
         "tell", "remote", "multiple-remote" });
   _cre_types = ({ "cre", "lord", "code", "liaison",
         "intermud-all", "intercre", "intergossip",
         "dwcre", "dwchat", "remote-spam", "newbiehelpers",
                     "verbose-logon"});
   _player_format = "{" + implode(_normal_types, "|") + "}";
}
int check_earmuffs() {
  string *on;
  string *types;
  on = TP->query_property(PLAYER_EARMUFF_PROP);
  if (!on) {
    on = ({ });
  }
  types = _normal_types;
  if (TP->query_creator()) {
    types += _cre_types + TP->channel_list();
  } else if (NEWBIEHELPERS_HANDLER->query_can_chat(TP)) {
    types += ({"newbiehelpers"});
  }
  if (TP->query_earmuffs()) {
    if (TP->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF) {
      printf("Your earmuffs are set to allow friends through.\n");
    } else {
      printf("Your earmuffs are on.\n");
    }
  } else {
    printf("Your earmuffs are off.\n");
  }
  if (!sizeof(on)) {
    printf("You have nothing set to be earmuffed.\n");
    write("$I$5=Earmuffable events are "+ query_multiple_short(types)+
          ".\n");
  } else {
    write("$I$5=You have "+ query_multiple_short(on)+ " earmuffed.\n");
    types -= on;
    if (sizeof(types)) {
      write("$I$5=You are not currently earmuffing "+
            query_multiple_short(types)+ " events.\n");
    }
  }
  return 1;
}
int do_earmuff_control(string str) {
  string *types;
  string *on;
  types = _normal_types;
  if (TP->query_creator()) {
    types += _cre_types + TP->channel_list();
  } else if (NEWBIEHELPERS_HANDLER->query_can_chat(TP)) {
    types += ({"newbiehelpers"});
  }
  on = TP->query_property(PLAYER_EARMUFF_PROP);
  if (!on) {
    on = ({ });
  }
  switch (str) {
    case "on" :
      if (!TP->query_earmuffs()) {
        TP->toggle_earmuffs();
      } else if (TP->query_allow_friends_earmuffs()) {
        TP->toggle_earmuffs();
        TP->toggle_earmuffs();
      }
      write("Earmuffs turned on.\n");
      break;
    case "off" :
      if (TP->query_earmuffs()) {
        TP->toggle_earmuffs();
      }
      write("Earmuffs turned off.\n");
      break;
    case "allowfriends" :
      TP->set_allow_friends_earmuffs();
      write("Earmuffs set to allow friends through.\n");
      break;
    case "all" :
      on = types;
      if (sizeof(on)) {
        write("$I$5=Your "+ query_multiple_short(on)+
              " events will now be earmuffed.\n");
      }
      break;
    case "none" :
      write("Nothing will be earmuffed any more.  (No news is good news?)\n");
      on = ({ });
      break;
  }
  TP->add_property(PLAYER_EARMUFF_PROP, on);
  return 1;
}
int do_earmuff(string str, string onOff) {
  string *types, *on, *off;
  types = _normal_types;
  if (TP->query_creator()) {
    types += _cre_types;
  }
  on = (string *)TP->query_property(PLAYER_EARMUFF_PROP);
  if (!on) {
    on = ({ });
  }
  off = ({ });
  switch (onOff) {
    case "on" :
      if (member_array(str, on) == -1) {
        on += ({ str });
      }
      write("You are now earmuffing " + str + " events.\n");
      break;
    case "off" :
      off += ({ str });
      write("You are not earmuffing " + str + " events anymore.\n");
      break;
    default :
      if (member_array(str, on) == -1) {
        on += ({ str });
        write("You are now earmuffing " + str + " events.\n");
      } else {
        off += ({ str });
        write("You are not earmuffing " + str + " events anymore.\n");
      }
      break;
  }
  on -= off;
  TP->add_property(PLAYER_EARMUFF_PROP, on);
  return 1;
}
mixed *query_patterns() {
  string cre_format;
  if (this_player()->query_creator()) {
    cre_format = "{" + implode(_normal_types +
                     _cre_types + this_player()->channel_list(), "|") + "}";
    return ({ "", (: check_earmuffs() :),
                "{on|off|all|none|allowfriends}",
                (: do_earmuff_control($4[0]) :),
                cre_format, (: do_earmuff($4[0], "") :),
                cre_format + " {on|off}", (: do_earmuff($4[0], $4[1]) :) });
  } else {
    if( NEWBIEHELPERS_HANDLER->query_can_chat(this_player()) ) {
      _player_format = "{" +
                       implode(_normal_types + ({"newbiehelpers"}), "|") + "}";
    }
    return ({ "", (: check_earmuffs() :),
                "{on|off|all|none|allowfriends}",
                (: do_earmuff_control($4[0]) :),
                _player_format, (: do_earmuff($4[0], "") :) ,
                _player_format + " {on|off}",
                (: do_earmuff($4[0], $4[1]) :) });
  }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/register.c ===
#include <player_handler.h>
#include <playerinfo.h>
inherit "/cmds/base";
int cmd(string alt) {
  string p1;
  string p2;
  alt = lower_case(alt);
  if (!PLAYER_HANDLER->test_user(alt))
    return notify_fail(alt + " is not a player.\n");
   p1 = PLAYERINFO_HANDLER->query_alt_of(this_player()->query_name());
   if(!p1 || p1 == "") {
     p1 = this_player()->query_name();
   }
   p2 = PLAYERINFO_HANDLER->query_alt_of(alt);
   if(!p2 || p2 == "") {
     p2 = alt;
   }
   if(p1 == p2) {
     add_failed_mess("You and " + alt + " are already registered.\n");
     return 0;
   }
   if(sizeof(PLAYERINFO_HANDLER->query_alts(p2)) &&
      sizeof(PLAYERINFO_HANDLER->query_alts(p1))) {
     add_failed_mess("Sorry, there is a clash of alts here, you'll need to "
                     "ask a creator for assistance.\n");
     return 0;
   }
  write("Enter your password (this character): ");
  input_to("get_pw", 1, this_player(), alt);
  return 1;
}
void get_pw(string pass, object player, string alt) {
  if (!PLAYER_HANDLER->test_password(player->query_name(), pass)) {
    write("Sorry, incorrect password.\n");
    return;
  }
  write("\nEnter the password for " + alt + ": ");
  input_to("get_alt_pw", 1, player, alt);
}
void get_alt_pw(string pass, object player, string alt) {
  string result;
  string p1, p2;
  write("\n");
  if(this_player() != player) {
    write("Something has gone wrong, player objects don't match.\n");
    return;
  }
  if (!PLAYER_HANDLER->test_password(alt, pass)) {
    write("Sorry, incorrect password.\n");
    return;
  }
  p1 = PLAYERINFO_HANDLER->query_alt_of(player->query_name());
  if(!p1 || p1 == "") {
    p1 = player->query_name();
  }
   p2 = PLAYERINFO_HANDLER->query_alt_of(alt);
   if(!p2 || p2 == "") {
     p2 = alt;
   }
   if(sizeof(PLAYERINFO_HANDLER->query_alts(p2))) {
     write("Registering " + p1 + " as an alt of " + p2 + ".\n");
     result = PLAYERINFO_HANDLER->add_alt(0, p2, p1);
   } else {
     write("Registering " + p2 + " as an alt of " + p1 + ".\n");
     result = PLAYERINFO_HANDLER->add_alt(0, p1, p2);
   }
   write(result);
}
int cmd_list() {
   string* alts;
   string p1;
   p1 = PLAYERINFO_HANDLER->query_alt_of(this_player()->query_name());
   if (!p1) {
      p1 = this_player()->query_name();
   }
   alts = (string*)PLAYERINFO_HANDLER->query_alts(p1) |
          (string*)PLAYERINFO_HANDLER->query_alt_of(this_player()->query_name());
   if (!sizeof(alts)) {
      write("No alts registered.\n");
      return 1;
   }
   write("Your registered alts are " + query_multiple_short(alts) + ".\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd_list :),
             "list", (: cmd_list :),
             "<word'alt-name'>", (: cmd($4[0]) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/news.c ===
#include <board.h>
inherit "/cmds/base";
object board;
string board_name = "announcements";
void do_list(int all);
int do_read(int num);
#define LOGON_LIMIT 10
#define MOST 1
#define ALL 2
#define SOME 0
mixed cmd(string str) {
  int msg;
  switch(str) {
  case "help":
  case "?":
  case "h":
    tell_object( this_player(),
                "Usage:\n"
                "To read next news item type: \"news\".\n"
                "To read a specific news item type: \"news <num>\".\n"
                "To list new news items type: \"news list\".\n"
                "To list all news items type: \"news review\".\n");
    break;
  case "l":
  case "list":
    do_list(MOST);
    break;
  case "r":
  case "review":
    do_list(ALL);
    break;
  default:
    if(str) sscanf(str, "%d", msg);
    do_read(msg);
  }
  return 1;
}
int do_read(int num) {
  mapping news_rc;
  mixed *stuff;
  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
  if ( !news_rc ) {
    news_rc = ([ ]);
  }
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if(!num) {
    num = sizeof(stuff);
    while((num > 0) && (stuff[num - 1][B_TIME] > news_rc[board_name])) {
      num--;
    }
    if(num == sizeof(stuff)) {
      write("No news is good news.\n");
      return 1;
    }
    num++;
  }
  if(num < 0) {
    num = sizeof(stuff) + num + 1;
  }
  if(( num < 1) || (num > sizeof(stuff))) {
    write("No news item of that number.\n");
    return 1;
  }
  num--;
  if(news_rc[ board_name ] < stuff[ num ][ B_TIME ]) {
    news_rc[ board_name ] = stuff[ num ][ B_TIME ];
    BOARD_HAND->set_newsrc(this_player()->query_name(), news_rc);
  }
  this_player()->more_string( "Note #"+ ( num + 1 ) +" posted at " +
        ctime(stuff[num][B_TIME])[0..9] + " Title: \""+
        stuff[ num ][ B_SUBJECT ][ 0 .. (int)this_player()->query_cols() -
       10 ] +"\"\n\n"+ (string)BOARD_HAND->get_message( board_name, num ),
       "[Note "+ ( num + 1 ) +"]" );
  return 1;
}
string the_date(int i) {
  return ctime(i)[4..9];
}
void do_list(int all) {
  int i, newones;
  mixed *stuff;
  string ret;
  mapping news_rc;
  ret = "";
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (!sizeof(stuff)) {
    tell_object(this_player(), "No news is good news.\n");
    return;
  }
  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
  if (!news_rc) {
    news_rc = ([ ]);
  }
  newones = 0;
  for (i = 0; i < sizeof(stuff); i++) {
    if (news_rc[board_name] < stuff[i][B_TIME]) {
      ret += sprintf("N %2d: %-=*s\n", i+1,
                     (int)this_player()->query_cols()-6,
                     stuff[i][B_SUBJECT]+" ("+the_date(stuff[i][B_TIME])+")");
      newones += 1;
      if (all == SOME) {
        if (newones > LOGON_LIMIT) {
          write("Plus more....\n");
          break;
        }
      }
    } else if(all == ALL) {
      ret += sprintf("  %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
                     stuff[i][B_SUBJECT]+" ("+the_date(stuff[i][B_TIME])+")");
    }
  }
  if(!newones && all != ALL) {
    ret += "\nNo news is good news.\n";
  }
  if (all == SOME) {
    ret += "\nUse 'news list' for all new news items and 'news review' for all news times.\n";
  }
  this_player()->more_string( ret, "News" );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/gather.c ===
#include <move_failures.h>
inherit "/cmds/base";
#define TP this_player()
int cmd( string str ) {
  object *items, *moved = ({ }), *left = ({ });
  int i;
  if( !stringp(str) || (str == "" )) {
    add_failed_mess("Syntax: gather <plant>\n");
    return 0;
  }
  items = "/obj/handlers/gathering"->gather_item(str, TP);
  if (!sizeof(items)) {
    if (str[<1] != 's') {
       str = pluralize(str);
    }
    add_failed_mess( "You couldn't find any " + str + ".\n");
    return 0;
  }
  for (i = 0; i < sizeof(items); i++) {
    if (items[i]->move(TP) == MOVE_OK) {
    moved += ({ items[i] });
  }  else
    if(items[i]->move(environment(TP)) == MOVE_OK) {
      left += ({ items[i] });
    } else {
      items[i]->move("/room/rubbish");
    }
  }
  if (sizeof(moved)) {
#ifdef NO_DECAY
    moved->set_decay_speed(0);
#endif
    add_succeeded_mess( "$N gather$s $I.\n", moved );
    event( environment( this_player() ), "gather", this_player(), str,
        moved );
  }
  left -= ({ this_player() });
  if (sizeof(left))
    write("You found but couldn't get " + query_multiple_short(left) + ".\n");
  return 1;
}
mixed query_patterns() {
  return ({ "<string>", (: cmd( $4[0] ) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/coverage.c ===
inherit "/cmds/base.c";
#define CLOTHING_HANDLER "/obj/handlers/clothing_handler"
private string _zone_patterns;
int cmd(object *items, int inverse, string bits)  {
   object   armor;
   object  *wearing;
   object  *fail = ({ });
   object  *armors;
   object  *covering;
   string  *types;
   string   equiv_type;
   string   type;
   string  *zones;
   string  *all_zones;
   string  *parts;
   string   zone;
   string   verb;
   string   mess;
   mapping  covered;
   mapping  pot_covered;
   all_zones = keys(CLOTHING_HANDLER->query_all_clothing_zones());
   covered = allocate_mapping(sizeof(all_zones));
   pot_covered = allocate_mapping(sizeof(all_zones));
   foreach (zone in all_zones)  {
      covered[zone] = ({ });
      pot_covered[zone] = ({ });
   }
   if (sizeof(items) == 0)
      armors = this_player()->query_armours();
   else
      armors = items;
   fail = filter(armors,
                 (: !$1->query_armour()  &&  !$1->query_clothing() :));
   armors -= fail;
   wearing = this_player()->query_wearing();
   if (bits)  {
      bits = replace(bits, " ", ",");
      bits = replace(bits, ",and,", ",");
      zones = explode(bits, ",") - ({ "" });
      parts = filter(zones, (: member_array($1, $(all_zones)) != -1 :));
      if (sizeof(parts) == 0)  {
         write("Please choose some combination of " +
               query_multiple_short(all_zones) + ".\n");
         return 1;
      }
   }
   foreach (armor in armors)  {
      if (!arrayp(armor->query_type()))
         types = ({ armor->query_type() });
      else
         types = armor->query_type();
      zones = ({ });
      foreach (type in types)  {
         equiv_type = CLOTHING_HANDLER->query_equivilant_type(type);
         if (equiv_type)
            zones += CLOTHING_HANDLER->query_zone_names(equiv_type);
         else
            zones += CLOTHING_HANDLER->query_zone_names(type);
      }
      if (sizeof(zones))  {
         if (member_array(armor, wearing) > -1)
            foreach (zone in zones)
               covered[zone] += ({ armor });
         else
            foreach (zone in zones)
               pot_covered[zone] += ({ armor });
      }
      else fail += ({ armor });
   }
   if (bits)  {
      covered = filter(covered, (: member_array($1, $(parts)) != -1 :));
      pot_covered = filter(pot_covered,
                           (: member_array($1, $(parts)) != -1 :));
   }
   if (inverse)  {
      zones = filter(all_zones, (: sizeof($(covered)[$1]) == 0 :));
      if (sizeof(zones) > 0)  {
         if (sizeof(zones) > 1  ||
             zones[0] == "arms"  ||  zones[0] == "hands"  ||
             zones[0] == "legs"  || zones[0] == "feet")
            verb = " are";
         else
            verb = " is";
         write("Your " + query_multiple_short(zones) + verb +
               " unprotected.\n");
      }
      else write("You are covered from head to foot.\n");
      return 1;
   }
   zones = sort_array(keys(covered) | keys(pot_covered), 1);
   foreach (zone in zones)  {
      if (zone == "arms"  ||  zone == "hands"  ||
          zone == "legs"  ||  zone == "feet")
         verb = " are";
      else
         verb = " is";
      if (sizeof(covering = covered[zone]) > 0)  {
         if (sizeof(covering) == 1)
            mess = "Your " + zone + verb + " protected by " +
                   covering[0]->one_short();
         else
            mess = "Your " + zone + verb + " protected by " +
                   query_num(sizeof(covering)) + " things, " +
                   query_multiple_short(covering, "one");
         if (sizeof(pot_covered[zone]) > 0)  {
            mess += " and could be protected by " +
                    query_multiple_short(pot_covered[zone], "one") + ".\n";
            pot_covered[zone] = ({ });
         }
         else mess += ".\n";
         write(mess);
      }
      else if (sizeof(covering = pot_covered[zone]) > 0)  {
         write("Your " + zone + " could be protected by " +
               query_multiple_short(covering, "one") + ".\n");
      }
      else if (bits) write("Your " + zone + verb + " unprotected.\n");
   }
   if (sizeof(fail) != 0  &&  sizeof(items) != 0)  {
      if (sizeof(fail) == 1  &&  fail[0] == this_player())
         write("You don't offer any protection.  Perhaps you should invest "
               "in some sonkies?\n");
      else
         write(query_multiple_short(fail, "the") +
               (sizeof(fail) == 1 ? " doesn't" : " don't") +
               " offer any protection.\n");
   }
   else if (sizeof(armors - fail) == 0)
      write("You are completely unprotected.  Good luck!\n");
   return 1;
}
mixed *query_patterns()  {
   return ({ "", (: cmd(({ }), 0, 0) :),
             "[by] <indirect:object'armour/clothing'>", (: cmd($1, 0, 0) :),
             "unprotected", (: cmd(({ }), 1, 0) :),
             "of <string'body part(s)'>", (: cmd(({ }), 0, $4[0]) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/bugcheck.c ===
#define WEIRD_OBJECT_LOG "/log/secure/playtesters/bugcheck-weird-objects"
inherit "/cmds/base";
varargs int cmd(object *obs) {
    string* s;
    string txt;
    foreach ( object ob in obs ) {
        if ( stringp( ob->query_property( "virtual name" ) ) )
            s = explode( ob->query_property( "virtual name" ), "/" );
        else
            s = explode( base_name( ob ), "/" );
        switch ( s[ 0 ] ) {
        case "d":
            write(capitalize( ob->the_short() ) +
                         " is a domain thing.  It's probably safe to "
                         "bugrep it directly.\n" );
            break;
        case "w":
            write(capitalize( ob->the_short() ) +
                         "... why do you have a creator item?\n" );
            log_file ("ILLEGAL_OBJECT", "%s: %s tried to bugcheck %s.\n\n",
              ctime(time()), this_player()->query_name(), base_name (ob));
            break;
        case "std":
            write(capitalize( ob->the_short() ) +
                         " is a weird MUD library thing.  If you bugrep "
                         "it, the response might be slow.  It may be a "
                         "better idea to bugrep the room that the object "
                         "was found in.\n" );
            break;
        case "obj":
          switch (s[1]) {
            case "weapons":
            case "armours":
            case "clothes":
            case "food":
            case "jewellery":
              write(capitalize( ob->the_short() ) +
                         " is a Disc-wide item, but belongs to a directory "
                         "that is checked regularly.  Best to make the "
                         "bugrep directly on the item.\n" );
            break;
            default:
              write(capitalize( ob->the_short() ) +
                         " is a fairly general Disc-wide object.  If you "
                         "bugrep it, the response might be slow.  It would "
                         "most likely be a better idea to bugrep the room "
                         "in which the object was found.\n" );
            break;
          }
        break;
        case "global":
          switch (s[1]) {
            case "player":
            case "lord":
            case "playtester":
              if ( ob == this_player() ) {
                  txt = "are";
              }
              else {
                  txt = "is";
              }
              write(capitalize( ob->the_short() ) +
                         " " + txt + " the general " + s[1] + " object... if your "
                         "bugrep is on this, then bugrep this object.  If "
                         "your bugrep is along the frivolous lines of '"
                         + ob->the_short() +" " + txt + " overpowered!', "
                         "then don't "
                         "bugreport it... be sure and raise the issue on the "
                         "nearest bulletin board.\n" );
            break;
          }
        break;
        default:
            write("I've got no idea about " +
                         ob->the_short() + ".  Sorry it didn't work out.\n" );
            log_file( WEIRD_OBJECT_LOG, implode( s, "/" ) + "\n" );
            break;
        }
    }
    return 1;
}
int cmd_room() {
   write("Bug report the room for anything that seems to be odd in the room, "
         "descriptions being wrong, items you look at being wrong.  Anything "
         "odd you see that does not seem to fit anywhere else should also be "
         "reported to the room.\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:'thing'>", (: cmd($1) :),
             "here", (: cmd_room :)
    });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/recover.c ===
#include <obj_parser.h>
inherit "/cmds/base";
#include <move_failures.h>
#include <cmds/bury.h>
#include <playtesters.h>
#include <player.h>
#define MAX_RECOVER 20
int cmd_recover(string name) {
   object* obs;
   object* fail;
   object* ok_me;
   object* ok_here;
   object cont;
   object ob;
   class obj_match omatch;
#ifdef PT
   if (!PLAYTESTER_HAND->query_playtester(this_player()->query_name()) &&
       !this_player()->query_creator()) {
      add_failed_mess("This command is in play testing at the moment.\n");
      return 0;
   }
#endif
   if (this_player()->query_property("dead")) {
      add_failed_mess("You're a disembodied spirit, how do you expect to "
                      "recover anything at all?\n");
      return 0;
   }
   cont = BURY_EFFECT->query_buried_container(environment(this_player()));
   if (!cont) {
      add_failed_mess("There is nothing buried here.\n");
      return 0;
   }
   omatch = (class obj_match)match_objects_in_environments(name, cont);
   if (omatch->result != OBJ_PARSER_SUCCESS) {
      add_failed_mess(match_objects_failed_mess(omatch));
      return 0;
   }
   obs = omatch->objects;
   if ( sizeof( obs ) > MAX_RECOVER ) {
      add_failed_mess( "You can only recover " +
        query_num( MAX_RECOVER ) + " items at a time.\n" );
      return 0;
   }
   fail = ({ });
   ok_me = ({ });
   ok_here = ({ });
   if (sizeof(obs)) {
      foreach (ob in obs) {
#ifndef __DISTRIBUTION_LIB__
        if(interactive(this_player()) &&
           PLAYER_MULTIPLAYER_HANDLER->check_multiplayers("recover",
                                                           this_player(),
                                                           ob)) {
          fail += ({ ob });
        } else
#endif
         if (ob->move(this_player()) == MOVE_OK) {
            ok_me += ({ ob });
         } else if (ob->move(environment(this_player())) == MOVE_OK) {
            ok_here += ({ ob });
         } else {
            fail += ({ ob });
         }
      }
      if (!sizeof(ok_me) && !sizeof(ok_here)) {
         add_failed_mess("Unable to recover $I.\n", fail);
         return 0;
      }
      if (sizeof(ok_me)) {
         add_succeeded_mess("$N $V $I.\n", ok_me);
      }
      if (sizeof(ok_here)) {
         add_succeeded_mess("$N $V $I and leave$s " +
                            (sizeof(ok_here) > 1?"them":"it") +
                            " here.\n", ok_here);
      }
      return 1;
   } else {
      ok_me = all_inventory(cont);
      if (sizeof(ok_me)) {
         add_failed_mess("Unable to recover " + name + ", available objects "
                       "are " + query_multiple_short(ok_me) +
                      ".\n");
      } else {
         add_failed_mess("Unable to recover " + name + ".\n");
      }
      return 0;
   }
}
mixed* query_patterns() {
   return ({ "<string'buried object'>", (: cmd_recover($4[0]) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/email.c ===
#include <player.h>
inherit "/cmds/base";
#define TP this_player()
int cmd(string str) {
   string email;
  email = TP->query_email();
   if (!str) {
      write("Your current email address is "+email+"\n");
      write("To clear use \"email CLEAR\"\n");
      write("For the email address to be only visible by lords prepend a :\n");
      write("eg email :frog@frogcentral.froguni.swamp\n");
      return 1;
   }
   if (str == "CLEAR")
      email = "";
   else
      email = str;
   if (email != "")
      write("Email address set to "+str+".\n");
   else
      write("Email address is null.\n");
   TP->set_email(email);
   return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/player/rituals.c ===
#include <spells.h>
inherit "/cmds/base";
int cmd( string words ) {
   string spell, *religious;
   mapping spells;
   spells = this_player()->query_spells();
   if ( !sizeof( spells ) ) {
      write( "You don't know any religious rituals.\n" );
      return 1;
   }
   religious = ({ });
   foreach ( spell in keys( spells ) ) {
      if ( sscanf( spells[ spell ][ 0 ], "%*spriest%*s" ) == 2 ) {
         religious += ({ spell });
         continue;
      }
      if ( sscanf( spells[ spell ][ 0 ], "%*srituals%*s" ) == 2 ) {
         religious += ({ spell });
         continue;
      }
      if ( sscanf( spells[ spell ][ 0 ], "%*swizard%*s" ) == 2 )
         continue;
      if ( sscanf( spells[ spell ][ 0 ], "%*switch%*s" ) == 2 )
         continue;
      if ( sscanf( spells[ spell ][ 0 ], "%*sspell%*s" ) == 2 )
         continue;
   }
   if ( !sizeof( religious ) ) {
      write( "You don't know any religious rituals.\n" );
      return 1;
   }
   if ( sizeof( religious ) ) {
      write( "You know the following religious ritual"+
            ( sizeof( religious ) == 1 ? "" : "s" ) +":\n" );
      printf( "%#-*s\n", (int)this_player()->query_cols(),
            implode( sort_array( religious, 1 ), "\n" ) );
   }
   return 1;
}
