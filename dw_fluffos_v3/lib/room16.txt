
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/terrain_map/air_base.c ===
#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>
inherit "/std/room/outside";
inherit TERRAIN_MAP_ROOM_BASE;
void create() {
   set_not_replaceable(1);
   terrain_room::create();
   outside::create();
}
void init() {
   terrain_room::init();
   outside::init();
}
varargs mixed* query_dest_other(string exit) {
   mixed* data;
   data = outside::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}
mixed* query_dest_dir(object thing) {
   mixed* data;
   data = outside::query_dest_dir(thing);
   return terrain_room::query_dest_dir(data);
}
mixed stats() {
   return outside::stats() + terrain_room::stats();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/terrain_map/geometry.c ===
class point {
   int x;
   int y;
}
#define SMALL_NUM 0.00001
class point intersection_of_line_and_segment(int lx1, int ly1, int lx2, int ly2,
                                             int sx1, int sy1, int sx2, int sy2) {
   float den;
   float uanum;
   float ubnum;
   float ua;
   float ub;
   class point p;
   den = to_float(sy2 - sy1) * to_float(lx2 - lx1) - to_float(sx2 - sx1) * to_float(ly2 - ly1);
   if (den == 0.0) {
      return 0;
   }
   ubnum = to_float(lx2 - lx1) * to_float(ly1 - sy1) - to_float(ly2 - ly1) * to_float(lx1 - sx1);
   ub = ubnum / den;
   if (ub < 0.0 || ub > 1.0) {
      return 0;
   }
   uanum = to_float(sx2 - sx1) * to_float(ly1 - sy1) - to_float(sy2 - sy1) * to_float(lx1 - sx1);
   ua = uanum / den;
   p = new(class point);
   p->x = lx1 + to_int(ua * (lx2 - lx1));
   p->y = ly1 + to_int(ub * (ly2 - ly1));
   return p;
}
int distance_point_to_line_segment(int x1, int y1, int x2, int y2,
                           int point_x, int point_y) {
   float v1_x;
   float v1_y;
   float v2_x;
   float v2_y;
   float distance;
   float dot1;
   float dot2;
   float b;
   float vm_x;
   float vm_y;
   v1_x = to_float(x1 - x2);
   v1_y = to_float(y1 - y2);
   v2_x = to_float(point_x - x2);
   v2_y = to_float(point_y - y2);
   dot1 = v1_x * v2_x + v1_y * v2_y;
   if (dot1 <= 0.0) {
      distance = sqrt(pow(x2 - point_x, 2) + pow(y2 - point_y, 2));
   } else {
      dot2 = v1_x * v1_x + v1_y * v1_y;
      if (dot2 <= dot1) {
         distance = sqrt(pow(x1 - point_x, 2) + pow(y1 - point_y, 2));
      } else {
         b = dot1 / dot2;
         vm_x = to_float(x2) + b * v1_x;
         vm_y = to_float(y2) + b * v1_y;
         distance = sqrt(pow(vm_x - point_x, 2) + pow(vm_y - point_y, 2));
      }
   }
   return to_int(distance);
}
int distance_between_two_line_segments(
     int x1_1, int y1_1, int x2_1, int y2_1,
     int x1_2, int y1_2, int x2_2, int y2_2) {
   float ux;
   float uy;
   float vx;
   float vy;
   float wx;
   float wy;
   float dpx;
   float dpy;
   float a;
   float b;
   float c;
   float d;
   float e;
   float dist;
   float sc;
   float sn;
   float sd;
   float tc;
   float tn;
   float td;
   ux = to_float(x2_1) - to_float(x1_1);
   uy = to_float(y2_1) - to_float(y1_1);
   vx = to_float(x2_2) - to_float(x1_2);
   vy = to_float(y2_2) - to_float(y1_2);
   wx = to_float(x1_1) - to_float(x1_2);
   wy = to_float(y1_1) - to_float(y1_2);
   a = ux * ux + uy * uy;
   b = ux * vx + uy * vy;
   c = vx * vx + vy * vy;
   d = ux * wx + uy * wy;
   e = vx * wx + vy * wy;
   dist = a * c - b * b;
   sd = dist;
   td = dist;
   if (dist < SMALL_NUM) {
      sn = 0.0;
      sd = 1.0;
      tn = e;
      td = c;
   } else {
      sn = b * e - c * d;
      tn = a * e - b * d;
      if (sn < 0.0) {
         sn = 0.0;
         tn = e;
         td = c;
      } else if (sn > sd) {
         sn = sd;
         tn = e + b;
         td = c;
      }
      if (tn < 0.0) {
         tn = 0.0;
         if (-d < 0.0) {
            sn = 0.0;
         } else if (-d > a) {
            sn = sd;
         } else {
            sn = -d;
            sd = a;
         }
      } else if (tn > td) {
         tn = td;
         if ((-d + b) < 0) {
            sn = 0.0;
         } else if ((-d + b) > a) {
            sn = sd;
         } else {
            sn = -d + b;
            sd  = a;
         }
      }
   }
   sc = sn / sd;
   tc = tn / td;
   dpx = wx + (sc * ux) - (tc * vx);
   dpy = wy + (sc * uy) - (tc * vy);
   dist = sqrt(dpx * dpx + dpy * dpy);
   if (dist > pow(2, 30)) {
      return to_int(pow(2, 30));
   }
   return to_int(sqrt(dpx  * dpx + dpy * dpy));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/terrain_map/simple_feature.c ===
#include <terrain_map.h>
inherit TERRAIN_MAP_FEATURE_BASE;
private string _base_desc;
private int _very_close_distance;
private int _distance_multiplier = 1;
void set_very_close_distance(int close) {
   _very_close_distance = close;
}
string query_base_description() {
   return _base_desc;
}
void set_base_description(string desc) {
   _base_desc = desc;
}
void set_distance_multiplier(int mult) {
   _distance_multiplier = mult;
}
string calc_feature_desc(mapping direcs, int night, int visibility) {
   string direc;
   int dist;
   int new_dist;
   string* bits;
   bits = ({ });
   if(visibility < 1 && visibility != -1)
     visibility = 1;
   foreach (direc, dist in direcs) {
      dist += query_range_offset() ;
      new_dist = dist * 100 / visibility;
      if (visibility == -1 ||
          (new_dist < query_max_range() && dist > query_min_range())) {
         if (dist < _very_close_distance) {
            bits += ({ "very close to the " + direc });
         } else {
            bits += ({ query_distance_str(dist * _distance_multiplier) + " to the " + direc });
         }
      }
   }
   if (sizeof(bits) > 1) {
      return implode(bits[0..<2], ", ") + " and " + bits[<1] + " " +_base_desc;
   }
   if (sizeof(bits)) {
      return bits[0] + " " + _base_desc;
   }
   return 0;
}
string calc_map_feature_desc(mapping direcs, int fudge) {
   string direc;
   int dist;
   string* bits;
   bits = ({ });
   foreach (direc, dist in direcs) {
      dist += query_range_offset();
      if (dist < _very_close_distance * 5) {
        bits += ({ "very close to the " + direc });
      } else {
        bits += ({ ({"approximately ", "about ", "roughly "})[random(3)] +
                     query_distance_str(dist * _distance_multiplier) +
                     " to the " + direc });
      }
   }
   if (sizeof(bits) > 1) {
      return implode(bits[0..<2], ", ") + " and " + bits[<1] + " " +_base_desc;
   }
   if (sizeof(bits)) {
      return bits[0] + " " + _base_desc;
   }
   return 0;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/terrain_map/map ===
-   -    -
 -  -   - 
  - -  -  
   -- -   
----------
    --    
   -- -   
  - -  -  
 -  -   - 
-   -    -


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/terrain_map/factory_base.c ===
#include <terrain_map.h>
private int _room_jump_size;
private int _follow_road;
private int _default_height;
private int _min_height;
private string _adjacent_desc;
private mapping _height_info;
private mapping _adjacent_items;
void create() {
   _adjacent_items = ([ ]);
}
void set_room_jump_size(int jump) {
   _room_jump_size = jump;
}
int query_room_jump_size() {
   return _room_jump_size;
}
void set_follow_road(int follow) {
  _follow_road = follow;
}
int query_follow_road() {
   return _follow_road;
}
void set_default_height(int height) {
   _default_height = height;
}
void set_adjacent_description(string desc) {
   _adjacent_desc = desc;
}
string query_adjacent_description() {
   return _adjacent_desc;
}
int query_default_height() {
   return _default_height;
}
void set_minimum_height(int height) {
   _min_height = height;
}
int query_minimum_height() {
   return _min_height;
}
void set_height_rooms(mapping map) {
   _height_info = map;
}
string find_base_terrain_room(int x, int y, int z, string base_name, int map_room, string ref base) {
   if (_height_info && _height_info[z]) {
      return _height_info[z];
   }
   if (z > _default_height) {
      if (map_room == TERRAIN_MAP_ROOM_CLIMB) {
         return 0;
      }
      if (map_room == TERRAIN_MAP_ROOM_EXACT) {
         return TERRAIN_MAP_DEFAULT_AIR_ROOM;
      }
      if (!_height_info) {
         return base_name;
      }
      return _height_info[_default_height];
   }
   if (!_height_info) {
      if (z == _default_height) {
         return base_name;
      }
      return 0;
   }
   if (_min_height > z) {
      return 0;
   }
   if (z == _default_height) {
      return base_name;
   }
   return _height_info["default"];
}
void add_adjacent_item(string name, string desc) {
   _adjacent_items[name] = desc;
}
mapping query_adjacent_items() {
   return _adjacent_items;
}
mixed stats() {
   return ({
  ({ "room jump", _room_jump_size }),
  ({ "follow road", _follow_road }),
  ({ "adjacent desc", _adjacent_desc }) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/terrain_map/water_inside_base.c ===
#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>
inherit "/std/room/water_inside";
inherit TERRAIN_MAP_ROOM_BASE;
void create() {
   set_not_replaceable(1);
   terrain_room::create();
   water_inside::create();
}
void init() {
   terrain_room::init();
   water_inside::init();
}
varargs mixed* query_dest_other(string exit) {
   mixed* data;
   data = water_inside::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}
mixed* query_dest_dir(object thing) {
   mixed* data;
   data = water_inside::query_dest_dir(thing);
   return terrain_room::query_dest_dir(data);
}
mixed stats() {
   return water_inside::stats() + terrain_room::stats();
}
string query_terrain_map_walk_exit() {
   return "swim ";
}
object query_surface_room() {
  string dest_path;
  object destination;
  if (query_surface()) {
    return this_object();
  }
  dest_path = file_name(this_object());
  dest_path = implode(explode(dest_path, ":")[0..<2], ":")+":0";
  destination = load_object(dest_path);
  if (destination && destination->query_water()) {
    return destination->query_surface_room();
  }
  return ::query_surface_room();
}
int get_water_surface_light() {
  float their_light, their_clarity, our_depth;
  string above_path = file_name(this_object());
  object above;
  above_path = implode(explode(above_path, ":")[0..<2], ":")+":0";
  above = load_object(above_path);
  if (!above) {
    return 0;
  }
  if (function_exists("query_water_surface_light", above)) {
    their_light = to_float(above->query_water_surface_light());
  } else {
    their_light = to_float(above->query_my_light());
  }
  their_clarity = to_float(above->query_clarity())/100.0;
  our_depth = to_float(-query_terrain_coords()[2]);
  return to_int(their_light * pow(their_clarity, our_depth));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/terrain_map/water_outside_base.c ===
#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>
inherit "/std/room/water_outside";
inherit TERRAIN_MAP_ROOM_BASE;
void create() {
   set_not_replaceable(1);
   terrain_room::create();
   water_outside::create();
}
void init() {
   terrain_room::init();
   water_outside::init();
}
varargs mixed* query_dest_other(string exit) {
   mixed* data;
   data = water_outside::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}
mixed* query_dest_dir(object thing) {
   mixed* data;
   data = water_outside::query_dest_dir(thing);
   return terrain_room::query_dest_dir(data);
}
mixed stats() {
   return water_outside::stats() + terrain_room::stats();
}
string query_terrain_map_walk_exit() {
   return "swim ";
}
object query_surface_room() {
  string dest_path;
  object destination;
  if (query_surface()) {
    return this_object();
  }
  dest_path = file_name(this_object());
  dest_path = implode(explode(dest_path, ":")[0..<2], ":")+":0";
  destination = load_object(dest_path);
  if (destination && destination->query_water()) {
    return destination->query_surface_room();
  }
  return ::query_surface_room();
}
int get_water_surface_light() {
  float their_light, their_clarity, our_depth;
  string above_path = file_name(this_object());
  object above;
  above_path = implode(explode(above_path, ":")[0..<2], ":")+":0";
  above = load_object(above_path);
  if (!above) {
    return 0;
  }
  if (function_exists("query_water_surface_light", above)) {
    their_light = to_float(above->query_water_surface_light());
  } else {
    their_light = to_float(above->query_my_light());
  }
  their_clarity = to_float(above->query_clarity())/100.0;
  our_depth = to_float(-query_terrain_coords()[2]);
  return to_int(their_light * pow(their_clarity, our_depth));
}
string query_enter_exit_direction(string key, string key_here, string direct,
                                  object room, string base_path) {
   if (!room->query_water()) {
      return "wade " + direct;
   }
   return 0;
}
int can_move_between(string my_type, string direc,
                     string first_type, string second_type, string new_base_path)
{
   return first_type->query_water() && second_type->query_water() &&
          new_base_path->query_water() ||
          (!new_base_path->query_water() &&
           (!first_type->query_water() || !second_type->query_water()));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/terrain_map/inside_base.c ===
#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>
inherit "/std/room/basic_room";
inherit TERRAIN_MAP_ROOM_BASE;
void create() {
   set_not_replaceable(1);
   terrain_room::create();
   basic_room::create();
}
void init() {
   terrain_room::init();
   basic_room::init();
}
varargs mixed* query_dest_other(string exit) {
   mixed* data;
   data = basic_room::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}
mixed* query_dest_dir(object thing) {
   mixed* data;
   data = basic_room::query_dest_dir(thing);
   return terrain_room::query_dest_dir();
}
mixed stats() {
   return basic_room::stats() + terrain_room::stats();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/terrain_map/feature_local.c ===
#include <terrain_map.h>
inherit TERRAIN_MAP_SIMPLE_FEATURE_BASE;
inherit "/std/basic/setup";
private string* _items;
private string* _night_descs;
private string* _day_descs;
void create() {
   _items = ({ });
   _night_descs = ({ });
   _day_descs = ({ });
   do_setup();
   do_reset();
}
void add_item(string item, string day, string night) {
   _items += ({ item });
   _night_descs += ({ night });
   _day_descs += ({ day });
}
string* query_items() {
   return _items;
}
string* query_day_items() {
   return _day_descs;
}
string* query_night_items() {
   return _night_descs;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/terrain_map/distance_str.c ===
#include <terrain_map.h>
private string query_distance_str_int(int dist, int show_one) {
   if (dist < 3) {
      if (dist > 1) {
         return query_num(dist) + " feet";
      } else if (show_one) {
         return "one foot";
      } else {
         return "foot";
      }
   } else if (dist < TERRAIN_MAP_HALF_MILE) {
      dist /= 3;
      if (dist > 50) {
         dist = dist / 50 * 50;
      }
      if (dist > 1) {
         return query_num(dist) + " yards";
      }
      if (show_one) {
         return "one yard";
      } else {
         return "yard";
      }
   } else if (dist < TERRAIN_MAP_ONE_MILE) {
      return "half mile";
   } else {
      dist /= TERRAIN_MAP_ONE_MILE;
      if (dist > 10) {
         dist = dist / 10 * 10;
      }
      if (dist > 100) {
         dist = dist / 50 * 50;
      }
       if (dist > 1000) {
         dist = dist / 500 * 500;
      }
      if (dist > 1) {
         return query_num(dist) + " miles";
      } else {
         if (show_one) {
            return "one mile";
         } else {
            return "mile";
         }
      }
   }
}
string query_distance_str(int dist) {
   return query_distance_str_int(dist, 1);
}
string query_distance_str_no_ones(int dist) {
   return query_distance_str_int(dist, 0);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/terrain_map/outside_base.c ===
#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>
inherit "/std/room/outside";
inherit TERRAIN_MAP_ROOM_BASE;
void create() {
   set_not_replaceable(1);
   do_setup++;
   terrain_room::create();
   outside::create();
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
     this_object()->reset();
   }
}
void init() {
   terrain_room::init();
   outside::init();
}
varargs mixed* query_dest_other(string exit) {
   mixed* data;
   data = outside::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}
mixed* query_dest_dir(object thing) {
   mixed* data;
   data = outside::query_dest_dir(thing);
   return terrain_room::query_dest_dir(data);
}
mixed stats() {
   return outside::stats() + terrain_room::stats();
}
void dest_me() {
  terrain_room::dest_me();
  outside::dest_me();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/terrain_map/region_rect.c ===
inherit "/std/room/inherit/terrain_map/geometry";
class feature_pos {
   int xstart;
   int ystart;
   int width;
   int height;
}
private mixed    *_feature_direcs = ({ ({ "southwest", "south", "southeast" }),
                               ({ "west", "Oops", "east" }),
                               ({ "northwest", "north", "northeast" }) });
private class feature_pos* _positions = ({ });
void add_feature_position(int x, int y, int width, int height) {
   class feature_pos pos;
   pos = new(class feature_pos, xstart : x, ystart : y,
                                width : width, height : height);
   _positions += ({ pos });
}
mapping query_feature_desc_from(int x, int y, int z) {
   int h;
   int v;
   int width;
   int height;
   float distance;
   float min_distance;
   string direc;
   class feature_pos pos;
   float xmod;
   float ymod;
   int xd;
   int yd;
   foreach (pos in _positions) {
      h = pos->xstart;
      v = pos->ystart;
      width = pos->width;
      height = pos->height;
      if (x >= (h + width)) {
         h = h + width - 1;
      } else if (x >= h) {
         h = x;
      }
      if (y >= (v + height)) {
         v = v + height - 1;
      } else if (y >= v) {
         v = y;
      }
      distance = sqrt(pow(x - h, 2) + pow(y - v, 2));
      if (distance > 0.0000001 && (distance < min_distance || !min_distance)) {
         xmod = ((h - x) < 0) ? -0.5 : 0.5;
         ymod = ((v - y) < 0) ? -0.5 : 0.5;
         xd = to_int(xmod + to_float(h - x) / distance) + 1;
         yd = to_int(ymod + to_float(v - y) / distance) + 1;
         direc = _feature_direcs[yd][xd];
         min_distance = distance;
      }
   }
   if (!direc) {
      return ([ ]);
   }
   return ([ direc : to_int(min_distance) ]);
}
void dest_me() {
   destruct(this_object());
}
int is_inside_region(int x1, int y1, int x2, int y2, int range) {
   class feature_pos position;
   int height;
   int width;
   foreach (position in _positions) {
      height = position->height;
      width = position->width;
      if (position->xstart >= x1 && position->xstart <= x2 &&
          position->ystart >= y1 && position->ystart <= y2) {
         return 1;
      }
      if (position->xstart >= x1 && position->xstart <= x2 &&
          position->ystart + height >= y1 && position->ystart + height <= y2) {
         return 1;
      }
      if (position->xstart +width >= x1 && position->xstart +width <= x2 &&
          position->ystart + height >= y1 && position->ystart + height <= y2) {
         return 1;
      }
      if (position->xstart +width >= x1 && position->xstart +width <= x2 &&
          position->ystart >= y1 && position->ystart <= y2) {
         return 1;
      }
   }
   return 0;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/carriage/carriage.c ===
#include <room/carriage.h>
#define DEFAULT_WAIT 60
#define DEFAULT_TRAVEL 45
inherit "/std/room/basic_room";
private class route_details _route_info;
private string _carriage_name;
private string _exit_name;
private int _current_stop;
private int _next_stop;
private object _outside;
private object _fake_carriage;
private object _bell;
private object _car_driver;
private object _handler;
private string _n_name;
private string _p_name;
int do_ring();
string query_environ_long();
void create() {
    do_setup++;
    ::create();
    do_setup--;
    set_light(60);
    set_keep_room_loaded(1);
    set_short( "inside a carriage" );
    add_property( "no teleport", 1 );
    add_property("determinate", "");
    add_property("no map", 1);
    add_property("no godmother", 1);
   add_item("window", (: query_environ_long :) );
   add_item( "carriage", "The carriage looks fairly old and barely "
     "road worthy." );
   _bell = clone_object("/std/object");
   _bell->set_name("bell");
   _bell->set_short("bell");
   _bell->add_property("there","hanging here");
   _bell->set_long("This is a bell you could probably ring if the "
                 "driver has fallen asleep and you want the carriage to go "
                 "somewhere.\n");
   _bell->reset_get();
   _bell->reset_drop();
   _bell->move( this_object() );
   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   }
}
void init() {
  this_player()->add_command("ring", _bell, "<direct:object>", (: do_ring :) );
}
object create_carriage_driver() {
   return 0;
}
string query_carriage_name() { return _carriage_name; }
class stop_list_details query_current_stop() { return _route_info->stops[_current_stop]; }
class stop_list_details query_next_stop() { return _route_info->stops[_next_stop]; }
object query_outside() { return _outside; }
class route_details query_route_map() { return _route_info; }
int *query_stop_info() { return ({ _current_stop, _next_stop }); }
void update_route( string name,
                  class route_details new_route_info,
                  object handler)
{
   _handler = handler;
   _route_info = new_route_info;
   if (_current_stop >= sizeof(_route_info)) {
      _current_stop = _current_stop % sizeof(_route_info->stops);
   }
   _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
}
int make_carriage( string name,
                   class route_details new_route_info,
                   object handler)
{
    _handler = handler;
    _carriage_name = name;
    _route_info = new_route_info;
    _current_stop = 0;
    _next_stop = 1;
  if (!stringp( _carriage_name )) {
     log_file("NEW_CARRIAGE","%O: Invalid name: %O", this_object(),_carriage_name);
     return 0;
  }
  if (!classp( _route_info )) {
     log_file("NEW_CARRIAGE","%O: Invalid class: %O", this_object(), _route_info);
     return 0;
  }
  call_out("make_stop",5);
  _current_stop = 0;
  _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
  if(!_car_driver) {
    _car_driver = create_carriage_driver();
    if(objectp(_car_driver)) {
      _car_driver->route_setup(_carriage_name);
      _car_driver->move(this_object());
    }
  }
  return 1;
}
void make_stop() {
   string name;
   string* name_parts;
   string np;
   string n_path;
   string path;
   int travel_time;
   int stop_time;
   name = _handler->query_stop_name(_route_info->stops[ _current_stop ]->id);
   path = _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
   _p_name = name;
   travel_time = _route_info->stops[ _next_stop ]->travel_time;
   stop_time = _handler->query_stop_delay(_route_info->stops[ _current_stop ]->id);
   _n_name = _handler->query_stop_name(_route_info->stops[ _next_stop ]->id);
   n_path = _handler->query_stop_location(_route_info->stops[ _next_stop ]->id);
   _outside = load_object(path);
   if (!_outside) {
      log_file("NEW_CARRIAGE", ctime(time())+" (%O): problem with "
        + path +" (" + name + ", " + _route_info->stops[ _current_stop ]->id + ")\n", this_object());
      _route_info->stops = _route_info->stops[0.._current_stop - 1] +
                    _route_info->stops[_current_stop + 1..];
      call_out("make_stop", 1);
      return;
   }
   tell_room(this_object(), "The carriage comes to a grinding "
     "halt.\n");
   if(objectp(_car_driver) && (environment(_car_driver) == this_object())) {
     _car_driver->arrived_at_to_carriage( name, _n_name );
   } else {
     tell_room(this_object(), "The carriage has arrived at " + name + ".\n");
   }
   if (!_fake_carriage) {
     _fake_carriage = clone_object("/std/object");
     _fake_carriage->set_name("carriage");
     _fake_carriage->add_property("determinate", "the " );
     _fake_carriage->set_short(_carriage_name + " Carriage");
     _fake_carriage->add_adjective( map(explode(_carriage_name, " "),
                       (: lower_case($1) :) ) );
     _fake_carriage->set_long("The carriage looks fairly old "
       "and barely road worthy.  You could probably enter "
       "it if you fancy a bumpy ride.\n");
     _fake_carriage->reset_get();
   }
   _fake_carriage->move( _outside );
   _fake_carriage->add_property("there","waiting here");
   add_exit("leave carriage", path, "corridor");
   modify_exit("leave carriage", ({
                "function", "check_can_leave",
                "enter", "$N climb$s out of the carriage.\n",
                "message", "$N climb$s out of the carriage.\n",
                "move mess", "\nYou climb out of the carriage.\n",
                "size", 190}));
   add_alias("out", "leave carriage");
   tell_room(_outside, "The "+ _carriage_name + " carriage arrives and "
      "pulls to a stop.\n"
      "The driver opens the carriage door.\n");
   if(objectp(_car_driver)) {
     _car_driver->do_command("leave carriage");
     if( environment(_car_driver) != _outside ) {
       _car_driver->move(_outside, "The " + _carriage_name +
                         " carriage driver hops out of the carriage.",
                         "The driver opens the door and leaps out.");
     }
     _car_driver->arrived_at_to_stop( capitalize(_n_name) );
   } else {
     tell_room(this_object(), "The carriage's next stop is " + _n_name
               + ".\n");
   }
   _exit_name = "enter " + lower_case(_carriage_name) + " carriage";
   _outside->add_exit(_exit_name, this_object(), "corridor");
   name_parts = explode(lower_case(_carriage_name), " ");
   foreach(np in name_parts) {
      _outside->add_alias("enter " + np + " carriage", _exit_name);
      _outside->add_alias("enter " + np + "s carriage", _exit_name);
   }
   _outside->add_alias("enter carriage", _exit_name);
   if(!_outside->query_linker()) {
      _outside->modify_exit(_exit_name, ({
                   "enter", "$N enter$s the carriage.\n",
                   "message", "$N climb$s aboard the carriage.\n",
                   "move mess", "\nYou climb aboard the carriage.\n",
                   "size", 190 }) );
   } else {
      string *linked_rooms;
      _outside->modify_exit(_exit_name, ({
                   "enter", "$N enter$s the carriage.\n",
                   "message", "$N climb$s aboard the carriage.\n",
                   "move mess", "\nYou climb aboard the carriage.\n",
                   "linker mess", ({
                      "At the carriage stop, $N $V$0=enters,enter$V$ "
                      "the carriage\n", "At the carriage stop, $N "
                      "$V$0=gets off,get off$V$ the carriage.\n"}) ,
                   "size", 190 }) );
      linked_rooms = ( _outside->query_linker() )->query_rooms()
                         - ({ base_name( _outside ) });
      foreach( string raum in linked_rooms ) {
         tell_room( raum ,
                "A carriage draws to a halt at the carriage stop.\n");
      }
   }
   stop_room_chats();
   call_out("give_warning", stop_time - 30, name, _n_name);
   call_out("move_on", stop_time );
}
int check_can_leave(string exit, object person) {
   return !_outside->check_cannot_leave_carriage(person);
}
void give_warning(string this_stop_name, string next_stop_name) {
  if(objectp(_outside) && objectp(_car_driver) &&
     (environment(_car_driver) == _outside)) {
    _car_driver->leaving_again_to_stop(next_stop_name);
  } else {
    tell_room(this_object(), "The carriage is about to leave for " +
                             next_stop_name + ".\n");
  }
}
void move_on() {
  string np;
  string* name_parts;
  if(objectp(_car_driver)) {
    _car_driver->do_command("mutter");
    _car_driver->do_command("enter " + lower_case(_carriage_name) +
                            " carriage");
    if( environment(_car_driver) != this_object() ) {
      debug_printf("Driver: Tried to \"enter " +
                   lower_case(_carriage_name) + " carriage\" and "
                   "failed.");
      _car_driver->move(this_object(), "The driver hops back in to the "
                        "carriage and gets ready to drive again.",
                        "The " + _carriage_name + " driver hops back "
                        "onto " + _car_driver->query_possessive() +
                        " carriage.");
    }
    _car_driver->next_stop_from_carriage(_n_name);
    tell_room(this_object(), "The carriage starts moving again.\n");
  } else {
    tell_room(this_object(), "The carriage leaves the current stop.\n");
  }
  remove_exit("leave carriage");
  remove_alias("out", "leave carriage");
  if(objectp(_outside)) {
    tell_room(_outside, "The driver closes the carriage door.\n"
                         "The carriage starts moving again.\n");
    _outside->remove_exit(_exit_name);
    name_parts = explode(lower_case(_carriage_name), " ");
    foreach(np in name_parts) {
      _outside->remove_alias("enter " + np + " carriage", _exit_name);
      _outside->remove_alias("enter " + np + "s carriage", _exit_name);
    }
    _outside->remove_alias("enter carriage", _exit_name);
    if (_fake_carriage) {
      _fake_carriage->move("/std/room");
    }
    _outside->modify_item("carriage", 0);
  }
  _current_stop = _next_stop;
  _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
  _outside = 0;
  room_chat(({15, 30, ({
    "The carriage seems to be on the verge of falling apart "
      "as it shakes.",
    "The carriage hits a bump in the road and you almost "
      "fall out.",
    "The driver seems to have a talent for hitting every "
      "pothole.",
    "The driver falls off, and just manages to get back on "
      "the carriage."
  }) }) );
  this_object()->check_chat();
  call_out("make_stop", 30 );
}
void dest_me() {
  string path;
  object ob;
  string np;
  string* name_parts;
  if(objectp(_outside)) {
    _outside->remove_exit(_exit_name);
    name_parts = explode(lower_case(_carriage_name), " ");
    foreach(np in name_parts) {
      _outside->remove_alias("enter " + np + " carriage", _exit_name);
      _outside->remove_alias("enter " + np + "s carriage", _exit_name);
    }
    _outside->remove_alias("enter carriage", _exit_name);
    _outside->remove_extra_look(this_object());
    _outside->modify_item("carriage", 0);
  }
  if (_fake_carriage) _fake_carriage->dest_me();
  if (_bell) _bell->dest_me();
  if (_car_driver) _car_driver->dest_me();
  if (_current_stop < sizeof(_route_info)) {
     path = _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
     foreach (ob in all_inventory()) {
        if (living(ob)) {
          ob->move(path, "$N appears looking a little shocked.",
                         "$N disappears in a cloud of shockedness.");
        }
     }
  }
  ::dest_me();
}
string query_quit_handler() {
   return _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
}
mixed *co() {
  return filter(call_out_info(),(: $1[0] == this_object() :));
}
int do_ring() {
  if ( sizeof( co() ) != 0 ) {
    add_succeeded_mess(({"You ring the bell.\n", "$N $V the "
      "bell.\n"}));
    if(objectp(_car_driver) && environment(_car_driver) == this_object()) {
      _car_driver->bell_ring(_n_name);
    } else {
      tell_room(this_object(), "Nothing much happens.\n");
    }
    return 1;
  }
  call_out("move_on",2);
  if(objectp(_car_driver) && environment(_car_driver) == this_object()) {
    _car_driver->do_command(":wakes with a start.");
  }
  tell_object( this_player(), "The carriage starts rolling again.\n");
  return 1;
}
string query_environ_long() {
  if ( !_outside ) {
    return "Outside the carriage, the road from " + _p_name + " to "
      + _n_name + " swishes by.";
  } else {
  return "Outside the window you can see:\n" + _outside->long();
  }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/carriage/testhandler.c ===
#include <room.h>
#include <data.h>
#include <room/carriage.h>
#define CARRIAGE ITEMS "carriage"
private mapping _routedetails = ([ ]);
private mapping _routesactual = ([ ]);
private nosave mapping _carriages = ([ ]);
private nosave string _base_dir;
private nosave string _carriage;
private nosave string _pole;
private nosave string _data_dir;
private nosave string _save_file;
private mapping _file_modified_time;
private void load_data();
private void map_carriages();
private void save_file() {
   unguarded((: save_object(_save_file) :));
}
void create() {
   seteuid(getuid());
   _file_modified_time = ([ ]);
   this_object()->setup();
}
void setup_carriage(string dir, string base_dir,
                    string carriage, string pole, string save_file) {
   _data_dir = dir;
   _base_dir = base_dir;
   _carriage = carriage;
   _pole = pole;
   _save_file = save_file;
   unguarded((: restore_object(_save_file) :));
   if (!_file_modified_time) {
      _file_modified_time = ([ ]);
   }
   load_data();
   map_carriages();
}
mapping query_route_details() { return _routedetails; }
mapping query_route_actual() { return _routesactual; }
string* query_route_names() { return keys(_routesactual); }
string query_stop_location(string name) {
   if (_routedetails[name]) {
     return _routedetails[name]->path;
   }
   return "bad stop " + name;
}
string query_stop_name(string name) {
   if (_routedetails[name]) {
      return _routedetails[name]->name;
   }
   return "Broken Position " + name;
}
int query_stop_delay(string name) {
   if (_routedetails[name]) {
      return _routedetails[name]->delay;
   }
   return 60;
}
class stop_list_details* query_route_stops(string route) {
   return _routesactual[route]->stops;
}
object query_carriage_on_route(string route) {
   return _carriages[route];
}
private void parse_stop(string fname, mapping data) {
   string name;
   class stop_details info;
   if (!data["id"]) {
      debug_printf("No id for stop %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   if (!data["name"]) {
      debug_printf("No name for stop %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   name = data["name"];
   if (!data["path"]) {
      log_file("COMPILE_ERROR", "Required path field not present for stop %s\n", name);
      return 0;
   }
   info = new(class stop_details);
   info->name = data["name"];
   if (data["path"][0] == '/') {
      info->path = data["path"];
   } else {
      info->path = _base_dir + data["path"];
   }
   info->delay = data["delay"];
   _routedetails[data["id"]] = info;
   save_file();
}
private void parse_route(string fname, mapping data) {
   string name;
   class route_details info;
   mixed bing;
   if (!data["name"]) {
      debug_printf("No id for route %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   if (!data["colour"]) {
      debug_printf("No colour for route %O\n", data);
      log_file("COMPILE_ERROR", "No name for stop %O\n", data);
      return 0;
   }
   name = data["name"];
   info = new(class route_details, stops : ({ }));
   info->colour = data["colour"];
   info->return_along = data["samereturnpath"];
   foreach (bing in data["stop"]) {
      if (!mapp(bing) || !stringp(bing["id"]) || !intp(bing["travel"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         log_file("COMPILE_ERROR", "Invalid data for route (%s) %O\n", name,  bing);
      } else {
         info->stops += ({ new(class stop_list_details, id : bing["id"],
                                             travel_time : bing["travel"]) });
      }
   }
   _routesactual[data["name"]] = info;
   save_file();
}
protected void finish_compiling(string fname, mapping data) {
   mixed* bits;
   mapping thing;
   string name;
   foreach (name, bits in data) {
      switch (name) {
      case "stop" :
         foreach (thing in bits) {
            parse_stop(fname, thing);
         }
         break;
      case "route" :
         foreach (thing in bits) {
            parse_route(fname, thing);
         }
         break;
      default :
         debug_printf("Unknown data area %s in %s\n", name, fname);
         log_file("COMPILE_ERROR", "Unknown data area %s in %s\n", name, fname);
         break;
      }
   }
   _file_modified_time[fname] = unguarded( (: stat($(fname)) :))[1];
   save_file();
   map_carriages();
}
void scan_for_new_data() {
   string *files;
   string fname;
   string *bits;
   debug_printf("Scan for new data.");
   if (unguarded( (: stat(__FILE__)[1] :)) !=
       _file_modified_time[__FILE__]) {
      _file_modified_time = ([ ]);
   }
   files = ({ _data_dir });
   while (sizeof(files)) {
      fname = files[0];
      files = files[1..];
      if (unguarded( (: file_size($(fname)) :)) == -2) {
         bits = get_dir(fname + "/");
         if (bits) {
            bits -= ({ "RCS", ".", ".." });
            bits = filter(bits, (: $1[0] != '.' :));
            files += map(bits, (: $2 + "/" + $1 :), fname);
         }
      } else {
         if (unguarded( (: stat($(fname)) :))[1] != _file_modified_time[fname]) {
            debug_printf("Compiling: %s", fname);
            DATA_HANDLER->compile_file(fname,
                     (: finish_compiling :));
         }
      }
   }
   _file_modified_time[__FILE__] =
                unguarded( (: stat(__FILE__)[1] :));
}
private string trim(string str) {
   while (strlen(str) && str[0] == ' ') {
      str = str[1..];
   }
   while (strlen(str) && str[<1] == ' ') {
      str = str[0..<2];
   }
   return str;
}
void load_data() {
   scan_for_new_data();
}
private void map_carriages() {
  string route;
  int i, j;
  class route_details rods;
  class route_details new_rods;
  string *locshorts;
  object carriage;
  object car;
  object room;
  object pole;
  class stop_list_details loc;
  string str;
  foreach( route, rods in _routesactual) {
    carriage = 0;
    if (!_carriages[route]) {
      foreach( car in children( _carriage ) ) {
        if (clonep(car) && car->query_carriage_name() == route) {
          carriage = car;
          break;
        }
      }
    } else {
      carriage = _carriages[route];
    }
    locshorts = ({ });
    foreach (loc in rods->stops) {
       str = query_stop_name(loc->id);
       if (str) {
          locshorts += ({ str });
       }
    }
    j = 0;
    foreach (loc in rods->stops) {
      str = query_stop_location(loc->id);
      room = load_object(str);
      if(objectp(room)) {
        if( room->query_property("test pole")) {
          pole = room->query_property("test pole");
        } else {
          pole = clone_object(_pole);
          if(objectp(pole)) {
            pole->move(room);
            room->add_property(ROOM_KEEP_PROP);
          }
        }
        if(objectp(pole)) {
          pole->setup_route(
                  locshorts[(j+1)..] + locshorts[0..j],
                  _routesactual[route]->colour,
                  route);
        }
      j++;
      }
    }
    if (rods->return_along) {
       new_rods = copy(rods);
       for (i = sizeof(rods->stops) - 2; i >= 1; i--) {
          new_rods->stops += ({ rods->stops[i] });
       }
    } else {
       new_rods = rods;
    }
    if (!carriage) {
      carriage = clone_object( _carriage );
      carriage->make_carriage( route, new_rods, this_object() );
      carriage->setup();
    } else {
      carriage->update_route( route, new_rods, this_object() );
      carriage->setup();
    }
    if(objectp(carriage)) {
      _carriages[route] = carriage;
    }
  }
}
mixed* stats() {
   mixed* ret;
   string route;
   object ob;
   ret = ({ });
   foreach (route in query_route_names()) {
      ob = query_carriage_on_route(route);
      if (ob) {
         ret += ({ ({ route + "-carriage", file_name(ob) })  });
      }
      ret += ({ ({ route + "-colour", _routesactual[route]->colour }) });
      ret += ({ ({ route + "-current stop", ob->query_current_stop()->name })  });
      ret += ({ ({ route + "-next stop", ob->query_next_stop()->name })  });
      if (ob && ob->query_outside()) {
         ret += ({ ({ route + "-outside", file_name(ob->query_outside()) }) });
      }
   }
   return ret;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/carriage/testcar.c ===
#include <room/carriage.h>
#define DEFAULT_WAIT 60
#define DEFAULT_TRAVEL 45
inherit "/std/room/basic_room";
private class route_details _route_info;
private string _carriage_name;
private string _exit_name;
private int _current_stop;
private int _next_stop;
private object _outside;
private object _fake_carriage;
private object _bell;
private object _car_driver;
private object _handler;
private string _n_name;
private string _p_name;
int do_ring();
string query_environ_long();
void create() {
    do_setup++;
    ::create();
    do_setup--;
    set_light(60);
    set_keep_room_loaded(1);
    set_short( "inside a carriage" );
    add_property( "no teleport", 1 );
    add_property("determinate", "");
    add_property("no map", 1);
    add_property("no godmother", 1);
   add_item("window", (: query_environ_long :) );
   add_item( "carriage", "The carriage looks fairly old and barely "
     "road worthy." );
   _bell = clone_object("/std/object");
   _bell->set_name("bell");
   _bell->set_short("bell");
   _bell->add_property("there","hanging here");
   _bell->set_long("This is a bell you could probably ring if the "
                 "driver has fallen asleep and you want the carriage to go "
                 "somewhere.\n");
   _bell->reset_get();
   _bell->reset_drop();
   _bell->move( this_object() );
   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   }
}
void init() {
  this_player()->add_command("ring", _bell, "<direct:object>", (: do_ring :) );
}
object create_carriage_driver() {
   return 0;
}
string query_carriage_name() { return _carriage_name; }
class stop_list_details query_current_stop() { return _route_info->stops[_current_stop]; }
class stop_list_details query_next_stop() { return _route_info->stops[_next_stop]; }
object query_outside() { return _outside; }
class route_details query_route_map() { return _route_info; }
int *query_stop_info() { return ({ _current_stop, _next_stop }); }
void update_route( string name,
                  class route_details new_route_info,
                  object handler)
{
   _handler = handler;
   _route_info = new_route_info;
   if (_current_stop >= sizeof(_route_info)) {
      _current_stop = _current_stop % sizeof(_route_info->stops);
   }
   _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
}
int make_carriage( string name,
                   class route_details new_route_info,
                   object handler)
{
    _handler = handler;
    _carriage_name = name;
    _route_info = new_route_info;
    _current_stop = 0;
    _next_stop = 1;
  if (!stringp( _carriage_name )) {
     log_file("NEW_CARRIAGE","%O: Invalid name: %O", this_object(),_carriage_name);
     return 0;
  }
  if (!classp( _route_info )) {
     log_file("NEW_CARRIAGE","%O: Invalid class: %O", this_object(), _route_info);
     return 0;
  }
  call_out("make_stop",5);
  _current_stop = 0;
  _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
  if(!_car_driver) {
    _car_driver = create_carriage_driver();
    if(objectp(_car_driver)) {
      _car_driver->route_setup(_carriage_name);
      _car_driver->move(this_object());
    }
  }
  return 1;
}
void make_stop() {
   string name;
   string* name_parts;
   string np;
   string n_path;
   string path;
   int travel_time;
   int stop_time;
   name = _handler->query_stop_name(_route_info->stops[ _current_stop ]->id);
   path = _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
   _p_name = name;
   travel_time = _route_info->stops[ _next_stop ]->travel_time;
   stop_time = _handler->query_stop_delay(_route_info->stops[ _current_stop ]->id);
   _n_name = _handler->query_stop_name(_route_info->stops[ _next_stop ]->id);
   n_path = _handler->query_stop_location(_route_info->stops[ _next_stop ]->id);
   _outside = load_object(path);
   if (!_outside) {
      log_file("NEW_CARRIAGE", ctime(time())+" (%O): problem with "
        + path +" (" + name + ", " + _route_info->stops[ _current_stop ]->id + ")\n", this_object());
      _route_info->stops = _route_info->stops[0.._current_stop - 1] +
                    _route_info->stops[_current_stop + 1..];
      call_out("make_stop", 1);
      return;
   }
   tell_room(this_object(), "The carriage comes to a grinding "
     "halt.\n");
   if(objectp(_car_driver) && (environment(_car_driver) == this_object())) {
     _car_driver->arrived_at_to_carriage( name, _n_name );
   } else {
     tell_room(this_object(), "The carriage has arrived at " + name + ".\n");
   }
   if (!_fake_carriage) {
     _fake_carriage = clone_object("/std/object");
     _fake_carriage->set_name("carriage");
     _fake_carriage->add_property("determinate", "the " );
     _fake_carriage->set_short(_carriage_name + " Carriage");
     _fake_carriage->add_adjective( map(explode(_carriage_name, " "),
                       (: lower_case($1) :) ) );
     _fake_carriage->set_long("The carriage looks fairly old "
       "and barely road worthy.  You could probably enter "
       "it if you fancy a bumpy ride.\n");
     _fake_carriage->reset_get();
   }
   _fake_carriage->move( _outside );
   _fake_carriage->add_property("there","waiting here");
   add_exit("leave carriage", path, "corridor");
   modify_exit("leave carriage", ({
                "function", "check_can_leave",
                "enter", "$N climb$s out of the carriage.\n",
                "message", "$N climb$s out of the carriage.\n",
                "move mess", "\nYou climb out of the carriage.\n",
                "size", 190}));
   add_alias("out", "leave carriage");
   tell_room(_outside, "The "+ _carriage_name + " carriage arrives and "
      "pulls to a stop.\n"
      "The driver opens the carriage door.\n");
   if(objectp(_car_driver)) {
     _car_driver->move(_outside, "The " + _carriage_name + " carriage "
       "driver hops out of the carriage.", "The driver opens the door "
       "and leaps out.");
     _car_driver->arrived_at_to_stop( capitalize(_n_name) );
   } else {
     tell_room(this_object(), "The carriage's next stop is " + _n_name + ".\n");
   }
   _exit_name = "enter " + lower_case(_carriage_name) + " carriage";
   _outside->add_exit(_exit_name, this_object(), "corridor");
   name_parts = explode(lower_case(_carriage_name), " ");
   foreach(np in name_parts) {
      _outside->add_alias("enter " + np + " carriage", _exit_name);
      _outside->add_alias("enter " + np + "s carriage", _exit_name);
   }
   _outside->add_alias("enter carriage", _exit_name);
   if(!_outside->query_linker()) {
      _outside->modify_exit(_exit_name, ({
                   "enter", "$N enter$s the carriage.\n",
                   "message", "$N climb$s aboard the carriage.\n",
                   "move mess", "\nYou climb aboard the carriage.\n",
                   "size", 190 }) );
   } else {
      string *linked_rooms;
      _outside->modify_exit(_exit_name, ({
                   "enter", "$N enter$s the carriage.\n",
                   "message", "$N climb$s aboard the carriage.\n",
                   "move mess", "\nYou climb aboard the carriage.\n",
                   "linker mess", ({
                      "At the carriage stop, $N $V$0=enters,enter$V$ "
                      "the carriage\n", "At the carriage stop $N "
                      "$V$0=gets off,get off$V$ the carriage.\n"}) ,
                   "size", 190 }) );
      linked_rooms = ( _outside->query_linker() )->query_rooms()
                         - ({ base_name( _outside ) });
      foreach( string raum in linked_rooms ) {
         tell_room( raum ,
                "A carriage draws to a halt at the carriage stop.\n");
      }
   }
   stop_room_chats();
   call_out("give_warning", stop_time - 30, name, _n_name);
   call_out("move_on", stop_time );
}
int check_can_leave(string exit, object person) {
   return !_outside->check_cannot_leave_carriage(person);
}
void give_warning(string this_stop_name, string next_stop_name) {
  if(objectp(_outside) && objectp(_car_driver) &&
     (environment(_car_driver) == _outside)) {
    _car_driver->leaving_again_to_stop(next_stop_name);
  } else {
    tell_room(this_object(), "The carriage is about to leave to " +
                             next_stop_name + ".\n");
  }
}
void move_on() {
  string* name_parts;
  if(objectp(_car_driver)) {
    _car_driver->do_command("mutter");
    _car_driver->move(this_object(), "The driver hops back in to the carriage "
      "and gets ready to drive again.", "The " + _carriage_name +
      " driver hops back onto " + _car_driver->query_possessive() +
      " carriage.");
  } else {
    tell_room(this_object(), "The carriage leaves the current stop.\n");
  }
  remove_exit("leave carriage");
  remove_alias("out", "leave carriage");
  if(objectp(_outside)) {
    tell_room(_outside, "The driver closes the carriage door.\n"
                         "The carriage starts moving again.\n");
    _outside->remove_exit(_exit_name);
    name_parts = explode(lower_case(_carriage_name), " ");
    foreach(np in name_parts) {
      _outside->remove_alias("enter " + np + " carriage", _exit_name);
      _outside->remove_alias("enter " + np + "s carriage", _exit_name);
    }
    _outside->remove_alias("enter carriage", _exit_name);
    if (_fake_carriage) {
      _fake_carriage->move("/std/room");
    }
    _outside->modify_item("carriage", 0);
  }
  if (objectp(_car_driver)) {
     _car_driver->next_stop_from_carriage(_n_name);
  }
  _current_stop = _next_stop;
  _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
  _outside = 0;
  room_chat(({15, 30, ({
    "The carriage seems to be on the verge of falling apart "
      "as it shakes.",
    "The carriage hits a bump in the road and you almost "
      "fall out.",
    "The driver seems to have a talent for hitting every "
      "pothole.",
    "The driver falls off, and just manages to get back on "
      "the carriage."
  }) }) );
  this_object()->check_chat();
  call_out("make_stop", 30 );
}
void dest_me() {
  string path;
  object ob;
  string* name_parts;
  if(objectp(_outside)) {
    _outside->remove_exit(_exit_name);
    name_parts = explode(lower_case(_carriage_name), " ");
    foreach(np in name_parts) {
      _outside->remove_alias("enter " + np + " carriage", _exit_name);
      _outside->remove_alias("enter " + np + "s carriage", _exit_name);
    }
    _outside->remove_alias("enter carriage", _exit_name);
    _outside->remove_extra_look(this_object());
    _outside->modify_item("carriage", 0);
  }
  if (_fake_carriage) _fake_carriage->dest_me();
  if (_bell) _bell->dest_me();
  if (_car_driver) _car_driver->dest_me();
  if (_current_stop < sizeof(_route_info)) {
     path = _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
     foreach (ob in all_inventory()) {
        if (living(ob)) {
          ob->move(path, "$N appears looking a little shocked.",
                         "$N disappears in a cloud of shockedness.");
        }
     }
  }
  ::dest_me();
}
string query_quit_handler() {
   return _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
}
mixed *co() {
  return filter(call_out_info(),(: $1[0] == this_object() :));
}
int do_ring() {
  if ( sizeof( co() ) != 0 ) {
    add_succeeded_mess(({"You ring the bell.\n", "$N $V the "
      "bell.\n"}));
    if(objectp(_car_driver) && environment(_car_driver) == this_object()) {
      _car_driver->do_command("scowl");
      _car_driver->do_command("'We won't reach " + _n_name + " any faster just "
        "cause you ring that danged bell!");
    }
    return 1;
  }
  call_out("move_on",2);
  _car_driver->do_command(":wakes with a start.");
  tell_object( this_player(), "The carriage starts rolling again.\n");
  return 1;
}
string query_environ_long() {
  if ( !_outside ) {
    return "Outside the carriage, the road from " + _p_name + " to "
      + _n_name + " swishes by.";
  } else {
  return "Outside the window you can see:\n" + _outside->long();
  }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/carriage/carriage_pole.c ===
inherit "/std/object";
void setup_route(string *ss, string c, string r);
string *notes = ({});
void setup() {
  set_name( "pole" );
  set_short("wooden pole");
  add_adjective( "wooden" );
  set_long("This is a wooden pole.  It's fairly unexciting.\n");
  set_weight( 10000 );
  add_property( "there", ( ({"casually placed in a corner",
                             "here",
                             "standing on the side of the road",
                             "trying to be noticed"})
                          [random(4)]));
  add_extra_look(this_object());
  reset_get();
}
void setup_route( string *stops, string colour, string route) {
  object note;
  string language;
  string pathofhere;
  if(member_array(colour + " note", notes) != -1) {
    return;
  }
  notes += ({ colour + " note" });
  pathofhere = file_name(environment(this_object()));
  if(strsrch(pathofhere, "/d/am/") != -1)
    language = "morporkian";
  if(strsrch(pathofhere, "/d/cwc/") != -1)
    language = "agatean";
  if(strsrch(pathofhere, "/d/klatch/") != -1)
    language = "djelian";
  if(strsrch(pathofhere, "/d/ram/") != -1)
    language = "morporkian";
  if(strsrch(pathofhere, "/d/ram/Uberwald/") != -1)
    language = "uberwaldean";
  if(strsrch(pathofhere, "/d/sur/") != -1)
    language = "morporkian";
  note = clone_object(__DIR__ + "carriage_note");
  note->setup_route(stops, colour, route, language);
  environment(this_object())->add_hidden_object(note);
  environment(this_object())->add_property("carriage pole",
    this_object());
  if(sizeof(notes)) {
    set_short("wooden pole with " + (query_multiple_short(map( notes,
    (: add_a($1) :)))) + " attached to it") ;
  }
}
string extra_look() {
  if(sizeof(notes)) {
    return capitalize((query_multiple_short(map( notes, (: add_a($1) :)))) +
      ((sizeof(notes) > 1) ? " are" : " is") + " attached to the pole.\n") ;
  }
  return "";
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/carriage/carriage_note.c ===
inherit "/std/object";
void setup_route(string* a, string b, string c, string d);
void setup() {
  set_name( "note" );
  set_short(  "Test note" ) ;
  set_long( "This note is probably broken, please contact a "
    "creator. :)\n" );
  reset_get();
  add_alias( "table" );
}
void setup_route(string* stops, string colour, string route, string language) {
  string prettystops = "";
  int i;
  set_short(route + " table");
  add_adjective(map(explode(route, " "), (: lower_case($1) :)));
  add_adjective(colour);
  add_alias("table");
  add_alias("cardboard");
  add_adjective(({"piece", "of", colour}));
  set_long("This is the table for the " + route + " route.  It is "
    "printed on a piece of sturdy " + colour + " cardboard, and stuck "
    "firmly to the pole.\n");
  for(i = 0; i < sizeof(stops) - 1; i++) {
    prettystops += capitalize(stops[i]) + "\n";
  }
  prettystops += "and back to " + stops[sizeof(stops) - 1];
  add_read_mess("\nThe " + route + " route:\n" +
    prettystops + ".\n",
    "bold letters", language);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/inherit/carriage/handler.c ===
#include <room.h>
#include <data.h>
#include <room/carriage.h>
#define CARRIAGE ITEMS "carriage"
private mapping _routedetails = ([ ]);
private mapping _routesactual = ([ ]);
private nosave mapping _carriages = ([ ]);
private nosave string _base_dir;
private nosave string _carriage;
private nosave string _pole;
private nosave string _data_dir;
private nosave string _save_file;
private mapping _file_modified_time;
private void load_data();
private void map_carriages();
private void save_file() {
   unguarded((: save_object(_save_file) :));
}
void create() {
   seteuid(getuid());
   _file_modified_time = ([ ]);
   this_object()->setup();
}
void setup_carriage(string dir, string base_dir,
                    string carriage, string pole, string save_file) {
   _data_dir = dir;
   _base_dir = base_dir;
   _carriage = carriage;
   _pole = pole;
   _save_file = save_file;
   unguarded((: restore_object(_save_file) :));
   if (!_file_modified_time) {
      _file_modified_time = ([ ]);
   }
   load_data();
   map_carriages();
}
mapping query_route_details() { return _routedetails; }
mapping query_route_actual() { return _routesactual; }
string* query_route_names() { return keys(_routesactual); }
string query_stop_location(string name) {
   if (_routedetails[name]) {
     return _routedetails[name]->path;
   }
   return "bad stop " + name;
}
string query_stop_name(string name) {
   if (_routedetails[name]) {
      return _routedetails[name]->name;
   }
   return "Broken Position " + name;
}
int query_stop_delay(string name) {
   if (_routedetails[name]) {
      return _routedetails[name]->delay;
   }
   return 60;
}
class stop_list_details* query_route_stops(string route) {
   return _routesactual[route]->stops;
}
object query_carriage_on_route(string route) {
   return _carriages[route];
}
private void parse_stop(string fname, mapping data) {
   string name;
   class stop_details info;
   if (!data["id"]) {
      debug_printf("No id for stop %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   if (!data["name"]) {
      debug_printf("No name for stop %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   name = data["name"];
   if (!data["path"]) {
      log_file("COMPILE_ERROR", "Required path field not present for stop %s\n", name);
      return 0;
   }
   info = new(class stop_details);
   info->name = data["name"];
   if (data["path"][0] == '/') {
      info->path = data["path"];
   } else {
      info->path = _base_dir + data["path"];
   }
   info->delay = data["delay"];
   _routedetails[data["id"]] = info;
   save_file();
}
private void parse_route(string fname, mapping data) {
   string name;
   class route_details info;
   mixed bing;
   if (!data["name"]) {
      debug_printf("No id for route %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   if (!data["colour"]) {
      debug_printf("No colour for route %O\n", data);
      log_file("COMPILE_ERROR", "No name for stop %O\n", data);
      return 0;
   }
   name = data["name"];
   info = new(class route_details, stops : ({ }));
   info->colour = data["colour"];
   info->return_along = data["samereturnpath"];
   foreach (bing in data["stop"]) {
      if (!mapp(bing) || !stringp(bing["id"]) || !intp(bing["travel"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         log_file("COMPILE_ERROR", "Invalid data for route (%s) %O\n", name,  bing);
      } else {
         info->stops += ({ new(class stop_list_details, id : bing["id"],
                                             travel_time : bing["travel"]) });
      }
   }
   _routesactual[data["name"]] = info;
   save_file();
}
protected void finish_compiling(string fname, mapping data) {
   mixed* bits;
   mapping thing;
   string name;
   foreach (name, bits in data) {
      switch (name) {
      case "stop" :
         foreach (thing in bits) {
            parse_stop(fname, thing);
         }
         break;
      case "route" :
         foreach (thing in bits) {
            parse_route(fname, thing);
         }
         break;
      default :
         debug_printf("Unknown data area %s in %s\n", name, fname);
         log_file("COMPILE_ERROR", "Unknown data area %s in %s\n", name, fname);
         break;
      }
   }
   _file_modified_time[fname] = unguarded( (: stat($(fname)) :))[1];
   save_file();
   map_carriages();
}
void scan_for_new_data() {
   string *files;
   string fname;
   string *bits;
   debug_printf("Scan for new data.");
   if (unguarded( (: stat(__FILE__)[1] :)) !=
       _file_modified_time[__FILE__]) {
      _file_modified_time = ([ ]);
   }
   files = ({ _data_dir });
   while (sizeof(files)) {
      fname = files[0];
      files = files[1..];
      if (unguarded( (: file_size($(fname)) :)) == -2) {
         bits = get_dir(fname + "/");
         if (bits) {
            bits -= ({ "RCS", ".", ".." });
            bits = filter(bits, (: $1[0] != '.' :));
            files += map(bits, (: $2 + "/" + $1 :), fname);
         }
      } else {
         if (unguarded( (: stat($(fname)) :))[1] != _file_modified_time[fname]) {
            debug_printf("Compiling: %s", fname);
            DATA_HANDLER->compile_file(fname,
                     (: finish_compiling :));
         }
      }
   }
   _file_modified_time[__FILE__] =
                unguarded( (: stat(__FILE__)[1] :));
}
private string trim(string str) {
   while (strlen(str) && str[0] == ' ') {
      str = str[1..];
   }
   while (strlen(str) && str[<1] == ' ') {
      str = str[0..<2];
   }
   return str;
}
void load_data() {
   scan_for_new_data();
}
private void map_carriages() {
  string route;
  int i, j;
  class route_details rods;
  class route_details new_rods;
  string *locshorts;
  object carriage;
  object car;
  object room;
  object pole;
  class stop_list_details loc;
  string str;
  foreach( route, rods in _routesactual) {
    carriage = 0;
    if (!_carriages[route]) {
      foreach( car in children( _carriage ) ) {
        if (clonep(car) && car->query_carriage_name() == route) {
          carriage = car;
          break;
        }
      }
    } else {
      carriage = _carriages[route];
    }
    locshorts = ({ });
    foreach (loc in rods->stops) {
       str = query_stop_name(loc->id);
       if (str) {
          locshorts += ({ str });
       }
    }
    j = 0;
    foreach (loc in rods->stops) {
      str = query_stop_location(loc->id);
      room = load_object(str);
      if(objectp(room)) {
        if( room->query_property("carriage pole")) {
          pole = room->query_property("carriage pole");
        } else {
          pole = clone_object(_pole);
          if(objectp(pole)) {
            pole->move(room);
            room->add_property(ROOM_KEEP_PROP);
          }
        }
        if(objectp(pole)) {
          pole->setup_route(
                  locshorts[(j+1)..] + locshorts[0..j],
                  _routesactual[route]->colour,
                  route);
        }
      j++;
      }
    }
    if (rods->return_along) {
       new_rods = copy(rods);
       for (i = sizeof(rods->stops) - 2; i >= 1; i--) {
          new_rods->stops += ({ rods->stops[i] });
       }
    } else {
       new_rods = rods;
    }
    if (!carriage) {
      carriage = clone_object( _carriage );
      carriage->make_carriage( route, new_rods, this_object() );
      carriage->setup();
    } else {
      carriage->update_route( route, new_rods, this_object() );
      carriage->setup();
    }
    if(objectp(carriage)) {
      _carriages[route] = carriage;
    }
  }
}
mixed* stats() {
   mixed* ret;
   string route;
   object ob;
   ret = ({ });
   foreach (route in query_route_names()) {
      ob = query_carriage_on_route(route);
      if (ob) {
         ret += ({ ({ route + "-carriage", file_name(ob) })  });
      }
      ret += ({ ({ route + "-colour", _routesactual[route]->colour }) });
      ret += ({ ({ route + "-current stop", ob->query_current_stop()->name })  });
      ret += ({ ({ route + "-next stop", ob->query_next_stop()->name })  });
      if (ob && ob->query_outside()) {
         ret += ({ ({ route + "-outside", file_name(ob->query_outside()) }) });
      }
   }
   return ret;
}
