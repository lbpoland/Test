
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/fourbedhouse/Nhalf-roof.c ===
#include "path.h";
inherit "/std/rooftop";
void setup() {
  set_light(100);
  set_short("half-roof");
  set_long("This is a half-roof, a piece of sloping roof halfway up the "
           "front of the house.  There is a window to the %2% and another "
           "to the %6%.\n");
  set_slope(30, "half-roof", %out%);
  add_exit("%6% window", PATH+"%N%bed2", "window");
  add_exit("%2% window", PATH+"%N%bed3", "window");
  set_wall( ({ "bottom", ({ %out", 250 }), }) );
  set_wall( ({ "move", ({ "down", 30, %out%,
                            "$N climb$s down from above to join you." }) }) );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/fourbedhouse/Nkitchen.c ===
#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%kitchen");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("large kitchen");
   set_base_desc("a large kitchen");
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit("%6%", PATH+"%N%diningroom", "corridor");
   add_exit("%4%", PATH+"%N%livingroom", "corridor");
   add_exit("%2%", PATH+"%N%familyroom", "corridor");
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/fourbedhouse/Ngarden.c ===
#include "path.h";
inherit PLAYER_HOUSE_OUTSIDE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%garden");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("small garden");
   set_base_desc("a quiet and secluded garden");
   add_surface("floor", "grass");
   add_surface("%0% wall", "red brick" );
   add_surface( "%2% wall", "red brick" );
   add_surface( "%6% wall", "red brick" );
   add_exit("%4%", PATH+"%N%familyroom", "door");
   modify_exit("%4%", ({ "door short", "garden door" }));
   add_exit("window", PATH+"%N%diningroom", "window");
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/fourbedhouse/Nmasterbed.c ===
#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%masterbed");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a huge master bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "%4%", PATH +"%N%landing1", "door" );
   modify_exit("%4%", ({ "door short", "bedroom door" }));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/fourbedhouse/Nlivingroom.c ===
#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%livingroom");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("livingroom");
   set_base_desc("a large, comfortable, and sunny livingroom");
   add_surface("floor", "finished pine board" );
   add_surface("ceiling", "plain plaster" );
   add_surface("%0% wall", "plain plaster");
   add_surface("%2% wall", "plain plaster");
   add_surface("%4% wall", "plain plaster");
   add_surface("%6% wall", "plain plaster");
   add_exit("out", %out%, "door");
   modify_exit("out", ({"door short", "front door"}));
   add_exit("%7%", PATH+"%N%diningroom", "corridor");
   add_exit("%0%", PATH + "%N%kitchen", "corridor");
   add_exit("up", PATH + "%N%landing1", "corridor");
   modify_exit("up", ({"upgrade", 9}));
   modify_exit("out", ({"message", "$N leaves the house.",
                          "enter",
                          ({ 1,
                             "$N enters from a house.",
                             "$N enter from a house." }),
                          "closed", 1,
                          "door long", "This is the front door to a house.  "
                          "It has the numerals '%N%' in brass lettering.\n",
                          }) );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/languages/rabbit.c ===
#include <language.h>
inherit LANGUAGE_INHERIT;
void setup() {
   set_long( "This is the local language of Rabbit.\n" );
   set_name( "Rabbitian" );
   set_start_text_bit( "Some carefully constructed characters "
                       "that might mean:\n" );
}
mixed do_garble_text( string text ) {
    return ({ "whats", "up", "doc", "carrot" })[random(4)];
}
string do_garble( string text, string text_type )  {
    return ({ "whats", "up", "doc", "carrot" })[random(4)];
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/languages/language_inherit.c ===
#include <fixed_random.h>
#include <tasks.h>
#include <living.h>
private string _long;
private string _name;
private string _start_text_bit;
void setup();
void create() {
  setup();
}
void set_long(string str) {
   _long = str;
}
string query_long() {
   return _long;
}
void set_name(string str) {
   _name = str;
}
string query_name() {
   return _name;
}
void setup() {
}
void set_start_text_bit(string str) {_start_text_bit = str; }
string do_garble(string word, string type) {
  string ret;
  int i;
  ret = "";
  for (i=0;i<strlen(word);i++)
    if (word[i] != ' ')
      ret += "*";
    else
      ret += " ";
  return ret;
}
void check_level_increase(object player, int difficulty, int level,
                          string skill, string mess) {
   int chance;
   if(query_verb() == "shout" || player->query_property("dead") ||
      player->query_property(PASSED_OUT) ||
      (userp(player) && !interactive(player)))
     return;
   if(player->query_current_language() !=
      lower_case(this_object()->query_name()))
     return;
   if (player->query_property("last message:" + skill) == mess ||
       player->query_property("dead")) {
      return ;
   }
   if(player->query_specific_gp("other") < difficulty) {
     return;
   } else {
     player->adjust_gp(-(difficulty*2));
   }
   player->add_property("last message:" + skill, mess, 360);
   if (difficulty <= level && level < 100) {
        chance = 800 + ((level - 40) * (level - 40)) / 20;
      chance -= level - difficulty;
      if (random(1000) > chance) {
        if(player->add_skill_level(skill, 1)) {
          tell_object(player, "%^YELLOW%^You feel like the " +
                      capitalize(_name) +
                      " language is less confusing.%^RESET%^\n");
        }
      }
   }
}
string garble_message(string mess, object player, object speaker,
                      string type, string skill, int no_increase) {
  int i, level, num;
  int max_difficulty, diff, difference;
  string *bits;
  int something_garbled;
  level = player->query_skill(skill);
  if (level > 100) {
    player->add_skill_level(skill, 100 - level, 1);
  }
  num = speaker->query_skill(skill);
  if (num > 100) {
    speaker->add_skill_level(skill, 100 - num, 1);
  }
  difference = speaker->query_skill(skill) - player->query_skill(skill);
  if (num < level)
    level = num;
  if (level >= 100) {
    return mess;
  }
  if (level == 0) {
    max_difficulty = 0;
  } else {
    max_difficulty = 1000;
  }
  RANDOM_OBJ->set_seed(crc32(mess));
  bits = explode(mess, " ");
  for (i=0;i<sizeof(bits);i++) {
    if (strlen(mess)) {
      if (level > 0) {
         num = (int)RANDOM_OBJ->random(100);
         if (strlen(mess) < 8) {
           diff = (level*100) / (strlen(mess)*10);
           if (num >= (level*100 / strlen(mess)*10)) {
             if (max_difficulty > diff)
               max_difficulty = diff;
             if (interactive(player)) {
               bits[i] = do_garble(bits[i], type);
               something_garbled = 1;
             } else {
               bits[i] = "";
             }
           }
         } else {
           diff = (level*100) / 90;
           if (num >= diff) {
             max_difficulty = level*100 / 100;
             if (interactive(player)) {
               bits[i] = do_garble(bits[i], type);
               something_garbled = 1;
             } else {
               bits[i] = "";
             }
           }
         }
      } else {
         if (interactive(player)) {
           bits[i] = do_garble(bits[i], type);
           something_garbled = 1;
         } else {
           bits[i] = "";
         }
      }
    }
  }
  if (something_garbled && (difference > -10) && !no_increase) {
    check_level_increase(player, max_difficulty, level, skill, mess);
  }
  return implode(bits, " ");
}
mixed garble_say(string start, string mess, object player,
                 object from, string type, string skill, int no_increase) {
  return ({ start, garble_message(mess, player, from, "speech", skill,
                                  no_increase) });
}
string garble_text( mixed text, object thing, object player, string skill) {
  string bing;
  if (stringp(text)) {
    if (player->query_default_language() != query_name()) {
      return _start_text_bit +
        garble_message(text, player, player, "text", skill, 0);
    } else {
      return garble_message(text, player, player, "text", skill, 0);
    }
  }
  if ( pointerp( text ) ) {
    if ( ( bing = (string)text[ 0 ]->garble_text( text, thing, player ) ) ) {
      if (player->query_default_language() != query_name()) {
        return _start_text_bit + bing;
      } else {
        return bing;
      }
    }
  }
  return "You cannot read the spidery writing.\n";
}
void dest_me() {
  destruct(this_object());
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/languages/general.c ===
string long() {
  return
"This is the normal language spoken by most creatures.\n";
}
mixed garble_tell(string start, string mess) {
  return ({ start, mess });
}
mixed garble_shout(string start, string mess) {
  return ({ start, mess });
}
mixed garble_say(string start, string mess) {
  return ({ start, mess });
}
string garble_text( mixed text, object thing, object player, string skill) {
   string bing;
   if (stringp(text)) {
      return text;
   }
   if ( pointerp( text ) ) {
      if ( ( bing = (string)text[ 0 ]->garble_text( text, thing, player ) ) ) {
         return bing;
      }
   }
   return "You cannot read the furry writing.\n";
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/languages/wommon.c ===
string long() {
  return
"International womens day language.\n";
}
string filter_string(string str) {
  return replace(" "+str,
      ({ " he ", " they ",
         " He ", " They ",
         " HE ", " THEY ",
         " his ", " theirs ",
         " His ", " Theirs ",
         " HIs ", " THEIrs ",
         " HIS ", " THEIRS ",
         " him ", " them ",
         " Him ", " Them ",
         " HIm ", " THem ",
         " HIM ", " THEM ",
         "man", "person",
         "Man", "Person",
         "MAn", "PERson",
         "MAN", "PERSON", }))[1..10000];
}
mixed garble_tell(string start, string mess) {
  return ({ start, filter_string(mess) });
}
mixed garble_shout(string start, string mess) {
  return ({ start, filter_string(mess) });
}
mixed garble_say(string start, string mess) {
  return ({ start, filter_string(mess) });
}
mixed garble_text(string str, object ob) {
  return filter_string(str);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/languages/grunt.c ===
string long() {
  return "Consists of grunting noises.\n";
}
mixed garble_say(string start, string rest) {
  string nam, loud;
  sscanf(start, "%s %s:", nam, start);
  if (sscanf(start, "%s loudly", start) == 1)
    loud = " loudly";
  else
    loud = "";
  switch (start) {
    case "asks" :
       nam = nam+" quizzically grunts"+loud;
       break;
    case "exclaims" :
       nam = nam+" pointedly grunts"+loud;
       break;
    default :
       nam = nam+" grunts"+loud;
       break;
  }
  return ({ nam+".", "" });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/liquids/ink.c ===
int splash_func(object ob) {
  ob->add_extra_look(this_object());
  ob->add_property("splashed with", previous_object()->query_liquid_name());
  return 1;
}
int query_ink() { return 1; }
string extra_look() {
  return capitalize((string)previous_object()->query_name())+
         " has been splashed with "+
         previous_object()->query_property("splashed with");
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/living/skills.c ===
#include <skills.h>
#include <tasks.h>
#include <tune.h>
#undef LOGGING
varargs int calc_bonus( int lvl, string skill, int use_base_stats );
varargs int stat_modify( int bonus, string skill, int use_base_stats );
mixed recursive_skill_add(mixed skil, string *path, int avr, int lvl, int exp,
                           mixed standard);
private void convert_skills(mixed *skills, string path);
int query_skill(string skill);
mapping new_skills;
nosave mapping _bonus_cache,
               _stat_cache,
               _teach_offer;
mapping _last_info;
mapping query_skills() { return copy( new_skills ); }
void set_skills( mapping map ) { new_skills = map; }
int calc_level(string *path);
void create() {
  _bonus_cache = ([ ]);
  _teach_offer = ([ ]);
  _stat_cache = ([ ]);
  new_skills = ([ ]);
  if(!_last_info)
    _last_info = ([ "time" : time() ]);
}
int not_there( string skill ) {
   return undefinedp(new_skills[skill]);
}
mapping query_bonus_cache() { return copy(_bonus_cache); }
mapping query_stat_cache() { return copy(_stat_cache); }
void zap_stat_cache() {
   int i;
   string word, *list, stat;
   stat = this_object()->stats_to_zap();
   if ( !stat ) {
      return;
   }
   if ( find_call_out( "reset_all2" ) == -1 ) {
      call_out( "reset_all2", 1 );
   }
   foreach( i in stat ) {
      list = _stat_cache[ i ];
      if ( !list )
         continue;
      foreach( word in list ) {
         map_delete( _stat_cache, word );
      }
   }
   word = (string)this_object()->query_race_ob();
   if ( word ) {
      word->set_unarmed_attacks( this_object() );
   }
}
void totaly_zap_bonus_cache() {
   _bonus_cache = ([ ]);
}
protected void totaly_zap_stat_cache() {
   _stat_cache = ([ ]);
}
varargs int query_skill_bonus( string skill, int use_base_stats ) {
#ifdef 0
   int tmp, lvl;
   string *path;
   object guild, race;
#endif
  if (!stringp(skill) || !strlen(skill)) {
    return 0;
  }
  if (!new_skills) {
    new_skills = ([ ]);
  }
  if (skill[0] == '.') {
    skill = skill[1..];
  }
  TASKER->set_control( ({ this_object(), skill }) );
  if ( _bonus_cache[ skill ] )
     return stat_modify( _bonus_cache[ skill ], skill, use_base_stats );
  return calc_bonus( query_skill(skill), skill, use_base_stats );
#ifdef 0
  lvl = query_skill(skill);
  guild = (object)this_object()->query_guild_ob();
  race = (object)this_object()->query_race_ob();
  if (race) {
    tmp = (int)race->query_skill_bonus(lvl, skill);
  }
  if (guild) {
    tmp += (int)guild->query_skill_bonus(lvl, skill);
  }
  return calc_bonus( lvl + tmp, skill, use_base_stats );
#endif
}
int query_skill(string skill) {
   string *path;
   if (!new_skills) {
      new_skills = ([ ]);
   }
   if (!stringp(skill)) {
      return 0;
   }
   if (skill[0] == '.') {
      skill = skill[1..];
   }
   TASKER->set_control( ({ this_object(), skill }) );
   if ( not_there( skill ) ) {
      int i;
      path = (string *)SKILL_OB->query_skill_tree(skill);
      if (path) {
         for (i=0;i<sizeof(path);i++) {
            if ( !not_there( path[ i ] ) ) {
               return new_skills[path[i]];
            }
         }
      }
   } else {
      return new_skills[skill];
   }
   return 0;
}
mapping query_complete_skill_branch( string branch ) {
  string *skills = SKILL_OB->query_all_children( branch );
  if ( !arrayp( skills ) || !sizeof( skills ) )
    return ([ ]);
  return allocate_mapping( skills, (: query_skill( $1 ) :) );
}
protected void flatten_it(string skill) {
   int value;
   int i;
   string *same;
   reset_eval_cost();
   value = new_skills[skill];
   same = (mixed *)SKILL_OB->query_immediate_children(skill);
   for (i=0;i<sizeof(same);i++) {
      if ( not_there( same[ i ] ) ) {
         new_skills[same[i]] = value;
      }
      flatten_it(same[i]);
   }
   if (sizeof(same)) {
      map_delete(new_skills, skill);
   }
}
int tm_check_ok(string skill, object exp) {
  string *history, *bits, *abits;
  int i, j, last, delay;
  if ( !_last_info ) {
    _last_info = ([ "time" : time() ]);
  }
#ifdef LOGGING
  if(base_name(previous_object()) != "/obj/handlers/taskmaster" &&
     base_name(previous_object()) != "/std/effects/fighting/combat" &&
     base_name(previous_object()) != "/std/shadows/misc/team" &&
     base_name(previous_object()) != "/std/shadows/other/group" &&
     base_name(previous_object()) != "/global/player" &&
     base_name(previous_object())[0..2] != "/w/") {
     log_file("ATTEMPT_TASK", "Object %s gave skill increase without using "
              "the taskmaster.\n", base_name(previous_object()));
   }
#endif
  history = this_object()->get_history();
  if(sizeof(history)) {
    for(i=0; i<sizeof(history) && history[i]; i++)
      ;
    last = i - 1;
    if(!this_object()->is_alias(history[last]))
      last -= this_object()->query_queued_commands();
    if(last > 0 && sizeof(history[last]) > 1 && skill[<7..] != ".points") {
      for(i=0; i<sizeof(history) && history[i]; i++) {
        if(history[last] == history[i]) {
          j++;
        }
      }
      if(j > 5 || j * 100 / i > 30) {
#ifdef BAD_TM
        log_file(BAD_TM, "%s %s in %s by %O too many attempts at %s [%s]\n",
                 ctime(time())[4..18], this_object()->query_name(), skill,
                 exp, history[last], history[i-1]);
#endif
        if(!_last_info["skill"] || _last_info["skill"][0] != skill)
          _last_info["skill"] = ({ skill, 2 });
        else
          _last_info["skill"][1] += 1;
        _last_info["time"] = time();
        if(!_last_info["object"] || _last_info["object"][0] != base_name(exp))
          _last_info["object"] = ({ base_name(exp), 2 });
        else
          _last_info["object"][1] += 1;
        if(!_last_info["env"] || _last_info["env"][0] != environment())
          _last_info["env"] = ({ environment(), 2 });
        else
          _last_info["env"][1] += 1;
        return 0;
      }
    }
  }
  delay = 30 + random(this_object()->query_level()) +
    random(this_object()->query_skill(skill));
  if(_last_info["object"] && base_name(exp) == _last_info["object"][0])
    delay *= _last_info["object"][1];
  if(this_object()->query_level() * 2 < this_object()->query_skill(skill))
    delay *= 2;
  if(_last_info["env"] && environment(this_object()) == _last_info["env"][0]) {
    delay *= _last_info["env"][1];
  }
  bits = explode(skill, ".");
  if(_last_info["skill"])
    abits = explode(_last_info["skill"][0], ".");
  else
    abits = ({ });
  for(i=0; i<sizeof(bits) && i<sizeof(abits) && bits[i] == abits[i]; i++)
    ;
  if(i && _last_info["skill"])
    delay *= (i * _last_info["skill"][1]);
  else
    delay = 60;
  if(_last_info["time"] > (time() - delay)) {
#ifdef BAD_TM
    log_file(BAD_TM, "%s %s in %s by %O last %d secs ago, delay %d.\n",
             ctime(time())[4..18], this_object()->query_name(), skill,
             exp, (time() - _last_info["time"]), delay);
#endif
    if(!_last_info["skill"] || _last_info["skill"][0] != skill)
      _last_info["skill"] = ({ skill, 2 });
    else
      _last_info["skill"][1] += 1;
    _last_info["time"] = time();
    if(!_last_info["object"] || _last_info["object"][0] != base_name(exp))
      _last_info["object"] = ({ base_name(exp), 2 });
    else
      _last_info["object"][1] += 1;
    if(!_last_info["env"] || _last_info["env"][0] != environment())
      _last_info["env"] = ({ environment(), 2 });
    else
      _last_info["env"][1] += 1;
    return 0;
  }
  if(!_last_info["skill"] || _last_info["skill"][0] != skill)
    _last_info["skill"] = ({ skill, 2 });
  else
    _last_info["skill"][1] += 1;
  _last_info["time"] = time();
  if(!_last_info["object"] || _last_info["object"][0] != base_name(exp))
    _last_info["object"] = ({ base_name(exp), 2 });
  else
    _last_info["object"][1] += 1;
  if(!_last_info["env"] || _last_info["env"][0] != environment())
    _last_info["env"] = ({ environment(), 2 });
  else
    _last_info["env"][1] += 1;
  return 1;
}
varargs int add_skill_level( string skill, int lvl, mixed exp ) {
   string guild, *recursive_skills, *same_level, *bits, *tree;
   int i;
   reset_eval_cost();
   if (!stringp(skill) || !intp(lvl) || lvl > 1000) {
      return 0;
   }
   if (!new_skills || (!mapp(new_skills))) {
      new_skills = ([ ]);
   }
   if (skill[0] == '.') {
      skill = skill[1..];
   }
   recursive_skills = (string *)SKILL_OB->query_related_skills(skill);
   if (!recursive_skills) {
      return 0;
   }
   bits = explode(skill, ".");
   if ( not_there( skill ) && !SKILL_OB->query_only_leaf(skill)) {
      int tmp_lvl, j;
      if (sizeof(bits) > 1) {
         tmp_lvl = 0;
         for (i=sizeof(bits)-1;!tmp_lvl && i>=0;i--) {
            if ( !not_there( implode( bits[ 0 .. i ], "." ) ) ) {
               tmp_lvl = new_skills[implode(bits[0..i], ".")];
               break;
            }
         }
         if (i>=0) {
            for (;i<sizeof(bits);i++) {
               same_level = (string *)
                 SKILL_OB->query_immediate_children(implode(bits[0..i], "."));
               for ( j = 0; j < sizeof( same_level ); j++ ) {
                  new_skills[ same_level[ j ] ] = tmp_lvl;
                  map_delete( _bonus_cache, same_level[ j ] );
               }
            }
         } else {
            tmp_lvl = 0;
         }
      }
   }
   for (i=0;i<sizeof(recursive_skills);i++) {
      if ( !not_there( recursive_skills[ i ] ) ) {
         new_skills[recursive_skills[i]] += lvl;
         if (new_skills[recursive_skills[i]] < 0) {
            new_skills[recursive_skills[i]] = 0;
         }
      }
      map_delete(_bonus_cache, recursive_skills[i]);
   }
   if ( not_there( skill ) ) {
      new_skills[skill] = lvl;
   }
   tree = (string *)SKILL_OB->query_skill_tree(skill);
   for (i=1;i<sizeof(tree);i++) {
      int total, j;
      same_level = (string *)SKILL_OB->query_immediate_children(tree[i]);
      if (sizeof(same_level)) {
         total = 0;
         for (j=0;j<sizeof(same_level);j++) {
            if ( not_there( same_level[ j ] ) ) {
               new_skills[ same_level[ j ] ] = new_skills[ tree[ i ] ];
               map_delete( _bonus_cache, same_level[ j ] );
            }
            total += new_skills[same_level[j]];
         }
         new_skills[tree[i]] = total/sizeof(same_level);
         map_delete( _bonus_cache, tree[ i ] );
      }
   }
   if ( interactive( this_object() ) &&
         ( guild = (string)this_object()->query_guild_ob() ) ) {
      if ( stringp( guild ) ) {
         guild->skills_advanced( this_object(), skill, new_skills[ skill ] );
      }
  }
  if((lvl == 1) && userp(this_object()) && (!exp || objectp(exp))) {
    if(!exp)
      exp = previous_object();
    if(!tm_check_ok(skill, exp)) {
      new_skills[skill] -= 1;
      return 0;
    } else {
      TASKER->award_made( (string)this_object()->query_name(),
                          base_name( exp ), skill, new_skills[ skill ] );
    }
  }
  if ( find_call_out( "reset_all" ) == -1 ) {
    call_out( "reset_all", 1 );
  }
  if(interactive(this_object()) && !this_object()->query_auto_loading())
     this_object()->save();
  return 1;
}
varargs int stat_modify( int lvl, string skill, int use_base_stats ) {
   int i, stat;
   string stat_bonus;
   float bonus;
   bonus = 0.0;
   if ( !_stat_cache[ skill ] || use_base_stats ) {
      stat_bonus = (string)SKILL_OB->query_skill_stat(skill);
      foreach ( i in stat_bonus ) {
         switch( i ) {
            case 'C' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_con();
               else
                  stat = (int)this_object()->query_con();
               break;
            case 'D' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_dex();
               else
                  stat = (int)this_object()->query_dex();
               break;
            case 'I' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_int();
               else
                  stat = (int)this_object()->query_int();
               break;
            case 'S' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_str();
               else
                  stat = (int)this_object()->query_str();
               break;
            case 'W' :
            default :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_wis();
               else
                  stat = (int)this_object()->query_wis();
         }
         if (stat > 0) {
            bonus += (log(stat) / 9.8) - 0.25;
         } else if (stat < 0) {
            bonus -= (log(-stat) / 9.8) + 0.25;
         } else {
            bonus -= 0.25;
         }
         if ( !_stat_cache[ i ] ) {
            _stat_cache[ i ] = ({ skill });
         } else {
            _stat_cache[ i ] |= ({ skill });
         }
      }
      if ( !use_base_stats ) {
         _stat_cache[ skill ] = ({ bonus, stat_bonus });
      }
   } else {
      bonus = _stat_cache[ skill ][ 0 ];
      stat_bonus = _stat_cache[ skill ][ 1 ];
   }
   i = strlen( stat_bonus );
   if ( i ) {
      stat = to_int(lvl + ( lvl * bonus ));
      if (stat < 0) {
         return 0;
      }
      return stat;
   }
   return lvl;
}
varargs int calc_bonus( int lvl, string skill, int use_base_stats ) {
   if (lvl > 60) {
      lvl = 170 + ((lvl-60) >> 1);
   } else if (lvl > 40) {
      lvl = 150 + (lvl-40);
   } else if (lvl > 20) {
      lvl = 100 + ( ((lvl-20)*5) >> 1);
   } else {
      lvl = lvl * 5;
   }
   if ( !use_base_stats ) {
      _bonus_cache[ skill ] = lvl;
   }
   return stat_modify( lvl, skill, use_base_stats );
}
int query_skill_successful(string str, int mod) {
  return (query_skill_bonus(str, 0) + mod >= random(200));
}
void add_teach_offer(object ob, string skill, int num, int lvl, int xp) {
  _teach_offer[ob] = ({ skill, num, lvl, xp });
}
mapping query_teach_offer() { return copy(_teach_offer); }
void stop_teaching_skills(int left, mixed bing) {
   object ob;
   if (left > 0) {
      if (bing[O_OTHER_PER] == this_object()) {
         say(this_object()->short() + " stops teaching themselves some "
             "skills.\n");
      } else if (previous_object() == this_object()) {
         ob = bing[O_OTHER_PER];
         tell_object(ob, this_object()->short() + " interupts your "
                         "training.\n");
      } else {
         ob = this_object();
         tell_object(ob, bing[O_OTHER_PER]->short() + " interupts your "
                         "training.\n");
      }
      say(bing[O_OTHER_PER]->short() + " stops teaching some skills to " +
          this_object()->short() + ".\n",
          ({ this_object(), bing[O_OTHER_PER] }));
      this_object()->adjust_time_left(-((int)this_object()->query_time_left()));
      this_object()->set_interupt_command(0);
      return ;
   }
   if (previous_object() != this_object()) {
      return ;
   }
   if(this_object()->query_xp() < bing[O_XP]) {
      write("Something has gone wrong. :(\n");
      return;
   }
   if (this_object() != bing[O_OTHER_PER]) {
      bing[O_OTHER_PER]->adjust_xp(bing[O_XP]/10);
   }
   this_object()->adjust_xp(-bing[O_XP]);
   add_skill_level(bing[O_SKILL], bing[O_NUM], bing[O_XP]);
   if (this_object() != bing[O_OTHER_PER]) {
      tell_object(this_object(), "You finish learning " + bing[O_NUM] +
                  " levels of "
                  + bing[O_SKILL] + " from " + bing[O_OTHER_PER]->short() +
                  ".\n");
      tell_object(bing[O_OTHER_PER], this_object()->short() + " finishes " +
                  "learning " + bing[O_NUM] + " levels of "
                  +bing[O_SKILL] + " from you.\n");
      say(this_object()->short() + " finishes learning some skills "+
          "from "+bing[O_OTHER_PER]->short()+".\n",
          ({ this_object(), bing[O_OTHER_PER] }));
   } else {
      tell_object(this_object(), "You finish teaching yourself " + bing[O_NUM] +
                  " levels of " + bing[O_SKILL] + ".\n");
      say(this_object()->short() + " finishes learning some skills "
          "from " + this_object()->query_objective() + "self.\n",
          ({ this_object(), bing[O_OTHER_PER] }));
   }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/living/nationality.c ===
#include <living.h>
#include <config.h>
private class living_nationality _nationality_data;
string query_nationality() {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality;
   }
   return 0;
}
string query_nationality_region() {
   if (_nationality_data && _nationality_data->region) {
      return _nationality_data->region;
   }
   return 0;
}
mixed query_nationality_data() {
   if (_nationality_data && _nationality_data->data) {
      return _nationality_data->data;
   }
   return 0;
}
void set_nationality(string nationality) {
   if (!_nationality_data) {
      _nationality_data = new(class living_nationality);
   }
   _nationality_data->nationality = nationality;
}
void set_nationality_region(string region) {
   if (!_nationality_data) {
      _nationality_data = new(class living_nationality);
   }
   _nationality_data->region = region;
}
void set_nationality_data(mixed data) {
   if (!_nationality_data) {
      _nationality_data = new(class living_nationality);
   }
   _nationality_data->data = data;
}
string query_nationality_name() {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality->query_name();
   }
   return 0;
}
string query_nationality_description(object looker) {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality->query_look_description(this_object(), looker);
   }
   return 0;
}
string query_nationality_accent_ob() {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality->query_region_accent_ob(_nationality_data->region);
   }
}
string query_nationality_start_location() {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality->query_start_location(_nationality_data->region);
   }
   return CONFIG_START_LOCATION;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/living/holding.c ===
nosave mixed *_using;
nosave mixed *_weapons;
#define START_VALUE "1"
int *set_hold(object ob, int location, int limbs);
int *set_unhold(object ob);
private int sub_hold(object ob, int pos, int first);
void create()
{
   _weapons = ({ });
}
string *query_limbs()
{
   string race_ob;
   string *limbs;
   race_ob = this_object()->query_race_ob();
   if (!race_ob) {
      _using = ({ });
      return ({ });
   }
   limbs = race_ob->query_limbs();
   if (!_using) {
      _using = allocate(sizeof(limbs));
   }
   return limbs;
}
string* query_using_array() {
   return copy(_using);
}
object *query_holding()
{
   if (!arrayp(_using)) {
      query_limbs();
   }
   _using =
      map(_using, (: $1 ? (environment($1) == this_object()? $1 : 0) : 0 :));
   return copy(_using);
}
string* query_holding_limbs(object ob) {
   string* ret;
   int i;
   object* holding;
   string* limbs;
   ret = ({ });
   holding = query_holding();
   limbs = query_limbs();
   for (i = 0; i < sizeof(holding); i++) {
      if (holding[i] == ob) {
         ret += ({ limbs[i] });
      }
   }
   return ret;
}
int query_free_limbs()
{
   if (!arrayp(_using)) {
      query_limbs();
   }
   return
      sizeof(filter(_using, (: !$1 || environment($1) != this_object() :)));
}
object *query_weapons()
{
   return filter(_weapons, (: $1 :));
}
int *set_unhold(object ob)
{
   int *pos;
   if (!objectp(ob)) {
      return ({ });
   }
   if (member_array(ob, _using) == -1) {
      return ({ });
   }
   if (!ob->set_holder(0)) {
      return ({ });
   }
   pos = find_member(ob, _using);
   if (ob->query_weapon()) {
      _weapons = filter(_weapons, (: $1 != $(ob) :));
   }
   if (ob->query_armour()) {
      this_object()->remove_armour(ob);
   }
   _using = map(_using, (: $1 == $(ob) ? 0 : $1 :));
   this_object()->do_burden_call();
   return pos;
}
int *set_hold(object ob, int pos, int limbs)
{
   int limb_count;
   int *free = ({ });
   int *used = ({ });
   int total = 0;
   int temp = 0;
   int ok;
   int failed;
   if (environment(ob) != this_object()) {
      debug_printf("Bad environment");
      return ({ });
   }
   limb_count = sizeof(this_player()->query_limbs());
   if (!arrayp(_using)) {
      query_limbs();
   }
   if (pos == -1) {
      total = ob->query_no_limbs();
      if (total > this_object()->query_free_limbs()) {
         debug_printf("Too many limbs");
         return ({ });
      }
      free = find_member(0, _using);
      if (!sizeof (free)) {
        return ({ });
      }
      pos = free[0];
   }
   if (objectp(_using[pos]) && environment(_using[pos]) == this_object()) {
      return ({ });
   }
   ok = sub_hold(ob, pos, 1);
   if (ok) {
      used += ({ pos });
   } else {
      return ({ });
   }
   if(limbs)
     total = limbs - 1;
   else
     total = ob->query_no_limbs() - 1;
   free = find_member(0, _using);
   temp = 0;
   while (temp < total && temp < sizeof(free)) {
      if (temp > limb_count) {
         set_unhold(ob);
         return ({ });
      }
      sub_hold(ob, free[temp], 0);
      if (ok) {
         used += ({ free[temp] });
         temp++;
      } else {
         failed = 1;
      }
   }
   if (failed) {
      set_unhold(ob);
      return ({ });
   } else {
     this_object()->do_burden_call();
      return used;
   }
}
private int sub_hold(object ob,
                     int pos,
                     int first)
{
   int success;
   if (environment(ob) != this_object()) {
      return 0;
   }
   if (first) {
      success = ob->set_holder(this_object(), pos);
      if (!success) {
         return 0;
      }
   }
   _using[pos] = ob;
   if (ob->query_weapon()) {
      if (member_array(ob, _weapons) == -1) {
         _weapons += ({ ob });
      }
   }
   return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/living/response_mon.c ===
#include <soul.h>
#include <language.h>
#define SPECIAL_DAY "/obj/handlers/special_day"
class response_data {
   object last_ob;
   string last_mess;
   int stop_responding;
   int use_regexp;
   int last_count;
   int last_time;
   int understand_anything;
   object* only_respond_to;
}
mixed *_respond_to_with;
nosave class response_data _response_data;
int match(string str, mixed str2);
void event_soul(object per, string mess, object *avoid, string verb,
                string last, mixed at) ;
void create() {
  _respond_to_with = ({ });
  _response_data = new(class response_data);
  _response_data->only_respond_to = ({ });
}
void set_response_mon_understand_anything(int flag) {
   _response_data->understand_anything = flag;
}
void set_response_mon_regexp(int flag) { _response_data->use_regexp = flag; }
int query_response_mon_regexp() { return _response_data->use_regexp; }
int query_response_mon_debug_mode() {
  return this_object()->query_property("respon mon debug");
}
void set_response_mon_debug_mode(int flag) {
  this_object()->add_property("respon mon debug", flag);
}
void set_stop_responding(int i) { _response_data->stop_responding = i; }
int query_stop_responding() { return _response_data->stop_responding; }
int query_response_allowed(object ob,
                           string *response) {
  if (!this_object()->query_visible(ob)) {
    return 0;
  }
  return 1;
}
void set_respond_to_with( mixed map ) {
  mixed *old_keys;
  int i;
  if ( mapp( map ) ) {
#ifdef DEBUG
    log_file("BAD_RESPONSE", "set_respond_to_with() called by %O (%s)\n",
             previous_object(), previous_object()->query_name());
#endif
    old_keys = keys(map);
    _respond_to_with = allocate(sizeof(old_keys) * 2);
    for (i = sizeof(old_keys); i--; ) {
      _respond_to_with[2*i] = old_keys[i];
      _respond_to_with[2*i+1] = map[old_keys[i]];
    }
    return;
  }
  _respond_to_with = map;
}
mixed *query_respond_to_with() { return _respond_to_with; }
void add_respond_to_with( mixed *trigger, mixed response ) {
  _respond_to_with += ({ trigger, response });
}
void add_only_respond_to(object person) {
  _response_data->only_respond_to += ({ person });
}
void remove_only_respond_to(object person) {
   _response_data->only_respond_to -= ({ person });
}
object* query_only_respond_to() {
   return _response_data->only_respond_to;
}
protected mixed *check_sub_sequence( mixed *words ) {
  int word_index;
  int format_index;
  int format_size;
  int word_size;
  int match_counter;
  int cu_format_size;
  string word_str;
  mixed data;
  string *patterns;
  string pattern;
  string extra;
  format_index = 0;
  word_size = sizeof( words );
  word_str = implode(words, " ");
  format_size = sizeof( _respond_to_with );
  while (format_index < format_size) {
    if ( _response_data->use_regexp ) {
        data = _respond_to_with[ format_index ];
        if ( arrayp( data ) && sizeof( data ) > 1 ) {
            if ( arrayp( data[0] ) ) {
                extra = "(" + implode( data, "|" ) + ")+";
            }
            else {
                extra = data[0];
            }
            patterns = map( data[1], (: $(extra) + " " + $1 :) );
        }
        else {
            patterns = ({ data });
        }
        foreach( pattern in patterns ) {
            if ( regexp( word_str, pattern ) ) {
                return _respond_to_with[ format_index + 1 ];
            }
        }
    }
    else {
        word_index = 0;
        match_counter = 0;
        cu_format_size = sizeof(_respond_to_with[format_index]);
        while ((word_index < word_size) && (match_counter < cu_format_size)) {
          match_counter += match(words[word_index],
                                 _respond_to_with[format_index][match_counter]);
          word_index++;
        }
        if (match_counter == (cu_format_size)) {
          return _respond_to_with[format_index + 1];
        }
    }
    format_index += 2;
  }
  return 0;
}
protected int match(string str, mixed format) {
  if (pointerp(format)) {
    return (member_array(str, format) != -1);
  }
  if (str == format) {
    return 1;
  }
  return 0;
}
protected string remove_read_marks(string str) {
  int blij;
  string result;
  int size;
  string temp;
  size = strlen(str);
  blij = 0;
  result = "";
  while (blij < size) {
    temp = str[blij..blij];
    if (((temp >= "a") && (temp <= "z")) ||
        ((temp >= "0") && (temp <= "9")) ||
        (temp == " ")) {
      result += temp;
    } else {
      result += " ";
    }
    blij++;
  }
  return result;
}
protected void senddstr(string str, object per) {
  if ( environment( this_object() ) ) {
    if ( per ) {
      command(replace(str, ({ "$hname$", per->query_name(), "$hcname$",
                                per->query_short(),
                              "$hshort$", per->query_short() })));
    } else {
      command( str );
    }
  }
}
protected void exec_response(mixed rep, object per, string mess) {
  string *rabbit;
  if (pointerp(rep)) {
    return exec_response(rep[random(sizeof(rep))], per, mess);
  }
  if (functionp(rep)) {
    evaluate(rep, per, mess);
  } else if (stringp(rep)) {
    if (rep[0..0] == "#") {
      rabbit = explode(rep[1..], "#");
      if (sizeof(rabbit) > 1) {
        call_out((: call_other($1, $2, $3, $4) :), 0,
                 rabbit[0], rabbit[1], per, mess);
      } else {
        call_out(rabbit[0], 0, per, mess);
      }
    } else {
      call_out("senddstr", 0, rep, per);
    }
  }
}
private void do_delay_thingy(string *extra, string mess, object per) {
  mixed *response;
  mess = lower_case(mess);
  if (!_response_data->use_regexp) {
    mess = remove_read_marks(mess);
  }
  if (query_response_mon_debug_mode()) {
    tell_object(per, "Parsing the text: " + implode(extra, " ") + " " + mess + "\n");
  }
  response = check_sub_sequence(extra + explode(mess, " "));
  if (query_response_mon_debug_mode()) {
    tell_object(per, sprintf("Responding with %O\n", response));
  }
  if (response) {
    if (query_response_allowed(per, response)) {
      exec_response(response, per, mess);
    }
  }
}
int check_loop(object per, string mess) {
  if(interactive(per)) {
    return 0;
  }
  if (_response_data->last_ob == per &&
      (_response_data->last_mess = mess) &&
      _response_data->last_time > time() - 10)
  {
    if(_response_data->last_count > 1) {
      return 1;
    } else {
      _response_data->last_count++;
    }
    _response_data->last_time = time();
  } else {
    _response_data->last_ob = per;
    _response_data->last_mess = mess;
    _response_data->last_count = 1;
    _response_data->last_time = time();
  }
  return 0;
}
private void do_response(string *extra, string mess, object per) {
  if (sizeof(_response_data->only_respond_to)) {
     _response_data->only_respond_to -= ({ 0 });
     if (sizeof(_response_data->only_respond_to) &&
         member_array(per, _response_data->only_respond_to) == -1) {
        return ;
     }
  }
  call_out((: do_delay_thingy($1, $2, $3) :), 2, extra, mess, per);
}
void event_person_sayto(object per, string mess, string lang, object* targets) {
  string skill;
  if(_response_data->stop_responding ||
     !sizeof(_respond_to_with) ||
     environment() == find_object( "/room/rubbish" ) ||
     environment() == find_object( "/room/void" ) ||
     !per || per == this_object()) {
    return ;
  }
  if(check_loop(per, mess)) {
    return;
  }
  skill = LANGUAGES->query_language_spoken_skill(lang);
  if (this_object()->query_skill(skill) < 90 ||
      per->query_skill(skill) < 60) {
    return;
  }
  do_response(({ "@sayto" }), mess, per);
}
void event_person_say(object per, string start, string mess, string lang) {
  string skill;
  if(_response_data->stop_responding ||
     !sizeof(_respond_to_with) ||
     environment() == find_object( "/room/rubbish" ) ||
     environment() == find_object( "/room/void" ) ||
     !per || per == this_object()) {
    return ;
  }
  if(check_loop(per, mess))
    return;
  if (!_response_data->understand_anything) {
     skill = LANGUAGES->query_language_spoken_skill(lang);
     if (this_object()->query_skill(skill) < 90 ||
         per->query_skill(skill) < 60) {
       return;
     }
  }
  do_response(({ "@say" }), mess, per);
}
varargs void event_soul(object per, string mess, object *avoid, string verb,
                        string last, mixed at) {
  if (per == find_object(SOUL_OBJECT))
    per = previous_object(2);
  if(!interactive(per) ||
     _response_data->stop_responding ||
     environment() == find_object( "/room/rubbish" ) ||
     environment() == find_object( "/room/void" ) ||
      member_array(this_object(), avoid) != -1 ||
     !sizeof(_respond_to_with)) {
    return ;
  }
  if((!objectp(at) || (objectp(at) && at != this_object())) &&
     environment(per) != environment() ) {
    return;
  }
  mess = this_object()->convert_message( mess );
  if(check_loop(per, mess))
    return;
  if (objectp(at)) {
    do_response(({ "@" + verb, "#" + last, at->query_name() }), mess, per);
  } else {
    do_response(({ "@" + verb, "#" + last }), mess, per);
  }
}
varargs void event_whisper(object per, string mess, object *obs, string lang,
                           object me) {
  string skill;
  if (!interactive(per) || _response_data->stop_responding ||
      environment() == find_object( "/room/rubbish" ) ||
      !sizeof(_respond_to_with)) {
    return ;
  }
  if(check_loop(per, mess)) {
    return;
  }
  if (!_response_data->understand_anything) {
    skill = LANGUAGES->query_language_spoken_skill(lang);
    if (this_object()->query_skill(skill) < 90 ||
        per->query_skill(skill) < 60) {
      return;
    }
  }
  if (member_array(this_object(), obs) == -1) {
    do_response(({ "@whisper", map(obs, (: $1->query_name() :)) }),
                "", per);
  } else {
    mess = this_object()->convert_message( mess );
    do_response(({ "@whisper", map(obs, (: $1->query_name() :)) }),
                mess, per);
  }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/living/health.c ===
#include <drinks.h>
#include <living.h>
#undef POINTS_LOG
#ifdef USE_SURRENDER
#define SURRENDER_SHADOW "/std/shadows/misc/surrender_shadow"
#endif
varargs int adjust_xp( int number, int shared );
int hp, max_hp, gp, max_gp, xp, wimpy, *drink_info;
#ifdef USE_SURENDER
int surrender;
#endif
nosave int max;
nosave int* runaway_callout_handles;
nosave string which;
nosave mapping counts;
mapping verbs;
nosave int callingdeath;
void create() {
   max_hp = 1;
   max_gp = 1;
#ifdef USE_SURRENDER
   surrender = -1;
#endif
   drink_info = allocate( D_SIZEOF );
   counts = ([ ]);
   verbs = ([ ]);
   callingdeath = 0;
   runaway_callout_handles = ({ });
}
int query_hp() { return hp; }
varargs int set_hp( int number, object attacker ) {
   if ( number > max_hp )
      number = max_hp;
   hp = number;
   if ( ( hp < 0 ) && ( find_call_out( "do_death" ) == -1 ) )
      call_out( "do_death", 0, attacker );
   return hp;
}
protected int check_wimpy() {
    int hp;
    hp = this_object()->query_hp();
    if ( hp < 1 )
        return 0;
    if( 100 * hp < this_object()->query_wimpy() *
        this_object()->query_max_hp()) {
        if(find_call_out("run_away") == -1) {
            runaway_callout_handles += ({ call_out("run_away", 0) });
        }
        return 1;
    }
    return 0;
}
#ifdef USE_SURRENDER
protected int check_surrender() {
   int hp;
   object *attackers, *all, shad;
   hp = this_object()->query_hp();
   if (hp < 1)
      return 0;
   if (hp * 100 < this_object()->query_surrender() *
       this_object()->query_max_hp()) {
     attackers = filter(this_object()->query_attacker_list(),
                        (: $1 && !$1->query_property("dead") &&
                         environment($1) == environment($2) :),
                        this_object());
     all = attackers + ({ this_object() });
     all->event_surrender(this_object(), attackers);
     shad = clone_object(SURRENDER_SHADOW);
     if (shad) {
       shad->setup_shadow(this_object(), attackers);
     }
     return 1;
   }
   return 0;
}
#endif
void reset_callingdeath() {
  callingdeath = 0;
}
int query_callingdeath() {
    return callingdeath;
}
varargs int adjust_hp(int number, object attacker, object weapon,
                      string attack) {
    int i;
    hp += number;
    if ( hp > max_hp )
        hp = max_hp;
    if (hp <= 0 && !callingdeath) {
        callingdeath = time();
        call_out("do_death", 0, attacker, weapon, attack);
        for( i=0; i<sizeof(runaway_callout_handles); i++ ) {
            remove_call_out( runaway_callout_handles[i] );
        }
        runaway_callout_handles = ({ });
    }
    if (hp > 0 && number < 0 && attacker && attacker != this_object()) {
#ifdef USE_SURRENDER
        if(this_object()->query_surrender() >= this_object()->query_wimpy()) {
            if (!check_surrender())
                check_wimpy();
        }
        else {
            if (!check_wimpy())
                check_surrender();
        }
#else
        check_wimpy();
#endif
    }
    return hp;
}
varargs string health_string(int flag, int ref health_level) {
   int level;
   string ret;
   if ( this_object()->query_property( "dead" ) )  {
      ret = "appears to be dead";
      level = 0;
   }
   else if ( hp < max_hp / 10 )  {
      ret = "is in very bad shape";
      level = 1;
   }
   else if ( hp < max_hp / 5 )  {
      ret = "is in bad shape";
      level = 2;
   }
   else if ( hp < max_hp / 2 )  {
      ret = "is not in good shape";
      level = 3;
   }
   else if ( hp < ( max_hp - 200 ) )  {
      ret = "is slightly hurt";
      level = 4;
   }
   else  {
      ret = "is in good shape";
      level = 5;
   }
   if (!undefinedp(flag))   health_level = level;
   return ret;
}
int query_max_hp() { return max_hp; }
int set_max_hp( int number ) {
  int old_hp;
  old_hp = hp;
  if ( max_hp == hp )
    hp = number;
  else
    if ( max_hp )
      hp = ( hp * number ) / max_hp;
    else
      hp = number;
  max_hp = number;
  if ( hp > max_hp )
    hp = max_hp;
  if ( ( hp < 0 ) && ( old_hp > 0 ) )
    hp = max_hp;
  return max_hp;
}
int query_gp() { return gp; }
int query_specific_gp( string gp_type ) {
   int now;
   if ( !gp_type )
      return 0;
   max = (int)this_object()->query_skill_bonus( gp_type
         +".points" ) + 50;
   if ( max >= max_gp )
      max = max_gp;
   now = gp + max - max_gp;
   which = gp_type;
   if ( find_call_out( "clear_gp_info" ) == -1 )
      call_out( "clear_gp_info", 1 );
   return now;
}
void clear_gp_info() { which = 0; }
int set_gp( int number ) {
   gp = number;
   if ( gp > max_gp )
      gp = max_gp;
   return gp;
}
int adjust_gp( int number ) {
  int tmp, diff;
  string guild_ob, current_verb;
  mixed *bits;
  if ( gp + number < 0 )
    return -1;
  gp += number;
  if ( gp > max_gp )
    gp = max_gp;
  tmp = number;
  if((number < 0) && stringp(which)) {
    if (number > ( GP_ADVANCE_MOD * max ) / MIN_TIMES)
      number = (GP_ADVANCE_MOD * max) / MIN_TIMES;
    counts[ which ] -= number;
    if (counts[ which ] > GP_ADVANCE_MOD * max) {
      counts[ which ] = 0;
      number = this_object()->query_skill(which +".points");
      if(!random(to_int(exp(number/150.0))) &&
         this_object()->add_skill_level( which +".points", 1,
                                         this_object())) {
        tell_object( this_object(), "%^YELLOW%^You find yourself "
                     "more able to concentrate on this task than you "
                     "thought.%^RESET%^\n" );
      }
#ifdef POINTS_LOG
      log_file( "POINTS", time() +" "+
                (string)this_object()->query_name() +" gets "+
                which +" ("+ max +")\n" );
#endif
    }
    number = tmp;
    guild_ob = this_object()->query_guild_ob();
    if(guild_ob && member_array(query_verb(), guild_ob->query_commands()) != -1)
      number *= -10;
    else
      number *= -4;
    if(query_verb() == "pray" || query_verb() == "berserk" ||
       query_verb() == "spellcheck" || query_verb() == "octograve")
      number /= 2;
    current_verb = query_verb();
    if(current_verb == "cast" || current_verb == "perform") {
      current_verb = this_object()->query_current_cmd();
    }
    if(verbs[current_verb]) {
      bits = verbs[current_verb];
      diff = time() - bits[0];
      if(diff > 300)
        bits[1] /= 2;
      if(bits[1] < 1)
        bits[1] = 1;
      if(bits[1] > 1 && bits[2] == environment())
        bits[1] += 1;
      if(bits[1] < 10)
         number /= (random(bits[1]) + 1);
      else
        number = 0;
      verbs[current_verb] = ({ time(), bits[1]+1, environment() });
    } else {
      verbs[current_verb] = ({ time(), 1, environment() });
    }
    if(number)
      adjust_xp(number, 1);
#ifdef GUILD_XP
    log_file("GUILD_XP", "%s Gave %s %d points for %s [%s, %d]\n",
             ctime(time()), this_object()->query_name(), number,
             current_verb, verbs[current_verb][0], verbs[current_verb][1]);
#endif
  }
  return gp;
}
int query_max_gp() { return max_gp; }
int set_max_gp( int number ) {
  if ( max_gp ) gp = ( gp * number ) / max_gp;
  else gp = number;
  max_gp = number;
  if ( gp > max_gp ) gp = max_gp;
  return max_gp;
}
int query_xp() { return xp; }
varargs int adjust_xp( int number, int shared ) {
  if(number > 0 && (xp > 10000000 || xp + number > 10000000))
    return xp;
  if(number > 10000 && previous_object() &&
     explode(file_name(previous_object()), "/")[0] == "w")
    log_file("/d/admin/log/CHEAT", ctime(time()) + " " +
             file_name(previous_object()) +
             " gave " + number + " Xp for " + this_object()->query_name() +
             "\n");
   xp += number;
   return xp;
}
int query_wimpy() { return wimpy < 30 ? wimpy : 30; }
int set_wimpy( int number ) {
  if ( ( number < 0 ) || ( number > 30 ) ) return -1;
  return wimpy = number;
}
#ifdef USE_SURRENDER
int query_surrender() {
  if (surrender == -1) {
    if (wimpy > 94)
      return 100;
    else
      return wimpy + 5;
  } else
    return surrender;
}
int set_surrender( int number ) {
  if ( ( number < 0 ) || ( number > 100 ) ) return -1;
  return surrender = number;
}
#endif
int *query_drink_info() { return drink_info; }
int query_volume( int type ) {
  if ( type >= D_SIZEOF ) return 0;
  return drink_info[ type ];
}
int adjust_volume( int type, int amount ) {
  if ( type >= D_SIZEOF ) return 0;
  return drink_info[ type ] += amount;
}
void update_volumes() {
  int i, delta;
  delta = (int)this_object()->query_con();
  for ( i = 0; i < sizeof( drink_info ); i++ ) {
    if ( drink_info[ i ] > delta ) {
      drink_info[ i ] -= delta;
      if(this_object()->query_personal_temp() >  0 && i == D_DRINK)
  this_object()->adjust_personal_temp(-(delta/3));
      else if(this_object()->query_personal_temp() <  0 && i == D_FOOD)
  this_object()->adjust_personal_temp(delta/3);
    } else
      if ( drink_info[ i ] < -delta )
        drink_info[ i ] += delta;
      else
        drink_info[ i ] = 0;
  }
}
mapping query_counts() { return counts; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/living/gender.old ===
/*  -*- LPC -*-  */
/*
 * $Locker: arby $
 * $Id: gender.c,v 1.1 1998/01/06 04:29:08 ceres Exp arby $
 * $Log: gender.c,v $
 * Revision 1.1  1998/01/06 04:29:08  ceres
 * Initial revision
 * 
*/
int gender;
nosave int womens_day;

int query_female() { return (gender == 2) || womens_day; }
int query_gender() { return (womens_day?2:gender); }
int query_male() { return gender == 1 && !womens_day; }
int query_neuter() { return !gender && !womens_day; }

string query_gender_string() {
    if (!gender && !womens_day) return "neuter";
    else if (gender == 1 && !womens_day) return "male";
    else return "female";
}

string query_gender_title() {
    if (!gender && !womens_day) return "creature";
    else if (gender == 1 && !womens_day) return "sir";
    else return "madam";
}
 
string query_objective() {
    if (!gender && !womens_day)
        return "it";
    else if (gender == 1 && !womens_day)
        return "him";
    else return "her";
}
 
string query_possessive() {
    if (!gender && !womens_day)
        return "its";
    else if (gender == 1 && !womens_day)
        return "his";
    else return "her";
}
 
string query_pronoun() {
    if (!gender && !womens_day)
        return "it";
    else if (gender == 1 && !womens_day)
        return "he";
    else return "she";
}

void set_gender(mixed arg) {
  if(stringp(arg)) {
    if(arg == "male")
      gender = 1;
    else if(arg == "female")
      gender = 2;
    else
      gender = 0;
  } else {
    gender = arg;
  }
} /* set_gender() */

/* Can only set ourselves on or off on womens day */
/* Bollocks. */
void set_womens_day(int bing) {
/*
  if (previous_object() != this_object())
    return ;
*/
  womens_day = bing;
} /* set_womens_day() */


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/living/carrying.c ===
#include <clothing.h>
#include <money.h>
object* query_wearing();
protected varargs string *query_types_worn( object *things ) {
   int i;
   string *types;
   mixed *stuff;
   types = ({ });
   if ( !things ) {
      things = (object *)this_object()->query_wearing();
   }
   stuff = (mixed *)things->query_type();
   for ( i = sizeof( stuff ) - 1; i > -1; i-- ) {
      if ( stringp( stuff[ i ] ) ) {
         stuff[ i ] = ({ stuff[ i ] });
      }
      if ( !pointerp( stuff[ i ] ) ) {
         printf( "%O (%s) has an invalid type.  Please bug report it.\n",
                 things[ i ], (string)things[ i ]->query_short() );
         stuff[ i ] = ({ "broken" });
      }
      types += stuff[ i ];
   }
   return ({ types, stuff });
}
object* query_wearing_hidden(object looker, object *things) {
   mixed* bing;
   string* types;
   mixed* obj_types;
   object* worn;
   object* ret;
   int i;
   int found_under;
   string fluff;
   string under_type;
   string* under;
   if (!things) {
      worn = query_wearing();
   } else {
      worn = things;
   }
   bing = query_types_worn( worn );
   types = bing[0];
   obj_types = bing[1];
   ret = ({ });
   for (i = 0; i < sizeof(worn); i++) {
      if (worn[i]->query_visible(looker)) {
         found_under = 0;
         foreach (fluff in obj_types[i]) {
            under = CLOTHING_HANDLER->query_clothing_hiding( fluff );
            if ( under && sizeof(under)) {
               foreach (under_type in under) {
                  if (member_array(under_type, types) != -1) {
                     ret += ({ worn[i] });
                     found_under = 1;
                     break;
                  }
               }
            }
            if (found_under) {
               break;
            }
         }
      } else {
         ret += ({ worn[i] });
      }
   }
   return ret;
}
protected string armour_list( object *things, int hidden_only, int self) {
   string word;
   object* hidden;
   hidden = query_wearing_hidden( this_player(), things);
   if (hidden_only) {
      things = filter(hidden, (: $1->query_visible( this_player() ) :));
   } else {
      things = things - hidden;
   }
   if ( !sizeof( things ) ) {
      return 0;
   }
   if (!self) {
      things = sort_array(things,
               (: CLOTHING_HANDLER->query_clothing_depth($2->query_type())  -
                  CLOTHING_HANDLER->query_clothing_depth($1->query_type()) :));
   }
   word = query_multiple_short( things );
   return word;
}
string query_living_contents( int self ) {
   string s;
   string fish;
   string *limbs;
   string *bits;
   string *strs;
   object *holding;
   object *arms;
   object *carry;
   object *conts;
   object money;
   object ob;
   int i;
   int coins;
   int pos;
   s = "";
   strs = ({ });
   conts = ({ });
   limbs = this_object()->query_limbs();
   if (!limbs) {
      limbs = ( this_object()->query_race_ob() )->query_limbs();
   }
   conts = filter(all_inventory(), (: $1->short(0) :) );
   if(!limbs || !sizeof(limbs))
     holding = ({ });
   else
     holding = (object *)this_object()->query_holding() + ({ });
   arms = (object *)this_object()->query_armours() - holding;
   money = present(MONEY_ALIAS, this_object());
   if(!arms) {
      arms = ({ });
   }
   carry = conts - arms - holding - ({ money });
   for (i = 0; i < sizeof(holding); i++) {
     if (holding[i] && environment(holding[i]) == this_object()) {
       bits = ({ limbs[i] });
       ob = holding[i];
       holding[i] = 0;
       while ((pos = member_array(ob, holding)) != -1) {
         bits += ({ limbs[pos] });
         holding[pos] = 0;
       }
       strs += ({  ob->a_short() + " (" +
                     query_multiple_short(bits, "a", 1)+")" });
     }
   }
   if (sizeof(strs)) {
      s += "$I$+10,+0=%^RED%^Holding%^RESET%^ : " +
         query_multiple_short( strs ) +
         ".\n$I$-10,-0=";
   }
   if ( sizeof( arms ) ) {
      if ( fish = armour_list( arms, 0, self) ) {
         s += "$I$+10,+0=%^YELLOW%^Wearing%^RESET%^ : " + fish +
            ".\n$I$-10,-0=";
      }
      if ( self && (fish = armour_list(arms, 1, self) ) ) {
         s += "$I$+10,+0=%^YELLOW%^(under)%^RESET%^ : " + fish +
            ".\n$I$-10,-0=";
      }
   }
   if ( sizeof( carry ) ) {
      fish = this_object()->query_contents(0, carry, 1);
      if ( fish ) {
         if (pointerp(fish)) {
            s += "$I$+10,+0=%^GREEN%^" + fish[1] + "%^RESET%^: " + fish[0] +
               "$I$-10,-0=";
         } else {
            s += "$I$+10,+0=%^GREEN%^Carrying%^RESET%^: " + fish +
               "$I$-10,-0=";
         }
      }
   }
   if ( self && environment() &&
        this_object()->check_dark(environment()->query_light()) > -1) {
      if ( money ) {
         fish = query_multiple_short( (string *)money->half_short( 1 ) );
      } else {
         fish = 0;
      }
      if ( s == "" ) {
         s = "You are empty handed.\n";
      }
      s += "Your purse contains " + (fish?fish:"only moths") + ".\n";
   } else if(money) {
      coins = (int)money->query_number_coins();
      if (self) {
         s += "Your purse is ";
      } else {
         s += capitalize( (string)this_object()->query_possessive() ) +
              " purse is ";
      }
      switch(coins) {
      case 0..10:
         s += "home to only moths!\n";
         break;
      case 11..100:
         s += "tinkling with coins.\n";
         break;
      case 101..300:
         s += "bulging with coins.\n";
         break;
      default:
         s += "fit to burst!\n";
         break;
      }
   }
   return s;
}
