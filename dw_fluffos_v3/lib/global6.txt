
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/more_file.c ===
#include <nroff.h>
#include <cmds/options.h>
#define ROWS (this_player()->query_rows() - 1)
#define COLS this_player()->query_cols()
private nosave int fsize, topl, botl, charl, real_rows, search_flag;
private nosave mixed mark_data;
private nosave string _more_file_fname,
              *mark_name,
              *filenames,
              finish_func,
              stat_line,
              last_search;
private int display_file() {
   int i;
   int ncols;
   int nrows;
   string file;
   string *bits;
   string *lines;
   string tstop;
   int tab;
   ncols = COLS;
   nrows = ROWS;
   file = read_file(_more_file_fname, topl, nrows);
   if (file == 0)
      return 0;
   tab = this_player()->query_property(TABSTOP_PROP);
   if (tab)
      tstop = sprintf("%" + tab + "' 's", "");
   else
      tstop = "<TAB>";
   file = replace(file, ({ "\t", tstop,
                           "\r", "^M",
                           sprintf("%c", 13), "^M" }));
   bits = explode("x\n" + file, "\n")[1 .. ];
   if (charl)
      bits[0] = bits[0][charl .. ];
   real_rows = 0;
   lines = ({ });
   for (i = 0; i < sizeof(bits); i++)  {
      if (strlen(bits[i]) > ncols)  {
         lines = ({ lines..., bits[i][0 .. ncols - 1] });
         bits[i] = bits[i][ncols .. ];
         charl += ncols;
         --i;
      } else {
         lines  = ({ lines..., bits[i] });
         charl = 0;
         ++real_rows;
      }
      if (sizeof(lines) == nrows)
         break;
   }
   printf("%s\n", implode(lines, "\n"));
   botl = topl + real_rows - 1;
   if (botl > fsize)
      botl = fsize;
  return 1;
}
private int get_next_filename() {
  string str;
  _more_file_fname = filenames[0];
  filenames = filenames[1 .. ];
  fsize = file_length(_more_file_fname);
  if (fsize == 0) {
    printf("Empty file.\n");
    if (sizeof(filenames) > 1)
      return get_next_filename();
    else
      return 0;
  }
  if (fsize == -1) {
    printf("File does not exist.\n");
    if (sizeof(filenames) > 1)
      return get_next_filename();
    else
      return 0;
  }
  if (fsize == -2) {
    printf("You cannot more a directory.\n");
    if (sizeof(filenames) > 1)
      return get_next_filename();
    else
      return 0;
  }
  topl = 1;
  charl = 0;
  printf( "\n" );
  str = read_file(_more_file_fname, 1, 1);
  if (str == 0)
    return 0;
  if (str[0] == '.')  {
    string s2;
    str = "/tmp/nroffed_file";
    if (NROFF_HAND->create_nroff(_more_file_fname, "/tmp/nroffed_file")) {
      s2 = NROFF_HAND->cat_file("/tmp/nroffed_file");
      rm("/tmp/nroffed_file.o");
      if (s2 != 0) {
        this_player()->more_string(s2, _more_file_fname);
        fsize = ROWS - 3;
        return 1;
      }
    }
  }
  return display_file();
}
private string *expand_path(string s) {
  string *s1;
  s1 = this_player()->get_files(s);
  if (s1 == 0)
    return ({ s });
  return s1;
}
int set_mark(string s) {
   int i;
   if (!mark_name) {
      mark_name = ({ });
      mark_data = ({ });
   }
   if ((i = member_array(s, mark_name)) != -1)
      mark_data[i] = ({ _more_file_fname, topl });
   else {
      mark_name += ({ s });
      mark_data += ({ ({ _more_file_fname, topl }) });
   }
   return 1;
}
private void status_line() {
   string *frog;
   string s;
   int i, percentage;
   if (!stat_line)
      stat_line = "$N From $T to $B of $S ($%%) - h for help. ";
   s = "";
   frog = explode(stat_line, "$");
   for (i = 0; i < sizeof(frog); i++) {
      if (frog[i] == "") {
         s += "$";
         ++i;
      }
      else switch (frog[i][0]) {
         case 'N':
            s += _more_file_fname + frog[i][1 .. ];
            break;
         case 'T':
            s += topl + frog[i][1 .. ];
            break;
         case 'B':
            if (botl > fsize)
               s += fsize + frog[i][1 .. ];
            else
               s += botl + frog[i][1 .. ];
            break;
         case '%':
            percentage = (botl * 100) / fsize;
            if (percentage > 100) percentage = 100;
            s += percentage + frog[i][1 .. ];
            break;
         case 'S':
            s += fsize + frog[i][1 .. ];
            break;
         default:
            printf("Bad tag (%s) found in format string.\n", frog[i]);
            break;
      }
   }
   printf("%s", s);
   return;
}
void next_page(string str) {
   int num, noargs, i, j, k, redraw;
   string s1, *s3;
   if (str == 0)
      str = "";
   if (sscanf(str, "%d%s", num, str) != 2)
      noargs = 1;
   s1 = extract(str, 1);
   switch (str[0 .. 0]) {
      case "":
      case " ":
         topl += real_rows;
         redraw = 1;
         break;
      case "f":
         if (noargs)
            num = 1;
         topl += ROWS * num;
         redraw = 1;
         break;
      case "q" :
         printf("OK.\n");
         return;
      case "/":
         search_flag = 0;
         j = topl + 4;
         if (s1[0] == '!') {
            search_flag = 1;
            s1 = extract(s1, 1);
         }
         set_mark("'");
         if (s1=="" || !s1)
            s1 = last_search;
         if (s1 == "") {
            printf("No previous search string.\n");
            break;
         }
         do {
            i = j;
            j = i + 900;
            if (j > fsize)
               j = fsize;
            s3 = explode(read_file(_more_file_fname, i, j), "\n");
            for (k = 0; k < sizeof(s3); k++)
               if (!search_flag) {
                  if (sscanf(s3[k], "%*s" + s1 + "%*s") == 2)
                     if (num-- <= 0)
                        break;
               } else
                  if (sscanf(s3[k], "%*s" + s1 + "%*s") != 2)
                     if (num-- <= 0)
                     break;
         } while (j < fsize && k == sizeof(s3));
         if (k == sizeof(s3))
            printf("Sorry " + s1 + " not found.\n");
         else {
            topl = i + k - 3;
            redraw = 1;
         }
         last_search = s1;
         break;
      case "?":
         i = topl;
         if (s1[0] == '!') {
            s1 = extract(s1, 1);
            search_flag = 3;
         } else
            search_flag = 2;
         set_mark("'");
         if (s1=="" || !s1)
            s1 = last_search;
         if (s1 == "") {
            printf("No previous search string.\n");
            break;
         }
         do {
            j = i - 900;
            if (j < 0)
               j = 0;
            s3 = explode(read_file(_more_file_fname, j, i), "\n");
            for (k = 0; k < sizeof(s3); k++)
               if (search_flag == 2) {
                  if (sscanf(s3[k], "%*s" + s1 + "%*s") == 2)
                     if (num-- <= 0)
                        break;
               } else
                  if (sscanf(s3[k], "%*s" + s1 + "%*s") != 2)
                     if (num-- <= 0)
                        break;
            i = j;
         } while (j > 0 && k == sizeof(s3));
         if (k == sizeof(s3))
            printf("Sorry "+ s1 +" not found.\n");
         else {
            topl = k + i - 2;
            redraw = 1;
         }
         last_search = s1;
         break;
      case "n":
         switch (search_flag) {
            case 0:
               next_page(num + "/");
               break;
            case 1:
               next_page(num + "/!");
               break;
            case 2:
               next_page(num + "?");
               break;
            case 3:
               next_page(num + "?!");
               break;
         }
         return;
      case "b":
         if (noargs)
            num = 1;
         if (topl > 0) {
            topl -= ROWS * num;
            redraw = 1;
            if (topl < 0)
               topl = 0;
         }
         break;
      case "G":
         if (noargs)
            num = fsize - ROWS + 1;
      case "g":
         set_mark("'");
         topl = num;
         if (topl >= fsize)
         topl = fsize - 2;
         redraw = 1;
         break;
      case "P":
         if (noargs)
            num = 100;
      case "p":
      case "%":
         redraw = 1;
         set_mark("'");
         topl = (num * fsize) / 100;
         if (topl + ROWS - 1 > fsize)
            topl -= ROWS - 1;
         break;
      case "d":
         if (noargs)
            num = ROWS / 2;
         topl += num;
         redraw = 1;
         break;
      case "u":
         if (noargs)
            num = ROWS / 2;
         topl -= num;
         redraw = 1;
         break;
      case "r":
         redraw = 1;
         break;
      case "m":
         if (s1 == "") {
            printf("Sorry, you must specify a name.\n");
            break;
         }
         set_mark(s1);
         printf("OK, mark " + s1 + " set.\n");
         break;
      case "'":
         if (!mark_name) {
            printf("Sorry, must go to a mark.\n");
            break;
         }
         if ((i = member_array(s1, mark_name)) != -1) {
            if (_more_file_fname != mark_data[i][0]) {
               _more_file_fname = mark_data[i][0];
               redraw = 1;
            }
            if (topl != mark_data[i][1]) {
               topl = mark_data[i][1];
               redraw = 1;
            }
         } else
            printf("Mark " + s1 + " not set.\n");
         break;
      case "F":
         filenames = expand_path(str);
         if (sizeof(filenames) == 0) {
            printf("No matching files.\n");
            break;
         }
         last_search = "";
         redraw = get_next_filename();
         break;
      case "h":
         cat("/doc/helpdir/more");
         break;
   }
   if (redraw)
      display_file();
   if (botl < fsize || charl) {
      status_line();
      input_to("next_page");
   } else
      if (sizeof(filenames) > 0) {
         if (get_next_filename())
            input_to("next_page");
         else if (finish_func)
            call_other(this_player(), finish_func);
      } else {
         if (finish_func)
            call_other(this_player(), finish_func);
      }
}
int more_file(string str) {
   filenames = expand_path(str);
   if (!sizeof(filenames)) {
      notify_fail("No matching files.\n");
      return 0;
   }
   last_search = "";
   if (!get_next_filename())  {
      notify_fail("Could not read " + _more_file_fname + ".\n");
      return 0;
   }
   if (botl < fsize || charl) {
      status_line();
      input_to("next_page");
   } else
      if (finish_func)
         call_other(this_player(), finish_func);
   return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/log.c ===
private nosave mapping last_error;
void logging_commands() {
}
void set_last_error(mapping err) {
  last_error = err;
}
mapping get_last_error() {
  return (mapp(last_error)?last_error:0);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/playtester.c ===
#include <login_handler.h>
#include <command.h>
#include <player.h>
#define PROTECTION_LOG "/log/secure/playtesters/protection_log"
#define MAX_COUNTER 2
class playtester_data {
   int protect;
   int hp;
   string log_file;
   int log_death;
   int log_damage;
   int turn_off;
   int protection_counter;
   int room_protection;
}
inherit "/global/player";
int query_in_pt_arena();
private nosave class playtester_data _pt_data;
int query_pt_area (object ob) {
  string *file;
  if (strsrch (base_name (ob), "_pt") != -1) {
    return 1;
  }
  if (strsrch (base_name (ob), "_dev") != -1) {
    return 1;
  }
  file = explode (base_name (ob), "/");
  if (file[1] == "playtesters") {
    return 1;
  }
  return 0;
}
void create() {
   ::create();
   _pt_data = new(class playtester_data);
}
void move_player_to_start(string bong, int new_pl, string c_name, string ident, int go_invis) {
  if(!sscanf(file_name(previous_object()), "/secure/login#%*s") &&
     !sscanf(file_name(previous_object()), "/secure/nlogin#%*s"))
    return 0;
#ifndef NEW_DRIVER
#endif
  ::move_player_to_start(bong, new_pl, c_name, ident, go_invis);
  AddSearchPath(({ DIR_PLAYTESTER_CMDS }));
  if (PLAYTESTER_HAND->query_senior_playtester(query_name())) {
     AddSearchPath(({ DIR_SENIOR_PLAYTESTER_CMDS }));
  }
  if (PLAYTESTER_HAND->query_exec_access (query_name())) {
     AddSearchPath(({ DIR_EXEC_PLAYTESTER_CMDS }));
  }
}
int query_playtester() { return 1; }
string query_object_type(object) {
  if (PLAYTESTER_HAND->query_pt_exec(query_name())) {
    return "E";
  }
  if (PLAYTESTER_HAND->query_senior_playtester(query_name())) {
    return "P";
  }
  return "p";
}
int query_pt_protection() {
  if (_pt_data->room_protection) {
    return 2;
  }
  return _pt_data->protect;
}
int enable_pt_protection() {
  if (_pt_data->room_protection != 1) {
   log_file (PROTECTION_LOG, "%s: %s had room PT "
    "protection enabled by %s.\n", ctime(time()), this_player()->query_name(),
    base_name (environment (this_player())));
    tell_object (this_player(), "%^BOLD%^You have had your playtester "
      "protection enabled by an external source.  It will last until switched "
      "off by another external source.\n%^RESET%^");
    _pt_data->room_protection = 1;
    return 1;
  }
  return 0;
}
int disable_pt_protection() {
  if (_pt_data->room_protection == 1) {
   log_file (PROTECTION_LOG, "%s: %s had room PT "
    "protection disabled by %s.\n", ctime(time()), this_player()->query_name(),
    base_name (environment (this_player())));
    tell_object (this_player(), "%^BOLD%^The playtester protection enabled "
      "by an external source has been switched off.\n%^RESET%^");
    _pt_data->room_protection = 0;
    return 1;
  }
  return 0;
}
int enable_personal_pt_protection() {
  if (query_pt_protection()) {
    return 0;
  }
   _pt_data = new(class playtester_data);
   _pt_data->hp = ::query_hp();
   _pt_data->protect = 1;
   _pt_data->log_file = "/d/playtesters/log/pain";
   tell_room (environment (this_player()), this_player()->one_short()
      + " looks as if " + this_player()->query_pronoun() + " no longer has "
      "any fear of the risks of the real world.\n", this_player());
   log_file (PROTECTION_LOG, "%s: %s enabled PT "
    "protection (%s).\n", ctime(time()), this_player()->query_name(),
    base_name (environment (this_player())));
   if (_pt_data->turn_off) {
      remove_call_out(_pt_data->turn_off);
   }
   if (!query_pt_area (environment (this_player()))) {
      tell_object (this_player(), "%^BOLD%^You feel somewhat more secure, as if "
        "you can no longer be harmed by conventional weapons (This will "
        "only last a maximum of fifteen minutes).%^RESET%^\n");
     _pt_data->protection_counter = 0;
     _pt_data->turn_off = call_out("disable_personal_pt_protection", 5 * 60);
   }
   else {
      tell_object (this_player(), "%^BOLD%^You feel somewhat more secure, as if "
        "you can no longer be harmed by conventional weapons (This will "
        "last until you switch it off or leave a PT area).%^RESET%^\n");
  }
   return 1;
}
int disable_personal_pt_protection() {
  if (query_pt_protection() != 1) {
    return 0;
  }
  if (this_player()) {
    _pt_data->protection_counter = MAX_COUNTER;
  }
  if (_pt_data->protection_counter < MAX_COUNTER) {
    tell_object (this_player(), "%^BOLD%^You still have your PT protection "
      "enabled.\n%^RESET%^");
    log_file (PROTECTION_LOG, "%s: %s warned about still enabled PT "
      "protection (%s).\n", ctime(time()), this_player()->query_name(),
      base_name (environment (this_player())));
    _pt_data->turn_off = call_out("disable_personal_pt_protection", 5 * 60);
    _pt_data->protection_counter = _pt_data->protection_counter + 1;
    return 0;
  }
   _pt_data->turn_off = 0;
   _pt_data->protect = 0;
   _pt_data->protection_counter = 0;
   log_file (PROTECTION_LOG, "%s: %s disabled PT "
    "protection (%s).\n", ctime(time()), this_player()->query_name(),
    base_name (environment (this_player())));
   tell_object (this_player(), "%^BOLD%^You feel less secure in your "
    "indestructability.%^RESET%^\n");
   tell_room (environment (this_player()), this_player()->one_short()
      + " looks as if the risks of the real world are once again "
      "relevant.\n", this_player());
   return 1;
}
void pt_set_hp( int hp ) {
   _pt_data->hp = hp;
}
int pt_query_hp() {
   return _pt_data->hp;
}
object pt_make_corpse() {
   object corpse;
   corpse = clone_object( "/obj/corpse" );
   corpse->set_owner( 0, this_object() );
   corpse->set_ownership( query_name() );
   corpse->set_race_name( query_race() );
   if ( !query_race_ob() ) {
      corpse->set_race_ob( "/std/races/unknown" );
   } else {
      corpse->set_race_ob( query_race_ob() );
   }
   corpse->add_adjective( query_adjectives() );
   corpse->start_decay();
   return corpse;
}
object pt_do_death() {
   object corpse, flowers;
   DEATH->death_informer( this_object(), 0, _pt_data->log_file, 1 );
   tell_object( this_object(),
         "The Death of Playtesters sneaks up behind you and taps "
         "you on the shoulder.\n"
         "%^CYAN%^The Death of Playtesters says: MY, WE'VE BEEN A BIT "
         "CARELESS, HAVEN'T WE?%^RESET%^\n"
         "The Death of Playtesters coughs.\n"
         "%^CYAN%^The Death of Playtesters says: Sorry about the Voice.  "
         "We have to do that, you know.  Well, you should really be dead "
         "now, but the Playtesters' Union renegotiated the whole death deal "
         "with the powers that be.%^RESET%^\n" );
   call_out ("pt_set_hp", 0, query_max_hp());
   corpse = pt_make_corpse();
   corpse->move( environment( ) );
   flowers = clone_object( "/std/object" );
   flowers->set_name( "flowers" );
   flowers->set_short( "bunch of flowers" );
   flowers->add_alias( "bunch" );
   flowers->add_adjective( ({ "bunch", "of" }) );
   flowers->set_main_plural( "bunches of flowers" );
   flowers->add_plural( ({ "bunches", "bunches of flowers" }) );
   flowers->set_long( "This is a small bunch of nice flowers.\n" );
   flowers->set_weight( 5 + random( 10 ) );
   flowers->set_value( 0 );
   flowers->set_read_mess( "Rest In Peas", "common" );
   flowers->move( corpse );
   return corpse;
}
varargs int pt_adjust_hp( int hp, object attacker ) {
   _pt_data->hp += hp;
   if( ( hp < 0 || hp > 10 ) && _pt_data->log_damage && stringp( _pt_data->log_file ) )
      log_file( _pt_data->log_file, ctime( time() ) +": "+
                query_name() +" - "+ hp +" hitpoints.\n" );
   if( _pt_data->hp <= 0 && hp < 0) {
      pt_do_death();
   } else if( _pt_data->hp > ::query_max_hp() ) {
      _pt_data->hp = ::query_max_hp();
   }
   if( hp < 0 && _pt_data->hp > 0 && attacker && attacker != this_object() ) {
      if( 100 * _pt_data->hp < query_wimpy() * ::query_max_hp() ) {
         run_away();
      }
   }
   return _pt_data->hp;
}
void set_pt_log_file( string str ) {
   _pt_data->log_file = str;
}
string query_pt_log_file() {
   return _pt_data->log_file;
}
void enable_death_log() {
   _pt_data->log_death = 1;
}
void disable_death_log() {
   _pt_data->log_death = 0;
}
int query_log_death() {
   return _pt_data->log_death;
}
void enable_damage_log() {
   _pt_data->log_damage = 1;
}
void disable_damage_log() {
   _pt_data->log_damage = 0;
}
int query_log_damage() {
   return _pt_data->log_damage;
}
object do_death( object thing ) {
   if( query_pt_protection() || query_in_pt_arena())
      return pt_do_death();
   else
      return ::do_death( thing );
}
varargs int adjust_hp( int hp, object attacker ) {
   if( query_pt_protection() ) {
     return pt_adjust_hp( hp, attacker );
   } else {
      return ::adjust_hp( hp, attacker );
   }
}
int query_hp() {
   if( query_pt_protection() )
      return pt_query_hp();
   else
      return ::query_hp();
}
mixed *stats() {
   return ::stats() + ({
      ({ "PT hitpoints", _pt_data->hp }),
      ({ "PT protection", ( query_pt_protection() ? "On" : "Off" ) })
   });
}
string extra_score() {
   return ::extra_score() +
         "Your playtester protection is "+
         ( query_pt_protection() ? "on" : "off" ) +".\n";
}
int query_in_pt_arena() {
  if (!environment(this_object())) {
    return 0;
  }
  if (environment (this_object())->query_pt_arena()) {
    return 1;
  }
  return 0;
}
int advancement_restriction() {
  if (query_pt_protection()) {
    return 1;
  }
  if (query_in_pt_arena()) {
    return 1;
  }
  return 0;
}
varargs int adjust_xp(int number, int shared) {
  if ( advancement_restriction() && number > 0) {
    return 0;
  }
  return ::adjust_xp(number, shared);
}
void event_move_object(mixed from, mixed to) {
  ::event_move_object (from, to);
  if (query_pt_protection()) {
    if (query_pt_area(from) && !query_pt_area (to)) {
       _pt_data->protection_counter = MAX_COUNTER;
      if (_pt_data->turn_off) {
        remove_call_out(_pt_data->turn_off);
      }
      tell_object (this_player(), "%^BOLD%^You are now leaving a PT area.  "
        "Your protection is still on.\n%^RESET%^");
      log_file (PROTECTION_LOG, "%s: %s left a playtester area with protection "
        "still active (%s).\n", ctime(time()), this_player()->query_name(),
        base_name (environment (this_player())));
      _pt_data->turn_off = call_out("disable_pt_protection", 5 * 60);
    }
    else if (!query_pt_area (from) && query_pt_area (to)) {
      tell_object (this_player(), "%^BOLD%^You are now entering a PT area.  "
        "Your protection will not wear off until you leave or switch it "
        "off.\n%^RESET%^");
      if (_pt_data->turn_off) {
        remove_call_out(_pt_data->turn_off);
        _pt_data->protection_counter = 0;
      }
    }
  }
}
int query_player_killer() {
  if (query_in_pt_arena()) {
    return 1;
  }
  return ::query_player_killer();
}
int query_contractable() {
  return ::query_player_killer();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/cloner.c ===
#define SAVE_FILE "/save/cloner"
#define SAVE_FILE_DELAY 15
#define LIFE_TIME 7257600
inherit "/std/object";
mapping changes;
mapping illegal;
private nosave int _save_file_call_out;
mapping query_changes() {
   return changes;
}
void save_file() {
   _save_file_call_out = 0;
   unguarded((: save_object, SAVE_FILE:));
}
void load_file() {
   if (file_size(SAVE_FILE + ".o") > 0)
      unguarded((: restore_object, SAVE_FILE:));
}
void setup() {
   changes = ([]);
   illegal = ([]);
   load_file();
   _save_file_call_out = 0;
}
object clone( string word ) {
   string new_file;
   object thing;
   if ( changes[ word ] && new_file = changes[ word ][ 0 ] )
      word = new_file;
   catch( thing = clone_object( word ) );
   return thing;
}
string other_file( string word ) {
   if ( changes[ word ] )
      return changes[ word ][ 0 ];
   return word;
}
int add_mapping( string from, string to ) {
  string obj_name;
  if(from[<2..] == ".c")
    from = from[0..<3];
  if(to[<2..] == ".c")
    to = to[0..<3];
  if((file_size(to) < 1) && (file_size(to+".c") < 1)) {
    write("Destination file does not exist\n");
    return 0;
  }
  changes[from] = ({to, time()});
  if ( !_save_file_call_out ) {
        _save_file_call_out = call_out( (: save_file :), SAVE_FILE_DELAY );
  }
  if ( !this_player() ) {
      obj_name = file_name( previous_object() );
  }
  else {
      obj_name = this_player()->query_cap_name();
  }
  write("Mapping of "+from+" to "+to+" added.\n");
  log_file("CLONER", "Mapping of "+from+" to "+to+" added by "+
           obj_name +" at "+ctime(time())+".\n");
  remove_call_out("clean_up");
  call_out("clean_up", 120 + random(500));
  return 1;
}
int remove_mapping( string from ) {
   string obj_name;
   if ( changes && changes[ from ] ) {
      map_delete( changes, from );
      save_file();
      write( "Mapping of " + from + " removed.\n" );
      if ( !this_player() ) {
          obj_name = file_name( previous_object() );
      }
      else {
          obj_name = this_player()->query_cap_name();
      }
      log_file( "CLONER", "Mapping of " + from + " removed by " +
          obj_name + " at " + ctime( time() ) + ".\n" );
      return 1;
   }
   write("No mapping found for " + from + ".\n");
   return 0;
}
string list_mappings( string str ) {
   string from, retval;
   retval = "";
   foreach(from in keys(changes)) {
      if (!str ||
          strsrch(from, str) != -1 ||
          strsrch(changes[from][0], str) != -1)
         retval += from + " -> " + changes[from][0] + "\n";
   }
   return retval;
}
int add_illegal(string basename, string short, string replacement) {
  if(!illegal)
    illegal = ([ ]);
  if(illegal[basename + ":" + short])
    return 0;
  if((file_size(replacement) < 1) && (file_size(replacement+".c") < 1))
    return 0;
  illegal[basename + ":" + short] = replacement;
  save_file();
  return 1;
}
int remove_illegal(string basename, string short) {
  if(!illegal)
    return 0;
  if(!illegal[basename+":"+short])
    return 0;
  map_delete(illegal, basename+":"+short);
  save_file();
  return 1;
}
mapping query_illegal() {
  return illegal;
}
string illegal_thing(string basename, string short) {
  if(!illegal)
    return 0;
  return illegal[basename + ":" + short];
}
void clean_up() {
   string from;
   mixed  *to;
   foreach(from, to in changes)
      if ((to[1] < time() - LIFE_TIME) ||
          ((file_size(to[0]) < 1) && (file_size(to[0] + ".c") < 1)))
         map_delete(changes, from);
   save_file();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/spells.c ===
#include "spells.h"
nosave mixed *_spell_effects;
void create() {
  _spell_effects = ({ });
}
mixed query_effects() { return _spell_effects; }
int queue_commands() { return sizeof( _spell_effects ); }
int add_spell_effect(int no_rnds, string type, string name, object callee,
                     string func, mixed params) {
  int i,j;
   if (strsrch(file_name(this_object()),"global")==-1)
      tell_object(find_living("olorin"),
                  sprintf("add_spell_effect in %s\n",
                          file_name(this_object())));
  if ((i=member_array(type, _spell_effects)) != -1)
    if ((j=member_array(name, _spell_effects[i+1])) == -1)
      _spell_effects[i+1] += ({ name, ({ no_rnds, callee, func, params }) });
    else
      _spell_effects[i+1][j+1] = ({ no_rnds, callee, func, params });
  else
    _spell_effects += ({ type, ({ name, ({ no_rnds, callee, func, params }) }) });
}
int remove_spell_effect(string name) {
  int i, j;
   if (strsrch(file_name(this_object()),"global")==-1)
      tell_object(find_living("olorin"),
                  sprintf("remove_spell_effect in %s\n",
                          file_name(this_object())));
  for (i=0;i<sizeof(_spell_effects);i+=2)
    if ((j=member_array(name, _spell_effects[i+1])) != -1) {
      _spell_effects[i+1] = delete(_spell_effects[i+1], j, 2);
      if (!sizeof(_spell_effects[i+1])) {
        _spell_effects = delete(_spell_effects, i, 2);
        i -= 2;
      }
    }
  return 1;
}
mixed query_spell_effect(string name) {
   int i;
   if (strsrch(file_name(this_object()),"global")==-1)
      tell_object(find_living("olorin"),
                  sprintf("query_spell_effect in %s\n",
                          file_name(this_object())));
  if ((i=member_array(name, _spell_effects)) == -1)
    return 0;
  if (sizeof(_spell_effects[i+1]))
    return _spell_effects[i..i]+_spell_effects[0..1];
  return 0;
}
mixed *query_spell_effects_type(string type) {
  int i, j;
  mixed *ret;
  if ((i=member_array(type, _spell_effects)) == -1)
    return ({ });
  ret = ({ });
  for (j=0;j<sizeof(_spell_effects);j+=2)
    ret += ({ _spell_effects[i], _spell_effects[i+1][j..j+1] });
  return ret;
}
int do_spell_effects(object attacker) {
  int i, j;
  this_object()->remove_property("casting");
  for (i=0;i<sizeof(_spell_effects);i+=2)
    for (j=0;j<sizeof(_spell_effects[i+1]);j+=2) {
      call_out("do_call_out_effect", 1, ({ _spell_effects[i+1][j+1], attacker }));
      _spell_effects[i+1][j+1][SP_NO_RNDS]--;
      if ( !_spell_effects[i+1][j+1][SP_NO_RNDS] || !_spell_effects[i+1][j+1][SP_OBJECT]) {
        _spell_effects[i+1] = delete(_spell_effects[i+1], j, 2);
        j -= 2;
        if (!sizeof(_spell_effects[i+1])) {
          _spell_effects = delete(_spell_effects, i, 2);
          i -= 2;
          break;
        }
      }
    }
    return 0;
}
void do_call_out_effect(mixed *params) {
  if (params[0][SP_OBJECT])
    call_other(params[0][SP_OBJECT],
             params[0][SP_FUNC],
             params[1],
             params[0][SP_PARAM],
             params[0][SP_NO_RNDS]);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/finger.c ===
#include <player.h>
#include <mail.h>
#include <clothing.h>
private mapping player_info;
private string password;
private nosave string tmppassword;
string query_name();
private int change_password();
private int change_password2(mixed pass);
private int change_password3(string pass);
private int change_password4(string pass);
int add_command(string command, object ob, mixed format, function func);
void finger_commands() {
   add_command("password", this_object(), "", (: change_password() :));
   add_command("passwd", this_object(), "", (: change_password() :));
}
void set_desc(string str) {
   if (!player_info) {
      player_info = ([ ]);
   }
   if (!str) {
      map_delete(player_info, "desc");
   } else {
      player_info["desc"] = str;
   }
}
string query_desc() {
   if (!player_info  ||  undefinedp(player_info["desc"])) {
      return "";
   }
   return player_info["desc"] + "%^RESET%^";
}
void set_zone_desc(string zone, string desc) {
   if (!player_info["zone desc"]) {
      player_info["zone desc"] = ([ ]);
   }
   if (!desc) {
      map_delete(player_info["zone desc"], zone);
   } else {
      player_info["zone desc"][zone] = desc;
   }
}
string query_zone_desc(string zone) {
   if (!player_info["zone desc"]) {
      return 0;
   }
   return player_info["zone desc"][zone];
}
string* query_zone_desc_names() {
   if (!player_info["zone desc"]) {
      return ({ });
   }
   return keys(player_info["zone desc"]);
}
string query_main_zone_desc(object* wearing) {
   object bing;
   string zone;
   string type;
   string eq_type;
   string str;
   mixed types;
   mapping covered;
   if (!sizeof(player_info["zone desc"])) {
      return "";
   }
   covered = ([ ]);
   foreach (bing in wearing) {
      types = bing->query_type();
      if (!arrayp(types)) {
         types = ({ types });
      }
      foreach (type in types) {
         eq_type = CLOTHING_HANDLER->query_equivilant_type(type);
         if (eq_type) {
            foreach (zone in CLOTHING_HANDLER->query_zone_names(eq_type)) {
               covered[zone] = 1;
            }
         } else {
            foreach (zone in CLOTHING_HANDLER->query_zone_names(type)) {
               covered[zone] = 1;
            }
         }
      }
   }
   str = "";
   foreach (zone in query_zone_desc_names()) {
      if (!covered[zone]) {
         str += " " + replace_string(query_zone_desc(zone), "$NEW_LINE$", "\n");
      }
   }
   return str;
}
void set_password(string pass) {
   if (file_name(previous_object())[0..12] == "/secure/login" ||
       file_name(previous_object())[0..13] == "/secure/nlogin") {
      password = pass;
   }
}
private int change_password() {
   if (password) {
      write("Please enter your old password : ");
      input_to((: change_password2 :),1);
      return 1;
   }
   change_password2(0);
   return 1;
}
private int change_password2(mixed pass) {
   string str;
   if (password) {
      str = crypt(pass,password);
      if (str != password) {
         write("\nIncorrect.\n");
         return 1;
      }
   }
   write("\nEnter new Password : ");
   input_to((: change_password3 :),1);
   return 1;
}
private int change_password3(string pass) {
   tmppassword = pass;
   if(sizeof(pass) < 6) {
     write("\nPassword is too short, must be at least 6 characters.\n");
     write("Enter new Password :");
     input_to((: change_password3 :),1);
     return 1;
   }
   write("\nPlease enter again : ");
   input_to((: change_password4 :),1);
   return 1;
}
private int change_password4(string pass) {
   if (tmppassword != pass) {
      write("\nIncorrect.\n");
      return 1;
   }
   password = crypt(pass,password);
   write("\nOk.\n");
   return 1;
}
string *query_rhosts() {
  if(!player_info)
    return 0;
  return player_info["allowed_ips"];
}
void set_rhosts(string *ips) {
  if(file_name(previous_object())[0..18] != "/cmds/player/access" &&
     file_name(previous_object())[0..19] != "/cmds/lord/authorise")
    return ;
  if(!player_info)
    player_info = ([ ]);
  player_info["allowed_ips"] = ips;
}
string query_real_name() {
   if (!player_info) {
      return 0;
   }
   return player_info["real_name"];
}
void set_real_name(string str) {
   if (!player_info) {
      player_info = ([ ]);
   }
   player_info["real_name"] = str;
}
string query_where() {
   if (!player_info) {
      return "";
   }
   return player_info["location"];
}
void set_where(string str) {
   if (!player_info) {
      player_info = ([ ]);
   }
   player_info["location"] = str;
}
string query_birthday() {
   if (!player_info) {
      return UNKNOWN_BIRTHDAY;
   }
   if (!player_info["birthday"]) {
      return UNKNOWN_BIRTHDAY;
   }
   return player_info["birthday"];
}
void set_birthday(string i) {
   if (!player_info) {
      player_info = ([]);
   }
   player_info["birthday"] = i;
}
int query_is_birthday_today() {
   string cmonth;
   string dummy;
   string bmonth;
   int cdate;
   int bdate;
   if (sscanf(ctime(time()), "%s %s %d %s", dummy, cmonth, cdate, dummy)!=4) {
      return 0;
   }
   if (sscanf(query_birthday(), "%d%s of %s", bdate, dummy, bmonth) !=3) {
      return 0;
   }
   if (cmonth == bmonth[0..2] && cdate == bdate) {
      return 1;
   }
}
string query_email() {
  if(file_name(previous_object())[0..13] != "/secure/finger" &&
     file_name(previous_object())[0..27] != "/obj/handlers/player_handler" &&
     file_name(previous_object())[0..28] != "/obj/handlers/options_handler") {
    return "";
   }
   if (!player_info) {
      return "";
   }
   return player_info["email"];
}
nomask void set_email(string str) {
   if (!player_info) {
      player_info = ([]);
   }
   player_info["email"] = str;
}
string query_homepage() {
   if (!player_info) {
      player_info = ([ ]);
   }
   return player_info["homepage"];
}
nomask void set_homepage(string str) {
   if (!player_info) {
      player_info = ([]);
   }
   player_info["homepage"] = str;
}
int finger_set() {
   if (!player_info ||
      player_info == ([ ]) ||
      sizeof(keys(player_info)) == 1) {
      return 0;
   }
   return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/wiz_channels.c ===
#include <broadcaster.h>
#include <creator.h>
#include <network.h>
#include <newudp.h>
#define TALKER "/std/shadows/object/talker"
#define BEEP sprintf("%c",7)
#define CHAN_OK 1
#define CHAN_FORCED 2
#define CHAN_EMOTED 4
#define CHAN_QUERY 8
private int channel_cmd(string mess);
private int channel_hist();
nomask string *channel_list() {
  string channel, *tmp, *channels;
  tmp = "/secure/master"->query_domains();
  tmp -= NO_CHANNELS;
  channels = ({ });
  foreach(channel in tmp)
    if("/secure/master"->query_senior(this_object()->query_name()) ||
       ("/d/"+channel+"/master")->query_member(this_object()->query_name()))
      channels += ({ channel });
  channels += ADDITIONAL_CHANNELS + keys(INTERMUD_MAP);
  if(this_object()->query_lord())
    channels += ({ "lord" });
  return channels;
}
void wiz_commands() {
  string channel;
  foreach(channel in channel_list()) {
    add_command(channel, "<string'mess'>", (: channel_cmd($4[0]) :));
    add_command(channel+"@", "<string'mess'>", (: channel_cmd("@"+$4[0]) :));
    add_command(channel+"?", "", (: channel_cmd("?") :));
    if(!INTERMUD_MAP[channel]) {
      add_command(channel+"!", "", (: channel_cmd("!") :));
      add_command("h"+channel, "", (: channel_hist() :));
    }
  }
}
private void my_mess(string fish, string erk) {
  int bing;
  if (!interactive(this_player())) {
    return;
  }
  bing = strlen(fish);
  if (bing > 15) {
    bing = 15;
  }
  efun::tell_object(this_player(),
                    this_player()->fix_string(sprintf("%s%s\n", fish, erk),
                                              (int)this_player()->query_cols(),
                                              bing));
}
protected int handle_command_line(string channel, string mess) {
  int retval;
  function map_func;
  int i;
  object *people, *off_line;
  add_failed_mess("Syntax: "+channel+"[@|?] [text]\n");
  if(!channel || !mess) {
    return 0;
  }
  if(member_array(channel, channel_list()) == -1) {
    add_failed_mess("No such channel " + channel + ".\n");
    return 0;
  }
  switch (mess[0]) {
  case '!' :
    retval |= CHAN_FORCED;
    break;
  case '@' :
    retval |= CHAN_EMOTED;
    break;
  case '?' :
    if (mess == "?") {
      if(INTERMUD_MAP[channel]) {
        SERVICES_D->eventSendChannelWhoRequest(INTERMUD_MAP[channel]);
        retval |= CHAN_QUERY;
        return retval;
      }
      people = filter(users(), (: $1 && $1->query_creator() &&
                                $1->query_visible(this_object()) :));
      off_line = ({ });
      for (i=0;i<sizeof(people);i++) {
        if(!people[i] || !people[i]->channel_list() ||
           member_array(channel, people[i]->channel_list()) == -1) {
          people = delete(people, i, 1);
          i--;
        } else if(people[i]->check_earmuffs(channel) ||
                  (member_array(channel, keys(INTERMUD_MAP)) != -1 &&
                   people[i]->check_earmuffs("intermud-all"))) {
          off_line += ({ people[i] });
          people = delete(people, i, 1);
          i--;
        }
      }
      people = sort_array(people, (: strcmp($1->query_name(),
                                            $2->query_name()) :) );
      off_line = sort_array(off_line, (: strcmp($1->query_name(),
                                                $2->query_name()) :) );
      map_func = function (object ob) {
        string str;
        if (ob->query_invis()) {
          if (ob->query_invis() == 2) {
            str = "({" + $1->query_cap_name() + "})";
          } else {
            str = "(" + $1->query_cap_name() + ")";
          }
        } else {
          str = $1->query_cap_name();
        }
        if (query_idle(ob) > 120) {
          int hours, mins, secs;
          secs = query_idle(ob);
          mins = secs / 60;
          secs %= 60;
          hours = mins / 60;
          mins %= 60;
          if ( !hours )  {
            str += sprintf(" [%02dm]", mins);
          } else {
            str += sprintf(" [%02dh:%02dm]", hours, mins);
          }
        }
        return str;
      };
      people = map(people, map_func);
      off_line = map(off_line, map_func);
      if (sizeof(people)) {
        write(sprintf( "On line: %-=" + (this_player()->query_cols() - 10) +
                       "s", query_multiple_short( people ) +".\n"));
      }
      if (sizeof(off_line)) {
        write(sprintf( "Off line: %-=" + (this_player()->query_cols() - 11) +
                       "s", query_multiple_short( off_line ) +".\n"));
      }
      retval |= CHAN_QUERY;
    }
    break;
  default :
    return CHAN_OK;
    break;
  }
  return retval;
}
private int channel_cmd(string mess) {
  int flags;
  string pad = " ";
  string start;
  string channel;
  object *things;
  channel = query_verb();
  if(channel[<1] == '?' || channel[<1] == '@' || channel[1] == ':') {
    channel = channel[0..<2];
  }
  flags = handle_command_line(channel, mess);
  if (!flags) {
    return 0;
  }
  if (flags & CHAN_QUERY) {
    return 1;
  }
  if(mess[0] == '!' || mess[0] == '@' || mess[0] == '?') {
    mess = mess[1..1000];
  }
  if (mess[0] == ' ') {
    mess = mess[1..1000];
  }
  if (mess == "") {
    return 0;
  }
  if (this_object()->check_earmuffs(channel)) {
    write("Why use " + channel + "-tell when you can't hear a response?\n");
    return 1;
  }
  mess = replace(mess, BEEP, "");
  if (mess[0..0] == "'") {
    pad = "";
  }
  if (flags & CHAN_EMOTED) {
    start = this_object()->query_cap_name() + pad;
    if(INTERMUD_MAP[channel])
      SERVICES_D->eventSendChannel((string)this_player()->query_cap_name(),
                                   INTERMUD_MAP[channel], "$N " + mess,
                                   flags & CHAN_EMOTED);
    else
      my_mess("(" + channel + ") "+
              ((string)this_object()->query_cap_name()) + pad,
              mess);
  } else {
    start = this_object()->query_cap_name() +": ";
    if(INTERMUD_MAP[channel])
      SERVICES_D->eventSendChannel((string)this_player()->query_cap_name(),
                                   INTERMUD_MAP[channel], mess,
                                   flags & CHAN_EMOTED);
    else
      my_mess("You " + channel + "-tell: ", mess);
  }
  if(INTERMUD_MAP[channel]) {
    user_event(this_object(), "intermud_tell", start, mess, channel);
    if(channel == "dwchat") {
      things = children(TALKER);
      things -= ({ find_object(TALKER) });
      if ( flags & CHAN_EMOTED ) {
        mess = ":" + mess;
      }
      things->receive("intermud", this_object()->query_cap_name(),
                       mess);
    }
  } else {
    user_event(this_object(), "creator_tell", start, mess,
                flags & CHAN_FORCED, channel);
    HIST_HANDLER->add_chat_history(channel, start, mess);
  }
  return 1;
}
private int channel_hist() {
  int i;
  mixed *hist;
  string channel;
  channel = query_verb()[1..];
  hist = HIST_HANDLER->query_chat_history(channel);
  if (!pointerp(hist) || !sizeof(hist)) {
    return notify_fail("Nobody said anything on the " + channel +
                       " channel.\n");
  }
  write("The " + channel + " channel history is:\n");
  for (i=0;i<sizeof(hist);i++) {
    if (sizeof(hist[i]) > 2) {
      efun::tell_object(this_object(),
                        this_object()->fix_string(sprintf("*%s* %s%-=*s\n",
                ctime(hist[i][2])[11..18], hist[i][0],
                (int)this_object()->query_cols()-strlen(hist[i][0])-11,
                                                          hist[i][1])));
    } else {
      efun::tell_object(this_object(),
                        (string)this_object()->fix_string(sprintf("%s%-=*s\n",
               hist[i][0], (int)this_object()->query_cols()-strlen(hist[i][0]),
                hist[i][1])));
    }
  }
  return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/alias.c ===
#include <alias.h>
#include <player.h>
inherit "/global/history";
mapping aliases;
nosave mapping doing_alias;
protected void exec_alias(string verb, string args);
protected string *expand_alias(string verb, string args);
protected void set_doing_alias(string verb);
protected int is_doing_alias(string verb);
protected string *run_alias(string verb, string args);
int remove_alias_thing(string);
protected int alias(string);
protected int edit_alias(string);
int add_player_alias(string name, mixed *value) {
   if (file_name(previous_object()) != ALIAS_CMD &&
       file_name(previous_object()) != EDIT_ALIAS_CMD) {
      return 0;
   }
   if(name == "unalias" || name == "alias" || name == "ealias")
     return 0;
   aliases[name] = value[0..1023];
   return 1;
}
mixed *query_player_alias(string name) {
  if(!mapp(aliases))  {
    aliases = ([ ]);
    return 0;
  }
   return copy(aliases[name]);
}
int remove_player_alias(string name) {
   if ((file_name(previous_object()) != UNALIAS_CMD) &&
       name != "" &&
       !this_player(1)->query_lord()) {
      printf("%O\n", file_name(previous_object()));
      return 0;
   }
   map_delete(aliases, name);
   return 1;
}
void alias_commands() {
   add_command("END_ALIAS", "<string>", (:remove_alias_thing($4[0]):));
}
int remove_all_aliases() {
   if (!this_player(1)->query_lord()) {
      write("You can't do that :)\n");
      return 0;
   }
   aliases = ([ ]);
   return 1;
}
mapping query_aliases() {
   return copy(aliases);
}
int is_alias(string verb) {
   return aliases[verb] != 0;
}
protected void exec_alias(string verb, string args) {
   string *bing;
   string comm;
   bing = run_alias(verb, args);
   if (bing) {
      set_doing_alias(verb);
      foreach (comm in bing) {
         command(comm);
      }
   }
}
protected string *run_alias(string verb, string args) {
   if (!mapp(aliases)) {
      aliases = ([ ]);
   }
   if (!aliases[verb] || is_doing_alias(verb)) {
      return 0;
   }
   return expand_alias(verb, args);
}
protected int is_doing_alias(string verb) {
   if (!doing_alias) {
      doing_alias = ([ ]);
   }
   if (doing_alias[verb]) {
      return 1;
   }
   return 0;
}
protected void set_doing_alias(string verb) {
  doing_alias[verb] = 1;
  in_alias_command++;
}
protected string *expand_alias(string verb, string args) {
   int i;
   int num;
   string *bits;
   string line;
   mixed stuff;
   string *ret;
   if (!aliases[verb]) {
      return ({ verb + " " + args });
   }
   ret = ({ });
   stuff = aliases[verb];
   line = "";
   if (!args) {
      args = "";
   }
   bits = explode(verb + " " + args, " ");
   for (i = 0; i < sizeof(stuff); i++) {
      if (stringp(stuff[i])) {
         line += stuff[i];
      } else {
         num = stuff[i] & ALIAS_MASK;
         switch (stuff[i] - num) {
         case NEW_LINE :
            ret += ({ line });
            line = "";
            break;
         case ALL_ARGS :
            line += args;
            break;
         case ONE_ARG  :
            if (num < sizeof(bits)) {
               line += bits[num];
            }
            break;
         case TO_ARG   :
            line += implode(bits[1..num], " ");
            break;
         case FROM_ARG :
            line += implode(bits[num..100], " ");
            break;
         case ALL_ARG  :
            i++;
            if (args == "") {
               line += stuff[i];
            } else {
               line += args;
            }
            break;
         case ARG_THING :
            i++;
            if (num < sizeof(bits)) {
               line += bits[num];
            } else {
               line += stuff[i];
            }
            break;
         case ALL_IFARG :
            i++;
            if (args == "") {
               i += stuff[i];
            }
            break;
         case IFARG_THING :
            i++;
            if (num >= sizeof(bits)) {
               i += stuff[i];
            }
            break;
         case ELSE_THING :
            i++;
            i += stuff[i];
            break;
         case CURR_LOC :
            i++;
            line += file_name(environment())+".c";
            break;
         case END_IF :
            break;
         }
      }
   }
   if (line != "") {
      ret += ({ line });
   }
   ret += ({ "END_ALIAS " + verb });
   return ret[0..1023];
}
int remove_alias_thing(string verb) {
   in_alias_command--;
   map_delete(doing_alias, verb);
   this_player()->adjust_time_left(-DEFAULT_TIME);
   return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/auto_mailer.c ===
#include <mail.h>
#include <player_handler.h>
int auto_mail(string to,
              string from,
              string sub,
              string cc,
              string body,
              int send_inter,
              string only_to,
              int flag)
{
  if (PLAYER_HANDLER->test_player(from) &&
      this_player() &&
      from != this_player()->query_name()) {
    write("AUTO_MAILER: Illegal access!\n");
    unguarded((: write_file, "/log/CHEAT",
           "Illegal access to AUTO_MAILER.\n" "Backtrace: " +
           back_trace() :));
    return 0;
  }
  return MAILER->do_mail_message(to, from, sub, cc, body,
                 send_inter, only_to, flag);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/creator.c ===
#include <login_handler.h>
inherit "/global/wiz_file_comm";
#define ECHO_ALLOWED
void move_player_to_start(string bong, int new_pl, string c_name, string ident, int go_invis) {
  if(!sscanf(file_name(previous_object()), "/secure/login#%*s") &&
     !sscanf(file_name(previous_object()), "/secure/nlogin#%*s"))
    return 0;
#ifndef NEW_DRIVER
#endif
  ::move_player_to_start(bong, new_pl, c_name, ident, go_invis);
  write(LOGIN_HANDLER->get_message("/doc/CREATORNEWS"));
  if(query_invis()) {
    tell_object(this_object(), "===> You are currently INVISIBLE! <===\n");
  }
}
int query_creator() { return 1; }
string query_object_type(object) {
   if ( master()->query_senior( query_name() ) )
      return "S";
   return "C";
}
void receive_snoop(string bing) {
  tell_object(this_object(), "] "+bing);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/friends.c ===
#include <player.h>
#include <player_handler.h>
#include <cmds/friends.h>
private mapping _friends;
void create() {
   _friends = ([ ]);
}
int is_friend(string person) {
   if (!_friends) {
     _friends = ([ ]);
   }
   return stringp(_friends[person]);
}
string query_friend_tag(string person) {
  if(!interactive(previous_object()))
     return _friends[person];
  if(previous_object()->query_name())
    log_file("CHEAT", "%s query_friend_tag called on %s by %s\n",
             ctime(time()), this_object()->query_name(),
             previous_object()->query_name());
  else
    log_file("CHEAT", "%s query_friend_tag called on %s by %s\n",
             ctime(time()), this_object()->query_name(),
             file_name(previous_object()));
  return "";
}
void add_friend(string person, string tag) {
   if (strlen(tag) > PLAYER_MAX_FRIEND_TAG_LEN) {
      return ;
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      return ;
   }
   _friends[person] = tag;
}
void remove_friend(string person) {
   map_delete(_friends, person);
}
string* query_friends() {
   if (file_name(previous_object()) == FRIENDS_CMD) {
      return keys(_friends);
   }
   if(previous_object()->query_name())
     log_file("CHEAT", "%s query_friends called on %s by %s\n",
              ctime(time()), this_object()->query_name(),
              previous_object()->query_name());
   else
     log_file("CHEAT", "%s query_friends called on %s by %s\n",
              ctime(time()), this_object()->query_name(),
              file_name(previous_object()));
   return ({ });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/lord.c ===
#define CREATOR_DOC "/doc/creator/concepts/creator_doc.txt"
#include <command.h>
#include <mail.h>
inherit "/global/wiz_file_comm";
protected int do_dismiss(string str, string reason);
protected int employ(string str);
protected int new_domain(string dom, string director);
private int do_heart_beat();
protected int do_qsnoop(object *obs);
protected int bulk_delete( string word );
protected int clean_up_files( string word );
protected int do_hexec(string);
void create() {
  ::create();
}
void move_player_to_start(string bong, int bing, string c_name, string ident,
                          int go_invis) {
  ::move_player_to_start(bong, bing, c_name, ident, go_invis);
  cat("doc/CREATORNEWS");
  cat("doc/DIRECTORNEWS");
#ifndef NEW_DRIVER
  enable_wizard();
#endif
   switch ( query_invis() ) {
      case 3 :
         tell_object( this_object(),
               "===> You are currently Trustee invisible! <===\n" );
         break;
      case 2 :
         tell_object( this_object(),
               "===> You are currently Director invisible! <===\n" );
         break;
      case 1:
         tell_object( this_object(),
               "===> You are currently invisible! <===\n" );
         break;
   }
  add_command("qsnoop", this_object(), "<indirect:player>", (: do_qsnoop($1)
                                                             :));
  add_command("qsnoop", this_object(), "", (: do_qsnoop :));
  add_command("employ", this_object(), "<word>", (: employ($4[0]) :));
  add_command("dismiss", this_object(), "<word> <string>", (: do_dismiss($4[0], $4[1]) :));
  add_command("new_domain", this_object(), "<word> <word>",
              (: new_domain($4[0], $4[1]) :) );
  add_command("heart_beat", this_object(), "", (: do_heart_beat() :) );
  add_command("bulk_delete", this_object(),
              "{a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p|q|r|s|t|u|v|w|x|y|z}",
              (: bulk_delete($4[0]) :) );
  add_command("clean_up_files",  this_object(), "<word>",
              (: clean_up_files($4[0]) :) );
  AddSearchPath(({ DIR_LORD_CMDS, DIR_SECURE_LORD_CMDS }));
}
protected mixed process_input(string input){
  if(input == "end_it_all")
    shutdown(0);
  if(input[0..4] == "hexec")
    return do_hexec(input[5..]);
  return ::process_input(input);
}
protected int end_it_all() {
  shutdown(0);
  return 1;
}
private int do_heart_beat() {
  heart_beat();
  return 1;
}
int query_creator() {
  return 1;
}
nomask int query_director() {
  return 1;
}
nomask int query_lord() {
  return 1;
}
protected int employ(string str) {
  string doc;
  if (GetForced()) {
    return 0;
  }
  switch (master()->employ_creator( lower_case(str) )) {
    case 2 :
      if(file_size(CREATOR_DOC) > 0) {
        doc = read_file(CREATOR_DOC);
        AUTO_MAILER->auto_mail(lower_case(str), this_player()->query_name(),
          "Documents for new creators", "", doc, 0, 0);
      }
      return 1;
    case 1 :
      return 1;
    default :
      return 0;
  }
}
protected int do_dismiss(string str, string reason) {
  if (GetForced()) {
    return 0;
  }
   return (int)master()->dismiss_creator( str + " " + reason);
}
protected int new_domain(string dom, string director) {
  if (GetForced()) {
    return 0;
  }
  return (int)master()->create_domain(dom, director);
}
string query_object_type(object) {
  if (master()->query_trustee(geteuid(this_object())))
    return "T";
  return "D";
}
void event_enter(object me, string s1, object from) {
  if ((!s1 || s1 == "") && interactive(me)) {
    if (environment() == environment(me))
      event_inform(me, me->query_cap_name()+" invisibly enters the room",
                   "enter");
    else
      event_inform(me, me->query_cap_name()+" invisibly enters your inventory",
                   "enter");
  }
  ::event_enter(me, s1, from);
}
void event_exit(object me, string s1, object from) {
  if ((!s1 || s1 == "") && interactive(me)) {
    if (environment() == environment(me))
      event_inform(me, me->query_cap_name()+" invisibly exits the room",
                   "enter");
    else
      event_inform(me, me->query_cap_name()+" invisibly exits your inventory",
                   "enter");
  }
  ::event_exit(me, s1, from);
}
protected int do_hexec(string junk) {
  if (GetForced()) {
    return 0;
  }
  write_file("/w/"+query_name()+"/exec_thing.c", "void create() { "+junk+"; }");
  catch(("/w/"+query_name()+"/exec_thing")->bingle());
  destruct(find_object("/w/"+query_name()+"/exec_thing"));
  rm("/w/"+query_name()+"/exec_thing.c");
  return 1;
}
varargs int adjust_xp(int number, int shared) {
  if (objectp(previous_object())) {
    event_inform(previous_object(),
                 (string)previous_object()->query_name() + " (" +
                 file_name(previous_object()) +") gives you " +
                 number + " xp", "xp");
  }
  return ::adjust_xp(number, shared);
}
protected int bulk_delete( string word ) {
  if (GetForced()) {
    return 0;
  }
  word = lower_case(word);
  return (int)"/secure/bulk_delete"->delete_files(word);
}
protected int clean_up_files( string word ) {
  if (GetForced()) {
    return 0;
  }
  return (int)"/secure/bulk_delete"->clean_up_files(word);
}
protected int do_qsnoop(object *obs) {
  object targ;
  if (GetForced()) {
    return 0;
  }
  if (!obs || !sizeof(obs)) {
    snoop(this_object(), 0);
    write("Ok, qsnoop cancelled.\n");
    return 1;
  }
  targ = obs[0];
  if(!snoop(this_object(), targ)) {
    notify_fail("You fail to qsnoop " + targ->query_cap_name() + ".\n");
    return 0;
  }
  write("Ok, qsnooping "+targ->query_cap_name() + ".\n");
  return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/virtual/c_compiler.c ===
#include "virtual.h"
void initialize_methods();
void create() {
    initialize_methods();
    seteuid(getuid());
}
void initialize_methods() {
    SERVER->add_method("c",  file_name(this_object()), "compile_c");
}
object compile_c(string name, int clone) {
    if (!clone) {
	name->go_ahead_make_my_womble();
	return efun::find_object(name);
    } else {
	return efun::clone_object(name);
    }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/virtual/efuns.c ===
#define HANDLER "/global/virtual/handler"
object clone_object(string name) {
  if(name[0..2] == "/d/" || name[0..1] == "d/")
    return (object)HANDLER->clone_virtual_object(name);
  return efun::clone_object(name);
}
void destruct(mixed name) {
  object obj;
  if(stringp(name)) {
    obj = find_object(name);
    if(obj->query_property("file_name"))
      HANDLER->destruct_virtual_object(obj);
    destruct(obj);
  } else if(objectp(name)) {
    if(name->query_property("file_name"))
      HANDLER->destruct_virtual_object(name);
    destruct(name);
  }
}
string file_name(object obj) {
  string name, number, file;
  name = efun::file_name(obj);
  if(sscanf(name, "%s#%s", name, number) == 2) {
    if(file = (string)obj->query_property("file_name")) {
      return file + "#" + number;
    } else {
      return name + "#" + number;
    }
  }
  return name;
}
object find_object(string str) {
  object obj;
  if(obj = efun::find_object(str))
    return obj;
  return (object)HANDLER->find_virtual_object(str);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/virtual/modified_efuns.c ===
#define MAX_SIZE 50000
varargs void say(string str, mixed avoid)
{
  if (!pointerp(avoid))
    avoid = ({ this_player(), previous_object() }) + ({ avoid });
  else
    avoid += ({ this_player(), previous_object() });
  if (!environment(previous_object()))
    if(this_player() && environment(this_player()))
      event(environment(this_player()), "say", str, avoid);
    else
      event(previous_object(), "say", str, avoid);
  else
  {
    if (environment(environment(previous_object())))
      event(environment(environment(previous_object())), "say", str, avoid);
    else
      event(environment(previous_object()), "say", str, avoid);
  }
}
varargs void tell_room(object ob, string str, mixed avoid) {
  if (!ob || !objectp(ob))
    return ;
  event(ob, "say", str, avoid);
}
void tell_object(object ob, string str) {
  if (objectp(ob))
    ob->event_write(previous_object(), str);
}
object find_living(string str) {
  string nick;
  object ob;
  if (this_player() && (nick = (string)this_player()->expand_nickname(str)))
    str = nick;
  if ((ob = efun::find_living(str)))
    if ((int)ob->query_invis() == 2) {
      if (member_array(this_player()->query_name(),
                       (object *)ob->query_allowed()) == -1)
        return 0;
    }
  return ob;
}
object find_player(string str) {
  object ob;
  if ((ob = efun::find_player(str)))
    if ((int)ob->query_invis() == 2)
      if (member_array(this_player()->query_name(),
                       (object *)ob->query_allowed()) == -1)
        return 0;
  return ob;
}
void log_file(string name, string mess) {
  if (file_size("/log/"+name) > MAX_SIZE) {
    seteuid("Root");
    rm("/log/"+name+".old");
    rename("/log/"+name, "/log/"+name+".old");
  }
  seteuid("Root");
  write_file("/log/"+name, mess);
  seteuid(0);
}
#ifdef MUD_NAME
string mud_name() {
  return capitalize(MUD_NAME);
}
#endif
void cat(string file, int start_line, int number) {
  string bing;
  seteuid(geteuid(previous_object()));
  bing = read_file(file, start_line, number);
  seteuid(0);
  if (bing)
    printf("%s", bing[0..5000]);
}
#define HANDLER "/global/virtual/handler"
object clone_object(string name) {
  seteuid(geteuid(previous_object()));
  if(name[0..2] == "/d/" || name[0..1] == "d/")
    return (object)HANDLER->clone_virtual_object(name);
  return efun::clone_object(name);
}
void destruct(mixed name) {
  object obj;
  if(stringp(name)) {
    obj = find_object(name);
    if(obj->query_property("file_name"))
      HANDLER->destruct_virtual_object(obj);
    destruct(obj);
  } else if(objectp(name)) {
    if(name->query_property("file_name"))
      HANDLER->destruct_virtual_object(name);
    destruct(name);
  }
}
string file_name(object obj) {
  string name, number, file;
  name = efun::file_name(obj);
  if(sscanf(name, "%s#%s", name, number) == 2) {
    if(file = (string)obj->query_property("file_name")) {
      return file + "#" + number;
    } else {
      return name + "#" + number;
    }
  }
  return name;
}
object find_object(string str) {
  object obj;
  if(obj = efun::find_object(str))
    return obj;
  return (object)HANDLER->find_virtual_object(str);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/virtual/server2.c ===
#include "virtual.h"
void add_method(string suffix, object ob, string fun, int type);
mapping methods;
#define OB   0
#define FUN  1
#define TYPE 2
#define LOAD   1
#define CLONE  2
void create() {
  seteuid(getuid());
  methods = ([ ]);
  add_method("C", "/global/virtual/c_compiler.c", "compile_c",
                        CLONE|LOAD);
}
object create_virtual_object(string name, int clone);
void add_method(string suffix, object ob, string fun, int type) {
  if (!type)
    type = CLONE;
  if (!methods[suffix]) {
    methods[suffix] = ({ ob, fun, type });
  }
}
#define Error(s) write(s); log_file("VO_HANDLER", s); return 0;
object create_virtual_object(string name, int clone) {
  string *split;
  mixed  *method;
  object ob;
  split = explode(name, ".");
  method = methods[split[sizeof(split) - 1]];
  if (method) {
    if (clone ||
        (method[TYPE]&LOAD)) {
      ob =  (object) call_other(method[OB], method[FUN], name, clone);
      ob->add_property("virtual name", name);
      return ob;
    }
    return 0;
  }
  Error("create_virtual_object() : unknown suffix to " + name + "\n");
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/virtual/compiler.h ===
#define TMP_FILE "/global/virtual/tmp_file.c"
#define O_FUN ([ "item"  : "add_item",\
                 "name"  : "set_name",\
                 "long"  : "set_long",\
                 "light" : "set_light",\
                 "alias" : "add_alias",\
                 "plural" : "add_plural",\
                 "adjective" : "add_adjective",\
                 "plural adjective" : "add_plural_adjective",\
                 "main_plural" : "set_main_plural",\
                 "main plural" : "set_main_plural",\
                 "weight" : "set_weight",\
                 "length" : "set_length",\
                 "width" : "set_width",\
                 "value" : "set_value",\
                 "value info" : "set_value_info", \
                 "material" : "set_material", \
                 "property" : "add_property",\
                 "clone" : ({ "do_clone", file_name(this_object()) }), \
                 "money" : "adjust_money",\
                 "effect" : "add_effect",\
                 "read mess" : "add_read_mess", \
                 "short" : "set_short" ])
#define R_FUN ([ "exit" : "add_exit",\
                 "modify exit" : "modify_exit",\
                 "reset" : "add_reset_item",\
                 "dark mess" :  "set_dark_mess",\
                 "co ord" : "set_co_ord", \
                 "size" : "set_room_size", \
                 "zone" : "set_zone", \
                 "cloned object" : "add_cloned_object", \
                 "alias" : "add_alias", \
                 "sign" : "add_sign" ])
#define ARM_FUN ([ "setup" : "setup_armour",\
                   "no limbs" : "set_no_limbs", \
                   "condition" : "set_cond", \
                   "enchant" : "set_enchant", \
                   "ac" : "add_ac", \
                   "max condition" : "set_max_cond", \
                   "immune" : "add_immune_to", \
                   "type" : "set_type", \
                   "wear remove" : "set_wear_remove_func", \
                   "wear effect" : "add_wear_effect", \
                   "dex minus" : "set_dex_minus", \
                   "damage chance" : "set_damage_chance" ])
#define CLO_FUN ([ "setup" : "setup_clothing",\
                   "condition" : "set_cond", \
                   "enchant" : "set_enchant", \
                   "max condition" : "set_max_cond", \
                   "immune" : "add_immune_to", \
                   "type" : "set_type", \
                   "wear remove" : "set_wear_remove_func", \
                   "wear effect" : "add_wear_effect", \
                   "dex minus" : "set_dex_minus", \
                   "pocket mess" : "set_pocket_mess", \
                   "pocket" : "add_pocket", \
                   "stuck" : "set_stuck", \
                   "key" : "set_key", \
                   "damage chance" : "set_damage_chance", \
                   "pair" : "set_is_pair" ])
#define CLOTRANS_FUN ([ \
                   "race" : "set_worn_by_race", \
                   "mount modifier" : "set_mount_difficulty_modifier", \
                   "direction modifier" : "set_direction_difficulty_modifier", \
                 ])
#define SCA_FUN ([ "setup" : "setup_scabbard",\
                   "condition" : "set_cond", \
                   "enchant" : "set_enchant", \
                   "max condition" : "set_max_cond", \
                   "immune" : "add_immune_to", \
                   "type" : "set_type", \
                   "wear remove" : "set_wear_remove_func", \
                   "wear effect" : "add_wear_effect", \
                   "dex minus" : "set_dex_minus", \
                   "types" : "set_types", \
                   "damage chance" : "set_damage_chance" ])
#define CONT_FUN ([ \
                    "amount" : "set_amount", \
                    "continuous" : "set_continuous", \
                    "weight unit" : "set_weight_unit", \
                    "medium alias" : "set_medium_alias", \
                    "pile name" : "set_pile_name", \
                    "amount types" : "set_amount_types", \
                    "pile types" : "set_pile_types", \
                  ])
#define FOOD_FUN ([ \
                    "bites gone" : "set_bites_gone", \
                    "weight per bite" : "set_weight_per_bite", \
                    "eat mess" : "set_eat_mess", \
                    "eat effects" : "add_eat_effect", \
                    "piece description" : "set_piece_description", \
                  ])
#define WEP_FUN ([ "setup" : "new_weapon",\
                   "condition" : "set_condition", \
                   "enchant" : "set_enchant", \
                   "attack" : "add_attack", \
                   "max condition" : "set_max_cond", \
                   "immune" : "add_immune", \
                   "no limbs" : "set_no_limbs", \
                   "attack message" : "add_attack_message", \
                   "damage chance" : "set_damage_chance" ])
#define MON_FUN ([ "move after" : "set_move_after", \
                   "move zone" : "add_move_zone", \
                   "race" : "set_race", \
                   "class" : "set_class", \
                   "guild" : "set_guild", \
                   "level" : "set_level", \
                   "attack" : "add_attack", \
                   "attack message" : "add_attack_message", \
                   "ac" : "add_ac", \
                   "skill" : "add_skill_level", \
                   "equip" : "init_equip", \
                   "remove ac" : "remove_ac", \
                   "remove attack" : "remove_attack", \
                   "attack everyone" : "set_attack_everyone", \
                   "random stats" : "set_random_stats", \
                   "money" : "give_money", \
                   "chat" : "add_chat_string", \
                   "chat chance" : "set_chat_chance", \
                   "achat" : "add_achat_string", \
                   "achat chance" : "set_achat_chance", \
                   "talk string" : "add_talk_string", \
                   "join fights" : "set_join_fights", \
                   "alignment" : "set_al", \
                   "follow speed" : "set_follow_speed", \
                   "aggressive" : "set_aggressive", \
                   "str" : "set_str", \
                   "con" : "set_con", \
                   "dex" : "set_dex", \
                   "wis" : "set_wis", \
                   "bonus int" : "set_bonus_int", \
                   "bonus str" : "set_bonus_str", \
                   "bonus con" : "set_bonus_con", \
                   "bonus dex" : "set_bonus_dex", \
                   "bonus wis" : "set_bonus_wis", \
                   "int" : "set_int", \
                   "gender" : "set_gender", \
                   "command" : "add_known_command", \
                   "concentrate" : "set_concentrate", \
                   "protect" : "do_protect", \
                   "follow" : "do_follow", \
                   "throw out" : "set_throw_out", \
                   "basic setup" : "basic_setup" ])

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/virtual/virtual.h ===
#include <virtual.h>
#define SERVER "/global/virtual/server"
#define LOAD   1
#define CLONE  2

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/virtual/data_compiler.c ===
#include "virtual.h"
#include <soul.h>
#include <random_names.h>
void initialize_methods();
void create() {
  initialize_methods();
  seteuid(getuid());
}
void initialize_methods() {
  SERVER->add_method("s",  file_name(this_object()), "compile_soul", 1);
  SERVER->add_method("r_n",  file_name(this_object()), "compile_random_name", 1);
}
object compile_soul(string name, int) {
  object ob;
  if (name[0] != '/')
    name = "/"+name;
  if (name[0..strlen(SOUL_DIR)-1] != SOUL_DIR) {
    return 0;
  }
  name = name[strlen(SOUL_DIR)..];
  SOUL_COMPILER->compile_file(name);
  ob = clone_object("/std/object");
  ob->set_name("compile");
  ob->set_short("Compiling "+name+" now");
  call_out((: $(ob)->dest_me() :), 2);
  return ob;
}
object compile_random_name(string name, int clone) {
  object ob;
  if (name[0] != '/')
    name = "/"+name;
  if (name[0..strlen(RANDOM_NAME_DATA_DIR)-1] != RANDOM_NAME_DATA_DIR) {
    return 0;
  }
  name = name[strlen(RANDOM_NAME_DATA_DIR)..];
  RANDOM_NAME_GENERATOR->open_file(name);
  ob = clone_object("/std/object");
  ob->set_name("compile");
  ob->set_short("Compiling "+name+" now");
  call_out((: $(ob)->dest_me() :), 2);
  return ob;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/virtual/compiler.c ===
#include "virtual.h"
#include "compiler.h"
void    initialize_methods();
string  strip_string( string str );
#define WHITESPACE(c) (c == 10 || c == 32 || c == '\n')
mapping o_funcs;
mapping r_funcs;
mapping arm_funcs;
mapping clo_funcs;
mapping sca_funcs;
mapping wep_funcs;
mapping cont_funcs;
mapping food_funcs;
mapping mon_funcs;
mapping clotrans_funcs;
object  return_ob;
int     tmp_file_no;
int     debug_file;
void    create()
{
  seteuid("Root");
  initialize_methods();
  o_funcs = O_FUN;
  r_funcs = O_FUN + R_FUN;
  arm_funcs = ARM_FUN + O_FUN;
  clo_funcs = CLO_FUN + O_FUN;
  sca_funcs = SCA_FUN + O_FUN;
  wep_funcs = WEP_FUN + O_FUN;
  mon_funcs = MON_FUN + O_FUN;
  cont_funcs = CONT_FUN + O_FUN;
  food_funcs = FOOD_FUN + CONT_FUN + O_FUN;
  clotrans_funcs = O_FUN + CLO_FUN + CLOTRANS_FUN;
}
object  query_return_ob()
{
    return return_ob;
}
void    set_return_ob( object ob )
{
    return_ob = ob;
}
void    initialize_methods()
{
    SERVER->add_method( "r", file_name( this_object() ), "compile_r",
                        CLONE|LOAD );
    SERVER->add_method( "ro", file_name( this_object() ), "compile_r",
                        CLONE|LOAD );
    SERVER->add_method( "ob", file_name( this_object() ), "compile_ob" );
    SERVER->add_method( "arm", file_name( this_object() ), "compile_arm" );
    SERVER->add_method( "clo", file_name( this_object() ), "compile_clo" );
    SERVER->add_method( "trans", file_name( this_object() ), "compile_clotrans" );
    SERVER->add_method( "sca", file_name( this_object() ), "compile_sca" );
    SERVER->add_method( "wep", file_name( this_object() ), "compile_wep" );
    SERVER->add_method( "mon", file_name( this_object() ), "compile_mon" );
    SERVER->add_method( "food", file_name( this_object() ), "compile_food" );
    SERVER->add_method( "cont", file_name( this_object() ), "compile_cont" );
    SERVER->add_method( "imp", file_name( this_object() ), "compile_imp" );
}
#define Error(s) write(s); log_file( "VO_COMPILER", s); return 0;
mixed  *extract_arguments( string str );
void    do_clone( object dest, string str )
{
    object  ob;
    ob = clone_object( str );
    if( ob )
        ob->move( dest );
}
object  prop_to_fun( string file, mapping funs, string virt_class,
                    string virt_include, int clone )
{
    string *segments, *ind, data, s1, dir, tmp_name, tmp_val;
    string file_data;
    mixed  *val;
    int     i;
    int pos;
    debug_file = 0;
    file_data = "";
    pos = strsrch(file, "/", -1);
    tmp_name = file[0..pos] + "." + file[pos+1..] + "_virtual_.c";
    if (file_size(tmp_name) <= 0 ||
        stat(file)[1] > stat(tmp_name)[1]) {
       tmp_file_no++;
       if( find_object( tmp_name ) ) {
           tmp_name->dest_me();
       }
       ind = explode( file, "/" );
       dir = implode( ind[ 0..sizeof( ind ) - 2 ], "/" );
       unguarded((: rm, tmp_name :));
       file_data = "#include <"+ virt_include +">\n\n"
                "void dest_me() { destruct( this_object() ); }\n\n"
                "void create()\n{\n"
                "  seteuid( (string)\"/secure/master\"->creator_file( file_name( this_object() ) ) );\n"
                "} \n"
                "\nobject create_virtual_ob() {\n"
                "   object clone;\n\n";
       data = read_file( file );
       if( !data )
       {
           Error( "prop_to_fun() : file " + file + " not found\n" );
       }
       segments = explode( "$\n" + data, "\n#" );
       if( !segments )
       {
           Error( "prop_to_fun() : Nothing but comments?\n" );
       }
       segments[ 0 ] = segments[ 0 ][ 1..(sizeof(segments[ 0 ]) - 1) ];
       for( i = 1; i < sizeof( segments ); i++ ) {
           if( sscanf( segments[ i ], "%s\n%s", s1, segments[ i ] ) != 2 ) {
               segments[ i ] = "";
           }
       }
       data = implode( segments, "\n" );
       segments = explode( strip_string( data ), "::" );
       if (sizeof( segments ) % 2) {
         segments += ({""});
       }
       ind = allocate( sizeof( segments ) / 2 );
       val = allocate( sizeof( segments ) / 2 );
       for( i = 0; i < sizeof( ind ); i++ )
       {
           ind[ i ] = segments[ i * 2 ];
           val[ i ] = replace( segments[ i * 2 + 1 ], "\n", " " );
           if( ind[ i ][ 0..0 ] == "#" )
           {
               ind[ i ] = lower_case( ind[ i ] );
               if( ind[ i ] == "#debug" )
               {
                   sscanf( val[ i ], "%d", debug_file );
               }
               else
               {
                   if( ind[ i ] == "#class" )
                   {
                       virt_class = replace( val[i], " ", "" );
                   }
                   else
                   {
                       if( ind[ i ] == "#include" )
                       {
                           tmp_val = val[i];
                           file_data += "#include " +
                                       replace( tmp_val, " ", "" ) +
                                       "\n";
                       }
                   }
               }
           }
       }
       file_data += "  clone = (object)SERVER->create_virtual_object( " +
                   virt_class + ", 1 );\n"
                   "  clone->add_property( VIRTUAL_NAME_PROP, \""
                   + file + (clone ? "#1" : "") + "\" );\n";
       for( i = 0; i < sizeof( ind ); i++ )
       {
           ind[ i ] = lower_case( ind[ i ] );
           if( ind[ i ][ 0..0 ] == "#" )
           {
               continue;
           }
           val[ i ] = replace( val[ i ], ({"(:", "bind( (:",
                                           ":)", ":), clone )" }) );
           if( ind[ i ][ 0..0 ] == "$" )
           {
               {
                   file_data +="  call_other( clone, \"" +
                               ind[ i ][ 1..100 ] + "\", " + val[ i ] +
                               " );\n";
               }
               continue;
           }
           if( funs[ ind[ i ] ] )
           {
               if( !pointerp( funs[ ind[ i ] ] ) )
               {
                   file_data += "  call_other( clone, \"" +
                               funs[ ind[ i ] ] + "\", " + val[ i ] + " );\n";
               }
               else
               {
                   file_data += "  call_other( " + funs[ ind[ i ] ][ 1 ] +
                               ", " + funs[ ind[ i ] ][ 0 ] + ", " + val[ i ] +
                               " );\n";
               }
           }
           else
           {
               write( "Error: Unknown index " + ind[ i ] + "\n" );
           }
       }
       file_data += "   return clone;\n} \n";
       unguarded((: write_file, tmp_name, file_data :));
   }
   if( data = catch( return_ob = tmp_name->create_virtual_ob() ) )
   {
        write( "Error loading " + file + ", " + data + "\n" );
        if( debug_file )
        {
            write( "File not removed.\n" );
        }
        else
        {
        }
    }
    else
    {
        tmp_name->dest_me();
        return return_ob;
    }
}
string  strip_string( string str )
{
    int     i, j;
    j = strlen( str ) - 1;
    for( ; WHITESPACE( str[ i ] ) && i < j; i++ ) ;
    for( ; WHITESPACE( str[ j ] ) && j > i; j-- ) ;
    return str[ i..j ];
}
mixed   str_to_var( string str )
{
    int     i;
    str = strip_string( str );
    switch( str[ 0 ] )
    {
        case '{':
            {
                str = str[ 1..strlen( str ) - 2 ];
                return map_array( explode( str, "," ), "str_to_var",
                                  this_object() );
            }
        case '"':
            {
                str = str[ 1..strlen( str ) - 2 ];
                return replace( str, "\n", " " ) + "\n";
            }
        case '0'..'9':
        case '-':
            {
                sscanf( str, "%d", i );
                return i;
            }
    }
    return str;
}
mixed  *extract_arguments( string str )
{
    return map_array( explode( str, "
}
object  compile_r( string name, int clone ) {
    object r;
    r = prop_to_fun( name, r_funcs, "\"/obj/virtual_room.c\"",
                    "virtual_room.h", 1 );
    r->reset();
    return r;
}
object  compile_ob( string name, int clone ) {
    return prop_to_fun( name, o_funcs, "\"/std/object.c\"",
                    "virtual.h", clone );
}
object  compile_arm( string name, int clone ) {
    if (name[0 .. 19] == "/obj/armours/shield/")
        return prop_to_fun(name, arm_funcs, "\"/obj/shield.c\"",
                        "virtual.h", clone );
    return prop_to_fun( name, arm_funcs, "\"/obj/armour.c\"",
                    "virtual.h", clone );
}
object  compile_clo( string name, int clone ) {
    return prop_to_fun( name, clo_funcs, "\"/obj/clothing.c\"",
                    "virtual.h", clone );
}
object compile_sca( string name, int clone ) {
   return prop_to_fun( name, sca_funcs, "\"/obj/scabbard.c\"",
                    "virtual.h", clone );
}
object  compile_wep( string name, int clone ) {
    return prop_to_fun( name, wep_funcs, "\"/obj/weapon.c\"",
                    "virtual.h", clone );
}
object  compile_mon( string name, int clone ) {
    return prop_to_fun( name, mon_funcs, "\"/obj/monster.c\"",
                    "virtual.h", clone );
}
object  compile_food( string name, int clone ) {
    return prop_to_fun( name, food_funcs, "\"/obj/food.c\"",
                    "virtual.h", clone );
}
object  compile_cont( string name, int clone ) {
    return prop_to_fun( name, cont_funcs, "\"/obj/cont_medium.c\"",
                    "virtual.h", clone );
}
object  compile_clotrans( string name, int clone ) {
    return prop_to_fun( name, clotrans_funcs, "\"/obj/clothing_transport.c\"",
                    "virtual.h", clone );
}
object  compile_imp( string name, int clone ) {
    return prop_to_fun( name, o_funcs, "\"/obj/implement.c\"",
                    "virtual.h", clone );
}
int set_debug_status(int d_stat) {
  debug_file=d_stat;
  return debug_file;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/virtual/test.ro ===
::Long:: "
  This is barely a room. It is, infact, a small lump of putty!
Deep in the heart of nowhere, you spy a circle of blue wax.
This room description is beginning to run out of steam. There! Psfth.\n"
::Short:: "Wombleroom"
::Item::  ({ "circle", "wax" }),  "
  The circle of blue wax is infact bright green.\n"
::Exit:: "north", "/players/zellski/virtual/test.r", "door"

::light::100


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/virtual/new_c_compiler.c ===
object clone_virtual_object(string name) {
  return efun::clone_object(name);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/virtual/vr_hand.c ===
object compile_virtual_room(string filename);
void parse_object(object room, string command);
void create()
{
  seteuid(getuid(this_object()));
}
object compile_virtual_room(string filen)
{
  string tmp, tmp2;
  object new_room;
  int i;
  i=3;
  tmp=read_file(filen, 2, 1);
  tmp2=tmp[1..strlen(tmp)-2];
  new_room=clone_object("/"+tmp2);
  while (read_file(filen, i, 1))
  {
    tmp=read_file(filen, i, 1);
    if(tmp=="") break;
    parse_object(new_room, tmp);
    i++;
  }
  return new_room;
}
void parse_object(object room, string command)
{
  string *func_call,s1,s2,s3;
  int i1,i2,i3,i4;
  if(!command) return;
  func_call=explode(command, "#");
  if((string)func_call[0][0]==";") return;
  switch (func_call[0])
  {
    case "SHORT" :
      room->set_short(func_call[1]);
      break;
    case "LONG" :
      room->set_long(func_call[1]);
      break;
    case "EXIT" :
      room->add_exit(func_call[1], func_call[2]);
      break;
    case "LIGHT" :
      i1=sscanf(func_call[1], "%d", i2);
      room->set_light(i2);
      break;
    case "ITEM" :
      room->add_item(explode(func_call[1], ","), explode(func_call[2], ","));
      break;
    case "TASTE" :
      room->add_taste(func_call[1], func_call[2]);
      break;
    case "SMELL" :
      room->add_smell(func_call[1], func_call[2]);
      break;
    case "SOUND" :
      room->add_sound(func_call[1], func_call[2]);
      break;
    case "TOUCH" :
      room->add_feel(func_call[1], func_call[2]);
      break;
    case "OBJECT" :
      room->add_object(func_call[1]);
      break;
    case "ACTION" :
      i2=0;
      catch(i1=sscanf(func_call[3], "%d", i2));
      room->action_add(func_call[1], func_call[2], i2);
      break;
    case "CODE" :
      room->set_code_module(func_call[1]);
      break;
    case "PROP" :
      room->add_property(func_call[1], func_call[2]);
      break;
    case "COORD" :
      i1=sscanf(func_call[1], "%d,%d,%d", i2,i3,i4);
      room->set_co_ord(({i2,i3,i4}));
      break;
  }
  return;
}
