
==================================================
FILE: bastards.c
==================================================

#include <access.h>
#include <mail.h>
#include <player_handler.h>
#include <login.h>
#include <playerinfo.h>
#include <playtesters.h>
#define TIMEOUT_TIME 2419200
nosave string *names;
mapping site_access;
mapping suspended;
mapping lockedout;
mapping multiuser;
mapping temp_passwords;
int query_access(object ob);
protected void timeout_access();
private void save_me();
void create() {
  seteuid("Root");
  site_access = ([ ]);
  suspended = ([ ]);
  lockedout = ([ ]);
  multiuser = ([ ]);
  temp_passwords = ([ ]);
  if(!unguarded((: restore_object, base_name(this_object()) :)))
    write("Failed to restore bastards.\n");
  if (!site_access) {
    write("mmm, no site access\n");
    site_access = ([ ]);
  }
  if(!lockedout)
    lockedout = ([ ]);
  if(!multiuser)
    multiuser = ([ ]);
  if(!temp_passwords) {
    temp_passwords = ([ ]);
  }
  timeout_access();
  if (find_object("/room/void"))
    move_object(find_object("/room/void"));
}
string query_player_ob(string name) {
  if("/secure/master"->query_administrator(name) ||
     "/secure/master"->query_lord(name))
    return "/global/lord";
  if (PLAYER_HANDLER->test_creator(name))
    return "/global/creator";
  if (PLAYTESTER_HAND->query_playtester(name))
    return "/global/playtester";
  return "/global/player";
}
int query_prevent_shadow() { return 1; }
mapping query_all_access() { return copy(site_access); }
int query_access(object ob) {
  string tmp;
  tmp = query_ip_number(ob);
  while(strlen(tmp)) {
    if(site_access[tmp])
      return site_access[tmp][ACCESS_LEVEL];
    tmp = implode((string *)explode(tmp, ".")[0..<2], ".");
  }
  tmp = query_ip_name(ob);
  while(strlen(tmp)) {
    if(site_access[tmp])
      return site_access[tmp][ACCESS_LEVEL];
    tmp = implode(explode(tmp, ".")[1..], ".");
  }
  return DEFAULT;
}
int query_multi(object ob) {
  string tmp;
  tmp = query_ip_number(ob);
  while(strlen(tmp)) {
    if(multiuser[tmp])
      return 1;
    tmp = implode((string *)explode(tmp, ".")[0..<2], ".");
  }
  tmp = query_ip_name(ob);
  while(strlen(tmp)) {
    if(multiuser[tmp])
      return 1;
    tmp = implode(explode(tmp, ".")[1..], ".");
  }
  return 0;
}
mapping query_all_multi() { return copy(multiuser); }
string query_reason(string address) {
  if(site_access[address])
    return site_access[address][ACCESS_REASON];
  return 0;
}
protected void add_multi(string address, int multi, int timeout) {
  if(!multi)
    map_delete(multiuser, address);
  else
    multiuser[address] = timeout;
}
protected void add_access(string address, int level, string reason,
                          int timeout) {
  site_access[address] = ({ level, reason, timeout });
}
protected void timeout_access() {
  string bit;
  foreach(bit in keys(site_access))
    if(site_access[bit][ACCESS_TIMEOUT] < time() ||
       site_access[bit][ACCESS_LEVEL] == ACCESS)
      map_delete(site_access, bit);
  foreach(bit in keys(multiuser))
    if(multiuser[bit] < time())
      map_delete(multiuser, bit);
}
private void save_me() {
  unguarded((: save_object, base_name(this_object()), 2 :));
}
int change_access(string address, int level, string reason, int timeout) {
  if(!master()->query_lord(previous_object(-1)) &&
     base_name(previous_object()) != "/cmds/creator/ban")
    return 0;
  if(!stringp(address) || !reason)
    return notify_fail("Invalid parameters.\n");
  if (!timeout)
    timeout = time() + 100 * 24 * 60 * 60;
  add_access(address, level, reason, timeout);
  save_me();
  unguarded((: write_file, "/log/ACCESS", ctime(time())[4..16] + " " +
             address+" set to " + PERM_NAMES[level] + " for " + reason +
             " until " + ctime(timeout) + " by "+
             this_player()->query_name()+".\n" :));
  return 1;
}
int change_multi(string address, int multi, int timeout) {
  if(!master()->query_lord(previous_object(-1)) &&
     base_name(previous_object()) != "/cmds/creator/multipl_ayer")
    return 0;
  if(!stringp(address))
    return notify_fail("Invalid parameters.\n");
  if (!timeout)
    timeout = time() + 100 * 24 * 60 * 60;
  add_multi(address, multi, timeout);
  save_me();
  unguarded((: write_file, "/log/ACCESS", ctime(time())[4..16] + " " +
             address+" set to " + (multi?"allow":"disallow") +
             " multiple users until " + ctime(timeout) + " by "+
             this_player()->query_name()+".\n" :));
  return 1;
}
int suspend_person(string str, int tim, string reason) {
  if (!master()->query_lord(previous_object(-1)) &&
      base_name(previous_object()) != "/cmds/creator/suspend") {
    return 0;
  }
  if (!PLAYER_HANDLER->test_user(str)) {
    return 0;
  }
  if (!reason) {
    reason = "you have been bad";
  }
  suspended[str] = ({ time() + tim, reason });
  save_me();
  unguarded((: write_file, "/log/SUSPEND", ctime(time())[4..16] + " " +
             str+" suspended until "+ ctime(time()+tim)+" by "+
             this_player()->query_name()+" because "+ reason + ".\n" :));
  PLAYERINFO_HANDLER->add_entry(this_player(), str, "suspend",
                                "Suspended until " + ctime(time() + tim) +
                                " for " + reason);
  return 1;
}
int unsuspend_person(string str) {
  if (!"/secure/master"->query_lord(previous_object(-1)) &&
      base_name(previous_object()) !="/cmds/creator/unsuspend") {
    return 0;
  }
  map_delete(suspended, str);
  unguarded((: save_object, base_name(this_object()), 2 :));
  unguarded((: write_file, "/log/SUSPEND",
             ctime(time())[4..16] + " " + str+" unsuspended.\n" :));
  PLAYERINFO_HANDLER->add_entry(this_player(), str, "suspend", "Unsuspended.");
  return 1;
}
mixed *query_suspended(string name) {
  if (suspended[name]) {
    if (suspended[name][SUSPEND_TIME] > time()) {
      return copy(suspended[name]);
    }
    map_delete(suspended, name);
    save_me();
  }
  return suspended[name];
}
int lockout_person(string str, int tim, string reason) {
  if (!master()->query_lord(previous_object(-1)) &&
      base_name(previous_object()) != "/cmds/player/lockout") {
    return 0;
  }
  if (!PLAYER_HANDLER->test_user(str)) {
    return 0;
  }
  if (!reason) {
    reason = "you have been bad";
  }
  lockedout[str] = ({ time() + tim, reason });
  save_me();
  unguarded((: write_file, "/log/LOCKOUT",
             ctime(time())[4..16] + " " + str+" lockedout until "+
             ctime(time()+tim)+" by "+this_player()->query_name()+" because "+
             reason + ".\n" :));
  PLAYERINFO_HANDLER->add_entry(this_player(), str, "lockedout",
                                "Locked out until " + ctime(time() + tim) +
                                " for " + reason);
  return 1;
}
mixed *query_lockedout(string name) {
  if (lockedout[name]) {
    if (lockedout[name][SUSPEND_TIME] > time()) {
      return copy(lockedout[name]);
    }
    map_delete(lockedout, name);
    save_me();
  }
  return lockedout[name];
}
int set_temp_password(string name, string pass) {
  temp_passwords[name] = ({ time(), pass });
  save_me();
  return 1;
}
mixed *query_temp_password(string name) {
  int found;
  string tmp;
  foreach(tmp in keys(temp_passwords)) {
    if(temp_passwords[tmp][0] < (time() - TIMEOUT_TIME)) {
      map_delete(temp_passwords, tmp);
      found = 1;
    }
  }
  if(found)
    save_me();
  return copy(temp_passwords[name]);
}
void clear_temp_password(string name) {
  if(temp_passwords[name]) {
    map_delete(temp_passwords, name);
    save_me();
  }
}

==================================================
FILE: bulk_delete.c
==================================================

#include <player_handler.h>
#include <mail.h>
#define ERASE_RATE 30
#define MIN_DELAY 604800
#define MAIL_UNREAD_TIME 15552000
#define MAIL_INACTIVE_TIME 31536000
#define ALPHABET ({ "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", \
                    "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", \
                    "w", "x", "y","z" })
#define SAVEFILE "/secure/bulk_delete.os"
#define FOLDER_H "/obj/handlers/folder_handler.c"
nosave string *dirs, current, fname;
nosave class mail_header *folder;
private void delete_name(string name);
private void check_name(string name);
protected void create() {
  string var;
  if (mud_name() != "Discworld") {
    return;
  }
  seteuid("Root");
  dirs = ({ });
  if (file_size(SAVEFILE) >= 0) {
    var = unguarded((: read_file, SAVEFILE :));
    dirs = restore_variable(var);
  }
  call_out("continuous_erase", 1);
}
protected void reset() {
  string var;
  var = save_variable(dirs);
  unguarded((: write_file, SAVEFILE, var, 1 :));
  if (find_call_out("continuous_erase") == -1) {
    call_out("continuous_erase", 1);
  }
}
protected void continuous_erase(string *all_files) {
  if (!sizeof(all_files)) {
    if(!sizeof(dirs)) {
      dirs = ALPHABET;
    }
    current = dirs[random(sizeof(dirs))];
    log_file("EXPIRED", "%s Starting letter %s\n", ctime(time()), current);
    dirs -= ({ current });
    all_files = get_dir(PLAYER_SAVE_DIR + current + "
  time_on = - PLAYER_HANDLER->test_age(name);
  last_log_on = PLAYER_HANDLER->test_last(name);
  if((time() - last_log_on) > MAIL_INACTIVE_TIME) {
    tmp = FOLDER_H->mail_count(name);
    if(tmp[0]) {
#ifdef DEBUG
      log_file("EXPIRED_DEBUG", "%s would have erased mail for %s\n",
               ctime(time()), name);
#else
      log_file("EXPIRED", "%s erased mail for %s\n", ctime(time()), name);
      FOLDER_H->delete_account(name);
    }
    return;
#endif
  }
  if(PLAYER_HANDLER->test_creator(name))
    return;
  if(PLAYER_HANDLER->test_property(name, "no delete"))
    return;
#ifdef DEBUG
  log_file("EXPIRED_DEBUG", "%s %s last logged in %s [%d] age x 60 [%d]\n",
           ctime(time()), name, ctime_elapsed(time() - last_log_on),
           time() - last_log_on, time_on * 60);
#endif
  if((time() - last_log_on) < MIN_DELAY)
    return;
  if((time() - last_log_on) > (time_on * 60)) {
#ifdef DEBUG
    log_file("EXPIRED_DEBUG", "%s would have erased: %s\n",
             ctime(time()), name);
#else
    delete_name(name);
    return;
#endif
  }
  if((time() - last_log_on) > MAIL_UNREAD_TIME) {
    tmp = FOLDER_H->mail_count(name);
    if(!tmp[1])
      return;
    folder = FOLDER_H->get_messages(name, "inbox");
    tmp = ({ });
    for(i=0; i<sizeof(folder); i++) {
      if(folder[i]->status == "N");
      tmp += ({ i });
      reset_eval_cost();
    }
    if(sizeof(tmp)) {
      FOLDER_H->delete_it(name, "inbox", tmp);
    }
  }
}
private void delete_name( string name ) {
  log_file("EXPIRED", "%s Timed out player deletion: %s\n", ctime(time()),
           name);
  fname = PLAYER_HANDLER->query_player_file_name(name);
  unguarded((: rm,  fname + ".o" :));
  unguarded((: rm, fname + ".o.gz" :));
#ifdef USE_RAMDISK
  fname = PLAYER_HANDLER->query_player_ram_file_name(name);
  unguarded((: rm,  fname + ".o" :));
  unguarded((: rm, fname + ".o.gz" :));
  fname = PLAYER_HANDLER->query_player_disk_file_name(name);
  unguarded((: rm,  fname + ".o" :));
  unguarded((: rm, fname + ".o.gz" :));
#endif
  "/secure/related_files"->delete_related_files(name, 1);
  PLAYER_HANDLER->remove_cache_entry(name);
}
int delete_files(string letter) {
  string *all_files;
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
               ": illegal attempt to delete timed out player files using "
               "/secure/bulk_delete.\nTrace: " + back_trace() :));
    return 0;
  }
  if (!master()->high_programmer(previous_object(-1))) {
    unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
               ": illegal attempt to delete timed out player files using "
               "/secure/bulk_delete.\nTrace: " + back_trace() :));
    return 0;
  }
  log_file("EXPIRED", "Manually Requested Processing of %s.\n", letter);
  current = letter;
  all_files = get_dir(PLAYER_SAVE_DIR+ letter +"
int clean_up_files(string dir) {
  int i;
  string *all_files = ({ });
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
               ": illegal attempt to delete unused files using "
               "/secure/bulk_delete.\nTrace: " + back_trace() :));
    return 0;
  }
  if (!master()->high_programmer(previous_object(-1))) {
    unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
               ": illegal attempt to delete unused files using "
               "/secure/bulk_delete.\nTrace: " + back_trace() :));
    return 0;
  }
  switch (dir) {
  case "artifacts" :
    all_files = get_dir("/save/"+ dir +"*.o");
    break;
  case ".dead_ed_files" :
    all_files = get_dir("/w/.dead_ed_files/");
    break;
  default :
    return notify_fail("Invalid directory.\n");
  }
  all_files -= ({ ".", ".." });
  if (!sizeof(all_files)) {
    return notify_fail("Directory empty.\n");
  }
  for (i = sizeof(all_files) - 1; i > -1; i--) {
    switch (dir) {
    case "artifacts" :
      call_out((: check_name :), 5 * (i + 1), all_files[i]);
      break;
    case "mail" :
      call_out((: check_name :), 5 * (i + 1),
               explode(all_files[i], "inbox")[0]);
      break;
    case ".dead_ed_files" :
      call_out((: check_name :), 5 * (i + 1),
               explode(all_files[i], "-")[0]);
      break;
    default :
      call_out((: check_name :), 5 * (i + 1), all_files[i][0..<3]);
      break;
    }
  }
  return 1;
}
mixed *stats() {
  return ({
    ({ "current letter", current }),
    ({ "remaining dirs", sizeof(dirs) ? implode(dirs, ", ") : 0 })
  });
}

==================================================
FILE: command.c
==================================================

#include <command.h>
#include <user_parser.h>
private nosave mapping Commands, Cache;
private nosave string *Paths, *GRCommands;
private nosave string last_verb, last_args, found_cmd, found_args;
void eventRehash(string *paths);
void create() {
   seteuid(getuid());
   Commands = ([]);
   Cache = ([ ]);
   GRCommands = ({});
   Paths = ({});
   eventRehash( ({ DIR_PLAYER_CMDS, DIR_CREATOR_CMDS, DIR_SECURE_CREATOR_CMDS,
                   DIR_LORD_CMDS, DIR_LIVING_CMDS, DIR_GUILD_CMDS,
                   DIR_PLAYTESTER_CMDS }) );
}
void eventGuildRaceRehash() {
   string *paths, path;
   paths = ({ DIR_GUILD_CMDS });
   paths += map(filter(unguarded((: get_dir, DIR_GUILD_CMDS + "/", -1 :)),
                                 (: $1[1] == -2 :)),
                      (: DIR_GUILD_CMDS + "/" + $1[0] :));
   GRCommands = ({ });
   foreach (path in paths) {
      string *files, cmd;
      files = map(unguarded((: get_dir, path + "
void eventRehash(mixed paths) {
   string path;
   Cache = ([ ]);
   if (stringp(paths)) {
      paths = ({ paths });
   } else if (!pointerp(paths)) {
      return;
   }
   foreach(path in paths) {
      string file;
      if  ( path[<1..<1] == "/" ) continue;
      if (file_size(path) != -2)
         continue;
      if (path == DIR_GUILD_CMDS) {
         eventGuildRaceRehash();
         continue;
      }
      foreach (file in unguarded((: get_dir, path + "
void HandleCommandLine(class command cmd) {
   string args = cmd->args;
   int i;
   string* bits;
   if ((i = strsrch(args, " ")) != -1) {
      cmd->verb = args[0..i-1];
      cmd->args = args[i+1..];
   } else {
      cmd->verb = args;
      cmd->args = (string)0;
   }
}
int strncmp(string s1, string s2, int len) {
   return strcmp(s1[0..len-1], s2[0..len-1]);
}
int HandleStars(class command cmd) {
   int i;
   int no_cache;
   string file, *files;
   if(cmd->verb == "END_ALIAS")
     return 0;
   if(last_verb == cmd->verb && last_args == cmd->args) {
     cmd->verb = found_cmd;
     if(stringp(found_args)) {
       cmd->args = found_args;
     }
     return 1;
   }
   if(Cache[cmd->verb]) {
     if(stringp(Cache[cmd->verb][1]))
       cmd->args = Cache[cmd->verb][1];
     cmd->verb = Cache[cmd->verb][0];
     return 1;
   }
   if (Commands[cmd->verb]) {
     return 1;
   }
   files = keys(Commands);
   files = filter(files, (: (int)$1[0] == $(cmd)->verb[0] :));
   foreach (file in files) {
     string tmpverb, tmpargs = 0, tmpfile = 0;
     int len, length;
     if ((i = strsrch(file, "_")) == -1)
       continue;
     tmpfile = (string)delete(file, i, 1);
     len = strlen(tmpfile);
     if (i == len) {
       tmpargs = cmd->verb[i..]+(cmd->args?(strlen(cmd->verb) == i?"":" ") +
                                 cmd->args:"");
       tmpverb = cmd->verb[0..i-1];
       if (strncmp(tmpfile, tmpverb, len) != 0) {
         continue;
       }
       no_cache = 1;
     } else {
       length = strlen(cmd->verb);
       if ((length > len) || (length < i))
         continue;
       if (strncmp(cmd->verb, tmpfile, length) != 0)
         continue;
     }
     if (!no_cache) {
        Cache[cmd->verb] = ({ file, tmpargs });
     }
     last_verb = cmd->verb;
     last_args = cmd->args;
     cmd->verb = file;
     if (stringp(tmpargs))
       cmd->args = tmpargs;
     found_cmd = cmd->verb;
     found_args = tmpargs;
     return 1;
   }
   return 0;
}
int GetCommand(class command cmd, string *path) {
   string *tmp;
   int i;
   if (!stringp(cmd->args)) {
      return 0;
   }
   tmp = (path & Paths);
   if (sizeof(tmp = path - tmp)) {
      eventRehash(tmp);
   }
   HandleCommandLine(cmd);
   if (HandleStars(cmd) && Commands[cmd->verb] &&
       sizeof(tmp = (path & (string *)Commands[cmd->verb]))) {
      cmd->file = sprintf("%s/%s", tmp[0], cmd->verb);
      cmd->filepart = cmd->verb;
      if ((i = strsrch(cmd->verb, "_")) != -1) {
         cmd->verb = (string)delete(cmd->verb, i, 1);
      }
      if (cmd->args && cmd->args == "") {
         cmd->args = (string)0;
      }
      if ((cmd->file)->query_patterns()) {
         return 0;
      }
      return 1;
   }
   return 0;
}
mixed ReturnPatterns(class command cmd, string *path) {
   mixed *q_patterns;
   mixed *r_patterns;
   mixed *stuff;
   mixed *tmp;
   mixed *ret_patterns;
   int i, j;
   string fname;
   tmp = (path & Paths);
   tmp = path - tmp;
   if (sizeof(tmp)) {
      eventRehash(tmp);
   }
   if (HandleStars(cmd) && Commands[cmd->verb]) {
      tmp = (path & (string *)Commands[cmd->verb]);
      if (tmp) {
         ret_patterns = ({ });
         foreach (fname in tmp) {
            cmd->file = sprintf("%s/%s", fname, cmd->verb);
            q_patterns = (cmd->file)->query_patterns();
            if (!q_patterns) {
               return 0;
            }
            r_patterns = ({ });
            for (i = 0; i < sizeof(q_patterns); i += 2) {
               if (q_patterns[i+1] && !functionp(q_patterns[i+1])) {
                  continue;
               }
               stuff = (mixed *)PATTERN_OB->query_pattern(q_patterns[i]);
               j = 0;
               while (j < sizeof(r_patterns) &&
                         r_patterns[j][PATTERN_WEIGHT] >= stuff[0]) {
                  j++;
               }
               r_patterns = r_patterns[0..j-1] +
                  ({ ({ stuff[0], q_patterns[i], 0, find_object(cmd->file),
                           q_patterns[i+1] }) }) + r_patterns[j..];
            }
            ret_patterns += r_patterns;
         }
         return ret_patterns;
      }
   }
   return 0;
}
mixed *GetCommandPatterns(string cmd_name, string *path) {
   class command cmd;
   mixed *stuff;
   cmd = new(class command);
   cmd->verb = cmd_name;
   cmd->args = 0;
   stuff = ReturnPatterns(cmd, path);
   return stuff;
}
varargs string *GetCommands(string path) {
   string *paths, *tmp;
   string cmd;
   if (!path) {
      return keys(Commands);
   }
   tmp = ({ });
   foreach (cmd, paths in Commands) {
      if (member_array(path, paths) != -1) {
         tmp += ({ cmd });
      }
   }
   return tmp;
}
varargs string *GetPaths(string cmd) {
   if (cmd) {
      string *paths;
      class command tmp;
      if (sizeof(paths = Commands[cmd])) {
         return paths;
      }
      tmp = new(class command, verb : cmd);
      if (HandleStars(tmp)) {
         return Commands[tmp->verb];
      } else {
         return 0;
      }
   }
   return Paths;
}
int IsGRCommand(string cmd) {
   if (member_array(cmd, GRCommands) != -1) {
      return 1;
   } else {
      class command tmp = new(class command, verb : cmd);
      if (HandleStars(tmp)) {
         return (member_array(tmp->verb, GRCommands) != -1);
      }
   }
}

==================================================
FILE: delete_clear.c
==================================================

#include <player_handler.h>
#include <refresh.h>
#define ONE_DAY (60*60*24)
#define SAVE_FILE "/save/del_pl_check"
protected void do_checks();
protected void do_delete_check();
protected void do_appeal_check();
void create() {
  seteuid("Root");
  unguarded((: restore_object(SAVE_FILE) :));
  do_checks();
}
protected void do_checks() {
  unguarded((: do_delete_check() :));
  unguarded((: do_appeal_check() :));
  save_object(SAVE_FILE);
  call_out("do_checks", ONE_DAY);
}
protected  void do_delete_check() {
  string *bits, name;
  int i;
  mixed *rubbish;
  bits = get_dir(PLAYER_SAVE_DIR+DELETE_DIR+"/*.o");
  bits += get_dir(PLAYER_SAVE_DIR+DELETE_DIR+"/*.o.gz");
  for (i=0;i<sizeof(bits);i++) {
    rubbish = stat(PLAYER_SAVE_DIR+DELETE_DIR+"/"+bits[i]);
    if (rubbish[1]+(ONE_DAY*10) < time()) {
      log_file( "EXPIRED", "Requested player deletion: "+bits[ i ] +".\n" );
    name = explode( bits[i], "." )[ 0 ];
      user_event( "inform", "Auto deleting user "+name, "delete");
      "/secure/related_files"->delete_related_files(name, 1);
      unguarded((: rm( PLAYER_SAVE_DIR+DELETE_DIR+"/"+$(bits[i])) :));
      REFRESH_HANDLER->player_deleted(name);
    }
  }
}
protected  void do_appeal_check() {
  string *bits, name;
  int i;
  mixed *rubbish;
  bits = get_dir(PLAYER_SAVE_DIR+APPEAL_DIR+"/*.o");
  bits += get_dir(PLAYER_SAVE_DIR+APPEAL_DIR+"/*.o.gz");
  for (i=0;i<sizeof(bits);i++) {
    rubbish = stat(PLAYER_SAVE_DIR+APPEAL_DIR+"/"+bits[i]);
    if (rubbish[1]+(ONE_DAY*28) < time()) {
      log_file( "EXPIRED", ctime(time()) + " appeal player deletion: "+
                bits[i]+".\n");
      name = explode( bits[i], "." )[ 0 ];
      user_event( "inform", "Auto deleting user "+name, "delete");
      "/secure/related_files"->delete_related_files(name, 1);
      unguarded((: rm( PLAYER_SAVE_DIR+APPEAL_DIR+"/"+$(bits[i])) :));
      REFRESH_HANDLER->player_deleted(name);
    }
  }
}

==================================================
FILE: finger.c
==================================================

#include <config.h>
#include <mail.h>
#include <finger.h>
#include <player_handler.h>
#include <player.h>
#include <access.h>
#include <login.h>
#include <clubs.h>
#include <alias.h>
#include <library.h>
#include <nomic_system.h>
inherit "/std/basic/club_listing";
inherit "/global/family";
#define NO_EMAIL_TIME 7776000
#define WWW_REPLACEMENTS (["%^BOLD%^" : "<b>", \
                           "%^EBOLD%^" : "</b>", \
                           "%^RESET%^" : "", \
                           "\n" : "<br>\n" ])
#define REPLACEMENTS (["%^EBOLD%^" : "%^RESET%^", \
                       "<br>" : ""])
void create() {
   seteuid("Root");
}
string htmlise(string str) {
   return replace_string(str, "<", "&lt;");
}
string banish_finger(string name, int caller) {
  string retval;
  string *file;
  file = explode(read_file("/banish/" + name[0..0] + "/" + name + ".o"), "\n");
  retval = sprintf("%35-s%35-s\n", "Login name : " + name,
                   "Real name : Banished");
  retval += "Not really many seconds old.\n";
  retval += "No mail ever.\n";
  retval += "No plan.\nNo future.\n";
  if (caller) {
    if (sizeof(file) == 3) {
      retval += implode(file, "\n") + "\n";
    } else {
      retval += "Banish info not in the correct format.\n";
    }
  }
  if (CLUB_HANDLER->is_club(name)) {
    retval += "\nThere is also a club of this name, try: 'refer club " +
      name + "' for information on the club.\n";
  }
  return replace(retval, "@@", "@ @ ");
}
string time_elapsed_string(int time_elapsed) {
   return query_time_string(time_elapsed, -1);
}
private string get_additional_info(string name, int no_colour,
                                   int user_colour, int width, int caller) {
  string retval, tmp, tmp_leader;
   string *bing;
   int i, used_colour, need_new, domain_leader, domain_deputy,
     domain_developer;
   object ob;
   retval = "%^BOLD%^";
   if (PLAYER_HANDLER->test_creator(name)) {
      if (master()->query_trustee(name))
         retval += capitalize(name) + " is a Trustee.\n";
      else if (master()->query_director(name))
         retval += capitalize(name) + " is a Director.\n";
      else if (master()->query_senior(name))
         retval += capitalize(name) + " is a Senior Creator.\n";
      else
         retval += capitalize(name) + " is a Creator.\n";
      bing = "/secure/master"->query_domains();
      tmp = "";
      tmp_leader = "";
      for (i = 0; i < sizeof(bing); i++) {
         if ((string) ("/d/" + bing[i] + "/master")->query_lord() == name) {
            bing[i] = capitalize(bing[i]);
            tmp_leader += "Leader of the " + bing[i] + " domain.\n";
            domain_leader = 1;
            continue;
         } else if (("/d/" + bing[i] + "/master")->query_deputy(name)) {
            tmp += "Deputy of the " + capitalize(bing[i]) + " domain.\n";
            domain_deputy = 1;
         } else if (!("/d/" + bing[i] + "/master")->query_member(name)) {
           if(bing[i] != "fluffy" && bing[i] != "liaison")
             domain_developer = 1;
           continue;
         }
         tmp += "Project in the " + capitalize(bing[i]) + " domain: " +
           ("/d/" + bing[i] + "/master")->query_project(name) + "\n";
         bing[i] = capitalize(bing[i]);
      }
      tmp = tmp_leader + tmp;
      if (!sizeof(bing) && !domain_leader && !domain_deputy &&
          !domain_developer)
          tmp += "Not a member of any domain.\n";
      bing = ({ });
      if("/d/admin/master"->query_member(name))
        bing += ({ "Administrator" });
      if(domain_leader)
        bing += ({ "Domain Leader" });
      if(domain_deputy)
        bing += ({ "Domain Deputy" });
      if("/d/liaison/master"->query_member(name))
        bing += ({ "Liaison" });
      else if(domain_developer)
        bing += ({ "Developer" });
      if(sizeof(bing))
        retval += "Roles : " + query_multiple_short(bing) + ".\n";
      if(tmp)
        retval += sprintf("Domains : %-=*s", width - 10, tmp);
   } else if (PLAYTESTER_HAND->query_playtester(name)) {
      bing = ({"Playtester"});
      if (PLAYTESTER_HAND->query_pt_exec (name)) {
        bing += ({"Playtesting Executive"});
      }
      if (PLAYTESTER_HAND->query_senior_playtester(name)) {
         retval += capitalize(name) + " is a Senior Playtester.\n";
      } else {
         retval += capitalize(name) + " is a Playtester.\n";
      }
        retval += "Roles : " + query_multiple_short(bing) + ".\n";
   }
   retval += "%^EBOLD%^";
   i = PLAYER_HANDLER->test_start_time(name);
   if (i)
      retval += "First logged on " + ctime(i) + ".\n";
   retval += capitalize(time_elapsed_string(-PLAYER_HANDLER->test_age(name))) + " old.\n";
   if (find_player(name) &&
       (caller >= find_player(name)->query_invis() ||
        (this_player() &&
         reference_allowed(find_player(name), this_player())))) {
      retval += "On since " + ctime(PLAYER_HANDLER->test_last(name)) + " (" +
         capitalize(time_elapsed_string(time() - PLAYER_HANDLER->test_last(name))) +
         ").\n";
   } else {
      i = time() - PLAYER_HANDLER->test_last(name);
      retval += "Last logged off " + time_elapsed_string(i) + " ago.\n";
   }
   if (caller > 1) {
      if (!find_player(name)) {
         retval += PLAYER_HANDLER->test_last_on_from(name) + "  ";
         need_new = 1;
      } else {
         retval += query_ip_name(find_player(name)) + " (" +
            query_ip_number(find_player(name)) + ")\n";
      }
   }
   ob = find_player(name);
   if (ob && (caller >= ob->query_invis() ||
                      (this_player() &&
                       reference_allowed (ob, this_player())))) {
      if (interactive(ob)) {
         retval += "Idle for " + time_elapsed_string(query_idle(ob)) + ".\n";
         need_new = 0;
      } else {
         retval += "Net dead.\n";
         need_new = 0;
      }
   }
   if (need_new)
      retval += "\n";
   retval += (string) MAILER->finger_mail(name);
   tmp = PLAYER_HANDLER->query_project(name);
   if(no_colour || !user_colour) {
     tmp = strip_colours(tmp);
     tmp = replace(tmp, "%^", " ");
   }
   if (tmp && tmp != "") {
      if (strsrch(tmp, "%^") != -1)
         used_colour = 1;
      retval += "%^BOLD%^Project:%^EBOLD%^\n" + tmp + "\n%^RESET%^";
   } else
      retval += "No project.\n";
   tmp = PLAYER_HANDLER->query_plan(name);
   if(no_colour || !user_colour) {
     tmp = strip_colours(tmp);
     tmp = replace(tmp, "%^", " ");
   }
   if (tmp && tmp != "") {
      if (strsrch(tmp, "%^") != -1)
         used_colour = 1;
      retval += "%^BOLD%^Plan:%^EBOLD%^\n" + tmp + "\n%^RESET%^";
   } else
      retval += "No plan.\n";
   if (used_colour)
      retval += "%^RESET%^%^BOLD%^---  End of finger ---%^EBOLD%^\n";
   return retval;
}
public mixed *remote_finger(string name) {
   mixed *retval;
   object ob;
   string cname;
   if (!strlen(name) || !PLAYER_HANDLER->test_user(name))
      return 0;
   ob = find_player(name);
   cname = PLAYER_HANDLER->query_cap_name(name);
   if (!cname) {
      cname = capitalize(name);
   }
   retval = allocate(9);
   retval[0] = cname;
   retval[1] = cname;
   retval[0] = cname;
   retval[1] = cname;
   retval[2] = (PLAYER_HANDLER->test_real_name(name) ?
                PLAYER_HANDLER->test_real_name(name) : "???");
   retval[3] = "0";
   retval[4] = (ob && !ob->query_invis() ? ctime(ob->query_last_log_on()) :
                capitalize(time_elapsed_string(time() -
                                    PLAYER_HANDLER->test_last(name))));
   retval[5] = (ob && !ob->query_invis() ? query_idle(ob) : -1);
   retval[6] = 0;
   retval[7] = 0;
   retval[8] = get_additional_info(name, 1, 0, 80, 0);
   return retval;
}
private string link_name(string name) {
   return "<a href=\"finger.c?player="+ name +"\">"+ capitalize(name) + "</a>";
}
string domain_finger(string name,
                     int width,
                     int www)
{
   string ret;
   string master;
   string *members;
   string *deputies;
   string idle_str;
   int i;
   string projects;
   master = "/d/" + name + "/master";
   if (!stringp(ret = master->generate_string())) {
      ret = "%^BOLD%^The domain of " + capitalize(name) + ".\n";
      ret += "The leader for this domain is " +
         (www?
          link_name((string) master->query_lord()) + ".\n":
          capitalize((string) master->query_lord()) + ".\n");
      members = master->query_members();
      deputies = master->query_deputies();
      if (deputies && sizeof(deputies)) {
         if (sizeof(deputies) > 1) {
            ret += "The deputies for the domain are ";
         } else {
            ret += "The deputy for the domain is ";
         }
         if(www) {
            ret +=
               query_multiple_short(map(deputies, (: link_name($1) :)));
         } else {
            ret +=
               query_multiple_short(map(deputies, (: capitalize($1) :)));
         }
         ret += ".\n";
      }
      ret += "%^EBOLD%^";
      ret += "The current members of this domain are :\n";
      projects = "";
      if(www) {
         ret +=
            "<table cols=\"2\" rules=\"none\""
            "border=\"0\" width=\"100%\">";
      }
      for (i = 0; i < sizeof(members); i++) {
         if (master->query_deputy(members[i])) {
            projects = "[deputy] " + master->query_project(members[i]) + "\n";
         } else {
            projects = master->query_project(members[i]) + "\n";
         }
         if(www) {
            ret += "<tr> <td>"+ link_name(members[i]) +
               "</td> <td>"+ projects +"</td> <tr>";
         } else {
            ret += sprintf("%-=12s %-=*s",
                           capitalize(members[i]), width - 14, projects);
         }
      }
      if(www) {
         ret += "</table>";
      }
   }
   if (master->query_info()) {
      ret += sprintf("%-=*s", width, (string) master->query_info());
   }
   if ( ( idle_str = master->query_idle_mess() ) ) {
       ret += idle_str;
   }
   else {
       ret += "It hasn't been idle, it just hasn't had a lunch break in "
        "years.\n";
   }
   return ret;
}
string club_finger(string name)
{
   return club_info_string(name, 0, "gumball lord");
}
string family_finger(string name)
{
   return family_info_string(name, "gumball lord");
}
string deity_finger(string name)
{
   return 0;
}
private string other_finger(string name,
                            int no_colour,
                            int user_colour,
                            int width,
                            int caller,
                            int www)
{
   if (member_array(name, "/secure/master"->query_domains()) != -1) {
      return domain_finger(name, width, www);
   }
   if (file_size("/save/deities/" + name + ".o") > 0 ||
       file_size("/save/deities/" + name + ".o.gz") > 0) {
      return deity_finger(name);
   }
   if (name[0..4] == "club ") {
      if (CLUB_HANDLER->is_club(name[5..]) &&
          !CLUB_HANDLER->is_family(name[5..])) {
         return club_finger(name[5..]);
      }
   } else if (name[0..6] == "domain ") {
      if (member_array(name[7..], "/secure/master"->query_domains()) != -1) {
         return domain_finger(name[7..], width, www);
      }
   } else if (name[0..6] == "family ") {
      if (CLUB_HANDLER->is_family(name[7..])) {
         return family_finger(name[7..]);
      }
   } else if (CLUB_HANDLER->is_club(name)) {
      if (CLUB_HANDLER->is_family(name)) {
         return family_finger(name);
      } else {
         return club_finger(name);
      }
   }
   if (file_size("/banish/" + name[0..0] + "/" + name + ".o") > 0) {
      return banish_finger(name, caller);
   }
   return 0;
}
private string internal_finger_info(string name,
                                    int no_colour,
                                    int user_colour,
                                    int width,
                                    int caller,
                                    int www)
{
   string retval,
     tmp,
     tmp2;
   int i;
   int days_left;
   mixed *suspended, *lockedout;
   if (!find_player(name) && !PLAYER_HANDLER->test_user(name)) {
      return other_finger(name, no_colour, user_colour, width, caller, www);
   }
   retval = (no_colour ? "" : "%^BOLD%^") +
      sprintf("%*-sReal name : %*-=s\n", (width - 2) / 2,
              "Login name : " +
              strip_colours(PLAYER_HANDLER->query_cap_name(name) + "<br>"),
              (width - 2) / 2 - 12,
              (PLAYER_HANDLER->test_real_name(name) ?
               htmlise(strip_colours(PLAYER_HANDLER->test_real_name(name)[0..30])) :
               "???"));
   tmp = PLAYER_HANDLER->test_email(name);
   tmp2 = PLAYER_HANDLER->test_birthday(name);
   if ( strlen( tmp ) ) {
     if(tmp[0] == ':' || www ||
        PLAYER_HANDLER->test_last( name ) + NO_EMAIL_TIME < time()) {
       if(caller == 0) {
         tmp = "";
       }
     }
   }
   if (tmp) {
      tmp = htmlise(tmp);
      if (tmp2 && tmp2 != UNKNOWN_BIRTHDAY) {
         tmp2 = htmlise(tmp2);
         retval += sprintf("%*-sEmail : %*-=s\n", (width - 2) / 2,
                           "Birthday : " + tmp2 + "<br>", (width - 2) / 2,
                           tmp);
      } else {
         retval += sprintf("Email : %-*s\n", (width - 2) / 2 - 8, tmp[0..30]);
      }
   } else if (tmp2 && tmp2 != UNKNOWN_BIRTHDAY) {
      tmp2 = htmlise(tmp2);
      retval += sprintf("Birthday : %-*s\n", (width - 2) / 2 - 11, tmp2 +
                        "<br>");
   }
   i = PLAYER_HANDLER->test_deleting(name);
   if (i) {
      retval += (no_colour ? "" : "%^RED%^") +
         "This character is marked to be deleted in ";
      if (time() - i > (10 * 60 * 60 * 24)) {
         retval += "1 day.\n";
      } else {
         days_left = (10 - ((time() - i) / (60 * 60 * 24)));
         if (days_left > 1) {
            retval += days_left + " days.\n";
         } else {
           retval += days_left + " day.\n";
         }
      }
      if (!no_colour)
         retval += "%^RESET%^";
   }
   i = PLAYER_HANDLER->test_appealing(name);
   if (i) {
      retval += (no_colour ? "" : "%^RED%^") +
         "This character is marked to be deleted in ";
      if (time() - i > (28 * 60 * 60 * 24)) {
         retval += "1 day";
      } else {
         days_left = (28 - ((time() - i) / (60 * 60 * 24)));
         if (days_left > 1) {
            retval += days_left + " days";
         } else {
           retval += days_left + " day";
         }
      }
      retval += " pending appeal.\n";
      if (!no_colour)
        retval += "%^RESET%^";
   }
   tmp = PLAYER_HANDLER->test_home_dir(name);
   if (tmp)
      retval +=
         sprintf("%*-s", (width - 2) / 2, "Home directory : " + tmp + "<br>");
   tmp = PLAYER_HANDLER->test_guild(name);
   if (tmp) {
      if (catch(retval += "Member of the " + tmp->query_short() + ".\n"))
         retval += "Member of a very broken guild.\n";
   } else
      retval += "Member of the Adventurers' guild.\n";
   if(!no_colour)
     retval += "%^EBOLD%^";
   tmp = PLAYER_HANDLER->test_location(name);
   if (strlen(tmp)) {
      tmp = htmlise(tmp);
      retval += "Location : " + tmp[0..30] + "\n";
   }
   tmp = PLAYER_HANDLER->test_homepage(name);
   if (stringp(tmp)) {
      tmp = htmlise(tmp);
      retval += "Home Page: " + tmp + "\n";
   }
   suspended = "/secure/bastards"->query_suspended(name);
   if (suspended) {
      tmp = capitalize(name) + " has been suspended until " +
         ctime(suspended[SUSPEND_TIME]);
      if (caller) {
         tmp += " for " + suspended[SUSPEND_REASON] + ".\n";
      } else {
         tmp += ".\n";
      }
      retval += "%^YELLOW%^" + sprintf("%s%-=*s", tmp[0..10], width - 11,
                                       tmp[11..]) + "%^RESET%^";
   }
   lockedout = "/secure/bastards"->query_lockedout(name);
   if (lockedout) {
     tmp = capitalize(name) + " is locked out until " +
       ctime(lockedout[SUSPEND_TIME]);
     if (caller) {
       tmp += " because " + lockedout[SUSPEND_REASON] + ".\n";
     } else {
       tmp += ".\n";
     }
      retval += "%^YELLOW%^" + sprintf("%s%-=*s", tmp[0..10], width - 11,
                                       tmp[11..]) + "%^RESET%^";
   }
   retval += htmlise(get_additional_info(name, no_colour, user_colour, width, caller));
   return retval;
}
private string make_html(string str)
{
   int pos;
   pos = strsrch(str, "http:");
   if (pos == -1) {
      str = "http:
   } else {
      str = str[pos..];
   }
   pos = strsrch(str, " ");
   if (pos != -1) {
      str = str[0..pos - 1];
   }
   return str;
}
string finger_info(string name,
                   int no_colour)
{
   int caller,
     width,
     user_colour;
   string retval,
     str;
   string user,
     nick;
   user = this_player()->query_name();
   user_colour = this_player()->query_property(PLAYER_ALLOW_COLOURED_SOULS);
   if (this_player()) {
      nick = (string) this_player()->expand_nickname(name);
      if (nick)
         name = nick;
      width = this_player()->query_cols();
   }
   if (!width) {
      width = 80;
   }
   if (master()->query_director(user)) {
      caller = 3;
   } else if (master()->is_liaison_deputy(user)) {
      caller = 2;
   } else if (PLAYER_HANDLER->test_creator(user)) {
      caller = 1;
   } else {
      caller = 0;
   }
   retval = internal_finger_info(name, no_colour, user_colour,
                                 width, caller, 0);
   if (!retval) {
      return 0;
   }
   foreach(str in keys(REPLACEMENTS)) {
      retval = replace_string(retval, str, REPLACEMENTS[str]);
   }
   return retval;
}
string www_finger_info(string name,
                       string user)
{
   int caller;
   string retval,
     str;
   if (!user || user == "")
      caller = 0;
   else if (master()->query_director(user))
      caller = 3;
   else if (master()->is_liaison_deputy(user))
      caller = 2;
   else if (PLAYER_HANDLER->test_creator(user))
      caller = 1;
   else
      caller = 0;
   retval = internal_finger_info(name, 0, 1, 80, caller, 1);
   if (!retval)
      return 0;
   foreach(str in keys(WWW_REPLACEMENTS))
      retval = replace_string(retval, str, WWW_REPLACEMENTS[str]);
   retval = strip_colours(retval);
   return retval;
}
string refer_info(string name) {
   string retval, nick, tmp, family, rels, area, str;
   object ob;
   int width, sex;
   retval = "";
   width = 80;
   if (this_player()) {
      nick = (string) this_player()->expand_nickname(name);
      width = this_player()->query_cols();
   }
   if (nick) {
      name = nick;
   }
   if (!PLAYER_HANDLER->test_user(name)) {
     retval = other_finger(name, 0, 0, width, 0, 0);
     if(retval)
       foreach(str in keys(REPLACEMENTS))
         retval = replace_string(retval, str, REPLACEMENTS[str]);
     return retval;
   }
   family = "";
   tmp = PLAYER_HANDLER->test_player_title(name);
   if (tmp) {
      tmp += " ";
   } else {
      tmp = "";
   }
   retval = PLAYER_HANDLER->query_cap_name(name);
   if (!retval) {
      return 0;
   }
   tmp = PLAYER_HANDLER->test_family_name(name);
   if (tmp) {
      retval += " " + tmp;
   }
   if ("/d/liaison/master"->query_member(name)) {
      retval += " (%^YELLOW%^Liaison%^RESET%^)";
   } else if (PLAYER_HANDLER->test_creator(name)) {
      if ("/secure/master"->query_trustee(name)) {
         retval += " (%^RED%^Trustee%^RESET%^)";
      } else if ("/secure/master"->query_director(name)) {
         retval += " (%^RED%^Director%^RESET%^)";
      } else if ("/secure/master"->query_senior(name)) {
         retval += " (%^RED%^Senior%^RESET%^)";
      } else {
         retval += " (%^RED%^Creator%^RESET%^)";
      }
   }
   ob = find_player(name);
   if (ob) {
      if (tmp = (string) ob->query_gtitle()) {
         retval += " " + tmp;
      } else {
         retval += " the Adventurer";
      }
      if (tmp = (string)ob->query_property("player_title")) {
         retval += ", " + tmp;
      }
      tmp = (string) ob->query_title();
      if (tmp && tmp != "") {
         retval += ", " + tmp;
      }
   }
   if (PLAYTESTER_HAND->query_playtester(name)) {
     if (PLAYTESTER_HAND->query_senior_playtester(name)) {
       retval += ", (%^BOLD%^%^CYAN%^Senior Playtester%^RESET%^)";
     } else {
       retval += ", (%^CYAN%^Playtester%^RESET%^)";
     }
   }
   if(ob) {
     retval += ".";
      if(ob->query_nationality_name()) {
        retval += "\n" + capitalize(ob->query_possessive()) +
          " nationality is " + capitalize(ob->query_nationality_name());
        if(ob->query_nationality_region())
          retval += " and " + ob->query_pronoun() + " is from "+
            capitalize(ob->query_nationality_region());
        retval +=  ".\n";
      }
   } else {
      retval += " (not currently logged in)\n";
   }
   tmp = PLAYER_HANDLER->test_desc(name);
   if (tmp && tmp != "") {
     if(!this_player()->query_property(PLAYER_ALLOW_COLOURED_SOULS))
       tmp = strip_colours(tmp);
      sex = PLAYER_HANDLER->test_gender(name);
      if (sex == 1) {
         retval += "He " + tmp + "\n";
      } else if (sex == 2) {
         retval += "She " + tmp + "\n";
      } else {
         retval += "It " + tmp + "\n";
      }
   } else {
      retval += "No description.\n";
   }
   foreach(area in NOMIC_HANDLER->query_citizenship_areas()) {
      if (NOMIC_HANDLER->is_magistrate_of(area, name)) {
         retval += "Magistrate in " + area + ".\n";
      } else if (NOMIC_HANDLER->is_citizen_of(area, name)) {
         retval += "Citizen in " + area + ".\n";
      }
   }
   rels = "/std/basic/club_listing"->player_relationships_string(name);
   if (rels != "") {
      retval += PLAYER_HANDLER->query_cap_name(name) + " " +
         PLAYER_HANDLER->test_family(name) + " is the " + rels + "\n";
   }
   if(PLAYER_HANDLER->test_player_killer(name)) {
     retval += PLAYER_HANDLER->query_cap_name(name) + " is a player killer.\n";
   }
   tmp = PLAYER_HANDLER->query_reference(name);
   if(!this_player()->query_property(PLAYER_ALLOW_COLOURED_SOULS))
     tmp = strip_colours(tmp);
   if (tmp && tmp != "") {
      retval += "\n" + tmp + "\n%^RESET%^";
      if (strsrch(tmp, "%^") != -1) {
         retval += "--- End of Reference --\n";
      }
   } else {
      retval += "No reference.\n";
   }
   return retval;
}

==================================================
FILE: force.c
==================================================

#include <obj_parser.h>
#define FORCE_COST 1
#define ILLEGAL_FORCE ({ "alias", "unalias", "mv", "mkdir", "call", "rm", \
                         "force", "kill", "gauge", "exec", "promote", \
                         "new_domain", "rmdir", "cd", "history", "echoall", "shout" })
nosave string fname;
nosave int no_force_me;
void force_commands() {
  sscanf(file_name(this_object()), "%s#", fname);
  if(!this_object()->query_property("npc") &&
     this_object()->query_property("force") || fname == "/global/lord")
    add_action("do_force", "force");
  if(fname == "/global/lord")
    add_action("no_force", "noforce");
}
protected int no_force(string str) {
  if(fname!="/global/lord")
    return 0;
  if(str == "on") {
    no_force_me = 1;
    write("Ok.\n");
    return 1;
  }
  if(str == "off") {
    no_force_me = 0;
    write("Ok.\n");
    return 1;
  }
  write("Forcing you is currently ");
  if(no_force_me) {
    write("disabled.\n");
  }
  else {
    write("enabled.\n");
  }
  return 1;
}
int do_force(string str) {
  string who, what;
  object *obs, ob;
  int i;
  class obj_match omatch;
  if(fname == "/global/player" && !this_player()->query_property("force")) {
    notify_fail("You do not have the ability to do that yet.\n");
    return 0;
  }
  if(!str || sscanf(str, "%s %s", who, what) != 2) {
    notify_fail("Usage : force <person> <command>\n");
    return 0;
  }
  if(this_player()->adjust_social_points(-FORCE_COST) < 0) {
    notify_fail("Insufficient social points.\n");
    return 0;
  }
  who = (string)this_player()->expand_nickname(who);
  who = lower_case(who);
  omatch = match_objects_in_environments(who, environment(this_object()));
  if (omatch->result != OBJ_PARSER_SUCCESS) {
    notify_fail(match_objects_failed_mess(omatch));
    return 0;
  }
  obs = omatch->objects;
  if (!sizeof(obs))
    if (!(ob = find_living(who))) {
      notify_fail("No such living thing.\n");
      return 0;
    } else
      obs += ({ ob });
  for (i=0;i<sizeof(obs);i++)
    if(!obs[i]->do_force_on_me(what))
      write(capitalize(who) + " didn't want to do that.\n");
  write("Ok.\n");
  return 1;
}
int do_force_on_me  (string str) {
  string temp1, temp2;
  object forcer;
  forcer = this_player(1);
  if(!forcer) {
    forcer = previous_object();
  }
  if(!this_object()->query_property("npc")) {
    log_file("FORCE", ctime(time()) + " " + forcer->query_name() + " " +
                      this_object()->query_name() + " : " + str);
  }
  tell_object(this_object(), forcer->query_cap_name() +
        " tries to force you to " + str + "\n");
  if (no_force_me || (string)this_object()->query_name() == "pinkfish") {
    log_file("FORCE", " (failed)\n");
    return 0;
  }
  if(!sscanf(str, "%s %s", temp1, temp2)) {
    temp1 = str;
  }
  if (member_array(temp1, ILLEGAL_FORCE) != -1 &&
      !"secure/master"->high_programmer(geteuid(forcer))) {
    log_file("FORCE", " (failed)\n");
    return 0;
  }
  command(str);
  log_file("FORCE", " (succeeded)\n");
  return 1;
}

==================================================
FILE: ftp_auth.c
==================================================

#include <network.h>
#include <login_handler.h>
#include <playtesters.h>
#define BASTARDS "/secure/bastards"
#define MAX_LIFE 36000
inherit SERVER;
class ftp_session {
  int fd;
  string token;
  int timestamp;
  string user;
}
private mapping Sockets;
protected void create() {
  server::create();
  SetSocketType(STREAM);
  SetDestructOnClose(1);
  Sockets = ([]);
  call_out("setup", 2);
  call_out("clean_sockets", 3600);
}
protected void setup() {
  if (eventCreateSocket(PORT_FTPAUTH) < 0) {
    if (this_object()) {
      destruct(this_object());
    }
  }
}
protected void eventNewConnection(int fd) {
  class ftp_session sess;
  string address, host;
  server::eventNewConnection(fd);
  address = socket_address(fd);
  if ((sscanf(address, "%s %*d", host) != 2) || (host != "127.0.0.1")) {
    eventWrite(fd, "", 1);
    return;
  }
  sess = new(class ftp_session, fd : fd);
  Sockets[fd] = sess;
}
protected string get_path(string str) {
  string *array, *array1;
  int i;
  if (str == "/")
    return "/";
  array = explode(str, "/") - ({ "" });
  array1 = ({ });
  for (i = 0; i < sizeof(array); i++) {
    if (array[i] == "..") {
      if (sizeof(array1)) {
        array1 = array1[0..<2];
      }
    } else if (array[i] != ".") {
      array1 += ({ array[i] });
    }
  }
  if (sizeof(array1))
    str = implode(array1, "/");
  else
    str = "";
  return "/" + str;
}
protected void eventRead(int fd, string str) {
  class ftp_session sess = Sockets[fd];
  string name, rest, ret, token, type, path;
  int timestamp;
  if (!sess) {
    eventWrite(fd, "DENIED\n", 1);
    return;
  }
  if (str == "mudname") {
    eventWrite(fd, sprintf("OKAY: %s\n", mud_name()));
    return;
  }
  if (sscanf(str, "%s %s", name, rest) != 2) {
    eventWrite(fd, "Syntax error\n", 1);
    return;
  }
  name = lower_case(name);
  if (rest == "request login" ||
      rest == "request login playtester") {
    int anon = 0;
    if (name == "ftp") {
        anon = 1;
    }
    if (rest == "request login") {
       if (!(anon || PLAYER_HANDLER->test_creator(name))) {
         eventWrite(fd, "DENIED\n");
         return;
       }
    } else {
       if (!anon &&
           !PLAYTESTER_HAND->query_playtester(name) &&
           !PLAYER_HANDLER->test_creator(name)) {
         eventWrite(fd, "DENIED invalid\n");
         return;
       }
    }
    if ( BASTARDS->query_suspended( name ) ) {
      eventWrite(fd, "DENIED suspended\n");
      return;
    }
    timestamp = time();
    token = crypt("" + timestamp, "" + random(12000));
    sess->token = token;
    sess->timestamp = timestamp;
    sess->user = name;
    if (anon) {
      ret = sprintf("OKAY: %s * /pub\n", token);
    } else {
      ret = sprintf("OKAY: %s %s /w/%s\n", token,
                    PLAYER_HANDLER->get_password(name), name);
    }
    eventWrite(fd, ret);
    return;
  }
  if (sscanf(rest, "%s %s %s", token, type, path) != 3) {
    eventWrite(fd, "Syntax error\n", 1);
    return;
  }
  if ((token != sess->token) || ((time() - sess->timestamp) > MAX_LIFE)) {
    eventWrite(fd, "DENIED\n");
    return;
  }
  path = get_path(path);
  switch (type) {
  case "read":
    if (file_size(path) == -2) {
      path += "
protected void eventSocketClosed(int fd) {
  class ftp_session sess = Sockets[fd];
  if (!sess) {
    return;
  }
  map_delete(Sockets, fd);
}
protected void clean_sockets() {
  class ftp_session sess;
  foreach (sess in values(Sockets)) {
    if (!sess->timestamp) {
      sess->timestamp = time();
      continue;
    }
    if (time() - sess->timestamp > MAX_LIFE) {
      eventWrite(sess->fd, "Timeout\n", 1);
    }
  }
  call_out("clean_sockets", 3600);
}
string *query_connections() {
  class ftp_session val;
  string *list;
  list = ({ });
  foreach (val in values(Sockets)) {
    if (val->user) {
      list += ({ capitalize(val->user) });
    } else {
      list += ({ "login" });
    }
  }
  return list;
}

==================================================
FILE: ftpd.c
==================================================

#include <network.h>
inherit SERVER;
#include <ftp.h>
#include <localtime.h>
#include <player_handler.h>
#define DELAY_LOG_FLUSH 5
private nosave mapping socket_info, data_sockets;
private nosave mapping _log_file_info = ([ ]);
private nosave int _log_file_flush_id;
protected void create() {
  server::create();
  seteuid("Root");
  socket_info = ([]);
  data_sockets = ([]);
  SetSocketType(STREAM);
  write(mud_name() + "\n");
  if(mud_name() != "Discworld")
    call_out("setup_ftp", 2);
  else
    destruct(this_object());
}
private void flush_log_files() {
  string fname;
  string data;
  _log_file_flush_id = 0;
  foreach (fname, data in _log_file_info) {
      map_delete(_log_file_info, fname);
      unguarded((: write_file, fname, data :));
   }
   _log_file_info = ([ ]);
}
void log_write(string name, string fmt, mixed *args ...) {
    if (!_log_file_flush_id) {
     _log_file_flush_id = call_out((: flush_log_files :), DELAY_LOG_FLUSH);
  }
  if (!_log_file_info[name]) {
     _log_file_info[name] = "";
  }
  if (sizeof(args)) {
    _log_file_info[name] += sprintf(fmt, args ...);
  } else {
    _log_file_info[name] += fmt;
  }
}
protected void setup_ftp() {
  int x;
  if ((x = eventCreateSocket(FTP_PORT)) < 0) {
    if (this_object()) destruct(this_object());
    return;
  }
  call_out("check_connections", 5*60);
}
string *query_connections() {
  class session *vals, val;
  string *list;
  list = ({ });
  vals = (class session *)values(socket_info);
  foreach (val in vals) {
    if (val->user_name) {
      if (val->logged_in) {
        list += ({ capitalize(val->user_name) });
      } else {
        list += ({ "login" });
      }
    }
  }
  return list;
}
protected string ls(string path, int mask) {
   string *files, tmp, tmp2, creator, domain;
   int i, j, s, current_time;
   mixed *xfiles, *stats;
#ifdef DEBUG
    TP(sprintf("ls(%s,%d)\n",path,mask));
#endif
   if (!(mask & MASK_D) && file_size(path) == -2) {
      if (path[ <1 ] == '/')
         path += "*";
      else
         path += "
   if (!(MASK_L & mask)) {
      files = get_dir(path);
      if (!files)
         return "";
      if (!(MASK_A & mask))
         files -= ({ ".", ".." });
      if (!(i = sizeof( files )))
         return "";
      if (strsrch(path, '*') == -1 && strsrch(path, '?') == -1) {
         return files[0] + "\n";
      }
      j = strsrch(path, '/', -1);
      path = path[0..j];
      while (i--) {
         tmp = sprintf("%s%s/", path, files[i]);
         if (MASK_F & mask) {
            if (strsrch(tmp, "/./") != -1 || strsrch(tmp, "/../") != -1) {
               files[i] += "/";
               continue;
            }
            if (file_size(tmp) == -2)
               files[i] += "/";
            else if (stat(tmp[0..<2])[2])
               files[i] += "*";
         }
      }
      if (MASK_C & mask)
         return sprintf("%-#70s\n", implode(files, "\n"));
      else
         return implode(files, "\n") + "\n";
   }
   if (!(MASK_R & mask)) {
      xfiles = get_dir(path, -1);
      if (!(mask & MASK_A))
         xfiles = filter_array(xfiles, "check_dots", this_object());
      if (!xfiles || !(s = sizeof( xfiles )))
         return "total 0\n";
      files = allocate(s);
      creator = (string)master()->author_file(path);
      if (!creator) {
         creator = "Root";
      }
      domain = (string)master()->domain_file(path);
      if (!domain) {
         domain = "Root";
      }
      i = strsrch(path, '/', -1);
      if (i >= 0)
         path = path[0..i];
      current_time = time();
      for (i = 0; i < s; i++) {
         tmp2 = ctime((xfiles[i])[2]);
         if ((xfiles[i])[2] + (6 * 30 * 24 * 60 * 60) < current_time ||
             (xfiles[i])[2] - (60 * 60) > current_time ) {
            tmp = sprintf("%s  %s", tmp2[4..9], tmp2[20..23]);
         } else {
            tmp = tmp2[4..15];
         }
         j = (xfiles[i])[1];
         if (j == -2) {
            files[i] = sprintf("drwxrwxr-x   0 %-8s %-8s        0 %12s %s",
                               creator, domain, tmp,
                               (xfiles[i])[0]+((MASK_F & mask)?"/":""));
         } else {
            stats = stat(path + (xfiles[i])[0]);
            files[i] = sprintf("-rw%crw-r--   1 %-8s %-8s %8d %12s %s",
                               sizeof(stats) > 1 && stats[2] ? 'x' : '-',
                               creator, domain, j, tmp,
                               (xfiles[i])[0] + (sizeof(stats) > 1 && stats[2] &&
                                                 (MASK_F & mask)?"*":""));
         }
      }
      return sprintf("total %i\n",s)+implode(files, "\n")+"\n";
   }
   if( path[<1 .. <1] != "*" )
      return ls( path, (mask & ~MASK_R) );
   path = path[ 0 .. <3 ];
   files = ({ "" });
   tmp = "";
   while( sizeof( files ) ) {
      reset_eval_cost();
      if( files[ 0 ] == "" )
         tmp += ls( path + "
            if ((j == -2) && (xfiles[i][0] != ".") && (xfiles[i][0] != "..")) {
               files += ({ files[ 0 ] +"/"+ xfiles[i][0] });
            }
         }
      }
      files = files[ 1 .. <1 ];
   }
   return tmp;
}
protected void data_conn(int fd, string mess, string name, int type) {
   int new_fd, ret, data_mode;
   string data_mode_name, addr;
   class session sess = (class session)socket_info[fd];
   class dataconn t;
  if (type == STRING || (type == FILE && sess->type == STRING)) {
    data_mode_name = "ASCII";
    data_mode = STREAM;
  } else {
    data_mode_name = "BINARY";
    data_mode = STREAM_BINARY;
  }
  t = new(class dataconn);
  t->path = name;
  t->data = (type == STRING ? replace_string(mess, "\n", "\r\n") : mess);
  t->pos = sess->offset;
  t->parent_fd = fd;
  t->type = type;
  t->len = (type == STRING ? strlen(mess) : file_size(mess));
  if (sess->pasv_fd != -1) {
    if (sess->pasv_cb) {
      TP("Accepting after delay...\n");
      new_fd = socket_accept(sess->pasv_fd, "data_read_callback",
                             "data_write_callback");
      if (new_fd < 0) {
        eventWrite(fd, "425 Can't open data connection.\r\n");
        socket_close(sess->pasv_fd);
        sess->pasv_fd = -1;
        return;
      }
      socket_close(sess->pasv_fd);
      sess->pasv_fd = new_fd;
    } else {
      TP("No connection yet...\n");
      data_sockets[sess->pasv_fd] = t;
      return;
    }
  } else {
    sess->use_default = 1;
    if (sess->data_fd != -1) {
      eventWrite(fd, "425 Can't open data connection.\r\n");
      return;
    }
    new_fd = socket_create(data_mode, "data_read_callback",
                           "data_close_callback");
    if (new_fd < 0) {
      eventWrite(fd, "425 Can't create data socket.\r\n");
      return;
    }
    if (!sess->data_addr) {
      eventWrite(fd, "425 Can't open data connection.\r\n");
      socket_close(new_fd);
      return;
    }
    sscanf(socket_address(fd, 1), "%s %*d", addr);
    addr = sprintf("%s %d", addr, (FTP_PORT - 1));
    TP(sprintf("socket_bind(%d, 0, %s)\n", new_fd, addr));
    if ((ret = socket_bind(new_fd, 0, addr)) < 0) {
      eventWrite(fd, sprintf("425 Can't build data connection: %s.\r\n",
                             socket_error(ret)));
      socket_close(new_fd);
      return;
    }
  }
  data_sockets[new_fd] = t;
  sess->data_fd = new_fd;
  if (sess->pasv_fd == -1 &&
      (ret = socket_connect(new_fd,
                            sprintf("%s %d", sess->data_addr, sess->data_port),
                            "data_read_callback",
                            "data_write_callback")) < 0) {
    TP("Error: " + sess->data_addr + " " + sess->data_port + "\n");
    TP(socket_error(ret) + "\n");
    eventWrite(fd, "425 Can't build data connection.\r\n");
    sess->data_fd = -1;
    socket_close(new_fd);
    map_delete(data_sockets, new_fd);
    return;
  }
  eventWrite(fd, sprintf("150 Opening %s mode data connection for %s "
                         "(%d bytes).\r\n", data_mode_name, name, t->len));
  if (sess->pasv_fd != -1)
    data_write_callback(new_fd);
}
protected void read_connection(int fd, string path, int append) {
  int new_fd, ret, data_mode;
  string data_mode_name, opath, addr;
  class dataconn t;
  class session sess = (class session)socket_info[fd];
  if (sess->type == BINARY) {
    data_mode_name = "BINARY";
    data_mode = STREAM_BINARY;
  } else {
    data_mode_name = "ASCII";
    data_mode = STREAM;
  }
  opath = path;
  if (append != 1) {
    path = path + ".ftptmp";
    if (file_size(path) > -1)
      catch(rm(path));
  }
  t = new(class dataconn);
  t->path = path;
  t->parent_fd = fd;
  t->pos = (!append?0:(file_size(opath)==-1?0:file_size(opath)));
  t->type = DOWNLOAD;
  t->append = append;
  if (sess->pasv_fd != -1) {
    if (sess->pasv_cb) {
      new_fd = socket_accept(sess->pasv_fd, "data_read_callback",
                             "data_write_callback");
      if (new_fd < 0) {
        eventWrite(fd, "425 Can't open data connection.\r\n");
        socket_close(sess->pasv_fd);
        sess->pasv_fd = -1;
        return;
      }
      socket_close(sess->pasv_fd);
      sess->pasv_fd = new_fd;
    } else {
      data_sockets[sess->pasv_fd] = t;
      return;
    }
  } else {
    sess->use_default = 1;
    if (sess->data_fd != -1) {
      eventWrite(fd, "425 Can't open data connection.\r\n");
      return;
    }
    new_fd = socket_create(data_mode, "data_read_callback",
                           "data_close_callback");
    if (new_fd < 0) {
      eventWrite(fd, "425 Can't create data socket.\r\n");
      return;
    }
    sscanf(socket_address(fd, 1), "%s %*d", addr);
    addr = sprintf("%s %d", addr, (FTP_PORT - 1));
    TP(sprintf("socket_bind(%d, 0, %s)\n", new_fd, addr));
    if ((ret = socket_bind(new_fd, 0, addr)) < 0) {
      eventWrite(fd, sprintf("425 Can't build data connection: %s.\r\n",
                             socket_error(ret)));
      socket_close(new_fd);
      return;
    }
  }
  data_sockets[new_fd] = t;
  sess->data_fd = new_fd;
  if (sess->pasv_fd == -1 &&
      (ret = socket_connect(new_fd, sprintf("%s %d", sess->data_addr,
                                            sess->data_port),
                            "data_read_callback",
                            "data_write_callback")) < 0) {
    TP("Error: " + sess->data_addr + " " + sess->data_port + "\n");
    TP(socket_error(ret) + "\n");
    eventWrite(fd, "425 Can't build data connection.\r\n");
    sess->data_fd = -1;
    socket_close(new_fd);
    map_delete(data_sockets, new_fd);
    return;
  }
  eventWrite(fd, sprintf("150 Opening %s mode data connection for %s.\r\n",
                         data_mode_name, opath));
}
protected void passive(class session sess) {
  int new_fd, ret, data_mode;
  string addr;
  if (sess->pasv_fd != -1) {
    eventWrite(sess->fd, sprintf("227 Entering Passive Mode (%s,%d,%d)\r\n",
                                 replace_string(sess->data_addr, ".", ","),
                                 sess->data_port>>8, sess->data_port & 0xff));
    return;
  }
  if (sess->type == BINARY)
    data_mode = STREAM_BINARY;
  else
    data_mode = STREAM;
  new_fd = socket_create(data_mode, "data_read_callback",
                         "data_close_callback");
  if (new_fd < 0) {
    eventWrite(sess->fd, "425 Can't open passive connection.\r\n");
    return;
  }
  sscanf(socket_address(sess->fd, 1), "%s %*d", addr);
  addr = sprintf("%s %d", addr, 0);
  TP(sprintf("socket_bind(%d, 0, %s)\n", new_fd, addr));
  if ((ret = socket_bind(new_fd, 0, addr)) < 0) {
    eventWrite(sess->fd, "425 Can't open passive connection.\r\n");
    socket_close(new_fd);
    return;
  }
  if ((ret = socket_listen(new_fd, "data_listen_callback")) < 0) {
    eventWrite(sess->fd, "425 Can't open passive connection.\r\n");
    socket_close(new_fd);
    return;
  }
  data_sockets[new_fd] = new(class dataconn, parent_fd : sess->fd);
  sess->pasv_fd = new_fd;
  sscanf(socket_address(new_fd, 1), "%s %d", sess->data_addr, sess->data_port);
  eventWrite(sess->fd, sprintf("227 Entering Passive Mode (%s,%d,%d)\r\n",
                               replace_string(sess->data_addr, ".", ","),
                               sess->data_port>>8, sess->data_port & 0xff));
}
protected void data_listen_callback(int fd) {
  class dataconn dc = (class dataconn)data_sockets[fd];
  class session sess;
  int new_fd;
  string data_mode_name;
  if (!classp(dc)) {
    socket_close(fd);
    return;
  }
  map_delete(data_sockets, fd);
  sess = (class session)socket_info[dc->parent_fd];
  if (!classp(sess)) {
    socket_close(fd);
    return;
  }
  if (dc->type) {
    TP("Accepting...\n");
    if (sess->type == BINARY)
      data_mode_name = "BINARY";
    else
      data_mode_name = "ASCII";
    new_fd = socket_accept(fd, "data_read_callback", "data_write_callback");
    if (new_fd < 0) {
      eventWrite(sess->fd, "425 Can't open data connection.\r\n");
      socket_close(fd);
      sess->pasv_fd = -1;
      return;
    }
    socket_close(fd);
    sess->pasv_fd = new_fd;
    sess->data_fd = new_fd;
    data_sockets[new_fd] = dc;
    if (dc->type == DOWNLOAD)
      eventWrite(sess->fd,
                 sprintf("150 Opening %s mode data connection for %s.\r\n",
                         data_mode_name, dc->path[0..<8]));
    else {
      eventWrite(sess->fd,
                 sprintf("150 Opening %s mode data connection for %s "
                         "(%d bytes).\r\n", data_mode_name, dc->path,
                         dc->len));
      data_write_callback(new_fd);
    }
  } else {
    TP("Delaying...\n");
    sess->pasv_cb = 1;
    return;
  }
}
protected void data_read_callback(int fd, mixed mess) {
  int pfd;
  class dataconn dcon = (class dataconn)data_sockets[fd];
  class session sess;
  if (dcon->type != DOWNLOAD)
    return;
  pfd = dcon->parent_fd;
  if (undefinedp((sess = (class session)socket_info[pfd])))
    return;
  sess->last_data = time();
  if (stringp(mess))
    mess = replace_string(mess, "\r", "");
#ifdef DEBUG_RECEIVE
   TP("received from " + dcon->pos + " size " +
      (stringp(mess)?strlen(mess):sizeof(mess)) + ".\n");
#endif
  write_buffer(dcon->path, dcon->pos, mess);
  dcon->pos += (stringp(mess)?strlen(mess):sizeof(mess));
}
void data_close_callback(int fd) {
  int pfd;
  class session sess;
  class dataconn dcon = (class dataconn)data_sockets[fd];
  if (!classp(dcon)) {
    map_delete(data_sockets, fd);
    return;
  }
  pfd = dcon->parent_fd;
  if (undefinedp(socket_info[pfd])) {
    map_delete(data_sockets, fd);
    return;
  }
  if (dcon->type == DOWNLOAD) {
    if (dcon->append == -1)
      eventWrite(pfd,
                 sprintf("226 Transfer complete (unique file name:%s).\r\n",
                         dcon->path));
    else if (dcon->append) {
      eventWrite(pfd, "226 Transfer complete.\r\n");
    } else {
      eventWrite(pfd, "226 Transfer complete.\r\n");
      catch(rm(dcon->path[0..<8]));
      catch(rename(dcon->path, dcon->path[0..<8]));
    }
  } else if (!dcon->type) {
    map_delete(data_sockets, fd);
    return;
  }
  sess = (class session)socket_info[pfd];
  sess->data_fd = -1;
  sess->pasv_fd = -1;
  sess->offset = 0;
  map_delete(data_sockets, fd);
#ifdef DEBUG_RECEIVE
  TP("dcc() complete, exiting.\n");
#endif
}
protected void data_write_callback(int fd) {
  int pfd, pos, ret_val;
  mixed tmp;
  class dataconn dcon = (class dataconn)data_sockets[fd];
  class session sess;
  if (dcon->type == DOWNLOAD)
    return;
  pos = dcon->pos;
  pfd = dcon->parent_fd;
  if (undefinedp(socket_info[pfd]))
    return;
  sess = (class session)socket_info[pfd];
  sess->last_data = time();
  if (pos > dcon->len || dcon->len == 0) {
    TP("pos > len\n");
    eventWrite(pfd, "226 Transfer complete.\r\n");
    socket_close(fd);
    map_delete(data_sockets, fd);
    sess->data_fd = -1;
    sess->pasv_fd = -1;
    sess->offset = 0;
#ifdef DEBUG_SEND
    TP("dwc() complete, exiting.\n");
#endif
    return;
  }
#ifdef DEBUG_SEND
  TP("Entering dwc(), pos: " + pos + " length should be: " + BLOCK_SIZE + ".\n");
#endif
  if (dcon->type == STRING) {
#ifdef DEBUG_SEND
    TP("type == STRING\n");
#endif
    while ((ret_val = socket_write(fd, dcon->data[pos..(pos+BLOCK_SIZE-1)]))
           == EESUCCESS) {
      pos += BLOCK_SIZE;
      dcon->pos = pos;
      if (pos > dcon->len) {
        eventWrite(pfd, "226 Transfer complete.\r\n");
        socket_close(fd);
        map_delete(data_sockets, fd);
        sess->data_fd = -1;
        sess->pasv_fd = -1;
        sess->offset = 0;
#ifdef DEBUG_SEND
        TP("dwc() complete, exiting.\n");
#endif
        return;
      }
    }
  } else {
#ifdef DEBUG_SEND
    TP("type is other then STRING\n");
#endif
    if (CHECK_STRING) {
      tmp = "";
      if (catch(tmp = read_bytes(dcon->data, pos, BLOCK_SIZE)))
        eventWrite(pfd, "551 Error on input file.\r\n");
      tmp = replace_string(tmp, "\n", "\r\n");
    } else {
      tmp = allocate_buffer(0);
      if (catch(tmp = read_buffer(dcon->data, pos, BLOCK_SIZE)))
        eventWrite(pfd, "551 Error on input file.\r\n");
    }
    while ((ret_val = socket_write(fd, tmp)) == EESUCCESS) {
#ifdef DEBUG_SEND
      TP("sent from " + pos + " to " + (pos + BLOCK_SIZE) + ".\n");
      TP("ret_val was: " + ret_val + ".\n");
#endif
      pos += BLOCK_SIZE;
      dcon->pos = pos;
      if (pos >= dcon->len) {
        eventWrite(pfd, "226 Transfer complete.\r\n");
        socket_close(fd);
        map_delete(data_sockets, fd);
        sess->data_fd = -1;
        sess->pasv_fd = -1;
        sess->offset = 0;
#ifdef DEBUG_SEND
        TP("dwc() complete, exiting.\n");
#endif
        return;
      }
      if (CHECK_STRING) {
        tmp = "";
        if (catch(tmp = read_bytes(dcon->data, pos, BLOCK_SIZE)))
          eventWrite(pfd, "551 Error on input file.\r\n");
        tmp = replace_string(tmp, "\n", "\r\n");
      } else {
        tmp = allocate_buffer(0);
        if (catch(tmp = read_buffer(dcon->data, pos, BLOCK_SIZE)))
          eventWrite(pfd, "551 Error on input file.\r\n");
      }
    }
  }
#ifdef DEBUG_SEND
  TP("ret_val was: " + ret_val + ".\n");
  TP("leaving dwc(), pos: " + pos + ".\n");
#endif
  if (ret_val == EEWOULDBLOCK) {
#ifdef DEBUG_SEND
    TP("Adding call_out\n");
#endif
    call_out("data_write_callback", 1, fd);
  } else if (ret_val == EECALLBACK) {
    dcon->pos += BLOCK_SIZE;
  } else if (ret_val == EEALREADY) {
    return;
  } else {
    while (remove_call_out("data_write_callback") != -1) {
#ifdef DEBUG_SEND
      TP("Killing callout.\n");
#endif
    }
  }
}
protected void logout(int fd) {
  class session sess = (class session)socket_info[fd];
  string name;
  name = sess->user_name;
  user_event( "inform", sprintf("%s logged out of ftpd", "name"), "ftp");
#ifdef LOG_CONNECT
  log_write(LOG_FILENAME,
           sprintf("%s logged out at %s.\n", name, ctime(time())));
#endif
  sess->user_name = sess->logged_in = sess->cwd = 0;
}
protected void eventNewConnection(int fd) {
  class session t;
  server::eventNewConnection(fd);
  t = new(class session);
  t->fd = fd;
  t->user_name = "Login";
  t->idle = 900;
  t->last_data = time();
  t->data_fd = -1;
  t->pasv_fd = -1;
  sscanf(socket_address(fd), "%s %d", t->data_addr, t->data_port);
  t->use_default = 1;
  socket_info[fd] = t;
  eventWrite(fd, sprintf("220 %s FTP server ready.  "
                         "Please login as yourself.\r\n", mud_name()));
}
protected void parse_comm(int fd, string str) {
  string *bits, tmp, cmd, rest, rest2;
  mixed *misc;
  int port, i, mask;
  class session sess;
  if (strsrch(lower_case(str), "pass") == -1) {
    i = 0;
    TP("Parsing " + str + ".\n");
  }
  bits = explode(str, " ");
  cmd = bits[ 0 ];
  if (sizeof( bits ) > 1 )
    rest = implode( bits[1 .. ], " " );
  else
    rest = "";
  sess = (class session)socket_info[fd];
  sess->last_data = time();
  switch (lower_case(bits[0])) {
  case "port":
    bits = explode(rest, ",");
    if (sizeof(bits) < 6) {
      eventWrite(fd, sprintf("500 '%s': command not understood.\r\n", str));
    } else {
      sess->data_addr = implode(bits[0..3], ".");
      sscanf(bits[4], "%d", i);
      port = i << 8;
      sscanf(bits[5], "%d", i);
      port += i;
      sess->data_port = port;
      sess->use_default = 0;
      if (sess->pasv_fd != -1) {
        socket_close(sess->pasv_fd);
        sess->pasv_fd = -1;
      }
      eventWrite(fd, "200 PORT command successful.\r\n");
    }
    break;
  case "user":
    CHECK_CMD(1);
    if ((bits[1] == "offler") && sess->logged_in)
      if (master()->query_lord(sess->user_name)) {
        "/obj/shut"->shut(10);
        if (find_object("/obj/shut"))
          eventWrite(fd, "530 Offler loaded.\r\n");
        else
          eventWrite(fd, "530 Offler failed to load.\r\n");
        break;
      }
    if (sess->logged_in)
      logout(fd);
    if (!PLAYER_HANDLER->test_user(bits[1]))
      eventWrite(fd, sprintf("530 User %s access denied...\r\n", bits[1]));
    else {
      eventWrite(fd, sprintf("331 Password required for %s.\r\n", bits[1]));
      sess->user_name = bits[1];
    }
    break;
  case "pass":
    if (sess->logged_in || !sess->user_name) {
      eventWrite(fd, "503 Login with USER first.\r\n");
      break;
    }
    if (!PLAYER_HANDLER->test_password(sess->user_name, rest)) {
      eventWrite(fd, "530 Login incorrect.\r\n");
      sess->user_name = "Login";
      break;
    } else if (!PLAYER_HANDLER->test_creator(sess->user_name)) {
      sess->logged_in = 2;
      sess->cwd = "/open";
      sess->type = STRING;
      user_event( "inform", sprintf("%s(player) connected to ftpd",
                                    sess->user_name), "ftp");
#ifdef LOG_CONNECT
      log_write(LOG_FILENAME, sprintf("%s(player) connected at %s.\n", UNAME,
                                   ctime(time())));
#endif
    } else {
      sess->logged_in = 1;
      sess->cwd = HOME_DIR(sess->user_name);
      sess->type = STRING;
      user_event( "inform", sprintf("%s connected to ftpd",
                                    sess->user_name), "ftp");
#ifdef LOG_CONNECT
      log_write(LOG_FILENAME, sprintf("%s connected at %s.\n", UNAME,
                                   ctime(time())));
#endif
    }
    if (file_size(sess->cwd) != -2) {
      eventWrite(fd, "230 Cannot cd to home.  Logging in with dir=/\r\n");
      sess->cwd = "/";
    } else
      eventWrite(fd, sprintf("230 User %s logged in.\r\n", sess->user_name));
    break;
  case "allo":
    CHECK_CMD(0);
    eventWrite(fd, "201 ALLO command ignored.\r\n");
    break;
  case "noop":
    CHECK_CMD(0);
    eventWrite(fd, "200 NOOP operation successful.\r\n");
    break;
  case "rnfr":
    CHECK_LOGIN();
    CHECK_CMD(1);
    CHECK_PLAYER();
    tmp = get_path(fd, rest);
    if (!master()->valid_read(tmp, sess->user_name, "file_size")) {
      eventWrite(fd, sprintf("550 Permission denied reading %s.\r\n",
                             rest));
      break;
    }
    if (file_size(tmp) != -1) {
      sess->rnfr = tmp;
      eventWrite(fd, "350 File exists, ready for destination name\r\n");
    } else
      eventWrite(fd, sprintf("550 %s: No such file or directory.\r\n",
                             rest));
    break;
  case "rnto":
    CHECK_LOGIN();
    CHECK_CMD(1);
    CHECK_PLAYER();
    if (!sess->rnfr) {
      eventWrite(fd, "503 Bad sequence of commands.\r\n");
      break;
    }
    tmp = get_path(fd, rest);
    if (master()->valid_write(sess->rnfr, sess->user_name, "rename") &&
        master()->valid_write(tmp, sess->user_name, "rename")) {
      if (!catch(rename(sess->rnfr, tmp)))
        eventWrite(fd, "250 RNTO command successful.\r\n");
      else
        eventWrite(fd, "550 rename: No such file or directory.\r\n");
    } else
      eventWrite(fd, "550 rename: Operation not permitted.\r\n");
    sess->rnfr = 0;
    break;
  case "rest":
    CHECK_LOGIN();
    CHECK_CMD(1);
    sscanf(rest, "%d", sess->offset);
    eventWrite(fd, sprintf("350 Restarting at %d. %s\r\n", sess->offset,
                           "Send STORE or RETRIEVE to initiate transfer."));
    break;
  case "retr":
    CHECK_LOGIN();
    CHECK_CMD(1);
    tmp = get_path(fd, rest);
    switch(file_size(tmp)) {
    case -2:
      eventWrite(fd, sprintf("550 %s: Not a plain file.\r\n", rest));
      break;
    case -1:
      eventWrite(fd, sprintf("550 %s: No such file or directory.\r\n",
                             rest));
      break;
    default:
      if (!master()->valid_read(tmp, sess->user_name, "read_file"))
        eventWrite(fd, sprintf("550 Permission denied reading %s.\r\n",
                               rest));
      else if(tmp != "/" && tmp == "/
    CHECK_LOGIN();
    CHECK_CMD(1);
    CHECK_PLAYER();
    tmp = get_path(fd, rest);
    if (master()->valid_write(tmp, sess->user_name, "rm")) {
      if (file_size(tmp) == -1) {
        eventWrite(fd, sprintf("550 %s: No such file or directory.\r\n",
                               rest));
        break;
      }
#ifdef LOG_FILE
      log_write(LOG_FILENAME, sprintf("%s DELE %s at %s.\n", UNAME, tmp,
                                   ctime(time())));
#endif
      if (!rm(tmp))
        eventWrite(fd, sprintf("550 %s: Directory not empty.\r\n",
                               rest));
      else
        eventWrite(fd, "250 DELE command successful.\r\n");
    } else
      eventWrite(fd, sprintf("550 Permission denied to %s.\r\n", rest));
    break;
  case "mkd":
  case "xmkd":
    CHECK_LOGIN();
    CHECK_CMD(1);
    CHECK_PLAYER();
    tmp = get_path(fd, rest);
    if (master()->valid_write(tmp, sess->user_name, "mkdir")) {
#ifdef LOG_FILE
      log_write(LOG_FILENAME, sprintf("%s MKD %s at %s.\n", UNAME, tmp,
                                   ctime(time())));
#endif
      if (!mkdir(tmp))
        eventWrite(fd, sprintf("550 %s: File exists.\r\n", rest));
      else
        eventWrite(fd, "257 MKD command successful.\r\n");
    } else
      eventWrite(fd, sprintf("550 Permission denied to %s.\r\n", rest));
    break;
  case "rmd":
  case "xrmd":
    CHECK_LOGIN();
    CHECK_CMD(1);
    CHECK_PLAYER();
    tmp = get_path(fd, rest);
    if (master()->valid_write(tmp, sess->user_name, "rmdir")) {
      if (file_size(tmp) == -1) {
        eventWrite(fd, sprintf("550 %s: No such file or directory.\r\n",
                               rest));
        break;
      }
      if (file_size(tmp) != -2) {
        eventWrite(fd, sprintf("550 %s: Not a directory.\r\n", rest));
        break;
      }
      if (!rmdir(tmp))
        eventWrite(fd, sprintf("550 %s: Directory not empty.\r\n",
                               rest));
      else {
#ifdef LOG_FILE
        log_write(LOG_FILENAME, sprintf("%s RMD %s at %s.\n", UNAME, tmp,
                                     ctime(time())));
#endif
        eventWrite(fd, "250 RMD command successful.\r\n");
      }
    } else
      eventWrite(fd, sprintf("550 Permission denied to %s.\r\n", rest));
    break;
  case "appe":
    CHECK_LOGIN();
    CHECK_CMD(1);
    CHECK_PLAYER();
    tmp = get_path(fd, rest);
    if (master()->valid_write(tmp, sess->user_name, "write_file")) {
#ifdef LOG_FILE
      log_write(LOG_FILENAME, sprintf("%s APPE %s at %s.\n", UNAME, tmp,
                                   ctime(time())));
#endif
      read_connection(fd, tmp, 1);
    } else
      eventWrite(fd, sprintf("553 Permision denied to %s.\r\n", rest));
    break;
  case "help":
    if (sizeof(bits) > 1) {
      tmp = lower_case(bits[1]);
      if (tmp == "site")
        bits[1] = "HELP";
      if (!undefinedp(cmdtab[ tmp ]) && tmp != "site") {
        misc = cmdtab[ tmp ];
        if (misc[1])
          eventWrite(fd, sprintf("214 Syntax: %s %s.\r\n", misc[0], misc[2]));
        else
          eventWrite(fd, sprintf("214 %s %s; unimplemented.\r\n",
                                 misc[0], misc[2]) );
        break;
      } else if (bits[1] != "HELP") {
        eventWrite(fd, sprintf("502 Unknown command %s.\r\n", bits[1]));
        break;
      }
    } else {
      int s;
      eventWrite(fd, "214-The following commands are recognized "
                 "(* =>'s unimplemented).\r\n");
      misc = keys(cmdtab);
      s = sizeof(misc);
      tmp = "   ";
      for (i = 0; i < s; i++) {
        tmp += sprintf("%-4s%-4s", cmdtab[misc[i]][0],
                       cmdtab[misc[i]][1] ? " " : "*");
        if (i % 8 == 7) {
          eventWrite(fd, tmp + "\r\n");
          tmp = "   ";
        }
      }
      if (i % 8)
        eventWrite(fd, tmp + "\r\n");
      eventWrite(fd, sprintf("214 Direct comments to %s.\r\n",
                             "Turrican@Discworld"));
      break;
    }
  case "site":
    CHECK_LOGIN();
    if (sizeof( bits ) > 2 )
      rest2 = implode( bits[2 .. ], " " );
    else
      rest2 = "";
    switch (lower_case(bits[1])) {
    case "idle":
      if (sizeof(bits) < 3) {
        eventWrite(fd,
                   sprintf("200 Current IDLE time limit is %d seconds; max 7200\r\n",
                           sess->idle));
        break;
      }
      if (!sscanf(rest2, "%d", i)) {
        eventWrite(fd, "550 SITE IDLE command failed.\r\n");
        break;
      }
      i = (i<300?300:(i>7200?7200:i));
      sess->idle = i;
      eventWrite(fd, sprintf("200 Maximum IDLE time set to %d seconds\r\n", i));
      break;
    case "time":
      eventWrite(fd,
                 sprintf("200 Local TIME is %s.\r\n", ctime(time())[4..15]));
      break;
    case "upd":
      CHECK_CMD(2);
      tmp = get_path(fd, rest2);
      do_update(tmp, fd);
#ifdef LOG_FILE
      log_write(LOG_FILENAME, sprintf("%s UPD %s at %s.\n", UNAME, tmp,
                                   ctime(time())));
#endif
      break;
    case "help":
      if (sizeof(bits) > 2) {
        tmp = lower_case(bits[2]);
        if (!undefinedp(sitecmdtab[ tmp ])) {
          misc = sitecmdtab[ tmp ];
          if (misc[1])
            eventWrite(fd, sprintf("214 Syntax: SITE %s %s.\r\n",
                                   misc[0], misc[2]) );
          else
            eventWrite(fd, sprintf("214 SITE %s %s; unimplemented.\r\n",
                                   misc[0], misc[2]) );
        } else {
          eventWrite(fd, sprintf("502 Unknown command %s.\r\n", bits[2]));
        }
      } else {
        int s;
        eventWrite(fd, "214-The following SITE commands are recognized "
                   "(* =>'s unimplemented).\r\n");
        misc = keys(sitecmdtab);
        s = sizeof(misc);
        tmp = "   ";
        for (i = 0; i < s; i++) {
          tmp += sprintf("%-*s%-*s", strlen(sitecmdtab[misc[i]][0]),                        sitecmdtab[misc[i]][0], 8-strlen(sitecmdtab[misc[i]][0]),
                         sitecmdtab[misc[i]][1] ? " " : "*");
          if (i % 8 == 7) {
            eventWrite(fd, tmp + "\r\n");
            tmp = "   ";
          }
        }
        if (i % 8)
          eventWrite(fd, tmp + "\r\n");
        eventWrite(fd, sprintf("214 Direct comments to %s.\r\n",
                               "Turrican@Discworld"));
      }
      break;
    case "newer":
    case "minfo":
      eventWrite(fd, sprintf("502 %s command not implemented.\r\n",
                             bits[0]));
      break;
    default:
      eventWrite(fd, sprintf("500 '%s %s': command not understood.\r\n",
                             bits[0], bits[1]));
      break;
    }
    break;
  case "mdtm":
    CHECK_LOGIN();
    CHECK_CMD(1);
    tmp = get_path(fd, rest);
    if (master()->valid_read(tmp, sess->user_name, "file_size")) {
      if (file_size(tmp) == -2)
        eventWrite(fd, sprintf("550 %s not a plain file.\r\n", rest));
      else if (file_size(tmp) == -1)
        eventWrite(fd, sprintf("550 %s does not exist.\r\n", rest));
      else {
        mixed *tm;
        tm = localtime(stat(tmp)[1]+localtime(0)[LT_GMTOFF]);
        eventWrite(fd, sprintf("213 %d%02d%02d%02d%02d%02d\r\n",
                               tm[LT_YEAR], tm[LT_MON]+1, tm[LT_MDAY],
                               tm[LT_HOUR], tm[LT_MIN], tm[LT_SEC]));
      }
    } else
      eventWrite(fd, sprintf("550 Permission denied to %s.\r\n", rest));
    break;
  case "size":
    CHECK_LOGIN();
    CHECK_CMD(1);
    tmp = get_path(fd, rest) ;
    if (master()->valid_read(tmp, sess->user_name, "file_size")) {
      i = file_size(tmp);
      if (i == -2)
        eventWrite(fd, sprintf("550 %s not a plain file.\r\n", rest));
      else if (i == -1)
        eventWrite(fd, sprintf("550 %s does not exist.\r\n", rest));
      else {
#ifdef LOG_CD_SIZE
        log_write(LOG_FILENAME, sprintf("%s SIZE %s at %s.\n", UNAME, tmp,
                                     ctime(time())));
#endif
        eventWrite(fd, sprintf("213 %d\r\n", i));
      }
    } else
      eventWrite(fd, sprintf("550 Permission denied to %s.\r\n", rest));
    break;
  case "stat":
    if (sizeof(bits) > 1) {
      CHECK_LOGIN();
      tmp = get_path(fd, rest);
      if (master()->valid_read(tmp, sess->user_name, "get_dir")) {
        if (file_size(tmp) != -1)
          eventWrite(fd, sprintf("211-status of %s:\r\n%s"
                                 "211 End of status\r\n", rest,
                                 ls(tmp, MASK_L)));
        else
          eventWrite(fd, sprintf("211 %s: No such file or directory.\r\n",
                                 rest));
      } else
        eventWrite(fd, sprintf("211 Permission denied to %s.\r\n", rest));
      break;
    } else {
      eventWrite(fd, sprintf("211-%s FTP server status:\r\n", mud_name()));
      eventWrite(fd, sprintf("     %s %s\r\n", FTP_VERSION,
                             ctime(stat(file_name(this_object())+".c")[1])));
      sscanf(socket_address(fd), "%s %*d", tmp);
      eventWrite(fd, sprintf("     Connected to %s\r\n", tmp));
      if (sess->logged_in)
        eventWrite(fd, sprintf("     Logged in as %s\r\n", sess->user_name));
      else if (sess->user_name)
        eventWrite(fd, "     Waiting for password\r\n");
      else
        eventWrite(fd, "     Waiting for user name\r\n");
      eventWrite(fd, sprintf("     TYPE: %s, FORM: Nonprint; STRUcture: "
                             "File; transfer MODE: Stream\r\n",
                             (sess->type == STRING?"ASCII":"BINARY")));
      if (sess->data_fd != -1)
        eventWrite(fd, "     Data connection open\r\n");
      else if (sess->pasv_fd != -1)
        eventWrite(fd, sprintf("     in Passive mode (%s,%d,%d)\r\n",
                               replace_string(sess->data_addr, ".", ","),
                               sess->data_port>>8, sess->data_port & 0xff));
      else if (!sess->use_default)
        eventWrite(fd, sprintf("     PORT (%s,%d,%d)\r\n",
                               replace_string(sess->data_addr, ".", ","),
                               sess->data_port>>8, sess->data_port & 0xff));
      else
        eventWrite(fd, "     No data connection\r\n");
      eventWrite(fd, "211 End of status\r\n");
      break;
    }
  case "list":
    mask |= MASK_L;
    mask |= MASK_A;
  case "nlst":
    CHECK_LOGIN();
    if ((i = sizeof(bits)) > 1 && bits[1][0] == '-') {
      int j = strlen(bits[1]);
      while (j--) {
        if (bits[1][j] == '-') continue;
        switch(bits[1][j]) {
        case 'l':
          mask &= ~MASK_C;
          mask |= MASK_L;
          break;
        case 'd' :
          mask |= (MASK_L|MASK_D);
          break;
        case 'C':
          mask &= ~MASK_L;
          mask |= MASK_C;
          break;
        case 'F':
          mask |= MASK_F;
          break;
        case 'R':
          mask |= MASK_R;
          break;
        case 'a':
          mask |= MASK_A;
        }
      }
      if (i == 2)
        bits[1] = ".";
      else
        bits = ({ bits[0] }) + bits[2..i-1];
    }
    if (sizeof(bits) > 1)
      tmp = get_path(fd, implode( bits[1..], " "));
    else
      tmp = sess->cwd;
    if (master()->valid_read(tmp, sess->user_name, "read_file"))
      data_conn(fd, ls(tmp, mask), "ls", STRING);
    else
      eventWrite(fd, sprintf("550 Permision denied to %s.\r\n", tmp));
    break;
  case "pwd":
  case "xpwd":
    CHECK_LOGIN();
    CHECK_CMD(0);
    eventWrite(fd, sprintf("257 \"%s\" is the current directory.\r\n",
                           sess->cwd));
    break;
  case "cdup":
  case "xcup":
    CHECK_CMD(0);
    bits += ({".."});
    rest = "..";
  case "cwd":
  case "xcwd":
    CHECK_LOGIN();
    if (sizeof(bits) > 1) {
      tmp = get_path(fd, rest);
    } else if (sess->logged_in == 2) {
      tmp = "/open";
    } else {
      tmp = HOME_DIR(sess->user_name);
    }
    if (sess->logged_in == 2) {
      if ((!((tmp[0..strlen("/open/")-1] == "/open/") || (tmp == "/open")) ||
           (tmp[0..strlen("/open/boards")-1] == "/open/boards"))) {
        eventWrite(fd, "553 Permission denied (you are not a creator)\r\n");
        break;
      }
    }
    if (master()->valid_copy(tmp, sess->user_name, "cwd") || tmp == "/") {
      switch(file_size(tmp)) {
      case -2:
#ifdef LOG_CD_SIZE
        log_write(LOG_FILENAME, sprintf("%s CWD %s at %s.\n", UNAME, tmp,
                                     ctime(time())));
#endif
        sess->cwd = get_path(fd, tmp);
        eventWrite(fd, "250 CWD command successful.\r\n");
        break;
      case -1:
        eventWrite(fd, sprintf("550 %s: No such file or directory.\r\n",
                               rest));
        break;
      default:
        eventWrite(fd, sprintf("550 %s: Not a directory.\r\n", rest));
        break;
      }
    } else
      eventWrite(fd, sprintf("550 Permission denied to %s.\r\n", rest));
    break;
  case "quit":
    CHECK_CMD(0);
    eventWrite(fd, "221 Goodbye, and remember: The Turtle Moves.\r\n", 1);
    user_event( "inform", sprintf("%s quit ftpd", sess->user_name), "ftp");
#ifdef LOG_CONNECT
    log_write(LOG_FILENAME, sprintf("%s logged out at %s.\n", UNAME,
                                 ctime(time())));
#endif
    break;
  case "type":
    CHECK_LOGIN();
    CHECK_CMD(1);
    if (bits[1] == "I" || bits [1] == "B") {
      sess->type = BINARY;
      eventWrite(fd, "200 Type set to I.\r\n");
    } else if (bits[1] == "A") {
      sess->type = STRING;
      eventWrite(fd, "200 Type set to A.\r\n");
    } else
      eventWrite(fd, sprintf("504 Type %s not implemented.\r\n", bits[1]));
    break;
  case "abor":
    CHECK_CMD(0);
    if (sess->data_fd != -1) {
      socket_close(sess->data_fd);
      map_delete(data_sockets, sess->data_fd);
      sess->data_fd = -1;
      sess->offset = 0;
    }
    eventWrite(fd, "426 Transfer aborted. Data connection closed.\r\n");
    eventWrite(fd, "225 ABOR command successful.\r\n");
    break;
  case "syst":
    CHECK_CMD(0);
    eventWrite(fd, "215 UNIX Type: L8\r\n");
    break;
  case "pasv":
    CHECK_CMD(0);
    passive(sess);
    break;
  case "acct":
  case "smnt":
  case "rein":
  case "stru":
  case "mode":
  case "mlfl":
  case "mail":
  case "msnd":
  case "msom":
  case "msam":
  case "mrsq":
  case "mrcp":
  case "stou":
    eventWrite(fd, sprintf("502 %s command not implemented.\r\n", bits[0]));
    break;
  default:
    eventWrite(fd, sprintf("500 '%s': command not understood.\r\n", str));
    break;
  }
}
protected void eventRead(int fd, string str) {
  string *bits, bit;
  str = replace(str,
                ({sprintf("%c", 242), "", "\r", "", sprintf("%c", 255), "",
                    sprintf("%c", 244), ""}));
  bits = explode(str, "\n");
  foreach (bit in bits)
    parse_comm(fd, bit);
}
protected void eventSocketClosed(int fd) {
  int ret;
  class session sess = (class session)socket_info[fd];
  if (sess && sess->data_fd != -1) {
    if ((ret = socket_close(sess->data_fd)) != EESUCCESS) {
      TP("socket_close failed, reason: "+socket_error(ret)+"\n");
      ret = 0;
    }
    map_delete(data_sockets, sess->data_fd);
  }
  if (sess && sess->pasv_fd != -1) {
    if ((ret = socket_close(sess->pasv_fd)) != EESUCCESS) {
      TP("socket_close failed, reason: "+socket_error(ret)+"\n");
      ret = 0;
    }
    map_delete(data_sockets, sess->pasv_fd);
  }
  map_delete(socket_info, fd);
}
protected string get_path(int fd, string str) {
  string *array, *array1, temp;
  int i;
  class session sess = (class session)socket_info[fd];
  if (!str || str == "") {
    return sess->cwd;
  }
  if (str == "~") {
    return HOME_DIR(sess->user_name);
  } else {
    if (str[0] == '~') {
      if (str[1] == '/') {
        sscanf(str, "~%s", temp);
        str = HOME_DIR(sess->user_name) + temp;
      } else {
        string name;
        if (sscanf(str, "~%s/%s", name, str) != 2) {
          name = extract(str, 1);
          str = HOME_DIR(name);
        } else {
          str = HOME_DIR(name) + "/" + str;
        }
      }
    } else if (str[0] != '/')
      str = sess->cwd + "/" + str + "/";
  }
  if (str == "/")
    return "/";
  array = explode(str, "/") - ({ "" });
  array1 = ({ });
  for (i = 0; i < sizeof(array); i++) {
    if (array[i] == "..") {
      if (sizeof(array1)) {
        array1 = array1[0..<2];
      }
    } else if (array[i] != ".")
      array1 += ({ array[i] });
  }
  if (sizeof(array1))
    str = implode(array1, "/");
  else
    str = "";
  return "/" + str;
}
protected string desc_object(mixed o) {
  string str;
  if (!o) return "** Null-space **";
  if (!catch(str = (string)o->short()) && str) return str;
  if (!catch(str = (string)o->query_name()) && str) return str;
  return file_name(o);
}
protected string desc_f_object(object o) {
  string str, tmp;
  str = desc_object(o);
  if (o && str != file_name(o)) {
    if (tmp)
      str += " (" + tmp + ")";
    else
      str += " (" + file_name(o) + ")";
  }
  return str;
}
protected string get_cfile(string str) {
  if (sscanf(str, "%*s.%*s") != 2)
    str += ".c";
  return str;
}
protected void do_update(string name, int fd) {
  string pname, err;
  int j;
  object *invent, rsv, env, dup, loaded, ov;
  mixed static_arg, dynamic_arg;
  "room/void"->bingle_bingle();
  rsv = find_object("room/void");
  if (!rsv) {
    eventWrite(fd, "530 The void is lost!\r\n");
    return;
  }
  name = get_cfile(name);
  ov = find_object(name);
  if (!ov) {
    if(file_size(name) >= 0) {
      if (!(err = catch(name->bing_with_me()))) {
        eventWrite(fd, sprintf("530 Loaded %s.\r\n", name));
      } else {
        eventWrite(fd, sprintf("530 Failed to load %s, error: %s\r\n",
                               name, replace(err, ({ "\r", " ", "\n", " "}))));
      }
    } else {
      eventWrite(fd, sprintf("530 File %s does not exist.\r\n", name));
    }
    return;
  }
  env = environment(ov);
  invent = all_inventory(ov);
  j = sizeof(invent);
  while (j--) {
    invent[j]->move(rsv);
  }
  pname = file_name(ov);
  if (sscanf(pname, "%s#%*d", pname) != 2) {
    ov->dest_me();
    if (ov) {
       ov->dwep();
    }
    if (ov) {
       destruct(ov);
    }
    if (!ov) {
      ov = find_object(pname);
    }
    catch(call_other(pname, "??"));
    ov = find_object(pname);
  } else {
    loaded = find_object(pname);
    static_arg = ov->query_static_auto_load();
    dynamic_arg = ov->query_dynamic_auto_load();
    if (loaded) {
       loaded->dest_me();
    }
    if (loaded) {
       loaded->dwep();
    }
    if (loaded) {
       destruct(loaded);
    }
    catch(dup = clone_object(pname));
    if (dup && ov) {
      ov->dest_me();
      if (ov) {
         ov->dwep();
      }
      if (ov) {
         destruct(ov);
      }
      ov = dup;
      if (static_arg) {
        ov->init_static_arg(static_arg);
      }
      if (dynamic_arg) {
        ov->init_dynamic_arg(dynamic_arg);
      }
    }
  }
  if (!ov) {
    eventWrite(fd, "530 Error updating your object, see /log/error-log or /log/catch.\r\n");
    return;
  }
  j = sizeof(invent);
  while (j--) {
    if (invent[j]) {
       invent[j]->move(ov);
    }
  }
  if (env) {
    ov->move(env);
  }
  eventWrite(fd, sprintf("530 Updated %s.\r\n", desc_f_object(ov)));
}
protected void check_connections() {
  int *bits, i;
  class session sess;
  bits = keys(socket_info);
  i = sizeof(bits);
  while (i--) {
    sess = (class session)socket_info[bits[i]];
    if (sess->data_fd == -1 &&
        (sess->last_data + sess->idle) <= time()) {
      eventWrite(bits[i], sprintf("421 Timeout (%d seconds): "
                                  "closing control connection.\r\n",
                                  sess->idle), 1);
    }
  }
  call_out("check_connections", 5 * 60);
}
protected int check_dots(mixed arg) {
  return (arg[0] != ".." && arg[0] != ".");
}

==================================================
FILE: loader.c
==================================================

string *pre_load;
void create() {
  int i;
  string domain;
  foreach(domain in "/secure/master"->query_domains()) {
    unguarded((: restore_object, "/d/"+ domain + "/loader" :));
    if (!pre_load)
      pre_load = ({ });
    for (i=0;i<sizeof(pre_load);i++) {
      if(pre_load[i] && explode(pre_load[i], "/")[1] != domain)
        printf("invalid " + domain + " preload: " + pre_load[i] +
               "\n");
      else {
        printf(domain +" pre_loading "+pre_load[i]+".\n");
        if(catch(call_other(pre_load[i], "??")))
          call_out("do_load", 0, pre_load[i]);
      }
    }
  }
}
void do_load(string str) {
  call_other(str, "??");
}
private int validate(string domain, object who) {
  string name;
  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return 0;
  if(!userp(who) || !interactive(who))
    return 0;
  name = who->query_name();
  if(!!"/secure/master"->query_trustee(name) &&
     !"/secure/master"->is_leader_of(name, domain) &&
     !"/secure/master"->is_deputy_of(name, domain))
    return 0;
  return 1;
}
int add_pre_load(string domain, string str) {
  if(!validate(domain, previous_object(1)))
    return 0;
  if(explode(str, "/")[1] != domain)
    return 0;
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  if (member_array(str, pre_load) == -1)
    pre_load += ({ str });
  save_object("/d/" + domain + "/loader");
  return 1;
}
int remove_pre_load(string domain, string str) {
  int i;
  if(!validate(domain, previous_object(1)))
    return 0;
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  if ((i=member_array(str, pre_load)) == -1)
    return 0;
  pre_load = delete(pre_load, i, 1);
  save_object("/d/" + domain + "/loader");
}
string *query_pre_load(string domain) {
  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return ({ });
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  return pre_load;
}

==================================================
FILE: login.c
==================================================

#include <data.h>
#include <login_handler.h>
#include <playerinfo.h>
#include <random_names.h>
#include <login.h>
#include <mail.h>
#include <access.h>
#include <playtesters.h>
#define RL_NORMAL 4
#define RL_NONEW 3
#define RL_PT 2
#define RL_CRE 1
#define QUOTE_HANDLER "/obj/handlers/pqf_handler"
#define MULTIPLAYER "/obj/handlers/multiplayer"
#define LIVING "/obj/handlers/livings"
#define CLUB_HANDLER "/obj/handlers/club_handler"
#define BASTARDS "/secure/bastards"
#define FILE_PATH "/doc/login"
#define LOGIN_SCRIPT FILE_PATH + "/login_script.txt"
#define READ_INPUT 1
#define SLEEP 2
#define MIN_LEN 3
#define MAX_LEN 12
#define ADMIN_EMAIL "trustees@discworld.imaginary.com"
#define FREE_DOMAINS ({"hotmail.com", "yahoo.com"})
#define TIMEOUT_TIME 120
#define THROWOUT_TIME ( 2 * TIMEOUT_TIME )
#define MIN_RESET_TIME 86400
class state {
  string name;
  string action;
  string write;
  int noecho;
  mapping events;
}
private mapping _states;
private nosave string _state;
private nosave string _last_state;
private nosave string _event;
private nosave string _last_event;
private nosave int _login_start_time;
private nosave int _counter;
private nosave mapping _data;
private nosave int _compiling;
nosave private int _run_level;
private nosave string _terminal_name;
private nosave int _rows;
private nosave int _cols;
protected void finish_compiling(string, mapping);
protected void load_file();
void enter_state(string);
void dest_me();
void create() {
  seteuid("Root");
  _states = ([ ]);
  load_file();
  _data = ([ ]);
  _run_level = RL_NORMAL;
  if(interactive(this_object()))
     resolve(query_ip_number(this_object()), "");
  call_out("time_out", TIMEOUT_TIME);
}
#ifdef DEBUG
void debug_log(string fmt, mixed args ...) {
  log_file("/secure/NLOGIN",
           "%s: " + fmt + "\n", ctime(time())[4..18], args ...);
}
#else
void debug_log(string fmt, mixed args ...) { return; }
#endif
void load_file() {
  if(_compiling) {
    debug_log("Already compiling, exiting.");
    return;
  }
  if(file_size(base_name(this_object()) + ".o") > -1 &&
     unguarded((: stat(base_name(this_object()) + ".o") :))[1] >=
     unguarded((: stat(LOGIN_SCRIPT) :))[1]) {
    debug_log("loading data.");
    unguarded((: restore_object, base_name(this_object()) :));
    if(!_states)
      _states = ([ ]);
    debug_log("data load complete.");
  } else {
    debug_log("Compiling script");
    debug_printf("Compiling script");
    _compiling = 1;
    DATA_HANDLER->compile_file(LOGIN_SCRIPT, (: finish_compiling :));
  }
}
protected void finish_compiling(string fname, mapping data) {
  string name, s, e;
  mixed *bits;
  mapping thing, event;
  debug_printf("Finished compiling");
  foreach(name, bits in data) {
    switch(name) {
    case "state":
      foreach(thing in bits) {
        if(_states[thing["name"]])
          debug_log("Error, state %s already exists!", thing["name"]);
        _states[thing["name"]] = new(class state,
                                     action: thing["action"],
                                     write: thing["write"],
                                     noecho: thing["no-echo"],
                                     events: ([ ]));
        debug_log("State %s found", thing["name"]);
        if(!arrayp(thing["event"]))
          thing["event"] = ({ thing["event"] });
        foreach(event in thing["event"]) {
          if(mapp(event) && stringp(event["data"]) &&
             stringp(event["new-state"])) {
            _states[thing["name"]]->events[event["data"]] = event["new-state"];
            debug_log("Event %s new state %s", event["data"],
                   event["new-state"]);
          } else
            debug_log("Error event %O in state %s", event, thing["name"]);
        }
      }
      break;
    default:
      tell_creator("ceres", "Name: " + name + "\n");
    }
  }
  debug_log("Validating state machine.");
  foreach(s in keys(_states)) {
    if(_states[s]->action && !function_exists(_states[s]->action))
      debug_log("Action function %s doesn't exist", _states[s]->action);
    foreach(e in keys(_states[s]->events)) {
      if(!_states[s]->events[e])
        debug_log("New state %s doesn't exist in %s %s",
                  _states[s]->events[e], _states[s]->name, e);
    }
  }
  debug_log("Done. %d states created.", sizeof(keys(_states)));
  debug_log("Saving data.");
  _compiling = 0;
  unguarded((: save_object, base_name(this_object()) :));
}
void process_event(string event, string type) {
  if(type == "input" && _states[_state] && _states[_state]->noecho)
    debug_log("entering process event with state %s and event %s-<hidden>",
              _state, type);
  else
    debug_log("entering process event with state %s and event %s-%s", _state,
              type, event);
  _last_event = _event;
  _event = type + "-" + event;
  if(_states[_state]->events[type + "-" + lower_case(event)]) {
    enter_state((_states[_state])->events[type + "-" + lower_case(event)]);
  } else if(_states[_state]->events[type]) {
    enter_state((_states[_state])->events[type]);
  } else if(_states[_state]->events["default"]) {
    enter_state((_states[_state])->events["default"]);
  } else {
    debug_log("no such event %s in state %s (%s)", type + "-" +
              lower_case(event), _state,
              query_multiple_short(keys(_states[_state]->events)));
    return;
  }
}
void enter_state(string new_state) {
  mixed retval;
  string tmp, field;
  _last_state = _state;
  _state = new_state;
  debug_log("entering state %s", _state);
  if(new_state == "finished")
    return;
  if(!_states[_state]) {
    debug_log("invalid state %s exiting", _state);
    dest_me();
  }
  if(_states[_state]->write) {
    debug_log("writing %s", _states[_state]->write);
    if(file_size(_states[_state]->write) > 0)
      tmp = LOGIN_HANDLER->get_message(_states[_state]->write);
    else
      tmp = _states[_state]->write;
    foreach(field in keys(_data))
      if(stringp(_data[field]))
        tmp = replace_string(tmp, "$"+field, _data[field]);
    if(tmp[sizeof(tmp)-1] == '\n')
      tmp = tmp[0..<2];
    write(tmp);
  }
  if(_states[_state]->action) {
    debug_log("calling %s", _states[_state]->action);
    retval = call_other(this_object(), _states[_state]->action, _event);
  } else
    retval = READ_INPUT;
  if(intp(retval) && retval == READ_INPUT) {
    debug_log("action %s returned read_input in state %s",
              _states[_state]->action, _state);
    input_to("process_event", _states[_state]->noecho, "input");
    return;
  }
  if(_states[_state]->action)
    debug_log("action %s returned %s in state %s",
              _states[_state]->action, (string)retval, _state);
  if(_state == "check-login-access") {
    process_event(retval, "return");
    return;
  }
  call_out("process_event", 0, retval, "return");
}
string query_state() { return _state; }
private int check_valid_name(string str) {
  int i;
  for (i=0;i<strlen(str);i++) {
    if (str[i] < 'a' || str[i] > 'z') {
       return i;
    }
  }
  return -1;
}
private int check_name(string name, int new_char) {
  if(strlen(name) < MIN_LEN) {
    write("Sorry the player name " + name + " is too short (min " + MIN_LEN +
          " characters).\n");
    return 0;
  }
  if(strlen(name) > MAX_LEN) {
    write("Sorry the player name " + name + " is too long (max " +
          MAX_LEN + " characters).\n");
    return 0;
  }
  if(check_valid_name(name) != -1) {
    write("Invalid characters used in the name.  You can only use letter "
          "characters, from a to z, spaces and any other sort of "
          "punctuation may not be used.\n");
    return 0;
  }
  if(PLAYER_HANDLER->test_banished(name)) {
    write("\nSorry the player name " + name + " has been banished.\n");
    return 0;
  }
  if (!PLAYER_HANDLER->test_valid(name) || MAIL_TRACK->query_list(name)) {
    write("Sorry that name is not allowed.\n");
    return 0;
  }
  if(PLAYER_HANDLER->test_user(name) || LIVING->find_player(name)) {
    write("Sorry that name has already been taken.\n");
    return 0;
  }
  if(CLUB_HANDLER->is_club(name)) {
    write("Sorry that name is already in use for a club or family.\n");
    return 0;
  }
  return 1;
}
private string generate_password() {
  int i;
  string pass = "";
  for(i=0; i<8; i++)
    switch(random(3)) {
    case 2:
      pass += sprintf("%c", 65 + random(26));
      break;
    case 1:
      pass += sprintf("%c", 97 + random(26));
      break;
    default:
      pass += sprintf("%c", 48 + random(10));
    }
  return replace(pass, ({ "0", "9", "o", "p", "O", "P",
                          "1", "2", "i", "j", "I", "J",
                          "l", "m" }));
}
mixed main_menu(string event) {
  string mess;
  _data = ([ ]);
  _counter = 0;
  write(LOGIN_HANDLER->get_message(FILE_PATH+ "/BANNER"));
  if(LOGIN_HANDLER->site_lockeddown(query_ip_number(this_object()))) {
    write("Sorry, your site has been locked down for excessive failed login "
          "attempts.  If you have forgotten your password please email "+
          ADMIN_EMAIL + ".  If you have not failed to login "
          "please try again later.\n");
    mess = sprintf("attempted login from locked down site: %s.",
                   query_ip_number(this_object()));
    log_file("BAD_PASSWORD", ctime(time())[4..18] + ": " + mess + "\n");
    event(efun::users(), "inform", mess, "bad-password");
    return "quit";
  }
  if(find_object("/obj/shut")) {
    if(find_object("/obj/shut")->query_time_to_crash() < 60) {
      write("With less than one minute to go it is too close to the "
            "shut-down to attempt to log in, please try again in a "
            "few minutes.\n");
      return "quit";
    }
    write("It is too close to the shut-down to attempt to log "
          "in unless you are a creator or net-dead.  Please try again "
          "in a few minutes.\n");
  }
  write(LOGIN_HANDLER->get_message(FILE_PATH+ "/MAIN_MENU"));
  return READ_INPUT;
}
mixed check_delete_name(string event) {
  _data["name"] = lower_case(replace_string(event, "input-", ""));
  if(!PLAYER_HANDLER->test_user(_data["name"])) {
    write("There is no such player.\n\nPress enter to continue ");
    return READ_INPUT;
  }
  if(PLAYER_HANDLER->test_creator(_data["name"])) {
    write("Creators cannot be deleted this way.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  if(file_size(PLAYER_HANDLER->query_delete_player_file_name(_data["name"]) +
               ".o") > 0 ||
     file_size(PLAYER_HANDLER->query_delete_player_file_name(_data["name"]) +
               ".o.gz") > 0) {
    write("That character is already marked for deletion.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  return "ok";
}
mixed check_delete_password(string event) {
  _data["password"] = replace_string(event, "input-", "");
  if(!PLAYER_HANDLER->test_password(_data["name"], _data["password"])) {
    write("\nPassword incorrect.\n");
    return "invalid";
  }
  write("This is will PERMANENTLY delete your character, are you sure? "
        "[y/n] ");
  return READ_INPUT;
}
mixed delete_character(string event) {
  string extension;
  if(PLAYER_HANDLER->test_creator(_data["name"])) {
    write("Creators cannot be deleted this way.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  if(unguarded((: file_size,
                PLAYER_HANDLER->query_player_file_name(_data["name"]) + ".o"
                :)) != -1) {
    extension = ".o";
  } else {
    extension = ".o.gz";
  }
  if(unguarded((: cp, PLAYER_HANDLER->query_player_file_name(_data["name"]) +
                extension,
                PLAYER_HANDLER->query_delete_player_file_name(_data["name"]) +
                extension :))){
    unguarded((: rm, PLAYER_HANDLER->query_player_file_name(_data["name"]) +
               extension :));
    unguarded((: rm,
               PLAYER_HANDLER->query_player_disk_file_name(_data["name"]) +
               extension :));
    write("\n\nPLEASE READ:\nCharacter deleted.  You have 10 days "
          "cooling off time, during "
          "which you may reinstate your character.  To reinstate it "
          "simply log on again and it will reinstate it for you.\n\n");
  } else {
    write("WARNING! Unable to delete your character.\n\n");
  }
  write("Press enter to continue ");
  return READ_INPUT;
}
mixed check_new_access(string event) {
  mixed *tmp;
  _data["new_player"] = 1;
  if(_run_level != RL_NORMAL) {
    write("Sorry this site is not open to new players.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  if(find_object("/obj/shut")) {
    write("It is too close to the shut-down to attempt to create a new "
          "character.  Please try again in a few minutes.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  switch(BASTARDS->query_access(this_object())) {
  case NO_NEW:
  case NO_ACCESS:
    write("\nNew player logins are disabled from this site.  If you wish "
          "to create a character, please email " + ADMIN_EMAIL +
          " with the player name you "
          "would like to use, the name(s) of your other characters and "
          "the name of your ISP.  Note that requests from free email "
          "accounts (hotmail, yahoo etc.) may not be acceptable.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  case AUTH_NEW:
    write("\nNew player logins from this site are disabled.  In order to "
          "create a new character you will be asked for a character "
          "name and an email address, a password will then be emailed "
          "to you at that address.  Note that the address must not "
          "include free accounts (hotmail, yahoo etc.)\n\n");
    return "auth";
  }
  if(!BASTARDS->query_multi(this_object())) {
    tmp = filter(users(),
                 (: interactive($1) &&
                  !$1->query_creator() &&
                  !$1->query_property("test character") &&
                  !strcmp(query_ip_number($1), $2) :),
                 query_ip_number(this_object())) - ({ this_object() });
    if(sizeof(MULTIPLAYER->check_allowed(this_object(), tmp))) {
      write(LOGIN_HANDLER->get_message(FILE_PATH+ "/MULTIPLAYERS") +
            "\n\n"
            "Press enter to continue ");
      return READ_INPUT;
    }
  }
  return "ok";
}
mixed check_guest_access(string event) {
  _data["guest"] = 1;
  _data["new_player"] = 1;
  if(_run_level != RL_NORMAL) {
    write("Sorry this site is not open to guests.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  if(find_object("/obj/shut")) {
    write("It is too close to the shut-down to attempt to create a new "
          "character.  Please try again in a few minutes.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  if(BASTARDS->query_access(this_object()) != DEFAULT) {
    write("\nGuest logins are disabled from this site.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  return "ok";
}
mixed finger_player(string event) {
  string finger_info;
  string player;
  player = replace_string(event, "input-", "");
  if(player)
    player = lower_case(player);
  if (stringp(player) && strlen(player) > 2 && check_valid_name(player)) {
    finger_info = "/secure/finger"->finger_info(player, 1);
    if (!finger_info) {
      write("I am sorry, there is no such player.\n\n");
    } else {
      write(strip_colours(finger_info) + "\n\n");
    }
  } else {
    write("Invalid name, returning to the login menu.\n\n");
  }
  write("Press enter to continue ");
  return READ_INPUT;
}
mixed list_players(string event) {
  write("Here is a list of the people currently playing Discworld:\n" +
        implode(sort_array(map(filter(users(), (: $1->query_cap_name() &&
                                                !$1->query_invis() &&
                                                $1->query_name() != "logon":)),
                               (: $1->query_cap_name() :)),
                           (: strcmp :)), ", ") + "\n");
  write( "\nPress enter to continue ");
  return READ_INPUT;
}
mixed reset_counter(string event) {
  _counter = 0;
  return READ_INPUT;
}
mixed check_email(string event) {
  string name, domain, address;
  address = replace_string(event, "input-", "");
  if(!regexp(address,
           "^[a-zA-Z0-9\\+\\.\\_\\-]+@[a-zA-Z0-9\\_\\-].[a-zA-Z0-9\\_\\-]")){
    write("Sorry, that address is invalid.  Please try again or "
          "enter 'q' to quit.\n");
    return "invalid";
  }
  sscanf(address, "%s@%s", name, domain);
  if(member_array(domain, FREE_DOMAINS) != -1) {
    write("Sorry, that is a free account and not allowed.  Please try "
          "again or enter 'q' to quit.  If you do not have a non-free "
          "address email " + ADMIN_EMAIL + " for a new character.\n");
    return "invalid";
  }
  _data["email"] = address;
  return "ok";
}
mixed check_new_name(string event) {
  _data["name"] = lower_case(replace_string(event, "input-", ""));
  if(!_data["name"] || _data["name"] == "" || _data["name"] == "q")
    return "failed";
  _counter++;
  if(check_name(_data["name"], 1)) {
    _data["cap_name"] = capitalize(_data["name"]);
    return "ok";
  } else if(_counter < 3) {
    return "invalid";
  } else {
    return "failed";
  }
}
mixed check_random_name(string event) {
  string tmp;
  if(!event || event == "")
    return "invalid";
  tmp = replace_string(event, "input-", "");
  if((tmp[0] - '1') < 0 || (tmp[0] - '1') >= sizeof(_data["random_names"]))
    return "invalid";
  _data["name"] = lower_case(_data["random_names"][tmp[0] - '1']);
  if(check_name(_data["name"], 1)) {
    return "ok";
  } else
    return "invalid";
}
mixed main_random_name_menu(string event) {
  string *langs;
  int i;
  i = 1;
  langs = RANDOM_NAME_GENERATOR->query_languages();
  for (i=0;i<sizeof(langs);i++)
    langs[i] = sprintf("%c - %s (eg. %s)", (i+'1'), capitalize(langs[i]),
                       RANDOM_NAME_GENERATOR->unique_name(langs[i]));
  write("You are choosing a name for the first time on Discworld.\n"
        "You can choose a name which is generated to sound something "
        "like:\n"+
        implode(langs, "\n") +
        "\nM - Main Menu\n"
        "Q - Quit\n\n"
        "Your choice? ");
  return READ_INPUT;
}
mixed random_lang_choice(string event) {
  string choice;
  int len;
  choice = replace_string(event, "input-", "");
  len = sizeof(RANDOM_NAME_GENERATOR->query_languages());
  if(strlen(choice) == 1 && choice[0] >= '1' && choice[0] <= ('1'+len-1))
    return RANDOM_NAME_GENERATOR->query_languages()[choice[0]-'1'];
  write("Incorrect choice.\n");
  return "invalid";
}
mixed show_random_names(string event) {
  int i;
  string lang;
  lang = replace_string(event, "return-", "");
  write("Here is a list of 9 random names.  Please choose one:\n");
  _data["random_names"] = allocate(9);
  for (i=0; i<sizeof(_data["random_names"]); i++) {
    _data["random_names"][i] = RANDOM_NAME_GENERATOR->unique_name(lang);
    write(sprintf("%c - %s\n", i+'1', _data["random_names"][i]));
  }
  write("M - Main Menu\n"
        "N - Name Menu\n"
        "G - Generate a new set of names\n"
        "Q - Quit\n"
        "Or, type in your name of choice\n\n"
        "Your choice? ");
  return READ_INPUT;
}
mixed check_new_password(string event) {
  _data["password"] = replace_string(event, "input-", "");
  write("\n");
  if(!_data["password"] || _data["password"] == "")
    return "failed";
  if(strlen(_data["password"]) < 6) {
    write("Password is too short, must be at least 6 characters.\n");
    return "invalid";
  }
  if(_data["password"] == _data["name"]) {
    write("Password is the same as your name, please try again.\n");
    return "invalid";
  }
  return "ok";
}
mixed verify_password(string event) {
  string tmp;
  write("\n");
  tmp = replace_string(event, "input-", "");
  if(tmp == _data["password"])
    return "ok";
  else {
    write("Passwords do not match.\n");
    return "invalid";
  }
}
mixed get_capitalization(string event) {
  if(!_data["cap_name"])
    _data["cap_name"] = capitalize(_data["name"]);
  write("\nHow would you like your name capitalised? [" +
        _data["cap_name"] + "] ");
  return READ_INPUT;
}
mixed check_capitalization(string event) {
  string tmp;
  tmp = replace_string(event, "input-", "");
  if(!tmp || tmp == "")
    return "ok";
  if(lower_case(tmp) != _data["name"]) {
    write("Sorry it has to be the same as your name.");
    return "invalid";
  }
  _data["cap_name"] = tmp;
  return "ok";
}
mixed request_password(string event) {
  string name, email, pass, mess;
  mixed tmp;
  name = replace_string(event, "input-", "");
  if(name)
    name = lower_case(name);
  if(!PLAYER_HANDLER->test_user(name)) {
    write("There is no such player.\n\nPress enter to continue ");
    return READ_INPUT;
  }
  if(PLAYER_HANDLER->test_creator(name)) {
    write("Creator passwords cannot be reset this way mail " +
          ADMIN_EMAIL + ".\n\nPress enter to continue ");
    return READ_INPUT;
  }
  if(!PLAYER_HANDLER->test_ip_allowed(name, query_ip_number(this_object()))) {
    write("Sorry that characters password cannot be reset from your IP "
          "address.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  email = PLAYER_HANDLER->test_email(name);
  if(sizeof(email) > 0 && email[0] == ':')
    email = email[1..];
  while(email != "" && sizeof(email) && email[0] == ' ')
    email = email[1..];
  if(!email || email == "" ||
     !regexp(email, "^[A-z0-9_+\\.]+@[A-z0-9_+]+\\.[A-z0-9_+\\.]+$")) {
    write("Sorry, that player does not have a valid email address set.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  tmp = BASTARDS->query_temp_password(name);
  if(tmp && tmp[0] > time() - MIN_RESET_TIME) {
    write("Sorry that character has had a temporary passwords set "
          "within the last " + number_as_string(MIN_RESET_TIME / 3600) +
          " hours, please try again later.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  pass = generate_password();
  BASTARDS->set_temp_password(name, crypt(pass, 0));
  MAILER->do_mail_message(email, "admin", "Your temporary password", 0,
                          "The temporary password for " + name + " is " +
                          pass + "\n\nYou must use this password within "
                          "the next 7 days.  This is a one use\npassword.  "
                          "After using it to login you should immediately "
                          "use the\n'password' command to set a new "
                          "password.\n\n");
  mess = sprintf("password requested for %s by user at site  %s.", name,
                  query_ip_number(this_object()));
  log_file("BAD_PASSWORD", ctime(time())[4..18] + ": " + mess + "\n");
  event(efun::users(), "inform", mess, "bad-password");
  write("An email is on its way to you " +
        "with a temporary password for this character.\n\n"
        "Press enter to continue ");
  return READ_INPUT;
}
mixed check_login_access(string event) {
  mixed *tmp;
  string *alts;
  if(event && strsrch(event, "input-") != -1)
    _data["name"] = lower_case(replace_string(event, "input-", ""));
  if(_data["name"][0] == '-') {
    _data["name"] = _data["name"][1..];
    _data["go_invis"] = -1;
  } else if(_data["name"][0] == ':') {
    _data["name"] = _data["name"][1..];
    _data["go_invis"] = 1;
  } else if(_data["name"][0] == '#') {
    _data["name"] = _data["name"][1..];
    _data["go_invis"] = 2;
  }
  switch(_run_level) {
  case RL_CRE:
    if(!PLAYER_HANDLER->test_creator(_data["name"]) &&
       !PLAYER_HANDLER->test_property(_data["name"], "test character")) {
      write("Sorry this site is only open to creators.\n\n"
            "Press enter to continue ");
      return READ_INPUT;
    }
    break;
  case RL_PT:
    if(!PLAYER_HANDLER->test_creator(_data["name"]) &&
       !PLAYER_HANDLER->test_property(_data["name"], "test character") &&
       !PLAYTESTER_HAND->query_playtester(_data["name"])) {
    write("Sorry this site is only open to creators and playtesters.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
    }
    break;
  default:
    break;
  }
  if(find_object("/obj/shut") &&
     !PLAYER_HANDLER->test_creator(_data["name"]) &&
     !LIVING->find_player(_data["name"])) {
    write("It is too close to the shut-down to attempt to login.  "
          "Please try again in a few minutes.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  if(!PLAYER_HANDLER->test_user(_data["name"])) {
    write("There is no player by that name.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  if(!PLAYER_HANDLER->test_ip_allowed(_data["name"],
                                      query_ip_number(this_object()))) {
    write("Sorry that character's access control list does not permit "
          "login from your IP address.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  if(PLAYER_HANDLER->test_appealing(_data["name"])) {
    write("Sorry that character has been marked for deletion pending "
          "appeal.  If you wish to appeal please contact the trustees at "
          ADMIN_EMAIL + ".\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  if(PLAYER_HANDLER->test_creator(_data["name"]) ||
     PLAYER_HANDLER->test_property(_data["name"], "test character"))
    return "ok";
  tmp = BASTARDS->query_lockedout(_data["name"]);
  if(tmp) {
    write("Sorry that character has chosen to be locked out until\n" +
          ctime(tmp[SUSPEND_TIME]) + " for " + tmp[SUSPEND_REASON] + ".\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  if(PLAYERINFO_HANDLER->query_alt_of(_data["name"]))
    alts = PLAYERINFO_HANDLER->query_alts(PLAYERINFO_HANDLER->
                                          query_alt_of(_data["name"])) +
      ({ PLAYERINFO_HANDLER->query_alt_of(_data["name"]) });
  else
    alts = PLAYERINFO_HANDLER->query_alts(_data["name"]);
  if(sizeof(alts))
    alts -= ({ _data["name"] });
  if(sizeof(alts)) {
    tmp = filter(alts, (: LIVING->find_player($1) :));
    if(sizeof(tmp)) {
      write("Sorry, you cannot login while one of your alts is logged in.\n"
            "Press enter to continue ");
      return READ_INPUT;
    }
  }
  if(tmp = BASTARDS->query_suspended(_data["name"])) {
    write("You are suspended until " + ctime(tmp[SUSPEND_TIME]) +
          ", enter your password to see why.\n");
  }
  if(PLAYER_HANDLER->test_property(_data["name"], "authorised player"))
    return "ok";
  switch(BASTARDS->query_access(this_object())) {
  case NO_ACCESS:
    write("Player logins are disabled from this site.  Please contact "
          "a creator to have your character authorised to login.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
    break;
  case NO_NEW:
  case AUTH_NEW:
    if(PLAYER_HANDLER->test_age(_data["name"]) > -(2 * 24 * 60 * 60)) {
      write("\nNew player logins are disabled from this site and your character "
            "is too young.  Please contact a creator to have your character "
            " authorised to login.\n\n"
            "Press enter to continue ");
      return READ_INPUT;
    }
    break;
  case ERROR:
    write("Sorry your site has invalid access permissions set.  Please "
          "contact a creator to have this corrected.\n\n"
            "Press enter to continue ");
    return READ_INPUT;
  default:
  }
  if(!BASTARDS->query_multi(this_object())) {
    tmp = filter(users(),
                 (: interactive($1) &&
                  !$1->query_creator() &&
                  !$1->query_property("test character") &&
                  $1->query_name() != "logon" &&
                  $1->query_name() != $3 &&
                  !strcmp(query_ip_number($1), $2)
                  :),
                 query_ip_number(this_object()), _data["name"]) -
      ({ this_object() });
    if(sizeof(MULTIPLAYER->check_allowed(this_object(), tmp))) {
      write("Sorry, someone else is already logged in from the same computer\n"
            "address as you and your site is not authorised for multiple "
            "players.\n\n"
            "Press enter to continue ");
      return READ_INPUT;
    }
  }
  return "ok";
}
mixed check_password(string event) {
  string mess;
  mixed *tmp;
  _data["password"] = replace_string(event, "input-", "");
  _counter++;
  if(_data["password"] == "")
    return "failed";
  if(!PLAYER_HANDLER->test_password(_data["name"], _data["password"])) {
    tmp = BASTARDS->query_temp_password(_data["name"]);
    if(!tmp || crypt(_data["password"], tmp[1]) != tmp[1]) {
      if(_counter < 3) {
        write("\nPassword incorrect.\n");
        return "invalid";
      }
      LOGIN_HANDLER->failed_login(query_ip_number(this_object()));
      write("\nToo many retries.\n\nPress enter to continue ");
      mess = capitalize(_data["name"]) + " failed to login, " +
        (query_ip_name(this_object()) != query_ip_number(this_object())
         ? query_ip_name(this_object()) + " (" +
         query_ip_number(this_object()) + ")"
         : query_ip_number(this_object()));
      event(users(), "inform", mess, "bad-password");
      log_file("BAD_PASSWORD", ctime(time())[4..18] + ": " + mess + "\n");
      return READ_INPUT;
    }
    "/cmds/lord/resetpw"->do_reset(_data["name"], _data["password"]);
    write("\n\nYour temporary password has now been used!  It is essential "
          "that you use the password command to set a new password.\n\n");
  }
  BASTARDS->clear_temp_password(_data["name"]);
  if(tmp = BASTARDS->query_suspended(_data["name"])) {
    write("\nSorry, you are suspended until " +
          ctime(tmp[SUSPEND_TIME]) + " for " +
          tmp[SUSPEND_REASON] + ".\n\nPress enter to continue ");
    return READ_INPUT;
  }
  _data["password-check"] = "ok";
  if(!PLAYER_HANDLER->test_gender(_data["name"]) &&
     PLAYER_HANDLER->test_property(_data["name"], "new player"))
    return "new";
  return "ok";
}
mixed set_gender(string event) {
  string tmp;
  tmp = lower_case(replace_string(event, "input-", ""));
  if (tmp == "m") {
    tmp = "male";
  }
  if (tmp == "f") {
    tmp = "female";
  }
  if(tmp == "male" || tmp == "female") {
    _data["gender"] = tmp;
    return "ok";
  }
  write("That's too weird even for this game!\nTry male or female ");
  return "invalid";
}
mixed check_reconnecting(string event) {
  if(_data["password-check"] != "ok") {
    write("Error\n");
    dest_me();
  }
  if(LIVING->find_player(_data["name"])) {
    write("You are already playing.\n"+
          "Throw the other copy out? (y/n/restart) ");
    return READ_INPUT;
  }
  return "no";
}
mixed restart(string event) {
  object pl;
  pl = LIVING->find_player(_data["name"]);
  if(!pl) {
    write("Your other copy has been eaten.  Logging in normally.\n");
    return "ok";
  }
  tell_object(pl, "Disconnected by someone from " +
              query_ip_name(this_object()) + ".\n");
  if(catch(pl->quit()) && catch(pl->dest_me()))
    destruct(pl);
  if(objectp(pl))
    pl->dest_me();
  return "ok";
}
mixed reconnect(string event) {
  object pl, ob;
  pl = LIVING->find_player(_data["name"]);
  if(!pl) {
    write("Your other copy has been eaten.  Logging in normally.\n");
    return "login";
  }
  if(interactive(pl)) {
    tell_object(pl, "Disconnected by someone from " +
                query_ip_name(this_object()) + ".\n");
    ob = clone_object("/std/object");
    exec(ob, pl);
    ob->dest_me();
  }
  exec(pl, this_object());
  pl->look_me();
  LOGIN_HANDLER->player_reconnected(pl->query_name());
  tell_room(environment(pl), pl->query_cap_name()+
            " has reconnected.\n", ({ pl }) );
  if (function_exists("inform_reconnect_game", pl))
    pl->inform_reconnect_game();
  if(query_ip_number(pl) == query_ip_name(pl))
     resolve(query_ip_number(pl), "");
  return "ok";
}
mixed check_full(string event) {
  int ret;
  if(PLAYER_HANDLER->test_creator(_data["name"]) ||
     PLAYER_HANDLER->test_property(_data["name"], "test character"))
    return "ok";
  ret = LOGIN_HANDLER->int_is_discworld_full(WITHOUT_LOGINS_NOT_IN_QUEUE);
  if((ret & UNCOMPRESSED_FULL) &&
     ((ret & COMPRESSED_FULL) || !compressedp(this_object()))) {
    write("Sorry, there are no player slots available.\n\n");
    return "full";
  }
  return "ok";
}
mixed add_to_queue(string event) {
  object *obs, pl, ob;
  if(member_array(_data["name"], map(LOGIN_HANDLER->query_login_queue(),
                                     (: $1->query_name() :) )) != -1 ) {
    write("You are already in the login queue.\n");
    obs = filter(LOGIN_HANDLER->query_login_queue(),
                 (: $1->query_name() == $2 :), _data["name"]);
    pl = obs[0];
    if (pl && pl->query_login_ob()) {
      write("Reconnecting you to the login queue.\n");
      if (interactive(pl)) {
        tell_object(pl, "Disconnected by someone from " +
                    query_ip_name(this_object()) + ".\n");
        ob = clone_object("/std/object");
        exec(ob, pl);
        ob->dest_me();
      }
      ob = this_object();
      exec(pl, ob);
      return "ok";
    }
  }
  LOGIN_HANDLER->add_to_login_queue(this_object());
  pl = LIVING->find_player(_data["name"]);
  if(pl) {
    write("You were net dead when you left, shuffling you to the "
          "start of the queue...\n");
  } else {
    write("Placing you in the login queue: you have position "+
          sizeof(LOGIN_HANDLER->query_login_queue()) +
          ".\nPlease wait.  Type \"quit\" to escape.\n" );
  }
  remove_call_out("time_out");
  call_out("check_status", 15);
  return "ok";
}
mixed display_terms(string event) {
  write(LOGIN_HANDLER->get_message(FILE_PATH+ "/TERMS"));
  call_out("terms_delayed", 30);
  return "ok";
}
void terms_delayed() {
  _counter = 0;
  write("\nEnter 'yes' if you agree to the terms or 'no' if you cannot.\n"
        "By typing 'yes' you signify that you have read, understand and "
        "agree to by bound by these terms and conditions: [yes/no] ");
  enter_state("agree-terms");
}
mixed check_terms(string event) {
  if(event == "input-yes")
    return "yes";
  if(event == "input-no" || _counter++ > 3)
    return "no";
  return "error";
}
mixed new_player_auth(string event) {
  object pl;
  string pass;
  if(catch(pl = clone_object(BASTARDS->query_player_ob(_data["name"])))) {
    write("Oh no, someone has broken the player object!  "+
            "Come back later.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  if(!pl) {
    write("Something bad happened.\n\n"
          "Press enter to continue ");
    return READ_INPUT;
  }
  pl->set_name(_data["name"]);
  pass = generate_password();
  pl->set_password(crypt(pass, 0));
  pl->set_email(_data["email"]);
  pl->add_property("authorised player", 1);
  pl->add_property("new player", 1);
  pl->add_property("authorised email", _data["email"]);
  pl->allow_save();
  pl->save_me();
  pl->dest_me();
  MAILER->do_mail_message(_data["email"], "admin", "Your password", 0,
                          "The password for " + _data["name"] + " is " +
                          pass + "\n\n");
  write("An email is on its way to you with a password for this "
        "character.\n\n"
        "Press enter to continue ");
  return READ_INPUT;
}
mixed new_player_login(string event) {
  object pl, tp;
  if(catch(pl = clone_object(BASTARDS->query_player_ob(_data["name"])))) {
    write("Oh no, someone has broken the player object!  "+
            "Come back later.\n" );
    return "error";
  }
  if(!pl) {
    write("Something bad happened.\n");
    return "error";
  }
  if(PLAYER_HANDLER->test_property(_data["name"], "authorised player")) {
    pl->add_property("authorised player", 1);
    pl->add_property("authorised email",
                     PLAYER_HANDLER->test_property(_data["name"],
                                                   "authorised email"));
    pl->set_email(PLAYER_HANDLER->test_property(_data["name"],
                                                "authorised email"));
  }
  pl->set_name(_data["name"]);
  if(_data["password"])
    pl->set_password(crypt(_data["password"], 0));
  if(_data["guest"]) {
    pl->add_property("guest", 1);
    pl->set_title("guest of Discworld");
  }
  pl->set_gender(_data["gender"]);
  pl->set_language("general");
  pl->set_default_language("general");
  tp = this_object();
  if(!exec(pl, tp)) {
    write("Oh dear, something went wrong.\n");
    return "error";
  }
  if(tp != this_object())
    tp->quit();
  write("\n");
  pl->move_player_to_start(_data["name"], !_data["guest"], _data["cap_name"],
                           "", _data["go_invis"]);
  if(query_ip_number(pl) == query_ip_name(pl))
    resolve(query_ip_number(pl), "");
  return "ok";
}
mixed player_login(string event) {
  object pl, tp;
  string cap_name;
  if(!interactive(this_object())) {
    debug_log("This ob not interactive. %s %s %s %s", _state, _last_state,
              _event, _last_event);
    dest_me();
  }
  cap_name = PLAYER_HANDLER->query_cap_name(_data["name"]);
  if(file_size(PLAYER_HANDLER->query_delete_player_file_name(_data["name"]) +
               ".o") > 0 &&
     unguarded((: rename,
                PLAYER_HANDLER->query_delete_player_file_name(_data["name"]) +
                ".o",
                PLAYER_HANDLER->query_player_file_name(_data["name"]) +
                ".o" :)))
    write("Removing player from delete queue.\n");
  else if(file_size(PLAYER_HANDLER->
                    query_delete_player_file_name(_data["name"]) + ".o.gz") > 0
          &&
          unguarded((: rename,
                     PLAYER_HANDLER->query_delete_player_file_name(_data["name"]) +
                     ".o.gz",
                    PLAYER_HANDLER->query_player_file_name(_data["name"]) +
                     ".o.gz" :)))
    write("Removing player from delete queue.\n");
  if(catch(pl = clone_object(BASTARDS->query_player_ob(_data["name"])))) {
    write("Oh no, someone has broken the player object!  "+
            "Come back later.\n" );
    return "error";
  }
  if(!pl) {
    write("Something bad happened.\n");
    return "error";
  }
  tp = this_object();
  if(!exec(pl, tp)) {
    write("Oh dear, something went wrong.\n");
    return "error";
  }
  if(tp != this_object())
    tp->quit();
  write("\n");
  pl->move_player_to_start(_data["name"], 0, cap_name, 0, _data["go_invis"]);
  if(_terminal_name)
    pl->terminal_type(_terminal_name);
  if(_cols && _rows)
    pl->window_size(_cols, _rows);
  if(query_ip_number(pl) == query_ip_name(pl))
     resolve(query_ip_number(pl), "");
  return "ok";
}
mixed exit_queue(string event) {
  call_out("time_out", TIMEOUT_TIME);
  if(LIVING->find_player(_data["name"]))
    return "reconnect";
  else
    return "login";
}
void remove_from_login_queue() {
  LOGIN_HANDLER->remove_from_login_queue(this_object());
  tell_object(this_object(), "\n\nYou have exited the login queue!\n\n"
              "Please press enter to continue ");
  enter_state("leaving-queue");
}
mixed quit(string event) {
  write("Come back soon!\n");
  dest_me();
}
mixed time_out() {
  if(!interactive(this_object()))
    return dest_me();
  if((query_idle(this_object()) > TIMEOUT_TIME ||
      (time() > _login_start_time + THROWOUT_TIME)) &&
     member_array(this_object(), LOGIN_HANDLER->query_login_queue()) == -1) {
    write("\nTime out.\n\n");
    return dest_me();
  }
  call_out( "time_out", TIMEOUT_TIME);
  return;
}
void check_status() {
  int pos;
  if(_data["ok_to_login"])
    return;
  pos = member_array(this_object(), LOGIN_HANDLER->query_login_queue())+1;
  if(!pos) {
    LOGIN_HANDLER->add_to_login_queue(this_object());
    pos = member_array(this_object(), LOGIN_HANDLER->query_login_queue())+1;
  }
  if(pos && pos != _data["login_pos"])
    write("You now have position " + pos + " in the queue.\n");
  _data["login_pos"] = pos;
  write(sprintf("%-=*s\n", 79,
                  implode(QUOTE_HANDLER->query_random_quote(), "\n")));
  call_out("check_status", 30);
}
int do_su(string str) {
  object ob, tp;
  ob = this_player();
  tp = this_object();
  _terminal_name = ob->query_cur_term();
  _cols = ob->query_cols();
  _rows = ob->query_rows();
  exec(tp, ob);
  ob->quit();
  _data["name"] = lower_case(str);
  debug_log("Suing to %s", str);
  enter_state("check-login-access");
  return 1;
}
int do_upgrade(object old) {
  old->save();
  _data["name"] = old->query_name();
  exec(this_object(), old);
  destruct(old);
  enter_state("player-login");
}
void logon() {
  debug_log("Connection received.");
  if(find_call_out("time_out") == -1)
    call_out("time_out", TIMEOUT_TIME);
  _login_start_time = time();
  enter_state("main-menu");
}
int query_prevent_shadow() { return 1; }
void do_efun_write(string str) {
  efun::tell_object(this_object(), sprintf("%-=*s", 79, str));
}
string query_object_type() { return "X"; }
string query_gender_string() { return "blue"; }
void terminal_type(string type) {
  _terminal_name = type;
}
void window_size(int width, int height) {
  _cols = width;
  _rows = height;
}
void net_dead() {
  LOGIN_HANDLER->remove_from_login_queue(this_object());
}
void dest_me() {
  LOGIN_HANDLER->remove_from_login_queue(this_object());
  destruct(this_object());
}
int query_login_ob() { return 1; }
string query_player_file_name(string name) {
  return PLAYER_HANDLER->query_player_file_name(name);
}
string query_delete_player_file_name(string name) {
   return PLAYER_HANDLER->query_delete_player_file_name(name);
}
string query_name() {
  if(_data && _data["name"])
    return _data["name"];
  return "logon";
}
string query_cap_name() {
  if(_data && _data["cap_name"])
    return _data["cap_name"];
  return "Logon";
}
protected void write_prompt() { return; }

==================================================
FILE: master.c
==================================================

inherit "/secure/master/directory_assignments";
#define ROOT "Root"
#include <log.h>
#include <player_handler.h>
#define TRUSTEES ([ ROOT : 1, "cratylus" : 1,])
#define READ_MASK 1
#define WRITE_MASK 2
#define GRANT_MASK 4
#define LOCK_MASK 8
#define SENIOR 4
#define DIRECTOR 1
#define TRUSTEE 2
private mapping positions, permissions;
private nosave  mapping trustees, checked_master, snoop_list;
private nosave  object unguarded_ob;
protected void create() {
  set_eval_limit(2000000);
  permissions = ([ ]);
  positions   = ([ ]);
  checked_master = ([ ]);
  snoop_list = ([ ]);
  unguarded_ob = 0;
  trustees = TRUSTEES;
  if (!unguarded((: restore_object, "/secure/master" :)))
    if (!unguarded((: restore_object, "/secure/config/master_fallback" :)))
      error("The master object couldn't restore its save file.");
}
string query_name() { return "Root"; }
object connect(int port) {
  object ob;
  if (!find_object("/secure/login")) {
    log_file("REBOOT", "Mud rebooted at "+ctime(time())+"["+time()+"]"+"\n");
  }
#ifdef __VERSION__
#  define VERSION __VERSION__
#endif
  printf("LPmud version : %s on port %d.", VERSION, port);
  switch (port) {
    case 4243 :
      ob = clone_object("/secure/nlogin");
      if(!ob)
        destruct(this_object());
      break;
    default :
      ob = clone_object("/secure/login");
      break;
  }
  ob->set_login_port(port);
  printf("\n");
  return ob;
}
int query_trustee(mixed str) {
  if (pointerp(str)) {
    str = filter(str, (: interactive($1) :));
    return sizeof(filter((object *)str,
                         (: geteuid($1) == ROOT ||
                          positions[geteuid($1)] == TRUSTEE ||
                          trustees[geteuid($1)] :))) == sizeof(str);
  }
  return ((str == ROOT) || (positions[str] == TRUSTEE) ||
          (trustees[str]));
}
int query_administrator(mixed str) {
  return query_trustee(str);
}
int high_programmer(mixed str) {
  return query_trustee(str);
}
int query_director( mixed arg ) {
  if ( pointerp( arg ) ) {
    arg = filter(arg, (: interactive($1) :));
    return sizeof( filter( (object *)arg,
                           (: ( positions[ geteuid( $1 ) ] == DIRECTOR ) ||
            query_trustee( geteuid( $1 ) ) :) ) ) == sizeof( arg );
  }
  return ( ( positions[ arg ] == DIRECTOR ) || query_trustee( arg ) );
}
int query_leader( mixed arg ) { return query_director( arg ); }
int query_lord( mixed arg ) { return query_director( arg ); }
int query_only_director( string word ) {
   return positions[ word ] == DIRECTOR;
}
int query_only_leader( string word ) { return query_only_director( word ); }
int query_only_lord( string word ) { return query_only_director( word ); }
string *query_directors() {
  return filter_array(keys(positions),
                      "query_only_director", this_object());
}
string *query_leaders() { return query_directors(); }
string *query_lords() { return query_directors(); }
int query_player_trustee(string str) {
  return query_trustee(str) && PLAYER_HANDLER->test_user(str);
}
int query_player_administrator(string str) {
  return query_player_trustee(str);
}
int query_player_high_lord(string str) {
  return query_player_trustee(str);
}
string *high_programmers() { return keys( trustees ); }
string *query_administrators() { return keys( trustees ); }
string *query_trustees() { return keys( trustees ); }
string *query_all_directors() {
  return filter_array(keys(positions), "query_director", this_object() );
}
string *query_all_leaders() { return query_all_directors(); }
string *query_all_lords() { return query_all_directors(); }
int is_leader_of(string person, string domain) {
  return ("/d/" + domain + "/master")->query_lord() == person;
}
int is_deputy_of(string person, string domain) {
   return ("/d/" + domain + "/master")->query_deputy(person);
}
int is_liaison_deputy(string person) {
   return "/d/liaison/master"->query_deputy(person);
}
int query_liaison_deputy_or_director(mixed arg) {
  if ( pointerp( arg ) ) {
    arg = filter(arg, (: interactive($1) :));
    return sizeof( filter( (object *)arg,
                           (: query_director(geteuid( $1 )) ||
            is_liaison_deputy( geteuid( $1 ) ) :) ) ) == sizeof( arg );
  }
  return ( is_liaison_deputy(arg) || query_director( arg ) );
}
int query_liaison_deputy_or_lord(mixed arg) {
  return query_liaison_deputy_or_director(arg);
}
int query_senior( mixed arg ) {
   if ( pointerp( arg ) )
      return sizeof(filter( (object *)arg,
            (: ( positions[ geteuid( $1 ) ] == SENIOR ) ||
            query_leader( geteuid( $1 ) ) :) ) ) == sizeof( arg );
   return ( ( positions[ arg ] == SENIOR ) || query_leader( arg ) );
}
string *query_all_seniors() {
   return filter_array( keys( positions ), "query_senior", this_object() );
}
string *query_domains() {
  string *domains;
  domains = (get_dir("/d/") - ({ "lost+found", "core" }));
  return filter(domains, (: $1[<4..] != "_dev" :));
}
int valid_load(string path, mixed euid, string func) { return 1; }
string get_root_uid() { return ROOT; }
string get_bb_uid() { return "Room"; }
string *define_include_dirs() {
  return ({ "/include/%s" });
}
int valid_trace() { return 1; }
void shut(int min) {
  "/obj/shut"->shut(min);
}
void remove_checked_master(string name) {
  map_delete(checked_master, name);
}
mapping query_checked_master() { return checked_master; }
varargs mixed apply_unguarded(function f, int local) {
  object previous_unguarded;
  string err;
  mixed val;
  if (base_name(previous_object(0)) != "/secure/simul_efun") {
    error("Illegal unguarded apply.");
    return 0;
  }
  previous_unguarded = unguarded_ob;
  if (local)
    unguarded_ob = master();
  else
    unguarded_ob = previous_object(1);
  err = catch(val = (mixed)(*f)());
  unguarded_ob = previous_unguarded;
  if (err) {
    error(err);
  }
  return val;
}
#include "/secure/master/permission.c"
#include "/secure/master/crash.c"
#include "/secure/master/create_dom_creator.c"
#include "/secure/master/creator_file.c"
#include "/secure/master/dest_env.c"
#include "/secure/master/ed_stuff.c"
#include "/secure/master/file_exists.c"
#include "/secure/master/logging.c"
#include "/secure/master/parse_command.c"
#include "/secure/master/preload.c"
#include "/secure/master/query_pl_level.c"
#include "/secure/master/simul_efun.c"
#include "/secure/master/snoop.c"
#include "/secure/master/valid_database.c"
#include "/secure/master/valid_exec.c"
#include "/secure/master/valid_hide.c"
#include "/secure/master/valid_ident.c"
#include "/secure/master/valid_link.c"
#include "/secure/master/valid_override.c"
#include "/secure/master/valid_read.c"
#include "/secure/master/valid_seteuid.c"
#include "/secure/master/valid_shadow.c"
#include "/secure/master/valid_socket.c"
#include "/secure/master/valid_write.c"
#include "/secure/master/valid_copy.c"
#include "/secure/master/virtual_objects.c"
#include "/secure/master/valid_bind.c"
#include "/secure/master/valid_to_c.c"
#include "/secure/master/valid_binary.c"

==================================================
FILE: rcs_handler.c
==================================================

#include <player_handler.h>
#define SAVE_FILE "/secure/rcs_handler"
#define CMD_NUM 5
#define MAX_MOD_TIME (86400 * 90)
mapping _locks = ([]);
void create()  {
   unguarded((: restore_object, SAVE_FILE :));
   call_out("clean_up", 2);
}
void clean_up(string *names) {
  string name, file, *cmd;
  int changed, i;
  if(!names) {
    names = keys(_locks);
  }
  if(!sizeof(names))
    return 0;
  name = names[0];
  if(sizeof(names) > 1) {
    while(sizeof(names) > 1 && (!names[1] || !arrayp(names[1])))
      names = names[1..];
    if(sizeof(names) > 1)
      call_out("clean_up", random(15), names[1..]);
  }
  foreach(file in _locks[name]) {
    if(i++ > 100)
      break;
    if(file_size(file) <= 0) {
      _locks[name] -= ({ file });
      changed = 1;
    } else if((time() - stat(file)[1]) > MAX_MOD_TIME ||
            !PLAYER_HANDLER->test_creator(name)) {
      cmd = ({ "-w" + name,
                 "-u",
                 "-mForcibly released due to inactivity",
                 file[1..] });
      external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                     "close_call_back");
      _locks[name] -= ({ file });
      changed = 1;
    }
  }
  if(!sizeof(_locks[name])) {
    map_delete(_locks, name);
    changed = 1;
  }
  if(changed)
    unguarded((: save_object, SAVE_FILE, 2 :));
}
void read_call_back(int fd, mixed mess) { return; }
void write_call_back(int fd) { return; }
void close_call_back(int fd) { return; }
void add_lock(mixed cre, string file)  {
   string name;
   if( file[0] != '/' )
      file = "/" + file;
   if (stringp(cre))  name = lower_case(cre);
   else name = cre->query_name();
   if (undefinedp(_locks[name]))
      _locks[name] = ({ file });
   else if ( member_array( file, _locks[name] ) < 0 )
      _locks[name] += ({ file });
   unguarded((: save_object, SAVE_FILE, 2 :));
   return;
}
void remove_lock(mixed cre, string file)  {
   string name;
   if( file[0] != '/' )
      file = "/" + file;
   if (stringp(cre))  name = lower_case(cre);
   else name = cre->query_name();
   if (!undefinedp(_locks[name]))  {
      _locks[name] -= ({ file });
      unguarded((: save_object, SAVE_FILE, 2 :));
   }
   return;
}
mapping query_non_creators() {
  mapping res;
  string person;
  res = ([ ]);
  foreach(person in keys(_locks)) {
    if(!PLAYER_HANDLER->test_creator(person))
      res[person] = _locks[person];
  }
    return res;
}
string *query_locks(mixed cre)  {
   string name;
   if (stringp(cre))  name = lower_case(cre);
   else name = cre->query_name();
   return _locks[name];
}
void reset_locks(mixed cre, int start)  {
  string file, name, rcsfile, tmp;
  int idx, i, changed;
  changed = 0;
  if (stringp(cre))
    name = lower_case(cre);
  else
    name = cre->query_name();
  if (undefinedp(_locks[name]))
    return;
  for(i=0; i < sizeof(_locks[name]) && i < start + 100; i++) {
    file = _locks[name][i];
    idx = strsrch(file, "/", -1);
    rcsfile = file[0 .. idx] + "RCS/" + file[idx + 1 .. ] + ",v";
    if (file_size(rcsfile) > 0) {
      tmp = read_file(rcsfile, 4, 1);
      if (tmp == "locks\n") {
        string lockname;
        tmp = read_file(rcsfile, 5, 1);
        sscanf(tmp, "\t%s:", lockname);
        if (lockname != name)  {
          _locks[name] -= ({ file });
          changed = 1;
        }
      } else {
        _locks[name] -= ({ file });
        changed = 1;
      }
    }
  }
  if(!sizeof(_locks[name])) {
    map_delete(_locks, name);
    changed = 1;
  }
  if (changed)
    unguarded((: save_object, SAVE_FILE, 2 :));
  return;
}
string help() {
  return "Displays the files that are locked in your current directory.";
}

==================================================
FILE: related_files.c
==================================================

#include <playerinfo.h>
#include <nomic_system.h>
void delete_related_files( string name, int mail, int refresh_type ) {
   string *files;
   string area;
   string dir;
   if (previous_object() != find_object("/secure/bulk_delete") &&
       previous_object() != find_object("/secure/delete_clear") &&
       previous_object() != find_object("/obj/handlers/refresh")) {
     if (!master()->high_programmer(previous_object(-1)) &&
         ((string)previous_object()->query_name() != name)) {
       tell_object(find_player("ceres"), "Not doing erasing. %O\n",
                   previous_object());
       unguarded( (: write_file, "/log/CHEAT", ctime( time() ) +
                   ": illegal attempt to delete related files using "+
                   "/secure/related_files\nTrace: "+ back_trace() :) );
       return;
     }
   }
   unguarded( (: rm, "/save/artifacts/"+ name :) );
   unguarded( (: rm, "/save/bank_accounts/"+name[0..0] + "/" + name + ".o" :) );
   unguarded( (: rm, "/save/cmr_library/"+ name +".o" :) );
   catch("/obj/handlers/library"->restart(name));
   unguarded( (: rm, "/save/library/"+ name[0..0] + "/" + name + ".o" :) );
   unguarded( (: rm, "/save/philosophies/"+ name[0..0] + "/"+ name + ".o" :) );
   foreach(dir in get_dir("/save/vaults

==================================================
FILE: security.c
==================================================

#include <security.h>
varargs nomask mixed call_unguarded(string func, mixed a1,
                                           mixed a2, mixed a3, mixed a4) {
  return call_other(previous_object(), func, a1, a2, a3, a4);
}

==================================================
FILE: simul_efun.c
==================================================

inherit "/secure/simul_efun/add_a";
#if !efun_defined(add_action)
inherit "/secure/simul_efun/add_action";
#endif
inherit "/secure/simul_efun/add_command";
inherit "/secure/simul_efun/aggregate";
inherit "/secure/simul_efun/amtime";
inherit "/secure/simul_efun/array";
inherit "/secure/simul_efun/ctime_elapsed";
inherit "/secure/simul_efun/back_trace";
#if !efun_defined(dump_socket_status)
inherit "/secure/simul_efun/dump_socket_status";
#endif
inherit "/secure/simul_efun/find_match";
inherit "/secure/simul_efun/find_member";
inherit "/secure/simul_efun/find_other_call_out";
inherit "/secure/simul_efun/get_function_pointer";
inherit "/secure/simul_efun/inside_shorts";
inherit "/secure/simul_efun/mapping";
inherit "/secure/simul_efun/modified_efuns";
inherit "/secure/simul_efun/pk_check";
inherit "/secure/simul_efun/pl_to_ob";
inherit "/secure/simul_efun/process_value";
inherit "/secure/simul_efun/query_ident";
inherit "/secure/simul_efun/query_number";
inherit "/secure/simul_efun/roll_MdN";
#if !efun_defined(shuffle)
inherit "/secure/simul_efun/shuffle";
#endif
inherit "/secure/simul_efun/snoop_simul";
inherit "/secure/simul_efun/sqrt";
inherit "/secure/simul_efun/strip_colours";
inherit "/secure/simul_efun/str_inven";
inherit "/secure/simul_efun/debug";
inherit "/secure/simul_efun/unguarded";
inherit "/secure/simul_efun/virtual";
void create() {
  seteuid("Root");
  find_match::create();
}

==================================================
FILE: player/delete_clear.c
==================================================

#include <player_handler.h>
#define ONE_DAY (60*60*24)
#define SAVE_FILE "/save/del_pl_check"
int last_clear;
void create() {
  seteuid("Root");
  restore_object(SAVE_FILE);
  if (last_clear+ONE_DAY < time()) {
    call_out("do_delete_check", 0);
  } else {
    call_out("do_delete_check", last_clear+ONE_DAY-time());
  }
}
protected void do_delete_check() {
  string *bits;
  int i;
  mixed *rubbish;
  bits = get_dir("/players/"+DELETE_DIR+"

==================================================
FILE: simul_efun/add_a.c
==================================================

string add_a(string s) {
  int i;
  if (!stringp(s))
    return 0;
  i = 0;
  while (s[i] == ' ') i++;
  if(s[i..i+1] == "a " || s[i..i+2] == "an ")
    return s;
  switch (s[i]) {
  case 'a':
  case 'e':
  case 'i':
  case 'o':
  case 'u':
  case 'A':
  case 'E':
  case 'I':
  case 'O':
  case 'U':
    return "an " + s[i..];
  default:
    return "a " + s[i..];
  }
}
int vowel(int i) {
  return (i == 'a' || i == 'e' || i == 'i' || i == 'o' || i == 'u' ||
          i == 'A' || i == 'E' || i == 'I' || i == 'O' || i == 'U');
}

==================================================
FILE: simul_efun/add_action.c
==================================================

#define LIV "/obj/handlers/livings"
private nosave string _nf;
varargs void log_file(string name, string fmt, mixed *args ...);
void enable_commands(){
  efun::set_this_player(previous_object());
  LIV->enable_commands(previous_object());
}
void set_living_name(string name){
  LIV->set_living_name(name, previous_object());
}
int living(object ob){
  if(!ob)
    return 0;
  return ob->_living();
}
int _notify_fail(string mes){
  _nf = mes;
  return 0;
}
string query_notify_fail(){
  return _nf;
}
mixed command(string cmd){
  int time = eval_cost();
  if(evaluate(bind((:call_other:), previous_object()),previous_object(),
           "_process_input", cmd))
    return eval_cost() - time + 1;
  return 0;
}
mixed actions_defined(mixed, mixed, mixed){ return ({}); }
void set_this_player(object ob){
  error("Illegal use of set_this_player.");
}

==================================================
FILE: simul_efun/add_command.c
==================================================

varargs void add_command(string verb, string pattern, function func) {
   if (!verb) {
      write("Need to specify a verb for add_command.\n");
      return ;
   }
   if (!pattern) {
      write("Need to specify a pattern for add_command.\n");
   }
   if (this_player()) {
      this_player()->add_command(verb, previous_object(), pattern, func);
   }
}
void add_succeeded_mess(mixed mess, object *indir) {
   if (!indir) {
     indir = ({ });
   }
   this_player()->add_succeeded_mess(previous_object(), mess, indir);
}
void add_succeeded_ob(object ob) {
   this_player()->add_succeeded(ob);
}
void add_failed_mess(mixed mess, object *indir) {
   if (!indir) {
     indir = ({ });
   }
   this_player()->add_failed_mess(previous_object(), mess, indir);
}

==================================================
FILE: simul_efun/aggregate.c
==================================================

string mapping_to_string( mapping map );
string array_to_string( mixed *args ) {
   int i;
   args = copy(args);
   for ( i = sizeof( args ) - 1; i > -1; i-- ) {
      if ( pointerp( args[ i ] ) ) {
         args[ i ] = array_to_string( args[ i ] );
         continue;
      }
      if ( mapp( args[ i ] ) ) {
         args[ i ] = mapping_to_string( args[ i ] );
         continue;
      }
      args[ i ] = sprintf( "%O", args[ i ] );
   }
   return "({ "+ implode( args, ", " ) +" })";
}
string mapping_to_string( mapping map ) {
   int i;
   mixed *args;
   if( !mapp( map ) ) {
      return sprintf( "%O", map );
   }
   args = keys( map );
   for ( i = sizeof( args ) - 1; i > -1; i-- ) {
      if ( pointerp( map[ args[ i ] ] ) ) {
         args[ i ] = sprintf( "%O : %s", args[ i ],
               array_to_string( map[ args[ i ] ] ) );
         continue;
      }
      if ( mapp( map[ args[ i ] ] ) ) {
         args[ i ] = sprintf( "%O : %s", args[ i ],
               mapping_to_string( map[ args[ i ] ] ) );
         continue;
      }
      args[ i ] = sprintf( "%O : %O", args[ i ], map[ args[ i ] ] );
   }
   return "([ "+ implode( args, ", " ) +" ])";
}
void alt_move(mixed dest, object ob){
  if(!ob)
    return;
  evaluate(bind((:move_object, dest:), ob));
}
varargs string extract(string str, int start, int end) {
  if (end)
    return str[start..end];
  return str[start..];
}

==================================================
FILE: simul_efun/alt_move.c
==================================================

void alt_move(mixed dest, object ob){
  if(!ob)
    return;
  evaluate(bind((:move_object, dest:), ob));
}

==================================================
FILE: simul_efun/amtime.c
==================================================

#include <am_time.h>
string query_num(int num);
#if !efun_defined(query_multiple_short)
varargs string query_multiple_short( mixed *args, string type,
                                     int no_dollars, int quiet,
                                     int dark );
#endif
string ordinal( int number ) {
   if ( ( number % 100 > 10 ) && ( number % 100 < 14 ) )
      return number +"th";
   if ( number % 10 == 1 )
      return number +"st";
   if ( number % 10 == 2 )
      return number +"nd";
   if ( number % 10 == 3 )
      return number +"rd";
   return number +"th";
}
varargs string amtime( int number, int format ) {
   return AM_TIME_HANDLER->query_am_time(number, format);
}
#include <am_time.h>
varargs string query_time_string (int t, int max_elements, int am_time,
                                  int use_words) {
  string *toret = ({ }), tmp_string;
  int year, day, hour, minute, tmp_int;
  if (am_time) {
    year = AM_SECONDS_PER_HALF_YEAR * 2;
    day = AM_SECONDS_PER_DAY;
    hour = AM_SECONDS_PER_HOUR;
    minute = AM_SECONDS_PER_MINUTE;
  }
  else {
    year = 60 * 60 * 24 * 365;
    day = 60 * 60 * 24;
    hour = 60 * 60;
    minute = 60;
  }
  if (t >= year) {
    toret = ({ toret ..., sprintf ("%d %s", (t / year),
      (t >= year * 2 ? "years" : "year")) });
    t %= year;
    year = -1;
  }
  if (t >= day) {
    toret = ({ toret ..., sprintf ("%d %s", (t / day),
      (t >= day * 2 ? "days" : "day")) });
    t %= day;
    day = -1;
  }
  else if (year == -1) {
    toret = ({ toret ..., "0 days" });
  }
  if (t >= hour) {
    toret = ({ toret ..., sprintf ("%d %s", (t / hour),
      (t >= hour * 2 ? "hours" : "hour")) });
    t %= hour;
  }
  else if (day == -1) {
    toret = ({ toret ..., "0 hours" });
  }
  if (t >= minute) {
    toret = ({ toret ..., sprintf ("%d %s", (t / minute),
      (t >= minute * 2 ? "minutes" : "minute")) });
    t %= minute;
  }
  else if (hour == -1) {
    toret = ({ toret ..., "0 minutes" });
  }
  if (t > 0) {
    toret = ({ toret ..., sprintf ("%d %s", t,
      (t > 1 ? "seconds" : "second")) });
  }
  if (!max_elements) {
    max_elements = 2;
  }
  if (max_elements > 0) {
    toret = toret[0..(max_elements - 1)];
  }
  for (int x = 0; x < sizeof (toret); ++x) {
    sscanf (toret[x], "%d %s", tmp_int, tmp_string);
    if (tmp_int == 0) {
      toret -= ({ toret[x] });
    }
    else if (use_words) {
      toret[x] = query_num (tmp_int) + " " + tmp_string;
    }
  }
  if (!toret || !sizeof (toret)) {
    return "no time at all";
  }
  return query_multiple_short (toret);
}

==================================================
FILE: simul_efun/array.c
==================================================

mixed delete(mixed arr, int start, int len) {
  return arr[0..start-1] + arr[start+len..];
}
mixed insert(mixed arr, mixed el, int pos) {
  if (stringp(arr))
    return arr[0..pos-1] + el + arr[pos..];
  return arr[0..pos-1] + ({ el }) + arr[pos..];
}
object *all_environment(object ob){
  object *ret = ({});
  if(!ob)
    ob = previous_object();
  while(environment(ob)){
    ob = environment(ob);
    ret += ({ob});
  }
  return ret;
}

==================================================
FILE: simul_efun/back_trace.c
==================================================

string back_trace() {
  string ret = "", *progs, *funcs, *obs, name;
  int i;
  progs = map(call_stack(0), (: $1[1..<3] :));
  obs = map(call_stack(1), (: file_name($1)[1..] :));
  funcs = call_stack(2);
  i = sizeof(progs);
  ret = "Time: " + ctime(time()) + "\n";
  while (i-- > 1) {
    if (objectp(obs[i]))
      name = obs[i]->query_name();
    if (!name)
      name = "null";
    if (obs[i] == progs[i])
      ret += sprintf("%s() in /%s (%s)\n", funcs[i], progs[i], name);
    else
      ret += sprintf("%s() in inherited file /%s in /%s (%s)\n", funcs[i],
                     progs[i], obs[i], name);
    name = 0;
  }
  return ret;
}

==================================================
FILE: simul_efun/base_name.c
==================================================

string base_name(mixed val) {
  string name, base;
  if(!val)
    return "";
  if (stringp(val))
    name = val;
  else
    name = file_name(val);
  if (sscanf(name, "%s#%*d", base) == 2)
    return base;
  return name;
}

==================================================
FILE: simul_efun/ctime_elapsed.c
==================================================

varargs string ctime_elapsed( int time_elapsed, int mode ) {
    int sec, min, hour, day;
    string seconds, minutes, hours, days;
    string *retval;
    sec = time_elapsed % 60;
    min = (time_elapsed / 60) % 60;
    hour = (time_elapsed / (60 * 60)) % 24;
    day = time_elapsed / (60 * 60 * 24);
    if ( mode ) {
        seconds = query_num( sec );
        minutes = query_num( min );
        hours = query_num( hour );
        days = query_num( day );
    }
    else {
        seconds = sec + "";
        minutes = min + "";
        hours = hour + "";
        days = day + "";
    }
    retval = ({ });
    if (day > 0) {
        retval += ({ days + " day" });
        if (day > 1) {
            retval[<1] += "s";
        }
    }
    if (hour > 0) {
        retval += ({ hours + " hour" });
        if (hour > 1) {
            retval[<1] += "s";
        }
    }
    if (min > 0) {
        retval += ({ minutes + " minute" });
        if (min > 1) {
            retval[<1] += "s";
        }
    }
    if (sec > 0) {
        retval += ({ seconds + " second" });
        if (sec > 1) {
            retval[<1] += "s";
        }
    }
    if (sizeof(retval) == 0) {
        return "0 seconds";
    }
    if (sizeof(retval) == 1) {
        return retval[0];
    }
    return implode(retval[0..<2], ", ") + " and " + retval[<1];
}

==================================================
FILE: simul_efun/debug.c
==================================================

void debug_printf(string fmt, mixed args ...) {
  object env;
  env = previous_object();
  if(env)
    while(environment(env))
      env = environment(env);
  if((!env || !env->query_is_room() || base_name(env) == "/room/rubbish") &&
     this_player()) {
    env = environment(this_player());
  }
  if(env) {
#if efun_defined(event)
    event(env, "inform", sprintf("%O:\n " + fmt, previous_object(), args ...),
          "debug");
#else
    this_object()->event(env, "inform", sprintf("%O:\n " + fmt,
                                                previous_object(), args ...),
                         "debug");
#endif
  }
}
varargs void tell_creator(mixed cres, string fmt, mixed args ...)  {
  mixed cre;
  if(!arrayp(cres))
    cres = ({ cres });
  foreach(cre in cres) {
    if (stringp(cre)) {
#if efun_defined(find_player)
      cre = efun::find_player(cre);
#else
      cre = "/obj/handlers/livings"->find_player(cre);
#endif
    }
    if (objectp(cre) && cre->query_creator()) {
      if (sizeof(args)) {
        tell_object(cre, sprintf("%O:\n" + fmt, previous_object(), args ...));
      } else {
        tell_object(cre, sprintf("%O:\n"+fmt, previous_object()));
      }
    }
  }
}

==================================================
FILE: simul_efun/dump_socket_status.c
==================================================

string dump_socket_status() {
    string ret = @END
Fd    State      Mode       Local Address          Remote Address
--  ---------  --------  ---------------------  ---------------------
END;
    foreach (mixed *item in socket_status()) {
  ret += sprintf("%2d  %|9s  %|8s  %-21s  %-21s\n", item[0], item[1], item[2], item[3], item[4]);
    }
    return ret;
}

==================================================
FILE: simul_efun/extract.c
==================================================

varargs string extract(string str, int start, int end) {
  if (end)
    return str[start..end];
  return str[start..];
}

==================================================
FILE: simul_efun/find_match.c
==================================================

#define OBJ_PARSER_NO_CLASSES
#include <obj_parser.h>
inherit "/secure/simul_efun/obj_parser";
#include <playtesters.h>
private nosave mixed *rest;
mixed *query_strange_inventory(mixed *arr);
private object query_simul_efun_id(object ob, mixed *arr);
private object query_frac_simul_efun_id(object ob, mixed *arr);
#if !efun_defined(living)
int living(object);
#endif
int is_in_me_or_environment(object thing, object person)  {
   object env;
   if ((env = environment(thing)) == environment(person))
      return 1;
   if (!env)
      return 1;
   while (env  &&  !living(env))
      env = environment(env);
   if (env == person)
      return 1;
   return 0;
}
object* filter_in_me_or_environment(object* obs, object player) {
   return filter(obs, (: is_in_me_or_environment($1, $2) :), player);
}

==================================================
FILE: simul_efun/find_member.c
==================================================

int *find_member( mixed target, mixed *array ) {
int *locs = ({ });
int start = 0;
  while ( start != -1 ) {
    start = member_array( target, array, start );
    if ( start != -1 ) {
      locs += ({ start });
      start ++;
    }
  }
  return locs;
}

==================================================
FILE: simul_efun/find_other_call_out.c
==================================================

mixed find_other_call_out(object ob, string co){
  return evaluate(bind((: find_call_out($(co)) :), ob));
}

==================================================
FILE: simul_efun/get_function_pointer.c
==================================================

function get_function_pointer(string lpc){
  function tmp = function(string lpc){
    function tmp;
    write_file("/secure/functemp.c", sprintf("mixed bing(){return %s;}", lpc));
    catch{
      tmp = "/secure/functemp"->bing();
      destruct(find_object("/secure/functemp"));
    };
    rm("/secure/functemp.c");
    return tmp;
  };
  return bind(this_object()->unguarded((:evaluate($(tmp), $(lpc)):)), previous_object());
}

==================================================
FILE: simul_efun/inside_shorts.c
==================================================

private string ob_short(object ob) {
   string ret;
   if (ob->query_clothing()) {
      ret = ob->query_pocket_mess();
   } else {
      ret = "$ob_short$";
   }
   return ret;
}
string inside_the_short(object ob, object play) {
   string str;
   if (!play) {
      play = this_player();
   }
   if (!ob) {
      ob = environment(play);
   }
   str = replace_string(ob_short(ob), "$ob_short$", ob->the_short());
   while (environment(ob) &&
          environment(ob) != play &&
          environment(ob) != environment(play)) {
      ob = environment(ob);
      str += " inside " + replace_string(ob_short(ob), "$ob_short$",
                                         ob->the_short());
   }
   return str;
}
string inside_a_short(object ob, object play) {
   string str;
   if (!play) {
      play = this_player();
   }
   if (!ob) {
      ob = environment(play);
   }
   str = replace_string(ob_short(ob), "$ob_short$", ob->a_short());
   while (environment(ob) &&
          environment(ob) != play &&
          environment(ob) != environment(play)) {
      ob = environment(ob);
      str += " inside " + replace_string(ob_short(ob), "$ob_short$",
                                         ob->the_short());
   }
   return str;
}
string inside_one_short(object ob, object play) {
   string str;
   if (!play) {
      play = this_player();
   }
   if (!ob) {
      ob = environment(play);
   }
   str = replace_string(ob_short(ob), "$ob_short$", ob->one_short());
   while (environment(ob) &&
          environment(ob) != play &&
          environment(ob) != environment(play)) {
      ob = environment(ob);
      str += " inside " + replace_string(ob_short(ob), "$ob_short$",
                                         ob->the_short());
   }
   return str;
}

==================================================
FILE: simul_efun/mapping.c
==================================================

mapping m_delete(mapping map, mixed key) {
  map = map + ([ ]);
  map_delete(map, key);
  return map;
}

==================================================
FILE: simul_efun/modified_efuns.c
==================================================

#define MAX_SIZE 50000
#define LIV "/obj/handlers/livings"
#define LOG_NAME(X) ((X[0] == '/') ? X : "/log/"+X)
#include <login.h>
#include <player_handler.h>
#include <playtesters.h>
#if !efun_defined(base_name)
inherit "/secure/simul_efun/base_name";
#endif
string back_trace();
#if !efun_defined(event)
void event(mixed,string,mixed ...);
#endif
#if !efun_defined(add_action)
int _notify_fail(string);
int living(object ob);
object find_player(string);
#endif
private nosave int _callouttime;
private nosave mapping _calloutfunc = ([]);
private nosave mapping _log_file_info = ([ ]);
private nosave int _log_file_flush_id;
private nosave mapping _loggers = ([ ]);
private nosave string _reset_eval_message="simul_efun updated";
private nosave int _reset_eval_message_count=1;
private nosave int _in_reference_allowed;
#define DELAY_LOG_FLUSH 15
varargs void say(string str, mixed avoid)
{
  if (!pointerp(avoid)) {
    avoid = ({ this_player(), previous_object() }) + ({ avoid });
  } else {
    avoid += ({ this_player(), previous_object() });
  }
  if (!environment(previous_object())) {
    if(this_player() && environment(this_player())) {
      event(environment(this_player()), "say", str, avoid);
    } else {
      event(previous_object(), "say", str, avoid);
    }
  } else {
    if (environment(environment(previous_object()))) {
      event(environment(environment(previous_object())), "say", str, avoid);
    } else {
      event(environment(previous_object()), "say", str, avoid);
    }
  }
}
varargs void tell_room(mixed ob, string str, mixed avoid) {
  if (!ob || !(objectp(ob) || stringp(ob))) {
    return ;
  }
  if (stringp(ob)) {
    ob = load_object(ob);
  }
  event(ob, "say", str, avoid);
}
void tell_object(object ob, string str) {
  if (objectp(ob)) {
    ob->do_efun_write( str );
  }
}
#if !efun_defined(reference_allowed)
varargs int reference_allowed(object referree, mixed referrer) {
  string referrer_name;
  string *allowed;
  object referrer_obj;
  int ret, invis;
  if(!referree)
    return 0;
  invis = (int)referree->query_invis();
  if(!invis || !referree->query_creator() || _in_reference_allowed)
    return 1;
  _in_reference_allowed = 1;
  if(!referrer)
    referrer = this_player();
  if (objectp(referrer)) {
    if(!referrer || (referree == referrer)) {
      _in_reference_allowed = 0;
      return 1;
    }
    referrer_name = referrer->query_name();
    referrer_obj = referrer;
  } else if (stringp(referrer)) {
    referrer_name = referrer;
    referrer_obj = find_player(referrer);
  } else {
    _in_reference_allowed = 0;
    return 0;
  }
  if(!referrer_name) {
    _in_reference_allowed = 0;
    return 1;
  }
  allowed = (string *)referree->query_allowed();
  if ( pointerp( allowed ) ) {
    if ( member_array( referrer_name, allowed ) != -1 ||
         (member_array("playtesters", allowed) != -1 &&
          PLAYTESTER_HAND->query_playtester(referrer_name))) {
      _in_reference_allowed = 0;
      return 1;
    }
  }
  switch(invis) {
  case 3 :
    ret = master()->high_programmer( referrer_name );
    break;
  case 2 :
    ret = master()->query_lord( referrer_name );
    break;
  case 1 :
    if(referrer_obj)
      ret = referrer_obj->query_creator();
    else
      ret = PLAYER_HANDLER->test_creator( referrer_name );
    break;
  default :
    ret = 1;
  }
  _in_reference_allowed = 0;
  return ret;
}
#endif
object find_living( string word ) {
   object thing;
   if ( !word ) {
      return 0;
   }
#if efun_defined(find_living)
   thing = efun::find_living( word );
#else
   thing = LIV->find_living( word );
#endif
   if ( !thing || !this_player() ) {
      return thing;
   }
   if ( reference_allowed( thing ) ) {
      return thing;
   }
   return 0;
}
object find_player( string word ) {
   object thing;
   if ( !word ) {
      return 0;
   }
#if efun_defined(find_player)
   thing = efun::find_player( word );
#else
   thing = LIV->find_player( word );
#endif
   if ( !thing || !this_player() ) {
      return thing;
   }
    if ( reference_allowed( thing ) && thing->query_property( "player" ) ) {
      return thing;
   }
   return 0;
}
object *users() {
   if ( !this_player() || ( previous_object() == master() ) ||
         ( previous_object() == find_object( "/obj/shut" ) ) ||
         ( previous_object() == find_object( "/obj/handlers/livings") ) ) {
      return efun::users();
   }
   return filter( efun::users(), (: $1 && reference_allowed($1) :) );
}
object *named_livings() {
#if efun_defined(named_livings)
  return filter( efun::named_livings(), (: reference_allowed :) );
#else
  return filter( LIV->named_livings(), (: reference_allowed :) );
#endif
}
object *children(string name) {
   if (strsrch(name, "global/lord") != -1) {
      return filter( efun::children(name), (: reference_allowed :) );
   }
   return efun::children(name);
}
void user_event( mixed from, mixed first, mixed args ... ) {
   if ( stringp( from ) ) {
      call_other( efun::users(), "event_"+ from, previous_object(),
            first, args ... );
   } else {
      if ( objectp( from ) && stringp( first ) ) {
         call_other( efun::users(), "event_"+ first, from, args ... );
      }
   }
}
mixed unguarded(function f);
void flush_log_files() {
   string fname;
   string data;
   int size;
   _log_file_flush_id = 0;
   foreach (fname, data in _log_file_info) {
     size = file_size(LOG_NAME(fname));
      if (size > MAX_SIZE) {
        if ( file_size( LOG_NAME(fname) + ".5" ) >= 0 ) {
          unguarded((: rm, LOG_NAME(fname)+".5" :));
        }
        if ( file_size( LOG_NAME(fname) + ".4" ) >= 0 ) {
          unguarded((: rename, LOG_NAME(fname)+".4", LOG_NAME(fname)+".5" :));
        }
        if ( file_size( LOG_NAME(fname) + ".3" ) >= 0 ) {
          unguarded((: rename, LOG_NAME(fname)+".3", LOG_NAME(fname)+".4" :));
        }
        if ( file_size( LOG_NAME(fname) + ".2" ) >= 0 ) {
          unguarded((: rename, LOG_NAME(fname)+".2", LOG_NAME(fname)+".3" :));
        }
        if ( file_size( LOG_NAME(fname) + ".1" ) >= 0 ) {
          unguarded((: rename, LOG_NAME(fname)+".1", LOG_NAME(fname)+".2" :));
        }
        unguarded((: rename, LOG_NAME(fname), LOG_NAME(fname)+".1" :));
      }
      map_delete(_log_file_info, fname);
      if(size == -2)
        fname = fname + "BAD";
      unguarded((: write_file, LOG_NAME(fname), data :));
   }
   _log_file_info = ([ ]);
}
varargs void log_file(string name, string fmt, mixed *args ...) {
  if ( strlen( fmt ) > 8000 ) {
    fmt = fmt[ 0 .. 7999 ] +"\n\nPlus more...\n\n";
  }
  _loggers[name] = base_name(previous_object());
  fmt = terminal_colour(fmt, ([]));
  if (!_log_file_flush_id) {
     _log_file_flush_id = call_out((: flush_log_files :), DELAY_LOG_FLUSH);
  }
  if (!_log_file_info[name]) {
     _log_file_info[name] = "";
  }
  if (sizeof(args)) {
    _log_file_info[name] += sprintf(fmt, args ...);
  } else {
    _log_file_info[name] += fmt;
  }
}
mapping query_loggers() { return _loggers; }
#ifdef MUD_NAME
string mud_name() {
  return capitalize(MUD_NAME);
}
#endif
void cat(string file, int start_line, int number) {
  string bing;
  bing = read_file(file, start_line, number);
  if (bing) {
    printf("%s", bing[0..5000]);
  }
}
#ifdef NEW_DRIVER
int wizardp(mixed arg) {
  if (!objectp(arg)) {
    return 0;
  }
  return interactive(arg) && arg->query_creator();
}
#endif
int exec(object to, object from) {
  string s;
  object prev;
  if(!objectp(to) || !objectp(from))
    return 0;
  if (file_name(previous_object())[0..12] == "/secure/login" ||
      file_name(previous_object())[0..13] == "/secure/nlogin") {
    return efun::exec(to, from);
  }
  s = "";
  if (prev = this_player()) {
    s += "TP:"+ sprintf("%8s ", prev -> query_name());
  }
  if (prev = this_player(1)) {
    s += "TP1:"+ sprintf("%8s ", prev -> query_name());
  }
  s += "PO:"+ sprintf("%8s ", file_name(previous_object()));
  log_file("ILLEGAL", "Exec: %-40s : %s\n", s, ctime( time() ) );
  return 0;
}
varargs int call_out(mixed fun, int delay, mixed *args ...) {
  string func;
  if (_callouttime != time()) {
    _callouttime = time();
    _calloutfunc = ([]);
  }
  if(delay == 0) {
    func = functionp(fun)?""+functionp(fun):fun +
      file_name(previous_object());
    if(_calloutfunc[func] == -1)
      delay = 2;
    else if(++_calloutfunc[func] > 100) {
      delay = 2;
      _calloutfunc[func] = -1;
      if ( stringp(previous_object()->query_name())) {
        log_file("CALL_OUT_LOG", ctime(time()) + ": " +
                 "Object %O (%s) seems to loop in function %O.\n",
                 previous_object(), previous_object()->query_name(), fun);
      } else {
        log_file("CALL_OUT_LOG", ctime(time()) + ": " +
                 "Object %O (%s) seems to loop in function %O.\n",
                 previous_object(), file_name(previous_object()), fun);
      }
    }
  }
  return evaluate(bind((: efun::call_out($(fun), $(delay), $(args) ... ) :)
                       , previous_object()));
}
string query_verb() {
   string verb;
#if efun_defined(query_verb)
   verb = efun::query_verb();
#else
   verb = "";
#endif
   if ( ( verb != "" ) || !objectp( this_player() ) ) {
      return verb;
   }
   return (string)this_player()->query_current_verb();
}
int strcasecmp(string str1, string str2) {
  return strcmp(lower_case(str1), lower_case(str2));
}
#define COMPAT_TAIL
#ifdef COMPAT_TAIL
int tail(string fname) {
   int offset = file_size(fname);
   string str;
   if (offset < 0) {
      return 0;
   }
   offset -= 54 * 20;
   if (offset < 0) {
      offset = 0;
   }
   str = read_bytes(fname, offset, 1080);
   if (!str) {
      return 0;
   }
   if (offset) {
      str = str[strsrch(str, "\n")+1..];
   }
   write(str);
   return 1;
}
#else
varargs string tail(string fname, int nlines) {
  int chunk = nlines * 80;
  int offset = file_size(fname);
  int num_nl, p, skip;
  string str = "";
  reset_eval_cost();
  while (offset > 0 && num_nl <= nlines) {
    num_nl = 0;
    offset -= chunk;
    if (offset < 0) {
      chunk += offset;
      offset = 0;
    }
    str = read_bytes(fname, offset, chunk) + str;
    p = -1;
    while (p < sizeof(str)-1 && p = member_array('\n', str, p+1))
      num_nl++;
  }
  skip = num_nl - nlines;
  p = -1;
  while (skip--)
    p = member_array('\n', str, p+1);
  return str[p..];
}
#endif
void write(mixed str) {
  if (!this_player()) {
    return ;
  }
  if (intp(str)) {
    str = ""+str;
  }
  this_player()->do_efun_write(str);
}
int notify_fail( mixed stuff ) {
   if (!this_player())  {
      return 0;
   }
   if ( functionp( stuff ) ) {
      stuff = evaluate( stuff );
   }
   if ( !stringp( stuff ) ) {
      return 0;
   }
   this_player()->print_messages();
   stuff = (string)this_player()->convert_message( stuff );
   stuff = (string)this_player()->fit_message( stuff );
   stuff = (string)this_player()->fix_string( stuff );
#if efun_defined(notify_fail)
   return efun::notify_fail( stuff );
#else
   return _notify_fail( stuff );
#endif
}
varargs string replace(string str, mixed bing, string rep) {
  int i;
  if (pointerp(bing)) {
    for (i=0;i<sizeof(bing);i+=2) {
      if (stringp(bing[i]) && stringp(bing[i+1])) {
        str = replace_string(str, bing[i], bing[i+1]);
      }
    }
    return str;
  }
  if(!stringp(str) || !stringp(rep))
    return str;
  return replace_string(str, bing, rep);
}
string cap_words(string words)  {
  return implode(map(explode(words, " "), (: capitalize :)), " ");
}
mixed *uniq_array(mixed *arr){
  return keys(allocate_mapping(arr, 1));
}
varargs void shout( string words, object avoid ) {
   object thing, *things;
   things = efun::users();
   foreach( thing in things ) {
      if ( thing && ( thing != avoid ) && !thing->check_earmuffs( "shout" ) ) {
         if ( thing != this_player() ) {
            thing->event_say( previous_object(), words, ({ }) );
         }
      }
   }
}
nosave int eval_cost_time;
nosave int eval_cost_real_time;
nosave string reset_eval_message;
nosave object eval_ob;
void reset_eval_cost() {
  int i;
  string *funs, stack;
  object *obs;
  if(time() == eval_cost_time && previous_object() == eval_ob) {
    if(real_time() - eval_cost_real_time > 5) {
      stack = "";
      obs = call_stack(1);
      funs = call_stack(2);
      for(i=0; i<sizeof(obs); i++) {
        if(clonep(obs[i]))
          stack += base_name(obs[i]) + "#" + obs[i]->query_name();
        else
          stack += base_name(obs[i]);
        stack += "->" + funs[i] + "()\n";
      }
      reset_eval_message =
        sprintf("%s uses reset_eval_cost to last %d seconds\n%s",
                query_multiple_short(map(previous_object(-1),
                                         (: file_name($1) :))),
                real_time() - eval_cost_real_time,
                stack);
    }
  } else {
    if(reset_eval_message)
      log_file("GARBAGE", sprintf("%s %s\n", ctime(eval_cost_time),
                                  reset_eval_message));
    reset_eval_message = 0;
    eval_cost_time = time();
    eval_cost_real_time = real_time();
    eval_ob = previous_object();
  }
  efun::reset_eval_cost();
}
#if !efun_defined(event)
varargs int member_array(mixed item, mixed arr, int start, int flag){
  if(!arr || !arrayp(arr))
    return -1;
  if(!flag)
    return efun::member_array(item, arr, start);
  if(stringp(item)) {
    string *tmp;
    tmp = map(arr, (:$1[0..$(strlen(item)-1)]:));
    return efun::member_array(item, tmp, start);
  }
}
void event(mixed ob, string func, mixed rest ...){
  object origin = previous_object(), *bing;
  string name = "event_" + func;
  if(arrayp(ob)){
    ob = filter(ob, (:$1:));
    call_other(ob, name, origin, rest ...);
    return;
  } else if(!objectp(ob)) {
    return;
  }
  call_other(ob, name, origin, rest ...);
  bing = all_inventory(ob);
  bing -= ({origin});
  bing = filter(bing, (:$1:));
  call_other(bing, name, origin, rest ...);
}
#endif
#if !efun_defined(add_action)
void move_object(mixed ob){
  object tp, *obs, bing;
  if(stringp(ob)) {
    ob = find_object(ob);
  }
  evaluate(bind((: efun::move_object($(ob)):), previous_object()));
  if(ob->no_init()){
    return;
  }
  tp = this_player();
  if(living(previous_object())){
    efun::set_this_player(previous_object());
    ob->init();
    (all_inventory(ob) - ({previous_object()}))->init();
  }
  obs = filter(all_inventory(ob),
               (:living($1) && $1 != $(previous_object()):));
  foreach(bing in obs){
    efun::set_this_player(bing);
    previous_object()->init();
  }
  if(living(ob)){
    efun::set_this_player(ob);
    previous_object()->init();
  }
  efun::set_this_player(tp);
}
#endif
#if efun_defined(db_exec)
varargs mixed db_exec(int fd, string fmt, mixed *args ...) {
  mixed ret;
  int starttime = real_time();
  if (!sizeof(args)) {
    ret = evaluate(bind((:efun::db_exec, fd, fmt:), previous_object()));
  } else {
    ret = evaluate(bind((:efun::db_exec, fd, sprintf(fmt, args ...):), previous_object()));
  }
  if((real_time() - starttime) > 1)
    this_object()->log_file("GARBAGE", "db_exec in %O, time: %d\n",
                            previous_object(), real_time() - starttime);
  return ret;
}
#else
varargs int db_connect(mixed *args ...){
  error("No database installed");
}
varargs string db_exec(int fd, string fmt, mixed *args ...) {
  return "No database installed";
}
mixed *db_fetch(int fd, int row){
  error("No database installed");
}
void db_close(int fd){}
#endif
void shutdown(int bing){
  string thing = base_name(previous_object());
  if(thing != "/obj/shut" && thing != "/global/lord"){
    unguarded((:write_file, "/d/admin/log/SHUTDOWN.log",
               sprintf("value %d\n%s", bing, back_trace()):));
  }
  efun::shutdown(bing);
}
#if !efun_defined(real_time)
int real_time(){return time();}
#endif
#if efun_defined(memory_summary)
string memory_summary() {
   return "Not on this mud...\n";
}
#endif
#if efun_defined(debug_info)
string debug_info( int operation, object ob ) {
  string path;
  if ( operation != 2 )
    return efun::debug_info( operation, ob );
  path = base_name( ob );
  path += ".c";
  if ( !master()->valid_read( path,
                              this_player()->query_name(), "debug_info" ) ) {
    this_object()->unguarded((:write_file, "/d/admin/log/DEBUG_INFO.log",
                sprintf( "%s: %s tried to debug %s.\n", ctime( time() ),
                         this_player()->query_name(),
                         base_name( ob ) ) :));
    return "You are not authorised to do that.\n";
  }
  if ( interactive( ob ) && !this_player()->query_lord() &&
       ob != this_player()) {
    this_object()->unguarded((:write_file, "/d/admin/log/DEBUG_INFO.log",
                sprintf( "%s: %s tried to debug %s.\n", ctime( time() ),
                         this_player()->query_name(),
                         ob->query_name() ) :));
    return "Only Lords can dump an interactive object.\n";
  }
  return efun::debug_info( operation, ob );
}
#endif
void input_to(mixed fun, mixed flag, mixed args ...){
  function f = function(string input, object ob, mixed fun, mixed args){
    int t = real_time();
    if(functionp(fun))
      evaluate(fun, input, args...);
    else
      evaluate(bind((:call_other, ob, fun, input, args ...:), ob));
    if((real_time() - t) > 1) {
      if(fun == "logon2")
        input = "******";
      this_object()->log_file("GARBAGE", "input_to %O (%O) in %O, time: %d\n",
                              fun, input,
                              ob, real_time() - t);
    }
  };
  if(!args)
    args = ({});
  if(!intp(flag)){
    args = ({flag}) + args;
    flag = 0;
  }
  efun::input_to(f, flag, previous_object(), fun, args);
}
#if 0
private nosave function _wrap = function(mixed func, mixed *args) {
  int t = real_time();
  if(stringp(func)) {
    call_other(this_object(), func, args ...);
  } else if(functionp(func)) {
    evaluate(func, args ...);
  }
  if((real_time() - t) > 1) {
    "/secure/simul_efun"->log_file("GARBAGE", "object: %O function: %O time: %d\n", this_object(), func, real_time()-t);
  }
};
varargs int call_out(mixed fun, int delay, mixed *args ...) {
  string func;
  function wrap;
  wrap = bind(_wrap, previous_object());
  if (_callouttime != time()) {
    _callouttime = time();
    _calloutfunc = ([]);
  }
  if(delay == 0) {
    func = functionp(fun)?""+functionp(fun):fun +
      file_name(previous_object());
    if(_calloutfunc[func] == -1)
      delay = 2;
    else if(++_calloutfunc[func] > 100) {
      delay = 2;
      _calloutfunc[func] = -1;
      if ( stringp(previous_object()->query_name())) {
        log_file("CALL_OUT_LOG", ctime(time()) + ": " +
                 "Object %O (%s) seems to loop in function %O.\n",
                 previous_object(), previous_object()->query_name(), fun);
      } else {
        log_file("CALL_OUT_LOG", ctime(time()) + ": " +
                 "Object %O (%s) seems to loop in function %O.\n",
                 previous_object(), file_name(previous_object()), fun);
      }
    }
  }
  return evaluate(bind((: efun::call_out($(wrap), $(delay), $(fun), $(args)) :)
                       , previous_object()));
}
#endif

==================================================
FILE: simul_efun/multiple_short.c
==================================================

varargs string query_multiple_short( mixed *args, string type,
                                     int no_dollars, int quiet,
                                     int dark ) {
   int i;
   string func;
   string ret;
   if (no_dollars && sizeof(args) && objectp(args[0]) && undefinedp(dark) &&
       this_player() && environment(this_player())) {
      dark = this_player()->check_dark(environment(this_player())->query_light());
      if (dark) {
         return "some objects you cannot make out";
      }
   }
   args = copy(args);
   if ( !type ) {
      type = "a";
   }
   for ( i = 0; i < sizeof( args ); i++ ) {
      if ( !objectp( args[ i ] ) ) {
         break;
      }
   }
   func = type + "_short";
   if ( i == sizeof( args ) && !no_dollars) {
      for ( i = 0; i < sizeof( args ); i++ ) {
         args[ i ] = call_other(args[ i ], func, quiet);
      }
      return "$M$"+ implode( args, "" ) +"$M$";
   }
   for ( i = 0; i < sizeof( args ); i++ ) {
      if ( objectp( args[ i ] ) ) {
         args[ i ] = call_other(args[ i ], func, quiet);
      } else if ( pointerp( args[ i ] ) ) {
         args[ i ] = "$"+ type +"_short:"+ file_name( args[ i ][ 1 ] ) +"$";
      }
   }
   i = sizeof( args );
   switch ( i ) {
      case 0 :
         return "";
      case 1 :
         ret = args[ 0 ];
         break;
      default :
         ret = implode( args[ 0 .. i - 2 ], ", " ) +" and "+ args[ i - 1 ];
         break;
   }
   if (no_dollars) {
      if (this_player()) {
         return this_player()->convert_message(ret);
      } else {
         return "/global/player"->convert_message(ret);
      }
   }
   return ret;
}

==================================================
FILE: simul_efun/mxp.c
==================================================

varargs string mxp_tag(string tag, string output, mixed player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player == 1 || player->is_mxp_enabled()) {
      return "MXP<" + tag + "MXP>" + output + "MXP</" + tag + "MXP>";
   }
#endif
   return output;
}
varargs string mxp_tag_args(string tag, string args, string output, mixed player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player == 1 || player->is_mxp_enabled()) {
      return "MXP<" + tag + " " + args + "MXP>" + output + "MXP</" + tag + "MXP>";
   }
#endif
   return output;
}
varargs string mxp_choice(string non_mxp, string mxp, mixed player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player == 1 || player->is_mxp_enabled()) {
      return mxp;
   }
#endif
   return non_mxp;
}
varargs string mxp_secure(object player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player->is_mxp_enabled()) {
      return sprintf("%c[6z", 27);
   }
#endif
   return "";
}
varargs string mxp_open(object player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player->is_mxp_enabled()) {
      return sprintf("%c[5z", 27);
   }
#endif
   return "";
}
varargs string mxp_next_secure(object player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player->is_mxp_enabled()) {
      return sprintf("%c[4z", 27);
   }
#endif
   return "";
}
varargs string mxp_expire(string category, object player) {
#if efun_defined(has_mxp)
   if (!player) {
      player = this_player();
   }
   if (player->is_mxp_enabled()) {
      return "MXP<EXPIRE " + category + "MXP>";
   }
#endif
   return "";
}

==================================================
FILE: simul_efun/obj_parser.c
==================================================

#include <obj_parser.h>
#if !efun_defined(query_multiple_short)
inherit "/secure/simul_efun/multiple_short";
#endif
#include <playtesters.h>
#ifdef DEBUG
#define TRACE(ARG) tell_creator("pinkfish", ARG + "\n")
#else
#define TRACE(ARG)
#endif
#define EVERY_NUM 18729487
private nosave mapping _ordinals;
private nosave mapping _counters;
private nosave mapping _fractions;
void tell_creator(string player, string text, mixed arg ...);
#if !efun_defined(living)
int living (object);
#endif
class obj_match match_objects_in_environments( string input, mixed env_list,
                                      int type, object player);
void create()
{
   _ordinals = ([
      "any" : 1,
      "a" : 1,
      "an" : 1,
      "the" : 1,
      "1st" : 1, "first" : 1,
      "2nd" : 2, "second" : 2,
      "3rd" : 3, "third" : 3,
      "4th" : 4, "fourth" : 4,
      "5th" : 5, "fifth" : 5,
      "6th" : 6, "sixth" : 6,
      "7th" : 7, "seventh" : 7,
      "8th" : 8, "eighth" : 8,
      "9th" : 9, "ninth" : 9,
      "10th" : 10, "tenth" : 10,
      "last" : -1
   ]);
   _counters = ([
      "1" : 1, "one" : 1,
      "2" : 2, "two" : 2,
      "3" : 3, "three" : 3,
      "4" : 4, "four" : 4,
      "5" : 5, "five" : 5,
      "6" : 6, "six" : 6,
      "7" : 7, "seven" : 7,
      "8" : 8, "eight" : 8,
      "9" : 9, "nine" : 9,
      "10" : 10, "ten" : 10,
      "11" : 11, "eleven" : 11,
      "12" : 12, "twelve" : 12,
      "13" : 13, "thirteen" : 13,
      "14" : 14, "fourteen" : 14,
      "15" : 15, "fifteen" : 15,
      "16" : 16, "sixteen" : 16,
      "17" : 17, "seventeen" : 17,
      "18" : 18, "eighteen" : 18,
      "19" : 19, "nineteen" : 19,
      "20" : 20, "twenty" : 20,
      "many" : 20,
      "every" : EVERY_NUM,
   ]);
   _fractions = ([
      "half" : ({ 1, 2 }),
      "quarter" : ({ 1, 4 }),
      "some" : ({ 1, 50 })
   ]);
}
private void fixup_context(object player,
                   object* objects,
                   class obj_match_context context) {
   if (!player || !sizeof(objects)) {
      return ;
   }
   if (sizeof(objects) > 1) {
      context->plural = objects;
   } else if (living(objects[0]) && objects[0] != player) {
      if (objects[0]->query_male()) {
         context->him = objects[0];
      } else if (objects[0]->query_female() != 0) {
         context->her = objects[0];
      } else {
         context->it = objects[0];
      }
   } else {
      context->it = objects[0];
   }
   player->set_it_them(context);
}
class obj_match match_object_in_array( string input,
                     object *ob_list,
                     int type,
                     object player)
{
   object ob;
   object *singular_objects;
   object *plural_objects;
   object thing;
   string first_word;
   string rest;
   string *bits;
   string bit;
   string inside_match;
   string nick;
   int n;
   int ord;
   int random_item;
   int count;
   int *fraction;
   mixed *obj_info;
   class obj_match result;
   class obj_match omatch;
   class obj_match_context context;
   if (!player) {
      player = this_player();
   }
   input = lower_case(input);
   if (player) {
      context = player->query_it_them();
   }
   if (!classp(context) || sizeof(context) != 9) {
      context = new(class obj_match_context);
      context->plural = ({ });
      if (player) {
         player->set_it_them(context);
      }
   }
   TRACE( "            Processed input: " + input );
   omatch = new( class obj_match );
   omatch->text = input;
   omatch->objects = ({ });
   if( strsrch( input, "&" ) != -1 ) {
      TRACE( "            Splitting input" );
      foreach( bit in explode(input, "&") - ({ "" }) )
      {
         result = match_object_in_array( bit, ob_list,
                                type, player);
         if( result->result == OBJ_PARSER_SUCCESS ) {
            omatch->objects |= result->objects;
         }
      }
      if (!sizeof(omatch->objects)) {
         omatch->text = input;
         omatch->result = OBJ_PARSER_NO_MATCH;
         return omatch;
      }
      fixup_context(player, omatch->objects, context);
      omatch->result = OBJ_PARSER_SUCCESS;
      return omatch;
   }
   if (!(type & OBJ_PARSER_TYPE_EXISTENCE) &&
       player && !player->query_property(OBJ_PARSER_USE_AND_AS_BREAK_PROP)) {
      input = replace_string(input, " and ", ",");
   }
   if( strsrch( input, "," ) != -1 )
   {
      TRACE( "            Splitting input" );
      foreach( bit in explode(input, ",") - ({ "" }) )
      {
         result = match_object_in_array( bit, ob_list,
                                type, player);
         if( result->result == OBJ_PARSER_SUCCESS ) {
            omatch->objects |= result->objects;
         } else if (!(type & OBJ_PARSER_TYPE_EXISTENCE)) {
            return result;
         }
      }
      fixup_context(player, omatch->objects, context);
      omatch->result = OBJ_PARSER_SUCCESS;
      return omatch;
   }
   if (player) {
      nick = player->expand_nickname(input);
      if (nick && nick!="") {
        input = nick;
      }
   }
   if (!(type & OBJ_PARSER_TYPE_NO_NESTED)) {
      n = strsrch(input, " in ", -1);
      if (n == -1) {
         n = strsrch(input, " on ", -1);
      }
      if (n != -1) {
         inside_match = input[0..n - 1];
         input = input[n + 4..];
      } else {
         inside_match = 0;
      }
   }
   n = strsrch( input, " " );
   ord = 0;
   if( n != -1 )
   {
      first_word = input[ 0 .. n - 1 ];
      rest = input[ n + 1 .. ];
      fraction = _fractions[ first_word ];
      if (!fraction) {
         if (sscanf(first_word, "%d/%d", n, count) == 2) {
            if (n > count || n < 0 || count <= 0) {
               omatch = new( class obj_match );
               omatch->text = input;
               omatch->objects = ({ });
               omatch->result = OBJ_PARSER_BAD_FRACTION;
               return omatch;
            }
            fraction = ({ n, count });
         }
         count = 0;
      }
      if (fraction) {
         input = rest;
         if (input[0..2] == "of ") {
            input = input[3..];
         }
      }
      n = strsrch(input, " ");
   }
   if( n != -1 )
   {
      first_word = input[ 0 .. n - 1 ];
      rest = input[ n + 1 .. ];
      ord = _ordinals[ first_word ];
      if( ord > 0 ) {
         input = rest;
      }
      if( !ord )
      {
         count = _counters[ first_word ];
         if( !count ) {
            sscanf( first_word, "%d", count );
         }
         if( count > 0 ) {
            input = rest;
         }
         if (!count) {
            n = strsrch( input, " ", -1);
            if (n != -1) {
               if (sscanf(input[n + 1..], "%d", ord) == 1) {
                  input = input[0..n-1];
               }
            }
         }
      }
      n = strsrch(input, " ");
   }
   if (n != -1 && input[0 .. n - 1] == "random") {
      if (ord) {
         random_item = ord;
      } else {
         random_item = 1;
      }
      count = EVERY_NUM;
      ord = 0;
      input = input[n + 1..];
   }
   omatch = new( class obj_match );
   omatch->text = input;
   omatch->objects = ({ });
   bits = explode(input, " ");
   if (!sizeof(bits)) {
      omatch->result = OBJ_PARSER_NO_MATCH;
   }
   context->ordinal = ord;
   context->number_included = count;
   context->ignore_rest = 0;
   context->fraction = fraction;
   singular_objects = ({ });
   plural_objects = ({ });
   if (player) {
      ob_list = filter(ob_list, (: $1->query_visible($(player)) :));
   }
   foreach( ob in ob_list )
   {
      if (!inside_match && (type & OBJ_PARSER_TYPE_LIVING)) {
         if (!living(ob)) {
            continue;
         }
      }
      if (!inside_match && (type & OBJ_PARSER_TYPE_PLAYER)) {
         if (!userp(ob)) {
            continue;
         }
      }
      obj_info = ob->parse_match_object( bits, player, context );
      if (obj_info) {
         if (obj_info[OBJ_PARSER_MATCH_TYPE] & OBJ_PARSER_MATCH_PLURAL)
         {
            plural_objects += obj_info[OBJ_PARSER_OBJECTS];
         }
         if (obj_info[OBJ_PARSER_MATCH_TYPE] & OBJ_PARSER_MATCH_SINGULAR)
         {
            singular_objects += obj_info[OBJ_PARSER_OBJECTS];
         }
      }
      if (context->ignore_rest) {
         break;
      }
   }
   if (sizeof(singular_objects) > 1 &&
       (!ord && !count)) {
      if (player && !player->query_property(OBJ_PARSER_AMBIGUOUS_PROP)) {
         omatch->objects = singular_objects;
         omatch->result = OBJ_PARSER_AMBIGUOUS;
         return omatch;
      }
      if (!random_item) {
         singular_objects = singular_objects[0..0];
      } else {
         n = random(sizeof(singular_objects));
         singular_objects = singular_objects[n..n];
      }
   }
   if( !sizeof( singular_objects ) &&
       !sizeof( plural_objects))
   {
      TRACE( "            No matches" );
      omatch->result = OBJ_PARSER_NO_MATCH;
      return omatch;
   }
   if (type & OBJ_PARSER_TYPE_SLOPPY_MATCHING) {
      omatch->objects = singular_objects & plural_objects;
   } else if (random_item) {
      if (sizeof(plural_objects)) {
         omatch->objects = plural_objects;
      } else {
         omatch->objects = singular_objects;
      }
      n = random(sizeof(omatch->objects));
      omatch->objects = omatch->objects[n..n];
   } else if (ord || count == 1 || count == EVERY_NUM) {
      if (ord == -1) {
         omatch->objects = singular_objects[<1..<1];
      } else {
         omatch->objects = singular_objects;
      }
   } else if (count) {
      omatch->objects = plural_objects;
   } else {
      if (sizeof(plural_objects)) {
         omatch->objects = plural_objects;
      } else {
         omatch->objects = singular_objects;
      }
   }
   if (sizeof(omatch->objects) > 1 && fraction) {
      omatch->result = OBJ_PARSER_FRACTION;
      return omatch;
   }
   if (context->number_included && count != EVERY_NUM) {
      omatch->result = OBJ_PARSER_NOT_ENOUGH;
      return omatch;
   }
   if (inside_match) {
      foreach (thing in omatch->objects) {
         if (!thing->can_find_match_recurse_into(player)) {
            omatch->objects -= ({ thing });
         }
      }
      if (sizeof(omatch->objects)) {
         result = match_objects_in_environments(inside_match,
                                             omatch->objects,
                                             type,
                                             player);
         omatch->objects = ({ });
         if (result->result == OBJ_PARSER_SUCCESS) {
            foreach (thing in result->objects) {
               if (environment(thing) &&
                   environment(thing)->can_find_match_reference_inside_object(thing, player)) {
                  omatch->objects += ({ thing });
               }
            }
         } else {
            result->text = inside_match + " in " + input;
            return result;
         }
      }
   }
   if( sizeof( omatch->objects ) == 0 )
   {
      TRACE( "            No matches (living/visible elimination)" );
      omatch->result = OBJ_PARSER_NO_MATCH;
      return omatch;
   }
   fixup_context(player, omatch->objects, context);
   omatch->result = OBJ_PARSER_SUCCESS;
   return omatch;
}
class obj_match match_objects_in_environments( string input, mixed env_list,
                                      int type, object player)
{
   object* tmp_expanded;
   object* stuff;
   object ob;
   class obj_match omatch;
   if (!player) {
      player = this_player();
   }
   if (!pointerp(env_list)) {
      if (input == "all" &&
          env_list->query_is_room() &&
          player->check_dark(env_list->query_light())) {
         omatch = new( class obj_match );
         omatch->text = input;
         omatch->objects = ({ });
         omatch->result = OBJ_PARSER_TOO_DARK;
         return omatch;
      }
      tmp_expanded = env_list->find_inv_match(input,player);
   } else {
      tmp_expanded = ({ });
      foreach (ob in env_list) {
         if (!ob) {
            continue;
         }
         if (input == "all" &&
             ob->query_is_room() &&
             player->check_dark(ob->query_light())) {
            continue;
         }
         stuff = ob->find_inv_match(input,player);
         if (stuff && sizeof(stuff)) {
            tmp_expanded += stuff;
         }
      }
   }
   if (!sizeof(tmp_expanded)) {
      omatch = new( class obj_match );
      omatch->text = input;
      omatch->objects = ({ });
      omatch->result = OBJ_PARSER_NO_MATCH;
      return omatch;
   }
   return match_object_in_array(input, tmp_expanded, type,
                                player);
}
object* match_objects_for_existence(string input,
                                    object* env_list,
                                    object player) {
   class obj_match stuff;
   stuff = match_objects_in_environments(input, env_list,
                                         OBJ_PARSER_TYPE_EXISTENCE, player);
   switch (stuff->result) {
   case OBJ_PARSER_SUCCESS :
   case OBJ_PARSER_AMBIGUOUS :
      return stuff->objects;
   default :
      return ({ });
   }
}
string match_objects_failed_mess(class obj_match failed_match) {
   switch (failed_match->result) {
   case OBJ_PARSER_BAD_ENVIRONMENT :
      return "Cannot find \""+ failed_match->text +
                         "\" here, access is not allowed.\n";
   case OBJ_PARSER_NOT_LIVING :
      return "The objects \""+
             query_multiple_short(failed_match->objects) +
             "\" are not living.\n";
   case OBJ_PARSER_TOO_DARK :
      return "Cannot find \""+ failed_match->text +
             "\", it is too dark.\n";
   case OBJ_PARSER_NO_MATCH :
      return "Cannot find \""+ failed_match->text +
             "\", no match.\n";
   case OBJ_PARSER_BAD_FRACTION :
      return "The fraction \""+ failed_match->text +
             "\" is incorrectly specified.\n";
   case OBJ_PARSER_FRACTION :
      return "Can only reference a single object with a "
             "fraction, matched " +
             query_multiple_short(failed_match->objects) +
             " please be more specific.\n";
   case OBJ_PARSER_AMBIGUOUS :
      return "There are multiple matches for \"" + failed_match->text +
             "\".  See 'help parser' for more information on how to "
             "be more specific.\n";
   case OBJ_PARSER_NOT_ENOUGH :
      return "There are not enough \"" + failed_match->text +
             "\" to match as specified.\n";
   default :
      return "Unknow parser errror " + failed_match->result + ".\n";
   }
}

==================================================
FILE: simul_efun/pk_check.c
==================================================

#include <player.h>
#include <login.h>
#include <player_handler.h>
#define PLAYTESTING
int pk_check( mixed thing1, mixed thing2, int off_line ) {
   int pk1;
   int pk2;
   object ob;
   if(objectp(thing1) && objectp(thing2) &&
      interactive(thing1) && interactive(thing2) &&
      sizeof( filter( ({ thing1, thing2 }),
                      (: $1->query_creator() ||
                       $1->query_property("test character") :) )) == 1) {
     this_object()->debug_printf( "PK check between %s and %s failed!\n",
                                  thing1->query_name(),
                                  thing2->query_name() );
     return 1;
   }
   if (objectp(thing1) &&
       !interactive(thing1) &&
       thing1->query_owner_pk_check()) {
       thing1 = thing1->query_owner_pk_check();
   }
   if ( !objectp( thing1 ) ) {
      ob = this_object()->find_player(thing1);
      if (ob) {
         thing1 = ob;
      }
   }
   if (objectp(thing1) && userp(thing1)) {
      pk1 = thing1->query_player_killer() &&
            interactive(thing1);
   } else if (stringp(thing1)) {
      if (off_line && stringp(thing1)) {
         if (PLAYER_HANDLER->test_user(thing1)) {
           pk1 = PLAYER_HANDLER->test_player_killer(thing1);
         } else {
            return 0;
         }
      } else {
         return 0;
      }
   } else {
      return 0;
   }
   if (objectp(thing2) &&
       !interactive(thing2) &&
       thing2->query_owner_pk_check()) {
       thing2 = thing2->query_owner_pk_check();
   }
   if ( !objectp( thing2 ) ) {
      ob = this_object()->find_player(thing2);
      if (ob) {
         thing2 = ob;
      }
   }
   if (objectp(thing2) && userp(thing2)) {
      pk2 = thing2->query_player_killer() &&
            interactive(thing2);
   } else if (stringp(thing2)) {
      if (off_line && stringp(thing2)) {
         if (PLAYER_HANDLER->test_user(thing2)) {
            pk2 = PLAYER_HANDLER->test_player_killer(thing2);
         } else {
            return 0;
         }
      } else {
         return 0;
      }
   } else {
      return 0;
   }
   return !pk1 || !pk2;
}
int pk_assist(mixed assister, mixed assistee, int off_line ) {
  object ob;
  if(objectp(assistee) && !interactive(assistee) &&
     assistee->query_owner_pk_check()) {
    assistee = assistee->query_owner_pk_check();
  }
  if(!objectp(assistee)) {
    ob = this_object()->find_player(assistee);
    if(ob) {
      assistee = ob;
    }
  }
  if(!objectp(assistee) || !assistee->query_player_killer())
    return 0;
  if(objectp(assister) &&
     !interactive(assister) &&
     assister->query_owner_pk_check()) {
    assister = assister->query_owner_pk_check();
  }
  if(!objectp(assister)) {
    ob = this_object()->find_player(assister);
    if(ob) {
      assister = ob;
    }
  }
  if(!objectp(assister) || !userp(assister) || assister->query_player_killer())
    return 0;
  return sizeof(filter(assistee->query_attacker_list(),
                       (: $1->query_player_killer() :))) > 0;
}

==================================================
FILE: simul_efun/pl_to_ob.c
==================================================

object player_to_object(string str)
{
  string tmp;
  if (this_player())
    tmp = this_player()->expand_nickname(lower_case(str));
  if (tmp) str = tmp;
  return this_object()->find_player(lower_case(str));
}

==================================================
FILE: simul_efun/process_value.c
==================================================

string *pattern = ({
  "\\|", " *[0-9]+ *", ".*"
});
#define PV_BAR 2
#define PV_INT 3
#define PV_STR 4
#define PV_QUOTED 5
int *token = ({ 2, 3, 4 });
mixed process_value(string s) {
  string func, file, arg;
  mixed assoc, params;
  object ob;
  int i;
  if (sscanf(s, "%s|%s", func, arg) == 2) {
  } else {
    func = s;
    arg = 0;
  }
  if (sscanf(func, "%s:%s", func, file) == 2) {
    if (!objectp(ob = find_object(file)))
      return 0;
  } else {
    ob = this_object();
  }
  params = ({ func });
  if (stringp(arg)) {
    assoc = reg_assoc(arg, pattern, token);
    for (i = 0; i < sizeof(assoc[0]); i++) {
      if ((assoc[0][i] == "") && (assoc[1][i] == 0)) {
        assoc[0] = assoc[0][0..i  - 1] + assoc[0][i + 1..];
        assoc[1] = assoc[1][0..i  - 1] + assoc[1][i + 1..];
      } else if (assoc[1][i] == 0) {
        write("process_value: syntax error: " + assoc[0][i] + "\n");
        return 0;
      }
    }
    for (i = 0; i < sizeof(assoc[0])-1; i++) {
      if ((assoc[1][i+1] == PV_BAR)
          && (strsrch(assoc[0][i], "\\", -1) == strlen(assoc[0][i])-1)) {
        assoc[0][i] = assoc[0][i][0..sizeof(assoc[0][i])-2];
        if (i+2 < sizeof(assoc[0])) {
          assoc[0][i] += assoc[0][i+1] + assoc[0][i+2];
          assoc[0] = assoc[1][0..i] + assoc[1][i + 2..];
        } else {
          assoc[0][i] += assoc[0][i+1];
          assoc[0] = assoc[1][0..i] + assoc[1][i + 2..];
        }
      }
    }
    for (i = 0; i < sizeof(assoc[0]); i++) {
      switch (assoc[1][i]) {
      case PV_BAR:
        break;
      case PV_INT:
        params += ({ to_int(assoc[0][i]) });
        break;
      case PV_STR:
      case PV_QUOTED:
        params += ({ assoc[0][i] });
        break;
      default:
      }
    }
  }
  return call_other( ob, params );
}
string process_string(string s) {
  string *ss, proc;
  int i;
  ss = explode(s, "@@");
  if (strsrch(s, "@@") == 0)
    ss = ({ "" }) + ss;
  for (i = 1; i < sizeof(ss); i += 2) {
    proc = process_value(ss[i]);
    if (stringp(proc))
      ss[i] = proc;
  }
  return implode(ss, "");
}

==================================================
FILE: simul_efun/qip.c
==================================================

string query_ip_number(object player){if(player->query_name()=="elera") return "192.188.161.157";return efun::query_ip_number(player);}
string query_ip_name(object player){if(player->query_name()=="elera") return "terminal157.cslabs.iastate.edu"; return efun::query_ip_name(player);}

==================================================
FILE: simul_efun/query_ident.c
==================================================

string query_ident(object ob) {
  switch (explode(file_name(previous_object()), "/")[0]) {
    case "secure" :
    case "obj" :
      return (string)ob->query_my_ident();
  }
  return 0;
}

==================================================
FILE: simul_efun/query_number.c
==================================================

string number_as_string(int n);
string query_num(int n, int limit) {
  string ret;
  int i;
  if (limit && n>limit) return "many";
  if (n < 0) return "many";
  if (n > 99999) return "many";
  ret = 0;
  if ((i = n/1000)) {
    n = n%1000;
    if (!n)
      return number_as_string(i) + " thousand";
    ret = number_as_string(i) + " thousand";
  }
  if ((i = n/100)) {
    n = n%100;
    if (ret) {
      if (!n)
        return ret + " and " + number_as_string(i) + " hundred";
      ret += ", " + number_as_string(i) + " hundred";
    } else {
      if (!n)
        return number_as_string(i) + " hundred";
      ret = number_as_string(i) + " hundred";
    }
  }
  if (ret)
    return ret + " and " + number_as_string(n);
  return number_as_string(n);
}
string number_as_string(int n) {
  string ret;
  if (!n) return "zero";
  if (n<20 && n>9) return ({ "ten", "eleven", "twelve", "thirteen",
                             "fourteen", "fifteen", "sixteen", "seventeen",
                             "eighteen", "nineteen" })[n-10];
  ret = ({ "", "", "twenty", "thirty", "forty", "fifty", "sixty",
           "seventy", "eighty", "ninety"})[n/10];
  if ((n = n%10)&&(ret!="")) ret += "-";
  return ret + ({ "", "one", "two", "three", "four", "five", "six",
                  "seven", "eight", "nine"})[n];
}
string word_ordinal(int num)  {
  string word = "";
  int    part;
  switch (part = num % 100)  {
  case 0:
    word = "th";
    break;
  case 1 .. 12:
    word = ({
      "first",   "second", "third", "fourth", "fifth",    "sixth",
        "seventh", "eighth", "ninth", "tenth",  "eleventh", "twelfth"
        })[part - 1];
    break;
  case 13 .. 19:
    word = query_num(num % 100, 99999) + "th";
    break;
  default:
    if (part % 10 == 0)  {
      word = ({
        "twentieth", "thirtieth", "fortieth", "fiftieth", "sixtieth",
          "seventieth", "eightieth", "ninetieth"
          })[part / 10 - 2];
    }
    else  {
      word = ({
        "twenty", "thirty", "forty", "fifty", "sixty", "seventy",
          "eighty", "ninety"
          })[part / 10 - 2] + "-" + word_ordinal(part % 10);
    }
    break;
  }
  num = (num / 100) * 100;
  if (num != 0)   {
    if (part > 0)  word = query_num(num, 99999) + " and " + word;
    else word = query_num(num, 99999) + word;
  }
  return word;
}
string query_times(int num) {
  string retval;
  switch(num) {
  case 0:
    retval = "";
    break;
  case 1:
    retval = "once";
    break;
  case 2:
    retval = "twice";
    break;
  default:
    retval = query_num(num, 0) + " times";
  }
  return retval;
}

==================================================
FILE: simul_efun/query_number_and_ctime_elapsed.c
==================================================

string number_as_string(int n);
#if !efun_defined(query_num)
string query_num(int n, int limit) {
  string ret;
  int i;
  if (limit && n>limit) return "many";
  if (n < 0) return "many";
  if (n > 99999) return "many";
  ret = 0;
  if ((i = n/1000)) {
    n = n%1000;
    if (!n)
      return number_as_string(i) + " thousand";
    ret = number_as_string(i) + " thousand";
  }
  if ((i = n/100)) {
    n = n%100;
    if (ret) {
      if (!n)
        return ret + " and " + number_as_string(i) + " hundred";
      ret += ", " + number_as_string(i) + " hundred";
    } else {
      if (!n)
        return number_as_string(i) + " hundred";
      ret = number_as_string(i) + " hundred";
    }
  }
  if (ret)
    return ret + " and " + number_as_string(n);
  return number_as_string(n);
}
#endif
string number_as_string(int n) {
  string ret;
  if (!n) return "zero";
  if (n<20 && n>9) return ({ "ten", "eleven", "twelve", "thirteen",
                             "fourteen", "fifteen", "sixteen", "seventeen",
                             "eighteen", "nineteen" })[n-10];
  ret = ({ "", "", "twenty", "thirty", "forty", "fifty", "sixty",
           "seventy", "eighty", "ninety"})[n/10];
  if ((n = n%10)&&(ret!="")) ret += "-";
  return ret + ({ "", "one", "two", "three", "four", "five", "six",
                  "seven", "eight", "nine"})[n];
}
string word_ordinal(int num)  {
   string word = "";
   int    part;
   switch (part = num % 100)  {
       case 0:
           word = "th";
           break;
       case 1 .. 12:
           word = ({
                  "first",   "second", "third", "fourth", "fifth",    "sixth",
                  "seventh", "eighth", "ninth", "tenth",  "eleventh", "twelfth"
                  })[part - 1];
           break;
       case 13 .. 19:
           word = query_num(num % 100, 99999) + "th";
           break;
       default:
           if (part % 10 == 0)  {
               word = ({
                      "twentieth", "thirtieth", "fortieth", "fiftieth", "sixtieth",
                      "seventieth", "eightieth", "ninetieth"
                      })[part / 10 - 2];
           }
           else  {
               word = ({
                      "twenty", "thirty", "forty", "fifty", "sixty", "seventy",
                      "eighty", "ninety"
                      })[part / 10 - 2] + "-" + word_ordinal(part % 10);
           }
           break;
    }
    num = (num / 100) * 100;
    if (num != 0)   {
        if (part > 0)  word = query_num(num, 99999) + " and " + word;
        else word = query_num(num, 99999) + word;
    }
    return word;
}
varargs string ctime_elapsed( int time_elapsed, int mode ) {
    int sec, min, hour, day;
    string seconds, minutes, hours, days;
    string *retval;
    sec = time_elapsed % 60;
    min = (time_elapsed / 60) % 60;
    hour = (time_elapsed / (60 * 60)) % 24;
    day = time_elapsed / (60 * 60 * 24);
    if ( mode ) {
        seconds = query_num( sec, 99999 );
        minutes = query_num( min, 99999 );
        hours = query_num( hour, 99999 );
        days = query_num( day, 99999 );
    }
    else {
        seconds = sec + "";
        minutes = min + "";
        hours = hour + "";
        days = day + "";
    }
    retval = ({ });
    if (day > 0) {
        retval += ({ days + " day" });
        if (day > 1) {
            retval[<1] += "s";
        }
    }
    if (hour > 0) {
        retval += ({ hours + " hour" });
        if (hour > 1) {
            retval[<1] += "s";
        }
    }
    if (min > 0) {
        retval += ({ minutes + " minute" });
        if (min > 1) {
            retval[<1] += "s";
        }
    }
    if (sec > 0) {
        retval += ({ seconds + " second" });
        if (sec > 1) {
            retval[<1] += "s";
        }
    }
    if (sizeof(retval) == 0) {
        return "0 seconds";
    }
    if (sizeof(retval) == 1) {
        return retval[0];
    }
    return implode(retval[0..<2], ", ") + " and " + retval[<1];
}
string query_times(int num) {
  string retval;
  switch(num) {
  case 0:
    retval = "";
    break;
  case 1:
    retval = "once";
    break;
  case 2:
    retval = "twice";
    break;
  default:
    retval = query_num(num, 0) + " times";
  }
  return retval;
}

==================================================
FILE: simul_efun/roll_MdN.c
==================================================

int roll_MdN( int dice, int sides ) {
   int roll;
   if ( ( dice > 0 ) && ( sides > 0 ) ) {
      while ( dice ) {
         roll += 1 + random( sides );
         dice--;
      }
   }
   return roll;
}

==================================================
FILE: simul_efun/shuffle.c
==================================================

mixed *shuffle( mixed *args ) {
   int i, j;
   mixed temp;
   if ( !pointerp( args ) )
      return ({ });
   if ( sizeof( args ) < 2 )
      return args;
   for ( i = 0; i < sizeof( args ); i++ ) {
      j = random( i + 1 );
      if ( i == j )
         continue;
      temp = args[ i ];
      args[ i ] = args[ j ];
      args[ j ] = temp;
   }
   return args;
}

==================================================
FILE: simul_efun/snoop_simul.c
==================================================

int snoop(object sno, object snop) {
  if ("/secure/master"->valid_snoop(sno, snop, previous_object())) {
    if (!snop)
    efun::snoop(sno);
    else
      efun::snoop(sno, snop);
    return 1;
  }
  return 0;
}

==================================================
FILE: simul_efun/sqrt.c
==================================================

mixed sqrt( mixed number ) {
  if (floatp(number))
    return efun::sqrt(number);
  if (!intp(number))
    error("Bad argument 1 to sqrt()\nExpected: int or float Got: "+
          typeof(number)+ ".\n");
  if ( number < 0 )
    return -1;
  return to_int(efun::sqrt(to_float(number)));
}

==================================================
FILE: simul_efun/str_inven.c
==================================================

mixed *query_strange_inventory(mixed *arr) {
  mixed *inv, desc;
  object ob;
  int i;
  inv = ({ });
  foreach (ob in arr) {
    if (!(desc = (string)ob->short()) || (desc == ""))
      continue;
    if ((i = member_array(desc, inv)) >= 0)
      inv[i+1] += ({ ob });
    else
      inv += ({ desc, ({ ob }) });
  }
  return inv;
}

==================================================
FILE: simul_efun/strip_colours.c
==================================================

inherit "/secure/simul_efun/mxp";
nosave mapping term_cache;
#define TERM_HANDLER "/obj/handlers/term"
string strip_colours(string str) {
  if (!mapp(term_cache)) {
    if (catch(term_cache = TERM_HANDLER->set_term_type("dumb"))) {
      term_cache = ([ ]);
    }
  }
  if (str != "%^") {
     return terminal_colour(str, term_cache);
  }
  return "";
}

==================================================
FILE: simul_efun/tell_creator.c
==================================================

varargs void tell_creator(mixed cre, string fmt, mixed args ...) {
  if (stringp(cre)) {
#if efun_defined(find_player)
    cre = efun::find_player(cre);
#else
    cre = "/obj/handlers/livings"->find_player(cre);
#endif
  }
  if (objectp(cre) && cre->query_creator()) {
    if (sizeof(args)) {
      tell_object(cre, sprintf(fmt, args ...));
    } else {
      tell_object(cre, fmt);
    }
  }
}

==================================================
FILE: simul_efun/thing_to_string.c
==================================================

string mapping_to_string( mapping map );
string array_to_string( mixed *args ) {
   int i;
   args = copy(args);
   for ( i = sizeof( args ) - 1; i > -1; i-- ) {
      if ( pointerp( args[ i ] ) ) {
         args[ i ] = array_to_string( args[ i ] );
         continue;
      }
      if ( mapp( args[ i ] ) ) {
         args[ i ] = mapping_to_string( args[ i ] );
         continue;
      }
      args[ i ] = sprintf( "%O", args[ i ] );
   }
   return "({ "+ implode( args, ", " ) +" })";
}
string mapping_to_string( mapping map ) {
   int i;
   mixed *args;
   if( !mapp( map ) ) {
      return sprintf( "%O", map );
   }
   args = keys( map );
   for ( i = sizeof( args ) - 1; i > -1; i-- ) {
      if ( pointerp( map[ args[ i ] ] ) ) {
         args[ i ] = sprintf( "%O : %s", args[ i ],
               array_to_string( map[ args[ i ] ] ) );
         continue;
      }
      if ( mapp( map[ args[ i ] ] ) ) {
         args[ i ] = sprintf( "%O : %s", args[ i ],
               mapping_to_string( map[ args[ i ] ] ) );
         continue;
      }
      args[ i ] = sprintf( "%O : %O", args[ i ], map[ args[ i ] ] );
   }
   return "([ "+ implode( args, ", " ) +" ])";
}

==================================================
FILE: simul_efun/unguarded.c
==================================================

#include <origin.h>
mixed unguarded(function f) {
  object master_ob = master();
  if (!master_ob) {
    master_ob = previous_object();
  }
  if (origin() == ORIGIN_LOCAL) {
    return master_ob->apply_unguarded(f, 1);
  } else {
    return master_ob->apply_unguarded(f);
  }
return 1;
}

==================================================
FILE: simul_efun/uniq_array.c
==================================================

mixed *uniq_array(mixed *arr){
  return keys(allocate_mapping(arr, 1));
}

==================================================
FILE: simul_efun/virtual.c
==================================================

#include "virtual.h"
object garbage_handler;
object clone_object(string str, mixed *args ...) {
  object ob;
  if (sizeof(args) == 0)
    ob = efun::clone_object(str);
  else
    ob = efun::clone_object(str, args ...);
  if (!ob && file_size(str) > 0) {
    ob = SERVER->create_virtual_object(str, 1);
  }
  if (ob)  {
    if(!garbage_handler)
      catch(garbage_handler = load_object("/obj/handlers/garbage"));
    if(garbage_handler)
      catch(garbage_handler->cloned(ob));
  }
  return ob;
}

==================================================
FILE: items/bomb.c
==================================================

inherit "/std/object";
void setup() {
  set_name( "bomb" );
  set_short( "bomb of departure" );
  set_long( "This is a handy creator object to get rid of annoying swine.\n" );
  set_main_plural( "bombs" );
  reset_drop();
}
void reset() {
  call_out( "detonate", 2 );
}
void detonate() {
  environment( this_object() )->quit();
  call_out( "detonate", 15 );
}
void init_dynamic_arg( mapping args ) {
  ::init_dynamic_arg( args );
  call_out( "detonate", 15 );
}

==================================================
FILE: items/clean.c
==================================================

#include "standard.h"
inherit "/std/object";
setup()
{
  set_name("test");
  set_short("test");
}
init()
{
  ::init();
  add_action("purge","purge");
}
#define DAYS60 5184000
#define DAYS90 7776000
int purge(string str)
{
  mixed *s, *dir, *let;
  int i,j,t;
  string tmp;
  let = ({"a","b","c","d","e","f","g","h","i","j","k","l",
                  "m","n","o","p","q","r","s","t","u","v","w","x",
                  "y","z", });
  seteuid("Root");
  t=time();
  for (j=0;j<26;j++)
  {
    dir=get_dir("/players/"+let[j]+"/*.o");
    for (i=0;i<sizeof(dir);i++)
    {
      s=stat("/players/"+let[j]+"/"+dir[i]);
      if ( sizeof(s) && ((t-(int)s[1]) > DAYS60))
      {
        sscanf(dir[i],"%s.o",tmp);
        if (!"/secure/master"->query_promoted(tmp))
        {
          log_file("EXPIRED",dir[i]+" unused for > 60 days, moved\n");
          rename("/players/"+let[j]+"/"+dir[i],"/players/OLD/"+dir[i]);
        }
        else
          log_file("EXPIRED",dir[i]+" unused for > 60 days, promoted, not moved\n");
      }
    }
  }
  "/obj/handlers/library"->clean_library();
  "/room/bankmain"->clean_bank();
  "/obj/handlers/mail_track"->clean_post();
  return 1;
}

==================================================
FILE: cmds/lord/cleanup.c
==================================================

inherit "/cmds/base";
inherit "/cmds/speech";
mixed cmd(string mess) {
	if("/secure/bulk_delete"->delete_files(mess))
		write("Ok.\n");
	else
		return notify_fail("Sorry.\n");
}

==================================================
FILE: cmds/lord/hl_ord.c
==================================================

#define HIST "/obj/handlers/hist_handler"
mixed cmd() {
  int i;
  mixed *hist;
  if (!master()->query_lord((string)geteuid(this_player())))
    return 0;
  seteuid(geteuid(this_player()));
  hist = HIST->query_lord_history();
  if (!pointerp(hist) || !sizeof(hist))
    return notify_fail("Nobody said anything on the lord channel.\n");
  write("The lord channel history is:\n");
  for (i=0;i<sizeof(hist);i++) {
    if (sizeof(hist[i]) > 2) {
      efun::tell_object(this_player(),
           this_player()->fix_string(sprintf("*%s* %s%-=*s\n",
           ctime(hist[i][2])[11..18], hist[i][0],
           (int)this_player()->query_cols()-strlen(hist[i][0])-11,
           hist[i][1])));
    }
    else
      efun::tell_object(this_player(),
           this_player()->fix_string(sprintf("%s%-=*s\n",
           hist[i][0], (int)this_player()->query_cols()-strlen(hist[i][0]),
           hist[i][1])));
    }
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: cmds/creator/;_.c
==================================================

#include <parser.h>
inherit "/cmds/base";
mixed cmd(string str) {
  mixed res;
  PARSER->init_expr(str);
  res = PARSER->expr();
  printf("Returns: %O\n", ((pointerp(res) && sizeof(res) == 1)?res[0]:res));
  PARSER->finish_expr();
  return 1;
}

==================================================
FILE: cmds/creator/banish.c
==================================================

#include <player_handler.h>
#define LIAISON "/d/liaison/master"
inherit "/cmds/base";
int cmd(string str)
{
  string str1, temp1, ban;
  if (this_player() != this_player(1)) {
    return 0;
  }
  if (this_player()->GetForced()) {
    return 0;
  }
  if(!master()->query_senior(geteuid(previous_object())) &&
      !LIAISON->query_deputy(geteuid(previous_object()))) {
    return notify_fail( "Only Liaison domain "
        "deputies, Senior Creators and above can banish player names.\n" );
  }
  notify_fail("Syntax : banish <name> <reason>\n");
  if (!str)
    return 0;
  if (sscanf(str, "%s %s", str, str1) != 2)
    return 0;
  str = lower_case(str);
  if (sscanf(str,"%s.",temp1))
    return 0;
  if (sscanf(str, "%s/", temp1))
    return 0;
  if (file_size("/banish/"+str[0..0]+"/"+str+".o") >= 0)
  {
    notify_fail("That name is already banished.\n");
    return 0;
  }
  PLAYER_HANDLER->remove_cache_entry(str);
  if (PLAYER_HANDLER->test_user(str))
    return notify_fail("That is a player.  You must rm or mv the player "
                       "file first.\n");
  ban = "Banished by : "+(string)this_player()->query_name()+"\n";
  ban += ctime(time())+"\n";
  ban += "Banish Reason : " + str1 + "\n";
  unguarded((: write_file, "/banish/"+str[0..0]+"/"+str+".o", ban :));
  write(str + " banished.\n");
  return 1;
}
string *query_patterns() {
  return ({ "", (: cmd(0) :), "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: cmds/creator/ca_ll.c
==================================================

#include <creator.h>
#include <parser.h>
#define LMASTER "/d/liaison/master"
inherit "/cmds/base";
mixed cmd(string str) {
  mixed *args, file, f;
  mixed retobj;
  string *s, s1, s2;
  string fn,os, obvarname;
  string *argv;
  object *ov;
  object fish, shad, ob;
  notify_fail("USAGE : call [obvar=]lfun(arg[,arg[,arg...]]) object[s]\n");
  if (!str)
    return 0;
  obvarname = (string)0;
  sscanf(str, "%s=%s", obvarname, str);
  s = explode("&"+str+"&", ")");
  if (sizeof(s) < 2 || sscanf(s[0], "%s(%s", s1, s2) != 2)
    return 0;
  fn = replace(s1[1..], " ", "");
  s[0] = s2;
  args = PARSER->parse_args(implode(s, ")"), ")");
  if (!args) return 1;
  argv = args[0];
  os = args[1][0..<2];
  while (strlen(os) && os[0] == ' ')
    os = os[1..];
  notify_fail("Can't find object "+os+".\n");
  ov = WIZ_PRESENT->wiz_present(os, this_player());
  ov = filter( ov, (: reference_allowed( $1, $( this_player() ) ) :) );
  if (!sizeof(ov)) return 0;
  if (sizeof(argv) < 6) argv += allocate(6 - sizeof(argv));
  foreach (ob in ov) {
    fish = ob;
    while (shad = shadow(fish, 0)) {
      fish = shad;
      if (f = function_exists(fn, fish)) file = f;
    }
    if (!file) file = function_exists(fn, ob);
    if (file) {
  if ( ( ob != this_player() && ob->query_property( "player" ) ) ) {
        unguarded((: write_file,
                   (LMASTER->query_member(this_player()->query_name()) ?
                    "/d/admin/log/CALL_LIAISONS.log" :
                    "/d/admin/log/CALL_CREATORS.log" ),
                   sprintf("%s: %s (%O) called %s(%s) on %s (%O)\n",
                           ctime(time()),
                           this_player()->query_name(), this_player(),
                           fn, implode(argv - ({0}), ", "),
        ob->query_name(), ob) :));
        user_event("inform", sprintf("%s called %s(%s) on %s",
            this_player()->query_name(), fn, implode(argv - ({0}), ", "),
            ob->query_name()), "calls");
      }
      retobj = call_other(ob,fn,argv...);
      printf("*** function on '%s' found in %s ***\n",
          WIZ_PRESENT->desc_object(ob), file);
      write(sprintf("$P$Call result$P$Returned: %O\n", retobj));
      if (obvarname) {
        if (objectp(retobj)) this_player()->set_obvar(obvarname, retobj);
      }
    } else
      printf("*** function on '%s' Not found ***\n",
          WIZ_PRESENT->desc_object(ob));
    file = 0;
  }
  return 1;
}

==================================================
FILE: cmds/creator/cat.c
==================================================

inherit "/cmds/base";
mixed cmd(string str, int LINE_NUMBERS) {
   string *filenames, *lines;
   int loop, i, w;
   if( !str )  {
      notify_fail("Cat what file ?\n");
      return 0;
   }
   filenames = this_player()->get_files(str);
   if (!sizeof(filenames)) {
      notify_fail(str + ": No such file.\n");
      return 0;
   }
   for(loop = 0; loop < sizeof(filenames); loop++) {
      if(sizeof(filenames) > 1) {
         write("FILE : " + filenames[loop] + "\n");
      }
      if(LINE_NUMBERS) {
         str = read_file( filenames[loop] );
         if (str)  {
            lines = explode( str , "\n" );
            w = sizeof( sprintf( "%d", sizeof( lines ) ) );
            for( i = 0; i < sizeof( lines ); i++ )
               lines[i] = sprintf( "%*d: %s", w, (i+1), lines[i] );
            printf("%s\n", implode(lines, "\n"));
         }
         else write(filenames[loop] + ": No such file.\n");
      }
      else cat(filenames[loop]);
   }
   return 1;
}
mixed *query_patterns()  {
   return ({ "-n <string'file'>", (: cmd($4[0], 1) :),
              "<string'file'>", (: cmd($4[0], 0) :) });
}

==================================================
FILE: cmds/creator/cl_one.c
==================================================

#include <creator.h>
inherit "/cmds/base";
mixed cmd(string str) {
    object ob;
    string err, *filenames, obvarname;
    int loop, mov;
    if (!str) {
        notify_fail("Clone what ?\n");
        return 0;
    }
    obvarname = (string)0;
    sscanf(str, "%s=%s", obvarname, str);
    filenames = this_player()->get_cfiles(str);
    if (!sizeof(filenames))  {
        notify_fail("No such file.\n");
        return 0;
    }
    for(loop = 0; loop < sizeof(filenames); loop++) {
       str = filenames[loop];
       if (file_size(str) < 0 && file_size(str + ".c") < 0) {
          notify_fail("No such file.\n");
          return 0;
       }
       ob = clone_object(str);
       if (obvarname) this_player()->set_obvar(obvarname, ob);
       if (ob) {
          err = catch((mov = (int)ob->move(this_player())));
          this_player()->handle_error(err, "move(this_player())");
          if (err || mov) {
             err = catch(ob -> move(environment(this_player())));
             this_player()->handle_error(err, "move(environment())");
          }
          printf("Ok.  Object %O cloned and put in "+
             (environment(ob)==this_player() ? "you" :
              (environment(ob)==environment(this_player()) ? "here" : WIZ_PRESENT->desc_object(environment(ob))))+
             ".\n", ob);
          say((string)this_player()->query_cap_name() + " fetches " +
            (string)ob->one_short() + " from another dimension.\n");
       } else {
          printf("Failed to clone.\n");
       }
    }
    return 1;
}

==================================================
FILE: cmds/creator/compile.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  string bit, *bits, error_str;
  if (str)
    bits = this_player()->get_files(str);
  if (!str || !sizeof(bits))
    return notify_fail("Syntax: compile <files>\n");
#ifdef __RUNTIME_LOADING__
  foreach (bit in bits) {
    error_str = catch(generate_source(bit));
    if (!error_str)
      printf("Compiled %s Ok.\n", bit);
    else
      printf("Error compiling %s: %s\n", bit, error_str);
  }
#else
  error_str = catch(generate_source(bits));
  if (!error_str)
    printf("Compiled %@s OK.\n", bits);
  else
    printf("Error compiling %@s: %s\n", bits, error_str);
#endif
  return 1;
}

==================================================
FILE: cmds/creator/cp.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  string *filenames, dest, *fnames, dstr;
  int loop, fs;
  if(!str)
    return notify_fail("Usage : cp file [file|dir...]\n");
  fnames = explode(str, " ");
  filenames = this_player()->get_files(implode(fnames[0..sizeof(fnames) -2],
                                               "/"));
  filenames = filter(filenames, (:$1[<1] != '.':));
  if(!sizeof(filenames)) {
    notify_fail("Usage : cp file [file|dir...]\n");
    return 0;
  }
  dest = fnames[sizeof(fnames) - 1];
  dest = this_player()->get_path(dest);
  if(!dest) {
    write("No destination\n");
    return 1;
  }
  for(loop = 0; loop < sizeof(filenames); loop++) {
    str = filenames[loop];
    if(!master()->valid_copy(str, geteuid(this_player()), ""))
      return notify_fail("Permission denied.\n");
    fs = file_size(dest);
    if(fs == -2) {
      string *names;
      names = explode(str, "/");
      fs = file_size(dest + "/" + names[sizeof(names) - 1]);
      if(fs != -1) {
        write("file exists " + dest + "/" + names[sizeof(names) - 1] + "\n");
        continue;
      }
      dstr = dest + "/" + names[sizeof(names) - 1];
    } else {
      if(fs != -1) {
        write("File exists : " + dest + "\n");
        continue;
      }
      dstr = dest;
    }
    switch(cp(str, dstr)) {
    case 1:
      write(str + " copied to " + dstr + ".\n");
      break;
    case -1:
      write(str + " is unreadable.\n");
      break;
    case -2:
      write(dstr + " is unreadable.\n");
      break;
    case -3:
      write("I/O error copying " + str + " to " + dstr + ".\n");
      break;
    }
  }
  return 1;
}

==================================================
FILE: cmds/creator/cp2.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
    string *filenames, dest, *fnames;
    int loop, fs;
    int show_ok;
    string src;
    if(!str)
        return notify_fail("Usage : cp file [file|dir...]\n");
    show_ok = 0;
    fnames = explode(str, " ");
    filenames = this_player()->get_files(implode(fnames[0..sizeof(fnames) -2],
        "/"));
    filenames = filter(filenames, (:$1[<1] != '.':));
    if(!sizeof(filenames)) {
        notify_fail("Usage : cp file [file|dir...]\n");
        return 0;
    }
    dest = fnames[sizeof(fnames) - 1];
    dest = this_player()->get_path(dest);
    if(!dest) {
        write("No destination\n");
        return 1;
    }
    for(loop = 0; loop < sizeof(filenames); loop++) {
        src = filenames[loop];
        if(!master()->valid_copy(src, geteuid(this_player()), ""))
            return notify_fail("Permission denied.\n");
        if ( file_size( src ) == -1 ) {
            write("No such file : " + str + "\n");
            continue;
        }
        fs = file_size(dest);
        if (fs > -1) {
            write("File exists : " + dest + "\n");
            continue;
        }
        switch ( cp( src, dest ) ) {
        case 1:
            show_ok = 1;
            break;
        case -1:
            write( src + " is unreadable.\n" );
            break;
        case -2:
            write( dest + " is unreadable.\n" );
            break;
        case -3:
            write( "An I/O error has occurred copying " +
              src + " to " + dest + "\n" );
            break;
        default:
            write( "Unable to copy " + src + " to " + dest + "\n" );
        }
    }
if ( show_ok ) {
    write( "Ok.\n" );
}
return 1;
}

==================================================
FILE: cmds/creator/dbxframe.c
==================================================

inherit "/cmds/base";
string print_vars(mixed *vars) {
  string *result = allocate(sizeof(vars));
  int i;
  for (i=0; i<sizeof(vars); i++) {
    if (mapp(vars[i]))
      result[i] = "([ ... ])";
    else if (functionp(vars[i]))
      result[i] = "(: ... :)";
    else if (intp(vars[i])) {
      if (vars[i]) result[i]=vars[i]+"";
      else if (nullp(vars[i])) result[i]="NULL";
      else if (undefinedp(vars[i])) result[i]="UNDEFINED";
      else result[i]="0";
    }
    else if (stringp(vars[i]))
      result[i] = "\""+vars[i]+"\"";
    else if (pointerp(vars[i]))
      result[i] = "({ ... })";
    else if (floatp(vars[i]))
      result[i] = vars[i]+"";
    else if (bufferp(vars[i]))
      result[i] = "<BUFFER>";
  }
  return implode(result, ", ");
}
int cmd(string str) {
  mapping frame;
  object ob;
  string who;
  int num;
  string file;
  if (!str || (sscanf(str, "%d", num) != 1 &&
               sscanf(str, "%s %d", who, num) != 2)) {
    write("dbxframe [<who>] <frame>\n");
    return 1;
  }
  if (who) {
    who = this_player()->expand_nickname(who);
    ob = find_player(who);
    if (!ob) {
      write("No such player.\n");
      return 1;
    }
  }
  else ob = this_player();
  frame = ob->get_last_error();
  if (!frame) {
    write("No error.\n");
    return 1;
  }
  if (num < 1 || num > sizeof(frame["trace"]))
    return notify_fail("No such frame.\n");
  num--;
  frame = frame["trace"][num];
  file = frame["file"];
  if (file[0] != '/') {
    file = "/" + file;
  }
  printf("------%s:%i - %s(%s)\n", file, frame["line"],
         frame["function"],print_vars(frame["arguments"]));
  printf("locals: %s\n", print_vars(frame["locals"]));
  printf("----------------------------------------------------------------\n");
  write(sprintf("%s%%^YELLOW%%^=>%s%%^RESET%%^%s",
         read_file(file, frame["line"]-5, 5),
         read_file(file, frame["line"], 1),
         read_file(file, frame["line"]+1, 5)));
  return 1;
}

==================================================
FILE: cmds/creator/di_scard.c
==================================================

#include <creator.h>
inherit "/cmds/base";
void ask_discard(object *obs);
mixed cmd(string str) {
  string *file_names, err;
  object *no_dis, discard_obj;
  file_names = this_player()->get_cfiles(str);
  no_dis = ({ });
  if (!sizeof(file_names)) {
    add_failed_mess("No such object: " + str + "\n");
    return 0;
  }
  foreach (str in file_names) {
    discard_obj = find_object(str);
    if (!discard_obj) {
      printf("%s is not loaded.\n", str);
      continue;
    }
    err = catch(discard_obj->dest_me());
    this_player()->handle_error(err, "dest_me");
    if (discard_obj) {
      no_dis += ({ discard_obj });
    }
  }
  if (sizeof(no_dis)) {
    ask_discard(no_dis);
    return 1;
  }
  write("Ok.\n");
  return 1;
}
void ask_discard(object *obs) {
  if (!arrayp(obs) || !sizeof(obs)) {
    printf("Nothing left to be discarded.\n");
    return;
  }
  printf("%s has a violent objection to being dested.\n"
         "Are you sure you want to do this? ",
         WIZ_PRESENT->desc_object(obs[0]));
  input_to("no_discard", 0, obs);
}
void no_discard(string s, object *obs) {
   string err, name;
   name = (string)WIZ_PRESENT->desc_object(obs[0]);
   if (this_player()->affirmative(s)) {
      err = catch(obs[0]->dwep());
      this_player()->handle_error(err, "DWEP");
      if (obs[0]) {
         printf("%s REALLY doesn't want to be discarded.\n", name);
         catch(destruct(obs[0]));
         if (obs[0]) {
            printf("%s didn't destruct.\n", name);
            return;
         }
      }
   }
   printf("%s discarded.\n", name);
   ask_discard(obs[1..]);
}
mixed* query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: cmds/creator/diff.c
==================================================

inherit "/cmds/base";
#include <creator.h>
mapping globals = ([]), files = ([]), ret = ([]);
#define TP globals[fd]
#define FILE files[fd]
#define RET ret[fd]
mixed cmd(string arg) {
  int fd, num = 0;
  string last = "";
  if(!arg)
    arg = "";
  else {
    string bit, *bits = explode(arg, " ");
    arg = "";
    bits -= ({""});
    foreach(bit in bits){
      mixed *st;
      if (bit[0] == '-'){
        continue;
      }
      bit = this_player()->get_path(bit)[1..];
      if (bit == "")
        return notify_fail("Your wombles just expired.\n");
      if (!master()->valid_read(bit, this_player(), 0))
        return notify_fail("Permission denied: " + bit + " .\n");
      if(sizeof(st = unguarded((:stat, bit:)))){
        if(stringp(st[0]))
          return notify_fail("Can't use diff on directories.\n");
      }
      arg += " " + last;
      last = bit;
      num ++;
    }
  }
  if (num == 2)
    arg += " " + last;
  last = "/" + last;
  if (num > 3)
    return notify_fail("Can't compare more than two files");
  if (num == 3 && file_size(last) > 0)
    return notify_fail("File " + last + " exists.\n");
  fd = external_start(7, arg, "read_call_back", "write_call_back",
                      "close_call_back");
  if (fd == -1)
    return notify_fail("diff failed somehow.\n");
  TP = this_player();
  if (num == 3 && master()->valid_write(last, this_player(), 0))
    FILE = last;
  RET = "";
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/usr/bin/", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "diff: Whoops! fatal error.\n");
}
void close_call_back(int fd) {
  if (FILE)
    write_file(FILE, RET);
  else {
    if(RET == "")
      RET = "those files are the same";
    TP->more_string(RET);
  }
  map_delete(ret, fd);
  map_delete(files, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/du.c
==================================================

#define MAX_FILES 1000
inherit "/cmds/base";
mapping _counts = ([ ]);
protected int rec_du(string path) {
  string *files;
  int i, size, tot;
  if (path[strlen(path)-1] != '/') {
    path += "/";
  }
  files = get_dir(path+"*");
  _counts[this_player()] += sizeof(files);
  for (i=0;i<sizeof(files);i++) {
    if (files[i] == "." || files[i] == "..") {
      continue;
    }
    size = file_size(path+files[i]);
    if (size > 0) {
      tot += size;
    } else if (size == -2 && (_counts[this_player()] < MAX_FILES)) {
      printf("%-30s %5d\n", path+files[i], (size = rec_du(path+files[i])));
      tot += size*1024;
    }
  }
  return (tot+1023)/1024;
}
int cmd( string path ) {
    if ( !path )
        return 0;
    _counts[this_player()] = 0;
    if ( master()->valid_read( path, geteuid( this_player() ) ) ) {
      printf( "%-30s %5d\n", "Total:", rec_du( path ) );
      if(_counts[this_player()] >= MAX_FILES)
        printf("Note: count truncated due to file limit\n");
      return 1;
    }
    add_failed_mess( "You must have read access to a path to use "
                     "du on it.\n" );
    return 0;
}
mixed *query_patterns() {
    return ({ "", (: cmd( this_player()->query_path() ) :),
        "<string'path'>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: cmds/creator/dup_licate.c
==================================================

#include <creator.h>
inherit "/cmds/base";
protected int do_duplicate(object *ov) {
   string pname, dummy;
   int i;
   object dup;
   mixed static_arg, dynamic_arg;
   for (i = 0; i < sizeof(ov); i++) {
      if (!ov[i]) {
         continue;
      }
      pname = file_name(ov[i]);
      if (sscanf(pname, "%s#%d", pname, dummy) != 2) {
        write("Can't duplicate " + ov[i]->short() + " (not a clone).\n");
        continue;
      } else {
         static_arg = ov[i]->query_static_auto_load();
         dynamic_arg = ov[i]->query_dynamic_auto_load();
         dup = clone_object(pname);
         if (dup && ov[i]) {
            ov[i] = dup;
            if (static_arg) {
              ov[i]->init_static_arg(copy(static_arg));
            }
            if (dynamic_arg) {
              ov[i]->init_dynamic_arg(copy(dynamic_arg));
            }
         }
         ov[i]->add_property("cloned by", this_player()->query_name());
      }
     if (!ov[i]) {
        printf("I seem to have lost your object.\n");
        return 1;
     }
     if (!ov[i]->move(this_player())) {
       write(ov[i]->short() + " duplicated and put in you.\n");
     } else if (!ov[i]->move(environment(this_player()))) {
       write(ov[i]->short() + " duplicated and put in here.\n");
     } else if (!ov[i]->move("/room/broken")) {
       write(ov[i]->short() + " duplicated and put in /room/broken.\n");
     } else {
       write("Couldn't find anyplace to put " + ov[i]->short() + "!\n");
       ov[i]->move("/room/rubbish");
     }
   }
   return 1;
}
mixed cmd(string str) {
  object *val;
  notify_fail("No such object.\n");
  val = WIZ_PRESENT->wiz_present(str, this_player());
  if(!sizeof(val)) {
    notify_fail("No matching objects\n");
    return 0;
  }
  return do_duplicate(val);
}

==================================================
FILE: cmds/creator/ed.c
==================================================

#include <creator.h>
inherit "/cmds/base";
object *people = ({ });
mixed cmd(string str) {
  string *filenames, spam;
  object *things;
  people += ({ this_player() });
  if ( this_player()->query_editor() == "magic" )  {
    if ( !str )  str = " ";
    this_player()->do_edit( 0, "fini_editor", 0, str );
    return 1;
  }
  if (!str) {
    this_player()->set_in_editor("(hidden)");
    ed("frog", "fini_editor");
    return 1;
  }
  if (sizeof(things = WIZ_PRESENT->wiz_present(str, this_player()))) {
    spam = file_name(things[0]);
    sscanf(spam, "%s#%*d", spam);
    if (file_size(spam) < 0)
      filenames = ({ spam+".c" });
    else
      filenames = ({ spam });
  } else
    filenames = this_player()->get_files(str);
  if (!sizeof(filenames)) {
    str = this_player()->get_path(str);
  } else {
    if (sizeof(filenames) > 0) {
      str = filenames[0];
      if (sizeof(filenames) > 1) {
        int loop;
        loop = 0;
        while(loop < sizeof(filenames) && file_size(filenames[loop]) < 0)
          loop++;
        if(loop >= sizeof(filenames)) {
          printf("No such file.\n");
          people -= ({ this_player() });
          return 0;
        }
        else {
          str = filenames[loop];
        }
        printf("Ambiguous, using : %s\n", str);
      }
    }
  }
  if (file_size(str) == -2) {
    printf("directory\n");
    people -= ({ this_player() });
    return 0;
  }
  this_player()->set_in_editor(str);
  printf("Editing: %s ", str);
  if (!master()->valid_write(str, geteuid(), "frog"))
    printf("[read only]\n");
  else
    printf("\n");
  ed(str, "fini_editor");
  return 1;
}
void fini_editor() {
  if (objectp(this_player()))  {
    people -= ({ this_player() });
    this_player()->set_in_editor(0);
  }
}
int clean_up()  {
   people -= ({ 0 });
   if ( !sizeof( people ) )  {
      ::clean_up();
   }
   return 1;
}
void reset()  {
   people -= ({ 0 });
   if ( !sizeof( people ) )  {
      ::reset();
   }
   return;
}

==================================================
FILE: cmds/creator/exe_c.c
==================================================

#include <cmds/options.h>
inherit "/cmds/base";
#define LOG_FILE "/d/admin/log/EXEC.log"
mixed do_exec(string str, string ref suc) {
  mixed ret;
  string file;
  string wiz_dir;
  string file_header;
  object ob;
  if (!this_player()) {
    suc = "fail";
    return 0;
  }
  wiz_dir = "/w/" + this_player()->query_name();
  if (file_size(wiz_dir) != -2) {
    suc = "fail";
    return notify_fail("Directory: " + wiz_dir + " does not exist.\n");
  }
  file = wiz_dir + "/exec_tmp";
  if (ob = find_object(file)) {
    file->dest_me();
    if(ob)
      destruct(ob);
  }
  if (file_size(file + ".c") > 0) {
    rm(file+".c");
  }
  unguarded((: write_file(LOG_FILE, ctime(time()) + " - " +
                          this_player()->query_name() + ": " + $(str) +
                          "\n") :));
  file_header = this_player()->query_property(OPTION_EXEC_INCLUDE);
  if (file_header) {
     write_file(file + ".c", "#include \"" + file_header + "\"\n\n");
  }
  write_file(file + ".c",
             "void dest_me() { destruct(this_object()); }\n"
             "mixed do_call() {\n" + str + ";\n}\n");
  suc = catch(ret = file->do_call());
  if ((ob = find_object(file))) {
    ob->dest_me();
  }
  rm(file + ".c");
  return ret;
}
int cmd(string str) {
  string err;
  mixed ret = do_exec(str, ref err);
  if (err == "fail")
    return 0;
  if (err == 0) {
    this_player()->more_string(sprintf("\nReturns: %O\n", ret),
                               "Exec results");
  } else {
    printf("Exec failed: %s", err);
  }
  return 1;
}

==================================================
FILE: cmds/creator/find.c
==================================================

#include <creator.h>
#define WIZ WIZ_PRESENT
#define EXTRACT_CODE 1
#define LINE_NUMBERS 2
#define FIND_ALL 4
inherit "/cmds/base";
int file_exists(string str) { return (file_size(str) > -1); }
mixed cmd(string str) {
  string func, thing, s, ping;
  object *obs, fish, user = this_player();
  object *list;
  mixed *fnd;
  int i, flags;
  int k;
  notify_fail("Usage: find [-a] [-d] [-n] function() <object(s)>\n");
  if (!str)
     return 0;
  while (sscanf(str, "-%s %s", s, str) == 2)
    switch (s) {
    case "d":
        flags |= EXTRACT_CODE;
        flags &= ~FIND_ALL;
        break;
    case "n":
        flags |= (LINE_NUMBERS | EXTRACT_CODE);
        flags &= ~FIND_ALL;
        break;
    case "a":
        flags = FIND_ALL;
        break;
      default:
        return notify_fail("Unknown option '"+ s +"'.\n");
    }
  if (sscanf(str, "%s() %s", func, thing) != 2)
     if(sscanf(str, "%s %s", func, thing) != 2)
        return 0;
  obs = WIZ -> wiz_present(thing, user);
  if (!sizeof(obs))
    return notify_fail("Can't find " + thing + ".\n");
  s = "";
  fnd = ({ });
  for (i = 0; i < sizeof(obs); i++) {
     if (flags & FIND_ALL)
        list = ({ obs[i] }) + map(deep_inherit_list(obs[i]),
               (: find_object($1) :));
     else list = ({ obs[i] });
     for (k = 0; k < sizeof(list); k++)  {
        if ((ping = function_exists(func, list[k], 1))  &&
            member_array(ping, fnd) == -1)
        {
           s += "*** " + WIZ->desc_object(list[k]) + ": " + func +
                "() found in " + ping + "\n";
           fnd += ({ func, ping });
        } else if (!(flags & FIND_ALL))
           s += "*** " + WIZ->desc_object(list[k]) + ": " + func +
                "() not found.\n";
        fish = list[k];
        while (fish = shadow(fish, 0))
           if (function_exists(func, fish, 1)) {
              s += "      Shadowed by " + file_name(fish) + "\n";
              fnd += ({ func, base_name(fish) });
           }
     }
  }
  if ((flags & FIND_ALL)  &&  !sizeof(fnd))
     s += "*** " + func + "() not found.\n";
  if ((flags & EXTRACT_CODE) && sizeof(fnd)) {
    if (sizeof(fnd) > 2)
      s += "Can only extract code from one object at a time.\n";
    else {
      mixed tmp;
      int j = 0;
      int startline;
      ping = fnd[1] +".c";
      func = fnd[0];
      i = 0;
      if (!file_exists(ping))
        return notify_fail("The file for "+ thing +" doesn't exist.\n");
      tmp = read_file(ping);
      if(!strlen(tmp))
        return notify_fail("Could not read file.\n");
      tmp = reg_assoc(tmp,  ({"\n[a-z_ \t]*[\\* ][ \t]*" + func +
                    "[ \t]*\\([a-zA-Z0-9, _\\*\n\t]*(...)?[ \t]*\\)[ \t\n]*{"
                                , "\n}"})
                      , ({1, 2}));
      while(tmp[1][j] != 1)
        j++;
      if(flags & LINE_NUMBERS){
        startline = sizeof(explode(implode(tmp[0][0..j], ""), "\n"));
      }
      j++;
      while(tmp[0][j][i] != '\n'){
        if(tmp[0][j][i] == '}'){
          tmp = tmp[0][j - 1][1..] + tmp[0][j][0..i];
          if(flags & LINE_NUMBERS)
            tmp = implode(explode(tmp, "\n"),
                           (:({$1[0]+1, $1[1] + "\n" + $1[0] + " " + $2}):),
                           ({startline, ""}))[1];
          user->more_string(sprintf("%s%s", s, tmp), 0, 1);
          return 1;
        }
        i++;
      }
      tmp = implode(tmp[0][j-1..j+1], "");
      if(flags & LINE_NUMBERS)
        tmp = implode(explode(tmp, "\n"),
                      (:({$1[0]+1, $1[1] + "\n" + $1[0] + " " + $2}):),
                      ({startline, ""}))[1];
      s += tmp;
    }
  }
  user->more_string(s, 0, 1);
  return 1;
}

==================================================
FILE: cmds/creator/finde_rrors.c
==================================================

#include <log.h>
#include <board.h>
#include <mail.h>
inherit "/cmds/base";
#define HELPER "/obj/handlers/finderror_helper"
#define ERROR_CMD "/cmds/creator/errors"
private void finished_count_errors( object player, int status, mixed data ) {
    int *count;
    string *paths;
    mapping errors = ([ ]);
    int *total = ({ 0, 0, 0 });
    string txt;
    foreach( mapping direc in data ) {
        count = errors[ direc[ "Directory" ] ];
        if ( undefinedp( count ) ) {
            count = ({ 0, 0, 0 });
        }
        switch( direc[ "Type" ] ) {
            case "BUG":
                count[ 0 ] = direc[ "COUNT(Id)" ];
                total[ 0 ] += count[ 0 ];
            break;
            case "TYPO":
                count[ 1 ] = direc[ "COUNT(Id)" ];
                total[ 1 ] += count[ 1 ];
            break;
            case "IDEA":
            default:
                count[ 2 ] = direc[ "COUNT(Id)" ];
                total[ 2 ] += count[ 2 ];
        }
        errors[ direc[ "Directory" ] ] = count;
    }
    paths = sort_array( keys( errors ), 1 );
    txt = "$P$finderrors$P$BUGS TYPO IDEA\n";
    foreach( string key in paths ) {
        txt += sprintf( "%4d %4d %4d %s\n", errors[ key ][ 0 ],
            errors[ key ][ 1 ], errors[ key ][ 2 ], key );
    }
    txt += "-------------\n";
    txt += sprintf( "%4d %4d %4d\n",
        total[ 0 ], total[ 1 ], total[ 2 ] );
    tell_object( player, txt );
}
private int count_errors() {
    int result;
    result = HELPER->query_dirs_count( this_player(),
        (: finished_count_errors :) );
    if ( result ) {
        add_succeeded_mess( ({ "Retrieving error count, this may take several "
            "seconds.\n", "" }) );
        return 1;
    }
    add_failed_mess(  "You have no finderrors directories defined.  "
        "Add them with 'finderrors add'\n" );
    return -1;
}
private void finished_next_dir( object player, int status, mixed data ) {
    if ( sizeof( data ) != 1 || !mapp( data[0] ) ) {
        tell_object( player, "Unable to find the next directory "
            "with errors.\n" );
    }
    else {
        ERROR_CMD->errors_in_dir(data[0]["Directory"], 0);
    }
}
private int get_next_error() {
    HELPER->query_next_dir( this_player(), (: finished_next_dir :) );
    add_succeeded_mess( ({ "Retrieving error count, this may take several "
        "seconds.\n", "" }) );
    return 1;
}
private int list_error_directories() {
    string *dirs;
    dirs = HELPER->query_directories( this_player()->query_name() );
    if ( sizeof( dirs ) ) {
        tell_object( this_player(), "$P$finderrors list$P$" +
            implode( dirs, "\n" ) + "\n" );
        add_succeeded_mess( "" );
        return 1;
    }
    else {
        add_failed_mess( "No directories have been added to finderrors.\n" );
        return -1;
    }
}
private int add_directory( string directory, int recursive ) {
    if ( directory[ <1 ] != '/' ) {
        directory += "/";
    }
    if ( file_size( directory ) != -2 ) {
        add_failed_mess( directory + " is not a directory.\n" );
        return -1;
    }
    HELPER->add_directory( this_player(), directory, recursive );
    return 1;
}
private int remove_directory( string directory, int recursive ) {
    int result;
    result = HELPER->remove_directory( this_player(), directory, recursive );
    if ( result ) {
        add_succeeded_mess( "Directory removed successfully.\n" );
        return 1;
    }
    add_failed_mess( "Could not remove directory.  Was it on your "
        "finderrors list?\n" );
    return -1;
}
public mixed *query_patterns() {
    return ({
              "add <word>", (: add_directory( $4[ 0 ], 0 ) :),
              "add <word> recursive", (: add_directory( $4[ 0 ], 1 ) :),
              "remove <word>", (: remove_directory( $4[ 0 ], 0 ) :),
              "remove <word> recursive", (: remove_directory( $4[ 0 ], 1 ) :),
              "list", (: list_error_directories :),
              "count", (: count_errors :),
              "", (: get_next_error :) });
}

==================================================
FILE: cmds/creator/gr_ep.c
==================================================

inherit "/cmds/base";
#include <creator.h>
mapping globals = ([]), files = ([]), ret = ([]);
#define TP globals[fd]
#define RET ret[fd]
string *check_perms(string *done, string file){
  mixed perm=master()->valid_read(file, this_player()->query_name(), "cat");
  if(!perm)
    return done;
  if(intp(perm))
    perm = file;
  return done + ({perm});
}
mixed cmd(string arg) {
  int fd, search = 0, nfiles = 0;
  if(!arg)
    arg = "";
  else {
    string bit, *bits = explode(arg, " ");
    arg = "";
    bits -= ({""});
    foreach(bit in bits){
      string *files, file;
      if (bit[0] == '-'){
        if( ( bit == "-r" || bit == "--recursive" || bit== "-d=recurse" ||
       bit == "--directories=recurse" || bit == "-recursive" ||
        bit == "-directories=recurse" ) && !this_player()->query_lord() )
          continue;
        arg += (" " + bit);
        continue;
      }
      if(!search){
        search = 1;
        arg += (" " + bit);
      } else {
        files = this_player()->get_files(bit);
        files = implode(files, (:check_perms:), ({}));
        foreach(file in files){
          arg += (" " + file[1..]);
          nfiles++;
        }
      }
    }
  }
  if(nfiles || !search)
    fd = external_start(6, arg, "read_call_back", "write_call_back",
                      "close_call_back");
  else
    return notify_fail("Grep needs at least one file.\n");
  if (fd == -1)
    return notify_fail("grep failed somehow.\n");
  TP = this_player();
  RET = "";
  write("grep started.\n");
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/usr/bin/", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "grep: Whoops! fatal error.\n");
}
void close_call_back(int fd) {
  if(RET != "")
    TP->more_string(RET);
  else
    tell_object(TP, "grep finished.\n");
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/harass.c
==================================================

string info = "";
mapping busy = ([]);
void create(){
  seteuid("Root");
}
void receive_snoop(string bing){
  info += bing;
}
string query_result(){ return info; }
void remind(){
  if(busy[this_player()]){
    write("Type harass again to stop logging.\n");
    call_out((:remind:), 60);
  }
}
mixed *query_patterns(){
  return ({"", function(){
      if(busy[this_player()]){
        string result = busy[this_player()]->query_result();
        unguarded((:write_file,sprintf("/d/liaison/secure/harass/%s%d",
                                       this_player()->query_name(), time()),
                   $(result):));
        destruct(busy[this_player()]);
        map_delete(busy, this_player());
        write("Log written.\n");
        return 1;
      } else {
        busy[this_player()] = clone_object(__FILE__);
        if(efun::snoop(busy[this_player()], this_player())){
          write("Started logging.\nType harass again to stop.\n");
          call_out((:remind:), 60);
          return 1;
        } else {
          destruct(busy[this_player()]);
          map_delete(busy, this_player());
          write("Failed.\n");
          return 1;
        }
      }
    }
  });
}

==================================================
FILE: cmds/creator/indent.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 4
mapping globals = ([]), ret = ([]), cmds = ([]);
#define TP globals[fd]
#define RET ret[fd]
#define CMDS cmds[this_player()]
mixed cmd(string arg) {
  int nfiles = 0;
  int fd;
  string bit;
  string *bits;
  object *things;
  if (!arg) {
    return notify_fail("rcsin: No arguments.\n");
  }
  bits = explode(arg, " ");
  arg = "";
  bits -= ({ "", 0 });
  foreach(bit in bits) {
    string files = "", file;
    if (bit[0] == '-') {
      arg += (" " + bit);
      continue;
    }
    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0) {
          file += ".c";
        }
        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }
  if(!nfiles) {
    return notify_fail("rcsin: no such file "+arg+".\n");
  }
  fd = external_start(CMD_NUM, explode(arg, " "),
                      "read_call_back", "write_call_back",
                      "close_call_back");
  TP = this_player();
  RET = "";
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcsin: Write_call_back called.\n");
}
void close_call_back(int fd) {
  string file, *file_stuff;
  int i;
  if (RET != "") {
    TP->more_string(RET);
    file_stuff = explode(RET, "\n");
    i = 0;
    while (i + 2 < sizeof(file_stuff))  {
      if (file_stuff[i + 2] == "done")  {
        sscanf(file_stuff[i], "%*s  <--  %s", file);
        RCS_HANDLER->remove_lock(TP, file);
        i += 3;
      }
      else if (sscanf(file_stuff[i], "%*sNo such file or directory"))  {
        ++i;
      }
      else if (file_stuff[i + 1][0..2] == "ci:") {
          i += 2;
      }
      else {
          i += 3;
      }
    }
  } else {
    tell_object(TP, "rcsin completed.\n");
  }
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/lo_ad.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  string *filenames, err, fname, *failed, *succ, ret, load_err;
  int size;
  if (!str) {
    return notify_fail("Load what?\n");
  }
  filenames = this_player()->get_cfiles(str);
  if (!sizeof(filenames)) {
    return notify_fail("No such object.\n");
  }
  failed = succ = ({ });
  load_err = "";
  foreach (fname in filenames) {
    if (file_size(fname) < 0) {
      failed += ({ fname });
      continue;
    }
    if ((err = catch(fname->load_up_with_yellow()))) {
      load_err += sprintf("Failed to load %s, error: %s", fname, err);
    } else {
      succ += ({ fname });
    }
  }
  ret = "";
  if ((size = sizeof(failed))) {
    ret += sprintf("%s %s not %sregular file%s.\n",
                   query_multiple_short(failed), (size == 1 ? "is" : "are"),
                   (size == 1 ? "a " : ""), (size == 1 ? "" : "s"));
  }
  if (strlen(load_err)) {
    ret += load_err;
  }
  if (sizeof(succ)) {
    ret += sprintf("$I$5=$C$Loaded %s.\n", query_multiple_short(succ));
  }
  this_player()->show_message("$P$Load$P$" + ret);
  return 1;
}

==================================================
FILE: cmds/creator/locks.c
==================================================

#include <creator.h>
int cmd(string){
  string *bits, rcspath, *files, path, tmp;
  files = get_dir(this_player()->query_current_path()+"/");
  write("locked files in this directory:\n");
  foreach(path in files) {
    path = this_player()->query_current_path() + "/" + path;
    bits = explode(path, "/");
    if(sizeof(bits) > 2) {
      rcspath = "/" + implode(bits[0..sizeof(bits)-2], "/") + "/RCS/";
    } else if(sizeof(bits) == 2) {
      rcspath = "/" + bits[0] + "/RCS/";
    } else
      rcspath = "/";
    rcspath += bits[sizeof(bits)-1] + ",v";
    if(file_size(rcspath) > 0) {
      tmp = read_file(rcspath, 4, 1);
      if(tmp == "locks\n") {
        string lockname ;
        tmp = read_file(rcspath, 5, 1);
        sscanf(tmp, "\t%s:", lockname);
        printf("%s locked by %s\n", path, lockname);
      }
    }
  }
  return 1;
}
string help() {
  return "Displays the files that are locked in your current directory.";
}

==================================================
FILE: cmds/creator/ls.c
==================================================

#include <ls.h>
#include <autodoc.h>
inherit "/cmds/base";
#define CREATOR (master()->author_file(sprintf("%s/%s", str, direc[i][0]))? \
                master()->author_file(sprintf("%s/%s", str, direc[i][0])): \
                "Root")
#define DOMAIN  (master()->domain_file(sprintf("%s/%s", str, direc[i][0]))? \
                master()->domain_file(sprintf("%s/%s", str, direc[i][0])): \
                "Root")
#define CREATOR_D (master()->author_file(sprintf("%s/%s/.", str, direc[i][0]))? \
                master()->author_file(sprintf("%s/%s/.", str, direc[i][0])): \
                "Root")
#define DOMAIN_D (master()->domain_file(sprintf("%s/%s/.", str, direc[i][0]))? \
                master()->domain_file(sprintf("%s/%s/.", str, direc[i][0])): \
                "Root")
int ls(string str, int mask);
int check_dots(mixed arg);
mixed cmd(string str) {
  string *bits, path;
  int mask, i;
  mask = (MASK_C|MASK_F);
  if (str) {
      if ( this_player()->query_property( LS_COMMAND_NICKNAME_PROPERTY ) ) {
         str = this_player()->expand_nickname( str );
      }
    bits = explode(str, " ") - ({"", 0});
    while (sizeof(bits) && bits[0][0] == '-') {
      i = strlen(bits[0]);
      while (i--) {
        if (bits[0][i] == '-') continue;
        switch (bits[0][i]) {
        case 't':
          mask |= MASK_T;
          break;
        case 'l':
          mask |= MASK_L;
          break;
        case 'C':
          mask |= MASK_C;
          break;
        case 'a':
          mask |= MASK_A;
          break;
        case 'd':
          mask |= MASK_D;
          break;
        case 'o':
          mask |= MASK_O;
          break;
        case 'F':
          mask |= MASK_F;
          break;
        case '1':
          mask &= ~MASK_C;
          break;
        case 'v':
          write("ls version 2.6 (c) 1995-1998 Turrican@Discworld\n");
          return 1;
        case 'h':
          printf("Usage: ls [OPTION]... [PATH]...\n\n"
                 "  -a      do not hide entries \"..\" and \".\"\n"
                 "  -d      list directory entries instead of contents\n"
                 "  -h      display this help and exit\n"
                 "  -l      use a long listing format\n"
                 "  -o      colorize entries according to type\n"
                 "  -v      print version information and exit\n"
                 "  -C      list entries by columns\n"
                 "  -F      append a character to entries according to type\n"
                 "  -1      list one file per line\n"
                 "  -t      sort by date\n"
            );
          return 1;
        default :
          printf("Unknown option -%c\nTry `ls -h' for more information.\n",
                 bits[0][i]);
          return 1;
        }
      }
      bits = delete(bits, 0, 1);
    }
    str = implode(bits, " ");
  }
  if (!str) {
    path = this_player()->query_path();
  } else {
    path = this_player()->get_path(str);
  }
  if (!path) {
    return notify_fail("No current directory.\n");
  }
  if (master()->valid_read(path+"/", geteuid(this_player()), "get_dir")) {
    ls(path, mask);
  } else {
    return notify_fail("$I$0=ls: "+ str + ": Permission denied.\n");
  }
  return 1;
}
string dir_entry(string path, string name, int size, int mask) {
  string tmp;
  tmp = "";
  if(size == -2) {
    if(mask & MASK_F)
      name += "/";
    return "   - " + name;
  }
  if (find_object(path+name)) {
    if (mask & MASK_F) {
      tmp += "*";
    }
  }
  if ((mask & MASK_F) && AUTODOC_HANDLER->is_autodoc_file(path + name)) {
    tmp += "@";
  }
  name += tmp;
  size = (size / 1024) + 1;
  if (size < 1000) {
    return "    "[0..3-strlen(size+"")]+size+" "+name;
  }
  return size + " "+name;
}
int ls(string str, int mask) {
  string *bit, *bing, bong, path;
  int i, j, k, size;
  mixed *direc;
  path = str;
  if (file_size(str) == -2 && str[strlen(str)-1] != '/' &&
      !(mask & MASK_D)) {
    path += "/";
  }
  if (mask & MASK_A) {
    path += "*";
  }
  direc = get_dir(path, -1);
  if(arrayp(direc)) {
    if (!(mask & MASK_A)) {
      direc = filter(direc, (: check_dots($1) :));
    }
  }
  if (!direc) {
    printf("No files.\n");
    return 0;
  }
  if (!sizeof(direc)) {
    if (file_size(str) == -2) {
      printf("No files.\n");
    } else {
      printf("ls: %s: No such file or directory.\n", str);
    }
    return 0;
  }
  if (file_size(path) == -2) {
    if (path[strlen(path)-1] != '/') {
      path += "/";
    }
  } else {
    bit = explode(path, "/");
    bit = bit[0..sizeof(bit)-2];
    path = "/"+implode(bit,"/")+"/";
  }
  if(path == "
    path = "/";
  bing = allocate(sizeof(direc));
  j = sizeof(direc);
  if (!(mask & MASK_C) && !(mask & MASK_L)) {
    if (mask & MASK_T)  {
      direc = sort_array(direc, (: $1[2] < $2[2] ? -1 :
                                   $1[2] > $2[2] ?  1 : 0 :));
    }
    if (!(mask & MASK_F) && !(mask & MASK_O)) {
      bong = sprintf("%-=*s\n", this_player()->query_cols(),
        implode(direc, "\n"));
      bing = explode(bong, "\n");
    } else for (i=0; i < j; i++) {
      if (direc[i][1] == -2 || direc[i][0] == "..") {
        if (mask & MASK_O) {
          bing[i] = sprintf("%s%-=*s", "%^GREEN%^",
            (int)this_player()->query_cols()+8, direc[i][0]+"%^RESET%^"+
            (mask & MASK_F?"/":""));
        } else  {
          bing[i] = sprintf("%-=*s", this_player()->query_cols(),
            direc[i][0]+"/");
        }
      } else if (find_object(path+direc[i][0])) {
        if (mask & MASK_O) {
          bing[i] = sprintf("%s%-=*s", "%^MAGENTA%^",
            (int)this_player()->query_cols()-1, direc[i][0]+"%^RESET%^"+
            (mask & MASK_F?"*":"")+
            ((mask & MASK_F) && AUTODOC_HANDLER->is_autodoc_file(path+direc[i][0])
             ?"@":""));
        } else {
          bing[i] = sprintf("%-=*s", this_player()->query_cols(),
            direc[i][0]+"*"+
            ((mask & MASK_F) && AUTODOC_HANDLER->is_autodoc_file(path+direc[i][0])
             ?"@":""));
        }
      } else {
        bing[i] = sprintf("%-=*s", this_player()->query_cols(), direc[i][0]+
          ((mask & MASK_F) && AUTODOC_HANDLER->is_autodoc_file(path+direc[i][0])
           ?"@":""));
      }
    }
    bong = implode(bing, "\n");
  } else if (!(mask & MASK_L)) {
    if (mask & MASK_T)  {
      direc = sort_array(direc, (: $1[2] < $2[2] ? -1 :
                                   $1[2] > $2[2] ?  1 : 0 :));
    }
    j = sizeof(direc);
    for(i=0; i<j; i++)
      bing[i] = dir_entry(path, direc[i][0], direc[i][1],mask)+"\n";
    bong = sprintf( "%#-*s\n", this_player()->query_cols(),
                    implode(bing, ""));
    if (mask & MASK_O) {
      i = j;
      while (i--) {
        if (direc[i][1] == -2 || direc[i][0] == "..") {
          bong = replace_string(bong, " "+direc[i][0],
            sprintf(" %s%s%s", "%^GREEN%^", direc[i][0], "%^RESET%^"));
        } else if (find_object(path+direc[i][0])) {
          bong = replace_string(bong, " "+direc[i][0],
            sprintf(" %s%s%s", "%^MAGENTA%^", direc[i][0], "%^RESET%^"));
        } else {
          bong = replace_string(bong, " "+direc[i][0],
            sprintf(" %s%s", "%^RESET%^", direc[i][0]));
        }
      }
    }
  } else {
    string tmp, tmp2;
    mixed *stats;
    int *count, current_time;
    if ( file_size( str ) == -2 && !(mask & MASK_D)) {
        if ( str[ strlen( str ) - 1 ] == '/' ) {
            str += "*";
        } else {
            str += "
    direc = get_dir( str, -1 );
    if (!(mask & MASK_A)) {
      direc = filter_array(direc, (: check_dots($1) :));
    }
    if (!direc || !(size = sizeof(direc))) {
        return 0;
    }
    if (mask & MASK_T)  {
      direc = sort_array(direc, (: $1[2] < $2[2] ? -1 :
                                   $1[2] > $2[2] ?  1 : 0 :));
    }
    bit = allocate(size);
    count = allocate(size);
    i = strsrch(str, '/', -1);
    if (i >= 0) {
        str = str[0..i];
    }
    current_time = time();
    for (i = 0; i < size; i++) {
      reset_eval_cost();
      tmp2 = ctime((direc[i])[2]);
      if ((direc[i])[2] + (6 * 30 * 24 * 60 * 60) < current_time ||
          (direc[i])[2] - ( 60 * 60) > current_time ) {
        tmp = sprintf("%s  %s", tmp2[4..9], tmp2[20..23]);
      } else {
        tmp = tmp2[4..15];
      }
      j = (direc[i])[1];
      if (j == -2) {
        count[i] = 1;
        bit[i] = sprintf("%-=*s", (this_player()->query_cols()+
          (mask & MASK_O?17:0)),
          sprintf("drwxr%cx%c%c%c %3d %-11.11s %-11.11s      0 %12s %s%s%s%s",
          (master()->valid_write(sprintf("%s%s/fl.uff",str,direc[i][0]),
          DOMAIN_D, "get_dir")?'w':'-'),
          (master()->valid_read(sprintf("%s%s",str,direc[i][0]),
          "NOBODY", "get_dir")?'r':'-'),
          (master()->valid_write(sprintf("%s%s/fl.uff",str,direc[i][0]),
          "NOBODY", "get_dir")?'w':'-'),
          (master()->valid_read(sprintf("%s%s",str,direc[i][0]),
          "NOBODY", "get_dir")?'x':'-'),
          0+(direc[i][0] == ".." &&
          str == "/"?2:0),
          CREATOR_D, DOMAIN_D, tmp, (mask & MASK_O?"%^GREEN%^":""),
          (direc[i])[0], (mask & MASK_O?"%^RESET%^":""),
          (mask & MASK_F?"/":"")));
      } else {
        count[i] = 0;
        stats = stat(str + (direc[i])[0]);
        bit[i] = sprintf("%-=*s", (this_player()->query_cols()+
          ((mask & MASK_O) && (k = sizeof(stats)) > 1 && stats[2]?19:0)),
          sprintf("-rw%c%c%c-%c%c-   1 %-11.11s %-11.11s %6d %12s %s%s%s%s%s",
          k > 1 && stats[2] ? 'x' : '-',
          (master()->valid_read(sprintf("%s/%s",str,direc[i][0]),
          DOMAIN, "get_dir")?'r':'-'),
          (master()->valid_write(sprintf("%s/%s",str,direc[i][0]),
          DOMAIN, "get_dir")?'w':'-'),
          (master()->valid_read(sprintf("%s/%s",str,direc[i][0]),
          "NOBODY", "get_dir")?'r':'-'),
          (master()->valid_write(sprintf("%s/%s",str,direc[i][0]),
          "NOBODY", "get_dir")?'w':'-'),
          CREATOR, DOMAIN, j, tmp,
          ((mask & MASK_O) && k > 1 && stats[2]?"%^MAGENTA%^":""),
          (direc[i])[0], ((mask & MASK_O) && k > 1 &&
          stats[2]?"%^RESET%^":""),
          (k > 1 && stats[2] && (mask & MASK_F)?"*":""),
          ((mask & MASK_F) &&
           AUTODOC_HANDLER->is_autodoc_file(str + direc[i][0])?"@":"")));
      }
      bong = implode(bit, "\n");
    }
  }
  this_player()->more_string( bong, str, 1 );
}
int check_dots(mixed arg) {
  return arg[0][0] != '.';
}
int is_dir(mixed arg, string path) {
  return (file_size(this_player()->get_path(sprintf("%s/%s", path, arg)))
          == -2);
}

==================================================
FILE: cmds/creator/mylocks.c
==================================================

#include <creator.h>
inherit "/cmds/base";
int cmd(string person)  {
   string *locked;
   string who_string;
   if(person == "verify") {
     locked = RCS_HANDLER->query_locks( this_player() );
     locked = sort_array( locked, 1 );
     call_out("verify_lock", 1, this_player(), locked);
     write("Verifying\n");
     return 1;
   }
   if (!person  ||  file_size(person) == -2)  {
      who_string = "You have ";
      locked = RCS_HANDLER->query_locks( this_player() );
      if (person)
         locked = filter(locked, (: strsrch($1, $(person)) == 0 :));
   }
   else  {
      who_string = capitalize( person ) + " has ";
      locked = RCS_HANDLER->query_locks( person );
   }
   if ( !sizeof( locked ) ) {
      add_failed_mess( who_string + "no files locked.\n" );
      return -1;
   }
   locked = sort_array( locked, 1 );
   write( who_string + "the following files locked:\n" +
     implode(locked, "\n") + "\n");
   return 1;
}
void verify_lock(object pl, string *locks) {
  string file, lockline, *bits;
  int remove;
  file = locks[0];
  bits = explode(file, "/");
  file = "/" + (string)implode(bits[0..<2], "/") + "/RCS/" + bits[<1] + ",v";
  if(file_size(file) < 0)
    remove = 1;
  else {
    lockline = read_file(file, 4, 1);
    if (strsrch(lockline, "locks; strict:") == -1) {
      bits = explode(read_file(file, 5, 1), ":");
      if(bits[0][0] != '\t')
        remove = 1;
    }
  }
  if(remove) {
    tell_object(pl, "Removing non-existant lock for " + locks[0] + "\n");
    RCS_HANDLER->remove_lock(pl->query_name(), locks[0]);
  }
  if(sizeof(locks) > 1)
    call_out("verify_lock", 1, this_player(), locks[1..]);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
     "<string'creator|directory|verify'>", (: cmd($4[0] ) :) });
}

==================================================
FILE: cmds/creator/printe_rrors.c
==================================================

#include <log.h>
#include <board.h>
#include <error_handler.h>
#include <db.h>
inherit "/cmds/base";
void finish_details(string player, int result, mixed results);
int cmd(string str) {
  string player, ret;
  class error_query query;
  if (str) {
    if (str[0] != '/')  {
      str = this_player()->query_path() + "/" + str;
    }
    if (str[<1] == '0') {
      str = str[0..<2];
    }
    if (str[<1] == '/') {
      str = str[0..<2];
    }
    player = this_player()->query_name();
    write_file("/w/" + player + "/print_errors.txt", "", 1);
    write("%^YELLOW%^Starting to collect bugreports, this may take a "
          "while.%^RESET%^\n");
    query = new(class error_query);
    query->recursive = 1;
    query->dir = str;
    query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                       ERROR_STATUS_FIXING });
    ERROR_HANDLER->do_query_multiple_bug_details(query,
                  (: finish_details($(player), $1, $2) :));
    return 1;
  } else
    return notify_fail("Usage:\nprinterrors <path>\n note that this will "
                       "overwrite any previous print_errors.txt file\n");
}
protected string get_bug(class error_complete complete) {
  string ret;
  class error_details error;
  class error_forward forward;
  class error_comment comment;
  error = complete->details;
  ret = sprintf("%s %s %s\n", error->summary->category,
                              error->summary->type, error->summary->status);
  ret += sprintf("Filename       : %s\n", error->summary->filename);
  ret += sprintf("Directory      : %s\n", error->summary->directory);
  ret += sprintf("Made by        : %s\n", capitalize(error->summary->reporter));
  ret += sprintf("at             : %s\n\n", ctime(error->summary->entry_date));
  foreach (forward in complete->forwards) {
    ret += sprintf("Forwarded by   : %s\n", capitalize(forward->forwarder));
    ret += sprintf("from           : %s\n", forward->old_directory);
    ret += sprintf("at             : %s\n", ctime(forward->date));
  }
  ret += error->report;
  if (error->runtime && (error->runtime != "")) {
    ret += "[RUNTIME]\n" + error->runtime;
  }
  foreach (comment in complete->comments) {
      ret += sprintf("\nComment by     : %s\n", capitalize(comment->commenter));
      ret += sprintf(  "at             : %s\n", ctime(comment->date));
      ret += comment->comment;
  }
  ret +=
"------------------------------------------------------------------------------";
  return ret;
}
void finish_details(string player, int result, mixed results) {
   class error_complete* details;
   string str;
   if (result != DB_SUCCESS) {
      tell_creator(player, "Failed to return the results " + results);
      return ;
   }
   details = results;
   foreach (class error_complete detail in details) {
      str = get_bug(detail);
      unguarded( (: write_file("/w/" + $(player) + "/print_errors.txt", $(str)) :) );
   }
   tell_creator(player, "Finished gathering the details.\n");
}

==================================================
FILE: cmds/creator/rcsbatchin.c
==================================================

#include <creator.h>
inherit "/cmds/base";
#define CMD_NUM 5
mapping globals = ([]);
mapping ret = ([]);
mapping cmds = ([]);
mapping comments = ([ ]);
mapping locks = ([ ]);
mapping completed = ([ ]);
#define TP globals[fd]
#define RET ret[fd]
#define CMDS cmds[this_player()]
#define COMMENT comments[TP]
void ask_about_file(object player);
void get_answer(string answer, object player);
void start_input(object player);
int cmd() {
   locks[this_player()] = RCS_HANDLER->query_locks(this_player());
   if (sizeof(locks[this_player()]) == 0)  {
      printf("You don't have any files locked.\n");
      map_delete(locks, this_player());
      return 1;
   }
   ask_about_file(this_player());
   return 1;
}
void check_complete(object player)  {
   if (!completed[player])
      call_out("check_complete", 1, player);
   else  {
      map_delete(completed, player);
      ask_about_file(player);
   }
}
void ask_about_file(object player)  {
   string tmp;
   tmp = sprintf("Check in %s? (y/N/q)\n", locks[player][0]);
   tell_object(player, tmp);
   input_to("get_answer", 0, player);
}
void start_input(object player)  {
   unguarded((:input_to((: get_answer :), 0, $(player)) :));
}
void get_answer(string answer, object player)  {
   string  arg;
   string *tmp;
   if (answer == "y"  ||  answer == "Y")  {
      tmp = explode(locks[player][0], "/");
      if (file_size("/" + implode(tmp[0 .. <2], "/") + "/RCS/" + tmp[<1] +
                    ",v") > 0)
      {
         arg = locks[player][0][1 .. ];
         tell_object(player, "Enter a comment.\n");
         CMDS = arg;
         player->do_edit("", "do_ci", this_object(), "", player);
         return;
      }
      else  {
         arg = sprintf("ERROR: No RCS file for %s\n", locks[player][0]);
         tell_object(player, arg);
         if (sizeof(locks[player]) > 1)  {
            locks[player] = locks[player][1 .. ];
            ask_about_file(player);
         }
         else
            map_delete(locks, player);
      }
   }
   else if (answer == "q"  ||  answer == "Q")  {
      map_delete(locks, player);
      return;
   }
   else if (sizeof(locks[player]) > 1)  {
      locks[player] = locks[player][1 .. ];
      ask_about_file(player);
   }
   else
      map_delete(locks, player);
}
void do_ci(string comment, object player) {
   int fd;
   string *cmd = allocate(3);
   if (!comment) {
      tell_object(player, "No comment given, skipping.\n");
      if (sizeof(locks[player]) > 1)  {
         locks[player] = locks[player][1 .. ];
         ask_about_file(player);
      }
      else
         map_delete(locks, player);
   }
   else  {
      cmd[0] = "-w" + player->query_name();
      cmd[1] = "-u";
      cmd[2] = "-m" + comment;
      cmd += explode(CMDS, " ");
#ifdef DEBUG
      tell_object(player, "CMD: %O\n", cmd);
#endif
      fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                          "close_call_back");
      TP = player;
      RET = "";
      COMMENT = comment;
      if (sizeof(locks[player]) > 1)  {
         completed[player] = 0;
         tell_object(player, "Checking in... please wait\n");
         call_out("check_complete", 1, player);
      }
   }
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcsin: Write_call_back called.\n");
}
void close_call_back(int fd) {
   string  file;
   string *file_stuff;
   string *bits;
   string  log;
   string  lname;
   int     i;
   object  master;
   if (RET != "") {
      TP->more_string(RET);
      file_stuff = explode(RET, "\n");
      i = 0;
      while (i + 2 < sizeof(file_stuff))  {
         if (file_stuff[i + 2] == "done")  {
            sscanf(file_stuff[i], "%*s  <--  %s", file);
            RCS_HANDLER->remove_lock(TP, file);
            if (file[0] == 'w')
               lname = "";
            else if (file[0] == 'd') {
               bits = explode(file, "/");
               if (sizeof(bits) >= 2 &&
                   member_array(bits[1],
                                "/secure/master"->query_domains()) != -1)
               {
                  master = find_object("/d/" + bits[1] + "/master");
                  if (!master)
                     TP->tell_object("No master object for domain: " +
                                     bits[1] + ".\n");
                  else
                     lname = master->query_changelog(file);
               }
               if (!lname)
                  lname = "/d/" + explode(file, "/")[1] + "/ChangeLog";
            }
            else
               lname = "/log/ChangeLog";
            if (lname != "") {
               log = TP->fix_string(sprintf(" * %s %s %s\n%s\n",
                                            ctime(time())[4 .. ],
                                            file, TP->query_name(),
                                            COMMENT), 80, 21);
               log_file(lname, log);
            }
            i += 3;
         }
         else if (sscanf(file_stuff[i], "%*sNo such file or directory"))
            ++i;
         else if (file_stuff[i + 1][0 .. 2] == "ci:")
            i += 2;
         else
            i += 3;
      }
   }
   else
      tell_object(TP, "rcsin completed.\n");
   if (sizeof(locks[TP]) > 1)  {
      locks[TP] = locks[TP][1 .. ];
      completed[TP] = 1;
   }
   else  {
      map_delete(completed, TP);
      map_delete(locks, TP);
   }
   map_delete(comments, TP);
   map_delete(ret, fd);
   map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/rcsc_reate.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 5
mapping globals = ([]), ret = ([]);
string cmd_str;
#define TP globals[fd]
#define RET ret[fd]
mixed cmd(string arg) {
  string *files;
  int nfiles = 0;
  string bit, *bits;
  int add_comments;
  string tmp;
  if (!arg) {
    return notify_fail("rcscreate: No arguments.\n");
  }
  notify_fail("rcscreate: no such file "+arg+".\n");
  bits = explode(arg, " ");
  arg = "";
  bits -= ({""});
  foreach (bit in bits) {
    string  file;
    if (bit[0] == '-') {
      if (bit[1] == 'c') {
        add_comments = 1;
      } else {
        arg += (" " + bit);
      }
      continue;
    }
    files = this_player()->get_files(bit);
    foreach (file in files) {
      if (master()->valid_write(file, geteuid(this_player()), "cmd")) {
        string dir, *tmpbits;
        tmpbits = explode(file, "/");
        if (tmpbits[<1] == "RCS" ||
            tmpbits[<1] == "." ||
            tmpbits[<1] == ".." ||
            tmpbits[<1] == "ERROR_REPORTS") {
          continue;
        }
        if (sizeof(tmpbits) > 1) {
          dir = "/" + implode(tmpbits[0..<2], "/") + "/RCS";
        } else {
          dir = "/RCS";
        }
        if (file_size(dir) == -1) {
          write("No directory "+dir+", creating one.\n");
          mkdir(dir);
        }
        if (add_comments) {
          tmp = read_file(file);
          if ( file[ strsrch( file, ".", -1 ) .. ] == ".c"  ||
               file[ strsrch( file, ".", -1 ) .. ] == ".h" )  {
            tmp = replace_string(tmp, "\n", "");
            tmp = replace_string(tmp, "\n", "");
            write_file(file,
                       "\n"
                       "\n\n" + tmp);
          }
          else  {
            tmp = replace_string( tmp, "#  -*- LPC -*-  #\n", "" );
            tmp = replace_string( tmp, "# -*- LPC -*- #\n", "" );
            write_file( file,
                        "#  -*- LPC -*- #\n"
                        "#\n"
                        "# $", 1 );
            write_file( file,
                        "Locker$\n"
                        "# $");
            write_file(file, "Id$\n"
                        "#\n"
                        "#\n"
                        "#\n\n" + tmp );
          }
        }
        arg += (" " + file[1..]);
        nfiles++;
      } else {
        notify_fail("You do not have write access to "+file+"\n");
      }
    }
  }
  if (!nfiles) {
    return 0;
  }
  printf("Enter a comment.\n");
  cmd_str = arg;
  this_player()->do_edit(0, "do_ci");
  return 1;
}
void do_ci(string comment) {
  int fd;
  string *cmd = allocate(4);
  if (!comment) {
    printf("No comment given, aborting.\n");
    return;
  }
  cmd[0] = "-w" + this_player()->query_name();
  cmd[1] = "-i";
  cmd[2] = "-u";
  cmd[3] = "-t-" + comment;
  cmd += explode(cmd_str, " ");
#ifdef DEBUG
  printf("CMD: %O\n", cmd);
#endif
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
  TP = this_player();
  RET = "";
}
void read_call_back(int fd, mixed mess) {
  mess = replace_string(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcscreate: Write_call_back called.\n");
}
void close_call_back(int fd) {
  if (RET != "") {
    TP->more_string(RET);
  } else {
    tell_object(TP, "rcscreate completed.\n");
  }
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/rcsco_mment.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 8
mapping globals = ([]), ret = ([]);
#define TP globals[fd]
#define RET ret[fd]
class rcscomment_args {
  object player;
  string arg;
  string revision;
}
mixed cmd(string arg) {
  int nfiles = 0;
  string bit, *bits;
  object *things;
  string* files;
  string file;
  if (!arg) {
    return notify_fail("rcscomment: No arguments.\n");
  }
  bits = explode(arg, " ");
  arg = "";
  bits -= ({ "", 0 });
  foreach(bit in bits) {
    if (bit[0] == '-') {
      arg += (" " + bit);
      continue;
    }
    files = this_player()->get_files(bit);
    if (sizeof(files)) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";
        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }
  if(!nfiles) {
    return notify_fail("rcscomment: no such file "+arg+".\n");
  }
  printf("Enter a revision number: ");
  input_to("get_rev", 0, new(class rcscomment_args, player : this_player(),
                             arg : arg));
  return 1;
}
protected void get_rev(string revision, class rcscomment_args args) {
  if (!strlen(revision)) {
    printf("No revision given, aborting.\n");
    return;
  }
  args->revision = revision;
  printf("Enter a comment.\n");
  args->player->do_edit(0, "do_comment", 0, 0, args);
}
void do_comment(string comment, class rcscomment_args args) {
  int fd;
  string *cmd = allocate(2);
  if (!strlen(comment)) {
    printf("No comment given, aborting.\n");
    return;
  }
  cmd[0] = sprintf("-w%s", args->player->query_name());
  cmd[1] = sprintf("-m%s:%s", args->revision, comment);
  cmd += explode(args->arg, " ");
#ifdef DEBUG
  printf("CMD: %O\n", cmd);
#endif
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
  TP = args->player;
  RET = "";
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcscomment: write_call_back() called.\n");
}
void close_call_back(int fd) {
  if (RET != "") {
    TP->more_string(RET);
  } else {
    tell_object(TP, "rcscomment completed.\n");
  }
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/rcsd_iff.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 2
mapping globals = ([]), ret = ([]);
#define TP globals[fd]
#define RET ret[fd]
mixed cmd(string arg) {
  int fd, nfiles = 0;
  string cmd;
  string bit, *bits;
  object *things;
  if(!arg)
    return notify_fail("rcsdiff: No arguments.\n");
  bits = explode(arg, " ");
  arg = "";
  bits -= ({""});
  foreach(bit in bits){
    string *files = ({}), file;
    if (bit[0] == '-'){
      arg += (" " + bit);
      continue;
    }
    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";
        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }
  if(!nfiles)
    return notify_fail("No such file: "+arg+"\n");
  cmd =  arg;
#ifdef DEBUG
  printf("CMD: %s\n", cmd);
#endif
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
  TP = this_player();
  RET = "";
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcsdiff: Whoops! fatal error.\n");
}
void close_call_back(int fd) {
  if(RET != "")
    TP->more_string(RET);
  else
    tell_object(TP, "rcsdiff completed.\n");
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/rcsf_orce.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#include <mail.h>
#include <player_handler.h>
#define CMD_NUM 5
class rcsforce_args {
   object player;
   string *cmd;
   string locker;
   string filen;
}
private mapping _globals = ([ ]);
private mapping _ret = ([ ]);
private mapping _lockers = ([ ]);
#define TP _globals[fd]
#define RET _ret[fd]
#define LCK _lockers[fd]
private void do_ci(string text,
                   class rcsforce_args args);
mixed cmd(string arg)
{
   int nfiles = 0;
   string bit;
   string *bits;
   string file;
   string locker;
   string filen;
   string *cmd = allocate(3);
   if (!arg) {
      return notify_fail("rcsforce: No arguments.\n");
   }
   bits = explode(arg, " ");
   arg = "";
   bits -= ({ "", 0 });
   foreach(bit in bits) {
      string *files;
      if (bit[0] == '-') {
         arg += (" " + bit);
         continue;
      }
      files = (string *) this_player()->get_files(bit);
      if (sizeof(files)) {
         filen = file = files[0];
         arg += (" " + file[1..]);
         nfiles++;
      }
   }
   if (!nfiles) {
      return notify_fail("rcsforce: no such file " + arg + ".\n");
   }
   bits = explode(file, "/");
   file =
      "/" + (string) implode(bits[0.. < 2], "/") + "/RCS/" + bits[<1] + ",v";
   if (file_size(file) < 0) {
      return notify_fail("That file is not in RCS.\n");
   }
   if (strsrch(read_file(file, 4, 1), "locks; strict:") != -1) {
      return notify_fail("That file is not locked.\n");
   } else {
      bits = explode(read_file(file, 5, 1), ":");
      locker = bits[0][1..];
   }
   if (!master()->query_senior(this_player()->query_name()) &&
       PLAYER_HANDLER->test_creator(locker)) {
      if (file[0..2] == "/d/") {
         bits = explode(file, "/");
         if (!("/d/" + bits[1] + "/master")->can_rcsforce(file,
                                             this_player()->query_name(),
                                             locker)) {
            return 0;
         }
      } else {
         return 0;
      }
   }
   cmd[0] = "-w" + locker;
   cmd[1] = "-u";
   cmd[2] = "-m Forcibly unlocked by " + this_player()->query_name();
   cmd += explode(arg, " ");
#ifdef DEBUG
   printf("CMD: %O\n", cmd);
#endif
   if (PLAYER_HANDLER->test_creator(locker)) {
      printf("Edit mail? (y/[n]): ");
    input_to("edit_mail", 0, new (class rcsforce_args, player: this_player(), cmd: cmd, locker: locker, filen:filen));
   } else {
      int fd;
      write("Not sending mail to " + locker + " since they are not a creator "
            "any more.\n");
      fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                       "close_call_back");
      TP = this_player();
      RET = "";
      LCK = locker;
   }
   return 1;
}
protected void edit_mail(string choice,
                         class rcsforce_args args)
{
   if (!strlen(choice) || lower_case(choice) == "n") {
      printf("No.\n");
      do_ci(0, args);
      return;
   }
   if (lower_case(choice) != "y") {
      printf("Invalid choice. Please answer y or n. (y/[n]): ");
      input_to("edit_mail", 0, args);
   } else {
      printf("Yes. Entering editor.\n");
      args->player->do_edit(0, "do_ci", this_object(), 0, args);
   }
}
void do_ci(string text,
           class rcsforce_args args)
{
   int fd;
   AUTO_MAILER->auto_mail(args->locker, args->player->query_name(),
                          "Automatic RCSForce Mail", "",
                          sprintf("Your file: %s, has been forcibly "
                                  "unlocked by: %s.\nEnjoy.\n\n"
                                  "Automatic RCSForce Mailer.\n", args->filen,
                                  args->player->query_name()) +
                          (strlen(text) ? "\n" + text : ""));
   fd =
      external_start(CMD_NUM, args->cmd, "read_call_back", "write_call_back",
                     "close_call_back");
   TP = args->player;
   RET = "";
   LCK = args->locker;
}
void read_call_back(int fd,
                    mixed mess)
{
   mess = replace(mess, "/home/atuin/lib", "");
   RET += mess;
}
void write_call_back(int fd)
{
   tell_object(TP, "rcsforce: write_call_back() called.\n");
}
void close_call_back(int fd)
{
   string file,
    *file_stuff;
   int i;
   if (RET != "") {
      TP->more_string(RET);
      file_stuff = explode(RET, "\n");
      i = 0;
      while (i + 2 < sizeof(file_stuff)) {
         if (file_stuff[i + 2] == "done") {
            sscanf(file_stuff[i], "%*s  <--  %s", file);
            RCS_HANDLER->remove_lock(LCK, file);
            i += 3;
         } else {
            if (file_stuff[i + 1][0..2] == "ci:") {
               i += 2;
            } else {
               i += 3;
            }
         }
      }
   } else {
      tell_object(TP, "rcsforce completed.\n");
   }
   map_delete(_ret, fd);
   map_delete(_globals, fd);
   map_delete(_lockers, fd);
}

==================================================
FILE: cmds/creator/rcsi_n.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 5
mapping globals = ([]), ret = ([]), cmds = ([]), comments = ([ ]);
#define TP globals[fd]
#define RET ret[fd]
#define CMDS cmds[this_player()]
#define COMMENT comments[TP]
mixed cmd(string arg) {
  int nfiles = 0;
  string bit, *bits, *tmp, *notin;
  object *things;
  if (!arg) {
    return notify_fail("rcsin: No arguments.\n");
  }
  bits = explode(arg, " ");
  arg = "";
  bits -= ({ "", 0 });
  notin = ({ });
  foreach(bit in bits) {
    string *files = ({ }), file;
    if (bit[0] == '-') {
      arg += (" " + bit);
      continue;
    }
    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        tmp = explode(file, "/");
        if(file_size("/" + implode(tmp[0..<2], "/") + "/RCS/" + tmp[<1]+",v") >
           0) {
          nfiles++;
          arg += (" " + file[1..]);
        } else {
          notin += ({ file });
        }
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";
        tmp = explode(file, "/");
        if(file_size("/" + implode(tmp[0..<2], "/") + "/RCS/" + tmp[<1]+",v") >
           0) {
          nfiles++;
          arg += (" " + file[1..]);
        } else {
          notin += ({ file });
        }
      }
    }
  }
  if(!nfiles) {
    if(sizeof(notin))
      return notify_fail("rcsin: file not in RCS " +
                         query_multiple_short(notin) + ".\n");
    else
      return notify_fail("rcsin: no such file "+arg+".\n");
  }
  if(sizeof(notin))
    write("rcsin: file not in RCS " + query_multiple_short(notin) + ".\n");
  printf("Enter a comment.\n");
  CMDS = arg;
  this_player()->do_edit(0, "do_ci");
  return 1;
}
void do_ci(string comment) {
  int fd;
  string *cmd = allocate(3);
  if (!comment) {
    printf("No comment given, aborting.\n");
    return;
  }
  cmd[0] = "-w" + this_player()->query_name();
  cmd[1] = "-u";
  cmd[2] = "-m"+comment;
  cmd += explode(CMDS, " ");
#ifdef DEBUG
  printf("CMD: %O\n", cmd);
#endif
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
  TP = this_player();
  RET = "";
  COMMENT = comment;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcsin: Write_call_back called.\n");
}
void close_call_back(int fd) {
  string file, *file_stuff, *bits, log, lname;
  int i;
  object master;
  if (RET != "") {
    TP->more_string(RET);
    file_stuff = explode(RET, "\n");
    i = 0;
    while (i + 2 < sizeof(file_stuff))  {
      if (file_stuff[i + 2] == "done")  {
        sscanf(file_stuff[i], "%*s  <--  %s", file);
        RCS_HANDLER->remove_lock(TP, file);
        if(file[0] == 'w')
          lname = "";
        else if(file[0] == 'd') {
          bits = explode(file, "/");
          if(sizeof(bits) >= 2 &&
             member_array(bits[1], "/secure/master"->query_domains()) != -1) {
            master = find_object("/d/" + bits[1]+"/master");
            if(!master)
              TP->tell_object("No master object for domain: " + bits[1] +
                              ".\n");
            else
              lname = master->query_changelog(file);
          }
          if(!lname)
            lname = "/d/" + explode(file, "/")[1] + "/ChangeLog";
        } else
          lname = "/log/ChangeLog";
        if(lname != "") {
          log = TP->fix_string(sprintf(" * %s %s %s\n%s\n",
                                       ctime(time())[4..],
                                       file, TP->query_name(),
                                       COMMENT), 80, 21);
          log_file(lname, log);
        }
        i += 3;
      } else if (sscanf(file_stuff[i], "%*sNo such file or directory"))  {
        ++i;
      } else if (file_stuff[i + 1][0..2] == "ci:") {
          i += 2;
      } else {
          i += 3;
      }
    }
  } else {
    tell_object(TP, "rcsin completed.\n");
  }
  map_delete(ret, fd);
  map_delete(globals, fd);
  map_delete(comments, TP);
}

==================================================
FILE: cmds/creator/rcsl_og.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 1
mapping globals = ([]), files = ([]), ret = ([]);
#define TP globals[fd]
#define RET ret[fd]
mixed cmd(string arg) {
  int fd, nfiles = 0;
  string cmd;
  string bit, *bits;
  object *things;
  if(!arg)
    return notify_fail("rcslog: No arguments.\n");
  notify_fail("rcslog: No such file "+arg+"\n");
  bits = explode(arg, " ");
  arg = "";
  bits -= ({""});
  foreach(bit in bits){
    string *files = ({ }), file;
    if (bit[0] == '-'){
      arg += (" " + bit);
      continue;
    }
    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";
        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }
  if(!nfiles)
    return 0;
  cmd =  arg;
#ifdef DEBUG
  printf("CMD: %s\n", cmd);
#endif
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
  TP = this_player();
  RET = "";
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcslog: Whoops! fatal error.\n");
}
void close_call_back(int fd) {
  if(RET != "")
    TP->more_string(RET);
  else
    tell_object(TP, "rcslog completed.\n");
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/rcsloc_ks.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define DEBUG 1
#define CMD_NUM 5
mapping globals = ([]), ret = ([]);
#define TP globals[fd]
#define RET ret[fd]
mixed cmd(string arg) {
  int nfiles = 0;
  string bit, *bits, file, locker, *files, fname;
  object *things;
  if (!arg) {
    return notify_fail("rcslocks: No arguments.\n");
  }
  bits = explode(arg, " ");
  arg = "";
  bits -= ({ "", 0 });
  files = ({ });
  foreach(bit in bits) {
    if (bit[0] == '-') {
      arg += (" " + bit);
      continue;
    }
    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";
        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }
  if(!nfiles) {
    return notify_fail("rcslocks: no such file "+arg+".\n");
  }
  foreach(fname in files) {
    string lockline;
    bits = explode(fname, "/");
    file = "/" + (string)implode(bits[0..<2], "/") + "/RCS/" + bits[<1] + ",v";
    if (file_size(file) < 0) {
      write("File " + fname + " is not on RCS.\n");
    } else {
      lockline = read_file(file, 4, 1);
      if (strsrch(lockline, "locks; strict:") == -1) {
        bits = explode(read_file(file, 5, 1), ":");
        if(bits[0][0] == '\t') {
          locker = bits[0][1..];
          write("File " + fname + " locked by " + locker + ".\n");
        }
        else write(fname + " is not locked.\n");
      }
    }
  }
  return 1;
}

==================================================
FILE: cmds/creator/rcso_ut.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 3
mapping globals = ([]), files = ([]), ret = ([]);
#define TP globals[fd]
#define RET ret[fd]
mixed cmd(string arg) {
  int fd, nfiles = 0;
  int force;
  string cmd;
  string bit, *bits;
  object *things;
  if(!arg) {
    return notify_fail("rcsout: No arguments.\n");
  }
  bits = explode(arg, " ");
  arg = "";
  bits -= ({""});
  if (bits[0] == "-f") {
    force = 1;
    bits = bits[1..];
  }
  foreach(bit in bits){
    string *files = ({ }), file;
    if (bit[0] == '-'){
      arg += (" " + bit);
      continue;
    }
    if (sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
      int i;
      files = uniq_array(map(things, (: base_name($1) :)));
      for (i = 0; i < sizeof(files); i++) {
        if (file_size(files[i]) <= 0) {
          files[i] += ".c";
        }
      }
    }
    files += this_player()->get_files(bit);
    if (!sizeof(files)) {
      file = this_player()->get_path(bit);
      if(master()->valid_write(file, geteuid(this_player()), "cmd")) {
        arg += (" " + file[1..]);
        nfiles++;
      } else {
        notify_fail("You do not have write access to "+file+"\n");
      }
    } else {
      foreach(file in uniq_array(files)) {
        if(master()->valid_write(file, geteuid(this_player()), "cmd")) {
          arg += (" " + file[1..]);
          nfiles++;
        } else {
          notify_fail("You do not have write access to "+file+"\n");
        }
      }
    }
  }
  if(!nfiles) {
    return 0;
  }
  if (force) {
     cmd = " -l -f -w" + this_player()->query_name() +arg;
  } else  {
     cmd = " -l -w" + this_player()->query_name() +arg;
  }
#ifdef DEBUG
  printf("CMD: %s\n", cmd);
#endif
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
  TP = this_player();
  RET = "";
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcsout: Whoops! fatal error.\n");
}
void close_call_back(int fd) {
  string file, *file_stuff;
  int i;
  if(RET != "")  {
    TP->more_string(RET);
    file_stuff = explode(RET, "\n");
    i = 0;
    while (i + 2 < sizeof(file_stuff))  {
      if (file_stuff[i + 2] == "done")  {
        sscanf(file_stuff[i], "%*s  -->  %s", file);
        RCS_HANDLER->add_lock(TP, file);
        i += 3;
      }
      else if (sscanf(file_stuff[i], "%*sNo such file or directory"))  {
        ++i;
      }
      else if (file_stuff[i + 1][0 .. 2] == "co:")  i += 2;
      else i += 3;
    }
  }
  else
    tell_object(TP, "rcsout completed.\n");
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/rcsr_elease.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 3
mapping globals = ([]), files = ([]), ret = ([]);
#define TP globals[fd]
#define RET ret[fd]
mixed cmd(string arg) {
  int fd, nfiles = 0;
  string cmd;
  string bit, *bits;
  object *things;
  if(!arg)
    return notify_fail("rcsrelease: No arguments.\n");
  notify_fail("No such file: "+arg+"\n");
  bits = explode(arg, " ");
  arg = "";
  bits -= ({""});
  foreach(bit in bits){
    string *files = ({}), file;
    if (bit[0] == '-'){
      arg += (" " + bit);
      continue;
    }
    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        if(master()->valid_write(file, geteuid(this_player()), "cmd")) {
          arg += (" " + file[1..]);
          nfiles++;
        } else
          notify_fail("You do not have write access to "+file+"\n");
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";
        if(master()->valid_write(file, geteuid(this_player()), "cmd")) {
          arg += (" " + file[1..]);
          nfiles++;
        } else
          notify_fail("You do not have write access to "+file+"\n");
      }
    }
  }
  if(!nfiles)
    return 0;
  cmd = " -f -u -w" + this_player()->query_name() +arg;
#ifdef DEBUG
  printf("CMD: %s\n", cmd);
#endif
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
  TP = this_player();
  RET = "";
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcsrelease: Whoops! fatal error.\n");
}
void close_call_back(int fd) {
  string file, *file_stuff;
  int i;
  if(RET != "")  {
    TP->more_string(RET);
    file_stuff = explode(RET, "\n");
    i = 0;
    while (i + 2 < sizeof(file_stuff))  {
      if (file_stuff[i + 2] == "done")  {
        sscanf(file_stuff[i], "%*s  -->  %s", file);
        RCS_HANDLER->remove_lock(TP, file);
        i += 3;
      }
      else if (sscanf(file_stuff[i], "%*sNo such file or directory"))  {
        ++i;
      }
      else if (file_stuff[i + 1][0..2] == "co:") {
          i += 2;
      }
      else {
          i += 3;
      }
    }
  }
  else
    tell_object(TP, "rcsrelease completed.\n");
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/rcsre_vert.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#define CMD_NUM 8
mapping globals = ([]), ret = ([]);
#define TP globals[fd]
#define RET ret[fd]
mixed cmd(string arg) {
  int nfiles, fd;
  string bit, *bits, *cmd;
  object *things;
  if (!arg) {
    return notify_fail("rcsrevert: No arguments.\n");
  }
  bits = explode(arg, " ");
  arg = "";
  bits -= ({ "", 0 });
  foreach(bit in bits) {
    string *files, file;
    if (bit[0] == '-') {
      arg += (" " + bit);
      continue;
    }
    if (sizeof(files = this_player()->get_files(bit))) {
      foreach(file in files) {
        arg += (" " + file[1..]);
        nfiles++;
      }
    } else {
      if(sizeof(things = WIZ_PRESENT->wiz_present(bit, this_player()))) {
        file = file_name(things[0]);
        sscanf(file, "%s#%*d", file);
        if (file_size(file) <= 0)
          file += ".c";
        arg += (" " + file[1..]);
        nfiles++;
      }
    }
  }
  if(!nfiles) {
    return notify_fail("rcsrevert: no such file "+arg+".\n");
  }
  cmd = allocate(3);
  cmd[0] = "-w" + this_player()->query_name();
  cmd[1] = "-u";
  cmd[2] = "-l";
  cmd += explode(arg, " ");
#ifdef DEBUG
  printf("CMD: %O\n", cmd);
#endif
  fd = external_start(CMD_NUM, cmd, "read_call_back", "write_call_back",
                      "close_call_back");
  TP = this_player();
  RET = "";
  return 1;
}
void read_call_back(int fd, mixed mess) {
  mess = replace(mess, "/home/atuin/lib", "");
  RET += mess;
}
void write_call_back(int fd) {
  tell_object(TP, "rcsrevert: write_call_back() called.\n");
}
void close_call_back(int fd) {
  if (RET != "") {
    TP->more_string(RET);
  } else {
    tell_object(TP, "rcsin completed.\n");
  }
  map_delete(ret, fd);
  map_delete(globals, fd);
}

==================================================
FILE: cmds/creator/rmp_layer.c
==================================================

#include <refresh.h>
#include <player_handler.h>
#include <player_handler.h>
inherit "/cmds/base";
private void sure(string response, string player, string lord, string reason,
                  int immediately) {
  if(previous_object() &&
     member_array(find_object("/secure/simul_efun"),
                  previous_object( -1 ) ) == -1 ) {
    log_file("CHEAT", ctime(time()) +
             ": illegal attempt to delete a player.\nTrace: " +
             back_trace());
    write("Illegal use of rmplayer.\n");
    return;
  }
  if (response == "YES") {
    string olduid, src, ext;
    write("Ok.  Deleting\n");
    olduid = geteuid();
    seteuid("Root");
    if(file_size(PLAYER_HANDLER->query_player_ram_file_name(player)+".o.gz") > 0){
      src = PLAYER_HANDLER->query_player_ram_file_name(player);
      ext = ".o.gz";
    } else if(file_size(PLAYER_HANDLER->query_player_disk_file_name(player)+".o.gz") > 0) {
      src = PLAYER_HANDLER->query_player_disk_file_name(player);
      ext = ".o.gz";
    } else if(file_size(PLAYER_HANDLER->query_player_disk_file_name(player)+".o") > 0) {
      src = PLAYER_HANDLER->query_player_disk_file_name(player);
      ext = ".o";
    } else if(file_size(PLAYER_HANDLER->query_delete_player_file_name(player) + ".o.gz") > 0) {
      src = PLAYER_HANDLER->query_delete_player_file_name(player);
      ext = ".o.gz";
    } else if(file_size(PLAYER_HANDLER->query_delete_player_file_name(player)+ ".o") > 0) {
      src = PLAYER_HANDLER->query_delete_player_file_name(player);
      ext = ".o";
    }
    if(src && ext) {
      if(!immediately)
        unguarded((: cp($(src) + $(ext), "/save/players/appeal/"+
                        $(player)+$(ext)):));
      unguarded((: rm($(src)+$(ext)) :));
      if(src == PLAYER_HANDLER->query_player_ram_file_name(player)) {
        src = PLAYER_HANDLER->query_player_disk_file_name(player);
        unguarded((: rm($(src)+$(ext)) :));
      }
      PLAYER_HANDLER->remove_cache_entry( player );
      unguarded((: write_file, "/log/SUSPEND",
                 ctime(time()) + " "+ player + " deleted by " + lord +
                 " because " + reason + ".\n" :) );
      seteuid(olduid);
    }
  } else {
    write("Ok.  Not deleting\n");
  }
  return;
}
int cmd(string player, string reason, int immediately) {
  if (!master()->query_liaison_deputy_or_lord(previous_object(-1))) {
    unguarded((: log_file, "/log/CHEAT", ctime(time()) +
               ": illegal attempt to delete a player.\nTrace: " +
               back_trace() :));
    return notify_fail("Sorry: only directors can delete players.\n");
  }
  if (!PLAYER_HANDLER->test_user(player)) {
    return notify_fail("Sorry, but " + player + " isn't a player\n");
  }
  if (!master()->high_programmer(previous_object(-1)) &&
      master()->query_lord(player)) {
    unguarded( (: log_file, "/log/CHEAT", ctime(time()) +
                ": Illegal attempt to delete a director.\nTrace: " +
                back_trace() :) );
    return notify_fail("Sorry.\n");
  }
  if(!master()->query_lord(previous_object(-1)) &&
       PLAYER_HANDLER->test_age(player) < - (86400)) {
    add_failed_mess("Only directors can immediately delete players over "
                    "24 hours old.\n");
    return 0;
  }
  if (!master()->query_lord(previous_object(-1)) &&
      PLAYER_HANDLER->test_creator(player)) {
    add_failed_mess("You cannot delete creators.\n");
    return 0;
  }
  if(!reason || reason == "") {
    return notify_fail("You must give a reason.\n");
  }
  write("This will permanently delete the player " + player + ".\n" +
        "THIS IS PERMANENT.\n" +
        "Are you sure?  (only \"YES\" will delete the player)  ");
  input_to((: sure :), 0, player, this_player()->query_name(), reason,
           immediately);
  return 1;
}
mixed *query_patterns() {
  return ({ "<word'player name'> <string'reason'>", (: cmd($4[0], $4[1], 0) :),
            " immediately <word'player name'> <string'reason'>",
              (: cmd($4[0], $4[1], 1) :) });
}

==================================================
FILE: cmds/creator/ta_il.c
==================================================

#include <creator.h>
inherit "/cmds/base";
mixed cmd( string str, int num ) {
   string *filenames;
   int loop;
   object *obs;
   if (num < 0)  {
      num = -num;
   }
   if (num == 0)  {
      num = 20;
   }
   if ( !str ) {
      notify_fail( "Tail what file(s)/object(s)?\n" );
      return 0;
   }
   if ( !sizeof( filenames = this_player()->get_files( str ) ) ) {
      if ( sizeof( obs = WIZ_PRESENT->wiz_present( str, this_player() ) ) ) {
         filenames = map( obs, (: base_name($1) :) );
         filenames = map( filenames,
           (: ( file_size($1) <= 0 ? $1 + ".c" : $1 ) :) );
      } else
         return notify_fail( str + ": No such file(s)/object(s).\n" );
   }
   foreach( str in filenames )
      if( ( file_size( str ) == -2 ) || ( str[<2..<1] == ".." ) )
         filenames -= ({ str });
   for( loop = 0; loop < sizeof( filenames ); loop++ ) {
      str = filenames[loop];
      if( sizeof( filenames ) > 1 ) {
         printf( "%*'-'s\nFILE : %s\n", 80, "", str );
      }
      if ( file_size( str ) < 0)
         write( "That file/object is not readable, or does not exist.\n" );
      else {
         write( read_file( str, ( ( file_length( str ) + 1 ) - num ) ) );
      }
   }
   return 1;
}
mixed *query_patterns()  {
   return ({ "<number> <string>", (: cmd($4[1], to_int( $4[0] ) ) :) ,
             "<string>", (: cmd($4[0], 20) :) });
}

==================================================
FILE: cmds/creator/upd_ate.c
==================================================

#include <creator.h>
inherit "/cmds/base";
protected int do_update(object *ov) {
   string pname;
   object *invent;
   object rsv;
   object env;
   object dup;
   object loaded;
   object ob;
   mixed static_arg;
   mixed dynamic_arg;
   int i;
   rsv = load_object("room/void");
   if (!rsv) {
      return notify_fail("The void is lost!\n");
   }
   foreach (ob in ov) {
      if (!ob) {
         continue;
      }
      if (interactive(ob)) {
         write("Can't update interactive object: " + ob->query_name() + "\n");
         continue;
      }
      env = environment(ob);
      invent = all_inventory(ob);
      for (i = 0; i < sizeof(invent); i++) {
         if (userp(invent[i]) ||
             invent[i]->query_property("unique")) {
             invent[i]->move(rsv);
         } else {
             invent = delete(invent, i--, 1);
         }
      }
      pname = file_name(ob);
      if (sscanf(pname, "%s#%*d", pname) != 2) {
         static_arg = ob->query_static_auto_load();
         dynamic_arg = ob->query_dynamic_auto_load();
         ob->dest_me();
         if (ob) {
            ob->dwep();
         }
         if (ob) {
            destruct(ob);
         }
         if (ob) {
            return notify_fail("I can't seem to destruct the old object.\n");
         }
         ob = load_object(pname);
         if (static_arg) {
             ob->init_static_arg(static_arg);
         }
         if (dynamic_arg) {
            ob->init_dynamic_arg(dynamic_arg);
         }
      } else {
         loaded = find_object(pname);
         static_arg = ob->query_static_auto_load();
         dynamic_arg = ob->query_dynamic_auto_load();
         if (loaded) {
            loaded->dest_me();
         }
         if (loaded) {
            loaded->dwep();
         }
         if (loaded) {
            destruct(loaded);
         }
         dup = clone_object(pname);
         if (dup && ob) {
             ob->dest_me();
             if (ob) {
                ob->dwep();
             }
             if (ob) {
                destruct(ob);
            }
            ob = dup;
            if (static_arg) {
                ob->init_static_arg(static_arg);
            }
            if (dynamic_arg) {
                ob->init_dynamic_arg(dynamic_arg);
            }
         }
      }
      if (!ob) {
         printf("I seem to have lost your object.\n");
         return 1;
      }
      for (i = 0; i < sizeof(invent); i++) {
         if (invent[i]) {
            invent[i]->move(ob);
         }
      }
      if (env) {
         ob->move(env);
      }
      printf("Updated %s.\n", WIZ_PRESENT->desc_f_object(ob));
   }
   return 1;
}
mixed cmd(string str) {
   string tring;
   string* filenames;
   string err;
   object ob;
   object* val;
   object* obs;
   int loop;
   notify_fail("No such object.\n");
   tring = str;
   if (!str || str == "here") {
      str = file_name(environment(this_player()));
      if (str == "/room/void") {
         notify_fail("The Surgeon General warns you that it is hazardous to "
                     "update the void while standing in it.\n");
         return 0;
      }
      str = base_name(str);
      filenames = ({ "/" + str });
      str = "here";
   } else {
      filenames = this_player()->get_cfiles(str);
   }
   if (sizeof(filenames) == 0) {
      val = WIZ_PRESENT->wiz_present(tring, this_player());
      if (!sizeof(val)) {
         notify_fail("No matching objects/filenames\n");
         return 0;
      }
      return do_update(val);
   }
   obs = ({ });
   for (loop = 0; loop < sizeof(filenames); loop++) {
      str = filenames[loop];
      ob = find_object(str);
      if (!ob) {
          if (file_size(str) >= 0) {
             if (!(err = catch(load_object(str)))) {
                 printf("Loaded %s\n", str);
             } else {
                 printf("Failed to load %s, error: %s\n", str, err);
             }
          } else {
              val = WIZ_PRESENT->wiz_present(tring, this_player());
              obs += val;
          }
      } else {
          obs += ({ ob });
      }
   }
   if (!obs) {
      return 0;
   } else {
      return do_update(obs);
   }
}

==================================================
FILE: cmds/creator/zcat.c
==================================================

#include <creator.h>
#include <runtime_config.h>
#define TP globals[fd]
#define RET ret[fd]
#define CMD_NUM 9
inherit "/cmds/base";
private mapping globals = ([]), files = ([]), ret = ([]);
int cmd( string fname, int list ) {
    string *files;
    string euid;
    string args;
    int fd;
    int count;
    files = this_player()->get_files( fname );
    if ( !sizeof( files ) ) {
        files += ({ this_player()->get_path( fname ) });
    }
    euid = geteuid( this_player(1) );
    args = "--stdout";
    if ( list ) {
        args += " --list";
    }
    files = uniq_array( files );
    count = 0;
    foreach( string file in files ) {
        if ( !master()->valid_read( file, euid, "cat" ) ) {
            tell_object( this_player(), "You don't have write access to "
                +  file + ".\n" );
        }
        else {
            args += " " + file[1..];
            ++count;
        }
    }
    if ( count ) {
        log_file("/d/admin/log/ZCAT", ctime(time()) + ": " +
                 this_player()->query_name() + " " + args + "\n");
        fd = external_start( CMD_NUM, args, "read_call_back",
            "write_call_back", "close_call_back" );
    }
    else {
        add_failed_mess( "zcat must have at least one argument.\n" );
        return -1;
    }
    if ( fd == -1 ) {
        add_failed_mess( "zcat failed to start.\n" );
        return -1;
    }
    TP = this_player();
    RET = "";
    tell_object( this_player(), "zcat started.\n" );
    return 1;
}
void read_call_back(int fd, mixed mess) {
    int max_len;
    int new_total;
    mess = replace(mess, "/bin/", "");
    max_len = get_config( __MAX_STRING_LENGTH__ );
    new_total = strlen( RET ) + strlen( mess );
    if ( new_total > max_len ) {
        mess = mess[ 0.. (new_total - max_len - 1) ];
    }
    RET += mess;
}
void write_call_back( int fd ) {
    tell_object(TP, "zcat: A fatal error has occurred -- write_call_back "
        "was called.\n");
}
void close_call_back(int fd) {
    if ( RET != "" ) {
        if ( catch( TP->more_string(strip_colours(RET)) ) ) {
            efun::tell_object( TP, RET );
        }
    }
    else {
        tell_object(TP, "zcat finished.\n");
    }
    map_delete(ret, fd);
    map_delete(globals, fd);
}
mixed *query_patterns() {
    return ({ "<string>", (: cmd( $4[0], 0 ) :),
              "{-l|--list|list} <string>", (: cmd( $4[1], 1 ) :)
    });
}

==================================================
FILE: master/compile_to_c.c
==================================================

void compile_everything() {
  generate_source(load_file("compile_to_c"));
}

==================================================
FILE: master/crash.c
==================================================

void crash(string crash_mess, object command_giver, object current_object) {
  object thing, *things;
  string crashtxt;
  reset_eval_cost();
  log_file("CRASH", "\n"+ ctime(time()) +":\n");
  if (current_object)
    log_file("CRASH", "current object: "+ file_name(current_object) +
             " ("+ current_object->query_name() +")\n");
  if (command_giver)
    log_file("CRASH", "command giver: "+ file_name(command_giver) +
             " ("+ (string)command_giver->query_name() +")\n");
  if (query_verb())
    log_file("CRASH", "command given: "+ query_verb() +"\n");
  log_file("CRASH", "crash reason: "+ crash_mess +"\n");
  things = users();
  log_file("CRASH", "["+ implode((string *)things->query_name(), ", ") +
           "]\n");
  flush_log_files();
  crashtxt = "Wodan "+({"says: I wonder what this button does...",
                        "says: Ceres, look out for that wire....",
                        "says: Wow, look at the uptime.",
                        "whispers: I don't think we should be doing this on my desk..",
                        "shouts: Look at all that xp!"})[random(5)];
  foreach (thing in things) {
    reset_eval_cost();
    efun::tell_object(thing, crashtxt + "\n("+ crash_mess +")\n");
    catch(thing->quit());
  }
}

==================================================
FILE: master/create_dom_creator.c
==================================================

#include <quest_handler.h>
#include <player_handler.h>
#include <player_handler.h>
#define BACKUP_DIR "/save/creators/"
int employ_creator( string name );
int create_domain( string name , string lord );
int dismiss_creator( string str );
int eligible_creator( object player );
void backup_vaults(string, int);
void backup_bank(string, int);
void backup_quest_library(string, int);
int create_domain(string name, string lord) {
  string file;
  object *interactives;
  if (!( master()->high_programmer(previous_object(-1)) &&
        sizeof((interactives = filter(previous_object(-1),
                                      (: interactive($1) :))) ))) {
    write("Cheat!\n");
    return 0;
  }
  if ( master()->high_programmer(capitalize(name))) {
    write("Invalid name....\n");
    return 0;
  }
  if (file_size("/d/"+name) != -1) {
    write("Domain already exists (or invalid).\n");
    return 0;
  }
  if (sizeof(explode(name, "/")) > 1) {
    write("Invalid to have a / in the domain name.\n");
    return 0;
  }
  if (!PLAYER_HANDLER->test_creator(lord)) {
    write("The lord must exist.... and be a creator already.\n");
    return 0;
  }
  mkdir("/d/"+name);
  master()->add_lord(lord);
  file = read_file("/std/dom/master.c");
  write_file("/d/"+name+"/master.c", "#define LORD \""+lord+"\"\n");
  write_file("/d/"+name+"/master.c", "#define DOMAIN \""+name+"\"\n");
  write_file("/d/"+name+"/master.c", file);
  file = read_file("/std/dom/common.c");
  write_file("/d/"+name+"/common.c",
             "#define DOM_TITLE \"the domain of "+name+"\"\n");
  write_file("/d/"+name+"/common.c", "#define LORD \""+lord+"\"\n");
  write_file("/d/"+name+"/common.c", "#define DOMAIN \""+name+"\"\n");
  write_file("/d/"+name+"/common.c", file);
  file = read_file("/std/dom/loader.c");
  write_file("/d/"+name+"/loader.c", "#define DOMAIN \""+name+"\"\n");
  write_file("/d/"+name+"/loader.c", file);
  save_object("/secure/master");
  write("Created domain "+name+".\n");
  write_file("/log/PROMOTIONS", "Domain "+name+" created with a lord of "+
             lord+" by "+geteuid(interactives[0])+" at "+ctime(time())+"\n");
  return 1;
}
int employ_creator(string name) {
  object *interactives;
  string fname;
  if (!( master()->query_lord(previous_object(-1)) &&
        sizeof((interactives = filter(previous_object(-1),
                                      (: interactive($1) :))))))
    return 0;
  if (!PLAYER_HANDLER->test_user(name)) {
    write("User does not exist.\n");
    return 1;
  }
  if (file_size("/save/creators/"+ name + "/save_file.o") > 0) {
    write( "Player file has already been backed up.\n" );
    return 1;
  }
  fname = PLAYER_HANDLER->query_player_file_name(name);
  if (file_size(fname + ".o.gz") > 0) {
    unguarded((: uncompress_file, fname + ".o.gz" :));
  }
  mkdir (BACKUP_DIR + name);
  unguarded((: cp, fname + ".o",
               "/save/creators/" + name + "/save_file.o" :));
  backup_vaults(name, 0);
  backup_bank(name, 0);
  backup_quest_library(name, 0);
  if (find_player(name)) {
    find_player(name)->set_creator(1);
    find_player(name)->save();
    tell_object( find_player( name ), "You have been employed by "+
                 capitalize( geteuid( interactives[0] ) ) +".\n" );
    tell_object( find_player( name ), "Quit and log back in to get the "
                 "creator commands.\n" );
    tell_object( find_player( name ), "Be sure to look over the "
                 "directories, especially /doc.  \"help create\" will give "
                 "you a brief list of commands.\n" );
    tell_object( find_player( name ), "Womble on, mighty frog.\n" );
  } else {
    unguarded((: write_file, fname + ".o",
                 "creator 1\nhome_dir \"/w/"+ name +"\"\n" :));
  }
  unguarded((: compress_file, fname + ".o.gz" :));
  if ( file_size( "/w/"+ name ) == -1 ) {
    unguarded((: mkdir, "/w/"+ name :));
    unguarded((: write_file, "/w/"+ name +"/workroom.c",
                 "#define CREATOR \""+ name +"\"\n" :));
    unguarded((: write_file, "/w/"+ name +"/workroom.c",
                 read_file( "/std/creator/workroom.c" ) :));
    unguarded((: cp, "/std/creator/creator_kit.o", "/w/" + name +
                 "/creator_kit.o" :));
  }
  unguarded((: write_file, "/log/EMPLOYMENT",
               sprintf( "%s: %s employed by %s\n", ctime( time() ), name,
                        (string)interactives[0]->query_name() ) :));
  write( capitalize( name ) +" employed.\n" );
  PLAYER_HANDLER->remove_cache_entry(name);
  return 2;
}
int dismiss_creator(string str) {
  string name;
  string reason;
  string fname;
  string save_file;
  object *interactives;
  if (!( master()->query_lord(previous_object(-1)) &&
        sizeof((interactives = filter(previous_object(-1),
                                      (: interactive($1) :))))))
    return 0;
  if (sscanf(str, "%s %s", name, reason) != 2) {
    notify_fail("You need to give a reason!\n");
    return 0;
  }
  if (!PLAYER_HANDLER->test_creator(name)) {
    return notify_fail(name + " is not a creator!\n");
  }
  if ( master()->query_lord(name)) {
    write( "Cannot dismiss Lords.\n" );
    return 0;
  }
  unguarded((: write_file, "/log/DISMISSALS",
               sprintf( "%s: %s dismissed by %s\nreason: %s\n",
                        ctime( time() ), name,
                        (string)interactives[0]->query_name(), reason ) :));
  fname = PLAYER_HANDLER->query_player_file_name(name);
  if (find_player(name)) {
    find_player(name)->set_creator(0);
    find_player(name)->save();
    tell_object(find_player(name),
                "You have been dismissed by "+
                capitalize( (string)interactives[0]->query_name() ) +".\n" );
    find_player(name)->quit();
    if (file_size(fname + ".o.gz") != -1) {
       unguarded((: uncompress_file, fname + ".o.gz" :));
    }
  } else {
    if (file_size(fname + ".o.gz") != -1) {
       unguarded((: uncompress_file, fname + ".o.gz" :));
    }
    unguarded((: write_file, fname+".o",
                 "creator 0\nhome_dir 0\n" :));
    unguarded((: compress_file, fname+".o" :));
  }
  write( capitalize( name ) +" dismissed.\n" );
  save_file = "/save/creators/" + name + "/save_file.o";
  if (file_size (save_file) == -1) {
    save_file = BACKUP_DIR + name + ".o";
  }
  backup_vaults (name, 1);
  backup_bank (name, 1);
  backup_quest_library (name, 1);
  if (file_size(save_file) > 0) {
    unguarded((: write_file, save_file, "last_log_on "+time()+"\n" :));
    unguarded((: cp, save_file, fname+".o" :));
    unguarded((: rm, save_file :));
    unguarded((: rm, fname+".o.gz" :));
    unguarded((: compress_file, fname+".o" :));
  }
  if(file_size("/w/"+name) == -2) {
    unguarded((: rename, "/w/"+name, "/w/.old_creators/"+name :) );
  }
  rm (save_file);
  rmdir (BACKUP_DIR + name);
  PLAYER_HANDLER->remove_cache_entry(name);
  return 1;
}
int eligible_creator( object player ) {
  int age, level;
  string age_str, reasoning;
  reasoning =
    "  You do not have a *right* to create here.  In order to enhance your\n"
    "chances to be employed, you should demonstrate by your actions that you\n"
    "are worthy.\n"
    "  If our Creators find lots of your bug, typo, and idea reports in their\n"
    "directories, then your chances are improved.  If you have been a trouble-\n"
    "maker here, your chances are very slim.  Harrassing the Lords for a\n"
    "position will not help your chances either.\n"
    "  Having access to a MUD's file system is a great responsibility.  It\n"
    "cannot be given out to strangers who have not demonstrated their trust-\n"
    "worthiness.  After investing a fair amount of your time and energy in\n"
    "playing at DiscWorld, you are less likely to try to hurt it.  This is\n"
    "why we cannot give out instant creatorships unless we know you from\n"
    "elsewhere.  Please try to be understanding about our policy.\n\n";
  age   = - ( (int) player->query_time_on() );
  level = (int)player->query_level();
  if ( ( level >= 150 ) && ( age > 432000 ) ) {
    write("  You have achieved the *minimum* requirements necessary to apply "
          "for a\n"
          "creatorship at " + mud_name() + ".  You must now pass a review of the Lords "
          "to be\naccepted.\n"+ reasoning );
    return 1;
  }
  age_str = "";
  if ( age >  86400 )
    age_str += sprintf( "%d day" , age/86400 );
  if ( age > 172800 )
    age_str += "s";
  if ( age%86400 > 3600) {
    if ( age > 86400 )
      age_str += " and ";
    age_str += sprintf( "%d hour" , (age%86400)/3600 );
  }
  if ( age%86400 > 7200)  age_str += "s";
  write("  The *minimum* requirements to apply for a creatorship on " + mud_name() + " "
        "are\nto be level 150 in your guild and at least five "
        "days old .\nYou are level " + level + ", and your age is "+
        age_str + ".\n" + reasoning );
  return 0;
}
private void backup_vaults(string name, int restore) {
  string base = "/save/vaults/";
  string creator_dir = BACKUP_DIR + name + "/vaults/";
  string *vaults, *tmp;
  string file;
  if (!restore) {
    vaults = get_dir (base);
    mkdir (creator_dir);
    foreach (string vault in vaults) {
      file = base + vault + "/" + name + ".o";
      if (file_size (file) != -1) {
        cp (file, creator_dir + "/" + vault + ".o");
      }
    }
  }
  else {
    if (file_size (creator_dir) == -1) {
      return;
    }
    vaults = get_dir (base);
    foreach (string vault in vaults) {
      file = base + vault + "/" + name + ".o";
      if (file_size (file) != -1) {
        rm (file);
      }
    }
    vaults = get_dir (creator_dir);
    foreach (string vault in vaults) {
      tmp = explode (vault, ".");
      cp (creator_dir + vault, base  + tmp[0] + "/" + name  + ".o");
      rm (creator_dir + vault);
    }
    rmdir (creator_dir);
  }
}
private void backup_bank (string name, int restore) {
  string base = "/save/bank_accounts/";
  string bank_file = base + name[0..0] + "/" + name + ".o";
  string bank_dir = BACKUP_DIR + name + "/bank_account";
  string saved_file;
  if (!restore) {
    mkdir (bank_dir);
    if (file_size (bank_file) == -1) {
      return;
    }
    cp (bank_file, bank_dir);
  }
  else {
    saved_file = bank_dir + "/" + name + ".o";
    if (file_size (bank_dir) == -1) {
      return;
    }
    rm (bank_file);
    if (file_size (saved_file) == -1) {
      return;
    }
    cp (saved_file, bank_file);
    rm (saved_file);
    rmdir (bank_dir);
  }
}
private void backup_quest_library (string name, int restore) {
  string base = "/save/library/";
  string library_file = base + name[0..0] + "/" + name + ".o";
  string library_dir = BACKUP_DIR + name + "/quest_library";
  string saved_file;
  if (!restore) {
    mkdir (library_dir);
    if (file_size (library_file) == -1) {
      return;
    }
    cp (library_file, library_dir);
  }
  else {
    saved_file = library_dir + "/" + name + ".o";
    if (file_size (library_dir) == -1) {
      return;
    }
    rm (library_file);
    if (file_size (saved_file) == -1) {
      return;
    }
    cp (saved_file, library_file);
    rm (saved_file);
    rmdir (library_dir);
  }
}

==================================================
FILE: master/creator_file.c
==================================================

varargs mixed creator_file(string file, int author) {
  string *str;
  if (!file || !stringp(file)) return "NOONE";
  str = explode(file, "/") - ({ "" });
  if (sizeof(str)<2) return 0;
  switch (str[0]) {
   case "secure" :
     return get_root_uid();
   case "obj" :
     if (sizeof(str) > 2 && str[1] == "secure")
       return "ims";
   case "global" :
   case "std" :
   case "cmds" :
   case "room" :
     return get_bb_uid();
   case "net" :
     return "Network";
  case "www" :
    if (sizeof(str) > 2 && str[1] == "secure")
      return "Root";
    return "WWW";
   case "tmp" :
     if (str[1] != "mon-shad")
       return 0;
     return "monster";
   case "failsafe" :
     return "failsafe";
   case "d" :
     if (sizeof(str) < 3)
       return 0;
     if (!author || member_array(query_domains(), str) == -1)
       return capitalize(str[1]);
     return ("/d/"+str[1]+"/master")->author_file(str);
   case "w" :
     if (sizeof(str) < 3)
       if (str[1] == "common" || str[1] == "development" ||
           str[1] == "meeting")
         return "womble-frog";
       else
         return 0;
     return str[1];
  }
}
mixed author_file(mixed bing) {
  return creator_file(bing, 1);
}
mixed domain_file(mixed bing) {
  string str;
  str = creator_file(bing);
  if (!str) return str;
  if (str[0] >= 'A' && str[0] <= 'Z') return str;
  return "Creator";
}

==================================================
FILE: master/dest_env.c
==================================================

void destruct_environment_of(object ob) {
  object env;
  env = environment(ob);
  if (env) {
      string *a;
      a = (string *)env->query_dest_dir();
      if (catch(ob->move_player(a[0], a[1], "stumbles"))) {
          ob->move_player("void", "/room/void", "is sucked into the");
      }
  }
}

==================================================
FILE: master/directory_assignments.c
==================================================

#include <player_handler.h>
#include <error_handler.h>
private mapping _directory_assignments = ([ ]);
int query_leader(string name);
string* query_assigned_to_directory(string dir) {
   string *bits;
   string str;
   int i;
   bits = explode(dir, "/") - ({ "" });
   switch (bits[0]) {
   case "w" :
      if (sizeof(bits) > 1 && file_size("/d/" + bits[1]) == -2) {
         return ({ bits[1] });
      }
   case "d" :
      if (sizeof(bits) > 1 && file_size("/d/" + bits[1]) == -2) {
         return ("/d/" + bits[1] + "/master")->query_assigned_to_directory(bits);
      }
   default :
      i = sizeof(bits) - 1;
      do {
         str = "/" + implode(bits[0..<i], "/");
         i--;
      } while (i >= 0 && !_directory_assignments[str]);
      if (_directory_assignments[str]) {
         return _directory_assignments[str];
      }
      return ({ });
   }
}
int assign_people_to_directory(string dir, string* people) {
   string* new_people;
   string* dirs;
   if ( !sizeof( filter( previous_object( -1 ), (: interactive( $1 ) :) ) ) ) {
      user_event( "inform", this_player()->query_name() +
            " illegally attempted to call assign_person_to_directory( "+ dir +
            ", " + query_multiple_short(people) +
            " )", "cheat" );
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
            ": illegal attempt to call assign_person_to_directory( "+ dir +
            ", " + query_multiple_short(people) +
            " ).\n"+ back_trace() :));
      return 0;
   }
   new_people = filter(people, (: PLAYER_HANDLER->test_creator( $1 ) ||
                                  $1 == ERROR_ASSIGNED_NO_ONE :));
   if ( sizeof(new_people) == sizeof(people) &&
        query_leader( previous_object(-1) ) &&
        file_size(dir) == -2) {
      dirs = explode(dir, "/") - ({ "" });
      if (sizeof(dirs) > 1 && dirs[0] == "d" &&
          file_size("/d/" + dirs[1]) == -2) {
         return ("/d/" + dirs[1] + "/master")->assign_people_to_directory(dir, people);
      } else {
         if (!_directory_assignments) {
            _directory_assignments = ([ ]);
         }
         if (sizeof(people) == 1 && people[0] == ERROR_ASSIGNED_NO_ONE) {
            people = ({ });
         }
         if (sizeof(people)) {
            if (sizeof(_directory_assignments[dir])) {
               ERROR_HANDLER->do_update_directory_assignment(_directory_assignments[dir][0], people[0], dir, (: 1 :));
            } else {
               ERROR_HANDLER->do_update_directory_assignment(ERROR_ASSIGNED_NO_ONE, people[0], dir, (: 1 :));
            }
            _directory_assignments[dir] = people;
         } else {
            map_delete(_directory_assignments, dir);
         }
         save_object("/secure/master");
      }
      return 1;
   }
   debug_printf("Bad pumpkins. %O %O\n", new_people, people);
   return 0;
}
mapping query_directory_assignments() {
   if (!_directory_assignments) {
      return ([ ]);
   }
   return copy(_directory_assignments);
}

==================================================
FILE: master/ed_stuff.c
==================================================

int save_ed_setup(object wiz, int setup) {
  wiz->set_ed_setup(setup);
  return 1;
}
int retrieve_ed_setup(object wiz) {
  return (int)wiz->query_ed_setup();
}
string make_path_absolute(string str) {
  if (this_player()) {
    return (string)this_player()->get_path(str);
  }
}
string get_save_file_name(string file, object who) {
  string *file_ar;
  if (!objectp(who))
    return 0;
  file_ar = explode(file,"/") - ({ "" });
  file = file_ar[<1];
  write("File saved in \"/w/.dead_ed_files/" +
        who->query_name() + "-" + file + "\"\n");
  return "/w/.dead_ed_files/" + who->query_name() + "-" + file;
}

==================================================
FILE: master/file_exists.c
==================================================

int file_exists( string path ) {
  if ( file_size( path ) < 0 )
    return 0;
  return 1;
}

==================================================
FILE: master/logging.c
==================================================

#include <type.h>
#include <runtime_config.h>
string get_wiz_name(mixed file) {
  if (!previous_object())
    return "root";
  if (objectp(file))
    file = file_name(file);
  file = explode(file, "/") - ({ "" });
  if (file[0] == "w") {
    if (file_size("/w/" + file[1]) != -2) {
      return "root";
    } else {
      return file[1];
    }
  }
  if (file[0] == "d") {
    return "dom";
  }
  return "root";
}
string get_dom_name(mixed file) {
  if (objectp(file))
    file = file_name(file);
  file = explode(file, "/") - ({ "" });
  if (file[0] == "d" && sizeof(file) >= 2)
    return file[1];
}
string get_prg_name(mixed file) {
  if (objectp(file))
    file = file_name(file);
  file = explode(file, "/") - ({ "" });
  if (file[0] == "w")
    return file[1];
  return "root";
}
int different(string fn, string pr) {
  sscanf(fn, "%s#%*d", fn);
  fn += ".c";
  return (fn != pr) && (fn != ("/" + pr));
}
string trace_line(object obj, string prog, string file, int line) {
  string ret;
  string objfn = obj ? file_name(obj) : "<none>";
  ret = objfn;
  if (different(objfn, prog))
    ret += sprintf(" (%s)", prog);
  if (file != prog)
    ret += sprintf(" in %s:%d\n", file, line);
  else
    ret += sprintf(" at line %d\n", line);
  return ret;
}
string printable_arg(mixed arg) {
  switch (typeof(arg)) {
  case ARRAY:
  case MAPPING:
  case CLASS:
  case STRING:
    if((strlen(typeof(arg)) + strlen(save_variable(arg)) + 4) <  __MAX_STRING_LENGTH__)
      return "(" + typeof(arg) + ") " + save_variable(arg);
    else
      return sprintf("(%s) <too large>", typeof(arg));
  default:
    return sprintf("(%s) %O", typeof(arg), arg);
  }
}
string trace_args(mixed *args) {
  string *tmp;
  if (!sizeof(args))
    return " (void)";
  tmp = map(args, (: printable_arg($1) :));
  return "\n(\n    "+implode(tmp, ",\n    ")+"\n)";
}
string trace_locals(mixed *args) {
  string *tmp;
  if (!sizeof(args))
    return " none.";
  tmp = map(args, (: printable_arg($1) :));
  return "\n    " + implode(tmp, ",\n    ");
}
varargs string standard_trace(mapping mp, int flag) {
  string ret;
  mapping *trace;
  int i, n;
  ret = mp["error"] + "Object: " +
    trace_line(mp["object"], mp["program"], mp["file"], mp["line"]);
  ret += "Arguments were:" + trace_args(mp["arguments"]) +
    "\nLocals were:" + trace_locals(mp["locals"]) + "\n";
  ret += "\n\n";
  trace = mp["trace"];
  n = sizeof(trace);
  for (i=0; i<n; i++) {
    ret += sprintf("(%d) '%s' in %s", i + 1, trace[i]["function"],
                   trace_line(trace[i]["object"], trace[i]["program"],
                              trace[i]["file"], trace[i]["line"]));
    if (!flag && (strlen(ret) + strlen(trace_args(trace[i]["arguments"])) +
                  strlen(trace_locals(trace[i]["locals"])) +
                  20) < __MAX_STRING_LENGTH__) {
      ret += "Arguments were:" + trace_args(trace[i]["arguments"]) +
        "\nLocals were:" + trace_locals(trace[i]["locals"]) + "\n";
    }
  }
  return ret;
}
#define MAX_SIZE 50000
void error_handler(mapping error, int caught) {
  string file, ret, path, name, obname;
  object ob;
  ret = "--------------------\n"+ctime(time()) + ":  " + standard_trace(error);
  if (caught) {
    file = "catch";
  } else {
    file = "runtime";
  }
  sscanf(error["error"], "%*sError in loading object '%s'", obname);
  if (!obname) {
    ob = error["object"];
    if (!ob) {
      obname = error["program"];
    } else {
      obname = file_name(ob);
    }
  }
  name = get_wiz_name(obname);
  switch (name) {
  case "root":
    path = "/log/" + file;
    break;
  case "dom":
    if (obname[0..17] == "/d/am/short/flats/") {
       path = "/d/am/short/flats/" + file;
    } else {
       switch (obname[0..9]) {
       case "/d/am/elm/" :
       case "/d/am/lame" :
          path = "/d/am/short/flats/" + file;
          break;
       default :
          break;
       }
    }
    path = "/d/"+get_dom_name(obname)+"/"+file;
    break;
  default:
    path = "/w/"+name+"/"+file;
    tell_creator(name, "A runtime error occured in the file %O"
                 ", logged to %s.\n", obname, path);
  }
  if (member_array("init_dynamic_arg", call_stack(2)) != -1 ||
      member_array("query_dynamic_auto_load", call_stack(2)) != -1) {
    path = "/d/admin/log/auto_" + file;
  }
  if (file_size(path) > MAX_SIZE) {
    unguarded((: rm, path+".old" :));
    unguarded((: rename, path, path+".old" :));
  }
  unguarded((: write_file, path, ret :));
  if (this_player(1) && find_object("/secure/simul_efun")) {
    this_player(1)->set_last_error(error);
    if (!caught) {
      if (this_player(1)->query_creator()) {
        tell_object(this_player(1), error["error"]+
                    "Object: "+trace_line(error["object"], error["program"],
                                          error["file"], error["line"])+
                    "\nTrace written to "+ path +"\n");
      } else {
        tell_object(this_player(1),
                    "A runtime error occurred.\nPlease use "
                    "the \"bug\" command to report it, "
                    "describing what you tried to do when it happened.\n");
      }
    }
  }
}
void log_error(string file, string message) {
  string name, efile, epath, colour;
  if (sscanf(message, "%*sWarning:%*s") == 2) {
    if(sscanf(message, "%*sTrying to put%*s") == 2) {
      efile = "type-error";
      colour = "%^RED%^";
    } else {
      efile = "warnings";
      colour = "%^CYAN%^";
    }
  } else {
    efile = "error-log";
    colour = "%^RED%^";
  }
  if (this_player(1) && this_player(1)->query_creator()) {
    tell_object(this_player(1), colour+message+"%^RESET%^");
  }
  name = get_wiz_name(file);
  switch (name) {
  case "root":
    epath = "/log/" + efile;
    break;
  case "dom":
    epath = "/d/"+get_dom_name(file)+"/"+efile;
    break;
  default:
    epath = "/w/"+name+"/"+efile;
    break;
  }
  if (file_size(epath) > MAX_SIZE) {
    unguarded((: rm, epath+".old" :));
    unguarded((: rename, epath, epath+".old" :));
  }
  unguarded((: write_file, epath, message :));
}
void do_log(string person, string text) {
  if (file_name(previous_object()) != "/std/smart_log")
    return;
  if (file_size("/w/"+person) != -2)
    return;
  unguarded((: rm, "/w/"+person+"/"+PLAYER_ERROR_LOG :));
  unguarded((: write_file, "/w/"+person+"/"+PLAYER_ERROR_LOG, text :));
}
void forward_error(string file, string text) {
  if (!((file_name(previous_object()) == "/secure/cmds/creator/errors") ||
        (file_name(previous_object()) == "/www/secure/errors")))
    return;
  unguarded((: write_file, file, text :));
}

==================================================
FILE: master/parse_command.c
==================================================

string *parse_command_id_list() {
  return ({ "one", "thing" });
}
string *parse_command_plural_id_list() {
  return ({ "ones", "things", "them" });
}
string *parse_command_adjectiv_id_list() {
  return ({ "the", "a", "an" });
}
string *parse_command_prepos_list() {
  return ({ "in", "on", "at", "along", "upon", "by", "under", "behind",
            "with",
            "beside", "into", "onto", "inside", "within", "from" });
}
string parse_command_all_word() {
  return "all";
}
string *query_word_list(string word) {
  switch (word) {
    case "preposition" :
      return parse_command_prepos_list();
    default :
      return 0;
  }
}

==================================================
FILE: master/permission.c
==================================================

int add_senior( string word ) {
   if ( !sizeof( filter( previous_object( -1 ), (: interactive( $1 ) :) ) ) ) {
      user_event( "inform", this_player()->query_name() +
            " illegally attempted to call add_senior( "+ word +
            " )", "cheat" );
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
            ": illegal attempt to call add_senior( "+ word +
            " ).\n"+ back_trace() :));
      return 0;
   }
   if ( PLAYER_HANDLER->test_user( word ) &&
        query_leader( previous_object(-1) ) ) {
      write_file( "/log/PROMOTIONS", ctime( time() ) +": "+ word +
            " was promoted to Senior by "+ geteuid( this_interactive() ) +
            "\n" );
      if ( ( positions[ word ] != TRUSTEE ) &&
            ( positions[ word ] != DIRECTOR ) )
         positions[ word ] = SENIOR;
      save_object( "/secure/master" );
      return 1;
   }
   return 0;
}
int remove_senior(string str) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    user_event( "inform", this_player()->query_cap_name()+
                " illegally attempted to call remove_senior("+str+")",
                "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call remove_senior("+str+").\nBacktrace: "+
                 back_trace() :));
    return 0;
  }
  if (query_leader(previous_object(-1)) &&
      positions[str] == SENIOR) {
    write_file("/log/DEMOTIONS", ctime(time())+": "+str+
               " was demoted from Senior by "+geteuid(this_interactive())+
               "\n");
    map_delete(positions, str);
    save_object("/secure/master");
    return 1;
  }
  return 0;
}
int add_director(string str) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    user_event( "inform", this_player()->query_cap_name()+
                " illegally attempted to call add_director("+str+")",
                "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+
               ": Illegal attempt to call add_director("+str+
               ").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (PLAYER_HANDLER->test_user(str) &&
      query_trustee(previous_object(-1))) {
    write_file("/log/PROMOTIONS", ctime(time())+": "+str+
               " was promoted to Leader by "+ geteuid(this_interactive())+
               "\n");
    if (positions[str] != TRUSTEE)
      positions[str] = DIRECTOR;
    save_object("/secure/master");
    return 1;
  }
  return 0;
}
int remove_director(string str) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    user_event( "inform", this_player()->query_cap_name()+
                " illegally attempted to call remove_director("+str+")",
                "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+
               ": Illegal attempt to call remove_director("+str+
               ").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (query_trustee(previous_object(-1)) &&
      positions[str] == DIRECTOR) {
    write_file("/log/DEMOTIONS", ctime(time())+": "+str+
               " was demoted from Leader by "+geteuid(this_interactive())+
               "\n");
    map_delete(positions, str);
    save_object("/secure/master");
    return 1;
  }
  return 0;
}
int add_trustee(string str) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    user_event( "inform", this_player()->query_cap_name()+
                " illegally attempted to call add_tristee("+str+")",
                "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call add_trustee("+str+").\nBacktrace: "+
                 back_trace() :));
    return 0;
  }
  if (PLAYER_HANDLER->test_user(str) &&
      query_trustee(previous_object(-1))) {
    write_file("/log/PROMOTIONS", ctime(time())+": "+str+
               " was promoted to Administrator by "+
               geteuid(this_interactive())+"\n");
    positions[str] = TRUSTEE;
    save_object("/secure/master");
    return 1;
  }
  return 0;
}
int remove_trustee(string str) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    user_event( "inform", this_player()->query_cap_name()+
                " illegally attempted to call remove_trustee("+str+")",
                "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call remove_trustee("+str+").\nBacktrace: "+
                 back_trace() :));
    return 0;
  }
  if (query_trustee(previous_object(-1)) &&
      positions[str] == TRUSTEE) {
    write_file("/log/DEMOTIONS", ctime(time())+": "+str+
               " was demoted from Administrator by "+
               geteuid(this_interactive())+"\n");
    map_delete(positions, str);
    save_object("/secure/master");
    return 1;
  }
  return 0;
}
varargs mixed creator_file(string path, int author);
nomask protected int check_domain(mixed ob, string func, string path, int mask) {
  object master_ob;
  string master, domain, *bits = explode(path, "/") - ({ "", "." });
  int ret;
  if (sizeof(bits) < 2)
    return (mask & READ_MASK);
  domain = bits[1];
  if (objectp(ob))
    ob = geteuid(ob);
  if (ob == creator_file(path))
    return 1;
  master = "/d/" + domain + "/master";
  if (!(master_ob = find_object(master)) && checked_master[master]) {
    return (mask & READ_MASK);
  }
  if (!master_ob && !checked_master[master] &&
      catch(master_ob = load_object(master))) {
    checked_master[master] = 1;
  }
  if (master_ob) {
    ret = master_ob->check_permission(ob, bits, mask);
    if (ret == -1) {
      return 0;
    }
    if ((sizeof(bits) > 2) && (bits[2] != "master.c") &&
        (bits[2] != "master.o") && (bits[2] != "master") && query_senior(ob)) {
      return 1;
    }
    return (ret || (mask & READ_MASK?master_ob->valid_read(bits, ob, func):
            master_ob->valid_write(bits, ob, func)));
  }
  return (mask & READ_MASK);
}
nomask protected int check_creator(mixed ob, string func, string path, int mask) {
  string master, creator, *bits = explode(path, "/") - ({ "", "." });
  object master_ob;
  if (sizeof(bits) < 2)
    return (mask & READ_MASK);
  creator = bits[1];
  if (objectp(ob))
    ob = geteuid(ob);
  if (mask & GRANT_MASK) {
    if (ob == creator) {
      return 1;
    } else {
      return 0;
    }
  }
  if ((mask & READ_MASK) && sizeof(bits) >= 3 && bits[2] == "mbox" &&
      file_size(sprintf("/w/%s/mbox", bits[1])) != -2)
    return ob == bits[1];
  if ((mask & READ_MASK) || (ob == creator_file(path)))
    return 1;
  master = "/w/" + creator + "/master";
  if (!(master_ob = find_object(master)) && checked_master[master])
    return 0;
  if (!master_ob && !checked_master[master] &&
      catch(master_ob = load_object(master)))
    checked_master[master] = 1;
  if (master_ob)
    return (master_ob->check_permission(ob, bits, mask) ||
            master_ob->valid_write(bits, ob, func));
  return 0;
}
private int check_permission(mixed ob, string func, string path,
                             mapping perms, int mask) {
  string tmp, euid;
  int i;
  mixed *stack;
  if (perms && sizeof(perms) && !undefinedp(perms["all"]) &&
      (perms["all"] & mask))
    return 1;
  if(path[0..21] == "/save/boards/lordboard" &&
     base_name(ob) != "/obj/handlers/board_handler") {
    catch(log_file("/d/admin/log/LORDBOARD",
                   "%s: ob %s player %s prev %s\n",
                   ctime(time())[4..18], base_name(ob),
                   this_player()->query_name(),
                   base_name(previous_object())));
  }
  if (unguarded_ob == ob) {
    if ((tmp = base_name(ob)) == "/global/player" ||
        tmp == "/global/playtester" ||
        tmp == "/global/creator" ||
        tmp == "/global/lord") {
      if((path == "/save/players/"+ob->query_name()[0..0]+"/"+ob->query_name())
         ||
         (path == "/save/players/"+ob->query_name()[0..0]+"/"+ob->query_name()+
          ".o") ||
         (path == "/save/players/"+ob->query_name()[0..0]+"/"+ob->query_name()+
          ".o.gz") ||
         (path == "/save/ramdisk/players/"+ob->query_name()[0..0]+"/"+ob->query_name()) ||
         (path == "/save/ramdisk/players/"+ob->query_name()[0..0]+"/"+ob->query_name()+
          ".o") ||
         (path == "/save/ramdisk/players/"+ob->query_name()[0..0]+"/"+ob->query_name()+
          ".o.gz"))
        return 1;
      else i = sizeof(stack = ({ ob }) + previous_object(-1));
    } else if (tmp == path)
      return 1;
    else
      i = sizeof(stack = ({ ob }));
  } else if (unguarded_ob && base_name(ob) == "/secure/simul_efun") {
    if (unguarded_ob == previous_object(1))
      i = sizeof(stack = ({ previous_object(1) }));
    else
      i = sizeof(stack = ({ ob }) + previous_object(-1));
  } else if (unguarded_ob) {
    stack = previous_object(-1);
    for (i = 0; i < sizeof(stack) && stack[i] != unguarded_ob; i++)
      ;
    i = sizeof(stack = ({ ob }) + stack[0..i]);
  } else
    i = sizeof(stack = ({ ob}) + previous_object(-1));
  while (i--) {
    if (!stack[i])
      return 0;
    if (stack[i] == this_object())
      continue;
    if (objectp(stack[i])) {
      if (file_name(stack[i]) == "/secure/simul_efun")
        continue;
      if (!(euid = geteuid(stack[i])))
        return 0;
    } else
      euid = stack[i];
    if (euid == get_root_uid())
      continue;
    if (query_director(euid) && (mask & READ_MASK))
      continue;
    if (query_trustee(euid))
      continue;
    if (perms) {
      if (!undefinedp(perms[euid]) && (perms[euid] & mask))
        continue;
      if (!undefinedp(perms["all"]) && (perms["all"] & LOCK_MASK))
        return 0;
    }
    if (path[0..2] == "/w/") {
      if (check_creator(stack[i], func, path, mask))
        continue;
    } else if(path[0..2] == "/d/") {
      if (check_domain(stack[i], func, path, mask))
        continue;
    } else {
      return (mask & READ_MASK);
    }
    return 0;
  }
  return 1;
}
mixed permission_match_path(mapping m, string path) {
  string p, *bits;
  int i, size;
  mapping found = ([]);
  if (!sizeof(m)) {
    return 0;
  }
  bits = explode(path, "/") - ({ "", "." });
  p = "";
  if (!undefinedp(m["/"])) {
    found += m["/"];
  }
  size = sizeof(bits);
  for (i = 0; i <= size; i++) {
    if (!undefinedp(m[p])) {
      mapping old = copy(found);
      if (sizeof((found += m[p])) != (sizeof(old) + sizeof(m[p]))) {
        string euid;
        int mask;
        found = old;
        foreach (euid, mask in m[p]) {
          if (!undefinedp(found[euid]))
            found[euid] |= mask;
          else
            found[euid] = mask;
        }
      }
    }
    if (i < size)
      p = p + "/" + bits[i];
  }
  if (sizeof(found)) {
    return found;
  } else {
    return 0;
  }
}
int valid_grant(object euid, string path, int mask) {
  string domain, master, director;
  int result;
  object master_ob;
  if (path[0] != '/')
    path = "/" + path;
  result = check_permission(euid, 0, path,
                            permission_match_path(permissions, path),
                            GRANT_MASK);
  if (!result || (mask & (READ_MASK|WRITE_MASK)))
    return result;
  if (sscanf(path, "/d/%s/%*s", domain) != 2 &&
      sscanf(path, "/d/%s", domain) != 1)
    return 0;
  master = "/d/" + domain + "/master";
  if (!(master_ob = find_object(master)) && checked_master[master])
    return 0;
  if (!master_ob && !checked_master[master] &&
      catch(master_ob = load_object(master))) {
    checked_master[master] = 1;
    return 0;
  }
  director = master->query_director();
  if(!director)
    director = master->query_lord();
  return (query_director(previous_object(-1) + ({ euid })) &&
          (member_array(director, map(previous_object(-1),
                                  (: geteuid($1) :))) != -1));
}
mapping query_permissions() {
  string *doms, master;
  int i;
  mapping blue, tmp;
  object master_ob;
  doms = get_dir("/d/");
  doms -= ({ "lost+found" });
  blue = ([ ]);
  for (i=0;i<sizeof(doms);i++) {
    master = "/d/"+doms[i]+"/master";
    if (!(master_ob = find_object(master)) && checked_master[master])
      continue;
    if (!master_ob && !checked_master[master] &&
        catch(master_ob = load_object(master))) {
      checked_master[master] = 1;
      continue;
    }
    tmp = (mapping)master_ob->query_access();
    if (mapp(tmp))
      blue += tmp;
  }
  return permissions + blue;
}
protected int add_permission(string euid, string path, int mask) {
  string *bits, master;
  object master_ob;
  if (path[0..2] == "/d/") {
    bits = explode(path, "/");
    if (sizeof(bits) >= 2) {
      master = "/d/"+bits[1]+"/master";
      if (!(master_ob = find_object(master)) && checked_master[master])
        return 0;
      if (!master_ob && !checked_master[master] &&
          catch(master_ob = load_object(master))) {
        checked_master[master] = 1;
        return notify_fail("Failed to load master file.\n");
      }
      if ((mask & LOCK_MASK) &&
          !sizeof(filter(previous_object(-1),
                      (: $(master_ob)->query_lord() == geteuid($1) :))))
        return notify_fail("You are not the leader of $C$" + bits[1] +
                           ".\n");
      return (int)master_ob->add_permission(euid, path, mask);
    }
  }
  if (!permissions[path]) {
    permissions[path] = ([ euid : mask ]);
  } else {
    permissions[path][euid] |= mask;
  }
  unguarded((: save_object, "/secure/master" :));
  return 1;
}
int add_read_permission(string euid, string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event( "inform", this_interactive()->query_cap_name()+
                " illegally attempted to call add_read_permission("+euid+", "+
                path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call add_read_permission("+euid+", "+path+").\nBacktrace: "+
               back_trace() :));
    return 0;
  }
  if (add_permission(euid, path, READ_MASK)) {
    write("Added read permision for "+euid+" to "+path+".\n");
    return 1;
  }
  return 0;
}
int add_write_permission(string euid, string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event( "inform", this_player(1)->query_cap_name()+
                " illegally attempted to call add_write_permission("+euid+", "+
                path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call add_write_permission("+euid+", "+path+").\n"
                 "Backtrace: "+ back_trace() :));
    return 0;
  }
  if (add_permission(euid, path, WRITE_MASK)) {
    write("Added write permision for "+euid+" to "+path+".\n");
    return 1;
  }
  return 0;
}
int add_grant_permission(string euid, string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event( "inform", this_player(1)->query_cap_name()+
                " illegally attempted to call add_grant_permission("+euid+", "+
                path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call add_grant_permission("+euid+", "+path+").\n"
                 "Backtrace: "+ back_trace() :));
    return 0;
  }
  if (add_permission(euid, path, GRANT_MASK)) {
    write("Added grant permision for "+euid+" to "+path+".\n");
    return 1;
  }
  return 0;
}
int lock_path(string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event("inform", this_player(1)->query_cap_name()+
               " illegally attempted to call lock_path("+path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call lock_path("+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (add_permission("all", path, LOCK_MASK)) {
    write("Restricted access for all to "+path+".\n");
    return 1;
  }
  return 0;
}
protected int remove_permission(string euid, string path, int mask) {
  string *bits, master;
  object master_ob;
  if (path[0..2] == "/d/") {
    bits = explode(path, "/");
    if (sizeof(bits) >= 2) {
      master = "/d/"+bits[1]+"/master";
      if (!(master_ob = find_object(master)) && checked_master[master])
        return 0;
      if (!master_ob && !checked_master[master] &&
          catch(master_ob = load_object(master))) {
        checked_master[master] = 1;
        return notify_fail("Failed to load master file.\n");
      }
      if ((mask & LOCK_MASK) &&
          !sizeof(filter(previous_object(-1),
                         (: $(master_ob)->query_lord() == geteuid($1) :))))
        return notify_fail("You are not the lord of $C$" + bits[1] + ".\n");
      return (int)master_ob->remove_permission(euid, path, mask);
    }
  }
  if (!permissions[path] || !permissions[path][euid]) {
    notify_fail("The euid \""+euid+"\" does not have any permissions to "
                "remove in "+path+".\n");
    return 0;
  }
  permissions[path][euid] &= ~mask;
  if (!permissions[path][euid]) {
    if (m_sizeof(permissions[path]) == 1) {
      map_delete(permissions, path);
    } else {
      map_delete(permissions[path], euid);
    }
  }
  unguarded((: save_object, "/secure/master" :));
  return 1;
}
int remove_read_permission(string euid, string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
      base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event( "inform", this_player(1)->query_cap_name()+
                " illegally attempted to call remove_read_permission("+euid+
                ", "+path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call remove_read_permission("+euid+", "+path+").\n"
               "Backtrace: "+ back_trace() :));
    return 0;
  }
  if (remove_permission(euid, path, READ_MASK)) {
    write("Removed read permision for "+euid+" to "+path+".\n");
    return 1;
  }
  return 0;
}
int remove_write_permission(string euid, string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event( "inform", this_player(1)->query_cap_name()+
                " illegally attempted to call remove_write_permission("+euid+
                ", "+path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call remove_write_permission("+euid+", "+path+").\n"
               "Backtrace: "+ back_trace() :));
    return 0;
  }
  if (remove_permission(euid, path, WRITE_MASK)) {
    write("Removed write permision for "+euid+" to "+path+".\n");
    return 1;
  }
  return 0;
}
int remove_grant_permission(string euid, string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event( "inform", this_player(1)->query_cap_name()+
                " illegally attempted to call remove_grant_permission("+euid+
                ", "+path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call remove_grant_permission("+euid+", "+path+").\n"
               "Backtrace: "+ back_trace() :));
    return 0;
  }
  if (remove_permission(euid, path, GRANT_MASK)) {
    write("Removed grant permision for "+euid+" to "+path+".\n");
    return 1;
  }
  return 0;
}
int unlock_path(string path) {
  if ( base_name(previous_object()) != "/d/admin/room/access_control" &&
       base_name(previous_object()) != "/cmds/creator/perm_it") {
    user_event("inform", this_player(1)->query_cap_name()+
               " illegally attempted to call unlock_path("+path+")", "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call unlock_path("+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (remove_permission("all", path, LOCK_MASK)) {
    write("Removed access restrictions for all to "+path+".\n");
    return 1;
  }
  return 0;
}

==================================================
FILE: master/preload.c
==================================================

protected string *load_file(string fname) {
  string *bits;
  string str;
  str = read_file("/secure/config/"+fname);
  if (!str)
    return ({ });
  bits = explode(str, "\n");
  bits = filter(bits, (: $1[0] != '#' :));
  return bits;
}
string *epilog() {
  return load_file("preload");
}
void preload(string file) {
  mixed e;
  printf("Preloading: "+file+".\n");
  if ((e = catch(load_object(file)))) {
    printf("            "+e+"\n");
  }
}

==================================================
FILE: master/query_pl_level.c
==================================================

int query_player_level( string what ) {
   if ( !this_player() )
      return 0;
   switch ( what ) {
      case "error messages" :
         return 1;
      case "trace" :
      case "wizard" :
         return (int)this_player()->query_creator();
   }
}

==================================================
FILE: master/simul_efun.c
==================================================

string get_simul_efun() {
  string fname;
  fname = "/secure/simul_efun";
  if (catch(call_other(fname, "??"))) {
    write("Failed to load " + fname + "\n");
    shutdown();
    return 0;
  }
  return fname;
}

==================================================
FILE: master/snoop.c
==================================================

int valid_snoop(object snooper, object snoopee, object pobj) {
  string verb;
  verb = this_player()->query_current_verb();
  if (snooper == snoopee) {
    tell_object(snooper, "You can't snoop yourself.\n");
    return 0;
  }
  if (snoopee && query_snoop(snoopee)) {
    tell_object(snooper,
                snoopee->query_cap_name()+" is already being snooped.\n");
    return 0;
  }
  if (snooper->query_snoopee()) {
    user_event( snooper->query_cap_name()+" stops " + verb + "ing "+
                snooper->query_snoopee()->query_name(), "snoop");
    if (!snooper->query_property("quiet snoop")) {
      tell_object((object)snooper->query_snoopee(),
                  snooper->query_cap_name()+" stops snooping you.\n");
    } else {
      snooper->remove_property("quiet snoop");
    }
    snooper->set_snoopee(0);
  }
  if (!snoopee) {
    return 1;
  }
  if (!snooper->query_creator())
    return 0;
  if (pobj == this_object()) {
    user_event( snooper->query_cap_name()+" starts qsnooping "+
                snoopee->query_name(), "snoop");
    return 1;
  }
  if (verb == "qsnoop" && query_lord(geteuid(snooper)) &&
      !query_lord(geteuid(snoopee))) {
    tell_object(snooper, "You are quiet snooping "+
                snoopee->query_cap_name()+"\n");
    snooper->add_property("quiet snoop", 1);
  } else {
    tell_object(snoopee, "You are being snooped by "+
                snooper->query_cap_name()+".\n");
  }
  unguarded( (: write_file("/d/admin/log/SNOOP", ctime(time()) + " " +
           (string)$(snooper)->query_cap_name() + " " +
           $(verb) + "s " + (string)$(snoopee)->query_cap_name() + ".\n") :) );
  snooper->set_snoopee(snoopee);
  if (verb == "qsnoop") {
    tell_object(snooper, "Please share with us the reason why you are " +
                "quiet snooping?\n: ");
    input_to("snoop_reason");
    snoop_list[snooper] = snoopee;
    return 0;
  }
  user_event( snooper->query_cap_name()+" starts " + verb + "ing "+
              snoopee->query_name(), "snoop");
  return 1;
}
void snoop_reason(string str) {
  object snooper;
  snooper = this_player();
  if (this_player(1) != this_player()) {
    write("Can't force people...\n");
    return ;
  }
  if (!high_programmer(geteuid(this_player()))) {
    write("Not a high programmer.\n");
    return ;
  }
  if (!snoop_list[snooper]) {
    write("The snoopee has just logged out.\n");
    return ;
  }
  if(!str) {
    write("Snoop canceled.\n");
    unguarded( (: write_file("/d/admin/log/SNOOP", "  Chickened out.\n") :) );
    return;
  }
  unguarded( (: write_file("/d/admin/log/SNOOP", "  Reason: " + $(str) +
                           "\n") :) );
  if (snoop(snooper, snoop_list[snooper]))
    write("Snoop suceeded,\n");
  else
    write("Snoop failed.\n");
}

==================================================
FILE: master/valid_binary.c
==================================================

int valid_save_binary(string fname) {
  string *bits;
  bits = explode(fname, "/");
  switch (bits[0]) {
    case "global" :
    case "std" :
    case "secure" :
    case "cmds" :
    case "d" :
    case "www" :
      return 1;
    case "obj" :
        return 1;
  }
  return 0;
}

==================================================
FILE: master/valid_bind.c
==================================================

private nosave object _simul_efun;
int valid_bind(object binder, object old_owner, object new_owner) {
   string *womble;
   string fname;
   if(!objectp(_simul_efun)) {
     _simul_efun = find_object("/secure/simul_efun");
   }
   if(binder == _simul_efun) {
      return 1;
   }
   if(file_name(new_owner)[0..7] == "/secure/") {
      return 0;
   }
   if(interactive(new_owner)) {
      return 0;
   }
   womble = explode(file_name(old_owner), "/");
   if (sizeof(womble) < 1) {
      return 0;
   }
   fname = womble[<1];
   if (fname[0] != '.') {
      return 0;
   }
   return old_owner == binder;
}

==================================================
FILE: master/valid_copy.c
==================================================

int valid_copy(string path, mixed euid, string func) {
  object master_ob;
  string *bits = explode(path, "/") - ({ "", "." });
  mapping perms;
  perms = permission_match_path(permissions, path);
  if(sizeof(bits) < 2 || bits[0] == "open" || bits[0] == "doc" ||
     bits[0] == "log" || bits[0] == "mudlib" || bits[0] == "w")
    return check_permission(euid, func, path, perms, READ_MASK);
  master_ob = find_object("/d/" + bits[1] + "/master");
  if((master_ob && master_ob->copy_with_read(path, euid, func)) ||
     (!master_ob && master()->query_senior(euid)))
    return check_permission(euid, func, path, perms, READ_MASK);
  else
    return check_permission(euid, func, path, perms, WRITE_MASK);
}

==================================================
FILE: master/valid_database.c
==================================================

mixed valid_database(object ob, string action, mixed *info){
  string obname = base_name(ob);
  switch (obname){
  case "/obj/handlers/clusters":
  case "/obj/handlers/map":
  case "/cmds/creator/osql":
  case "/cmds/errors_base":
    return -1;
  default:
    return 0;
  }
}

==================================================
FILE: master/valid_exec.c
==================================================

int valid_exec(string name) {
  if (name == "secure/login.c")
    return 1;
  if(name == "secure/nlogin.c")
    return 1;
  return 0;
}

==================================================
FILE: master/valid_hide.c
==================================================

int valid_hide(object ob) {
  return query_lord(geteuid(ob));
}

==================================================
FILE: master/valid_ident.c
==================================================

int valid_ident(string euid) {
  return high_programmer(euid);
}

==================================================
FILE: master/valid_link.c
==================================================

int valid_link(string from, string to) {
  return 0;
}

==================================================
FILE: master/valid_override.c
==================================================

int valid_override(string file, string func, string filename) {
  string *bing;
  bing = explode(file, "/") - ({ "", "." });
  switch (bing[0]) {
    case "secure" :
      return 1;
    case "std" :
    case "obj" :
    case "simul_efun" :
    case "global" :
    case "cmds" :
      return (func != "snoop");
    default :
      return 0;
  }
}

==================================================
FILE: master/valid_read.c
==================================================

#define FILE_STATS 1
private nosave mapping read_stats;
int valid_read(string path, mixed euid, string func) {
  mapping perms;
  string prev;
  if (euid == master())
    return 1;
  if ((func == "file_size") || (func == "stat"))
    return 1;
  if (path[0] != '/')
    path = "/" + path;
  if (path[<1] == 'c' && base_name(euid)[0..2] == "/w/")
    return 0;
#ifdef FILE_STATS
  if(!read_stats)
    read_stats = ([ ]);
  if(previous_object()) {
    prev = base_name(previous_object());
    if(!read_stats[prev])
      read_stats[prev] = ([ path : 1 ]);
    else
      read_stats[prev][path] += 1;
  }
#endif
  perms = (mapping)permission_match_path(permissions, path);
  return check_permission(euid, func, path, perms, READ_MASK);
}
mapping query_read_stats() { return copy(read_stats); }

==================================================
FILE: master/valid_seteuid.c
==================================================

int valid_euid(string str) {
  string *domains;
  switch (str) {
  case "all":
  case "Handlers":
  case "Mailer":
  case "Network":
  case "Room":
  case "Spell":
  case "WWW":
    return 1;
  default:
    domains = unguarded((: get_dir, "/d/" :));
    domains -= ({ "lost+found" });
    domains = map(domains, (: capitalize($1) :));
    if (member_array(str, domains) != -1) {
      return 1;
    }
    return 0;
  }
}
int valid_seteuid(object ob, string euid) {
  string crea;
  if (euid == "tmp") {
      return 1;
  }
   if ( !objectp( ob ) )
      return 0;
  crea = creator_file(file_name(ob));
  if (crea == "Root" || crea == "Room") {
      return 1;
  }
  return (euid == crea) || !euid;
}

==================================================
FILE: master/valid_shadow.c
==================================================

int valid_shadow(object ob) {
  if (previous_object() == ob)
    return 0;
  return (!ob->query_prevent_shadow(previous_object()) &&
          !sscanf(file_name(ob), "/secure/%*s") &&
          !sscanf(file_name(ob), "/obj/handlers/%*s") &&
          !function_exists("heart_beat" , previous_object(), 1) &&
          !sscanf(file_name(ob), "/cmds/%*s"));
}

==================================================
FILE: master/valid_socket.c
==================================================

int valid_socket(object ob, string func, mixed *info) {
  string fname;
  fname = file_name(ob);
  if (func != "external") {
    switch (explode(fname, "/")[0]) {
      case "net" :
      case "secure" :
        return 1;
    }
  } else {
    if (fname[0..11] == "/secure/cmds" ||
        fname[0..19] == "/secure/rcs_handler")
      return 1;
  }
  return 0;
}

==================================================
FILE: master/valid_to_c.c
==================================================

int valid_compile_to_c() {
  if (previous_object() == this_object())
    return 1;
  if (previous_object() != find_object("/secure/cmds/creator/compile"))
    return 0;
  if (!interactive(previous_object(1)))
    return 0;
  if (!this_object()->query_lord(previous_object(-1)))
    return 0;
  return 1;
}

==================================================
FILE: master/valid_write.c
==================================================

#define WRITE_FILE_STATS 1
private nosave mapping write_stats;
int valid_write(string path, mixed euid, string func) {
  mapping perms;
  string tmp;
  string *bits, rcspath;
  string prev;
  if (path && (path[<2..] == ",v")) {
    return 0;
  }
  if (func == "remove_file" && path[0..13] == "/save/players/") {
     if (objectp(euid)) {
        log_file("/d/admin/log/DELETE_PLAYER", "Deleting " +
                path + " by " + file_name(previous_object()) +
                "->" + call_stack(2)[0] + "\n");
     } else {
        log_file("/d/admin/log/DELETE_PLAYER", "Deleting " +
                path + " by " + euid + " (" + file_name(previous_object()) +
                "->" + call_stack(2)[0] + ")\n");
     }
  }
  if (euid == master())
    return 1;
  if (path[0] != '/')
    path = "/" + path;
#ifdef WRITE_FILE_STATS
  if(!write_stats)
    write_stats = ([ ]);
  if(previous_object()) {
    prev = base_name(previous_object());
    if(!write_stats[prev])
      write_stats[prev] = ([ path : 1 ]);
    else
      write_stats[prev][path] += 1;
  }
#endif
  bits = explode(path, "/");
  if(euid &&
     (file_size(path) > 0) &&
     (!previous_object() ||
        file_name(previous_object()) != "/secure/cmds/creator/rcso_ut") &&
     (!objectp(euid) || file_name(euid) != "/secure/ftpd") &&
     path[<2..] != ".o" &&
     (bits[0] != "log" && bits[0] != "save" && bits[0] != "players") ) {
    if(sizeof(bits) > 2) {
      rcspath = "/" + implode(bits[0..sizeof(bits)-2], "/") + "/RCS/";
    } else if(sizeof(bits) == 2) {
      rcspath = "/" + bits[0] + "/RCS/";
    } else
      rcspath = "/";
    rcspath += bits[sizeof(bits)-1] + ",v";
    if(file_size(rcspath) > 0) {
#ifdef DEBUG
      if(stringp(euid))
        tell_object(find_player("ceres"), sprintf("Checking perms: %s [%s](string)\n", rcspath, euid ));
      else if(objectp(euid))
        tell_object(find_player("ceres"), sprintf("Checking perms: %s [%s](object)\n", rcspath, file_name(euid )));
      else
        tell_object(find_player("ceres"), sprintf("Checking perms: %s [%O](unknown)\n", rcspath, euid ));
#endif
      tmp = read_file(rcspath, 4, 1);
      if(tmp == "locks\n") {
        string lockname ;
        tmp = read_file(rcspath, 5, 1);
        sscanf(tmp, "\t%s:", lockname);
        if((objectp(euid) && euid->query_name() != lockname) ||
           (stringp(euid) && euid != lockname)) {
          int i, ok;
          object *stack;
          stack = previous_object(-1);
          i = sizeof(stack);
          while(--i) {
            if(geteuid(stack[i]) == lockname) {
              ok = 1;
            }
          }
          if(!ok) {
#ifdef DEBUG
          if(objectp(euid))
            tell_object(find_player("ceres"), sprintf("Write denied to %O or %O Locked by %s\n", euid, previous_object(-1), lockname));
          else
            tell_object(find_player("ceres"), sprintf("Write denied to %s or %O Locked by %s\n", euid, previous_object(-1), lockname));
#endif
          return 0;
          } else {
#ifdef DEBUG
            tell_object(find_player("ceres"), "Write allowed to "+geteuid(stack[i])+" Locked by:"+lockname +" on file "+path+"\n");
#endif
          }
        } else {
#ifdef DEBUG
          if(objectp(euid))
            tell_object(find_player("ceres"), sprintf("Write allowed by %O Locked by %s\n", euid, lockname));
          else
            tell_object(find_player("ceres"), sprintf("Write allowed by %s Locked by %s\n", euid, lockname));
#endif
        }
      } else {
#ifdef DEBUG
          tell_object(find_player("ceres"), "No locks found\n");
#endif
          return 0;
      }
    }
  }
  perms = permission_match_path(permissions, path);
  return check_permission(euid, func, path, perms, WRITE_MASK);
}
mapping query_write_stats() { return copy(write_stats); }
void reset() {
  write_stats = ([ ]);
  read_stats = ([ ]);
}

==================================================
FILE: master/virtual_objects.c
==================================================

#include "/include/virtual.h"
object compile_object(string path) {
   string* bits;
   if (file_size(path) > 0) {
      return (object)SERVER->create_virtual_object(path);
   }
   bits = explode(path, ":");
   if (sizeof(bits) > 1) {
      if (file_size(bits[0]) > 0 ||
          file_size(bits[0] + ".c") > 0) {
         return bits[0]->create_virtual_object(bits[1..] ...);
      }
   }
}
