
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/eat_corpse.c ===
#include <effect.h>
#include "path.h"
void beginning( object player, string dest, int id ) {
}
int merge_effect( object player, int time1, int time2, int id ) {
   return time1;
}
string query_classification() { return "npc.eat.corpse"; }
string query_shadow_ob() { return SHADOWS + "eat_corpse"; }
int query_indefinate() { return 1; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/eat_edible.c ===
#include <effect.h>
#include <route.h>
#include <wander.h>
#include "path.h"
void beginning( object player, string dest, int id ) {
}
int merge_effect( object player, int time1, int time2, int id ) {
   return time1;
}
string query_classification() { return "npc.eat.edible"; }
string query_shadow_ob() { return SHADOWS + "eat_edible"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/given.c ===
#include <effect.h>
#include "path.h"
string query_classification() { return "npc.given"; }
string query_shadow_ob() { return SHADOWS + "given"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/savage_corpse.c ===
#include <effect.h>
#include <route.h>
#include <wander.h>
#include "path.h"
void beginning( object player, string dest, int id ) {
}
int merge_effect( object player, int time1, int time2, int id ) {
   return time1;
}
string query_classification() { return "npc.eat.savage"; }
string query_shadow_ob() { return SHADOWS + "savage_corpse"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/vampirebite_effect.c ===
#include <effect.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>
mapping compass = ([ "north" : 1, "northeast" : 1, "east" : 1, "southeast" : 1,
                     "south" : 1, "southwest" : 1, "west" : 1, "northwest" : 1
                    ]);
void come_around( object person );
string query_classification() { return "body.bite.vampire"; }
string query_shadow_ob() { return "/std/shadows/npc/vampirebite_shadow"; }
int survive_death() { return 1; }
int beginning( object person, int extent, int id ) {
   int con, time;
   tell_object( person, "Pain shoots through your veins, exploding inside "
      "your head, making you scream in agony as the effect of the vampire's "
      "bite fills your body.\n" );
   person->add_extra_look( this_object() );
   person->adjust_bonus_int(-2);
   person->adjust_bonus_wis(-2);
   person->adjust_bonus_str(-2);
   person->adjust_bonus_dex(-2);
   person->submit_ee( "bite_pain", ({ 10, 60 }), EE_CONTINUOUS );
   con = person->query_con();
   if( con < 1 ) con = 1;
   time = 2 * extent / con;
   person->submit_ee( 0, time, EE_REMOVE );
   return time;
}
int merge_effect( object person, int old_time, int new_extent, int id ) {
   int con, new_time;
   con = person->query_con();
   if( con < 1 ) con = 1;
   new_time = ( 2 * new_extent / con ) + person->expected_tt();
   person->submit_ee( 0, new_time, EE_REMOVE );
   return new_time;
}
void restart( object person, int time, int id ) {
   person->adjust_bonus_int(-2);
   person->adjust_bonus_wis(-2);
   person->adjust_bonus_str(-2);
   person->adjust_bonus_dex(-2);
}
void end( object person, int time, int id ) {
   if( person->query_property( PASSED_OUT_PROP ) )
      come_around( person );
   person->adjust_bonus_int(2);
   person->adjust_bonus_wis(2);
   person->adjust_bonus_str(2);
   person->adjust_bonus_dex(2);
   tell_object( person, "The firey pain screaming through your veins and "
      "incessant pounding inside your head finally wear off, leaving you "
      "with a mild headache.\n" );
}
void bite_pain( object person, int time, int id ) {
   int timeleft, selector;
   timeleft = (int)person->expected_tt();
   if( person->query_property( PASSED_OUT_PROP ) ) {
      switch( random(3) ) {
      case 0 :
         tell_room( environment(person), person->one_short() + " shakes "
            "slightly in silent agony.\n", person );
         break;
      case 1 :
         tell_room( environment(person), person->one_short() + " moans, "
            "writhing on the ground.\n", person );
         break;
      case 2 :
         tell_room( environment(person), person->one_short() + " opens " +
            person->query_possessive() + " eyes, stares around wildly as if "
            "in a fever, and passes out again with a groan.\n", person );
         break;
      }
      return;
   }
   selector = random( timeleft ) / person->query_con() / 5;
   switch( selector ) {
   case 0 :
      break;
   case 1 :
   case 2 :
      switch( random(4) ) {
      case 0 :
         person->new_parser( "gasp in pain" );
         break;
      case 1 :
         person->new_parser( "moan agonisingly" );
         break;
      case 2 :
         person->new_parser( "stumble" );
         break;
      default :
         person->new_parser( "dloh head in pain" );
         break;
      }
      break;
   case 3 :
   case 4 :
   case 5 :
      switch( random(4) ) {
      case 0 :
         tell_object( person, "You clutch your head and groan in agony as "
            "the effect of the vampires bite burns through you.\n" );
         tell_room( environment( person ), person->the_short() +
            " clutches " + person->query_possessive() + " head and groans "
            "in agony.\n", person );
         break;
      case 1 :
         tell_object( person, "You stagger about, your vision blurring and "
            "fading for a moment while your head throbs with pain.\n" );
         tell_room( environment( person ), person->the_short() +
            " staggers about, " + person->query_possessive() + " eyes "
            "drifting in and out of focus.\n", person );
         break;
      case 2 :
         tell_object( person, "You feel yourself go lightheaded and the "
            "pain fades for just a moment, before slamming back into you "
            "like a hammer to the forehead.\n" );
         tell_room( environment( person ), person->the_short() + " pales "
            "as the blood drains from " + person->query_possessive() +
            " face, then clenches " + person->query_possessive() + " teeth "
            "and groans with pain.\n", person );
         break;
      default :
         tell_object( person, "The fire flooding through your veins causes "
            "you to scream in agony, your body racked with pain.\n" );
         tell_room( environment( person ), person->the_short() + " leans "
            + person->query_possessive() + " head back and screams in "
            "pain.\n", person );
         break;
      }
      break;
   default :
      if( timeleft > 100 ) {
         switch( random(2) ) {
         case 0 :
            tell_object( person, "The world goes black.  You have "+
                "passed out.\n" );
            tell_room( environment( person ), "The blood drains from " +
                person->the_short() + "'s face, and " +
                person->query_pronoun() + " collapses heavily to the "
                "ground.\n", person );
            person->add_property( PASSED_OUT_PROP, 1 );
            person->submit_ee( "come_around", ({ 50, 80 }), EE_ONCE );
            break;
         case 1 :
            person->submit_ee( "wander_about", 3, EE_ONCE );
            break;
         }
      }
   }
}
void come_around( object person ) {
   tell_object( person, "You feel a pounding headache coming on and realise "
      "you are finally conscious.\n" );
   tell_room( environment( person ), person->the_short() + " groans "
      "painfully, opens " + person->query_possessive() + " eyes and slowly "
      "picks " + person->query_objective() + "self up.\n", person );
   person->remove_property( PASSED_OUT_PROP );
}
void wander_about( object person, int time, int id ) {
   int i, flag;
   string *direcs;
   if( person->query_property( PASSED_OUT_PROP ) || !environment( person ) )
      return;
   if( random( 4 ) )
      person->submit_ee( "wander_about", ({ 8, 8 }), EE_ONCE );
   direcs = (string *)environment( person )->query_direc();
   while( sizeof( direcs ) && !flag ) {
      i = random( sizeof( direcs ) );
      if(
          !environment( person )->query_door_open( direcs[ i ] ) ) {
         direcs = delete( direcs, i, 1 );
         continue;
      }
      person->add_property( UNKNOWN_MOVE, 1 );
      if( compass[direcs[i]] )
         flag = person->exit_command( 0, ({ direcs[ i ], "$N attempt$s to "
            "walk in one direction and instead stumble$s off towards the "
            "$T." }) );
      else
         flag = person->exit_command( 0, ({ direcs[ i ], "$N stumble$s off "
            "towards the $T." }) );
      tell_object( person, "You attempt to get up and walk and just "
         "manage to stumble around a bit.\n" );
      person->remove_property( UNKNOWN_MOVE );
      if( !flag )
         direcs = delete( direcs, i, 1 );
   }
}
string extra_look( object player, mixed *args ) {
    return capitalize(player->query_pronoun()+" looks rather pale with cold,"
    " clammy skin and a look of dizziness.\n");
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/i_died.c ===
#include <effect.h>
#include "path.h"
string query_classification() { return "npc.death.me"; }
string query_shadow_ob() { return SHADOWS + "i_died"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/dont_move.c ===
#include <effect.h>
#include <route.h>
#include <wander.h>
#include "path.h"
void beginning( object player, int arg, int id ) {
   player->submit_ee(0, arg, EE_REMOVE);
}
int merge_effect( object player, int time1, int time2, int id ) {
   player->submit_ee( 0, time1 + time2 - player->expected_tt(),
          EE_REMOVE );
   return time1 + time2;
}
string query_classification() { return "npc.move.no"; }
string query_shadow_ob() { return SHADOWS + "dont_move"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/path.h ===
#define PATH "/std/effects/npc/"
#define SHADOWS "/std/shadows/npc/"

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/no_follow.c ===
#include <effect.h>
#include <route.h>
#include <wander.h>
#include "path.h"
void beginning( object player, string dest, int id ) {
   player->do_command("lose everyone");
}
int merge_effect( object player, int time1, int time2, int id ) {
   return time1;
}
string query_classification() { return "npc.follow.no"; }
string query_shadow_ob() { return SHADOWS + "no_follow"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/controlled_monster.c ===
#include "path.h"
string query_shadow_ob() { return SHADOWS + "controlled_monster"; }
void beginning( object player, string dest, int id ) {
}
int merge_effect( object player, int time1, int time2, int id ) {
   return time2;
}
string query_classification() { return "npc.controlled_monster"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/wizards_protection.c ===
#include <effect.h>
#define SHADOWS "/std/shadows/npc/"
#define SHADOW_OB  "uu_staff_protection"
string query_classification(){return "npc.protection.wizards"; }
void beginning(object player, mixed arg){
   player->submit_ee( 0, -1, EE_REMOVE );
}
string query_shadow_ob() {
   return (SHADOWS SHADOW_OB);
}
mixed merge_effect(object player, mixed old_arg, mixed new_arg){
   return new_arg;
}
int query_indefinite() { return 1; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/vampirecorpse_effect.c ===
#include <effect.h>
string query_classification() { return "corpse.transformation.vampire"; }
void beginning( object corpse, mixed *args ) {
   corpse->add_extra_look( this_object() );
   corpse->submit_ee( "corpse_action", 10, EE_CONTINUOUS );
}
mixed *merge_effect( object corpse, mixed *old_args, mixed *new_args ) {
   return new_args;
}
void end( object corpse, mixed *args ) {
   object ob, vampire;
   tell_room( environment(corpse), "The corpse's eyes snap open, and a "
      "vicious grin spreads across its face.  It rises upwards without "
      "bothering to push away from the ground, standing upright, its eyes "
      "flashing.  You notice that the fangs of the corpse look considerably "
      "longer than they used to.\n" );
   vampire = clone_object( "/d/ram/chars/Uberwald/corpse_vampire" );
   vampire->setup_vampire( args[0], args[1] );
   vampire->move( environment( corpse ), vampire->the_short() + " glances "
      "down at " + vampire->query_objective() + "self and grimaces.  " +
      capitalize( vampire->query_pronoun() ) + " waves one arm and is "
      "instantly clothed in more fitting garments.\n"  );
   vampire->do_command( "grin viciously" );
   corpse->clear_armours();
   foreach( ob in all_inventory( corpse ) ) {
      ob->move( environment( corpse ) );
   }
   corpse->remove_extra_look( this_object() );
   corpse->move( "/room/rubbish" );
}
void corpse_action( object corpse, mixed *args ) {
   int rate;
   object *stuff;
   stuff = all_inventory (corpse);
   rate = (int) (corpse->query_decay());
  if( sizeof( stuff ) ) {
    tell_room( environment(corpse), corpse->one_short() + " twitches "
         "slightly.\n" );
    if (rate < 20) {
      tell_room( environment(corpse), corpse->one_short() + " seems to "
         "arch its back, and a faint gasp comes from its mouth.\n" );
      corpse->submit_ee( 0, 1, EE_REMOVE );
     }
    return;
   }
   switch( args[3] ) {
   case 0 :
      tell_room( environment(corpse), corpse->one_short() + " twitches "
         "slightly.\n" );
      break;
   case 1 :
      tell_room( environment(corpse), corpse->one_short() + " jerks "
         "violently, its limbs quivering.\n" );
      break;
   case 2 :
      tell_room( environment(corpse), corpse->one_short() + " seems to "
         "arch its back, and a faint gasp comes from its mouth.\n" );
      corpse->submit_ee( 0, 1, EE_REMOVE );
      break;
  }
   args[3]++;
}
string extra_look( object corpse, mixed *args ) {
   return "It seems to be twitching slightly, almost as if it's still "
      "alive.  You probably shouldn't get too close.\n";
}
int query_theft_command() { return -1; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/goto_destination.c ===
#include <effect.h>
#include "path.h"
#define LOG_FILE "EFFECTS"
private string standardize(mixed dest);
void call_move_to(object player, string dest)
{
  if (!player) {
#ifdef DEBUG
    log_file(LOG_FILE,
             sprintf("%O %s: player became 0 before call_move_to() called\n",
                     this_object(), ctime(time())));
#endif
    return;
  }
  if(!dest) {
#ifdef DEBUG
    log_file(LOG_FILE,
             sprintf("%O %s: dest became 0 before call_move_to() called\n",
                     this_object(), ctime(time())));
#endif
    return;
  }
  player->move_me_to(dest);
}
void remove_effect(object player, int id)
{
  if (player)
    player->remove_effect(id);
}
void beginning( object player, mixed arg, int id ) {
   mixed dest;
   if (pointerp(arg)) {
      if (sizeof(arg) > 3) {
         arg = arg[0..2];
      } else while (sizeof(arg) < 3) {
         arg += ({ 20 });
      }
   } else {
      arg = ({ arg, 0, 20 });
   }
   arg[0] = standardize(arg[0]);
   if (!dest) {
      while (!arg[0] && sizeof(arg) > 3) {
         arg = arg[3..];
         arg[0] = standardize(arg[0]);
      }
      if (!arg[0]) {
         call_out("remove_effect", 2, player, id);
         return ;
      }
   }
   if (objectp(arg[0])) {
      call_out("call_move_to", 2, player, file_name(environment(arg[0])));
   } else {
      call_out("call_move_to", 2, player, arg[0]);
   }
}
private string standardize(mixed dest) {
   if (objectp(dest)) {
      if (!living(dest)) {
         dest = file_name(dest);
      }
   } else if (stringp(dest)) {
      if (catch(dest->rabbit_well())) {
         dest = 0;
      } else {
         dest = file_name(find_object(dest));
      }
   }
   return dest;
}
mixed merge_effect( object player, mixed arg1, mixed arg2, int id ) {
   if (!pointerp(arg1)) {
      arg1 = ({ arg1, 0, 20 });
   }
   if (sizeof(arg1) > 0) {
      while (sizeof(arg1) < 3) {
         arg1 += ({ 20 });
      }
      arg1[0] = standardize(arg1[0]);
   }
   if (!pointerp(arg2)) {
      arg2 = ({ arg2, 0, 20 });
   }
   if (sizeof(arg2) > 0) {
      while (sizeof(arg2) < 3) {
         arg2 += ({ 20 });
      }
      arg2[0] = standardize(arg2[0]);
   }
   arg1 += arg2;
   while (!arg1[0] && sizeof(arg1) > 3) {
      arg1 = arg1[3..];
      arg1[0] = standardize(arg1[0]);
   }
   if (!arg1[0]) {
      call_out("remove_effect", 2, player, id);
      return ({ });
   }
   return arg1;
}
void effect_womble(object player, mixed *arr) {
  if(!player)
    return;
   player->add_effect(file_name(this_object()), arr);
}
void do_the_sell(object player) {
   object *obs;
   int i;
   obs = all_inventory(player);
   for (i = 0; i < sizeof(obs); i++) {
      if (!obs[i]->query_property("start equipment")) {
         call_out((: $1->do_command("sell "+file_name($2)) :),
                   1, player, obs[i]);
      }
   }
}
void end( object player, mixed room, int id ) {
   int ok;
   if (pointerp(room)) {
      if (sizeof(room) > 3) {
         call_out( "effect_womble", room[2], player, room[3..]);
      }
      if (!room[0]) {
         ok = 0;
      } else if (objectp(room[0])) {
         ok = (environment(room[0]) == environment(player));
      } else {
         ok = file_name(environment(player)) == room[0];
      }
      if (functionp(room[1])) {
         evaluate(room[1], player, room[0], ok, room[1]);
      }
      if (stringp(room[1])) {
         if (ok) {
            switch (room[1]) {
               case "sell" :
                  do_the_sell(player);
                  break;
               default :
                  player->do_command(room[1]);
                  break;
            }
         }
      }
      if (pointerp(room[1])) {
         call_other(room[1][0], room[1][1], player, room[0], ok, room[1]);
      }
   }
}
string query_classification() { return "npc.move"; }
string query_shadow_ob() { return SHADOWS + "goto_destination"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/mock_block.c ===
#include "path.h"
string *beginning( object player, string *skills ) {
  return skills;
}
string *merge_effect( object player, string *old, string *arg ) {
  arg = filter( arg, (: member_array( $1, $2 ) == -1 :), old );
  return old + arg;
}
string query_classification() { return "mock.block.npc"; }
string query_shadow_ob() { return SHADOWS "mock_block"; }
int query_indefinite() { return 1; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/light_change.c ===
#include <effect.h>
#include "path.h"
string query_classification() { return "npc.light_change"; }
string query_shadow_ob() { return SHADOWS + "light_change"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/unsocial_effect.c ===
#include <effect.h>
void beginning( object player,mixed *arg, int id ) {
   tell_object( player, "The spectral image of a "+arg[0]+" appears in front "
         "of you and looks sadly at you through pale eyes.  You shudder "
         "in horror as the image passes through you with tears in its "
         "eyes.  You find your yourself less able to communicate from the "
         "shock.\n");
   tell_room( environment( player ), player->the_short()+" suddenly looks "
         "straight ahead and shudders for no visible reason.\n", player );
   player->submit_ee( "reminder_mess", 20, EE_CONTINUOUS );
   player->submit_ee( 0, arg[1], EE_REMOVE );
   player->set_max_sp( 0 );
}
int merge_effect( object player, int time1, int time2, int id ) {
   player->submit_ee( 0, time1 + time2 - (int)player->expected_tt(),
         EE_REMOVE );
   return time1 + time2;
}
void end( object player, int time, int id ) {
   int number;
   tell_object( player, "You feel you have recovered and are ready to "
         "communicate with the world again.\n");
   number= player->query_real_max_sp();
   player->adjust_max_sp( number );
}
void reminder_mess( object player, mixed *arg, int id ) {
   string message;
   if (!random(4))
       switch(random(2)){
         case 0 :
           message = "The spectral image of a "+arg[0]+" just like you had "
            "as a "
            "child appears in front of you.  Before you know what you are "
            "doing you strike out at the "+arg[0]+" spilling spectral blood "
            "everywhere.\n";
           break;
         default :
           message = "You have a vision of yourself walking down a street "
            "when suddenly a masked "+arg[0]+" jumps out of the shadows "+
            "and cuts you into pieces with its natural weapons.\n";
           break;
       }
   else message = "The pitiful looking ghost of a "+arg[0]+
         " suffering from horrifying wounds drifts past you.\n";
   tell_object( player, message);
   tell_room( environment( player ),player->the_short()+" shudders and "
         "looks worried.\n", player );
   player->run_away();
   if (sizeof(player->effects_matching("priest.paralysis"))){
     tell_object(player,"You look around in panicked confusion, unsure "
                 "of exactly where you are.\n");
     tell_room( environment( player ),player->the_short()+ " stares dazedly "
                "at their surroundings.\n",player);
     tell_object(player,((environment(player)->query_long() )+"\n"));
  }
}
string query_classification() { return "curse.magic.social"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/basilisk_stare.c ===
#include <effect.h>
#include "path.h"
void do_damage(object to, int amount, object from, int id)
{
  if (!to) return;
  if (to->query_hp() <= amount)
    to->delete_effect(to->sid_to_enum(id));
  to->attack_by(this_object());
  to->adjust_hp(-amount, from);
}
void stop_fighting(object who, mixed arg, int id)
{
  int *fights, i;
  fights = who->effects_matching("fighting");
  if (sizeof(fights))
    for (i = sizeof(fights) - 1; i >= 0; i--)
      who->delete_effect(fights[i]);
}
void doit(object them, int arg, int id)
{
  int dam;
  object basilisk;
  arg--;
  them->set_arg_of(them->sid_to_enum(id), arg);
  if (!arg) {
    them->delete_effect(them->sid_to_enum(id));
    return;
  }
  if (sizeof(match_objects_for_existence("basilisk", environment(them))) == 0) {
    tell_object(them, "You suddenly notice that the basilisk is no "
                "longer here.\n");
    them->delete_effect(them->sid_to_enum(id));
    return;
  }
  tell_object(them,
         ({
      "You cannot stand the deadly stare.\n",
      "Your soul is being drilled through and out the other side.\n",
      "Your eyeballs are being ripped apart.\n",
      "Your brain is being flayed.\n"
      })[random(4)]);
  tell_room(environment(them),
       ({
         them->one_short()+" cannot bear the deadly gaze.\n",
         them->one_short()+"'s soul is being torn apart.\n",
         them->one_short()+"'s brain is afire.\n",
         them->one_short()+"'s eyeballs are being drilled through.\n"
         })[random(4)], them);
  basilisk = find_living("basilisk");
  if (basilisk) {
    dam = random(50)+50;
    call_out("do_damage", 1, them, dam, basilisk, id);
  }
}
int beginning(object them, int arg, int id)
{
  tell_object(them, "You feel a pair of mental diamond drills penetrating "
         "your brain.\n");
  tell_room(environment(them), them->one_short() +
            "'s soul is about to be ripped apart.\n", them) ;
  them->submit_ee("stop_fighting", 1, EE_ONCE);
  them->submit_ee("doit", 10, EE_CONTINUOUS);
  them->add_property("passed out", 1);
  return arg;
}
void end(object them)
{
  tell_object(them, "You are freed from the basilisk's deadly stare.\n");
  them->remove_property("passed out");
}
string query_shadow_ob() {
  return SHADOWS+"basilisk_stare";
}
void merge_effect(object them, int arg1, int arg2, int id)
{
  them->set_arg_of(them->sid_to_enum(id), arg1 + arg2);
}
string query_classification() { return "magic.offensive.paralysis.stare"; }
string query_name()
{
  return "a horrible sight";
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/enter.c ===
#include <effect.h>
#include "path.h"
string query_classification() { return "npc.enter"; }
string query_shadow_ob() { return SHADOWS + "enter"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/scavenge.c ===
#include <effect.h>
#include "path.h"
string query_classification() { return "npc.given"; }
string query_shadow_ob() { return SHADOWS + "given"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/good_fighter.c ===
#include "path.h"
#include <effect.h>
#define CLASS "npc.fighter"
string query_classification() { return CLASS; }
int query_indefinite() { return 1; }
string query_shadow_ob() { return SHADOWS "good_fighter"; }
void gfs(object player)
{
  player->good_fighter_setup();
}
int *beginning(object player, int *arg)
{
  if (!arg || !arrayp(arg) || sizeof(arg) != 2)
    arg = ({ 0, 0 });
  player->submit_ee("gfs", 1, EE_ONCE);
  return arg;
}
void restart(object player, int *arg)
{
  beginning(player, arg);
}
int *merge_effect(object player, int *oldarg, int *newarg)
{
  return oldarg;
}
void end(object player, int *arg)
{
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/they_died.c ===
#include <effect.h>
#include "path.h"
string query_classification() { return "npc.death.them"; }
string query_shadow_ob() { return SHADOWS + "they_died"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/gossip.c ===
#include <effect.h>
#include "path.h"
string query_classification() { return "npc.gossip"; }
string query_shadow_ob() { return SHADOWS + "gossip"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/exit.c ===
#include <effect.h>
#include "path.h"
string query_classification() { return "npc.exit"; }
string query_shadow_ob() { return SHADOWS + "exit"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/npc/pub_brawl.c ===
#include <effect.h>
#include "path.h"
string query_classification() { return "npc.pub_brawl"; }
string query_shadow_ob() { return SHADOWS + "pub_brawl"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/fighting/bob.c ===
#include "path.h"
#include <effect.h>
#include <player.h>
void beginning( object player, object *things, int id ) {
   tell_object( player, "You prepare to bob "+
         (string)things[ 0 ]->the_short() +".\n" );
   player->set_data( ({ "unarmed", "blunt", "hands" }) );
   player->submit_ee( 0, 10 * COMBAT_SPEED, EE_REMOVE );
}
void end( object player, object *things, int id ) {
   if ( sizeof( things ) )
      tell_object( player, "You missed your opportunity!\n" );
}
void restart( object player, object *things, int id ) {
   player->submit_ee( 0, 0, EE_REMOVE );
}
string query_classification() { return "fighting.combat.special.punch"; }
string query_shadow_ob() { return SHADOWS +"bob"; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/attached/stat_adjustment.c ===
#include "path.h"
#include <effect.h>
class stat_class {
   mapping current_adjustments;
   object* obs;
   mapping* adjs;
   object me;
}
private string* _stats;
void create() {
   _stats = ({ "str", "dex", "wis", "int", "con" });
}
string query_classification() { return "mudlib.clothing.stat"; }
void update_adjustments(object player, class stat_class arg) {
   mapping stats;
   mapping bing;
   string stat;
   int i;
   int num;
   if (sizeof(arg) == 4 && arg->me != player) {
      arg->me = player;
      arg->current_adjustments = ([ ]);
   }
if (player == find_player("presto"))  printf("UPDATE: %O\n", arg);
if (player == find_player("presto"))  printf("UPDATE: %O\n", arg->obs);
   for (i = 0; i < sizeof(arg->obs); i++) {
if (player == find_player("presto"))  {
printf("%O, %d\n", arg->obs, i);
printf( "UPDATE: checkpoint 2: %O\n", arg->obs[i]);
}
      if (!arg->obs[i]) {
         arg->obs = arg->obs[0.. i -1] + arg->obs[i+1..];
         arg->adjs = arg->adjs[0.. i -1] + arg->adjs[i+1..];
      }
   }
if (player == find_player("presto"))
tell_creator("presto", "checkpoint 3\n");
   stats = ([ ]);
   foreach (stat in _stats) {
      num = 0;
      for (i = 0; i < sizeof(arg->adjs); i++) {
         bing = arg->adjs[i];
         if (bing[stat] > 0) {
            if (i > 0) {
               num += bing[stat] / (i + 1);
            } else {
               num += bing[stat];
            }
         } else if (bing[stat] < 0) {
            if (i > 1) {
               num += bing[stat] * i;
            } else {
               num += bing[stat];
            }
         } else if (i > 0) {
            num -= i;
         }
      }
      stats[stat] = num;
   }
if (player == find_player("presto"))
tell_creator("presto", "UPDATE: checkpoint 1\n");
   foreach (stat in _stats) {
      if (stats[stat] != arg->current_adjustments[stat]) {
         call_other(player,
                    "adjust_bonus_" + stat,
                    stats[stat] - arg->current_adjustments[stat]);
         arg->current_adjustments[stat] = stats[stat];
      }
   }
}
class stat_class beginning(object player, mixed arg, int id) {
   class stat_class bing;
   bing = new(class stat_class);
   bing->current_adjustments = ([ ]);
   bing->obs = ({ arg[0] });
   bing->adjs = ({ arg[1] });
   bing->me = player;
if (player == find_player("presto"))  printf("BEFORE: %O\n", bing);
   update_adjustments(player, bing);
if (player == find_player("presto"))
tell_creator("presto", "BEGINNING: bing == %O, player == %s\n", bing, player->short());
   return bing;
}
int query_indefinite() { return 1; }
class stat_class merge_effect( object player, class stat_class old_arg, mixed new_arg ) {
   int i;
   if (pointerp(old_arg)) {
      player->submit_ee(0, 0, EE_REMOVE);
      return old_arg;
   }
   i = member_array(new_arg[0], old_arg->obs);
   if (i != -1) {
      old_arg->adjs[i] = new_arg[1];
   } else {
      old_arg->obs += ({ new_arg[0] });
      old_arg->adjs += ({ new_arg[1] });
   }
   update_adjustments(player, old_arg);
   return old_arg;
}
void restart( object player, class stat_class edible ) {
   update_adjustments(player, edible);
}
void quiting( object player, class stat_class womble ) {
   womble->obs = ({ });
   womble->adjs = ({ });
   update_adjustments(player, womble);
}
void end( object player, class stat_class bing ) {
   bing->obs = ({ });
   bing->adjs = ({ });
   update_adjustments(player, bing);
}
void remove_stat_adjustment_ob(object player, object ob) {
   class stat_class fluff;
   int *ids;
   int i;
   ids = player->effects_matching(query_classification());
   if (sizeof(ids)) {
      fluff = player->arg_of(ids[0]);
      for (i = 0; i < sizeof(fluff->obs); i++) {
         if (fluff->obs[i] == ob) {
            fluff->adjs = fluff->adjs[0..i-1] + fluff->adjs[i+1..];
            fluff->obs = fluff->obs[0..i-1] + fluff->obs[i+1..];
         }
      }
      if (!sizeof(fluff->obs)) {
         player->delete_effect(ids[0]);
      } else {
         update_adjustments(player, fluff);
         player->set_arg_of(ids[0], fluff);
      }
   }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/attached/single_shoulder.c ===
#include "path.h"
#include <effect.h>
string query_classification() { return "mudlib.clothing.single-shoulder"; }
int query_indefinite() { return 1; }
string query_shadow_ob() { return SHADOWS +"single_shoulder"; }
int merge_effect( object, int old_arg, int new_arg ) {
   if (objectp(new_arg)) {
      new_arg = 0;
   }
   if (objectp(old_arg)) {
      old_arg = 0;
   }
   return old_arg + new_arg;
}
void restart( object player, int handicap ) {
   player->adjust_bonus_dex( -handicap );
}
void end( object player, int handicap ) {
   if (intp(handicap)) {
      player->adjust_bonus_dex( handicap );
   }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/attached/owned_transport.c ===
#include <player.h>
inherit "/std/basic/virtual_quit_control";
class riding {
   object* transport;
   string* environments;
   mixed save_stuff;
}
private nosave int _transport_id;
void create() {
   _transport_id = random(3000) + 1;
}
string query_classification() {
   return "mudlib.riding.owned";
}
int query_indefinite() {
   return 1;
}
class riding beginning(object player, object transport, int id) {
   class riding bing;
   bing = new(class riding);
   bing->transport = ({ transport });
   bing->save_stuff = 0;
   transport->set_transport_id(_transport_id++);
   return bing;
}
class riding merge_effect(object player, class riding fluff, object transport) {
   if ( member_array(transport, fluff->transport) == -1) {
      if (!transport->query_transport_id()) {
         while(sizeof(filter(fluff->transport,
                             (: $1 && $1->query_transport_id() == $2 :),
                             _transport_id))) {
            _transport_id++;
         }
         transport->set_transport_id(_transport_id++);
      } else if (sizeof(filter(fluff->transport,
                        (: $1 && $1->query_transport_id() == $2 :),
                        transport->query_transport_id()))) {
         transport->dest_me();
         return fluff;
      }
      fluff->transport += ({ transport });
   }
   return fluff;
}
void end(object player, class riding arg) {
}
void restart(object player, class riding bing) {
   int i;
   object* blue;
   object* green;
   blue = filter(bing->transport, (: $1 :));
   if (!sizeof(blue) &&
       bing->save_stuff) {
      green = AUTO_LOAD_OB->load_auto_load_to_array(bing->save_stuff,
                                         player);
      for (i = 0; i < sizeof(bing->transport); i++) {
         if (green) {
            bing->transport[i] = green[i];
            green->move(bing->environments[i],
                        "$N appears with a puff of fluff.");
         }
      }
   }
}
void clear_thingy(class riding bing) {
   bing->save_stuff = 0;
}
void saving(object player, class riding bing) {
   string *env;
   bing->transport -= ({ 0 });
   env = map(bing->transport,
             (: find_start_pos($1, environment($1)) :));
   bing->environments = map(bing->transport,
                            (: find_start_pos($1, environment($1)) :));
   bing->save_stuff = AUTO_LOAD_OB->create_auto_load( bing->transport );
   call_out( (: clear_thingy :), 2, bing);
}
void quiting(object player, class riding bing) {
   call_out((: $1->move("/room/rubbish", 0,
                        "$N vanishes in a puff of fluff.") :),
            2, bing->transport);
}
void remove_owner(object player, class riding bing, int id, object trans) {
   bing->transport -= ({ trans });
   if (!sizeof(bing->transport)) {
      player->delete_effect(id);
   }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/attached/path.h ===
#define PATH "/std/effects/attached/"
#define SHADOWS "/std/shadows/attached/"
#define HUMAN "/std/races/human"

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/attached/talker_response.c ===
#include <effect.h>
#define CLASS "object.talker.response"
#define SHADOW "/std/shadows/attached/"
string query_classification() { return CLASS; }
int query_indefinite() { return 1; }
string query_shadow_ob() { return SHADOW + "talker_response"; }
mixed beginning( object item, mixed arg, int id )
{
}
mixed restart( object player, mixed arg, int id )
{
  return beginning(player, arg, id);
}
mixed merge_effect(object player, mixed oldarg, mixed newarg, int id)
{
	return oldarg;
}
void end( object player, mixed arg, int id )
{}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/attached/riding.c ===
class riding {
   object transport;
   mixed saved_info;
}
string extra_look(object player) {
   return player->query_pronoun() + " is riding on " +
          environment(player)->the_short();
}
string query_classification() {
   return "mudlib.riding.transport";
}
int query_indefinate() {
   return 1;
}
class riding beginning(object player, mixed arg, int id) {
   class riding bing;
   bing = new(class riding);
   return bing;
}
class riding end(object player, class riding arg) {
}
void restart(object player, class riding bing) {
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/attached/living_light.c ===
#include "path.h"
#include <effect.h>
#define COST_PER_ROUND 30
#define INTENSITY 25
string query_classification() { return "magic.body.light"; }
int beginning( object player ) {
   tell_object( player, "A soft glow spreads out from your middle to "+
         "envelop you.\n" );
   tell_room( environment( player ), "A soft glow spreads out from "+
         (string)player->the_short() +"'s middle to envelop "+
         (string)player->query_objective() +".\n", player );
   player->adjust_light( INTENSITY );
   player->add_extra_look( this_object() );
   player->submit_ee( "decrease_points", 1, EE_ONCE );
   player->submit_ee( "decrease_points", ({ 30, 60 }), EE_CONTINUOUS );
   return INTENSITY;
}
void restart( object player, int light ) {
   player->adjust_light( light );
   player->add_extra_look( this_object() );
}
int merge_effect( object player, int light ) {
   int times;
   times = sizeof( filter_array( (object *)player->query_armours(),
         "test_for_effect", this_object() ) );
   if ( light >= ( INTENSITY * times ) )
      return light;
   tell_object( player, "The light surrounding you intensifies.\n" );
   tell_room( environment( player ), "The light around "+
         (string)player->short() +" grows brighter.\n", player );
   player->adjust_light( INTENSITY );
   return light + INTENSITY;
}
void end( object player, int light ) {
   tell_object( player, "The light surrounding you flickers and winks "+
         "out.\n" );
   tell_room( environment( player ), "The light around "+
         (string)player->short() +" flickers and winks out.\n", player );
   player->adjust_light( -light );
   player->remove_extra_look( this_object() );
}
int test_for_effect( object thing ) {
   if( !thing || !thing->query_wear_effects() )
     return 0;
   return member_array( file_name( this_object() ),
         (string *)thing->query_wear_effects() ) != -1;
}
void decrease_points( object player, int light, int id ) {
   int times;
   if ( player->query_auto_loading() )
      return;
   times = sizeof( filter_array( (object *)player->query_armours(),
         "test_for_effect", this_object() ) );
   if ( !times ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return;
   }
   if ( (int)player->query_gp() < times * COST_PER_ROUND ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return;
   }
   player->clear_gp_info();
   player->adjust_gp( - times * COST_PER_ROUND );
   if ( light != ( times * INTENSITY ) ) {
      tell_object( player, "The light surrounding you flickers and "+
            "stabilises, only a little dimmer than before.\n" );
      tell_room( environment( player ), "The light around "+
         (string)player->short() +" flickers and stabilises, only a "+
         "little dimmer than before.\n", player );
      player->adjust_light( times * INTENSITY - light );
      light = times * INTENSITY;
      player->set_arg_of( (int)player->sid_to_enum( id ), light );
   }
}
string extra_look( object player ) {
   return capitalize( (string)player->query_pronoun() ) +" is surrounded by "+
         "a soft yellow glow.\n";
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/other/path.h ===
#define PATH "/std/effects/other/"
#define SHADOWS "/std/shadows/other/"

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/effects/other/wetness.c ===
#include "path.h"
#include <effect.h>
#include <weather.h>
#define MAX_EFFECT 200
#define MAX_DURATION 120
#define MAX_STRENGTH 240
#define MIN_STRENGTH 20
string query_classification() { return "body.wetness"; }
int beginning( object player, int wetness, int id ) {
  int dryness;
  tell_object( player, "Squelch.\n" );
  player->submit_ee( "squelch", ({ 20, 20 }), EE_CONTINUOUS );
  player->add_extra_look( this_object() );
  if(dryness = (int)player->check_dryness())
    wetness -= dryness;
  if ( wetness > (int)player->query_weight() )
    wetness = (int)player->query_weight();
  return wetness;
}
void restart( object player ) {
  player->add_extra_look( this_object() );
}
int merge_effect( object player, int new_wetness, int old_wetness, int id ) {
  int wetness, dryness;
  wetness = new_wetness + old_wetness;
  if(dryness = (int)player->check_dryness())
    wetness -= dryness;
  if ( wetness > (int)player->query_weight() )
      wetness = (int)player->query_weight();
  if ( wetness <= 0 )
    player->submit_ee(0, 0, EE_REMOVE );
  return wetness;
}
void end( object player, int strength, int id ) {
  tell_object(player, "You feel dry now.\n");
  player->remove_extra_look( this_object() );
}
void squelch(object player, int wetness, int id) {
  string loc;
  object env;
  int bingle;
  env = environment(player);
  if(!env)
    return;
  loc = (string)env->query_property("location");
  if(loc == "outside" && (int)WEATHER->query_temperature(env) > 0) {
    bingle = (int)WEATHER->query_temperature(env) / 2 +
      env->query_property("warmth");
  } else if(loc == "inside")
    bingle = (20 / 2) + env->query_property( "warmth" );
  if(player->query_personal_temp() / 3 > bingle)
    bingle -= (player->query_personal_temp() / 3);
  if(!env->query_water() && bingle > 0)
    wetness -= bingle;
  if(player->query_property("dead"))
    wetness = 0;
  if(wetness <= 0)
    player->submit_ee(0, 0, EE_REMOVE );
  if (wetness > 10 && !random(3) && !env->query_water() ) {
    tell_object(player, "Squelch.\n" );
  }
  player->set_arg_of(player->sid_to_enum(id), wetness);
}
string wet_string( object player, int self ) {
  int wetness;
  int *enums;
  enums = (int *)player->effects_matching( "body.wetness" );
  if ( !sizeof( enums ) )
    return "";
  wetness = (int)player->arg_of(enums[0]);
  if (!intp(wetness)) {
     wetness = 0;
     player->submit_ee(0, 0, EE_REMOVE );
  }
  switch ( ( wetness * 100 ) / ( 1 +
      (int)player->query_weight() ) ) {
    case 0 .. 5 :
      if (self)
        return "look slightly wet";
      else
        return "looks slightly wet";
    case 6 .. 10 :
      if (self)
        return "look rather wet";
      else
        return "looks rather wet";
    case 11 .. 30 :
      if (self)
        return "look wet and bedraggled";
      else
        return "looks wet and bedraggled";
    case 31 .. 80 :
      if (self)
        return "are soaked and don't look that well at all";
      else
        return "is soaked and doesn't look that well at all";
    case 81 .. 100 :
      if (self)
        return "look like you have just been dunked in a lake";
      else
        return "looks like "+ player->query_pronoun() +
          " has just been dunked in a lake";
      break;
    default :
      return "";
  }
}
string extra_look(object player)  {
   return capitalize(player->query_pronoun()) + " " + wet_string(player, 0) +
             ".\n";
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/environ/snowball.c ===
#include <tasks.h>
inherit "std/object";
int strength;
void set_strength( int number );
void setup() {
   set_name( "snowball" );
   add_alias( "ball" );
   add_adjective( "snow" );
   set_strength( 99 );
   set_heart_beat( 1 );
}
int query_strength() { return strength; }
void set_strength( int number ) { strength = number; }
string long( string word, int dark ) {
   return "This is a "+ ({
      "very small lump of slush",
      "small and rather soggy lump of snow",
      "small snowball",
      "smallish snowball",
      "vaguely small snowball",
      "decent sized snowball",
      "reasonably sized snowball",
      "snowball for throwing at someone",
      "good snowball for throwing at someone",
      "nice, big snowball, just right for throwing at someone"
   })[ strength / 10 ] +".\n";
}
void init() {
    add_command( "throw", "<direct:object> {at|to} <indirect:object>" );
}
void heart_beat() {
   strength--;
   if ( strength < 1 ) {
      set_heart_beat( 0 );
      move( "/room/rubbish" );
   }
}
private object find_person(object ob) {
   if (living(ob)) {
      return ob;
   } else {
      while (ob && !living(ob)) {
         ob = environment(ob);
      }
      if (ob) {
         return ob;
      }
   }
   return 0;
}
int do_throw( object *obs ) {
   object per;
   int chance;
   per = find_person(obs[0]);
   if (per) {
      if (per != obs[0]) {
         chance = 0;
      } else {
         chance = 30;
      }
      if (per == this_player()) {
         per->add_effect( "/std/effects/external/snowball", strength );
      } else {
         switch (TASKER->compare_skills(this_player(),
                                        "fighting.combat.range.thrown",
                                        per,
                                        "fighting.combat.dodging.range",
                                        chance,
                                        TM_FREE,
                                        TM_FREE)) {
         case OFFAWARD :
            tell_object(this_player(), "%^YELLOW%^You feel more able to throw "
                                       "snowballs at people.\n%^YELLOW%^");
         case OFFWIN :
            per->add_effect( "/std/effects/external/snowball", strength );
            add_succeeded_mess( ({ "$N throw$s $D at $I and hit$s!\n",
                "$N throw$s $D at $I and hits!\n" }),  ({ obs[0] }) );
            break;
         case DEFAWARD :
            tell_object(this_player(), "%^YELLOW%^You feel more able to dodge "
                                       "snowball thrown by people.\n%^YELLOW%^");
         case DEFWIN :
            add_succeeded_mess( "$N throw$s $D at $I and miss$es!\n",
                                   ({ obs[0] }) );
            break;
         }
      }
   } else {
      add_succeeded_mess( "$N throw$s $D at $I.\n", ({ obs[ 0 ] }) );
   }
   move( "/room/rubbish" );
   return 1;
}
mapping query_dynamic_auto_load() {
   return ([
      "::" : ::query_dynamic_auto_load(),
      "strength" : strength
   ]);
}
void init_dynamic_arg( mapping map, object ) {
   ::init_dynamic_arg( map[ "::" ] );
   strength = map[ "strength" ];
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/environ/snowman.c ===
#include <move_failures.h>
inherit "/std/object";
private int _call_out_handle;
void setup() {
    reset_get();
    if ( clonep() ) {
        _call_out_handle = call_out("die",400);
    }
}
void set_type(string type) {
    set_name(type);
    set_short(type);
    set_long("A wonderful " + type + " with glowing eyes made of coal and twigs "
      "for ears.\n");
    add_extra_look( this_object() );
}
string extra_look( object ob ) {
    int time_left;
    if ( !_call_out_handle ) {
        return "";
    }
    time_left = find_call_out( _call_out_handle );
    debug_printf( "time left is %d\n", time_left );
    if ( time_left > 300 || time_left < 0 ) {
        return "";
    }
    return "It is " + ({ "mostly", "half", "slightly" })[time_left/100] +
        " melted.\n";
}
void die() {
    string noun;
    switch( environment( this_object() )->query_property( "location" ) ) {
    case "inside":
        noun = "floor";
        break;
    case "outside":
        noun = "ground";
        break;
    case "underwater":
        noun = "seabed";
        break;
    default:
        noun = "floor";
        break;
    }
    tell_room( environment( this_object() ),
      the_short() + " $V$0=melts,melt$V$ into the " + noun + ".\n");
    if ( this_object()->move( "/room/rubbish" ) != MOVE_OK ) {
        dest_me();
    }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/environ/weather_room.c ===
inherit "std/room";
mixed leverarr;
reset (arg) {
  if (arg) return;
  set_short("The weather room");
  set_long("The weather control center for the entire mud. On the floor should\n"+
           "be the controller itself, scattered around the room are hundred of impresive\n"+
           "flashing lights, dials and levers. You get the feeling however that they dont\n"+
           "actually do anything.\n");
  set_light(1);
  seteuid("pinkfish");
  add_property("inside");
  add_exit("pinkfish","d/Fish/pinkfish/workroom");
  add_item("lights","What did I say? there are lots of them and they are insesantly\n"+
           "flashing.\n");
  add_item("dials","Large dials with all sort of things on them. One you can see says\n"+
           "'Colour of spring', it is currently pointing at purple.\n");
  add_item("levers",
           "The levers are large multicolour protuberances which are scattered around the\n"+
           "room in random profusion.\n");
  leverarr = ({ ({ "blue",
       "The rooms spins and a small bit of printed paper falls from the\n"+
       "Weather controller saying:\n#query_rain" }),
                ({ "white",
       "The ground heaves in a major convulsion and a mound of paper falls onto\n"+
       "You from the ceiling saying:\n#query_cloud" }) });
}
init() {
  ::init();
  add_action("pull","pull");
  add_action("push","push");
}
pull(str) {
  int i;
  string type,rand;
  object lever, weather;
  if (str == "lever" || str == "levers")
    lever = leverarr[random(sizeof(leverarr))];
  else {
    if (!sscanf(str,"%s lever%s",type,rand)) {
      notify_fail("You have to pull a lever.\n");
      return 0;
    }
    for (i=0;i<sizeof(leverarr);i++) {
      if (leverarr[i][0] == type) {
        lever = leverarr[i];
        break;
      }
    }
  }
  if (!lever) {
    notify_fail("You need to choose and existing lever");
    return ;
  }
  weather = present("weather",this_object());
  if (!weather) {
    notify_fail("Opps the weather controller does not exist.\n");
    return 0;
  }
  sscanf(lever[1],"%s#%s",type,rand);
  write(type);
  this_player()->print_object(call_other(weather,rand));
  return 1;
}
push(str) {
  object lever;
  int i;
  string type,bing;
  if (str == "levers" && str == "lever")
    lever = leverarr[random(sizeof(leverarr))];
  else {
    if (!sscanf(str,"%s lever%s",type,bing)) {
      notify_fail("You must push an existing lever.\n");
      return 0;
    }
    for (i=0;i<sizeof(leverarr);i++)
      if (type == leverarr[i][0]) {
        lever = leverarr[i];
        break;
      }
  }
  if (!lever) {
    notify_fail("An existing lever could be usefull...\n");
    return 0;
  }
  write("You huff and you puff, but you just cant push that lever.\n");
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/environ/snowball.h ===
#define SNOW_THING "The snow ball thing"
#define SNOW_EXTRA "/std/environ/snowball_look"

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/environ/weather.c ===
#include <config.h>
inherit "std/object";
#include "climate.h"
#define FILE_NAME "/save/environ/weather"
#define HOME "/obj/handlers/weather_room"
#define MAX_DIST 100
#define YEAR 60
#define DAY 60
#define SPEED 40
mixed *coldarr,
      *cloudarr,
      *rainarr;
int timeofyear,
    mooncycle,
    moonoff,
    timeofday,
    intensity;
int distance(mixed *co_ord1,mixed *co_ord);
int cloud_index(object env);
int rain_index(object env);
int temperature_index(object env);
string cloud_string(object env);
string rain_string(object env);
string temperature_string(object env);
void setup() {
  set_name("weather");
  set_short("weather controller extrodinare");
  set_long("The weather controller, at least this one is always right!\n");
  cloudarr = ({ ({ 0,0 }), ({ 50,50 }), ({ -50,-50 }) });
  rainarr = ({ ({ 0,0 }), ({ 50,50 }), ({ -50,-50 }) });
  coldarr = ({ ({ 0,0 }), ({ 50,50 }), ({ -50,-50 }) });
  intensity = 100;
  restore_object(FILE_NAME);
  call_out("update_low",SPEED);
  move("bing");
}
move(arg) {
  ::move(HOME);
}
mixed *query_cold() { return coldarr; }
mixed *query_rain() { return rainarr; }
mixed *query_cloud() { return cloudarr; }
int query_moon() { return mooncycle; }
string query_moon_string(object env) {
  int bing;
  bing = timeofday - (DAY/4) -
         (distance((mixed *)env->query_co_ord(), ({ 0, 0, 0, }))/100);
  if (bing<0) bing += DAY;
  if ((moonoff+(DAY/2)<bing) && (bing<DAY-moonoff))
    return 0;
  return ({ "full moon",
            "waning three quarter moon",
            "waning half moon",
            "waning quarter moon",
            "waning cresent moon",
            "new moon",
            "waxing cresent moon",
            "waxing quarter moon",
            "waxing half moon",
            "waxing three quarter moon" })[mooncycle];
}
int distance(mixed *co_ord1, mixed *co_ord2) {
  int off;
  if (!pointerp(co_ord1) || !pointerp(co_ord2))
    return 0;
  if (co_ord1[0]>co_ord2[0])
    off = co_ord1[0] - co_ord2[0];
  else
    off = co_ord2[0] - co_ord1[0];
  if (co_ord1[1]>co_ord2[1])
    off += co_ord1[1] - co_ord2[1];
  else
    off += co_ord2[1] - co_ord1[1];
  return off;
}
int query_season() { return timeofyear/15; }
int query_time_of_year() { return timeofyear; }
int query_time_of_day() { return timeofday; }
int query_day(object env) {
  int bing, bit;
  if (!env) {
    load_object(CONFIG_START_LOCATION);
    env = find_object(CONFIG_START_LOCATION);
  }
  bing = timeofday - (DAY/4) -
         (distance((mixed *)env->query_co_ord(), ({ 0, 0, 0, }))/100);
  if (bing<0) bing += DAY;
  bit = (DAY/2)-(timeofyear-(YEAR/2))/(YEAR/10);
  if (bing>bit)
    return 0;
  if (bit < 10)
    return bit;
  return -(bing - bit);
}
int query_darkness(object env) {
  int bing, per, i;
  per = -cloud_index(env);
  if (per <-100)
    per = -100;
  if (per > 100)
    per = 100;
  if ((i=query_day(env))) {
    i *= 20;
    if (i>100)
      i = 100;
    return 50+(per+100)*150*i/20000;
  }
  bing = timeofday - (DAY/4) -
         (distance((mixed *)env->query_co_ord(), ({ 0, 0, 0, }))/100);
  if (bing<0) bing += DAY;
  if ((moonoff+(DAY/2)<bing) && (bing<DAY-moonoff))
    return 15+(per+100)*30/200;
  if (timeofday<0) timeofday += DAY;
  i = mooncycle -5;
  if (i<0)
    i = -i;
  return 30+(per+100)*14*i/200;
}
string weather_string(object env) {
  return temperature_string(env)+" with "+cloud_string(env)+
         rain_string(env);
}
int query_raining(object env) {
  int cloud,rain;
  if (temperature_index(env)/(100/7)<2) {
    cloud = cloud_index(env);
    if (cloud<=0)
      return 0;
    rain = rain_index(env);
    if (cloud-rain<=0)
      return 0;
    return cloud-rain;
  }
  return 0;
}
int query_hailing(object env) {
  int cloud, rain;
  if (temperature_index(env)/(100/7)==2) {
    cloud = cloud_index(env);
    if (cloud <=0)
      return 0;
    rain = rain_index(env);
    if (cloud-rain <=0)
      return 0;
    return cloud-rain;
  }
  return 0;
}
int query_snowing(object env) {
  int cloud,rain;
  if ((temperature_index(env)/(100/7))>=3) {
    cloud = cloud_index(env);
    if (cloud<=0)
      return 0;
    rain = cloud_index(env);
    if (cloud-rain<=0)
      return 0;
    return cloud-rain;
  }
  return 0;
}
string rain_string(object env) {
  int cloud, rain, temp;
  string tempstr1,tempstr2;
  cloud = cloud_index(env);
  rain = rain_index(env);
  if (cloud<=0) return "";
  if (cloud-rain<=0) return "";
  temp = temperature_index(env)/(100/7);
  if (temp>3) temp = 3;
  if (temp<-3) temp = -3;
  tempstr1 = ({ "very hot ",
                "hot ",
                "warm ",
                "nice ",
                "cold ",
                "",
                "" })[temp+3];
  tempstr2 = ({ " rain",
                " rain",
                " rain",
                " rain",
                " rain",
                " hail",
                " snow" })[temp+3];
  cloud = (cloud-rain) / 20;
  if (cloud>5) cloud = 5;
  return "\n"+capitalize(tempstr1 + ({ "very light",
                      "light",
                      "medium",
                      "heavy",
                      "very heavy" }) [cloud]+tempstr2);
}
string temperature_string(object env) {
  int inten;
  inten = temperature_index(env);
  inten /= 10;
  if (inten>10)
    inten = 10;
  if (inten<-10)
    inten = -10;
  return ({ "Its one of those baking eggs on the pavement days",
            "So hot that the sun feels like its right next door",
            "Damn hot",
            "Very hot",
            "Hot",
            "Hot",
            "Reasonably hot",
            "Very warm",
            "Warm",
            "Pleasantly warm",
            "Average temerature",
            "A little chilly",
            "A slight nip in the air",
            "Chilly",
            "Very chilly",
            "Cold",
            "Cold",
            "Very cold",
            "Damn cold",
            "Incredibly cold",
            "Freezing cold" })[inten+10];
}
string cloud_string(object env) {
  int off;
  off = cloud_index(env) / 20;
  if (off>5) off = 5;
  if (off<-5) off = -5;
  return ({ "a beatifully clear sky",
            "a few high level sirius clouds",
            "scattered puffy clouds",
            "very thin complete cloud cover",
            "light cloud cover",
            "medium cloud cover",
            "dense cloud cover",
            "packed cloud cover",
            "packed cloud cover",
            "heavy black clouds",
            "thick heavy clouds",
         })[off+5];
}
int temperature_index(object env) {
  int off,i;
  mixed clim, *co_ord;
  for (i=0;i<sizeof(coldarr);i++)
    off += (distance((mixed *)env->query_co_ord(), coldarr[i]) % (MAX_DIST*2));
  off = off / sizeof(coldarr);
  if ((clim = (mixed *)env->query_property("climate")))
    off += clim[C_TEMP];
  if (off>MAX_DIST) off = (MAX_DIST*2) - off;
  off -= (MAX_DIST/2);
  off = 0 - off;
  co_ord = (mixed *)env->query_co_ord();
  if (!co_ord)
    co_ord = ({ 0, 0, 0 });
  return (off + (timeofyear - (YEAR/2)) + (timeofday - (DAY/2)) + co_ord[2]);
}
int cloud_index(object env) {
  int off;
  mixed *clim;
  int i;
  for (i=0;i<sizeof(cloudarr);i++)
    off += (distance((mixed *)env->query_co_ord(), cloudarr[i]) % (MAX_DIST*2));
  off = off / sizeof(cloudarr);
  if ((clim = (mixed *)env->query_property("climate")))
    off += clim[C_CLOUD];
  if (off>MAX_DIST) off = (MAX_DIST*2) - off;
  off -= (MAX_DIST/2);
  off = 0-off;
  return (off + (timeofyear - (YEAR/2)));
}
int rain_index(object env) {
  int off;
  mixed *clim;
  int i;
  for (i=0;i<sizeof(rainarr);i++)
    off += (distance((mixed *)env->query_co_ord(), rainarr[i]) % (MAX_DIST*2));
  off = off / sizeof(rainarr);
  if ((clim = (mixed *)env->query_property("climate")))
    off += clim[C_RAIN];
  if (off>MAX_DIST) off = (MAX_DIST*2) - off;
  off -= MAX_DIST/2;
  off = 0-off;
  return off;
}
void update_low() {
  int i;
  timeofday++;
  if (timeofday>DAY) {
    timeofday = 0;
    timeofyear++;
    mooncycle++;
    if (mooncycle %2) {
      moonoff += 1;
      moonoff = moonoff % (DAY/2);
    }
    timeofyear = timeofyear % YEAR;
    mooncycle = mooncycle % 10;
    save_object(FILE_NAME);
  }
  for (i=0;i<sizeof(rainarr);i++) {
    rainarr[i][0] += random(3)-1;
    rainarr[i][0] = rainarr[i][0] % (MAX_DIST*2);
    rainarr[i][1] += random(3)-1;
    rainarr[i][1] = rainarr[i][1] % (MAX_DIST*2);
  }
  for (i=0;i<sizeof(cloudarr);i++) {
    cloudarr[i][0] += random(3)-1;
    cloudarr[i][0] = cloudarr[i][0] % (MAX_DIST*2);
    cloudarr[i][1] += random(3)-1;
    cloudarr[i][1] = cloudarr[i][1] % (MAX_DIST*2);
  }
  for (i=0;i<sizeof(coldarr);i++) {
    coldarr[i][0] += random(3)-1;
    coldarr[i][0] = coldarr[i][0] % (MAX_DIST*2);
    coldarr[i][1] += random(3)-1;
    coldarr[i][1] = coldarr[i][1] % (MAX_DIST*2);
  }
  intensity += random(3)-1;
  if (intensity<50)
    intensity=50;
  if (intensity>300)
    intensity=300;
  call_out("update_low",SPEED);
}
void dest_me() {
  save_object(FILE_NAME);
  ::dest_me();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/guilds/standard.c ===
#include <skills.h>
#include <tune.h>
#include <guilds.h>
#include <config.h>
inherit "/std/object";
nosave string gp_skill;
nosave string start_pos;
nosave mixed *commands;
nosave string *skills;
nosave mixed *spells;
protected void create() {
   gp_skill = "other.points";
   start_pos = CONFIG_START_LOCATION;
   skills = ({ "crafts", "faith", "fighting", "other" });
   commands = ({ });
   spells = ({ });
   ::create();
}
string query_gp_skill() { return gp_skill; }
void set_gp_skill( string word ) { gp_skill = word; }
void set_gp( object thing ) {
   if ( !thing ) {
      return;
   }
   thing->set_max_gp( 50 + (int)thing->query_skill_bonus( gp_skill ) );
}
string query_start_pos( object thing ) { return start_pos; }
void set_start_pos( string word ) { start_pos = word; }
string *query_skills() { return skills; }
void set_skills( string *words ) { skills = words; }
int add_command(string name, int add_if_player) {
   if (member_array(name, commands) != -1) {
      return 0;
   }
   commands += ({ name, ({ add_if_player }) });
   return 1;
}
int remove_command(string name) {
   int i;
   if ((i = member_array(name, commands)) == -1) {
      return 0;
   }
   commands = delete(commands, i, 1);
   return 1;
}
int do_command(string name, mixed param) {
   log_file("BAD_COMMANDS", "do_command() called on /std/guilds/standard.c\n");
   return 0;
}
int add_spell(string name, mixed ob, string func_name, int add_if_player) {
   int i;
   if ((i = member_array(name, spells)) != -1) {
      return 0;
   }
   spells += ({ name, ({ ob, func_name, add_if_player }), });
   return 1;
}
int remove_spell(string name) {
   int i;
   if ((i= member_array(name, spells)) == -1) {
      return 0;
   }
   spells = delete(spells, i, 2);
   return 1;
}
int cast_spell(string name, mixed bing) {
   int i;
   if ((i=member_array(name, spells)) == -1) {
      return 0;
   }
   return (int)call_other(spells[i+1][0], spells[i+1][1], bing);
}
mixed *query_spells() { return spells; }
string *query_commands() { return commands; }
int query_skill_cost( string skill ) { return 10; }
int query_skill_max_level( string skill ) { return 10; }
void start_player(object pl) {
   int i;
   if (!spells) {
      spells = ({ });
   }
   for (i=0;i<sizeof(spells);i+=2) {
      if (spells[i+1][2] || !interactive(pl)) {
         pl->add_spell(spells[i], spells[i+1][0], spells[i+1][1]);
      }
   }
   if (!pointerp(commands)) {
      commands = ({ });
   }
   for (i=0;i<sizeof(commands);i+=2) {
      if (commands[i+1][0] || !interactive(pl)) {
         pl->add_known_command(commands[i]);
      }
   }
}
void leave_guild() { return; }
void player_quit() { return; }
void player_save() { return; }
void player_heart_beat( string guild, object thing ) {
}
void set_level( object thing, int level, string guild ) {
   call_out( "set_new_level", 1, ({ thing, level, guild }) );
}
string adjust_primaries( object thing, int level ) {
  int i;
  string stat_list;
  stat_list = "";
  for ( i = 0; i < sizeof( skills ); i++ ) {
    if(level - thing->query_skill(skills[i]) > 0)
      thing->add_skill_level(skills[i], level - thing->query_skill(skills[i]));
    stat_list += (string)SKILL_OB->query_skill_stat(skills[i]);
    if(random(2)) {
      stat_list += "C";
    }
  }
  return stat_list;
}
void set_new_level( mixed *args ) {
   int i, j, level;
   string stat_list;
   object thing;
   thing = args[ 0 ];
   if ( !thing ) {
      return;
   }
   level = args[ 1 ];
   thing->add_skill_level("fighting", level / 4 );
   thing->add_skill_level("other", level / 4 );
   switch(thing->query_guild_ob()) {
   case "/std/guilds/warrior":
   case "/std/guilds/assassin":
     thing->add_skill_level("other.health", level);
     break;
   case "/std/guilds/thief":
     thing->add_skill_level("other.health", (level * 3) / 4);
     break;
   default:
     thing->add_skill_level("other.health", level / 2);
   }
   thing->add_skill_level("other.perception", level / 3);
   stat_list = adjust_primaries( thing, level );
   if(thing->query_property( "unique" ) ||
      thing->query_property( "keep setup stats" ) ||
      (!thing->query_race_ob() ||
       !(thing->query_race_ob())->query_humanoid()))
     return;
   thing->adjust_con( -6 + random( 3 ) );
   thing->adjust_dex( -6 + random( 3 ) );
   thing->adjust_int( -6 + random( 3 ) );
   thing->adjust_str( -6 + random( 3 ) );
   thing->adjust_wis( -6 + random( 3 ) );
   for ( i = 0; i < 25; i++ ) {
      j = random( strlen( stat_list ) );
      switch ( stat_list[ j .. j ] ) {
         case "C" :
            thing->adjust_con( 1 );
            break;
         case "D" :
            thing->adjust_dex( 1 );
            break;
         case "I" :
            thing->adjust_int( 1 );
            break;
         case "S" :
            thing->adjust_str( 1 );
            break;
         default :
            thing->adjust_wis( 1 );
            break;
      }
   }
}
int query_level( object thing ) {
   int i, lvl;
   if ( !thing || !sizeof( skills ) ) {
      return 0;
   }
   for ( i = 0; i < sizeof( skills ); i++ ) {
      lvl += (int)thing->query_skill( skills[ i ] );
   }
   lvl /= sizeof( skills );
   return lvl;
}
string query_title( object player ) { return "the Adventurer"; }
void skills_advanced( object thing, string skill, int level ) {
   if ( strsrch( skill, "covert" ) != -1 ) {
      if ( ( (int)thing->query_skill( "covert.stealth" ) > 5 ) &&
             !thing->query_known_command( "peek" ) ) {
         tell_object( thing, "You realise that you could use your newly "
                      "improved stealth to \"peek\" covertly at someone, and "
                      "maybe they won't notice...\n" );
         thing->add_known_command( "peek" );
      }
   } else if ( strsrch( skill, "fighting.combat.parry.held" ) != -1 ) {
      if ( ( (int)thing->query_skill( "fighting.combat.parry.held" ) > 50 ) &&
                  !thing->query_known_command( "riposte" ) ) {
         tell_object( thing, "You realise that you could use your newly "
                     "improved parry to \"riposte\" someones attack.\n" );
         thing->add_known_command( "riposte" );
      }
   }
}
int add_position( string sub_guild, string position,
                           int max, string* abilities, mixed* description ) {
    return POSITION_FAIL;
}
int remove_position( string sub_guild, string position ) {
    return POSITION_FAIL;
}
mapping query_positions( string sub_guild, string position ) {
    return 0;
}
string *query_position_appointments( string sub_guild, string position ) {
    return 0;
}
mixed *query_position_description( string sub_guild, string position ) {
    return 0;
}
string *query_position_abilities( string sub_guild, string position ) {
    return 0;
}
void reset_positions( string sub_guild ) {
}
int appoint_position( string sub_guild, string position,
                                 string player_name ) {
    return POSITION_FAIL;
}
int dismiss_position( string sub_guild, string position,
                                 string player_name ) {
    return POSITION_FAIL;
}
string query_position( string sub_guild, string player_name ) {
    return 0;
}
int query_guild_ability( mixed thing, string ability ) {
    return 0;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/guilds/warrior.c ===
#include <player_handler.h>
#include <top_ten_tables.h>
#include <playtesters.h>
#define SAVE_FILE ( "/save/guilds/warriors/warrior_ob" )
inherit "/std/guilds/standard";
void load_file();
void save_file();
void setup() {
  set_name("warriors");
  set_short("Warriors' Guild");
  set_long("The Warriors' Guild.\n\n"
           "The Warriors' Guild is for the brave and "
           "heroic.  As a member you can expect to "
           "recieve a sound background in beating, "
           "bashing, slicing, and dicing a variety of "
           "opponents up with a wide selection of "
           "weapons.  The evaluation of arms and armour "
           "will also be covered in detail.  Join this "
           "guild if you wish to journey to interesting "
           "places, meet interesting people, and give "
           "them a sound thrashing.\n");
  set_gp_skill("fighting.points");
  set_start_pos("/d/dist/pumpkin/squash/squash5");
  set_skills(({  "fighting.points",
                 "fighting.combat.melee.sharp",
                 "fighting.combat.melee.pierce",
                 "fighting.combat.melee.blunt",
                 "fighting.combat.melee.unarmed",
                 "fighting.combat.range.thrown",
                 "fighting.combat.range.fired",
                 "fighting.combat.parry.melee",
                 "fighting.combat.parry.range",
                 "fighting.combat.dodging.melee",
                 "fighting.combat.dodging.range",
                 "fighting.combat.special.weapon",
                 "fighting.combat.special.unarmed",
                 "other.evaluating.weapons",
                 "other.evaluating.armour"  }));
}
int query_skill_cost(string skill) {
  string *bits;
  if(member_array(skill, skills) != -1)
    return 3;
  bits = explode(skill, ".");
  switch(bits[0]) {
    case "faith" :
      return 15;
    case "fighting" :
      return 5;
    case "magic" :
      return 50;
    default :
      return 10;
  }
}
int query_skill_max_level( string skill ) {
  string *bits;
  if(member_array(skill, skills) != -1)
    return 300;
  bits = explode(skill, ".");
  switch (bits[0]) {
    case "faith" :
      return 25;
    case "fighting" :
      return 50;
    case "magic" :
      return 5;
    case "other" :
      return 25;
    default :
      return 10;
  }
}
string query_title( object player ) {
  int lvl, female;
  female = (int)player->query_gender() == 2;
  lvl = query_level( player );
  switch( lvl ) {
      case 0..15: return "the Novice Fighter";
      case 16..30: return "the Apprentice Fighter";
      case 31..45: return "the Skillful Fighter";
      default: return "the Grave of All Hope";
    }
}
int query_warrior( string player ) {
  if( PLAYER_HANDLER->test_guild( player ) == "/std/guilds/warrior" ) {
    return 1;
  }
  return 0;
}
int query_warrior_ob( object player ) {
  if( player->query_guild_ob() == "/std/guilds/warrior" ) {
    return 1;
  }
  return 0;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/README ===
This is the directory in which the house layouts are written.

Each directory contains one template. Any directory which ends with the
letter 'M' means that template contains multiple houses (e.g. a duplex or
block of flats).

Within each directory are a number of files. Each file corresponds to a
single room. Each file starts with N. The N will be replaced by the house
number (so you could have several houses in a particular area each with a
different number so they don't get mixed up). If there are multiple houses
in the directory they will be indicated by a letter after the
N. e.g. Nagarden.c Naliving.c Nafluff.c are all part of house Na and
Nbgarden.c Nbliving.c Nbfluff.c are all part of the house Nb. Finally the
room will have a name e.g. livingroom, bedroom1, etc.

The code for the house rooms is normal LPC code except that information
that will vary has been replaced with %<name>%. These fields are
substituted when you use the housing creator. The following substitutions
are available:

  %savedir% -- the directory for the houses save files
  %N% -- the house number
  %orientation% -- 1 if the house is oriented on a diagonal, 0 otherwise.
  %out% -- the destination of the exit onto the street.
  %1% - %7% -- the directions as follows:  7 0 1
                                            \|/
                                           6-+-2  
                                            /|\
                                           5 4 3
               these relative directions will be mapped to cardinal
               directions by the housing creator.

A typical room will look something like this:

    #include "path.h";
    inherit PLAYER_HOUSE;
    
    void setup() {
       set_light(50);
       set_theft_handler( HOSPITAL );
       set_save_file("%savedir%/%N%bed");
       
       /* DESCRIPTIONS */
       set_orientation(%orientation%);
       set_quit_handler(%out%);
    
       set_short("bedroom");
       set_base_desc( "a small bedroom" );
       add_surface( "floor", "stone paving" );
       add_surface( "ceiling", "roughly finished wood" );
       add_surface( "%0% wall", "roughly finished wood" );
       add_surface( "%2% wall", "roughly finished wood" );
       add_surface( "%4% wall", "roughly finished wood" );
       add_surface( "%6% wall", "roughly finished wood" );
    
       /* EXITS */
    
       add_exit( "%4%", PATH +"%N%livingroom", "door" );
       modify_exit("%4%", ({ "door short", "living room door" }));
    }

The base description is put at the beginning of the rooms generated
description, it only needs to be brief description, the full description
will be auto-generated.

6 surfaces should be present -- floor, ceiling, %0%, %2%, %4% and
%6%. Ceiling will not be present in an outside room of course.

Doors should be given a short description typically involving the room the
door leads to. Do not mark doors as open, closed, locked, unlocked or
having any keys since this is all handled by the housing system.


=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/tworoomflat/flatNbed.c ===
#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/flat%N%bed");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "%6%", PATH +"flat%N%", "door" );
   modify_exit("%6%", ({ "door short", "livingroom door" }));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/tworoomflat/flatN.c ===
#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/flat%N%");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("front room");
   set_base_desc("a small and cosy front room" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit("out", %out%, "door");
   modify_exit("out", ({ "door short", "front door"}));
   add_exit("%2%", PATH+"flat%N%bed", "door");
   modify_exit("%2%", ({ "door short", "bedroom door"}));
   modify_exit("out", ({"exit mess", "$N leaves the flat.",
                         "enter mess",
                           ({ 1,
                              "$N enters from a flat.",
                              "$N enter from a flat."
                           }),
                       }) );
   modify_exit( "out", ({ "closed", 1 }) );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/onebedhouse/Nhall.c ===
#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%hall");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("front room");
   set_base_desc("a small hallway" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit("out", %out%, "door");
   modify_exit("out", ({"door short", "front door",
                          "exit mess", "$N leaves the house.",
                          "closed", 1,
                          "enter mess",
                          ({ 1,
                               "$N enters from a house.",
                               "$N enter from a house."
                               }),
                          }) );
   add_exit("%0%", PATH+"%N%livingroom", "door");
   modify_exit("%0%", ({ "door short", "livingroom door"}));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/onebedhouse/Nbed.c ===
#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "down", PATH +"%N%livingroom", "stair" );
   modify_exit("down", ({ "downgrade", 9 }));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/onebedhouse/Nlivingroom.c ===
#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%livingroom");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("livingroom");
   set_base_desc("a comfortable livingroom");
   add_surface("floor", "finished pine board" );
   add_surface("ceiling", "plain plaster" );
   add_surface("%0% wall", "plain plaster");
   add_surface("%2% wall", "plain plaster");
   add_surface("%4% wall", "plain plaster");
   add_surface("%6% wall", "plain plaster");
   add_exit("%4%", PATH+"%N%hall", "door");
   modify_exit("%4%", ({"door short", "hallway door"}));
   add_exit("up", PATH+"%N%bed", "stair");
   modify_exit("up", ({ "upgrade", 9 }));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/onebedhut/Nbed.c ===
#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "stone paving" );
   add_surface( "ceiling", "roughly finished wood" );
   add_surface( "%0% wall", "roughly finished wood" );
   add_surface( "%2% wall", "roughly finished wood" );
   add_surface( "%4% wall", "roughly finished wood" );
   add_surface( "%6% wall", "roughly finished wood" );
   add_exit( "%4%", PATH +"%N%livingroom", "door" );
   modify_exit("%4%", ({ "door short", "living room door" }));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/onebedhut/Nlivingroom.c ===
#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%livingroom");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("livingroom");
   set_base_desc("a small cramped livingroom");
   add_surface("floor", "stone paving" );
   add_surface("ceiling", "roughly finished wood" );
   add_surface("%0% wall", "roughly finished wood" );
   add_surface("%2% wall", "roughly finished wood" );
   add_surface("%4% wall", "roughly finished wood" );
   add_surface("%6% wall", "roughly finished wood" );
   add_exit("out", %out%, "door");
   modify_exit("out", ({"door short", "front door",
                          "exit mess", "$N leaves the hut.",
                          "closed", 1,
                          "enter mess",
                          ({ 1,
                               "$N enters from a hut.",
                               "$N enter from a hut."
                               }),
                          }) );
   add_exit("%0%", PATH+"%N%bed", "door");
   modify_exit("%0%", ({"door short", "bedroom door"}));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/fourbedhouse/Nbed2.c ===
#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed2");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "%0%", PATH +"%N%landing1", "door" );
   modify_exit("%0%", ({ "door short", "bedroom door" }));
   add_exit("window", PATH + "%N%half-roof", "window");
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/fourbedhouse/Nbed4.c ===
#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed4");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "%4%", PATH +"%N%landing2", "door" );
   modify_exit("%4%", ({ "door short", "livingroom door" }));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/fourbedhouse/Nbed3.c ===
#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed3");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "%0%", PATH +"%N%landing2", "door" );
   modify_exit("%0%", ({ "door short", "bedroom door" }));
   add_exit("window", PATH + "%N%half-roof", "window");
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/fourbedhouse/Nfamilyroom.c ===
#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/flat%N%study");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("small study");
   set_base_desc("a small study");
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit("%6%", PATH+"%N%kitchen", "corridor");
   add_exit("%0%", PATH+"%N%garden", "door");
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/fourbedhouse/Nlanding2.c ===
#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/flat%N%bed");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("hallway");
   set_base_desc( "a hallway" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_exit( "%0%", PATH +"%N%bed4", "door" );
   modify_exit("%0%", ({ "door short", "bedroom door" }));
   add_exit( "%4%", PATH +"%N%bed3", "door" );
   modify_exit("%4%", ({ "door short", "bedroom door" }));
   add_exit( "%6%", PATH +"%N%landing1", "corridor" );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/fourbedhouse/Nlanding1.c ===
#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%landing1");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("landing");
   set_base_desc( "a landing at the top of the stairs" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "%0%", PATH +"%N%masterbed", "door" );
   modify_exit("%0%", ({ "door short", "bedroom door" }));
   add_exit( "%4%", PATH +"%N%bed2", "door" );
   modify_exit("%4%", ({ "door short", "bedroom door" }));
   add_exit("%2%", PATH+"%N%landing2", "corridor");
   add_exit("down", PATH+"%N%livingroom", "corridor");
   modify_exit("down", ({"downgrade", 9 }));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/house/fourbedhouse/Ndiningroom.c ===
#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%diningroom");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("spacious dining room");
   set_base_desc("a spacious dining room");
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit("%3%", PATH+"%N%livingroom", "corridor");
   add_exit("%2%", PATH+"%N%kitchen", "corridor");
   add_exit("window", PATH+"%N%garden", "window");
}
