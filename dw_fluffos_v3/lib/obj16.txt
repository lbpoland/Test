
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/nquest_handler.c ===
#include <player_handler.h>
#define LIBRARY "/obj/handlers/nlibrary"
#define QUEST_LOG "QUESTS"
#define SAVE_FILE "/save/quests"
#define BACKUP_FILE "/save/quests/quests"
inherit "/std/object";
private int *quest_level;
private int *num_times_done;
private int *quest_status;
private string *quest_name;
private string *quest_title;
private string *quest_story;
private string *last_done_by;
private nosave int total_qp;
void load_quests() { unguarded( (: restore_object, SAVE_FILE :) ); }
void save_quests() { unguarded( (: save_object, SAVE_FILE :) ); }
void create() {
   int i;
   ::create();
   load_quests();
   if ( !quest_name ) {
      quest_name = ({ });
   }
   if ( !quest_level ) {
      quest_level = ({ });
   }
   if ( !quest_title ) {
      quest_title = ({ });
   }
   if ( !quest_story ) {
      quest_story = ({ });
   }
   if ( !last_done_by ) {
      last_done_by = ({ });
   }
   if ( !num_times_done ) {
      num_times_done = ({ });
   }
   if ( !quest_status ) {
     if(sizeof(quest_name)) {
       quest_status = allocate(sizeof(quest_name));
       for(i=0; i<sizeof(quest_name); i++) {
         quest_status[i] = 1;
       }
     } else {
       quest_status = ({ });
     }
   }
   for(i = 0; i<sizeof(quest_level); i++) {
     if(quest_status[i]) {
       total_qp += quest_level[i];
     }
   }
}
int query_total_qp() { return total_qp; }
int add_quest( string name, int level, string title, string story ) {
   string log_name;
   if ( member_array( name, quest_name ) != -1 )
      return 0;
   quest_name += ({ name });
   quest_level += ({ level });
   quest_title += ({ title });
   quest_story += ({ story });
   last_done_by += ({ "nobody" });
   num_times_done += ({ 0 });
   quest_status += ({ 1 });
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file( QUEST_LOG, log_name +
         " added: "+ name +", "+ level +", "+ title +", "+ story +"\n" );
   save_quests();
   unguarded( (: cp, SAVE_FILE +".o", BACKUP_FILE +"."+ time() :) );
   total_qp += level;
   return 1;
}
int change_quest_status(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  quest_status[temp] = !quest_status[temp];
  return quest_status[temp];
}
int query_quest_status(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  return quest_status[temp];
}
int query_quest_level(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  return quest_level[temp];
}
int set_quest_level(string name, int level) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : level set for %s to %d\n\n",
            log_name, name, level);
   quest_level[ temp ] = level;
   save_quests();
   return 1;
}
string query_quest_story(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return "did nothing";
  }
  return quest_story[temp];
}
int set_quest_story(string name, string story) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : story set for %s to %s\n\n",
            log_name, name, story);
   quest_story[ temp ] = story;
   save_quests();
   return 1;
}
string query_quest_title(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1 || quest_title[temp] == "") {
    return "Unknown Quester";
  }
  return quest_title[temp];
}
int set_quest_title(string name, string title) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : title set for %s to %s\n\n",
            log_name, name, title);
   quest_title[ temp ] = title;
   save_quests();
   return 1;
}
int query_quest_times( string name ) {
   int i;
   i = member_array( name, quest_name );
   if ( i == -1 )
      return -1;
   return num_times_done[ i ];
}
mixed query_quest_done( string name ) {
   int i;
   i = member_array( name, quest_name );
   if ( i == -1 )
      return -1;
   return last_done_by[ i ];
}
int delete_quest(string name) {
   int temp;
   string log_name;
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, log_name + " removed : " +
            name + "\n\n");
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   total_qp -= quest_level[temp];
   quest_name = delete(quest_name, temp, 1);
   quest_level = delete(quest_level, temp, 1);
   quest_title = delete(quest_title, temp, 1);
   quest_story = delete(quest_story, temp, 1);
   last_done_by = delete( last_done_by, temp, 1 );
   num_times_done = delete( num_times_done, temp, 1 );
   save_quests();
   return 1;
}
string *query_quest_names() {
  return quest_name + ({ });
}
int *query_quest_levels() {
  return quest_level + ({ });
}
string *query_quest_titles() {
  return quest_title + ({ });
}
string *query_quest_stories() {
  return quest_story + ({ });
}
void quest_completed( string name, string quest, object prev_ob ) {
   int i;
   string word;
   log_file( QUEST_LOG, ctime( time() ) +" "+ name +" completed "+
         quest +"\n" );
   user_event( "inform", name +" completes "+ quest, "quest" );
   if ( file_name( previous_object() ) != LIBRARY ) {
      prev_ob = previous_object();
   }
   word = (string)prev_ob->query_name();
   if ( !word ) {
      word = file_name( prev_ob );
   } else {
      word += " ("+ file_name( prev_ob ) +")";
   }
   log_file( QUEST_LOG, "given by "+ word +"\n" );
   i = member_array( quest, quest_name );
   if ( i == -1 ) {
      log_file( QUEST_LOG, "non existent quest\n" );
      return;
   }
   last_done_by[ i ] = name;
   num_times_done[ i ]++;
   save_quests();
}
int query_player_fame(string name){
   int playerqp, rank;
   if (!name){
      return 0;
   }
   if (this_player()){
      name = (string)this_player()->expand_nickname(name);
   }
   if (!PLAYER_HANDLER->test_user(name)){
      return 0;
   }
   playerqp = (int)LIBRARY->query_quest_points(name);
   rank = ( playerqp * 125 ) / query_total_qp();
   return rank;
}
string query_fame_str( string name ) {
   switch ( query_player_fame( name ) ) {
      case 0 .. 4 :
         return "completely unknown";
      case 5 .. 14 :
         return "unknown";
      case 15 .. 24 :
         return "unknown";
      case 25 .. 34 :
         return "moderately well known";
      case 35 .. 44 :
         return "well known";
      case 45 .. 54 :
         return "very well known";
      case 55 .. 64 :
         return "known throughout the region";
      case 65 .. 74 :
         return "famous";
      case 75 .. 84 :
         return "renowned";
      case 85 .. 94 :
         return "Disc renowned";
      default :
         return "so renowned that no introduction is needed";
   }
}
string *query_player_story(string name){
   string *quests;
   string *story;
   int i;
   story = ({ });
   if (!name){
      return ({ });
   }
   if (this_player()){
      name = (string)this_player()->expand_nickname(name);
   }
   if (!PLAYER_HANDLER->test_user(name)){
      return 0;
   }
   quests = query_quest_names();
   if (sizeof(quests) == 1){
      story = ({"Is an under achiever."});
   }
   else{
      for(i=0;i<sizeof(quests);i++){
         if (LIBRARY->query_quest_done(name, quests[i])){
            story = ({ query_quest_story( quests[ i ] ) }) + story;
         }
      }
   }
   return story;
}
void print_some_stats()  {
   int i;
   for (i = 0; i < sizeof(quest_name); i++)
      printf("%s: %6d, %3d\n", quest_name[i], num_times_done[i], quest_level[i]);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/data.c ===
#include <data.h>
#include <function.h>
#define CALLOUT_DELAY 0
#define DEBUG !
#define DC_DELIM 0
#define DC_ARRAY 1
#define DC_MAPPING 2
#define DC_OF 3
#define DC_CLASS 4
#define DC_STRING 5
#define DC_ITEM 6
#define DC_NUMBER 7
#define DC_GREY 8
#define MAX_SUBF_SIZE 16000
#define WHITESPACE(c) (c == 10 || c == 32 || c == '\n')
#ifdef DEBUG
#  define Error(s) write(s); log_file( "DATA_COMPILER", s);
#else
#  define Error(s) ;
#endif
string std_euid;
void create() {
    std_euid = "/secure/master"->creator_file(file_name(this_object()));
    seteuid(std_euid);
}
int tmp_file_no;
private string strip_string( string str ) {
    int     i, j;
    if (!str || str == "") return "";
    j = strlen( str ) - 1;
    for( ; WHITESPACE( str[ i ] ) && i <= j; i++ ) ;
    for( ; WHITESPACE( str[ j ] ) && j > i; j-- ) ;
    return str[ i..j ];
}
private mixed cleanup_assoc( mixed parse ) {
    int j;
    for (j = 0; j < sizeof(parse[0]); j++) {
        if ((parse[1][j] == DC_DELIM) || (parse[1][j] == DC_OF)) {
            parse[0][j] = 0;
            parse[1][j] = 0;
        }
    }
    parse[0] -= ({ 0 });
    parse[1] -= ({ 0 });
    return parse;
}
mixed compile_data( string *path ) {
    string tmp_name, data = "", file_data = "", s1, tmp_val, base, keyword;
    string *segments, *ind, *val, cur_index;
    int i, j, t, debug_file, class_pending, stat, subfunc_cnt,
        subfunc_char_cnt, data_keyword_found, allocated_data;
    int *index_types;
    mixed parse, index_max;
    if (!sizeof(path))
      return 0;
    tmp_name = path[0] + "_dc.c";
    if( find_object( tmp_name ) )
        tmp_name->dest_me();
    if (file_size(tmp_name) > 0) {
        if ((stat = seteuid("Root")) == 0) {
        }
        stat = unguarded((: rm, tmp_name :));
        if (!stat) {
            Error("Error: couldn't remove old .c file (" +
                  geteuid(this_object()) + ", " +
                  "secure/master"->valid_seteuid(this_object(), "Root") +
                  ")\n");
            seteuid(std_euid);
            return 0;
        }
    }
    seteuid(std_euid);
    for (i = 0; i < sizeof(path); i++) {
        if (file_size(path[i]) <= 0)
          continue;
        data += read_file( path[i] );
    }
    if (!data) {
        Error("Error: file(s) not found.\n");
        return 0;
    }
    segments = explode( "$\n" + data, "\n#" );
    if( !segments ) {
        Error( "prop_to_fun() : Nothing but comments?\n" );
        return 0;
    }
    segments[ 0 ] = segments[ 0 ][ 1..(sizeof(segments[ 0 ]) - 1) ];
    for( i = 1; i < sizeof( segments ); i++ ) {
        if( sscanf( segments[ i ], "%s\n%s", s1, segments[ i ] ) != 2 ) {
            segments[ i ] = "";
        }
    }
    data = implode( segments, "\n" );
    segments = explode( strip_string( data ), "::" );
    if (sizeof( segments ) % 2) {
      segments += ({""});
    }
    ind = allocate( sizeof( segments ) / 2 );
    val = allocate( sizeof( segments ) / 2 );
    allocated_data = 0;
    for( i = 0; i < sizeof( ind ); i++ ) {
        ind[ i ] = segments[ i * 2 ];
        val[ i ] = strip_string( segments[ i * 2 + 1 ] );
        if( ind[ i ][ 0..0 ] == "#" ) {
            ind[ i ] = lower_case( ind[ i ] );
            if( ind[ i ] == "#debug" ) {
                sscanf( val[ i ], "%d", debug_file );
            } else if( ind[ i ] == "#include" ) {
                tmp_val = val[i];
                file_data += "#include " + replace( tmp_val, " ", "" ) + "\n";
            }
        }
    }
    for( i = 0; i < sizeof( ind ); i++ ) {
        keyword = lower_case( ind[ i ] );
        if( keyword[ 0..0 ] == "#" ) {
            continue;
        }
        subfunc_char_cnt += sizeof(ind[i]) + sizeof(val[i]);
        if (keyword == "data") {
            if (data_keyword_found) {
                Error("Error: more than one data keyword found.\n");
                return 0;
            }
            data_keyword_found = 1;
            file_data += "void dest_me() { destruct( this_object() ); }\n\n";
            parse = reg_assoc(val[i],
                              ({ "array", "mapping", "of", "class +[^\t ]+",
                                 "[^\t ]+" }),
                              ({ DC_ARRAY, DC_MAPPING, DC_OF, DC_CLASS,
                                 DC_GREY }),
                              DC_DELIM);
            parse = cleanup_assoc( parse );
            for (j = 0; (j < sizeof(parse[0])) && !index_max; j++) {
                switch (parse[1][j]) {
                  case DC_ARRAY:
                    break;
                  case DC_MAPPING:
                    break;
                  case DC_CLASS:
                    base = implode(parse[0][j..], " ");
                    file_data += base + " item;\n";
                  case DC_GREY:
                    index_types = parse[1][0..j-1];
                    index_max = allocate(sizeof(index_types));
                    break;
                  default:
                    Error("Error: data parse error 1 (" + parse[0][j] + ")\n");
                    return 0;
                }
            }
            if (index_types[0] == DC_MAPPING)
              file_data += "mapping data = ([ ]);\n\n";
            else
              file_data += "mixed data;\n\n";
            for (j = 0; j < sizeof(index_types); j++) {
                switch (index_types[j]) {
                  case DC_ARRAY:
                    index_max[j] = -1;
                    break;
                  case DC_MAPPING:
                    break;
                  default:
                    Error("Error: illegal index type found ("
                          + index_types[j] + ")\n");
                    return 0;
                }
            }
            file_data += "mixed data_return_" + subfunc_cnt + "() {\n";
            subfunc_cnt++;
            continue;
        }
        if (keyword[0..3] == "item") {
            if (class_pending) {
                file_data += "  data" + cur_index + " = item;\n";
                class_pending = 0;
            }
            if (subfunc_char_cnt > MAX_SUBF_SIZE) {
                file_data += "}\n\n";
                file_data += "mixed data_return_" + subfunc_cnt + "() {\n";
                subfunc_cnt++;
                subfunc_char_cnt = 0;
            }
            parse = reg_assoc( ind[i], ({ "\"[^\"]*\"", "item", "[0-9]+",
                                      "[^,\t ]+"}),
                              ({ DC_STRING, DC_ITEM, DC_NUMBER, DC_GREY }));
            parse = cleanup_assoc( parse );
            cur_index = "";
            for (j = 0; j < sizeof(index_types); j++) {
                switch (index_types[j]) {
                  case DC_ARRAY:
                    if (parse[1][j+1] != DC_NUMBER) {
                        if (parse[0][j+1] == "i") {
                            parse[0][j+1] = index_max[j] + "";
                        } else if (parse[0][j+1] == "i++") {
                            parse[0][j+1] = index_max[j] + "";
                            index_max[j]++;
                        } else if (parse[0][j+1] == "++i") {
                            index_max[j]++;
                            parse[0][j+1] = index_max[j] + "";
                        } else {
                          Error("Error: illegal index for array (" +
                                  parse[0][j+1] + ")\n");
                            return 0;
                        }
                    }
                    if ((t = to_int(parse[0][j+1])) > index_max[j]) {
                        file_data += "  data" + cur_index
                          + " = allocate(" + (t-index_max[j]) + ");\n";
                        index_max[j] = t;
                        allocated_data = 1;
                    }
                    break;
                  case DC_MAPPING:
                    if (j) {
                        file_data += "  if (!mapp(data" + cur_index + "))"
                          + " data" + cur_index + " = ([]);\n";
                    }
                    break;
                  default:
                    Error("Error: illegal index type found (" + index_types[j]
                          + ")\n");
                    return 0;
                }
                cur_index += "[" + parse[0][j+1] + "]";
            }
            if (strip_string(val[i]) != "") {
                file_data += "  data" + cur_index + " = " + val[i] + ";\n";
            }
            continue;
        }
        if (keyword[0..1] == "->") {
            if (!class_pending) {
                file_data += "  item = new( " + base + " );\n";
                class_pending = 1;
            }
            file_data += "  item->" + ind[i][2..] + " = " + val[i] + ";\n";
            continue;
        }
        if (keyword == "quote") {
            file_data += val[i] + "\n";
            continue;
        }
    }
    if (class_pending) {
        file_data += "  data" + cur_index + " = item;\n";
    }
    file_data += "}\n\n";
    file_data += "mixed data_return() {\n";
    if ( !allocated_data ) {
        for (j = 0; j < sizeof(index_types); j++) {
            switch (index_types[j]) {
                case DC_ARRAY:
                    file_data += "  data = allocate(" + (to_int(index_max[j]) + 1) + ");\n";
                break;
            }
        }
    }
    for (i = 0; i < subfunc_cnt; i++) {
        file_data += "  data_return_" + i + "();\n";
    }
    file_data += "  return data;\n}\n";
    seteuid("Root");
    unguarded((: write_file, tmp_name, file_data, 1 :));
    seteuid(std_euid);
    return tmp_name->data_return();
}
class data_node {
   int type;
   mixed value;
}
class queue_node {
   string name;
   class data_node data;
}
class compile_data {
   string file_name;
   function call_back;
   int current_line;
   int look_for;
   int last_chunk_compile;
   int file_len;
   class queue_node* depths;
}
private nosave class compile_data* _to_compile = ({ });
void start_compile();
void parse_chunk(class compile_data data, string chunk);
#define DATA_UNKNOWN 0
#define DATA_CHILDREN 1
#define DATA_NUMBER 2
#define DATA_STRING 3
#define DATA_LIST 4
#define OPEN_BRACKET 1
#define START_ARGUMENT 2
#define END_BRACKET 3
#define END_STRING 4
#define START_LIST 5
#define END_NUMBER 6
#define ARGUMENT_VALUE 7
#define ARGUMENT_NAME 8
#define REST_OF_ARGUMENT 9
#define END_STRING_LIST 10
#define END_NUMBER_LIST 11
#define END_LIST 12
#define CHUNK_SIZE 10
void compile_file(string fname, function call_back) {
   class compile_data data;
   if (file_size(fname) == -1) {
      tell_object(this_player(), "The file "+
                         fname+" does not exist.\n");
      return ;
   }
   if (file_size(fname) == -2) {
      tell_object(this_player(), "The file "+
                         fname+" is a directory exist.\n");
      return ;
   }
   data = new(class compile_data);
   data->file_name = fname;
   data->call_back = call_back;
   data->look_for = OPEN_BRACKET;
   _to_compile += ({ data });
   start_compile();
}
void start_compile() {
   class compile_data data;
   if (!sizeof(_to_compile) || _to_compile[0]->last_chunk_compile) {
      return ;
   }
   data = _to_compile[0];
   data->last_chunk_compile = time();
   data->current_line = 1;
   data->look_for = OPEN_BRACKET;
   data->file_len = file_length(data->file_name);
   data->depths = ({ new(class queue_node,
                  data : new(class data_node, type : 0, value : ([ ]) )) });
   call_out("compile_chunk", CALLOUT_DELAY);
}
void compile_chunk() {
   string chunk;
   int end;
   class compile_data data;
   data = _to_compile[0];
   data->last_chunk_compile = time();
   if (data->current_line > data->file_len ||
       functionp(data->call_back) & FP_OWNER_DESTED) {
      call_out("start_compile", CALLOUT_DELAY);
      _to_compile = _to_compile[1..];
      if (!(functionp(data->call_back) & FP_OWNER_DESTED)) {
         evaluate(data->call_back, data->file_name, data->depths[0]->data->value);
      }
      return ;
   }
   if (data->current_line+CHUNK_SIZE > data->file_len) {
      end = data->file_len+1;
   } else {
      end = data->current_line+CHUNK_SIZE;
   }
   chunk = unguarded((: read_file, data->file_name, data->current_line,
                               end-data->current_line :));
   data->current_line = end;
   call_out("compile_chunk", CALLOUT_DELAY);
   parse_chunk(data, chunk);
}
mixed to_diceint(string str) {
   class data_dice dice;
   string s1;
   if (strsrch(str, "d") != -1) {
      dice = new(class data_dice);
      if (sscanf(str, "%dd%s", dice->number, s1) == 2) {
         if (strsrch(s1, "+")) {
            if (sscanf(s1, "%d+%d", dice->die, dice->modifier) != 2) {
               dice->die = to_int(s1);
            }
         } else if (strsrch(s1, "-")) {
            if (sscanf(s1, "%d-%d", dice->die, dice->modifier) != 2) {
               dice->die = to_int(s1);
            } else {
               dice->modifier = - dice->modifier;
            }
         } else {
            dice->die = to_int(s1);
         }
      }
      return dice;
   }
   return to_int(str);
}
void parse_chunk(class compile_data data, string chunk) {
   string *bits;
   string s1;
   string s2;
   string s3;
   int pos;
   int chunk_size;
   int start;
   class data_node node;
   while (sscanf(chunk, "%s#%s\n%s", s1, s2, s3) == 3) {
      chunk = s1 + s3;
   }
   chunk_size = strlen(chunk);
   pos = 0;
   bits = explode(chunk, "(");
   while (pos < chunk_size) {
      switch (data->look_for) {
         case OPEN_BRACKET :
            while (pos < chunk_size && (chunk[pos] == ' ' ||
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos == chunk_size) {
               break;
            }
            if (chunk[pos] == ')') {
               data->look_for = END_BRACKET;
               break;
            }
            if (chunk[pos] == '(') {
               chunk = chunk[pos+1..];
               chunk_size = strlen(chunk);
               pos = 0;
               node = new(class data_node, type : 0);
               data->depths += ({ new(class queue_node, data : node) });
               data->look_for = ARGUMENT_NAME;
            } else {
               pos = chunk_size;
            }
            break;
         case ARGUMENT_NAME :
            while (pos < chunk_size && (chunk[pos] == ' ' ||
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos == chunk_size) {
               break;
            }
            start = pos;
            while (pos < chunk_size && chunk[pos] != ' ' &&
                      chunk[pos] != '\t' && chunk[pos] != '\n') {
               pos++;
            }
            data->depths[<1]->name = chunk[start..pos-1];
            data->look_for = ARGUMENT_VALUE;
            break;
         case ARGUMENT_VALUE :
         case START_LIST :
            while (pos < chunk_size && (chunk[pos] == ' ' ||
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos >= chunk_size) {
               break;
            }
            switch (chunk[pos]) {
               case '(' :
                  if (data->look_for == START_LIST) {
                     debug_printf("Error, found a bracket inside a list.\n");
                     pos = chunk_size;
                     break;
                  }
                  data->look_for = OPEN_BRACKET;
                  data->depths[<1]->data->type = DATA_CHILDREN;
                  data->depths[<1]->data->value = ([ ]);
                  break;
               case '"' :
                  if (data->look_for == START_LIST) {
                     data->look_for = END_STRING_LIST;
                     data->depths[<1]->data->value += ({ "" });
                  } else {
                     data->look_for = END_STRING;
                     data->depths[<1]->data->value = "";
                  }
                  pos++;
                  data->depths[<1]->data->type = DATA_STRING;
                  break;
               case '0'..'9' :
                  if (data->look_for == START_LIST) {
                     data->look_for = END_NUMBER_LIST;
                     data->depths[<1]->data->value += ({ "" });
                  } else {
                     data->look_for = END_NUMBER;
                     data->depths[<1]->data->value = "";
                  }
                  data->depths[<1]->data->type = DATA_NUMBER;
                  break;
               case '}' :
                  if (data->look_for == START_LIST) {
                     data->look_for = END_BRACKET;
                     pos++;
                     data->depths[<1]->data->type = DATA_LIST;
                  } else {
                     debug_printf("End of list without a start of list.\n");
                     pos = chunk_size;
                  }
                  break;
               case '{' :
                  if (data->look_for == START_LIST) {
                     debug_printf("Cannot have nested lists.\n");
                     pos = chunk_size;
                  } else {
                     data->look_for = START_LIST;
                  }
                  data->depths[<1]->data->value = ({ });
                  data->depths[<1]->data->type = DATA_LIST;
                  pos++;
                  break;
               default :
                 if(chunk[pos] = 't')
                  if(chunk[pos..pos+3] == "true" || chunk[pos..pos+2] == "yes") {
                    if(chunk[pos..pos+3] == "true")
                      pos += 3;
                    else
                      pos += 2;
                    data->depths[<1]->data->value = 1;
                    data->depths[<1]->data->type = DATA_NUMBER;
                    data->look_for = END_BRACKET;
                    break;
                  }
                  debug_printf("Unknown data type %s in %s\n",
                               chunk[pos..pos+5], chunk);
                  pos = chunk_size;
                  break;
            }
            break;
         case END_LIST :
            while (pos < chunk_size && (chunk[pos] == ' ' ||
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos >= chunk_size) {
               break;
            }
            switch (chunk[pos]) {
               case ',' :
                  pos++;
                  data->look_for = START_LIST;
                  break;
               case '}' :
                  data->look_for = START_LIST;
                  break;
               default :
                  debug_printf("Expected , or } not %s\n", chunk[pos..pos+5]);
                  pos = chunk_size;
                  break;
            }
            break;
         case END_BRACKET :
            if (sscanf(chunk[pos..], "%s)%s", s1, s2)) {
               if (arrayp(data->depths[<2]->data->value[data->depths[<1]->name])) {
                  data->depths[<2]->data->value[data->depths[<1]->name] += ({
                       data->depths[<1]->data->value });
               } else if (sizeof(data->depths) == 2) {
                  data->depths[<2]->data->value[data->depths[<1]->name] = ({
                       data->depths[<1]->data->value });
               } else if (!undefinedp(data->depths[<2]->data->value[data->depths[<1]->name])) {
                  data->depths[<2]->data->value[data->depths[<1]->name] = ({
                       data->depths[<2]->data->value[data->depths[<1]->name],
                       data->depths[<1]->data->value });
               } else {
                  data->depths[<2]->data->value[data->depths[<1]->name] = data->depths[<1]->data->value;
               }
               data->depths = data->depths[0..<2];
               chunk = s2;
               chunk_size = strlen(s2);
               pos = 0;
               data->look_for = OPEN_BRACKET;
            }
            break;
         case END_NUMBER_LIST :
         case END_NUMBER :
            start = pos;
            while (pos < chunk_size && ((chunk[pos] >= '0' &&
                      chunk[pos] <= '9') ||
                      chunk[pos] == 'd' || chunk[pos] == '+' ||
                      chunk[pos] == '-')) {
               pos++;
            }
            if (data->look_for == END_NUMBER) {
               data->depths[<1]->data->value += chunk[start..pos - 1];
            } else {
               data->depths[<1]->data->value[<1] += chunk[start..pos - 1];
            }
            if (pos < chunk_size) {
               if (data->look_for == END_NUMBER) {
                  data->depths[<1]->data->value = to_diceint(data->depths[<1]->data->value);
                  data->look_for = END_BRACKET;
               } else {
                  data->depths[<1]->data->value[<1] = to_diceint(data->depths[<1]->data->value[<1]);
                  data->look_for = END_LIST;
               }
            }
            break;
         case END_STRING_LIST :
         case END_STRING :
            if (sscanf(chunk[pos..], "%s\"%s", s1, s2)) {
               if (strlen(s1) > 0 && s1[strlen(s1)-1] == '\\') {
                  if (data->look_for == END_STRING) {
                     data->depths[<1]->data->value += replace(s1[0..strlen(s1)-2], "\n", "")+"\"";
                  } else {
                     data->depths[<1]->data->value[<1] += replace(s1[0..strlen(s1)-2], "\n", "")+"\"";
                  }
                  chunk = s2;
                  pos = 0;
                  chunk_size = strlen(s2);
               } else {
                  if (data->look_for == END_STRING) {
                     data->depths[<1]->data->value += replace(s1, "\n", "");
                     data->look_for = END_BRACKET;
                  } else {
                     data->depths[<1]->data->value[<1] += replace(s1, "\n", "")+"\"";
                     data->look_for = END_LIST;
                  }
                  chunk = s2;
                  pos = 0;
                  chunk_size = strlen(s2);
               }
            } else {
               if (data->look_for == END_STRING) {
                  data->depths[<1]->data->value += replace(chunk, "\n", "");
               } else {
                  data->depths[<1]->data->value[<1] += chunk;
               }
               pos = chunk_size;
            }
            break;
         default :
            debug_printf("Horrible error "+data->look_for+" (" +
                         data->file_name + ") " + data->current_line + " " +
                         chunk[pos..] + "\n");
            pos = chunk_size;
            break;
      }
   }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/inhume.c ===
#include <inhume.h>
void create() {
   string * prev;
   string msg;
   prev = map( previous_object(-1), (: file_name($1) :) );
   msg = sprintf( "%s: /obj/handlers/inhume loaded: previous_object(-1) = %O",
     ctime( time() ), prev );
   tell_creator( "shrike", msg );
   log_file( LOG, msg );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/broadcaster.c ===
#define DIR_ARRAY ({ "east", "northeast", "north", "northwest", \
                     "west", "southwest", "south", "southeast", "east" })
#define SAVE_FILE "/save/broadcaster"
#define BROADCAST_HISTORY_LENGTH 10
void broadcast_event( object *things,
                      int *centre,
                      string message,
                      int range,
                      int inside,
                      int underwater );
void npc_hear_shouts(object newlistener);
int npc_unhear_shouts(object oldlistener);
void npc_shout_event( object shouter,
                      string start,
                      string message,
                      string lang,
                      int *coord,
                      int range );
private void load_me();
private void save_me();
private nosave object *_listeners;
private nosave mapping _channels;
private nosave mapping _channel_history;
private mapping _channel_ids;
void create() {
   _listeners = ({ });
   _channels = ([ ]);
   _channel_ids = ([ ]);
   _channel_history = ([ ]);
   load_me();
}
mixed *get_direc_dist( int *co_ord1, int *co_ord2 ) {
   int dx, dy, dz, sector;
   if (!pointerp(co_ord1) ||
       !pointerp(co_ord2)) {
      return ({ 0, DIR_ARRAY[0], 0 });
   }
   dx = co_ord1[ 0 ] - co_ord2[ 0 ];
   dy = co_ord1[ 1 ] - co_ord2[ 1 ];
   dz = co_ord1[ 2 ] - co_ord2[ 2 ];
   if ( dx > 0 ) {
      if ( ( 1000 * dy ) > ( 2414 * dx ) ) {
         sector = 0;
      } else {
         if ( ( 1000 * dy ) > ( 414 * dx ) ) {
            sector = 1;
         } else {
            if ( ( 1000 * dy ) > ( -414 * dx ) ) {
               sector = 2;
            } else {
               if ( ( 1000 * dy ) > ( -2414 * dx ) ) {
                  sector = 3;
               } else {
                  sector = 4;
               }
            }
         }
      }
   } else {
      if ( ( 1000 * dy ) < ( 2414 * dx ) ) {
         sector = 4;
      } else {
         if ( ( 1000 * dy ) < ( 414 * dx ) ) {
            sector = 5;
         } else {
            if ( ( 1000 * dy ) < ( -414 * dx ) ) {
               sector = 6;
            } else {
               if ( ( 1000 * dy ) < ( -2414 * dx ) ) {
                  sector = 7;
               } else {
                  sector = 8;
               }
            }
         }
      }
   }
   return ({ dx * dx + dy * dy + dz * dz, DIR_ARRAY[ sector ], dz });
}
void broadcast_event( object *things, int *centre, string message,
      int range, int inside, int underwater ) {
   int *to;
   string text;
   object thing, place;
   mixed *dir_direc;
   if ( !pointerp( things ) ||
        !pointerp( centre ) ||
        sizeof( centre ) != 3 ) {
      return;
   }
   foreach ( thing in things ) {
      if ( !living( thing ) ) {
         continue;
      }
      place = environment( thing );
      if ( !place ) {
         continue;
      }
      to = (int *)place->query_co_ord();
      if ( !pointerp( to ) || sizeof( to ) != 3 ) {
         continue;
      }
      switch ( (string)place->query_property( "location" ) ) {
         case "inside" :
            if ( !inside ) {
               continue;
            }
            break;
         case "underwater" :
            if ( !underwater ) {
               continue;
            }
            break;
         default :
      }
      dir_direc = get_direc_dist( centre, to );
      if ( dir_direc[ 0 ] < 0 ) {
         continue;
      }
      if ( dir_direc[ 0 ] > range * range ) {
         continue;
      }
      switch ( dir_direc[ 0 ] ) {
         case 0 :
            continue;
         case 1 .. 2500 :
            if ( ( dir_direc[ 2 ] * dir_direc[ 2 ] ) > ( dir_direc[ 0 ] / 2 ) ) {
               if ( dir_direc[ 2 ] > 0 ) {
                  text = "Right above you, "+ message +"\n";
               } else {
                  text = "Right below you, "+ message +"\n";
               }
            } else {
               text = "Very close to the "+ dir_direc[ 1 ] + ", "+
                     message +"\n";
            }
            break;
         case 2501 .. 40000 :
            text = "Nearby to the "+ dir_direc[ 1 ] + ", "+ message +"\n";
            break;
         case 40001 .. 640000 :
            text = "To the "+ dir_direc[ 1 ] + ", "+ message +"\n";
            break;
         case 640001 .. 10240000 :
            text = "In the distance to the "+ dir_direc[ 1 ] + ", "+
                  message +"\n";
            break;
         default:
            continue;
      }
      if(interactive(thing) && query_verb() == "shout") {
        text = thing->colour_event("shout", "") + text + "%^RESET%^";
      }
      thing->add_message( "$I$5="+ text, ({ }) );
   }
}
void npc_hear_shouts(object newlistener) {
  int i;
  if (member_array(newlistener,_listeners)!=-1) {
     return;
  }
  i = member_array(0,_listeners);
  if (i != -1) {
    _listeners[i]=newlistener;
  } else {
    _listeners=_listeners+({newlistener});
  }
}
int npc_unhear_shouts(object oldlistener) {
  int i;
  if (sizeof(_listeners)==0) {
    return 0;
  }
  i = member_array(oldlistener,_listeners);
  if (i == -1) {
    return 0;
  }
  _listeners = _listeners[0..i] + _listeners[i+1..];
  return 1;
}
void npc_shout_event( object shouter, string start, string message,
      string lang, int *coord, int range ) {
  if (_listeners) {
    _listeners -= ({ 0 });
    _listeners->event_person_shout(shouter, start, message,
                                  lang, coord, range );
  }
}
void add_object_to_channel(string channel_name,
                           object ob) {
   if (!_channels[channel_name]) {
      _channels[channel_name] = ({ });
   }
   _channels[channel_name] += ({ ob });
}
int remove_object_from_channel(string channel_name,
                               object ob) {
   if (_channels[channel_name]) {
      if (member_array(ob, _channels[channel_name]) != -1) {
         _channels[channel_name] -= ({ ob });
         if (!sizeof(_channels[channel_name])) {
           map_delete(_channels, channel_name);
         }
         return 1;
      }
   }
   return 0;
}
void broadcast_to_channel(mixed ob,
                          string channel,
                          mixed message) {
   string str;
   if (!ob) {
      return ;
   }
   if (objectp(ob)) {
      str = ob->query_cap_name();
   }
   if (_channels[channel]) {
      _channels[channel] -= ({ 0 });
      _channels[channel]->event_channel_message(ob, channel, message);
      if (!_channel_history[channel]) {
         _channel_history[channel] = ({ });
      }
      _channel_history[channel] += ({ ({ str, message, time() }) });
      if (sizeof(_channel_history[channel]) > BROADCAST_HISTORY_LENGTH) {
         _channel_history[channel] = _channel_history[channel][1..];
      }
   }
}
mixed *query_channel_history(string channel) {
   return _channel_history[channel];
}
object *query_channel_members(string channel) {
   return _channels[channel];
}
int is_channel(string channel) {
  return !undefinedp(_channels[channel]);
}
mapping query_all_channels() {
   return _channels;
}
int query_next_channel_number(string channel) {
   int next_num;
   next_num = ++_channel_ids[channel];
   save_me();
   return next_num;
}
private void save_me() {
   unguarded( (: save_object(SAVE_FILE) :) );
}
private void load_me() {
   unguarded( (: restore_object(SAVE_FILE, 1) :) );
}
mapping query_dynamic_auto_load() {
   return ([ "channels" : _channels,
       "history" : _channel_history ]);
}
void init_dynamic_arg(mapping arg) {
   _channels = arg["channels"];
   if (!_channels) {
      _channels = ([ ]);
   }
   _channel_history = arg["history"];
   if (!_channel_history) {
      _channel_history = ([ ]);
   }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/options_handler.c ===
#include <cmds/options.h>
#include <cmds/teach.h>
#include <colour.h>
#include <clubs.h>
#include <ls.h>
#include <obj_parser.h>
#include <player.h>
#include <creator.h>
#include <terrain_map.h>
#include <error_handler.h>
class option {
   mixed type;
   int restriction;
   function set;
   function query;
   mapping suboptions;
   string help;
}
private mapping _options;
private string* _colours;
private mapping _cache_input;
protected int add_option(string path, mixed type, int cre_only,
                         function set_function, function query_function,
                         string help);
private int set_player_brief(object player, string variable, int value);
private int query_player_brief(object player, string variable);
private mapping get_inform_colours(object player);
private mapping get_club_colours(object player);
private int change_bool_property(string prop, object player, int new_value);
private int change_earmuffs(object player, string ear, int new_value);
private int setup_earmuffs(object player, string value);
private int valid_birthday(string str);
private string convert_birthday(string birthday);
private int change_error_reports(object player, string ear, int new_value);
void create() {
   string womble;
   _options = ([ ]);
   _cache_input = ([ ]);
   _colours = ({
    "BOLD",
    "FLASH",
    "BLACK",
    "RED",
    "BLUE",
    "CYAN",
    "MAGENTA",
    "ORANGE",
    "YELLOW",
    "GREEN",
    "WHITE",
    "B_RED",
    "B_ORANGE",
    "B_YELLOW",
    "B_BLACK",
    "B_CYAN",
    "B_WHITE",
    "B_GREEN",
    "B_MAGENTA" });
   add_option("output look", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display room descriptions briefly or in full");
   add_option("output combat", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display all combat messages or only those involving damage");
   add_option("output errors", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display errors in the error handler briefly");
   add_option("output score", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Amount of detail to be displayed by the 'score' command");
   add_option("output accent", ({ "mangle", "unadulterated" }),
              OPTIONS_TYPE_ALL,
              (: $1->set_mangle_accent($3 == "mangle"), 1 :),
              (: $1->query_mangle_accent() ? "mangle" : "unadulterated" :),
              "Show others speech with or without regional accents");
   add_option("output names", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display player names with or without title and surname");
   add_option("output htell", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Cause the 'htell' command to display times for tells or not");
   add_option("output msgout", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_msgout($3) :),
              (: $1->query_msgout() :),
              "The message that is displayed when you walk out of a room");
   add_option("output msgin", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_msgin($3) :),
              (: $1->query_msgin() :),
              "The message that is displayed when you walk into a room");
   add_option("output mmsgout", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_mmsgout($3) :),
              (: $1->query_mmsgout() :),
              "The message that is displayed when you trans out of a room");
   add_option("output mmsgin", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_mmsgin($3) :),
              (: $1->query_mmsgin() :),
              "The message that is displayed when you trans into of a room");
   add_option("output usercolour",
              OPTIONS_TYPE_BOOLEAN, 0,
              (: $3?$1->add_property(PLAYER_ALLOW_COLOURED_SOULS, 1):
                    $1->remove_property(PLAYER_ALLOW_COLOURED_SOULS), 1 :),
              (: $1->query_property(PLAYER_ALLOW_COLOURED_SOULS) :),
              "Display user chosen colours in souls");
   add_option("output plainmaps",
              OPTIONS_TYPE_BOOLEAN, 0,
              (: $3?$1->add_property(PLAYER_PLAIN_MAPS, 1):
                    $1->remove_property(PLAYER_PLAIN_MAPS), 1 :),
              (: $1->query_property(PLAYER_PLAIN_MAPS) :),
              "Display terrain maps without colour");
   add_option("output lookmap", OPTIONS_TYPE_BOOLEAN,
              OPTIONS_TYPE_PLAYTESTER_ONLY,
              (: $3?$1->add_property(TERRAIN_MAP_IN_LOOK_PROP, 1):
                    $1->remove_property(TERRAIN_MAP_IN_LOOK_PROP), 1 :),
              (: $1->query_property(TERRAIN_MAP_IN_LOOK_PROP) :),
              "Display room a map in the terrain long or not");
   add_option( "output tabstops", OPTIONS_TYPE_INTEGER, OPTIONS_TYPE_CRE_ONLY,
              (: $1->add_property( TABSTOP_PROP, $3 ) :),
              (: $1->query_property( TABSTOP_PROP ) :),
               "Show tabstops as <TAB> or as spaces");
   add_option( "output shorthand", OPTIONS_TYPE_BOOLEAN, 0,
               (: $1->add_property( SHORTHAND_OUTPUT_PROP, $3 ) :),
               (: $1->query_property( SHORTHAND_OUTPUT_PROP ) :),
               "Convert others shorthand text into long form");
   foreach (womble in USER_COLOUR_LIST) {
      add_option("colour " + womble, OPTIONS_TYPE_COLOUR, 0,
                 (: $1->set_my_colours($2[<1], $3), 1 :),
                 (: $1->colour_event($2[<1], "default") :),
                 "The colour for " + womble + " messages");
   }
   foreach (womble in ADDITIONAL_CHANNELS) {
     add_option("colour " + womble, OPTIONS_TYPE_COLOUR, OPTIONS_TYPE_CRE_ONLY,
                (: $1->set_my_colours($2[<1], $3), 1 :),
                (: $1->colour_event($2[<1], "default") :),
                "The colour for " + womble + " messages");
   }
   foreach (womble in "/secure/master"->query_domains() - NO_CHANNELS) {
     add_option("colour " + womble, OPTIONS_TYPE_COLOUR, OPTIONS_TYPE_CRE_ONLY,
                (: $1->set_my_colours($2[<1], $3), 1 :),
                 (: $1->colour_event($2[<1], "default") :),
                "The colour for " + womble + " messages");
   }
   add_option("colour inform", OPTIONS_TYPE_DYNAMIC_GROUP, 0,
              0, (: get_inform_colours :),
              "The colours of various informational messages");
   add_option("colour club", OPTIONS_TYPE_DYNAMIC_GROUP, 0,
              0, (: get_club_colours :),
              "The colour for club messages");
   add_option("terminal type", OPTIONS_TYPE_TERMINAL, 0,
              (: $1->set_term_type($3), 1 :),
              (: $1->query_term_name() :),
              "The type of terminal you are using");
   add_option("terminal rows", OPTIONS_TYPE_INTEGER, 0,
              (: $1->set_rows($3), 1 :),
              (: $1->query_rows() :),
              "The number of rows in your terminal");
   add_option("terminal cols", OPTIONS_TYPE_INTEGER, 0,
              (: $1->set_cols($3), 1 :),
              (: $1->query_cols() :),
              "The number of coloumns in your terminal");
    add_option("combat wimpy", OPTIONS_TYPE_INTEGER, 0,
              (: $1->set_wimpy($3) :),
              (: $1->query_wimpy() :),
               "The percentage of your hitpoints at which you will run away");
   add_option("combat monitor", MONITOR_OPTIONS, 0,
              (: $1->set_monitor(member_array($3, MONITOR_OPTIONS)), 1 :),
              (: MONITOR_OPTIONS[$1->query_monitor()] :),
              "The frequency of display of your combat monitor");
   add_option("combat tactics attitude",
              ({ "insane", "offensive", "neutral", "defensive", "wimp" }), 0,
              (: $1->set_combat_attitude($3), 1 :),
              (: $1->query_combat_attitude() :),
              "Your combat attitude (see help tactics)");
   add_option("combat tactics response",
              ({ "dodge", "neutral", "parry" }), 0,
              (: $1->set_combat_response($3), 1 :),
              (: $1->query_combat_response() :),
              "Your combat response (see help tactics)");
   add_option("combat tactics parry",
              ({ "left", "right", "both" }), 0,
              (: $1->set_combat_parry($3), 1 :),
              (: $1->query_combat_parry() :),
              "Which hand you will parry with (see help tactics)");
   add_option("combat tactics unarmed_parry",
              OPTIONS_TYPE_BOOLEAN, 0,
              (: $1->set_unarmed_parry($3), 1 :),
              (: $1->query_unarmed_parry() :),
              "Which hand you will parry with (see help tactics)");
   add_option("combat tactics attack",
              ({ "left", "right", "both" }), 0,
              (: $1->set_combat_attack($3), 1 :),
              (: $1->query_combat_attack() :),
              "Which hand you will attack with (see help tactics)");
#ifdef USE_SURRENDER
   add_option("combat tactics mercy",
              ({ "always", "ask", "never" }), 0,
              (: $1->set_combat_mercy($3), 1 :),
              (: $1->query_combat_mercy() :),
              "Whether or not you will show mercy to opponents");
#endif
   add_option("combat tactics focus",
              ({"upper body", "lower body", "head", "neck", "chest",
                  "abdomen", "arms", "hands", "legs", "feet", "none"}), 0,
              (: $1->set_combat_focus($3), 1 :),
              (: $1->query_combat_focus() :),
              "Which body part you will focus on in combat (see help tactics)");
#ifdef USE_DISTANCE
   add_option("combat tactics distance",
              ({"long", "medium", "close", "hand-to-hand", "none" }), 0,
              (: $1->set_combat_distance($3), 1 :),
              (: $1->query_combat_distance() :),
              "Your ideal combat distance (see help tactics)");
#endif
   add_option("combat killer",
              OPTIONS_TYPE_BOOLEAN, 1,
              (: $1->set_player_killer($3) :),
              (: $1->query_player_killer() :),
              "Whether or not you are a registered player killer");
   add_option("input ambiguous", OPTIONS_TYPE_BOOLEAN, 0,
              (: change_bool_property(OBJ_PARSER_AMBIGUOUS_PROP, $1, !$3) :),
              (: !$1->query_property(OBJ_PARSER_AMBIGUOUS_PROP) :),
              "Should the parser notify you of ambiguities");
   add_option("input andascomma", OPTIONS_TYPE_BOOLEAN, 0,
              (: change_bool_property(OBJ_PARSER_USE_AND_AS_BREAK_PROP, $1, !$3) :),
          (: !$1->query_property(OBJ_PARSER_USE_AND_AS_BREAK_PROP) :),
              "Should 'and' be treated as a comma (an inclusive list)");
   add_option("input editor", ({ "menu", "magic", "command", "ed" }), 0,
              (: $1->set_editor($3) :),
              (: $1->query_editor() :),
              "Your preferred editor");
   add_option( "input shorthand", OPTIONS_TYPE_BOOLEAN, 0,
               (: $1->add_property( SHORTHAND_PROP, $3 ) :),
               (: $1->query_property( SHORTHAND_PROP ) :),
               "Convert your shorthand typing into long form");
   foreach (womble in ({ "shout", "newbie", "cryer", "remote-soul",
                           "multiple-soul", "multiple-tell",  "teach",
                           "tell", "remote", "multiple-remote" })) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, 0,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   foreach(womble in ADDITIONAL_CHANNELS) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   foreach(womble in "/secure/master"->query_domains() - NO_CHANNELS) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   foreach(womble in ({ "lord", "intermud-all", "intercre",
                          "intergossip", "dwcre", "dwchat", "remote-spam" })) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   add_option("earmuff state",
              ({ "on", "off", "allowfriends" }), 0,
              (: setup_earmuffs($1, $3) :),
              (: $1->query_earmuffs()? ($1->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF ? "allowfriends" : "on") : "off" :),
              "Enable or disable earmuffs always or just for friends");
   add_option("earmuff cut-through", ({ "off", "ask", "auto"}), 1,
              (: $1->add_property("cut earmuffed tells",
                    member_array($3, ({ "off", "ask", "auto"}))) :),
              (: ({ "off", "ask", "auto" })[$1->query_property(
                                             "cut earmuffed tells")] :),
              "Cut through a players tell earmuffs");
   add_option("command ls use_nickname", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
              (: $3 ? change_bool_property( LS_COMMAND_NICKNAME_PROPERTY, $1, 1 ) : change_bool_property( LS_COMMAND_NICKNAME_PROPERTY, $1, 0 ) :),
              (: $1->query_property( LS_COMMAND_NICKNAME_PROPERTY ) :),
              "Should 'ls' check for nicknames");
   foreach(womble in ERROR_TYPE) {
      womble = lower_case(womble);
      add_option("command look error " + womble, OPTIONS_TYPE_BOOLEAN,
              OPTIONS_TYPE_CRE_ONLY,
              (: change_error_reports($1, $2[<1], $3) :),
              (: member_array(upper_case($2[<1]), ($1->query_property(PLAYER_SHOW_ERRORS_PROP)?$1->query_property(PLAYER_SHOW_ERRORS_PROP):({}))) != -1 :),
              "Show the errors of type " + lower_case(womble) +
              " when doing a look.");
   }
   add_option("personal description", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_desc($3 == "none"?0:$3), 1) :),
              (: (($1->query_desc())?($1->query_desc()):"none") :),
              "Ain't you perdy");
   add_option("personal real_name", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_real_name($3 == "none"?0:$3), 1) :),
              (: (($1->query_real_name())?($1->query_real_name()):"none") :),
              "The real name displayed in your finger information");
   add_option("personal location", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_where($3 == "none"?0:$3), 1) :),
              (: (($1->query_where())?($1->query_where()):"none") :),
              "The location displayed in your finger information");
   add_option("personal home_page", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_homepage($3 == "none"?0:$3), 1) :),
              (: (($1->query_homepage())?($1->query_homepage()):"none") :),
              "The url displayed in your finger information");
   add_option("personal email", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_email($3 == "none"?0:$3), 1) :),
              (: (($1->query_email())?($1->query_email()):"none") :),
              "The email address displayed in your finger information");
   add_option("personal birthday", OPTIONS_TYPE_STRING, 0,
              (: (!valid_birthday($3) || $1->query_birthday())? 0:($1->set_birthday($3 == "none"?0:convert_birthday($3)), 1) :),
              (: (($1->query_birthday())?($1->query_birthday()):"none") :),
              "Your birthday");
   add_option("personal execinclude", OPTIONS_TYPE_STRING, 0,
              (: ($3=="none"?$1->remove_property(OPTION_EXEC_INCLUDE):$1->add_property(OPTION_EXEC_INCLUDE, $3)), 1 :),
              (: ($1->query_property(OPTION_EXEC_INCLUDE)?$1->query_property(OPTION_EXEC_INCLUDE):"none") :),
              "The path of files to be included in exec commands?");
   add_option("personal auto teach", OPTIONS_TYPE_BOOLEAN, 0,
              (: $3?$1->add_property(TEACH_COMMAND_AUTO_PROPERTY,$3):$1->remove_property(TEACH_COMMAND_AUTO_PROPERTY) :),
              (: $1->query_property(TEACH_COMMAND_AUTO_PROPERTY) :),
              "Are you available to auto-teach");
   add_option("personal travel",
              ({ "walk", "journey" }), 0,
              (: $3 == "walk" ?$1->remove_property(TERRAIN_MAP_LONG_JUMP_PROPERTY):$1->add_property(TERRAIN_MAP_LONG_JUMP_PROPERTY,1), 1 :),
              (: $1->query_property(TERRAIN_MAP_LONG_JUMP_PROPERTY)?"journey":"walk" :),
              "By default should you walk or journey across terrains");
   add_option("playtester protection", OPTIONS_TYPE_BOOLEAN,
              OPTIONS_TYPE_PLAYTESTER_ONLY,
              (: $3 ? $1->enable_personal_pt_protection() : $1->disable_personal_pt_protection() :),
              (: $1->query_pt_protection() :),
              "Enable or disable playtester protection");
   add_option("personal roleplaying", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_PLAYTESTER_ONLY,
              (: $1->set_role_playing($3), 1 :),
              (: $1->query_role_playing() :),
              "Enable or disable roleplaying mode");
}
protected void add_option_to_mapping(mapping array, string name, mixed type,
                                     int cre_only, function set_function,
                                     function query_function, string help) {
   class option fluff;
   fluff = new(class option);
   fluff->type = type;
   fluff->set = set_function;
   fluff->query = query_function;
   fluff->restriction = cre_only;
   fluff->suboptions = ([ ]);
   fluff->help = help;
   array[name] = fluff;
}
protected int add_option(string name, mixed type, int cre_only,
                         function set_function, function query_function,
                         string help) {
   string option;
   mapping stuff;
   string *path;
   path = explode(name, " ");
   stuff = _options;
   foreach (option in path[0..<2]) {
      if (!stuff[option]) {
         add_option_to_mapping(stuff, option, OPTIONS_TYPE_GROUP, cre_only,
                               0, 0, help);
      } else if (((class option)stuff[option])->type != OPTIONS_TYPE_GROUP) {
         return 0;
      }
      stuff = stuff[option]->suboptions;
   }
   add_option_to_mapping(stuff, path[<1], type, cre_only, set_function,
                         query_function, help);
   return 1;
}
private mixed query_sub_option(object player, string name, mapping tree) {
   mixed tmp;
   if (mapp(tree[name])) {
      return tree[name];
   }
   if (classp(tree[name])) {
      switch (tree[name]->restriction) {
      case OPTIONS_TYPE_CRE_ONLY:
         if (!player->query_creator()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_LORD_ONLY:
         if (!player->query_lord()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_PLAYTESTER_ONLY:
         if (!player->query_playtester()) {
            return 0;
         }
         break;
      }
      if (((class option)tree[name])->type == OPTIONS_TYPE_DYNAMIC_GROUP) {
         tmp = evaluate(tree[name]->query, player, name);
         return tmp;
      }
      if (((class option)tree[name])->type == OPTIONS_TYPE_GROUP) {
         return tree[name]->suboptions;
      }
      return tree[name];
   }
   return 0;
}
private mixed query_bottom_sub_option(object player, string* path) {
   string option;
   mixed stuff;
   if (!sizeof(path)) {
      return _options;
   }
   stuff = _options;
   foreach (option in path[0..<2]) {
      stuff = query_sub_option(player, option, stuff);
      if (!mapp(stuff)) {
         return 0;
      }
   }
   stuff = query_sub_option(player, path[<1], stuff);
   if (classp(stuff)) {
      switch (stuff->restriction) {
      case OPTIONS_TYPE_CRE_ONLY:
         if (!player->query_creator()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_LORD_ONLY:
         if (!player->query_lord()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_PLAYTESTER_ONLY:
         if (!player->query_playtester()) {
            return 0;
         }
         break;
      }
   }
   return stuff;
}
int is_option(object player, string name) {
   mixed stuff;
   string *path;
   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (!classp(stuff)) {
      return 0;
   }
   return 1;
}
int is_option_group(object player, string name) {
   mixed stuff;
   string *path;
   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (!mapp(stuff)) {
      return 0;
   }
   return 1;
}
string *query_sub_options(object player, string name) {
   mapping stuff;
   string *path;
   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (mapp(stuff)) {
      return filter(keys(stuff),
                    (: query_bottom_sub_option($2, $3 + ({ $1 })) :),
                    player, path);
   }
   return ({ });
}
string* query_option_values(object player, string name) {
   mixed stuff;
   class option opt;
   string *path;
   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (classp(stuff)) {
      opt = stuff;
      if (intp(opt->type)) {
         switch (opt->type) {
         case OPTIONS_TYPE_BOOLEAN :
            return ({ "on", "off" });
         case OPTIONS_TYPE_BRIEF :
            return ({ "brief", "verbose" });
         case OPTIONS_TYPE_INTEGER :
            return ({ "integer" });
         case OPTIONS_TYPE_STRING :
            return ({ "string" });
         case OPTIONS_TYPE_PERCENTAGE :
            return ({ "0..100" });
         case OPTIONS_TYPE_COLOUR :
            return ({ "none", "default", "colour" });
         }
      } else {
         return opt->type;
      }
   }
   return ({ });
}
string query_option_value(object player, string path) {
   string* bits;
   mixed value;
   class option stuff;
   bits = explode(path, " ");
   stuff = query_bottom_sub_option(player, bits);
   if (classp(stuff)) {
      value = evaluate(stuff->query, player, bits);
      if (intp(stuff->type)) {
         switch (stuff->type) {
         case OPTIONS_TYPE_BRIEF:
            if (value) {
               value = "verbose";
            } else {
               value = "brief";
            }
            break;
         case OPTIONS_TYPE_BOOLEAN :
            if (value) {
               value = "on";
            } else {
               value = "off";
            }
            break;
         case OPTIONS_TYPE_COLOUR :
            if (value == "") {
               value = "[none]";
            } else if (value == "default") {
               value = "[default]";
            } else {
               value = "[" + value + "" +
                       lower_case(replace(value, ({ "%^%^", " ", "%^", "" }))) +
                       "%^RESET%^]";
            }
            break;
         default :
         }
      }
      return value + "";
   }
}
string query_option_help(object player, string path) {
  string *bits;
  mixed stuff;
  bits = explode(path, " ");
  stuff = query_bottom_sub_option(player, bits);
  if (classp(stuff)) {
    return copy(stuff->help);
  }
  return "";
}
int set_option_value(object player, string path, string value) {
   string* bits;
   string* bad;
   mixed set_value;
   class option stuff;
   bits = explode(path, " ");
   stuff = query_bottom_sub_option(player, bits);
   if (classp(stuff)) {
      if (pointerp(stuff->type)) {
         if (member_array(value, stuff->type) == -1) {
            add_failed_mess("You must set your type to one of " +
                            query_multiple_short(stuff->type) + ".\n");
            return 0;
         }
         set_value = value;
      } else switch (stuff->type) {
      case OPTIONS_TYPE_BRIEF:
         if (value == "verbose") {
            set_value = 1;
         } else if (value == "brief") {
            set_value = 0;
         } else {
            return 0;
         }
         break;
      case OPTIONS_TYPE_BOOLEAN :
         if (value == "on" || value == "true") {
            set_value = 1;
         } else if (value == "off" || value == "false") {
            set_value = 0;
         } else {
            return 0;
         }
         break;
      case OPTIONS_TYPE_PERCENTAGE :
      case OPTIONS_TYPE_INTEGER :
         if (sscanf(value, "%d", set_value) != 1) {
            return 0;
         }
         if (stuff->type == OPTIONS_TYPE_PERCENTAGE &&
             (set_value < 0 || set_value > 100)) {
            add_failed_mess("Value must be between 0 and 100.\n");
            return 0;
         }
         break;
      case OPTIONS_TYPE_COLOUR :
         if (value == "none" || value == "default") {
            set_value = value;
         } else {
            set_value = map(explode(value, " "),
                         (: upper_case($1) :));
            bad = filter(set_value, (: member_array($1, _colours) == -1 :));
            if (sizeof(bad)) {
               add_failed_mess("Bad colours " + implode(bad, " ") + ".\n");
               return 0;
            }
            set_value = "%^" + implode(set_value, (: $1 + "%^ %^" + $2 :)) + "%^";
         }
         break;
      default :
         set_value = value;
         break;
      }
      return evaluate(stuff->set, player, bits, set_value);
   }
   return 0;
}
private mapping get_inform_colours(object player) {
   string* colours;
   string womble;
   mapping ret;
   string index;
   if (player->query_creator()) {
      index = "colour 1";
   } else if (player->query_lord()) {
      index = "colour 2";
   } else {
      index = "colour 0";
   }
   if (_cache_input[index]) {
      return _cache_input[index];
   }
   colours = player->query_inform_types();
   ret = ([ ]);
   foreach (womble in colours) {
      add_option_to_mapping(ret, womble, OPTIONS_TYPE_COLOUR, 0,
                            (: $1->set_my_colours($2[<1], $3), 1 :),
                            (: $1->colour_event($2[<1], "default") :),
                            "The colour of " + womble + " informs");
   }
   _cache_input[index] = ret;
   return ret;
}
private mapping get_club_colours(object player) {
   string* colours;
   string womble;
   mapping ret;
   string index;
   index = "colour " + player->query_name();
   if (_cache_input[index]) {
      return _cache_input[index];
   }
   colours = map(this_player()->query_player_clubs(),
                 (: CLUB_HANDLER->normalise_name($1) :) );
   ret = ([ ]);
   foreach (womble in colours) {
      add_option_to_mapping(ret, womble, OPTIONS_TYPE_COLOUR, 0,
                            (: $1->set_my_colours("club_" + $2[<1], $3), 1 :),
                            (: $1->colour_event("club_" + $2[<1], "default") :),
                            "The colour for " + womble + " club messages");
   }
   _cache_input[index] = ret;
   call_out((: map_delete(_cache_input, $1) :), 5 * 60, index);
   return ret;
}
private int change_bool_property(string prop, object player, int new_value) {
   if (new_value) {
      player->add_property(prop, 1);
   } else {
      player->remove_property(prop);
   }
   return 1;
}
private int setup_earmuffs(object player, string ear) {
   switch (ear) {
   case "on" :
      if (!player->query_earmuffs()) {
         player->toggle_earmuffs();
      } else if (player->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF) {
         player->toggle_earmuffs();
         player->toggle_earmuffs();
      }
      break;
   case "off" :
      if (player->query_earmuffs()) {
         player->toggle_earmuffs();
      }
      break;
   case "allowfriends" :
      player->set_allow_friends_earmuffs();
      break;
   }
   return 1;
}
private int change_error_reports(object player, string error, int new_value) {
   string *on;
   on = player->query_property(PLAYER_SHOW_ERRORS_PROP);
   if (!on) {
      on = ({ });
   }
   error = upper_case(error);
   if (new_value) {
      if (member_array(error, on) == -1) {
         on += ({ error });
         player->add_property(PLAYER_SHOW_ERRORS_PROP, on);
      }
   } else {
      on -= ({ error });
      player->add_property(PLAYER_SHOW_ERRORS_PROP, on);
   }
   return 1;
}
private int change_earmuffs(object player, string ear, int new_value) {
   string *on;
   on = player->query_property("earmuffs");
   if (!on) {
      on = ({ });
   }
   if (new_value) {
      if (member_array(ear, on) == -1) {
         on += ({ ear });
         player->add_property("earmuffs", on);
      }
   } else {
      on -= ({ ear });
      player->add_property("earmuffs", on);
   }
   return 1;
}
private int valid_birthday(string str) {
#define LENGTHS ({ 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 })
  int tot, month, day;
  if(strlen(str) != 4) {
    return 0;
  }
  if(!sscanf(str, "%d", tot)) {
    return 0;
  }
  month = tot % 100;
  day = tot / 100;
  if(month > 12 || month < 1) {
    return 0;
  }
  if(day < 1) {
    return 0;
  }
  return day <= LENGTHS[month];
}
string convert_birthday(string str) {
#undef MONTHS
#define MONTHS ({ "January", "February", "March", "April", "May", "June", \
      "July", "August", "September", "October", "November", "December" })
  int day, month, tot;
  string retval;
  sscanf(str, "%d", tot);
  day = tot / 100;
  month = tot % 100;
  switch(day) {
    case 11:
      retval = "11th"; break;
    case 12:
      retval = "12th"; break;
    case 13:
      retval = "13th"; break;
    default:
      switch(day%10) {
        case 1:
          retval = day+"st"; break;
        case 2:
          retval = day+"nd"; break;
        case 3:
          retval = day+"rd"; break;
        default:
          retval = day+"th";
      }
  }
  return retval + " of " + MONTHS[month-1];
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/room_rental.c ===
#include <money.h>
#include <room/room_rental.h>
protected void do_load();
protected void do_save();
protected void evict_tenant( object room_ob );
private nosave int loaded = 0;
private mapping rented_rooms = ([]);
private mapping rental = ([]);
private mapping eviction_times = ([]);
private mapping locations = ([]);
private mapping paths = ([]);
void create() {
  do_load();
}
void reset() {
   string room;
   int now = time();
   foreach( room in keys( rented_rooms ) ) {
      if ( stringp( rented_rooms[ room ] ) ) {
         if ( ( eviction_times[ room ] < now ) &&
              ( eviction_times[ room ] > -1 ) ) {
            evict_tenant( find_object( room ) );
            tell_creator( "goldenthread", "RENTAL: %s no longer rents %s\n",
                          rented_rooms[ room ], room );
            rented_rooms[ room ] = 0;
            eviction_times[ room ] = -1;
         }
      }
   }
   do_save();
}
protected void do_load() {
   if ( !loaded )
      unguarded( (: restore_object( ROOM_RENTAL_SAVE_FILE, 1 ) :) );
   loaded = 1;
}
protected void do_save() {
   unguarded( (: save_object( ROOM_RENTAL_SAVE_FILE , 0 ) :) );
}
void evict_tenant( object room_ob ) {
   object *occupants;
   occupants = filter( all_inventory( room_ob ), (: living :) );
   room_ob->evict_tenant( occupants );
}
int add_room( string room, int cost, object office ) {
   object room_ob;
   if( !room_ob = load_object( room ) )
      return 0;
   rented_rooms[ room ] = 0;
   rental[ room ] = cost;
   eviction_times[ room ] = -1;
   locations[ room ] = office->query_location();
   paths[ room_ob->short() ] = room;
   do_save();
   return 1;
}
string query_who_rents( string room, object office ) {
   if ( locations[room] == office->query_location() ) {
      if ( stringp( rented_rooms[room] ) )
         return rented_rooms[room];
      else
         return "nobody";
   } else
      return "no such room in this location";
}
int check_tenant( object player_ob, object room_ob, object office ) {
   string player = player_ob->short();
   string room = room_ob->short();
   if ( player == query_who_rents( room, office ) )
      return RENTAL_SUCCESS;
   else if ( player == "nobody" )
      return RENTAL_AVAILABLE;
   else if ( player == "no such room!" )
      return RENTAL_NO_SUCH_ROOM;
   else
      return RENTAL_ALREADY_RENTED;
}
int delete_room( string room, object office ) {
  string room_short = load_object( room )->short();
  if ( locations[room] == office->query_location() ) {
    map_delete( rented_rooms, room );
    map_delete( rental, room );
    map_delete( eviction_times, room );
    map_delete( locations, room );
    map_delete( paths, room_short );
    do_save();
    return 1;
  } else
    return 0;
}
int clear_rooms( object office ) {
   object room_ob;
   foreach( string room in keys( filter( locations,
            (: $2 == $( office->query_location() ) :) ) ) ) {
      room_ob = load_object( room );
    map_delete( rented_rooms, room );
    map_delete( rental, room );
    map_delete( eviction_times, room );
    map_delete( locations, room );
    map_delete( paths, room_ob->query_short() );
  }
  do_save();
  return 1;
}
string *query_rooms_to_rent( object office ) {
  return keys( filter( locations,
               (: $2 == $( office->query_location() ) :) ) );
}
int do_rental( object player_ob, string room_short, object office ) {
   int result;
   string domain = office->query_domain();
   string room = paths[ room_short ];
   if ( locations[room] == office->query_location() ) {
      if ( !rented_rooms[room] ||
           ( rented_rooms[room] == player_ob->short()) ) {
         if ( (int)player_ob->query_value_in( domain ) < rental[room] )
            return RENTAL_NO_MONEY;
         rented_rooms[room] = player_ob->short();
         eviction_times[room] = time() + ONE_DAY;
         result = RENTAL_SUCCESS;
      } else
         result = RENTAL_ALREADY_RENTED;
   } else
      result = RENTAL_NO_SUCH_ROOM;
   do_save();
   return result;
}
int query_rental_value( string room ) {
   return rental[ room ];
}
int remove_rental( object room_ob ) {
   int result;
   string room_short = room_ob->short();
   string room = paths[ room_short ];
   if ( !undefinedp( rented_rooms[room] ) ) {
      rented_rooms[room] = 0;
      result = RENTAL_SUCCESS;
   } else
      result = RENTAL_NO_SUCH_ROOM;
   do_save();
   return result;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/twiki.c ===
#include <board.h>
void do_check_changes();
#define SAVE_FILE "/save/twiki"
#define CHECK_TIME (7 * 24 * 60 * 60)
#define TWIKI_CHANGE_FILE "/.changes"
#define TWIKI_DATA_DIRECTORY "/twiki/data/"
private nosave string* _databases;
private int _last_check;
private mapping _last_change;
void create() {
   _databases = ({ "Main", "Am", "Ram", "Cwc", "Sur", "Klatch",
                   "Forn", "Underworld", "Other", "Playtesters" });
   seteuid(getuid());
   restore_object(SAVE_FILE);
   if (_last_check + CHECK_TIME < time()) {
      do_check_changes();
   }
   call_out("do_check_changes", _last_check + CHECK_TIME - time());
   if (!_last_change) {
      _last_change = ([ ]);
   }
   call_out("do_change_inform", 60 * 5);
}
mapping find_changed_pages(int limit, string database) {
   string* lines;
   int i;
   int tim;
   string page;
   string author;
   mixed* bits;
   mapping changes_pages;
   lines = explode(read_file(TWIKI_DATA_DIRECTORY + database + TWIKI_CHANGE_FILE), "\n");
   changes_pages = ([ ]);
   for (i = 1; i < sizeof(lines); i++) {
      bits = reg_assoc(lines[<i], ({ "([a-zA-Z][a-zA-Z0-9]+)", "[0-9]+" }), ({ 1, 2 }) );
      if (sizeof(bits[0]) == 9 || sizeof(bits[0]) == 7) {
         page = bits[0][1];
         author = bits[0][3];
         sscanf(bits[0][5], "%d", tim);
         if (tim > limit) {
            if (page[0..4] != "TWiki" &&
                page[0..9] != "Underworld" &&
                author != "PeterThoeny" &&
                page != author &&
                page != "WebPreferences") {
               if (file_size("/twiki/data/" + database + "/" + page + ".txt") > 0 &&
                   strsrch(read_file("/twiki/data/" + database + "/" + page + ".txt"),
                           "\t* Login Name:") == -1) {
                  if (!changes_pages[page]) {
                     changes_pages[page] = ({ });
                  }
                  if (member_array(author, changes_pages[page]) == -1) {
                     changes_pages[page] += ({ author });
                  }
               }
            }
         } else {
            break;
         }
      } else {
         break;
      }
   }
   return changes_pages;
}
string find_changes(int limit) {
   mapping changes_pages;
   string ret;
   string page;
   string database;
   ret = "Changes since " + ctime(limit) + " in\n"
         "http:
   foreach (database in _databases) {
      changes_pages = find_changed_pages(limit, database);
      foreach (page in sort_array(keys(changes_pages), 1)) {
         ret += sprintf("%-30s changed by %s\n", database + "." + page,
                         query_multiple_short(changes_pages[page]));
      }
   }
   return ret;
}
string find_changes_in_database(string database, int limit) {
   mapping changes_pages;
   string ret;
   string page;
   if (database == "Playtesters") {
      ret = "Changes since " + ctime(limit) + " in\n"
         "http:
   } else {
      ret = "Changes since " + ctime(limit) + " in\n"
         "http:
   }
   changes_pages = find_changed_pages(limit, database);
   foreach (page in sort_array(keys(changes_pages), 1)) {
      ret += sprintf("%-30s changed by %s\n", database + "." + page,
                      query_multiple_short(changes_pages[page]));
   }
   return ret;
}
string query_file(string fname) {
   if (strsrch(fname, ".") > 0) {
      fname = "/twiki/data/" + replace_string(fname, ".", "/") + ".txt";
   } else {
      fname = "/twiki/data/Main/" + fname + ".txt";
   }
   if (sizeof(stat(fname))) {
      return read_file(fname);
   }
   return 0;
}
void do_check_changes() {
   string changes;
   changes = find_changes(_last_check);
   BOARD_HAND->add_message("commonroom", "Twiki Database",
                           "Changes in the Twiki database",
                           changes);
   _last_check = time();
   save_object(SAVE_FILE);
   call_out("do_check_changes", _last_check + CHECK_TIME - time());
}
void do_change_inform() {
   int changed;
   mapping changed_pages;
   string page;
   string* changers;
   int dosave;
   string database;
   if (!mapp(_last_change)) {
      _last_change = ([ ]);
   }
   foreach (database in _databases) {
      if (!_last_change[database]) {
         _last_change[database] = time();
         dosave = 1;
      } else {
         changed = stat(TWIKI_DATA_DIRECTORY + database + TWIKI_CHANGE_FILE)[1];
         if (changed != _last_change[database]) {
            changed_pages = find_changed_pages(_last_change[database], database);
            _last_change[database] = changed;
            dosave = 1;
            foreach (page, changers in changed_pages) {
               user_event( "inform",
                           sprintf( "%s changes the twiki page %s.%s",
                                    query_multiple_short(changers), database,
                                    page),
                           "message",
                           this_player() );
            }
         }
      }
   }
   if (dosave) {
      save_object(SAVE_FILE);
   }
   call_out("do_change_inform", 60 * 5);
}
