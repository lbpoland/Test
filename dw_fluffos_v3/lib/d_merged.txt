
==================================================
FILE: learning/common.c
==================================================

#include <config.h>
#include "path.h"
inherit "/std/room/basic_room";
#define HANDLER (LEARNING +"handlers/request")
object board;
object *chairs;
int do_claim(int);
int do_remove(int);
int do_request(string, string);
int do_sit( string command, object *indir, string dir_match,
           string indir_match, mixed *args, string pattern );
void setup() {
   set_light( 100 );
   set_short( "somewhat boring commonroom of the learning domain" );
   add_property( "determinate", "the " );
   set_long( "This is the common room of the domain of learning, the place "
            "where creators come to learn.  It is a somewhat boring room "
            "except for some chairs strewn around the place which happen to "
            "be an example of having commands defined in add_items, and some "
            "sort of list hanging on the wall which is an example of using "
            "add_command in rooms.\n" );
   add_item( "chair", ({
      "long", "This chair looks comfortable, perhaps you can sit in it.",
      "sit", ({ (: do_sit :), "[in] <direct:object>" })
   }), 1 );
   add_item( "chairs", ({
      "long", "These chairs look comfortable, "
              "perhaps you can sit in one of them.",
      "sit", ({ (: do_sit :),  "[in] <direct:object>" })
   }), 1 );
   add_item( "list",
            "This list has several actions associated with it:\n"
            "\"show list\" will show the current requests.\n"
            "\"request documentation\" will ask for "
            "documentation on something.\n"
            "\"request example\" will ask for an example of "
            "something to be coded.\n"
            "\"claim <number>\" is use to claim a request, thereby attempting "
            "to make sure that only one creator is writing the documentation/"
            "coding the examples." );
   add_exit( "entrance", PATH +"main", "path" );
   add_exit( "drum", CONFIG_START_LOCATION, "path" );
   chairs = ({ });
   add_extra_look( this_object() );
   add_property( "commented functions", ({ "add_extra_look", "extra_look",
      "remove_extra_look", "add_command" }) );
   add_property( "keywords", ({ "room", "add_item", "action" }) );
   board = clone_object( "/obj/misc/board" );
   board->set_datafile( DOMAIN );
   board->move( this_object() );
}
void init() {
   ::init();
   add_command( "show", "list" );
   add_command( "claim", "<number>", (:do_claim( $4[0] ):) );
   add_command( "request", "{documentation|example} <string'subject'>",
                (:do_request( $4[0], $4[1] ):));
   add_command( "remove", "<number>", (:do_remove( $4[0] ):) );
}
int do_show() {
   write( HANDLER->query_list() );
   return 1;
}
int do_claim( int i ) {
  if ( HANDLER->claim_request( this_player()->query_name(), i ) ) {
    add_succeeded_mess("$N $V a request.\n", ({}));
  } else {
    return notify_fail( "Illegal request number.\n" );
  }
  return 1;
}
int do_remove( int i ) {
  if ( HANDLER->remove_request( this_player()->query_name(), i ) ) {
    add_succeeded_mess("$N $V a request.\n", ({}));
  } else {
    return notify_fail( "You can't remove that request.\n" );
  }
  return 1;
}
int do_request( string option, string words ) {
  if ( option == "documentation" ){
      HANDLER->add_request( this_player()->query_name(),
                           "documentation for "+ words );
      write( "You request some documentation.\n");
      say( this_player()->the_short() +" requests some documentation.\n");
      return 1;
   }
  if ( option == "example") {
      HANDLER->add_request( this_player()->query_name(),
                           "examples of "+ words );
      write( "You request some example.\n");
      say( this_player()->the_short() +" requests some example.\n");
      return 1;
   }
   return 0;
}
int do_sit( string command, object *indir, string dir_match,
           string indir_match, mixed *args, string pattern ) {
   if ( dir_match == "chairs" ) {
      this_player()->add_succeeded_mess( previous_object(),
             "How can you sit on more than one chair at the same time?\n",
             ({ }) );
      return 1;
   }
   if ( member_array( this_player(), chairs ) != -1 ) {
      this_player()->add_succeeded_mess( previous_object(),
             "You are already sitting in a chair.\n", ({ }) );
      return 1;
   }
   chairs += ({ this_player() });
   this_player()->add_extra_look( this_object() );
   this_player()->add_succeeded_mess( previous_object(),
           "$N $V in a "+ dir_match +".\n", ({ }) );
   return 1;
}
string extra_look( object thing ) {
   if ( thing == this_object() ) {
      chairs = filter_array( chairs, (: $1 != 0 :) );
      chairs = filter_array( chairs,
                            (: environment( $1 ) == this_object() :) );
      if ( !sizeof( chairs ) ) {
         return "";
      } else {
         if ( sizeof( chairs ) == 1 ) {
            if ( chairs[ 0 ] == this_player() ) {
               return "You are sitting in one of the chairs.\n";
            } else {
               return (string)chairs[ 0 ]->the_short()
                      +" is sitting in one of the chairs.\n";
            }
         } else {
            return query_multiple_short( chairs, "the" )
              +" are sitting in the chairs.\n";
         }
      }
   } else if ( member_array( thing, chairs ) != -1 ) {
      if ( environment( thing ) == this_object() ) {
         if ( thing == this_player() ) {
            return "You are sitting in a chair looking lazy.\n";
         } else {
            return thing->query_pronoun() +" is lazing around in a chair.\n";
         }
      }
   }
   thing->remove_extra_look( this_object() );
   return "";
}

==================================================
FILE: learning/function_room.c
==================================================

#include "path.h"
#include <map.h>
inherit "/std/room/basic_room";
string function_chosen;
void setup() {
   set_short( "uninitialised search room for functions" );
   set_long( "You are in an uninitialized search room.  "
            "This is an example of a room that gets cloned and configured "
            "afterwards.  In this room, it's the function set_marker that's "
            "used to define its look, and most if the exits as well.  And "
            "the function set_destination that is used to find, possibly "
            "clone and configure, the rooms that fit the keywords you search "
            "for.  The handler called SEARCH in the code, is \""+
            SEARCH +"\" and the one called QUIT_HANDLER, is \""+
            QUIT_HANDLER +"\".\n" );
   add_property( "no map", 1 );
   set_light( 50 );
   add_exit( "exit", PATH +"functions", "path" );
   add_property( "commented functions",
                ({ "set_destination", "query_quit_handler",
                   "query_cloning_info" }) );
   add_property( "keywords", ({ "room", "virtual" }) );
}
string query_marker() {
   return function_chosen;
}
void set_marker( string word ) {
   string description, exit_letter, exit_room, exit;
   set_short( "\""+ word +"\" search room" );
   add_property( "determinate", "the " );
   function_chosen = word;
   description = "You have chosen to see the rooms describing the use of the "
         "function "+ function_chosen +".";
   description += "$I$5=Take one of the lettered exits to go to that room.";
   exit_letter = "a";
   foreach( exit_room in (string *)SEARCH->query_rooms_with_function( word ) ) {
      exit = sprintf( "%s: %s",
                     exit_letter,
                     (string)MAP->query_short( exit_room ) );
      add_exit( exit_letter, exit_room, "path" );
      description += "\n$C$"+ exit +".";
      exit_letter[ 0 ]++;
   }
   description += "$I$0=\n";
   set_long( description );
}
void check_empty() {
   if ( sizeof( all_inventory( this_object() ) ) )
      return;
   dest_me();
}
string query_quit_handler() { return QUIT_HANDLER; }
mixed *query_cloning_info() {
   return ({ SEARCH, "find_function_room", function_chosen });
}
void event_exit( object thing, string mess, object to ) {
   string handler;
   if ( find_call_out( "check_empty" ) == -1 )
      call_out( "check_empty", 10 );
   if ( file_name( to ) == "/room/departures" )
      return;
   handler = query_quit_handler();
   if ( (string)to->query_quit_handler() != handler )
      handler->remove_from_list( thing );
}

==================================================
FILE: learning/functions.c
==================================================

#include "path.h"
#include <learning.h>
#define PATH LEARNING
inherit "/std/room/basic_room";
string *functions;
int do_list();
int word();
void setup() {
   string word;
   set_short( "room of function examples" );
   add_property( "determinate", "the " );
   set_long( "This is the room that might lead you to better understanding "
            "of how to use some of the functions we have here.\n"
            "Try \"list functions\" to get a list of the functions known by "
            "the room, "
            "take the exit named by the function to get to a room with exits "
            "to the examples.\n"
            "If you have something you'd like to see here, "
            "mail "+ CURRENT_LORD +" and suggest it.\n" );
   set_light( 50 );
   functions = SEARCH->query_functions();
   foreach( word in functions ) {
      add_exit( word, "??", "path" );
      modify_exit( word, ({ "obvious", 0 }) );
   }
   add_exit( "exit", ENTRANCE, "door" );
   add_property( "commented functions",
                ({ "set_long", "set_short", "add_property", "set_light" }) );
   add_property( "keywords", ({ }) );
}
void init() {
  ::init();
  add_command( "list","functions");
}
int do_list() {
   write( sprintf( "The following functions have examples of use:\n%#-*s\n",
                  75, implode( functions, "\n" ) ) );
   return 1;
}
void set_destination( string word ) {
   if( word != "exit" ) {
      modify_exit( word, ({ "dest", SEARCH->find_function_room( word ) }) );
   }
}

==================================================
FILE: learning/main.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
void setup() {
   set_short( "entrance to learning" );
   add_property( "determinate", "the " );
   set_long( "Welcome to the entrance room of the learning domain.  "
            "The purpose of this domain is to help beginning creators, by "
            "giving examples of the way to use the different functions that "
            "are available, and show ways to solve common problems.\n"
            "To see the code used in a room or an object you can use the "
            "commands \"more here\" and \"more <object name>\" "
            "respectively.  If you have something you'd like to see here, "
            "mail "+ CURRENT_LORD +" and suggest it.\n"
            "The search exit will take you to a special room with exits "
            "for each of the keywords defined in the different files in the "
            "domain, this will enable you to search for examples by "
            "selecting keywords, and is also an example of the use of "
            "virtual or cloned rooms.\n"
            "If you want to find examples of how to use specific functions, "
            "use the functions exit.\n"
            );
   set_light( 50 );
   set_co_ord( ({ 30, 0, 40 }) );
   add_exit( "search", PATH + "search", "door" );
   add_exit( "functions", PATH + "functions", "door" );
   add_exit( "common", "/w/common", "door" );
   "/w/common"->add_exit( "learning", ENTRANCE, "door" );
   add_property( "commented functions",
                ({ "set_long", "set_short", "add_property", "set_light",
                   "add_exit" }) );
   add_property( "keywords", ({ "room" }) );
}

==================================================
FILE: learning/master.c
==================================================

#define LORD "taffyd"
#define DOMAIN "learning"
inherit "/std/dom/base_master";
string info = "";
string query_lord() {
  return LORD;
}
string author_file(string *path) {
  return capitalize(DOMAIN);
}
int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}
int copy_with_read(string path, string euid, string func) {
  return 1;
}
int add_member(string name) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::add_member(name);
}
int remove_member(string name) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::remove_member(name);
}
int set_project(string name, string pro) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::set_project(name, pro);
}
int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
}
string log_who(string where) {
   return LORD;
}
void set_info( string words ) {
  info = words;
  save_me();
}
string query_info() {
  return info;
}

==================================================
FILE: learning/path.h
==================================================

#include <learning.h>
#define PATH LEARNING

==================================================
FILE: learning/search.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
string *keywords;
void setup() {
   mixed search_result;
   string word;
   set_short( "primary search room" );
   add_property( "determinate", "the " );
   set_long( "Welcome to the first room for doing keyword searches.  "
            "Take an exit to narrow the search to that keyword.  If less than "
            "five rooms or objects fit the keywords there will also be exits "
            "directly to them.\n" );
   set_light( 50 );
   search_result = SEARCH->get_keywords( ({ }) );
   keywords = search_result[ 0 ];
   foreach( word in keywords ) {
      add_exit( word, "??", "path" );
   }
   add_exit( "exit", ENTRANCE, "door" );
   add_property( "commented functions",
                ({ "add_exit", "set_destination" }) );
   add_property( "keywords", ({ "virtual", "room" }) );
   add_property( "no map", 1 );
}
void set_destination( string keyword ) {
   if( member_array( keyword, ({ "exit", "back", "a", "b", "c", "d", "e" }) ) != -1 )
      return;
   modify_exit( keyword, ({ "dest", SEARCH->find_room( ({ keyword }) ) }) );
}

==================================================
FILE: learning/search_room.c
==================================================

#include "path.h"
#include <map.h>
inherit "/std/room/basic_room";
string marker, *keywords, *exits;
void setup() {
   set_short( "uninitialised search room" );
   set_long( "You are in an uninitialized search room.  "
            "This is an example of a room that gets cloned and configured "
            "afterwards.  In this room, it's the function set_marker that's "
            "used to define its look, and most if the exits as well.  And "
            "the function set_destination that is used to find, possibly "
            "clone and configure, the rooms that fit the keywords you search "
            "for.  The handler called SEARCH in the code, is \""+
            SEARCH +"\" and the one called QUIT_HANDLER, is \""+
            QUIT_HANDLER +"\".\n" );
   add_property( "no map", 1 );
   set_light( 50 );
   add_exit( "exit", LEARNING +"search", "path" );
   add_property( "commented functions",
                ({ "set_destination", "query_quit_handler",
                   "query_cloning_info" }) );
   add_property( "keywords", ({ "room", "virtual" }) );
}
string query_marker() {
   return marker;
}
string *query_keywords() {
   if( !keywords ) {
      return ({ });
   }
   return keywords;
}
void set_marker( string word, string *words ) {
   mixed search_result;
   string description, exit;
   int i;
   set_short( "\""+ word +"\" search room" );
   add_property( "determinate", "the " );
   marker = word;
   keywords = words;
   description ="You are in one of the search rooms of the learning domain "
                "and you have chosen the word"+
                ({ " \"", "s \"" })[ sizeof( words ) > 1 ] + word +"\" so far.";
   search_result = SEARCH->get_keywords( words );
   exits = search_result[ 0 ];
   if( sizeof( exits ) ) {
      description += "  Take one of the keyword exits to narrow the search to "
                     "include that keyword.";
      foreach( word in exits ) {
         add_exit( word, "/??", "path" );
      }
   }
   description += "\n";
   if( sizeof( search_result[ 1 ] ) < 6 ) {
      description += "$I$5=Take one of the numbered exits to go to that room.";
      for( i = 0; i < sizeof( search_result[ 1 ] ); i++ ) {
         exit = sprintf( "%s: %s", ({ "1", "2", "3", "4", "5" })[ i ],
                        MAP->query_short( search_result[ 1 ][ i ] ) );
         add_exit( ({ "1", "2", "3", "4", "5" })[ i ],
                  search_result[ 1 ][ i ], "path" );
         description += "\n$C$"+ exit +".";
      }
      description += "$I$0=\n";
   }
   set_long( description );
}
void set_destination( string keyword ) {
   if( member_array( keyword, exits ) != -1 ) {
      modify_exit( keyword, ({ "dest",
         SEARCH->find_room( keywords + ({ keyword }) ) }) );
   }
   if ( find_call_out( "check_empty" ) == -1 )
      call_out( "check_empty", 10 );
}
void check_empty() {
   if ( sizeof( all_inventory( this_object() ) ) )
      return;
   dest_me();
}
string query_quit_handler() { return QUIT_HANDLER; }
mixed *query_cloning_info() {
   return ({ SEARCH, "find_room", keywords });
}
void event_exit( object thing, string mess, object to ) {
   string handler;
   if ( file_name( to ) == "/room/departures" )
      return;
   handler = query_quit_handler();
   if ( (string)to->query_quit_handler() != handler )
      handler->remove_from_list( thing );
}

==================================================
FILE: learning/help_topics/error_messages/arg_missing_type.c
==================================================

void bing(int) {
}

==================================================
FILE: learning/help_topics/error_messages/arr_index.c
==================================================

void bing() {
    ({ })[1];
}

==================================================
FILE: learning/help_topics/error_messages/bad_break.c
==================================================

void bing() {
    break;
}

==================================================
FILE: learning/help_topics/error_messages/bad_continue.c
==================================================

void bing() {
    continue;
}

==================================================
FILE: learning/help_topics/error_messages/bad_for_init.c
==================================================

void bing() {
    for (int x += 1; ; ) ;
}

==================================================
FILE: learning/help_topics/error_messages/bad_foreach.c
==================================================

void bing() {
    foreach (x in ({})) ;
}

==================================================
FILE: learning/help_topics/error_messages/bad_init.c
==================================================

int x += 1;

==================================================
FILE: learning/help_topics/error_messages/bad_local_init.c
==================================================

void bing() {
    int x += 1;
}

==================================================
FILE: learning/help_topics/error_messages/bad_local_init2.c
==================================================

void bing() {
    int x = "hi";
}

==================================================
FILE: learning/help_topics/error_messages/bad_param.c
==================================================

void bing() {
    (: $-1 :);
}

==================================================
FILE: learning/help_topics/error_messages/bad_param2.c
==================================================

void bing() {
    (: $1000 :);
}

==================================================
FILE: learning/help_topics/error_messages/bad_return.c
==================================================

void bing() {
    return 1;
}

==================================================
FILE: learning/help_topics/error_messages/bad_return2.c
==================================================

int bing() {
    return "hi";
}

==================================================
FILE: learning/help_topics/error_messages/bad_type_init.c
==================================================

int x = "hi";

==================================================
FILE: learning/help_topics/error_messages/class_redef.c
==================================================

class bing {
}
class bing {
}

==================================================
FILE: learning/help_topics/error_messages/div_zero.c
==================================================

void bing(mixed x) {
    switch(x) {
    case 1 / 0:
    }
}

==================================================
FILE: learning/help_topics/error_messages/div_zero3.c
==================================================

int bing() {
    return 1/0.0;
}

==================================================
FILE: learning/help_topics/error_messages/eof_in_comment.c
==================================================

/* Comments have to stop as well as start

==================================================
FILE: learning/help_topics/error_messages/eof_in_string.c
==================================================

void create() {
    "
}

==================================================
FILE: learning/help_topics/error_messages/local_redef.c
==================================================

void bing(int x) {
    int x;
}

==================================================
FILE: learning/help_topics/error_messages/local_redef2.c
==================================================

void bing() {
    int x;
    {
	int x;
    }
}

==================================================
FILE: learning/help_topics/error_messages/lvar_func.c
==================================================

void bing() {
    int x;
    (: x :);
}

==================================================
FILE: learning/help_topics/error_messages/lvar_func2.c
==================================================

void bing() {
    int x;
    (: x + 1 :);
}

==================================================
FILE: learning/help_topics/error_messages/missing_arg_type.c
==================================================

void bing(x) {
}

==================================================
FILE: learning/help_topics/error_messages/missing_endif.c
==================================================

#if 1

==================================================
FILE: learning/help_topics/error_messages/missing_type.c
==================================================

bing;

==================================================
FILE: learning/help_topics/error_messages/mixed_case.c
==================================================

void bing(mixed x) {
    switch (x) {
    case 1:
    case "hi":
    }
}

==================================================
FILE: learning/help_topics/error_messages/mod_zero.c
==================================================

void bing(mixed x) {
    switch(x) {
    case 1 % 0:
    }
}

==================================================
FILE: learning/help_topics/error_messages/no_member.c
==================================================

class bing {
    int x;
}
void bing() {
    bing y;
    y->z;
}

==================================================
FILE: learning/help_topics/error_messages/no_ret_type.c
==================================================

#pragma strict_types
bing() {
}

==================================================
FILE: learning/help_topics/error_messages/no_such_class.c
==================================================

void bing() {
    new(class bing);
}

==================================================
FILE: learning/help_topics/error_messages/predef.c
==================================================

#undef __VERSION__

==================================================
FILE: learning/help_topics/error_messages/redef_function.c
==================================================

void bing() {
}
void bing() {
}

==================================================
FILE: learning/help_topics/error_messages/static_local.c
==================================================

void main() {
    nosave int x = 5;
}

==================================================
FILE: learning/help_topics/error_messages/string_case.c
==================================================

void bing() {
    switch ("hi") {
    case "bing".."bar":
    }
}

==================================================
FILE: learning/help_topics/error_messages/two_default.c
==================================================

void bing() {
    switch (1) {
    default:
    default:
    }
}

==================================================
FILE: learning/help_topics/error_messages/undef_class.c
==================================================

class bing x;

==================================================
FILE: learning/help_topics/error_messages/var_to_nonvar.c
==================================================

void bing(int x) {
}
void bar() {
    bing( ({ })...);
}

==================================================
FILE: learning/help_topics/error_messages/void_arg.c
==================================================

void bing(void x) {
}

==================================================
FILE: learning/help_topics/error_messages/void_arg2.c
==================================================

void bing(void);

==================================================
FILE: learning/help_topics/error_messages/void_for_var.c
==================================================

void bing() {
    for (void x = 1; ; ) ;
}

==================================================
FILE: learning/help_topics/error_messages/void_global.c
==================================================

void x;

==================================================
FILE: learning/help_topics/error_messages/void_local.c
==================================================

void bing() {
    void x;
}

==================================================
FILE: learning/help_topics/error_messages/void_member.c
==================================================

class bing {
    void x;
}

==================================================
FILE: learning/help_topics/npcs/make_person.c
==================================================

#include "path.h";
inherit "/std/room";
object red_demon;
void setup() {
   set_short( "room telling about adding NPC's" );
   add_property( "determinate", "the " );
   set_long( "This is a room showing how to add a stationary NPC to a room.  "
            "If you try to \"update here\" you will see that it waits a few "
            "seconds after loading the room before adding the NPC and, that "
            "when it appears there are a message notifying the player about "
            "it.\n" );
   set_light( 60 );
   add_exit( "exit", ENTRANCE, "path" );
   add_property( "commented functions",
                ({ "set_long", "set_short", "add_property",
                   "set_light", "reset" }) );
   add_property( "keywords", ({ "npc", "clone", "permanent", "make" }) );
}
void reset() {
   if ( !red_demon ) {
      call_out( "make_demon", 5 );
   }
}
void make_demon() {
   red_demon = clone_object( "/obj/monster" );
   red_demon->set_name( "imp" );
   red_demon->set_short( "small red imp" );
   red_demon->add_adjective( ({ "small", "red" }) );
   red_demon->set_long( "This is a small red imp who has agreed to be used "
                       "as an example.\n" );
   red_demon->set_base_weight( 10 );
   red_demon->set_height( 17 );
   red_demon->set_race( "imp" );
   red_demon->set_level( 1 );
   red_demon->move( this_object(), "$N materialize$s with a small *POP*." );
}

==================================================
FILE: learning/help_topics/npcs/path.h
==================================================

#include <learning.h>
#define PATH HELP + "npcs/"

==================================================
FILE: learning/help_topics/rooms/path.h
==================================================

#include <learning.h>
#define PATH HELP + "rooms/"

==================================================
FILE: learning/help_topics/rooms/terrains/foyer.c
==================================================

#include "path.h"
inherit "/std/room";
object teacher;
object sign;
void setup() {
   set_short( "foyer of the terrain school" );
   add_property( "determinate", "the " );
   set_long( "This is the foyer to the terrain teacher's school.  "
      "The walls here are hung with beautiful landscapes of complex tracts "
      "of land, and beneath each landscape is a map of some kind.  "
      "An intricate chandelier hangs from the ceiling, casting an even "
      "glow on all the landscapes.  "
      "Comfortable benches line the walls here, with small tables "
      "between them.  "
      "The floor is covered with a plush green carpet, which would be nice "
      "if not for the heavy mud stains across it.\n" );
   add_item( "landscape",
      "The landscapes show mountains, jungles, forests, "
      "oceans, rivers... all sorts of different terrains, including a "
      "city and a village." );
   add_item( "map",
      "Beneath each landscape hangs a single topographical "
      "map which appears to be a detailed representation of the landscape "
      "above it." );
   add_item( "chandelier",
      "Crystal teardrops scatter the light of a dozen "
      "candles around the room, casting an easy, comfortable light by which "
      "you can see.", 1 );
   add_item( "crystal teardrop",
      "The candlelight makes it too hard to see "
      "the crystals clearly." );
   add_item( "candle",
      "Nestled into the midst of the chandelier, the twelve "
      "candles provide all the light in this room.");
   add_item( "bench",
     ({ "long", "These wooden benches have comfortable leather cushions "
           "firmly attached.",
        "position", "a wooden bench",
     }) );
   add_item( "table",
     ({ "long", "These tables are covered with magazines talking "
           "about far away places and exotic architecture.",
        "position", "a table",
     }) );
   add_item( "plush green carpet",
      "This deep pile carpet was once a rich evergreen colour, but "
      "years of muddy footprints have stained much of it a deep, "
      "ugly brown." );
   add_item( "mud stains",
      "Someone has b een walking on this formerly beautiful carpet with "
      "muddy boots." );
   add_item( "cushions",
      "Thick leather cushions, stuffed with something very soft, and "
      "affixed quite securely to the benches." );
   add_item( "magazines",
     ({ "long", "Architectural and travel magazines sit on the "
           "various tables around the room.",
        "read", "\"Ruins of The Temple of Offler!\", "
           "\"Beautiful Ankh-Morpork!\", \"Design of the Tower of Art\", "
           "and \"Scenic Ramtops Vacations!\" are just the most visible "
           "of the titles that scream up at you.  Hopefully the "
           "magazines are kept just for their pictures, which seem far "
           "more interesting than their text.",
     }) );
   set_light( 60 );
   add_exit( "grassyfield", PATH "grassystep", "hidden" );
   add_exit( "desert", PATH "sandtent", "hidden" );
   add_exit( "mountaintop", PATH "mountaincabin", "hidden" );
   add_exit( "back", LEARNING +"search", "path" );
   add_exit( "exit", ENTRANCE, "path" );
   add_property( "commented functions",
                ({  }) );
   add_property( "keywords",
                ({ "terrain" }) );
   sign = add_sign(
      "A cardboard sign, with text scrawled messily across the front.\n",
      "Awye FRoM TH OFFICe",
      "cardboard sign",
      "sign",
      "common" );
   if (sign) sign->set_get();
}
void init() {
   if ( !this_player() )
      return;
   if ( !interactive( this_player() ) )
      return;
   if (!teacher) {
      teacher = load_object( CHARS "terrain_teacher" );
   }    if ( teacher ) {
      teacher->pupil_arrived( this_object() );
   }
}

==================================================
FILE: learning/help_topics/rooms/terrains/grassyfield.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
   set_terrain("tutorial_grassy_field");
   set_short("grassy field");
   set_long("This field is covered with nicely mowed grass.\n");
   add_item("grass", "It's grass.  There isn't much to say about it.");
}

==================================================
FILE: learning/help_topics/rooms/terrains/grassystep.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
   set_terrain( "tutorial_grassy_field" );
   set_short( "doorstep");
   set_long( "This is the doorstep to a small cottage.  All around "
            "here is a field covered with nicely cut grass.\n" );
   add_item( "grass", "It's grass.  There isn't much to say about it." );
   add_item( "cottage", "A plain, one-room cottage, painted white, "
            "with pink shutters on both the windows.  *hack* *cough*" );
   add_exit( "cottage", PATH "foyer", "corridor" );
}

==================================================
FILE: learning/help_topics/rooms/terrains/mountainbedroom.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_terrain( "tutorial_mountain" );
   set_short( "mountain cabin attic" );
   set_long( "This is the second floor of a comfortable mountain cabin.  "
            "The bed occupying most of this room would seem to indicate "
            "that this is a bedroom.\n" );
   add_item( "bed", ({
      "long", "A big king-sized bed with a nice, thick, comforter on top.",
      "position", "the bed" }), 0 );
   add_item( "comforter",
      "This thick quilted comforter is made of some "
      "soft cotton fabric sandwiching a thick layer of down.");
   set_light( 50 );
}

==================================================
FILE: learning/help_topics/rooms/terrains/mountaincabin.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_terrain( "tutorial_mountain" );
   set_short( "rustic mountain cabin" );
   set_long( "This is the ground floor of a comfortable mountain cabin, "
      "complete with walls made of chinked logs, a bearskin rug, "
      "a huge, comfy sofa, and a bare lumber staircase leading "
      "up and down.  Unfortunately, since someone forgot to put a "
      "front door on this place, it's damned cold in here.\n" );
   add_item( ({ "log", "wall" }),
      "Formed of whole logs, sanded to a satin "
      "finish, laid together, and with the gaps chinked with mud." );
   add_item( "bearskin rug", ({
      "long", "Looks like a large blackbear gave his life that you can be "
         "comfortable lying before the fire.",
      "position", "the rug" }), 0 );
   add_item( "comfy sofa", ({
      "long", "Not very sophisticated, but it sure looks comfortable.",
      "position", "the sofa" }), 0 );
   set_light( 50 );
   room_chat( ({ 100, 300,
      ({ "A chill wind blows some snow in through the open doorway.",
         "A sudden shiver runs down your spine.",
         "Maybe you should have packed some cold weather gear?",
         "Oh, a mug of hot cocoa would about hit the spot right now."
      }) }) );
   add_exit( "down", PATH "foyer", "stair" );
}
string query_exit_type( string direc, string dest) {
   if (direc == "up" || direc == "down")
      return "stair";
   else if (direc == "west")
      return "corridor";
   else
      return "none";
}

==================================================
FILE: learning/help_topics/rooms/terrains/mountainsnows.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
   set_terrain( "tutorial_mountain" );
   set_short( "the snowy wastes" );
   add_property( "determinate", "" );
   set_long( "This snow covered land is swept by strong winds night and "
            "day.  No trees can stand the harsh climate.\n" );
   add_item( "tree", "No, I said there _weren't_ any trees." );
   add_property( "climate", ({ -40, 50, 40 }) );
}

==================================================
FILE: learning/help_topics/rooms/terrains/mountaintree.c
==================================================

#include "path.h"
#include <terrain.h>
inherit "/std/outside";
void setup() {
   set_room_size( 20 );
   set_terrain( "tutorial_mountain" );
   set_short( "tree in the mountains" );
   set_long( "This tree has defied all the odds, and grows straight and "
            "tall in the blustery wastes." );
   add_extra_look( this_object() );
   add_property( "climate", ({ -40, 50, 40 }) );
}
string extra_look() {
   if ( co_ord[ 2 ] < 800200 )
      return "\n";
   else
      return "  You can just make out a cabin in the snows to your "
             "northeast.\n";
}

==================================================
FILE: learning/help_topics/rooms/terrains/path.h
==================================================

#include <learning.h>
#define PATH HELP +"rooms/terrains/"
#define MAIN PATH +"main"

==================================================
FILE: learning/help_topics/rooms/terrains/sanddunes.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
   set_terrain( "tutorial_desert" );
   set_short( "sandy wasteland" );
   set_long( "This is just one small section of an endless "
            "expanse of sand.\n" );
   add_item( "sand",
      "It's sand.  There isn't much to say about it.");
   add_property( "climate", ({ 40, -100, -100 }) );
}

==================================================
FILE: learning/help_topics/rooms/terrains/sandoasis.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
   set_terrain( "tutorial_desert" );
   set_short( "desert oasis" );
   set_long( "The trees in this oasis provide welcome relief from the harsh "
            "sunlight of the desert.\n" );
   add_item( "sand",
      "It's sand.  There isn't much to say about it other than "
      "that it's much moister here than elsewhere in the desert." );
   add_item( "tree",
      "The palm trees grow majestically all around you, "
      "providing all the shade you could want." );
   add_property( "climate", ({ 10, -100, -100 }) );
}

==================================================
FILE: learning/help_topics/rooms/terrains/sandtent.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
   set_terrain( "tutorial_desert" );
   set_short( "outside tent" );
   set_long( "This is just outside the front flap of a canvas tent, set "
      "in the middle of a huge desert waste.  Nothing but sand as far "
      "as the eye can see.\n" );
   add_item( "sand",
      "It's sand.  There isn't much to say about it." );
   add_item( "tent",
      "This is a plain, white canvas tent, that reflects the harsh "
      "glare of the sun harmlessly away from its occupants." );
   add_exit( "tent", PATH "foyer", "corridor" );
   add_property( "climate", ({ 40, -100, -100 }) );
}

==================================================
FILE: learning/help_topics/rooms/add_item/action_verbs.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about making verbs do stuff" );
   set_light(100);
   set_long( "This is the room telling about making verbs do stuff.\n"
            "Let's say you have a rat in a room and randomly (let's say one "
            "out of two times) want to let players touch it.\n"
            "Read the ratnote to get an explanation of what happens when "
            "you touch the rat.\n"
            "There is a rat on the floor and a ratnote on the wall.\n");
   add_item( "large filthy rat", ({
      "long", "It looks like it wants to be touched.",
      "touch", ({ this_object(), "do_touch" }) }) );
   add_item( "ratnote", ({
      "long", "It can be read.",
      "read", "When the rat is touched, do_touch() is called.  The do_touch() "
         "function must return an integer - If the touch was successful it "
         "returns a 1, if the touch failed the function should return a 0.\n"
         "Note also that a success message is given to all in the room.  But, "
         "if the person fails, the add_item code looks for more matches - "
         "thinking that the function do_touch is the wrong one.  If there is "
         "no other function found that defines touching rats and that returns "
         "a 1, then the game returns the message 'You fail to touch a rat'.\n"
         "The this_object() reference tells the add_item code what object is "
         "the direct object of the verb.  Just trust me, and leave it in your "
         "code without asking why for now.  It is one of those things that "
         "can give you more flexibility later on.\n" }) );
   add_exit( "east", PATH +"verb_failure", "path" );
   add_exit( "west", PATH +"many_verbs", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_touch() {
   if( random(2) ) {
      tell_object( this_player(), "\n ****  You feel deathly sick. ****\n"
                  " (this is a tell_object(this_player(),...))\n" );
      tell_object( this_player(),
                  "do_touch is returning a 0, indicating failure!\n" );
      return 0;
   }
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/action_verbs2.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #6, making verbs do stuff, better version ");
   set_light(100);
   set_long("add_item room #6, making verbs do stuff, better version\n"
	    +"There are two ways to call a function if a verb is used.  "
	    +"This room demonstrates the second one.  "
       	    +"Lets say you have a rat in a room and randomly ( one out of "
	    +"two times lets say ) want to let players touch it. "
	    +"This is how you could do it.\n"
	    +"A filthy rat and a can.\nA ratnote and a cannote.\n");
   add_item("ratnote", ({ "long", "It can be read.",
		       "read", "Here is the code for the rat:\n"
     +"   add_item(\"large filthy rat\", ({\n"
     +"        \"long\",\n"
     +"           \"It looks like it wants to be touched.\\n\"\n"
     +"         ,\"touch\",\n"
     +"           ({ this_object(), \"do_touch\" }) }) );  \n"
     +"When the rat is touched, do_touch() is called.  The do_touch() func "
     +"must return an integer - If the touch was successful it returns a 1, "
     +"if the touch failed the function should return a 0.  Note that a "
     +"success message is given to all in the room.  But, if the person fails "
     +"the add_item code looks for more matches - thinking that the func "
     +"do_touch is the wrong one.  If there is no other function found that "
     +"defines touching rats and that returns a 1, then the game returns the "
     +"message 'You fail to touch a rat'.\n"
     +"The this_object() refrence tells the add_item code what object is "
     +"the direct object of the verb.  Just trust me, and leave it in your "
     +"code without asking why for now.  It is one of those things that can "
     +"give you more flexibility later on.\n" }));
   add_item("dirty can", ({
	        "long",
	                   "It looks like it wants to be touched."
		,"touch",
                             ({ this_object(), "always_fail" })
                   }));
   add_item("cannote", ({ "long", "It can be read.",
		          "read", "Here is the code for the can:\n"
     +"   add_item(\"dirty can\", ({\n"
     +"        \"long\",\n"
     +"           \"It looks like it wants to be touched.\\n\"\n"
     +"         ,\"touch\",\n"
     +"           ({ this_object(), \"always_fail\" }) }) );  \n"
     +"When the can is touched, always_fail() is called.  This function "
     +"looks like this:\n int always_fail() { return 0; }\n"
     +"in this way if you want a person to be able to use a verb on an "
     +"object, but want to be lazy - and don't want the action to succeed "
     +"( such as a door that can't be broken down ) this is the way to do "
     +"it.\nPlease read ratnote also, if you havn't.\n" }));
   add_item("large filthy rat", ({
	        "long",
	                   "It looks like it wants to be touched."
		,"touch",
                             ({ this_object(), "do_touch" })
                   }));
   add_exit("east",ROOM+"verb_failure","door");
   add_exit("west",ROOM+"changing_descs","door");
   add_exit("north",MAIN,"door" );
 }
int  do_touch()
{
  if( random(2) ) {
      tell_object(this_player(),"\n ****  You feel deathly sick. ****\n  "
		              "(this is a tell_object(this_player(),...)) \n");
      tell_object(this_player(),
		  "do_touch is returning a 0, indicating failure!\n");
      return 0;
    }
    return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/args_char.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #12, Getting character arguments ");
   set_light(100);
   set_long("add_item room #12, Getting character arguments\n"
	    +"There is a large stone in the middle of the room.  It looks as "
	    +"if you can engrave your name onto it.\nSource code.\n");
   add_item("large stone", ({
	        "long",
	                   "It can be engraved."
		,"engrave",
			   ({ this_object(), "do_engrave",
				"'into' %D 'the' text' %s"  })
	}));
   add_item("source code", ({ "long",
         "It looks like some source code."
         ,"read",
         "The source code:\n"
+"\n"
+"   add_item(\"large stone\", ({\n"
+"	        \"long\",\n"
+"	                   \"It can be engraved.\"\n"
+"		,\"engrave\",\n"
+"			   ({ this_object(), \"do_engrave\",\n"
+"				\"'into' %D 'the' text' %s\"  })\n"
+"	}));\n"
+"\n\nRead also:  do_engrave\n" }));
   add_item("do_engrave", ({ "long",
         "It looks like some source code."
         ,"read",
         "The source code:\n"
+"int do_engrave(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)\n"
+"{\n"
+"     string mess;\n"
+"        mess =  \"$N $V \"+a5[1]+\" into \"+a3+\".\\n\";\n"
+"        this_player()->add_succeeded_mess(previous_object(),\n"
+"					        mess,\n"
+"					        ({}));\n"
+"        return 1;\n"
+"}\n"
+"\n" }));
   add_exit("east",ROOM+"args_object","door");
   add_exit("west",ROOM+"args_integer","door");
   add_exit("north",MAIN,"door" );
 }
int do_engrave(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
     string mess;
        mess =  "$N $V "+a5[1]+" into "+a3+".\n";
        this_player()->add_succeeded_mess(previous_object(),
					        mess,
					        ({}));
        return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/args_integer.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about getting integer arguments" );
   set_light( 100 );
   add_property( "determinate", "the " );
   set_long( "This is the room telling about getting integer arguments from a "
            "command defined with add_item.  Go east to learn about getting "
            "string arguments, west to learn about the arguments passed "
            "to the function called when you do the command.\n"
            "This room is filled with an uncountable number of rats.  They "
            "all have numbers branded into them.  You can dissolve a rat if "
            "you know its number.\n" );
   add_item( "large filthy rat", ({
      "long", "The rats look vile.",
      "dissolve", ({ this_object(), "do_dissolve",
         "<direct:object> [no|number] <number>" })
   }) );
   add_exit( "east", PATH +"args_string", "path");
   add_exit( "west", PATH +"func_arguments", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_dissolve( string command, object *indir, string dir_match,
                string indir_match, mixed *args, string pattern ) {
   string mess;
   tell_object( this_player(),
               sprintf( "$I$2=do_dissolve called:\ncommand=%O\nindir=%O\n"
                       "dir_match=%O\nindir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, indir, dir_match,
                       indir_match, args, pattern ) );
   mess =  "$N $V "+ dir_match +" number "+ args[ 1 ] +".\n";
   this_player()->add_succeeded_mess( previous_object(),
                                      mess, ({ }) );
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/args_object.c
==================================================

#include "path.h"
inherit "/std/room";
object key;
void setup() {
   set_short( "'add_item' room telling about getting the object as argument" );
   set_light(100);
   add_property( "determinate", "the " );
   set_long( "This is the room telling about getting string arguments from a "
            "command defined with add_item.  Go east to see about getting "
            "string arguments, west to see about item conflicts.\n"
            "There is a large stone in the middle of the room.  It looks as "
            "if you can unlock it if you have the correct key.\n" );
   add_item( "large stone", ({
      "long","It can be unlocked.",
      "unlock", ({ this_object(), "do_unlock",
         "<direct:object> [with] <indirect:object>" })
   }) );
   add_exit( "east", PATH +"item_conflicts", "path" );
   add_exit( "west", PATH +"args_string", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_unlock( string command, object *indir, string dir_match,
               string indir_match, mixed *args, string pattern ) {
   object ob;
   tell_object( this_player(),
               sprintf( "$I$2=do_unlock called:\ncommand=%O\nindir=%O\n"
                       "dir_match=%O\nindir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, indir, dir_match,
                       indir_match, args, pattern ) );
   this_player()->add_failed_mess( previous_object(),
                                  "You don't have the correct key.\n", ({ }) );
   ob = indir[ 0 ];
   if( (int) ob->query_property( "Mithal" ) != 1 ) {
      write( "wrong key\n" );
      return 0;
   }
   this_player()->add_succeeded( ob );
   this_player()->add_succeeded_mess( previous_object(),
                                     "$N $V the stone with $I.\n",
                                     ({ ob }));
   write( "You succeeded!\n" );
   return 1;
}
void reset() {
   call_out( "check_key", 2 );
}
void check_key() {
   if( !key ) {
      key = clone_object( "std/object" );
      key->set_name( "key" );
      key->set_short( "Mithal's key" );
      key->add_property( "Mithal", 1 );
      key->move( this_object(), "Mithal sneaks through the room, "
                "dropping $N in the process." );
   }
}

==================================================
FILE: learning/help_topics/rooms/add_item/args_string.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about getting string arguments" );
   set_light( 100 );
   add_property( "determinate", "the " );
   set_long( "This is the room telling about getting string arguments from a "
            "command defined with add_item.  Go east to see about getting "
            "object arguments, west to see about integer arguments.\n"
            "There is a large stone in the middle of the room.  It looks as "
            "if you can engrave your name onto it.\n");
   add_item( "large stone",
            ({ "long", "It can be engraved.",
               "engrave", ({ this_object(), "do_engrave",
                  "[the text] <string> [into] [the] <direct:object>" })
            }) );
   add_exit( "east", PATH +"args_object", "path");
   add_exit( "west", PATH +"args_integer", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_engrave( string command, object *indir, string dir_match,
               string indir_match, mixed *args, string pattern ) {
   string mess;
   tell_object( this_player(),
               sprintf( "$I$2=do_engrave called:\ncommand=%O\nindir=%O\n"
                       "dir_match=%O\nindir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, indir, dir_match,
                       indir_match, args, pattern ) );
   mess =  "$N $V \""+ args[ 0 ] +"\" into "+ dir_match +".\n";
   this_player()->add_succeeded_mess( previous_object(), mess, ({ }) );
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/changing_descs.c
==================================================

#include "path.h"
inherit "/std/room";
int open;
void setup() {
   set_short("add_item room #5b, item descriptions that change with time");
   set_light(100);
   set_long("add_item room #5b, item description that change with time\n"
            "*BEEEP* *BEEEP* WARNING! WARNING! *BEEEP* *BEEEP*\n"
            "This room is crap, and uses a non longer valid way of changing "
            "descriptions, if you see anything like this, be sure to bug "
            "report it.\nAlso note that \"I\" is Mithal:)\n"
	    +"There are a few other uses for the pasting function. One of "
	    +"them is to provide descriptions that change depending on "
	    +"certan variables.  In this room there is a chest.  Every other "
	    +"time you look at it, it is open.  In the code there is a "
	    +"global variable 'open' that is switched between 1 and 0 every "
	    +"time 'look_chest' is called.  The function returns 'The chest "
	    +"is open' if open == 1, else 'The chest is closed'. "
	    +"Unfortunately, the exact code cannot be put here... since the "
	    +"pasting function would work as you read the help text. *smile* "
	    +"Thus & is used in place of @ in the example code.\n"
	    +"A chest.\nA note.\n");
   add_item("note", ({ "long", "It can be read.",
		       "read", "Here is the code for the chest:\n"
       +"   add_item(\"chest\",\"The Chest is \"+\n"
      +"        \"&&look_chest:\"+file_name(this_object())+\"&&\\n\");\n\n"
     +"Again, the & signs are used to represent @ signs.\n"
     +"The code for look_chest:\n\n"
     +"   string do_chest() { \n"
       +"      if( open ) { open = 0; return \"Open.\"; } \n"
       +"      open = 1;  return \"Closed!\";  } \n\n"
     +"  I think this is a much better way to deal with stuff than the famous "
     +" modify_item.\nUse and be happy!\n" }));
      add_item("chest","The chest is "+
               "@@look_chest:"+file_name(this_object())+"@@\n");
   open = 0;
   add_exit("east",PATH+"action_verbs2","path");
   add_exit("west",PATH+"action_verbs","path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
string look_chest() {
   if(open) { open = 0; return "Open."; }
   open = 1; return "Closed!";
}

==================================================
FILE: learning/help_topics/rooms/add_item/func_arguments.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about the arguments of the function" );
   set_light( 100 );
   add_property( "determinate", "the " );
   set_long( "This is a room telling about the arguments passed to the "
            "do_<verb>() function.  Go east for examples of using the "
            "arguments, west for something else:).\n"
            "Here goes:\n"
            "  int do_<verb>( string command, object *indir, string dir_match,\n"
            "                 string indir_match, mixed *args, string pattern );\n"
            "$I$12=command     is a string, it is the name of the verb "
             "used.$I$0=\n"
            "$I$12=indir       is an array of objects.  If any indirect "
             "objects are requested for, then they will be in this array."
             "$I$0=\n"
            "$I$12=dir_match   is a string, it is the name of the direct "
             "object.$I$0=\n"
            "$I$12=indir_match is a string, it is the name of the indirect "
             "object.$I$0=\n"
            "$I$12=args        is a mixed array of strings and numbers.  For "
             "each <> thingie you have in the pattern, it has a member.  So "
             "if you have <direct:object>, it has the name of the direct "
             "object, if you have <number> then it will have a number also, "
             "if <indirect:object>, the indirect object's name, and so on.  "
             "They are in the same order as in the pattern.$I$0=\n"
            "$I$12=pattern     is a string containing the pattern. It is "
             "useful to know which pattern has been caught since multiple "
             "patterns are allowed per function.$I$0=\n\n"
            "All do_<verb> functions in the learning domain will write their "
            "arguments, to help you figure out how to use them.\n"
            "A pool you can jump into is here.\n" );
   add_item( "large pool", ({
      "long", "It looks like you can jump into it.",
      "jump", ({ this_object(), "do_jump", "[into|in] <direct:object>" })
   }) );
   add_exit( "east", PATH +"args_integer", "path" );
   add_exit( "west", PATH +"verb_patterns", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_jump( string command, object *indir, string dir_match,
            string indir_match, mixed *args, string pattern ) {
   tell_object( this_player(),
               sprintf( "$I$2=do_jump called:\ncommand=%O\nindir=%O\n"
                       "dir_match=%O\nindir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, indir, dir_match,
                       indir_match, args, pattern ) );
   this_player()->add_succeeded_mess( previous_object(),
                                     "$N $V into a pool!\n", ({ }) );
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/intro.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about simple items" );
   set_light( 100 );
   add_property( "determinate", "the " );
   set_long( "This is the first room about add_item(), covering simple items.\n"
            "Go east to see how to make items that can be refered to in more "
            "complicated ways.\n"
            "In your course of describing a room you often mention quite "
            "a few nouns.  In this mud we try to give every noun mentioned a "
            "description a description.  We do this with the function "
            "add_item.  For more information read the note.\n" );
   add_item( "noun", "Nouns should have descriptions." );
   add_item( "description", "Descriptions should be witty wherever reasonable." );
   add_item( "discworld", "The mud you are learning to code for." );
   add_item( "information", "See the note." );
   add_sign( "This is a note with some information, perhaps you should read "
                "it.\n",
             "For simple items like 'room' the corresponding code "
               "to represent that item is relatively easy:\n\n"
               "   add_item( \"room\", \"It is a big room.\" );  \n\n"
               "Notice that there is no newline in the description.  "
               "The mudlib adds newline when necessary.  Also "
               "notice that this is not true with set_long where a \\n is "
               "necessary at the end of the description.",
             "note", "note" );
   add_item( "room", "It is a big room." );
   add_exit( "east", PATH +"many_names", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}

==================================================
FILE: learning/help_topics/rooms/add_item/item_conflicts.c
==================================================

#include "path.h"
inherit "/std/room";
object key;
void setup() {
   set_short( "'add_item' room telling about resolving item conflicts" );
   set_light( 100 );
   set_long( "This is the room telling about resolving item conflicts in "
            "items defined with add_item.\n"
            "This room still has some basic problems, and shouldn't be used "
            "as an example.\n"
            "Inside, add_item creates one "
            "object per room for its use and assigns an alias to each item "
            "pointing to this object.  Therefore it is likely that "
            "if you have multiple add_items with verbs that call functions "
            "you can run into problems.  In this room there is a fountain and "
            "a pool.  Both of these define 'toss'.  If the wrong function is "
            "called, then your function must return a 0 in order for the "
            "correct function to be called.  Otherwise you will have a bug!  "
            "Please look at this code and notice how each function checks to "
            "make sure that the appropriate pattern is used.  If this code "
            "were removed, then funny things would start to happen.:)\n" );
   add_item( "small fountain",
            ({ "long",
               "You can see a few platinum coins in the water.",
               "toss", ({ this_object(), "do_throw_fount",
                  "<number> platinum [coins|coin] into <direct:object>" })
            }) );
   add_item( "small pool",
            ({ "long", "You can see some silver coins lying around in the "
                       "pool.",
               "toss", ({  this_object(),"do_throw_pool",
                  "<number> silver [coins|coin] into <direct:object>" })
            }) );
   add_exit( "west", PATH + "args_object", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_success_thing( int pool, int silver, int no ) {
   string coinstr, poolstr, nocoins;
   if( no < 0 ) return 0;
   if( silver ) coinstr = "silver";
   else coinstr = "platinum";
   if( pool ) poolstr = "pool";
   else poolstr = "fountain";
   nocoins = no+" "+coinstr+" coins";
   if( no == 1 ) nocoins = "one "+coinstr+" coin";
   this_player()->add_succeeded_mess( previous_object(),
           "$N $V "+ nocoins +" into a "+ poolstr +".\n", ({ }) );
   return 1;
}
int do_throw_pool( string command, object *indir, string dir_match,
                  string indir_match, mixed *args, string pattern ) {
   string nocoins;
   int no;
   tell_object( this_player(),
               sprintf( "$I$2=do_throw_pool called:\ncommand=%O\n"
                       "dir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, dir_match,
                       args, pattern ) );
   no = args[ 0 ];
   if( pattern != "<number> silver [coins|coin] into <direct:object>" )
      return do_success_thing( 1, 0, no );
   if( !do_success_thing( 1, 1, no ) ) return 0;
   tell_object( this_player(), "You throw coins!\n");
   return 1;
}
int do_throw_fount( string command, object *indir, string dir_match,
                   string indir_match, mixed *args, string pattern ) {
   int no, stored, ran;
   tell_object( this_player(),
               sprintf( "$I$2=do_throw_fount called:\ncommand=%O\n"
                       "dir_match=%O\nargs=%O\n"
                       "pattern=%O$I$0=\n",
                       command, dir_match,
                       args, pattern ) );
   no = args[ 0 ];
   if( pattern != "<number> platinum [coins|coin] into <direct:object>" )
      return do_success_thing( 0, 1, no );
   if( !do_success_thing( 0, 0, no ) ) return 0;
   tell_object( this_player(),  "*giggle*\n");
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/item_helper.c
==================================================

#include "path.h"
inherit "/std/room";
string pattern;
string verb;
void setup() {
   set_short("add_item room #15, Testing and creating a form ");
   set_light(100);
   set_long("add_item room #15, Testing and creating a form "
            +"This item is ment to help in the formulation of items."
	    +"it provides a way to use add_item without coding.  I "
	    +"will try to explain it.  *sigh* You can change the pattern and "
	    +"name of the verb construct seperately. And you can add items to "
	    +"this room.  The 'add an object named XXXX' command creates an "
	    +"object with the name XXXX useing the current verb and pattern.  "
	    +"Once you have added the item, you can look at it, and use the "
	    +"defined verb on it.  The verb will spit out all of the "
	    +"arguments to the function, like room 12.  In this way you can "
	    +"test verb patterns - since many of them don't work - without "
	    +"any coding.  It should help you get an idea how it all works.  "
	    +"\nA reference sheet.\nA stupid object.\n");
   add_exit("west",PATH+"item_conflicts","path");
   add_exit("north",MAIN,"path" );
      add_item("reference sheet",
	    "Pattern: Is the add_command pattern( parse_command): \n"
	    +"Example string = \" 'get' / 'take' %i \" \n"
	    +"Syntax:\n"
	    +"  'word'          obligatory text     \n"
	    +"  [word]          optional text       \n"
	    +"  /               Alternative marker  \n"
	    +"  %o              Single item, object \n"
	    +"  %l              Living objects      \n"
	    +"  %s              Any text            \n"
	    +"  %w              Any word            \n"
	    +"  %p              One of a list (prepositions)  \n"
	    +"  %i              Any items                     \n"
	    +"  %d              Number 0- or tx(0-99)         \n"
	    +"Things from add_command                         \n"
	    +"  %D              Direct Object                 \n"
            +"  %I              Indirect object               \n\n"
	    +"Currently %s and %w behave a bit erradically... \n"
	    +"If you put 'text' before and after them it might help.\n"
	    +"Hope this helps!\n" );
   pattern = "%D";
   verb    = "use";
   add_item("stupid object"
      ,({
            "long",       "This object is used to create items in the room!\n"
            +" set object pattern to <pattern> \n"
	    +" name object verb to <verb> \n"
            +" query object  ( returns the current pattern and verb ) \n"
            +" add an object named <item>\n"
            ,"set"      ,({this_object(),"do_set","%D 'pattern' 'to' %s" })
	    ,"name"     ,({this_object(),"do_name","%D 'verb' 'to' %s" })
            ,"query"    ,"@@do_query:"+file_name(this_object())+"@@\n"
            ,"add"      ,({this_object(),"do_add","'an' %D 'named' %s" })
        }));
}
int do_set(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
   pattern = (string) a5[1];
   return 1;
}
int do_name(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
   verb = (string) a5[1];
   return 1;
}
int do_add(mixed a1,mixed a2,mixed a3,mixed a4, mixed a5, mixed a6)
{
   object *obs;
  add_item( a5[1]
      ,({
            "long",
	       "This object's name is: "+a5[1]
	        +"\nAnd it can be used with the pattern:"+pattern
		+":\nAnd verb:"+verb+":\n\n"
            ,verb      ,({this_object(),"do_use",pattern })
        }));
   obs = all_inventory(this_object());
   obs->move("/room/void");
    obs->move(this_object());
   this_player()->move(this_object());
   return 1;
}
string do_query()
{ return "\nPattern:"+pattern+":Verb:"+verb+":\n"; }
int  do_use(mixed a1, mixed a2, mixed a3, mixed a4, mixed a5, mixed a6)
{
  printf("\nThe Verb:(A1):  %O\nThe Objects(A2):\n%O\nDirect Object(A3):  %O\nIndirect Object(A4):  %O\nReturn Array(A5):\n%O\nPattern(A6):  %O\n\n",a1,a2,a3,a4,a5,a6);
  tell_object(this_player(),"Hope that worked...\n");
  return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/main.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "primary room for \"add_item\"" );
   add_property( "determinate", "the " );
   set_light( 100 );
   set_long( "This is the start room for the examples for add_item.  "
            "Essentially boring, since it's only here to start you on your "
            "way:)\n" );
   add_exit( "start", PATH +"intro", "path" );
   add_exit( "failure", PATH +"verb_failure", "path" );
   add_exit( "success", PATH +"verb_success", "path" );
   add_exit( "patterns", PATH +"verb_patterns", "path" );
   add_exit( "arguments", PATH +"func_arguments", "path" );
   add_exit( "args_int", PATH +"args_integer", "path" );
   add_exit( "args_string", PATH +"args_string", "path" );
   add_exit( "args_object", PATH +"args_object", "path" );
   add_exit( "helper", PATH +"item_helper", "path" );
   add_exit( "exit", LEARNING + "search", "path" );
   add_property( "commented functions", ({ "add_item" }) );
   add_property( "keywords", ({ "room", "add_item", "action", "command" }) );
}

==================================================
FILE: learning/help_topics/rooms/add_item/many_names.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short( "'add_item' room telling about simple items with many names" );
   set_light( 100 );
   set_long( "This is the room telling about making simple items with many "
            "names.  To help as examples it's been filled with several items "
            "including a small note, candles and some chairs.  Look at the "
            "note to learn more.  Go east to learn about adding verbs to the "
            "items, and west to go to a simpler example.\n" );
   add_item( "small note",
            "Ok things get more complicated here.\n"
            "First of all, the mudlib adds the plural forms of an "
            "item you add to a room.  Thus, \n"
            "  add_item( \"candle\", \"Very nice.\" );\n"
            "will take care of both \"look at candle\" and \"look at "
            "candles\".\n"
            "Secondly, the code:\n"
            "  add_item( \"small note\", \"Ok things ... \n"
            "will take care of both \"look at note\" and \"look at small "
            "note\"\n"
            "And finally, the code:\n"
            "  add_item( ({ \"corridor\", \"long hallway\" }), "
            "\"It is long.\" );\n"
            "will take care of \"look at corridor\", \"look at hallway\", "
            "\"look at long hallway\" and even \"look at long hallways\".\n"
            "If you look at the hallways you'll see the message you get is "
            "not very good as it refers to a single hallway.  To make a "
            "different description when you look at a single "
            "item and all of them, you can use the optional third parameter "
            "to tell the mudlib it shouldn't try to add the plural form. "
            "Thus:\n"
            "  add_item( \"chair\", \"This chair looks about ready to fall "
            "over.\", 1 );\n"
            "  add_item( \"chairs\", \"The chairs look ready to fall "
            "over.\", 1 );\n"
            "Oh, one last thing when listing things in this manner as a rule "
            "of thumb, put the best description first.\n" );
   add_item( "candle", "Very nice." );
   add_item( ({ "corridor", "long hallway" }), "It is long." );
   add_item( "chair", "This chair looks about ready to fall over", 1 );
   add_item( "chairs", "The chairs look ready to fall over", 1 );
   add_item( "item", "You don't see any since noone coded one yet!" );
   add_item( "reference", "Like one that you would find in a theusaures." );
   add_item( "room", "It is a big room." );
   add_exit( "east", PATH +"verbs", "path");
   add_exit( "west", PATH +"intro", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}

==================================================
FILE: learning/help_topics/rooms/add_item/many_verbs.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #4, many verbs ");
   set_light(100);
   set_long( "add_item room #4, many verbs \n"
            "Sometimes you have two or more identical verbs - or at least "
            "identical in how you want to treat them.  Take our oak tree "
            "we can cut it, slice it, saw it, etc...  Now all of these have "
            "the same meaning. How do we do this?\n"
            "A large oak.\nA note.\n");
   add_item("note", ({ "long", "It can be read.",
      "read", "Here is the code for the tree:\n"
      "    add_item(\"large oak tree\", ({\n"
      "      \"long\",\n"
      "              \"It looks like it is very well protected.\"\n"
      "      ({\"cut\",\"slice\",\"saw\",\"destroy\",\"kill\" }),\n"
      "              \"It seems to have no effect.\\n\"       }});\n\n"
      "Pretty obvious hunh?  Note that kill probably does not work( I "
      "say probably cuz things might change)  That is beacuse user commands "
      "have precidence over object actions in rooms.  Also be aware that a "
      "add_action on an item that a person is holding will most likely stop "
      "your verbs from being used (unless it's coded right:).  Soul commands "
      "do not have precedence, however.  So verbs like \"pick\" which would "
      "normally say \"You pick your nose\" can be trapped appropriately.\n"
   }) );
   add_item("large oak", ({
      "long", "It looks like it is very well protected.",
      ({ "cut", "slice", "saw", "destroy", "kill" }),
        "It seems to have no effect.\n" }) );
   add_exit( "east", PATH +"action_verbs", "path");
   add_exit( "west", PATH +"verbs", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}

==================================================
FILE: learning/help_topics/rooms/add_item/path.h
==================================================

#include <learning.h>
#define PATH HELP +"rooms/add_item/"
#define MAIN PATH +"main"

==================================================
FILE: learning/help_topics/rooms/add_item/verb_failure.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #7, verb failure messages ");
   set_light(100);
   set_long("add_item room #7, verb failure messages\n"
            +"Let us continue with our rat.  Sometimes the general failure "
            +"message just dosn't cut it.  When the player fails to  "
            +"touch our rat, the mud should tell him/her nicely and not "
            +"let them think they messed up.  This rat does just that.  "
            +"Notice that, unlike success messages, failure messages go only "
            +"to the player - not to everyone in the room.  *smile* \n"
            +"A filthy rat.\nA note.\n");
   add_item("note", ({ "long", "It can be read.",
		       "read", "Here is the code for the do_touch:\n"
	     +"int  do_touch()\n"
             +"{\n"
	     +"   if(!random(2)) {\n"
	     +"       this_player()->add_failed_mess(previous_object(),\n"
	     +"                       \"You miss the rat!\\n\",\n"
	     +"                       ({})); \n"
	     +"        return 0;\n"
	     +"    }\n"
	     +"    return 1;\n"
	     +"}\n\n"
	     +"The add_failed_mess is a pretty complicated fella.  The first "
	     +"argument I beleve is the object that the verb failed on, ie "
	     +"the rat.  The second argument is the failure message. Since "
	     +"it is going only to the player, it is really simple to "
	     +"understand.  The third argument is the set of indirect "
	     +"that were used in the failing attempt.  I think you can "
	     +"reference there name in the message as %I.  But don't quote "
	     +"me on that.  Similarly %D can be used as a substution for the "
	     +"direct object, ie previous_object().  It is complicated.  "
	     +"If you stick to this form, you shouldn't have any problems.  "
	     +"If all else fails, read the help file on it. *giggle* \n" }));
   add_item( "large filthy rat", ({
      "long", "It looks like it wants to be touched.",
      "touch", ({ this_object(), "do_touch" }) }));
   add_exit( "east", PATH +"verb_success", "path" );
   add_exit( "west", PATH +"action_verbs", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_touch() {
   if(!random(2)) {
      this_player()->add_failed_mess(previous_object(),
                                     "You miss the rat!\n",
                                     ({}));
      return 0;
   }
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/verb_patterns.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #9, verb patterns ");
   set_light(100);
   set_long("add_item room #9, verb patterns\n"
            +"Outdated! see man add_command for patterns\n "
            +"As you guessed I am still holding out on you.  There is, "
            +"unfortunately, tons more!  Most things take the form: VERB "
            +"DIRECT_OBJECT or $V $D.  Add item has a limited number of "
            +"patterns that it can recognize, the first limitation is that "
            +"the verb must come first.  ie VERB PATTERN.  The default "
            +"pattern we have been using to date is %D.  We can change the "
            +"pattern!\nReference sheet.\nLarge pool.\nNote.\n");
   add_item("reference sheet",
            "Pattern: Is the add_command pattern( parse_command): \n"
            +"Example string = \" 'get' / 'take' %i \" \n"
            +"Syntax:\n"
            +"  'word'          obligatory text     \n"
            +"  [word]          optional text       \n"
            +"  /               Alternative marker  \n"
            +"  %o              Single item, object \n"
            +"  %l              Living objects      \n"
            +"  %s              Any text            \n"
            +"  %w              Any word            \n"
            +"  %p              One of a list (prepositions)  \n"
            +"  %i              Any items                     \n"
            +"  %d              Number 0- or tx(0-99)         \n"
            +"Things from add_command                         \n"
            +"  %D              Direct Object                 \n"
            +"  %I              Indirect object               \n\n"
            +"Currently %s and %w behave a bit erradically... \n"
            +"If you put 'text' before and after them it might help.\n"
            +"Hope this helps!\n" );
   add_item("note", ({ "long", "It can be read.",
      "read", "Here is the code for the pool:\n"
      +"  add_item(\"large pool\", ({  \n"
      +"       \"long\",\n"
      +"                   \"It looks like you can jump into it!\"\n"
      +"	,\"jump\",\n"
      +"		   ({ this_object(), \"do_jump\", \n"
      +"			\" 'into' / 'in' %D \"  })  \n"
      +"	 )} );\n\n"
      +"Ok. Not much different, just one more argument.  Look at the "
      +"reference sheet.  Looks complicated hunh?  The most useful ones "
      +"are %D, %I, %d, [text], 'text', and /.  I will demonstrate how to "
      +"use %d and %I in a few rooms.  I have also changed the succeed "
      +"mess, otherwise it would say: \"You jump into / in a large pool.\"  "
      +"Not good huh? *smile* Oh well on to the next room!\n" }));
   add_item( "large pool", ({
      "long", "It looks like you can jump into it!",
      "jump", ({ this_object(), "do_jump", " [into|in] <direct:object>" })
   }) );
   add_exit( "east", PATH +"func_arguments", "path");
   add_exit( "west", PATH +"verb_success", "path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int do_jump() {
   this_player()->add_succeeded_mess(previous_object(),
                                     "$N $V into a pool!\n",  ({}));
   return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/verb_success.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #8, verb success messages ");
   set_light(100);
   set_long("add_item room #8, verb success messages\n"
	    "Let us continue with our rat.  Suppose now that we want the "
	    "player to succeed - but that the default message is really "
	    "inappropriate.  What we want to do is change the succeed "
	    "message!  Let's say when the player goes to touch the rat "
	    "it tells him - As you touch the rat, it snarls. - "
	    "Unfortunately succeed messages are much more complicated "
	    "beacuse your message is going to two parties, the player and "
	    "other players in the room. So you can't put the words \"You\" and "
	    "\"touch\" directly into code, because \"Fred\" and \"touches\" are the "
	    "appropriate substitutions to be used for the audience.  "
	    "Furthermore, if you are useing "
	    "multiple verbs, how do you know what verb the person used? "
	    "The solution is to use $V for verb and $N for player name.\n"
	    "A filthy rat.\nA note.\n");
   add_item("note", ({ "long", "It can be read.",
		       "read", "Here is the code for the do_touch:\n"
	     "int  do_touch()\n"
             "{\n"
             "      this_player()->add_succeeded_mess(previous_object(),\n"
	     "        \"As $N $V $D, it snarls.\\n\",  ({}));\n"
	     "    return 1;\n"
	     "}\n\n"
	     "The only difference between add_failed_mess and this one is "
	     "the message: When the message is processed for the player, "
	     "\"You\" is substituted for $N and \"touch\" for $V.  Likewise, when "
	     "the message is processed for others: \"Fred\" is substituted for $N "
	     "and \"touches\" is substituted for $V.  If you were using multiple "
	     "verbs, the appropriate verb would be used.  There might be "
	     "other $ stuff in the docs( namely $D and $I if you have an "
	     "indirect object list.)  There might be ones for pronouns and "
	     "possessives also.  At last "
	     "resort, you can always make this string a null string! And "
	     "insert tell_other and tell_room call's directly in your code."
	     "Of course add_failed_mess and this one can be used together in "
	     "the same code...\n" }));
   add_item("large filthy rat", ({
	        "long",
	                   "It looks like it wants to be touched.",
		"touch",
                           ({ this_object(), "do_touch" }) }));
   add_exit("west",PATH+"verb_failure","path");
   add_exit("east",PATH+"verb_patterns","path");
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}
int  do_touch()
{
  this_player()->add_succeeded_mess(previous_object(),
	            "As $N $V $D, it snarls.\n",  ({}));
    return 1;
}

==================================================
FILE: learning/help_topics/rooms/add_item/verbs.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
   set_short("add_item room #3, verbs ");
   set_light(100);
   set_long("add_item room #3, verbs \n"
            "As you know, things can be read, kicked, etc... in DiscWorld.  "
            "Therefore we need to make our items respond to actions.  The "
            "old way to do this is through add_action.  Unless you are "
            "experienced, you should not use this function.  add_item "
            "provides many facilities to do this which are much better to "
            "write, easier to understand, and have less chance of 'bugging' "
            "out on you.\nA large oak.\nA note.\n\n");
   add_item("note", ({ "long", "It can be read.",
      "read", "As you can see, this note can be read, "
      "this is our first introduction to verbs.  "
      "The code that does this:\n"
      "      add_item(\"note\", ({ \"long\", \"It can be read.\" \n"
      "                          \"read\", \"As you can see ... \" }) );\n"
      "This uses a mixed variable in the description part of the "
      "add_item.  The members of the mixed variables are strings which "
      "come in pairs.  Notice that \"long\" is not \"look\" this is just "
      "a simple way to specify a whole range of verbs that return this "
      "description, namely:  look, examine, ... \n"
      "After printing out the message the add_item program prints out to "
      "the person reading the note: \"You read a note.\"  More generally:  "
      "\"You <verb> <indefinate artical> <item>.\"  Similarly everyone "
      "else in the room sees:  \"Fred reads a note.\"\n\nA description of "
      "the tree can be found in treenote.\n" }));
   add_item("treenote", ({ "long", "Read it nim wit!",
      "read", "Here is the add_item for the oak:\n"
      " add_item( ({\"large oak tree\",\"large oak\"}) , ({  \n"
      "      \"long\",\"It looks like it can be climbed and cut.\"\n"
      "      \"climb\",\"You get half way up, and climb back down.\\n\"\n"
      "      \"cut\",\"You cannot hurt this tree!\\n\"  })); \n\n"
      "Oh joy.  Notice that it always prints out:\n"
      "   \"You <verb> a large oak.\" \n"
      "It picks the first description of the item from the mixed array.\n"
      "Some times you can interfere with item commands or soul commands "
      "by installing these actions. But, the interference would be more "
      "if you used add_action!.\n" }));
   add_item( ({ "large oak tree", "large oak" }) , ({
      "long", "It looks like it can be climbed and cut.",
      "climb", "You get half way up, and climb back down.\n",
      "cut", "You cannot hurt this tree!\n" }) );
   add_exit( "east", PATH +"many_verbs", "path" );
   add_exit( "west", PATH +"many_names", "path" );
   add_exit( "start", MAIN, "path" );
   add_exit( "exit", LEARNING +"search", "path" );
}

==================================================
FILE: learning/help_topics/rooms/situations/path.h
==================================================

#include <learning.h>
#define SIT "/d/learning/help_topics/rooms/situations/"

==================================================
FILE: learning/help_topics/rooms/situations/sitroom1.c
==================================================

#include <situations.h>
#include "path.h"
inherit "/std/room";
void setup() {
  add_property( "commented functions",
                ({  }) );
  add_property( "keywords",
                ({ "situation" }) );
  set_short("Basic situation example room");
  set_light(100);
  set_long("This is a very simple situation example.  "
           "To start it \"press\" the button.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  change_situation.%^RESET%^\n");
  add_exit( "next", SIT+"sitroom2", "path" );
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  add_item( "button", "There is a button on the wall you might \"press\".");
  add_situation( "frog",
    new(class situation,
        start_mess: "A little frog appears from nowhere.\n",
        extra_look: "There is a little frog here.",
        add_items: ({ ({ "frog", "The frog is small but happy." }) }),
        chat_rate: ({ 10, 30 }),
        chats: ({"The little frog hops on the spot.",
                 "The little frog says:  Ribbit." }) ,
        end_mess: "The little frog disappears into thin air."
    )
  );
}
int do_press()
{
  tell_object(this_player(),"You press the button.\n");
  tell_object(this_player(),"%^YELLOW%^You just started the frog situation.  "
              "It will go for 60 seconds.  It adds an add_item ( look frog ), "
              "an extra_look to the room ( look ) and some chats.%^RESET%^\n");
  change_situation( "frog", 60 );
  return 1;
}
void init()
{
  this_player()->add_command( "press", this_object(), "button" );
  ::init();
}

==================================================
FILE: learning/help_topics/rooms/situations/sitroom2.c
==================================================

#include <situations.h>
#include "path.h"
inherit "/std/outside";
void setup() {
  add_property( "commented functions",
                ({  }) );
  add_property( "keywords",
                ({ "situation" }) );
  set_short("Combination of situations example room");
  set_light(40);
  set_long("This is a combination of situations example.  "
           "It is outside in a dark neighbourhood.  "
           "To start a combination of situations \"press\" the button.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  change_situation.%^RESET%^\n");
  add_exit( "next", SIT+"sitroom3", "path" );
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  add_item( "button", "There is a button on the wall you might \"press\".");
  add_item( "house", "There are old wooden houses here.");
  add_situation( "house",
    new(class situation,
      add_items: ({
        ({ "nearby house", "The wooden house has thin walls so you can "
             "easily hear what goes on inside." }),
        ({ "voice", "There are voices coming from a nearby house here." })
            }),
      end_mess: "You hear running footsteps in the alley on the other side "
             "of the house.\nThe nearby wooden house falls eerily silent."
    )
  );
  add_situation( "argue",
    new(class situation,
      chats:({"A man yells shrilly, something that sounds like an accusation.",
        "A man with a deep voice threatens loudly.",
        "A woman's voice calls for calm." }),
      chat_rate: ({ 10, 30 })
   )
  );
  add_situation( "murder",
    new(class situation,
      start_mess:"There is a loud bang, as if something fell over or "
        "was struck solidly within the wooden house here.",
      chats:({"A man says something in shocked voice.",
              "A woman's voice hisses for silence.",
              "There is the sound of something heavy being moved inside the "
              "wooden house here." }),
      chat_rate: ({ 5, 15 })
    )
  );
}
int do_press()
{
  tell_object(this_player(),"You press the button.\n");
  tell_object(this_player(),"%^YELLOW%^You just started the argue and house "                "situations.  It will go for 80 seconds and then the murder "
              "and house situations will replace it for 40 more seconds.  "
              "As house follows itself immediately it just continues without "
              "being changed and its end message is given only at the very "
              "end.%^RESET%^\n");
  change_situation( ({ "argue,house", "murder,house" }), ({ 80, 40 }) );
  return 1;
}
void init()
{
  this_player()->add_command( "press", this_object(), "button" );
  ::init();
}

==================================================
FILE: learning/help_topics/rooms/situations/sitroom3.c
==================================================

#include <situations.h>
#include "path.h"
inherit "/std/outside";
object warrior;
void setup() {
  add_property( "commented functions",
                ({  }) );
  add_property( "keywords",
                ({ "situation" }) );
  set_short("Automated situations (with function pointers) example room");
  set_light(40);
  set_long("This is a combination of situations example that is automated "
           "and makes use of function pointers.  "
           "It is outside in a run down neighbourhood.  "
           "Just wait to experience the situations within a minute or so.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  automate_situation.%^RESET%^\n");
  add_exit( "next", SIT+"sitroom4", "path" );
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  add_item( "window", "There is window up high with maroon curtains." );
  add_item( "curtain", "That is all you can see, sorry." );
  add_situation( "sew1",
    new(class situation,
      chats: ({"There is a distinct giggle.",
        "A woman's giggle drifts down from an upstairs window.",
        "A man murmurs something upstairs." }),
      chat_rate: ({ 10, 15 })
    )
  );
  add_situation( "sew2",
    new(class situation,
      start_mess: "There is a whump like something landing on a matress "
         "above.",
      chats:({
        "A high-pitched giggle reaches the street from above.",
        "There is the creak of complaining coils from an upstairs window.",
        "You can make out a muffled voice from above." }),
      chat_rate: ({ 10, 15 }),
      end_mess: "The upstairs noises stop.\nYou hear the clink of coinage.",
      end_func: (: call_out("make_warrior",5) :)
    )
  );
  add_situation( "pause", new(class situation) );
  automate_situation( ({ "sew1","sew2","pause" }), ({ 25,35,20 }),
    WHEN_ANY_TIME, 500 );
}
void make_warrior()
{
  if (warrior)
    call_out( (: $1->move( "/room/rubbish",
     "", $1->the_short()+" races off to kill something.") :), 5, warrior );
  warrior = clone_object( "/d/am/chars/am_warrior_human" );
  warrior->move(this_object(),warrior->the_short()+
    " enters the street from a building nearby looking pleased with "
    +warrior->query_objective()+"self.");
}

==================================================
FILE: learning/help_topics/rooms/situations/sitroom4.c
==================================================

#include <situations.h>
#include "path.h"
inherit "/std/outside";
void setup() {
  add_property( "commented functions",
                ({  }) );
  add_property( "keywords",
                ({ "situation" }) );
  set_short("Exclusion and random words situations example room");
  set_light(100);
  set_long("This is a of situations example that is automated "
           "and makes use of random words and exclusion.  "
           "It is at a pier where one ship may dock at a time.  "
           "Exclusion means one situation (or set of them) "
           "prevents another from happenning at the same time "
           "and vice versa.  "
           "Random words mean that the text changes each time.  "
           "Just wait to experience the situations within a minute or so.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  automate_situation.%^RESET%^\n");
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "next", SIT+"sitroom5", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  add_item( "pier", "There is small pier here." );
  add_situation( "boat1",
    new(class situation,
      start_mess: "A little fishing boat comes up to the pier.  "
         "It has the name \"#1\" painted on the side.\n"
         "A fisherman jumps off the boat and ties its painter to a post.",
      chats: ({"The little boat bobs up and down next to the pier.",
               "A fisherman hops off the little boat." }),
      chat_rate: ({ 20, 30 }),
      extra_look: "There is a little boat here.",
      add_items: ({ ({ ({ "#1","little boat" }),
        "There is little fishing boat tied up at the pier here.  "
        "The name \"#1\" is painted on the side."   }) }),
      end_mess: "The fishermen get back on board and "
         "the little boat moves on.",
      random_words: ({ ({ "Honey Toad", "Piker", "Bing" }) })
    )
  );
  add_situation( "boat2",
    new(class situation,
      start_mess: "A fat trading vessel comes up to the pier.  "
         "It has the name \"#1\" painted on the prow.\n"
         "A sailor jumps off and ties the vessel to a post.",
      chats: ({"The trading vessel thumps against the pier.",
               "A sailor comes ashore.",
               "#2 is unloaded from the vessel.",
               "#3 is loaded onto the vessel." }),
      chat_rate: ({ 10, 20 }),
      extra_look: "There is a trading vessel docked here.",
      add_items: ({ ({ ({ "#1","fat vessel","ship" }),
        "There is a trading vessel docked at the pier here.  "
          "The name \"#1\" is painted on the prow." }) }),
      end_mess: "The sailors get back on board and "
         "the trading vessel departs.",
      random_words: ({ ({ "Fat Cat", "Scumbag", "Cap Pig" }),
          ({ "A pair of slaves", "A bale of wool", "A bolt of cloth" }),
          ({ "A stock option", "A cage of frogs", "A wooden crate" }), })
    )
  );
  automate_situation( "boat2", 61, WHEN_ANY_TIME, 300, "boat" );
  automate_situation( "boat1", 50, WHEN_ANY_TIME, 200, "boat" );
}

==================================================
FILE: learning/help_topics/rooms/situations/sitroom5.c
==================================================

#include <situations.h>
#include "path.h"
inherit "/std/outside";
void setup() {
  add_property( "commented functions",
                ({  }) );
  add_property( "keywords",
                ({ "situation" }) );
  set_short("Situation with a background state example room");
  set_light(100);
  set_long("This is a situations example that is automated "
           "and makes use of a background situation.  "
           "This means that when the automated manager has not "
           "fired up the labelled automated situations you specified "
           "there is another situation that goes by default the rest "
           "of the time.  It is marked in the list by having -1 "
           "for its duration.  "
           "Please more here to see how it is done.\n"
           "%^CYAN%^Functions shown:%^RESET%^\n"
           "%^YELLOW%^add_situation,  automate_situation.%^RESET%^\n");
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  add_situation( "tramp_sleeping",
    new(class situation,
      chats: ({"The tramp snores." }),
      chat_rate: ({ 60,120 }),
      extra_look: "There is a tramp sleeping here.",
      add_items: ({ ({ "tramp",
        "There is dusty and fairly dirty tramp curled up and sleeping "
        "at one side of the road."   }) })
    )
  );
  add_situation( "tramp_awake",
    new(class situation,
      start_mess: "The tramp leaps to his feet, instantly alert.",
      chats: ({"The tramp produces some brightly coloured balls and juggles "
                 "them.",
               "The tramp does a handstand.",
               "The tramp leaps into the air and touches his toes.",
               "The tramp does a little dance.",
               "Dust billows from the frenetic tramp's clothes."
             }),
      chat_rate: ({ 20,30 }),
      extra_look: "There is a tramp bouncing around here.",
      add_items: ({ ({ "tramp",
        "The dusty tramp is bright eyed and very awake."  }) }),
      end_mess: "The tramp flops to the ground and slowly curls into a ball."
    )
  );
  automate_situation( ({ "tramp_sleeping", "tramp_awake" }),
                      ({ -1, 61 }) , WHEN_ANY_TIME, 300 );
}

==================================================
FILE: learning/help_topics/rooms/crowd/am_crippled_beggar.c
==================================================

inherit "/obj/monster";
#include "/d/am/chars/path.h"
#include <money.h>
int going;
string from;
string spouse;
int start_money;
void initial_chats() {
   load_chat( 15, ({
      1, "'Money for the crippled.",
      1, "'Please give me some money.",
      1, ":pulls on your leg.",
      1, ":rattles "+query_possessive()+" tin.",
      1, ":mutters something about a "+spouse+" and 7 children.",
      1, ":looks at you with big brown eyes.",
      1, "'Who will help me?",
      1, ":hobbles around pathetically.",
      1, "#do_gossip_say:Did you know $name$ said $mess$?",
      1, "@open door",
   }) );
}
void fix_gender( int gender ) {
   set_gender( gender );
   set_long( "This is a crippled beggar.  "
     "One of "+query_possessive()+
     " legs has wasted so that it ressembles a gnarled branch.\n" );
   spouse = (query_gender()==1) ? "wife" : "husband" ;
}
void setup() {
   set_name("beggar");
   set_short( "crippled beggar" );
   set_main_plural( "crippled beggars" );
   add_adjective("crippled");
   add_alias("beggar");
   set_race("human");
   set_level( 3 + random( 10 ) );
   set_wimpy( 80 );
   set_al( HOSPITAL->pick_al() / 10 );
   fix_gender(1+random(2));
   add_move_zone("docks");
   add_move_zone("underdocks");
   start_money = 3 + random( 300 );
   adjust_money( start_money, "Ankh-Morpork pence" );
   initial_chats();
   add_effect( "/std/effects/npc/gossip", 5 );
   add_effect( "/std/effects/npc/given", ({ this_object(), "given_thing" }));
}
void done_everything() {
   going = 0;
}
void at_pub() {
   mixed *stuff;
   string dest;
   stuff = environment()->query_menu_items();
   if (!stuff) {
      dest = PUBS[random(sizeof(PUBS))];
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   } else {
      add_effect( "/std/effects/npc/drink_silly",
                  ({ this_object(), "done_drinking" }) );
   }
}
void hassle_opposite_gender() {
  object *things;
  string action;
  things=filter(all_inventory(environment()),
      (: $1->query_gender()==3-($2->query_gender()) :), this_object() );
  if (sizeof(things)) {
     action=({ ":leers at TARGET.",
        ":pats TARGET on the bum.",
        "say How's it going sweetheart?",
        ":grins at TARGET.",
        ":wolf whistles at TARGET." })[random(5)];
     do_command(replace(action,"TARGET",
        things[random(sizeof(things))]->the_short() ));
     return;
  }
  do_command( ({ ":cracks a rude joke.",
                "drool",
                "laugh out loud",
                "say So where are the babes?",
                "burp loudly" })[random(5)] );
}
void done_drinking() {
   load_chat( 60, ({
      1, "'You rich prats never give me any respect.",
      1, "'Give me some money for booze.",
      5, "#hassle_opposite_gender",
      1, ":ponders "+query_possessive()+" empty tin.",
      1, ":chuckles something about a "+spouse+" and 7 children.",
      1, ":grins toothily at you.",
      1, "@burp",
      1, "#do_gossip_say:Do you even care that $name$ said $mess$?"
   }) );
   call_out( function() { this_object()->initial_chats();
               this_object()->add_effect( "/std/effects/npc/goto_destination",
               ({ from, ({ this_object(), "done_everything" }), 5 }) ); },
             random(300)+300 );
}
void given_thing(object player, object ob, string mess) {
   string dest;
   if (ob->id(MONEY_ALIAS)) {
      if (!going) {
         if(ob->query_value_in("Ankh-Morpork") > 300) {
            this_player()->adjust_al( -5 );
         }
         dest = PUBS[random(sizeof(PUBS))];
         add_effect( "/std/effects/npc/no_follow", 0 );
         add_effect( "/std/effects/npc/goto_destination",
                     ({ dest, ({ this_object(), "at_pub" }), 20 }) );
      }
      return ;
   }
   if (!ob->query_value()) {
      init_command("drop "+implode(ob->query_adjectives(), " ")+
                           " "+ob->query_name());
      return ;
   }
   if (!going) {
      from = file_name(environment());
      this_player()->adjust_al( -5 );
      going = 1;
      from = file_name(environment());
      init_command("'Thanks!  I always wanted "+
                   ob->a_short());
      init_command("womble");
      dest = SHOPS[random(sizeof(SHOPS))];
      add_effect( "/std/effects/npc/no_follow", 0 );
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, "sell", 20 }) );
      dest = PUBS[random(sizeof(PUBS))];
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   }
}
void loot_coins() {
   call_out( (: do_command(":looks around nervously.") :), 2 );
   call_out( (: do_command("get coins from corpse") :), 5+random(10) );
}

==================================================
FILE: learning/help_topics/rooms/crowd/am_diseased_beggar.c
==================================================

inherit "/obj/monster";
#include "/d/am/chars/path.h"
#include <money.h>
int going;
string from;
string spouse;
int start_money;
void initial_chats() {
   load_chat( 15, ({
      1, "'Money for the diseased.",
      1, "'Please give me some money.",
      1, ":pulls on your leg.",
      1, ":rattles "+query_possessive()+" tin.",
      1, ":mutters something about a "+spouse+" and 7 children.",
      1, ":looks at you with big brown eyes.",
      1, "'Who will help me?",
      1, ":picks at some sores.",
      1, "#do_gossip_say:Did you know $name$ said $mess$?",
      1, "@open door",
   }) );
}
void fix_gender( int gender ) {
   set_gender( gender );
   set_long( "This is a diseased beggar.  "
     "Looking at the running sores covering "+query_possessive()+
     " body makes your skin crawl.\n");
   spouse = (query_gender()==1) ? "wife" : "husband" ;
}
void setup() {
   set_name("beggar");
   set_short( "diseased beggar" );
   set_main_plural( "diseased beggars" );
   add_adjective("diseased");
   add_alias("beggar");
   set_race("human");
   set_level( 3 + random( 10 ) );
   set_wimpy( 80 );
   set_al( HOSPITAL->pick_al() / 10 );
   fix_gender(1+random(2));
   add_move_zone("docks");
   add_move_zone("underdocks");
   start_money = 3 + random( 300 );
   adjust_money( start_money, "Ankh-Morpork pence" );
   initial_chats();
   add_effect( "/std/effects/npc/gossip", 5 );
   add_effect( "/std/effects/npc/given", ({ this_object(), "given_thing" }));
}
void done_everything() {
   going = 0;
}
void at_pub() {
   mixed *stuff;
   string dest;
   stuff = environment()->query_menu_items();
   if (!stuff) {
      dest = PUBS[random(sizeof(PUBS))];
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   } else {
      add_effect( "/std/effects/npc/drink_silly",
                  ({ this_object(), "done_drinking" }) );
   }
}
void hassle_opposite_gender() {
  object *things;
  string action;
  things=filter(all_inventory(environment()),
      (: $1->query_gender()==3-($2->query_gender()) :), this_object() );
  if (sizeof(things)) {
     action=({ ":leers at TARGET.",
        ":pats TARGET on the bum.",
        "say How's it going sweetheart?",
        ":grins at TARGET.",
        ":wolf whistles at TARGET." })[random(5)];
     do_command(replace(action,"TARGET",
        things[random(sizeof(things))]->the_short() ));
     return;
  }
  do_command( ({ ":cracks a rude joke.",
                "drool",
                "laugh out loud",
                "say So where are the babes?",
                "burp loudly" })[random(5)] );
}
void done_drinking() {
   load_chat( 60, ({
      1, "'You rich prats never give me any respect.",
      1, "'Give me some money for booze.",
      5, "#hassle_opposite_gender",
      1, ":ponders "+query_possessive()+" empty tin.",
      1, ":chuckles something about a "+spouse+" and 7 children.",
      1, ":grins toothily at you.",
      1, "@burp",
      1, "#do_gossip_say:Do you even care that $name$ said $mess$?"
   }) );
   call_out( function() { this_object()->initial_chats();
               this_object()->add_effect( "/std/effects/npc/goto_destination",
               ({ from, ({ this_object(), "done_everything" }), 5 }) ); },
             random(300)+300 );
}
void given_thing(object player, object ob, string mess) {
   string dest;
   if (ob->id(MONEY_ALIAS)) {
      if (!going) {
         if(ob->query_value_in("Ankh-Morpork") > 300) {
            this_player()->adjust_al( -5 );
         }
         dest = PUBS[random(sizeof(PUBS))];
         add_effect( "/std/effects/npc/no_follow", 0 );
         add_effect( "/std/effects/npc/goto_destination",
                     ({ dest, ({ this_object(), "at_pub" }), 20 }) );
      }
      return ;
   }
   if (!ob->query_value()) {
      init_command("drop "+implode(ob->query_adjectives(), " ")+
                           " "+ob->query_name());
      return ;
   }
   if (!going) {
      from = file_name(environment());
      this_player()->adjust_al( -5 );
      going = 1;
      from = file_name(environment());
      init_command("'Thanks!  I always wanted "+
                   ob->a_short());
      init_command("womble");
      dest = SHOPS[random(sizeof(SHOPS))];
      add_effect( "/std/effects/npc/no_follow", 0 );
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, "sell", 20 }) );
      dest = PUBS[random(sizeof(PUBS))];
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   }
}
void loot_coins() {
   call_out( (: do_command(":looks around nervously.") :), 2 );
   call_out( (: do_command("get coins from corpse") :), 5+random(10) );
}

==================================================
FILE: learning/help_topics/rooms/crowd/am_poor_beggar.c
==================================================

inherit "/obj/monster";
#include "/d/am/chars/path.h"
#include <money.h>
int going;
string from;
string spouse;
int start_money;
void initial_chats() {
   load_chat( 15, ({
      1, "'Money for the poor.",
      1, "'Please give me some money.",
      1, ":pulls on your leg.",
      1, ":rattles "+query_possessive()+" tin.",
      1, ":mutters something about a "+spouse+" and 7 children.",
      1, ":looks at you with big brown eyes.",
      1, "'Who will help me?",
      1, ":looks down at the ground and sobs.",
      1, "#do_gossip_say:Did you know $name$ said $mess$?",
      1, "@open door",
   }) );
}
void fix_gender( int gender ) {
   set_gender( gender );
   set_long( "This is a poor beggar.  Perhaps you should give "+
            (string)query_objective() +" some money.\n" );
   spouse = (query_gender()==1) ? "wife" : "husband" ;
}
void setup() {
   set_name("beggar");
   set_short( "poor beggar" );
   set_main_plural( "poor beggars" );
   add_adjective("poor");
   add_alias("beggar");
   set_race("human");
   set_level( 3 + random( 10 ) );
   set_wimpy( 80 );
   set_al( HOSPITAL->pick_al() / 10 );
   fix_gender(1+random(2));
   add_move_zone("docks");
   add_move_zone("underdocks");
   start_money = 3 + random( 300 );
   adjust_money( start_money, "Ankh-Morpork pence" );
   initial_chats();
   add_effect( "/std/effects/npc/gossip", 5 );
   add_effect( "/std/effects/npc/given", ({ this_object(), "given_thing" }));
}
void done_everything() {
   going = 0;
}
void at_pub() {
   mixed *stuff;
   string dest;
   stuff = environment()->query_menu_items();
   if (!stuff) {
      dest = PUBS[random(sizeof(PUBS))];
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   } else {
      add_effect( "/std/effects/npc/drink_silly",
                  ({ this_object(), "done_drinking" }) );
   }
}
void hassle_opposite_gender() {
  object *things;
  string action;
  things=filter(all_inventory(environment()),
      (: $1->query_gender()==3-($2->query_gender()) :), this_object() );
  if (sizeof(things)) {
     action=({ ":leers at TARGET.",
        ":pats TARGET on the bum.",
        "say How's it going sweetheart?",
        ":grins at TARGET.",
        ":wolf whistles at TARGET." })[random(5)];
     do_command(replace(action,"TARGET",
        things[random(sizeof(things))]->the_short() ));
     return;
  }
  do_command( ({ ":cracks a rude joke.",
                "drool",
                "laugh out loud",
                "say So where are the babes?",
                "burp loudly" })[random(5)] );
}
void done_drinking() {
   load_chat( 60, ({
      1, "'You rich prats never give me any respect.",
      1, "'Give me some money for booze.",
      5, "#hassle_opposite_gender",
      1, ":ponders "+query_possessive()+" empty tin.",
      1, ":chuckles something about a "+spouse+" and 7 children.",
      1, ":grins toothily at you.",
      1, "@burp",
      1, "#do_gossip_say:Do you even care that $name$ said $mess$?"
   }) );
   call_out( function() { this_object()->initial_chats();
               this_object()->add_effect( "/std/effects/npc/goto_destination",
               ({ from, ({ this_object(), "done_everything" }), 5 }) ); },
             random(300)+300 );
}
void given_thing(object player, object ob, string mess) {
   string dest;
   if (ob->id(MONEY_ALIAS)) {
      if (!going) {
         if(ob->query_value_in("Ankh-Morpork") > 300) {
            this_player()->adjust_al( -5 );
         }
         dest = PUBS[random(sizeof(PUBS))];
         add_effect( "/std/effects/npc/no_follow", 0 );
         add_effect( "/std/effects/npc/goto_destination",
                     ({ dest, ({ this_object(), "at_pub" }), 20 }) );
      }
      return ;
   }
   if (!ob->query_value()) {
      init_command("drop "+implode(ob->query_adjectives(), " ")+
                           " "+ob->query_name());
      return ;
   }
   if (!going) {
      from = file_name(environment());
      this_player()->adjust_al( -5 );
      going = 1;
      from = file_name(environment());
      init_command("'Thanks!  I always wanted "+
                   ob->a_short());
      init_command("womble");
      dest = SHOPS[random(sizeof(SHOPS))];
      add_effect( "/std/effects/npc/no_follow", 0 );
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, "sell", 20 }) );
      dest = PUBS[random(sizeof(PUBS))];
      add_effect( "/std/effects/npc/goto_destination",
                  ({ dest, ({ this_object(), "at_pub" }), 20 }) );
   }
}
void loot_coins() {
   call_out( (: do_command(":looks around nervously.") :), 2 );
   call_out( (: do_command("get coins from corpse") :), 5+random(10) );
}

==================================================
FILE: learning/help_topics/rooms/crowd/crowd.c
==================================================

#include <parse_command.h>
#include "path.h"
#define MAXATONCE 6
inherit "/std/object";
class member {
  string file;
  string short;
  string *adjectives;
  string *names;
  string *plurals;
  string long;
  int *original_number;
}
int n_alive, n_crowd, n_selection, n_cloned, n_here, n_max=MAXATONCE;
int *crowd,*selection;
mixed *here;
mixed *_m_names;
mixed *_m_plurals;
mixed *_m_adjectives;
mixed store=({});
int cnt=0;
mixed query_store() { return ({ store, cnt }); }
int lookflag=0;
int lastmatch=0;
int i_member=0;
mixed *members = ({
  new(class member,
     file : CROWD+"am_poor_beggar",
     short : "poor beggar",
     long : "This is a poor beggar.  "
     "Perhaps you should give $OBJ$ some money.\n"
     "$PRO$ is in good shape.\n"
     "$PRO$ is standing.\n",
     original_number : ({ 0,13,15 }) ),
  new(class member,
     file : CROWD+"am_diseased_beggar",
     short : "diseased beggar",
     long : "This is a diseased beggar.  "
     "Looking at the running sores covering $POSS$ body makes your skin crawl.\n"
     "$PRO$ is in good shape, considering.\n"
     "$PRO$ is standing.\n",
     original_number : ({ 0,17,2 }) ),
  new(class member,
     file : CROWD+"am_crippled_beggar",
     short : "crippled beggar",
     long : "This is a crippled beggar.  "
     "One of $POSS$ legs has wasted so that it ressembles a gnarled branch.\n"
     "$PRO$ is in good shape.\n"
     "$PRO$ is standing awkwardly.\n",
     original_number : ({ 0,6,11 }) )
});
int *query_crowd() { return ({ selection, crowd }); }
int query_n_crowd() { return n_crowd; }
int query_visible() { return n_crowd; }
int group_object() { return n_crowd-1; }
string include_gender( string long, int gender ) {
  switch ( gender ) {
  case 2:
    return
      replace( long, ({ "$POSS$","her","$OBJ$","her","$PRO$","She" }) );
  default:
    return
      replace( long, ({ "$POSS$","his","$OBJ$","him","$PRO$","He" }) );
  }
}
string long(string word, int dark) {
  int i;
  string ret="";
  if ( !lookflag ) {
    foreach (i in crowd) ret += include_gender( (members[i>>2])->long, i&3 );
    return ret;
  }
  else if ( lastmatch ==  0 ) {
    foreach (i in selection )
      ret += include_gender( (members[i>>2])->long, i&3 );
    return ret;
  }
  else if ( lastmatch > 0 ) {
    foreach (i in selection[0..(lastmatch-1)] )
      ret += include_gender( (members[i>>2])->long, i&3 );
    return ret;
  }
  else if (-lastmatch <= sizeof(selection)) {
    i = selection[-lastmatch-1];
    return include_gender( members[i>>2]->long, i&3 );
  }
  return ret;
}
string a_short() {
  string ret="";
  int i,n_match;
  string prev=file_name(previous_object(1));
  if ( prev == "/cmds/living/glance" ||
       prev == "/cmds/living/l_ook" ) {
    lookflag = 0;
    i_member = 0;
    selection = crowd;
    n_selection = n_crowd;
  }
  else if ( file_name(previous_object()) != "/cmds/living/glance" ) {
    lookflag = 0;
  }
  n_match = n_selection;
  if (lookflag && lastmatch && lastmatch < n_match)
    n_match = (lastmatch > 0 ? lastmatch : 1);
  for (i=i_member;i<n_match;i++) {
    ret+="$a_short:"+ file_name(load_object(members[selection[i]>>2]->file)) +"$";
  }
  if (lookflag) { ret = "$M$" + ret + "$M$"; }
  return ret;
}
string the_short() {
  string ret="";
  int i;
  for (i=0;i<n_crowd;i++)
    ret+="$the_short:"+ file_name( this_object() ) +"$";
  return ret;
}
string one_short() {
  string ret="";
  int i;
  for (i=0;i<n_crowd;i++)
    ret+="$one_short:"+ file_name( this_object() ) +"$";
  return ret;
}
string poss_short() {
  return a_short();
}
varargs string short(int dark) {
  return "crowd";
}
void create() {
  class member p;
  int i,j,k;
  string *tmp;
  string *adjs = ({});
  string *names = ({});
  ::create();
  set_name("beggar");
  set_short("crowd of crowd.");
  set_long("This is a crowd of people.");
  enable_commands();
  crowd = ({ });
  for (j=0; j<sizeof(members);j++) {
    p = members[j];
    tmp = explode(p->short," ");
    p->names = ({ tmp[<1] });
    p->plurals = ({ pluralize(tmp[<1]) });
    names += ({ tmp[<1] });
    p->adjectives = tmp[0..<2];
    adjs += tmp[0..<2];
    for (k=0;k<sizeof(p->original_number);k++)
      for (i=0; i<(p->original_number)[k]; i++) crowd += ({ (j<<2)+k });
  }
  crowd = shuffle(shuffle(crowd));
  n_crowd = sizeof(crowd);
  n_alive = sizeof(crowd);
  n_cloned = 0;
  here = ({ });
  n_here = 0;
  _m_names = ({});
  _m_plurals = ({});
  while(sizeof(names)) {
    _m_names += ({ names[0] });
    _m_plurals += ({ pluralize(names[0]) });
    names-= ({ names[0] });
  }
  _m_adjectives = ({});
  while(sizeof(adjs)) {
    _m_adjectives += ({ adjs[0] });
    adjs-= ({ adjs[0] });
  }
}
void crowd_member_died( ) {
  n_alive--;
  n_cloned--;
  if (!n_alive) dest_me();
}
void merge_crowd_member( object member ) {
  tell_room(environment(),"%^YELLOW%^"+sprintf("%O reabsorbed into %O", member, this_object())+"%^RESET%^\n");
  if (member && environment(member)==environment() ) {
    int i;
    for (i=0;i<sizeof(members);i++) {
      if ( base_name(member) == members[i]->file ) {
        n_cloned--;
        n_crowd++;
        n_here--;
        here -= ({ member->crowd_number() });
        n_max = MAXATONCE - ((n_here + n_cloned) >> 2);
        if ( n_max < 1 ) n_max = 1;
        crowd = ({ (i<<2)+member->query_gender() }) + crowd;
        member->dest_me();
      }
    }
  }
}
object make_member() {
  object frog;
  int i,j;
  if (i_member<0 || i_member>=sizeof(selection)) i_member=0;
  i = selection[i_member];
  j = member_array( i, crowd );
  frog = clone_object(members[i>>2]->file);
  if (frog) {
    n_crowd--;
    n_cloned++;
    n_here++;
    n_max = (n_max+1)>>1;
    n_selection--;
    crowd = crowd[0..j-1] + crowd[j+1..<1];
    selection = selection[0..i_member-1]+selection[i_member+1..<1];
    crowd = crowd[0..j-1] + crowd[j+1..<1];
    here += ({ i });
    tell_room(environment(),"%^YELLOW%^"+sprintf("Cloned %O : %i of %i selected (%i remaining)",frog,i_member+1,sizeof(selection)+1,n_crowd)+"%^RESET%^\n");
    frog->fix_gender( i&3 );
    frog->add_effect( CROWD+"crowd_merge_effect", ({ this_object(), i }) );
    frog->move( environment(this_object()) );
  }
  return frog;
}
string *parse_command_id_list() {
  return _m_names;
}
string *parse_command_plural_id_list() {
  return _m_plurals;
}
string *parse_command_adjectiv_id_list() {
  return _m_adjectives;
}
mixed query_parse_id(mixed *arr) {
   string *bits, bat;
   int i;
   selection = ({ });
   i_member = 0;
   if (!n_crowd) return 0;
   lastmatch=arr[P_THING];
   switch (query_verb()) {
   case 0:
   case "look":
   case "glance":
   case "destruct":
   case "lose":
   case "trans":
     lookflag=1;
     break;
   default:
     lookflag=0;
   }
   bits = explode(arr[P_STR]," ");
   bat = bits[<1];
   selection = copy(crowd);
   if ( member_array( bat, _m_names ) != -1 ) {
     for (i=0;i<sizeof(members);i++) {
       if ( member_array( bat, members[i]->names ) == -1)
         selection -= ({ (i<<2)+1, (i<<2)+2 });
     }
     while (sizeof(bits = bits[0..<2])) {
       bat = bits[<1];
       if ( member_array( bat, _m_adjectives ) != -1 ) {
         for (i=0;i<sizeof(members);i++) {
           if ( member_array( bat, members[i]->adjectives ) == -1)
             selection -= ({ (i<<2)+1, (i<<2)+2 });
         }
       }
     }
   }
   else if ( member_array( bat, _m_plurals ) != -1 ) {
     for (i=0;i<sizeof(members);i++) {
       if ( member_array( bat, members[i]->plurals ) == -1)
         selection-= ({ (i<<2)+1, (i<<2)+2 });
     }
     while (sizeof(bits = bits[0..<2])) {
       bat = bits[<1];
       if ( member_array( bat, _m_adjectives ) != -1 ) {
         for (i=0;i<sizeof(members);i++) {
           if ( member_array( bat, members[i]->adjectives ) == -1)
             selection -= ({ (i<<2)+1, (i<<2)+2 });
         }
       }
     }
   }
   if (!(n_selection = sizeof(selection))) return 0;
   if (lookflag) {
     if (lastmatch < 0) i_member = -lastmatch-1;
     if (arr[P_THING] == 0) return this_object();
     if (arr[P_THING] < 0) {
        arr[P_THING]+=n_selection;
        if (arr[P_THING] <0) {
          return 0;
        }
        arr[P_THING] = -10321;
        return this_object();
     }
     if (arr[P_THING] != 1) {
       i=arr[P_THING];
       if (i>n_selection) i = n_selection;
       arr[P_THING]-=i;
       if (!arr[P_THING]) arr[P_THING] = -10101;
       return this_object();
     }
     arr[P_THING] = -10101;
     return this_object();
   }
   if (arr[P_THING] == 0) {
      object *things=({ });
      i = n_max;
      if (i>n_selection) i = n_selection;
      while (i--) things += ({ make_member() });
      return things;
   }
   if (arr[P_THING] < 0) {
      i_member = -arr[P_THING]-1;
      arr[P_THING]+=n_selection;
      if (arr[P_THING] <0) {
         return 0;
      }
      arr[P_THING] = -10321;
      return make_member();
   }
   if (arr[P_THING] != 1) {
      object *things=({ });
      i=arr[P_THING];
      if (i>n_selection) i = n_selection;
      if (i>n_max) i = n_max;
      while (i--) {
         arr[P_THING]--;
	 things += ({ make_member() });
      }
      if (!arr[P_THING]) arr[P_THING] = -10101;
      return things;
   }
   arr[P_THING] = -10101;
   return make_member();
}
void event_enter( object ob, string message, object from ) {
  if (from) {
    object *things;
    n_here = sizeof( things = filter(all_inventory( environment() ),
      (: $1->crowd_object() == this_object() :) ));
    here = ({ });
    if ( n_here ) here = map( things, (: $1->crowd_number() :) );
    n_max = MAXATONCE - ((n_here + n_cloned) >> 2);
    if ( n_max < 1 ) n_max = 1;
    tell_creator("shaggy","ENTER %O: n_here: %i n_cloned: %i n_alive: %i n_crowd:%i n_max: %i %O\n",from,n_here,n_cloned,n_alive,n_crowd,n_max, here);
  }
}
void event_exit( object ob, string message, object to ) {
  object *things;
  n_here = sizeof( things = filter(all_inventory( environment() ),
     (: $1->crowd_object() == this_object() :) ));
  here = ({ });
  if ( n_here ) here = map( things, (: $1->crowd_number() :) );
  n_max = MAXATONCE - ((n_here + n_cloned) >> 2);
  if ( n_max < 1 ) n_max = 1;
  tell_creator("shaggy","EXIT: n_here: %i n_cloned: %i n_alive: %i n_crowd:%i n_max: %i %O\n",n_here,n_cloned,n_alive,n_crowd,n_max, here);
}

==================================================
FILE: learning/help_topics/rooms/crowd/crowd_merge_effect.c
==================================================

#include <effect.h>
#include "path.h"
#define SHADOWS  CROWD
mixed beginning( object player, mixed arg, int id ) {
  call_out( (: $1->crowd_merge() :), 5, player );
}
mixed merge_effect( object player, mixed oldarg, mixed newarg, int id ) {
   return newarg;
}
string query_classification() { return "npc.crowd.merge"; }
string query_shadow_ob() { return SHADOWS + "crowd_merge_shadow"; }

==================================================
FILE: learning/help_topics/rooms/crowd/crowd_merge_shadow.c
==================================================

#include <move_failures.h>
inherit "/std/effect_shadow";
int actually_attacked=0;
varargs void crowd_merge() {
  object crowd,thing;
  object *list;
  crowd=(arg())[0];
  if (!crowd) {
    int *effs=player->effects_matching("npc.crowd.merge");
    player->delete_effect(effs[0]);
    return;
  }
  if (sizeof(player->query_attacker_list()) ||
     (player->query_hp()<player->query_max_hp())) {
    call_out( "crowd_merge", 60 );
    return;
  }
  if (actually_attacked) {
    foreach( thing in filter(all_inventory(environment(player)),
          (: living($1) :) )) {
      if ( (list = thing->query_attacker_list())
           && member_array(player,list) != -1 ) {
        call_out( "crowd_merge", 60 );
        return;
      }
    }
  }
  if ( environment(player) == environment(crowd) ) {
    crowd->merge_crowd_member( player );
    return;
  }
  player->add_effect( "/std/effects/npc/goto_destination",
    ({ file_name(environment(crowd)),
       ({ this_object(), "crowd_merge" }), 1 }) );
}
int attack_by( object thing ) {
  actually_attacked=1;
  return player->attack_by( thing );
}
object crowd_object( ) { return (arg())[0]; }
object crowd_number() { return (arg())[1]; }
object do_death( object thing) {
   if ((arg())[0]) ((arg())[0])->crowd_member_died();
   return player->do_death( thing );
}

==================================================
FILE: learning/help_topics/rooms/crowd/crowdroom.c
==================================================

#include "path.h"
inherit "/std/room";
object crowd;
void setup() {
  add_property( "commented functions",
                ({  }) );
  add_property( "keywords",
                ({ "crowd" }) );
  set_short("crowd demonstration room");
  set_light(100);
  set_long("This is a room to contain a crowd of NPC's.  "
           "It is intend to be a venue to test and try out "
           "the crowd NPC object and related files:\n"
           "%^YELLOW%^/d/am/learning/help_topics/crowd/crowd.c\n"
           "/d/am/learning/help_topics/crowd/crowd_merge_effect.c\n"
           "/d/am/learning/help_topics/crowd/crowd_merge_shadow.c"
           "%^RESET%^\n"
           "You can %^CYAN%^inv here%^RESET%^ to see objects present.  "
           "You can also attack the beggars as NPCs may not use the exits.\n");
  add_exit( "back", LEARNING +"search", "path" );
  add_exit( "exit", ENTRANCE, "path" );
  modify_exit( "back", ({ "function", (: interactive($2) :) }) );
  modify_exit( "exit", ({ "function", (: interactive($2) :) }) );
}
void reset() {
  if (!crowd) {
    crowd=clone_object( CROWD+"crowd" );
    crowd->move( this_object() );
  }
}

==================================================
FILE: learning/help_topics/rooms/crowd/path.h
==================================================

#include <learning.h>
#define CROWD "/d/learning/help_topics/rooms/crowd/"

==================================================
FILE: learning/help_topics/objects/container_save.c
==================================================

#include "path.h"
inherit "/std/room";
object shelf, wardrobe;
void setup() {
   set_short("room of shelf and wardrobe examples");
   add_property( "determinate", "the " );
   set_long( "This room gives some simple examples of how to make shelves, "
            "wardrobes and such that'll save the content for you.\n"
            "To make a shelf, which is characterized by having a surface "
            "you can put things on, you make a clone of /obj/surf_save, "
            "configure it like all cloned objects, and call set_save_file( "
            "file_name ) do tell what file should be used to save the "
            "objects that are put on it.  If the savefile isn't in /save/ "
            "you should call check_euid() on the shelf before calling "
            "set_save_file().\n"
            "Making a wardrobe, you do the same, except you that it is "
            "/obj/cont_save you should clone.\n"
            "Note that since these are fixed parts of the room, and not "
            "something that is put here, I clone them directly in reset() "
            "instead of doing a call_out() to a function that makes them.\n" );
   set_light( 100 );
   add_exit( "back", LEARNING +"search", "path" );
   add_exit( "exit", ENTRANCE, "path" );
   add_property( "commented functions",
                ({ "check_euid", "set_save_file" }) );
   add_property( "keywords",
                ({ "shelf", "wardrobe", "save" }) );
}
void reset() {
   if (!shelf) {
      shelf = clone_object("/obj/surf_save");
      shelf->set_name( "shelf" );
      shelf->set_short( "oaken shelf" );
      shelf->add_adjective( "wooden" );
      shelf->add_adjective( "oak" );
      shelf->add_adjective( "oaken" );
      shelf->add_property( "there", "hanging from the wall" );
      shelf->set_long( "This shelf is made from oak and "
                      "varnished to bring out the glow.\n" );
      shelf->set_weight( 2000 );
      shelf->set_max_weight( 2000 );
      shelf->reset_get();
      shelf->check_euid();
      shelf->set_save_file( SAVEPATH+"/oak_shelf" );
      shelf->move( this_object() );
   }
   if (!wardrobe) {
      wardrobe = clone_object("/obj/cont_save");
      wardrobe->set_name( "wardrobe" );
      wardrobe->set_short( "oaken wardrobe" );
      wardrobe->add_adjective( "wooden" );
      wardrobe->add_adjective( "oaken" );
      wardrobe->add_adjective( "oak" );
      wardrobe->set_long( "This wardrobe is made from oak and "
                         "varnished to bring out the glow.\n" );
      wardrobe->set_weight( 2000 );
      wardrobe->set_max_weight( 2000 );
      wardrobe->reset_get();
      wardrobe->check_euid();
      wardrobe->set_save_file( SAVEPATH+"/wardrobe" );
      wardrobe->move( this_object() );
   }
}

==================================================
FILE: learning/help_topics/objects/path.h
==================================================

#include <learning.h>
#define PATH HELP + "objects/"

==================================================
FILE: learning/help_topics/objects/vessel.c
==================================================

#include "path.h"
inherit "/std/room";
object wine_bottle, glass, cup;
void setup() {
   set_short("room of vessel and liquid examples");
   add_property( "determinate", "the " );
   set_long( "This room gives some simple examples of using vessels.  "
            "There should be a wine bottle, a wine glass, and a "
            "coffee cup in here.  There are also a few usage notes "
            "on the wall (\"read note1\", \"read note2\", etc).\n" );
   set_light( 100 );
   add_item( "note1",
            ({ "long", "This note describes how to use the vessels.",
               "read", "The vessels all have the following commands: "
                   "pour, fill, drink, empty.  There are a few others, "
                  "but they're mainly carry-overs from the old "
                  "container code, and probably don't work correctly.  "
                  "Try pouring from one object to another, drinking, etc.  "
                  "Try mixing equal parts of wine and Klatchian coffee.  "
                  "Use the \"stat\" command to check on the volumes (eg, "
                  "\"stat bottle\", \"stat all in cup\").  If you want "
                  "to start over with a fresh vessel, dest it and "
                  "\"call reset() here\".\n"
            }) );
   add_item( "note2",
            ({ "long", "This is a little note on liquid units of measure.",
               "read", "The base unit for a liquid is the drop.  Four "
                  "drops is roughly 1 cc, and 200 drops of water weighs "
                  "one Discworld weight unit.  Here are some common "
                  "amounts (I believe these are all British measures, "
                  "but I could have made an error):\n"
                  "    1 teaspoon =      20 drops\n"
                  "    1 tablespoon =    60 drops\n"
                  "    1 ounce =        120 drops\n"
                  "    1 cup =          960 drops\n"
                  "    1 pint =        2400 drops\n"
                  "    1 quart =       4800 drops\n"
                  "    1 gallon =     19200 drops\n"
            }) );
   add_item( "note3",
            ({ "long", "This is a note on adding effects to food, "
                  "especially liquids.",
               "read", "To add an effect to food so that it will be "
                  "applied to the player when consumed, use "
                  "add_eat_effect(<effect>, <arg>).  <arg> (which "
                  "should be an integer) is multiplied by the weight "
                  "of the amount consumed; for liquids, this is generally "
                  "200 drops per weight unit.\n\n"
                  "For example, the wine in the wine bottle adds the "
                  "drunk effect; a final <arg> of 3900 for this effect "
                  "will last 10 minutes on a player with constitution 13 "
                  "(trust me on this).  If we want one pint (2400 drops) "
                  "of wine to have this effect, the <arg> to "
                  "add_eat_effect() should be 3900/(2400/200), or "
                  "325.\n"
            }) );
   add_item( "note4",
            ({ "long", "This is a note on using continuous objects.",
               "read", "Continuous objects (those derived from "
                  "/obj/cont_medium, such as /obj/food) are a way "
                  "to have multiple identical instances of an item "
                  "without having to have a clone for each one.  Each "
                  "unique continuous object is identified by its "
                  "\"medium alias\".  The medium alias must be a single "
                  "word without embedded spaces; by convention, it is "
                  "made by concatenating a series of capitalized words "
                  "that describe it, such as \"RedWine\" or "
                  "\"GroundPurpleMushroom\".  All objects with a common "
                  "medium alias in the same environment are combined "
                  "into a single object.  Also, the reaction handler "
                  "uses the medium alias to identify objects that "
                  "react with one another.\n"
            }) );
   add_exit( "back", LEARNING +"search", "path" );
   add_exit( "exit", ENTRANCE, "path" );
   add_property( "commented functions",
                ({ "make_bottle", "add_eat_effect", "set_medium_alias",
                   "set_max_weight", "set_max_volume" }) );
   add_property( "keywords",
                ({ "bottle", "vessel", "liquid" }) );
}
void reset() {
   call_out( "check_vessels", 3 );
}
void check_vessels() {
   object wine, coffee;
   if ( !wine_bottle || ( environment( wine_bottle ) != this_object() ) ) {
      wine_bottle = clone_object( "/obj/bottle" );
      wine_bottle->make_bottle( "green", 600 );
      wine_bottle->move( this_object(), "Jeremy walks into the room and "
                        "leaves $N before walking out again." );
      wine = clone_object( "/obj/reagents/generic_liquid.ob" );
      wine->set_name( "wine" );
      wine->set_short( "red wine" );
      wine->set_long( "This is a deep red wine, $amount_size$.\n");
      wine->set_medium_alias( "RedWine" );
      wine->add_adjective( "red" );
      wine->add_eat_effect( "/std/effects/ingested/drunk", 325 );
      wine->set_amount( 2400 );
      wine->move( wine_bottle );
   }
   if ( !glass || ( environment( glass ) != this_object() ) ) {
      glass = clone_object( "/obj/vessel" );
      glass->set_name( "glass" );
      glass->set_short( "wine glass" );
      glass->set_long( "This is a fine crystal wine glass.\n" );
      glass->set_weight( 4 );
      glass->set_max_weight( 8 );
      glass->set_max_volume( 480 );
      glass->add_adjective( ({ "crystal", "wine" }));
      glass->move( this_object(), "Jeremy walks into the room and "
                        "leaves $N before walking out again.");
   }
   if ( !cup || ( environment( cup ) != this_object() ) ) {
      cup = clone_object( "/obj/vessel" );
      cup->set_name( "cup" );
      cup->set_short( "coffee cup" );
      cup->set_long( "This is a delicate china coffee cup.  The intricate "
                    "artwork on the side depicts some sort of sexual "
                    "orgy.  Why it's on a coffee cup is beyond me.\n" );
      cup->set_weight( 4 );
      cup->set_max_weight( 8 );
      cup->set_max_volume( 960 );
      cup->add_adjective( ({ "china", "coffee" }) );
      cup->move( this_object(), "Jeremy walks into the room and "
                "leaves $N before walking out again." );
      coffee = clone_object( "/obj/reagents/generic_liquid.ob" );
      coffee->set_name( "coffee" );
      coffee->set_short( "coffee" );
      coffee->set_long( "This is some Klatchian coffee, $amount_size$.  "
                       "It is very dark and aromatic.\n" );
      coffee->set_medium_alias( "KlatchianCoffee" );
      coffee->add_adjective( "klatchian" );
      coffee->add_eat_effect( "/std/effects/ingested/knurd", 325 );
      coffee->set_amount( 960 );
      coffee->move( cup );
   }
}

==================================================
FILE: learning/TinyTown/roads/path.h
==================================================

#include <learning.h>
#define PATH TTOWNROADS

==================================================
FILE: learning/TinyTown/roads/womble01.c
==================================================

#include "path.h"
inherit "/std/room/outside";
void setup() {
  add_property( "determinate", "the " );
  set_short( "southwestern corner of Womble square" );
  set_long("This is the western edge of Tiny Town, a small "
           "town built as an example for new creators who might want to see "
           "how to make rooms, npc's and such without the complexity of "
           "the \"real\" domains.\n");
  set_zone( "Tiny Town");
  set_linker(({ PATH +"womble02", PATH +"womble03", PATH +"womble04", }),
             "into", "", "Womble Square" );
  add_exit( "north", PATH +"womble03", "road" );
  add_exit( "northeast", PATH +"womble04", "hidden" );
  add_exit( "east", PATH +"womble02", "road" );
  add_exit( "south", TTOWNBUILDINGS +"item-shop", "door" );
  modify_exit( "south", ({
    "exit mess", "$N leave$s through the door to the south.",
      "enter mess", ({
        1,
          "Chimes start playing as $N enters.",
          "Chimes start playing as $N enter." }),
      "move mess", "Chimes start playing as you enter the shop.\n"
      }));
  set_wall( ({ "move", ({ "up", 100, TTOWNBUILDINGS + "shop-ledge",
                            "$N climb$s up from below." }) }) );
}

==================================================
FILE: learning/TinyTown/roads/womble02.c
==================================================

#include "path.h"
inherit "/std/room/outside";
void setup() {
  add_property( "determinate", "the " );
  set_short( "southeastern corner of Womble square" );
  set_long("This is the eastern edge of Tiny Town, a small "
           "town built as an example for new creators who might want to see "
           "how to make rooms, npc's and such without the complexity of "
           "the \"real\" domains.\n");
  set_zone( "Tiny Town");
  set_linker(({ PATH +"womble01", PATH +"womble03", PATH +"womble04", }),
             "into", "", "Womble Square" );
  add_exit( "north", PATH +"womble04", "road" );
  add_exit( "northwest", PATH +"womble03", "hidden" );
  add_exit( "west", PATH +"womble01", "road" );
}

==================================================
FILE: learning/TinyTown/roads/womble03.c
==================================================

#include "path.h"
inherit "/std/room/outside";
void setup() {
  add_property( "determinate", "the " );
  set_short( "northwestern corner of Womble square" );
  set_long("This is the western edge of Tiny Town, a small "
           "town built as an example for new creators who might want to see "
           "how to make rooms, npc's and such without the complexity of "
           "the \"real\" domains.\n");
  set_zone( "Tiny Town");
  set_linker(({ PATH +"womble01", PATH +"womble03", PATH +"womble04", }),
             "into", "", "Womble Square" );
  add_exit( "south", PATH +"womble01", "road" );
  add_exit( "southeast", PATH +"womble02", "hidden" );
  add_exit( "east", PATH +"womble04", "road" );
}

==================================================
FILE: learning/TinyTown/roads/womble04.c
==================================================

#include "path.h"
inherit "/std/room/outside";
void setup() {
  add_property( "determinate", "the " );
  set_short( "northeastern corner of Womble square" );
  set_long("This is the eastern edge of Tiny Town, a small "
           "town built as an example for new creators who might want to see "
           "how to make rooms, npc's and such without the complexity of "
           "the \"real\" domains.\n");
  set_zone( "Tiny Town");
  set_linker(({ PATH +"womble03", PATH +"womble01", PATH +"womble02", }),
             "into", "", "Womble Square" );
  add_exit( "south", PATH +"womble02", "road" );
  add_exit( "southwest", PATH +"womble01", "hidden" );
  add_exit( "west", PATH +"womble03", "road" );
}

==================================================
FILE: learning/TinyTown/buildings/item-shop.c
==================================================

#include "path.h"
inherit "/std/shops/item_shop";
void setup() {
  add_property( "determinate", "A " );
  set_short( "simple item shop" );
  set_long( "This is a nice looking shop.  Obviously your shop would have "
            "a much more interesting description.\n");
  set_light( 60 );
  set_room_size( 10 );
  set_zone( "Tiny Town");
  add_exit( "north", TTOWNROADS +"womble01", "door" );
  modify_exit( "nouth", ({
    "exit mess", "Chimes start playing as $N "
      "leave$s through the north door.",
      "enter mess", ({
        1,
          "$N enters from the south.",
          "$N enter from the south." }),
      "move mess", "Chimes start playing as you leave the shop.\n"
      }));
  add_exit("up", PATH+"shop-upstairs", "stair");
  modify_exit("up", ({"upgrade", 9 }));
}

==================================================
FILE: learning/TinyTown/buildings/path.h
==================================================

#include <learning.h>
#define PATH TTOWNBUILDINGS

==================================================
FILE: learning/TinyTown/buildings/shop-ledge.c
==================================================

#include "path.h"
inherit "/std/room/rooftop";
void setup() {
  set_short( "small ledge" );
  set_long( "This is a small ledge just outside the upstairs window of "
						"the item shop.\n");
  set_room_size( 10 );
	set_slope(60, "ledge", TTOWNROADS + "womble01");
	set_weak_messages("The ledge crumbles under your weight.\n",
										"$short$ falls from the crumbling ledge.",
										"$short$ comes crashing to the ground.",
                                                                                "The ledge makes a strange sound.");
	set_weak_roof(2500, TTOWNROADS + "womble01");
	add_exit("window", PATH+"shop-upstairs", "window");
	set_wall( ({ "bottom", ({ TTOWNROADS + "womble01", 200 }), }) );
	set_wall( ({ "move", ({ "down", 30, TTOWNROADS + "womble01",
														"$N climb$s down from above." }) }) );
}

==================================================
FILE: learning/TinyTown/buildings/shop-upstairs.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
void setup() {
  set_short( "bedroom" );
  set_long( "This is a small bedroom above the shop.  There is a window "
            "in the north wall.\n");
  set_light( 60 );
  set_room_size( 10 );
  set_zone( "Tiny Town");
  add_exit("window", PATH+"shop-ledge", "window");
  add_exit("down", PATH +"item-shop", "stair" );
  modify_exit("down", ({ "downgrade", 9 }));
}

==================================================
FILE: learning/functions/function_room.c
==================================================

#include "path.h"
#include <map.h>
inherit "/std/room/basic_room";
string function_chosen;
void setup() {
   set_short( "uninitialised search room for functions" );
   set_long( "You are in an uninitialized search room.  "
            "This is an example of a room that gets cloned and configured "
            "afterwards.  In this room, it's the function set_marker that's "
            "used to define its look, and most if the exits as well.  And "
            "the function set_destination that is used to find, possibly "
            "clone and configure, the rooms that fit the keywords you search "
            "for.  The handler called SEARCH in the code, is \""+
            SEARCH +"\" and the one called QUIT_HANDLER, is \""+
            QUIT_HANDLER +"\".\n" );
   add_property( "no map", 1 );
   set_light( 50 );
   add_exit( "exit", PATH +"functions", "path" );
   add_property( "commented functions",
                ({ "set_destination", "query_quit_handler",
                   "query_cloning_info" }) );
   add_property( "keywords", ({ "room", "virtual" }) );
}
string query_marker() {
   return function_chosen;
}
void set_marker( string word ) {
   string description, exit_letter, exit_room, exit;
   set_short( "\""+ word +"\" search room" );
   add_property( "determinate", "the " );
   function_chosen = word;
   description = "You have chosen to see the rooms describing the use of the "
         "function "+ function_chosen +".";
   description += "$I$5=Take one of the lettered exits to go to that room.";
   exit_letter = "a";
   foreach( exit_room in (string *)SEARCH->query_rooms_with_function( word ) ) {
      exit = sprintf( "%s: %s",
                     exit_letter,
                     (string)MAP->query_short( exit_room ) );
      add_exit( exit_letter, exit_room, "path" );
      description += "\n$C$"+ exit +".";
      exit_letter[ 0 ]++;
   }
   description += "$I$0=\n";
   set_long( description );
}
void check_empty() {
   if ( sizeof( all_inventory( this_object() ) ) )
      return;
   dest_me();
}
string query_quit_handler() { return QUIT_HANDLER; }
mixed *query_cloning_info() {
   return ({ SEARCH, "find_function_room", function_chosen });
}
void event_exit( object thing, string mess, object to ) {
   string handler;
   if ( find_call_out( "check_empty" ) == -1 )
      call_out( "check_empty", 10 );
   if ( file_name( to ) == "/room/departures" )
      return;
   handler = query_quit_handler();
   if ( (string)to->query_quit_handler() != handler )
      handler->remove_from_list( thing );
}

==================================================
FILE: learning/functions/path.h
==================================================

#include <learning.h>
#define PATH FUNCTIONS

==================================================
FILE: learning/examples/player_houses/npcs/surface_decorator.c
==================================================

inherit "/std/npc/surface_decorator";
void setup() {
    set_name( "worker" );
    set_short( "construction worker" );
    add_property( "determinate", "a " );
    add_adjective( "construction" );
    add_property( "unique", 1 );
    setup_nationality( "/std/nationality/agatean", "Bes Pelargic" );
    basic_setup( "human", "warrior", 30 );
    set_gender( 1 );
    set_long("This is a construction worker.  You can use him to "
        "decorate surfaces in player housing to the exact specifications "
        "that you will set later in this file.  He is slightly grubby, "
        "is covered in dust and paint, and likes to do wolf whistles.\n");
    add_property( "place", "Counterweight Continent" );
    add_allowed_surface( "floor" );
    add_allowed_surface( "wall" );
    add_fitted_surface( "plush green carpet", "covered with plush "
        "green carpet", 1000 );
    add_fitted_surface( "plush red carpet", "covered with plush "
        "red carpet", 1000 );
    add_fitted_surface( "plush yellow carpet", "covered with plush "
        "yellow carpet", 1000 );
    add_fitted_surface( "plush blue carpet", "covered with plush "
        "blue carpet", 1000 );
    set_under_construction_mess( "covered in dust, plaster and carpet bits" );
    add_allowed_domain( "/w/una" );
    add_allowed_domain( "/d/cwc/Bes_Pelargic" );
    set_responses( ({
        "'I don't fit those kinds of surfaces matey!",
        "'I've never heard of those sort of carpets, arrrrr.",
        "'Arr, you don't own this place, mister!",
        "'I can't be decoratin' these here surfaces, shogun!  You should "
        "take me to a house!",
        "'Arr matey, something went horribly wrong!",
        "'Arrrr matey, all done!",
        "'You don't have enough money to pay for the $decor$!  It "
        "will cost you $amount$, guv!",
        "'I can fit $allowed$ with any of the following:",
        "'Cor blimey mister, I haven't got any stock.",
        "'Okey doke, I'll have it done in a jiffy guv'nor!",
        "'What?  Who sed dat?",
        "'I've already got this great job with $employer$, mate!",
        "'Righty-o, you just take me to the room you want spiffied "
        "up and ask me to fit something!",
        "'Sorry matey, bad karma over that way."
    }) );
}

==================================================
FILE: learning/examples/terrain_map/basic/entrance.c
==================================================

#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
string query_handler_path() { return __DIR__ + "field_handler"; }
void setup()
{
  set_short("field entrance");
  set_long("You are at the entrance to a large grassy field.\n");
  add_item("path", "Trampled down by the hooves of time.");
  add_item("field", "Large and grassy.");
  add_item("grass", "It's green, which should come as no surprise at all.");
  add_exit("north", __DIR__ + "path:2:0", "road");
}

==================================================
FILE: learning/examples/terrain_map/basic/field.c
==================================================

#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
string query_handler_path() { return __DIR__ + "field_handler"; }
void setup()
{
  set_short("grassy field");
  set_long("This is a large grassy field.\n");
  add_item("field", "Large and grassy.");
  add_item("grass", "It's green, which should come as no surprise at all.");
}

==================================================
FILE: learning/examples/terrain_map/basic/field_handler.c
==================================================

#include <terrain_map.h>
inherit TERRAIN_MAP_HANDLER_BASE;
string query_map_file() { return __DIR__ + "field"; }
void  setup_handler()
{
   add_obstacle_type("*", "A tall fence blocks your way to the $D.",
                "fence", "A tall, unclimable wooden fence.");
   add_room_type(".", __DIR__ + "field");
   add_road_type(",", __DIR__ + "path",
            "The path meanders $D.",
            "A small path meanders its way across the field to the $D.",
            "path",
            "The path has been trampled down by the hooves of time.");
   add_feature("bigtree", 4, 1, 1, 1, 4,
                ({ "A giant tree towers over you to the $D.",
                   "A little way to the $D, you can see a huge tree.",
                   "You can just make out a large tree, a way off in an "
                   "$Derly direction." }),
                   "tree", "A fairly large, and quite beautiful tree." );
   set_feature_chats("bigtree",
                     ({ "The branches on the tree to the $D "
                        "sway slightly in the breeze." }) );
   add_exit_at(2, 0, "south", __DIR__ + "entrance", "road");
}

==================================================
FILE: learning/examples/terrain_map/basic/path.c
==================================================

#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
string query_handler_path() { return __DIR__ + "field_handler"; }
void setup()
{
  set_short("trampled path");
  set_long("This path meanders through a large grassy field.\n");
  add_item("path", "Trampled down by the hooves of time.");
  add_item("field", "Large and grassy.");
  add_item("grass", "It's green, which should come as no surprise at all.");
}

==================================================
FILE: learning/examples/npcs/barley.c
==================================================

inherit "/obj/monster";
void setup() {
    set_name( "barley" );
    set_short( "Barley" );
    add_property("determinate", "");
    add_alias( ({"npc", "warrior", "man"}) );
    set_long("Barley is a friendly, talkative NPC.  He chats and emotes."
    "  Also, he will occasionally give out quest hints.  If you try and"
    " kill him, he will become more animated.\n");
    basic_setup ("human", "warrior", 50);
    set_gender( 1 );
    add_language( "common" );
    set_language( "common" );
    load_chat( 50, ({
                  3, "'I say this quite often.",
                  3, ":does this quite often.",
                  3, "Chats can appear without the NPC name in them.",
                  1, "'I only give out quest hints 10% of the time."
               }) );
    load_a_chat( 150, ({
                    1, "'Oof!",
                    1, ":is happy to die so you can learn.",
                    1, "You feel Someone is waiting in the wings."}) );
}

==================================================
FILE: learning/examples/npcs/cuthbert.c
==================================================

#include <armoury.h>
#define TO this_object()
inherit "/obj/monster";
object cape, trousers;
void setup() {
    set_name( "cuthbert" );
    set_short( "Cuthbert" );
    add_property("determinate", "");
    add_alias( ({"npc", "warrior", "man"}) );
    set_long("Cuthbert is a fashion victim.  Not content with off the peg "
    "stuff, he wants clothing unique to him.  Fair enough, let's give him"
    " some.\n");
    basic_setup ("human", "warrior", 50);
    set_gender( 1 );
    add_language( "common" );
    set_language( "common" );
    load_chat( 50, ({
                  1, ":checks his equipment.",
                  1, ":feels all snuggly and warm in his new clothes."
               }) );
    load_a_chat( 150, ({
                    1, "'Oof!",
                    1, ":is happy to die so you can learn.",
                    1, "You feel Someone is waiting in the wings."}) );
         ARMOURY->request_item( "short sword",
         70+random(30))->move( TO );
         ARMOURY->request_item( "baggy leather loincloth",
         70+random(30))->move( TO );
         ARMOURY->request_item( "metal helmet",
         70+random(30))->move( TO );
   trousers = clone_object( "/obj/clothing" );
   trousers->set_name( "britches" );
   trousers->add_adjective(({"pair", "of"}));
   trousers->set_short( "pair of britches" );
   trousers->add_alias("trousers");
   trousers->set_long( "These are funky purple flaired britches, made of camel"
   "skin with beaver fur lining.\n" );
   trousers->set_value( 100 );
   trousers->set_weight( 7 );
   trousers->set_type( "trousers" );
   trousers->add_pocket( "side", 100 );
   trousers->add_pocket( "side", 100 );
   trousers->set_damage_chance( 10 );
   trousers->set_max_cond( 800 );
   trousers->set_cond( 600 + random( 200 ) );
   trousers->move( TO );
         cape = clone_object( "/obj/clothing" );
   cape->set_name( "cape" );
   cape->set_short( "orange cape" );
   cape->add_adjective("orange");
   cape->set_long( "Orange velvet has been made into a large cape.  It is bright "
   "and garish.\n" );
   cape->set_value( 100 );
   cape->set_weight( 7 );
   cape->set_type( "cape" );
   cape->set_damage_chance( 10 );
   cape->set_max_cond( 800 );
   cape->set_cond( 600 + random( 200 ) );
   cape->move( TO );
      init_equip();
         give_money( 10, 30, "Ankh-Morpork pence" );
}

==================================================
FILE: learning/examples/npcs/macgrew.c
==================================================

#include <armoury.h>
#define TO this_object()
inherit "/obj/monster";
void setup() {
    set_name( "macgrew" );
    set_short( "MacGrew" );
    add_property("determinate", "");
    add_alias( ({"npc", "warrior", "man"}) );
    set_long("MacGrew is a warm, armed NPC.  He models some of the latest "
    "fashions, but beware of mentioning them in the long() because he may "
    "have them stolen, or broken.  Let players look at him.\n");
    basic_setup ("human", "warrior", 50);
    set_gender( 1 );
    add_language( "common" );
    set_language( "common" );
    load_chat( 50, ({
                  1, ":checks his equipment.",
                  1, ":feels all snuggly and warm in his new clothes."
               }) );
    load_a_chat( 150, ({
                    1, "'Oof!",
                    1, ":is happy to die so you can learn.",
                    1, "You feel Someone is waiting in the wings."}) );
         ARMOURY->request_item( "short sword",
         70+random(30))->move(this_object());
         ARMOURY->request_item( "baggy leather loincloth",
         70+random(30))->move(this_object());
         ARMOURY->request_item( "metal helmet",
         70+random(30))->move(this_object());
         init_equip();
         give_money( 10, 30, "Ankh-Morpork pence" );
}

==================================================
FILE: learning/examples/npcs/path.h
==================================================

#define PATH "/d/learning/examples/npcs/"

==================================================
FILE: learning/examples/npcs/pugh2.c
==================================================

inherit "/obj/monster";
void setup() {
    set_name( "pugh" );
    set_short( "Pugh" );
    add_property("determinate", "");
    add_alias( ({"npc", "warrior", "man"}) );
    set_long("This is Pugh.  He exists in a separate file, so can easily be "
    "loaded in a variety of locations at once.  Essentially, he is identical"
    " to Pugh in the other room.\n");
    basic_setup ("human", "warrior", 10);
    set_gender( 1 );
}

==================================================
FILE: learning/examples/npcs/rat.c
==================================================

inherit "/obj/monster";
void setup() {
    string *name_adjectives = ({ "furry", "manky",
      "flea-ridden", "obnoxious", "sharp-toothed", "stinky", "dirty, stinking",
      "brown", "beady-eyed", "corpse-eating" });
    string adjective;
    adjective = name_adjectives[random(sizeof(name_adjectives))];
    set_name("rat");
    add_alias("rodent");
    set_gender(1 + random(2));
    set_short(adjective + " rat");
    add_adjective(adjective);
    set_long("The learning domain is full of rats.  This one appears "
    "not to have eaten for some hours and has a look"
    " of hunger in " + query_possessive()
      + " eyes.\n");
    basic_setup ("rat", "fighter", 2 + random(5));
}

==================================================
FILE: learning/examples/npcs/room1.c
==================================================

#include "path.h"
inherit "/std/room";
object npc;
void setup() {
    set_light(70);
    set_short( "cloned NPC room" );
    add_property( "determinate", "the " );
    set_long( "This room holds a very simple NPC.  He is a fighter.  His "
    "code is within the room code.  If he's not here, type update, and"
    ", like magic, he should appear.  If he doesn't, panic.\n");
    add_exit("onwards", PATH +"room2", "door");
    }
void reset(){
        if (!npc){
    npc = clone_object( "/obj/monster" );
    npc -> set_name("pugh");
    npc -> set_short("Pugh");
    npc -> add_property("determinate", "");
    npc -> add_alias( ({"npc", "warrior", "man"}) );
    npc -> set_long("This is Pugh.  He was cloned here, and "
    "this is his world.  Welcome to it.\n");
    npc -> basic_setup("human", "warrior", 10);
    npc -> set_gender( 1 );
    npc->move( this_object() );
    }
    }

==================================================
FILE: learning/examples/npcs/room2.c
==================================================

#include "path.h"
inherit "/std/room";
object npc;
void setup() {
    set_light(70);
    set_short( "seperate file NPC room" );
    add_property( "determinate", "the " );
    set_long( "The NPC in here is cloned from another file, and brought here."
    "  This method means the same NPC can easily be loaded into a variety "
    "of locations, without the need to repeat much code.  The npc file is "
    "in /d/learning/examples/npcs/pugh2.c.\n");
    add_exit("backwards", PATH +"room1", "door");
    add_exit("onwards", PATH +"room3", "door");
    }
void reset(){
        if (!npc){
    npc = clone_object( PATH +"pugh2" );
    npc->move( this_object() );
    }
    }

==================================================
FILE: learning/examples/npcs/room3.c
==================================================

#include "path.h"
inherit "/std/room";
object npc;
void setup() {
    set_light(70);
    set_short( "variable NPC room" );
    add_property( "determinate", "the " );
    set_long( "This room clones an NPC from a single file.  However, the NPC"
    " has built in variety.  Its description changes randomly.  Typing "
    "update will bring a new version of the NPC here, each time it"
    " will be different.\n");
    add_exit("backwards", PATH +"room2", "door");
    add_exit("onwards", PATH +"room4", "door");
    }
void reset(){
        if (!npc){
    npc = clone_object( PATH +"rat" );
    npc->move( this_object() );
    }
    }

==================================================
FILE: learning/examples/npcs/room4.c
==================================================

#include "path.h"
inherit "/std/room";
object npc;
void setup() {
    set_light(70);
    set_short( "chatting NPC room" );
    add_property( "determinate", "the " );
    set_long( "The NPC in here gets to talk a little bit.  He has both random"
    " chats, and chats for use in combat which make him more entertaining.  "
    "Some chats appear more often than others.\n");
    add_exit("backwards", PATH +"room3", "door");
    add_exit("onwards", PATH +"room5", "door");
    }
void reset(){
        if (!npc){
    npc = clone_object( PATH +"barley" );
    npc->move( this_object() );
    }
    }

==================================================
FILE: learning/examples/npcs/room5.c
==================================================

#include "path.h"
inherit "/std/room";
object npc;
void setup() {
    set_light(70);
    set_short( "room with a non-naked NPC" );
    add_property( "determinate", "the " );
    set_long( "We ought to clothe our NPCs and give them weapons, else how "
    "will the poor darlings survive the winter, and fend off attackers?  "
    "The easiest way is to give them items which already exist on the MUD"
    " via the armoury.\n");
    add_exit("backwards", PATH +"room4", "door");
    add_exit("onwards", PATH +"room6", "door");
    }
void reset(){
        if (!npc){
    npc = clone_object( PATH +"macgrew" );
    npc->move( this_object() );
    }
    }

==================================================
FILE: learning/examples/npcs/room6.c
==================================================

#include "path.h"
inherit "/std/room";
object npc;
void setup() {
    set_light(70);
    set_short( "room with a fashion-victim NPC" );
    add_property( "determinate", "the " );
    set_long( "The NPC is here is not content with last year's fashion.  "
    "He wants new, exciting clothes, to be unique to him.  He has some "
    "standard stuff, but he has things which are unique to him.\n");
    add_exit("backwards", PATH +"room5", "door");
    add_exit("onwards", PATH +"room7", "door");
    }
void reset(){
        if (!npc){
    npc = clone_object( PATH +"cuthbert" );
    npc->move( this_object() );
    }
    }

==================================================
FILE: learning/handlers/quit.c
==================================================

#include <learning.h>
#define SAVE_FILE SAVEPATH +"search_quit"
inherit "/std/room/basic_room";
mapping locations;
void setup() {
   set_short( "quit handler of the search rooms" );
   set_light( 50 );
   set_long( "You are in the quit_handler of the search rooms of the learning "
            "domain.  In normal use, people only end up in the quit_handler "
            "if something goes wrong, since the event_enter() function will "
            "send them on to the correct place immediately.\n" );
   add_exit( "back", ENTRANCE, "path" );
   locations = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) )
      unguarded( (: restore_object, SAVE_FILE :) );
   call_out( "check_names", 2 );
}
void save_this() { unguarded( (: save_object, SAVE_FILE :) ); }
void check_names() {
   string word;
   foreach ( word in keys( locations ) )
      if ( !"/secure/login"->test_user( word ) )
         locations = m_delete( locations, word );
   save_this();
}
void player_quitting( object player, object place ) {
   if ( player->query_property( "guest" ) )
      return;
   locations[ (string)player->query_name() ] =
         (string *)place->query_keywords();
   if ( !locations[ (string)player->query_name() ] ) {
      locations[ (string)player->query_name() ] =
          (string)place->query_marker();
   }
   save_this();
}
void remove_from_list( object player ) {
   string word;
   word = (string)player->query_name();
   if ( locations[ word ] )
      locations = m_delete( locations, word );
   save_this();
}
void event_enter( object player, string words, object from ) {
   string location, word;
   if( from ) {
      return;
   }
   word = (string)player->query_name();
   if ( !locations[ word ] ) {
      player->move( (string)player->query_start_pos(),
            "$N enter$s the game." );
      return;
   }
   if ( pointerp( locations[ word ] ) ) {
      location = (string)SEARCH->find_room( locations[ word ] );
   } else {
      location = (string)SEARCH->find_function_room( locations[ word ] );
   }
   player->move( location, "$N enter$s the game." );
}

==================================================
FILE: learning/handlers/request.c
==================================================

#include <learning.h>
#define SAVE SAVEPATH +"request"
mixed *requests;
void create() {
   seteuid( (string)master()->get_bb_uid() );
   unguarded( (: restore_object, SAVE :) );
   if( !requests ) requests = ({ });
}
void save_me() {
   unguarded( (: save_object, SAVE :) );
}
string query_list() {
   int i;
   string ret;
   mixed request;
   if ( !sizeof( requests ) ) {
      return "There are no requests at the moment.\n";
   }
   ret = "$P$Requests$P$The following requests have been made:\n";
   foreach( request in requests ) {
      if ( !request[ 1 ] ) {
         ret += sprintf( "%4d. $C$%s asked for %s.\n", i,
                        request[ 0 ], request[ 2 ] );
      } else {
         ret += sprintf( "%4d. $C$%s asked for %s.\n       Claimed by $C$%s\n", i,
                        request[ 0 ], request[ 2 ],
                        request[ 1 ]);
      }
   }
   return ret;
}
void add_request( string name, string words ) {
   requests += ({ ({ name, 0, words }) });
   save_me();
}
int claim_request( string name, int number ) {
   if ( number >= 0 && number < sizeof( requests ) ) {
      requests[ number ][ 1 ] = name;
      save_me();
      return 1;
   }
   return 0;
}
int remove_request( string name, int number ) {
   if ( number >= 0 && number < sizeof( requests ) ) {
      if ( requests[ number ][ 0 ] == name || name == CURRENT_LORD ) {
         requests = delete( requests, number, 1 );
         save_me();
         return 1;
      }
   }
   return 0;
}

==================================================
FILE: learning/handlers/search.c
==================================================

#include <learning.h>
#define SAVE SAVEPATH +"search"
mapping rooms,
        objects,
        keywords,
        functions;
string *directories;
nosave string word;
void create() {
   seteuid( (string)master()->get_bb_uid() );
   unguarded( (: restore_object, SAVE :) );
}
mixed get_keywords( string *words ) {
   string *found_words, *found_rooms, *found_objects, key, *value;
   if( sizeof( words ) ) {
      found_objects = keys( keywords );
      foreach( word in words ) {
         if( objects[ word ] ) {
            found_objects = filter_array( found_objects,
                (: member_array( $1, objects[ word ] ) != -1 :) );
         } else {
            found_objects = ({ });
         }
      }
      found_rooms = keys( keywords );
      foreach( word in words ) {
         if( rooms[ word ] ) {
            found_rooms = filter_array( found_rooms,
                (: member_array( $1, rooms[ word ] ) != -1 :) );
         } else {
            found_rooms = ({ });
         }
      }
      found_words = ({ });
      foreach( word in found_rooms ) {
         found_words -= keywords[ word ];
         found_words += keywords[ word ];
      }
      foreach( word in found_objects ) {
         found_words -= keywords[ word ];
         found_words += keywords[ word ];
      }
      found_words -= words;
   } else {
      found_rooms = ({ });
      foreach( key, value in rooms ) {
         found_rooms -= value;
         found_rooms += value;
      }
      found_objects = ({ });
      foreach( key, value in objects ) {
         found_objects -= value;
         found_objects += value;
      }
      found_words = keys( rooms );
      found_words -= keys( objects );
      found_words += keys( objects );
   }
   return ({ found_words, found_rooms, found_objects });
}
void update_info_for( string file ) {
   string *words, word;
   object obj;
   if( !catch( file->force_load() ) ) {
      obj = find_object( file );
      words = obj->query_property( "commented functions" );
      if( words ) {
         functions[ file ] = words;
      }
      words = obj->query_property( "keywords" );
      if( words ) {
         keywords[ file ] = words;
         if( function_exists( "add_exit", obj ) ) {
            foreach ( word in words ) {
               if( rooms[ word ] ) {
                  rooms[ word ] -= ({ file });
                  rooms[ word ] += ({ file });
               } else {
                  rooms[ word ] = ({ file });
               }
            }
         } else {
            foreach ( word in words ) {
               if( objects[ word ] ) {
                  objects[ word ] -= ({ file });
                  objects[ word ] += ({ file });
               } else {
                  objects[ word ] = ({ file });
               }
            }
         }
      }
      if( !directories ) {
         unguarded( (: save_object, SAVE :) );
      }
   }
}
void update_search( string room ) {
   object *obs;
   int i;
   obs = all_inventory( find_object( room ) );
   i = sizeof( obs );
   while( i--  ) {
      if ( userp( obs[ i ] ) ) {
         obs[ i ]->move( "/room/void" );
      } else {
         obs = delete( obs, i, 1 );
      }
   }
   room->dest_me();
   room->force_load();
   obs->move( room );
}
void collect_one() {
   string dir, file, *funcs;
   mixed dirs, file_info;
   dir = directories[ 0 ];
   dirs = get_dir( dir, -1 );
   if( dirs ) {
      foreach ( file_info in dirs ) {
         if( file_info[ 1 ] == -2 ) {
            if( file_info[ 0 ] != "old" ) {
               directories = directories + ({ dir + file_info[ 0 ] +"/" });
            }
         } else {
            if( ( sizeof( file_info[ 0 ] ) > 2 ) &&
                ( file_info[ 0 ][ <2 .. <1 ] == ".c" ) ) {
               update_info_for( dir + file_info[ 0 ][ 0 .. <3 ] );
            }
         }
      }
   }
   directories = directories[ 1 .. <1 ];
   if( find_call_out( "collect_one" ) == -1 && sizeof( directories ) ) {
      call_out( "collect_one", 3 );
   } else if( !sizeof( directories ) ) {
      tell_object( find_living( "olorin" ), "Collect finished.\n" );
      directories = 0;
      unguarded( (: save_object, SAVE :) );
      update_search( LEARNING +"search" );
      update_search( LEARNING +"functions" );
   }
}
void collect() {
   rooms=([ ]);
   objects=([ ]);
   functions=([ ]);
   keywords=([ ]);
   directories=({ "/d/learning/" });
   collect_one();
}
int query_collecting() {
   if( directories ) {
      return 1;
   } else {
      return 0;
   }
}
string find_room( string *words ) {
   object thing, *things;
   string word_mark;
   if( !sizeof( words ) )
     return LEARNING +"search";
   word_mark = implode( sort_array( words, 1 ), ", " );
   things = children( SEARCH_ROOM ) - ({ find_object( SEARCH_ROOM ) });
   foreach ( thing in things ) {
      if ( (string)thing->query_marker() == word_mark )
        return file_name( thing );
   }
   thing = clone_object( SEARCH_ROOM );
   thing->set_marker( word_mark, words );
   return file_name( thing );
}
string find_function_room( string word ) {
   object thing, *things;
   if( !word )
     return LEARNING +"functions";
   things = children( FUNCTION_ROOM ) - ({ find_object( FUNCTION_ROOM ) });
   foreach ( thing in things ) {
      if ( (string)thing->query_marker() == word )
        return file_name( thing );
   }
   thing = clone_object( FUNCTION_ROOM );
   thing->set_marker( word );
   return file_name( thing );
}
string *query_functions() {
   string *functions_found, key, *value;
   functions_found = ({ });
   foreach ( key, value in functions ) {
      functions_found -= value;
      functions_found += value;
   }
   return sort_array( functions_found, 1 );
}
string *query_rooms_with_function( string word ) {
   string *rooms_found, key, *value;
   rooms_found = ({ });
   foreach ( key, value in functions ) {
      if ( member_array( word, value ) != -1 )
        rooms_found += ({ key });
   }
   return uniq_array(rooms_found);
}

==================================================
FILE: learning/newbie/introduction/examples/.advanced_item_4.food_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/food.c", 1 );
  clone->add_property( "virtual name", "/d/learning/newbie/introduction/examples/advanced_item_4.food#1" );
  call_other( clone, "set_name", "sandwich"  );
  call_other( clone, "set_short", "monkey sandwich"  );
  call_other( clone, "add_adjective", ({ "monkey" })  );
  call_other( clone, "set_value", 0  );
  call_other( clone, "set_weight", 1  );
  call_other( clone, "set_long", "This is a monkey sandwich.  Made from real monkey.  Mmm!\n"  );
  call_other( clone, "add_eat_effect",  "/std/effects/ingested/poison", 600 );
   return clone;
}

==================================================
FILE: learning/newbie/introduction/examples/.simple_object.clo_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/clothing.c", 1 );
  clone->add_property( "virtual name", "/d/learning/newbie/introduction/examples/simple_object.clo#1" );
  call_other( clone, "set_name",  "dungarees"  );
  call_other( clone, "set_short",  "pair of waterproof dungarees"  );
  call_other( clone, "set_long",  "This is a pair of waterproof dungarees.  Luckily they "     "are also ooze proof.\n"  );
  call_other( clone, "add_adjective",  ({"pair of", "waterproof"})  );
  call_other( clone, "set_weight",  45  );
  call_other( clone, "set_value",  4000  );
  call_other( clone, "setup_clothing",  50000  );
  call_other( clone, "set_type",  "robe" );
   return clone;
}

==================================================
FILE: learning/newbie/introduction/examples/.simple_weapon.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( "virtual name", "/d/learning/newbie/introduction/examples/simple_weapon.wep#1" );
  call_other( clone, "set_name",  "mop"  );
  call_other( clone, "set_short",  "dirty mop"  );
  call_other( clone, "set_long",  "This is a dirty mop, dripping with ooze.\n"  );
  call_other( clone, "add_adjective",  "dirty"  );
  call_other( clone, "set_weight",  20  );
  call_other( clone, "set_value",  2000  );
  call_other( clone, "new_weapon", 10000  );
  call_other( clone, "add_attack",  "prod", 50, ({ 5, 6, 6 }), "blunt", "blunt", 0  );
  call_other( clone, "add_attack",  "whack", 50, ({ 10, 10, 5 }), "blunt", "blunt", 0 );
   return clone;
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_item_1.c
==================================================

inherit "/obj/baggage";
void setup() {
    set_name("bag");
    set_short("little green bag");
    set_long("This is a little green bag.\n");
    add_adjective(({"little", "green"}));
    set_weight(5);
    set_max_weight(20);
}
int test_add(object ob, int flag) {
    if(this_player()->query_name() != "drakkos") {
        return 0;
    }
    else {
        return ::test_add(ob, flag);
    }
}
int test_remove(object ob, int flag, mixed dest) {
    if(this_player()->query_name() != "drakkos") {
        return 0;
    }
    else {
        return ::test_remove(ob, flag, dest);
    }
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_item_2.c
==================================================

inherit "/obj/clothing";
void setup() {
    set_name("trousers");
    set_short("pair of flourescent pink flared trousers");
    add_adjective(({"pair of", "flourescent", "pink", "flared"}));
    set_long("This is a pair of extremely stylish, extremely "
    "tasteful, flourescent pink flared trousers.\n");
    set_weight(10);
    set_value(0);
    set_type("trousers");
    add_alias("flares");
    set_main_plural("pairs of flourescent pink flared trousers");
    add_plural("trousers");
    setup_clothing(10000);
    add_pocket("left", 20);
    add_pocket("right", 20);
    set_wear_remove_func(base_name(this_object()), "do_wear_stuff");
}
void do_wear_stuff(object ob) {
    if(this_player()->query_name() != "drakkos") {
        if(!ob) {
            tell_object(this_player(), "You heave a sigh of relief as "
                "you remove the ghastly garment.\n");
        }
        else {
            tell_object(this_player(), "Ye gods, are you really going "
            "to wear those hideous things?!\n");
        }
    }
    else {
        if(!ob) {
            tell_object(this_player(), "Awww, why are you taking off your "
                "super-cool slacks?\n");
        }
        else {
            tell_object(this_player(), "You feel Real Cool as you slip "
                "into your fabulous flares!\n");
        }
    }
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_item_3.c
==================================================

inherit "/obj/weapon";
void setup() {
    set_name("ruler");
    set_short("wooden ruler");
    add_adjective("wooden");
    set_long("This is a thick, wooden ruler, with the inches "
        "inked out in black.\n");
    set_weight(1);
    set_value(0);
    new_weapon(5000);
    add_attack("rap", 50,({ 25, 10, 5 }), "blunt", "blunt", "do_shame");
    add_attack_message( "rap", "blunt",
   ({
    0,({ "You rap $hcname$ smartly across the knuckles with your "
        "ruler.\n",
        "$mcname$ raps you smartly across the knuckles with $mposs$ "
            "ruler.\n",
        "$mcname$ raps $hcname$ smartly across the knuckles with "
            "$mposs$ ruler.\n"})
    }));
    set_wield_func( "test_creator", base_name( this_object() ) );
}
int test_creator(object ob)  {
    if(!ob) {
        return 1;
    }
    if(ob->query_corpse()) {
        return 1;
    }
    if(ob->query_creator()) {
        tell_object(ob, "You have been deemed worthy, leetle creator!\n");
        return 1;
    }
    else {
        tell_object(ob, "You have been deemed unworthy, leetle player!\n");
        return 0;
    }
}
void do_shame( int damage, object attack_ob, object attack_by, string
    type, string name ) {
    tell_object(attack_ob, "Your knuckles %^BOLD%^sting!%^RESET%^\n");
    tell_object(attack_by, "You feel strangely satisfied as " +
        attack_ob->one_short() + " whimpers in pain!\n");
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_npc.c
==================================================

#include <armoury.h>
inherit "/obj/monster";
void do_bunny(object, object);
void do_maintain(object, object);
void setup() {
    set_name("gnome");
    set_short("laughing gnome");
    set_long("This is a little, friendly looking gnome.  Well... "
        "friendly looking aside from the vicious sharp teefs and the "
        "wicked razor-like claws.  He has laughter lines all over "
        "his face, tho', so he can't be all bad.\n");
    add_property("unique", 1);
    basic_setup("gnome", "wizard", 50);
    set_gender("male");
    set_int(23);
    set_str(18);
    set_wis(18);
    add_skill_level("magic", 100);
    add_skill_level("fighting", 50);
    load_chat(20,({
        1, "' Ha ha ha!.",
        1, "' He he he!.",
        2 , "' I'm the laughing gnome, and you can't catch me!",
        1 , "#charm_women",
    }) );
    load_a_chat(20,({
        2, ": bares his teeth.",
        1, "' I'll get my brother Fred onto you!.",
        2 , "' I'll call out the Gnome Guard!",
    }) );
    add_spell("bunnies", "/obj/spells/fire_bunny", "cast_spell");
    add_spell("flowers", "/obj/spells/flowers", "cast_spell");
    add_spell("shield", "/obj/spells/small_shield", "cast_spell");
    add_combat_action(25, "bunny_them",(: do_bunny :));
    add_combat_action(25, "maintain_me",(: do_maintain :));
    add_attack( "claws", 88,({ 10, 8, 20 }), "sharp", "sharp", 0 );
    add_attack( "teeth", 88,({ 5, 5, 25 }), "pierce", "pierce", 0 );
    add_attack_message( "claws", "sharp",
   ({
    100,
       ({ "You slice $hcname$ with your claws.\n",
            "$mcname$ slices you with $mposs$ claws.\n",
            "$mcname$ slices $hcname$ with $mposs$ claws.\n"}),
    200,
       ({ "You rip $hcname$ apart with your claws.\n",
            "$mcname$ rips you apart with $mposs$ claws.\n",
            "$mcname$ rips $hcname$ apart with $mposs$ claws.\n"}),
    0,
       ({ "You scratch $hcname$ viciously with your claws.\n",
            "$mcname$ scratches you viciously with $mposs$ claws.\n",
            "$mcname$ scratches $hcname$ viciously with $mposs$ claws.\n"})
    }));
    add_attack_message( "teeth", "pierce",
   ({
    100,
       ({ "You nibble $hcname$ with your teeth.\n",
            "$mcname$ nibbles you with $mposs$ teeth.\n",
            "$mcname$ nibbles $hcname$ with $mposs$ teeth.\n"}),
    200,
       ({ "You chew on $hcname$ with your teeth.\n",
            "$mcname$ chews on you with $mposs$ teeth.\n",
            "$mcname$ chews on $hcname$ with $mposs$ teeth.\n"}),
    0,
       ({ "You sink your teeth into $hcname$.\n",
            "$mcname$ sinks $mposs$ teeth into you.\n",
            "$mcname$ sinks $mposs$ teeth into $hcname$.\n"})
    }));
}
void charm_women() {
    object player;
    foreach(player in all_inventory(environment(this_object()))) {
        if(interactive(player) && player->query_gender() == 2) {
            queue_command("cast flowers");
            queue_command("give flowers to " + player->query_name());
            queue_command("bow with a flourish");
            return;
        }
    }
}
void do_bunny(object attacker, object target) {
    object carrot,torch;
    if(target != this_object() ) {
        if(!sizeof(match_objects_for_existence("carrot", this_object()))) {
            carrot =ARMOURY->request_item ("carrot");
            carrot->move(this_object());
        }
        if(!sizeof(match_objects_for_existence("torch", this_object()))) {
            torch = ARMOURY->request_item ("torch");
            torch->move(this_object());
        }
        do_command("cast bunnies on " + target->query_name());
    }
}
void do_maintain(object attacker, object target) {
    object temp;
    if(!sizeof(match_objects_for_existence("shields", this_object()))) {
        temp = ARMOURY->request_item("wooden djelian shield", 100);
        temp->move(this_object());
    }
    do_command("cast shield on " + this_object()->query_name());
}
void adjust_hp(int number) {
    return;
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_room_1.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
    set_short("market square");
    set_day_long("This is a lovely market square, where people mill about "
        "doing the kind of things you would expect people to do in a lovely "
        "market square.  Brightly coloured stalls stand in the corners of "
        "the market.  They seem to do good business judging by the steady "
        "stream of consumers ducking under the flaps.\n");
    set_night_long("The darkness settles on this market square like a thick "
        "black blanket.  The stalls, undoubtedly merry and brightly coloured "
        "during the day, lie dormant and unusued.  The silence is "
        "deafening.\n");
    add_property("climate",({20, 20, 10}));
    set_light(80);
    add_zone("my rooms");
    set_linker(({PATH + "advanced_room_2", PATH + "advanced_room_3"}),
        "onto", "on", "the newbie creator marketplace");
    add_day_item(({"people", "consumers"}), "The people mill around happily, "
        "browsing the goods and talking with the stallowners.");
    add_night_item(({"people", "consumers"}), "They're all tucked up in "
        "bed.  Only crazed retrobrates like you are awake at this time of "
        "night.");
    add_day_item("stall", "The stalls are brightly coloured and really "
        "quite merry.");
    add_night_item("stall", "The stalls lie dormant in the night.  Creepy!");
    room_day_chat(({120,240,({
        "People mill around happily.",
        "The brightly coloured stalls attract the eye.",
    })}));
    room_night_chat(({120,240,({
        "The only sound is the chirping of the crickets.",
        "The stalls loom ominously in the darkness.",
    })}));
    add_exit("north", PATH + "advanced_room_3", "road");
    add_exit("south", PATH + "advanced_room_2", "road");
    add_exit("east", "/w/drakkos/workroom", "road");
    add_exit("west", PATH + "simple_room", "road");
    modify_exit("east",({"look", "You get the feeling that peeking into a "
        "creator's workroom is very rude!", "function", "test_creator"}));
}
int do_search(string str) {
    if(!sizeof(str)) {
        return -1;
    }
    if(str == "shards") {
        tell_object(this_player(), "You search through the shards, but "
            "succeed only in cutting your hand slightly.  Ouch!\n");
        this_player()->adjust_hp(-100);
        if(this_player()->query_hp() < 0) {
            this_player()->attack_by(this_object());
        }
    return 1;
    }
    else {
        notify_fail("Try searching something else, perhaps?\n");
        return 0;
    }
}
string query_death_reason() {
    return "a nasty cut in the newbie creator tutorial room";
}
int test_creator(string str, object ob, string special_mess) {
    if(!ob->query_creator()) {
        notify_fail ("");
        tell_object (ob, "You are not a creator!  You may not pass!\n");
        return 0;
    }
    else {
        tell_object(ob, "You feel a tingle down your spine as you take the "
            "exit.\n");
        return 1;
    }
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_room_2.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
    set_short("road to the market");
    add_property("determinate", "the ");
    set_day_long("This is a quiet road.  Absolutely nothing of interest is "
        "here..\n");
    set_night_long("This is a quiet road.  But at night!.\n");
    set_linker(({PATH + "advanced_room_1", PATH + "advanced_room_3"}),
        "onto", "on", "the newbie creator marketplace");
    set_light(80);
    add_zone("my rooms");
    add_item("road", "I *said*, there's nothing interesting at all here.");
    add_exit("north", PATH + "advanced_room_1", "road");
}

==================================================
FILE: learning/newbie/introduction/examples/advanced_room_3.c
==================================================

#include "path.h"
inherit "/std/outside";
void setup() {
    set_short("road to the market");
    add_property("determinate", "the ");
    set_day_long("This is a quiet road.  Absolutely nothing of interest is "
        "here..\n");
    set_night_long("This is a quiet road.  But at night!.\n");
    set_linker(({PATH + "advanced_room_1", PATH + "advanced_room_2"}),
        "onto", "on", "the newbie creator marketplace");
    set_light(80);
    add_zone("my rooms");
    add_item("road", "I *said*, there's nothing interesting at all here.");
    add_exit("south", PATH + "advanced_room_1", "road");
}

==================================================
FILE: learning/newbie/introduction/examples/path.h
==================================================

#define PATH "/d/learning/newbie/introduction/examples/"

==================================================
FILE: learning/newbie/introduction/examples/simple_npc.c
==================================================

inherit "/obj/monster";
void setup() {
  set_name("blob");
  set_short("grey blob");
  set_long("This is a grey blob.  It is grey.  It is also quite "
      "blobby.\n");
  basic_setup("human", "warrior", 10);
  set_gender("male");
  add_adjective(({"oozing", "grey"}));
  set_main_plural("grey blobses");
  add_alias("porridge");
  add_respond_to_with(({ "@say",({"blob", "grey"}),
      }), "say Yes, I am a grey blob.");
  add_respond_to_with(({ "@say",({"ooze", "blue", "cardboard"}),
     ({"porridge", "bing", "womble"}),
      }), "' Yes, I'm oozing quite nicely, like grey "
          "blobs do.  Like porridge!");
  add_respond_to_with(({ "@thank", ({ "you", "blob" }) }),
      "' Aw, shucks. T'weren't nuthin'.");
  add_respond_to_with(({ ({"@gnaw", "@bite", "@chew"}), ({ "you",
    "blob" }) }),
      ({"' What did you do that for?!",  "scream", "cry", "weep"}));
  load_chat(20,({ 2, ": oozes around.",
      1, "' I'm very grey.",
      2 , "' I'm a blob.",
      2 , "@bing",
  }) );
  load_a_chat(20,({ 2, ": oozes all over you.",
      1, "' Lemme alone!.",
      2 , ": sobs bitter, slimy tears.",
  }) );
}

==================================================
FILE: learning/newbie/introduction/examples/simple_object.c
==================================================

inherit "/obj/clothing";
void setup() {
    set_name("dungarees");
    set_short("pair of waterproof dungarees");
    add_adjective(({"pair of", "waterproof"}));
    set_long("This is a pair of waterproof dungarees.  Luckily they "
        "are also ooze proof.\n");
    add_adjective(({"pair of", "waterproof"}));
    set_weight(45);
    set_value(4000);
    setup_clothing(50000);
    set_type("robe");
}

==================================================
FILE: learning/newbie/introduction/examples/simple_room.c
==================================================

#include "path.h"
inherit "/std/room";
void setup() {
    set_short("blobby lair");
    set_long("This is where the grey blob lives.  All around lie "
        "frogs, and wombles, and strange oozy things.  It's a "
        "very nice lair, as lairs go.\n");
    add_property("determinate", "a ");
    set_light(50);
    add_item(({"frog", "pinkfish", "toad"}),({"long", "The frogs are very "
        "nice.  Very froggy.", "position", "one of the poor leetle "
        "frogs."}));
    add_item(({"womble", "uncle bulgaria"}),({"long", "It's Uncle "
        "Bulgaria!", "pet", "You pet Uncle Bulgaria.  He growls and "
        "chews the nails off your hand.\n", "snuggle", "Uncle Bulgaria gnaws "
        "on your teeth.\n"}));
    add_item("strange oozy things", "Ewww!");
    add_zone("my rooms");
    add_sign("This is a nice sign.\n", "Do Notte Feed Thee Blob!",
        "nice sign", "sign", "common");
    room_chat(({120,240,({
        "A thick blob of goo oozes over one of the frogs.",
        "The womble bings quietly.",
        "The frogs ribbit in abstract contemplation.",
    })}));
    add_exit("east", PATH + "advanced_room_1", "road");
}
void reset() {
    call_out("after_reset", 3);
}
void after_reset() {
    object ob = find_object
        (PATH + "simple_npc");
    if(!ob) {
        ob=load_object(PATH + "simple_npc");
        ob->move(this_object(), "$N appear$s with a wet squelch.\n");
    }
    else if(!environment(ob)) {
        ob->move(this_object(), "$N appear$s with a wet squelch.\n");
    }
}

==================================================
FILE: learning/cutnpaste/althea.c
==================================================

#define CREATOR "Ceres"
#include <armoury.h>
inherit "/obj/monster";
#define HEAL_COST 30
object flail;
int dickens_warned;
void do_heal(object);
void check_injured();
void maintain_self(object, object);
void fighting_stuff(object, object);
void ritual_stuff(object, object);
void setup() {
    set_name("althea");
    set_short("Althea of Pishe");
    set_main_plural("Altheas of Pishe");
    set_long("This is Althea, an Archcardinal of Pishe.  She is a beautiful, "
      "middle-aged woman with a kind face.  She almost seems to glow "
      "with a gentle power.\n");
    add_adjective(({"arch", "cardinal", "of", "pishe"}));
    add_alias(({"priestess", "archcardinal", "cardinal"}));
    add_property("determinate","");
    add_property("unique", 1);
    set_gender("female");
    set_race("human");
    set_guild("priest");
    set_deity("pishe");
    set_level(400);
    set_height(140);
    set_weight(1000);
    set_al(-2000 - random(501));
    set_con(15);
    set_dex(13);
    set_int(12);
    set_str(15);
    set_wis(20);
    add_skill_level("fighting", 300, 0);
    add_skill_level("fighting.combat.melee.blunt", 150, 0);
    add_skill_level("faith", 200);
    add_skill_level("faith.rituals.misc.area", 300);
    add_skill_level("other.perception", 400, 0);
    add_skill_level("other.health", 200, 0);
    add_known_command("strike");
    add_known_command("crush");
    add_spell("cure light wounds", "/obj/rituals/curelight", "cast_spell");
    add_spell("cure serious wounds", "/obj/rituals/cureserious", "cast_spell");
    add_spell("cure critical wounds", "/obj/rituals/curecritical", "cast_spell");
    add_spell("minor shield", "/obj/rituals/minorshield", "cast_spell");
    add_spell("dust devil", "/obj/rituals/dustdevil", "cast_spell");
    add_combat_action(100, "maintenance", (: maintain_self :)) ;
    add_combat_action(70, "fighting_stuff", (: fighting_stuff :));
    add_combat_action(50, "ritual_stuff", (: ritual_stuff :));
    ARMOURY->request_item("white cotton tunic", 100)->move(this_object());
    ARMOURY->request_item("rope belt", 100)->move(this_object());
    ARMOURY->request_item("soft leather shoes", 100)->move(this_object());
    clone_object("/obj/faith/pishe_symbol.ob")->move(this_object());
    do_command("tactics response parry");
    do_command("tactics attitude defensive");
    load_chat(20, ({ 2, ":smiles kindly.",
        1, "'May the countenance of Pishe rain upon you.",
        2, ":smiles serenely." }));
    load_a_chat(20, ({ 1, "'Do you know who I am?",
        1, "'May the power of Pishe strike you down.",
        1, "'Die unbeliever!",
        1, "'You fight me, you fight Pishe herself",
        1, "'Pishe! Aid your loyal servant!" }));
    set_virtual_move(1);
    set_move_after(30, 120);
    add_move_zone("Ankh-Morpork");
    add_move_zone("Temple");
    set_wimpy(10);
    add_respond_to_with(({ "@say",
        ({ ({ "heal", "healing" }), "please" }) }), (: do_heal :));
    add_respond_to_with(({ "@say",
        ({ "please", "heal", "me" }) }), (: do_heal :));
    add_respond_to_with(({ "@smile", "althea" }), "smile $hname$");
    add_respond_to_with(({ ({ "@bow", "@curtsey" }), "althea" }),
      "curtsey $hname$");
    add_enter_commands((: check_injured :));
    flail = ARMOURY->request_item("cleric rod", 100);
    flail->set_enchant(flail->query_max_enchant() / 2);
    flail->whichone(7);
    flail->move(this_object());
    call_out((: init_equip :), 2);
    move("/d/guilds/priests/Ankh-Morpork/small-gods/old/PriestGardenStatue", "$N walk$s into the "
      "room, smiling serenely.");
}
void maintain_self(object thing1, object thing2) {
    if (thing2 != this_object())
        return;
    if (member_array(flail, query_holding()) == -1) {
        queue_command("get flail");
        queue_command("hold flail");
    }
    if (query_gp() < 200)
        adjust_gp(200);
    if (query_hp() < query_max_hp() / 2) {
        do_command("cast cure serious wounds on althea");
    }
    if(query_hp() < query_max_hp() - 1000) {
        do_command("cast dust devil on althea");
    }
    if (query_hp() < query_max_hp() - 500) {
        do_command("cast minor shield on althea");
    }
    if (query_hp() < query_max_hp() - 250) {
        do_command("cast cure light wounds on althea");
    }
}
void fighting_stuff(object thing1, object thing2) {
    if (thing2 != this_object())
        return;
    if ( random( 10 ) )
        return;
   do_command("concentrate " + thing1->query_name());
    do_command("tactics attitude offensive" );
    do_command("crush "+ thing1->query_name() + " with flail");
}
void ritual_stuff(object thing1, object thing2) {
    if (thing2 != this_object())
        return;
    switch (random(6)) {
    case 0..1:
        do_command( "cast minor shield on althea" );
        break;
    case 2 .. 4 :
        do_command("cast dust devil on althea");
        do_command("cast dust devil on althea");
        do_command("cast dust devil on althea");
        break;
    case 5 :
        do_command("use flail to cast fear on " + thing1->query_name());
        break;
    }
    do_command("tactics attitude defensive");
}
void do_heal(object victim) {
    if (member_array(victim, query_attacker_list()) != -1) {
        do_command("say I'm not going to heal you!");
        return;
    }
    if (victim->query_hp() > (victim->query_max_hp() / 2)) {
        do_command("say You don't need healing from me, " +
          victim->short()+".");
        return;
    }
    if (victim->query_gp() < HEAL_COST) {
        do_command("say Sorry you're not strong enough for me to "
          "heal at the moment.\n");
        return;
    }
    if (victim->query_guild_ob() == "/std/guilds/wizard") {
        do_command("say I thought wizards didn't believe in gods?");
        do_command("smirk");
        return;
    }
    if (victim->query_al() > random(300)) {
        do_command("say You are far too wicked for Pishe's healing.");
        return;
    }
    do_command("say May the power of Pishe heal you.");
    tell_room(environment(), "Althea places her hands upon " +
      victim->the_short() + " and starts to pray softly.\n");
    tell_room(environment(), "As she does so her hands start to glow with a "
      "gentle silver light.\nThe light gradually intensifies until "
      "everything is bathed in it.\n");
    tell_object(victim, "As Althea prays you feel warmth spreading from her "
      "hands throughout your body.\n");
    tell_room(environment(), "Gradually the light fades.\n");
    tell_object(victim, "You feel much better.\n");
    tell_room(environment(), victim->the_short()+" looks much better.\n",
      victim);
    victim->set_hp(victim->query_max_hp());
    victim->adjust_gp(-HEAL_COST);
}
void check_injured() {
    object *people, person;
    people = filter(all_inventory(environment()), (: living($1) &&
        ($1->query_hp() < ($1->query_max_hp() / 2)) &&
        $1->query_al() < -300 :));
    people -= ({ this_object() });
    if (!sizeof(people))
        return;
    person = people[random(sizeof(people))];
    do_command("say Oh my, " + person->short()+ " you don't look so good.");
    do_command("say Allow me to heal you.");
    call_out((: do_heal($1) :), 1, person);
}
void event_fight_in_progress(object attacker, object victim) {
    if ( attacker != this_object() && victim->query_name() == "dickens" ) {
        if ( !dickens_warned ) {
            do_command( "say Fear not, Dickens, Pishe"
                " shall protect you!" );
            dickens_warned = 1;
            do_command( "protect dickens" );
            attack_ob( attacker );
        }
    }
    ::event_fight_in_progress( attacker, victim );
}
int adjust_hp(int hp, object attacker) {
    int result;
    result = ::adjust_hp(hp, attacker);
    if(hp < -1500)
        call_out("eek", 0);
    return result;
}
void eek() {
    init_command("use flail to cast sanctuary", 1);
    init_command("cast cure critical wounds on althea", 2);
    run_away();
}
void check_fumble( object ob ) {
    if ( environment( ob ) == environment() ) {
        do_command( "say Whoops, I must have dropped my precious flail!" );
        do_command( "get " + file_name( ob ) );
        do_command( "hold " + file_name( ob ) );
    }
}
void event_enter( object ob, string mess, object from ) {
    ::event_enter( ob, mess, from );
    if ( environment( ob ) == environment() &&
        ob->id( "flail" ) && ob->query_cloned_by() == "althea" ) {
        call_out( (: check_fumble :), 1, ob );
    }
}

==================================================
FILE: learning/cutnpaste/kess.c
==================================================

#define CREATOR "Ceres"
#include <armoury.h>
inherit "/obj/monster";
object rod;
void setup() {
  object chain;
  set_name("kess");
  set_short("Kess of Sek");
  set_main_plural("Kesses of Sek");
  set_long( "This is Kess, an Archcardinal of Sek.  She is a young woman, "+
           "and beautiful in a twisted kind of way.  She seems fairly "+
           "innocuous until you notice her eyes and see the vicious look in "+
           "them.\n" );
  add_adjective(({"archcardinal", "of", "sek"}));
  add_alias(({"priestess", "archcardinal", "cardinal"}));
  add_property("determinate","");
  add_property("unique", 1);
  set_gender("female");
  set_race("human");
  set_class("priest");
  set_deity("sek");
  set_level(260);
  set_height(140);
  set_weight(1000);
  set_al(2000);
  adjust_str(2);
  adjust_con(2);
  adjust_wis(5);
  adjust_int(-6);
  adjust_dex(-3);
  add_skill_level( "faith.items.rod", 250, 0 );
  add_skill_level( "fighting.combat.melee.blunt", 200, 0 );
  add_skill_level( "fighting.combat.parry.held", 200, 0 );
  add_known_command("kick");
  add_spell( "paralysis", "/obj/rituals/paralysis",
            "cast_spell" );
  add_spell( "fear", "/obj/rituals/fear",
            "cast_spell" );
  add_spell("cure medium wounds", "/obj/rituals/curemedium",
            "cast_spell" );
  add_spell("calm", "/obj/rituals/calm",
            "cast_spell" );
  add_spell( "rage", "/obj/rituals/rage",
            "cast_spell" );
  set_join_fights( "Blood-lust glows in Kess' eyes as she dives "+
                   "into the melee.\n" );
  set_join_fight_type(1);
  chain = ARMOURY->request_armour("chainmail", 100);
  chain->add_ac("magic", "magic", 60);
  chain->add_ac("fire", "fire" , 60);
  chain->add_ac("cold", "cold", 60);
  chain->move(this_object());
  chain->add_property("holy amulet", "sek");
  chain->add_property("sek", 1);
  ARMOURY->request_armour("blood red cloak", 100)->move(this_object());
  ARMOURY->request_armour("rope belt", 100)->move(this_object());
  ARMOURY->request_armour("soft leather shoes", 100)->move(this_object());
  rod = ARMOURY->request_weapon( "cleric rod", 100 );
  rod->whichone(6);
  rod->set_enchant(8);
  rod->move(this_object());
  clone_object("/obj/faith/sek_symbol.arm")->move(this_object());
  init_equip();
  ((object)ARMOURY->request_weapon("dagger", 100))->move(this_object());
  do_command("tactics response parry");
  do_command("tactics parry both");
  do_command("tactics attitude offensive");
  load_chat(20, ({2, ":smiles viciously.",
                  1, "@glare $lname$",
                  1, "@smirk",
                }));
  load_a_chat(20, ({1, "'Do you know who I am?",
                    1, "'Die unbeliever!",
                    1, "'You fight me, Sek will rip your heart out!"}) );
  set_virtual_move(1);
  set_move_after(30, 120);
  add_move_zone("Ankh-Morpork");
  add_move_zone("sek");
  add_enter_commands("#get_heart");
  add_combat_action(100, "maintenance", ({ "maintain_self" }) );
  add_combat_action(70, "fighting_stuff", ({ "fighting_stuff" }) );
  add_combat_action(50, "reequip", ({ "reequip" }));
}
void reequip(object thing1, object thing2) {
  if(this_object()->query_holding()[0] != rod) {
    do_command( "get yellow rod" );
    do_command( "hold yellow rod" );
  }
}
void fighting_stuff(object thing1, object thing2) {
  if(thing2 != this_object())
    return;
  switch(random(6)) {
  case 5:
    do_command("cast rage on "+thing1->query_name());
    break;
  case 4:
    do_command("cast fear on "+thing1->query_name());
    break;
  case 3:
    do_command("cast paralysis on "+thing1->query_name());
    break;
  case 2:
    do_command("use rod to cast dustdevil");
    break;
  case 1:
    do_command("use rod to cast barrier");
    break;
  default:
    do_command("concentrate on "+thing1->query_name());
    do_command("kick "+thing1->query_name());
    break;
  }
}
void maintain_self( object thing1, object thing2 ) {
   if ( thing2 != this_object() )
      return;
   if ( query_gp() < 200 )
      adjust_gp( 200 );
   if ( query_hp() < query_max_hp() / 4 )
     do_command( "use rod to cast sanctuary" );
   if ( query_hp() < query_max_hp() / 2 )
     do_command( "cast calm on "+thing1->query_name());
   if ( query_hp() < query_max_hp() )
     do_command( "cast cure medium wounds on kess" );
}
void event_death(object thing) {
  if(thing != this_object()) {
    call_out("get_heart", 3);
  }
}
void get_heart() {
  object corpse;
  if(find_match("corpse", environment()) != ({})) {
    do_command("hold dagger");
    do_command("get heart from corpse");
    do_command("eat heart");
    do_command("hold rod");
  }
}
int adjust_hp(int hp, object attacker) {
  ::adjust_hp(hp, attacker);
  if(hp < -300) {
    init_command("cast cure medium wounds on kess");
    if(!random(3))
      call_out("eek", 0);
  }
}
void eek() {
  do_command("lose all");
  run_away();
}

==================================================
FILE: learning/items/matcher.c
==================================================

inherit "/std/object";
#define CMD 0
#define PAT 1
void add_cmds( object player );
int do_add( string command, string pattern );
int do_remove( int i );
int do_match( object *indirect_obs, string dir_match,
    string *indirect_match, mixed args, string pattern );
string read_msg();
string *cmds = ({});
void setup() {
  set_name( "matcher" );
  set_short( "Tannah's pattern matcher" );
  add_property( "determinate", "" );
  add_alias( "pattern matcher" );
  set_long(
    "This is a very handy wossname, useful for testing patterns you "
    "might like to use in an add_command.\n"
  );
  add_adjective( ({ "handy", "patterned" }) );
  set_weight( 1 );
  set_value( 0 );
  add_property( "no recycling", 1 );
}
void init() {
  add_cmds( this_player() );
}
void add_cmds( object player ) {
  set_read_mess( (: read_msg :) );
  player->add_command( "add", this_object(), "command <word'command'> "
      "with pattern <string:quoted'pattern'>",
      (: do_add( $4[0], $4[1] ) :) );
  player->add_command( "remove", this_object(), "command <number>",
      (: do_remove( $4[0] ) :) );
  if( sizeof( cmds ) ) {
    for( int i = 0; i < sizeof( cmds ); i++ )
      player->add_command( cmds[i][CMD], this_object(), cmds[i][PAT],
          (: do_match :) );
  }
}
int do_add( string command, string pattern ) {
  cmds += ({ ({ command, pattern }) });
  this_player()->remove_object( this_object(), 1 );
  add_cmds( this_player() );
  printf( "You add the command \"%s\" with the pattern \"%s\" to the "
      "pattern matcher.\n", command, pattern );
  return 1;
}
int do_remove( int i ) {
  if( i >= sizeof( cmds ) || i < 0 ) {
    printf( "Invalid command number.\n" );
    return 0;
  }
  printf( "You remove the command \"%s\" with the pattern \"%s\" from "
      "the pattern matcher.\n", cmds[i][CMD], cmds[i][PAT] );
  cmds = cmds[0..i-1] + cmds[i+1..];
  this_player()->remove_object( this_object(), 1 );
  add_cmds( this_player() );
  return 1;
}
int do_match( object *indirect_obs, string dir_match,
    string *indirect_match, mixed args, string pattern ) {
  printf( "Indirect objects: %O\n", indirect_obs );
  printf( "Direct match: %s\n", dir_match );
  printf( "Indirect match: %O\n", indirect_match );
  printf( "Args: %O\n", args );
  printf( "Pattern: \"%s\"\n", pattern );
  return 1;
}
string read_msg() {
  int i;
  string msg;
  msg = "The pattern matcher is currently set to test the following "
        "commands and patterns:\n";
  if( !sizeof( cmds ) ) msg += "  None.\n";
  else for( i = 0; i < sizeof( cmds ); i++ ) {
    msg += sprintf( "[%d] \"%s\", \"%s\"\n", i, cmds[i][CMD],
           cmds[i][PAT] );
  }
  msg += "See 'syntax add' and 'syntax remove' to modify the list.";
  return msg;
  msg += "For further [nearly accurate] information on add_command, "
    "see the files in /w/tannah/learning/add_cmd.\n";
}
void list_cmds() {
  printf( "Commands and patterns added:\n%O\n", cmds );
}

==================================================
FILE: learning/chars/npc_example.c
==================================================

inherit "/obj/monster";
#include <armoury.h>
object comb;
void setup() {
   set_name( "ralph" );
   set_short( "Ralph the spotted giraffe" );
   add_property( "determinate", "" );
   add_adjective( "spotted" );
   set_main_plural("Ralph the spotted giraffes");
   add_plural(( { "ralphs", "giraffes" } ));
   add_alias(( { "giraffe", "Ralph" } ));
   set_long( "This is Ralph the spotted giraffe.  He is just an example in "
             "this file so I won't describe him although I should.  Well, "
             "okay then... He's like any normal giraffe except for his cool "
             "black specs and mop fringe.  He is coolnes personified.\n" );
   add_property( "unique", 1 );
   set_race( "horse" );
   set_guild("wizard");
   set_height( 300 );
   set_weight( 1600 );
   set_gender( 1 );
   set_al( -500 );
     set_level( 15 );
   set_con(18);
   set_dex(18);
   set_str(16);
   set_wis(15);
   set_int(15);
   add_move_zone( "Short" );
   add_move_zone( "Filigree" );
   set_move_after( 50, 60 );
   set_virtual_move(1);
   load_chat( 90, ({
      3, "@grin",
      3, "@high5 $lname$",
      2, "@bless $lname$",
      1, "@moonwalk",
      1, "'Far out man.",
      1, ({
         "'Hey, if it isn't $lname$!",
         "'You're looking cool as usual!"
      }),
      1, ":tells you: Hey my man!  Watcha up to?",
      1, "'That's cool.",
      1, "'Chillin' out here, are we?",
      1, "@ruffle $lname$",
      1, "@wink $lname$",
      2, ":does a really complicated tap dance manoeuvre.",
      1, "'Let's do something wild and crazy...",
      1, ({
         "'Yoho, how's it hangin'?",
         "'I'm in a darn good mood today!"
      }),
      1, ":tells you: Ouch man, where the heck did you find those clothes?"
   }) );
   load_a_chat( 100, ({
     1, "'Wait till Hobbes hears about this!",
     1, "'It's SO uncool to fight!",
     1, "@scream",
     1, "You can't believe you're fighting such a nice creature as Ralph.",
     1, ":seems to wish he was somewhere else."
     }) );
   ARMOURY->request_weapon("meat cleaver", 80+random(20))->move(this_object());
   ARMOURY->request_armour("gigantic dog collar", 100)->move(this_object());
   ARMOURY->request_armour("straw hat", 80)->move(this_object());
   comb=clone_object("/d/am/items/comb");
   comb->move( this_object() );
   init_equip();
}

==================================================
FILE: learning/chars/path.h
==================================================

#include <learning.h>
#define TERRAIN_TUTORIAL HELP +"rooms/terrains/"

==================================================
FILE: learning/chars/terrain_teacher.c
==================================================

#include <armoury.h>
#include "path.h"
inherit "/obj/monster";
#define TERRAIN_CONTROL "/d/admin/room/terrain"
#define PROPERTY "terrain lesson stage"
#define CROSS_IMPATIENCE 100
#define TAPS_IMPATIENCE 200
#define MAX_IMPATIENCE 300
#define COSTUME_NORMAL 0
#define COSTUME_DESERT 1
#define COSTUME_WET 2
#define COSTUME_COLD 3
int costume_normal();
int costume_desert();
int costume_wet();
int costume_cold();
protected void to_terrain();
protected void from_terrain(string to);
object hq;
object pupil;
int impatience;
int costume;
int lesson_step;
int speeching;
mixed *lessons =
({
   ({ "grassyfield", COSTUME_NORMAL,
      ({
         "emote sniffs the air.",
         "smile",
         "'This is a very simple terrain.  Take a little time to look around "
            "at it, wander around, read some of the code.  There isn't a whole "
            "lot to it.  When you feel you know what's here, come back and tell "
            "me you're ready.  I'll wait until you say \"ok\" or "
            "\"ready\" where I can hear you.  If you accidentally wander back to "
            "the foyer, type 'grassyfield' to return here.",
         0,
         "'You should have noticed that there are two different rooms in this "
            "area: the room in which we stand now, with this quaint cottage "
            "behind me, and the rooms of the field.",
         "'All the rooms are very simple.  You should have read the code for "
            "them.  If you haven't, do it now.  I'll wait until you're ready.",
         0,
         "'I assume that you have written rooms, both indoors and outdoors, "
            "before.  You should have noticed two strange features to the files "
            "that make up this area: first that they both have a call to a "
            "function called set_terrain(), and second that they both are "
            "remarkably lacking in add_exit() calls!",
         "'In fact, excepting this one 'cottage' exit behind me, the files "
            "have no exits at all.  Nevertheless, you were able to walk around "
            "quite freely.",
         "'That is the primary purpose to the terrain handler: it manages your "
            "exits for you.",
         "'The call to set_terrain(), then is simply the means by which you "
            "can tell the terrain handler that it needs to manage this room.",
         0,
         "'There are two types of rooms that the terrain handler can manage: "
            "fixed rooms and floating rooms.  The code for both looks the same, "
            "but the terrain handler treats them very differently.",
         "'In order for the terrain handler to know how to handle each room, "
            "you have to tell it.  That's done in the terrain handler control "
            "room: /d/admin/room/terrain.  You can get there from the commonroom "
            "by walking one east then one southeast.  Personally, I prefer to "
            "use an alias.",
         "'We'll go to the terrain control room in a moment, so you can see "
            "how to use it.  For the moment, suffice to say that every room "
            "that has a call to set_terrain() also needs to be registered in "
            "the terrain control room.",
         0,
         "'In this terrain, we have the doorstep (a fixed room) and all the "
            "rooms of the field (floating).  The primary difference between "
            "floating and fixed rooms is that you can only have one of each "
            "fixed room in a terrain, but you can have any number of floating "
            "rooms.",
         "'In fact, you probably noticed that this area is a 3x3 grid.  We're "
            "in the center of the southern edge of that grid right now, at the "
            "doorstep.",
         "'When I created this terrain, I just said that the field should "
            "cover the entire 3x3 area.  Then I plopped the fixed room down here, "
            "and it automatically took the place of the field room that would "
            "have been here.",
         "'This is an important concept: floating rooms cover predefined "
            "regions, while fixed rooms are in one place.  When a particular "
            "location is in the region of a floating room _and_ is the location "
            "of a fixed room, the fixed room wins.",
         "'This makes it so you can define huge sweeping areas of the floating "
            "rooms, and just plop down your fixed rooms in strategic areas.",
         0,
         "'Now, when I say 'location', what I'm referring to is the coordinates "
            "of the room.  As a creator, you can look at a room, and the "
            "coordinates (or \"unset\") appear just before the description.  "
            "As you work on terrains, you'll find yourself looking at those "
            "coordinates a lot.",
         "'Walk around a bit, and see how the coordinates change as you move "
            "in the different directions.  You will see the first number "
            "increase when you walk north, and decrease when you walk south.  "
            "The second increases when you walk east, and the third increases "
            "whenever you go up.",
         "'So that's ( north, east, up ).",
         0,
         "'Ok, let's show you the terrain control room now.",
         (: this_object()->to_terrain() :),
         "'Ok, here we are in the terrain control room.",
         "'Feel free to look at the room here before I explain everything "
            "to you.  Well, not quite everything: that green box is an advanced "
            "device for a later lesson.",
         0,
         "'The first thing you need to do before using the terrain room is "
            "always, always, always, set the terrain name.  Do that with the "
            "\"terrain\" command.",
         "'Type \"terrain tutorial_grassy_field\".  Be very careful about "
            "the spelling, you have to get it exactly right.",
         "'If you're worried, just type \"terrain\" and the room will "
            "show you the current terrain",
         0,
         "'Now that you've set the terrain, you can list the rooms that I "
            "have set here.  Use \"list floating\" to see all the floating "
            "rooms, and \"list fixed\" to see all the fixed rooms.",
         "'As I've mentioned before, this terrain only has one fixed and "
            "one floating room.",
         0,
         "'When it lists the floating room, it tells you the name of the "
            "file, the coordinates of two opposite corners of the region, and "
            "one final number.  That last number is a priority.  We'll talk "
            "about that in the second lesson.  For now, ignore it.",
         "'In this terrain, we have the field room in the whole area where "
            "the first coordinate is between -100 and 100 (inclusive), the "
            "second coordinate is between -100 and 100 (inclusive), and "
            "the third coordinate is equal to 800000.",
         "'The only reason for that strange third coordinate was that I wanted "
            "to keep these rooms far away from the player areas.",
         "shrug",
         "'That number before the file name is just an index in the list of "
            "floating rooms.  Since we only have one floating room, it isn't "
            "very useful to us.",
         0,
         "'Both of our rooms inherit /std/room/outside.  That makes the rooms 100 "
            "units wide in each direction.  So in that range of coordinates, we "
            "can have 3 rooms: -100, 0, and 100 for each of the first two "
            "coordinates.  So the whole terrain is a 3x3 block.",
         0,
         "'Now looking at the fixed room, it gives you the name of the file "
            "and _one_ set of coordinates.  That's it.  There's only the one set "
            "of coordinates, because each fixed room can only be in one location.",
         "'If you try to add another fixed room with the same file, the "
            "terrain control room will gripe at you and refuse to do it.  You'll "
            "have to remove the old room first.  You do that with the \"remove\" "
            "command, but we'll get to that later.",
         0,
         "'Notice that the fixed room is at (-100, 0, 800000).  That is inside "
            "the range of coordinates that we have set for the floating rooms: "
            "the first and second coordinates are between -100 and 100, and the "
            "last coordinate is 800000.  But this is a fixed room, so it wins the "
            "fight for that location.",
         "'This is what I was talking about earlier, when I mentioned putting "
            "the doorstep in the middle of the southern edge of the square: -100 "
            "is the southernmost edge of the square, while 0 is in the middle of "
            "that edge.",
         0,
         (: this_object()->from_terrain(TERRAIN_TUTORIAL "grassystep") :),
         "'And here we are back at the field.",
         "'That's it for the basic terrain lesson.  Wander around a bit more "
            "to look at the things I have mentioned, and come back here when "
            "you're ready to finish this lesson up.",
         "'There are more lessons available to you, so if you're up to it, "
            "talk to me when we get back to the foyer, and I'll continue to teach "
            "you.",
         "smile",
         "'You've been an excellent pupil.",
         0,
         "'Good",
      }),
      "cottage"
   }),
   ({ "desert", COSTUME_DESERT,
      ({
         "stretch",
         "emote starts to sweat",
         "'Ah, the desert!",
         "'As in the field, take a moment to wander around here.  Use what you "
            "learned in the first lesson, and look a bit more closely at the rooms "
            "in this area.",
         0,
         "'You should have noticed that there are three different areas in this "
            "terrain: this spot here next to the tent, the desert, and an oasis.  "
            "If you didn't notice, look at it now.",
         0,
         "'Once again, we have a largely square area, this time 6 squares east "
            "and west, and 5 squares north and south.  As you might have guessed, "
            "I created this area by covering the whole square with the desert "
            "room, and then plopped down this room in the corner.  But the oasis "
            "squares are interesting.  Let's go to the terrain control room and "
            "see.",
         (: this_object()->to_terrain() :),
         0,
         "'Ok, set the terrain to \"tutorial_desert\".  If you've forgotten, "
            "that's \"terrain tutorial_desert\".",
         "'When you've done that, list the floating rooms to see some nifty "
            "stuff.",
         0,
         "'Notice how I've got two rooms here: sanddunes and sandoasis.",
         "'Look carefully at the coordinates for the rooms, and you'll see that "
            "the sandoasis rooms overlap the sanddunes rooms.\n",
         "'The important difference is that last number.  Sanddunes says that "
            "it is \"level 0\", while sandoasis says it is \"level 1\".",
         "'The level is a kind of priority: when two or more floating rooms are "
            "at the same coordinates, the one with the highest level wins, and "
            "will be the room that the terrain handler actually puts down.",
         "'So in this terrain, the far northwest corner (that's at "
            "200, 1000, 800000) is in both the sanddunes and the sandoasis "
            "areas.  But since sandoasis has a higher level, that location "
            "is an oasis.",
         0,
         "'This little wrinkle lets you overlay lots of different rooms, "
            "stacking them up, to get very complex shapes without having to "
            "plop down rooms one by one.",
         "'For example, suppose one room covers (-200, -200, 0) to "
            "(200, 200, 0), at level 0.  Then we put a second room from "
            "(-100, -100, 0) to (100, 100, 0) at level 1.  The first room "
            "makes a 5 by 5 ring around the second area, which is 3 by 3.",
         "'We can make that more complex by putting more of the first "
            "room down, from (0, 0, 0) to (0, 100, 0) at level 2.  Now the "
            "center area, instead of being a 3 by 3 square, is a kind of "
            "'C' shape.  It might be helpful to draw that out on a piece "
            "of graph paper, so you can see it better.",
         0,
         "'Using these levels, you can even make it so that a terrain has "
            "holes in it.  That's convenient when you want to force people "
            "to walk around something.  Just add a floating room with a high "
            "level, and use the special file name \"nothing\".",
         0,
         "'Well, that's it for this lesson.",
         (: this_object()->from_terrain(TERRAIN_TUTORIAL "sandtent") :),
         "'Come back again, and we'll talk about some of the pitfalls "
            "involved in designing terrains.",
         0,
      }),
      "tent"
   }),
   ({ "mountaintop", COSTUME_COLD,
      ({ "rub hands",
         "shiver",
         "'Sorry about the cold, I never got around to putting a door on "
            "this cabin.",
         "frown",
         "shrug",
         "'Oh well.",
         "'This time, I don't want you to wander freely around the terrain: "
            "it's much more complex than the others you've explored, and I want "
            "to do this one one step at a time.",
         0,
         "'This room right here is a fixed room.  We have one more fixed room "
            "upstairs, and both are connected by the staircase behind me.  That "
            "exit was added automatically by the terrain handler, just as in "
            "the case of floating rooms, but here we have two fixed rooms whose "
            "exits are being managed.",
         "'We'll go to the terrain control room in a moment, but first I want "
            "to show you a few things.",
         "'Look at the coordinates for this room.  If you didn't see the "
            "coordinates when you came in to this room, 'look' now.",
         0,
         "up",
         "'Now compare the coordinates of this room to the room we were just "
            "in.",
         0,
         "'Previously, whenever you moved from one room to another, the "
            "coordinates changed by 100.  This time, they only changed by 20.",
         "'Previously, all our rooms were 100 units across.  These two "
            "rooms, however, are only 20.  That's because our previous rooms "
            "all inherited /std/room/outside, while these two cabin rooms inherit "
            "/std/room/basic_room.  The code assumes that indoor rooms tend to be smaller "
            "than the great outdoors.",
         "'One side effect of that is that you have to be careful when "
            "lining up rooms in the terrain control room.  Be sure to check "
            "that the positions you give your rooms line up right, so the "
            "terrain handler can generate the correct exits.",
         "'In this case, I had to make sure that I planted this attic "
            "exactly 20 units above the other room.",
         0,
         "'This gets a little bit hairy when you have an indoor room "
            "meeting an outdoor room.  Let's look at that now.",
         "down",
         "'Here's an indoor room",
         0,
         "west",
         "lsay And here's an outdoor room",
         0,
         "lsay This time the coordinates changed by 60.",
         "lsay \"60?!  Where'd 60 come from?\" I bet you ask?",
         "lsay I've already said that outside rooms are 100 units across, and "
            "indoor rooms are 20 units across.  So from the center of an outside "
            "room, the walls are all 50 units from you.  From the center of an "
            "indoor room, the walls are 10 units from you.  Normally, when you go "
            "from the center of one outdoor room to another, that's 50 units in "
            "the first room, and another 50 units in the destination room: 100 "
            "units total",
         "lsay Likewise, in an indoor room, you go 10 units in the first room, "
            "and another 10 units in the second room: 20 units total.",
         "lsay So the 60 units we just moved is 10 units in the indoor room "
            "where we started, plus another 50 units in the outdoor room where "
            "we ended up.",
         "lsay Of course, I had to take that into account in the terrain "
            "control room when I lined up these rooms.",
         0,
         "lsay Now, there's one more thing that I want to show you before "
           "we go to the terrain room.",
         "sw",
         "s",
         "lsay Here's a tree that I planted a few years ago.  We can climb "
            "it.",
         "up",
         0,
         "lsay Did you notice the change in coordinates this time?  70.",
         0,
         "lsay Now this tree that we're hanging from is an outdoor room, as "
            "you can tell by all the weather we're having.  However, it's not "
            "the usual size.",
         "lsay Do 'find -d setup() here', to read the setup function for this "
            "room.  Notice how I have a call to set_room_size() just before "
            "the call to set_terrain().  That set_room_size() controls how far "
            "the walls are from the center of the room.  So this room is twice "
            "that width: 40 units across and 40 units tall.",
         "lsay That should account for the coordinates changing by 70 when "
            "we climbed the tree: 50 as we left the lower room, and 20 coming in "
            "to this room.",
         0,
         "lsay You can change the size of any room you want this way, but "
            "make absolutely sure that you call set_room_size() _before_ "
            "you call set_terrain().  That is critically important, and all "
            "sorts of subtle bugs can happen, generally involving the wrong "
            "exits showing up, if you get that wrong.",
         "lsay Also, set_room_size() can take an array of 3 coordinates to "
            "control the size of the room separately in all three dimensions.",
         "lsay Unfortunately, the terrain handler doesn't understand that "
            "level of complexity, so don't ever do it with rooms you expect to "
            "have managed by the terrain handler.",
         0,
         "lsay ok, let's go to the terrain control room, and you can look "
            "at my work.",
         (: this_object()->to_terrain() :),
         "lsay Here we...",
         "blush",
         "' Heh.  Got so used to yelling over the wind...",
         "smile",
         "'Here we are in the terrain room.  Set the terrain to "
            "tutorial_mountain and list out the fixed rooms.",
         0,
         "'Notice the last coordinates on both.  That's what I mentioned "
            "before, that I had set the two 20 units apart.",
         "'Now list the floating rooms.",
         0,
         "'Here I've done something different.  The mountainsnows room "
            "makes a big square, 5 by 5.  In the very center of that square, "
            "there is a 'nothing' room.  You should remember from the last "
            "lesson, that when the filename of a floating room is 'nothing', "
            "the terrain handler puts no room at that location.  So here we "
            "have the floating terrain with a hole in the middle.",
         "'Inside that hole, I plopped down the cabin.  How it's not "
            "centered in that hole, it's actually to the west of the center.",
         "'That's because I needed to ensure that, with the differente "
            "sizes of the outside vs. inside rooms, things would still line up.",
         "'So when you walk out of the cabin, you walk west.  When you walk "
            "around it, the terrain handler doesn't give you any extra entrances "
            "to the cabin.",
         0,
         "'There's one extra thing I had to do to get the cabin to work right, "
            "and I'll show you that soon, but first notice the mountaintree "
            "rooms.  There shouldn't be any suprises with that, just remember "
            "that the tree rooms are a different size.",
         0,
         "'Ok, back to the cabin.",
         (: this_object()->from_terrain(TERRAIN_TUTORIAL "mountaincabin") :),
         "'Here we are, back in the ground floor of the mountain cabin.",
         "'Notice how we have 3 exits here: up, down, and west.  Obviously, "
            "there's no north, east, or south exits, because we have that "
            "'nothing' room right here.",
         "lsay Wrong!",
         "grin",
         "'That 'nothing' trick only works with floating rooms.  In order to "
            "ensure that this room doesn't have the north, east, and south exits, "
            "I had to add a special function to the room.",
         "'Type 'find -d query_exit_type() here'",
         0,
         "'In any room that is managed by the terrain handler, whether than "
            "room is a floating room or a fixed room, the terrain handler checks "
            "a function called query_exit_type() to see what type of exit it "
            "should create in each direction.",
         "'The arguments are a string for the direction of the exit (north, "
            "west, south, northeast, etc.) and a string containing the file name "
            "of the destination room.  These are both just like you would use "
            "in a call to add_exit().",
         "'The function returns a string for an exit type, just like the "
            "third argument to add_exit().",
         "'There is, of course, a wrinkle: if query_exit_type() returns "
            "\"none\", then that exit isn't created at all.",
         0,
         "'If the room doesn't have a function called query_exit_type(), "
            "then some default values are used.  Those defaults are in an array "
            "at the beginning of /obj/handlers/terrain_handler.  It's real "
            "easy to find.",
         "'There are a lot of things that can be done to modify the exits "
            "that the terrain handler builds, but that'll be the subject for the "
            "next lesson.",
         "'For now, wander around if you feel like it, and come back to me "
            "when you're ready to finish this up.",
         0,
      }),
      "down"
   }),
   ({ "grassyfield", COSTUME_NORMAL,
      ({ "laugh",
         "'In spite of dragging you out here like this, Sin hasn't actually "
            "scripted this lesson yet.  Sorry.  This would've been the fourth "
            "lesson, in which I talk about how you can modify the exits that "
            "the terrain handler makes for you.",
         "shrug",
      }),
      "cottage"
   }),
});
void setup() {
   object obj;
   object backpack;
   set_name("terrain teacher");
   add_alias("teacher");
   set_short("terrain teacher");
   add_property("determinate", "the ");
   add_property("unique", 1);
   set_long("This man is middle aged, and apparently human.  That's about "
            "all you can really see, because he's soaking wet, his hair is caked "
            "with leaves and mud, his clothes are torn, and his boots are caked "
            "with dirt.\n");
   set_race("human");
   set_guild("monk");
   set_level(50);
   set_gender(1);
   add_effect("/std/effects/other/wetness", 10000);
   set_respond_to_with( ({
      ({ "@say", "teach", "please" }), "#new_pupil",
      ({ "@say", "please", "teach" }), "#new_pupil",
      ({ "@say", "teach" }), "#new_rude_pupil",
      ({ "@say", ({ "ok", "ready" }) }), "#next_speech",
   }) );
   backpack = ARMOURY->request_item("large backpack", 80);
   if (!backpack) backpack = ARMOURY->request_item("black leather backpack", 80);
   if (!backpack) backpack = ARMOURY->request_item("small backpack", 80);
   if (backpack) backpack->move(this_object());
   obj = ARMOURY->request_item("large leather boots", 20);
   if (obj) obj->move(this_object());
   obj = ARMOURY->request_item("thermal underwear", 10);
   if (obj) obj->move(this_object());
   obj = ARMOURY->request_item("fawn cotton trousers", 50);
   if (obj) obj->move(this_object());
   obj = ARMOURY->request_item("leather belt", 50);
   if (obj) obj->move(this_object());
   obj = ARMOURY->request_item("black wool socks", 40);
   if (obj) obj->move(this_object());
   obj = ARMOURY->request_item("gaudy shirt", 35);
   if (obj) obj->move(this_object());
   obj = ARMOURY->request_item("brown felt hat", 10);
   if (obj) obj->move(this_object());
   obj = ARMOURY->request_item("white cotton toga", 80);
   if (obj) obj->move(backpack);
   obj = ARMOURY->request_item("yellow raincoat", 60);
   if (obj) obj->move(backpack);
   obj = ARMOURY->request_item("old black cloak", 72);
   if (obj) obj->move(backpack);
   obj = ARMOURY->request_item("amusing earmuffs", 100);
   if (obj) obj->move(backpack);
   init_equip();
   costume = COSTUME_NORMAL;
   hq = find_object(TERRAIN_TUTORIAL "foyer");
   impatience = 0;
   lesson_step = 0;
   speeching = 0;
}
int check_anyone_here() {
   if (pupil) return 1;
   else return ::check_anyone_here();
}
void heart_beat() {
   ::heart_beat();
   if (!pupil) return;
   ++impatience;
   if (impatience == CROSS_IMPATIENCE) {
      init_command("emote is beginning to look a bit impatient.", 1);
   } else if (impatience == TAPS_IMPATIENCE) {
      init_command("emote begins tapping his foot.", 1);
   } else if (impatience == MAX_IMPATIENCE) {
      init_command("'That's it, you clearly don't really want to learn.  "
                   "I give up on you, " + pupil->short(), 1);
      call_out("come", 3 + costume_normal(), hq);
      pupil = 0;
      impatience = 0;
   }
}
int add_follower( object who ) {
   if (who == pupil) {
      int lesson;
      impatience = 0;
      lesson = pupil->query_property(PROPERTY);
      if (lesson < 0 || lesson >= sizeof(lessons)) {
         init_command("think", 1);
         init_command("'Odd, you seem to have done more lessons than I know.", 2);
         init_command("'I'm afraid I have nothing to teach you.", 3);
         pupil->remove_property(PROPERTY);
         pupil = 0;
         return 0;
      } else if (::add_follower(who)) {
         int delay;
         switch (lessons[lesson][1]) {
          case COSTUME_NORMAL: delay = costume_normal(); break;
          case COSTUME_DESERT: delay = costume_desert(); break;
          case COSTUME_WET: delay = costume_wet(); break;
          case COSTUME_COLD: delay = costume_cold(); break;
         }
         init_command(lessons[lesson][0], delay + 2);
         lesson_step = 0;
         call_out("speech", delay + 10);
         return 1;
      } else {
         return 0;
      }
   } else {
      init_command("'For what reason do you want to follow me, " +
                   who->short() + "?  I'm not teaching you.", 0);
      return 0;
   }
}
void coming( object where ) {
   tell_room( where,
      "%^CYAN%^Someone says: One moment!  I'll be right down!%^RESET%^\n",
             ({ this_object() }) );
}
void annoyed_coming( object where ) {
  tell_room( where,
    "%^CYAN%^An annoyed someone says: I said I'm coming!  "
    "Jeez!%^RESET%^\n",
    ({ this_object() }) );
}
void come( object where ) {
   hq = where;
   if (where != environment())
      move( where, this_object()->a_short() + " arrives",
           this_object()->a_short() + " stomps away" );
   init_command( "emote looks around", 1 );
   init_command( "sigh", 4 );
   init_command( "get sign", 7 );
   init_command( "emote looks at the sign", 9 );
   init_command( "sit on bench", 10 );
   init_command( "'What can I do for you?", 12 );
}
void done() {
   int delay = costume_normal();
   int lesson;
   lesson = pupil->query_property(PROPERTY) + 1;
   if (lesson == sizeof(lessons)) {
      init_command("'congratulations, " + pupil->short() + ", you have "
                   "completed all the terrain handler lessons.", ++delay);
      pupil->remove_property(PROPERTY);
   } else
      pupil->add_property(PROPERTY, lesson);
   init_command("emote looks around", delay + 1);
   init_command("sigh", delay + 4);
   init_command("get sign", delay + 7);
   init_command("emote looks at the sign", delay + 9);
   init_command("sit on bench", delay + 10);
   pupil = 0;
   impatience = 0;
   speeching = 0;
}
void speech() {
   int lesson = pupil->query_property(PROPERTY);
   int delay;
   delay = 0;
   speeching = 1;
   if (lesson_step == sizeof(lessons[lesson][2])) {
      init_command(lessons[lesson][3], delay + 3);
      call_out("done", delay + 4);
      call_out( (: speeching = 0 :), delay + 5);
      return;
   }
   do {
      if (functionp(lessons[lesson][2][lesson_step])) {
         call_out(lessons[lesson][2][lesson_step], ++delay);
      } else if (stringp(lessons[lesson][2][lesson_step])) {
         init_command(lessons[lesson][2][lesson_step], ++delay);
      }
      if (++lesson_step == sizeof(lessons[lesson][2])) {
         init_command(lessons[lesson][3], delay + 3);
         call_out("done", delay + 4);
         call_out( (: speeching = 0 :), delay + 5);
         return;
      }
   } while (lessons[lesson][2][lesson_step]);
   lesson_step++;
   init_command("emote waits for " + pupil->a_short(), ++delay);
   call_out( (: speeching = 0 :), ++delay);
}
void pupil_arrived( object where ) {
   if (pupil) return;
   if (!environment()) {
      if (find_call_out("come") != -1)
         call_out("annoyed_coming", 0, where);
      else {
         call_out("come", 10, where);
         if (find_call_out("coming") == -1)
            call_out("coming", 2, where);
      }
   } else if (environment() == where) {
      init_command("'Oh, a pupil!", 2);
   }
}
protected void to_terrain() {
   move(TERRAIN_CONTROL, "The terrain teacher appears",
        "The terrain teacher snaps his fingers and vanishes");
   tell_object(pupil, "Something snags you through space\n");
   pupil->move_with_look(TERRAIN_CONTROL, pupil->short() + " appears",
                         pupil->short() + " looks surprised and disappears.");
}
protected void from_terrain( string to ) {
   move(to, "The terrain teacher appears",
        "The terrain teacher snaps his fingers and vanishes");
   tell_object(pupil, "Something snags you through space\n");
   pupil->move_with_look(to, pupil->short() + " appears",
                         pupil->short() + " looks surprised and disappears.");
}
protected int modesty() {
   int num;
   num = sizeof(filter_array(all_inventory(environment()),
            (: living($1) && $1->query_gender() != 1 :) ));
   if (num) {
      if (num > 1)
         init_command("'Ladies, would you please turn around for a "
                      "moment?", 1);
      else
         init_command("'Ma'am, would you please turn around for a "
                      "moment?", 1);
      return 10;
   } else return 0;
}
int costume_normal() {
   int i;
   if (costume == COSTUME_NORMAL) return 0;
   i = modesty();
   init_command("remove backpack", ++i);
   init_command("remove toga, raincoat, cloak, earmuffs", ++i);
   init_command("put toga, raincoat, cloak, earmuffs in backpack", ++i);
   init_command("get trousers, belt, shirt, hat from backpack", ++i);
   init_command("equip", ++i);
   costume = COSTUME_NORMAL;
   return i;
}
int costume_desert() {
   int i;
   if (costume == COSTUME_DESERT) return 0;
   i = modesty();
   init_command("remove backpack", ++i);
   init_command("remove raincoat, cloak, earmuffs", ++i);
   init_command("remove belt, hat, shirt", ++i);
   init_command("remove trousers", ++i);
   init_command("put trousers, belt, shirt, hat, raincoat, cloak, "
                "earmuffs in backpack", ++i);
   init_command("get toga from backpack", ++i);
   init_command("equip", ++i);
   costume = COSTUME_DESERT;
   return i;
}
int costume_wet() {
   int i;
   if (costume == COSTUME_WET) return 0;
   i = modesty();
   init_command("remove backpack", ++i);
   init_command("remove toga, cloak, earmuffs", ++i);
   init_command("put toga, cloak, earmuffs in backpack", ++i);
   init_command("get trousers, belt, shirt, hat, raincoat from "
                "backpack", ++i);
   init_command("equip", ++i);
   costume = COSTUME_WET;
   return i;
}
int costume_cold() {
  int i;
   if (costume == COSTUME_COLD) return 0;
   i = modesty();
   init_command("remove backpack", ++i);
   init_command("remove toga, raincoat, hat", ++i);
   init_command("put toga, raincoat, hat in backpack", ++i);
   init_command("get trousers, belt, shirt, cloak, earmuffs "
                "from backpack", ++i);
   init_command("equip", ++i);
   costume = COSTUME_COLD;
   return i;
}
void next_speech( object who, string message ) {
   if (who != pupil) return;
   if (speeching) return;
   impatience = 0;
   call_out("speech", 1);
}
void new_pupil( object who, string message ) {
   if ( pupil ) {
      if ( pupil == who ) {
         impatience = 0;
         init_command("pat " + who->short(), 1);
         init_command("'That's alright.  I understand you can get "
                      "excited at times like this.  Be assured that I am going "
                      "to teach you, " + who->short(), 3);
      } else {
         init_command("'sorry, " + who->short() + ", but I am teaching " +
                      pupil->short() + " right now.", 1);
      }
   } else {
      pupil = who;
      set_heart_beat(1);
      init_command("'Yes, " + pupil->short() +
                   ", I would be happy to teach you.", 1);
      init_command("drop sign", 3);
      init_command("stand", 4);
      init_command("'follow me, if you will", 6);
      impatience = 0;
   }
}
void new_rude_pupil( object who, string message ) {
   if (!pupil) {
      init_command("emote hums quietly to himself.", 2);
      init_command("mumble rude pupils", 5);
   }
}
mixed *stats() {
   return ::stats() +
      ({
         ({ "pupil", pupil ? pupil->query_name() : "no pupil" }),
         ({ "impatience", impatience }),
         ({ "costume", (costume == COSTUME_NORMAL) ? "normal" :
            ((costume == COSTUME_DESERT) ? "desert" :
             ((costume == COSTUME_WET) ? "wet" :
              ((costume == COSTUME_COLD) ? "cold" : "???"))) }),
         ({ "lesson step", lesson_step }),
      });
}

==================================================
FILE: dist/common.c
==================================================

#define DOM_TITLE "the domain of dist"
#define LORD "pinkfish"
#define DOMAIN "dist"
inherit "/std/dom/cmn_mas";
object board;
void setup() {
  set_dom(DOMAIN);
  set_light(100);
  add_exit("drum", "/d/am/am/mendeddrum", "door");
  set_short("Common room of "+DOM_TITLE);
  set_long("Large relaxing chairs addorn the room.  The walls are covered "+
           "with strange motifs from different lands and the little shelf "+
           "above the fireplace is chocker block full of strange figurines "+
           "and bits of cloth.  It appears to be the common room of "+
           DOM_TITLE+" the large red letters on the wall were the " +
           "give away.\n");
  add_alias("chairs", "chair");
  add_alias("cloths", "cloth");
  add_alias("motifs", "motif");
  add_alias("figurines", "figurine");
  add_item("chair", "The chairs are lazing around the room relaxing it looks "+
                    "like they come here after a hard days working in "+
                    DOM_TITLE+".\n");
  add_item("fireplace", "A nice little fire place with a cheery fire burning "+
                        "in it keeping every one warm.\n");
  add_item("figurine", "Small figurines, they look strangely familiar "+
                         "until you realise they are the members of "+
                         DOM_TITLE+".\n");
  add_item("cloth", "Strange coloured bits of cloth strewn over the "+
                    "mantlepice for no readily apparent reason.\n");
  add_item("motif", "The motifs on close inspection look like stylised "+
                     "signatures of all the members of "+DOM_TITLE+
                     ".  Some of them are very strange, in fact there "+
                     "seem to be more than there are members of the house.  "+
                     "perhaps it is the members of the future.\n");
  add_item("shelf", "A nice normal sort of shelf thing.  It is like all "+
                    "those ones you see in houses all over the place, "+
                    "execpt... the way it has been burnt... hmm it does "+
                    "not look like the fire did it.\n");
  add_item("fire", "There is a fire happily burning away in the fireplace "+
                   "spluttering and crackling to itself.  The flames almost "+
                   "seem afraid of something.  Looking closer you notice a "+
                   "picture tacked to the side of the fire place.\n");
  add_item("picture", "Tacked to the inside wall of the fire thingy, you "+
                      "know the hole bit at the bottom, is a small picture "+
                      "it looks like it was taken with the best of demon "+
                      "photography.  It is a picture of a person holding "+
                      "a small staff, you think it might be "+LORD+
                      " but you are not sure as the fire light sparkles "+
                      "in your eyes.\n");
  board = clone_object("/obj/misc/board");
  board->set_datafile(DOMAIN);
  board->move(this_object());
}
void dest_me()
{
  if(board) board->dest_me();
  ::dest_me();
}

==================================================
FILE: dist/loader.c
==================================================

#define DOMAIN "dist"
string *pre_load;
void create() {
  int i;
  seteuid((string)"/secure/master"->creator_file(file_name()));
  unguarded((: restore_object, file_name(this_object()) :));
  if (!pre_load)
    pre_load = ({ });
  for (i=0;i<sizeof(pre_load);i++) {
    printf(DOMAIN+" pre_loading "+pre_load[i]+".\n");
    if (catch(call_other(pre_load[i], "??")))
      call_out("do_load", 0, pre_load[i]);
  }
}
void do_load(string str) {
  call_other(str, "??");
}
int add_pre_load(string str) {
  if (member_array(str, pre_load) == -1)
    pre_load += ({ str });
  save_object(file_name(this_object()));
  return 1;
}
int remove_pre_load(string str) {
  int i;
  if ((i=member_array(str, pre_load)) == -1)
    return 0;
  pre_load = delete(pre_load, i, 1);
  save_object(file_name(this_object()));
}
string *query_pre_load() { return pre_load; }

==================================================
FILE: dist/master.c
==================================================

#define LORD "pinkfish"
#define DOMAIN "dist"
inherit "/std/dom/base_master";
string query_lord() {
  return LORD;
}
string author_file(string *path) {
  return capitalize(DOMAIN);
}
int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}
int valid_read(string *path, string euid, string funct);
int valid_write(string *path, string euid, string funct);
int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
}
string log_who(string where) {
  return LORD;
}
string query_info() {
  return "";
}

==================================================
FILE: dist/mtf/key_deft.c
==================================================

# "/std/outside"

==================================================
FILE: dist/mtf/mtf.c
==================================================

#include "mtfincl.h";
mapping get_exits(int ypos, int xpos, mixed *map, mapping keys) {
  int x, y;
  mapping exits = ([ ]);
  string *keylist, room;
  keylist = keys(keys);
  room = map[ypos][xpos][0];
  for(y = -1; y < 2; y++) {
    if(y+ypos < 0)
      continue;
    if(y+ypos >= sizeof(map))
      continue;
    for(x = -1; x < 2; x++) {
      if(x+xpos < 0)
        continue;
      if(x+xpos >= sizeof(map[y+ypos]))
        continue;
      if(!x && !y)
        continue;
      if(map[y+ypos][x+xpos] != 0) {
        exits[DIRECTIONS[y+1][x+1]] = upper_case(map[y+ypos][x+xpos][3]) +
          " + \"" + map[y+ypos][x+xpos][0] + "\"";
      }
    }
  }
  return exits;
}
int write_this_file(string istring, string dir, string fname, string sname,
                    mapping exits) {
  string str, tmp, exit;
  int i;
  str = "#include \"path.h\";\n\n";
  str += "inherit " + istring + ";\n";
  str += "\n";
  str += "void setup() {\n";
  str += "  set_short(\"" + sname + "\");\n";
  str += "  set_long(\"This is " + sname + " it hasn't had its long \"\n";
  str += "           \"description set yet.\\n\");\n";
  str += "  set_light( 80 );\n";
  for(i=0; i<sizeof(LIST); i++) {
    if(exits[LIST[i]] &&
       exits[LIST[(i+1) % sizeof(LIST)]] &&
       exits[LIST[(i+2) % sizeof(LIST)]]) {
      map_delete(exits, LIST[(i)]);
      map_delete(exits, LIST[(i+2) % sizeof(LIST)]);
    }
  }
  foreach(exit in keys(exits)) {
    str += sprintf("  add_exit(\"%s\", %s, \"road\");\n",
                   exit, exits[exit]);
  }
  str += "}\n";
  if(file_size(dir) != -2) {
    mkdir(dir);
    tmp = "#include \"../path.h\"\n";
    tmp += "#undef PATH\n";
    tmp += "#define PATH __DIR__\n";
    write_file(dir + "/path.h", tmp, 1);
  }
  return write_file( dir + "/" + fname + ".c", str, 1 );
}
mixed *read_map(string mapfile, mapping keys) {
  int i, j;
  mixed *map;
  string *lines;
  lines = explode(read_file(mapfile), "\n");
  map = allocate(sizeof(lines));
  for(i=0; i<sizeof(lines); i++) {
    map[i] = allocate(strlen(lines[i]));
    for(j=0; j<strlen(lines[i]); j++) {
      if(keys[lines[i][j]]) {
        keys[lines[i][j]][0] = to_int(keys[lines[i][j]][0]) + 1;
        map[i][j] = ({ keys[lines[i][j]][2] + keys[lines[i][j]][0] }) +
                         keys[lines[i][j]];
      } else {
        map[i][j] = 0;
      }
    }
  }
  log_file("/w/ceres/tmp.log", "%O", map);
  return map;
}
mapping read_keys(string keyfile) {
  mapping keys;
  string line, *lines;
  keys = ([ ]);
  lines = explode(read_file(keyfile), "\n");
  foreach(line in lines)
    keys[line[0]] = explode(line[1..], "\t");
  return keys;
}
int map_to_files( string mapfile, string fdir, string keyfile ) {
  int tot;
  string *file_tmp;
  string pstr;
  int x, y;
  mapping keys;
  mixed *temp_map, temp_exits;
  if(!mapfile || mapfile == "")
    return NO_MAP_FILE;
  file_tmp = this_player()->get_files(mapfile);
  if(!file_tmp || sizeof(file_tmp) != 1 || file_size(file_tmp[0]) < 1)
    return NO_MAP_FILE;
  else
    mapfile = file_tmp[0];
  if(!fdir || fdir == "")
    file_tmp = ({ this_player()->query_path() });
  else
    file_tmp = this_player()->get_files(fdir);
  if(!file_tmp || sizeof(file_tmp) != 1 || file_size(file_tmp[0]) != -2)
    return NO_FILE_DIR;
  else
    fdir = file_tmp[0];
  if(!keyfile || keyfile == "" )
    keyfile = DEFAULT_KEYS;
  file_tmp = this_player()->get_files(keyfile);
  if(sizeof(file_tmp) != 1 || file_size(file_tmp[0]) < 1)
    return NO_KEY_FILE;
  else
    keyfile = file_tmp[0];
  keys = read_keys(keyfile);
  temp_map = read_map(mapfile, keys);
  for(y = 0; y < sizeof(temp_map); y++) {
    reset_eval_cost();
    for(x = 0; x < sizeof(temp_map[ y ]); x++) {
      if(temp_map[y][x] != 0) {
        temp_exits = get_exits(y, x, temp_map, keys);
        if(sizeof(temp_map[y][x]) < 5) {
          return;
        }
        tot += write_this_file(temp_map[y][x][2],
                               fdir + "/" + temp_map[y][x][3],
                               temp_map[y][x][0], temp_map[y][x][4],
                               temp_exits);
      }
    }
  }
  pstr = "\n";
  pstr += "#define CITY \"" + fdir + "/\"\n";
  foreach(x in keys(keys))
    pstr += "#define " + upper_case(keys[x][2]) + " CITY + \"" + keys[x][2] +
      "/\"\n";
  tot += write_file( fdir+ "/path.h", pstr, 1 );
  return tot;
}

==================================================
FILE: dist/mtf/mtf2.c
==================================================

#include "mtfincl.h";
mixed *map;
mapping key_data;
class map_class {
  string filename;
  int counter;
  string inheritname;
  string basename;
  string short;
  string long;
  mapping exits;
}
class exit {
  string dest;
  int ypos;
  int xpos;
}
mapping get_exits(int ypos, int xpos) {
  int x, y;
  class map_class data;
  mapping exits = ([ ]);
  if(!classp(map[ypos][xpos]))
    return ([ ]);
  for(y = -1; y < 2; y++) {
    if((y*2)+ypos < 0)
      continue;
    if((y*2)+ypos >= sizeof(map))
      continue;
    for(x = -1; x < 2; x++) {
      if((x*2)+xpos < 0)
        continue;
      if((x*2)+xpos >= sizeof(map[(y*2)+ypos]))
        continue;
      if(!x && !y)
        continue;
      if(classp(map[(y*2)+ypos][(x*2)+xpos])) {
        data = map[(y*2)+ypos][(x*2)+xpos];
        if((map[y+ypos][x+xpos] == '*') ||
           (map[y+ypos][x+xpos] == '+' && (y == 0 || x == 0)) ||
           (map[y+ypos][x+xpos] == 'x' && (y != 0 && x != 0)) ||
           (map[y+ypos][x+xpos] == '|' && y != 0 && x == 0) ||
           (map[y+ypos][x+xpos] == '-' && y == 0 && x != 0) ||
           (map[y+ypos][x+xpos] == '\\' && y == -1 && x == -1) ||
           (map[y+ypos][x+xpos] == '\\' && y == 1 && x == 1) ||
           (map[y+ypos][x+xpos] == '/' && y == 1 && x == -1) ||
           (map[y+ypos][x+xpos] == '/' && y == -1 && x == 1)) {
          exits[DIRECTIONS[y+1][x+1]] = new(class exit,
                                            dest : upper_case(data->basename)+
                                            " + \"" + data->filename + "\"",
                                            ypos : y+ypos,
                                            xpos : x+xpos);
        } else if(map[y+ypos][x+xpos] != ' ') {
          debug_printf("Unknown direction char: %O (%c), %d - %d, %d - %d %O %s",
                       map[y+ypos][x+xpos], map[y+ypos][x+xpos], x, xpos, y, ypos,
                       map[ypos][xpos],
                       data->basename);
        }
      }
    }
  }
  return exits;
}
#ifdef 0
mixed *find_nearby(int ypos, int xpos, int distance, int direc) {
  string *dirs;
  int ny, nx;
  class exit tmp;
  if(distance > 4)
    return 0;
  if(!classp(map[ypos][xpos]))
    return 0;
  dirs = keys(map[ypos][xpos]->exits);
  if(direc >= sizeof(dirs))
    return 0;
  tmp = map[ypos][xpos]->exits;
  ny = tmp[]->ypos;
  nx = tmp[]->xpos;
  if(nx == xpos && ny == ypos) {
    if(direc == sizeof(dirs) -1)
      return 0;
    else
      direc++;
  }
  if(!find_nearby(ny, nx, ++distance);
}
#endif
string calc_long(int ypos, int xpos) {
  int x, y, sameroad;
  class map_class data;
  string *exits = ({ });
  string *junctions = ({ });
  string long_str;
  mixed *nearby;
  if(!classp(map[ypos][xpos]))
    return "";
  sameroad = 0;
  for(y = -1; y < 2; y++) {
    if((y*2)+ypos < 0)
      continue;
    if((y*2)+ypos >= sizeof(map))
      continue;
    for(x = -1; x < 2; x++) {
      if((x*2)+xpos < 0)
        continue;
      if((x*2)+xpos >= sizeof(map[(y*2)+ypos]))
        continue;
      if(!x && !y)
        continue;
      if(classp(map[(y*2)+ypos][(x*2)+xpos])) {
        data = map[(y*2)+ypos][(x*2)+xpos];
        if(map[y+ypos][x+xpos] == '+' &&
           map[ypos][xpos]->basename ==
           map[(y*2)+ypos][(x*2)+xpos]->basename) {
          sameroad++;
          exits += ({ DIRECTIONS[y+1][x+1] });
        }
      }
    }
  }
  for(y = -1; y < 2; y++) {
    if((y*2)+ypos < 0)
      continue;
    if((y*2)+ypos >= sizeof(map))
      continue;
    for(x = -1; x < 2; x++) {
      if((x*2)+xpos < 0)
        continue;
      if((x*2)+xpos >= sizeof(map[(y*2)+ypos]))
        continue;
      if(!x && !y)
        continue;
      if(classp(map[(y*2)+ypos][(x*2)+xpos])) {
        data = map[(y*2)+ypos][(x*2)+xpos];
        if(((map[y+ypos][x+xpos] == '*') ||
            (map[y+ypos][x+xpos] == '+' && (y == 0 || x == 0)) ||
            (map[y+ypos][x+xpos] == 'x' && (y != 0 && x != 0)) ||
            (map[y+ypos][x+xpos] == '|' && y != 0 && x == 0) ||
            (map[y+ypos][x+xpos] == '-' && y == 0 && x != 0) ||
            (map[y+ypos][x+xpos] == '\\' && y == -1 && x == -1) ||
            (map[y+ypos][x+xpos] == '\\' && y == 1 && x == 1) ||
            (map[y+ypos][x+xpos] == '/' && y == 1 && x == -1) ||
            (map[y+ypos][x+xpos] == '/' && y == -1 && x == 1)) &&
           map[ypos][xpos]->basename !=
           map[(y*2)+ypos][(x*2)+xpos]->basename) {
          if(member_array(map[(y*2)+ypos][(x*2)+xpos]->short, junctions) == -1)
            junctions += ({ map[(y*2)+ypos][(x*2)+xpos]->short });
        }
      }
    }
  }
#ifdef 0
  if(!sizeof(junctions)) {
    nearby = find_nearby(ypos, xpos);
  }
#endif
  long_str = "This is ";
  if(sizeof(junctions)) {
    long_str += map[ypos][xpos]->short + " at the junction with " +
      query_multiple_short(junctions) +
      ".\n";
  } else if(sameroad == 0) {
    long_str += "the end of " + map[ypos][xpos]->short;
  } else if(sameroad == 1) {
    long_str += "a fork in " + map[ypos][xpos]->short +
      " where it splits heading " +
      query_multiple_short(exits);
  } else {
    long_str += map[ypos][xpos]->short;
  }
  return long_str;
}
int write_this_file(string fdir, int ypos, int xpos) {
  class map_class room;
  string str, tmp, exit;
  mapping exits;
  int i;
  room = map[ypos][xpos];
  str = "#include \"path.h\";\n\n";
  str += "inherit " + room->inheritname + ";\n";
  str += "\n";
  str += "void setup() {\n";
  str += "  set_short(\"" + room->short + "\");\n";
  str += "  set_long(\"" + room->long + "\\n\");\n";
  str += "  set_light( 80 );\n";
  exits = room->exits;
  foreach(exit in keys(exits)) {
    i = member_array(exit, DIRECTIONS);
    if(i % 2 == 1 &&
       exits[DIRECTIONS[i-1]] &&
       exits[DIRECTIONS[(i+1) % sizeof(DIRECTIONS)]])
      str += sprintf("  add_exit(\"%s\", %s, \"secret\");\n",
                     exit, exits[exit]->dest);
    else
      str += sprintf("  add_exit(\"%s\", %s, \"road\");\n",
                     exit, exits[exit]->dest);
  }
  str += "}\n";
  if(file_size(fdir + "/" + room->basename) != -2) {
    mkdir(fdir + "/" + room->basename);
    tmp = "#include \"../path.h\"\n";
    tmp += "#undef PATH\n";
    tmp += "#define PATH __DIR__\n";
    write_file(fdir + "/" + room->basename + "/path.h", tmp, 1);
  }
  return write_file( fdir + "/" + room->basename + "/" + room->filename + ".c",
                     str, 1 );
}
mixed *read_map(string mapfile) {
  int i, j;
  mixed *temp_map;
  string *lines;
  lines = explode(read_file(mapfile), "\n");
  temp_map = allocate(sizeof(lines));
  for(i=0; i<sizeof(lines); i++) {
    temp_map[i] = allocate(strlen(lines[i]));
    for(j=0; j<strlen(lines[i]); j++) {
      if(key_data[lines[i][j]]) {
        key_data[lines[i][j]][0] = to_int(key_data[lines[i][j]][0]) + 1;
        if(sizeof(key_data[lines[i][j]]) < 4)
          debug_printf("Key data too small: %O", key_data[lines[i][j]]);
        temp_map[i][j] = new(class map_class,
                             filename : key_data[lines[i][j]][2] +
                             key_data[lines[i][j]][0],
                             counter : key_data[lines[i][j]][0],
                             inheritname : key_data[lines[i][j]][1],
                             basename : key_data[lines[i][j]][2],
                             short : key_data[lines[i][j]][3]);
      } else
        temp_map[i][j] = lines[i][j];
    }
  }
  return temp_map;
}
mapping read_keys(string keyfile) {
  mapping key_data;
  string line, *lines;
  key_data = ([ ]);
  lines = explode(read_file(keyfile), "\n");
  foreach(line in lines) {
    key_data[line[0]] = explode(line[1..], "\t");
  }
  return key_data;
}
int map_to_files( string mapfile, string fdir, string keyfile ) {
  int tot;
  string *file_tmp;
  string pstr;
  int x, y;
  if(!mapfile || mapfile == "")
    return NO_MAP_FILE;
  file_tmp = this_player()->get_files(mapfile);
  if(!file_tmp || sizeof(file_tmp) != 1 || file_size(file_tmp[0]) < 1)
    return NO_MAP_FILE;
  else
    mapfile = file_tmp[0];
  if(!fdir || fdir == "")
    file_tmp = ({ this_player()->query_path() });
  else
    file_tmp = this_player()->get_files(fdir);
  if(!file_tmp || sizeof(file_tmp) != 1 || file_size(file_tmp[0]) != -2)
    return NO_FILE_DIR;
  else
    fdir = file_tmp[0];
  if(!keyfile || keyfile == "" )
    keyfile = DEFAULT_KEYS;
  file_tmp = this_player()->get_files(keyfile);
  if(sizeof(file_tmp) != 1 || file_size(file_tmp[0]) < 1)
    return NO_KEY_FILE;
  else
    keyfile = file_tmp[0];
  key_data = read_keys(keyfile);
  map = read_map(mapfile);
  for(y = 0; y < sizeof(map); y++)
    for(x = 0; x < sizeof(map[ y ]); x++)
      if(classp(map[y][x])) {
        map[y][x]->exits = get_exits(y, x);
      }
  reset_eval_cost();
  for(y = 0; y < sizeof(map); y++)
    for(x = 0; x < sizeof(map[ y ]); x++)
      if(classp(map[y][x]))
        map[y][x]->long = calc_long(y, x);
  reset_eval_cost();
  for(y = 0; y < sizeof(map); y++)
    for(x = 0; x < sizeof(map[ y ]); x++)
      if(classp(map[y][x]))
        tot += write_this_file(fdir, y, x);
  pstr = "\n";
  pstr += "#define CITYROOM \"/d/am/cityroom\"\n";
  pstr += "#undef CITY\n";
  pstr += "#define CITY \"" + fdir + "/\"\n";
  foreach(x in keys(key_data))
    pstr += "#define " + upper_case(key_data[x][2]) + " CITY + \"" + key_data[x][2] +
      "/\"\n";
  tot += write_file( fdir+ "/path.h", pstr, 1 );
  return tot;
}

==================================================
FILE: dist/mtf/mtfincl.h
==================================================

#define PATH "/w/ceres/mtf-v1.1/"
#define VERSION v1.1
#define NO_MAP_FILE -1
#define NO_FILE_DIR -2
#define NO_KEY_FILE -3
#define DEFAULT_KEYS PATH+"key_dft.c"
#define SPECIALS ({ "*", "+", "x", "-", "|", "\\", "/" })
#define EXITS_NS ({ "north", "", "south" })
#define EXITS_WE ({ "west", "", "east" })
#define DIRECTIONS ({ ({ "northwest", "north", "northeast", }), ({ "west", "", "east", }), ({ "southwest", "south", "southeast" }) })
#define LIST ({"north", "northeast", "east", "southeast", "south", "southwest", "west", "northwest" })

==================================================
FILE: dist/start/entrance.c
==================================================

#include <config.h>
inherit "/std/room/basic_room";
void setup() {
   set_short("entrance");
   set_long("You are standing at the entrance to a big wide, well quite small, "
            "area.  Welcome to the Discworld mud distribution lib entrance.\n");
   set_light(70);
   add_exit("pumpkin", CONFIG_START_LOCATION, "road");
}

==================================================
FILE: dist/pumpkin/hospital.c
==================================================

#include <armoury.h>
#include <hospital.h>
#include <living.h>
#include <map.h>
#include <money.h>
#include <move_failures.h>
#include <route.h>
#include <wander.h>
#include "path.h"
#define MAX_HEAVIES 10
#define DAY 8 * 60 * 60
#define INTERVAL 20 * 60
#define MUD_TO_REAL 3
#define BLOCK 5
#define MAX_EMPTIES 12
#define MAX_MOVERS 60
#define SAVE_FILE SAVE +"hospital"
inherit "/std/room/basic_room";
nosave int alchemists, update, *alignments;
mapping uniques;
nosave int *al_data;
nosave string *city;
nosave object *empties;
nosave mapping blockages;
nosave mixed *movers;
nosave int am_npcs, last_check;
int ok_to_clone();
void get_weapon(object ob, string *items);
void get_armour(object ob, string *items);
void get_jewellery(object ob, string *items);
void setup() {
   set_keep_room_loaded(1);
   update = time();
   alignments = allocate( 50 );
   uniques = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 ) {
      unguarded( (: restore_object, SAVE_FILE :) );
   }
   alchemists++;
   unguarded( (: save_object, SAVE_FILE :) );
   city = ({
      "child", "rodent", "cockroach", "dog"
   });
   empties = ({ });
   blockages = ([ ]);
   movers = allocate( MAX_MOVERS );
   call_out( "check_movers", 10 );
   call_out( "housekeeping", INTERVAL );
}
int *query_al_data() { return al_data; }
mapping query_uniques() { return uniques; }
object *query_empties() { return empties; }
mapping query_blockages() { return blockages; }
int query_blockage( string this, string other, int number ) {
   if ( undefinedp( blockages[ this ] ) ) {
      if ( random( 100 ) >= BLOCK )
         number = -1;
      blockages[ this ] = blockages[ other ] = number;
   }
   return blockages[ this ];
}
mixed *query_movers() { return movers; }
void housekeeping() {
   object thing;
   update = time();
   foreach( thing in users() ) {
      if ( thing->query_creator() )
         continue;
      alignments[ random( sizeof( alignments ) ) ] =
            (int)thing->query_al();
   }
   al_data = 0;
   unguarded( (: save_object, SAVE_FILE :) );
   call_out( "housekeeping", INTERVAL );
}
int pick_al() {
   int one, *stats;
   if ( !al_data ) {
      al_data = allocate( 3 );
      stats = allocate( 4 );
      foreach( one in alignments ) {
         stats[ 0 ] += one;
         stats[ 1 ] += one * one;
         if ( one > stats[ 2 ] )
            stats[ 2 ] = one;
         if ( one < stats[ 3 ] )
            stats[ 3 ] = one;
      }
      stats[ 0 ] /= sizeof( alignments );
      stats[ 1 ] /= sizeof( alignments );
      stats[ 1 ] -= stats[ 0 ] * stats[ 0 ];
      stats[ 1 ] /= 10;
      if ( stats[ 1 ] < 50 )
         stats[ 1 ] = 50;
      stats[ 2 ] -= stats[ 3 ];
      if ( stats[ 2 ] < 2 )
         stats[ 2 ] = 2;
      al_data[ 0 ] = stats[ 0 ] - stats[ 2 ] / 2;
      al_data[ 1 ] = ( stats[ 2 ] * stats[ 2 ] ) / ( 12 * stats[ 1 ] );
      if ( al_data[ 1 ] < 5 )
         al_data[ 1 ] = 5;
      al_data[ 2 ] = ( 12 * stats[ 1 ] ) / stats[ 2 ];
      if ( al_data[ 2 ] < 25 )
         al_data[ 2 ] = 25;
   }
   return al_data[ 0 ] + roll_MdN( al_data[ 1 ], al_data[ 2 ] );
}
int make_unique( string word ) {
   if ( uniques[ word ] > time() )
      return 0;
    uniques[ word ] = time() + 1 * 60 * 60;
   unguarded( (: save_object, SAVE_FILE :) );
   return 1;
}
void add_mover( object thing ) {
   int number;
   number = MAX_MOVERS / 2 + random( MAX_MOVERS / 2 );
   if ( !pointerp( movers[ number ] ) )
      movers[ number ] = ({ thing });
   else
      movers[ number ] += ({ thing });
}
object get_monster( string type ) {
   object thing;
   object ob;
   switch( type ) {
      case "city" :
      case "pumpkin" :
         thing = get_monster( city[ random( sizeof( city ) ) ] );
         thing->add_property( "monster type", type +":"+
               (string)thing->query_property( "monster type" ) );
         thing->add_move_zone( "Pumpkin" );
         add_mover( thing );
         return thing;
      case "dog":
         thing = clone_object( CHARS + "dog" );
         if ( random( 4 ) )
            thing->set_type( "small" );
         else
            thing->set_type( "large" );
         thing->add_effect( "/std/effects/npc/i_died",
               ({ HOSPITAL, "regen_after_death" }));
         thing->add_effect( "/std/effects/npc/eat_edible" );
         thing->add_effect( "/std/effects/npc/savage_corpse" );
         thing->add_property( "monster type", type );
         thing->add_property("animal type", type);
         return thing;
      case "child":
         thing = clone_object( CHARS + "child_human" );
         return thing;
    case "cityguard":
      ob = clone_object(MONSTER);
      ob->add_property("monster type", type);
      ob->set_name("guard");
      ob->add_adjective("city");
      ob->set_main_plural( "city guards" );
      ob->set_short("city guard");
      ob->set_long("This is a city guard. He is supposed to protect the " +
        "city from undesirables. Sadly, Pumpkin isn't very fussy.\n");
      ob->set_race("human");
      ob->set_gender("male");
      ob->set_guild("fighter");
      ob->set_level(8);
      ob->set_al( pick_al() / 5 );
      ob->adjust_money( 5 + random( 10 ), "Pumpkin pence" );
      ob->load_chat(10, ({
          3, "@grumble bitterly",
          1, "@daydream",
          1, "@sigh heavily"
          }) );
      ob->load_a_chat(50, ({
          1, "'Ouch!",
          1, "'Come on! I don't need this.",
          1, "'Be on your way!",
          }) );
      ARMOURY->request_weapon("long sword", 40+random(40))->move(ob);
      if(random(2))
        ARMOURY->request_armour("hard leather cap", 70 + random(30))->move(ob);
      ob->init_equip();
      return ob;
    case "mercenary":
      ob = clone_object(MONSTER);
      ob->set_name("mercenary");
      ob->set_main_plural( "mercenaries" );
      ob->add_plural( "mercenaries" );
      ob->add_adjective("tough");
      ob->set_race("human");
      ob->set_class("fighter");
      ob->set_level( 50 + roll_MdN( 5, 50 ) );
      ob->set_al( pick_al() );
      ob->set_gender(random(2) + 1);
      ob->set_long("A tough battle scarred mercenary.  There are better "
                   "ways of filling in an afternoon than messing with the "
                   "likes of "+ob->query_objective()+".\n");
      ob->adjust_money( 5 + random( 50 ), "Ankh-Morpork pence" );
      ob->adjust_money( 1 + random( 5 ), "Ankh-Morpork dollar" );
      ob->load_chat(3, ({
        1, "'Anyone you don't like?",
        1, "'I'll do anything if the price is right?",
        1, "'Don't get me angry.  You won't like me when I'm angry."
      }));
      ob->load_a_chat(30, ({
        1, "'I'll show you who's boss.",
        1, "'You think you're so tough.",
        1, "The crowd runs in terror as the mercenary kills someone by "+
           "accident."
      }));
      get_weapon(ob, ({"bastard sword", "long sword", "morning star",
       "two-handed axe"}));
      get_armour(ob, ({"chainmail", "splintmail", "ringmail"}));
      ob->add_property("monster type", type);
      ob->init_equip();
      return ob;
    case "rodent":
      ob = clone_object(MONSTER);
      ob->set_name("rat");
      ob->set_short("rat");
      ob->set_race("rat");
      ob->set_level( random( 1 + random( 3 ) ) );
      ob->add_alias("city rat");
      ob->set_main_plural("rats");
      ob->add_adjective("dirty");
      ob->add_adjective("city");
      ob->set_long("This is a large rat.  It appears to have done well "+
       "living in the city.\n"+
       "The pollution must not affect it too much.\n" );
      ob->load_chat( 5, ({
         1, ":squeaks.",
         1, ":sniffs the air, whiskers twitching.",
         1, ":checks for dwarves."
      }) );
      ob->set_wimpy( 10 );
      ob->load_a_chat( 50, ({
         1, ":squeals in pain.",
         1, ":twitches fearfully."
      }) );
      ob->add_effect("/std/effects/npc/i_died",
                     ({ HOSPITAL, "regen_after_death" }));
      ob->add_effect( "/std/effects/npc/eat_edible" );
      ob->add_effect( "/std/effects/npc/savage_corpse" );
      ob->add_property("monster type", type);
      ob->add_property("animal type", type);
      return ob;
    case "cockroach":
      ob = clone_object(MONSTER);
      ob->set_name("cockroach");
      ob->set_short("cockroach");
      ob->set_race("cockroach");
      ob->set_level( random( 1 + random( 3 ) ) );
      ob->set_main_plural("cockroaches");
      ob->add_adjective("dirty");
      ob->add_alias("roach");
      ob->set_long( "This is a huge dirty great big cockroach, the size of "
             "your hand at least.  It waves its feelers at you and looks "
             "horrible and black.  Not only can cockroaches survive fires, "
             "plagues, earthquakes and miscellaneous acts of supernatural "
             "beings, they can survive in Ankh-Morpork!\n" );
      ob->load_chat( 5, ({
         10, ":scuttles around a bit.",
         10, ":cleans its feelers.",
         10, ":rushes around in circles.",
         1,  ":jerks off in a strange direction.",
      }) );
      ob->set_wimpy( 30 );
      ob->load_a_chat( 50, ({
         1, ":oozes horrible white stuff.",
         1, ":makes a sort of scraping noise."
      }) );
      ob->add_effect("/std/effects/npc/i_died",
                      ({ HOSPITAL, "regen_after_death" }));
      ob->add_property("monster type", type);
      ob->add_property("animal type", type);
      return ob;
    default:
      ob = clone_object(MONSTER);
      ob->set_name("failure");
      ob->set_short("failure");
      ob->set_long( "Please inform a creator about this object.\n"+
          "Type is "+ type +" from "+ file_name( previous_object() ) +".\n" );
      ob->add_property( "monster type", "failure:"+ type );
      return ob;
  }
}
void get_armour(object ob, string *items) {
  ARMOURY->request_armour(items[random(sizeof(items))], 50+random(50))->
    move(ob);
}
void get_jewellery(object ob, string *items) {
  ARMOURY->request_armour(items[random(sizeof(items))], 20+random(80))->
    move(ob);
}
void get_weapon(object ob, string *items) {
  ARMOURY->request_weapon(items[random(sizeof(items))], 50+random(50))->
    move(ob);
}
void regen_after_death(object player) {
  object ob, dest;
  string nam;
  if (!player)
    return ;
  nam = (string)player->query_property("monster type");
  dest = (object)player->query_property("start location");
  if ( !nam )
    return;
  if ( !dest )
    return;
  if(!ok_to_clone())
    return;
  ob = get_monster( explode( nam, ":" )[ 0 ] );
  dest->add_monster(player, ob);
  call_out("do_move", 10, ({ ob, dest }) );
}
void do_move(mixed *junk) {
  junk[0]->move(junk[1]);
}
string change_to_name(object ob) {
  return implode((string *)ob->query_adjectives(), " ")+
         (string)ob->query_name();
}
void do_run(object ob) {
  if (ob)
    ob -> run_away();
}
void fight_check(object ob, object ob1) {
  if (ob->query_property(previous_object()->query_name()))
    previous_object()->attack_ob(ob1);
}
void do_grin_laugh(object ob) {
  ob->add_respond_to_with(({ "@grin", ob->query_name() }),
                          "laugh man at $hname$");
}
void add_empty( object thing ) {
   empties -= ({ 0 });
   empties += ({ thing });
   if ( sizeof( empties ) > MAX_EMPTIES )
      empties = shuffle( empties )[ 0 .. MAX_EMPTIES - 1 ];
}
void move_monster( object thing ) {
   int i;
   string dest, direc, zone, *movez, *roomz;
   object place;
   if ( !thing )
      return;
   if ( (int)thing->query_hp() < 0 )
      return;
   if ( thing->query_property( PASSED_OUT ) || thing->query_fighting() ) {
      add_mover( thing );
      return;
   }
   movez = (string *)thing->query_move_zones();
   empties -= ({ 0 });
   if ( sizeof( empties ) && !thing->check_anyone_here() )
      foreach ( place in empties ) {
         roomz = (string *)place->query_zones();
         if ( !sizeof( roomz ) ) {
            empties -= ({ place });
            continue;
         }
         foreach ( zone in roomz ) {
            i = member_array( zone, movez );
            if ( i != -1 )
               break;
         }
         if ( i == -1 )
            continue;
         thing->move( place );
         place->add_monster( 0, thing );
         place->announce_entry( thing );
         empties -= ({ place });
         add_mover( thing );
         return;
      }
   place = environment( thing );
   if ( !place )
      return;
   add_mover( thing );
   foreach ( direc in shuffle( (string *)place->query_direc() ) ) {
      place->set_destination( direc );
      dest = (string)place->query_destination( direc );
      if ( !stringp( dest ) )
         continue;
      if ( !thing->check_anyone_here() && !find_object( dest ) )
         continue;
      if ( find_object( dest ) )
         roomz = (string *)dest->query_zones();
      else
         roomz = (string *)MAP->query_zones( dest );
      if ( !sizeof( roomz ) )
         continue;
      foreach ( zone in roomz ) {
         i = member_array( zone, movez );
         if ( i != -1 )
            break;
      }
      if ( i == -1 )
         continue;
      if ( place->query_relative( direc ) )
         direc = (string)thing->find_rel( direc, 0 );
      if ( thing->do_command( direc ) )
         return;
   }
}
void check_movers() {
   int when;
   object thing, *things;
   things = movers[ 0 ];
   movers[ 0 .. MAX_MOVERS - 2 ] = movers[ 1 .. ];
   movers[ MAX_MOVERS - 1 ] = 0;
   call_out( "check_movers", 10 );
   if ( !pointerp( things ) )
      return;
   foreach ( thing in things ) {
      if ( objectp( thing ) ) {
         when += 2;
         call_out( "move_monster", when, thing );
      }
   }
}
int ok_to_clone() {
  if(time() > last_check + 300) {
    last_check = time();
    am_npcs = sizeof( filter( named_livings(),
      (: environment( $1 ) && base_name( environment( $1
       ) )[0..4] == "/d/am" :) ) );
  }
  return ( am_npcs < MAX_AM_LIVING );
}
int *query_npcs() {
  return ({ am_npcs, last_check });
}

==================================================
FILE: dist/pumpkin/money_symboliser.c
==================================================

string symbolise_value( int value ) {
   int dollars;
   int pence;
   string s;
   if (value < 0) {
      s = "-";
      value = - value;
   } else {
      s = "";
   }
   dollars = value / 100;
   pence = ( value % 100 );
   if ( !pence ) {
      return "P$"+ s + dollars;
   }
   if ( !dollars ) {
      return s + pence +"p";
   }
   if ( pence < 10 ) {
      return "P$"+ s + dollars +".0"+ pence;
   }
   return "P$" + s + dollars + "." + pence;
}
int unsymbolise_string( string str ) {
  int dollars;
  int pence;
  if (strlen(str) < 2) {
    return 0;
  }
  if (str[0] == '$' ||
      lower_case(str[0..1]) == "p$") {
     if (str[0] == 'p') {
       str = str[1..];
     }
     if (sscanf(str, "$%d.%d", dollars, pence) == 2) {
        return dollars * 100 + pence;
     } else if (sscanf(str, "$%d", dollars) == 1) {
        return dollars * 100;
     }
  } else if (lower_case(str[<1..<1]) == "p") {
     if (sscanf(str, "%dp", pence) == 1) {
       return pence;
     }
  }
  return 0;
}

==================================================
FILE: dist/pumpkin/path.h
==================================================

#undef CITY
#define CITY "/d/dist/pumpkin/"
#define CITYROOM (CITY "inherit/cityroom")
#define RABBIT CITY + "rabbit/"
#define STABLE CITY + "stable/"
#define PUMPKIN CITY + "pumpkin/"
#define GUMBOOT CITY + "gumboot/"
#define FRUITBAT CITY + "fruitbat/"
#define STABLE CITY + "stable/"
#define CRUMPT CITY + "crumpt/"
#define PLAIN CITY + "plain/"
#define DESERT CITY + "desert/"
#define SQUASH CITY + "squash/"
#define WOODS CITY + "woods/"
#define HOSPITAL (CITY "hospital")
#define HOSPITAL_INC (CITY "handler/hostpial.h")
#define SAVE CITY + "save/"
#define CHARS (CITY + "chars/")
#define TERRAIN_HANDLER (CITY + "terrain/terrain_handler")

==================================================
FILE: dist/pumpkin/path2.h
==================================================

#undef CITY
#define CITY "/d/dist/pumpkin/"
#define CITYROOM (CITY "inherit/cityroom")
#define RABBIT CITY + "rabbit/"
#define STABLE CITY + "stable/"
#define PUMPKIN CITY + "pumpkin/"
#define GUMBOOT CITY + "gumboot/"
#define FRUITBAT CITY + "fruitbat/"
#define STABLE CITY + "stable/"
#define CRUMPT CITY + "crumpt/"
#define PLAIN CITY + "plain/"
#define PLAIN CITY + "plain/"
#define SQUASH CITY + "squash/"
#define PLAIN CITY + "plain/"

==================================================
FILE: dist/pumpkin/crumpt/bank.c
==================================================

#include "path.h"
inherit "/std/shops/bank";
void setup() {
   set_short("Pumpkin's Bank");
   set_long(
"The room is full of pumpkins with little dollar signs carved in the side.  "
"There is a wooden counter running across the room with some telers peering "
"through the wooden grill into the main room.\n");
   add_item("counter", ({ "long", "It is wooden and has a grill on top to "
            "seperate the tellers from the unwashed masses.",
            "position", "the counter" }));
   add_item("teller", "They peer out at through the grill wondering who has "
            "come to give them money.\n");
   add_item("pumpkin", "There are little pumpkins everywhere in the room.");
   set_light(70);
   set_percentage(95);
   set_place("Pumpkin");
   add_exit("south", CRUMPT + "crumpt7", "door");
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/crumpt/club_office.c
==================================================

#include "path.h"
#include <clubs.h>
inherit "/std/room/club_control_room";
void setup() {
   set_light(70);
   set_club_control_type(CLUB_ROOM_CLUB_ONLY);
   set_short("Club control room");
   set_long("This is a small cosy room with a nice comradely atmosphere "
            "about it.  There is a nice sofa and a desk with little club "
            "ornaments all over it.\n");
   add_item("sofa", ({ "long",
                      "The sofa looks nice and comfortable, just the spot "
                      "after a hard days hacking people into small bits.\n",
               "position", "the comfy sofa" }));
   add_item("desk",
            ({ "long",
                   "The brown leather covered desk looks really nice "
                   "and comforable sitting in the middle of the room like "
                   "that.  It is covered in small club shaped ornaments.\n",
               "position", "the large black desk" }));
   add_item("club ordanment",
            "The desk is covered in them, 'Real genuine minature babarian "
            "clubs'.  Looks like someone has a club fetish.\n");
   set_not_replaceable(1);
   clone_object("/obj/misc/top_clubs")->move(this_object());
   add_exit("south", PATH + "crumpt6", "door");
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/crumpt/crumpt1.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Crumpet Circle");
  set_long("This is Crumpet Circle at the junction with Pumpkin Way.
\n");
  set_light( 80 );
  add_exit("northeast", PUMPKIN + "pumpkin1", "road");
  add_exit("southwest", CRUMPT + "crumpt2", "road");
  add_exit("south", CRUMPT + "crumpt3", "road");
  set_monster( 1, "city" );
}

==================================================
FILE: dist/pumpkin/crumpt/crumpt2.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("northeast", CRUMPT + "crumpt1", "road");
  add_exit("southwest", CRUMPT + "crumpt4", "road");
  add_exit("northwest", CRUMPT + "post_office", "door");
  set_monster( 1, "city" );
}

==================================================
FILE: dist/pumpkin/crumpt/crumpt3.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("north", CRUMPT + "crumpt1", "road");
  add_exit("south", CRUMPT + "crumpt5", "road");
  set_monster( 1, "city" );
}

==================================================
FILE: dist/pumpkin/crumpt/crumpt4.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("northeast", CRUMPT + "crumpt2", "road");
  add_exit("southwest", CRUMPT + "crumpt6", "road");
  add_exit("north", CRUMPT + "family_office", "door");
  set_monster( 1, "city" );
}

==================================================
FILE: dist/pumpkin/crumpt/crumpt5.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("southwest", CRUMPT + "crumpt7", "road");
  add_exit("north", CRUMPT + "crumpt3", "road");
  set_monster( 1, "city" );
}

==================================================
FILE: dist/pumpkin/crumpt/crumpt6.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("northeast", CRUMPT + "crumpt4", "road");
  add_exit("south", CRUMPT + "crumpt8", "road");
  add_exit("north", PATH + "club_office", "door");
  set_monster( 1, "city" );
}

==================================================
FILE: dist/pumpkin/crumpt/crumpt7.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("northeast", CRUMPT + "crumpt5", "road");
  add_exit("southwest", CRUMPT + "crumpt9", "road");
  add_exit("north", CRUMPT + "bank", "door");
  set_monster( 1, "city" );
}

==================================================
FILE: dist/pumpkin/crumpt/crumpt8.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Crumpet Circle");
  set_long("This is Crumpet Circle at the junction with Fruitbat Avenue.
\n");
  set_light( 80 );
  add_exit("east", CRUMPT + "crumpt9", "road");
  add_exit("north", CRUMPT + "crumpt6", "road");
  add_exit("south", FRUITBAT + "fruitbat1", "road");
  set_monster( 1, "city" );
}

==================================================
FILE: dist/pumpkin/crumpt/crumpt9.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Crumpet Circle");
  set_long("This is the end of Crumpet Circle\n");
  set_light( 80 );
  add_exit("northeast", CRUMPT + "crumpt7", "road");
  add_exit("west", CRUMPT + "crumpt8", "road");
  set_monster( 1, "city" );
}

==================================================
FILE: dist/pumpkin/crumpt/family_office.c
==================================================

#include "path.h"
#include <clubs.h>
inherit "/std/room/club_control_room";
int check_playtester(string str, object ob, string special_mess);
void setup() {
   object table;
   set_light(100);
   set_club_control_type(CLUB_ROOM_FAMILY_ONLY);
   set_short("Family control room");
   set_long("White boards cover the walls of the room, in the middle of "
            "the boards is a large black desk.  Scribblings and weird lines "
            "joining squiggly blobs to other squiggly blobs cover the white "
            "boards.\n");
   add_sign("A large imposing 'read me' type sign.\n",
            (: query_club_warning_message() :),
            "sign");
   add_item("white board", "They are everywhere, the drawings all look "
                   "somewhat meaningless, although perhaps they are "
                   "trying to convey some sort of family tree feeling.  "
                   "All the drawings look rather old, odd really.  "
                   "A singular lack of white board markers or erasers "
                   "could be the reason behind it.\n");
   add_item("white board eraser",
                   "There are none of them here, not one, not even...  No "
                   "none at all.\n");
   add_item("white board marker",
                   "Looking around the place, there is a singular lack of "
                   "white board markers.\n");
   add_item("large black desk",
            ({ "long",
                   "The desk looks imposing in its bulk and girth.  It "
                   "looks a bit unused, although there is a register "
                   "sitting on top of the desk which seems to contain the "
                   "list of all the current clubs in Ankh-Morpork.\n",
               "position", "the large black desk" }));
   add_item("squiggly blob",
                   "It appears to be joined to another squiggly blob.\n");
   add_item("weird line",
                   "This line darts across the board at an angle that "
                   "is hard to determine, you guess 16.123678 degrees.\n");
   add_item("scribblings",
                   "They are not recognisably words, they just look like they "
                   "could be words until you take a closer look.\n");
   set_not_replaceable(1);
   add_exit("south", PATH + "crumpt4", "door");
   table = clone_object("/obj/misc/top_families");
   table->move(this_object());
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/crumpt/parcel_post.c
==================================================

#include "path.h"
inherit "/std/room/parcel_inherit";
void setup() {
   set_short("Parcel Post");
   set_long(
"Livid orange strips criss cross the room contrasting just beautifully "
"against the black background.  The walls almost seem to be pulsing with "
"colour.\n");
   set_light(70);
   add_exit("south", CRUMPT + "post_office", "south");
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/crumpt/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/crumpt/post_office.c
==================================================

#include "path.h"
#include <mail.h>
inherit "/std/room/basic_room";
int do_mail( string words );
private nosave object _dictionary;
void setup() {
   add_help_file("mail_room");
   set_short("Post Office");
   set_light(70);
   set_long(
"Black and orange colours seem to dominate the room, you can see a counter "
"or something in amongst all the clashing colours.\n");
   add_item("counter", ({ "long",
            "There are some envelopes and bits of paper strewn "
            "about on the counter.",
            "position", "the counter" }));
   add_exit("southeast", CRUMPT + "crumpt2", "door");
   add_exit("north", CRUMPT + "parcel_post", "corridor");
   add_property("place", "Pumpkin");
}
void reset() {
   if ( !_dictionary ) {
      _dictionary = clone_object( "/net/obj/dict" );
      _dictionary->add_property( "there", "attached to the counter" );
      _dictionary->reset_get();
      _dictionary->move( this_object() );
   }
}
void init() {
   ::init();
   add_command("mail", "<string>", (: do_mail($4[0]) :));
   add_command("mail", "", (: do_mail(0) :));
}
int do_mail( string words ) {
   return (int)MAIL_TRACK->mail( words );
}
int send_message( string from, int parcel ) {
#if 0
   object thing;
   thing = clone_object( CHARS +"post_et" );
   thing->set_home( file_name( this_object() ) );
   thing->move( this_object(), "$N pop$s out of the counter and grab$s the mail." );
   if ( find_player( recipient ) ) {
      thing->goto_player( recipient, from );
   } else {
      thing->goto_dest( COMM_ROOM, from );
   }
   return 1;
#endif
}

==================================================
FILE: dist/pumpkin/inherit/cityroom.c
==================================================

#include <armoury.h>
#include <hospital.h>
#include <move_failures.h>
#include <weather.h>
#include "path.h"
#define CREVICE ({ "a crevice", "a pothole", "a gutter" })[ random( 3 ) ]
#define LOG_FILE LOG +"city_log"
inherit "/std/room/outside";
int *crowd;
string type, *froms;
object *monsters;
int last_found;
int query_cityroom() { return 1; }
int *query_crowd() { return crowd; }
object *query_monsters() { return monsters; }
void announce_entry( object thing ) {
  string word;
  if ( !froms ) {
    froms = ({ });
    foreach ( word in query_direc() ) {
      if ( member_array( word, ({ "north", "south", "east", "west",
                                    "northeast", "southwest", "southeast",
                                    "northwest" }) ) == -1 )
        continue;
      if ( call_door( word, "query_closed" ) )
        continue;
      froms += ({ "the "+ word });
    }
  }
  if ( !sizeof( froms ) )
    tell_room( this_object(), "$a_short:"+ file_name( thing ) +
               "$ $V$0=arrives,arrive$V$ from elsewhere.\n" );
  else
    tell_room( this_object(), "$a_short:"+ file_name( thing ) +
               "$ $V$0=arrives,arrive$V$ from "+
               froms[ random( sizeof( froms ) ) ] +".\n" );
}
void make_citymonster( int number ) {
  if(!(int)HOSPITAL->ok_to_clone()) {
    HOSPITAL->add_empty( this_object() );
    return;
  }
  if ( !monsters[ number ] ) {
    monsters[ number ] = (object)( HOSPITAL )->get_monster( type );
    monsters[ number ]->add_property( "start location", this_object() );
    this_object()->do_zoning( monsters[ number ] );
    monsters[ number ]->move( this_object() );
    announce_entry( monsters[ number ] );
  }
  number++;
  if ( number >= sizeof( monsters ) )
    return;
  if((int)HOSPITAL->ok_to_clone())
    call_out( "make_citymonster", 5 + random( 5 ), number );
}
void set_monster( mixed number, string word ) {
  if ( intp( number ) ) {
    crowd = ({ number });
  } else {
    crowd = number;
  }
  number = crowd[ 0 ];
  crowd += ({ number });
  if ( number > 3 ) {
    number = 3;
  }
  monsters = allocate( random( 1 + number ) );
  type = word;
}
void create() {
  crowd = ({ 0, 0 });
  type = "unknown";
  monsters = ({ });
  do_setup++;
  ::create();
  do_setup--;
  add_property( "room size", 20 );
  add_property( "room zone", ({ "Pumpkin" }) );
  add_extra_look( this_object() );
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void reset() {
  if ( sizeof( monsters ) ) {
    call_out( "make_citymonster", 5 + random( 5 ), 0 );
  }
}
void dest_me() {
  ::dest_me();
}
int clean_up( int parent ) {
  if ( base_name( this_object() )[0..<3] == __FILE__) {
    return 0;
  }
  return ::clean_up( 0 );
}
mixed *stats() {
  return ::stats() + ({
    ({ "crowd", array_to_string( crowd[ 0 .. <2 ] ) }),
      });
}
int do_search( string words ) {
  object found;
  if ( query_property( "no scavenging" ) ) {
    return -1;
  }
  if ( this_player()->query_property( "dead" ) ) {
    return -1;
  }
  if ( words ) {
    if ( ( strsrch( words, "ground" ) == -1 ) &&
         ( strsrch( words, "crevice" ) == -1 ) &&
         ( strsrch( words, "pothole" ) == -1 ) &&
         ( strsrch( words, "gutter" ) == -1 ) &&
         ( strsrch( words, "cobble" ) == -1 ) ) {
      return -1;
    }
  }
  switch ( random( 21 ) ) {
  case 0 .. 6 :
    found = clone_object( "/obj/money" );
    if ( random( 80 ) ) {
      found->adjust_money( 1, "Pumpkin cent" );
    } else {
      if ( random( 80 ) ) {
        found->adjust_money( 1, "Pumpkin dollar" );
      } else {
        found->adjust_money( 10, "Pumpkin dollar" );
      }
    }
    break;
  case 7 .. 16 :
    if((time() - last_found) > random(360)) {
      found = (object)ARMOURY->choose_small_item();
      if(objectp(found)) {
        found->set_percentage(5 + random(30));
      } else {
        found = 0;
      }
      last_found = time();
    }
    break;
  case 17 .. 18 :
    if(sizeof(match_objects_for_existence("cockroach", this_object())) > 3) {
      return -1;
    }
    found = (object)HOSPITAL->get_monster( "cockroach" );
    found->move( this_object(), "$N scuttle$s out of "+
                 CREVICE +"." );
    return -1;
  case 19 :
    if(sizeof(match_objects_for_existence("rodent", this_object())) > 3) {
      return -1;
    }
    found = (object)HOSPITAL->get_monster( "rodent" );
    found->move( this_object(), "$N slink$s out of "+
                 CREVICE +"." );
    return -1;
  default :
    write( "You have a good look at the ground and spotting "
           "something, pick it up.  It's only a lump of rotting "
           "rubbish, though, which you throw away quickly.\n" );
    say( (string)this_player()->a_short() +" looks closely at "
         "the ground.  Seeing something, "+
         (string)this_player()->query_pronoun() +" picks it up, "
         "but finds that it's only a lump of rotting rubbish, so "+
         (string)this_player()->query_pronoun() +" throws it away.\n" );
    this_player()->add_effect( "/std/effects/other/rubbish_smell",
                               roll_MdN( 5, 60 ) );
    return 1;
  }
  if ( !found ) {
    return -1;
  }
  write( "You have a good look at the ground and scavenge "+
         (string)found->a_short() +" from "+ CREVICE +".\n" );
  say( (string)this_player()->a_short() +" looks closely at the ground.\n" );
  if ( (int)found->move( this_player() ) == MOVE_OK ) {
    write( "You pick it up.\n" );
    say( (string)this_player()->query_pronoun() +" picks something up.\n" );
  } else {
    write("Unfortunately you cannot pick it up and it disappears down "+
          CREVICE+".\n");
  }
  return 1;
}
void add_monster( object old_thing, object new_thing ) {
  int i;
  i = member_array( old_thing, monsters );
  if ( i != -1 ) {
    monsters[ i ] = new_thing;
    return;
  }
  i = member_array( 0, monsters );
  if ( i != -1 ) {
    monsters[ i ] = new_thing;
    return;
  }
  monsters += ({ new_thing });
}
void event_dest_me() {
  if ( find_call_out( "check_stuff" ) == -1 ) {
    call_out( "check_stuff", 30 );
  }
}
void check_stuff() {
  object thing, *things;
  things = all_inventory( this_object() );
  foreach( thing in things ) {
    if ( userp( thing ) ) {
      call_out( "check_stuff", 30 );
      return;
    }
    if ( living( thing ) || thing->query_corpse() ) {
      things -= ({ thing });
      continue;
    }
    if ( thing->do_not_sell() || !thing->query_value() ) {
      thing->move( "/room/rubbish" );
      things -= ({ thing });
      continue;
    }
  }
  if ( sizeof( things ) ) {
    things->move( "/d/am/filigree/general_store" );
  }
}
int query_crowd_now() {
  return crowd[ ( (int)WEATHER->minute_number() *
                  sizeof( crowd ) - 720 ) / 1440 ];
}
string extra_look( object thing ) {
  switch ( query_crowd_now() ) {
  case 0 :
    return "";
  case 1 :
    return "With few people about, this seems to be a quiet "
      "part of the city, perfect for getting mugged.\n";
  case 2 :
    return "A number of people pass by as they go about their "
      "lives (or in some cases, existences).\n";
  case 3 :
    return "Quite a few people, some in small groups, walk, "
      "trot and lurch along the street.\n";
  case 4 :
    return "This seems to be a busy part of the city, with "
      "many people hurrying to various destinations.\n";
  case 5 :
    return "All around you, crowds teem as Pumpkin moves "
      "turbulently through its hectic day.\n";
  case 6 :
    return "Crowds of people jostle you constantly, so keep "
      "an eye on your pockets...\n";
  default :
    return "The densely packed crowds make it difficult to "
      "move, and unpleasant to breathe.\n";
  }
}

==================================================
FILE: dist/pumpkin/inherit/hospital.c
==================================================

#include <armoury.h>
#include <hospital.h>
#include "path.h"
#include HOSPITAL_INC
#define CREATE_NPCS 1
#define REGEN_TIME 1 * 60 * 60
#define DEFAULT_LOG_DIRECTORY "/d/cwc/log"
#define DEFAULT_POPULATION 3
#define MINIMUM_DEATH_REGEN 3
inherit "/std/room";
class regenerated_npc {
    string type;
    string load_position;
}
protected void load_file();
protected void save_file();
protected void set_save_file(string new_save);
protected void restore_default_npcs();
protected void set_max_living(int new_living);
protected void set_hospital_type(string new_type);
protected object *make_monster(string type);
public object *get_monster(string type);
public void hospital_log_file(string file, string format, mixed *args ...);
public int get_item(object destination, string *items);
public string query_save_file();
public int query_max_living();
public int *query_npcs();
public mapping query_hospital_npcs();
public void add_npc_type(string type, string *data);
public void regen_after_death( object dead_npc );
private nosave string _save_file, _hospital_type;
private nosave int _max_living;
private nosave mixed *_regenerated_npcs;
private nosave int _hospital_call_id;
private nosave mapping _log_file_info;
private nosave string _hospital_log_directory;
public mapping _unique_npcs;
public mapping _hospital_npcs;
public int _last_npc_check, _zone_npcs;
private nosave mapping _npc_groups;
private nosave mapping _npc_info;
void create() {
    seteuid(master()->creator_file(file_name(this_object())));
    do_setup++;
    ::create();
    do_setup--;
    if (_save_file) {
        load_file();
        if (!_hospital_npcs) {
            restore_default_npcs();
        }
        if (!_unique_npcs) {
            _unique_npcs = ([ ]);
        }
        save_file();
    }
    if (!_npc_groups)
        _npc_groups = ([ ]);
    if (!_npc_groups)
        _npc_info = ([ ]);
    _regenerated_npcs = ({ });
    _log_file_info = ([ ]);
    if (!do_setup) {
        set_short("Counterweight Continent Hospital");
        set_long("All around you NPC's wait in neat little lines, "
            "ready to be sent on a massive journey that will ultimately "
            "lead to their deaths.  Some of them stand by a small window "
            "in the far wall, looking out at freedom.\n");
        add_property("determinate", "the ");
        set_light(60);
    }
}
public int get_item(object destination, string *items) {
    int i;
    object item;
    if (!objectp(destination)) {
        return 0;
    }
    while (!item) {
        i = random(sizeof(items));
        item = ARMOURY->request_item(items[i], 80 + random(21));
        if (!objectp(item)) {
            items = items[0..i-1] + items[i+1..];
            continue;
        }
        if (!sizeof(items)) {
            hospital_log_file("BROKEN_ITEMS", "Unable to select any items "
                "for %s in the CWC hospital.\n", previous_object()->short());
            break;
        }
    }
    if (objectp(item)) {
        item->move(destination);
        return 1;
    }
    return 0;
}
protected void load_file() {
    if (file_size(_save_file + ".o") > -1) {
        unguarded((: restore_object, _save_file :));
    }
}
protected void save_file() {
    unguarded((: save_object, _save_file :));
}
protected void set_save_file(string new_save) {
    _save_file = new_save;
}
public string query_save_file() {
    return _save_file;
}
public int make_unique(mixed who) {
    if (!_unique_npcs)
        return 0;
    if (objectp(who))
        who = who->query_name();
    if ( _unique_npcs[who] > time() )
        return 0;
    _unique_npcs[who] = time() + REGEN_TIME;
    save_file();
}
public int query_regen_time(mixed who) {
    if (objectp(who))
        who = who->query_name();
    if (!_unique_npcs)
        return 0;
    return _unique_npcs[who];
}
protected void set_max_living(int new_living) {
    _max_living = new_living;
}
public int query_max_living() {
    return _max_living;
}
protected void restore_default_npcs() {
    _hospital_npcs = ([ ]);
}
public int ok_to_clone(string where) {
    if (time() > _last_npc_check + 300) {
        _last_npc_check = time();
        _zone_npcs = sizeof(filter(named_livings(), (: environment($1) &&
            base_name(environment($1))[0..(sizeof(CWC) + sizeof($(where)) - 1)] ==
                (CWC + $(where)) :)));
    }
    return _zone_npcs < _max_living;
}
public int *query_npcs() {
    return ({ _zone_npcs, _last_npc_check });
}
public void add_npc_type(string type, string *data) {
    if (undefinedp(_hospital_npcs[type])) {
        _hospital_npcs[type] = copy(data);
    }
    else {
        if (arrayp(_hospital_npcs[type])) {
            _hospital_npcs[type] += data;
        }
    }
    save_file();
}
public mapping query_hospital_npcs() {
    return copy(_hospital_npcs);
}
public object *get_monster(string type) {
    object *monsters, monster;
    if (_hospital_npcs[type]) {
        tell_creator("taffyd", "Attempting to create a %s NPC.\n", type);
        monsters = make_monster(_hospital_npcs[type][random(sizeof(_hospital_npcs[type]))]);
        tell_creator("taffyd", "Monsters are now %O.\n", monsters);
    }
    else {
        monsters = make_monster(type);
    }
    foreach (monster in monsters) {
        monster->add_property("monster_type", type);
        monster->add_effect("/std/effects/npc/i_died",
            (: regen_after_death :) );
    }
    return monsters;
}
protected object *make_monster(string type) {
    object monster;
    monster = clone_object("/obj/monster");
    monster->set_name("failure");
    monster->set_short("hospital accident");
    monster->set_race("human");
    monster->set_guild("warrior");
    monster->set_level(1);
    return ({ monster });
}
public void regen_after_death( object dead_npc ) {
    object *monsters, destination;
    class regenerated_npc new_npc;
    int i, max;
    if ( !dead_npc )
        return;
    _regenerated_npcs += ({ new( class regenerated_npc,
        type : dead_npc->query_property("monster_type"),
        load_position : previous_object()->query_property("start location") ) });
    if ( !ok_to_clone(_hospital_type) || sizeof(_regenerated_npcs) < MINIMUM_DEATH_REGEN )
        return;
    new_npc = _regenerated_npcs[0];
    if ( !classp( new_npc ) )
        return;
    _regenerated_npcs = _regenerated_npcs[1..];
    if (!new_npc->load_position || !new_npc->type );
        return;
    max = random(5);
    for ( i = 0; i < max; i++ ){
        destination = find_object( new_npc->load_position );
        if ( !objectp( destination ) )
            return;
        monsters = get_monster(new_npc->type);
        destination->replace_monster(previous_object(), monsters);
        call_out((: $1->announce_entry($2) :), 8 + random(6), destination,
            monsters);
    }
}
protected void set_hospital_type(string new_type) {
    _hospital_type = new_type;
}
public void hospital_log_file(string file, string format, mixed *args ...) {
    string filename;
    filename = _hospital_log_directory;
    if (file[0] == '/') {
        file = file[ strsrch( file, "/", -1 ) + 1 .. ];
    }
    log_file( _hospital_log_directory + "/" + file, format, args ...);
}
protected void set_log_directory(string new_dir) {
    if (file_size(new_dir) != -2) {
        tell_creator( previous_object( 1 ), "%s: Invalid "
            "log directory -- defaulting to %s.\n",
            file_name( this_object() ), DEFAULT_LOG_DIRECTORY );
        new_dir = DEFAULT_LOG_DIRECTORY;
    }
    _hospital_log_directory = new_dir;
}
protected void set_npc_groups(mapping x) {
    _npc_groups = x;
}
protected void set_npc_info(mapping x) {
    _npc_info = x;
}
public object data_get_npc(string npc_name) {
    class npc_info info;
    object npc;
    function func;
    if ( undefinedp(_npc_info[npc_name]) )
        return 0;
    info = _npc_info[npc_name];
    if (stringp(info->base))
        npc = clone_object(info->base);
    else
        return 0;
    if (arrayp(info->functions)) {
        foreach (func in info->functions) {
            evaluate(func, npc, previous_object());
        }
    }
    return npc;
}
object *data_get_group(string group_name) {
    class npc_group group;
    function func;
    int population, quantity, i;
    object *npcs, npc;
    if ( undefinedp(_npc_groups[group_name]) )
        return 0;
    group = _npc_groups[group_name];
    if (functionp(group->population))
        population = evaluate(group->population);
    else {
        population = DEFAULT_POPULATION;
    }
    if (!group->storage) {
        group->storage = ({ });
    }
    else {
        group->storage = filter(group->storage, (: objectp($1) :));
        if (sizeof(group->storage) >= population)
            return 0;
    }
    if (functionp(group->quantity)) {
        quantity = evaluate(group->quantity);
    }
    else {
        quantity = 1;
    }
    if (stringp(group->npc)) {
        npcs = allocate(quantity);
        for (i = 0; i < quantity; i++) {
            npcs[i] = data_get_npc(group->npc);
        }
        npcs = filter(npcs, (: objectp($1) :));
        group->storage += npcs;
    }
    foreach (npc in npcs) {
        if (arrayp(group->functions)) {
            foreach (func in group->functions) {
                evaluate(func, npc, previous_object());
            }
        }
    }
    return npcs;
}
mixed accumulate_npc_array( mixed a ) {
    int cum, i;
    mixed choices;
    choices = copy(a);
    cum = 0;
    for (i = 0; i < sizeof(choices); i++) {
        cum += choices[i][0];
        choices[i][0] = cum;
    }
    return choices;
}
varargs mixed get_random_npcs(mixed *choices) {
    int i;
    int chance;
    if (!choices)
        choices = previous_object()->query_npcs();
    if (!arrayp(choices) || !sizeof(choices))
        return 0;
    chance = random(choices[<1][0]);
    for (i = 0; i < sizeof( choices ); i++) {
        if ( choices[ i ][ 0 ] > chance ) {
            return data_get_group( choices[ i ][ 1 ]);
        }
    }
    return 0;
}

==================================================
FILE: dist/pumpkin/inherit/hospital.h
==================================================

class npc_info {
    string base;
    function *functions;
}
class npc_group {
    mixed npc;
    function quantity;
    function population;
    function *functions;
    object *storage;
}

==================================================
FILE: dist/pumpkin/inherit/path.h
==================================================

#include "../path.h"

==================================================
FILE: dist/pumpkin/gumboot/armour_shop.c
==================================================

#include "path.h"
inherit "/std/shops/item_shop";
void setup() {
   set_short("Smashers Armour Store");
   set_long(
"The room is filled with the smell of leather and oil, you can see racks "
"some suits of armour in various stages of being made around the store.\n");
   set_light(70);
   add_exit("west", PATH + "gumboot3", "door");
   add_object("brigandine armour", 1 + random(4));
   add_object("hardened leather breastplate", 1 + random(4));
   add_object("jazerant armour", 1 + random(2));
   add_object("leather boxer shorts", 1 + random(2));
   add_object("leather hat", 1 + random(2));
   add_object("leather jerkin", 1 + random(2));
   add_object("padded aketon", 1 + random(2));
   add_object("studded leather jerkin", 1 + random(2));
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/gumboot/clothes_shop.c
==================================================

#include "path.h"
inherit "/std/shops/item_shop";
void setup() {
   set_short("Squiggles Clothing Store");
   set_long(
"You are standing in a veritable forest of clothes, they hang off racks "
"and almost completely hide the floor.  Unfortunately they seem to be "
"reall limited in the type clothes they sell, obviously they belive in "
"volume rather than breadth of stock.\n");
   set_light(70);
   add_exit("east", PATH + "gumboot2", "door");
   add_object("green bathrobe", 1 + random(10));
   add_object("green cloak", 1 + random(10));
   add_object("green pants", 1 + random(10));
   add_object("green peaked hat", 1 + random(10));
   add_object("green silk sash", 1 + random(10));
   add_object("green wool shirt", 1 + random(10));
   add_object("white apron", 1 + random(10));
   add_object("white burnous", 1 + random(10));
   add_object("white cotton bodice", 1 + random(10));
   add_object("white cotton robe", 1 + random(10));
   add_object("white cotton shirt", 1 + random(10));
   add_object("white cotton toga", 1 + random(10));
   add_object("white cotton tunic", 1 + random(10));
   add_object("white linen tunic", 1 + random(10));
   add_object("white linen skirt", 1 + random(10));
   add_object("white short-sleeved shirt", 1 + random(10));
   add_object("white silk lace bodice", 1 + random(10));
   add_object("white silk pinafore", 1 + random(10));
   add_object("white silk sash", 1 + random(10));
   add_object("white socks", 1 + random(10));
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/gumboot/gumboot1.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Gumboot Road");
  set_long("This is north end of Gumboot Road at the junction with Squash Square.\n");
  set_light( 80 );
  add_exit("north", SQUASH + "squash8", "road");
  add_exit("south", GUMBOOT + "gumboot2", "road");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/gumboot/gumboot2.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Gumboot Road");
  set_long("This is the middle of Gumboot Road\n");
  set_light( 80 );
  add_exit("north", GUMBOOT + "gumboot1", "road");
  add_exit("south", GUMBOOT + "gumboot3", "road");
  add_exit("west", PATH + "clothes_shop", "door");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/gumboot/gumboot3.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Gumboot Road");
  set_long("This is the middle of Gumboot Road\n");
  set_light( 80 );
  add_exit("north", GUMBOOT + "gumboot2", "road");
  add_exit("south", GUMBOOT + "gumboot4", "road");
  add_exit("east", PATH + "armour_shop", "door");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/gumboot/gumboot4.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Gumboot Road");
  set_long("This is the middle of Gumboot Road\n");
  set_light( 80 );
  add_exit("north", GUMBOOT + "gumboot3", "road");
  add_exit("south", GUMBOOT + "gumboot5", "road");
  add_exit("west", PATH + "weapon_shop", "door");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/gumboot/gumboot5.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Gumboot Road");
  set_long("This is end of Gumboot Road at the edge of the city of Pumpkin.\n");
  set_light( 80 );
  add_exit("east", TERRAIN_HANDLER + ":0:1:0", "road");
  add_exit("north", GUMBOOT + "gumboot4", "road");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/gumboot/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/gumboot/weapon_shop.c
==================================================

#include "path.h"
inherit "/std/shops/item_shop";
void setup() {
   set_short("Pointy's Weapon Shop");
   set_long(
"Racks of weapons line the room, don't touch, they look sharp.\n");
   set_light(70);
   add_exit("east", PATH + "gumboot4", "door");
   add_object("morning star", 1 + random(20));
   add_object("black handled ceremonial bronze knife", 1 + random(20));
   add_object("carving knife", 1 + random(20));
   add_object("chisel", 1 + random(20));
   add_object("copper fighting knife", 1 + random(20));
   add_object("dagger", 1 + random(20));
   add_object("howondalandish throwing knife", 1 + random(20));
   add_object("klatchian steel dirk", 1 + random(20));
   add_object("knife", 1 + random(20));
   add_object("letter opener", 1 + random(20));
   add_object("meat cleaver", 1 + random(20));
   add_object("sharp butter knife", 1 + random(20));
   add_object("silver sickle", 1 + random(20));
   add_object("small copper knife", 1 + random(20));
   add_object("small knife", 1 + random(20));
   add_object("stiletto", 1 + random(20));
   add_object("tanto", 1 + random(20));
   add_object("white handled ceremonial bronze knife", 1 + random(20));
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/plain/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/plain/plain1.c
==================================================

#include "path.h";
inherit "/std/outsides/plain";
void setup() {
  set_short("Plains");
  set_long("This is Plains at the junction with Rabbit Lane.
\n");
  set_light( 80 );
  add_exit("east", PLAIN + "plain2", "road");
  add_exit("west", RABBIT + "rabbit4", "road");
}

==================================================
FILE: dist/pumpkin/plain/plain10.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Forest");
  set_long("This is the end of Forest\n");
  set_light( 80 );
  add_exit("west", PLAIN + "plain9", "road");
  add_exit("north", PLAIN + "plain5", "road");
}

==================================================
FILE: dist/pumpkin/plain/plain2.c
==================================================

#include "path.h";
inherit "/std/outsides/plain";
void setup() {
  set_short("Plains");
  set_long("This is the end of Plains\n");
  set_light( 80 );
  add_exit("east", PLAIN + "plain3", "road");
  add_exit("west", PLAIN + "plain1", "road");
}

==================================================
FILE: dist/pumpkin/plain/plain3.c
==================================================

#include "path.h";
inherit "/std/outsides/plain";
void setup() {
  set_short("Plains");
  set_long("This is the end of Plains\n");
  set_light( 80 );
  add_exit("east", PLAIN + "plain4", "road");
  add_exit("west", PLAIN + "plain2", "road");
}

==================================================
FILE: dist/pumpkin/plain/plain4.c
==================================================

#include "path.h";
inherit "/std/outsides/plain";
void setup() {
  set_short("Plains");
  set_long("This is the end of Plains\n");
  set_light( 80 );
  add_exit("east", PLAIN + "plain5", "road");
  add_exit("west", PLAIN + "plain3", "road");
}

==================================================
FILE: dist/pumpkin/plain/plain5.c
==================================================

#include "path.h";
inherit "/std/outsides/plain";
void setup() {
  set_short("Plains");
  set_long("This is Plains at the junction with Woods.
\n");
  set_light( 80 );
  add_exit("west", PLAIN + "plain4", "road");
  add_exit("south", WOODS + "woods1", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert1.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is Desert at the junction with Gumboot Road.
\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert2", "road");
  add_exit("west", GUMBOOT + "gumboot5", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert10.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is Desert at the junction with Woods.
\n");
  set_light( 80 );
  add_exit("west", DESERT + "desert9", "road");
  add_exit("north", WOODS + "woods5", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert2.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert3", "road");
  add_exit("west", DESERT + "desert1", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert3.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert4", "road");
  add_exit("west", DESERT + "desert2", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert4.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert5", "road");
  add_exit("west", DESERT + "desert3", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert5.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert6", "road");
  add_exit("west", DESERT + "desert4", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert6.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert7", "road");
  add_exit("west", DESERT + "desert5", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert7.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert8", "road");
  add_exit("west", DESERT + "desert6", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert8.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert9", "road");
  add_exit("west", DESERT + "desert7", "road");
}

==================================================
FILE: dist/pumpkin/desert/desert9.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("This is the end of Desert\n");
  set_light( 80 );
  add_exit("east", DESERT + "desert10", "road");
  add_exit("west", DESERT + "desert8", "road");
}

==================================================
FILE: dist/pumpkin/desert/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/rabbit/bookshop.c
==================================================

#include "path.h"
inherit "/std/shops/book_shop";
void setup() {
   set_short("Bugs Bookstore");
   set_long(
"The distinctly carroty atmosphere of the store makes you feel like "
"saying 'Whats up doc?'\n");
   add_exit("south", RABBIT + "rabbit2", "door");
   set_light(70);
   set_cut(10);
   set_when_sold_function( (: $1->set_open_page(0) :) );
   set_allowed_to_sell( (: $1->query_book() || $1->query_paper() :) );
   set_minimum_cost(400);
   set_save_dir(SAVE + "bookshop");
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/rabbit/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/rabbit/potion_shop.c
==================================================

#include "path.h"
inherit "/std/shops/potion_shop";
void setup() {
   set_short("Carrot's Potion Store");
   set_long(
"This is a bright orange room with a green ceiling.\n");
   set_light(70);
   add_exit("south", RABBIT + "rabbit4", "door");
   set_save_dir(SAVE + "potions");
   set_cut(10);
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/rabbit/print_shop.c
==================================================

#include "path.h"
inherit "/std/shops/print_shop";
void setup() {
   set_short("Flopsies Print Shop");
   set_long(
"This place appears to have been made into a shrine for a rabbit, you "
"can see a small altar and carrot covered cloth on the counter.\n");
   add_item("counter", ({ "long", "The counter runs across the "
            "front of the room and there is a small altar set up "
            "on the edge of it.",
            "position", "the counter" }) );
   add_item("altar", ({ "long", "A nice altar with a little sign "
            "under it.",
            "read", "In memory of 'Mopsy'.\n" }) );
   set_light(70);
   add_exit("north", RABBIT + "rabbit3", "door");
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/rabbit/print_shop_binding.c
==================================================

#include "path.h"
#include <armoury.h>
inherit "/std/shops/print_shop";
int is_room_open();
void setup() {
   set_light(70);
   set_room_size(5);
   set_short("print shop's binding room");
   add_property("determinate", "the ");
   set_long(
"Several tables are laid out in this room, people sit at the tables "
"placing the pages which come in from the printing press into the "
"final bound editions of the books.  This looks like the place where "
"the completed books are stored until taken away by their owners, judging "
"by the huge piles of books scattered around on the floor.\n");
   add_item("table",
({ "long", "Several tables house the equipment used to bind the books into "
"completed volumes are scattered around the room.  All the space not used by "
"the tables is covered in piles of completed, bound books.",
"position", "a binding table",
"position multiple", 1 }) );
   add_item(({ "edition", "volume", }),
"The uncompleted, or soon to be completed volumes of work are sitting "
"on the tables, when they get put on the ground they suddenly turn "
"into books.");
   add_item("people",
"They are binding the books, placing each page into (hopefully) the "
"correct place and creating a final, probably exact output.");
   add_item("book",
({ "long", "There are books all over the floor, in piles and stacks.  Some "
"of the stacks look a little precarious.",
"position", "a pile of books",
"position multiple", 1 }) );
   add_item("page",
"The pages are stacked up on the tables, somewhat neatly, beside the "
"workers as they place them into the bound copies.");
   add_exit("south", PATH + "print_shop_press", "corridor");
   set_office_room(PATH + "print_shop_office");
   set_open_func((: is_room_open :));
   set_print_shop_name("Goatbergers printing shop, Pumpkin");
   add_property("place", "Pumpkin");
}
int is_room_open() {
   return 1;
}

==================================================
FILE: dist/pumpkin/rabbit/print_shop_foyer.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
void setup() {
   set_light(70);
   set_room_size(5);
   set_short("print shop's foyer");
   add_property("determinate", "the ");
   set_long(
"A busy room full of people running around carrying trays full of moving "
"type and ink.  There is a coffee table in the middle of the chaos with "
"a chair sitting beside it.  To the west there is a door with a "
"brass plaque attached to it.\n");
   add_item("coffee table",
({ "long", "The coffee table is old and very coffee and tea stained, you are "
"not sure just how undisturbed you would be sitting at the table, the whole "
"place looks a little busy.",
"position", "the coffee table" }) );
   add_item("rickety chair",
({ "long", "The rickety chair sits beside the coffee table, it looks "
"pretty precarious about its role in life.  Sitting on it might be a "
"dangerous occupation.",
"position", "the rickety chair" }) );
   add_item("moving type",
"Lots of little letters placed in rows on boards, or heaped in buckets.  "
"They don't actually appear to move, but is hard to tell because no one "
"with them ever stops long enough for you to look.");
   add_item("ink",
"Large pots of ink, small pots of ink, ink!  All colours of ink, black, "
"red, green, although mostly black, are being carted around.  You are sure "
"there is a purpose to all the movement even if it is a little unclear.");
   add_item("people",
"They are all in a hurry, they look determined and stressed as if they "
"could never manage to get to whatever their destination is fast enough.  "
"Most of them do not appear to really know where their destination is, "
"they rush in and out of the room carrying the same items, look around "
"wildly and dash out again.");
   add_item("brass plaque",
({ "long", "It is a nice polished brass plaque on a surprisingly nice "
"looking door.\nIt appears to have something written on it.",
"read", "Office.\n" }) );
   add_exit("west", PATH + "print_shop_office", "door");
   add_exit("east", PATH + "print_shop_press", "corridor");
   add_exit("south", PATH + "rabbit3", "door");
   room_chat( ({ 120, 240, ({
       "Someone rushes into the room, looks around wildly and rushes back "
       "out again.",
         "You hear a CLANK, WHAM, HISS from the east",
    }) }) );
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/rabbit/print_shop_office.c
==================================================

#include "path.h"
#include <armoury.h>
inherit "/std/shops/print_shop";
nosave object goatberger;
int is_office_open(object *obs);
void setup() {
   set_light(70);
   set_room_size(5);
   set_short("print shop's office");
   add_property("determinate", "the ");
   set_long(
"A big impressive table dominates the room, contrasting sharply to the "
"bare undecorated walls and single bookcase on the back wall.  "
"The soft squooshy carpet covers the floor "
"in a soft cuddly way, licking up against the walls of the room.  "
"The room gives the impression of opulence by its starkness.\n");
   add_item("impressive table",
({ "long", "The table is almost bare except for a blotting pad and a nice "
"set of gold plated quills.  It is a deep shiny maroon colour "
"and the finish glistens softly in the light.  Nestled in behind the "
"table is a wonderful looking chair.",
"position", "the impressive table" }));
   add_item("chair",
({ "long", "The chair is one of those amazing office executive chairs.  "
"It has bits that wobble, bits that zip around and generally looks "
"pretty exciting.",
"position", "the chair" }) );
   add_item("gold plated quill",
"The gold plated quills rest on a quill holder on the table, slightly "
"askew from the blotting paper.  They look hardly used.");
   add_item("bare undecorated wall",
"The walls are bare and undecorated, but nicely finished with a "
"coat of some sort of timber varnish.\n");
   add_item( ({ "blotting paper", "blotting pad" }),
"The blotting paper is bright white, it looks like it has never seen "
"anything remotely resembling ink.  Scribbled just on the corner of "
"the wonderful white paper is a small note saying, 'Please note we can "
"\"print\" books and allow you to \"claim\" copyright here.'");
   add_item("quill holder",
"Resting on the hand engraved silver quill holder are two gold plated "
"quills.");
   add_item("soft squooshy carpet",
"The light brown carpet decorates the room perfectly, running from "
"wall to wall, gently fading into the floor and not being too obtrusive.");
   add_item("bookcase",
"It is sparsely populated with a couple of new looking leather bound "
"books.  They are titled 'Two nights in a closet', 'The Joye of Snacks' "
"and 'A few bedtime poems'.\n");
   add_item(({ "two nights in a closet", "book" }),
({ "long", "The red leather cover looks posh and gorgeous in your "
"hands.  You can see the title 'Two nights in a closet' etched "
"into the cover.\n"
"It appears to have something written on it.",
"read",
"This is a long winding book about a monster having to temporarily "
"relocate from a nice cellar in which it used to live.  The cellar "
"is undergoing refurbishment and is unavailable for monster "
"habitation, so it moved to a closet in a childs bedroom.  The "
"mother of the child refuses to believe that there is a monster "
"in the closet despite the loud protestations of the child.  The "
"monster peers out at the child every night, when it leaves it "
"eats the childs favorite toy and the mother eventually agrees "
"to look in the closet.  But it is empty.\n" }));
   add_item(({ "the joye of snacks", "book" }),
({ "long", "Wonderful bright red alluring cover with an interesting "
"picture of two people, naked, embracing in a shower with a "
"coffee table lurking in the foreground.  The caption 'Joye of "
"snacks' can be seen on the binder.\n"
"It appears to have something written on it.",
"read", "The first page has 'Demo copy only' written on it in "
"big black letters.  Sounds like a really interesting book though.\n" }) );
   add_item(({ "a few bedtime poems", "book" }),
({ "long", "The mate black cover of this book hardly even gleams at "
"all, the straight time Roman lettering saying 'A few bedtime poems "
"by a small colourful fish'.\n"
"It appears to have something written on it.",
"read",
"Strawberries\n"
"------------\n"
"\n"
"Starting from a above,\n"
"Working slowly down under.\n"
"Sliding up the sides\n"
"Eating a meal, fresh cream and syrup.\n"
"\n"
"Round and round, and round again\n"
"Grinning mischeviously\n"
"One tongue at play\n"
"Firm and hard, fresh strawberries today.\n"
"\n"
"\n"
"Flirting\n"
"--------\n"
"\n"
"A sidelong glance,\n"
"A funny remark!\n"
"Glittering eyes\n"
"Meeting in the dark.\n"
"\n"
"Fear of whats to come\n"
"Glad of what is here.\n"
"Hoping, wishing, believing\n"
"We will be as one.\n"
"\n"
"\n"
"Bewitched by the highlands\n"
"--------------------------\n"
 "\n"
"Scotland reminds me\n"
"Of heather and song\n"
"Of bagpipes and dancing\n"
"Never a witch\n"
 "\n"
"Then she bewitched me\n"
"Her eyes were brown\n"
"Her hair was like satin\n"
"Skin of pure honey\n"
 "\n"
"We talked for hours\n"
"Talking of the times\n"
"Strawberries and cream\n"
"Staring at her eyes\n"
 "\n"
"We laughed and sighed\n"
"Talked far and wide\n"
"Feeling a glow inside\n"
"Hands touching in my mind\n"
 "\n"
"Many more times we met\n"
"Laughed and had fun\n"
"Flirting with abandon\n"
"More happy than ever before\n"
 "\n"
"Now Scotland and witches\n"
"Are inextricably linked\n"
"With joy and happiness\n"
"In my dreams at night\n"
 }) );
   set_no_collection(1);
   set_open_func((: is_office_open($1) :));
   set_default_language("common");
   add_translation_cost("djelian", 130);
   set_save_dir("/d/am/save/printing/");
   add_exit("east", PATH + "print_shop_foyer", "door");
   add_property("place", "Pumpkin");
}
void reset() {
   if (!goatberger) {
      goatberger = clone_object("/obj/monster");
      goatberger->set_name("goatberger");
      goatberger->set_short("Mr. Goatberger");
      goatberger->set_long(
"He is smartly dressed in an expensive looking imported suit, a slight smile "
"just playing on his lips.  A gold fob watch peeks out of the lapels "
"of his suit.\n");
      goatberger->set_race("human");
      goatberger->set_level(10);
      goatberger->set_gender("male");
      goatberger->add_property("determinate", "");
      ARMOURY->request_item("white linen tunic", 90)->move(goatberger);
      ARMOURY->request_item("green pants", 90)->move(goatberger);
      goatberger->set_default_position( (: goatberger->do_command("sit on chair") :) );
      goatberger->do_command("equip");
      goatberger->move(this_object(), "$N arrives from the west.\n");
      goatberger->return_to_default_position(0);
   }
}
int is_office_open(object *obs) {
   if (!goatberger) {
      add_failed_mess("There is no one here to serve you.\n", obs);
      return 0;
   }
   return 1;
}

==================================================
FILE: dist/pumpkin/rabbit/print_shop_press.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
void setup() {
   set_light(70);
   set_room_size(5);
   set_short("print shop's machinery room");
   add_property("determinate", "the ");
   set_long(
"Big huge black machines, belching steam and exciting noises, completely cover "
"the floor of the room.  People scurry back and forth, carrying single "
"pages, bound books and trays of moving type.  The floor is covered in "
"spilled ink, both new and old, and little bits of metal, forgotten "
"bits of moving type and the odd rat.\n");
   add_item(({ "big huge black machine", "press", "machines" }),
"The machines are big presses that squish the moving type down onto "
"bits of paper which are then shuffled off to the binding department.  Steam "
"and unnecessary noise appear to be vital components of the printing "
"process.");
   add_item(({ "metal bit", "metal" }),
"There are a number of small bits of metal scattered over the floor, they "
"appear to be broken bits of moving type and things shaved off the "
"industriously working machines.");
   add_item("floor",
"The floor is covered in spilled ink, both new and old, and little bits of "
"metal,  forgotten bits of moving type and the odd rat.");
   add_item("people",
"There are people scurrying around in a hurry, moving pages from the "
"press into the binding room and swapping the moving type.  In a corner "
"there are a group of people arranging the type onto the trays from an "
"original book.");
   add_item("bound book",
"You have no idea why people would be walking around with bound books here, "
"especially since they seem to be reading the books and then blushing bright "
"red.  The title of the books appears to be 'The Joye of Snacks'.");
   add_item("spilled ink",
"The ink is all over the floor in a thick layer, caking everything in a "
"fine dust.");
   add_item("rat",
"The rat looks kind of, well very, covered in ink.  It sniffs around the "
"place industriously, perhaps it is a spy rat?");
   add_item("single page",
"The pages are single pages from books, they are not particularly ordered "
"from what you can tell.  You wonder how the books make it out alive.");
   add_item(({ "tray", "tray of moving type" }),
"Trays of moveable type to be inserted into the machines, they then print "
"the pages which get placed into the final book.");
   add_exit("west", PATH + "print_shop_foyer", "corridor");
   add_exit("north", PATH + "print_shop_binding", "corridor");
   room_chat( ({ 120, 240, ({
      "Someone reading a book blushes bright red and drops a tray of "
      "moving type.",
      "WHUMP!",
      "HISS!",
      "A machine clanks alarmingly.",
      "Someone wanders off with a bunch of pages to be bound to the binding "
      "room."
    }) }) );
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/rabbit/rabbit1.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Rabbit Lane");
  set_long("This is Rabbit Lane at the junction with Squash Square.\n");
  set_light( 80 );
  add_exit("east", RABBIT + "rabbit2", "road");
  add_exit("west", SQUASH + "squash6", "road");
}

==================================================
FILE: dist/pumpkin/rabbit/rabbit2.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Rabbit Lane");
  set_long("This is the middle of Rabbit Lane where a bunch of "
           "books and things seem to be.\n");
  set_light( 80 );
  add_exit("east", RABBIT + "rabbit3", "road");
  add_exit("west", RABBIT + "rabbit1", "road");
  add_exit("north", RABBIT + "bookshop", "door");
}

==================================================
FILE: dist/pumpkin/rabbit/rabbit3.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Rabbit Lane");
  set_long("This is the middle of Rabbit Lane\n");
  set_light( 80 );
  add_exit("east", RABBIT + "rabbit4", "road");
  add_exit("west", RABBIT + "rabbit2", "road");
  add_exit("north", RABBIT + "print_shop_foyer", "door");
}

==================================================
FILE: dist/pumpkin/rabbit/rabbit4.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Rabbit Lane");
  set_long("This is end of Rabbit Lane at the exit of the city of Pumpkin.\n");
  set_light( 80 );
  add_exit("east", TERRAIN_HANDLER + ":0:18:0", "road");
  add_exit("west", RABBIT + "rabbit3", "road");
  add_exit("north", RABBIT + "potion_shop", "door");
}

==================================================
FILE: dist/pumpkin/woods/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/woods/woods1.c
==================================================

#include "path.h";
inherit "/std/outsides/woodland";
void setup() {
  set_short("Woods");
  set_long("This is Woods at the junction with Plains.
\n");
  set_light( 80 );
  add_exit("north", PLAIN + "plain5", "road");
  add_exit("south", WOODS + "woods2", "road");
}

==================================================
FILE: dist/pumpkin/woods/woods2.c
==================================================

#include "path.h";
inherit "/std/outsides/woodland";
void setup() {
  set_short("Woods");
  set_long("This is the end of Woods\n");
  set_light( 80 );
  add_exit("north", WOODS + "woods1", "road");
  add_exit("south", WOODS + "woods3", "road");
}

==================================================
FILE: dist/pumpkin/woods/woods3.c
==================================================

#include "path.h";
inherit "/std/outsides/woodland";
void setup() {
  set_short("Woods");
  set_long("This is the end of Woods\n");
  set_light( 80 );
  add_exit("north", WOODS + "woods2", "road");
  add_exit("south", WOODS + "woods4", "road");
}

==================================================
FILE: dist/pumpkin/woods/woods4.c
==================================================

#include "path.h";
inherit "/std/outsides/woodland";
void setup() {
  set_short("Woods");
  set_long("This is the end of Woods\n");
  set_light( 80 );
  add_exit("north", WOODS + "woods3", "road");
  add_exit("south", WOODS + "woods5", "road");
}

==================================================
FILE: dist/pumpkin/woods/woods5.c
==================================================

#include "path.h";
inherit "/std/outsides/woodland";
void setup() {
  set_short("Woods");
  set_long("This is Woods at the junction with Desert.
\n");
  set_light( 80 );
  add_exit("north", WOODS + "woods4", "road");
  add_exit("south", DESERT + "desert10", "road");
}

==================================================
FILE: dist/pumpkin/hospital/hospital.c
==================================================

#include "path.h"
inherit CITY "inherit/hospital";
void create() {
   set_hospital_type("Pumpkin");
   set_save_file("/d/dist/dist/pumpkin_hospital");
   set_max_living(100);
   set_log_directory("/d/dist/log");
   do_setup++;
   ::create();
   do_setup--;
   if (!do_setup) {
      set_short("Pumpkin Hospital");
      set_light(60);
   }
   set_npc_groups(DATA->compile_data( ({ HOSPITAL_DIR "bes_pelargic_group" }) ));
   set_npc_info(DATA->compile_data( ({ HOSPITAL_DIR "bes_pelargic_info" }) ));
}

==================================================
FILE: dist/pumpkin/squash/beer_bar.c
==================================================

#include "path.h"
#include <armoury.h>
#include <shops/pub_shop.h>
inherit "/std/shops/pub_shop";
object *drunkards;
object bartender, barmaid;
int do_sit(string str);
int ref_to_serve(object player, int type);
void setup() {
   set_short("beer room");
   set_room_size(5);
   add_property( "place", "Pumpkin");
   set_light(60);
   set_theft_handler( HOSPITAL );
   set_zone("Flaming Cabbage");
   set_open_function( (: ref_to_serve :) );
   set_long("This is a beer bar.  Hence, all the bottles, signs and glasses "
      "are related to beer.  Maybe it could be possible to get something "
      "else, but most likely, beer (and of course the sort of healthy, "
      "nutritious food that goes along with beer) is all they sell here.  "
      "The customers, sitting on chairs around the tables, are all drinking "
      "beer and chatting merrily.  At one of the more secluded tables, "
      "some seedy-looking characters are whispering less merrily.  Of course, "
      "they too are enjoying a tasty beer.  A menu is tacked to the "
      "wall behind the counter.\n");
   add_item("floor", "The floor is sticky, and it seems like it'd be hard "
      "to walk out of here.  That could explain why some of the clientele "
      "here seem to have been drinking for days.");
   add_item("sign","There are a number of signs in this bar.  Most of "
      "them are tacky, sticky old cardboard signs pointing out the "
      "special benefits of drinking beer X or ale Y.");
   add_item("bottle","There are a vast amount of bottles on the wall "
      "behind the counter.  They all seem to be the same sort, and quite "
      "a few of them seem to be empty.  At least they catch the seedy "
      "light in a very pretty way.");
   add_item("glass","Beer glasses (the empty kind which are not overly dirty "
      "on the inside) are flooding the bar behind the counter.  Considering "
      "how empty, used glasses seem to disappear altogether, it is probably "
      "necessary to have quite a few glasses around.");
   add_item(({"customer","clientele"}), "The people in here seem to be "
      "mainly concerned with the intake of beer.  They all look rather red "
      "around their noses and, for some reason, they all look rather "
      "happy.  All except those who wouldn't be caught dead doing something "
      "as silly as looking happy, of course.");
   add_item(({"seedy-looking character","character","corner"}), "In a "
      "corner of the bar, some people (who seem to melt in extraordinarily "
      "well into the dark shadows) are quietly drinking some beer, keeping "
      "a watchful eye on everything that happens");
   add_item(({"bar","counter"}), "The counter runs along one wall of the "
      "room.  All empty glasses put on it seem to disappear to some other "
      "dimension.  Only Dogbolter, the God of Empty Beer Pints, knows "
      "where that is.");
   add_item("wall", "The walls are sticky with dried in beer.  Somehow it "
      "has ended up on the walls, but there is nothing here to explain how.  "
      "On one of the walls there's a sign - it appears to be stuck there "
      "without the aid of a pin or anything...");
   add_item("ceiling", "The ceiling is sticky.  They must have had quite a "
      "party here recently.  Or maybe they had a party a long time ago and "
      "just haven't washed the ceiling since?");
   add_item( "wooden table", ({"long", "This is a rather nice wooden "
      "table.  At least it could be, somewhere underneath all that "
      "sticky beer.",
      "position","the wooden table"}));
   add_item( "small table", ({"long", "This table is made of wood, but a "
      "lot smaller than the other tables here.",
      "position","the small table"}));
   add_item( "sticky table", ({"long", "This large table is a lot stickier "
      "than anything else in here, and that means it's pretty darn sticky!",
      "position","the sticky table"}));
   add_item( "old chair",
         ({ "long", "The chairs around the wooden table are old and worn.",
            "position","the wooden table"
         }) );
   add_item( "small chair",
         ({ "long", "The chairs around the wooden table are old and worn.",
            "position","a chair at the wooden table"
         }) );
   add_item("sticky beer", "It's just about everywhere.");
   add_menu_item("Spicy sausage", PUB_APPETISER, 396, "spicy sausage");
   add_menu_alias("sausage", "Spicy sausage");
   add_menu_item("Salad", PUB_MAINCOURSE, 796, "salad",
                 PUB_STD_SIDEPLATE);
   add_menu_item("Fish'n'chips", PUB_MAINCOURSE, 1196, "fish'n'chips",
                 PUB_STD_DINNERPLATE);
   add_menu_item("Ribs", PUB_MAINCOURSE, 1304, "ribs",
                 PUB_STD_DINNERPLATE);
   add_menu_item("Hot chicken sandwich", PUB_MAINCOURSE, 796,
      "chicken sandwich");
   add_menu_alias("chicken sandwich", "Hot chicken sandwich");
   add_menu_item("Ham'n'cheese sandwich", PUB_MAINCOURSE, 796, "ham sandwich");
   add_menu_alias("ham sandwich", "Ham'n'cheese sandwich");
   add_menu_item("Unnameable liquid", PUB_ALCOHOL, 1704, "unnameable",
                 PUB_STD_PINT, 0, 1);
   add_menu_alias("unnameable", "Unnameable liquid");
   add_menu_item("CMOTD's Finest Brew", PUB_ALCOHOL, 1704, "finest brew",
                 PUB_STD_PINT, 0, 1);
   add_menu_alias("brew", "CMOTD's Finest Brew");
   add_menu_alias("cmotd", "CMOTD's Finest Brew");
   add_menu_item("Pumpkine Ale", PUB_ALCOHOL, 1838, "/obj/food/ale.food",
                 PUB_STD_PINT, 0, 1);
   add_menu_alias("ale", "Pumpkine Ale");
   add_menu_item("Troll Beer", PUB_ALCOHOL, 1838, "troll beer",
                 PUB_STD_PINT, 0, 3);
   add_menu_alias("beer", "Troll Beer");
   add_menu_item("Schlorg Beer", PUB_ALCOHOL, 1838, "schlorg beer",
                 "schlorg bottle", 0, 2);
   add_menu_alias("schlorg", "Schlorg Beer");
   add_exit("west", PATH + "squash9", "corridor");
}
object create_item( string word ) {
   object thing, thang;
   switch ( word ) {
   case "spicy sausage" :
      thing = clone_object( "/obj/food" );
      thing->set_weight_per_bite(1);
      thing->set_name("sausage");
      thing->set_short("spicy sausage");
      thing->set_long( "The sausage, of a very questionable origin, seems "
         "to be designed to increase the thirst of whomever eats it.\n" );
      thing->set_value( 396 );
      thing->set_weight(5);
      return thing;
   case "unnameable liquid" :
      thang = clone_object( "/obj/reagents/generic_liquid.ob" );
      thang->set_medium_alias("beer");
      thang->set_name("unnameable");
      thang->set_short( "unnameable liquid" );
      thang->set_long( "This sludge is definitely better off without a "
           "name.  If someone was to try to give it a name, it'd have to be "
           "something along the lines of \"Stinking Mud\", \"Utterly "
           "Disgusting and Undrinkable Slush\" or maybe just \"Yuck!\".\n" );
      thang->add_eat_effect( "/std/effects/ingested/drunk", 40 );
      thang->add_eat_effect("/std/effects/ingested/nausea", 100);
      thang->set_amount( 2000 );
      return thang;
   case "finest brew" :
      thang = clone_object( "/obj/reagents/generic_liquid.ob" );
      thang->set_name("brew");
      thang->set_medium_alias("beer");
      thang->set_short( "CMOTD's Finest Brew" );
      thang->add_alias(({"finest brew","CMOTD's finest","CMOTD's brew"}));
      thang->set_long( "CMOT Dibbler has produced an amazing beer from "
           "Pumpkin, weird spices and possibly some more things.  Being "
           "Dibbler, he has of course made sure that the pint is rather "
           "a small one.\n" );
      thang->add_eat_effect( "/std/effects/ingested/drunk", 50 );
      thang->set_amount( 980 );
      return thang;
   case "troll beer" :
      thang = clone_object( "/obj/reagents/generic_liquid.ob" );
      thang->add_alias("beer");
      thang->set_name("beer");
      thang->set_short("troll beer");
      thang->add_adjective("pint");
      thang->set_long("This is trollish beer.  You suspect a human "
            "shouldn't really be drinking this stuff.\n" );
      thang->add_alias( "trollbeer" );
      thang->add_adjective("troll");
      thang->add_eat_effect("/std/effects/ingested/drunk", 70);
      thang->set_amount( 2000 );
      return thang;
   case "schlorg" :
      thang = clone_object( "/obj/reagents/generic_liquid.ob" );
      thang->set_name("schlorg");
      thang->set_short("Schlorg");
      thang->set_medium_alias("beer");
      thang->set_long("This beer must be \"forn\".  It has none of the "
           "characteristic muddiness that all beer brewed from Pumpkin water "
           "possesses.\n" );
      thang->add_eat_effect("/std/effects/ingested/drunk", 180);
      thang->set_amount(3900);
      thang->move(thing);
      thing->do_close();
      return thing;
      break;
   case "salad" :
      thing = clone_object( "/obj/food" );
      thing->set_name("salad");
      thing->add_property("food", 1);
      thing->set_short( "green salad" );
      thing->set_long( "This green salad is at least partially green, "
         "with interesting bits and thingies in it.\n" );
      thing->add_eat_effect("/std/effects/ingested/nausea", 10);
      thing->set_value( 796 );
      thing->set_amount( 2000 );
      return thing;
   case "fish'n'chips" :
      thing = clone_object( "/obj/food" );
      thing->add_alias(({"fish","chips"}));
      thing->add_property("food", 1);
      thing->set_name("cod");
      thing->set_short( "fish'n'chips" );
      thing->set_long( "It's hard to tell what is the fish and which of "
         "the small, sloppy pieces that are supposed to be the chips.  "
         "They all taste the same anyway.\n" );
      thing->add_eat_effect("/std/effects/ingested/nausea", 10);
      thing->set_value( 1196 );
      thing->set_amount( 2000 );
      return thing;
   case "ribs" :
      thing = clone_object( "/obj/food" );
      thing->set_name("ribs");
      thing->add_property("food", 1);
      thing->set_short( "ribs" );
      thing->set_main_plural("ribs");
      thing->set_long( "These are ribs.  What animal(s) they come from is "
         "not of any interest, rest assured...  They are quite a lot smaller "
         "than the Real Pork Ribs that you can get in the posh restaurants "
         "in any case.\n" );
      thing->set_value( 1304 );
      thing->set_amount( 2000 );
      return thing;
   case "chicken sandwich" :
      thing = clone_object( "/obj/food" );
      thing->add_alias("sandwich");
      thing->add_property("food", 1);
      thing->set_name("chicken");
      thing->set_short( "hot chicken sandwich" );
      thing->set_long( "The chicken on this sandwich is of the green sort.  "
         "It smells funny, moves funny and even sounds a bit funny.  The "
         "only nice thing to say about this sandwich is that it is indeed "
         "hot.  It should probably be eaten with caution, though.\n" );
      thing->add_eat_effect("/std/effects/ingested/nausea", 40);
      thing->set_value( 796 );
      thing->set_amount( 2000 );
      return thing;
   case "ham sandwich" :
      thing = clone_object( "/obj/food" );
      thing->add_alias("sandwich");
      thing->add_property("food", 1);
      thing->set_name("ham");
      thing->set_short( "ham'n'cheese sandwich" );
      thing->set_long( "This sandwich has some ham and some cheese on it, "
         "which is why it is called a ham and cheese sandwich.  It has been "
         "baked in an oven.  A long time ago.  It is rather cold an clammy "
         "now.\n" );
      thing->set_value( 796 );
      thing->set_amount( 2000 );
      return thing;
   }
}
object create_container(string name) {
   object thing;
   switch (name) {
   case "schlorg" :
      thing = clone_object( "/obj/bottle" );
      thing->make_bottle("green", 1000);
      thing->set_value(1596);
      thing->set_long( (string)thing->query_long() + "This bottle has a "
               "slightly odd-looking porcelain cap, and no label at all, "
               "in the ordinary fashion of Schlorg-bottles discwide.\n");
      return thing;
   }
}
void reset() {
   int i, j, x, y, z;
   string *kinds = ({"jolly","burly","fat","happy","drunk","very drunk",
      "silly"});
   j = 5 + random(2);
   if (sizeof(drunkards) < 3) {
      drunkards = allocate(j);
   }
   for (i=0;i<(sizeof(drunkards));i++) {
      if (!drunkards[i]) {
         x = random(sizeof(kinds));
         y = random(4);
         drunkards[i] = clone_object("/obj/monster");
         drunkards[i]->set_name("drunkard");
         drunkards[i]->add_alias(kinds[x]+"drunkard");
         drunkards[i]->add_alias(kinds[x]+" drunkard");
         drunkards[i]->add_property("emote",1);
         drunkards[i]->add_move_zone("Flaming Cabbage");
         drunkards[i]->set_short(kinds[x]+" drunkard");
         drunkards[i]->set_main_plural(kinds[x]+" drunkards");
         drunkards[i]->add_plural("drunkards");
         drunkards[i]->add_plural(kinds[x]+" drunkards");
         drunkards[i]->set_gender(1+random(1));
         drunkards[i]->set_long("This "+kinds[x]+" drunkard seems very "
            "content with sitting here, chugging down beer after beer.  Who "
            "can blame " + drunkards[i]->query_objective() + ", really?\n");
         drunkards[i]->set_race("human");
         drunkards[i]->set_al(-300 + random(600));
         drunkards[i]->set_guild("fighters");
         drunkards[i]->set_class("fighter");
         drunkards[i]->adjust_con(10);
         drunkards[i]->adjust_str(5);
         drunkards[i]->adjust_dex(-1);
         drunkards[i]->set_level(75 + random(25));
         drunkards[i]->add_skill_level( "other.health", 50 );
         drunkards[i]->add_skill_level("fighting.combat.melee",
                                       20+random(20));
         drunkards[i]->add_skill_level("fighting.combat.special",30);
         drunkards[i]->adjust_money(0 + random(1),"Pumpkin dollar");
         drunkards[i]->adjust_money(10+ random(20),"Pumpkin pence");
         switch(y) {
            case 0:
            ((object)ARMOURY->request_item("dagger",30 +
                    random(30)))->move(drunkards[i]);
            drunkards[i]->init_equip();
            drunkards[i]->do_command("tactics response parry");
            drunkards[i]->add_skill_level("fighting.combat.parry.held",
                                          50+random(100));
            break;
            case 1:
               ((object)ARMOURY->request_item("knife",70 +
                                              random(20)))->move(drunkards[i]);
               ((object)ARMOURY->request_item("green pants",70 +
                                              random(20)))->move(drunkards[i]);
               drunkards[i]->init_equip();
               drunkards[i]->do_command("tactics response parry");
               drunkards[i]->add_skill_level("fighting.combat.parry.held",
                                             50+random(20));
               break;
            default:
               ((object)ARMOURY->request_item("knife",30 +
                                           random(30)))->move(drunkards[i]);
               ((object)ARMOURY->request_item("green pants",70 +
                                              random(20)))->move(drunkards[i]);
               drunkards[i]->init_equip();
               drunkards[i]->add_property("emote", 1);
               drunkards[i]->do_command("tactics response parry");
               drunkards[i]->add_skill_level("fighting.combat.parry.held",
                                             20+random(20));
               drunkards[i]->load_chat(2,({
                  1, "'I need another beer.",
                  1, "'Bring me some beer, will you?",
                  1, "'I jolly well need beer!  Hurry up!"
                    }));
         }
         drunkards[i]->move("/room/void");
         y = random(4);
         z = 40 + random(90);
         call_out("make_drunk", z, drunkards[i], y, kinds[x]);
      }
   }
   if (!bartender) {
      bartender = clone_object( "/obj/monster" );
      bartender->set_name("bartender");
      bartender->set_short("sympathetic bartender");
      bartender->add_property("determinate","a ");
      bartender->set_long("This bartender looks just like you would "
         "expect in a place like this.  He has a huge red beard and seems "
         "to be laughing and smiling in a friendly manner at everyone all "
         "the time.\n");
      bartender->set_race("human");
      bartender->set_gender( 1 );
      bartender->set_al( -350 );
      bartender->set_class("fighter");
      bartender->set_level(100);
      bartender->do_command("tactics attitude offensive");
      bartender->do_command("tactics response parry");
      bartender->adjust_con(6);
      bartender->adjust_str(6);
      bartender->adjust_dex(3);
      bartender->add_skill_level( "other.health",55);
      bartender->add_skill_level("fighting.combat.melee.sharp",100);
      bartender->add_skill_level("fighting.combat.special",50);
      ((object)ARMOURY->request_item("dagger",100))->move(bartender);
      ((object)ARMOURY->request_item("dagger",85))->move(bartender);
      ((object)ARMOURY->request_item("leather undershirt",80))->
         move(bartender);
      ((object)ARMOURY->request_item("leather breeches",80))->move(bartender);
      ((object)ARMOURY->request_item("white apron",80))->move(bartender);
      bartender->add_respond_to_with( ({({"@spank"}),"bartender"}),
         "thank $hname$ profusely");
      bartender->load_chat(25,({
                  1, ":brings some beer out to his thirsty customers.",
                  1, "@wink barmaid",
                  1, "@beam brightly",
                  1, "@hum",
                  1, "@laugh",
                  1, ":laughs pleasantly.",
                  1, "'Well, well - what have we here?",
                  1, "'Bring you another beer, shall I?"
                    }));
      bartender->init_equip();
      barmaid = clone_object( "/obj/monster" );
      barmaid->set_name("barmaid");
      barmaid->set_short("lovely barmaid");
      barmaid->set_long("This barmaid looks happy with her work.  She smiles "
         "a lot and has a noticeable tendency to flutter her eye-lashes at "
         "the bartender.\n");
      barmaid->set_race("human");
      barmaid->set_class("fighter");
      barmaid->set_level(50);
      barmaid->set_gender(2);
      ((object)ARMOURY->request_item("white linen skirt",80))->move(barmaid);
      ((object)ARMOURY->request_item("white apron",80))->move(barmaid);
      barmaid->init_equip();
      call_out("make_bart", 20, bartender, barmaid);
   }
}
void make_drunk(object ob, int y, string str) {
   int a = random(2);
   string adj, adv;
   adv = ({ "not at all", "very", "quite", "extremely", "rather" })
     [ random(5) ];
   ob->move(this_object(), "A "+  str + " drunkard comes in, looking " + adv +
          " thirsty.");
   switch (y) {
   case 0:
      adj = "small";
      break;
   case 1:
   case 2:
      adj = "wooden";
      break;
   case 3:
      adj = "sticky";
      break;
   }
   if (a)
      ob->do_command("sit at "+adj+" table");
   y = 5 + random(50);
   call_out("buy_new", y, ob);
}
void make_bart(object ob, object obette) {
   ob->move(this_object(), "The bartender pops up from behind the counter "
          "with a wide grin on his face.");
   call_out("make_barm", 5, obette);
}
void make_barm(object ob) {
   ob->move(this_object(), "The barmaid appears from behind the counter and "
          "tries to look innocent.  She desperately tries to sort out her "
          "hair which is a bit unordered.");
}
void buy_new(object ob) {
   int tim;
   if (!undefinedp(ob)) {
      if (environment(ob) == this_object()) {
         int z;
         string beer;
         beer = ({ "troll beer", "brew", "brew",
                      "unnameable liquid" })[ random(4) ];
         ob->adjust_money(5, "Pumpkin dollar");
         ob->do_command("buy " + beer );
         ob->do_command("hold glass in left hand");
         z = 120 + random(120);
         tim = 20 + random(20);
         while (tim < z) {
            call_out("sip_beer", tim, ob);
            tim += 30 + random(20);
         }
         call_out("drink_beer", z, ob);
      }
   }
}
void sip_beer(object ob) {
   if (ob &&
       environment(ob) == this_object()) {
      ob->do_command("drink 1/3rd of glass");
   }
}
void drink_beer(object ob) {
   if (!undefinedp(ob)) {
      ob->do_command("drink glass");
      ob->do_command("'Ha!  Nice beer, this.");
      call_out("no_litter",3,ob);
   }
}
void no_litter(object ob) {
   object pint, *obinv;
   int z;
   int a = random(2);
   if (!ob) {
      return ;
   }
   obinv = deep_inventory(ob);
   if (sizeof(obinv)) {
      foreach( pint in obinv ) {
	 if (pint->query_max_volume()) {
            switch (a) {
            case 0:
               ob->do_command("'Ah.  An empty pint.  Now what would I "
                       "want that for?");
               break;
            case 1:
               ob->do_command("'Bugger.  It's all empty.  Now I'm sad.");
               break;
            case 2:
               ob->do_command("'No more beer.  What has the world come to?");
               break;
	    }
            ob->do_command("put " + pint->query_name() + " on counter");
         }
      }
   }
   if (a) {
      z = 120 + random(240);
      call_out("buy_new", z, ob);
   } else {
      ob->do_command("north");
   }
}
int ref_to_serve(object player, int type) {
   int clock, servtime;
   clock = (time()%(3600*24));
   servtime = ((clock > 35000) && (clock < 60000));
   if((!servtime) && (type == PUB_MAINCOURSE)) {
      add_failed_mess("Unfortunately, this pub doesn't serve food at the "
         "moment.  Try to change your order, please.\n");
      return 2;
   }
}
void event_enter(object ob, string str, object from) {
   if (ob->query_name() == "drunkard") {
      if( sizeof( match_objects_for_existence( "pint", ob ))) {
         ob->do_command("'Time for another beer for me.");
         call_out("buy_new",5 + random(50),ob);
      }
   }
}

==================================================
FILE: dist/pumpkin/squash/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/squash/squash1.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("northwest corner of Squash Square");
  set_long("This is the north west corner of Squash Square\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash2", "road");
  add_exit("south", SQUASH + "squash4", "road");
  add_exit("southeast", SQUASH + "squash5", "hidden");
  add_property( "los", "open" );
  set_linker(({ PATH + "squash2", PATH + "squash4", PATH + "squash5" }),
             "to a point", "", "Squash Square");
  set_zone("pumpkin");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/squash/squash2.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("north edge of Squash Square");
  set_long("This is the north of Squash Square at the "
           "junction with Pumpkin Way.\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash3", "road");
  add_exit("west", SQUASH + "squash1", "road");
  add_exit("north", PUMPKIN + "pumpkin6", "road");
  add_exit("south", SQUASH + "squash5", "road");
  add_exit("southwest", SQUASH + "squash4", "hidden");
  add_exit("southeast", SQUASH + "squash6", "hidden");
  set_linker(({ PATH + "squash3", PATH + "squash1", PATH + "squash5",
                PATH + "squash4", PATH + "squash6" }),
             "into", "", "Squash Square");
  set_zone("pumpkin");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/squash/squash3.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("north east corner of Squash Square");
  set_long("This is the north east corner of Squash Square\n");
  set_light( 80 );
  add_exit("west", SQUASH + "squash2", "road");
  add_exit("south", SQUASH + "squash6", "road");
  add_exit("southwest", SQUASH + "squash5", "hidden");
  add_property( "los", "open" );
  set_linker(({ PATH + "squash2", PATH + "squash6", PATH + "squash5" }),
             "to a point", "", "Squash Square");
  set_zone("pumpkin");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/squash/squash4.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("west edge of Squash Square");
  set_long("This is the west side of Squash Square at the junction "
           "with Fruitbat Avenue.\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash5", "road");
  add_exit("west", FRUITBAT + "fruitbat4", "road");
  add_exit("north", SQUASH + "squash1", "road");
  add_exit("south", SQUASH + "squash7", "road");
  add_exit("northeast", SQUASH + "squash2", "hidden");
  add_exit("southeast", SQUASH + "squash8", "hidden");
  add_property( "los", "open" );
  set_linker(({ PATH + "squash5", PATH + "squash1", PATH + "squash7",
                 PATH + "squash2", PATH + "squash8" }),
              "into", "", "Squash Square");
  set_zone("pumpkin");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/squash/squash5.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("in the middle of Squash Square");
  set_long("This is the middle of Squash Square\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash6", "road");
  add_exit("west", SQUASH + "squash4", "road");
  add_exit("north", SQUASH + "squash2", "road");
  add_exit("south", SQUASH + "squash8", "road");
  add_exit("northeast", SQUASH + "squash3", "hidden");
  add_exit("northwest", SQUASH + "squash1", "hidden");
  add_exit("southeast", SQUASH + "squash9", "hidden");
  add_exit("northwest", SQUASH + "squash7", "hidden");
  add_property( "los", "open" );
  set_linker(({ PATH + "squash6", PATH + "squash4", PATH + "squash2",
                PATH + "squash8", PATH + "squash3", PATH + "squash1",
                PATH + "squash9", PATH + "squash7" }),
             "to a point", "", "Squash Square");
  set_monster(1, "city");
  set_zone("pumpkin");
  set_co_ord(({ 0, 0, 0 }));
}

==================================================
FILE: dist/pumpkin/squash/squash6.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("east edge of Squash Square");
  set_long("This is east side of Squash Square at the junction "
           "with Rabbit Lane.\n");
  set_light( 80 );
  add_exit("east", RABBIT + "rabbit1", "road");
  add_exit("west", SQUASH + "squash5", "road");
  add_exit("north", SQUASH + "squash3", "road");
  add_exit("south", SQUASH + "squash9", "road");
  add_exit("northwest", SQUASH + "squash2", "hidden");
  add_exit("southwest", SQUASH + "squash8", "hidden");
  add_property( "los", "open" );
  set_linker(({ PATH + "squash5", PATH + "squash3", PATH + "squash9",
                PATH + "squash2", PATH + "squahs8" }),
             "into", "", "Squash Square");
  set_zone("pumpkin");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/squash/squash7.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("south west corner of Squash Square");
  set_long("This is the south west corner Squash Square\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash8", "road");
  add_exit("north", SQUASH + "squash4", "road");
  add_exit("northeast", SQUASH + "squash3", "hidden");
  add_property( "los", "open" );
  set_linker(({ PATH + "squash8", PATH + "squash4", PATH + "squash3" }),
             "to a point", "", "Squash Square");
  set_zone("pumpkin");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/squash/squash8.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("south edge of Squash Square");
  set_long("This is south side of Squash Square at the "
           "junction with Gumboot Road.\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash9", "road");
  add_exit("west", SQUASH + "squash7", "road");
  add_exit("north", SQUASH + "squash5", "road");
  add_exit("south", GUMBOOT + "gumboot1", "road");
  add_exit("northwest", SQUASH + "squash4", "hidden");
  add_exit("northeast", SQUASH + "squash6", "hidden");
  add_property( "los", "open" );
  set_linker( ({ PATH + "squash9", PATH + "squash7", PATH + "squash5",
                 PATH + "squash4", PATH + "squash6" }),
             "into", "", "Squash Square");
  set_zone("pumpkin");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/squash/squash9.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("south east corner of Squash Square");
  set_long("This is the south east corner Squash Square.\n");
  set_light( 80 );
  add_exit("west", SQUASH + "squash8", "road");
  add_exit("north", SQUASH + "squash6", "road");
  add_exit("northwest", SQUASH + "squash5", "hidden");
  add_exit("east", PATH + "beer_bar", "door");
  add_property( "los", "open" );
  set_linker(({ PATH + "squash8", PATH + "squash6", PATH + "squash5" }),
             "to a point", "", "Squash Square");
  set_zone("pumpkin");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/terrain/desert.c
==================================================

#include "path.h";
inherit "/std/outsides/desert";
void setup() {
  set_short("Desert");
  set_long("A bunch of sand.");
  set_light( 80 );
}

==================================================
FILE: dist/pumpkin/terrain/desertpath.c
==================================================

inherit "/std/outsides/road";
void setup() {
   set_short("Road through desert");
   set_long("A road through the desert.");
   set_light(80);
}

==================================================
FILE: dist/pumpkin/terrain/path.h
==================================================

#include "../path.h"

==================================================
FILE: dist/pumpkin/terrain/plainpath.c
==================================================

inherit "/std/outsides/road";
void setup() {
   set_short("Road through plain");
   set_long("A road through the plain.");
   set_light(80);
}

==================================================
FILE: dist/pumpkin/terrain/plains.c
==================================================

#include "path.h";
inherit "/std/outsides/plain";
void setup() {
  set_short("Plains");
  set_long("A bunch of plains.");
  set_light( 80 );
}

==================================================
FILE: dist/pumpkin/terrain/terrain_handler.c
==================================================

#include <terrain_map.h>
#include "path.h"
inherit TERRAIN_MAP_HANDLER_BASE;
string query_map_file() {
    return __DIR__ + "terrain";
}
void setup_handler() {
    set_newline_mode(0);
   set_visible_distance(5);
   add_obstacle_type("H", "a lush, thick hedge surrounds the small garden",
     "hedge", "The hedge surrounds the garden, stretching thick and "
     "impenetrable towards the sky, protecting anyone in the garden from the "
     "gawking eyes of passers-by.");
   add_obstacle_type("*", "s big high lump that you cannot avoid looking at",
     "lump", "The lump is very lumpy.");
   add_feature("lump",
               16, 3,
               1, 1,
               15,
               ({
                  "a lump towers above you to the $D",
                }),
               "lump", "A lumpy thing that lumps around.",
               ({
                  "a lump at night to the $D",
                }),
               "It looks just like a lump, even though it is dark.");
   add_road_type("=", __DIR__ "plainpath",
     "", "a nice sandy path leads through the plains.");
   add_road_type("+", __DIR__ "woodpath",
     "", "a nice sandy path leads through the woods.");
   add_road_special_type("-", __DIR__ "desertpath",
     3,
     1,
     0,
     "", "a nice sandy path leads through the woods.");
   add_room_type("L", __DIR__ "plains");
   add_room_type("W", __DIR__ "woods");
   add_room_type("d", __DIR__ "desert");
   add_exit_at(0, 1, "west", GUMBOOT + "gumboot5", "road");
   add_exit_at(0, 18, "west", RABBIT + "rabbit4", "road");
}

==================================================
FILE: dist/pumpkin/terrain/woods.c
==================================================

#include "path.h";
inherit "/std/outsides/woodland";
void setup() {
  set_short("Woodlands");
  set_long("A bunch of trees.");
  set_light( 80 );
}

==================================================
FILE: dist/pumpkin/terrain/woodspath.c
==================================================

inherit "/std/outsides/road";
void setup() {
   set_short("Road through woods");
   set_long("A road through the woods.");
   set_light(80);
}

==================================================
FILE: dist/pumpkin/pumpkin/hospital.c
==================================================

#include <armoury.h>
#include <hospital.h>
#include <living.h>
#include <map.h>
#include <money.h>
#include <move_failures.h>
#include <route.h>
#include <wander.h>
#include "path.h"
#define MAX_HEAVIES 10
#define DAY 8 * 60 * 60
#define INTERVAL 20 * 60
#define MUD_TO_REAL 3
#define BLOCK 5
#define MAX_EMPTIES 12
#define MAX_MOVERS 60
#define SAVE_FILE SAVE +"hospital"
inherit "/std/room/basic_room";
nosave int alchemists, update, *alignments;
mapping uniques;
nosave int *al_data;
nosave string *city;
nosave object *empties;
nosave mapping blockages;
nosave mixed *movers;
nosave int am_npcs, last_check;
int ok_to_clone();
void get_weapon(object ob, string *items);
void get_armour(object ob, string *items);
void get_jewellery(object ob, string *items);
void setup() {
   set_keep_room_loaded(1);
   update = time();
   alignments = allocate( 50 );
   uniques = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 ) {
      unguarded( (: restore_object, SAVE_FILE :) );
   }
   alchemists++;
   unguarded( (: save_object, SAVE_FILE :) );
   city = ({
      "child", "rodent", "cockroach", "dog"
   });
   empties = ({ });
   blockages = ([ ]);
   movers = allocate( MAX_MOVERS );
   call_out( "check_movers", 10 );
   call_out( "housekeeping", INTERVAL );
}
int *query_al_data() { return al_data; }
mapping query_uniques() { return uniques; }
object *query_empties() { return empties; }
mapping query_blockages() { return blockages; }
int query_blockage( string this, string other, int number ) {
   if ( undefinedp( blockages[ this ] ) ) {
      if ( random( 100 ) >= BLOCK )
         number = -1;
      blockages[ this ] = blockages[ other ] = number;
   }
   return blockages[ this ];
}
mixed *query_movers() { return movers; }
void housekeeping() {
   object thing;
   update = time();
   foreach( thing in users() ) {
      if ( thing->query_creator() )
         continue;
      alignments[ random( sizeof( alignments ) ) ] =
            (int)thing->query_al();
   }
   al_data = 0;
   unguarded( (: save_object, SAVE_FILE :) );
   call_out( "housekeeping", INTERVAL );
}
int pick_al() {
   int one, *stats;
   if ( !al_data ) {
      al_data = allocate( 3 );
      stats = allocate( 4 );
      foreach( one in alignments ) {
         stats[ 0 ] += one;
         stats[ 1 ] += one * one;
         if ( one > stats[ 2 ] )
            stats[ 2 ] = one;
         if ( one < stats[ 3 ] )
            stats[ 3 ] = one;
      }
      stats[ 0 ] /= sizeof( alignments );
      stats[ 1 ] /= sizeof( alignments );
      stats[ 1 ] -= stats[ 0 ] * stats[ 0 ];
      stats[ 1 ] /= 10;
      if ( stats[ 1 ] < 50 )
         stats[ 1 ] = 50;
      stats[ 2 ] -= stats[ 3 ];
      if ( stats[ 2 ] < 2 )
         stats[ 2 ] = 2;
      al_data[ 0 ] = stats[ 0 ] - stats[ 2 ] / 2;
      al_data[ 1 ] = ( stats[ 2 ] * stats[ 2 ] ) / ( 12 * stats[ 1 ] );
      if ( al_data[ 1 ] < 5 )
         al_data[ 1 ] = 5;
      al_data[ 2 ] = ( 12 * stats[ 1 ] ) / stats[ 2 ];
      if ( al_data[ 2 ] < 25 )
         al_data[ 2 ] = 25;
   }
   return al_data[ 0 ] + roll_MdN( al_data[ 1 ], al_data[ 2 ] );
}
int make_unique( string word ) {
   if ( uniques[ word ] > time() )
      return 0;
    uniques[ word ] = time() + 1 * 60 * 60;
   unguarded( (: save_object, SAVE_FILE :) );
   return 1;
}
void add_mover( object thing ) {
   int number;
   number = MAX_MOVERS / 2 + random( MAX_MOVERS / 2 );
   if ( !pointerp( movers[ number ] ) )
      movers[ number ] = ({ thing });
   else
      movers[ number ] += ({ thing });
}
object get_monster( string type ) {
   object thing;
   object ob;
   switch( type ) {
      case "city" :
      case "pumpkin" :
         thing = get_monster( city[ random( sizeof( city ) ) ] );
         thing->add_property( "monster type", type +":"+
               (string)thing->query_property( "monster type" ) );
         thing->add_move_zone( "Pumpkin" );
         add_mover( thing );
         return thing;
      case "dog":
         thing = clone_object( CHARS + "dog" );
         if ( random( 4 ) )
            thing->set_type( "small" );
         else
            thing->set_type( "large" );
         thing->add_effect( "/std/effects/npc/i_died",
               ({ HOSPITAL, "regen_after_death" }));
         thing->add_effect( "/std/effects/npc/eat_edible" );
         thing->add_effect( "/std/effects/npc/savage_corpse" );
         thing->add_property( "monster type", type );
         thing->add_property("animal type", type);
         return thing;
      case "child":
         thing = clone_object( CHARS + "child_human" );
         return thing;
    case "cityguard":
      ob = clone_object(MONSTER);
      ob->add_property("monster type", type);
      ob->set_name("guard");
      ob->add_adjective("city");
      ob->set_main_plural( "city guards" );
      ob->set_short("city guard");
      ob->set_long("This is a city guard. He is supposed to protect the " +
        "city from undesirables. Sadly, Pumpkin isn't very fussy.\n");
      ob->set_race("human");
      ob->set_gender("male");
      ob->set_guild("fighter");
      ob->set_level(8);
      ob->set_al( pick_al() / 5 );
      ob->adjust_money( 5 + random( 10 ), "Pumpkin pence" );
      ob->load_chat(10, ({
          3, "@grumble bitterly",
          1, "@daydream",
          1, "@sigh heavily"
          }) );
      ob->load_a_chat(50, ({
          1, "'Ouch!",
          1, "'Come on! I don't need this.",
          1, "'Be on your way!",
          }) );
      ARMOURY->request_weapon("long sword", 40+random(40))->move(ob);
      if(random(2))
        ARMOURY->request_armour("hard leather cap", 70 + random(30))->move(ob);
      ob->init_equip();
      return ob;
    case "mercenary":
      ob = clone_object(MONSTER);
      ob->set_name("mercenary");
      ob->set_main_plural( "mercenaries" );
      ob->add_plural( "mercenaries" );
      ob->add_adjective("tough");
      ob->set_race("human");
      ob->set_class("fighter");
      ob->set_level( 50 + roll_MdN( 5, 50 ) );
      ob->set_al( pick_al() );
      ob->set_gender(random(2) + 1);
      ob->set_long("A tough battle scarred mercenary.  There are better "
                   "ways of filling in an afternoon than messing with the "
                   "likes of "+ob->query_objective()+".\n");
      ob->adjust_money( 5 + random( 50 ), "Ankh-Morpork pence" );
      ob->adjust_money( 1 + random( 5 ), "Ankh-Morpork dollar" );
      ob->load_chat(3, ({
        1, "'Anyone you don't like?",
        1, "'I'll do anything if the price is right?",
        1, "'Don't get me angry.  You won't like me when I'm angry."
      }));
      ob->load_a_chat(30, ({
        1, "'I'll show you who's boss.",
        1, "'You think you're so tough.",
        1, "The crowd runs in terror as the mercenary kills someone by "+
           "accident."
      }));
      get_weapon(ob, ({"bastard sword", "long sword", "morning star",
       "two-handed axe"}));
      get_armour(ob, ({"chainmail", "splintmail", "ringmail"}));
      ob->add_property("monster type", type);
      ob->init_equip();
      return ob;
    case "rodent":
      ob = clone_object(MONSTER);
      ob->set_name("rat");
      ob->set_short("rat");
      ob->set_race("rat");
      ob->set_level( random( 1 + random( 3 ) ) );
      ob->add_alias("city rat");
      ob->set_main_plural("rats");
      ob->add_adjective("dirty");
      ob->add_adjective("city");
      ob->set_long("This is a large rat.  It appears to have done well "+
       "living in the city.\n"+
       "The pollution must not affect it too much.\n" );
      ob->load_chat( 5, ({
         1, ":squeaks.",
         1, ":sniffs the air, whiskers twitching.",
         1, ":checks for dwarves."
      }) );
      ob->set_wimpy( 10 );
      ob->load_a_chat( 50, ({
         1, ":squeals in pain.",
         1, ":twitches fearfully."
      }) );
      ob->add_effect("/std/effects/npc/i_died",
                     ({ HOSPITAL, "regen_after_death" }));
      ob->add_effect( "/std/effects/npc/eat_edible" );
      ob->add_effect( "/std/effects/npc/savage_corpse" );
      ob->add_property("monster type", type);
      ob->add_property("animal type", type);
      return ob;
    case "cockroach":
      ob = clone_object(MONSTER);
      ob->set_name("cockroach");
      ob->set_short("cockroach");
      ob->set_race("cockroach");
      ob->set_level( random( 1 + random( 3 ) ) );
      ob->set_main_plural("cockroaches");
      ob->add_adjective("dirty");
      ob->add_alias("roach");
      ob->set_long( "This is a huge dirty great big cockroach, the size of "
             "your hand at least.  It waves its feelers at you and looks "
             "horrible and black.  Not only can cockroaches survive fires, "
             "plagues, earthquakes and miscellaneous acts of supernatural "
             "beings, they can survive in Ankh-Morpork!\n" );
      ob->load_chat( 5, ({
         10, ":scuttles around a bit.",
         10, ":cleans its feelers.",
         10, ":rushes around in circles.",
         1,  ":jerks off in a strange direction.",
      }) );
      ob->set_wimpy( 30 );
      ob->load_a_chat( 50, ({
         1, ":oozes horrible white stuff.",
         1, ":makes a sort of scraping noise."
      }) );
      ob->add_effect("/std/effects/npc/i_died",
                      ({ HOSPITAL, "regen_after_death" }));
      ob->add_property("monster type", type);
      ob->add_property("animal type", type);
      return ob;
    default:
      ob = clone_object(MONSTER);
      ob->set_name("failure");
      ob->set_short("failure");
      ob->set_long( "Please inform a creator about this object.\n"+
          "Type is "+ type +" from "+ file_name( previous_object() ) +".\n" );
      ob->add_property( "monster type", "failure:"+ type );
      return ob;
  }
}
void get_armour(object ob, string *items) {
  ARMOURY->request_armour(items[random(sizeof(items))], 50+random(50))->
    move(ob);
}
void get_jewellery(object ob, string *items) {
  ARMOURY->request_armour(items[random(sizeof(items))], 20+random(80))->
    move(ob);
}
void get_weapon(object ob, string *items) {
  ARMOURY->request_weapon(items[random(sizeof(items))], 50+random(50))->
    move(ob);
}
void regen_after_death(object player) {
  object ob, dest;
  string nam;
  if (!player)
    return ;
  nam = (string)player->query_property("monster type");
  dest = (object)player->query_property("start location");
  if ( !nam )
    return;
  if ( !dest )
    return;
  if(!ok_to_clone())
    return;
  ob = get_monster( explode( nam, ":" )[ 0 ] );
  dest->add_monster(player, ob);
  call_out("do_move", 10, ({ ob, dest }) );
}
void do_move(mixed *junk) {
  junk[0]->move(junk[1]);
}
string change_to_name(object ob) {
  return implode((string *)ob->query_adjectives(), " ")+
         (string)ob->query_name();
}
void do_run(object ob) {
  if (ob)
    ob -> run_away();
}
void fight_check(object ob, object ob1) {
  if (ob->query_property(previous_object()->query_name()))
    previous_object()->attack_ob(ob1);
}
void do_grin_laugh(object ob) {
  ob->add_respond_to_with(({ "@grin", ob->query_name() }),
                          "laugh man at $hname$");
}
void add_empty( object thing ) {
   empties -= ({ 0 });
   empties += ({ thing });
   if ( sizeof( empties ) > MAX_EMPTIES )
      empties = shuffle( empties )[ 0 .. MAX_EMPTIES - 1 ];
}
void move_monster( object thing ) {
   int i;
   string dest, direc, zone, *movez, *roomz;
   object place;
   if ( !thing )
      return;
   if ( (int)thing->query_hp() < 0 )
      return;
   if ( thing->query_property( PASSED_OUT ) || thing->query_fighting() ) {
      add_mover( thing );
      return;
   }
   movez = (string *)thing->query_move_zones();
   empties -= ({ 0 });
   if ( sizeof( empties ) && !thing->check_anyone_here() )
      foreach ( place in empties ) {
         roomz = (string *)place->query_zones();
         if ( !sizeof( roomz ) ) {
            empties -= ({ place });
            continue;
         }
         foreach ( zone in roomz ) {
            i = member_array( zone, movez );
            if ( i != -1 )
               break;
         }
         if ( i == -1 )
            continue;
         thing->move( place );
         place->add_monster( 0, thing );
         place->announce_entry( thing );
         empties -= ({ place });
         add_mover( thing );
         return;
      }
   place = environment( thing );
   if ( !place )
      return;
   add_mover( thing );
   foreach ( direc in shuffle( (string *)place->query_direc() ) ) {
      place->set_destination( direc );
      dest = (string)place->query_destination( direc );
      if ( !stringp( dest ) )
         continue;
      if ( !thing->check_anyone_here() && !find_object( dest ) )
         continue;
      if ( find_object( dest ) )
         roomz = (string *)dest->query_zones();
      else
         roomz = (string *)MAP->query_zones( dest );
      if ( !sizeof( roomz ) )
         continue;
      foreach ( zone in roomz ) {
         i = member_array( zone, movez );
         if ( i != -1 )
            break;
      }
      if ( i == -1 )
         continue;
      if ( place->query_relative( direc ) )
         direc = (string)thing->find_rel( direc, 0 );
      if ( thing->do_command( direc ) )
         return;
   }
}
void check_movers() {
   int when;
   object thing, *things;
   things = movers[ 0 ];
   movers[ 0 .. MAX_MOVERS - 2 ] = movers[ 1 .. ];
   movers[ MAX_MOVERS - 1 ] = 0;
   call_out( "check_movers", 10 );
   if ( !pointerp( things ) )
      return;
   foreach ( thing in things ) {
      if ( objectp( thing ) ) {
         when += 2;
         call_out( "move_monster", when, thing );
      }
   }
}
int ok_to_clone() {
  if(time() > last_check + 300) {
    last_check = time();
    am_npcs = sizeof( filter( named_livings(),
      (: environment( $1 ) && base_name( environment( $1
       ) )[0..4] == "/d/am" :) ) );
  }
  return ( am_npcs < MAX_AM_LIVING );
}
int *query_npcs() {
  return ({ am_npcs, last_check });
}

==================================================
FILE: dist/pumpkin/pumpkin/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/pumpkin/pumpkin1.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Pumpkin Way");
  set_long("This is end of Pumpkin Way at the junction with Crumpet Circle.\n");
  set_light( 80 );
  add_exit("east", PUMPKIN + "pumpkin2", "road");
  add_exit("southwest", CRUMPT + "crumpt1", "road");
  set_monster(2, "pumpkin");
}

==================================================
FILE: dist/pumpkin/pumpkin/pumpkin2.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Pumpkin Way");
  set_long("This is middle of Pumpkin Way just north of Crumpt Circle.\n");
  set_light( 80 );
  add_exit("west", PUMPKIN + "pumpkin1", "road");
  add_exit("south", PUMPKIN + "pumpkin3", "road");
  set_monster(2, "pumpkin");
}

==================================================
FILE: dist/pumpkin/pumpkin/pumpkin3.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Pumpkin Way");
  set_long("This is the middle of Pumpkin Way north of Squash Square.\n");
  set_light( 80 );
  add_exit("north", PUMPKIN + "pumpkin2", "road");
  add_exit("south", PUMPKIN + "pumpkin4", "road");
  set_monster(2, "pumpkin");
}

==================================================
FILE: dist/pumpkin/pumpkin/pumpkin4.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Pumpkin Way");
  set_long("This is the middle of Pumpkin Way you can just see Squash Square "
           "to the south.\n");
  set_light( 80 );
  add_exit("north", PUMPKIN + "pumpkin3", "road");
  add_exit("south", PUMPKIN + "pumpkin5", "road");
  add_exit("west", PATH + "stable_entry", "gate");
  set_monster(2, "pumpkin");
}

==================================================
FILE: dist/pumpkin/pumpkin/pumpkin5.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Pumpkin Way");
  set_long("This is the middle of Pumpkin Way, quite close to the junction "
           "with Squash Square to the south.\n");
  set_light( 80 );
  add_exit("north", PUMPKIN + "pumpkin4", "road");
  add_exit("south", PUMPKIN + "pumpkin6", "road");
  set_monster(2, "pumpkin");
}

==================================================
FILE: dist/pumpkin/pumpkin/pumpkin6.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Pumpkin Way");
  set_long("This is the end of Pumpkin Way at the junction with "
           "Squash Square.\n");
  set_light( 80 );
  add_exit("north", PUMPKIN + "pumpkin5", "road");
  add_exit("south", SQUASH + "squash2", "road");
  set_monster(2, "pumpkin");
}

==================================================
FILE: dist/pumpkin/pumpkin/stable_entry.c
==================================================

#include "path.h"
#include <armoury.h>
inherit "/std/room/stable";
void setup() {
   set_light(60);
   set_theft_handler( HOSPITAL );
   set_short( "stables" );
   add_property("determinate", "the ");
   set_long( "These are the Pumpkin Street stables, an ornate gate to the "+
      "north opening onto the street.  There are many stalls here, "+
           "and some of them even have horses in them. Against one wall "+
           "is a pile of hay and hanging on the walls are saddles and "+
           "other horse riding equipment.\n");
   add_exit( "east", PATH +"pumpkin4", "gate" );
   add_item(({"horse", "horses"}), "There are a few horses here, but "+
              "most of them seem to be in the carthorse mold, rather "+
              "than being fine chargers.\n");
   add_item(({"hay", "pile"}), "A big pile of hay (that's dead grass to you and me).\n");
   add_item(({"saddle", "saddles", "riding equipment", "equipment"}),
              "Hanging on one wall are saddles, bridles, bits and other "+
              "things that help you ride a horse.\n");
   add_item("stalls", "Boxes where horses live!\n");
   add_item("gate", "A large gate, made of wrought iron bent into intricate "+
                    "shapes. On the other side you can see Filigree Street.\n");
   add_item(({"shape", "shapes"}), "There are many shapes and patterns "+
              "to be found in the twists and turns of the iron gates, "+
              "but you can't find any meaning in them. Maybe it's "+
              "meant to be abstract?\n");
   room_chat( ({ 50, 50, ({
 		  "A horseman rides through the gates and dismounts. "+
             "A stable boy rushes forward and leads the horse to a stall "+
             "while the rider leaves.",
             "One of the horses rears up in its stall, but can't "+
             "force the door open."
   }) }) );
   set_zone("pumpkin stables");
   set_save_directory("/d/dist/pumpkin/save/stables/");
   add_stable_type("horse");
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/pumpkin/stable_shop.c
==================================================

#include "path.h"
inherit "/std/shops/item_shop";
void setup() {
   set_short("Stable shop");
   set_long(
"You are in the stable shop, it is completely full of various weird things "
"like bits, bridles and other obscure looking bits of leather.\n");
   add_exit("west", PATH + "pumpkin5", "gate");
   set_light(70);
   add_object("pale grey horse");
   add_object("painted grey horse");
   add_object("plaid horse");
   add_object("dappled brown horse");
   add_object("light brown horse");
   add_object("dark brown horse");
   add_object("dark red horse");
   add_object("black warhorse");
   add_property("place", "Pumpkin");
}
object create_object(string thing) {
   object horse;
   object bing;
   if (strlen(thing) > 8 && thing[<8..] == "warhorse") {
      horse = clone_object("/obj/monster/transport/warhorse");
      horse->set_colour(thing[0..<10]);
      horse->set_value(8);
      horse->add_property("cost here", 8);
      return horse;
   } else if (strlen(thing) > 5 && thing[<5..] == "horse") {
      horse = clone_object("/obj/monster/transport/horse");
      horse->set_colour(thing[0..<7]);
      horse->set_value(8);
      horse->add_property("cost here", 8);
      return horse;
   } else {
      bing = clone_object(thing);
      bing->setup_clothing(1000);
      bing->set_value(8);
      return bing;
   }
}

==================================================
FILE: dist/pumpkin/chars/child_human.c
==================================================

#include "path.h"
inherit "/obj/monster";
void respond_to_soul(object play);
void setup() {
   int i;
   string *types = ({ "playful", "quiet", "thin", "fat", "noisy",
         "thoughtful", "happy", "sad", "boring", "interesting" });
   set_name( "child" );
   i = random( sizeof( types ) );
   set_short( types[ i ] +" child" );
   add_adjective( types[ i ] );
   set_main_plural( types[ i ] +" children" );
   set_race( "human" );
   set_gender( 1 + random( 2 ) );
   i = (int)"/std/races/human"->query_weight();
   i += (int)"/std/races/human"->modifier( weight );
   set_base_weight( ( 3 * i ) / ( 4 + random( 6 ) ) );
   i = (int)"/std/races/human"->query_height();
   i += (int)"/std/races/human"->modifier( height );
   set_height( ( 2 * i ) / ( 3 + random( 4 ) ) );
   set_con( ( 2 * query_con() ) / ( 3 + random( 4 ) ) );
   set_dex( ( 2 * query_dex() ) / ( 3 + random( 4 ) ) );
   set_str( ( 2 * query_str() ) / ( 3 + random( 4 ) ) );
   set_al( -50 + (int)HOSPITAL->pick_al() / 10 );
   set_level( random( 5 ) );
   set_wimpy( 90 );
   set_long( "This is one of the inhabitants of Pumpkin.\n" );
   add_effect( "/std/effects/npc/gossip", 5);
   load_chat(40, ({ 1, "#do_gossip_say:$mess$" }));
   add_respond_to_with(({ ({ "@skick", "@spunch", "@jump", "@push",
                             "@shove", "@knee" }) }),
                       (: respond_to_soul :));
}
void respond_to_soul(object play) {
   switch (random(6)) {
   case 0:
      do_command("'Thats not very nice!");
      break;
   case 1:
      do_command("'Pick on someone your own size.");
      do_command("glare " + player->query_name());
      break;
   case 2:
      do_command("cry");
      do_command("accuse " + player->query_name() + " of child abuse");
      break;
   case 3:
      do_command("spunch " + player->query_name());
      do_command("'Take that!  and that!");
      do_command("skick " + player->query_name());
      break;
   case 4:
      do_command("accuse " + player->query_name() + " of child abuse");
      break;
   case 5:
      do_command("'I will tell my brother!");
      break;
   }
   call_out("run_away", 2);
}

==================================================
FILE: dist/pumpkin/chars/dog.c
==================================================

inherit "/obj/monster";
#include "path.h"
string colour, type;
void check_for_hidden();
void test_rabid_attack();
void test_urinate();
void pat_me( object per );
void sic_em( object per, string mess );
string query_colour() { return colour; }
void setup() {
   colour = ({ "light brown", "black", "grey", "mottled", "white", "patched",
         "dark brown", "black and white", "fluorescent yellow" })[ random( 9 ) ];
  set_name("dog");
  set_race("dog");
  set_gender(1 + random(2));
  set_level( 1 + random( 1 + random( 3 ) ) );
  add_adjective("hairy");
  add_adjective(explode(colour, " "));
}
void set_type(string type) {
   set_short( type +" "+ colour +" dog" );
   set_main_plural( type +" "+ colour +" dogs" );
   add_adjective( type );
   if ( type == "small" ) {
      set_long("The small "+colour+" dog is very hairy.  It looks a "
                 "bit sad and lost in the streets of Pumpkin.  "
                 "You are sure it would prefer a cat flap and a nice "
                 "hot meal every night, or is that you?\n");
   } else {
      add_skill_level( "fighting", random( 10 + random( 30 ) ) );
      add_skill_level( "other.health", random( 10 + random( 30 ) ) );
      set_main_plural("large "+colour+" dogs");
      add_adjective("large");
      set_long("The large "+colour+" dog confidently walks the streets, "
                 "insolently not moving aside for the warriors and heroes "
                 "stalking the streets.\n");
   }
   add_enter_commands( "#check_for_hidden" );
   if ( !random( 3 ) )
     add_effect( "/std/effects/disease/flea_infestation", 10000 );
  if (!random(6)) {
    set_wimpy(10);
    load_chat( 10, ({
       1, "@froth",
       1, "@roll eye",
       1, "@growl",
       1, "#test_rabid_attack",
    }) );
    load_a_chat( 10, ({
       1, "@froth",
       1, "@roll eye",
       1, "@growl" }) );
    add_respond_to_with( ({ ({ "@pat", "@stroke", "@hug" }),
                             query_name() }), "bite $hname$");
  } else {
    set_wimpy( 70 );
    load_chat( 5, ({
       1, (type=="small"?":whines pathetically.":"@growl"),
       1, (type=="small"?"@stare hungrily at $lname":
                             "@stare int at $lname"),
       1, (type=="small"?"@bite $lname ankles":"@stare rud at $lname"),
       1, "#test_urinate",
    }) );
    load_a_chat( 50, ({
       1, "@bite $aname ?",
       1, "@growl",
       1, "@bark",
    }) );
    add_respond_to_with( ({ ({ "@pat", "@stroke", "@hug" }),
                                query_name() }), "#pat_me" );
    add_respond_to_with( ({ "@say", ({ "get", "sic" }), }), "#sic_em" );
  }
  add_effect("/std/effects/npc/eat_edible", 0);
  add_effect("/std/effects/npc/i_died", ({ HOSPITAL, "regen_after_death" }));
  add_property("monster_type", type);
  add_property("animal type", type);
}
void bark_at_hidden(object per) {
  mapping hide_invis;
  if (per) {
    hide_invis = per->query_hide_invis();
    if (environment(per) == environment() &&
        hide_invis["hiding"]) {
      do_command("bark loudly");
      if (!random(4))
        do_command("bark loudly at "+
                 per->query_name());
      else
        do_command("bark loudly");
      call_out("bark_at_hidden", 2, per);
    }
  }
}
void check_for_hidden() {
  object *obs, mine;
  int i;
  mapping hide_invis;
  function fun;
  mine = query_property("following");
  obs = all_inventory(environment(this_object()));
  for (i=0;i<sizeof(obs);i++) {
    hide_invis = query_hide_invis();
    if (living(obs[i]) && hide_invis["hiding"] &&
        obs[i] != mine && obs[i]->query_visible(this_object())) {
      call_out("bark_at_hidden", 0, obs[i]);
      break;
    }
  }
}
void test_rabid_attack() {
  int i;
  object *obs;
  obs = filter_array(all_inventory(environment()),
                     (: living($1) && $1 != $2 &&
                        (!$1->query_property("player") ||
                         $1->query_level() > 5) :),
                      this_object());
  if (sizeof(obs))
    attack_ob(obs[0]);
}
void test_urinate() {
  object *obs, *liv, blue, mine;
  int i;
  liv = ({ });
  mine = query_property("following");
  obs = all_inventory(environment());
  check_for_hidden();
  for (i=0;i<sizeof(obs);i++) {
    if (living(obs[i]) && obs[i] != mine &&
        obs[i] != this_object()) {
      liv += obs[i..i];
    }
  }
  if (sizeof(liv)) {
    blue = liv[random(sizeof(liv))];
    tell_room(environment(),
              the_short() + " urinates on " + blue->the_short() + "'s leg.\n",
              ({ blue }));
    tell_object(blue, capitalize(the_short()) + " urinates on your leg.\n");
    blue->add_effect("/std/effects/other/dog_urinate", 120);
  }
}
void i_like_them(object them) {
  if(!them || environment() != environment(them))
    return ;
  call_out("i_like_them", 60+random(240), them);
  if (query_property("excited")) {
    do_command("bounce excit");
  } else switch (random(5)) {
    case 0 :
      do_command("nuzzle "+them->query_name());
      break;
    case 1 :
      do_command("stare pitifully at "+them->query_name());
      break;
    case 2 :
      do_command("smile "+them->query_name());
      break;
    case 3 :
      do_command("eye "+them->query_name());
      break;
    case 4 :
      do_command("drool "+them->query_name());
      break;
  }
}
void pat_me(object per) {
  object ob;
  ob = query_property("following");
  if (objectp(ob) &&
      environment(ob) == environment()) {
    init_command("nuzzle "+per->query_name());
  } else if (environment() == environment(per) &&
   (query_property("monster type") == "small dog" ||
   !random(5))) {
    init_command("follow "+per->query_name());
    init_command("protect "+per->query_name());
    add_property("following", per);
    call_out("i_like_them", 60+random(240), per);
  } else {
    init_command("ignore "+per->query_name());
  }
}
void periodic_excited() {
  if (query_property("excited")) {
    if (query_property("excited") > 1) {
      switch (random(4)) {
        case 0 :
          do_command("growl");
          break;
        case 1 :
          do_command("bark");
          break;
        case 2 :
          do_command("caper");
          break;
        case 3 :
          do_command("bounce excit");
          break;
      }
    } else if (!random(2))
      do_command("bounce excit");
    else
      do_command("caper");
    call_out("periodic_excited", 10+random(10));
  }
}
void sic_em(object per, string mess) {
   string *bing;
   object mine;
   object *obs;
   int lvl;
   bing = explode(replace(mess, "!", ""), " ");
   mine = query_property("following");
   if (bing[0] == "get" && per == mine) {
      obs = match_objects_for_existence(bing[1], environment());
      obs = filter_array(obs, (: living($1) :));
      if ( sizeof( obs ) ) {
	 lvl = query_property( "excited" );
	 add_property( "excited", lvl+1 );
	 call_out( function( object npc ) {
	    int lvl;
	    lvl = npc->query_property("excited");
	    if (lvl > 0)
	       npc->add_property("excited", lvl - 1);
	    else
	       npc->remove_property("excited");
	 }, 120, this_object());
	 if (!lvl) {
	    call_out("periodic_excited", 10+random(10));
	 }
	 switch (lvl) {
	  case 0 :
	    init_command("bounce excit");
	    break;
	  case 1 :
	    init_command("growl "+obs[0]->query_name());
	    break;
	  default :
	    call_out((: attack_ob($2) :), 0, obs[0]);
	    break;
	 }
      }
   }
}

==================================================
FILE: dist/pumpkin/chars/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/fruitbat/fruitbat1.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Fruitbat Avenue");
  set_long("This is Fruitbat Avenue at the junction with Crumpet Circle.\n");
  set_light( 80 );
  add_exit("east", FRUITBAT + "fruitbat2", "road");
  add_exit("north", CRUMPT + "crumpt8", "road");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/fruitbat/fruitbat2.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Fruitbat Avenue");
  set_long("This is the middle of Fruitbat Avenue just west of "
           "Crumpt Circle.\n");
  set_light( 80 );
  add_exit("east", FRUITBAT + "fruitbat3", "road");
  add_exit("west", FRUITBAT + "fruitbat1", "road");
  add_exit("south", FRUITBAT + "general_store", "door");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/fruitbat/fruitbat3.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Fruitbat Avenue");
  set_long("This is the middle of Fruitbat Avenue just south of the "
           "vault.\n");
  set_light( 80 );
  add_exit("east", FRUITBAT + "fruitbat4", "road");
  add_exit("west", FRUITBAT + "fruitbat2", "road");
  add_exit("north", FRUITBAT + "walrus_vault_entry", "door");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/fruitbat/fruitbat4.c
==================================================

#include "path.h";
inherit CITYROOM;
void setup() {
  set_short("Fruitbat Avenue");
  set_long("This is east end of Fruitbat Avenue at the junction "
           "with Squash Square.\n");
  set_light( 80 );
  add_exit("east", SQUASH + "squash4", "road");
  add_exit("west", FRUITBAT + "fruitbat3", "road");
  set_monster(1, "city");
}

==================================================
FILE: dist/pumpkin/fruitbat/general_store.c
==================================================

#include "path.h"
inherit "/std/shops/general_shop";
void setup() {
   set_short("Elephant's Stamp");
   set_long(
"A huge picture of an elephant covers tha back room of the shop.  You can "
"see the elephant guarding a huge pile of goods.\n");
   add_exit("north", FRUITBAT + "fruitbat2", "door");
   set_light(70);
   set_store_room(FRUITBAT + "storeroom");
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/fruitbat/path.h
==================================================

#include "../path.h"
#undef PATH
#define PATH __DIR__

==================================================
FILE: dist/pumpkin/fruitbat/storeroom.c
==================================================

inherit "/std/shops/storeroom";
void setup() {
   set_short("Elephant's Storeroom");
   set_light(70);
   set_long("Lots of stored stuff.\n");
 }

==================================================
FILE: dist/pumpkin/fruitbat/walrus_vault.c
==================================================

#include "path.h"
inherit "/std/shops/vault";
void setup() {
   set_short("Wulrus's vault");
   set_long(
"A big picture of a nice friendly looking walrus looks down on you "
"with a nice happy smile.\n");
   set_light(70);
   set_vault_name("walrus");
   set_vault_exit("south", FRUITBAT + "walrus_vault_entry", "door");
   add_property("place", "Pumpkin");
}

==================================================
FILE: dist/pumpkin/fruitbat/walrus_vault_entry.c
==================================================

#include "path.h"
inherit "/std/shops/vault_entry";
object _npc;
void setup() {
   set_short("Wulrus's vault");
   set_long(
"A big picture of a nice friendly looking walrus looks down on you "
"with a nice happy smile.\n");
   set_light(70);
   set_vault_name("walrus");
   set_visit_cost(400);
   set_open_cost(4000);
   add_exit("south", FRUITBAT + "fruitbat3", "door");
   set_vault_exit("north", FRUITBAT + "walrus_vault", "door");
   add_property("place", "Pumpkin");
}
void reset() {
   set_proprietor(_npc);
}

==================================================
FILE: admin/common.c
==================================================

#include <config.h>
#define DOM_TITLE "the domain of admin"
#define LORD "pinkfish"
#define DOMAIN "admin"
inherit "/std/dom/cmn_mas";
object board;
void setup() {
  set_dom(DOMAIN);
  set_light(100);
  add_exit("drum", CONFIG_START_ROOM, "door");
  modify_exit( "drum", ({ "one way", 1 }) );
  set_short("Common room of "+DOM_TITLE);
  set_long("Large relaxing chairs adorn the room.  The walls are covered "+
           "with strange motifs from different lands and the little shelf "+
           "above the fireplace is chocker block full of strange figurines "+
           "and bits of cloth.  It appears to be the common room of "+
           DOM_TITLE+" the large red letters on the wall were the " +
           "give away.\n");
  add_alias("chairs", "chair");
  add_alias("cloths", "cloth");
  add_alias("motifs", "motif");
  add_alias("figurines", "figurine");
  add_item("chair", "The chairs are lazing around the room relaxing it looks "+
                    "like they come here after a hard days working in "+
                    DOM_TITLE+".\n");
  add_item("fireplace", "A nice little fire place with a cheery fire burning "+
                        "in it keeping every one warm.\n");
  add_item("figurine", "Small figurines, they look strangely familiar "+
                         "until you realise they are the members of "+
                         DOM_TITLE+".\n");
  add_item("cloth", "Strange coloured bits of cloth strewn over the "+
                    "mantlepice for no readily apparent reason.\n");
  add_item("motif", "The motifs on close inspection look like stylised "+
                     "signatures of all the members of "+DOM_TITLE+
                     ".  Some of them are very strange, in fact there "+
                     "seem to be more than there are members of the house.  "+
                     "perhaps it is the members of the future.\n");
  add_item("shelf", "A nice normal sort of shelf thing.  It is like all "+
                    "those ones you see in houses all over the place, "+
                    "execpt... the way it has been burnt... hmm it does "+
                    "not look like the fire did it.\n");
  add_item("fire", "There is a fire happily burning away in the fireplace "+
                   "spluttering and crackling to itself.  The flames almost "+
                   "seem afraid of something.  Looking closer you notice a "+
                   "picture tacked to the side of the fire place.\n");
  add_item("picture", "Tacked to the inside wall of the fire thingy, you "+
                      "know the hole bit at the bottom, is a small picture "+
                      "it looks like it was taken with the best of demon "+
                      "photography.  It is a picture of a person holding "+
                      "a small staff, you think it might be "+LORD+
                      " but you are not sure as the fire light sparkles "+
                      "in your eyes.\n");
  board = clone_object("/obj/misc/board");
  board->set_datafile(DOMAIN);
  board->move(this_object());
}

==================================================
FILE: admin/master.c
==================================================

#define LORD "pinkfish"
#define DOMAIN "admin"
#define LOGS "/d/admin/log/"
#define BACKUP_COUNT 9
inherit "/std/dom/base_master";
void create() {
   string file;
   int i;
   ::create();
   foreach ( file in unguarded( (: get_dir, LOGS +"*.log" :) ) ) {
     if( ( unguarded( (: file_size, LOGS + file :) ) > 1024000) ||
         ( file != "ENTER.log" &&
           unguarded( (: file_size, LOGS + file :) ) > 64000 ) ) {
       file = explode( file, "." )[ 0 ];
       if(file_size(LOGS+file+"."+BACKUP_COUNT) > 0)
         unguarded( (: rm, LOGS + file +"."+ BACKUP_COUNT :) );
       for(i=(BACKUP_COUNT-1); i>0; i--)
         if(file_size(LOGS+file+"."+i) > 0)
           unguarded( (: rename, LOGS+file+"."+i, LOGS+file+"."+(i+1) :) );
       unguarded( (: rename, LOGS+file+".log", LOGS+file+"."+"1" :) );
     }
   }
}
string query_lord() {
  return LORD;
}
string author_file(string *path) {
  return capitalize(DOMAIN);
}
int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}
int valid_read(string *path, string euid, string funct);
int valid_write(string *path, string euid, string funct);
int add_member(string name) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::add_member(name);
}
int remove_member(string name) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::remove_member(name);
}
int set_project(string name, string pro) {
  if (geteuid(this_player(1)) != query_lord())
    return 0;
  return ::set_project(name, pro);
}
int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
}
string log_who(string where) {
  return LORD;
}
string query_info() {
  return "\nThe admin domain is made up of the active Trustees of "
    "Discworld.  Their role is to ensure the smooth running of the game.  "
    "They carry the ultimate responsibility for Discworld, how it operates "
    "and its policies and rules.\n\n";
}

==================================================
FILE: admin/room/access_control.c
==================================================

#include <access.h>
#include "path.h"
inherit "/std/room/basic_room";
#define LOGIN "/secure/login"
#define READ_MASK 1
#define WRITE_MASK 2
#define GRANT_MASK 4
#define LOCK_MASK 8
int do_read(string euid, string path);
int do_write(string euid, string path);
int do_grant(string euid, string path);
int do_lock(string path);
int do_noread(string euid, string path);
int do_nowrite(string euid, string path);
int do_nogrant(string euid, string path);
int do_unlock(string path);
int do_summary(string str);
int do_tidy();
void setup() {
  set_light(100);
  set_short("file-access control room");
  add_property("determinate", "the ");
  set_long(
    "You are in a room full of filing cabinets.  There are filing "
    "cabinets everywhere, they are all packed full of papers and look "
    "in a horrible mess.\n"
"Available commands:\n"
"  read    <euid> <path>     : add read permission to the path.\n"
"  write   <euid> <path>     : add write permission to the path.\n"
"  grant   <euid> <path>     : add granting privileges to the path.\n"
"  lock           <path>     : restrict access to the path.\n"
"  noread  <euid> <path>     : remove read permission from the path.\n"
"  nowrite <euid> <path>     : remove write permission from the path.\n"
"  nogrant <euid> <path>     : remove granting privileges to the path.\n"
"  unlock         <path>     : remove restrictions to path.\n"
"  summary [path|euid]       : give a list of all the read/write perms.\n"
"  tidy                      : tidy away unnecessary perms.\n" );
  add_exit("east", ROOM+"domain_control", "corridor");
}
void init() {
  ::init();
  this_player()->add_command("read",    this_object(),
    "<string'euid'> <string'path'>", (: do_read($4[0], $4[1]) :) );
  this_player()->add_command("write",   this_object(),
    "<string'euid'> <string'path'>", (: do_write($4[0], $4[1]) :) );
  this_player()->add_command("grant",   this_object(),
    "<string'euid'> <string'path'>", (: do_grant($4[0], $4[1]) :) );
  this_player()->add_command("lock",    this_object(),
    "<string'path'>",                (: do_lock($4[0]) :) );
  this_player()->add_command("noread",  this_object(),
    "<string'euid'> <string'path'>", (: do_noread($4[0], $4[1]) :) );
  this_player()->add_command("nowrite", this_object(),
    "<string'euid'> <string'path'>", (: do_nowrite($4[0], $4[1]) :) );
  this_player()->add_command("nogrant", this_object(),
    "<string'euid'> <string'path'>", (: do_nogrant($4[0], $4[1]) :) );
  this_player()->add_command("unlock",  this_object(),
    "<string'path'>",                (: do_unlock($4[0]) :) );
  this_player()->add_command("summary", this_object(),
    "<string'path or euid'>",        (: do_summary($4[0]) :) );
  this_player()->add_command("tidy",    this_object(),
    "",                              (: do_tidy() :) );
}
int do_read(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_read("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call do_read("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, READ_MASK)) {
    notify_fail("You do not have permission to add read access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->add_read_permission(euid, path);
}
int do_write(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_write("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call do_write("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, WRITE_MASK)) {
    notify_fail("You do not have permission to add write access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->add_write_permission(euid, path);
}
int do_grant(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_grant("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call do_grant("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, GRANT_MASK)) {
    notify_fail("You do not have permission to add grant access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->add_grant_permission(euid, path);
}
int do_lock(string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_lock("+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call do_lock("+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (!path)
    return notify_fail("Syntax: "+query_verb()+" <path>\n");
  if (!master()->query_lord(previous_object(-1)))
    return notify_fail("You don't have permission to lock paths.\n");
  if ((path[0..2] != "/d/") &&
      !master()->high_programmer(previous_object(-1)))
    return notify_fail("You don't have permission to lock paths there.\n");
  notify_fail("Something went wrong.\n");
  return (int)master()->lock_path(path);
}
int do_noread(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_noread("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call do_noread("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, READ_MASK)) {
    notify_fail("You do not have permission to remove read access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->remove_read_permission(euid, path);
}
int do_nowrite(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_nowrite("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
                 "to call do_nowrite("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, WRITE_MASK)) {
    notify_fail("You do not have permission to remove write access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->remove_write_permission(euid, path);
}
int do_nogrant(string euid, string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_nogrant("+euid+", "+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call do_nogrant("+euid+", "+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  path = (string)this_player()->get_path(path);
  if (!master()->high_programmer(previous_object(-1)) &&
      !master()->valid_grant(previous_object(), path, GRANT_MASK)) {
    notify_fail("You do not have permission to remove grant access.\n");
    return 0;
  }
  notify_fail("Something went wrong.\n");
  return (int)master()->remove_grant_permission(euid, path);
}
int do_unlock(string path) {
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    event(users(), "inform", "Illegal attempt to call do_unlock("+path+") by "+
          this_player()->one_short(), "cheat");
    unguarded((: write_file, "/log/CHEAT", ctime(time())+": Illegal attempt "
               "to call do_unlock("+path+").\nBacktrace: "+ back_trace() :));
    return 0;
  }
  if (!path)
    return notify_fail("Syntax: "+query_verb()+" <path>\n");
  if (!master()->query_lord(previous_object(-1)))
    return notify_fail("You don't have permission to lock paths.\n");
  if ((path[0..2] != "/d/") &&
      !master()->high_programmer(previous_object(-1)))
    return notify_fail("You don't have permission to lock paths there.\n");
  notify_fail("Something went wrong.\n");
  return (int)master()->unlock_path(path);
}
int list_before( string first, string second ) {
   if ( first < second )
      return -1;
   if ( first > second )
      return 1;
   return 0;
}
int do_summary(string str) {
  mapping perms;
  string *paths, *euids, ret, creator;
  int i, j, k;
  perms = (mapping)master()->query_permissions();
  if (str) {
    if (!perms[str]) {
      if (!LOGIN->test_user(str) && !master()->valid_euid(str)) {
        write("There are no permissions for "+str+".\n");
        return 1;
      } else {
        creator = str;
      }
    } else {
      perms = ([ str : perms[str] ]);
    }
  }
  paths = sort_array( m_indices( perms ), "list_before", this_object() );
  if (!sizeof(paths))
    ret = "No permissions set.\n";
  else
    ret = sprintf("%11-s    Path\n", "Euid");
  for (i=0;i<sizeof(paths);i++) {
    euids = m_indices(perms[paths[i]]);
    for (j=0;j<sizeof(euids);j++) {
      if (!creator || (euids[j] == creator ) ) {
        k = perms[paths[i]][euids[j]];
        if (k & LOCK_MASK)
          ret += sprintf("%11-s LCK %s\n", euids[j], paths[i]);
        else
          ret += sprintf("%11-s %c%c%c %s\n", euids[j],(k & READ_MASK?'R':' '),
                         (k & WRITE_MASK?'W':' '), (k & GRANT_MASK?'G':' '),
                         paths[i]);
      }
    }
  }
  this_player()->more_string( ret, "Permissions", 1 );
  return 1;
}
int do_tidy() {
   int i, j, perm, same;
   string path, creator, *bits;
   mapping perms, euids, others;
   if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
      event( users(), "inform", "illegal attempt to call do_tidy() by "+
            (string)this_player()->query_name(), "cheat" );
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +": illegal "
                   "attempt to call do_tidy() by "+
                   (string)this_player()->query_name() +"\n" :));
      return notify_fail( "Failed.\n" );
   }
   perms = (mapping)master()->query_permissions();
   foreach( path in keys( perms ) ) {
      euids = perms[ path ];
      foreach( creator in keys( euids ) ) {
         perm = euids[ creator ];
         if ( !LOGIN->test_creator( creator ) &&
              !master()->valid_euid( creator ) ) {
            write( "No creator: "+ creator +".\n" );
            if ( perm & READ_MASK )
               master()->remove_read_permission( creator, path );
            if ( perm & WRITE_MASK )
               master()->remove_write_permission( creator, path );
            if ( perm & GRANT_MASK )
               master()->remove_grant_permission( creator, path );
            continue;
         }
         if ( path == "/" )
            continue;
         same = perms[ "/" ][ creator ] & perm;
         if ( same ) {
            write( "Access to / supercedes "+ path +" for "+ creator +".\n" );
            if ( same & READ_MASK )
               master()->remove_read_permission( creator, path );
            if ( same & WRITE_MASK )
               master()->remove_write_permission( creator, path );
            if ( same & GRANT_MASK )
               master()->remove_grant_permission( creator, path );
            continue;
         }
         bits = explode( path, "/" );
         j = sizeof( bits ) - 1;
         for ( i = 0; i < j; i++ ) {
            others = perms[ "/"+ implode( bits[ 0 .. i ], "/" ) ];
            if ( !others )
               continue;
            same = others[ creator ] & perm;
            if ( same ) {
               write( "Access to /"+ implode( bits[ 0 .. i ], "/" ) +
                     " supercedes "+ path +" for "+ creator +".\n" );
               if ( same & READ_MASK )
                  master()->remove_read_permission( creator, path );
               if ( same & WRITE_MASK )
                  master()->remove_write_permission( creator, path );
               if ( same & GRANT_MASK )
                  master()->remove_grant_permission( creator, path );
               break;
            }
         }
      }
   }
   return 1;
}

==================================================
FILE: admin/room/cloner_control.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
#define CLONER "/global/cloner"
int do_add(string from, string to);
int do_remove(string from);
int do_list(string matching);
void setup() {
  set_light(100);
  set_short("Cloner Room");
  set_long("This room is used to look at or add filename mappings for the "+
     "cloner object.  It's a very, very, very, very boring room.\n\n"+
     "  add <from> <to> - adds a mapping.\n"+
     "  remove <from> - removes a mapping.\n"+
     "  list [str] - lists mappings which contain the optional string "+
     "str.\n");
  add_exit("southwest" , ROOM+"development" , "door");
}
void init() {
  ::init();
  if (!this_player()) return;
  this_player()->add_command("add", this_object(),
    "<string:small'from object'> <string:small'to object'>",
    (: do_add($4[0], $4[1]) :)
    );
  this_player()->add_command("remove", this_object(),
    "<string:small'from object'>",
    (: do_remove($4[0]) :)
    );
  this_player()->add_command("list", this_object(),
    "<string:small'matching'>",
    (: do_list($4[0]) :)
    );
  this_player()->add_command("list", this_object(),
    "",
    (: do_list("") :)
    );
}
int do_add(string from, string to) {
  CLONER->add_mapping(from, to);
  return 1;
}
int do_remove(string str) {
  CLONER->remove_mapping(str);
  return 1;
}
int do_list(string from) {
  this_player()->more_string(CLONER->list_mappings(from));
  return 1;
}

==================================================
FILE: admin/room/development.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
object board;
void reset() {
  if(!board) {
    board = clone_object("obj/misc/board");
    board->set_datafile("development");
    board->move(this_object());
  }
}
void setup() {
  set_light(80);
  set_short("Mud Development Office");
  set_long(
    "You are in the Development Office of the mud. Maps and charts of the "+
    "world adorn the panelled walls. Forms sit on a table near the door "+
    "for registration of new projects. A few bored looking clerks rustle "+
    "some papers and try to look busy.\n");
  add_item("clerk", "They seem more interested in coffee than work.\n");
  add_item("map", "Type 'list' to see available maps, and 'read' to look "+
           "at one.\n");
  add_exit("west", "w/common", "door");
  add_exit("east", ROOM+"quest_room", "door");
  add_exit("north", ROOM+"mail_room", "door");
  add_exit("south", ROOM+"domain_control", "corridor");
  add_exit("northeast", ROOM+"cloner_control", "door");
   add_exit( "southeast", ROOM +"terrain", "door" );
}
void dest_me() {
  if (board)
    board->dest_me();
  ::dest_me();
}

==================================================
FILE: admin/room/domain_control.c
==================================================

#include "access.h"
#include "path.h"
inherit "/std/room/basic_room";
#define MASTER "/secure/master"
int do_list(string arg);
int do_create(string dom, string lord);
int do_list_all();
int do_deputy(string cre, string dom);
int do_undeputy(string cre, string dom);
int do_create(string dom, string lord);
int do_project(string cre, string dom, string project);
int do_add(string cre, string dom);
int do_delete(string cre, string dom);
void setup() {
  set_light(100);
  set_short("domain-control room");
  add_property("determinate", "the ");
  set_long("You float in nothingness, before a vast turtle, its shell pocked "
    "by asteroid craters. In all directions stars twinkle in the black "
    "curtain of space.\n"
"Available commands:\n"
"  list                         : list all domains.\n"
"  list <domain>                : list members of a domain.\n"
"  create <domain>              : create a domain (you are lord).\n"
"  create <domain> <lord>       : create a domain for someone else.\n"
"  add <creator> <domain>       : add a creator to a domain you own.\n"
"  delete <creator> <domain>    : remove a creator from a domain you own.\n"
"  project <cre> <dom> <proj>   : Set the creators project.\n"
"  deputy <cre> <dom>           : Appoint creator as a deputy.\n"
"  undeputy <cre> <dom>         : Remove creator as a deputy.\n"
);
  add_item("turtle", "On its back you can see four elephants, and they bear " +
    "the weight of the disc upon their wide backs.\n");
  add_item("elephants", "The four great elephants labour endlessly in the " +
    "task of turning the disc upon their backs.\n");
  add_item("disc", "The whole discworld, from hub to rim, rides upon the " +
    "elephant's backs.\n");
  add_alias("elephant", "elephants");
  add_exit("north", ROOM+"development", "corridor");
  add_exit("south", ROOM+"site_control", "corridor");
  add_exit("west", ROOM+"access_control", "corridor");
  seteuid("Admin");
}
void init() {
  ::init();
  add_command("list", "", (: do_list_all() :) );
  add_command("list", "<word>", (: do_list($4[0]) :) );
  add_command("create", "<word>", (: do_create($4[0], 0) :) );
  add_command("create", "<word> <word>", (: do_create($4[0], $4[1]) :) );
  add_command("add", "<word> <word>", (: do_add($4[0], $4[1]) :) );
  add_command("delete", "<word> <word>", (: do_delete($4[0], $4[1]) :) );
  add_command("project", "<word> <word> <string>",
                         (: do_project($4[0], $4[1], $4[2]) :) );
  add_command("deputy", "<word> <word>", (: do_deputy($4[0], $4[1]) :) );
  add_command("undeputy", "<word> <word>", (: do_undeputy($4[0], $4[1]) :) );
}
int do_list_all() {
  int i, num;
  string *members, *domains, mast;
  if (this_player() != this_player(1))
    return 0;
  domains = "/secure/master"->query_domains();
  if(!sizeof(domains)) {
    notify_fail("No domains exist.\n");
    return 0;
  }
  write("Current domains:\n");
  for(i=0; i<sizeof(domains); i++) {
    mast = "/d/" + domains[i] + "/master";
    members = (string *)mast->query_members();
    printf( "%15s has %2d %-7s and is owned by %s.\n", domains[ i ],
      num = sizeof( (string *)mast->query_members() ),
      ( ( num == 1 ) ? "member" : "members" ),
      capitalize( (string)mast->query_lord() ) );
  }
  return 1;
}
int do_list(string arg) {
  int i, cols;
  string *members, *domains, mast;
  if (this_player() != this_player(1))
    return 0;
  domains = "/secure/master"->query_domains();
  if(!sizeof(domains)) {
    notify_fail("No domains exist.\n");
    return 0;
  }
  if(member_array(arg, domains) == -1) {
    notify_fail("No such domain as " + arg + ".\n");
    return 0;
  } else {
    mast = "/d/" + arg + "/master";
    write(capitalize((string)mast->query_lord()) + " is the lord of " +
      arg + ".\nMembers         Project\n");
    members = (string *)mast->query_members();
    cols = (int)this_player()->query_cols();
    for (i=0;i<sizeof(members);i++)
      printf("%-15s %*-=s\n", members[i], cols-16,
                             mast->query_project(members[i]) +
             (mast->query_deputy(members[i])?" (deputy)":""));
  }
  return 1;
}
int do_create(string dom, string lord) {
  if (this_player() != this_player(1))
    return 0;
  if(!MASTER->high_programmer(geteuid(previous_object()))) {
    notify_fail("You lack the Power of Change on this scale!\n");
    return 0;
  }
  if (!lord) {
    lord = (string)this_player()->query_name();
  }
  if (!MASTER->create_domain(dom, lord)) {
    notify_fail("Failed to create domain " + dom + " with the lord " + lord
                + ".\n");
    return 0;
  }
  write("You create the domain " + dom + " with " + capitalize(lord) +
    " as its lord.\n");
  return 1;
}
int do_add(string cre, string dom) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "/d/" + dom + "/master";
  if (!mast->add_member(cre)) {
    notify_fail("Failed to add " + capitalize(cre) + " to domain " +
      dom + ".\n");
    return 0;
  }
  write("Creator " + capitalize(cre) + " now added to domain " + dom + ".\n");
  return 1;
}
int do_delete(string cre, string dom) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "d/" + dom + "/master";
  if (!mast->remove_member(cre)) {
    notify_fail("Failed to remove " + capitalize(cre) + " from domain " +
       dom + "\n");
    return 0;
  }
  write("Member " + capitalize(cre) + " removed from domain " + dom + ".\n");
  return 1;
}
int do_project(string cre, string dom, string project) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "/d/" + dom + "/master";
  if (!mast->set_project(cre, project)) {
    notify_fail("Failed to set the project " + project + " for " +
                capitalize(cre) + " in the domain " + dom + "\n");
    return 0;
  }
  write("Project for " + capitalize(cre) + " set to " + project +
        " in the domain " + dom + ".\n");
  return 1;
}
int do_deputy(string cre, string dom) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "d/" + dom + "/master";
  if (!mast->add_deputy(cre)) {
    notify_fail("Failed to add the deputy " +
                capitalize(cre) + " to the domain " + dom + "\n");
    return 0;
  }
  write("Deputy " + capitalize(cre) + " added to "
        "the domain " + dom + ".\n");
  return 1;
}
int do_undeputy(string cre, string dom) {
  string mast;
  if (this_player() != this_player(1))
    return 0;
  if(file_size("/d/" + dom) != -2) {
    notify_fail("No such domain as " + dom + ".\n");
    return 0;
  }
  cre = (string)this_player()->expand_nickname(cre);
  mast = "d/" + dom + "/master";
  if (!mast->remove_deputy(cre)) {
    notify_fail("Failed to remove the deputy " +
                capitalize(cre) + " from the domain " + dom + "\n");
    return 0;
  }
  write("Deputy " + capitalize(cre) + " removed from "
        "the domain " + dom + ".\n");
  return 1;
}

==================================================
FILE: admin/room/mail_room.c
==================================================

inherit "/std/room/basic_room";
#include "path.h"
#include <mail.h>
#define NAME (string)this_player()->query_name()
#define HIGHLORD() (master()->high_programmer(NAME))
int do_add(string list, string name);
varargs int do_list(string str);
int do_create(string str);
int do_remove(string list, string names);
void setup() {
  set_short("Mail control room");
  set_long(
"This is the mail control room.  You can see several frogs hopping around "
"looking important, sorting mail into nice little boxes, putting them in "
"their backpacks and hopping off into the distance.  Over to the west of "
"the room is a small control panel, with odd levers and lots of strange "
"buttons.\n");
  set_light(100);
  add_exit("south", ROOM + "development", "door");
  add_item("important looking post office frog",
           "They are rushing around in a seemless unending hurry.  They are "
           "all wearing nice little hats that have the post office symbol on "
           "them.");
  add_item("box",
           "There are several nice boxes around the room.  They all appear "
           "to be labeled in some arcane script.  If you squint at them they "
           "form interesting patterns.");
  add_item("backpack",
           "Every frog has its own backback.  Some are full, some are empty, "
           "but they all have them.  The regulation backback is about big "
           "enough to contain over a hundred letters.  Some of them look "
           "battered and worn as if they have seen many years of service.");
  add_item("control panel",
           "It is covered with odd levers and buttons.  Some of them are "
           "labeled in a readable script.  They are \"add\", \"list\", "
           "\"listcreate\" and \"remove\".");
}
void init() {
  ::init();
  if (!this_player()) return;
  this_player()->add_command(
    "add", this_object(),
    "<string:small'list'> <string:long'names'>",
    (: do_add($4[0], $4[1]) :) );
  this_player()->add_command(
    "list", this_object(),
    "<string:small'list'>",
    (: do_list($4[0]) :) );
  this_player()->add_command(
    "list", this_object(),
    "",
    (: do_list() :) );
  this_player()->add_command(
    "remove", this_object(),
    "<string:small'list'> <string:long'names'>",
    (: do_remove($4[0], $4[1]) :) );
  this_player()->add_command(
    "listcreate", this_object(),
    "<string:small'list'>",
    (: do_create($4[0]) :) );
}
int do_add(string list, string name) {
  string *names;
  if (!MAIL_TRACK->query_list(list)) {
    notify_fail("The mailing list \"" + list + "\" does not exist.\n");
    return 0;
  }
  if (!(MAIL_TRACK->query_controller(list, NAME) || HIGHLORD())) {
    notify_fail("You have to be a controller of a list to be able to add a "
                "member.\n");
    return 0;
  }
  names = explode(replace(lower_case(name), " ", ","), ",") - ({ "" });
  if (!sizeof(names)) {
    notify_fail("It helps if you tell me who to add.\n");
    return 0;
  }
  foreach (name in names) {
    if (name[0] == '*') {
      name = name[1..];
      if (!"/secure/login"->test_user(name)) {
        write("The player \"" + name + "\" does not exist.\n");
      } else if (MAIL_TRACK->add_controller(list, name)) {
        write("Added " + name + " as a controller of \"" + list + "\".\n");
      } else {
        write("Failed to add " + name + " as a controller of \"" +
              list + "\".\n");
      }
    } else if (!"/secure/login"->test_user(name) &&
               !MAIL_TRACK->query_list(name)) {
      write("The player \"" + name + "\" does not exist.\n");
    } else if (MAIL_TRACK->add_member(list, name)) {
      write("Added " + name + " to the mailing list.\n");
    } else {
      write("Failed to add " + name + " to the mailing list.\n");
    }
  }
  return 1;
}
varargs int do_list(string str) {
  string *strs, *cont, creator;
  if (!str) {
    strs = MAIL_TRACK->query_mailing_lists();
    write("$I$5=Current mailing lists: " + query_multiple_short(strs) + ".\n");
  } else {
    strs = MAIL_TRACK->query_members(str);
    cont = MAIL_TRACK->query_controllers(str);
    if (!sizeof(strs)) {
      notify_fail("The mailing list \""+str+"\" does not exist.\n");
      return 0;
    }
    if ((creator = MAIL_TRACK->query_creator(str))) {
      write("The list \"" + str + "\" was created by " + creator + ".\n");
    }
    if (sizeof(cont)) {
      write("$I$5=Controllers of list \"" + str + "\": " +
            query_multiple_short(cont) + ".\n");
    }
    write("$I$5=Members of list \"" + str + "\": " +
          query_multiple_short(strs) + ".\n");
  }
  return 1;
}
int do_remove(string list, string name) {
  string *names;
  if (!MAIL_TRACK->query_list(list)) {
    notify_fail("The mailing list \""+list+"\" does not exist.\n");
    return 0;
  }
  if (!(MAIL_TRACK->query_controller(list, NAME) || HIGHLORD())) {
    notify_fail("You have to be a controller of a list to be able to "+
                "remove a member.\n");
    return 0;
  }
  names = explode(replace(lower_case(name), " ", ","), ",") - ({ "" });
  if (!sizeof(names)) {
    notify_fail("It helps if you tell me who to remove.\n");
    return 0;
  }
  foreach (name in names) {
    if (name[0] == '*') {
      name = name[1..];
      if (MAIL_TRACK->remove_controller(list, name)) {
        write("Removed " + name + " as a controller of \"" + list + "\".\n");
      } else {
        write("Failed to remove " + name + " as a controller of \"" +
              list + "\".\n");
      }
    } else if (MAIL_TRACK->query_controller(list, name) && (name != NAME)) {
      write("Could not remove " + name + ", because " + name + " is a "
            "controller of \"" + list + "\".\n");
    } else if (MAIL_TRACK->remove_member(list, name)) {
      write("Removed " + name + " from the mailing list.\n");
    } else {
      write("Could not remove " + name + " from the mailing list.\n");
    }
  }
  return 1;
}
int do_create(string str) {
  if (MAIL_TRACK->query_list(str)) {
    notify_fail("The list \"" + str + "\" already exists.\n");
    return 0;
  }
  if (sscanf(str, "%*s %*s") == 2 || sscanf(str, "%*s,%*s")) {
    notify_fail("The mailing list name cannot have spaces or commas in it.\n");
    return 0;
  }
  if (MAIL_TRACK->create_list(str, this_player()->query_name())) {
    write("Created the mailing list \""+str+"\".\n");
    return 1;
  }
  notify_fail("Failed to create the mailing list.\n");
  return 0;
}

==================================================
FILE: admin/room/meeting.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
object floor, sign;
string log_bing, chair;
void setup() {
  set_short("Meeting room");
  set_long(
"A large oak table dominates this room.  There are some heavy ornate "+
"looking candle sticks in the center of the table.  The table is "+
"sourounded by large expensive looking teak chairs, at one end of the "+
"table are some larger more expensive looking ones.  There is a small "+
"hammer sitting in the middle of the room.  You can see a small sign on "+
"the wall.\n");
  set_light(70);
  add_item("oak table",
           "A large heavy looking oak table.  It was built to last. "+
           "It looks very old, you can tell by all the worn marks "+
           "at the places around the table where people sit.\n");
  add_item("teak chair",
           "The chairs are overly ornate and obviously in a very good "+
           "condition for their age.  The large chairs at the end are "+
           "obviously not well used (you can tell, all the dust).\n");
  add_item("candle stick",
           "The candle sticks are made of silver, however if you try "+
           "and take them, you notice they are attached to the table "+
           "somehow.  The candles seemed to have been carved into the "+
           "shape of a small chicken holding a torch.\n");
  add_item(({ "hammer", "gavel" }),
           "The gavel looks like ones fo those things so common in "+
           "meeting rooms.  You could bang it around a little maybe, "+
           "it might help if you had it though.\n");
  log_bing = 0;
  sign = add_sign("A small sign with not much written on it.\n",
                  "There is no current chair of the meeting.\n");
}
void reset() {
  if (floor)
    return ;
  floor = clone_object("/std/object");
  floor->set_name("floor");
  floor->set_short( "floor" );
  floor->add_property( "determinate", "the " );
  floor->set_long(
"This is the floor of the meeting.  It gives you the right to speak "+
"during the meeting.  Please give this to the next person to speak "+
"after you have finished.\n");
  floor->move(this_object());
}
void init() {
  string str;
  ::init();
  str = previous_object()->query_name();
  if (interactive(previous_object()) && (previous_object()->query_lord()
      || str == chair)) {
    add_action("appoint", "appoint");
    add_action("bang", "bang");
    add_action("recover", "recover");
    add_action("do_log", "log");
  }
}
int appoint(string str) {
  object ob;
  if (chair && (string)this_player()->query_name() != chair) {
    notify_fail("The chair has already been apointed.\n");
    return 0;
  }
  if (!(ob = find_player(str))) {
    notify_fail("Sorry, cannot find "+str+" to be the chair.\n");
    return 0;
  }
  chair = str;
  say(this_player()->one_short()+" just appointed "+str+" as the "+
        "chair of the meeting.\n", ob);
  write("Ok, "+str+" is now the chair of the meeting.\n");
  tell_object(ob, this_player()->one_short()+
        " just appointed you the chair of the meeting.\n");
  if (environment(ob) == this_object())
    ob->move(this_object());
  sign->set_read_mess("The chair of the meeting is "+str+".\n");
  return 1;
}
int bang(string str) {
  if ((string)this_player()->query_name() != chair) {
    notify_fail("Only the chair can bang the gavel.\n");
    return 0;
  }
  tell_room(this_object(),
            this_player()->one_short()+" bangs the gavel loudly.  STOP "+
            "STOP!\n");
  return 1;
}
int recover() {
  if (!floor)
    reset();
  floor->move(this_player());
  write("Floor recovered.\n");
  say(this_player()->one_short()+" has recovered the floor.\n");
  return 1;
}
int do_log(string str) {
  if (log_bing && !str) {
    write("Stopped logging.\n");
    log_bing = str;
    return 1;
  }
  if (!str) {
    notify_fail("Syntax: log <file_name>\n"+
                "        log by itself to stop logging.\n");
    return 0;
  }
  if (log_bing)
    write("Stopped loggin to "+log_bing+" and started logging to "+str+".\n");
  else
    write("Logging to "+str+".\n");
  log_bing = str;
  return 1;
}
void event_person_say(object ob, string start, string rest) {
  if (log_bing)
    log_file(log_bing, start+rest+"\n");
}
void event_say(object ob, string rest) {
  if (log_bing)
    log_file(log_bing, rest);
}
void event_soul(object ob, string rest) {
  if (log_bing)
    log_file(log_bing, rest);
}
void dest_me() {
  if (floor)
    floor->dest_me();
  ::dest_me();
}

==================================================
FILE: admin/room/path.h
==================================================

#define ROOM "/d/admin/room/"

==================================================
FILE: admin/room/playroom.c
==================================================

#include <config.h>
inherit "/std/room/basic_room";
object board;
void reset() {
  if(!board) {
    board = clone_object("obj/misc/board");
    board->set_datafile("playerhelp");
    board->move(this_object());
  }
}
void setup() {
  set_light(60);
  set_short("Player Help Room");
  set_long(
"You are in a strange room with hundreds of frozen statues in the likenesses "+
"of many players on the DiscWorld.  They all seem to be begging, and "+
"looking at you with mournful eyes.\n");
  add_item(({"player","statue"}),
"They all look as if they are asking you questions, but without "+
"moving their lips.  Some of them look genuinly hopeless, but most "+
"have the look of treachery and deceit.  Quite a few of them have many "+
"faces looking in several directions.  Beware them all.\n");
  add_exit("east", "/w/common", "door");
}
void dest_me() {
  if (board)
    board->dest_me();
  ::dest_me();
}
void event_enter(object ob) {
  if (!ob->query_creator() && !ob->query_property("demon")) {
      tell_object(ob, "Whoops!  You don't seem to be a creator.\n");
      call_out("do_move", 2, ob);
   }
}
void do_move(object ob) {
   tell_object( ob, "A trap door opens in the floor and you fall through!\n" );
   ob->move_with_look( "/d/am/am/mendeddrum", "$N fall$s through a trap "+
         "door in the ceiling.", "A trap door opens in the floor and "+
         "$N fall$s through." );
}

==================================================
FILE: admin/room/quest_room.c
==================================================

#include "quest_handler.h"
#include "path.h"
inherit "/std/room/basic_room";
int level;
string  old_quest;
string  story;
string  title;
int do_create( string quest );
int do_delete( string quest );
int do_help( string what );
int do_level( string new_level );
int do_list();
int do_name( string new_name );
int do_story( string new_story );
int do_title( string new_title );
void  remove_quest( string answer );
void  init();
void  setup();
int
do_create( string quest )
{
    if ( !quest )
    {
  write( "Syntax is: create <quest>, where <quest> will be the name of "
       + "the new quest.\n" );
  return 1;
    }
    if ( !level )
    {
  write( "You must set the quest level first.\n" );
  return 1;
    }
    if ( !story )
    {
  write( "You must set the quest story first.\n" );
  return 1;
    }
    if ( !title )
    {
  write( "You must set the quest title first.\n" );
  return 1;
    }
    if ( QUEST_HANDLER->add_quest( quest , level , title , story ) )
    {
  tell_room( this_object() , "Quest \"" + quest + "\" added.\n" );
  level = 0;
  story = 0;
  title = 0;
    }
    else
  tell_room( this_object() , "Quest failed to add.\n" );
    return 1;
}
int
do_delete( string quest )
{
    string  *quests;
    if(!"/secure/master"->query_lord( geteuid( this_player() ) ))
      return 1;
      quests = (mixed*) QUEST_HANDLER->query_quest_names();
    if ( quest )
    {
        if ( member_array( quest, quests ) == -1 )
  {
      write( "Quest not found.\n" );
      return 1;
  }
  old_quest = quest;
  write( "\nYou should not remove someone else's quest!!!\n\n"
       + "Are your sure you want to remove this quest? (y/n) > " );
  input_to( "remove_quest" );
  return 1;
    }
    write( "Syntax: remove <quest>, where <quest> is the name of an "
   + "existing quest.\n" );
    return 1;
}
int
do_help( string what )
{
    if ( what != "room" )  return 0;
    write( "Quest room help:\n\n"
   + "  create <string> - Use current settings to create a new quest\n"
   + "                    whose name is <string>.\n"
   + "  delete <string> - Delete the quest whose name is <string>.\n"
   + "                    This option available only to Lords.\n"
   + "  help room       - Generate this help screen.\n"
   + "  level <int>     - Set the level of difficulty to <int>.\n"
   + "  list            - List the current quests.\n"
   + "  story <string>  - Set the quest story to <string>.\n"
   + "  title <string>  - Set the string that is added to the player's\n"
   + "                    title to <string>.\n"
   );
    return 1;
}
int
do_level( string new_level )
{
    if ( new_level )
    {
  sscanf( new_level , "%d" , level );
  tell_room( this_object() , "Quest level set to " + level + ".\n" );
    }
    else
  write( "Syntax: level <new_level>, where new_level is an integer "
       + "indicating how difficult the quest is.\n" );
    return 1;
}
int do_list() {
  int i;
  string list;
  mixed *names;
  if(!"/secure/master"->query_lord( geteuid( this_player() ) ))
    return 1;
  list = "These are the Discworld quests:\n\n";
  names = (mixed *)QUEST_HANDLER->query_quest_names();
  for ( i = 0; i < sizeof( names ); i++ ) {
    list += "Quest "+ ( i + 1 ) +"  \""+ names[ i ] +"\", level "+
        (int)QUEST_HANDLER->query_quest_level( names[ i ] ) +"\n    title: "+
        (string)QUEST_HANDLER->query_quest_title( names[ i ] ) +"\n    story: "+
        (string)QUEST_HANDLER->query_quest_story( names[ i ] ) +"\n";
    if ( i < sizeof( names ) - 1 )
      list += "\n";
   }
  reset_eval_cost();
  this_player()->more_string( list, "Quest List", 1 );
  return 1;
}
int
do_story( string new_story )
{
    if ( new_story )
    {
  story = new_story;
  tell_room( this_object() , "Quest story set to:\n" + story + "\n" );
    }
    else
  write( "Syntax: story <new_story>, where new_story is a string that "
       + "describes the quest.\n" );
    return 1;
}
int
do_title( string new_title )
{
    if ( new_title )
    {
  title = new_title;
  tell_room( this_object() , "Quest title set to \"" + title + "\".\n" );
    }
    else
  write( "Syntax: title <new_title>, where new_title is the title that "
       + "is appended to the players name for \"who\".\n" );
    return 1;
}
void
init()
{
#ifdef 0
    string  euid;
    object  tp;
    tp   = this_player();
    euid = geteuid( tp );
    if ( ( "/secure/master"->god( euid )             )
      || ( "/secure/master"->high_programmer( euid ) )
      || ( "/secure/master"->query_lord( euid )      )
      || ( tp->query_creator()                       )
      || ( tp->query_app_creator()                   ) )
    {
  add_action( "do_create" , "create" );
  add_action( "do_help"   , "help"   );
  add_action( "do_level"  , "level"  );
  add_action( "do_story"  , "story"  );
  add_action( "do_title"  , "title"  );
  if ( ( "/secure/master"->god( euid )             )
    || ( "/secure/master"->high_programmer( euid ) )
    || ( "/secure/master"->query_lord( euid )      ) )
  {
      add_action( "do_delete" , "delete" );
      add_action( "do_list"   , "list"   );
  }
  level = 0;
  story = 0;
  title = 0;
  do_help( "room" );
  tell_room( this_object() , "\nQuest settings have been reset to "
         + "nulls by init().\n\n" );
    }
    ::init();
#endif
}
void remove_quest( string answer ) {
    answer = lower_case( answer );
    if ( answer == "y" )
    {
  if ( QUEST_HANDLER->delete_quest( old_quest ) )
      tell_room( this_object() , "Quest \"" + old_quest
             + "\" deleted.\n" );
  else
      tell_room( this_object() , "Quest \"" + old_quest + "\" was not "
             + "deleted.\n" );
  return;
    }
    tell_room( this_object() , "Quest \"" + old_quest
           + "\" was not deleted.\n" );
    return;
}
void
setup()
{
    set_short( "Quest Room" );
    set_long("Don't use this room, get a lord to use the quests command instead. This room will break the quests!\n");
    set_light( 100 );
    add_exit( "west" , ROOM+"development" , "corridor" );
}

==================================================
FILE: admin/room/site_control.c
==================================================

#include "path.h"
#include "access.h"
inherit "/std/room/basic_room";
#define MASTER "/secure/master"
int do_banish(string);
int do_access();
int do_suspend(string);
int do_unsuspend(string);
void setup() {
  set_light(100);
  set_short("site-access control room");
  add_property("determinate", "the ");
  set_long(
    "In front of you teem hundreds of small packages.  They rush around "+
    "yelling out strange numbers and get directed into various parts "+
    "of the maze by large mice with red flags.  Everything happens at "+
    "break neck speed.  Every now and then one of the packages "+
    "spontaneously combusts.\n"+
"Available commands:\n"+
"  ban       :  Ban a site.\n"+
"  access    :  Show the current access of various sites.\n"+
"  suspend   :  Suspend someones access.\n"+
"  unsuspend :  Unsuspend someones access.\n");
  seteuid("Admin");
  add_exit("north", ROOM+"domain_control", "corridor");
}
#if efun_defined(add_action)
#define NUM
#else
#define NUM 1
#endif
void init() {
  ::init();
  if (!interactive(previous_object(NUM))) return 0;
  if ("/secure/master"->query_lord(geteuid(previous_object(NUM))))
    add_command("ban", "<string>", (:do_banish($4[0]):));
  add_command("access", "", (:do_access():));
  add_command("suspend", "<string'person'>", (:do_suspend($4[0]):));
  add_command("unsuspend", "<string'person'>", (:do_unsuspend($4[0]):));
}
int print_access(string bit, mapping bing, int depth, int cols) {
  mixed *bits;
  int i;
  if (this_player() != this_player(1))
    return 0;
  bits = m_indices(bing);
  if (depth == 4) {
    for (i=0;i<sizeof(bits);i++)
      switch (bing[bits[i]][0]) {
        case NO_NEW :
          printf("%s@%-=*s", bits[i], cols - strlen(bits[i]), bit +
                             " set to no new characters.\n");
          break;
        case NO_ACCESS :
          printf("%s@%-=*s", bits[i], cols - strlen(bits[i]), bit +
                             " set to no characters.\n");
          break;
        case ACCESS :
          printf("%s@%-=*s", bits[i], cols - strlen(bits[i]), bit +
                             " set to normal access.\n");
          break;
    }
    return 1;
  }
  for (i=0;i<sizeof(bits);i++)
    print_access(bit+"."+bits[i], bing[bits[i]], depth+1, cols);
  return 1;
}
int do_access() {
  mixed bing;
  if (this_player() != this_player(1))
    return 0;
  bing = (mixed)"/secure/bastards"->query_all_access();
  if (!m_sizeof(bing)) {
    notify_fail("No access control defined.\n");
    return 0;
  }
  write("Current access list:\n");
  print_access("", bing, 0, (int)this_player()->query_cols());
  return 1;
}
int do_banish(string str) {
  string ip, ident, reason;
  int level;
  if (this_player() != this_player(1))
    return 0;
  if (!"/secure/master"->high_programmer(geteuid(previous_object())))
    return 0;
  notify_fail("Syntax: banish <ip number> <ident> <level> <reason>\n"+
              "        <level> := 0 delete ident, 1 normal access,\n"+
              "                   2 no new players, 3 No access.\n");
  if (!str)
    return 0;
  if (sscanf(str, "%s %s %d %s", ip, ident, level, reason) != 4)
    return 0;
  if (!"/secure/bastards"->change_access(explode(ip, "."), ident, level,
                                         reason))
    return 0;
  write("Access permisions changed.\n");
  return 1;
}
int do_suspend(string str) {
  string reason;
  string name;
  int tim;
  if (this_player() != this_player(1))
    return 0;
  if (!"/secure/master"->query_lord(geteuid(previous_object())))
    return 0;
  if (!str || sscanf(str, "%s %d %s", name, tim, reason) != 3) {
    notify_fail("Syntax: suspend <name> <time> <reason>\nWhere time is in hours.\n");
    return 0;
  }
  notify_fail("We failed!\n");
  if (!"/secure/bastards"->suspend_person(name, tim*60*60, reason))
    return 0;
  write(name+" suspended until "+ctime(time()+tim*60*60)+"\n");
  return 1;
}
int do_unsuspend(string str) {
  if (this_player() != this_player(1))
    return 0;
  if (!"/secure/master"->query_lord(geteuid(previous_object())))
    return 0;
  notify_fail("We failed!\n");
  if (!"/secure/bastards"->unsuspend_person(str))
    return 0;
  write(str+" unsuspended.\n");
  return 1;
}

==================================================
FILE: admin/room/terrain.c
==================================================

#include "path.h"
#include <terrain.h>
#define COLS (int)this_player()->query_cols()
inherit "/std/room/basic_room";
int do_help();
int do_terrain(string name);
int do_list(string what);
int do_member(string type, string params);
int do_clear();
int do_add(int floating, string file, int x1, int y1, int z1,
	   int x2, int y2, int z2, int level);
int do_remove(int floating, string file, int x1, int y1, int z1,
	   int x2, int y2, int z2);
string terrain_name;
object generator;
void setup() {
   set_short( "terrain-maker room" );
   add_property( "determinate", "the " );
   set_light( 100 );
   set_long( "This room is quite bare, save a notice that has been "
         "taped on the door but its walls have been painted with "
         "scenes of deserts and forests, oceans and mountains, caves and "
         "swamps, and all manner of other types of terrain.\n"
         "Use \"help room\" to list the room's commands.\n" );
   add_exit( "northwest", ROOM +"development", "door" );
   add_sign("The large notice has furled corners and has been taped "
           "and re-taped to the door.\n",
           "Due to the incomprehensible help in this room, this \n"
           "notice was put up to help with the confusion.\n"
           "\n"
           "1.  To get information on a certain terrain, you\n"
           "    need to select that terrain by typing \n"
           "    \"terrain <terrain_name>\".\n"
           "\n"
           "2.  To remove floating or fixed locations within the terrain,\n"
           "    type \"list floating\" or \"list fixed\".\n"
           "\n"
           "    remove floating <path of terrain> <all 6 co ordinates> <level>\n"
           "\n"
           "    remove fixed <path of room>\n"
           "\n"
           "3.  To add a floating location, same as above, only use add.\n"
           "    For both removing and adding, no commas and no .c at the end\n"
           "    of path names.  When removing/adding fixed locations, all\n"
           "    locations must be done one by one.\n", 0, "notice");
}
void reset() {
   if ( !generator ) {
      generator = clone_object( "/obj/handlers/terrain_things/dungeon_maker" );
      generator->move( this_object() );
   }
}
void init() {
  ::init();
  add_command("help", "room", (: do_help() :) );
  add_command("terrain", "<string>", (: do_terrain($4[0]) :) );
  add_command("list", "fixed", (: do_list("fixed") :) );
  add_command("list", "floating", (: do_list("floating") :) );
  add_command("member", "", (: do_member(0,0) :) );
  add_command("member", "fixed <string>",
    (: do_member("fixed", $4[0]) :) );
  add_command("member", "floating <string>",
    (: do_member("floating", $4[0]) :) );
  add_command("add",
    "fixed <word'file'> <number'x'> <number'y'> <number'z'>",
    (: do_add(0, $4[0], $4[1], $4[2], $4[3], 0, 0, 0, 0) :) );
  add_command("add",
    "floating <word'file'> <number'x1'> <number'y1'> <number'z1'> "
      "<number'x2'> <number'y2'> <number'z2'> <number'level'>",
    (: do_add(1, $4[0], $4[1], $4[2], $4[3],
                        $4[4], $4[5], $4[6],
                 $4[7]) :) );
  add_command("add",
    "floating <word'file'> <number'x'> <number'y'> <number'z'> "
      "<number'level'>",
    (: do_add(2, $4[0], $4[1], $4[2], $4[3],
                        0, 0, 0,
                 $4[4]) :) );
  add_command("remove",
    "fixed <word'file'>",
    (: do_remove(0, $4[0], 0, 0, 0, 0, 0, 0) :) );
  add_command("remove",
    "floating <word'file'> <number'x1'> <number'y1'> <number'z1'> "
      "<number'x2'> <number'y2'> <number'z2'>",
    (: do_remove(1, $4[0], $4[1], $4[2], $4[3],
		 $4[4], $4[5], $4[6]) :) );
  add_command("remove",
    "floating <word'file'> <number'x'> <number'y'> <number'z'>",
    (: do_remove(2, $4[0], $4[1], $4[2], $4[3],
		 0, 0, 0 ) :) );
  add_command("clear", "", (: do_clear() :) );
}
int do_help () {
  write( "Available commands are:\n\n"+
      "     terrain  -  set terrain name\n"+
      "     list     -  list locations in current terrain\n"+
      "     member   -  find locations matching coordinates\n"+
      "     add      -  add a new location\n"+
      "     remove   -  remove an old location\n"+
      "     clear    -  clear all clones and connections\n" );
  return 1;
}
int do_terrain( string name ) {
  if ( !name ) {
    if ( stringp( terrain_name ) )
      write( "Terrain name is "+ terrain_name +".\n" );
    else
      write( "There is no terrain name set.\n" );
    return 1;
  }
  write( "Terrain name set to "+ name +".\n" );
  terrain_name = name;
  return 1;
}
int do_list( string word ) {
  int i, size;
  string list;
  mapping locations;
  mixed indeces, values;
  if ( ( word != "fixed" ) && ( word != "floating" ) ) {
    write( "List what? Options are \"fixed\" and \"floating\".\n" );
    return 1;
  }
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  if ( !( (int)TERRAIN_MAP->get_data_file( terrain_name ) ) ) {
    write( "There are no locations in the terrain "+ terrain_name +".\n" );
    return 1;
  }
  if ( word == "fixed" ) {
    locations = (mapping)TERRAIN_MAP->query_fixed_locations( terrain_name );
    size = m_sizeof( locations );
    indeces = m_indices( locations );
    values = m_values( locations );
    if ( !size ) {
      write( "There are no fixed locations in the terrain "+ terrain_name
                +".\n" );
      return 1;
    }
    list = "The terrain "+ terrain_name +" has the following fixed location"+
              ( size == 1 ? "" : "s" ) +":\n";
    for ( i = 0; i < size; i++ )
      list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, indeces[ i ] +
          " at ("+ values[ i ][ 0 ] +", "+ values[ i ][ 1 ] +", "+
          values[ i ][ 2 ] +")" );
    this_player()->more_string( list, "Fixed" );
    return 1;
  }
  locations = (mapping)TERRAIN_MAP->query_floating_locations( terrain_name );
  size = sizeof( locations );
  if ( !size ) {
    write( "There are no floating locations in the terrain "+ terrain_name
              +".\n" );
    return 1;
  }
  list = "The terrain "+ terrain_name +" has the following floating "+
      "location"+ ( size == 1 ? "" : "s" ) +":\n";
  for ( i = 0; i < size; i++ )
    if ( sizeof( locations[ i ][ 1 ] ) == 3 )
      list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, locations[ i ][ 0 ] +
          " at ("+ locations[ i ][ 1 ][ 0 ] +", "+ locations[ i ][ 1 ][ 1 ] +
          ", "+ locations[ i ][ 1 ][ 2 ] +"), level "+ locations[ i ][ 2 ] );
    else
      list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, locations[ i ][ 0 ] +
          " from ("+ locations[ i ][ 1 ][ 0 ] +", "+ locations[ i ][ 1 ][ 1 ] +
          ", "+ locations[ i ][ 1 ][ 2 ] +") to ("+ locations[ i ][ 1 ][ 3 ] +
          ", "+ locations[ i ][ 1 ][ 4 ] +", "+ locations[ i ][ 1 ][ 5 ] +
          "), level "+ locations[ i ][ 2 ] );
  this_player()->more_string( list, "Floating" );
  return 1;
}
int do_member( string type, string parameters ) {
  int i, size, *co_ords;
  string list, location;
  mixed *locations;
  if (!type || !parameters) {
    write( "Syntax: member <fixed|floating> <coord1> ...\n" );
    return 1;
  }
  if ( ( type != "fixed" ) && ( type != "floating" ) ) {
    write( "Syntax: member <fixed|floating> ...\n" );
    return 1;
  }
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  co_ords = allocate( 3 );
  if ( type == "fixed" ) {
    if ( sscanf( parameters, "%d %d %d", co_ords[ 0 ], co_ords[ 1 ],
        co_ords[ 2 ] ) != 3 ) {
      write( "Syntax: member fixed <coord1> <coord2> <coord3>\n" );
      return 1;
    }
    TERRAIN_MAP->get_data_file( terrain_name );
    location = (string)TERRAIN_MAP->member_fixed_locations( co_ords );
    if ( !location ) {
      write( "There is no fixed location in the terrain "+ terrain_name +
          " at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+ co_ords[ 2 ] +
          ").\n" );
      return 1;
    }
    write( "The terrain "+ terrain_name +" has "+ location +" as a fixed "+
        "location at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+ co_ords[ 2 ] +
        ").\n" );
    return 1;
  }
  if ( sscanf( parameters, "%d %d %d", co_ords[ 0 ], co_ords[ 1 ], co_ords[ 2 ] )
      != 3 ) {
    write( "Syntax: member floating <coord1> <coord2> <coord3>\n" );
    return 1;
  }
  TERRAIN_MAP->get_data_file( terrain_name );
  locations = (mixed *)TERRAIN_MAP->member_floating_locations( co_ords );
  size = sizeof( locations ) / 2;
  if ( !size ) {
    write( "There are no floating locations in the terrain "+ terrain_name +
        " at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+ co_ords[ 2 ] +
        ").\n" );
    return 1;
  }
  list = "There "+ ( size == 1 ? "is one floating location" : "are "+
      query_num( size ) +" floating locations " ) +" in the terrain "+
      terrain_name +" at ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +", "+
      co_ords[ 2 ] +"):\n";
  for ( i = 0; i < size; i++ )
    list += sprintf( "% 5d - %-=*s\n", i + 1, COLS - 9, locations[ 2 * i ] +
        ", level "+ locations[ 2 * i + 1 ] );
  this_player()->more_string( list, "Member" );
  return 1;
}
int do_add(int floating,
	   string file, int x1, int y1, int z1,
	   int x2, int y2, int z2, int level)
{
  int *co_ords;
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  if (floating == 0 || floating == 2) {
    co_ords = allocate(3);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
  } else {
    co_ords = allocate(6);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
    co_ords[3] = x2;
    co_ords[4] = y2;
    co_ords[5] = z2;
  }
  if (floating == 0) {
    if ( !TERRAIN_MAP->add_fixed_location( terrain_name, file, co_ords ) ) {
      write( "The fixed location "+ file +" in the terrain "+ terrain_name
                +" already exists.\n" );
      return 1;
    }
    write( "The fixed location "+ file +" has been added to the terrain "+
        terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
        ", "+ co_ords[ 2 ] +").\n" );
    return 1;
  }
  TERRAIN_MAP->add_floating_location( terrain_name, file, co_ords, level );
  if ( sizeof( co_ords ) == 6 )
    write( "A floating location using "+ file +" has been added to the "+
        "terrain "+ terrain_name +" from coordinates ("+ co_ords[ 0 ] +", "+
        co_ords[ 1 ] +", "+ co_ords[ 2 ] +") to coordinates ("+ co_ords[ 3 ] +
        ", "+ co_ords[ 4 ] +", "+ co_ords[ 5 ] +") at level "+ level +".\n" );
  else
    write( "A floating location using "+ file +" has been added to the "+
        "terrain "+ terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+
        co_ords[ 1 ] +", "+ co_ords[ 2 ] +") and level "+ level +".\n" );
  return 1;
}
int do_remove(int floating,
	   string file, int x1, int y1, int z1,
	   int x2, int y2, int z2)
{
  int *co_ords;
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  if (floating == 2) {
    co_ords = allocate(3);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
  } else if (floating == 1) {
    co_ords = allocate(6);
    co_ords[0] = x1;
    co_ords[1] = y1;
    co_ords[2] = z1;
    co_ords[3] = x2;
    co_ords[4] = y2;
    co_ords[5] = z2;
  }
  if ( floating == 0 ) {
    if ( !TERRAIN_MAP->delete_fixed_location( terrain_name, file ) ) {
      write( "There is no fixed location "+ file +" in the terrain "+
          terrain_name +" to remove.\n" );
      return 1;
    }
    write( "The fixed location "+ file +" has been removed from the terrain "+
        terrain_name +".\n" );
    return 1;
  }
  if ( !TERRAIN_MAP->delete_floating_location( terrain_name, file, co_ords ) ) {
    if ( sizeof( co_ords ) == 6 )
      write( "There is no floating location using "+ file +" in the terrain "+
          terrain_name +" from coordinates ("+ co_ords[ 0 ] +", "+
          co_ords[ 1 ] +", "+ co_ords[ 2 ] +") to coordinates ("+ co_ords[ 3 ] +
          ", "+ co_ords[ 4 ] +", "+ co_ords[ 5 ] +") to remove.\n" );
    else
      write( "There is no floating location using "+ file +" in the terrain "+
          terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
          ", "+ co_ords[ 2 ] +") to remove.\n" );
    return 1;
  }
  if ( sizeof( co_ords ) == 6 )
    write( "The floating location using "+ file +" in the terrain "+
        terrain_name +" from coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
        ", "+ co_ords[ 2 ] +") to coordinates ("+ co_ords[ 3 ] +", "+
        co_ords[ 4 ] +", "+ co_ords[ 5 ] +") has been removed.\n" );
  else
    write( "The floating location using "+ file +" in the terrain "+
      terrain_name +" at coordinates ("+ co_ords[ 0 ] +", "+ co_ords[ 1 ] +
      ", "+ co_ords[ 2 ] +") has been removed.\n" );
  return 1;
}
int do_clear() {
  if ( !terrain_name ) {
    write( "There is no current terrain name.\n" );
    return 1;
  }
  TERRAIN_MAP->clear_cloned_locations( terrain_name );
  TERRAIN_MAP->clear_connections( terrain_name );
  write( "Clones and connections cleared for the terrain "+ terrain_name +
      ".\n" );
  return 1;
}

==================================================
FILE: admin/room/we_care/club_room_controller.c
==================================================

#include <clubs.h>
inherit "/std/room/controller/club_room_controller";
#include <room/club_room.h>
void setup() {
   set_save_file("/d/admin/save/club_room");
   set_board_associated(1);
   add_controlled_ownership("main room",
                            CLUB_ROOM_CONTROLLER_DISCUSSED,
                            CLUB_ROOM_OWNED_POSITION,
                            (: CLUB_HANDLER->query_president_position($2) :));
}

==================================================
FILE: admin/room/we_care/main_club_room.c
==================================================

#include "path.h"
inherit "/std/room/club_room";
void setup() {
   set_short("main club room");
   set_long("The main club room.\n");
   set_club_controller(CONTROLLER);
   set_light(70);
   set_leave_exit("south");
   add_exit("south", "/d/admin/room/meeting", "door");
}

==================================================
FILE: admin/room/we_care/owned_room1.c
==================================================

inherit "/std/room/inherit/club_owned_room";
#include "path.h"
void setup() {
   set_short("The first owned room");
   set_long("A room that is owned.\n");
   set_club_controller(CLUB_CONTROLLER);
   set_club_owned_id("main office");
}

==================================================
FILE: admin/room/we_care/path.h
==================================================

#define CONTROLLER "/d/admin/room/we_care/club_room_controller"

==================================================
FILE: admin/obj/bingle.c
==================================================

inherit "/std/object";
void setup() {
  set_name("domainer");
  set_long(
"This object shows you all of the creators who are in each domain and those "+
"that don't have directorys, are not cretors and ones who are not in a "+
"domain at all.\nThe command to view all this is \"info\".\n");
}
void init() {
  add_action("do_info", "info");
}
int do_info(string str) {
  string *creators,
         *domains,
         *mem,
         *cre_not,
         bit;
  mapping no_dir, not_creator;
  int i, j, cols;
  cols = (int)this_player()->query_cols();
  creators = get_dir("/w/");
  domains = get_dir("/d/");
  no_dir = ([ ]);
  not_creator = ([ ]);
  cre_not = ({ });
  for (i=0;i<sizeof(creators);i++)
    if (file_size("/w/"+creators[i]) != -2) {
      creators = delete(creators, i, 1);
      i--;
    } else if (!"/secure/login"->test_creator(creators[i])) {
      cre_not += ({ creators[i] });
      creators = delete(creators, i, 1);
      i--;
    }
  for (i=0;i<sizeof(domains);i++) {
    mem = (string *)("/d/"+domains[i]+"/master")->query_members() +
          ({ (string *)("/d/"+domains[i]+"/master")->query_lord() });
    creators -= mem;
    for (j=0;j<sizeof(mem);j++) {
      if (file_size("/w/"+mem[j]) != -2)
        no_dir[mem[j]] = domains[i];
      if (!"/secure/login"->test_creator(mem[j]))
        not_creator[mem[j]] = domains[i];
    }
    bit = "Members of "+domains[i]+" are: ";
    printf("%s%-=*s\n", bit, cols-strlen(bit), implode(mem, ", ")+".");
  }
  if (sizeof(no_dir)) {
    write("These creators are in domains but do not have a directory:\n");
    printf("    %-=*s", cols-5, implode(keys(no_dir), ", ")+".\n");
  }
  if (sizeof(not_creator)) {
    write("These creators are in domains but are not actually creators:\n");
    printf("    %-=*s", cols-5, implode(keys(not_creator), ", ")+".\n");
  }
  if (sizeof(creators)) {
    write("These creators are not in any domain:\n");
    printf("    %-=*s", cols-5, implode(creators, ", ")+".\n");
  }
  if (sizeof(cre_not)) {
    write("These creators have a directory, but are not creators...:\n");
    printf("    %-=*s", cols-5, implode(cre_not, ", ")+".\n");
  }
  return 1;
}

==================================================
FILE: admin/obj/check.c
==================================================

#define SAVE_FILE "/d/admin/log/"
string *paths, *cloned_by;
int *times;
mapping illegal;
void dest_me()
{
   destruct(this_object());
}
void create()
{
   illegal = ([ ]);
   paths = ({ });
   cloned_by = ({ });
}
void log_file()
{
   int p;
   string *person, *filename;
   filename=m_indices(illegal);
   person=values(illegal);
   if(sizeof(illegal)>0) {
      unguarded((: write_file, SAVE_FILE+"illegal.txt",
                 "\nSearch carried out on "+ctime(time())+" from here.\n" :));
      for(p=0;p<sizeof(illegal);p++) {
         unguarded((: write_file, SAVE_FILE+"illegal.txt",
                    filename[p]+"  -  on player "+person[p]+" - cloned by "+
                    cloned_by[p]+"\n" :));
      }
   }
}
void check_sub_inv(object *things, object owner)
{
int q, r, check;
string *pre_filename, filename, *switcher;
mixed info;
   for(q=0;q<sizeof(things);q++)
   {
      pre_filename=explode(file_name(things[q]),"#");
      filename=pre_filename[0];
      switcher=explode(filename,"/");
      if( (switcher[0]=="w") && (!owner->query_creator() ) )
      {
         illegal=illegal+([filename:owner->query_name()]);
         info = things[q]->stats();
         for(r=0; r<sizeof(info);r++)
         {
            if(info[r][0] == "cloned by")
            {
               cloned_by = cloned_by + ({ info[r][1] });
            }
         }
           destruct(things[q]);
       }
      if ( (!owner->query_creator()) && (sizeof(switcher)>2) && (switcher[0]=="obj") && (switcher[1]=="misc") )
      {
         switch(switcher[2]){
         case "mailer_ob":
         case "board_mas":
            info = things[q]->stats();
            for(r=0; r<sizeof(info);r++)
            {
               if(info[r][0] == "cloned by")
               {
                  cloned_by = cloned_by + ({ info[r][1] });
               }
            }
            illegal=illegal+([filename:owner->query_name()]);
             destruct(things[q]);
            break;
         }
      }
   }
}
void check_inv(object player)
{
int q;
object *things, *contents, owner;
   things=deep_inventory(player);
   owner=player;
   check_sub_inv(things, player);
}
do_seek()
{
   int p;
   object *everyone_on;
   seteuid("Admin");
   everyone_on = users();
   for(p=0;p<sizeof(everyone_on);p++)
   {
      check_inv(everyone_on[p]);
   }
   log_file();
   return 1;
}

==================================================
FILE: admin/obj/inv_check.c
==================================================

#include <playtesters.h>
#include <move_failures.h>
#define FILENAME "/save/inv_check"
int do_seek();
nosave string to_log;
string *forbidden = ({ });
void save_me() {
  unguarded ((: save_object (FILENAME) :));
}
void dest_me() {
   destruct( this_object() );
   save_me();
}
void create() {
  seteuid( "Admin" );
  unguarded ((: restore_object (FILENAME) :));
  do_seek();
}
void log_it() {
   if( sizeof( to_log ) > 0 ) {
      log_file( "ILLEGAL_OBJECT",
               "Illegal objects removed %s\n%s\n",
               ctime( time() ),
               to_log );
   }
}
void check_sub_inv( object *things, string owner, object owner_ob ) {
   string *pre_filename, filename, *switcher;
   object *obs, thing;
   object *contents, *fragile;
   string mess = "";
   object bag;
   obs = ({ });
   foreach ( thing in things ) {
     if ( thing->query_property( "virtual name" ) ) {
       filename = thing->query_property( "virtual name" );
     } else {
       pre_filename = explode( file_name( thing ),"#" );
       filename = pre_filename[ 0 ];
     }
      switcher = explode( filename, "/" );
      if( ( switcher[0]=="w" ) &&
          ( !"/obj/handlers/playtesters"->query_playtester( owner ) ) ) {
         to_log += sprintf("%s in %s, cloned by %s\n",
                           filename, owner,
                           (string)thing->query_cloned_by() );
         obs += ({ thing });
      }
      if ( ( sizeof( switcher ) > 2 ) &&
          ( switcher[ 0 ] == "obj" ) &&
          ( switcher[ 1 ] == "misc" ) ) {
         switch(switcher[2]){
          case "mailer_ob":
            if ( !"/obj/handlers/playtesters"->query_playtester( owner ) &&
                 ( !owner_ob->query_property("allowed mailer")) ) {
               to_log += sprintf("%s in %s, cloned by %s\n",
                                 filename, owner,
                                 (string)thing->query_cloned_by() );
               obs += ({ thing });
            }
            break;
          case "board_mas":
            to_log += sprintf("%s in %s, cloned by %s\n",
                              filename, owner,
                              (string)thing->query_cloned_by() );
            obs += ({ thing });
            break;
         }
      }
      if (sizeof (switcher) ==4 &&
        switcher [0] == "d" &&
        switcher [1] == "liaison" &&
        switcher [2] == "items") {
           to_log += sprintf("%s in %s, cloned by %s\n",
                             filename, owner,
                             (string)thing->query_cloned_by() );
           obs += ({ thing });
      }
      reset_eval_cost();
      if (member_array (filename, forbidden) != -1) {
            to_log += sprintf("%s in %s, cloned by %s\n",
                              filename, owner,
                              (string)thing->query_cloned_by() );
            obs += ({ thing });
            thing->add_property ("no recycling", 1);
            if (function_exists ("query_max_weight", thing)) {
              contents = all_inventory (thing);
            }
      }
   }
   if ( sizeof( obs ) ) {
      tell_object (owner_ob, owner_ob->colour_event ("say", "%^CYAN%^") +
        "A small official looking dwarf walks up to you and says: In "
        "accordance with paragraph 5, sub-paragraph 7 of the Domestic "
        "& Domesticated Animals (Care & Protection) Act, 1673, I hereby "
        "remove from you: "+ (string)query_multiple_short( obs, "one" )
        + ".%^RESET%^");
      if (sizeof (contents)) {
        mess += "\nThe dwarf removes all the inventory from the confiscated "
          "items.";
        fragile = filter (contents, (: $1->query_property("fragile") :));
        if (sizeof (fragile)) {
          mess += "\nHe hands " + query_multiple_short (fragile) + " to "
            "you.\n";
          contents -= fragile;
          fragile->move (owner_ob);
        }
        if (sizeof (contents)) {
          bag = clone_object ("/obj/baggage");
          bag->set_name ("bag");
          bag->set_short ("brown paper bag");
          bag->add_adjective (({"brown", "paper"}));
          bag->set_weight(5);
          bag->set_max_weight (implode (map (contents,
            (: $1->query_complete_weight() :)),(: $1 + $2 :)) + 1);
          bag->set_value (0);
          bag->set_long ("This is a plain, brown, paper bag... the kind grubby "
            "old men are often found in possession of after leaving their "
            "local newsagent.\n");
          contents->move (bag);
          if (bag->move (owner_ob) == MOVE_TOO_HEAVY) {
            mess +=  "He sticks " + query_multiple_short (contents) + " in a "
              "brown paper bag and leaves it on the ground.";
          }
          else {
            mess +=  "He sticks " + query_multiple_short (contents) + " in a "
              "brown paper bag and hands it to you.";
          }
        }
      }
      mess += "\nHe scribbles something on a clipboard, then walks away.\n";
      tell_object (owner_ob, mess);
      obs->move( "/room/rubbish" );
      call_out( "check_obs", 7, obs );
   }
}
void check_obs( object* obs ) {
   object thing;
   foreach( thing in obs ) {
      if( thing ) {
   thing->dest_me();
      }
   }
}
void check_inv( object player ) {
   object *things;
   things = deep_inventory( player );
   check_sub_inv( things, (string)player->query_name(), player );
}
int do_seek() {
  object user;
  to_log = "";
  foreach ( user in users() ) {
    if( user && !user->query_property( "guest" ) &&
       !user->query_creator() &&
       !PLAYTESTER_HAND->query_tester (user) &&
       !user->query_property ("test character") ) {
      check_inv( user );
    }
  }
  log_it();
  call_out( "do_seek", 300 );
  return 1;
}
int query_theft_command() { return -1; }
string parse_filename (string str) {
  if (strsrch (str, ".wep") != -1 ||
      strsrch (str, ".clo") != -1 ||
      strsrch (str, ".ob") != -1 ||
      strsrch (str, ".arm") != -1 ||
      strsrch (str, ".food") != -1 ||
      strsrch (str, ".sca") != -1) {
        if (file_size(str) <= 0) {
          return 0;
        }
        else {
          return str;
        }
  }
  else {
    str = explode (str, ".c")[0];
    if (file_size(str + ".c") <= 0 ) {
      return 0;
    }
    else {
      return str;
    }
  }
}
int ban_object(string filename) {
  if (!master()->query_lord(previous_object(-1))) {
    printf ("Please get a lord to ban your object for you.\n");
    return 0;
  }
  filename = parse_filename (filename);
  if (filename == 0) {
    printf ("No file with that filename.\n", filename);
    return 0;
  }
  else {
    if (member_array (filename, forbidden) == -1) {
      forbidden += ({ filename });
      printf ("%s added to the list of banned objects.\n", filename);
      save_me();
    }
    else {
      printf ("%s already banned.\n", filename);
    }
  }
  return 1;
}
int unban_object(string filename) {
  if (!master()->query_lord(previous_object(-1))) {
    printf ("Please get a lord to unban your object for you.\n");
    return 0;
  }
  filename = parse_filename (filename);
  if (filename == 0) {
    printf ("No file with that filename.\n", filename);
    return 0;
  }
  else {
    if (member_array (filename, forbidden) != -1) {
      forbidden -= ({ filename });
      printf ("%s removed from the list of banned objects.\n", filename);
      save_me();
    }
    else {
      printf ("%s not currently banned.\n", filename);
    }
  }
  return 1;
}
string list_banned() {
  if (sizeof (forbidden)) {
    return sprintf ("Objects cloned from the following filenames "
      "will be confiscated by the dwarves:\n%s\n",
      implode (forbidden, "\n"));
  }
  else {
    return "There are no objects currently forbidden.\n";
  }
}
mixed stats()
{
  return ({
    ({ "Time until next tick", query_num (find_call_out ("do_seek"))
      + " seconds"}),
  });
}

==================================================
FILE: admin/obj/path.h
==================================================



==================================================
FILE: liaison/common.c
==================================================

#include <config.h>
#define DOM_TITLE "Liaison Domain"
#define LORD "wyvyrn"
#define DOMAIN "liaison"
#define BOSS_ROOM "/w/wyvyrn/rooms/office"
inherit "/std/dom/cmn_mas";
object board;
void setup() {
   set_dom( DOMAIN );
   set_light( 100 );
   set_short( "Liaison Domain Common room" );
   add_property( "determinate", "the " );
   set_long("The Liaison common room looks like a comfortable place to "
            "come to after a hard day's liaising.  The large pile of stress "
            "balls sat in one corner and the drinks cabinet against a wall "
            "highlight this.  The various evil-looking devices scattered "
            "around the room seem to add character and even a slightly "
            "malicious overtone to the entire place.  There are also a "
            "few chairs scattered around the place providing welcome bum "
            "relief.  One even looks to be occupied.\n"
            "A sign is hanging on the wall.\n");
   add_alias("balls", "ball");
   add_alias("devices", "device");
   add_alias("bottles", "bottle");
   add_alias("chairs", "chair");
   add_alias("whips", "whip");
   add_alias("chains", "chain");
   add_alias("easy chair", "chair");
   add_alias("dolls", "doll");
   add_alias("armrests", "armrest");
   add_alias("cushions", "cushion");
   add_alias("strings", "string");
   add_alias("needles", "needle");
   add_item( ({"ball", "stress ball"}), "The pile of stress balls seems very "
            "inviting, albeit until you get up close and see that they are "
            "actually coated in tough plastic and tied to a pole with string - "
            "effectively ending their usefulness.  They look nice though.");
   add_item("string", "Each piece of string connects a ball to the pole, "
            "stopping the ball moving very far.  Cruel.");
   add_item("pile", "The pile of stress balls seems very inviting, albeit "
            "until you get up close and see that they are actually coated in "
            "tough plastic and tied to a pole with string - effectively "
            "ending their usefulness. They look nice though.");
   add_item("lock", "A big lock that looks completely unpickable, mainly due "
            "to it having no keyhole.  Nothing will unlock it, so you heavy "
            "drinkers are just out of luck.");
   add_item("corner", "A corner of the room. Where two walls, the ceiling "
            "and the floor meet.");
   add_item("pole", "There is a short pole hiding unobtrusively behind the "
            "stress balls and it is only through very close scruitiny that "
            "it is actually noticable at all.  The pole seems to have "
            "lots of strings coming out of it, each of which lead to a "
            "stress ball, limiting the distance it can travel.\n"
            "It is secured to the floor and cannot come out.");
   add_item("device", "Devices of differing shapes and sizes litter most "
            "of the walls - all seemingly to do with harming nasty players. "
            " From the voodoo dolls in one corner to the rack in another, "
            "not to mention the whips and chains.  Serious stuff.");
   add_item("whip", "I told you not to mention them.");
   add_item("chain", "I told you not to mention them.");
   add_item("bottle", "The bottles line the inside of the cabinet, all "
            "different shapes and sizes of bottles.  Green bottles, "
            "blue bottles, red bottles, bottles with caterpillers in, "
            "bottles with toads in, bottles with DUCKs in, bottles "
            "with labels on, bottles with warnings on, bottles with "
            "skulls and crossbones on, so basically, lots of bottles.");
   add_item("cabinet", "The drinks cabinet is leaning idly against a "
            "wall [as much as a drinks cabinet can] and seems to sneer "
            "at you [as much as a drinks cabinet can].  The polished "
            "glass of the cabinet windows show all the drinks that "
            "seem to look smug [as much as bottles can].  The large "
            "lock holding the cabinet shut makes the bottles "
            "completely out of range.\n"
            "If you are really desperate, "
            "clone /w/lucifer/misc/blasterbottle.c and go nuts.");
   add_item("glass", "It's just some glass in the cabinet.  Nothing "
            "special.");
   add_item("chair", "The easy chairs that line the walls are "
            "pretty nondescript: big "
            "deep cushions and fluffy armrests, but that's all "
            "they are - and ever will be: chairs.  "
            "As a profound sense of misery sweeps over you, you "
            "notice one of the chairs is occupied by a rather "
            "despondant looking man.");
   add_item("doll", "The voodoo dolls lie in a messy pile in a "
            "corner of the room, looking particularly morbid with "
            "a hundred different needles sticking out at various "
            "points of their doll bodies.  The faces of the dolls "
            "are hard to make out, seeming to shift from likeness to "
            "likeness as you look at them.  There is a barrier in front "
            "of the dolls, suggesting they shouldn't be touched.");
   add_item("barrier", "A thick looking piece of metal completely blocking "
            "all access to the dolls.  Most probably for the best, too.");
   add_item("needle", "The needles are -unsurprisingly- sharp things "
            "currently embedded into the dolls, no doubt causing extreme "
            "pain.  Well, at least they would if the dolls were real. "
            "Which they aren't.  Which is a good thing.");
   add_item("rack", "The rack is a vicious looking instrument that allows "
            "the human [or non-human] body to be stretched to completely "
            "wrong proportions.  This is something that should be used "
            "with extreme caution.  Happily, it appears not to have been "
            "used yet [there is a still plastic covering on it] and long "
            "may it stay that way.");
   add_item("covering", "Mercifully there is a covering on the rack, "
            "showing it has never been used.  Which is a good thing.");
   add_item("armrest", "It's an armrest.  You rest your arm on it.");
   add_item("wall", "It's a wall.  That's about it.");
   add_item("cushion", "It's a cushion. You rest your bum on it.");
   add_item("man", "The man seated in one of the easy chairs looks "
            "to have resigned himself to a lifetime there, and "
            "from what you can see there appears to be a deep "
            "groove in the chair from his body shape.\n"
            "He notices you looking at him and speaks slowly, like he "
            "has nearly forgotten how: 'Do you know how long Moonchild "
            "will be? I've been waiting here for over 5 years now! I "
            "missed the fall of quest XP and everything - just because "
            "I wanted my items back!'\n"
            "As the man starts to froth at the mouth, you hurriedly turn "
            "your back on him and leave him to his waiting.");
   add_sign("This is a sign.  But then you knew that, or at least we hope "
            "you did.\n",
            "Commands available here are:\n"
            "add <name>   : add <name> as one of your characters.\n"
            "remove <name>: remove <name> as one of your characters.\n"
            "list [<name>]: list characters added for you or <name>.", 0, 0, 0);
   board = clone_object("/obj/misc/board");
   board->set_datafile(DOMAIN);
   board->move(this_object());
   add_exit("office", "/w/wyvyrn/rooms/study", "door");
   add_exit("drum", CONFIG_START_LOCATION, "path");
   add_exit("corridor", "/d/liaison/cre_corridor", "door");
   add_exit("interview", "/d/liaison/utils/interview", "door");
   BOSS_ROOM->add_exit("common", "/d/"+DOMAIN+"/common", "door");
}
void init() {
   this_player()->add_command( "add", this_object(), "<word> <word>" );
   this_player()->add_command( "add", this_object(), "<word>" );
   this_player()->add_command( "remove", this_object(), "<word> <word>" );
   this_player()->add_command( "remove", this_object(), "<word>" );
   this_player()->add_command( "list", this_object(), "" );
   this_player()->add_command( "list", this_object(), "<word>" );
}
int do_add( object *indir, string indir_match, string dir_match,
           mixed *args, string pattern  ) {
   switch( pattern ) {
    case "<word> <word>":
      if ( master()->query_lord( this_player()->query_name() ) ||
           "/d/liaison/master"->query_deputy( this_player()->query_name() ) ) {
         if ( "/d/liaison/master"->add_member_alias( args[ 0 ],
                                                    args[ 1 ] ) ) {
            this_player()->add_succeeded_mess( this_object(),
                args[ 1 ] +" added as alias for "+ args[ 0 ] +".\n" );
            return 1;
         } else {
            this_player()->add_failed_mess( this_object(),
                "Something went wrong.\n" );
            return 0;
         }
      } else {
         this_player()->add_failed_mess( this_object(),
                "Only lords and deputies can add aliases to others.\n" );
         return 0;
      }
      break;
    case "<word>":
      if ( "/d/liaison/master"->add_member_alias( this_player()->query_name(),
                                                 args[ 0 ] ) ) {
         this_player()->add_succeeded_mess( this_object(),
                args[ 0 ] +" added as alias for $N.\n" );
         return 1;
      } else {
         this_player()->add_failed_mess( this_object(),
                "Couldn't add "+ args[ 0 ] +" as alias for $N.\n" );
         return 0;
      }
      break;
   }
}
int do_remove( object *indir, string indir_match, string dir_match,
           mixed *args, string pattern  ) {
   switch( pattern ) {
    case "<word> <word>":
      if ( master()->query_lord( this_player()->query_name() ) ||
           "/d/liaison/master"->query_deputy( this_player()->query_name() ) ) {
         if ( "/d/liaison/master"->delete_member_alias( args[ 0 ],
                                                       args[ 1 ] ) ) {
            this_player()->add_succeeded_mess( this_object(),
                    args[ 1 ] +" removed as alias for "+ args[ 0 ] +".\n" );
            return 1;
         } else {
            this_player()->add_failed_mess( this_object(),
                "Something went wrong.\n" );
            return 0;
         }
      } else {
         this_player()->add_failed_mess( this_object(),
                "Only lords and deputies can remove aliases for others.\n" );
         return 0;
      }
      break;
    case "<word>":
      if ( "/d/liaison/master"->delete_member_alias(
                 this_player()->query_name(), args[ 0 ] ) ) {
         this_player()->add_succeeded_mess( this_object(),
                 args[ 0 ] +" removed as alias for $N.\n" );
         return 1;
      } else {
         this_player()->add_failed_mess( this_object(),
                 "Couldn't remove "+ args[ 0 ] +" as alias for $N.\n" );
         return 0;
      }
      break;
   }
}
int do_list( object *indir, string indir_match, string dir_match,
           mixed *args, string pattern  ) {
   string *names, name;
   int i;
   switch( pattern ) {
    case "<word>":
      name = args[ 0 ];
      break;
    case "":
      name = this_player()->query_name();
      break;
   }
   names = "/d/liaison/master"->member_alias( name );
   name = capitalize( name );
   i = sizeof( names );
   if ( i ) {
      if ( i > 1 ) {
         while ( i-- ) {
            names[ i ] = capitalize( names[ i ] );
         }
         this_player()->add_succeeded_mess( this_object(),
                "Aliases for "+ name +" are "+
                query_multiple_short( names )+".\n" );
      } else {
         this_player()->add_succeeded_mess( this_object(),
                "Alias for "+ name +" is "+
                capitalize( names[ 0 ] )+".\n" );
      }
   } else {
      this_player()->add_succeeded_mess( this_object(),
             "No aliases known for "+ name +".\n" );
   }
   return 1;
}

==================================================
FILE: liaison/cre_corridor.c
==================================================

inherit "/std/room/basic_room";
string do_mirror();
void setup() {
    set_short("Liaison hallway");
    set_light(100);
    add_property("determinate", "the ");
    set_long("This is the homely corridor of the Liaison Domain.  There are "
             "a lot of doors leading off here, hopefully taking the plucky "
             "entrant a-wandering into Liaison workrooms.  Exercise caution "
             "as some Creators prefer you to ask or at least knock first.  "
             "Apart from the doors here there are some paintings of various "
             "people, as well as a large floor to ceiling mirror. Taking "
             "pride of place on one of the walls, however, is an ancient "
             "looking scroll housed in a picture frame.  There is "
             "also a sign here.\n");
    add_item("doors", "Lots of doors.  Tall doors, short doors, red doors, "
             "blue doors, green doors, thin doors, wide doors, old doors, "
             "grimy doors, wooden doors, metal doors and even a padded "
             "red linonium door - kinky.  However, you can only go through "
             "the doors marked in the exits, sorry.");
    add_item("paintings", "Paintings of people who have been important to "
             "the domain.  There's one of Ohdamn, Moonchild, Olorin, Shalla, "
             "Kaea, Nevvyn, Wyvyrn and - strangely enough - You.");
    add_item("painting of ohdamn", "The painting of Ohdamn shows a very "
             "tall man with reddish blond hair.  He appears to be carrying "
             "a box of chocolates and looks to be in the middle of a rousing "
             "love song, which may have something to do with the bottle of "
             "rum in his other hand.");
    add_item(({"mission", "scroll", "statement"}), "It's the liaison "
             "statement of mission!\n"
             "Or mission statement, if you would prefer.\n\n"
             "Our mission in the Liaison Domain is to give continuous "
             "support to the creator and player bases and facilitate "
             "communcation between them.\n"
             "Through a diverse range of activities, we aim to maintain "
             "Discworld MUD as an enjoyable, interesting, in-theme and "
             "safe virtual space.\n"
             "We seek to contribute to Discworld MUD as a visible and helpful "
             "helpful first point of creator contact for players.  Additionally, "
             "we will work within assigned creator areas to assist in the "
             "development and implementation of concepts.\n\n"
             "Impressive, huh?");
    add_alias("mission", "statement");
    add_item("frame", "It's just a frame holding a large scroll in place.");
    add_item("hair", "It's hair.  It's reddish blond and it's Ohdamn's.");
    add_item("rum", "It's rum.  Held very securely by Ohdamn.");
    add_item("chocolates", "They are chocolates.  On Ohdamn's painting.");
    add_item("painting of moonchild", "The painting of Moonchild shows a "
             "looming lady with a big whip and an evil grin.  She appears "
             "to be half in shadows.");
    add_item("whip", "A fearsome looking whip that seems to fit well in "
             "Moonchild's hand.");
    add_item("painting of olorin", "Olorin's picture appears to be only "
             "half done - as if the artist didn't have time to finish it.");
    add_item("painting of shalla", "Shalla's painting depicts a pretty "
             "lady and although she is fully clothed, your attention is "
             "drawn to her socks.  Strange.");
    add_item("socks", "Stop looking - that's illegal in some countries!");
    add_item("painting of kaea", "Kaea's painting shows a young lady with a "
             "silly looking grin on her face and giggling.  Seems to say it "
             "all really...");
    add_item("painting of nevvyn", "The painting of Nevvyn shows a man with a "
             "pint hefted in a salute and a cheeky looking grin on his face.");
    add_item("pint", "A half empty pint in Nevvyn's hand.  Says it all!");
    add_item("painting of wyvyrn", "Wyvyrn's painting depicts a ... well, a "
             "Wyvyrn.  He looks a bit like a dragon and has green wings - but "
             "seems to have the distinct disadvantage of looking cute.");
    add_item("wings", "Wings.  On Wyvyrn.");
    add_alias("painting of me", "painting of you");
    add_item("painting of you", "The painting of you is ... well, blank with the "
             "words 'Your Name Here' on it.  You get the feeling its a rather "
             "cheesy way of saying everyone is important!  If it wasn't so "
             "cheesy it might make you feel better.");
    add_sign("This is an important sign, for viewing along with the "
             "paintings.\n",
             "If you are having problems seeing the paintings, look at "
             "painting of <person>.  "
             "Please note: These paintings are done on collective images.  "
             "Basically, if you don't like your portrait, don't beat Luci "
             "up.  Thanks!");
    add_item("mirror", (: do_mirror() :));
    add_exit("common", "/d/liaison/common", "door");
    add_exit("drum", "/d/am/am/mendeddrum", "path");
}
string do_mirror() {
  string text;
  text = "The mirror is a full length floor to ceiling job, a full length "
    "mirror in the true sense of the word.  It's here to make sure you look "
    "you look your best.  Good job you are checking!\n\n";
  text += this_player()->long(this_player());
  tell_room (this_object(), this_player()->short() + " checks " +
    this_player()->query_objective() + "self in the big mirror.  Poser.\n",
    this_player());
  return text;
}

==================================================
FILE: liaison/master.c
==================================================

#define LORD "wyvyrn"
#define DOMAIN "liaison"
#include <liaison.h>
inherit "/std/dom/base_master";
mapping member_alias;
nosave string* member_cache = 0;
string query_lord() {
  return LORD;
}
string author_file(string *path) {
  return capitalize(DOMAIN);
}
int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}
int valid_read(string *path, string euid, string funct);
int valid_write(string *path, string euid, string funct);
int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
}
string log_who(string where) {
  return "eron";
}
string query_info() {
  if (file_size(LIAISON_DOMAIN_INFO) < 0) {
    return "\nFor information on this domain, please visit "
           "http:
  }
  return "\n"+ unguarded((: read_file(LIAISON_DOMAIN_INFO) :)) +"\n";
}
string *member_alias( string name ) {
   int i;
   if ( !member_alias )
      member_alias = ([ ]);
   if ( undefinedp( members[ name ] ) ) {
      map_delete(member_alias, name);
      return 0;
   }
   if ( !member_alias[ name ] )
      member_alias[ name ] = ({ });
   i = sizeof( member_alias[ name ] );
   while ( i-- )
      member_alias[ name ][ i ] = lower_case( member_alias[ name ][ i ] );
   return member_alias[ name ] + ({ });
}
int add_member_alias( string name, string alias ) {
   if ( !members[ name ] )
      return 0;
   if ( !"/secure/login"->test_user( alias ) )
      return 0;
   if ( !member_alias )
      member_alias = ([ ]);
   if ( !member_alias[ name ])
      member_alias[ name ] = ({ });
   member_alias[ name ] -= ({ alias });
   member_alias[ name ] += ({ alias });
   save_me();
   return 1;
}
int delete_member_alias( string name, string alias ) {
   if ( !members[ name ] )
      return 0;
   if ( !member_alias )
      member_alias = ([ ]);
   if ( !member_alias[ name ])
      member_alias[ name ] = ({ });
   member_alias[ name ] -= ({ alias });
   save_me();
   return 1;
}
string *query_unsorted_members() {
    return ::query_members();
}
string *query_members() {
    string* temporary_array = ({});
    string* first = ({});
    string* seniors = ({});
    string* newbies = ({});
    if (!member_cache) {
        first = ({ query_lord() })   +
                sort_array(query_deputies(),1);
        temporary_array = ::query_members() - first;
        temporary_array = sort_array( temporary_array, 1 );
        foreach ( string person in temporary_array ) {
          if ( master()->query_senior(person) ) {
              seniors += ({ person });
          }
        }
        temporary_array -= seniors;
        foreach ( string person in temporary_array ) {
          if ( regexp( members[ person ], "^(N|n)ewbie$" ) ) {
              newbies += ({ person });
          }
        }
        temporary_array -= newbies;
        member_cache = first + seniors + temporary_array + newbies;
    }
    return copy(member_cache);
}
string *query_projects() {
    return values(members);
}

==================================================
FILE: liaison/NEWBIE/advancement.c
==================================================

#include "path.h"
inherit PATH + "inside";
object sign;
void setup() {
  set_zone( "Newbie" );
  set_short("Advancement Room" );
  set_light( 75 );
  add_property("no teleport", 1);
  set_long( "This is a rather cosy room designed to encourage visitors to "
            "linger a while and read a few of the notices pinned to the "
            "walls.  The air is thick and overly warm, and there is a "
            "pervasive odour of stale tea, mothballs, and elderly ladies who "
            "collect rather more cats and string than they can properly "
            "handle.  "
            "Several overstuffed sofas have been grouped in the centre "
            "of the room along with wobbly occasional tables.  There is "
            "a small cage holding an odd-looking creature in one corner, "
            "and an immense ball of yarn in the other.  A door to the south "
            "leads back to the foyer.\n");
  add_item(({ "floor", "ground" }), "The floor is scuffed, dusty wood.  It "
           "was probably nice at some point.");
  add_item( "wall", "The walls (what can be seen of them under the notices) "
            "have been covered with a gaudy floral paper.");
  add_item(({ "paper", "wallpaper", "floral", "flower" }), "The wallpaper has "
            "a dark, muddy background covered with enormous fantasy flowers "
            "in red, blue, and yellow.");
  add_item( "door", "The plain wooden door has been propped open in an effort "
            "to let some of the stale air out.");
  add_item( "cage", "The cage is a small, rickety bamboo affair with a tiny "
            "door tied closed with a strand of wire.  It contains a strange "
            "creature.");
  add_item( "creature", "The creature is a pale, translucent colour.  It has "
            "long, spindly legs, big teeth, and eyes that glow like lamps "
            "when it is awake.  Even though it is small, you sense it would "
            "not be wise to disturb it.  It is holding a small card.");
  add_item( "wire", "The wire holding the cage door shut is a hopelessly "
            "twisted mass of spun octiron, the magical metal of Discworld.");
  add_item( "card", "The card is stamped 'Demon Local 45, Holywood' in "
            "fading ink.");
  add_item(({"ball", "yarn"}), "A large ball of string.");
  add_item("notice",
           ({ "long", "There are many of these pinned to the walls of the "
                "room.  Several catch your eye including ones marked "
                "'statistics', 'guildpoints', 'hitpoints', "
                "'skills' and 'advancement'.\n",
                "read", "There are many of these pinned to the walls of the "
                "room.  Several catch your eye including ones marked "
                "'statistics', 'guildpoints', 'hitpoints', "
                "'skills' and 'advancement'.\n"}));
  add_item("sofa", ({"long", "Several well-stuffed and well-worn sofas with "
                       "rather dirty, brown upholstery.",
                       "position", "a sofa",
                       "position multiple", 1 }));
  add_item("table", "A number of wobbly occasional tables made from "
           "some indeterminable kind of wood have been placed near the "
           "sofas.");
  sign=add_sign("A handwritten notice marked 'Statistics and Rearrange'.\n",
                "On Discworld your skill bonus typically determines your "
                "ability to perform a task.  Skill bonus is calculated "
                "from your skill level and your statistics.  Different "
                "stats affect different skills.\n"
                "Once you enter Discworld, you may rearrange your stats.  "
                "This should be done to improve your combination of "
                "constitution, dexterity, intelligence, strength and wisdom "
                "(your stats), but you are advised to wait until you have "
                "chosen a guild and have asked other guild members for "
                "advice.  Use the command 'rearrange' to do this, but "
                "consider it well, as you can only rearrange your stats "
                "once.\n", 0, "statistics", "general" );
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'statistics and rearrange'");
  sign=add_sign("A handwritten notice marked 'Guildpoints'.\n",
           "Guildpoints are a measure of your capability to perform guild "
           "commands such as stealing, fighting, casting spells or rituals, "
           "etc.  When you have used all your guild points, you will have to "
           "rest to allow them to regenerate.  For more information, type "
           "in 'help guildpoints'.\n", 0, "guildpoints", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'guild points'");
  sign=add_sign("A handwritten notice marked 'Experience'.\n",
           "In addition to the direct skill advances provided by the "
           "taskmaster, quest completion, using your guild commands "
           "and by doing certain tasks, you are rewarded with "
           "experience points or XP.  These may be spent in advancing skills "
                "from your guild or by learning from other players.\n", 0,
                "experience", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'experience'");
  sign=add_sign("A handwritten notice marked 'Hitpoints'.\n",
           "Hitpoints, or HP determine how much damage you can take in "
           "combat before you die.  The number of hit points you have is "
           "dependent upon your stats (mostly Con) and on your levels of "
           "other.health.  Hitpoints regenerate gradually over time.  "
           "There are also a variety of other ways to be healed.  You "
           "can use 'monitor' to keep track of your hitpoints.  See also "
           "'help wimpy'.\n", 0, "hitpoints", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'hitpoints'");
  sign=add_sign("A handwritten notice marked 'Skills'.\n",
           "To check your skill levels, use the command 'skills', and "
           "to see various statistics about yourself, use 'score'.  Your "
           "stats can also be reviewed using 'score stats'.  The command "
           "'help' will give you a variety of other topics with useful "
           "information.", 0, "skills", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'skills'");
  sign=add_sign("A handwritten notice marked 'advancement'.\n\n",
           "Skills can be advanced in a variety of ways on Discworld.  "
           "The guild you join will allow you to advance your skills "
           "for a certain number of experience points and a small fee.  "
           "When you reach the proper skill level your guild will "
           "teach you the commands that you will need to carry out "
           "your guild duties.\n"
           "You may also have another player teach you skills if they have "
           "a higher skill level than you, or you may teach yourself.  Both "
           "of these methods cost experience points, and it is generally more "
           "expensive to teach yourself.\n"
           "Finally, many of your skills can be advanced simply by performing "
           "tasks that make use of those skills.  For example, your fighting "
           "skills will get better as you participate in more fights.  For "
           "more information on this system, type "
           "'help taskmaster'.\n",0, "advancement", "general");
  sign->add_property("determinate","the ");
  sign->set_short("sign marked 'advancement'");
  add_property("no godmother", 1);
  add_exit( "foyer", PATH + "foyer", "door" );
  add_alias( "south", "foyer");
}

==================================================
FILE: liaison/NEWBIE/align.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
inherit PATH+"common";
object _wlever;
object _blever;
object _glever;
int do_pull(object lever);
void setup() {
  object sign;
  set_zone("Newbie");
  set_short("alignment room" );
  set_light( 75 );
  add_property("no teleport", 1);
  set_long( "This is a small, bare room that is quite empty apart from "
            "a lever stuck onto each of three walls and a small wooden "
            "sign placed in the centre of the room.\n"
            "A door to the east leads back to the foyer.\n");
  add_item(({"west wall", "south wall", "east wall"}),
           "A plain, flat wall with a lever sticking out of it.");
  sign=add_sign("A sign marked 'alignment'.\n",
                FOYER->format_sign(
           "Alignment is how good or evil you are.  This changes gradually "
           "depending on the things you do.  Because it changes so slowly "
           "you can choose to start out with a good, neutral or evil "
           "alignment.  To become evil, pull the black lever, to become "
           "good pull the white lever, and to stay neutral don't pull "
           "either lever, or pull the grey lever if you have already pulled "
           "one of the other ones.\n"),0,"sign","general");
  sign->set_short("sign");
  sign->add_adjective("wooden");
  add_property("no godmother", 1);
  add_exit( "foyer", PATH + "foyer", "door");
  add_alias( "east", "foyer");
  room_chat(({10, 40, ({"A voice which seems to come from the black lever "
                        "says: Don't be a goody-goody, pull me!",
                        "A voice which seems to come from the white lever "
                        "says: You should be nice, pull me!",
                        "A voice which seems to come from the grey lever "
                        "says: It's all about balance in the end."})}));
}
void init() {
  if (_wlever) {
     this_player()->add_command("pull", _wlever, "<direct:object>",
                              (: do_pull(_wlever) :));
  }
  if (_blever) {
     this_player()->add_command("pull", _blever, "<direct:object>",
                              (: do_pull(_blever) :));
  }
  if (_glever) {
     this_player()->add_command("pull", _glever, "<direct:object>",
                              (: do_pull(_glever) :));
  }
  ::init();
}
void reset() {
  if(!_wlever) {
    _wlever = clone_object("/std/object");
    _wlever->set_name("lever");
      _wlever->add_adjective("white");
    _wlever->set_short("white lever");
    _wlever->set_long("This is a lever which is set into the wall.  It "
                     "radiates a soft white glow.  The closer you stand "
                     "to it the more peaceful you feel.\n");
    _wlever->reset_get();
    _wlever->add_property("there", "on the east wall");
    _wlever->move(this_object());
  }
  if(!_blever) {
    _blever = clone_object("/std/object");
    _blever->set_name("lever");
    _blever->add_adjective("black");
    _blever->set_short("black lever");
    _blever->set_long("This is a lever which is set into the wall.  It "
                     "is pure black and emanates a deep, blood-red glow.  "
                     "The closer you get to it the more angry and hateful "
                     "you feel.\n");
    _blever->reset_get();
    _blever->add_property("there", "on the west wall");
    _blever->move(this_object());
  }
  if(!_glever) {
    _glever = clone_object("/std/object");
    _glever->set_name("lever");
    _glever->add_adjective("grey");
    _glever->set_short("grey lever");
    _glever->set_long("This is a lever which is set into the wall.  It "
                     "is a dull grey and very boring.\n");
    _glever->reset_get();
    _glever->add_property("there", "on the south wall");
    _glever->move(this_object());
  }
}
int do_pull(object lever) {
  int align;
  if(lever == _glever) {
    add_succeeded_mess(({ "$N $V $I and feel an overwhelming urge to do "
          "absolutely nothing about the world's problems.\n",
          "$N $V $I and suddenly looks very apathetic.\n" }),
          ({ _glever }));
    this_player()->set_al(0);
    return 1;
  }
  align = 300 + random(400);
  if(lever == _wlever) {
    align = -align;
  }
  this_player()->set_al(align);
  if(lever == _wlever) {
    add_succeeded_mess(({ "$N $V $I and suddenly feel$s like hugging "
          "everyone.\n",
          "$N $V $I and looks bright and cheery.\n" }),
          ({ _wlever }));
  } else {
    add_succeeded_mess(({ "$N $V $I and get a sudden urge to pull the "
          "wings off butterflies and torture small furry creatures.\n",
          "$N $V $I and a dark scowl crosses $p face.\n" }),
          ({ _blever }));
  }
  return 1;
}

==================================================
FILE: liaison/NEWBIE/assassins.c
==================================================

#include "path.h"
inherit PATH + "inside";
void setup() {
   set_short( "Assassins' gazebo" );
   set_light( 80 );
   add_property("no teleport", 1);
   set_long("This is a very comfortably furnished gazebo.  Obviously assassins "+
            "have excellent taste.  There is no sign at all of anything even "
            "remotely dangerous or threatening.  There is a large plaque on "
            "the wall explaining more about this rather enigmatic "
            "profession. You can view it by typing 'read sign'.\n"
            "A small, black, and elegant looking notice states that this is not "
            "where you actually join this guild.\n" );
   set_zone( "Newbie" );
   add_item("notice", "A small, black, and elegant looking notice that "
            "states that this is not where you actually join the guild.");
   add_item( ({ "furnishing" }), "The room is furnished in an expensive, "
            "although tasteful manner.  On the walls are a variety of "
            "quality oil paintings and the floor is covered with a thick "
            "carpet.  Against one wall is a chaise longue and in a corner "
            "is a well stocked drinks cabinet.");
   add_item("carpet", "A well-made carpet, thick and luxurious.");
   add_item("painting", "A variety of landscapes from some of the Disc's "
            "more notable painters.");
   add_item(({"chaise longue", "chaise", "longue"}),
            "Upholstered in the softest leather "
            "it looks very comfortable.");
   add_item(({"drink", "cabinet"}), "Its most notable feature is that it "
            "is locked.  Behind the glass door you can see a variety of "+
            "bottles, crystal decanters and glasses.");
   add_sign("A plaque entitled 'Guild of Assassins'\n",
            "The guild of assassins provides an excellent all-round "
            "education.  Graduates of the guild (graduation is by "+
            "competitive examination) will be skilled in a wide variety of "
            "subjects and able to move in all social circles.\n"
            "All assassins automatically become player killers (see "
            "'help playerkilling') on graduation.  This is not "+
            "a guild for the faint-hearted.  Becoming an assassin is a "
            "challenge.  Assassins are a proud guild, neither giving nor"
            " asking for information on how to join.\n", 0, 0, "general");
   add_property("no godmother", 1);
   add_exit( "garden", PATH +"guilds_foyer", "gate" );
}

==================================================
FILE: liaison/NEWBIE/choose_land.c
==================================================

#include "path.h"
#include <config.h>
#include <language.h>
#include <money.h>
inherit PATH+"inside";
#define DEBUG 1
#define LOG PATH + "save/CHOICE"
private mapping _nationalities;
private object _sign;
void setup() {
   string name;
   string nationality;
   string region;
  _nationalities = ([
       "pumpkin" : "/std/nationality/pumpkin"
     ]);
  add_property("no teleport", 1);
  add_property("determinate", "");
  add_property("no godmother", 1);
  set_zone( "Newbie" );
  set_short( "Discworld's realm of choice" );
  set_light( 75 );
  set_long("You are on a huge open-air platform far, far above the Disc itself.  "
           "Down below, the water tumbles and falls off the rim of the disc "
           "spilling down and out into a spray of mist over the elephants and "
           "the back of A'tuin, the great star turtle.  There are several "
           "sets of stairs leading down off the platform to the unknown and "
           "a large dial sits in the middle of the room.  A large sign "
           "shimmers and hangs in the air in the middle of the platform.\n");
  add_item(({ "disc", "Disc", "discworld"}),
           "You can see from the sharp spire of Cori "
           "Celesti at the centre, to the surrounding Circle Sea, "
           "the deserts of Klatch, the watery world of Krull, and the "
           "mysterious Counterweight Continent.  A spectacular rimbow "
           "sparkles where the seas pour over the edge of the Disc.  As "
           "you study the map's details, you are sure you saw one of the "
           "elephants move.");
  add_item("rimbow", "It's like a rainbow except that it's caused by the "
           "water pouring off the edge of the disc.");
  add_item("elephant", "These are the four elephants that bear the weight"
           " of the Disc.");
  add_item(({ "floor", "platform" }),
           "The floor is made of some weird black stone that is "
           "semi-transparent, allowing the Disc below you to be "
           "seen through it.");
  add_item(({ "stairs", "stairways" }), "Stairs leading down to the "
           "dark unknown.  They all appear to be crafted of some thin, "
           "spidery metal.");
  add_item("dial", "The dial is a huge heavy looking stone dial, with some "
                   "arrows and numbers carved into the surface.  They say "
                   "'Klatch 4000 miles', 'Ankh-Morpork 3000 miles', "
                   "'Lancre 3500 miles', 'Bes Pelargic 3000 miles'.");
   _sign = add_sign("A huge shimmering sign, the letters are transparent "
      "and it is possible to walk through it.\n",
      FOYER->format_sign(
      "Travellers choose your destination!  Which parts of the world "
      "do you want to explore?\n\n"
      "Look carefully at each of the lands "
      "before you make your choice - it determines the language you "
      "start with and your local accent, as well as where you start.\n\n"
      "The current list of available start nationalities is: " +
      query_multiple_short(keys(_nationalities)) + ".\n\n"
      "You can get 'info' on each nationality, and each region within "
      "a nationality.\n\n"
      "You choose your nationality with 'choose <nationality> <region>'; "
      "for example 'choose morpork Ankh-Morpork'.\n\n"
      "Use 'help here' for more help on 'info' and 'choose'.\n"),
      "shimmering sign", "sign", "general");
   foreach (name, nationality in _nationalities) {
      if (file_size(nationality + ".c") > 0) {
         add_item(name, nationality->query_information());
         foreach (region in nationality->query_regions()) {
            add_item(name + " " + lower_case(region), nationality->query_region_description(region));
         }
      } else {
         printf("Bad nationality %O\n", nationality);
      }
   }
   add_help_file(PATH + "doc/choose_land");
}
string find_region(string nationality, string region) {
   string tmp;
   foreach (tmp in nationality->query_regions()) {
      if (lower_case(tmp) == lower_case(region)) {
         return tmp;
      }
   }
   return 0;
}
void change_nationality(object person, string nationality, string region) {
   string old_nationality;
   int old_speak;
   int old_write;
   int new_speak;
   int new_write;
   string skill_speak;
   string skill_write;
   string lang;
   string guild;
   mixed newbie;
   nationality = _nationalities[nationality];
   old_nationality = this_player()->query_nationality();
#ifdef DEBUG
   debug_printf("Old nationality was %O, new nationality is %O.\n", old_nationality, nationality);
#endif
   lang = nationality->query_language();
   skill_speak = LANGUAGE_HAND->query_language_spoken_skill(lang);
   skill_write = LANGUAGE_HAND->query_language_written_skill(lang);
   old_speak = this_player()->query_skill(skill_speak);
   old_write = this_player()->query_skill(skill_write);
   if (old_speak > 100) {
      old_speak = 100;
   }
   this_player()->add_skill_level(skill_speak, 100 - old_speak);
   if (old_write > 100) {
      old_write = 100;
   }
   this_player()->add_skill_level(skill_write, 100 - old_write);
   if (old_nationality &&
       old_nationality->query_language() != nationality->query_language()) {
      lang = old_nationality->query_language();
      skill_speak = LANGUAGE_HAND->query_language_spoken_skill(lang);
      skill_write = LANGUAGE_HAND->query_language_written_skill(lang);
      new_speak = this_player()->query_skill(skill_speak);
      new_write = this_player()->query_skill(skill_write);
      if (new_speak > 100) {
         new_speak = 100;
      }
      this_player()->add_skill_level(skill_speak, old_speak - new_speak);
      if (new_write > 100) {
         new_write = 100;
      }
      this_player()->add_skill_level(skill_write, old_write - new_write);
   }
   this_player()->set_nationality(nationality);
   this_player()->set_nationality_region(find_region(nationality, region));
   lang = nationality->query_language();
   this_player()->set_default_language(lang);
   this_player()->set_language(lang);
   guild = this_player()->query_guild_ob();
   newbie = this_player()->query_property("not real newbie");
   log_file( LOG , "%s:\n   %s the %s%s chose %s (%s)\n",
      ctime(time()),
      this_player()->query_short(),
      guild ? capitalize(guild[12..<1]) : "Adventurer",
      newbie ? "" : " (newbie)",
      capitalize(this_player()->query_nationality_region()),
      capitalize(this_player()->query_nationality()[17..<1]));
   if (!this_player()->query_property("not real newbie")) {
      int value;
      string currency_area = "";
      mixed* array;
      value = this_player()->query_value_in("Newbie Area");
      currency_area = this_player()->query_nationality()->query_currency_area();
      if (this_player()->query_nationality_region() == "Sto Lat" ) {
         currency_area = "default";
      }
      tell_creator( "wyvyrn" ,
         "[ %s the %s%s picked %s and got money for %s ]\n",
         this_player()->query_short(),
         guild ? capitalize(guild->query_name()[0..<2]) : "Adventurer",
         newbie ? "" : " (newbie)",
         this_player()->query_nationality_region(),
         currency_area);
      array = MONEY_HAND->create_money_array(value, currency_area);
      this_player()->set_money_array(array);
   } else {
      object ob;
      foreach (ob in all_inventory()) {
         if (!living(ob) && ob->query_short() != "shimmering sign") {
            ob->move(nationality->query_region_start_location(region));
         }
      }
      tell_creator( "wyvyrn" ,
         "[ %s the %s%s picked %s and kept their money ]\n",
         this_player()->query_short(),
         guild ? capitalize(guild->query_name()[0..<2]) : "Adventurer",
         newbie ? "" : " (newbie)",
         this_player()->query_nationality_region());
   }
}
int setup_nationality(string direction, object person) {
   string* bits;
   bits = explode(direction, " ");
   change_nationality(person, bits[1], implode(bits[2..], " "));
   return 1;
}
int do_choose(string nat, string region) {
   string region_new;
   string nationality;
   string loc;
   nationality = lower_case(nat);
   if (!_nationalities[nationality]) {
      add_failed_mess("There is no nationality " + nationality + ".\n");
      return 0;
   }
   nat = nationality;
   nationality = _nationalities[nationality];
   region_new = find_region(nationality, region);
   if (!region_new) {
      add_failed_mess("Cannot find the region " + region +
                      " in the nationality " + nat + ".  It must be "
                      "one of " +
                      query_multiple_short(nationality->query_regions()) + ".\n");
      return 0;
   }
#ifdef DEBUG
   debug_printf("Nationality is %O, region is %O, player is %O.\n",
      nationality, region_new, this_player()->query_short());
#endif
   change_nationality(this_player(), nat, region_new);
   loc = nationality->query_region_start_location(region_new);
   this_player()->move_with_look(loc, "$N arrive$s into the world.",
                                 "$N disappears to a better life.");
   this_player()->remove_property("not real newbie");
   if (clonep(this_object())) {
      call_out((: dest_me :), 10);
      if (_sign) {
         _sign->dest_me();
      }
   }
   return 1;
}
int do_info(string nat, string region) {
   string region_new;
   string nationality;
   nationality = lower_case(nat);
   if (!_nationalities[nationality]) {
      add_failed_mess("There is no nationality " + nationality + ".\n");
      return 0;
   }
   nationality = _nationalities[nationality];
   region_new = find_region(nationality, region);
   if (!region_new) {
      add_failed_mess("Cannot find the region " + region +
                      " in the nationality " + nat + ".  It must be "
                      "one of " +
                      query_multiple_short(nationality->query_regions()) + ".\n");
      return 0;
   }
#ifdef DEBUG
   debug_printf("Nationality is %O, region is %O, player is %O.\n",
      nationality, region_new, this_player()->query_short());
#endif
   write(nationality->query_region_description(region_new) + "\n");
   return 1;
}
int do_nationality_info(string nationality) {
   string ret;
   string region;
   nationality = lower_case(nationality);
   if (!_nationalities[nationality]) {
      add_failed_mess("There is no nationality " + nationality + ".\n");
      return 0;
   }
   nationality = _nationalities[nationality];
   ret = nationality->query_information() +
         "Regions you can choose:\n";
   foreach (region in nationality->query_regions()) {
      ret += "  * " + region + "\n";
   }
   write(ret);
   return 1;
}
void init() {
  add_command("info", "<word'nation'>", (: do_nationality_info($4[0]) :));
  add_command("info", "<word'nation'> <string'region'>", (: do_info($4[0], $4[1]) :));
  add_command("choose", "<word'nationality'> <string'region'>", (: do_choose($4[0], $4[1]) :));
}
void fixup_player(object player) {
   object ob;
   ob = clone_object(__FILE__);
   player->move_with_look(ob);
}
string query_quit_handler() {
   return __FILE__;
}

==================================================
FILE: liaison/NEWBIE/combat.c
==================================================

#include "path.h"
#define MAX 100;
inherit PATH+"inside";
object instructor;
object sign;
void setup() {
  set_zone( "Newbie" );
  set_short("Combat Training Room");
  add_property("determinate", "");
  set_light( 75 );
  add_property("no teleport", 1);
  set_long("This is a small training room, designed to help the new "
           "adventurer get off to a good start on Discworld.  The air is "
           "stale with the combined stench of sweat, beer, and old "
           "warriors.  There is a small sign attached to the wall.\n");
  add_item( "floor", "The floor is made of flagstones, cemented together "
            "with centuries of accumulated muck.\n");
  add_item( "wall", "The walls are marked with mysterious stains that may or "
            "may not be blood.  But surely training dummies don't bleed.\n");
  add_item( "ceiling", "The ceiling appears to be dingy patches of plaster "
            "stuck between old oak rafters that have turned black with "
            "age.\n");
  add_property("no godmother", 1);
  add_exit( "foyer", PATH + "foyer", "door" );
  add_alias( "southwest", "foyer");
  add_exit("one", PATH + "combat_room1", "door");
  add_exit("two", PATH+"combat_room2", "door");
  add_exit("three", PATH+"combat_room3", "door");
  modify_exit("one", ({"function", "check_room", "closed", 1,
                         "look", "It is the door to training room one.\n"}));
  modify_exit("two", ({"function", "check_room", "closed", 1,
                         "look", "It is the door to training room two.\n"}));
  modify_exit("three", ({"function", "check_room", "closed", 1,
                         "look", "It is the door to training room three.\n"}));
}
void reset() {
  if(!sign) {
    sign=add_sign("This is a sign stuck to the wall.  It contains "
                  "instructions on how to use this room.\n",
                  "Welcome to the newbie combat area!  If you would like "
                  "to practise your combat skills just ask Greg.  To do "
                  "this say \"can I practise please\".",
                  0, "sign", "general");
  }
}
void dest_me() {
  if(sign)
    sign->dest_me();
  if(instructor)
    instructor->dest_me();
  ::dest_me();
}
void init() {
  call_out("get_instructor", 0);
}
void get_instructor() {
  if(!instructor)
    instructor = load_object(PATH +"greg");
  if(instructor && environment(instructor) != this_object()) {
    instructor->move( this_object(), "$N marches in from another room.");
  }
}
int check_room(string str, object ob, string special_mess) {
  int room;
  switch(str) {
  case "one":
    room = 0;
    break;
  case "two":
    room = 1;
    break;
  case "three":
    room = 2;
  }
  if(ob == instructor)
    return 1;
  if(!instructor || instructor->query_using(room) != ob) {
    tell_object(ob, "The door slams closed in your face.\n");
    modify_exit("one", ({ "closed", 1}));
    return notify_fail("");
  }
  return 1;
}

==================================================
FILE: liaison/NEWBIE/combat_room1.c
==================================================

#include "path.h"
#define MAX 100;
inherit PATH + "inside";
string *arr0;
object sign, dummy, trainer;
void setup() {
  set_short("Xrazzicaz' Boot Camp");
  add_property("determinate", "");
  set_light( 75 );
  add_property("no teleport", 1);
  set_long("This is a small training room, designed to help the new "
           "adventurer get off to a good start on Discworld.  The air is "
           "stale with the combined stench of sweat, beer, and old "
           "warriors.  Off to one side is a rather unusual training "
           "dummy above which is a small plaque.\n");
  add_item( "face", "As you stare at it, squinting and turning your head "
            "side to side, you realise it looks rather like your old maths "
            "teacher!\n");
  add_item( "floor", "The floor is made of flagstones, cemented together "
            "with centuries of accumulated muck.\n");
  add_item( "wall", "The walls are marked with mysterious stains that may or "
            "may not be blood.  But surely training dummies don't bleed.\n");
  add_item( "ceiling", "The ceiling appears to be dingy patches of plaster "
            "stuck between old oak rafters that have turned black with "
            "age.\n");
  add_property("no godmother", 1);
  add_exit( "combat", PATH + "combat", "door" );
  add_alias( "southeast", "foyer");
}
void reset() {
  if(!sign) {
    sign=add_sign("This is a plaque that seems to describe how to have "
                  "your combat skills assessed.\n", "To assess your "
                  "skills, attack the dummy with the weapon you want to "
                  "test your proficiency in.  Each time you hit the "
                  "dummy, the instructor will comment on your "
                  "performance.  After a number of rounds, the "
                  "instructor will stop you and give you an overall "
                  "performance rating.\n\n"
                  "Don't forget to hold your weapon of choice before "
                  "attacking the training dummy!\n",
                  "small plaque", "plaque", "general");
    sign->add_property("there", "on the wall");
  }
  if(!dummy)
    dummy = clone_object(PATH + "dummy");
  dummy->move(this_object());
  call_out("get_trainer", 1);
}
void dest_me() {
  if(sign)
    sign->dest_me();
  if(dummy)
    dummy->dest_me();
  if(trainer)
    trainer->dest_me();
  ::dest_me();
}
void get_trainer() {
  if(!trainer)
    trainer = clone_object(PATH +"trainer");
  if (trainer) {
    trainer->whichone("xrazzicaz");
    trainer->move( this_object(), "$N hobble$s toward you on his straw-filled stumps." );
    dummy->set_trainer(trainer);
  }
}
void stop_them(object who) {
  if(trainer && dummy)
    trainer->stop_them(who, dummy);
}
string query_quit_handler() {
  return "/d/liaison/NEWBIE/combat";
}

==================================================
FILE: liaison/NEWBIE/combat_room2.c
==================================================

#include "path.h"
#define MAX 100;
inherit PATH + "inside";
string *arr0;
object sign, dummy, trainer;
void setup() {
  set_short("Zazzifraz' Boot Camp");
  add_property("determinate", "");
  set_light( 75 );
  add_property("no teleport", 1);
  set_long("This is a small training room, designed to help the new "
           "adventurer get off to a good start on Discworld.  The air is "
           "stale with the combined stench of sweat, beer, and old "
           "warriors.  Off to one side is a rather unusual training "
           "dummy above which is a small plaque.\n");
  add_item( "face", "As you stare at it, squinting and turning your head "
            "side to side, you realise it looks rather like your old maths "
            "teacher!\n");
  add_item( "floor", "The floor is made of flagstones, cemented together "
            "with centuries of accumulated muck.\n");
  add_item( "wall", "The walls are marked with mysterious stains that may or "
            "may not be blood.  But surely training dummies don't bleed.\n");
  add_item( "ceiling", "The ceiling appears to be dingy patches of plaster "
            "stuck between old oak rafters that have turned black with "
            "age.\n");
  add_property("no godmother", 1);
  add_exit( "combat", PATH + "combat", "door" );
  add_alias( "northwest", "combat");
}
void reset() {
  if(!sign) {
    sign=add_sign("This is a plaque that seems to describe how to have "
                  "your combat skills assessed.\n", "To assess your "
                  "skills, attack the dummy with the weapon you want to "
                  "test your proficiency in.  Each time you hit the "
                  "dummy, the instructor will comment on your "
                  "performance.  After a number of rounds, the "
                  "instructor will stop you and give you an overall "
                  "performance rating.\n\n"
                  "Don't forget to hold your weapon of choice before "
                  "attacking the training dummy!\n",
                  "small plaque", "plaque", "general");
    sign->add_property("there", "on the wall");
  }
  if(!dummy)
    dummy = clone_object(PATH + "dummy");
  dummy->move(this_object());
  call_out("get_trainer", 1);
}
void dest_me() {
  if(sign)
    sign->dest_me();
  if(dummy)
    dummy->dest_me();
  if(trainer)
    trainer->dest_me();
  ::dest_me();
}
void get_trainer() {
  if(!trainer)
    trainer = clone_object(PATH +"trainer");
  if (trainer) {
    trainer->whichone("zazzifraz");
    trainer->move( this_object(), "$N hobble$s toward you on his straw-filled stumps." );
    dummy->set_trainer(trainer);
  }
}
void stop_them(object who) {
  if(trainer && dummy)
    trainer->stop_them(who, dummy);
}
string query_quit_handler() {
  return "/d/liaison/NEWBIE/combat";
}

==================================================
FILE: liaison/NEWBIE/combat_room3.c
==================================================

#include "path.h"
#define MAX 100;
inherit PATH + "inside";
string *arr0;
object sign, dummy, trainer;
void setup() {
  set_short("John's Boot Camp");
  add_property("determinate", "");
  set_light( 75 );
  add_property("no teleport", 1);
  set_long("This is a small training room, designed to help the new "
           "adventurer get off to a good start on Discworld.  The air is "
           "stale with the combined stench of sweat, beer, and old "
           "warriors.  Off to one side is a rather unusual training "
           "dummy above which is a small plaque.\n");
  add_item( "face", "As you stare at it, squinting and turning your head "
            "side to side, you realise it looks rather like your old maths "
            "teacher!\n");
  add_item( "floor", "The floor is made of flagstones, cemented together "
            "with centuries of accumulated muck.\n");
  add_item( "wall", "The walls are marked with mysterious stains that may or "
            "may not be blood.  But surely training dummies don't bleed.\n");
  add_item( "ceiling", "The ceiling appears to be dingy patches of plaster "
            "stuck between old oak rafters that have turned black with "
            "age.\n");
  add_property("no godmother", 1);
  add_exit( "combat", PATH + "combat", "door" );
  add_alias( "southeast", "foyer");
}
void reset() {
  if(!sign) {
    sign=add_sign("This is a plaque that seems to describe how to have "
                   "your combat skills assessed.\n", "To assess your "
                   "skills, attack the dummy with the weapon you want to "
                   "test your proficiency in.  Each time you hit the "
                   "dummy, the instructor will comment on your "
                   "performance.  After a number of rounds, the "
                   "instructor will stop you and give you an overall "
                   "performance rating.\n\n"
                   "Don't forget to hold your weapon of choice before "
                   "attacking the training dummy!\n",
                   "small plaque", "plaque", "general");
    sign->add_property("there", "on the wall");
  }
  if(!dummy)
    dummy = clone_object(PATH + "dummy");
  dummy->move(this_object());
  call_out("get_trainer", 1);
}
void dest_me() {
  if(sign)
    sign->dest_me();
  if(dummy)
    dummy->dest_me();
  if(trainer)
    trainer->dest_me();
  ::dest_me();
}
void get_trainer() {
  if(!trainer)
    trainer = clone_object(PATH +"trainer");
  if (trainer) {
    trainer->whichone("john");
    trainer->move( this_object(), "$N hobble$s toward you on his straw-filled stumps." );
    dummy->set_trainer(trainer);
  }
}
void stop_them(object who) {
  if(trainer && dummy)
    trainer->stop_them(who, dummy);
}
string query_quit_handler() {
  return "/d/liaison/NEWBIE/combat";
}

==================================================
FILE: liaison/NEWBIE/common.c
==================================================

void dest_money(object coins) {
  if(coins->query_number_coins() > 1)
    tell_room(this_object(), "As the coins hit the ground they "
              "slip between the cracks and disappear.\n");
  else
    tell_room(this_object(), "As the coin hits the ground it "
              "slips between the cracks and disappears.\n");
  coins->move("/room/rubbish");
}
#ifdef 0
void event_enter(object ob, string mess, object from) {
  if(base_name(ob) == "/obj/money") {
    call_out("dest_money", 0, ob);
  }
  return;
}
#endif

==================================================
FILE: liaison/NEWBIE/communication.c
==================================================

#include "path.h"
inherit PATH + "inside";
object sign;
void setup() {
  set_zone( "Newbie" );
  set_short( "Communication room" );
  set_light( 75 );
  add_property("no teleport", 1);
  set_long("This small room seems to be filled with frogs which are bouncing "
           "around, wombling on and chattering away like crazy.  Around the "
           "walls are a number of posters that describe various aspects of "
           "communication on Discworld.  There are posters on 'general', "
           "'speaking', 'expression', 'emote', 'newbie' and "
           "'mail'.\n");
  add_item("frog", "There are small green frogs everywhere.  They seem very "
           "excited and are moshing, sniggering, hugging,... you name it, "
           "they are doing it.");
  add_item("poster", "There are several of these around the room.  To look "
           "at a particular poster type 'look' and the name of the "
           "poster.");
  add_item("wall", "It is hard to make out much of the walls behind the "
           "posters, but what you can see is painted a subtle sunflower "
           "yellow.");
  add_item("floor", "The floor is composed of stone slabs and covered "
           "with frogs.");
  sign=add_sign("A poster entitled 'What Do You Mean?'\n",
           "If you are new to online communication you may be surprised how "
           "easy it is to misunderstand and to be misunderstood when you "
           "only have typed words to go on.  So please take care in how you "
           "word things and also be prepared to seek clarification before "
           "getting upset with someone, they may not have meant it how you "
           "read it!", 0, "general", "general");
  sign->set_short("sign marked 'general'");
  sign->add_property("determinate","the ");
  sign=add_sign("A poster entitled 'It's Good To Talk'\n",
           "There are a number of ways to communicate verbally.\n"
           "To speak to everyone in the same room as yourself use the "
           "command 'say', 'lsay' (loud say).  To speak to an individual "
           "you may use 'whisper' if they are in the same room, or "
           "'tell' if they are elsewhere on the disc.  You may also "
           "'shout' which will be heard by everyone who is nearby, however "
           "shouting uses up social points which will regenerate slowly.\n",
           0, "speaking", "general");
  sign->set_short("sign marked 'speaking'");
  sign->add_property("determinate","the ");
  sign=add_sign("A poster entitled 'Womble On'\n",
           "Discworld also has a soul which allows you some emotional "
           "expression, thus you can 'laugh' or 'cry'.  There are "
           "approximately 550 soul commands so they are not listed here.  "
           "Use 'help soul' and 'look soul' to find out more about "
           "them.\n", 0, "expression", "general");
  sign->set_short("sign marked 'expression'");
  sign->add_property("determinate","the ");
  sign=add_sign("A poster entitled 'Laugh In An Old Fashioned Way'\n",
           "Emote allows free expression.  If Jim used 'emote jumps around "
           "in a slightly artistic manner' everyone in the room would see "
           "him do just that.  Initially you will not be able to emote, you "
           "must learn that skill.", 0, "emote", "general");
  sign->set_short("sign marked 'emote'");
  sign->add_property("determinate","the ");
  sign=add_sign("A poster entitled 'What Do You Mean?'\n",
           "For the first day of your time on Discworld you will have access "
           "to the newbie chat channel which is listened to by most creators "
           "and many of the players.  You may use this channel to ask for "
           "help and advice.  To use the channel type 'newbie <message>'"
           ", and to see the last few messages type 'hnewbie'.\n",
           0, "newbie", "general");
  sign->set_short("sign marked 'newbie'");
  sign->add_property("determinate","the ");
  sign=add_sign("A poster entitled 'But You're Not There'\n",
           "Discworld provides a mail system which allows you to send "
           "messages to players who are not currently logged in.  You must "
           "go to the post office to read or send mail.\n"
           "There are also a number of bulletin boards around the place on "
           "which people can place public messages.  The frog board is in "
           "the Mended Drum and the newspaper board is in the offices of "
           "the Ankh-Morpork Daily Times.  Your guild will also have a "
           "board located somewhere in the guildhouse.\n", 0, "mail", "general");
  sign->set_short("sign marked 'mail'");
  sign->add_property("determinate","the ");
  add_property("no godmother", 1);
  room_chat(({120, 240, ({"A small frog bumps into you, apologises "
                            "profusely, and hops off.",
                            "A frog leaps up and down excitedly.",
                            "A frog wombles around you happily.",
                            "A frog bingles happily.",
                            "A frog parps wryly at you."})}));
  add_exit( "foyer", PATH + "foyer", "door" );
  add_alias( "west", "foyer" );
}

==================================================
FILE: liaison/NEWBIE/dummy.c
==================================================

inherit "/obj/monster";
#include <armoury.h>
#include <weapon.h>
#include <tasks.h>
#include <combat.h>
int told_attack, told_parry, ability;
string *misc;
object trainer, trainee;
#define DODGE "fighting.combat.dodging.melee"
#define PARRY "fighting.combat.parry.melee"
#define PERSON_DODGE_FAILURE "As the dummy spins around, an arm swings towards you and hits you before you can dodge out of the way!\n"
#define ROOM_DODGE_FAILURE " isn't fast enough to dodge a spinning arm!  Ouch!\n"
#define PERSON_DODGE_SUCESS "As the dummy spins around, an arm swings towards you but you see it in time and dodge it.\n"
#define ROOM_DODGE_SUCESS " dodges the arm of the wooden training dummy.\n"
#define PERSON_PARRY_FAILURE "As the dummy spins around, an arm swings towards you but you are unable to block it!\n"
#define ROOM_PARRY_FAILURE " isn't fast enough to avoid the training dummy! Ouch!\n"
#define PERSON_PARRY_SUCCESS "As the dummy spins around, an arm swings towards you but you see it in time and block it.\n"
#define ROOM_PARRY_SUCCESS " parries the training dummy.\n"
#define MISC_MESSAGES ({ "Generally, heavier weapons are harder to attack and "\
  "parry with but their attacks are harder to parry.", \
  "Being burdened in combat, by carrying lots of things or wearing lots of " \
  "armour, reduces your effectiveness.  This is especially true for dodging.", \
  "When injured it is harder to fight, so watch your health closely.", \
  "Holding a two-handed weapon in one hand can be useful when using a shield "\
  "but is hard to do unless you have high strength.", \
  "You can focus on specific parts of your opponents body to take advantage " \
  "of weaknesses in their armour but this is harder to do than attacking " \
  "normally."})
#define DIFF 15
#define MOD 10
int assault_dummy();
mixed *callback(int stage, class attack att, mixed data);
void failed_defense( object );
void failed_attack( object );
void tell_misc( object );
void spin_arm( object, object );
object query_trainer() {
  return trainer;
}
object reset_trainer() {
  trainer = 0;
}
object set_trainer( object thing ) {
  return trainer = thing;
}
object query_trainee() {
  return trainee;
}
object reset_trainee() {
  trainee = 0;
}
object set_trainee( object thing ) {
  return trainee = thing;
}
int query_skill_bonus( string words ) {
  return 10;
}
void setup() {
  set_name( "dummy" );
  add_adjective( ({ "wood", "wooden", "training" }) );
  set_short( "training dummy" );
  set_long( "A fighters dummy.  It is looking pretty worn from having "+
    "all the stuffing knocked out of it all day.\n");
  basic_setup( "human", "warrior", 10 );
  set_gender( 0 );
  add_property( "run away", -1 );
  set_dex(6);
  set_str(6);
  set_con(18);
  set_int(6);
  set_wis(6);
  remove_ac( "sharp" );
  remove_ac( "pierce" );
  remove_ac( "blunt" );
  remove_ac( "unarmed" );
  add_skill_level( "other.health", 1000 );
  add_combat_action( 100, "spin_arm", (: spin_arm :) );
  ARMOURY->request_item( "dirty rags", 30 )->move( this_object() );
}
int attack_this_time() {
  return 0;
}
void init() {
  if( this_player() ) {
    this_player()->add_command( "kill", this_object(), "{dummy}",
      (: assault_dummy() :) );
    this_player()->add_command( "attack", this_object(), "{dummy}",
      (: assault_dummy() :) );
  }
}
int assault_dummy() {
  object *weapons, weapon;
  int i;
  if( trainer->query_fighting() ) {
    write( "You beat at and tear up " + this_object()->the_short() +
      " for a while until you get bored.\n" );
    say( this_player()->query_short() + " hacks at " +
      this_object()->the_short() + " for a while.\n", this_player() );
  }
  if( trainee && !interactive( trainee ) )
    reset_trainee();
  if( trainee ) {
    if( trainee->query_fighting() ) {
      if( trainee == this_player() ) {
        tell_object( this_player(), "You are already using " +
          this_object()->the_short() + ".\n" );
        return notify_fail( "" );
      }
      tell_object( this_player(), trainee->one_short() + " is currently "
        "using " + this_object()->the_short() + ".\n" );
      return notify_fail( "" );
    }
  }
  weapon = 0;
  ability = 0;
  told_attack = 0;
  told_parry = 0;
  misc = copy(MISC_MESSAGES);
  weapons = (object *)this_player()->query_weapons();
  if( sizeof( weapons ) > 1 ) {
    trainer->stop_them( previous_object(), this_object() );
    trainer->do_command( "say Just use one weapon, I get confused if you use "
      "more than one!" );
    return 1;
  }
  if( sizeof( weapons ) && !weapon )
    weapon = weapons[ 0 ];
  this_player()->attack_ob( this_object() );
  write( "You attack " + this_object()->the_short() + ".\n" );
  say( this_player()->the_short() + " attacks " + this_object()->a_short() +
    ".\n", this_player() );
  trainee = this_player();
  for( i = 0; i < sizeof( ( class combat_special )this_object()->
    query_specials() ); i++ ) {
      this_object()->remove_special( ( class combat_special )this_object()->
        query_specials()[i]->id );
  }
  this_object()->register_special( T_DEFENSIVE,
                                   E_AFTER_ATTACK,
                                   ({ this_object(), "callback" }),
                                   ({ 0, 0, weapon }) );
  return 1;
}
int attack_by(object ob) {
  if(!sizeof(query_specials()))
    call_out("attack_dummy", 0);
  return ::attack_by(ob);
}
mixed *callback( int stage, class attack att, mixed data ) {
  int *rating, number, damage, last_damage;
  object dumdum, newbie, *weapons, weapon;
  string what, skill;
  mixed *attacks;
  newbie = att->attacker;
  dumdum = att->opponent;
  weapons = (object *)this_player()->query_weapons();
  if( sizeof( weapons ) > 1 ) {
    trainer->stop_them( newbie, dumdum );
    trainer->do_command( "say Just use one weapon, I get confused if you use "
      "more than one!" );
    debug_printf( "More than one weapon, removing special.\n" );
    return({ R_CONTINUE | R_REMOVE_ME, att, data });
  }
  if( sizeof( weapons ) && !weapon )
    weapon = weapons[ 0 ];
  if( weapon != data[2] ) {
    trainer->stop_them( newbie, dumdum );
    trainer->do_command( "say You've changed weapons!" );
    debug_printf( "Changed weapons, removing special.\n" );
    return({ R_CONTINUE | R_REMOVE_ME, att, data });
  }
  last_damage = data[1];
  damage = att->damage;
  data[1] = damage;
  if( !last_damage) {
    failed_attack(newbie);
  }
  if(last_damage || !random(4)) {
    if( weapon ) {
      attacks = weapon->query_attack_data();
      skill = attacks[random( sizeof( attacks ) / W_ARRAY_SIZE ) *
        W_ARRAY_SIZE + W_SKILL];
    } else {
      skill = "unarmed";
    }
    if( newbie->query_skill( "fighting.combat.melee." + skill ) < 5 &&
       !random( 4 * ( newbie->query_skill( "fighting.combat.melee." +
       skill ) ) ) &&
       newbie->add_skill_level( "fighting.combat.melee." + skill, 1, 1 ) ) {
      if( skill == "unarmed" )
         tell_object( newbie, "%^YELLOW%^You feel you've learned something "
          "about unarmed combat.%^RESET%^\n" );
       tell_object( newbie, "%^YELLOW%^You feel you've learned something about "
         "using " + weapon->a_short() + ".%^RESET%^\n" );
    }
  }
  if( data[0]++ > 15 ) {
    number = ( 2 * (ability + data[0]) ) / ( 2 * data[0] );
    if( weapon )
      what = convert_message( ( string )weapon->the_short() );
    else
      what = "whatever it was you were using";
    trainer->stop_them( newbie, dumdum );
    trainer->do_command( "think" );
    switch ( number ) {
    case 0..1 :
      if( skill == "unarmed" )
        trainer->do_command( "say Well, you're rather hopeless." );
      else {
        if( strsrch( what, "knife" ) == -1 && strsrch( what, "dagger" ) == -1)
          trainer->do_command( "say Well, you're rather hopeless with " + what +
            ", really.  A lighter, simpler weapon may help." );
        else
          trainer->do_command( "say Well, you're rather hopeless with " + what +
            ", really, but with practice you'll get better.");
      }
      break;
    case 2 .. 3 :
      if( skill == "unarmed" )
        trainer->do_command( "say Hmmm... You have some skill." );
      trainer->do_command( "say Hmmm... You have some skill with " + what +
        ", at any rate, as you practice you'll get better." );
      break;
    case 4 .. 5 :
      if( skill == "unarmed" )
        trainer->do_command( "say You're getting there.  Keep training and "
          "you'll be pretty good soon." );
      trainer->do_command( "say You're getting there.  Keep training with " +
        what + " and you'll be pretty good with it soon." );
      break;
    default :
      if( skill == "unarmed" )
        trainer->do_command( "say I'd say you've more or less mastered unarmed "
          "combat.  Well done!" );
      trainer->do_command( "say I'd say you've more or less mastered " + what +
        ".  Well done!" );
    }
    trainee = 0;
    return({ R_CONTINUE | R_REMOVE_ME, att, data });
  }
  tell_misc(newbie);
  if( !damage) {
    return ({ R_CONTINUE, att, data });
  }
  if( skill == "unarmed" ) {
    rating = (int *)"/cmds/guild-race/other/judge"->calc_rating( newbie );
  } else {
    rating = (int *)"/cmds/guild-race/other/judge"->calc_rating( weapon );
  }
  if( !rating[0] )
    rating [0] = random( 10 ) + 30;
  if( !rating[1] )
    rating [1] = random( 80 ) + 60;
  number = ( ( 40 * damage ) / rating[ 0 ] +
             ( 20 * damage ) / rating[ 1 ] ) / 5;
  debug_printf("%d", number);
  ability += number;
  if (number > 14)
    number = 14;
  trainer->do_command( "say That's " + ({ "an atrocious", "an extremely poor",
    "a very poor", "a rather poor", "a poor", "a pretty poor", "quite a poor",
    "a reasonable", "quite a good", "a pretty good", "a good", "a rather "
    "good", "a very good", "an extremely good", "an excellent" })
    [ number ] + " attack." );
  return ({ R_CONTINUE, att, data });
}
void spin_arm( object newbie, object dumdum ) {
  int diff, which, failed;
  if( environment( newbie ) != environment( this_object() ) )
     return;
  switch( ( ( class tactics )newbie->query_tactics() )->attitude ) {
  case "offensive":
    diff = DIFF + MOD;
    break;
  case "defensive":
    diff = DIFF - MOD;
    break;
  default:
    diff = DIFF;
  }
  switch( newbie->query_combat_response() ) {
  case "dodge" :
    which = 1;
    break;
  case "parry":
    which = 0;
    break;
  default:
    which = random( 2 );
  }
  if( which ) {
    switch( TASKER->perform_task( newbie, DODGE, diff, TM_FIXED ) ) {
      case FAIL :
        if( newbie->query_skill( DODGE ) >= 5 ||
           random( 3 * ( newbie->query_skill( DODGE ) ) ) ||
           !newbie->add_skill_level( DODGE, 1, 1 ) ) {
          tell_object( newbie, PERSON_DODGE_FAILURE );
          tell_room( environment( newbie ),newbie->one_short() +
            ROOM_DODGE_FAILURE, ({ newbie }) );
          failed = 1;
          break;
        }
      case AWARD :
        tell_object( newbie, "%^YELLOW%^You feel better at dodging "
          "things.%^RESET%^\n" );
      case SUCCEED :
        tell_object( newbie,PERSON_DODGE_SUCESS );
        tell_room( environment( newbie ), newbie->one_short() +
          ROOM_DODGE_SUCESS, ({ newbie }) );
        break;
    }
  } else {
    switch( TASKER->perform_task( newbie, PARRY, diff, TM_FIXED ) ) {
      case FAIL :
        if( newbie->query_skill( PARRY ) >= 5 ||
           random( 3 * ( newbie->query_skill( PARRY ) ) ) ||
           !newbie->add_skill_level( PARRY, 1, 1 ) ) {
          tell_object( newbie, PERSON_PARRY_FAILURE );
          tell_room( environment( newbie ), newbie->one_short() +
            ROOM_PARRY_FAILURE, ({ newbie }) );
          failed = 1;
          break;
        }
      case AWARD :
        tell_object( newbie, "%^YELLOW%^You feel better at parrying things."
          "%^RESET%^\n" );
      case SUCCEED :
        tell_object( newbie, PERSON_PARRY_SUCCESS );
        tell_room( environment( newbie ), newbie->one_short() +
          ROOM_PARRY_SUCCESS, ({ newbie }) );
        break;
    }
  }
  if( trainer && failed )
    failed_defense(newbie);
  return;
}
void tell_misc(object newbie) {
  int which;
  if(!sizeof(misc) || random(5))
    return;
  which = random(sizeof(misc));
  trainer->do_command("say " + misc[which]);
  misc -= ({ misc[which] });
}
void failed_attack( object newbie ) {
  string attitude;
  if(told_attack)
    return;
  attitude = (newbie->query_tactics())->attitude;
  if(attitude != "offensive" && attitude != "insane") {
    told_attack = 1;
    trainer->do_command( "say You can improve your chances of hitting your "
                         "opponent by setting your tactics to a more "
                         "offensive attitude.");
  }
}
void failed_defense( object newbie ) {
  string attitude;
  if(told_parry)
    return;
  attitude = (newbie->query_tactics())->attitude;
  if(attitude != "defensive" && attitude != "wimp") {
    told_parry = 1;
    trainer->do_command( "say You can improve your chances of defending by "
                         "setting your tactics to a more defensive "
                         "attitude." );
  }
}
void adjust_hp() {
  return this_object()->query_max_hp();
}

==================================================
FILE: liaison/NEWBIE/fighters.c
==================================================

#include "path.h"
inherit PATH + "inside";
void setup() {
   set_short( "Warriors' gazebo" );
   set_light( 75 );
   add_property("no teleport", 1);
   set_long( "As you enter this gazebo, you are overwhelmed with a smell of "
             "decaying limbs and dried blood.  A sign catches your eye and you "
             "notice it's the only non-blood covered item in the room.  Maybe "
             "if you 'read sign' you'll get some information about this "
             "deadly guild.\n"
             "A small notice pinned to the wall with a sword states that this "
             "is not the place where you actually join the guild.  The rest "
             "of the note is too torn to read.\n" );
   set_zone( "Newbie" );
   add_item( ({ "armour" }),
             "There are many items around the room, but their function is "
             "beyond you for the most part." );
   add_item( ({ "notice" }),
             "This notice was probably pinned to the wall during combat "
             "practice, and is therefore more or less unreadable after the "
             "battering it got during the session.\n" );
   add_sign( "This sign seems to cower in the corner of the room "
             "unsure of it's place here.\n", "In this deadly guild, "
             "the fine art of killing and berserking is taught.  Learn how "
             "to be deadly with accuracy and lots of pain!  To be a warrior "
             "you must endure lots of pain, practice as much as you can, have "
             "a strong stomach, and have the ability to kill without batting "
             "an eye.  Remember to always keep your guild motto with you: 'If "
             "It Moves Kill It.  If It Doesn't Move, Wait For It To Move, "
             "Then Kill It.'", 0, 0, "general" );
   add_property("no godmother", 1);
   add_exit( "garden", PATH +"guilds_foyer", "gate" );
}

==================================================
FILE: liaison/NEWBIE/foyer.c
==================================================

#include "path.h"
#include <library.h>
#include <config.h>
inherit PATH+"inside";
object womble;
string format_sign(string message);
void setup() {
  add_property("no teleport", 1);
  set_zone( "Newbie" );
  set_short( "Discworld foyer" );
  set_light( 75 );
  set_long("This is a cavernous, circular room that echoes the shape of "
           "the Discworld itself.  At its centre is a large round table upon "
           "which is what appears to be a map of Discworld, complete with "
           "Great A'Tuin swimming slowly through space carrying Berilia, "
           "Tubul, Great T'Phon and Jerakeen, the four giant elephants upon "
           "whose shoulders the disc of the world rests.  The walls are "
           "decorated with murals showing scenes from the disc.  Dark doorways "
           "ring the perimeter of the room, leading away in all directions.\n"
           "There is a large white sign on one wall labelled 'Discworld'.  "
           "You may 'look' at a sign or 'read' a sign.\n");
  add_item(({ "map", "disc", "Disc" }), "Upon closer examination you are not "
           "quite so certain that this is just a map of the Disc.  "
           "The detail is incredible, from the sharp spire of Cori "
           "Celesti at the centre, to the surrounding Circle Sea, "
           "the deserts of Klatch, the watery world of Krull, and the "
           "mysterious Counterweight Continent.  A spectacular rimbow "
           "sparkles where the seas pour over the edge of the Disc.  As "
           "you study the map's details, you are sure you saw one of the "
           "elephants move.");
  add_item("rimbow", "It's like a rainbow except that it's caused by the "
           "water pouring off the edge of the disc.");
  add_item("elephant", "These are the four elephants that bear the weight"
           " of the Disc.");
  add_item( "table", "The table is made of a single piece of green granite, "
           "heavily carved with small figures.  The top of the table is "
           "mostly covered by the map of Discworld, although you can see "
           "a few squares of black and white marble underneath, rather "
           "like a chessboard.");
  add_item(({ "figure", "carving" }), "The tiny, carved figures are "
           "extremely detailed.  You can make out what appears to be "
           "some trolls, a handful of dwarfs, three witches, and what "
           "surely must be the ugliest cat ever.  Looking at the cat "
           "carving, you are sure you catch a whiff of something vile, "
           "much like fermented carpets.");
  add_item("floor", "The floor is made of polished marble so smooth that "
           "you can see your face in it - yeuch!");
  add_item("wall", "The walls are covered in murals showing scenes from "
           "the disc.");
  add_item( "ceiling", "The ceiling, if there is one, disappears into the "
           "lofty gloom overhead.");
  add_item(({ "doorway", "door" }), "The doorways are dark, yet somehow "
           "inviting.  Or at least not threatening.");
  add_item("mural", "On one wall there is a painting of a seedy looking inn "
           "with a sign of a drum hanging outside.  On another a small castle "
           "set high in a mountainous region where the peaks are snow-"
           "capped.  You can almost feel the biting wind.  On another an "
           "oasis in an otherwise hot, dry desert.  The final one is the "
           "most peculiar being a strange bone covered landscape with a "
           "massive sphinx in the centre.");
   add_sign("This is a simple white sign marked \"Discworld\".\n",
            format_sign("This mud is based on the books written by Terry "
                        "Pratchett.  While it is not necessary to have read "
                        "the Discworld books you may find it helpful for some "
                        "of the quests and in knowing more about the "
                        "characters and places in the game."),
            0, ({ "sign","discworld","Discworld" }), "general" )->add_property(
            "determinate","the ");
   room_chat(({60, 120, ({"There is a sound like the rattle and fall of a "
                         "pair of dice.",
                         "You hear a hushed chuckle far above your head.",
                         "A pleasant voice says: Another game?"
                         })}));
   add_exit("helpme", PATH+"help", "door");
   add_exit("communication", PATH +"communication", "door");
   add_exit("hints", PATH +"hints", "door");
   add_exit("guilds", PATH+"guilds_foyer", "door");
   add_exit("commerce", PATH+"shop", "door");
   add_exit("align", PATH+"align", "door");
   add_exit("advancement", PATH+"advancement", "door");
   add_exit("combat", PATH+"combat","door");
  add_property("no godmother", 1);
   add_exit("out", PATH + "choose_land", "path" );
   modify_exit( "out", ({ "function", "check_allow" }) );
}
int check_allow( string str, object ob, string special_mess ) {
  if(ob->query_property("womble's brooch")) {
    ob->set_language("general");
    return 1;
  }
  tell_object( ob,
               "You haven't completed the womble's quest yet.\n"
               "Complete that quest and you can enter the game.\n"
               "HINT: Find the womble's brooch and give it to her.\n");
  return notify_fail( "" );
}
void init() {
   ::init();
   womble = find_object( PATH +"womble" );
   if ( !womble || !environment( womble ) )
      ( PATH +"womble" )->move( this_object(), "$N womble$s in." );
}
string format_sign(string message) {
  int i;
  string *bits;
  string ret = "", bit;
  bits = explode(sprintf("%-="+(SIGN_WIDTH-2)+"s", message), "\n");
  ret += "\n     _";
  for(i=0; i<SIGN_WIDTH - 1; i++)
    ret += "_";
  ret += "\n";
  ret +="
  for(i=0; i<SIGN_WIDTH; i++)
    ret += " ";
  ret += "\\\n";
  foreach(bit in bits) {
    ret += "   || " + bit;
    for(i=sizeof(bit); i<SIGN_WIDTH-1; i++)
      ret += " ";
    ret += "|\n";
  }
  ret += "   \\\\";
  for(i=0; i<SIGN_WIDTH; i++)
    ret += "_";
  ret += "/\n";
  return ret;
}

==================================================
FILE: liaison/NEWBIE/greg.c
==================================================

#include "path.h"
#include <armoury.h>
inherit "/obj/monster";
#define THROW_OUT 300
#define RPATHS ({ PATH + "combat_room1", PATH + "combat_room2", PATH + "combat_room3"})
#define RNAMES ({ "one", "two", "three" })
object *queue = ({ });
object *offered = ({ });
object *in_use = ({ 0, 0, 0 });
object combat_room;
mapping callouts;
void setup() {
  add_property("determinate", "");
  set_name( "greg" );
  set_short("Greg" );
  set_main_plural("Gregs" );
  set_race( "human" );
  set_response_mon_understand_anything(1);
  set_gender( 1 );
  set_al(-500 );
  set_class( "fighter" );
  set_language( "general" );
  set_level( 100 + random( 100 ) );
  set_long( "This is Greg the combat instructor.  He looks pretty mean, but "
            "don't let appearances deceive you, he's a softy at heart.\n" );
  adjust_money( 10 + random( 40 ), "Ankh-Morpork pence" );
  load_chat( 25, ({
    1, ":grunts.",
      1, "'Ug.",
      1, "'I am great.",
      1, "@flex",
      1, "'Look at my cool muscles.",
      }) );
  add_respond_to_with(({ "yes" }), ({ "#yes" }));
  add_respond_to_with(({ "no" }), ({ "#no" }));
  add_respond_to_with(({ ({ "can", "may" }),
                         ({ "practise", "practice", "train"}),
                         ({ "please" }) }),
                      ({ "#request" }) );
  add_respond_to_with(({ ({ "hello", "hi", "gday", }),
                           ({ "womble", "all" }) }), ({ "'Hello $hcname$",
                                                          "bow ? $hname$" }));
  add_respond_to_with(({ "fuck", ({ "off", "you" }) }), ({ "'Same to you!",
                                                             "skick $hname$"
                                                             }));
  add_respond_to_with(({ "fuck" }), "waggle $hname$");
  add_respond_to_with(
                      ({ "@smile", "womble" }), "smile $hname$");
  add_respond_to_with(
     ({ ({ "@skick", "@spunch", "@jump", "@pat", "@slap" }),
          "womble" }), "glare $hname$");
  add_respond_to_with(
                      ({ ({ "@poke", "@glare", "@point" }),
                           "womble" }), "peer sus at $hname$");
  add_respond_to_with(
                      ({ "@grin", "womble" }), "grin $hname$");
  add_respond_to_with(
                ({ ({ "@caress", "@snuggle", "@nestle", "@love", "@throw" }),
                     "womble" }), "waggle $hname$");
  add_respond_to_with(
                      ({ ({ "@kiss", "@french", }),
                           "womble" }), "slap $hname$");
  add_respond_to_with(({ ({ "@bing", "@womble", }),
                           "womble" }), "smile bri $hname$");
  add_skill_level( "other.health", 50 + random( 50 ) );
  (ARMOURY->request_weapon("long sword", 75))->move(this_object());
  (ARMOURY->request_armour("ringmail", 80))->move(this_object());
  (ARMOURY->request_armour("metal clad boots", 80))->move(this_object());
  (ARMOURY->request_armour("metal gauntlets", 80))->move(this_object());
  init_equip();
  callouts = ([ ]);
}
void event_enter(object ob, string message, object from) {
  if(environment() == find_object("/room/rubbish")) {
    return ::event_enter(ob, message, from);
  }
  if(ob->query_property("dead")) {
    return ::event_enter(ob, message, from);
  }
  if(!ob->query_visible(this_object())) {
    return ::event_enter(ob, message, from);
  }
  if(!userp(ob)) {
    return ::event_enter(ob, message, from);
  }
  if(callouts && callouts[ob]) {
    remove_call_out(callouts[ob]);
    map_delete(callouts, ob);
  }
  call_out("do_greeting", 1, ob, from);
}
int attack_by(object thing) {
  tell_room(environment(), "Greg lifts a hand and slaps " + thing->one_short()
            + " sending " + thing->query_objective() + " flying across "
            "the room.\n", thing);
  write("Greg lifts a hand, almost as large as your head, and gives you a "
        "slap that sends you flying across the room.\n");
  write("You bash your head against the wall and the world starts "
        "spinning.\n");
  do_command("'Hey, that's not nice!");
  thing->add_effect("/std/effects/ingested/tranquil_sleep", 120);
  this_object()->stop_fight(thing);
  thing->stop_fight(this_object());
  return 0;
}
void check_room() {
  int room;
  object ob;
  queue = filter_array(queue,
                       (: environment($1) == environment(this_object()) :));
  if(sizeof(queue))
    ob = queue[0];
  if(member_array(ob, queue) == -1)
    return;
  room = member_array(0, in_use);
  if(room == -1) {
    do_command("'Ok " + ob->one_short() + ", unfortunately all the rooms are "
               "busy right now, but "
               "if you don't mind waiting a minute one will become free.");
    return;
  }
  do_command("'Ok " + ob->one_short() + ", you can use room " +
             RNAMES[room] + ".");
  tell_object(ob, "Greg leads you into room " +
              RNAMES[room] + ".\n");
  ob->move_with_look(RPATHS[room], "$N is propelled into the room.",
                     "$N is led out of the room.");
  in_use[room] = ob;
  queue -= ({ ob });
  callouts[ob] = call_out("throw_out", THROW_OUT, ob);
  combat_room = environment();
}
void yes(object ob) {
  if(member_array(ob, offered) == -1 || member_array(ob, queue) != -1)
    return;
  queue += ({ ob });
  check_room();
}
void no(object ob) {
  if(member_array(ob, offered) == -1)
    return;
  offered -= ({ ob });
  if ( environment(ob) == environment(this_object()) ) {
    do_command("'Okay.  Well, come back if you feel like having a go later.");
    do_command("smile " + ob->query_name());
  }
}
void request(object ob) {
  do_command("'Would you like to try out your skills " + ob->one_short() +
             "?");
  if(!sizeof(filter_array(ob->query_holding(), (: $1 && $1->query_weapon()
                                                :))))
    do_command("'You may want to buy a weapon at the shop before trying out "
               "your skills.");
  if(!offered)
    offered = ({ });
  offered += ({ ob });
}
object query_using(int room) {
  return in_use[room];
}
void throw_out(object ob) {
  int room;
  room = member_array(ob, in_use);
  if(room != -1) {
    if(base_name(environment(ob)) == RPATHS[room]) {
      do_command(RNAMES[room]);
      call_out("tell_them", 2, ob, room);
    } else {
      in_use[room] = 0;
    }
  }
}
void tell_them(object ob, int room) {
  if(!ob) {
    do_command("combat");
    return;
  }
  do_command("'Ok " + ob->one_short() + ", time's up.");
  do_command("'Come with me.");
  environment()->stop_them(ob);
  tell_object(ob, "Greg leads you out of the room.\n");
  do_command("combat");
  ob->move_with_look(combat_room, "$N is propelled into the room.",
                     "$N is pushed out of the room.");
}
void do_greeting(object ob) {
  int room;
  if(!ob || !interactive(ob) || member_array(ob, queue) != -1)
    return;
  room = member_array(ob, in_use);
  if(room == -1) {
    do_command("'Hello " + ob->one_short() + ", welcome to the combat "
               "training area.");
    do_command("'Would you like to try out your skills?");
    if(!sizeof(filter_array(ob->query_holding(), (: $1 && $1->query_weapon()
                                                  :))))
      do_command("'You may want to buy a weapon at the shop before trying out "
                 "your skills.");
  } else {
    do_command("'I hope you had a productive time.  Would you like to have "
               "another go?");
    if(room != -1) {
      in_use[room] = 0;
      check_room();
    }
  }
  if(!offered)
    offered = ({ });
  offered += ({ ob });
}

==================================================
FILE: liaison/NEWBIE/guilds_foyer.c
==================================================

#include "path.h"
inherit PATH+"outside";
void setup() {
  set_zone( "Newbie" );
  set_short( "Garden of Guilds" );
  set_light( 100 );
  add_property("no teleport", 1);
  set_day_long( "This is a pleasant garden with trees, shrubs and flowers.  "
                "There are six gazebos in the garden each with a wrought "
                "iron gate with a coat of arms on it.  Each "
                "gazebo is dedicated to one of the Discworld guilds, which "
                "are "+ GUILDS +".  "
                "To look at the gates themselves - use "
                "'look wizard' or 'look witch' or to enter one of the "
                "gazebos, use 'wizard', 'witch' or whichever is appropriate.\n"
                "There is also a sign attached to a post in the centre of the "
                "garden.\n" );
  set_night_long("This is an octagonal garden with a fence around it.  "
                 "Someone has placed braziers around the garden to provide "
                 "light.  There "
                 "are six gazebos in the garden each with a wrought iron gate "
                 "with a coat of arms on it.  Each "
                 "gazebo is dedicated to one of the Discworld guilds, which "
                 "are "+ GUILDS +".  "
                 "To look at the gates themselves - use "
                 "'look wizard' or 'look witch' or to enter one of the "
                 "gazebos, use 'wizard', 'witch' or whichever is "
                 "appropriate.\n"
                 "There is also a sign attached to a post in the centre of "
                 "the garden.\n" );
  add_item("gazebo", "There are a number of gazebos here each dedicated to "
           "a different guild.");
  add_sign("This is a simple white sign attached to a post.\n",
      FOYER->format_sign("Each player will usually join a guild so that "
      "they can learn skills and commands and so advance their abilities.  "
      "Being in a guild also gives character to your character.  To find "
      "out more about the different guilds take each of the guild gates "
      "from this garden.  When you are in Ankh-Morpork you will find that "
      "each guild has a headquarters where you may join.\n\nTake care with "
      "your choice of guild since you will not be able to change it.\n")
      , 0, "sign", "general" );
  add_property("no godmother", 1);
  add_exit( "foyer", PATH + "foyer", "gate" );
#ifndef __DISTRIBUTION_LIB__
  add_exit( "witch", PATH +"witches", "gate" );
  add_exit( "wizard", PATH +"wizards", "gate" );
  add_exit( "thief", PATH +"thieves", "gate" );
  add_exit( "assassin", PATH + "assassins", "gate" );
  add_exit( "warrior", PATH +"fighters", "gate" );
  add_exit( "priest", PATH +"priests", "gate" );
  add_alias( "north", "communication");
  modify_exit("witch",
              ({ "look", "It's too dark to see inside the gazebo."}));
  modify_exit("wizard",
              ({ "look", "It's too dark to see inside the gazebo."}));
  modify_exit("thief",
              ({ "look", "It's too dark to see inside the gazebo."}));
  modify_exit("assassin",
              ({ "look", "It's too dark to see inside the gazebo."}));
  modify_exit("warrior",
              ({ "look", "It's too dark to see inside the gazebo."}));
  modify_exit("priest",
              ({ "look", "It's too dark to see inside the gazebo."}));
  modify_exit("witch", ({ "closed", 1}));
  modify_exit("wizard", ({ "closed", 1}));
  modify_exit("thief", ({ "closed", 1}));
  modify_exit("assassin", ({ "closed", 1}));
  modify_exit("warrior", ({ "closed", 1}));
  modify_exit("priest", ({ "closed", 1}));
  modify_exit( "witch", ({
      "door long", "Over the gate to the Witch room "
      "is the burned-in image of a broomstick with a cat clinging on "
      "to the bristles for dear life.  The gate itself has a little "
      "window in it, but all that you can see through it is darkness.  "
      "To enter here type 'witch'.\n"}) );
  modify_exit( "wizard", ({ "door long", "The gate into the Wizard room "
         "has the crest of Unseen University on it: this shows a large "
         "pointy hat with stars, above it an open book with the words "
         "'Nunc Id Vides, Nunc Ne Vides'. "
         "To enter here type 'wizard'.\n"}) );
  modify_exit( "thief", ({ "door long", "On the Thieves' gate you see "
      "their crest. It has a slashed purse with change falling from a "
        "hole in the bottom and the words ACVTVS ID VERBERAT below. "
          "To enter this gate type \"thief\".\n"}) );
  modify_exit( "assassin", ({ "door long", "On the Assassins' gate you see "
         "their crest.  A cloak and a dagger in the top left and two gold "
           "crosses in the bottom right. Their motto reads: \"Nil Mortifi "
             "Sine Lucre.\"  "
               "To enter this gate type \"assassin\".\n"}) );
  modify_exit( "warrior", ({ "door long", "On the Warriors' gate "
         "they have a strange crest.  A skull and scythe with blood "
         "dripping from it.  Their motto reads: \"If It Moves Kill It. "
         "If It Doesn't Move, Wait For It To Move, Then Kill It.\"  "
         "To enter here type \"warrior\".\n"}) );
  modify_exit( "priest", ({ "door long", "On the Priest's gate you "
         "see an odd crest.  Many unusual symbols, everything from a jar "
         "of fluff to a puddle of water, even an obscure breed of monkey. "
         "To enter here type \"priest\".\n"}) );
#endif
  add_night_item("brazier", "Basically this is a torch on a pole.\n");
  add_room_chats(({"An elderly man dressed in a blue robe and wearing "
                     "a large pointy hat enters from the wizards "
                     "gazebo and leaves south.\n",
                     "An elderly man dressed in a blue robe and wearing "
                     "a large pointy hat enters from the south "
                     "and leaves for the wizards gazebo.\n",
                     "A small woman dressed in a black cloak and wearing "
                     "a large pointy hat enters from the witches "
                     "gazebo and leaves south.\n",
                     "A small woman dressed in a black cloak and wearing "
                     "a large pointy hat enters from the south "
                     "and leaves for the witches gazebo.\n",
                     "A burly man dressed head to toe in armour and "
                     "carrying a large sword enters from the warriors "
                     "gazebo and leaves south.\n",
                     "A burly man dressed head to toe in armour and "
                     "carrying a large sword enters from the north "
                     "and leaves for the warriors gazebo.\n",
                     "A saintly looking woman walks in from the north, "
                     "smiles benevolently at you, and leaves for the "
                     "priests gazebo.\n",
                     "A saintly looking woman enters from the priests "
                     "gazebo, smiles benevolently at you, and leaves "
                     "south.\n",
                     "A shadowy figure enters from the assassins "
                     "gazebo and leaves for the foyer.\n",
                     "A shadowy figure enters from the foyer "
                     "and leaves for the assassins gazebo.\n",
                     "A weaselly, furtive man sneaks in from the foyer "
                     "and leaves for the thieves gazebo.\n",
                     "A weaselly, furtive man sneaks in from the thieves "
                     "gazebo and leaves for the foyer.\n"}));
}
int query_light() {
  int light;
  light = ::query_light();
  if(light < 40)
    light = 40;
  return light;
}

==================================================
FILE: liaison/NEWBIE/help.c
==================================================

#include "path.h"
#include <library.h>
inherit PATH+"inside";
object womble;
void setup() {
  set_zone( "Newbie" );
  set_short( "Help Room" );
  set_light( 75 );
  set_long("This room looks like a library.  There are shelves around the "
           "room crammed with reference books.  Around the room are a "
           "number of signs.\n"
           "The signs are labelled 'helpme', 'newbie', 'problems', "
           "'etiquette' and 'quit'.\n");
  add_item("floor", "The floor is made of polished marble so smooth that "
           "you can see your face in it - yeuch!\n");
  add_item("wall", "The walls are hidden behind row upon row of shelves.\n");
  add_item(({ "shelves", "shelf" }), "The shelves are filled with books.\n");
  add_item("book", "There are many, many reference books here, most are "
           "weighty tomes in black leather bindings.\n");
  add_sign("This is a simple white sign marked 'helpme'.\n",
           FOYER->format_sign(
                 "The Discworld help system is divided into two parts: "
                 "concept help which explains discworld concepts such as "
                 "magic and command help which explains how to use specific "
                 "commands.\n\nPerhaps the single most useful command is "
                 "'help concepts'.  This command will provide a list of "
                 "concepts for which there is an overview.  These overviews "
                 "will help you understand how things work and also what "
                 "commands to use to do things.\n\nTo see the list of "
                 "commands type 'help command_list'.  In addition, the "
                 "'essentials' help file covers all the basic commands "
                 "you're likely to need to get you started."),
           "sign marked 'helpme'",
           "helpme", "general");
   add_sign("This is a simple white sign marked 'problems'.\n",
            FOYER->format_sign(
            "If you have problems getting started or understanding help "
            "files, you can talk to a newbiehelper (type 'helpers' for "
            "a list of online newbiehelpers) or use the newbie channel.  "
            "If you have any problems with the mud not working as you "
            "expect, liaisons are available for giving help and for "
            "answering questions.  They can't provide quest details but "
            "will try to help you if they can.\n\n"
            "To see if any creators are logged on, and to get a list "
            "of all players logged on, use the command 'finger': "
            "Creators are marked by having a C next to their name.  "
            "Senior creators are marked with an S next to their name.  "
            "Directors are marked by having an D next to their name.  "
            "Trustees are marked by having an T next to their name.\n\n"
            "To find out which creators are in the liaison domain "
            "type 'finger liaison', and to see which of those are "
            "currently online, type 'liaisons'.  "
            "To report any bugs or typos that you may encounter, please "
            "make a report out for them. Please read 'help bug' or "
            "'help typo' for information on making reports."),
            "sign marked 'problems'",
            "problems", "general" );
   add_sign("This is a simple white sign marked 'newbie'.\n",
            FOYER->format_sign(
            "This is part of the newbie area on Discworld, "
            "written to help you get acquainted with the game.  "
            "Please enter each room and find out about what "
            "each of Discworld's guilds has to offer.\n\n"
            "If you have any questions that aren't answered by the "
            "signs, first try 'help <subject>' if that doesn't work "
            "use 'newbie <question>' and hopefully someone will "
            "answer your question and 'hnewbie' to view the past couple "
            "of questions.\n\n"
            "Once you have visited each room you may "
            "leave the newbie area to enter Discworld proper.  "
            "Before reaching the Disc, you'll be given the choice of "
            "which city you wish to start in.  Information is given about "
            "each region and city at that time."),
            "sign marked 'newbie'",
            "newbie", "general" );
   add_sign("This is a simple white sign marked 'etiquette'.\n",
            FOYER->format_sign(
            "Discworld is a very friendly mud and there are "
            "few written rules. The bottom line is be nice "
            "and don't cheat.  In particular: \n\n"
            "The use of foul language in shouting and the "
            "broadcasting of quest information are frowned upon.  "
            "Creators will remind you of this if provoked, and "
            "will take appropriate action if necessary. Playing "
            "more than one character at once is not permitted.\n\n"
            "If you wish to play more than one character you must "
            "never have them both logged on at the same time.  "
            "Harassment of other players, sexual or otherwise, "
            "is not acceptable and may lead to banishment."),
            "sign marked 'etiquette'",
            "etiquette", "general" );
   add_sign("This is a simple white sign marked 'quit'.\n",
            FOYER->format_sign(
            "To leave Discworld at any time, "
            "type 'quit' at the prompt.  Your "
            "player file will automatically be "
            "saved with all your equipment.  The only exception is if "
            "you are under 30 minutes old, in which case you won't save."),
            "sign marked 'quit'",
            "quit", "general" );
   add_exit( "foyer", PATH +"foyer", "door");
   add_alias( "southeast", "foyer");
  add_property("no godmother", 1);
}

==================================================
FILE: liaison/NEWBIE/hints.c
==================================================

#include "path.h"
inherit PATH+"inside";
object sign;
void setup() {
  set_zone( "Newbie" );
  set_short("Hints Room" );
  set_light( 75 );
  add_property("no teleport", 1);
  set_long( "You are in a small, dark room.  The only illumination seems to "
            "come from the crack under the door.  The walls are covered "
            "with handwritten notices, most of which you cannot read in this "
            "half-light, however a few catch your eye.  One is entitled "
            "'statistics', another 'navigation', another "
            "'advancement', a fourth 'assistance', yet another 'skills'"
            ", and a final one is marked 'dying'.  Something in the "
            "corner catches your eye.\n");
   add_item( ({ "something", "corner" }),
             "There's something in the corner.  Maybe you could 'search' "
             "the corner and find out what's there." );
  add_item( "floor",
            "You can barely make out the floor.  It appears to be made of "
            "stone");
  add_item( "wall",
            "The walls (what you can see of them under the notices) are made "
            "of grey stone.");
  add_item(({"notice"}), "The walls are covered with handwritten notices.  In "
           "the half-light it's hard to pick them out, but you can make "
           "out a few of them.  One is entitled "
           "'statistics', another 'navigation', another "
           "'advancement', a fourth 'assistance', yet another 'skills'"
           ", and a final one is marked 'dying'.");
  sign=add_sign("A handwritten notice marked 'statistics'.\n",
                FOYER->format_sign(
           "Once you enter Discworld, you can rearrange your stats.  This "
           "should be done to improve your combination of constitution, "
           "dexterity, intelligence, strength and wisdom (your stats) once "
           "you have chosen a guild.  Use the command 'rearrange' to do "
           "this, but consider it well, as you can only rearrange your stats "
           "once.  You can view them using 'score stats'.  See 'help "
           "score'.\n"), 0, "statistics", "general");
  sign->set_short("sign marked 'statistics'");
  sign=add_sign("A handwritten notice marked 'combat'.\n",
                FOYER->format_sign(
           "Combat is a fairly important part of Discworld.  The combat "
           "system is quite advanced.  You should type 'help fighting' "
           "and 'help tactics' to find out more about how to modify "
           "the way in which you fight.\n"),
           0, "combat", "general");
  sign->set_short("sign marked 'combat'");
  sign=add_sign("A handwritten notice marked 'navigation'.\n",
                FOYER->format_sign(
           "Exploring a new area can be quite exciting.  There are lots of "
           "things to look at, and maps to make.  If you get lost, though, "
           "you might appreciate some maps.  In some areas, typing 'map' will "
           "show you a map of your immediate surroundings.  You may also find "
           "the maps some players have made useful - follow the 'Mud Atlas' "
           "link on our homepage.  See 'help maps'.\n"),
           0, "navigation", "general");
  sign->set_short("sign marked 'navigation'");
  sign=add_sign("A handwritten notice marked 'assistance'.\n",
      FOYER->format_sign(
      "Liaison creators are available for giving help and for "
      "answering questions; they cannot provide quest information, "
      "however.  You can find which liaisons are logged on at the moment "
      "using the 'liaisons' command.  "
      "To see if any creators are logged on, and to get a "
      "list of all players logged on, use the command 'finger':\n"
      " - creators are marked by having a C next to their name.\n"
      " - senior creators are marked by having an S next to their name\n"
      " - directors (domain leaders) are marked by having a D next to their "
      "name.\n"
      " - trustees (administrators) are marked by having a T next to their "
      "name.\n\n"
      "To report any bugs or typos that you may encounter, please "
      "make a report out for them.  To do this, please type "
      "'bug' and make out your report.  Please include the error, if "
      "any, that you get, the room that it is occuring in, and what "
      "you were doing to get the error.  Use the 'typo' command and "
      "the same guidelines when you report a typo.\n"), 0, "assistance", "general");
  sign->set_short("sign marked 'assistance'");
  sign=add_sign("A handwritten notice marked 'skills'.\n",
                FOYER->format_sign(
           "To check your skill levels, use the command 'skills', and "
           "to see various statistics about yourself, use 'score'.  Your "
           "stats can also be reviewed using 'score stats'.  The command "
           "'help' will give you a variety of other topics with useful "
           "information."), 0, "skills", "general");
  sign->set_short("sign marked 'skills'");
  sign=add_sign("A handwritten notice marked 'advancement'.\n",
                FOYER->format_sign(
           "Skills can be advanced in a variety of ways on Discworld.  "
           "The guild you join will allow you to advance your skills "
           "for a certain number of experience points and a small fee.  "
           "When you reach the proper skill level your guild will "
           "teach you the commands that you will need to carry out "
           "your guild duties.\n\n"
           "You may also have another player teach you skills if they have "
           "a higher skill level than you, or you may teach yourself.  Both "
           "of these methods cost experience points, and it is generally more "
           "expensive to teach yourself.\n\n"
           "Finally, many of your skills can be advanced simply by performing "
           "tasks that make use of those skills.  For example, your fighting "
           "skills will get better as you participate in more fights.  For "
           "more information on this system, type "
           "'help taskmaster'.\n"),0, "advancement", "general");
  sign->set_short("sign marked 'advancement'");
  sign=add_sign("A handwritten notice marked 'dying'.\n",
                FOYER->format_sign(
           "At some point you will inevitably end up dying on Discworld, but "
           "fear not for you are given 7+1 lives.  When you die you need to "
           "go and visit Harry in the Temple of Small Gods who will raise "
           "you.\n"), 0, "dying", "general");
  sign->set_short("sign marked 'dying'");
  add_property("no godmother", 1);
  add_exit( "foyer", PATH + "foyer", "door" );
  add_alias( "northwest", "foyer");
  room_chat(({10, 40, ({"A voice whispers something that you can't quite "
                         "make out.",
                        "You think you hear someone whispering.",
                        "A voice whispers: Use 'chfn' to change your "+
                         "finger information.",
                        "A voice whispers: 'consider' will tell you how "
                         "tough an opponent is.",
                        "A voice whispers: You can re-execute your last "
                         "command by using '.' or the last command "+
                         "beginning xxx with '.xxx'.",
                        "A voice whispers: You can set up aliases for "
                         "sequences of commands that you use frequently.",
                        "A voice whispers: You can give your friends easier-"
                         "to-type nicknames.",
                        "A voice whispers: Use 'wimpy' to automatically "
                         "run away before you "
                         "die, or 'monitor' to keep a track of how hurt "
                         "you are getting.",
                        "A voice whispers: 'who' will provide a list of "
                         "the current players on Discworld.",
                        "If it's too noisy you can use 'earmuffs' to "
                         "quiet things down a bit.",
                        "A voice whispers: The street urchins can take you "
                         "to various places around Ankh-Morpork.  Just "
                         "say where you want to go and if they know it "
                         "they'll take you there."
                              })}));
}
int do_search()
{
  object ob;
  tell_object( this_player(), "You examine the floor more "
              "closely and find a brooch lying in the corner.\n");
  tell_object(this_player(), "You pick up the brooch.\n");
  say(this_player()->one_short()+" searches the room "
      "and finds something in the corner.\n");
  ob = clone_object( PATH + "womble_brooch" );
  ob->move( this_player() );
  return 1;
}

==================================================
FILE: liaison/NEWBIE/inside.c
==================================================

#include "path.h"
inherit "/std/room/basic_room";
inherit PATH + "common";
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void init() {
  ::init();
  this_player()->add_command("speak", this_object(), "<string'language'>" );
}
int do_speak(string str) {
  write("Sorry, you cannot do that here.\n");
  return 1;
}

==================================================
FILE: liaison/NEWBIE/newbie_book.c
==================================================

#include "path.h"
#define NEWBIE_SAVE "/d/liaison/NEWBIE/save/"
inherit "/std/book_dir";
void setup() {
  set_name( "book" );
  set_short( "newbie guide book");
  set_main_plural( "newbie guide books" );
  add_adjective( ({"newbie", "guide"}) );
  add_alias( "newbiebook" );
  set_weight( 2 );
  set_value( 0 );
  set_long( "This is a guide book for the newbies who rushed through the "
            "newbie foyer too fast or are just absent-minded in general.  "
            "It contains valuable information on the commands, guilds "
            "and the city of Ankh-Morpork.\n\n"
            "You may 'open book', 'read newbie book', 'turn page of "
            "newbie book' or 'open newbie book to page #'.\n" );
  set_book_language( "general" );
  set_book_dir( NEWBIE_SAVE + "newbie_book_page" );
  set_read_mess("\n"
"                          _______   nn   _______                      \n"
"                          \\____ _\\ [@@] / _____/                       \n"
"                             \\__ _\\/\\/\\/ ___/                        \n"
"                               \\__| [] |__/                            \n"
"                  ___              \\__/              ___             \n"
"                 / ..\\             /__\\             /.. \\          \n"
"               _/ \\___\\            (())            /___/ \\_        \n"
"             _/@  /V /V   _________=||=________    V\\ V\\  @\\_      \n"
"             \\   |_n_n    \\         ||        /     n_n_|   /          \n"
"              |   ____|    |                 |     |____   |           \n"
"              |-----|_____ |       The       | _____|------|           \n"
"             / __    \\ ___)|      NEWBIE     |(___ /     __ \\          \n"
"            | /  \\___ |    |    Guide book   |    | ____/  \\ |         \n"
"            | \\______)|    |      f o r      |    |(_______/ |         \n"
"            |         |    |    Discworld    |    |          |         \n"
"            |        /      \\    Mudders    /      \\         |         \n"
"             \\   _  /        \\_           _/        \\   _   /         \n"
"              | | | |          \\_       _/           | | | |           \n"
"              |_| |_|            \\_____/             |_| |_|           \n"
"       ____________________________________________________________     \n"
"   ___|  Syntaxes: 'open book' 'read book' 'turn a page of book'   |___  \n"
"   \\  |____________        'open book to page #'       ____________|  /  \n"
"   /____/          \\__________________________________/          \\____\\ ",
"general");
}

==================================================
FILE: liaison/NEWBIE/newbie_book_old.c
==================================================

#include "path.h"
#define PAGES    8
inherit "/std/book";
void setup() {
  set_name( "book" );
  set_short( "newbie guide book");
  set_main_plural( "newbie guide books" );
  add_adjective( ( {"newbie", "guide"} ) );
  set_weight( 2 );
  set_value( 0 );
  set_no_pages( PAGES );
  set_long( "This is a guide book for the newbies who rushed through the "
            "newbie foyer too fast or are just absent-minded in general.  "
            "It contains valuable information on the commands, guilds "
            "and the city.  "
            "You may <read newbie book>, <open newbie book to page #> and "
            "<turn a page of newbie book>.\n" );
  set_read_mess("\n"
"                          _______   nn   _______                      \n"
"                          \\____ _\\ [@@] / _____/                       \n"
"                             \\__ _\\/\\/\\/ ___/                        \n"
"                               \\__| [] |__/                            \n"
"                  ___              \\__/              ___             \n"
"                 / ..\\             /__\\             /.. \\          \n"
"               _/ \\___\\            (())            /___/ \\_        \n"
"             _/@  /V /V   _________=||=________    V\\ V\\  @\\_      \n"
"             \\   |_n_n    \\         ||        /     n_n_|   /          \n"
"              |   ____|    |                 |     |____   |           \n"
"              |-----|_____ |       The       | _____|------|           \n"
"             / __    \\ ___)|      NEWBIE     |(___ /     __ \\          \n"
"            | /  \\___ |    |    Guide book   |    | ____/  \\ |         \n"
"            | \\______)|    |      f o r      |    |(_______/ |         \n"
"            |         |    |    Discworld    |    |          |         \n"
"            |        /      \\    Mudders    /      \\         |         \n"
"             \\   _  /        \\_           _/        \\   _   /         \n"
"              | | | |          \\_       _/           | | | |           \n"
"              |_| |_|            \\_____/             |_| |_|           \n"
"       ____________________________________________________________     \n"
"   ___|  Syntaxes: <open book> <read book> <turn a page of book>   |___  \n"
"   \\  |____________        <open book to page #>       ____________|  /  \n"
"   /____/          \\__________________________________/          \\____\\ ",
"general");
  set_open_page( 1 );
  set_read_mess( "                                                \n"
 "                                                                \n"
"                            %^B_RED%^TABLE OF CONTENTS%^RESET%^                        Page 1\n"
 "                    .o0o.o0o.o0o.o0o.o0o.o0o.o0o.o0o.       \n"
 "                                            \n"
 "         General information.....................................2-3\n"
 "         Commands................................................4-5\n"
 "         Guilds..................................................6-7\n"
 "         The lands around Ankh-Morpork.............................8\n"
 "\n\n"
 " %^B_RED%^NOTE:%^RESET%^ If you haven't played MUD's before, we advise you"
 " to read any of\n"
 " the FAQ's around (Frequently Asked Questions).  To read the "
 "Discworld FAQ,\n"
 " type 'help FAQ' or point your http browser at \n"
 " <http:
 " 'Frequently Asked Questions' link.",
 "general", 100 );
  set_open_page( 2 );
  set_read_mess( "\n"
 "                            GENERAL INFORMATION                     Page 2\n"
 "                           -=-=-=-=-=-=-=-=-=-=-                 \n"
 "\n"
 " At any time during the course of playing you can get HELP on various \n"
 " topics by typing  '%^B_RED%^help concepts%^RESET%^' "
 "and  '%^B_RED%^help command_list%^RESET%^'. \n"
 " If you need to ask something else, or have problems of any kind, \n"
 " the LIAISON creators will kindly help you out, if you ask nicely. \n"
 " To see if any are logged on, simply type  '%^B_RED%^liaisons%^RESET%^'.\n"
 " Also, most of the players are usually very helpful when it comes to \n"
 " answering questions.                                \n"
 "\n"
 " As soon as you have made a choice you should join a GUILD where you can \n"
 " advance your skills (take a look at page 5 in this brochure for more \n"
 " information on the different guilds).  But while deciding, you can \n"
 " simply teach yourself.  Type  '%^B_RED%^help level%^RESET%^'  and "
 " '%^B_RED%^help teach%^RESET%^' \n"
 " to find out more.\n"
 "\n"
 " CONTINUES ON NEXT PAGE.",
 "general", 100 );
  set_open_page( 3 );
  set_read_mess( "\n"
 "                        MORE GENERAL INFORMATION                   Page 3\n"
 "                       -=-=-=-=-=-=-=-=-=-=-=-=- \n"
 "\n"
 " In Ankh-Morpork there are GUIDES wandering around that can take you to \n"
 " certain destinations.  These are often waiting by the guilds or in the \n"
 " Mended Drum.  To use one you say in the same room as one, for example: \n"
 " 'take me to wizards guild please'.  \n"
 " Other places they can take you to, besides the guilds, are \n"
 " 'the post office',  'the bank',  'least gate' and  'hubwards gate'.\n"
 "                                                    \n"
 " You start off with a total of eight lives.  If you should happen to die,\n"
 " Harry at the Temple of Small Gods, can RAISE you from the dead and you \n"
 " are then set to go again (one life shorter).  Some player Priests also \n"
 " have the ability to resurrect.\n"
" And please BUG report bugs and typos you see.  Do  '%^B_RED%^help bug%^RESET%^' "
 " and \n"
 " '%^B_RED%^help typo%^RESET%^'  for more information.",
 "general", 100 );
  set_open_page( 4 );
  set_read_mess( " \n"
  "                                  COMMANDS                         Page 4\n"
  "                                -=-=-=-=-=-\n"
  "\n"
  " '%^B_RED%^who%^RESET%^' or '%^B_RED%^finger%^RESET%^'"
  "  Will show the people logged on.  \n"
  "                    You can also 'finger <playername>'\n"
  " '%^B_RED%^rearrange%^RESET%^'        Allows you to set your stats"
  " (You can only do this once).\n"
  " '%^B_RED%^score%^RESET%^'            Will show statistics.\n"
  " '%^B_RED%^score stats%^RESET%^'      More statistics.\n"
  " '%^B_RED%^i%^RESET%^'                Will show you your inventory.\n"
  " '%^B_RED%^skills%^RESET%^'           Will list your skills.\n"
  " '%^B_RED%^wimpy < % >%^RESET%^'      To automatically run away before "
  "you die.\n"
  " '%^B_RED%^monitor on%^RESET%^'       Will help you keep track of Hit"
  " and Guild points.\n"
  " '%^B_RED%^inform logon on/off%^RESET%^'    Gives you info on logon/out-"
  "events (once you've \n                    joined a guild).\n"
  " '%^B_RED%^.%^RESET%^'                Will repeat your last command.\n"
  "\n"
  " CONTINUES ON NEXT PAGE.",
  "general", 100 );
  set_open_page( 5 );
  set_read_mess("\n"
  "                              MORE COMMANDS                        Page 5\n"
  "                             -=-=-=-=-=-=-=-\n"
  "\n"
  " '%^B_RED%^tactics%^RESET%^'         Will show your combat tactics.  Read\n"
  "                  'help tactics' for information on how to use it.\n"
  "\n"
  " Other commands worth checking out, or read the help files for, are: \n"
  " '%^B_RED%^alias%^RESET%^',  '%^B_RED%^earmuff%^RESET%^', "
  " '%^B_RED%^commands%^RESET%^', "
  "'%^B_RED%^nickname%^RESET%^',  '%^B_RED%^consider%^RESET%^'\n"
  " '%^B_RED%^gp%^RESET%^' and  '%^B_RED%^playerkilling%^RESET%^'.",
  "general", 100 );
  set_open_page( 6 );
  set_read_mess( "\n"
 "                               THE GUILDS                           Page 6\n"
 "                             -=-=-=-=-=-=-\n"
 "\n"
 " Each player will usually join a guild so that they can learn skills\n"
 " and commands and so advance their abilities.   Being in a guild also \n"
 " adds character to your character.  These guilds are currently available:\n"
 " WIZARDS GUILD is located west of Sator Square.  To join you have to look\n"
 " around in the Great Hall and find a staircase.\n"
 " THIEVES GUILD is at the beginning of Alchemist street.\n"
 " FIGHTERS GUILD is on Filigree Street, just a stone's throw from Mended \n"
 " Drum.\n"
 " PRIESTS GUILD with its various Gods is located on Small Gods Street.\n"
 " The Gods are: Hat, Pishe, Fish, Sek, Gapp, Gufnork and Sandelfon.\n"
 " For more information, type 'info' in their guild rooms.\n"
 "\n"
 " CONTINUES ON NEXT PAGE.",
 "general", 100 );
 set_open_page( 7 );
 set_read_mess( "\n"
 "                               THE GUILDS                           Page 7\n"
 "                             -=-=-=-=-=-=-\n"
 "\n"
 " ASSASSINS GUILD is located at the eastern end of Filigree Street.  Fill \n"
 " in an application and give it to the secretary in the guild office.\n"
 " WITCHES GUILD is located at Granny Weatherwax' cottage in Lancre. \n"
 " See Gennie Applebottom at Dione Street in Ankh-Morpork if you have \n"
 " trouble finding the place.",
 "general", 100 );
  set_open_page( 8 );
  set_read_mess( "\n"
 "                        THE LANDS OUTSIDE ANKH-MORPORK              Page 8\n"
 "                       -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-                \n"
 "\n"
 " The lands around the city can sometimes be strange and dangerous \n"
 " places.  Through the northeastern (Least) gate is the path that goes \n"
 " through the plains, some small villages, and finally up to the \n"
 " mountains, also known as the Ramtops.\n"
 " The southeastern (Hubwards) gate takes you into the vast forest where \n"
 " innocent people are terrorised by wolves and other strange creatures \n"
 " that roam unfettered.  It's also a more direct route to the Ramtops\n"
 " (Carriages from Ankh-Morpork are a nice alternative to tired feet for \n"
 " travelling to and from the towns in the Sto Plains and Ramtops).\n"
 " Holywood is a great place for newbies venturing out of the city.  You \n"
 " get there via the Brass Bridge.\n"
 " The tour operator at Sator Square is ready to send you to the warm \n"
 " and distant continent of Klatch, if you have enough money.\n"
 " '%^B_RED%^help map%^RESET%^'  will give you a nice map of Discworld and "
 "there are more \n"
 " fantastic and exciting places to come.",
 "general", 100 );
  set_open_page( 0 );
}

==================================================
FILE: liaison/NEWBIE/newbie_brochure.c
==================================================

#include "path.h"
#define PAGES    6
inherit "/std/leaflet";
void setup() {
  set_name( "brochure" );
  set_short( "newbie brochure");
  set_main_plural( "brochures" );
  add_alias ( ( {"brochure", "pamphlet", "newbie brochure"} ) );
  set_weight( 0 );
  set_value( 400 );
  set_no_pages( PAGES );
  set_long( "This is a pamphlet for the newbies who rushed through the "
            "newbie foyer too fast or are just absent-minded in general.  "
            "It contains valuable information on the commands, guilds "
            "and the city.  "
            "You may <read brochure>, and "
            "<turn a page of brochure>.\n" );
  set_open_page( 1 );
  set_read_mess( "                                                \n"
 "                                                                \n"
"                            %^B_RED%^TABLE OF CONTENTS%^RESET%^                        Page 1\n"
 "                    .o0o.o0o.o0o.o0o.o0o.o0o.o0o.o0o.       \n"
 "                                            \n"
 "         General information.....................................2-3\n"
 "         Commands..................................................4\n"
 "         Guilds....................................................5\n"
 "         The lands around Ankh-Morpork.............................6\n"
 "                                                                  "
 "                                                                  "
 "                                                                  "
 "%^B_RED%^ NOTE:%^RESET%^ If you haven't played MUD's before, we advise you"
 " to read any of the \n"
 " FAQ's around (Frequently Asked Questions).  To read the Discworld FAQ,\n"
 " type 'help FAQ' or point your http browser at: \n"
 " http:
 "general", 100 );
  set_open_page( 2 );
  set_read_mess( "                                                        \n"
 "                            GENERAL INFORMATION                     Page 2\n"
 "                           -=-=-=-=-=-=-=-=-=-=-                 \n"
        "                                                \n"
 " At any time during the course of playing you can get HELP on various \n"
 " topics by typing  '%^B_RED%^help concepts%^RESET%^' "
 "and  '%^B_RED%^help command_list%^RESET%^'. \n"
 " If you need to ask something else, or have problems of any kind, \n"
 " the LIAISON people will kindly help you out, if you ask nicely. \n"
 " To see if any are logged on, simply type  '%^B_RED%^liaisons%^RESET%^'.\n"
 " Also, most of the players are usually very helpful when it comes to \n"
 " answering questions.                                \n"
 "                                                                        \n"
 " As soon as you have made a choice you should join a GUILD where you can \n"
 " advance your skills (take a look at page 5 in this brochure for more \n"
 " information on the different guilds).  But while deciding, you can \n"
 " simply teach yourself.  Type  '%^B_RED%^help level%^RESET%^' and "
 " '%^B_RED%^help teach%^RESET%^' \n"
 " to find out more.\n"
 "                                 \n"
 " CONTINUES ON NEXT PAGE.\n",
 "general", 100 );
  set_open_page( 3 );
  set_read_mess( "                                                  \n"
 "                                                                   Page 3\n"
 " In Ankh-Morpork there are GUIDES wandering around that can take you to \n"
 " certain destinations.  These are often waiting by the guilds or in the \n"
 " Mended Drum.  To use one you say in the same room as one, for example: \n"
 " 'take me to wizards guild please'.  \n"
 " Other places they can take you to, besides the guilds, are \n"
 " 'the post office',  'the bank',  'least gate' and  'hubwards gate'.\n"
 "                                                    \n"
 " You start off with a total of eight lives.  If you should happen to die,\n"
 " Harry at the Temple of Small Gods, can RAISE you from the dead and you \n"
 " are then set to go again (one life shorter).  Player Priests also have \n"
 " the ability to resurrect.\n"
" And please BUG report bugs and typos you see.  Do  '%^B_RED%^help bug%^RESET%^' "
 " and \n"
 " '%^B_RED%^help typo%^RESET%^' for more information.\n",
 "general", 100 );
  set_open_page( 4 );
  set_read_mess( "                                                       \n"
 "                                   COMMANDS                        Page 4\n"
 "                                 -=-=-=-=-=-\n"
 "                                                                  \n"
  " '%^B_RED%^who%^RESET%^' or '%^B_RED%^finger%^RESET%^'"
  "  Will show the people logged on.  \n"
  "                    You can also 'finger <playername>'\n"
  " '%^B_RED%^rearrange%^RESET%^'        Allows you to set your stats"
  " (You can only do this once).\n"
  " '%^B_RED%^score%^RESET%^'            Will show statistics.\n"
  " '%^B_RED%^i%^RESET%^'                Will show you your inventory.\n"
  " '%^B_RED%^skills%^RESET%^'           Will list your skills.\n"
  " '%^B_RED%^wimpy < % >%^RESET%^'      To automatically run away before "
  "you die.\n"
  " '%^B_RED%^monitor on%^RESET%^'       Will help you keep track of Hit"
  " and Guild points.\n"
  " '%^B_RED%^inform logon on/off%^RESET%^'    Gives you info on logon/out-"
  "events (once you've \n                    joined a guild).\n"
  " '%^B_RED%^help map%^RESET%^'         Gives you a map of Ankh-Morpork  "
  "(Try also \n"
  "                   'help ankh-morpork'.)\n"
 " '%^B_RED%^.%^RESET%^'                Will repeat your last command.\n"
  " Other commands "
  "worth checking out, or read the help files for, are: \n"
  " '%^B_RED%^alias%^RESET%^',  '%^B_RED%^earmuff%^RESET%^', "
  " '%^B_RED%^commands%^RESET%^', '%^B_RED%^score stats%^RESET%^',  "
  "'%^B_RED%^nickname%^RESET%^',  '%^B_RED%^consider%^RESET%^'\n"
  " '%^B_RED%^gp%^RESET%^' and  '%^B_RED%^playerkilling%^RESET%^'.\n",
  "general", 100 );
  set_open_page( 5 );
  set_read_mess( "                                                   \n"
 "                               THE GUILDS                           Page 5\n"
 "                             -=-=-=-=-=-=-\n"
       "                                                  \n"
 " Each player will usually join a guild so that they can learn skills\n"
 " and commands and so advance their abilities.   Being in a guild also \n"
 " adds character to your character.  These guilds are currently available:\n"
 " WIZARDS GUILD is located west of Sator Square.  To join you have to look\n"
 " around in the Great Hall and find a staircase.\n"
 " THIEVES GUILD is at the beginning of Alchemist street.\n"
 " FIGHTERS GUILD is on Filigree Street, just a stone's throw from Mended \n"
 " Drum.\n"
 " PRIESTS GUILD with its various Gods is located on Small Gods Street.\n"
 " The Gods are: Hat, Pishe, Fish, Sek, Gapp, Gufnork and Sandelfon.\n"
 " For more information, type 'info' in their guild rooms.\n"
 " ASSASSINS GUILD is located at the eastern end of Filigree Street.  Fill \n"
 " in an application and give it to the secretary in the guild office.\n"
 " WITCHES GUILD is located at Granny Weatherwax' cottage in Lancre. \n"
 " See Gennie Applebottom at Dione Street in Ankh-\n"
 " Morpork if you have trouble finding the place.\n",
 "general", 100 );
  set_open_page( 6 );
  set_read_mess( "                                                    \n"
 "                        THE LANDS OUTSIDE ANKH-MORPORK              Page 6\n"
 "                       -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-                \n"
 "                                                           \n"
 " The lands around the city can sometimes be strange and dangerous \n"
 " places.  Through the northeastern (Least) gate is the path that goes \n"
 " through the plains, some small villages, and finally up to the \n"
 " mountains, also known as the Ramtops.\n"
 " The southeastern (Hubwards) gate takes you into the vast forest where \n"
 " innocent people are terrorised by wolves and other strange creatures \n"
 " that roam unfettered.  It's also a more direct route to the Ramtops\n"
 " (Carriages from Ankh-Morpork are a nice alternative to tired feet for \n"
 " travelling to and from the towns in the Sto Plains and Ramtops).\n"
 " The tour operator at Sator Square is ready to send you to the warm \n"
 " and distant continent of Klatch, if you have enough money.\n"
 " There are more fantastic and exciting places to come.\n",
 "general", 100 );
  set_open_page( 1 );
}

==================================================
FILE: liaison/NEWBIE/outside.c
==================================================

#include "path.h"
inherit "/std/outside";
inherit PATH + "common";
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void init() {
  ::init();
  this_player()->add_command("speak", this_object(), "<string'language'>" );
}
int do_speak(string str) {
  write("Sorry, you cannot do that here.\n");
  return 1;
}

==================================================
FILE: liaison/NEWBIE/path.h
==================================================

#define PATH "/d/liaison/NEWBIE/"
#ifdef __DISTRIBUTION_LIB__
#define GUILDS "None currently"
#else
#define GUILDS "Witches, Wizards, Warriors, Priests, Thieves, and Assassins"
#endif
#define SIGN_WIDTH 67
#define FOYER (PATH+"foyer")

==================================================
FILE: liaison/NEWBIE/priests.c
==================================================

#include "path.h"
inherit PATH + "inside";
string list_deities();
void setup() {
  set_short( "Priests' Gazebo" );
  set_light( 75 );
  add_property("no teleport", 1);
  set_long( "As you enter this blessed and holy gazebo, a warm feeling of "
            "peace and calmness overwhelms you.  You get the feeling that "
            "this must be what it's like to be a priest.  Around the room "
            "you can see items of priesthood: jars of fluff, holy symbols "
            "and coloured rods.  A small sign with a green aura sits in the "
            "corner. If you 'read sign' you can get some information "
            "about the priests.\n"
            "A small notice, blessed into oblivion, states that this is not "
            "the place where you actually join the guild.\n" );
   set_zone( "Newbie" );
   add_item( ({ "jar", "jar of fluff", "jars of fluff", "fluff",
             "holy symbol", "coloured rod", "relic", "symbol", "rod" }),
             "There are many items around the room, but their function is "
             "beyond you for the most part." );
   add_item( "notice",
             "This blessed notice rests peacefully against a holy relic." );
   add_sign( "The sign is covered in a soothing green aura, and sits "
             "in the corner of the room.\n",
             FOYER->format_sign("This holy guild, and its many "
             "gods, is based at the Temple of Small Gods in Ankh-Morpork.  "
             "You may learn how to heal and resurrect, shield with the "
             "power of your faith, and many other holy powers.  Some gods "
             "shun healing almost completely, preferring to concentrate on "
             "causing strife and mayhem among the citizens of Discworld.  Ask"
             " some of the other priests in the city about finding a god "
             "that will suit your needs, and help back you up.\n"
             "The following gods are desirous of priests: " + list_deities() +
             ".  Many gods require particular alignments.  Use 'finger "
             "<deity>' to find out a particular deities alignment "
             "requirements and visit the alignment room to get yours "
             "adjusted if you wish.\n"), 0, 0, "general");
   add_property("no godmother", 1);
   add_exit( "garden", PATH +"guilds_foyer", "gate" );
}
string list_deities() {
  string *deities;
  int i;
  deities = unguarded((: get_dir("/save/deities/") :));
  deities -= ({ ".", ".." });
  for(i=0; i<sizeof(deities); i++) {
    deities[i] = replace(deities[i], ".o", "");
    deities[i] = replace(deities[i], ".gz", "");
  }
  deities = map (filter(deities,
                   (: "/obj/handlers/deity_handler"->query_want_priests($1)
                    :)), (: capitalize ($1) :));
  return query_multiple_short(deities);
}

==================================================
FILE: liaison/NEWBIE/shop.c
==================================================

#include "path.h"
inherit "/std/shops/general_shop";
inherit PATH+"common";
void setup() {
  set_zone("Newbie");
  set_light( 75 );
  add_property("no teleport", 1);
  add_property("place", "Newbie Area");
  set_short("Commerce room");
  set_room_size( 5 );
  set_long( "This room is dedicated to trade and commerce.  There is a "
            "shiny counter, behind which is a shopkeeper.\n"
            "Type 'list' to get a list of the "
            "items, 'browse' to examine an item before buying it, "
            "'value' to value your items before you 'sell' them and, "
            "of course, 'buy' to buy an object from the shop.\n"
            "There is a brightly coloured sign here marked 'commerce'.\n");
  add_item( "shiny counter", "That's a display counter for the wares of the "+
            "shop.  Use the command 'list' to get a list of them." );
  add_item( ({ "object", "item", "ware" }), "Use 'list' to get a list of the "+
  "items for sale here." );
  add_item("shopkeeper", "The shopkeeper is a small man apparently in his "
           "mid-thirties.  He seems to be ready to serve you.");
  add_sign("a brightly coloured sign marked 'commerce'.\n",
           "/d/liaison/NEWBIE/foyer"->format_sign(
           "On Discworld different regions use different types of money.  "
           "Type 'help currency' for a list of conversion rates.  Money is "
           "needed to buy equipment, to learn at your guild and for a "
           "variety of other purposes.\n\n"
           "Making money can be difficult.  You can loot the corpses of "
           "your victims of course, but you can also scavenge money using "
           "the 'search' command and make money performing services for your "
           "fellow players.\n\n"
           "Spending money is the fun part.  This shop has instructions "
           "on how to use it.  Take a few minutes to buy yourself some "
           "equipment with the money you were given on login.\n"), 0,
           ({"commerce", "sign"}), "general" )->add_property("determinate","the ");
  add_exit( "foyer", PATH +"foyer", "door" );
  set_store_room( PATH +"store" );
  set_min_amount(1);
  set_max_inventory(200);
}
void init() {
  ::init();
  this_player()->add_command("speak", this_object(), "<string'language'>" );
}
int do_speak(string str) {
  write("Sorry, you cannot do that here.\n");
  return 1;
}

==================================================
FILE: liaison/NEWBIE/store.c
==================================================

#include "path.h"
#include <armoury.h>
inherit "/std/shops/storeroom";
nosave string *weapons = ({"dagger", "knife", "small knife", "short sword",
   "foil", "rapier", "cudgel", "crowbar", "knobbly mace","long sword",
   "chain", "morning star", "axe", "two-handed axe"});
nosave string *armours = ({"hard leather cap", "heavy cotton breeches",
   "ringmail", "leather breeches", "bone helm",
   "brass breastplate", "leather breastplate", "bone mail",
   "bone shield", "medium wooden shield", "small metal shield",
   "hard leather boots", "metal clad boots", "leather gloves",
   "metal gauntlets", "metal helm", "iron breastplate"});
nosave string *clothes = ({"brown linen shirt", "white linen skirt",
   "white linen tunic", "black cotton dress", "white cotton robe",
   "black leather shoes", "soft leather shoes", "grey worsted trousers",
   "fawn cotton trousers", "discreet black trousers", "black wool socks",
   "socks", "black leather shoes", "soft leather shoes", "green cloak",
   "red-brown tunic", "nightshirt", "thermal underwear", "lacy underwear",
   "jester costume", "wide brimmed hat", "soft leather gloves"});
void setup() {
  set_short( "storeroom" );
  add_property( "determinate", "the " );
  set_long( "This is a storeroom.\n" );
  set_light( 100 );
}
void reset() { call_out( "restock", 0 ); }
void restock() {
  int i, size;
  object thing;
  object new_item;
  i = sizeof( match_objects_for_existence( "buckets", this_object() ) );
  for ( ; i < 3; i ++ ) {
    thing = clone_object( "/obj/vessel" );
    if (thing) {
      size = random( 3 );
      thing->set_leak_rate( 0 );
      thing->set_max_volume( 1000 + size * 2000 );
      thing->set_max_weight( 20 + size * 40 );
      thing->set_full_weight( 20 + size * 40 );
      thing->set_stuck( 1 );
      thing->set_name( "bucket" );
      thing->set_short( ({ "small", "medium", "large" })[ size ]
                        +" bucket" );
      thing->set_main_plural( ({ "small", "medium", "large" })[ size ]
                              +" buckets" );
      thing->add_adjective( ({ "small", "medium", "large" })[ size ] );
      thing->set_value( 60 + size * 25 );
      thing->set_long( "This is a metal thing.  It is not very shiny.\n" );
      thing->set_weight( 10 + size * 10 );
      thing->move( this_object() );
    }
  }
  i = sizeof( match_objects_for_existence( "torches", this_object() ) );
  for ( ; i < 6; i++ ) {
    new_item = ( ARMOURY->request_item("torch", 100) );
    if (new_item) new_item->move( this_object() );
  }
  for(i=0; i<30; i++) {
    new_item = ( ARMOURY->request_weapon( weapons[random(sizeof(weapons))],
                   95 ) );
    if (new_item) new_item->move( this_object() );
  }
  for(i=0; i<25; i++) {
    new_item = ( ARMOURY->request_armour( armours[random(sizeof(armours))],
                   95 ) );
    if (new_item) new_item->move( this_object() );
  }
  for(i=0; i<30; i++) {
    new_item = ( ARMOURY->request_clothing( clothes[random(sizeof(clothes))],
                   95 ) );
    if (new_item) new_item->move( this_object() );
  }
}

==================================================
FILE: liaison/NEWBIE/thieves.c
==================================================

#include "path.h"
inherit PATH + "inside";
void setup() {
  set_short( "Thieves' Gazebo" );
  set_light( 75 );
  add_property("no teleport", 1);
  set_long( "You carefully sneak into this small gazebo.  You're not "
            "really sure why, but you don't feel comfortable in here.  You "
            "hope to make it out, without anyone noticing you.  Sneaking a "
            "quick glance around here you see piles of stolen items from the "
            "citizens of Ankh-Morpork.  There is a small sign cowering in "
            "a corner.  If you 'read sign' maybe you'll be able to find "
            "out a bit more about this dangerous profession.\n"
            "A small notice resembling the backside of a receipt states that "
            "this is not actually the place where you join the guild.\n" );
  set_zone( "Newbie" );
  add_item( ({ "item" }), "There "
            "are many items around the room, but their function is beyond "
            "you for the most part." );
  add_item( ({ "notice" }),
            "This small notice looks like the backside of a receipt of some "
            "kind.\n" );
  add_sign( "This poor sign sits huddled in a dark corner of this "
            "foreboding room.\n", "This guild specializes in stealing all "
            "they can from the citizens and player killers of Ankh-Morpork.  They "
            "will teach you the fine art of thieving - how to steal from your "
            "friends and enemies.  Not only is this a dangerous profession, "
            "but it is also a great way to get some pocket change.  Picking "
            "pockets is just one of the things you will get to learn from "
            "this bunch of Authorized Income Redistributors.",
            0, 0, "general");
  add_property("no godmother", 1);
  add_exit( "garden", PATH +"guilds_foyer", "gate" );
}

==================================================
FILE: liaison/NEWBIE/trainer.c
==================================================

#include <weapon.h>
#include <armoury.h>
inherit "/obj/monster";
object *greeters = ({ });
#define GREETINGS ({ \
   "Welcome to Combat Boot Camp, $name$.",\
   "This here course is set up to teach you the basics of fighting.",\
   "You can attack this here dummy and I'll tell ya how well ya done.",\
   "Arr!  You have the look of a fine fighter, $name$." \
})
void setup() {
  set_language( "general" );
  basic_setup( "human", "warrior", 100 );
  set_gender( 1 );
  ARMOURY->request_item("leather jerkin", 30)->move( this_object() );
  ARMOURY->request_item("leather breeches", 30)->move( this_object() );
  ARMOURY->request_item("hard leather boots", 30)->move( this_object() );
  init_equip();
}
void whichone(string name) {
  switch(name) {
  case "xrazzicaz":
    set_name( "xrazzicaz" );
    add_alias( "xraz" );
    add_property( "determinate", "" );
    set_short( "Xrazzicaz" );
    set_long( "This is the former Warriors' Guild dummy.  After being replaced by "
              "the newer mechanical dummy, Xrazzicaz decided to stay on as an "
              "instructor.\n");
    break;
  case "zazzifraz":
  set_name( "zazzifraz" );
  add_alias( "zazz" );
  add_property( "determinate", "" );
  set_short( "Zazzifraz" );
  set_long( "This is Xrazzicaz' brother, a former Warriors' Guild dummy.  After "
            "being replaced by the newer mechanical dummy, Zazzifraz, like "
            "his brother, decided to stay on as an instructor.\n");
  break;
  case "john":
    set_name( "john" );
    add_property( "determinate", "" );
    set_short( "John" );
    set_long( "This is Xrazzicaz' other brother, John.  He was the Warriors' "
              "Guild dummy in Ohulan Cutash until he was replaced by a "
              "mechanical dummy.  Like Xrazzicaz and Zazzifraz he got a "
              "job teaching after retirement.\n");
  }
}
int attack_by(object thing) {
  write(this_object()->the_short() + " glares at you before swiftly knocking "
    "you to the ground.\n");
  this_object()->stop_fight(thing);
  thing->stop_fight(this_object());
  return 0;
}
int attack_ob(object thing) {
  this_object()->stop_fight(thing);
  thing->stop_fight(this_object());
  return 0;
}
void init() {
  if(!this_player()) {
    return;
  }
  if(environment() == find_object("/room/rubbish")) {
    return;
  }
  if(this_player()->query_property("dead")) {
    return;
  }
  if(!this_player()->query_visible(this_object())) {
    return;
  }
  if(!userp(this_player())) {
    return;
  }
  if(this_player()->query_property("player")) {
    greeters += ({this_player()});
    call_out("do_greeting", 1, this_player());
  }
}
void do_greeting() {
  string str;
  if(!sizeof(greeters)) {
    return;
  }
  greeters = filter(greeters,
    (: $1 && environment($1) == environment(this_object()) &&
     $1->query_visible(this_object()) :));
  uniq_array(greeters);
  foreach(str in GREETINGS) {
    str = replace(str, "$name$", query_multiple_short(greeters));
    do_command("'" + str);
  }
  greeters = ({ });
}
void stop_them( object attacker, object dummy ) {
  tell_object( attacker, one_short() +" stops you attacking "+
               (string)dummy->the_short() +".\n" );
  tell_room( environment(), one_short() +" stops "+
             (string)attacker->the_short() +" attacking "+
             (string)dummy->the_short() +".\n", attacker );
  attacker->stop_fight( dummy );
  dummy->stop_all_fight();
}

==================================================
FILE: liaison/NEWBIE/witches.c
==================================================

#include "path.h"
inherit PATH + "inside";
void setup() {
   set_short( "Witches' Gazebo" );
   set_light( 75 );
   add_property("no teleport", 1);
   set_long( "As you wander in through the small gate to this little room, "
             "you are overwhelmed by an array of smells.  Of course, you "
             "can't identify any of these smells nor any of the items that "
             "are strewn about haphazardly.  The only thing you can identify "
             "is a nicely embroidered sign hanging on the wall.  Maybe if you "
             "'read sign' you'll learn a bit about the Witches' Guild.\n"
             "A small notice, which seems to have been used as a teabag, "
             "states that this is not actually the place where you join this "
             "guild.\n" );
   set_zone( "Newbie" );
   add_item( ({ "item" }), "There "
             "are several items of inexplicable function scattered around the "
             "room.  Some of these may be the source of the smells, but you "
             "wisely hesitate to test this possibility." );
   add_item( ({ "notice" }),
             "This small, tea stained notice is casually leaned against a "
             "strange item." );
   add_sign( "The sign is beautifully embroidered and somehow makes the "
             "room brighter and darker at the same time.\n",
             FOYER->format_sign("This guild "
             "is very unusual in that it only accepts those of the "
             "*female* persuasion.  It is "
             "a magical guild, but not the magic of wizards and mages.  "
             "Witch magic is the magic of herbs, cursing, flying around, "
             "and most importantly, headology.\n\n"
             "The prominent witches of the Discworld will be "
             "able to tell you more about headology.  Granny Weatherwax, "
             "whom you must see to join the guild, will be particularly "
             "helpful.  So, if you think you have what it takes to learn "
             "how to know what is real, what is not, and how to tell the "
             "difference, then give the Witches' Guild a go!  Granny, "
             "Nanny Ogg, and Magrat Garlick will be there to greet you.  "
             "Oh, and if you need help getting there, just go see good old "
             "Gennie Applebottom in Ankh-Morpork.  She'll help you out, as "
             "will almost any witch!  "
             "And don't forget, Witches prefer to use the back door "
             "to enter a house.\n"), 0, 0, "general");
   add_property("no godmother", 1);
   add_exit( "garden", PATH +"guilds_foyer", "gate" );
}

==================================================
FILE: liaison/NEWBIE/wizards.c
==================================================

#include "path.h"
inherit PATH + "inside";
void setup() {
   set_short( "Wizards' Gazebo" );
   set_light( 75 );
   add_property("no teleport", 1);
   set_long( "As you enter this gazebo, it is obvious that it is the room "
             "of a mage.  Strewn around are pointy hats, wands and other "
             "items of wizardly paraphernalia.  A small sign catches your "
             "eye.  Maybe if you 'read sign' you'll find something out "
             "about this magical guild.\n"
             "A small notice that, for some reason, is extremely fat, wearing "
             "a pointy hat and winking at you, states that this is not the "
             "place where you actually join the guild.\n" );
   set_zone( "Newbies" );
   add_item( ({ "pointy hat", "wand", "item", "paraphernalia" }),
             "There are many items around the room, but their function is "
             "beyond you for the most part." );
   add_item( "notice",
             "This notice is extremely fat, wears a pointy hat and winks at "
             "you -- that's magic for you." );
   add_sign( "The sign is floating, apparently unsupported, in the "
         "centre of the room.\n", "In this magical guild, based at "
         "Unseen University in Ankh-Morpork, you can learn many "
         "wonderful and exciting spells.  Learn how to tickle an "
         "enemy with a feather, create cabbage pets for your friends "
         "and hold your own against muggers using a carrot "
         "and a torch, or even a human eye!  The Library at the Unseen "
         "University (U.U.) is extensive, with many books in which to "
         "search for that special spell.  You'll learn all this and more "
         "if you decide to follow the Higher Art.", 0, 0, "general" );
   add_property("no godmother", 1);
   add_exit( "garden", PATH +"guilds_foyer", "gate" );
}

==================================================
FILE: liaison/NEWBIE/womble.c
==================================================

#include "path.h"
#include <library.h>
inherit "/obj/monster";
void setup() {
  set_name("womble");
  set_short("womble");
  set_long("This is a small, furry womble.  She is about four feet "
           "tall and looks very cuddly.  She also looks very sad and "
           "is sobbing loudly.\n");
  add_property( "unique", 1 );
  set_gender(2);
  add_plural("wombles");
  set_race("human");
  set_level(100);
  set_language("general");
  add_move_zone("Newbie");
  set_move_after(30, 30);
  set_response_mon_understand_anything(1);
  set_respond_to_with(({
    ({"@comfort", "womble"}),
      "'Thank you, will you find my brooch for me?",
    ({({"@kick", "@punch"}), "womble"}),
      "cry"}));
  add_respond_to_with(({ ({ "hello", "hi", "gday", }),
                     ({ "womble", "all" }) }), ({ "'Hello $hcname$",
                                                    "greet $hname$" }));
  add_respond_to_with(
                           ({ ({"good day", "greetings"}),
         ({ "womble", "all" }) }), ({ "'Hello $hcname$",
                                        "bow deep $hname$" }));
  add_respond_to_with(
   ({ "fuck", ({ "off", "you" }) }), ({ "'Same to you!", "skick $hname$" }));
  add_respond_to_with(({ "fuck" }), "waggle $hname$");
  add_respond_to_with(
                      ({ "@smile", "womble" }), "smile $hname$");
  add_respond_to_with(
     ({ ({ "@skick", "@spunch", "@jump", "@pat", "@slap" }),
          "womble" }), "glare $hname$");
  add_respond_to_with(
                      ({ ({ "@poke", "@glare", "@point" }),
                           "womble" }), "peer sus at $hname$");
  add_respond_to_with(
                      ({ "@grin", "womble" }), "grin $hname$");
  add_respond_to_with(
                ({ ({ "@caress", "@snuggle", "@nestle", "@love", "@throw" }),
                     "womble" }), "waggle $hname$");
  add_respond_to_with(
                      ({ ({ "@kiss", "@french", }),
                           "womble" }), "slap $hname$");
  add_respond_to_with(({ ({ "@bing", "@womble", }),
                           "womble" }), "smile bri $hname$");
  load_chat(50, ({
    1, ":sobs loudly.",
    1, "'Boo Hoo!  I've lost my brooch!",
    1, "@weep",
    1, "'I really loved that brooch.",
    1, "@cry",
    1, "'Oh I wish someone would find it for me.",
    2, "'Please find my brooch for me.",
    2, "'I lost my brooch in one of the rooms while I was reading all "+
       "the wonderful information here."}) );
}
void event_enter(object obj, string mess, object from) {
  if( (obj->query_property("wombles brooch")) &&
      (obj->query_name() == "brooch") &&
      (environment(obj) == this_object()) ) {
    call_out("brooch", 1, ({ this_player() }) );
  }
}
void brooch(mixed arg) {
  object item, tp;
  tp = arg[0];
  if(tp->query_property("womble's brooch")) {
    do_command("'Thank you for returning my brooch again.");
  } else {
    tp->add_property("womble's brooch", 1, 86400);
    tp->adjust_xp(10000);
    do_command("'Wow!  My brooch!");
    do_command("'Thank you very much!");
  }
  do_command("'You may now enter the game by typing \"out\" in the foyer.");
  do_command("'Good Luck!");
  do_command("huggle "+(string)tp->query_short());
  do_command("emote sets the brooch down, and quickly forgets where she left it.");
  foreach(item in all_inventory()) {
    item->dest_me();
  }
}
int attack_by(object thing) {
  write("The womble smacks you round the head with her paw sending you "
  "flying across the room.\n");
  write("You bash your head against the wall and the world starts "
  "spinning.\n");
  do_command("'Hey, that's not nice!\n");
  thing->add_effect("/std/effects/ingested/tranquil_sleep", 120);
  this_object()->stop_fight(thing);
  thing->stop_fight(this_object());
  return 0;
}
int attack_ob(object thing) {
  this_object()->stop_fight(thing);
  thing->stop_fight(this_object());
  return 0;
}

==================================================
FILE: liaison/NEWBIE/womble_brooch.c
==================================================

#include "path.h"
inherit "/obj/armour";
void setup()
{
  set_name("brooch");
  add_adjective( ({ "womble", "brass" }) );
  set_short("womble brooch");
  set_long("A brass brooch with a womble engraved "
    "upon it.\n");
  add_alias("jewellery");
  add_plural("jewellery");
  set_type("badge");
  setup_armour(1000);
  set_percentage(100);
  set_damage_chance(0);
  set_weight(2);
  add_property("wombles brooch", 1);
  add_property( "shop type", "jewellers" );
}
