
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/voting_room.c ===
#include <board.h>
#define DEFAULT_VOTE_DURATION 2600*24*7
inherit "/std/room/basic_room";
inherit "/std/room/inherit/voting_room";
void create() {
  voting_room::create();
  do_setup++;
  add_help_file("voting_room");
  basic_room::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  seteuid("Room");
}
void init() {
   basic_room::init();
   voting_room::init();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/safe_room.c ===
#include <armoury.h>
#define TP this_player()
#define SHAD "/std/shadows/misc/davidshad"
inherit "/std/room/basic_room";
object keeper;
void create() {
    do_setup++;
    ::create();
    do_setup--;
    set_light(90);
    add_property("warmth", 3);
    add_property( "los", "closed" );
    add_property("calm room", 1);
    if(!do_setup) {
      this_object()->setup();
      this_object()->reset();
  }
}
int trap_action( string str ) {
    string st1;
    if( sscanf( str,"%s %s",str,st1 ) );
    switch(str) {
    case "ambush":
    case "attack":
    case "backstab":
    case "behead":
    case "bury":
    case "cast":
    case "circle":
    case "conflagrate":
    case "crush":
    case "decompose":
    case "drag":
    case "eat":
    case "ensumpf":
    case "fade":
    case "filch":
    case "fire":
    case "fuel":
    case "guard":
    case "hedgehog":
    case "hide":
    case "hurl":
    case "iai":
    case "inhume":
    case "inpale":
    case "invoke":
    case "kill":
    case "mock":
    case "order":
    case "tempt":
    case "palm":
    case "perform":
    case "plant":
    case "pyroscipate":
    case "scathe":
    case "scribe":
    case "scry":
    case "shroud":
    case "slip":
    case "snatch":
    case "sneak":
    case "steal":
    case "recharge":
    case "rifle":
    case "throw":
    case "twist":
    case "use":
    case "ventisepelate":
    case "zap":
    case "skick":
    case "sburn":
    case "slap":
    case "spunch":
    case "berserk":
        tell_object( this_player(), "You feel too peaceful to do that.\n");
        return 1;
    default:
        return 0;
    }
}
void event_exit(object ob, string message, object to);
void init() {
    this_player()->remove_hide_invis( "hiding" );
    clone_object( SHAD )->setup_shadow(TP);
    this_player()->command_override( (: trap_action :) );
    this_player()->add_command( "dream", this_object(), "" );
    this_player()->add_command( "rest", this_object(), "" );
    ::init();
}
void set_keeper(object ob) { keeper = ob; }
void event_exit(object ob, string message, object to){
    ob->dest_shadow();
}
void event_enter( object ob, string stringy, string stringy2 ) {
    object thing;
    if ( base_name( ob ) == "/d/guilds/priests/summoned/dust_devil" ) {
        ob->do_leave();
    }
    if ( base_name( ob ) == "/d/am/chars/herrena" ) {
            int *enums = ob->effects_matching( "fighting.combat" );
            foreach( int i in enums ) ob->delete_effect( i );
    }
    foreach( thing in all_inventory(ob)) {
        if( base_name( thing ) == "/d/sur/items/crystal_ball" )
            thing->do_rub();
    }
    if ( living( ob ) )
        call_out("make_calm", 1, ob );
        call_out( "stop_sneaking", 1, ob );
}
int do_rest( string str ) {
    this_player()->adjust_hp( 4 );
    this_player()->adjust_gp( -( 2 + random( 4 ) ) );
    this_player()->adjust_social_points( -( 2 + random(8)));
    tell_object( this_player() ,
      "You rest on one of the pillows, and feel much "
      "better for it.\n");
    return 1;
}
int do_dream( string str ) {
    this_player()->adjust_hp( 4 );
    this_player()->adjust_gp( -( 2 + random( 4 ) ) );
    this_player()->adjust_social_points( -( 2 + random(8)));
    tell_object( this_player(), ({
      "You dream of a world where cabbages roam free.\n",
      "You have a vision of penguin waiters serving giraffes in white leisure "
         "suits.\n",
      "You dream of imp-powered sheep leaping over fences.\n",
      "You dream uneasily of creators with cuddly teddy-bears.\n",
      "Visions of sugar-plums dance through your head.\n",
      "You count lemons as you try to get to sleep.\n" }) [ random(4) ] );
    return 1;
}
void event_fight_in_progress( object ob1, object ob2 ) {
    if ( keeper ) { tell_room ( this_object(),
    keeper->the_short() + " hums a peaceful tune softly and calm fils the "
      "room." ); }
    ob2->stop_all_fight();
    ob1->stop_all_fight();
}
void make_calm( object blue ) {
    int *enums;
    int wibble;
    enums = blue->effects_matching("fighting.combat");
    if ( sizeof( enums ) ) {
        foreach( wibble in enums ) { blue->delete_effect( wibble ); }
        keeper->do_command("smile "+ blue->query_name() );
        tell_object( blue, "You feel a lot calmer.\n");
    }
}
void stop_sneaking( object sneaker ) {
    int *enums;
    int wibble;
    enums = sneaker->effects_matching( "covert.sneaking" );
    if ( sizeof( enums ) ) {
        foreach( wibble in enums ) { sneaker->delete_effect( wibble ); }
        keeper->do_command("hug "+ sneaker->query_name() );
        tell_object( sneaker, "You feel less sneaky.\n");
    }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/council_fine.c ===
#include <money.h>
#include <nomic_system.h>
#include <player_handler.h>
inherit "/std/room/basic_room";
inherit "/std/room/inherit/council_base";
private string _fine_handler;
void create() {
   ::create();
   add_help_file("fines");
}
void set_fine_handler(string fine) {
   _fine_handler = fine;
}
string query_fine_handler() {
   return _fine_handler;
}
int do_pay() {
   string place;
   mixed* m_array;
   int fine;
   int value;
   fine = _fine_handler->query_current_fine(this_player()->query_name());
   if (!fine) {
      add_failed_mess("You do not have any fines due here.\n");
      return 0;
   }
   place = query_property("place");
   value = this_player()->query_value_in(place);
   if (value >= fine) {
      m_array = MONEY_HAND->create_money_array(fine, place);
      this_player()->pay_money(m_array, place);
      _fine_handler->pay_fine(this_player()->query_name(), fine);
      write("You pay off all of your fine of " +
            MONEY_HAND->money_value_string(fine, place) + ".\n");
   } else {
      m_array = MONEY_HAND->create_money_array(value, place);
      this_player()->pay_money(m_array, place);
      _fine_handler->pay_fine(this_player()->query_name(), value);
      write("You pay off " +
            MONEY_HAND->money_value_string(value, place) +
            " of your fine of " +
            MONEY_HAND->money_value_string(fine, place) + ".\n");
   }
   add_succeeded_mess(({ "", "$N $V $p fine.\n" }));
   return 1;
}
string query_fine_information(string person) {
   string ret;
   int fine;
   string place;
   place = query_property("place");
   ret = "";
   fine = _fine_handler->query_current_fine(person);
   if (!fine) {
      ret += "No current fine.\n";
   } else {
      ret += "Current fine of " +
            MONEY_HAND->money_value_string(fine, place) + ".\n";
   }
   fine = _fine_handler->query_total_fine(person);
   if (!fine) {
      ret += "No fines ever.\n";
   } else {
      ret += "Total fines of " +
            MONEY_HAND->money_value_string(fine, place) + ".\n";
   }
   fine = _fine_handler->query_total_payments(person);
   if (!fine) {
   } else {
      ret += "Total fine payments of " +
            MONEY_HAND->money_value_string(fine, place) + ".\n";
   }
   return ret;
}
int do_fine() {
   write(query_fine_information(this_player()->query_name()));
   add_succeeded_mess(({ "", "$N look$s up a fine.\n" }));
   return 1;
}
int do_show_fine(string person) {
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("You must find a fine for an existing person.\n");
      return 0;
   }
   write(person + ":\n" + query_fine_information(person));
   add_succeeded_mess(({ "", "$N look$s up a fine.\n" }));
   return 1;
}
int do_show_all_fines() {
   string ret;
   int fine;
   ret = "";
   foreach (string person in _fine_handler->query_people_with_fines()) {
      fine = _fine_handler->query_current_fine(person);
      if (fine) {
         ret += person + " " + query_fine_information(person) + "\n";
      }
   }
   write("$P$Fines$P$" + ret);
}
void init() {
   add_command("pay", "fine", (: do_pay() :));
   add_command("fine", "", (: do_fine() :));
   if (NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                       this_player()->query_name())) {
      add_command("fine", "<string'player'>", (: do_show_fine($4[0]) :));
      add_command("fine", "all", (: do_show_all_fines :));
      add_command("list", "fines", (: do_show_all_fines :));
   }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/council_cases.c ===
inherit "/std/room/basic_room";
inherit "/std/room/inherit/council_base";
#define NOMIC_SYSTEM_CASE_CLASSES
#include <nomic_system.h>
#include <player_handler.h>
#include <mail.h>
void add_punishment_type(string name, string file);
string query_punishment_type(string name);
private mapping _types;
void create() {
   _types = ([ ]);
   ::create();
   if (!query_punishment_type("not guilty")) {
      add_punishment_type("not guilty", NOMIC_PUNISHMENT_DIR + "not_guilty");
   }
   if (!query_punishment_type("dismissed")) {
      add_punishment_type("dismissed", NOMIC_PUNISHMENT_DIR + "dismissed");
   }
   if (!query_punishment_type("lose citizenship")) {
      add_punishment_type("lose citizenship",
                          NOMIC_PUNISHMENT_DIR + "lose_citizenship");
   }
   add_help_file("cases");
}
void add_punishment_type(string name, string file) {
   _types[name] = file;
}
string query_punishment_type(string name) {
   return _types[name];
}
void start_punishment(string name, class nomic_case the_case, function finish) {
   string bing;
   bing = query_punishment_type(name);
   if (bing) {
      call_other(bing, "start_punishment", query_council_area(),
                 the_case, name, finish);
   } else {
      write("Big hairy error.\n");
   }
}
void complete_punishment(string name, class nomic_case the_case, mixed data) {
   string bing;
   bing = query_punishment_type(name);
   if (bing) {
      call_other(bing, "complete_punishment", query_council_area(),
                 the_case, name, data);
   } else {
      write("Big hairy error.\n");
   }
}
void suspend_punishment(class nomic_case the_case) {
   string bing;
   class nomic_case_event event;
   string type;
   mixed data;
   foreach (event in the_case->events) {
      if (event->type == NOMIC_CASE_EVENT_CLOSE) {
         type = event->data[0];
         data = event->data[1];
      }
   }
   bing = query_punishment_type(type);
   if (bing) {
      call_other(bing, "suspend_punishment", query_council_area(),
                 the_case, type, data);
   } else {
      write("Big hairy error.\n");
   }
}
string query_punishment_short(string name, class nomic_case the_case,
                              mixed data) {
   string bing;
   bing = query_punishment_type(name);
   if (bing) {
      return call_other(bing, "query_short", query_council_area(), the_case, name, data);
   } else {
      return "Big hairy error.\n";
   }
}
string query_punishment_mail_info(string name, class nomic_case the_case,
                              mixed data) {
   string bing;
   bing = query_punishment_type(name);
   if (bing) {
      return call_other(bing, "query_mail_information", query_council_area(), the_case,
                        name, data);
   } else {
      return "Big hairy error.\n";
   }
}
string* query_all_punishment_types() {
   return keys(_types);
}
string query_extra_player_status(string player) {
   return 0;
}
string query_last_appealer(class nomic_case the_case) {
   class nomic_case_event event;
   string ret;
   ret = 0;
   foreach (event in the_case->events) {
      if (event->type == NOMIC_CASE_EVENT_APPEAL) {
         ret = event->person;
      }
   }
   return ret;
}
int is_last_appealer(class nomic_case the_case, string person) {
   return query_last_appealer(the_case) == person;
}
string query_last_closer(class nomic_case the_case) {
   class nomic_case_event event;
   string ret;
   ret = 0;
   foreach (event in the_case->events) {
      if (event->type == NOMIC_CASE_EVENT_CLOSE) {
         ret = event->person;
      }
   }
   return ret;
}
int is_last_closer(class nomic_case the_case, string person) {
   return query_last_closer(the_case) == person;
}
int do_list_punishments() {
   string punish;
   string file;
   write("Punishments:\n");
   foreach (punish, file in _types) {
      write("   " + punish + "\n");
   }
   return 1;
}
int do_list_punishments_desc(string type) {
   string file;
   write("Punishments:\n");
   file = _types[type];
   if (!file) {
      add_failed_mess("No punishment of type " + type + ".\n");
      return 0;
   }
   this_player()->more_string(file->query_description(), "punishment");
   return 1;
}
int do_open_case(string people, string short) {
   string* bits;
   string* bad;
   string person;
   people = replace_string(people, " and ", ",");
   people = replace_string(people, " ", "");
   bits = explode(lower_case(people), ",");
   bad = ({ });
   foreach (person in bits) {
      if (!PLAYER_HANDLER->test_user(person)) {
         bad += ({ person });
      }
   }
   if (member_array(this_player()->query_name(), bits) != -1) {
      bits = bits - ({ this_player()->query_name() });
   }
   if (sizeof(bad) == 1) {
      add_failed_mess("The player " + query_multiple_short(bad) +
                      " does not exist.\n", bad);
      return 0;
   } else if (sizeof(bad)) {
      add_failed_mess("The players " + query_multiple_short(bad) +
                      " do not exist.\n", bad);
      return 0;
   }
   if (!sizeof(bits)) {
      add_failed_mess("There have to be some people involved in the case.\n");
      return 0;
   }
   write("For the case with the people " + query_multiple_short(bits) +
         " and a short of " + short + ", please type in an intial "
         "description of the case.\n");
   this_player()->do_edit("", "open_case_desc", this_object(), 0,
                          ({ bits, short }));
   return 1;
}
void open_case_desc(string desc, mixed* extra) {
   string* bits;
   string short;
   bits = extra[0];
   short = extra[1];
   if (!desc) {
      write("Aborted.\n");
      return ;
   }
   write("Adding in a case with " + query_multiple_short(bits) +
         " people and a short description of " + short + ".\nYour note is:\n");
   write(desc);
   write("\nAre you sure you wish to add this? ");
   input_to("open_case_desc_confirm", 0, bits, short, desc);
}
void open_case_desc_confirm(string response, string* bits,
                            string short, string desc) {
   int id;
   string* magistrates;
   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborting the addition of the case.\n");
      return ;
   }
   id = NOMIC_HANDLER->add_new_case(query_council_area(),
                                    this_player()->query_name(), short,
                                    bits);
   if (id) {
      NOMIC_HANDLER->add_note_to_case(query_council_area(),
                                      id, this_player()->query_name(),
                                      desc);
      write("Added the case into the system.\n");
      magistrates = NOMIC_HANDLER->query_magistrates(query_council_area());
      MAILER->do_mail_message(implode(magistrates + bits, ","),
                           query_council_area() + " magistrates",
                           "New case against " + implode(bits, ","),
                           "",
                           "A new case is opened against " +
                           implode(bits, ",") +
                           " by " + this_player()->query_cap_name() +
                           "\nwith a reason of:\n" +
                           desc);
      tell_room(this_object(),
           this_player()->the_short() + " opens a case against " +
           query_multiple_short(bits) + ".\n", ({ this_player() }) );
   } else {
      write("Unable to add the case for some reason.\n");
   }
}
string query_case_short(class nomic_case the_case) {
   string ret;
   ret = "Case #" + the_case->id + " \"" +
         the_case->short + "\" opened by " + the_case->opener +
         " against " + query_multiple_short(the_case->people) + " at " +
         ctime(the_case->time_opened);
   return ret;
}
int do_list_open_cases() {
   int* cases;
   string ret;
   class nomic_case the_case;
   int id;
   cases = NOMIC_HANDLER->query_open_cases(query_council_area());
   if (!sizeof(cases)) {
      add_failed_mess("There are no open cases.\n");
      return 0;
   }
   ret = "Currently open cases:\n";
   foreach (id in cases) {
      the_case = NOMIC_HANDLER->query_open_case(query_council_area(), id);
      ret += "$I$5=$C$" + query_case_short(the_case);
      ret += "\n";
   }
   this_player()->more_string(ret, "open cases");
   return 1;
}
int do_list_closed_cases() {
   int* cases;
   string ret;
   class nomic_case the_case;
   int id;
   cases = NOMIC_HANDLER->query_recently_closed_cases(query_council_area());
   if (!sizeof(cases)) {
      add_failed_mess("There are no recently closed cases.\n");
      return 0;
   }
   ret = "Recently closed cases:\n";
   foreach (id in cases) {
      the_case = NOMIC_HANDLER->query_recently_closed_case(query_council_area(), id);
      ret += "$I$5=$C$" + query_case_short(the_case);
      ret += "\n";
   }
   this_player()->more_string(ret, "closed cases");
   return 1;
}
int do_list_case(int case_id) {
   string ret;
   class nomic_case the_case;
   class nomic_case_note note;
   class nomic_case_event event;
   int id;
   ret = "";
   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   if (!the_case) {
      add_failed_mess("Unable to find the case.\n");
      return 0;
   }
   ret += "$I$3=" + query_case_short(the_case);
   if (sizeof(the_case->events)) {
      ret += "\n";
      ret += "$I$0=%^YELLOW%^Events%^RESET%^:\n";
      foreach (event in the_case->events) {
         ret += "$I$6=   " +
                capitalize(NOMIC_HANDLER->query_event_name(event->type)) +
                " " +
                "by " + event->person + " at " + ctime(event->event_time) +
                " " +
                event->mess + "\n";
      }
   }
   if (sizeof(the_case->notes)) {
      ret += "\n";
      ret += "$I$0=%^YELLOW%^Notes%^RESET%^:\n";
      foreach (id in the_case->notes) {
         note = NOMIC_HANDLER->query_note(id);
         ret += "$I$6=   Note by " + note->person + " at " +
                ctime(note->time_created) +
                ".\n" + note->text + "\n\n";
      }
   }
   this_player()->more_string(ret, "open cases");
   return 1;
}
int do_list_closed_case(int case_id) {
   string ret;
   class nomic_case the_case;
   class nomic_case_note note;
   class nomic_case_event event;
   int id;
   int* cases;
   ret = "";
   cases = NOMIC_HANDLER->query_recently_closed_cases(query_council_area());
   if (member_array(case_id, cases) == -1) {
      add_failed_mess("Unable to find the case.\n");
      return 0;
   }
   the_case = NOMIC_HANDLER->query_recently_closed_case(query_council_area(),
                                                        case_id);
   if (!the_case) {
      add_failed_mess("Unable to find the case.\n");
      return 0;
   }
   ret += "$I$3=" + query_case_short(the_case);
   if (sizeof(the_case->events)) {
      ret += "\n";
      ret += "$I$0=%^YELLOW%^Events%^RESET%^:\n";
      foreach (event in the_case->events) {
         ret += "$I$6=   " +
                capitalize(NOMIC_HANDLER->query_event_name(event->type)) +
                " " +
                "by " + event->person + " at " + ctime(event->event_time) +
                " " + event->mess + ".\n";
      }
   }
   if (sizeof(the_case->notes)) {
      ret += "\n";
      ret += "$I$0=%^YELLOW%^Notes%^RESET%^:\n";
      foreach (id in the_case->notes) {
         note = NOMIC_HANDLER->query_note(id);
         ret += "$I$6=   Note by " + note->person + " at " +
                ctime(note->time_created) +
                ".\n" + note->text + "\n\n";
      }
   }
   this_player()->more_string(ret, "open cases");
   return 1;
}
int do_add_person(int case_id, string person) {
   class nomic_case the_case;
   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   if (!the_case) {
      add_failed_mess("Unable to find the id of the case.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("You must be a magistrate to add a person from "
                      "the case.\n");
      return 0;
   }
   if (member_array(this_player()->query_name(), the_case->people) != -1 ||
       this_player()->query_name() == the_case->opener) {
      add_failed_mess("You cannot add a person to a case involving you or "
                      "started by you.\n");
      return 0;
   }
   write("What reason to wish to give for adding this person?\n");
   this_player()->do_edit("", "person_desc", this_object(), 0,
                          ({ case_id, person, "add" }));
   return 1;
}
void person_desc(string desc, mixed* stuff) {
   int case_id;
   string person;
   string type;
   class nomic_case the_case;
   case_id = stuff[0];
   person = stuff[1];
   type = stuff[2];
   if (!desc) {
      write("Aborted " + type + "ing " + person + ".\n");
      return ;
   }
   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   write("Are you sure you wish to " + type + " " + person + " to the "
        "case " + query_case_short(the_case) + ".\n");
   input_to("person_confirm", 0, case_id, person, type, desc);
}
void person_confirm(
   string response,
   int case_id,
   string person,
   string type,
   string desc
) {
   string* people;
   class nomic_case the_case;
   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborted " + type + "ing " + person + ".\n");
      return ;
   }
   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   people = the_case->people;
   if (type == "add") {
      if (NOMIC_HANDLER->add_person_to_case(query_council_area(), case_id,
                                            this_player()->query_name(),
                                            person, "\n" + desc)) {
         write("Sucessfully added " + person + " to the case.\n");
         people += ({ person });
      } else {
         write("Unable to add " + person + " to the case.\n");
         return ;
      }
   } else {
      if (NOMIC_HANDLER->remove_person_from_case(query_council_area(), case_id,
                                            this_player()->query_name(),
                                            person, "\n" + desc)) {
         write("Sucessfully removed " + person + " from the case.\n");
      } else {
         write("Unable to remove " + person + " from the case.\n");
         return ;
      }
   }
   MAILER->do_mail_message(implode(people, ","),
                           query_council_area() + " magistrates",
                           capitalize(type) + " person",
                           "",
                           "From the desk of " +
                           this_player()->query_cap_name() + ":\n"
                           "The " + type + "ing the person " + person +
                           " to the case " +
                           query_case_short(the_case) +
                           "\nwith a reason of:\n" +
                           desc);
   tell_room(this_object(),
           this_player()->the_short() + " " + type + "s " + person +
           " to case #" + the_case->id + ".\n", ({ this_player() }) );
}
int do_remove_person(int case_id, string person) {
   class nomic_case the_case;
   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   if (!the_case) {
      add_failed_mess("Unable to find the id of the case.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("You must be a magistrate to remove a person "
                      "from the case.\n");
      return 0;
   }
   if (member_array(this_player()->query_name(), the_case->people) != -1 ||
       this_player()->query_name() == the_case->opener) {
      add_failed_mess("You cannot remove a person to a case involving you or "
                      "started by you.\n");
      return 0;
   }
   if (sizeof(the_case->people) == 1) {
      add_failed_mess("You cannot remove everyone from the case.\n");
      return 0;
   }
   write("What reason to wish to give for removeing this person?\n");
   this_player()->do_edit("", "person_desc", this_object(), 0,
                          ({ case_id, person, "remove" }));
   return 1;
}
int do_add_note(int case_id) {
   class nomic_case the_case;
   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   if (!the_case) {
      add_failed_mess("Unable to find the id of the case.\n");
      return 0;
   }
   write(query_case_short(the_case));
   write("\nAdd note:\n");
   this_player()->do_edit("", "note_case_desc", this_object(), 0,
                          the_case);
   return 1;
}
void note_case_desc(string desc, class nomic_case the_case) {
   if (!desc) {
      write("Aborted.\n");
   }
   write("Do you wish to add the note to the case " +
         query_case_short(the_case) + ".\n");
   write(desc + "\nAre you sure you wish to add this note? ");
   input_to("note_case_desc_confirm", 0, desc, the_case);
}
void note_case_desc_confirm(string response, string desc,
                            class nomic_case the_case) {
   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborting the addition of the note.\n");
      return ;
   }
   if (NOMIC_HANDLER->add_note_to_case(query_council_area(), the_case->id,
                                       this_player()->query_name(), desc)) {
      write("Added the note to the case.\n");
      tell_room(this_object(),
           this_player()->the_short() + " adds a note "
           " to case #" + the_case->id + ".\n", ({ this_player() }) );
   } else {
      write("Unable to add the note to the case for some reason.\n");
   }
}
void close_case_bit(class nomic_case the_case, string type, mixed data) {
   write("Please add in your closing summary.\n");
   this_player()->do_edit("", "close_case_desc", this_object(), 0,
                          ({ the_case, type, data }));
}
int do_close_case(int case_id, string type) {
   class nomic_case the_case;
   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   if (!the_case) {
      add_failed_mess("Cannot find the case.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("You must be a magistrate to close the case.\n");
      return 0;
   }
   if (!query_punishment_type(type)) {
      add_failed_mess("This is not an allowed type for closing the case, "+
                      "it must be one of " +
                      query_multiple_short(query_all_punishment_types()) + ".\n");
      return 0;
   }
   if (member_array(this_player()->query_name(), the_case->people) != -1 ||
       this_player()->query_name() == the_case->opener) {
      add_failed_mess("You cannot close a case involving you or started "
                      "by you.\n");
      return 0;
   }
   if (is_last_appealer(the_case, this_player()->query_name())) {
      add_failed_mess("You cannot close a case you appealed.\n");
      return 0;
   }
   start_punishment(type, the_case, (: close_case_bit :));
   return 1;
}
void close_case_desc(string desc, mixed* extra) {
   class nomic_case the_case;
   string type;
   mixed data;
   if (!desc) {
      write("Aborted.\n");
      return ;
   }
   the_case = extra[0];
   type = extra[1];
   data = extra[2];
   write("Closing the case " +
         query_case_short(the_case) +  " with the type of " +
         query_punishment_short(type, the_case, data) + ".\n");
   write("Are sure you wish you wish to close this case? ");
   input_to("close_case_desc_confirm", 0, the_case, type, data, desc);
}
void close_case_desc_confirm(string response, class nomic_case the_case,
                             string type, mixed* data, string desc) {
   string* people;
   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborting the closing of the note.\n");
      return ;
   }
   if (NOMIC_HANDLER->close_case(query_council_area(), the_case->id,
                                this_player()->query_name(),
                                query_punishment_short(type, the_case, data) +
                                "\n" + desc, ({ type, data }))) {
      complete_punishment(type, the_case, data);
      write("Completed closing the case.\n");
      people = the_case->people + ({ the_case->opener }) +
               NOMIC_HANDLER->query_magistrates(query_council_area());
      if (query_last_appealer(the_case)) {
         people += ({ query_last_appealer(the_case) });
      }
      MAILER->do_mail_message(implode(people, ","),
                              query_council_area() + " magistrates",
                              "Case closed against " +
                              implode(the_case->people, ","),
                              "",
                              "From the desk of " +
                              this_player()->query_cap_name() + ":\n"
                              "The case " +
                              query_case_short(the_case) +
                              "\nhas been closed with a verdict of " +
                              query_punishment_short(type, the_case, data) +
                              "\nWith a reason of:\n" +
                              desc +
                              query_punishment_mail_info(type, the_case, data));
      tell_room(this_object(),
           this_player()->the_short() + " closes the case #" +
           the_case->id + " against " + query_multiple_short(the_case->people) +
           " with a result of " +
           query_punishment_short(type, the_case, data) +
           ".\n", ({ this_player() }) );
   } else {
      write("Unable to complete closing the case.\n");
   }
}
int do_appeal_case(int case_id) {
   class nomic_case the_case;
   the_case = NOMIC_HANDLER->query_recently_closed_case(query_council_area(),
                                                        case_id);
   if (!the_case) {
      add_failed_mess("Cannot find the case.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("You must be a magistrate to appeal the case.\n");
      return 0;
   }
   if (member_array(this_player()->query_name(), the_case->people) != -1 ||
       this_player()->query_name() == the_case->opener) {
      add_failed_mess("You cannot appeal a case involving you or started "
                      "by you.\n");
      return 0;
   }
   if (is_last_closer(the_case, this_player()->query_name())) {
      add_failed_mess("You cannot appeal a case you closed.\n");
      return 0;
   }
   write("What is the detailed reason for appealing this case?\n");
   this_player()->do_edit("", "appeal_case_desc", this_object(), 0, case_id);
   return 1;
}
void appeal_case_desc(string desc, int case_id) {
   class nomic_case the_case;
   if (!desc) {
      write("Aborted.\n");
      return ;
   }
   the_case = NOMIC_HANDLER->query_recently_closed_case(query_council_area(),
                                                        case_id);
   write("Appealing the case " +
         query_case_short(the_case) +  " because:\n" + desc + "\nAre you sure "
         "you wish to do this? ");
   input_to("appeal_case_desc_confirm", 0, case_id, desc);
}
void appeal_case_desc_confirm(string response, int case_id, string desc) {
   class nomic_case the_case;
   string* people;
   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborting the closing of the note.\n");
      return ;
   }
   the_case = NOMIC_HANDLER->query_recently_closed_case(query_council_area(),
                                                        case_id);
   if (NOMIC_HANDLER->appeal_case(query_council_area(), case_id,
                                  this_player()->query_name(),
                                  "\n" + desc)) {
      write("Appealed the case successfully.\n");
      the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
      suspend_punishment(the_case);
      people = the_case->people + ({ the_case->opener });
      MAILER->do_mail_message(implode(people, ","),
                              query_council_area() + " magistrates",
                              "Case appealed",
                              "",
                              "The case " +
                              query_case_short(the_case) +
                              "\nhas been appealed by " +
                              this_player()->query_cap_name() + " because:\n" +
                              desc);
      tell_room(this_object(),
           this_player()->the_short() + " appeals the case #" +
           the_case->id + " against " + query_multiple_short(the_case->people) +
           ".\n", ({ this_player() }) );
   } else {
      write("Error trying to appeal the case!\n");
   }
}
int do_player_status(string person) {
   int* cases;
   class nomic_case the_case;
   int id;
   int found;
   int *open_defendant;
   int *open_opener;
   int *open_appealed;
   int *closed_defendant;
   int *closed_opener;
   int *closed_closed;
   string ret;
   string bing;
   person = lower_case(person);
   cases = NOMIC_HANDLER->query_open_cases(query_council_area());
   if (!sizeof(cases)) {
      add_failed_mess("There are no open cases.\n");
      return 0;
   }
   open_defendant = ({ });
   open_opener = ({ });
   foreach (id in cases) {
      the_case = NOMIC_HANDLER->query_open_case(query_council_area(), id);
      if (member_array(person, the_case->people) != -1) {
         found = 1;
         open_defendant += ({ id + "" });
      }
      if (the_case->opener == person) {
         found = 1;
         open_opener += ({ id + "" });
      }
      bing = query_last_appealer(the_case);
      if (bing == person) {
         found = 1;
         open_appealed += ({ id + "" });
      }
   }
   cases = NOMIC_HANDLER->query_recently_closed_cases(query_council_area());
   closed_defendant = ({ });
   closed_opener = ({ });
   foreach (id in cases) {
      the_case = NOMIC_HANDLER->query_recently_closed_case(query_council_area(), id);
      if (member_array(person, the_case->people) != -1) {
         found = 1;
         closed_defendant += ({ id + " (closed)"  });
      }
      if (the_case->opener == person) {
         found = 1;
         closed_opener += ({ id + " (closed)" });
      }
      bing = query_last_closer(the_case);
      if (bing == person) {
         found = 1;
         closed_closed += ({ id + "" });
      }
   }
   ret = "Status for " + capitalize(person) + ":\n";
   if (sizeof(open_opener) || sizeof(closed_opener)) {
      ret += "Opened the cases      : " +
             query_multiple_short(open_opener + closed_opener) + "\n";
   }
   if (sizeof(open_defendant) || sizeof(closed_defendant)) {
      ret += "Defendant in the cases: " +
             query_multiple_short(open_defendant + closed_defendant) + "\n";
   }
   bing = query_extra_player_status(person);
   if (bing) {
      ret += bing;
   } else if (!found) {
      add_failed_mess("The player " + person + " has no record.\n");
      return 0;
   }
   write("$P$Status$P$" + ret);
   return 1;
}
void init() {
   add_command("list", "", (: do_list_open_cases() :));
   add_command("list", "[case] <number>", (: do_list_case($4[0]) :));
   add_command("list", "closed", (: do_list_closed_cases() :));
   add_command("list", "{punishments|results}", (: do_list_punishments :));
   add_command("list", "{punishment|punishments|results} <string'type'>", (: do_list_punishments_desc($4[1]) :));
   add_command("list", "closed [case] <number>", (: do_list_closed_case($4[0]) :));
   add_command("case", "add person <string'person'> to <number'case id'>",
               (: do_add_person($4[1], $4[0]) :));
   add_command("case", "remove person <string'person'> from <number'case id'>",
               (: do_remove_person($4[1], $4[0]) :));
   add_command("case", "[add] note <number'case id'>", (: do_add_note($4[0]) :));
   add_command("case", "open [with] <string'people'> about <string'short descripion'>",
                       (: do_open_case($4[0], $4[1]) :));
   add_command("case", "close <number'case id'> result <string'result'>",
                       (: do_close_case($4[0], $4[1]) :));
   add_command("case", "appeal <number'case id'>",
                       (: do_appeal_case($4[0]) :));
   add_command("status", "[of] <string'player'>",
                       (: do_player_status($4[0]) :));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/water_inside.c ===
inherit "/std/room/basic_room";
inherit "/std/room/basic/water";
private int _setting_water_light = 0;
void init() {
  water::init();
  basic_room::init();
}
int is_allowed_position(string poss) {
  return water::is_allowed_position(poss);
}
mixed *query_default_position(object ob) {
  return water::query_default_position(ob);
}
int add_exit(string direc, mixed dest, string type) {
  int retval = basic_room::add_exit(direc, dest, type);
  water::add_exit(direc, dest, type);
  return retval;
}
int query_light() {
  update_water_light();
  if (query_surface()) {
    return ::query_light();
  }
  return ::query_light()*query_clarity()/100;
}
int set_water_light(int number) {
  _setting_water_light = 1;
  set_light(number);
  _setting_water_light = 0;
}
int adjust_light(int number) {
  if (!_setting_water_light) {
    set_use_surface_light(0);
  }
  return ::adjust_light(number);
}
mixed query_property(string tag) {
  if ("location" == tag && !query_surface()) {
    return "underwater";
  }
  return ::query_property(tag);
}
int attack_speed() { return 5; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/council_citizenship.c ===
#define EXPRESSION_NO_CLASSES 1
#include <expressions.h>
inherit "/std/basic/expressions";
inherit "/std/room/basic_room";
inherit "/std/room/inherit/council_base";
inherit "/std/room/inherit/honours";
#include <nomic_system.h>
#include <player_handler.h>
#include <mail.h>
#define WEEK (7 * (24 * 60 * 60))
class approval_list {
   string* sponsors;
   mapping against;
   int time_added;
}
class approved_person {
   class approval_list info;
   int time_approved;
   string approver;
   int denied;
}
class blacklist {
   string blacklister;
   string reason;
}
class denied {
   string denier;
   string deny_reason;
   int time_denied;
}
private mapping _waiting_approval;
private mapping _blacklist;
private mapping _denied;
private class parse_node* _expression;
private class parse_node* _sponsor_expression;
private mapping _approved;
private int _last_posted;
private nosave string _save_file;
int variable_age_in_days(object player);
int variable_age_in_hours(object player);
int variable_level(object player);
int variable_denied_in_days(object player);
int function_citizen_of(string area, object player);
int function_magistrate_of(string area, object player);
int do_apply();
int do_sponsor(string person);
int do_approve(string person);
int do_deny(string person, string reason);
int do_list();
int do_add_blacklist(string person, string reason);
int do_remove_blacklist(string person);
int do_list_blacklist(int verbose);
int do_list_expression();
int do_set_expression(string expr, int applicant);
int do_list_denied();
void load_me();
void create() {
   _waiting_approval = ([ ]);
   _blacklist = ([ ]);
   _denied = ([ ]);
   _approved = ([ ]);
   _last_posted = time();
   honours::create();
   expressions::create();
   add_allowed_variable("ageindays", EXPRESSION_TYPE_INTEGER,
                        (: variable_age_in_days :));
   add_allowed_variable("ageinhours", EXPRESSION_TYPE_INTEGER,
                        (: variable_age_in_hours :));
   add_allowed_variable("level", EXPRESSION_TYPE_INTEGER,
                        (: variable_level :));
   add_allowed_variable("timesincedeniedindays", EXPRESSION_TYPE_INTEGER,
                        (: variable_denied_in_days :));
   add_allowed_function("citizenof", EXPRESSION_TYPE_BOOLEAN,
                        ({ EXPRESSION_TYPE_STRING }),
                        (: function_citizen_of :));
   add_allowed_function("magistrateof", EXPRESSION_TYPE_BOOLEAN,
                        ({ EXPRESSION_TYPE_STRING }),
                        (: function_citizen_of :));
   add_help_file("citizenship");
   basic_room::create();
}
void init() {
   add_command("apply", "[for] [citizenship]", (: do_apply() :));
   add_command("sponsor", "<string'person'> for citizenship",
               (: do_sponsor($4[0]) :));
   add_command("deny", "<string'person'> for citizenship because <string'reason'>",
               (: do_deny($4[0], $4[1]) :));
   add_command("list", "", (: do_list() :));
   add_command("expression", "list",
               (: do_list_expression() :));
   if (NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                      this_player()->query_name()) ||
       master()->query_lord(this_player()->query_name())) {
      add_command("blacklist", "add <string'person'> for <string'reason'>",
                  (: do_add_blacklist($4[0], $4[1]) :));
      add_command("blacklist", "remove <string'person'>",
                  (: do_remove_blacklist($4[0]) :));
      add_command("blacklist", "list {verbose|brief}",
                  (: do_list_blacklist($4[0] == "verbose") :));
      add_command("expression", "citizen <string'citizenship'>",
                   (: do_set_expression($4[0], 0) :));
      add_command("expression", "sponsor <string'citizenship'>",
                   (: do_set_expression($4[0], 1) :));
      add_command("list", "denied", (: do_list_denied :));
      add_command("approve", "<string'person'> for citizenship",
                  (: do_approve($4[0]) :));
   }
   honours::init();
}
void set_save_file(string fname) {
   _save_file = fname;
   load_me();
}
string query_save_file() {
   return _save_file;
}
void load_me() {
   if (!_save_file) {
      return ;
   }
   unguarded( (: restore_object(_save_file, 1) :));
   if (!_expression) {
      _expression = parse_boolean_string("ageindays >= 2 and timesincedeniedindays > 14");
   }
   if (!_sponsor_expression) {
      _sponsor_expression = parse_boolean_string("ageindays >= 10");
   }
   if (!_approved) {
      _approved = ([ ]);
   }
   remove_call_out("post_weekly_results");
   call_out("post_weekly_results", _last_posted + WEEK - time());
}
void save_me() {
   if (!_save_file) {
      return ;
   }
   unguarded( (: save_object(_save_file, 1) :));
}
void post_weekly_results() {
   string post;
   string* cit;
   string person;
   string denied;
   cit = sort_array(keys(_approved), 1);
   if (sizeof(cit) > 0) {
      post = "Here are the weekly citizenship application results:\n\n";
      denied = "";
      foreach (person in cit) {
         if (!_approved[person]->denied) {
            if (sizeof(_approved[person]->info->sponsors)) {
               post += "  " + capitalize(person) + " " +
                      ctime(((class approval_list)_approved[person]->info)->time_added)[4..9] +
                      " sponsors " +
                      query_multiple_short(map(_approved[person]->info->sponsors,
                                               (: capitalize($1) :)));
            } else {
               post += "  " + person + " no sponsor";
            }
            post += " approved " +
                    ctime(_approved[person]->time_approved)[4..9] +
                    " by " + capitalize(_approved[person]->approver) + ".\n";
         } else {
            if (sizeof(_approved[person]->info->sponsors)) {
               denied += "  " + capitalize(person) + " " +
                      ctime(((class approval_list)_approved[person]->info)->time_added)[4..9] +
                      " sponsors " +
                      query_multiple_short(map(_approved[person]->info->sponsors,
                                               (: capitalize($1) :)));
            } else {
               denied += "  " + person + " no sponsor";
            }
            denied += " denied " +
                    ctime(_denied[person]->time_denied)[4..9] +
                    " by " + capitalize(_denied[person]->denier) + ".\n";
         }
      }
      if (strlen(denied) > 0) {
         post += "\n\nThese people have been denied citizenship:\n" +
                 denied;
      }
      NOMIC_HANDLER->post_citizen_message(query_council_area(),
                                         "Citizenship results.",
                                         post);
      _approved = ([ ]);
      save_me();
   }
   _last_posted = time();
   remove_call_out("post_weekly_results");
   call_out("post_weekly_results", _last_posted + WEEK - time());
}
int do_apply() {
   class approval_list womble;
   string str;
   if (NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                           this_player()->query_name())) {
      add_failed_mess("You are already a citizen.\n");
      return 0;
   }
   if (_blacklist[this_player()->query_name()]) {
      add_failed_mess("You are not allowed to become a citizen here.\n");
      return 0;
   }
   if (_waiting_approval[this_player()->query_name()]) {
      add_failed_mess("You are already asking for approval.\n");
      return 0;
   }
   if (!evaluate_expression(_expression, this_player())->value) {
      str = query_expression_string(_expression, 0);
      add_failed_mess("You do not meet the requirements to be a citizen, the "
                      "requirements currently are:\n" + str + "\n");
      return 0;
   }
   if (this_player()->query_creator()) {
      add_failed_mess("Creators cannot be citizens.\n");
      return 0;
   }
   if (NOMIC_HANDLER->is_grace_phase(query_council_area())) {
      str = NOMIC_HANDLER->query_citizen(this_player()->query_name());
      if (str) {
         add_failed_mess("You are already a citizen of " + str +
                         " and cannot join here.\n");
         return 0;
      }
      NOMIC_HANDLER->add_citizen(query_council_area(), this_player()->query_name());
      add_succeeded_mess("$N become$s a citizen of " + query_council_area() +
                          ".\n");
      return 1;
   }
   womble = new(class approval_list);
   womble->sponsors = ({ });
   womble->against = ([ ]);
   womble->time_added = time();
   _waiting_approval[this_player()->query_name()] = womble;
   save_me();
   send_council_inform(1,
              this_player()->query_cap_name() + " applied for citizenship in " +
              query_council_area());
   add_succeeded_mess(({ "You apply for citizenship.\n",
                         "$N applies for citizenship.\n" }));
   return 1;
}
int do_sponsor(string person) {
   string str;
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("Sorry, " + person + " is not a player.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                           this_player()->query_name())) {
      add_failed_mess("Only citizens can sponsor someone.\n");
      return 0;
   }
   if (_blacklist[this_player()->query_name()]) {
      add_failed_mess("You are not allowed to sponsor citizens.\n");
      return 0;
   }
   if (!_waiting_approval[person]) {
      add_failed_mess("I am sorry, " + person + " is not currently "
                      "awaiting citizenship.\n");
      return 0;
   }
   if (!evaluate_expression(_sponsor_expression, this_player())->value) {
      str = query_expression_string(_sponsor_expression, 0);
      add_failed_mess("You do not meet the requirements to sponsor citizen, the "
                      "requirements currently are:\n" + str + "\n");
      return 0;
   }
   if (member_array(this_player()->query_name(),
                    _waiting_approval[person]->sponsors) != -1) {
      add_failed_mess("You are already sponsoring " + person + ".\n");
      return 0;
   }
   if (_waiting_approval[person]->against[this_player()->query_name()]) {
      add_failed_mess("You have already put in a reason for deny "
                      "citizenship to " + person + ".\n");
      return 0;
   }
   _waiting_approval[person]->sponsors += ({ this_player()->query_name() });
   save_me();
   add_succeeded_mess("$N $V someone for citizenship.\n");
   return 1;
}
int do_approve(string person) {
   person = lower_case( person );
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("Sorry, " + person + " is not a player.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                           this_player()->query_name())) {
      add_failed_mess("Only citizens can sponsor someone.\n");
      return 0;
   }
   if (!_waiting_approval[person]) {
      add_failed_mess("I am sorry, " + person + " is not currently "
                      "awaiting citizenship.\n");
      return 0;
   }
   if (NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                       this_player()->query_name())) {
      NOMIC_HANDLER->add_citizen(query_council_area(), person);
      _approved[person] = new(class approved_person);
      _approved[person]->info = _waiting_approval[person];
      _approved[person]->time_approved = time();
      _approved[person]->approver = this_player()->query_name();
      map_delete(_waiting_approval, person);
      save_me();
      send_council_inform(1, person + " granted citizenship by " +
              this_player()->query_cap_name() + " in " +
              query_council_area());
      add_succeeded_mess("$N add$s " + person + " as a citizen.\n");
      if (find_player(person)) {
         tell_object(find_player(person), "%^RED%^You have been granted "
                     "citizenship of " + query_council_area() +
                     "%^RESET%^.\n");
      } else {
         AUTO_MAILER->auto_mail(person, "Council of " + query_council_area(),
                                "Citizenship of " + query_council_area(),
                                "",
                                "Morning,\n\nYou have been granted "
                                "citizenship in " + query_council_area() +
                                ".\n\n"
                                "Good luck!\nCouncil Administrator.\n");
      }
      return 1;
   }
   add_failed_mess("You are not a magistrate of " + query_council_area() +
                   ".\n");
   return 0;
}
int do_deny(string person, string reason) {
   class denied fluff;
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("Sorry, " + person + " is not a player.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                           this_player()->query_name())) {
      add_failed_mess("Only citizens can deny someone.\n");
      return 0;
   }
   if (!_waiting_approval[person]) {
      add_failed_mess("I am sorry, " + person + " is not currently "
                      "awaiting citizenship.\n");
      return 0;
   }
   if (NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                       this_player()->query_name())) {
      map_delete(_waiting_approval, person);
      fluff = new(class denied);
      fluff->deny_reason = reason;
      fluff->denier = this_player()->query_name();
      fluff->time_denied = time();
      _denied[person] = fluff;
      save_me();
      if (find_player(person)) {
         tell_object(find_player(person), "%^RED%^You have been denied "
                     "citizenship of " + query_council_area() +
                     "%^RESET%^.\n");
      } else {
         AUTO_MAILER->auto_mail(person, "Council of " + query_council_area(),
                                "Citizenship of " + query_council_area(),
                                "",
                                "Morning,\n\nYou have been denied as a "
                                "citizen of " + query_council_area() + ".\n\n"
                                "Bad luck!\nCouncil Administrator.\n");
      }
      add_succeeded_mess(({ "$N deny " + person + " as a citizen.\n",
                            "$N denies " + person + " as a citizen.\n"
                             }) );
      return 1;
   }
   if (member_array(this_player()->query_name(),
                    _waiting_approval[person]->sponsors) != -1) {
      add_failed_mess("You are already sponsoring " + person + ".\n");
      return 0;
   }
   if (_waiting_approval[person]->against[this_player()->query_name()]) {
      add_failed_mess("You have already put in a reason for deny "
                      "citizenship to " + person + ".\n");
      return 0;
   }
   _waiting_approval[person]->against[this_player()->query_name()] = reason;
   save_me();
   add_succeeded_mess("$N $V someone for citizenship.\n");
   return 1;
}
int do_list() {
   string ret;
   string ret_tmp;
   string ret_no_sponsor;
   int magistrate;
   string* people;
   string person;
   string denier;
   string reason;
   int index;
   int last;
   int no_sponsor;
   if (!sizeof(_waiting_approval)) {
      add_failed_mess("No one is waiting for citizenship approval.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                           this_player()->query_name())) {
      add_failed_mess("Only citizens can see who is applying for "
                      "citizenship.\n");
      return 0;
   }
   magistrate = NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                                this_player()->query_name());
   people = keys(_waiting_approval);
   people = sort_array(people, (: ((class approval_list)_waiting_approval[$1])->time_added -
                                  ((class approval_list)_waiting_approval[$2])->time_added :));
   ret = "";
   ret_no_sponsor = "";
   foreach (person in people) {
      if (!PLAYER_HANDLER->test_user(person)) {
         map_delete(_waiting_approval, person);
         continue;
      }
      if (sizeof(_waiting_approval[person]->sponsors)) {
         ret += "$I$6=   " +
                ctime(((class approval_list)_waiting_approval[person])->time_added)[4..9] + ": " +
                capitalize(person) + " sponsored by " +
                query_multiple_short(map(_waiting_approval[person]->sponsors,
                                         (: capitalize($1) :)));
         no_sponsor = 0;
      } else {
         ret_no_sponsor += "$I$6=   " +
                ctime(((class approval_list)_waiting_approval[person])->time_added)[4..9] + ": " +
                capitalize(person) + " not sponsored by anyone";
         no_sponsor = 1;
      }
      ret_tmp = "";
      if (sizeof(_waiting_approval[person]->against)) {
         if (magistrate) {
             ret_tmp += ";\n";
             index = 1;
             last = sizeof(_waiting_approval[person]->against);
             foreach (denier, reason in _waiting_approval[person]->against) {
                ret_tmp += "- " + denier + " denied '" + reason + "'";
                if( index == last ) {
                   ret_tmp += "\n";
                } else {
                   ret_tmp += ",\n";
                   index++;
                }
             }
         } else {
             ret_tmp += " denied by " +
                    query_num(sizeof(_waiting_approval[person]->against)) +
                    ".\n";
         }
      } else {
         ret_tmp += ".\n";
      }
      if (no_sponsor) {
         ret_no_sponsor += ret_tmp;
      } else {
         ret += ret_tmp;
      }
   }
   if (ret != "") {
      ret = "$I$0=Waiting for approval:\n" + ret;
   }
   if (ret_no_sponsor != "") {
      ret = "$I$0=Waiting for sponsorship:\n" + ret_no_sponsor + "\n" + ret;
   }
   this_player()->more_string(ret, "citizenship");
   return 1;
}
int do_list_denied() {
   string* people;
   string person;
   string ret;
   if (!sizeof(_denied)) {
      add_failed_mess("No one has been denied yet.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                           this_player()->query_name())) {
      add_failed_mess("Only magistrates can see the denied list.\n");
      return 0;
   }
   people = keys(_denied);
   people = sort_array(people, 1);
   ret = "";
   foreach (person in people) {
      ret += "$I$5=" + person + " at " + ctime(_denied[person]->time_denied) +
             " by " + _denied[person]->denier +
             " for " + _denied[person]->deny_reason + ".\n";
   }
   this_player()->more_string(ret, "denied");
   return 1;
}
int do_list_expression() {
   string str;
   str = query_expression_string(_expression, 0);
   write("The expression to check to make sure someone is allowed to "
         "apply for citizenship is:\n" + str + "\n");
   str = query_expression_string(_sponsor_expression, 0);
   write("The expression to check to make sure someone is allowed to "
         "sponsor an application for citizenship is:\n" + str + "\n");
   return 1;
}
int do_set_expression(string expression, int sponsor_expr) {
   class parse_node* expr;
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("Only magistrates can set an expression string.\n");
      return 0;
   }
   expr = parse_boolean_string(expression);
   if (!sizeof(expr)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   }
   if (!sponsor_expr) {
      _expression = expr;
   } else {
      _sponsor_expression = expr;
   }
   save_me();
   add_succeeded_mess("$N set$s the citizenship requirements.\n");
   return 1;
}
int do_add_blacklist(string person, string reason) {
   class blacklist bing;
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("Only magistrates can manipulate the blacklist.\n");
      return 0;
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("You cannot blacklist someone that does not exist.\n");
      return 0;
   }
   bing = new(class blacklist);
   bing->blacklister = this_player()->query_name();
   bing->reason = reason;
   _blacklist[person] = bing;
   save_me();
   add_succeeded_mess("$N add$s someone to the blacklist.\n");
   return 1;
}
int do_remove_blacklist(string person) {
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("Only magistrates can manipulate the blacklist.\n");
      return 0;
   }
   if (!_blacklist[person]) {
      add_failed_mess("You cannot remove someone from a blacklist that is not "
                      "black listed already!\n");
      return 0;
   }
   map_delete(_blacklist, person);
   save_me();
   add_succeeded_mess("$N remove$s someone from the blacklist.\n");
   return 1;
}
int do_list_blacklist(int verbose) {
   string ret;
   string* people;
   string person;
   people = keys(_blacklist);
   people = sort_array(people, 1);
   if (!sizeof(people)) {
      add_failed_mess("There is no one in the blacklist currently.\n");
      return 0;
   }
   ret = "";
   if (!verbose) {
      ret += "$I$5=Blacklist is: " + query_multiple_short(people);
   } else {
      ret += "Blacklist:\n";
      foreach (person in people) {
         ret += "$I$5=" + person + " by " + _blacklist[person]->blacklister +
                " for " + _blacklist[person]->reason + ".\n";
      }
   }
   this_player()->more_string(ret, "blacklist");
   return 1;
}
int variable_age_in_days(object player) {
   int bing;
   bing = -player->query_time_on();
   return bing / (60 * 60 * 24);
}
int variable_age_in_hours(object player) {
   int bing;
   bing = -player->query_time_on();
   return bing / (60 * 60);
}
int variable_level(object player) {
   return player->query_level();
}
int variable_denied_in_days(object player) {
   if (_denied[player->query_name()]) {
      return (time() - _denied[player->query_name()]->time_denied) / (60 * 60 * 24);
   }
   return 10000;
}
int function_citizen_of(string area, object player) {
   return NOMIC_HANDLER->is_citizen_of(area, player->query_name());
}
int function_magistrate_of(string area, object player) {
   return NOMIC_HANDLER->is_magistrate_of(area, player->query_name());
}
int is_allowed_to_change(string person) {
   return NOMIC_HANDLER->is_magistrate_of(query_council_area(), person);
}
void inform_of_honour_change(string type, string person,
                             string reason, string changed_by) {
   string subject;
   string mess;
   if (type == "add") {
      subject = PLAYER_HANDLER->query_cap_name(person) +
                " added to the honour roll.";
      mess = PLAYER_HANDLER->query_cap_name(person) + " is added to the "
             "honour roll for this council.\n\nThis means they gain the "
             "honour of using the title(s) " +
             query_multiple_short(map(query_controlled_titles(),
                                      (: capitalize :))) +  ".\n\n" +
             "They were added by " +
             PLAYER_HANDLER->query_cap_name(changed_by) +
             " for:\n" + reason + "\n";
   } else {
      subject = PLAYER_HANDLER->query_cap_name(person) +
                " removed from the honour roll.";
      mess = PLAYER_HANDLER->query_cap_name(person) + " is removed from the "
             "honour roll for this council.\n\nThis means they lose the "
             "privilege of using the title " +
             query_multiple_short(map(query_controlled_titles(),
                                      (: capitalize :))) +  ".\n\n" +
             "They were removed by " +
             PLAYER_HANDLER->query_cap_name(changed_by) +
             " for:\n" + reason + "\n";
   }
   NOMIC_HANDLER->post_citizen_message(query_council_area(),
                                       subject,
                                       mess);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/bath_house_inside.c ===
inherit "/std/room/basic_room";
inherit "/std/room/inherit/bath_house";
void create() {
    basic_room::create();
    bath_house::create();
}
void init() {
    basic_room::init();
    bath_house::init();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/parcel_inherit.c ===
#include <money.h>
#include <mail.h>
#include <player_handler.h>
#include <player.h>
inherit "/std/room/basic_room";
string loc;
string where;
object shelf;
int cost;
varargs int do_deposit( object *obs, string name, int show_sender );
int do_collect();
void make_shelf( string short, string long ) {
  shelf = clone_object( "/std/surface" );
  shelf->set_name( short );
  shelf->set_long( long );
  shelf->set_max_weight( 10000 );
  shelf->move( this_object() );
  shelf->add_property( "there", "fixed to one wall" );
  shelf->reset_get();
}
void set_location( string _loc ) { loc = _loc; }
void set_cost( int _cost ) { cost = _cost; }
void set_currency( string temp ) { where = temp; }
string query_location() { return loc; }
int query_cost() { return cost; }
string query_currency() { return where; }
void init() {
    ::init();
  this_player()->add_command( "deposit", this_object(),
                  "<indirect:object> for <string>",
                  (: do_deposit( $1, $4[1] ) :) );
  this_player()->add_command( "collect", this_object(), "",
                  (: do_collect() :) );
}
int deposit_parcel( object *obs, string name, int show_sender ) {
  if ( obs == 0 || name == 0 ) {
    return 0;
  }
  if ( !PLAYER_HANDLER->test_user( name ) )  {
    return -2;
  }
  if ( !sizeof( obs ) ) {
    return 0;
  }
  if ( PLAYER_MULTIPLAYER_HANDLER->member_denied_parcel( this_player()->query_name() ) ) {
    return -4;
  }
  if ( PLAYER_MULTIPLAYER_HANDLER->member_denied_parcel( lower_case(name) ) ) {
    return -5;
  }
  MAIL_PARCEL_HANDLER->deposit( name, this_player()->query_name(),
                   loc, obs );
  AUTO_MAILER->auto_mail( name, "the parcel clerk",
       "Parcel Deposit Notification", "",
       "Please come to the " + loc + " Post Office parcel counter to\n"
       "collect " + ( sizeof( obs ) == 1 ? "a parcel which has" :
       query_num( sizeof( obs ) ) +" parcels which have" ) +
       " been deposited for you" +
       ( show_sender ? " by " + this_player()->query_short() : "" ) + ".\n\n"
       "Due to limited space in our warehouse you have two weeks to collect\n"
       "your parcels, if you do not collect them within this time they will\n"
       "will be destroyed.\n\n   The parcel clerk, " +
       loc + " Post Office.", 0, 0 );
  return 1;
}
varargs int do_deposit( object *obs, string name, int show_sender ) {
  int ret;
  int total_cost;
  object* total_obs;
  object ob;
  total_obs = obs;
  foreach (ob in obs) {
     total_obs += deep_inventory(ob);
  }
  if (sizeof(total_obs) > 20) {
     add_failed_mess("You are depositing too many items.  The maximum is "
                     "20.\n");
     return -6;
  }
  total_cost = cost * sizeof(total_obs);
  if ( this_player()->query_value_in( where ) < total_cost )  {
    add_failed_mess("You do not have enough money to deposit these "
                    "items, you need " +
                    MONEY_HAND->money_value_string(total_cost,
                            query_property("place")) + ".\n");
    return -1;
  }
  if ( lower_case(name) == this_player()->query_name() ) {
    add_failed_mess("You cannot deposit things for yourself!\n");
    return -3;
  }
  ret = deposit_parcel(obs, name, show_sender);
  switch (ret) {
  case 0 :
  case -1 :
  case -2 :
     return ret;
  case -3 :
    add_failed_mess("You cannot deposit things for yourself!\n");
    return -3;
  case -4 :
    add_failed_mess("You are not allowed to deposit parcels.\n");
    return -4;
  case -5 :
    add_failed_mess(upper_case(name)+" is not allowed to recieve parcels.\n");
    return -5;
  case 1 :
     this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
                                total_cost, where ), where );
     return 1;
  }
  return ret;
}
int do_collect() {
  string this_player_name;
  this_player_name = lower_case(this_player()->query_name());
  if( PLAYER_MULTIPLAYER_HANDLER->member_denied_parcel(this_player_name) ) {
    add_failed_mess("You are not allowed to collect things.\n");
    return 0;
  }
  if ( !MAIL_PARCEL_HANDLER->collect( this_player()->query_name(), loc,
                        (shelf) ? shelf : this_object(), 0 ) ) {
    return 0;
  }
  return 1;
}
void set_shelf( object ob ) {
    shelf = ob;
}
object query_shelf() {
    return shelf;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/player_housing.c ===
#include <dirs.h>
#include <housing.h>
#include <login_handler.h>
#include <player_handler.h>
inherit "/std/room/basic_room";
inherit "/std/room/inherit/player_housing";
void create() {
  add_help_file("player_housing");
  do_setup++;
  basic_room::create();
  player_housing::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  seteuid("Room");
  add_property("no burial", 1);
  add_property("no teleport", 1);
}
string query_long() {
  return player_housing::query_long();
}
int add_exit(string direc, mixed dest, string type) {
  int tmp;
  tmp = ::add_exit(direc, dest, type);
  setup_exit(direc, 1);
  return tmp;
}
string query_address() {
   return HOUSING->query_address(file_name(this_object()));
}
string process_non_living(object *int_non_livings, int start) {
  object *not_positioned;
  not_positioned = player_housing::my_process_non_living(int_non_livings);
  return ::process_non_living(not_positioned, start);
}
void init() {
  player_housing::init();
  basic_room::init();
}
void event_exit(object ob, string message, object to) {
  player_housing::event_exit(ob, message, to);
}
int query_keep_room_loaded() {
  player_housing::query_keep_room_loaded();
}
void dest_me() {
  player_housing::dest_me();
  basic_room::dest_me();
}
int test_remove(object thing, int flag, mixed dest) {
  object thief;
  mixed *stuff;
  if(!basic_room::test_remove(thing, flag, dest))
    return 0;
  thief = this_player();
  if(!thief)
    return player_housing::test_remove(thing, flag, dest);
  if(thief->query_caster())
    thief = find_player(thief->query_caster());
  else if(thief->query_owner())
    thief = thief->query_owner();
  stuff = thing->query_property("dropped");
  if(thief &&
     test_save(thing) && PLAYER_HANDLER->test_user(query_owner()) &&
     !this_object()->test_occupier(thief->query_name()) &&
     (!stuff || stuff[0] != thief->query_name())) {
    log_file("HOUSING_THEFT", "%s: %s stole %s from %s in %s\n",
             ctime( time() )[4..18], (string)thief->query_short(),
             thing->query_short(),
             (string)query_owner(), file_name());
    event(this_object(), "theft", thief, this_object(), ({ thing }));
  }
  return player_housing::test_remove(thing, flag, dest);
}
int test_add( object ob, int flag) {
  int retval;
  retval = basic_room::test_add(ob, flag);
  if(retval)
    retval = player_housing::test_add(ob, flag);
  return retval;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/room_save.c ===
#include <move_failures.h>
#include <player.h>
inherit "/std/room/basic_room";
inherit "/std/room/inherit/room_save";
inherit "/std/basic/auto_load";
void create() {
   do_setup++;
   basic_room::create();
   room_save::create();
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
     this_object()->reset();
   }
}
int test_remove(object thing, int flag, mixed dest) {
  int result;
  result = basic_room::test_remove(thing, flag, dest);
  if(result) {
    room_save::test_remove(thing, flag, dest);
  }
  return result;
}
int test_add( object ob, int flag) {
  room_save::test_add(ob, flag);
  return basic_room::test_add(ob, flag);
}
#ifdef DONT_USE
void dest_me() {
  room_save::dest_me();
  basic_room::dest_me();
}
#endif
