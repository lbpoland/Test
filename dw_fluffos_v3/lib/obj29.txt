
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/fountain.c ===
#include <volumes.h>
#define FOUNTAIN_SIZE 150000
#define DEFAULT_CYCLE_TIME 60 * ( 2 + random( 2 ) )
inherit "/obj/vessel";
string _liquid_path;
int _liquid_volume;
int _time;
void setup() {
  set_name( "fountain" );
  set_short( "fountain" );
  set_long( "This is a fountain.\n" );
  set_max_volume( FOUNTAIN_SIZE );
  set_weight( 100000 );
  set_stuck( 1 );
}
varargs void initialise( string path, int amount, int time) {
  if ( !stringp( path ) )
    error( "Path not set in initialise.\n" );
  if ( !intp( amount ) )
    amount = VOLUME_LITRE;
  if ( !time )
    time = DEFAULT_CYCLE_TIME;
  _liquid_path = path;
  _liquid_volume = amount;
  _time = time;
  call_out( "make_water", 5 );
  return;
}
varargs void reinitialise( string path, int amount, int time) {
  if ( !stringp( path ) )
    error( "Path not set in initialise.\n" );
  if ( !intp( amount ) )
    amount = VOLUME_LITRE;
  if ( !time )
    time = DEFAULT_CYCLE_TIME;
  _liquid_path = path;
  _liquid_volume = amount;
  _time = time;
  return;
}
void make_water() {
object water;
  if ( !( query_max_volume() - query_volume() ) ) {
    tell_room( environment(), sprintf( "Some of the %s in %s sloshes over the sides.\n",
      query_multiple_short( all_inventory() ), this_object()->the_short() ) );
    remove_volume( -VOLUME_QUART * random( 4 ) * 2 );
  }
  water = clone_object( _liquid_path );
  water->set_amount( _liquid_volume );
  call_out( (: $(water)->move( this_object() ) :), 1 );
  switch( water->query_amount() ) {
	case 0 .. VOLUME_SHOT:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
  	  water->a_short(), ({ "trickles", "seeps", "dribbles" })[random(3)],
	  this_object()->the_short() ) );
      break;
    case VOLUME_SHOT + 1 .. VOLUME_PINT:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
		water->a_short(),  ({ "flows", "splashes", "pours" })[random(3)],
		this_object()->the_short() ) );
      break;
    case VOLUME_PINT + 1 .. VOLUME_LITRE:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
		water->a_short(), ({ "streams", "cascades", "sloshes" })[random(3)],
		this_object()->the_short() ) );
      break;
    case VOLUME_LITRE + 1 .. VOLUME_QUART:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
	    water->a_short(), ({ "gushes", "courses", "swirls" })[random(3)],
        this_object()->the_short() ) );
      break;
    default:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
        water->a_short(), ({ "floods", "surges", "washes" })[random(3)],
  	    this_object()->the_short() ) );
      break;
  }
  call_out( "make_water", _time );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/shell.c ===
#include "potion_attrs.h"
#include "library.h"
inherit "/std/object";
#define MY_ROOM "/d/sur/Sto_Plains/n_caravan/picnic_area"
object *demons, cauldron, coin;
void setup() {
  set_weight(10);
  set_value(5);
  set_name("shell");
  add_adjective("sea");
  add_alias("seashell");
  set_short("sea shell");
  set_long("A large conch shell.  It looks like it has been hollowed "+
           "out so that it can be played.  Perhaps if you blew into "+
           "it it might work.\n");
}
void init() {
  this_player()->add_command("blow", this_object());
}
int finish_quest();
int do_blow(object *indir, string s1, string s2, string prep) {
  if (sizeof(indir)) {
    write("Blow "+short(0)+" "+prep+" "+indir->short(0)+"????\n");
    return 0;
  }
  if (file_name(environment(this_player())) == MY_ROOM)
    return finish_quest();
  add_succeeded_mess("$N $V $D and make$s a horrible noise.\n");
  return 1;
}
int finish_quest() {
  object *obs, *obs2, *obs3, ob, fish, frisbee, ladle;
  mixed *attrs;
  string failure;
  int i, j;
  write("The "+short(0)+" blows amazing loudly.\n");
  say(this_player()->one_short()+" blows the "+short(0)+
      " amazingly loudly.\n");
  if (demons) {
    write("Demons glare at you.\n");
    say("Demons glare at "+this_player()->one_short()+".\n");
    return 1;
  }
  obs = all_inventory(environment(this_player()));
  obs3 = obs;
  obs = map_array(obs, "bingle_bit", this_object());
  if ((i=member_array("ladle", obs)) == -1) {
    failure = "no ladle";
  } else {
    ladle = obs3[i];
  }
  if ((i=member_array("frisbee", obs)) == -1) {
    failure = "no frisbee";
  } else {
    frisbee = obs3[i];
  }
  if ((i=member_array("cauldron", obs)) == -1) {
    failure = "no caldron";
  } else {
    cauldron = obs3[i];
      obs2 = match_objects_for_existence("cauldrons", environment(this_player()));
    for (i=0;i<sizeof(obs2);i++) {
      if ((int)obs2[i]->query_volume() < 100 ||
          (int)obs2[i]->query_volume() < (int)obs2[i]->query_max_volume() / 2) continue;
      attrs = (mixed *)obs2[i]->query_misc_attrs();
      if (pointerp(attrs)) attrs = attrs[POTION_NAMES];
      if (pointerp(attrs) && sizeof(attrs) && attrs[0][0] == "yucky ankh water") {
        j++;
      }
    }
    if (!j) {
      failure = "no cauldron full of anhk river water";
    }
  }
  if ((i = member_array("coin", obs)) == -1) {
    failure = "no coin";
  } else {
    coin = obs3[i];
  }
  if ((i=member_array("fish", obs)) == -1) {
    failure = "no fish";
  } else {
    fish = obs3[i];
  }
      obs2 = match_objects_for_existence("toadstools", environment(this_player()));
  obs2 = filter_array(obs2, "bongle_array", this_object());
  if (sizeof(obs2) < 4) {
    failure = "not enough toadstools to sit on";
  }
  if (failure) {
    write("A bunch of hungry looking demons show up.\n");
    write("They look around the clearing.\n");
    write("Mutter to themselves about there being "+failure+".\n");
    write("Demon glares at you.\n");
    say("A bunch of hungry looking demons show up.\n");
    say("They look around the clearing.\n");
    say("Mutter to themselves about there being "+failure+".\n");
    say("Demon glares at "+this_player()->one_short()+".\n");
    return 1;
  }
  demons = allocate(4);
  for (i=0;i<sizeof(demons);i++) {
    demons[i] = clone_object("/std/container");
    demons[i]->set_name("demon");
    demons[i]->reset_get();
    demons[i]->set_long("A small demon with a manic look in his eyes "+
                        "cooking soup.\n");
    demons[i]->move(environment(this_player()));
    obs2[i]->move(demons[i]);
  }
  coin->reset_get();
  cauldron->reset_get();
  fish->dest_me();
  ladle->move(demons[2]);
  frisbee->move(demons[1]);
  say("The demons grab the fish and stick it into the cauldron.  "+
        "They then put the frisbee on the top of the cauldron as a "+
        "lid.  One of the demons grabs the ladle and stirs the "+
        "mixture around a bit whilst the other demons blow on "+
        "cauldron to heat it up.\n");
  call_out("do_finish_it", 10);
  write("The demons grab the fish and stick it into the cauldron.  "+
        "They then put the frisbee on the top of the cauldron as a "+
        "lid.  One of the demons grabs the ladle and stirs the "+
        "mixture around a bit whilst the other demons blow on "+
        "cauldron to heat it up.\n");
  return 1;
}
void do_finish_it() {
  object *obs;
  int i, j;
  say("The soup is obviously hot now, and all the demons sit down "+
        "on their toadstools to enjoy the meal.  After finishing the "+
        "meal, they smile happily.  You hear one of the say on the "+
        "way out, \"Great way to get a meal, it works every time\".\n"+
       "The demons leave taking the table, cauldron and ladle with them.\n");
  write("The soup is obviously hot now, and all the demons sit down "+
        "on their toadstools to enjoy the meal.  After finishing the "+
        "meal, they smile happily and leave.  You hear one of the "+
        "demons say on the "+
        "way out, \"Great way to get a meal, it works every time\".\n"+
       "The demons leave taking the table, cauldron and ladle with them.\n");
  cauldron->dest_me();
  coin->dest_me();
  obs = all_inventory(environment(demons[0]));
  for (i=0;i<sizeof(obs);i++)
    if (interactive(obs[i])) {
      if (!LIBRARY->set_quest(obs[i]->query_name(), "feeding frenzy"))
        continue;
      obs[i]->adjust_xp(5000);
    }
  for (i=0;i<sizeof(demons);i++) {
    obs = all_inventory(demons[i]);
    for (j=0;j<sizeof(obs);j++)
      obs[j]->dest_me();
    demons[i]->dest_me();
  }
  demons = 0;
}
mixed bingle_bit(object ob) {
  return (mixed)ob->query_property("feeding_frenzy");
}
int bongle_array(object ob) {
  return (int)ob->query_property("feeding_frenzy") != 0;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/suggestion_box.c ===
inherit "/std/object";
int do_fill();
string _savedir, _savefile;
void setup() {
  set_short( "suggestion box" );
  set_long( "This is a suggestion box.  It is sitting on a pole which puts"
	    " the box at a convienient height for writing.  It has a pile "
	    "of small papers on it on which you can write suggestions.  "
	    "There is a slot in the top for stuffing the suggestion in "
	    "when you're done.\n" );
  set_name( "box" );
  set_main_plural( "boxes" );
  set_read_mess( "\nPlease fill in a suggestion form", "common" );
  add_property( "there", "sitting in the middle of the floor" );
  set_weight( 1000 );
  reset_get();
}
void init() {
  add_command( "fill", "in a suggestion form", (: do_fill() :) );
}
void set_save_file ( string file ) {
  _savefile = file;
  return;
}
void set_save_dir ( string dir ) {
  _savedir = dir;
  return;
}
string query_save_file () {
  return _savefile;
}
string query_save_dir () {
  return _savedir;
}
int do_fill() {
  tell_object( this_player(), "Please fill in your suggestion below.\n" );
  this_player()->do_edit( 0, "end_suggestion", this_object() );
  add_succeeded_mess( ({"", "$N fill$s in a suggestion form and stuff$s "
			  "it in the box.\n" }) );
  return 1;
}
void end_suggestion( string text ) {
  string player, file;
  if( _savefile ) {
    file = _savefile;
  } else if( _savedir ) {
    player = previous_object()->query_name();
    file = sprintf( query_save_dir() + "/%s-%d.txt", player, time() );
  }
  debug_printf( "File: %s", file );
  if( !(unguarded( (: write_file, file, text :) ) ) ) {
    tell_object( previous_object(), "Sorry, your suggestion was not recorded."
		 "  Please use the 'bug object' command to bug report the "
		 "suggestion box.\n" );
    return;
  }
  tell_object( previous_object(), "You fill in a suggestion form and stuff "
	       "it in the box.\n" );
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/board_rab.c ===
#include <mail.h>
#include <board.h>
inherit "/obj/misc/board";
int do_transfer(int num, string str);
int do_store(int num, string str);
int do_storeall(string str);
int do_minimum(int num);
int do_maximum(int num);
int do_timeout(int num);
int do_add(string str);
int do_remove(string str);
int do_board(string str);
int do_archive(string str);
int do_killfile(string str);
int do_unkillfile(string str);
void setup() {
  ::setup();
  add_alias("board master");
  action_pri = 3;
  reset_drop();
  set_get();
}
string long(string str, int dark) {
  int i, irp;
  mixed *stuff;
  string ret;
  mapping news_rc;
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  ret = "A bulletin board ("+board_name+").\n";
  irp = (int)BOARD_HAND->query_minimum(board_name);
  if (irp)
    ret += "Minimum number of messages left by automagic deletion is "+ irp +
           ".\n";
  irp = (int)BOARD_HAND->query_maximum(board_name);
  if (irp)
    ret += "Maximum number of messages on this board is "+irp+".\n";
  irp = (int)BOARD_HAND->query_timeout(board_name);
  if (irp)
    ret += "Messages will automagically time out in "+ irp +" days.\n";
  irp = (int)BOARD_HAND->query_archive(board_name);
  if (irp)
    ret += "Deleted messages are archived in "+irp+".\n";
  ret += sprintf("%#-*s\n\n", this_player()->query_cols(),
                            "read <note number>\npost <subject>\n"+
                            "boards\n"+
                            "store <note number> <file>\n"+
          "storeall <file> (optional)\n"+
          "eat <note number>\n"+
                            "reply <note number>\nfollowup <note number>\n"+
                            "summary [all]\nnext\nprev\nnew\n"+
                            "board <board name>\n"+
                            "timeout <time>\nminimum <num>\nmaximum <num>\n"+
                            "archive <name|none>\n"+
                            "security\nsadd <name>\nsremove <name>\n"+
                            "killfile <board name>\nunkillfile <board name>\nlistkillfile\ntransfer <note> <board>");
  if (!sizeof(stuff))
    return ret+"The board is completely empty.\n";
  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  if (!news_rc)
    news_rc = ([ ]);
  for (i=0;i<sizeof(stuff);i++)
    if (news_rc[board_name] < stuff[i][B_TIME])
      ret += sprintf("N %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
             stuff[i][B_SUBJECT]+" ("+
             stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
    else
      ret += sprintf("  %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
             stuff[i][B_SUBJECT]+" ("+
             stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
  return ret;
}
void init() {
   if (environment() == this_player() &&
       this_player()->query_creator()) {
      add_commands();
      add_command("store", "<number> <word>", (: do_store($4[0], $4[1]) :));
      add_command("storeall", "<word>", (: do_storeall($4[0]) :));
      add_command("next", "");
      add_command("prev", "");
      add_command("new", "");
      add_command("board", "<string>", (: do_board($4[0]) :));
      add_command("boards", "");
      add_command("killfile", "<string>", (: do_killfile($4[0]) :));
      add_command("unkillfile", "<string>",(: do_unkillfile($4[0]) :));
      add_command("listkillfile", "");
      add_command("security", "");
      add_command("sadd", "<word>", (: do_add($4[0]) :));
      add_command("sremove", "<word>", (: do_remove($4[0]) :));
      add_command("timeout", "<number>", (: do_timeout($4[0]) :));
      add_command("minimum", "<number>", (: do_minimum($4[0]) :));
      add_command("maximum", "<number>", (: do_maximum($4[0]) :));
      add_command("archive", "<word>", (: do_archive($4[0]) :));
      add_command("summary", "");
      add_command("skip", "");
      add_command("arts", "");
      add_command("transfer", "<number> <string>",
                     (: do_transfer($4[0], $4[1]) :));
   }
}
int do_storeall(string file) {
  int which;
  mixed *stuff;
  int i, j, no, amt, cnt=0;
  string *boards, their_name;
  mapping news_rc;
  seteuid( geteuid( this_player() ) );
  their_name = this_player()->query_name();
  boards = (string *)BOARD_HAND->list_of_boards();
  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  if (!write_file(file, "File created on "+ctime(time())+
                        " - Seattle time\n", 1)) {
    add_failed_mess("Unable to save the file "+file+"\n");
    return 0;
  }
  for (i=0;i<sizeof(boards);i++) {
    if (!this_player()->query_property("news_kill_"+lower_case(boards[i]))) {
      stuff = (mixed *)BOARD_HAND->get_subjects(boards[i]);
      if (!sizeof(stuff))
        continue;
      for (amt=sizeof(stuff)-1;amt >= 0 &&
                               (stuff[amt][B_TIME] > news_rc[boards[i]] &&
                               lower_case(stuff[amt][B_NAME]) != their_name);
                 amt--);
      if (amt != sizeof(stuff)-1) {
        write_file(file,"\n----> Bulletin Board Name: "+boards[i]+"\n\n\n");
        news_rc[boards[i]] = stuff[sizeof(stuff)-1][B_TIME];
        for(j = amt+1;j<sizeof(stuff);j++) {
          write_file(file,"***** Note #" +(j+1)+ " by " +stuff[j][B_NAME]+
       " posted at " +ctime(stuff[j][B_TIME])+ "\nTitle: "+
       stuff[j][B_SUBJECT][0..(int)this_player()->
                                                 query_cols() - 10]+"\n\n"+
                         BOARD_HAND->get_message(boards[i], j)+"\n\n\n");
          if (cnt == 0)
             printf("Storing ");
          cnt++;
          printf(".");
        }
      }
    }
  }
  add_succeeded_mess(this_object(), ({
                   "\n"+cnt+" new messages are now saved in "+file+"\n",
                   "$N appears to scribble something a lot.\n" }), ({ }));
  if (cnt == 0) {
    this_player()->add_property(NEWS_RC, news_rc);
  }
  return 1;
}
int do_store(int which, string file) {
  mixed *stuff;
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (which < 1 || which > sizeof(stuff)) {
    add_failed_mess("Invalid note number.\n");
    return 0;
  }
  which--;
  file += ".note";
  if (!write_file(file,stuff[which][B_SUBJECT]+"\n\n"+
                  BOARD_HAND->get_message(board_name, which))) {
    add_failed_mess("The master object appears and prevents you.\n");
    return 0;
  }
  add_succeeded_mess(this_object(), ({ "Ok.\n", "$N copies some stuff off "
                                       "the board.\n" }), ({ }) );
  return 1;
}
void set_board_name(string str) { board_name = str; }
void set_datafile(string str) { board_name = str; }
int do_next() {
  int i;
  string *boards;
  boards = (string *)BOARD_HAND->list_of_boards();
  if ((i = member_array(board_name, boards)) == -1)
    i = 0;
  else
    i = (i+1)%sizeof(boards);
  board_name = boards[i];
  add_succeeded_mess(this_object(), ({ "Gone to board:"+board_name+".\n",
                      "$N turns their board over.\n" }), ({ }) );
  return 1;
}
int prev() {
  int i;
  string *boards;
  boards = (string *)BOARD_HAND->list_of_boards();
  if ((i = member_array(board_name, boards)) == -1)
    i = 0;
  else
    i = (i-1+sizeof(boards))%sizeof(boards);
  board_name = boards[i];
  add_succeeded_mess(this_object(), ({ "Gone to board:"+board_name+".\n",
                      "$N turns their board over.\n" }), ({ }) );
  return 1;
}
int do_killfile(string arg) {
  this_player()->add_property( "news_kill_" +lower_case( arg ), 1 );
  add_succeeded_mess(this_object(), ({ "Board "+arg+" killed.\n", "" }), ({}));
  return 1;
}
int do_unkillfile(string arg) {
  if (!this_player()->query_property( "news_kill_" +lower_case( arg ) )) {
     add_failed_mess("Board "+arg+" is not kill file anyway.\n");
     return 0;
  } else {
     this_player()->remove_property( "news_kill_" +lower_case( arg ) );
     add_succeeded_mess(this_object(), ({ "Board "+arg+" unkilled.\n", "" }),
                       ({ }));
  }
  return 1;
}
int do_listkillfile(string arg) {
   string property, s1, *boards=({ });
   mixed value;
   foreach ( property, value in this_player()->query_properties() )
      if ( sscanf(property,"news_kill_%s",s1) == 1 &&
           value )
         boards += ({ s1 });
   if ( sizeof( s1 ) )
      tell_object( this_player(), "You have the following boards killfiled: "+
                  query_multiple_short( boards ) +".\n" );
   add_succeeded_mess(this_object(), "", ({ }));
   return 1;
}
int do_new() {
  int i, amt;
  string *boards, their_name;
  mixed *stuff;
  mixed otherstuff;
  mapping news_rc;
  boards = (string *)BOARD_HAND->list_of_boards();
  their_name = this_player()->query_name();
  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  for (i=0;i<sizeof(boards);i++) {
    if (!this_player()->query_property("news_kill_"+lower_case(boards[i]))) {
      stuff = (mixed *)BOARD_HAND->get_subjects(boards[i]);
      if (!sizeof(stuff))
        continue;
      for (amt=sizeof(stuff)-1;amt >= 0 &&
                               (stuff[amt][B_TIME] > news_rc[boards[i]] &&
                                lower_case(stuff[amt][B_NAME]) != their_name);
                 amt--);
      if (amt != sizeof(stuff)-1) {
        board_name = boards[i];
        add_succeeded_mess(this_object(), ({
          "The "+ boards[ i ] +" board has "+ ( sizeof( stuff ) - amt -
          1 ) +" new message"+ ( ( ( sizeof( stuff ) - amt ) > 2 ) ? "s" : "" )
          +".\n", "$N turns over their board.\n" }), ({ }));
        return 1;
      }
    }
  }
  add_failed_mess("No boards with new messages.\n");
  return 0;
}
int do_board(string str) {
  int i;
  string *boards;
  boards = (string *)BOARD_HAND->list_of_boards();
  i = member_array(str, boards);
  if (i == -1) {
    add_failed_mess("The board "+str+" does not exist sorry.\n");
    return 0;
  }
  add_succeeded_mess(this_object(), ({ "Okay, changed to board "+ str +".\n",
                                   "$N turns over their board.\n" }), ({ }));
  board_name = str;
  return 1;
}
int do_boards() {
   write( "The current boards are:\n\""+
         implode( (string *)BOARD_HAND->list_of_boards(), "\", \"" ) +
         "\".\n" );
  return 1;
}
int do_security() {
   write( "The current people in this boards security array are:\n"+
        implode((string *)BOARD_HAND->query_security(board_name), ", ")+"\n");
  return 1;
}
int do_add(string name) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->add_allowed(board_name, name);
}
int do_remove(string name) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->remove_allowed(board_name, name);
}
int do_timeout(int i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_timeout(board_name, i);
}
int do_minimum(string i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_minimum(board_name, i);
}
int do_maximum(int i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_maximum(board_name, i);
}
int do_archive(string name) {
  if (!name)
    return 0;
  if (name != "none")
    return (int)BOARD_HAND->set_archive(board_name, name);
  return (int)BOARD_HAND->set_archive(board_name);
}
varargs int move(object dest, string s1, string s2) {
  int ret;
  if (!objectp(dest))
    return ::move(dest, s1, s2);
  if (interactive(dest)) {
    ret = ::move(dest, s1, s2);
    if (ret)
      return ret;
    seteuid(geteuid(dest));
    return 0;
  }
  return ::move(dest, s1, s2);
}
mixed query_static_auto_load() {
  return board_name;
}
void init_static_arg(mixed board) {
  if (stringp(board))
    board_name = board;
}
int do_summary(string str) {
  int i, no, amt;
  string *boards, their_name;
  mapping news_rc;
  mixed *stuff;
  boards = (string *)BOARD_HAND->list_of_boards();
  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  their_name = this_player()->query_name();
  for (i=0;i<sizeof(boards);i++) {
    if (!this_player()->query_property("news_kill_"+lower_case(boards[i]))) {
      stuff = (mixed *)BOARD_HAND->get_subjects(boards[i]);
      if (!sizeof(stuff))
        continue;
      for (amt=sizeof(stuff)-1;amt >= 0 &&
                               (stuff[amt][B_TIME] > news_rc[boards[i]] &&
                               lower_case(stuff[amt][B_NAME]) != their_name);
                 amt--);
      if (amt != sizeof(stuff)-1) {
        printf( "The "+ boards[ i ] +" board has "+ ( sizeof( stuff ) - amt -
          1 ) +" new message"+ ( ( ( sizeof( stuff ) - amt ) > 2 ) ? "s" : "" )
          +".\n" );
        no++;
      } else if (str == "all") {
        printf("The "+boards[i]+" board has no new messages.\n");
        no++;
      }
    }
  }
  if (no) {
    add_succeeded_mess(this_object(), ({ "", "$N runs their finger over "
                                             "thier board.\n" }), ({ }));
  } else {
    add_failed_mess("No boards with new messages.\n");
  }
  return no;
}
int do_skip() {
  mapping news_rc;
  mixed *otherstuff;
  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  otherstuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (sizeof(otherstuff)) {
    news_rc[board_name] = otherstuff[sizeof(otherstuff)-1][B_TIME];
    this_player()->add_property(NEWS_RC, news_rc);
  }
  printf("Marked all of "+board_name+" as read.\n");
  if (!do_new()) {
    printf("No new messages.\n");
  }
  add_succeeded_mess(this_object(), "", ({ }));
  return 1;
}
int do_arts() {
  int i;
  mixed *otherstuff;
  otherstuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  for (i=0;i<sizeof(otherstuff);i++)
    printf("%2d# %-20s %d\n", i, otherstuff[i][B_NAME], otherstuff[i][B_NUM]);
  add_succeeded_mess(this_object(), "", ({ }));
  return 1;
}
int do_transfer(int num, string str) {
  string mess;
  string *boards;
  mixed *otherstuff;
  int i;
  boards = (string *)BOARD_HAND->query_boards();
  otherstuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (member_array(str, boards) == -1) {
    add_failed_mess("Cannot find the board '"+str+"'.\n");
    return 0;
  }
  if (num < 1 || num > sizeof(otherstuff)) {
    add_failed_mess("There is no note '"+num+"' on the board '"+
                        board_name+".\n");
    return 0;
  }
  mess = BOARD_HAND->get_message(board_name, num-1);
  if (mess && BOARD_HAND->add_message(str, otherstuff[num-1][B_NAME],
                              otherstuff[num-1][B_SUBJECT],
                              mess)) {
    write("Transfered note "+num+" to board '"+str+
                   "', local copy retained.\n");
    return 1;
  }
  add_failed_mess("Unable to transfer note "+num+" to the board '"+
                      board_name+", no security privilages?\n");
  return 0;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/crystal_phial.c ===
inherit "/obj/vessel";
void setup() {
   set_name( "phial" );
   set_short( "crystal phial" );
   add_adjective( "crystal" );
   set_main_plural( "crystal phials" );
   set_long( "This is a small tube-like bottle made of some sort of "+
         "crystal.  A stopper is attached at one end on a bit of wire.\n" );
   set_weight( 1 );
   set_value( 1000 );
   set_max_weight( 1 );
   set_max_volume( 10 );
   set_transparent();
}
int test_add( object thing, int flag ) {
   string word;
   object *things;
   if ( !this_player() )
      return ::test_add( thing, flag );
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return ::test_add( thing, flag );
   word = (string)things[ 0 ]->query_medium_alias();
   if ( word == (string)thing->query_medium_alias() )
      return ::test_add( thing, flag );
   write( "You don't want to contaminate "+ ( stringp( word ) ?
         (string)things[ 0 ]->the_short() :
         (string)thing->the_short() ) +", do you?\n" );
   return 0;
}
object query_substance() {
   object *things;
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return 0;
   if ( !stringp( (string)things[ 0 ]->query_medium_alias() ) )
      return 0;
   return things[ 0 ];
}
string short( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::short( dark );
   return ::short( dark ) +" of "+ (string)thing->short( dark );
}
string query_plural( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::query_plural( dark );
   return ::query_plural( dark ) +" of "+ (string)thing->short( dark );
}
string *parse_command_adjectiv_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_adjectiv_id_list();
   return ::parse_command_adjectiv_id_list() + ({ "of" }) +
      (string *)thing->query_adjectives();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/board_mas.c ===
#include <mail.h>
#include <board.h>
inherit "/obj/misc/board";
int do_store(int num, string str);
int do_storeall(string str);
int do_minimum(int num);
int do_maximum(int num);
int do_timeout(int num);
int do_add(string str);
int do_remove(string str);
int do_board(string str);
int do_archive(string str);
int do_killfile(string str);
int do_unkillfile(string str);
int do_transfer(int num, string str);
int do_summary();
int do_skip(string str, int move_on);
int calc_new(object player, string board);
void setup() {
  ::setup();
  add_alias("board master");
  action_pri = 3;
  reset_drop();
  set_get();
}
string long(string str, int dark) {
  int i, irp;
  mixed *stuff;
  string ret;
  mapping news_rc;
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  ret = "A bulletin board ("+board_name+").\n";
  irp = (int)BOARD_HAND->query_minimum(board_name);
  if (irp)
    ret += "Minimum number of messages left by automagic deletion is "+ irp +
           ".\n";
  irp = (int)BOARD_HAND->query_maximum(board_name);
  if (irp)
    ret += "Maximum number of messages on this board is "+irp+".\n";
  irp = (int)BOARD_HAND->query_timeout(board_name);
  if (irp)
    ret += "Messages will automagically time out in "+ irp +" days.\n";
  irp = (int)BOARD_HAND->query_archive(board_name);
  if (irp)
    ret += "Deleted messages are archived in "+irp+".\n";
  ret += sprintf("%#-*s\n\n", this_player()->query_cols(),
                 "read <note number>\npost <subject>\n"+
                 "boards\n"
                 "store <note number> <file>\n"
                 "storeall <file> (optional)\n"
                 "eat <note number>\n"
                 "reply <note number>\n"
                 "followup <note number>\n"
                 "summary [all]\n"
                 "next\n"
                 "prev\n"
                 "skip [<board name>]\n"
                 "board <board name>\n"
                 "timeout <time>\n"
                 "minimum <num>\n"
                 "maximum <num>\n"
                 "archive <name|none>\n"
                 "security\n"
                 "sadd <name>\n"
                 "sremove <name>\n"
                 "killfile <board name>\n"
                 "unkillfile <board name>\n"
                 "listkillfile\ntransfer <note> <board>");
  if (!sizeof(stuff))
    return ret+"The board is completely empty.\n";
  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
  if (!news_rc)
    news_rc = ([ ]);
  for (i=0;i<sizeof(stuff);i++)
    if (news_rc[board_name] < stuff[i][B_TIME])
      ret += sprintf("N %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
             stuff[i][B_SUBJECT]+" ("+
             stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
    else
      ret += sprintf("  %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
             stuff[i][B_SUBJECT]+" ("+
             stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
  return ret;
}
int calc_new(object who, string board) {
  mapping news_rc;
  mixed *stuff;
  int amt;
  news_rc = BOARD_HAND->query_newsrc(who->query_name());
  if ( !news_rc )
    news_rc = ([ ]);
  stuff = (mixed *)BOARD_HAND->get_subjects(board);
  if ( !sizeof( stuff ) )
    return 0;
  amt = sizeof( filter_array( stuff, (: ( $1[ B_TIME ] > $2 ) &&
              ( lower_case( $1[ B_NAME ] ) != $3 ) :), news_rc[ board ],
                              (string)who->query_name() ) );
  return amt;
}
void init() {
   if (this_player()->query_creator()) {
      add_commands();
      add_command("store", "<number> <word>", (: do_store($4[0], $4[1]) :));
      add_command("storeall", "<word>", (: do_storeall($4[0]) :));
      add_command("next", "");
      add_command("prev", "");
      add_command("new", "");
      add_command("board", "<string>", (: do_board($4[0]) :));
      add_command("boards", "");
      add_command("killfile", "<string>", (: do_killfile($4[0]) :));
      add_command("unkillfile", "<string>",(: do_unkillfile($4[0]) :));
      add_command("listkillfile", "");
      add_command("security", "");
      add_command("sadd", "<word>", (: do_add($4[0]) :));
      add_command("sremove", "<word>", (: do_remove($4[0]) :));
      add_command("timeout", "<number>", (: do_timeout($4[0]) :));
      add_command("minimum", "<number>", (: do_minimum($4[0]) :));
      add_command("maximum", "<number>", (: do_maximum($4[0]) :));
      add_command("archive", "<word>", (: do_archive($4[0]) :));
      add_command("summary", "");
      add_command("skip", "", (: do_skip(0, 1) :));
      add_command("catchup", "", (: do_skip(0, 0) :));
      add_command("skip", "<string>", (: do_skip($4[0], 1) :));
      add_command("catchup", "<string>", (: do_skip($4[0], 0) :));
      add_command("arts", "");
      add_command("transfer", "<number> <string>",
                     (: do_transfer($4[0], $4[1]) :));
   }
}
int do_storeall(string file) {
  mixed *stuff;
  int i, j, amt, cnt=0;
  string *boards, their_name;
  mapping news_rc;
  seteuid( geteuid( this_player() ) );
  their_name = this_player()->query_name();
  boards = (string *)BOARD_HAND->list_of_boards();
  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if ( !news_rc )
      news_rc = ([ ]);
  if (!write_file(file, "File created on "+ctime(time())+
                        " - Seattle time\n", 1)) {
    add_failed_mess("Unable to save the file "+file+"\n");
    return 0;
  }
  for (i=0;i<sizeof(boards);i++) {
    reset_eval_cost();
    if (!BOARD_HAND->query_killfile(this_player()->query_name(), lower_case(boards[i]))) {
      stuff = (mixed *)BOARD_HAND->get_subjects(boards[i]);
      if (!sizeof(stuff))
        continue;
      for (amt=sizeof(stuff)-1;amt >= 0 &&
                               (stuff[amt][B_TIME] > news_rc[boards[i]] &&
                               lower_case(stuff[amt][B_NAME]) != their_name);
                 amt--);
      if (amt != sizeof(stuff)-1) {
        write_file(file,"\n----> Bulletin Board Name: "+boards[i]+"\n\n\n");
        news_rc[boards[i]] = stuff[sizeof(stuff)-1][B_TIME];
        for(j = amt+1;j<sizeof(stuff);j++) {
          write_file(file,"***** Note #" +(j+1)+ " by " +stuff[j][B_NAME]+
       " posted at " +ctime(stuff[j][B_TIME])+ "\nTitle: "+
       stuff[j][B_SUBJECT][0..(int)this_player()->
                                                 query_cols() - 10]+"\n\n"+
                         BOARD_HAND->get_message(boards[i], j)+"\n\n\n");
          if (cnt == 0)
             printf("Storing ");
          cnt++;
          printf(".");
        }
      }
    }
  }
  write("\n"+cnt+" new messages are now saved in "+file+"\n");
  if (cnt == 0) {
    BOARD_HAND->set_newsrc(this_player()->query_name(), news_rc);
  }
  return 1;
}
int do_store(int which, string file) {
  mixed *stuff;
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (which < 1 || which > sizeof(stuff)) {
    add_failed_mess("Invalid note number.\n");
    return 0;
  }
  which--;
  file += ".note";
     seteuid( geteuid( this_player() ) );
  if (!write_file(file,stuff[which][B_SUBJECT]+"\n\n"+
                  BOARD_HAND->get_message(board_name, which))) {
    add_failed_mess("The master object appears and prevents you.\n");
    return 0;
  }
  write("Ok.\n");
  return 1;
}
void set_board_name(string str) { board_name = str; }
void set_datafile(string str) { board_name = str; }
int do_next() {
  int start, i, j, k, found;
  string *boards;
  if(calc_new(this_player(), board_name))
    return do_read_new();
  boards = (string *)BOARD_HAND->list_of_boards();
  if ((start = member_array(board_name, boards)) == -1)
    start = 0;
  for(i=0; i<sizeof(boards); i++) {
    j = (i + start) % sizeof(boards);
    if(!BOARD_HAND->query_killfile(this_player()->query_name(),
                                     lower_case(boards[j])) &&
       k = calc_new(this_player(), boards[j])) {
      found = 1;
      break;
    }
  }
  if(found) {
    board_name = boards[j];
    write("Okay, changed to board "+board_name+" with " + k +
          " new notes.\n");
    return do_read_new();
  } else
    write("No boards with new messages.\n");
  return 1;
}
int do_prev() {
  int i;
  string *boards;
  boards = (string *)BOARD_HAND->list_of_boards();
  if ((i = member_array(board_name, boards)) == -1)
    i = 0;
  else
    i = (i-1+sizeof(boards))%sizeof(boards);
  board_name = boards[i];
  write("Okay, changed to board "+board_name+".\n");
  return 1;
}
int do_killfile(string arg) {
    string *bits, board;
    bits = explode( arg, "," );
    foreach ( board in bits ) {
        if ( sizeof( BOARD_HAND->get_subjects( board ) ) ) {
          BOARD_HAND->set_killfile(this_player()->query_name(),
                lower_case( board ));
            tell_object( this_player(), "Board " + board  + " killed.\n" );
        }
        else {
            tell_object( this_player(), "There is no such board " +
                board + ".\n" );
        }
    }
    return 1;
}
int do_unkillfile(string arg) {
  if (!BOARD_HAND->query_killfile(this_player()->query_name(),
                                  lower_case( arg ) )) {
     add_failed_mess("Board "+arg+" is not kill file anyway.\n");
     return 0;
  } else {
    BOARD_HAND->remove_killfile(this_player()->query_name(),
                                lower_case(arg));
     write("Board "+arg+" unkilled.\n");
  }
  return 1;
}
int do_listkillfile() {
   string *boards;
   boards = BOARD_HAND->list_killfile(this_player()->query_name());
   if ( sizeof( boards ) )
     write("You have the following boards killfiled: "+
           query_multiple_short( boards ) +".\n" );
   return 1;
}
int do_board(string str) {
  int i;
  string *boards;
  boards = (string *)BOARD_HAND->list_of_boards();
  i = member_array(str, boards);
  if (i == -1) {
    add_failed_mess("The board "+str+" does not exist sorry.\n");
    return 0;
  }
  write("Okay, changed to board "+ str);
  i = calc_new(this_player(), boards[i]);
  if(i)
    write(" with " + i + " new notes.\n");
  else
    write(" with no new notes.\n");
  board_name = str;
  return 1;
}
int do_boards() {
   write( "The current boards are:\n\""+
         implode( (string *)BOARD_HAND->list_of_boards(), "\", \"" ) +
         "\".\n" );
  return 1;
}
int do_security() {
   write( "The current people in this boards security array are:\n"+
        implode((string *)BOARD_HAND->query_security(board_name), ", ")+"\n");
  return 1;
}
int do_add(string name) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->add_allowed(board_name, name);
}
int do_remove(string name) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->remove_allowed(board_name, name);
}
int do_timeout(int i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_timeout(board_name, i);
}
int do_minimum(string i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_minimum(board_name, i);
}
int do_maximum(int i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_maximum(board_name, i);
}
int do_archive(string name) {
  if (!name)
    return 0;
  if (name != "none")
    return (int)BOARD_HAND->set_archive(board_name, name);
  return (int)BOARD_HAND->set_archive(board_name);
}
varargs int move(object dest, string s1, string s2) {
  int ret;
  if (!objectp(dest))
    return ::move(dest, s1, s2);
  if (interactive(dest)) {
    ret = ::move(dest, s1, s2);
    if (ret)
      return ret;
    seteuid(geteuid(dest));
    return 0;
  }
  return ::move(dest, s1, s2);
}
mixed query_static_auto_load() {
  return board_name;
}
void init_static_arg(mixed board) {
  if (stringp(board))
    board_name = board;
}
int do_summary() {
   int i, no, amt;
   string *boards;
   boards = (string *)BOARD_HAND->list_of_boards();
   for ( i = sizeof( boards ) - 1; i > -1; i-- )
      if ( !BOARD_HAND->query_killfile(this_player()->query_name(),
                                      lower_case( boards[ i ] ) ) ) {
        amt = calc_new(this_player(), boards[i]);
         if ( amt ) {
            printf( "The %s board has %d new message%s.\n", boards[ i ],
                  amt, amt > 1 ? "s" : "" );
            no++;
         }
      }
   if ( !no )
      add_failed_mess( "No boards with new messages.\n" );
   return no;
}
int do_new() {
   int i, amt;
   string *boards;
   boards = (string *)BOARD_HAND->list_of_boards();
   for ( i = sizeof( boards ) - 1; i > -1; i-- )
     if ( !BOARD_HAND->query_killfile(this_player()->query_name(),
                                      lower_case( boards[ i ] ) ) ) {
        amt = calc_new(this_player(), boards[i]);
         if ( amt ) {
            board_name = boards[ i ];
            printf( "The %s board has %d new message%s.\n", boards[ i ],
                  amt, amt > 1 ? "s" : "" );
            return 1;
         }
      }
   add_failed_mess( "No boards with new messages.\n" );
   return 0;
}
int do_skip(string str, int move_on) {
  mapping news_rc;
  mixed *otherstuff;
  int i, j, k, start, found;
  string *boards;
  if(!str) {
    str = board_name;
  }
  boards = (string *)BOARD_HAND->list_of_boards();
  if(member_array(str, boards) == -1)
    return notify_fail("No such board " + str + ".\n");
  news_rc = BOARD_HAND->query_newsrc(this_player()->query_name());
   if ( !news_rc )
      news_rc = ([ ]);
  otherstuff = (mixed *)BOARD_HAND->get_subjects(str);
  if (sizeof(otherstuff)) {
    news_rc[str] = otherstuff[sizeof(otherstuff)-1][B_TIME];
    BOARD_HAND->set_newsrc(this_player()->query_name(), news_rc);
  }
  printf("Marked all of "+str+" as read.\n");
  if(move_on) {
    reset_eval_cost();
    if ((start = member_array(board_name, boards)) == -1)
      start = 0;
    for(i=0; i<sizeof(boards); i++) {
      j = (i + start) % sizeof(boards);
      if(!BOARD_HAND->query_killfile(this_player()->query_name(),
                                     lower_case(boards[j])) &&
         k = calc_new(this_player(), boards[j])) {
        found = 1;
        break;
      }
    }
    if(found) {
      board_name = boards[j];
      write("Okay, changed to board "+board_name+" with " + k +
            " new notes.\n");
    } else
      write("No boards with new messages.\n");
  }
  return 1;
}
int do_arts() {
  int i;
  mixed *otherstuff;
  otherstuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  for (i=0;i<sizeof(otherstuff);i++)
    printf("%2d# %-20s %d\n", i, otherstuff[i][B_NAME], otherstuff[i][B_NUM]);
  return 1;
}
int do_transfer(int num, string str) {
  string mess;
  string *boards;
  mixed *otherstuff;
  boards = (string *)BOARD_HAND->query_boards();
  otherstuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (member_array(str, boards) == -1) {
    add_failed_mess("Cannot find the board '"+str+"'.\n");
    return 0;
  }
  if (num < 1 || num > sizeof(otherstuff)) {
    add_failed_mess("There is no note '"+num+"' on the board '"+
                        board_name+".\n");
    return 0;
  }
  mess = BOARD_HAND->get_message(board_name, num-1);
  if (mess && BOARD_HAND->add_message(str, otherstuff[num-1][B_NAME],
                              otherstuff[num-1][B_SUBJECT],
                              mess)) {
    write("Transfered note "+num+" to board '"+str+
                   "', local copy retained.\n");
    return 1;
  }
  add_failed_mess("Unable to transfer note "+num+" to the board '"+
                      board_name+", no security privilages?\n");
  return 0;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/tin_of_paint.c ===
inherit "/obj/vessel";
#define VOLUME 5000
private nosave string _colour;
varargs int do_paint(string, object);
void setup() {
  set_name( "tin" );
  set_short( "tin of paint" );
  set_main_plural( "tins of paint");
  add_adjective( ({ "tin", "of"}));
  add_alias(({"paint"}));
  set_long( "A tin of paint.  It has a picture of a man with "
            "a big smile on his face painting a wall.\n");
  set_leak_rate( 0 );
  set_max_volume( VOLUME );
  set_value( 30 );
  set_weight( 10 );
  set_max_weight( 30 );
}
void setup_attribs() {
  set_short( "tin of " + _colour + " paint" );
  set_main_plural( "tins of " + _colour + " paint");
  add_adjective( ({ _colour}));
  set_long( "A tin of " + _colour + " paint.  It has a picture of a man with "
            "a big smile on his face painting a wall.\n");
}
void make_tin( string colour ) {
  object liquid;
  liquid = clone_object( "/obj/reagents/generic_liquid.ob" );
  liquid->set_name( "paint" );
  liquid->set_short( colour + " paint" );
  liquid->add_adjective(({colour }));
  liquid->set_amount( VOLUME );
  liquid->set_continuous();
  liquid->set_long( "This is " + colour + " paint, it's thick and gloopy.\n");
  liquid->set_pile_name( "puddle" );
  liquid->add_eat_effect( "/std/effects/ingested/poison", 10 );
  liquid->move( this_object() );
  set_closed();
  _colour = colour;
  setup_attribs();
}
void init() {
  ::init();
  this_player()->add_command("paint", this_object(),
           "<indirect:object:here'cardinal direction'> with <direct:object'paint'>",
                        (: do_paint( $4[0] ) :));
  this_player()->add_command("paint", this_object(),
                        "<string'part'> on <indirect:object:here> with <direct:object'paint'>",
                        (: do_paint( $4[0], $1[0] ) :));
  this_player()->add_command("paint", this_object(),
            "<indirect:object:here> help",
            (: do_paint( 0, $1[0] ) :));
}
varargs int do_paint(string indirect, object target) {
  object *obs;
  if(!indirect && target) {
      if(function_exists("what_to_paint", target))
          printf(target->what_to_paint());
      else
          printf("Help: paint " + target->short() + " with paint\n");
      return 1;
  }
  obs = match_objects_for_existence("paint", this_object());
  if(!query_volume() || !sizeof(obs)) {
    this_player()->add_failed_mess(this_object(), "$D appears to be empty.\n",
                                   ({ }));
    return 0;
  }
  if(query_closed()) {
    this_player()->add_failed_mess(this_object(), "$D is closed.\n", ({ }));
    return 0;
  }
  if(!sizeof(filter(this_player()->query_holding() - ({ 0 }),
                    (: $1->id("paint brush") :)))) {
    this_player()->add_failed_mess(this_object(), "You must be holding a "
                                   "paint brush to paint the walls.\n", ({ }));
    return 0;
  }
  if(!environment(this_player())->test_occupier(this_player()->query_name())) {
    this_player()->add_failed_mess(this_object(),
                                   "You don't own this house.\n", ({ }));
    return 0;
  }
  if(target) {
      if(!target->query_short()) return 0;
          if(!function_exists("decorate_part", target)) {
                  this_player()->add_failed_mess(this_object(), "You can't $V the " +
                                indirect + " on the " + target->query_short() + "!\n", ({ }));
                  return 0;
          }
          if(!target->decorate_part( indirect, obs[0]->query_short() )) {
                  this_player()->add_failed_mess(this_object(), "You can't $V the " +
                                                                        indirect + ".\n", ({ }));
                  return 0;
          }
          this_player()->add_succeeded_mess(this_object(), "$N $V the " +
                                    indirect + " on the " + target->query_short() +
                                                                        " with the brush using light, smooth strokes.\n", ({ }));
          return 1;
  }
  if(!function_exists("decorate_surface", environment(this_player()))) {
    this_player()->add_failed_mess(this_object(), "You can't $V the walls "
                                   "here.\n", ({ }));
    return 0;
  }
  if(!environment(this_player())->
     decorate_surface(indirect, "covered with " + obs[0]->query_short())) {
    this_player()->add_failed_mess(this_object(), "You can't $V the " +
                                   indirect + ".\n", ({ }));
    return 0;
  }
  remove_volume(query_volume());
  this_player()->add_succeeded_mess(this_object(), "$N $V the " +
                                    indirect + " with $D using "
                                    "broad, smooth strokes.\n", ({ }));
  return 1;
}
mapping int_query_static_auto_load() {
  mapping tmp;
  tmp = ::int_query_static_auto_load();
  return ([ "::" : tmp,
          "colour" : _colour,
          ]);
}
mapping query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}
void init_static_arg(mapping args) {
  if (args["::"])
    ::init_static_arg(args["::"]);
  if (!undefinedp(args["colour"]))
    _colour = args["colour"];
  if(_colour)
    setup_attribs();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/torch.c ===
#include <fuel_handler.h>
#include <move_failures.h>
inherit "/std/object";
inherit "/std/basic/holdable";
#define BRIGHTNESS 30
#define MAX_FUEL 2000
#define FUEL_PER_TICK ( FUEL_TIME * 2 )
private int amount_of_fuel;
private int is_lit;
int finish_it();
void setup_shorts();
void create() {
   object::create();
   holdable::create();
}
void setup() {
   amount_of_fuel = MAX_FUEL;
   set_name( "torch" );
   add_plural( "torches" );
   setup_shorts();
   add_help_file("torch");
   set_long( function() {
      string str;
      if ( is_lit && amount_of_fuel) {
         call_out( (: setup_shorts() :), 2 );
         str = "This is a fire burning out of control on the end "
            "of a stick of wood.  There is a lot of smoke coming "
            "off the fire, of the kind that, no matter which "
            "way you turn, will go up your nose.";
         switch ( amount_of_fuel / ( MAX_FUEL / 10 ) ) {
          case 10 :
          case 9  :
            return str+"  The torch looks brand new, it will burn for "
               "ages yet.\n";
          case 8 :
          case 7 :
          case 6 :
            return str+"  Not yet burning for very long, this torch is "
               "pretty happy with itself.  It doesn't seem "
               "to care about its short life span.\n";
          case 5 :
          case 4 :
            return str+"  The torch is happily burning.  It is in the "
               "prime of its life.\n";
          case 3 :
            return str+"  The torch has a little way to go yet, as it is "
               "now burning the light wood.\n";
          case 2 :
            return str+"  It looks like this torch won't "
               "last much longer.  Buying a new one would "
               "probably be a good investment.\n";
          case 1 :
          case 0 :
            return str+"  The torch is spluttering, there are huge "
               "amounts of smoke coming off it.  It looks like "
               "it is about to go out.\n";
         }
      }
      if ( amount_of_fuel >= MAX_FUEL )
         return "This lump of what looks like some sort of tree has a few "
         "dirty rags wrapped around the end of it, and it looks as "
         "though it might be possible to light them.  The dirty rags "
         "have some sort of stuff covering them, probably "
         "to make them burn better.\n";
      if ( amount_of_fuel > MAX_FUEL / 2 )
         return "Someone has cut down a tree, chopped it up into smaller "
         "chunks and then wrapped the end in some rags.  "
         "The rags are blackened and it looks like someone set "
         "fire to them.  Perhaps you can too?\n";
      str = "This lump of what looks like some sort of tree has a few "
         "dirty rags wrapped around the end.  ";
      if ( !amount_of_fuel )
         return str +"The end is completely blackened.  You would "
         "have to be extremely clever to get this torch "
         "going again.\n";
      switch (amount_of_fuel/(MAX_FUEL/10)) {
       case 5 :
       case 4 :
         return str +"The end has been blackened quite a bit, "
            "but it looks like there is a fair bit of "
            "go still left in it.\n";
       case 3 :
       case 2 :
         return str +"A few rags here and there cling to a meager "
            "existence.  You could set fire to them and "
            "make their life hell for a little while, but "
            "not for very long.\n";
       case 1 :
       case 0 :
         return str +"You can just see the remains of some rags "
            "attached to the blackened and burnt end of "
            "the torch.  It will last only for a short while "
            "longer.\n";
      }
      return "Whoops.  Tell a creator if you see this.\n";
   }
            );
   is_lit = 0;
   set_weight( 6 );
   set_value( 50 );
}
void set_fuel(int f) {
   amount_of_fuel = f;
   if(amount_of_fuel < 0)
     amount_of_fuel = 0;
   setup_shorts();
}
void init() {
  this_player()->add_command( "light", this_object() );
  this_player()->add_command( "extinguish", this_object() );
  this_player()->add_command( "dowse", this_object() );
}
void setup_shorts() {
   if ( is_lit && amount_of_fuel) {
      set_short( "lit torch" );
      set_main_plural( "lit torches" );
      remove_adjective( ({ "lightable", "burnt", "out" }) );
      add_adjective( "lit" );
   } else if ( amount_of_fuel > 0 ) {
      set_short( "lightable torch" );
      set_main_plural( "lightable torches" );
      remove_adjective( ({ "lit", "burnt", "out" }) );
      add_adjective( "lightable" );
   } else {
      set_short( "burnt torch" );
      set_main_plural( "burnt torches" );
      remove_adjective( ({ "lit", "lightable" }) );
      add_adjective( ({ "burnt", "out" }) );
   }
}
int do_light() {
   if (environment(this_object()) != this_player()) {
      this_player()->add_failed_mess( this_object(),
                                     "You are not carrying $D.\n", ({ }) );
      return 0;
   }
   if (amount_of_fuel <= 0) {
      this_player()->add_failed_mess( this_object(), "$D is burnt out.\n",
                                     ({ }) );
      return 0;
   }
   if (is_lit) {
      this_player()->add_failed_mess( this_object(), "$D is already lit.\n",
                                     ({ }) );
      return 0;
   }
   if (!query_holder() &&
       !sizeof( this_object()->hold_item( this_player(), -1 ) ) ) {
     this_player()->add_failed_mess( this_object(), "Unable to hold $D, "
         "your arms are probably full.\n", ({ }) );
      return 0;
   }
   is_lit = 1;
   FUEL_HANDLER->add_burner( this_object() );
   set_light( BRIGHTNESS );
   call_out( "setup_shorts", 2);
   return 1;
}
void out_of_fuel() {
   is_lit = amount_of_fuel = 0;
   set_light( 0 );
   set_value( 0 );
   FUEL_HANDLER->remove_burner( this_object() );
   tell_room( environment(), one_short() +" splutters violently "
     "for the last time before it crumbles to dust.\n" );
   call_out( "finish_it", 2 );
}
void do_warning() {
   tell_room( environment(), poss_short() +" starts to sputter and smoke a "
             "lot as it is now burning the light wood.  It is on its last "
             "legs.\n");
   return;
}
void consume_fuel() {
   amount_of_fuel -= FUEL_PER_TICK;
   if(amount_of_fuel < 0)
     amount_of_fuel = 0;
   switch ( amount_of_fuel ) {
    case (200-FUEL_PER_TICK) .. 200:
      do_warning();
      break;
    case 0:
      out_of_fuel();
      break;
    default:
   }
}
int do_extinguish(object *, string, string, string) {
   if ( !is_lit && objectp( this_player() ) ) {
      this_player()->add_failed_mess(this_object(), "$D is not lit.\n", ({ }) );
      return 0;
   } else if ( !is_lit ) {
      return 0;
   }
   FUEL_HANDLER->remove_burner( this_object() );
   is_lit = 0;
   set_light( 0 );
   call_out( "setup_shorts", 2);
   return 1;
}
int do_dowse() {
   return do_extinguish(({ }), 0, 0, 0);
}
void dest_me() {
   FUEL_HANDLER->remove_burner( this_object() );
   set_light( 0 );
   holdable::dest_me();
   object::dest_me();
}
mixed *stats() {
  return ::stats() + ({
    ({ "fuel" , amount_of_fuel, }),
    ({ "is lit", is_lit, }),
   });
}
mixed query_dynamic_auto_load() {
  return ([ "::" : object::query_dynamic_auto_load(),
            "amount of fuel" : amount_of_fuel,
            "hold" : holdable::query_dynamic_auto_load(),
            "is lit" : is_lit,
          ]);
}
int held_this_item(int type, object holder, mixed arg) {
   if (!type) {
      if (holder && is_lit) {
         tell_object( holder,
                     "You extinguish the "+ short() +" as you put it down.\n");
         tell_room( environment(holder ),
                   holder->short() +" extinguishes the "+
                   short() +" as "+ holder->query_pronoun()
                   +" puts it down.\n", ({ holder }));
      }
      do_extinguish( ({ }), "", "", "");
   } else if (type == 2) {
      if (arg && holder && amount_of_fuel > 0) {
         set_light( BRIGHTNESS );
         FUEL_HANDLER->add_burner( this_object() );
         is_lit = 1;
      } else {
         is_lit = 0;
      }
      setup_shorts();
   }
   return 1;
}
void init_dynamic_arg( mapping arg ) {
   amount_of_fuel = arg["amount of fuel"];
   is_lit = arg["is lit"];
   if (arg["hold"]) {
      holdable::init_dynamic_arg(arg["hold"], arg["is lit"]);
   }
   ::init_dynamic_arg(arg["::"]);
}
void init_static_arg(mapping arg) {
}
mapping query_static_auto_load() {
   return 0;
}
varargs int move( mixed ob, string mess1, string mess2 ) {
   int ret;
   ret = holdable::move(ob);
   if (ret != MOVE_OK) {
      return ret;
   }
   return object::move( ob, mess1, mess2 );
}
void self_light() {
   is_lit = 1;
   FUEL_HANDLER->add_burner( this_object() );
   set_light( BRIGHTNESS );
   call_out( (: setup_shorts() :), 2);
   return;
}
  int finish_it () {
    this_object()->move( "/room/rubbish" );
    return 1;
}
int query_torch() {
  return 1;
}
int query_lit() {
  return is_lit;
}
int query_fuel() {
  return amount_of_fuel;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/teddy.c ===
#define TP this_player()
#define TPCAP this_player()->one_short()
#define TO this_object()
inherit "std/object";
void setup(){
   set_name("bear");
   set_short("teddy bear");
   add_alias("teddy");
   add_adjective("teddy");
   set_long("This is a cute and cuddly teddy bear.  Just the sort to give "
     +"someone you love to remind them of you.  It looks very soft and "
     +"huggable.\n");
   set_weight(10);
   set_value(25);
   set_main_plural("teddy bears");
   add_plural(({"bears", "teddys"}));
}
void init() {
   TP->add_command("hug", TO);
   TP->add_command("cuddle", TO);
}
int do_hug() {
   write("You hug the teddy bear close to you and feel all warm and fuzzy "
     "inside.\n");
   say(TP->one_short()+ " hugs the teddy bear close and smiles happily.\n");
   TP->add_succeeded_mess(TO, "", ({ }) );
   return 1;
}
int do_cuddle() {
  do_hug();
   TP->add_succeeded_mess(TO, "", ({ }) );
   return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/abscond_trigger.c ===
#define CLASS "fighting.combat.special.abscond"
#include <effect.h>
inherit "/std/object";
void init() {
   if( !environment()
    || file_name( environment( this_object() ) ) == "/room/rubbish" ) {
      return;
   }
   if( this_player()
    && this_player() == query_property( "abscond player" ) ) {
      this_player()->submit_ee2( this_player()->effects_matching(CLASS)[0],
                                 "after_command", 0, EE_REMOVE );
   }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/top_families.c ===
#include <top_ten_tables.h>
#include <clubs.h>
inherit "/std/object";
private string _lang = "morporkian";
string _long();
void setup() {
   set_name( "table" );
   set_short( "top family table" );
   set_long("This is a table listing those families that are most "
            "advanced in certain aspects.\n");
   add_adjective( ({ "top", "family", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
   call_out("setup_read_mess", 5);
}
void setup_read_mess() {
   add_read_mess((: _long() :), 0, _lang, 0);
}
void set_language(string lang) {
  _lang = lang;
}
string query_language() { return _lang; }
string club_name(string str) {
   if (!str) {
      return "Unknown";
   }
   return CLUB_HANDLER->query_club_name(str);
}
string _long() {
   mixed *stuff;
   string bing, str;
   string guild;
   mapping g_info;
   string *g_sorted;
   stuff = TOP_TEN_HANDLER->query_family_info();
   str = "The family with:\n"
         "The most members          : " +
         club_name(stuff[TOP_TEN_LARGEST_FAMILY])  + "\n"
         "The oldest average age    : " +
         club_name(stuff[TOP_TEN_OLDEST_FAMILY]) + "\n"
         "Most average quest points : " +
         club_name(stuff[TOP_TEN_MOST_QUEST_POINTS]) + "\n"
         "Most player killers       : " +
         club_name(stuff[TOP_TEN_MOST_PKS]) + "\n"
         "Largest single gender     : " +
         club_name(stuff[TOP_TEN_SINGLE_GENDER]) + "\n"
         "Oldest start DW time      : " +
         club_name(stuff[TOP_TEN_OLDEST_LOGONS]) + "\n"
         "Most average relationships: " +
         club_name(stuff[TOP_TEN_MOST_RELATIONSHIPS]) + "\n";
   g_info = stuff[TOP_TEN_MOST_GUILD];
   g_sorted = sort_array(filter(keys(g_info), (: stringp($1) &&
                                                 file_size($1 + ".c") > 0 :)),
                         (: strcmp($1->query_name(), $2->query_name()) :));
   foreach (guild in g_sorted) {
      if (stringp(guild)) {
         bing = g_info[guild];
         str += sprintf("%-26s: %s\n",
               "Most " + (guild->query_name()),
               club_name(bing));
      }
   }
   str += "\nTo get onto the average list the family must have more than "
          "3 members that are not creators.\n";
   return str;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/tray.c ===
#include <move_failures.h>
inherit "/std/surface";
inherit "/std/basic/holdable";
inherit "/std/basic/wearable";
void create() {
  wearable::create();
  holdable::create();
  surface::create();
}
void setup() {
  set_name( "tray" );
  set_short( "wooden tray" );
  set_long( "This is a small wooden tray, similar in style to the ones used by "
    "many vendors and travelling salespeople. Only a small quantity of items will "
    "fit on top of it.\n" );
  add_adjective(({ "small", "wooden" }));
  set_material("wood");
  set_weight(5);
  set_max_weight(40);
  set_no_limbs(2);
  set_type("sash");
  set_cond(1000);
  set_max_cond(1000);
  add_wear_effect( "/std/effects/attached/single_shoulder" );
}
string long( string word, int dark ) {
  return surface::long() + wearable::long();
}
varargs int move( mixed dir, string messin, string messout ) {
  if ( holdable::move( dir, messin, messout ) == MOVE_OK ) {
	  return surface::move( dir, messin, messout );
  }
  return MOVE_NO_UNHOLD;
}
mapping query_static_auto_load() {
mapping map = ([ ]);
  map["holdable"] = holdable::query_static_auto_load();
  map["surface"] = surface::query_static_auto_load();
  map["wearable"] = wearable::query_static_auto_load();
  return map;
}
void init_static_arg( mapping map ) {
  if (!undefinedp( map["holdable"] ) )
	holdable::init_static_arg( map["holdable"] );
  if ( !undefinedp( map["surface"] ) && map["surface"] )
	surface::init_static_arg( map["surface"] );
  if ( !undefinedp( map["wearable"] ) && map["wearable"] )
	surface::init_static_arg( map["wearable"] );
}
void dest_me() {
  holdable::dest_me();
  surface::dest_me();
}
mapping query_dynamic_auto_load() {
mapping map = ([ ]);
  map["holdable"] = holdable::query_dynamic_auto_load();
  map["surface"] = surface::query_dynamic_auto_load();
  map["wearable"] = wearable::query_dynamic_auto_load();
  return map;
}
varargs void init_dynamic_arg( mapping map, mixed new_arg ) {
  if (!undefinedp( map["holdable"] ) )
	holdable::init_dynamic_arg( map["holdable"] );
  if ( !undefinedp( map["surface"] ) && map["surface"] )
	surface::init_dynamic_arg( map["surface"] );
  if ( !undefinedp( map["wearable"] ) && map["wearable"] )
	surface::init_dynamic_arg( map["wearable"] );
}
mixed stats() {
	return surface::stats() + wearable::stats();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/balance.c ===
#include <library.h>
#define DEFAULT_PANS ([ \
  "left" : ([ ]), \
  "middle" : ([ \
  "very small" : ({ "1/9", 1 }), \
  "small" : ({ "1/3", 3 }), \
  "medium" : ({ "1", 9 }), \
  "large" : ({ "3", 27 }), \
  "very large" : ({ "9", 81 }) ]), \
  "right" : ([ ]) ])
inherit "/std/object";
private nosave int balance;
private nosave string *doing;
private nosave mapping pans;
void setup();
void init();
string *query_doing();
mapping query_pans();
string long( string words, int dark );
string pans_look();
void recalculate_balance();
int reset_weights();
string weight_string( int weight );
int weigh_something( object* obs );
int figure_it_out();
int move_a_specific_weight( string weight_size, string pan_to );
int move_a_weight( string weight_size, string pan_from, string pan_to );
void it_is_balanced( object person );
void setup() {
  set_name( "balance" );
  set_short( "weighing balance" );
  add_adjective( "weighing" );
  add_alias( ({ "pan", "pans", "weight", "weights" }) );
  set_weight( 200 );
  reset_get();
  doing = ({ });
  pans = DEFAULT_PANS;
}
void init() {
  add_command("weigh", "<indirect:object:me'thing(s)'> on <direct:object>",
    (:this_object()->weigh_something($1):));
  add_command("reset", "weights on balance", (: reset_weights() :));
  add_command("figure", "", (:this_object()->figure_it_out():));
  add_command("move",
          "<string'size'> weight to <string'position'> pan",
          (:this_object()->move_a_specific_weight($4[0], $4[1]):));
}
string *query_doing() { return doing; }
mapping query_pans() { return pans; }
string long( string words, int dark ) {
  int i, j;
  string long;
  string *bits;
  string *places;
  string *weights;
  if (!words) {
    words = "balance";
  }
  bits = explode( words, " " );
  switch ( bits[ sizeof( bits ) - 1 ] ) {
    case "balance" :
      return "This is a largish bronze balance, securely bolted in "
        "place.  The main part of the balance is a long arm which "
        "pivots at its centre.  There is a pan hanging from each "
        "end of the arm such that it will be level when the weights "
        "in the pans are equal.  A third pan is fixed to a stationary "
        "part of the balance where the weights can be held when not "
        "in use.\n" + pans_look() + "You could probably use the balance "
        "to weigh something.\nThere appears to be something "
        "written on it.\n";
    case "pan" :
    case "pans" :
      return "There are three pans.  One pan hangs from the left end of "
        "the arm, one from the right end and there is a third pan "
        "in the middle.\n"+ pans_look();
    case "weight" :
    case "weights" :
      long = "There are weights of many different sizes in the pans.  "
        "They are:\n";
      bits = ({ });
      places = m_indices( pans );
      for ( i = 0; i < sizeof( places ); i++ ) {
        if ( !m_sizeof( pans[ places[ i ] ] ) ) {
          continue;
        }
        weights = m_indices( pans[ places[ i ] ] );
        for ( j = 0; j < sizeof( weights ); j++ ) {
          if ( sizeof( doing ) ) {
            if ( doing[ 1 ] == weights[ j ] ) {
              continue;
            }
          }
          bits += ({ add_a( weights[ j ] ) + " weight marked with \""
            + pans[ places[ i ] ][ weights[ j ] ][ 0 ] +" lb\"" });
        }
      }
      long += "    " + implode( bits[ 0 .. sizeof( bits ) - 2 ],
        ",\n    " ) +",\n  and "+ bits[ sizeof( bits ) - 1 ] + ".\n";
      long += "The weights can be moved from one pan to another and "
        "reset back to their starting positions.\n";
      return long;
  }
  return "You're not quite sure what you're looking at.\n";
}
string pans_look() {
  int i;
  int j;
  string pans_status;
  string *places;
  string *weights;
  pans_status = "";
  places = m_indices( pans );
  for ( i = 0; i < sizeof( places ); i++ ) {
    pans_status += "The "+ places[ i ] +" pan ";
    if ( !m_sizeof( pans[ places[ i ] ] ) )
      pans_status += "is empty.\n";
    else {
      weights = m_indices( pans[ places[ i ] ] );
      for ( j = 0; j < sizeof( weights ); j++ )
        weights[ j ] = add_a( weights[ j ] ) +" weight";
      pans_status += "holds "+ query_multiple_short( weights ) +".\n";
    }
  }
  switch ( balance ) {
    case -1 :
      pans_status += "The left pan hangs lower than the right pan.\n";
      break;
    case 0 :
      pans_status += "The left pan hangs level with the right pan.\n";
      break;
    case 1 :
      pans_status += "The left pan hangs higher than the right pan.\n";
      break;
  }
  return pans_status;
}
void recalculate_balance() {
  int i;
  int j;
  int old_balance;
  string *places;
  string *weights;
  mapping pan_weights;
  pan_weights = ([ ]);
  places = m_indices( pans );
  for ( i = 0; i < sizeof( places ); i++ ) {
    pan_weights[ places[ i ] ] = 0;
    if ( !m_sizeof( pans[ places[ i ] ] ) ) {
      continue;
    }
    weights = m_indices( pans[ places[ i ] ] );
    for ( j = 0; j < sizeof( weights ); j++ ) {
      pan_weights[ places[ i ] ] +=
        pans[ places[ i ] ][ weights[ j ] ][ 1 ];
    }
  }
  old_balance = balance;
  if ( pan_weights[ "left" ] > pan_weights[ "right" ] ) {
    balance = -1;
  } else {
    if ( pan_weights[ "left" ] == pan_weights[ "right" ] ) {
      balance = 0;
    } else {
      balance = 1;
    }
  }
  if ( old_balance == balance ) {
    switch ( balance ) {
      case -1 :
        tell_room( environment(), "The arm rocks a bit but steadies, "
          "with the left pan still hanging lowest.\n" );
        break;
      case 1 :
        tell_room( environment(), "The arm rocks a bit but steadies, "
          "with the right pan still hanging lowest.\n" );
        break;
    }
    return;
  }
  switch ( balance ) {
    case -1 :
      tell_room( environment(), "The arm of the balance tips and the "
        "left pan ends up hanging lowest.\n" );
      break;
    case 0 :
      tell_room( environment(), "The arm of the balance levels out, "
        "with the left and right pans hanging level.\n" );
      break;
    case 1 :
      tell_room( environment(), "The arm of the balance tips and the "
        "right pan ends up hanging lowest.\n" );
      break;
  }
}
int reset_weights() {
  pans = DEFAULT_PANS;
  if (sizeof(doing)) {
    pans[ "left" ][ doing[ 1 ] ] = ({ "?", 1 + random( 121 ) });
  }
  add_succeeded_mess("$N $V the weights on $D.\n");
  recalculate_balance();
  return 1;
}
string weight_string( int weight ) {
  int wholes;
  int ninths;
  wholes = weight / 9;
  ninths = weight % 9;
  if ( wholes && ninths ) {
    return wholes + " " + ninths + "/9 lb";
  }
  if ( wholes ) {
    return wholes + " lb";
  }
  return ninths + "/9 lb";
}
int weigh_something( object* obs ) {
  int i;
  int info;
  int weight;
  object person;
  if ( sizeof( doing ) ) {
    person = find_player( doing[ 0 ] );
    if ( person == this_player() ) {
      add_failed_mess( "Hold your horses, you're trying to get the hang "
        "of it still.\n" );
      return 0;
    }
    if ( person && ( environment( person ) == environment() ) ) {
      add_failed_mess( (string)person->one_short() + " is using "
        "the balance at the moment.  Come back when "
        + (string)person->query_pronoun() + " has finished.\n" );
      return 0;
    }
    doing = ({ });
    pans = DEFAULT_PANS;
  }
  info = (int)LIBRARY->query_player_quest_info(
    (string)this_player()->query_name(), "balance" );
  switch ( info ) {
    case 0 :
      add_failed_mess( "You don't know how the balance works to weigh "
        "anything.\nTry looking at the balance, the pans and "
        "the weights, and then maybe you can figure it out.\n" );
      return 0;
    case 1 :
      add_failed_mess( "You're still not too sure how the balance works "
        "to weigh anything.\nTry looking at the balance, the pans and "
        "the weights, and then maybe you can figure it out.\n" );
      return 0;
    case 2 :
      add_failed_mess( "You're very nearly sure how the balance works, "
        "but maybe you should try to figure it out once more before "
        "you weigh anything.\n" );
      return 0;
  }
  for ( i = 0; i < sizeof( obs ); i++ ) {
    weight = obs[ i ]->query_complete_weight();
    if ( !weight ) {
      write( obs[ i ]->the_short() + " doesn't weigh anything.\n" );
      continue;
    }
    if ( weight > 121 ) {
      write( obs[ i ]->the_short() +
        " is heavier than all the weights available put together.\n" );
      continue;
    }
    write( obs[ i ]->the_short() +
      " weighs "+ weight_string( weight ) +".\n" );
  }
  add_succeeded_mess(({ "", "$N $V $I on $D.\n" }), obs);
  return 1;
}
int figure_it_out() {
  int info;
  object person;
  if ( sizeof( doing ) ) {
    person = find_player( doing[ 0 ] );
    if ( person == this_player() ) {
      notify_fail( "You're already engaged in figuring out how the "
        "balance can be used to weigh something.\n" );
      return 0;
    }
    if ( person && ( environment( person ) == environment() ) ) {
      notify_fail( (string)person->one_short() + " is using "
        "the balance at the moment.  Come back when "
        + (string)person->query_pronoun() + " has finished.\n" );
      return 0;
    }
    doing = ({ });
    pans = DEFAULT_PANS;
  }
  info = (int)LIBRARY->query_player_quest_info(
    (string)this_player()->query_name(), "balance" );
  if ( info > 2 ) {
    write( "You already know how the balance works.\n" );
    return 1;
  }
  doing = ({ (string)this_player()->query_name(), ({ "red", "green",
    "blue" })[ info ] });
  write( "You see " + add_a( doing[ 1 ] ) + " weight in the middle pan "
    "that you hadn't noticed before.  Maybe you could use this to "
    "experiment, so you place it in the left pan.\n" );
  say( (string)this_player()->one_short() + " moves "
    + add_a( doing[ 1 ] ) + " weight from the middle pan to the "
    "left pan.\n" );
  pans[ "left" ][ doing[ 1 ] ] = ({ "?", 1 + random( 121 ) });
  recalculate_balance();
  return 1;
}
int move_a_specific_weight( string weight_size, string pan_to ) {
  object person;
  string pan_from;
  if ( sizeof( doing ) ) {
    person = find_player( doing[ 0 ] );
    if ( !person ) {
      doing = ({ });
    } else {
      if ( person != this_player() ) {
        if ( environment( person ) == environment() ) {
          add_failed_mess( (string)person->one_short() + " is "
            "using the balance at the moment.  Come back when "
            + (string)person->query_pronoun() + " has finished.\n" );
          return 0;
        } else {
          doing = ({ });
          pans = DEFAULT_PANS;
        }
      }
    }
  }
  if ( !pans[ pan_to ] ) {
    add_failed_mess( "There is a left pan, a middle pan and a right pan, "
      "but no " + pan_to + " pan.\n" );
    return 0;
  }
  foreach (pan_from in keys(pans)) {
    if ( pans[ pan_from ][ weight_size ] ) {
      return move_a_weight(weight_size, pan_from, pan_to);
    }
  }
  add_failed_mess("Unable to find the " + weight_size + " weight.\n");
  return 0;
}
int move_a_weight( string weight_size, string pan_from, string pan_to ) {
  if ( pan_from == pan_to ) {
    add_failed_mess( "The " + weight_size + " weight is already in the "
      + pan_to + " pan.\n" );
    return 0;
  }
  if ( sizeof( doing ) ) {
    if ( weight_size == doing[ 1 ] ) {
      notify_fail( "You don't feel like moving the " + doing[ 1 ]
        + " weight since that's what you're trying to weigh.\n" );
      return 0;
    }
  }
  pans[ pan_to ][ weight_size ] = pans[ pan_from ][ weight_size ];
  pans[ pan_from ] = m_delete( pans[ pan_from ], weight_size );
  write( "You move the "+ weight_size +" weight from the "+ pan_from
    + " pan to the "+ pan_to + " pan.\n" );
  say( (string)this_player()->one_short() + " moves "
    + add_a( weight_size ) +" weight from the "+ pan_from + " pan "
    "of the balance to the " + pan_to + " pan.\n" );
  recalculate_balance();
  if ( sizeof( doing ) && !balance ) {
    call_out( "it_is_balanced", 0, this_player() );
  }
  return 1;
}
void it_is_balanced( object person ) {
  int info;
  tell_object( person, "You feel a small surge of self-esteem to have found "
    "that the "+ doing[ 1 ] +" weight weighs "
    + weight_string( pans[ "left" ][ doing[ 1 ] ][ 1 ] ) +".\n" );
  info = (int)LIBRARY->query_player_quest_info( (string)person->query_name(),
    "balance" );
  info++;
  switch ( info ) {
    case 1 :
      tell_object( person, "You've made a good start at working out "
        "how the balance operates.  You think you should practice "
        "with it a couple of times more to get the hang of it, "
        "though.\n" );
      person->adjust_xp( 5000 );
      break;
    case 2 :
      tell_object( person, "You're definitely getting to understand how "
        "the balance operates.  You think you should practice with "
        "it once more to get used to it completely, though.\n" );
      person->adjust_xp( 10000 );
      break;
    case 3 :
      tell_object( person, "You're now adept at using the balance and "
        "can use it to weigh anything.\n" );
      if ( interactive( person ) ) {
        if ( !LIBRARY->query_quest_done( (string)person->query_name(),
          "balance quest" ) ) {
          LIBRARY->set_quest( (string)person->query_name(),
            "balance quest" );
        }
      }
      break;
    case 4:
      info--;
      break;
    default :
      tell_object( person, "Something has gone wrong with the balance.  "
        "Please contact Wodan about it.\n" );
  }
  LIBRARY->set_player_quest_info( (string)person->query_name(), "balance",
    info );
  tell_object( person, "You put all the weights back into the middle "
    "pan.\n" );
  tell_room( environment(), (string)person->the_short() +
     " seems satisfied with "+ (string)person->query_objective() +"self, "
    "and returns all of the weights to the middle pan.\n", person );
  doing = ({ });
  pans = DEFAULT_PANS;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/delete_thyself.c ===
inherit "/std/object";
void create() {
   ::create();
   if (clonep(this_object())) {
      call_out((: move("/room/rubbish") :), 3);
   }
}
void init_dynamic_arg(mapping map) {
}
void init_static_arg() {
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/label.c ===
inherit "/std/object";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_name( "label" );
   set_short( "small label" );
   add_adjective( "small" );
   set_main_plural( "small labels" );
   set_long( "This is a small label made from paper with some sort of "+
         "dried glue smeared on one side.  You could probably \"stick\" "+
         "it onto something.\n" );
   set_value( 100 );
   add_property( "writeable", 1 );
   add_property( "label", 1 );
   set_max_size( 200 );
   if ( !do_setup )
      this_object()->setup();
}
void init() {
   this_player()->add_command( "stick", this_object(),
         "<direct:object:me> to <indirect:object>" );
}
int do_stick( mixed *things ) {
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can't stick $D to more than one thing at a time.\n");
      return 0;
   }
   if ( things[ 0 ] == this_object() ) {
      add_failed_mess("You cannott stick $D to itself!\n");
      return 0;
   }
   things[ 0 ]->add_effect( "/std/effects/object/label", this_object() );
   add_succeeded_mess("$N lick$s $D and stick$s it to $I.\n", things[0..0]);
   return 1;
}
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/misc/label" ) {
      return ([ ]);
   }
   return int_query_static_auto_load();
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/deplusser.c ===
inherit "/std/object.c";
void setup()  {
   set_short("deplusser");
   set_name("deplusser");
   set_long("It's shaped like a plus sign set in a circle, with a diagonal "
             "slash across it.  Type 'deplus <path>' to use.");
   set_weight(9);
}
void init()  {
   add_command("deplus", "<string'file'>", (:this_object()->deplus($4[0]):));
}
int deplus( string fname )  {
   string *files, *lines, last_line, this_line, next_line, old;
   int i, j, sz;
   seteuid(geteuid(this_player()));
   files = get_dir( this_player()->get_path( fname ) );
   if ( !sizeof(files) )
      return notify_fail( "No files found\n" );
   for (i = 0; i < sizeof(files); i++ )  {
      if ( file_size( this_player()->get_path( files[i] ) ) == -2 )  continue;
      old = read_file( this_player()->get_path( files[i] ) );
      lines = explode( replace_string( old, "\t", "   " ), "\n" );
      if ( ( sz = sizeof( lines ) ) < 2 )  continue;
      last_line = implode( explode( lines[0], " " ), "" );
      this_line = implode( explode( lines[1], " " ), "" );
      if ( sz > 2 )
         next_line = implode( explode( lines[2], " " ), "" );
      else next_line = "";
      for (j = 1, sz = sizeof(lines); j < sz - 1; j++ )  {
         if ( last_line[<2 .. <1] == "\"+"  &&
             strlen( this_line )  &&  this_line[0] == '\"' )
            lines[j-1] = lines[j-1][0 .. strsrch(lines[j-1], "+", -1) - 1];
         else if ( this_line[0 .. 1] == "+\""  &&
                   strlen(last_line)  && last_line[<1] == '\"' )
            lines[j] = " " + delete( lines[j], strsrch(lines[j], "+"), 1 );
         last_line = this_line;
         this_line = next_line;
         if ( j < sz - 2 )
            next_line = implode( explode( lines[j+2], " " ), "" );
      }
      if ( !rm( this_player()->get_path(files[i]) ) )
         write("Couldn't remove old file: " + files[i] + "\n" );
      else if ( !write_file(this_player()->get_path(files[i]),
                            implode(lines, "\n" ) + "\n" ) )  {
         write("Could not write new file: " + files[i] + "\n" );
         if ( !write_file(this_player()->get_path(files[i]), old ) )
            return notify_fail("Uh-oh, could not replace old file either.\n");
      }
      else write("File deplussed: " + files[i] + "\n");
   }
   return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/misc/button.c ===
inherit "std/object";
void setup() {
   set_name( "button" );
   set_short( "red button" );
   add_adjective( "red" );
   set_long( "This red button destructs all non-user objects in "
         "the room.  USE WITH EXTREME CAUTION.\n");
   reset_get();
   add_property( "there", "embedded into the wall" );
}
void init() {
   this_player()->add_command( "press" , this_object() );
}
int do_press() {
   object thing, *things;
   things = (object *)environment()->query_non_destable();
   if ( !things )
      things = ({ this_object() });
   else
      things += ({ this_object() });
   foreach ( thing in all_inventory( environment() ) - things )
      if ( !userp( thing ) )
         thing->dest_me();
   write( "You clean up.\n" );
   say( (string)this_player()->one_short() +" cleans up.\n" );
   return 1;
}
