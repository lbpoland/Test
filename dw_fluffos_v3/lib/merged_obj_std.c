
==================================================
FILE: armour_logic.c
==================================================

#include "weapon_old.h"
nosave mapping ac;
nosave mixed armour_types;
void create() {
  ac = ([ ]);
  armour_types = ({ });
}
int add_ac(string name, string type, mixed a_c) {
  int i;
  if (!stringp(type))
    return 0;
  if (!ac) ac = ([ ]);
  if (ac[name])
    return 0;
  ac[name] = ({ a_c, type });
  if ((i=member_array(type, armour_types)) == -1)
    armour_types += ({ type, ({ name }) });
  else
    armour_types[i+1] += ({ name });
  return 1;
}
int remove_ac(string name) {
  int j, k;
  if (!ac[name])
    return 0;
  j = member_array(ac[name][1], armour_types);
  k = member_array(name, armour_types[j+1]);
  armour_types[j+1] = delete(armour_types[j+1], k, 1);
  if (!sizeof(armour_types[j+1]))
    armour_types = delete(armour_types, j, 2);
  map_delete(ac, name);
  return 1;
}
int calc_value(mixed arr) {
  int i, val;
  if (intp(arr)) {
    if(!random(10))
      return random(arr);
    else
      return arr;
  }
  if (!pointerp(arr))
    return 0;
  if (sizeof(arr) == 1)
    return arr[F_FIXED];
  if (sizeof(arr) == 2)
    return arr[F_FIXED]+random(arr[F_RAND]);
  for (i=0;i<arr[F_NUM];i++)
    val += random(arr[F_DIE]);
  return val + arr[F_FIXED];
}
varargs int query_ac( string type, int dam, string zone ) {
  int val, i, j;
  if ( !armour_types )
    return 0;
  if ((i=member_array(type, armour_types)) != -1) {
    for ( j = 0; j < sizeof( armour_types[ i + 1 ] ); j++ )
      if ( ac[ armour_types[ i + 1 ][ j ]])
        if ( sizeof( ac[ armour_types[ i + 1 ][ j ] ] ) == A_ARRAY_SIZE )
          val += calc_value( ac[ armour_types[ i + 1 ][ j ] ][ A_AC ] );
  }
  val -= (val / 4);
  return val;
}
mapping query_armour_class() { return ac; }
string calc_string(mixed b) {
  if (intp(b))
    return "rand("+b+")";
  if (!pointerp(b))
    return "Dead";
  switch (sizeof(b)) {
    case 1 :
      return ""+b[0];
    case 2 :
      return ""+b[0]+"+rand("+b[1]+")";
    case 3 :
      return ""+b[0]+"+"+b[1]+"d"+b[2];
    default :
      return "Oh hell";
  }
}
mixed *stats() {
  int i;
  mixed *ret;
  mixed *stuff;
  ret = ({ });
  stuff = keys(ac);
  for (i=0;i<sizeof(stuff);i++)
    ret += ({ ({ "ARM"+ i +" name", stuff[ i ], }),
              ({ "     type", ac[stuff[i]][A_TYPE], }),
              ({ "    class", calc_string(ac[stuff[i]][A_AC]) }),
          });
  return ret;
}
void set_ac(mixed *bing) {
  int i;
  for (i=0;i<sizeof(ac);i+=A_ARRAY_SIZE)
    add_ac(ac[i], ac[i+1][A_TYPE], ac[i+1][A_AC]);
}

==================================================
FILE: bit.c
==================================================

#include <bit.h>
#include <corpse.h>
inherit "std/object";
#define DECAY_TIME 60
mixed *bit_data, *bits;
mixed race_ob;
int corpse_weight;
string race_name, *bits_gone = ({ });
int decay, cured;
void set_bits();
object make_bit(string which_bit);
object *make_bits(string *what_bits);
string *query_bits_left();
string *query_possible_bits(string);
void create() {
  ::create();
  set_short("anonymous bit");
  set_long("This is an unknown bit of some creature.\n");
  corpse_weight = STD_CORPSE_WEIGHT;
  set_weight(5);
  set_name("bit");
  add_property( "corpse bit", 1 );
  add_property("cureable", 1);
}
void init() {
  add_command("eat", "<direct:object>");
}
int query_edible() {
  string bit;
  if(!race_ob->query_eat(bit_data[BIT_NAME])) {
    return 0;
  }
  foreach(bit in query_possible_bits(0) - bits_gone) {
    if(!race_ob->query_eat(bit)) {
      return 0;
    }
  }
  return 1;
}
int do_eat() {
  if(!query_edible())
    return 0;
  move( "/room/rubbish" );
  return 1;
}
int no_decay() {
  if( race_ob && bit_data ) {
    return race_ob->query_unrottable(bit_data[BIT_NAME]);
  }
}
void set_race_ob(object s) {
  race_ob = s;
}
void set_race_name(string s) {
  race_name = s;
}
void setup_long() {
  if ( !bit_data ) {
    return;
  }
  if (no_decay()) {
    if (race_name) {
      set_short( race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( race_name +" "+ pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is the " + (bit_data[BIT_NAME]) + " of " +
      add_a(race_name) + ".\n");
    } else {
      set_short( bit_data[ BIT_NAME ] );
      set_main_plural( pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is the " + (bit_data[BIT_NAME]) +
               " of an unknown creature.\n");
    }
  } else if (decay > 80) {
    if (race_name) {
      set_short( race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( race_name +" "+ pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is a fresh " + (bit_data[BIT_NAME]) +
               " severed from the corpse of " + add_a(race_name) + ".\n");
    } else {      set_short( bit_data[ BIT_NAME ] );
      set_main_plural( pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is a fresh " + (bit_data[BIT_NAME]) +
               " severed from the corpse of an unknown creature.\n");
    }
  } else if (decay > 50) {
    if (race_name) {
      set_short( race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( race_name +" "+ pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is " + add_a(bit_data[BIT_NAME]) + " severed from the "
               "corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( bit_data[ BIT_NAME ] );
      set_main_plural( pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is " + add_a(bit_data[BIT_NAME]) + " severed from the "
               "corpse of an unknown creature.\n");
    }
  } else if (decay > 30) {
    if (race_name) {
      set_short( race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( race_name +" "+ pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is the partially decayed remains of " +
               add_a(bit_data[BIT_NAME]) + " severed from the "
               "corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( bit_data[ BIT_NAME ] );
      set_main_plural( pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is the partially decayed remains of " +
      add_a(bit_data[BIT_NAME]) + " severed from the "
      "corpse of an unknown creature.\n");
    }
  } else {
    if (race_name) {
      set_short( race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( race_name +" "+ pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is the almost unrecognizable remains of " +
               add_a(bit_data[BIT_NAME]) + " severed from the "
               "corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( bit_data[ BIT_NAME ] );
      set_main_plural( pluralize( bit_data[ BIT_NAME ] ) );
      set_long("This is the almost unrecognizable remains of " +
               add_a(bit_data[BIT_NAME]) + " severed from the " +
               "corpse of an unknown creature.\n");
    }
  }
  add_extra_look(this_object());
  if ( cured ) {
    set_long( query_long() +"It seems to have been pickled.\n" );
  }
}
string extra_look() {
  if(sizeof(bits_gone))
    return "It appears to be missing the " + query_multiple_short(bits_gone) + ".\n";
  return "";
}
void set_corpse_weight(int i) { corpse_weight = i; }
void set_bit(string s, int dec) {
  int temp;
  bit_data = (mixed *)race_ob->query_bit(s);
  if (!bit_data || !sizeof(bit_data)) {
    return;
  }
  if (race_name) {
    add_adjective(race_name);
  } else {
    add_adjective("unknown");
  }
  add_adjective( explode( s, " " ) );
  if ( pointerp( bit_data[ BIT_EXTRA ][ EXTRA_VALUE ] ) &&
       ( sizeof( bit_data[ BIT_EXTRA ][ EXTRA_VALUE ] ) > 3 ) ) {
    set_value(bit_data[BIT_EXTRA][EXTRA_VALUE][3]);
  }
  add_alias( bit_data[ BIT_NAME ] );
  add_plural( pluralize( bit_data[ BIT_NAME ] ) );
  if ( bit_data[ BIT_ALIAS ] && strlen( bit_data[ BIT_ALIAS ] ) ) {
    add_alias(bit_data[BIT_ALIAS]);
    add_plural( pluralize( bit_data[ BIT_ALIAS ] ) );
  }
  if ((temp=bit_data[BIT_EXTRA][EXTRA_WEIGHT] * corpse_weight
             / STD_CORPSE_WEIGHT) > 0) {
    set_weight(temp);
  } else {
    set_weight(1);
  }
  if(dec) {
    decay = dec;
  } else {
    decay = 100;
  }
  if (!no_decay()) {
      BIT_CONTROLLER->add_bit(this_object());
  }
  setup_long();
  set_bits();
  return;
}
int do_decay() {
  int rate;
  if (!environment()) {
    move( "/room/rubbish" );
    return 0;
  }
  rate = 5 + (int)environment()->query_property( "decay rate" );
  if ( rate > 0 ) {
    decay -= rate;
  }
  if (decay < 0) {
    tell_object(environment(),
                capitalize(the_short()) + " decays to dust.\n");
    move( "/room/rubbish" );
    return 0;
  }
  if (decay == 80 || decay == 50 || decay == 30) {
    setup_long();
  }
  return 1;
}
object query_race_ob() { return race_ob; }
string query_race_name() { return race_name; }
mixed query_bit_data() { return bit_data; }
int query_decay() { return decay; }
void dest_me() {
  BIT_CONTROLLER->remove_bit(this_object());
  ::dest_me();
}
mixed query_static_auto_load() {
  return int_query_static_auto_load();
}
mixed query_dynamic_auto_load() {
  return ({ bit_data, race_ob, corpse_weight, race_name,
              decay, cured, bits_gone, ::query_dynamic_auto_load() });
}
void init_dynamic_arg(mixed arg, object) {
  if (mapp(arg)) {
    ::init_dynamic_arg(arg);
    return ;
  }
  bit_data = arg[0];
  race_ob = arg[1];
  corpse_weight = arg[2];
  race_name = arg[3];
  decay = arg[4];
  cured = arg[5];
  bits_gone = arg[6];
  ::init_dynamic_arg(arg[7]);
  if ((!cured) && (!no_decay())) {
    BIT_CONTROLLER->add_bit(this_object());
  }
  setup_long();
  if(sizeof(bit_data))
    set_bits();
}
void do_cure() {
  if ( cured ) {
    return;
  }
  cured = 1;
  BIT_CONTROLLER->remove_bit( this_object() );
  set_long( query_long() +"It seems to have been pickled.\n" );
  set_short( "cured " + query_short());
  set_main_plural( "cured " + query_main_plural() );
  add_adjective("cured");
}
int query_cured() { return cured; }
int *query_vect() { return bit_data[BIT_EXTRA][EXTRA_VALUE]; }
string *query_possible_bits( string word ) {
  int i, j;
  string *possibles;
  possibles = ({ });
  for ( i = sizeof( bits ) - 3; i > -1; i -= 3 ) {
    if ( ( bits[ i ] == word ) ||
         ( bits[ i + 1 ] == word ) ||
         !word) {
      if (arrayp( bits[i+2][2] )) {
        for ( j = 0; j < bits[ i + 2][2][1]; j++ ) {
          possibles += ({ bits[ i ] });
        }
      } else {
        possibles += ({ bits[ i ] });
      }
    }
  }
  return possibles;
}
string *query_possible_plural_bits( string word ) {
  int i, j;
  string *possibles;
  possibles = ({ });
  for ( i = sizeof( bits ) - 3; i > -1; i -= 3 ) {
    if (((bits[i] && pluralize(bits[ i ]) == word )) ||
        ((bits[i+1] && pluralize(bits[ i + 1 ]) == word )) ||
        !word) {
      if (arrayp( bits[i+2][2] )) {
        for ( j = 0; j < bits[ i + 2][2][1]; j++ ) {
          possibles += ({ bits[ i ] });
        }
      } else {
        possibles += ({ bits[ i ] });
      }
    }
  }
  return possibles;
}
string query_bit_left(string s) {
  string *poss_bits;
  poss_bits = query_possible_bits(s);
  if (!poss_bits || !sizeof(poss_bits)) {
     return 0;
  }
  poss_bits = poss_bits - bits_gone;
  if (!sizeof(poss_bits)) {
    return 0;
  }
  return poss_bits[0];
}
string *query_bit_left_pl(string s) {
  string *poss_bits;
  poss_bits = query_possible_plural_bits(s);
  if (!poss_bits || !sizeof(poss_bits)) {
    return 0;
  }
  poss_bits = poss_bits - bits_gone;
  if (!sizeof(poss_bits)) {
    return 0;
  }
  return poss_bits;
}
object *find_inv_match( string s, object looker ) {
  string bit, *bit_pl;
  object *weap, wep, tmp;
  int cut;
  bit = query_bit_left(s);
  bit_pl = query_bit_left_pl(s);
  if (!bit && !sizeof(bit_pl))
    return all_inventory();
  cut = 0;
  if(looker)
    weap = (object *)looker->query_weapons();
  if (sizeof(weap)) {
    foreach( wep in weap ) {
      if (wep->id("dagger") || wep->id("knife"))
        cut = 1;
    }
  }
  if (bit) {
    if (cut || (string)race_ob->query_pluckable(bit)) {
      tmp = make_bit(bit);
      return ({ tmp  });
    }
    if (sizeof(weap)) {
      tell_object( looker, "You can only cut things from "+a_short()+
                           " with a knife or dagger.\n" );
    } else {
      tell_object( looker, "You can't cut bits from "+a_short()+" with your "
                           "bare hands.\n" );
    }
    return ({ });
  }
  if (sizeof(bit_pl)) {
    if (cut) {
      if (sizeof(bit_pl) > 5) {
        return make_bits(bit_pl[0..4]);
      } else {
        return make_bits(bit_pl);
      }
    }
    foreach( bit in bit_pl ) {
      if (!((string)race_ob->query_pluckable(bit)))
        bit_pl -= ({ bit });
    }
    if (sizeof(bit_pl)) {
      if (sizeof(bit_pl) > 5) {
        return make_bits(bit_pl[0..4]);
      } else {
        return make_bits(bit_pl);
      }
    }
    if (sizeof(weap)) {
      tell_object( looker, "You can only cut things from "+a_short()+
                           " with a knife or dagger.\n" );
    } else {
      tell_object( looker, "You can't cut bits from "+a_short()+" with your "
                           "bare hands.\n" );
    }
    return ({ });
  }
}
object make_bit(string which_bit) {
  mixed *bit;
  object bitobj;
  int i,j;
  bit = race_ob->query_bit(which_bit);
  if ((sizeof(bit[2][2]) > 1) && stringp(bit[2][2][1])) {
    bitobj = clone_object( bit[2][2] );
  } else if (bit[2][2] == 0) {
    bitobj = clone_object("/std/bit");
  } else {
    bitobj = clone_object("/std/bit");
  }
  bitobj->set_race_ob(race_ob);
  if (race_name) bitobj->set_race_name(race_name);
  else bitobj->set_race_name(race_ob->query_name());
  bitobj->set_corpse_weight(query_weight());
  if(!race_ob->query_eat(bit[BIT_NAME])) {
    bitobj->set_bit(bit[0], 0);
  } else {
    bitobj->set_bit(bit[0], (decay * 2) / 3);
  }
  for (i = 0; i < sizeof(bits_gone); i++) {
    j = member_array(bits_gone[i], bit[BIT_EXTRA]);
    if (j >= 0) {
      bitobj->add_bit_gone(bits_gone[i]);
    }
  }
  bits_gone += ({ bit[BIT_NAME] }) + bit[BIT_EXTRA][3..50];
  if (environment()) {
    bitobj->move(environment());
  }
  return bitobj;
}
object *make_bits(string *what_bits) {
  string bit;
  object *bit_pl = ({ });
  foreach(bit in what_bits) {
    bit_pl += ({ make_bit(bit) });
  }
  return bit_pl;
}
string *query_bits_gone() { return bits_gone; }
mixed *add_bit_gone( string bit ) {
  string *poss_bits, tempbit;
  mixed *bit_details;
  int i;
  poss_bits = query_possible_bits( bit ) - bits_gone;
  if ( !sizeof( poss_bits ) ) return 0;
  bit_details = (mixed *)race_ob->query_bit( poss_bits[ 0 ] );
  bits_gone += ({ bit_details[ BIT_NAME ] });
  foreach (tempbit in bit_details[ BIT_EXTRA ][ 3 .. sizeof(bit_details[BIT_EXTRA]) ]) {
    if (arrayp(race_ob->query_bit( tempbit )[2][2]) && intp(race_ob->query_bit( tempbit )[2][2][1])) {
      for (i = 0; i < race_ob->query_bit( tempbit )[2][2][1]; i++) {
        bits_gone += ({ tempbit });
      }
    }
  }
  return bit_details;
}
void set_bits_gone( string *bits ) {
  int i;
  bits_gone = ({ });
  for ( i = 0; i < sizeof( bits ); i++ ) {
    add_bit_gone( bits[ i ] );
  }
}
string *query_bits_left() {
  int i, j;
  string *all_bits;
  mixed *bit_pl;
  bit_pl = (mixed *)race_ob->query_bits();
  all_bits = ({ });
  for ( i = 0; i < sizeof( bit_pl ); i += 3 ) {
    if (arrayp( bit_pl[i+2][2] )) {
      for ( j = 0; j < bit_pl[ i + 2][2][1]; j++ ) {
        all_bits += ({ bit_pl[ i ] });
      }
    } else {
      all_bits += ({ bit_pl[ i ] });
    }
  }
  return all_bits - bits_gone;
}
void set_bits() {
  int i, j;
  mixed *these_bits, *all_bits;
  bits = ({ });
  these_bits = bit_data;
  all_bits = race_ob->query_bits();
  for (i=3; i<sizeof(these_bits[2]); i++) {
    for (j=0; j<sizeof(all_bits); j = j+3) {
      if ((these_bits[0] == all_bits[j+2][0]) && (these_bits[2][i] == all_bits[j])) {
        bits += all_bits[j..j+2];
        delete(all_bits, j, 2);
        break;
      }
    }
  }
}
string query_determinate(object caller)  {
   return race_ob->query_determinate(caller);
}
string query_medium_alias() {
  string temp;
  string *temp2 = ({ });
    if ( !sizeof( bit_data ) )
        return "";
    temp = bit_data[0];
    temp2 = explode( temp, " " );
    temp2 = map( temp2, (: capitalize( $1 ) :) );
    temp = implode( temp2, "" );
    return temp + "Of" + capitalize( race_ob->query_name() ) ;
}
int query_collective() {
  if(query_verb() == "get" || query_verb() == "take")
    return 1;
}

==================================================
FILE: bit_set.c
==================================================

#include "corpse.h"
inherit "std/bit";
#include <bit.h>
void create() {
  ::create();
  set_short("anonymous set of bits");
  set_long("This is an unknown set of bits of some creature.\n");
  corpse_weight = STD_CORPSE_WEIGHT;
  set_weight(5);
  set_name("bit");
  add_property( "corpse bit", 1 );
  add_property("cureable", 1);
}
void setup_long() {
  if ( !bit_data )
    return;
  if (no_decay()) {
    if (race_name) {
      set_short( "set of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_long("This is a set of " + (bit_data[BIT_NAME]) +
               " from " + add_a(race_name) + ".\n");
    } else {
      set_short( "set of "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ bit_data[ BIT_NAME ] );
      set_long("This is a set of " + (bit_data[BIT_NAME]) +
               " from an unknown creature.\n");
    }
  } else if (decay > 80) {
    if (race_name) {
      set_short( "set of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_long("This is a fresh set of " + (bit_data[BIT_NAME]) +
               " severed from the corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( "set of "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ bit_data[ BIT_NAME ] );
      set_long("This is a fresh set of " + (bit_data[BIT_NAME]) +
               " severed from the corpse of an unknown creature.\n");
    }
  } else if (decay > 50) {
    if (race_name) {
      set_short( "set of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_long("This is a set of " + bit_data[BIT_NAME] + " severed from the " +
               "corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( "set of "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ bit_data[ BIT_NAME ] );
      set_long("This is a set of " + bit_data[BIT_NAME] + " severed from the " +
               "corpse of an unknown creature.\n");
    }
  } else if (decay > 30) {
    if (race_name) {
      set_short( "set of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_long("This is the partially decayed remains of a set of " +
               bit_data[BIT_NAME] +" severed from the "
               "corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( "set of "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ bit_data[ BIT_NAME ] );
      set_long("This is the partially decayed remains of a set of " +
               bit_data[BIT_NAME] + " severed from the " +
               "corpse of an unknown creature.\n");
    }
  } else {
    if (race_name) {
      set_short( "set of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ race_name +" "+ bit_data[ BIT_NAME ] );
      set_long("This is the almost unrecognizable remains of a set of " +
         bit_data[BIT_NAME] +" severed from the "
         "corpse of " + add_a(race_name) + ".\n");
    } else {
      set_short( "set of "+ bit_data[ BIT_NAME ] );
      set_main_plural( "sets of "+ bit_data[ BIT_NAME ] );
      set_long("This is the almost unrecognizable remains of a set of " +
         bit_data[BIT_NAME] + " severed from the " +
         "corpse of an unknown creature.\n");
    }
  }
  if ( cured )
    set_long( query_long() +"It seems to have been pickled.\n" );
}

==================================================
FILE: book.c
==================================================

inherit "/std/object";
#include <move_failures.h>
#include <player.h>
private mixed *_pages;
private string _default_page_object;
private object _def_p_obj;
private int _open_page;
private int _book_num;
private int _ignore_open_page;
private int _ignore_saved_pages;
private nosave object _player;
private nosave int _num_torn_out = -1;
protected int do_open(int page);
protected int do_tear(int number);
protected int do_turn(int number);
protected int do_close();
object create_default_page_object();
void create() {
  _pages = ({ });
  _default_page_object = "/obj/misc/paper";
  load_object(_default_page_object);
  _def_p_obj = find_object(_default_page_object);
  ::create();
  add_help_file("book");
}
int query_book() { return 1; }
int query_weight() {
   if (!_def_p_obj) {
      load_object(_default_page_object);
      _def_p_obj = find_object(_default_page_object);
   }
   return ::query_weight() +
          sizeof(filter(_pages, (: objectp($1) :))) * _def_p_obj->query_weight();
}
void init() {
  add_command("open", "<direct:object>", (: do_open(1) :));
  add_command("open", "<direct:object> to [page] <number>",
              (: do_open($4[1]) :));
  add_command("tear", "page from <direct:object>", (: do_tear(1) :));
  add_command("tear", "[all] pages from <direct:object>", (: do_tear(0) :));
  add_command("tear", "<number> [of] pages from <direct:object>",
              (: do_tear($4[0]) :));
  add_command("rip", "page from <direct:object>", (: do_tear(1) :));
  add_command("rip", "<number> [of] pages from <direct:object>",
              (: do_tear($4[0]) :));
  add_command("rip", "[all] pages from <direct:object>", (: do_tear(0) :));
  add_command("turn", "[a|1] page of <direct:object>", (: do_turn(1) :));
  add_command("turn", "<number> pages of <direct:object>",
              (: do_turn($4[0]) :));
  add_command("turn", "<direct:object> to [page] <number>",
              (: do_open($4[1]) :) );
  add_command("turn", "to page <number> of <direct:object>",
              (: do_open($4[0]) :) );
  add_command("close", "<direct:object>", (: do_close() :));
}
int add_weight( int number ) {
   adjust_weight( number );
   return 1;
}
int test_add(object ob, int flag) {
  return (object)ob->query_property("my book") == this_object();
}
int test_remove( object ob, int flag, mixed dest ) {
  return ob->query_property("my book") != this_object();
}
void set_no_pages(int no) {
  int i;
  int siz;
  siz = sizeof(_pages);
  if (no < siz) {
    _pages = _pages[0..no-1];
    if (_open_page >= no) {
      _open_page = no;
    }
  } else {
    _pages = _pages + allocate(no-siz);
    for (i=siz;i<no;i++) {
      _pages[i] = ({ });
    }
  }
}
mixed *query_pages() { return _pages; }
void set_open_page(int i) {
  if (i < 0 || i == _open_page) {
     return ;
  }
  if (!_open_page && i) {
    add_alias("page");
    add_plural("pages");
  }
  if (i > sizeof(_pages)) {
    _open_page = sizeof(_pages);
  } else {
    _open_page = i;
  }
  if (!_open_page) {
    remove_alias("page");
    remove_plural("pages");
  }
}
int query_open_page() {
   return _open_page;
}
int is_current_page_torn_out() {
   if (!_open_page) {
      return 0;
   }
   if ( !_pages ) {
      return 0;
   }
   if (!_pages[_open_page-1]) {
      return 1;
   }
   return 0;
}
int is_page_torn_out(int page) {
   if (page < 1 || page > sizeof(_pages)) {
      return 0;
   }
   if (!_pages[page - 1]) {
      return 1;
   }
   return 0;
}
object query_current_page() {
   int i;
   if (!_open_page) {
      return this_object();
   }
   for (i = _open_page - 1; i < sizeof(_pages); i++) {
     if (_pages[i]) {
       if (!_def_p_obj) {
         load_object(_default_page_object);
         _def_p_obj = find_object(_default_page_object);
       }
       return _def_p_obj;
     }
   }
   return 0;
}
object query_current_page_clone() {
  return this_object();
}
int is_default_page(int num) {
   if (num > 0 && num <= sizeof(_pages)) {
      if (_pages[num - 1] &&
          !objectp(_pages[num - 1])) {
         return 1;
      }
   }
   return 0;
}
object query_selected_page(int num) {
   if (!intp(num) || num <= 0 || num > sizeof(_pages)) {
      return 0;
   }
   if (_pages[num - 1]) {
      if (objectp(_pages[num - 1])) {
         return _pages[num - 1];
      } else {
         if (!_def_p_obj) {
            load_object(_default_page_object);
            _def_p_obj = find_object(_default_page_object);
         }
         return _def_p_obj;
      }
   }
   return 0;
}
object query_selected_page_clone(int num) {
  return this_object();
}
object tear_current_page_out(object dest) {
  object page;
  if (is_current_page_torn_out()) {
    return 0;
  }
  if (_pages[_open_page-1]) {
    page = clone_object(_default_page_object);
    page->add_alias("page");
    page->add_plural("pages");
    if(_pages[_open_page-1] != 1)
      page->set_read_mess(_pages[_open_page-1]);
   }
  if (page && page->move(dest) == MOVE_OK) {
    _pages[_open_page-1] = 0;
    return page;
  }
  return 0;
}
int add_page_after(object page, int after) {
   if (after < 0 || after > sizeof(_pages) + 1 ||
       !objectp(page) || !intp(after)) {
      return 0;
   }
   _pages = _pages[0..after - 1] + page->query_read_mess() + _pages[after..];
   page->move("/room/rubbish");
   return 1;
}
int replace_page_with(object page, int num) {
   if (num < 1 || num > sizeof(_pages) ||
       !objectp(page) || !intp(num)) {
      return 0;
   }
   _pages[num-1] = page->query_read_mess();
   page->move("/room/rubbish");
}
int make_page_blank(int num) {
   if (num < 1 || num > sizeof(_pages) || !intp(num)) {
      return 0;
   }
   _pages[num-1] = 1;
}
string short(int flags) {
  if (!flags || _ignore_open_page) {
    return ::short(flags);
  }
  if (_open_page) {
    return "open " + ::short(flags);
  }
  return "closed " + ::short(flags);
}
string *parse_command_adjectiv_id_list() {
   if (_open_page) {
      return ::parse_command_adjectiv_id_list() + ({ "open" });
   }
   return ::parse_command_adjectiv_id_list() + ({ "closed" });
}
string long(string str, int dark) {
  string ret;
  int i;
  if (!_open_page) {
    return ::long(str, dark)+"It is closed.\n";
  }
  ret = ::long(str, dark)+"It is open at page " + _open_page + ".\n";
  for (i=_open_page-1;i<sizeof(_pages) && !_pages[i];i++) {
    if (!_pages[i]) {
      ret += "Page "+(i+1)+" has been torn out.\n";
    }
  }
  if (i >= sizeof(_pages)) {
    ret += "All the rest of the pages have been torn out!\n";
  } else {
    if (i != _open_page -1) {
      ret += "You can see page "+(i+1)+" however.\n";
    }
    if(str && strsrch(str, "page") != -1) {
      ret += _default_page_object->long(str, dark);
    }
  }
  return ret;
}
protected int do_open(int page) {
  if (page <= 0)  {
     write("Oddly enough, the first page is page 1.\n");
     page = 1;
  }
  else if (page > sizeof(_pages))  {
     write("There " + (sizeof(_pages) == 1 ? "is only " : "are only ") +
           query_num(sizeof(_pages)) +
           (sizeof(_pages) == 1 ? " page in " : " pages in ") +
           the_short() + ".\n");
     page = sizeof(_pages);
  }
  if (query_open_page() == page) {
    add_failed_mess("The $D is already open at page " + page + ".\n");
  }
  if (_open_page > 0  &&  is_page_torn_out (page)) {
     add_failed_mess("The page " +  page + " in $D is torn out.\n");
     return 0;
  }
  _ignore_open_page = 1;
  call_out((: _ignore_open_page = 0 :), 4);
  set_open_page(page);
  add_succeeded_mess("$N $V $D to page " + page + ".\n", ({ }));
  return 1;
}
protected int do_turn(int number) {
  int tmp;
  tmp = query_open_page();
  if (tmp+number > sizeof(_pages)) {
    set_open_page(0);
    add_succeeded_mess("$N close$s $D.\n");
  } else {
    if (tmp == 0) {
       add_succeeded_mess("$N turn$s $D to page " + number + ".\n");
    }
    else add_succeeded_mess("$N turn$s " + number +
           (number > 1 ? " pages " : " page ") + "of $D.\n");
    set_open_page(tmp + number);
  }
  if (tmp == query_open_page()) {
     add_failed_mess("Unable to turn page of $D.\n", ({ }));
     return 0;
  }
  _ignore_open_page = 1;
  call_out((: _ignore_open_page = 0 :), 4);
  return 1;
}
protected int do_close() {
  if (!query_open_page()) {
    this_player()->add_failed_mess(this_object(), "$D is already closed.\n",
                                   ({}));
    return 0;
  }
  _ignore_open_page = 1;
  call_out((: _ignore_open_page = 0 :), 4);
  set_open_page(0);
  return 1;
}
int do_tear(int number) {
  int i;
  if (_ignore_saved_pages) {
    add_failed_mess("For some reason you cannot seem to tear any pages "
                    "from $D.\n");
    return 0;
  }
  if (!_open_page) {
    this_player()->add_failed_mess(this_object(), "$D is closed!\n",
                                   ({}));
    return 0;
  }
  if(number == 0) {
    _open_page = 1;
    number = sizeof(_pages);
  }
  for(i=0; i<number; i++) {
    if(!tear_current_page_out(this_player()))
      break;
    if ( _open_page != sizeof( _pages ) ) {
        _open_page++;
    }
  }
  if(i) {
    if(i > 1)
      add_succeeded_mess("$N $V " + i + " pages from $D.\n");
    else
      add_succeeded_mess("$N $V a page from $D.\n");
    return 1;
  }
  return 0;
}
varargs void set_read_mess(string str, string lang, int size) {
  if (_open_page) {
    if(pointerp(str)) {
      _pages[_open_page-1] = str;
      return;
    }
    if(str)
      _pages[_open_page-1] = ({ ({ str, 0, lang, size }) });
    else
      _pages[_open_page-1] = 1;
    return;
  }
  return ::set_read_mess(str, lang, size);
}
void add_read_mess(mixed str, string type, string lang, int size) {
  if(_open_page) {
    if(!arrayp(_pages[_open_page-1]))
      _pages[_open_page-1] = ({ });
    _pages[_open_page-1] += ({ ({ str, type, lang, size }) });
    return;
  }
  ::add_read_mess(str, type, lang, size);
}
mixed query_read_mess() {
  if (_open_page) {
    if(!_pages[_open_page-1])
      return ({ });
    return _pages[_open_page-1];
  }
  return ::query_read_mess();
}
mixed *stats() {
  return ({
    ({ "num pages" , sizeof(_pages) }),
    ({ "ignore saved pages" , _ignore_saved_pages }),
    ({ "default page ob" , _default_page_object }),
    ({ "open page", _open_page }),
    ({ "book number" , _book_num }),
  }) + ::stats();
}
void dest_me() {
  int i;
  for (i=0;i<sizeof(_pages);i++) {
    if (objectp(_pages[i])) {
      _pages[i]->dest_me();
    }
  }
  ::dest_me();
}
mixed query_static_auto_load() {
  if (file_name(this_object())[0..8] == "/std/book") {
    return int_query_static_auto_load();
  }
}
mapping query_dynamic_auto_load() {
  mapping bing;
  bing = ([
      "::" : ::query_dynamic_auto_load(),
      "default page object" : _default_page_object,
      "open page" : _open_page,
      "book num" : _book_num,
    ]);
  if (!_ignore_saved_pages) {
    bing["pages"] = _pages;
  }
  return bing;
}
void init_dynamic_arg(mapping map, object player) {
  int i;
  object *tmp;
  if (!player) {
    player = _player;
    if (!player) {
       player = this_player();
    }
  }
  if (map["::"]) {
    ::init_dynamic_arg(map["::"]);
  }
  if (map["default page object"]) {
    _default_page_object = map["default page object"];
    load_object(_default_page_object);
    _def_p_obj = find_object(_default_page_object);
  }
  if (map["pages"] && !_ignore_saved_pages) {
    if(sizeof(map["pages"]) && sizeof(map["pages"][0]) == 3) {
      for(i=0; i<sizeof(_pages); i++) {
        tmp = (object *)player->load_auto_load_to_array(map["pages"][i],
                                                        this_object(), player);
        if(sizeof(tmp->query_read_mess()))
          _pages[i] = tmp->query_read_mess()[0];
        tmp->move("/room/rubbish");
      }
    } else
      _pages = map["pages"];
  }
  _book_num = map["book num"];
  set_open_page(map["open page"]);
}
void set_default_page_object(string obj) {
  load_object(obj);
  if (find_object(obj)) {
    _default_page_object = obj;
    _def_p_obj = find_object(obj);
  }
}
string query_default_page_object() {
   return _default_page_object;
}
object create_default_page_object() {
   return clone_object(_default_page_object);
}
int query_num_pages() {
  return sizeof(_pages);
}
int query_book_num() {
   return _book_num;
}
void set_book_num(int num) {
   _book_num = num;
}
int query_ignore_saved_pages() {
   return _ignore_saved_pages;
}
protected void set_ignore_saved_pages(int saved) {
   _ignore_saved_pages = saved;
}
void set_player(object player) {
   _player = player;
}
object query_player() {
   return _player;
}
string query_read_short(object player, int ignore_labels) {
  if(!::query_read_short(player, 0))
    return 0;
  if (!_open_page) {
    return "the cover of " + ::query_read_short(player, 0);
  }
  return "page " + query_num(_open_page) + " of " +
    ::query_read_short(player, 1);
}
string query_readable_message(object player, int ignore_labels) {
   return ::query_readable_message(player, _open_page != 0);
}

==================================================
FILE: book_dir.c
==================================================

inherit "/std/book";
#include "nroff.h"
string language = 0;
void set_book_language(string lang) {
   language = lang;
}
string query_language() { return language; }
void set_book_dir(string dir) {
  int i, max;
  set_no_pages(10);
  set_ignore_saved_pages(1);
  max = 10;
  i = 1;
  set_default_page_object("/obj/misc/nroff_paper");
  set_open_page (0);
  while (file_size(dir+i) > 0) {
    set_open_page(i);
    set_read_mess("$$" + dir + i + "$$" , language, 0);
    i++;
    if (i >= max) {
      max += 10;
      set_no_pages(max);
    }
  }
  set_no_pages(i-1);
  set_open_page(0);
}

==================================================
FILE: container.c
==================================================

#include <move_failures.h>
#include <player.h>
#include <player_handler.h>
inherit "/std/object";
inherit "/std/basic/cute_look";
inherit "/std/basic/export_inventory";
inherit "/global/auto_load";
private nosave int _max_weight;
private nosave int _loc_weight;
private nosave int _max_items;
private nosave int _prevent_insert;
private nosave string _ownership;
private nosave object _player;
private nosave int _n_tracked_items;
private nosave int _tracking;
void create() {
  registered_containers = ({ });
  _n_tracked_items = 0;
  _tracking = 1;
  export_inventory::create();
  object::create();
}
int query_max_items() {
  if(_max_items)
    return _max_items;
  if(_max_weight)
    return 4 * sqrt(_max_weight);
  return -1;
}
void set_max_items( int number ) { _max_items = number; }
int query_max_weight() { return _max_weight; }
void set_max_weight( int number ) { _max_weight = number; }
int query_loc_weight() { return _loc_weight; }
void update_loc_weight() {
   object thing;
   _loc_weight = 0;
   foreach ( thing in all_inventory( this_object() ) )
      _loc_weight += (int)thing->query_complete_weight();
}
int query_complete_weight() {
   return ::query_complete_weight() + _loc_weight;
}
int add_weight( int n ) {
#ifdef 0
  if ( _prevent_insert )
    return 0;
#endif
  if ( !_max_weight ) {
    _loc_weight += n;
    return 1;
  }
  if ( n + _loc_weight > _max_weight )
    return 0;
  if ( !environment() ) {
    _loc_weight += n;
    return 1;
  }
  if ( !environment()->add_weight( n ) )
    return 0;
  _loc_weight += n;
  return 1;
}
string query_ownership() { return _ownership; }
void set_ownership( string word ) {
  if( word )
    _ownership = lower_case( word );
  else
    _ownership = word;
}
int test_remove( object thing, int flag, mixed dest ) {
  int player;
  string str;
  if( !_ownership || !this_player() ) {
    return 1;
  }
  if( objectp( dest ) ) {
    dest = file_name( dest );
  }
  if( dest == "/room/rubbish" || dest == "/room/vault" ) {
    return 1;
  }
  str = "Item " + file_name( this_object() ) + " accessed by " +
    this_player()->query_short() + " which belongs to $C$" + _ownership;
  if( (string)this_player()->query_name() == _ownership ) {
    str += ".  Taking items, no theft event.";
    log_file( "/w/trilogy/CONTAINER", str + "\n" );
    return 1;
  }
  player = PLAYER_HANDLER->test_user( _ownership );
  if( player ) {
    str += ", who is a player.  ";
    if( !pk_check( this_player(), _ownership, 1 ) &&
      environment( this_player() ) ) {
      str += "PK check succeded: Taking items, theft event triggered.";
      this_player()->zap_harry_shadow();
      event( environment( this_player() ), "theft", this_player(),
        this_object(), ({ thing }) );
      log_file( "/w/trilogy/CONTAINER", str + "\n" );
      return 1;
    } else {
      str += "PK check failed: Cannot take items.";
      write( "An unseen force stays your hand.\n" );
      log_file( "/w/trilogy/CONTAINER", str + "\n" );
      return 0;
    }
  } else {
    str += ", which is not a player.  Taking items, theft event triggered.";
    this_player()->zap_harry_shadow();
    event( environment( this_player() ), "theft", this_player(),
      this_object(), ({ thing }) );
    log_file( "/w/trilogy/CONTAINER", str + "\n" );
    return 1;
  }
}
int test_add(object ob, int flag) {
  if(!_max_weight && !_max_items)
    return 1;
  if(ob->query_max_weight() > _max_weight - _loc_weight) {
    return 0;
  }
  if(this_object()->query_length() > 1 &&
     this_object()->query_length() < ob->query_length()) {
    return 0;
  }
  if(this_object()->query_width() > 1 &&
     this_object()->query_width() < ob->query_width()) {
    return 0;
  }
  if(ob->query_max_weight())
    return ((sizeof(deep_inventory(this_object())) +
             sizeof(deep_inventory(ob))) < query_max_items());
  else
    return sizeof(deep_inventory(this_object())) < query_max_items();
}
int set_prevent_insert() { _prevent_insert = 1; }
int reset_prevent_insert() { _prevent_insert = 0; }
int query_prevent_insert() { return _prevent_insert; }
varargs int move(mixed dest, mixed messin, mixed messout) {
  if (_prevent_insert && _loc_weight && !living(dest) && environment(dest))
    return MOVE_INVALID_DEST;
  return object::move( dest, messin, messout );
}
object *find_inv_match( string words, object looker ) {
   object *things;
   things = all_inventory( this_object() );
   things = filter(things, (: $1->short(0) &&
                              (!$2 || $1->query_visible($2)) :), looker);
   return things;
}
int do_restore_inventory_error(object ob, int move_flag) {
   object receipt;
   int ret;
   receipt = clone_object(PLAYER_RECEIPT);
   receipt->setup_receipt(ob);
   receipt->set_weight(0);
   ret = receipt->move(this_object());
   if (ret != MOVE_OK) {
      receipt->dest_me();
   } else {
      move_flag = MOVE_OK;
      ob->move("/room/rubbish");
   }
   return move_flag;
}
protected int handle_restore_inventory(object ob) {
  int move_flag;
  ob->disable_item_tracking();
  move_flag = ob->move(this_object());
  ob->enable_item_tracking();
  if (move_flag != MOVE_OK) {
     move_flag = do_restore_inventory_error(ob, move_flag);
  }
  return move_flag;
}
mixed stats() {
  return ::stats() + ({
    ({ "loc_weight", query_loc_weight(), }),
    ({ "max_weight", query_max_weight(), }),
    ({ "max_items", query_max_items(), }),
    ({ "export invent", query_can_export_inventory() }),
  });
}
mapping int_query_static_auto_load() {
  mapping tmp;
  tmp = ::int_query_static_auto_load();
  return ([
     "::" : tmp,
     "max weight" : _max_weight,
     "prevent insert" : _prevent_insert,
     "can export inventory" : query_can_export_inventory(),
  ]);
}
mapping query_dynamic_auto_load() {
  mixed inventory;
  catch(inventory = create_auto_load( all_inventory( this_object() ), 0 ) );
  return ([
    "::" : object::query_dynamic_auto_load(),
    "inv" : inventory
  ]);
}
void set_player( object thing ) {
   ::set_player(thing);
    _player = thing;
}
object query_player() { return _player; }
nomask void enable_item_tracking() { _tracking = 1; }
nomask void disable_item_tracking() { _tracking = 0; }
nomask void event_container_move( object mover, mixed from, mixed to ) {
  if (_n_tracked_items)
    all_inventory()->event_container_move( mover, from, to );
}
void event_move_object( mixed from, mixed to ) {
  if (_n_tracked_items && _tracking && !interactive()) {
    all_inventory()->event_container_move( this_object(), from, to );
    if (objectp(from)) from->remove_tracked_items( _n_tracked_items );
    if (objectp( to )) to->add_tracked_items( _n_tracked_items );
  }
}
nomask void set_tracked_item_status_reason(string reason) {
  if (_n_tracked_items)
    all_inventory()->set_tracked_item_status( reason );
}
nomask void add_tracked_items( int n_items ) {
   _n_tracked_items += n_items;
   if (environment()) environment()->add_tracked_items( n_items );
}
nomask void remove_tracked_items( int n_items ) {
  _n_tracked_items -= n_items;
  if (environment()) environment()->remove_tracked_items( n_items );
}
nomask int query_tracked_items() {
  return _n_tracked_items;
}
int can_find_match_recurse_into(object looker) {
   object env;
   env = environment();
   while (env &&
          !living(env) &&
          env != looker &&
          env != environment(looker)) {
      env = environment(looker);
   }
   return env == looker || env == environment(looker);
}
int can_find_match_reference_inside_object(object thing, object looker) {
   return 1;
}
void init_dynamic_arg( mapping bing, object ) {
  function f;
  if ( bing[ "::" ] ) {
    ::init_dynamic_arg( bing[ "::" ] );
  }
  if ( bing[ "inv" ] ) {
    f = (: handle_restore_inventory($1) :);
    if (!_player) {
      _player = this_player();
    }
    if (_player) {
      load_auto_load_to_inventory( bing["inv"], this_object(), _player, f );
    } else {
      load_auto_load_to_inventory( bing["inv"], this_object(), this_player(), f);
    }
  }
}
void init_static_arg( mapping bing ) {
  if ( bing[ "::" ] ) {
    ::init_static_arg( bing[ "::" ] );
  }
  if ( !undefinedp( bing[ "max weight" ] ) ) {
    _max_weight = bing[ "max weight" ];
  }
  if ( !undefinedp( bing[ "prevent insert" ] ) ) {
    _prevent_insert = bing[ "prevent insert" ];
  }
  if (bing["can export inventory"]) {
    set_can_export_inventory();
  } else {
    reset_can_export_inventory();
  }
}
mixed query_static_auto_load() {
  if (file_name(this_object())[0..13] == "/std/container") {
    return int_query_static_auto_load();
  }
  return ([ ]);
}
void dest_me() {
   foreach( object ob in all_inventory( this_object() ) ) {
       reset_eval_cost();
       ob->dest_me();
   }
   ::dest_me();
}

==================================================
FILE: delivery.c
==================================================

#include <player_handler.h>
#include <login.h>
#include <move_failures.h>
inherit "/global/auto_load";
class delivery_item {
    object delivery_ob;
    string sent_by;
    int submit_time;
    int delay_time;
}
protected void set_delivery_delay(int new_time);
protected int valid_delivery(class delivery_item delivery, string person);
protected void deliver_item(string who, object ob, string sent_by);
protected void set_burdened_mess(string s);
protected void set_delivery(mapping x);
protected void set_delivery_mess(string s);
protected void set_save_file(string str);
public int query_delivery_delay();
public string query_burdened_mess();
public string query_delivery_mess();
public string query_save_file();
public varargs mixed query_delivery(string person);
public void add_delivery(mixed who, mixed sender, object item, int delay);
public void check_delivery(mixed person, string type);
public void clear_delivery();
public void setup_delivery();
public void load_file();
public void save_file();
private mapping _delivery;
private mixed _item_save;
private nosave string _save_file;
private nosave object _cont;
private nosave string _delivery_mess;
private nosave string _burdened_mess;
private nosave int _delivery_delay;
void create() {
    _delivery = ([ ]);
    _save_file = "";
    _delivery_delay = 5;
    _delivery_mess = "\nA small womble wearing a bright green hat "
        "strides up to you confidently and hands you $N.  She "
        "mutters something about \"delivery\" and \"$S\", before "
        "scurrying away.\n";
    _burdened_mess = "\nA small womble wearing a bright purple "
        "hat strides up to you, and places \"$N\" on the ground.  She "
        "mutters something about a gift from \"$S\", and the runs off.\n";
    _cont = clone_object("/std/container");
    call_out("tidy_up", 30 + random(30));
}
public void setup_delivery() {
    LOGIN_HANDLER->add_static_login_call("all", "check_delivery",
        base_name(this_object()));
}
public string query_save_file() {
    return _save_file;
}
protected void set_save_file(string str) {
    _save_file = str;
}
public void clear_delivery() {
    _delivery = ([ ]);
    save_file();
}
protected void set_delivery(mapping x) {
    _delivery = x;
    save_file();
}
void add_delivery(mixed who, mixed sender, object item, int delay) {
    string name, from;
    class delivery_item parcel;
    if (objectp(who))
        name = who->query_name();
    else
        name = who;
    if (objectp(sender))
        from = sender->query_cap_name();
    else
        from = sender;
    parcel = new(class delivery_item,
        delivery_ob : item, submit_time : time(), sent_by : from,
        delay_time : delay);
    if (undefinedp(_delivery[name]))
        _delivery[name] = ({ parcel });
    else
        _delivery[name] += ({ parcel });
    log_file("DELIVERY", "%s added a new delivery item for %s, %s sent "
        "by %s.\n", previous_object()->short(), name, item->short(),
        from);
    item->move(_cont);
    save_file();
}
protected int valid_delivery(class delivery_item delivery, string person) {
  if (delivery->submit_time + delivery->delay_time > time())
    return 1;
  if (!objectp(delivery->delivery_ob))
    return 0;
  call_out( (: deliver_item :), _delivery_delay, person, delivery->delivery_ob,
            delivery->sent_by);
  return 0;
}
public void check_delivery(mixed person, string type) {
    if (type != LOGIN && type != RECONNECT)
        return;
    if (!_delivery[person])
        return;
    _delivery[person] = filter(_delivery[person],
        (: valid_delivery($1, $(person)) :));
    if (!sizeof(_delivery[person]))
        map_delete(_delivery, person);
    save_file();
}
protected void deliver_item(string who, object ob, string sent_by) {
    string new_mess;
    object player;
    player = find_player(who);
    if (!player)
        ob->move("/room/rubbish");
    if (ob->move(player) != MOVE_OK) {
        if (environment(player)) {
            new_mess = replace(_burdened_mess, ({ "$S", sent_by, "$N",
                "$0$" }));
            player->add_message(new_mess,  ({ ({ "my_a_short:" +
            file_name(ob) }) }));
            ob->move(environment(player), );
        }
        else {
            ob->move("/room/rubbish", "$N appear$s in a puff of smoke.");
            log_file("DELIVERY", "%s: %s sent to the rubbish room, %s has "
                "no environment.\n", ctime(time()), ob->short(),
                player->short());
        }
    }
    else {
        new_mess = replace(_delivery_mess, ({ "$S", sent_by, "$N", "$0$" }));
        player->add_message(new_mess,  ({ ({ "my_a_short:" +
            file_name(ob) }) }));
        log_file("DELIVERY", "%s: %s delivered to %s.\n", ctime(time()),
            ob->short(), who);
    }
}
int query_theft_command() {
    return -1;
}
void clean_delivery_mapping() {
    string *people, person;
    people = keys(_delivery);
    foreach (person in people) {
        _delivery[person] = filter(_delivery[person],
            (: objectp($1->delivery_ob) :));
    }
    _delivery = filter(_delivery, (: sizeof($2) :));
}
public void save_file() {
  mixed *tmp;
  string player;
  class delivery_item *values;
  if(_save_file == "")
    return;
  _item_save = ({ });
  clean_delivery_mapping();
  foreach (player, values in _delivery) {
    tmp = map(values, (: $1->delivery_ob :));
    if (!arrayp(tmp))
      continue;
    _item_save += ({ player, create_auto_load(tmp, 0) });
  }
  tell_creator("ceres", "Saving: %s\n", _save_file);
  unguarded((: save_object, _save_file :));
  _item_save = 0;
}
void load_file() {
  int i, j, size;
  mixed *tmp;
  string who;
  mixed *items;
  if(_save_file == "")
    return;
  log_file("DELIVERY", "Attempting to load save file at %s.\n",
           ctime(time()));
  tell_creator("ceres", "Loading: %s\n", _save_file);
  if (file_size(_save_file + ".o") > -1) {
    unguarded((: restore_object, _save_file :));
    if (!_cont)
      _cont = clone_object("/std/container");
    all_inventory(_cont)->move("/room/rubbish");
    for (i = 0; i < sizeof(_item_save); i = i + 2) {
      who = _item_save[i];
      items = _item_save[i + 1];
      if (!_delivery[who])
        return;
      tmp = load_auto_load_to_array(items, this_player());
      size = sizeof(tmp);
      for (j = 0; j < size; j++) {
        _delivery[who][j]->delivery_ob = tmp[size - j - 1];
        tmp[j]->move(_cont);
      }
    }
    _item_save = 0;
  }
}
public string query_delivery_mess() {
    return _delivery_mess;
}
public int query_delivery_delay() {
    return _delivery_delay;
}
protected void set_delivery_delay(int new_time) {
    _delivery_delay = new_time;
}
protected void set_delivery_mess(string s) {
    _delivery_mess = s;
}
protected void set_burdened_mess(string s) {
    _burdened_mess = s;
}
public string query_burdened_mess() {
    return _burdened_mess;
}
public varargs mixed query_delivery(string person) {
    if (undefinedp(_delivery[person])) {
        return copy(_delivery);
    }
    else {
        return copy(_delivery[person]);
    }
}
void dest_me() {
    if (_cont)
        _cont->dest_me();
}
object query_cont() {
  return _cont;
}
void tidy_up() {
  string person;
  foreach(person in keys(_delivery)) {
    if(!PLAYER_HANDLER->test_user(person) || !PLAYER_HANDLER->test_active(person)) {
      log_file("DELIVERY", "%s Removing delivery for %s (inactive).\n",
               this_object()->query_short(), person);
      map_delete(_delivery, person);
    }
  }
  save_file();
}
mixed *stats() {
    return ({
        ({ "delivery mess", replace(_delivery_mess, ({ "\n",  "" }) ) }),
        ({ "burdened mess", replace(_burdened_mess, ({ "\n",  "" }) ) }),
        ({ "delivery delay", _delivery_delay, }),
        ({ "delivery save file", _save_file, }),
        ({ "undelivered items", _cont ? sizeof(all_inventory(_cont)) : 0 }),
    });
}

==================================================
FILE: effect_shadow.c
==================================================

object player;
int id;
object attach_to_player(object p, int i) {
  player = p;
  id = i;
  return shadow( player, 1 );
}
void remove_effect_shadow(int i) {
  if (i == id) { if( this_object() ) destruct( this_object() ); return; }
  player->remove_effect_shadow(i);
}
protected mixed arg() {
   int enum;
   enum = (int)player->sid_to_enum( id );
   if ( enum == -1 ) {
#ifdef DEBUG
     log_file( "EFFECTS", time() +": no effect for "+
               file_name( this_object() ) +"\n           on "+
               file_name( player ) +"\n" );
#endif
      destruct( this_object() );
      return 0;
   }
   return (mixed)player->arg_of( enum );
}
protected void set_arg(mixed newarg) {
   player->set_arg_of(player->sid_to_enum(id), newarg);
}
protected void remove_this_effect() {
  player->delete_effect( (int)player->sid_to_enum( id ) );
}

==================================================
FILE: held.c
==================================================

inherit "/std/object";
nosave object holder;
int query_holdable() { return 1; }
int set_holder(object ob) {
  holder = ob;
  return 1;
}
object query_holder() { return holder; }
int drop(mixed dest) {
  holder = 0;
  return ::drop(dest);
}
varargs int move( mixed dest, string arrive, string leave ) {
  if (holder && dest != holder) {
      holder->unhold_ob(this_object());
      holder = 0;
  }
  return ::move(dest, arrive, leave);
}

==================================================
FILE: hospital.c
==================================================

#include <armoury.h>
#include <data.h>
#include <weather.h>
#include <hospital.h>
#define CREATE_NPCS 1
inherit "/std/room";
inherit HOSPITAL_ALIGNMENT_INHERIT;
public object *load_random_npc(string zone, int wealth, int busy);
protected void load_file();
protected void save_file();
protected void set_save_file(string new_save);
public void hospital_log_file(string file, string format, mixed *args ...);
public int get_item(object destination, string *items);
public string query_save_file();
public int *query_npcs();
public mapping query_hospital_npcs();
public void add_npc_type(string type, string *data);
public void regen_after_death( object dead_npc );
private nosave string _save_file;
private nosave string _hospital_type;
private nosave mixed *_regenerated_npcs;
private nosave int _hospital_call_id;
private nosave mapping _log_file_info;
private nosave string _hospital_log_directory;
private nosave string _data_directory;
private nosave string _npc_path;
private nosave string _domain;
private nosave int _max_cache;
private nosave int _disable_npc_generation;
private mapping _unique_npcs;
private mapping _hospital_npcs;
private mapping _cache_inventory;
private int _last_npc_check;
private int _zone_npcs;
private mapping _group_info;
private mapping _npc_info;
private mapping _zone_info;
private mapping _path_to_npc;
private mapping _file_modified_time;
void create() {
    seteuid(master()->creator_file(file_name(this_object())));
    do_setup++;
    ::create();
    do_setup--;
    if (!_group_info) {
        _group_info = ([ ]);
    }
    if (!_npc_info) {
        _npc_info = ([ ]);
    }
    if (!_zone_info) {
        _zone_info = ([ ]);
    }
    if (!_path_to_npc) {
        _path_to_npc = ([ ]);
    }
    if (!_file_modified_time) {
        _file_modified_time = ([ ]);
    }
    if (!_unique_npcs) {
        _unique_npcs = ([ ]);
    }
    if (!_cache_inventory) {
      _cache_inventory = ([ ]);
    }
    _regenerated_npcs = ({ });
    _log_file_info = ([ ]);
    if(!_max_cache)
      _max_cache = DEFAULT_MAX_CACHE;
    if (!do_setup) {
        set_short( "Un-configured Hospital" );
        set_long("This is an unconfigured hospital.  Find the right one.\n");
        add_property("determinate", "the ");
        set_light(60);
        this_object()->setup();
    }
}
int ok_to_clone() {
   return 1;
}
public string *query_deities() {
   return ({ "fish", "pishe", "sek", "hat", "gapp",
      "gufnork", "sandelfon" });
}
public int get_item(object destination, string *items) {
    int i;
    object item;
    if (!objectp(destination)) {
        return 0;
    }
    while (!item) {
        i = random(sizeof(items));
        item = ARMOURY->request_item(items[i], 80 + random(21), _domain);
        if (!item) {
            item = ARMOURY->request_item(items[i], 80 + random(21) );
            if ( !item ) {
                items = items[0..i-1] + items[i+1..];
                continue;
            }
        }
        if (!sizeof(items)) {
            hospital_log_file("BROKEN_ITEMS", "Unable to select any items "
                "for %s in the Ankh-Morpork hospital.\n",
                previous_object()->short());
            break;
        }
    }
    if (objectp(item)) {
        item->move(destination);
        return 1;
    }
    return 0;
}
protected void load_file() {
    class npc_info npc;
    class group_info group;
    string name;
    if (file_size(_save_file + ".o") > -1) {
        unguarded((: restore_object, _save_file :));
        if (!_group_info) {
            _group_info = ([ ]);
        } else {
            foreach (name, group in _group_info) {
                group->storage = 0;
            }
        }
        if (!_npc_info) {
            _npc_info = ([ ]);
        } else {
            foreach (name, npc in _npc_info) {
                npc->population = ({ });
            }
        }
        if (!_zone_info) {
            _zone_info = ([ ]);
        }
        if (!_path_to_npc) {
            _path_to_npc = ([ ]);
        }
        if (!_file_modified_time) {
            _file_modified_time = ([ ]);
        }
        if (!_unique_npcs) {
            _unique_npcs = ([ ]);
        }
    }
}
protected void save_file() {
    unguarded((: save_object, _save_file :));
}
protected void set_save_file(string new_save) {
    _save_file = new_save;
    load_file();
}
public string query_save_file() {
    return _save_file;
}
void set_data_directory(string dir) {
   _data_directory = dir;
   call_out("scan_for_new_data", 2);
}
string query_data_directory() {
   return _data_directory;
}
void set_npc_path(string path) {
  _npc_path = path;
}
void set_domain(string domain) {
  _domain = domain;
}
void set_max_cache(int num) {
  _max_cache = num;
}
void set_disable_npc_generation(int value) {
   _disable_npc_generation = value;
}
int query_disable_npc_generation() {
   return _disable_npc_generation;
}
public int make_unique(mixed who) {
    int delay;
    if (!_unique_npcs) {
        return 0;
    }
    if (objectp(who)) {
        who = who->query_name();
    }
    if (!_unique_npcs[who]) {
        _unique_npcs[who] = new(class unique_npc);
    }
    if ( _unique_npcs[who]->next_regen_time > time() ) {
        return 0;
    }
    if (_npc_info[who] && _npc_info[who]->delay) {
        delay = _npc_info[who]->delay;
    } else {
        delay = REGEN_TIME;
    }
    _unique_npcs[who]->next_regen_time = time() + delay;
    save_file();
    return 1;
}
public void reset_unique(string who) {
    if (!_unique_npcs[who]) {
        return ;
    }
    _unique_npcs[who]->next_regen_time = 0;
}
#ifdef REGENERATE_AFTER_DEATH
public void regen_after_death( object dead_npc ) {
    object *monsters, destination;
    class regenerated_npc new_npc;
    int i, max;
    if ( !dead_npc )
        return;
    _regenerated_npcs += ({ new( class regenerated_npc,
        type : dead_npc->query_property("monster_type"),
        load_position : previous_object()->query_property("start location") ) });
    if ( !ok_to_clone(_hospital_type) || sizeof(_regenerated_npcs) < MINIMUM_DEATH_REGEN )
        return;
    new_npc = _regenerated_npcs[0];
    if ( !classp( new_npc ) )
        return;
    _regenerated_npcs = _regenerated_npcs[1..];
    if (!new_npc->load_position || !new_npc->type );
        return;
    max = random(5);
    for ( i = 0; i < max; i++ ){
        destination = find_object( new_npc->load_position );
        if ( !objectp( destination ) )
            return;
        monsters = get_monster(new_npc->type);
        destination->replace_monster(previous_object(), monsters);
        call_out((: $1->announce_entry($2) :), 8 + random(6), destination,
            monsters);
    }
}
#endif
string npc_path(string str) {
   return _npc_path + "/" + str;
}
public void hospital_log_file(string file, string format, mixed *args ...) {
    string filename;
    filename = _hospital_log_directory;
    if (file[0] == '/') {
        file = file[ strsrch( file, "/", -1 ) + 1 .. ];
    }
    log_file( _hospital_log_directory + "/" + file, ctime(time()) + ": " + format, args ...);
}
protected void set_log_directory(string new_dir) {
    if (file_size(new_dir) != -2) {
        debug_printf( "%s: Invalid "
            "log directory -- defaulting to %s.\n",
            file_name( this_object() ), DEFAULT_LOG_DIRECTORY );
        new_dir = DEFAULT_LOG_DIRECTORY;
    }
    _hospital_log_directory = new_dir;
}
private void parse_zone(string fname, mapping data) {
   string name;
   class zone_info info;
   mapping bing;
   int chance;
   string* bits;
   if (!data["name"]) {
      debug_printf("No name for zone %O\n", data);
      hospital_log_file("COMPILE_ERROR", "No name for zone %O\n", data);
      return 0;
   }
   name = data["name"];
   if (data["group"] && !arrayp(data["group"])) {
      data["group"] = ({ data["group"] });
   } else if (!arrayp(data["groups"])) {
      data["group"] = ({ });
   }
   if (data["npc"] && !arrayp(data["npc"])) {
      data["npc"] = ({ data["npc"] });
   } else if (!arrayp(data["npc"])) {
      data["npc"] = ({ });
   }
   if (data["zone"] && !arrayp(data["zone"])) {
      data["zone"] = ({ data["zone"] });
   } else if (!arrayp(data["zone"])) {
      data["zone"] = ({ });
   }
   info = new(class zone_info, npcs : ([ ]), groups : ([ ]), zones : ([ ]));
   chance = 0;
   foreach (bing in data["npc"]) {
      if (!mapp(bing) || !stringp(bing["name"]) || !intp(bing["chance"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for zone (%s) %O\n", name,  bing);
      } else {
         info->npcs[bing["name"]] = bing["chance"];
         chance += bing["chance"];
      }
   }
   info->npc_chance = chance;
   chance = 0;
   foreach (bing in data["group"]) {
      if (!mapp(bing) || !stringp(bing["name"]) || !intp(bing["chance"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for zone (%s) %O\n", name,  bing);
      } else {
         info->groups[bing["name"]] = bing["chance"];
         chance += bing["chance"];
      }
   }
   info->group_chance = chance;
   chance = 0;
   foreach (bing in data["zone"]) {
      if (!mapp(bing) || !stringp(bing["name"]) || !intp(bing["chance"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for zone (%s) %O\n", name,  bing);
      } else {
         info->zones[bing["name"]] = bing["chance"];
         chance += bing["chance"];
      }
   }
   info->zone_chance = chance;
   info->busy = data["busy"];
   bits = keys(data) - ({ "zone", "group", "npc", "name", "busy" });
   if (sizeof(bits)) {
      debug_printf("Unknown keys %s in zone %s\n", query_multiple_short(bits),
                   name);
      hospital_log_file("COMPILE_ERROR", "Unknown keys %s in %s\n",
                         query_multiple_short(bits), name);
   }
   _zone_info[name] = info;
   save_file();
}
private void parse_npc(string fname, mapping data) {
   string name;
   class npc_info info;
   string* bits;
   if (!data["name"]) {
      debug_printf("No name for npc %O\n", data);
      hospital_log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   name = data["name"];
   if (!data["path"]) {
      hospital_log_file("COMPILE_ERROR", "Required path field not present for npc %s\n", name);
      return 0;
   }
   if (file_size(npc_path(data["path"]) + ".c") < 0) {
      hospital_log_file("BAD_NPC_PATH", "Bad path for npc %s (%s)\n", name, data["path"]);
   }
   if (data["command"] && !arrayp(data["command"])) {
      data["command"] = ({ data["command"] });
   }
   if (data["move_zone"] && !arrayp(data["move_zone"])) {
      data["move_zone"] = ({ data["move_zone"] });
   }
   info = new(class npc_info, move_zones : ({ }), commands : ({ }));
   info->unique = data["unique"];
   info->path = data["path"];
   info->delay = data["delay"];
   info->max_population = data["population"];
   if(data["transient"])
     info->transient = 1;
   if(data["nocturnal"])
     info->nocturnal = 1;
   if(data["diurnal"])
     info->diurnal = 1;
   if(data["seasonal"]) {
     if(!arrayp(data["group"]))
       info->seasonal = ({ data["seasonal"] });
     else
       info->seasonal = data["seasonal"];
   }
   if (data["move_zone"]) {
      info->move_zones = data["move_zone"];
   }
   if (data["command"]) {
      info->commands = data["commands"];
   }
   bits = keys(data) - ({ "unique", "path", "move_zone", "population", "name", "delay", "transient", "nocturnal" });
   if (sizeof(bits)) {
      debug_printf("Unknown keys %s in npc %s\n", query_multiple_short(bits),
                   name);
      hospital_log_file("COMPILE_ERROR", "Unknown keys %s in npc %s\n",
                         query_multiple_short(bits), name);
   }
   if (_path_to_npc[info->path] && _path_to_npc[info->path] != name) {
      hospital_log_file("NPC_NAME_CLASH", "NPC path %s is used by %s and %s.\n",
                         info->path, name, _path_to_npc[info->path]);
   }
   _path_to_npc[info->path] = name;
   if (_npc_info[name]) {
      info->population = _npc_info[name]->population;
      info->no_created = _npc_info[name]->no_created;
      info->no_reused = _npc_info[name]->no_reused;
      info->no_deaths = _npc_info[name]->no_deaths;
   }
   _npc_info[name] = info;
   save_file();
}
private void parse_group(string fname, mapping data) {
   string name;
   class group_info info;
   mapping bing;
   int chance;
   string* bits;
   if (!data["name"]) {
      debug_printf("No name for group %O\n", data);
      hospital_log_file("COMPILE_ERROR", "No name for group %O\n", data);
      return 0;
   }
   name = data["name"];
   if (data["npc"] && !arrayp(data["npc"])) {
      data["npc"] = ({ data["npc"] });
   } else if (!arrayp(data["npc"])) {
      data["npc"] = ({ });
   }
   info = new(class group_info, npcs : ([ ]), move_zones : ({ }),
                                npc_commands : ([ ]));
   chance = 0;
   foreach (bing in data["npc"]) {
      if (!mapp(bing) || !stringp(bing["name"]) ||
          (!intp(bing["quantity"]) && !classp(bing["quantity"]))) {
         debug_printf("Invalid data for group (%s) %O\n", name, bing);
         hospital_log_file("COMPILE_ERROR", "Invalid data for group (%s) %O\n", name,  bing);
      } else {
         info->npcs[bing["name"]] = bing["quantity"];
         if (bing["command"]) {
            if (arrayp(bing["command"])) {
               info->npc_commands[bing["name"]] = bing["command"];
            } else {
               info->npc_commands[bing["name"]] = ({ bing["command"] });
            }
         }
      }
   }
   if (data["move_zone"]) {
      info->move_zones = data["move_zone"];
   }
   info->max_population = data["population"];
   info->protect = data["protect"];
   info->defend = data["defend"];
   info->transient = data["transient"];
   bits = keys(data) - ({ "npc", "name", "population", "move_zone", "protect", "defend", "transient", });
   if (sizeof(bits)) {
      debug_printf("Unknown keys %s in group %s\n", query_multiple_short(bits),
                   name);
      hospital_log_file("COMPILE_ERROR", "Unknown keys %s in group %s\n",
                         query_multiple_short(bits), name);
   }
   if (_group_info[name]) {
     info->storage = _group_info[name]->storage;
   }
   _group_info[name] = info;
}
protected void finish_compiling(string fname, mapping data) {
   mixed* bits;
   mapping thing;
   string name;
   foreach (name, bits in data) {
      switch (name) {
      case "zone" :
         foreach (thing in bits) {
            parse_zone(fname, thing);
         }
         break;
      case "npc" :
         foreach (thing in bits) {
            parse_npc(fname, thing);
         }
         break;
      case "group" :
         foreach (thing in bits) {
            parse_group(fname, thing);
         }
         break;
      default :
         debug_printf("Unknown data area %s in %s\n", name, fname);
         hospital_log_file("COMPILE_ERROR", "Unknown data area %s in %s\n", name, fname);
         break;
      }
   }
   _file_modified_time[fname] = unguarded( (: stat($(fname)) :))[1];
   save_file();
}
int scan_for_new_data(int force) {
  string *files;
  string fname;
  string *bits;
  debug_printf("Scan for new data.");
  if (unguarded( (: stat(__FILE__)[1] :)) !=
      _file_modified_time[__FILE__]) {
    _file_modified_time = ([ ]);
  }
  if(force) {
    _npc_info = ([ ]);
    _zone_info = ([ ]);
    _group_info = ([ ]);
  }
  files = ({ _data_directory });
  while (sizeof(files)) {
    fname = files[0];
    files = files[1..];
    if (unguarded( (: file_size($(fname)) :)) == -2) {
      bits = get_dir(fname + "/");
      if (bits) {
        bits -= ({ "RCS", ".", ".." });
        bits = filter(bits, (: $1[0] != '.' :));
        files += map(bits, (: $2 + "/" + $1 :), fname);
      }
    } else {
      if(unguarded((: stat($(fname)) :))[1] != _file_modified_time[fname] ||
         force) {
        debug_printf("Compiling %s", fname);
        DATA_HANDLER->compile_file(fname, (: finish_compiling :));
      }
    }
  }
  _file_modified_time[__FILE__] = unguarded( (: stat(__FILE__)[1] :));
  return 1;
}
int roll_dice(mixed die) {
   int result;
   int i;
   if (intp(die)) {
      return die;
   }
   if (classp(die)) {
      for (i = 0; i < die->number; i++) {
         result += random(die->die) + 1;
      }
      result += die->modifier;
      return result;
   }
   return 0;
}
int query_npc_max_population( string npc) {
   if (!_npc_info[npc]) {
      return -1;
   }
   return ((class npc_info)_npc_info[npc])->max_population;
}
int query_npc_current_population( string npc, int clean) {
   class npc_info data;
   if (!_npc_info[npc]) {
      return -1;
   }
   data = _npc_info[npc];
   if (!data->population) {
      data->population = children(npc_path(data->path));
      data->next_update = time() + POPULATION_UPDATE_TIME;
   }
   if (clean || data->next_update < time()) {
      data->population = filter(data->population, (: objectp($1) :));
      data->next_update = time() + POPULATION_UPDATE_TIME;
   }
   return sizeof(data->population);
}
int is_npc_under_max_population(string name) {
    class npc_info info;
    info = _npc_info[name];
    if (!info) {
       return 0;
    }
    if(info->transient)
      return 1;
    if (info->max_population) {
       return query_npc_current_population(name, 1) < info->max_population;
    }
    return 1;
}
int is_group_under_max_population(string name) {
    class group_info group;
    group = _group_info[name];
    if (!group) {
       return 0;
    }
    if (!group->max_population || group->transient) {
       return 1;
    }
    if (!group->storage) {
        group->storage = ({ });
    } else if (group->next_update < time()) {
        group->storage = map(group->storage, (: filter($1, (: objectp($1) :)) :));
        group->storage = filter(group->storage, (: sizeof($1) :));
        group->next_update = time() + POPULATION_UPDATE_TIME;
    }
    if (sizeof(group->storage) >= group->max_population) {
        return 0;
    }
    return 1;
}
public object load_npc_object(string npc_name) {
    class npc_info info;
    object npc;
    string zone;
    string cmd;
    if ( undefinedp(_npc_info[npc_name])) {
        debug_printf("Unable to find npc %O", npc_name);
        return 0;
    }
    info = _npc_info[npc_name];
    if(info->diurnal && !WEATHER->query_day(previous_object()))
      return 0;
    if(info->nocturnal && !WEATHER->query_day(previous_object()))
      return 0;
    if(info->seasonal &&
       member_array(WEATHER->query_season(), info->seasonal) == -1)
      return 0;
    if (stringp(info->path)) {
        if ( info->unique ) {
            npc = find_object( npc_path(info->path) );
            if ((!npc || !environment(npc)) && make_unique(npc_name)) {
               debug_printf("Unique npc %O", info);
               if (catch(npc = load_object( npc_path(info->path) ))) {
                   hospital_log_file("BAD_NPC_PATH", "Error loading %s (%s)\n", npc_name, info->path);
                   return 0;
               }
               if (!objectp(npc) || npc == 0) {
                   hospital_log_file("BAD_NPC_PATH", "Failed to load %s (%s)\n", npc_name, info->path);
                   return 0;
               }
               if ( environment( npc ) ) {
                   debug_printf("NPC unique and already exists %O", npc_name);
                   return 0;
               }
            }
        } else if(info->transient) {
          if(!_cache_inventory)
            _cache_inventory = ([ ]);
          else if(_cache_inventory[npc_name])
            _cache_inventory[npc_name] -= ({ 0 });
          if(sizeof(_cache_inventory[npc_name])) {
            npc = _cache_inventory[npc_name][0];
            _cache_inventory[npc_name] -= ({ npc });
            info->no_reused++;
          } else {
            npc = clone_object( npc_path(info->path) );
            if(npc) {
              npc->add_property("transient", 1);
              npc->add_property("npc_id", npc_name);
              npc->add_property("hospital", base_name(this_object()));
              info->no_created++;
            } else
              debug_printf("Failed to clone %s", npc_path(info->path));
          }
        } else {
            if (is_npc_under_max_population(npc_name)) {
               npc = clone_object( npc_path(info->path) );
               info->no_created++;
               if (!npc) {
                  debug_printf("Npc path does not exist %O (%O)", npc, npc_path(info->path));
               }
            } else {
               debug_printf("NPC over max population %O", npc_name);
            }
        }
    } else {
        debug_printf("Broken npc data %O", info->path);
        return 0;
    }
    if (npc && !info->transient) {
        if( info->population == 0 )
            info->population = ({ });
        info->population += ({ npc });
        npc->add_property("npc_id", npc_name);
        foreach (zone in info->move_zones) {
            npc->add_move_zone(zone);
        }
        foreach (cmd in info->commands) {
            npc->init_command(cmd, 2);
        }
    }
    return npc;
}
public object *load_group_npcs(string group_name) {
    class group_info group;
    int quantity;
    int i;
    object *npcs;
    string npc_name;
    object ob;
    object ob_bing;
    string cmd;
    if ( undefinedp(_group_info[group_name]) ||
         !is_group_under_max_population(group_name)) {
        return 0;
    }
    group = _group_info[group_name];
    npcs = ({ });
    foreach (npc_name, quantity in group->npcs) {
        quantity = roll_dice(quantity);
        for (i = 0; i < quantity; i++) {
            ob = load_npc_object(npc_name);
            if (!ob) {
               npcs->move("/room/rubbish");
               return ({ });
            }
            npcs += ({ ob });
            if (group->npc_commands[npc_name]) {
               foreach (cmd in group->npc_commands[npc_name]) {
                  ob->init_command(cmd, 2);
               }
            }
        }
    }
    if (!group->storage) {
        group->storage = ({ });
    }
    group->storage += ({ npcs });
    npcs->add_property("group_id", group_name);
    foreach (ob in npcs) {
       foreach (ob_bing in npcs) {
          if (ob != ob_bing) {
             ob->add_follower(ob_bing);
             if (group->defend) {
               ob->add_defender(ob_bing);
             }
             if (group->protect) {
                ob->add_protector(ob_bing);
             }
          }
       }
    }
    return npcs;
}
public class npc_info query_npc_info( string npc ) {
    if ( !_npc_info ) {
        return 0;
    }
    return _npc_info[ npc ];
}
mapping query_debug_npc_info() {
   return _npc_info;
}
public class group_info query_group_info( string group ) {
    if ( !_group_info ) {
        return 0;
    }
    return _group_info[ group ];
}
void npc_died(object ob) {
   string npc_id;
   class npc_info info;
   int i;
   mixed* stuff;
   npc_id = ob->query_property("npc_id");
   info = _npc_info[npc_id];
   if (!info || !npc_id) {
      return ;
   }
   info->population -= ({ ob });
   info->no_deaths++;
   npc_id = ob->query_property("group_id");
   stuff = _group_info[npc_id]->storage;
   if (sizeof(stuff)) {
      for (i = 0; i < sizeof(stuff); i++) {
         stuff[i] -= ({ ob, 0 });
      }
      _group_info[npc_id]->storage = filter(_group_info[npc_id]->storage,
                                             (: sizeof($1) :));
   }
}
mapping query_all_npc_info() {
   return _npc_info;
}
mapping query_all_group_info() {
   return _group_info;
}
mapping query_all_zone_info() {
   return _zone_info;
}
private int count_chances_in_zone(string zone) {
    class zone_info info;
    int chance;
    info = _zone_info[zone];
    if (!zone) {
       return 0;
    }
    chance = info->npc_chance + info->group_chance + info->zone_chance;
    return chance;
}
private object* create_npcs_in_zone(string zone, int pos) {
    class zone_info info;
    string extra;
    string npc;
    object ob;
    object* obs;
    int chance;
    info = _zone_info[zone];
    if (!zone) {
       return ({ });
    }
    if (pos < info->npc_chance) {
       foreach (npc, chance in info->npcs) {
          if (pos < chance) {
             ob = load_npc_object(npc);
             if (ob) {
               if(environment(ob) == this_object())
                 debug_printf("Reused %s in %s", npc, zone);
               else
                 debug_printf("Created %s in %s", npc, zone);
                return ({ ob });
             }
          }
          pos -= chance;
       }
    }
    pos -= info->npc_chance;
    if (pos < info->group_chance) {
       foreach (npc, chance in info->groups) {
          if (pos < chance) {
             obs = load_group_npcs(npc);
             if (sizeof(obs)) {
                return obs;
             }
          }
          pos -= chance;
       }
    }
    pos -= info->group_chance;
    foreach (extra, chance in info->zones) {
        if (pos < chance) {
           return load_random_npc(extra, -1, -1);
        }
    }
    return ({ });
}
public object *load_random_npc(string zone, int wealth, int busy) {
    int chance;
    int pos;
    if (_disable_npc_generation) {
        return ({ });
    }
    if (_zone_info[zone + "-w" + wealth + "-b" + busy]) {
       zone = zone + "-w" + wealth + "-b" + busy;
    } else if (_zone_info[zone + "-w" + wealth]) {
       zone = zone + "-w" + wealth;
    } else if (_zone_info[zone + "-b" + busy]) {
       zone = zone + "-b" + busy;
    }
    if (!_zone_info[zone]) {
        return ({ });
    }
    if(_zone_info[zone]->busy &&
       _zone_info[zone]->busy < random(random(100)))
      return ({ });
    chance = count_chances_in_zone(zone);
    if (!chance) {
       return ({ });
    }
    pos = random(chance);
    return create_npcs_in_zone(zone, pos);
}
int do_report() {
    string name;
    class group_info group;
    class npc_info npc;
    string txt;
    int total;
    int max;
    int pop;
    txt = "";
    total = 0;
    txt += "%^WHITE%^NPCs%^RESET%^\n";
    foreach( name, npc in _npc_info ) {
      reset_eval_cost();
      if(stringp(npc->path) && file_size(npc_path(npc->path) + ".c") > 0) {
        pop = query_npc_current_population(name, 0);
      } else {
        pop = 0;
      }
      if(npc->transient)
        txt += sprintf( "$I$5=Name: %s. (%s) (Transient) Reused %d Created %d Died %d\n", name + "",
                        (stringp(npc->path)?npc->path:"Broken!"),
                        npc->no_reused, npc->no_created, npc->no_deaths);
      else
        txt += sprintf( "$I$5=Name: %s. (%s) Population: (%d/%d) Created %d Died %d\n", name + "",
                        (stringp(npc->path)?npc->path:"Broken!"),
            pop, npc->max_population, npc->no_created, npc->no_deaths );
        total += pop;
        max += npc->max_population;
    }
    txt += "$I$0=%^WHITE%^Groups%^RESET%^\n";
    foreach( name, group in _group_info ) {
      if(group->transient)
        txt += sprintf( "$I$5=Name: %s. (%s) (Transient)\n", name,
            query_multiple_short(keys(group->npcs)));
      else
        txt += sprintf( "$I$5=Name: %s. (%s) Population: (%d/%d)\n", name,
            query_multiple_short(keys(group->npcs)),
            sizeof( group->storage ), group->max_population );
    }
    txt += "$I$0=%^WHITE%^Cache%^RESET%^\n";
    foreach(name in keys(_cache_inventory))
      _cache_inventory[name] -= ({ 0 });
    foreach(name, group in _cache_inventory)
      txt += sprintf("$I$5=Name: %s %d\n", name, sizeof(group));
    txt += "\nTotal NPCs in hospital: " + total + "/" +
            max + ".\n";
    write("$P$Report$P$" + txt );
    return 1;
}
void init() {
  object ob;
  ob = this_player();
  add_command("report", "", (: do_report :));
  add_command("scan", "", (: scan_for_new_data :));
  if(ob->query_property("npc_id") && ob->query_property("hospital") &&
     ob->query_property("hospital") == base_name(this_object())) {
    if(!_cache_inventory[ob->query_property("npc_id")])
      _cache_inventory[ob->query_property("npc_id")] = ({ ob });
    else if(sizeof(_cache_inventory[ob->query_property("npc_id")]) >
            _max_cache)
      ob->move("/room/rubbish");
    else
      _cache_inventory[ob->query_property("npc_id")] += ({ ob });
  } else if(base_name(ob) == "/obj/corpse")
    ob->move("/room/rubbish");
}
int no_attack() { return 1; }
mapping query_dynamic_auto_load() {
    string group_name;
    string npc;
    class group_info data;
    class npc_info npc_data;
    mapping tmp;
    mapping tmp2;
    tmp = allocate_mapping( sizeof( _group_info ) );
    foreach( group_name, data in _group_info ) {
        tmp[ group_name ] = data->storage;
    }
    tmp2 = allocate_mapping( sizeof( _npc_info) );
    foreach( npc, npc_data in _npc_info ) {
        tmp2[ npc ] = npc_data->population;
    }
    return ([ file_name( this_object() ) : tmp, "npcs" : tmp2 ]);
}
void init_dynamic_arg( mapping tmp ) {
    string group_name;
    object *npcs;
    if ( tmp[ file_name( this_object() ) ] ) {
        foreach( group_name, npcs in tmp[ file_name( this_object() ) ] ) {
            if (_group_info[group_name]) {
               _group_info[ group_name ]->storage = npcs;
            }
        }
        foreach( group_name, npcs in tmp[ "npcs" ]) {
            if (_npc_info[group_name]) {
               _npc_info[ group_name ]->population = npcs;
            }
        }
    }
}
mixed query_all_npcs() {
    return values( map( _group_info, (: $2->storage :) ) );
}
mapping query_inventory_cache() {
  return copy(_cache_inventory);
}
string* query_registered_npcs() {
    return keys( _npc_info );
}

==================================================
FILE: key.c
==================================================

inherit "/std/object";
#include <shops/engrave.h>
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_name("key");
  set_long("A key.  Wonder where it fits?.\n");
  add_plural("keys");
  set_short("key");
  add_property(ENGRAVE_PROP, 1);
  if(!do_setup) {
    this_object()->setup();
  }
}
void set_key( string str, string prop ) {
  string *bits;
  int i;
  set_short( str + " key" );
  set_main_plural( str + " keys" );
  set_name( "key" );
  add_plural( "keys" );
  bits = explode( str, " " );
  for( i = 0; i < sizeof( bits ); i ++ ) {
    add_adjective( bits[i] );
  }
  add_property( prop, 1 );
  set_value( 0 );
  set_weight( 1 );
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}

==================================================
FILE: leaflet.c
==================================================

inherit "/std/object";
private int page;
private mixed *pages;
int do_open(int page_no);
void create() {
   do_setup++;
   ::create();
   do_setup--;
   pages = ({ ({ }) });
   if ( !do_setup )
      this_object()->setup();
  add_help_file("leaflet");
}
int query_leaflet() { return 1; }
int query_page() { return page; }
mixed *query_pages() { return copy( pages ); }
void init() {
   add_command( "turn", "[a] page of <direct:object>" );
   add_command( "open", "<direct:object> to [page] <number>",
                (: do_open($4[1]) :));
}
void set_no_pages( int number ) {
   int i;
   if ( number < 1 ) {
      number = 1;
   }
   pages = ({ });
   for ( i = 0; i < number; i++ ) {
      pages += ({ ({ }) });
   }
}
varargs void set_read_mess( mixed mess, string lang, int size ) {
   ::set_read_mess( mess, lang, size );
   pages[ page ] = query_read_mess();
}
mixed add_read_mess( mixed mess, string type, string lang, int size ) {
   mixed ret;
   ret = ::add_read_mess( mess, type, lang, size );
   pages[ page ] = query_read_mess();
   return ret;
}
int query_open_page() { return page + 1; }
void set_open_page( int number ) {
   if ( ( number < 1 ) || ( number > sizeof( pages ) ) ) {
      number = 1;
   }
   page = number - 1;
   ::set_read_mess( pages[ page ] );
}
int do_turn() {
   set_open_page( page + 2 );
   return 1;
}
int do_open(int page_no) {
   if ( ( page_no < 1 ) || ( page_no > sizeof( pages ) ) ) {
      add_failed_mess("The page no " + page_no + " does not exist.\n");
      return 0;
   }
   set_open_page(page_no);
   return 1;
}
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/std/leaflet" ) {
      return ([ ]);
   }
   return int_query_static_auto_load();
}
mapping query_dynamic_auto_load() {
   return ([
      "::" : ::query_dynamic_auto_load(),
      "page" : page,
      "pages" : copy( pages ),
   ]);
}
void init_dynamic_arg( mapping map ) {
   if ( !mapp( map ) ) {
      return;
   }
   if ( map[ "::" ] ) {
      ::init_dynamic_arg( map[ "::" ] );
   }
   page = map[ "page" ];
   if ( pointerp( map[ "pages" ] ) ) {
      pages = map[ "pages" ];
      set_open_page( page + 1 );
   }
}
string query_read_short(object player, int ignore_labels) {
   string ret;
   if (page == 0) {
      ret = ::query_read_short(player, 1);
   } else {
      ret = ::query_read_short(player, 0);
   }
   return "page " + query_num(page) + " of " + ret;
}

==================================================
FILE: learning.c
==================================================

#include <money.h>
#include <tasks.h>
class step {
  string *blurbs;
  string skill;
  int difficulty;
  string *responses;
  string *params;
  string award_mess;
  string succeed_mess;
  string fail_mess;
}
class lesson {
  mapping minimum_skills;
  mapping maximum_skills;
  string *materials;
  int cost;
  string currency;
  string *lesson_ending;
  object teacher;
  class step *plan;
}
private nosave mapping _lessons;
private nosave int current_step;
private nosave int attempt;
int lesson_response(string, object, int, string);
int register_lesson(string name, mapping minimum_skills,
                    mapping maximum_skills, string *materials, int cost,
                    string currency, string *lesson_ending, object teacher ) {
  if(!_lessons)
    _lessons = ([ ]);
  if(_lessons[name])
    return 0;
  _lessons[name] = new(class lesson,
                       minimum_skills : minimum_skills,
                       maximum_skills : maximum_skills,
                       materials : materials,
                       cost : cost,
                       currency : currency,
                       lesson_ending : lesson_ending,
                       teacher : teacher
                       );
  return 1;
}
int add_step( string lesson_name, string *blurbs, string skill, int diff,
        string *responses, string *params, string award_mess, string succeed_mess,
        string fail_mess) {
  if(!_lessons)
    _lessons = ([ ]);
  if( !_lessons[lesson_name] ){
    return 0;
  }
  if( !_lessons[lesson_name]->plan ){
    _lessons[lesson_name]->plan = ({ });
  }
  _lessons[lesson_name]->plan += ({ new(class step,
          blurbs : blurbs,
          skill : skill,
          difficulty : diff,
          responses : responses,
          params : params,
          award_mess : award_mess,
          succeed_mess : succeed_mess,
          fail_mess : fail_mess
          ) });
  return 1;
}
int has_required_skills( string name, object player ) {
  string skill;
  int p_level;
  foreach( skill in (keys(_lessons[name]->minimum_skills)) ){
    p_level = player->query_skill(skill);
    if( p_level < _lessons[name]->minimum_skills[skill] ){
      return 0;
    }
  }
  foreach( skill in (keys(_lessons[name]->maximum_skills)) ){
    p_level = player->query_skill(skill);
    if( p_level > _lessons[name]->maximum_skills[skill] ){
      return 0;
    }
  }
  return 1;
}
int has_required_materials( string name, object player ) {
  string mat;
  foreach( mat in _lessons[name]->materials ) {
    if( sizeof( filter_array(deep_inventory(player),
           (: ($1)->query_short() :) ) ) ){
      return 1;
    }
  }
  return 0;
}
int has_required_cash( string name, object player ) {
  if(player->query_value_in(_lessons[name]->currency) < _lessons[name]->cost) {
    return 0;
  } else {
    return 1;
  }
}
int start_lesson(string name, object player) {
  string *needed;
  if(!_lessons[name])
    return notify_fail(player, "Sorry, it's not clear what you want to learn "
                "here.\n");
  needed = ({ });
  if(!has_required_skills(name, player))
    needed += ({ "skills" });
  if(!has_required_materials( name, player ))
    needed += ({ "materials" });
  if(!has_required_cash( name, player ))
    needed += ({ "cash" });
  if(sizeof(needed)) {
    debug_printf( "Player doesn't have the correct %s\n",
                  query_multiple_short(needed) );
    return add_failed_mess("Sorry, You don't have the correct " +
                  query_multiple_short(needed) + " to learn today.\n");
  }
  call_out("lesson_step", 1, name, player, 0);
  return 1;
}
string *query_lessons() { return keys(_lessons); }
protected void lesson_step(string name, object student, int lessonstep) {
  string str;
  class step current;
  object teacher = _lessons[name]->teacher;
  int i;
  current = _lessons[name]->plan[lessonstep];
  str = "";
  for(i=0; i<sizeof(current->responses); i++) {
    if(current->params && sizeof(current->params) > i) {
      str = " <string:'" + current->params[i] + "'>";
      student->add_command(current->responses[i], this_object(), str,
                           (: lesson_response($(name), $(student),
                                              $(lessonstep), $4) :));
    } else {
      str = "";
      student->add_command(current->responses[i], this_object(), str,
                           (: lesson_response($(name), $(student),
                                              $(lessonstep), "") :));
    }
  }
  foreach( str in (current->blurbs) ) {
   if( teacher )
      teacher->queue_command(str);
    else
      tell_object(student, str);
  }
}
int lesson_response(string name, object student, int lessonstep, string args) {
  class step current;
  if(this_player() != student)
    return 0;
  current = _lessons[name]->plan[lessonstep];
  if(sizeof(current->params) &&
     member_array(args[0], current->params) == -1)
    return student->add_failed_mess(this_object(), "Invalid response.\n",
            ({ }));
  switch(TASKER->perform_task(student, current->skill, current->difficulty,
                              TM_FIXED)) {
  case AWARD:
    tell_object(student, "%^YELLOW%^"+current->award_mess+"%^RESET%^\n");
  case SUCCEED:
    tell_object( student, current->succeed_mess + "\n");
    student->remove_object(this_object(), 1);
    if( (sizeof(_lessons[name]->plan)-1) == lessonstep ) {
      tell_creator("belle", "Lesson is on its last step: %d\n", lessonstep );
      call_out( "lesson_end", 1, name, student );
      return 1;
    } else {
      call_out("lesson_step", 1, name, student, ++lessonstep);
    }
    break;
  default:
    tell_object(student, current->fail_mess + "\n" );
    break;
  }
  return 1;
}
int lesson_end ( string name, object student ) {
  string str;
  object teacher = _lessons[name]->teacher;
  foreach( str in (_lessons[name]->lesson_ending) ) {
    if( teacher )
      teacher->queue_command(str);
    else
      tell_object(student, str);
  }
  return 1;
}

==================================================
FILE: lightable.c
==================================================

#include <fuel_handler.h>
#define HOLD_COMMAND "/cmds/living/ho_ld"
#define DEPARTURES "/room/departures"
inherit "/obj/weapon";
int max_fuel, fuel, lit, brightness, time, hold;
string empty_mess;
mixed fuel_messages;
int set_lit(int);
void create() {
   ::create();
   add_extra_look( this_object() );
}
void init() {
   this_player()->add_command( "light", this_object() );
   this_player()->add_command( "dowse", this_object() );
   this_player()->add_command( "extinguish", this_object() );
}
varargs string short( int dark ) {
   if( lit )
      return "lit "+ ::short( dark );
   else
      return ::short( dark );
}
void out_of_fuel() {
   object env;
   fuel = 0;
   lit = 0;
   set_lit( 0 );
   FUEL_HANDLER->remove_burner( this_object() );
   if( !environment() ) return;
   env = environment();
   if( living( env ) ) {
      tell_object( env, the_short() +" goes out.\n" );
      tell_room( environment( env ),
            env->the_short() +"'s "+ short() +" goes out.\n", env );
   } else {
      tell_room( env, the_short() +" goes out.\n" );
   }
}
void delayed_light() {
   lit = 1;
}
int hold_thing() {
   if( !query_wielded() )
      return HOLD_COMMAND->cmd( ({ this_object() }) );
   else
      return 1;
}
int set_lit( int i ) {
   if( !i ) {
      if( !query_property( "unextinguishable" ) ) {
         lit = 0;
         FUEL_HANDLER->remove_burner( this_object() );
         remove_adjective( "lit" );
         set_light( 0 );
         return 0;
      }
   } else {
      if( !query_property( "unlightable" ) && fuel > 0 ) {
         if( lit )
            return 1;
         if( hold && !hold_thing() )
            return 0;
         call_out( (: delayed_light :), 2 );
         FUEL_HANDLER->add_burner( this_object() );
         add_adjective( "lit" );
         set_light( brightness );
         return 1;
      }
   }
}
mixed set_holder( object ob, int pos ) {
   if( lit && hold && !ob && environment( this_player() )
       && file_name( environment( this_player() ) ) != DEPARTURES )
      if( !set_lit( 0 ) ) {
         tell_object( this_player(), "You extinguish "+ the_short() +".\n" );
         tell_room( environment( this_player() ), this_player()->the_short() +
               " extinguishes "+ the_short() +".\n", this_player() );
     }
   return ::set_holder( ob, pos );
}
int query_lit() {
   return lit;
}
int do_light() {
   if( lit )
      return notify_fail( the_short() +" is already lit.\n" );
   if( !fuel )
      return notify_fail( the_short() +" "+ empty_mess +"\n" );
   if( !set_lit( 1 ) )
      return notify_fail( "You cannot light "+ the_short() +".\n" );
   this_player()->add_succeeded_mess( this_object(), "$N $V $D.\n", ({ }) );
   return 1;
}
int do_dowse() {
   if( !lit )
      return notify_fail( the_short() +" is not lit.\n" );
   if( set_lit( 0 ) )
      return notify_fail( "You cannot extinguish "+ the_short() +".\n" );
   this_player()->add_succeeded_mess( this_object(), "$N $V $D.\n", ({ }) );
   return 1;
}
int do_extinguish() {
   return do_dowse();
}
void set_fuel_messages( mixed msgs ) {
   fuel_messages = msgs;
}
mixed query_fuel_messages() {
   return fuel_messages;
}
void set_max_fuel( int i ) {
   max_fuel = i;
}
int query_max_fuel() {
   return max_fuel;
}
void set_fuel( int i ) {
   fuel = i;
   if( fuel > max_fuel )
      fuel = max_fuel;
}
int query_fuel() {
   return fuel;
}
string current_fuel_message() {
   mixed messages;
   int fuel_percent, size, i;
   string fuel_string = "";
   if( fuel < 1 )
      return "It "+ empty_mess;
   messages = query_fuel_messages();
   size = sizeof( messages );
   if( !size )
      return "This item needs a creator.  It is broken and lonely.";
   if( size < 2 )
      return messages[0];
   fuel_percent = fuel * 99 / max_fuel;
   if( intp( messages[1] ) ) {
      for( i = 1; i < size; i += 2 ) {
         if( messages[i] > fuel_percent ) {
            fuel_string = messages[i-1];
            break;
         }
      }
      if( fuel_string == "" )
         fuel_string = messages[ size - 2 ];
   } else {
      fuel_string = messages[ fuel_percent * size / 100 ];
   }
   return fuel_string;
}
void set_empty_mess( string msg ) {
   empty_mess = msg;
}
string query_empty_mess() {
   return empty_mess;
}
void set_brightness( int i ) {
   brightness = i;
}
int query_brightness() {
   return brightness;
}
void set_hold_required( int hands ) {
   hold = hands;
}
int query_hold_required() {
   return hold;
}
string extra_look() {
   string lit_str;
   if( lit )
      lit_str = "It is lit.  ";
   else
      lit_str = "It is not currently lit.  ";
   return lit_str + current_fuel_message() +"\n";
}
mixed query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "fuel" : fuel,
             "lit" : lit,
           ]);
}
void init_dynamic_arg(mapping arg, object bing ) {
   fuel = arg["fuel"];
   ::init_dynamic_arg(arg["::"], bing);
   set_lit(arg["lit"]);
}
void consume_fuel() {
   fuel -= FUEL_TIME;
   if( fuel < 1 )
      out_of_fuel();
}
int query_value() {
   return (int)( ::query_value() * fuel / max_fuel );
}
varargs int move( mixed dest, string messin, string messout ) {
   object destination;
   if( objectp( dest ) ) {
      destination = dest;
   } else {
      destination = load_object( dest );
   }
   if( ( inherits( "/std/container", destination ) &&
         !living( destination ) ) ||
       inherits( "/std/uwater", destination ) ||
       inherits( "/std/water_inside", destination ) ||
       inherits( "/std/water_outside", destination ) ) {
      set_lit( 0 );
   }
   return ::move( dest, messin, messout );
}

==================================================
FILE: map.c
==================================================

#include <terrain_map.h>
inherit "/std/object";
#define WORLD_MAP TERRAIN_MAP_WORLD_MAP
private nosave int *_area;
private nosave int _detail;
private nosave string *_features;
private nosave mapping _locations;
private nosave object _env, _pl;
private nosave int *_co_ords;
private nosave int _fudge;
void create() {
  do_setup++;
  ::create();
  do_setup--;
  add_alias("map");
  add_plural("maps");
  _locations = ([ ]);
  add_extra_look(this_object());
  if(!do_setup) {
    this_object()->setup();
  }
}
string extra_look() {
  return "Marked on the map are " +
    query_multiple_short(_features->query_base_description() +
                         keys(_locations)) + ".";
}
int filter_features(string feature) {
#ifdef DEBUG
  debug_printf("%s %d %d", feature,
               feature->query_max_range() / TERRAIN_MAP_ONE_MILE,
               _detail / TERRAIN_MAP_ONE_MILE);
#endif
  return (!feature->query_max_range() ||
          feature->query_max_range() >= _detail);
}
void setup_map(int x1, int y1, int x2, int y2, int detail) {
  _area = ({ x1, y1, x2, y2 });
  _detail = detail;
  _features = WORLD_MAP->query_features_in_region(x1, y1, x2, y2);
  _features = filter(_features, "filter_features", this_object());
}
void set_map(string area) {
  int width, height, detail, x1, y1, x2, y2;
  switch(area) {
  case "sur":
    width = (TERRAIN_MAP_ONE_MILE * 300);
    height = (TERRAIN_MAP_ONE_MILE * 200);
    x1 = -150575040 - width;
    y1 = -2173248 - height;
    x2 = -150575040 + width;
    y2 = -2173248 + height;
    detail = (TERRAIN_MAP_ONE_MILE * 50);
    break;
  case "world":
    x1 = TERRAIN_MAP_WORLD_LOW_X / 10;
    y1 = TERRAIN_MAP_WORLD_LOW_Y / 10;
    x2 = TERRAIN_MAP_WORLD_HIGH_X / 10;
    y2 = TERRAIN_MAP_WORLD_HIGH_Y / 10;
    detail = (TERRAIN_MAP_ONE_MILE * 200);
    break;
  }
  setup_map(x1, y1, x2, y2, detail);
}
void recalc_coords() {
  int accuracy;
  if(!_co_ords || this_player() != _pl || environment(this_player()) != _env) {
    _pl = this_player();
    _env = environment(_pl);
    _co_ords = _env->query_co_ord();
    accuracy = 500 - _pl->query_skill_bonus("other.direction");
    if(accuracy < 1)
      accuracy = 1;
    _fudge = TERRAIN_MAP_ONE_MILE * accuracy;
    _co_ords[0] += -(_fudge/2) + random(_fudge);
    _co_ords[1] += -(_fudge/2) + random(_fudge);
    _co_ords[2] += -(_fudge/2) + random(_fudge);
  }
}
int do_consult(string find) {
  string feature, *res;
  object ob;
  mapping direcs;
  if(this_player()->check_dark(environment(this_player())->query_light()))
    return notify_fail("Sorry the light levels are not conducive to "
                       "reading a map.\n");
  recalc_coords();
  if(_co_ords[0] < _area[0] || _co_ords[1] < _area[1] ||
     _co_ords[0] > _area[2] || _co_ords[1] > _area[3])
    return notify_fail("Sorry, you do not appear to be anywhere on this "
                       "map.\n");
  res = ({ });
  foreach(feature in _features) {
    ob = feature->query_region_ob();
    if(ob) {
#ifdef DEBUG
      debug_printf("%O max range %d", feature,
                   feature->query_max_range()/TERRAIN_MAP_ONE_MILE);
#endif
      direcs = ob->query_feature_desc_from(_co_ords[0], _co_ords[1],
                                           _co_ords[2], 1);
      if(direcs) {
        if(find == "" || strsrch(lower_case(feature->query_base_description()),
                   lower_case(find)) != -1)
          res += ({ feature->calc_map_feature_desc(direcs, _fudge) });
      }
    }
  }
  if(res == ({ })) {
    if(find != "")
      return notify_fail("You cannot find " + find + " on your map.\n");
    else
      return notify_fail("You cannot find anything on your map.\n");
  }
  write("You consult your map and estimate that " +
        query_multiple_short(res) + "\n");
  this_player()->add_succeeded_mess(this_object(), "");
  return 1;
}
int do_add(string location) {
  if(member_array(lower_case(location), keys(_locations)) != -1)
    return notify_fail("A location with the name " + location +
                       " already exists on this map.\n");
  _locations[lower_case(location)] = _co_ords;
  this_player()->add_succeeded_mess(this_object(), "$N $V a new location "
                                    "to $D.\n");
  return 1;
}
void init() {
  this_player()->add_command("consult", this_object(), "<direct:object>",
                             (: do_consult("") :));
  this_player()->add_command("find", this_object(),
                             "<string'place'> on <direct:object>",
                             (: do_consult($4[0]) :));
  this_player()->add_command("add", this_object(),
                             "<string'description'> to <direct:object>",
                             (: do_add($4[0]) :));
}
mapping int_query_static_auto_load() {
  return ([
    "::": ::int_query_static_auto_load(),
    "features": _features,
    "detail": _detail,
    "area": _area,
  ]);
}
mixed query_static_auto_load() {
  if((file_name(this_object()))[0..7] != "/std/map" )
    return 0;
  return int_query_static_auto_load();
}
void init_static_arg(mapping args) {
  if(args["::"])
    ::init_static_arg(args["::"]);
  if(args["features"])
    _features = args["features"];
  if(args["detail"])
    _detail = args["detail"];
  if(args["area"])
    _area = args["area"];
}

==================================================
FILE: mineral.c
==================================================

#include <mineral.h>
#define HANDLER "/obj/handlers/cmr_handler"
#define PRICE_INDEX "/obj/handlers/cpi_handler"
#define DEFAULT_MARKET "Ankh-Morpork"
inherit "/std/object";
int check_tool( object *tools );
nosave string mineral;
void create() {
   write( "If you've not just logged in and are waiting for your "
         "inventory to be regenerated, please bug report this location, "
         "as it's using the obsolete mineral object.\n" );
   ::create();
}
void init() {
   this_player()->add_command( "chip", this_object(), "<direct:object> 'with' <indirect:object>" );
   this_player()->add_command( "chip", this_object(), "<direct:object> 'using' <indirect:object>" );
   this_player()->add_command( "smash", this_object(), "<direct:object> 'with' <indirect:object>" );
   this_player()->add_command( "smash", this_object(), "<direct:object> 'using' <indirect:object>" );
}
varargs void make_mineral( string word, int number, string *inputs ) {
   string adjective, material_adjective, colour_code, noun, *args;
   mineral = word;
   material_adjective = (string)HANDLER->query_material_adjective( mineral );
   colour_code = (string)HANDLER->query_material_ansi_colour( mineral );
   set_weight( number );
   switch( number ) {
      case 0..PEBBLE:
         adjective = "small";
         noun = "pebble";
         break;
      case PEBBLE+1..STONE:
         adjective = "medium sized";
         noun = "stone";
         break;
      case STONE+1..ROCK:
         adjective = "large";
         noun = "rock";
         break;
      default:
         adjective = "huge";
         noun = "boulder";
   }
   if ( !pointerp( inputs ) )
      args = allocate( 10 );
   else
      args = inputs + ({ 0, 0, 0, 0, 0 });
   if ( !args[0] ) {
      set_name( noun );
      add_plural( noun +"s" );
   } else {
      set_name( args[0] );
      if ( !args[3] )
         add_plural( args[0] +"s" );
      else
         add_plural( args[3] );
   }
   if ( !args[1] ) {
      set_short( colour_code + material_adjective +" "+ noun +"%^RESET%^" );
      set_main_plural( colour_code + material_adjective +" "+ noun +
            "s%^RESET%^" );
   } else {
      set_short( args[1] );
      if ( !args[4] )
         set_main_plural( args[1] +"s" );
      else
         set_main_plural( args[4] );
   }
   if ( !args[2] )
      set_long( "This is a "+ adjective +" lump of $mineral$.\n" );
   else
      set_long( args[2] );
   add_adjective( ({ adjective }) + explode( material_adjective, " " ) );
}
string long( string str, int dark ) {
   string bit1, bit2, ret;
   sscanf( ::long( str, dark ), "%s$mineral$%s", bit1, bit2 );
   ret = bit1 + (string)HANDLER->identify_material( mineral, this_player(), 1 )
      + bit2;
   return ret;
}
string *query_adjectives() {
   string ret;
   ret = HANDLER->identify_material( mineral, this_player(), 0 );
   return ::query_adjectives() + ({ ret });
}
string *parse_command_adjectiv_id_list() {
   string ret;
   ret = HANDLER->identify_material( mineral, this_player(), 0 );
   return ::parse_command_adjectiv_id_list() + ({ ret });
}
string query_mineral() { return mineral; }
string query_material() { return mineral; }
int query_value() {
  return ( query_weight() * (int)(PRICE_INDEX)->query_price( mineral,
            DEFAULT_MARKET ) );
}
int query_value_in( string word ) {
  if ( ( !word || ( word == "" ) ) || ( word == "default" ) )
    word = DEFAULT_MARKET;
  return ( query_weight() * (int)(PRICE_INDEX)->query_price( mineral, word ) );
}
int do_chip( object *tools ) {
   object chip;
   if ( !check_tool( tools ) )
      return 0;
   if ( query_weight() == 1 ) {
      write( "This piece of "+ (string)HANDLER->identify_material( mineral,
                this_player(), 0 ) +" is already a chip.\n" );
      return 0;
   }
   set_weight( query_weight() - 1 );
   chip = clone_object( MINERAL );
   chip->make_mineral( mineral, 1 );
   chip->move( environment() );
   this_player()->add_succeeded( tools[0] );
   return 1;
}
int do_smash( object *tools ) {
   int i, j, largest, number, size;
   object debris, remains;
   if ( !check_tool( tools ) )
      return 0;
   largest = this_player()->query_max_weight();
   if ( largest >= query_weight() )
      largest = query_weight();
   else {
      remains = clone_object( MINERAL );
      remains->make_mineral( mineral, query_weight() - largest );
      remains->move( environment() );
   }
   tools[ 0 ]->hit_weapon( largest, "blunt" );
   number = 2 + random( 4 );
   for ( i = 0; i < 8; i++ ) {
      largest /= number;
      for ( j = 1; j < number; j++ ) {
         size = ( 3 * largest + random( largest ) ) / 4;
         if ( size ) {
            debris = clone_object( MINERAL );
            debris->make_mineral( mineral, size );
            debris->move( environment() );
          }
       }
   }
   this_player()->add_succeeded( tools[0] );
   move( "/room/rubbish" );
   return 1;
}
int check_tool( object *tools ) {
   string tool;
   object *held;
   if ( sizeof( tools ) > 1 ) {
      write( "You only need to use one tool at a time.\n" );
      return 0;
   }
   if ( !sizeof( tools ) ) {
      write( "You need to use a tool of some sort.\n" );
      return 0;
   }
   held = this_player()->query_holding();
   if ( member_array( tools[0], held ) == -1 ) {
      write( "You need to use a tool that you are holding.\n" );
      return 0;
   }
   tool = tools[0]->query_name();
   if ( member_array( tool, ({ "pickaxe", "pick" }) ) == -1 ) {
      write( "You need to use a tool appropriate to the job.\n" );
      return 0;
   }
   return 1;
}
mixed *stats() {
   return ::stats() + ({
      ({ "mineral", mineral, }),
   });
}
mapping int_query_static_auto_load() {
   return ([
      "::" : ::int_query_static_auto_load(),
      "mineral" : mineral,
   ]);
}
void init_static_arg( mapping map ) {
   if ( map["::"] )
      ::init_static_arg( map["::"] );
   if ( !undefinedp( map["mineral"] ) )
      mineral = map["mineral"];
}
mixed query_static_auto_load() {
   if ( file_name( this_object() )[ 0 .. 11 ] == "/std/mineral" )
      return int_query_static_auto_load();
   return ([ ]);
}

==================================================
FILE: object.c
==================================================

#include <cmr.h>
inherit "/std/basic/extra_look";
inherit "/std/basic/enchant";
inherit "/std/basic/id";
inherit "/std/basic/misc";
inherit "/std/basic/property";
inherit "/std/basic/read_desc";
inherit "/std/basic/auto_load";
inherit "/std/basic/help_files";
inherit "/std/basic/theft_callback";
inherit "/std/basic/effects";
#define AUTO_LOAD_TAG "basic.object";
nosave int do_setup;
nosave string create_me;
nosave string colour;
private string* _materials;
nosave object player;
void create() {
  _materials = ({ });
  extra_look::create();
  id::create();
  misc::create();
  property::create();
  read_desc::create();
  effects::create();
  seteuid( (string)"/secure/master"->
      creator_file( file_name( this_object() ) ) );
  if ( this_player() ) {
    create_me = (string)this_player()->query_name();
  } else {
    create_me = "who knows";
  }
  if ( !do_setup ) {
    this_object()->setup();
  }
}
void set_name( string word ) {
  if ( query_name() && ( query_name() != "object" ) ) {
    ::set_name(word);
    return;
  }
  ::set_name(word);
  if ( !short_d ) {
    short_d = word;
  }
  add_plural( pluralize( word ) );
}
string query_long_details(string arg, int dark, object looker) {
   string stuff;
   stuff = "";
   if ( this_player()->query_see_octarine() ) {
      stuff += enchant_string();
   }
   if ( sizeof( query_read_mess() ) ) {
      stuff += "It appears to have something written on it.\n";
   }
   return stuff;
}
string replace_long_dollars(object player, string text) {
   if ( colour ) {
      text = replace( text, "$colour$",
          (string)CMR_HANDLER->identify_colour( colour, player ) );
   }
   if ( sizeof(_materials) ) {
      text = replace( text, "$material$",
          (string)CMR_HANDLER->identify_material( _materials[0], player, 1 ) );
   }
   return text;
}
string long( string word, int dark ) {
   string stuff;
   stuff = ::long( word, dark );
   stuff += calc_extra_look();
   stuff += query_long_details(word, dark, this_player());
   stuff = replace_long_dollars( this_player(), stuff );
   return stuff;
}
string query_colour() { return colour; }
void set_colour( string word ) { colour = word; }
string query_material() {
   if (sizeof(_materials)) {
      return _materials[0];
   }
   return 0;
}
string* query_materials() {
    string *new_materials;
    new_materials = ({ });
     if(!_materials) _materials=({ });
    foreach( mixed bit in _materials ) {
        if ( stringp( bit ) ) {
            new_materials += ({ bit });
        }
        else {
            if ( arrayp( bit ) ) {
                foreach( mixed inner_bit in bit ) {
                    if( stringp( inner_bit ) ) {
                        new_materials += ({ inner_bit });
                    }
                }
            }
        }
    }
   return new_materials;
}
void set_material( mixed word ) {
   if (!arrayp(word)) {
      word = ({ word });
   }
   if (sizeof (word)) {
      _materials = word + _materials;
      add_adjective(word);
   }
}
void add_material(mixed material) {
   if (pointerp(material)) {
      _materials |= material;
   } else if (stringp(material)) {
      _materials += ({ material });
   }
   add_adjective(material);
}
string query_pronoun() { return "it"; }
string query_possessive() { return "its"; }
string query_objective() { return "it"; }
string query_cloned_by() { return create_me; }
void set_quality(int quality) {
   add_property("quality", quality);
}
int query_quality() {
   return query_property("quality");
}
mixed *stats() {
  if(!_materials) _materials=({ });
  return ({
    ({ "name" , query_name(), }),
    ({ "short", short( 0 ), }),
    ({ "plural", query_plural(0), }),
    ({ "weight", (int)this_object()->query_weight(), }),
    ({ "enchantment", query_enchant(), }),
    ({ "colour", colour, }),
    ({ "material", query_multiple_short(_materials), }),
    ({ "cloned by", create_me, }),
    ({ "length", (int)this_object()->query_length(), }),
    ({ "width", (int)this_object()->query_width(), }),
   }) + property::stats() + misc::stats() + effects::stats();
}
mapping int_query_static_auto_load() {
  return ([
    "name" : query_name(),
    "short" : short_d,
    "main plural" : plural_d,
    "long" : long_d,
    "alias" : query_alias(1),
    "adjective" : query_adjectives(1),
    "plural adjective" : query_plural_adjectives(),
    "plural" : query_plurals(),
    "value" : value,
    "value info" : value_info + ([ ]),
    "weight" : weight,
    "colour" : colour,
    "length" : length,
    "width" : width,
  ]);
}
mapping query_static_auto_load() {
  if ( !query_name() || ( query_name() == "object" ) ) {
    return 0;
  }
  if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/std/object" ) {
    return ([ ]);
  }
  return int_query_static_auto_load();
}
mapping query_dynamic_auto_load() {
   mapping map;
   if ( !query_name() || ( query_name() == "object" ) ) {
      return 0;
   }
   if ( query_enchant() > this_object()->query_max_enchant() ) {
      set_enchant(this_object()->query_max_enchant());
   }
   map = ([
      "read mess" : ::query_read_mess(),
      "degrade enchantment" : query_degrade_enchant(),
      "enchantment" : query_real_enchant(),
      "enchantment time" : query_enchant_set_time(),
      "light" : query_my_light(),
      "materials" : query_materials(),
      "cloned by" : create_me,
   ]);
   if ( map_prop ) {
      map[ "properties" ] = copy( map_prop );
   }
   if ( timed_properties ) {
      save_player_properties();
      map[ "timed properties" ] = copy(timed_properties);
   }
   if ( sizeof(query_effs() ) ) {
     effect_freeze();
     effects_saving();
     map += ([
              "effects" : ({
                (mixed *)query_effs(),
                  (int *)query_eeq()
                  })
              ]);
     effect_unfreeze();
   }
   if ( this_object()->query_special() ) {
      map[ "special" ] =  (mapping)this_object()->query_special_info();
   }
   if ( query_deity() ) {
     map[ "consecrated" ] = query_deity();
   }
   return map;
}
void init_static_arg( mapping map ) {
   if ( !mapp( map ) ) {
      return;
   }
   if ( !undefinedp( map[ "name" ] ) ) {
      set_name(map[ "name" ]);
   }
   if ( !undefinedp( map[ "short" ] ) ) {
      set_short( map[ "short" ] );
   }
   if ( !undefinedp( map[ "main plural" ] ) ) {
      set_main_plural( map[ "main plural" ] );
   }
   if ( !undefinedp( map[ "long" ] ) ) {
      set_long( map[ "long" ] );
   }
   if ( map[ "alias" ] ) {
      set_aliases( map[ "alias" ] );
   }
   if ( map[ "adjective" ] ) {
      set_adjectives( map[ "adjective" ] );
   }
   if ( map[ "plural adjective" ] ) {
      set_plural_adjectives( map[ "plural adjective" ] );
   }
   if ( map[ "plural" ] ) {
      set_plurals( map[ "plural" ] );
   }
   if ( !undefinedp( map[ "value" ] ) ) {
      set_value( map[ "value" ] );
   }
   if ( !undefinedp( map[ "value info" ] ) ) {
      value_info = map[ "value info" ];
   }
   if ( !undefinedp( map[ "weight" ] ) ) {
      set_weight( map[ "weight" ] );
   }
   if ( !undefinedp( map[ "colour" ] ) ) {
      set_colour( map[ "colour" ] );
   }
   if ( !undefinedp( map[ "material" ] ) ) {
      set_material( map[ "material" ] );
   }
   if ( !undefinedp( map[ "length" ] ) ) {
      set_length( map[ "length" ] );
   }
   if ( !undefinedp( map[ "width" ] ) ) {
      set_width( map[ "width" ] );
   }
}
void set_player( object thing ) { player = thing; }
void init_dynamic_arg( mapping map, object ) {
   int recycle;
   if ( !mapp( map ) )
      return;
   recycle = query_property("no recycling");
   if ( map[ "properties" ] )
      map_prop = map[ "properties" ];
   if (recycle)
      add_property("no recycling", recycle);
   if ( map[ "timed properties" ] ) {
      timed_properties = map[ "timed properties" ];
      reload_player_properties();
   }
   if ( sizeof( map[ "read mess" ] ) )
      set_read_mess( map[ "read mess" ] );
   if ( !undefinedp( map[ "materials" ] ) ) {
      _materials = map["materials"];
   }
   set_enchant(map["enchantment"]);
   set_degrade_enchant(map["degrade enchantment"]);
   if (map["enchantment time"]) {
      set_enchant_set_time(map["enchantment time"]);
   }
   set_light( map[ "light" ] );
   create_me = map[ "cloned by" ];
   if( map[ "effects" ] ) {
     set_effs( map[ "effects" ][ 0 ] );
     set_eeq( map[ "effects" ][ 1 ] );
     if ( environment() && shadow( this_object(), 0 ) )
       move_object( environment() );
   }
   init_after_save();
   if ( map[ "special" ] ) {
      clone_object( "/std/shadows/object/special_item" )->
            setup_shadow( this_object(), player );
      this_object()->set_special_info( map[ "special" ] );
   }
   if ( map[ "consecrated" ] ) {
     set_deity( map[ "consecrated" ] );
   }
}
string query_readable_message(object player, int ignore_labels) {
   string ret;
   string bing;
   object *labels;
   object ob;
   int *enums;
   object store;
   ret = ::query_readable_message(player);
   if (!ignore_labels) {
      enums = (int *)this_object()->effects_matching( "object.label" );
      if ( !sizeof( enums ) ) {
         labels = ({ });
      } else {
         store = (object)this_object()->arg_of( enums[ 0 ] )[ 0 ];
         if ( !objectp( store ) ) {
            labels = ({ });
         } else {
            labels = (object *)store->find_inv_match( "" );
         }
      }
      if (sizeof(labels) && !ret) {
         ret = "";
      }
      foreach (ob in labels) {
         ret += "On " + ob->the_short() + " is written:\n";
         bing = ob->query_readable_message(player, 0);
         if (bing) {
            ret += bing;
         } else {
            ret += "Nothing.\n";
         }
      }
   }
   return ret;
}
string query_read_short(object player, int ignore_labels) {
   string ret;
   object *labels;
   int *enums;
   object store;
   ret = ::query_read_short(player);
   if (!ignore_labels) {
      enums = (int *)this_object()->effects_matching( "object.label" );
      if ( !sizeof( enums ) ) {
         labels = ({ });
      } else {
         store = (object)this_object()->arg_of( enums[ 0 ] );
         if ( !objectp( store ) ) {
            labels = ({ });
         } else {
            labels = (object *)store->find_inv_match( "" );
         }
      }
      if (sizeof(labels)) {
         if (ret) {
            ret += " and " + query_multiple_short(labels, "the") +
                   " stuck on $name$";
         } else {
            ret = query_multiple_short(labels, "the") +
                   " stuck on $name$";
         }
      }
   }
   return ret;
}
string query_help_file_directory() {
   return "/doc/object/";
}
int clean_up(int inherited) {
  if(inherited) {
    log_file("CLEANUP", "%s %s cleaned up.\n", ctime(time()),
             file_name(this_object()));
    move("/room/rubbish");
  }
  return 1;
}
void dest_me() {
  effects_desting();
  ::dest_me();
}

==================================================
FILE: plant.c
==================================================

inherit "/std/object";
string plant_name, plant_type, plant_desc;
void set_plant(string name) { plant_name = name; add_alias(name);  }
void set_plant_type(string type) { plant_type = type; }
void set_plant_desc(string desc) { plant_desc = desc; }
string query_plant() { return plant_name; }
string query_plant_type() { return plant_type; }
string get_plant_short() {
  if (plant_name && plant_type)
    return plant_type;
  return "plant";
}
string get_plant_long() {
  if (plant_desc)
    return plant_desc;
  return "A lovely plant thingy.\n";
}
void setup() {
  set_name("plant");
  set_short((: get_plant_short() :));
  set_long((: get_plant_long() :));
  add_property("plant",1);
}
mapping query_dynamic_auto_load() {
   return ([
      "::" : ::query_dynamic_auto_load(),
      "plant_name" : plant_name,
      "plant_type" : plant_type,
      "plant_desc" : plant_desc,
   ]);
}
void init_dynamic_arg( mapping map, object bing ) {
   if ( map["::"] )
      ::init_dynamic_arg( map["::"], bing );
   if ( !undefinedp( map["plant_name"] ) ) {
      plant_name = map["plant_name"];
   }
   if( !undefinedp( map["plant_type"] ) ) {
      plant_type = map["plant_type"];
   }
   if( !undefinedp( map["plant_desc"] ) ) {
      plant_desc = map["plant_desc"];
   }
}

==================================================
FILE: race.c
==================================================

#include "race.h"
inherit "/std/basic/print_object";
private mapping _races;
private mapping _guilds;
private mapping _race_obs;
private mapping _guild_obs;
void create() {
  string tmp;
  _races = ([
      0                  : "/std/races/human",
      "ape"              : "/std/races/ape",
      "arachnid"         : "/std/races/arachnid",
      "baboon"           : "/std/races/baboon",
      "basilisk"         : "/std/races/basilisk",
      "badger"           : "/std/races/badger",
      "bat"              : "/std/races/bat",
      "bear"             : "/std/races/bear",
      "beetle"           : "/std/races/beetle",
      "bird"             : "/std/races/bird",
      "blowfish"         : "/std/races/blowfish",
      "bufonid"          : "/std/races/bufonid",
      "cabbage"          : "/std/races/cabbage",
      "camel"            : "/std/races/camel",
      "cat"              : "/std/races/cat",
      "caterpillar"      : "/std/races/caterpillar",
      "chicken"          : "/std/races/chicken",
      "chimera"          : "/std/races/chimera",
      "cockroach"        : "/std/races/cockroach",
      "cow"              : "/std/races/cow",
      "crab"             : "/std/races/crab",
      "crocodile"        : "/std/races/crocodile",
      "deer"             : "/std/races/deer",
      "demon"            : "/std/races/demon",
      "dog"              : "/std/races/dog",
      "dryad"            : "/std/races/dryad",
      "duck"             : "/std/races/duck",
      "dwarf"            : "/std/races/dwarf",
      "duckling"         : "/std/races/duckling",
      "eagle"            : "/std/races/chicken",
      "elemental"        : "/std/races/elemental",
      "elephant"         : "/std/races/elephant",
      "elf"              : "/std/races/elf",
      "ferret"           : "/std/races/ferret",
      "fish"             : "/std/races/fish",
      "fox"              : "/std/races/fox",
      "frog"             : "/std/races/frog",
      "gargoyle"         : "/std/races/gargoyle",
      "giant"            : "/std/races/giant",
      "giant bat"        : "/std/races/giant_bat",
      "giant spider"     : "/std/races/giant_spider",
      "gnoll"            : "/std/races/gnoll",
      "gnome"            : "/std/races/gnome",
      "goat"             : "/std/races/goat",
      "golem"            : "/std/races/golem",
      "grflx"            : "/std/races/grflx",
      "guppy"            : "/std/races/guppy",
      "half elf"         : "/std/races/half_elf",
      "hare"             : "/std/races/hare",
      "hedgehog"         : "/std/races/hedgehog",
      "hengeyokai"       : "/std/races/hengeyokai",
      "horse"            : "/std/races/horse",
      "human"            : "/std/races/human",
      "igor"             : "/std/races/igor",
      "imp"              : "/std/races/imp",
      "insect"           : "/std/races/insect",
      "light"            : "/std/races/light",
      "lion"             : "/std/races/lion",
      "lobster"          : "/std/races/lobster",
      "luggage"          : "/std/races/luggage",
      "jellyfish"        : "/std/races/jellyfish",
      "mole"             : "/std/races/mole",
      "moose"            : "/std/races/moose",
      "mouse"            : "/std/races/mouse",
      "mustelidae"       : "/std/races/mustelidae",
      "newt"             : "/std/races/newt",
      "noble dragon"     : "/std/races/noble_dragon",
      "nymph"            : "/std/races/nymph",
      "peacock"          : "/std/races/peacock",
      "penguin"          : "/std/races/penguin",
      "panda"            : "/std/races/panda",
      "parrot"           : "/std/races/parrot",
      "pig"              : "/std/races/pig",
      "rabbit"           : "/std/races/rabbit",
      "raptor"           : "/std/races/raptor",
      "rat"              : "/std/races/rat",
      "rodent"           : "/std/races/rodent",
      "sargassum"        : "/std/races/sargassum",
      "satyr"            : "/std/races/satyr",
      "scorpion"         : "/std/races/scorpion",
      "sektarian demon"  : "/std/races/sektarian_demon",
      "shark"            : "/std/races/shark",
      "sprite"           : "/std/races/sprite",
      "sheep"            : "/std/races/sheep",
      "skunk"            : "/std/races/skunk",
      "slice human"      : "/std/races/slice_human",
      "snake"            : "/std/races/snake",
      "sphinx"           : "/std/races/sphinx",
      "spider"           : "/std/races/spider",
      "squirrel"         : "/std/races/squirrel",
      "stoat"            : "/std/races/stoat",
      "stone giant"      : "/std/races/stone_giant",
      "stone palm"       : "/std/races/stone_palm",
      "strange"          : "/std/races/strange",
      "swamp dragon"     : "/std/races/swamp_dragon",
      "toad"             : "/std/races/toad",
      "tortoise"         : "/std/races/tortoise",
      "tree"             : "/std/races/tree",
      "troll"            : "/std/races/troll",
      "vulture"          : "/std/races/vulture",
      "unicorn"          : "/std/races/unicorn",
      "vampire"          : "/std/races/vampire",
      "vorpal bunny"     : "/std/races/vorpal_bunny",
      "weasel"           : "/std/races/weasel",
      "werewolf"         : "/std/races/werewolf",
      "wolf"             : "/std/races/wolf",
      "wombat"           : "/std/races/wombat",
      "wererat"          : "/std/races/wererat",
      "giant rat"        : "/std/races/giant_rat",
    ]);
    _guilds = ([
      0                  : "/std/guilds/standard",
      "fighter"          : "/std/guilds/warrior",
      "warrior"          : "/std/guilds/warrior",
      "cleric"           : "/std/guilds/priest",
      "priest"           : "/std/guilds/priest",
      "witch"            : "/std/guilds/witch",
      "wizard"           : "/std/guilds/wizard",
      "cat burglar"      : "/std/guilds/thief",
      "cut throat"       : "/std/guilds/thief",
      "thief"            : "/std/guilds/thief",
      "pickpocket"       : "/std/guilds/thief",
      "swashbuckler"     : "/std/guilds/thief",
      "monk"             : "/std/guilds/monk",
      "assassin"         : "/std/guilds/assassin",
    ]);
    _race_obs = ([ ]);
    foreach(tmp in values(_races))
      _race_obs[tmp] = load_object(tmp);
    _guild_obs = ([ ]);
    foreach(tmp in values(_guilds))
      catch(_guild_obs[tmp] = load_object(tmp));
}
int query_valid_race( string race ) {
    return !undefinedp(_races[race]);
}
void set_level( int lvl, string race, string guild ) {
    object ob;
    string race_ob, guild_ob;
    if (_races[race]) {
        race_ob = _races[race];
    } else {
        race_ob = _races[0];
    }
    if (_guilds[guild]) {
        guild_ob = _guilds[guild];
    } else {
        guild_ob = _guilds[0];
    }
    ob = previous_object();
    ob->set_no_check(1);
    ob->set_race_ob(race_ob);
    race_ob->set_level(ob, lvl);
    ob->set_guild_ob(guild_ob);
    guild_ob->set_level(ob, lvl, guild);
    ob->race_guild_commands();
}
private int add_race( string name, mixed ob ) {
    if (_races[name]) {
        return 0;
    }
    _races[name] = ob;
    return 1;
}
private int remove_race( string name ) {
    if (!_races[name]) {
        return 0;
    }
    _races[name] = 0;
    return 1;
}
mapping query_races() {
    return copy(_races);
}
string query_race_path( string race_name ) {
    return _races[race_name];
}
private int add_guild( string name, mixed ob ) {
    if (_guilds[name]) {
        return 0;
    }
    _guilds[name] = ob;
    return 1;
}
private int remove_guild( string name ) {
    if (!_guilds[name]) {
        return 0;
    }
    _guilds[name] = 0;
    return 1;
}
mapping query_guilds() {
    return copy(_guilds);
}
string query_guild_path(string guild_name) {
    return _guilds[guild_name];
}
void monster_heart_beat(string race,  string guild, mixed race_ob,
                        mixed guild_ob) {
  object tmp;
  if(stringp(race_ob)) {
    if(!_race_obs[race_ob])
      _race_obs[race_ob] = find_object(race_ob);
    tmp = _race_obs[race_ob];
  } else if(objectp(race_ob))
    tmp = race_ob;
  if(tmp)
    tmp->player_heart_beat( race, previous_object() );
  if(stringp(guild_ob)) {
    if(!_guild_obs)
      _guild_obs = ([ ]);
    if(!_guild_obs[guild_ob]) {
      _guild_obs[guild_ob] = find_object(guild_ob);
    }
    tmp = _guild_obs[guild_ob];
  } else if(objectp(guild_ob))
    tmp = guild_ob;
  if(tmp)
    tmp->player_heart_beat(guild, previous_object());
}

==================================================
FILE: scroll.c
==================================================

inherit "/std/object";
int num_pages, open_page;
mixed *pages;
void create() {
  num_pages = 1;
  open_page = 1;
  pages = ({ ({ 0, 0, 0 }) });
  ::create();
}
void init() {
  add_command("scroll", "<word'forward|backward'>", (:this_object()->do_scroll($4[0]):));
}
void set_read_mess( string mess, string lang, int size ) {
  pages[ open_page ] = ({ mess, lang, size });
  ::set_read_mess( mess, lang, size );
}
void add_read_mess( string mess, string type, string lang, string size ) {
  pages[ open_page ] = ({ mess, lang, size });
  ::set_read_mess( mess, lang, size );
}
int query_num_pages() { return num_pages; }
void set_num_pages( int number ) { num_pages = number; }
int query_open_page() { return open_page; }
void set_open_page( int number ) {
  int size;
  string mess, lang;
  mixed *text;
  if ( ( number < 0 ) || ( number > num_pages ) )
    open_page = 1;
  else
    open_page = number;
  text = pages[ open_page ];
  if ( !text || ( sizeof( text ) < 3 ) )
    text = ({ 0, 0, 0 });
  mess = text[ 0 ];
  lang = text[ 1 ];
  size = text[ 2 ];
  ::set_read_mess( mess, lang, size );
}
int do_scroll( string word ) {
  if ( ( word != "forward" ) && ( word != "backward" ) ) {
    notify_fail( "Syntax: scroll forward|backward\n" );
    return 0;
  }
  if ( word == "forward" ) {
    if ( open_page == num_pages ) {
      notify_fail( "The scroll is already rolled forward to the last "+
          "section.\n" );
      return 0;
    }
    set_open_page( ++open_page );
    write( "You roll the scroll forward to the next section.\n" );
    say( (string)this_player()->one_short() +" rolls the "+ short( 0 ) +
        " forward.\n" );
    return 1;
  }
  if ( open_page == 1 ) {
    notify_fail( "The scroll is already open at the first section.\n" );
    return 0;
  }
  set_open_page( --open_page );
  write( "You roll the scroll backward to the previous section.\n" );
  say( (string)this_player()->one_short() +" rolls the "+ short( 0 ) +
      " backward.\n" );
  return 1;
}
mixed *stats() {
  return ::stats() + ({
    ({ "pages", num_pages }),
    ({ "open at", open_page })
  });
}
mapping query_auto_dynamic_load() {
  return ([
    "::": ::query_dynamic_auto_load(),
    "open_page": open_page
  ]);
}
mapping int_query_static_auto_load() {
  return ([
    "::": ::int_query_static_auto_load(),
    "num_pages": num_pages,
    "pages": pages
  ]);
}
mixed query_static_auto_load() {
  if ( ( file_name( this_object() ) )[ 0 .. 10 ] != "/std/scroll" )
    return 0;
  return int_query_static_auto_load();
}
void init_dynamic_arg( mapping args ) {
  ::init_dynamic_arg( args[ "::" ] );
  open_page = args[ "open_page" ];
}
void init_static_arg( mapping args ) {
  if ( args[ "::" ] ) ::init_static_arg( args[ "::" ] );
  if ( args[ "num_pages" ] ) num_pages = args[ "num_pages" ];
  if ( args[ "pages" ] ) pages = args[ "pages" ];
}

==================================================
FILE: skills.c
==================================================

#include <skills.h>
#include <language.h>
#define SKILL_BONUS 0
private mapping _stat_bonus;
private mixed *_skills;
private mapping _reg_skills;
private mapping _skill_tree;
private mapping _immediate_children;
private mapping _only_leaf;
private mapping _not_allowed_to_teach;
private mapping _only_show_if_non_zero;
private mapping _no_bonus;
private mapping _ignore_bits;
private mapping flatten(mixed *arr, string bit);
mixed *add_skill_rec(mixed *skill, string *path);
mixed *del_skill_rec(mixed *skill, string *path);
int query_skill_cost_int(string str);
void create() {
  string *languages, *lang_tree;
  int i;
  mixed *rabbit;
  string skill_written;
  string skill_spoken;
  string *skill_bits;
  _skills = STD_SKILLS;
  _skill_tree = ([ ]);
  _immediate_children = ([ ]);
  _not_allowed_to_teach = ([ ]);
  _only_show_if_non_zero = ([ ]);
  _no_bonus = ([ ]);
  lang_tree = ({ });
  languages = LANGUAGE_HAND->query_languages();
  for (i=0;i<sizeof(languages);i++) {
     rabbit = ({ });
     if (LANGUAGE_HAND->query_language_spoken(languages[i])) {
        rabbit += ({ SPOKEN_SKILL, 0, 0, ({ }), });
     }
     if (LANGUAGE_HAND->query_language_written(languages[i]) ||
         LANGUAGE_HAND->query_language_magic(languages[i])) {
        rabbit += ({ WRITTEN_SKILL, 0, 0, ({ }) });
     }
     skill_written = LANGUAGE_HAND->query_language_written_skill(languages[i]);
     skill_spoken = LANGUAGE_HAND->query_language_spoken_skill(languages[i]);
     languages[i] = replace(languages[i], " ", "_");
     lang_tree += ({ languages[i], 0, 0, rabbit });
     _not_allowed_to_teach[LANGUAGE_SKILL_START + languages[i]] = 1;
     _not_allowed_to_teach[skill_spoken] = 1;
     _not_allowed_to_teach[skill_written] = 1;
     _only_show_if_non_zero[skill_spoken] = 1;
     _only_show_if_non_zero[skill_written] = 1;
     _no_bonus[skill_spoken] = 1;
     _no_bonus[skill_written] = 1;
  }
  skill_bits = explode(LANGUAGE_SKILL_START, ".");
  _not_allowed_to_teach["other.language"] = 1;
  i = member_array(skill_bits[0], _skills);
  if (i != -1) {
     _skills[i+SKILL_BIT] += ({ skill_bits[1], 0, 0, lang_tree });
  }
  _only_leaf = ([ "other" : 1 ]);
  _ignore_bits = ([ "crafts" : 1 ]);
  _reg_skills = flatten( _skills, "" );
  _stat_bonus = ([
"covert"                            : ({ "DDDII" }),
  "covert.stealth"                  : ({ "DDDIS" }),
  "covert.hiding"                   : ({ "DDIIS" }),
  "covert.lockpick"                 : ({ "DDDDI" }),
  "covert.manipulation"             : ({ "DDISS" }),
  "covert.casing"                   : ({ "DIIWW" }),
  "covert.items"                    : ({ "DIIII" }),
  "covert.points"                   : ({ "DDIIC" }),
"crafts"                            : ({ "DDIIW" }),
  "crafts.smithing"                 : ({ "DDIIS" }),
  "crafts.mining"                   : ({ "DIISS" }),
  "crafts.hunting"                  : ({ "DDIII" }),
  "crafts.carpentry"                : ({ "DDIIS" }),
  "crafts.pottery"                  : ({ "DDDII" }),
  "crafts.materials"                : ({ "DDIIS" }),
  "crafts.husbandry"                : ({ "IIIWW" }),
  "crafts.culinary"                 : ({ "DDIII" }),
  "crafts.arts"                     : ({ "DIIII" }),
  "crafts.music"                    : ({ "DIIII" }),
  "crafts.points"                   : ({ "DDIIW" }),
"faith"                             : ({ "ISWWW" }),
  "faith.rituals.offensive"         : ({ "ISSWW" }),
  "faith.rituals.defensive"         : ({ "IDDWW" }),
  "faith.rituals.curing"            : ({ "ICCWW" }),
  "faith.rituals.misc"              : ({ "IIWWW" }),
  "faith.items"                     : ({ "IIDWW" }),
  "faith.points"                    : ({ "IICWW" }),
"fighting"                          : ({ "DDSSI" }),
  "fighting.combat.melee"           : ({ "DSSSW" }),
  "fighting.combat.melee.sharp"     : ({ "DDSSS" }),
  "fighting.combat.melee.pierce"    : ({ "DDDSS" }),
  "fighting.combat.melee.blunt"     : ({ "DSSSS" }),
  "fighting.combat.melee.unarmed"   : ({ "DDDSW" }),
  "fighting.combat.range"           : ({ "DDDSS" }),
  "fighting.combat.parry"           : ({ "DDSSW" }),
  "fighting.combat.dodging"         : ({ "DDDSW" }),
  "fighting.combat.special.weapon"  : ({ "SDIII" }),
  "fighting.combat.special.unarmed" : ({ "DDIII" }),
  "fighting.combat.special.tactics" : ({ "WWIII" }),
  "fighting.points"                 : ({ "DSSCC" }),
"magic"                             : ({ "IIIDW" }),
  "magic.spells"                    : ({ "IIDWW" }),
  "magic.spells.offensive"          : ({ "WSSII" }),
  "magic.spells.defensive"          : ({ "WCCII" }),
  "magic.spells.misc"               : ({ "WDDII" }),
  "magic.spells.special"            : ({ "WWWII" }),
  "magic.methods.elemental"         : ({ "IICCC" }),
  "magic.methods.mental"            : ({ "IIIII" }),
  "magic.methods.spiritual"         : ({ "IIWWW" }),
  "magic.methods.physical"          : ({ "IIDDD" }),
  "magic.items"                     : ({ "IIDWW" }),
  "magic.items.held"                : ({ "IIDWW" }),
  "magic.points"                    : ({ "IISWW" }),
"other"                             : ({ "DDISS" }),
   "other.trading"                  : ({ "IIIIW" }),
   "other.movement"                 : ({ "CCDDS" }),
   "other.acrobatics"               : ({ "CDDSS" }),
   "other.evaluating"               : ({ "IIIIW" }),
   "other.perception"               : ({ "IIWWW" }),
   "other.direction"                : ({ "DDIIW" }),
   "other.health"                   : ({ "CCCCS" }),
   "other.points"                   : ({ "CDISW" }),
   "other.language"                 : ({ "IIIWW" }),
   "other.culture"                  : ({ "IIIWW" }),
  ]);
}
mapping query_reg_skills() { return _reg_skills; }
mixed *query_skills() { return _skills; }
string *query_skill_path(string skill) {
   if (skill[0] == '.') {
      skill = skill[1..1090];
   }
   if (!_reg_skills[skill]) {
      return 0;
   }
   return explode(skill, ".");
}
string *query_skill_tree(string skill) {
   return _skill_tree[skill];
}
string query_skill_stat(string skill) {
   int i;
   string *bit, s;
   bit = explode(skill, ".");
   i = sizeof(bit);
   while (i >= 0) {
      s = implode(bit[0..i], ".");
      if (_stat_bonus[s])
         return _stat_bonus[s][SKILL_BONUS];
      else
         i--;
   }
   return "";
}
private int add_stat_bonus(string skill, string bonus) {
   if (_stat_bonus[skill]) {
      return 0;
   }
   _stat_bonus[skill] = ({ bonus });
   return 1;
}
private int remove_stat_bonus(string skill) {
   if (!_stat_bonus[skill]) {
      return 0;
   }
   _stat_bonus = m_delete(_stat_bonus, skill);
   return 1;
}
string *query_children(mixed *arr, string path) {
   string *ret;
   int i;
   ret = ({ });
   for (i = 0; i < sizeof(arr); i += SKILL_ARR_SIZE) {
      ret += ({ path+arr[i] }) +
           query_children(arr[i+SKILL_BIT], path+arr[i]+".");
   }
   return ret;
}
string *query_immediate_children(string skill) {
   return _immediate_children[skill];
}
string *query_all_children(string skill) {
   if (_reg_skills[skill]) {
      return _reg_skills[skill][0];
   }
   return 0;
}
private string *query_imm_children(mixed *arr, string path) {
   string *ret;
   int i;
   ret = ({ });
   for (i = 0; i < sizeof(arr); i+= SKILL_ARR_SIZE) {
      ret += ({ path+arr[i] });
   }
   return ret;
}
private string *create_skill_tree(string skill) {
   string *ret, *bits;
   int i;
   ret = ({ });
   bits = explode(skill, ".");
   if (_only_leaf[bits[0]]) {
      return ({ skill });
   }
   for (i = sizeof(bits) - 1; i >= 0; i--) {
      ret += ({ implode(bits[0..i], ".") });
   }
   return ret;
}
private mapping flatten(mixed *arr, string bit) {
   int i;
   mapping ret;
   if (!bit) {
      bit = "";
   }
   ret = ([ ]);
   for (i = 0; i < sizeof(arr); i += SKILL_ARR_SIZE) {
      reset_eval_cost();
      if (sizeof(arr[i+SKILL_BIT]) == 0) {
         ret[(bit+arr[i])] = ({ ({ bit+arr[i] }), 1 });
      } else {
         ret[bit + arr[i]] = ({ query_children(arr[i+SKILL_BIT], bit+arr[i]+".") +
                              ({ bit + arr[i] }),
                              query_skill_cost_int(bit+arr[i]) });
         ret += flatten(arr[i+SKILL_BIT], bit+arr[i]+".");
      }
      _skill_tree[(bit+arr[i])] = create_skill_tree(bit+arr[i]);
      _immediate_children[(bit+arr[i])] = query_imm_children(arr[i+SKILL_BIT],bit+arr[i]+".");
   }
   return ret;
}
private int query_skill_cost_rec(mixed *arr) {
   int i, tmp;
   if (!sizeof(arr)) {
      return 1;
   }
   for (i=0;i<sizeof(arr);i+=SKILL_ARR_SIZE) {
      tmp += query_skill_cost_rec(arr[i+SKILL_BIT]);
   }
   return tmp;
}
private int query_skill_cost_int(string str) {
   int i;
   mixed *arr;
   string *path;
   path = explode(str, ".");
   arr = _skills;
   while (sizeof(path)) {
      i = member_array(path[0], arr);
      if (i == -1) {
         return -1;
      } else {
         path = path[1..sizeof(path)];
         arr = arr[i+SKILL_BIT];
      }
   }
   return query_skill_cost_rec(arr);
}
string *query_related_skills(string skill) {
   if (_reg_skills[skill]) {
      return _reg_skills[skill][0];
   }
   return 0;
}
int query_skill_cost(string skill) {
   if (_reg_skills[skill]) {
      return _reg_skills[skill][1];
   }
   return -1;
}
string query_skill(string *bits) {
   mixed *arr;
   int i;
   string path, s1;
   if( !bits || !sizeof(bits) ) {
      return 0;
   }
   path = "";
   arr = _skills;
   for (i = 0; i < sizeof(arr); i += SKILL_ARR_SIZE) {
      if (sscanf(arr[i], bits[0]+"%s", s1) == 1) {
         path += "."+arr[i];
         arr = arr[i+SKILL_BIT];
         i = -SKILL_ARR_SIZE;
         bits = bits[1..sizeof(bits)];
         if (!sizeof(bits))
            return path[1..strlen(path)];
      }
   }
   if (i<sizeof(arr)) {
      return path[1..strlen(path)];
   }
   return 0;
}
int query_only_leaf(string str) {
   string *bits;
   bits = explode(str, ".");
   return _only_leaf[bits[0]];
}
int query_allowed_to_teach(string str) {
   return !_not_allowed_to_teach[str];
}
int query_only_show_if_non_zero(string str) {
   return _only_show_if_non_zero[str];
}
int query_no_bonus(string str) {
   return _no_bonus[str] || _ignore_bits[str];
}
int is_skill_ignored(string skill) {
   return _ignore_bits[skill];
}
int query_skill_depth(string* skill) {
   int depth;
   int i;
   depth = 0;
   for (i = 0; i < sizeof(skill) - 1; i++) {
      if (!is_skill_ignored(implode(skill[0..i], "."))) {
         depth++;
      }
   }
   return depth;
}

==================================================
FILE: smart_log.c
==================================================

#include <log.h>
#include <db.h>
#include <config.h>
#include <playtesters.h>
#undef OLD_SYSTEM
#define NEW_SYSTEM
void create() {
}
void smart_log(string full_type, string reporter, string text,
                      string trace, string file) {
   int i;
   string type, temp1, *j, *person, dir;
#ifdef OLD_SYSTEM
   string temp2, report;
#endif
#ifdef NEW_SYSTEM
   string query, name, category;
   int rtime;
#endif
   seteuid("Root");
   person = ({ });
   person = master()->query_assigned_to_directory(file);
   j = explode(file, "/") - ({ "" });
   dir = "/" + implode(j[0..<2], "/");
   file = implode(j, "/");
   sscanf(full_type, "%s %s", category, full_type);
   if (!sscanf(full_type, "%s %s", type, name)) {
      type = full_type;
      name = "";
   }
   rtime = time();
   if (sizeof(person) > 0) {
      query = sprintf("INSERT INTO errors (EntryDate, DirEntryDate, "
                           "Directory, Filename, Category, Type, Name, Reporter, "
                           "Report, Runtime, AssignedTo) VALUES(%d, %d, '%s', '/%s', '%s', '%s', "
                           "'%s', '%s', '%s', '%s', '%s');", rtime, rtime, dir,
                           db_escape(file), category, type, db_escape(name), reporter,
                           db_escape(text), (trace ? db_escape(trace) : ""),
                           db_escape(person[0]));
   } else {
      query = sprintf("INSERT INTO errors (EntryDate, DirEntryDate, "
                           "Directory, Filename, Category, Type, Name, Reporter, "
                           "Report, Runtime) VALUES(%d, %d, '%s', '/%s', '%s', '%s', "
                           "'%s', '%s', '%s', '%s');", rtime, rtime, dir,
                           db_escape(file), category, type, db_escape(name), reporter,
                           db_escape(text), (trace ? db_escape(trace) : ""));
   }
   DB_HANDLER->make_sql_request("errors", CONFIG_DB_USER, "",
                                query, (: tell_creator("pinkfish", "%O %O\n", $1, $2) :));
   PLAYTESTER_HAND->report_made(reporter, type, file,
                               (sizeof(person) > 0 ?
                                 "Assigned to " + capitalize(person[0]) + "\n\n" : "Not assigned to anyone.\n\n" ) +
                               text + ( trace
                                       ? "\nError:\n" + trace : ""));
   j = explode( file, "/" );
   file = "/"+ implode( j[ 0 .. <2 ], "/" );
   for(i=0;i<sizeof(person);i++) {
      temp1 = read_file("/w/"+person[i]+"/"+PLAYER_ERROR_LOG);
      if (!temp1) {
         temp1 = "";
      }
      j = explode(temp1, "\n");
      if (!j) {
         j = ({ });
      }
      if (member_array(file, j) == -1) {
         j += ({ file });
      }
      temp1 = implode(j, "\n")+ "\n";
      master()->do_log(person[i], temp1);
   }
}
void dest_me() {
   destruct(this_object());
}
void clean_up() { dest_me(); }
void reset() { dest_me(); }

==================================================
FILE: storeroom.c
==================================================

inherit "/std/shops/storeroom";
void create() {
   ::create();
}

==================================================
FILE: weapon_logic.c
==================================================

#include <weapon.h>
nosave string *attack_names;
nosave string *attack_types;
nosave mixed *attack_data;
nosave mapping special_messages;
void create() {
   attack_names = ({ });
   attack_types = ({ });
   attack_data = ({ });
   special_messages = ([ ]);
}
string *query_attack_names() { return copy( attack_names ); }
string *query_attack_types() { return uniq_array( attack_types ); }
mixed *query_attack_data() { return copy( attack_data ); }
mapping query_special_messages() { return copy( special_messages ); }
void add_attack_message(string name, string type, string *data) {
   string nam;
   nam = type;
   if (name) {
      nam += "-" + name;
   }
   special_messages[nam] = data;
}
mixed *query_attack_message(string name, string type) {
   if (special_messages[type + "-" + name]) {
      return special_messages[type + "-" + name];
   }
   if (special_messages[type]) {
     return special_messages[type];
   }
   return 0;
}
varargs int add_attack( string a_name, int chance, int *damage, string type,
      string skill, mixed func, mixed bogus_1, mixed bogus_2 ) {
   if ( stringp( bogus_1 ) ) {
      write( file_name( this_object() ) +" is using the obselete syntax "+
            "of add_attack.\n" );
      return 0;
   }
   if ( member_array( a_name, attack_names ) != -1 )
      return 0;
   attack_names += ({ a_name });
   attack_types += ({ type });
   attack_data += ({ chance, damage, type, skill, func });
   return 1;
}
void remove_attack( string a_name ) {
   int i;
   i = member_array( a_name, attack_names );
   if ( i == -1 )
      return;
   attack_names = delete(attack_names, i, 1);
   attack_types = delete(attack_types, i, 1);
   attack_data = delete( attack_data, i * W_ARRAY_SIZE, W_ARRAY_SIZE );
}
int modify_damage( int damage, string attack_name ) { return damage; }
int calc_attack( int number, int percent ) {
   int damage, *data;
   data = attack_data[ number * W_ARRAY_SIZE + W_DAMAGE ];
   damage = data[ F_FIXED ] + roll_MdN( data[ F_NUM ], data[ F_DIE ] );
   damage = (int)this_object()->modify_damage( damage,
         attack_names[ number ] );
   damage = ( damage * percent ) / 100;
   return damage;
}
mixed *weapon_attacks(int percent, object target ) {
   int i, *order;
   mixed *attacks;
   if ( !percent )
      percent = 100;
   order = ({ });
   for ( i = 0; i < sizeof( attack_names ); i++ )
      order += ({ i });
   order = shuffle( order );
   attacks = ({ });
   for ( i = 0; i < sizeof( order ); i++ ) {
      if ( random( percent ) <
            attack_data[ order[ i ] * W_ARRAY_SIZE + W_CHANCE ] ) {
         attacks += ({ calc_attack( order[ i ], percent ),
               attack_data[ order[ i ] * W_ARRAY_SIZE + W_SKILL ],
               attack_data[ order[ i ] * W_ARRAY_SIZE + W_TYPE ],
               attack_names[ order[ i ] ] });
      }
   }
   return attacks;
}
void attack_function( string a_name, int damage, object attack_ob,
      object attack_by ) {
   int i;
   i = member_array( a_name, attack_names );
   if ( i == -1 ) {
      return;
   }
   i *= W_ARRAY_SIZE;
   if ( !attack_data[ i + W_FUNCTION ] ) {
      return;
   }
   if ( stringp( attack_data[ i + W_FUNCTION ] ) ) {
      call_other( this_object(), attack_data[ i + W_FUNCTION ],
            damage, attack_ob, attack_by, attack_data[ i + W_TYPE ], a_name );
   } else {
      call_other( attack_data[ i + W_FUNCTION ][ 1 ],
            attack_data[ i + W_FUNCTION ][ 0 ], damage, attack_ob, attack_by,
            attack_data[ i + W_TYPE ], a_name );
   }
}
string query_weapon_type() {
   int i;
   string type;
   for ( i = 0; i < sizeof( attack_data ); i += W_ARRAY_SIZE ) {
      if ( !type ) {
         type = attack_data[ i + W_SKILL ];
         continue;
      }
      if ( type != attack_data[ i + W_SKILL ] )
         return "mixed";
   }
   return type;
}
mixed weapon_stats() {
   int i, j;
   string bit;
   mixed *ret;
   ret = ({ });
   for ( i = 0; i < sizeof( attack_data ); i += W_ARRAY_SIZE, j++ ) {
      ret += ({
         ({ "attack #"+ j, attack_names[ j ] }),
         ({ "   chance", attack_data[ i + W_CHANCE ] })
      });
      if ( attack_data[ i + W_DAMAGE ][ F_FIXED ] )
         bit = attack_data[ i + W_DAMAGE ][ F_FIXED ] +"+";
      else
         bit = "";
      if ( attack_data[ i + W_DAMAGE ][ F_NUM ] )
         bit += attack_data[ i + W_DAMAGE ][ F_NUM ] +"d"+
               attack_data[ i + W_DAMAGE ][ F_DIE ];
      else
         if ( attack_data[ i + W_DAMAGE ][ F_DIE ] )
            bit += "1d"+ attack_data[ i + W_DAMAGE ][ F_DIE ];
      ret += ({
         ({ "   damage", bit }),
         ({ "     type", attack_data[ i + W_TYPE ] }),
         ({ "    skill", attack_data[ i + W_SKILL ] })
      });
      if ( stringp( attack_data[ i + W_FUNCTION ] ) )
         ret += ({ ({ " function", attack_data[ i + W_FUNCTION ] }) });
      else
         if ( pointerp( attack_data[ i + W_FUNCTION ] ) )
            ret += ({
               ({ " function", attack_data[ i + W_FUNCTION ][ 0 ] }),
               ({ "called on", attack_data[ i + W_FUNCTION ][ 1 ] })
            });
   }
   return ret;
}
mixed stats() { return weapon_stats(); }

==================================================
FILE: basic/artifact.c
==================================================

#include <artifacts.h>
int charges, level, total_charges;
string type, zapper;
string query_artifact_type() { return type; }
void set_artifact_type( string word ) { type = word; }
int query_charges() { return charges; }
void set_charges( int number ) { charges = number; }
int adjust_charges( int number ) {
  charges += number;
  if ( number > 0 )
    total_charges += number;
  if ( charges < 0 )
    charges = 0;
  return charges;
}
int query_total_charges() { return total_charges; }
void set_total_charges( int number ) { total_charges = number; }
int query_level() { return level; }
void set_level( int number ) { level = number; }
string query_zapper() { return zapper; }
void set_zapper( string word ) {
   zapper = word;
   call_out( "zapper_init", 1, this_object() );
}
void zapper_init( object thing ) {
   if ( !thing )
      return;
   zapper->init_artifact( thing );
}
int break_on_charging() {
  int top, chance;
  top = 1000 / ( 32 + level );
  if ( total_charges > top )
    chance = 6 * ( total_charges - top ) * ( total_charges - top );
  top = 14 - level / 7;
  if ( top < 0 )
    top = 0;
  if ( charges > top )
    chance += 3 * ( charges - top ) * ( charges - top );
  chance += 1;
  if ( random( 100 ) < chance )
    return 1;
  return 0;
}
string long( int word, int dark ) {
  string a_name, start;
  a_name = (string)call_other( zapper, "query_"+ type +"_name" );
  if ( !ARTIFACT_HAND->query_known( (string)this_player()->query_name(),
      a_name ) )
    return "";
   start = "You recognise "+ this_object()->the_short() +" to be ";
  if ( a_name[ 0 .. 0 ] == lower_case( a_name[ 0 .. 0 ] ) )
    return start + add_a( a_name ) +".  ";
  return start + a_name +".  ";
}
mixed *stats() {
  return ({
    ({ "charges", charges +" ("+ total_charges +")", }),
    ({ "level", level, }),
    ({ "zapper", zapper, }),
  });
}
mapping query_dynamic_auto_load() {
  return ([
    "charges" : charges,
    "total charges" : total_charges,
  ]);
}
mapping query_static_auto_load() {
  return ([
    "level" : level,
    "zapper" : zapper,
  ]);
}
void init_dynamic_arg( mapping map ) {
  charges = map[ "charges" ];
  total_charges = map[ "total charges" ];
}
void init_static_arg( mapping map ) {
  if ( map[ "level" ] )
    level = map[ "level" ];
  if ( map[ "zapper" ] )
    zapper = map[ "zapper" ];
}

==================================================
FILE: basic/auto_load.c
==================================================

mapping add_auto_load_value(mapping map,
                            string file_name,
                            string tag,
                            mixed value) {
   map[file_name + "  :  " + tag] = value;
   return map;
}
mixed query_auto_load_value(mapping map,
                            string file_name,
                            string tag) {
   mixed tmp;
   if (tag == "::") {
      return map;
   }
   tmp = map[file_name + "  :  " + tag];
   if (tmp) {
      return tmp;
   }
   return map[tag];
}

==================================================
FILE: basic/close_lock.c
==================================================

#include <move_failures.h>
#include <tasks.h>
#include <clothing.h>
#define MAX_INVENT 40
#define C_CLOSED 1
#define C_TRANS 2
#define C_OPAQUE 1
#define LOCKED        1
#define CLOSED        2
#define CLOSED_LOCKED 3
#define SKILL "covert.manipulation.sleight-of-hand"
#define STEALTH_NONE        0
#define STEALTH_FAILED      1
#define STEALTH_SUCCEEDED   2
#define TP this_player()
#define TO this_object()
int do_open();
int do_close();
int do_lock(object *keys);
int do_unlock(object *keys);
private int _locked;
private int _closed;
private string _pick_skill;
private nosave int _stuck;
private nosave int _trans;
private nosave int _difficulty;
private nosave int _autolock;
private nosave string _trap_open_func;
private nosave string _trap_lock_func;
private nosave object _trap_open_ob;
private nosave object _trap_lock_ob;
private nosave mixed _key;
void create() {
  _difficulty = 5;
  _pick_skill = "covert.lockpick.doors";
}
void set_open() {
    if (!_closed)
        return;
    _closed = 0;
    _locked = 0;
    if (environment()) {
      event( ({ environment(), TO, }), "open", TP);
    } else if (TO->query_my_room()) {
      event( ({ TO->query_my_room(), TO, }), "open", TP);
    }
}
void set_closed() {
    if (_closed)
        return;
    _closed = 1;
    if (environment()) {
      event( ({ environment(), TO, }), "close", TP);
    } else if (TO->query_my_room()) {
      event( ({ TO->query_my_room(), TO, }), "close", TP);
    }
}
int query_closed() {
  return _closed;
}
int query_open() {
  return !_closed;
}
void set_locked() {
    if (!_closed)
        return;
    if (_locked)
        return;
    _locked = 1;
    if (environment()) {
        event( ({ environment(), TO, }), "lock", TP);
    } else if (TO->query_my_room()) {
        event( ({ TO->query_my_room(), TO, }), "lock", TP);
    }
}
void set_unlocked() {
    if (!_locked)
        return;
    _locked = 0;
    if (environment()) {
        event( ({ environment(), TO, }), "unlock", TP);
    } else if (TO->query_my_room()) {
        event( ({ TO->query_my_room(), TO, }), "unlock", TP);
    }
}
int query_locked() {
  return _locked;
}
int query_unlocked() {
  return !_locked;
}
void set_autolock(int number) { _autolock = number; }
int query_autolock() { return _autolock; }
void set_key(mixed val) {
    if (!stringp(val) && !functionp(val))
        return;
    _key = val;
}
string query_key() {
    if (stringp(_key))
        return _key;
    if (functionp(_key))
        return evaluate(_key);
    return 0;
}
void set_pick_skill(string str) {
  _pick_skill = str;
}
string query_pick_skill() {
  return _pick_skill;
}
void set_difficulty(int i) {
  _difficulty = i;
}
int query_difficulty() {
  return _difficulty;
}
void set_stuck(int i) {
  _stuck = i;
}
int query_stuck() {
  return _stuck;
}
void set_transparent() {
  _trans = C_TRANS;
}
void reset_transparent() {
  _trans = 0;
}
int query_transparent() {
  return _trans;
}
void set_open_trap(object ob, string func) {
  _trap_open_func =  func;
  _trap_open_ob = ob;
}
string query_open_trap_func() {
  return _trap_open_func;
}
object query_open_trap_ob() {
  return _trap_open_ob;
}
void set_lock_trap(object ob, string func) {
  _trap_lock_func = func;
  _trap_lock_ob = ob;
}
string query_lock_trap_func() {
  return _trap_lock_func;
}
object query_lock_trap_ob() {
  return _trap_lock_ob;
}
int query_closed_locked_status() {
    if (_closed && _locked) {
        return CLOSED_LOCKED;
    }
    if (_closed) {
        return CLOSED;
    }
    if (_locked) {
        return LOCKED;
    }
    return 0;
}
void add_close_lock_commands(object player) {
  if(!player)
    return;
    player->add_command("open", TO,
        "<direct:object:me-here>",
        (: do_open() :) );
    player->add_command("close", TO,
        "<direct:object:me-here>",
        (: do_close() :) );
    if (TO->query_key()) {
        player->add_command("lock", TO,
            "<direct:object:me-here>",
            (: do_lock(0) :) );
        player->add_command("lock", TO,
            "<direct:object:me-here> with <indirect:object:me>",
            (: do_lock($1) :) );
        player->add_command("unlock", TO,
            "<direct:object:me-here>",
            (: do_unlock(0) :) );
        player->add_command("unlock", TO,
            "<direct:object:me-here> with <indirect:object:me>",
            (: do_unlock($1) :) );
    }
}
void init() {
    add_close_lock_commands(this_player());
}
string short_status() {
    return "";
}
string long_status() {
    if (TO->query_stuck())
        return "";
    switch (query_closed_locked_status()) {
        case CLOSED_LOCKED:
            return "It is closed and locked.\n";
        case CLOSED:
            return "It is closed.\n";
        default:
            return "It is open.\n";
    }
}
int check_stealth() {
    mapping hide_invis;
    int hiding, sneaking, difficulty, light, my_light, items_blocking;
    hide_invis = (mapping) TP->query_hide_invis();
    hiding = undefinedp(hide_invis["hiding"]) ? 0 : 1;
    sneaking = TP->query_sneak_level() ? 1 : 0;
    if (!hiding && !sneaking)
        return STEALTH_NONE;
    my_light = TP->query_light();
    light = environment(TP)->query_light();
    difficulty = light + (4 * my_light) / (light + 1);
    items_blocking = sizeof(CLOTHING_HANDLER->query_items_blocking(TO, TP));
    if (items_blocking) {
        difficulty += 50 * items_blocking;
    }
    debug_printf( "Difficulty = %d.\n Skill = %s\n Bonus = %d\n",
                  difficulty, SKILL, TP->query_skill_bonus( SKILL ) );
    switch (TASKER->perform_task(TP, SKILL, difficulty, TM_FREE)) {
        case AWARD:
            write("%^YELLOW%^" + ({
                "You discover something that lets your fingers move more nimbly.",
                "You find yourself capable of deceiving the eye with greater ease "
                "than before.",
                "You realise how to deceive the eye more effectively."
                })[ random(3) ] + "%^RESET%^\n" );
        case SUCCEED :
            return STEALTH_SUCCEEDED;
        default :
            return STEALTH_FAILED;
    }
}
int do_unlock(object *keys) {
    object *gkeys = ({ });
    string key = TO->query_key();
    int inv = 0;
    if (!_locked) {
        TP->add_failed_mess(TO,
            "$D $V$0=isn't,aren't$V$ locked.\n",
            ({ }) );
        return 0;
    }
    if (_stuck) {
        TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ stuck.\n",
            ({ }) );
        return 0;
    }
    if (!_closed) {
        TP->add_failed_mess(TO,
            "$D $V$0=isn't,aren't$V$ closed.\n",
            ({ }) );
        return 0;
    }
    if (!key) {
        TP->add_failed_mess(TO,
            "$D $V$0=doesn't,don't$V$ have a lock.\n",
            ({ }) );
        return 0;
    }
    if (key != "by hand") {
        if (!keys || !sizeof(keys)) {
            keys = all_inventory(TP);
            inv = 1;
        }
        gkeys = filter(keys, (: $1->query_property( $(key) ) :) );
        if (!sizeof(gkeys)) {
            if (!inv) {
                TP->add_failed_mess(TO,
                    "You cannot $V $D with $I.\n",
                        keys);
                return 0;
            }
            TP->add_failed_mess(TO,
                "You cannot $V $D.\n",
                ({ }) );
            return 0;
        }
        gkeys[0]->use_key(TO);
    }
    if (_trap_lock_func && _trap_lock_ob) {
        if (!call_other(_trap_lock_ob, _trap_lock_func, "unlock", TO, TP)) {
            return 0;
        }
    }
    set_unlocked();
    switch (check_stealth()) {
        case STEALTH_SUCCEEDED:
          if (sizeof (gkeys)) {
            TP->add_succeeded_mess(TO, ({
                "$N $V $D with $I, managing to stay unnoticed.\n",
                "", }),
                ({ ( gkeys[0] ) }) );
          } else {
            TP->add_succeeded_mess(TO, ({
                "$N $V $D, managing to stay unnoticed.\n",
                "", }),
                ({ }) );
          }
            break;
        case STEALTH_FAILED:
            TP->add_succeeded_mess(TO,
                "$N unsuccessfully tr$y to " + query_verb() + " $D while "
                "staying unnoticed.\n", ({ }) );
            break;
        default:
            if (sizeof (gkeys)) {
              TP->add_succeeded_mess(TO,
                 "$N $V $D with $I.\n", ({ gkeys[0] }) );
            } else {
              TP->add_succeeded_mess (TO, "$N $V $D.\n", ({ }));
            }
            break;
    }
    return 1;
}
int do_lock(object *keys) {
    object *gkeys = ({ });
    string key = TO->query_key();
    int inv = 0;
    if (_locked) {
        TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ already locked.\n",
            ({ }) );
        return 0;
    }
    if (_stuck) {
        TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ stuck.\n",
            ({ }) );
        return 0;
    }
    if (!_closed && !do_close()) {
        TP->add_failed_mess(TO,
            "$D $V$0=isn't,aren't$V$ closed.\n",
            ({ }) );
        return 0;
    }
    if (!key) {
        TP->add_failed_mess(TO,
            "$D $V$0=doesn't,don't$V$ have a lock.\n",
            ({ }) );
        return 0;
    }
    if (key != "by hand") {
        if (!keys || !sizeof(keys)) {
            keys = all_inventory(TP);
            inv = 1;
        }
        gkeys = filter(keys, (: $1->query_property( $(key) ) :) );
        if (!sizeof(gkeys)) {
            if (!inv) {
                TP->add_failed_mess(TO, "You cannot lock $D with $I.\n", keys);
                return 0;
            }
            TP->add_failed_mess(TO, "You cannot lock $D.\n", ({ }) );
            return 0;
        }
        gkeys[0]->use_key(TO);
    }
    if (_trap_lock_func && _trap_lock_ob) {
        if (!call_other(_trap_lock_ob, _trap_lock_func, "lock", TO, TP)) {
            return 0;
        }
    }
    set_locked();
    switch (check_stealth()) {
    case STEALTH_SUCCEEDED:
          if (sizeof (gkeys)) {
            TP->add_succeeded_mess(TO, ({
                "$N lock$s $D with $I, managing to stay unnoticed.\n",
                "", }),
                ({ ( gkeys[0] ) }) );
          } else {
            TP->add_succeeded_mess(TO, ({
                "$N lock$s $D, managing to stay unnoticed.\n",
                "", }),
                ({ }) );
          }
        break;
      case STEALTH_FAILED:
        TP->add_succeeded_mess(TO, "$N unsuccessfully tr$y to " +
                               "lock $D while staying unnoticed.\n",
                               ({ }) );
        break;
      default:
        if (sizeof (gkeys)) {
          TP->add_succeeded_mess(TO,
                                 "$N lock$s $D with $I.\n", ({ gkeys[0] }) );
        } else {
          TP->add_succeeded_mess (TO, "$N lock$s $D.\n", ({ }));
        }
        break;
    }
    return 1;
}
int pick_lock(object player) {
    if (_trap_lock_ob
     && !call_other(_trap_lock_ob, _trap_lock_func, "pick", TO, player)) {
        return 0;
    }
    set_locked();
    return 1;
}
int pick_unlock(object player) {
    if (_trap_lock_ob
     && !call_other(_trap_lock_ob, _trap_lock_func, "pick", TO, player)) {
        return 0;
    }
    set_unlocked();
    return 1;
}
int do_open() {
    if (!_closed) {
        TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ already open.\n",
            ({ }) );
        return 0;
    }
    if (_stuck) {
        TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ stuck.\n",
            ({ }) );
        return 0;
    }
    if (_locked && !do_unlock(0)) {
        TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ locked.\n",
            ({ }) );
        return 0;
    }
    if (_trap_open_func && _trap_open_ob) {
        if (!call_other(_trap_open_ob, _trap_open_func, "open", TO, TP)) {
            return 0;
        }
    }
    set_open();
    if (!TO->query_door_name()) {
        switch (check_stealth()) {
            case STEALTH_SUCCEEDED:
                TP->add_succeeded_mess(TO, ({
                    "$N $V $D, managing to stay unnoticed.\n",
                    "", }),
                    ({ }) );
                break;
            case STEALTH_FAILED:
                TP->add_succeeded_mess(TO,
                    "$N unsuccessfully tr$y to " + query_verb() + " $D while "
                    "staying unnoticed.\n", ({ }) );
                break;
            default:
                TP->add_succeeded_mess(TO,
                    "$N $V $D.\n",
                    ({ }) );
                break;
        }
    }
    return 1;
}
int do_close() {
    if (_closed) {
        TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ already closed.\n",
            ({ }) );
        return 0;
    }
    if (_stuck) {
        TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ stuck.\n",
            ({ }) );
        return 0;
    }
    if (_trap_open_func && _trap_open_ob) {
        if (!call_other(_trap_open_ob, _trap_open_func, "close", TO,TP)) {
            return 0;
        }
    }
    set_closed();
    if (_autolock)
        set_locked();
    if (!TO->query_door_name()) {
        switch (check_stealth()) {
            case STEALTH_SUCCEEDED:
                TP->add_succeeded_mess(TO, ({
                    "$N $V $D, managing to stay unnoticed.\n",
                    "", }),
                    ({ }) );
                break;
            case STEALTH_FAILED:
                TP->add_succeeded_mess(TO,
                    "$N unsuccessfully tr$y to " + query_verb() + " $D while "
                    "staying unnoticed.\n", ({ }) );
                break;
            default:
                TP->add_succeeded_mess(TO,
                    "$N $V $D.\n",
                    ({ }) );
                break;
        }
    }
    return 1;
}
string *parse_command_adjectiv_id_list() {
    switch( query_closed_locked_status() ) {
        case CLOSED_LOCKED:
            return ({ "closed", "locked" });
        case CLOSED:
            return ({ "closed", "unlocked" });
        case LOCKED:
            return ({ "open", "locked" });
        default:
            return ({ "open", "unlocked" });
    }
}
mixed *stats() {
  return ({
    ({"closed", query_closed()}),
    ({"transparent", query_transparent()}),
    ({"key", query_key()}),
    ({"difficulty", query_difficulty()}),
    ({"locked", query_locked()}),
    ({"stuck", query_stuck()}),
    ({"open trapped", _trap_open_func != 0}),
    ({"lock trapped", _trap_lock_func != 0}),
    ({"pick skill", query_pick_skill()}),});
}

==================================================
FILE: basic/close_lock_container.c
==================================================

inherit "/std/basic/close_lock";
void set_closed() {
   ::set_closed();
   if (environment()) {
      environment()->remove_inventory_container(this_object());
   }
}
void reset_closed() {
   ::set_closed();
   if (environment()) {
      environment()->add_inventory_container(this_object());
   }
}
void we_moved(object from, object to) {
   if (!query_closed()) {
      if (from) {
         from->remove_inventory_container(this_object());
      }
      if (to) {
         to->add_inventory_container(this_object());
      }
   }
}
void dest_me() {
   if (environment()) {
      environment()->remove_inventory_container(this_object());
   }
}

==================================================
FILE: basic/club_discuss.c
==================================================

#include <clubs.h>
#include <player_handler.h>
#include <player_handler.h>
#define MAX_SUBJECT_LEN 40
#define MAX_CHOICE_LEN 10
#define MIN_TIMEOUT 1
#define MAX_TIMEOUT 20
#define MIN_POSITION_LEN 5
#define SAVE_START "club_discuss -- "
#define CLUB_ALL_POSITIONS "all positions"
string query_club();
int do_vote(int id, string choice);
int do_nominate(int id, string person);
int do_withdraw(int id);
int do_list_all();
int do_list_item(int id);
int do_list_archives();
int do_archive(int num);
private nosave int _last_time;
string discussion_item_list(string player) {
   class discussion_idea* ideas;
   class discussion_idea bing;
   string ret;
   int no;
   ideas = CLUB_HANDLER->query_all_discussion_items(query_club());
   ret = "";
   no = 0;
   if (sizeof(ideas)) {
      foreach (bing in ideas) {
         if (CLUB_HANDLER->is_discussion_item_finished(query_club(),
                                                       bing->id)) {
            CLUB_HANDLER->complete_discussion_item(query_club(),
                                                   bing->id);
         } else {
            if (CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                                            bing->id,
                                                            player)) {
               ret += bing->id + ") " +
                  CLUB_HANDLER->query_discussion_item_short_description(query_club(),
                                                                        bing->id);
               if (CLUB_HANDLER->is_discussion_item_quorum(query_club(),
                                                           bing->id)) {
                  ret += " (quorum)";
               }
               if (CLUB_HANDLER->has_voted_for_discussion_item(query_club(),
                                                               bing->id,
                                                               player)) {
                  ret += " (voted)\n";
               } else {
                  ret += "\n";
               }
               no++;
            }
         }
      }
   }
   if (no == 0) {
      ret += "No items up for discussion.\n";
   }
   return ret;
}
string discussion_item(int id,
                       string player) {
   string ret;
   if (CLUB_HANDLER->query_discussion_item(query_club(), id) &&
       CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                                   id,
                                                   player)) {
      ret = "Discussion item #" + id + " by " +
         CLUB_HANDLER->query_discussion_added_by(query_club(), id) +
         " (Finish: " +
         ctime(CLUB_HANDLER->query_discussion_time_finish(query_club(),
                                                          id)) + ")\n" +
         CLUB_HANDLER->query_discussion_item_long_description(query_club(),
                                                              id) +
         "\n\nWith voting choices of " +
         query_multiple_short(CLUB_HANDLER->query_discussion_choices(query_club(),
                                                                     id)) +
         ".\n";
      if (CLUB_HANDLER->has_voted_for_discussion_item(query_club(),
                                                      id,
                                                      player)) {
         ret += "You have voted for the discussion item.\n";
      }
      if (CLUB_HANDLER->is_no_quorum_discussion_item(query_club(), id)) {
         ret += "The discussion item does not require a quorum to carry.\n";
      } else if (CLUB_HANDLER->is_discussion_item_quorum(query_club(), id)) {
         ret += "The discussion item has reached a quorum, so any result "
            "will be final.\n";
         ret += "The discussion item needed " +
                CLUB_HANDLER->query_discussion_item_quorum_number(query_club(),
                                                                  id) +
                " to vote for quorum and so far " +
                CLUB_HANDLER->query_discussion_item_number_voted(query_club(),
                                                                 id) +
                " people have voted.\n";
      } else {
         ret += "The discussion item needs " +
                CLUB_HANDLER->query_discussion_item_quorum_number(query_club(),
                                                                  id) +
                " to vote for quorum and so far " +
                CLUB_HANDLER->query_discussion_item_number_voted(query_club(),
                                                                 id) +
                " people have voted.\n";
      }
      if (CLUB_HANDLER->is_committee_discussion_item(query_club(), id)) {
         ret += "This is a committee only discussion item.\n";
      }
      return ret;
   }
   return "Lost discussion item of the far west.\n";
}
protected void add_elected_commands(object per) {
   string tmp_name;
   class discussion_idea* ideas;
   tmp_name = replace(lower_case(query_club()), " ", "_");
   per->add_command(tmp_name,
               this_object(),
               "vote for <string'choice'> in <number'id'>",
               (: do_vote($4[1], $4[0]) :));
   per->add_command(tmp_name,
               this_object(),
               "nominate <string'person'> in <number'id'>",
               (: do_nominate($4[1], $4[0]) :));
   per->add_command(tmp_name,
               this_object(),
               "withdraw from <number'id'>",
               (: do_withdraw($4[0]) :));
   per->add_command(tmp_name,
               this_object(),
               "list all [discussion items]",
               (: do_list_all() :));
   per->add_command(tmp_name,
               this_object(),
               "list [discussion item] <number'id'>",
               (: do_list_item($4[0]) :));
   per->add_command(tmp_name,
               this_object(),
               "archives",
               (: do_list_archives() :));
   per->add_command(tmp_name,
               this_object(),
               "archives [list] <number>",
               (: do_archive($4[0]) :));
   if (_last_time + 24 * 60 * 60 < time()) {
      _last_time = time();
      ideas = CLUB_HANDLER->query_all_discussion_items(query_club());
      ideas = filter(ideas,  (:
                   CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                        $1->id,
                                        this_player()->query_name()) :) );
      ideas = filter(ideas, (:
                   !CLUB_HANDLER->has_voted_for_discussion_item(query_club(),
                                        $1->id,
                                        this_player()->query_name()) :) );
      if (sizeof(ideas)) {
         write("%^YELLOW%^There are discussion items you have not voted "
               "for, use '" + tmp_name +
               " list all' for a list.\n%^RESET%^");
      }
   }
}
protected void add_club_commands(object per) {
}
int do_list_all() {
   string ret;
   ret = discussion_item_list(this_player()->query_name());
   write("$P$Discussion items$P$" + ret);
   return 1;
}
int do_list_item(int id) {
   string ret;
   if (!CLUB_HANDLER->query_discussion_item(query_club(), id) ||
       !CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                                    id,
                                                    this_player()->query_name())) {
      add_failed_mess("There is no discussion item #" + id + ".\n");
      return 0;
   }
   ret = discussion_item(id, this_player()->query_name());
   write("$P$Discussion item$P$" + ret);
   return 1;
}
int do_vote(int id,
            string choice) {
   if (!CLUB_HANDLER->query_discussion_item(query_club(), id) ||
       !CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                                    id,
                                                    this_player()->query_name())) {
      add_failed_mess("There is no discussion item #" + id + ".\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_discuss_votable(query_club(), id)) {
      add_failed_mess("The discussion item #" + id + " is not able "
                      "to be voted for.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_valid_discussion_choice(query_club(),
                                                 id,
                                                 choice)) {
      add_failed_mess("Invalid choice to the discussion item, the allowed "
                      "choices are " +
                      query_multiple_short(
                        CLUB_HANDLER->query_discussion_choices(query_club(),
                                                               id)) +
                      ".\n");
      return 0;
   }
   if (CLUB_HANDLER->vote_for_discussion_item(query_club(),
                                              id,
                                              this_player()->query_name(),
                                              choice)) {
      add_succeeded_mess(({ "Voted '" + choice + "' for discussion item #" +
                            id + ".\n",
                            "$N voted for a discussion item in '" +
                            CLUB_HANDLER->query_club_name(query_club()) +
                            "'.\n" }));
      return 1;
   } else {
      add_failed_mess("Unable to vote for the discussion item for "
                      "some reason.\n");
      return 0;
   }
}
int do_nominate(int id, string person) {
   if (!CLUB_HANDLER->query_discussion_item(query_club(), id) ||
       !CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                                    id,
                                                    this_player()->query_name())) {
      add_failed_mess("There is no discussion item #" + id + ".\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_discuss_nominateable(query_club(), id)) {
      add_failed_mess("The discussion item #" + id + " is not able "
                      "to be nominated for.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_discuss_person_nominated(query_club(),
                                                 id,
                                                 person,
                                                 this_player()->query_name())) {
      add_failed_mess("The person " + person + " has already been nominated "
                      "for that position.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_creator_club(query_club()) &&
       PLAYER_HANDLER->test_creator(person)) {
      add_failed_mess("You can only nominated creators to positions in "
                      "creator clubs.\n");
      return 0;
   }
   if (CLUB_HANDLER->nominate_discussion_item(query_club(),
                                              id,
                                              this_player()->query_name(),
                                              person)) {
      add_succeeded_mess(({ "Nominated '" + person +
                            "' for discussion item #" + id + ".\n",
                            "$N nominated someone in a discussion item in '" +
                            CLUB_HANDLER->query_club_name(query_club()) +
                            "'.\n" }));
      return 1;
   } else {
      add_failed_mess("Unable to nominate " + person + " for "
                      "some reason.\n");
      return 0;
   }
}
int do_withdraw(int id) {
   if (!CLUB_HANDLER->query_discussion_item(query_club(), id) ||
       !CLUB_HANDLER->can_reference_discussion_item(query_club(),
                                                    id,
                                                    this_player()->query_name())) {
      add_failed_mess("There is no discussion item #" + id + ".\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_discuss_nominateable(query_club(), id)) {
      add_failed_mess("The discussion item #" + id + " is not able "
                      "to be nominated for (and therefor withdrawn from).\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_discuss_person_nominated(query_club(),
                                                 id,
                                                 this_player()->query_name(),
                                                 this_player()->query_name())) {
      add_failed_mess("You have not been nominated for this position.\n");
      return 0;
   }
   if (CLUB_HANDLER->withdraw_discussion_item(query_club(),
                                              id,
                                              this_player()->query_name(),
                                              this_player()->query_name())) {
      add_succeeded_mess(({ "Withdrew from discussion item #" + id + ".\n",
                            "$N withdrew from a discussion item in '" +
                            CLUB_HANDLER->query_club_name(query_club()) +
                            "'.\n" }));
      return 1;
   } else {
      add_failed_mess("Unable to withdraw from the discussion item for "
                      "some reason.\n");
      return 0;
   }
}
int do_list_archives() {
   class club_archive* archives;
   string bing;
   class club_archive fluff;
   int num;
   archives = CLUB_HANDLER->query_archives(query_club());
   if (!sizeof(archives)) {
      add_failed_mess("This club has no archives currently.\n");
      return 0;
   }
   bing = "";
   num = 1;
   foreach (fluff in archives) {
      bing += "#" + num + " finished at " + ctime(fluff->archive_date) + " " +
              fluff->subject + "\n";
      num++;
   }
   write("$P$Club Archives$P$" + bing);
   return 1;
}
int do_archive(int num) {
   string bing;
   class club_archive fluff;
   class club_archive* archives;
   archives = CLUB_HANDLER->query_archives(query_club());
   if (!sizeof(archives)) {
      add_failed_mess("This club has no archives currently.\n");
      return 0;
   }
   if (num < 1 || num > sizeof(archives)) {
      add_failed_mess("The number must be between 1 and " +
                      sizeof(archives) + ".\n");
      return 0;
   }
   fluff = archives[num - 1];
   bing = "Archive #" + num + " finished at " +
           ctime(fluff->archive_date) + " " +
           fluff->subject + "\n" + fluff->matter + "\n";
   write("$P$Club Archives$P$" + bing);
   return 1;
}
mapping query_dynamic_auto_load(mapping map) {
   if (!map) {
      map = ([ ]);
   }
   map[SAVE_START + "last time"] = _last_time;
   return map;
}
void init_dynamic_arg(mapping map) {
   _last_time = map[SAVE_START + "last time"];
}

==================================================
FILE: basic/club_insignia.c
==================================================

#include <clubs.h>
inherit "/std/basic/club_listing";
inherit "/std/basic/club_discuss";
#include <broadcaster.h>
#define SAVE_START "club_insignia"
#define NOMINATION_STATE 1
#define ELECTION_STATE   2
private nosave string _club;
private nosave int _channel_off;
private nosave int _last_state;
private nosave int _last_club_time;
private nosave int _callout_id;
private nosave string _brief_string;
private nosave int _brief_mode;
private string *query_not_voted_for(string name);
protected int do_recruit(object *players, string club);
protected int club_chat(string str, int emote);
protected int do_history();
protected int do_channel_off(int new_value);
protected int do_resign();
protected int do_resign_position(string name);
protected int do_disbar(string name);
protected int do_brief_mode(int mode);
protected int do_brief_string(string str);
private int query_has_nominated_someone(string name);
private void check_announce(object player);
protected int do_announcement();
string query_club();
private void add_broadcaster() {
   if (query_club()) {
      BROADCASTER->add_object_to_channel(lower_case(query_club()),
                                         this_object());
   }
}
void set_club(string club) {
   if (_club) {
      BROADCASTER->remove_object_from_channel(lower_case(_club),
                                              this_object());
   }
   if (club) {
      _club = CLUB_HANDLER->query_club_name(club);
      add_broadcaster();
   } else {
      _club = 0;
   }
}
string query_club() {
   return _club;
}
protected void add_elected_commands(object per) {
   string tmp_name;
   string *not_voted;
   int announce;
   if (!query_club()) {
      return ;
   }
   tmp_name = replace(lower_case(query_club()), " ", "_");
   per->add_command(tmp_name, this_object(), "announcement",
               (: do_announcement() :));
   per->add_command(tmp_name,
                    this_object(),
                    "resign as <string'position'>",
                    (: do_resign_position($4[0]) :) );
   if (CLUB_HANDLER->is_nomination_in_progress(query_club())) {
      if (_last_state != NOMINATION_STATE ||
           _last_club_time + 24 * 60 * 60 < time()) {
         _last_state = NOMINATION_STATE;
         _last_club_time = time();
         if (!query_has_nominated_someone(this_player()->query_name())) {
            call_out((: tell_object($1,
                "%^YELLOW%^The club '" + query_club() + "' is currently accepting "
                "nominations for positions.%^RESET%^\n") :), 2, this_player());
         }
      }
   } else if (CLUB_HANDLER->is_voting_in_progress(query_club())) {
      if (_last_state != ELECTION_STATE ||
          _last_club_time + 24 * 60 * 60 < time()) {
         _last_state = ELECTION_STATE;
         _last_club_time = time();
         not_voted = query_not_voted_for(this_player()->query_name());
         if (sizeof(not_voted)) {
            call_out((: tell_object($1,
                "%^YELLOW%^You have not voted for " +
                query_multiple_short($(not_voted)) + " in '" + query_club() +
                "'.%^RESET%^\n") :), 2, this_player());
         }
      }
   } else {
      _last_state = 0;
   }
   announce = CLUB_HANDLER->query_announcement_time(query_club());
   if (announce &&
       announce != this_player()->query_property(_club + " announce time")) {
      remove_call_out(_callout_id);
      _callout_id = call_out((: check_announce :), 0, this_player());
   }
   this_player()->add_property(_club + " announce time",
              this_player()->query_property(_club + " announce time"),
                                  4 * 7 * (24 * 60 * 60));
   club_discuss::add_elected_commands(per);
}
protected void add_club_commands(object per) {
   string tmp_name;
   if (!query_club()) {
      return ;
   }
   tmp_name = replace(lower_case(query_club()), " ", "_");
   per->add_command("recruit",
                    this_object(),
                    "<indirect:living'player'> into <string'club'>",
                  (: do_recruit($1, $4[1]) :) );
   per->add_command(tmp_name,
                    this_object(),
                    "members",
                         (: club_members(query_club(), 0, this_player()->query_name()) :));
   per->add_command(tmp_name,
                    this_object(),
                    "recruit <indirect:living'player'>",
                         (: do_recruit($1, query_club()) :));
   per->add_command(tmp_name,
                    this_object(),
                    "members {online|listening}",
                         (: club_members(query_club(), ($4[0]=="online"?1:2),
                                         this_player()->query_name()) :));
   per->add_command(tmp_name,
                    this_object(),
                    "info",
                         (: club_info(query_club(), 1,
                                      this_player()->query_name()) :));
   per->add_command(tmp_name,
                    this_object(),
                    "talk <string>", (: club_chat($4[0], 0) :));
   per->add_command(tmp_name,
                    this_object(),
                    "emote <string>", (: club_chat($4[0], 1) :));
   per->add_command(tmp_name,
                    this_object(),
                    "history", (: do_history() :));
   per->add_command(tmp_name,
                    this_object(),
                    "resign", (: do_resign() :));
   per->add_command(tmp_name,
                    this_object(),
                    "disbar <string'member'>", (: do_disbar($4[0]) :));
   per->add_command(tmp_name,
                    this_object(),
                    "mute {on|off}",
                    (: do_channel_off($4[0] == "on") :));
   per->add_command(tmp_name,
                    this_object(),
                    "brief {on|off}",
                    (: do_brief_mode($4[0] == "on") :));
   per->add_command(tmp_name,
                    this_object(),
                    "brief name <string'brief name'>",
                    (: do_brief_string($4[0]) :));
   club_discuss::add_club_commands(per);
   if (CLUB_HANDLER->is_elected_club(query_club())) {
      add_elected_commands(this_player());
   }
}
void init() {
   if (query_club() &&
       this_player() == environment() &&
       CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      this_player()->add_player_club(query_club());
      add_club_commands(this_player());
   } else {
      this_player()->remove_player_club(query_club());
   }
}
private void check_announce(object player) {
   int announce;
   if (!query_club()) {
      return ;
   }
   announce = CLUB_HANDLER->query_announcement_time(query_club());
   if (this_player() &&
       announce &&
       announce != this_player()->query_property(_club + " announce time")) {
      remove_call_out(_callout_id);
      call_out((: check_announce :), 15 * 60, player);
      tell_object(player,
                  "\n%^YELLOW%^The club '" +
                  CLUB_HANDLER->query_club_name(query_club()) +
                  "' has a new announcement.\n%^RESET%^\n");
   }
}
private int query_has_nominated_someone(string name) {
   string *positions;
   string pos;
   string *people;
   string person;
   positions = CLUB_HANDLER->query_valid_positions(query_club());
   foreach (pos in positions) {
      people = CLUB_HANDLER->query_nominated_for(query_club(), pos);
      foreach (person in people) {
         if (member_array(name,
                 CLUB_HANDLER->query_nominators_for(query_club(), pos, person)) != -1) {
            return 1;
         }
      }
   }
   return 0;
}
private string *query_not_voted_for(string name) {
   string *positions;
   positions = CLUB_HANDLER->query_valid_positions(query_club());
   positions = filter(positions,
         (: !CLUB_HANDLER->has_person_voted(query_club(), $1, $(name)) &&
            sizeof(CLUB_HANDLER->query_nominated_for(query_club(), $1)) > 1 :));
   return positions;
}
int query_channel_off() {
   return _channel_off;
}
int query_brief_mode() {
   return _brief_mode;
}
string query_brief_string() {
   return _brief_string;
}
protected int club_chat(string str, int emote) {
   string player_name;
   string channel_name;
   string colour;
   if (!CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      add_failed_mess("You can only chat to clubs you are a member of.\n");
      return 0;
   }
   if (_channel_off) {
      add_failed_mess("You have your club channel turned off.\n");
      return 0;
   }
   player_name = this_player()->query_cap_name();
   if (this_player()->query_family_name()) {
      player_name += " " + this_player()->query_family_name();
   }
   BROADCASTER->broadcast_to_channel(this_player(),
                                     lower_case(query_club()),
                                     ({ str, emote }));
   if (_brief_mode) {
      channel_name = _brief_string;
   } else {
      channel_name = query_club();
   }
   colour = this_player()->colour_event("club_" +
                       CLUB_HANDLER->normalise_name(query_club()), "%^CYAN%^");
   if (emote) {
      write("$I$5=(" + colour + channel_name +
            "%^RESET%^) " + player_name +
            " " + str + "\n");
   } else {
      write("$I$5=(" + colour + channel_name +
            "%^RESET%^) " + player_name +
            ": " + str + "\n");
   }
   if (!this_player()->query_hide_invis()["hiding"] &&
       !this_player()->query_invis()) {
      add_succeeded_mess(({ "",
                            "$N stare$s intently into space for a bit.\n" }));
   }
   return 1;
}
void event_channel_message(object ob, string channel, mixed *data) {
   object our_player;
   int emote;
   string message;
   string player_name;
   string channel_name;
   string colour;
   if (channel != lower_case(query_club())) {
      return ;
   }
   our_player = environment();
   if (our_player &&
       userp(our_player) &&
       our_player != this_player()) {
      if (sizeof(our_player->query_ignoring( ({ ob }) ))) {
          return ;
      }
      emote = data[CLUB_MESSAGE_EMOTE_INDEX];
      message = data[CLUB_MESSAGE_MESSAGE_INDEX];
      if (CLUB_HANDLER->is_member_of(query_club(), our_player->query_name()) &&
          !_channel_off) {
         player_name = ob->query_cap_name();
         if (ob->query_family_name()) {
            player_name += " " + ob->query_family_name();
         }
         if (_brief_mode) {
            channel_name = _brief_string;
         } else {
            channel_name = query_club();
         }
         colour = our_player->colour_event("club_" +
                       CLUB_HANDLER->normalise_name(query_club()), "%^CYAN%^");
         if (emote) {
            our_player->add_message("$I$5=(" + colour + channel_name +
                                    "%^RESET%^) " +
                                    player_name + " " + message +
                                    "\n%^RESET%^", ({ }));
         } else {
            our_player->add_message("$I$5=(" + colour + channel_name +
                                    "%^RESET%^) " +
                                    player_name + ": " + message +
                                    "\n%^RESET%^", ({ }));
         }
      }
   }
}
mapping query_dynamic_auto_load(mapping map) {
   if (!map) {
      map = ([ ]);
   }
   map[SAVE_START + "club"] =  query_club();
   map[SAVE_START + "channel off"] =  _channel_off;
   map[SAVE_START + "last state"] = _last_state;
   map[SAVE_START + "last time"] = _last_club_time;
   map[SAVE_START + "brief mode"] = _brief_mode;
   map[SAVE_START + "brief string"] = _brief_string;
   return club_discuss::query_dynamic_auto_load(map);
}
void init_dynamic_arg(mapping map) {
   string fluff;
   set_club(map[SAVE_START + "club"]);
   _channel_off = map[SAVE_START + "channel off"];
   _last_state = map[SAVE_START + "last state"];
   _last_club_time = map[SAVE_START + "last time"];
   _brief_mode = map[SAVE_START + "brief mode"];
   _brief_string = map[SAVE_START + "brief string"];
   if (query_club()) {
      fluff = CLUB_HANDLER->query_club_name(query_club());
   }
   if (fluff) {
      _club = fluff;
   }
   club_discuss::init_dynamic_arg(map);
}
protected int do_recruit(object *obs, string club) {
   object ob;
   object *already;
   object *invites;
   object *not_player;
   if (!query_club()) {
      add_failed_mess("The club associated with this badge appears to "
                      "have evaporated.\n");
      return 0;
   }
   if (lower_case(club) != lower_case(query_club())) {
      add_failed_mess("You can only recruit people to club '" + query_club() + "', "
                      "not '" + club  + "'.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_recruiter_of(query_club(), this_player()->query_name())) {
      add_failed_mess("You must be a recruiter to recruit people to "
                      "the club.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_personal_club(query_club()) &&
       sizeof(CLUB_HANDLER->query_members(query_club())) >= CLUB_MAXIMUM_ELECTED_MEMBERS) {
      add_failed_mess("Your club has more than " +
                      query_num(CLUB_MAXIMUM_ELECTED_MEMBERS) + " members, so it "
                      "must change into an elected club before more "
                      "can be added.\n");
      return 0;
   }
   invites = ({ });
   already = ({ });
   not_player = ({ });
   foreach (ob in obs) {
      if (!userp(ob)) {
         not_player += ({ ob });
      } else if (!CLUB_HANDLER->is_member_of(query_club(), ob->query_name())) {
         invites += ({ ob });
         tell_object(ob, this_player()->the_short() + " invites you to "
                         "join the club '" + query_club() + "'.\nUse the command "
                         "'accept invite from " +
                         this_player()->query_name() +
                         " to " + query_club() + "'.\n");
         ob->add_respond_command(CLUB_RESPOND_TYPE, this_player(),
                                 query_club());
      } else {
         already += ({ ob });
      }
   }
   if (!sizeof(invites)) {
      if (sizeof(already)) {
         if (sizeof(already) > 1) {
            add_failed_mess("$I are already members of the club '" +
                         query_club() + "'.\n", already);
         } else {
            add_failed_mess("$I is already a member of the club '" +
                         query_club() + "'.\n", already);
         }
      }
      if (sizeof(not_player)) {
         add_failed_mess("You can only recruit players into the club, $I " +
                         (sizeof(not_player) > 1?"are not players":
                                                  "is not a player"),
                         not_player);
      }
   } else {
      add_succeeded_mess(({
        "$N invite $I to join the club '" + query_club() + "'.\n",
        "$N invites $I to join the club '" + query_club() + "'.\n" }),
                         invites);
   }
   return sizeof(invites) > 0;
}
protected int do_history() {
   mixed *history;
   mixed *data;
   int emote;
   string message;
   string name;
   string colour;
   string tim;
   if (!CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      add_failed_mess("You must be a member of the club to get a "
                      "history of its channel.\n");
      return 0;
   }
   history = BROADCASTER->query_channel_history(lower_case(query_club()));
   if (!history ||
       !sizeof(history)) {
      add_failed_mess("No history for this channel.\n");
      return 0;
   }
   colour = this_player()->colour_event("club_" +
                       CLUB_HANDLER->normalise_name(query_club()), "%^CYAN%^");
   foreach (data in history) {
      name = data[0];
      emote = data[1][CLUB_MESSAGE_EMOTE_INDEX];
      message = data[1][CLUB_MESSAGE_MESSAGE_INDEX];
      if (sizeof(data) > 2) {
         tim = ctime(data[2])[4..15];
      } else {
         tim = "";
      }
      if (emote) {
         this_player()->add_message("$I$5=(" + colour +
                         CLUB_HANDLER->query_club_name(query_club()) +
                         "%^RESET%^ " + tim + ") " +
                     name + " " + message + "\n", ({ }));
      } else {
         this_player()->add_message("$I$5=(" + colour +
                         CLUB_HANDLER->query_club_name(query_club()) +
                         "%^RESET%^ " + tim + ") " +
                     name + ": " + message + "\n", ({ }));
      }
   }
   write("History for the '" + query_club() + "' club channel.\n");
   return 1;
}
protected int do_channel_off(int flag) {
   if (!CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      add_failed_mess("You must be a member of the channel to turn it off.\n");
      return 0;
   }
   if (_channel_off == flag) {
      if (_channel_off) {
         add_failed_mess("The channel is already muted.\n");
      } else {
         add_failed_mess("You are already listening to the channel.\n");
      }
      return 0;
   }
   _channel_off = flag;
   if (_channel_off) {
      add_succeeded_mess(({ "Muting the channel '" + query_club() + "'.\n", "" }));
   } else {
      add_succeeded_mess(({ "Removing the mute from the channel '" + query_club() +
                            "'.\n", "" }));
   }
   return 1;
}
protected int do_brief_mode(int mode) {
   if (!_brief_string) {
      add_failed_mess("You need to set a brief string for '" +
                      query_club() + "' before you can change the brief "
                      "mode.\n");
      return 0;
   }
   _brief_mode = mode;
   if (_brief_mode) {
      write("Set the channel '" + query_club() + "' into brief mode "
            "(using '" + _brief_string + "' as the channel name).\n");
   } else {
      write("Set the channel '" + query_club() + "' into verbose mode,\n");
   }
   return 1;
}
protected int do_brief_string(string str) {
   if (strlen(str) > strlen(query_club())) {
      add_failed_mess("Cannot set the channel name brief to longer than it "
                      "already is!\n");
      return 0;
   }
   write("Setting the brief channel name for '" + query_club() +
         "' to '" + str + "'.\n");
   _brief_string = str;
   return 1;
}
protected int do_resign_position(string position) {
   if (!query_club()) {
      add_failed_mess("This badge is not associated with any clubs!\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_member_of(query_club(),
                                   this_player()->query_name())) {
      add_failed_mess("You need to be a member of a club before you can "
                      "resign from it.\n");
      return 0;
   }
   if (!CLUB_HANDLER->holds_position_of(query_club(),
                                        position,
                                        this_player()->query_name())) {
      add_failed_mess("You need to hold a position before you can "
                      "resign from it.\n");
      return 0;
   }
   write("Are you sure you wish to resign from the position " + position +
         " in the club '" + query_club() + "'? ");
   input_to("confirm_resign", 0, position);
   add_succeeded_mess("");
   return 1;
}
protected int do_resign() {
   if (!query_club()) {
      add_failed_mess("This badge is not associated with any clubs!\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_member_of(query_club(),
                                   this_player()->query_name())) {
      add_failed_mess("You need to be a member of a club before you can "
                      "resign from it.\n");
      return 0;
   }
   write("Are you sure you wish to resign from the club '" +
         query_club() + "'? ");
   input_to("confirm_resign");
   add_succeeded_mess("");
   return 1;
}
private void do_fixup_badges(string club_name) {
   object ob;
   string club;
   foreach (ob in all_inventory(this_player())) {
      club = ob->query_club();
      if (club &&
          ob->query_club_insignia()) {
         if (CLUB_HANDLER->query_club_name(club) ==
             CLUB_HANDLER->query_club_name(query_club())) {
            set_club(0);
         }
      }
   }
}
protected void confirm_resign(string str, string position) {
   string club;
   str = lower_case(str);
   if (!strlen(str) ||
       str[0] == 'n') {
      write("Aborted resignation.\n");
      return 0;
   }
   if (str[0] == 'y') {
      if (!position) {
         if (CLUB_HANDLER->remove_member(query_club(),
                                         this_player()->query_name())) {
            write("You have resigned from the club '" + query_club() + "'.\n");
            club = query_club();
            set_club(0);
            call_out( (: do_fixup_badges :), 0, club);
         } else {
            write("You were unable to resign from the club '" + query_club() +
                  "'.\n");
         }
      } else {
         if (CLUB_HANDLER->set_position_holder(query_club(),
                                              position,
                                              CLUB_UNKNOWN_MEMBER)) {
            write("You have resigned from the position " + position +
                  " in the club '" + query_club() + "'.\n");
         } else {
            write("You were unable to resign from the position " + position +
                  " in the club '" + query_club() + "'.\n");
         }
      }
   } else {
      write("You need to answer yes or no.\n");
      if (!position) {
         write("Are you sure you wish to resign from the club '" +
                         query_club() + "'? ");
      } else {
         write("Are you sure you wish to resign from the position " + position +
               " in the club '" + query_club() + "'? ");
      }
      input_to("confirm_resign", 0, position);
   }
}
protected int do_disbar(string name) {
   if (!CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      add_failed_mess("You must be a member of the club before you can "
          "disbar people from it.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_elected_club(query_club())) {
      if (!CLUB_HANDLER->is_president_of(query_club(), this_player()->query_name()) &&
          !CLUB_HANDLER->is_vice_president_of(query_club(), this_player()->query_name())) {
         add_failed_mess("You must be the president or the vice president to "
                         "disbar someone.\n");
         return 0;
      }
   } else if (!CLUB_HANDLER->is_founder_of(query_club(), this_player()->query_name())) {
      add_failed_mess("You must be the founder of the club to disbar "
                      "someone.\n");
      return 0;
   }
   name = lower_case(name);
   if (name == this_player()->query_name()) {
      add_failed_mess("You cannot disbar yourself.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_member_of(query_club(), name)) {
      add_failed_mess("You must disbar someone who is a member of the "
                      "club.\n");
      return 0;
   }
   write("Do you want to disbar " + capitalize(name) + " from the club '" +
                   query_club() + "'? ");
   add_succeeded_mess("");
   input_to("confirm_disbar", 0, name);
   return 1;
}
protected void confirm_disbar(string str, string name) {
   if (str == "" ||
       str[0] == 'q' ||
       str[0] == 'n') {
      write("Aborting disbar.\n");
      return ;
   }
   if (str[0] == 'y') {
      if (CLUB_HANDLER->remove_member(query_club(), name)) {
         write("Disbarred " + capitalize(name) +
               " from the club '" + query_club() + "'.\n");
      } else {
         write("You were unable to disbar " + capitalize(name) +
               " from the club '" + query_club() + "'.\n");
      }
   } else {
      write("You must type yes or no.\n");
      write("Do you want to disbar " + capitalize(name) + " from the club '" +
                      query_club() + "'? ");
      input_to("confirm_disbar", 0, name);
   }
}
protected int do_announcement() {
   string announce;
   announce = CLUB_HANDLER->query_announcement(query_club());
   if (!strlen(announce)) {
      add_failed_mess("There is no announcement to read.\n");
      return 0;
   }
   write("$P$Announcement$P$Added by the president or secretary at " +
         ctime(CLUB_HANDLER->query_announcement_time(query_club())) + "\n" +
         announce + "\n");
   this_player()->add_property(_club + " announce time",
                               CLUB_HANDLER->query_announcement_time(query_club()),
                               4 * 7 * (24 * 60 * 60));
   return 1;
}
void event_joined_club(object person, string club_name) {
   if (CLUB_HANDLER->query_club_name(query_club()) ==
       CLUB_HANDLER->query_club_name(club_name)) {
      add_club_commands(environment());
   }
}
void event_club_changed(object person,
                        string club_name) {
   if (CLUB_HANDLER->is_elected_club(club_name)) {
      call_out( (: add_elected_commands(environment()) :), 0);
   }
}
mixed * stats()
{
  return ({
    ({ "club name", _club })
    });
}

==================================================
FILE: basic/club_listing.c
==================================================

#include <clubs.h>
#include <broadcaster.h>
#include <player_handler.h>
protected string sort_and_capitalise(string *arr) {
   return query_multiple_short(sort_array(map(arr, (: capitalize :)), 0));
}
protected object person_in_control(object ob) {
   if (ob && environment(ob) &&
       !ob->query_channel_off()) {
      if (living(environment(ob))) {
         return environment(ob);
      }
      ob = environment(ob);
   }
   return 0;
}
private string add_flags_to_name(string club, string name, string output_name) {
   if (CLUB_HANDLER->is_recruiter_of(club, name)) {
      return output_name + "(%^YELLOW%^r%^RESET%^)";
   }
   return output_name;
}
protected int club_members(string club, int online, string person) {
   string *members;
   object *obs;
   string *bing;
   if (CLUB_HANDLER->query_club_secret(club)) {
      if (!CLUB_HANDLER->is_member_of(club, person)) {
         add_failed_mess("You must be a member of a secret club to get "
                         "the members of it.\n");
         return 0;
      }
   }
   members = CLUB_HANDLER->query_members(club);
   if (online == 1) {
      members = filter(members, (: find_player($1) && find_player($1)->query_cap_name() :) );
      write("The currently online members of " + club +
                            " are:\n$C$$I$5=" +
                      query_multiple_short(sort_array(map(members,
                    (: add_flags_to_name($(club), $1, find_player(lower_case($1))->query_cap_name()) :)), 0)) +
                      ".\n");
   } else if (online == 2) {
      obs = BROADCASTER->query_channel_members(lower_case(club));
      bing = map(filter(map(obs, (: person_in_control($1) :)),
                        (: $1 && reference_allowed($1, $(person)) :)),
                 (: $1?$1->query_name():0 :));
      bing = bing & members;
      write("The current members of " + club +
                            " listening are:\n$C$$I$5=" +
                      sort_and_capitalise(bing) + ".\n");
   } else {
      write("The current members of " + club +
                            " are:\n$C$$I$5=" +
                      sort_and_capitalise(
       map(members, (: add_flags_to_name($(club), $1, $1) :))) + ".\n");
   }
   return 1;
}
protected int club_list(string person,
                        int print_families,
                        function check_list) {
   string *clubs;
   string club;
   string stuff;
   int num;
   int found;
   clubs = CLUB_HANDLER->query_clubs();
   if (!sizeof(clubs)) {
       add_failed_mess("There are no clubs or families to list.\n");
       return 0;
   }
   if (print_families) {
      clubs = filter(clubs, (: CLUB_HANDLER->is_family($1) :));
      stuff = "Families:\n";
   } else {
      clubs = filter(clubs, (: !CLUB_HANDLER->is_family($1) :));
      stuff = "Clubs:\n";
   }
   clubs = sort_array(clubs, 1);
   foreach (club in clubs) {
      if (!check_list ||
          evaluate(check_list, club, person)) {
         found++;
         num = sizeof(CLUB_HANDLER->query_members(club));
         if (CLUB_HANDLER->is_family(club)) {
            stuff += "'" + CLUB_HANDLER->query_club_name(club) +
                     "' was founded by " +
               capitalize(CLUB_HANDLER->query_founder(club)) +
                     " with " + query_num(num) + " member" +
                     (num > 1?"s":"") + ".\n";
         } else if (!CLUB_HANDLER->query_club_secret(club) ||
             CLUB_HANDLER->is_member_of(club, person)) {
            stuff += "'" + CLUB_HANDLER->query_club_name(club) +
                     "' founded by " +
                     capitalize(CLUB_HANDLER->query_founder(club)) +
                     " with " + query_num(num) + " member" +
                     (num > 1?"s":"") + ".\n";
          } else {
            stuff += "'" + CLUB_HANDLER->query_club_name(club) +
                     "' founded by " +
                     capitalize(CLUB_HANDLER->query_founder(club)) +
                     " with an unknown number of members.\n";
          }
       }
    }
    if (!found) {
       return 0;
    }
    if (print_families) {
       write("$P$Family list$P$" + stuff);
    } else {
       write("$P$Club list$P$" + stuff);
    }
    return 1;
}
protected string club_info_string(string name,
                                  int show_election,
                                  string person) {
   string *nominations;
   string *positions;
   string *online;
   string pos;
   string nom;
   string last;
   string ret;
   string desc;
   string status;
   int member;
   int min;
   if (!CLUB_HANDLER->is_club(name) ||
       CLUB_HANDLER->is_family(name)) {
      return 0;
   }
   ret = "";
   member = CLUB_HANDLER->is_member_of(name, person);
   if (CLUB_HANDLER->query_club_secret(name)) {
      if (!member) {
         return "This is a secret club and no information is shown "
                "about the club to non members.\n";
      } else {
         ret += "This is a secret club!  Information about members is not "
                "shown to people outside the club.\n";
      }
   }
   ret += "Information on club '" + name + "' with a founder of " +
         capitalize(CLUB_HANDLER->query_founder(name)) +
         " based in " +
         CLUB_HANDLER->query_club_region(name) +
         ".\n";
   desc = CLUB_HANDLER->query_club_description(name);
   if (desc) {
      ret += "$I$2=  " + desc + "\n%^RESET%^$I$0=";
   }
   online = filter(CLUB_HANDLER->query_members(name), (: find_player($1) :));
   if (sizeof(online)) {
      ret += "$I$5=The online members are: " +
          sort_and_capitalise(online) +
          ".$I$0=\n";
   }
   ret += "$I$5=The not currently online members are: " +
          sort_and_capitalise(CLUB_HANDLER->query_members(name) - online) +
          ".$I$0=\n";
   if (!CLUB_HANDLER->is_family(name)) {
      ret += "$I$5=The recruiters are: " +
            sort_and_capitalise(CLUB_HANDLER->query_recruiters(name)) +
            ".$I$0=\n";
   }
   if (CLUB_HANDLER->is_elected_club(name)) {
      ret += "This is an elected club type.\n";
      positions = CLUB_HANDLER->query_valid_positions(name);
      foreach (pos in positions) {
         ret += capitalize(pos) + ": " +
               capitalize(CLUB_HANDLER->query_position_members(name,
                                                     pos)) + "\n";
      }
      if (CLUB_HANDLER->is_nomination_in_progress(name) &&
          show_election) {
         status = CLUB_HANDLER->query_election_status(name);
         ret += "\nThe player must nominate themselves to accept the "
               "nomination.  Until this point the nomination is not "
               "accepted.\n";
         if (status) {
            ret += status + "\n";
         }
         ret += "The club is currently accepting nominations for "
               "positions, the nomination period ends at " +
               ctime(CLUB_HANDLER->query_next_event_time(name)) +
               ".  So far the following have been "
               "nominated:\n";
         foreach (pos in positions) {
            nominations = CLUB_HANDLER->query_nominated_for(name, pos);
            if (sizeof(nominations)) {
               ret += capitalize(pos) + " has the following nominations:\n";
               foreach (nom in nominations) {
                  if (CLUB_HANDLER->is_nomination_accepted(name, pos, nom)) {
                     last = " (accepted).\n";
                  } else {
                     last = ".\n";
                  }
                  if (sizeof(CLUB_HANDLER->query_nominators_for(name, pos, nom))) {
                     ret += "$I$9=     " + capitalize(nom) + " nominated by " +
                           sort_and_capitalise(
                           CLUB_HANDLER->query_nominators_for(name, pos, nom)) +
                           last + "$I$0=";
                  } else {
                     ret += "$I$9=     " + capitalize(nom) + " nominated by " +
                           "noone" + last + "$I$0=";
                  }
               }
           } else {
               ret += "No nominations for the position of " + capitalize(pos) +
                     ".\n";
           }
         }
      } else if (CLUB_HANDLER->is_election_in_progress(name) &&
                 show_election) {
         status = CLUB_HANDLER->query_election_status(name);
         ret += "\nThe club is currently electing new committee members, the "
               "vote ends at " +
               ctime(CLUB_HANDLER->query_next_event_time(name)) +
               ".\n";
         if (status) {
            ret += status + "\n";
         }
         if (member) {
            ret += "You can vote for:\n";
         } else {
            ret += "Nominations for the positions are:\n";
         }
         foreach (pos in positions) {
            nominations = CLUB_HANDLER->query_nominated_for(name, pos);
            if (sizeof(nominations)) {
               ret += capitalize(pos) + ": " +
                     sort_and_capitalise(nominations) +
                     ".";
               if (member) {
                  if (CLUB_HANDLER->has_person_voted(name,
                                                pos,
                                                this_player()->query_name())) {
                     ret += " (voted)\n";
                  } else {
                     ret += " (not voted)\n";
                  }
               } else {
                  ret += "\n";
               }
            } else {
               ret += capitalize(pos) + ": " +
                      capitalize(CLUB_HANDLER->query_position_members(name,
                                                           pos)) +
                      " elected with no opposition.\n";
            }
         }
      } else {
         min = CLUB_HANDLER->query_minimum_next_election(name);
         if (min < time()) {
            ret += "The next default election will be held at " +
                   ctime(CLUB_HANDLER->query_next_election(name)) + " and an "
                   "election can now be forced.\n";
         } else {
            ret += "The next default election will be held at " +
                   ctime(CLUB_HANDLER->query_next_election(name)) + " and an "
                   "election can be forced after " +
                   ctime(min) + ".\n";
         }
      }
   }
   return ret;
}
protected int club_info(string name, int show_election, string person) {
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("There is no club called " + name + ".\n");
      return 0;
   }
   if (CLUB_HANDLER->query_club_secret(name)) {
      if (!CLUB_HANDLER->is_member_of(name, person)) {
         add_failed_mess("You must be a member of a secret club to "
                         "see information on it.\n");
         return 0;
      }
   }
   write("$P$" + CLUB_HANDLER->query_club_name(name) + "$P$" +
          club_info_string(name, show_election, person));
   return 1;
}
string player_relationships_string(string player) {
   string family;
   string ret;
   string region;
   class relationship_data *wombles;
   int gender;
   int i;
   family = PLAYER_HANDLER->test_family(player);
   if (!family) {
      return "";
   }
   if (!CLUB_HANDLER->is_family(family)) {
      return "";
   }
   ret = "";
   region = CLUB_HANDLER->query_club_region(family);
   wombles = CLUB_HANDLER->query_relationships(family,
                                               player);
   wombles = sort_array(wombles,
                        (: strcmp($1->related_to, $2->related_to) :));
   gender = PLAYER_HANDLER->test_gender(player);
   if (gender) {
      gender -= 1;
   }
   if (sizeof(wombles)) {
      for (i = 0; i < sizeof(wombles); i++) {
         ret += CLUB_HANDLER->query_relationship_gender(wombles[i]->relationship, gender, region) +
             " of " + capitalize(wombles[i]->related_to);
         if (i == sizeof(wombles) - 2) {
            ret += " and ";
         } else if (i < sizeof(wombles) -2) {
            ret += "; ";
         }
      }
   }
   return ret;
}
protected string family_info_string(string name,
                                    string person) {
   string ret;
   string desc;
   if (!CLUB_HANDLER->is_family(name)) {
      return 0;
   }
   ret = "";
   ret += "Information on family '" + name + "' with a founder of " +
         capitalize(CLUB_HANDLER->query_founder(name)) +
         " based in " +
         CLUB_HANDLER->query_club_region(name) + ".\n";
   desc = CLUB_HANDLER->query_club_description(name);
   if (desc) {
      ret += "$I$2=  " + desc + "\n%^RESET%^$I$0=";
   }
   ret += "$I$5=The members are: " +
          sort_and_capitalise(CLUB_HANDLER->query_members(name)) +
          ".$I$0=\n";
   return ret;
}
protected int family_info(string name, string person) {
   if (!CLUB_HANDLER->is_family(name)) {
      add_failed_mess("There is no family called " + name + ".\n");
      return 0;
   }
   write("$P$" + CLUB_HANDLER->query_club_name(name) + "$P$" +
          family_info_string(name, person));
   return 1;
}
protected string www_finger_name(string name) {
   return "<a href=\"finger.c?player=" + lower_case(name) + "\">" +
          name + "</a>";
}
protected string www_club_list(string person, int print_families, int start, int show) {
   string *clubs;
   string club;
   string stuff;
   int num;
   clubs = CLUB_HANDLER->query_clubs();
   if (!sizeof(clubs)) {
       return "There are no clubs or families to list.\n";
   }
   if (print_families) {
      clubs = filter(clubs, (: CLUB_HANDLER->is_family($1) :));
      stuff = "<h2>Current " + mud_name() + " Families</h2>\n";
   } else {
      clubs = filter(clubs, (: !CLUB_HANDLER->is_family($1) :));
      stuff = "<h2>Current " + mud_name() + " Clubs</h2>\n";
   }
   clubs = sort_array(clubs, 1);
   stuff += "<ul>";
   foreach (club in clubs[start..start+show]) {
      num = sizeof(CLUB_HANDLER->query_members(club));
      if (CLUB_HANDLER->is_family(club) ||
          !CLUB_HANDLER->query_club_secret(club) ||
          CLUB_HANDLER->is_member_of(club, person)) {
         stuff += "<li>'<a href=\"club_info.c?club_name=" + club + "\">" +
                  CLUB_HANDLER->query_club_name(club) +
                  "</a>' was founded by " +
            www_finger_name(capitalize(CLUB_HANDLER->query_founder(club))) +
                  " with " + query_num(num) + " member" +
                  (num > 1?"s":"") + ".<br>\n";
       } else {
         stuff += "<li>'<a href=\"club_info.c?club_name=" + club + "\">" +
                  CLUB_HANDLER->query_club_name(club) +
                  "</a>' was founded by " +
            www_finger_name(capitalize(CLUB_HANDLER->query_founder(club))) +
                  " with an unknown number of members.\n";
       }
   }
   if (print_families) {
      return stuff + "</ul>\n" +
           "There are currently " + query_num(sizeof(clubs)) + " "
           "families on " + mud_name() + " \n";
   } else {
       return stuff + "</ul>\n" +
           "There are currently " + query_num(sizeof(clubs)) + " "
           "clubs on " + mud_name() + " \n";
   }
}
protected string www_club_info_string(string name,
                                      int show_election,
                                      string person) {
   string *nominations;
   string *positions;
   string pos;
   string nom;
   string last;
   string ret;
   string desc;
   string status;
   string *stuff;
   int member;
   if (!CLUB_HANDLER->is_club(name) ||
       CLUB_HANDLER->is_family(name)) {
      return 0;
   }
   ret = "";
   member = CLUB_HANDLER->is_member_of(name, person);
   if (CLUB_HANDLER->query_club_secret(name)) {
      if (!member) {
         ret += "This is a secret club!  Information about members is not "
                "shown to people outside the club.<p>\n";
         desc = CLUB_HANDLER->query_club_description(name);
         if (desc) {
            ret += "<blockquote>" + desc + "\n</blockquote>";
         }
         return ret;
      } else {
         ret += "This is a secret club!  Information about members is not "
                "shown to people outside the club.<p>\n";
      }
   }
   ret += "<h4>Information on club '" +
          CLUB_HANDLER->query_club_name(name) +
          "' with a founder of "  +
          www_finger_name(CLUB_HANDLER->query_founder(name)) +
          " based in " +
          CLUB_HANDLER->query_club_region(name) + ".</h4>\n";
   desc = CLUB_HANDLER->query_club_description(name);
   if (desc) {
      ret += "<blockquote>" + desc + "\n</blockquote>";
   }
   stuff = CLUB_HANDLER->query_members(name);
   stuff = sort_array(stuff, 0);
   stuff = map(stuff, (: www_finger_name(capitalize($1)) :) );
   ret += "<dl><dt><b>The members are:</b>\n<dd>" +
          query_multiple_short(stuff) +
          "</dl>\n";
   if (!CLUB_HANDLER->is_family(name)) {
      stuff = CLUB_HANDLER->query_recruiters(name);
      stuff = sort_array(stuff, 0);
      stuff = map(stuff, (: www_finger_name(capitalize($1)) :) );
      ret += "<dl><dt><b>The recruiters are:</b>\n<dd>" +
             query_multiple_short(stuff) +
             "</dl>\n";
   }
   if (CLUB_HANDLER->is_elected_club(name)) {
      ret += "This is an elected club type.<br>\n";
      if (CLUB_HANDLER->query_club_board(name)) {
         ret += "<a href=\"boards.c?board=" +
            replace_string(CLUB_HANDLER->query_club_board_name(name),
                           " ", "%20") +
            "\">The club board</a><p>\n";
      }
      positions = CLUB_HANDLER->query_valid_positions(name);
      ret += "<ul>\n";
      foreach (pos in positions) {
         ret += "<li>" + capitalize(pos) + ": " +
               www_finger_name(capitalize(CLUB_HANDLER->query_position_members(name,
                                                     pos))) + "\n";
      }
      ret += "</ul>";
      if (CLUB_HANDLER->is_nomination_in_progress(name) &&
          show_election) {
         status = CLUB_HANDLER->query_election_status(name);
         ret += "<p>The player must nominate themselves to accept the "
               "nomination.  Until this point the nomination is not "
               "accepted.\n";
         if (status) {
            ret += status + "<p>\n";
         }
         ret += "<p>The club is currently accepting nominations for "
               "positions, the nomination period ends at " +
               ctime(CLUB_HANDLER->query_next_event_time(name)) +
               ".  So far the following have been "
               "nominated:\n<dl>";
         foreach (pos in positions) {
            nominations = CLUB_HANDLER->query_nominated_for(name, pos);
            if (sizeof(nominations)) {
               ret += "<dt>" + capitalize(pos) +
                      " has the following nominations:\n";
               foreach (nom in nominations) {
                  if (CLUB_HANDLER->is_nomination_accepted(name, pos, nom)) {
                     last = " (accepted).\n";
                  } else {
                     last = ".\n";
                  }
                  stuff = CLUB_HANDLER->query_nominators_for(name, pos, nom);
                  stuff = sort_array(stuff, 0);
                  stuff = map(stuff, (: www_finger_name(capitalize($1)) :) );
                  ret += "<dd>" +
                         www_finger_name(capitalize(nom)) + " nominated by " +
                         query_multiple_short(stuff) +
                         last;
               }
           } else {
               ret += "No nominations for the position of " + capitalize(pos) +
                     ".\n";
           }
           ret += "</dl>";
         }
      } else if (CLUB_HANDLER->is_election_in_progress(name) &&
                 show_election) {
         status = CLUB_HANDLER->query_election_status(name);
         ret += "<p>The club is currently electing new committee members, the "
               "vote ends at " +
               ctime(CLUB_HANDLER->query_next_event_time(name)) +
               ".<p>";
         if (status) {
            ret += status + "<p>\n";
         }
         ret += "You can vote for:\n<ul>";
         foreach (pos in positions) {
            stuff = CLUB_HANDLER->query_nominated_for(name, pos);
            if (sizeof(stuff)) {
               stuff = sort_array(stuff, 0);
               stuff = map(stuff, (: www_finger_name(capitalize($1)) :) );
               ret += "<li>" + capitalize(pos) + ": " +
                      query_multiple_short(stuff) +
                     ".";
               if (member) {
                  if (CLUB_HANDLER->has_person_voted(name, pos,
                                     person)) {
                     ret += " (voted)\n";
                  } else {
                     ret += " (not voted)\n";
                  }
               } else {
                  ret += "\n";
               }
            } else {
               ret += "<li>" + capitalize(pos) + ": " +
                   www_finger_name(capitalize(CLUB_HANDLER->query_position_members(name,
                                                        pos))) +
                   " elected with no opposition.\n";
            }
         }
         ret += "</ul>\n";
      }  else {
         ret += "The next election will be held at " +
                ctime(CLUB_HANDLER->query_next_election(name)) + "\n<p>";
      }
   }
   return ret;
}
protected string www_family_info_string(string name,
                                        string person) {
   string ret;
   string desc;
   string per;
   string *stuff;
   if (!CLUB_HANDLER->is_family(name)) {
      return 0;
   }
   ret = "";
   ret += "<h4>Information on family '" +
         CLUB_HANDLER->query_club_name(name) + "' with a founder of " +
         www_finger_name(capitalize(CLUB_HANDLER->query_founder(name))) +
         " based in " +
         CLUB_HANDLER->query_club_region(name) + ".</h4>\n";
   desc = CLUB_HANDLER->query_club_description(name);
   if (desc) {
      ret += "<blockquote>" + desc + "</blockquote>\n";
   }
   ret += "<dl>";
   foreach (per in CLUB_HANDLER->query_members(name)) {
      ret += "<dt>" + www_finger_name(capitalize(per));
   }
   ret += "</dl>";
   stuff = CLUB_HANDLER->query_members(name);
   stuff = sort_array(stuff, 0);
   stuff = map(stuff, (: www_finger_name(capitalize($1)) :) );
   ret += "<dl><dt><b>The members are:</b>\n<dd>" +
          query_multiple_short(stuff) + "</dl>\n";
   return ret;
}

==================================================
FILE: basic/condition.c
==================================================

#include <armoury.h>
#include <move_failures.h>
#define DAMAGE_NORM 200
private nosave int cond, max_cond, lowest_cond, damage_chance, hide_cond;
void create() {
   max_cond = 1;
}
void break_me() {
  if(environment(this_object())) {
    if(living(environment(this_object())))
      tell_object(environment(this_object()),
                  capitalize(this_object()->the_short()) + " breaks!\n");
    else
      tell_room(environment(this_object()),
                capitalize(this_object()->the_short()) + " breaks!\n");
  }
  if((int)this_object()->move("/room/rubbish") != MOVE_OK)
    move_object("/room/rubbish");
}
string cond_string() {
   string pronoun;
   string verb;
   if ( cond > max_cond ) {
      cond = max_cond;
   }
   if ( hide_cond )
      return "";
   pronoun = capitalize(this_object()->query_pronoun());
   verb = this_object()->query_is_pair() ? " are" : " is";
   switch ( ( 100 * cond ) / max_cond ) {
      case 91 .. 100 :
         return pronoun + verb + " in excellent condition.\n";
      case 81 .. 90 :
         return pronoun + verb + " in very good condition.\n";
      case 71 .. 80 :
         return pronoun + verb + " in good condition.\n";
      case 61 .. 70 :
         return pronoun + verb + " in decent condition.\n";
      case 51 .. 60 :
         return pronoun + verb + " in fairly good condition.\n";
      case 41 .. 50 :
         return pronoun + verb + " in fairly poor condition.\n";
      case 31 .. 40 :
         return pronoun + verb + " in poor condition.\n";
      case 21 .. 30 :
         return pronoun + verb + " in really poor condition.\n";
      case 11 .. 20 :
         return pronoun + verb + " in very poor condition.\n";
      case 1 .. 10 :
         return pronoun + verb + " in atrocious condition.\n";
      default :
         return pronoun + verb + " a complete wreck.\n";
   }
}
void set_max_cond(int i) { max_cond = i; }
void set_cond(int i) {
   cond = i;
   if (cond < 0) {
      cond = 0;
   }
   if (cond < lowest_cond) {
      lowest_cond = cond;
   }
   if ( cond <= 0 ) {
      if ( environment( this_object() ) &&
          !environment( this_object() )->query_property("don't break contents")) {
         this_object()->break_me();
      }
      return 0;
   }
}
int adjust_cond( int i ) {
   cond += i;
   if (cond < 0)
      cond = 0;
   if ( cond < lowest_cond )
      lowest_cond = cond;
   if ( cond > max_cond )
      cond = max_cond;
   if ( cond <= 0 ) {
      if ( !environment()->query_property( "don't break contents" ) )
         this_object()->break_me();
      return 0;
   }
   return cond;
}
void set_lowest_cond(int i) { lowest_cond = i; }
void set_hide_cond(int i) { hide_cond = i; }
int query_cond() {
  if ( cond > max_cond ) {
    cond = max_cond;
  }
  return cond;
}
int query_max_cond() { return max_cond; }
int query_lowest_cond() { return lowest_cond; }
int query_hide_cond() { return hide_cond; }
void set_percentage(int i) {
   if (i > 100) {
      i = 100;
   }
   set_cond((query_max_cond() * i) / 100);
   set_lowest_cond((query_cond()*(random(30) + 70)) / 100);
}
int query_damage_chance() { return damage_chance; }
void set_damage_chance( int number ) { damage_chance = number; }
void do_damage( string type, int amount ) {
   int wholes, parts;
   wholes = amount * ( 1 + random( damage_chance ) + random( damage_chance ) );
   parts = wholes % DAMAGE_NORM;
   wholes /= DAMAGE_NORM;
   if ( random( DAMAGE_NORM ) < parts )
      wholes++;
   adjust_cond( -wholes );
}
mixed *stats() {
   return
      ({
         ({ "condition", cond }),
         ({ "max cond", max_cond }),
         ({ "lowest cond", lowest_cond }),
         ({ "damage chance", damage_chance }),
         ({ "hide cond", hide_cond }),
      });
}
mapping query_static_auto_load() {
   return ([
      "max cond" : max_cond,
      "damage chance" : damage_chance,
      "hide cond" : hide_cond
   ]);
}
void init_static_arg( mapping map ) {
   if ( !undefinedp( map[ "max cond" ] ) )
      max_cond = map[ "max cond" ];
   if ( !undefinedp( map[ "damage chance" ] ) )
      damage_chance = map[ "damage chance" ];
   if ( !undefinedp( map[ "hide cond" ] ) )
      hide_cond = map[ "hide cond" ];
}
mapping query_dynamic_auto_load() {
   if ( cond > max_cond ) {
      cond = max_cond;
   }
   if ( lowest_cond > cond ) {
      lowest_cond = cond;
   }
   return ([
      "cond" : cond,
      "lowest cond" : lowest_cond
   ]);
}
void init_dynamic_arg( mapping map, object ) {
   if ( !undefinedp( map[ "cond" ] ) )
      cond = map[ "cond" ];
   if ( !undefinedp( map[ "lowest cond" ] ) )
      lowest_cond = map[ "lowest cond" ];
}

==================================================
FILE: basic/consecrate.c
==================================================

private string _god;
void set_god( string deity ) {
  if ( stringp( deity ) )
    deity = lower_case( deity );
  _god =  deity;
  return;
}
void set_deity( string deity ) {
  if ( stringp( deity ) )
    deity = lower_case( deity );
  _god = deity;
  return;
}
string query_god() { return _god; }
string query_deity() { return _god; }
int query_consecrated( string god ) {
  if ( !stringp( god ) )
    return 0;
  god = lower_case( god );
  if ( _god )
    return god == _god;
  return this_object()->query_property( god );
}
mixed *stats() {
   return
      ({
         ({ "consecrated", _god }),
      });
}
mapping query_static_auto_load() {
   return ([
      "god" : _god
   ]);
}
void init_static_arg( mapping map ) {
   if ( !undefinedp( map[ "god" ] ) )
      _god = map[ "god" ];
}

==================================================
FILE: basic/cute_look.c
==================================================

#include <position.h>
#define NEW_PROCESS_NON_LIVING 1
mixed *process_living( object *int_livings );
string process_non_living( object *int_non_livings, int start );
void set_ignore_livings_in_inventory( int ignore );
int ignore_livings_in_inventory();
private nosave int _ignore_livings = 1;
int env_check(object ob) { return environment(ob) == this_object(); }
int living_check(object ob) { return living(ob); }
mixed there_check(object ob) { return ob->query_property("there"); }
varargs string query_contents( string start, object *things,
  int ignore_living) {
    object *livings = ({ }), *non_livings = ({ });
    mixed *bits;
    string return_string = "";
    int groups;
    if( undefinedp( ignore_living ) )
        ignore_living = ignore_livings_in_inventory();
    if ( stringp( start ) ) return_string = start;
    if ( !arrayp( things ) ) {
        things = this_object()->find_inv_match( "", this_player() );
        things -= ({ this_player() });
        things = filter_array( things, "env_check", this_object());
    }
    if ( !sizeof( things ) )
        return "";
    if (!ignore_living) {
        livings = filter(things, "living_check", this_object());
        non_livings = things - livings;
    } else non_livings = things;
    if ( sizeof( livings ) ) {
        bits = process_living( livings );
        return_string += bits[ 0 ];
        groups = bits[1];
    }
    if ( sizeof( non_livings ) ) {
        return_string += process_non_living( non_livings, groups );
    }
    if(return_string == "")
        return return_string;
    else
        return  return_string = this_player()->colour_event("inventory", "") +
        return_string[0..<2] + "%^RESET%^\n";
}
mixed *process_living( object *int_livings ) {
  int i;
  mapping positions = ([ ]);
  object live_temp;
  string my_pos, int_ret_string = "", *all_positions, current_pos, ministring;
  foreach( live_temp in int_livings ) {
    if ( undefinedp( my_pos = live_temp->query_position_short() ) )
      my_pos = POSITION_DEFAULT;
    if ( undefinedp( positions[ my_pos ] ) )
      positions[ my_pos ] = ({ live_temp });
    else
      positions[ my_pos ] += ({ live_temp });
  }
  all_positions = keys( positions );
  i = 0;
  foreach( current_pos in all_positions ) {
    if(i==0) {
      ministring = "$C$$M$";
    } else {
      ministring = "$M$";
    }
    foreach( live_temp in positions[ current_pos ] ) {
      if ( !live_temp->query_visible( this_player() ) ) {
        continue;
      }
      ministring += live_temp->a_short();
    }
    if (!positions[current_pos][0]->query_position_dont_use_is_are()) {
      if ( sizeof( positions[ current_pos ] ) > 1 ||
           positions[ current_pos ][0]->group_object() ) {
        if ( positions[ current_pos ][0]->query_position_multiple() ) {
          ministring += "$M$ are each " + current_pos;
        } else {
          ministring += "$M$ are " + current_pos;
        }
      } else {
        ministring += "$M$ is " + current_pos;
      }
    } else {
      ministring += "$M$ " + current_pos;
    }
    switch( current_pos ) {
    case SITTING:
    case STANDING:
    case KNEELING:
    case SWIMMING:
    case LYING:
    case MEDITATING:
    case CROUCHING:
      ministring += " here";
    default:
      i++;
      if(i<sizeof(all_positions)-1)
        ministring += ", ";
      else if(i<sizeof(all_positions))
        ministring += " and ";
      else
        ministring += ".\n";
      int_ret_string += ministring;
      continue;
    }
  }
  return ({ int_ret_string, sizeof( all_positions ) }) ;
}
string process_non_living( object *non_livings, int start ) {
  mapping positions;
  string position;
  object *items, item, *bulk;
  string here;
  string *room_items;
  int i;
  if(!sizeof(non_livings))
    return "";
  here = this_object()->query_property( "here" );
  if (!here)
    return query_multiple_short( non_livings ) + ".\n";
  positions = unique_mapping( non_livings, "there_check", this_object());
  if ( positions[ 0 ] ) {
    positions[ here ] = positions[ 0 ];
    map_delete( positions, 0 );
  }
  i = start;
  room_items = ({ });
  foreach( position, items in positions ) {
    bulk = ({ });
    foreach( item in items ) {
      if( ( ( item->query_continuous() || item->query_collective() ) &&
         item->query_how_many() > 1 ) || item->query_are_override() )
      {
        if( item->query_short() == item->query_plural() )
          room_items += ({ item->a_short() + " is " + position });
        else
          room_items += ({ item->a_short() + " are " + position });
      } else {
        bulk += ({ item });
      }
    }
    if ( sizeof( bulk ) ) {
      room_items += ({ "$M$" + implode( bulk->a_short(), "" ) +
                         "$M$ " + "$V$" + i + "=is,are$V$ " + position });
    }
    i++;
  }
  return "$C$" + query_multiple_short( room_items ) + ".\n";
}
void list_contents( string words ) { write( query_contents( words ) ); }
int query_last() {
    log_file( "CUTELAST", "(%s) %s called query_last.\n",
      ctime( time() ), file_name( this_object() ) );
    return 0;
}
void adjust_last( int wibble ) {
    log_file( "CUTELAST", "(%s) %s called adjust_last.\n",
      ctime( time() ), file_name( this_object() ) );
    return;
}
void set_ignore_livings_in_inventory( int ignore ) {
  _ignore_livings = !!ignore;
}
int ignore_livings_in_inventory() { return _ignore_livings; }

==================================================
FILE: basic/desc.c
==================================================

inherit "/std/basic/hide_invis";
nosave mixed short_d;
nosave mixed plural_d;
nosave mixed long_d;
private nosave string short_desc;
void set_short(mixed words) {
  if (functionp(words)) {
    if (!short_d)
      plural_d = (: pluralize(evaluate(short_d)) :);
  } else {
     if ( !short_d && words && ( words != "" ) )
        plural_d = pluralize( words );
  }
   short_d = words;
}
void set_long(mixed str) { long_d = str; }
void set_main_plural(mixed str) { plural_d = str; }
mixed query_main_plural() { return plural_d; }
mixed query_short() {
   if ( functionp( short_d ) )  {
      return evaluate(short_d);
   }
   else return short_d;
}
string query_short_desc() {
  string tmp;
  if(!short_desc) {
    short_desc = "";
    if(this_object()->query_str() > 16)
      short_desc += "strapping ";
    else if(this_object()->query_dex() > 16)
      short_desc += "nimble ";
    else if(this_object()->query_int() > 16)
      short_desc += "studious ";
    else if(this_object()->query_wis() > 16)
      short_desc += "pious ";
    short_desc += "young ";
    switch(this_object()->query_guild_ob()) {
    case "/std/guilds/warrior":
      short_desc += (this_object()->query_gender() == 2? "female " : "male ") +
        "warrior";
      break;
    case "/std/guilds/thief":
      tmp = "/std/guilds/thief"->query_guild_data();
      if(tmp)
        short_desc += (this_object()->query_gender() == 2? "female ": "male ")+
          tmp;
      else
        short_desc += (this_object()->query_gender() == 2? "female ": "male ")+
          "thief";
      break;
    case "/std/guilds/wizard":
      short_desc += (this_object()->query_gender() == 2? "female " : "male ") +
        "wizard";
      break;
    case "/std/guilds/witch":
      short_desc += "witch";
      break;
    case "/std/guilds/assassin":
      short_desc += (this_object()->query_gender() == 2? "female " : "male ") +
        "assassin";
      break;
    default:
      short_desc += (this_object()->query_gender() == 2? "lass" : "lad");
    }
  }
  return short_desc;
}
string query_plural_desc() {
    return pluralize( query_short_desc() );
}
varargs mixed query_long(string str, int dark) {
  if (functionp(long_d))
    return evaluate(long_d);
  return long_d;
}
string query_long_details(string arg, int dark, object looker) {
   return 0;
}
varargs string short(int dark) {
  if (functionp(short_d))
    return (string)evaluate(short_d);
  return short_d;
}
string long(string str, int dark) {
  if (!long_d)
    return "You see nothing particularly interesting.\n";
  if (functionp(long_d))
    return (string)evaluate(long_d);
  return long_d;
}
varargs string query_plural( int dark ) {
  if (!plural_d)
    if (!short( dark ))
      return 0;
    else
      return pluralize(short( dark ));
  if (functionp(plural_d))
    return (string)evaluate(plural_d);
  return plural_d;
}
string query_determinate(object thing) {
  if(query_visible(thing)) {
#ifdef USE_ROLE_PLAYING_SHORTS
    if(interactive(this_object()) &&
      thing->query_role_playing() &&
       !thing->is_friend(this_object()->query_name()))
      return "a ";
#endif
    return (string)this_object()->query_property( "determinate" );
  }
  return "";
}
varargs string pretty_short( object thing ) {
   int dark, verbose;
   if ( objectp( thing ) ) {
      dark = (int)thing->check_dark( (int)this_object()->query_light() );
      if(userp(thing))
        verbose = thing->query_verbose("names");
   }
   return (string)this_object()->short( dark, verbose );
}
varargs string pretty_plural( object thing ) {
   int dark;
   if ( objectp( thing ) )
      dark = (int)thing->check_dark( (int)this_object()->query_light() );
   return (string)this_object()->query_plural( dark );
}
varargs string a_short( int flag ) {
   if ( this_object() == this_player() && !flag )
      this_object()->remove_hide_invis( "hiding" );
   return "$a_short:"+ file_name( this_object() ) +"$";
}
varargs string one_short( int flag ) {
   if ( this_object() == this_player() && !flag )
      this_object()->remove_hide_invis( "hiding" );
   return "$one_short:"+ file_name( this_object() ) +"$";
}
varargs string poss_short( int flag ) {
   if ( this_object() == this_player() && !flag )
      this_object()->remove_hide_invis( "hiding" );
   return "$poss_short:"+ file_name( this_object() ) +"$";
}
varargs string the_poss_short( int flag ) {
   if ( this_object() == this_player() && !flag )
      this_object()->remove_hide_invis( "hiding" );
   return "$the_poss_short:"+ file_name( this_object() ) +"$";
}
varargs string the_short( int flag ) {
   if ( this_object() == this_player() && !flag )
      this_object()->remove_hide_invis( "hiding" );
   return "$the_short:"+ file_name( this_object() ) +"$";
}

==================================================
FILE: basic/effects.c
==================================================

#include <effect.h>
class effect_shadow {
   object shad_ob;
   int idnum;
}
class effect_event {
   int inctime;
   mixed func;
   int eff_ob_num;
   mixed interval;
   int flags;
   mixed eff_ev_args;
}
#undef DEBUG
#ifdef DEBUG
nosave int logging_effects;
void set_logging_effects(int i) { logging_effects = i; }
int query_logging_effects() { return logging_effects; }
#endif
class effect_data {
   int current_enum;
   int next_id;
   int next_event_time;
   class effect_shadow* shadows;
}
void delete_effect(int i);
private nosave class effect_data _data;
private class effect *effs;
private class effect_event *eeq;
protected void create() {
  effs = ({ });
  eeq = ({ });
  _data = new(class effect_data);
  _data->shadows = ({ });
  _data->next_id = 0;
  _data->current_enum = -1;
  _data->next_event_time = 0;
#ifdef DEBUG
  logging_effects = 0;
#endif
}
void reset_effects() {
   effs = ({ });
   eeq = ({ });
   _data->shadows = ({ });
   _data->current_enum = -1;
   _data->next_event_time = 0;
   remove_call_out("effect_timer");
#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) reset_effects:remove_call_out( \"effect_timer\" )\n",
               time() % 1000,
               this_object()->query_name(),
               _data->current_enum);
#endif
}
object affected_object() {
   object this, other;
   other = this_object();
   this = other;
   while (objectp(other)) {
      this = other;
      other = query_shadowing(this);
   }
   return this;
}
void effect_freeze() {
   remove_call_out( "effect_timer" );
#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) effect_freeze:remove_call_out( \"effect_timer\" )=%d\n",
               time() % 1000,this_object()->query_name(),_data->current_enum,timeleft);
#endif
   if ( sizeof( eeq ) && _data->next_event_time) {
      if (_data->next_event_time <= time()) {
         eeq[ 0 ]->inctime = 1;
      } else {
         eeq[ 0 ]->inctime = _data->next_event_time - time();
      }
   }
}
void effects_saving() {
   int i, neffs;
   string effn;
   mixed arg;
   neffs = sizeof( effs );
   for ( i = 0; i < neffs; i++ ) {
      effn = effs[ i ]->ob_name;
      arg = effs[ i ]->arg;
      if ( pointerp( arg ) && ( sizeof( arg ) == 3 ) &&
          ( arg[ 2 ] == BOGUS_OLD_ARG ) ) {
         arg = arg[ 1 ];
      }
      if ( effn ) {
         catch( (void)effn->saving( affected_object(), arg, i ) );
      }
   }
}
void effects_quiting() {
   int i, neffs;
   string effn;
   mixed arg;
   neffs = sizeof( effs );
   for ( i = 0; i < neffs; i++ ) {
      effn = effs[ i ]->ob_name;
      arg = effs[ i ]->arg;
      if ( pointerp( arg ) && ( sizeof( arg ) == 3 ) &&
          ( arg[ 2 ] == BOGUS_OLD_ARG ) ) {
         arg = arg[ 1 ];
      }
      if ( effn ) {
         catch( (void)effn->quiting( affected_object(), arg, i ) );
      }
   }
}
void effects_desting() {
   int i, neffs;
   string effn;
   mixed arg;
   neffs = sizeof( effs );
   for ( i = 0; i < neffs; i++ ) {
      effn = effs[ i ]->ob_name;
      arg = effs[ i ]->arg;
      if ( pointerp( arg ) && ( sizeof( arg ) == 3 ) &&
          ( arg[ 2 ] == BOGUS_OLD_ARG ) ) {
         arg = arg[ 1 ];
      }
      if ( effn ) {
         catch( (void)effn->desting( affected_object(), arg, i ) );
      }
   }
}
void effect_unfreeze() {
   if ( sizeof( eeq ) ) {
#ifdef DEBUG
      if ( logging_effects )
         log_file( "EFFECT_WOBBLE",
                  "%d:%s(%d) effect_unfreeze:call_out( \"effect_timer\", %d)\n",
                  time() % 1000,this_object()->query_name(),_data->current_enum,eeq[ 0 ]->inctime);
#endif
      remove_call_out( "effect_timer" );
      _data->next_event_time = time() + eeq[ 0 ]->inctime;
      call_out( "effect_timer", eeq[ 0 ]->inctime );
   }
}
protected int int_submit_ee( int eff_ob_num, mixed fun, mixed
      interval, int flags, mixed event_args ) {
   int i, ntime;
#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) int_submit_ee:( %d, %O, %O, %s, %O )\n",
               time() % 1000,this_object()->query_name(),_data->current_enum,
               eff_ob_num, fun, interval,
               ({"once","remove","continuous"})[flags], event_args );
#endif
   if (intp(interval))
      ntime = interval;
   else if (pointerp(interval)) {
      switch (sizeof(interval)) {
       case 0:
         return -1;
       case 1:
         ntime = interval[0];
         break;
       case 2:
         ntime = interval[0] + random(interval[1] - interval[0] + 1);
         break;
       case 3:
         ntime = 0;
         for (i = 0; i < interval[2]; i++) {
            ntime += interval[0] + random(interval[1] - interval[0] + 1);
         }
         ntime += (interval[2]/2);
         ntime /= interval[2];
         break;
       default:
         return -1;
      }
   } else return -1;
   if (flags == EE_REMOVE) {
      for(i = 0; i < sizeof(eeq); i++) {
         if ((eeq[i]->eff_ob_num == eff_ob_num) &&
             (eeq[i]->flags == EE_REMOVE)) {
            eeq = eeq[0..i-1] + eeq[i+1..];
            break;
         }
      }
   }
   if ( ntime < 0 ) {
      return 0;
   }
   for (i = 0; i < sizeof(eeq); i++) {
      if (ntime < eeq[i]->inctime) {
         eeq[i]->inctime -= ntime;
         eeq = eeq[0..i-1] +
            ({ new(class effect_event, inctime : ntime, func : fun,
                   eff_ob_num : eff_ob_num, interval : interval,
                   flags : flags, eff_ev_args : event_args ) }) + eeq[i..];
         break;
      }
      ntime -= eeq[i]->inctime;
   }
   if ((i == sizeof(eeq)) && eeq) {
      eeq += ({ new(class effect_event, inctime : ntime, func : fun,
                    eff_ob_num : eff_ob_num, interval : interval,
                    flags : flags, eff_ev_args : event_args ) });
   } else if ( !sizeof(eeq) ) {
      eeq = ({ new(class effect_event, inctime : ntime, func : fun,
                   eff_ob_num : eff_ob_num, interval : interval,
                   flags : flags, eff_ev_args : event_args ) });
   }
   return i;
}
varargs void submit_ee(mixed fun, mixed interval, int flags, mixed
    event_args ) {
  int enumb;
  if( undefinedp( event_args ) )
     event_args = 0;
#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) submit_ee:( %O, %O, %s, %O )\n",
               time() % 1000,this_object()->query_name(),_data->current_enum,
               fun, interval, ({"once","remove","continuous"})[flags],
               event_args );
#endif
  enumb = _data->current_enum;
  if (enumb < 0) {
    enumb = member_array(1,
        map(_data->shadows, (: $1 && (((class effect_shadow)$1)->shad_ob == previous_object()) :)));
    if (enumb < 0) {
      error("Can not submit from that object");
    }
  }
  effect_freeze();
  int_submit_ee(enumb, fun, interval, flags, event_args );
  effect_unfreeze();
}
varargs void submit_ee2(int enum, mixed fun, mixed interval, int flags,
    mixed event_args ) {
  if( undefinedp( event_args ) )
    event_args = 0;
#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) int_submit_ee:( %d, %O, %O, %s, %O )\n",
               time() % 1000,this_object()->query_name(),_data->current_enum,
               enum, fun, interval, ({"once","remove","continuous"})[flags],
               event_args );
#endif
  if (enum < 0)
    error("Can't submit from that object");
  effect_freeze();
  int_submit_ee(enum, fun, interval, flags, event_args );
  effect_unfreeze();
}
int expected_tt(int flag, int new_enum) {
  int i, timeleft, enum;
  if (flag)
    enum = new_enum;
  else
    enum = _data->current_enum;
  if (enum < 0)
    return -1;
  if (!sizeof(eeq))
    return -1;
  effect_freeze();
  for (i = 0; i < sizeof(eeq); i++) {
    timeleft += eeq[i]->inctime;
    if ((eeq[i]->eff_ob_num == enum) &&
        (eeq[i]->flags == EE_REMOVE)) {
      effect_unfreeze();
      return timeleft;
    }
  }
  effect_unfreeze();
  return -1;
}
varargs int expected_ee( string func_name, int enum ) {
  int timeleft = 0;
  if( undefinedp( enum ) ) {
    enum = _data->current_enum;
  }
  if( !enum ) {
    return -1;
  }
  if( !stringp( func_name ) ) {
    return -1;
  }
  if( !sizeof( eeq ) ) {
    return -1;
  }
  effect_freeze();
  for( int i = 0; i < sizeof( eeq ); i++) {
    timeleft += eeq[i]->inctime;
    if( eeq[i]->eff_ob_num == enum &&
        eeq[i]->func == func_name ) {
      effect_unfreeze();
      return timeleft;
    }
  }
  effect_unfreeze();
  return -1;
}
varargs int *all_expected_ees( string func_name, int *enums ) {
  int timeleft = 0;
  int *alltimesleft = ({});
  if( undefinedp( enums ) ) {
    enums = ({ _data->current_enum });
  }
  if( intp( enums ) ) {
    enums = ({ enums });
  }
  if( !enums ) {
    return ({});
  }
  if( !stringp( func_name ) ) {
    return ({});
  }
  if( !sizeof( eeq ) ) {
    return ({});
  }
  effect_freeze();
  for( int i = 0; i < sizeof( eeq ); i++) {
    timeleft += eeq[i]->inctime;
    if( member_array( eeq[i]->eff_ob_num , enums ) != -1 &&
        eeq[i]->func == func_name ) {
      alltimesleft += ({ timeleft });
    }
  }
  effect_unfreeze();
  return alltimesleft;
}
void add_effect(string eff, mixed arg) {
  string shad;
  object ob, effob;
  mixed hbf, res;
  int i;
  int old_current_enum;
  int enum;
#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) add_effect:(%s,%O)\n",
               time() % 1000,this_object()->query_name(),current_enum,eff,arg);
#endif
  hbf = (mixed)eff->query_secs_between_hb();
  if (!hbf) {
    hbf = (mixed) eff->query_heart_beat_frequency();
    if (hbf) {
      if (intp(hbf)) hbf *= 60;
    }
  }
  old_current_enum = _data->current_enum;
  effob = find_object(eff);
  if (!effob)
    error("bad effect object");
  for (i=0; i<sizeof(effs); i++) {
    if (effs[i]->ob_name == eff) {
      if (function_exists("merge_effect", effob)) {
        _data->current_enum = i;
        if (hbf) {
          res = (mixed) effob->merge_effect(affected_object(),
                                            effs[i]->arg[1], arg);
          if (res)
            effs[i]->arg[1] = res;
        } else {
          res = (mixed) effob->merge_effect(affected_object(),
                                            effs[i]->arg, arg);
          if (res)
            effs[i]->arg = res;
        }
        _data->current_enum = old_current_enum;
        return ;
      }
    }
  }
  shad = effob->query_shadow_ob();
  if (shad) {
    ob = clone_object(shad);
    if(!ob) {
      error("Failed to clone shadow object " + shad + ".\n");
      _data->shadows += ({ new(class effect_shadow, shad_ob : 0, idnum : _data->next_id) });
    } else {
      _data->shadows += ({ new(class effect_shadow, shad_ob : ob, idnum : _data->next_id) });
      ob->attach_to_player(affected_object(), _data->next_id);
    }
  } else {
    _data->shadows += ({ new(class effect_shadow, shad_ob : 0, idnum : _data->next_id) });
  }
  _data->current_enum = sizeof(effs);
  enum = _data->current_enum;
  if(!effs)
    effs = ({ });
  effs += ({ new(class effect, ob_name : eff, arg : arg) });
  if (function_exists("beginning", effob)) {
    res = (mixed) effob->beginning(affected_object(), arg, _data->next_id);
    if (res) {
      effs[enum]->arg = res;
    }
  }
  _data->next_id++;
  if (hbf) {
    submit_ee("effect_heart_beat", hbf, EE_CONTINUOUS | EE_OLD);
    effs[enum]->arg = ({ 0, effs[<1]->arg, BOGUS_OLD_ARG });
  }
  _data->current_enum = old_current_enum;
}
#define EFF_OB_NAME 0
#define EFF_ARG 1
#define EEQ_INCTIME 0
#define EEQ_FUNC 1
#define EEQ_EFF_OB 2
#define EEQ_INTERVAL 3
#define EEQ_FLAGS 4
#define EEQ_ARGS 5
#define EFF_SIZE 2
#define EEQ_SIZE 5
protected void convert_arrays() {
  int i, neffs, neeq;
  mixed *old;
  if (sizeof(effs) && !classp(effs[0])) {
    old = effs;
    neffs = sizeof(old) / EFF_SIZE;
    effs = allocate(neffs);
    for (i = 0; i < neffs; i++)
      effs[i] = new(class effect,
                    ob_name : old[i*EFF_SIZE+EFF_OB_NAME],
                    arg : old[i*EFF_SIZE+EFF_ARG]);
  }
  if (sizeof(eeq) && !classp(eeq[0])) {
    old = eeq;
    neeq = sizeof(eeq) / EEQ_SIZE;
    eeq = allocate(neeq);
    for (i = 0; i < neeq; i++)
      eeq[i] = new(class effect_event,
                   inctime : old[ i * EEQ_SIZE + EEQ_INCTIME ],
                   func : old[ i * EEQ_SIZE + EEQ_FUNC ],
                   eff_ob_num : old[ i * EEQ_SIZE + EEQ_EFF_OB ],
                   interval : old[ i * EEQ_SIZE + EEQ_INTERVAL ],
                   flags : old[ i * EEQ_SIZE + EEQ_FLAGS ],
                   eff_ev_args : old[ i * EEQ_SIZE + EEQ_ARGS ] );
  }
}
void init_after_save() {
  int i;
  int neffs;
  string shad;
  string effn;
  object ob;
  mixed arg;
  int *ee_exists;
  convert_arrays();
  for( i = 0; i < sizeof( eeq ); i++ ) {
    if( classp( eeq[i] ) && sizeof( eeq[i] ) < 6 ) {
      eeq[i] = new( class effect_event,
                    inctime : eeq[i]->inctime ,
                    func : eeq[i]->func ,
                    eff_ob_num : eeq[i]->eff_ob_num ,
                    interval : eeq[i]->interval ,
                    flags : eeq[i]->flags ,
                    eff_ev_args : 0 );
    }
  }
  neffs = sizeof(effs);
  _data->shadows = allocate(neffs);
  for (i = 0; i < neffs; i++) {
    effn = effs[i]->ob_name;
    _data->shadows[i] = new(class effect_shadow, idnum : _data->next_id);
    if (catch(shad = (string)
              effn->query_shadow_ob())) {
      continue;
    }
    if (shad) {
      ob = clone_object(shad);
      _data->shadows[i]->shad_ob = ob;
      ob->attach_to_player(affected_object(), _data->next_id);
    }
    _data->current_enum = i;
    arg = effs[i]->arg;
    if (pointerp(arg) && sizeof(arg) == 3 && arg[2] == BOGUS_OLD_ARG) {
      arg = arg[1];
    }
    catch(effn->restart(affected_object(), arg, _data->next_id++));
  }
  ee_exists = allocate(sizeof(effs));
  for (i = 0; i < sizeof(eeq); i++) {
    ee_exists[eeq[i]->eff_ob_num] = 1;
  }
  for (i = sizeof(ee_exists) - 1; i >= 0; i--) {
    if (catch(ob = load_object(effs[i]->ob_name)) || !ob) {
      delete_effect(i);
      continue;
    }
    if (!ee_exists[i] && !ob->query_indefinite()) {
      delete_effect(i);
    }
  }
  _data->current_enum = -1;
  effect_unfreeze();
}
int *effects_matching(string eff) {
  int i, neffs;
  int *match;
  string clas;
  object ob;
  match = ({ });
  neffs = sizeof(effs);
  for (i = 0; i < neffs; i++) {
    if (catch(ob = load_object(effs[i]->ob_name)) || !ob) {
      continue;
    }
    clas = (string)ob->query_classification();
    if (!stringp(clas)) {
      continue;
    }
    if (clas[0..strlen(eff)-1] == eff) {
      match += ({ i });
    }
  }
  return match;
}
void delete_effect(int i) {
   int id, j;
   object effect_object, shadow_object;
   string effect_file;
   mixed arg;
#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) delete_effect:(%d) sizeof(eeq)=%d\n",time() % 1000,
               this_object()->query_name(),current_enum,i, sizeof(eeq));
#endif
   if ((i < 0) || (i >= sizeof( effs ))) {
      return;
   }
   id = _data->shadows[i]->idnum;
   arg = effs[i]->arg;
   effect_freeze();
   for (j = 0; j < sizeof(eeq); j++) {
      if (eeq[j]->eff_ob_num == i) {
         if (sizeof(eeq)-1 > j)
            eeq[j+1]->inctime += eeq[j]->inctime;
         eeq = delete(eeq, j--, 1);
      } else {
         if (eeq[j]->eff_ob_num > i)
            eeq[j]->eff_ob_num--;
      }
   }
   effect_file = effs[i]->ob_name;
   effs = delete(effs, i, 1);
   shadow_object = _data->shadows[i]->shad_ob;
   _data->shadows = delete(_data->shadows, i, 1);
   effect_unfreeze();
#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) delete_effect: before end\n",time() % 1000,
               this_object()->query_name(),current_enum);
#endif
   effect_object = find_object(effect_file);
   if (!effect_object)
      catch(effect_object = load_object(effect_file));
   if (effect_object)
      if (pointerp(arg) && (sizeof(arg) == 3) &&
          (arg[2] == BOGUS_OLD_ARG))
         effect_object->end(affected_object(), arg[1], id);
   else
      effect_object->end(affected_object(), arg, id);
#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) delete_effect: after end\n",time() % 1000,
               this_object()->query_name(),_data->current_enum);
#endif
   if (objectp(shadow_object))
      shadow_object->remove_effect_shadow(id);
}
int sid_to_enum(int sid) {
   return member_array(1,
      map(_data->shadows, (: classp($1) &&
                      ((class effect_shadow)$1)->idnum == $(sid) :)));
}
int enum_to_sid(int enum) {
  return _data->shadows[enum]->idnum;
}
string eff_of(int enum) {
  return effs[enum]->ob_name;
}
mixed arg_of(int enum) {
  mixed arg;
  if (sizeof(effs) <= enum)
    return 0;
  arg = effs[enum]->arg;
  if (arrayp(arg) && sizeof(arg) == 3)
    if (arg[2] == BOGUS_OLD_ARG)
      return copy(arg[1]);
  return copy(arg);
}
void set_arg_of(int enum, mixed newarg) {
  effs[enum]->arg = newarg;
}
class effect *query_effs() { return effs; }
class effect_shadow *query_effect_shadows() { return _data->shadows; }
class effect_event *query_eeq() { return eeq; }
void effect_timer() {
   int enum;
   object effect_object;
   mixed res, last_flags;
   class effect_event thisee;
#ifdef DEBUG
   if ( logging_effects )
      log_file( "EFFECT_WOBBLE",
               "%d:%s(%d) effect_timer:() sizeof(eeq)=%d\n",time() % 1000,
               this_object()->query_name(),current_enum,sizeof(eeq));
#endif
   _data->next_event_time = 0;
   if (!sizeof(eeq)) {
      return;
   }
   thisee = eeq[0];
   eeq = eeq[1..];
   enum = _data->current_enum = thisee->eff_ob_num;
   if (enum >= sizeof(effs)) {
      effect_unfreeze();
      if (this_object()->query_creator()) {
         tell_object(this_object(), "Effect number out of range, "
                     "ignoring.\n");
      }
      return;
   }
   if (thisee->flags & EE_CANCELLED) {
      effect_unfreeze();
      return;
   }
   if (thisee->flags & EE_CONTINUOUS) {
      last_flags = int_submit_ee(enum, thisee->func, thisee->interval,
                                 thisee->flags, thisee->eff_ev_args );
   }
   effect_unfreeze();
   effect_object = find_object(effs[enum]->ob_name);
   if (!effect_object) {
      catch {
         effect_object = load_object(effs[enum]->ob_name);
      };
   }
   if (!effect_object) {
      if (this_object()->query_creator() ) {
         tell_object( this_object(), "Non-existent effect "+
                     effs[enum]->ob_name +", deleting.\n" );
      }
      delete_effect(enum);
      _data->current_enum = -1;
      return;
   }
   if (thisee->flags & EE_OLD) {
      res = (mixed)effect_object->
         effect_heart_beat(this_object(), ++effs[enum]->arg[0],
                           effs[enum]->arg[1], _data->shadows[enum]->idnum);
      if (res == REMOVE_THIS_EFFECT) {
         delete_effect(enum);
      } else {
         effs[enum]->arg[1] = res;
      }
   } else {
      if (stringp(thisee->func)) {
         res = call_other(effect_object, thisee->func, affected_object(),
                          effs[enum]->arg, _data->shadows[enum]->idnum, enum,
                          thisee->eff_ev_args );
         if (res == REMOVE_THIS_EFFECT) {
            delete_effect(enum);
         } else {
            if (res == CANCEL_THIS_EE) {
               eeq[last_flags]->flags |= EE_CANCELLED;
            }
         }
      } else if (functionp(thisee->func)) {
         res = evaluate(thisee->func, affected_object(), effs[enum]->arg,
                     _data->shadows[enum]->idnum, enum, thisee->eff_ev_args );
         if (res == REMOVE_THIS_EFFECT) {
            delete_effect(enum);
         } else if (res == CANCEL_THIS_EE) {
               eeq[last_flags]->flags |= EE_CANCELLED;
         }
      }
   }
   if (thisee->flags & EE_REMOVE)
      delete_effect(enum);
   _data->current_enum = -1;
}
mixed *stats() {
   mixed *sr;
   int i;
   object ob;
   sr = ({ });
   for (i = 0; i < sizeof(effs); i++) {
      if (catch(ob = load_object(effs[i]->ob_name)) || !ob) {
         sr += ({ ({ "effect#" + i, " (buggered)" }) });
         continue;
      }
      if (intp(effs[i]->arg) || stringp(effs[i]->arg)) {
         sr += ({ ({ "effect#" + i,
                       effs[i]->ob_name->query_classification() +
                       " (" + effs[i]->ob_name + ") (" +
                       effs[i]->arg + ")" }) });
      } else {
         sr += ({ ({ "effect#"+i, effs[i]->ob_name->query_classification() +
               " (complex)" }) });
      }
   }
   return sr;
}
void effects_thru_death() {
   int i;
   int id;
   object ob;
   i = sizeof( effs );
   while ( i-- ) {
      id = _data->shadows[i]->idnum;
      if ( catch( ob = load_object(effs[i]->ob_name)) || !ob ||
          !ob->survive_death( affected_object(), effs[i]->arg, id) ) {
         delete_effect(i);
      }
   }
}
int query_current_effect_enum() {
   return _data->current_enum;
}
protected void set_effs( mixed *args ) {
  int i, neffs;
  if ( sizeof( args ) && !classp( args[ 0 ] ) ) {
    neffs = sizeof( args ) / EFF_SIZE;
    effs = allocate( neffs );
    for (i = 0; i < neffs; i++) {
      effs[ i ] = new( class effect,
                       ob_name : args[ i * EFF_SIZE + EFF_OB_NAME ],
                       arg : args[ i * EFF_SIZE + EFF_ARG ] );
    }
  } else {
    effs = args;
  }
}
protected void set_eeq( mixed *args ) {
  int i, neeq;
  if ( sizeof( args ) && !classp( args[ 0 ] ) ) {
    neeq = sizeof( args ) / EEQ_SIZE;
    eeq = allocate( neeq );
    for (i = 0; i < neeq; i++) {
      eeq[ i ] = new( class effect_event,
                      inctime : args[ i * EEQ_SIZE + EEQ_INCTIME ],
                      func : args[ i * EEQ_SIZE + EEQ_FUNC ],
                      eff_ob_num : args[ i * EEQ_SIZE + EEQ_EFF_OB ],
                      interval : args[ i * EEQ_SIZE + EEQ_INTERVAL ],
                      flags : args[ i * EEQ_SIZE + EEQ_FLAGS ],
                      eff_ev_args : args[ i * EEQ_SIZE + EEQ_ARGS ] );
    }
  } else {
    eeq = args;
  }
}

==================================================
FILE: basic/enchant.c
==================================================

nosave private int _enchanted;
nosave private int _set_enchant_time;
nosave private int _degrade_enchant;
#define ENCHANT_DEGRADE_TIME (8 * 7 * 24 * 60 * 60)
int query_max_enchant()
{
   return 5 + (int) this_object()->query_weight() / 4;
}
int query_degrade_enchant() {
   if (!_degrade_enchant) {
      return this_object()->query_max_enchant() / 2;
   }
   return _degrade_enchant;
}
void set_degrade_enchant(int enchant) {
   if (enchant > this_object()->query_max_enchant()) {
      enchant = this_object()->query_max_enchant();
   }
   _degrade_enchant = enchant;
}
string enchant_string()
{
   string tal_msg;
   string ench_msg;
   if (this_object()->query_property("talisman")) {
      tal_msg = (string) this_object()->query_property("talisman_mess");
      if (!tal_msg)
         tal_msg = "It has the hazy octarine sparkle of a magical talisman.";
      tal_msg += "\n";
   } else {
      tal_msg = "";
   }
   if (this_object()->query_property("octarine_mess")) {
      ench_msg = (string) this_object()->query_property("octarine_mess")
         + "\n";
   } else {
      switch ((this_object()->query_enchant() * 100) /
              this_object()->query_max_enchant()) {
      case 1..10:
         ench_msg = "It occasionally pulses with octarine light.\n";
         break;
      case 11..20:
         ench_msg = "It emits a slight octarine glow.\n";
         break;
      case 21..30:
         ench_msg = "It softly pulses in dull octarine shades.\n";
         break;
      case 31..40:
         ench_msg = "It gives off a steady but dull octarine glow.\n";
         break;
      case 41..50:
         ench_msg = "It gives off a steady octarine glow.\n";
         break;
      case 51..60:
         ench_msg = "It glows an intense octarine.\n";
         break;
      case 61..70:
         ench_msg = "It emits a bright octarine colour.\n";
         break;
      case 71..80:
         ench_msg = "It brightly pulses octarine.\n";
         break;
      case 81..90:
         ench_msg = "It glows brilliant octarine shades.\n";
         break;
      case 91..100:
         ench_msg = "It radiates pure octarine brilliance.\n";
         break;
      default:
         ench_msg = "";
      }
   }
   return ench_msg + tal_msg;
}
void set_enchant(int number)
{
   if (number > this_object()->query_max_enchant()) {
      number = this_object()->query_max_enchant();
   }
   _set_enchant_time = time();
   _enchanted = number;
}
int add_enchant(int number)
{
   set_enchant(this_object()->query_enchant() + number);
   return _enchanted;
}
int query_enchant()
{
   int max;
   int tmp;
   int tmp2;
   int degrade;
   max = this_object()->query_max_enchant();
   if (_enchanted > max) {
      _enchanted = max;
   }
   degrade = this_object()->query_degrade_enchant();
   if (_enchanted > degrade) {
      if (!_set_enchant_time) {
         _set_enchant_time = time();
      }
      if (time() - _set_enchant_time >= ENCHANT_DEGRADE_TIME) {
         _enchanted = degrade;
      } else {
         tmp2 = tmp = (_enchanted - degrade) * 100 + 99;
         tmp *= 100 - (((time() - _set_enchant_time) * 100) /
                       ENCHANT_DEGRADE_TIME);
         return degrade + (tmp / 10000);
      }
   }
   return _enchanted;
}
int query_real_enchant()
{
   return _enchanted;
}
int query_enchant_set_time()
{
   return _set_enchant_time;
}
protected void set_enchant_set_time(int tim)
{
   _set_enchant_time = tim;
}

==================================================
FILE: basic/export_inventory.c
==================================================

nosave object *registered_containers;
nosave int can_export_inventory;
void create() {
   registered_containers = ({ });
}
void add_inventory_container(object cont) {
   if (member_array(cont, registered_containers) == -1 &&
       environment(cont) == this_object()) {
      registered_containers += ({ cont });
   }
}
void remove_inventory_container(object cont) {
  if(!registered_containers || !cont)
    return;
  registered_containers -= ({ cont });
}
void set_can_export_inventory() {
   can_export_inventory = 1;
}
void reset_can_export_inventory() {
   can_export_inventory = 0;
}
int query_can_export_inventory() {
   return can_export_inventory;
}
protected object *find_expanded_inv_match( string words, object looker,
                                           object *things) {
   object *stuff;
   object bing;
   stuff = ({ });
   if (can_export_inventory) {
      foreach (bing in registered_containers) {
         if (member_array(bing, things) != -1) {
            stuff += bing->find_inv_match(words, looker);
         }
      }
   }
   return stuff;
}

==================================================
FILE: basic/expressions.c
==================================================

#include <money.h>
#include <expressions.h>
#define EXPRESSION_AND       -1
#define EXPRESSION_OR        -2
#define EXPRESSION_NOT       -3
#define EXPRESSION_FALSE     -4
#define EXPRESSION_TRUE      -5
#define EXPRESSION_GREATOR_THAN     -6
#define EXPRESSION_LESS_THAN        -7
#define EXPRESSION_EQUAL_TO         -8
#define EXPRESSION_GREATOR_OR_EQUAL -9
#define EXPRESSION_LESS_OR_EQUAL    -10
#define EXPRESSION_PLUS             -11
#define EXPRESSION_MINUS            -12
#define EXPRESSION_MULTIPLY         -13
#define EXPRESSION_DIVIDE           -14
#define EXPRESSION_IF               -15
#define EXPRESSION_NOT_EQUAL_TO     -16
#define EXPRESSION_ARRAY_DEREFERENCE -17
#define EXPRESSION_ARRAY_AGGREGATE   -18
#define EXPRESSION_AND_NEW          -19
#define EXPRESSION_OR_NEW           -20
#define EXPRESSION_IF_NEW           -21
#define EXPRESSION_TREE         0
#define EXPRESSION_PARSE_STRING 1
#define EXPRESSION_TYPE         2
#define EXPRESSION_FUNC_NAME    0
#define EXPRESSION_FUNC_NO_ARGS 1
#define EXPRESSION_FUNC_VAR_NAME 0
#define EXPRESSION_FUNC_VAR_POS  1
class variable_thing {
   int type;
   function value;
}
class func_variable_thing {
   int type;
   int arg_no;
}
class function_thing {
   int type;
   function value;
   int* args;
   int return_pos;
}
class user_function_thing {
   int type;
   class parse_node* expr;
   int* arg_types;
   string* arg_names;
}
private mixed* parse_operator(string str, string token);
string query_expression_string(class parse_node* expr, int brief);
class parse_node evaluate_expression(class parse_node* expr, mixed args ...);
void add_allowed_function(string name, int type, int* args, function value);
mixed query_property(string name);
protected int is_array_type(int type);
int sizeof_function(mixed args ...);
int filter_function(mixed args ...);
private mapping _user_functions;
private nosave mapping _func_variables;
private nosave mapping _variables;
private nosave mapping _functions;
private nosave string _error_string;
private nosave string _warning_string;
void create() {
   _variables = ([ ]);
   _functions = ([ ]);
   if (!_user_functions) {
      _user_functions = ([ ]);
   }
   _func_variables = ([ ]);
   _error_string = "no error";
   add_allowed_function("sizeof", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_ARRAY }), (: sizeof_function :) );
}
string query_last_expression_error() {
   return _error_string;
}
string query_last_expression_warning() {
   return _warning_string;
}
void add_allowed_variable(string name, int type, function value) {
   class variable_thing bing;
   bing = new(class variable_thing);
   bing->type = type;
   bing->value = value;
   _variables[name] = bing;
}
void add_allowed_function(string name, int type, int* args, function value) {
   class function_thing bing;
   bing = new(class function_thing);
   bing->type = type;
   bing->args = args;
   bing->value = value;
   _functions[name] = bing;
}
int query_function_variable_type(string name) {
   if (_func_variables[name]) {
      return ((class func_variable_thing)_func_variables[name])->type;
   }
   return EXPRESSION_TYPE_ERROR;
}
int query_function_variable_position(string name) {
   if (_func_variables[name]) {
      return ((class func_variable_thing)_func_variables[name])->arg_no;
   }
   return EXPRESSION_TYPE_ERROR;
}
string *query_variable_names() {
   return keys(_variables);
}
int query_variable_type(string name) {
   if (_variables[name]) {
      return ((class variable_thing)_variables[name])->type;
   }
   return EXPRESSION_TYPE_ERROR;
}
function query_variable_value(string name) {
   if (_variables[name]) {
      return ((class variable_thing)_variables[name])->value;
   }
   return 0;
}
string* query_function_names() {
   return keys(_functions);
}
int* query_function_args_types(string name) {
   if (_functions[name]) {
      return ((class function_thing)_functions[name])->args;
   }
   return ({ });
}
int query_function_type(string name) {
   if (_functions[name]) {
      return ((class function_thing)_functions[name])->type;
   }
   return EXPRESSION_TYPE_ERROR;
}
function query_function_value(string name) {
   if (_functions[name]) {
      return ((class function_thing)_functions[name])->value;
   }
   return 0;
}
string* query_user_function_names() {
   return keys(_user_functions);
}
mixed* query_user_function_arg_types(string name) {
   if (_user_functions[name]) {
      return _user_functions[name]->arg_types;
   }
   return 0;
}
mixed* query_user_function_arg_names(string name) {
   if (_user_functions[name]) {
      return _user_functions[name]->arg_names;
   }
   return 0;
}
mixed* query_user_function_args(string name) {
   if (_user_functions[name]) {
      return ({ _user_functions[name]->arg_names,
                _user_functions[name]->arg_types });
   }
   return 0;
}
int query_user_function_return_type(string name) {
   if (_user_functions[name]) {
      return ((class user_function_thing)_user_functions[name])->type;
   }
   return EXPRESSION_TYPE_ERROR;
}
class parse_node* query_user_function_expression(string name) {
   if (_user_functions[name]) {
      return _user_functions[name]->expr;
   }
   return 0;
}
int remove_user_expression(string name) {
   if (_user_functions[name]) {
      map_delete(_user_functions, name);
      return 1;
   }
   return 0;
}
int query_type_value(string type) {
   switch (lower_case(type)) {
   case "integer" :
   case "int"     :
      return EXPRESSION_TYPE_INTEGER;
   case "string"  :
      return EXPRESSION_TYPE_STRING;
   case "float"   :
      return EXPRESSION_TYPE_FLOAT;
   case "boolean" :
   case "bool"    :
      return EXPRESSION_TYPE_BOOLEAN;
   case "money" :
      return EXPRESSION_TYPE_MONEY;
   case "object" :
      return EXPRESSION_TYPE_OBJECT;
   case "array" :
      return EXPRESSION_TYPE_ARRAY;
   default :
      return EXPRESSION_TYPE_ERROR;
   }
}
string query_type_name(int type) {
   if (is_array_type(type)) {
      return "array " + query_type_name(type - EXPRESSION_TYPE_ARRAY_OFFSET);
   }
   switch (type) {
   case EXPRESSION_TYPE_INTEGER  :
      return "integer";
   case EXPRESSION_TYPE_STRING   :
      return "string";
   case EXPRESSION_TYPE_ARRAY    :
      return "array";
   case EXPRESSION_TYPE_ARRAY_NULL :
      return "array null";
   case EXPRESSION_TYPE_MAPPING  :
      return "mapping";
   case EXPRESSION_TYPE_FLOAT    :
      return "float";
   case EXPRESSION_TYPE_BOOLEAN  :
      return "boolean";
   case EXPRESSION_TYPE_MONEY  :
      return "money";
   case EXPRESSION_TYPE_OBJECT :
      return "object";
   default :
      return "error";
   }
}
string query_operator_name(int operator) {
   switch (operator) {
   case EXPRESSION_AND_NEW   :
   case EXPRESSION_AND       :
      return "and";
   case EXPRESSION_OR_NEW    :
   case EXPRESSION_OR        :
      return "or";
   case EXPRESSION_NOT       :
      return "not";
   case EXPRESSION_FALSE     :
      return "false";
   case EXPRESSION_TRUE      :
      return "true";
   case EXPRESSION_GREATOR_THAN     :
      return ">";
   case EXPRESSION_LESS_THAN        :
      return "<";
   case EXPRESSION_EQUAL_TO         :
      return "=";
   case EXPRESSION_NOT_EQUAL_TO         :
      return "<>";
   case EXPRESSION_GREATOR_OR_EQUAL :
      return ">=";
   case EXPRESSION_LESS_OR_EQUAL    :
      return "<=";
   case EXPRESSION_PLUS             :
      return "+";
   case EXPRESSION_MINUS            :
      return "-";
   case EXPRESSION_MULTIPLY         :
      return "*";
   case EXPRESSION_DIVIDE           :
      return "/";
   case EXPRESSION_IF               :
      return "if";
   default :
      return "unknown";
   }
}
private class parse_node make_node(int type, mixed value, int* tree) {
   class parse_node bing;
   bing = new(class parse_node);
   bing->type = type;
   bing->value = value;
   bing->tree = tree;
   return bing;
}
class parse_node query_null_type(int type) {
   if (is_array_type(type)) {
      return make_node(type, ({ }), ({ }));
   }
   switch (type) {
   case EXPRESSION_TYPE_INTEGER  :
      return make_node(type, 0, ({ }));
   case EXPRESSION_TYPE_MONEY  :
      return make_node(type, 0, ({ }));
   case EXPRESSION_TYPE_STRING   :
      return make_node(type, "", ({ }));
   case EXPRESSION_TYPE_ARRAY    :
   case EXPRESSION_TYPE_ARRAY_NULL  :
      return make_node(type, ({ }), ({ }));
   case EXPRESSION_TYPE_MAPPING  :
      return make_node(type, ([ ]), ({ }));
   case EXPRESSION_TYPE_FLOAT    :
      return make_node(type, 0.0, ({ }));
   case EXPRESSION_TYPE_BOOLEAN  :
      return make_node(EXPRESSION_TYPE_OPERATOR, EXPRESSION_FALSE, ({ }));
   case EXPRESSION_TYPE_OBJECT :
      return make_node(type, 0, ({ }));
   default :
      return 0;
   }
}
protected int is_alpha(int alpha) {
   if ((alpha >= 'a' && alpha <= 'z') ||
       (alpha >= 'A' && alpha <= 'Z')) {
      return 1;
   }
   return 0;
}
protected int is_number(int number) {
   if (number >= '0' && number <= '9') {
      return 1;
   }
   return 0;
}
protected int is_space(int space) {
   if (space == ' ' || space == '\t') {
      return 1;
   }
   return 0;
}
protected int is_number_type(int type) {
   return type == EXPRESSION_TYPE_INTEGER ||
          type == EXPRESSION_TYPE_FLOAT ||
          type == EXPRESSION_TYPE_MONEY;
}
protected int is_array_type(int type) {
   return type == EXPRESSION_TYPE_ARRAY ||
          type == EXPRESSION_TYPE_ARRAY_NULL ||
          type >= EXPRESSION_TYPE_ARRAY_OFFSET;
}
protected int is_null_array_type(int type) {
   return type == EXPRESSION_TYPE_ARRAY_NULL;
}
private int is_valid_variable_name(int type) {
   return type == '_' ||
          is_alpha(type) ||
          is_number(type);
}
protected string* query_token(string str) {
   int i = 0;
   int j;
   while (strlen(str) > 1 && is_space(str[0])) {
      str = str[1..];
   }
   if (!strlen(str)) {
      return ({ "", str });
   }
   if (str[0] == '$') {
      i = 1;
      while (strlen(str) > i &&
             (str[i] != '$')) {
         i++;
      }
      return ({ str[0..i], str[i+1..] });
   }
   if (str[0] == '-' || is_number(str[0])) {
      i = 0;
      while (strlen(str) > i + 1 &&
             is_number(str[i + 1])) {
         i++;
      }
      return ({ str[0..i], str[i+1..] });
   }
   if (is_alpha(str[0]) || str[0] == '_') {
      while (strlen(str) > i + 1 &&
             is_valid_variable_name(str[i + 1])) {
         i++;
      }
      return ({ str[0..i], str[i+1..] });
   }
   if (str[0] == '"') {
      do {
         j = strsrch(str[i + 1..], "\"");
         if (j == -1) {
            _error_string = "Missing close \"\n";
            return 0;
         }
         i += j + 1;
      } while (str[i - 1] == '\\');
      return ({ str[0..i], str[i+1..] });
   }
   if (str[0] == '\'') {
      do {
         j = strsrch(str[i + 1..], "'");
         if (j == -1) {
            _error_string = "Missing close '\n";
            return 0;
         }
         i += j + 1;
      } while (str[i - 1] == '\\');
      return ({ str[0..i], str[i+1..] });
   }
   if (str[0] == '>' ||
       str[0] == '<') {
      if (strlen(str) > 1 &&
          str[1] == '=') {
         return ({ str[0..1], str[2..] });
      }
      return ({ str[0..0], str[1..] });
   }
   while (strlen(str) > i + 1 &&
          !is_alpha(str[i + 1]) &&
          !is_number(str[i + 1]) &&
          !is_space(str[i + 1]) &&
          member_array(str[i + 1], ({ '>', '<', '=', '!', '-', '$', '\'',
                                      '"', '_', '(', ')', '{', '}', ',' })) == -1)
   {
      i++;
   }
   if (i) {
      return ({ str[0..i], str[i+1..] });
   }
   return ({ str[0..0], str[1..] });
}
private mixed* parse_node(string str, string token) {
   class parse_node num;
   int type;
   int bing;
   int pos;
   string place;
   string fname;
   string* token_ret;
   mixed *stuff;
   mixed *args;
   while (strlen(str) &&
          str[0] == ' ') {
      str = str[1..];
   }
   if (_functions[token]) {
      fname = token;
      token_ret = query_token(str);
      if (!token_ret) {
         return 0;
      }
      if (token_ret[0] != "(") {
         _error_string = "Expected (, got " + token_ret[0] + " rest: " +
                     token_ret[1];
         return 0;
      }
      str = token_ret[1];
      args = ({ });
      token_ret = query_token(str);
      if (!token_ret) {
         return 0;
      }
      if (token_ret[0] != ")") {
         pos = 0;
         do {
            stuff = parse_operator(token_ret[1], token_ret[0]);
            if (!stuff) {
               return 0;
            }
            pos++;
            if (sizeof(_functions[fname]->args) < pos) {
               _error_string = "To many arguments to " + token + " expected " +
                              sizeof(_functions[fname]->args) + " got " +
                              pos;
               return 0;
            }
            if (_functions[fname]->args[pos - 1] != stuff[EXPRESSION_TYPE] &&
                !(_functions[fname]->args[pos - 1] == EXPRESSION_TYPE_ARRAY &&
                  is_array_type(stuff[EXPRESSION_TYPE])) &&
                !(is_array_type(stuff[EXPRESSION_TYPE]) &&
                  is_null_array_type(stuff[EXPRESSION_TYPE]))) {
               _error_string = "Expected arg " + pos + " to be " +
                        query_type_name(_functions[fname]->args[pos - 1]) +
                        " not " + query_type_name(stuff[EXPRESSION_TYPE]);
               return 0;
            }
            str = stuff[EXPRESSION_PARSE_STRING];
            args += stuff[EXPRESSION_TREE];
            token_ret = query_token(str);
            if (!token_ret) {
               return 0;
            }
            if (token_ret[0] == ",") {
               token_ret = query_token(token_ret[1]);
            }
         } while (token_ret[0] != ")");
         if (token_ret[0] != ")") {
            _error_string = "Expected ')' got " + token_ret[0];
            return 0;
         }
         if (pos != sizeof(_functions[fname]->args)) {
            _error_string = "To few arguments to " + token + " expected " +
                           sizeof(_functions[fname]->args);
            return 0;
         }
         return ({ args +
                  ({ make_node(EXPRESSION_TYPE_FUNCTION,
                               ({ fname, pos }), ({ })) }),
                  token_ret[1],
                  ((class function_thing)_functions[fname])->type });
      }
   } else if (_user_functions[token]) {
      fname = token;
      token_ret = query_token(str);
      if (!token_ret) {
         return 0;
      }
      if (token_ret[0] != "(") {
         _error_string = "Expected (, got " + token_ret[0] + " rest: " +
                     token_ret[1];
         return 0;
      }
      str = token_ret[1];
      args = ({ });
      token_ret = query_token(str);
      if (!token_ret) {
         return 0;
      }
      if (token_ret[0] != ")") {
         do {
            stuff = parse_operator(token_ret[1], token_ret[0]);
            if (!stuff) {
               return 0;
            }
            pos = sizeof(args);
            if (sizeof(_user_functions[fname]->arg_types) <= pos) {
               _error_string = "To many arguments to " + token + " expected " +
                              sizeof(_user_functions[fname]->arg_types);
               return 0;
            }
            if (_user_functions[fname]->arg_types[pos] != stuff[EXPRESSION_TYPE] &&
                !(is_array_type(stuff[EXPRESSION_TYPE]) &&
                  is_null_array_type(stuff[EXPRESSION_TYPE]))) {
               _error_string = "Expected arg " + (pos + 1) + " to be " +
                        query_type_name(_user_functions[fname]->arg_types[pos]) +
                        " not " + query_type_name(stuff[EXPRESSION_TYPE]);
               return 0;
            }
            str = stuff[EXPRESSION_PARSE_STRING];
            args += stuff[EXPRESSION_TREE];
            token_ret = query_token(str);
            if (!token_ret) {
               return 0;
            }
            if (token_ret[0] != "," && token_ret[0] != ")") {
               _error_string = "Expected ')' or ',' got " + token_ret[0];
               return 0;
            }
            if (token_ret[0] == ",") {
               token_ret = query_token(token_ret[1]);
            }
         } while (token_ret[0] != ")");
         if (token_ret[0] != ")") {
            _error_string = "Expected ')' got " + token_ret[0];
            return 0;
         }
         if (sizeof(args) < sizeof(_user_functions[fname]->arg_types)) {
            _error_string = "To few arguments to " + token + " expected " +
                           sizeof(_user_functions[fname]->arg_types);
            return 0;
         }
         return ({ args +
                  ({ make_node(EXPRESSION_TYPE_USER_FUNCTION,
                               ({ fname, sizeof(args) }), ({ })) }),
                  token_ret[1],
                  ((class user_function_thing)_user_functions[fname])->type });
      }
   } else switch (token) {
   case "true" :
      num = make_node(EXPRESSION_TYPE_OPERATOR, EXPRESSION_TRUE, ({ }));
      type = EXPRESSION_TYPE_BOOLEAN;
      break;
   case "false" :
      num = make_node(EXPRESSION_TYPE_OPERATOR, EXPRESSION_FALSE, ({ }));
      type = EXPRESSION_TYPE_BOOLEAN;
      break;
   case "{" :
      token_ret = query_token(str);
      args = ({ });
      type = EXPRESSION_TYPE_ARRAY;
      pos = 0;
      while (token_ret[0] != "}") {
         stuff = parse_operator(token_ret[1], token_ret[0]);
         if (!stuff) {
            return 0;
         }
         if (sizeof(args)) {
            if (type != stuff[EXPRESSION_TYPE]) {
               _error_string = "Arrays must be of only one type.  " +
                      query_type_name(type) + " and " +
                      query_type_name(stuff[EXPRESSION_TYPE]) +
                      " do not match.";
               return 0;
            }
         } else {
            type = stuff[EXPRESSION_TYPE];
            if (is_array_type(type)) {
               _error_string = "Cannot have nested arrays.";
               return 0;
            }
         }
         str = stuff[EXPRESSION_PARSE_STRING];
         args += stuff[EXPRESSION_TREE];
         token_ret = query_token(str);
         if (!token_ret) {
            return 0;
         }
         if (token_ret[0] != "," && token_ret[0] != "}") {
            _error_string = "Expected ')' or ',' got " + token_ret[0];
            return 0;
         }
         if (token_ret[0] == ",") {
            token_ret = query_token(token_ret[1]);
         }
         pos++;
      }
      if (type != EXPRESSION_TYPE_ARRAY) {
         type += EXPRESSION_TYPE_ARRAY_OFFSET;
         return ({ args +
                  ({ make_node(EXPRESSION_TYPE_INTEGER, pos, ({ })),
                     make_node(EXPRESSION_TYPE_OPERATOR,
                               EXPRESSION_ARRAY_AGGREGATE, ({ })) }),
                  token_ret[1],
                  type });
      } else {
         type = EXPRESSION_TYPE_ARRAY_NULL;
         num = make_node(EXPRESSION_TYPE_ARRAY_NULL, 0, ({ }));
         str = token_ret[1];
      }
      break;
   case "" :
      _error_string = "No token found at: " + token + " " + str;
      return 0;
   default :
      if (token[0] == '-' || is_number(token[0])) {
         sscanf(token, "%d", bing);
         num = make_node(EXPRESSION_TYPE_INTEGER, bing, ({ }));
         type = EXPRESSION_TYPE_INTEGER;
      } else if (token == "$0$") {
         num = make_node(EXPRESSION_TYPE_MONEY, 0, ({ }));
         type = EXPRESSION_TYPE_MONEY;
      } else if (token[0] == '$') {
         place = query_property("place");
         if (!place) {
            place = "default";
         }
         bing = MONEY_HAND->value_from_string(token[1..<2], place);
         if (!bing) {
            bing = MONEY_HAND->value_from_string(token[0..<2], place);
         }
         if (bing) {
            num = make_node(EXPRESSION_TYPE_MONEY, bing, ({ }));
            type = EXPRESSION_TYPE_MONEY;
         } else {
            _error_string = "Money value is invalid: " + token[1..<2] + " and " +
                            token[0..<2];
            return 0;
         }
      } else if (token[0] == '\"' || token[0] == '\'') {
         num = make_node(EXPRESSION_TYPE_STRING, token[1..<2], ({ }));
         type = EXPRESSION_TYPE_STRING;
      } else {
         type = query_variable_type(token);
         if (type == EXPRESSION_TYPE_ERROR) {
            type = query_function_variable_type(token);
            if (type == EXPRESSION_TYPE_ERROR) {
               _error_string = "No variable called '" + token + "' rest: '" +
                               str;
               return 0;
            }
            pos = query_function_variable_position(token);
            num = make_node(EXPRESSION_TYPE_FUNCTION_VARIABLE,
                            ({ token, pos }), ({ }));
         } else {
            num = make_node(EXPRESSION_TYPE_VARIABLE, token, ({ }));
         }
      }
      break;
   }
   return ({ ({ num }), str, type });
}
private mixed* parse_bracket(string str, string token) {
   mixed* stuff;
   string* token_ret;
   mixed* ret;
   switch (token) {
   case "(" :
      token_ret = query_token(str);
      if (!token_ret) {
         return 0;
      }
      stuff = parse_operator(token_ret[1], token_ret[0]);
      if (stuff) {
         str = stuff[EXPRESSION_PARSE_STRING];
         token_ret = query_token(str);
         if (!token_ret) {
            return 0;
         }
         if (token_ret[0] !=  ")") {
            _error_string = "Could not find closing bracket at " + str;
            return 0;
         }
         str = token_ret[1];
         ret = ({ stuff[EXPRESSION_TREE], str,
                  stuff[EXPRESSION_TYPE] });
      } else {
         return 0;
      }
      break;
   default :
      stuff = parse_node(str, token);
      if (stuff) {
         ret = ({ stuff[EXPRESSION_TREE],
                   stuff[EXPRESSION_PARSE_STRING],
                   stuff[EXPRESSION_TYPE] });
      } else {
         return 0;
      }
      break;
   }
   str = ret[EXPRESSION_PARSE_STRING];
   token_ret = query_token(str);
   if (token_ret && token_ret[0] == "[") {
      mixed *stuffy;
      if (!is_array_type(ret[EXPRESSION_TYPE])) {
         _error_string = "Cannot de-reference " +
                         query_type_name(stuff[EXPRESSION_TYPE]);
         return 0;
      }
      if (is_null_array_type(ret[EXPRESSION_TYPE])) {
         _error_string = "Cannot de-reference a null array, it has no "
                         "members!";
         return 0;
      }
      token_ret = query_token(token_ret[1]);
      stuffy = parse_operator(token_ret[1], token_ret[0]);
      if (!stuffy) {
         return 0;
      }
      if (stuffy[EXPRESSION_TYPE] != EXPRESSION_TYPE_INTEGER) {
         _error_string = "Can only dereference an array with an integer "
                         "not a " +
                         query_type_name(stuff[EXPRESSION_TYPE]);
         return 0;
      }
      str = stuffy[EXPRESSION_PARSE_STRING];
      token_ret = query_token(str);
      if (token_ret[0] != "]") {
         _error_string = "Could not find closing square bracket at " + str;
         return 0;
      }
      return ({ ret[EXPRESSION_TREE] + stuffy[EXPRESSION_TREE] +
             ({ make_node(EXPRESSION_TYPE_OPERATOR, EXPRESSION_ARRAY_DEREFERENCE, ({ })) }),
                token_ret[1],
                ret[EXPRESSION_TYPE] - EXPRESSION_TYPE_ARRAY_OFFSET });
   }
   return ret;
}
private mixed* parse_plus(string str, string token) {
   mixed *stuff;
   mixed *stuff2;
   int type;
   string* token_ret;
   string blue;
   stuff = parse_bracket(str, token);
   if (!stuff) {
      return 0;
   }
   str = stuff[EXPRESSION_PARSE_STRING];
   token_ret = query_token(str);
   if (!token_ret) {
      return 0;
   }
   switch (token_ret[0]) {
   case "+" :
      type = EXPRESSION_PLUS;
      break;
   case "-" :
      type = EXPRESSION_MINUS;
      break;
   }
   blue = token_ret[0];
   if (type) {
      token_ret = query_token(token_ret[1]);
      if (!token_ret) {
         return 0;
      }
      stuff2 = parse_plus(token_ret[1], token_ret[0]);
      if (!stuff2) {
         return 0;
      }
      if ((!is_number_type(stuff[EXPRESSION_TYPE]) ||
           !is_number_type(stuff2[EXPRESSION_TYPE])) &&
          type != EXPRESSION_PLUS) {
         _error_string = "Invalid types to " + blue +
                     " expected number got: " +
                     query_type_name(stuff[EXPRESSION_TYPE]) + " and " +
                     query_type_name(stuff2[EXPRESSION_TYPE]);
         return 0;
      }
      return ({ stuff[EXPRESSION_TREE] + stuff2[EXPRESSION_TREE] +
                ({ make_node(EXPRESSION_TYPE_OPERATOR, type, ({ })) }),
                stuff2[EXPRESSION_PARSE_STRING], stuff[EXPRESSION_TYPE] });
   } else {
      return stuff;
   }
}
private mixed* parse_multiply(string str, string token) {
   mixed *stuff;
   mixed *stuff2;
   string* token_ret;
   int type;
   string blue;
   stuff = parse_plus(str, token);
   if (!stuff) {
      return 0;
   }
   str = stuff[EXPRESSION_PARSE_STRING];
   token_ret = query_token(str);
   if (!token_ret) {
      return 0;
   }
   switch (token_ret[0]) {
   case "*" :
      type = EXPRESSION_MULTIPLY;
      break;
   case "/" :
      type = EXPRESSION_DIVIDE;
      break;
   }
   blue = token_ret[0];
   if (type) {
      token_ret = query_token(token_ret[1]);
      if (!token_ret) {
         return 0;
      }
      stuff2 = parse_multiply(token_ret[1], token_ret[0]);
      if (!stuff2) {
         return 0;
      }
      if (!is_number_type(stuff[EXPRESSION_TYPE]) ||
           !is_number_type(stuff2[EXPRESSION_TYPE])) {
         _error_string = "Invalid types to " + blue +
                     " expected number got: " +
                     query_type_name(stuff[EXPRESSION_TYPE]) + " and " +
                     query_type_name(stuff2[EXPRESSION_TYPE]);
         return 0;
      }
      return ({ stuff[EXPRESSION_TREE] + stuff2[EXPRESSION_TREE] +
                ({ make_node(EXPRESSION_TYPE_OPERATOR, type, ({ })) }),
                stuff2[EXPRESSION_PARSE_STRING], stuff[EXPRESSION_TYPE] });
   } else {
      return stuff;
   }
}
private mixed* parse_compare(string str, string token) {
   mixed *stuff;
   mixed *stuff2;
   string* token_ret;
   int type;
   string blue;
   stuff = parse_multiply(str, token);
   if (!stuff) {
      return 0;
   }
   str = stuff[EXPRESSION_PARSE_STRING];
   token_ret = query_token(str);
   if (!token_ret) {
      return 0;
   }
   switch (token_ret[0]) {
   case ">=" :
      type = EXPRESSION_GREATOR_OR_EQUAL;
      break;
   case "<=" :
      type = EXPRESSION_LESS_OR_EQUAL;
      break;
   case ">" :
      type = EXPRESSION_GREATOR_THAN;
      break;
   case "<" :
      type = EXPRESSION_LESS_THAN;
      break;
   case "<>" :
   case "!=" :
      type = EXPRESSION_NOT_EQUAL_TO;
      break;
   case "==" :
   case "=" :
      type = EXPRESSION_EQUAL_TO;
      break;
   }
   blue = token_ret[0];
   if (type) {
      token_ret = query_token(token_ret[1]);
      if (!token_ret) {
         return 0;
      }
      stuff2 = parse_compare(token_ret[1], token_ret[0]);
      if (!stuff2) {
         return 0;
      }
      if ((!is_number_type(stuff[EXPRESSION_TYPE]) ||
           !is_number_type(stuff2[EXPRESSION_TYPE])) &&
          type != EXPRESSION_EQUAL_TO &&
          type != EXPRESSION_NOT_EQUAL_TO)
      {
         _error_string = "Invalid types to " + blue +
                     " expected number got: " +
                     query_type_name(stuff[EXPRESSION_TYPE]) + " and " +
                     query_type_name(stuff2[EXPRESSION_TYPE]);
         return 0;
      }
      return ({ stuff[EXPRESSION_TREE] + stuff2[EXPRESSION_TREE] +
                ({ make_node(EXPRESSION_TYPE_OPERATOR, type, ({ })) }),
                stuff2[EXPRESSION_PARSE_STRING],
                EXPRESSION_TYPE_BOOLEAN });
   } else {
      return stuff;
   }
}
private mixed* parse_not(string str, string token) {
   mixed *stuff;
   if (token == "not") {
      stuff = query_token(str);
      if (!stuff) {
         return 0;
      }
      stuff = parse_not(stuff[1], stuff[0]);
      if (!stuff) {
         return 0;
      }
      if (stuff[EXPRESSION_TYPE] != EXPRESSION_TYPE_BOOLEAN) {
         _error_string = "Invalid type to not expected boolean got: " +
                     query_type_name(stuff[EXPRESSION_TYPE]);
         return 0;
      }
      return ({ stuff[EXPRESSION_TREE] +
                ({ make_node(EXPRESSION_TYPE_OPERATOR, EXPRESSION_NOT, ({ }))  }),
                stuff[EXPRESSION_PARSE_STRING],
                EXPRESSION_TYPE_BOOLEAN });
   } else {
      return parse_compare(str, token);
   }
}
private mixed* parse_boolean(string str, string token) {
   mixed *stuff;
   mixed *stuff2;
   string* token_ret;
   string blue;
   int type;
   stuff = parse_not(str, token);
   if (!stuff) {
      return 0;
   }
   str = stuff[EXPRESSION_PARSE_STRING];
   token_ret = query_token(str);
   if (!token_ret) {
      return 0;
   }
   switch (token_ret[0]) {
   case "and" :
      type = EXPRESSION_AND_NEW;
      break;
   case "or" :
      type = EXPRESSION_OR_NEW;
      break;
   }
   blue = token_ret[0];
   if (type) {
      token_ret = query_token(token_ret[1]);
      if (!token_ret) {
         return 0;
      }
      stuff2 = parse_boolean(token_ret[1], token_ret[0]);
      if (!stuff2) {
         return 0;
      }
      if (stuff[EXPRESSION_TYPE] != stuff2[EXPRESSION_TYPE] ||
          stuff[EXPRESSION_TYPE] != EXPRESSION_TYPE_BOOLEAN) {
         _error_string = "Invalid types to " + blue +
                     " expected boolean got: " +
                     query_type_name(stuff[EXPRESSION_TYPE]) + " and " +
                     query_type_name(stuff2[EXPRESSION_TYPE]);
         return 0;
      }
      return ({ ({ make_node(EXPRESSION_TYPE_OPERATOR, type,
                     ({ stuff[EXPRESSION_TREE], stuff2[EXPRESSION_TREE] }) ) }),
                stuff2[EXPRESSION_PARSE_STRING],
                stuff2[EXPRESSION_TYPE] });
   } else {
      return stuff;
   }
}
private mixed* parse_operator(string str, string token) {
   mixed *stuff;
   mixed *stuff2;
   mixed *stuff3;
   string* token_ret;
      switch (token) {
      case "if" :
         token_ret = query_token(str);
         if (!token_ret) {
            return 0;
         }
         stuff = parse_operator(token_ret[1], token_ret[0]);
         if (!stuff) {
            return 0;
         }
         if (stuff[EXPRESSION_TYPE] != EXPRESSION_TYPE_BOOLEAN) {
            _error_string = "Invalid type to if expected boolean got: " +
                        query_type_name(stuff[EXPRESSION_TYPE]);
            return 0;
         }
         token_ret = query_token(stuff[EXPRESSION_PARSE_STRING]);
         if (!token_ret) {
            return 0;
         }
         if (token_ret[0] != "then") {
            _error_string = "Expected 'then' got " + token_ret[0];
            return 0;
         }
         token_ret = query_token(token_ret[1]);
         if (!token_ret) {
            return 0;
         }
         stuff2 = parse_operator(token_ret[1], token_ret[0]);
         if (!stuff2) {
            return 0;
         }
         token_ret = query_token(stuff2[EXPRESSION_PARSE_STRING]);
         if (!token_ret) {
            return 0;
         }
         if (token_ret[0] == "else") {
            token_ret = query_token(token_ret[1]);
            if (!token_ret) {
               return 0;
            }
            stuff3 = parse_operator(token_ret[1], token_ret[0]);
            if (!stuff3) {
               return 0;
            }
            if (stuff2[EXPRESSION_TYPE] != stuff3[EXPRESSION_TYPE]) {
               if (is_array_type(stuff2[EXPRESSION_TYPE]) &&
                   is_array_type(stuff3[EXPRESSION_TYPE]) &&
                   (is_null_array_type(stuff2[EXPRESSION_TYPE]) ||
                    is_null_array_type(stuff3[EXPRESSION_TYPE]))) {
                  if (is_null_array_type(stuff2[EXPRESSION_TYPE])) {
                     stuff2[EXPRESSION_TYPE] = stuff3[EXPRESSION_TYPE];
                  }
               } else {
                  _error_string = "Types on both sides of an if must match: " +
                           query_type_name(stuff2[EXPRESSION_TYPE]) + " and " +
                           query_type_name(stuff3[EXPRESSION_TYPE]);
                  return 0;
               }
            }
            token_ret = query_token(stuff3[EXPRESSION_PARSE_STRING]);
            if (!token_ret) {
               return 0;
            }
         } else {
            stuff3 = ({ ({ query_null_type(stuff2[EXPRESSION_TYPE]) }) });
         }
         if (token_ret[0] != "endif") {
            _error_string = "Expected 'endif' got " + token_ret[0] + " (" +
                            token_ret[1];
            return 0;
         }
         return ({ stuff[EXPRESSION_TREE] +
                   ({ make_node(EXPRESSION_TYPE_OPERATOR, EXPRESSION_IF_NEW,
                                ({
                                    stuff2[EXPRESSION_TREE],
                                    stuff3[EXPRESSION_TREE]
                                   }) ) }),
                   token_ret[1],
                   stuff2[EXPRESSION_TYPE] });
         break;
      default :
         stuff = parse_boolean(str, token);
         if (!stuff) {
            return 0;
         }
         return stuff;
      }
}
class parse_node* parse_boolean_string(string str) {
   mixed* stuff;
   string* token_ret;
   _warning_string = "";
   _func_variables = ([ ]);
   token_ret = query_token(lower_case(str));
   if (!token_ret) {
      return 0;
   }
   stuff = parse_operator(token_ret[1], token_ret[0]);
   if (!stuff) {
      return ({ });
   }
   if (strlen(stuff[EXPRESSION_PARSE_STRING])) {
      _error_string = "Unable to parse the rest of: " +
                      stuff[EXPRESSION_PARSE_STRING];
      return ({ });
   }
   if (stuff[EXPRESSION_TYPE] != EXPRESSION_TYPE_BOOLEAN) {
      _error_string = "Invalid return type, expected boolean got " +
                     query_type_name(stuff[EXPRESSION_TYPE]);
      return ({ });
   }
   return stuff[EXPRESSION_TREE];
}
class parse_node* parse_integer_string(string str) {
   mixed* stuff;
   string* token_ret;
   _warning_string = "";
   _func_variables = ([ ]);
   token_ret = query_token(lower_case(str));
   if (!token_ret) {
      return 0;
   }
   stuff = parse_operator(token_ret[1], token_ret[0]);
   if (!stuff) {
      return ({ });
   }
   if (strlen(stuff[EXPRESSION_PARSE_STRING])) {
      _error_string = "Unable to parse the rest of: " +
                      stuff[EXPRESSION_PARSE_STRING];
      return ({ });
   }
   if (stuff[EXPRESSION_TYPE] != EXPRESSION_TYPE_INTEGER) {
      _error_string = "Invalid return type, expected integer got " +
                     query_type_name(stuff[EXPRESSION_TYPE]);
      return ({ });
   }
   return stuff[EXPRESSION_TREE];
}
class parse_node* parse_money_string(string str) {
   mixed* stuff;
   string* token_ret;
   _warning_string = "";
   _func_variables = ([ ]);
   token_ret = query_token(lower_case(str));
   if (!token_ret) {
      return 0;
   }
   stuff = parse_operator(token_ret[1], token_ret[0]);
   if (!stuff) {
      return ({ });
   }
   if (strlen(stuff[EXPRESSION_PARSE_STRING])) {
      _error_string = "Unable to parse the rest of: " +
                      stuff[EXPRESSION_PARSE_STRING];
      return ({ });
   }
   if (stuff[EXPRESSION_TYPE] != EXPRESSION_TYPE_MONEY) {
      _error_string = "Invalid return type, expected money got " +
                     query_type_name(stuff[EXPRESSION_TYPE]);
      return ({ });
   }
   return stuff[EXPRESSION_TREE];
}
mixed* parse_user_expression_definition(string def) {
   mixed* token;
   string name;
   int* arg_types;
   int type;
   string* arg_names;
   token = query_token(def);
   name = token[0];
   def = token[1];
   if (!strlen(def)) {
      return ({ name, ({ }), ({ }) });
   }
   token = query_token(def);
   if (token[0] == "(") {
      token = query_token(token[1]);
      arg_names = ({ });
      arg_types = ({ });
      while (token[0] != ")") {
         type = query_type_value(token[0]);
         if (type == EXPRESSION_TYPE_ARRAY) {
            token = query_token(token[1]);
            type = query_type_value(token[0]);
            if (type != EXPRESSION_TYPE_ERROR) {
               type += EXPRESSION_TYPE_ARRAY_OFFSET;
            }
         }
         if (type == EXPRESSION_TYPE_ERROR) {
            _error_string = "Invalid type " + token[0];
            return 0;
         } else {
            token = query_token(token[1]);
            if (member_array(token[0], arg_names) != -1) {
               _error_string = "Duplicate argument name " + token[0];
               return 0;
            }
            arg_types += ({ type });
            arg_names += ({ token[0] });
            token = query_token(token[1]);
            if (token[0] != "," && token[0] != ")") {
               _error_string = "Expected , or ) after " + arg_names[<1];
               return 0;
            }
            if (token[0] == ",") {
               token = query_token(token[1]);
            }
         }
      }
      if (strlen(token[1])) {
         _error_string = "Unable to parse the rest of " + token[1];
         return 0;
      }
      return ({ name, arg_types, arg_names });
   } else {
      _error_string = "Unable to parse rest of: " + def;
   }
}
string parse_user_expression(
   string def,
   string str)
{
   mixed* stuff;
   int i;
   string* token_ret;
   class user_function_thing old_fluff;
   class user_function_thing fluff;
   class func_variable_thing womble;
   int* arg_types;
   string* arg_names;
   string name;
   _warning_string = "";
   stuff = parse_user_expression_definition(def);
   if (!stuff) {
      return 0;
   }
   name = stuff[0];
   arg_types = stuff[1];
   arg_names = stuff[2];
   _func_variables = ([ ]);
   for (i = 0; i < sizeof(arg_types); i++) {
      womble = new(class func_variable_thing);
      womble->type = arg_types[i];
      womble->arg_no = i;
      _func_variables[arg_names[i]] = womble;
   }
   token_ret = query_token(lower_case(str));
   if (!token_ret) {
      return 0;
   }
   stuff = parse_operator(token_ret[1], token_ret[0]);
   _func_variables = ([ ]);
   if (!stuff) {
      return 0;
   }
   if (strlen(stuff[EXPRESSION_PARSE_STRING])) {
      _error_string = "Unable to parse the rest of: " +
                      stuff[EXPRESSION_PARSE_STRING];
      return 0;
   }
   fluff = new(class user_function_thing);
   fluff->type = stuff[EXPRESSION_TYPE];
   fluff->expr = stuff[EXPRESSION_TREE];
   fluff->arg_names = arg_names;
   fluff->arg_types = arg_types;
   old_fluff = _user_functions[name];
   if (old_fluff) {
      if (old_fluff->type != fluff->type) {
         _warning_string += "Warning: Return types have changed " +
                    query_type_name(old_fluff->type) + " to " +
                    query_type_name(fluff->type) + ".\n";
      }
      if (sizeof(old_fluff->arg_types) != sizeof(fluff->arg_types)) {
         _warning_string += "Warning: Number of arguments has changed.\n";
      }
      for (i = 0; i < sizeof(old_fluff->arg_types) && i < sizeof(fluff->arg_types); i++) {
         if (old_fluff->arg_types[i] != fluff->arg_types[i]) {
            _warning_string += "Warning: Argument number " + i +
                               " differs in type " +
                               query_type_name(old_fluff->arg_types[i]) +
                               " to " + query_type_name(fluff->arg_types[i]) +
                               ".\n";
         }
      }
   }
   _user_functions[name] = fluff;
   return name;
}
int sizeof_function(mixed* arr, mixed args ...) {
   return sizeof(arr);
}
string query_expression_string(class parse_node* expr, int brief) {
   string str;
   int i;
   string* stack;
   int* thing;
   string tmp;
   string place;
   int value;
   string indent;
   if (!sizeof(expr)) {
      return "No expression set.";
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   indent = "";
   str = "";
   stack = ({ });
   thing = ({ });
   for (i = 0; i < sizeof(expr); i++) {
      if (!classp(expr[i])) {
         stack += ({ "Broken element" });
         thing += ({ 0 });
         continue;
      }
      switch (expr[i]->type) {
      case EXPRESSION_TYPE_OPERATOR :
         value = expr[i]->value;
         switch (expr[i]->value) {
         case EXPRESSION_NOT :
            str = " " + query_operator_name(expr[i]->value) + " ";
            if (thing[<1] && thing[<1] != expr[i]->value) {
               str += "(" + stack[<1] + ")";
            } else {
               str += stack[<1];
            }
            stack = stack[0..<2];
            thing = thing[0..<2];
            break;
         case EXPRESSION_AND_NEW :
         case EXPRESSION_OR_NEW :
            str += query_expression_string(expr[i]->tree[0], brief);
            str += " " + query_operator_name(expr[i]->value) + " ";
            str += query_expression_string(expr[i]->tree[1], brief);
            break;
         case EXPRESSION_AND :
         case EXPRESSION_OR :
         case EXPRESSION_PLUS :
         case EXPRESSION_MINUS :
         case EXPRESSION_DIVIDE :
         case EXPRESSION_MULTIPLY :
         case EXPRESSION_GREATOR_THAN     :
         case EXPRESSION_LESS_THAN        :
         case EXPRESSION_EQUAL_TO         :
         case EXPRESSION_GREATOR_OR_EQUAL :
         case EXPRESSION_LESS_OR_EQUAL    :
         case EXPRESSION_NOT_EQUAL_TO     :
            tmp = stack[<2];
            if (thing[<2] && thing[<2] != expr[i]->value) {
               str = "(" + stack[<2] + ")";
            } else {
               str = stack[<2];
            }
            str += " " + query_operator_name(expr[i]->value) + " ";
            if (thing[<1] && thing[<1] != expr[i]->value) {
               str += "(" + stack[<1] + ")";
            } else {
               str += stack[<1];
            }
            stack = stack[0..<3];
            thing = thing[0..<3];
            break;
         case EXPRESSION_TRUE :
            str = "true";
            value = 0;
            break;
         case EXPRESSION_FALSE :
            str = "false";
            value = 0;
            break;
         case EXPRESSION_IF_NEW :
            if (brief) {
               str = "if " + stack[<1] + " then " +
                     query_expression_string(expr[i]->tree[0], brief) +
                     " else " +
                     query_expression_string(expr[i]->tree[1], brief) +
                     " endif";
            } else {
               str = "if " + stack[<1] + " then\n" +
                     "   " + replace_string(
                        query_expression_string(expr[i]->tree[0], brief),
                                     "\n", "\n   ") +
                     "\nelse\n" +
                     "   " + replace_string(
                        query_expression_string(expr[i]->tree[1], brief),
                                     "\n", "\n   ") +
                     "\nendif";
            }
            stack = stack[0..<2];
            thing = thing[0..<2];
            value = 0;
            break;
         case EXPRESSION_IF :
            if (brief) {
               str = "if " + stack[<3] + " then " + stack[<2] + " else " +
                     stack[<1] + " endif";
            } else {
               str = "if " + stack[<3] + " then\n" +
                     "   " + replace_string(stack[<2], "\n", "\n   ") +
                     "\nelse\n" +
                     "   " + replace_string(stack[<1], "\n", "\n   ") +
                     "\nendif";
            }
            stack = stack[0..<4];
            thing = thing[0..<4];
            value = 0;
            break;
         case EXPRESSION_ARRAY_DEREFERENCE :
            str = stack[<2] + "[" + stack[<1] + "]";
            stack = stack[0..<3];
            thing = thing[0..<3];
            value = 0;
            break;
         case EXPRESSION_ARRAY_AGGREGATE :
            str = "{ " +
                   implode(stack[<(expr[i - 1]->value+1)..<2],
                        ", ") + " }";
            thing = thing[0..<expr[i - 1]->value + 2];
            stack = stack[0..<expr[i - 1]->value + 2];
            value = 0;
            break;
         default :
            str = "Error!";
            break;
         }
         stack += ({ str });
         thing += ({ value });
         break;
      case EXPRESSION_TYPE_ARRAY_NULL :
         stack += ({ "{}" });
         thing += ({ 0 });
         break;
      case EXPRESSION_TYPE_MONEY :
         stack += ({ MONEY_HAND->money_value_string(expr[i]->value, place) });
         thing += ({ 0 });
         break;
      case EXPRESSION_TYPE_INTEGER :
         stack += ({ "" + expr[i]->value });
         thing += ({ 0 });
         break;
      case EXPRESSION_TYPE_STRING :
         stack += ({ "\"" + expr[i]->value + "\"" });
         thing += ({ 0 });
         break;
      case EXPRESSION_TYPE_VARIABLE :
         stack += ({ expr[i]->value });
         thing += ({ 0 });
         break;
      case EXPRESSION_TYPE_FUNCTION_VARIABLE :
         stack += ({ expr[i]->value[EXPRESSION_FUNC_VAR_NAME] });
         thing += ({ 0 });
         break;
      case EXPRESSION_TYPE_FUNCTION :
      case EXPRESSION_TYPE_USER_FUNCTION :
         str = expr[i]->value[EXPRESSION_FUNC_NAME] + "(";
         str += implode(stack[<expr[i]->value[EXPRESSION_FUNC_NO_ARGS]..],
                        ", ");
         str += ")";
         stack = stack[0..<expr[i]->value[EXPRESSION_FUNC_NO_ARGS] + 1];
         thing = thing[0..<expr[i]->value[EXPRESSION_FUNC_NO_ARGS] + 1];
         stack += ({ str });
         thing += ({ 0 });
         break;
      default :
         stack += ({ "Unknown: " + expr[i]->type + " (" + expr[i]->value + ")" });
         thing += ({ 0 });
         break;
      }
   }
   return stack[<1];
}
string query_user_function_string(string func) {
   class user_function_thing thing;
   int i;
   string ret;
   thing = _user_functions[func];
   ret = "";
   ret += query_type_name(thing->type) + " " + func + "(";
   for (i = 0; i < sizeof(thing->arg_types); i++) {
      ret += query_type_name(thing->arg_types[i]) + " " + thing->arg_names[i];
      if (i < sizeof(thing->arg_types) - 1) {
         ret += ", ";
      }
   }
   ret += ") {\n   ";
   ret += replace_string(query_expression_string(thing->expr, 0),
                         "\n", "\n   ") + "\n}\n";
   return ret;
}
class parse_node evaluate_expression(class parse_node* expr, mixed args ...) {
   class parse_node bing;
   class parse_node new_node;
   class parse_node* stack;
   string fname;
   mixed* fargs;
   int i;
   if (!sizeof(expr)) {
      return make_node(EXPRESSION_TYPE_BOOLEAN, 0, ({ }));
   }
   stack = ({ });
   foreach (bing in expr) {
      if (!classp(bing)) {
         continue;
      }
      switch (bing->type) {
      case EXPRESSION_TYPE_OPERATOR :
         switch (bing->value) {
         case EXPRESSION_NOT :
            stack[<1] = make_node(EXPRESSION_TYPE_BOOLEAN, !stack[<1]->value, 0);
            break;
         case EXPRESSION_AND_NEW :
            new_node = evaluate_expression(bing->tree[0],
                   args + ({ sizeof(args) }) ...);
            if (!new_node->value) {
               stack += ({ make_node(EXPRESSION_TYPE_BOOLEAN, 0, 0) });
            } else {
               new_node = evaluate_expression(bing->tree[1],
                       args ...);
               stack += ({ make_node(EXPRESSION_TYPE_BOOLEAN, new_node->value, 0) });
            }
            break;
         case EXPRESSION_OR_NEW :
            new_node = evaluate_expression(bing->tree[0],
                   args...);
            if (new_node->value) {
               stack += ({ make_node(EXPRESSION_TYPE_BOOLEAN, 1, 0) });
            } else {
               new_node = evaluate_expression(bing->tree[1],
                       args ...);
               stack += ({ make_node(EXPRESSION_TYPE_BOOLEAN, new_node->value, 0) });
            }
            break;
         case EXPRESSION_AND :
            stack[<2] = make_node(EXPRESSION_TYPE_BOOLEAN, stack[<1]->value &&
                                                           stack[<2]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_OR :
            stack[<2] = make_node(EXPRESSION_TYPE_BOOLEAN, stack[<1]->value ||
                                                           stack[<2]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_PLUS :
            stack[<2] = make_node(stack[<1]->type, stack[<2]->value +
                                                   stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_MINUS :
            stack[<2] = make_node(stack[<1]->type, stack[<2]->value -
                                                   stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_DIVIDE :
            stack[<2] = make_node(stack[<1]->type, stack[<2]->value /
                                                   stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_MULTIPLY :
            stack[<2] = make_node(stack[<1]->type, stack[<2]->value *
                                                   stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_GREATOR_THAN     :
            stack[<2] = make_node(EXPRESSION_TYPE_BOOLEAN, stack[<2]->value >
                                                           stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_LESS_THAN        :
            stack[<2] = make_node(EXPRESSION_TYPE_BOOLEAN, stack[<2]->value <
                                                           stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_EQUAL_TO         :
            stack[<2] = make_node(EXPRESSION_TYPE_BOOLEAN, stack[<2]->value ==
                                                           stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_GREATOR_OR_EQUAL :
            stack[<2] = make_node(EXPRESSION_TYPE_BOOLEAN, stack[<2]->value >=
                                                           stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_LESS_OR_EQUAL    :
            stack[<2] = make_node(EXPRESSION_TYPE_BOOLEAN, stack[<2]->value <=
                                                           stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_NOT_EQUAL_TO     :
            stack[<2] = make_node(EXPRESSION_TYPE_BOOLEAN, stack[<2]->value !=
                                                           stack[<1]->value, 0);
            stack = stack[0..<2];
            break;
         case EXPRESSION_IF_NEW               :
            if (stack[<1]->value) {
               new_node = evaluate_expression(bing->tree[0],
                   args ...);
            } else {
               new_node = evaluate_expression(bing->tree[1],
                   args ...);
            }
            stack = stack[0..<2] + ({ new_node });
            break;
         case EXPRESSION_IF               :
            if (stack[<3]->value) {
               new_node = stack[<2];
            } else {
               new_node = stack[<1];
            }
            stack = stack[0..<4] + ({ new_node });
            break;
         case EXPRESSION_ARRAY_DEREFERENCE :
            if (stack[<1]->value < 0 ||
                stack[<1]->value >= sizeof(stack[<2]->value)) {
               printf("Warning!  Array out of bounds (" +
                      query_expression_string(expr, 1) + ")\n");
               stack = stack[0..<3] + ({ query_null_type(EXPRESSION_TYPE_INTEGER) });
            } else {
               stack = stack[0..<3] +
                     ({ make_node(stack[<1]->type - EXPRESSION_TYPE_ARRAY_OFFSET,
                                  stack[<2]->value[stack[<1]->value], 0) });
            }
            break;
         case EXPRESSION_ARRAY_AGGREGATE :
            fargs = ({ });
            for (i = 0; i < stack[<1]->value; i++) {
               fargs += ({ stack[<i + 2]->value });
            }
            new_node = new(class parse_node,
                           type : stack[<2]->type + EXPRESSION_TYPE_ARRAY_OFFSET,
                           value : fargs);
            stack = stack[0..<stack[<1]->value+2] + ({ new_node });
            break;
         case EXPRESSION_TRUE             :
            stack += ({ make_node(EXPRESSION_TYPE_BOOLEAN, 1, 0) });
            break;
         case EXPRESSION_FALSE            :
            stack += ({ make_node(EXPRESSION_TYPE_BOOLEAN, 0, 0) });
            break;
         default :
            printf("Unknown operator %O\n", bing);
            break;
         }
         break;
      case EXPRESSION_TYPE_ARRAY_NULL :
         stack += ({ new(class parse_node, type : EXPRESSION_TYPE_ARRAY_NULL,
                         value : ({ }) ) });
         break;
      case EXPRESSION_TYPE_INTEGER :
         stack += ({ copy(bing) });
         break;
      case EXPRESSION_TYPE_STRING :
         stack += ({ copy(bing) });
         break;
      case EXPRESSION_TYPE_MONEY :
         stack += ({ copy(bing) });
         break;
      case EXPRESSION_TYPE_VARIABLE :
         stack += ({ make_node(query_variable_type(bing->value),
                               evaluate(query_variable_value(bing->value),
                                        args ...), 0) });
         break;
      case EXPRESSION_TYPE_FUNCTION_VARIABLE:
         stack += ({ args[bing->value[EXPRESSION_FUNC_VAR_POS] + args[<1]] });
         break;
      case EXPRESSION_TYPE_USER_FUNCTION:
         fname = bing->value[EXPRESSION_FUNC_NAME];
         fargs = stack[<bing->value[EXPRESSION_FUNC_NO_ARGS]..];
         stack = stack[0..<bing->value[EXPRESSION_FUNC_NO_ARGS] + 1];
         if (!_user_functions[fname]) {
            printf("Unknown function %O\n", fname);
            break;
         }
         bing = evaluate_expression(_user_functions[fname]->expr,
                   args + fargs + ({ sizeof(args) }) ...);
         if (!bing) {
            printf("Broken return stuff.\n");
            break;
         }
         stack += ({ bing });
         break;
      case EXPRESSION_TYPE_FUNCTION :
         fname = bing->value[EXPRESSION_FUNC_NAME];
         fargs = stack[<bing->value[EXPRESSION_FUNC_NO_ARGS]..];
         stack = stack[0..<bing->value[EXPRESSION_FUNC_NO_ARGS] + 1];
         stack += ({ make_node(query_function_type(fname),
                               evaluate(query_function_value(fname),
                                        map(fargs, (: $1->value :)) +
                                        args ...), 0) });
         break;
      default :
         printf("Unknown type %O\n", bing);
         break;
      }
   }
   return stack[<1];
}

==================================================
FILE: basic/extra_look.c
==================================================

private nosave object *extra_looks;
void create() {
  extra_looks = ({ });
}
string calc_extra_look() {
  int i;
  string s1, s2;
  s1 = "";
  if (!extra_looks) {
    extra_looks = ({ });
  }
  for (i = 0; i < sizeof(extra_looks); i++) {
    if (extra_looks[i]) {
      s2 = (string)((extra_looks[i])->extra_look(this_object()));
      if(s2)
        s1 += s2;
    } else {
      extra_looks = delete(extra_looks, i, 1);
      i--;
    }
  }
  return s1;
}
void add_extra_look(object ob) {
  if(member_array(ob, extra_looks) != -1) {
    return;
  }
  if(stringp(ob))
    ob = find_object((string)ob);
  extra_looks += ({ ob });
}
void remove_extra_look(object ob) {
  int i;
  i = member_array(ob, extra_looks);
  if (i < 0) {
    return;
  }
  extra_looks = delete(extra_looks, i, 1);
}
object *query_extra_look_list() {
  return extra_looks;
}

==================================================
FILE: basic/help_files.c
==================================================

#include <room.h>
#include <nroff.h>
mixed query_property(string name);
void add_property(string name, mixed value);
void add_help_file(string help_file) {
   string* help;
   help = query_property(ROOM_HELP_FILE_PROPERTY);
   if (help) {
      if (member_array(help_file, help) == -1) {
         help += ({ help_file });
      }
   } else {
      help = ({ help_file });
   }
   add_property(ROOM_HELP_FILE_PROPERTY, help);
}
void remove_help_file(string help_file) {
   string* help;
   help = query_property(ROOM_HELP_FILE_PROPERTY);
   if (help) {
      help -= ({ help_file });
      add_property(ROOM_HELP_FILE_PROPERTY, help);
   }
}
string query_help_files() {
   return query_property(ROOM_HELP_FILE_PROPERTY);
}
string query_help_file_directory() {
   return "/doc/unknown/";
}
private string nroff_file(string name, int html) {
   string nroff_fn;
   string str;
   if (name[0] != '/') {
      name = query_help_file_directory() + name;
   }
   nroff_fn = NROFF_DIR + replace(name, "/", ".");
   if (html) {
      str = NROFF_HAND->html_file(nroff_fn, 1);
   } else {
      str = NROFF_HAND->cat_file(nroff_fn, 1);
   }
   if (!str) {
      NROFF_HAND->create_nroff(name, nroff_fn);
      if (html) {
         str = NROFF_HAND->html_file(nroff_fn, 0);
      } else {
         str = NROFF_HAND->cat_file(nroff_fn, 0);
      }
   }
   return str;
}
mixed* help_function() {
   string* help;
   string bing;
   string* ret;
   help = query_property(ROOM_HELP_FILE_PROPERTY);
   if (sizeof(help)) {
      ret = ({ });
      foreach (bing in help) {
         ret += ({ ({ replace_string(bing, "_", " "),
                   (: nroff_file($(bing), 0) :) }) });
      }
      return ret;
   }
   return 0;
}
string help_string() {
   string *help;
   string str;
   string bing;
   help = query_property(ROOM_HELP_FILE_PROPERTY);
   if (sizeof(help)) {
      str = "";
      foreach (bing in help) {
        str += nroff_file(bing, 0);
      }
      return str;
   }
   return 0;
}

==================================================
FILE: basic/hide_invis.c
==================================================

#define SKILL "other.perception"
private nosave mapping _hide_invis;
void create() {
  _hide_invis = ([]);
}
mapping query_hide_invis() {
  return copy( _hide_invis );
}
int add_hide_invis( string type, object who, mixed see, string *gone ) {
  if( _hide_invis[type] ) {
    return 0;
  }
  _hide_invis[type] = ({ who, see, gone });
  if( environment( this_object() ) ) {
    event( environment( this_object() ), "hide_invis", 1, type, 0 );
  }
  return 1;
}
varargs int remove_hide_invis( string type, int quiet ) {
  mixed *gone;
  if( !_hide_invis[type] ) {
    return 0;
  }
  gone = _hide_invis[type][2];
  if( sizeof( gone ) == 2 && gone[0] )
    if( quiet )
      call_other( gone[0], gone[1], quiet );
    else
      call_other( gone[0], gone[1] );
  map_delete( _hide_invis, type );
  if( environment( this_object() ) ) {
    event( environment( this_object() ), "hide_invis", 0, type, quiet );
  }
  return 1;
}
int perception_check( object thing ) {
  int perception;
  perception = thing->query_skill_bonus( SKILL );
  if( !environment( thing ) || !perception )
    return perception;
  switch( thing->check_dark( (int)environment( thing )->query_light() ) ) {
    case -2:
    case 2:
      perception /= 4;
      break;
    case -1:
    case 1:
      perception /= 2;
      break;
    default:
      break;
  }
  return perception;
}
int query_visible( object thing ) {
  int i;
  string *types;
  mixed see;
  if( thing == this_object() ) {
    return 1;
  }
  if( thing->query_creator() || thing->query_property( "demon" ) ) {
    return 1;
  }
  if( thing->query_blinded() ) {
    return 0;
  }
  types = keys( _hide_invis );
  if( !sizeof( types ) ) {
    return 1;
  }
  for( i = 0; i < sizeof( types ); i++ ) {
    if( _hide_invis[types[i]][0] == thing ) {
      continue;
    }
    see = _hide_invis[types[i]][1];
    if( intp( see ) ) {
      if( perception_check( thing ) > see ) {
        continue;
      }
      return 0;
    }
    if( stringp( see ) ) {
      if( call_other( thing, see ) ) {
        continue;
      }
      return 0;
    }
    return 0;
  }
  return 1;
}
string hide_invis_string() {
  int i;
  string list;
  string *types;
  types = keys( _hide_invis );
  if( !sizeof( types ) ) {
    return "";
  }
  list = "";
  for( i = 0; i < sizeof( types ); i++ ) {
    list += " ("+ types[i] +")";
  }
  return list;
}

==================================================
FILE: basic/holdable.c
==================================================

#include <move_failures.h>
private int _my_limb;
private nosave int _no_limbs;
private object _holder;
int held_this_item(int held, object holder, mixed arg);
void set_no_limbs(int num);
void create() {
   _no_limbs = 1;
}
mixed query_static_auto_load() {
  return ([ "no limbs" : _no_limbs
          ]);
}
void init_static_arg( mapping arg ) {
   if (!arg) {
      return ;
   }
   if (arg["no limbs"]) {
      set_no_limbs(arg["no limbs"]);
   }
}
mixed query_dynamic_auto_load() {
  return ([ "limb"       : (_holder ? _my_limb : -1),
            "limbs used" : (_holder ?
              sizeof(find_member(this_object(),
                                 _holder->query_holding())) : 0)
          ]);
}
void init_dynamic_arg( mapping arg, mixed new_arg ) {
   if (!arg) {
      return ;
   }
   if (arg["limb"] != -1) {
      call_out( function( int pos, mapping arg, mixed new_arg ) {
         if ( environment() ) {
            environment()->set_hold(this_object(), pos,
                                    arg["limbs used"]);
         }
         held_this_item(2, environment(), new_arg);
      }, 0, arg["limb"], arg, new_arg);
   }
}
int held_this_item(int held, object holder, mixed arg) {
   return 1;
}
int set_holder(object ob, int limb) {
   if (ob && environment() != ob) {
      return 0;
   }
   this_object()->remove_hide_invis( "concealed" );
   if ( !ob ||
        ob != _holder) {
      if (!held_this_item(0, _holder, 0)) {
         return 0;
      }
   }
   if (ob) {
      if (!held_this_item(1, ob, 0)) {
         return 0;
      }
   }
   _holder = ob;
   _my_limb = limb;
   return 1;
}
int query_my_limb() { return _my_limb; }
int query_no_limbs() { return _no_limbs; }
void set_no_limbs(int num) {
   if (num < 0) {
      return ;
   }
   _no_limbs = num;
}
int move( mixed ob) {
   if ( ob != _holder && _holder ) {
      if ( !sizeof( _holder->set_unhold( this_object() ) ) ) {
         return MOVE_NO_UNHOLD;
      }
   }
   return MOVE_OK;
}
object query_wielded() { return _holder; }
object query_holder() { return _holder; }
void dest_me() {
   if (_holder) {
      _holder->set_unhold(this_object());
   }
}
varargs int *hold_item( object who, int pos ) {
   object ob;
   object *held_things;
   object *dropped_things = ({ });
   int num_limbs;
  if( !undefinedp( pos ) && pos != -1 ) {
    if( pos < 0 || pos >= sizeof( who->query_holding() ) )
      return ({});
    ob = who->query_holding()[ pos ];
    if( ob ) {
      if( !sizeof( who->set_unhold( ob ) ) )
        return ({});
      else dropped_things += ({ ob });
    }
    held_things = who->query_holding()[pos..] +
                  who->query_holding()[0..pos-1];
  }
  else {
    held_things = who->query_holding();
    pos = -1;
  }
  if (pos == -1)  num_limbs = this_object()->query_no_limbs();
  else num_limbs = 1;
  tell_creator( who, "FL: %d, NL: %d, ob: %O\n", who->query_free_limbs(),
      num_limbs, this_object() );
  tell_creator( who, "Dropped things: %O\n", dropped_things );
  for( int i = 0; who->query_free_limbs() <
      num_limbs && i < sizeof( held_things ); i++ ) {
    tell_creator( who, "freeing limbs\n" );
    ob = held_things[i];
    if( ob && sizeof( who->set_unhold( ob ) ) )
      dropped_things += ({ ob });
  }
  if ( sizeof( dropped_things ) )
    tell_object( who, "You put down " + query_multiple_short(
        dropped_things ) + ".\n" );
  if( who->query_free_limbs() >= num_limbs ) {
     return who->set_hold( this_object(), pos, num_limbs );
  }
   tell_object( who, "You can't free up enough limbs to use "+
       this_object()->a_short() + ".\n" );
   return ({ });
}

==================================================
FILE: basic/id.c
==================================================

#include <parse_command.h>
inherit "/std/basic/id_match";
class Id {
  string name;
  string *alias;
  string *faux_alias;
  string *unique_faux_alias;
  string *adjectives;
  string *faux_adjectives;
  string *unique_faux_adjectives;
  string *plural_adjectives;
  string *plurals;
}
private nosave class Id _id;
int id_adjective(string);
int id_plural(string str);
int faux_id_allowed();
private void setup_id_class() {
   if (_id) {
      return ;
   }
   _id = new( class Id );
   _id->alias = ({ });
   _id->faux_alias = ({ });
   _id->unique_faux_alias = ({ });
   _id->plurals = ({ });
   _id->adjectives = ({ });
   _id->faux_adjectives = ({ });
   _id->unique_faux_adjectives = ({ });
   _id->plural_adjectives = ({ });
   _id->name = "object";
}
void set_name(string str) {
   _id->name = str;
}
string query_name() {
   if (!_id) {
      return 0;
   }
   return _id->name;
}
string query_cap_name() {
   if (!_id->name) {
      return "Someone";
   }
   return capitalize(_id->name);
}
void create() {
   setup_id_class();
}
void set_aliases(string *str) {
   _id->alias = str;
}
void add_alias(mixed str) {
   if (pointerp(str)) {
      _id->alias += str;
      return;
   }
   if (member_array(str, _id->alias) == -1) {
      _id->alias += ({ str });
   }
}
int remove_alias(string str) {
   int i;
   i = member_array(str, _id->alias);
   if (i == -1) {
      return 0;
   }
   _id->alias = _id->alias[0..i - 1] + _id->alias[i + 1..];
   return 1;
}
varargs string *query_alias( int no_faux ) {
  if( no_faux ||
      !sizeof( _id->unique_faux_alias ) ||
      !faux_id_allowed() )
    return _id->alias;
  else
    return _id->alias + _id->unique_faux_alias;
}
void add_faux_alias(mixed str) {
   if (pointerp(str)) {
      foreach( string aka in str )
        add_faux_alias( aka );
      return;
   }
   if( member_array( str, _id->alias ) != -1 )
     return;
   _id->faux_alias += ({ str });
   _id->unique_faux_alias = _id->unique_faux_alias | ({ str });
}
int remove_faux_alias(string str) {
   int i;
   i = member_array(str, _id->faux_alias);
   if (i == -1) {
      return 0;
   }
   _id->faux_alias = _id->faux_alias[0..i - 1] +
                      _id->faux_alias[i + 1..];
   if( member_array(str, _id->faux_alias) == -1 ) {
      _id->unique_faux_alias -= ({ str });
   }
   return 1;
}
string *query_faux_alias() {
  return _id->faux_alias;
}
string *query_unique_faux_alias() {
  return _id->unique_faux_alias;
}
int faux_id_allowed() {
  foreach( object ob in previous_object(-1) ) {
    if( objectp(ob) && ob->ignore_identifier() )
      return 0;
  }
  return 1;
}
int id(string str) {
   return (str == _id->name ||
          (member_array(str, query_alias()) != -1) );
}
int full_id(string str) {
   string *words;
   string name;
   string adjective;
   words = explode(str, " ") - ({ "" });
   name = words[<1];
   words = words[0.. < 2];
   if (!id(name)) {
      if (!id_plural(name)) {
         return 0;
      }
   }
   foreach(adjective in words) {
      if (!id_adjective(adjective)) {
         return 0;
      }
   }
   return 1;
}
void set_plurals(string *str) {
   _id->plurals = str;
}
void add_plural(mixed str) {
   if (pointerp(str)) {
      _id->plurals += str;
   } else if (_id->plurals) {
      if (member_array(str, _id->plurals) == -1) {
         _id->plurals += ({ str });
      }
   } else {
      _id->plurals = ({ str });
   }
}
void remove_plural(string str) {
   int i;
   i = member_array(str, _id->plurals);
   if (i != -1) {
      _id->plurals = _id->plurals[0..i - 1] + _id->plurals[i + 1..];
   }
}
void add_plurals(string *str) {
   _id->plurals += str;
}
string *query_plurals() {
   return _id->plurals;
}
int id_plural(string str) {
   return (member_array(str, _id->plurals) != -1);
}
void set_adjectives(string *str) {
   _id->adjectives = str;
}
void add_adjective(mixed str) {
   int i;
   if (pointerp(str)) {
      for (i = 0; i < sizeof(str); i++) {
         add_adjective(str[i]);
      }
      return;
   }
   if (stringp(str)) {
      str = explode(str, " ");
   }
   for (i = 0; i < sizeof(str); i++) {
      if (member_array(str[i], _id->adjectives) == -1) {
         _id->adjectives += ({ str[i] });
      }
   }
}
void remove_adjective(mixed str) {
   int i;
   if (pointerp(str)) {
      for (i = 0; i < sizeof(str); i++) {
         remove_adjective(str[i]);
      }
   } else {
      if ((i = member_array(str, _id->adjectives)) != -1) {
         _id->adjectives = delete(_id->adjectives, i, 1);
      }
   }
}
void add_faux_adjective(mixed str) {
   if (pointerp(str)) {
      foreach( string adj in str )
         add_faux_adjective( adj );
      return;
   }
   if( stringp( str ) ) {
      str = explode(str, " ");
   }
   str -= _id->adjectives;
   foreach( string adj in str ) {
      _id->faux_adjectives += ({ adj });
      _id->unique_faux_adjectives = _id->unique_faux_adjectives |
                                    ({ adj });
   }
}
void remove_faux_adjective(mixed str) {
   int i;
   if (pointerp(str)) {
      foreach( string adj in str )
         remove_faux_adjective( adj );
      return;
   }
   i = member_array(str, _id->faux_adjectives);
   if( i == -1 )
     return;
   _id->faux_adjectives = _id->faux_adjectives[0..i-1] +
                          _id->faux_adjectives[i+1..];
   if( ( i = member_array( str, _id->faux_adjectives ) ) == -1 )
     _id->unique_faux_adjectives -= ({ str });
}
string *query_faux_adjectives() {
  return _id->faux_adjectives;
}
string *query_unique_faux_adjectives() {
  return _id->unique_faux_adjectives;
}
varargs string *query_adjectives( int no_faux ) {
  if( no_faux ||
      !sizeof( _id->unique_faux_adjectives ) ||
      !faux_id_allowed() )
    return _id->adjectives;
  else
    return _id->adjectives + _id->unique_faux_adjectives;
}
int id_adjective(string word) {
   return (member_array(word, query_adjectives()) != -1);
}
void set_plural_adjectives(string *str) {
   _id->plural_adjectives = str;
}
void add_plural_adjective(mixed str) {
   int i;
   if (pointerp(str)) {
      for (i = 0; i < sizeof(str); i++) {
         add_plural_adjective(str[i]);
      }
      return;
   }
   if (stringp(str)) {
      str = explode(str, " ");
   }
   for (i = 0; i < sizeof(str); i++) {
      if (member_array(str[i], _id->plural_adjectives) == -1) {
         _id->plural_adjectives += ({ str[i] });
      }
   }
}
void remove_plural_adjective(mixed str) {
   int i;
   if (pointerp(str)) {
      for (i = 0; i < sizeof(str); i++) {
         remove_plural_adjective(str[i]);
      }
   } else {
      if ((i = member_array(str, _id->plural_adjectives)) != -1) {
         _id->plural_adjectives = delete(_id->plural_adjectives, i, 1);
      }
   }
}
string *query_plural_adjectives() {
   return _id->plural_adjectives;
}
int id_plural_adjective(string word) {
   return (member_array(word, _id->plural_adjectives) != -1);
}
string *parse_command_id_list() {
   return ({ _id->name, file_name(this_object()) }) + query_alias();
}
string *parse_command_plural_id_list() {
   return query_plurals();
}
string *parse_command_adjectiv_id_list() {
   return query_adjectives();
}
string *parse_command_plural_adjectiv_id_list() {
   return query_plural_adjectives();
}
object query_parse_id(mixed *arr) {
   if (arr[P_THING] == 0) {
      return this_object();
   }
   if (arr[P_THING] < 0) {
      arr[P_THING]++;
      if (arr[P_THING] != 0) {
         return 0;
      }
      arr[P_THING] = -10321;
      return this_object();
   }
   arr[P_THING]--;
   if (arr[P_THING] != 0) {
      return this_object();
   }
   arr[P_THING] = -10101;
   return this_object();
}
object query_frac_parse_id(mixed *arr) {
   if (arr[P_THING] < 0) {
      arr[P_THING]++;
      if (arr[P_THING] != 0) {
         return 0;
      }
      arr[P_THING] = -10235;
      return 0;
   }
   if (arr[P_THING] == 0) {
      if ((arr[P_MAX_NUM] * arr[P_TOP]) / arr[P_BOT] > arr[P_CUR_NUM]++) {
         return this_object();
      } else {
         return 0;
      }
   }
   if ((arr[P_THING] * arr[P_TOP]) / arr[P_BOT] > arr[P_CUR_NUM]++) {
      return this_object();
   }
   return 0;
}

==================================================
FILE: basic/id_match.c
==================================================

#include <obj_parser.h>
private int _no_all;
protected void set_no_all(int no_all) {
   _no_all = no_all;
}
int query_no_all() {
   return _no_all;
}
protected int is_matching_object(string* input,
                          object viewer,
                          class obj_match_context context )
{
   string *adj;
   string *padj;
   string *names;
   string *pnames;
   int n;
   int ret;
   if( this_object() == context->him &&
       input[<1] == "him" ) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   } else if( this_object() == context->her &&
              input[<1] == "her" ) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   } else if( this_object() == context->it &&
              input[<1] == "it" ) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   } else if( context->plural &&
              input[<1] == "them" &&
              member_array( this_object(), context->plural ) != -1 ) {
      ret |= OBJ_PARSER_MATCH_PLURAL;
   } else if( this_object() == viewer &&
              input[<1] == "me" ) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   } else if (!_no_all && input[<1] == "all") {
      ret |= OBJ_PARSER_MATCH_PLURAL;
   } else if (!_no_all && (input[<1] == "things" || input[<1] == "ones")) {
      ret |= OBJ_PARSER_MATCH_PLURAL;
   } else if (!_no_all && (input[<1] == "thing" || input[<1] == "one")) {
      ret |= OBJ_PARSER_MATCH_SINGULAR;
   }
   if (!ret) {
      if (input[<1] == "here" &&
          viewer != environment() &&
          sizeof(input) > 1) {
         input = input[0..<2];
      }
      names = this_object()->parse_command_id_list();
      pnames = this_object()->parse_command_plural_id_list();
      if( member_array( input[<1], pnames ) != -1 ) {
         ret |= OBJ_PARSER_MATCH_PLURAL;
      }
      if( member_array( input[<1], names ) != -1 ) {
         ret |= OBJ_PARSER_MATCH_SINGULAR;
      }
      if (!ret) {
         return 0;
      }
   }
   adj = this_object()->parse_command_adjectiv_id_list();
   padj = this_object()->parse_command_plural_adjectiv_id_list();
   if( environment() == context->him ) {
      adj += ({ "his" });
   } else if( environment() == context->her ) {
      adj += ({ "her" });
   } else if( environment() == context->it ) {
      adj += ({ "its" });
   } else if( environment() == viewer ) {
      adj += ({ "my" });
   } else if( context->plural &&
                   member_array( environment(), context->plural ) != -1 ) {
      adj += ({ "their" });
   }
   for( n = 0; n < sizeof( input ) - 1; n++ )
   {
      if( member_array( input[n], adj ) == -1 ) {
         if (!padj || member_array(input[n], padj) == -1) {
            return 0;
         } else {
            ret &= ~OBJ_PARSER_MATCH_SINGULAR;
            ret |= OBJ_PARSER_MATCH_PLURAL;
         }
      }
   }
   return ret;
}
protected int update_parse_match_context(class obj_match_context context,
                                         int num,
                                         int singular) {
   if (context->ordinal) {
      if (context->ordinal == -1) {
         return 1;
      }
      if (context->ordinal > num) {
         context->ordinal -= num;
         return 0;
      }
      context->ignore_rest = 1;
      return 1;
   } else if (context->number_included) {
      if (context->number_included <= num) {
         context->ignore_rest = 1;
         num = context->number_included;
         context->number_included = 0;
         return num;
      }
      context->number_included -= num;
      return num;
   } else {
      if (num > 0 && (singular & OBJ_PARSER_MATCH_SINGULAR)) {
         return 1;
      }
      return num;
   }
}
mixed parse_match_object( string* input,
                          object viewer,
                          class obj_match_context context )
{
   int ret;
   ret = is_matching_object(input, viewer, context);
   if (!ret) {
      return 0;
   }
   if (!update_parse_match_context(context, 1, ret)) {
      return 0;
   }
   return ({ ret, ({ this_object() }) });
}

==================================================
FILE: basic/item_chat.c
==================================================

#include <room.h>
private nosave int _off, _already_added;
private nosave mixed *_chats;
void check_chat();
mixed *query_chats() { return _chats; }
void init() {
  check_chat();
}
void item_chat( mixed *args ) {
  if ( !args || sizeof(args) < 3 || !sizeof(args[2]) ){
    write( "Incorrect args to item_chat.\n" );
    return;
  }
  args = args - ({ 0 });
  args[2] = map( args[2],
        (: replace( $1, ({ "$a_short$", this_object()->a_short(),
                           "$the_short$", this_object()->the_short(),
                           "$poss_short$", this_object()->poss_short() }) ) :) );
  _off = 0;
  _chats = args + ({ 0 });
  check_chat();
}
void chat_on(){
   _off = 0;
   check_chat();
}
void chat_off(){
   _off = 1;
}
void make_chat(){
  int saying;
  string stuff;
  object env, *targets;
  _already_added = 0;
  if( !(env = environment()) || _off )
    return;
  saying = random( sizeof(_chats[ 2 ]) );
  if( saying == _chats[ 3 ] )
    saying = ( saying + 1 ) % sizeof( _chats[ 2 ] );
  _chats[ 3 ] = saying;
  stuff = _chats[ 2 ][ saying ];
  if( env->query_is_room() ||
      ( interactive(env) && (env = environment(env)) && env->query_is_room() ) ){
    targets = filter( all_inventory(env), (: interactive($1) :) );
    if( !sizeof(targets) )
      return;
    if( stuff[0..0] == "#" )
      call_other( this_object(), stuff[ 1 .. ] );
    else
      tell_room( env, stuff + "\n" );
    _already_added = 1;
    ROOM_HANDLER->add_chatter( this_object(), _chats[ 0 ] +
                               random( _chats[ 1 ] - _chats[ 0 ] + 1 ) );
  }
}
void check_chat(){
  if( !_off && !_already_added && arrayp(_chats) && environment() ){
    if( interactive(environment()) ||
          ( environment(environment()) &&
            interactive(environment(environment()))
          )
       ){
           _already_added = 1;
           ROOM_HANDLER->add_chatter( this_object(),
           ( _chats[ 0 ] + random( _chats[ 1 ] - _chats[ 0 ] + 1 ) ) / 2 );
        }
  }
}
mapping query_dynamic_auto_load() {
   return ([ "_off"  : _off,
            "_chats" : _chats
          ]);
}
string fix_saved_chat( string chat ){
  string old_ob;
  if( !chat )
    return 0;
  sscanf( chat, "%*s$%*s_short:%s$%*s", old_ob );
  if( old_ob )
    chat = replace( chat, old_ob, file_name(this_object()) );
  return chat;
}
void init_dynamic_arg( mapping map ) {
  mixed info;
  if( !map )
    return;
  if( (info = map["_chats"]) && arrayp(info) && sizeof(info) > 2 ){
    info[2] = map( info[2], "fix_saved_chat", this_object() );
    item_chat( info );
  }
  if( !(_off = map["_off"]) )
    chat_on();
  else
    chat_off();
}

==================================================
FILE: basic/light.c
==================================================

private nosave int _light;
private nosave int _my_light;
private nosave int _need_recalculate;
private nosave object *_inform_of_change;
void new_recalc_light();
mixed query_property(string name);
void add_property(string name, mixed value);
void remove_property(string name);
void create() {
    _inform_of_change = ({ });
}
int query_light() {
    if (_need_recalculate) {
        _need_recalculate = 0;
        new_recalc_light();
    }
    return _light;
}
int query_light_needs_inform() {
    return _light || _need_recalculate;
}
int query_my_light() { return _my_light; }
varargs void new_recalc_light() {
    object *obs;
    object ob;
    int tmp_light;
    _need_recalculate = 0;
    _light = _my_light * _my_light;
    if (_my_light < 0)  _light = -_light;
    if ( !this_object()->query_opaque() ) {
        obs = all_inventory(this_object());
        foreach (ob in obs) {
            if (ob->query_opaque()) {
                tmp_light = ob->query_my_light();
            } else {
                tmp_light = ob->query_light();
            }
            if (tmp_light >= 0)  _light += tmp_light * tmp_light;
            else  _light -= tmp_light * tmp_light;
        }
    }
    if (_light >= 0)  _light = sqrt(_light);
    else  _light = -sqrt(-_light);
    _inform_of_change->event_light_change(this_object(), 0, _light);
}
void light_level_changed() {
    _need_recalculate = 1;
}
void inform_of_light_level_change(object ob) {
    if (ob) {
        ob->light_level_changed();
    }
    while (ob && !ob->query_opaque()) {
        ob->light_level_changed();
        ob = environment(ob);
    }
}
void add_inform_light_change(object ob) {
    _inform_of_change += ({ ob });
}
void remove_inform_light_change(object ob) {
    _inform_of_change -= ({ ob });
}
void set_opaque() {
    add_property( "opaque", 1 );
}
void reset_opaque() {
    remove_property( "opaque" );
}
int query_opaque() {
    return query_property("opaque");
}
int adjust_light( int number ) {
    if (number) {
        _my_light += number;
        inform_of_light_level_change(this_object());
    }
    return _light;
}
int set_light(int number) {
    return adjust_light(number - _my_light);
}
mixed *stats() {
    return ({
      ({ "light", _light, }),
      ({ "my light", _my_light, }),
    });
}

==================================================
FILE: basic/misc.c
==================================================

#include <money.h>
#include <move_failures.h>
#define WATCH_DEFINE "fluff'n'stuff"
#define PRICE_INDEX "/obj/handlers/cpi_handler"
inherit "/std/basic/light";
inherit "/std/basic/consecrate";
inherit "/std/basic/move";
nosave int weight;
nosave int length = 1;
nosave int width = 1;
nosave int value;
nosave mapping value_info;
void check_log_status( object *parray );
void create() {
  weight = 1;
  light::create();
  if(this_object()->query_property(WATCH_DEFINE))
    call_out( "check_log_status", 1, previous_object(-1) );
  value_info = ([ ]);
}
void set_width(int w) { width = w; }
int query_width() { return width; }
void set_length(int l) { length = l; }
int query_length() { return length; }
void adjust_weight(int w) {
    if (environment()) {
        environment()->add_weight(w);
    }
    weight += w;
}
void set_weight(int w) {
    if (environment())
        environment()->add_weight(w-weight);
    weight = w;
}
int query_weight() { return weight; }
int query_complete_weight() { return (int)this_object()->query_weight(); }
varargs int adjust_money(mixed amt, string coin) {
    if (pointerp(amt)) {
        value += (int)MONEY_HAND->query_total_value(amt);
        if (value < 0) {
            value = 0;
        }
        return value;
    }
    amt = (int)MONEY_HAND->query_total_value( ({ coin, amt }) );
    value += amt;
    if (value < 0) {
        value = 0;
    }
    return value;
}
int adjust_value(int i) {
    value += i;
    return value;
}
mixed *query_money_array() {
    return (mixed *)MONEY_HAND->create_money_array(value);
}
int query_money(string type) {
    int i;
    mixed *m_a;
    m_a = (mixed *)MONEY_HAND->create_money_array(value);
    i = member_array(type, m_a);
    if (i == -1) {
        return 0;
    }
    return m_a[i+1];
}
void set_value( int number ) { value = number; }
void set_value_info( string word, int number ) {
    value_info[ word ] = number;
}
void remove_value_info( string word ) {
    if ( undefinedp( value_info[ word ] ) )
        return;
    value_info = m_delete( value_info, word );
}
int query_value() { return value; }
int query_base_value() {
   return value;
}
mapping query_value_info() { return value_info; }
int query_value_at( object place ) {
    int i, total;
    string *info;
    mixed how;
    if ( !value_info ) {
        value_info = ([ ]);
    }
    total = (int)this_object()->query_value();
    info = m_indices( value_info );
    for ( i = 0; i < sizeof( info ); i++ ) {
        how = (mixed)place->query_property( info[ i ] +" valued" );
        if ( how ) {
            switch ( info[ i ] ) {
            case "artifact" :
                total += ( value_info[ "artifact" ] * ( how[ 0 ] +
                    how[ 1 ] * (int)this_object()->query_charges() ) ) / how[ 2 ];
                break;
            case "enchantment" :
                if ( this_object()->query_max_enchant() )
                    total += ( value_info[ "enchantment" ] * how *
                      (int)this_object()->query_enchant() ) /
                    (int)this_object()->query_max_enchant();
                break;
            case "material" :
                total += (int)this_object()->query_weight() *
                (int)PRICE_INDEX->query_price( (string)this_object()->
                  query_material(), how );
                break;
            default :
                total += value_info[ info[ i ] ];
            }
        }
    }
    return total;
}
int query_value_real(string place) {
   int i;
   int total;
   string *info;
   if ( !value_info ) {
      value_info = ([ ]);
   }
   total = (int)this_object()->query_value();
   info = m_indices( value_info );
   for ( i = 0; i < sizeof( info ); i++ ) {
      switch ( info[ i ] ) {
      case "artifact" :
         total += ( value_info[ "artifact" ] * ( 3 +
             1 * (int)this_object()->query_charges() ) ) / 1;
         break;
      case "enchantment" :
         if ( this_object()->query_max_enchant() )
             total += ( value_info[ "enchantment" ] * 10 *
               (int)this_object()->query_enchant() ) /
             (int)this_object()->query_max_enchant();
         break;
      case "material" :
         total += (int)this_object()->query_weight() *
         (int)PRICE_INDEX->query_price( (string)this_object()->
           query_material(), place );
         break;
      default :
         total += value_info[ info[ i ] ];
         break;
      }
   }
   return total;
}
varargs int move( mixed dest, string messin, string messout ) {
  int i, w;
  object from;
  if( stringp(dest) ) {
   if ( strsrch( dest , "#") != -1 )
     dest = find_object(dest);
   else
     dest = load_object(dest);
  }
  if(!dest)
    return MOVE_INVALID_DEST;
  w = (int)this_object()->query_complete_weight();
  if(!(dest->add_weight(w)))
    return MOVE_TOO_HEAVY;
  from = environment();
  i = ::move(dest, messin, messout);
  if(i != MOVE_OK) {
    dest->add_weight(-w);
    return i;
  }
  if(from)
    from->add_weight(-w);
  if(query_light_needs_inform()) {
    if(from)
      inform_of_light_level_change(from);
    inform_of_light_level_change(dest);
  }
  return i;
}
void dest_me() {
    if ( environment() ) {
        environment()->add_weight( -(int)this_object()->query_complete_weight() );
        if ( query_my_light() )
            adjust_light( -query_my_light() );
    }
    ::dest_me();
}
mixed *stats() {
    int i;
    string *info;
    mixed *guff;
    guff = ({ ({ "value", value }) });
    if ( !value_info )
        value_info = ([ ]);
    info = m_indices( value_info );
    for ( i = 0; i < sizeof( info ); i++ )
        guff += ({ ({ "(info) "+ info[ i ], value_info[ info[ i ] ] }) });
    return light::stats() + consecrate::stats() + guff;
}
void check_log_status( object *parray ) {
  if ( this_object()->query_property( WATCH_DEFINE ) &&
       clonep( this_object() ) &&
       arrayp( parray ) &&
       member_array(load_object("/secure/cmds/creator/cl_one"), parray) != -1){
    log_file( "WATCH", "%s TO: %s. TP: %s.\n", ctime(time()),
              base_name( this_object() ), parray[2]->query_name() );
    this_object()->add_property( "CT", time() );
    user_event( "inform", sprintf( "[Restricted] %s cloned %s.",
                                   parray[2]->query_cap_name(),
                                   base_name( this_object() ) ), "cheat" );
  }
}

==================================================
FILE: basic/move.c
==================================================

#include <move_failures.h>
#define DROP 1
#define GET 2
private int move_flag;
varargs int move( mixed dest, string messin, string messout ) {
   object prev;
   if ( !objectp( dest ) ) {
      if ( !stringp( dest ) || !( dest = find_object( dest ) ) ) {
         return MOVE_EMPTY_DEST;
      }
   }
   if ( !dest->test_add( this_object(), this_object()->get(dest) ) ) {
      return MOVE_NO_GET;
   }
   if(dest == this_object()) {
      return MOVE_INVALID_DEST;
   }
   prev = environment();
   if ( prev ) {
      if ( !prev->test_remove( this_object(),
                               this_object()->drop(dest),
                               dest ) ) {
         return MOVE_NO_DROP;
      } else if (prev != find_object("/room/virtual")) {
         event( prev, "exit", messout, dest );
      }
   }
   if (dest != environment()) {
      if( environment() )
        this_object()->remove_property( "there" );
      move_object (dest);
      this_object()->event_move_object( prev, dest );
   }
   if (!(dest == find_object("/room/rubbish") || dest == find_object("/room/virtual"))) {
      event( dest, "enter", messin, prev );
   }
   this_object()->remove_hide_invis( "concealed" );
   this_object()->remove_hide_invis( "secreted" );
   return MOVE_OK;
}
void reset_get() { move_flag |= GET; }
void set_get() { move_flag &= ~GET; }
void reset_drop() { move_flag |= DROP; }
void set_drop() { move_flag &= ~DROP; }
void dest_me() {
   if ( environment() ) {
      event( environment(), "dest_me" );
   }
   this_object()->event_destruct();
   efun::destruct( this_object() );
}
nomask mixed dwep() {
   efun::destruct( this_object() );
   return "Destructed With Extreme Prejudice";
}
int drop( mixed dest ) { return move_flag & DROP; }
int get( mixed dest ) { return move_flag & GET; }
void set_move_flag( int i ) { move_flag = i; }

==================================================
FILE: basic/print_object.c
==================================================

varargs string print_object(mixed ob, int off) {
  int i;
  write("                   "[0..off]);
  if (intp(ob)) {
    write(ob+"\n");
    return "int";
  }
  if (stringp(ob)) {
    write("\""+ob+"\"\n");
    return "string";
  }
  if (objectp(ob)) {
    write(file_name(ob)+"  ");
    if (ob->short())
      write("(short) "+ob->short()+"\n");
    else if (ob->query_name())
      write("(name)  "+ob->query_name()+"\n");
    else
      write("(Argghhhh)\n");
    return "object";
  }
  if (pointerp(ob)) {
    if (!sizeof(ob))
      write("({ })\n");
    else {
      write("({  -- size "+sizeof(ob)+"\n");
      for (i=0;i<sizeof(ob);i++)
        print_object(ob[i], off+3);
      write("                       "[0..off]+"})\n");
    }
    return "pointer";
  }
  return "oh dear";
}

==================================================
FILE: basic/property.c
==================================================

mapping map_prop;
mapping timed_properties;
mapping property_stats;
void create() {
}
varargs int add_property(string var, mixed val, int tim) {
  if (!stringp(var))
    return 0;
  if (!map_prop)
    map_prop = ([ ]);
  map_prop[var] = val;
  if (tim > 0) {
    if (!timed_properties)
      timed_properties = ([ ]);
    timed_properties[var] = tim + time();
  }
#ifdef TRACK_PROPERTY_STATS
  if (!property_stats)
    property_stats = ([ ]);
  if (previous_object())
    property_stats[var] = ({ file_name( previous_object() ), time(), tim });
  else
    property_stats[var] = ({ "No previous object.", time(), tim });
#endif
  return 1;
}
int remove_property(string var) {
  if (map_prop)
    map_delete(map_prop, var);
  if (timed_properties)
    map_delete(timed_properties, var);
#ifdef TRACK_PROPERTY_STATS
  if (property_stats)
    map_delete(property_stats, var);
#endif
  return 1;
}
mixed query_property(string str) {
  if (!map_prop)
    return ([ ])["bing"];
  if (timed_properties && timed_properties[str] &&
      timed_properties[str] < time()) {
    map_delete(timed_properties, str);
    map_delete(map_prop, str);
#ifdef TRACK_PROPERTY_STATS
    if(property_stats)
      map_delete(property_stats, str);
#endif
    return map_prop[str];
  }
  return map_prop[str];
}
int query_is_timed_property(string str) {
  if (timed_properties && timed_properties[str]) {
    if (timed_properties[str] < time()) {
      map_delete(timed_properties, str);
      map_delete(map_prop, str);
#ifdef TRACK_PROPERTY_STATS
      map_delete(property_stats, str);
#endif
      return 0;
    }
    return 1;
  }
  return 0;
}
int query_property_time_left(string str) {
  if (timed_properties &&
      timed_properties[str]) {
    if (timed_properties[str] < time()) {
      map_delete(timed_properties, str);
      map_delete(map_prop, str);
#ifdef TRACK_PROPERTY_STATS
      map_delete(property_stats, str);
#endif
      return 0;
    }
    return timed_properties[str] - time();
  }
  return 0;
}
int query_property_exists(string str) {
  if (!map_prop)
    return 0;
  if (timed_properties &&
      timed_properties[str] &&
      timed_properties[str] < time()) {
    map_delete(timed_properties, str);
    map_delete(map_prop, str);
#ifdef TRACK_PROPERTY_STATS
    map_delete(property_stats, str);
#endif
    return map_prop[str];
  }
  return !undefinedp(map_prop[str]);
}
mapping query_properties() {
  if (map_prop)
    return map_prop ;
  return ([ ]);
}
mapping query_timed_properties() {
  if (timed_properties)
    return timed_properties;
  return ([ ]);
}
void add_properties(mapping map) {
  if (!map_prop)
    map_prop = map;
  else
    map_prop += map;
}
void set_properties(mapping map) {
  map_prop = map;
}
protected void save_player_properties() {
  string prop;
  if(timed_properties)
    foreach(prop in keys(timed_properties))
      if(timed_properties[prop] < time())
        map_delete(timed_properties, prop);
      else
        timed_properties[prop] -= time();
}
protected void reload_player_properties() {
  string prop;
  if (timed_properties)
    foreach(prop in keys(timed_properties))
      if(!map_prop[prop])
        map_delete(timed_properties, prop);
      else
        timed_properties[prop] += time();
}
mixed stats() {
  int i, bing;
  mixed *k, *v, *res;
  mapping props;
  props = (mapping)this_object()->query_properties();
  if ( !props )
    return ({ });
  k = keys( props );
  v = values( props );
  res = ({ });
  for ( i = sizeof( k ) - 1; i > -1; i-- ) {
    bing = 0;
    if (timed_properties &&
        timed_properties[ k[ i ] ] &&
        timed_properties[ k[ i ] ] < time()) {
      map_delete(timed_properties, k[ i ]);
      map_delete(map_prop, k[ i ]);
#ifdef TRACK_PROPERTY_STATS
      if(property_stats)
        map_delete(property_stats, k[i]);
#endif
      continue;
    }
    if (timed_properties &&
        timed_properties[ k[ i ] ]) {
      bing = timed_properties[ k[ i ] ] - time();
    }
    if ( !stringp( k[ i ] ) || k[ i ][ 0 .. 3 ] == "news" ||
         k[ i ] [ 0 ] == '.' )
      continue;
    if ( pointerp( v[ i ] ) ) {
      res += ({ ({ "(" + k[ i ] + (bing ? ":"+bing : "") + ")",
                     array_to_string( v[ i ] ) }) });
      continue;
    }
    if ( mapp( v[ i ] ) ) {
      res += ({ ({ "(" + k[ i ] + (bing ? ":"+bing : "") + ")",
                     mapping_to_string( v[ i ] ) }) });
      continue;
    }
    res += ({ ({ "("+ k[ i ] + ( bing ? ":"+ bing : "" ) +")",
                   v[ i ] }) });
  }
  return res;
}
#ifdef TRACK_PROPERTY_STATS
mixed query_property_stats( string var ) {
  if (!property_stats || undefinedp( property_stats[var] ) )
    return ({ });
  return property_stats[ var ];
}
mapping query_stats() {
  mixed property1, property2;
  if (!property_stats)
    return ([ ]);
  foreach( property1, property2 in property_stats )
    if(undefinedp(map_prop[property1]) &&
       undefinedp(timed_properties[property1]))
      map_delete(property_stats, property1);
  return property_stats;
}
#endif

==================================================
FILE: basic/read_desc.c
==================================================

#include <language.h>
#include <nroff.h>
inherit "/std/basic/desc";
private nosave mixed *_read_mess = ({ });
private nosave int _max_size = 100;
private nosave int _cur_size;
varargs mixed add_read_mess(mixed str, string type, string lang, int size);
mixed query_property(string name);
void set_max_size(int siz) { _max_size = siz; }
int query_max_size() { return _max_size; }
void set_cur_size(int siz) { _cur_size = siz; }
int query_cur_size() { return _cur_size; }
varargs void set_read_mess(mixed str, string lang, int size) {
   if ( pointerp( str ) ) {
      _read_mess = str;
      return;
   }
  if (!lang)
    return;
  if (!size)
    size = 1;
  if ( str )
    _read_mess = ({ ({ str, 0, lang, size }) });
  else
    _read_mess = ({ });
}
mixed *query_read_mess() { return copy( _read_mess ); }
varargs mixed add_read_mess(mixed str, string type, string lang, int size) {
  int de_size;
  if (_cur_size >= _max_size) {
     return "";
  }
  if (!size) {
    size = 1;
  }
  de_size = size*((int)LANGUAGE_HAND->query_language_size(lang, str));
  if (_cur_size+de_size > _max_size) {
    str = (string)LANGUAGE_HAND->squidge_text(lang, str,
                                              (_max_size-_cur_size)/size);
    if (!strlen(str))
      return ;
    _cur_size += size*((int)LANGUAGE_HAND->query_language_size(lang, str));
  }
  _read_mess += ({ ({ str, type, lang, size }) });
  return str;
}
int remove_read_mess(string str, string type, string lang) {
  int i;
  for (i=0;i<sizeof(_read_mess);i++) {
    if (str && _read_mess[i][READ_STR] != str)
      continue;
    if (type && _read_mess[i][READ_TYPE] != type)
      continue;
    if (lang && _read_mess[i][READ_LANG] != lang)
      continue;
    _cur_size -= _read_mess[i][READ_SIZE]
                *((int)LANGUAGE_HAND->query_language_size(lang,
                                                    _read_mess[i][READ_STR]));
    _read_mess = _read_mess[0..i - 1] + _read_mess[i + 1..];
    return 1;
  }
  return 0;
}
string query_readable_message(object player, int ignore_labels) {
  string message;
  string file;
  string type;
  string lang;
  mixed mess;
  mixed *bit;
  mixed *read_mess;
  int pos;
  if(!player)
    player = this_player();
  read_mess = query_read_mess();
  if ( !sizeof( read_mess ) ) {
    return 0;
  }
  message = "";
  foreach ( bit in read_mess ) {
    mess = bit[ READ_MESS ];
    type = bit[ READ_TYPE ];
    lang = bit[ READ_LANG ];
    if ( functionp( mess ) ) {
      mess = evaluate( mess );
    }
    if ( stringp( mess ) ) {
      if ( sscanf( mess, "$$%s$$", file ) ) {
        mess = unguarded( (: read_file, file +".txt" :) );
        if ( !mess ) {
          mess = unguarded( (: NROFF_HAND->cat_file($(file)+"_nroff", 1) :) );
          if(!mess) {
            unguarded((: NROFF_HAND->create_nroff($(file),
                                                  $(file)+"_nroff") :));
            mess = unguarded((: NROFF_HAND->cat_file($(file)+"_nroff", 0) :));
            if(!mess)
              mess = "Warning: text file cannot be read!";
          }
        }
      }
    }
    mess = LANGUAGES->garble_text(lang, mess, this_object(), player);
#ifdef DISABLED
    if (stringp(mess)) {
      pos = strsrch(mess, "Written in ");
      while (pos != -1) {
        if ((pos == 0 && !type) || (pos > 0 && mess[pos-1] == '\n')) {
          mess = mess[0..pos-1] + "---> " + mess[pos..pos + 4] + " " +
            mess[pos + 5..];
        } else {
          mess = mess[0..pos + 4] + " " +
            mess[pos + 5..];
        }
        pos = strsrch(mess[pos + 5..], "Written in ");
      }
    }
#endif
    if ( !LANGUAGES->query_language_magic( lang ) ) {
      if ( !type && player && (lang == player->query_default_language())) {
        mess += "\n";
      } else {
        if (stringp(lang)) {
          mess = "Written"+ ( type ? " in "+ type : "" ) +
            ( lang != "general" ? " in "+ capitalize(lang) : "" ) +
            ": "+ mess +"\n";
        } else {
          mess = "Written in some weird broken language: " + mess + "\n";
        }
      }
    }
    message += mess;
  }
  return message;
}
string query_read_short(object player, int ignore_labels) {
   string id;
   string *read_mess;
   read_mess = query_read_mess();
   if ( !arrayp(read_mess) || !sizeof( read_mess ) ) {
      return 0;
   }
   id = query_property("read id");
   if (id) {
      id += " $name$";
   } else {
      id = "$name$";
   }
   return id;
}

==================================================
FILE: basic/repeater.c
==================================================

private nosave object _repeater;
void set_repeater_owner(object owner) {
   _repeater = owner;
}
object query_repeater_owner() {
   return _repeater;
}
void repeat_event_person_say(object caller,
                             object ob,
                             string start,
                             string mess,
                             string lang) {
}
void event_person_say(object ob, string start, string mess, string lang) {
   if (_repeater) {
      _repeater->repeat_event_person_say(this_object(),
                                         ob,
                                         start,
                                         mess,
                                         lang);
   }
}
void repeat_event_emote(object caller,
                        object ob,
                        string mess) {
}
void event_emote( object ob, string mess ) {
   if (_repeater) {
   _repeater->repeat_event_emote(this_object(),
                                 ob,
                                 mess);
   }
}
void repeat_event_say(object caller,
                      object ob,
                      string mess,
                      object *avoid) {
}
void event_say(object ob, string str, mixed avoid) {
   if (_repeater) {
      _repeater->repeat_event_say(this_object(),
                                  ob,
                                  str,
                                  avoid);
   }
}
void repeat_event_soul(object caller,
                       object ob,
                       string mess,
                       object *avoid) {
}
void event_soul(object ob, string str, mixed avoid) {
   if (_repeater) {
      _repeater->repeat_event_soul(this_object(),
                                  ob,
                                  str,
                                  avoid);
   }
}
void repeat_event_enter(object caller,
                        object ob,
                        string mess,
                        object prev) {
}
void event_enter( object thing,
                  string mess,
                  object prev ) {
   if (_repeater) {
      _repeater->repeat_event_enter(this_object(),
                                    thing,
                                    mess,
                                    prev);
   }
}
void repeat_event_exit(object caller,
                       object ob,
                       string mess,
                       object dest) {
}
void event_exit( object thing,
                 string mess,
                 object dest ) {
   if (_repeater) {
      _repeater->repeat_event_enter(this_object(),
                                    thing,
                                    mess,
                                    dest);
   }
}

==================================================
FILE: basic/scroll_base.c
==================================================

#include <tasks.h>
inherit "/std/basic/scroll_book_react";
#define SKILL "magic.items.scroll"
#define CONTROL_SKILL "magic.spells.special"
private string _spell;
string long( string word, int dark ) {
   int i;
   int j;
   int chance;
   int level;
   int width;
   string spell_name;
   level = 2 * (int)_spell->query_power_level();
   width = sqrt( level );
   chance = (int)this_player()->query_skill_bonus( SKILL ) - ( level - width );
   chance = ( 100 * chance ) / ( 2 * width + 1 );
   spell_name = "$"+ (string)_spell->query_name() +"$";
   j = strlen( spell_name ) - 1;
   for ( i = 1; i < j; i++ ) {
      if ( random( 100 ) > chance ) {
         switch ( spell_name[ i ] ) {
            case 32 :
               break;
            case 65 .. 90 :
               spell_name = spell_name[ 0 .. i - 1 ] +
                     sprintf( "%c", 65 + random( 26 ) ) +
                     spell_name[ i + 1 .. j ];
               break;
            case 97 .. 122 :
               spell_name = spell_name[ 0 .. i - 1 ] +
                     sprintf( "%c", 97 + random( 26 ) ) +
                     spell_name[ i + 1 .. j ];
               break;
            default :
               spell_name = spell_name[ 0 .. i - 1 ] +
                     spell_name[ i + 1 .. j ];
               j--;
         }
      }
   }
   spell_name = spell_name[ 1 .. j - 1 ];
   return spell_name;
}
int query_magic_scroll() { return 1; }
int query_binding_force() { return 5; }
string query_spell() { return _spell; }
int query_spell_power_level() {
   if (_spell) {
      return _spell->query_power_level();
   }
}
void set_spell( string word ) { _spell = word; }
string query_spell_name() { return (string)_spell->query_name(); }
int test_skill() {
   int level;
   level = 2 * (int)( _spell->query_power_level() ) + 1;
   return (int)TASKER->perform_task(this_player(), SKILL, level, TM_FREE);
}
void clear_spell( int award ) {
   if ( award ) {
     write( "%^YELLOW%^"+ ({ "A piece of lore concerning scrolls becomes "
             "clearer for you", "You manage to grasp one of the principles "
             "of magic scrolls more firmly", "A sudden flash of insight "
             "allows you to understand process of casting a spell from a "
             "scroll a little better" })[ random( 3 ) ] +".%^RESET%^\n" );
   }
}
int cast_spell( string words ) {
   int outcome;
   if ( !words ) {
      words = "";
   }
   outcome = test_skill();
   if ( outcome == FAIL ) {
      return notify_fail( "You can't figure out how to use the scroll.\n" );
   }
   if ( !( _spell->cast_spell( words, 1 ) ) ) {
      return 0;
   }
   clear_spell( outcome == AWARD );
   return 1;
}
int cast_spell_new( string words , object* targets, object* using ) {
   int outcome;
   if ( !words ) {
      words = "";
   }
   outcome = test_skill();
   if ( outcome == FAIL ) {
      return notify_fail( "You can't figure out how to use the scroll.\n" );
   }
   if ( !( _spell->cast_spell_new( words, 1, targets, using ) ) ) {
      return 0;
   }
   clear_spell( outcome == AWARD );
   return 1;
}
string query_death_reason() {
   return " a spell going wild and getting out of control.";
}

==================================================
FILE: basic/scroll_book_react.c
==================================================

#include <tasks.h>
#define SKILL "magic.items.scroll"
#define CONTROL_SKILL "magic.spells.special"
void destroy_this_scroll() {
}
void check_react(object player) {
   object ob;
   int level;
   int ac;
   string check_spell;
   object paper;
   object *items;
   object env;
   if (!environment(player)) {
      return;
   }
   env = environment(player);
   while (env && !living(env)) {
      env = environment(env);
   }
   if (env && !userp(env) && !env->query_owner()) {
      return ;
   }
   items = filter(deep_inventory(environment(player)),
                  (: $1->query_magic_scroll() ||
                     $1->query_spell_book() :));
   foreach (paper in items) {
      level += paper->query_spell_power_level();
   }
   if (random(sqrt(level)) <= 5 + random(5)) {
      return;
   }
   ob = environment(player);
   while(ob) {
      if(living(ob)) {
         break;
      } else {
         ob = environment(ob);
      }
   }
   if(!ob || !living(ob)) {
      return;
   }
   if(ob) {
      switch(TASKER->perform_task(ob, CONTROL_SKILL, level*2 + random(4),
                                  TM_FREE)) {
      case AWARD:
         tell_object(ob, "Suddenly the spell "+
                      this_object()->query_spell_name()+ " on the "+
                     player->the_short()+" gets out of control and tries to go "
                     "wild.\n");
         tell_room(environment(ob), "Suddenly " + ob->one_short() +
                   " looks very startled as the spell " +
                   this_object()->query_spell_name() +
                   " on "+player->the_short()+" gets out of control and "
                   "tries to go wild.\n", ob);
         write("%^YELLOW%^You feel you have a better grasp of controlling "
               "spells on scrolls.\n.%^RESET%^\n" );
      case SUCCEED:
         return;
      default:
         tell_object(ob, "Suddenly the spell " +
                     this_object()->query_spell_name() + " on the "+
                     player->the_short() +
                     " gets out of control and tries to go wild.\n");
         tell_room(environment(ob), "Suddenly " + ob->one_short() +
                   " looks very startled as the spell " +
                   this_object()->query_spell_name() +
                   " on " + player->the_short() + " gets out of control and "
                   "tries to go wild.\n", ob);
         tell_object(ob, "Unfortunately you cannot get control of it and "
                     "before flying away into nowhere it tears wildly at "
                     "your mind.\n");
         tell_room(environment(ob), "Unfortunately "+ob->one_short()+" cannot "
                   "get control of it and it flies away to freedom.\n", ob);
         ac = (int)ob->query_ac("magic", level * 10);
         level -= ac;
         ob->adjust_hp(-level, this_object());
         ob->adjust_tmp_int(-2 + random(2));
         destroy_this_scroll();
         break;
      }
   }
}
string query_death_reason() {
   return " a spell going wild and getting out of control.";
}

==================================================
FILE: basic/setup.c
==================================================

private int _do_setup;
protected void inc_setup() {
   _do_setup++;
}
protected void dec_setup() {
   _do_setup--;
}
protected void do_setup() {
   if (!_do_setup) {
      this_object()->setup();
   }
}
protected void do_reset() {
   if (!_do_setup) {
      this_object()->reset();
   }
}

==================================================
FILE: basic/stat_adjustments.c
==================================================

#include <effects/stat_adjustment.h>
private nosave mapping _adjs;
void create() {
   _adjs = ([ ]);
}
void set_stat_adjustment(object player, mapping adjs) {
   _adjs[player] = adjs;
   player->add_effect(STAT_ADJUSTMENT_EFFECT, ({ this_object(), adjs }));
}
void remove_stat_adjustment(object player) {
   STAT_ADJUSTMENT_EFFECT->remove_stat_adjustment_ob(player, this_object());
   map_delete(_adjs, player);
}
void remove_all_stat_adjustments() {
   mapping adj;
   object play;
   foreach (play, adj in _adjs) {
      STAT_ADJUSTMENT_EFFECT->remove_stat_adjustment_ob(play, this_object());
      map_delete(_adjs, play);
   }
   _adjs = ([ ]);
}
mapping query_stat_adjustments(object play) {
   return _adjs[play];
}

==================================================
FILE: basic/surface.c
==================================================

#include <surface.h>
nosave object *surface_shadows;
object *query_surface_shadows() {
   return surface_shadows;
}
void make_shadow( object thing ) {
  object shadow;
  shadow = clone_object( SURFACE_SHADOW );
  shadow->setup_shadow( thing, this_object() );
  if ( !surface_shadows ) surface_shadows = ({ });
  surface_shadows += ({ shadow });
}
void check_shadows() {
  int i;
  for ( i = 0; i < sizeof( surface_shadows ); i++ ) {
    if ( surface_shadows[ i ] ) {
      if ( environment() == (object)surface_shadows[ i ]->
          query_shadowed( surface_shadows[ i ] ) ) {
        surface_shadows[ i ]->destruct_shadow( surface_shadows[ i ] );
        surface_shadows = surface_shadows[0..i-1] + surface_shadows[i + 1..];
        i--;
      }
    } else {
      surface_shadows = surface_shadows[0..i-1] + surface_shadows[i + 1..];
      i--;
    }
  }
  call_out( "check_environment", 0 );
}
void check_environment() {
  if ( environment() ) {
     make_shadow( environment() );
  }
}
void dest_me() {
  int i;
  for ( i = 0; i < sizeof( surface_shadows ); i++ )
    if ( surface_shadows[ i ] )
      surface_shadows[ i ]->destruct_shadow( surface_shadows[ i ] );
}

==================================================
FILE: basic/theft_callback.c
==================================================

class theft_callback {
     string func_name;
     string path;
}
class theft_callback *calls = ({ });
void event_theft( object command_ob, object thief, object victim,
                  object *stolen ) {
  if ( !sizeof( calls ) )
    return;
  if ( !stolen ) {
    foreach( class theft_callback temp in calls ) {
      if ( stringp( temp->path ) && stringp( temp->func_name ) )
        call_other( temp->path, temp->func_name, this_object(), thief, victim );
    }
  }
  return;
}
int add_theft_callback( string func_name, string path ) {
class theft_callback temp = new( class theft_callback, func_name: func_name,
  path: path );
  if ( !stringp( func_name ) || !stringp( path ) )
    return -1;
  debug_printf( "Added theft callback: %s %s.\n", func_name, path );
  calls += ({ temp });
  return sizeof( calls ) - 1;
}
int remove_theft_callback( int id ) {
  if ( id >= sizeof( calls ) || id < 0 )
    return -1;
  debug_printf( "Deleting callback: %s %s.\n", calls[id]->func_name,
    calls[id]->path );
  calls -= ({ calls[id] });
  return 1;
}
string query_theft_callbacks() {
string ret = "";
int count = 0;
  if ( !sizeof( calls ) )
    return "No theft callbacks found!\n";
  foreach( class theft_callback temp in calls ) {
    ret += sprintf( "%d. %s: %s.\n", count, temp->func_name, temp->path );
    count++;
  }
  return ret;
}

==================================================
FILE: basic/trap.c
==================================================

#include <tasks.h>
#define SKILL "covert.lockpick.traps"
private nosave int _trap_difficulty;
private nosave string _trap_trigger;
private nosave string _trap_description;
private nosave mixed _trap_message;
private nosave mixed _trap_effect;
private nosave mixed _trap_armed;
void setup_trap(int difficulty, string trigger, string description,
                     mixed message, mixed effect) {
  if(!trigger)
    return;
  if(trigger == "open")
    this_object()->set_open_trap(this_object(), "basic_trap");
  else
    this_object()->set_lock_trap(this_object(), "basic_trap");
  _trap_difficulty = difficulty;
  _trap_trigger = trigger;
  _trap_description = description;
  _trap_message = message;
  _trap_effect = effect;
}
mixed *query_trap_data() {
  return ({ _trap_difficulty, _trap_trigger, _trap_description,
              _trap_message, _trap_effect, _trap_armed });
}
int query_trap_difficulty() { return _trap_difficulty; }
string query_trap_trigger() { return _trap_trigger; }
string query_trap_description() { return _trap_description; }
mixed query_trap_message() { return _trap_message; }
mixed query_trap_effect() { return _trap_effect; }
void set_trap_armed(int i) { _trap_armed = i; }
int query_trap_armed() { return _trap_armed; }
int basic_trap(string action) {
  if(!_trap_armed || action != _trap_trigger)
    return 1;
  switch(TASKER->perform_task(this_player(), SKILL, _trap_difficulty,
                              TM_FREE)) {
  case AWARD:
    write("%^YELLOW%^You feel you have learned something about avoiding "
          "traps.%^RESET%^\n");
  case SUCCEED:
    return 1;
  default:
    if(arrayp(_trap_message)) {
      write(_trap_message[0]);
      say(_trap_message[1], this_player());
    } else
      write(_trap_message);
    if(intp(_trap_effect)) {
      if(_trap_effect > this_player()->query_hp())
        this_player()->do_death();
      else
        this_player()->adjust_hp(-(_trap_effect));
    } else if(arrayp(_trap_effect)) {
      if(sizeof(_trap_effect) == 2)
        this_player()->add_effect(_trap_effect[0], _trap_effect[1]);
      else
        this_player()->add_effect(_trap_effect[0], _trap_effect[1..]);
    } else
      this_player()->add_effect(_trap_effect);
    return 0;
  }
}

==================================================
FILE: basic/version.c
==================================================

nosave mapping version_control = ([ ]);
void create() {
  version_control[ base_name( this_object() ) ] = ctime( time() );
  foreach( object temp in inherit_list( this_object() ) )
    version_control[ base_name( temp ) ] = temp->query_version();
}
void query_version_control() {
  write( "File:\tTime:\n" );
  foreach( string temp in keys( version_control ) )
    printf( "%s\t%s.\n", temp, version_control[ temp ] );
  return;
}
string query_version() {
  return version_control[ base_name( this_object() ) ];
}

==================================================
FILE: basic/virtual_quit_control.c
==================================================

protected string find_start_pos(object player, object place) {
   mixed quit_env;
   string last_pos, name;
   mixed test_char;
   if ( place ) {
      quit_env = place->query_quit_handler( player );
      if (arrayp(quit_env)) {
         last_pos = quit_env[0];
      } else {
         last_pos = (string)quit_env;
      }
      if ( last_pos ) {
         last_pos->player_quitting( player, place );
      } else {
         last_pos = file_name( place );
      }
   } else {
      last_pos = player->query_start_pos();
   }
   if (last_pos && last_pos[ 0 .. 2 ] == "/w/" && last_pos != "/w/common.c") {
      test_char = player->query_property( "test character" );
      if ( !stringp( test_char ) ) {
          name = player->query_name();
      }
      else {
          name = test_char;
      }
      if (!sscanf(last_pos, "/w/"+ name +"%*s") ) {
         if (!player->query_creator() ||
              !last_pos->query_valid_save( player->query_name() )) {
            last_pos = player->query_start_pos();
         }
      }
   }
   return last_pos;
}
protected int * find_start_coord(object player, object place) {
   mixed quit_env;
   string last_pos, name;
   mixed test_char;
   if ( place ) {
      quit_env = place->query_quit_handler();
      if (arrayp(quit_env)) {
         return quit_env[1];
      } else {
         last_pos = (string)quit_env;
      }
      if ( !last_pos ) {
         last_pos = file_name( place );
      }
   } else {
      last_pos = player->query_start_pos();
   }
   if (last_pos[ 0 .. 2 ] == "/w/" && last_pos != "/w/common.c") {
      test_char = player->query_property( "test character" );
      if ( !stringp( test_char ) ) {
          name = player->query_name();
      }
      else {
          name = test_char;
      }
      if (!sscanf(last_pos, "/w/"+ name +"%*s") ) {
         if( !( player->query_creator() ||
                player->query_property( "test character" ) ) ||
              !last_pos->query_valid_save( player->query_name() )) {
            last_pos = player->query_start_pos();
         }
      }
   }
   return last_pos->query_co_ord();
}

==================================================
FILE: basic/virtual_update.c
==================================================

#include <virtual.h>
mixed query_property(string name);
void add_property(string name, mixed prop);
void init_static_arg(mapping data);
void replace_me()
{
   object receipt;
   mixed als;
   receipt = clone_object("/obj/misc/al_receipt");
   receipt->set_name("receipt");
   receipt->set_object(file_name(this_object()));
   receipt->set_virtobname(query_property(VIRTUAL_NAME_PROP));
   receipt->set_value(this_object()->query_value());
   als = "/global/auto_load"->fragile_auto_str_ob(this_object());
   als[0] = 1;
   receipt->set_static_save(als);
   receipt->set_short("destructed item receipt");
   receipt->add_adjective(({ "destructed", "item" }));
   receipt->set_long("This seems to be a small piece of paper.\n");
   receipt->set_read_mess("According to our sources, your " +
                          this_object()->query_short() +
                          " was not " "allowed to exist.  Have a nice day.");
   receipt->move(environment());
   receipt->set_weight(1);
   destruct(this_object());
}
void init_virtual_object()
{
   mapping stat_temp;
   string virt_name;
   string new_name;
   virt_name = query_property(VIRTUAL_NAME_PROP);
   if (virt_name) {
      if (file_size(virt_name) == -1) {
         new_name = (CLONER)->other_file(virt_name);
         if (stringp(new_name) && (new_name != virt_name)) {
            add_property(VIRTUAL_NAME_PROP, new_name);
            virt_name = new_name;
         } else {
            if (VIRTUAL_HANDLER->query_forbidden(virt_name)) {
               call_out("replace_me", 1);
            } else {
               VIRTUAL_HANDLER->add_missing(virt_name);
            }
         }
      }
      if (file_size(virt_name) != -1 &&
          query_property("virtual time") < stat(virt_name)[1]) {
         stat_temp = (VIRTUAL_HANDLER)->new_data(virt_name);
         if (mapp(stat_temp)) {
            init_static_arg(stat_temp);
            add_property("virtual time", time());
         }
      }
   }
}

==================================================
FILE: basic/wearable.c
==================================================

inherit "/std/basic/condition";
#include <clothing.h>
#include <move_failures.h>
private string *immune_to;
private string *wear_effects;
private mixed type;
private mixed *wear_remove_func;
nosave object worn_by;
void create() {
   condition::create();
   set_damage_chance( 25 );
   immune_to = ({ "cold", "sound", "gas", "mental" });
   wear_effects = ({ });
   wear_remove_func = ({ });
}
int query_wearable() { return 1; }
string long( string word, int dark ) {
   switch ( dark ) {
      case 0 :
         return cond_string();
      default :
         return "";
   }
}
mixed *query_wear_remove_func() {
   return wear_remove_func;
}
void set_wear_remove_func( mixed file, string func ) {
   wear_remove_func = ({ file, func });
}
string *query_wear_effects() {
  if(!wear_effects)
    wear_effects = ({ });
  return copy(wear_effects);
}
void set_wear_effects( string *effects ) {
   wear_effects = effects;
}
void add_wear_effect( string effect ) {
   if ( member_array( effect, wear_effects ) == -1 ) {
      wear_effects += ({ effect });
   }
}
void do_damage( string type, int amount ) {
   if ( member_array( type, immune_to ) == -1 ) {
      condition::do_damage( type, amount );
   }
}
object query_worn_by() {
   return worn_by;
}
int set_worn_by( object thing ) {
   int i;
   if ( thing == worn_by ) {
      return 1;
   }
   if (thing && environment() != thing) {
      return 0;
   }
   this_object()->remove_hide_invis( "concealed" );
   if ( sizeof( wear_remove_func ) ) {
    if ( !objectp( wear_remove_func[ 0 ] ) && !objectp( load_object( wear_remove_func[ 0 ] ) ) ) {
        debug_printf( "Wear/Remove func is %O. Not called.\n", wear_remove_func );
      return 0;
    }
    if ( worn_by ) {
         call_other( wear_remove_func[ 0 ], wear_remove_func[ 1 ], 0, worn_by );
      }
      if ( thing ) {
         call_other( wear_remove_func[ 0 ], wear_remove_func[ 1 ], thing, thing );
      }
   }
   if ( sizeof( wear_effects ) ) {
      for ( i = 0; i < sizeof( wear_effects ); i++ ) {
         if ( worn_by ) {
            worn_by->taken_off( this_object(), wear_effects[ i ] );
         }
         if ( thing ) {
            thing->add_effect( wear_effects[ i ], this_object() );
         } else {
            wear_effects[i]->person_removing_item(this_object(), worn_by);
         }
      }
   }
   if ( worn_by ) {
      worn_by->now_removed( this_object() );
      this_object()->add_adjective("worn");
      this_object()->remove_adjective("unworn");
   } else {
      this_object()->remove_adjective("worn");
      this_object()->add_adjective("unworn");
   }
   if ( thing ) {
      thing->now_worn( this_object() );
   }
   worn_by = thing;
   return 1;
}
string *query_immune_to() {
   return immune_to;
}
void add_immune_to( mixed args ) {
   int i;
   if ( pointerp( args ) ) {
      for ( i = 0; i < sizeof( args ); i++ ) {
         add_immune_to( args[ i ] );
      }
   } else {
      if ( member_array( args, immune_to ) == -1 ) {
         immune_to += ({ args });
      }
   }
}
void remove_immune_to( mixed args ) {
   int i;
   if ( pointerp( args ) ) {
      for ( i = 0; i < sizeof( args ); i++ ) {
         remove_immune_to( args[ i ] );
      }
   } else {
      i = member_array( args, immune_to );
      if ( i != -1 ) {
         immune_to = delete( immune_to, i, 1 );
      }
   }
}
string query_type() {
   return type;
}
private void log_bad_type( mixed type ) {
  string word, str;
  if ( !clonep( this_object() ) ) {
      return;
  }
  word = (string)this_object()->query_property( "virtual name" );
  if ( word ) {
     str = sprintf( "BAD_TYPE %s (%s) = %O\n", word,
           (string)this_object()->query_short(), type );
  } else {
     str = sprintf( "BAD_TYPE %s (%s) = %O\n", file_name(),
           (string)this_object()->query_short(), type );
  }
  if ( this_player()) {
    write(str);
  }
  call_out("move", 2, "/room/broken");
}
void set_type( mixed word ) {
  int i;
   if(!stringp(word) && !pointerp(word))
      return log_bad_type(word);
   type = word;
   if(stringp(word)) {
     if(CLOTHING_HANDLER->query_equivilant_type(word))
       type = CLOTHING_HANDLER->query_equivilant_type(word);
     if(!CLOTHING_HANDLER->query_valid_type(word))
       log_bad_type( word );
     return;
   }
   for(i=0; i<sizeof(word); i++) {
     if(CLOTHING_HANDLER->query_equivilant_type(word[i]))
       type[i] = CLOTHING_HANDLER->query_equivilant_type(word[i]);
     if (!CLOTHING_HANDLER->query_valid_type(word[i]))
       log_bad_type( word );
     return;
   }
}
int modify_value( int amount ) {
   return ( amount * ( 10 + ( 90 * query_cond() ) / query_max_cond() ) ) / 100;
}
void player_wear() {
   if ( !environment() ) {
      return;
   }
   environment()->wear_armour( this_object() );
}
void break_me() {
   if ( !worn_by ) {
      return condition::break_me();
   }
   tell_object( worn_by, "%^RED%^$C$"+ (string)this_object()->the_short() +
         " breaks!%^RESET%^\n" );
   tell_room( environment( worn_by ), (string)worn_by->the_short() +"'s "+
         this_object()->short( 0 ) +" breaks!\n", worn_by );
   worn_by->remove_armour( this_object() );
   if((int)this_object()->move("/room/rubbish") != MOVE_OK)
     move_object("/room/rubbish");
}
mixed *stats() {
   int i;
   string *stuff;
   stuff = condition::stats() +
      ({
         ({ "type", type }),
      });
   if ( sizeof( wear_effects ) ) {
      for ( i = 0; i < sizeof( wear_effects ); i++ ) {
         stuff += ({ ({ "wear effect", wear_effects[ i ] }) });
      }
   }
   for ( i = 0; i < sizeof( immune_to ); i++ ) {
      stuff += ({ ({ "immune to", immune_to[ i ] }) });
   }
   if (worn_by) {
      stuff += ({ ({ "worn by", worn_by->short() }) });
   }
   return stuff;
}
mapping query_static_auto_load() {
   return ([
      "condition" : condition::query_static_auto_load(),
      "type" : type,
      "wear remove func" : wear_remove_func
   ]);
}
mapping query_dynamic_auto_load() {
   return ([
      "condition" : condition::query_dynamic_auto_load(),
      "wear effects" : wear_effects,
      "immune" : immune_to,
      "worn" : ( worn_by != 0 )
   ]);
}
void init_static_arg( mapping map ) {
   if ( map[ "type" ] )
      type = map[ "type" ];
   if ( map[ "wear remove func" ] )
      wear_remove_func = map[ "wear remove func" ];
   if ( !undefinedp( map[ "condition" ] ) ) {
      condition::init_static_arg( map[ "condition" ] );
   }
#ifdef AFTER_1999_I_BELIEVE
   else {
      if ( !undefinedp( map[ "max cond" ] ) )
         max_cond = map[ "max cond" ];
      if ( !undefinedp( map[ "damage chance" ] ) )
         damage_chance = map[ "damage chance" ];
   }
#endif
}
void init_dynamic_arg( mapping map, object ) {
   if ( map[ "effect" ] )
      wear_effects = ({ map[ "effect" ] });
   if ( pointerp( map[ "wear effects" ] ) )
      wear_effects = map[ "wear effects" ];
   if ( map[ "immune" ] )
      immune_to = map[ "immune" ];
   if ( map[ "worn" ] )
      call_out( "player_wear", 0 );
   if ( !undefinedp( map[ "condition" ] ) ) {
      condition::init_dynamic_arg( map[ "condition" ] );
   }
#ifdef AFTER_1999_I_BELIEVE
   } else {
      cond = map[ "cond" ];
      lowest_cond = map[ "lowest cond" ];
   }
#endif
}
void remove_wear_remove_func() {
    wear_remove_func = ({ });
}

==================================================
FILE: socket/telnet.c
==================================================

#include <socket.h>
#include <socket_errors.h>
#define WRITE_WAIT_CALLBACK 0
#define WRITE_GO_AHEAD      1
#define DISCONNECTED "an internet terminal"
#define CONNECTED "an internet terminal (connected)"
#define IAC  255
#define DONT 254
#define DO   253
#define WONT 252
#define WILL 251
#define TELOPT_ECHO   1
#define TELOPT_SGA    3
#define TELOPT_TTYPE 24
#define TELOPT_NAWS  31
nosave string *telopts = ({"BINARY", "ECHO", "RCP", "SUPPRESS GO AHEAD",
			"NAME", "STATUS", "TIMING MARK", "RCTE", "NAOL", "NAOP",
		    "NAOCRD", "NAOHTS", "NAOHTD", "NAOFFD", "NAOVTS",
		    "NAOVTD", "NAOLFD", "EXTEND ASCII", "LOGOUT", "BYTE MACRO",
		    "DATA ENTRY TERMINAL", "SUPDUP", "SUPDUP OUTPUT",
		    "SEND LOCATION", "TERMINAL TYPE", "END OF RECORD",
		    "TACACS UID", "OUTPUT MARKING", "TTYLOC",
		    "3270 REGIME", "X.3 PAD", "NAWS", "TSPEED", "LFLOW",
		    "LINEMODE"});
nosave string s_iac_dont_echo;
nosave string s_iac_do_echo;
nosave string s_iac_wont_echo;
nosave string s_iac_will_echo;
nosave string s_iac_dont_sga;
nosave string s_iac_do_sga;
nosave string s_iac_wont_sga;
nosave string s_iac_will_sga;
nosave string s_iac_wont_ttype;
nosave string s_iac_wont_naws;
nosave string s_iac;
nosave string s_dont_echo;
nosave string s_do_echo;
private string callback;
private int conn_fd;
private int connected;
private int verbose;
private int write_state = WRITE_WAIT_CALLBACK;
private string write_message = "";
protected void init_tel_neg()
{
  s_iac_dont_echo  = sprintf("%c%c%c",IAC,DONT,TELOPT_ECHO);
  s_iac_do_echo    = sprintf("%c%c%c",IAC,DO  ,TELOPT_ECHO);
  s_iac_wont_echo  = sprintf("%c%c%c",IAC,WONT,TELOPT_ECHO);
  s_iac_will_echo  = sprintf("%c%c%c",IAC,WILL,TELOPT_ECHO);
  s_iac_dont_sga   = sprintf("%c%c%c",IAC,DONT,TELOPT_SGA);
  s_iac_do_sga     = sprintf("%c%c%c",IAC,DO  ,TELOPT_SGA);
  s_iac_wont_sga   = sprintf("%c%c%c",IAC,WONT,TELOPT_SGA);
  s_iac_will_sga   = sprintf("%c%c%c",IAC,WILL,TELOPT_SGA);
  s_iac_wont_ttype = sprintf("%c%c%c",IAC,WONT,TELOPT_TTYPE);
  s_iac_wont_naws  = sprintf("%c%c%c",IAC,WONT,TELOPT_NAWS);
  s_iac            = sprintf("%c",    IAC);
  s_dont_echo      = sprintf("%c%c",  DONT,TELOPT_ECHO);
  s_do_echo        = sprintf("%c%c",  DO,  TELOPT_ECHO);
}
void
set_callback(string arg)
{
	callback = arg;
}
void create()
{
  init_tel_neg();
  connected = 0;
  verbose = 0;
  set_callback("handler");
}
void
set_verbosity(int v)
{
	verbose = v;
}
int
query_connected()
{
	return connected;
}
void disconnected()
{
  call_other(this_object(), callback, "close");
  connected = 0;
}
int connected()
{
  call_other(this_object(), callback, "open");
  connected = 1;
}
void my_socket_write(int fd, string message)
{
  int ret;
  write_message = write_message + message;
  if(write_state == WRITE_GO_AHEAD){
    ret = socket_write(fd, write_message);
    write_message = "";
    if(ret == EESUCCESS) write_state = WRITE_GO_AHEAD;
    else if(ret == EECALLBACK) write_state = WRITE_WAIT_CALLBACK;
  }
}
int line(string str)
{
  if(connected){
    my_socket_write(conn_fd,s_iac_dont_sga+s_iac_dont_echo);
    write("SENT dont SUPPRESS GO AHEAD\nSENT dont ECHO\n");
    return(1);
  }
  return(0);
}
int char(string str)
{
  if(connected){
    my_socket_write(conn_fd,s_iac_do_sga+s_iac_do_echo);
    write("SENT do SUPPRESS GO AHEAD\nSENT do ECHO\n");
    return(1);
  }
  return(0);
}
int connect(string str)
{
  int ret;
  if(!str) return(0);
  conn_fd = socket_create(STREAM,"socket_shutdown");
  ret = socket_connect(conn_fd,str,"receive_data","write_data");
  if(ret != EESUCCESS){
    notify_fail("unable to connect: " + socket_error(ret) + "\n");
    return(0);
  }
  connected();
  return(1);
}
int send(string str)
{
  if(connected){
    if(!str){
      write("Sending CR.\n");
      my_socket_write(conn_fd,"\n");
      return(1);
    }
    my_socket_write(conn_fd,str + "\n");
    return(1);
  }
  return(0);
}
int disconnect(string str)
{
  int ret;
  ret = socket_close(conn_fd);
  if(ret <= 0){
    notify_fail("unable to disconnect.\n");
    return(0);
  }
  disconnected();
  return(1);
}
void receive_data(int rec_fd, string msg) {
  string *chunks;
  int i;
  object hearer;
  this_object()->recieve_message(msg);
}
void write_data(int fd) {
  write_state = WRITE_GO_AHEAD;
  my_socket_write(fd,"");
}
void socket_shutdown(int fd)
{
  object hearer;
  if(fd == conn_fd){
    hearer = environment(this_object());
    disconnected();
    return;
  }
}

==================================================
FILE: nationality/basic.c
==================================================

inherit "/std/basic/setup";
class region {
   string description;
   string start_location;
   string accent_ob;
}
private string _name;
private string _information;
private string _same_nat_description;
private string _different_nat_description;
private string _start_loc;
private string _language;
private string _accent;
private string _currency;
private mapping _regions;
void create() {
   _regions = ([ ]);
   do_setup();
}
void add_region(string name, string description, string start, string accent) {
   class region bing;
   bing = new(class region,
              description : description,
              start_location : start,
              accent_ob : accent);
   _regions[name] = bing;
}
void set_name(string name) {
   _name = name;
}
string query_name() {
   return _name;
}
void set_same_nationality_description(string description) {
   _same_nat_description = description;
}
string query_same_nationality_description() {
   return _same_nat_description;
}
void set_different_nationality_description(string description) {
   _different_nat_description = description;
}
string query_different_nationality_description() {
   return _different_nat_description;
}
string query_look_description(object person, object looker) {
   return "";
   if (person->query_nationality() == looker->query_nationality()) {
      return capitalize(person->query_pronoun()) + " " +
             _same_nat_description;
   } else {
      return capitalize(person->query_pronoun()) + " " +
             _different_nat_description;
   }
}
void set_default_start_location(string start_loc) {
   _start_loc = start_loc;
}
string query_default_start_location() {
   return _start_loc;
}
void set_language(string language) {
   _language = language;
}
string query_language() {
   return _language;
}
void set_information(string info) {
   _information = info;
}
string query_information() {
	if (!_information) {
      _information = "The $C$" + query_name() + " nationality is yet to "
                     "be described.\n";
   }
   return _information;
}
string* query_regions() {
   return keys(_regions);
}
string query_region_description(string region) {
   return _regions[region]->description;
}
string query_region_start_location(string region) {
   return _regions[region]->start_location;
}
string query_start_location(string region) {
   if (_regions[region] && _regions[region]->start_location) {
      return _regions[region]->start_location;
   }
   return _start_loc;
}
string query_region_accent_ob(string region) {
   if (_regions[region]) {
      return _regions[region]->accent_ob;
   }
   return 0;
}
void set_currency_area(string area) {
   _currency = area;
}
string query_currency_area() {
   return _currency;
}

==================================================
FILE: nationality/pumpkin.c
==================================================

inherit "/std/nationality/basic";
void setup() {
   set_name( "pumpkin" );
   set_information( "Pumpkin is a large orange ball shaped town.\n");
   add_region( "round",
               "Pumpkins which are round.",
               "/d/dist/start/entrance",
               "/std/nationality/accents/regional/round");
   add_region( "square",
               "Sto Lat is the second biggest city in the Morporkian kingdom, "
               "it sits on the river Ankh on the way to the Carrack "
               "Mountains.  It is a harder starting location than "
               "Ankh-Morpork but close enough that it is not that much of an "
               "issue.",
               "/d/dist/start/entrance",
               "/std/nationality/accents/regional/square");
   set_language("pumpkin");
   set_currency_area("Pumpkin");
   set_default_start_location("/d/am/buildings/drum/mendeddrum");
}

==================================================
FILE: nationality/accents/accent_base.c
==================================================

#define NATIONAL_ACCENT_PATH "/std/nationality/accents/national/"
mapping accent_lang_map = ([
   "Pumpkin" : "pumpkin",
   ]);
string query_nat_accent( string lang ) {
   return NATIONAL_ACCENT_PATH + lang;
}
string national_garble( string mess, object person, object sayer, int say_type,
                        string def_lang, string accent ) {
   string accent_lang = accent_lang_map[ accent ];
   string nat_accent = query_nat_accent( accent_lang );
   if( def_lang != accent_lang ) {
      if( nat_accent )
         mess = load_object( query_nat_accent( accent_lang ) )->garble_say( mess,
                                                                            person,
                                                                            sayer,
                                                                            say_type );
   } else {
   }
   return mess;
}

==================================================
FILE: nationality/accents/regional/round.c
==================================================

inherit "/std/nationality/accents/accent_base.c";
string query_accent_name() {
   return "Morporkian";
}
string garble_say( string mess, object person,
                   object sayer, int say_type, string default_language ) {
   mess = ::national_garble( mess, person, sayer, say_type, default_language,
                             query_accent_name() );
   return replace( mess, ({ "au", "$AU_PROTECT",
                               "oo", "$OO_PROTECT",
                               "ou", "$OU_PROTECT",
                               "ua", "ue",
                                "ui", "ue",
                                "uo", "ua",
                                "$OO_PROTECT", "oo",
                               "$OU_PROTECT", "ou",
                               "$AU_PROTECT", "au"
                               }) );
}

==================================================
FILE: nationality/accents/regional/square.c
==================================================

inherit "/std/nationality/accents/accent_base.c";
string query_accent_name() {
   return "Pumpkian";
}
string garble_say( string mess, object person,
                   object sayer, int say_type, string default_language ) {
   mess = ::national_garble( mess, person, sayer, say_type, default_language,
                             query_accent_name() );
   return replace( mess, ({ "a", "aa",
                               "oo", "o",
                               "ou", "ooou"
                               "ua", "ue",
                                "ui", "ue",
                                "uo", "ua",
                               }) );
}

==================================================
FILE: nationality/accents/national/pumpkin.c
==================================================

string garble_say( string mess, object person,
                   object sayer, int say_type ) {
   return replace( mess, ({
                            "eh", "a",
                            "ah", "eh",
                            "ou", "oo"
                         }) );
}
string query_accent_name() {
   return "Pumpkinian";
}

==================================================
FILE: curses/chef_curse.c
==================================================

#include "path.h"
#define MY_NAME "chef curse"
object my_player;
int init_curse(object pl) {
  string str, i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove(string name) {
  if (name != MY_NAME)
    return (int)my_player->query_remove(name);
  return 1;
}
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(HERE+"chef_curse");
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
int do_emote_all(string str) {
  return (int)my_player->do_emote_all((HERE+"chef_mangle")->do_transmute(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout((HERE+"chef_mangle")->do_transmute(str));
}
int do_say(string str) {
  return (int)my_player->do_say((HERE+"chef_mangle")->do_transmute(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say((HERE+"chef_mangle")->do_transmute(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote((HERE+"chef_mangle")->do_transmute(str));
}
int do_tell(string str) {
  string s1;
  if (sscanf(str, "%s %s", s1, str) != 2)
    return (int)my_player->do_tell(str);
  return (int)my_player->do_tell(s1+" "+(HERE+"chef_mangle")->do_transmute(str));
}

==================================================
FILE: curses/chef_mangle.c
==================================================

string *replace_matrix;
void create() {
  replace_matrix =  ({
"the", "zee",
"The", "Zee",
"ir", "ur",
"ow", "oo",
"th", "t",
"au", "oo",
"Au", "Oo",
"u", "oo",
"U", "Oo",
"tion", "shun",
"an", "un",
"An", "Un",
"en ", "ee ",
"ew", "oo",
"a", "e*",
"A", "E*",
"e* ", "e ",
"E* ", "E ",
"e*", "e",
"E*", "E",
"e ", "e-a ",
"f", "ff",
" o", " oo",
" O", " Oo",
"v", "f",
"V", "F",
"w", "v",
"W", "V", });
}
string do_transmute(string str) {
  return replace(" "+str, replace_matrix)[1..10000];
}

==================================================
FILE: curses/ken_curse.c
==================================================

#include "path.h"
#define MY_NAME "ken curse"
object my_player;
int init_curse(object pl) {
  string str, i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove(string name) {
  if (name != MY_NAME)
    return (int)my_player->query_remove(name);
  return 1;
}
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(HERE+"ken_curse");
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
int do_emote_all(string str) {
  return (int)my_player->do_emote_all((HERE+"ken_mangle")->do_transmute(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout((HERE+"ken_mangle")->do_transmute(str));
}
int do_say(string str) {
  return (int)my_player->do_say((HERE+"ken_mangle")->do_transmute(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say((HERE+"ken_mangle")->do_transmute(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote((HERE+"ken_mangle")->do_transmute(str));
}
int do_tell(string str) {
  string s1;
  if (sscanf(str, "%s %s", s1, str) != 2)
    return (int)my_player->do_tell(str);
  return (int)my_player->do_tell(s1+" "+(HERE+"ken_mangle")->do_transmute(str));
}

==================================================
FILE: curses/ken_mangle.c
==================================================

string *replace_matrix;
mapping trans;
void create() {
  replace_matrix = ({
  "Aren't you ", "Aintcha ",
  "aren't you ", "aintcha ",
  "You are", "Yer ",
  "you are ", "yer ",
  "Are not ", "Ain't",
  "are not ", "ain't ",
  "Is not ", "Ain't ",
  " is not ", " ain't ",
  "What is ", "Woss",
  "what is ", "woss",
  "What are you ", "Wotcher ",
  "what are you ", "wotcher ",
  "What you are", "Wotcher",
  "what you are", "wotcher",
  "What you're", "Wotcher",
  "what you're", "wotcher",
  "What are your", "Wotcher",
  "what are your", "wotcher",
  "What do you ", "Wotcher ",
  "what do you ", "wotcher ",
  "What do your", "Wotcher",
  "what do your", "wotcher",
  "a h", "an '",
  "A h", "An '",
  " h", " '",
  " H", " '",
  "Th", "F",
  "Wh", "W",
  "wh", "w",
  "aw", "or",
  "ing ", "in' ",
  " th", " f",
  "th", "ff",
  ".", " .",
  "?", " ?",
  "!", " !",
  });
  trans = ([ ]);
  trans["stairs"] = "apples and pears";
  trans["Downstairs"] = "Down the apples and pears";
  trans["downstairs"] =	"down the apples and pears";
  trans["Upstairs"] = "Up the apples and pears";
  trans["upstairs"] = "up the apples and pears";
  trans["mouth"] = "North and South";
  trans["Mouth"] = "North and South";
  trans["Face"] = "Boat Race";
  trans["face"] = "Boat Race";
  trans["Trouble"] = "Barney Rubble";
  trans["trouble"] = "Barney Rubble";
  trans["wife"] = ({ "trouble and strife", "ole lady" });
  trans["Road"] = "Frog and Toad";
  trans["road"] = "frog and toad";
  trans["pub"] = "rub-a-dub ";
  trans["bar"] = "boozer";
  trans["husband"] = "ole man";
  trans["Party"] = "Knees-up";
  trans["party"] = "knees-up";
  trans["Parties"] = "Knees-ups";
  trans["parties"] = "knees-ups";
  trans["My"] = "Me";
  trans["my"] = "me";
  trans["Your"] = "Yer";
  trans["your"] = "yer";
  trans["You"] = "Yer";
  trans["you"] = "yer";
  trans["Those"] = "Them";
  trans["those"] = "them";
  trans["those"] = "them";
  trans["(those"] = "(them";
  trans["The"] = ({ "The bleedin'", "The" });
  trans["Fe"] = ({ "The bleedin'", "The" });
  trans["the"] = ({ "the bleedin'", "the" });
  trans["fe"] = ({ "the bleedin'", "the" });
  trans["Thus"] = "So";
  trans["thus"] = "so";
  trans["(thus"] = "(so";
  trans["thus"] = "so";
  trans["old"] = "ole";
  trans["to"] = "ter";
  trans["Aren't"] = "Ain't";
  trans["aren't"] = "ain't";
  trans["Isn't"] = "Ain't";
  trans["isn't"] = "ain't";
  trans["Hallo"] = "Wotcher";
  trans["Hello"] = "Wotcher";
  trans["Hullo"] = "Wotcher";
  trans["Hi"] = "Wotcher";
  trans["hallo"] = "wotcher";
  trans["hello"] = "wotcher";
  trans["hullo"] = "wotcher";
  trans["hi"] = "wotcher";
  trans["What"] = "Wot";
  trans["what"] = "wot";
  trans["Were"] = "Was";
  trans["were "] = "was";
  trans["Bother"] = "Ars";
  trans["bother"] = "ars";
  trans["Mother"] = "Muvver";
  trans["Other"] = "Uvver";
  trans["other"] = "uvver";
  trans["Father"] = "Favver";
  trans["father"] = "favver";
  trans["Rather"] = "Ravver";
  trans["rather"] = "ravver";
  trans["Weather"] = "Wevver";
  trans["weather"] = "wevver";
  trans["Leather"] = "Levver";
  trans["leather"] = "levver";
  trans["Wither"] = "Wivver";
  trans["wither"] = "wivver";
  trans["Either"] = "Eever";
  trans["either"] = "eever";
  trans["With"] = "Wiv";
  trans["with"] = "wiv";
  trans["Anything"] = "Anyfink";
  trans["anything"] = "anyfink";
  trans["Something"] = "Sumfink";
  trans["something"] = "sumfink";
  trans["Nothing"] = "Nuffink";
  trans["nothing"] = "nuffink";
  trans["guitars"] = "spoons";
  trans["guitar"] = "spoons";
  trans["drums"] = "spoons";
  trans["drum"] = "spoons";
  trans["trumpets"] = "spoons";
  trans["trumpet"] = "spoons";
  trans["violins"] = "spoons";
  trans["violin"] = "spoons";
  trans["clarinets"] = "spoons";
  trans["clarinet"] = "spoons";
  trans["trombones"] = "spoons";
  trans["trombone"] = "spoons";
  trans["oboes"] = "spoons";
  trans["oboe"] = "spoons";
  trans["flutes"] = "spoons";
  trans["flute"] = "spoons";
  trans["tubas"] = "spoons";
  trans["tuba"] = "spoons";
  trans["Data"] = "Info";
  trans["data"] = "info";
  trans["Directory"] = "Lockup";
  trans["directory"] = "lockup";
  trans["Directories"] = "Lockups";
  trans["directories"] = "lockups";
  trans["Stopped"] = "'Ad the mockers put on";
  trans["stopped"] = "'ad the mockers put on";
  trans["Stopping"] = "Putting the mockers on";
  trans["stopping"] = "putting the mockers on";
  trans["stops"] = "puts the mockers on";
  trans["stop"] = "put the mockers on";
  trans["STOP"] = "Put The Mockers On";
  trans["Londoner"] = "Cockney";
  trans["londoner"] = "Cockney";
  trans["friend"] = ({ "mucker", "mate", "china" });
  trans["sin'"] = "sing";
  trans["rin'"] = "ring";
}
string do_transmute(string str) {
  string tmp, *bits;
  mixed erp;
  int i;
  tmp = replace(" "+str+" ", replace_matrix);
  bits = explode(tmp, " ");
  for (i=0;i<sizeof(bits);i++) {
    if (erp = trans[bits[i]])
      if (stringp(erp))
        bits[i] = erp;
      else
        bits[i] = erp[random(sizeof(erp))];
  }
  tmp = implode(bits, " ");
  while (tmp[strlen(tmp)-1] == ' ')
    tmp = tmp[0..strlen(tmp)-2];
  switch (tmp[strlen(tmp)-1]) {
    case '?' :
      tmp = tmp[0..strlen(tmp)-3]+ ({ ", mate? ", ", guv? ",
                                      ", squire? " })[random(3)];
      break;
    case '!' :
      tmp = tmp[0..strlen(tmp)-3]+ ({ ", cor blimey!", "! Struth!",
		    ", guv!", " ! Honest guv!", ", mate! ", "!", })[random(6)];
      break;
    case '.' :
      tmp = tmp[0..strlen(tmp)-3];
    default :
      tmp += ({
		    ". I'll get out me spoons. ",
		    ". Yer can't 'ave a knees-up wivout a joanna. ",
		    ". Cor blimey guv, would I lie to you. ",
		    ". I'll make us all a nice cup of tea. ",
               })[random(4)];
  }
  return replace(tmp, ({ " !", "!", " .", ".", " ?", "?" }));
}

==================================================
FILE: curses/newbie_curse.c
==================================================

#include "path.h"
#define MY_NAME "NEWBIE SIMULATOR"
object my_player;
int init_curse(object pl) {
  string str;
  int i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove() { return 1; }
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(file_name(this_object()));
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
protected string newbie(string str) {
  string *says;
  string ret;
  int i;
  says = ({
	"Are you a creator?\n",
	"How can I level in this mud?\n",
	"How do I kill things?\n",
	"This is nothing like my nintendo... where are the baddies?\n",
	"Where can I get a good weapon?\n",
	"Where do I get money?\n",
	"I'm going to kill you now. Prepare to die.\n",
	"All mudders stink.\n",
	"How can I do those funny nudge and poke things?\n",
	"Why can't I see invisible people?\n",
	"I still don't get this. Who's Terry Pratchett?\n",
	"I'm going back to Diku's, they're much better.\n",
	"Can you tell me where a good quest is?\n",
	"I hate this mud.\n",
	"I'm not really saying this; I've been possessed.\n",
	"Personally, I prefer Volkswagens.\n",
	"What do you mean?\n",
	"Isn't there something you can do?\n",
	"Can you show me what happens when you PK, please?\n",
	"Why can't I kill you? It keeps giving a funny message...\n",
	"I've got a great bug for getting xp...\n",
	"How do I join a guild?\n",
	"How do I go berzerk?\n",
	"I'll be fourteen next week.\n",
	"Where are you in RL?\n",
	"I'm bored. How do I win?\n",
	"Hit me.\n",
	"I'm a newbie! I'm a newbie!\n",
	"If I said you had a beautfiul body...\n",
	"Underground, Overground, wombling free.\n"
	});
  ret = str;
  if (random(100) > 30) {
	ret = (says[(random(sizeof(says)))]);
  }
  return ret;
}
protected string newbie_emote(string str) {
  string *emotes_male;
  string *emotes_female;
  string ret;
  int i;
  emotes_male = ({
	"looks extremely puzzled.\n",
	"stares around myopically.\n",
	"is obviously hugely well muscled.\n",
	"is a black belt in real life.\n",
	"stares at you intimidatingly.\n",
	"is stunningly masculine.\n",
	"has a real life as well as this mud stuff.\n",
	"doesn't like mud geeks.\n",
	"is a creator on another mud.\n",
	"is a creator on this mud.\n",
	"hasn't looked back after the first twelve million xp.\n",
	"has been asked to be a creator, but turned it down.\n",
	"has loads of girlfriends.\n",
	"has been told he looks like Richard Gere in rl.\n",
	"was consulted for the joy of sex.\n",
	"wonders why anyone would ever drive anything other than a Porsche.\n"
	});
  emotes_female = ({
	"carefully brushes out her long, golden hair.\n",
	"looks a bit like Kim Basinger in RL.\n",
	"has really _great_ tits.\n",
	"stares at you seductively and bites her lower lip.\n",
	"has modelled for a couple of magazines.\n",
	"looks really puzzled.\n",
	"carefully picks her nose with a long, elegant fingernail.\n",
	"tries to straighten her hose without anyone noticing.\n",
	"carefully applies some new lip gloss.\n",
	"isn't really into this competition thing.\n",
	"is really only fourteen years old.\n"
	});
  if ((int)(my_player->query_gender()) == 2 ) {
	ret = (emotes_female[(random(sizeof(emotes_female)))]);
  }
  if ((int)(my_player->query_gender()) == 1 ) {
	ret = (emotes_male[(random(sizeof(emotes_male)))]);
  }
  return ret;
}
int do_say(string str) {
  return (int)my_player->do_say(newbie(str));
}
int do_tell(string str) {
  return (int)my_player->do_tell(newbie(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say(newbie(str));
}
int do_echo(string str) {
  return (int)my_player->do_echo(newbie(str));
}
int do_emote_all(string str) {
  return (int)my_player->do_echo_all(newbie_emote(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote(newbie_emote(str));
}
int do_whisper(string str) {
  return (int)my_player->do_whisper(newbie(str));
}
int do_echo_to(string str) {
  return (int)my_player->do_echo_to(newbie(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout(newbie(str));
}
int do_talk(string str) {
  return (int)my_player->do_talk(newbie(str));
}

==================================================
FILE: curses/newbie_eff_shadow.c
==================================================

inherit "/std/effect_shadow";
#define MY_NAME "NEWBIE SIMULATOR"
object my_player;
string name, my_name;
void remove_effect_shadow(int i) {
   if (i == id) {
      destruct(this_object());
      return;
   }
      else player->remove_effect_shadow(i);
}
protected string newbie(string str) {
  string *says;
  string ret;
  int i;
  says = ({
	"Are you a creator?\n",
	"How can I level in this mud?\n",
	"How do I kill things?\n",
	"This is nothing like my nintendo... where are the baddies?\n",
	"Where can I get a good weapon?\n",
	"Where do I get money?\n",
	"I'm going to kill you now. Prepare to die.\n",
	"All mudders stink.\n",
	"How can I do those funny nudge and poke things?\n",
	"Why can't I see invisible people?\n",
	"I still don't get this. Who's Terry Pratchett?\n",
	"I'm going back to Diku's, they're much better.\n",
	"Can you tell me where a good quest is?\n",
	"I hate this mud.\n",
	"I'm not really saying this; I've been possessed.\n",
	"Personally, I prefer Volkswagens.\n",
	"What do you mean?\n",
	"Isn't there something you can do?\n",
	"Can you show me what happens when you PK, please?\n",
	"Why can't I kill you? It keeps giving a funny message...\n",
	"I've got a great bug for getting xp...\n",
	"How do I join a guild?\n",
	"How do I go berzerk?\n",
	"I'll be fourteen next week.\n",
	"Where are you in RL?\n",
	"I'm bored. How do I win?\n",
	"Hit me.\n",
	"I'm a newbie! I'm a newbie!\n",
	"If I said you had a beautfiul body...\n",
	"Underground, Overground, wombling free.\n"
	});
  ret = str;
  if (random(100) > 30) {
	ret = (says[(random(sizeof(says)))]);
  }
  return ret;
}
protected string newbie_emote(string str) {
  string *emotes_male;
  string *emotes_female;
  string ret;
  int i;
  emotes_male = ({
	"looks extremely puzzled.\n",
	"stares around myopically.\n",
	"is obviously hugely well muscled.\n",
	"is a black belt in real life.\n",
	"stares at you intimidatingly.\n",
	"is stunningly masculine.\n",
	"has a real life as well as this mud stuff.\n",
	"doesn't like mud geeks.\n",
	"is a creator on another mud.\n",
	"is a creator on this mud.\n",
	"hasn't looked back after the first twelve million xp.\n",
	"has been asked to be a creator, but turned it down.\n",
	"has loads of girlfriends.\n",
	"has been told he looks like Richard Gere in rl.\n",
	"was consulted for the joy of sex.\n",
	"wonders why anyone would ever drive anything other than a Porsche.\n"
	});
  emotes_female = ({
	"carefully brushes out her long, golden hair.\n",
	"looks a bit like Kim Basinger in RL.\n",
	"has really _great_ tits.\n",
	"stares at you seductively and bites her lower lip.\n",
	"has modelled for a couple of magazines.\n",
	"looks really puzzled.\n",
	"carefully picks her nose with a long, elegant fingernail.\n",
	"tries to straighten her hose without anyone noticing.\n",
	"carefully applies some new lip gloss.\n",
	"isn't really into this competition thing.\n",
	"is really only fourteen years old.\n"
	});
  if ((int)(my_player->query_gender()) == 2 ) {
	ret = (emotes_female[(random(sizeof(emotes_female)))]);
  }
  if ((int)(my_player->query_gender()) == 1 ) {
	ret = (emotes_male[(random(sizeof(emotes_male)))]);
  }
  return ret;
}
int do_say(string str) {
  return (int)my_player->do_say(newbie(str));
}
int do_tell(string str) {
  return (int)my_player->do_tell(newbie(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say(newbie(str));
}
int do_echo(string str) {
  return (int)my_player->do_echo(newbie(str));
}
int do_emote_all(string str) {
  return (int)my_player->do_emote_all(newbie_emote(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote(newbie_emote(str));
}
int do_whisper(string str) {
  return (int)my_player->do_whisper(newbie(str));
}
int do_echo_to(string str) {
  return (int)my_player->do_echo_to(newbie(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout(newbie(str));
}
int do_talk(string str) {
  return (int)my_player->do_talk(newbie(str));
}

==================================================
FILE: curses/shout_curse.c
==================================================

#include "path.h"
#define MY_NAME "Shout curse"
object my_player;
int init_curse(object pl) {
  string str, i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  printf("%O, %O\n", pl, this_object());
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove(string name) {
  return 1;
}
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(HERE+"shout_curse");
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
int do_emote_all(string str) {
  write("Your voice is too hoarse to shout.\n");
  return 1;
}
int do_shout(string str) {
  write("Your voice is too hoarse to shout.\n");
  return 1;
}

==================================================
FILE: curses/upper_case.c
==================================================

#include "path.h"
#define MY_NAME "UPPER CASE"
object my_player;
int init_curse(object pl) {
  string str;
  int i;
  if (sscanf((str = file_name(this_object())), "%s#%d", str, i) != 2) {
    seteuid((string)"/secure/master"->creator_file(str));
    return (int)clone_object(str)->init_curse(pl);
  }
  my_player = pl;
  pl->add_curse(MY_NAME, str);
  if (!shadow(pl, 1)) {
    pl->remove_curse(MY_NAME);
    return 0;
  }
  return 1;
}
int query_remove() { return 1; }
int player_start(object pl) {
  object ob;
  if (!pl)
    pl = this_player();
  ob = clone_object(file_name(this_object()));
  ob->init_curse(pl);
}
int destruct_curse(string str) {
  if (str == MY_NAME)
    destruct(this_object());
  else
    my_player->destruct_curse(str);
}
protected string upper_case(string str) {
  string ret;
  int i;
  ret = "";
  for (i=0;i<strlen(str);i++)
    ret += capitalize(str[i..i]);
  return ret;
}
int do_say(string str) {
  return (int)my_player->do_say(upper_case(str));
}
int do_tell(string str) {
  return (int)my_player->do_tell(upper_case(str));
}
int do_loud_say(string str) {
  return (int)my_player->do_loud_say(upper_case(str));
}
int do_echo(string str) {
  return (int)my_player->do_echo(upper_case(str));
}
int do_emote_all(string str) {
  return (int)my_player->do_echo_all(upper_case(str));
}
int do_emote(string str) {
  return (int)my_player->do_emote(upper_case(str));
}
int do_whisper(string str) {
  return (int)my_player->do_whisper(upper_case(str));
}
int do_echo_to(string str) {
  return (int)my_player->do_echo_to(upper_case(str));
}
int do_shout(string str) {
  return (int)my_player->do_shout(upper_case(str));
}

==================================================
FILE: shops/auction_house.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/auction_house";
void create() {
   auction_house::create();
   basic_room::create();
   add_help_file("auction_house");
}
void init() {
   basic_room::init();
   auction_house::init();
}

==================================================
FILE: shops/bank.c
==================================================

#include <money.h>
#include <move_failures.h>
#define NAME (string)this_player()->query_name()
#define CAP_NAME (string)this_player()->one_short()
#define POSS (string)this_player()->query_possessive()
#define HANDLER "/obj/handlers/bank_handler"
#define OLD_BANK "/d/am/save/bank"
nosave inherit "/std/room/basic_room";
int total_account, total_made;
nosave int account_cost, percentage;
nosave string bank_name, place;
int do_withdraw(int num, string type);
int do_deposit(string str);
nosave string save_file;
void create() {
  account_cost = 0;
  percentage = 90;
  total_account = 0;
  total_made = 0;
  bank_name = "Bing's First";
  place = "default";
  add_help_file("bank");
  ::create();
}
void init() {
  add_command( "balance", "" );
  add_command( "withdraw", "<number> <string>",
               (: do_withdraw($4[0], $4[1]) :) );
  add_command( "open", "account" );
  add_command( "close", "account" );
  add_command( "deposit", "<string>", (: do_deposit($4[0]) :) );
  ::init();
}
int query_account_cost() { return account_cost; }
void set_account_cost( int number ) { account_cost = number; }
int query_percentage() { return percentage; }
void set_percentage( int number ) { percentage = number; }
int query_total_account() { return total_account; }
int query_total_made() { return total_made; }
string query_bank_name() { return bank_name; }
void set_bank_name( string word ) { bank_name = word; }
string query_place() { return place; }
string query_money_place() { return query_place(); }
void set_place( string word ) { place = word; }
string query_save_file() { return save_file; }
void set_save_file( string word ) {
  save_file = word;
  if ( file_size( save_file +".o" ) > 0 )
    unguarded((: restore_object, save_file :));
}
void do_save() {
   if ( !save_file ) {
      return;
   }
   unguarded( (: save_object, save_file :) );
}
int get_account() {
  int amount;
  if ( amount = (int)this_player()->query_property( "bank "+ OLD_BANK ) ) {
    HANDLER->adjust_account( NAME, bank_name, amount );
    this_player()->remove_property( "bank "+ OLD_BANK );
    total_account += amount;
    do_save();
  }
  return (int)HANDLER->query_account( NAME, bank_name );
}
int set_account( int amount ) {
  HANDLER->set_account( NAME, bank_name, amount );
}
int do_balance() {
  int amount;
  amount = get_account();
  if ( amount < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }
  if ( !amount ) {
     this_player()->add_succeeded_mess(this_object(),
       ({ "Your account is empty.\n",
           "$N checks the balance of $p account.\n" }), ({ }) );
    return 1;
  }
  this_player()->add_succeeded_mess(this_object(),
     ({ "You have "+ (string)MONEY_HAND->money_value_string( amount, place ) +
        " in your account.\n",
        "$N checks the balance of $p account.\n" }), ({ }) );
  return 1;
}
int do_withdraw( int number, string type ) {
  int amount;
  int best;
  int total;
  object money;
  total = get_account();
  if ( total < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }
  if ( number <= 0 ) {
    notify_fail( "You must withdraw something.\n" );
    return 0;
  }
  money = clone_object( MONEY_OBJECT );
  money->set_money_array( (mixed *)MONEY_HAND->query_values_in( place ) );
  if ( ( best = (int)money->find_best_fit( type ) ) == -1 ) {
    notify_fail( "That currency is not legal tender here.  Sorry.\n" );
    money->dest_me();
    return 0;
  }
  type = ( (mixed *)money->query_money_array() )[ best ];
  amount = number * ( (mixed *)money->query_money_array() )[ best + 1 ];
  if ( ( amount > total ) ||
       ( amount < 0 ) ) {
    notify_fail( "You don't have enough money in your account.  Sorry.\n" );
    money->dest_me();
    return 0;
  }
  money->set_money_array( ({ type, number }) );
  set_account( total - amount );
  total_account -= amount;
  do_save();
  this_player()->add_succeeded_mess(this_object(),
   ({ "You withdraw "+ (string)money->short() +".\n" +
      "You have "+ (string)MONEY_HAND->money_value_string( get_account(),
                                                           place ) +
        " in your account after the withdrawal.\n",
      "$N withdraws some money from $p account.\n"
       }), ({ }) );
  if ( (int)money->move( this_player() ) != MOVE_OK ) {
    write( "You are too heavily burdened to collect the money, so the teller "+
      "puts it on the counter for you.\n" );
    money->move( this_object() );
  }
  this_player()->save();
  return 1;
}
int do_deposit( string words ) {
   int amount;
   int total;
   int tmp;
   mixed money;
   object *tender;
   object legal;
   object illegal;
   string howmuch;
   total = get_account();
   if ( total < 0 ) {
      notify_fail("You don't have an account here.\n");
      return 0;
   }
   money = (mixed)MONEY_HAND->parse_money( words, this_player(), place );
   if ( intp( money ) ) {
      switch( money ) {
         case NO_MATCH :
            return notify_fail( "You do not have \""+ words +"\".\n" );
         case NO_MONEY :
            return notify_fail( "You can only deposit money.\n" );
         default :
            return notify_fail( "You can only deposit legal tender.\n" );
      }
   }
   if (!place) {
      place = "default";
   }
   tender = MONEY_HAND->filter_legal_tender( money, place);
   legal = tender[0];
   illegal = tender[1];
   if (legal) {
     amount = legal->query_value_in(place);
     if (place != "default") {
       amount += legal->query_value_in("default");
     }
     if(amount < 200) {
       if( legal->move( this_player() ) != MOVE_OK ) {
          legal->move( environment( this_player() ) );
          tell_object( this_player(), "You lose hold of some coins and "
             "they tumble to the floor.\n" );
          tell_room( environment( this_player() ), this_player()->one_short() +
             "accidentally drops some coins.\n", this_player() );
       }
       if(illegal)
         if( illegal->move( this_player() ) != MOVE_OK ) {
            illegal->move( environment( this_player() ) );
            tell_object( this_player(), "You lose hold of some coins and "
               "they tumble to the floor.\n" );
            tell_room( environment( this_player() ), this_player()->one_short() +
             "accidentally drops some coins.\n", this_player() );
         }
       add_failed_mess("That is too small an amount to deposit.\n");
       return 0;
     }
     tmp = ( amount * ( 100 - percentage ) ) / 100;
     total_made += tmp;
     amount = amount - tmp;
     set_account( total + amount );
     total_account += amount;
     do_save();
   }
   if (illegal) {
      if( illegal->move( this_player() ) != MOVE_OK ) {
         illegal->move( environment( this_player() ) );
         tell_object( this_player(), "You lose hold of some coins and "
            "they tumble to the floor.\n" );
         tell_room( environment( this_player() ), this_player()->one_short() +
            "accidentally drops some coins.\n", this_player() );
       }
   }
   if (legal) {
      howmuch = legal->the_short();
      legal->move( "/room/rubbish" );
      this_player()->save();
   } else {
      add_failed_mess("Unable to find any legal money to deposit.\n");
      return 0;
   }
   write( "You give the teller "+ howmuch +".\n" );
   write( "After expenses, this leaves "+ (string)MONEY_HAND->
          money_value_string( amount, place ) +".\n" );
   this_player()->add_succeeded_mess(this_object(),
       ({  "$N $V "+words+".\n"
           "This gives a total of " +
           MONEY_HAND->money_value_string(total + amount, place ) +
           " in your account.\n",
           "$N deposit$s some money into $p account.\n" }), ({ }) );
   return 1;
}
int do_open() {
  int amount;
  object money;
  if ( get_account() >= 0 ) {
    notify_fail( "You already have an account here.\n" );
    return 0;
  }
  if ( account_cost ) {
    if ( !( money = present( MONEY_ALIAS, this_player() ) ) ) {
      notify_fail( "You do not have any money.\n" );
      return 0;
    }
    amount = (int)money->query_value_in( place );
    if ( place != "default" )
      amount += (int)money->query_value_in( "default" );
    if ( amount < account_cost ) {
      notify_fail( "You do not have enough money to open an account.\n" );
      return 0;
    }
    write( "It will cost you "+ (string)MONEY_HAND->money_value_string(
      account_cost, place ) +" to open the account.\nDo you still wish to "+
      "open an account here? " );
    input_to( "check_open" );
    return 1;
  }
  set_account( 0 );
  this_player()->add_succeeded_mess(this_object(),
     "$N $V an account.\n", ({ }) );
  return 1;
}
int check_open( string word ) {
  object money;
  word = lower_case( word );
  if (word [ 0 ] ==  110 ) {
    write( "Okay, not opening an account.\n" );
    return 1;
  }
  if ( word[ 0 ] !=  121 ) {
    write( "Do you want to open an account? Answer \"yes\" or \"no\".\n" );
    input_to( "check_open" );
    return 1;
  }
  set_account( 0 );
  write( "You now have an account here.\n" );
  money = present( MONEY_ALIAS, this_player() );
  MONEY_HAND->pay_amount_from( account_cost, money, place );
  total_made += account_cost;
  do_save();
  this_player()->save();
  return 1;
}
int do_close() {
  int total;
  object money;
  total = get_account();
  if ( total < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }
  if ( total ) {
    if ( money = (object)MONEY_HAND->make_new_amount( total, place ) ) {
      write( "You receive "+ (string)money->short() +" on closing "+
        "your account.\n" );
      if ( (int)money->move( this_player() ) != MOVE_OK ) {
        write( "You are too heavily burdened to accept all that money, so "+
          "the teller puts it on the counter for you.\n" );
        money->move( this_object() );
      }
    } else {
      write( "The amount of money in your account was not even worth a "+
        "coin of the lowest denomination in the local currency.  Sorry.\n"+
        "Your account is now closed.\n" );
      total_made += total;
    }
    total_account -= total;
  } else
    write( "You close your account.\n" );
  this_player()->add_succeeded_mess(this_object(),
     "$N $V an account.\n", ({ }) );
  set_account( -1 );
  do_save();
  this_player()->save();
  return 1;
}
mixed *stats() {
  return ::stats() + ({
    ({ "account cost", account_cost }),
    ({ "percentage", percentage }),
    ({ "total accounts", total_account }),
    ({ "total made", total_made }),
    ({ "bank name", bank_name }),
    ({ "place", place }),
    ({ "save file", save_file }) });
}
int make_bank_robbers() {
  int i, amount, loss, number, percent_loss, total;
  string player_name;
  object *bags, *money, *players, *robbers;
  mixed *mon_array;
  percent_loss = 2 + random( 4 );
  players = users();
  for ( i = 0; i < sizeof( players ); i++ ) {
    player_name = (string)players[ i ]->query_name();
    if ( ( amount = (int)HANDLER->query_account( player_name, bank_name ) ) ) {
      switch( amount ) {
        case 1 .. 10:
          loss = 0;
          break;
        case 11 .. 100:
          loss = ( amount * percent_loss ) / 100;
          break;
        case 101 .. 1000:
          loss = ( amount * percent_loss * 2 ) / 100;
          break;
        case 1001 .. 10000:
          loss = ( amount * percent_loss * 3 ) / 100;
          break;
        case 10001 .. 100000:
          loss = ( amount * percent_loss * 4 ) / 100;
          break;
        default:
          loss = ( amount * percent_loss * 5 ) / 100;
      }
      HANDLER->adjust_account( player_name, bank_name, -loss );
      total += loss;
    }
  }
  if ( !total ) return 0;
  if ( !( number = total / 10000 ) ) number = 1;
  if ( number > 5 ) number = 5;
  total_account -= total;
  amount = total / 3;
  total_made += 2 * amount;
  do_save();
  mon_array = (mixed *)MONEY_HAND->create_money_array( amount / number, place );
  bags = allocate( number );
  money = allocate( number );
  robbers = allocate( number );
  for ( i = 0; i < number; i++ ) {
    money[ i ] = clone_object( MONEY_OBJECT );
    money[ i ]->set_money_array( mon_array );
    bags[ i ] = clone_object( "/obj/container" );
    bags[ i ]->set_name( "bag" );
    bags[ i ]->set_short( "money bag" );
    bags[ i ]->add_adjective( "money" );
    bags[ i ]->add_property( "determinate", "a " );
    bags[ i ]->set_main_plural( "money bags" );
    bags[ i ]->set_long( "This is a roughly sewn sacking bag with a big "+
      "\"$\" sign on it.\n" );
    bags[ i ]->set_weight( 10 );
    bags[ i ]->set_max_weight( 3 * (int)money[ i ]->query_weight() + 10 );
    robbers[ i ] = clone_object( "/obj/monster" );
    robbers[ i ]->set_name( "robber" );
    robbers[ i ]->set_short( "bank robber" );
    robbers[ i ]->add_adjective( "bank" );
    robbers[ i ]->add_property( "determinate", "a " );
    robbers[ i ]->set_main_plural( "bank robbers" );
    robbers[ i ]->set_long( "This is a bank robber.  You can tell by the "+
      "stripey jersey and the mask over his eyes.\n" );
    robbers[ i ]->set_race( "human" );
    robbers[ i ]->set_guild( "thief" );
    robbers[ i ]->set_gender( 1 + random( 1 ) );
    robbers[ i ]->set_level( 20 + random( 30 ) + random( 40 ) );
    robbers[ i ]->reset_all();
    money[ i ]->move( bags[ i ] );
    bags[ i ]->move( robbers[ i ] );
    robbers[ i ]->move( this_object() );
  }
  return amount;
}

==================================================
FILE: shops/bank_franchise.c
==================================================

#include <money.h>
#include <move_failures.h>
nosave inherit "/std/room/basic_room";
nosave inherit "/std/shops/inherit/bank_franchise";
private int _total_account;
private int _total_made;
private nosave string _place;
nosave string _save_file;
void create() {
  _total_account = 0;
  _total_made = 0;
  add_help_file("bank");
  ::create();
}
int query_float() {
   return 2400000;
}
void adjust_float(int amt) {
}
string query_franchise() {
   return file_name(this_object());
}
int is_open_for(string type, string person) {
   return 1;
}
string query_money_place() { return _place; }
void set_place( string word ) { _place = word; }
string query_save_file() { return _save_file; }
void set_save_file( string word ) {
  _save_file = word;
  if ( file_size( _save_file +".o" ) > 0 ) {
    unguarded((: restore_object, _save_file :));
  }
}
void event_save(object ob) {
   if ( !_save_file ) {
      return;
   }
   unguarded( (: save_object, _save_file :) );
}
mixed *stats() {
  return basic_room::stats() +
         bank_franchise::stats() + ({
         ({ "save file", query_save_file() }) });
}
int make_bank_robbers() {
  int i, amount, loss, number, percent_loss, total;
  string player_name;
  object *bags, *money, *players, *robbers;
  mixed *mon_array;
  percent_loss = 2 + random( 4 );
  players = users();
  for ( i = 0; i < sizeof( players ); i++ ) {
    player_name = (string)players[ i ]->query_name();
    if ( ( amount = BANK_HANDLER->query_account( player_name, query_bank_name() ) ) ) {
      switch( amount ) {
        case 1 .. 10:
          loss = 0;
          break;
        case 11 .. 100:
          loss = ( amount * percent_loss ) / 100;
          break;
        case 101 .. 1000:
          loss = ( amount * percent_loss * 2 ) / 100;
          break;
        case 1001 .. 10000:
          loss = ( amount * percent_loss * 3 ) / 100;
          break;
        case 10001 .. 100000:
          loss = ( amount * percent_loss * 4 ) / 100;
          break;
        default:
          loss = ( amount * percent_loss * 5 ) / 100;
      }
      BANK_HANDLER->adjust_account( player_name, query_bank_name(), -loss );
      total += loss;
    }
  }
  if ( !total ) return 0;
  if ( !( number = total / 10000 ) ) number = 1;
  if ( number > 5 ) number = 5;
  amount = total / 3;
  event_save(this_object());
  mon_array = MONEY_HAND->create_money_array( amount / number, _place );
  bags = allocate( number );
  money = allocate( number );
  robbers = allocate( number );
  for ( i = 0; i < number; i++ ) {
    money[ i ] = clone_object( MONEY_OBJECT );
    money[ i ]->set_money_array( mon_array );
    bags[ i ] = clone_object( "/obj/container" );
    bags[ i ]->set_name( "bag" );
    bags[ i ]->set_short( "money bag" );
    bags[ i ]->add_adjective( "money" );
    bags[ i ]->add_property( "determinate", "a " );
    bags[ i ]->set_main_plural( "money bags" );
    bags[ i ]->set_long( "This is a roughly sewn sacking bag with a big "+
      "\"$\" sign on it.\n" );
    bags[ i ]->set_weight( 10 );
    bags[ i ]->set_max_weight( 3 * (int)money[ i ]->query_weight() + 10 );
    robbers[ i ] = clone_object( "/obj/monster" );
    robbers[ i ]->set_name( "robber" );
    robbers[ i ]->set_short( "bank robber" );
    robbers[ i ]->add_adjective( "bank" );
    robbers[ i ]->add_property( "determinate", "a " );
    robbers[ i ]->set_main_plural( "bank robbers" );
    robbers[ i ]->set_long( "This is a bank robber.  You can tell by the "+
      "stripey jersey and the mask over his eyes.\n" );
    robbers[ i ]->set_race( "human" );
    robbers[ i ]->set_guild( "thief" );
    robbers[ i ]->set_gender( 1 + random( 1 ) );
    robbers[ i ]->set_level( 20 + random( 30 ) + random( 40 ) );
    robbers[ i ]->reset_all();
    money[ i ]->move( bags[ i ] );
    bags[ i ]->move( robbers[ i ] );
    robbers[ i ]->move( this_object() );
  }
  return amount;
}
void init() {
   basic_room::init();
   bank_franchise::init();
}

==================================================
FILE: shops/bank_master.c
==================================================

#include <money.h>
#include <move_failures.h>
nosave inherit "/std/room/basic_room";
nosave inherit "/std/shops/inherit/bank_master";
private int _total_account;
private int _total_made;
private nosave string _place;
nosave string _save_file;
void create() {
  _total_account = 0;
  _total_made = 0;
  add_help_file("bank");
  ::create();
}
int query_float() {
   return 2400000;
}
void adjust_float(int amt) {
}
int is_open_for(string type, string person) {
   return 1;
}
string query_money_place() { return _place; }
void set_place( string word ) { _place = word; }
string query_save_file() { return _save_file; }
void set_save_file( string word ) {
  _save_file = word;
  if ( file_size( _save_file +".o" ) > 0 ) {
    unguarded((: restore_object, _save_file :));
  }
}
void event_save(object ob) {
   if ( !_save_file ) {
      return;
   }
   unguarded( (: save_object, _save_file :) );
}
mixed *stats() {
  return basic_room::stats() +
         bank_master::stats() + ({
         ({ "save file", query_save_file() }) });
}
int make_bank_robbers() {
  int i, amount, loss, number, percent_loss, total;
  string player_name;
  object *bags, *money, *players, *robbers;
  mixed *mon_array;
  percent_loss = 2 + random( 4 );
  players = users();
  for ( i = 0; i < sizeof( players ); i++ ) {
    player_name = (string)players[ i ]->query_name();
    if ( ( amount = BANK_HANDLER->query_account( player_name, query_bank_name() ) ) ) {
      switch( amount ) {
        case 1 .. 10:
          loss = 0;
          break;
        case 11 .. 100:
          loss = ( amount * percent_loss ) / 100;
          break;
        case 101 .. 1000:
          loss = ( amount * percent_loss * 2 ) / 100;
          break;
        case 1001 .. 10000:
          loss = ( amount * percent_loss * 3 ) / 100;
          break;
        case 10001 .. 100000:
          loss = ( amount * percent_loss * 4 ) / 100;
          break;
        default:
          loss = ( amount * percent_loss * 5 ) / 100;
      }
      BANK_HANDLER->adjust_account( player_name, query_bank_name(), -loss );
      total += loss;
    }
  }
  if ( !total ) return 0;
  if ( !( number = total / 10000 ) ) number = 1;
  if ( number > 5 ) number = 5;
  amount = total / 3;
  event_save(this_object());
  mon_array = MONEY_HAND->create_money_array( amount / number, _place );
  bags = allocate( number );
  money = allocate( number );
  robbers = allocate( number );
  for ( i = 0; i < number; i++ ) {
    money[ i ] = clone_object( MONEY_OBJECT );
    money[ i ]->set_money_array( mon_array );
    bags[ i ] = clone_object( "/obj/container" );
    bags[ i ]->set_name( "bag" );
    bags[ i ]->set_short( "money bag" );
    bags[ i ]->add_adjective( "money" );
    bags[ i ]->add_property( "determinate", "a " );
    bags[ i ]->set_main_plural( "money bags" );
    bags[ i ]->set_long( "This is a roughly sewn sacking bag with a big "+
      "\"$\" sign on it.\n" );
    bags[ i ]->set_weight( 10 );
    bags[ i ]->set_max_weight( 3 * (int)money[ i ]->query_weight() + 10 );
    robbers[ i ] = clone_object( "/obj/monster" );
    robbers[ i ]->set_name( "robber" );
    robbers[ i ]->set_short( "bank robber" );
    robbers[ i ]->add_adjective( "bank" );
    robbers[ i ]->add_property( "determinate", "a " );
    robbers[ i ]->set_main_plural( "bank robbers" );
    robbers[ i ]->set_long( "This is a bank robber.  You can tell by the "+
      "stripey jersey and the mask over his eyes.\n" );
    robbers[ i ]->set_race( "human" );
    robbers[ i ]->set_guild( "thief" );
    robbers[ i ]->set_gender( 1 + random( 1 ) );
    robbers[ i ]->set_level( 20 + random( 30 ) + random( 40 ) );
    robbers[ i ]->reset_all();
    money[ i ]->move( bags[ i ] );
    bags[ i ]->move( robbers[ i ] );
    robbers[ i ]->move( this_object() );
  }
  return amount;
}
void init() {
   basic_room::init();
   bank_master::init();
}

==================================================
FILE: shops/binding.c
==================================================

inherit "/std/room/basic_room";
#include <money.h>
#include <language.h>
private int _cost_per_book;
private int _cost_per_page;
void create() {
   _cost_per_book = 4000;
   _cost_per_page = 400;
}
void init() {
   add_command("bind", "<object:indirect:me'pages'> into book");
}
int check_for_magic_writing(object ob) {
   mixed *stuff;
   int i;
   stuff = ob->query_read_mess();
   for (i = 0; i < sizeof(stuff); i++) {
      if (LANGUAGE_HAND->query_language_magic(stuff[i][READ_LANG])) {
         return 1;
      }
   }
   return 0;
}
int do_bind(object *obs) {
   object *magic;
   object *paper;
   object *fail;
   object ob;
   object book;
   string place;
   int cost;
   foreach (ob in obs) {
      if (ob->query_paper()) {
         if (check_for_magic_writing(ob)) {
            magic += ({ ob });
         } else {
            paper += ({ ob });
         }
      }
   }
   if (sizeof(fail) || sizeof(magic)) {
      if (sizeof(magic)) {
         add_failed_mess("Cannot bind up $I with magic stuff into "
                         "a book.\n", magic);
      }
      if (sizeof(fail)) {
         add_failed_mess("$I are not pieces of paper and cannot be "
                         "bound into a book.\n", fail);
      }
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   cost = _cost_per_book + _cost_per_page * sizeof(paper);
   if (this_player()->query_value(place) > cost) {
      add_failed_mess("You do not have enough money, you need " +
                      MONEY_HAND->money_value_string(cost, place) +
                      " to bind $I into a book.\n", paper);
      return 0;
   }
   book = clone_object("/std/book");
   foreach (ob in paper) {
      book->add_page_after(ob, book->query_num_pages() + 1);
   }
   book->move(this_player());
   this_player()->pay_money( MONEY_HAND->create_money_array(cost, place),
                             place);
   return 1;
}

==================================================
FILE: shops/book_shop.c
==================================================

#include <shops/craft_shop.h>
inherit CRAFT_SHOP_INHERIT;
#define READ_PAGE_PROPERTY "browse page"
int browse_pages(object *obs);
protected int choose_which_page(function end_func, int value,
                                string name, object *sellables);
private void finish_choose(string page_num, function end_func, int value,
                          string name, object *sellables);
void init() {
   string storeroom;
   ::init();
   storeroom = file_name(query_controller()->query_sell_list());
   add_command("browse", "page of <indirect:object:" + storeroom + ">",
               (: browse_pages($1) :) );
   set_extra_sell_check((: choose_which_page :));
}
int browse_pages(object *obs) {
   object *real_obs;
   object ob;
   int number;
   string mess;
   string read;
   object *no_pages;
   object *ok;
   int i;
   if (!check_open(this_player(), "browse")) {
      return 0;
   }
   real_obs = query_controller()->create_all_real_objects(this_player(), obs);
   mess = "$P$Browse page$P$";
   no_pages = ({ });
   ok = ({ });
   for (i = 0; i < sizeof(obs); i++) {
      ob = real_obs[i];
      number = ob->query_property(READ_PAGE_PROPERTY);
      if (undefinedp(number)) {
         number = random(ob->query_num_pages() - 1) + 1;
         ob->add_property(READ_PAGE_PROPERTY, number);
         query_controller()->update_craft_object(obs[i], real_obs[i]);
      }
      if (number > ob->query_num_pages()) {
         no_pages += ({ ob });
      } else {
         ob->set_open_page(number);
         mess += ob->the_short() + ":\n" + ob->long();
         read = ob->query_readable_message();
         if (read) {
            mess += "You read " +
                    replace(ob->query_read_short(this_player()), "$name$",
                            ob->a_short()) + ":\n" +
                    ob->query_readable_message();
         }
         ok += ({ ob });
      }
   }
   if (sizeof(ok)) {
      add_succeeded_mess(({ mess, "$N browses a page of $I.\n" }), ok);
      return 1;
   } else {
      add_failed_mess("There are not enough pages in $I to open to " +
                      " page " + number + ".\n", no_pages);
      return 0;
   }
}
protected int choose_which_page(function end_func, int value,
                                string name, object *sellables) {
   write("Which page of " + query_multiple_short(sellables) +
         " would you like to let people browse (0 for the cover only)? ");
   input_to((: finish_choose :), 0, end_func, value, name, sellables);
}
private void finish_choose(string page_num, function end_func, int value,
                          string name, object *sellables) {
   int page;
   object *invalid;
   if (page_num == "quit" ||
       page_num == "q") {
      write("Aborting sale.\n");
      return ;
   }
   if (sscanf(page_num, "%d", page) != 1) {
      write("Need to actually enter a number.\n");
      write("Which page of " + query_multiple_short(sellables) +
           " would you like to let people browse? ");
      input_to((: finish_choose :), 0, end_func, value, name, sellables);
      return ;
   }
   if (page < 0) {
      write("Need to specify a page number greator than zero.\n");
      write("Which page of " + query_multiple_short(sellables) +
           " would you like to let people browse? ");
      input_to((: finish_choose :), 0, end_func, value, name, sellables);
      return ;
   }
   invalid = filter(sellables, (: $1->query_num_pages() < $(page) :) );
   if (sizeof(invalid)) {
      write("Page Number " + page + " is larger the number of pages in " +
            query_multiple_short(invalid) + ".\n");
      write("Which page of " + query_multiple_short(sellables) +
           " would you like to let people browse? ");
      input_to((: finish_choose :), 0, end_func, value, name, sellables);
      return ;
   }
   sellables->add_property(READ_PAGE_PROPERTY, page);
   sellables->set_open_page(0);
   evaluate(end_func, value, name, sellables);
}

==================================================
FILE: shops/bureau_de_change.c
==================================================

#include <money.h>
#include <move_failures.h>
inherit "/std/room/basic_room";
int standard, buy_only;
string place;
mapping exchanges;
int do_buy(object *obs, string country);
int query_standard() { return standard; }
void set_standard( int number ) { standard = number; }
int query_buy_only() { return buy_only; }
void set_buy_only() { buy_only = 1; }
string query_place() { return place; }
void set_place( string word ) { place = word; }
mapping query_exchanges() { return exchanges; }
void set_exchanges( mapping map ) { exchanges = map; }
string exchanges_list() {
    int i, value, smallest;
    string list, *places;
    if ( !sizeof( exchanges ) )
         return "There are no exchanges to be made here.";
    list = "";
    places = keys( exchanges );
    for ( i = 0; i < sizeof( places ); i++ ) {
         list += places[ i ] +":\n      $I$+20,+10="+
                  (string)MONEY_HAND->money_value_string( standard, place ) +
                  " will buy: ";
         value = ( exchanges[ places[ i ] ][ 0 ] * standard ) / 100;
         smallest = MONEY_HAND->smallest_value_in( places[ i ] );
         if (value % smallest != 0)  value += smallest - (value % smallest);
         list += (string)MONEY_HAND->money_value_string( value, places[ i ] );
         if ( buy_only ) {
             list += ".$I$-20,-10=";
             if ( i < sizeof( places ) - 1 )
                  list += "\n";
         } else {
             list += ";$I$-20,-10=\n$I$+20,+10=      for "+
                      (string)MONEY_HAND->money_value_string( standard,
                      place ) +", sell: ";
             value = ( 100 * standard ) / exchanges[ places[ i ] ][ 1 ];
             list += (string)MONEY_HAND->money_value_string( value,
                      places[ i ] ) +".$I$-20,-10=";
             if ( i < sizeof( places ) - 1 )
                  list += "\n";
         }
    }
    return list;
}
void create() {
   do_setup++;
   ::create();
   do_setup--;
   standard = 100;
   place = "default";
   exchanges = ([ ]);
   if ( !do_setup ) {
      this_object()->setup();
      this_object()->reset();
   }
}
void init() {
   ::init();
   add_command("buy", "[from] <string'" + implode(keys(exchanges), "|") +
       "'> with <indirect:object:me>",  (: do_buy( $1, $4[0] ) :) );
   if ( !buy_only ){
      add_command("sell" ,"<indirect:object:me'stuff'>",
                        (:this_object()->sell($1):));
   }
   add_command("list", "", (:this_object()->list():));
}
int do_buy(object *things, string country) {
   int     value;
   int     smallest;
   object  thing;
   object  money;
   mixed  *change;
   mixed  *monies;
   mixed  *no_value;
   string  word;
   change = ({ });
   foreach (thing in things)  {
      if (thing->query_property("money"))  {
         change = MONEY_HAND->merge_money_arrays(change,
                                                 thing->query_money_array());
#ifdef USE_VAULT
         MONEY_VAULT->add_to_list(thing);
#else
         thing->move("/room/rubbish");
#endif
      }
   }
   if (sizeof(change) == 0) {
      return notify_fail("You can only use money to buy currency here.  "
                         "Sorry.\n");
   }
   if (undefinedp(exchanges[country])) {
      foreach (word in keys(exchanges)) {
         if (lower_case(country) == lower_case(word)) {
            country = word;
            break;
         }
      }
      if (country != word) {
         add_failed_mess("You cannot exchange that currency here.  Only " +
              query_multiple_short(keys(exchanges)) + " currency can be "
              "purchased at this shop.\n");
         this_player()->adjust_money(change);
         return 0;
      }
   }
   if (country == place) {
      this_player()->adjust_money(change);
      return notify_fail("You cannot buy currency from " + country +
            " here, since you're currently in " + country + ".\n");
   }
   monies = MONEY_HAND->filter_legal_money_to_array(change, place);
   no_value = monies[1];
   if (sizeof(monies[0]) != 0  &&  place != "default")  {
      monies = MONEY_HAND->filter_legal_money_to_array(monies[0], "default");
      if (sizeof(monies[0]) != 0)
         no_value = MONEY_HAND->merge_money_arrays(no_value, monies[0]);
      monies[0] = monies[1];
   }
   if (sizeof(no_value) != 0)  {
      this_player()->adjust_money(no_value);
      write("Sorry, but you cannot use " +
            MONEY_HAND->money_string(no_value) + " to buy currency here.\n");
   }
   if (sizeof(monies[0]) == 0) {
      return notify_fail("Sorry, but you didn't offer any acceptable money "
                         "to buy currency.\n");
   }
   value = (MONEY_HAND->query_total_value(monies[0], place) *
           exchanges[country][0]) / 100;
   smallest = MONEY_HAND->smallest_value_in(country);
   if (value % smallest != 0)  value += smallest - (value % smallest);
   change = MONEY_HAND->create_money_array(value, country);
   if (sizeof(change) == 0) {
      this_player()->adjust_money(monies[0]);
      return notify_fail("Sorry, but " +
            MONEY_HAND->money_string(monies[0]) + " is not worth anything "
            "in " + country + ".\n");
   }
   write("OK, you bought "+ MONEY_HAND->money_string(change) + " with " +
         MONEY_HAND->money_string(monies[0]) + ".\n");
#ifdef USE_VAULT
   money = MONEY_VAULT->get_money_ob();
#else
   money = clone_object(MONEY_OBJECT);
#endif
   money->set_money_array(change);
   if (money->move(this_player()) != MOVE_OK) {
      write("Unfortunately, you're too heavily burdened to accept all that "
            "money, so it's put on the table for you.\n");
      money->move(this_object());
   }
   say(this_player()->one_short() + " exchanges some currency.\n");
   return 1;
}
int sell(object *things) {
   int value;
   int test_val;
   int first;
   string *places;
   string  a_place;
   object thing;
   object money;
   mixed *monies;
   mixed *change;
   mixed *m_array_a;
   mixed *m_array_b;
   mixed *m_array_c;
   m_array_a = ({ });
   foreach (thing in things)  {
      if (thing->query_property("money")) {
         m_array_a = MONEY_HAND->merge_money_arrays(m_array_a,
                         thing->query_money_array());
#ifdef USE_VAULT
         MONEY_VAULT->add_to_list(thing);
#else
         thing->move("/room/rubbish");
#endif
      }
   }
   if (sizeof(m_array_a) == 0) {
      return notify_fail("You can only sell currency here.  Sorry.\n");
   }
   places = m_indices(exchanges);
   m_array_b = ({ });
   m_array_c = ({ });
   first = 1;
   foreach (a_place in places)  {
      monies = MONEY_HAND->filter_legal_money_to_array(m_array_a, a_place);
      m_array_a = monies[1];
      if (sizeof(monies[0]) != 0)  {
         if (first  &&  a_place != "default")   {
            monies = MONEY_HAND->filter_legal_money_to_array(monies[0], "default");
            if (sizeof(monies[0]) != 0)
               m_array_c = MONEY_HAND->merge_money_arrays(m_array_c, monies[0]);
            monies[0] = monies[1];
            first = 0;
         }
         test_val = MONEY_HAND->query_total_value(monies[0], a_place) *
                    exchanges[a_place][1] / 100;
         if (test_val)   {
            value += test_val;
            m_array_b = MONEY_HAND->merge_money_arrays(m_array_b, monies[0]);
         }
         else
            m_array_c = MONEY_HAND->merge_money_arrays(m_array_c, monies[0]);
      }
      if (sizeof(m_array_a) == 0)
         break;
   }
   if (sizeof(m_array_c) != 0)
      m_array_a = MONEY_HAND->merge_money_arrays(m_array_a, m_array_c);
   if (sizeof(m_array_a) != 0) {
      write("Sorry, but you cannot sell " +
            MONEY_HAND->money_string(m_array_a) + " here.\n");
      this_player()->adjust_money(m_array_a);
   }
   if (sizeof(m_array_b) == 0) {
      return notify_fail( "Sorry, but you aren't offering to sell any "
            "acceptable coinage.\n");
   }
   change = MONEY_HAND->create_money_array(value, place);
   if (sizeof(change) == 0) {
      this_player()->adjust_money(m_array_b);
      return notify_fail("Sorry, but " +
            MONEY_HAND->money_string(m_array_b) + " is not "
            "worth anything in " + place + ".\n");
   }
   write("OK, you sold " + MONEY_HAND->money_string(m_array_b) + " for " +
         MONEY_HAND->money_string(change) + ".\n");
#ifdef USE_VAULT
   money = MONEY_VAULT->get_money_ob();
#else
   money = clone_object(MONEY_OBJECT);
#endif
   money->set_money_array(change);
   if (money->move(this_player()) != MOVE_OK) {
      write("Unfortunately, you're too heavily burdened to accept all that "
            "money, so it's put on the table for you.\n");
      money->move(this_object());
   }
   say(this_player()->one_short() + " exchanges some currency.\n");
   return 1;
}
int list() {
   write( exchanges_list() +"\n" );
   return 1;
}

==================================================
FILE: shops/commercial.c
==================================================

inherit "/std/shops/inherit/commercial";

==================================================
FILE: shops/craft_shop.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/craft_shop";
void create() {
   add_help_file("craft_shop");
   basic_room::create();
   craft_shop::create();
}
void init() {
   basic_room::init();
   craft_shop::init();
}
void dest_me() {
   craft_shop::dest_me();
   basic_room::dest_me();
}

==================================================
FILE: shops/craft_shop_category.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/craft_shop_category";
void create() {
   add_help_file("craft_shop");
   add_help_file("craft_shop_category");
   basic_room::create();
   craft_shop_category::create();
}
void init() {
   basic_room::init();
   craft_shop_category::init();
}
void dest_me() {
   craft_shop_category::dest_me();
   basic_room::dest_me();
}

==================================================
FILE: shops/engrave_inherit.c
==================================================

#include <money.h>
#include <shops/engrave.h>
void set_engrave_language(string str);
protected int do_engrave( object *things, string message);
mixed query_property(string name);
private string _lingo = "general";
void create() {
   this_object()->add_help_file("engrave");
}
void engrave_init() {
   add_command( "engrave", "<string> on <indirect:object>",
                (: do_engrave($1, $4[0]) :));
}
protected int engrave_living(object *obs) {
   return 0;
}
protected int engrave_wrong_items(object *obs) {
   return 0;
}
protected int engrave_no_money(object *obs, int cost) {
   return 0;
}
int engrave_objects(object *obs, int cost) {
   return 0;
}
protected int do_engrave( object *things, string message) {
   int cost;
   string coststring;
   string place;
   object *liv;
   object *engravable;
   liv = filter(things, (: living($1) :));
   if (sizeof(liv) && !engrave_living(liv)) {
      add_failed_mess("Cannot engrave messages on $I, they are living things.\n", liv);
   }
   things -= liv;
   if (!sizeof(things)) {
      return 0;
   }
   engravable = filter(things,
                       (: ($1->query_property( "shop type" ) == "jewellers" ||
                         $1->query_property( ENGRAVE_PROP ) == 1 ||
                           $1->query_property( "shop type" ) == "armoury") &&
                          $1->query_short() != "holy blade of Soyin" :) );
   if (!sizeof(engravable)) {
      if (!engrave_wrong_items(things - engravable)) {
         add_failed_mess("Cannot engrave messages on $I.\n",
                         things - engravable);
      }
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   coststring = replace_string(message, " ", "");
   cost = (strlen(coststring) * 80) * sizeof(engravable);
   if ( (int) this_player()->query_value_in( place ) < cost ) {
      if (!engrave_no_money(engravable, cost)) {
         add_failed_mess("Not enough money to engrave $I, you need " +
                         MONEY_HAND->money_value_string(cost, place) + ".\n",
                         engravable);
      }
      return 0;
   }
   if ( engrave_objects( engravable, cost ) ) {
      this_player()->pay_money( ( mixed *)MONEY_HAND->create_money_array( cost,
                                place ), place );
      add_succeeded_mess( ({ "You have the message \"" + message +
                            "\" engraved into $I for " +
                            MONEY_HAND->money_value_string(cost, place)
                            + ".\n", "$N gets $I engraved with a message.\n" }),
                            engravable);
      engravable->add_read_mess( message,
                 "neatly engraved letters", _lingo, 1);
      return 1;
   }
   else return 0;
}
void init() {
  engrave_init();
}
void set_engrave_language(string lang) {
  _lingo = lang;
}

==================================================
FILE: shops/general_shop.c
==================================================

#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <shop.h>
#include <tasks.h>
inherit "/std/room/basic_room";
inherit "/std/shops/inherit/open_shop";
private mixed our_storeroom;
private mixed buy_mess;
private mixed sell_mess;
private mixed list_mess;
private mixed value_mess;
private mixed too_costly_mess;
private mixed not_worthy_mess;
private mixed browse_mess;
private mixed *other_shops;
private int amount_sold;
private int amount_bought;
private int strict_shop;
private int no_steal;
private int sell_stolen;
private int steal_difficulty;
private int min_amount;
private int max_inventory;
private int sell_large;
private mixed shop_type;
private mixed buy_func;
private mixed sell_func;
private mixed value_func;
private mixed too_costly_func;
private mixed cannot_sell_func;
private mixed browse_func;
private mixed list_func;
private nosave string shoplift_handler;
private string original_storeroom;
private int _strict_currency;
private nosave mapping elist = (["north" : "south", "south" : "north",
  "east" : "west", "west" : "east", "up" : "down", "down" : "up"]);
string shop_list(mixed arr, int detail);
string shop_parse(string str, mixed ob, object client, string money,
  string extra, string which);
string find_free_exit();
int do_buy(object *ob);
int do_list_these(object *obs);
void do_buy_things( object *obs, int cost, object pl );
void do_parse(mixed arr, mixed ob, object client, string money,
  string extra);
object create_mercenary(object rep);
void event_shoplift(object command_ob, object thief, object victim);
object query_store_room();
int creator_object (object);
void create() {
    buy_mess = ({
      "You buy $ob$ for $money$.\n",
      "$client$ buys $ob$.\n"});
    sell_mess = ({
      "You sell $ob$ for $money$.\n",
      "$client$ sells $ob$.\n"});
    list_mess = "$extra$";
    value_mess = "$ob$ is valued at $money$.\n";
    too_costly_mess = "$ob$ is worth too much to be sold here.\n";
    not_worthy_mess = "$ob$ is not worth enough to be sold here.\n";
    browse_mess = "$ob$ costs $money$, it looks like:\n$extra$";
    other_shops = ({ });
    max_inventory = MAX_INVENTORY;
    min_amount = 50;
    add_help_file("shop");
    _strict_currency = 1;
    ::create();
}
void reset() {
    if(!random(3)) {
        remove_property("inventory_loss");
    }
    call_out("send_out_reps", 2);
}
void set_buy_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        buy_func = func;
    }
}
void set_sell_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        sell_func = func;
    }
}
void set_value_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        value_func = func;
    }
}
void set_too_costly_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        too_costly_func = func;
    }
}
void set_cannot_sell_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        cannot_sell_func = func;
    }
}
void set_browse_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        browse_func = func;
    }
}
void set_list_function(mixed func) {
    if (stringp(func) || functionp(func)) {
        list_func = func;
    }
}
void set_sell_message(mixed str) {
    sell_mess = str;
}
void set_buy_message(mixed str) {
    buy_mess = str;
}
void set_value_message(mixed str) {
    value_mess = str;
}
void set_too_costly_message(mixed str) {
    too_costly_mess = str;
}
void set_not_worthy_message(mixed str) {
    not_worthy_mess = str;
}
void set_browse_message(mixed str) {
    browse_mess = str;
}
void set_list_message(mixed str) {
    list_mess = str;
}
void set_open_condition(mixed str) {
   if (functionp(str)) {
      ::set_open_function(str);
   } else if (intp(str)) {
      ::set_open_function( (: $(str) :) );
   } else if (pointerp(str)) {
      ::set_open_function( (: call_other($(str[0]), $(str[1]), $1) :) );
   } if ( stringp(str) ) {
      ::set_open_function( (: call_other( this_object(), $(str), $1 ) :) );
   }
}
void set_no_steal(int i) {
    no_steal = i;
}
void set_steal_difficulty(int i) {
    steal_difficulty = i;
}
void set_sell_stolen(int i) {
    sell_stolen = i;
    no_steal = 1;
}
void set_sell_large(int i) { sell_large = i; }
mixed query_sell_mess() {
    return sell_mess;
}
mixed query_list_mess() {
    return list_mess;
}
mixed query_value_mess() {
    return value_mess;
}
mixed query_too_costly_mess() {
    return too_costly_mess;
}
mixed query_not_worthy_mess() {
    return not_worthy_mess;
}
mixed query_buy_mess() {
    return buy_mess;
}
mixed query_browse_mess() {
    return browse_mess;
}
int query_no_steal() {
    return no_steal;
}
int query_steal_difficulty(int i) {
    return steal_difficulty;
}
string query_shoplift_response_handler() {
    return shoplift_handler;
}
int query_shop() {
    return 1;
}
object *query_shop_lift_items(string str, object player) {
    return match_objects_for_existence(str, ({ query_store_room() }));
}
object shoplift_success(object ob) {
    return ob;
}
void set_shoplift_response_handler(string word) {
    shoplift_handler = word;
}
void set_min_amount(int i) { min_amount = i; }
void set_max_inventory(int i) { max_inventory = i; }
void init() {
    string room;
    ::init();
    if(stringp(our_storeroom)) {
        room = our_storeroom;
    } else if(our_storeroom) {
        room = file_name(our_storeroom);
    } else {
      tell_room(this_object(),
                "Oh dear, we don't seem to have a storeroom.\n");
    }
    add_command("sell", "<indirect:object:me>");
    add_command("buy", "<indirect:object:"+room+">");
    add_command("list", "[all]");
    add_command("list", "<indirect:object:"+room+">",
      (: do_list_these($1) :));
    add_command("browse", "<indirect:object:"+room+">");
    add_command("value", "<indirect:object:me>");
}
int query_max_amount() {
    return MAX_AMOUNT;
}
int query_min_amount() {
    return min_amount;
}
varargs int query_value(object thing, int sell) {
     if ( thing->query_property("cost here") && !sell ) {
         return (int)thing->query_property("cost here");
     }
     else {
        return (int)thing->query_value_at( this_object() );
     }
}
int scaled_value(int n) {
    int i, tot, *fish;
    fish = PAY_RATES;
    if(n < fish[0]) {
        return n;
    } else {
        tot = fish[0];
        n -= fish[0];
    }
    i = 0;
    while(n && ((i + 1) < sizeof(fish))) {
        if(n >= fish[i]) {
            tot += fish[i + 1] * fish[i] / 100;
            n -= fish[i];
        } else {
            tot += fish[i + 1] * n / 100;
            n = 0;
        }
        i += 2;
    }
    if(n) {
        tot += (n * fish[sizeof(fish) - 1]) / 100;
    }
    return tot;
}
int do_sell(object *in_obs) {
    int i, amt, total_amt;
    string place, filename, *text = ({ });
    object money, *obs, *selling, *cannot, *stolen, storeob, one_item, *cre;
    object thing;
    mixed *m_array;
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    in_obs = uniq_array( in_obs );
    obs = filter_array(in_obs, (: !$1->query_keep() :));
    cre = filter (obs, (: creator_object ($1) :));
    if (sizeof (cre) && strsrch (file_name (this_object()),
      "_dev") == -1) {
      if (!this_player()->query_creator()) {
        tell_object (this_player(), "Oh dear, you shouldn't have " +
          query_multiple_short (cre) + "!  They disappear with a flash "
          "of octarine light.\n");
        cre->move ("/room/rubbish");
      }
      else {
        tell_object (this_player(), "Oh dear, you shouldn't be trying to sell " +
          query_multiple_short (cre) + "!\n");
      }
      foreach (thing in cre) {
        if ( thing->query_property( "virtual name" ) ) {
          filename = thing->query_property( "virtual name" );
        } else {
          filename = base_name (thing);
        }
        text += ({filename});
      }
      log_file ("ILLEGAL_OBJECT", sprintf ("%s: %s tried to sell %s at "
        "%s.\n\n", ctime (time()), this_player()->query_name(),
        query_multiple_short (text), file_name (this_object())));
      obs -= cre;
   }
    if(!sizeof(obs)) {
        this_player()->add_failed_mess(this_object(),
          "You previously decided to keep $I.\n", in_obs);
        return 0;
    }
    in_obs = this_player()->query_holding() + this_player()->query_armours();
    cannot = filter(obs, (: member_array($1, $2) != -1 :), in_obs);
    if (sizeof(cannot)) {
        obs -= cannot;
        tell_object(this_player(), "You decide not to sell " +
          query_multiple_short(cannot, "the") + ", because "
          "you are wearing or holding $V$0=it,them$V$.\n");
    }
    if(objectp(our_storeroom)) {
        storeob = our_storeroom;
    } else {
        our_storeroom->rabbit_away();
        storeob = find_object(our_storeroom);
    }
    if(sizeof(all_inventory(storeob)) > max_inventory) {
        this_player()->add_failed_mess(this_object(),
          "Sorry, the shop is full up and isn't buying items!\n", ({ }));
        call_out("tidy_inventory", random(20));
        return 0;
    }
    if(sizeof(obs) > MAX_OBS) {
        write("The shopkeeper can't cope with all those objects.\n");
        obs = obs[0..MAX_OBS - 1];
    }
    selling = cannot = stolen = ({ });
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    for(i = 0; i < sizeof(obs); i++) {
        if(!sell_stolen && obs[i]->query_property("stolen")) {
            stolen += ({obs[i]});
            continue;
        } else {
            obs[i]->remove_property("stolen");
        }
        if((this_object()->query_value(obs[i], 1) > 0) &&
          !obs[i]->do_not_sell() &&
          !this_object()->do_not_buy(obs[i]) && (!strict_shop ||
            shop_type == obs[i]->query_property("shop type")) &&
          environment(obs[i]) == this_player()) {
            if(obs[i]->move(our_storeroom)) {
                if(obs[i]->short()) {
                    cannot += ({obs[i]});
                }
                continue;
            }
            amt = (int)this_object()->query_value(obs[i], 1);
            if(!(obs[i]->query_property("sale_value"))) {
                amt = scaled_value( amt );
            }
            if((amt <= (int)this_object()->query_max_amount()) &&
              (amt >= (int)this_object()->query_min_amount())) {
                if(shop_type != obs[i]->query_property("shop type")) {
                    amt = (amt * 90) / 100;
                }
                total_amt += amt;
                selling += ({obs[i]});
                obs[i]->being_sold();
            } else {
                if(obs[i]->short())
                    cannot += ({obs[i]});
                obs[i]->move(this_player());
            }
        } else {
            if(obs[i]->short()) {
                cannot += ({obs[i]});
            }
        }
    }
    if (!sizeof(selling)) {
        if (sizeof(cannot)) {
            if (stringp(cannot_sell_func)) {
                call_other(this_object(), cannot_sell_func, this_player(), cannot);
            } else if (functionp(cannot_sell_func)) {
                evaluate(cannot_sell_func, this_player(), cannot);
            }
            this_player()->add_failed_mess(this_object(),
              "You cannot sell $I.\n", cannot);
        } else if(sizeof(stolen)) {
            if(sizeof(stolen) > 1) {
                this_player()->add_failed_mess(this_object(),
                  "You cannot sell $I because they're stolen!\n", stolen);
            } else {
                this_player()->add_failed_mess(this_object(),
                  "You cannot sell $I because it's stolen!\n", stolen);
            }
            foreach(one_item in obs) {
                if(one_item->query_property("stolen") == this_player()->query_name()) {
                    event_shoplift(this_object(), this_player(), this_object());
                    break;
                }
            }
        } else {
            this_player()->add_failed_mess(this_object(),
              "You have nothing to sell.\n", ({ }));
        }
        return 0;
    }
    if(this_object()->cannot_afford(total_amt)) {
        selling->move(this_player());
        this_player()->add_failed_mess(this_object(),
          "The shop cannot afford to buy $I from you.\n", selling);
        return 0;
    }
    amount_sold += total_amt;
    m_array = (mixed *)MONEY_HAND->create_money_array(total_amt, place);
    money = clone_object(MONEY_OBJECT);
    money->set_money_array(m_array);
    if(sizeof(cannot)) {
        if(stringp(cannot_sell_func)) {
            call_other(this_object(), cannot_sell_func, this_player(), cannot);
        } else if (functionp(cannot_sell_func)) {
            evaluate(cannot_sell_func, this_player(), cannot);
        }
        write("You cannot sell "+query_multiple_short(cannot)+".\n");
        cannot->move(this_player());
    }
    if(stringp(sell_func)) {
        call_other(this_object(), sell_func, this_player(), obs);
    } else if (functionp(sell_func)) {
        evaluate(sell_func, this_player(), obs);
    }
    do_parse(sell_mess, selling, this_player(),
      (string)MONEY_HAND->money_string(m_array), "");
    if((int)money->move(this_player()) != MOVE_OK) {
        tell_object(this_player(),
          "You're too heavily burdened to accept all that money, "
          "so the shopkeeper puts it on the floor.\n");
        money->move(this_object());
    }
    this_object()->made_transaction(-total_amt, selling);
    return 1;
}
int creator_object( object ob ) {
    string path;
    if ( file_name( ob )[0..2] == "/w/" ) {
        return 1;
    }
    if ( ( path = ob->query_property( "virtual name" ) ) &&
      path[0..2] == "/w/" ) {
        return 1;
    }
    return 0;
}
int do_buy(object *obs) {
    int i, amt, ob_amt, total_cost;
    string place;
    object money, *to_buy, *cannot, *too_much;
    object *creator_obs;
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    if(sizeof(obs) > MAX_OBS) {
        write("The shopkeeper can't cope with all those objects.\n");
        obs = obs[0..MAX_OBS-1];
    }
    creator_obs = filter( obs, (: creator_object( $1 ) :) );
    if ( sizeof( creator_obs ) && file_name()[0..2] != "/w/" ) {
        tell_object( this_player(), "You cannot buy " +
          query_multiple_short( creator_obs, "the" ) +
          " because they shouldn't be in the game!\n" );
        obs -= creator_obs;
    }
    to_buy = too_much = cannot = ({ });
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    money = present(MONEY_ALIAS, this_player());
    if(!money) {
        if(stringp(too_costly_func)) {
            call_other(this_object(), too_costly_func, this_player(), obs);
        } else if (functionp(too_costly_func)) {
            evaluate(too_costly_func, this_player(), obs);
        }
        this_player()->add_failed_mess(this_object(),
          "You have no money.\n", obs);
        return 0;
    }
    amt = money->query_value_in(place);
    if(place != "default" && !_strict_currency ) {
        amt += money->query_value_in("default");
    }
    while(i < sizeof(obs)) {
        ob_amt = this_object()->query_value(obs[i], 0);
        if(ob_amt > amt) {
            if(obs[i]->short()) {
                too_much += ({obs[i]});
            }
            obs = delete(obs, i, 1);
            continue;
        }
        if(obs[i]->move(this_player())) {
            if(!sell_large) {
                if(obs[i]->short()) {
                    cannot += ({obs[i]});
                }
                i++;
                continue;
            } else {
                obs[i]->move(this_object());
            }
        }
        amt -= ob_amt;
        total_cost += ob_amt;
        to_buy += ({obs[i]});
        i++;
    }
    amount_bought += total_cost;
    if(sizeof(cannot)) {
        this_player()->add_failed_mess(this_object(),
          "You cannot pick up $I.\n", cannot);
    }
    if(sizeof(too_much)) {
        if(stringp(too_costly_func)) {
            call_other(this_object(), too_costly_func, this_player(), cannot);
        } else if (functionp(too_costly_func)) {
            evaluate(too_costly_func, this_player(), cannot);
        }
        this_player()->add_failed_mess(this_object(),
          "$I costs too much.\n", too_much);
    }
    if(!sizeof(to_buy)) {
        return 0;
    }
    do_buy_things(to_buy, total_cost, this_player());
    return 1;
}
void do_buy_things(object *obs, int cost, object pl) {
    int i, j;
    string place;
    object money, change;
    mixed m_array, p_array;
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    money = present(MONEY_ALIAS, pl);
    if(!money) {
        if(stringp(too_costly_func)) {
            call_other(this_object(), too_costly_func, this_player(), obs);
        } else if (functionp(too_costly_func)) {
            evaluate(too_costly_func, this_object(), obs);
        }
        this_player()->add_failed_mess(this_object(),
          "You don't have any money.\n", obs);
        return 0;
    }
    change = clone_object(MONEY_OBJECT);
    m_array = (int)MONEY_HAND->create_money_array(cost, place);
    for(i = 0; i < sizeof(m_array); i += 2) {
        p_array = (mixed *)MONEY_HAND->make_payment(m_array[i],
          m_array[i + 1], money, place);
        if(!pointerp(p_array)) {
            continue;
        }
        for(j = 0; j < sizeof(p_array[0]); j += 2) {
            money->adjust_money(-p_array[0][j + 1], p_array[0][j]);
        }
        change->adjust_money(p_array[1]);
    }
    do_parse(buy_mess, obs, pl,
      (string)MONEY_HAND->money_string(m_array), "");
    if(stringp(buy_func)) {
        call_other(this_object(), buy_func, pl, obs);
    } else if (functionp(buy_func)) {
        evaluate(buy_func, pl, obs);
    }
    if((int)change->move(pl) != MOVE_OK) {
        tell_object(pl, "You are too heavily burdened to accept "
          "your change, so the shopkeeper puts it on the floor.\n");
        change->move(this_object());
    }
    this_object()->made_transaction(cost, obs);
}
int do_list() {
    object ob;
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    if(objectp(our_storeroom)) {
        ob = our_storeroom;
    } else {
        if ( original_storeroom ) {
            our_storeroom = load_object( original_storeroom );
            ob = our_storeroom;
        }
        else {
            add_failed_mess( "Please notify a creator: the storeroom for "
                "this shop cannot load or has gone missing.\n" );
            return 0;
        }
    }
    if(stringp(list_func)) {
        call_other(this_object(), list_func, this_player());
    } else if (functionp(list_func)) {
        evaluate(list_func, this_player());
    }
    do_parse(list_mess, ({ this_object() }), this_player(), "",
      shop_list(all_inventory(ob), 0));
    return 1;
}
int do_list_these(object *obs) {
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    do_parse(list_mess, ({this_object()}),
      this_player(), "", shop_list(obs, 1));
    return 1;
}
int do_browse(object *obs) {
    int i, value;
    string place;
    if (!is_open(this_player(), 0)) {
        return 0;
    }
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    if(stringp(browse_func)) {
        call_other(this_object(), browse_func, this_player(), obs);
    } else if (functionp(browse_func)) {
        evaluate(browse_func, this_player(), obs);
    }
    for(i = 0; i < sizeof(obs); i++) {
        value = (int)this_object()->query_value(obs[i], 0);
        do_parse(browse_mess, obs[i..i], this_player(),
          (string)MONEY_HAND->money_value_string(value, place),
          (string)obs[i]->long());
    }
    return 1;
}
int do_value(object *obs) {
    int i;
    int val;
    int total;
    string place;
    int obnum;
    if(!is_open(this_player(), 0)) {
        return 0;
    }
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    for(i = 0; i < sizeof(obs); i++) {
        if(obs[i]->do_not_sell() || this_object()->do_not_buy(obs[i]) ||
          (environment(obs[i] ) != this_player()) ||
          (strict_shop &&
            (shop_type != (string)obs[i]->query_property("shop type")))) {
            val = 0;
        } else {
            val = (int)this_object()->query_value(obs[i], 1);
            if (shop_type != (string)obs[i]->query_property("shop type")) {
                val = (val * 90) / 100;
            }
        }
        val = scaled_value(val);
        total += val;
        if(val > (int)this_object()->query_max_amount()) {
            do_parse(too_costly_mess, obs[i..i], this_player(), "",
              (string)obs[i]->do_not_sell());
            total -= val;
        } else if(val < (int)this_object()->query_min_amount()) {
            do_parse(not_worthy_mess, obs[i..i], this_player(), "",
              (string)obs[i]->do_not_sell());
            total -= val;
        } else {
            do_parse(value_mess, obs[i..i], this_player(),
              (string)MONEY_HAND->money_value_string(val, place),
              (string)obs[i]->do_not_sell());
            if(stringp(value_func)) {
                call_other(this_object(), value_func, this_player(), obs,
                  MONEY_HAND->money_string(MONEY_HAND->create_money_array(val,
                      place)));
            } else if (functionp(value_func)) {
                evaluate(value_func, this_player(), obs,
                  MONEY_HAND->money_string(MONEY_HAND->create_money_array(val,
                      place)));
            }
        obnum++;
        }
    }
    if (obnum > 1) {
        write("This gives you a total value of " +
          MONEY_HAND->money_value_string(total, place) +
          ".\n");
        return 1;
    }
    this_player()->add_failed_mess( this_object(), "None of your items are "
        "suitable for sale here!\n", obs );
    return obnum;
}
string shop_list(mixed arr, int detail) {
    int i, j, value, num;
    string s, mon, place, *shorts, *vals;
    object *list;
    mapping inv, costs;
    mixed ind;
    if(pointerp(arr)) {
        list = arr;
    } else {
        list = all_inventory(this_object());
    }
    inv = ([ ]);
    for(i = 0; i < sizeof(list); i++) {
        s = (string)list[i]->short();
        if(!s || !this_object()->query_value(list[i], 1)) {
            continue;
        }
        if(!stringp(s)) {
            s = "get a creator for this one!";
        }
        if(inv[s]) {
            inv[s] += ({list[i]});
        } else {
            inv[s] = ({list[i]});
        }
    }
    s = "";
    shorts = m_indices(inv);
    if(!sizeof(shorts)) {
        if(detail) {
            return "The shop is all out of what you wanted.\n";
        } else {
            return "The shop is totally out of stock.\n";
        }
    }
    s = "You find on offer:\n";
    place = query_property("place");
    if(!place || (place == "")) {
        place = "default";
    }
    for(i = 0; i < sizeof(shorts); i++) {
        ind = inv[shorts[i]];
	num = sizeof(ind);
	if(num == 1 && ind[0]->query_collective())
	  num = ind[0]->query_amount();
        switch(num) {
        case 1:
            s += "Our very last " + shorts[i];
            break;
        case 2..5 :
            s += capitalize(query_num(num, 0)+" "+
			    (string)ind[0]->query_plural());
            break;
        default:
            if(detail) {
                s += capitalize(query_num(num, 0) + " " +
                  (string)ind[0]->query_plural());
            } else {
                s += "A large selection of "+
                (string)ind[0]->query_plural();
            }
        }
        if(detail) {
            costs = ([ ]);
            for(j = 0; j < sizeof(ind); j++) {
                value = (int)this_object()->query_value(ind[j], 0);
                mon = (string)MONEY_HAND->money_value_string(value, place);
                if(!costs[mon]) {
                    costs[mon] = ({""+(j + 1)});
                } else {
                    costs[mon] += ({""+(j + 1)});
                }
            }
            if(m_sizeof(costs) == 1) {
                s += " for "+m_indices(costs)[0];
                if(sizeof(m_values(costs)[0]) > 1) {
                    s += " each.\n";
                } else {
                    s += ".\n";
                }
            } else {
                s += ":-\n";
                vals = m_indices(costs);
                for(j = 0; j < sizeof(vals); j++) {
                    s += "  [#"+implode(costs[vals[j]], ",")+"] for "
                    +vals[j]+".\n";
                }
            }
        } else {
            s += ".\n";
        }
    }
    return s;
}
void set_store_room(mixed ob) {
    if(stringp(ob)) {
        original_storeroom = ob;
        our_storeroom = find_object(ob);
        if(!our_storeroom) {
            our_storeroom = load_object(ob);
        }
    }
    else our_storeroom = ob;
}
void guards(object tp) {
    object ob;
    if(environment(tp) != this_object() && environment(tp) != our_storeroom) {
        return;
    }
    while(!random(6)) {
        ob = create_mercenary(0);
        ob->move(environment(tp));
        ob->attack_ob(tp);
    }
}
object query_store_room() {
    return our_storeroom;
}
void do_parse(mixed arr, object *ob, object client,
  string money, string extra) {
    if(stringp(arr)) {
        this_player()->show_message("$P$List$P$"+
          this_player()->convert_message(replace(arr,
              ({"$ob$", query_multiple_short(ob),
                "$client$", this_player()->short(),
                "$money$", money, "$extra$", extra}))));
        this_player()->add_succeeded_mess(this_object(), "", ob);
    } else if (functionp(arr)) {
        evaluate(arr, ob, client, money, extra);
    } else {
        this_player()->show_message("$P$List$P$"+
          this_player()->convert_message(replace(arr[0],
              ({"$ob$", query_multiple_short(ob),
                "$client$", this_player()->short(),
                "$money$", money, "$extra$", extra}))));
        this_player()->add_succeeded_mess(this_object(),
          ({"", replace(arr[1], ({"$ob$", "$I", "$client$",
                "$N", "$money$", money, "$extra$", extra}))}), ob);
    }
}
string shop_parse(string str, mixed ob, object client, string money,
  string extra, string which) {
    if(sizeof(ob)) {
        str = replace(str, "$ob$", query_multiple_short(ob, which));
    } else {
        str = replace(str, "$ob$", call_other(ob, which +"_short"));
    }
    if(client) {
        str = replace(str, "$client$", client->the_short());
    }
    str = replace(str, ({"$money$", money, "$extra$", extra}));
    return str;
}
void add_other_shop(mixed shop) {
    other_shops += ({shop});
}
string query_shop_type() {
    return shop_type;
}
void set_shop_type(string ty) {
    shop_type = ty;
}
void set_strict_shop(int i) {
    strict_shop = i;
}
int query_strict_shop() {
    return strict_shop;
}
object create_rep() {
    object ob;
    ob = clone_object("/obj/monster");
    ob->set_name("rep");
    ob->set_short("sales rep");
    ob->add_adjective("sales");
    ob->set_long("This is tall strong looking sales rep.  He "
      "stares at you with bright piercing eyes.\n");
    ob->add_alias("Sales rep alias");
    ob->set_guild("fighter");
    ob->set_race("human");
    ob->adjust_bon_str(15);
    ob->set_level(60);
    ARMOURY->request_weapon("dagger", 100)->move(ob);
    ARMOURY->request_armour("cloth robe", 100)->move(ob);
    ob->init_equip();
    ob->add_property("rep type", shop_type);
    all_inventory(ob)->add_property("mine", 1);
    return ob;
}
void send_out_reps() {
    int i;
    object ob;
    for(i = 0; i < sizeof(other_shops); i++) {
        ob = (object)this_object()->create_rep();
        ob->add_property("goto destination", other_shops[i]);
        ob->add_property("goto property", "shop");
        ob->move(this_object(),
          "$N stride$s determinedly into the room.");
        ob->add_triggered_action("froggy", "goto_destination",
          file_name(this_object()), "rep_made_it");
    }
}
void rep_made_it(int bing) {
    object *obs, rep;
    int i, cost;
    if(!bing) {
        previous_object()->init_command("'Oh no!  I am utterly lost!");
        previous_object()->init_command("sigh");
        call_out("set_up_return", 5, previous_object());
        return ;
    }
    rep = present("Sales rep alias",
      (object)previous_object()->query_current_room());
    obs = (previous_object()->query_current_room())->query_stock(shop_type);
    if(!obs) {
        obs = ({ });
    }
    if(!sizeof(obs)) {
        this_object()->none_to_sell();
        call_out("set_up_return", 5, previous_object());
        return ;
    }
    for(i = 0; i < sizeof(obs); i++) {
        if(obs[i]) {
            cost += (int)this_object()->query_value( obs[ i ], 1 ) * 2 / 3;
        }
    }
    call_out("do_rep_buy", 5, ({previous_object(), obs, cost}));
    cost += (int)this_object()->query_value(obs[i], 1) * 2 / 3;
    call_out("do_rep_buy", 5, ({previous_object(), obs, cost}));
    previous_object()->adjust_value(cost);
}
object create_mercenary(object rep) {
    object ob;
    string nam;
    if(rep) {
        nam = implode(rep->query_adjectives(), " ")+" "+rep->query_name();
    }
    ob = clone_object("/obj/monster");
    ob->set_name("mercenary");
    ob->add_alias("troll");
    ob->add_adjective("troll");
    ob->set_short("troll mercenary");
    ob->set_main_plural("troll mercenaries");
    ob->set_race("troll");
    ob->set_class("fighter");
    ob->set_level(200 + random(200));
    ob->set_long("This is a large, hulking troll.  He looks "
      "quite competent and capable of mashing you with or "
      "without a weapon.\n");
    if(rep) {
        ob->move(environment(rep));
        ob->do_command("follow "+nam);
        ob->do_command("protect "+nam);
        ob->add_property("merchant", rep);
    } else {
        ARMOURY->request_weapon("spiked club", 100)->move(ob);
    }
    ob->set_natural(1);
    ob->init_equip();
    ob->set_join_fights("Troll yells something incomprehensible.\n");
    ob->set_join_fight_type(0);
    return ob;
}
object *query_stock(string type) {
    mapping blue;
    blue = (mapping)our_storeroom->query_shop_type_mapping();
    if(!blue[type]) {
        return ({ });
    }
    return blue[type];
}
void do_rep_buy(mixed *bing) {
    object rep, *obs;
    int cost;
    rep = bing[0];
    obs = bing[1];
    cost = bing[2];
    rep->adjust_money(cost, "brass");
    rep->query_current_room()->do_buy(obs, cost, rep);
    obs->move(present("Sales rep alias", rep->query_current_room()));
    call_out("set_up_return", 5, rep);
}
void set_up_return(object rep) {
    rep->add_property("goto destination", file_name(this_object()));
    rep->add_triggered_action("froggy", "goto_destination",
      this_object(), "rep_came_back");
}
void rep_came_back() {
    int i;
    object *obs, *obs2, rep;
    obs = previous_object()->find_inv_match("all", previous_object());
    obs2 = ({ });
    for(i = 0; i < sizeof(obs); i++) {
        if(obs[i]->query_property("mine")) {
            continue;
        }
        if(obs[i]->query_property("money")) {
            continue;
        }
        obs[i]->move(our_storeroom);
        obs2 += ({obs[i]});
    }
    if(sizeof(obs2)) {
        tell_room(this_object(), previous_object()->short()+" puts "+
          query_multiple_short(obs2)+" into the stock.\n");
    }
    rep = present("Sales rep alias",
      (object)previous_object()->query_current_room());
    obs = all_inventory(this_object());
    obs2 = ({ });
    for(i = 0; i < sizeof(obs); i++) {
        if((object)obs[i]->query_property("merchant") == rep) {
            obs2 += ({ obs[i] });
        }
    }
    if(sizeof(obs2)) {
        tell_room(this_object(),
          query_multiple_short(obs2+({previous_object()}), "one")+" go away.\n");
    } else {
        tell_room(this_object(), previous_object()->short()+" goes away.\n");
    }
    obs2->dest_me();
    previous_object()->dest_me();
}
void summon_guards(object tp) {
    object ob;
    int i;
    if(environment(tp) != this_object()) {
        return;
    }
    ob = environment(tp)->create_mercenary(0);
    if(!ob) {
        return;
    }
    ob->move(this_object(),
      "$N charge$s in to protect the shop!");
    ob->attack_ob(tp);
    for(i = 0; i < random(5); i++) {
        ob = create_mercenary(0);
        ob->move(this_object(),
          "$N charge$s in to protect the shop!");
        ob->attack_ob(tp);
    }
}
void set_strict_currency( int new_strict ) {
    _strict_currency = new_strict;
}
int query_strict_currency() {
    return _strict_currency;
}
void event_shoplift(object command_ob, object thief, object victim) {
    if(stringp(shoplift_handler)) {
        if(shoplift_handler != "none") {
            shoplift_handler->handle_shoplift(thief, victim);
        }
    } else if (functionp(shoplift_handler)) {
        evaluate(shoplift_handler, thief, victim);
    } else {
        "/obj/handlers/theft_handler"->handle_shoplift(thief, victim);
    }
}
void tidy_inventory() {
    object storeob;
    object *inventory;
    int i, inv_to_leave;
    int count;
    inv_to_leave = max_inventory - (max_inventory / 4);
    if(objectp(our_storeroom)) {
        storeob = our_storeroom;
    } else {
        our_storeroom->rabbit_away();
        storeob = find_object(our_storeroom);
    }
    if(sizeof(all_inventory(storeob)) < inv_to_leave)
        return;
    inventory = all_inventory(storeob);
    while(sizeof(inventory) > inv_to_leave) {
        i = random(sizeof(inventory));
        if(inventory[i])
            inventory[i]->dest_me();
        if(count++ > 500)
            break;
        inventory = all_inventory(storeob);
    }
}
void dest_me() {
    if(our_storeroom)
        our_storeroom->dest_me();
    ::dest_me();
}
mixed *stats() {
    return ::stats()+({
      ({"total sold", amount_sold}),
      ({"total bought", amount_bought}),
      ({"shop type", shop_type}),
      ({"shoplift handler", shoplift_handler }),
      ({"strict shop", strict_shop})});
}

==================================================
FILE: shops/general_shop_close.c
==================================================

inherit "/std/shops/general_shop";
inherit "/std/shops/inherit/store_close";
void womble() {
}

==================================================
FILE: shops/item_shop.c
==================================================

#include <armoury.h>
#include <money.h>
#include <move_failures.h>
inherit "/std/room/basic_room";
inherit "/std/shops/inherit/item_shop";
void create() {
  do_setup++;
  basic_room::create();
  item_shop::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void init() {
   basic_room::init();
   item_shop::init();
}
void event_theft( object command_ob, object thief, object victim,
  object *stolen ) {
    basic_room::event_theft( command_ob, thief, victim, stolen );
    item_shop::event_theft( command_ob, thief, victim, stolen );
}
void dest_me() {
   item_shop::dest_me();
   basic_room::dest_me();
}

==================================================
FILE: shops/item_shop_close.c
==================================================

inherit "/std/shops/item_shop";
inherit "/std/shops/inherit/store_close";
void womble() {
}

==================================================
FILE: shops/item_shop_outside.c
==================================================

#include <armoury.h>
#include <money.h>
#include <move_failures.h>
inherit "/std/room/outside";
inherit "/std/shops/inherit/item_shop";
void create() {
   item_shop::create();
   outside::create();
}
void init() {
   outside::init();
   item_shop::init();
}
void event_theft( object command_ob, object thief, object victim,
  object *stolen ) {
    outside::event_theft( command_ob, thief, victim, stolen );
    item_shop::event_theft( command_ob, thief, victim, stolen );
}
void dest_me() {
   item_shop::dest_me();
   outside::dest_me();
}

==================================================
FILE: shops/laundry_entry_inherit.c
==================================================

#include <money.h>
#include <vault.h>
inherit "/std/room";
#define TIME_LIMIT 500
#define LO laundryowner->the_short()
string location, laundry_room;
int visit_cost;
object laundryowner;
void set_location(string str) { location = str; }
void set_visit_cost(int i) { visit_cost = i; }
void set_laundryowner(object ob) { laundryowner = ob; }
void set_laundry_exit(string direc, mixed dest, string type) {
  laundry_room = dest;
  add_exit(direc, dest, type);
  modify_exit( direc, ({ "function", "check_customer" }) );
  modify_exit( direc, ({ "closed", 1}));
}
int check_customer( string verb, object thing, string special ) {
  string owner;
  object vroom;
  if(!laundryowner || environment(laundryowner) != this_object())
    return notify_fail("Since the owner of this laundry is missing "
      "you think twice before entering the laundry.\n");
  if( !interactive(thing) )
    return 0;
  owner = (string)thing->query_name();
  if ( !( vroom = find_object( laundry_room ) ) )  {
      laundry_room->load_me();
      vroom = find_object( laundry_room );
  }
  if(sizeof(filter_array(all_inventory(vroom),
                         (: userp( $1 ) :)))) {
    tell_object(thing, LO + " intercepts you.\n");
    tell_room( this_object(), LO + " intercepts "+
               (string)thing->the_short() +".\n",
               thing);
    laundryowner->do_command("say No more than one person at a time in "
      "laundry room.  It can be very dangerous!");
    laundryowner->do_command("emote taps his head implying madness.");
    return notify_fail( "" );
  }
  if(query_property(owner)) {
    remove_property(owner);
    tell_object(thing, LO + " opens the round door of the laundry and "
      "signalls you to enter.\n" );
    tell_room(this_object(), LO + " signalls "+
              (string)thing->the_short() +" to enter the laundry through "
                "the small round door of the laundry.\n", thing );
    call_out("check_idler", TIME_LIMIT, thing);
    return 1;
  }
  if ( (int)thing->query_value_in( location ) +
       (int)thing->query_value_in( "default" ) < visit_cost ) {
    tell_object( thing, LO + " intercepts you.\n" );
    tell_room( this_object(), LO + " intercepts "+
               (string)thing->the_short() +".\n",
               thing );
    laundryowner->do_command("say Well... I am but a poor man.  I cannot "
      "just let you use my fine, imp-powered laundry for nothing!\n" );
    laundryowner->do_command("emote sniffs.\n" );
    return notify_fail( "" );
  }
  thing->pay_money((mixed *)MONEY_HAND->create_money_array(visit_cost,
                                                           location),
                   location);
  tell_object( thing, "You pay " + LO + " who signals you to go through "
    "the small, round door of the laundry.\n" );
  tell_room( this_object(), (string)thing->the_short() +
             " pays " + LO + " who signals to "
             + (string)thing->query_objective() + " to move through "
             "a small, round door and enters the laundry.\n", thing );
   return 1;
}
void player_quitting(object who, object env) {
}

==================================================
FILE: shops/money_changer.c
==================================================

#include <money.h>
#include <move_failures.h>
inherit "/std/room/basic_room";
int change(string str1, string str2);
void create() {
   add_help_file("money_changer");
   ::create();
}
void init() {
  ::init();
  add_command("change", "<string> {into|to} <string>",
                (: change($4[0], $4[2]) :) );
}
int change( string words, string type ) {
   int val_index;
   int value;
   int value_type;
   int value_unit;
   int value_change;
   int i;
   string place;
   mixed money;
   object changed;
   object *monies;
   mixed *change;
   mixed *values;
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   values = (mixed *)MONEY_HAND->query_values_in( place );
   MONEY_OBJECT->set_money_array( values );
   val_index = (int)MONEY_OBJECT->find_best_fit( type );
   if ( val_index == -1 ) {
      return notify_fail( "The coin type \""+ type +
            "\" is not legal tender here.\n" );
   }
   money = (mixed)MONEY_HAND->parse_money( words, this_player(), place );
   if ( intp( money ) ) {
      switch( money ) {
         case NO_MATCH :
            return notify_fail( "You do not have \""+ words +"\".\n" );
         case NO_MONEY :
            return notify_fail( "You can only change money here.\n" );
         default :
            return notify_fail( "You can only change legal tender.\n" );
      }
   }
   if (place != "default")  {
      monies = MONEY_HAND->filter_legal_tender(money, "default");
      if (monies[0])  monies[0]->move(this_player());
      if (!monies[1])  {
         return notify_fail( "You can only change legal tender.\n" );
      }
      money = monies[1];
   }
   value = (int)money->query_value_in( place );
   i = member_array(values[val_index], money->query_money_array());
   if (i != -1) {
      value_type = money->query_money_array()[i + 1] * values[val_index + 1];
   }
   value_unit = values[val_index + 1] * 100 / query_property("rate");
   value_change = (value - value_type) % value_unit;
   value = ( (value - value_type) / value_unit ) * values[val_index + 1] +
           value_type;
   if ( value < values[ val_index + 1 ] ) {
      money->move( this_player() );
      return notify_fail(
        "That is not even worth one "+ values[ val_index ] +" after I "
        "subtract my commission.\n" );
   }
   changed = clone_object( MONEY_OBJECT );
   changed->set_money_array( ({ values[ val_index ],
                                value / values[ val_index + 1 ] }));
   change = (mixed *)MONEY_HAND->create_money_array( value_change, place );
   this_player()->add_succeeded_mess(this_object(),
    ({ "You changed "+query_multiple_short( money->half_short( 1 ) ) +
         " into "+
         query_multiple_short( changed->half_short( 1 ) ) +".\n",
       "$N $V some money into "+type+".\n" }), ({ }) );
   money->move( "/room/rubbish" );
   if ( sizeof( change ) ) {
      changed->adjust_money( change );
      write( "You were returned "+ (string)MONEY_HAND->money_string( change )
            +" in change.\n" );
   }
   if ( (int)changed->move( this_player() ) != MOVE_OK ) {
      write( "Unfortunately, you're too heavily burdened to accept all that "+
            "money, so it's put on the table for you.\n" );
      changed->move( this_object() );
   }
   return 1;
}

==================================================
FILE: shops/player_craft_shop.c
==================================================

#include <config.h>
#ifdef __DISTRIBUTION_LIB__
inherit "/std/room";
#else
inherit "/std/room/player_housing";
#endif
inherit "/std/shops/inherit/player_craft_shop";
void create() {
#ifdef __DISTRIBUTION_LIB__
   room::create();
#else
   player_housing::create();
#endif
   player_craft_shop::create();
   add_help_file("craft_shop");
   add_help_file("craft_shop_category");
   add_help_file("player_craft_shop");
}
void init() {
#ifdef __DISTRIBUTION_LIB__
   room::init();
#else
   player_housing::init();
#endif
   player_craft_shop::init();
}
void dest_me() {
#ifdef __DISTRIBUTION_LIB__
   room::dest_me();
#else
   player_craft_shop::dest_me();
#endif
   player_housing::dest_me();
}
void set_save_dir(string dir) {
   set_save_file(dir + "_main");
#ifndef __DISTRIBUTION_LIB__
   ::set_save_dir(dir);
#endif
}
int is_allowed(string name) {
   if (name == "pinkfish") {
      return 1;
   }
   if (lower_case(name) == lower_case(query_owner())) {
      return 1;
   }
   if (member_array(lower_case(name), query_allowed()) != -1) {
      return 1;
   }
   return 0;
}
void event_exit(object ob, string mess, object to) {
#ifdef __DISTRIBUTION_LIB__
   room::event_exit(ob, mess, to);
#else
   player_housing::event_exit(ob, mess, to);
#endif
   player_craft_shop::event_exit(ob, mess, to);
}
#ifndef __DISTRIBUTION_LIB__
int ownership_change(string old_owner, string new_owner) {
   player_craft_shop::ownership_change(old_owner, new_owner);
   return player_housing::ownership_change(old_owner, new_owner);
}
#endif

==================================================
FILE: shops/player_pub.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/pub";
private mapping _cold_drinks;
private mapping _food;
private mapping _hot_drinks;
void create() {
   do_setup++;
   basic_room::create();
   pub::create();
   do_setup--;
   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   }
}
void init() {
   basic_room::init();
   pub::init();
}
void dest_me() {
   pub::dest_me();
   basic_room::dest_me();
}

==================================================
FILE: shops/potion_shop.c
==================================================

#define CONVERT "/global/events"->convert_message
#define MIN_VOLUME 1000
inherit "/std/shops/craft_shop_category";
void shopkeeper_say( string message );
int is_potion_or_salve( object ob );
void set_message_function( function wossname );
private nosave function _message_function;
private nosave string _shopkeeper;
void create() {
   set_message_function( (: shopkeeper_say :) );
   ::create();
   set_allowed_to_sell( (: is_potion_or_salve :) );
}
void set_message_function( function wossname ) {
   _message_function = wossname;
}
function query_message_function() {
   return _message_function;
}
void set_shopkeeper( string name ) {
   _shopkeeper = name;
}
string query_shopkeeper() {
   return _shopkeeper;
}
void shopkeeper_say( string message ) {
   object *frog;
   if( !message || message == "" )
      message = "Tuppence a bucket, well stamped down!";
   if( _shopkeeper ) {
      frog = match_objects_for_existence( _shopkeeper, this_object() );
      if( sizeof( frog ) == 1 ) {
         frog[0]->init_command( "' "+ message );
         return;
      }
   }
   write( message );
   return;
}
int is_potion_or_salve( object ob ) {
   object thing, *contents;
   int found_something;
   string contents_string;
   if( !ob->query_volume() ) {
      tell_creator( this_player(), "ob has 0 volume.\n" );
      if( _message_function )
         evaluate( _message_function,
               CONVERT( "There's nothing in "+ ob->the_short() +" that "
               "can be described as either potion or salve, "+
               this_player()->the_short() +".\n" ) );
      return 0;
   } else if( ob->query_volume() < MIN_VOLUME ||
              ob->query_volume() < ( 7 * ob->query_max_volume() / 10 ) ) {
      tell_creator( this_player(), "ob does not contain enough stuff.\n" );
      if( _message_function )
         evaluate( _message_function,
               CONVERT( "We don't deal in quantities smaller than a cup, "+
               this_player()->the_short() +".\n" ) );
      return 0;
   }
   contents = all_inventory( ob );
   if( !sizeof( contents ) ) {
      tell_creator( this_player(), "No contents.\n" );
      if( _message_function )
         evaluate( _message_function,
               CONVERT( ob->the_short() +" is empty, "+
               this_player()->the_short() +"!\n" ) );
      return 0;
   }
   foreach( thing in contents )
      if( !( sizeof( thing->query_apply_effects() ) +
             sizeof( thing->query_eat_effects() ) ) ) {
         found_something = 1;
      } else {
         tell_creator( this_player(), "thing %s, effect %O.\n",
                       thing->query_short(), thing->query_eat_effects()  );
      }
   contents_string = ( sizeof( contents ) > 1 ) ?
         query_multiple_short( contents, "the" ) +" are neither potions nor "
            "salves, or they are " :
         contents[0]->the_short() +" is neither potion nor salve, or it is ";
   if( found_something ) {
      if( _message_function )
         evaluate( _message_function,
               CONVERT( "Either "+ contents_string +"impure, or so weak as "
               "to make no difference, "+ this_player()->the_short() +"." ) );
      return 0;
   }
   return 1;
}

==================================================
FILE: shops/print_shop.c
==================================================

#include <language.h>
#include <money.h>
#include <book_handler.h>
inherit "/std/room/basic_room";
#define COPYRIGHT_NUMBER 3
nosave mixed *discount_schedule;
mapping collectables;
int current_save_number;
nosave int letter_cost;
nosave int time_to_collect;
nosave int time_per_copy;
nosave string save_dir;
nosave string office_room;
nosave int no_collection;
nosave function open_func;
nosave string default_language;
nosave mapping translation_costs;
nosave string print_shop_name;
#define SCHEDULE_NUM 1
#define SCHEDULE_PERCENTAGE 0
#define COLLECT_TIME 0
#define COLLECT_NUM  1
#define COLLECT_OB_NAME 2
#define COLLECT_LANGUAGE 3
#define COLLECT_AUTO_LOAD_NUM 4
#define COLLECT_ARR_SIZE 5
#define BINDING_COST 600
#define DEFAULT_LETTER_COST 1
#define DEFAULT_TIME_TO_COLLECT (8*60*60)
#define DEFAULT_TIME_PER_COPY (20*60)
#define MAX_NUMBER 30
int price_object(object ob, int num, string language);
protected int do_print_copies(object *obs, int num, string language);
protected int do_print(object *obs, string language);
protected int do_claim(object *obs);
protected int do_collect();
void do_print_run(object ob, int number, int cost, string language);
void print_pricing(object ob, string language);
void remove_print_run(string name, mixed *info);
mixed *query_print_run(string name);
void add_print_run(string name, object ob, int number, string language);
void load_it();
void save_it();
string query_print_shop_name();
string query_static_auto_load_info(int num);
mapping query_dynamic_auto_load_info(int num);
protected int add_auto_load_info(string static, string dynamic);
private object create_fly_leaf(object book, string language);
private void remove_auto_load_info(int num);
void create() {
   letter_cost = DEFAULT_LETTER_COST;
   time_to_collect = DEFAULT_TIME_TO_COLLECT;
   time_per_copy = DEFAULT_TIME_PER_COPY;
   collectables = ([ ]);
   discount_schedule = ({ ({ 100, 5 }),
                          ({ 95, 10 }),
                          ({ 90, 20 }),
                          ({ 80, 101 }) });
   default_language = "common";
   translation_costs = ([ ]);
   print_shop_name = "Rabbits happy little printing press";
   ::create();
   load_it();
   add_help_file("print_shop");
}
void init() {
   string languages;
   if (!office_room) {
      add_command("print", "<indirect:object>",
                   (: do_print($1, default_language) :));
      add_command("print", "<number> [copies] of <indirect:object>",
                      (: do_print_copies($1, $4[0], default_language) :) );
      add_command("claim", "copyright on <indirect:object>", (: do_claim :));
      if (sizeof(translation_costs)) {
         languages = implode(keys(translation_costs) + ({ default_language }), "|");
         add_command("print", "<indirect:object> in {" + languages + "}",
                   (: do_print($1, $4[1]) :));
         add_command("print", "<number> [copies] of <indirect:object> in "
                              "{" + languages + "}",
                         (: do_print_copies($1, $4[0], $4[2]) :) );
      }
   }
   if (!no_collection) {
      add_command("collect", "", (: do_collect :));
   }
}
protected int is_copyright(object book) {
  if (BOOK_HANDLER->check_book_same(book, book->query_book_num())) {
     return 1;
  }
  return 0;
}
protected string copyright_holder(object book) {
   return BOOK_HANDLER->query_book_owner(book->query_book_num());
}
protected int do_claim(object *obs) {
   object ob;
   object *already_copyright;
   object *new_copyright;
   object *cannot_copyright;
   string name;
   string place;
   int value;
   int player_money;
   already_copyright = ({ });
   new_copyright = ({ });
   cannot_copyright = ({ });
   name = this_player()->query_name();
   foreach (ob in obs) {
      if (!ob->query_book()) {
         cannot_copyright += ({ ob });
      } else if (is_copyright(ob)) {
         already_copyright += ({ ob });
      } else {
         new_copyright += ({ ob });
      }
   }
   if (!sizeof(new_copyright)) {
      if (sizeof(cannot_copyright)) {
         add_failed_mess("You cannot copyright $I.\n", cannot_copyright);
      }
      if (sizeof(already_copyright) == 1) {
         add_failed_mess("$I is copyrighted.\n",
                         already_copyright);
      } else {
         add_failed_mess("$I are copyrighted.\n",
                         already_copyright);
      }
      return 0;
   }
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   value = 0;
   foreach (ob in new_copyright) {
      value += price_object(ob, COPYRIGHT_NUMBER, default_language);
   }
   player_money = (int)this_player()->query_value_in( place );
   if ( place != "default" ) {
      player_money += (int)this_player()->query_value_in( "default" );
   }
   write("It will cost you " + MONEY_HAND->money_value_string( value, place ) +
         " to make " + query_multiple_short(new_copyright) +
         " copyright.\n");
   if (player_money > value) {
      write("Do you wish to continue? ");
      input_to("check_copyright", 0, new_copyright, value);
   } else {
      write("Although you do not currently have enough money.\n");
   }
   add_succeeded_mess( ({ "", "$N enquires about copyrighting $I.\n" }),
                       new_copyright);
   return 1;
}
protected void check_copyright(string str, object *new_copyright, int value) {
   int new_num;
   object ob;
   string place;
   if (!strlen(str) || (str[0] != 'y' && str[0] != 'Y')) {
      write("Ok, never mind.  See you again soon.\n");
      return ;
   }
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
               value, place ), place );
   foreach (ob in new_copyright) {
      new_num = BOOK_HANDLER->add_book(ob, 0, this_player()->query_name());
      ob->set_book_num(new_num);
      ob->add_property(BH_COPYRIGHT, this_player()->query_name());
   }
   write("Ok, added " + query_multiple_short(new_copyright) +
         " as a copyright book.\n");
}
protected int do_collect() {
   object new_ob;
   object page;
   object fly_leaf;
   int i;
   int j;
   int number;
   int no_printed;
   string ob_name;
   mixed static_arg;
   mixed dynamic_arg;
   string language;
   mixed *info;
   mixed *stuff;
   mixed *collectables;
   mixed room;
   int auto_load_num;
   if (open_func) {
      if (!evaluate(open_func)) {
         return 0;
      }
   }
   if (office_room) {
      room = office_room;
   } else {
      room = this_object();
   }
   collectables = room->query_print_run(this_player()->query_name());
   if (!collectables) {
      add_failed_mess("No books available for collection.\n");
      return 0;
   }
   no_printed = 0;
   foreach (info in collectables) {
      if (time() < info[COLLECT_TIME]) {
         add_failed_mess("You need to wait until " +
                         amtime(info[COLLECT_TIME]) +
                         " to collect your book.\n");
         continue;
      }
      auto_load_num = info[COLLECT_AUTO_LOAD_NUM];
      static_arg = room->query_static_auto_load_info(auto_load_num);
      dynamic_arg = room->query_dynamic_auto_load_info(auto_load_num);
      ob_name = info[COLLECT_OB_NAME];
      number = info[COLLECT_NUM];
      language = info[COLLECT_LANGUAGE];
      if (office_room) {
         office_room->remove_print_run(this_player()->query_name(), info);
      } else {
         remove_print_run(this_player()->query_name(), info);
      }
      new_ob = clone_object(ob_name);
      if (static_arg) {
         new_ob->init_static_arg(static_arg);
      }
      if (dynamic_arg) {
         new_ob->init_dynamic_arg(dynamic_arg);
      }
      new_ob->set_open_page(0);
      for (j = 0; j < new_ob->query_num_pages(); j++) {
         if (j > 0) {
            page = new_ob->query_selected_page(j);
         } else {
            new_ob->set_open_page(0);
            page = new_ob;
         }
         if (j == 1) {
             fly_leaf = create_fly_leaf(new_ob, language);
             if (page->query_property(BH_IGNORE_PAGE)) {
                new_ob->replace_page_with(fly_leaf, j);
             } else {
                new_ob->add_page_after(fly_leaf, j - 1);
             }
             page = new_ob->query_selected_page(j + 1);
         }
         stuff = page->query_read_mess();
         foreach (info in stuff) {
            if (info[READ_LANG] != language) {
               info[READ_LANG] = language;
            }
         }
         page->set_read_mess(stuff);
      }
      static_arg = new_ob->query_static_auto_load();
      dynamic_arg = new_ob->query_dynamic_auto_load();
      new_ob->dest_me();
      for (i = 0; i < number; i++) {
         new_ob = clone_object(ob_name);
         new_ob->set_player(this_player());
         if (static_arg) {
            new_ob->init_static_arg(static_arg, this_player());
         }
         if (dynamic_arg) {
            new_ob->init_dynamic_arg(dynamic_arg, this_player());
         }
         new_ob->move(this_object());
      }
      if (number > 1) {
         write("Ok, your " + query_num(number, 1000) + " copies of " +
               new_ob->the_short() +
               " have been placed on the floor here.\n");
      } else {
         write("Ok, your copy of " + new_ob->the_short() +
               " has been placed on the floor here.\n");
      }
      no_printed++;
   }
   return no_printed;
}
private object create_fly_leaf(object book, string language) {
    object page;
    page = book->create_default_page_object();
    if (is_copyright(book)) {
       page->add_read_mess("\n\nPrinted " + amtime(time()) +
                             " by " + query_print_shop_name() +
                             "\n\nCopyright " +
                             this_player()->query_name(), 0,
                             language);
    } else {
       page->add_read_mess("\n\nPrinted " + amtime(time()) +
                             " by " + query_print_shop_name() +
                             "\n", 0,
                             language);
    }
    page->add_property(BH_IGNORE_PAGE, 1);
    return page;
}
int check_for_magic_writing(object ob) {
   mixed *stuff;
   int i;
   stuff = ob->query_read_mess();
   for (i = 0; i < sizeof(stuff); i++) {
      if (LANGUAGE_HAND->query_language_magic(stuff[i][READ_LANG])) {
         return 1;
      }
   }
   return 0;
}
int check_for_untranslatable_language(object ob) {
   mixed *stuff;
   int i;
   string lang;
   stuff = ob->query_read_mess();
   for (i = 0; i < sizeof(stuff); i++) {
      lang = stuff[i][READ_LANG];
      if (lang != default_language &&
          !translation_costs[lang]) {
         return 1;
      }
   }
   return 0;
}
object find_book_or_paper(object *obs) {
   object *paper;
   object *books;
   object *magic;
   object *torn_out;
   object *nothing;
   object ob;
   int page;
   int old_page;
   string owner;
   paper = ({ });
   books = ({ });
   magic = ({ });
   torn_out = ({ });
   nothing = ({ });
   foreach (ob in obs) {
      owner = copyright_holder(ob);
      if (is_copyright(ob) && owner != this_player()->query_name()) {
         add_failed_mess("$I has been copyrighted by " + owner +
                         " and cannot be copied.\n", ({ ob }));
      } else if (ob->query_book()) {
         if (ob->query_spell_book()) {
            magic += ({ ob });
         } else {
            old_page = ob->query_open_page();
            for (page = 0; page <= ob->query_num_pages(); page++) {
               ob->set_open_page(page);
               if (ob->is_current_page_torn_out()) {
                  torn_out += ({ ob });
                  break;
               }
               if (check_for_magic_writing(ob)) {
                  magic += ({ ob });
                  break;
               }
            }
            ob->set_open_page(old_page);
            if (page == ob->query_num_pages() + 1) {
               books += ({ ob });
            }
         }
      } else if (ob->query_paper()) {
         if (check_for_magic_writing(ob)) {
            magic += ({ ob });
         } else {
            paper += ({ ob });
         }
      } else {
         nothing += ({ ob });
      }
   }
   if (sizeof(magic)) {
      add_failed_mess("$I have magic writing in them and cannot be copied.\n",
                      magic);
   }
   if (sizeof(torn_out)) {
      add_failed_mess("$I have pages torn out and cannot be copied.\n",
                      torn_out);
   }
   if (!sizeof(books) && !sizeof(paper)) {
      if (sizeof(nothing)) {
         add_failed_mess("Unable to print $I as they are not a book or paper.\n", nothing);
      }
      return 0;
   }
   if (sizeof(books + paper) > 1) {
      add_failed_mess("Can only do print one book or piece of paper at a time.  "
                  "Please be more specific and choose from " +
                  query_multiple_short(books + paper) + ".\n");
      return 0;
   }
   if (sizeof(books) > 0) {
      return books[0];
   }
   return paper[0];
}
int do_print(object *obs, string language) {
   object ob;
   if (open_func) {
      if (!evaluate(open_func, obs)) {
         return 0;
      }
   }
   ob = find_book_or_paper(obs);
   if (!ob) {
      return 0;
   }
   print_pricing(ob, language);
   write("Use: print <number> of <book>\n");
   add_succeeded_mess(({ "",
                       "$N enquires about the cost of printing a book.\n" }));
   return 1;
}
int do_print_copies(object *obs, int number, string language) {
   object ob;
   int cost;
   int player_money;
   string place;
   if (open_func) {
      if (!evaluate(open_func, obs)) {
         return 0;
      }
   }
   if (number < 1) {
      add_failed_mess("Must print at least one copy.\n", obs);
      return 0;
   }
   if (number > MAX_NUMBER) {
      add_failed_mess("Cannot print more than " + MAX_NUMBER +
                      " copies.\n", obs);
      return 0;
   }
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   ob = find_book_or_paper(obs);
   if (!ob) {
      return 0;
   }
   cost = price_object(ob, number, language);
   player_money = (int)this_player()->query_value_in( place );
   if ( place != "default" ) {
      player_money += (int)this_player()->query_value_in( "default" );
   }
   if (player_money < cost) {
      add_failed_mess("This will cost you " +
                       (string)MONEY_HAND->money_value_string(
                      cost, place ) + " and you do not have enough "
                  "money to afford it.\n", ({ ob }));
      return 0;
   }
   if (is_copyright(ob)) {
      write("NOTE:  You are printing a copyright document.\n");
   } else {
      write("NOTE:  Please use 'claim copyright' to claim copyright "
            "on a document.\n");
   }
   add_succeeded_mess(({ "This will cost you " +
                       (string)MONEY_HAND->money_value_string(
                      cost, place ) +
                       " to do, do you wish to continue? ",
                       "$N starts to do some printing.\n" }));
   input_to("check_cost", 0, ob, number, cost, language);
   return 1;
}
void check_cost(string str, object ob, int number, int cost, string language) {
   if (strlen(str) < 1 || (str[0] != 'y' && str[0] != 'Y')) {
      write("Ok, don't worry.  See you again.\n");
      return ;
   }
   do_print_run(ob, number, cost, language);
}
void do_print_run(object ob, int number, int cost, string language) {
   string place;
   int player_money;
   mixed *stuff;
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   player_money = (int)this_player()->query_value_in( place );
   if ( place != "default" ) {
      player_money += (int)this_player()->query_value_in( "default" );
   }
   if (player_money < cost) {
      write("You do not seem to have enough money any more.\n");
      return ;
   }
   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
               cost, place ), place );
   add_print_run(this_player()->query_name(),
                 ob,
                 number,
                 language);
   stuff = query_print_run(this_player()->query_name());
   if (no_collection) {
      write("The copies will be ready at " +
            amtime(stuff[<1][COLLECT_TIME]) + " for 'collect'ion at the "
            "collection office.\n");
   } else {
      write("The copies will be ready at " +
            amtime(stuff[<1][COLLECT_TIME]) + " for 'collect'ion.\n");
   }
}
int price_object(object ob, int num, string to_language) {
   int i;
   int num_letters;
   int multiplier;
   int cost;
   mixed *stuff;
   if (num <= 0 || !ob) {
     return 0;
   }
   ob->set_open_page(0);
   stuff = ob->query_read_mess();
   for (i = 0; i < sizeof(stuff); i++) {
      num_letters += strlen(stuff[i][READ_MESS]);
      if (stuff[i][READ_LANG] != default_language) {
         cost = translation_costs[stuff[i][READ_LANG]];
         if (!cost) {
            cost = 1000;
         }
         num_letters = (num_letters * cost) / 100;
      }
      if (to_language != default_language) {
         cost = translation_costs[to_language];
         if (!cost) {
            cost = 1000;
         }
         num_letters = (num_letters * cost) / 100;
      }
   }
   cost = ob->query_value() + (num_letters / 10) * letter_cost;
   if (ob->query_book()) {
      for (i = 1; i < ob->query_num_pages(); i++) {
         ob->set_open_page(i + 1);
         if (ob != ob->query_current_page()) {
            cost += price_object(ob->query_current_page(), 1, to_language);
         }
      }
      cost += BINDING_COST;
   }
   multiplier = 200;
   for (i = 0; i < sizeof(discount_schedule); i++) {
      if (num < discount_schedule[i][SCHEDULE_NUM]) {
         multiplier = discount_schedule[i][SCHEDULE_PERCENTAGE];
      }
   }
   return (cost * num * multiplier) / 100;
}
void print_pricing(object ob, string language) {
   int i;
   int num;
   string place;
   int cost;
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   write("The cost for the different numbers of " + ob->the_short() + " is:\n");
   write("  1 for " + (string)MONEY_HAND->money_value_string(
                    price_object(ob, 1, language), place ) +
                    " and will be ready at " +
                    amtime(time_to_collect + time_per_copy + time()) + ".\n");;
   for (i = 0; i < sizeof(discount_schedule); i++) {
      num = discount_schedule[i][SCHEDULE_NUM];
      if (num < MAX_NUMBER) {
         write(sprintf("%3d for %s and will be ready at %s.\n", num,
                       (string)MONEY_HAND->money_value_string(
                       price_object(ob, num, language), place ),
                       amtime(time_to_collect + time_per_copy * num + time()) ));
      }
   }
   if (sizeof(translation_costs)) {
      write("You can translate a book to or from " +
            query_multiple_short(keys(translation_costs) + ({ default_language })) +
            ", the cost of doing the translation is defined in the "
            "following table.");
      if (sizeof(translation_costs) > 2) {
         write("  Translating between two of these languages "
               "is also possible, but it will cost the amount to translate "
               "from the language to " + default_language + " and back again.");
      }
      write("\n");
      foreach (language, cost in translation_costs) {
         write(sprintf("   %3d%% %s", cost, language));
      }
      write("\n");
   }
}
mixed *query_discount_schedule() {
   return discount_schedule;
}
void set_discount_schedule(mixed *value) {
   discount_schedule = value;
}
int query_letter_cost() {
   return letter_cost;
}
void set_letter_cost(int value) {
   letter_cost = value;
}
void add_print_run(string name, object ob, int number, string language) {
   mixed *arr;
   int num;
   if (!collectables[name]) {
      collectables[name] = ({ });
   }
   arr = allocate(COLLECT_ARR_SIZE);
   arr[COLLECT_TIME] = time() + time_to_collect + time_per_copy * number;
   arr[COLLECT_NUM] = number;
   arr[COLLECT_LANGUAGE] = language;
   arr[COLLECT_OB_NAME] = base_name(ob);
   num = add_auto_load_info(ob->query_static_auto_load(),
                             ob->query_dynamic_auto_load());
   arr[COLLECT_AUTO_LOAD_NUM] = num;
   collectables[name] += ({ arr });
   save_it();
}
mixed *query_print_run(string name) {
   return collectables[name];
}
void remove_print_run(string name, mixed *info) {
   int index;
   if (collectables[name]) {
      index = member_array(info, collectables[name]);
      if (index != -1) {
         remove_auto_load_info(info[COLLECT_AUTO_LOAD_NUM]);
         collectables[name] = collectables[name][0.. index - 1] +
                              collectables[name][index + 1..];
         if (!sizeof(collectables[name])) {
            map_delete(collectables, name);
         }
         save_it();
      }
   }
}
protected int add_auto_load_info(string static, string dynamic) {
   int num;
   num = current_save_number;
   while (unguarded( (: file_size(save_dir + "/" + $(num)) :) ) > 0) {
      num++;
   }
   current_save_number = num + 1;
   unguarded( (: write_file(save_dir + "/" + $(num),
                            save_variable( ({ $(static), $(dynamic) }) ) +
                            "\n") :) );
   return num;
}
private void remove_auto_load_info(int num) {
   unguarded( (: rm(save_dir + "/" + $(num) ) :) );
}
string query_static_auto_load_info(int num) {
   string *arr;
   string tmp;
   if (unguarded( (: file_size(save_dir + "/" + $(num)) :) ) > 0) {
      tmp = unguarded( (: read_file(save_dir + "/" + $(num)) :) );
      if (tmp) {
         arr = restore_variable(tmp);
         return arr[0];
      }
   }
   return 0;
}
mapping query_dynamic_auto_load_info(int num) {
   mixed arr;
   string tmp;
   if (unguarded( (: file_size(save_dir + "/" + $(num)) :) ) > 0) {
      tmp = unguarded( (: read_file(save_dir + "/" + $(num)) :) );
      if (tmp) {
         arr = restore_variable(tmp);
         return arr[1];
      }
   }
   return 0;
}
void set_save_dir(string name) {
   save_dir = name;
}
string query_save_dir() {
   return save_dir;
}
void load_it() {
   if (save_dir) {
      unguarded((: restore_object(save_dir + "/main") :));
      if (!collectables) {
         collectables = ([ ]);
      }
   }
}
void save_it() {
   if (save_dir) {
      unguarded((: save_object(save_dir + "/main") :));
   }
}
void set_office_room(string room) {
   office_room = room;
}
string query_office_room() {
   return office_room;
}
void set_no_collection(int collect) {
   no_collection = collect;
}
int query_no_collection() {
   return no_collection;
}
void set_open_func(function func) {
   open_func = func;
}
function query_open_func() {
   return open_func;
}
void set_default_language(string lang) {
   default_language = lang;
}
string query_default_language() {
   return default_language;
}
void add_translation_cost(string lang, int cost) {
   translation_costs[lang] = cost;
}
void remove_translation_cost(string lang) {
   map_delete(translation_costs, lang);
}
mapping query_all_translantion_costs() {
   return translation_costs;
}
void set_print_shop_name(string name) {
   print_shop_name = name;
}
string query_print_shop_name() {
   return print_shop_name;
}

==================================================
FILE: shops/pub_shop.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/pub";
void create() {
   add_help_file("pub_shop");
   do_setup++;
   basic_room::create();
   pub::create();
   do_setup--;
   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   }
}
void init() {
   basic_room::init();
   pub::init();
}
void dest_me() {
   pub::dest_me();
   basic_room::dest_me();
}

==================================================
FILE: shops/pub_shop_outside.c
==================================================

inherit "/std/room/outside";
inherit "/std/shops/inherit/pub";
void create() {
   add_help_file("pub_shop");
   do_setup++;
   outside::create();
   pub::create();
   do_setup--;
   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   }
}
void init() {
   outside::init();
   pub::init();
}
void dest_me() {
   pub::dest_me();
   outside::dest_me();
}

==================================================
FILE: shops/real_estate_auction.c
==================================================

inherit "/std/shops/auction_house";
#include <housing.h>
#include <money.h>
#include <move_failures.h>
#include <room/auction.h>
#include <nomic_system.h>
#include <morpork.h>
#define AUCTION_LENGTH (3600*24*5)
#define NEW_AGREEMENT_COST 4000
#define REAL_ESTATE_NEW_LOT_BIDDING "new_low_bidding"
private nosave string* _areas;
private nosave string _city;
private nosave string _language;
int add_house(string house);
int check_can_bid(object person,
                  class auction which,
                  int bid_amount);
void create() {
   _areas = ({ });
   _city = "Ankh-Morpork";
   _language = "morporkian";
   ::create();
   add_help_file("real_estate");
}
void reset()
{
   call_out("after_reset", 10);
}
void add_housing_area(string area) {
   _areas += ({ area });
}
string* query_housing_areas() {
   return _areas;
}
void after_reset()
{
   string house;
   string *available;
   int i;
   string area;
   foreach (area in _areas) {
      available = HOUSING->query_vacant(area);
      if (sizeof(available)) {
        i = 1;
        foreach(house in available) {
          call_out("add_house", i++, house);
        }
      }
   }
}
int add_house(string house)
{
   object agreement;
   string text;
   int tim;
   if (member_array(house, keys(HOUSING->query_houses())) == -1) {
      return 0;
   }
   if(lower_case(HOUSING->query_owner(house)) != "for sale") {
     log_file("REAS", ctime(time()) + ": attempt to add house %s that's "
              "not for sale.\n", house);
     return 0;
   }
   HOUSING->set_rent(house, 0);
   agreement = clone_object(AGREEMENT);
   agreement->set_city(_city);
   agreement->set_language(_language);
   agreement->set_house(house);
   text = HOUSING->query_address(house);
   tim = query_last_auction_finish_time();
   if (tim + 60 * 60 < time() + query_auction_times()["very long"]) {
      tim = 0;
   } else {
      tim = tim + 60 * 60 - time();
   }
   if (add_item_to_auction(({ agreement }), text,
                           400, "Patrician", tim,
                           "housing_auction", house)) {
      HOUSING->set_under_offer(house);
      broadcast_shop_event(REAL_ESTATE_NEW_LOT_BIDDING, this_player(),
                           house);
      log_file("REAS", ctime(time()) + ": Added house %s\n", house);
      return 1;
   }
}
void housing_auction(int event_type,
                     class auction auct,
                     string house,
                     string buyer,
                     int cost,
                     object *obs)
{
   object book;
   switch (event_type) {
   case AUCTION_WITHDRAW_PHASE:
     if(lower_case(HOUSING->query_owner(house)) != "under offer") {
       write("House is not currently under offer!\n");
       log_file("REAS", ctime(time()) + ": attempted to withdraw %s when it "
                "was not 'Under Offer'.\n", house);
     } else {
       HOUSING->set_for_sale(house);
       log_file("REAS", ctime(time()) + ": %s back to For Sale.\n", house);
     }
     break;
   case AUCTION_CLAIM_PHASE:
      HOUSING->set_owner(house, buyer);
      HOUSING->set_value(house, cost);
      obs[0]->set_city(_city);
      obs[0]->set_language(_language);
      obs[0]->set_house(house);
      log_file("REAS", ctime(time()) + ": %O sold to %O for %O.\n",
               house, buyer,
               MONEY_HAND->money_value_string(cost, query_property("place")));
      book = clone_object(BOOK);
      if (book) {
         if (book->move(this_player()) != MOVE_OK) {
            book->move(this_object());
         }
      }
      write("A nice new house owner's guide pops up for you.\n");
      break;
   }
}
int do_agreement()
{
   string *houses;
   int i;
   string place;
   place = query_property("place");
   if (this_player()->query_value_in(place) < NEW_AGREEMENT_COST) {
      add_failed_mess("You need " +
                      MONEY_HAND->
                      money_value_string(NEW_AGREEMENT_COST,
                                         place) +
                      " to get a new agreement.\n");
      return 0;
   }
   houses = filter(keys(HOUSING->query_houses()),
                   (: HOUSING->query_owner($1) == $2 :),
                   this_player()->query_name());
   if (!sizeof(houses)) {
      add_failed_mess("You are not renting any houses.\n");
      return 0;
   }
   for (i = 0; i < sizeof(houses); i++) {
      printf("%c) %s %s\n", i + 'A',
             HOUSING->query_address(houses[i]),
             HOUSING->query_region(houses[i]));
   }
   write("It will cost you " + MONEY_HAND->
                      money_value_string(NEW_AGREEMENT_COST,
                                         place) + " for a new "
         "agreement.\n");
   write("Which house to choose? ");
   input_to("new_agreement_choice", 0, houses);
   add_succeeded_mess(({ "",
                         "$N enquires about a new rental agreement.\n" }));
   return 1;
}
protected void new_agreement_choice(string choice,
                          string *houses)
{
   int index;
   object agreement;
   string place;
   place = query_property("place");
   choice = lower_case(choice);
   if (!strlen(choice)) {
      write("Ok, canceling agreement check.\n");
      return;
   }
   index = choice[0] - 'a';
   if (index < 0 || index >= sizeof(houses)) {
      write("Choice out of bounds.\n");
      return;
   }
   if (this_player()->query_value_in(place) < NEW_AGREEMENT_COST) {
      add_failed_mess("You need " +
                      MONEY_HAND->
                      money_value_string(NEW_AGREEMENT_COST,
                                         place) +
                      " to get a new agreement.\n");
      return 0;
   }
   this_player()->pay_money(MONEY_HAND->
                            create_money_array(NEW_AGREEMENT_COST, place));
   agreement = clone_object(AGREEMENT);
   agreement->set_city(_city);
   agreement->set_language(_language);
   agreement->set_house(houses[index]);
   if (agreement->move(this_player()) != MOVE_OK) {
      write("Unable to move the agreement into your inventory.\n");
      return 0;
   }
   write("Created a new agreement for " +
         HOUSING->query_address(houses[index]) + ".\n");
}
int check_can_bid(object person,
                  class auction which,
                  int bid_amount)
{
   int total_money,
     total_bids;
   string *accounts;
   string account;
   class auction auction;
   accounts = "/obj/handlers/bank_handler"->query_accounts(person->
                                                           query_name());
   foreach(account in accounts) {
      total_money += "/obj/handlers/bank_handler"->query_account(person->
                                                                 query_name(),
                                                                 account);
   }
   foreach(auction in query_auctions()) {
      if (auction->current_bidder &&
          lower_case(auction->current_bidder) == person->query_name()) {
         total_bids += auction->bid;
      }
   }
   if (total_bids + bid_amount > total_money * 3) {
      add_failed_mess
         ("You do not have sufficient funds in your bank accounts "
          "to cover such a bid.\n");
      return 0;
   }
   return 1;
}
void init()
{
   ::init();
   add_command("request", "[agreement]", (: do_agreement() :));
}
void reset_auctions_to_under_offer() {
    class auction auc;
    foreach( auc in query_auctions() ) {
        HOUSING->set_under_offer(auc->extra);
    }
}
void set_city( string where ) {
    _city = where;
}
void set_language( string lang ) {
    _language = lang;
}
string query_city() {
    return _city;
}
string query_language() {
    return _language;
}
mixed *stats() {
  return ::stats() +
    ({
        ({ "areas", _areas }),
        ({ "city", _city }),
        ({ "language", _language }),
    });
}

==================================================
FILE: shops/sign_writer.c
==================================================

inherit "/std/room/basic_room";
#include <money.h>
#include <move_failures.h>
#define SIGN_MAKING_PICK_UP_TIME (24 * 60 * 60)
class sign_type {
   string short;
   string long;
   int cost;
   int weight;
   int max_letters;
   int max_lines;
}
class sign_making {
   int type;
   string mess;
   string colour;
   int pick_up;
}
private nosave class sign_type* _signtypes;
private nosave mapping _paintcolours;
private nosave string _save_file;
private nosave string _language;
private nosave function _open_func;
private mapping _signs;
void do_load();
void create() {
   _signtypes = ({ });
   _paintcolours = ([ ]);
   _signs = ([ ]);
   ::create();
   do_load();
   add_help_file("sign_writer");
}
int is_open() {
   if (_open_func) {
      return evaluate(_open_func);
   }
   return 1;
}
void set_open_func(function func) {
   _open_func = func;
}
function query_open_func() {
   return _open_func;
}
void set_language(string lang) {
   _language = lang;
}
string query_language() {
   return _language;
}
void set_save_file_name(string save) {
   _save_file = save;
}
string query_save_file_name() {
   return _save_file;
}
void do_save() {
   if (_save_file) {
      save_object(_save_file);
   }
}
void do_load() {
   if (_save_file) {
      restore_object(_save_file);
   }
}
void add_paint_colour(string colour, int cost) {
   _paintcolours[colour] = cost;
}
void add_sign_type(string short, string long, int cost,
                   int weight, int max_letters, int max_lines) {
   class sign_type bing;
   bing = new(class sign_type);
   bing->short = short;
   bing->long = long;
   bing->cost = cost;
   bing->weight = weight;
   bing->max_letters = max_letters;
   bing->max_lines = max_lines;
   _signtypes += ({ bing });
}
void add_sign_making(string owner, int type, string mess,
                     string colour, int pick_up) {
   class sign_making bing;
   bing = new(class sign_making);
   bing->type = type;
   bing->mess = mess;
   bing->colour = colour;
   bing->pick_up = pick_up;
   if (!_signs[owner]) {
      _signs[owner] = ({ });
   }
   _signs[owner] += ({ bing });
   do_save();
}
int do_order(string type) {
   int pos;
   int cost;
   string place;
   if (!is_open()) {
      add_failed_mess(the_short() + " is not currently open.\n");
      return 0;
   }
   if (strlen(type) == 1) {
      pos = lower_case(type)[0] - 'a';
      if (pos < 0 || pos > sizeof(_signtypes)) {
         add_failed_mess("The id must be between 'a' and '" +
               sprintf("%c", 'a' + sizeof(_signtypes) - 1) + "'.\n");
         return 0;
      }
   } else {
      add_failed_mess("The id must be between 'a' and '" +
            sprintf("%c", 'a' + sizeof(_signtypes) - 1) + "'.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   cost = _signtypes[pos]->cost;
   if (cost > this_player()->query_value_in(place)) {
      add_failed_mess("You do not have enough money to pay for this "
            "sign.  You "
            "need " + MONEY_HAND->money_value_string(cost, place) +
            ".\n");
      return 0;
   }
   write("Using a sign of type " + _signtypes[pos]->short +
         ".  What message would "
         "you like on your sign?\n");
   this_player()->do_edit("", "finish_editing_message", this_object(),
                          0, pos);
   add_succeeded_mess(({ "",
                         "$N looks into getting a sign made up.\n" }));
   return 1;
}
void finish_editing_message(string mess, int type) {
   string colour;
   int cost;
   string place;
   class sign_type bing;
   if (!mess) {
      write("Aborting sign writing process.\n");
      return ;
   }
   bing = _signtypes[type];
   if (strlen(replace(mess, ({ "\n", "", }))) > bing->max_letters) {
      write("The message " + mess + " has too many letters for the "
            "sign " + bing->short + ", the most allowed is " +
            bing->max_letters + ", you have " +
            strlen(replace(mess, ({ "\n", "", }))) +
            ".\n");
      return ;
   }
   if (sizeof(explode(mess, "\n")) > bing->max_lines) {
      write("The message " + mess + " has too many lines for the "
            "sign " + bing->short + ", the most allowed is " +
            bing->max_lines + ", you have " +
            sizeof(explode(mess, "\n")) +
            ".\n");
      return ;
   }
   write("You have selected a sign of type " + bing->short + " and have "
         "decided to put the message:\n" + mess + "\nonto the sign.\n"
         "Paint colours are:\n");
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   foreach (colour, cost in _paintcolours) {
      write(sprintf("%-20s %s per letter\n", colour,
            MONEY_HAND->money_value_string(cost, place)));
   }
   write("What colour paint would you like? ");
   input_to("finish_sign", 0, type, mess);
}
void finish_sign(string colour, int type, string mess) {
   int cost;
   string place;
   class sign_type bing;
   colour = lower_case(colour);
   bing = _signtypes[type];
   if (!strlen(colour)) {
      write("Aborting the sign process.\n");
      return ;
   }
   if (!_paintcolours[colour]) {
      write("I am sorry, we do not stock " + colour + ".\n");
      write("Try one of " +
            query_multiple_short(keys(_paintcolours)) + ".\n");
      write("What colour paint would you like? ");
      input_to("finish_sign", 0, type, mess);
      return ;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   cost = _paintcolours[colour] *
          strlen(replace(mess, ({ "\n", "", " ", "" })));
   cost += bing->cost;
   if (cost > this_player()->query_value_in(place)) {
      write("You do not have enough money to pay for this sign.  You "
            "need " + MONEY_HAND->money_value_string(cost, place) +
            ".\n");
      return ;
   }
   write("Making a sign of type " + bing->short + " with a message of:\n" +
         mess + "\nWill cost " +
         MONEY_HAND->money_value_string(cost, place) +
         ".\nDo you wish to make this sign? ");
   input_to("validate_sign", 0, type, mess, colour, cost);
}
void validate_sign(string choice, int type, string mess,
                   string colour, int cost) {
   int pick_up;
   string place;
   class sign_type bing;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (cost > this_player()->query_value_in(place)) {
      write("You do not have enough money to pay for this sign.  You "
            "need " + MONEY_HAND->money_value_string(cost, place) +
            ".\n");
      return ;
   }
   bing = _signtypes[type];
   choice = lower_case(choice);
   if (!strlen(choice) || (choice[0] != 'n' && choice[0] != 'y')) {
      write("You did not enter 'yes' or 'no'.  Please try again.\n");
      write("Making a sign of type " + bing->short + " with a message of:\n" +
            mess + "\nWill cost " +
            MONEY_HAND->money_value_string(cost, place) +
            ".\nDo you wish to make this sign? ");
      input_to("validate_sign", 0, type, mess, colour);
      return 0;
   }
   this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
               cost, place ), place );
   pick_up = time() + SIGN_MAKING_PICK_UP_TIME;
   add_sign_making(this_player()->query_name(), type, mess, colour,
                   pick_up);
   write("Ok, we will start making your sign.  Please come "
         "back tomorrow (after " + ctime(pick_up) +
         ") to pick up your sign.\n");
}
int do_collect() {
   class sign_making sign;
   class sign_type type;
   object* ok;
   string* not_yet;
   string* bits;
   object ob;
   if (!is_open()) {
      add_failed_mess(the_short() + " is not currently open.\n");
      return 0;
   }
   if (!_signs[this_player()->query_name()]) {
      add_failed_mess("You have no signs to pick up.\n");
      return 0;
   }
   ok = ({ });
   not_yet = ({ });
   foreach (sign in _signs[this_player()->query_name()]) {
      if (time() > sign->pick_up) {
         type = _signtypes[sign->type];
         ob = clone_object("/std/room/furniture/basic");
         bits = explode(type->short, " ");
         ob->set_name(bits[<1]);
         ob->add_adjective(bits[0..<2]);
         ob->set_short(type->short);
         ob->set_long(type->long);
         ob->set_weight(type->weight);
         ob->add_read_mess(sign->mess, sign->colour + " paint",
                           query_language(), 1);
         ob->add_property("sign");
         if (ob->move(this_player()) != MOVE_OK) {
            ob->move(this_object());
         }
         ok += ({ ob });
      } else {
         not_yet += ({ _signtypes[sign->type]->short + " with " +
                       sign->colour + " letters" });
      }
   }
   if (sizeof(ok)) {
      add_succeeded_mess("$N pick$s up $I.\n", ok);
      return 1;
   }
   if (sizeof(not_yet) == 1) {
      add_failed_mess("The sign " + query_multiple_short(not_yet) +
                      " is not ready to be picked up yet.\n");
   } else {
      add_failed_mess("The signs " + query_multiple_short(not_yet) +
                      " are not ready to be picked up yet.\n");
   }
   return 0;
}
int do_browse(string type) {
   class sign_type bing;
   string place;
   int pos;
   if (!is_open()) {
      add_failed_mess(the_short() + " is not currently open.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (strlen(type) == 1) {
      pos = lower_case(type)[0] - 'a';
      if (pos < 0 || pos > sizeof(_signtypes)) {
         add_failed_mess("The id must be between 'a' and '" +
               sprintf("%c", 'a' + sizeof(_signtypes) - 1) + "'.\n");
         return 0;
      }
   } else {
      add_failed_mess("The id must be between 'a' and '" +
            sprintf("%c", 'a' + sizeof(_signtypes) - 1) + "'.\n");
      return 0;
   }
   bing = _signtypes[pos];
   write("The sign of type " + type + " has a short description of '" +
         bing->short + "' and a long description:\n" + bing->long +
         "\nIt will cost " +
         MONEY_HAND->money_value_string(bing->cost, place) +
         " and will take a maximum of " + bing->max_letters +
         " letters and a maximum number of lines of " +
         bing->max_lines + ".\n");
   add_succeeded_mess(({ "", "$N browses a sign in " + the_short() +
                             ".\n" }));
   return 1;
}
int do_list() {
   class sign_type bing;
   int i;
   string ret;
   string place;
   string colour;
   int cost;
   if (!is_open()) {
      add_failed_mess(the_short() + " is not currently open.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   ret = "Signs availabe:\n";
   for (i = 0; i < sizeof(_signtypes); i++) {
      bing = _signtypes[i];
      ret += "$I$7=   " + sprintf("%c", 'a' + i) +
             ") " + bing->short + " costs " +
         MONEY_HAND->money_value_string(bing->cost, place) +
         " with " + bing->max_letters + " characters and " +
         bing->max_lines + " lines.\n";
   }
   ret += "\n$I$0=Colours available:\n";
   foreach (colour, cost in _paintcolours) {
      ret += sprintf("$I$7=   %-20s %s per letter\n", colour,
            MONEY_HAND->money_value_string(cost, place));
   }
   write("$P$Sign browse$P$" + ret);
   add_succeeded_mess(({ "", "$N lists the signs in " +
                             the_short() + ".\n" }) );
   return 1;
}
void init() {
   add_command("list", "", (: do_list() :));
   add_command("browse", "<string'sign'>", (: do_browse($4[0]) :));
   add_command("collect", "sign", (: do_collect() :));
   add_command("buy", "<string'sign'>", (: do_order($4[0]) :));
   add_command("order", "<string'sign'>", (: do_order($4[0]) :));
}

==================================================
FILE: shops/storeroom.c
==================================================

#include <config.h>
#ifndef __DISTRIBUTION_LIB__
#include <thief.h>
#endif
inherit "/std/room/basic_room";
mapping room_cont;
int max_num;
int loot;
mapping shop_type;
void create() {
  room_cont = ([ ]);
  shop_type = ([ ]);
  max_num = 8;
  ::create();
  loot = random(10);
  set_keep_room_loaded(1);
  call_out("test_cont", 1);
}
mapping query_room_cont() {
  return room_cont;
}
int query_max_num() { return max_num; }
void set_max_num(int i) { max_num = i; }
void add_thing(object ob) {
  string shr;
  if (!ob || environment(ob) != this_object())
    return ;
  shr = (string)ob->query_property("shop type");
  if (!shop_type[shr])
    shop_type[shr] = ({ ob });
  else
    shop_type[shr] += ({ ob });
  shr = (string)ob->short();
  if (!room_cont[shr]) {
    room_cont[shr] = ({ ob });
    return ;
  }
  if (sizeof(room_cont[shr]) > max_num)
    call_out("do_dest", 1, ob);
  else
    room_cont[shr] += ({ ob });
  return ;
}
void test_cont() {
  int i;
  object *obs;
  obs = all_inventory();
  for (i=0;i<sizeof(obs);i++)
    add_thing(obs[i]);
}
void remove_thing(object ob) {
  mixed *arr;
  int i;
  string sh;
  if (!ob || environment(ob) == this_object())
    return ;
  sh = (string)ob->query_property("shop type");
  if (shop_type[sh])
    shop_type[sh] = (object *)shop_type[sh] - ({ ob });
  sh = (string)ob->short();
  if (!room_cont[sh])
    return ;
  arr = room_cont[sh];
  if ((i = member_array(ob, arr)) == -1)
    return ;
  if (sizeof(arr) <= 1) {
    room_cont = m_delete(room_cont, sh);
  } else
    room_cont[sh] = delete(arr, i, 1);
}
void event_enter(object ob, string, object) {
  call_out("add_thing", 1, ob);
}
void event_exit(object ob, string mesage, object to) {
  call_out("remove_thing", 1, ob);
}
void do_dest( object thing ) {
   if ( !thing )
      return;
   thing->move( "/room/rubbish" );
}
mapping query_shop_type_mapping() { return shop_type; }
int clean_up(int) { return 0; }

==================================================
FILE: shops/vault.c
==================================================

#include <vault.h>
inherit "/std/room/basic_room";
private object _container;
private string _vault_name;
private string _entry;
private string _there;
void set_vault_exit(string direc, mixed dest, string type) {
  _entry = dest;
  add_exit(direc, dest, type);
  modify_exit( direc, ({ "function", "check_done" }) );
  modify_exit( direc, ({ "closed", 1 }) );
}
void set_vault_name(string str) { _vault_name = str; }
object init_container(object person) {
  object container;
  string owner;
  owner = person->query_name();
  container = clone_object( "/obj/cont_save" );
  container->set_max_weight( 1000 );
  container->set_open();
  container->set_stuck( 1 );
  container->set_can_recurse(1);
  container->reset_get();
  container->set_save_file( VAULT_SAVE +_vault_name+ "/"+ owner,
                           person );
  if ( !master()->file_exists( VAULT_SAVE +_vault_name+"/"+ owner +".o" ) ) {
    container->add_property( "owner", owner );
    container->do_save();
  }
  container->move(this_object());
  container->add_property("there", "here");
  this_object()->setup_container(container);
  container->add_property( "owner", owner );
  _there = container->query_property("there");
  return container;
}
void event_enter(object thing, string mess, object from) {
  string owner;
  if( !userp( thing ) )
    return;
  owner = thing->query_name();
  if ( _container ) {
    if((string)_container->query_property( "owner" ) == owner)
      return;
    else if(thing->query_creator() &&
            find_player(_container->query_property( "owner" )) &&
            environment(find_player(_container->query_property( "owner" ))) ==
            this_object())
         return;
      else {
        _container->dest_me();
        _container = 0;
      }
  }
  _container = init_container(thing);
  call_out("fix_owner", 2, owner);
}
void fix_owner(string owner) {
  if (_container) {
     _container->add_property( "owner", owner );
     if(_there) {
       _container->add_property("there", _there);
     }
  }
}
int check_done( string verb, object thing, string special ) {
  if ( thing->query_auto_loading() ) {
    tell_room( this_object(), "The door swings shut.\n" );
    tell_object( thing, "Your vaults's inventory is still being generated.\n"
                "Please wait until it is completed.\n" );
      return notify_fail( "" );
   }
   return 1;
}
void event_exit( object thing, string message, object to ) {
  if(_container && _container->query_property("owner") == thing->query_name()) {
    _container->move("/room/void");
    call_out((: _container->dest_me() :), 1);
  }
  if(interactive(thing))
    thing->save_me();
}
string query_quit_handler() {
  return _entry;
}
void setup_container(object container) {
  container->set_name( "drawer" );
  container->set_short( "drawer" );
  container->add_alias( "drawer" );
  container->set_long("The single open drawer is sticking straight "
                      "out of the wall like...  well, like a drawer sticking "
                      "straight out of the wall.  " );
}
int trap_action( string str ) {
   string st1;
   if( sscanf( str,"%s %s", str, st1 ) );
      switch(str) {
      case "circle":
         tell_object( this_player(),
               "Something tells you that drawing a circle in this location "
               "would be a bad idea.\n");
         return 1;
      case "erect":
         tell_object( this_player(),
               "You can't seem to get the tent to unfold properly.  "
               "Perhaps you should try it somewhere else.\n");
         return 1;
      default:
         return 0;
    }
}
void event_net_dead(object ob) {
   ob->move_with_look(_entry);
}
void init() {
   ::init();
   this_player()->command_override( (: trap_action :) );
}
int query_vault_room() {
   return 1;
}

==================================================
FILE: shops/vault_entry.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/shops/inherit/vault_entry";
void create() {
   add_help_file("vault_entry");
   basic_room::create();
}
void init() {
  basic_room::init();
  vault_entry::init();
}

==================================================
FILE: shops/controllers/craft_shop_controller.c
==================================================

#include <obj_parser.h>
#include <money.h>
#include <move_failures.h>
#include <player.h>
#include <shops/craft_shop.h>
class craft_object {
   int cost;
   string cap_owner;
   int ob_num;
   string category;
   string short;
}
class craft_sellable {
   mapping objects;
}
class craft_category {
   int state;
   string description;
   string information;
   string* voted;
   int yes;
   int no;
   int abstain;
   int timeout;
}
#define SELL_OBJECT_NAME_PROP "sell name"
#define SELL_OBJECT_OWNER_PROP "sell owner"
#define SELL_OBJECT_CLASS_PROP "sell class"
#define SELL_OBJECT_ID_PROP "sell id"
private nosave mapping _sellables;
private nosave object _sell_list;
private nosave mapping _royalties;
private nosave int _current_save_num;
private nosave mapping _categories;
private nosave int _category_callout;
private nosave int _category_dont_use_name;
private nosave function _save_function;
private nosave function _load_function;
private nosave function _category_function;
private nosave int *_current_ids;
private nosave int _has_loaded;
void load_it();
void save_it();
private void update_sellable(string name);
class craft_object create_craft_object(object ob,
                                       string owner,
                                       int cost,
                                       string category);
void adjust_royalty(string player, int amt);
class craft_sellable create_craft_sellable();
void adjust_royalty(string player, int amt);
class craft_object query_class_of_shop_object(object ob);
object find_shop_object(class craft_object frog);
object *query_sell_list_obs();
string query_id_of_shop_object(object ob);
void remove_shop_id(string id);
private void setup_timeout_call();
object* query_items_with_shop_id(string id);
void create() {
   _sell_list = clone_object("/std/container");
   _current_save_num = 1;
   _current_ids = ({ });
   _categories = ([ ]);
}
void set_dont_use_name(int flag) {
   _category_dont_use_name = flag;
}
int query_dont_use_name() {
   return _category_dont_use_name;
}
protected int create_auto_load_file(mixed ob, int fixed_num) {
   mixed *auto_load;
   mixed tmp;
   if (objectp(ob)) {
      if (this_player()) {
         catch(auto_load = this_player()->create_auto_load(({ ob })));
      }
      if (!auto_load) {
         catch(auto_load = PLAYER_OB->create_auto_load(({ ob })));
      }
      if (!auto_load) {
         auto_load = AUTO_LOAD_OB->create_auto_load(({ ob }));
      }
   } else if (pointerp(ob)) {
      auto_load = ob;
   } else {
      printf("Error!  Dammit!\n");
   }
   if (!fixed_num) {
      do {
         tmp = evaluate(_load_function,
                        CRAFT_SHOP_DATA_SAVE_FILE,
                        "" + _current_save_num);
         if (tmp) {
            _current_save_num++;
         }
      } while (tmp);
      fixed_num = _current_save_num;
   }
   evaluate(_save_function,
            CRAFT_SHOP_DATA_SAVE_FILE,
            auto_load,
            "" + fixed_num);
   return fixed_num;
}
protected object create_real_auto_load_object(int num, object player) {
   mixed *auto_load;
   object *obs;
   auto_load = evaluate(_load_function,
                        CRAFT_SHOP_DATA_SAVE_FILE,
                        "" + num);
   if (userp(player)) {
      obs = player->load_auto_load_to_array(auto_load, player);
   } else if (this_player()) {
      obs = this_player()->load_auto_load_to_array(auto_load, player);
   } else {
      obs = PLAYER_OB->load_auto_load_to_array(auto_load, player);
   }
   if (sizeof(obs)) {
      return obs[0];
   }
   return 0;
}
protected void remove_auto_load_file(int num) {
   evaluate(_save_function,
            CRAFT_SHOP_REMOVE_DATA_SAVE_FILE,
            0,
            "" + num);
}
protected void add_to_sellables(string name,
                                string owner,
                                class craft_object *ob) {
   class craft_sellable craft_sell;
   if (_sellables[name]) {
      craft_sell = (class craft_sellable)_sellables[name];
   } else {
      craft_sell = create_craft_sellable();
      _sellables[name] = craft_sell;
   }
   if (!craft_sell->objects[owner]) {
      craft_sell->objects[owner] = ({ });
   }
   craft_sell->objects[owner] += ob;
   update_sellable(name);
}
int add_list_object(object ob,
                    string name,
                    int cost,
                    string owner,
                    string category,
                    int dont_update_cost) {
   class craft_object craft_ob;
   string cap_owner;
   if (!objectp(ob) || !stringp(name) || !intp(cost)) {
      return 0;
   }
   cap_owner = owner;
   owner = lower_case(owner);
   add_to_sellables(name,
                    owner,
                    ({ create_craft_object(ob, cap_owner, cost, category) }));
   if (!dont_update_cost) {
      foreach (craft_ob in ((class craft_sellable)_sellables[name])->objects[owner]) {
         craft_ob->cost = cost;
         craft_ob->category = category;
      }
   }
   save_it();
   return 1;
}
void remove_list_object(string name, string owner, class craft_object ob) {
   int i;
   object us;
   class craft_object *data;
   if (_sellables[name] &&
       ((class craft_sellable)_sellables[name])->objects[owner]) {
      data = ((class craft_sellable)_sellables[name])->objects[owner];
      for (i = 0; i < sizeof(data); i++) {
         if (data[i] == ob) {
            break;
         }
      }
      if (i < sizeof(data)) {
         ((class craft_sellable)_sellables[name])->objects[owner] -= ({ ob });
         if (!sizeof(((class craft_sellable)_sellables[name])->objects[owner])) {
            map_delete(((class craft_sellable)_sellables[name])->objects, owner);
            if (!sizeof(((class craft_sellable)_sellables[name])->objects)) {
               map_delete(_sellables, name);
               us = find_shop_object(ob);
               remove_shop_id(query_id_of_shop_object(us));
            }
         }
         save_it();
         remove_auto_load_file(ob->ob_num);
         us = find_shop_object(ob);
         us->dest_me();
      } else {
         printf("Unable to find the object to remove? %O, %O\n", name, owner);
      }
   }
}
object create_real_object(object player, class craft_object craft) {
   return create_real_auto_load_object(craft->ob_num, player);
}
object *create_all_real_objects(object player, object *obs) {
   object *ret;
   object ob;
   class craft_object craft;
   object new_ob;
   ret = ({ });
   foreach (ob in obs) {
      craft = query_class_of_shop_object(ob);
      new_ob = create_real_object(player, craft);
      if (!new_ob) {
         ret->move("/room/rubbish");
         return ({ });
      }
      ret += ({ new_ob });
   }
   return ret;
}
class craft_object create_craft_object(object ob,
                                       string owner,
                                       int cost,
                                       string category) {
   class craft_object craft;
   int num;
   craft = new (class craft_object);
   num = create_auto_load_file(ob, 0);
   craft->ob_num = num;
   craft->cost = cost;
   craft->cap_owner = owner;
   craft->category = category;
   craft->short = ob->query_short();
   return craft;
}
class craft_sellable create_craft_sellable() {
   class craft_sellable craft;
   craft = new(class craft_sellable);
   craft->objects = ([ ]);
   return craft;
}
string query_owner_of_shop_object(object ob) {
   return ob->query_property(SELL_OBJECT_OWNER_PROP);
}
string query_name_of_shop_object(object ob) {
   return ob->query_property(SELL_OBJECT_NAME_PROP);
}
string query_id_of_shop_object(object ob) {
   return ob->query_property(SELL_OBJECT_ID_PROP);
}
void set_id_of_shop_objects(object *obs, string id) {
   obs->add_property(SELL_OBJECT_ID_PROP, id);
   obs->add_alias(id);
}
string query_category_of_shop_object(object ob) {
   class craft_object craft;
   craft = query_class_of_shop_object(ob);
   if (craft) {
      return craft->category;
   }
   return 0;
}
string query_short_of_shop_object(object ob) {
   class craft_object craft;
   craft = query_class_of_shop_object(ob);
   if (craft) {
      if (sizeof(craft) == 5) {
         return craft->short;
      }
      return "womble";
   }
   return 0;
}
void update_craft_object(object craft_ob, object replacement_ob) {
   class craft_object craft;
   craft = query_class_of_shop_object(craft_ob);
   if (craft) {
      create_auto_load_file(replacement_ob, craft->ob_num);
   }
}
string query_next_shop_id() {
   int num;
   num = 0;
   while (member_array(num, _current_ids) != -1) {
      num++;
   }
   _current_ids += ({ num });
   return sprintf("%c%c", (num / 26) + 'a',
                          (num % 26) + 'a');
}
void remove_shop_id(string id) {
   int real_id;
   real_id = (id[0] * 26) - 'a' + id[1] - 'a';
   _current_ids -= ({ real_id });
}
class craft_object query_class_of_shop_object(object ob) {
   return ob->query_property(SELL_OBJECT_CLASS_PROP);
}
object find_shop_object(class craft_object frog) {
   object ob;
   foreach (ob in query_sell_list_obs()) {
      if (query_class_of_shop_object(ob) == frog) {
         return ob;
      }
   }
   return 0;
}
void change_value_of_shop_object(object ob, int value) {
   string owner;
   string name;
   class craft_object wombat;
   object* obs;
   obs = query_items_with_shop_id(query_id_of_shop_object(ob));
   foreach (ob in obs) {
      owner = query_owner_of_shop_object(ob);
      name = query_name_of_shop_object(ob);
      wombat = query_class_of_shop_object(ob);
      wombat->cost = value;
      ob->set_value(value);
   }
   save_it();
}
int change_name_of_shop_object(object ob, string new_name,
                               int dont_update_cost) {
   string owner;
   string name;
   object* obs;
   string* names;
   class craft_object wombat;
   int new_cost;
   class craft_object* fluff;
   int i;
   obs = query_items_with_shop_id(query_id_of_shop_object(ob));
   names = ({ });
   foreach (ob in obs) {
      owner = query_owner_of_shop_object(ob);
      name = query_name_of_shop_object(ob);
      wombat = query_class_of_shop_object(ob);
      if (!_sellables[name]) {
tell_creator("pinkfish", "The name %O does not exist.\n", name);
         return 0;
      }
      if (!wombat) {
tell_creator("pinkfish", "Unable to find the class.\n");
         return 0;
      }
      if (!dont_update_cost &&
          _sellables[new_name] &&
          (((class craft_sellable)_sellables[new_name])->objects[owner])) {
         new_cost = (((class craft_sellable)_sellables[new_name])->objects[owner])[0]->cost;
         wombat->cost = new_cost;
      }
      if (!_sellables[new_name]) {
         _sellables[new_name] = create_craft_sellable();
      }
      if (!(((class craft_sellable)_sellables[new_name])->objects[owner])) {
         (((class craft_sellable)_sellables[new_name])->objects[owner]) = ({ });
      }
      (((class craft_sellable)_sellables[new_name])->objects[owner]) += ({ wombat });
      fluff = ((class craft_sellable)_sellables[name])->objects[owner];
      for (i = 0; i < sizeof(fluff); i++) {
         if (fluff[i] == wombat) {
            fluff = fluff[0..i-1] + fluff[i+1..];
         }
      }
      if (sizeof(fluff)) {
         ((class craft_sellable)_sellables[name])->objects[owner] = fluff;
      } else {
         map_delete(((class craft_sellable)_sellables[name])->objects, owner);
      }
      if (!sizeof(((class craft_sellable)_sellables[name])->objects)) {
         map_delete(_sellables, name);
      }
      names |= ({ name });
   }
   if (sizeof(names)) {
      update_sellable(name);
      update_sellable(new_name);
      save_it();
      return 1;
   }
   return 0;
}
int change_category_of_shop_object(object ob, string new_category) {
   string owner;
   string name;
   class craft_object bing;
   object* obs;
   int do_save;
   obs = query_items_with_shop_id(query_id_of_shop_object(ob));
   foreach (ob in obs) {
      owner = query_owner_of_shop_object(ob);
      name = query_name_of_shop_object(ob);
      if (!_sellables[name] ||
          !((class craft_sellable)_sellables[name])->objects[owner]) {
         return 0;
      }
      foreach (bing in ((class craft_sellable)_sellables[name])->objects[owner]) {
         bing->category = new_category;
         do_save = 1;
      }
   }
   if (do_save) {
      save_it();
   }
   return 1;
}
void remove_shop_object(object ob) {
   string name;
   string owner;
   owner = query_owner_of_shop_object(ob);
   name = query_name_of_shop_object(ob);
   remove_list_object(name, owner, query_class_of_shop_object(ob));
}
class obj_match find_matching_objects(string str) {
   class obj_match obs;
   obs = (class obj_match)match_objects_in_environments(str, ({ _sell_list }));
   return obs;
}
int value_of_objects(object *obs) {
   object ob;
   class craft_object craft;
   int value;
   foreach (ob in obs) {
      craft = query_class_of_shop_object(ob);
      if (craft) {
         value += craft->cost;
      }
   }
   return value;
}
object *sell_objects(object *obs, string place, object player, int cut) {
   object ob;
   object this_ob;
   object *sold;
   class craft_object craft;
   sold = ({ });
   if (cut < 0) {
      cut = 0;
   }
   if (cut > 100) {
      cut = 100;
   }
   foreach (ob in obs) {
      craft = query_class_of_shop_object(ob);
      if (craft) {
         if (player->query_value_in(place) >= craft->cost) {
            this_ob = create_real_object(player, craft);
            if (this_ob && this_ob->move(player) == MOVE_OK) {
               sold += ({ this_ob });
               player->pay_money(
                       MONEY_HAND->create_money_array(craft->cost, place),
                       place);
               adjust_royalty(query_owner_of_shop_object(ob),
                              craft->cost - (craft->cost * cut) / 100);
               remove_shop_object(ob);
            }
         }
      }
   }
   return sold;
}
void delete_objects( string id ) {
   object ob, *obs;
   obs = all_inventory( _sell_list );
   obs = filter( obs,
         (: $1->query_property( SELL_OBJECT_ID_PROP ) == $(id) :) );
   foreach( ob in obs ) {
      remove_shop_object( ob );
   }
}
object *buy_objects(object *obs,
                    string name,
                    int cost,
                    string owner,
                    string category,
                    int dont_update_costs) {
   object ob;
   object *bought;
   bought = ({ });
   foreach (ob in obs) {
      if (add_list_object(ob, name, cost, owner, category, dont_update_costs)) {
         ob->move("/room/rubbish");
         bought += ({ ob });
      }
   }
   return bought;
}
protected object create_dummy_object(string owner, string name, int cost,
                                     class craft_object craft) {
   object new_name;
   string *bits;
   new_name = clone_object("/std/object");
   new_name->reset_get();
   bits = explode(lower_case(name), " ");
   if (!sizeof (bits)) {
    new_name->set_name("error");
   }
   else {
    new_name->set_name(bits[<1]);
    new_name->add_adjective(bits[0..<2]);
   }
   if (member_array(lower_case(owner), bits) == -1) {
      new_name->add_adjective(owner);
   }
   if (!_category_dont_use_name &&
       member_array(lower_case(owner) + "'s", bits) == -1) {
      new_name->add_adjective(lower_case(owner) + "'s");
      new_name->set_short(craft->cap_owner + "'s " + name);
   } else {
      new_name->set_short(capitalize(name));
   }
   new_name->add_property(SELL_OBJECT_NAME_PROP, name);
   new_name->add_property(SELL_OBJECT_OWNER_PROP, owner);
   new_name->add_property(SELL_OBJECT_CLASS_PROP, craft);
   new_name->add_property("determinate", "");
   new_name->set_value(cost);
   return new_name;
}
private void add_sell_object(object ob) {
   if (ob->move(_sell_list) != MOVE_OK) {
      printf("Unable to move %O into the sell list (%O).\n", ob, _sell_list);
   }
}
object *query_sell_list_obs() {
   return all_inventory(_sell_list);
}
object query_sell_list() {
   return _sell_list;
}
object* query_items_with_shop_id(string id) {
   return filter(query_sell_list_obs(), (: query_id_of_shop_object($1) == $2 :),
                 id);
}
private void update_sellable(string name) {
   string owner;
   class craft_sellable bing;
   mixed *data;
   class craft_object womble;
   class craft_object craft;
   object shop_ob;
   string id;
   mixed *need_ids;
   int cost;
   mapping costs;
   int pos;
   if (_sellables[name]) {
      bing = _sellables[name];
      costs = ([ ]);
      foreach (owner, data in bing->objects) {
         id = 0;
         data = filter(data, (: $1 :));
         bing->objects[owner] = data;
         pos = 0;
         foreach (womble in data) {
            if (sizeof(womble) == 4) {
               craft = new(class craft_object);
               craft->ob_num = womble->ob_num;
               craft->cost = womble->cost;
               craft->cap_owner = womble->cap_owner;
               craft->category = womble->category;
               craft->short = "womble";
               data[pos] = craft;
            }
            pos++;
            shop_ob = find_shop_object(womble);
            if (!shop_ob ||
                query_name_of_shop_object(shop_ob) != name) {
               if (shop_ob) {
                  shop_ob->move("/room/rubbish");
               }
               add_sell_object(create_dummy_object(owner, name,
                                                   womble->cost, womble));
            }
            shop_ob = find_shop_object(womble);
            if (!costs[womble->cost]) {
               costs[womble->cost] = ({ 0, ({ }) });
            }
            if (!costs[womble->cost][0]) {
               id = query_id_of_shop_object(shop_ob);
               if (id) {
                  costs[womble->cost][0] = id;
               }
            }
            if (!costs[womble->cost][0] ||
                query_id_of_shop_object(shop_ob) != costs[womble->cost][0]) {
               costs[womble->cost][1] += ({ shop_ob });
            }
         }
         if (!_category_dont_use_name) {
            foreach (cost, need_ids in costs) {
               if (!need_ids[0]) {
                  need_ids[0] = query_next_shop_id();
               }
               set_id_of_shop_objects(need_ids[1], need_ids[0]);
            }
         }
      }
      if (_category_dont_use_name) {
         foreach (cost, need_ids in costs) {
            if (!need_ids[0]) {
               need_ids[0] = query_next_shop_id();
            }
            set_id_of_shop_objects(need_ids[1], need_ids[0]);
         }
      }
   }
}
string *query_owner_sellables(string owner) {
   class craft_sellable sell;
   mixed *womble;
   string *ret;
   string name;
   ret = ({ });
   foreach (name, sell in _sellables) {
      if (sell->objects[owner]) {
         womble = sell->objects[owner];
         ret += allocate(sizeof(womble), (: $(name) :) );
      }
   }
   return ret;
}
int query_list_object_cost(string name, string owner) {
   class craft_sellable sell;
   class craft_object wombat;
   owner = lower_case(owner);
   if (_sellables[name]) {
      sell = _sellables[name];
      if (sell->objects[owner]) {
         wombat = sell->objects[owner][0];
         return wombat->cost;
      }
   }
   return 0;
}
void set_save_function(function func) {
   _save_function = func;
}
void set_load_function(function func) {
   _load_function = func;
}
void set_category_function(function func) {
   _category_function = func;
}
void save_it() {
   if (_has_loaded) {
      evaluate(_save_function, CRAFT_SHOP_MAIN_SAVE_FILE,
            ({ _sellables, _royalties, _current_save_num, _categories }) );
   }
}
void load_it() {
   mixed *map;
   string name;
   _has_loaded = 1;
   map = evaluate(_load_function, CRAFT_SHOP_MAIN_SAVE_FILE);
   if (pointerp(map) && sizeof(map) == 3) {
      _sellables = map[0];
      _royalties = map[1];
      _current_save_num = map[2];
      foreach (name in keys(_sellables)) {
         reset_eval_cost();
         update_sellable(name);
      }
   } else if (pointerp(map) && sizeof(map) == 4) {
      _sellables = map[0];
      _royalties = map[1];
      _current_save_num = map[2];
      _categories = map[3];
      foreach (name in keys(_sellables)) {
         reset_eval_cost();
         update_sellable(name);
      }
   } else {
      _sellables = ([ ]);
      _royalties = ([ ]);
   }
   setup_timeout_call();
}
void adjust_royalty(string player, int amt) {
   _royalties[player] += amt;
   save_it();
}
int query_royalty(string player) {
  return _royalties[player];
}
mapping query_all_royalties() {
   return copy(_royalties);
}
void pay_out_royalty(string player, string place, int amount) {
   object pl;
   pl = find_player(player);
   if (pl && _royalties[player]) {
      if (!amount) {
         amount = _royalties[player];
      }
      pl->adjust_money(MONEY_HAND->create_money_array(amount, place));
      _royalties[player] -= amount;
      if (!_royalties[player]) {
         map_delete(_royalties, player);
      }
      save_it();
   }
}
int is_valid_category(string category) {
   if (_categories[category] &&
       (_categories[category]->state == CRAFT_CATEGORY_STATE_ACCEPTED ||
        _categories[category]->state == CRAFT_CATEGORY_STATE_DELETEING)) {
      return 1;
   }
   return 0;
}
int add_category_request(string name,
                         object player,
                         int timeout) {
   if (!_categories[name]) {
      _categories[name] = new(class craft_category);
      _categories[name]->state = CRAFT_CATEGORY_STATE_NOMINATING;
      _categories[name]->voted = ({ player->query_name() });
      _categories[name]->description = 0;
      _categories[name]->yes = 0;
      _categories[name]->no = 0;
      _categories[name]->timeout = time() + timeout;
      save_it();
      return 1;
   }
   return 0;
}
int remove_category_accepted(string category) {
   if (_categories[category]) {
      map_delete(_categories, category);
      save_it();
      return 1;
   }
   return 0;
}
int add_category_accepted(string name) {
   if (!_categories[name]) {
      _categories[name] = new(class craft_category);
      _categories[name]->state = CRAFT_CATEGORY_STATE_ACCEPTED;
      _categories[name]->voted = ({ });
      _categories[name]->description = 0;
      _categories[name]->yes = 0;
      _categories[name]->no = 0;
      _categories[name]->timeout = 0;
      save_it();
      return 1;
   }
   return 0;
}
void set_category_description(string cat, string desc) {
   if (_categories[cat]) {
      _categories[cat]->description = desc;
      save_it();
   }
}
string query_category_description(string cat) {
   if (_categories[cat]) {
      if (stringp(_categories[cat]->description)) {
         return _categories[cat]->description;
      }
   }
   return 0;
}
void set_category_information(string cat, string info) {
   if (_categories[cat]) {
      _categories[cat]->information = info;
      save_it();
   }
}
string query_category_information(string cat) {
   if (_categories[cat]) {
      if (stringp(_categories[cat]->information)) {
         return _categories[cat]->information;
      }
   }
}
string query_category_of(string name, string owner) {
   if (_sellables[name] &&
       sizeof( ((class craft_sellable)_sellables[name])->objects[owner])) {
      return ((class craft_sellable)_sellables[name])->objects[owner][0]->category;
   }
   return 0;
}
int has_voted_for_category(string name,
                           object player) {
   return _categories[name] &&
       member_array(player->query_name(), _categories[name]->voted) != -1;
}
int query_category_timeout(string name) {
   if (_categories[name]) {
      return _categories[name]->timeout;
   }
   return CRAFT_CATEGORY_ERROR;
}
int vote_for_category(string name,
                      object player,
                      int choice) {
   if (_categories[name]) {
      if (!has_voted_for_category(name, player)) {
         if (choice == CRAFT_CATEGORY_CHOICE_YES ||
             choice == CRAFT_CATEGORY_CHOICE_NO ||
             choice == CRAFT_CATEGORY_CHOICE_ABSTAIN) {
            switch (choice) {
            case CRAFT_CATEGORY_CHOICE_YES :
               _categories[name]->yes++;
               break;
            case CRAFT_CATEGORY_CHOICE_NO :
               _categories[name]->no++;
               break;
            case CRAFT_CATEGORY_CHOICE_ABSTAIN :
               _categories[name]->abstain++;
               break;
            }
            _categories[name]->voted += ({ player->query_name() });
            save_it();
         }
      }
   }
   return 0;
}
string* query_categories() {
   return filter(keys(_categories), (: is_valid_category($1) :));
}
private void do_timeout_categories() {
   string name;
   class craft_category cat;
   int timeout;
   foreach (name, cat in _categories) {
      if (cat->state != CRAFT_CATEGORY_STATE_ACCEPTED &&
          cat->timeout &&
          cat->timeout < time()) {
         timeout = evaluate(_category_function,
                            cat->state,
                            cat->voted,
                            cat->yes,
                            cat->no,
                            cat->abstain);
         if (timeout) {
            cat->voted = ({ });
            cat->yes = 0;
            cat->no = 0;
            switch (cat->state) {
            case CRAFT_CATEGORY_STATE_NOMINATING :
               cat->state = CRAFT_CATEGORY_STATE_VOTING;
               cat->timeout = time() + timeout;
               break;
            case CRAFT_CATEGORY_STATE_VOTING :
               cat->state = CRAFT_CATEGORY_STATE_ACCEPTED;
               cat->timeout = 0;
               break;
            case CRAFT_CATEGORY_STATE_DELETEING :
               map_delete(_categories, name);
               break;
            }
         } else {
            switch (cat->state) {
            case CRAFT_CATEGORY_STATE_VOTING :
            case CRAFT_CATEGORY_STATE_NOMINATING :
               map_delete(_categories, name);
               break;
            case CRAFT_CATEGORY_STATE_DELETEING :
               cat->state = CRAFT_CATEGORY_STATE_ACCEPTED;
               cat->timeout = 0;
               cat->voted = ({ });
               cat->yes = 0;
               cat->no = 0;
               break;
            }
         }
      }
   }
   save_it();
   setup_timeout_call();
}
private void setup_timeout_call() {
   string name;
   class craft_category cat;
   int bing;
   foreach (name, cat in _categories) {
      if (cat->state != CRAFT_CATEGORY_STATE_ACCEPTED &&
          cat->timeout != 0 &&
          cat->timeout < bing) {
         bing = cat->timeout;
      }
   }
   if (_category_callout) {
      remove_call_out(_category_callout);
   }
   if (bing) {
      _category_callout = call_out((: do_timeout_categories() :), bing);
   }
}
void dest_me() {
  if(_sell_list) {
    all_inventory(_sell_list)->move("/room/rubbish");
    _sell_list->dest_me();
  }
  destruct(this_object());
}

==================================================
FILE: shops/inherit/auction_house.c
==================================================

#include <room/auction.h>
#include <player.h>
#include <money.h>
#include <move_failures.h>
#include <mail.h>
#include <player_handler.h>
#include <am_time.h>
inherit "/std/shops/inherit/shop_event";
inherit "/std/shops/inherit/open_shop";
#define DEFAULT_QUICK_AUCTION_LENGTH (15 * 60)
#define DEFAULT_SHORT_AUCTION_LENGTH (60 * 60)
#define DEFAULT_MEDIUM_AUCTION_LENGTH (AM_SECONDS_PER_DAY)
#define DEFAULT_LONG_AUCTION_LENGTH (AM_SECONDS_PER_DAY * 3)
#define DEFAULT_VERY_LONG_AUCTION_LENGTH (AM_SECONDS_PER_DAY * 14)
#define DEFAULT_RETRIEVAL_TIME (AM_SECONDS_PER_DAY * 7)
#define DEFAULT_EXTENSION_TIME (20 * 60)
class auction {
   mixed save_stuff;
   int time_started;
   int auction_length;
   string name;
   string seller;
   string current_bidder;
   int bid;
   int reserve;
   int retries;
   string end_function;
   mixed extra;
}
private nosave mixed* _auction_obs;
private nosave int _callout_id;
private nosave string _save_file;
private nosave int _max_auctions;
private nosave mapping _auction_times;
private nosave int _retrieval_time;
private nosave int _max_retries;
private nosave int _cut;
private nosave int _minimum_bid_increase;
private nosave function _can_bid;
private nosave int _allow_add;
private nosave string _bid_type_names;
private class auction* _auctions;
private class auction* _finished_auctions;
private mapping _royalties;
void next_auction_finish();
mixed query_property(string name);
class auction query_auction_item(string id);
void retry_auction(class auction auction);
void create() {
   _auctions = ({ });
   _finished_auctions = ({ });
   _cut = 10;
   _max_auctions = 20;
   _auction_obs = ({ });
   _royalties = ([ ]);
   _auction_times = ([
                      "quick" : DEFAULT_QUICK_AUCTION_LENGTH,
                      "short" : DEFAULT_SHORT_AUCTION_LENGTH,
                      "medium" : DEFAULT_MEDIUM_AUCTION_LENGTH,
                      "long" : DEFAULT_LONG_AUCTION_LENGTH,
                      "very long" : DEFAULT_VERY_LONG_AUCTION_LENGTH
                    ]);
   _retrieval_time = DEFAULT_RETRIEVAL_TIME;
   _max_retries = 5;
   _minimum_bid_increase = 10;
   _allow_add = 1;
   shop_event::create();
}
class auction *query_auctions() { return copy(_auctions); }
class auction *query_finished_auctions() { return copy(_finished_auctions); }
void load_me() {
   unguarded( (: restore_object(_save_file, 1) :));
   _auction_obs = allocate(sizeof(_auctions));
   if (!_royalties) {
      _royalties = ([ ]);
   }
   next_auction_finish();
}
void save_me() {
   unguarded( (: save_object(_save_file) :));
}
void set_save_file(string fname) {
   _save_file = fname;
   load_me();
}
string query_save_file() {
   return _save_file;
}
void set_check_can_bid(function f) {
   _can_bid = f;
}
void set_allowed_add(int flag) {
   _allow_add = flag;
}
void set_max_auctions(int i) { _max_auctions = i; }
void set_auction_time(string index, int i) {
   if (!i) {
      map_delete(_auction_times, index);
   } else {
      if (!_auction_times[index]) {
         _bid_type_names = 0;
      }
      _auction_times[index] = i;
   }
}
mapping query_auction_times() { return _auction_times; }
void set_retrieval_time(int i) { _retrieval_time = i; }
void set_max_retries(int i) { _max_retries = i; }
void set_min_bid_increase(int i) { _minimum_bid_increase = i; }
int add_item_to_auction(object* obs, string name, int reserve,
                        string seller, int length,
                         string end_function, mixed extra) {
   class auction new_auct;
   if (sizeof(_auctions) + sizeof(_finished_auctions) >= _max_auctions) {
      return 0;
   }
   if (!reserve) {
      reserve = 40;
   }
   new_auct = new(class auction);
   new_auct->save_stuff = AUTO_LOAD_OB->create_auto_load(obs);
   new_auct->name = name;
   new_auct->reserve = reserve;
   new_auct->end_function = end_function;
   new_auct->time_started = time();
   if (!length) {
      new_auct->auction_length = _auction_times["very long"];
   } else {
      new_auct->auction_length = length;
   }
   new_auct->seller = seller;
   new_auct->extra = extra;
   _auctions += ({ new_auct });
   _auction_obs += ({ obs });
   save_me();
   next_auction_finish();
   _auction_obs -= ({ obs });
   _auction_obs += ({ 0 });
   return 1;
}
object* query_auction_objects(class auction auct) {
   int i;
   for (i = 0; i < sizeof(_auctions); i++) {
      if (_auctions[i] == auct) {
         if (!_auction_obs[i]) {
            _auction_obs[i] = AUTO_LOAD_OB->load_auto_load_to_array(auct->save_stuff);
         }
         return _auction_obs[i];
      }
   }
   return ({ });
}
void bid_on_item(class auction auct,
                 int bid, string person) {
    if (bid > auct->bid && bid >= auct->reserve) {
        auct->bid = bid;
        auct->current_bidder = person;
        if (auct->auction_length + auct->time_started - time() <
            DEFAULT_EXTENSION_TIME) {
            auct->auction_length = time() - auct->time_started +
                DEFAULT_EXTENSION_TIME;
        }
    }
}
int reset_bid(string id, int bid, string person) {
  class auction auct;
  if(!(this_player()->query_lord()))
    return 0;
  auct = query_auction_item(id);
  if(!auct)
    return 0;
  auct->bid = bid;
  auct->current_bidder = person;
  return 1;
}
void remove_finished_auction_item(class auction auction) {
   int i;
   for (i = 0; i < sizeof(_finished_auctions); i++) {
      if (_finished_auctions[i] == auction) {
         _finished_auctions = _finished_auctions[0..i-1] + _finished_auctions[i+1..];
      }
   }
}
void remove_auction_item(class auction auction) {
   int i;
   for (i = 0; i < sizeof(_auctions); i++) {
      if (_auctions[i] == auction) {
         if (i < sizeof(_auction_obs) && _auction_obs[i]) {
            ((_auction_obs[i]) - ({ 0 }))->move("/room/rubbish");
         }
         _auctions = _auctions[0..i-1] + _auctions[i+1..];
         _auction_obs = _auction_obs[0..i-1] + _auction_obs[i+1..];
      }
   }
}
void finish_auction(class auction auction) {
   string place;
   if (auction->end_function) {
      call_other(this_object(), auction->end_function,
                 AUCTION_FINISH_PHASE, auction, auction->extra,
                 auction->current_bidder, auction->bid);
   }
   place = query_property("place");
   remove_auction_item(auction);
   if (!auction->current_bidder) {
      auction->current_bidder = auction->seller;
      auction->bid = 4000;
   }
   _finished_auctions += ({ auction });
   save_me();
   if (auction->current_bidder &&
       PLAYER_HANDLER->test_user(lower_case(auction->current_bidder))) {
      AUTO_MAILER->auto_mail(lower_case(auction->current_bidder),
                              this_object()->query_short(),
                              "Results of auction for " + auction->name,
                              "",
                              "Your auction for " + auction->name +
                              " has completed.\nPlease pay the " +
                              MONEY_HAND->money_value_string(auction->bid, place) +
                              " as soon as you can.\n", 0, auction->current_bidder);
   } else {
      retry_auction(auction);
   }
   return ;
}
void force_finish_auction(string id) {
   string place;
   class auction auction;
   auction = query_auction_item(id);
   if (auction->end_function) {
      call_other(this_object(), auction->end_function,
                 AUCTION_FINISH_PHASE, auction, auction->extra,
                 auction->current_bidder, auction->bid);
   }
   place = query_property("place");
   remove_auction_item(auction);
   if (!auction->current_bidder) {
      auction->current_bidder = auction->seller;
      auction->bid = 4000;
   }
   _finished_auctions += ({ auction });
   save_me();
   if (auction->current_bidder &&
       PLAYER_HANDLER->test_user(lower_case(auction->current_bidder))) {
      AUTO_MAILER->auto_mail(lower_case(auction->current_bidder),
                              this_object()->query_short(),
                              "Results of auction for " + auction->name,
                              "",
                              "Your auction for " + auction->name +
                              " has completed.\nPlease pay the " +
                              MONEY_HAND->money_value_string(auction->bid, place) +
                              " as soon as you can.\n");
   }
   return ;
}
void retry_auction(class auction auction) {
   string place;
   if (auction->end_function) {
      call_other(this_object(), auction->end_function,
                 AUCTION_RETRY_PHASE, auction, auction->extra);
   }
   place = query_property("place");
   remove_finished_auction_item(auction);
   auction->bid = 0;
   auction->current_bidder = 0;
   auction->retries++;
   auction->time_started = time();
   if (auction->retries > _max_retries) {
   } else {
      _auctions += ({ auction });
      _auction_obs += ({ 0 });
   }
   save_me();
   if (auction->seller &&
       PLAYER_HANDLER->test_user(lower_case(auction->seller))) {
      AUTO_MAILER->auto_mail(lower_case(auction->seller),
                              this_object()->query_short(),
                              "Default on auction of " + auction->name,
                              "",
                              "Your auction for " + auction->name +
                              " has completed and the payee defaulted.\n"
                              "The item has been put up for reauctioning.\n");
   }
   return ;
}
class auction query_auction_item(string id) {
   id = lower_case(id);
   if (strlen(id) == 1 &&
       id[0] >= 'a' && id[0] < 'a' + sizeof(_auctions)) {
      return _auctions[id[0] - 'a'];
   }
   return 0;
}
string query_time_end_string(int left) {
   string str;
   string extra;
   if (left >= AM_SECONDS_PER_DAY) {
      str = (left / AM_SECONDS_PER_DAY) + " day";
      if ((left / AM_SECONDS_PER_DAY) > 1) {
         str += "s";
      }
      left = left % (AM_SECONDS_PER_DAY);
      if (left >= (AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR)) {
         if ((left / (AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR)) > 1) {
             extra = "s";
          } else {
             extra = "";
         }
         return str + " and " +
           (left / (AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR)) + " hour" +
           extra;
      }
      return str;
   } else if (left >= AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR) {
      if ((left / (AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR)) > 1) {
          extra = "s";
       } else {
          extra = "";
      }
      str = (left / (AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR)) + " hour" +
            extra;
      left %= AM_SECONDS_PER_MINUTE * AM_MINUTES_PER_HOUR;
      if ((left / (AM_SECONDS_PER_MINUTE)) > 1) {
          extra = "s";
       } else {
          extra = "";
      }
      if (left > AM_SECONDS_PER_MINUTE) {
         return str + " and " + (left / AM_SECONDS_PER_MINUTE) + " minute" +
                extra;
      }
      return str;
   } else if (left <= 0) {
      return "already finished";
   }
    if( !(left/60) ) {
        return "less than a minute";
    }
    else {
        str = "";
        str += ( left / 60) + " minute";
        if (left / 60 > 1) {
            str += "s";
        }
        return str;
    }
}
string query_auction_end_string(class auction auction) {
   return query_time_end_string(auction->time_started +
                                auction->auction_length - time());
}
int query_last_auction_finish_time() {
   int tim;
   class auction auction;
   foreach (auction in _auctions) {
      if (tim < auction->time_started + auction->auction_length) {
         tim = auction->time_started + auction->auction_length;
      }
   }
   return tim;
}
void next_auction_finish() {
   class auction auct;
   int next;
   int tmp;
   next = 0;
   foreach (auct in _auctions) {
      tmp = auct->time_started + auct->auction_length - time();
      if (tmp <= 0) {
         finish_auction(auct);
      } else if (tmp < next || !next) {
         next = tmp;
      }
   }
   foreach (auct in _finished_auctions) {
      tmp = auct->time_started + auct->auction_length + _retrieval_time -
        time();
      if (tmp <= 0) {
         retry_auction(auct);
         tmp = auct->time_started + auct->auction_length - time();
         if (tmp < next || !next) {
            next = tmp;
         }
      } else if (tmp < next || !next) {
         next = tmp;
      }
   }
   if (_callout_id) {
      remove_call_out(_callout_id);
      _callout_id = 0;
   }
   if (next) {
      _callout_id = call_out("next_auction_finish", next);
   }
}
int do_list() {
   string str;
   class auction bing;
   int pos;
   string place;
   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }
   if (!sizeof(_auctions)) {
      add_failed_mess("Nothing currently on auction.\n");
      return 0;
   }
   place = query_property("place");
   str = "Items currently up for auction:\n";
   foreach (bing in _auctions) {
      str += sprintf("%c) %s", pos + 'A', bing->name);
      if (bing->current_bidder) {
         str += "; " +
                MONEY_HAND->money_value_string(bing->bid, place) +
                " by " + bing->current_bidder + "; finishes in " +
                query_auction_end_string(bing) + ".\n";
      } else {
         str += "; no current bid; finishes in " +
                query_auction_end_string(bing) + ".\n";
      }
      pos++;
   }
   if (!broadcast_shop_event(AUCTION_EVENT_LIST,
                             this_player(), str)) {
      write("$P$Auctions$P$" + str);
   }
   return 1;
}
int do_browse(string id) {
   class auction bing;
   string place;
   string str;
   object* obs;
   object ob;
   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }
   bing = query_auction_item(id);
   if (!bing) {
      add_failed_mess("There is no auction item " + id + ".\n");
      return 0;
   }
   place = query_property("place");
   str = "Auction called " + bing->name + " started at " +
        amtime(bing->time_started) + " finishes at " +
        amtime(bing->time_started + bing->auction_length) + " (in " +
        query_auction_end_string(bing) + ".\n";
   str += "Reserve price " +
          MONEY_HAND->money_value_string(bing->reserve, place);
   if (bing->bid) {
      str += "; current bid " +
             MONEY_HAND->money_value_string(bing->bid, place) +
             " by " + bing->current_bidder + ".\n";
   } else {
      str += "; no current bid.\n";
   }
   obs = query_auction_objects(bing);
   foreach (ob in obs) {
      str += "\n$I$0=$C$" + ob->the_short() + ":\n$I$3=   " +
             ob->long();
      if (ob->query_readable_message(this_player())) {
         str += "$I$0=Read message:\n$I$3=   " + ob->query_readable_message(this_player()) + "\n";
      }
   }
   if (!broadcast_shop_event(AUCTION_EVENT_BROWSE,
                             this_player(), bing, obs, str)) {
      write("$P$Browse Auction$P$" + str);
   }
   return 1;
}
int do_bid(string id, string bid) {
   class auction auct;
   string place;
   int value;
   int inc;
   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }
   auct = query_auction_item(id);
   if (!auct) {
      if (!broadcast_shop_event(AUCTION_EVENT_BAD_ITEM,
                                 this_player(), id)) {
         add_failed_mess("There is no auction item " + id + ".\n");
      }
      return 0;
   }
   place = query_property("place");
   value = MONEY_HAND->value_from_string(bid, place);
   if (_can_bid) {
      if (!evaluate(_can_bid, this_player(), auct, value)) {
         return 0;
      }
   }
   inc = auct->bid + ((auct->bid * _minimum_bid_increase) / 100);
   if (value < inc) {
      if (!broadcast_shop_event(AUCTION_EVENT_BID_TOO_SMALL,
                                 this_player(), auct, value, inc)) {
         add_failed_mess("You must bid " + _minimum_bid_increase + "% more than "
                         "the current bid, current bid is " +
                         MONEY_HAND->money_value_string(auct->bid, place) +
                         " so " + _minimum_bid_increase + "% more is " +
                         MONEY_HAND->money_value_string(inc, place) +
                         ".\n");
      }
      return 0;
   }
   if (value < auct->reserve) {
      if (!broadcast_shop_event(AUCTION_EVENT_BID_BELOW_RESERVE,
                                 this_player(), auct, value, auct->reserve)) {
         add_failed_mess("You must bid more than the reserve bid, it is " +
                      MONEY_HAND->money_value_string(auct->reserve, place) + ".\n");
      }
      return 0;
   }
   bid_on_item(auct, value, this_player()->query_cap_name());
   save_me();
   if (!broadcast_shop_event(AUCTION_EVENT_BID,
                             this_player(), auct, value)) {
      add_succeeded_mess("$N $V " +
                         MONEY_HAND->money_value_string(value, place) +
                         " on " + auct->name + ".\n");
   }
   return 1;
}
int do_withdraw(string id) {
   class auction auct;
   string place;
   int value;
   object* obs;
   object ob;
   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }
   auct = query_auction_item(id);
   if (!auct) {
      if (!broadcast_shop_event(AUCTION_EVENT_BAD_ITEM,
                                 this_player(), id)) {
         add_failed_mess("There is no auction item " + id + ".\n");
      }
      return 0;
   }
   place = query_property("place");
   if (lower_case(auct->seller) == this_player()->query_name() ||
       this_player()->query_creator()) {
      if (auct->reserve > auct->bid) {
         value = auct->reserve;
      } else {
         value = auct->bid;
      }
      if (this_player()->query_value_in(place) < value) {
         if (!broadcast_shop_event(AUCTION_EVENT_TOO_POOR,
                              this_player(), auct,
                              this_player()->query_value_in(place),
                              auct->bid)) {
            add_failed_mess("You need at least " +
                            MONEY_HAND->money_value_string(value, place) +
                            " to withdraw this item from auction.\n");
         }
         return 0;
      }
      obs = query_auction_objects(auct);
      this_player()->pay_money(MONEY_HAND->create_money_array(value, place),
        place);
      remove_auction_item(auct);
      save_me();
      if (auct->end_function) {
         call_other(this_object(), auct->end_function,
                    AUCTION_WITHDRAW_PHASE, auct, auct->extra);
      }
      foreach (ob in obs) {
         if (ob->move(this_player()) != MOVE_OK) {
             ob->move(this_object());
             write("Unable to move " + ob->the_short() +
                   " into your inventory, put on the floor.\n");
         }
      }
      if (!broadcast_shop_event(AUCTION_EVENT_WITHDRAW,
                                 this_player(), auct)) {
         add_succeeded_mess("$N remove$s " + auct->name + " from auction.\n");
      }
      return 1;
   }
   if (!broadcast_shop_event(AUCTION_EVENT_CANNOT_WITHDRAW,
                              this_player(), auct)) {
      add_failed_mess("You cannot withdraw that item from auction.\n");
   }
   return 0;
}
int do_claim() {
   class auction auction;
   int num;
   string place;
   object* obs;
   object ob;
   int i;
   int value;
   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }
   place = query_property("place");
   value = this_player()->query_value_in(place);
   foreach (auction in _finished_auctions) {
      if (!auction->current_bidder) {
         remove_finished_auction_item(auction);
      } else if (lower_case(auction->current_bidder) == this_player()->query_name()) {
         if (value < auction->bid) {
            if (!broadcast_shop_event(AUCTION_EVENT_TOO_POOR,
                              this_player(), auction, value, auction->bid)) {
               write("You do not have enough money to pay for " +
                     MONEY_HAND->money_value_string(auction->bid, place) +
                     ".\n");
            }
         } else {
            this_player()->pay_money(
                MONEY_HAND->create_money_array(auction->bid, place), place);
            value -= auction->bid;
            _royalties[lower_case(auction->seller)] += auction->bid -
                                           auction->bid * _cut / 100;
            obs = AUTO_LOAD_OB->load_auto_load_to_array(auction->save_stuff);
            foreach (ob in obs) {
               if (ob->move(this_player()) != MOVE_OK) {
                  ob->move(this_object());
                  write("Unable to move " + ob->the_short() +
                        " into your inventory, put on the floor.\n");
               }
            }
            if (!broadcast_shop_event(AUCTION_EVENT_CLAIM,
                              this_player(), auction, auction->bid, obs)) {
               write("You paid " +
                     MONEY_HAND->money_value_string(auction->bid, place) +
                     " for " +
                     query_multiple_short(obs) + ".\n");
            }
            remove_finished_auction_item(auction);
            save_me();
            if (auction->end_function) {
               call_other(this_object(), auction->end_function,
                          AUCTION_CLAIM_PHASE, auction, auction->extra,
                          auction->current_bidder, auction->bid, obs);
            }
         }
         num++;
      }
      i++;
   }
   if (!num) {
      if (!broadcast_shop_event(AUCTION_EVENT_NOTHING_TO_CLAIM,
                              this_player())) {
         add_failed_mess("You cannot find anything to claim.\n");
      }
   }
   return num;
}
int do_add(string name, object* obs, string res_str, string length) {
   int reserve;
   string ret;
   string place;
   int len;
   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }
   place = query_property("place");
   len = _auction_times[length];
   if (sizeof(_auctions) >= _max_auctions) {
      if (!broadcast_shop_event(AUCTION_EVENT_FULL,
                             this_player(), name, obs, reserve, len)) {
         add_failed_mess("The auction house is full.\n");
      }
      return 0;
   }
   if (res_str) {
      reserve = MONEY_HAND->value_from_string(res_str, place);
      if (!reserve) {
         if (!broadcast_shop_event(AUCTION_EVENT_BAD_MONEY,
                             this_player(), name, obs, reserve, len)) {
            add_failed_mess("Unable to figure out how much " + res_str +
                            " is.\n");
         }
         return 0;
      }
   }
   ret = "You are putting " + query_multiple_short(obs) + " up for "
         "auction as " + name + " for " +
          query_time_end_string(len);
   if (reserve) {
     ret += " with a reserve price of " +
            MONEY_HAND->money_value_string(reserve, place);
   }
   if (!broadcast_shop_event(AUCTION_EVENT_ADD_AUCTION,
                             this_player(), name, obs, reserve, len, ret + ".")) {
      write(ret + ".\n");
      write("Are you sure you wish to do this? ");
   }
   input_to("confirm_auction", 0, name, obs, reserve, len);
   add_succeeded_mess(({ "", "$N put$s $I up for auction.\n" }), obs);
   return 1;
}
void confirm_auction(string check, string name, object* obs, int reserve, int len) {
   string place;
   string ret;
   place = query_property("place");
   check = lower_case(check);
   if (!strlen(check) || check[0] != 'y') {
      if (!broadcast_shop_event(AUCTION_EVENT_ADD_ABORT,
                             this_player(), name, obs, reserve, len)) {
         write("Ok, Aborting.\n");
      }
      return ;
   }
   add_item_to_auction(obs, name, reserve,
                       this_player()->query_cap_name(), len, 0, 0);
   ret = "You put " + query_multiple_short(obs) + " up for "
         "auction as " + name + " for " +
          query_time_end_string(len);
   if (reserve) {
     ret += " with a reserve price of " +
            MONEY_HAND->money_value_string(reserve, place) + "";
   }
   if (!broadcast_shop_event(AUCTION_EVENT_CONFIRM_AUCTION,
                             this_player(), name, obs, reserve, len, ret + ".")) {
      write(ret + ".\n");
   }
   obs->move("/room/rubbish");
}
int do_info() {
   string ret;
   string name;
   int len;
   if (!is_open(this_player(), 0)) {
      add_failed_mess(this_object()->the_short() + " is not open.\n");
      return 0;
   }
   ret = "$I$3=The times for the auction are:\n";
   foreach (name, len in _auction_times) {
      ret += name + ": " + query_time_end_string(len) + "\n";
   }
   if (!broadcast_shop_event(AUCTION_EVENT_INFO, this_player(), ret)) {
      write("$P$Auction lengths$P$" + ret);
   }
   return 1;
}
void init() {
   add_command("list", "", (: do_list() :));
   add_command("browse", "<string'auction id'>", (: do_browse($4[0]) :));
   add_command("bid", "<string'auction id'> for <string'money'>",
               (: do_bid($4[0], $4[1]) :));
   add_command("bid", "<string'money'> on <string'auction id'>",
               (: do_bid($4[1], $4[0]) :));
   add_command("claim", "", (: do_claim() :));
   add_command("withdraw", "<string'auction id'> [from auction]",
                (: do_withdraw($4[0]) :));
   if (_allow_add) {
      if (!_bid_type_names) {
         _bid_type_names = implode(keys(_auction_times), "|");
      }
      add_command("info", "", (: do_info() :));
      add_command("add", "{" + _bid_type_names +
                   "} auction of <indirect:object:me> as <string'name'>",
                  (: do_add($4[2], $1, 0, $4[0]) :));
      add_command("add", "{" + _bid_type_names +
                  "}  auction of <indirect:object:me> as <string'name'> reserve <string'price'>",
                  (: do_add($4[2], $1, $4[3], $4[0]) :));
   }
}

==================================================
FILE: shops/inherit/bank_base.c
==================================================

#include <money.h>
#include <move_failures.h>
#define NAME (string)this_player()->query_name()
#define CAP_NAME (string)this_player()->one_short()
#define POSS (string)this_player()->query_possessive()
#define HANDLER "/obj/handlers/bank_handler"
#define OLD_BANK "/d/am/save/bank"
private string _franchise;
private int _total_difference;
private nosave int _account_cost;
private nosave int _percentage;
private nosave string _bank_name;
string query_money_place();
void adjust_float(int amount);
int is_open_for(string type, string person);
void event_save(object ob);
void create() {
  _account_cost = 400;
  _total_difference = 0;
  _percentage = 10;
}
int query_bank() {
   return 1;
}
int query_account_cost() { return _account_cost; }
void set_account_cost( int number ) { _account_cost = number; }
int query_percentage() { return _percentage; }
void set_percentage( int number ) { _percentage = number; }
int query_total_difference() { return _total_difference; }
void adjust_total_difference(int amount) {
   _total_difference += amount;
}
void set_total_difference(int amount) {
   _total_difference = amount;
}
string query_bank_name() { return _bank_name; }
void set_bank_name( string word ) { _bank_name = word; }
int get_account(string player) {
  return HANDLER->query_account( player, _bank_name );
}
void set_account( string player, int amount ) {
  HANDLER->set_account( player, _bank_name, amount );
}
void adjust_account(string person, int amount) {
}
string query_franchise() {
   return _franchise;
}
void set_franchise(string franchise) {
   _franchise = franchise;
}
int can_adjust_account(string person, int amount) {
   if ( ( get_account( person ) + amount ) >= 0 ) {
      return 1;
   }
   add_failed_mess("You do not have enough money to complete the "
                   "transaction.\n");
   return 0;
}
object find_main_bank() {
   object office;
   string room;
   room = BANK_HANDLER->query_bank_master_office(_bank_name);
   if (!room) {
      return 0;
   }
   office = load_object(room);
   if (!office) {
      return 0;
   }
   if (office->query_bank()) {
      return office;
   }
   return 0;
}
string query_main_branch_owner() {
   object branch;
   branch = find_main_bank();
   if (!branch) {
      return "no owner";
   }
   if (branch->query_owner()) {
      return lower_case(branch->query_owner());
   }
   return "no owner";
}
int do_balance() {
  int amount;
   if (!query_bank_name()) {
      add_failed_mess("This is a forgotten bank in a dusty land.\n");
      return 0;
   }
   if (!is_open_for("bank", this_player()->query_name())) {
      add_failed_mess("The bank is not open for withdrawals.\n");
      return 0;
   }
   amount = get_account(this_player()->query_name());
  if ( amount < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }
  if ( !amount ) {
     add_succeeded_mess(
       ({ "Your account is empty.\n",
           "$N checks the balance of $p account.\n" }));
    return 1;
  }
  add_succeeded_mess(
     ({ "You have "+ (string)MONEY_HAND->money_value_string( amount,
         query_money_place() ) +
        " in your account.\n",
        "$N checks the balance of $p account.\n" }));
  return 1;
}
int do_withdraw( string type ) {
  int amount;
  int total;
  object money;
   if (this_player()->query_property("dead"))  {
      add_failed_mess("You are dead.  You know what they say; you can't take "
         "it with you.\n");
      return 0;
   }
   if (!query_bank_name()) {
      add_failed_mess("This is a forgotten bank in a dusty land.\n");
      return 0;
   }
   if (!is_open_for("withdraw", this_player()->query_name())) {
      add_failed_mess("The bank is not open for withdrawals.\n");
      return 0;
   }
   total = get_account(this_player()->query_name());
   if ( total < 0 ) {
      notify_fail( "You do not have an account here.\n" );
      return 0;
   }
   amount = MONEY_HAND->value_from_string(type, query_money_place());
   if ( amount <= 0 ) {
      notify_fail( "You must withdraw something.\n" );
      return 0;
   }
   if ( amount > total ) {
      add_failed_mess( "You don't have that much money in your account!\n" );
      return 0;
   }
   if (!can_adjust_account(this_player()->query_name(), -amount)) {
      add_failed_mess("The bank cannot handle this transaction.\n");
      return 0;
   }
   money = MONEY_VAULT->get_money_ob();
   money->set_money_array(MONEY_HAND->create_money_array(amount,
       query_money_place()));
   if (money->move(this_player()) != MOVE_OK)  {
      if (money->move(this_object()) != MOVE_OK) {
         add_failed_mess("Unable to put the money on the floor, cancelling "
               "the transaction.\n");
         money->move("/room/rubbish");
         return 0;
      } else {
         write("You are carrying too much weight to accept your money, "
               "So it is placed on the floor for you.\n");
      }
   }
   set_account(this_player()->query_name(), total - amount );
   adjust_account(this_player()->query_name(), -amount);
   _total_difference -= amount;
   event_save(this_object());
   add_succeeded_mess( ({
      "You withdraw "
      + MONEY_HAND->money_value_string( amount, query_money_place() )
      +".\nYou have "
      + MONEY_HAND->money_value_string( get_account( this_player()->query_name() ),
                                        query_money_place() )
      + " in your account after the withdrawal.\n",
      "$N withdraws some money from $p account.\n"
   }) );
   this_player()->save();
   return 1;
}
int do_deposit( string words ) {
   int amount;
   int total;
   int tmp;
   int howmuch;
   mixed money;
   if (!query_bank_name()) {
      add_failed_mess("This is a forgotten bank in a dusty land.\n");
      return 0;
   }
   if (!is_open_for("deposit", this_player()->query_name())) {
      add_failed_mess("The bank is not open for deposits.\n");
      return 0;
   }
   total = get_account(this_player()->query_name());
   if ( total < 0 ) {
      notify_fail("You don't have an account here.\n");
      return 0;
   }
   money = MONEY_HAND->parse_money(words, this_player(), query_money_place());
   if( money == NO_MATCH ) {
      add_failed_mess( "Deposit what?\n" );
      return 0;
   }
   else if( money == NO_MONEY ) {
      add_failed_mess( "You can't deposit that.\n" );
      return 0;
   }
   else if( money == NO_LEGAL ) {
      add_failed_mess( "You can only deposit legal tender.\n");
      return 0;
   }
   amount = money->query_value_in(query_money_place());
   if(amount < 200) {
      money->move(this_player());
      add_failed_mess("That is too small an amount, you must deposit "
                      "at least " +
                      MONEY_HAND->money_value_string(200, query_money_place()) +
                      ".\n");
      return 0;
   }
   if (!can_adjust_account(this_player()->query_name(), amount)) {
      money->move(this_player());
      add_failed_mess("The bank cannot handle this transaction.\n");
      return 0;
   }
   tmp = ( amount * _percentage ) / 100;
   adjust_float(tmp);
   howmuch = amount;
   amount = amount - tmp;
   set_account(this_player()->query_name(), total + amount );
   _total_difference += amount;
   adjust_account(this_player()->query_name(), amount);
   event_save(this_object());
   money->move("/room/rubbish");
   this_player()->save();
   add_succeeded_mess(
       ({  "You give the teller "+ MONEY_HAND->
           money_string(money->query_money_array(), query_money_place()) +
           ", which after expenses leaves "+ MONEY_HAND->
           money_value_string( amount, query_money_place() ) +".\n"
           "This gives a total of " + MONEY_HAND->
           money_value_string(total + amount, query_money_place() ) +
           " in your account.\n",
           "$N deposits some money into $p account.\n" }) );
   return 1;
}
int do_open() {
  int amount;
  if (!is_open_for("open account", this_player()->query_name())) {
     add_failed_mess("The bank is not open for new accounts.\n");
     return 0;
  }
  if ( get_account(this_player()->query_name()) >= 0 ) {
    notify_fail( "You already have an account here.\n" );
    return 0;
  }
  if ( _account_cost ) {
    amount = this_player()->query_value_in( query_money_place() );
    if ( amount < _account_cost ) {
      notify_fail( "You do not have enough money to open an account.\n" );
      return 0;
    }
    write( "It will cost you "+ (string)MONEY_HAND->money_value_string(
      _account_cost, query_money_place() ) +
      " to open the account.\nDo you still wish to "+
      "open an account here? " );
    input_to( "check_open" );
    return 1;
  }
  set_account(this_player()->query_name(), 0 );
  add_succeeded_mess( "$N $V an account.\n" );
  return 1;
}
void check_open( string word ) {
  object money;
  int amount;
  object main;
  word = lower_case( word );
  if (!strlen(word) || word [ 0 ] !=  'y') {
    write( "Okay, not opening an account.\n" );
    return ;
  }
  amount = this_player()->query_value_in( query_money_place() );
  if (amount < _account_cost) {
    write("You lost all your money!\n");
    return ;
  }
  set_account(this_player()->query_name(), 0 );
  write( "You now have an account here.\n" );
  money = this_player()->query_money_object(0);
  money = MONEY_HAND->pay_amount_from( _account_cost, money, query_money_place() );
  if (money  &&  money->move(this_player()) != MOVE_OK)  {
    write("Your change is too heavy and you drop it on the floor.\n");
    money->move(this_object());
  }
  amount = BANK_HANDLER->query_cost_for_new_account(_bank_name,
                                                    query_franchise());
  main = find_main_bank();
  if (main) {
     main->adjust_float(amount);
  }
  adjust_float(_account_cost - amount);
  return ;
}
int do_close() {
  int total;
  object money;
  total = get_account(this_player()->query_name());
  if ( total < 0 ) {
    notify_fail( "You do not have an account here.\n" );
    return 0;
  }
  if ( total ) {
    if ( money = (object)MONEY_HAND->make_new_amount( total, query_money_place() ) ) {
      write( "You receive "+ (string)money->short() +" on closing "+
        "your account.\n" );
      if ( (int)money->move( this_player() ) != MOVE_OK ) {
        write( "You are too heavily burdened to accept all that money, so "+
          "the teller puts it on the counter for you.\n" );
        money->move( this_object() );
      }
      adjust_float(-total);
      _total_difference -= total;
    } else {
      write( "The amount of money in your account was not even worth a "+
        "coin of the lowest denomination in the local currency.  Sorry.\n"+
        "Your account is now closed.\n" );
    }
  } else {
    write( "You close your account.\n" );
  }
  add_succeeded_mess("$N $V an account.\n");
  set_account(this_player()->query_name(), -1 );
  event_save(this_object());
  this_player()->save();
  return 1;
}
mixed *stats() {
  return ({
    ({ "account cost", _account_cost }),
    ({ "percentage", _percentage }),
    ({ "total difference", _total_difference }),
    ({ "bank name", _bank_name }),
    ({ "place", query_money_place() }) });
}
void init() {
  add_command( "balance", "" );
  add_command( "withdraw", "<string>",
               (: do_withdraw($4[0]) :) );
  add_command( "open", "account" );
  add_command( "close", "account" );
  add_command( "deposit", "<string>", (: do_deposit($4[0]) :) );
}

==================================================
FILE: shops/inherit/bank_franchise.c
==================================================

inherit "/std/shops/inherit/bank_base";
#include <money.h>
#include <shops/bank.h>
class credit_note {
   int num;
   int amt;
   int made;
   string maker;
}
private int _credit_num;
private class credit_note* _notes;
void create() {
   _notes = ({ });
   ::create();
}
int is_allowed(string name) {
   return 0;
}
int is_allowed_credit(string name) {
   return is_allowed(name) ||
          name == query_main_branch_owner();
}
protected void set_credit_num(int num) {
   _credit_num = num;
}
int query_credit_num() {
   return _credit_num;
}
protected void set_credit_notes(class credit_note* notes) {
   _notes = notes;
}
class credit_note* query_credit_notes() {
   return copy(_notes);
}
int query_outstanding_credit_value() {
   int diff;
   class credit_note note;
   foreach (note in _notes) {
      diff += note->amt;
   }
   return diff;
}
int do_create() {
   object ob;
   int diff;
   if (!is_allowed_credit(this_player()->query_name())) {
      add_failed_mess("The bank is not open for creating credit notes.\n");
      return 0;
   }
   diff = query_total_difference() - query_outstanding_credit_value();
   if (diff == 0) {
      add_failed_mess("The bank is currently at a zero balance with the "
                      "outstanding credit notes.\n");
      return 0;
   }
   ob = clone_object(BANK_CREDIT_NOTE);
   ob->set_credit_num(++_credit_num);
   ob->set_franchise(query_franchise());
   ob->set_bank_name(query_bank_name());
   ob->set_amount(query_total_difference());
   ob->add_property("place", query_money_place());
   ob->setup_read_messages();
   ob->move(this_player());
   if (!_notes) {
      _notes = ({ });
   }
   _notes += ({ new(class credit_note, num : ob->query_credit_num(),
                                   amt : ob->query_amount(),
                                   maker : this_player()->query_cap_name(),
                                   made : time()) });
   event_save(this_object());
   add_succeeded_mess("$N $V " + ob->a_short() + ".\n");
   return 1;
}
int do_list() {
   class credit_note note;
   string ret;
   string place;
   if (!is_allowed_credit(this_player()->query_name())) {
      add_failed_mess("The bank is not open for listing credit notes.\n");
      return 0;
   }
   place = query_money_place();
   if (!sizeof(_notes)) {
      add_failed_mess("No credit notes to list.\n");
      return 0;
   }
   ret = "Credit notes\n\n";
   foreach (note in _notes) {
      ret += "$I$6=" + sprintf("%3d) ", note->num) +
             ctime(note->made) + ": by " +
             note->maker + " for " +
             MONEY_HAND->money_value_string(note->amt, place) + "\n";
   }
   write("$P$Credit Notes$P$" + ret);
   return 1;
}
int do_recind(int id) {
   class credit_note note;
   int i;
   string place;
   if (!is_allowed_credit(this_player()->query_name())) {
      add_failed_mess("The bank is not open for listing credit notes.\n");
      return 0;
   }
   for (i = 0; i < sizeof(_notes); i++) {
      note = _notes[i];
      if (note->num == id) {
          place = query_money_place();
          _notes = _notes[0..i-1] + _notes[i+1..];
          add_succeeded_mess(({
             "You recind #" + note->num + " made at " +
             ctime(note->made) + " by " +
             note->maker + " for " +
             MONEY_HAND->money_value_string(note->amt, place) + "\n", "" }));
          return 1;
      }
   }
   add_failed_mess("Unable to find credit note #" + id + ".\n");
   return 0;
}
int is_valid_note(int id) {
   int i;
   for (i = 0; i < sizeof(_notes); i++) {
      if (_notes[i]->num == id) {
         return 1;
      }
   }
   return 0;
}
int process_note(int id) {
   int i;
   if (!is_valid_note(id)) {
      return 0;
   }
   for (i = 0; i < sizeof(_notes); i++) {
      if (_notes[i]->num == id) {
         adjust_total_difference(-_notes[i]->amt);
         _notes = _notes[0..i-1] + _notes[i+1..];
         i--;
      }
   }
   event_save(this_object());
   return 1;
}
void init() {
   ::init();
   add_command("create", "credit note");
   add_command("list", "credit notes");
   add_command("recind", "credit note <number'id'>", (: do_recind($4[0]) :));
}

==================================================
FILE: shops/inherit/bank_master.c
==================================================

inherit "/std/shops/inherit/bank_base";
#include <money.h>
int query_float();
int do_process(object *obs) {
   object ob;
   int amount;
   int found;
   object* not_credit;
   object* not_valid;
   string place;
   place = query_money_place();
   not_valid = ({ });
   not_credit = ({ });
   foreach (ob in obs) {
      if (ob->query_credit_note() ||
          ob->query_bank_name() != query_bank_name()) {
         not_credit += ({ ob });
         obs -= ({ ob });
      } else if (ob->is_valid_note()) {
         amount += ob->query_credit_balance();
      } else {
         not_valid += ({ ob });
         obs -= ({ ob });
      }
   }
   if (!sizeof(obs)) {
      if (sizeof(not_credit)) {
         add_failed_mess("None of $I are credit notes.\n", not_credit);
      }
      if (sizeof(not_valid)) {
         add_failed_mess("None of $I are valid credit notes.\n", not_valid);
      }
      return 0;
   }
   foreach (ob in obs) {
      amount = ob->query_amount();
      if (amount > 0) {
         if (this_player()->query_value_in(query_money_place()) < amount) {
            add_failed_mess("You do not have the needed " +
                            MONEY_HAND->money_value_string(amount, place) +
                            " to deposit.\n");
            continue;
         }
         else if (ob->do_process()) {
            this_player()->pay_money(MONEY_HAND->create_money_array(amount,
                   place), place);
            add_succeeded_mess("$N $V depositing " +
                               MONEY_HAND->money_value_string(amount, place) +
                               " from $I.\n", ({ ob }));
            found++;
         } else {
            add_failed_mess("You cannot process $I for some reason.\n",
                            ({ ob }));
            continue;
         }
      } else if (amount < 0) {
         if (ob->do_process()) {
            this_player()->adjust_money(MONEY_HAND->create_money_array(-amount, place));
            add_succeeded_mess("$N $V withdrawing " +
                               MONEY_HAND->money_value_string(-amount, place) +
                               " from $I.\n", ({ ob }));
            found++;
         } else {
            add_failed_mess("You cannot process $I for some reason.\n",
                            ({ ob }));
            continue;
         }
      }
      ob->move("/room/rubbish");
   }
   return found;
}
void init() {
   ::init();
   add_command("process", "<indirect:object>");
}

==================================================
FILE: shops/inherit/clone_on_demand.c
==================================================

#include <armoury.h>
#define INFINITE_LEFT 10000
#define MAX_PROP "max per reset"
#define NUM_REMOVED "number removed this reset"
#define REFERENCE "name we are reference by"
#define DISPLAY "display in shop"
nosave object _cont;
nosave string _domain;
void create(){
}
object query_cont(){  return _cont;  }
void check_cont() {
  if (!_cont) {
     _cont = clone_object("/std/container");
     _cont->set_name( "clone_on_demand-store" );
  }
}
void reset() {
  object ob;
  check_cont();
  foreach( ob in all_inventory(_cont) ){
    ob->remove_property(NUM_REMOVED);
  }
}
void set_object_domain(string domain) {
   _domain = domain;
}
string query_object_domain() {
   return _domain;
}
varargs int add_object( string name, int max_per_reset, string display_as ) {
  object ob;
  if(!_cont) {
     _cont = clone_object("/std/container");
     _cont->set_name( "clone_on_demand-store" );
  }
  if (!(ob = this_object()->create_object(name))) {
    if(!ob = clone_object(name)) {
      ob = ARMOURY->request_item(name, 100, _domain);
    }
  }
  if(ob) {
    if (ob->query_decays()) {
      ob->set_decay_speed(0);
    }
    ob->move(_cont);
    if (display_as) {
         ob->add_property( DISPLAY, display_as);
    }
    ob->add_property( REFERENCE, name);
    ob->add_property( MAX_PROP, max_per_reset );
    return 1;
  }
  return 0;
}
int query_num_items_left(object ob) {
   int max;
   int num;
   max = ob->query_property( MAX_PROP );
   num = ob->query_property( NUM_REMOVED );
   if( max ){
     return max - num;
   }
   return INFINITE_LEFT;
}
int query_number_left(string name) {
   object * things;
   things = filter( all_inventory(_cont),
     (: $1->query_short() == $(name) :) );
   if( !sizeof(things) ) {
      return -1;
   }
   return query_num_items_left( things[0] );
}
int * query_items_left( string *names ) {
   if( !names )
      return ({ });
   return map( names, (: query_number_left($1) :) );
}
private void switch_properties(object newone, object original) {
  mixed *extra, *props, prop;
  props = ({ MAX_PROP, NUM_REMOVED, REFERENCE });
  extra = this_object()->switch_extra_properties();
  if( sizeof(extra) )
    props += extra;
  foreach( prop in props ){
    newone->add_property( prop, original->query_property( prop ) );
    original->remove_property( prop );
  }
  if (newone->query_decay_speed()) {
     original->set_decay_speed( newone->query_decay_speed() );
     newone->set_decay_speed(0);
  }
}
protected object create_real_object(object thing) {
   string name;
   object new_thing, *continv, temp_cont;
   int j, max, num;
   name = thing->query_property( REFERENCE );
   if(!name)
     return 0;
   new_thing = this_object()->create_object( name );
   if ( !new_thing )  {
      new_thing = clone_object(name);
   }
   if ( !new_thing )  {
      new_thing = ARMOURY->request_item( name, 80 + random( 20 ), _domain );
   }
  if( new_thing ){
    switch_properties( new_thing, thing );
    continv = all_inventory(_cont);
    j = member_array( thing, continv );
    temp_cont = clone_object("/std/container");
    thing->move("/room/void");
    continv[j] = new_thing;
    new_thing->move(_cont);
      for (j=sizeof(continv)-1;j>=0;j--) {
      continv[j]->move(temp_cont);
      continv[j]->move(_cont);
    }
    temp_cont->dest_me();
    max = new_thing->query_property( MAX_PROP );
    num = new_thing->query_property( NUM_REMOVED );
    if ( max ) {
      new_thing->add_property( NUM_REMOVED, num + 1 );
    }
  }
  return thing;
}
void dest_me(){
  if( _cont )
    _cont->dest_me();
}
varargs int add_armour( string name, int max_per_reset, string display_as ) {
  return add_object(name, max_per_reset, display_as);
}
varargs int add_weapon( string name, int max_per_reset, string display_as ) {
  return add_object(name, max_per_reset, display_as);
}

==================================================
FILE: shops/inherit/commercial.c
==================================================

#include <player.h>
#include <move_failures.h>
#include <expressions.h>
#include <money.h>
#include <player_handler.h>
#include <mail.h>
inherit "/std/room/player_housing";
inherit "/std/shops/inherit/expression_util";
inherit "/std/shops/inherit/person_expressions";
#define COMMERCIAL_WEEKLY_STATS_TIME (7 * 24 * 60 * 60)
#define COMMERCIAL_ROYALTY_TIMEOUT_PERIOD (7 * 24 * 60 * 60)
class float_withdrawls {
   string person;
   int amount;
   int withdrawl_time;
}
class weekly_status {
   int total_incoming;
   int total_outgoing;
   class float_withdrawls* withdrawls;
}
class royalty_data {
   int value;
   int last_withdrawl;
}
private string* _auto_load_sign_str;
private int _broken_sign;
private string _property_name;
private mapping _royalties;
private class parse_node* _use_expression;
private class parse_node* _entry_cost;
private int _entry_time_limit;
private mapping _use_type_expressions;
private string* _black_list;
private int _last_stats;
private class weekly_status _weekly_status;
private int _commercial_id;
private nosave object _sign_ob;
private nosave string _parcel_post;
private nosave object* _commercial_things;
private nosave string _use_type;
private nosave string _commercial_type;
private nosave string _save_dir;
private nosave int _property_size;
private nosave string _language;
#define COMMERCIAL_SALESPERSON "/obj/monster/commercial"
private string variable_use_type(string seller);
void create() {
    _commercial_things = ({ });
    _royalties = ([ ]);
    _use_type_expressions = ([ ]);
    _property_size = 25;
    _black_list = ({ });
    _last_stats = time();
    _weekly_status = new(class weekly_status);
    _weekly_status->withdrawls = ({ });
    _language = "common";
    expression_util::create();
    player_housing::create();
    person_expressions::create();
    add_allowed_variable("type", EXPRESSION_TYPE_STRING,
                        (: variable_use_type :));
    set_expression_type("room");
    add_help_file("commercial");
    if (!_use_expression) {
        _use_expression = parse_boolean_string("false");
    }
    if (!_black_list) {
        _black_list = ({ });
    }
    if (!_last_stats) {
        _last_stats = time();
    }
    if (_last_stats + COMMERCIAL_WEEKLY_STATS_TIME - time() < 0) {
        call_out("mail_weekly_status", 0);
    }
    else {
        call_out("mail_weekly_status", _last_stats +
            COMMERCIAL_WEEKLY_STATS_TIME - time());
    }
}
string short() {
    if (_property_name) {
        set_short(_property_name);
        add_property("determinate", "");
    }
    return ::short();
}
string long(string word, int dark) {
    if (_property_name) {
        set_short(_property_name);
        add_property("determinate", "");
    }
    return ::long(word, dark);
}
int is_open_for(string type, string person) {
   class parse_node ret;
   if (is_allowed(person)) {
      return 1;
   }
   if (member_array(person, _black_list) != -1) {
      return 0;
   }
   _use_type = type;
   ret = evaluate_expression(_use_expression, this_player()->query_name());
   if (ret->value) {
      if (_use_type_expressions[type]) {
         ret = evaluate_expression(_use_type_expressions[type],
                                   this_player()->query_name());
      }
   }
   return ret->value;
}
object query_main_room() {
   return this_object();
}
void add_commercial_thing(object ob) {
   _commercial_things += ({ ob });
   ob->load_me();
}
void remove_commercial_thing(object thing) {
   thing->save_me();
   _commercial_things -= ({ thing });
}
object* query_commercial_things() {
   return _commercial_things;
}
int query_owners_money() {
   if (classp(_royalties[query_owner()])) {
      return ((class royalty_data)_royalties[query_owner()])->value;
   }
   return 0;
}
void adjust_royalty(string person, int amount) {
   if (is_allowed(person)) {
      if (!_weekly_status) {
         _weekly_status = new(class weekly_status);
         _weekly_status->withdrawls = ({ });
      }
      if (amount > 0) {
         _weekly_status->total_incoming += amount;
      } else {
         _weekly_status->total_outgoing += -amount;
      }
      if (!classp(_royalties[query_owner()])) {
         _royalties[query_owner()] = new(class royalty_data,
                      value : amount + _royalties[query_owner()],
                      last_withdrawl : time());
      } else {
         if (((class royalty_data)_royalties[query_owner()])->value == 0) {
            ((class royalty_data)_royalties[query_owner()])->last_withdrawl = time();
         }
         ((class royalty_data)_royalties[query_owner()])->value += amount;
      }
   } else {
      if (!classp(_royalties[person])) {
         _royalties[person] = new(class royalty_data,
                      value : amount + _royalties[person],
                      last_withdrawl : time());
      } else {
         if (((class royalty_data)_royalties[person])->value == 0) {
            ((class royalty_data)_royalties[person])->last_withdrawl = time();
         }
         ((class royalty_data)_royalties[person])->value += amount;
      }
   }
   event_save(this_object());
}
int query_royalty(string person) {
   if (classp(_royalties[person])) {
      return ((class royalty_data)_royalties[person])->value;
   }
   return 0;
}
int query_float() {
   return query_owners_money();
}
int query_commercial_property() {
   return 1;
}
void set_parcel_post(string parcel) {
   _parcel_post = parcel;
}
string query_parcel_post() {
   return _parcel_post;
}
void set_language(string language) {
   _language = language;
}
string query_language() {
   return _language;
}
void set_commercial_type(string name) {
   _commercial_type = name;
}
string query_commercial_type() {
   return _commercial_type;
}
void set_property_name(string name) {
  if(strsrch(name, "%^") != -1)
    return 0;
   _property_name = name;
   add_property("determinate", "");
   set_short(_property_name);
}
string query_property_name() {
   return _property_name;
}
void event_dest_me(object ob) {
   if (_sign_ob) {
      _sign_ob->dest_me();
   }
}
object query_sign_object() {
   object* obs;
   if (!_sign_ob && _auto_load_sign_str && !_broken_sign) {
      if (catch(obs = (PLAYER_OB)->load_auto_load_to_array(_auto_load_sign_str))) {
         _broken_sign = 1;
      } else {
         if (sizeof(obs)) {
            _sign_ob = obs[0];
            _sign_ob->reset_get();
         } else {
            _broken_sign = 1;
         }
      }
   }
   return _sign_ob;
}
void set_sign_object(object ob) {
   if (ob) {
      _auto_load_sign_str = (PLAYER_OB)->create_auto_load(({ ob }));
      ob->reset_get();
   } else {
      _auto_load_sign_str = 0;
   }
   _sign_ob = ob;
   event_save(this_object());
}
void set_save_file(string str) {
   printf("ERROR!  Do not use set_save_file.\n");
}
void set_save_dir(string dir) {
   if (dir[<1] != '/') {
      dir += "/";
   }
   _save_dir = dir;
   ::set_save_file(dir + "_main");
}
string query_save_dir() {
   return _save_dir;
}
int find_next_commercial_id() {
   object *obs;
   obs = all_inventory();
   while (file_size(query_save_dir() + _commercial_id) >= 0 ||
          file_size(query_save_dir() + _commercial_id + ".o") >= 0 ||
          file_size(query_save_dir() + _commercial_id + ".o.gz") >= 0 ||
          sizeof(filter(obs,
                        (: $1->query_commercial_id() == _commercial_id :)))) {
      _commercial_id++;
   }
   event_save(this_object());
   return _commercial_id;
}
void set_property_size(int size) {
   _property_size = size;
}
int query_property_size() {
   return _property_size;
}
void reset_weekly_status() {
   object ob;
   _weekly_status = new(class weekly_status);
   _weekly_status->withdrawls = ({ });
   foreach (ob in _commercial_things) {
      if (ob) {
         ob->reset_weekly_status();
      }
   }
}
string query_weekly_status_string() {
   string place;
   string ret;
   string str;
   object ob;
   class float_withdrawls withdrawl;
   place = query_property("place");
   if (!_weekly_status) {
      _weekly_status = new(class weekly_status);
      _weekly_status->withdrawls = ({ });
   }
   ret = "";
   ret += "\n$I$0=---=== " + the_short() + " ===---\n";
   ret += "Total outgoing   : " +
          MONEY_HAND->money_value_string(_weekly_status->total_outgoing, place) + "\n";
   ret += "Total incoming   : " +
          MONEY_HAND->money_value_string(_weekly_status->total_incoming, place) + "\n";
   if (sizeof(_weekly_status->withdrawls)) {
      ret += "Float withdrawls:\n";
      foreach (withdrawl in _weekly_status->withdrawls) {
         ret += "$I$6=   " + ctime(withdrawl->withdrawl_time)[0..11] + " " +
                withdrawl->person + " for " +
                MONEY_HAND->money_value_string(withdrawl->amount, place) + "\n";
      }
   } else {
      ret += "No withdrawls from the float.\n";
   }
   foreach (ob in _commercial_things) {
      if (ob) {
         str = ob->query_weekly_status_string();
         if (str) {
            ret += "\n$I$0=---=== " + ob->the_short() + " ===---\n";
            ret += str;
         }
      }
   }
   return ret;
}
protected void mail_weekly_status() {
   string str;
   string ret;
   class royalty_data data;
   string person;
   if(!query_owner()) {
      return;
   }
   foreach (person, data in _royalties) {
      if (classp(data)) {
         if (person != query_owner() &&
             data->value > 0 &&
             data->last_withdrawl +
                  COMMERCIAL_ROYALTY_TIMEOUT_PERIOD - time() < 0) {
            AUTO_MAILER->auto_mail(person,
                                   the_short(),
                                   "Lost royalties.",
                                   0,
                                   "You took too long to collect your "
                                   "royalties and they vanished.\n\n"
                                   "Good luck!\n"
                                   "Administrator.");
            map_delete(_royalties, person);
         }
      }
   }
   ret = catch(str = query_weekly_status_string());
   if (ret) {
      AUTO_MAILER->auto_mail(query_owner(),
                        the_short(),
                        "Weekly Statistics " + ctime(time()),
                        implode(query_allowed(), ","),
                        "The weekly stats generated an error: " + ret + "\n");
      AUTO_MAILER->auto_mail("pinkfish",
                        the_short(),
                        "Weekly Statistics " + ctime(time()),
                        0,
                        "The weekly stats generated an error: " +
                        ret + "\nin room: " + file_name(this_object()) + "\n");
   } else {
      str = PLAYER_OB->convert_message(str);
      AUTO_MAILER->auto_mail(query_owner(),
                        the_short(),
                        "Weekly Statistics " + ctime(time()),
                        implode(query_allowed(), ","),
                        str);
   }
   _last_stats = time();
   foreach (object ob in _commercial_things) {
      adjust_royalty(query_owner(), -ob->query_weekly_upkeep_cost());
   }
   event_save(this_object());
   reset_weekly_status();
   event_save(this_object());
}
object* find_commercial_items(string type) {
   object* obs;
   obs = filter(all_inventory(this_object()),
                (: $1->query_commercial_name() == $2 :), type);
   return obs;
}
void register_use_types(string* types) {
   string bing;
   if (!_use_type_expressions) {
      _use_type_expressions = ([ ]);
   }
   foreach (bing in types) {
      if (!_use_type_expressions[bing]) {
         _use_type_expressions[bing] = parse_boolean_string("true");
      }
   }
}
int do_name_property(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot set the name of " + the_short() + ".\n");
      return 0;
   }
   set_property_name(name);
   add_succeeded_mess("$N set$s the property name to '" + name + "'.\n");
   return 1;
}
int do_set_sign(object* obs) {
   object ob;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot set the sign for the property.\n");
      return 0;
   }
   if (sizeof(obs) > 1) {
      add_failed_mess("You must only specifiy one sign.\n");
      return 0;
   }
   if (living(obs[0])) {
      add_failed_mess("You have to wait till " + obs[0]->the_short() +
                      " dies first.\n");
      return 0;
   }
   if (obs[0]->get()) {
      add_failed_mess("Cannot set something as a sign that you cannot get.\n");
      return 0;
   }
   ob = query_sign_object();
   if (obs[0]->move("/room/rubbish") == MOVE_OK) {
      set_sign_object(obs[0]);
   } else {
      add_failed_mess("Unable to move $I off you.\n", obs[0..0]);
      return 0;
   }
   if (query_sign_object() != ob) {
      if (ob) {
         ob->set_get();
         if (ob->move(this_player()) != MOVE_OK) {
            ob->move(this_object());
         }
         add_succeeded_mess(({ "You remove the sign " +ob->the_short() +
                               " and set " + obs[0]->the_short() +
                               " as your property sign.\n",
                               "$N sets the sign for outside " + the_short() +
                               ".\n" }));
      } else {
         add_succeeded_mess(({ "You set " + obs[0]->the_short() +
                               " as your property sign.\n",
                               "$N sets the sign for outside " + the_short() +
                               ".\n" }));
      }
      return 1;
   } else {
      obs[0]->move(this_player());
      add_failed_mess("You cannot set the sign for some reason.\n");
      return 0;
   }
}
int do_remove_sign() {
   object ob;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot set the sign for the property.\n");
      return 0;
   }
   if (!query_sign_object()) {
      add_failed_mess("You cannot remove the sign since there is no sign.\n");
      return 0;
   }
   ob = query_sign_object();
   ob->set_get();
   if (ob->move(this_player()) == MOVE_OK) {
      add_succeeded_mess("$N $V $I from " + the_short() +
                         ".\n", ({ ob }));
      set_sign_object(0);
      return 1;
   } else {
      ob->reset_get();
      add_failed_mess("You cannot remove the sign, unable to hold it?\n");
      return 0;
   }
}
int do_status(int hint) {
   string ret;
   object ob;
   string str;
   string place;
   string fluff;
   class parse_node* expr;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }
   place = query_property("place");
   ret = "";
   ret += "$I$5=The owner of the property is " + query_owner() + ".\n";
   ret += "$I$5=The name of the property is " + _property_name + ".\n";
   if (hint) {
      ret += "$I$0=       Hint: name property <name>\n";
   }
   if (sizeof(_black_list)) {
      ret += "$I$5=The black list is " +
             query_multiple_short(_black_list) + ".\n";
   } else {
      ret += "$I$5=The black list is empty.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: blacklist add <name>\n";
      ret += "$I$0=       Hint: blacklist add ignore\n";
      ret += "$I$0=       Hint: blacklist remove <name>\n";
   }
   if (query_sign_object()) {
      ret += "$I$5=The property currently has a sign set.\n";
   } else {
      ret += "$I$5=The property does not currently have a sign set.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: set sign <object>\n";
      ret += "$I$0=       Hint: remove sign\n";
   }
   if (sizeof(query_allowed())) {
      ret += "$I$5=People allowed to change the property are " +
             query_multiple_short(sort_array(query_allowed(), 0)) + ".\n";
   } else if (hint) {
      ret += "$I$5=Only the owner can change the property.\n";
   }
   ret += "$I$5=Current float is " +
          MONEY_HAND->money_value_string(query_float(), place) + ".\n";
   if (sizeof(_use_expression)) {
      ret += "$I$5=Use condition: " + query_expression_string(_use_expression, 0) +
             ".\n";
   } else {
      ret += "$I$5=Anyone can use the shop.\n";
   }
   foreach (fluff, expr in _use_type_expressions) {
      ret += "$I$5=  Use " + fluff + " condition: " +
             query_expression_string(expr, 0) + ".\n";
   }
   ret += "$I$0=\n";
   foreach (ob in _commercial_things) {
      if (ob) {
         str = ob->query_main_status(hint);
         if (str) {
            ret += str;
         }
      }
   }
   write("$P$Status$P$" + ret);
   return 1;
}
int do_weekly_status() {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }
   write("$P$Weekly Status$P$" + query_weekly_status_string());
   return 1;
}
int do_use_expression(string str) {
   class parse_node* expr;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add restrictions to the property.\n");
      return 0;
   }
   if (str == "disable")  {
      _use_expression = ({ });
      add_succeeded_mess(({ "You disable checking to see if "
         "someone can use the property.\n",
         "$N fiddle$s about with " + the_short() + " a bit.\n" }));
      return 1;
   }
   expr = parse_boolean_string(str);
   if (!sizeof(expr)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   } else {
      _use_expression = expr;
      add_succeeded_mess(({ "You set the expression to use when checking "
                            "to see if someone can use the property to " +
                            query_expression_string(expr, 1) +
                            ".\n",
                            "$N fiddle$s about with " + the_short() +
                                " a bit.\n" }));
      event_save(this_object());
   }
   return 1;
}
int do_use_expression_type(string type, string str) {
   class parse_node* expr;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add restrictions to the property.\n");
      return 0;
   }
   if (!_use_type_expressions[type]) {
      add_failed_mess("The type '" + type + "' is invalid, must be one "
                      "of " +
                      query_multiple_short(keys(_use_type_expressions)) +
                      ".\n");
      return 0;
   }
   if (str == "disable")  {
      _use_type_expressions[type] = ({ });
      add_succeeded_mess(({ "You disable checking to see if "
         "someone can use the property for " + type + ".\n",
         "$N fiddle$s about with " + the_short() + " a bit.\n" }));
      return 1;
   }
   expr = parse_boolean_string(str);
   if (!sizeof(expr)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   } else {
      _use_type_expressions[type] = expr;
      add_succeeded_mess(({ "You set the expression to use when checking "
                            "to see if someone can use the property for " +
                            type + " to " +
                            query_expression_string(expr, 1) +
                            ".\n",
                            "$N fiddle$s about with " + the_short() +
                                " a bit.\n" }));
      event_save(this_object());
   }
   return 1;
}
int do_royalties() {
   string place;
   class royalty_data data;
   if (!is_open_for("royalty", this_player()->query_name())) {
      add_failed_mess(the_short() + " is not currently open for "
                      "customers.\n");
      return 0;
   }
   if (!classp(_royalties[this_player()->query_name()]) &&
       _royalties[this_player()->query_name()] != 0) {
      data = new(class royalty_data,
                 value : _royalties[this_player()->query_name()],
                 last_withdrawl : time());
     _royalties[this_player()->query_name()] = data;
   }
   data = _royalties[this_player()->query_name()];
   if (!data) {
      add_failed_mess("You have no money owed to you here.\n");
      return 0;
   }
   if (this_player()->query_name() != query_owner() && data->value > 0) {
      if (data->last_withdrawl + COMMERCIAL_ROYALTY_TIMEOUT_PERIOD - time() < 0) {
         write("Your royalties timed out before you could claim them.\n");
         map_delete(_royalties, this_player()->query_name());
      }
   }
   if (data->value < 0) {
      add_failed_mess("You owe money to " + the_short() + ".\n");
      return 0;
   }
   if (data->value == 0) {
      map_delete(_royalties, this_player()->query_name());
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   add_succeeded_mess(({ "You have " +
                      MONEY_HAND->money_value_string(data->value, place) +
                      " in royalties currently which will timeout in " +
                      query_time_string(data->last_withdrawl + COMMERCIAL_ROYALTY_TIMEOUT_PERIOD - time(), 2) + ".\n",
                      "$N checks $p royalties.\n" }));
   return 1;
}
int do_royalty_list() {
   string place;
   mixed value;
   class royalty_data data;
   string person;
   string ret;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("Only the property owners can do this.\n");
      return 0;
   }
   if (!sizeof(_royalties)) {
      add_failed_mess("No one has royalties here currently.\n");
      return 0;
   }
   place = query_property("place");
   ret = "";
   foreach (person in sort_array(keys(_royalties), 0)) {
      value = _royalties[person];
      if (!classp(value)) {
         data = new(class royalty_data, value : value, last_withdrawl : time());
      } else {
         data = value;
      }
      if (PLAYER_HANDLER->test_user(person)) {
         ret += capitalize(person) + " " +
                MONEY_HAND->money_value_string(data->value, place);
         if (person != query_owner()) {
            ret += " (Timeout: " + query_time_string(data->last_withdrawl +
                     COMMERCIAL_ROYALTY_TIMEOUT_PERIOD - time(), 2) + ")\n";
         } else {
            ret += "\n";
         }
      } else {
         map_delete(_royalties, person);
      }
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   write("$P$Royalties$P$" + ret);
   return 1;
}
int do_collect() {
   string place;
   string name;
   class royalty_data data;
   if (!is_open_for("royalty", this_player()->query_name())) {
      add_failed_mess(the_short() + " is not currently open for "
                      "customers.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   name = this_player()->query_name();
   if (!classp(_royalties[this_player()->query_name()]) &&
       _royalties[this_player()->query_name()] != 0) {
      data = new(class royalty_data,
                 value : _royalties[this_player()->query_name()],
                 last_withdrawl : time());
     _royalties[this_player()->query_name()] = data;
   }
   data = _royalties[name];
   if (!data) {
      add_failed_mess("You have no royalties to collect.\n");
      return 0;
   }
   if (name != query_owner() && data->value > 0) {
      if (data->last_withdrawl + COMMERCIAL_ROYALTY_TIMEOUT_PERIOD - time() < 0) {
         write("Your royalties timed out before you could claim them.\n");
         map_delete(_royalties, name);
         return 1;
      }
   }
   if (data->value == 0) {
      map_delete(_royalties, this_player()->query_name());
   }
   if (this_player()->query_refresh_time() &&
       this_player()->query_refresh_time() > data->last_withdrawl) {
      add_failed_mess("You have refreshed since your last collection.\n");
      map_delete(_royalties, name);
      return 0;
   }
   if ((!data || !data->value) && is_allowed(this_player()->query_name())) {
      name = query_owner();
      data = _royalties[name];
   }
   if (data->value > 0) {
      this_player()->adjust_money(MONEY_HAND->create_money_array(data->value, place));
      if (name == query_owner()) {
         _weekly_status->withdrawls += ({ new(class float_withdrawls, amount : data->value,
                               person : name,
                               withdrawl_time : time() ) });
      }
      event_save(this_object());
      add_succeeded_mess(({ "You collect " +
                            MONEY_HAND->money_value_string(data->value, place) +
                            " in royalties.\n",
                            "$N collects some royalties.\n" }));
      data->value = 0;
      if (!data->value && name != query_owner()) {
         map_delete(_royalties, name);
      }
      return 1;
   } else if (!data->value) {
      add_failed_mess("You have no royalties to collect.\n");
   } else {
      if (this_player()->query_value_in(place) < -data->value) {
         add_failed_mess("You do not have enough money to pay off "
                         "your debts.\n");
         return 0;
      }
      this_player()->pay_money(MONEY_HAND->create_money_array(-data->value, place),
                               place);
      add_succeeded_mess(({ "You pay off " +
                            MONEY_HAND->money_value_string(data->value, place) +
                            " in debt.\n",
                            "$N pays off some debt.\n" }));
      if (name != query_owner()) {
         map_delete(_royalties, name);
      } else {
         data->value = 0;
      }
      return 1;
   }
}
int do_collect_partial_royalties(string amount) {
   int amt;
   string place;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("Only the owners can do this.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   amt = MONEY_HAND->value_from_string(amount, place);
   if (!amt) {
      add_failed_mess("The value " + amount + " is not a valid money "
                      "amount.\n");
      return 0;
   }
   if (amt > query_owners_money()) {
      add_failed_mess("You cannot collect more money than you have.\n");
      return 0;
   }
   this_player()->adjust_money(MONEY_HAND->create_money_array(amt, place));
   ((class royalty_data)_royalties[query_owner()])->value -= amt;
   if (!((class royalty_data)_royalties[query_owner()])->value) {
      map_delete(_royalties, query_owner());
   }
   if (!_weekly_status) {
      _weekly_status = new(class weekly_status);
      _weekly_status->withdrawls = ({ });
   }
   _weekly_status->withdrawls += ({ new(class float_withdrawls, amount : amt,
                                        person : this_player()->query_name(),
                                        withdrawl_time : time() ) });
   event_save(this_object());
   add_succeeded_mess(({ "You collect " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " in royalties.\n",
                      "$N collects some money in royalties.\n" }));
   return 1;
}
int do_pay_entry() {
   string place;
   class parse_node ret;
   if (!_entry_cost) {
      add_failed_mess("Entry into " + the_short() + " is free.\n");
      return 0;
   }
   if (!is_open_for("entry", this_player()->query_name())) {
      add_failed_mess(the_short() + " is not currently open for "
                      "customers.\n");
      return 0;
   }
   ret = evaluate_expression(_entry_cost, this_player()->query_name());
   if (this_player()->query_value_in(place) < ret->value) {
      add_failed_mess("You do not have the " +
                      MONEY_HAND->money_value_string(ret->value, place) +
                      " needed to enter.\n");
      return 0;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(ret->value, place),
                            place);
   this_player()->add_property(file_name(this_object()),
                               _entry_time_limit * 60 * 60);
   add_succeeded_mess("$N pay$s " +
                      MONEY_HAND->money_value_string(ret->value, place) +
                      " for entry into " + the_short() + ".\n");
   return 1;
}
int do_add_royalties(string amount) {
   int amt;
   string place;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot add to the float.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   amt = MONEY_HAND->value_from_string(amount, place);
   if (!amt) {
      add_failed_mess("The value " + amount + " is not a valid money "
                      "amount.\n");
      return 0;
   }
   if (this_player()->query_value_in(place) < amt) {
      add_failed_mess("You do not have " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to add to the float.\n");
      return 0;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(amt, place),
                            place);
   if (!classp(_royalties[query_owner()])) {
       int value;
       value = _royalties[query_owner()];
       _royalties[query_owner()] = new(class royalty_data,
            value : value,
            last_withdrawl : time());
   }
   ((class royalty_data)_royalties[query_owner()])->value += amt;
   add_succeeded_mess(({ "You add " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to " + poss_short() + " float.\n",
                      "$N fiddles about in " + the_short() + ".\n" }));
   return 1;
}
int do_purchase() {
   object ob;
   ob = clone_object(COMMERCIAL_SALESPERSON);
   ob->move(this_object(), "$N arrives in a flash.\n");
   ob->set_commercial_type(query_commercial_type());
   ob->do_start_speil(this_player());
   return 1;
}
int do_deposit(object* obs) {
   object* monies;
   object money;
   string place;
   monies = filter(obs, (: $1->id(MONEY_ALIAS) :));
   if (!sizeof(monies)) {
      add_failed_mess("YOu cannot deposit any of $I.\n", obs);
      return 0;
   }
   money = monies[0];
   place = query_property("place");
   monies = MONEY_HAND->filter_legal_tender(money, place);
   if (monies[1]) {
      monies[1]->move(this_player());
   }
   if (!monies[0]) {
      add_failed_mess("You must use legal tender.\n");
      return 0;
   }
   adjust_royalty(query_owner(), monies[0]->query_value_in(place));
   monies[0]->move("/room/rubbish");
   add_succeeded_mess(({ "$N $V $I into " + the_short() + ".\n",
                         "$N $V some money into " + the_short() + ".\n" }),
                      monies[0..0]);
   event_save(this_object());
   return 1;
}
int do_black_list_add(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add people to the black list.\n");
      return 0;
   }
   name = lower_case(name);
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("Sorry, " + name + " does not play here.\n");
      return 0;
   }
   if (is_allowed(name)) {
      add_failed_mess("This person is in the list of people allowed to use "
                      "the shop.  They cannot be put on a black list.\n");
      return 0;
   }
   if (member_array(name, _black_list) != -1) {
      add_failed_mess("The person " + name + " is already in the "
                      "black list.\n");
      return 0;
   }
   _black_list += ({ name });
   event_save(this_object());
   add_succeeded_mess(({ "You add " + name + " to the black list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_black_list_add_ignore() {
   string *people;
   string *bad;
   string *ok;
   string name;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add people to the black list.\n");
      return 0;
   }
   people = this_player()->query_property("ignoring");
   if (!people) {
      add_failed_mess("You are not ignoring anyone.\n");
      return 0;
   }
   bad = ({ });
   ok = ({ });
   foreach (name in people) {
      name = lower_case(name);
      if (!PLAYER_HANDLER->test_user(name)) {
         bad += ({ name });
      } else if (member_array(name, _black_list) != -1) {
         bad += ({ name });
      } else {
         _black_list += ({ name });
         ok += ({ name });
      }
   }
   event_save(this_object());
   if (!sizeof(ok)) {
      add_failed_mess("Your ignore list is already added to the black list.\n");
      return 0;
   }
   add_succeeded_mess(({ "You add " + query_multiple_short(ok) + " to the "
                         "black list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_black_list_remove(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove people from "
                      "the black list.\n");
      return 0;
   }
   name = lower_case(name);
   if (member_array(name, _black_list) == -1) {
      add_failed_mess("The person " + name + " is not in the black list.\n");
      return 0;
   }
   _black_list -= ({ name });
   event_save(this_object());
   add_succeeded_mess(({ "You remove " + name + " from the black list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
private string variable_use_type(string seller) {
   return _use_type;
}
int do_measure() {
    this_player()->add_succeeded_mess( this_object(),
        ({
            "$N $V up the size of the property and calculate that it is "
            "about " + query_num(query_property_size()) + " square yards.\n",
            "$N $V up the size of the property.\n"
        }), ({ }) );
    return 1;
}
void init() {
   if (!_royalties) {
      _royalties = ([ ]);
   }
   player_housing::init();
   expression_util::init();
   add_command("collect", "royalties", (: do_collect() :));
   add_command("royalties", "", (: do_royalties() :));
   add_command("royalty", "", (: do_royalties() :));
   add_command("measure", "property", (: do_measure() :) );
   if (!is_allowed(this_player()->query_name())) {
      return ;
   }
   add_command("royalty", "list", (: do_royalty_list() :));
   add_command("royalties", "list", (: do_royalty_list() :));
   add_command("collect", "royalties of <string'amount'>",
               (: do_collect_partial_royalties($4[0]) :));
   add_command("royalty", "add <string'amount'> to float",
               (: do_add_royalties($4[0]) :));
   add_command("deposit", "[to] float <indirect:object>",
               (: do_deposit :));
   add_command("status", "room",
               (: do_status(0) :));
   add_command("status", "room {hint|hints}",
               (: do_status(1) :));
   add_command("status", "room weekly",
               (: do_weekly_status() :));
   add_command("name", "property <string'property name'>",
               (: do_name_property($4[0]) :));
   add_command("set", "use expression <string'expression'>",
               (: do_use_expression($4[0]) :));
   add_command("set",
               "use expression for <string'type'> as <string'expression'>",
               (: do_use_expression_type($4[0], $4[1]) :));
   add_command("set", "sign <indirect:object'sign'>",
               (: do_set_sign($1) :) );
   add_command("remove", "sign",
               (: do_remove_sign() :) );
   add_command("blacklist", "add <string'person'>",
               (: do_black_list_add($4[0]) :));
   add_command("blacklist", "add ignore",
               (: do_black_list_add_ignore() :));
   add_command("blacklist", "remove <string'person'>",
               (: do_black_list_remove($4[0]) :));
   add_command("purchase", "stuff", (: do_purchase() :));
}

==================================================
FILE: shops/inherit/craft_shop.c
==================================================

#include <money.h>
#include <shops/craft_shop.h>
inherit "/std/shops/inherit/open_shop";
private nosave object _controller;
private nosave string _save_dir_name;
private nosave function _allowed_to_sell;
private nosave function _when_sold_func;
private nosave int _max_sell_per_person;
private nosave int _cut;
private nosave int _minimum_cost;
private nosave function _extra_sell_check;
private nosave int _always_ask_price;
private nosave int _use_name;
private nosave int _no_royalty_commands;
int do_sell(object *obs);
void set_controller(string name);
int do_buy(object *obs, int force);
int do_delete(string id);
int do_browse(object *obs);
int do_change(object *obs, string str);
int do_change_name(object *obs, string str);
void set_allowed_to_sell(function f);
void set_minimum_cost(int i);
protected void sell_name(string name, object *sellable);
protected void sell_choice(string choice, object *sellable, string *names);
protected void determine_cost(string cost, string name, object *sellable);
protected void confirm_sale(string answer, int value, string name,
                            object *sellable, string category);
protected void confirm_sell_name_choice(string answer, string name,
                                        object *sellable);
protected void complete_sale(int value, string name, object *sellable, string category);
protected void do_confirm_sale(int value, string name, object *sellable);
void set_cut(int value);
int query_cut();
int check_open(object player, string command);
mixed query_property(string name);
string the_short();
string query_craft_shop_save_dir();
void create() {
   if (!_allowed_to_sell) {
      set_allowed_to_sell((: 1 :));
   }
   if (!_cut) {
      set_cut(10);
   }
   if (!_minimum_cost) {
      set_minimum_cost(12 * 4);
   }
   if (!_controller && _save_dir_name) {
      set_controller("/std/shops/controllers/craft_shop_controller");
      _controller->load_it();
   }
}
int value_from_string(string str, string place) {
   return MONEY_HAND->value_from_string(str, place);
}
protected void do_save_file(int type, mixed value, string fname) {
   string tmp, file;
   string dir;
   switch (type) {
   case CRAFT_SHOP_MAIN_SAVE_FILE :
     debug_printf("attempting to write main");
#ifdef USE_RAMDISK
     tmp = replace_string(query_craft_shop_save_dir(), "/save/",
                          "/save/ramdisk/");
     file = tmp + ".o";
#endif
     if(!file) {
       file = query_craft_shop_save_dir() + ".o";
     }
     debug_printf("writing main %s", file);
     tmp = save_variable(value);
     if (file_size(query_craft_shop_save_dir() + ".o") != -1) {
       unguarded( (: rename(query_craft_shop_save_dir() + ".o",
                            query_craft_shop_save_dir() + ".o.bak") :));
     }
     if(unguarded( (: write_file($(file), $(tmp), 1) :) )) {
       unguarded( (: rm($(file) + ".bak") :));
     } else {
       unguarded( (: rename($(file) + ".bak", $(file)) :));
     }
     break;
   case CRAFT_SHOP_DATA_SAVE_FILE :
#ifdef USE_RAMDISK
     dir = replace_string(query_craft_shop_save_dir(), "/save/", "/save/ramdisk/");
     if (file_size(dir) == -2) {
        file = dir + "/" + fname;
     }
#endif
     if(!file) {
       file = query_craft_shop_save_dir() + "/" + fname;
     }
     debug_printf("writing data %s", file);
     tmp = save_variable(value);
     if (!unguarded( (: write_file($(file), $(tmp), 1) :))) {
        debug_printf("failed to write data to %s", file);
     }
     break;
   case CRAFT_SHOP_REMOVE_DATA_SAVE_FILE :
#ifdef USE_RAMDISK
     file = replace_string(query_craft_shop_save_dir() + "/" + fname, "/save/",
                          "/save/ramdisk/");
     unguarded( (: rm($(file)) :) );
#endif
     unguarded((: rm(query_craft_shop_save_dir() + "/" + $(fname)) :));
     break;
   default :
     printf("Unknown file type to write in %O, of %O\n", __FILE__, type);
     break;
   }
}
protected string do_read_file(int type, string fname) {
   string tmp, file;
   switch (type) {
   case CRAFT_SHOP_MAIN_SAVE_FILE :
#ifdef USE_RAMDISK
     tmp = replace_string(query_craft_shop_save_dir(), "/save/",
                          "/save/ramdisk/");
     if(unguarded((: file_size($(tmp) + ".o") :)) > 0) {
       file = tmp + ".o";
     }
#endif
     if(!file) {
       tmp = query_craft_shop_save_dir();
       if(unguarded((: file_size($(tmp) + ".o") :)) > 0) {
         file = tmp + ".o";
       }
       if(unguarded((: file_size($(tmp) + ".o.bak") :)) > 0) {
         file = tmp + ".o.bak";
       }
     }
     if (!file) {
        debug_printf("No file found at %s or %s\n", tmp + ".o", tmp + ".o.bak");
        return 0;
     }
     tmp = unguarded( (: read_file($(file)) :) );
     if(tmp)
       return restore_variable(tmp);
     return 0;
   case CRAFT_SHOP_DATA_SAVE_FILE :
#ifdef USE_RAMDISK
     tmp = replace_string(query_craft_shop_save_dir() + "/" + fname,
                           "/save/", "/save/ramdisk/");
     if(unguarded((: file_size($(tmp)) :)) > 0)
       file = tmp;
#endif
     if(!file)
       file = query_craft_shop_save_dir() + "/" + fname;
     debug_printf("reading %s", file);
     tmp = unguarded( (: read_file($(file)) :) );
     if (tmp) {
       return restore_variable(tmp);
     }
     return 0;
   default :
     printf("Unknown file type to read in %O, of %O\n", __FILE__, type);
     break;
   }
}
void reload_shop() {
   set_controller("/std/shops/controllers/craft_shop_controller");
   _controller->load_it();
}
void set_controller(string name) {
   if (_controller) {
      _controller->dest_me();
   }
   _controller = clone_object(name);
   _controller->set_save_function((: do_save_file($1, $2, $3) :));
   _controller->set_load_function((: do_read_file($1, $2) :) );
}
object query_controller() {
   return _controller;
}
void set_save_dir(string fname) {
   _save_dir_name = fname;
}
string query_craft_shop_save_dir() {
   return _save_dir_name;
}
void set_allowed_to_sell(function func) {
   _allowed_to_sell = func;
}
function query_allowed_to_sell() {
   return _allowed_to_sell;
}
void set_max_sell_per_person(int num) {
   _max_sell_per_person = num;
}
int query_max_sell_per_person() {
   return _max_sell_per_person;
}
void set_always_ask_price(int ask_price) {
   _always_ask_price = ask_price;
}
int query_always_ask_price() {
   return _always_ask_price;
}
void set_use_name(int flag) {
   _use_name = flag;
}
int query_use_name() {
   return _use_name;
}
int query_maximum_sale_value(string person, object *obs) {
   return 0;
}
string query_extra_price_information(string person, object *obs) {
   return "";
}
int query_shop() {
   return 1;
}
object *query_shop_lift_items(string str, object player) {
   object *stuff;
   object *pk_ok;
   object ob;
   stuff = match_objects_for_existence(str, ({ _controller->query_sell_list() }));
   pk_ok = ({ });
   foreach (ob in stuff) {
      if (!pk_check(_controller->query_owner_of_shop_object(ob),
                      player, 1)) {
         pk_ok += ({ ob });
      }
   }
   if (sizeof(pk_ok) != sizeof(stuff)) {
      player->add_failed_mess(previous_object(),
                      "You cannot shoplift $I since you cannot "
                      "shoplift from non-player killers.\n", stuff);
   }
   return pk_ok;
}
void inform_of_buy(int value, object *obs, object player, string *sellers,
                   string *names, string *cats, int *values) {
}
int query_no_steal() {
   return 1;
}
int is_able_to_change(object ob) {
   return _controller->query_owner_of_shop_object(ob) ==
       this_player()->query_name();
}
int is_allowed_to_sell(object* obs, string name, string *sellable_names) {
   if ((sizeof(sellable_names)+sizeof(obs)) > query_max_sell_per_person() &&
       query_max_sell_per_person()) {
      add_failed_mess("Cannot sell $I, since you already have " +
                      number_as_string(sizeof(sellable_names)) +
                      " items listed with a maximum of " +
                      number_as_string(query_max_sell_per_person()) +
                      ".\n", obs);
      return 0;
   }
   return 1;
}
void init() {
   string storeroom;
   add_command("sell", "<indirect:object:me>");
   add_command("list", "");
   if (query_controller()) {
      storeroom = file_name(_controller->query_sell_list());
      add_command("buy", "<indirect:object:" + storeroom + ">",
                  (: do_buy($1, 0) :));
      add_command("browse", "<indirect:object:" + storeroom + ">",
                  (: do_browse($1) :));
      add_command("change", "price of <indirect:object:" + storeroom +
                            "> to <string>", (: do_change($1, $4[1]) :));
      add_command("change", "name of <indirect:object:" + storeroom +
                            "> to <string>", (: do_change_name($1, $4[1]) :));
   }
   if (!_no_royalty_commands) {
      add_command("collect", "royalties");
      add_command("royalties", "");
   }
   add_command("delete", "<string'sell id'>",
               (: do_delete($4[0]) :));
}
int do_sell_id(object* obs, string id, int force) {
   object *sellable;
   object *cannot;
   object *worn;
   string name;
   string *sellable_names;
   if (!check_open(this_player(), "sell")) {
      return 0;
   }
   sellable = filter(obs, query_allowed_to_sell());
   if (!sizeof(sellable)) {
      add_failed_mess("This shop does not deal in $I.\n", obs);
      return 0;
   }
   worn = this_player()->query_holding() + this_player()->query_armours();
   cannot = filter(sellable, (: member_array($1, $2) != -1 :), worn);
   if (sizeof(cannot)) {
       sellable -= cannot;
       tell_object(this_player(), "You decide not to sell " +
         query_multiple_short(cannot, "the") + ", because "
         "you are wearing or holding $V$0=it,them$V$.\n");
      if (!sizeof(sellable))  return 0;
   }
   name = this_player()->query_name();
   if (!is_allowed_to_sell(sellable, name, sellable_names)) {
      return 0;
   }
   if (query_cut() != 100) {
      write("Selling an item to this shop does not automatically give you the "
            "money.  You will get a cut of " + (100 - query_cut()) +
            "% of the sale price once the item has been sold by the shop.\n");   }
}
int do_sell(object *obs) {
   object *sellable;
   object *cannot;
   object *worn;
   string name;
   string *sellable_names;
   int i;
   int cost;
   string place;
   if (!check_open(this_player(), "sell")) {
      return 0;
   }
   sellable = filter(obs, query_allowed_to_sell());
   if (!sizeof(sellable)) {
      add_failed_mess("This shop does not deal in $I.\n", obs);
      return 0;
   }
   worn = this_player()->query_holding() + this_player()->query_armours();
   cannot = filter(sellable, (: member_array($1, $2) != -1 :), worn);
   if (sizeof(cannot)) {
       sellable -= cannot;
       tell_object(this_player(), "You decide not to sell " +
         query_multiple_short(cannot, "the") + ", because "
         "you are wearing or holding $V$0=it,them$V$.\n");
      if (!sizeof(sellable))  return 0;
   }
   name = this_player()->query_name();
   if (!is_allowed_to_sell(sellable, name, sellable_names)) {
      return 0;
   }
   if (query_cut() != 100) {
      write("Selling an item to this shop does not automatically give you the "
            "money.  You will get a cut of " + (100 - query_cut()) +
            "% of the sale price once the item has been sold by the shop.\n");
   }
   if (_use_name) {
      sell_name(query_multiple_short(sellable, 0, 1), sellable);
      add_succeeded_mess(({ "", "$N starts to sell $I to the shop.\n" }),
                         sellable);
      return 1;
   }
   obs->set_no_join();
   sellable_names = _controller->query_owner_sellables(name);
   sellable_names = uniq_array(sellable_names);
   if (!sizeof(sellable_names)) {
      write("You are not currently selling any items.  What item name "
            "would you like to list " + query_multiple_short(sellable) +
            " under?  (Blank line to quit)\nList name: ");
      input_to((: sell_name :), 0, sellable);
   } else {
      place = query_property("place");
      if (!place) {
         place = "default";
      }
      write("You currently have the following listed for sale:\n");
      for (i = 0; i < sizeof(sellable_names); i++) {
         cost = _controller->query_list_object_cost(sellable_names[i],
                                   this_player()->query_name());
         write(sprintf("  %c) %s (%s)\n", 'a' + i, sellable_names[i],
                       MONEY_HAND->money_value_string(cost, place)));
      }
      write("Select the letter of the choice to add to the item, or type "
            "'create' to create a new listing name.\n"
            "Your choice ([a-" + sprintf("%c", 'a' + sizeof(sellable_names) -1) +
            "],create) ? ");
      input_to((: sell_choice :), 0, sellable, sellable_names);
   }
   add_succeeded_mess(({ "", "$N starts to sell $I to the shop.\n" }),
                      sellable);
   return 1;
}
protected int check_sell_name( string name ) {
   if (strlen(name) > CRAFT_SHOP_MAX_NAME_LENGTH) {
      write("Sorry, that name is too long.  It can be a maximum of " +
            CRAFT_SHOP_MAX_NAME_LENGTH + " characters.\n");
      return 0;
   }
   if (strsrch(name, "%^") != -1) {
      write("Sorry, you cannot use colour sequences in names.\n");
      return 0;
   }
   return 1;
}
protected void sell_name(string name, object *sellable) {
   if (name == "" || name == 0) {
      write("Ok, cancelling the sale of " + query_multiple_short(sellable) +
            ".\n");
      return ;
   }
   if ( !check_sell_name( name ) ) {
      input_to((: sell_name :), 0, sellable);
      write("What name would you like to list " +
            query_multiple_short(sellable) + " under? ");
      return;
   }
   write("You wish to sell " + query_multiple_short(sellable) +
         " as '" + name + "' (y/n)? ");
   input_to((: confirm_sell_name_choice :), 0, name, sellable);
}
protected void confirm_sell_name_choice(string answer, string name,
                                        object *sellable) {
   answer = lower_case(answer);
   if (strlen(answer) > 0 && ( answer[0] == 'n' || answer[0] == 'q' ) ) {
      write("Ok, cancelling the sale of " + query_multiple_short(sellable) +
            ".\n");
      return ;
   }
   if (!strlen(answer) || answer[0] != 'y') {
      write("Unknown selection.\n");
      write("You wish to sell " + query_multiple_short(sellable) +
            " as '" + name + "' (y/n)? ");
      input_to( (: confirm_sell_name_choice :), 0, name, sellable);
      return ;
   }
   write(query_extra_price_information(this_player()->query_name(), sellable));
   write("How much money do you wish to sell the item '" + name + "' for? ");
   input_to((: determine_cost :), 0, name, sellable);
}
protected void sell_choice(string answer, object *sellables, string *names) {
   int cost;
   string place;
   int pos;
   if (sizeof(names) >= 17) {
      if (answer == "" || answer[0..1] == "qu") {
         write("Ok, cancelling the sale of " + query_multiple_short(sellables) +
             ".\n");
         return 0;
      }
   } else if (answer == "" || answer[0] == 'q') {
      write("Ok, cancelling the sale of " + query_multiple_short(sellables) +
            ".\n");
      return ;
   }
   answer = lower_case(answer);
   if (answer == "create") {
      write("Please enter the name you wish to list " +
            query_multiple_short(sellables) + " as.\nList name: ");
      input_to((: sell_name :), 0, sellables);
      return ;
   }
   if (strlen(answer) > 1 ||
       (answer[0] < 'a' || answer[0] >= 'a' + sizeof(names))) {
      write(sprintf("Your response must be between 'a' and '%c' or "
                    "'create'.\nChoice? ", 'a' + sizeof(names) - 1));
      input_to((: sell_choice :), 0, sellables, names);
      return ;
   }
   pos = answer[0] - 'a';
   cost = _controller->query_list_object_cost(names[pos],
                                              this_player()->query_name());
   if (!cost || _always_ask_price) {
      write("How much money do you wish to list the item '" + names[pos] +
            "' for? ");
      write(query_extra_price_information(this_player()->query_name(),
                                          sellables));
      input_to((: determine_cost :), 0, names[pos], sellables);
   } else {
      place = query_property("place");
      if (!place) {
         place = "default";
      }
      do_confirm_sale(cost, names[pos], sellables);
   }
}
protected void determine_cost(string cost, string name, object *sellable) {
   int max;
   int value;
   string place;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   value = value_from_string(cost, place);
   if (value < _minimum_cost) {
      if (!strlen(cost) ||
          lower_case(cost)[0] == 'q') {
         write("Aborting.\n");
         return ;
      }
      write("You must list your item as costing more than " +
            MONEY_HAND->money_value_string(_minimum_cost, place) + ".\n");
      write(query_extra_price_information(this_player()->query_name(),
                                          sellable));
      write("What do you wish to list " + name + " for? ");
      input_to("determine_cost", 0, name, sellable);
      return ;
   }
   max = query_maximum_sale_value(this_player()->query_name(), sellable);
   if (value > max && max) {
      write("You must list your item as costing less than " +
            MONEY_HAND->money_value_string(max, place) + ".\n");
      write(query_extra_price_information(this_player()->query_name(),
                                          sellable));
      write("What do you wish to list " + name + " for? ");
      input_to("determine_cost", 0, name, sellable);
      return ;
   }
   do_confirm_sale(value, name, sellable);
}
private void confirm_sale_question(int value,
                                   string name,
                                   object *sellables,
                                   string category) {
   string place;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   write("Confirming your sale of " + query_multiple_short(sellables) +
         " as '" + name +
         "' " + (category?"in category " + category + " ":"") +
         "for " + MONEY_HAND->money_value_string(value, place) + " (y/n)? ");
   input_to((: confirm_sale :), 0, value, name, sellables, category);
}
protected void do_confirm_sale(int value, string name, object *sellables) {
   if (_extra_sell_check) {
      evaluate(_extra_sell_check,
               (: confirm_sale_question :),
               value, name, sellables);
   } else {
      confirm_sale_question(value, name, sellables, 0);
   }
}
protected void confirm_sale(string answer, int value, string name,
                            object *sellable,
                            string category) {
   if (answer == "" || answer[0] == 'q' || answer[0] == 'Q' ||
       answer[0] == 'n' || answer[0] == 'N') {
      write("Ok, aborting sale of " + query_multiple_short(sellable) + ".\n");
      return 0;
   }
   if (answer[0] != 'y' && answer[0] != 'Y') {
      write("Please answer yes or no.\n");
      confirm_sale_question(value, name, sellable, category);
      return 0;
   }
   complete_sale(value, name, sellable, category);
}
protected void complete_sale(int value, string name, object *sellable,
                             string category) {
   object *bought;
   string place;
   object ob;
   if (_when_sold_func) {
      foreach (ob in sellable) {
         evaluate(_when_sold_func, ob);
      }
   }
   bought = _controller->buy_objects(sellable, name, value,
                                   this_player()->query_cap_name(), category);
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (sizeof(bought)) {
      write("Sold " + query_multiple_short(bought) + ", listed as '" +
            name + "' " + (category?"in category " + category + " ":"") +
            "for " + MONEY_HAND->money_value_string(value, place) +
            ".\nYou will need to come back later to pick up your royalties "
            "for the sale.\n");
      say(this_player()->query_cap_name() + " sold " +
          query_multiple_short(bought) + " to " + the_short() + ".\n");
   } else {
      write("Unable to sell " + query_multiple_short(sellable) + ".\n");
   }
}
int do_list() {
   string place;
   object *obs;
   object ob;
   mixed *stuff;
   string ret;
   if (!check_open(this_player(), "list")) {
      return 0;
   }
   obs = _controller->query_sell_list_obs();
   if (!sizeof(obs)) {
      add_failed_mess("The shop is empty.\n", ({ }));
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   stuff = unique_array(obs, (: _controller->query_id_of_shop_object($1) :) );
   stuff = sort_array(stuff, (:
                strcmp(_controller->query_id_of_shop_object($1[0]),
                       _controller->query_id_of_shop_object($2[0])) :) );
   ret = "";
   foreach (obs in stuff) {
      ob = obs[0];
      ret += "$I$9=$C$" + _controller->query_id_of_shop_object(ob) +
            ") $C$" + ob->short() + " for " +
            MONEY_HAND->money_value_string(ob->query_value(), place) + "; " +
            query_num(sizeof(obs)) + " left.\n";
   }
   write("$P$Shop list$P$" + ret);
   add_succeeded_mess( ({ "", "$N browses through the inventory.\n" }) );
   return 1;
}
int do_buy(object *obs, int force) {
   int value;
   string place;
   int player_money;
   object *bought;
   string *sellers;
   string *names;
   string *cats;
   int *values;
   if (!check_open(this_player(), "buy")) {
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   player_money = this_player()->query_value_in(place);
   value = _controller->value_of_objects(obs);
   if (value > player_money) {
      add_failed_mess("You cannot buy $I as "+
                      ( sizeof( obs ) > 1 ? "they cost ":"it costs " )+
                      MONEY_HAND->money_value_string(value, place) +
                      " and you do not have that much money.\n", obs );
      return 0;
   }
   sellers = map(obs, (: _controller->query_owner_of_shop_object($1) :));
   names = map(obs, (: _controller->query_name_of_shop_object($1) :));
   cats = map(obs, (: _controller->query_category_of_shop_object($1) :));
   values = map(obs, (: $1->query_value() :));
   bought = _controller->sell_objects(obs, place, this_player(),
                                     query_cut(), force, ref value);
   if (!sizeof(bought)) {
      if (sizeof(bought) > 1) {
         add_failed_mess("Cannot move any of $I into your inventory, nothing "
                         "bought.\n", obs);
      } else {
         add_failed_mess("Unable to find any objects to buy, the shop "
                         "seems to have some stock problems.\n");
      }
      return 0;
   }
   inform_of_buy(value, bought, this_player(), sellers, names, cats, values);
   add_succeeded_mess(({ "You buy $I for " +
                       MONEY_HAND->money_value_string(value, place) + ".\n",
                         "$N buys $I.\n" }), bought);
   return 1;
}
int do_delete(string id ) {
   if( !this_player()->query_director() ) {
      add_failed_mess( "This command is reserved for directors.\n", ({ }) );
      return 0;
   }
   if( !id || id == "" ) {
      add_failed_mess( "You have to choose a valid sell id.\n", ({ }) );
      return 0;
   }
   _controller->delete_objects(id);
   add_succeeded_mess( "$N $V some things.\n", ({ }) );
   return 1;
}
int do_browse(object *obs) {
   object *real_obs;
   object ob;
   string mess;
   string read;
   if (!check_open(this_player(), "browse")) {
      return 0;
   }
   if (sizeof(obs) > 10) {
      add_failed_mess("You cannot browse more than 10 things at once.\n");
      return 0;
   }
   real_obs = _controller->create_all_real_objects(this_player(), obs);
   mess = "$P$Browse$P$";
   foreach (ob in real_obs) {
      mess += ob->the_short() + ":\n" + ob->long();
      read = ob->query_readable_message();
      if (read) {
         mess += "You read " +
                 replace(ob->query_read_short(this_player()), "$name$",
                         ob->a_short()) + ":\n" +
                 ob->query_readable_message();
      }
   }
   real_obs->move("/room/rubbish");
   add_succeeded_mess(({ mess, "$N $V $I.\n" }), obs);
   return 1;
}
int do_change(object *obs, string change) {
   object *frog;
   int value;
   string place;
   if (!check_open(this_player(), "change")) {
      return 0;
   }
   frog = filter(obs, (: $1->short() == $2->short() :), obs[0]);
   if (sizeof(frog) != sizeof(obs)) {
      add_failed_mess("You cannot change the value of more than one "
                      "type of object at once.\n", obs);
      return 0;
   }
   if (!is_able_to_change(obs[0])) {
      add_failed_mess("You do not own $I.\n", obs);
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   value = value_from_string(change, place);
   if (value < _minimum_cost) {
      add_failed_mess("You cannot set $I to a value less than " +
                 MONEY_HAND->money_value_string(_minimum_cost, place) + ".\n",
                 obs);
      return 0;
   }
   _controller->change_value_of_shop_object(obs[0], value);
   add_succeeded_mess( ({ "You change the value of $I to " +
         MONEY_HAND->money_value_string(value, place) + ".\n",
         "$N changes the value of $I.\n" }), obs[0..0]);
   return 1;
}
int do_change_name(object *obs, string new_name) {
   object *frog;
   if (!check_open(this_player(), "change")) {
      return 0;
   }
   frog = filter(obs, (: $1->short() == $2->short() :), obs[0]);
   if (sizeof(frog) != sizeof(obs)) {
      add_failed_mess("You cannot change the value of more than one "
                      "type of object at once.\n", obs);
      return 0;
   }
   if (!is_able_to_change(obs[0])) {
      add_failed_mess("You do not own $I.\n", obs);
      return 0;
   }
   if( !check_sell_name( new_name ) ) {
      add_failed_mess( "Try another name.\n", ({ }) );
      return 0;
   }
   if (_controller->change_name_of_shop_object(obs[0], new_name,
                               _controller->query_dont_use_name())) {
      add_succeeded_mess(({ "You change the name of $I to " +
                               new_name + ".\n",
                               "$N changes the name of $I.\n" }),
                         ({ obs[0] }) );
   } else {
      add_failed_mess("The name " + new_name + " is already in use.\n", obs);
   }
   return 1;
}
int do_collect() {
   string name;
   string place;
   int value;
   if (!check_open(this_player(), "collect")) {
      return 0;
   }
   name = this_player()->query_name();
   value = _controller->query_royalty(name);
   if (!value) {
      add_failed_mess("You have no money owed to you here.\n");
      return 0;
   }
   if (value < 0) {
      add_failed_mess("You owe money to " + the_short() + ".\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   _controller->pay_out_royalty(name, place);
   log_file(__FILE__ + ".log",
            name + " collects " +
                      MONEY_HAND->money_value_string(value, place) +
                      " in royalties.\n");
   add_succeeded_mess(({ "You collect " +
                      MONEY_HAND->money_value_string(value, place) +
                      " in royalties.\n",
                      "$N collects some money in royalties.\n" }));
   return 1;
}
int do_royalties() {
   string name;
   string place;
   int value;
   if (!check_open(this_player(), "royalties")) {
      return 0;
   }
   name = this_player()->query_name();
   value = _controller->query_royalty(name);
   if (!value) {
      add_failed_mess("You have no money owed to you here.\n");
      return 0;
   }
   if (value < 0) {
      add_failed_mess("You owe money to " + the_short() + ".\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   add_succeeded_mess(({ "You have " +
                      MONEY_HAND->money_value_string(value, place) +
                      " in royalties currently.\n",
                      "$N checks $p royalties.\n" }));
   return 1;
}
void set_cut(int new_cut) {
   _cut = new_cut;
}
int query_cut() {
   return _cut;
}
void set_minimum_cost(int cost) {
   _minimum_cost = cost;
}
int query_minimum_cost() {
   return _minimum_cost;
}
void set_when_sold_function(function func) {
   _when_sold_func = func;
}
function query_when_sold_function() {
   return _when_sold_func;
}
int check_open(object player, string type) {
   if (!is_open(player, 0)) {
      add_failed_mess("The shop is not open.\n");
      return 0;
   }
   return 1;
}
void set_extra_sell_check(function func) {
   _extra_sell_check = func;
}
function query_extra_sell_check() {
   return _extra_sell_check;
}
void set_no_royalty_commands(int flag) {
   _no_royalty_commands = flag;
}
int query_no_royalty_commands() {
   return _no_royalty_commands;
}
void dest_me() {
  if(_controller) {
     _controller->dest_me();
  }
}

==================================================
FILE: shops/inherit/craft_shop_category.c
==================================================

#include <money.h>
#include <shops/craft_shop.h>
inherit "/std/shops/inherit/craft_shop";
private nosave function _cat_extra_sell_check;
private string _default_category;
#define DAY (24 * 60 * 60)
protected void setup_category(function func,
                              int value,
                              string name,
                              object* sellables);
protected void choose_category(string category,
                              function func,
                              int value,
                              string name,
                              object* sellables,
                              string* categories);
int do_list_category(string category);
int do_change_category(object* obs, string category);
void create() {
   ::set_extra_sell_check( (: setup_category :) );
   if (!_default_category) {
      _default_category = "General";
   }
   ::create();
}
void init() {
   string storeroom;
   ::init();
   if (query_controller()) {
      storeroom = file_name(query_controller()->query_sell_list());
      add_command("change", "category of <indirect:object:" + storeroom +
                            "> to <string'category'>",
                  (: do_change_category($1, $4[1]) :));
   }
   add_command("list", "<string'category'>", (: do_list_category($4[0]) :));
}
void add_shop_category(string category) {
   query_controller()->add_category_accepted(category);
}
void set_category_description(string category, string description) {
   query_controller()->set_category_description(category, description);
}
void set_category_information(string category, string information) {
   query_controller()->set_category_information(category, information);
}
void remove_shop_category(string category) {
   query_controller()->remove_category_accepted(category);
}
private void setup_default_category() {
   if (!query_controller()->is_valid_category(_default_category) &&
       _default_category) {
      add_shop_category(_default_category);
   }
}
string query_default_category() {
   return _default_category;
}
void set_controller(string name) {
   ::set_controller(name);
   setup_default_category();
}
void update_categories() {
   object *obs;
   object ob;
   obs = query_controller()->query_sell_list_obs();
   foreach (ob in obs) {
      if (!query_controller()->query_category_of_shop_object(ob)) {
         query_controller()->change_category_of_shop_object(ob, _default_category);
      }
   }
}
string query_real_category_name(string in_cat) {
   string* categories;
   string cat;
   categories = query_controller()->query_categories();
   foreach (cat in categories) {
      if (lower_case(cat)[0..strlen(in_cat)-1] == lower_case(in_cat)) {
          return cat;
      }
   }
   return 0;
}
protected void setup_category(function func,
                              int value,
                              string name,
                              object* sellables) {
   string* categories;
   string cat;
   int i;
   cat = query_controller()->query_category_of(name,
                                               this_player()->query_name());
   if (cat) {
      evaluate(func, value, name, sellables, cat);
   } else {
      categories = query_controller()->query_categories();
      if (sizeof(categories) == 1) {
         write("There is only category, putting it into the default " +
               categories[0] + ".\n");
         evaluate(func, value, name, sellables, categories[0]);
      } else {
         write("Categories:\n");
         for (i = 0; i < sizeof(categories); i++) {
            write(sprintf("%c) %s\n", i + 'A', categories[i]));
         }
         write("Which category do you wish to put '" + name + "' into? ");
         input_to((: choose_category :),
                  0,
                  func,
                  value,
                  name,
                  sellables,
                  categories);
      }
   }
}
private void complete_cat_sale(int value,
                               string name,
                               object* sellables,
                               string category,
                               function func) {
   evaluate(func, value, name, sellables, category);
}
protected void choose_category(string category,
                              function func,
                              int value,
                              string name,
                              object* sellables,
                              string* categories) {
   string real_category;
   if (!strlen(category)) {
      write("Ok, stopping the sell.\n");
      return ;
   }
   if (strlen(category) == 1) {
      category = lower_case(category);
      if (category[0] < 'a' ||
          category[0] >= 'a' + sizeof(categories)) {
         write("Sorry, " + category + " is out of range.  Try again.\n");
         write("Which category do you wish to put '" + name + "' into? ");
         input_to((: choose_category :),
                  0,
                  func,
                  value,
                  name,
                  sellables,
                  categories);
         return ;
      } else {
         real_category = categories[category[0] - 'a'];
      }
   } else {
      real_category = query_real_category_name(category);
      if (!real_category) {
         write("Sorry, " + category + " is not a category.\n");
         write("Which category do you wish to put '" + name + "' into? ");
         input_to((: choose_category :),
                  0,
                  func,
                  value,
                  name,
                  sellables,
                  categories);
         return ;
      }
   }
   if (!real_category) {
      setup_category(func, value, name, sellables);
   } else {
      if (_cat_extra_sell_check) {
         evaluate(_cat_extra_sell_check,
                  (: complete_cat_sale :),
                  value, name, sellables, real_category, func);
      } else {
         complete_cat_sale(value, name, sellables, real_category, func);
      }
   }
}
int do_list_category(string category) {
   string place;
   string info;
   object *obs;
   object ob;
   mixed *morestuff;
   string ret;
   string list;
   if (!check_open(this_player(), "list")) {
      return 0;
   }
   list = query_real_category_name(category);
   if (!list ||
       !query_controller()->is_valid_category(list)) {
      add_failed_mess("The category " + category + " does not exist.\n");
      return 0;
   }
   info = query_controller()->query_category_information(list);
   obs = query_controller()->query_sell_list_obs();
   if (!sizeof(obs)) {
      add_failed_mess("The shop is empty.\n", ({ }));
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   obs = filter(obs, (: query_controller()->query_category_of_shop_object($1)  == $2:), list );
   ret = "";
   ret += list + ":\n";
   if (info) {
      ret += "$I$3=" + info + "\n";
   }
   morestuff = unique_array(obs, (: query_controller()->query_id_of_shop_object($1) :));
   morestuff = sort_array(morestuff, (:
                strcmp(query_controller()->query_id_of_shop_object($1[0]),
                       query_controller()->query_id_of_shop_object($2[0])) :) );
   foreach (obs in morestuff) {
      ob = obs[0];
      ret += "$I$9=$C$   " + query_controller()->query_id_of_shop_object(ob) +
            ") $C$" + ob->short() + " for " +
            MONEY_HAND->money_value_string(ob->query_value(), place) + "; " +
            query_num(sizeof(obs)) + " left.\n";
   }
   write("$P$Shop list" + list + "$P$" + ret);
   add_succeeded_mess( ({ "", "$N browses through the inventory.\n" }) );
   return 1;
}
int do_list() {
   string place;
   object *obs;
   mixed *stuff;
   mixed *morestuff;
   string ret;
   string* categories;
   string cat;
   string desc;
   object ob;
   if (!check_open(this_player(), "list")) {
      return 0;
   }
   obs = query_controller()->query_sell_list_obs();
   if (!sizeof(obs)) {
      add_failed_mess("The shop is empty.\n", ({ }));
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   categories = query_controller()->query_categories();
   stuff = unique_array(obs, (: query_controller()->query_category_of_shop_object($1) :), 12 );
   ret = "";
   foreach (obs in stuff) {
      if (!query_controller()->query_category_of_shop_object(obs[0])) {
         cat = "No category";
         foreach (ob in obs) {
            query_controller()->change_category_of_shop_object(ob,
                              query_default_category());
         }
         cat = query_default_category();
      } else {
         cat = query_controller()->query_category_of_shop_object(obs[0]);
         categories -= ({ query_controller()->query_category_of_shop_object(obs[0]) });
         desc = query_controller()->query_category_description(cat);
      }
      morestuff = unique_array(obs, (: query_controller()->query_id_of_shop_object($1) :));
      ret += "$I$3=" + cat + ": " + sizeof(morestuff) +
             " different item" + (sizeof(morestuff)>1?"s":"") + " for sale.\n";
      if (desc) {
         ret += "$I$6=   " + desc + "\n";
      }
   }
   if (sizeof(categories) > 1) {
      ret += "$I$0=The categories " + query_multiple_short(categories) +
             " do not have anything for sale.\n";
   } else if (sizeof(categories)) {
      ret += "$I$0=The category " + query_multiple_short(categories) +
             " does not have anything for sale.\n";
   }
   ret += "\n$I$0=Please list each category for the items in the category.\n";
   write("$P$Shop list$P$" + ret);
   add_succeeded_mess( ({ "", "$N browses through the inventory.\n" }) );
   return 1;
}
int do_change_category(object *obs, string new_category) {
   object *frog;
   if (!check_open(this_player(), "change")) {
      return 0;
   }
   frog = filter(obs, (: $1->short() == $2->short() :), obs[0]);
   if (sizeof(frog) != sizeof(obs)) {
      add_failed_mess("You cannot change the category of more than one "
                      "type of object at once.\n", obs);
      return 0;
   }
   if (!is_able_to_change(obs[0])) {
      add_failed_mess("You do not own $I.\n", obs);
      return 0;
   }
   new_category = query_real_category_name(new_category);
   if (!new_category ||
       !query_controller()->is_valid_category(new_category)) {
      add_failed_mess("You must choose a category that exists.\n");
      return 0;
   }
   if (query_controller()->change_category_of_shop_object(obs[0], new_category)) {
      add_succeeded_mess(({ "You change the category of $I to " +
                               new_category + ".\n",
                               "$N changes the category of $I.\n" }),
                         ({ obs[0] }) );
   } else {
      add_failed_mess("Unable to change to category " + new_category + ".\n", obs);
   }
   return 1;
}
void set_extra_sell_check(function func) {
   _cat_extra_sell_check = func;
}
function query_extra_sell_check() {
   return _cat_extra_sell_check;
}
void set_default_category(string category) {
  _default_category = category;
}

==================================================
FILE: shops/inherit/craft_shop_category_modify.c
==================================================

#include <money.h>
#include <shops/craft_shop.h>
inherit "/std/shops/inherit/craft_shop_category";
private nosave int _minimum_age_to_vote;
private nosave int _minimum_age_to_nominate;
private nosave int _minimum_number_nominated;
private nosave int _minimum_number_voted;
private nosave int _percentage_needed_creation;
private nosave int _percentage_needed_deletion;
private nosave int _nomination_time;
private nosave int _election_time;
private nosave int _deletion_time;
#define DAY (24 * 60 * 60)
protected void setup_category(function func,
                              int value,
                              string name,
                              object* sellables);
protected void choose_category(string category,
                              function func,
                              int value,
                              string name,
                              object* sellables,
                              string* categories);
void create() {
   if (!_minimum_age_to_vote) {
      _minimum_age_to_vote = 2 * DAY;
   }
   if (!_minimum_age_to_nominate) {
      _minimum_age_to_nominate = 10 * DAY;
   }
   if (!_minimum_number_nominated) {
      _minimum_number_nominated = 4;
   }
   if (!_nomination_time) {
      _nomination_time = 7 * DAY;
   }
   if (!_election_time) {
      _election_time = 7 * DAY;
   }
   if (!_deletion_time) {
      _deletion_time = 7 * DAY;
   }
   if (!_minimum_number_voted) {
      _minimum_number_voted = 20;
   }
   if (!_percentage_needed_creation) {
      _percentage_needed_creation = 75;
   }
   if (!_percentage_needed_deletion) {
      _percentage_needed_deletion = 75;
   }
   ::create();
}
protected int category_function(string name,
                      int state,
                      string* voted,
                      int yes,
                      int no,
                      int abstain) {
   switch (state) {
   case CRAFT_CATEGORY_STATE_NOMINATING :
      if (sizeof(voted) > _minimum_number_nominated) {
         return _election_time;
      }
      break;
   case CRAFT_CATEGORY_STATE_VOTING :
      if (sizeof(voted) > _minimum_number_voted) {
         if (yes * 100 / (no + yes) >= _percentage_needed_creation) {
            return 1;
         }
      }
      break;
   case CRAFT_CATEGORY_STATE_DELETEING :
      if (sizeof(voted) > _minimum_number_voted) {
         if (yes * 100 / (no + yes) >= _percentage_needed_deletion) {
            return 1;
         }
      }
   }
   return 0;
}
void set_minimum_age_to_vote(int age) {
   _minimum_age_to_vote = age;
}
void set_minimum_age_to_nominate(int age) {
   _minimum_age_to_nominate = age;
}
void set_minimum_nomination_number(int num) {
   _minimum_number_nominated = num;
}
void set_nomination_time(int tim) {
   _nomination_time = tim;
}
void set_election_time(int tim) {
   _election_time = tim;
}
void set_deletion_time(int tim) {
   _deletion_time = tim;
}

==================================================
FILE: shops/inherit/expression_util.c
==================================================

inherit "/std/basic/expressions";
#include <expressions.h>
#include <shops/craft_shop.h>
#include <nroff.h>
int is_allowed(string person);
void event_save(object ob);
private nosave string _type;
void set_expression_type(string type) {
   _type = type;
}
string query_expression_type() {
   return _type;
}
int do_user_function_add(string def, string expr) {
   string name;
if (this_player()->query_name() != "presto")
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add functions to this store.\n");
      return 0;
   }
   name = parse_user_expression(def, expr);
   if (name) {
      if (strlen(query_last_expression_warning())) {
         write("WARNING!!! Any changes of types could cause expressions "
               "currently using the functions to fail.\n" +
               query_last_expression_warning());
      }
      write("You successfully add:\n" + query_user_function_string(name));
      add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
      event_save(this_object());
      return 1;
   }
   add_failed_mess(query_last_expression_error() + "\n");
   return 0;
}
int do_user_function_remove(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove functions from this store.\n");
      return 0;
   }
   if (query_user_function_return_type(name) != EXPRESSION_TYPE_ERROR) {
      if (remove_user_expression(name)) {
         add_succeeded_mess(({ "You remove the function " + name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
         return 1;
      }
   }
   add_failed_mess(query_last_expression_error() + "\n");
   return 0;
}
int do_approve_status_internal_functions() {
   string* names;
   string name;
   string ret;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }
   names = query_function_names();
   ret = "Functions:\n";
   foreach (name in names) {
      ret += query_type_name(query_function_type(name)) + " " + name +
             "(" + implode(map(query_function_args_types(name),
                               (: query_type_name($1) :)), ", ") +
             ")\n";
   }
   ret += "\nVariables:\n";
   names = query_variable_names();
   foreach (name in names) {
      ret += query_type_name(query_variable_type(name)) + " " + name +
             "\n";
   }
   write("$P$Internal functions$P$" + ret);
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_function_help(string name) {
   string nroff_fn;
   string str;
   string fname;
   fname = CRAFT_SHOP_EXPRESSION_HELP_DIR + name;
   if (file_size(fname) <= 0) {
      add_failed_mess("There is no help for the function '" + name + "'.\n");
      return 0;
   }
   nroff_fn = NROFF_DIR + replace(fname, "/", ".");
   str = NROFF_HAND->cat_file(nroff_fn, 1);
   if (!str) {
      NROFF_HAND->create_nroff(fname, nroff_fn);
      str = NROFF_HAND->cat_file(nroff_fn, 0);
   }
   write("$P$function: " + name + "$P$" + str);
   return 1;
}
int do_function_help_list() {
   string *names;
   names = get_dir(CRAFT_SHOP_EXPRESSION_HELP_DIR);
   if (!sizeof(names)) {
      add_failed_mess("There is no help on any functions.\n");
      return 0;
   }
   names -= ({ ".", "..", "RCS" });
   write(sprintf("%-#*s\n", this_player()->query_cols(), implode(names, "\n")));
   return 1;
}
int do_approve_status_functions(int hints) {
   string* names;
   string name;
   string ret;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }
   names = query_user_function_names();
   if (!sizeof(names)) {
      add_failed_mess("Could not find any user defined expressions.\n");
      return 0;
   }
   ret = "";
   foreach (name in names) {
      ret += query_user_function_string(name) + "\n";
   }
   if (hints) {
      ret += "$I$0=       Hint: add function <function> as <expression>";
      ret += "$I$0=       Hint: remove function <function>";
   }
   write("$P$User functions$P$" + ret);
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
void init() {
   if (!is_allowed(this_player()->query_name())) {
      return ;
   }
   add_command("add",
               _type + " function <string'function'> as <string'expression'>",
               (: do_user_function_add($4[0], $4[1]) :));
   add_command("remove",
               _type + " function <string'function'>",
               (: do_user_function_remove($4[0]) :));
   add_command("functions", _type + " internal",
               (: do_approve_status_internal_functions() :));
   add_command("functions", _type,
               (: do_approve_status_functions(0) :));
   add_command("functions", _type +" help list",
               (: do_function_help_list() :));
   add_command("functions", _type + " help <string'function name'>",
               (: do_function_help($4[0]) :));
   add_command("functions", _type + " hints",
               (: do_approve_status_functions(1) :));
}

==================================================
FILE: shops/inherit/item_shop.c
==================================================

#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <shops/item_shop.h>
#define INFINITE_LEFT 10000
#define TYPE "item shop type"
#define DISPLAY "display in shop"
#define SHOP_INHERIT "/std/shops/inherit/"
inherit SHOP_INHERIT + "clone_on_demand";
inherit SHOP_INHERIT + "open_shop";
inherit SHOP_INHERIT + "shop_event";
private nosave int _no_steal;
private nosave int _steal_difficulty;
private nosave string _shoplift_handler;
private nosave function _list_func;
private nosave function _browse_func;
private nosave function _buy_func;
private nosave function _sort_func;
void setup_safe();
void do_banking();
int do_word_buy(string str);
int do_word_browse(string str);
int do_buy( object *things );
int do_browse( object *things );
void remove_property(string name);
mixed query_property(string name);
void set_max_float( int );
int query_max_float();
private nosave object _safe;
private nosave int _hidden_safe;
private nosave int _max_float;
void create() {
  shop_event::create();
  clone_on_demand::create();
  this_object()->add_help_file("item_shop");
  setup_safe();
  set_max_float( 20000 + random( 50000 ) );
}
object query_safe() {
  return _safe;
}
void setup_safe() {
  if( !_safe ) {
    _safe = clone_object( ITEM_SHOP_ITEMS + "item_shop_safe" );
    _safe->set_difficulty( 2 + random( 7 ) );
    _safe->set_ownership( "shop" );
    if ( this_object()->query_hidden_safe( _safe ) ) {
        this_object()->add_hidden_object( _safe );
    } else {
        _safe->move( this_object() );
    }
  }
}
void set_safe(object safe) {
    _safe = safe;
    if ( _safe ) {
        _safe->set_ownership( "shop" );
        if ( this_object()->query_hidden_safe( _safe ) ) {
            this_object()->add_hidden_object( _safe );
        } else {
            _safe->move( this_object() );
        }
    }
}
void reset() {
  ::reset();
  if(!random(3)) {
    remove_property("inventory_loss");
  }
  do_banking();
}
mixed *switch_extra_properties(){
  return ({ TYPE, DISPLAY });
}
int query_shop() {
   return 1;
}
object *query_shop_lift_items(string str, object player) {
   return filter(match_objects_for_existence(str, ({ query_cont() })),
     (: query_num_items_left($1) > 0 :));
}
object shoplift_success(object ob) {
   object real_ob;
   real_ob = create_real_object(ob);
   return real_ob;
}
string query_shoplift_response_handler() { return _shoplift_handler; }
void set_shoplift_response_handler( string word ) { _shoplift_handler = word; }
void set_open_func(function func) {
   ::set_open_function(func);
}
void set_open_condition(function func) {
   ::set_open_function(func);
}
void set_buy_function(function func) {
  _buy_func = func;
}
function query_buy_function() {
   return _buy_func;
}
void set_browse_function(function func) {
  _browse_func = func;
}
function query_browse_function() {
   return _browse_func;
}
void set_list_function(function func) {
  _list_func = func;
}
function query_list_function() {
   return _list_func;
}
void set_sort_function(function func) {
   _sort_func = func;
}
function query_sort_function() {
   return _sort_func;
}
void set_no_steal(int i) { _no_steal = i; }
int query_no_steal() { return _no_steal; }
void set_steal_difficulty(int i) { _steal_difficulty = i; }
int query_steal_difficulty(int i) { return _steal_difficulty; }
void init() {
   if (query_cont()) {
      add_command( "list", "[all]" );
      add_command( "browse", "<indirect:object:"+file_name(query_cont())+">" );
      add_command( "browse", "<word>", (: do_word_browse($4[0]) :) );
      add_command( "buy", "<indirect:object:"+file_name(query_cont())+">" );
      add_command( "buy", "<word>", (: do_word_buy($4[0]) :) );
   }
}
private object find_object_from_number(int number) {
   object *things;
   things = all_inventory( query_cont() );
   if ( number >= sizeof( things ) ) {
      add_failed_mess( "There is no item with that label.\n" );
      return 0;
   }
   if (_sort_func) {
      things = sort_array(things, _sort_func);
   }
   return things[number];
}
private string letter_name(int letter,
                           object* things) {
   string bing;
   if (sizeof(things) > 26) {
      bing = "AA";
      bing[0] = 'A' + (letter / 26);
      bing[1] = 'A' + (letter % 26);
      return bing;
   }
   bing = "A";
   bing[0] = 'A' + letter;
   return bing;
}
private string start_letter() {
   object *things;
   things = all_inventory( query_cont() );
   return letter_name(0, things);
}
private string end_letter() {
   object *things;
   things = all_inventory( query_cont() );
   return letter_name(sizeof(things) - 1, things);
}
private int query_number_from_string(string name) {
   object *things;
   int pos;
   things = all_inventory( query_cont() );
   if (sizeof(things) > 26) {
      if (strlen(name) != 2) {
         return -1;
      }
      name = lower_case(name);
      if (name[0] < 'a' || name[0] > 'z') {
         return -1;
      }
      if (name[1] < 'a' || name[1] > 'z') {
         return -1;
      }
      pos = (name[0] - 'a') * 26 + name[1] - 'a';
      if (pos >= sizeof(things)) {
         return -1;
      }
      return pos;
   }
   if (strlen(name) != 1) {
      return -1;
   }
   name = lower_case(name);
   if (name[0] < 'a' || name[0] > 'z') {
      return -1;
   }
   pos = name[0] - 'a';
   if (pos >= sizeof(things)) {
      return -1;
   }
   return pos;
}
int query_cost( object thing ) {
   int cost;
   string place;
   if (!thing) {
      return 0;
   }
   if ( environment( thing ) == query_cont() ) {
      cost = (int)thing->query_property( "cost here" );
      if ( cost ) {
         return cost;
      }
   }
   cost = (int)thing->query_value_at( this_object() );
   place = query_property( "place" );
   if ( !place ) {
      return cost;
   }
   cost = (int)MONEY_HAND->query_total_value(
         (mixed *)MONEY_HAND->create_money_array( cost, place ), place );
   if ( environment( thing ) == query_cont() ) {
      thing->add_property( "cost here", cost );
   }
   return cost;
}
int do_list( string str ) {
   int i;
   int left;
   string list;
   string place;
   string display;
   object thing;
   object *listed;
   object *things;
   if (!is_open(this_player(), 0)) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
         add_failed_mess("The shop is not open.\n");
      }
      return 0;
   }
   listed = ({ });
   list = "";
   place = query_property( "place" );
   if ( !place || ( place == "" ) )  {
      place = "default";
   }
   if ( !query_cont() ) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_NOTHING, this_player())) {
         add_failed_mess( "There is nothing to buy here.\n" );
      }
      return 0;
   }
   things = all_inventory( query_cont() );
   if (_sort_func) {
      things = sort_array(things, _sort_func);
   }
   foreach ( thing in things ) {
      left = query_num_items_left(thing);
      if (!left) {
         i++;
         continue;
      }
      display = (string)thing->query_property( DISPLAY );
      if ( !stringp( display )  && thing->short()) {
         display = (string)thing->a_short();
      }
      if (display) {
         list += "$I$6=   "+ letter_name(i, things) +": "+ display +" for "+
               (string)MONEY_HAND->money_value_string(
               (int)this_object()->query_cost( thing ), place );
         if ( left == INFINITE_LEFT ) {
            list += " (plenty left).$I$0=\n";
         } else {
            list += " (" + query_num( left, 0 ) +" left).\n";
         }
         listed += ({ thing });
      }
      i++;
   }
   if ( list == "" ) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_NOTHING, this_player())) {
         add_failed_mess( "There is nothing to buy here.\n" );
      }
      return 0;
   }
   if (!broadcast_shop_event(ITEM_SHOP_EVENT_LIST, this_player(), list)) {
      list = "/global/events"->convert_message(list);
      write("$P$item list$P$" +
         "The following items are for sale:\n" + list);
      add_succeeded_mess(({ "", "$N list$s the inventory.\n" }), ({ }));
   }
   if (_list_func) {
      evaluate(_list_func, this_player(), listed);
   }
   return 1;
}
int do_word_buy(string str) {
   object thing;
   int i;
   if (!is_open(this_player(), 0)) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
         add_failed_mess("The shop is not open.\n");
      }
      return 0;
   }
   if ( strlen( str ) <= 2 ) {
      i = query_number_from_string( str );
      if ( i == -1) {
         if (!broadcast_shop_event(ITEM_SHOP_EVENT_BAD_LABEL, this_player(), str)) {
            add_failed_mess( "The item label must be from " +
                             start_letter() + " to " + end_letter() + ".\n" );
         }
         return 0;
      }
      thing = find_object_from_number(i);
      if ( !thing) {
         return 0;
      }
      return do_buy( ({ thing }) );
   }
   return 0;
}
int do_buy( object *things ) {
   int i, cost, value, ret, money_in_safe;
   string place;
   object thing, money, *sold, ob, *obs;
   mixed *money_arr, temp;
   if (!is_open(this_player(), 0)) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
         add_failed_mess("The shop is not open.\n");
      }
      return 0;
   }
   sold = ({ });
   for (i = 0; i < sizeof(things); i++) {
      if (query_num_items_left(things[i]) <= 0) {
         if (!broadcast_shop_event(ITEM_SHOP_EVENT_SOLD_OUT, this_player(), things[i..i])) {
            add_failed_mess( "The shop is sold out of "+
                  (string)things[ i ]->query_plural() +".\n" );
         }
         return 0;
      }
      place = query_property( "place" );
      if ( !place || ( place == "" ) ) {
         place = "default";
      }
      value = (int)this_player()->query_value_in( place );
      cost = (int)this_object()->query_cost( things[i] );
      if ( cost > value ) {
         if (!broadcast_shop_event(ITEM_SHOP_EVENT_TOO_EXPENSIVE, this_player(), things[i], cost, value)) {
            add_failed_mess("You cannot afford to buy $I.\n", ({ things[i] }));
         }
      } else {
        thing = create_real_object(things[i]);
        if (!thing){
          add_failed_mess( "Something is hosed.  Please file a bug "
                           "report.  Thank you.\n" );
          return 0;
        }
         ret = 1;
         this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
               cost, place ), place );
         if( _safe ) {
           money_arr = MONEY_HAND->create_money_array( cost, place );
           money = clone_object( "/obj/money" );
           money->set_money_array( money_arr );
           money->move( _safe );
           _safe->set_closed();
           _safe->set_locked();
           obs = all_inventory( _safe );
           money_in_safe = 0;
           foreach( ob in obs ) {
             if( ob->query_property( "money" ) ) {
               temp = ob->query_money_array();
               money_in_safe += MONEY_HAND->query_total_value( temp, place );
             }
           }
           if( money_in_safe >= query_max_float() )
            do_banking();
         }
         if (!broadcast_shop_event(ITEM_SHOP_EVENT_BUY_THING, this_player(), thing)) {
            add_succeeded_mess("$N $V $I.\n", ({ thing }) );
         }
         this_object()->something_bought( thing, this_player(), cost );
         if ( query_property( "package items" ) ) {
            thing = (object)this_object()->package_item( thing );
         }
         if ( (int)thing->move( this_player() ) != MOVE_OK ) {
            thing->move( this_object() );
            write( "You cannot pick "+ (string)thing->a_short() +
                  " up.  It's left on the floor for you.\n" );
         }
         sold += ({ thing });
      }
   }
   if (_buy_func) {
      evaluate(_buy_func, this_player(), sold);
   }
   return ret;
}
int do_word_browse( string words ) {
   int i;
   object thing;
   if (!is_open(this_player(), 0)) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
         add_failed_mess("The shop is not open.\n");
      }
      return 0;
   }
   if ( strlen( words ) <= 2 ) {
      i = query_number_from_string( words );
      if ( i == -1) {
         if (!broadcast_shop_event(ITEM_SHOP_EVENT_BAD_LABEL, this_player(), words)) {
            add_failed_mess( "The item label must be from " +
                          start_letter() + " to " + end_letter() + ".\n" );
         }
         return 0;
      }
      thing = find_object_from_number(i);
      if ( !thing) {
         return 0;
      }
      return do_browse( ({ thing }) );
   }
   return 0;
}
int do_browse( object *things ) {
   int i;
   int num;
   string place;
   string mess;
   if (!is_open(this_player(), 0)) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
         add_failed_mess("The shop is not open.\n");
      }
      return 0;
   }
   place = query_property( "place" );
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   mess = "";
   for (i = 0; i < sizeof(things); i++) {
      if (query_num_items_left(things[i])) {
         mess += things[i]->the_short() +
                 " is priced at " + MONEY_HAND->money_value_string(
                 this_object()->query_cost( things[ i ] ), place ) +
                 " and looks like:\n" + things[ i ]->long();
         num++;
      }
   }
   if (!num) {
      if (!broadcast_shop_event(ITEM_SHOP_EVENT_SOLD_OUT, this_player(), things)) {
         add_failed_mess("The shop is sold out of $I.\n", things);
      }
      return 0;
   }
   if (!broadcast_shop_event(ITEM_SHOP_EVENT_BROWSE, this_player(), things, mess)) {
      write("$P$Browse things$P$" + mess);
      add_succeeded_mess(({ "", "$N $V $I.\n", }), things);
   }
   if (_browse_func) {
      evaluate(_browse_func, this_player(), things);
   }
   return 1;
}
void dest_me() {
  ::dest_me();
}
void event_theft( object command_ob, object thief, object victim,
  object *stolen ) {
  int stolen_from, difficulty;
  if( _safe ) {
    if( victim == _safe ) {
      stolen_from = _safe->query_property( "stolen from" );
      if( !stolen_from )
        _safe->add_property( "stolen from", 1 );
      else
        _safe->add_property( "stolen from", stolen_from + 1 );
      difficulty = _safe->query_difficulty();
      if( difficulty + 1 <= 10 )
        _safe->set_difficulty( difficulty + 2 );
      else
        if( difficulty <= 10 )
          _safe->set_difficulty( difficulty + 1 );
    }
  }
}
void event_shoplift(object command_ob, object thief, object victim) {
   if (stringp(_shoplift_handler)) {
     if(_shoplift_handler != "none" ) {
       _shoplift_handler->handle_shoplift(thief, victim);
     }
   } else {
     "/obj/handlers/theft_handler"->handle_shoplift(thief, victim);
   }
}
void do_banking() {
  object ob, *obs;
  debug_printf( "Doing banking.\n" );
  if( _safe ) {
    obs = all_inventory( _safe );
     foreach( ob in obs ) {
       if( ob->query_property( "money" ) ) {
         ob->move( "/room/rubbish" );
       }
     }
   }
}
void set_max_float( int f ) {
  _max_float = f;
}
int query_max_float() {
  return _max_float;
}

==================================================
FILE: shops/inherit/newspaper_archive.c
==================================================

inherit "/std/shops/inherit/shop_event";
#include <room/newspaper.h>
#include <shops/newspaper_archive.h>
#include <money.h>
#include <move_failures.h>
private nosave string _area;
private nosave string _paper;
mixed query_property(string name);
void create() {
   shop_event::create();
}
void set_paper_area(string area) {
   _area = area;
}
string query_paper_area() {
   return _area;
}
void set_paper(string paper) {
   _paper = paper;
}
string query_paper() {
   return _paper;
}
int do_list_papers() {
   string paper;
   string* papers;
   string str;
   int cost;
   string place;
   place = query_property("place");
   if (_paper) {
      papers = ({ _paper });
   } else {
      papers = NEWSPAPER_HANDLER->query_papers_in_area(_area);
   }
   if (!sizeof(papers)) {
      if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_NO_PAPERS, this_player())) {
         add_failed_mess("There do appear to be any newspapers to get "
                         "back issues of.\n");
      }
      return 0;
   }
   str = "Back issues of the following papers:\n";
   foreach (paper in papers) {
      cost = NEWSPAPER_HANDLER->query_paper_cost(paper) * 10;
      if (NEWSPAPER_HANDLER->query_last_edition_num(paper)) {
         if (NEWSPAPER_HANDLER->query_last_edition_num(paper) > 1) {
            str += "$I$5=" + paper + " issues, 1 to " +
                   NEWSPAPER_HANDLER->query_last_edition_num(paper);
         } else {
            str += "$I$5=" + paper + " issue, 1";
         }
         str += " for " + MONEY_HAND->money_value_string(cost, place);
      } else {
         str += "$I$5=" + paper + " has no back issues.\n";
      }
      str += ".\n";
   }
   if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_LIST, this_player(),
                             str, papers)) {
      write("$P$Archives$P$" + str);
   }
   return 1;
}
int do_buy(string paper, int edition) {
   string found_paper;
   int pos;
   object ob;
   string place;
   string* papers;
   int cost;
   int* editions;
   place = query_property("place");
   if (_paper) {
      papers = ({ _paper });
   } else {
      papers = NEWSPAPER_HANDLER->query_papers_in_area(_area);
   }
   if (strlen(paper) == 1) {
      pos = lower_case(paper)[0] - 'a';
      if (pos < 0 || pos >= sizeof(papers)) {
         found_paper = papers[pos];
      }
   } else {
      for (pos = 0; pos < sizeof(papers); pos++) {
         if (lower_case(paper) == lower_case(papers[pos])) {
            found_paper = papers[pos];
         }
      }
   }
   if (!found_paper) {
      if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_INVALID_PAPER,
                                this_player(), paper)) {
         add_failed_mess("There is no paper called " + paper + ".\n");
      }
      return 0;
   }
   if (edition < 0 ||
       edition > NEWSPAPER_HANDLER->query_last_edition_num(found_paper)) {
      if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_INVALID_EDITION,
                                this_player(), paper, edition)) {
         add_failed_mess("There is no edition " + edition + " of the "
                         "paper " + found_paper + ".\n");
      }
      return 0;
   }
   cost = NEWSPAPER_HANDLER->query_paper_cost(found_paper) * 10;
   if (this_player()->query_value_in(place) < cost) {
      if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_TOO_POOR,
                                this_player(), paper, edition, cost)) {
         add_failed_mess("You need " +
                         MONEY_HAND->money_value_string(cost, place) +
                         " to buy a back issue of " + found_paper + ".\n");
      }
      return 0;
   }
   ob = clone_object("/obj/misc/newspaper");
   ob->set_paper(found_paper);
   ob->set_edition(edition);
   if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_MOVE_PAPER,
                             this_player(), paper, edition, cost, ob)) {
      if (ob->move(this_player()) != MOVE_OK) {
         ob->move(this_object());
         write("Unable to move the paper into your inventory, putting it "
               "on the floor.\n");
      }
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);
   if (!broadcast_shop_event(NEWSPAPER_ARCHIVE_EVENT_BOUGHT,
                             this_player(), paper, edition, cost, ob)) {
      add_succeeded_mess("$N buy$s edition " + edition + " of " +
                         found_paper + " for " +
                         MONEY_HAND->money_value_string(cost, place) + ".\n");
   }
   editions = this_player()->query_property("Paper " + found_paper);
   if (!editions) {
      editions = ({ });
   }
   if (member_array(edition, editions) == -1) {
      editions += ({ edition });
      this_player()->add_property("Paper " + found_paper, editions);
      NEWSPAPER_HANDLER->add_edition_paper_sold(_paper, edition,
                        cost);
   }
   return 1;
}
void init() {
   add_command("list", "[papers]", (: do_list_papers() :));
   add_command("buy", "<number'edition number'> of <string'paper name'>",
                (: do_buy($4[1], $4[0]) :));
}

==================================================
FILE: shops/inherit/object_expressions.c
==================================================

#include <expressions.h>
#include <player_handler.h>
#define CHARGE_MULT 10
string query_owner();
string* query_allowed();
void add_allowed_function(string name, int type, int* args, function value);
void add_allowed_variable(string name, int type, function value);
private int function_object_base_value(object* obs) {
   int value;
   object ob;
   int tmp;
   value = 1000000000;
   foreach (ob in obs) {
      tmp = ob->query_base_value();
      if (tmp < value) {
         value = tmp;
      }
   }
   return value;
}
private int function_object_value(object* obs) {
   int value;
   object ob;
   int tmp;
   value = 1000000000;
   foreach (ob in obs) {
      tmp = ob->query_value();
      if (tmp < value) {
         value = tmp;
      }
   }
   return value;
}
private int function_object_condition(object* obs) {
   int cond;
   object ob;
   int tmp;
   int max;
   cond = 100;
   foreach (ob in obs) {
      tmp = ob->query_cond();
      max = ob->query_max_cond();
      if (max) {
         tmp = tmp * 100 / max;
         if (tmp < cond) {
            cond = tmp;
         }
      }
   }
   return cond;
}
private int function_object_enchant(object*obs) {
   int enchant;
   object ob;
   int tmp;
   int max;
   string bing;
   if (!sizeof(obs)) {
      return 0;
   }
   if (!PLAYER_HANDLER->test_guild(query_owner())->query_see_octarine()) {
      foreach (bing in query_allowed()) {
         if (PLAYER_HANDLER->test_guild(bing)->query_see_octarine()) {
            tmp = 1;
         }
      }
      if (!tmp) {
         return 0;
      }
   }
   enchant = 100;
   foreach (ob in obs) {
      tmp = ob->query_enchant();
      max = ob->query_max_enchant();
      tmp = tmp * 100 / max;
      if (tmp < enchant) {
         enchant = tmp;
      }
   }
   return enchant;
}
private string function_object_type(object* obs) {
   string type;
   string old_type;
   object ob;
   if (!sizeof(obs)) {
      return 0;
   }
   foreach (ob in obs) {
      if (ob->query_weapon()) {
         type = "weapon";
      } else if (ob->query_armour()) {
         type = "armour";
      } else if (ob->query_clothing()) {
         type = "clothing";
      } else {
         type = "misc";
      }
      if (old_type && old_type != type) {
         type = "mixed";
      }
      old_type = type;
   }
   return type;
}
private object* function_object_stolen(object* obs) {
   obs = filter(obs, (: $1->query_property("stolen") :));
   return obs;
}
private object* function_object_warded(object* obs) {
   string classification;
   classification = "/std/effects/object/ward"->query_classification();
   obs = filter(obs, (: sizeof($1->effects_matching($2)) :), classification);
   return obs;
}
private object* function_object_contains_spell(object* obs, string spell_name) {
   string bing;
   int tmp;
   if (!sizeof(obs)) {
      return 0;
   }
   if (!PLAYER_HANDLER->test_guild(query_owner())->query_see_spells()) {
      foreach (bing in query_allowed()) {
         if (PLAYER_HANDLER->test_guild(bing)->query_see_spells()) {
            tmp = 1;
         }
      }
      if (!tmp) {
         return 0;
      }
   }
   obs = filter(obs, (: $1->query_magic_scroll() &&
           ($2 == "any" || lower_case($1->query_spell_name()) == lower_case($2)) :), spell_name);
   return obs;
}
private object* function_object_contains_imbue(object* obs, string ritual_name) {
   if (!sizeof(obs)) {
      return ({ });
   }
   obs = filter(obs, (: $1->query_faith_imbue() &&
      ($2 == "any" ||
       lower_case($1->query_ritual_name()) == lower_case($2)) :), ritual_name );
   return obs;
}
private int function_object_percentage_liquid(object* obs, string liquid_name) {
   object ob;
   object* liquids;
   object liq;
   int volume;
   int found;
   int tmp;
   if (!sizeof(obs)) {
      return 0;
   }
   volume = 100;
   foreach (ob in obs) {
      liquids = filter(all_inventory(ob), (: $1->query_liquid() :));
      if (sizeof(liquids))  {
         foreach (liq in liquids) {
            if (liq->query_short() &&
                lower_case(liq->query_short()) == lower_case(liquid_name)) {
               tmp = liq->query_weight() * 100 / ob->query_max_weight();
               if (tmp < volume) {
                  volume = tmp;
                  found = 1;
               }
            }
         }
      }
      else if (ob->query_liquid_short() &&
               lower_case(ob->query_liquid_short()) ==
               lower_case(liquid_name))
      {
         tmp = ob->query_water_volume() * 100 / ob->query_max_volume();
         if (tmp < volume)  {
            volume = tmp;
            found = 1;
         }
      }
   }
   if (found) {
      return volume;
   }
   return 0;
}
private int function_object_charges(object* obs) {
   int total = 0;
   int possible = 0;
   int charges;
   mixed info;
   object ob;
   foreach (ob in obs)  {
      charges = ob->query_charges();
      if (charges)  {
         info = ob->query_static_auto_load();
         if (pointerp(info)  &&  sizeof(info) == 2  &&  info[0] == charges)  {
            possible += info[1] * CHARGE_MULT;
            total += charges;
         }
      }
   }
   if (possible)
      return 100 * total / possible;
   else
      return 0;
}
private object* function_object_matching(object* obs, string match) {
   object ob;
   string *bits;
   string bit;
   object* ret;
   bits = explode(match, ",");
   ret = ({ });
   foreach (ob in obs)  {
      foreach(bit in bits)   {
         if (ob && ob->full_id(bit)) {
            ret += ({ ob });
         }
      }
   }
   return ret;
}
private object* function_object_short(object* obs, string match) {
   string* bits;
   object* result;
   bits = explode(match, ",");
   result = filter(obs, (: member_array(strip_colours($1->query_short()), $2) != -1 :),
                   bits);
   return result;
}
private object* function_contents(object ob) {
   if (!ob) {
      return ({ });
   }
   return all_inventory(ob);
}
void create() {
   if (!function_exists("add_allowed_function", this_object())) {
      return ;
   }
   add_allowed_function("objectenchant", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_enchant :) );
   add_allowed_function("objectvalue", EXPRESSION_TYPE_MONEY,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_value :) );
   add_allowed_function("objectbasevalue", EXPRESSION_TYPE_MONEY,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_base_value :) );
   add_allowed_function("objectcondition", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_condition :) );
   add_allowed_function("objecttype", EXPRESSION_TYPE_STRING,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_type :) );
   add_allowed_function("objectwarded", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_warded :) );
   add_allowed_function("objectstolen", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_stolen :) );
   add_allowed_function("charges", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_charges :) );
   add_allowed_function("containsspell", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_contains_spell :) );
   add_allowed_function("containsimbue", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_contains_imbue :) );
   add_allowed_function("percentageliquid", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_percentage_liquid :) );
   add_allowed_function("objectmatch", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_matching :) );
   add_allowed_function("objectshort", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_short :) );
   add_allowed_function("contents", EXPRESSION_TYPE_OBJECT +
                                    EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT }),
                        (: function_contents :) );
}

==================================================
FILE: shops/inherit/open_shop.c
==================================================

private nosave function _open_func;
void set_open_function(function func) {
   _open_func = func;
}
function query_open_function() {
   return _open_func;
}
int is_open(object player, int type) {
   if (_open_func) {
      return evaluate(_open_func, player, type);
   }
   return 1;
}
int test_open() {
    return is_open( this_player(), 0 );
}

==================================================
FILE: shops/inherit/pawn_shop.c
==================================================

#include <money.h>
#include <move_failures.h>
#define RECEIPT "/obj/misc/pawn_receipt"
#define TO this_object()
#define TP this_player()
inherit "/std/shop" ;
private int    _pawn_ttl ;
private mixed  _pawn_mess ;
private int    _pawn_markup ;
private string _shop_language;
void set_language( string lang ) {
    _shop_language = lang;
}
string query_language() {
    return _shop_language;
}
void set_pawn_markup( int percent ) {
    _pawn_markup = percent ;
}
int query_pawn_markup() {
    return _pawn_markup ;
}
void set_pawn_ttl( int ttl ) {
    _pawn_ttl = ttl ;
}
int query_pawn_ttl() {
    return _pawn_ttl ;
}
void set_pawn_mess( mixed mess ) {
    _pawn_mess = mess ;
}
string query_pawn_mess() {
    return _pawn_mess ;
}
void create() {
    do_setup++ ;
    ::create() ;
    do_setup-- ;
    add_help_file( "pawn_shop" ) ;
    remove_help_file( "shop" );
    _pawn_mess = ({
        "You pawn $ob$ for $money$.\n",
        "$client$ pawns $ob$.\n"
    }) ;
    _pawn_markup = 20 ;
    _pawn_ttl = 7 * 24 * 60 * 60 ;
    _shop_language = "morporkian" ;
    set_min_amount( 400 ) ;
    add_property( "no steal", 1 ) ;
    if ( ! do_setup ) {
        TO->setup() ;
        TO->reset() ;
    }
}
void init() {
    ::init() ;
    add_command( "pawn", "<indirect:object:me'items'>" ) ;
}
int do_pawn( object *in_obs ) {
    int value, total ;
    mixed *m_array ;
    object ob, money, receipt ;
    object *cheap, *cre, *expensive, *kept, *nobuy, *stolen, *worn ;
    string place, fn ;
    string *text = ({ }) ;
    if ( ! is_open( TP, 0 ) ) {
        return 0 ;
    }
    in_obs = uniq_array( in_obs ) ;
    cre = filter( in_obs, (: creator_object($1) :) ) ;
    if ( sizeof(cre) ) {
        if ( ! TP->query_creator() ) {
            tell_object( TP,
                "Oh dear, you shouldn't have " + query_multiple_short( cre ) +
                "!  "
                + ( sizeof(cre) > 1 ? "They disappear" : "It disappears" ) +
                " with a flash of octarine light.\n" ) ;
            cre->move( "/room/rubbish" ) ;
        } else {
            tell_object( TP,
                "You decide not to pawn " + query_multiple_short( cre ) +
                ", as " + ( sizeof(cre) > 1 ? "they are creator-only items"
                : "it is a creator-only item" ) + ".\n" ) ;
        }
        foreach( ob in cre ) {
            if ( fn = ob->query_property( "virtual name" ) ) {
                fn = ob->query_property( "virtual name" ) ;
            } else {
                fn = base_name( ob ) ;
            }
            text += ({ fn }) ;
        }
        log_file( "ILLEGAL_OBJECT", "%s: %s tried to pawn %s at %s.\n\n",
            ctime(time()), TP->query_name(), query_multiple_short( text ),
            file_name( TO ) ) ;
        in_obs -= cre ;
    }
    kept = filter_array( in_obs, (: $1->query_keep() :) ) ;
    if ( sizeof(kept) ) {
        tell_object( TP,
            "You decide not to pawn " + query_multiple_short( kept ) +
            ", as you are keeping " + ( sizeof(kept) > 1 ? "them" : "it" )
            + ".\n" ) ;
        in_obs -= kept ;
    }
    worn = filter( in_obs, (: $1->query_holder() || $1->query_worn_by() :) ) ;
    if ( sizeof(worn) ) {
        tell_object( TP, "You decide not to pawn "
            + query_multiple_short( worn ) + ", because you are wearing or "
            "holding " + ( sizeof(worn) > 1 ? "them" : "it" ) + ".\n" ) ;
        in_obs -= worn ;
    }
    stolen = filter( in_obs, (: $1->query_property( "stolen" ) :) ) ;
    if ( sizeof(stolen) ) {
        tell_object( TP,
            "You cannot pawn " + query_multiple_short( stolen ) +
            " because " + ( sizeof(stolen) > 1 ? "they're" : "it's" ) +
            " stolen!\n" ) ;
        in_obs -= stolen ;
    }
    nobuy = filter( in_obs, (: $1->do_not_sell() || TO->do_not_buy($1) :) ) ;
    if ( sizeof( nobuy ) ) {
        tell_object( TP,
            "You cannot pawn " + query_multiple_short( nobuy ) + ".\n" ) ;
        in_obs -= nobuy ;
    }
    cheap = filter( in_obs, (: $1->query_value() < TO->query_min_amount() :) ) ;
    if ( sizeof(cheap) ) {
        tell_object( TP,
            "You cannot pawn " + query_multiple_short( cheap ) +
            " as " + ( sizeof(cheap) > 1 ? "they are" : "it is" ) +
            " not expensive enough.\n" ) ;
        in_obs -= cheap ;
    }
    expensive = filter( in_obs,
        (: $1->query_value() > TO->query_max_amount() :) ) ;
    if ( sizeof(expensive) ) {
        tell_object( TP,
            "You cannot pawn " + query_multiple_short( expensive ) +
            " as " + ( sizeof(expensive) > 1 ? "they are" : "it is" ) +
            " too expensive.\n" ) ;
        in_obs -= expensive ;
    }
    if ( ! sizeof( in_obs ) ) {
        add_failed_mess( "You have nothing to pawn.\n" ) ;
        return 0 ;
    }
    foreach( ob in in_obs ) {
        value = scaled_value( ob->query_value() ) ;
        value = ( value * 90 ) / 100;
        total += value ;
        receipt = clone_object( RECEIPT ) ;
        if ( ! receipt ) {
            add_failed_mess(
                "Oh dear, something went very wrong (can't clone receipt object).  "
                "Please bugrep this room.\n" ) ;
            return 0 ;
        }
        receipt->setup_receipt( ob ) ;
        receipt->set_shop_path( TO ) ;
        receipt->set_item_value( value ) ;
        receipt->set_expiry_time( time() + query_pawn_ttl() ) ;
        receipt->setup_read_mess( _shop_language );
        receipt->move( TP ) ;
        ob->move( "/room/rubbish" ) ;
    }
    place = query_property( "place" ) ;
    if ( ! place || ( place == "" ) ) {
        place = "default" ;
    }
    m_array = MONEY_HAND->create_money_array(total, place);
    money = clone_object(MONEY_OBJECT);
    if ( ! money ) {
        add_failed_mess(
            "Oh dear, something went very wrong (can't clone money object).  "
            "Please bugrep this room.\n" ) ;
        return 0 ;
    }
    money->set_money_array(m_array);
    if ( money->move( TP ) != MOVE_OK ) {
        tell_object( TP,
            "You're too heavily burdened to accept all that money, so the "
            "shopkeeper puts it on the floor.\n" ) ;
        money->move( TO ) ;
    }
    do_parse( _pawn_mess, in_obs, TP,
        MONEY_HAND->money_string( m_array ), "" ) ;
    return 1 ;
}
int do_sell( object *in_obs ) {
    add_failed_mess(
        "If you just want to sell items, you'll need to find a general "
        "store.  Pawn shops are for pawning in.\n" ) ;
    return 0 ;
}

==================================================
FILE: shops/inherit/person_expressions.c
==================================================

#include <expressions.h>
#include <player_handler.h>
#include <clubs.h>
#include <nomic_system.h>
void add_allowed_function(string name, int type, int* args, function value);
void add_allowed_variable(string name, int type, function value);
private int variable_player_level(string seller) {
   return PLAYER_HANDLER->test_level(seller);
}
private string variable_player_guild(string seller) {
   string guild;
   guild = PLAYER_HANDLER->test_guild(seller);
   if (guild) {
      return guild->query_name();
   }
   return "";
}
private string variable_player_order(string seller) {
   string guild;
   guild = PLAYER_HANDLER->test_guild(seller);
   if (guild) {
      guild = guild->query_wizard_order();
      if (guild) {
         return replace_string(lower_case(guild), "_", " ");
      }
   }
   return "";
}
private string variable_player_name(string seller) {
   return lower_case(seller);
}
private string variable_player_deity(string seller) {
   string deity;
   deity = PLAYER_HANDLER->test_deity(seller);
   if (deity) {
      return deity;
   }
   return "";
}
private string variable_player_family(string seller) {
   string family;
   family = PLAYER_HANDLER->test_family(seller);
   if (family) {
      return family;
   }
   return "";
}
private int function_club_member(string club, string seller) {
   return CLUB_HANDLER->is_member_of(club, seller);
}
private int function_citizen_of(string region, string seller) {
   return NOMIC_HANDLER->is_citizen_of(region, seller);
}
void create() {
   if (!function_exists("add_allowed_variable", this_object())) {
      return ;
   }
   add_allowed_variable("level", EXPRESSION_TYPE_INTEGER,
                        (: variable_player_level :) );
   add_allowed_variable("guild", EXPRESSION_TYPE_STRING,
                        (: variable_player_guild :) );
   add_allowed_variable("deity", EXPRESSION_TYPE_STRING,
                        (: variable_player_deity :) );
   add_allowed_variable("family", EXPRESSION_TYPE_STRING,
                        (: variable_player_family :) );
   add_allowed_variable("order", EXPRESSION_TYPE_STRING,
                        (: variable_player_order :) );
   add_allowed_variable("playername", EXPRESSION_TYPE_STRING,
                        (: variable_player_name :) );
   add_allowed_function("clubmember", EXPRESSION_TYPE_BOOLEAN,
                        ({ EXPRESSION_TYPE_STRING }),
                        (: function_club_member :) );
   add_allowed_function("citizenof", EXPRESSION_TYPE_BOOLEAN,
                        ({ EXPRESSION_TYPE_STRING }),
                        (: function_club_member :) );
}

==================================================
FILE: shops/inherit/player_craft_shop.c
==================================================

inherit "/std/basic/expressions";
inherit "/std/shops/inherit/craft_shop_category";
#include <player.h>
#include <money.h>
#include <move_failures.h>
#include <shops/craft_shop.h>
#include <player_handler.h>
#include <clubs.h>
#define EXPRESSION_NO_CLASSES
#include <expressions.h>
#include <mail.h>
#include <nroff.h>
#define CHARGE_MULT 10
#define PLAYER_CRAFT_SHOP_CHECK_PROP "player craft shop check"
#define PLAYER_CRAFT_SHOP_SELL      1
#define PLAYER_CRAFT_SHOP_SELL_AUTO 2
#define PLAYER_CRAFT_SHOP_BUY       3
#define PLAYER_CRAFT_SHOP_APPROVE   4
#define PLAYER_CRAFT_SHOP_EXPR_DENY   1
#define PLAYER_CRAFT_SHOP_EXPR_ACCEPT 2
class approval_item  {
   mixed value;
   string list_name;
   int markup;
   int final_cost;
}
class expression_type {
   int type;
   class parse_node* condition;
   class parse_node* value;
   string list_name;
}
class approval {
   mixed hairy;
   class expression_type* expressions;
   int low_cost;
   int high_cost;
   mapping items;
   int num_allowed;
   int high_cost_deny;
}
class approval_obs {
   string seller;
   string category;
   int value;
   string name;
   int* saved;
   int enter_time;
   int* checkout;
}
#if USE_TRANSACTIONS
class shop_transaction {
   int time;
   string person;
   string objects;
   string name_cat;
   int type;
   int amount;
   mixed extra;
}
#endif
class shop_stats {
   int num_sold;
   int value_sold;
}
class seller_information {
   int max_sellable;
   int value_limit;
   int deny_value_limit;
}
private class approval_obs* _waiting_for_approval;
private class approval_obs* _approved;
private class approval _automatic_approval;
private string* _list_names;
private int _automatic_percentage;
private int _royalty_percentage;
private int _current_save_num;
private int _total_outgoing;
private int _total_ingoing;
private string _shop_name;
private class parse_node *_tax_expression;
#if USE_TRANSACTIONS
private class shop_transaction* _transactions;
#endif
private mapping _sell_stats;
private int _stats_start;
private mapping _sellers;
private string *_black_list;
private class parse_node* _buy_expression;
private class parse_node* _use_expression;
private string _auto_load_sign_str;
private int _broken_sign;
private mapping _num_checked_so_far;
private nosave string _parcel_post;
private nosave int _something_checkedout;
private nosave int _maximum_inventory;
private nosave object _sign_ob;
private nosave int _round_value;
private nosave int _max_list_names;
private nosave int _max_items_in_queue;
private nosave object _royalty_ob;
protected void confirm_approval(string answer, class approval_obs approve, int final_cost);
private mixed* parse_or(string str);
private int variable_player_level(string seller, int cost, object* ob);
private string variable_player_guild(string seller, int cost, object* ob);
private string variable_player_deity(string seller, int cost, object* ob);
private string variable_player_family(string seller, int cost, object* ob);
private string variable_player_order(string seller, int cost, object* ob);
private object* variable_objects(string seller, int cost, object* ob);
private string function_object_type(object*, string seller, int cost, object* ob);
private int function_object_value(object*, string seller, int cost, object* ob);
private int function_object_base_value(object*, string seller, int cost, object* ob);
private int function_object_condition(object*, string seller, int cost, object* ob);
private int function_object_enchant(object*, string seller, int cost, object* ob);
private object* function_object_stolen(object*, string seller, int cost, object* ob);
private object* function_object_warded(object*, string seller, int cost, object* ob);
private int function_object_charges(object*, string seller, int cost, object *ob);
private int variable_sale_cost(string seller, int cost, object* ob, string name, string category);
private string variable_sale_name(string seller, int cost, object* ob, string name, string category);
private string variable_sale_category(string seller, int cost, object* ob, string name, string category);
private int function_club_member(string club, string seller, int cost, object* ob);
private object* function_object_contains_spell(object*, string spell, string seller, int cost, object* ob);
private object* function_object_contains_imbue(object*, string spell, string seller, int cost, object* ob);
private int function_object_percentage_liquid(object*, string liquid, string seller, int cost, object* ob);
private object* function_object_matching(object*, string match, string seller, int cost, object* ob);
private object* function_object_short(object* obs, string match, string seller, int cost, object* fluff);
private int function_inventory_number(string short, string seller, int cost, object* ob);
private object* function_contents(object ob, string seller, int cost, object* obs);
string query_owner();
int is_allowed(string person);
void do_save();
void event_save(object thing);
string *query_allowed();
void set_short(string short);
void add_property(string name, mixed value);
void create() {
   class parse_node* expr;
   _round_value = 1;
   if (!_waiting_for_approval) {
      _waiting_for_approval = ({ });
   }
   if (!_approved) {
      _approved = ({ });
   }
   if (!_list_names) {
      _list_names = ({ });
   }
   if (!_automatic_approval) {
      _automatic_approval = new(class approval);
      _automatic_approval->expressions = ({ });
      _automatic_approval->items = ([ ]);
   }
   if (!_automatic_percentage) {
      _automatic_percentage = 10;
   }
#if USE_TRANSACTIONS
   if (!_transactions) {
      _transactions = ({ });
   }
#endif
   if (!_sell_stats) {
      _sell_stats = ([ ]);
   }
   if (!_stats_start) {
      _stats_start = time();
   }
   if (!_sellers) {
      _sellers = ([ ]);
   }
   if (!_black_list) {
      _black_list = ({ });
   }
   if (!_num_checked_so_far) {
      _num_checked_so_far = ([ ]);
   }
   if (!_tax_expression)  {
      _tax_expression = ({ });
   }
   set_cut(100);
   _max_items_in_queue = 100;
   craft_shop_category::create();
   expressions::create();
   if (_shop_name) {
      set_short(_shop_name);
      add_property("determinate", "");
   }
   set_always_ask_price(1);
   if (!_buy_expression) {
      expr = parse_boolean_string("false");
      _buy_expression = expr;
   }
   if (!_use_expression) {
      expr = parse_boolean_string("false");
      _use_expression = expr;
   }
   add_allowed_variable("level", EXPRESSION_TYPE_INTEGER,
                        (: variable_player_level :) );
   add_allowed_variable("guild", EXPRESSION_TYPE_STRING,
                        (: variable_player_guild :) );
   add_allowed_variable("deity", EXPRESSION_TYPE_STRING,
                        (: variable_player_deity :) );
   add_allowed_variable("family", EXPRESSION_TYPE_STRING,
                        (: variable_player_family :) );
   add_allowed_variable("order", EXPRESSION_TYPE_STRING,
                        (: variable_player_order :) );
   add_allowed_variable("objects", EXPRESSION_TYPE_OBJECT +
                                   EXPRESSION_TYPE_ARRAY_OFFSET,
                        (: variable_objects :) );
   add_allowed_function("objectenchant", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_enchant :) );
   add_allowed_function("objectvalue", EXPRESSION_TYPE_MONEY,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_value :) );
   add_allowed_function("objectbasevalue", EXPRESSION_TYPE_MONEY,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_base_value :) );
   add_allowed_function("objectcondition", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_condition :) );
   add_allowed_function("objecttype", EXPRESSION_TYPE_STRING,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_type :) );
   add_allowed_function("objectwarded", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_warded :) );
   add_allowed_function("objectstolen", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_stolen :) );
   add_allowed_variable("salecost", EXPRESSION_TYPE_MONEY,
                        (: variable_sale_cost :) );
   add_allowed_variable("salename", EXPRESSION_TYPE_STRING,
                        (: variable_sale_name :) );
   add_allowed_variable("salencategory", EXPRESSION_TYPE_STRING,
                        (: variable_sale_category :) );
   add_allowed_function("charges", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET }),
                        (: function_object_charges :) );
   add_allowed_function("clubmember", EXPRESSION_TYPE_BOOLEAN,
                        ({ EXPRESSION_TYPE_STRING }),
                        (: function_club_member :) );
   add_allowed_function("containsspell", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_contains_spell :) );
   add_allowed_function("containsimbue", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_contains_imbue :) );
   add_allowed_function("percentageliquid", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_percentage_liquid :) );
   add_allowed_function("objectmatch", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING }),
                        (: function_object_matching :) );
   add_allowed_function("objectshort", EXPRESSION_TYPE_OBJECT + EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT +
                           EXPRESSION_TYPE_ARRAY_OFFSET,
                           EXPRESSION_TYPE_STRING,
                           EXPRESSION_TYPE_BOOLEAN }),
                        (: function_object_short :) );
   add_allowed_function("inventorynumber", EXPRESSION_TYPE_INTEGER,
                        ({ EXPRESSION_TYPE_STRING, }),
                        (: function_inventory_number :) );
   add_allowed_function("contents", EXPRESSION_TYPE_OBJECT +
                                    EXPRESSION_TYPE_ARRAY_OFFSET,
                        ({ EXPRESSION_TYPE_OBJECT }),
                        (: function_contents :) );
}
private string strip_quotes(string str)  {
   if (str)  {
      if (str[0] == '\"')  str = str[1 .. ];
      if (str[<1] == '\"')  str = str[0 .. <2];
   }
   return str;
}
void set_maximum_waiting_queue_size(int size) {
   _max_items_in_queue = size;
}
int query_maximum_waiting_queue_size() {
   return _max_items_in_queue;
}
void set_maximum_inventory_size(int size) {
   _maximum_inventory = size;
}
int query_maximum_inventory_size() {
   return _maximum_inventory;
}
void set_parcel_post(string parcel) {
   _parcel_post = parcel;
}
string query_parcel_post() {
   return _parcel_post;
}
void set_shop_name(string name) {
   _shop_name = name;
   add_property("determinate", "");
   set_short(_shop_name);
}
string query_shop_name() {
   return _shop_name;
}
void set_round_price(int round) {
   _round_value = round;
}
int query_round_prices() {
   return _round_value;
}
class approval_obs* query_approval_list(int approved) {
   if (approved) {
      return _approved;
   } else {
      return _waiting_for_approval;
   }
}
int query_number_of_items_listed(string name) {
   int num;
   class approval_obs bing;
   name = lower_case(name);
   num = sizeof(query_controller()->query_owner_sellables(name));
   foreach (bing in _waiting_for_approval) {
      if (lower_case(bing->seller) == name) {
         num += sizeof(bing->saved);
      }
   }
   return num;
}
int query_royalty(string name) {
   return query_controller()->query_royalty(name);
}
void adjust_royalty(string name, int amount) {
   query_controller()->adjust_royalty(name, amount);
}
mixed is_item_approved(string seller, int value, string name, object* sellables,
                     string category, int ref final_cost) {
   string short;
   object ob;
   int item_approval;
   class expression_type bing;
   class parse_node frog;
   int cost;
   mixed item;
   final_cost = ((value * (100 + _automatic_percentage)) / 100);
   value = value - (cost % _round_value);
   if (is_allowed(seller)) {
      final_cost = value;
      return 1;
   }
   seller = lower_case(seller);
   if (_sellers[seller] &&
       _sellers[seller]->deny_value_limit) {
      if (_sellers[seller]->deny_value_limit < value) {
         return -1;
      }
   } else if (_automatic_approval->high_cost_deny &&
              _automatic_approval->high_cost_deny <= value) {
      return -1;
   }
   foreach (ob in sellables) {
      if (!ob) {
         return -1;
      }
      short = ob->query_short();
      if (_automatic_approval->items[short]) {
         if (classp(_automatic_approval->items[short])) {
            item = ((class approval_item)_automatic_approval->items[short])->value;
         } else {
            item = _automatic_approval->items[short];
         }
         if (pointerp(item)) {
            frog = evaluate_expression(item,
                                     seller,
                                     value,
                                     ({ ob }),
                                     name,
                                     category);
            cost = frog->value - (frog->value % _round_value);
            if (cost < value) {
               item_approval = 0;
               break;
            }
            item_approval++;
         } else if (item < value) {
            item_approval = 0;
            break;
         } else {
            item_approval++;
         }
      }
   }
   if (item_approval) {
      if (classp(_automatic_approval->items[short]))  {
         class approval_item womble;
         womble = _automatic_approval->items[short];
         if (sizeof(womble) == 3) {
            _automatic_approval->items[short] = new(class approval_item,
                   markup : womble->markup,
                   value : womble->value,
                   list_name : womble->list_name,
                   final_cost : 0);
            womble = _automatic_approval->items[short];
         }
         if (womble->markup) {
            final_cost = ((value * (100 + womble->markup)) / 100);
         } else if (womble->final_cost) {
            final_cost = womble->final_cost;
         }
         if (womble->list_name) {
            return womble->list_name;
         } else {
            return 1;
         }
      } else {
         return 1;
      }
   }
   if (!pointerp(_automatic_approval->expressions)) {
      _automatic_approval->expressions = ({ });
   }
   foreach (bing in _automatic_approval->expressions) {
      if (evaluate_expression(bing->condition,
                              seller,
                              value,
                              sellables,
                              name,
                              category)->value) {
         if (bing->type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
            frog = evaluate_expression(bing->value,
                                 seller,
                                 value,
                                 sellables,
                                 name,
                                 category);
            cost = frog->value - (frog->value % _round_value);
            if (cost >= value) {
               if (bing->list_name) {
                  return bing->list_name;
               }
               else if (classp(_automatic_approval->items[short]))  {
                  return ((class approval_item)_automatic_approval->items[short])->list_name;
               }
               else return 1;
            }
         } else {
            return -1;
         }
      }
   }
   if (_sellers[seller] &&
       _sellers[seller]->value_limit) {
      if (_sellers[seller]->value_limit < value) {
         return 0;
      } else if (classp(_automatic_approval->items[short]))  {
         return ((class approval_item)_automatic_approval->items[short])->list_name;
      }
      else return 1;
   } else if (_automatic_approval->high_cost &&
              _automatic_approval->high_cost < value) {
      return 0;
   }
   if (_automatic_approval->low_cost &&
       _automatic_approval->low_cost >= value) {
      if (classp(_automatic_approval->items[short]))  {
         return ((class approval_item)_automatic_approval->items[short])->list_name;
      }
      else return 1;
   }
   return 0;
}
int is_allowed_to_use_shop(string person) {
   class parse_node frog;
   if (is_allowed(person) || !sizeof(_use_expression)) {
      return 1;
   }
   frog = evaluate_expression(_use_expression, person, 0, ({ }), 0, 0);
   return frog->value;
}
int check_open(object player, string type) {
   if (!::check_open(player)) {
      return 0;
   }
   if (type == "sell") {
      if (sizeof(query_approval_list(0)) + sizeof(query_approval_list(1)) >= _max_items_in_queue) {
         add_failed_mess("Unable to sell things, the shop is full.\n");
         return 0;
      }
   }
   if (member_array(player->query_name(), _black_list) != -1) {
      add_failed_mess("You are not allowed to use this shop.\n");
      return 0;
   }
   if (!is_allowed_to_use_shop(player->query_name())) {
      add_failed_mess("The shop is currently closed.\n");
      return 0;
   }
   return 1;
}
void set_controller(string name) {
   ::set_controller(name);
   query_controller()->set_dont_use_name(1);
}
int is_allowed_to_sell(object *obs, string name, string *sellable_names) {
   int num;
   int max;
   if (_automatic_approval->num_allowed ||
       _sellers[name]) {
      num = query_number_of_items_listed(name) + sizeof(obs);
      if (_sellers[name] && _sellers[name]->max_sellable) {
         max = _sellers[name]->max_sellable;
      } else {
         max = _automatic_approval->num_allowed;
      }
      if (num > max) {
         add_failed_mess("You cannot have more than " + max + " items "
                         "listed at " + the_short() + ", with this sale you "
                         "would have " +
                         num + ".\n");
         return 0;
      }
   }
   if (member_array(lower_case(name), _black_list) != -1) {
      add_failed_mess("You are not allowed to sell things here.\n");
      return 0;
   }
   num = sizeof(query_controller()->query_sell_list_obs());
   if (num + sizeof(obs) > query_maximum_inventory_size()) {
      add_failed_mess("The shop is full, it can only hold " +
                      query_maximum_inventory_size() + " and it currently "
                      "holds " + num + ".\n");
      return 0;
   }
   return 1;
}
int* query_maximum_sale_value_both(string person, object item) {
   int max_deny;
   int max_accept;
   string short;
   class expression_type stuff;
   mixed app_item;
   if (_sellers[person]) {
      if (_sellers[person]->value_limit) {
         max_accept = _sellers[person]->value_limit;
      }
      if (_sellers[person]->deny_value_limit) {
         max_deny = _sellers[person]->deny_value_limit;
      }
   }
   if (!max_accept) {
      max_accept = _automatic_approval->high_cost;
   }
   if (!max_deny) {
      max_deny = _automatic_approval->high_cost_deny;
   }
   short = item->query_short();
   if (_automatic_approval->items[short]) {
      if (classp(_automatic_approval->items[short]))  {
         app_item = ((class approval_item)_automatic_approval->items[short])->value;
      } else {
         app_item= _automatic_approval->items[short];
      }
      if (pointerp(app_item)) {
         max_accept = evaluate_expression(app_item,
                                        person, 0, ({ item }), 0, 0)->value;
      } else if (app_item < max_deny) {
         max_accept = app_item;
      }
   }
   foreach (stuff in _automatic_approval->expressions) {
      if (evaluate_expression(stuff->condition, person, 0, ({ }), 0, 0)->value) {
         if (stuff->type == PLAYER_CRAFT_SHOP_EXPR_DENY) {
            max_deny = evaluate_expression(stuff->value, person, 0, ({ item }), 0, 0)->value;
         } else {
            max_accept = evaluate_expression(stuff->value, person, 0, ({ item }), 0, 0)->value;
         }
      }
   }
   max_accept -= max_accept % _round_value;
   max_deny -= max_deny % _round_value;
   return ({ max_accept, max_deny });
}
int query_maximum_sale_value(string person, object* obs) {
   int* stuff;
   object ob;
   int cur_deny;
   foreach (ob in obs) {
      stuff = query_maximum_sale_value_both(person, ob);
      if (!cur_deny && stuff[1]) {
         cur_deny = stuff[1];
      } else if (cur_deny && cur_deny > stuff[1]) {
         cur_deny = stuff[1];
      }
   }
   return cur_deny;
}
string query_extra_price_information(string seller, object *obs) {
   int* max;
   int* max_tmp;
   string ret;
   string place;
   object ob;
   max = ({ 0, 0 });
   foreach (ob in obs) {
      max_tmp = query_maximum_sale_value_both(seller, ob);
      if (max_tmp[0] && max[0] > max_tmp[0]) {
         max[0] = max_tmp[0];
      }
      if (max_tmp[1] && max[1] > max_tmp[1]) {
         max[1] = max_tmp[1];
      }
   }
   ret = "";
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (max[0]) {
      ret += "the maximum price you can sell this straight into the "
             "inventory for is " +
             MONEY_HAND->money_value_string(max[0], place);
   }
   if (max[1]) {
      if (max[0]) {
         ret += " and ";
      }
      ret += "the maximum price you can sell the item for at all is " +
             MONEY_HAND->money_value_string(max[1], place);
   }
   return capitalize(ret) + ".\n";
}
protected int create_auto_load_file(mixed ob, int fixed_num) {
   mixed *auto_load;
   string tmp;
   if (objectp(ob)) {
      if (this_player()) {
         catch(auto_load = this_player()->create_auto_load(({ ob })));
      }
      if (!auto_load) {
         catch(auto_load = PLAYER_OB->create_auto_load(({ ob })));
      }
      if (!auto_load) {
         auto_load = AUTO_LOAD_OB->create_auto_load(({ ob }));
      }
   } else if (pointerp(ob)) {
      auto_load = ob;
   } else {
      printf("Error!  Dammit!\n");
   }
   if (!fixed_num) {
      do {
         tmp = do_read_file(CRAFT_SHOP_DATA_SAVE_FILE,
                        "app_" + _current_save_num);
         if (tmp) {
            _current_save_num++;
         }
      } while (tmp);
      fixed_num = _current_save_num;
   }
   do_save_file(CRAFT_SHOP_DATA_SAVE_FILE,
            auto_load,
            "app_" + fixed_num);
   return fixed_num;
}
protected object create_real_auto_load_object(int num, object player) {
   string auto_load;
   object *obs;
   auto_load = do_read_file(CRAFT_SHOP_DATA_SAVE_FILE,
                        "app_" + num);
   if (userp(player)) {
      obs = player->load_auto_load_to_array(auto_load, player);
   } else if (this_player()) {
      obs = this_player()->load_auto_load_to_array(auto_load, player);
   } else {
      obs = PLAYER_OB->load_auto_load_to_array(auto_load, player);
   }
   if (sizeof(obs)) {
      return obs[0];
   }
   return 0;
}
object create_checkout_object(class approval_obs approve,
                            int id,
                            object player) {
   object ob;
   int i;
   ob = create_real_auto_load_object(id, player);
   if (ob) {
      ob->add_effect("/std/effects/object/no_save");
      ob->add_property(PLAYER_CRAFT_SHOP_CHECK_PROP, ({ approve, id }));
      i = member_array(id, approve->saved);
      approve->checkout[i] = 1;
      event_save(this_object());
      _something_checkedout++;
   }
   return ob;
}
int destroy_checkout_object(object ob) {
   int id;
   int *ids;
   int i;
   class approval_obs approve;
   if (!ob) {
      return 0;
   }
   if (ob->move("/room/rubbish") != MOVE_OK) {
      return 0;
   }
   ids = ob->effects_matching("/std/effects/object/no_save"->query_classification());
   foreach (id in ids) {
      ob->delete_effect(id);
   }
   id = ob->query_property(PLAYER_CRAFT_SHOP_CHECK_PROP)[1];
   approve = ob->query_property(PLAYER_CRAFT_SHOP_CHECK_PROP)[0];
   i = member_array(id, approve->saved);
   approve->checkout[i] = 0;
   ob->remove_property(PLAYER_CRAFT_SHOP_CHECK_PROP);
   create_auto_load_file(ob, id);
   event_save(this_object());
   _something_checkedout--;
   if (_something_checkedout < 0) {
       _something_checkedout = 0;
   }
   return 1;
}
int is_checkout_object(object ob) {
   return ob->query_property(PLAYER_CRAFT_SHOP_CHECK_PROP);
}
object* add_to_approval_list(string seller, object* sellables, int value,
                          string name, string category, int approved) {
   class approval_obs stuff;
   object ob;
   object* obs;
   obs = ({ });
   foreach (stuff in query_approval_list(approved)) {
      if (lower_case(stuff->name) == lower_case(name) &&
          stuff->seller == seller &&
          stuff->value == value) {
         stuff->category = category;
         foreach (ob in sellables) {
            if (ob->move("/room/rubbish") == MOVE_OK) {
               stuff->saved += ({ create_auto_load_file(ob, 0) });
               stuff->checkout += ({ 0 });
               obs += ({ ob });
            }
         }
         if (sizeof(obs)) {
            event_save(this_object());
         }
         return obs;
      }
   }
   stuff = new(class approval_obs);
   stuff->seller = seller;
   stuff->value = value;
   stuff->name = name;
   stuff->category = category;
   stuff->saved = ({ });
   stuff->enter_time = time();
   foreach (ob in sellables) {
      if (ob->move("/room/rubbish") == MOVE_OK) {
         stuff->saved += ({ create_auto_load_file(ob, 0) });
         obs += ({ ob });
      }
   }
   stuff->checkout = allocate(sizeof(stuff->saved));
   if (sizeof(obs)) {
      if (approved) {
         _approved += ({ stuff });
      } else {
         _waiting_for_approval += ({ stuff });
      }
      event_save(this_object());
   }
   return obs;
}
void remove_from_approval_list(class approval_obs approve) {
   int i;
   int pos;
   for (i = 0; i < sizeof(_approved); i++) {
      if (_approved[i] == approve) {
         foreach (pos in approve->saved) {
            do_save_file(CRAFT_SHOP_REMOVE_DATA_SAVE_FILE,
                         0,
                         "app_" + pos);
         }
         _approved = _approved[0..i-1] + _approved[i+1..];
         event_save(this_object());
         return ;
      }
   }
   for (i = 0; i < sizeof(_waiting_for_approval); i++) {
      if (_waiting_for_approval[i] == approve) {
         foreach (pos in approve->saved) {
            do_save_file(CRAFT_SHOP_REMOVE_DATA_SAVE_FILE,
                         0,
                         "app_" + pos);
         }
         _waiting_for_approval = _waiting_for_approval[0..i-1] + _waiting_for_approval[i+1..];
         event_save(this_object());
         return ;
      }
   }
}
void add_transaction(string person, object* objects, int type, int amount,
                     string name_cat, mixed extra) {
#if USE_TRANSACTIONS
   class shop_transaction bing;
   string str;
   str = query_multiple_short(objects, 0, 1);
   bing = new(class shop_transaction);
   bing->time = time();
   bing->person = person;
   bing->objects = str;
   bing->type = type;
   bing->amount = amount;
   bing->name_cat = name_cat;
   bing->extra = extra;
   _transactions += ({ bing });
   event_save(this_object());
#endif
}
#if USE_TRANSACTIONS
string query_transaction_string(class shop_transaction trans) {
   string ret;
   string amt;
   string place;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   amt = MONEY_HAND->money_value_string(trans->amount, place);
   ret = ctime(trans->time)[4..<9] + ": " + trans->person;
   switch (trans->type) {
   case PLAYER_CRAFT_SHOP_SELL :
      ret += " sells " + trans->objects + " (" + trans->name_cat +
             ") for " + amt;
      break;
   case PLAYER_CRAFT_SHOP_SELL_AUTO :
      ret += " sells " + trans->objects + " (" + trans->name_cat +
             ") [accepted] for " + amt;
      break;
   case PLAYER_CRAFT_SHOP_APPROVE :
      ret += " approves " + trans->objects + " (" + trans->name_cat +
             ") sold by " + trans->extra + " for " + amt;
      break;
   case PLAYER_CRAFT_SHOP_BUY :
      ret += " buys " + trans->objects + " (" + trans->name_cat +
             ") sold by " + trans->extra + " for " + amt;
      break;
   }
   return ret;
}
#endif
protected void complete_sale(int value, string name, object *sellable,
                             string category) {
   string place;
   object *bought;
   mixed approve;
   int final_cost;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   _num_checked_so_far = ([ ]);
   approve = is_item_approved(this_player()->query_name(),
                        value, name, sellable, category, ref final_cost);
   if (approve == -1) {
      write("This item is denied sale here, it is not something the "
            "owner wishes to buy.\n");
      say(this_player()->query_cap_name() + " finished attempting to sell " +
                query_multiple_short(sellable) + " to " + the_short() + ".\n");
      return ;
   }
   if (approve == 1 || stringp(approve)) {
      if (stringp(approve)) {
         name = approve;
      }
   }
   write("Waiting for approval from the shop owner for the items " +
         query_multiple_short(sellable) + " with the name '" +
         name + "' selling for " +
         MONEY_HAND->money_value_string(value, place) +
         " in category " + category + ".\nIf the item is accepted the "
         "money will be paid into your royalty pool.\n");
   bought = add_to_approval_list(this_player()->query_cap_name(), sellable,
                        value, name, category, approve != 0);
   if (sizeof(bought)) {
      add_transaction(this_player()->query_name(),
                   bought,
                   PLAYER_CRAFT_SHOP_SELL,
                   value * sizeof(sellable),
                   name + " in " + category,
                   0);
      if (sizeof(bought) != sizeof(sellable)) {
         write("Unable to sell " + query_multiple_short(sellable - bought) +
                  " to " + the_short() + ".\n");
      }
      say(this_player()->the_short() + " completes selling something "
       "to the shop.\n");
   } else {
      write("Unable to sell " + query_multiple_short(sellable) + " to " +
            the_short() + ".\n");
   }
}
string query_letter_value(int pos) {
   return sprintf("%c%c", 'A' + (pos / 26), 'A' + (pos % 26));
}
int query_number_value(string letter) {
   if (!strlen(letter)) {
      return -1;
   }
   letter = lower_case(letter);
   if (strlen(letter) < 2) {
      if (letter[0] >= 'a' && letter[0] <= 'z') {
         return letter[0] - 'a';
      }
   }
   if (strlen(letter) > 2) {
      return -1;
   }
   if (letter[0] >= 'a' && letter[0] <= 'z') {
      if (letter[1] >= 'a' && letter[1] <= 'z') {
         return (letter[0] - 'a') * 26 + (letter[1] - 'a');
      }
   }
   return -1;
}
class approval_obs query_approval_class(string name) {
   int pos;
   if (name[0] == '-') {
      pos = query_number_value(name[1..]);
   } else {
      pos = query_number_value(name);
   }
   if (pos == -1) {
      add_failed_mess(name + " is not a valid number.\n");
      return 0;
   }
   if (name[0] == '-') {
      if (!sizeof(query_approval_list(0))) {
         add_failed_mess("There is nothing in the approval list currently.\n");
         return 0;
      }
      if (pos >= sizeof(query_approval_list(0))) {
         add_failed_mess("The " + name + " is out of range, must be between AA-" +
                         query_letter_value(sizeof(query_approval_list(0)) - 1) +
                         ".\n");
      }
      return query_approval_list(0)[pos];
   }
   if (pos >= sizeof(query_approval_list(1))) {
      add_failed_mess("The " + name + " is out of range, must be between AA-" +
                      query_letter_value(sizeof(query_approval_list(1)) - 1) +
                      ".\n");
      return 0;
   }
   return query_approval_list(1)[pos];
}
int ownership_change(string old_owner, string new_owner) {
   class parse_node* expr;
   if (old_owner == new_owner) {
      return 0;
   }
   _automatic_approval = new(class approval);
   _automatic_approval->items = ([ ]);
   _automatic_approval->expressions = ({ });
   _automatic_percentage = 10;
#if USE_TRANSACTIONS
   _transactions = ({ });
#endif
   _sell_stats = ([ ]);
   _stats_start = time();
   _sellers = ([ ]);
   _black_list = ({ });
   expr = parse_boolean_string("false");
   _buy_expression = expr;
   _use_expression = expr;
}
void inform_of_buy(int value, object *obs, object player, string *sellers,
                   string *names, string *cats, int *values) {
   string name_cat;
   int i;
   class shop_stats stat;
   _total_ingoing += value;
   adjust_royalty(query_owner(), value);
   for (i = 0; i < sizeof(obs); i++) {
      name_cat = names[i] + " in " + cats[i];
      add_transaction(this_player()->query_name(),
                      obs[i..i],
                      PLAYER_CRAFT_SHOP_BUY,
                      values[i],
                      name_cat,
                      sellers[i]);
      stat = _sell_stats[sellers[i] + " - " + name_cat];
      if (!stat) {
         stat = new(class shop_stats);
      }
      stat->num_sold++;
      stat->value_sold += values[i];
      _sell_stats[sellers[i] + " - " + name_cat] = stat;
   }
}
object* check_for_checkout(object ob) {
   object* obs = ({ });
   if (_something_checkedout) {
      if (living(ob)) {
         obs = filter(deep_inventory(ob), (: is_checkout_object($1) :));
      } else {
         if (is_checkout_object(ob)) {
            obs = ({ ob });
         }
      }
      if (sizeof(obs)) {
         foreach (ob in obs) {
            if (!destroy_checkout_object(ob)) {
               obs -= ({ ob });
            }
         }
      }
      return obs;
   }
   return ({ });
}
void event_exit(object ob, string message, object to) {
   object *obs;
   obs = check_for_checkout(ob);
   if (sizeof(obs)) {
      tell_object(ob, "You suddenly find the uncheckout items " +
                      query_multiple_short(obs) + " check themselves "
                      "back in.\n");
      obs->move("/room/rubbish");
   }
}
void event_dest_me(object ob) {
   check_for_checkout(ob);
   if (_sign_ob) {
      _sign_ob->dest_me();
   }
}
void return_all_checkedout_objects() {
   object ob;
   object* obs;
   if (_something_checkedout) {
      obs = filter(deep_inventory(this_object()), (: is_checkout_object($1) :));
      if (sizeof(obs)) {
         foreach (ob in obs) {
            destroy_checkout_object(ob);
         }
      }
      tell_room(this_object(), query_multiple_short(obs) +
                " mysteriously check themselves back in.\n");
   }
}
void dest_me() {
   ::dest_me();
}
int is_able_to_change(object ob) {
   return is_allowed(this_player()->query_name());
}
int query_owners_money() {
   return query_royalty(query_owner());
}
void adjust_owners_money(int amt) {
   adjust_royalty(query_owner(), amt);
}
object query_sign_object() {
   object* obs;
   if (!_sign_ob && _auto_load_sign_str && !_broken_sign) {
      if (catch(obs = PLAYER_OB->load_auto_load_to_array(_auto_load_sign_str))) {
         _broken_sign = 1;
      } else {
         if (sizeof(obs)) {
            _sign_ob = obs[0];
            _sign_ob->reset_get();
         } else {
            _broken_sign = 1;
         }
      }
   }
   return _sign_ob;
}
void set_sign_object(object ob) {
   if (ob) {
      _auto_load_sign_str = PLAYER_OB->create_auto_load(({ ob }));
      ob->reset_get();
   } else {
      _auto_load_sign_str = 0;
   }
   _sign_ob = ob;
   event_save(this_object());
}
int do_buy(object *obs) {
   int status;
   if (!evaluate_expression(_buy_expression, this_player()->query_name(), 0, ({ }), 0, 0)->value &&
       !is_allowed_to_use_shop(this_player()->query_name())) {
      add_failed_mess("You cannot buy anything at this shop.\n");
      return 0;
   }
   status = ::do_buy(obs);
   if (!status)  return 0;
   return 1;
}
int do_check_sell(object *obs) {
   int *stuff;
   object ob;
   string ret;
   string place;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   ret = "";
   foreach (ob in obs) {
      stuff = query_maximum_sale_value_both(this_player()->query_name(), ob);
      ret += "$I$5=$C$" + the_short() + ": ";
      if (stuff[0]) {
         ret += "will be queued for more than " +
                MONEY_HAND->money_value_string(stuff[0], place);
      }
      if (stuff[0] && stuff[1]) {
         ret += " and ";
      }
      if (stuff[1]) {
         ret += "will be denied for more than " +
                MONEY_HAND->money_value_string(stuff[1], place);
      }
      ret += ".\n";
   }
   write("$P$Check Sell$P$" + ret);
   add_succeeded_mess(({ "", "$N checks the sale of $I.\n" }), obs);
   return 1;
}
int do_list_approval(int approved) {
   class approval_obs approve;
   int pos;
   int shown;
   int allowed;
   int checkout;
   int i;
   int fluff;
   string place;
   string ret;
   object* obs;
   object *current;
   object* result;
   string *possible_names;
   string start;
   mapping result_type;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   allowed = is_allowed(this_player()->query_name());
   if (!allowed) {
      approved = 1;
   }
   if (!approved) {
      start = "-";
   } else {
      start = "";
   }
   result_type = ([ ]);
   ret = "";
   current = query_controller()->create_all_real_objects(this_player(),
                 query_controller()->query_sell_list_obs());
   while (allowed || approved) {
      if (approved == 2) {
         approved = 0;
         start = "-";
      }
      foreach (approve in query_approval_list(approved)) {
         if (lower_case(approve->seller) == this_player()->query_name() ||
             allowed) {
            checkout = sizeof(filter(approve->checkout, (: $1 :)));
            obs = ({ });
            for (i = 0; i < sizeof(approve->saved); i++) {
               fluff = approve->saved[i];
               obs += ({ create_real_auto_load_object(fluff, this_player()) });
            }
            obs -= ({ 0 });
            possible_names = obs->query_short();
            obs->move("/room/rubbish");
            if (!result_type[lower_case(approve->name)]) {
               result = filter(current,
                        (: member_array($1->query_short(),
                                        $(possible_names)) > -1 :));
               result_type[lower_case(approve->name)] = sizeof(result);
            }
            ret += start + query_letter_value(pos) + ") " +
                  approve->seller + "'s " + approve->name + " for " +
                  MONEY_HAND->money_value_string(approve->value, place) +
                  " in " + approve->category + ", " +
                  sizeof(approve->saved) + " objects (" +
                  query_multiple_short(obs) + ") " +
                  result_type[lower_case(approve->name)] + " in stock";
            if (checkout) {
               ret += " and " + checkout + " checked out.\n";
            } else {
               ret += ".\n";
            }
            shown++;
         }
         pos++;
      }
      if (!allowed && approved) {
         approved = 2;
         pos = 0;
      } else {
         break;
      }
   }
   if (sizeof(current)) {
      current->dest_me();
   }
   if (!shown) {
      add_failed_mess("No items to approve at the moment.\n");
      return 0;
   }
   write("$P$Approval list$P$The current approval items are:\n" + ret);
   return 1;
}
int do_return(string name) {
   object *obs;
   object *ok;
   object *here;
   object *fail;
   object *checkout;
   object money;
   class approval_obs approve;
   object ob;
   int pos;
   int i;
   int value;
   string place;
   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }
   if (lower_case(approve->seller) != this_player()->query_name()) {
      add_failed_mess("You must be the one that sold the item to return "
                      "it.\n");
      return 0;
   }
   obs = ({ });
   checkout = ({ });
   if (sizeof(filter(approve->checkout, (: $1 :))) > 0 &&
       _something_checkedout) {
      return_all_checkedout_objects();
   }
   for (i = 0; i < sizeof(approve->saved); i++) {
      pos = approve->saved[i];
      if (!approve->checkout[i]) {
         obs += ({ create_real_auto_load_object(pos, this_player()) });
      } else {
         checkout += ({ create_real_auto_load_object(pos, this_player()) });
      }
   }
   obs -= ({ 0 });
   checkout -= ({ 0 });
   if (sizeof(checkout)) {
      place = query_property("place");
      if (!place) {
         place = "default";
      }
      write("The items " + query_multiple_short(checkout) +
            " are currently checked out.  You are reimbused the amount "
            "they would have cost to sell.\n");
      value = approve->value * sizeof(checkout);
      money = MONEY_HAND->make_new_amount( value, place);
      money->move(this_player());
      _total_outgoing += approve->value * sizeof(checkout);
   }
   ok = ({ });
   here = ({ });
   fail = ({ });
   foreach (ob in obs) {
      if (ob->move(this_player()) == MOVE_OK) {
         ok += ({ ob });
      } else if (ob->move(this_object())) {
         here += ({ ob });
      } else {
         fail += ({ ob });
      }
   }
   remove_from_approval_list(approve);
   if (sizeof(ok)) {
      add_succeeded_mess("$N $V $I.\n", map(ok, (: $1->poss_short() :)));
   }
   if (sizeof(here)) {
      add_succeeded_mess("$N $V their $I and they get put on the floor.\n",
                         map(ok, (: $1->poss_short() :)));
   }
   if (sizeof(fail)) {
      add_succeeded_mess( ({ "You find that $I do not want to be moved.\n",
                             "" }), fail);
   }
   return 1;
}
int do_approve_item(string name, string money_str) {
   int cost;
   object *obs;
   class approval_obs approve;
   string place;
   int final_cost;
   int num;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to approve items.\n");
      return 0;
   }
   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   num = sizeof(query_controller()->query_sell_list_obs());
   if (num + sizeof(approve->saved) > query_maximum_inventory_size()) {
      add_failed_mess("You cannot approve anything, the shop is already "
                      "at the maximum number allowed.\n");
      return 0;
   }
   cost = approve->value * sizeof(obs);
   if (this_player()->query_value_in(place) < cost) {
      add_failed_mess("You need at least " +
                      MONEY_HAND->money_value_string(cost, place) +
                      " to put this into the shop.\n");
      return 0;
   }
   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess("The amount " + money_str + " is not a valid "
                         "money cost.\n");
         return 0;
      }
   }
   if (sizeof(filter(approve->checkout, (: $1 :))) > 0 &&
       _something_checkedout) {
      write("One of these objects is still checkedout, do you wish to "
            "continue this without these items? ");
      input_to("confirm_approval", 0, approve, final_cost);
      add_succeeded_mess( ({ "", "$N approves something in the shop.\n" }) );
      return 1;
   }
   confirm_approval("y", approve, final_cost);
   return 1;
}
protected void confirm_approval(string answer,
                                class approval_obs approve,
                                int final_cost) {
   int pos;
   int i;
   int bing;
   int cost;
   object *obs;
   object *bought;
   object *checkout;
   string place;
   if (strlen(answer) < 1 || lower_case(answer)[0] != 'y') {
      write("Ok, canceled the approval of the item.\n");
      return ;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   obs = ({ });
   checkout = ({ });
   for (i = 0; i < sizeof(approve->saved); i++) {
      pos = approve->saved[i];
      if (!approve->checkout[i]) {
         obs += ({ create_real_auto_load_object(pos, this_player()) });
      } else {
         checkout += ({ create_real_auto_load_object(pos, this_player()) });
      }
   }
   obs -= ({ 0 });
   checkout -= ({ 0 });
   if (sizeof(checkout)) {
      write("The items " + query_multiple_short(checkout) + " were "
            "checked out and therefore lost.\n");
   }
   if (!final_cost) {
      final_cost = ((approve->value * (100 + _automatic_percentage)) / 100);
   }
   final_cost -= final_cost % _round_value;
   bought = query_controller()->buy_objects(obs, approve->name,
                                   final_cost,
                                   approve->seller, approve->category, 1);
   if (sizeof(bought)) {
      cost = approve->value * (sizeof(obs) + sizeof(checkout));
      cost -= cost % _round_value;
      _total_outgoing += cost;
      remove_from_approval_list(approve);
      adjust_royalty(lower_case(approve->seller), cost);
      if (query_owners_money() > 0) {
         if (query_owners_money() > cost) {
            adjust_owners_money(-cost);
            cost = 0;
         } else {
            cost -= query_owners_money();
            adjust_owners_money(-query_owners_money());
         }
      }
      if (cost > 0) {
         if (this_player()->query_value_in(place) > 0) {
            bing = this_player()->query_value_in(place);
            if (bing > cost) {
               bing = cost;
               cost = 0;
            } else {
               cost -= bing;
            }
            if (bing) {
               this_player()->pay_money(MONEY_HAND->create_money_array(bing, place), place);
            }
         }
         if (cost > 0) {
            adjust_owners_money(-cost);
         }
      }
      write("You approve " + query_multiple_short(obs) + " to be sold as " +
            approve->name + " in " + approve->category + " for " +
            MONEY_HAND->money_value_string(approve->value, place) + ".\n");
      add_succeeded_mess( ({ "", "$N approves something in the shop.\n" }) );
      add_transaction(this_player()->query_name(),
                      obs,
                      PLAYER_CRAFT_SHOP_APPROVE,
                      approve->value * (sizeof(obs) + sizeof(checkout)),
                      approve->name + " in " + approve->category,
                      approve->seller);
   } else {
      write("Unable to move the items into the shops inventory.  "
            "Contact a creator or error report this please.\n");
   }
   return ;
}
int do_approve_reject(string name, string mess, int reject_pos) {
   object *obs;
   object *ok;
   object *here;
   object *checkout;
   object ob;
   object play;
   class approval_obs approve;
   int pos;
   int i;
   int ret;
   string ob_mess;
   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }
   if (lower_case(approve->seller) == this_player()->query_name()) {
      return do_return(name);
   }
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You're not allowed to reject items.\n");
      return 0;
   }
   if (sizeof(filter(approve->checkout, (: $1 :))) > 0 &&
       _something_checkedout) {
      return_all_checkedout_objects();
   }
   if (reject_pos != -1 &&
       (reject_pos <= 0 ||
       reject_pos > sizeof(approve->saved))) {
      add_failed_mess("You cannot reject the item of position " + reject_pos +
                      " since there are only " + sizeof(approve->saved) +
                      " items.\n");
      return 0;
   }
   if (reject_pos != -1) {
      reject_pos--;
   }
   obs = ({ });
   checkout = ({ });
   for (i = 0; i < sizeof(approve->saved); i++) {
      if (reject_pos == -1 ||
          reject_pos == i) {
         pos = approve->saved[i];
         if (!approve->checkout[i]) {
            obs += ({ create_real_auto_load_object(pos, this_player()) });
         } else {
            checkout += ({ create_real_auto_load_object(pos, this_player()) });
         }
      }
   }
   obs -= ({ 0 });
   checkout -= ({ 0 });
   if (member_array(0, obs) != -1) {
      add_failed_mess("There seems to be a problem with this rejection set, "
                      "one of the items is 0.\n");
      return 0;
   }
   if (reject_pos != -1 && sizeof(checkout)) {
      add_failed_mess("The item $I has been checked out, you cannot reject "
                      "it.\n", checkout);
      return 0;
   }
   if (sizeof(checkout)) {
      write("The items " + query_multiple_short(checkout) + " were "
            "checked out and lost.\n");
      adjust_royalty(lower_case(approve->seller),
                                approve->value * sizeof(checkout));
      AUTO_MAILER->auto_mail(lower_case(approve->seller),
                            this_player()->query_name(),
                            "Rejected items", "",
                            sprintf("%-=75s",
                                   this_player()->query_name() + " lost your " +
                                   query_multiple_short(checkout, "the", 1) +
                                   ",so you have been paid but the items "
                                   "were not returned.\n"));
   }
   if (!sizeof(obs)) {
      write("Nothing to give back or send off.\n");
   } else {
      play = find_player(lower_case(approve->seller));
      if (play  &&  environment(play) == this_object()) {
         ok = ({ });
         here = ({ });
         foreach (ob in obs) {
            if (ob) {
               if (ob->move(play) == MOVE_OK) {
                  ok += ({ ob });
               } else if (ob->move(this_object()) == MOVE_OK) {
                  here += ({ ob });
               }
            }
         }
         if (sizeof(ok)) {
            tell_object(play, "Your items: " +
                        query_multiple_short(obs) + " have been rejected "
                        "and placed in your inventory.\n");
         }
         if (sizeof(here)) {
            tell_object(play, "Your items: " +
                        query_multiple_short(obs) + " have been rejected "
                        "and placed on the floor here.\n");
         }
         write("You reject the item.\n");
      } else {
         if (!_parcel_post) {
            add_failed_mess("Eeek!  No parcel post defined on this room.\n");
            return 0;
         }
         ob_mess = "The shop " + this_player()->convert_message(the_short()) +
                   " rejected " + query_multiple_short(obs, "the", 1) +
                   " because:\n";
         ret = _parcel_post->deposit_parcel(obs, lower_case(approve->seller), 1);
         if (ret != 1) {
            if (ret == -5) {
               write("The player " + approve->seller + " has been denied use "
                     "of the parcel post system, tossing objects away.\n");
               obs->move("/room/rubbish");
               if (mess) {
                  write("Still sending the message to the person.\n");
                  mess += "\nYou were denied use of the parcel post system "
                          "so your objects were thrown away.\n";
               }
            } else if (ret == -4) {
               write("You have been denied use of the postal system, perhaps "
                     "you could try clearing this up with the creators?\n");
               obs->move("/room/rubbish");
               return 1;
            } else if (ret == -2) {
               write("The player " + approve->seller + " no longer exists, "
                     "tossing objects away.\n");
               obs->move("/room/rubbish");
            } else {
               add_failed_mess("Unable to send the parcel for some reason (" +
                            ret + ").\n");
                  obs->move("/room/rubbish");
               return 0;
            }
         }
         if (ret != -2) {
            if (mess) {
               AUTO_MAILER->auto_mail(approve->seller, this_player()->query_name(),
                               "Rejected items", "",
                               ob_mess + mess);
            } else {
               write("You reject the item and it is parcel posted back to the "
                  "person who "
                  "sent it.\nWould you like to send them a note about it as well? ");
               obs -= ({ 0 });
               input_to("check_reject_note", 0, ob_mess,
                        approve->seller);
            }
         }
      }
   }
   if (reject_pos != -1) {
      approve->saved = approve->saved[0..reject_pos-1] + approve->saved[reject_pos+1..];
      event_save(this_object());
      if (!sizeof(approve->saved)) {
         reject_pos = -1;
      }
   }
   if (reject_pos == -1) {
      remove_from_approval_list(approve);
   }
   add_succeeded_mess(({ "", "$N reject$s a sellable object.\n" }));
   return 1;
}
void check_reject_note(string str, string ob_str, string name) {
   str = lower_case(str);
   if (!strlen(str) ||
       (str[0] != 'y' &&
        str[0] != 'n')) {
      write("Please answer yes or no.\nWould you like to send them "
            "a note about it as well?");
      input_to("check_reject_note", 0, ob_str, name);
      return ;
   }
   if (str[0] == 'n') {
      write("ok, bye then!\n");
      return ;
   }
   this_player()->do_edit("Your items " + ob_str + " were rejected "
                         "from " + the_short() + ".\n\n",
                         "send_reject_note", this_object(), 0, name);
}
void send_reject_note(string mess, string name) {
   if (!mess) {
      write("Aborted.\n");
      return ;
   }
   AUTO_MAILER->auto_mail(name, this_player()->query_name(),
                            "Rejected items", "", mess);
}
int do_approve_browse(string name) {
   object *obs;
   object ob;
   string read;
   string ret;
   class approval_obs approve;
   int pos;
   string place;
   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }
   if (lower_case(approve->seller) == this_player()->query_name()) {
      return do_return(name);
   }
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to reject items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   obs = ({ });
   foreach (pos in approve->saved) {
      obs += ({ create_real_auto_load_object(pos, this_player()) });
   }
   obs -= ({ 0 });
   ret = "";
   foreach (ob in obs) {
      ret += ob->the_short() + ": (Base cost " +
             MONEY_HAND->money_value_string(ob->query_base_value(), place) +
             "; scaled cost " +
             MONEY_HAND->money_value_string(ob->query_value(), place) +
             ")\n" + ob->long();
      read = ob->query_readable_message();
      if (read) {
         ret += "You read " +
                 replace_string(ob->query_read_short(this_player()), "$name$",
                         ob->a_short()) + ":\n" +
                 ob->query_readable_message();
      }
   }
   obs->move("/room/rubbish");
   write("$P$Browse list$P$" + ret);
   add_succeeded_mess("$N browse$s an item waiting for approval.\n");
   return 1;
}
int do_approve_checkout(string name) {
   object *obs;
   object *bad;
   object *checkout;
   object ob;
   class approval_obs approve;
   int pos;
   int i;
   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }
   if (lower_case(approve->seller) == this_player()->query_name()) {
      return do_return(name);
   }
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to reject items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   obs = ({ });
   checkout = ({ });
   for (i = 0; i < sizeof(approve->saved); i++) {
      pos = approve->saved[i];
      if (!approve->checkout[i]) {
         ob = create_checkout_object(approve, pos, this_player());
         if (!ob) {
            write("Unable to create " + pos + approve->name + ", weird...\n");
         } else {
            obs += ({ ob });
         }
      } else {
         checkout += ({ create_checkout_object(approve, pos, this_player()) });
      }
   }
   checkout->move("/room/rubbish");
   if (!sizeof(obs) &&
       sizeof(checkout)) {
      if (sizeof(checkout) > 0) {
         add_failed_mess("$I are already checked out.\n", checkout);
      } else {
         add_failed_mess("$I is already checked out.\n", checkout);
      }
      return 0;
   }
   bad = ({ });
   foreach (ob in obs) {
      if (ob->move(this_player()) != MOVE_OK) {
         bad += ({ ob });
         destroy_checkout_object(ob);
      }
   }
   if (sizeof(bad)) {
      write("Unable to move " + query_multiple_short(bad) + " into your "
            "inventory for you to check.\n");
   }
   obs -= bad;
   if (sizeof(obs)) {
      write("Moved " + query_multiple_short(obs) + " into your inventory "
            "for you to check.\n");
      add_succeeded_mess("$N check$s out $I.\n", obs);
   }
   return 1;
}
int do_approve_checkin(object* obs) {
   object ob;
   object* ok;
   ok = ({ });
   foreach (ob in obs) {
      if (is_checkout_object(ob)) {
         destroy_checkout_object(ob);
         ok += ({ ob });
      }
   }
   if (!sizeof(ok)) {
      add_failed_mess("None of $I have been checked out.\n", obs);
      return 0;
   }
   add_succeeded_mess("$N check$s $I back in.\n", ok);
   return 1;
}
int do_approve_name_change(string name, string new_name) {
   class approval_obs approve;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to approve items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   approve = query_approval_class(name);
   if (!approve)  return 0;
   write("You change the name of the item waiting to be approved from " +
         approve->name + " to " + new_name + ".\n");
   approve->name = new_name;
   add_succeeded_mess( ({ "", "$N messes with the approval items.\n" }));
   event_save(this_object());
   return 1;
}
int do_approve_category_change(string name, string new_category) {
   class approval_obs approve;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to approve items.\n");
      return 0;
   }
   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   new_category = query_real_category_name(new_category);
   if (!new_category ||
       !query_controller()->is_valid_category(new_category)) {
      add_failed_mess("You must choose a category that exists.\n");
      return 0;
   }
   approve->category = new_category;
   add_succeeded_mess(({
      "You change the category of the approval item " + name + ".\n",
      "$N messes with the approval items.\n" }));
   event_save(this_object());
   return 1;
}
int do_approve_auto_low(string cost) {
   string place;
   int value;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   value = value_from_string(cost, place);
   _automatic_approval->low_cost = value;
   event_save(this_object());
   if (!value) {
      add_succeeded_mess(({ "You disable the automatic acception of items of "
                            "low value.\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "costing less than " +
                         MONEY_HAND->money_value_string(value, place) + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_high(string cost) {
   string place;
   int value;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   value = value_from_string(cost, place);
   if (!value) {
      _automatic_approval->high_cost = value;
      add_succeeded_mess(({ "You disable the automatic placing items into the "
                            "approve list of items of high value.\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   _automatic_approval->high_cost = value;
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically put any item "
                         "costing more than " +
                         MONEY_HAND->money_value_string(value, place) +
                         " into the approve list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_high_deny(string cost) {
   string place;
   int value;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   value = value_from_string(cost, place);
   if (!value) {
      _automatic_approval->high_cost_deny = 0;
      add_succeeded_mess(({ "You disable the automatic denying of items of "
                            "high value.\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   _automatic_approval->high_cost_deny = value;
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically deny any item "
                         "costing more than " +
                         MONEY_HAND->money_value_string(value, place) + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_item_add(string item, string money, string list_name,
                             int markup, string money_str) {
   int value;
   string place;
   int final_cost;
   mixed app_item;
   class approval_item new_app_item;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   value = value_from_string(money, place);
   if (!value) {
      add_failed_mess("The value " + money + " is invalid.\n");
      return 0;
   }
   if (markup < 0) {
      markup = 0;
   }
   item = strip_quotes(item);
   list_name = strip_quotes(list_name);
   if (classp(_automatic_approval->items[item])) {
      app_item = ((class approval_item)_automatic_approval->items[item])->value;
   } else {
      app_item = _automatic_approval->items[item];
   }
   if (app_item == value) {
      add_failed_mess("The item " + item + " already has a cut off "
                      "value of " +
                      MONEY_HAND->money_value_string(value, place) + ".\n");
      return 0;
   }
   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }
   new_app_item = new(class approval_item);
   new_app_item->list_name = list_name;
   new_app_item->value = value;
   new_app_item->markup = markup;
   new_app_item->final_cost = final_cost;
   _automatic_approval->items[item] = new_app_item;
   place = query_property("place");
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "with a short of " + item + " up to a cost "
                         "of " + MONEY_HAND->money_value_string(value, place) +
                         (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_item_add_object(object *obs, string money,
                                    string list_name, int markup,
                                    string money_str) {
   int value;
   string place;
   object ob;
   string name;
   object *ok;
   object *bad;
   mixed item;
   class approval_item new_item;
   int final_cost;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   value = value_from_string(money, place);
   if (!value) {
      add_failed_mess("The value " + money + " is invalid.\n");
      return 0;
   }
   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }
   if (markup < 0) {
      markup = 0;
   }
   bad = ({ });
   ok = ({ });
   list_name = strip_quotes(list_name);
   foreach (ob in obs) {
      name = ob->query_short();
      if (classp(_automatic_approval->items[name])) {
         item = ((class approval_item)_automatic_approval->items[name])->value;
      } else {
         item = _automatic_approval->items[name];
      }
      if (item == value) {
         bad += ({ name });
      } else {
         new_item = new(class approval_item);
         new_item->value = value;
         new_item->list_name = list_name;
         new_item->markup = markup;
         new_item->final_cost = final_cost;
         _automatic_approval->items[name] = new_item;
         ok += ({ name });
      }
   }
   event_save(this_object());
   if (sizeof(ok)) {
      add_succeeded_mess(({ "You set the shop to automatically accept any of "
                         "$I up to a cost "
                         "of " + MONEY_HAND->money_value_string(value, place) +
                         (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }), ok );
      return 1;
   } else {
      add_failed_mess("You cannot set $I to a value limit of " +
                      MONEY_HAND->money_value_string(value, place) +
                      " since it already has this limit.\n");
      return 0;
   }
}
int do_approve_auto_item_add_expr(string item, string expr,
                                  string list_name, int markup,
                                  string money_str) {
   class approval_item new_app_item;
   class parse_node* value;
   string place;
   int final_cost;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   value = parse_money_string(expr);
   if (!sizeof(value)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   }
   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }
   if (markup < 0) {
      markup = 0;
   }
   item = strip_quotes(item);
   list_name = strip_quotes(list_name);
   new_app_item = new(class approval_item);
   new_app_item->list_name = list_name;
   new_app_item->value = value;
   new_app_item->markup = markup;
   new_app_item->final_cost = final_cost;
   _automatic_approval->items[item] = new_app_item;
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "with a short of " + item + " with an expression "
                         "of " + query_expression_string(value, 1) +
                         (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_item_add_object_expr(object *obs, string expr,
                          string list_name, int markup, string money_str) {
   class parse_node* value;
   object ob;
   string name;
   class approval_item new_item;
   int final_cost;
   string place;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   value = parse_money_string(expr);
   if (!sizeof(value)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   }
   if (money_str) {
      place = query_property("place");
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }
   if (markup < 0) {
      markup = 0;
   }
   list_name = strip_quotes(list_name);
   foreach (ob in obs) {
      name = ob->query_short();
      new_item = new(class approval_item);
      new_item->value = value;
      new_item->list_name = list_name;
      new_item->markup = markup;
      new_item->final_cost = final_cost;
      _automatic_approval->items[name] = new_item;
   }
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically accept any of "
                      "$I with an expression "
                      "of " + query_expression_string(value, 1) +
                      (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                       "$N fiddle$s with something in the shop.\n" }), obs );
   return 1;
}
int do_approve_auto_item_test(object* obs) {
   object ob;
   string place;
   mixed cost;
   int found;
   int allowed;
   class expression_type stuff;
   class parse_node frog;
   allowed = is_allowed(this_player()->query_name());
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   foreach (ob in obs) {
      found = 0;
      cost = _automatic_approval->items[ob->query_short()];
      if (classp(cost)) {
         cost = ((class approval_item)cost)->value;
      }
      if (cost) {
         if (pointerp(cost)) {
            frog = evaluate_expression(cost, this_player()->query_name(),
                                        0, ({ ob }), 0, 0);
            if (allowed) {
               write("$I$5=The item " + ob->the_short() + " can be sold if it "
                 "costs less than " +
                  query_expression_string(cost, 1) +
                  ";\n" + ob->query_short() + " - " +
                  MONEY_HAND->money_value_string(frog->value, place) +
                  ".\n");
            } else {
               write("$I$5=The item " + ob->the_short() + " can be sold if it "
                 "costs less than " +
                  " " + MONEY_HAND->money_value_string(frog->value, place) +
                  ".\n");
            }
         } else {
            write("$I$5=The item " + ob->the_short() + " can be sold if it "
              "costs less than " +
               MONEY_HAND->money_value_string(cost, place) +
               " (" + ob->query_short() + ").\n");
         }
         found |= 1;
      }
      foreach (stuff in _automatic_approval->expressions) {
         frog = evaluate_expression(stuff->condition,
                                    this_player()->query_name(),
                                    0, ({ ob }), 0, 0);
         if (frog->value) {
            if (stuff->type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
               frog = evaluate_expression(stuff->value,
                                      this_player()->query_name(),
                                      0, ({ ob }), 0, 0);
               if (allowed) {
                  write("$I$5=The item " + ob->the_short() +
                        " can be sold if it "
                        "costs less than " +
                        query_expression_string(stuff->value, 1) +
                        ";\n" + ob->query_short() + " - " +
                        MONEY_HAND->money_value_string(frog->value, place) +
                        ".\n");
               } else {
                  write("$I$5=The item " + ob->the_short() +
                        " can be sold if it "
                        "costs less than " +
                        MONEY_HAND->money_value_string(frog->value, place) +
                        ".\n");
               }
               found |= 2;
            }
            else found |= 4;
         }
      }
      if (found & 4)  {
         write("$I$5=The item " + ob->the_short() + " will be denied sale.\n");
      }
      else if (!found) {
         write("$I$5=The item " + ob->the_short() + " will not be "
               "automatically accepted.\n");
      }
   }
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_item_remove(string item) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   item = strip_quotes(item);
   if (!_automatic_approval->items[item]) {
      add_failed_mess("The item " + item + " is not in the list.\n");
      return 0;
   }
   map_delete(_automatic_approval->items, item);
   event_save(this_object());
   add_succeeded_mess(({ "You remove the item " + item +
                         " from the list of automatically accepted items.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_item_remove_object(object *obs) {
   object ob;
   object *bad;
   object *ok;
   string name;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   ok = ({ });
   bad = ({ });
   foreach (ob in obs) {
      name = ob->query_short();
      if (!_automatic_approval->items[name]) {
         bad += ({ ob });
      } else {
         ok += ({ ob });
         map_delete(_automatic_approval->items, name);
      }
   }
   event_save(this_object());
   if (sizeof(ok)) {
      add_succeeded_mess(({ "You remove $I from the list of "
                            "automatically accepted items.\n",
                         "$N fiddle$s with something in the shop.\n" }), ok );
      return 1;
   }
   add_failed_mess("None of $I are in the shops allow item list for you "
                   "to remove.\n", bad);
   return 0;
}
int do_approve_auto_expression_add(string expression, string value_str,
                                   int type, string list_name) {
   class parse_node* expr;
   class parse_node* value;
   class expression_type bing;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   expr = parse_boolean_string(expression);
   if (!sizeof(expr)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   }
   if (type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
      value = parse_money_string(value_str);
      if (!sizeof(value)) {
         add_failed_mess(query_last_expression_error() + ".\n");
         return 0;
      }
   }
   list_name = strip_quotes(list_name);
   bing = new(class expression_type);
   bing->type = type;
   bing->condition = expr;
   bing->value = value;
   bing->list_name = list_name;
   _automatic_approval->expressions += ({ bing });
   event_save(this_object());
   if (type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
      add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "matching the expression " +
                         query_expression_string(expr, 0) + " with a cost "
                         "of " + query_expression_string(value, 0) +
                         " as '" + list_name + "'.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   } else {
      add_succeeded_mess(({ "You set the shop to automatically deny any item "
                         "matching the expression " +
                         query_expression_string(expr, 0) + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   }
   return 1;
}
int do_approve_auto_expression_remove(string idstr) {
   class expression_type expr;
   int id;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   id = query_number_value(idstr);
   if (id == -1 || id >= sizeof(_automatic_approval->expressions)) {
      add_failed_mess("The id " + idstr + " is invalid.\n");
      return 0;
   }
   expr = _automatic_approval->expressions[id];
   _automatic_approval->expressions = _automatic_approval->expressions[0..id - 1] +
                                      _automatic_approval->expressions[id + 1..];
   event_save(this_object());
   add_succeeded_mess(({ "You remove the expression " +
                         query_expression_string(expr->condition, 1) +
                         " cost: " +
                         query_expression_string(expr->value, 1) +
                         " from the list of allowed expressions.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_percentage(mixed num) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   if (num <= 0) {
      add_failed_mess("The percentage to add must be greator than 0.\n");
      return 0;
   }
   _automatic_percentage = num;
   add_succeeded_mess(({ "You set the percentage to add to the sale price "
                         "to " + _automatic_percentage + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_limit(string limit) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }
   if (limit == "disable")  {
      _automatic_approval->num_allowed = 0;
      add_succeeded_mess(({ "You disable the default number of sold items "
                         "per person.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   else if (to_int(limit) > 0)  {
      _automatic_approval->num_allowed = to_int(limit);
      add_succeeded_mess(({ "You set the default number of sold items per "
                            "person to " + _automatic_approval->num_allowed + ".\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   return 0;
}
int do_approve_limit_person_items(string name, string value) {
   int amt;
   class seller_information info;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }
   name = lower_case(name);
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("The person " + name + " does not exist.\n");
      return 0;
   }
   amt = to_int(value);
   info = _sellers[name];
   if (!info) {
      info = new(class seller_information);
   }
   info->max_sellable = amt;
   if (info->value_limit || info->max_sellable || info->deny_value_limit) {
      _sellers[name] = info;
   } else {
      map_delete(_sellers, name);
   }
   if (amt)
      add_succeeded_mess(({ "You set the maximum number of items sellable by " +
                            name + " to " + info->max_sellable + ".\n",
                            "$N fiddle$s with something in the shop.\n" }) );
   else
      add_succeeded_mess(({ "You remove the limit for the maximum number of "
         "items sellable by " + name + ".\n",
         "$N fiddle$s with something in the shop.\n" }));
   return 1;
}
int do_approve_limit_person_value(string name, string money) {
   class seller_information info;
   int value;
   string place;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }
   name = lower_case(name);
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("The person " + name + " does not exist.\n");
      return -1;
   }
   money = lower_case(money);
   if (money == "disable" || money == "0") {
      value = 0;
   } else {
      place = query_property("place");
      if (!place) {
         place = "default";
      }
      value = value_from_string(money, place);
      if (!value) {
         add_failed_mess("The value " + value + " is invalid, please use "
                         "'disable' to disable this feature for the person.\n");
         return 0;
      }
   }
   info = _sellers[name];
   if (!info) {
      info = new(class seller_information);
   }
   info->value_limit = value;
   if (info->value_limit || info->max_sellable || info->deny_value_limit) {
      _sellers[name] = info;
   } else {
      map_delete(_sellers, name);
   }
   if (value) {
      add_succeeded_mess(({ "You set the maximum cost of items automatically "
                            "approved by " +
                         name + " to " +
                         MONEY_HAND->money_value_string(info->value_limit, place) +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   } else {
      add_succeeded_mess(({ "You disable the maximum cost of items "
                         "automatically approved by " +
                         name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   }
   return 1;
}
int do_approve_limit_person_value_deny(string name, string money) {
   class seller_information info;
   int value;
   string place;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }
   name = lower_case(name);
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("The person " + name + " does not exist.\n");
      return -1;
   }
   money = lower_case(money);
   if (money == "disable" || money == "0") {
      value = 0;
   } else {
      place = query_property("place");
      if (!place) {
         place = "default";
      }
      value = value_from_string(money, place);
      if (!value) {
         add_failed_mess("The value " + value + " is invalid, please use "
                         "'disable' to disable this feature for the person.\n");
         return 0;
      }
   }
   info = _sellers[name];
   if (!info) {
      info = new(class seller_information);
   }
   info->deny_value_limit = value;
   if (info->deny_value_limit || info->max_sellable || info->value_limit) {
      _sellers[name] = info;
   } else {
      map_delete(_sellers, name);
   }
   if (value) {
      add_succeeded_mess(({ "You set the maximum cost of items accepted by " +
                         name + " to " +
                         MONEY_HAND->money_value_string(info->deny_value_limit, place) +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   } else {
      add_succeeded_mess(({ "You disable the maximum cost of items to be sold by " +
                         name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   }
   return 1;
}
int do_approve_limit_person_remove(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove limits "
                      "off someone.\n");
      return 0;
   }
   name = lower_case(name);
   if (!_sellers[name]) {
      add_failed_mess("The person " + name + " does not have any limits placed "
                      "on them.\n");
      return 0;
   }
   map_delete(_sellers, name);
   event_save(this_object());
   add_succeeded_mess(({ "You remove any limits set on " + name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_black_list_add(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add people to the black list.\n");
      return 0;
   }
   name = lower_case(name);
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("Sorry, " + name + " does not play here.\n");
      return 0;
   }
   if (is_allowed(name)) {
      add_failed_mess("This person is in the list of people allowed to use "
                      "the shop.  They cannot be put on a black list.\n");
      return 0;
   }
   if (member_array(name, _black_list) != -1) {
      add_failed_mess("The person " + name + " is already in the "
                      "black list.\n");
      return 0;
   }
   _black_list += ({ name });
   event_save(this_object());
   add_succeeded_mess(({ "You add " + name + " to the black list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_black_list_add_ignore() {
   string *people;
   string *bad;
   string *ok;
   string name;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add people to the black list.\n");
      return 0;
   }
   people = this_player()->query_property("ignoring");
   if (!people) {
      add_failed_mess("You are not ignoring anyone.\n");
      return 0;
   }
   bad = ({ });
   ok = ({ });
   foreach (name in people) {
      name = lower_case(name);
      if (!PLAYER_HANDLER->test_user(name)) {
         bad += ({ name });
      } else if (member_array(name, _black_list) != -1) {
         bad += ({ name });
      } else {
         _black_list += ({ name });
         ok += ({ name });
      }
   }
   event_save(this_object());
   if (!sizeof(ok)) {
      add_failed_mess("Your ignore list is already added to the black list.\n");
      return 0;
   }
   add_succeeded_mess(({ "You add " + query_multiple_short(ok) + " to the "
                         "black list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_black_list_remove(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove people from "
                      "the black list.\n");
      return 0;
   }
   name = lower_case(name);
   if (member_array(name, _black_list) == -1) {
      add_failed_mess("The person " + name + " is not in the black list.\n");
      return 0;
   }
   _black_list -= ({ name });
   event_save(this_object());
   add_succeeded_mess(({ "You remove " + name + " from the black list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_user_function_add(string def, string expr) {
   string name;
if (this_player()->query_name() != "presto")
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add functions to this store.\n");
      return 0;
   }
   name = parse_user_expression(def, expr);
   if (name) {
      if (strlen(query_last_expression_warning())) {
         write("WARNING!!! Any changes of types could cause expressions "
               "currently using the functions to fail.\n" +
               query_last_expression_warning());
      }
      write("You successfully add:\n" + query_user_function_string(name));
      add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
      event_save(this_object());
      return 1;
   }
   add_failed_mess(query_last_expression_error() + "\n");
   return 0;
}
int do_user_function_remove(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove functions from this store.\n");
      return 0;
   }
   if (query_user_function_return_type(name) != EXPRESSION_TYPE_ERROR) {
      if (remove_user_expression(name)) {
         add_succeeded_mess(({ "You remove the function " + name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
         return 1;
      }
   }
   add_failed_mess(query_last_expression_error() + "\n");
   return 0;
}
int do_approve_status_internal_functions() {
   string* names;
   string name;
   string ret;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }
   names = query_function_names();
   ret = "Functions:\n";
   foreach (name in names) {
      ret += query_type_name(query_function_type(name)) + " " + name +
             "(" + implode(map(query_function_args_types(name),
                               (: query_type_name($1) :)), ", ") +
             ")\n";
   }
   ret += "\nVariables:\n";
   names = query_variable_names();
   foreach (name in names) {
      ret += query_type_name(query_variable_type(name)) + " " + name +
             "\n";
   }
   write("$P$Internal functions$P$" + ret);
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_function_help(string name) {
   string nroff_fn;
   string str;
   string fname;
   fname = CRAFT_SHOP_EXPRESSION_HELP_DIR + name;
   if (file_size(fname) <= 0) {
      add_failed_mess("There is no help for the function '" + name + "'.\n");
      return 0;
   }
   nroff_fn = NROFF_DIR + replace(fname, "/", ".");
   str = NROFF_HAND->cat_file(nroff_fn, 1);
   if (!str) {
      NROFF_HAND->create_nroff(fname, nroff_fn);
      str = NROFF_HAND->cat_file(nroff_fn, 0);
   }
   write("$P$function: " + name + "$P$" + str);
   return 1;
}
int do_function_help_list() {
   string *names;
   names = get_dir(CRAFT_SHOP_EXPRESSION_HELP_DIR);
   if (!sizeof(names)) {
      add_failed_mess("There is no help on any functions.\n");
      return 0;
   }
   names -= ({ ".", "..", "RCS" });
   write(sprintf("%-#*s\n", this_player()->query_cols(), implode(names, "\n")));
   return 1;
}
int do_approve_status_functions(int hints) {
   string* names;
   string name;
   string ret;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }
   names = query_user_function_names();
   if (!sizeof(names)) {
      add_failed_mess("Could not find any user defined expressions.\n");
      return 0;
   }
   ret = "";
   foreach (name in names) {
      ret += query_user_function_string(name) + "\n";
   }
   if (hints) {
      ret += "$I$0=       Hint: add function <function> as <expression>";
      ret += "$I$0=       Hint: remove function <function>";
   }
   write("$P$User functions$P$" + ret);
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_status(int status) {
   string ret;
   string place;
   mixed expr;
   string str;
   string name;
   class seller_information stuff;
   string *bits;
   int pos;
   int hint;
   int show_expr;
   class expression_type bing;
   class expression_type binger;
   class approval_item approval;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   hint = status & 1;
   show_expr = status & 2;
   ret = "";
   if (!show_expr) {
      ret += "$I$5=The owner of the shop is " + query_owner() + ".\n";
      ret += "$I$5=The name of the shop is " + _shop_name + ".\n";
      if (hint) {
         ret += "$I$0=       Hint: name shop <name>\n";
      }
      if (query_sign_object()) {
         ret += "$I$5=The shop currently has a sign set.\n";
      } else {
         ret += "$I$5=The shop does not currently have a sign set.\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: set sign <object>\n";
         ret += "$I$0=       Hint: remove sign\n";
      }
      if (sizeof(query_allowed())) {
         ret += "$I$5=People allowed to change the shop are " +
                query_multiple_short(sort_array(query_allowed(), 0)) + ".\n";
      } else if (hint) {
         ret += "$I$5=Only the owner can change the shop.\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: allow <person>\n";
         ret += "$I$0=       Hint: deny <person>\n";
         ret += "$I$0=       Hint: allow list\n";
      }
      if (sizeof(_black_list)) {
         ret += "$I$5=People denied access to the shop are ";
         ret += query_multiple_short(sort_array(_black_list, 0)) + "\n";
      } else {
         ret += "$I$0=Noone is denied access to the shop.\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: add <person> to blacklist\n";
         ret += "$I$0=       Hint: remove <person> from blacklist\n";
         ret += "$I$0=       Hint: add ignore to blacklist\n";
      }
      ret += "$I$0=\n";
      ret += "The current percentage to automatically add to the buy price is: " +
             _automatic_percentage + "%\n";
      if (hint) {
         ret += "$I$0=       Hint: markup <percent>\n";
      }
      ret += "Limits on what can be sold.\n";
      ret += "Maximum number of items allowed in the shop : ";
      if (query_maximum_inventory_size()) {
         ret += query_maximum_inventory_size() + " currently " +
                sizeof(query_controller()->query_sell_list_obs()) + " (fixed).\n";
      } else {
         ret += "disabled (fixed).\n";
      }
      ret += "Maximum number of items allowed per player  : ";
      if (_automatic_approval->num_allowed) {
         ret += _automatic_approval->num_allowed + ".\n";
      } else {
         ret += "disabled.\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: set max number <number|disable>\n";
      }
      ret += "Automatically queue sales more than         : ";
      if (_automatic_approval->high_cost) {
         ret += MONEY_HAND->money_value_string(_automatic_approval->high_cost, place) +
                ".\n";
      } else {
         ret += "disabled.\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: set high queue cost <cost|disable>\n";
      }
      ret += "Automatically deny sales more than          : ";
      if (_automatic_approval->high_cost_deny) {
         ret += MONEY_HAND->money_value_string(_automatic_approval->high_cost_deny, place) +
                ".\n";
      } else {
         ret += "disabled.\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: set high deny cost <cost|disable>\n";
      }
      if (sizeof(_sellers)) {
         ret += "Limits set per player.\n";
         ret += sprintf("   %-15s %-15s %-20s %s\n", "Name", "Max Sellable",
                        "Approve Limit", "Deny limit (per item)");
         bits = sort_array(keys(_sellers), 0);
         foreach (name in bits) {
            stuff = _sellers[name];
            ret += sprintf("   %-15s %-15s %-20s %s\n", name,
                       (stuff->max_sellable?stuff->max_sellable+"":"disabled"),
                       (stuff->value_limit?MONEY_HAND->money_value_string(stuff->value_limit, place):"disabled"),
                       (stuff->deny_value_limit?MONEY_HAND->money_value_string(stuff->deny_value_limit, place):"disabled"));
         }
      } else {
         ret += "No limits set per player.\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: set max number <max sellable|disable> for <player>\n";
         ret += "$I$0=       Hint: set high queue cost <cost|disable> for <player>\n";
         ret += "$I$0=       Hint: set high deny cost <cost|disable> for <player> to <cost|disable>\n";
      }
      ret += "\nAutomatically approve sales less than       : ";
      if (_automatic_approval->low_cost) {
         ret += MONEY_HAND->money_value_string(_automatic_approval->low_cost, place) +
                ".\n";
      } else {
         ret += "disabled.\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: set low approve cost <cost|disable>\n";
      }
   }
   if (show_expr) {
      if (sizeof(_automatic_approval->items)) {
         ret += "$I$0=%^BOLD%^Automatically accept sales of items%^RESET%^\n";
         foreach (str, expr in _automatic_approval->items) {
            if (classp(expr)) {
               approval = (class approval_item)expr;
               expr = ((class approval_item)expr)->value;
            } else {
               approval = new(class approval_item);
            }
            if (pointerp(expr) && intp(expr[0])) {
               map_delete(_automatic_approval->items, str);
            } else {
               ret += sprintf("$I$10=   %-20s", "* " + str);
               if (sizeof(approval) == 3) {
                  approval = new(class approval_item,
                         markup : approval->markup,
                         value : approval->value,
                         list_name : approval->list_name,
                         final_cost : 0);
               }
               if (approval->list_name) {
                  ret += " listed as '" + approval->list_name + "'";
               }
               if (approval->markup) {
                  ret += " markup of " + approval->markup;
               }
               if (approval->final_cost) {
                  ret += " final cost of " +
                  MONEY_HAND->money_value_string(approval->final_cost, place);
               }
               ret += " max value:";
               if (pointerp(expr)) {
                  str = query_expression_string(expr, 0);
                  if (strsrch(str, "\n") != -1) {
                     ret += "\n" + str;
                  } else {
                     ret += str;
                  }
               } else {
                  ret += MONEY_HAND->money_value_string(expr, place);
               }
               ret += "\n";
            }
         }
      } else {
         ret += "Automatically accept sales of               : (none setup)\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: auto add name <name> up to <value>\n";
         ret += "$I$0=       Hint: auto add name <name> up to <value> as <list name>\n";
         ret += "$I$0=       Hint: auto add name <name> up to <value> with markup <percentage>\n";
         ret += "$I$0=       Hint: auto add name <name> up to <value> with value <final cost>\n";
         ret += "$I$0=       Hint: auto add name <name> up to <value> as <list name> with markup <percentage>\n";
         ret += "$I$0=       Hint: auto add name <name> up to <value> as <list name> with value <final cost>\n";
         ret += "$I$0=       Hint: auto add name <name> with <expression>\n";
         ret += "$I$0=       Hint: auto add name <name> with <expression> as <list name>\n";
         ret += "$I$0=       Hint: auto add name <name> with <expression> and markup <percentage>\n";
         ret += "$I$0=       Hint: auto add name <name> with <expression> and value <final cost>\n";
         ret += "$I$0=       Hint: auto add name <name> with <expression> as <list name> with markup <percentage>\n";
         ret += "$I$0=       Hint: auto add object <object> up to <value>\n";
         ret += "$I$0=       Hint: auto add object <object> up to <value> as <list name>\n";
         ret += "$I$0=       Hint: auto add object <object> up to <value> with markup <percentage>\n";
         ret += "$I$0=       Hint: auto add object <object> up to <value> with value <final cost>\n";
         ret += "$I$0=       Hint: auto add object <object> up to <value> as <list name> with markup <percentage>\n";
         ret += "$I$0=       Hint: auto add object <object> up to <value> as <list name> with value <final cost>\n";
         ret += "$I$0=       Hint: auto add item object <object> with <expression>\n";
         ret += "$I$0=       Hint: auto add item object <object> with <expression> as <list name>\n";
         ret += "$I$0=       Hint: auto add item object <object> with <expression> with markup <percentage>\n";
         ret += "$I$0=       Hint: auto add item object <object> with <expression> with value <final cost>\n";
         ret += "$I$0=       Hint: auto add item object <object> with <expression> as <list name> with markup <percentage>\n";
         ret += "$I$0=       Hint: auto add item object <object> with <expression> as <list name> with value <final cost>\n";
         ret += "$I$0=       Hint: auto remove name <name>\n";
         ret += "$I$0=       Hint: auto remove object <object>\n";
      }
      ret += "\n$I$0=%^BOLD%^Automatic approval expressions.%^RESET%^\n";
      if (sizeof(_automatic_approval->expressions)) {
         pos = 0;
         foreach (bing in _automatic_approval->expressions) {
            if (sizeof(bing) == 3) {
               binger = new(class expression_type);
               binger->type = bing->type;
               binger->condition = bing->condition;
               binger->value = bing->value;
               bing = binger;
               event_save(this_object());
            }
            if (bing->type != PLAYER_CRAFT_SHOP_EXPR_DENY) {
               str = query_expression_string(bing->value, 0);
               if (strsrch(str, "\n") != -1) {
                  str = "\n" + str;
               }
               str = " accept value: " + str;
               if (bing->list_name) {
                  str += " as " + bing->list_name;
               }
            } else {
               str = " -- deny item";
            }
            ret += "$I$5=" + query_letter_value(pos) + ") " +
                   query_expression_string(bing->condition, 0) + str + ".\n";
            pos++;
         }
      } else {
         ret += "$I$0=No automatic approval expressions setup.\n";
      }
      if (hint) {
         ret += "$I$0=       Hint: auto add approve expression <condition> cost <value> as <list name>\n";
         ret += "$I$0=       Hint: auto deny expression <expression>\n";
         ret += "$I$0=       Hint: auto remove expression <id>\n";
      }
   }
   ret += "\n$I$0=";
   if (sizeof(_buy_expression)) {
      ret += "Buy condition: " + query_expression_string(_buy_expression, 0) +
             ".\n";
   } else {
      ret += "Anyone can buy from the shop.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: buy expression <expression|disable>\n";
   }
   if (sizeof(_use_expression)) {
      ret += "Use condition: " + query_expression_string(_use_expression, 0) +
             ".\n";
   } else {
      ret += "Anyone can use the shop.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: use expression <expression|disable>\n";
   }
   if (!show_expr) {
      ret += "$I$0=Use 'expressions' to see the expressions.\n";
   }
   ret += "$I$0=Use 'functions' to see the user defined "
          "functions.\n";
   write("$P$Status$P$" + ret);
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_pay_deficit() {
   int cost;
   string place;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to pay off the deficit for " +
                      the_short() + ".\n");
      return 0;
   }
   if (query_owners_money() >= 0) {
      add_failed_mess("There is no deficit here to pay off.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   cost = -query_owners_money();
   if (this_player()->query_value_in(place) >= cost) {
      adjust_royalty(query_owner(), cost);
      this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);
      add_succeeded_mess("$N pay$s off the deficit in " + the_short() + ".\n");
      return 1;
   }
   add_failed_mess("You do not have enough money to pay off the deficit "
                   "of " + MONEY_HAND->money_value_string(cost, place) +
                   ".\n");
   return 0;
}
int do_approve_buy_expression(string str) {
   class parse_node* expr;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add restrictions to the shop.\n");
      return 0;
   }
   if (str == "disable")  {
      _buy_expression = ({ });
      add_succeeded_mess(({"You disable checking to see if someone "
         "can buy from the shop.\n",
         "$N fiddle$s about with " + the_short() + " a bit.\n"}));
      return 1;
   }
   expr = parse_boolean_string(str);
   if (!sizeof(expr)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   } else {
      _buy_expression = expr;
      add_succeeded_mess(({ "You set the expression to use when checking "
                            "to see if someone can buy from the shop to " +
                            query_expression_string(expr, 1) +
                            ".\n",
                            "$N fiddle$s about with " + the_short() +
                                " a bit.\n" }));
      event_save(this_object());
   }
   return 1;
}
int do_approve_use_expression(string str) {
   class parse_node* expr;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add restrictions to the shop.\n");
      return 0;
   }
   if (str == "disable")  {
      _use_expression = ({ });
      add_succeeded_mess(({ "You disable checking to see if "
         "someone can use the shop.\n",
         "$N fiddle$s about with " + the_short() + " a bit.\n" }));
      return 1;
   }
   expr = parse_boolean_string(str);
   if (!sizeof(expr)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   } else {
      _use_expression = expr;
      add_succeeded_mess(({ "You set the expression to use when checking "
                            "to see if someone can use the shop to " +
                            query_expression_string(expr, 1) +
                            ".\n",
                            "$N fiddle$s about with " + the_short() +
                                " a bit.\n" }));
      event_save(this_object());
   }
   return 1;
}
int do_add_new_category(string category) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add categories.\n");
      return 0;
   }
   if (query_controller()->is_valid_category(category)) {
      add_failed_mess("The category already exists.\n");
      return 0;
   }
   add_shop_category(category);
   add_succeeded_mess("$N add$s a new category.\n");
   return 1;
}
int do_remove_category(string category) {
   object* obs;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove categories.\n");
      return 0;
   }
   category = query_real_category_name(category);
   if (!category ||
       !query_controller()->is_valid_category(category)) {
      add_failed_mess("The category " + category + " does not exist.\n");
      return 0;
   }
   if (category == query_default_category()) {
      add_failed_mess("You cannot remove the default category.\n");
      return 0;
   }
   obs = query_controller()->query_sell_list_obs();
   obs = filter(obs, (: query_controller()->query_category_of_shop_object($1)  == $2:), category );
   if (sizeof(obs)) {
      add_failed_mess("The category '" + category + "' is not empty "
                     "and cannot be removed.\n");
      return 0;
   }
   write("Do you wish to remove the category " + category + " from " +
         the_short() + " (y/n)?");
   input_to("check_remove_category", 0, category);
   add_succeeded_mess(({ "", "$N removes a category from the shop.\n" }));
   return 1;
}
int do_rename_category(string category, string new_category) {
   object* obs;
   object ob;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to rename categories.\n");
      return 0;
   }
   category = query_real_category_name(category);
   if (!category ||
       !query_controller()->is_valid_category(category)) {
      add_failed_mess("The category " + category + " does not exist.\n");
      return 0;
   }
   if (category == query_default_category()) {
      add_failed_mess("You cannot remove the default category.\n");
      return 0;
   }
   add_shop_category(new_category);
   obs = query_controller()->query_sell_list_obs();
   obs = filter(obs, (: query_controller()->query_category_of_shop_object($1)  == $2:), category );
   if (sizeof(obs)) {
      foreach (ob in obs) {
         query_controller()->change_category_of_shop_object(ob, new_category);
      }
   }
   remove_shop_category(category);
   add_succeeded_mess("$N rename$s category " + category + " to " +
                      new_category + ".\n");
   return 1;
}
protected void check_remove_category(string answer, string category) {
   class approval_obs approve;
   if (!strlen(answer) ||
       lower_case(answer)[0] != 'y') {
      write("Aborting deleting the category " + category + ".\n");
      return ;
   }
   remove_shop_category(category);
   write("Removed the shop category " + category + ".\n");
   foreach (approve in query_approval_list(0)) {
      if (approve->category == category) {
         approve->category = query_default_category();
      }
   }
   foreach (approve in query_approval_list(1)) {
      if (approve->category == category) {
         approve->category = query_default_category();
      }
   }
   event_save(this_object());
   return ;
}
int do_set_default_category(string default_cat) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set the default category.\n");
      return 0;
   }
   default_cat = query_real_category_name(default_cat);
   if (!default_cat ||
       !query_controller()->is_valid_category(default_cat)) {
      add_failed_mess("The category " + default_cat + " does not exist.\n");
      return 0;
   }
   set_default_category(default_cat);
   add_succeeded_mess("$N set$s the default category for " + the_short() +
                      ".\n");
   event_save(this_object());
   return 1;
}
int do_list_categories() {
   string cat;
   string ret;
   ret = "";
   foreach (cat in query_controller()->query_categories()) {
      if (cat == query_default_category()) {
         ret += cat + " (default)\n";
      } else {
         ret += cat + "\n";
      }
   }
   write("$P$Category list$P$The current categories are:\n" + ret);
   add_succeeded_mess(({ "", "$N browses the categories.\n" }));
   return 1;
}
int do_name_shop(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot set the name of " + the_short() + ".\n");
      return 0;
   }
   set_shop_name(name);
   add_succeeded_mess("$N set$s the shop name to '" + name + "'.\n");
   return 1;
}
int do_stats_items(int type) {
   class shop_stats stat;
   string ret;
   string *bits;
   string place;
   string name;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot read " + the_short() + "'s ledger.\n");
      return 0;
   }
   if (!sizeof(_sell_stats)) {
      add_failed_mess("Nothing has been sold in this transaction section "
                      "yet.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   switch (type) {
   case 1:
      bits = sort_array(keys(_sell_stats), (: _sell_stats[$1]->num_sold - _sell_stats[$2]->num_sold :));
      break;
   case 2:
      bits = sort_array(keys(_sell_stats), (: _sell_stats[$1]->value_sold - _sell_stats[$2]->value_sold :));
      break;
   default :
      bits = sort_array(keys(_sell_stats), 0);
      break;
   }
   ret = "Statistics for items sold since " + ctime(_stats_start) + ".\n";
   foreach (name in bits) {
      stat = _sell_stats[name];
      ret += name + ": " + stat->num_sold + " for " +
             MONEY_HAND->money_value_string(stat->value_sold, place) + ".\n";
   }
   write("$P$Sold stats$P$" + ret);
   add_succeeded_mess(({ "", "$N looks at the ledger.\n" }));
   return 1;
}
#if USE_TRANSACTIONS
int do_stats_transactions() {
   class shop_transaction bing;
   string ret;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot read " + the_short() + "'s ledger.\n");
      return 0;
   }
   ret = "Statistics for transactions since " + ctime(_stats_start) + ".\n";
   foreach (bing in _transactions) {
      ret += "$I$5=" + query_transaction_string(bing) + "\n";
   }
   write("$P$Sold stats$P$" + ret);
   add_succeeded_mess(({ "", "$N looks at the ledger.\n" }));
   return 1;
}
#endif
int do_stats_money() {
   string ret;
   int stock_value;
   string place;
   object ob;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot read " + the_short() + "'s ledger.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   ret = "";
   ret += "\nCurrent money spent " +
          MONEY_HAND->money_value_string(_total_outgoing, place) +
          " and money made " +
          MONEY_HAND->money_value_string(_total_ingoing, place) + ".\n";
   foreach (ob in query_controller()->query_sell_list_obs()) {
      stock_value += ob->query_value();
   }
   ret += "The current stock value is " +
             MONEY_HAND->money_value_string(stock_value, place) +
          ".\n";
   ret += "\n";
   if (query_owners_money() > 0) {
      ret += "The owner current has a cash float (royalties) of " +
             MONEY_HAND->money_value_string(query_owners_money(), place) +
             ".\n";
   } else if (query_owners_money() < 0) {
      ret += "The owner current has a cash deficit of " +
             MONEY_HAND->money_value_string(-query_owners_money(), place) +
             ".\n";
   }
   write(ret);
   add_succeeded_mess(({ "", "$N looks at the ledger.\n" }));
   return 1;
}
int do_set_sign(object* obs) {
   object ob;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot set the sign for the shop.\n");
      return 0;
   }
   if (sizeof(obs) > 1) {
      add_failed_mess("You must only specifiy one sign.\n");
      return 0;
   }
   if (living(obs[0])) {
      add_failed_mess("You have to wait till " + obs[0]->the_short() +
                      " dies first.\n");
      return 0;
   }
   if (obs[0]->get()) {
      add_failed_mess("Cannot set something as a sign that you cannot get.\n");
      return 0;
   }
   ob = query_sign_object();
   if (obs[0]->move("/room/rubbish") == MOVE_OK) {
      set_sign_object(obs[0]);
   } else {
      add_failed_mess("Unable to move $I off you.\n", obs[0..0]);
      return 0;
   }
   if (query_sign_object() != ob) {
      if (ob) {
         ob->set_get();
         if (ob->move(this_player()) != MOVE_OK) {
            ob->move(this_object());
         }
         add_succeeded_mess(({ "You remove the sign " +ob->the_short() +
                               " and set " + obs[0]->the_short() +
                               " as your shop sign.\n",
                               "$N sets the sign for outside " + the_short() +
                               ".\n" }));
      } else {
         add_succeeded_mess(({ "You set " + obs[0]->the_short() +
                               " as your shop sign.\n",
                               "$N sets the sign for outside " + the_short() +
                               ".\n" }));
      }
      return 1;
   } else {
      obs[0]->move(this_player());
      add_failed_mess("You cannot set the sign for some reason.\n");
      return 0;
   }
}
int do_remove_sign() {
   object ob;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot set the sign for the shop.\n");
      return 0;
   }
   if (!query_sign_object()) {
      add_failed_mess("You cannot remove the sign since there is no sign.\n");
      return 0;
   }
   ob = query_sign_object();
   ob->set_get();
   if (ob->move(this_player()) == MOVE_OK) {
      add_succeeded_mess("$N $V $I from " + the_short() +
                         ".\n", ({ ob }));
      set_sign_object(0);
      return 1;
   } else {
      ob->reset_get();
      add_failed_mess("You cannot remove the sign, unable to hold it?\n");
      return 0;
   }
}
int do_collect_partial_royalties(string amount) {
   int amt;
   string place;
   if (query_owner() != this_player()->query_name()) {
      add_failed_mess("Only the owner can do this.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   amt = value_from_string(amount, place);
   if (!amt) {
      add_failed_mess("The value " + amount + " is not a valid money "
                      "amount.\n");
      return 0;
   }
   if (amt > query_owners_money()) {
      add_failed_mess("You cannot collect more money than you have.\n");
      return 0;
   }
   query_controller()->pay_out_royalty(this_player()->query_name(), place, amt);
   add_succeeded_mess(({ "You collect " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " in royalties.\n",
                      "$N collects some money in royalties.\n" }));
   return 1;
}
private int variable_player_level(string seller, int cost, object* ob) {
   return PLAYER_HANDLER->test_level(seller);
}
private string variable_player_guild(string seller, int cost, object* ob) {
   string guild;
   guild = PLAYER_HANDLER->test_guild(seller);
   if (guild) {
      return guild->query_name();
   }
   return "";
}
private string variable_player_order(string seller, int cost, object* ob) {
   string guild;
   guild = PLAYER_HANDLER->test_guild(seller);
   if (guild) {
      guild = guild->query_wizard_order();
      if (guild) {
         return replace_string(lower_case(guild), "_", " ");
      }
   }
   return "";
}
private string variable_player_deity(string seller, int cost, object* ob) {
   string deity;
   deity = PLAYER_HANDLER->test_deity(seller);
   if (deity) {
      return deity;
   }
   return "";
}
private string variable_player_family(string seller, int cost, object* ob) {
   string family;
   family = PLAYER_HANDLER->test_family(seller);
   if (family) {
      return family;
   }
   return "";
}
private int function_object_base_value(object* obs, string seller, int cost, object* fluff) {
   int value;
   object ob;
   int tmp;
   value = 1000000000;
   foreach (ob in obs) {
      tmp = ob->query_base_value();
      if (tmp < value) {
         value = tmp;
      }
   }
   return value;
}
private int function_object_value(object* obs, string seller, int cost, object* fluff) {
   int value;
   object ob;
   int tmp;
   value = 1000000000;
   foreach (ob in obs) {
      tmp = ob->query_value();
      if (tmp < value) {
         value = tmp;
      }
   }
   return value;
}
private int function_object_condition(object* obs, string seller, int cost, object* fluff) {
   int cond;
   object ob;
   int tmp;
   int max;
   cond = 100;
   foreach (ob in obs) {
      tmp = ob->query_cond();
      max = ob->query_max_cond();
      if (max) {
         tmp = tmp * 100 / max;
         if (tmp < cond) {
            cond = tmp;
         }
      }
   }
   return cond;
}
private int function_object_enchant(object*obs, string seller, int cost, object* fluff) {
   int enchant;
   object ob;
   int tmp;
   int max;
   string bing;
   if (!sizeof(obs)) {
      return 0;
   }
   if (!PLAYER_HANDLER->test_guild(query_owner())->query_see_octarine()) {
      foreach (bing in query_allowed()) {
         if (PLAYER_HANDLER->test_guild(bing)->query_see_octarine()) {
            tmp = 1;
         }
      }
      if (!tmp) {
         return 0;
      }
   }
   enchant = 100;
   foreach (ob in obs) {
      tmp = ob->query_enchant();
      max = ob->query_max_enchant();
      tmp = tmp * 100 / max;
      if (tmp < enchant) {
         enchant = tmp;
      }
   }
   return enchant;
}
private object* variable_objects(string seller, int cost, object* obs) {
   return obs;
}
private string function_object_type(object* obs, string seller, int cost, object* fluff) {
   string type;
   string old_type;
   object ob;
   if (!sizeof(obs)) {
      return 0;
   }
   foreach (ob in obs) {
      if (ob->query_weapon()) {
         type = "weapon";
      } else if (ob->query_armour()) {
         type = "armour";
      } else if (ob->query_clothing()) {
         type = "clothing";
      } else {
         type = "misc";
      }
      if (old_type && old_type != type) {
         type = "mixed";
      }
      old_type = type;
   }
   return type;
}
private object* function_object_stolen(object* obs, string seller, int cost, object* fluff) {
   obs = filter(obs, (: $1->query_property("stolen") :));
   return obs;
}
private object* function_object_warded(object* obs, string seller, int cost, object* fluff) {
   string classification;
   classification = "/std/effects/object/ward"->query_classification();
   obs = filter(obs, (: sizeof($1->effects_matching($2)) :), classification);
   return obs;
}
private string variable_sale_name(string seller, int cost, object* ob, string name, string category) {
   if (name) {
      return lower_case(name);
   }
   return "";
}
private string variable_sale_category(string seller, int cost, object* ob, string name, string category) {
   if (category) {
      return lower_case(category);
   }
   return "";
}
private int variable_sale_cost(string seller, int cost, object* ob, string name, string category) {
   return cost;
}
private object* function_object_contains_spell(object* obs, string spell_name,
                          string seller, int cost, object* fluff) {
   string bing;
   int tmp;
   if (!sizeof(obs)) {
      return 0;
   }
   if (!PLAYER_HANDLER->test_guild(query_owner())->query_see_spells()) {
      foreach (bing in query_allowed()) {
         if (PLAYER_HANDLER->test_guild(bing)->query_see_spells()) {
            tmp = 1;
         }
      }
      if (!tmp) {
         return 0;
      }
   }
   obs = filter(obs, (: $1->query_magic_scroll() &&
           ($2 == "any" || lower_case($1->query_spell_name()) == lower_case($2)) :), spell_name);
   return obs;
}
private object* function_object_contains_imbue(object* obs, string ritual_name,
                          string seller, int cost, object* fluff) {
   if (!sizeof(obs)) {
      return ({ });
   }
   obs = filter(obs, (: $1->query_faith_imbue() &&
      ($2 == "any" ||
       lower_case($1->query_ritual_name()) == lower_case($2)) :), ritual_name );
   return obs;
}
private int function_object_percentage_liquid(object* obs, string liquid_name,
                          string seller, int cost, object* fluff) {
   object ob;
   object* liquids;
   object liq;
   int volume;
   int found;
   int tmp;
   if (!sizeof(obs)) {
      return 0;
   }
   volume = 100;
   foreach (ob in obs) {
      liquids = filter(all_inventory(ob), (: $1->query_liquid() :));
      if (sizeof(liquids))  {
         foreach (liq in liquids) {
            if (liq->query_short() &&
                lower_case(liq->query_short()) == lower_case(liquid_name)) {
               tmp = liq->query_weight() * 100 / ob->query_max_weight();
               if (tmp < volume) {
                  volume = tmp;
                  found = 1;
               }
            }
         }
      }
      else if (ob->query_liquid_short() &&
               lower_case(ob->query_liquid_short()) ==
               lower_case(liquid_name))
      {
         tmp = ob->query_water_volume() * 100 / ob->query_max_volume();
         if (tmp < volume)  {
            volume = tmp;
            found = 1;
         }
      }
   }
   if (found) {
      return volume;
   }
   return 0;
}
private int function_object_charges(object* obs, string seller, int cost, object *fluff)  {
   int total = 0;
   int possible = 0;
   int charges;
   mixed info;
   object ob;
   foreach (ob in obs)  {
      charges = ob->query_charges();
      if (charges)  {
         info = ob->query_static_auto_load();
         if (pointerp(info)  &&  sizeof(info) == 2  &&  info[0] == charges)  {
            possible += info[1] * CHARGE_MULT;
            total += charges;
         }
      }
   }
   if (possible)
      return 100 * total / possible;
   else
      return 0;
}
private object* function_object_matching(object* obs, string match,
                          string seller, int cost, object* fluff) {
   object ob;
   string *bits;
   string bit;
   object* ret;
   bits = explode(match, ",");
   ret = ({ });
   foreach (ob in obs)  {
      foreach(bit in bits)   {
         if (ob && ob->full_id(bit)) {
            ret += ({ ob });
         }
      }
   }
   return ret;
}
private object* function_object_short(object* obs, string match,
                          string seller, int cost, object* fluff) {
   string* bits;
   object* result;
   bits = explode(match, ",");
   result = filter(obs, (: member_array($1->query_short(), $2) != -1 :),
                   bits);
   return result;
}
private int function_inventory_number(string inventory_type,
                          string seller, int cost, object* fluff) {
   object* result;
   int quantity;
   string lc_type;
   result = filter(query_controller()->query_sell_list_obs(),
     (: lower_case(query_controller()->query_name_of_shop_object($1)) == $2 :),
                   lc_type);
   quantity = sizeof(result);
   return quantity;
}
private int function_club_member(string club, string seller, int cost, object* ob) {
   return CLUB_HANDLER->is_member_of(club, seller);
}
private object* function_contents(object ob, string seller, int cost, object* obs) {
   if (!ob) {
      return ({ });
   }
   return all_inventory(ob);
}
void inform_of_royalties(object player) {
   if (player && environment(player) == this_object()) {
      tell_object(player, "You have some royalties to pick up.\n");
   }
}
void init() {
   if (query_controller()->query_royalty(this_player()->query_name())) {
      call_out("inform_of_royalties", 5);
   }
   add_command("waiting", "", (: do_list_approval(1) :));
   add_command("waiting", "unapproved", (: do_list_approval(0) :));
   add_command("reject", "<string'id'>",
               (: do_approve_reject($4[0], 0, -1) :));
   add_command("retrieve", "<string'id'>", (: do_return($4[0]) :) );
   add_command("return", "<string'id'>", (: do_return($4[0]) :) );
   add_command("value", "<indirect:object>",
               (: do_approve_auto_item_test($1) :));
   if (!is_allowed(this_player()->query_name())) {
      ::init();
      return ;
   }
   add_command("approve", "<string'id'>", (: do_approve_item($4[0], 0) :));
   add_command("approve", "<string'id'> for <string'value'>",
               (: do_approve_item($4[0], $4[1]) :));
   add_command("reject", "<string'id'> position <number>",
               (: do_approve_reject($4[0], 0, $4[1]) :));
   add_command("reject", "<string'id'> message <string'reject message'>",
               (: do_approve_reject($4[0], $4[1], -1) :));
   add_command("reject", "<string'id'> position <number> message <string'reject message'>",
               (: do_approve_reject($4[0], $4[2], $4[1]) :));
   add_command("set", "low approve cost <string'cost|disable'>",
               (: do_approve_auto_low($4[0]) :));
   add_command("auto", "add approve expression <string'condition'> cost <string'value'> as <string'list name'>",
               (: do_approve_auto_expression_add($4[0], $4[1],
                            PLAYER_CRAFT_SHOP_EXPR_ACCEPT, $4[2]) :));
   add_command("auto", "add deny expression <string'condition'>",
               (: do_approve_auto_expression_add($4[0], 0,
                            PLAYER_CRAFT_SHOP_EXPR_DENY, 0) :));
   add_command("auto", "remove expression <string'id'>",
               (: do_approve_auto_expression_remove($4[0]) :));
   add_command("markup", "<number'percentage'>",
               (: do_approve_percentage($4[0]) :));
   add_command("auto", "add name <string'name'> up to <string'value'>",
               (: do_approve_auto_item_add($4[0], $4[1], 0, 0, 0) :));
   add_command("auto", "add name <string'name'> up to <string'value'> with value <string'final cost'>",
               (: do_approve_auto_item_add($4[0], $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add name <string'name'> up to <string'value'> with markup <number'percentage'>",
               (: do_approve_auto_item_add($4[0], $4[1], 0, $4[2], 0) :));
   add_command("auto", "add name <string'name'> up to <string'value'> as <string'list name'>",
               (: do_approve_auto_item_add($4[0], $4[1], $4[2], 0, 0) :));
   add_command("auto", "add name <string'name'> up to <string'value'> as <string'list name'> with value <string'final cost'>",
               (: do_approve_auto_item_add($4[0], $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "add name <string'name'> up to <string'value'> as <string'list name'> with markup <number'percentage'>",
               (: do_approve_auto_item_add($4[0], $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], 0, 0, 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], 0, $4[2], 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> and value <string'final cost'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add name <string'name'> with <string'expression'> as <string'list name'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], $4[2], 0, 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> as <string'list name'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> as <string'list name'> and value <string'final cost'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "add object <indirect:object> up to <string'value'>",
               (: do_approve_auto_item_add_object($1, $4[1], 0, 0, 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> with markup <number'percentage'>",
               (: do_approve_auto_item_add_object($1, $4[1], 0, $4[2], 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> with value <string'final cost'>",
               (: do_approve_auto_item_add_object($1, $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> as <string'list name'>",
               (: do_approve_auto_item_add_object($1, $4[1], $4[2], 0, 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> as <string'list name'> with markup <number'percentage'>",
               (: do_approve_auto_item_add_object($1, $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> as <string'list name'> with value <string'final cost'>",
               (: do_approve_auto_item_add_object($1, $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "add object <indirect:object> with <string'expression'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], 0, 0, 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], 0, $4[2], 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> and value <string'final cost'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> as <string'list name'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], $4[2], 0, 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> as <string'list name'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> as <string'list name'> and value <string'final cost'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "remove name <string'name'>",
               (: do_approve_auto_item_remove($4[0]) :));
   add_command("auto", "remove object <indirect:object>",
               (: do_approve_auto_item_remove_object($1) :));
   add_command("set", "high queue cost <string'cost|disable'>",
               (: do_approve_auto_high($4[0]) :));
   add_command("set", "high deny cost <string'cost|disable'>",
               (: do_approve_auto_high_deny($4[0]) :));
   add_command("set", "max number <string'max sellable|disable'>",
               (: do_approve_limit($4[0]) :));
   add_command("set", "max number <string'max sellable|disable'> for <string'player'>",
               (: do_approve_limit_person_items($4[1], $4[0]) :));
   add_command("set", "high queue cost <string'cost|disable'> for <string'player'>",
               (: do_approve_limit_person_value($4[1], $4[0]) :));
   add_command("set", "high deny cost <string'cost|disable'> for <string'player'>",
               (: do_approve_limit_person_value_deny($4[1], $4[0]) :));
   add_command("approve", "limit remove <string'player'>",
               (: do_approve_limit_person_remove($4[0]) :));
   add_command("add", "<string'player'> to blacklist",
               (: do_approve_black_list_add($4[0]) :));
   add_command("add", "ignore to blacklist",
               (: do_approve_black_list_add_ignore() :));
   add_command("remove", "<string'player'> from blacklist",
               (: do_approve_black_list_remove($4[0]) :));
   add_command("add",
               "function <string'function'> as <string'expression'>",
               (: do_user_function_add($4[0], $4[1]) :));
   add_command("remove",
               "function <string'function'>",
               (: do_user_function_remove($4[0]) :));
   add_command("status", "",
               (: do_approve_status(0) :));
   add_command("expressions", "",
               (: do_approve_status(2) :));
   add_command("functions", "internal",
               (: do_approve_status_internal_functions() :));
   add_command("functions", "",
               (: do_approve_status_functions(0) :));
   add_command("functions", "help list",
               (: do_function_help_list() :));
   add_command("functions", "help <string'function name'>",
               (: do_function_help($4[0]) :));
   add_command("functions", "hints",
               (: do_approve_status_functions(1) :));
   add_command("expressions", "hints",
               (: do_approve_status(3) :));
   add_command("status", "hints",
               (: do_approve_status(1) :));
   add_command("browse", "waiting <string'id'>",
               (: do_approve_browse($4[0]) :));
   add_command("checkout", "<string'id'>",
               (: do_approve_checkout($4[0]) :));
   add_command("checkin", "<indirect:object>",
               (: do_approve_checkin($1) :));
   add_command("pay", "deficit",
               (: do_approve_pay_deficit() :));
   add_command("buy", "expression <string'expression|disable'>",
               (: do_approve_buy_expression($4[0]) :));
   add_command("use", "expression <string'expression|disable'>",
               (: do_approve_use_expression($4[0]) :));
   add_command("name", "shop <string'shop name'>",
               (: do_name_shop($4[0]) :));
   add_command("set", "sign <indirect:object'sign'>",
               (: do_set_sign($1) :) );
   add_command("remove", "sign",
               (: do_remove_sign() :) );
   add_command("stats", "items by name", (: do_stats_items(0) :));
   add_command("stats", "items by number", (: do_stats_items(1) :));
   add_command("stats", "items by value", (: do_stats_items(2) :));
#if USE_TRANSACTIONS
   add_command("stats", "transactions", (: do_stats_transactions() :));
#endif
   add_command("stats", "money", (: do_stats_money() :));
   add_command("check", "sell <indirect:object>",
                (: do_check_sell($1) :));
   add_command("category", "list", (: do_list_categories() :));
   add_command("category", "default <string'category'>",
               (: do_set_default_category($4[0]) :));
   add_command("category", "add <string'category'>",
               (: do_add_new_category($4[0]) :));
   add_command("category", "remove <string'category'>",
               (: do_remove_category($4[0]) :));
   add_command("category", "rename <string'category'> to <string'category'>",
               (: do_rename_category($4[0], $4[1]) :));
   add_command("collect", "royalties of <string'amount'>",
               (: do_collect_partial_royalties($4[0]) :));
   ::init();
}

==================================================
FILE: shops/inherit/player_craft_shop_base.c
==================================================

inherit "/std/shops/inherit/craft_shop_category";
inherit "/std/shops/inherit/expression_util";
inherit "/std/shops/inherit/person_expressions";
inherit "/std/shops/inherit/object_expressions";
#include <player.h>
#include <money.h>
#include <move_failures.h>
#include <shops/craft_shop.h>
#include <player_handler.h>
#include <clubs.h>
#define EXPRESSION_NO_CLASSES
#include <expressions.h>
#include <mail.h>
#include <nroff.h>
#include <player_handler.h>
#define PLAYER_CRAFT_SHOP_CHECK_PROP "player craft shop check"
#define PLAYER_CRAFT_SHOP_SELL      1
#define PLAYER_CRAFT_SHOP_SELL_AUTO 2
#define PLAYER_CRAFT_SHOP_BUY       3
#define PLAYER_CRAFT_SHOP_APPROVE   4
#define PLAYER_CRAFT_SHOP_EXPR_DENY   1
#define PLAYER_CRAFT_SHOP_EXPR_ACCEPT 2
class approval_item  {
   mixed value;
   string list_name;
   int markup;
   int final_cost;
}
class expression_type {
   int type;
   class parse_node* condition;
   class parse_node* value;
   string list_name;
}
class approval {
   mixed hairy;
   class expression_type* expressions;
   int low_cost;
   int high_cost;
   mapping items;
   int num_allowed;
   int high_cost_deny;
}
class approval_obs {
   string seller;
   string category;
   int value;
   string name;
   int* saved;
   int enter_time;
   int* checkout;
   string* shorts;
}
#if USE_TRANSACTIONS
class shop_transaction {
   int time;
   string person;
   string objects;
   string name_cat;
   int type;
   int amount;
   mixed extra;
}
#endif
class shop_stats {
   int num_sold;
   int value_sold;
   string seller;
   string name;
}
class helper_stats {
   int num_approved;
   int total_cost;
   int num_rejected;
   mapping items_approved;
}
class item_stats {
   int num_sold;
   int total_cost;
   int total_made;
   int num_bought;
}
class weekly_stats {
   int num_sold;
   int total_cost;
   int total_made;
   int num_bought;
   mapping items;
   mapping helper;
}
class seller_information {
   int max_sellable;
   int value_limit;
   int deny_value_limit;
}
private class approval_obs* _waiting_for_approval;
private class approval_obs* _approved;
private class approval _automatic_approval;
private string* _list_names;
private int _automatic_percentage;
private int _current_save_num;
private int _total_outgoing;
private int _total_ingoing;
private int _time_of_mail;
private class parse_node *_tax_expression;
#if USE_TRANSACTIONS
private class shop_transaction* _transactions;
#endif
private mapping _sold_stats;
private int _stats_start;
private mapping _sellers;
private mapping _num_checked_so_far;
private string* _helpers;
private class weekly_stats _weekly_stats;
private nosave string _parcel_post;
private nosave int _something_checkedout;
private nosave int _maximum_inventory;
private nosave int _round_value;
private nosave int _max_list_names;
private nosave int _max_items_in_queue;
protected void confirm_approval(string answer, class approval_obs approve, int final_cost);
private object* variable_objects(string seller, int cost, object* ob);
private int variable_sale_cost(string seller, int cost, object* ob, string name, string category);
private string variable_sale_name(string seller, int cost, object* ob, string name, string category);
private string variable_sale_category(string seller, int cost, object* ob, string name, string category);
private int function_inventory_number(string short, string seller, int cost, object* ob);
string query_owner();
int is_allowed(string person);
void event_save(object thing);
int is_open_for(string type, string name);
void create() {
   _round_value = 1;
   if (!_waiting_for_approval) {
      _waiting_for_approval = ({ });
   }
   if (!_approved) {
      _approved = ({ });
   }
   if (!_list_names) {
      _list_names = ({ });
   }
   if (!_automatic_approval) {
      _automatic_approval = new(class approval);
      _automatic_approval->expressions = ({ });
      _automatic_approval->items = ([ ]);
   }
   if (!_automatic_percentage) {
      _automatic_percentage = 10;
   }
#if USE_TRANSACTIONS
   if (!_transactions) {
      _transactions = ({ });
   }
#endif
   if (!_sold_stats) {
      _sold_stats = ([ ]);
   }
   if (!_helpers) {
      _helpers = ({ });
   }
   if (!_stats_start) {
      _stats_start = time();
   }
   if (!_sellers) {
      _sellers = ([ ]);
   }
   if (!_num_checked_so_far) {
      _num_checked_so_far = ([ ]);
   }
   if (!_tax_expression)  {
      _tax_expression = ({ });
   }
   if (!_weekly_stats) {
      _weekly_stats = new(class weekly_stats);
      _weekly_stats->items = ([ ]);
      _weekly_stats->helper = ([ ]);
   }
   set_cut(100);
   _max_items_in_queue = 100;
   craft_shop_category::create();
   expression_util::create();
   set_always_ask_price(1);
   add_allowed_variable("objects", EXPRESSION_TYPE_OBJECT +
                                   EXPRESSION_TYPE_ARRAY_OFFSET,
                        (: variable_objects :) );
   add_allowed_variable("salecost", EXPRESSION_TYPE_MONEY,
                        (: variable_sale_cost :) );
   add_allowed_variable("salename", EXPRESSION_TYPE_STRING,
                        (: variable_sale_name :) );
   add_allowed_variable("salencategory", EXPRESSION_TYPE_STRING,
                        (: variable_sale_category :) );
   set_expression_type("shop");
   object_expressions::create();
   person_expressions::create();
   set_no_royalty_commands(1);
}
int is_helper(string person) {
   if (!_helpers) {
      _helpers = ({ });
   }
   return member_array(person, _helpers) != -1 ||
          is_allowed(person);
}
private string strip_quotes(string str)  {
   if (str)  {
      if (str[0] == '\"')  str = str[1 .. ];
      if (str[<1] == '\"')  str = str[0 .. <2];
   }
   return str;
}
void set_maximum_waiting_queue_size(int size) {
   _max_items_in_queue = size;
}
int query_maximum_waiting_queue_size() {
   return _max_items_in_queue;
}
void set_maximum_inventory_size(int size) {
   _maximum_inventory = size;
}
int query_maximum_inventory_size() {
   return _maximum_inventory;
}
void set_parcel_post(string parcel) {
   _parcel_post = parcel;
}
string query_parcel_post() {
   return _parcel_post;
}
int query_royalty(string person) {
   return query_controller()->query_royalty(person);
}
int query_owners_money() {
   return query_royalty(query_owner());
}
void adjust_royalty(string person, int amount) {
   query_controller()->adjust_royalty(person, amount);
}
int adjust_owners_money(int amount) {
   return adjust_royalty(query_owner(), amount);
}
void set_round_price(int round) {
   _round_value = round;
}
int query_round_prices() {
   return _round_value;
}
class approval_obs* query_approval_list(int approved) {
   if (approved) {
      return _approved;
   } else {
      return _waiting_for_approval;
   }
}
int query_number_of_items_listed(string name) {
   int num;
   class approval_obs bing;
   name = lower_case(name);
   num = sizeof(query_controller()->query_owner_sellables(name));
   foreach (bing in _waiting_for_approval) {
      if (lower_case(bing->seller) == name) {
         num += sizeof(bing->saved);
      }
   }
   return num;
}
mixed is_item_approved(string seller, int value, string name, object* sellables,
                     string category, int ref final_cost) {
   string short;
   object ob;
   int item_approval;
   class expression_type bing;
   class parse_node frog;
   int cost;
   mixed item;
   final_cost = ((value * (100 + _automatic_percentage)) / 100);
   value = value - (cost % _round_value);
   if (is_allowed(seller) ||
       is_helper(seller)) {
      final_cost = value;
      return 1;
   }
   seller = lower_case(seller);
   if (_sellers[seller] &&
       _sellers[seller]->deny_value_limit) {
      if (_sellers[seller]->deny_value_limit < value) {
         return -1;
      }
   } else if (_automatic_approval->high_cost_deny &&
              _automatic_approval->high_cost_deny <= value) {
      return -1;
   }
   foreach (ob in sellables) {
      if (!ob) {
         return -1;
      }
      short = ob->query_short();
      if (_automatic_approval->items[short]) {
         if (classp(_automatic_approval->items[short])) {
            item = ((class approval_item)_automatic_approval->items[short])->value;
         } else {
            item = _automatic_approval->items[short];
         }
         if (pointerp(item)) {
            frog = evaluate_expression(item,
                                     seller,
                                     value,
                                     ({ ob }),
                                     name,
                                     category);
            cost = frog->value - (frog->value % _round_value);
            if (cost < value) {
               item_approval = 0;
               break;
            }
            item_approval++;
         } else if (item < value) {
            item_approval = 0;
            break;
         } else {
            item_approval++;
         }
      }
   }
   if (item_approval) {
      if (classp(_automatic_approval->items[short]))  {
         class approval_item womble;
         womble = _automatic_approval->items[short];
         if (sizeof(womble) == 3) {
            _automatic_approval->items[short] = new(class approval_item,
                   markup : womble->markup,
                   value : womble->value,
                   list_name : womble->list_name,
                   final_cost : 0);
            womble = _automatic_approval->items[short];
         }
         if (womble->markup) {
            final_cost = ((value * (100 + womble->markup)) / 100);
         } else if (womble->final_cost) {
            final_cost = womble->final_cost;
         }
         if (womble->list_name) {
            return womble->list_name;
         } else {
            return 1;
         }
      } else {
         return 1;
      }
   }
   if (!pointerp(_automatic_approval->expressions)) {
      _automatic_approval->expressions = ({ });
   }
   foreach (bing in _automatic_approval->expressions) {
      if (evaluate_expression(bing->condition,
                              seller,
                              value,
                              sellables,
                              name,
                              category)->value) {
         if (bing->type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
            frog = evaluate_expression(bing->value,
                                 seller,
                                 value,
                                 sellables,
                                 name,
                                 category);
            cost = frog->value - (frog->value % _round_value);
            if (cost >= value) {
               if (bing->list_name) {
                  return bing->list_name;
               } else if (classp(_automatic_approval->items[short]))  {
                  return ((class approval_item)_automatic_approval->items[short])->list_name;
               } else {
                  return 1;
               }
            }
         } else {
            return -1;
         }
      }
   }
   if (_sellers[seller] &&
       _sellers[seller]->value_limit) {
      if (_sellers[seller]->value_limit < value) {
         return 0;
      } else if (classp(_automatic_approval->items[short]))  {
         return ((class approval_item)_automatic_approval->items[short])->list_name;
      }
      else return 1;
   } else if (_automatic_approval->high_cost &&
              _automatic_approval->high_cost < value) {
      return 0;
   }
   if (_automatic_approval->low_cost &&
       _automatic_approval->low_cost >= value) {
      if (classp(_automatic_approval->items[short]))  {
         return ((class approval_item)_automatic_approval->items[short])->list_name;
      }
      else return 1;
   }
   return 0;
}
int is_allowed_to_use_shop(string person) {
   return (is_allowed(person) || is_helper(person) ||
           is_open_for("use", person));
}
int check_open(object player, string type) {
   if (!::check_open(player)) {
      return 0;
   }
   if (type == "sell") {
      if (sizeof(query_approval_list(0)) + sizeof(query_approval_list(1)) >= _max_items_in_queue) {
         add_failed_mess("Unable to sell things, the shop is full.\n");
         return 0;
      }
   }
   if (!is_allowed_to_use_shop(player->query_name())) {
      add_failed_mess("The shop is currently closed.\n");
      return 0;
   }
   return 1;
}
void set_controller(string name) {
   ::set_controller(name);
   query_controller()->set_dont_use_name(1);
}
int is_allowed_to_sell(object *obs, string name, string *sellable_names) {
   int num;
   int max;
   if (_automatic_approval->num_allowed ||
       _sellers[name]) {
      num = query_number_of_items_listed(name) + sizeof(obs);
      if (_sellers[name] && _sellers[name]->max_sellable) {
         max = _sellers[name]->max_sellable;
      } else {
         max = _automatic_approval->num_allowed;
      }
      if (num > max) {
         add_failed_mess("You cannot have more than " + max + " items "
                         "listed at " + the_short() + ", with this sale you "
                         "would have " +
                         num + ".\n");
         return 0;
      }
   }
   if (sizeof(filter(obs, (: $1->query_property("money") :))) > 0) {
      add_failed_mess("You cannot sell money.\n");
      return 0;
   }
   num = sizeof(query_controller()->query_sell_list_obs());
   if (num + sizeof(obs) > query_maximum_inventory_size()) {
      add_failed_mess("The shop is full, it can only hold " +
                      query_maximum_inventory_size() + " items and it currently "
                      "holds " + num + " items.\n");
      return 0;
   }
   return 1;
}
int* query_maximum_sale_value_both(string person, object item) {
   int max_deny;
   int max_accept;
   string short;
   class expression_type stuff;
   mixed app_item;
   if (_sellers[person]) {
      if (_sellers[person]->value_limit) {
         max_accept = _sellers[person]->value_limit;
      }
      if (_sellers[person]->deny_value_limit) {
         max_deny = _sellers[person]->deny_value_limit;
      }
   }
   if (!max_accept) {
      max_accept = _automatic_approval->high_cost;
   }
   if (!max_deny) {
      max_deny = _automatic_approval->high_cost_deny;
   }
   if (!item) {
      return ({ 0, 0 });
   }
   short = item->query_short();
   if (_automatic_approval->items[short]) {
      if (classp(_automatic_approval->items[short]))  {
         app_item = ((class approval_item)_automatic_approval->items[short])->value;
      } else {
         app_item= _automatic_approval->items[short];
      }
      if (pointerp(app_item)) {
         max_accept = evaluate_expression(app_item,
                                        person, 0, ({ item }), 0, 0)->value;
      } else if (app_item < max_deny) {
         max_accept = app_item;
      }
   }
   foreach (stuff in _automatic_approval->expressions) {
      if (evaluate_expression(stuff->condition, person, 0, ({ }), 0, 0)->value) {
         if (stuff->type == PLAYER_CRAFT_SHOP_EXPR_DENY) {
            max_deny = evaluate_expression(stuff->value, person, 0, ({ item }), 0, 0)->value;
         } else {
            max_accept = evaluate_expression(stuff->value, person, 0, ({ item }), 0, 0)->value;
         }
      }
   }
   max_accept -= max_accept % _round_value;
   max_deny -= max_deny % _round_value;
   return ({ max_accept, max_deny });
}
int query_maximum_sale_value(string person, object* obs) {
   int* stuff;
   object ob;
   int cur_deny;
   foreach (ob in obs) {
      stuff = query_maximum_sale_value_both(person, ob);
      if (!cur_deny && stuff[1]) {
         cur_deny = stuff[1];
      } else if (cur_deny && cur_deny > stuff[1]) {
         cur_deny = stuff[1];
      }
   }
   return cur_deny;
}
string query_extra_price_information(string seller, object *obs) {
   int* max;
   int* max_tmp;
   string ret;
   string place;
   object ob;
   max = ({ 0, 0 });
   foreach (ob in obs) {
      max_tmp = query_maximum_sale_value_both(seller, ob);
      if (max_tmp[0] && max[0] > max_tmp[0]) {
         max[0] = max_tmp[0];
      }
      if (max_tmp[1] && max[1] > max_tmp[1]) {
         max[1] = max_tmp[1];
      }
   }
   ret = "";
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (max[0]) {
      ret += "the maximum price you can sell this straight into the "
             "inventory for is " +
             MONEY_HAND->money_value_string(max[0], place);
   }
   if (max[1]) {
      if (max[0]) {
         ret += " and ";
      }
      ret += "the maximum price you can sell the item for at all is " +
             MONEY_HAND->money_value_string(max[1], place);
   }
   return capitalize(ret) + ".\n";
}
protected int create_auto_load_file(mixed ob, int fixed_num) {
   mixed *auto_load;
   string tmp;
   if (objectp(ob)) {
      if (this_player()) {
         catch(auto_load = this_player()->create_auto_load(({ ob })));
      }
      if (!auto_load) {
         catch(auto_load = PLAYER_OB->create_auto_load(({ ob })));
      }
      if (!auto_load) {
         auto_load = AUTO_LOAD_OB->create_auto_load(({ ob }));
      }
   } else if (pointerp(ob)) {
      auto_load = ob;
   } else {
      printf("Error!  Dammit!\n");
   }
   if (!fixed_num) {
      do {
         tmp = do_read_file(CRAFT_SHOP_DATA_SAVE_FILE,
                        "app_" + _current_save_num);
         if (tmp) {
            _current_save_num++;
         }
      } while (tmp);
      fixed_num = _current_save_num;
   }
   do_save_file(CRAFT_SHOP_DATA_SAVE_FILE,
            auto_load,
            "app_" + fixed_num);
   return fixed_num;
}
protected object create_real_auto_load_object(int num, object player) {
   string auto_load;
   object *obs;
   auto_load = do_read_file(CRAFT_SHOP_DATA_SAVE_FILE,
                        "app_" + num);
   if (userp(player)) {
      obs = player->load_auto_load_to_array(auto_load, player);
   } else if (this_player()) {
      obs = this_player()->load_auto_load_to_array(auto_load, player);
   } else {
      obs = PLAYER_OB->load_auto_load_to_array(auto_load, player);
   }
   if (sizeof(obs)) {
      return obs[0];
   }
   return 0;
}
object create_checkout_object(class approval_obs approve,
                            int id,
                            object player) {
   object ob;
   int i;
   ob = create_real_auto_load_object(id, player);
   if (ob) {
      ob->add_effect("/std/effects/object/no_save");
      ob->add_property(PLAYER_CRAFT_SHOP_CHECK_PROP, ({ approve, id }));
      i = member_array(id, approve->saved);
      approve->checkout[i] = 1;
      event_save(this_object());
      _something_checkedout++;
   }
   return ob;
}
int destroy_checkout_object(object ob) {
   int id;
   int *ids;
   int i;
   class approval_obs approve;
   if (!ob) {
      return 0;
   }
   ob->add_property("destroy checkout object", 1, 2);
   if (ob->move("/room/rubbish") != MOVE_OK) {
      return 0;
   }
   debug_printf("Destroying the checkout object %O\n", ob);
   ids = ob->effects_matching("/std/effects/object/no_save"->query_classification());
   foreach (id in ids) {
      ob->delete_effect(id);
   }
   id = ob->query_property(PLAYER_CRAFT_SHOP_CHECK_PROP)[1];
   approve = ob->query_property(PLAYER_CRAFT_SHOP_CHECK_PROP)[0];
   i = member_array(id, approve->saved);
   approve->checkout[i] = 0;
   ob->remove_property(PLAYER_CRAFT_SHOP_CHECK_PROP);
   create_auto_load_file(ob, id);
   event_save(this_object());
   _something_checkedout--;
   if (_something_checkedout < 0) {
       _something_checkedout = 0;
   }
   return 1;
}
int is_checkout_object(object ob) {
   return ob->query_property(PLAYER_CRAFT_SHOP_CHECK_PROP);
}
object* add_to_approval_list(string seller, object* sellables, int value,
                          string name, string category, int approved) {
   class approval_obs stuff;
   object ob;
   object* obs;
   obs = ({ });
   foreach (stuff in query_approval_list(approved)) {
      if (lower_case(stuff->name) == lower_case(name) &&
          stuff->seller == seller &&
          stuff->value == value) {
         stuff->category = category;
         foreach (ob in sellables) {
            if (ob->move("/room/rubbish") == MOVE_OK) {
               stuff->saved += ({ create_auto_load_file(ob, 0) });
               stuff->checkout += ({ 0 });
               stuff->shorts += ({ ob->query_short() });
               obs += ({ ob });
            }
         }
         if (sizeof(obs)) {
            event_save(this_object());
         }
         return obs;
      }
   }
   stuff = new(class approval_obs);
   stuff->seller = seller;
   stuff->value = value;
   stuff->name = name;
   stuff->category = category;
   stuff->saved = ({ });
   stuff->shorts = ({ });
   stuff->enter_time = time();
   foreach (ob in sellables) {
      if (ob->move("/room/rubbish") == MOVE_OK) {
         stuff->saved += ({ create_auto_load_file(ob, 0) });
         stuff->shorts += ({ ob->query_short() });
         obs += ({ ob });
      }
   }
   stuff->checkout = allocate(sizeof(stuff->saved));
   if (sizeof(obs)) {
      if (approved) {
         _approved += ({ stuff });
      } else {
         _waiting_for_approval += ({ stuff });
      }
      event_save(this_object());
   }
   return obs;
}
void remove_from_approval_list(class approval_obs approve) {
   int i;
   int pos;
   for (i = 0; i < sizeof(_approved); i++) {
      if (_approved[i] == approve) {
         foreach (pos in approve->saved) {
            do_save_file(CRAFT_SHOP_REMOVE_DATA_SAVE_FILE,
                         0,
                         "app_" + pos);
         }
         _approved = _approved[0..i-1] + _approved[i+1..];
         event_save(this_object());
         return ;
      }
   }
   for (i = 0; i < sizeof(_waiting_for_approval); i++) {
      if (_waiting_for_approval[i] == approve) {
         foreach (pos in approve->saved) {
            do_save_file(CRAFT_SHOP_REMOVE_DATA_SAVE_FILE,
                         0,
                         "app_" + pos);
         }
         _waiting_for_approval = _waiting_for_approval[0..i-1] + _waiting_for_approval[i+1..];
         event_save(this_object());
         return ;
      }
   }
}
void add_transaction(string person, object* objects, int type, int amount,
                     string name_cat, mixed extra) {
#if USE_TRANSACTIONS
   class shop_transaction bing;
   string str;
   str = query_multiple_short(objects, 0, 1);
   bing = new(class shop_transaction);
   bing->time = time();
   bing->person = person;
   bing->objects = str;
   bing->type = type;
   bing->amount = amount;
   bing->name_cat = name_cat;
   bing->extra = extra;
   _transactions += ({ bing });
   event_save(this_object());
#endif
}
#if USE_TRANSACTIONS
string query_transaction_string(class shop_transaction trans) {
   string ret;
   string amt;
   string place;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   amt = MONEY_HAND->money_value_string(trans->amount, place);
   ret = ctime(trans->time)[4..<9] + ": " + trans->person;
   switch (trans->type) {
   case PLAYER_CRAFT_SHOP_SELL :
      ret += " sells " + trans->objects + " (" + trans->name_cat +
             ") for " + amt;
      break;
   case PLAYER_CRAFT_SHOP_SELL_AUTO :
      ret += " sells " + trans->objects + " (" + trans->name_cat +
             ") [accepted] for " + amt;
      break;
   case PLAYER_CRAFT_SHOP_APPROVE :
      ret += " approves " + trans->objects + " (" + trans->name_cat +
             ") sold by " + trans->extra + " for " + amt;
      break;
   case PLAYER_CRAFT_SHOP_BUY :
      ret += " buys " + trans->objects + " (" + trans->name_cat +
             ") sold by " + trans->extra + " for " + amt;
      break;
   }
   return ret;
}
#endif
protected void complete_sale(int value, string name, object *sellable,
                             string category) {
   string place;
   object *bought;
   mixed approve;
   int final_cost;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   _num_checked_so_far = ([ ]);
   approve = is_item_approved(this_player()->query_name(),
                        value, name, sellable, category, ref final_cost);
   if (approve == -1) {
      write("This item is denied sale here, it is not something the "
            "owner wishes to buy.\n");
      say(this_player()->query_cap_name() + " finished attempting to sell " +
                query_multiple_short(sellable) + " to " + the_short() + ".\n");
      return ;
   }
   if (approve == 1 || stringp(approve)) {
      if (stringp(approve)) {
         name = approve;
      }
   }
   write("Waiting for approval from the shop owner for the items " +
         query_multiple_short(sellable) + " with the name '" +
         name + "' selling for " +
         MONEY_HAND->money_value_string(value, place) +
         " in category " + category + ".\nIf the item is accepted the "
         "money will be paid into your royalty pool.\n");
   bought = add_to_approval_list(this_player()->query_cap_name(), sellable,
                        value, name, category, approve != 0);
   if (sizeof(bought)) {
      add_transaction(this_player()->query_name(),
                   bought,
                   PLAYER_CRAFT_SHOP_SELL,
                   value * sizeof(sellable),
                   name + " in " + category,
                   0);
      if (sizeof(bought) != sizeof(sellable)) {
         write("Unable to sell " + query_multiple_short(sellable - bought) +
                  " to " + the_short() + ".\n");
      }
      say(this_player()->the_short() + " completes selling something "
       "to the shop.\n");
   } else {
      write("Unable to sell " + query_multiple_short(sellable) + " to " +
            the_short() + ".\n");
   }
}
string query_letter_value(int pos) {
   return sprintf("%c%c", 'A' + (pos / 26), 'A' + (pos % 26));
}
int query_number_value(string letter) {
   if (!strlen(letter)) {
      return -1;
   }
   letter = lower_case(letter);
   if (strlen(letter) < 2) {
      if (letter[0] >= 'a' && letter[0] <= 'z') {
         return letter[0] - 'a';
      }
   }
   if (strlen(letter) > 2) {
      return -1;
   }
   if (letter[0] >= 'a' && letter[0] <= 'z') {
      if (letter[1] >= 'a' && letter[1] <= 'z') {
         return (letter[0] - 'a') * 26 + (letter[1] - 'a');
      }
   }
   return -1;
}
class approval_obs query_approval_class(string name) {
   int pos;
   if (name[0] == '-') {
      pos = query_number_value(name[1..]);
   } else {
      pos = query_number_value(name);
   }
   if (pos == -1) {
      add_failed_mess(name + " is not a valid number.\n");
      return 0;
   }
   if (name[0] == '-') {
      if (!sizeof(query_approval_list(0))) {
         add_failed_mess("There is nothing in the approval list currently.\n");
         return 0;
      }
      if (pos >= sizeof(query_approval_list(0))) {
         add_failed_mess("The " + name + " is out of range, must be "
                         "between -AA and -" +
                         query_letter_value(sizeof(query_approval_list(0)) - 1) +
                         ".\n");
         return 0;
      }
      return query_approval_list(0)[pos];
   }
   if (pos >= sizeof(query_approval_list(1))) {
      add_failed_mess("The " + name + " is out of range, must be between AA-" +
                      query_letter_value(sizeof(query_approval_list(1)) - 1) +
                      ".\n");
      return 0;
   }
   return query_approval_list(1)[pos];
}
int ownership_change(string old_owner, string new_owner) {
   class parse_node* expr;
   if (old_owner == new_owner) {
      return 0;
   }
   _automatic_approval = new(class approval);
   _automatic_approval->items = ([ ]);
   _automatic_approval->expressions = ({ });
   _automatic_percentage = 10;
#if USE_TRANSACTIONS
   _transactions = ({ });
#endif
   _sold_stats = ([ ]);
   _stats_start = time();
   _sellers = ([ ]);
   expr = parse_boolean_string("false");
}
void inform_of_buy(int value, object *obs, object player, string *sellers,
                   string *names, string *cats, int *values) {
   string name_cat;
   int i;
   class shop_stats stat;
   _total_ingoing += value;
   adjust_royalty(query_owner(), value);
   for (i = 0; i < sizeof(obs); i++) {
      name_cat = names[i] + " in " + cats[i];
      add_transaction(this_player()->query_name(),
                      obs[i..i],
                      PLAYER_CRAFT_SHOP_BUY,
                      values[i],
                      name_cat,
                      sellers[i]);
      if (!_sold_stats) {
         _sold_stats = ([ ]);
      }
      stat = _sold_stats[sellers[i] + " - " + name_cat];
      if (!stat) {
         stat = new(class shop_stats);
         stat->name = name_cat;
         stat->seller = sellers[i];
      }
      stat->num_sold++;
      stat->value_sold += values[i];
      _sold_stats[sellers[i] + " - " + name_cat] = stat;
   }
   _weekly_stats->total_made += value;
}
object* check_for_checkout(object ob) {
   object* obs = ({ });
   if (_something_checkedout && ob) {
      if (living(ob)) {
         obs = filter(deep_inventory(ob), (: is_checkout_object($1) :));
         if (sizeof(obs)) {
            foreach (ob in obs) {
               if (!destroy_checkout_object(ob)) {
                  obs -= ({ ob });
               }
            }
         }
      } else {
         if (is_checkout_object(ob)) {
            call_out("verify_destroy_checkout_object", 2, ob);
         }
      }
      return obs;
   }
   return ({ });
}
void verify_destroy_checkout_object(object ob) {
   if (destroy_checkout_object(ob)) {
      tell_room(environment(), ob->the_short() +
                " magically checks itself back in.\n");
   }
}
void event_exit(object ob, string message, object to) {
   object *obs;
   if (ob->query_property("destroy checkout object")) {
      return ;
   }
   obs = check_for_checkout(ob);
   if (sizeof(obs)) {
      tell_object(ob, "You suddenly find the uncheckout items " +
                      query_multiple_short(obs) + " check themselves "
                      "back in.\n");
      obs->move("/room/rubbish");
   }
}
void event_dest_me(object ob) {
   check_for_checkout(ob);
}
void return_all_checkedout_objects() {
   object ob;
   object* obs;
   if (_something_checkedout) {
      obs = filter(deep_inventory(this_object()), (: is_checkout_object($1) :));
      if (sizeof(obs)) {
         foreach (ob in obs) {
            destroy_checkout_object(ob);
         }
      }
      tell_room(this_object(), query_multiple_short(obs) +
                " mysteriously check themselves back in.\n");
   }
}
void dest_me() {
   ::dest_me();
}
int is_able_to_change(object ob) {
   return is_allowed(this_player()->query_name()) ||
          is_helper(this_player()->query_name());
}
int do_buy(object *obs, int force) {
   if (!is_open_for("buy", this_player()->query_name()) ||
       !is_open_for("use", this_player()->query_name())) {
      add_failed_mess("You cannot buy anything at this shop.\n");
      return 0;
   }
   return ::do_buy(obs, force);
}
int do_check_sell(object *obs) {
   int *stuff;
   object ob;
   string ret;
   string place;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   ret = "";
   foreach (ob in obs) {
      stuff = query_maximum_sale_value_both(this_player()->query_name(), ob);
      ret += "$I$5=$C$" + the_short() + ": ";
      if (stuff[0]) {
         ret += "will be queued for more than " +
                MONEY_HAND->money_value_string(stuff[0], place);
      }
      if (stuff[0] && stuff[1]) {
         ret += " and ";
      }
      if (stuff[1]) {
         ret += "will be denied for more than " +
                MONEY_HAND->money_value_string(stuff[1], place);
      }
      ret += ".\n";
   }
   write("$P$Check Sell$P$" + ret);
   add_succeeded_mess(({ "", "$N checks the sale of $I.\n" }), obs);
   return 1;
}
int do_list_approval(int approved) {
   class approval_obs approve;
   int pos;
   int shown;
   int allowed;
   int checkout;
   string place;
   string ret;
   object* obs;
   object *current;
   object* result;
   string *possible_names;
   string start;
   mapping result_type;
   int i;
   int fluff;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   allowed = is_allowed(this_player()->query_name()) ||
             is_helper(this_player()->query_name());
   if (!allowed) {
      approved = 1;
   }
   if (!approved) {
      start = "-";
   } else {
      start = "";
   }
   result_type = ([ ]);
   ret = "";
   while (allowed || approved) {
      if (approved == 2) {
         approved = 0;
         start = "-";
      }
      foreach (approve in query_approval_list(approved)) {
         if (lower_case(approve->seller) == this_player()->query_name() ||
             allowed) {
            checkout = sizeof(filter(approve->checkout, (: $1 :)));
            obs = ({ });
            for (i = 0; i < sizeof(approve->saved); i++) {
               fluff = approve->saved[i];
               obs += ({ create_real_auto_load_object(fluff, this_player()) });
            }
            obs -= ({ 0 });
            possible_names = obs->query_short();
            obs->move("/room/rubbish");
            if (!result_type[lower_case(approve->name)]) {
               if (!current) {
                  current = map(query_controller()->query_sell_list_obs(),
                                (: query_controller()->query_short_of_shop_object($1) :));
               }
               result = current & possible_names;
               result_type[lower_case(approve->name)] = sizeof(result);
            }
            ret += start + query_letter_value(pos) + ") " +
                  approve->seller + "'s " + approve->name + " for " +
                  MONEY_HAND->money_value_string(approve->value, place) +
                  " in " + approve->category + ", " +
                  sizeof(approve->saved) + " objects (" +
                  query_multiple_short(obs) + ") " +
                  result_type[lower_case(approve->name)] + " in stock";
            if (checkout) {
               ret += " and " + checkout + " checked out.\n";
            } else {
               ret += ".\n";
            }
            shown++;
         }
         pos++;
      }
      if (!allowed && approved) {
         approved = 2;
         pos = 0;
      } else {
         break;
      }
   }
   if (sizeof(current)) {
      current->dest_me();
   }
   if (!shown) {
      add_failed_mess("No items to approve at the moment.\n");
      return 0;
   }
   write("$P$Approval list$P$The current approval items are:\n" + ret);
   return 1;
}
int do_return(string name) {
   object *obs;
   object *ok;
   object *here;
   object *fail;
   object *checkout;
   object money;
   class approval_obs approve;
   object ob;
   int pos;
   int i;
   int value;
   string place;
   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }
   if (lower_case(approve->seller) != this_player()->query_name()) {
      add_failed_mess("You must be the one that sold the item to return "
                      "it.\n");
      return 0;
   }
   obs = ({ });
   checkout = ({ });
   if (sizeof(filter(approve->checkout, (: $1 :))) > 0 &&
       _something_checkedout) {
      return_all_checkedout_objects();
   }
   for (i = 0; i < sizeof(approve->saved); i++) {
      pos = approve->saved[i];
      if (!approve->checkout[i]) {
         obs += ({ create_real_auto_load_object(pos, this_player()) });
      } else {
         checkout += ({ create_real_auto_load_object(pos, this_player()) });
      }
   }
   obs -= ({ 0 });
   checkout -= ({ 0 });
   if (sizeof(checkout)) {
      place = query_property("place");
      if (!place) {
         place = "default";
      }
      write("The items " + query_multiple_short(checkout) +
            " are currently checked out.  You are reimbused the amount "
            "they would have cost to sell.\n");
      value = approve->value * sizeof(checkout);
      money = MONEY_HAND->make_new_amount( value, place);
      money->move(this_player());
      _total_outgoing += approve->value * sizeof(checkout);
   }
   ok = ({ });
   here = ({ });
   fail = ({ });
   foreach (ob in obs) {
      if (ob->move(this_player()) == MOVE_OK) {
         ok += ({ ob });
      } else if (ob->move(environment(this_player()))) {
         here += ({ ob });
      } else {
         fail += ({ ob });
      }
   }
   remove_from_approval_list(approve);
   if (sizeof(ok)) {
      add_succeeded_mess("$N return$s $I.\n", map(ok, (: $1->poss_short() :)));
   }
   if (sizeof(here)) {
      add_succeeded_mess("$N $V their $I and they get put on the floor.\n",
                         map(ok, (: $1->poss_short() :)));
   }
   if (sizeof(fail)) {
      add_succeeded_mess( ({ "You find that $I do not want to be moved.\n",
                             "" }), fail);
   }
   return 1;
}
int do_approve_item(string name, string money_str) {
   int cost;
   object *obs;
   class approval_obs approve;
   string place;
   int final_cost;
   int num;
   if (!is_allowed(this_player()->query_name()) &&
       !is_helper(this_player()->query_name())) {
      add_failed_mess("You are not allowed to approve items.\n");
      return 0;
   }
   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   num = sizeof(query_controller()->query_sell_list_obs());
   if (num + sizeof(approve->saved) > query_maximum_inventory_size()) {
      add_failed_mess("You cannot approve anything, the shop is already "
                      "at the maximum number allowed.\n");
      return 0;
   }
   cost = approve->value * sizeof(obs);
   if (this_player()->query_value_in(place) < cost) {
      add_failed_mess("You need at least " +
                      MONEY_HAND->money_value_string(cost, place) +
                      " to put this into the shop.\n");
      return 0;
   }
   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess("The amount " + money_str + " is not a valid "
                         "money cost.\n");
         return 0;
      }
   }
   if (sizeof(filter(approve->checkout, (: $1 :))) > 0 &&
       _something_checkedout) {
      write("One of these objects is still checkedout, do you wish to "
            "continue this without these items? ");
      input_to("confirm_approval", 0, approve, final_cost);
      add_succeeded_mess( ({ "", "$N approves something in the shop.\n" }) );
      return 1;
   }
   confirm_approval("y", approve, final_cost);
   return 1;
}
void reset_weekly_status() {
   _weekly_stats = new(class weekly_stats);
   _weekly_stats->num_sold = 0;
   _weekly_stats->total_cost = 0;
   _weekly_stats->total_made = 0;
   _weekly_stats->num_bought = 0;
   _weekly_stats->helper = ([ ]);
}
string query_weekly_status_string() {
   string ret;
   string place;
   string player;
   class helper_stats helpers;
   class item_stats items;
   string* item_bits;
   string item;
   int num;
   place = query_property("place");
   ret = "$I$0=Total Outgoing  : " +
          MONEY_HAND->money_value_string(_weekly_stats->total_cost, place) + "\n";
   ret += "$I$0=Total Incoming : " +
          MONEY_HAND->money_value_string(_weekly_stats->total_made, place) + "\n";
   if (_weekly_stats->total_made > _weekly_stats->total_cost) {
      ret += "$I$0=Profit of      : " +
          MONEY_HAND->money_value_string(_weekly_stats->total_made - _weekly_stats->total_cost, place) + "\n";
   } else {
      ret += "$I$0=Loss of        : " +
          MONEY_HAND->money_value_string(-(_weekly_stats->total_made - _weekly_stats->total_cost), place) + "\n";
   }
   ret += "$I$0=Items             : " +
          _weekly_stats->num_sold + " sold and " +
          _weekly_stats->num_bought + " bought.\n";
   ret += "\n$I$0=Player summaries:\n";
   foreach (player, helpers in _weekly_stats->helper) {
      item_bits = ({ });
      if (sizeof(helpers->items_approved)) {
         foreach (item, num in helpers->items_approved) {
            item_bits += ({ num + " " + item });
         }
      } else {
         item_bits = ({ "nothing" });
      }
      ret += "$I$6=   " + player + ": " + helpers->num_approved +
             " approved, " + helpers->num_rejected + " rejected, " +
             MONEY_HAND->money_value_string(helpers->total_cost, place) +
             " approved " + query_multiple_short(item_bits) + "\n";
   }
   return ret;
}
protected void inform_of_approved_item(string name,
                            int cost,
                            class approval_obs approve) {
   string str;
   if (!_weekly_stats) {
      _weekly_stats = new(class weekly_stats);
      _weekly_stats->items = ([ ]);
      _weekly_stats->helper = ([ ]);
   }
   _weekly_stats->total_cost += cost;
   str = approve->name;
   name = this_player()->query_name();
   if (!_weekly_stats->helper[name]) {
      _weekly_stats->helper[name] = new(class helper_stats);
      _weekly_stats->helper[name]->items_approved = ([ ]);
   }
   _weekly_stats->helper[name]->num_approved++;
   _weekly_stats->helper[name]->total_cost += cost;
   if (!mapp(_weekly_stats->helper[name]->items_approved)) {
      _weekly_stats->helper[name]->items_approved = ([ ]);
   }
   _weekly_stats->helper[name]->items_approved[str]++;
}
protected void inform_of_rejected_item(string name,
                            class approval_obs approve) {
   if (!_weekly_stats) {
      _weekly_stats = new(class weekly_stats);
      _weekly_stats->items = ([ ]);
      _weekly_stats->helper = ([ ]);
   }
   name = this_player()->query_name();
   if (!_weekly_stats->helper[name]) {
      _weekly_stats->helper[name] = new(class helper_stats);
   }
   _weekly_stats->helper[name]->num_rejected++;
}
protected void confirm_approval(string answer,
                                class approval_obs approve,
                                int final_cost) {
   int pos;
   int i;
   int bing;
   int cost;
   object *obs;
   object *bought;
   object *checkout;
   string place;
   if (strlen(answer) < 1 || lower_case(answer)[0] != 'y') {
      write("Ok, canceled the approval of the item.\n");
      return ;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   obs = ({ });
   checkout = ({ });
   for (i = 0; i < sizeof(approve->saved); i++) {
      pos = approve->saved[i];
      if (!approve->checkout[i]) {
         obs += ({ create_real_auto_load_object(pos, this_player()) });
      } else {
         checkout += ({ create_real_auto_load_object(pos, this_player()) });
      }
   }
   obs -= ({ 0 });
   checkout -= ({ 0 });
   if (sizeof(checkout)) {
      write("The items " + query_multiple_short(checkout) + " were "
            "checked out and therefore lost.\n");
   }
   if (!final_cost) {
      final_cost = ((approve->value * (100 + _automatic_percentage)) / 100);
   }
   final_cost -= final_cost % _round_value;
   obs->remove_property("dropped");
   bought = query_controller()->buy_objects(obs, approve->name,
                                   final_cost,
                                   approve->seller, approve->category, 1);
   if (sizeof(bought)) {
      cost = approve->value * (sizeof(obs) + sizeof(checkout));
      cost -= cost % _round_value;
      _total_outgoing += cost;
      remove_from_approval_list(approve);
      adjust_royalty(lower_case(approve->seller), cost);
      if (query_owners_money() > 0) {
         if (query_owners_money() > cost) {
            adjust_owners_money(-cost);
            cost = 0;
         } else {
            cost -= query_owners_money();
            adjust_owners_money(-query_owners_money());
         }
      }
      if (cost > 0) {
         if (this_player()->query_value_in(place) > 0) {
            bing = this_player()->query_value_in(place);
            if (bing > cost) {
               bing = cost;
               cost = 0;
            } else {
               cost -= bing;
            }
            if (bing) {
               this_player()->pay_money(MONEY_HAND->create_money_array(bing, place), place);
            }
         }
         if (cost > 0) {
            adjust_owners_money(-cost);
         }
      }
      write("You approve " + query_multiple_short(obs) + " to be sold as " +
            approve->name + " in " + approve->category + " for " +
            MONEY_HAND->money_value_string(approve->value, place) + ".\n");
      add_succeeded_mess( ({ "", "$N approves something in the shop.\n" }) );
      cost = approve->value * (sizeof(obs) + sizeof(checkout));
      cost -= cost % _round_value;
      inform_of_approved_item(this_player()->query_name(),
                              cost, approve);
      add_transaction(this_player()->query_name(),
                      obs,
                      PLAYER_CRAFT_SHOP_APPROVE,
                      approve->value * (sizeof(obs) + sizeof(checkout)),
                      approve->name + " in " + approve->category,
                      approve->seller);
   } else {
      write("Unable to move the items into the shops inventory, you "
            "will need to reject this item.\n");
   }
   return ;
}
int do_approve_reject(string name, string mess, int reject_pos) {
   object *obs;
   object *ok;
   object *here;
   object *checkout;
   object ob;
   object play;
   class approval_obs approve;
   int pos;
   int i;
   int ret;
   string ob_mess;
   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }
   if (lower_case(approve->seller) == this_player()->query_name()) {
      return do_return(name);
   }
   if (!is_allowed(this_player()->query_name()) &&
       !is_helper(this_player()->query_name())) {
      add_failed_mess("You're not allowed to reject items.\n");
      return 0;
   }
   if (sizeof(filter(approve->checkout, (: $1 :))) > 0 &&
       _something_checkedout) {
      return_all_checkedout_objects();
   }
   if (reject_pos != -1 &&
       (reject_pos <= 0 ||
       reject_pos > sizeof(approve->saved))) {
      add_failed_mess("You cannot reject the item of position " + reject_pos +
                      " since there are only " + sizeof(approve->saved) +
                      " items.\n");
      return 0;
   }
   if (reject_pos != -1) {
      reject_pos--;
   }
   obs = ({ });
   checkout = ({ });
   for (i = 0; i < sizeof(approve->saved); i++) {
      if (reject_pos == -1 ||
          reject_pos == i) {
         pos = approve->saved[i];
         if (!approve->checkout[i]) {
            obs += ({ create_real_auto_load_object(pos, this_player()) });
         } else {
            checkout += ({ create_real_auto_load_object(pos, this_player()) });
         }
      }
   }
   obs = filter(obs, (: $1 && objectp($1) :));
   checkout = filter(checkout, (: $1 && objectp($1) :));
   if (member_array(0, obs) != -1) {
      add_failed_mess("There seems to be a problem with this rejection set, "
                      "one of the items is 0.\n");
      return 0;
   }
   if (reject_pos != -1 && sizeof(checkout)) {
      add_failed_mess("The item $I has been checked out, you cannot reject "
                      "it.\n", checkout);
      return 0;
   }
   if (sizeof(checkout)) {
      write("The items " + query_multiple_short(checkout) + " were "
            "checked out and lost.\n");
      adjust_royalty(lower_case(approve->seller),
                     approve->value * sizeof(checkout));
      AUTO_MAILER->auto_mail(lower_case(approve->seller),
                            this_player()->query_name(),
                            "Rejected items", "",
                            sprintf("%-=75s",
                                   this_player()->query_name() + " lost your " +
                                   query_multiple_short(checkout, "the", 1) +
                                   ",so you have been paid but the items "
                                   "were not returned.\n"));
   }
   inform_of_rejected_item(this_player()->query_name(), approve);
   if (!sizeof(obs)) {
      write("Nothing to give back or send off.\n");
   } else {
      play = find_player(lower_case(approve->seller));
      if (play  &&  environment(play) == this_object()) {
         ok = ({ });
         here = ({ });
         foreach (ob in obs) {
            if (ob) {
               if (ob->move(play) == MOVE_OK) {
                  ok += ({ ob });
               } else if (ob->move(environment(play)) == MOVE_OK) {
                  here += ({ ob });
               }
            }
         }
         if (sizeof(ok)) {
            tell_object(play, "Your items: " +
                        query_multiple_short(obs) + " have been rejected "
                        "and placed in your inventory.\n");
         }
         if (sizeof(here)) {
            tell_object(play, "Your items: " +
                        query_multiple_short(obs) + " have been rejected "
                        "and placed on the floor here.\n");
         }
         write("You reject the item.\n");
      } else {
         if (!query_parcel_post()) {
            add_failed_mess("Eeek!  No parcel post defined on this room.\n");
            return 0;
         } else if(!load_object(query_parcel_post())) {
           add_failed_mess("Eeek!  Parcel post cannot be loaded.\n");
           return 0;
         }
         ob_mess = "The shop " + this_player()->convert_message(the_short()) +
                   " rejected " + query_multiple_short(obs, "the", 1) +
                   " because:\n";
         if (!mess) {
            mess = "They didn't want to add a reject message.";
         }
         ret = query_parcel_post()->deposit_parcel(obs, lower_case(approve->seller), 1);
         if (ret != 1) {
            if (ret == -5) {
               write("The player " + approve->seller + " has been denied use "
                     "of the parcel post system, tossing objects away.\n");
               obs->move("/room/rubbish");
               if (mess) {
                  write("Still sending the message to the person.\n");
                  mess += "\nYou were denied use of the parcel post system "
                          "so your objects were thrown away.\n";
               }
            } else if (ret == -4) {
               write("You have been denied use of the postal system, perhaps "
                     "you could try clearing this up with the creators?\n");
               obs->move("/room/rubbish");
               return 1;
            } else if (ret == -2) {
               write("The player " + approve->seller + " no longer exists, "
                     "tossing objects away.\n");
               obs->move("/room/rubbish");
            } else {
               add_failed_mess("Unable to send the parcel for some reason (" +
                            ret + ").\n");
                  obs->move("/room/rubbish");
               return 0;
            }
         }
         if (ret != -2) {
            if (mess) {
               AUTO_MAILER->auto_mail(approve->seller, this_player()->query_name(),
                               "Rejected items", "",
                               ob_mess + mess);
            } else {
               write("You reject the item and it is parcel posted back to the "
                  "person who "
                  "sent it.\nWould you like to send them a note about it as well? ");
               obs -= ({ 0 });
               input_to("check_reject_note", 0, ob_mess,
                        approve->seller);
            }
         }
      }
   }
   if (reject_pos != -1) {
      approve->saved = approve->saved[0..reject_pos-1] + approve->saved[reject_pos+1..];
      event_save(this_object());
      if (!sizeof(approve->saved)) {
         reject_pos = -1;
      }
   }
   if (reject_pos == -1) {
      remove_from_approval_list(approve);
   }
   add_succeeded_mess(({ "", "$N reject$s a sellable object.\n" }));
   return 1;
}
void check_reject_note(string str, string ob_str, string name) {
   str = lower_case(str);
   if (!strlen(str) ||
       (str[0] != 'y' &&
        str[0] != 'n')) {
      write("Please answer yes or no.\nWould you like to send them "
            "a note about it as well?");
      input_to("check_reject_note", 0, ob_str, name);
      return ;
   }
   if (str[0] == 'n') {
      write("ok, bye then!\n");
      return ;
   }
   this_player()->do_edit("Your items " + ob_str + " were rejected "
                         "from " + the_short() + ".\n\n",
                         "send_reject_note", this_object(), 0, name);
}
void send_reject_note(string mess, string name) {
   if (!mess) {
      write("Aborted.\n");
      return ;
   }
   AUTO_MAILER->auto_mail(name, this_player()->query_name(),
                            "Rejected items", "", mess);
}
int do_approve_browse(string name) {
   object *obs;
   object ob;
   string read;
   string ret;
   string bits;
   class approval_obs approve;
   int pos;
   string place;
   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }
   if (lower_case(approve->seller) == this_player()->query_name()) {
      return do_return(name);
   }
   if (!is_allowed(this_player()->query_name()) &&
       !is_helper(this_player()->query_name())) {
      add_failed_mess("You are not allowed to reject items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   obs = ({ });
   foreach (pos in approve->saved) {
      obs += ({ create_real_auto_load_object(pos, this_player()) });
   }
   obs -= ({ 0 });
   ret = "";
   foreach (ob in obs) {
      ret += ob->the_short() + ": (Base cost " +
             MONEY_HAND->money_value_string(ob->query_base_value(), place) +
             "; scaled cost " +
             MONEY_HAND->money_value_string(ob->query_value(), place) +
             ")\n" + ob->long();
      read = ob->query_readable_message();
      if (read) {
         bits = ob->query_read_short(this_player());
         if (!bits) {
            bits = "$name$";
         }
         ret += "You read " +
                 replace_string(ob->query_read_short(this_player()), "$name$",
                         ob->a_short()) + ":\n" +
                 ob->query_readable_message();
      }
   }
   obs->move("/room/rubbish");
   write("$P$Browse list$P$" + ret);
   add_succeeded_mess("$N browse$s an item waiting for approval.\n");
   return 1;
}
int do_approve_checkout(string name) {
   object *obs;
   object *bad;
   object *checkout;
   object ob;
   class approval_obs approve;
   int pos;
   int i;
   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }
   if (lower_case(approve->seller) == this_player()->query_name() &&
       lower_case(approve->seller) != "pinkfish") {
      return do_return(name);
   }
   if (!is_allowed(this_player()->query_name()) &&
       !is_helper(this_player()->query_name())) {
      add_failed_mess("You are not allowed to reject items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   obs = ({ });
   checkout = ({ });
   for (i = 0; i < sizeof(approve->saved); i++) {
      pos = approve->saved[i];
      if (!approve->checkout[i]) {
         ob = create_checkout_object(approve, pos, this_player());
         if (!ob) {
            write("Unable to create " + pos + approve->name + ", weird...\n");
         } else {
            obs += ({ ob });
         }
      } else {
         checkout += ({ create_checkout_object(approve, pos, this_player()) });
      }
   }
   checkout->move("/room/rubbish");
   if (!sizeof(obs) &&
       sizeof(checkout)) {
      if (sizeof(checkout) > 0) {
         add_failed_mess("$I are already checked out.\n", checkout);
      } else {
         add_failed_mess("$I is already checked out.\n", checkout);
      }
      return 0;
   }
   bad = ({ });
   foreach (ob in obs) {
      if (ob->move(this_player()) != MOVE_OK) {
         bad += ({ ob });
         destroy_checkout_object(ob);
      }
   }
   if (sizeof(bad)) {
      write("Unable to move " + query_multiple_short(bad) + " into your "
            "inventory for you to check.\n");
   }
   obs -= bad;
   if (sizeof(obs)) {
      write("Moved " + query_multiple_short(obs) + " into your inventory "
            "for you to check.\n");
      add_succeeded_mess("$N check$s out $I.\n", obs);
   }
   return 1;
}
int do_approve_checkin(object* obs) {
   object ob;
   object* ok;
   ok = ({ });
   foreach (ob in obs) {
      if (is_checkout_object(ob)) {
         destroy_checkout_object(ob);
         ok += ({ ob });
      }
   }
   if (!sizeof(ok)) {
      add_failed_mess("None of $I have been checked out.\n", obs);
      return 0;
   }
   add_succeeded_mess("$N check$s $I back in.\n", ok);
   return 1;
}
int do_approve_name_change(string name, string new_name) {
   class approval_obs approve;
   if (!is_allowed(this_player()->query_name()) &&
       !is_helper(this_player()->query_name())) {
      add_failed_mess("You are not allowed to approve items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   approve = query_approval_class(name);
   if (!approve)  return 0;
   write("You change the name of the item waiting to be approved from " +
         approve->name + " to " + new_name + ".\n");
   approve->name = new_name;
   add_succeeded_mess( ({ "", "$N messes with the approval items.\n" }));
   event_save(this_object());
   return 1;
}
int do_approve_category_change(string name, string new_category) {
   class approval_obs approve;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to approve items.\n");
      return 0;
   }
   approve = query_approval_class(name);
   if (!approve) {
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   new_category = query_real_category_name(new_category);
   if (!new_category ||
       !query_controller()->is_valid_category(new_category)) {
      add_failed_mess("You must choose a category that exists.\n");
      return 0;
   }
   approve->category = new_category;
   add_succeeded_mess(({
      "You change the category of the approval item " + name + ".\n",
      "$N messes with the approval items.\n" }));
   event_save(this_object());
   return 1;
}
int do_approve_auto_low(string cost) {
   string place;
   int value;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   value = value_from_string(cost, place);
   _automatic_approval->low_cost = value;
   event_save(this_object());
   if (!value) {
      add_succeeded_mess(({ "You disable the automatic acception of items of "
                            "low value.\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "costing less than " +
                         MONEY_HAND->money_value_string(value, place) + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_high(string cost) {
   string place;
   int value;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   value = value_from_string(cost, place);
   if (!value) {
      _automatic_approval->high_cost = value;
      add_succeeded_mess(({ "You disable the automatic placing items into the "
                            "approve list of items of high value.\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   _automatic_approval->high_cost = value;
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically put any item "
                         "costing more than " +
                         MONEY_HAND->money_value_string(value, place) +
                         " into the approve list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_high_deny(string cost) {
   string place;
   int value;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   value = value_from_string(cost, place);
   if (!value) {
      _automatic_approval->high_cost_deny = 0;
      add_succeeded_mess(({ "You disable the automatic denying of items of "
                            "high value.\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   _automatic_approval->high_cost_deny = value;
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically deny any item "
                         "costing more than " +
                         MONEY_HAND->money_value_string(value, place) + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_item_add(string item, string money, string list_name,
                             int markup, string money_str) {
   int value;
   string place;
   int final_cost;
   mixed app_item;
   class approval_item new_app_item;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   value = value_from_string(money, place);
   if (!value) {
      add_failed_mess("The value " + money + " is invalid.\n");
      return 0;
   }
   if (markup < 0) {
      markup = 0;
   }
   item = strip_quotes(item);
   list_name = strip_quotes(list_name);
   if (classp(_automatic_approval->items[item])) {
      app_item = ((class approval_item)_automatic_approval->items[item])->value;
   } else {
      app_item = _automatic_approval->items[item];
   }
   if (app_item == value) {
      add_failed_mess("The item " + item + " already has a cut off "
                      "value of " +
                      MONEY_HAND->money_value_string(value, place) + ".\n");
      return 0;
   }
   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }
   new_app_item = new(class approval_item);
   new_app_item->list_name = list_name;
   new_app_item->value = value;
   new_app_item->markup = markup;
   new_app_item->final_cost = final_cost;
   _automatic_approval->items[item] = new_app_item;
   place = query_property("place");
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "with a short of " + item + " up to a cost "
                         "of " + MONEY_HAND->money_value_string(value, place) +
                         (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_item_add_object(object *obs, string money,
                                    string list_name, int markup,
                                    string money_str) {
   int value;
   string place;
   object ob;
   string name;
   object *ok;
   object *bad;
   mixed item;
   class approval_item new_item;
   int final_cost;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   value = value_from_string(money, place);
   if (!value) {
      add_failed_mess("The value " + money + " is invalid.\n");
      return 0;
   }
   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }
   if (markup < 0) {
      markup = 0;
   }
   bad = ({ });
   ok = ({ });
   list_name = strip_quotes(list_name);
   foreach (ob in obs) {
      name = ob->query_short();
      if (classp(_automatic_approval->items[name])) {
         item = ((class approval_item)_automatic_approval->items[name])->value;
      } else {
         item = _automatic_approval->items[name];
      }
      if (item == value) {
         bad += ({ name });
      } else {
         new_item = new(class approval_item);
         new_item->value = value;
         new_item->list_name = list_name;
         new_item->markup = markup;
         new_item->final_cost = final_cost;
         _automatic_approval->items[name] = new_item;
         ok += ({ name });
      }
   }
   event_save(this_object());
   if (sizeof(ok)) {
      add_succeeded_mess(({ "You set the shop to automatically accept any of "
                         "$I up to a cost "
                         "of " + MONEY_HAND->money_value_string(value, place) +
                         (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }), ok );
      return 1;
   } else {
      add_failed_mess("You cannot set $I to a value limit of " +
                      MONEY_HAND->money_value_string(value, place) +
                      " since it already has this limit.\n");
      return 0;
   }
}
int do_approve_auto_item_add_expr(string item, string expr,
                                  string list_name, int markup,
                                  string money_str) {
   class approval_item new_app_item;
   class parse_node* value;
   string place;
   int final_cost;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   value = parse_money_string(expr);
   if (!sizeof(value)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   }
   if (money_str) {
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }
   if (markup < 0) {
      markup = 0;
   }
   item = strip_quotes(item);
   list_name = strip_quotes(list_name);
   new_app_item = new(class approval_item);
   new_app_item->list_name = list_name;
   new_app_item->value = value;
   new_app_item->markup = markup;
   new_app_item->final_cost = final_cost;
   _automatic_approval->items[item] = new_app_item;
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "with a short of " + item + " with an expression "
                         "of " + query_expression_string(value, 1) +
                         (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_item_add_object_expr(object *obs, string expr,
                          string list_name, int markup, string money_str) {
   class parse_node* value;
   object ob;
   string name;
   class approval_item new_item;
   int final_cost;
   string place;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   value = parse_money_string(expr);
   if (!sizeof(value)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   }
   if (money_str) {
      place = query_property("place");
      final_cost = MONEY_HAND->value_from_string(money_str, place);
      if (!final_cost) {
         add_failed_mess(money_str + " is an invalid money value.\n");
         return 0;
      }
   }
   if (markup < 0) {
      markup = 0;
   }
   list_name = strip_quotes(list_name);
   foreach (ob in obs) {
      name = ob->query_short();
      new_item = new(class approval_item);
      new_item->value = value;
      new_item->list_name = list_name;
      new_item->markup = markup;
      new_item->final_cost = final_cost;
      _automatic_approval->items[name] = new_item;
   }
   event_save(this_object());
   add_succeeded_mess(({ "You set the shop to automatically accept any of "
                      "$I with an expression "
                      "of " + query_expression_string(value, 1) +
                      (list_name ? " as \"" + list_name + "\"" : "") +
                         (markup ? " with a markup of " + markup + "%" : "") +
                         (final_cost ? " with a final cost of " +
                           MONEY_HAND->money_value_string(final_cost, place) + "" : "") +
                         ".\n",
                       "$N fiddle$s with something in the shop.\n" }), obs );
   return 1;
}
int do_approve_auto_item_test(object* obs) {
   object ob;
   string place;
   mixed cost;
   int found;
   int allowed;
   class expression_type stuff;
   class parse_node frog;
   allowed = is_allowed(this_player()->query_name()) ||
             is_helper(this_player()->query_name());
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   foreach (ob in obs) {
      found = 0;
      cost = _automatic_approval->items[ob->query_short()];
      if (classp(cost)) {
         cost = ((class approval_item)cost)->value;
      }
      if (cost) {
         if (pointerp(cost)) {
            frog = evaluate_expression(cost, this_player()->query_name(),
                                        0, ({ ob }), 0, 0);
            if (allowed) {
               write("$I$5=The item " + ob->the_short() + " can be sold if it "
                 "costs less than " +
                  query_expression_string(cost, 1) +
                  ";\n" + ob->query_short() + " - " +
                  MONEY_HAND->money_value_string(frog->value, place) +
                  ".\n");
            } else {
               write("$I$5=The item " + ob->the_short() + " can be sold if it "
                 "costs less than " +
                  " " + MONEY_HAND->money_value_string(frog->value, place) +
                  ".\n");
            }
         } else {
            write("$I$5=The item " + ob->the_short() + " can be sold if it "
              "costs less than " +
               MONEY_HAND->money_value_string(cost, place) +
               " (" + ob->query_short() + ").\n");
         }
         found |= 1;
      }
      foreach (stuff in _automatic_approval->expressions) {
         frog = evaluate_expression(stuff->condition,
                                    this_player()->query_name(),
                                    0, ({ ob }), 0, 0);
         if (frog->value) {
            if (stuff->type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
               frog = evaluate_expression(stuff->value,
                                      this_player()->query_name(),
                                      0, ({ ob }), 0, 0);
               if (allowed) {
                  write("$I$5=The item " + ob->the_short() +
                        " can be sold if it "
                        "costs less than " +
                        query_expression_string(stuff->value, 1) +
                        ";\n" + ob->query_short() + " - " +
                        MONEY_HAND->money_value_string(frog->value, place) +
                        ".\n");
               } else {
                  write("$I$5=The item " + ob->the_short() +
                        " can be sold if it "
                        "costs less than " +
                        MONEY_HAND->money_value_string(frog->value, place) +
                        ".\n");
               }
               found |= 2;
            } else {
               found |= 4;
            }
         }
      }
      if (found & 4)  {
         write("$I$5=The item " + ob->the_short() + " will be denied sale.\n");
      }
      else if (!found) {
         write("$I$5=The item " + ob->the_short() + " will not be "
               "automatically accepted.\n");
      }
   }
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_item_remove(string item) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   item = strip_quotes(item);
   if (!_automatic_approval->items[item]) {
      add_failed_mess("The item " + item + " is not in the list.\n");
      return 0;
   }
   map_delete(_automatic_approval->items, item);
   event_save(this_object());
   add_succeeded_mess(({ "You remove the item " + item +
                         " from the list of automatically accepted items.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_auto_item_remove_object(object *obs) {
   object ob;
   object *bad;
   object *ok;
   string name;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   ok = ({ });
   bad = ({ });
   foreach (ob in obs) {
      name = ob->query_short();
      if (!_automatic_approval->items[name]) {
         bad += ({ ob });
      } else {
         ok += ({ ob });
         map_delete(_automatic_approval->items, name);
      }
   }
   event_save(this_object());
   if (sizeof(ok)) {
      add_succeeded_mess(({ "You remove $I from the list of "
                            "automatically accepted items.\n",
                         "$N fiddle$s with something in the shop.\n" }), ok );
      return 1;
   }
   add_failed_mess("None of $I are in the shops allow item list for you "
                   "to remove.\n", bad);
   return 0;
}
int do_approve_auto_expression_add(string expression, string value_str,
                                   int type, string list_name) {
   class parse_node* expr;
   class parse_node* value;
   class expression_type bing;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   expr = parse_boolean_string(expression);
   if (!sizeof(expr)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   }
   if (type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
      value = parse_money_string(value_str);
      if (!sizeof(value)) {
         add_failed_mess(query_last_expression_error() + ".\n");
         return 0;
      }
   }
   list_name = strip_quotes(list_name);
   bing = new(class expression_type);
   bing->type = type;
   bing->condition = expr;
   bing->value = value;
   bing->list_name = list_name;
   _automatic_approval->expressions += ({ bing });
   event_save(this_object());
   if (type == PLAYER_CRAFT_SHOP_EXPR_ACCEPT) {
      add_succeeded_mess(({ "You set the shop to automatically accept any item "
                         "matching the expression " +
                         query_expression_string(expr, 0) + " with a cost "
                         "of " + query_expression_string(value, 0) +
                         " as '" + list_name + "'.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   } else {
      add_succeeded_mess(({ "You set the shop to automatically deny any item "
                         "matching the expression " +
                         query_expression_string(expr, 0) + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   }
   return 1;
}
int do_approve_auto_expression_remove(string idstr) {
   class expression_type expr;
   int id;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   id = query_number_value(idstr);
   if (id == -1 || id >= sizeof(_automatic_approval->expressions)) {
      add_failed_mess("The id " + idstr + " is invalid.\n");
      return 0;
   }
   expr = _automatic_approval->expressions[id];
   _automatic_approval->expressions = _automatic_approval->expressions[0..id - 1] +
                                      _automatic_approval->expressions[id + 1..];
   event_save(this_object());
   add_succeeded_mess(({ "You remove the expression " +
                         query_expression_string(expr->condition, 1) +
                         " cost: " +
                         query_expression_string(expr->value, 1) +
                         " from the list of allowed expressions.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_percentage(mixed num) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set automatic approval items.\n");
      return 0;
   }
   if (query_owners_money() < 0) {
      add_failed_mess("You cannot do this until the shop's deficit is payed "
                      "off.\n");
      return 0;
   }
   if (num <= 0) {
      add_failed_mess("The percentage to add must be greator than 0.\n");
      return 0;
   }
   _automatic_percentage = num;
   add_succeeded_mess(({ "You set the percentage to add to the sale price "
                         "to " + _automatic_percentage + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_limit(string limit) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }
   if (limit == "disable")  {
      _automatic_approval->num_allowed = 0;
      add_succeeded_mess(({ "You disable the default number of sold items "
                         "per person.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   else if (to_int(limit) > 0)  {
      _automatic_approval->num_allowed = to_int(limit);
      add_succeeded_mess(({ "You set the default number of sold items per "
                            "person to " + _automatic_approval->num_allowed + ".\n",
                            "$N fiddle$s with something in the shop.\n" }) );
      return 1;
   }
   return 0;
}
int do_approve_limit_person_items(string name, string value) {
   int amt;
   class seller_information info;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }
   name = lower_case(name);
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("The person " + name + " does not exist.\n");
      return 0;
   }
   amt = to_int(value);
   info = _sellers[name];
   if (!info) {
      info = new(class seller_information);
   }
   info->max_sellable = amt;
   if (info->value_limit || info->max_sellable || info->deny_value_limit) {
      _sellers[name] = info;
   } else {
      map_delete(_sellers, name);
   }
   if (amt)
      add_succeeded_mess(({ "You set the maximum number of items sellable by " +
                            name + " to " + info->max_sellable + ".\n",
                            "$N fiddle$s with something in the shop.\n" }) );
   else
      add_succeeded_mess(({ "You remove the limit for the maximum number of "
         "items sellable by " + name + ".\n",
         "$N fiddle$s with something in the shop.\n" }));
   return 1;
}
int do_approve_limit_person_value(string name, string money) {
   class seller_information info;
   int value;
   string place;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }
   name = lower_case(name);
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("The person " + name + " does not exist.\n");
      return -1;
   }
   money = lower_case(money);
   if (money == "disable" || money == "0") {
      value = 0;
   } else {
      place = query_property("place");
      if (!place) {
         place = "default";
      }
      value = value_from_string(money, place);
      if (!value) {
         add_failed_mess("The value " + value + " is invalid, please use "
                         "'disable' to disable this feature for the person.\n");
         return 0;
      }
   }
   info = _sellers[name];
   if (!info) {
      info = new(class seller_information);
   }
   info->value_limit = value;
   if (info->value_limit || info->max_sellable || info->deny_value_limit) {
      _sellers[name] = info;
   } else {
      map_delete(_sellers, name);
   }
   if (value) {
      add_succeeded_mess(({ "You set the maximum cost of items automatically "
                            "approved by " +
                         name + " to " +
                         MONEY_HAND->money_value_string(info->value_limit, place) +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   } else {
      add_succeeded_mess(({ "You disable the maximum cost of items "
                         "automatically approved by " +
                         name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   }
   return 1;
}
int do_approve_limit_person_value_deny(string name, string money) {
   class seller_information info;
   int value;
   string place;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set any limits on selling "
                      "items.\n");
      return 0;
   }
   name = lower_case(name);
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("The person " + name + " does not exist.\n");
      return -1;
   }
   money = lower_case(money);
   if (money == "disable" || money == "0") {
      value = 0;
   } else {
      place = query_property("place");
      if (!place) {
         place = "default";
      }
      value = value_from_string(money, place);
      if (!value) {
         add_failed_mess("The value " + value + " is invalid, please use "
                         "'disable' to disable this feature for the person.\n");
         return 0;
      }
   }
   info = _sellers[name];
   if (!info) {
      info = new(class seller_information);
   }
   info->deny_value_limit = value;
   if (info->deny_value_limit || info->max_sellable || info->value_limit) {
      _sellers[name] = info;
   } else {
      map_delete(_sellers, name);
   }
   if (value) {
      add_succeeded_mess(({ "You set the maximum cost of items accepted by " +
                         name + " to " +
                         MONEY_HAND->money_value_string(info->deny_value_limit, place) +
                         ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   } else {
      add_succeeded_mess(({ "You disable the maximum cost of items to be sold by " +
                         name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   }
   return 1;
}
int do_approve_limit_person_remove(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove limits "
                      "off someone.\n");
      return 0;
   }
   name = lower_case(name);
   if (!_sellers[name]) {
      add_failed_mess("The person " + name + " does not have any limits placed "
                      "on them.\n");
      return 0;
   }
   map_delete(_sellers, name);
   event_save(this_object());
   add_succeeded_mess(({ "You remove any limits set on " + name + ".\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
string query_main_status(int hint) {
   string ret;
   string place;
   string name;
   class seller_information stuff;
   string *bits;
   if (!is_allowed(this_player()->query_name()) &&
       !is_helper(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   ret = "$I$0=" + the_short() + "\n";
   ret += "$I$6=   The current percentage to automatically add to the buy price is: " +
          _automatic_percentage + "%\n";
   if (hint) {
      ret += "$I$0=       Hint: markup <percent>\n";
   }
   ret += "$I$6=   Limits on what can be sold.\n";
   ret += "$I$6=   Maximum number of items allowed in the shop : ";
   if (query_maximum_inventory_size()) {
      ret += query_maximum_inventory_size() + " currently " +
             sizeof(query_controller()->query_sell_list_obs()) + " (fixed).\n";
   } else {
      ret += "disabled (fixed).\n";
   }
   ret += "$I$6=   Maximum number of items allowed per player  : ";
   if (_automatic_approval->num_allowed) {
      ret += _automatic_approval->num_allowed + ".\n";
   } else {
      ret += "disabled.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: set max number <number|disable>\n";
   }
   ret += "$I$6=   Automatically queue sales more than         : ";
   if (_automatic_approval->high_cost) {
      ret += MONEY_HAND->money_value_string(_automatic_approval->high_cost, place) +
             ".\n";
   } else {
      ret += "disabled.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: set high queue cost <cost|disable>\n";
   }
   ret += "$I$6=   Automatically deny sales more than          : ";
   if (_automatic_approval->high_cost_deny) {
      ret += MONEY_HAND->money_value_string(_automatic_approval->high_cost_deny, place) +
             ".\n";
   } else {
      ret += "disabled.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: set high deny cost <cost|disable>\n";
   }
   ret += "$I$6=   Helpers     : ";
   if (sizeof(_helpers)) {
      ret += query_multiple_short(_helpers) + "\n";
   } else {
      ret += "None at all.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: helper add <name>\n";
      ret += "$I$0=       Hint: helper remove <name>\n";
      ret += "$I$0=       Hint: helper list\n";
   }
   if (sizeof(_sellers)) {
      ret += "$I$6=   Limits set per player.\n";
      ret += sprintf("   %-15s %-15s %-20s %s\n", "Name", "Max Sellable",
                     "Approve Limit", "Deny limit (per item)");
      bits = sort_array(keys(_sellers), 0);
      foreach (name in bits) {
         stuff = _sellers[name];
         ret += sprintf("   %-15s %-15s %-20s %s\n", name,
                    (stuff->max_sellable?stuff->max_sellable+"":"disabled"),
                    (stuff->value_limit?MONEY_HAND->money_value_string(stuff->value_limit, place):"disabled"),
                    (stuff->deny_value_limit?MONEY_HAND->money_value_string(stuff->deny_value_limit, place):"disabled"));
      }
   } else {
      ret += "$I$6=   No limits set per player.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: set max number <max sellable|disable> for <player>\n";
      ret += "$I$0=       Hint: set high queue cost <cost|disable> for <player>\n";
      ret += "$I$0=       Hint: set high deny cost <cost|disable> for <player> to <cost|disable>\n";
   }
   ret += "\n$I$6=   Automatically approve sales less than       : ";
   if (_automatic_approval->low_cost) {
      ret += MONEY_HAND->money_value_string(_automatic_approval->low_cost, place) +
             ".\n";
   } else {
      ret += "disabled.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: set low approve cost <cost|disable>\n";
   }
   ret += "$I$0=Use 'expressions' to see the expressions.\n";
   ret += "$I$0=Use 'functions shop' to see the user defined "
          "functions.\n";
   return ret;
}
string query_expression_status(int hint) {
   string ret;
   string place;
   mixed expr;
   string str;
   int pos;
   class expression_type bing;
   class expression_type binger;
   class approval_item approval;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   ret = "";
   if (sizeof(_automatic_approval->items)) {
      ret += "$I$0=%^BOLD%^Automatically accept sales of items%^RESET%^\n";
      foreach (str, expr in _automatic_approval->items) {
         if (classp(expr)) {
            approval = (class approval_item)expr;
            expr = ((class approval_item)expr)->value;
         } else {
            approval = new(class approval_item);
         }
         if (pointerp(expr) && intp(expr[0])) {
            map_delete(_automatic_approval->items, str);
         } else {
            ret += sprintf("$I$10=   %-20s", "* " + str);
            if (sizeof(approval) == 3) {
               approval = new(class approval_item,
                      markup : approval->markup,
                      value : approval->value,
                      list_name : approval->list_name,
                      final_cost : 0);
            }
            if (approval->list_name) {
               ret += " listed as '" + approval->list_name + "'";
            }
            if (approval->markup) {
               ret += " markup of " + approval->markup;
            }
            if (approval->final_cost) {
               ret += " final cost of " +
               MONEY_HAND->money_value_string(approval->final_cost, place);
            }
            ret += " max value:";
            if (pointerp(expr)) {
               str = query_expression_string(expr, 0);
               if (strsrch(str, "\n") != -1) {
                  ret += "\n" + str;
               } else {
                  ret += str;
               }
            } else {
               ret += MONEY_HAND->money_value_string(expr, place);
            }
            ret += "\n";
         }
      }
   } else {
      ret += "Automatically accept sales of               : (none setup)\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: auto add name <name> up to <value>\n";
      ret += "$I$0=       Hint: auto add name <name> up to <value> as <list name>\n";
      ret += "$I$0=       Hint: auto add name <name> up to <value> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add name <name> up to <value> with value <final cost>\n";
      ret += "$I$0=       Hint: auto add name <name> up to <value> as <list name> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add name <name> up to <value> as <list name> with value <final cost>\n";
      ret += "$I$0=       Hint: auto add name <name> with <expression>\n";
      ret += "$I$0=       Hint: auto add name <name> with <expression> as <list name>\n";
      ret += "$I$0=       Hint: auto add name <name> with <expression> and markup <percentage>\n";
      ret += "$I$0=       Hint: auto add name <name> with <expression> and value <final cost>\n";
      ret += "$I$0=       Hint: auto add name <name> with <expression> as <list name> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add object <object> up to <value>\n";
      ret += "$I$0=       Hint: auto add object <object> up to <value> as <list name>\n";
      ret += "$I$0=       Hint: auto add object <object> up to <value> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add object <object> up to <value> with value <final cost>\n";
      ret += "$I$0=       Hint: auto add object <object> up to <value> as <list name> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add object <object> up to <value> as <list name> with value <final cost>\n";
      ret += "$I$0=       Hint: auto add item object <object> with <expression>\n";
      ret += "$I$0=       Hint: auto add item object <object> with <expression> as <list name>\n";
      ret += "$I$0=       Hint: auto add item object <object> with <expression> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add item object <object> with <expression> with value <final cost>\n";
      ret += "$I$0=       Hint: auto add item object <object> with <expression> as <list name> with markup <percentage>\n";
      ret += "$I$0=       Hint: auto add item object <object> with <expression> as <list name> with value <final cost>\n";
      ret += "$I$0=       Hint: auto remove name <name>\n";
      ret += "$I$0=       Hint: auto remove object <object>\n";
   }
   ret += "\n$I$0=%^BOLD%^Automatic approval expressions.%^RESET%^\n";
   if (sizeof(_automatic_approval->expressions)) {
      pos = 0;
      foreach (bing in _automatic_approval->expressions) {
         if (sizeof(bing) == 3) {
            binger = new(class expression_type);
            binger->type = bing->type;
            binger->condition = bing->condition;
            binger->value = bing->value;
            bing = binger;
            event_save(this_object());
         }
         if (bing->type != PLAYER_CRAFT_SHOP_EXPR_DENY) {
            str = query_expression_string(bing->value, 0);
            if (strsrch(str, "\n") != -1) {
               str = "\n" + str;
            }
            str = " accept value: " + str;
            if (bing->list_name) {
               str += " as " + bing->list_name;
            }
         } else {
            str = " -- deny item";
         }
         ret += "$I$5=" + query_letter_value(pos) + ") " +
                query_expression_string(bing->condition, 0) + str + ".\n";
         pos++;
      }
   } else {
      ret += "$I$0=No automatic approval expressions setup.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: auto add approve expression <condition> cost <value> as <list name>\n";
      ret += "$I$0=       Hint: auto deny expression <expression>\n";
      ret += "$I$0=       Hint: auto remove expression <id>\n";
   }
   ret += "\n$I$0=";
   ret += "$I$0=Use 'functions shop' to see the user defined "
          "functions.\n";
   return ret;
}
int do_main_status(int hint) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("Cannot do that!\n");
      return 0;
   }
   write("$P$Status$P$" + query_main_status(hint));
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_expression_status(int hint) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("Cannot do that!\n");
      return 0;
   }
   write("$P$Status$P$" + query_expression_status(hint));
   add_succeeded_mess(({ "",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_approve_pay_deficit() {
   int cost;
   string place;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to pay off the deficit for " +
                      the_short() + ".\n");
      return 0;
   }
   if (query_owners_money() >= 0) {
      add_failed_mess("There is no deficit here to pay off.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   cost = -query_owners_money();
   if (this_player()->query_value_in(place) >= cost) {
      adjust_royalty(query_owner(), cost);
      this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);
      add_succeeded_mess("$N pay$s off the deficit in " + the_short() + ".\n");
      return 1;
   }
   add_failed_mess("You do not have enough money to pay off the deficit "
                   "of " + MONEY_HAND->money_value_string(cost, place) +
                   ".\n");
   return 0;
}
int do_category_description(string category, string desc) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add categories.\n");
      return 0;
   }
   if (!query_controller()->is_valid_category(category)) {
      add_failed_mess("The category doesn't exists.\n");
      return 0;
   }
   set_category_description(category, desc);
   add_succeeded_mess("$N set$s the description of " + category + ".\n");
   return 1;
}
int do_category_information(string category, string desc) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add categories.\n");
      return 0;
   }
   if (!query_controller()->is_valid_category(category)) {
      add_failed_mess("The category doesn't exists.\n");
      return 0;
   }
   set_category_information(category, desc);
   add_succeeded_mess("$N set$s the description of " + category + ".\n");
   return 1;
}
int do_add_new_category(string category) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add categories.\n");
      return 0;
   }
   if (query_controller()->is_valid_category(category)) {
      add_failed_mess("The category already exists.\n");
      return 0;
   }
   add_shop_category(category);
   add_succeeded_mess("$N add$s a new category.\n");
   return 1;
}
int do_remove_category(string category) {
   object* obs;
   string old_cat;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove categories.\n");
      return 0;
   }
   old_cat = category;
   category = query_real_category_name(category);
   if (!category ||
       !query_controller()->is_valid_category(category)) {
      add_failed_mess("The category " + old_cat + " does not exist.\n");
      return 0;
   }
   if (category == query_default_category()) {
      add_failed_mess("You cannot remove the default category.\n");
      return 0;
   }
   obs = query_controller()->query_sell_list_obs();
   obs = filter(obs, (: query_controller()->query_category_of_shop_object($1)  == $2:), category );
   if (sizeof(obs)) {
      add_failed_mess("The category '" + category + "' is not empty "
                     "and cannot be removed.\n");
      return 0;
   }
   write("Do you wish to remove the category " + category + " from " +
         the_short() + " (y/n)?");
   input_to("check_remove_category", 0, category);
   add_succeeded_mess(({ "", "$N removes a category from the shop.\n" }));
   return 1;
}
int do_rename_category(string category, string new_category) {
   object* obs;
   object ob;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to rename categories.\n");
      return 0;
   }
   category = query_real_category_name(category);
   if (!category ||
       !query_controller()->is_valid_category(category)) {
      add_failed_mess("The category " + category + " does not exist.\n");
      return 0;
   }
   if (category == query_default_category()) {
      add_failed_mess("You cannot remove the default category.\n");
      return 0;
   }
   add_shop_category(new_category);
   obs = query_controller()->query_sell_list_obs();
   obs = filter(obs, (: query_controller()->query_category_of_shop_object($1)  == $2:), category );
   if (sizeof(obs)) {
      foreach (ob in obs) {
         query_controller()->change_category_of_shop_object(ob, new_category);
      }
   }
   remove_shop_category(category);
   add_succeeded_mess("$N rename$s category " + category + " to " +
                      new_category + ".\n");
   return 1;
}
protected void check_remove_category(string answer, string category) {
   class approval_obs approve;
   if (!strlen(answer) ||
       lower_case(answer)[0] != 'y') {
      write("Aborting deleting the category " + category + ".\n");
      return ;
   }
   remove_shop_category(category);
   write("Removed the shop category " + category + ".\n");
   foreach (approve in query_approval_list(0)) {
      if (approve->category == category) {
         approve->category = query_default_category();
      }
   }
   foreach (approve in query_approval_list(1)) {
      if (approve->category == category) {
         approve->category = query_default_category();
      }
   }
   event_save(this_object());
   return ;
}
int do_set_default_category(string default_cat) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to set the default category.\n");
      return 0;
   }
   default_cat = query_real_category_name(default_cat);
   if (!default_cat ||
       !query_controller()->is_valid_category(default_cat)) {
      add_failed_mess("The category " + default_cat + " does not exist.\n");
      return 0;
   }
   set_default_category(default_cat);
   add_succeeded_mess("$N set$s the default category for " + the_short() +
                      ".\n");
   event_save(this_object());
   return 1;
}
int do_list_categories() {
   string cat;
   string ret;
   ret = "";
   foreach (cat in query_controller()->query_categories()) {
      if (cat == query_default_category()) {
         ret += cat + " (default)\n";
      } else {
         ret += cat + "\n";
      }
   }
   write("$P$Category list$P$The current categories are:\n" + ret);
   add_succeeded_mess(({ "", "$N browses the categories.\n" }));
   return 1;
}
int do_stats_items(int type) {
   class shop_stats stat;
   string ret;
   string *bits;
   string place;
   string name;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot read " + the_short() + "'s ledger.\n");
      return 0;
   }
   if (!sizeof(_sold_stats)) {
      add_failed_mess("Nothing has been sold in this transaction section "
                      "yet.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   switch (type) {
   case 1:
      bits = sort_array(keys(_sold_stats), (: _sold_stats[$1]->num_sold - _sold_stats[$2]->num_sold :));
      break;
   case 2:
      bits = sort_array(keys(_sold_stats), (: _sold_stats[$1]->value_sold - _sold_stats[$2]->value_sold :));
      break;
   case 3 :
      bits = sort_array(keys(_sold_stats), (: strcmp(((class shop_stats)_sold_stats[$1])->seller, ((class shop_stats)_sold_stats[$1])->seller) :));
      break;
   case 4 :
      bits = sort_array(keys(_sold_stats), (: strcmp(((class shop_stats)_sold_stats[$1])->name, ((class shop_stats)_sold_stats[$1])->name) :));
      break;
   default :
      bits = sort_array(keys(_sold_stats), 0);
      break;
   }
   ret = "Statistics for items sold since " + ctime(_stats_start) + ".\n";
   foreach (name in bits) {
      stat = _sold_stats[name];
      ret += name + ": " + stat->num_sold + " for " +
             MONEY_HAND->money_value_string(stat->value_sold, place) + ".\n";
   }
   write("$P$Sold stats$P$" + ret);
   add_succeeded_mess(({ "", "$N looks at the ledger.\n" }));
   return 1;
}
#if USE_TRANSACTIONS
int do_stats_transactions() {
   class shop_transaction bing;
   string ret;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot read " + the_short() + "'s ledger.\n");
      return 0;
   }
   ret = "Statistics for transactions since " + ctime(_stats_start) + ".\n";
   foreach (bing in _transactions) {
      ret += "$I$5=" + query_transaction_string(bing) + "\n";
   }
   write("$P$Sold stats$P$" + ret);
   add_succeeded_mess(({ "", "$N looks at the ledger.\n" }));
   return 1;
}
#endif
int do_stats_money() {
   string ret;
   int stock_value;
   string place;
   object ob;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot read " + the_short() + "'s ledger.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   ret = "";
   ret += "\nCurrent money spent " +
          MONEY_HAND->money_value_string(_total_outgoing, place) +
          " and money made " +
          MONEY_HAND->money_value_string(_total_ingoing, place) + ".\n";
   foreach (ob in query_controller()->query_sell_list_obs()) {
      stock_value += ob->query_value();
   }
   ret += "The current stock value is " +
             MONEY_HAND->money_value_string(stock_value, place) +
          ".\n";
   ret += "\n";
   if (query_owners_money() > 0) {
      ret += "The owner current has a cash float (royalties) of " +
             MONEY_HAND->money_value_string(query_owners_money(), place) +
             ".\n";
   } else if (query_owners_money() < 0) {
      ret += "The owner current has a cash deficit of " +
             MONEY_HAND->money_value_string(-query_owners_money(), place) +
             ".\n";
   }
   write(ret);
   add_succeeded_mess(({ "", "$N looks at the ledger.\n" }));
   return 1;
}
int do_helper_list() {
   write("$I$3=The current helpers are: " +
         query_multiple_short(_helpers) + ".\n");
   return 1;
}
int do_helper_add(string helper) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to mess with the helpers.\n");
      return 0;
   }
   helper = lower_case(helper);
   if (is_helper(helper)) {
      add_failed_mess(capitalize(helper) + " is already a helper.\n");
      return 0;
   }
   if (!PLAYER_HANDLER->test_user(helper)) {
      add_failed_mess(capitalize(helper) + " is not a player.\n");
      return 0;
   }
   _helpers += ({ helper });
   add_succeeded_mess("$N add$s " + capitalize(helper) +
                      " as a helper.\n");
   return 1;
}
int do_helper_remove(string helper) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to mess with the helpers.\n");
      return 0;
   }
   helper = lower_case(helper);
   if (!is_helper(helper)) {
      add_failed_mess(capitalize(helper) + " is not a helper to remove.\n");
      return 0;
   }
   _helpers -= ({ helper });
   add_succeeded_mess("$N remove$s " + capitalize(helper) +
                      " as a helper.\n");
   return 1;
}
private object* variable_objects(string seller, int cost, object* obs) {
   return obs;
}
private string variable_sale_name(string seller, int cost, object* ob, string name, string category) {
   if (name) {
      return lower_case(name);
   }
   return "";
}
private string variable_sale_category(string seller, int cost, object* ob, string name, string category) {
   if (category) {
      return lower_case(category);
   }
   return "";
}
private int variable_sale_cost(string seller, int cost, object* ob, string name, string category) {
   return cost;
}
void init() {
   expression_util::init();
   craft_shop_category::init();
   add_command("waiting", "", (: do_list_approval(1) :));
   add_command("waiting", "unapproved", (: do_list_approval(0) :));
   add_command("reject", "<string'id'>",
               (: do_approve_reject($4[0], 0, -1) :));
   add_command("retrieve", "<string'id'>", (: do_return($4[0]) :) );
   add_command("return", "<string'id'>", (: do_return($4[0]) :) );
   add_command("value", "<indirect:object>",
               (: do_approve_auto_item_test($1) :));
   if (!is_helper(this_player()->query_name())) {
      return ;
   }
   add_command("approve", "<string'id'>", (: do_approve_item($4[0], 0) :));
   add_command("approve", "<string'id'> for <string'value'>",
               (: do_approve_item($4[0], $4[1]) :));
   add_command("reject", "<string'id'> position <number>",
               (: do_approve_reject($4[0], 0, $4[1]) :));
   add_command("reject", "<string'id'> message <string'reject message'>",
               (: do_approve_reject($4[0], $4[1], -1) :));
   add_command("reject", "<string'id'> position <number> message <string'reject message'>",
               (: do_approve_reject($4[0], $4[2], $4[1]) :));
   add_command("browse", "waiting <string'id'>",
               (: do_approve_browse($4[0]) :));
   add_command("checkout", "<string'id'>",
               (: do_approve_checkout($4[0]) :));
   add_command("checkin", "<indirect:object:me-here>",
               (: do_approve_checkin($1) :));
   if (!is_allowed(this_player()->query_name())) {
      return ;
   }
   add_command("set", "low approve cost <string'cost|disable'>",
               (: do_approve_auto_low($4[0]) :));
   add_command("auto", "add approve expression <string'condition'> cost <string'value'> as <string'list name'>",
               (: do_approve_auto_expression_add($4[0], $4[1],
                            PLAYER_CRAFT_SHOP_EXPR_ACCEPT, $4[2]) :));
   add_command("auto", "add deny expression <string'condition'>",
               (: do_approve_auto_expression_add($4[0], 0,
                            PLAYER_CRAFT_SHOP_EXPR_DENY, 0) :));
   add_command("auto", "remove expression <string'id'>",
               (: do_approve_auto_expression_remove($4[0]) :));
   add_command("markup", "<number'percentage'>",
               (: do_approve_percentage($4[0]) :));
   add_command("auto", "add name <string'name'> up to <string'value'>",
               (: do_approve_auto_item_add($4[0], $4[1], 0, 0, 0) :));
   add_command("auto", "add name <string'name'> up to <string'value'> with value <string'final cost'>",
               (: do_approve_auto_item_add($4[0], $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add name <string'name'> up to <string'value'> with markup <number'percentage'>",
               (: do_approve_auto_item_add($4[0], $4[1], 0, $4[2], 0) :));
   add_command("auto", "add name <string'name'> up to <string'value'> as <string'list name'>",
               (: do_approve_auto_item_add($4[0], $4[1], $4[2], 0, 0) :));
   add_command("auto", "add name <string'name'> up to <string'value'> as <string'list name'> with value <string'final cost'>",
               (: do_approve_auto_item_add($4[0], $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "add name <string'name'> up to <string'value'> as <string'list name'> with markup <number'percentage'>",
               (: do_approve_auto_item_add($4[0], $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], 0, 0, 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], 0, $4[2], 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> and value <string'final cost'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add name <string'name'> with <string'expression'> as <string'list name'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], $4[2], 0, 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> as <string'list name'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add name <string'name'> with <string'expression'> as <string'list name'> and value <string'final cost'>",
               (: do_approve_auto_item_add_expr($4[0], $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "add object <indirect:object> up to <string'value'>",
               (: do_approve_auto_item_add_object($1, $4[1], 0, 0, 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> with markup <number'percentage'>",
               (: do_approve_auto_item_add_object($1, $4[1], 0, $4[2], 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> with value <string'final cost'>",
               (: do_approve_auto_item_add_object($1, $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> as <string'list name'>",
               (: do_approve_auto_item_add_object($1, $4[1], $4[2], 0, 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> as <string'list name'> with markup <number'percentage'>",
               (: do_approve_auto_item_add_object($1, $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add object <indirect:object> up to <string'value'> as <string'list name'> with value <string'final cost'>",
               (: do_approve_auto_item_add_object($1, $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "add object <indirect:object> with <string'expression'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], 0, 0, 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], 0, $4[2], 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> and value <string'final cost'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], 0, 0, $4[2]) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> as <string'list name'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], $4[2], 0, 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> as <string'list name'> and markup <number'percentage'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], $4[2], $4[3], 0) :));
   add_command("auto", "add object <indirect:object> with <string'expression'> as <string'list name'> and value <string'final cost'>",
               (: do_approve_auto_item_add_object_expr($1, $4[1], $4[2], 0, $4[3]) :));
   add_command("auto", "remove name <string'name'>",
               (: do_approve_auto_item_remove($4[0]) :));
   add_command("auto", "remove object <indirect:object>",
               (: do_approve_auto_item_remove_object($1) :));
   add_command("set", "high queue cost <string'cost|disable'>",
               (: do_approve_auto_high($4[0]) :));
   add_command("set", "high deny cost <string'cost|disable'>",
               (: do_approve_auto_high_deny($4[0]) :));
   add_command("set", "max number <string'max sellable|disable'>",
               (: do_approve_limit($4[0]) :));
   add_command("set", "max number <string'max sellable|disable'> for <string'player'>",
               (: do_approve_limit_person_items($4[1], $4[0]) :));
   add_command("set", "high queue cost <string'cost|disable'> for <string'player'>",
               (: do_approve_limit_person_value($4[1], $4[0]) :));
   add_command("set", "high deny cost <string'cost|disable'> for <string'player'>",
               (: do_approve_limit_person_value_deny($4[1], $4[0]) :));
   add_command("approve", "limit remove <string'player'>",
               (: do_approve_limit_person_remove($4[0]) :));
   add_command("expressions", "",
               (: do_expression_status(0) :));
   add_command("expressions", "hints",
               (: do_expression_status(1) :));
   add_command("pay", "deficit",
               (: do_approve_pay_deficit() :));
   add_command("stats", "items by name", (: do_stats_items(4) :));
   add_command("stats", "items by seller", (: do_stats_items(3) :));
   add_command("stats", "items by number", (: do_stats_items(1) :));
   add_command("stats", "items by value", (: do_stats_items(2) :));
#if USE_TRANSACTIONS
   add_command("stats", "transactions", (: do_stats_transactions() :));
#endif
   add_command("stats", "money", (: do_stats_money() :));
   add_command("status", "<direct:object>", (: do_main_status(0) :));
   add_command("status", "<direct:object> hints", (: do_main_status(1) :));
   add_command("check", "sell <indirect:object>",
                (: do_check_sell($1) :));
   add_command("category", "list", (: do_list_categories() :));
   add_command("category", "default <string'category'>",
               (: do_set_default_category($4[0]) :));
   add_command("category", "add <string'category'>",
               (: do_add_new_category($4[0]) :));
   add_command("category", "description <string'category'> <string:quoted'description'>",
               (: do_category_description($4[0], $4[1]) :));
   add_command("category", "description <string'category'> remove",
               (: do_category_description($4[0], 0) :));
   add_command("category", "information <string'category'> <string:quoted'information'>",
               (: do_category_information($4[0], $4[1]) :));
   add_command("category", "information <string'category'> remove",
               (: do_category_information($4[0], 0) :));
   add_command("category", "remove <string'category'>",
               (: do_remove_category($4[0]) :));
   add_command("category", "rename <string'category'> to <string'category'>",
               (: do_rename_category($4[0], $4[1]) :));
   add_command("helper", "list",
               (: do_helper_list() :));
   add_command("helper", "add <string'helper'>",
               (: do_helper_add($4[0]) :));
   add_command("helper", "remove <string'helper'>",
               (: do_helper_remove($4[0]) :));
   add_command("buy", "force <indirect:object:" +
                      file_name(query_controller()->query_sell_list()) + ">",
                (: do_buy($1, 1) :));
}

==================================================
FILE: shops/inherit/pub.c
==================================================

#include <shops/pub_shop.h>
#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <map.h>
inherit "/std/shops/inherit/open_shop";
inherit "/std/shops/inherit/shop_event";
void add_hidden_object(object ob);
private mapping _menu_items;
private mapping _menu_aliases;
private string _menu_header;
private string _language;
private int _display_header;
private string *_menu_subheadings;
private int _display_subheadings;
private int no_standard_alias;
private object _menu_object;
private object _counter;
void add_menu_alias( mixed alias, string actual );
string *calc_standard_aliases( string *aliases );
int do_buy( object *obs, string dir, string indir, mixed *args );
float query_discount( object ob );
object make_counter();
void create() {
   shop_event::create();
   _menu_items = ([ ]);
   _menu_aliases = ([ ]);
   _menu_header = "The menu reads:";
   _display_header = 1;
   _menu_subheadings = ({ "Appetisers", "Main Courses", "Desserts",
                         "Alcoholic Beverages", "Soft Drinks",
                         "Hot Drinks" });
   _display_subheadings = 1;
   if( base_name( this_object() ) + ".c" != __FILE__ ) {
      _menu_object = clone_object( PUB_MENU_FILE );
      _menu_object->set_pub( this_object() );
      add_hidden_object( _menu_object );
      _counter = make_counter();
   }
}
void init() {
   this_player()->add_command( "buy", this_object(), "<string>" );
   this_player()->add_command( "buy", this_object(),
                     "<string> for <indirect:living:here>" );
   this_player()->add_command( "order", this_object(), "<string>",
                     (: do_buy( $1, $2, $3, $4 ) :) );
   this_player()->add_command( "order", this_object(),
                     "<string> for <indirect:living:here>",
                     (: do_buy( $1, $2, $3, $4 ) :) );
}
varargs void add_menu_item(
   string name,
   int type,
   int cost,
   string item,
   string container,
   int volume,
   int intox
) {
   class menu_item new_item;
   string noun, alias;
   string *adjectives, *aliases;
   if( intox < 0 )
      intox = 0;
   if( intox > 10 )
      intox = 10;
   new_item = new( class menu_item );
   new_item->type = type;
   new_item->cost = cost;
   new_item->item = item;
   new_item->container = container;
   new_item->volume = volume;
   new_item->intox = intox;
   _menu_items[name] = new_item;
   if( no_standard_alias ) {
      if( lower_case( name ) != name )
         add_menu_alias( lower_case( name ), name );
      return;
   }
   adjectives = explode( lower_case( name ), " " );
   noun = adjectives[sizeof(adjectives) - 1];
   adjectives = adjectives[0..sizeof(adjectives) - 2];
   aliases = calc_standard_aliases( adjectives );
   foreach( alias in aliases ) {
      add_menu_alias( implode( ({ alias, noun }), " " ), name );
   }
}
string *calc_standard_aliases( string *array ) {
   int i, num_aliases;
   string *new_alias, *aliases;
   if( !sizeof( array ) )
      return ({ 0 });
   if( sizeof( array ) == 1 )
      return ({ array[0], 0 });
   aliases = calc_standard_aliases( array[0..sizeof( array ) - 2] );
   num_aliases = sizeof( aliases );
   for( i = 0; i < num_aliases; i++ ) {
      new_alias = ({ aliases[i], array[ sizeof( array ) - 1] });
      aliases += ({ implode( new_alias, " " ) });
   }
   return aliases;
}
mapping query_menu_items() {
   return _menu_items;
}
int query_pub() {
   return 1;
}
void set_language(string language) {
   _language = language;
}
string query_language() {
   return _language;
}
int remove_menu_item( string name ) {
   if( !_menu_items[name] ) {
      return 0;
   }
   map_delete( _menu_items, name );
   return 1;
}
string string_menu( string *items ) {
   int loop;
   string str, place;
   str = "";
   place = this_object()->query_property( "place" );
   if( !place || ( place == "" ) ) {
      place = "default";
   }
   for( loop = 0; loop < sizeof(items); loop++ ) {
      str += sprintf( "    %-30s %s\n", items[loop],
             MONEY_HAND->money_value_string(
             _menu_items[items[loop]]->cost, place ) );
   }
   return str;
}
string *query_items_of_type( int type ) {
   int i;
   string *selected;
   string *items;
   selected = ({ });
   items = keys( _menu_items );
   for( i = 0; i < sizeof(items); i++ ) {
      if( _menu_items[items[i]]->type == type ) {
         selected += ({ items[i] });
      }
   }
   selected = sort_array( selected, (: _menu_items[$1]->cost -
                                       _menu_items[$2]->cost :) );
   return selected;
}
string string_menu_of_type( int type ) {
   string str;
   string *items;
   items = query_items_of_type( type );
   if( !sizeof(items) ) {
      return "";
   }
   if( _display_subheadings ) {
      str = _menu_subheadings[ type ] + "\n";
   }
   str += string_menu( items );
   return sprintf( "%-=*s\n", (int)this_player()->query_cols(), str );
}
string read() {
   string ret;
   ret = "\n";
   if( _display_header ) {
      ret += _menu_header + "\n";
   }
   ret += string_menu_of_type( PUB_APPETISER );
   ret += string_menu_of_type( PUB_MAINCOURSE );
   ret += string_menu_of_type( PUB_DESSERT );
   ret += string_menu_of_type( PUB_ALCOHOL );
   ret += string_menu_of_type( PUB_SOFTDRINK );
   ret += string_menu_of_type( PUB_HOTDRINK );
   return ret;
}
void set_display_header( int value ) {
   _display_header = value;
}
int query_display_header() {
   return _display_header;
}
void set_menu_header( string header ) {
   _menu_header = header;
}
string query_menu_header() {
   return _menu_header;
}
void set_display_subheadings( int value ) {
   _display_subheadings = value;
}
int query_display_subheadings() {
   return _display_subheadings;
}
void set_menu_subheadings( int subheading, string text ) {
   _menu_subheadings[ subheading ] = text;
}
string *query_menu_subheadings() {
   return _menu_subheadings;
}
void add_menu_alias( mixed alias, string actual ) {
   string bing;
   if (arrayp(alias)) {
      foreach (bing in alias) {
         add_menu_alias(bing, actual);
      }
   }
   _menu_aliases[alias] = actual;
}
void add_menu_aliases( string *aliases, string actual ) {
   string alias;
   foreach( alias in aliases ) {
      add_menu_alias( alias, actual );
   }
}
mapping query_menu_aliases() {
   return _menu_aliases;
}
int remove_menu_alias( string alias ) {
   if( !_menu_aliases[alias] ) {
      return 0;
   }
   map_delete( _menu_aliases, alias );
   return 1;
}
void set_no_standard_alias( int flag ) {
   no_standard_alias = flag;
}
int query_no_standard_alias() {
   return no_standard_alias;
}
object create_real_object( string name ) {
   object item, container;
   if( _menu_items[name]->container ) {
      container = this_object()->create_container(
                                    _menu_items[name]->container );
      if( !container ) {
         container = clone_object( _menu_items[name]->container );
      }
      if( !container ) {
         container = ARMOURY->request_item(
                                 _menu_items[name]->container, 100 );
      }
   }
   if( _menu_items[name]->item ) {
      item = this_object()->create_item( _menu_items[name]->item );
      if( !item ) {
         item = clone_object( _menu_items[name]->item );
      }
      if( !item ) {
         item = ARMOURY->request_item( _menu_items[name]->item, 100 );
      }
   }
   if( item && _menu_items[name]->volume ) {
      item->set_amount( _menu_items[name]->volume );
   } else if ( item && !_menu_items[name]->volume &&
              ( _menu_items[name]->type == PUB_ALCOHOL ||
                _menu_items[name]->type == PUB_HOTDRINK ||
                _menu_items[name]->type == PUB_SOFTDRINK ) ) {
      item->set_amount( container->query_max_volume() -
                        container->query_volume() );
   }
   if( item && container ) {
      if( (int)item->move( container ) != MOVE_OK ) {
         write( "The " + container->short() + " is too small to hold " +
            item->the_short() + ".  Please file a bug report.\n" );
         item->move( "/room/rubbish" );
      }
   }
   if( container ) {
      return container;
   }
   if( item ) {
      return item;
   }
   return 0;
}
int do_buy( object *obs, string dir, string indir, mixed *args ) {
   int value, cost;
   string str, place;
   object person, thing;
   object *succeededpeople, *deadpeople, *failedpeople, *poorpeople;
   succeededpeople = ({ });
   deadpeople = ({ });
   failedpeople = ({ });
   poorpeople = ({ });
   str = args[0];
   if( this_player()->query_property( "dead" ) ) {
      add_failed_mess( "How can you expect to buy " + str + " when you're "
         "dead?\n" );
      return 0;
   }
   if( _menu_aliases[str] ) {
      str = _menu_aliases[str];
   }
   if( !_menu_items[str] ) {
      if (!broadcast_shop_event(PUB_EVENT_NOT_AVAILABLE, this_player(), str)) {
         add_failed_mess( "Sorry, " + str + " is not on the menu.\n" );
      }
      return 0;
   }
   if ( !is_open( this_player(), _menu_items[str]->type ) ) {
      broadcast_shop_event(PUB_EVENT_NOT_OPEN, this_player());
      return 0;
   }
   if( !sizeof( obs ) ) {
      obs = ({ this_player() });
   }
   foreach( person in obs ) {
      if( person->query_property( "dead" ) ) {
         deadpeople += ({ person });
         continue;
      }
      if( !living( person ) ||
          !interactive( person ) && !person->query_property( "npc" ) ) {
         failedpeople += ({ person });
         continue;
      }
      cost = ( _menu_items[str]->cost ) * query_discount( this_player() );
      place = this_object()->query_property( "place" );
      if( !place || ( place == "" ) ) {
         place = "default";
      }
      value = (int)this_player()->query_value_in( place );
      if( place != "default" ) {
         value += (int)this_player()->query_value_in( "default" );
      }
      if( cost > value ) {
         poorpeople += ({ person });
         continue;
      }
      thing = create_real_object( str );
      if( !thing ) {
         add_failed_mess( "Something is buggered.  Please file a bug report.  "
            "Thank you.\n" );
         return 0;
      }
      this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
                        cost, place ), place );
      succeededpeople += ({ person });
      if( (int)thing->move( person ) != MOVE_OK ) {
         if( (int)thing->move( _counter ) != MOVE_OK ) {
            thing->move( this_object() );
            write("You cannot pick " + thing->a_short() +
               " up.  It's left on the floor for you.\n" );
         } else {
           write("You cannot pick " + thing->a_short() +
              " up.  It's left on the counter for you.\n" );
         }
      }
   }
   if( sizeof( succeededpeople ) ) {
      if (!broadcast_shop_event(PUB_EVENT_BOUGHT_STUFF, this_player(),
                           succeededpeople, str)) {
         if( !MAP_HANDLER->compare_arrays( succeededpeople,
                                           ({ this_player() }) ) ) {
            this_player()->add_succeeded_mess( this_object(),
               "$N $V $I.\n", ({ add_a(str) }) );
         } else {
            add_succeeded_mess("$N $V "
               + query_multiple_short( ({ thing }), "a" ) + " for $I.\n",
               succeededpeople);
         }
      }
   } else {
      if( sizeof( deadpeople ) ) {
         if (!broadcast_shop_event(PUB_EVENT_DEAD_PEOPLE, this_player(),
                              deadpeople, str)) {
            add_failed_mess("What use " +
               ( sizeof( deadpeople ) > 1?"have ":"has " ) +
               query_multiple_short( deadpeople, "one" ) + " got for " + str +
               "?\n" );
         }
      }
      if( sizeof( failedpeople ) ) {
         if (!broadcast_shop_event(PUB_EVENT_FAILED_PEOPLE, this_player(),
                              failedpeople, str)) {
            add_failed_mess("You can't buy anything for " +
               query_multiple_short( failedpeople, "one" ) + ".\n" );
         }
      }
      if( sizeof( poorpeople ) ) {
         if (!broadcast_shop_event(PUB_EVENT_POOR_PERSON, this_player(),
                              poorpeople, str)) {
            add_failed_mess("You cannot afford to order " + str +
               " for " + query_multiple_short( poorpeople, "one" ) + ".\n" );
         }
      }
      return 0;
   }
   return 1;
}
void dest_me() {
   if( _menu_object ) {
      _menu_object->dest_me();
   }
}
float query_discount( object ob ) {
   return 1.0;
}
object make_counter() {
   object ob;
   ob = clone_object( PUB_COUNTER_FILE );
   add_hidden_object( ob );
   return ob;
}
object query_counter() {
   return _counter;
}
object query_menu() {
   return _menu_object;
}

==================================================
FILE: shops/inherit/shop_event.c
==================================================

private nosave object* _events;
void create() {
   _events = ({ });
}
void add_shop_observer(object observer) {
   if (!_events) {
      _events = ({ });
   }
   if (member_array(observer, _events) == -1) {
      _events += ({ observer });
   }
}
void remove_shop_observer(object observer) {
   _events -= ({ observer });
}
int broadcast_shop_event(string type, object player, mixed args ...) {
   debug_printf("Calling %O on %O\n", "event_shop_" + type, _events);
   if (sizeof(filter(call_other(_events, "event_shop_" + type, this_object(),
                                player, args ...),
                    (: $1 :)))) {
      return 1;
   }
   return 0;
}

==================================================
FILE: shops/inherit/store_close.c
==================================================

#include <weather.h>
#include <climate.h>
#include <am_time.h>
void open_up();
void close_up();
private string _keeper;
private string *_outside_rooms;
private string *_exits;
private string _burglar;
private string _file;
private int _flag;
private int _open;
private int _closed;
private nosave object _keeper_ob;
void event_weather(int whats_changed){
   if(whats_changed >= 8){
      if (_flag) {
         call_out("night_time_check", 1);
      } else {
         call_out("day_time_check", 1);
      }
   }
}
protected void night_time_check(){
   int bing;
   bing = AM_TIME_HANDLER->query_am_hour(time() );
   if (bing > 12 && bing < 23 && !_closed) {
      _open = 0;
      _closed = 1;
      close_up();
   }
   if (bing > 0 && bing < 12 && !_open) {
      _closed = 0;
      _open = 1;
      open_up();
   }
}
protected void day_time_check(){
   int bing;
   bing = AM_TIME_HANDLER->query_am_hour(time() );
   if (bing > 0 && bing < 12 && !_closed) {
      _open = 0;
      _closed = 1;
      close_up();
   }
   if (bing > 12 && bing < 23 && !_open) {
      _closed = 0;
      _open = 1;
      open_up();
   }
}
void set_night_close(int night, string shopkeeper, string *outside,
    string burglar_func){
   int i;
   _flag = night;
   WEATHER->weather_notify( this_object(), NOTIFY_DAY );
   _keeper = _file = shopkeeper;
   if (sizeof(outside) && !(sizeof(outside)%2)) {
      _exits = allocate(sizeof(outside)/2);
      _outside_rooms = allocate(sizeof(outside)/2);
      for(i=0; i<sizeof(outside); i++) {
         if(!i%2)
            _outside_rooms[i] = outside[i];
         else
            _exits[i-1] = outside[i];
      }
   }
   _burglar = burglar_func;
}
void close_up(){
   object *obs;
   object *people;
   object bing;
   object *keeper_ob;
   int i;
   if (_keeper == "none") {
     event (this_object(), "person_say", "The shopkeeper says: ",
       "I'm sorry, it's time to close!", "common");
     tell_room (this_object(), "The shopkeeper ushers you out of "
          "the store.\n");
   }
   else {
      keeper_ob = children(_keeper);
      if (!sizeof(keeper_ob)) {
         return;
      }
      if (keeper_ob[0]->query_fighting()) {
         call_out("close_up", 60);
         return;
      }
      keeper_ob[0]->do_command("'I'm sorry, it's time to close!");
      keeper_ob[0]->do_command(":ushers you out of the store.");
      keeper_ob[0]->move("/room/rubbish");
   }
   obs = all_inventory( this_object() );
   people = filter(obs, (: $1->query_property("player") :));
   foreach(bing in people){
      bing->move_with_look(_outside_rooms[0]);
   }
   for(i=0; i<sizeof(_outside_rooms); i++){
      _outside_rooms[i]->modify_exit(_exits[i], ({"open", 0, "locked", 1,
          "difficulty", 4}));
   }
}
void open_up(){
   int i;
   for(i=0; i<sizeof(_outside_rooms); i++){
     _outside_rooms[i]->modify_exit(_exits[i], ({"open", 1, "locked", 0,
        "difficulty", 4}));
   }
   if (_keeper == "none") {
      return;
   }
   _keeper_ob = clone_object(_file);
   _keeper_ob->move(this_object());
}
void event_enter(object ob, string message, object from){
   if (!_burglar) {
      return;
   }
   if (!_closed) {
      return;
   }
   if (ob->query_creator()) {
      return;
   }
   if (!ob->query_property("player")) {
      return;
   }
   call_out(_burglar, 1, ob);
}
mapping query_dynamic_auto_load() {
   return ([ "keeper ob" : _keeper_ob ]);
}
void init_dynamic_arg(mapping map) {
   _keeper_ob = map["keeper ob"];
}

==================================================
FILE: shops/inherit/vault_entry.c
==================================================

#include <money.h>
#include <vault.h>
#define PTS proprietor->the_short()
#define TIME_LIMIT 500
#define SPAM_GUARD (60 * 3)
void add_exit(string name, string dest, string type);
void modify_exit(string name, mixed* stuff);
mixed query_property(string name);
void add_property(string name, mixed value);
void remove_property(string name);
string location, vault_name, vault_room;
int visit_cost, open_cost;
object proprietor;
void set_location(string str) { location = str; }
void set_open_cost(int i) { open_cost = i; }
void set_visit_cost(int i) { visit_cost = i; }
void set_proprietor(object ob) { proprietor = ob; }
void set_vault_name(string str) { vault_name = str; }
void set_vault_exit(string direc, mixed dest, string type) {
  vault_room = dest;
  add_exit(direc, dest, type);
  modify_exit( direc, ({ "function", "check_customer" }) );
  modify_exit( direc, ({ "closed", 1}));
}
int apply_for_account() {
  string owner;
  object container;
  if(!proprietor || environment(proprietor) != this_object())
    return notify_fail("The vault is closed since the proprietor is "
                       "missing.\n");
  this_player()->add_succeeded_mess( this_object(), "", ({ }) );
  write("You ask for an account.\n");
  say((string)this_player()->one_short() +" asks for an account.\n");
  owner = (string)this_player()->query_name();
  if ( master()->file_exists( VAULT_SAVE +vault_name+ "/"+ owner +".o" ) ||
       query_property( owner ) )
  {
    if ( this_player()->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ this_player()->query_name() );
      proprietor->do_command( "say I just said, you already have an "
         "account." );
      return notify_fail("");
    }
    proprietor->do_command( "say You already have an account!" );
    this_player()->add_property( "vault warned", 1, SPAM_GUARD );
    return 1;
  }
  if ( this_player()->query_value_in( location) < open_cost ) {
    if ( this_player()->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ this_player()->query_name() );
      proprietor->do_command( "say I just said, you don't have enough money!" );
      return notify_fail("");
    }
    proprietor->do_command("say You do not have the "+
                           (string)MONEY_HAND->money_value_string(open_cost,
                                                                  location) +
                           " that it costs to open an account." );
    this_player()->add_property( "vault warned", 1, SPAM_GUARD );
    return 1;
  }
  proprietor->do_command("say Very well, that'll be "+
                         (string)MONEY_HAND->money_value_string( open_cost,
                                                                 location) +
                         ", please." );
  this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array( open_cost,
                                                                     location),
                            location);
  write( "You pay "+PTS+".\n" );
  say( (string)this_player()->the_short() +" pays "+proprietor->the_short()+
       ".\n" );
  proprietor->do_command("say As a new account holder, "
                         "your first use of the facility will be free.  "
                         "Thereafter, it will cost "+
                         (string)MONEY_HAND->money_value_string( visit_cost,
                                                                 location) +
                         " each time.");
  add_property( owner, 1 );
  container = vault_room->init_container(this_player());
  container->dest_me();
  return 1;
}
void init() {
  add_command( "apply", "for [an] account", (: apply_for_account :) );
}
int check_customer( string verb, object thing, string special ) {
  string owner;
  object vroom;
  if(!proprietor || environment(proprietor) != this_object())
    return notify_fail("The vault is closed since the proprietor is "
                       "missing.\n");
  if( !interactive(thing) )
    return 0;
  owner = (string)thing->query_name();
  if ( !master()->file_exists( VAULT_SAVE +vault_name+ "/" + owner +".o" ) &&
       !query_property( owner ) )
  {
    tell_object( thing, PTS+
                 " intercepts you.\n" );
    tell_room( this_object(), PTS+" intercepts "+
               (string)thing->the_short() +".\n",
               thing );
    if ( thing->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ thing->query_name() );
      proprietor->do_command( "say I just said, you don't have an account "
         "so I won't let you in!" );
      return notify_fail("");
    }
    proprietor->do_command("say You do not have an account!");
    if( interactive(thing) )
      proprietor->do_command("say For "+
                             (string)MONEY_HAND->money_value_string(open_cost,
                                                                    location)+
                             ", you could apply for an account.\n" );
    thing->add_property( "vault warned", 1, SPAM_GUARD );
    return notify_fail( "" );
  }
  if ( !( vroom = find_object( vault_room ) ) ) {
    vault_room->load_me();
    vroom = find_object( vault_room );
  }
  if( sizeof( filter_array( all_inventory( vroom ), (: userp( $1 ) :) ) ) ) {
    tell_object( thing, PTS+" intercepts you.\n" );
    tell_room( this_object(), PTS+" intercepts "+ (string)thing->the_short()
       +".\n", thing );
    if( thing->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ thing->query_name() );
      proprietor->do_command( "say I just told you, someone is using the "
         "facility at the moment!" );
      return notify_fail("");
    }
    proprietor->do_command("say Someone is using the facility at the moment!");
    thing->add_property( "vault warned", 1, SPAM_GUARD );
    return notify_fail( "" );
  }
  if( query_property( owner ) ) {
    remove_property(owner);
    tell_object(thing, PTS+" waves you through.\n" );
    tell_room( this_object(), PTS+" waves "+(string)thing->the_short() +
      " through.\n", thing );
    call_out( "check_idler", TIME_LIMIT, thing );
    return 1;
  }
  if ( (int)thing->query_value_in( location ) < visit_cost ) {
    tell_object( thing, PTS+" intercepts you.\n" );
    tell_room( this_object(), PTS+" intercepts "+ (string)thing->the_short()
      +".\n", thing );
    if ( thing->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ thing->query_name() );
      proprietor->do_command( "say I just said, you don't have enough "
         "money to use the facility!" );
      return notify_fail("");
    }
    proprietor->do_command("say It costs "+
                           (string)MONEY_HAND->money_value_string( visit_cost,
                                                                   location ) +
                           " to use the facility!" );
    thing->add_property( "vault warned", 1, SPAM_GUARD );
    return notify_fail( "" );
  }
  thing->pay_money((mixed *)MONEY_HAND->create_money_array(visit_cost,
                                                           location),
                   location);
  tell_object( thing, "You pay "+PTS+" who waves you through.\n" );
  tell_room( this_object(), (string)thing->the_short() +
             " pays "+PTS+" who waves "+ (string)thing->query_objective() +
             " through.\n", thing );
  remove_call_out("check_idler");
  call_out("check_idler", TIME_LIMIT, thing);
  return 1;
}
void check_idler(object who) {
  if(who && base_name(environment(who)) == vault_room) {
    tell_object(who, "You've been in here too long so " + PTS + " comes and "
              "drags you out.\n");
    who->move_with_look(this_object(),
                      "$N is dragged out of the vault by the hair.",
                      "$N is dragged out of the vault by the hair.");
  }
}
void player_quitting(object who, object env) {
}

==================================================
FILE: shops/objs/counter.c
==================================================

#include <position.h>
inherit "/std/surface";
void create() {
   ::create();
   set_name( "counter" );
   set_short( "counter" );
   set_long( "The counter seems to be where you should leave glasses and "
      "plates to be cleared away.\n" );
   reset_get();
   add_property(CAN_POSITION_PROPERTY, 1);
}
void clear_item( object item ) {
   if( environment( item ) == this_object()
       && !sizeof( all_inventory( item ) ) )
      item->move( "/room/rubbish" );
}
void event_enter( object ob, string mess, object from ) {
   if( ob->query_property( "pub item" )
       && !sizeof( all_inventory( ob ) ) )
      call_out( "clear_item", 3, ob );
}

==================================================
FILE: shops/player_shop/counter.c
==================================================

inherit "/std/room/basic_room";
#include <player_shop.h>
#include <money.h>
private nosave mixed *_money;
private nosave object _register = 0;
private nosave string _save_file = "",
                      _place = UNSET_STR,
                      _office = "",
                      _storeroom = "",
                      _mgr_office = "",
                      _shop_front = "",
                      _store_dir = "",
                      _office_dir = "",
                      _shop_dir = "";
private nosave int _call_save = 0;
int action(string);
void add_money_ob(object);
int adjust_register(string, int);
string directions_to(string);
private int do_calc(int,string,int);
private int do_correction(mixed);
private int do_log(mixed *);
int query_register();
private void save_me(string);
void save_register(int);
protected void set_office(string);
protected void set_directions(string, string, string);
void create()
{
   do_setup++;
   ::create();
   do_setup--;
   add_property("no burial", 1);
   add_property("determinate", "");
   if (!do_setup)
   {
      this_object()->setup();
      this_object()->reset();
   }
   add_item("calculator", "A standard shop's calculator used to total "
     "up all those difficult prices.  To use, see \"syntax calc\".");
   add_help_file("player_shop_counter");
}
void init()
{
   ::init();
   if (!_office || _office == "") return;
   this_player()->command_override((: action :));
   add_command("calc", "<number> {+|-|*|/} <number>",
     (: do_calc($4[0],$4[1],$4[2]) :));
   if (_office->query_employee(this_player()->query_name()) ||
     this_player()->query_creator())
   {
      add_command("log",
        "shop {bought|sold} <number> <string'item(s)'> for <word'amount'>",
        (: do_log($4) :));
      add_command("correction",
        "shop {bought|sold} <number> <string'item(s)'> for <word'amount'>",
        (: do_correction($4) :));
   }
}
int action(string str)
{
   string st1;
   if (_office->query_employee(this_player()->query_name()) ||
     this_player()->query_creator())
     return 0;
   sscanf(str,"%s %s",str,st1);
   if(str == "get" || str == "take")
      if (strsrch(st1, "register") != -1)
      {
         tell_object(this_player(), "You are not an active employee here!\n");
         return 1;
      }
   return 0;
}
void add_money_ob(object money)
{
   if (previous_object() && previous_object() != find_object(_office))
   {
      LOG_ERROR("counter.c", "add_money_ob()");
      return;
   }
   if (!money) return;
   money->move( _register );
   save_register(TRUE);
}
int adjust_register(string player, int amount)
{
   int value;
   object cash, change;
   if (previous_object() && previous_object() != find_object(_office))
   {
      LOG_ERROR("counter.c", "adjust_register(" + player+","+amount+")");
      return 0;
   }
   if (amount < 0) return 0;
   cash = present(MONEY_ALIAS, _register);
   if ( !cash ) return 0;
   _money = cash->query_money_array() + ({});
   value = MONEY_HAND->query_total_value(_money, _place);
   if (value < amount) amount = value;
   change = MONEY_HAND->pay_amount_from( amount, cash, _place );
   if (change) change->move( _register );
   _office->shop_log(ACCOUNTS, player, "adjusted the register by "+
     MONEY_HAND->money_value_string(amount, _place), UNPAID);
   save_register(TRUE);
   return amount;
}
string directions_to(string place)
{
   if (place == _storeroom) return _store_dir;
   if (place == _office) return _office_dir;
   if (place == _shop_front) return _shop_dir;
   return "here";
}
private int do_calc(int a, string sign, int b)
{
   int c = 0;
   string result = a+ " "+ sign+ " "+ b+ " = ",
          temp;
   switch (sign)
   {
     case "+" :
        result += sprintf("%d\n", a+b);
        break;
     case "-" :
        result += sprintf("%d\n", a-b);
        break;
     case "*" :
        result += sprintf("%d\n", a*b);
        break;
     case "/" :
        if (!b)
        {
           tell_object( this_player(),
             "Trying to divide by zero?  Whatever next?\n");
           return 1;
        }
        if (a % b) c = ((a%b) * 100)/b;
        temp = sprintf("%02d",c);
        result += sprintf("%d.%s\n", a/b, temp[0..1]);
        break;
   }
   tell_object(this_player(), result);
   add_succeeded_mess("$N use$s the calculator.\n");
   return 1;
}
private int do_correction(mixed *args)
{
   _office->shop_log(LOG_ENTRY, this_player()->query_name(),
     "ERROR IN LOG - correct entry follows:", UNPAID);
   _office->shop_log(LOG_ENTRY, this_player()->query_name(),
     args[0]+ " "+ args[1]+ " "+ args[2]+ " for "+ args[3], UNPAID);
   add_succeeded_mess("$N make$s a correction in the transaction log book.\n");
   return 1;
}
private int do_log(mixed *args)
{
   _office->shop_log(LOG_ENTRY, this_player()->query_name(),
     args[0]+ " "+ args[1]+ " "+ args[2]+ " for "+ args[3], PAID);
   add_succeeded_mess("$N make$s an entry in the transaction log book.\n");
   return 1;
}
void event_death(object k, object *o, object k2, string r, string k3)
{
   _office->event_death(k, o, k2, r, k3);
}
void event_enter(object ob, string message, object from)
{
   _office->event_enter(ob, message, from);
}
int query_register()
{
   object cash = present(MONEY_ALIAS, _register);
   if (!cash) return 0;
   _money = cash->query_money_array() + ({});
   return MONEY_HAND->query_total_value(_money, _place);
}
private void save_me(string name)
{
   int difference;
   object cash;
   mixed *old = _money + ({});
   if (!_register) return;
   cash = present(MONEY_ALIAS, _register);
   if (!cash) _money = ({});
   else _money = (mixed *)cash->query_money_array() + ({});
#ifdef DEBUG
   tell_creator(CREATOR, "Register contains: %O.\n", _money);
#endif
   _office->save_register(_money);
   difference = MONEY_HAND->query_total_value(_money, _place) -
     MONEY_HAND->query_total_value(old, _place);
   if (!difference) return;
   _office->adjust_takings(difference);
   if (!name || name == "") return;
   if (difference < 0)
      _office->shop_log(PURCHASE, name, "removed "+
        MONEY_HAND->money_value_string(-difference, _place)+
        " from register", UNPAID);
   else
      _office->shop_log(SALE, name, "added "+
        MONEY_HAND->money_value_string(difference, _place)+
        " to register", UNPAID);
}
void save_register(int no_player)
{
   remove_call_out(_call_save);
   _call_save = call_out((: save_me($((!no_player)?
      this_player()->query_name():"shop")) :), 1);
}
protected void set_directions(string office, string storeroom, string shop)
{
   _office_dir = office;
   _store_dir = storeroom;
   _shop_dir = shop;
}
protected void set_long(string long_desc)
{
   long_desc += "Employees of the shop can \"log\" transactions or "
     "\"correction\"s here.  The shop's cash register is under the "
     "counter and there is a calculator next to that.\n";
   ::set_long(long_desc);
}
protected void set_office(string path)
{
   object cash;
   _office = path;
   _storeroom = _office->query_storeroom();
   _mgr_office = _office->query_mgr_office();
   _shop_front = _office->query_shop_front();
   _place = _office->query_place();
   if (_register) return;
   _register = clone_object("/obj/misc/cash_register");
   _register->set_name("register");
   _register->set_short("cash register");
   _register->add_adjective("cash");
   _register->set_long("The cash register is really just an iron drawer "
     "mounted underneath the counter.  In a certain light, it almost "
     "seems tongue-shaped.\n");
   _register->set_shop(this_object());
   add_hidden_object(_register);
   _register->reset_get();
   _money = _office->restore_register();
   if (!_money || !sizeof(_money)) return;
   cash = clone_object(MONEY_OBJECT);
   cash->set_money_array(_money);
   cash->move(_register);
}

==================================================
FILE: shops/player_shop/mgr_office.c
==================================================

inherit "/std/room/basic_room";
#include <player_shop.h>
#include <mail.h>
#include <move_failures.h>
#include <money.h>
#include "patterns.h"
private nosave string _office = "",
_place = "",
_shop_front = "",
_counter = "",
_storeroom = "";
private nosave object _notice = 0;
private string cap_name(string);
private int do_accounts();
private int do_ban(mixed *);
private int do_check();
private int do_claim();
private int do_commend(string);
private int do_demote(string);
private int do_fire(mixed *);
private int do_leave(mixed *);
private int do_list(mixed *);
private int do_logs(mixed *, string);
private int do_mail(string);
private int do_memo();
private int do_office();
private int do_policies();
private int do_policy(mixed *,string);
private int do_project(string);
private int do_query(string);
private int do_remove();
private int do_rent();
private int do_retire();
private int do_set(mixed *, string);
private int do_suspend(mixed *);
private int do_transfer(mixed *);
private int do_unban(string);
private int do_view(string,string);
private int do_vote(mixed *, string);
private int do_warn(mixed *);
private void end_memo(string,string);
private void end_policy_suggest(string,string,int);
private void send_memo(string, string, string);
protected void set_office(string);
private void write_memo(string);
void create()
{
    do_setup++;
    ::create();
    do_setup--;
    add_property("determinate", "");
    if (!do_setup)
    {
        this_object()->setup();
        this_object()->reset();
    }
    add_help_file("player_shop_mgr_office");
}
void init()
{
    ::init();
    if (!_office || _office == "") return;
    if ( !_office->query_manager(this_player()->query_name()) &&
      !_office->query_retired(this_player()->query_name()) &&
      !this_player()->query_creator()) return;
    add_command("list", ({LIST_BLANK, LIST_CHOICE}),
      (: do_list($4) :));
    add_command("memo", "", (: do_memo() :));
    add_command("office", "", (: do_office() :));
    add_command("claim", "", (: do_claim() :));
    add_command("accounts", "", (: do_accounts() :));
    add_command("logs", ({LOG_BLANK, LOG_NUMBER, LOG_MGR}),
      (: do_logs($4,$5) :));
    add_command("mail", ({"", "<string>"}), (: do_mail($4) :));
    add_command("query", "{pay|employees}", (: do_query($4[0]) :));
    add_command("view", ({VIEW_EMP, VIEW_APP}), (: do_view($4[0],$5) :));
    add_command("project", "{pay|bonus}", (: do_project($4[0]) :));
    add_command("vote", VOTE_POLICY, (: do_vote($4,$5) :));
    add_command("policy", ({POLICY_SUGGEST, POLICY_REMOVE}),
      (: do_policy($4,$5) :));
    add_command("policies", "", (: do_policies() :));
    if (_office->query_retired(this_player()->query_name())) return;
    add_command("rent", "cabinet", (: do_rent() :));
    add_command("remove", "cabinet", (: do_remove() :));
    add_command("retire", "", (: do_retire() :));
    add_command("vote", VOTE_APPLICANT, (: do_vote($4,$5) :));
    add_command("check", "votes", (: do_check() :));
    add_command("commend", "<word'employee'>", (: do_commend($4[0]) :));
    add_command("fire", "<word'employee'> [for] <string'reason'>",
      (: do_fire($4) :));
    add_command("warn", "<word'employee'> [for] <string'reason'>",
      (: do_warn($4) :));
    add_command("demote", "<word'employee'>", (: do_demote($4[0]) :));
    add_command("suspend", "<word'employee'> [for] <number> [months]",
      (: do_suspend($4) :));
    add_command("leave", "<word'employee'> [for] <number> [days]",
      (: do_leave($4) :));
    add_command("ban", "<word'person'> [for] <string'reason'>",
      (: do_ban($4) :));
    add_command("unban", "<word'person'>", (: do_unban($4[0]) :));
    add_command("set", ({SET_EMPS, SET_PAY}), (: do_set($4,$5) :));
    add_command("transfer", "<number'amount'> <string'type'> [from] "
      "{register|bonus|profit} [to] {register|bonus|profit}",
      (: do_transfer($4) :));
}
private string cap_name(string name)
{
    if (test_player(name))
        return PLAYER_HANDLER->query_cap_name(name);
    else return capitalize(name);
}
void dest_me()
{
    if (_notice) _notice->dest_me();
    ::dest_me();
}
private int do_accounts()
{
    tell_object(this_player(), "The shop's accounts are as follows:\n"+
      sprintf("   Cash   : %s\n   Bonus  : %s\n   Profit : %s\n",
        MONEY_HAND->money_value_string(_counter->query_register(), _place),
        MONEY_HAND->money_value_string(_office->query_bonus(), _place),
        MONEY_HAND->money_value_string(_office->query_profit(), _place)));
    return 1;
}
private int do_ban(mixed *args) { return _office->do_ban(args); }
private int do_check()
{
    string results,
    name = this_player()->query_name();
    mapping applicants;
    add_succeeded_mess("");
    applicants = _office->get_applicants();
    applicants = filter(applicants, (: $(applicants)[$1][APP_TYPE] == 1 :));
    if (this_player()->query_creator())
    {
        results = "The following votes have been cast:\n\n";
        foreach (string word in sort_array(keys(applicants), 1))
        {
            results += cap_name(word)+ " - applied " +
            ctime(applicants[word][APP_TIME] )+ "\n   Votes for:     ";
            foreach (string vote in applicants[word][APP_FOR])
            results += cap_name(vote) + "  ";
            results += "\n   Votes against: ";
            foreach (string vote in applicants[word][APP_AGAINST])
            results += cap_name(vote) + "  ";
            results += "\n   Abstentions:   ";
            foreach (string vote in applicants[word][APP_ABSTAIN])
            results += cap_name(vote) + "  ";
            results += "\n\n";
        }
        tell_object(this_player(), "$P$Votes cast$P$"+ results);
        return 1;
    }
    results = "You have cast the following votes:\n\nFor: ";
    foreach (string vote in sort_array(keys(applicants), 1))
    if (member_array(name, applicants[vote][APP_FOR]) != -1)
        results += cap_name(vote)+ "  ";
    results += "\nAgainst: ";
    foreach (string vote in sort_array(keys(applicants), 1))
    if (member_array(name, applicants[vote][APP_AGAINST]) != -1)
        results += cap_name(vote)+ "  ";
    results += "\nAbstentions: ";
    foreach (string vote in sort_array(keys(applicants), 1))
    if (member_array(name, applicants[vote][APP_ABSTAIN]) != -1)
        results += cap_name(vote)+ "  ";
    tell_object(this_player(), results + "\n");
    return 1;
}
private int do_claim()
{
    object thing;
    if (!_office || _office == "") return 0;
    thing = clone_object(MGR_BOOK);
    thing->set_read_mess("\n   "+ _office->query_shop_name()+ "\n\n"
      "   Manager's Handbook\n\n   This handbook belongs to: "+
      this_player()->query_short()+ "\n\n", "common", 100);
    thing->set_office(_office);
    if (thing->move(this_player()) != MOVE_OK)
    {
        thing->move(this_object());
        tell_object(this_player(),
          "You drop your handbook as you're carrying too much.\n");
    }
    add_succeeded_mess("$N $V a new handbook.\n");
    return 1;
}
private int do_commend(string emp) { return _office->do_commend(emp); }
private int do_demote(string emp) { return _office->do_demote(emp); }
private int do_fire(mixed *args) { return _office->do_fire(args); }
private int do_leave(mixed *args) { return _office->do_leave(args); }
private int do_list(mixed *args)
{
    string results, word;
    mapping baddies, applicants;
    string *applied, *hired, *awaiting;
    if (!sizeof(args)) args = ({"employees"});
    add_succeeded_mess("");
    switch (args[0])
    {
    case "applicants" :
        results = "      Applications for employment as at " +
        ctime(time()) + "\n\n";
        applicants = _office->get_applicants();
        if (!applicants || applicants == ([]))
        {
            tell_object(this_player(), results+
              "No applications outstanding.\n");
            return 1;
        }
        applied = sort_array(keys(filter(applicants,
              (: $(applicants)[$1][APP_TYPE] == APPLIED :))),
          (: $(applicants)[$1][APP_TIME] - $(applicants)[$2][APP_TIME] :));
        hired = sort_array(keys(filter(applicants,
              (: $(applicants)[$1][APP_TYPE] == HIRED :))),
          (: $(applicants)[$1][APP_TIME] - $(applicants)[$2][APP_TIME] :));
        awaiting = sort_array(keys(filter(applicants,
              (: $(applicants)[$1][APP_TYPE] == AWAITING :))),
          (: $(applicants)[$1][APP_TIME] - $(applicants)[$2][APP_TIME] :));
        if ( sizeof(awaiting))
        {
            results += "Applicants awaiting vacancies:\n";
            foreach (word in awaiting)
            results += "     "+ cap_name(word)+
            " - confirmed employment " +
            ctime(applicants[word][1])+ "\n";
            results += "\n";
        }
        if (sizeof(hired))
        {
            results += "Applicants yet to confirm their employment:\n";
            foreach (word in hired)
            results += "     "+ cap_name(word)+ " - voted in " +
            ctime(applicants[word][1])+ "\n";
            results += "\n";
        }
        if (sizeof(applied))
        {
            results += "Applicants yet to be hired or rejected.  Vote now!\n";
            foreach (word in applied)
            {
                results += "     "+ cap_name(word)+ " - applied " +
                ctime(applicants[word][1])+ "\n";
                results += sprintf("     %-12s%-5d%-16s%-5d%-13s%-5d\n",
                  "Votes for:", sizeof(applicants[word][APP_FOR]),
                  "Votes against:", sizeof(applicants[word][APP_AGAINST]),
                  "Abstentions:", sizeof(applicants[word][APP_ABSTAIN]));
            }
        }
        tell_object(this_player(), "$P$Applications list$P$"+ results);
        break;
    case "baddies" :
        if (!m_sizeof(baddies = _office->get_baddies()))
        {
            tell_object(this_player(),
              "There are no people on the list at the moment.\n");
            return 1;
        }
        results = "This is a list of people banned from the shop:\n\n";
        foreach (word in sort_array(keys(baddies), 1))
        {
            results += cap_name(word)+ " banned by "+
            baddies[word][BAD_BANNER]+ " on "+
            ctime(baddies[word][BAD_TIME] )+ ".\n   Banned for "+
            baddies[word][BAD_REASON]+ ".\n\n";
        }
        tell_object(this_player(), "$P$Baddies$P$\n"+ results);
        break;
    default :
        return _office->do_list();
    }
    return 1;
}
private int do_logs(mixed *args, string pattern)
{
    return _office->do_logs(args, pattern);
}
private int do_mail(string words) { return MAIL_TRACK->mail(words); }
private int do_memo()
{
    tell_object(this_player(), "Subject: (hit enter for general memo)\n");
    input_to((: write_memo($1) :), 0);
    add_succeeded_mess("");
    return 1;
}
private int do_office()
{
    int retired = _office->query_retired(this_player()->query_name());
    string result = (retired)?
    "As a retired manager, you can use the following commands:\n":
    "As a manager, you can use the following commands:\n";
    result +=
    "   accounts  - view register, bonus & profit accounts\n"
    "   claim     - claim a manager's handbook\n"
    "   list      - list employees, applicants or banned people\n"
    "   logs      - review the shop's logs\n"
    "   mail      - read / send mail\n"
    "   memo      - send a message to the other managers\n"
    "   policy    - suggest a new (or remove an old) policy for the shop\n"
    "   policies  - check on the proposed policies\n"
    "   project   - view anticipated paypacket & bonus values\n"
    "   query     - query pay amount or number of employees\n"
    "   view      - view a person's history with this shop\n"
    "               or an applicant's application form\n"
    "   vote      - vote for a policy to be implemented into the shop\n";
    if (!retired)
        result +=
        "               or for an applicant to work for the shop\n"
        "   (un)ban   - (un)ban a person from the shop for "+
        BAN_LENGTH+ " days\n"
        "   rent      - rent storeroom cabinets\n"
        "   remove    - remove storeroom cabinets\n"
        "   check     - check votes you have made on applications\n"
        "   commend   - reward an outstanding employee\n"
        "   demote    - demote an employee\n"
        "   fire      - end someone's employment\n"
        "   leave     - place an employee on leave for up to "+
        MAX_LEAVE+ " days\n"
        "   retire    - end your active employment at the shop\n"
        "   set       - set number of employees, and pay amount\n"
        "   suspend   - suspend an employee's bonus entitlement\n"
        "   transfer  - transfer money between register, bonus & profit\n"
        "   warn      - issue a formal warning to an employee\n";
    tell_object(this_player(), result+ "\n");
    add_succeeded_mess("");
    return 1;
}
private int do_policies()
{
    mapping policies = _office->get_new_policies();
    if (!m_sizeof(policies))
        tell_object(this_player(), "There are no policies awaiting sanction.\n");
    else
    {
        int i = 1;
        tell_object(this_player(), "The following policies have been suggested."
          "  Policies in existence are proposed to be overturned.\n");
        foreach(string policy in m_indices(policies))
        tell_object(this_player(), sprintf("%d. %s - %s [%s]. %s\n", i++,
            (policies[policy][POLICY_TYPE])?"MGR":"EMP", policy,
            policies[policy][POLICY_MGR], policies[policy][POLICY_TEXT]));
    }
    return 1;
}
private int do_policy(mixed *args, string pattern)
{
    string *managers, mgr;
    if (pattern == POLICY_SUGGEST)
    {
        if (_office->query_policy(args[1]))
        {
            tell_object(this_player(), "This name is already in use.\n");
            return 1;
        }
        this_player()->do_edit(0, (: end_policy_suggest($1,
              $(lower_case(args[1])),$((args[0] == "manager")?1:0)) :));
        add_succeeded_mess("");
        return 1;
    }
    if (_office->query_policy(args[0]) < 2)
    {
        tell_object(this_player(), "This policy does not exist.\n");
        return 1;
    }
    args[0] = lower_case(args[0]);
    tell_object(this_player(), "You suggest that the "+ args[0]+
      " policy should be removed.\n");
    mgr = this_player()->query_name();
    managers = _office->get_managers();
    managers += _office->get_retired();
    managers += ({_office->query_creator()});
    managers -= ({mgr});
    AUTO_MAILER->auto_mail(implode(managers, ","),
      mgr, "TFQC policy suggestion",
      "", "Please note that I would like you to vote on removing the "+
      args[0]+ " policy.\n", 0, 0);
    _office->add_policy_suggest(args[0], "", mgr);
    return 1;
}
private int do_project(string projection)
{
    add_succeeded_mess("");
    switch (projection)
    {
    case "bonus" :
        _office->calc_bonus();
        break;
    case "pay" :
        tell_object(this_player(),
          "For the month to date, the staff wages total "+
          MONEY_HAND->money_value_string( _office->calc_pay(),
            _place)+ ".\n");
        break;
    }
    return 1;
}
private int do_query(string query)
{
    add_succeeded_mess("");
    switch(query)
    {
    case "pay" :
        tell_object(this_player(), "The pay is currently set at "+
          MONEY_HAND->money_value_string(_office->query_pay(),
            _place)+ ".\n");
        break;
    case "employees" :
        tell_object(this_player(),
          "The maximum number of employees is currently "+
          _office->query_maxemp()+ ".\n");
        break;
    default :
    }
    return 1;
}
private int do_remove() { return _office->do_remove(); }
private int do_rent() { return _office->do_rent(); }
private int do_retire() { return _office->do_retire(); }
private int do_set(mixed *args, string pattern)
{
    return _office->do_set(args, pattern);
}
private int do_suspend(mixed *args) { return _office->do_suspend(args); }
private int do_transfer(mixed *args) { return _office->do_transfer(args); }
private int do_unban( string person ) { return _office->do_unban(person); }
private int do_view(string person, string pattern)
{
    _office->view_record(person, pattern);
    return 1;
}
private int do_vote(mixed *args, string pattern)
{
    return _office->do_vote(args, pattern);
}
private int do_warn(mixed *args) { return _office->do_warn(args); }
private void end_memo(string text, string subject)
{
    if (!text)
    {
        tell_object(this_player(), "Aborted.\n");
        return;
    }
    tell_object(this_player(),
      "Do you want to keep a copy of the memo? ");
    input_to((: send_memo($1,$(subject),$(text)) :), 0);
}
private void end_policy_suggest(string text, string name, int type)
{
    string mgr, *managers;
    if (!text)
    {
        tell_object(this_player(), "Aborted.\n");
        return;
    }
    text = replace_string(text, "\n", " ");
    text = replace_string(text, "  ", " ");
    mgr = this_player()->query_name();
    managers = _office->get_managers();
    managers += _office->get_retired();
    managers += ({_office->query_creator()});
    managers -= ({lower_case(mgr)});
    AUTO_MAILER->auto_mail(implode(managers, ","),
      mgr, _office->shop_very_short()+ " policy suggestion",
      "", "Please note that there is a new policy, "+ name+
      ", on which I would like you to vote.\n", 0, 0);
    _office->add_policy_suggest(name, text, mgr, type);
}
void event_death(object k, object *o, object k2, string r, string k3)
{
    _office->event_death(k, o, k2, r, k3);
}
void event_enter(object ob, string message, object from)
{
    _office->event_enter(ob, message, from);
}
private void send_memo(string ans, string subject, string text)
{
    string *managers;
    ans = lower_case(ans);
    if (strlen(ans) < 1 || (ans[0] != 'y' && ans[0] != 'n'))
    {
        tell_object(this_player(),
          "Do you want to keep a copy of the memo? (Yes or No)? ");
        input_to((: send_memo($1,$(subject),$(text)) :), 0);
        return;
    }
    managers = _office->get_managers();
    managers += _office->get_retired();
    if ( this_player()->query_creator() &&
      this_player()->query_name() != _office->query_creator())
        managers += ({lower_case(this_player()->query_name())});
    managers += ({_office->query_creator()});
    if ( ans[0] == 'n' )
        managers -= ({lower_case(this_player()->query_name())});
    if (!sizeof(managers))
    {
        tell_object(this_player(), "\nNo recipients!\n");
        return;
    }
    tell_object(this_player(), "\nSending your memo.\n");
    subject = (subject && subject != "")?" - "+ subject:"";
    AUTO_MAILER->auto_mail(implode(managers, ","),
      this_player()->query_name(), _office->shop_very_short()+
      " manager memo" + subject, "", text, 0, 0);
}
protected void set_long(string long_desc)
{
    long_desc += "Managers can use their own \"office\" commands "
    "from in here.  There is a management policy notice on the wall.\n";
    ::set_long( long_desc );
}
protected void set_office(string path)
{
    _office = path;
    _place = _office->query_place();
    _shop_front = _office->query_shop_front();
    _counter = _office->query_counter();
    _storeroom = _office->query_storeroom();
    _notice = clone_object(SHOP_NOTICE);
    _notice->set_office(_office);
    _notice->set_type(1);
    add_hidden_object(_notice);
}
private void write_memo(string text)
{
    this_player()->do_edit(0, (: end_memo($1,$(text)) :));
}

==================================================
FILE: shops/player_shop/office.c
==================================================

inherit "/std/room/basic_room";
#include <player_shop.h>
#include <mail.h>
#include <board.h>
#include <money.h>
#include <move_failures.h>
#include <refresh.h>
#include "office.h"
private nosave string _proprietor = UNSET_STR,
                      _shop_name = UNSET_STR,
                      _very_short = UNSET_STR,
                      _place = UNSET_STR,
                      _channel = UNSET_STR,
                      _storeroom = "",
                      _shop_front = "",
                      _counter = "",
                      _mgr_office = "",
                      _store_dir = "",
                      _counter_dir = "",
                      _shop_dir = "",
                      _shopkeeper = "",
                      _stock_policy = "",
                      _cab_name = "",
                      _review_month = "",
                      _savedir = "",
                      _creator = CREATOR;
private nosave object _chart = 0,
                      _board = 0,
                      _notice = 0;
private nosave mapping _history = 0,
                       _applicants = 0,
                       _policies = 0,
                       _new_policies = 0,
                       _list = ([]),
                       _times = ([]),
                       _employees = ([]);
private nosave int _call_save = 0,
                   _call_hist = 0,
                   _call_hist_clear = 0,
                   _call_times = 0,
                   _call_hire_list = 0,
                   _call_mail_hirees = 0,
                   _call_summon = 0,
                   _call_emps = 0,
                   _call_review = 0,
                   _call_apps = 0,
                   _call_apps_clear = 0,
                   _call_pols = 0,
                   _call_pols_clear = 0,
                   _call_newpols = 0,
                   _call_newpols_clear = 0;
private string *_retired = ({}),
               *_got_bonus = ({}),
               _last_month = "last month",
               _eom = CREATOR;
private mapping _baddies = ([]),
                _declined = ([]),
                _accounts = (["profit":0,"bonus":0]);
private int _max_emp = MAX_EMP,
            _bonus_val = 0,
            _bonus = 0,
            _pay_val = 4,
            _num_cabinets = MIN_CABINETS,
            _net_takings = 0;
private mixed *_register = ({});
void create()
{
   do_setup++;
   ::create();
   do_setup--;
   if (!do_setup)
   {
      this_object()->setup();
      this_object()->reset();
   }
   seteuid("Room");
   add_property("determinate", "");
   add_help_file("player_shop_office");
}
#include "office_code/admin.c"
#include "office_code/applications.c"
#include "office_code/baddies.c"
#include "office_code/cabinets.c"
#include "office_code/emp_cmd.c"
#include "office_code/lists.c"
#include "office_code/logging.c"
#include "office_code/masked.c"
#include "office_code/memo.c"
#include "office_code/personnel.c"
#include "office_code/policies.c"
#include "office_code/review.c"
#include "office_code/save.c"
#include "office_code/stock.c"
protected void add_manager_exit(string dir, string path)
{
   add_exit(dir, path, "door");
   modify_exit(dir, ({"function", ({this_object(),
     "check_manager"}), "door short", "office door", "door long",
     "There is a sign on the door which reads: \""+ _proprietor+
     "- Private\".\n"}));
   _mgr_office = path;
}
mapping get_applicants()
{
   load_applicants();
   clear_applicants();
   return copy(_applicants + ([]));
}
mapping get_baddies() { return copy(_baddies + ([])); }
string *get_employees()
{
   string *employees = m_indices(_employees);
   foreach (string word in employees)
      if (_employees[word][EMP_POINTS] & SUPERVISOR)
         employees -= ({word});
   return copy(sort_array(employees, 1));
}
string *get_managers()
{
   return copy(sort_array(keys(filter(_employees,
        (: _employees[$1][EMP_POINTS] & MANAGER :))), 1));
}
mapping get_new_policies()
{
   load_new_policies();
   clear_new_policies();
   return copy(_new_policies);
}
mapping get_policies(int type)
{
   load_policies();
   clear_policies();
   if (type)
      return copy(filter(_policies, (: _policies[$1][1] :)));
   else
      return copy(filter(_policies, (: !_policies[$1][1] :)));
}
string *get_retired() { return copy(sort_array(_retired, 1)); }
string *get_supervisors()
{
   string *supervisors = keys(filter(_employees,
        (: _employees[$1][EMP_POINTS] & SUPERVISOR :)));
   foreach (string word in supervisors)
      if (_employees[word][EMP_POINTS] & MANAGER)
         supervisors -= ({word});
   return copy(sort_array(supervisors, 1));
}
int num_employees_in()
{
   int any = 0;
   foreach (string word in m_indices(_employees))
      if (_employees[word][EMP_POINTS] & CLOCKED_IN)
      {
         if (_employees[word][EMP_POINTS] & NPC) continue;
         if (!find_player(word) || !interactive(find_player(word)))
         {
            reset_employee(word, CLOCKED_IN);
            shop_log(GENERAL, word, "was clocked out", UNPAID);
         }
         else any++;
      }
   return any;
}
int query_applicant(string player)
{
   load_applicants();
   clear_applicants();
   if (!sizeof(_applicants)) return FALSE;
   if (_applicants[player]) return copy(_applicants[player][APP_TYPE]);
   return FALSE;
}
int query_baddie(string player)
{
   if (!m_sizeof(_baddies)) return FALSE;
   if (_baddies[player]) return copy(_baddies[player][BAD_TIME]);
   return FALSE;
}
int query_bonus() { return copy(_accounts["bonus"]); }
string query_channel() { return copy(_channel); }
string query_counter() { return copy(_counter); }
void query_creator(string creator) { return copy(_creator); }
int query_declined(string player)
{
   if (!sizeof(_declined)) return FALSE;
   if (_declined[player]) return copy(_declined[player]);
   return FALSE;
}
int query_employee(string player)
{
   if (_employees[player]) return copy(_employees[player][EMP_POINTS]);
   return FALSE;
}
mapping query_employees() { return copy(_employees + ([])); }
string *query_list_array() { return copy(m_indices(_list) + ({})); }
mapping query_list_mapping() { return copy(_list) + ([]); }
string query_list_string()
{
   if (!m_sizeof(_list)) return "absolutely nothing at the moment";
   return query_multiple_short(m_indices(_list));
}
int query_manager(string player)
{
   if (_employees[player]) return (_employees[player][EMP_POINTS] & MANAGER);
   return FALSE;
}
int query_maxemp() { return copy(_max_emp); }
string query_mgr_office() { return copy(_mgr_office); }
int query_num_cabinets() { return copy(_num_cabinets); }
int query_pay() { return copy(_pay_val); }
string query_place() { return copy(_place); }
int query_policy(string policy)
{
   load_policies();
   clear_policies();
   if (m_sizeof(_policies) && _policies[policy]) return 2;
   load_new_policies();
   clear_new_policies();
   if (m_sizeof(_new_policies) && _new_policies[policy]) return 1;
   return 0;
}
int query_profit() { return copy(_accounts["profit"]); }
string query_proprietor() { return copy(_proprietor); }
int query_retired(string player)
{
   return (member_array(player, _retired) == -1)?FALSE:TRUE;
}
string query_savedir() { return copy(_savedir); }
string query_shop_front() { return copy(_shop_front); }
string query_shop_name() { return copy(_shop_name); }
string query_shopkeeper() { return copy(_shopkeeper); }
int query_stock(string items) { return _storeroom->query_num_items(items, 0); }
string query_storeroom() { return copy(_storeroom); }
int query_supervisor(string player)
{
   if (_employees[player])
      return (_employees[player][EMP_POINTS] & SUPERVISOR);
   return FALSE;
}
protected void save_emps()
{
   if (_very_short == UNSET_STR) return;
   remove_call_out(_call_emps);
   _call_emps = call_out((: do_save_emps() :), SAVE_DELAY);
}
protected void save_me()
{
   if (_very_short == UNSET_STR) return;
   remove_call_out(_call_save);
   _call_save = call_out((: do_save() :), SAVE_DELAY);
}
protected void set_channel(string name, int board)
{
   _channel = lower_case(name);
   if (board)
   {
      _board = clone_object("/obj/misc/board");
      _board->set_datafile(name);
      _board->move(this_object());
   }
}
protected void set_counter(string path) { _counter = path; }
protected void set_creator(string creator) { _creator = creator; }
protected void set_directions(string store, string counter, string shop)
{
   _store_dir = store;
   _counter_dir = counter;
   _shop_dir = shop;
}
protected void set_place(string place) { _place = place; }
protected void set_proprietor(string name) { _proprietor = name; }
protected void set_shop_front(string path) { _shop_front = path; }
protected void set_shop_name(string name) { _shop_name = name; }
protected void set_shopkeeper(string path)
{
   _shopkeeper = path;
   path=_shopkeeper->query_name();
   if (!_employees || !_employees[path])
   {
      _employees += ([path:EMP_MAP]);
      _employees[path][EMP_POINTS] = EMPLOYEE + NPC;
   }
}
protected void set_storeroom(string path) { _storeroom = path; }
protected void set_stock_policy(string desc) { _stock_policy = desc; }
protected void set_very_short(string name)
{
   if (PLAYER_SHOP->query_shop(name) != file_name(this_object()))
      return;
   _very_short = name;
   _savedir = sprintf("/save/player_housing/%s/player_shops/%s/",
      lower_case(geteuid(this_object())), name);
   if (file_size(_savedir+ "shop_data.o") > 0)
      unguarded((: restore_object, _savedir+ "shop_data" :));
   if (file_size(_savedir+ "employees") > 0)
      _employees = restore_variable(unguarded((: read_file,
        _savedir+ "employees" :)));
   if (file_size(_savedir+ "times") > 0)
      _times = restore_variable(unguarded((: read_file,
      _savedir+ "times" :)));
   if (file_size(_savedir+ "list") > 0)
      _list = restore_variable(unguarded((: read_file, _savedir+ "list" :)));
}
string shop_very_short() { return copy(_very_short); }

==================================================
FILE: shops/player_shop/shop_front.c
==================================================

inherit "/std/room/basic_room";
#include <player_shop.h>
#include <mail.h>
private nosave class applying_player
{
    int step;
    string *answers;
}
private nosave string _inside = "",
_outside = "",
_office = "",
_counter = "",
_storeroom = "",
_mgr_office = "",
_channel;
private void abort_app(class applying_player);
private void apply(class applying_player);
private string cap_name(string);
int check_employee(string, object, string);
private void confirm_abort(string, class applying_player);
private void confirm_apply(string, string, class applying_player);
private void continue_loop(class applying_player);
string directions_to(string);
private int do_apply();
private int do_cancel();
private int do_complain();
private int do_confirm();
private int do_push();
private int do_suggestion();
private void end_app(class applying_player);
private void end_complaint(string);
private void end_suggestion(string);
private void finish_edit(string, class applying_player);
string query_office();
string query_outside();
protected void set_exit_counter(string);
protected void set_exit_out(string, string);
protected void set_office(string);
string sign_text();
int tinkle_bell(string);
void create()
{
    do_setup++;
    ::create();
    do_setup--;
    add_property("no burial", 1);
    add_property("los", "closed");
    add_property("determinate", "");
    add_item("counter", "The counter divides this room of the shop in two.  "
      "You get the feeling that only employees can pass it.  There's a "
      "%^BOLD%^card%^RESET%^ on the counter that catches your attention, "
      "next to which is a small %^BOLD%^bell%^RESET%^.");
    add_item("card", "The card seems to be a simple form.  One section "
      "seems to allow you to \"apply\" for a job here, whilst the "
      "bottom section could be filled out to make a \"suggestion\".\n"
      "If you wish to \"complain\" about an employee, you may do so here.  "
      "If you have been accepted for employment, you can also \"confirm\" "
      "you accept, or you can \"cancel\" your application at any time.");
    add_item("doorbell", "The bell above the door is positioned so that as the "
      "door passes underneath it, it will ring.");
    add_item(({"bell", "push-bell"}),
      ({"long", "This is a small push-bell for summoning the employees.",
        "push", (: do_push() :)}));
    if (!do_setup)
    {
        this_object()->setup();
        this_object()->reset();
    }
    add_help_file("player_shop_shopfront");
}
void init()
{
    string tp;
    ::init();
    if (!_office || _office == "") return;
    tp = this_player()->query_name();
    _office->summon_shopkeeper();
    add_command("complain", "", (: do_complain() :));
    add_command("suggestion", "", (: do_suggestion() :));
    if (!check_employee("void", this_player(), "void"))
        add_command("apply", "", (: do_apply() :));
    if ( _office->query_applicant(tp) == HIRED)
        add_command("confirm", "employment", (: do_confirm() :));
    if (_office->query_applicant(tp))
        add_command( "cancel", "application", (: do_cancel() :) );
}
private void abort_app(class applying_player player_info)
{
    tell_object(this_player(),
      "Are you sure you want to ABORT the application? ");
    input_to((: confirm_abort($1,$(player_info)) :), 0);
}
private void apply(class applying_player player_info)
{
    object tp = this_player();
    tell_object(tp, "\n\n");
    tell_object(tp, "%^BOLD%^Application for employment with "+
      _office->query_shop_name()+ "%^RESET%^\n\n"
      "Please note that a blank entry will abort your application.\n");
    tell_object(tp, "There are " + query_num(sizeof(APP_QUESTIONS))+
      " questions on this application form.  Please answer them all.  "
      "You will get an opportunity at the end to let us know anything "
      "else about you that seems relevant.\n\n" );
    continue_loop(player_info);
}
private string cap_name(string name)
{
    if (test_player(name))
        return PLAYER_HANDLER->query_cap_name(name);
    else return capitalize(name);
}
int check_employee(string verb, object thing, string special)
{
    if (thing->query_creator() ||
      _office->query_retired(thing->query_name())) return 1;
    return _office->query_employee(thing->query_name());
}
private void confirm_abort(string confirm, class applying_player player_info)
{
    confirm = lower_case(confirm);
    if (strlen(confirm) < 1 || (confirm[0] != 'y' && confirm[0] != 'n'))
    {
        tell_object(this_player(), "Please enter 'yes' or 'no'.\n"
          "Are you sure you want to ABORT the application? ");
        input_to((: confirm_abort($1,$(player_info)) :), 0);
        return ;
    }
    if (confirm[0..0] != "y")
    {
        continue_loop(player_info);
        return ;
    }
    tell_object(this_player(), "Application aborted.\n");
    return;
}
private void confirm_apply(string str, string message,
  class applying_player player_info)
{
    string from, *managers;
    str = lower_case( str );
    if (strlen(str) < 1 || (str[0] != 'y' && str[0] != 'n'))
    {
        tell_object(this_player(), "Are you sure you want to send "
          "the application (Yes or No)? ");
        input_to((: confirm_apply($1,$(message),$(player_info)) :), 0);
        return;
    }
    if(str[0] == 'n')
    {
        confirm_abort("y", player_info);
        return;
    }
    from = (string)this_player()->query_name();
    managers = _office->get_managers();
    if (!sizeof(managers)) managers = ({ _office->query_creator() });
    AUTO_MAILER->auto_mail(implode(managers, ","),
      _office->query_proprietor(), "Application for employment with "+
      _office->shop_very_short(), "", "There is a new application to be "
      "viewed.\nPlease vote on "+ cap_name( from )+ "'s application as "
      "soon as possible.\n", 0, 0);
    _office->add_applicant(from, message);
    tell_object(this_player(), "\nYour application has now been sent "
      "to the managers.  You will hear from us as soon as they have "
      "made a decision.  Thank you for your application, and good luck.\n");
}
private void continue_loop(class applying_player player_info)
{
    string q_str = "Question #"+(player_info->step+1)+": ";
    tell_object(this_player(), "\n%^CYAN%^" + sprintf("%s%-=*s\n",
        q_str, this_player()->query_cols() - strlen(q_str),
        APP_QUESTIONS[player_info->step]) + "%^RESET%^");
    this_player()->do_edit("", (: finish_edit($1,$(player_info)) :), 0);
}
string directions_to(string place)
{
    if (place == _counter || place == _office || place == _storeroom)
        return copy(_inside);
    return "here";
}
private int do_apply()
{
    int awaiting_vacancies = 0;
    mapping applicants;
    string tp = this_player()->query_name();
    class applying_player player_info;
    if (_office->query_applicant(tp))
    {
        tell_object(this_player(), "You've already applied here!\n");
        return 1;
    }
    if (_office->query_declined(tp))
    {
        tell_object(this_player(), "I'm sorry, but you cannot make another "
          "application just yet.\n");
        return 1;
    }
    applicants = _office->get_applicants();
    foreach (string applicant in m_indices(applicants))
    if (applicants[applicant][APP_TYPE] == AWAITING)
        awaiting_vacancies++;
    if ((awaiting_vacancies > (_office->query_maxemp() / 10)))
    {
        tell_object(this_player(), "I'm sorry, but we do not have any "
          "vacancies at the moment.  Please try again at a later date.\n");
        return 1;
    }
    player_info = new(class applying_player);
    player_info->step = 0;
    player_info->answers = ({});
    call_out((: apply($(player_info)) :), 0);
    add_succeeded_mess("");
    return 1;
}
private int do_cancel() { return _office->do_cancel(); }
private int do_complain()
{
    tell_object(this_player(), COMPLAINT_TEXT +
      "  This complaint will then be sent to the managers of the shop.  "
      "If you would rather remain anonymous to the managers, please "
      "contact a liaison, or send a mail with all the above details to "+
      cap_name(_office->query_creator())+ ".\n");
    this_player()->do_edit("%^CYAN%^"+ COMPLAINT_TEXT + "%^RESET%^\n\n",
      (: end_complaint($1) :));
    add_succeeded_mess("");
    return 1;
}
private int do_confirm() { return _office->do_confirm(); }
private int do_push()
{
    if (this_player()->query_property("shop bell pressed"))
        return notify_fail( "Calm down!  You've only just pushed it.  Try "
          "in a minute or so if there's still no reply.\n" );
    if (check_employee("void", this_player(), "void"))
        return notify_fail("There's already an employee here: You!\n");
    if (!_channel || _channel == "")
        return notify_fail( "You push the bell, but no-one can hear you.\n" );
    this_player()->add_property("shop bell pressed", 1, BELL_TIMEOUT);
    HISTORY_HANDLER->add_chat_history(_channel, "Shop: ", this_player()->
      query_short() + " called for assistance.");
    children(BADGE)->receive(_channel, "Shop", this_player()->query_short()+
      " is calling for assistance.");
    add_succeeded_mess("$N $V the bell.\n");
    return 1;
}
private int do_suggestion()
{
    tell_object(this_player(), SUGGEST_TEXT+ "\n");
    this_player()->do_edit("%^CYAN%^"+ SUGGEST_TEXT+ "%^RESET%^\n",
      (: end_suggestion($1) :));
    add_succeeded_mess("");
    return 1;
}
private void end_app(class applying_player player_info)
{
    string message = "";
    for (int i = 0; i < sizeof(APP_QUESTIONS); i++)
    {
        message += "%^CYAN%^" + sprintf("%2d) %-=*s\n", (i+1), 70,
          APP_QUESTIONS[i]) + "%^RESET%^" +
        sprintf("      %-=*s\n\n", 72, player_info->answers[i]);
    }
    tell_object(this_player(), "We have your application as:\n" + message+
      "\nDo you wish to send it? ");
    input_to((: confirm_apply($1,$(message),$(player_info)) :), 0);
}
private void end_complaint(string text)
{
    string *managers;
    if (!text)
    {
        tell_object(this_player(), "Aborted.\n");
        return;
    }
    if (!sizeof(managers = _office->get_managers()))
        managers = ({_office->query_creator()});
    AUTO_MAILER->auto_mail(implode(managers, ","),
      this_player()->query_name(), _office->shop_very_short()+ " complaint",
      "", text, 0, 0);
    tell_object(this_player(), "Your complaint has now been sent to the "
      "managers, and will be dealt with as soon as possible.\n");
}
private void end_suggestion(string text)
{
    string *managers;
    if (!text)
    {
        tell_object( this_player(), "Aborted.\n" );
        return;
    }
    if (!sizeof(managers = _office->get_managers()))
        managers = ({_office->query_creator()});
    AUTO_MAILER->auto_mail( implode( managers, "," ),
      this_player()->query_name(), _office->shop_very_short()+ " suggestion",
      "", text, 0, 0 );
    tell_object(this_player(), "Your suggestion has been sent to the "
      "managers, and will be dealt with as soon as possible.\n");
}
void event_death(object k, object *o, object k2, string r, string k3)
{
    _office->event_death(k,o,k2,r,k3);
}
void event_enter(object ob, string message, object from)
{
    mapping baddies;
    int days;
    string name = ob->query_name();
    if (_office->query_baddie(name))
    {
        baddies = _office->get_baddies();
        days = (((BAN_LENGTH*60*60*24) -
            (time() - baddies[name][2])) / (60*60*24)) + 1;
        tell_room(this_object(), ob->query_short()+
          " drifts out of the door, seemingly against "+
          ob->query_possessive()+ " will.\n", ({ob}));
        tell_object(ob, "You feel yourself pushed out of the shop by "
          "a mysterious force.\nYou have been banned from this shop for "+
          baddies[name][0]+ " and will not be re-admitted for a maximum of "+
          query_num(days)+ " days.\n");
        ob->move(_outside);
    }
}
string long(string word, int dark)
{
    int emps_in = 0;
    if (find_object(_office->query_shopkeeper()) &&
      _office->query_employee(_office->query_shopkeeper()->
        query_name()) & CLOCKED_IN)
    {
        emps_in = 1;
    }
    emps_in += _office->num_employees_in();
    return sprintf("%s%s %s currently clocked in.\n",
      ::long(word,dark), _office->employees_clocked_in(),
      (emps_in == 1)? "is" : "are");
}
private void finish_edit(string message, class applying_player player_info)
{
    if (!message || message == "")
    {
        abort_app(player_info);
        return;
    }
    player_info->answers += ({message});
    player_info->step++;
    if (player_info->step == sizeof(APP_QUESTIONS)) end_app(player_info);
    else continue_loop(player_info);
}
string query_office() { return copy(_office); }
string query_outside() { return copy(_outside); }
protected void set_exit_counter(string direction)
{
    _inside = direction;
    add_exit(direction, _counter, "hidden");
    modify_exit(direction, ({"function", "check_employee"}));
}
protected void set_exit_out(string direction, string path)
{
    _outside = path;
    add_exit(direction, path, "door");
    modify_exit(direction, ({"open/close func", ({this_object(),
          "tinkle_bell"})}));
}
protected void set_office(string path)
{
    _office = path;
    _counter = path->query_counter();
    _mgr_office = path->query_mgr_office();
    _storeroom = path->query_storeroom();
    _channel = path->query_channel();
    set_short( path->query_shop_name() );
    add_sign("A small golden plaque with engraved text.\n",
      (: sign_text :), "small plaque", "plaque",
      "common")->add_property("there", "on one wall");
}
string sign_text()
{
    string *eom = _office->query_eom();
    return sprintf("\n%%^YELLOW%%^  Employee Of The Month for %s : %s%%^RESET%%^\n\n",
       eom[0], cap_name(eom[1]));
}
int tinkle_bell(string action)
{
    tell_room(this_object(), "The bell tinkles as the door "+
      action+ "s.\n");
    tell_room(find_object(_counter), "The bell over the shop door "
      "tinkles.\n");
    tell_room(find_object(_office), "You hear the bell tinkle in "
      "the main room of the shop.\n");
    tell_room(find_object(_storeroom), "You hear the bell tinkle in "
      "the main room of the shop.\n");
    tell_room(find_object(_mgr_office), "You hear the bell tinkle in "
      "the main room of the shop.\n");
    return 1;
}

==================================================
FILE: shops/player_shop/shopkeeper.c
==================================================

inherit "/obj/monster";
#include <player_shop.h>
#include <money.h>
#include <living.h>
#include <move_failures.h>
#define set_busy(O) (_busy = O)
#define reset_busy() (_busy = 0)
#define NOT_EIGHT (({ "between seven and nine", \
                     "just over seven", \
                     "just under nine", \
                     "seven plus one", \
                     "nine minus one", \
                     "two times four", \
                  })[random(5)])
#define num_str(i) ((i == 8)?NOT_EIGHT:query_num(i))
#define DEARIE (", "+ _dearie[random(sizeof(_dearie)-1)])
private nosave object _busy = 0;
private nosave mixed _info = 0;
private nosave string _office = "",
_storeroom = "",
_shop_front = "",
_counter = "",
_place = "",
_smallest_in,
_smallest_plural_in,
*_dearie = ({""});
private nosave int * _work_hrs = ({9,0,17,30,}),
_smallest_value_in,
_failed = 0;
private nosave mapping _values_sing = ([]),
_values_plural = ([]);
private void announce_number();
private void announce_price();
private void buy_something(object *);
private void check_money(mixed);
private void deposit_money();
int do_buy(string);
int do_browse(string);
int do_list(mixed  *);
int do_sell(object *);
private void end_shift();
private void get_from_store();
private void get_money();
private void get_more_stuff();
private void give_stuff();
private void how_many(string);
private void how_much(string);
private void look_chart();
private void look_how_much();
private void no_coins();
private int outside_hours(int);
private void put_in_store();
private int query_busy();
string query_office();
private void say_to_room(object, string, string);
private void sell_something(string);
protected object * item_test(object *);
protected void set_dearie(string *);
void set_failed(int);
protected void set_office(string);
protected void set_work_hours(int *);
void shuffle_to(string,function);
private int sort_keys(string, string, int);
void start_shift();
private void taken_over();
private void what_items();
void create()
{
    do_setup++;
    ::create();
    do_setup--;
    add_property("determinate", "");
    add_property("unique", 1);
    add_property("run away", -1);
    add_alias("shopkeeper");
    if (!do_setup)
    {
        this_object()->setup();
        this_object()->reset();
    }
}
private void announce_number()
{
    if (stringp(_info))
    {
        int number = _storeroom->query_num_items(_info);
        if (!number) do_command("'I'm afraid we don't have any "+ _info +
              " in stock"+ DEARIE+ ".");
        else do_command("'You're in luck"+ DEARIE+ ".  We have "+
              num_str(number) + " in stock.");
    }
    reset_busy();
    _info = 0;
}
private void announce_price()
{
    if (stringp(_info))
        do_command("'We sell "+ _info + " for "+
          num_str(_office->query_sell(_info))+ " "+ _smallest_plural_in+
          " each, and buy them for "+ num_str(_office->query_buy(_info))+
          " "+ _smallest_plural_in + " each.");
    reset_busy();
    _info = 0;
}
void attack_by(object baddie)
{
    if (_office == "") return;
    this_object()->stop_fight(baddie);
    baddie->stop_fight(this_object());
    do_command("'Why are you attacking me, "+ baddie->query_cap_name()+ "?");
    do_command("'I'm not staying here for this!");
    do_command(_office->query_channel()+ "@ is being attacked by "+
      baddie->query_cap_name()+ ".");
    call_out("shuffle_to", NPC_DELAY, _office, (: end_shift() :));
    _office->event_death(this_object(), 0, baddie, 0, 0);
#ifdef DEBUG
    tell_creator(CREATOR,  "Attacked by %s.\n", baddie->query_short());
#endif
}
private void buy_something(object *obs)
{
    int spare, number, amount = 0;
    object *give_back, cont = clone_object("/std/container");
    obs->move(cont);
    _info = ({});
    foreach(string item in _office->query_list_array())
    _info += ((class obj_match)match_objects_in_environments(item, cont))->objects;
    give_back = obs - _info;
    if (sizeof(give_back))
    {
        give_back->move(_busy);
        do_command("'I'm afraid I can't buy "+
          query_multiple_short(give_back)+ " from you"+ DEARIE+ ".");
    }
    if (number = sizeof(_info))
    {
        if (_info[0]->query_collective())
            number = _info[0]->query_amount();
    }
    if (number > (MAX_INVEN + query_dex()))
    {
        _info->move(_busy);
        do_command("'I'm sorry"+ DEARIE+ ", but I can only carry "+
          num_str(MAX_INVEN+ query_dex())+ " items.");
        cont->dest_me();
        reset_busy();
        return;
    }
    give_back = ({});
    give_back = filter(_info, (: ($1)->query_continuous() :));
    if (sizeof(give_back))
    {
        _info -= give_back;
        do_command("'I have nothing to carry "+
          query_multiple_short(give_back)+ " in.");
        give_back->move(_busy);
    }
    give_back = item_test(_info);
    if (sizeof(give_back))
    {
        give_back->move(_busy);
        _info -= give_back;
    }
    if (!(number = sizeof(_info)))
    {
        do_command("'You don't have anything to sell"+ DEARIE+ ".");
        cont->dest_me();
        reset_busy();
        return;
    }
    if (_info[0]->query_collective())
        number = _info[0]->query_amount();
#ifdef DEBUG
    tell_creator(CREATOR,  "Checking stock.\n");
#endif
    spare = _office->query_max(pluralize(_info[0]->query_name())) -
    _office->query_stock(pluralize(_info[0]->query_name()));
    if (spare < 1)
        foreach(string alias in _info[0]->query_alias())
    {
        int check_spare;
        if((check_spare = _office->query_max(pluralize(alias)) -
            _office->query_stock(pluralize(alias))) > 0)
            spare = check_spare;
    }
    if (spare < 1)
        spare = _office->query_max(pluralize(_info[0]->query_short())) -
        _office->query_stock(pluralize(_info[0]->query_short()));
    if (spare < 1)
    {
        do_command("'I'm afraid we don't need any of those"+ DEARIE+ ".");
        _info->move(_busy);
        cont->dest_me();
        reset_busy();
        return;
    }
    if (number > spare)
    {
        do_command("'I'm afraid we don't need that many"+ DEARIE+
          ", but I could take "+ num_str(spare)+ " from you.");
        _info->move(_busy);
        cont->dest_me();
        reset_busy();
        return;
    }
#ifdef DEBUG
    tell_creator(CREATOR,  "Checking money.\n");
#endif
    foreach(string item in _office->query_list_array())
    {
obs = ((class obj_match)match_objects_in_environments(item, this_object()))->objects;
        if (number = sizeof(obs))
        {
            if (obs[0]->query_collective())
                number = obs[0]->query_amount();
            amount += _office->query_buy(item) * number;
        }
        if (_counter->query_register() < amount * _smallest_value_in)
        {
            do_command("'I'm afraid we don't have enough money to buy "+
              query_multiple_short(_info) + " from you" + DEARIE+ ".");
            _info->move(_busy);
            cont->dest_me();
            reset_busy();
            return;
        }
    }
    give_back = ({});
#ifdef DEBUG
    tell_creator(CREATOR,  "Checking we can carry it.\n");
#endif
    if (sizeof(_info))
    {
        obs = _info;
        foreach(object thing in obs)
        if ((int)thing->move(this_object()) != MOVE_OK)
        {
#ifdef DEBUG
            tell_creator(CREATOR,  "Can't carry %O.\n", thing);
#endif            _info -= ({ thing });
            give_back += ({ thing });
        }
        tell_room(environment(this_object()), query_short()+
          " takes "+ query_multiple_short(_info) +".\n");
    }
    obs = all_inventory(cont) - give_back;
    if (sizeof(give_back))
    {
        do_command("'I cannot carry "+ query_multiple_short(give_back, "the")
          +DEARIE+".");
        give_back->move(_busy);
    }
    if (sizeof(obs))
    {
        do_command("'I'm afraid we can't buy "+
          query_multiple_short(obs, "the") +" from you"+ DEARIE+ ".");
        obs->move(_busy);
    }
    obs = all_inventory(cont);
    if (sizeof(obs)) obs->move(environment(_busy),
          "$N manage$s to get knocked onto the floor.");
    if (sizeof(_info))
    {
#ifdef DEBUG
        tell_creator(CREATOR,  "Buying: %O\n", _info);
#endif
        do_command("'I'll be right back.");
        call_out("shuffle_to", NPC_DELAY, _counter, (: get_money() :));
    }
    else reset_busy();
    cont->dest_me();
}
private void check_money(mixed monies)
{
#ifdef DEBUG
    tell_creator(CREATOR, "Buying %d %s for %d each - total %d.\n", monies[1],
      monies[2], monies[3], monies[0] );
#endif
    if (monies[0] > query_value_in(_place))
    {
#ifdef DEBUG
        tell_creator(CREATOR, "No correct change (%d).\n", query_value_in(_place));
#endif
        do_command("put coins in register");
        call_out("shuffle_to", NPC_DELAY, _shop_front, (: no_coins() :));
        return;
    }
    do_command("log shop bought "+ monies[1] +" "+ monies[2] +
      " for "+ (monies[3] * monies[1]));
#ifdef DEBUG
    tell_creator(CREATOR, "Total: %d   My value: %d\n", monies[0],
      query_value_in( _place ) );
#endif
    call_out("shuffle_to", NPC_DELAY, _storeroom, (: put_in_store() :));
}
private void deposit_money()
{
    if (pointerp(_info))
    {
        do_command("log shop sold "+ _info[1]+ " "+ _info[0]+ " for "+
          _info[2]);
        do_command("put coins in register");
    }
    call_out("shuffle_to", NPC_DELAY, _storeroom, (: get_from_store() :));
}
int do_buy(string stuff)
{
#ifdef DEBUG
    tell_creator(CREATOR,  "In do_buy()\n");
#endif
    if (outside_hours(TRUE)) return 1;
    say_to_room(this_player(), "say", "I would like to buy "+ stuff +
      ", please.\n%^RESET%^");
    if (query_busy())
        init_command(":seems busy at the moment.", NPC_DELAY);
    else
    {
        set_busy(this_player());
        call_out((: sell_something($(stuff)) :), NPC_DELAY);
    }
    return 1;
}
int do_browse(string item)
{
#ifdef DEBUG
    tell_creator(CREATOR,  "In do_browse()\n");
#endif
    if (outside_hours(TRUE)) return 1;
    say_to_room(this_player(), "ask", "How much do "+ item +" cost?\n");
    if (query_busy())
        init_command(":seems busy at the moment.", NPC_DELAY);
    else
    {
        set_busy(this_player());
        call_out((: how_much($(item)) :), NPC_DELAY);
    }
    return 1;
}
int do_list(mixed *args)
{
#ifdef DEBUG
    tell_creator(CREATOR,  "In do_list()\n");
#endif
    if (outside_hours(TRUE)) return 1;
    if (!sizeof(args) || !args[0] || args[0] == "")
    {
        say_to_room( this_player(), "ask", "What items do you buy and sell?\n");
        if (query_busy())
            init_command(":seems busy at the moment.", NPC_DELAY);
        else
        {
            set_busy(this_player());
            call_out((: what_items() :), NPC_DELAY);
        }
        return 1;
    }
    say_to_room(this_player(), "ask", "How many "+ args[0]+ " do you have?\n");
    if (query_busy())
        init_command(":seems busy at the moment.", NPC_DELAY);
    else
    {
        set_busy(this_player());
        call_out((: how_many($(args[0])) :), NPC_DELAY);
    }
    return 1;
}
int do_sell(object *obs)
{
#ifdef DEBUG
    tell_creator(CREATOR,  "In do_sell()\n" );
#endif
    if (outside_hours(TRUE)) return 1;
    say_to_room(this_player(), "say", "I would like to sell " +
      query_multiple_short(obs, "the")+ ", please.\n%^RESET%^");
    if (query_busy())
        init_command(":seems busy at the moment.", NPC_DELAY);
    else
    {
        set_busy(this_player());
        call_out((: buy_something($(obs)) :), NPC_DELAY);
    }
    return 1;
}
private void end_shift()
{
    if (environment() != find_object("/room/rubbish"))
        do_command(_office->query_channel()+ "@ is clocking out.");
    do_command("clock out");
    move("/room/rubbish", "$N make$s some tea.", "$N go$s home for tea.");
}
void event_person_say(object thing, string start, string mess, string lang)
{
    string words;
#ifdef DEBUG
    tell_creator(CREATOR,  "In event_person_say()\n" );
#endif
    if (outside_hours(TRUE)) return;
    if (!mess || (mess == "")) return;
    mess = lower_case(mess);
    if (query_busy()) return;
    set_busy(thing);
    if (sscanf(mess, "%*s buy %s, please.", words) == 2)
    {
        call_out((: sell_something($(words)) :), NPC_DELAY);
        return;
    }
    if (sscanf(mess, "%*show many %s", words) == 2)
    {
        call_out((: how_many($(words)) :), NPC_DELAY);
        return;
    }
    if (sscanf(mess, "%*show much %s", words) == 2)
    {
        call_out((: how_much($(words)) :), NPC_DELAY);
        return;
    }
    if (( sscanf( mess, "%*s take over%*s") == 2) &&
      (_office->query_employee(thing->query_name()) ||
        thing->query_name() == CREATOR))
    {
        call_out((: taken_over() :), NPC_DELAY);
        return;
    }
    reset_busy();
    ::event_person_say(thing, start, mess, lang);
}
private void get_from_store()
{
    if (pointerp(_info))
    {
        int number, bag_item_weight, info1 = to_int(_info[1]);
        object *inven;
        _failed = 0;
        if (info1 > (MAX_INVEN + query_dex())) number = MAX_INVEN + query_dex();
        else number = info1;
#ifdef DEBUG
        tell_creator(CREATOR, "Removing %d %s\n", number, _info[0]);
#endif
        inven = all_inventory();
        do_command("remove " + number+ " "+ _info[0]);
        if (_failed)
        {
            do_command("add "+ _failed+ " "+ _info[0]);
            do_command("get "+ _info[0]);
        }
        inven = all_inventory() - inven;
        number -= _failed;
        info1 -= number;
        foreach(object thing in inven)
        if (thing->query_weight() < MAX_BAG_WEIGHT/5)
            bag_item_weight += thing->query_weight();
        bag_item_weight = (MAX_BAG_WEIGHT+bag_item_weight-1)/MAX_BAG_WEIGHT;
        if ( number > 9 )
        {
            number = (((number+9)/10) > bag_item_weight)?
            (number+9)/10:bag_item_weight;
            for(int i=0; i < number; i++) do_command("pull roll");
            for(int i=0; i < number; i++)
                do_command("put "+ _info[0]+ " in bag "+ (i+1));
        }
        if (info1)
        {
            _info[1] = sprintf("%d",info1);
            call_out("shuffle_to", NPC_DELAY, _shop_front,
              (: get_more_stuff() :));
            return;
        }
    }
    call_out("shuffle_to", NPC_DELAY, _shop_front, (: give_stuff() :));
}
private void get_money()
{
    if (pointerp(_info))
    {
        int total;
        mixed monies = ({0,0,0,0,});
        string *sort_keys_sing = sort_array(keys(_values_sing),
          (: sort_keys($1,$2,1) :));
        string *sort_keys_plural = sort_array(keys(_values_plural),
          (: sort_keys($1,$2,0) :));
#ifdef DEBUG
        tell_creator(CREATOR, "Singular: %O\n", sort_keys_sing);
        tell_creator(CREATOR, "Plural: %O\n", sort_keys_plural);
#endif
        foreach(string item in _office->query_list_array())
        {
            object *things = ((class obj_match)match_objects_in_environments(item,
              this_object()))->objects;
#ifdef DEBUG
            tell_creator(CREATOR, "We have %d %s\n", sizeof(things), item);
#endif
            if (monies[1] = sizeof(things))
            {
                if (things[0]->query_collective())
                    monies[1] = things[0]->query_amount();
                monies[3] = _office->query_buy(item);
                do_command( "'"+ capitalize(item) +" are worth "+
                  num_str(monies[3]) +" "+ _smallest_plural_in +
                  " each, and I have "+ num_str(monies[1]) + ".");
                monies[0] += monies[3] * monies[1];
                monies[2] = item;
                break;
            }
        }
        monies[0] *= _smallest_value_in;
        total = monies[0];
        for (int i=0; i < sizeof(sort_keys_sing); i++)
        {
            if (total < _values_sing[sort_keys_sing[i]]) continue;
            for (int c = total / _values_sing[sort_keys_sing[i]]; c > 0; c--)
            {
                string coins = sprintf("%d %s", c,
                  (c == 1)?sort_keys_sing[i]:sort_keys_plural[i]);
#ifdef DEBUG
                tell_creator(CREATOR, "Trying to get %s\n", coins);
#endif
                do_command("get "+ coins+ " from register");
                if (sizeof(match_objects_for_existence(coins, this_object())))
                {
                    total -= (c * _values_sing[sort_keys_sing[i]]);
#ifdef DEBUG
                    tell_creator(CREATOR, "New total: %d\n", total);
#endif
                    break;
                }
            }
        }
#ifdef DEBUG
        tell_creator(CREATOR, "Buying %d %s for %d each.\n", monies[1],
          monies[2], monies[3]);
#endif
        call_out((: check_money($(monies)) :), 1);
    }
    else
        call_out("shuffle_to", NPC_DELAY, _storeroom, (: put_in_store() :));
}
private void get_more_stuff()
{
    if (query_busy())
    {
        do_command("give all to "+ _busy->query_name());
        do_command("drop all");
        do_command("'I still need to get you "+ num_str(to_int(_info[1]))+ " "+
          _info[0]+ DEARIE+ ".  I won't be long.");
        call_out( "shuffle_to", NPC_DELAY, _storeroom,
          (: get_from_store() :) );
        return;
    }
    else
    {
        do_command("'Well now.  I wonder where they could have gone.");
        do_command("ponder");
    }
    do_command("drop all");
    reset_busy();
    _info = 0;
}
private void give_stuff()
{
    if (query_busy())
    {
        do_command("give all to "+ _busy->query_name());
        do_command("'Thank you for your custom" + DEARIE+ ".");
    }
    else
    {
        do_command("'Well now.  I wonder where they could have gone.");
        do_command("ponder");
    }
    do_command("drop all");
    reset_busy();
    _info = 0;
}
private void how_many(string item)
{
    _info = 0;
    foreach (string thing in _office->query_list_array())
    if (sscanf(item, "%*s"+ thing +"%*s") == 2) _info = item;
    if (!_info)
    {
        do_command("'I'm afraid we don't deal in those" + DEARIE+ ".");
        reset_busy();
        return;
    }
    do_command("'"+ capitalize( _info ) +"?  I'll just go and see.");
    call_out("shuffle_to", NPC_DELAY, _office, (: look_chart() :));
}
private void how_much(string item)
{
    _info = 0;
    foreach (string thing in _office->query_list_array())
    if (sscanf(item, "%*s"+ thing +"%*s") == 2) _info = thing;
    if (!_info)
    {
        do_command("'I'm afraid we don't deal in those"+ DEARIE+ ".");
        reset_busy();
        return;
    }
    do_command("'"+ capitalize( _info ) +"?  I'll just go and see.");
    call_out("shuffle_to", NPC_DELAY, _office, (: look_how_much() :));
}
void init()
{
    object tp = this_player();
#ifdef DEBUG
    tell_creator(CREATOR,  "In init()\n" );
#endif
    if (environment(this_object()) == find_object("/room/rubbish")) return;
#ifdef DEBUG
    tell_creator(CREATOR,  "Not in /room/rubbish\n");
#endif
    ::init();
    tp->add_command("buy", this_object(), "<string'item(s)'>",
      (: do_buy($4[0]) :));
    tp->add_command("sell", this_object(), "<indirect:object:me>",
      (: do_sell($1) :));
    tp->add_command("list", this_object(), ({"", "<string'item(s)'>"}),
      (: do_list($4) :));
    tp->add_command("browse", this_object(), "<string'item(s)'>",
      (: do_browse($4[0]) :));
    outside_hours(TRUE);
}
private void look_chart()
{
    if (stringp(_info)) do_command("'Now, let me see, "+ _info +"...");
    call_out("shuffle_to", NPC_DELAY, _shop_front, (: announce_number() :));
}
private void look_how_much()
{
    if (stringp(_info)) do_command("'Now, let me see, "+ _info +"...");
    call_out("shuffle_to", NPC_DELAY, _shop_front, (: announce_price() :));
}
private void no_coins()
{
    if (query_busy())
    {
        do_command("give all to "+ _busy->query_name());
        do_command("'I'm sorry" + DEARIE+ ".  I don't have the correct "
          "change to give you.  Please call again later.");
    }
    else
    {
        do_command("'Well now.  I wonder where they could have gone.");
        do_command("ponder");
    }
    do_command("drop all");
    reset_busy();
    _info = 0;
}
private int outside_hours(int working)
{
    int hrs, mins;
    string am_pm;
    if (query_busy())
    {
#ifdef DEBUG
        tell_creator(CREATOR, "Outside working hours but already busy.  "
          "Continuing.\n");
#endif
        return FALSE;
    }
    if (sscanf(amtime(time()), "%d:%d%s,%*s", hrs, mins, am_pm) == 4)
    {
#ifdef DEBUG
        tell_creator(CREATOR, "Time is %02d:%02d%s.\n", hrs, mins, am_pm);
#endif
        if (am_pm == "am")
        {
            if (hrs == 12) hrs = 0;
        }
        else
        if (hrs != 12) hrs += 12;
#ifdef DEBUG
        tell_creator(CREATOR, "Which is %02d:%02d.\n", hrs, mins);
#endif
        if ((hrs < _work_hrs[0] ||
            (hrs == _work_hrs[0] && mins < _work_hrs[1])) ||
          (hrs > _work_hrs[2] ||
            (hrs == _work_hrs[2] && mins > _work_hrs[3])))
        {
            if (!working)
            {
#ifdef DEBUG
                tell_creator(CREATOR, "Outside working hours & not "
                  "working.  Sending to /room/rubbish.\n");
#endif
                move("/room/rubbish");
                return TRUE;
            }
#ifdef DEBUG
            tell_creator(CREATOR, "Outside working hours & working.  "
              "Sending home now.\n");
#endif
            call_out("shuffle_to", NPC_DELAY, _office, (: end_shift() :));
            return TRUE;
        }
    }
    return FALSE;
}
private void put_in_store()
{
    if (pointerp(_info)) do_command("add all");
    do_command("drop all");
    foreach (string value in keys(_values_sing))
    do_command("get every "+ value);
    call_out("shuffle_to", NPC_DELAY, _shop_front, (: give_stuff() :));
}
private int query_busy()
{
    if (!objectp(_busy) || !interactive(_busy) || _busy->query_invis())
        return 0;
    if (environment(_busy) != find_object(_shop_front)) return 0;
    return (_busy != 0);
}
string query_office() { return copy(_office); }
private void say_to_room(object me, string t, string message)
{
    tell_object(me, "You "+ t+ ": "+ message);
    foreach(object player in all_inventory(environment(this_object())))
    if (interactive(player) && player != me)
        tell_object(player, player->colour_event("say", "%^CYAN%^")+
          me->query_short()+ " "+ t + "s: "+ message);
}
private void sell_something(string items)
{
    int each, number, in_stock;
    mixed *money_array;
    _info = 0;
    foreach (string item in _office->query_list_array())
    if (sscanf(items, "%*s"+ item +"%*s") == 2) _info = item;
    else if (sscanf(pluralize(items), "%*s"+ item +"%*s") == 2)
        _info = item;
    if (!_info)
    {
        do_command("'I'm afraid we don't deal in those"+ DEARIE+ ".");
        reset_busy();
        return;
    }
    if (sscanf(items, "%*s%d "+ _info +"%*s", number) != 3) number = 1;
#ifdef DEBUG
    tell_creator(CREATOR, "Customer asked for %d %s.\n", number, _info);
#endif
    if (number > (in_stock = _storeroom->query_num_items(_info)))
    {
        if (!in_stock)
        {
            do_command("'I'm afraid we don't have any "+ _info+ " in stock"+
              DEARIE+ ".");
            reset_busy();
            return;
        }
        do_command("'I'm afraid we don't have that many "+ _info +
          " in stock, but I can sell you "+ num_str(in_stock)+ ".");
        reset_busy();
        return;
    }
    if (number < 1)
    {
        do_command("'My, my.  You are amusing aren't you" + DEARIE+ "?");
        do_command("peer "+ _busy->query_name());
        reset_busy();
        return;
    }
    each = _office->query_sell(_info);
    do_command( "'"+ capitalize(_info) +" are worth "+
      num_str(each) +" "+ _smallest_plural_in + " each, and you want "+
      num_str(number) + ".");
    each *= number;
    if (_busy->query_value_in(_place) < (each * _smallest_value_in))
    {
        do_command("'I'm afraid you don't have enough money" + DEARIE+ ".");
        reset_busy();
        return;
    }
    money_array = MONEY_HAND->create_money_array(each * _smallest_value_in,
      _place);
    _busy->pay_money(money_array, _place);
    adjust_money(money_array);
#ifdef DEBUG
    tell_creator(CREATOR, "Monies adjusted by %O.\n", money_array);
#endif
    tell_room( environment( this_object() ), query_short()+
      " takes the money.\n" );
    do_command("'I'll be right back"+ DEARIE+ ".");
    _info = ({ _info, sprintf("%d", number), sprintf("%d", each) });
#ifdef DEBUG
    tell_creator(CREATOR,  "Selling: %O\n", _info);
#endif
    call_out("shuffle_to", NPC_DELAY, _counter, (: deposit_money() :));
}
protected object * item_test(mixed * items) { return ({}); }
protected void set_dearie(string *dearie) { _dearie = dearie; }
void set_failed(int failed) { _failed = failed; }
protected void set_office(string path)
{
    mapping values;
    string new_key;
    _office = path;
    _place = _office->query_place();
    _smallest_in = MONEY_HAND->smallest_in( _place );
    _smallest_value_in = MONEY_HAND->smallest_value_in(_place);
    _smallest_plural_in = MONEY_HAND->query_plural_for(_smallest_in);
    values = MONEY_HAND->query_mapped_values_in(_place);
    foreach(string key in keys(values))
    {
        new_key = MONEY_HAND->query_aliases_for(key)[0];
        _values_sing += ([new_key:values[key]]);
    new_key = MONEY_HAND->query_details_for(key)[5];
    _values_plural += ([new_key:values[key]]);
}
#ifdef DEBUG
tell_creator(CREATOR, "Singular values: %O.\n", _values_sing);
tell_creator(CREATOR, "Plural values: %O.\n", _values_plural);
#endif
_storeroom = _office->query_storeroom();
_counter = _office->query_counter();
_shop_front = _office->query_shop_front();
add_respond_to_with(({ "@say", "hello" }), "'Hello, $hcname$.  What can I do for you?");
add_respond_to_with(({ "@smile", query_name() }), "smile at $hname$");
}
protected void set_work_hours(int *hours) { _work_hrs = hours; }
void shuffle_to(string location, function next_action)
{
    string direc = environment()->directions_to(location);
    if (!direc)
    {
        if (environment() == find_object("/room/rubbish")) return;
        if (environment() == _shop_front->query_outside())
        {
            move(_shop_front, "$N enter$s the shop.",
              "$N enter$s _shop_front->query_short().");
        }
        else
        {
            do_command("'I seem to be lost...");
            do_command("sob");
            move(_office, "$N runs in, sobbing.", "$N leave$s, sobbing.");
            end_shift();
            return;
        }
        call_out("shuffle_to", NPC_DELAY, location, next_action);
        return;
    }
    if (direc == "here")
    {
        do_command("smile brightly");
        do_command("'Here we are.");
        if (next_action) call_out(next_action, NPC_DELAY);
        else reset_busy();
        return;
    }
    do_command(direc);
    call_out("shuffle_to", NPC_DELAY, location, next_action);
}
private int sort_keys(string s1, string s2, int sing)
{
    if (sing) return (_values_sing[s1] < _values_sing[s2])?1:-1;
    else return (_values_plural[s1] < _values_plural[s2])?1:-1;
}
void start_shift()
{
#ifdef DEBUG
    tell_creator(CREATOR,  "In start_shift()\n" );
#endif
    if (outside_hours(FALSE)) return;
    set_busy(this_object());
    move(_office, "$N arrive$s for " + query_possessive()+ " shift.");
    if (_office->query_employee(query_name()) & CLOCKED_IN)
        do_command("clock out");
    do_command("claim badge");
    do_command("wear badge");
    do_command("clock in");
    do_command(_office->query_channel()+ "@ is clocking in.");
    call_out("shuffle_to", NPC_DELAY, _shop_front, 0);
}
private void taken_over()
{
    do_command("'Okay then" + DEARIE+ ".  See you later.");
    set_busy(this_object());
    call_out("shuffle_to", NPC_DELAY, _office, (: end_shift() :));
}
private void what_items()
{
    do_command("'Well" + DEARIE+ ", we trade in "+
      _office->query_list_string()+ ".");
    reset_busy();
}

==================================================
FILE: shops/player_shop/storeroom.c
==================================================

inherit "/std/room/basic_room";
#include <player_shop.h>
#include <move_failures.h>
#include "patterns.h"
private nosave string _office = "",
_counter = "",
_mgr_office = "",
_shop_front = "",
_office_dir = "",
_counter_dir = "",
_shop_dir = "";
private nosave object *_cabinets = 0;
private nosave int _num_cabinets, _call_cabs_clear;
private nosave mapping _cache = ([]);
int add_cabinet();
private void clear_cabinets();
string directions_to(string);
private int do_add(object *, mixed *);
private int do_list(mixed *, string);
private int do_remove(mixed *);
private void init_cabinets();
private int pull_roll();
int query_content(int);
int query_num_items(string, int);
string query_office();
int query_stock(string);
string remove_cabinet();
protected void set_directions(string, string, string);
protected void set_office(string);
void create()
{
    do_setup++;
    ::create();
    do_setup--;
    add_property("no burial", 1);
    add_property("determinate", "");
    add_item("cabinet", "There are several cabinets in the room, holding "
      "the entire stock of the shop.  If you are authorised to do so, you "
      "may \"list\" the stock, as well as \"add\" and \"remove\" "
      "items from the cabinets.");
    add_item(({"roll", "bag"}), "You could probably \"pull\" a bag off "
      "the roll and give it to a customer with their purchase.\n"
      "Bags should only be handed out with purchases of 10 or more items.");
    if (!do_setup)
    {
        this_object()->setup();
        this_object()->reset();
    }
    add_help_file("player_shop_storeroom");
}
void init()
{
    ::init();
    if (!_office || _office == "") return;
    add_command("add", ({"<indirect:object:me'item(s)'>",
        "<indirect:object:me'item(s)'> to cabinet <number'cabinet'>"}),
      (: do_add($1,$4) :));
    add_command("pull", "roll", (: pull_roll() :));
    if (_office->query_employee(this_player()->query_name()) ||
      this_player()->query_creator())
    {
        add_command("list", ({LIST_BLANK, LIST_CABINET,
            LIST_ITEM, LIST_ITEM_CABINET}),
          (: do_list($4,$5) :));
        add_command("remove", ({"<number> <string'item(s)'>",
            "<number> <string'item(s)'> from cabinet <number'cabinet'>"}),
          (: do_remove($4) :));
    }
    else if (_office->query_retired(this_player()->query_name()))
        add_command("list", ({LIST_BLANK, LIST_CABINET,
            LIST_ITEM, LIST_ITEM_CABINET}), (: do_list($4,$5) :));
}
int add_cabinet()
{
    object cabinet;
    string cab_name;
    if (previous_object() && previous_object() != find_object(_office))
    {
        LOG_ERROR("storeroom.c", "add_cabinet()");
        return 0;
    }
    if ((_num_cabinets) == MAX_CABINETS) return 0;
    init_cabinets();
    cab_name = "cabinet"+ _num_cabinets++;
    cabinet = clone_object(CABINET);
    cabinet->set_name(cab_name);
    cabinet->set_save_file(_office->query_savedir()+ cab_name);
    _cabinets += ({cabinet});
    return 1;
}
private void clear_cabinets()
{
    if (!_cabinets) return;
#ifdef DEBUG
    tell_creator(CREATOR, "Clearing cabinets.\n");
#endif
    foreach (object cabinet in _cabinets) cabinet->dest_me();
    _cabinets = 0;
}
void dest_me()
{
    remove_call_out(_call_cabs_clear);
    clear_cabinets();
    ::dest_me();
}
string directions_to(string place)
{
    if (place == _counter) return copy(_counter_dir);
    if (place == _office) return copy(_office_dir);
    if (place == _shop_front) return copy(_shop_dir);
    return "here";
}
private int do_add(object *items, mixed *args)
{
    int cab_no = 0;
    object *okay = ({}),
    *failed = ({});
    add_succeeded_mess("");
    if (sizeof(args) > 1)
    {
        cab_no = args[1];
        if (cab_no < 1 || cab_no > _num_cabinets)
        {
            tell_object(this_player(), "That cabinet does not exist!\n");
            return 1;
        }
    }
    init_cabinets();
    foreach (string plural in _office->query_list_array())
    {
        int tot_i, number, temp_num;
        mixed *test;
        parse_command(plural, items, "%i", test);
        if (!test || !sizeof(test)) continue;
        if (!sizeof(_office->query_cabinet(plural)))
        {
            tell_object(this_player(), "There are no cabinets assigned to "+
              plural+ "!\n");
            return 1;
        }
        if ((tot_i = _office->query_max(plural) - query_stock(plural)) < 1)
        {
            tell_object(this_player(),
              "The shop is already fully stocked on "+ plural +".\n");
            test = ({});
            continue;
        }
        test = test[1..];
        if (test[0]->query_collective())
        {
            number = test[0]->query_amount();
        }
        else
        {
            number = sizeof(test);
        }
        if (cab_no)
        {
            int cab_i = 0;
            foreach (object ob in all_inventory(_cabinets[cab_no-1]))
            {
                if (ob->query_collective())
                {
                    cab_i += ob->query_amount();
                }
                else
                {
                    cab_i += 1;
                }
            }
            cab_i = STOCK_PER_CABINET - cab_i;
            if (cab_i < 1)
            {
                tell_object(this_player(), "That cabinet is already full.\n");
                return 1;
            }
            if (member_array(cab_no, _office->query_cabinet(plural)) == -1)
            {
                tell_object(this_player(), plural +
                  " do not belong in that cabinet.\n");
                return 1;
            }
            if (number > cab_i)
            {
                tell_object(this_player(), "You cannot add all of the "+ plural +
                  " to cabinet "+ cab_no+ " without exceeding the maximum.\n");
                if (test[0]->query_collective())
                {
                    object temp = test[0]->make_medium_clone(cab_i);
                    test[0]->adjust_amount(-cab_i);
                    test = ({temp});
                    test->move(this_player());
                }
                else
                {
                    test = test[0 .. (cab_i - 1)];
                }
            }
        }
        else if (number > tot_i)
        {
            tell_object(this_player(), "You cannot add all of the "+ plural +
              " to the stock without exceeding the maximum.\n");
            if (test[0]->query_collective())
            {
                object temp = test[0]->make_medium_clone(tot_i);
                test[0]->adjust_amount(-tot_i);
                test = ({temp});
                test->move(this_player());
            }
            else
            {
                test = test[0 .. (tot_i - 1)];
            }
            number = tot_i;
        }
        temp_num = number;
        if (cab_no)
        {
            object *temp_fail;
            okay += test;
            temp_fail = _cabinets[cab_no - 1]->
            add_items(test, this_player());
            failed += temp_fail;
            if (sizeof(temp_fail))
            {
                temp_num -= temp_fail[0]->query_amount();
            }
            else
            {
                temp_num -= sizeof(temp_fail);
            }
        }
        else
        {
            int cab_i = 0;
            foreach(cab_no in _office->query_cabinet(plural))
            {
                object *temp_fail;
                if (!number) break;
                foreach (object ob in all_inventory(_cabinets[cab_no-1]))
                {
                    if (ob->query_collective())
                    {
                        cab_i += ob->query_amount();
                    }
                    else
                    {
                        cab_i += 1;
                    }
                }
                cab_i = STOCK_PER_CABINET - cab_i;
                if (cab_i < 1) continue;
                if (cab_i > number)
                {
                    cab_i = number;
                }
                if (test[0]->query_collective())
                {
                    object temp = test[0]->make_medium_clone(cab_i);
                    test[0]->adjust_amount(-cab_i);
                    okay += ({temp});
                    temp_fail = _cabinets[cab_no - 1]->
                    add_items(({temp}), this_player());
                }
                else
                {
                    okay += test[0..(cab_i-1)];
                    temp_fail = _cabinets[cab_no - 1]->
                    add_items(test[0 .. (cab_i - 1)], this_player());
                    test -= test[0 .. (cab_i - 1)];
                }
                number -= cab_i;
                failed += temp_fail;
                if (sizeof(temp_fail))
                {
                    if (temp_fail[0]->query_collective())
                    {
                        temp_num -= temp_fail[0]->query_amount();
                    }
                    else
                    {
                        temp_num -= sizeof(temp_fail);
                    }
                }
            }
            if (sizeof(test) && test[0]->query_amount())
            {
                tell_object(this_player(), "There is not enough room in the "
                  "assigned cabinets for "+ query_multiple_short(test)+ ".\n");
                if (test[0]->query_collective())
                {
                    temp_num -= test[0]->query_amount();
                }
                else
                {
                    temp_num -= sizeof(test);
                }
            }
            cab_no = 0;
        }
        test = ({});
        _office->adjust_bought(plural, temp_num);
        if (!_cache[plural])
        {
#ifdef DEBUG
            tell_creator(CREATOR,"Creating %s cache entry.\n", plural);
#endif
            _cache += ([plural:({1,0})]);
        }
        else
        {
            _cache[plural][0] = 1;
        }
    }
    okay -= failed;
    if (sizeof(failed))
    {
        string short = query_multiple_short(failed);
        tell_room(environment(this_player()), this_player()->query_short()+
          " accidentally drops "+ short+
          " on the floor.\n", ({this_player()}));
        tell_object(this_player() , "You accidentally drop "+
          short+ " on the floor.\n");
    }
    if (sizeof(okay))
    {
        string short = query_multiple_short(okay);
        _office->shop_log(PURCHASE, this_player()->query_name(),
          this_player()->convert_message(short)+
          " added to stock", UNPAID);
        add_succeeded_mess("$N $V "+ short+
          " to the stock.\n");
    }
    return 1;
}
private int do_list(mixed *args, string pattern)
{
    object *found_items = ({});
    int i = 0;
    add_succeeded_mess("");
    init_cabinets();
    foreach (object cabinet in _cabinets)
    i += sizeof(all_inventory(cabinet));
    if (!i)
    {
        tell_object(this_player(),
          "There is nothing in stock at the moment.\n");
        return 1;
    }
    if (pattern == LIST_BLANK)
    {
        string result = sprintf("     Stock of %s\n     As at %s\n\n",
          _office->query_shop_name(), ctime(time()));
        foreach(string key in _office->query_list_array())
        {
            found_items = ({});
            found_items += ((class obj_match)match_objects_in_environments(key, _cabinets))->objects;
            if (sizeof(found_items))
                result += query_multiple_short( found_items )+ "\n";
        }
        tell_object(this_player(), "$P$Stock list$P$"+ result);
        return 1;
    }
    if (pattern == LIST_CABINET)
    {
        string result;
        if (args[0] < 1 || args[0] > _num_cabinets)
        {
            tell_object(this_player(), "That cabinet does not exist!\n");
            return 1;
        }
        if (!sizeof(all_inventory(_cabinets[args[0] - 1])))
        {
            result = "There is nothing in that cabinet at the moment.\n";
        }
        else
        {
            result = sprintf("     Stock of cabinet %d\n     As at %s\n\n",
              args[0], ctime(time()));
            foreach(string key in _office->query_list_array())
            {
                if (sizeof(found_items = ((class obj_match)match_objects_in_environments(key,
                        _cabinets[args[0]-1]))->objects ))
                {
                    result += query_multiple_short(found_items)+ "\n";
                }
            }
        }
        tell_object(this_player(), "$P$Cabinet "+ args[0]+
          " stock list$P$"+ result);
        return 1;
    }
    if (pattern == LIST_ITEM)
    {
        string result;
        found_items += ((class obj_match)match_objects_in_environments(args[0], _cabinets))->objects;
        if (!sizeof(found_items))
        {
            tell_object(this_player(),  "There are no "+ args[0]+
              " in stock.\n");
            return 1;
        }
        result = sprintf("     List of %s\n     As at %s\n\n%s", args[0],
          ctime(time()), query_multiple_short(found_items));
        tell_object(this_player(), "$P$List of " + args[0]+ "$P$"+ result);
        return 1;
    }
    if (args[1] < 1 || args[1] > _num_cabinets)
    {
        tell_object(this_player(), "That cabinet does not exist!\n");
        return 1;
    }
    if (!sizeof(all_inventory(_cabinets[args[1] - 1])))
    {
        tell_object(this_player(), "There is nothing in that cabinet at "
          "the moment.\n");
        return 1;
    }
    found_items = ((class obj_match)match_objects_in_environments(args[0],
        _cabinets[args[1]-1]))->objects;
    if (!sizeof(found_items))
    {
        tell_object(this_player(), "There are no "+ args[0]+ " in stock.\n");
        return 1;
    }
    tell_object(this_player(), "$P$List of "+ args[0]+ " in cabinet "+
      args[1]+ "$P$"+ sprintf("     List of %s in cabinet %d\n     "
        "As at %s\n\n%s", args[0], args[1], ctime(time()),
        query_multiple_short(found_items)));
    return 1;
}
private int do_remove(mixed *args)
{
    int cab_no = 0;
    object *items = ({}), *failed;
    failed = ({});
    add_succeeded_mess("");
    if (sizeof(args) > 2) cab_no = args[2];
    if (query_num_items(args[1], cab_no) < args[0])
    {
        tell_object(this_player(), "The stock does not contain "+
          args[0] + " "+ args[1]+ " to remove.\n");
        return 1;
    }
    init_cabinets();
    if (!cab_no)
    {
        int number = args[0];
        for(int i = sizeof(_cabinets); i > 0; i--)
        {
            object *stock = ((class obj_match)match_objects_in_environments(args[1],
                _cabinets[i-1]))->objects;
            if (sizeof(stock))
            {
                if (stock[0]->query_collective())
                {
                    if (stock[0]->query_amount() > number)
                    {
                        object ob = stock[0]->make_medium_clone(number);
                        items += ({ ob });
                        stock[0]->adjust_amount(-number);
                        if (ob->move(this_player()) != MOVE_OK)
                        {
                            ob->move(environment(this_player()));
                            failed += ({ ob });
                        }
                    }
                    else
                    {
                        number -= stock[0]->query_amount();
                        items += stock;
                        failed += _cabinets[i-1]->remove_items(stock, this_player());
                    }
                }
                else
                {
                    if (sizeof(stock) > number) stock = stock[ 0 .. (number-1) ];
                    items += stock;
                    failed += _cabinets[i-1]->remove_items(stock, this_player());
                    number -= sizeof(stock);
                }
            }
            if (!number) break;
        }
    }
    else
    {
        items = ((class obj_match)match_objects_in_environments(args[1],
            _cabinets[cab_no-1]))->objects[0 .. (args[0] - 1)];
        failed = _cabinets[cab_no - 1]->remove_items(items, this_player());
    }
    foreach (string vest in _office->query_list_array())
    {
        if (pluralize(args[1]) == vest)
        {
            args[1] = pluralize(args[1]);
            break;
        }
    }
    if (!_cache[args[1]])
    {
#ifdef DEBUG
        tell_creator(CREATOR,"Creating %s cache entry.\n", args[1]);
#endif
        _cache += ([args[1]:({1,0})]);
    }
    else
    {
        _cache[args[1]][0] = 1;
    }
    items -= failed;
    if (sizeof(failed))
    {
        tell_room(environment(this_player() ), this_player()->query_short()+
          " accidentally drops "+ query_multiple_short(failed)+
          " on the floor.\n", ({this_player()}));
        tell_object(this_player() , "You accidentally drop "+
          query_multiple_short(failed)+ " on the floor.\n");
    }
    if (find_object(_office->query_shopkeeper()) &&
      this_player() == find_object(_office->query_shopkeeper()))
        _office->query_shopkeeper()->set_failed(sizeof(failed));
    if (sizeof(items))
    {
        _office->shop_log(SALE, this_player()->query_name(),
          this_player()->convert_message(query_multiple_short(items))+
          " removed from stock", UNPAID);
        foreach (string plural in _office->query_list_array())
        {
            object *test = ({});
            parse_command(plural, items, "%i", test);
            if (!test || !sizeof(test)) continue;
            _office->adjust_sold(plural, sizeof(test) - 1);
        }
        add_succeeded_mess("$N $V "+ query_multiple_short(items)+
          " from the stock.\n");
    }
    return 1;
}
void event_death(object k, object *o, object k2, string r, string k3)
{
    _office->event_death(k,o,k2,r,k3);
}
void event_enter(object ob, string message, object from)
{
    _office->event_enter(ob, message, from);
}
string long(string word, int dark)
{
    return sprintf("%sThere are currently %d store cabinets "
      "in the room.\n", ::long(word,dark), _num_cabinets);
}
private void init_cabinets()
{
    if (remove_call_out(_call_cabs_clear) == -1 && !_cabinets)
    {
#ifdef DEBUG
        tell_creator(CREATOR, "Initialising cabinets.\n");
#endif
        _cabinets = ({});
        for (int i = 0; i < _num_cabinets; i++)
        {
            string cab_name = "cabinet"+ i;
            object cabinet = clone_object(CABINET);
            cabinet->set_name(cab_name);
            cabinet->set_save_file(_office->query_savedir()+ cab_name);
            _cabinets += ({cabinet});
        }
    }
    _call_cabs_clear = call_out((: clear_cabinets() :), CLEAR_DELAY);
}
private int pull_roll()
{
    object bag;
    string message, day, day2, month;
    bag = clone_object(SHOP_BAG);
    sscanf(amtime(time()), "%*s %s %s %s", day, day2, month);
    if (member_array( month, ({"Offle", "February", "March",
          "April", "May", "June", "Grune", "August", "Spune", "Sektober",
          "Ember", "December", "Ick"}) ) == -1)
        message = sprintf("A very happy %s %s %s\n\nfrom everyone at\n\n%s, %s",
          day, day2, month, _office->query_shop_name(),
          _office->query_place());
    else message = sprintf("With the compliments of\n\n%s, %s.",
          _office->query_shop_name(), _office->query_place());
    bag->set_read_mess(message);
    bag->set_max_cond(400);
    bag->set_cond(400);
    if ((int)bag->move(this_player()) != MOVE_OK)
    {
        bag->move(this_object());
        tell_object(this_player(),
          "You drop the bag as you're carrying too much.\n");
    }
    add_succeeded_mess("$N $V the roll and $I comes off in $p hand.\n",
      ({bag}) );
    return 1;
}
int query_num_items(string item, int cabinet)
{
    object *obs;
    init_cabinets();
    if (cabinet)
    {
        obs = ((class obj_match)match_objects_in_environments(item,
            _cabinets[cabinet-1]))->objects;
        if (!sizeof(obs))
        {
            return 0;
        }
        else if (obs[0]->query_collective())
        {
            return obs[0]->query_amount();
        }
        else
        {
            return sizeof(obs);
        }
    }
    else
    {
        return query_stock(item);
    }
}
string query_office() { return copy(_office); }
int query_stock(string item)
{
    object *obs;
    init_cabinets();
    if (!_cache[item])
    {
#ifdef DEBUG
        tell_creator(CREATOR,"Creating %s cache entry.\n", item);
#endif
        _cache += ([item:({1,0})]);
    }
    if (_cache[item][0])
    {
#ifdef DEBUG
        tell_creator("ringo","Updating %s in cache.\n", item);
#endif
        obs = ((class obj_match)match_objects_in_environments(item, _cabinets))->objects;
        if (!sizeof(obs))
        {
            _cache[item][1] = 0;
        }
        else if (obs[0]->query_collective())
        {
            _cache[item][1] = obs[0]->query_amount();
        }
        else
        {
            _cache[item][1] = sizeof(obs);
        }
        _cache[item][0] = 0;
    }
    return _cache[item][1];
}
string remove_cabinet()
{
    object cabinet;
    if (previous_object() && previous_object() != find_object(_office))
    {
        LOG_ERROR("storeroom.c", "remove_cabinet()");
        return "";
    }
    if ((_num_cabinets) == MIN_CABINETS) return "";
    init_cabinets();
    _num_cabinets--;
    cabinet = _cabinets[_num_cabinets];
    _cabinets -= ({cabinet});
    cabinet->move("/room/rubbish");
    return cabinet->query_name();
}
protected void set_directions(string office, string counter, string shop)
{
    _office_dir = office;
    _counter_dir = counter;
    _shop_dir = shop;
}
protected void set_long(string long_desc)
{
    long_desc += "Employees can \"add\" something to, \"remove\" "
    "something from and \"list\" the stock.\nThere is a roll of "
    "shopping bags conveniently located on one wall.\n";
    ::set_long(long_desc);
}
protected void set_office(string path)
{
    _office = path;
    _counter = _office->query_counter();
    _mgr_office = _office->query_mgr_office();
    _shop_front = _office->query_shop_front();
    _num_cabinets = _office->query_num_cabinets();
}

==================================================
FILE: shops/player_shop/office_code/admin.c
==================================================

private void add_board_message(string subject, string post)
{
   string *employees;
   if (_board)
   {
#ifdef DEBUG
      tell_creator(CREATOR, "Posting message %s to board %s.\n", subject,
        _channel);
#endif
      BOARD_HAND->add_message(_channel, _proprietor,
        subject, post + "--\n"+ _proprietor+ " (proprietor)");
   }
   else
   {
      employees = _retired;
      foreach(string employee in m_indices(_employees))
         if (!(_employees[employee][EMP_POINTS] & NPC))
            employees += ({ employee });
      if (!sizeof(employees))
      {
#ifdef DEBUG
         tell_creator(CREATOR, "No employees to send mail to.\n");
#endif
         return;
      }
      employees += ({CREATOR});
#ifdef DEBUG
      tell_creator(CREATOR, "Sending mail %s to all employees.\n", subject);
#endif
      AUTO_MAILER->auto_mail(implode(employees, ","), _proprietor,
           subject+ " ("+ _very_short+ ")", "", post);
   }
}
private void adjust_bonus(string emp, int amount)
{
   string sign = "";
   _accounts["bonus"] += amount;
   if (amount < 0)
   {
      sign = "-";
      amount = -amount;
   }
   shop_log( ACCOUNTS, emp, sprintf( "adjusted the bonus account by %s%s",
     sign, MONEY_HAND->money_value_string( amount, _place ) ), UNPAID );
   save_me();
}
private void adjust_profit(string emp, int amount)
{
   string sign = "";
   _accounts["profit"] += amount;
   if (amount < 0)
   {
      sign = "-";
      amount = -amount;
   }
   shop_log(ACCOUNTS, emp, sprintf("adjusted the profit account by %s%s",
     sign, MONEY_HAND->money_value_string(amount, _place)), UNPAID);
   save_me();
}
void adjust_takings(int amt)
{
   if (previous_object() && previous_object() != find_object(_counter))
   {
      LOG_ERROR("office.c", "adjust_bought("+amt+")");
      return;
   }
   _net_takings += amt;
   save_me();
}
void calc_bonus()
{
   int bonus_val, bonus_divisor = 0;
   foreach (string str in m_indices(_employees))
   {
      if (_employees[str][EMP_NOBONUS]) continue;
      if (_employees[str][EMP_POINTS] & MANAGER)
      {
         bonus_divisor += 4;
      }
      else if (_employees[str][EMP_POINTS] & SUPERVISOR || _eom == str)
      {
         bonus_divisor += 3;
      }
      else
      {
         bonus_divisor += 2;
      }
   }
   if (!bonus_divisor) bonus_val = _accounts["bonus"];
   else bonus_val = ( _accounts["bonus"] * 2 ) / bonus_divisor;
   tell_object(this_player(), "Based on the bonus fund of "+
     MONEY_HAND->money_value_string(_accounts["bonus"], _place)+
     ", the following bonuses are anticipated:\n"
     "\n     Managers    - "+
     MONEY_HAND->money_value_string(bonus_val * 2, _place)+
     "\n     Supervisors - "+
     MONEY_HAND->money_value_string(to_int(bonus_val * 1.5), _place)+
     "\n     Employees   - "+
     MONEY_HAND->money_value_string(bonus_val, _place)+ "\n");
}
int calc_pay()
{
   int amount = 0;
   foreach(string word in m_indices(_employees))
      amount += _employees[word][EMP_PAY];
   return amount;
}
private string cap_name(string name)
{
   if (!name) return 0;
   if (test_player(name))
      return PLAYER_HANDLER->query_cap_name(name);
   else return capitalize(name);
}
int check_manager( string action )
{
   object tp = this_player();
   string tp_name = tp->query_name();
   if (tp->query_creator() || (_employees[tp_name][EMP_POINTS] & MANAGER) ||
     (member_array(tp_name, _retired) != -1)) return 1;
   return notify_fail( "You are not a manager here!\n" );
}
string directions_to( string place )
{
   if (place == _counter) return copy(_counter_dir);
   if (place == _storeroom) return copy(_store_dir);
   if (place == _shop_front) return copy(_shop_dir);
   return "here";
}
int do_set(mixed *args, string pattern)
{
   int value, best;
   object money;
   switch(pattern)
   {
      case SET_EMPS :
         if (args[0] < MIN_EMP || args[0] > MAX_EMP)
         {
            tell_object(this_player(), "Must be between "+ MIN_EMP+
              " and "+ MAX_EMP+ ".\n");
            return 1;
         }
         shop_log(PERSONNEL, this_player()->query_name(),
           "set maximum employees to "+ args[0], PAID);
         _max_emp = args[0];
         break;
      case SET_PAY :
         money = clone_object( MONEY_OBJECT );
         money->set_money_array(MONEY_HAND->query_values_in(_place));
         if ((best = money->find_best_fit(args[1])) == -1)
         {
            tell_object(this_player(),
              "That currency is not used by the shop.\n");
            return 1;
         }
         value = args[0] * (money->query_money_array())[best + 1];
         money->dest_me();
         if (value < 1)
         {
            tell_object(this_player(),
              "You must pay your employees something.\n");
            return 1;
         }
         shop_log(PERSONNEL, this_player()->query_name(), "set pay to "+
           MONEY_HAND->money_value_string(value, _place), PAID);
         _pay_val = value;
         add_board_message("Pay", sprintf("The base pay rate has today "
           "been set to:\n\n   Managers: %s\n   Supervisors: %s\n   "
           "Employees: %s\n", MONEY_HAND->money_value_string(value * 2, _place),
           MONEY_HAND->money_value_string(to_int(value * 1.5), _place),
           MONEY_HAND->money_value_string(value, _place)));
         break;
   }
   tell_object(this_player(), "Ok.\n");
   save_me();
   return 1;
}
int do_transfer(mixed *args)
{
   int value, best;
   object money;
   string tp;
   if (args[2] == args[3] || !args[0])
   {
      tell_object(this_player(), "The point being?\n");
      return 1;
   }
   tp = this_player()->query_name();
   money = clone_object(MONEY_OBJECT);
   money->set_money_array(MONEY_HAND->query_values_in(_place));
   if ((best = money->find_best_fit(args[1])) == -1)
   {
      tell_object(this_player(), "That currency is not used by "
        "the shop.\n");
      return 1;
   }
   value = args[0] * (money->query_money_array())[best + 1];
   money->dest_me();
   switch(args[2]) {
   case "register" :
      if (_counter->query_register() < value)
      {
         tell_object(this_player(), "There isn't that much available.\n");
         return 1;
      }
      _counter->adjust_register(tp, value);
      if (args[3] == "profit") adjust_profit(tp, value);
      else adjust_bonus( tp, value );
      break;
   case "bonus" :
      if (_accounts["bonus"] < value)
      {
         tell_object(this_player(), "There isn't that much available.\n");
         return 1;
      }
      adjust_bonus(tp, -value);
      if (args[3] == "profit") adjust_profit(tp, value);
      else
      {
         money = MONEY_HAND->make_new_amount(value, _place);
         _counter->add_money_ob(money);
         shop_log(ACCOUNTS, tp, "adjusted the register by "+
           MONEY_HAND->money_value_string(value, _place), UNPAID);
      }
      break;
   case "profit" :
      if (_accounts["profit"] < value)
      {
         tell_object(this_player(), "There isn't that much available.\n");
         return 1;
      }
      adjust_profit(tp, -value);
      if (args[3] == "bonus") adjust_bonus( tp, value );
      else
      {
         money = MONEY_HAND->make_new_amount(value, _place);
         _counter->add_money_ob(money);
         shop_log( ACCOUNTS, tp, "adjusted the register by "+
           MONEY_HAND->money_value_string(value, _place), UNPAID);
      }
      break;
   }
   shop_log (ACCOUNTS, tp, "transferred "+ args[0]+ " "+ args[1]+ " from "+
      args[2]+ " to "+ args[3], PAID);
   tell_object(this_player(), "Ok.\n");
   return 1;
}
private void load_applicants()
{
   if (remove_call_out(_call_apps) != -1 ||
      remove_call_out(_call_apps_clear) != -1) return;
   if (!_applicants)
      if (file_size(_savedir+ "applications") > 0)
         _applicants = restore_variable(unguarded((: read_file,
            _savedir+ "applications" :)));
      else _applicants = ([]);
}
private void load_history()
{
   if (remove_call_out(_call_hist) != -1 ||
      remove_call_out(_call_hist_clear) != -1) return;
   if (!_history)
      if (file_size(_savedir+ "history") > 0)
         _history = restore_variable(unguarded((: read_file,
            _savedir+ "history" :)));
      else _history = ([]);
}
private void load_new_policies()
{
   if (remove_call_out(_call_newpols) != -1 ||
      remove_call_out(_call_newpols_clear) != -1) return;
   if (!_new_policies)
      if ( file_size(_savedir+ "new_policies") > 0 )
         _new_policies = restore_variable(unguarded((: read_file,
            _savedir+ "new_policies" :)));
      else _new_policies = ([]);
}
private void load_policies()
{
   if (remove_call_out(_call_pols) != -1 ||
      remove_call_out(_call_pols_clear) != -1) return;
   if (!_policies)
      if ( file_size( _savedir+ "policies" ) > 0 )
         _policies = restore_variable( unguarded( (: read_file,
            _savedir+ "policies" :) ) );
      else _policies = ([]);
}
string * query_eom() { return ({_last_month,_eom,}); }
private void remove_employee(string employee)
{
   employee = lower_case(employee);
   if (_employees[employee])
   {
      map_delete(_employees, employee);
      save_emps();
   }
   remove_applicant(employee);
   remove_retired(employee);
   remove_call_out(_call_hire_list);
   _call_hire_list = call_out((: check_hire_list() :), 5);
}
private void remove_retired(string retired)
{
   retired = lower_case(retired);
   if (member_array(retired, _retired) == -1) return;
   _retired -= ({retired});
   save_me();
}
private void reset_employee(string word, int bit)
{
   if (!_employees[word]) return;
   if ((bit < EMPLOYEE) || (bit > CLOCKED_IN))
   {
#ifdef DEBUG
      tell_creator(CREATOR, "Trying to reset an employee bit < %d || > %d\n",
         EMPLOYEE, CLOCKED_IN );
#endif
      return;
   }
   _employees[word][EMP_POINTS] -= _employees[word][EMP_POINTS] & bit;
   if (bit != CLOCKED_IN) save_emps();
}
mixed *restore_register() { return copy(_register + ({})); }
void set_employee(string word, int bit)
{
   if (!_employees[word]) return;
   _employees[word][EMP_POINTS] |= bit;
   if (bit != CLOCKED_IN) save_emps();
}
void summon_shopkeeper()
{
   object shopkeeper = find_object(_shopkeeper);
   if (shopkeeper && environment(shopkeeper)) return;
   if (num_employees_in()) return;
   _shopkeeper->start_shift();
}

==================================================
FILE: shops/player_shop/office_code/applications.c
==================================================

void add_applicant(string player, string message)
{
   if (previous_object() && previous_object() != find_object(_shop_front))
   {
      LOG_ERROR("office.c", "add_applicant("+player+","+message+")");
      return;
   }
   player = lower_case(player);
   if (!query_applicant(player))
   {
      load_applicants();
      if (!sizeof(_applicants)) _applicants = ([ player:APP_MAP ]);
      else _applicants += ([ player:APP_MAP ]);
      _applicants[player][APP_TIME] = time();
      _applicants[player][APP_MESSAGE] = message;
      employee_log( player, "Applied for employment" );
      save_applicants();
   }
}
private void add_declined(string applicant)
{
   applicant = lower_case(applicant);
   if (!query_declined(applicant))
   {
      if (!sizeof(_declined)) _declined = ([applicant:0]);
      else _declined += ([applicant:0]);
      _declined[applicant] = time();
      save_me();
   }
}
private void add_vote(string applicant, int vote)
{
   string voter = this_player()->query_name();
   int managers = sizeof(get_managers());
   if (!managers) managers = 1;
   load_applicants();
   if (vote == VABSTAIN) _applicants[applicant][APP_ABSTAIN] += ({voter});
   else if (vote == VFOR) _applicants[applicant][APP_FOR] += ({voter});
   else _applicants[applicant][APP_AGAINST] += ({voter});
   shop_log(GENERAL, voter, "voted on "+ cap_name(applicant), PAID);
   save_applicants();
   managers -= sizeof(_applicants[applicant][APP_ABSTAIN]);
   if (sizeof(_applicants[applicant][APP_FOR]) > managers / 2)
   {
      PLAYER_SHOP->auto_mail(applicant, _proprietor, _shop_name, "",
         "Congratulations!  You've been accepted to work at "+
         _shop_name+ ".  Please return to the shop within the next "
         "seven days to \"confirm\" that you wish to accept "
         "the position.\n");
      _applicants[applicant][APP_TYPE] = HIRED;
      _applicants[applicant][APP_TIME] = time();
      employee_log(applicant, "Application was accepted");
   }
   else if (sizeof(_applicants[applicant][APP_AGAINST]) >=
      managers / 2)
   {
      remove_applicant(applicant);
      PLAYER_SHOP->auto_mail(applicant, _proprietor, _shop_name, "",
         "Thank you for your recent application for employment "
         "with us.  Unfortunately, I have to inform you that you "
         "have been unsuccessful at this time.  Please feel free "
         "to re-apply again in the future, when your application "
         "will be re-considered.\n");
      employee_log(applicant, "Application was declined");
      add_declined(applicant);
   }
}
void check_hire_list()
{
   int count;
   string *hirees = ({});
   load_applicants();
   foreach (string word in m_indices(filter(_applicants,
      (: _applicants[$1][APP_TYPE] == HIRED :))))
      if (time() - _applicants[word][APP_TIME] > HIRE_TIMEOUT)
      {
         PLAYER_SHOP->auto_mail(word, _proprietor,
            _shop_name, "", "Since you have not returned to confirm "
            "your employment with us, we have assumed that you are no "
            "longer interested, and removed your name from our files.  "
            "If you wish to re-apply at any time in the future, please "
            "return to the shop to do so.\n");
         employee_log(word, "Lapsed their application");
         remove_applicant(word);
      }
   foreach (string word in m_indices(filter(_applicants,
      (: _applicants[$1][APP_TYPE] == APPLIED :))))
      if (sizeof(_applicants[word][APP_FOR]) >
         sizeof(get_managers()) / 2)
      {
         PLAYER_SHOP->auto_mail(word, _proprietor, _shop_name, "",
            "Congratulations!  You've been accepted to work at "+
            _shop_name+ ".  Please return to the shop within the next "
            "seven days to \"confirm\" that you wish to accept "
            "the position.\n");
         _applicants[word][APP_TYPE] = HIRED;
         _applicants[word][APP_TIME] = time();
         employee_log(word, "Application was accepted");
      }
      else if (time() - _applicants[word][APP_TIME] > VOTE_TIMEOUT)
      {
         if (sizeof(_applicants[word][APP_FOR]) <=
            sizeof(_applicants[word][APP_AGAINST]))
         {
            remove_applicant(word);
            PLAYER_SHOP->auto_mail(word, _proprietor, _shop_name, "",
               "Thank you for your recent application for employment "
               "with us.  Unfortunately, I have to inform you that you "
               "have been unsuccessful at this time.  Please feel free "
               "to re-apply again in the future, when your application "
               "will be re-considered.\n");
            employee_log(word, "Application was declined");
            add_declined(word);
         }
         else
         {
            PLAYER_SHOP->auto_mail(word, _proprietor, _shop_name, "",
               "Congratulations!  You've been accepted to work at "+
               _shop_name+ ".  Please return to the shop within the next "
               "seven days to \"confirm\" that you wish to accept "
               "the position.\n");
            _applicants[word][APP_TYPE] = HIRED;
            _applicants[word][APP_TIME] = time();
            employee_log(word, "Application was accepted");
         }
      }
   count = _max_emp - sizeof(_employees);
   if (count < 1) return;
   hirees = sort_array(keys(filter(_applicants,
      (: _applicants[$1][APP_TYPE] == AWAITING :))),
      (: _applicants[$1][APP_TIME] - _applicants[$2][APP_TIME] :));
   if (count > sizeof(hirees)) count = sizeof( hirees );
   for (int n = 0; n < count; n++) hire(hirees[n]);
   save_applicants();
}
int do_cancel()
{
   object tp = this_player();
   remove_applicant(tp->query_name());
   employee_log(tp->query_name(), "Cancelled application");
   tell_object(tp, "You cancel your application.\n");
   return 1;
}
int do_confirm()
{
   object tp = this_player();
   string applicant = lower_case(tp->query_name());
   if (previous_object() && previous_object() != find_object(_shop_front))
   {
      LOG_ERROR("office.c", "do_confirm()");
      return 0;
   }
   load_applicants();
   _applicants[applicant][APP_TYPE] = AWAITING;
   _applicants[applicant][APP_TIME] = time();
   tell_object(tp, "You have now been added to "
      "our waiting list.  You will be notified of your position in the "
      "list as it changes.  You may \"cancel\" your application at "
      "any time.  You are currently at position " +
      sizeof(m_indices(filter(_applicants,
      (: _applicants[$1][APP_TYPE] == AWAITING :))))+
      " in the waiting list.\n");
   save_applicants();
   employee_log(applicant, "Confirmed employment");
   tell_object(tp, "You confirm your employment.\n");
   return 1;
}
int do_vote(mixed *args, string pattern)
{
   int query_app;
   string tp = this_player()->query_name();
   if (pattern == VOTE_APPLICANT)
   {
      args[0] = lower_case(args[0]);
      if (!(query_app = query_applicant(args[0])))
      {
         tell_object(this_player(),cap_name(args[0])+
            " hasn't applied!\n");
         return 1;
      }
      if (query_app != APPLIED)
      {
         tell_object(this_player(), cap_name( args[0])+
            " has already been hired!\n");
         return 1;
      }
      load_applicants();
      if (member_array(tp, _applicants[args[0]][APP_FOR]) != -1 ||
         member_array(tp, _applicants[args[0]][APP_AGAINST]) != -1 ||
         member_array(tp, _applicants[args[0]][APP_ABSTAIN]) != -1)
      {
         tell_object(this_player(),
            "You have already voted for this person!\n");
         return 1;
      }
      switch (args[1][0])
      {
      case 'y' :
         add_vote(args[0], VFOR);
         tell_object(this_player(), "You vote for " +
            cap_name( args[0] ) + " to work for the shop.\n");
         break;
      case 'a' :
         add_vote(args[0], VABSTAIN);
         tell_object(this_player(), "You abstain on " +
            cap_name(args[0] ) + ".\n");
         break;
      default :
         add_vote(args[0], VAGAINST);
         tell_object(this_player(), "You vote against " +
            cap_name( args[0] ) + " working for the shop.\n");
      }
      clear_applicants();
   }
   else do_policy_vote(tp, args[0], args[1]);
   return 1;
}
private void mail_hirees()
{
   string *hirees;
   load_applicants();
   hirees = sort_array(keys(filter(_applicants,
      (: _applicants[$1][APP_TYPE] == AWAITING :))),
      (: _applicants[$1][APP_TIME] - _applicants[$2][APP_TIME] :));
   for (int x = 0; x < sizeof(hirees); x++)
      PLAYER_SHOP->auto_mail(hirees[x], _proprietor, _shop_name, "",
         "I am writing to inform you that you have now moved to position "+
         (x + 1)+ " in the employment waiting list.  If you are not near "
         "the top of the list, please be patient.\nThank you.\n");
   clear_applicants();
}
private void remove_applicant(string applicant)
{
   applicant = lower_case(applicant);
   if (query_applicant(applicant))
   {
      load_applicants();
      map_delete(_applicants, applicant);
      save_applicants();
   }
}
private void remove_declined(string declined)
{
   declined = lower_case(declined);
   if (query_declined(declined))
   {
      map_delete(_declined, declined);
      save_me();
   }
}

==================================================
FILE: shops/player_shop/office_code/baddies.c
==================================================

private void add_baddie(string word, string reason, string banner)
{
   object ob;
   word = lower_case(word);
   if (query_baddie(word))
   {
      if (_baddies[word][BAD_TIME] == time() ||
         reason == _baddies[word][BAD_REASON]) return;
      remove_baddie( word );
   }
   if (!sizeof(_baddies)) _baddies = ([word:BAD_MAP]);
   else _baddies += ([word:BAD_MAP]);
   _baddies[word][BAD_REASON] = reason;
   _baddies[word][BAD_BANNER] = banner;
   _baddies[word][BAD_TIME] = time();
   save_me();
   shop_log(GENERAL, banner, "banned "+ cap_name(word)+
      " for "+ reason, PAID);
   employee_log(word, sprintf("Banned by %s for %s.", cap_name(banner),
      reason));
   fire_them(_proprietor, word, reason);
   remove_applicant(word);
   if (!(ob = find_player(word))) return;
   if (environment(ob) == find_object(_shop_front))
   {
      tell_room(_shop_front, ob->query_short()+ " drifts out of the door, "
        "seemingly against "+ ob->query_possessive()+ " will.\n", ({ob}));
      tell_object(ob , "You feel yourself pushed out of the shop "
        "by a mysterious force.\n");
      tell_room(_shop_front->query_outside(), ob->query_short()+
        " drifts through the door of "+ _shop_name +
        ", seemingly against "+ ob->query_possessive()+ " will.\n", ({ob}));
      ob->move(_shop_front->query_outside());
   }
}
int do_ban(mixed *args)
{
   if (!test_player(lower_case(args[0])))
   {
      tell_object(this_player(), args[0]+ " is not a player.\n");
      return 1;
   }
   if (_employees[args[0]][EMP_POINTS] & MANAGER &&
      !this_player()->query_creator())
   {
      tell_object(this_player(), "You cannot ban "+ cap_name(args[0])+
         ".\n");
      return 1;
   }
   add_baddie(args[0], args[1], this_player()->query_name());
   tell_object(this_player(), "You ban "+ cap_name(args[0])+
     " for "+ args[1]+ ".\n");
   return 1;
}
int do_unban(string person)
{
   if (!query_baddie(person))
   {
      tell_object(this_player(), person+ " is not currently banned.\n");
      return 1;
   }
   remove_baddie(person);
   shop_log(GENERAL, this_player()->query_name(),
     "removed the ban on "+ cap_name(person), PAID);
   tell_object(this_player(), "You remove the ban on "+
     cap_name(person)+ ".\n" );
   return 1;
}
private void remove_baddie(string word)
{
   if (!query_baddie(word)) return;
   map_delete(_baddies, word);
   save_me();
}

==================================================
FILE: shops/player_shop/office_code/cabinets.c
==================================================

private void add_chart_cabinet(string word, int number)
{
   if (!_list[word]) return;
   _list[word][CHART_CAB] += ({number});
   _list[word][CHART_CAB] = sort_array(_list[word][CHART_CAB], 1);
   save_list();
}
void confirm_cabinet(string confirm, int rent)
{
   if (previous_object() && previous_object() != this_object())
   {
      LOG_ERROR("office.c", "confirm_cabinet("+confirm+","+rent+")");
      return;
   }
   confirm = lower_case(confirm);
   if ( strlen(confirm) < 1 ||
     (confirm[0] != 'y' && confirm[0] != 'n'))
   {
       tell_object(this_player(), sprintf("Please enter 'yes' or 'no'.\n"
         "Are you sure you want to %s a cabinet? ", (rent)?"rent":"remove"));
       input_to("confirm_cabinet", 0, rent);
       return ;
   }
   if (confirm[0] == 'n')
   {
      tell_object(this_player(), "Ok.\n");
      return;
   }
   if (rent)
      if (_storeroom->add_cabinet())
      {
         _num_cabinets++;
         adjust_profit(this_player()->query_name(), -CABINET_COST);
         shop_log(ACCOUNTS, this_player()->query_name(),
           "rented cabinet for "+ MONEY_HAND->money_value_string(CABINET_COST,
           _place), PAID);
         save_me();
      }
   else
   {
      string cab_name;
      if ((cab_name = _storeroom->remove_cabinet()) != "")
      {
         _num_cabinets--;
         shop_log(ACCOUNTS, this_player()->query_name(),
           "removed cabinet", PAID);
         if (file_size(_savedir+ _cab_name + ".o") > 0)
         {
            _cab_name = cab_name;
            call_out((: rm_cab() :), 5);
         }
         save_me();
      }
   }
   tell_object(this_player(), "Cabinet "+ (rent)?"rent":"remov" + "ed.\n");
}
private int do_check()
{
   string result = "Current cabinet assignments are:\n";
   for (int x = 0; x < _num_cabinets; x++)
   {
      string *items = ({});
      result += sprintf("Cabinet %2d: ", x+1);
      foreach(string item in m_indices(_list))
         if (member_array(x+1, _list[item][CHART_CAB]) != -1)
            items += ({sprintf("%s (%d)", item, _list[item][CHART_MAX])});
      if (sizeof(items)) result += query_multiple_short( items );
      result += "\n";
   }
   result += "\n";
   tell_object(this_player(), "$P$Cabinet assignments$P$"+ result);
   return 1;
}
int do_remove()
{
   int stock;
   if (!((stock = _num_cabinets) > MIN_CABINETS))
   {
      tell_object(this_player(), "The shop already contains the "
        "minimum number of cabinets.\n");
      return 1;
   }
   if (sizeof(_storeroom->query_stock(stock)))
   {
      tell_object(this_player(), "Cabinet "+ stock+
        " still contains stock.\n");
      return 1;
   }
   if (query_cabinet_used(stock))
   {
      tell_object(this_player(), "Cabinet "+ stock+
        " is still assigned to hold stock.\n");
      return 1;
   }
   tell_object(this_player(), "Are you sure you wish to remove a cabinet? ");
   input_to("confirm_cabinet", 0, 0);
   return 1;
}
int do_rent()
{
   if (!(_num_cabinets < MAX_CABINETS))
   {
      tell_object(this_player(), "The shop already contains the "
        "maximum number of cabinets.\n");
      return 1;
   }
   if (CABINET_COST > _accounts["profit"])
   {
      tell_object(this_player(), "Cabinets currently cost "+
        MONEY_HAND->money_value_string(CABINET_COST, _place) +
        ".  There is not enough money in the profit account.\n");
      return 1;
   }
   tell_object(this_player(), "Are you sure you wish to rent a cabinet for "+
     MONEY_HAND->money_value_string( CABINET_COST, _place ) + " per month? ");
   input_to("confirm_cabinet", 0, 1);
   return 1;
}
int *query_cabinet(string item)
{
   return (!_list[item])?({}):copy(_list[item][CHART_CAB]);
}
int query_cabinet_used(int cabinet)
{
   foreach(string word in m_indices(_list))
      if ( member_array(cabinet, _list[word][CHART_CAB]) != -1)
         return TRUE;
   return FALSE;
}
private void remove_chart_cabinet(string word, int number)
{
   if (!_list[word]) return;
   _list[word][CHART_CAB] -= ({number});
   save_list();
}
private void rm_cab()
{
#ifdef DEBUG
   tell_creator(CREATOR, "Removing cabinet file %s.\n",
     _savedir+ _cab_name+ ".o");
#endif
   unguarded((: rm, _savedir+ _cab_name+ ".o" :));
   _cab_name = "";
}

==================================================
FILE: shops/player_shop/office_code/emp_cmd.c
==================================================

private int do_bank(mixed *args)
{
   object tp = this_player();
   string word = tp->query_name();
   if (tp->query_creator())
   {
      tell_object(tp, "Creators don't get paid.\n");
      return 1;
   }
   add_succeeded_mess( "" );
   if ( !sizeof( args ) )
   {
      string message = "You are currently being paid into your account at "+
        BANKS[_employees[word][EMP_BANK]][0]+ ".  To change which bank "
        "you would like your pay to be deposited at, use the command "
        "\"bank <number>\" where <number> is one of the following:\n\n";
      for (int x = 0; x < sizeof(BANKS); x++)
         message += sprintf("     %d: %s\n", x+1, BANKS[x][0]);
      tell_object(tp, message + "\n");
      return 1;
   }
   if (args[0] < 1 || args[0] > sizeof(BANKS))
   {
      tell_object(tp,  "There are "+ sizeof(BANKS)+
        " banks to choose from.\n");
      return 1;
   }
   _employees[word][EMP_BANK] = args[0] - 1;
   save_emps();
   tell_object(tp, "You change your bank details.\n");
   return 1;
}
private int do_claim(string item)
{
   object thing,
          tp = this_player();
   int give_bonus;
   string tp_name = tp->query_name();
   switch(item)
   {
     case "badge" :
        thing = clone_object(BADGE);
        thing->set_props(file_name(this_object()), tp->query_name());
        break;
     case "handbook" :
        thing = clone_object(STAFF_BOOK);
        thing->set_read_mess("\n   "+ _shop_name+ "\n\n"
          "   Staff Handbook\n\n   This handbook belongs to: "+
          tp->query_short()+ "\n\n", "common", 100);
        thing->set_office(file_name(this_object()));
        tp->add_property(_very_short+ " handbook",1);
        break;
     case "bonus" :
        if (member_array(tp_name, _got_bonus) != -1)
        {
           tell_object(tp, "You are not entitled to a "
             "bonus this month!\n");
           return 1;
        }
        if (_employees[tp_name][EMP_POINTS] & MANAGER)
        {
           give_bonus = _bonus_val * 2;
        }
        else if (_employees[tp_name][EMP_POINTS] & SUPERVISOR ||
           _eom == tp_name)
        {
           give_bonus = to_int(_bonus_val * 1.5);
        }
        else
        {
           give_bonus = _bonus_val;
        }
        if (!give_bonus)
        {
           tell_object(tp,  "There is no money in the bonus "
             "fund this month.\n");
           return 1;
        }
        _got_bonus += ({tp_name});
        _bonus -= give_bonus;
        if (_bonus < 0) _bonus = 0;
        thing = MONEY_HAND->make_new_amount(give_bonus, _place);
        shop_log(GENERAL, tp_name, "claimed "+
          MONEY_HAND->money_value_string(give_bonus, _place), UNPAID);
        if (thing->move(tp) != MOVE_OK)
        {
           thing->move(environment(tp));
           tell_object(tp, "You drop "+ thing->query_short()+
             " as you're carrying too much.\n");
        }
        save_me();
        add_succeeded_mess("$N $V "+ MONEY_HAND->
          money_value_string(give_bonus, _place )+ ".\n");
        return 1;
        break;
   }
   if (thing->move(tp) != MOVE_OK)
   {
      thing->move(this_object());
      tell_object(tp, "You drop your "+ item+
        " as you're carrying too much.\n");
   }
   add_succeeded_mess("$N $V a new "+ item+ ".\n");
   return 1;
}
private int do_clock(string clock)
{
   object tp = this_player();
   string word = tp->query_name();
   int pay_them = UNPAID;
   if (tp->query_creator())
   {
      tell_object(tp, "Creators don't clock in or out.\n");
      return 1;
   }
   switch(clock)
   {
     case "in" :
        if (_employees[word][EMP_POINTS] & CLOCKED_IN)
        {
           tell_object(tp, "You are already clocked in!\n");
           return 1;
        }
        remove_call_out(_call_summon);
        if (tp->query_property("no score") &&
           !_employees[word][EMP_NOPROMOTE])
        {
           _employees[word][EMP_NOPROMOTE] = TRUE;
           save_emps();
        }
        pay_them = PAID;
        set_employee(word, CLOCKED_IN);
        break;
     case "out" :
        if (!(_employees[word][EMP_POINTS] & CLOCKED_IN))
        {
           tell_object(tp, "You are already clocked out!\n");
           return 1;
        }
        remove_call_out(_call_summon);
        _call_summon = call_out((: summon_shopkeeper() :), 60);
        reset_employee(word, CLOCKED_IN);
        break;
   }
   add_succeeded_mess("$N $V "+ clock+ ".\n");
   shop_log(GENERAL, word, "clocked "+ clock, pay_them);
   return 1;
}

==================================================
FILE: shops/player_shop/office_code/lists.c
==================================================

string badge_list()
{
   string *results = ({}),
          *creators = ({});
   foreach(object ob in children(BADGE))
   {
      if (ob == find_object(BADGE)) continue;
      if (ob->query_channel() != _channel) continue;
      if (environment(ob)->query_creator())
         creators += ({ environment(ob)->query_name() });
   }
   if (member_array(CREATOR, creators) != -1)
   {
      object ob = find_player(CREATOR);
      creators -= ({CREATOR});
      if (ob && !ob->query_invis())
      {
         string temp_result = ob->query_cap_name() +
            "%^YELLOW%^ (C)%^RESET%^";
         results += ({temp_result});
      }
   }
   if (sizeof(creators))
      foreach(string word in sort_array(creators, 1))
      {
         string temp_result = cap_name(word) +
            "%^YELLOW%^ (C)%^RESET%^";
         results += ({temp_result});
      }
   foreach (string word in sort_array(_retired, 1))
   {
      object ob;
      if (ob = find_player(word))
      {
         string temp_result = "%^CYAN%^"+ ob->query_cap_name() +
            "%^RESET%^ (R)";
         int idle = 0;
         if (interactive(ob))
            idle = query_idle(ob);
         else temp_result += " [net-dead]";
         if (idle > 90)
            temp_result += sprintf(" [idle: %d:%02d]",
               idle  / 60, idle % 60);
         results += ({temp_result});
      }
   }
   foreach (string word in get_managers())
   {
      string temp_result = "";
      object ob;
      if (ob = find_player(word))
      {
         int idle = 0;
         if (interactive(ob))
            idle = query_idle(ob);
         else temp_result += " [net-dead]";
         if (_employees[word][EMP_POINTS] & CLOCKED_IN)
            temp_result = "%^YELLOW%^";
         temp_result += ob->query_cap_name()+ "%^RESET%^ (m)";
         if (idle > 90)
            temp_result += sprintf(" [idle: %d:%02d]",
               idle  / 60, idle % 60);
         results += ({temp_result});
      }
   }
   foreach (string word in get_supervisors())
   {
      string temp_result = "";
      object ob;
      if (ob = find_player(word))
      {
         int idle = 0;
         if (interactive(ob))
            idle = query_idle(ob);
         else temp_result += " [net-dead]";
         if (_employees[word][EMP_POINTS] & CLOCKED_IN)
            temp_result = "%^YELLOW%^";
         temp_result += ob->query_cap_name()+ "%^RESET%^ (s)";
         if (idle > 90)
            temp_result += sprintf(" [idle: %d:%02d]",
               idle  / 60, idle % 60);
         results += ({temp_result});
      }
   }
   foreach (string word in get_employees())
   {
      string temp_result = "";
      object ob;
      if (ob = find_player(word))
      {
         int idle = 0;
         if (interactive(ob))
            idle = query_idle(ob);
         else temp_result += " [net-dead]";
         if (_employees[word][EMP_POINTS] & CLOCKED_IN)
            temp_result = "%^YELLOW%^";
         temp_result += ob->query_cap_name()+ "%^RESET%^";
         if (idle > 90)
            temp_result += sprintf(" [idle: %d:%02d]",
               idle  / 60, idle % 60);
         results += ({temp_result});
      }
   }
   if (!sizeof(results))
      return "\nJust you, I'm afraid.\n";
   return sprintf("\n%s\n", query_multiple_short(results));
}
int do_list()
{
   int emps_in;
   string results = "   Employees of "+ _shop_name + "\n"
                    "     As at " + ctime(time()) + "\n\n";
   foreach (string word in sort_array(_retired, 1))
   {
      object ob = find_player(word);
      if (ob)
         results += "%^GREEN%^";
      results += "     "+ cap_name(word)+
      "%^RESET%^ (retired manager)\n";
   }
   foreach (string word in get_managers())
   {
      object ob = find_player(word);
      if (ob)
      {
         emps_in++;
         results += "%^GREEN%^";
      }
      results += "     "+ cap_name(word)+ "%^RESET%^ (manager)"+
        list_stuff(word);
   }
   foreach (string word in get_supervisors())
   {
      object ob = find_player(word);
      if (ob)
      {
         emps_in++;
         results += "%^GREEN%^";
      }
      results += "     "+ cap_name(word)+ "%^RESET%^ (supervisor)"+
        list_stuff(word);
   }
   foreach (string word in get_employees())
   {
      object ob = find_player(word);
      if (ob)
      {
         emps_in ++;
         results += "%^GREEN%^";
      }
      results += "     "+ cap_name(word)+ "%^RESET%^"+ list_stuff(word);
   }
   results += "\n";
   if (this_player()->query_creator() ||
     _employees[this_player()->query_name()][EMP_POINTS] & MANAGER)
   {
      results += (emps_in == 1)?"   There is one employee ":
                 "   There are "+ query_num(emps_in,0)+ " employees ";
      results += "out of "+ query_num(sizeof(_employees) - 1)+
        " on " + mud_name() + " at the moment, with "+ query_num(num_employees_in(),
          0) + " currently clocked in.\n\n";
   }
   tell_object(this_player(), "$P$Employees$P$"+ results);
   add_succeeded_mess("");
   return 1;
}
private int do_office()
{
   int employee;
   object tp = this_player();
   string tp_name = tp->query_name(),
          board_mess = "";
   if (!_board)
      board_mess = "   memo      - send a memo to the other employees\n";
   add_succeeded_mess("");
   tp = this_player();
   tp_name = tp->query_name();
   if (member_array(tp_name, _retired) != -1)
   {
      tell_object( tp, "As a retired manager, you can use the following "
        "commands:\n"
        "   claim     - claim a badge or handbook\n"
        "   list      - list the other employees of the shop\n"
        "   logs      - review the shop's logs\n"
        "   resign    - terminate your association with Tarnach's\n"+
        board_mess+
        "You may also enter the managers' office for more commands.\n" );
      return 1;
   }
   employee = (tp->query_creator())?SUPERVISOR + MANAGER:
              _employees[tp_name][EMP_POINTS];
   tell_object(tp, "As an employee, you can use the following commands:\n"
     "   clock     - start or finish your working day\n"+
     "   claim     - claim a badge, handbook, or this month's bonus\n"
     "   bank      - set to which bank account you are paid\n"
     "   list      - list the other employees of the shop\n"
     "   promotion - request to be ignored for promotion\n"
     "   resign    - end your employment at the shop\n"+
     board_mess );
   if (employee & SUPERVISOR)
      tell_object( tp, "\nAs a supervisor, you can also use:\n"
        "   chart   - change the information on the sales chart\n"
        "   check   - check cabinet assignments\n"
        "   logs    - review the shop's logs\n" );
   if (employee & MANAGER)
      tell_object( tp, "\nAs a manager you can enter the managers' "
        "office and use the commands listed there.\n" );
   add_succeeded_mess("");
   return 1;
}
string employees_clocked_in()
{
   object *words = ({}), ob;
   if (!num_employees_in()) words = ({"No employees"});
   if (find_object(_shopkeeper) &&
      _employees[_shopkeeper->query_name()][EMP_POINTS] & CLOCKED_IN)
      words = ({_shopkeeper->query_short()});
   foreach (string word in m_indices(_employees))
   {
      ob = find_player(word);
      if (ob && _employees[word][EMP_POINTS] & CLOCKED_IN)
            words += ({ob->query_cap_name()});
   }
   return query_multiple_short(words);
}
private string list_stuff(string word)
{
   string results = "",
          tp = this_player()->query_name();
   if (member_array(word, _retired) != -1) return "\n";
   if (_employees[word][EMP_POINTS] & NPC) return query_worked(word) + "\n";
   if (this_player()->query_creator())
      results = " ["+ (_employees[word][EMP_POINTS] / 32) +"]";
   else if ((word == tp) && !(_employees[word][EMP_POINTS] & MANAGER))
      if (_employees[word][EMP_POINTS] & SUPERVISOR)
         results = " ["+ ((100 * (_employees[word][EMP_POINTS] /
           32 - SUPER_POINTS)) /
           (MANAGER_POINTS - SUPER_POINTS)) +"%]";
      else
         results = " ["+ ((100 * (_employees[word][EMP_POINTS] / 32)) /
           SUPER_POINTS) +"%]";
   if (this_player()->query_creator() || (_employees[tp][EMP_POINTS] & MANAGER))
      results += query_worked(word);
   return results + "\n";
}

==================================================
FILE: shops/player_shop/office_code/logging.c
==================================================

int do_logs(mixed *args, string pattern)
{
    string start, end, file, *files, words;
    add_succeeded_mess("");
    switch (pattern)
    {
    case LOG_BLANK :
        files = get_dir(_savedir +"general.log*");
        words = "Available logs:\n\n";
        if (sizeof(files))
            words += " 1: current log\n";
        for (int i = sizeof(files); i > 1; i--)
        {
            sscanf(unguarded((: read_file, _savedir + files[i-1], 2, 1 :)),
              "%*s, %s:", start);
            sscanf(unguarded((: read_file, _savedir + files[i-1],
                  file_length(_savedir + files[i-1]), 1 :)),
              "%*s, %s: %*s", end );
            if (start == end)
                words += sprintf("%2d: %s\n",
                  sizeof(files)-(i-2), start);
            else
                words += sprintf("%2d: %s to %s\n",
                  sizeof(files)-(i-2), start, end);
        }
        words += "\nUse \"logs <number>\" to read one of them, or \"logs ";
        if ((_employees[this_player()->query_name()] &&
            _employees[this_player()->query_name()][EMP_POINTS] & MANAGER) ||
          this_player()->query_creator())
        {
            words += "{personnel|accounts|chart}\" to view "
            "those logs.\n";
        }
        else
        {
            words += "chart\" to view that log.\n";
        }
        tell_object(this_player(),"$P$Logs$P$"+ words);
        break;
    case LOG_NUMBER :
        files = get_dir(_savedir +"general.log*");
        if ((args[0] < 1) || (args[0] > sizeof(files)))
        {
            tell_object(this_player(), "There are "+ sizeof(files) +
              " logs.  Use \"logs\".\n");
            return 1;
        }
        if (args[0] == 1)
            sscanf(unguarded((: read_file, _savedir +
                  files[0] :)), "%*s\n%s", words);
        else
            sscanf(unguarded((: read_file, _savedir +
                  files[sizeof(files) - (args[0]-1)] :)), "%*s\n%s", words);
        tell_object(this_player(),"$P$Log "+ args[0]+ "$P$"+ words);
        break;
    case LOG_CHART :
        file = _savedir + "chart.log";
        if (file_size(file) > 0)
        {
            sscanf(unguarded((: read_file, file :)), "%s", words);
            tell_object(this_player(),"$P$Chart log$P$"+ words);
        }
        else
        {
            tell_object(this_player(), "The chart log is empty.\n");
            return 1;
        }
        break;
    case LOG_MGR :
        file = _savedir + args[0] + ".log";
        if (file_size( file ) > 0)
        {
            sscanf(unguarded((: read_file, file :)), "%s", words);
            tell_object(this_player(),"$P$"+ capitalize(args[0])+
              " log$P$"+ words);
        }
        else
        {
            tell_object(this_player(), "The "+ args[0]+ " log is empty.\n");
            return 1;
        }
        break;
    }
    return 1;
}
private void employee_log(string employee, string note)
{
    load_history();
    if (!sizeof(_history)) _history = ([employee:({({}),({}),})]);
    else if (!_history[employee]) _history += ([employee:({({}),({}),})]);
    _history[employee][0] += ({time()});
    _history[employee][1] += ({note});
    save_hist();
    remove_call_out(_call_times);
    if (!sizeof(_times)) _times = ([employee:0]);
    else if (!_times[employee]) _times += ([ employee:0 ]);
    _times[employee] = time();
    _call_times = call_out((: save_times() :), PERS_DELAY);
}
void shop_log(int logtype, string word, string words, int paid)
{
    string date, month, colour;
    sscanf(amtime(time()), "%*s %*s %*s %s %*s", month);
    if (file_size(_savedir +"general.log") > 0)
    {
        date = ctime(time())[0 .. 9];
        if (date != unguarded((: read_file,
              _savedir +"general.log", 1, 1 :))[0 .. 9])
        {
            string logfile = _savedir +"general.log-"+ time(),
            summary = sprintf( "%sFor the period ending %s:%s\n",
              "%^BOLD%^", amtime(time()), "%^RESET%^" ),
            sign = "";
            _storeroom->force_load();
            call_out((: update_averages() :), 60);
            unguarded((: rename, _savedir +"general.log", logfile :));
            call_out((: review_employees() :), 5 );
            foreach (string item in m_indices(_list))
            {
                summary += sprintf(" %s - Bought %d, Sold %d\n", capitalize(item),
                  _list[item][CHART_BOUGHT], _list[item][CHART_SOLD]);
                _list[item][CHART_AVESALE] = (_list[item][CHART_AVESALE] +
                  _list[item][CHART_SOLD] + random(2)) / 2;
                _list[item][CHART_SOLD] = 0;
                _list[item][CHART_BOUGHT] = 0;
            }
            save_list();
            if (_net_takings < 0)
            {
                _net_takings = -_net_takings;
                sign = "-";
            }
            summary += sprintf("%sThe net takings of the shop were %s%s.%s\n\n",
              "%^BOLD%^", sign, MONEY_HAND->money_value_string(_net_takings,
                _place), "%^RESET%^");
            _net_takings = 0;
            save_me();
            unguarded((: write_file, _savedir +"general.log",
                date +"\n" + summary :));
            foreach (string file in get_dir(_savedir +"general.log-*"))
            {
                sscanf(file, "%*s-%s", date);
                if (time() - to_int(date) > (60*60*24*LOG_DAYS))
                    unguarded((: rm, _savedir + "general.log-"+ date :));
            }
        }
    }
    if (month != _last_month && !_call_review)
    {
        if (member_array(month, ({"Offle", "February", "March",
              "April", "May", "June", "Grune", "August", "Spune",
              "Sektober", "Ember", "December", "Ick"})) != -1)
        {
            _review_month = month;
            remove_call_out(_call_review);
            _call_review = call_out((: monthly_review() :), 60);
        }
    }
    if (_employees[word])
    {
        if (!(_employees[word][EMP_POINTS] & NPC))
            _employees[word][EMP_EOM]++;
        if (paid && _employees[word][EMP_POINTS] & CLOCKED_IN)
        {
            if (_employees[word][EMP_POINTS] & MANAGER)
                _employees[word][EMP_PAY] += (_pay_val * 2);
            else if (_employees[word][EMP_POINTS] & SUPERVISOR ||
              _eom == word)
            {
                _employees[word][EMP_PAY] += to_int(_pay_val * 1.5);
                _employees[word][EMP_POINTS] += 32;
            }
            else
            {
                _employees[word][EMP_PAY] += _pay_val;
                _employees[word][EMP_POINTS] += 32;
            }
        }
        set_emp_time(word);
        save_emps();
    }
    switch (logtype)
    {
    case PURCHASE :
        colour = "%^GREEN%^";
        break;
    case SALE :
        colour = "%^RED%^";
        break;
    case GENERAL :
        colour = "%^CYAN%^";
        break;
    case PERSONNEL :
        log_file(_savedir+ "personnel.log", "%s: %s - %s\n",
          amtime(time()), cap_name(word), words);
        return;
        break;
    case ACCOUNTS :
        log_file(_savedir+ "accounts.log", "%s: %s - %s\n",
          amtime(time()), cap_name(word), words);
        return;
        break;
    case CHARTLOG :
        log_file(_savedir+ "chart.log", "%s: %s - %s\n",
          amtime(time()), cap_name(word), words);
        return;
        break;
    default :
        colour = "%^RESET%^";
        break;
    }
    unguarded((: write_file, _savedir +"general.log", colour + amtime(time())+
        ": "+ cap_name(word) +"%^RESET%^ - "+ words +"\n" :));
}

==================================================
FILE: shops/player_shop/office_code/masked.c
==================================================

void dest_me()
{
   if (_very_short != UNSET_STR)
   {
      if (remove_call_out(_call_save) != -1) do_save();
      if (remove_call_out(_call_apps) != -1) do_save_applicants();
      if (remove_call_out(_call_hist) != -1) do_save_hist();
      if (remove_call_out(_call_newpols) != -1) do_save_new_policies();
      if (remove_call_out(_call_pols) != -1) do_save_policies();
      if (remove_call_out(_call_times) != -1) save_times();
      if (remove_call_out(_call_emps) != -1) do_save_emps();
   }
   if (_chart) _chart->dest_me();
   if (_board) _board->dest_me();
   if (_notice) _notice->dest_me();
   ::dest_me();
}
void event_death(object killed, object *others, object killer,
  string rmess, string kmess)
{
   if (!killed->query_player() &&
     !(query_employee(killed->query_name()) & NPC)) return;
   if (!killer) return;
   if ((query_employee(killed->query_name()) & NPC)  ||
    (query_employee(killed->query_name())))
   {
      add_baddie(killer->query_name(), "the vicious assault on "+
        killed->query_name(), _proprietor);
      foreach(object baddie in others)
         if (baddie->query_player())
            add_baddie(baddie->query_name(),
              "the vicious assault on "+ killed->query_name(),
              _proprietor);
      return;
   }
   if (query_employee(killer->query_name()) & CLOCKED_IN)
      add_baddie(killer->query_name(), "the vicious assault on "+
        killed->query_name(), _proprietor);
   if (sizeof(others))
      foreach(object baddie in others)
      {
         if (!baddie->query_player()) continue;
         if (query_employee(baddie->query_name())& CLOCKED_IN)
            add_baddie(baddie->query_name(), "the vicious assault on "+
               killed->query_name(), _proprietor);
      }
}
void event_enter(object ob, string message, object from)
{
   string room;
   if (!from || ob->query_creator() || from == find_object("/room/void") ||
     !ob->query_player()) return;
   room = file_name(from);
   if (room == _counter || room == _shop_front || room == _storeroom ||
     room == _mgr_office || from == this_object()) return;
#ifdef DEBUG
   tell_creator(CREATOR, "%s arrived from %O.\n", ob->query_name(), from);
#endif
   fire_them(_proprietor, ob->query_name(), "for teleporting into the shop");
}
void init()
{
   object tp = this_player();
   string word = tp->query_name();
   ::init();
   if (!tp->query_creator() && !_employees[word] &&
     (member_array(word, _retired) == -1)) return;
   add_command("claim", "{badge|handbook|bonus}", (: do_claim($4[0]) :));
   add_command("resign", "", (: do_resign() :));
   add_command("list", "", (: do_list() :));
   add_command("office", "", (: do_office() :));
   if (!_board) add_command("memo", "", (: do_memo() :));
   if (member_array(word, _retired) != -1) return;
   add_command("clock", "{in|out}", (: do_clock($4[0]) :));
   add_command("bank", ({ "", "<number>" }), (: do_bank($4) :));
   if (!this_player()->query_property("no score"))
      add_command( "promotion", "{on|off}", (: do_promote($4[0]) :) );
   if (!tp->query_creator() &&  !(_employees[word][EMP_POINTS] & SUPERVISOR))
      return;
   add_command("chart", ({CHART_ADDITEM, CHART_REMITEM, CHART_MAXITEM,
      CHART_BUYITEM, CHART_SELLITEM, CHART_ASSIGN_ITEM, CHART_UNASSIGN_ITEM}),
     (: do_chart($4,$5) :));
   add_command("check", "cabinets", (: do_check() :));
   if (!tp->query_creator() && !(_employees[word][EMP_POINTS] & MANAGER))
      add_command( "logs", ({LOG_BLANK, LOG_NUMBER, LOG_CHART}),
      (: do_logs($4,$5) :));
   else
      add_command("logs", ({LOG_BLANK, LOG_NUMBER,
        LOG_MGR}), (: do_logs($4,$5) :));
}
void refresh_function(mixed employee, int flag)
{
   string emp_name;
   switch (flag)
   {
      case PLAYER_DELETED :
        emp_name = employee;
        break;
      case TOTAL_REFRESH :
      case PARTIAL_REFRESH :
        emp_name = employee->query_name();
        break;
   }
   if (query_applicant(emp_name))
   {
      remove_employee(emp_name);
      switch (flag)
      {
         case PLAYER_DELETED :
           shop_log(PERSONNEL, emp_name, "deleted character", UNPAID);
           employee_log(emp_name, "Deleted character");
           break;
         case TOTAL_REFRESH :
         case PARTIAL_REFRESH :
           tell_object(employee, "Your application at "+ _shop_name+
             " has been removed.\n");
           shop_log(PERSONNEL, emp_name, "refreshed character", UNPAID);
           employee_log(emp_name, "Refreshed character");
           break;
      }
   }
   if (member_array(emp_name, _retired) != -1)
   {
      remove_employee(emp_name);
      switch (flag)
      {
         case PLAYER_DELETED :
           shop_log(PERSONNEL, emp_name, "deleted character", UNPAID);
           employee_log(emp_name, "Deleted character");
           break;
         case TOTAL_REFRESH :
         case PARTIAL_REFRESH :
           tell_object(employee, "Your employment at "+ _shop_name+
             " has been terminated.\n");
           shop_log(PERSONNEL, emp_name, "refreshed character", UNPAID);
           employee_log(emp_name, "Refreshed character");
           break;
      }
   }
   if (!_employees[emp_name]) return;
   switch (flag)
   {
      case PLAYER_DELETED :
        shop_log(PERSONNEL, emp_name, "deleted character", UNPAID);
        employee_log(emp_name, "Deleted character");
        remove_employee(emp_name);
        break;
      case TOTAL_REFRESH :
        tell_object(employee, "Your employment at "+ _shop_name+
          " has been terminated.\n");
        shop_log(PERSONNEL, emp_name, "refreshed totally", UNPAID);
        employee_log(emp_name, "Refreshed totally");
        remove_employee(emp_name);
        break;
      case PARTIAL_REFRESH :
        tell_object(employee, "Your employment level at "+ _shop_name+
          " has been reset.\n");
        shop_log(PERSONNEL, emp_name, "refreshed character", UNPAID);
        employee_log(emp_name, "Refreshed character");
        _employees[emp_name] = EMP_MAP;
        set_emp_time(emp_name);
        _got_bonus += ({emp_name});
        save_me();
        break;
   }
}
protected void set_long(string long_desc)
{
   string ob_file = file_name(this_object());
   _chart = clone_object(SHOP_CHART);
   _chart->set_office(ob_file);
   add_hidden_object(_chart);
   _notice = clone_object(SHOP_NOTICE);
   _notice->set_office(ob_file);
   add_hidden_object(_notice);
   long_desc += "Employees may \"clock\" in and out of work here "
     "and examine the items chart.  There is also a policy notice "
     "located next to the chart.\n";
   ::set_long(long_desc);
}

==================================================
FILE: shops/player_shop/office_code/memo.c
==================================================

private int do_memo()
{
   tell_object(this_player(), "Subject: (hit enter for general memo)\n");
   input_to((: write_memo($1) :), 0);
   add_succeeded_mess("");
   return 1;
}
private void end_memo(string text, string subject)
{
   if (!text)
   {
      tell_object(this_player(), "Aborted.\n");
      return;
   }
   tell_object(this_player(), "Do you want to keep a copy of the memo? ");
   input_to((: send_memo($1,$(subject),$(text)) :), 0);
}
private void send_memo(string ans, string subject, string text)
{
   object tp = this_player();
   string *employees = _retired,
          tp_name = tp->query_name();
   tp = this_player();
   tp_name = tp->query_name();
   ans = lower_case(ans);
   if (strlen(ans) < 1 || (ans[0] != 'y' && ans[0] != 'n'))
   {
      tell_object(tp,
        "Do you want to keep a copy of the memo? (Yes or No)? ");
      input_to((: send_memo($1,$(subject),$(text)) :), 0);
      return;
   }
   if (tp->query_creator() && tp_name != _creator)
      employees += ({tp_name});
   employees += ({_creator});
   foreach(string employee in m_indices(_employees))
      if (!(_employees[employee][EMP_POINTS] & NPC))
         employees += ({employee});
   if (ans[0] == 'n') employees -= ({tp_name});
   if (!sizeof(employees))
   {
#ifdef DEBUG
      tell_creator(CREATOR, "No employees to send mail to.\n");
#endif
      tell_object(tp, "There is no-one to send a memo to!\n");
      return;
   }
#ifdef DEBUG
   tell_creator(CREATOR, "Sending employee memo to %s.\n",
     implode(employees, "," ));
#endif
   tell_object( tp, "Sending your memo.\n" );
   if (subject && subject != "") subject = " - " + subject;
   else subject = "";
   AUTO_MAILER->auto_mail(implode(employees, ","),
     tp_name, _very_short+ " employee memo" + subject, "", text, 0, 0);
}
private void write_memo(string text)
{
   this_player()->do_edit(0, (: end_memo($1,$(text)) :));
}

==================================================
FILE: shops/player_shop/office_code/personnel.c
==================================================

private void add_employee(string player)
{
    if (!_employees[player])
    {
        _employees += ([player:EMP_MAP]);
        _employees[player][EMP_NOBONUS] = 1;
        set_emp_time(player);
        _got_bonus += ({player});
        save_me();
        save_emps();
    }
}
private void demote(string demoter, string demotee)
{
    int points = _employees[demotee][EMP_POINTS] & CLOCKED_IN;
    if (_employees[demotee][EMP_POINTS] & MANAGER)
        points += (SUPER_POINTS * 32) + EMPLOYEE + SUPERVISOR;
    else points += EMPLOYEE;
    _employees[demotee][EMP_POINTS] = points;
    save_emps();
    PLAYER_SHOP->auto_mail(demotee, _proprietor, "Demotion", "",
      "This is to advise you that you have today been demoted.\n"
      "This demotion will now stay on your employment record.\n");
    employee_log(demotee, "Demoted by "+ demoter);
    shop_log(PERSONNEL, demoter, "demoted "+ cap_name(demotee), PAID);
}
int do_commend(string emp)
{
    string commender;
    if (!_employees[emp])
    {
        tell_object(this_player(), cap_name(emp)+
          " is not an active employee!\n");
        return 1;
    }
    if (_employees[emp][EMP_POINTS] & MANAGER)
    {
        tell_object(this_player(), "You can't commend a manager.\n");
        return 1;
    }
    if (_employees[emp][EMP_POINTS] & NPC)
    {
        tell_object(this_player(), "Don't be silly!  "
          "You can't commend $C$"+ emp +".\n");
        return 1;
    }
    commender = this_player()->query_cap_name();
    AUTO_MAILER->auto_mail(emp, lower_case(commender), "Commendation",
      "", "This is to advise you that you have today received a "
      "commendation for outstanding service.\nThis will now stay on "
      "your employment record.\n");
    employee_log(emp, "Received a commendation from "+ commender);
    shop_log(PERSONNEL, commender, "commended "+ cap_name(emp), PAID);
    _employees[emp][EMP_POINTS] += (_employees[emp][EMP_POINTS] & SUPERVISOR)?
    to_int(MANAGER_POINTS * 0.05 * 32) : to_int(SUPER_POINTS * 0.05 * 32);
    save_emps();
    tell_object(this_player(), "You commend "+ cap_name(emp)+ ".\n");
    return 1;
}
int do_demote(string emp)
{
    object tp = this_player();
    emp = lower_case(emp);
    if (!_employees[emp])
    {
        tell_object(tp, cap_name(emp)+ " is not an active employee!\n");
        return 1;
    }
    if (_employees[emp][EMP_POINTS] & MANAGER && !tp->query_creator())
    {
        tell_object(tp, "You don't have the authority to "
          "demote $C$"+ emp +".\n");
        return 1;
    }
    if (!( _employees[emp][EMP_POINTS] & SUPERVISOR))
    {
        tell_object(tp, "Don't be silly!  You can't demote $C$"+
          emp +".\n");
        return 1;
    }
    demote(tp->query_cap_name(), emp);
    tell_object(tp, "You demote "+ cap_name(emp)+ ".\n");
    return 1;
}
int do_fire(mixed *args)
{
    args[0] = lower_case(args[0]);
    if (!_employees[args[0]])
    {
        tell_object(this_player(), cap_name(args[0])+
          " doesn't work at the shop!\n");
        return 1;
    }
    if ((member_array(args[0], _retired) != -1) ||
      query_manager(args[0]) && !this_player()->query_creator())
    {
        tell_object(this_player(), "You don't have the authority "
          "to fire $C$"+ args[0] +".\n");
        return 1;
    }
    if (_employees[args[0]][EMP_POINTS] & NPC)
    {
        tell_object(this_player(), "Don't be silly!  You can't fire $C$"+
          args[0] +".\n");
        return 1;
    }
    fire_them(this_player()->query_name(), args[0], args[1]);
    tell_object(this_player(), "You fire "+ cap_name(args[0])+
      " for "+ args[1]+ ".\n" );
    return 1;
}
int do_leave(mixed *args)
{
    object tp = this_player();
    args[0] = lower_case(args[0]);
    if (!_employees[args[0]])
    {
        tell_object(tp, cap_name(args[0])+ " is not an employee!\n");
        return 1;
    }
    if (args[1] > MAX_LEAVE)
    {
        tell_object(tp, "You cannot place an employee on leave "
          "for more than "+ MAX_LEAVE+ " days at a time.\n");
        return 1;
    }
    _times[args[0]] = time() + (args[1] * 86400);
    remove_call_out(_call_times);
    _call_times = call_out((: save_times() :), PERS_DELAY);
    add_succeeded_mess(cap_name(args[0])+
      " is on leave until "+ ctime(time() + (args[1] * 86400))+ ".\n");
    shop_log(PERSONNEL, tp->query_name(), "placed "+
      cap_name(args[0])+ " on leave for " + args[1]+ " days", PAID);
    employee_log(args[0], "Placed on leave by "+ tp->query_cap_name()+
      " for "+ args[1]+ " days.");
    tell_object(tp, "You place "+ cap_name(args[0])+
      " on leave for " + args[1]+ " days.\n");
    return 1;
}
private int do_promote(string on)
{
    object tp = this_player();
    add_succeeded_mess("");
    if (tp->query_creator())
    {
        tell_object(tp, "Creators don't get promoted.\n");
        return 1;
    }
    switch (on)
    {
    case "off" :
        _employees[tp->query_name()][EMP_NOPROMOTE] = TRUE;
        tell_object(tp, "You have now requested to be "
          "passed over for promotion.\n");
        break;
    case "on" :
        if (tp->query_property("no score"))
        {
            tell_object(tp, "Sorry, you cannot be promoted.\n");
            return 1;
        }
        _employees[tp->query_name()][EMP_NOPROMOTE] = FALSE;
        tell_object(tp, "You have now requested to be "
          "considered for promotion.\n");
        break;
    }
    save_emps();
    return 1;
}
private int do_resign()
{
    string word = this_player()->query_name();
    add_succeeded_mess("$N $V.\n");
    remove_employee(word);
    shop_log(PERSONNEL, word, "resigned", UNPAID);
    employee_log(word, "Resigned");
    return 1;
}
int do_retire()
{
    string manager = this_player()->query_name();
    if (!(_employees[manager][EMP_POINTS] & MANAGER)) return 0;
    remove_employee(manager);
    _retired += ({manager});
    shop_log(PERSONNEL, manager, "retired from management", UNPAID);
    employee_log(manager, "Retired from management");
    save_me();
    add_succeeded_mess("$N retire$s.\n");
    return 1;
}
int do_suspend(mixed *args)
{
    string suspender;
    object tp = this_player();
    args[0] = lower_case(args[0]);
    if (!_employees[args[0]])
    {
        tell_object(tp, cap_name(args[0])+ " is not an active employee!\n");
        return 1;
    }
    if ((_employees[args[0]][EMP_POINTS] & MANAGER) &&
      (!tp->query_creator()))
    {
        tell_object(tp, "You don't have the authority to "
          "suspend $C$"+ args[0] +"'s bonus.\n");
        return 1;
    }
    if (_employees[args[0]][EMP_POINTS] & NPC)
    {
        tell_object(tp, "Don't be silly!  "
          "You can't suspend $C$"+ args[0] +"'s bonus.\n");
        return 1;
    }
    suspender = tp->query_cap_name();
    _employees[args[0]][EMP_NOBONUS] = args[1];
    save_emps();
    AUTO_MAILER->auto_mail(args[0], _proprietor, "Suspended bonus", "",
      sprintf( "This is to advise you that you have had your bonus "
        "entitlement suspended for %d month%s.\nThis suspension will "
        "now stay on your employment record.\n", args[1],
        (args[1] == 1)?"":"s"));
    employee_log(args[0], sprintf("Bonus suspended for %d month%s by %s",
        args[1], (args[1] == 1)?"":"s", suspender));
    shop_log(PERSONNEL, suspender,
      sprintf("suspended %s's bonus for %d month%s", args[0],
        args[1], (args[1] == 1)?"":"s"), PAID);
    tell_object(tp, "You suspend "+ cap_name(args[0])+
      "'s bonus for "+ args[1]+ " months.\n");
    return 1;
}
int do_warn(mixed *args)
{
    string warner;
    object tp = this_player();
    int points;
    args[0] = lower_case(args[0]);
    if (!_employees[args[0]])
    {
        tell_object(tp, cap_name(args[0])+ " is not an active employee!\n");
        return 1;
    }
    if (_employees[args[0]][EMP_POINTS] & MANAGER && !tp->query_creator() )
    {
        tell_object( tp, "You don't have the authority to "
          "warn $C$"+ args[0] +".\n" );
        return 1;
    }
    if (_employees[args[0]][EMP_POINTS] & NPC)
    {
        tell_object(tp, "Don't be silly!  You can't warn $C$"+ args[0] +".\n");
        return 1;
    }
    warner = tp->query_cap_name();
    AUTO_MAILER->auto_mail(args[0], _proprietor, "Official warning", "",
      "This is to advise you that you have today received a formal "
      "warning for " + args[1] + ".\nThis warning will now stay on "
      "your employment record.\n");
    employee_log(args[0], "Received a warning from "+ warner+
      " for "+ args[1]);
    shop_log(PERSONNEL, warner, "warned "+
      cap_name( args[0] ) + " for "+ args[1], PAID);
    points = _employees[args[0]][EMP_POINTS] & CLOCKED_IN;
    if (_employees[args[0]][EMP_POINTS] & SUPERVISOR)
        _employees[args[0]][EMP_POINTS] -= to_int(MANAGER_POINTS * 0.05 * 32);
    else
    {
        _employees[args[0]][EMP_POINTS] -= to_int(SUPER_POINTS * 0.05 * 32) +
        EMPLOYEE;
        if (_employees[args[0]][EMP_POINTS] < 1)
            _employees[args[0]][EMP_POINTS] = EMPLOYEE + points;
    }
    save_emps();
    tell_object(tp, "You warn "+ cap_name(args[0])+ " for "+
      args[1]+ ".\n");
    return 1;
}
private void fire_them(string word, string them, string reason)
{
    if (!_employees[them]) return;
    BANK_HANDLER->adjust_account(them, BANKS[_employees[them][EMP_BANK]][1],
      _employees[them][EMP_PAY]);
    shop_log(ACCOUNTS, _proprietor, "paid "+
      MONEY_HAND->money_value_string(_employees[them][EMP_PAY], _place)+
      " to "+ cap_name(them), UNPAID);
    shop_log(PERSONNEL, word, "fired "+ cap_name(them) +
      " for "+ reason, PAID);
    PLAYER_SHOP->auto_mail(them, word, _shop_name, "",
      "Unfortunately, I have to inform you that you have today "
      "been fired for " + reason + ".  You have been paid the sum of "+
      MONEY_HAND->money_value_string( _employees[them][EMP_PAY], _place )+
      " for the work you have carried out to this date.\nIf you feel you "
      "have been unfairly dismissed, please refer to a manager.\n");
    employee_log(them, "Fired by "+ cap_name(word)+
      " for "+ reason);
    remove_employee(them);
}
private void hire(string word)
{
    int gender;
    remove_applicant(word);
    if (!test_player(word) || _employees[word] || query_baddie(word)) return;
    add_employee(word);
    employee_log(word, "Hired");
    shop_log(PERSONNEL, _proprietor, "hired "+ cap_name(word), UNPAID);
    PLAYER_SHOP->auto_mail(word, _proprietor, _shop_name, "",
      "Congratulations!  You've been hired to work at "+ _shop_name+
      ".  You'll find that you can now move through the counter "
      "to the back areas of the shop.  The first things you should "
      "do are \"claim\" a new badge and staff handbook.\n");
    gender = PLAYER_HANDLER->test_gender(word);
    add_board_message("New employee", sprintf("%s has today been employed to "
        "work for the shop.  Please make %s feel welcome, and assist %s while "
        "%s gets started in %s new position.\n", cap_name(word),
        ({"it", "him", "her"})[gender] ,({"it", "him", "her"})[gender],
        ({"it", "he", "she"})[gender], ({"its", "his", "her"})[gender]));
    remove_call_out(_call_mail_hirees);
    _call_mail_hirees = call_out((: mail_hirees() :), 5);
}
private string query_worked(string emp)
{
    string blurb;
    if (_employees[emp][EMP_POINTS] & CLOCKED_IN)
        return " is currently clocked in";
    if (_employees[emp][EMP_POINTS] & NPC)
        return " has gone home for tea";
    if (_times[emp] > time())
        return " - %^CYAN%^on leave until "+ ctime(_times[emp])+ "%^RESET%^";
    blurb = " - last action ";
    if (_employees[emp][EMP_POINTS] & MANAGER)
    {
        if ((time() - _times[emp]) > ((60*60*24*MGR_DEMOTE)-7))
            blurb += "%^RED%^";
        else if ((time() - _times[emp]) > (60*60*24*MGR_WARN))
            blurb += "%^RED%^";
    }
    else if (_employees[emp][EMP_POINTS] & SUPERVISOR)
    {
        if (( time() - _times[emp]) > ((60*60*24*SPR_DEMOTE)-7))
            blurb += "%^RED%^";
        else if ((time() - _times[emp]) > (60*60*24*SPR_WARN))
            blurb += "%^YELLOW%^";
    }
    else if (( time() - _times[emp]) > ((60*60*24*EMP_FIRE)-7))
        blurb += "%^RED%^";
    else if ((time() - _times[emp]) > (60*60*24*EMP_WARN))
        blurb += "%^YELLOW%^";
    return blurb + ctime(_times[emp])+ "%^RESET%^";
}
private void set_emp_time(string employee)
{
    if (!_employees[employee]) return;
    if (_employees[employee][EMP_INACTIVE])
    {
        _employees[employee][EMP_INACTIVE] = 0;
        save_emps();
    }
    if (!sizeof(_times)) _times = ([employee:0]);
    else if (!_times[employee]) _times += ([employee:0]);
    _times[employee] = time();
    remove_call_out(_call_times);
    _call_times = call_out((: save_times() :), PERS_DELAY);
}
void view_record(string person, string pattern)
{
    if (pattern == VIEW_EMP)
    {
        string text = sprintf("Employment history of %s:\n\n", cap_name(person));
        load_history();
        if (!sizeof(_history) || !_history[person])
        {
            tell_object(this_player(), "There is no history for that person.\n");
            return;
        }
        for(int i = 0; i < sizeof(_history[person][0]); i++)
            text += sprintf("%s: %s\n", ctime(_history[person][0][i]),
              _history[person][1][i]);
        tell_object(this_player(), sprintf("$P$%s's history$P$%s",
            cap_name(person), text));
        clear_history();
    }
    else
    {
        if (!query_applicant(person))
        {
            tell_object(this_player(), "That person has no application form "
              "on file.\n");
            return;
        }
        load_applicants();
        tell_object(this_player(),
          sprintf("$P$%s's history$P$Application of %s:\n\n%s", cap_name(person),
            cap_name(person), _applicants[person][APP_MESSAGE]));
        clear_applicants();
    }
}

==================================================
FILE: shops/player_shop/office_code/policies.c
==================================================

private void add_policy(string policy)
{
   load_policies();
   load_new_policies();
   if (!_policies[policy])
   {
      _policies += ([policy:({"",0})]);
      _policies[policy][0] = _new_policies[policy][POLICY_TEXT];
      _policies[policy][1] = _new_policies[policy][POLICY_TYPE];
      PLAYER_SHOP->auto_mail(_new_policies[policy][POLICY_MGR], _proprietor,
        "Policy proposition - "+ policy, "", "Your proposition has been "
        "accepted by majority vote and is now policy.\n" );
      shop_log(GENERAL, "Shop", "accepted the "+ policy + " policy.", UNPAID);
   }
   else
   {
      map_delete(_policies, policy);
      PLAYER_SHOP->auto_mail(_new_policies[policy][POLICY_MGR], _proprietor,
        "Policy proposition - "+ policy, "",
        "Your proposition to remove the above policy has been accepted "
        "by majority vote.\n");
      shop_log(GENERAL, "Shop", "removed the "+ policy + " policy.", UNPAID);
   }
   map_delete(_new_policies, policy);
   save_policies();
   save_new_policies();
}
void add_policy_suggest(string name, string text, string mgr, int type)
{
   if (previous_object() && previous_object() != find_object(_mgr_office))
   {
      LOG_ERROR("office.c", "add_policy_suggest("+name+","+text+","+mgr+")");
      return;
   }
   load_new_policies();
   if (!sizeof(_new_policies)) _new_policies = ([ name:POLICY_MAP ]);
   else _new_policies += ([ name:POLICY_MAP ]);
   load_policies();
   if (sizeof(_policies) && _policies[name]) text = _policies[name][0];
   _new_policies[name][POLICY_TIME] = time();
   _new_policies[name][POLICY_MGR] = mgr;
   _new_policies[name][POLICY_TEXT] = text;
   _new_policies[name][POLICY_TYPE] = type;
   do_policy_vote(mgr, name, "y");
   clear_policies();
   save_new_policies();
}
private int do_policy_vote(string mgr, string policy, string decision)
{
   int managers;
   load_new_policies();
   if (!m_sizeof(_new_policies) || !_new_policies[policy])
   {
      tell_object(this_player(), "There is no such policy pending!\n");
      return 1;
   }
   if (member_array(mgr, _new_policies[policy][POLICY_FOR]) != -1 ||
     member_array(mgr, _new_policies[policy][POLICY_AGAINST]) != -1 )
   {
      tell_object(this_player(), "You have already voted on this policy!\n");
      return 1;
   }
   if (decision == "y")
   {
      _new_policies[policy][POLICY_FOR] += ({mgr});
      tell_object(this_player(), "You vote for the " + policy+ " policy.\n");
   }
   else
   {
      _new_policies[policy][POLICY_AGAINST] += ({mgr});
      tell_object(this_player(), "You vote against the "+
         policy+ " policy.\n");
   }
   shop_log(GENERAL, mgr, "voted on the "+ policy + " policy.", PAID);
   save_new_policies();
   managers = sizeof(get_managers()) + sizeof(get_retired());
   if (sizeof(_new_policies[policy][POLICY_FOR]) > managers / 2)
      add_policy(policy);
   else if (sizeof(_new_policies[policy][POLICY_AGAINST]) >= managers / 2)
      remove_policy(policy);
   return 1;
}
string get_stock_policy() { return copy(_stock_policy); }
private void remove_policy(string policy)
{
   load_new_policies();
   PLAYER_SHOP->auto_mail(_new_policies[policy][POLICY_MGR],
     "Tarnach Fendertwin", "Policy proposition - "+ policy, "",
     "Your proposition has been rejected by majority vote.\n");
   shop_log(GENERAL, "Shop", "rejected the "+ policy + " policy.\n", UNPAID);
   map_delete(_new_policies, policy);
   save_new_policies();
}

==================================================
FILE: shops/player_shop/office_code/review.c
==================================================

private void monthly_review()
{
   int amount = calc_pay(),
       bonus_divisor = 0,
       cabinet_cost = (_num_cabinets - MIN_CABINETS) * CABINET_COST,
       pay;
   float pay_multiplier = 1.0;
   string *emps = m_indices(_employees);
   log_file("/log/PLAYER_SHOP", "%s: %s entered monthly review (review.c)\n",
      ctime(time()), _very_short);
   if (cabinet_cost)
   {
      adjust_profit(_proprietor, -cabinet_cost);
      shop_log(ACCOUNTS, _proprietor,
         "paid "+ MONEY_HAND->money_value_string(cabinet_cost,
         _place) + " for the rent of " + (_num_cabinets - MIN_CABINETS) +
         " cabinets", UNPAID);
   }
   if (_accounts["profit"] < 0) adjust_bonus("Shop",_accounts["profit"]);
   if (amount > _accounts["profit"])
      pay_multiplier = _accounts["profit"] / amount;
   foreach (string word in emps)
   {
      if (!_employees[word][EMP_PAY]) continue;
      pay = to_int(_employees[word][EMP_PAY] * pay_multiplier);
      if (!(_employees[word][EMP_POINTS] & NPC))
      {
         BANK_HANDLER->adjust_account(word,
            BANKS[_employees[word][EMP_BANK]][1], pay );
         PLAYER_SHOP->auto_mail(word, _proprietor, "Pay advice for "+
            _last_month, "", sprintf("For your work during %s, you have been "
            "paid a total of %s.  Keep up the good work.\n--\n%s "
            "(proprietor)\n", _last_month, MONEY_HAND->money_value_string(pay,
            _place ), _proprietor));
      }
      else _employees[word][EMP_POINTS] = EMPLOYEE + NPC;
      shop_log(ACCOUNTS, _proprietor, "paid "+ MONEY_HAND->
        money_value_string(pay, _place)+ " to "+ cap_name(word), UNPAID);
      _employees[word][EMP_PAY] = 0;
      _accounts["profit"] -= pay;
   }
   _bonus += _accounts["bonus"];
   if (_bonus < 0)
   {
      _accounts["bonus"] = _bonus;
      _bonus = 0;
   }
   else _accounts["bonus"] = 0;
   foreach (string word in m_indices(_employees))
   {
      if (_employees[word][EMP_NOBONUS]) continue;
      if (!test_prop(word, _very_short+ " handbook")) continue;
      if (_employees[word][EMP_POINTS] & MANAGER)
      {
         bonus_divisor += 4;
      }
      else if (_employees[word][EMP_POINTS] & SUPERVISOR ||
         _eom == word)
      {
         bonus_divisor += 3;
      }
      else
      {
         bonus_divisor += 2;
      }
   }
   if (!bonus_divisor) _bonus_val = _bonus;
   else _bonus_val = (_bonus * 2) / bonus_divisor;
   _got_bonus = ({});
   _eom = sort_array(get_employees(),
      (: _employees[$2][EMP_EOM] - _employees[$1][EMP_EOM] :))[0];
   foreach (string word in m_indices(_employees))
   {
      if (_employees[word][EMP_NOBONUS])
      {
         _employees[word][EMP_NOBONUS]--;
         _got_bonus += ({word});
      }
      _employees[word][EMP_EOM] = 0;
   }
   employee_log(_eom, _last_month+ "'s Employee Of The Month");
   add_board_message("Bonuses for "+ _last_month,
      sprintf("Based on the bonus fund of %s for %s, the following "
      "bonuses have been awarded:\n\n     Managers    - %s\n     Supervisors"
      " - %s\n     Employees   - %s\n\n%s's Employee Of The Month was %s.  "
      "Well done to you.\n", MONEY_HAND->money_value_string(_bonus, _place),
      _last_month, MONEY_HAND->money_value_string(_bonus_val * 2, _place),
      MONEY_HAND->money_value_string(to_int(_bonus_val * 1.5), _place),
      MONEY_HAND->money_value_string(_bonus_val, _place), _last_month,
      cap_name(_eom)));
   if (_bonus)
   {
      shop_log( ACCOUNTS, _proprietor, "paid out "+
        MONEY_HAND->money_value_string(_bonus, _place)+
        " in bonuses for "+ _last_month, UNPAID );
   }
   if (_eom == _shopkeeper->query_name())
   {
      _bonus -= to_int(_bonus_val * 1.5);
      shop_log(GENERAL, _eom, "claimed "+
         MONEY_HAND->money_value_string(to_int(_bonus_val * 1.5), _place),
         UNPAID);
   }
   else
   {
      _bonus -= _bonus_val;
      shop_log(GENERAL, _shopkeeper->query_name(), "claimed "+
         MONEY_HAND->money_value_string(_bonus_val, _place), UNPAID);
   }
   if (_bonus < 0) _bonus = 0;
   _last_month = _review_month;
   _call_review = 0;
   save_me();
   save_emps();
}
private void review_employees()
{
   int prom = FALSE,
       prom_number,
       managers,
       time = time();
   string *promos = ({}),
          promopost,
          *emps = _retired + m_indices(_employees);
   log_file("/log/PLAYER_SHOP", "%s: %s entered review_employees (review.c)\n",
      ctime(time()), _very_short);
   foreach (string word in emps)
   {
      if (!test_player(word))
      {
         if (_employees[word][EMP_POINTS] & NPC) continue;
         fire_them(_proprietor, word, "not existing");
      }
      else if (test_cre(word))
         fire_them(_proprietor, word, "being a creator");
      else if (test_prop(word,"no score") &&
         _employees[word][EMP_POINTS] & SUPERVISOR )
      {
         _employees[word][EMP_POINTS] =
            _employees[word][EMP_POINTS] & CLOCKED_IN + EMPLOYEE;
         save_emps();
         PLAYER_SHOP->auto_mail(word, _proprietor, "Demotion", "",
         "This is to advise you that, due to you having a creator alt, "
         "you have today been demoted.\n");
         employee_log(word, "Demoted by "+ _proprietor);
         shop_log(PERSONNEL, _proprietor, "demoted "+ cap_name(word), UNPAID);
      }
      if (!test_prop(word, _very_short+ " handbook"))
      {
         _employees[word][EMP_PAY] = 0;
         _employees[word][EMP_POINTS] =
            _employees[word][EMP_POINTS] & CLOCKED_IN + EMPLOYEE;
      }
   }
   foreach (string word in get_managers())
      if ((time - _times[word]) > (60*60*24*MGR_DEMOTE) &&
         _employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
            demote( _proprietor, word );
      else if (time - _times[word] > (60*60*24*MGR_WARN) &&
         !_employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
      {
         PLAYER_SHOP->auto_mail(word, _proprietor, "Poor attendance",
           "", "It has come to my attention that you have now been "
           "inactive for over " + MGR_WARN+ " days.  As you are a manager, "
           "you are required to meet certain levels of attendance.  "
           "You are now in serious danger of being demoted without "
           "further warning.\n---\n" + _proprietor+ " (proprietor)\n");
         _employees[word][EMP_INACTIVE] = TRUE;
         employee_log(word, "Warned about inactivity");
         shop_log(PERSONNEL, _proprietor, "warned "+
               cap_name(word) + " about inactivity", UNPAID);
      }
   foreach(string word in sort_array(get_supervisors(),
     (: _employees[$1][EMP_POINTS] - _employees[$2][EMP_POINTS] :)))
      if (time - _times[word] > (60*60*24*SPR_DEMOTE) &&
         _employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
            demote( _proprietor, word );
      else if (time - _times[word] > (60*60*24*SPR_WARN) &&
        !_employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
      {
         PLAYER_SHOP->auto_mail(word, _proprietor, "Poor attendance",
            "", "It has come to my attention that you have now been "
            "inactive for over "+ SPR_WARN+ " days.  As you are a supervisor, "
            "you are required to meet certain levels of attendance.  "
            "You are now in serious danger of being demoted without "
            "further warning.\n---\n" + _proprietor+ " (proprietor)\n");
         _employees[word][EMP_INACTIVE] = TRUE;
         employee_log(word, "Warned about inactivity");
         shop_log(PERSONNEL, _proprietor, "warned "+
            cap_name(word) + " about inactivity", UNPAID);
      }
      else
      {
         prom_number = (_max_emp * PERCENT_M) / 100;
         if ((_employees[word][EMP_POINTS] > 32 * MANAGER_POINTS) &&
           sizeof(get_managers()) < prom_number &&
           !_employees[word][EMP_NOPROMOTE])
         {
            set_employee(word, MANAGER);
            shop_log(PERSONNEL, _proprietor, "promoted "+
               cap_name(word)+ " to manager", UNPAID);
            employee_log(word, "Promoted to manager");
            PLAYER_SHOP->auto_mail(word, _proprietor, "Promotion!",
              "", "Congratulations!  You've been promoted to manager "
              "of "+ _shop_name+ ".  You'll find that you can now enter "
              "the managers' office.  Please remember to use the \"memo\" "
              "facility from there to discuss any major admin points with "
              "other managers.  This includes hiring, firing, and so on.\n");
            promos += ({word});
            prom = TRUE;
         }
      }
   foreach(string word in sort_array(get_employees(),
     (: _employees[$1][EMP_POINTS] - _employees[$2][EMP_POINTS] :)))
   {
      if (_employees[word][EMP_POINTS] & NPC) continue;
      if (time - _times[word] > (60*60*24*EMP_FIRE) &&
         _employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
      {
         fire_them(_proprietor, word, "serious inactivity");
         continue;
      }
      if (time - _times[word] > (60*60*24*EMP_WARN))
      {
         if (!_employees[word][EMP_INACTIVE] &&
         last_login(word) - _times[word] > (60*60*24*2))
         {
            PLAYER_SHOP->auto_mail(word, _proprietor, "Inactivity",
              "", "It has come to my attention that you have now been "
              "inactive for over "+ EMP_WARN+ " days.  Unless this "
              "situation is resolved, the management may have no option "
              "but to terminate your employment.\n---\n"+ _proprietor+
              " (proprietor)\n");
            _employees[word][EMP_INACTIVE] = TRUE;
            shop_log(PERSONNEL, _proprietor, "warned "+
              cap_name(word)+ " about inactivity", UNPAID);
            employee_log(word, "Warned about inactivity");
         }
      }
      else
      {
         prom_number = (_max_emp * PERCENT_S) / 100;
         if ((_employees[word][EMP_POINTS] > 32 * SUPER_POINTS) &&
           sizeof( get_supervisors() ) < prom_number &&
           !_employees[word][EMP_NOPROMOTE])
         {
            if(_employees[word][EMP_POINTS] & CLOCKED_IN)
               _employees[word][EMP_POINTS] = (SUPER_POINTS * 32) +
                 EMPLOYEE+ SUPERVISOR + CLOCKED_IN;
            else
               _employees[word][EMP_POINTS] = (SUPER_POINTS * 32) +
                 EMPLOYEE+ SUPERVISOR;
            shop_log(PERSONNEL, _proprietor, "promoted "+
              cap_name(word)+ " to supervisor", UNPAID);
            employee_log(word, "Promoted to supervisor");
            PLAYER_SHOP->auto_mail(word, _proprietor, "Promotion!", "",
              "Congratulations!  You've been promoted to supervisor "
              "of "+ _shop_name+ ".  You will now be able to use your "
              "newly acquired supervisor commands.\n");
            promos += ({word});
            prom = TRUE;
         }
      }
   }
   if (prom)
   {
      promopost = "The following employees have been promoted:\n\n";
      foreach (string word in promos)
         promopost += sprintf("     %s has been promoted to %s\n",
           cap_name(word), (_employees[word][EMP_POINTS] & MANAGER)?
           "manager":"supervisor");
      promopost += "\nCongratulations!\n";
      add_board_message("Promotions", promopost);
   }
   foreach (string word in m_indices(_baddies))
      if (time - _baddies[word][BAD_TIME] > (60*60*24*BAN_LENGTH))
         remove_baddie( word );
   foreach (string word in m_indices(_declined))
      if (time - _declined[word] > (60*60*24*DECLINE_LENGTH))
         remove_declined(word);
   remove_call_out(_call_hire_list);
   _call_hire_list = call_out((: check_hire_list() :), 5);
   save_emps();
   managers = sizeof(get_managers()) + sizeof(get_retired());
   load_new_policies();
   if (sizeof(_new_policies))
   {
      foreach (string word in m_indices(_new_policies))
      {
         if (sizeof(_new_policies[word][POLICY_FOR]) > managers / 2)
         {
            add_policy(word);
         }
         else if (time - _new_policies[word][POLICY_TIME] > VOTE_TIMEOUT)
         {
            if (sizeof(_new_policies[word][POLICY_FOR]) >=
               sizeof(_new_policies[word][POLICY_AGAINST]))
            {
               add_policy(word);
            }
            else remove_policy(word);
         }
      }
   }
   clear_new_policies();
   load_history();
   foreach (string word in m_indices(_history))
   {
      if (!test_player(word) || test_cre(word) ||
        !_times[word] || _times[word] < (time - HIST_TIMEOUT))
      {
         map_delete(_times, word);
         map_delete(_history, word);
      }
   }
   save_hist();
   save_times();
}

==================================================
FILE: shops/player_shop/office_code/save.c
==================================================

private void do_save()
{
#ifdef DEBUG
   tell_creator(CREATOR,"Saving shop data to %s/.\n", _savedir);
#endif
   unguarded((: save_object, _savedir+ "shop_data" :));
}
private void do_save_applicants()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving applications data to %s.\n",
     _savedir+ "applications");
#endif
   unguarded((: write_file, _savedir+ "applications",
     save_variable(_applicants), 1 :));
   clear_applicants();
}
private void do_save_emps()
{
#ifdef DEBUG
   tell_creator(CREATOR,"Saving employee data to %s.\n",
     _savedir+ "employees");
#endif
   unguarded((: write_file, _savedir+ "employees",
     save_variable(_employees), 1 :));
}
private void do_save_hist()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving history data to %s.\n",
     _savedir+ "history");
#endif
   unguarded((: write_file, _savedir+ "history",
     save_variable(_history), 1 :));
   clear_history();
}
private void do_save_new_policies()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving new policies data to %s.\n",
     _savedir+ "new_policies");
#endif
   unguarded((: write_file, _savedir+ "new_policies",
     save_variable(_new_policies), 1 :));
   _call_newpols_clear = call_out((: _new_policies= 0 :), CLEAR_DELAY);
}
private void do_save_policies()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving policies data to %s.\n",
     _savedir+ "policies");
#endif
   unguarded((: write_file, _savedir+ "policies",
      save_variable(_policies), 1 :));
   clear_policies();
}
private void save_list()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving chart list data to %s.\n",
     _savedir+ "list");
#endif
   unguarded((: write_file, _savedir+ "list",
     save_variable(_list), 1 :));
}
void save_register(mixed *money)
{
   _register = money;
   save_me();
}
private void save_times()
{
   if (_very_short == UNSET_STR) return;
#ifdef DEBUG
   tell_creator(CREATOR,"Saving times data to %s.\n",
     _savedir+ "times");
#endif
   unguarded((: write_file, _savedir+ "times",
     save_variable(_times), 1 :));
}

==================================================
FILE: shops/player_shop/office_code/stock.c
==================================================

void adjust_bought(string item, int amt)
{
   if (previous_object() && previous_object() != find_object(_storeroom))
   {
      LOG_ERROR("office.c", "adjust_bought("+item+","+amt+")");
      return;
   }
   _list[item][CHART_BOUGHT] += amt;
   save_list();
}
void adjust_sold(string item, int amt)
{
   if (previous_object() && previous_object() != find_object(_storeroom))
   {
      LOG_ERROR("office.c", "adjust_sold("+item+","+amt+")");
      return;
   }
   _list[item][CHART_SOLD] += amt;
   save_list();
}
private int do_chart(mixed *args, string pattern)
{
   int number;
   string word = this_player()->query_name();
   if (sizeof(args) > 1) number = args[1];
   if (pattern == CHART_ADDITEM)
   {
      if(query_on_list(args[0]))
      {
         tell_object( this_player(), args[0] +
            " are already on the sales list.\n" );
         return 1;
      }
   }
   else if (!query_on_list(args[0]))
   {
      tell_object(this_player(), args[0] +" are not on the sales list.\n");
      return 1;
   }
   switch (pattern)
   {
   case CHART_ADDITEM :
      add_succeeded_mess("$N put$s "+ args[0] +" on the sales list.\n");
      put_on_list(args[0]);
      shop_log(CHARTLOG, word, "put "+ args[0] +" on the sales list", PAID);
      break;
   case CHART_REMITEM :
      add_succeeded_mess("$N take$s "+args[0] +" off the sales list.\n");
      take_off_list( args[0] );
      shop_log(CHARTLOG, word, "took "+args[0] +" off the sales list", PAID);
      break;
   case CHART_MAXITEM :
      if (number < 1)
      {
         tell_object(this_player(), "Maximum must be greater than zero.\n");
         return 1;
      }
      add_succeeded_mess("$N set$s the maximum stock of "+ args[0] +" to "+
         number +".\n");
      set_max(args[0], number);
      shop_log(CHARTLOG, word, "set max of "+ args[0] +" to "+ number, PAID);
      break;
   case CHART_BUYITEM :
      if (number < 1)
      {
         tell_object(this_player(), "Price must be greater than zero.\n");
         return 1;
      }
      add_succeeded_mess("$N set$s the buying price of "+ args[0] +" to "+
         number +".\n");
      set_buy(args[0], number);
      shop_log(CHARTLOG, word, "set buy of "+ args[0] +" to "+ number, PAID);
      break;
   case CHART_SELLITEM :
      if (number < 1)
      {
         tell_object(this_player(), "Price must be greater than zero.\n");
         return 1;
      }
      add_succeeded_mess("$N set$s the selling price of "+ args[0] +" to "+
         number +".\n");
      set_sell(args[0], number);
      shop_log(CHARTLOG, word, "set sell of "+ args[0] +" to "+ number, PAID);
      break;
   case CHART_ASSIGN_ITEM :
      if (member_array( number, _list[args[0]][CHART_CAB] ) != -1)
      {
         tell_object(this_player(), args[0]+
            " are already assigned to cabinet "+ number+ ".\n");
         return 1;
      }
      if (number < 1 || number > _num_cabinets)
      {
         tell_object(this_player(), "That cabinet does not exist.\n");
         return 1;
      }
      add_chart_cabinet(args[0], number);
      add_succeeded_mess("$N assign$s "+ args[0] +" to use cabinet "+
         number +".\n");
      shop_log(CHARTLOG, word, "assigned "+ args[0] +
         " to cabinet "+ number, PAID);
      break;
   case CHART_UNASSIGN_ITEM :
      if (member_array( number, _list[args[0]][CHART_CAB] ) == -1)
      {
         tell_object(this_player(), args[0]+
            " are not assigned to cabinet "+ number+ ".\n");
         return 1;
      }
      remove_chart_cabinet(args[0], number);
      add_succeeded_mess("$N stop$s "+ args[0] +" using cabinet "+
         number +".\n");
      shop_log(CHARTLOG, word, "unassigned "+ args[0] +
         " from cabinet "+ number, PAID);
      break;
   }
   return 1;
}
private void put_on_list(string word)
{
   if (!_list[word])
   {
      _list[word] = ({5, 0, 20, 25, ({}), 0, 0, 0});
      save_list();
   }
}
int query_ave(string item)
{
   return (!_list[item])?0:copy(_list[item][CHART_AVE]);
}
int query_buy(string item)
{
   return (!_list[item])?0:copy(_list[item][CHART_BUY]);
}
int query_max(string item)
{
   return (!_list[item])?0:copy(_list[item][CHART_MAX]);
}
int query_on_list(string item) { return (!_list[item])?FALSE:TRUE; }
int query_sell(string item)
{
   return (!_list[item])?0:copy(_list[item][CHART_SELL]);
}
private void set_buy(string word, int number)
{
   if (!_list[word]) return;
   _list[word][CHART_BUY] = number;
   save_list();
}
private void set_max(string word, int number)
{
   if (!_list[word]) return;
   _list[word][CHART_MAX] = number;
   save_list();
}
private void set_sell(string word, int number)
{
   if (!_list[word]) return;
   _list[word][CHART_SELL] = number;
   save_list();
}
private void take_off_list(string word)
{
   if (!_list[word]) return;
   map_delete(_list, word);
   save_list();
}
private void update_averages()
{
   log_file("/log/PLAYER_SHOP", "%s: %s entered update_averages (stock.c)\n",
      ctime(time()), _very_short);
   foreach (string words in m_indices(_list))
   {
      _list[words][CHART_AVE] = (_list[words][CHART_AVE] +
         query_stock(words) + random(2)) / 2;
   }
   save_list();
}

==================================================
FILE: room/auction_room.c
==================================================

#include <money.h>
#include <move_failures.h>
#include <player_handler.h>
#include <mail.h>
#define COLOUR_ID "colour code"
#define AUCTION_PLAYER_NAME 0
#define AUCTION_PLAYER_BID 1
#define ERRNOSPACE -1
#define ERRBADPARM -2
#define ERRBADCBOB -3
#define ERROBNOMOVE -4
#define ERRGENFAIL -5
#define ERRNORECV -6
#define ERRRECVEMP -7
#define WARNUNDEST -8
#define WARNEXCL -9
#define WARNNOLOTS "NULL"
#define TCTP( x, y ) tell_creator( this_player(), x, y )
#define GECM( x ) "/global/events"->convert_message( x )
#define c_item class item
#define c_store class store
#define c_lot class lot
#define OPEN "open"
#define CLOSED "closed"
#define WAIT_SELLER "waitsell"
#define WAIT_BUYER "waitbuy"
#define WAIT_BUYER_LAPSE "waitbuylapse"
#define WAIT_CRE_INTERVENTION "waitcreint"
#define CHECK_CYCLE 10
#define COLOURS ({ "red", "orange", "yellow", "blue", "green", "indigo",\
  "violet", "crimson", "puce", "emerald", "ochre", "tangerine", "aquamarine",\
  "silver", "gold", "copper", "lilac" })
#define NO_COLOURS sizeof( COLOURS )
nosave inherit "/std/room";
inherit "/global/auto_load";
c_item {
  string name;
  string *alias;
  string *adjectives;
  string long;
  string read_mess;
  string enchant_mess;
}
c_store {
  int case_code;
  string colour;
  string inv_string;
  c_item *inventory;
}
c_lot {
  int case_code;
  c_store assoc_store;
  string seller;
  string status;
  int expiration_time;
  int reserve_price;
  mapping bids;
  mixed *lot_autoload;
  mixed *current_bid;
  string *auto_bids;
  string notes;
  string *excluded;
}
c_lot *lots = ({ });
mapping payments = ([ ]);
int lot_count = 0;
nosave string *used_colours = ({ });
nosave string currency = "default";
nosave string location = "unset";
nosave string shop_name = "REAS Auction Inheritable";
nosave int admin_cost = 2000;
nosave float commission = ( 5.0/100.0 );
mapping cases = ([ ]);
void save_file();
void load_file();
void set_location( string loc );
void set_currency( string cur );
void set_admin_cost( int value );
void set_commission( int percent );
void set_case_desc( string *bits );
mixed recover_lot( mixed lot_autoload );
int change_status( int lot_ident, string new_status );
void adjust_money( int amount, object player );
mixed generate_auto_load( object *obs );
c_store generate_store( object *things, int lot_id );
c_lot query_status( int lot_ident );
int do_deposit( object *things, int auction_time, string time_type,
  string res_price );
int do_bid( string offer, object *boxes );
int do_collect( string pattern );
int do_list();
int do_withdraw( object *boxes);
int do_describe( object *boxes, string int_desc );
int do_exclude( object *cases, string excluded );
int do_browse( object *cases, string target, int identifier );
int do_unexclude( object *cases, string excluded );
string generate_advertising_string( c_lot lot );
string generate_random_adv_str();
void create() {
    do_setup++;
    ::create();
    do_setup--;
    if ( !do_setup ) {
       this_object()->setup();
       this_object()->reset();
    }
    call_out( "load_file", 1 );
    call_out( "load_store", 2 );
    call_out( "lot_check", 5 );
}
void init() {
    this_player()->add_command( "bid", this_object(),
      "<string'amount'> {on|for} <indirect:object:here'case'>",
      (: do_bid( $4[0], $1 ) :) );
   this_player()->add_command( "collect", this_object(),
      ({ "successful bids", "money", "expired lots",
        "all" }),
      (: do_collect( $5 ) :) );
    this_player()->add_command( "deposit", this_object(),
      "<indirect:object:me'items'> for <number> "
      "{minute|hour|day} auction" ,
      (: do_deposit( $1, $4[1], $4[2], "" ) :) );
   this_player()->add_command( "deposit", this_object(),
      "<indirect:object:me'items'> for <number> "
      "{minute|hour|day} "
      "auction with [a] reserve price of <string'amount'>",
      (: do_deposit( $1, $4[1], $4[2], $4[3] ) :) );
    this_player()->add_command( "list", this_object(), "" );
   this_player()->add_command( "browse", this_object(),
       "<string'object'> in <indirect:object'case'>", (: do_browse( $1, $4[0], 0 ) :) );
    this_player()->add_command( "browse", this_object(),
       "<string'object'> <number> in <indirect:object'case'>",
       (: do_browse( $1, $4[0], $4[1] ) :) );
    this_player()->add_command( "withdraw", this_object(),
      "<indirect:object'case'> from auction",
      (: do_withdraw( $1 ) :) );
   this_player()->add_command( "write", this_object(),
      "<string'text'> on <indirect:object'case'>",
      (: do_describe( $1, $4[0] ) :) );
   this_player()->add_command( "exclude", this_object(),
      "<string'name'> from bidding on <indirect:object'case'>",
      (: do_exclude( $1, $4[0] ) :) );
   this_player()->add_command( "exclude", this_object(),
      "list for <indirect:object'case'>",
      (: do_exclude( $1, "list" ) :) );
   this_player()->add_command( "exclude", this_object(),
      "current ignore list from bidding on <indirect:object'case'>",
      (: do_exclude( $1, "ignore list" ) :) );
   this_player()->add_command( "unexclude", this_object(),
      "<string'name'> from bidding on <indirect:object'case'>",
      (: do_unexclude( $1, $4[0] ) :) );
}
int automated_deposit( object *things, int auction_length,
 string function_cb, string object_cb, int res_price,
  string int_desc ) {
  mixed *auto_load_string;
  c_lot temp;
  c_store temp2;
 if ( !sizeof( COLOURS - used_colours ) ) {
#ifdef DEBUG
   log_file( "REAS", "%s: ERRNOSPACE generated by: %s!\n", ctime( time() ),
             (previous_object()?file_name( previous_object()):"No previous object" ) );
#endif
    return ERRNOSPACE;
  }
  if ( !sizeof( things ) || auction_length < 0 ) {
#ifdef DEBUG
    log_file( "REAS", "%s: ERRBADPARM generated by: %s!\n", ctime( time() ),
      (previous_object()?file_name( previous_object()):"No previous object" ) );
#endif
    return ERRBADPARM;
  }
  if ( !objectp( load_object( object_cb ) ) ) {
#ifdef DEBUG
    log_file( "REAS", "%s: ERRBADCBOB generated by: %s!\n", ctime( time() ),
      (previous_object()?file_name( previous_object()):"No previous object" ) );
#endif
    return ERRBADCBOB;
  }
 lot_count ++;
  temp2 = generate_store( things, lot_count );
  auto_load_string = generate_auto_load( things );
  if ( !arrayp( auto_load_string ) ) {
   if ( (int) auto_load_string == ERROBNOMOVE ) {
#ifdef DEBUG
      log_file( "REAS", "%s: ERROBNOMOVE generated by: %s!\n", ctime( time() ),
        query_multiple_short( map( things, (: file_name( $1 ) :) ) ) );
#endif
      return ERROBNOMOVE;
    }
#ifdef DEBUG
    log_file( "REAS", "%s: ERRGENFAIL generated by: %s!\n", ctime( time() ),
      query_multiple_short( map( things, (: file_name( $1 ) :) ) ) );
#endif
    return ERRGENFAIL;
    }
   temp = new( c_lot, assoc_store: temp2, case_code: lot_count, seller: "Auto", status: OPEN,
      expiration_time: time() + auction_length, reserve_price: res_price,
      bids: ([ ]), current_bid: allocate( 2 ), lot_autoload: auto_load_string,
      auto_bids: ({ function_cb, object_cb }), notes: int_desc, excluded: ({ }) );
    lots += ({ temp });
   return lot_count;
}
mixed generate_auto_load( object *obs ) {
 object box = clone_object( "/obj/baggage" );
string *temp;
  box->set_name( "box" );
  box->set_long( "This is a box used in the auction room inheritable. "
    "How did you get hold of one?\n" );
  box->set_weight( 500000 );
  box->set_max_weight( 500000 );
  box->set_volume( 500000 );
 if ( sizeof( filter( obs->move( box ), (: $1 != 0 :) ) ) )
   return ERROBNOMOVE;
  temp = create_auto_load( ({ box }), 0 );
  if ( !arrayp( temp ) )
  return ERRGENFAIL;
   obs->dest_me();
   obs -= ({ 0 });
   if ( sizeof( obs ) ) {
#ifdef DEBUG
     log_file( "REAS", "%s: WARNUNDEST generated by object %s.\n", ctime( time() ),
     query_multiple_short( map( obs, (: file_name( $1 ) :) ) ) );
#endif
   }
   box->dest_me();
   return temp;
}
c_store generate_store( object *things, int lot_id ) {
  c_store temp;
  c_item temp2;
  object temp3;
  string *avail_colours = COLOURS - used_colours;
  string _colour = avail_colours[ random( sizeof( avail_colours ) ) ];
  temp = new( c_store, case_code: lot_id, colour: _colour,
    inventory: ({ }), inv_string: GECM( query_multiple_short( things ) ) );
    used_colours += ({ _colour });
  foreach( temp3 in things ) {
    temp2 = new( c_item, name: temp3->query_name(),
    alias: temp3->query_alias(), long: temp3->query_long(),
    read_mess: temp3->query_readable_message(), enchant_mess:
    temp3->enchant_string(), adjectives: temp3->query_adjectives() );
    temp->inventory += ({ temp2 });
    if ( !stringp( temp2->read_mess ) )
      temp2->read_mess = "";
  }
 return temp;
}
void lot_check() {
  c_lot temp_lot;
  c_store current_store;
  object new_case;
  object *all_new_cases = ({ });
  object *obs;
  object *exp_cases;
  int *active_lots;
  string name;
  int *bids;
  cases = filter( cases, (: objectp( $1 ) :) );
  active_lots = map( filter( lots, (: ( (c_lot) $1)->status == OPEN :) ),
   (: ( (c_lot) $1)->case_code :) );
  if ( sizeof( cases ) < sizeof( active_lots ) ) {
    active_lots = active_lots - values( cases );
    foreach( int temp in active_lots ) {
      temp_lot = filter( lots, (: $1->case_code == $(temp) :) )[0];
      current_store = temp_lot->assoc_store;
      new_case = clone_object( "/std/object" );
      new_case->set_name( "case" );
      new_case->set_short( current_store->colour + " case" );
      new_case->set_long( "This is a display case used in this auction shop. "
        "It contains " + current_store->inv_string +".\nYou can \"browse\" these"
        " items.\n" );
      new_case->add_adjective( current_store->colour );
      new_case->move( this_object() );
      new_case->reset_get();
      new_case->add_extra_look( this_object() );
      used_colours += ({ current_store->colour });
      cases += ([ new_case: temp ]);
      all_new_cases += ({ new_case });
    }
    if ( sizeof( all_new_cases ) )
      this_object()->add_new_case( all_new_cases );
  }
  foreach( temp_lot in ( filter( lots, (: $1->expiration_time < time() :) ) ) ) {
    TCTP( "Looking at lot %d. ", temp_lot->case_code );
    TCTP( "Status is: %s\n", temp_lot->status );
    switch( temp_lot->status ) {
      case OPEN:
      TCTP( "In open %s", "\n" );
        current_store = temp_lot->assoc_store;
        exp_cases = filter( cases, (: $2 == $(temp_lot)->case_code :) );
        map( exp_cases, (: this_object()->remove_lot( $1 ) :) );
        if ( sizeof( temp_lot->auto_bids ) ) {
          obs = recover_lot( temp_lot->lot_autoload );
          call_other( temp_lot->auto_bids[1], temp_lot->auto_bids[0],
          temp_lot->case_code, stringp( temp_lot->current_bid[ AUCTION_PLAYER_NAME ] ),
          temp_lot->current_bid[ AUCTION_PLAYER_NAME ],
          temp_lot->current_bid[ AUCTION_PLAYER_BID ], obs );
          temp_lot->status = CLOSED;
          temp_lot->expiration_time = time() + ( 2 * 60 * 60 );
          continue;
        }
        if ( stringp( name = temp_lot->current_bid[ AUCTION_PLAYER_NAME ] ) ) {
          if ( PLAYER_HANDLER->test_user( name ) ) {
            AUTO_MAILER->auto_mail( name, shop_name, "Your successful purchase!",
            "","Congratulations! You have successfully purchased "+
            current_store->inv_string +" with a bid of "
            + MONEY_HAND->money_value_string( temp_lot->current_bid[ AUCTION_PLAYER_BID ],
            currency )+ ".\n\nYou have one week to collect your items before they are "
            "forfeit.\n", 0, 0 );
          }
          temp_lot->status = WAIT_BUYER;
          temp_lot->expiration_time = time() + ( 7 * 24 * 60 * 60 );
          continue;
        }
        case WAIT_BUYER_LAPSE:
        name = temp_lot->seller;
        if (PLAYER_HANDLER->test_user( name ) ) {
          AUTO_MAILER->auto_mail( name, shop_name, "Your unsuccessful sale!",
          "", "Dear "+ capitalize( name ) +",\n\nIt is with some regret that I inform you "
          "that we were unable to sell " + current_store->inv_string +
          ".\n\nYou have one week to collect your items before they are forfeit.\n",
          0, 0 );
        }
        temp_lot->status = WAIT_SELLER;
        temp_lot->expiration_time = time() + ( 7 * 24 * 60 * 60 );
        continue;
      case WAIT_SELLER:
        name = temp_lot->seller;
        if ( PLAYER_HANDLER->test_user( name ) ) {
          AUTO_MAILER->auto_mail( name, shop_name, "Your unsuccessful sale!",
          "", "Dear "+ name +",\n\nAs you have not collected your items within "
          "7 days, they have been disposed of.\n\nHave a nice day.\n",
         0, 0 );
        }
        temp_lot->status = CLOSED;
        temp_lot->expiration_time = time() + ( 2 * 60 * 60 );
        continue;
    case WAIT_BUYER:
      name = temp_lot->current_bid[ AUCTION_PLAYER_NAME ];
      if ( PLAYER_HANDLER->test_user( name ) ) {
        AUTO_MAILER->auto_mail( name, shop_name, "Your successful purchase!",
        "","Dear " + name +",\nBecause you have not picked up your items, "+
        "they have been sold to another client.\n\nHave a nice day.", 0, 0 );
      }
      map_delete( temp_lot->bids, name );
      if ( sizeof( temp_lot->bids ) == 0 ) {
        temp_lot->status = WAIT_BUYER_LAPSE;
        temp_lot->expiration_time = time() + ( 2 * 60 * 60 );
        continue;
      }
      bids = sort_array( values( temp_lot->bids ), -1 );
      TCTP( "bids is %O.\n", bids );
      name = filter( temp_lot->bids, (: $2 == $(bids[0]) :) );
      temp_lot->current_bid[ AUCTION_PLAYER_NAME ] = name;
      temp_lot->current_bid[ AUCTION_PLAYER_BID ] = bids[0];
      if ( PLAYER_HANDLER->test_user( name ) ) {
        AUTO_MAILER->auto_mail( name, shop_name, "Your successful purchase!",
        "","Congratulations! You have successfully purchased "+
        current_store->inv_string +" with a bid of "
        + MONEY_HAND->money_value_string( temp_lot->current_bid[ AUCTION_PLAYER_BID ],
        currency )+ ".\n\nYou have one week to collect your items before they are "
        "forfeit.\n", 0, 0 );
      }
      temp_lot->status = WAIT_BUYER;
      temp_lot->expiration_time = time() + ( 7 * 24 * 60 * 60 );
      continue;
    case WAIT_CRE_INTERVENTION:
#ifdef DEBUG
      log_file("REAS", "%s: Lot %d is still waiting for manual intervention!\n",
        ctime( time() ), temp_lot->case_code );
#endif
      temp_lot->expiration_time = time() + ( 7 * 24 * 60 * 60 );
      continue;
      case CLOSED:
        TCTP( "In closed %s", "" );
        lots -= ({ temp_lot });
#ifdef DEBUG
        log_file( "REAS", "%s: Closed lot %d\n", ctime( time() ), temp_lot->case_code );
#endif
        continue;
    }
  }
  call_out( "lot_check", CHECK_CYCLE );
  return ;
}
int do_deposit( object *things, int auction_time, string time_type, string res_price ) {
  mixed *auto_load_string;
  c_lot temp;
  c_store temp2;
 int value;
  int finishtime;
 if ( auction_time <= 0 || ( time_type == "day" && auction_time > 10 )
    || ( time_type == "minute" && auction_time > 59 ) ||
    ( time_type == "hour" && auction_time > 23 ) ) {
      this_player()->add_failed_mess( this_object(),
        "That's not a valid length.\n" );
      return 0;
  }
  if ( sizeof( res_price ) ) {
   value = MONEY_HAND->value_from_string( res_price, currency );
    if ( value == 0 ) {
      this_player()->add_failed_mess( this_object(),
        res_price +" isn't a valid reserve price.\n" );
      return 0;
    }
  }
 if ( !sizeof( COLOURS - used_colours ) ) {
    this_player()->add_failed_mess( this_object(), "The auction house "
      "doesn't have any display cases left to auction your item.\n" );
    return 0;
  }
  switch( time_type ) {
    case "minute":
      if ( auction_time < 5 ) {
        this_player()->add_failed_mess( this_object(),
          "Auctions must go for at least 5 minutes.\n" );
        return 0;
      }
      finishtime = time() + ( auction_time * 60 );
      break;
    case "hour":
       finishtime = time() + ( auction_time * 60 * 60 );
       break;
    case "day":
      if ( auction_time > 14 ) {
        this_player()->add_failed_mess( this_object(),
          "Auction can not go for longer then two weeks.\n" );
        return 0;
      }
      finishtime = time() + ( auction_time * 60 * 60 * 24 );
      break;
    default:
       return 0;
 }
  foreach( object tmp in things ) {
    if ( base_name( tmp ) == "/obj/money.c" ) {
      this_player()->add_failed_mess( this_player(), "You can't auction money.\n" );
      things->move( this_player(), "" );
      filter( things, (: environment( $1 ) != this_player() :) )->
        move( environment( this_player() ),  "$N falls to the floor!\n" );
      return 0;
    }
  }
  lot_count ++;
  temp2 = generate_store( things, lot_count );
  auto_load_string = generate_auto_load( things );
  if ( !arrayp( auto_load_string ) ) {
    this_player()->add_failed_mess( this_player(), "You can't auction that.\n" );
    things->move( this_player(), "" );
    filter( things, (: environment( $1 ) != this_player() :) )->
      move( environment( this_player() ),  "$N falls to the floor!\n" );
    return 0;
 }
  temp = new( c_lot, assoc_store: temp2, case_code: lot_count, seller: this_player()->query_name(),
    status: OPEN, expiration_time: finishtime, reserve_price: value,
    bids: ([ ]), current_bid: allocate( 2 ), lot_autoload: auto_load_string,
    auto_bids: ({ }), notes: "", excluded: ({ }) );
  lots += ({ temp });
 if ( strlen( res_price ) )
    this_player()->add_succeeded_mess( this_object(), "$N $V "+
    temp2->inv_string + " for "+ add_a( query_num( auction_time, 5000 ) ) +
    " " + time_type + " auction, with a reserve price of "+
      MONEY_HAND->money_value_string( value, currency ) +".\n" );
  else
    this_player()->add_succeeded_mess( this_object(), "$N $V "+
    temp2->inv_string +" for a "+ query_num( auction_time, 5000 ) +
    " " + time_type + " auction, with no reserve price.\n" );
    TCTP( "Generated lot %d.\n", lot_count );
    return 1;
}
int do_list() {
  c_lot *_lots;
  c_lot _lot;
  string str;
  if ( !sizeof( cases ) ) {
    write( "There is nothing up for auction in this store.\n" );
    return 1;
  }
  str = "Items currently for auction:\n" ;
  foreach( object _case in keys( cases ) ) {
    _lots = filter( lots, (: $1->case_code == $( cases[ _case ] ) :) );
    if ( !sizeof( _lots ) ) continue;
    _lot = _lots[0];
    str +=  "$I$6=   " +
      capitalize( _lot->assoc_store->colour + " case" ) + ": " +
      _lot->assoc_store->inv_string;
    if (_lot->current_bid[AUCTION_PLAYER_NAME]) {
       str += "; bid: "+ MONEY_HAND->money_value_string(
        _lot->current_bid[1], currency ) + ", by " +
        capitalize(_lot->current_bid[ AUCTION_PLAYER_NAME ] ) +".\n";
    } else {
       str += ", no bid yet.\n";
    }
  }
  write("$P$Auctions$P$" + str);
  return 1;
}
void remove_lot( object ob ) {
  if ( member_array( ob, keys( cases ) ) == -1 )  {
    return;
  }
  map_delete( cases, ob );
  ob->dest_me();
  return;
}
int do_bid( string offer, object *boxes ) {
c_lot temp;
c_lot *temps;
c_store temp2;
object box;
int value;
 if ( sizeof( boxes ) > 1 ) {
    this_player()->add_failed_mess( this_object(),
      "You can only $V on one case at "
      "a time.\n" );
    return 0;
  }
  box = boxes[0];
  if ( member_array( box, keys( cases ) ) == -1 ) {
    this_player()->add_failed_mess( this_object(),
      "$I isn't being auctioned here.\n", ({ box }) );
    return 0;
  }
  temps = filter_array( lots, (: $1->case_code == cases[ $(box) ] :) );
  temp = temps[0];
  temp2 = temp->assoc_store;
  if ( temp->status != OPEN ) {
    this_player()->add_failed_mess(this_object(),
      "The bidding on this item is finished.\n" );
    return 0;
  }
  if ( member_array( this_player()->query_name(),
       temp->excluded ) != -1 ) {
    write( "You have been excluded from bidding on this object.\n" );
    return WARNEXCL;
  }
  if ( !classp( temp2 ) ) {
#ifdef DEBUG
    log_file( "REAS", "%s: Open lot without store! Lot code: %d.\n",
      ctime( time() ), temp->case_code );
#endif
    write( "Something has gone wrong. Please fetch a liaison post haste!\n" );
    printf( "Your lot code is: %d.\n", temp->case_code );
    temp->status = WAIT_CRE_INTERVENTION;
    temp->expiration_time = time() + ( 7 * 24 * 60 * 60 );
    this_player()->add_succeeded_mess( this_object(), "" );
    return 1;
  }
  value = MONEY_HAND->value_from_string( offer, currency );
  if ( value == 0 ) {
        this_player()->add_failed_mess( this_object(),
          offer +" isn't worth anything here.\n" );
        return 0;
  }
 if ( this_player()->query_value_in( currency ) < value ) {
   this_player()->add_failed_mess( this_object(), "You don't "
     "have that much.\n" );
   return 0;
 }
 if ( temp->reserve_price != 0 && value < temp->reserve_price ) {
   this_player()->add_failed_mess( this_object(),
     "The reserve price for this lot is "+
     MONEY_HAND->money_value_string( temp->reserve_price, currency ) +".\n" );
     return 0;
 }
  if ( value < 400 ) {
   this_player()->add_failed_mess( this_object(),
     "You must bid at least "+
     MONEY_HAND->money_value_string( 400, currency ) + ".\n" );
     return 0;
 }
 if ( sizeof( temp->current_bid ) &&
   temp->current_bid[ AUCTION_PLAYER_BID ] >= value ) {
   this_player()->add_failed_mess(this_object(),
     "Someone else has already bid more than that.\n");
   return 0;
 }
 if ( sizeof( temp->current_bid ) &&
   ( ( value - temp->current_bid[ AUCTION_PLAYER_BID ] ) <
     ( temp->current_bid[ AUCTION_PLAYER_BID ] / 20 ) ) ) {
     this_player()->add_failed_mess( this_object(), "You must bid 5% "
     "more then the current bid.\n" );
   return 0;
 }
 temp->bids[ this_player()->query_name() ] = value;
 temp->current_bid[0] = this_player()->query_name();
 temp->current_bid[1] = value;
 this_player()->add_succeeded_mess(this_object(),
   "$N $V "+ offer +" for "+ temp2->inv_string +".\n" );
 return 1;
}
int do_browse( object *boxes, string target, int identifier ) {
object box;
c_store container;
c_item temp;
mapping contents = ([ ]);
string *names = ({ });
mixed *longadj = ({ });
string temp2;
mixed *contenders;
string *contender;
string *adjectives;
string name;
string word;
int keep_flag;
 if ( sizeof( boxes ) > 1 ) {
    this_player()->add_failed_mess( this_object(),
      "You can only $V one case at a time.\n" );
    return 0;
  }
  box = boxes[0];
 if ( member_array( box, keys( cases ) ) == -1 ) {
    this_player()->add_failed_mess( this_object(),
      "$I isn't being auctioned here.\n", ({ box }) );
    return 0;
  }
  container = filter( lots, (: $1->case_code == cases[ $(box) ] :) )[ 0 ]->assoc_store;
  TCTP( "The case code for this case is: %d.\n", container->case_code );
  foreach( temp in container->inventory ) {
    names = temp->alias + ({ temp->name });
    names = uniq_array( names );
    longadj = ({ temp->long + temp->read_mess +
      ( this_player()->query_see_octarine() ? temp->enchant_mess : "" ),
      temp->adjectives });
    foreach( temp2 in names ) {
      if ( arrayp( contents[ temp2 ] ) )
        contents[ temp2 ] += ({ longadj });
      else
        contents[ temp2 ] = ({ longadj });
    }
  }
  adjectives = explode( target, " " );
    name = adjectives[ sizeof( adjectives ) - 1 ];
    adjectives -= ({ name });
  TCTP( "Search Name: %s ", name );
  TCTP( "Search Adj: %O.\n", adjectives );
  if ( !arrayp( contents[ name ] ) ) {
    this_player()->add_failed_mess( this_object(),
      "There is nothing like that in the case.\n" );
    return 0;
 }
  contenders = contents[ name ];
  if ( sizeof( contenders ) == 1 ) {
    contender = contenders[0];
    this_player()->add_succeeded_mess( this_player(),
     "$N $V "+ target +" in $I.\n", ({ box }) );
    call_out( (: tell_object( this_player(),
      $(GECM( contender[0]) ) ) :) );
    return 1;
  }
  if ( identifier != 0 ) {
    if ( identifier > sizeof( contenders ) ) {
     this_player()->add_failed_mess( this_player(),
        "There are only " + sizeof( contenders ) +
        " " + pluralize( target ) + " in $I.\n", ({ box }) );
       return 0;
      }
    this_player()->add_succeeded_mess( this_player(),
      "$N $V "+ add_a( target ) +" in $I.\n", ({ box }) );
    call_out( (: tell_object( this_player(),
      GECM( $(contenders[ identifier - 1 ][0]) ) ) :), 0 );
    return 1;
  }
  if ( !sizeof( adjectives ) ) {
    this_player()->add_failed_mess( this_object(),
      "There are "+ sizeof( contenders ) +" objects like that in the case.\n" );
    return 0;
 }
  foreach ( contender in contenders ) {
    keep_flag = 0;
    foreach( word in contender[ 1 ] ) {
      if ( member_array( word, adjectives ) != -1 )
        keep_flag = 0;
      continue;
    }
    if ( !keep_flag )
      contenders -= ({ contender });
    continue;
  }
  if ( !sizeof( contenders ) ) {
    this_player()->add_failed_mess( this_object(),
      "There is nothing matching "+ target +" in the case.\n" );
    return 0;
  }
  if ( sizeof( contenders ) > 1 ) {
     this_player()->add_failed_mess( this_object(),
       "There are " + sizeof( contenders ) + " items like that in the case. "
       "Please specify which one you want to browse.\n" );
     return 0;
  }
  contender = contenders[0];
  this_player()->add_succeeded_mess( this_player(),
    "$N peruse "+ add_a( target ) +" in $I.\n", ({ box }) );
  call_out( (: tell_object( this_player(),
    GECM( $(contender[0]) ) ) :), 0 );
  return 1;
}
void adjust_money( int amount, object player ) {
    object money;
    if ( amount < 0 ) {
        player->pay_money(MONEY_HAND->create_money_array(-amount, currency ));
        return;
    }
    money = MONEY_HAND->create_money_array( amount, currency );
    player->adjust_money( money, currency );
}
void load_file() {
    if ( !stringp( location ) ) return;
    if ( file_size( location +".o" ) < 0 ) return;
    unguarded( (: restore_object, location :) );
    return;
}
void save_file() {
    if ( location == "unset" ) return;
    unguarded( (: save_object, location :) );
    return;
}
void set_shop_name( string _name ) { shop_name = _name; }
void set_save_path( string path ) { location = path; }
void set_currency( string cur ) { currency = cur; }
void set_admin_cost( int value ) { admin_cost = value; }
void set_commission( int percent ) { commission = percent/100.0; }
mapping query_payments() { return payments; }
void dest_me() {
    save_file();
    if ( sizeof( cases ) ) keys( cases )->dest_me();
    ::dest_me();
}
mixed recover_lot( mixed lot_autoload ) {
  object *boxes;
  object *stuff;
  boxes = load_auto_load_to_array( lot_autoload, this_player() );
  if ( !objectp( boxes[0] ) ) {
#ifdef DEBUG
    log_file( "REAS", "%s: Could not recover: %O.\n", ctime( time() ),
      lot_autoload );
#endif
    return ERRNORECV;
  }
  stuff = all_inventory( boxes[ 0 ] );
  if ( !sizeof( stuff ) ) {
#ifdef DEBUG
    log_file( "REAS", "%s: Recovered case as empty: %O.\n", ctime( time() ),
      lot_autoload );
#endif
    return ERRRECVEMP;
  }
  call_out( (: $(boxes)->dest_me() :), 5 );
  return stuff;
}
int do_withdraw( object *boxes ) {
object box;
c_lot *_lots;
object *obs;
  if ( sizeof( boxes ) > 1  ) {
    this_player()->add_failed_mess( this_object(),
      "You can only $V on one case at "
      "a time.\n" );
      return 0;
  }
  box = boxes[0];
  if ( member_array( box, keys( cases ) ) == -1 ) {
    this_player()->add_failed_mess( this_object(),
      "$I isn't being auctioned here.\n", boxes );
    return 0;
  }
  _lots = filter( lots, (: $1->case_code == cases[ $(box) ] :) );
  if ( this_player()->query_name() != _lots[0]->seller &&
    !this_player()->query_creator() ) {
     this_player()->add_failed_mess( this_player(), "This isn't your "
       "lot to withdraw!\n" );
     return 0;
  }
  _lots[0]->status = CLOSED;
  _lots[0]->expiration_time = time() + ( 2 * 60 * 60 );
  obs = recover_lot( _lots[0]->lot_autoload );
  if ( !arrayp( obs ) ) {
    write( "Something has gone wrong. Please fetch a liaison post haste!\n" );
    printf( "Your lot code is: %d.\n", _lots[0]->case_code );
    _lots[0]->status = WAIT_CRE_INTERVENTION;
    _lots[0]->expiration_time = time() + ( 7 * 24 * 60 * 60 );
    this_player()->add_succeeded_mess( this_object(), "" );
    return 1;
  }
  obs->move( this_player(), "You collect $N." );
  filter( obs, (: environment( $1 ) != this_player() :) )->
    move( environment( this_player() ), "$N falls to the floor!\n" );
  this_object()->remove_lot( box );
  this_player()->add_succeeded_mess( this_object(), "" );
  return 1;
}
int do_describe( object *boxes, string int_desc ) {
    object box;
    c_lot *_lots;
    c_lot  _lot;
    int code;
    if ( sizeof( boxes ) > 1 ) {
        this_player()->add_failed_mess( this_object(),
          "You can only $V on one case at "
          "a time.\n" );
        return 0;
    }
    box = boxes[0];
    if ( member_array( box, keys( cases ) ) == -1 ) {
        this_player()->add_failed_mess( this_object(),
          "$I isn't being auctioned here.\n",
          ({ box }) );
        return 0;
    }
    code = cases[ box ];
    _lots = filter( lots, (: $1->case_code == $(code) :) );
    if ( sizeof( _lots ) != 1 ) {
        printf( "Please inform a creator, there are %d records to "
          "match this case.\n", sizeof( _lots ) );
        printf( "Your lot code is: %d.\n", code );
        this_player()->add_succeeded_mess( this_object(), "" );
        return 1;
    }
    _lot = _lots[0];
    if ( this_player()->query_name() != _lot->seller &&
      !this_player()->query_creator() ) {
        this_player()->add_failed_mess( this_player(), "This isn't your "
          "lot to describe!\n" );
        return 0;
    }
    _lot->notes = int_desc;
    printf( "You neatly letter %s on the case.\n", int_desc );
    this_player()->add_succeeded_mess( this_object(), "" );
    return 1;
}
string extra_look( object ob ) {
    c_lot temp, *temp2;
    mixed bid_info;
    string ret;
    int code;
    if ( member_array( ob, keys( cases ) ) == -1 ) return "";
    code = cases[ ob ];
    temp2 = filter( lots, (: $1->case_code == $(code) :) );
    if ( sizeof( temp2 ) != 1 ) return sizeof( temp2 ) +" found in lot array!\n";
    temp = temp2[0];
    bid_info = temp->current_bid;
    ret = "";
    if ( !stringp( bid_info[ AUCTION_PLAYER_NAME ] ) ) {
        if ( temp->reserve_price ) {
          ret += "Reserve price is: ";
          ret += MONEY_HAND->money_value_string( temp->reserve_price, currency );
          ret += ".\n";
        }
        else
            ret += "No bid as of yet.\n";
    }
    else
      ret += "The current bid is "+ MONEY_HAND->money_value_string(
        bid_info[1], currency ) + ", made by "+ capitalize(
        bid_info[ AUCTION_PLAYER_NAME ] ) +".\n";
    ret += "The bidding on this lot stops at "+ amtime( temp->expiration_time )+
      ".\n";
    if ( sizeof( temp->notes ) ) {
      ret += "Neatly lettered on the case is: ";
      ret += temp->notes;
      ret += ".\n";
    }
    return ret;
}
int do_collect( string pattern ) {
    int amount;
    c_lot _lot, *_lots = ({ }), *_exp_lots;
    object *items = ({ });
    _exp_lots = filter( lots, (: ((c_lot)$1)->status != OPEN :) );
    _exp_lots = filter( _exp_lots, (: ((c_lot)$1)->status != CLOSED :) );
    _exp_lots = filter( _exp_lots, (: ((c_lot)$1)->status != WAIT_CRE_INTERVENTION :) );
    if ( pattern == "all" ) {
        do_collect( "money" );
        do_collect( "successful bids" );
        do_collect( "expired lots" );
        return 1;
    }
    if ( pattern == "money" ) {
      _lots = filter( lots, (: ( $1->seller == $2 ) &&
        ( stringp( $1->current_bid[ AUCTION_PLAYER_NAME ] ) ) :),
        this_player()->query_name() );
      if ( undefinedp( payments[ this_player()->query_name() ] ) ) {
        if ( sizeof( _lots ) ) {
          foreach( c_lot tempy in _lots ) {
            write( capitalize( tempy->current_bid[ AUCTION_PLAYER_NAME ] ) +
              " must pay for the items they bid on before you can collect "
              "the money for them! They have until "+ amtime( tempy->expiration_time )+".\n" );
            }
       }
      }
      if ( undefinedp( payments[ this_player()->query_name() ] ) ) {
        write( "You aren't owed any money!\n" );
        return 0;
      }
      amount = payments[ this_player()->query_name() ];
      adjust_money( amount - to_int( amount * commission ), this_player() );
      printf( "You recieve %s, minus %s commission.\n",
        MONEY_HAND->money_value_string( amount, currency ),
        MONEY_HAND->money_value_string( to_int( amount * commission ),
        currency ) );
      map_delete( payments, this_player()->query_name() );
      this_player()->add_succeeded_mess( this_object(),
        "$N $V some money from $D.\n" );
      save_file();
      return 1;
    }
    if ( pattern == "successful bids" ) {
        _lots = filter( _exp_lots,
          (: $1->current_bid[ AUCTION_PLAYER_NAME ] == $2 :),
          this_player()->query_name() );
        if ( !sizeof( _lots ) ) {
            write( "You aren't expecting any bids!\n" );
            return 0;
        }
        foreach( _lot in _lots )
          amount += _lot->current_bid[ 1 ];
        if ( this_player()->query_value_in( currency ) < amount ) {
            printf( "You have %d %s waiting, for a total cost of %s.\n"
              "You don't have enough money.\n",
              sizeof( _lots ),
              sizeof( _lots ) > 1 ? "lots" : "lot",
              MONEY_HAND->money_value_string( amount, currency ) );
            this_player()->add_failed_mess( this_object(), "" );
            return 0;
        }
        adjust_money( -amount, this_player() );
        foreach( _lot in _lots ) {
          items += recover_lot( _lot->lot_autoload );
          if ( undefinedp( payments[ _lot->seller ] ) )
            payments[ _lot->seller ] = _lot->current_bid[ AUCTION_PLAYER_BID ];
          else
            payments[ _lot->seller ] += _lot->current_bid[ AUCTION_PLAYER_BID ];
          _lot->status = CLOSED;
          _lot->expiration_time = time() + ( 2 * 60 * 60 );
        }
        items->move( this_player(), "You collect $N." );
        filter( items, (: environment( $1 ) != this_player() :) )->
          move( environment( this_player() ), "$N falls to the floor!\n" );
        printf( "You had %d %s waiting, for a total cost of %s.\nYou "
          "hand over the money.\n", sizeof( _lots ),
          sizeof( _lots ) > 1 ? "lots" : "lot",
          MONEY_HAND->money_value_string( amount, currency ) );
        return 1;
    }
    if ( pattern == "expired lots" ) {
        _lots = filter( _exp_lots,
          (: !stringp( $1->current_bid[ AUCTION_PLAYER_NAME ] ) &&
            $1->seller == $2 :), this_player()->query_name() );
        if ( !sizeof( _lots ) ) {
            this_player()->add_failed_mess( this_object(), "You aren't expecting "
              "any items.\n" );
            return 0;
        }
        amount = admin_cost * sizeof( _lots );
        if ( this_player()->query_value_in( currency ) < amount ) {
            printf( "You have %d %s waiting, for a total administration "
              "cost of %s.\n"
              "You don't have enough money.\n",
              sizeof( _lots ),
              sizeof( _lots ) > 1 ? "lots" : "lot",
              MONEY_HAND->money_value_string( amount, currency ) );
            return 0;
        }
        adjust_money( -amount, this_player() );
        foreach( _lot in _lots ) {
          items += recover_lot( _lot->lot_autoload );
          if ( undefinedp( payments[ _lot->seller ] ) )
            payments[ _lot->seller ] = _lot->current_bid[ AUCTION_PLAYER_BID ];
          else
            payments[ _lot->seller ] += _lot->current_bid[ AUCTION_PLAYER_BID ];
          _lot->status = CLOSED;
          _lot->expiration_time = time() + ( 2 * 60 * 60 );
        }
        items->move( this_player(), "You collect $N." );
        filter( items, (: environment( $1 ) != this_player() :) )->
          move( environment( this_player() ), "$N falls to the floor!\n" );
        printf( "You had %d %s waiting, for a total administration "
          "cost of %s.\n"
          "You hand over the money.\n",
          sizeof( _lots ), sizeof( _lots ) > 1 ?
          "lots" : "lot",
          MONEY_HAND->money_value_string( amount, currency ) );
        return 1;
    }
}
int do_exclude( object *boxes, string excluded ) {
    object box;
    c_lot *_lots;
    c_lot  _lot;
    int code;
    string *ignored = this_player()->query_property( "ignoring" );
    if ( sizeof( boxes ) > 1 ) {
        this_player()->add_failed_mess( this_object(),
          "You can only $V people from one case at "
          "a time.\n" );
        return 0;
    }
    box = boxes[0];
    if ( member_array( box, keys( cases ) ) == -1 ) {
        this_player()->add_failed_mess( this_object(),
          "$I isn't being auctioned here.\n",
          ({ box }) );
        return 0;
    }
    code = cases[ box ];
    _lots = filter( lots, (: $1->case_code == $(code) :) );
    if ( sizeof( _lots ) != 1 ) {
        printf( "Please inform a creator, there are %d records to "
          "match this case.\n", sizeof( _lots ) );
        printf( "Your lot code is: %d.\n", code );
        this_player()->add_succeeded_mess( this_object(), "" );
        return 1;
    }
    _lot = _lots[0];
    if ( this_player()->query_name() != _lot->seller &&
      !this_player()->query_creator() ) {
        this_player()->add_failed_mess( this_player(), "This isn't your "
          "lot to exclude people from!\n" );
        return 0;
    }
    if ( excluded == "list" ) {
      if ( !sizeof( _lot->excluded ) )
        write( "No one is being excluded from bidding on this lot.\n" );
      else
        write( query_multiple_short( _lot->excluded ) + " is being excluded from "
          "bidding on this lot.\n" );
      return 1;
    }
    if ( excluded != "ignore list" ) {
      if ( member_array( excluded, _lot->excluded ) != -1 ) {
        write( excluded + " is already excluded from this lot.\n" );
        return 1;
      }
      if ( !PLAYER_HANDLER->test_user( excluded ) )
        return notify_fail( excluded +" is not a player here!\n" );
      else  {
        _lot->excluded += ({ excluded });
        _lot->excluded = uniq_array( _lot->excluded );
        write( excluded +" will not be allowed to bid on "+
          query_multiple_short( boxes ) +".\n" );
        return 1;
      }
    }
    if ( !arrayp( ignored ) || !sizeof( ignored ) ) {
      write( "You aren't ignoring anyone!\n" );
      return 1;
    }
    _lot->excluded += ignored;
    _lot->excluded = uniq_array( _lot->excluded );
    write( query_multiple_short( ignored ) + " will not be allowed to bid on "+
      query_multiple_short( boxes ) +".\n"  );
    this_player()->add_succeeded_mess( this_object(), "" );
    return 1;
}
int do_unexclude( object *boxes, string excluded ) {
    object box;
    c_lot *_lots;
    c_lot  _lot;
    int code;
    if ( sizeof( boxes ) > 1 ) {
        this_player()->add_failed_mess( this_object(),
          "You can only $V people from one case at "
          "a time.\n" );
        return 0;
    }
    box = boxes[0];
    if ( member_array( box, keys( cases ) ) == -1 ) {
        this_player()->add_failed_mess( this_object(),
          "$I isn't being auctioned here.\n",
          ({ box }) );
        return 0;
    }
    code = cases[ box ];
    _lots = filter( lots, (: $1->case_code == $(code) :) );
    if ( sizeof( _lots ) != 1 ) {
        printf( "Please inform a creator, there are %d records to "
          "match this case.\n", sizeof( _lots ) );
        printf( "Your lot code is: %d.\n", code );
        this_player()->add_succeeded_mess( this_object(), "" );
        return 1;
    }
    _lot = _lots[0];
    if ( this_player()->query_name() != _lot->seller &&
      !this_player()->query_creator() ) {
        this_player()->add_failed_mess( this_player(), "This isn't your "
          "lot to unexclude people from!\n" );
        return 0;
    }
    if ( member_array( excluded, _lot->excluded ) == -1 ) {
      if ( !sizeof( _lot->excluded ) ) {
        write( "No one is excluded from bidding on this case!\n" );
        return 1;
      }
      write( "Only "+ query_multiple_short( _lot->excluded ) +
        ( sizeof( excluded ) == 1 ? " is " : " are " ) +
        " being excluded from bidding on this case!\n" );
      return 1;
    }
    _lot->excluded -= ({ excluded });
    write( capitalize( excluded ) + " is now allowed to bid on this case.\n" );
    this_player()->add_succeeded_mess( this_object(), "" );
    return 1;
}
c_lot find_spec_lot( int pos ) { return lots[ pos ]; }
string generate_advertising_string( c_lot lot ) {
  string c_string;
  if ( intp( lot->current_bid[ 0 ] ) && ( lot->current_bid[ 0 ] ) )
    c_string = MONEY_HAND->money_value_string( lot->current_bid[ 0 ], currency );
  else
    if ( intp( lot->reserve_price ) && lot->reserve_price )
      c_string = MONEY_HAND->money_value_string( lot->reserve_price, currency );
    else
     c_string = "make an offer";
  if ( c_string == "make an offer" )
    return lot->assoc_store->inv_string + ", " + c_string +
    " but hurry, bidding stops at " + amtime( lot->expiration_time );
  return lot->assoc_store->inv_string + ", currently going for " + c_string +
    " but hurry, bidding stops at " + amtime( lot->expiration_time );
}
string generate_random_adv_string() {
c_lot temp;
  if ( sizeof( lots ) ) {
    temp = lots[ random( sizeof( lots ) ) ];
    if ( temp->status != OPEN )
      return WARNNOLOTS;
    else return generate_advertising_string( temp );
  }
  else
    return WARNNOLOTS;
}

==================================================
FILE: room/basic_room.c
==================================================

#include <armoury.h>
#include <dirs.h>
#include <door.h>
#include <move_failures.h>
#include <room.h>
#include <position.h>
#include <situations.h>
#include <weather.h>
#include <nroff.h>
inherit "/std/basic/cute_look";
inherit "/std/basic/desc";
inherit "/std/basic/extra_look";
inherit "/std/basic/light";
inherit "/std/basic/property";
inherit "/std/basic/export_inventory";
inherit "/std/basic/help_files";
inherit "/std/basic/effects";
nosave int do_setup;
nosave int *co_ord;
nosave int co_ord_calculated;
nosave string long_exit;
nosave string long_exit_mxp;
nosave string short_exit;
nosave string theft_handler;
nosave string *aliases;
nosave string *_exits;
nosave object item;
private nosave object chatter;
nosave object sitchanger;
nosave object linker;
nosave object terrain;
nosave object wall;
nosave object *hidden_objects;
private nosave object* _use_internal_objects;
nosave mapping door_control;
nosave mixed *dest_other;
nosave int enchant_time;
nosave int background_enchant;
nosave float dynamic_enchant;
private nosave int last_visited;
private nosave string *variablelongs;
private nosave mixed variablechats;
private nosave mixed variableitems;
private nosave int is_day = -1;
varargs int add_item( mixed shorts, mixed desc, int no_plural );
int remove_item( string word );
private void setup_room_chat( );
void set_not_replaceable(int replace);
int query_not_replaceable();
void set_night_long( string str );
protected void create() {
   object *npcs;
   object virt_room;
   string *inhs;
   desc::create();
   extra_look::create();
   property::create();
   export_inventory::create();
   light::create();
   effects::create();
   set_can_export_inventory();
   set_ignore_livings_in_inventory( 0 );
   aliases = ({ });
   _exits = ({ });
   hidden_objects = ({ });
   _use_internal_objects = ({ });
   door_control = ([ ]);
   dest_other = ({ });
   seteuid( (string)"/secure/master"->creator_file( file_name(
           this_object() ) ) );
   add_property( "location", "inside" );
   add_property( "here", "on the floor" );
   if ( !do_setup ) {
      this_object()->setup();
      this_object()->reset();
   }
   if ( find_object( "/obj/handlers/map" ) ) {
      catch( "/obj/handlers/map"->check_map( file_name( this_object() ) ) );
   }
   if( (virt_room = find_object("/room/virtual") ) ){
     npcs = ({}) + all_inventory(virt_room);
     catch(npcs->real_room(file_name()));
   }
   inhs = inherit_list(this_object());
   if (sizeof(inhs) == 1) {
      if (replaceable(this_object(), ({ "setup" }))) {
         call_out(function(string fname) {
           if (!query_not_replaceable()) {
               catch(replace_program(fname));
           }
         }, 0, inhs[0]);
      }
   }
}
int query_is_room()
{
  return 1;
}
int query_enchant() {
  int enchant_level =  to_int( floor( 0.5 + dynamic_enchant *
                        exp( -0.693 *
                             ( time() - enchant_time ) /
                             ENCHANT_HALF)) +
                 background_enchant );
  if ( enchant_level > 5000 ) {
    return 5000;
  }
  return enchant_level;
}
int set_enchant(int number) {
  if (number < 0) {
    number = 0;
  }
  if (previous_object()==this_object()) {
    background_enchant = (float) number;
    dynamic_enchant = 0.0;
    enchant_time = time();
  } else {
    dynamic_enchant = number - background_enchant;
    enchant_time=time();
  }
  return number;
}
int add_enchant( int number ) {
  dynamic_enchant = dynamic_enchant * exp( -0.693 *
                                           ( time() - enchant_time ) /
                                           ENCHANT_HALF ) + number;
  enchant_time = time();
  return floor( 0.5 + dynamic_enchant ) + background_enchant;
}
void set_background_enchant( int number ) {
  background_enchant = number;
}
void set_dynamic_enchant( float number ) {
  dynamic_enchant = number;
  enchant_time = time();
}
int query_background_enchant() {
  return background_enchant;
}
float query_dynamic_enchant() {
  dynamic_enchant = dynamic_enchant * exp( -0.693 *
                                           ( time() - enchant_time ) /
                                           ENCHANT_HALF );
  enchant_time = time();
  return dynamic_enchant;
}
int *query_co_ord() {
  if ( pointerp( co_ord ) ) {
    return copy(co_ord);
  }
  return 0;
}
void set_co_ord( int *new_co_ord ) {
  if ( !pointerp( new_co_ord ) ) {
    write( "Warning: Co-ordinate must be an array.\n" );
    return;
  }
  if ( sizeof( new_co_ord ) != 3 ) {
      write( "Warning: The co-ordinate must have three elements.\n" );
      return;
  }
  co_ord = new_co_ord;
  if ( previous_object() == this_object() ) {
    co_ord_calculated = 0;
  } else {
    co_ord_calculated = 1;
  }
}
void flush_co_ord() {
    co_ord = 0;
    co_ord_calculated = 0;
}
int query_co_ord_calculated() { return co_ord_calculated; }
string query_long_exit() { return long_exit; }
string query_long_exit_mxp() { return long_exit_mxp; }
void calc_long_exit() {
  int i, add;
  string *words;
  mixed tmp;
  words = ({ });
  for ( i = 0; i < sizeof( dest_other ); i += 2 ) {
    tmp = dest_other[ i + 1 ][ ROOM_OBV ];
    if ( !tmp ) {
      continue;
    }
    if ( intp( tmp ) && tmp ) {
      add = 1;
    }
    if ( stringp( tmp ) ) {
      add = (int)call_other( this_object(), tmp, dest_other[ i ] );
    }
    if ( pointerp( tmp ) ) {
      add = (int)call_other( tmp[ 0 ], tmp[ 1 ], dest_other[ i ] );
    }
    if ( add ) {
      if(dest_other[i+1][ROOM_REL]) {
        words += ({ "$R$-"+ dest_other[ i ] +"$R$" });
      } else {
        words += ({ dest_other[i] });
      }
    }
  }
  switch ( sizeof( words ) ) {
  case 0 :
    long_exit = "There are no obvious exits.";
    long_exit_mxp = mxp_expire("Exits") + "There are no obvious exits.";
    break;
  case 1 :
    long_exit = "There is one obvious exit: "+ words[ 0 ] + ".";
    long_exit_mxp = mxp_expire("Exits") +
                    "There is one obvious exit: "+ mxp_tag("Exit", words[ 0 ], 1) + ".";
    break;
  default :
    long_exit = "There are "+ query_num( sizeof( words ), 0 ) +
      " obvious exits: "+ query_multiple_short( words ) +
      ".";
    long_exit_mxp = mxp_expire("Exits") +
      "There are "+ query_num( sizeof( words ), 0 ) +
      " obvious exits: "+ query_multiple_short( map(words, (: mxp_tag("Exit", $1, 1) :) ) ) +
      ".";
  }
}
string query_theft_handler() { return theft_handler; }
void set_theft_handler( string word ) { theft_handler = word; }
string *query_aliases() { return copy( aliases ); }
void add_alias( mixed names, string word ) {
  string name;
  if ( !aliases ) {
    aliases = ({ });
  }
  if ( pointerp( names ) ) {
    foreach ( name in names ) {
      add_alias( name, word );
    }
    return;
  }
  aliases += ({ word, names });
  if ( find_call_out( "calc_exits" ) == -1 ) {
    call_out( "calc_exits", 1 );
  }
}
void remove_alias( mixed names, string word ) {
  int i;
  string name;
  if ( !aliases ) {
    return;
  }
  if ( pointerp( names ) ) {
    foreach ( name in names ) {
      remove_alias( name, word );
    }
    return;
  }
  for ( i = sizeof( aliases ) - 2; i >= -1; i -= 2 ) {
    if ( ( aliases[ i ] == word ) && ( aliases[ i + 1 ] == names ) ) {
      aliases = delete( aliases, i, 2 );
    }
  }
}
string *query_exits() { return copy(_exits); }
void reset_exits() { _exits = ({ }); }
object query_item() { return item; }
object query_chatter() { return chatter; }
object query_situation_changer() { return sitchanger; }
object query_linker() { return linker; }
object query_terrain() { return terrain; }
object query_wall() { return wall; }
object *query_hidden_objects() { return hidden_objects + ({ }); }
int add_hidden_object( object thing ) {
  if ( !hidden_objects ) {
    hidden_objects = ({ });
  }
  if ( member_array( thing, hidden_objects ) != -1 ) {
    return 0;
  }
  hidden_objects += ({ thing });
  return 1;
}
int remove_hidden_object( object thing ) {
  int i;
  i = member_array( thing, hidden_objects );
  if ( i == -1 ) {
    return 0;
  }
  hidden_objects = hidden_objects[0..i - 1] + hidden_objects[i + 1..];
  return 1;
}
void add_use_internal_object(object thing) {
   _use_internal_objects |= ({ thing });
}
void remove_use_internal_object(object thing) {
   _use_internal_objects -= ({ thing });
}
object* query_use_internal_objects() {
   return _use_internal_objects;
}
varargs mixed query_door_control( string direc, string name ) {
   if ( !stringp( direc ) ) {
      return copy( door_control );
   }
   if (name) {
      return door_control[ direc + " " + name ];
   }
   return door_control[ direc ];
}
varargs mixed *query_dest_other( string direc ) {
  int i;
  if ( !stringp( direc ) ) {
    return copy( dest_other );
  }
  i = member_array( direc, dest_other );
  if ( i == -1 ) {
    return 0;
  }
  return copy( dest_other[ i + 1 ] );
}
varargs string *query_dest_dir( object thing ) {
  int i;
  string *ret;
  ret = ({ });
  for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
    if ( !dest_other[ i + 1 ][ ROOM_REL ] || !objectp( thing ) ) {
      ret += ({ dest_other[ i ], dest_other[ i + 1 ][ ROOM_DEST ] });
    } else {
      ret += ({ (string)thing->find_rel( dest_other[ i ] ),
                  dest_other[ i + 1 ][ ROOM_DEST ] });
    }
  }
  return ret;
}
varargs string *query_direc( object thing ) {
  int i;
  string *ret;
  ret = ({ });
  for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
    if ( !dest_other[ i + 1 ][ ROOM_REL ] || !objectp( thing ) ) {
      ret += ({ dest_other[ i ] });
    } else {
      ret += ({ (string)thing->find_rel( dest_other[ i ] ) });
    }
  }
  return ret;
}
string query_destination( string exit ) {
   int i;
   i = member_array( exit, dest_other );
   if ( ( i < 0 ) && objectp( this_player() ) )
      i = member_array( (string)this_player()->reorient_rel( exit ),
            dest_other );
   if ( i < 0 )
      return ROOM_VOID;
   return dest_other[ i + 1 ][ ROOM_DEST ];
}
int test_add( object thing, int flag ) { return 1; }
int test_remove( object thing, int flag, mixed dest ) { return 1; }
int add_weight( int number ) { return 1; }
int query_no_writing() { return 1; }
int query_decay() { return 10; }
int query_day() { return is_day; }
int attack_speed() { return 15; }
string query_dark_mess() {
  mixed dark_mess;
  if ( !stringp( dark_mess = query_property( "dark mess" ) ) ) {
    return "It's dark here, isn't it?";
  }
  return dark_mess;
}
void set_dark_mess( string word ) {
    add_property( "dark mess", word );
}
string query_bright_mess() {
  mixed bright_mess;
  if ( !stringp( bright_mess = query_property( "bright mess" ) ) ) {
    return "It's too bright to see anything!";
  }
  return bright_mess;
}
void set_bright_mess( string word ) { add_property( "bright mess", word ); }
mixed query_room_size() {
   mixed room_size;
   room_size = query_property( "room size" );
   if ( !room_size ) {
      return 10;
   }
   return room_size;
}
int *query_room_size_array() {
   mixed room_size;
   room_size = query_room_size();
   if ( pointerp( room_size ) ) {
      return room_size;
   }
   return ({ room_size, room_size, room_size });
}
void set_room_size( mixed number ) {
   if ( intp( number ) ) {
      add_property( "room size", number );
      return;
   }
   if ( pointerp( number ) ) {
      if ( sizeof( number ) == 3 ) {
         add_property( "room size", number );
         return;
      }
   }
   write( "Room size must be an integer or an array of three integers.\n" );
}
int id( string word ) { return 0; }
string expand_alias( string word ) {
   int i;
   if ( !aliases || !sizeof( aliases ) ) {
      return word;
   }
   i = member_array( word, aliases );
   if ( i == -1 ) {
      return word;
   }
   if ( i % 2 ) {
      return aliases[ i - 1 ];
   }
   return word;
}
string calc_short_exit_string() {
   int i, add;
   string *words;
   int pos;
   string tmp_dir;
   mixed tmp;
   words = ({ });
   for ( i = 0; i < sizeof( dest_other ); i += 2 ) {
      tmp = dest_other[ i + 1 ][ ROOM_OBV ];
      if ( !tmp ) {
         continue;
      }
      if ( intp( tmp ) && tmp ) {
         add = 1;
      }
      if ( stringp( tmp ) ) {
         add = (int)call_other( this_object(), tmp, dest_other[ i ] );
      }
      if ( pointerp( tmp ) ) {
         add = (int)call_other( tmp[ 0 ], tmp[ 1 ], dest_other[ i ] );
      }
      if ( add ) {
         if ( tmp = SHORTEN[ dest_other[ i ] ] ) {
            if (dest_other[i+1][ROOM_REL]) {
               words += ({ "$r$-"+tmp+"$r$" });
            } else {
               words += ({ tmp });
            }
         } else {
            if (dest_other[i+1][ROOM_REL]) {
               words += ({ "$r$-"+dest_other[ i ]+"$r$" });
            } else {
               pos = strsrch(dest_other[i], " ");
               if (pos != -1) {
                  tmp_dir = dest_other[i][pos + 1..];
                  tmp = SHORTEN[tmp_dir];
                  if (tmp) {
                     tmp_dir = tmp;
                  }
                  words += ({ dest_other[i][0..pos] + tmp_dir });
               } else {
                  words += ({ dest_other[i] });
               }
            }
         }
      }
   }
   if(!sizeof(words)) {
     return " [none]";
   }
   return " ["+ implode( words, "," ) +"]";
}
string query_short_exit_string() {
   string tmp;
   if(short_exit) {
      return this_player()->colour_event("exits", "%^GREEN%^") +
     short_exit + "%^RESET%^";
   }
   tmp = calc_short_exit_string();
   if (!query_property("no exit cache")) {
      short_exit = tmp;
   }
   return this_player()->colour_event("exits", "%^GREEN%^") +
     tmp + "%^RESET%^";
}
string enchant_string() {
   string words;
   words = (string)this_object()->query_property( "octarine_mess" );
   if ( words ) {
      return words +"\n";
   }
   switch ( query_enchant() ) {
      case 0 .. 49 :
         return "";
      case 50 .. 149 :
         return "There is the residual taste of magic in this place.\n";
      case 150 .. 299 :
         return "This place has seen some use of magic.\n";
      case 300 .. 499 :
         return "A considerable amount of magic has been used here.\n";
      case 500 .. 749 :
         return "A very large quantity of magic has been manipulated here.\n";
      case 750 .. 1000 :
         return "You can feel the Dungeon Dimensions trying to push in.\n";
      case 1001 .. 1500 :
         return "Little sparks flash in from the Dungeon Dimensions.\n";
      case 1501 .. 2000 :
         return "Apparations of things with lots of tentacles seem to be "
                "on the edge of your vision.\n";
      default :
         return "So much magic has been expended here that the area is in "+
               "danger of dumping itself into the Dungeon Dimensions.\n";
   }
}
string long( string word, int dark ) {
   string ret;
   if ( !long_exit ) {
      calc_long_exit();
   }
   if ( dark ) {
      if ( dark < 0 ) {
         ret = mxp_tag("RoomDesc", this_object()->query_dark_mess(), this_player()) +"\n";
      } else {
         ret = mxp_tag("RoomDesc", this_object()->query_bright_mess(), this_player()) +"\n";
      }
      if ( query_property( "location" ) == "outside" ) {
         ret += "$weather$";
      }
      if ( ( dark == 1 ) || ( dark == -1 ) ) {
         ret = "$C$"+ mxp_tag("RoomName", a_short(), this_player()) +".  "+ ret +
           this_player()->colour_event("exits", "%^GREEN%^") +
           mxp_tag("RoomExits", mxp_choice(long_exit, long_exit_mxp, this_player()), this_player())
           +"%^RESET%^\n";
         if ( query_contents( "" ) != "" ) {
            ret += this_player()->colour_event("inventory", "") + "Some objects you can't make out are here.%^RESET%^\n";
         }
      }
   } else {
      if ( query_property( "location" ) == "outside" ) {
         ret = "$long$";
      } else {
         ret = query_long();
      }
      if(!ret) {
         ret = "Erk, this room seems to be broken.\n";
      }
      word = calc_extra_look();
      if ( stringp( word ) && ( word != "" ) ) {
         ret += word;
      }
      if ( this_player()->query_see_octarine() ) {
         ret += enchant_string();
      }
      if ( query_property( "location" ) == "outside" ) {
         ret += "$weather$";
      }
      ret = mxp_tag("RoomDesc", ret, this_player());
      ret += this_player()->colour_event("exits", "%^GREEN%^") +
         mxp_tag("RoomExits", mxp_choice(long_exit, long_exit_mxp, this_player()), this_player())
         +"%^RESET%^\n"+ query_contents( "" );
   }
   if ( query_property( "no exit cache" ) )  {
      long_exit = 0;
   }
   return mxp_secure(this_player()) + ret + mxp_open(this_player());
}
string pretty_short( object thing ) {
   int dark;
   if ( thing ) {
      dark = (int)thing->check_dark( (int)this_object()->query_light() );
   }
   return ::short( dark );
}
int query_visibility() {
   return 100;
}
int can_use_for_co_ords(string other) {
   return 1;
}
void calc_co_ord() {
  int i, j, k, shift, *delta, *other_co_ord;
  string other;
  mixed* std_orders = STD_ORDERS;
  for ( i = sizeof( dest_other ) - 2; ( i > -1 ) && !co_ord; i -= 2 ) {
    other = dest_other[ i + 1 ][ ROOM_DEST ];
    if ( !find_object( other ) ) {
       continue;
    }
    if ( other->query_do_not_use_coords()) {
       continue;
    }
    if (stringp(other) && other[0..2] == "/w/") {
       continue;
    }
    other_co_ord = (int *)other->query_co_ord();
    if ( !other_co_ord ) {
      continue;
    }
    if (!other_co_ord[0] && !other_co_ord[1] && !other_co_ord[2]) {
      continue;
    }
    if (!can_use_for_co_ords(other)) {
       continue;
    }
    j = -1;
    if ( delta = dest_other[ i + 1 ][ ROOM_DELTA ] ) {
      co_ord = copy( other_co_ord );
      if (pointerp(delta)) {
        k = 3;
        while ( k-- ) {
          co_ord[ k ] -= delta[ k ];
        }
        continue;
      } else {
        j = member_array(delta, std_orders);
      }
    }
    if (j == -1) {
      j = member_array( dest_other[ i ], std_orders );
      if ( j == -1 ) {
        continue;
      }
    }
    co_ord = copy( other_co_ord );
    delta = query_room_size_array() + (int *)other->query_room_size_array();
    for ( k = 0; k < 3; k++ ) {
      co_ord[ k ] += std_orders[ j + 1 ][ k ] *
        ( delta[ k ] + delta[ k + 3 ] );
    }
    if ( ( j < 16 ) && dest_other[ i + 1 ][ ROOM_GRADE ] ) {
      switch ( j ) {
      case 0 .. 1 :
        shift = delta[ 0 ] + delta[ 3 ];
        break;
      case 2 .. 3 :
        shift = delta[ 1 ] + delta[ 4 ];
        break;
      default :
        shift = delta[ 0 ] + delta[ 1 ] + delta[ 3 ] + delta[ 4 ];
      }
      co_ord[ 2 ] -= ( dest_other[ i + 1 ][ ROOM_GRADE ] * shift ) / 100;
      }
    co_ord_calculated = 1;
  }
}
void calc_exits() {
   int i, j;
   string exit, word, *tmp_al;
   _exits = ({ });
   for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
      exit = dest_other[ i ];
      if ( member_array( exit, _exits ) == -1 ) {
         _exits += ({ exit });
         word = SHORTEN[ exit ];
         if ( stringp( word ) ) {
            _exits += ({ word });
         }
      }
      tmp_al = aliases;
      j = member_array( exit, tmp_al );
      while ( j != -1 ) {
         if ( j % 2 ) {
            j--;
         } else {
            word = tmp_al[ j + 1 ];
            if ( member_array( word, _exits ) == -1 ) {
               _exits += ({ word });
            }
         }
         tmp_al = delete( tmp_al, j, 2 );
         j = member_array( exit, tmp_al );
      }
   }
}
void init() {
  object ob;
  int i;
  if(this_player() && interactive(this_player())) {
    if(((!last_visited && uptime() > 1800 + random(3600)) ||
      (last_visited && (time() - last_visited > random(900) + 900)))) {
      if(clonep(this_object()))
        this_player()->adjust_xp(random(random(50)), 0);
      else
        this_player()->adjust_xp(random(random(500)), 0);
    }
    last_visited = time();
  }
  if(is_day != -1 && ((WEATHER_HANDLER->query_day() > 0) != is_day)) {
    is_day = (1 - is_day);
    if(variablelongs && strlen(variablelongs[is_day]))
      set_long(variablelongs[is_day]);
    if(variableitems) {
      for(i=0; i<sizeof(variableitems[1-is_day]); i += 2)
        remove_item(variableitems[1-is_day][i]);
      for(i=0; i<sizeof(variableitems[is_day]); i += 2)
        add_item(variableitems[is_day][i], variableitems[is_day][i+1]);
    }
    setup_room_chat();
  }
  if(chatter) {
    chatter->check_chat();
  }
  if(sitchanger) {
    sitchanger->check_situations();
  }
  if(!sizeof(_exits)) {
    calc_exits();
  }
  if(!pointerp(co_ord)) {
    this_object()->calc_co_ord();
  }
  foreach (ob in hidden_objects) {
    if ( ob && objectp( ob ) ) {
      ob->init();
    } else {
      hidden_objects -= ({ 0, ob });
    }
  }
  if (this_player() && userp(this_player())) {
    foreach (ob in _use_internal_objects) {
      if (ob && objectp(ob)) {
        _use_internal_objects->find_inv_match("all", this_player())->init();
      } else {
        _use_internal_objects -= ({ 0, ob });
      }
    }
  }
  if(item) {
    item->init();
  }
}
string *query_zones() {
  string *zones;
  zones = query_property( "room zone" );
  if ( !zones ) {
    return ({ "nowhere" });
  }
  return zones + ({ });
}
void add_zone(string zone) {
   string *zones;
   zones = query_property( "room zone" );
   if ( !zones ) {
      zones = ({ zone });
   } else {
      zones += ({ zone });
   }
   add_property( "room zone", zones );
}
void remove_zone(string zone) {
   string *zones;
   zones = query_property( "room zone" );
   if ( !zones ) {
      return;
   } else {
      zones -= ({ zone });
   }
   add_property( "room zone", zones );
}
void set_zone( string zone ) {
   add_zone(zone);
}
int query_exit( string direc ) {
  return ( member_array( direc, dest_other ) != -1 );
}
int add_exit( string direc, mixed dest, string type ) {
   mixed *stuff;
   if ( !dest_other ) dest_other = ({ });
   if ( member_array( direc, dest_other ) != -1 ) return 0;
   if ( objectp( dest ) )
      dest = file_name( dest );
   if ( dest[ 0 .. 0 ] != "/" )
      dest = "/"+ dest;
   stuff = ({ dest }) + (mixed *)ROOM_HANDLER->query_exit_type( type, direc );
   dest_other += ({ direc, stuff });
   stuff = ROOM_HANDLER->query_door_type( type, direc,
                                                         dest );
   if ( stuff ) {
      door_control[ direc ] = clone_object( DOOR_OBJECT );
      door_control[ direc ]->setup_door( direc, this_object(), dest, stuff,
                                         type);
      hidden_objects += ({ door_control[ direc ] });
      if (door_control[ direc ]->query_door_name()) {
         door_control[ dest + " " + door_control[ direc ]->query_door_name()] = direc;
      } else {
         door_control[ dest ] = direc;
      }
   }
   if ( find_call_out( "calc_exits" ) == -1 ) {
      call_out( "calc_exits", 1 );
   }
   long_exit = 0;
   short_exit = 0;
   return 1;
}
int modify_exit( mixed direc, mixed *data ) {
   int i, j, k;
   if(pointerp(direc)) {
     for(k = 0; k < sizeof(direc); k++) {
       modify_exit(direc[k], data);
     }
     return 0;
   }
   if ( ( i = member_array( direc, dest_other ) ) == -1 ) {
     return 0;
   }
   for ( j = 0; j < sizeof( data ); j+= 2 ) {
     switch ( lower_case( data[ j ] ) ) {
     case "message" :
       dest_other[ i + 1 ][ ROOM_EXIT ] = data[ j + 1 ];
       break;
     case "exit mess" :
     case "exit_mess" :
       dest_other[ i + 1 ][ ROOM_EXIT ] = data[ j + 1 ];
       break;
     case "move mess" :
       dest_other[ i + 1 ][ ROOM_MESS ] = data[ j + 1 ];
       break;
     case "linker mess" :
       dest_other[ i + 1 ][ ROOM_LINK_MESS ] = data[ j + 1 ];
       break;
     case "obvious" :
       dest_other[ i + 1 ][ ROOM_OBV ] = data[ j + 1 ];
       if ( !intp( data[ j + 1 ] ) )
         add_property( "no exit cache", 1 );
       long_exit = 0;
       short_exit = 0;
       break;
     case "function" :
       dest_other[ i + 1 ][ ROOM_FUNC ] = data[ j + 1 ];
       break;
     case "size" :
       dest_other[ i + 1 ][ ROOM_SIZE ] = data[ j + 1 ];
       break;
     case "upgrade" :
       dest_other[ i + 1 ][ ROOM_GRADE ] = data[ j + 1 ];
       break;
     case "downgrade" :
       dest_other[ i + 1 ][ ROOM_GRADE ] = -data[ j + 1 ];
       break;
     case "enter" :
       dest_other[ i + 1 ][ ROOM_ENTER ] = data[ j + 1 ];
       break;
     case "enter mess" :
     case "enter_mess" :
       if ( sizeof( dest_other[ i + 1 ][ ROOM_ENTER ] ) == 2 )
         dest_other[ i + 1 ][ ROOM_ENTER ] = replace( data[ j + 1 ],
           "$F", dest_other[ i + 1 ][ ROOM_ENTER ][ 1 ] );
       else
         dest_other[ i + 1 ][ ROOM_ENTER ] = data[ j + 1 ];
       break;
     case "dest" :
       dest_other[ i + 1 ][ ROOM_DEST ] = data[ j + 1 ];
       if ( objectp( door_control[ direc ] ) ) {
         map_delete(door_control, door_control[ direc ]->query_dest() + " " + door_control[ direc ]->query_door_name());
         door_control[ direc ]->set_dest( data[ j + 1 ] );
         door_control[ data[ j + 1 ] ] = direc;
         if (door_control[ direc ]->query_door_name()) {
            door_control[ data[ j + 1 ] + " " + door_control[ direc ]->query_door_name()] = direc;
         }
       }
       break;
     case "door name" :
       if ( objectp( door_control[ direc ] ) ) {
          map_delete(door_control, door_control[ direc ]->query_dest() + " " + door_control[ direc ]->query_door_name());
          door_control[ direc ]->set_door_name( data[ j + 1 ] );
          door_control[ door_control[ direc ]->query_dest() + " " + data[ j + 1 ]] = direc;
       }
       break;
     case "relative" :
       dest_other[ i + 1 ][ ROOM_REL ] = data[ j + 1 ];
       break;
     case "lock owner" :
       if ( objectp( door_control[ direc ] ) ) {
          door_control[ direc ]->set_lock_owner( data[ j + 1 ] );
       }
       break;
     case "look" :
       dest_other[ i + 1][ ROOM_LOOK ] = data[ j + 1 ];
       break;
     case "look func" :
       dest_other[ i + 1][ ROOM_LOOK_FUNC ] = data[ j + 1 ];
       break;
     case "no map" :
       dest_other[ i + 1][ ROOM_NO_MAP ] = data[ j + 1 ];
       break;
     case "delta" :
       dest_other[ i + 1][ ROOM_DELTA ] = data[ j + 1 ];
       break;
     case "closed" :
       if ( objectp( door_control[ direc ] ) ) {
         if ( data[j+1]) {
            door_control[ direc ]->set_closed();
         } else {
            door_control[ direc ]->set_open();
         }
       }
       break;
     case "open" :
       if ( objectp( door_control[ direc ] ) ) {
         if ( data[j+1]) {
            door_control[ direc ]->set_open();
         } else {
            door_control[ direc ]->set_closed();
         }
       }
       break;
     case "transparent" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_transparent() :
           door_control[ direc ]->reset_transparent();
       }
       break;
     case "stuck" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_stuck( data[ j + 1 ] );
       }
       break;
     case "locked" :
       if ( objectp( door_control[ direc ] ) ) {
         if(data[j+1]) {
           door_control[ direc ]->set_closed();
           door_control[ direc ]->set_locked();
         } else
           door_control[ direc ]->set_unlocked();
       }
       break;
     case "unlocked" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_unlocked() :
           door_control[ direc ]->set_locked();
       }
       break;
     case "autolock":
       if ( objectp( door_control [direc ] ) ) {
         door_control[ direc ]->set_autolock( data[ j + 1 ] );
       }
       break;
     case "key" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_key( data[ j + 1 ] );
       }
       break;
     case "other" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_other_id( data[ j + 1 ] );
       }
       break;
     case "difficulty" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_difficulty( data[ j + 1 ] );
       }
       break;
     case "door long" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_long( data[ j + 1 ] );
       }
       break;
     case "open/close func" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[direc]->set_open_trap(data[j+1][0], data[j+1][1]);
       }
       break;
     case "lock/unlock func" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[direc]->set_lock_trap(data[j+1][0], data[j+1][1]);
       }
       break;
     case "door short" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_short( data[ j + 1 ] );
       }
       break;
     case "double doors" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_how_many( data[ j + 1 ] );
       }
       break;
     case "one way" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_one_way( data[ j + 1 ] );
       }
       break;
     case "secret" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->remove_hide_invis( "secret" );
         if ( data[ j + 1 ] > 0 ) {
           door_control[ direc ]->add_hide_invis( "secret", 0,
                                                  data[ j + 1 ], 0 );
         }
       }
       break;
     case "undoor" :
       if ( objectp( door_control[ direc ] ) ) {
         map_delete( door_control, dest_other[ i + 1 ][ ROOM_DEST ] + " " +
                                   door_control[ direc ]->query_door_name() );
         door_control[ direc ]->go_away();
         hidden_objects -= ({ door_control[ direc ] });
         map_delete( door_control, direc );
         map_delete( door_control, dest_other[ i + 1 ][ ROOM_DEST ] );
       }
       break;
     case "no follow" :
       if (data[j + 1]) {
         dest_other[ i + 1 ][ROOM_NPC_STOP] = 1;
       } else {
         dest_other[ i + 1 ][ROOM_NPC_STOP] = 0;
       }
       break;
     }
   }
   return 1;
}
int remove_exit( string direc ) {
  int i;
  if ( !dest_other ) {
    dest_other = ({ });
    return 0;
  }
  i = member_array( direc, dest_other );
  if ( i == -1 )
    return 0;
  if ( door_control[ direc ] ) {
    door_control[ direc ]->dest_me();
    hidden_objects -= ({ door_control[ direc ] });
    door_control = m_delete( door_control, direc );
    door_control = m_delete( door_control, dest_other[ i + 1 ][ ROOM_DEST ] );
  }
  dest_other = delete( dest_other, i, 2 );
  if ( find_call_out( "calc_exits" ) == -1 )
    call_out( "calc_exits", 1 );
   long_exit = 0;
   short_exit = 0;
  return 1;
}
int query_door_open( string direc ) {
  if ( !objectp( door_control[ direc ] ) ) {
    return -1;
  }
  return (int)door_control[ direc ]->query_open();
}
int query_relative( string direc ) {
   int i;
   i = member_array( direc, dest_other );
   if ( i == -1 ) {
      return 0;
   }
   return dest_other[ i + 1 ][ ROOM_REL ];
}
string query_look( string direc ) {
   int i;
   i = member_array( direc, dest_other );
   if ( i == -1 )
      return 0;
   if ( !dest_other[ i + 1 ] )
      return 0;
   return (string)evaluate(dest_other[ i + 1 ][ ROOM_LOOK ]);
}
mixed *query_look_func( string direc ) {
  int i;
  if ( ( i = member_array( direc, dest_other ) ) == -1 ) return 0;
  if( !dest_other[ i + 1 ] ) return 0;
  return dest_other[ i + 1 ][ ROOM_LOOK_FUNC ];
}
int query_size( string direc ) {
  int i;
  if ( ( i = member_array( direc, dest_other ) ) == -1 ) return 0;
  if ( stringp( dest_other[ i + 1 ][ ROOM_SIZE ] ) )
    return (int)call_other( this_object(), dest_other[ i + 1 ][ ROOM_SIZE ] );
  if ( pointerp( dest_other[ i + 1 ][ ROOM_SIZE ] ) )
    return (int)call_other( dest_other[ i + 1 ][ ROOM_SIZE ][ 0 ],
        dest_other[ i + 1 ][ ROOM_SIZE ][ 1 ] );
  return dest_other[ i + 1 ][ ROOM_SIZE ];
}
void event_magic( object channel, int amount, object caster ) {
   add_enchant( amount / 5 );
}
void event_theft( object command_ob, object thief, object victim,
                  object *stolen ) {
  if(thief->query_caster())
    thief = find_player(thief->query_caster());
  else if(thief->query_owner())
    thief = thief->query_owner();
  log_file( "THEFT", "%s: %s stole %s from %s in %s\n",
            ctime( time() )[4..18], (string)thief->query_short(),
            implode( (string *)stolen->query_short(), ", " ),
            (string)victim->query_short(), file_name() );
  if ( stringp( theft_handler )) {
    if( theft_handler != "none" )
      theft_handler->handle_theft( this_object(), command_ob, thief,
                                   victim, stolen );
  } else
    "/obj/handlers/theft_handler"->handle_theft( this_object(), command_ob,
                                                 thief, victim, stolen );
}
int query_last_visited() { return last_visited; }
varargs int add_item( mixed shorts, mixed desc, int no_plural ) {
  if (!desc) {
     printf("Error!  In %O add_item(%O, 0), not added.\n", file_name(),
                                                           shorts);
     return 0;
  }
  if ( !item ) {
     item = clone_object( ITEM_OBJECT );
  }
  item->setup_item( shorts, desc, no_plural );
  return 1;
}
int remove_item( string word ) {
  if ( !item ) {
    return 1;
  }
  return (int)item->remove_item( word );
}
int modify_item( string word, mixed new_desc ) {
  if ( !item ) {
    return 0;
  }
  return (int)item->modify_item( word, new_desc );
}
varargs int set_linker( string *rooms, string d_prep, string s_prep,
    string r_name ) {
  if ( linker ) {
    return 0;
  }
  linker = clone_object( LINKER_OBJECT );
  linker->setup_shadow( this_object(), rooms, d_prep, s_prep, r_name );
  return 1;
}
int set_terrain( string terrain_name ) {
   if ( terrain ) {
      return 0;
   }
   terrain = clone_object( TERRAIN_OBJECT );
   terrain->setup_shadow( this_object(), terrain_name );
   set_not_replaceable(1);
   return 1;
}
void set_wall( mixed *args ) {
   if ( !wall ) {
      wall = clone_object( WALL_OBJECT );
      wall->setup_shadow( this_object() );
   }
   wall->set_wall( args );
}
void set_default_position(mixed stuff) {
  add_property(DEFAULT_POSITION_PROPERTY, stuff);
}
mixed query_default_position() {
   return query_property(DEFAULT_POSITION_PROPERTY);
}
int is_allowed_position(string poss) {
  switch (poss) {
    case SITTING :
    case STANDING :
    case KNEELING :
    case LYING :
    case MEDITATING :
    case CROUCHING :
      return 1;
    default :
      return 0;
  }
}
void dest_me() {
  object thing;
  if ( file_name( this_object() ) != ROOM_VOID ) {
    foreach( thing in all_inventory( this_object() ) ) {
      if ( userp( thing ) ) {
        thing->move_with_look( ROOM_VOID, "$N fall$s into the void." );
        continue;
      }
      thing->dest_me();
    }
  }
  if ( chatter )
    chatter->dest_me();
  if ( sitchanger )
    sitchanger->dest_me();
  if ( linker )
    linker->destruct_shadow( linker );
  if ( terrain )
    terrain->destruct_shadow( terrain );
  if(wall)
    wall->destruct_shadow(wall);
  if ( item )
    item->dest_me();
  if(door_control)
    foreach(thing in keys(door_control))
      if(objectp(thing))
        catch(thing->dest_me());
  if ( sizeof( hidden_objects ) )
    foreach( thing in hidden_objects ) {
      if ( objectp( thing ) && ( thing->multiple_hidden() == 0 ) )
        catch( thing->dest_me() );
    }
  destruct( this_object() );
}
void set_keep_room_loaded(int flag) {
   add_property(ROOM_KEEP_PROP, flag);
}
int query_keep_room_loaded() {
   return query_property(ROOM_KEEP_PROP);
}
int clean_up( int parent ) {
  if (parent) {
    return 0;
  }
  if (this_object()->query_keep_room_loaded()) {
      return 0;
  }
  call_out("real_clean", 30 + random(120));
  return 1;
}
int real_clean() {
   object thing;
   foreach ( thing in all_inventory( this_object() ) ) {
     if(thing->query_property("transient")) {
       if(thing->query_property("hospital"))
         thing->move(thing->query_property("hospital"), "$N wander$s in.",
                     "$N wander$s out.");
       else
         thing->move("/room/rubbish", "$N wander$s in.", "$N wander$s out.");
     }
     if ( thing->query_property( "player" ) ||
          (thing->query_property( "unique" ) &&
           last_visited > time() - 3600) ||
          thing->query_slave() ||
          thing->query_name() == "corpse") {
         return 0;
      }
   }
   dest_me();
   return 1;
}
int filter_inventory(object item, object looker) {
  return item && item->short(0) && (!looker || item->query_visible(looker));
}
object *find_inv_match( string words, object looker ) {
   object *things;
   things = all_inventory( this_object() );
   if ( pointerp( hidden_objects ) ) {
      things += hidden_objects;
   }
   if (looker && userp(looker)) {
      things = filter(things, "filter_inventory", this_object(), looker);
   }
   if ( item ) {
      things += ({ item });
   }
   return things;
}
varargs object add_sign( string sign_long, mixed sign_read_mess, string
    sign_short, mixed sign_name, string sign_language ) {
  object sign;
  string* bits;
  sign = clone_object( "/std/object" );
  if ( !sign_name ) {
     sign_name = "sign";
  }
  if (pointerp(sign_name)) {
    bits = explode(sign_name[0], " ");
    sign->set_name( bits[<1] );
    sign->add_adjective( bits[0..<2]);
    sign->add_alias(implode(map(sign_name[1..], (: explode($1, " ")[<1] :)),
           (: $1 | ({ $2 }) :), ({ })));
    sign->add_plural(implode(map(sign_name[1..],
           (: pluralize(explode($1, " ")[<1]) :)), (: $1 | ({ $2 }) :), ({ })));
    sign->add_adjective(implode(map(sign_name[1..],
           (: explode($1, " ")[0..<2] :)), (: $1 | ({ $2 }) :), ({ })));
  } else {
    bits = explode(sign_name, " ");
    sign->set_name( bits[<1] );
    sign->add_adjective( bits[0..<2]);
  }
  sign->set_long( sign_long );
  if ( !sign_language ) sign_language = "common";
  sign->set_read_mess( sign_read_mess, sign_language );
  sign->reset_get();
  if ( sign_short && ( sign_short != "" ) ) {
    sign->set_short( sign_short );
    sign->set_main_plural( pluralize( sign_short ) );
    sign->move( this_object() );
    sign->add_property("there", "here");
  } else {
    hidden_objects += ({ sign });
    bits = sign->query_adjectives();
    if (sizeof(bits) > 0)
      sign->set_short(implode(bits, " ") + " " + sign->query_name());
    else
      sign->set_short(sign->query_name());
  }
  return sign;
}
void tell_door( string direc, string message, object thing ) {
   if ( objectp( door_control[ direc ] ) )
      door_control[ direc ]->tell_door( message, thing );
}
varargs mixed call_door( string direc, string func, mixed arg1, mixed arg2,
      mixed arg3 ) {
   if ( objectp( door_control[ direc ] ) )
      return (mixed)call_other( door_control[ direc ], func, arg1, arg2,
            arg3 );
}
string query_door( mixed dest, string name ) {
   int i;
   string direc;
   mixed bing;
   if ( objectp( dest ) ) {
      dest = file_name( dest );
   }
   if ( !stringp( dest ) ) {
      return 0;
   }
   if (name) {
      bing = door_control[ dest + " " + name];
      if (!bing) {
         bing = door_control[ dest ];
      }
   } else {
      bing = door_control[ dest ];
   }
   if ( bing ) {
      if ( !objectp( bing ) ) {
         direc = bing;
      }
   }
   if ( !direc ) {
      return 0;
   }
   bing = door_control[ direc ];
   if ( objectp( bing ) ) {
      return direc;
   }
   bing = clone_object( DOOR_OBJECT );
   i = member_array( direc, dest_other );
   bing->setup_door( direc, this_object(), dest, dest_other[ i + 1 ] );
   hidden_objects += ({ bing });
   door_control[ direc ] = bing;
   return direc;
}
void stop_room_chats() {
   if ( chatter ) {
      chatter->dest_me();
   }
}
void set_chat_min_max( int min,int  max ) {
  if (chatter) chatter->set_chat_min_max(min,max);
}
void add_room_chats( string *new_chats ) {
  if (chatter) {
    chatter->add_room_chats( new_chats );
  }
}
void remove_room_chats( string *dead_chats ) {
  if (chatter) {
    chatter->remove_room_chats( dead_chats );
  }
}
mixed *query_room_chats() {
  if (chatter) {
    return chatter->query_room_chats();
  }
  return 0;
}
private void setup_room_chat() {
  mixed* chats;
  if (!chatter) {
    chatter = clone_object( CHATTER_OBJECT );
    if(base_name(this_object()) == "/d/sur/Maps/basic_rooms/plains/plains")
      log_file("CHATTER", "%s cloned chatter: %O\n",
               file_name(this_object()), chatter);
  }
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }
  if (!variablechats) {
    variablechats = allocate(3);
  }
  if (is_day) {
    chats = variablechats[ROOM_DAY_INDEX];
  } else {
    chats = variablechats[ROOM_NIGHT_INDEX];
  }
  if (!chats) {
    chats = variablechats[ROOM_DEFAULT_INDEX];
  } else if (variablechats[ROOM_DEFAULT_INDEX]) {
    chats[2] += variablechats[ROOM_DEFAULT_INDEX][2];
  }
  chatter->setup_chatter( this_object(), chats );
}
varargs void room_chat( mixed *args, object chatobj ) {
   if (!args)  {
      return;
   }
   if ( !pointerp( args[ 2 ] ) ) {
      write( "Error: second argument of room_chat args is not an array.\n" );
      return;
   }
   if (!chatter && objectp(chatobj)) {
     chatter = chatobj;
   }
   if (!variablechats) {
      variablechats = allocate(3);
   }
   variablechats[ROOM_DEFAULT_INDEX] = args;
   setup_room_chat();
}
varargs object set_situation_changer( mixed changer ) {
  if (stringp(changer)) {
    sitchanger = clone_object( changer );
  } else if (objectp(changer)) {
    sitchanger = changer;
  } else {
    sitchanger = clone_object( SITUATION_CHANGER_OBJECT );
  }
  return (sitchanger = sitchanger->set_room( this_object() ));
}
void add_situation( mixed label, class situation sit ) {
  if (!sitchanger) {
    sitchanger = clone_object( SITUATION_CHANGER_OBJECT );
    sitchanger->set_room( this_object() );
  }
  sitchanger->add_situation( label, sit );
}
void make_situation_seed(int xval, int yval) {
  if (sitchanger) sitchanger->set_seed(xval,yval);
}
void start_situation(int label, int do_start_mess) {
  if (sitchanger)
    sitchanger->start_situation( label, do_start_mess );
}
void end_situation(mixed label) {
  if (sitchanger) sitchanger->end_situation( label );
}
varargs mixed change_situation( mixed label, mixed duration, mixed words ) {
  if (sitchanger)
    return sitchanger->change_situation(label,duration,words,0);
  return 0;
}
varargs void automate_situation( mixed label, mixed duration, mixed when,
    mixed chance, mixed category ) {
  if (sitchanger)
    sitchanger->automate_situation(label,duration,when,chance,category);
}
void shutdown_all_situations() {
  if (sitchanger) sitchanger->shutdown_all_situations();
}
void shutdown_situation(int call, mixed label) {
  if (sitchanger) sitchanger->shutdown_situation(call,label);
}
int query_not_replaceable() {
   return query_property(ROOM_NOT_REPLACE_PROGRAM_PROP);
}
void set_not_replaceable(int replace) {
   add_property(ROOM_NOT_REPLACE_PROGRAM_PROP, replace);
}
mixed stats() {
   int i;
   mixed *stuff;
   stuff = ({ });
   for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 )
      stuff += ({
         ({ dest_other[ i ], dest_other[ i + 1 ][ ROOM_DEST ] })
      });
   if ( co_ord )
      stuff += ({
         ({ "co-ord x", co_ord[ 0 ] }),
         ({ "co-ord y", co_ord[ 1 ] }),
         ({ "co-ord z", co_ord[ 2 ] })
      });
   return light::stats() + property::stats() + effects::stats() + stuff + ({
      ({ "short", short( 0 ) }),
      ({ "enchantment", query_enchant() }),
      ({ "background enchantment", background_enchant }),
      ({ "dynamic enchantment", dynamic_enchant }),
      ({ "enchantment time", enchant_time }),
      ({ "theft handler", theft_handler }),
   });
}
void set_day_long( string str ) {
  if(!variablelongs) {
    variablelongs = allocate(2);
  }
  variablelongs[ROOM_DAY_INDEX] = str;
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }
  if(is_day == ROOM_DAY_INDEX) {
    set_long(str);
  }
}
string query_day_long() {
   if(variablelongs && strlen(variablelongs[ROOM_DAY_INDEX]))
     return variablelongs[ROOM_DAY_INDEX];
   return this_object()->query_long();
}
void set_night_long( string str ) {
  if(!variablelongs)
    variablelongs = allocate(2);
  variablelongs[ROOM_NIGHT_INDEX] = str;
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == ROOM_NIGHT_INDEX)
    set_long(str);
}
string query_night_long() {
   if(variablelongs && strlen(variablelongs[ROOM_NIGHT_INDEX]))
     return variablelongs[ROOM_NIGHT_INDEX];
   return this_object()->query_long();
}
private string return_long(mixed desc) {
  int ma;
  if(!pointerp(desc))
    return (string)desc;
  ma = member_array("long", desc);
  if(ma < 0)
    return "Error: No long found.";
  return (string)desc[ma+1];
}
varargs int add_day_item(mixed shorts, mixed desc, mixed no_plural) {
  string the_item;
  if(pointerp(shorts))
    the_item = shorts[0];
  else
    the_item = shorts;
  if(!variableitems)
    variableitems = ({ ({ }), ({ }) });
  variableitems[ROOM_DAY_INDEX] += ({ the_item, return_long(desc) });
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == ROOM_DAY_INDEX)
    return add_item(shorts, desc, no_plural);
  return 1;
}
varargs int add_night_item(mixed shorts, mixed desc, mixed no_plural) {
  string the_item;
  if(pointerp(shorts))
    the_item = shorts[0];
  else
    the_item = shorts;
  if(!variableitems)
    variableitems = ({ ({ }), ({ }) });
  variableitems[ROOM_NIGHT_INDEX] += ({ the_item, return_long( desc ) });
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }
  if(is_day == ROOM_NIGHT_INDEX)  {
    return add_item(shorts, desc, no_plural);
  }
  return 1;
}
void room_day_chat(mixed *args) {
  if(!variablechats) {
    variablechats = allocate(3);
  }
  variablechats[ROOM_DAY_INDEX] = args;
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }
  if(is_day == ROOM_DAY_INDEX) {
    setup_room_chat();
  }
}
void room_night_chat( mixed *args ) {
  if(!variablechats) {
    variablechats = allocate(3);
  }
  variablechats[ROOM_NIGHT_INDEX] = args;
  if(is_day == -1) {
    is_day = (WEATHER_HANDLER->query_day() > 0);
  }
  if(is_day == ROOM_NIGHT_INDEX) {
    setup_room_chat();
  }
}
string query_help_file_directory() {
  return ROOM_HELP_FILE_DIR;
}
mixed* query_room_night_chats() {
  if (sizeof (variablechats)) {
    return variablechats[ROOM_NIGHT_INDEX];
  }
  return ({ });
}
mixed* query_room_day_chats() {
  if (sizeof (variablechats)) {
    return variablechats[ROOM_DAY_INDEX];
  }
  return ({ });
}
mixed* query_room_default_chats() {
   if (sizeof(variablechats)) {
      return variablechats[ROOM_DEFAULT_INDEX];
   }
   return ({ });
}
mixed* query_day_items() {
  if (sizeof (variableitems)) {
    return variableitems[ROOM_DAY_INDEX];
  }
  return ({ });
}
mixed* query_night_items() {
  if (sizeof (variableitems)) {
    return variableitems[ROOM_NIGHT_INDEX];
  }
  return ({ });
}

==================================================
FILE: room/basic_room_new.c
==================================================

#include <armoury.h>
#include <dirs.h>
#include <door.h>
#include <move_failures.h>
#include <room.h>
#include <position.h>
#include <situations.h>
#include <twilight.h>
#include <nroff.h>
inherit "/std/basic/cute_look";
inherit "/std/basic/desc";
inherit "/std/basic/extra_look";
inherit "/std/basic/light";
inherit "/std/basic/property";
inherit "/std/basic/export_inventory";
inherit "/std/basic/help_files";
nosave int do_setup;
nosave int *co_ord;
nosave int co_ord_calculated;
nosave string long_exit;
nosave string short_exit;
nosave string theft_handler;
nosave string *aliases;
nosave string *exits;
nosave object item;
nosave object chatter;
nosave object sitchanger;
nosave object effects;
nosave object linker;
nosave object terrain;
nosave object wall;
nosave object *hidden_objects;
private nosave object* _use_internal_objects;
nosave mapping door_control;
nosave mixed *dest_other;
nosave int enchant_time;
nosave int background_enchant;
nosave float dynamic_enchant;
private nosave int last_visited;
nosave string *variablelongs;
nosave mixed variablechats;
nosave mixed variableitems;
nosave int is_day = -1;
varargs int add_item( mixed shorts, mixed desc, int no_plural );
int remove_item( string word );
varargs void room_chat( mixed *args, object chatobj );
void set_not_replaceable(int replace);
int query_not_replaceable();
void set_night_long( string str );
protected void create() {
   object *npcs;
   object virt_room;
   string *inhs;
   desc::create();
   extra_look::create();
   property::create();
   export_inventory::create();
   light::create();
   set_can_export_inventory();
   set_ignore_livings_in_inventory( 0 );
   aliases = ({ });
   exits = ({ });
   hidden_objects = ({ });
   _use_internal_objects = ({ });
   door_control = ([ ]);
   dest_other = ({ });
   seteuid( (string)"/secure/master"->creator_file( file_name(
           this_object() ) ) );
   add_property( "location", "inside" );
   add_property( "here", "on the floor" );
   if ( !do_setup ) {
      this_object()->setup();
      this_object()->reset();
   }
   if ( find_object( "/obj/handlers/map" ) ) {
      catch( "/obj/handlers/map"->check_map( file_name( this_object() ) ) );
   }
   if( (virt_room = find_object("/room/virtual") ) ){
     npcs = ({}) + all_inventory(virt_room);
     catch(npcs->real_room(file_name()));
   }
   inhs = inherit_list(this_object());
   if (sizeof(inhs) == 1) {
      if (replaceable(this_object(), ({ "setup" }))) {
         call_out(function(string fname) {
           if (!query_not_replaceable()) {
             replace_program(fname);
           }
         }, 0, inhs[0]);
      }
   }
}
int query_is_room()
{
  return 1;
}
int query_enchant() {
  int enchant_level =  to_int( floor( 0.5 + dynamic_enchant *
                        exp( -0.693 *
                             ( time() - enchant_time ) /
                             ENCHANT_HALF)) +
                 background_enchant );
  if ( enchant_level > 5000 ) {
    return 5000;
  }
  return enchant_level;
}
int set_enchant(int number) {
  if (number < 0) {
    number = 0;
  }
  if (previous_object()==this_object()) {
    background_enchant = (float) number;
    dynamic_enchant = 0.0;
    enchant_time = time();
  } else {
    dynamic_enchant = number - background_enchant;
    enchant_time=time();
  }
  return number;
}
int add_enchant( int number ) {
  dynamic_enchant = dynamic_enchant * exp( -0.693 *
                                           ( time() - enchant_time ) /
                                           ENCHANT_HALF ) + number;
  enchant_time = time();
  return floor( 0.5 + dynamic_enchant ) + background_enchant;
}
void set_background_enchant( int number ) {
  background_enchant = number;
}
void set_dynamic_enchant( float number ) {
  dynamic_enchant = number;
  enchant_time = time();
}
int query_background_enchant() {
  return background_enchant;
}
float query_dynamic_enchant() {
  dynamic_enchant = dynamic_enchant * exp( -0.693 *
                                           ( time() - enchant_time ) /
                                           ENCHANT_HALF );
  enchant_time = time();
  return dynamic_enchant;
}
int *query_co_ord() {
  if ( pointerp( co_ord ) ) {
    return copy(co_ord);
  }
  return 0;
}
void set_co_ord( int *new_co_ord ) {
  if ( !pointerp( new_co_ord ) ) {
    write( "Warning: Co-ordinate must be an array.\n" );
    return;
  }
  if ( sizeof( new_co_ord ) != 3 ) {
      write( "Warning: The co-ordinate must have three elements.\n" );
      return;
  }
  co_ord = new_co_ord;
  if ( previous_object() == this_object() ) {
    co_ord_calculated = 0;
  } else {
    co_ord_calculated = 1;
  }
}
int query_co_ord_calculated() { return co_ord_calculated; }
string query_long_exit() { return long_exit; }
void calc_long_exit() {
  int i, add;
  string *words;
  mixed tmp;
  words = ({ });
  for ( i = 0; i < sizeof( dest_other ); i += 2 ) {
    tmp = dest_other[ i + 1 ][ ROOM_OBV ];
    if ( !tmp ) {
      continue;
    }
    if ( intp( tmp ) && tmp ) {
      add = 1;
    }
    if ( stringp( tmp ) ) {
      add = (int)call_other( this_object(), tmp, dest_other[ i ] );
    }
    if ( pointerp( tmp ) ) {
      add = (int)call_other( tmp[ 0 ], tmp[ 1 ], dest_other[ i ] );
    }
    if ( add ) {
      if(dest_other[i+1][ROOM_REL]) {
        words += ({ "$R$-"+ dest_other[ i ] +"$R$" });
      } else {
        words += ({ dest_other[i] });
      }
    }
  }
  switch ( sizeof( words ) ) {
  case 0 :
    long_exit = "There are no obvious exits.";
    break;
  case 1 :
    long_exit = "There is one obvious exit: "+ words[ 0 ];
    break;
  default :
    long_exit = "There are "+ query_num( sizeof( words ), 0 ) +
      " obvious exits: "+ query_multiple_short( words ) +
      ".";
  }
}
string query_theft_handler() { return theft_handler; }
void set_theft_handler( string word ) { theft_handler = word; }
string *query_aliases() { return copy( aliases ); }
void add_alias( mixed names, string word ) {
  string name;
  if ( !aliases ) {
    aliases = ({ });
  }
  if ( pointerp( names ) ) {
    foreach ( name in names ) {
      add_alias( name, word );
    }
    return;
  }
  aliases += ({ word, names });
  if ( find_call_out( "calc_exits" ) == -1 ) {
    call_out( "calc_exits", 1 );
  }
}
void remove_alias( mixed names, string word ) {
  int i;
  string name;
  if ( !aliases ) {
    return;
  }
  if ( pointerp( names ) ) {
    foreach ( name in names ) {
      remove_alias( name, word );
    }
    return;
  }
  for ( i = sizeof( aliases ) - 2; i >= -1; i -= 2 ) {
    if ( ( aliases[ i ] == word ) && ( aliases[ i + 1 ] == names ) ) {
      aliases = delete( aliases, i, 2 );
    }
  }
}
string *query_exits() { return copy(exits); }
void reset_exits() { exits = ({ }); }
object query_item() { return item; }
object query_chatter() { return chatter; }
object query_situation_changer() { return sitchanger; }
object query_effects() { return effects; }
object query_linker() { return linker; }
object query_terrain() { return terrain; }
object query_wall() { return wall; }
object *query_hidden_objects() { return hidden_objects + ({ }); }
int add_hidden_object( object thing ) {
  if ( member_array( thing, hidden_objects ) != -1 ) {
    return 0;
  }
  hidden_objects += ({ thing });
  return 1;
}
int remove_hidden_object( object thing ) {
  int i;
  i = member_array( thing, hidden_objects );
  if ( i == -1 ) {
    return 0;
  }
  hidden_objects = hidden_objects[0..i - 1] + hidden_objects[i + 1..];
  return 1;
}
void add_use_internal_object(object thing) {
   _use_internal_objects |= ({ thing });
}
void remove_use_internal_object(object thing) {
   _use_internal_objects -= ({ thing });
}
object* query_use_internal_objects() {
   return _use_internal_objects;
}
varargs mixed query_door_control( string direc ) {
   if ( !stringp( direc ) ) {
      return copy( door_control );
   }
   return door_control[ direc ];
}
varargs mixed *query_dest_other( string direc ) {
  int i;
  if ( !stringp( direc ) ) {
    return copy( dest_other );
  }
  i = member_array( direc, dest_other );
  if ( i == -1 ) {
    return 0;
  }
  return copy( dest_other[ i + 1 ] );
}
varargs string *query_dest_dir( object thing ) {
  int i;
  string *ret;
  ret = ({ });
  for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
    if ( !dest_other[ i + 1 ][ ROOM_REL ] || !objectp( thing ) ) {
      ret += ({ dest_other[ i ], dest_other[ i + 1 ][ ROOM_DEST ] });
    } else {
      ret += ({ (string)thing->find_rel( dest_other[ i ] ),
                  dest_other[ i + 1 ][ ROOM_DEST ] });
    }
  }
  return ret;
}
varargs string *query_direc( object thing ) {
  int i;
  string *ret;
  ret = ({ });
  for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
    if ( !dest_other[ i + 1 ][ ROOM_REL ] || !objectp( thing ) ) {
      ret += ({ dest_other[ i ] });
    } else {
      ret += ({ (string)thing->find_rel( dest_other[ i ] ) });
    }
  }
  return ret;
}
string query_destination( string exit ) {
   int i;
   i = member_array( exit, dest_other );
   if ( ( i < 0 ) && objectp( this_player() ) )
      i = member_array( (string)this_player()->reorient_rel( exit ),
            dest_other );
   if ( i < 0 )
      return ROOM_VOID;
   return dest_other[ i + 1 ][ ROOM_DEST ];
}
int test_add( object thing, int flag ) { return 1; }
int test_remove( object thing, int flag, mixed dest ) { return 1; }
int add_weight( int number ) { return 1; }
int query_no_writing() { return 1; }
int query_decay() { return 10; }
int attack_speed() { return 15; }
string query_dark_mess() {
  mixed dark_mess;
  if ( !stringp( dark_mess = query_property( "dark mess" ) ) ) {
    return "It's dark here, isn't it?";
  }
  return dark_mess;
}
void set_dark_mess( string word ) {
    add_property( "dark mess", word );
}
string query_bright_mess() {
  mixed bright_mess;
  if ( !stringp( bright_mess = query_property( "bright mess" ) ) ) {
    return "It's too bright to see anything!";
  }
  return bright_mess;
}
void set_bright_mess( string word ) { add_property( "bright mess", word ); }
mixed query_room_size() {
   mixed room_size;
   room_size = query_property( "room size" );
   if ( !room_size ) {
      return 10;
   }
   return room_size;
}
int *query_room_size_array() {
   mixed room_size;
   room_size = query_room_size();
   if ( pointerp( room_size ) ) {
      return room_size;
   }
   return ({ room_size, room_size, room_size });
}
void set_room_size( mixed number ) {
   if ( intp( number ) ) {
      add_property( "room size", number );
      return;
   }
   if ( pointerp( number ) ) {
      if ( sizeof( number ) == 3 ) {
         add_property( "room size", number );
         return;
      }
   }
   write( "Room size must be an integer or an array of three integers.\n" );
}
int id( string word ) { return 0; }
string expand_alias( string word ) {
   int i;
   if ( !aliases || !sizeof( aliases ) ) {
      return word;
   }
   i = member_array( word, aliases );
   if ( i == -1 ) {
      return word;
   }
   if ( i % 2 ) {
      return aliases[ i - 1 ];
   }
   return word;
}
string calc_short_exit_string() {
   int i, add;
   string *words;
   mixed tmp;
   words = ({ });
   for ( i = 0; i < sizeof( dest_other ); i += 2 ) {
      tmp = dest_other[ i + 1 ][ ROOM_OBV ];
      if ( !tmp ) {
         continue;
      }
      if ( intp( tmp ) && tmp ) {
         add = 1;
      }
      if ( stringp( tmp ) ) {
         add = (int)call_other( this_object(), tmp, dest_other[ i ] );
      }
      if ( pointerp( tmp ) ) {
         add = (int)call_other( tmp[ 0 ], tmp[ 1 ], dest_other[ i ] );
      }
      if ( add ) {
         if ( tmp = SHORTEN[ dest_other[ i ] ] ) {
            if (dest_other[i+1][ROOM_REL]) {
               words += ({ "$r$-"+tmp+"$r$" });
            } else {
               words += ({ tmp });
            }
         } else {
            if (dest_other[i+1][ROOM_REL]) {
               words += ({ "$r$-"+dest_other[ i ]+"$r$" });
            } else {
               words += ({ dest_other[i] });
            }
         }
      }
   }
   if(!sizeof(words)) {
     return " [none]";
   }
   return " ["+ implode( words, "," ) +"]";
}
string query_short_exit_string() {
   string tmp;
   if(short_exit) {
      return this_player()->colour_event("exits", "%^GREEN%^") +
     short_exit + "%^RESET%^";
   }
   tmp = calc_short_exit_string();
   if (!query_property("no exit cache")) {
      short_exit = tmp;
   }
   return this_player()->colour_event("exits", "%^GREEN%^") +
     tmp + "%^RESET%^";
}
string enchant_string() {
   string words;
   words = (string)this_object()->query_property( "octarine_mess" );
   if ( words ) {
      return words +"\n";
   }
   switch ( query_enchant() ) {
      case 0 .. 49 :
         return "";
      case 50 .. 149 :
         return "There is the residual taste of magic in this place.\n";
      case 150 .. 299 :
         return "This place has seen some use of magic.\n";
      case 300 .. 499 :
         return "A considerable amount of magic has been used here.\n";
      case 500 .. 749 :
         return "A very large quantity of magic has been manipulated here.\n";
      case 750 .. 1000 :
         return "You can feel the Dungeon Dimensions trying to push in.\n";
      case 1001 .. 1500 :
         return "Little sparks flash in from the Dungeon Dimensions.\n";
      case 1501 .. 2000 :
         return "Apparations of things with lots of tentacles seem to be "
                "on the edge of your vision.\n";
      default :
         return "So much magic has been expended here that the area is in "+
               "danger of dumping itself into the Dungeon Dimensions.\n";
   }
}
string long( string word, int dark ) {
   string ret;
   if ( !long_exit ) {
      calc_long_exit();
   }
   if ( dark ) {
      if ( dark < 0 ) {
         ret = this_object()->query_dark_mess() +"\n";
      } else {
         ret = this_object()->query_bright_mess() +"\n";
      }
      if ( query_property( "location" ) == "outside" ) {
         ret += "$weather$";
      }
      if ( ( dark == 1 ) || ( dark == -1 ) ) {
         ret = "$C$"+ a_short() +".  "+ ret +
           this_player()->colour_event("exits", "%^GREEN%^") +long_exit
           +"%^RESET%^\n";
         if ( query_contents( "" ) != "" ) {
            ret += this_player()->colour_event("inventory", "") + "Some objects you can't make out are here.%^RESET%^\n";
         }
      }
   } else {
      if ( query_property( "location" ) == "outside" ) {
         ret = "$long$";
      } else {
         ret = query_long();
      }
      if(!ret) {
         ret = "Erk, this room seems to be broken.\n";
      }
      word = calc_extra_look();
      if ( stringp( word ) && ( word != "" ) ) {
         ret += word;
      }
      if ( this_player()->query_see_octarine() ) {
         ret += enchant_string();
      }
      if ( query_property( "location" ) == "outside" ) {
         ret += "$weather$";
      }
      ret += this_player()->colour_event("exits", "%^GREEN%^") +
        long_exit +"%^RESET%^\n"+ query_contents( "" );
   }
   if ( query_property( "no exit cache" ) )  {
      long_exit = 0;
   }
   return ret;
}
string pretty_short( object thing ) {
   int dark;
   if ( thing ) {
      dark = (int)thing->check_dark( (int)this_object()->query_light() );
   }
   return ::short( dark );
}
void calc_co_ord() {
  int i, j, k, shift, *delta, *other_co_ord;
  string other;
  for ( i = sizeof( dest_other ) - 2; ( i > -1 ) && !co_ord; i -= 2 ) {
    other = dest_other[ i + 1 ][ ROOM_DEST ];
    if ( !find_object( other ) ) {
      continue;
    }
    other_co_ord = (int *)other->query_co_ord();
    if ( !other_co_ord ) {
      continue;
    }
    j = -1;
    if ( delta = dest_other[ i + 1 ][ ROOM_DELTA ] ) {
      co_ord = copy( other_co_ord );
      if (pointerp(delta)) {
        k = 3;
        while ( k-- ) {
          co_ord[ k ] -= delta[ k ];
        }
        continue;
      } else {
        j = member_array(delta, STD_ORDERS);
      }
    }
    if (j == -1) {
      j = member_array( dest_other[ i ], STD_ORDERS );
      if ( j == -1 ) {
        continue;
      }
    }
    co_ord = copy( other_co_ord );
    delta = query_room_size_array() + (int *)other->query_room_size_array();
    for ( k = 0; k < 3; k++ ) {
      co_ord[ k ] += STD_ORDERS[ j + 1 ][ k ] *
        ( delta[ k ] + delta[ k + 3 ] );
    }
    if ( ( j < 16 ) && dest_other[ i + 1 ][ ROOM_GRADE ] ) {
      switch ( j ) {
      case 0 .. 1 :
        shift = delta[ 0 ] + delta[ 3 ];
        break;
      case 2 .. 3 :
        shift = delta[ 1 ] + delta[ 4 ];
        break;
      default :
        shift = delta[ 0 ] + delta[ 1 ] + delta[ 3 ] + delta[ 4 ];
      }
      co_ord[ 2 ] -= ( dest_other[ i + 1 ][ ROOM_GRADE ] * shift ) / 100;
      }
    co_ord_calculated = 1;
  }
}
void calc_exits() {
   int i, j;
   string exit, word, *tmp_al;
   exits = ({ });
   for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
      exit = dest_other[ i ];
      if ( member_array( exit, exits ) == -1 ) {
         exits += ({ exit });
         word = SHORTEN[ exit ];
         if ( stringp( word ) ) {
            exits += ({ word });
         }
      }
      tmp_al = aliases;
      j = member_array( exit, tmp_al );
      while ( j != -1 ) {
         if ( j % 2 ) {
            j--;
         } else {
            word = tmp_al[ j + 1 ];
            if ( member_array( word, exits ) == -1 ) {
               exits += ({ word });
            }
         }
         tmp_al = delete( tmp_al, j, 2 );
         j = member_array( exit, tmp_al );
      }
   }
}
void init() {
  object ob;
  int i;
  if(is_day != -1 && ((WEATHER_HANDLER->query_day() > 0) != is_day)) {
    is_day = (1 - is_day);
    if(variablelongs && strlen(variablelongs[is_day]))
      set_long(variablelongs[is_day]);
    if(variableitems) {
      for(i=0; i<sizeof(variableitems[1-is_day]); i += 2)
        remove_item(variableitems[1-is_day][i]);
      for(i=0; i<sizeof(variableitems[is_day]); i += 2)
        add_item(variableitems[is_day][i], variableitems[is_day][i+1]);
    }
    if(variablechats)
      room_chat(variablechats[is_day]);
  }
  if(chatter)
    chatter->check_chat();
  if(sitchanger)
    sitchanger->check_situations();
  if(!sizeof(exits))
    calc_exits();
  if(!pointerp(co_ord))
    this_object()->calc_co_ord();
  foreach (ob in hidden_objects) {
    if ( ob && objectp( ob ) ) {
      ob->init();
    } else {
      hidden_objects -= ({ 0, ob });
    }
  }
  if (userp(this_player())) {
    foreach (ob in _use_internal_objects) {
      if (ob && objectp(ob)) {
        _use_internal_objects->find_inv_match("all", this_player())->init();
      } else {
        _use_internal_objects -= ({ 0, ob });
      }
    }
  }
  if(item)
    item->init();
}
string *query_zones() {
  string *zones;
  zones = query_property( "room zone" );
  if ( !zones ) {
    return ({ "nowhere" });
  }
  return zones + ({ });
}
void add_zone(string zone) {
   string *zones;
   zones = query_property( "room zone" );
   if ( !zones ) {
      zones = ({ zone });
   } else {
      zones += ({ zone });
   }
   add_property( "room zone", zones );
}
void set_zone( string zone ) {
   add_zone(zone);
}
int query_exit( string direc ) {
  return ( member_array( direc, dest_other ) != -1 );
}
int add_exit( string direc, mixed dest, string type ) {
   mixed *stuff;
   if ( !dest_other ) dest_other = ({ });
   if ( member_array( direc, dest_other ) != -1 ) return 0;
   if ( objectp( dest ) )
      dest = file_name( dest );
   if ( dest[ 0 .. 0 ] != "/" )
      dest = "/"+ dest;
   stuff = ({ dest }) + (mixed *)ROOM_HANDLER->query_exit_type( type, direc );
   dest_other += ({ direc, stuff });
   if ( ( stuff = (mixed *)ROOM_HANDLER->query_door_type( type, direc,
                                                         dest ) ) ) {
      door_control[ direc ] = clone_object( DOOR_OBJECT );
      door_control[ direc ]->setup_door( direc, this_object(), dest, stuff,
                                         type);
      hidden_objects += ({ door_control[ direc ] });
      door_control[ dest ] = direc;
   }
   if ( find_call_out( "calc_exits" ) == -1 )
      call_out( "calc_exits", 1 );
   long_exit = 0;
   short_exit = 0;
   return 1;
}
int modify_exit( mixed direc, mixed *data ) {
   int i, j, k;
   if(pointerp(direc)) {
     for(k = 0; k < sizeof(direc); k++) {
       modify_exit(direc[k], data);
     }
     return 0;
   }
   if ( ( i = member_array( direc, dest_other ) ) == -1 ) {
     return 0;
   }
   for ( j = 0; j < sizeof( data ); j+= 2 ) {
     switch ( lower_case( data[ j ] ) ) {
     case "message" :
       dest_other[ i + 1 ][ ROOM_EXIT ] = data[ j + 1 ];
       break;
     case "exit mess" :
     case "exit_mess" :
       dest_other[ i + 1 ][ ROOM_EXIT ] = data[ j + 1 ];
       break;
     case "move mess" :
       dest_other[ i + 1 ][ ROOM_MESS ] = data[ j + 1 ];
       break;
     case "linker mess" :
       dest_other[ i + 1 ][ ROOM_LINK_MESS ] = data[ j + 1 ];
       break;
     case "obvious" :
       dest_other[ i + 1 ][ ROOM_OBV ] = data[ j + 1 ];
       if ( !intp( data[ j + 1 ] ) )
         add_property( "no exit cache", 1 );
       long_exit = 0;
       short_exit = 0;
       break;
     case "function" :
       dest_other[ i + 1 ][ ROOM_FUNC ] = data[ j + 1 ];
       break;
     case "size" :
       dest_other[ i + 1 ][ ROOM_SIZE ] = data[ j + 1 ];
       break;
     case "upgrade" :
       dest_other[ i + 1 ][ ROOM_GRADE ] = data[ j + 1 ];
       break;
     case "downgrade" :
       dest_other[ i + 1 ][ ROOM_GRADE ] = -data[ j + 1 ];
       break;
     case "enter" :
       dest_other[ i + 1 ][ ROOM_ENTER ] = data[ j + 1 ];
       break;
     case "enter mess" :
     case "enter_mess" :
       if ( sizeof( dest_other[ i + 1 ][ ROOM_ENTER ] ) == 2 )
         dest_other[ i + 1 ][ ROOM_ENTER ] = replace( data[ j + 1 ],
           "$F", dest_other[ i + 1 ][ ROOM_ENTER ][ 1 ] );
       else
         dest_other[ i + 1 ][ ROOM_ENTER ] = data[ j + 1 ];
       break;
     case "dest" :
       dest_other[ i + 1 ][ ROOM_DEST ] = data[ j + 1 ];
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_dest( data[ j + 1 ] );
         door_control[ data[ j + 1 ] ] = direc;
       }
       break;
     case "relative" :
       dest_other[ i + 1 ][ ROOM_REL ] = data[ j + 1 ];
       break;
     case "look" :
       dest_other[ i + 1][ ROOM_LOOK ] = data[ j + 1 ];
       break;
     case "look func" :
       dest_other[ i + 1][ ROOM_LOOK_FUNC ] = data[ j + 1 ];
       break;
     case "no map" :
       dest_other[ i + 1][ ROOM_NO_MAP ] = data[ j + 1 ];
       break;
     case "delta" :
       dest_other[ i + 1][ ROOM_DELTA ] = data[ j + 1 ];
       break;
     case "closed" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_closed() :
           door_control[ direc ]->set_open();
       }
       break;
     case "open" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_open() :
           door_control[ direc ]->set_closed();
       }
       break;
     case "transparent" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_transparent() :
           door_control[ direc ]->reset_transparent();
       }
       break;
     case "stuck" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_stuck( data[ j + 1 ] );
       }
       break;
     case "locked" :
       if ( objectp( door_control[ direc ] ) ) {
         if(data[j+1]) {
           door_control[ direc ]->set_closed();
           door_control[ direc ]->set_locked();
         } else
           door_control[ direc ]->set_unlocked();
       }
       break;
     case "unlocked" :
       if ( objectp( door_control[ direc ] ) ) {
         data[j+1] ? door_control[ direc ]->set_unlocked() :
           door_control[ direc ]->set_locked();
       }
       break;
     case "autolock":
       if ( objectp( door_control [direc ] ) ) {
         door_control[ direc ]->set_autolock( data[ j + 1 ] );
       }
       break;
     case "key" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_key( data[ j + 1 ] );
       }
       break;
     case "other" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_other_id( data[ j + 1 ] );
       }
       break;
     case "difficulty" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_difficulty( data[ j + 1 ] );
       }
       break;
     case "door long" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_long( data[ j + 1 ] );
       }
       break;
     case "open/close func" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[direc]->set_open_trap(data[j+1][0], data[j+1][1]);
       }
       break;
     case "lock/unlock func" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[direc]->set_lock_trap(data[j+1][0], data[j+1][1]);
       }
       break;
     case "door short" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_short( data[ j + 1 ] );
       }
       break;
     case "double doors" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_how_many( data[ j + 1 ] );
       }
       break;
     case "one way" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->set_one_way( data[ j + 1 ] );
       }
       break;
     case "secret" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->remove_hide_invis( "secret" );
         if ( data[ j + 1 ] > 0 ) {
           door_control[ direc ]->add_hide_invis( "secret", 0,
                                                  data[ j + 1 ], 0 );
         }
       }
       break;
     case "undoor" :
       if ( objectp( door_control[ direc ] ) ) {
         door_control[ direc ]->go_away();
         hidden_objects -= ({ door_control[ direc ] });
         door_control = m_delete( door_control, direc );
         door_control = m_delete( door_control,
                                  dest_other[ i + 1 ][ ROOM_DEST ] );
       }
       break;
     }
   }
   return 1;
}
int remove_exit( string direc ) {
  int i;
  if ( !dest_other ) {
    dest_other = ({ });
    return 0;
  }
  i = member_array( direc, dest_other );
  if ( i == -1 )
    return 0;
  if ( door_control[ direc ] ) {
    door_control[ direc ]->dest_me();
    hidden_objects -= ({ door_control[ direc ] });
    door_control = m_delete( door_control, direc );
    door_control = m_delete( door_control, dest_other[ i + 1 ][ ROOM_DEST ] );
  }
  dest_other = delete( dest_other, i, 2 );
  if ( find_call_out( "calc_exits" ) == -1 )
    call_out( "calc_exits", 1 );
   long_exit = 0;
   short_exit = 0;
  return 1;
}
int query_door_open( string direc ) {
  if ( !objectp( door_control[ direc ] ) ) {
    return -1;
  }
  return (int)door_control[ direc ]->query_open();
}
int query_relative( string direc ) {
   int i;
   i = member_array( direc, dest_other );
   if ( i == -1 ) {
      return 0;
   }
   return dest_other[ i + 1 ][ ROOM_REL ];
}
string query_look( string direc ) {
   int i;
   i = member_array( direc, dest_other );
   if ( i == -1 )
      return 0;
   if ( !dest_other[ i + 1 ] )
      return 0;
   return (string)evaluate(dest_other[ i + 1 ][ ROOM_LOOK ]);
}
mixed *query_look_func( string direc ) {
  int i;
  if ( ( i = member_array( direc, dest_other ) ) == -1 ) return 0;
  if( !dest_other[ i + 1 ] ) return 0;
  return dest_other[ i + 1 ][ ROOM_LOOK_FUNC ];
}
int query_size( string direc ) {
  int i;
  if ( ( i = member_array( direc, dest_other ) ) == -1 ) return 0;
  if ( stringp( dest_other[ i + 1 ][ ROOM_SIZE ] ) )
    return (int)call_other( this_object(), dest_other[ i + 1 ][ ROOM_SIZE ] );
  if ( pointerp( dest_other[ i + 1 ][ ROOM_SIZE ] ) )
    return (int)call_other( dest_other[ i + 1 ][ ROOM_SIZE ][ 0 ],
        dest_other[ i + 1 ][ ROOM_SIZE ][ 1 ] );
  return dest_other[ i + 1 ][ ROOM_SIZE ];
}
void event_magic( object channel, int amount, object caster ) {
   add_enchant( amount / 5 );
}
void event_theft( object command_ob, object thief, object victim,
                  object *stolen ) {
  log_file( "THEFT", "%s: %s stole %s from %s in %s\n",
            ctime( time() ), (string)thief->query_short(),
            implode( (string *)stolen->query_short(), ", " ),
            (string)victim->query_short(), file_name() );
  if ( stringp( theft_handler )) {
    if( theft_handler != "none" )
      theft_handler->handle_theft( this_object(), command_ob, thief,
                                   victim, stolen );
  } else
    "/obj/handlers/theft_handler"->handle_theft( this_object(), command_ob,
                                                 thief, victim, stolen );
}
void event_exit(object ob, string message, object to) {
    if(interactive(ob))
    last_visited = time();
}
int query_last_visited() { return last_visited; }
varargs int add_item( mixed shorts, mixed desc, int no_plural ) {
  if (!desc) {
     printf("Error!  In %O add_item(%O, 0), not added.\n", file_name(),
                                                           shorts);
     return 0;
  }
  if ( !item ) {
     item = clone_object( ITEM_OBJECT );
  }
  item->setup_item( shorts, desc, no_plural );
  return 1;
}
int remove_item( string word ) {
  if ( !item ) {
    return 1;
  }
  return (int)item->remove_item( word );
}
int modify_item( string word, mixed new_desc ) {
  if ( !item ) {
    return 0;
  }
  return (int)item->modify_item( word, new_desc );
}
void add_effect( string eff, mixed arg ) {
   effects = clone_object( "/std/shadows/misc/effects" );
   effects->setup_shadow( this_object() );
   effects->add_effect( eff, arg );
}
varargs int set_linker( string *rooms, string d_prep, string s_prep,
    string r_name ) {
  if ( linker ) {
    return 0;
  }
  linker = clone_object( LINKER_OBJECT );
  linker->setup_shadow( this_object(), rooms, d_prep, s_prep, r_name );
  return 1;
}
int set_terrain( string terrain_name ) {
   if ( terrain ) {
      return 0;
   }
   terrain = clone_object( TERRAIN_OBJECT );
   terrain->setup_shadow( this_object(), terrain_name );
   set_not_replaceable(1);
   return 1;
}
void set_wall( mixed *args ) {
   if ( !wall ) {
      wall = clone_object( WALL_OBJECT );
      wall->setup_shadow( this_object() );
   }
   wall->set_wall( args );
}
void set_default_position(mixed stuff) {
  add_property(DEFAULT_POSITION_PROPERTY, stuff);
}
mixed query_default_position() {
   return query_property(DEFAULT_POSITION_PROPERTY);
}
int is_allowed_position(string poss) {
  switch (poss) {
    case SITTING :
    case STANDING :
    case KNEELING :
    case LYING :
    case MEDITATING :
    case CROUCHING :
      return 1;
    default :
      return 0;
  }
}
void dest_me() {
   int in_armoury, in_void;
   object thing, *things;
   if ( file_name( this_object() ) == ARMOURY )
      in_armoury = 1;
   if ( file_name( this_object() ) == ROOM_VOID )
      in_void = 1;
   if ( !in_void ) {
      things = all_inventory( this_object() );
      foreach( thing in things ) {
         if ( userp( thing ) ) {
            thing->move_with_look( ROOM_VOID, "$N fall$s into the void." );
            continue;
         }
         if(thing->cleaning_room())
           continue;
         thing->move("/room/rubbish");
      }
   }
   if ( chatter )
      chatter->dest_me();
   if ( sitchanger )
      sitchanger->dest_me();
   if ( effects )
      effects->destruct_shadow( effects );
   if ( linker )
      linker->destruct_shadow( linker );
   if ( terrain )
      terrain->destruct_shadow( terrain );
   if(wall)
     wall->destruct_shadow(wall);
   if ( item )
      item->dest_me();
   if(door_control)
     foreach(thing in keys(door_control))
       if(objectp(thing))
         catch(thing->dest_me());
   if ( sizeof( hidden_objects ) )
      foreach( thing in hidden_objects ) {
         if ( objectp( thing ) && ( thing->multiple_hidden() == 0 ) )
           catch( thing->dest_me() );
      }
   destruct( this_object() );
}
void set_keep_room_loaded(int flag) {
   add_property(ROOM_KEEP_PROP, flag);
}
int query_keep_room_loaded() {
   return query_property(ROOM_KEEP_PROP);
}
int clean_up( int parent ) {
  if (parent) {
    return 0;
  }
  if (query_keep_room_loaded()) {
      return 0;
  }
  call_out("real_clean", 30 + random(120));
  return 1;
}
int real_clean() {
   object thing;
   foreach ( thing in all_inventory( this_object() ) ) {
     if ( thing->query_property( "player" ) ||
          (thing->query_property( "unique" ) &&
           last_visited > time() - 3600) ||
          thing->query_slave() ||
          thing->query_name() == "corpse") {
         return 0;
      }
   }
   dest_me();
   return 1;
}
object *find_inv_match( string words, object looker ) {
   object *things;
   things = all_inventory( this_object() );
   if ( pointerp( hidden_objects ) ) {
      things += hidden_objects;
   }
   if (looker && userp(looker)) {
      things = filter(things, (: $1 && $1->short(0) &&
                              (!$2 || $1->query_visible($2)) :), looker);
   }
   if ( item ) {
      things += ({ item });
   }
   return things;
}
varargs object add_sign( string sign_long, mixed sign_read_mess, string
    sign_short, mixed sign_name, string sign_language ) {
  object sign;
  string* bits;
  sign = clone_object( "/std/object" );
  if ( !sign_name ) {
     sign_name = "sign";
  }
  if (pointerp(sign_name)) {
    bits = explode(sign_name[0], " ");
    sign->set_name( bits[<1] );
    sign->add_adjective( bits[0..<2]);
    sign->add_alias(sign_name[1..]);
  } else {
    bits = explode(sign_name, " ");
    sign->set_name( bits[<1] );
    sign->add_adjective( bits[0..<2]);
  }
  sign->set_long( sign_long );
  if ( !sign_language ) sign_language = "common";
  sign->set_read_mess( sign_read_mess, sign_language );
  sign->reset_get();
  if ( sign_short && ( sign_short != "" ) ) {
    sign->set_short( sign_short );
    sign->set_main_plural( pluralize( sign_short ) );
    sign->move( this_object() );
    sign->add_property("there", "here");
  } else hidden_objects += ({ sign });
  return sign;
}
void tell_door( string direc, string message, object thing ) {
   if ( objectp( door_control[ direc ] ) )
      door_control[ direc ]->tell_door( message, thing );
}
varargs mixed call_door( string direc, string func, mixed arg1, mixed arg2,
      mixed arg3 ) {
   if ( objectp( door_control[ direc ] ) )
      return (mixed)call_other( door_control[ direc ], func, arg1, arg2,
            arg3 );
}
string query_door( mixed dest ) {
   int i;
   string direc;
   mixed bing;
   if ( objectp( dest ) ) {
      dest = file_name( dest );
   }
   if ( !stringp( dest ) ) {
      return 0;
   }
   if ( bing = door_control[ dest ] ) {
      if ( !objectp( bing ) ) {
         direc = bing;
      }
   }
   if ( !direc ) {
      return 0;
   }
   bing = door_control[ direc ];
   if ( objectp( bing ) ) {
      return direc;
   }
   bing = clone_object( DOOR_OBJECT );
   i = member_array( direc, dest_other );
   bing->setup_door( direc, this_object(), dest, dest_other[ i + 1 ] );
   hidden_objects += ({ bing });
   door_control[ direc ] = bing;
   return direc;
}
void stop_room_chats() {
   if ( chatter ) {
      chatter->dest_me();
   }
}
void set_chat_min_max( int min,int  max ) {
  if (chatter) chatter->set_chat_min_max(min,max);
}
void add_room_chats( string *new_chats ) {
  if (chatter) chatter->add_room_chats( new_chats );
}
void remove_room_chats( string *dead_chats ) {
 if (chatter) chatter->remove_room_chats( dead_chats );
}
mixed *query_room_chats() {
  if (chatter) return chatter->query_room_chats();
  return 0;
}
varargs void room_chat( mixed *args, object chatobj ) {
   if ( !pointerp( args[ 2 ] ) ) {
      write( "Error: second argument of room_chat args is not an array.\n" );
      return;
   }
  if ( chatter ) {
    chatter->setup_chatter( this_object(), args );
    return;
  }
  if (objectp(chatobj)) chatter = chatobj;
  else chatter = clone_object( CHATTER_OBJECT );
  chatter->setup_chatter( this_object(), args );
}
varargs object set_situation_changer( mixed changer ) {
  if (stringp(changer)) {
    sitchanger = clone_object( changer );
  } else if (objectp(changer)) {
    sitchanger = changer;
  } else {
    sitchanger = clone_object( SITUATION_CHANGER_OBJECT );
  }
  return (sitchanger = sitchanger->set_room( this_object() ));
}
void add_situation( mixed label, class situation sit ) {
  if (!sitchanger) {
    sitchanger = clone_object( SITUATION_CHANGER_OBJECT );
    sitchanger->set_room( this_object() );
  }
  sitchanger->add_situation( label, sit );
}
void make_situation_seed(int xval, int yval) {
  if (sitchanger) sitchanger->set_seed(xval,yval);
}
void start_situation(int label, int do_start_mess) {
  if (sitchanger)
    sitchanger->start_situation( label, do_start_mess );
}
void end_situation(mixed label) {
  if (sitchanger) sitchanger->end_situation( label );
}
varargs mixed change_situation( mixed label, mixed duration, mixed words ) {
  if (sitchanger)
    return sitchanger->change_situation(label,duration,words,0);
  return 0;
}
varargs void automate_situation( mixed label, mixed duration, mixed when,
    mixed chance, mixed category ) {
  if (sitchanger)
    sitchanger->automate_situation(label,duration,when,chance,category);
}
void shutdown_all_situations() {
  if (sitchanger) sitchanger->shutdown_all_situations();
}
void shutdown_situation(int call, mixed label) {
  if (sitchanger) sitchanger->shutdown_situation(call,label);
}
int query_not_replaceable() {
   return query_property(ROOM_NOT_REPLACE_PROGRAM_PROP);
}
void set_not_replaceable(int replace) {
   add_property(ROOM_NOT_REPLACE_PROGRAM_PROP, replace);
}
mixed stats() {
   int i;
   mixed *stuff;
   stuff = ({ });
   for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 )
      stuff += ({
         ({ dest_other[ i ], dest_other[ i + 1 ][ ROOM_DEST ] })
      });
   if ( co_ord )
      stuff += ({
         ({ "co-ord x", co_ord[ 0 ] }),
         ({ "co-ord y", co_ord[ 1 ] }),
         ({ "co-ord z", co_ord[ 2 ] })
      });
   return light::stats() + property::stats() + stuff + ({
      ({ "short", short( 0 ) }),
      ({ "enchantment", query_enchant() }),
      ({ "background enchantment", background_enchant }),
      ({ "dynamic enchantment", dynamic_enchant }),
      ({ "enchantment time", enchant_time }),
      ({ "theft handler", theft_handler }),
   });
}
void set_day_long( string str ) {
  if(!variablelongs)
    variablelongs = allocate(2);
  variablelongs[DAY] = str;
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == DAY)
    set_long(str);
}
void set_night_long( string str ) {
  if(!variablelongs)
    variablelongs = allocate(2);
  variablelongs[NIGHT] = str;
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == NIGHT)
    set_long(str);
}
string query_night_long() {
   if(variablelongs && strlen(variablelongs[NIGHT]))
     return variablelongs[NIGHT];
   return this_object()->query_long();
}
private string return_long(mixed desc) {
  int ma;
  if(!pointerp(desc))
    return (string)desc;
  ma = member_array("long", desc);
  if(ma < 0)
    return "Error: No long found.";
  return (string)desc[ma+1];
}
varargs int add_day_item(mixed shorts, mixed desc, mixed no_plural) {
  string the_item;
  if(pointerp(shorts))
    the_item = shorts[0];
  else
    the_item = shorts;
  if(!variableitems)
    variableitems = ({ ({ }), ({ }) });
  variableitems[DAY] += ({ the_item, return_long(desc) });
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == DAY)
    return add_item(shorts, desc, no_plural);
  return 1;
}
varargs int add_night_item(mixed shorts, mixed desc, mixed no_plural) {
  string the_item;
  if(pointerp(shorts))
    the_item = shorts[0];
  else
    the_item = shorts;
  if(!variableitems)
    variableitems = ({ ({ }), ({ }) });
  variableitems[NIGHT] += ({ the_item, return_long( desc ) });
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == NIGHT)
    return add_item(shorts, desc, no_plural);
  return 1;
}
void room_day_chat(mixed *args) {
  if(!variablechats)
    variablechats = allocate(2);
  variablechats[DAY] = args;
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == DAY)
    room_chat(args);
}
void room_night_chat( mixed *args ) {
  if(!variablechats)
    variablechats = allocate(2);
  variablechats[NIGHT] = args;
  if(is_day == -1)
    is_day = (WEATHER_HANDLER->query_day() > 0);
  if(is_day == NIGHT)
    room_chat(args);
}
string query_help_file_directory() {
  return ROOM_HELP_FILE_DIR;
}

==================================================
FILE: room/bath_house_inside.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/room/inherit/bath_house";
void create() {
    basic_room::create();
    bath_house::create();
}
void init() {
    basic_room::init();
    bath_house::init();
}

==================================================
FILE: room/bath_house_outside.c
==================================================

inherit "/std/room/outside";
inherit "/std/room/inherit/bath_house";
void create() {
    bath_house::create();
    outside::create();
}
void init() {
    outside::init();
    bath_house::init();
}

==================================================
FILE: room/club_control_room.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/room/inherit/club_control_room";
void create() {
    do_setup++;
    basic_room::create();
    club_control_room::create();
    do_setup--;
    if ( !do_setup ) {
        this_object()->setup();
        this_object()->reset();
    }
}
void init() {
    basic_room::init();
    club_control_room::init();
}

==================================================
FILE: room/complaints_room.c
==================================================

inherit "/std/room/inherit/complaints_room";
inherit "/std/room/basic_room";
void create() {
    add_help_file("complaints_room");
    do_setup++;
    basic_room::create();
    do_setup--;
    set_not_replaceable( 1 );
    if ( !do_setup ) {
        this_object()->setup();
        this_object()->reset();
    }
}
void init() {
    complaints_room::init();
    basic_room::init();
}

==================================================
FILE: room/council_archive.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/room/inherit/council_base";
#define NOMIC_SYSTEM_CASE_CLASSES
#include <nomic_system.h>
#include <player_handler.h>
#include <mail.h>
void create() {
   ::create();
   add_help_file("council_archive");
}
string query_case_short(class nomic_case the_case) {
   string ret;
   ret = "Case #" + the_case->id + " \"" +
         the_case->short + "\" opened by " + the_case->opener +
         " against " + query_multiple_short(the_case->people) + " at " +
         ctime(the_case->time_opened);
   return ret;
}
int do_list_all_cases() {
   int* cases;
   string ret;
   int id;
   cases = NOMIC_HANDLER->query_closed_cases(query_council_area());
   if (!sizeof(cases)) {
      add_failed_mess("There are no open cases.\n");
      return 0;
   }
   ret = "Currently closed cases:\n";
   foreach (id in cases) {
      ret += "$I$5=$C$Case #" + id;
      ret += "\n";
   }
   this_player()->more_string(ret, "closed cases");
   return 1;
}
int do_list_case(int case_id) {
   string ret;
   class nomic_case the_case;
   class nomic_case_note note;
   class nomic_case_event event;
   int id;
   ret = "";
   the_case = NOMIC_HANDLER->query_closed_case(query_council_area(), case_id);
   if (!the_case) {
      add_failed_mess("Unable to find the case.\n");
      return 0;
   }
   ret += "$I$3=" + query_case_short(the_case);
   if (sizeof(the_case->events)) {
      ret += "\n";
      ret += "$I$0=%^YELLOW%^Events%^RESET%^:\n";
      foreach (event in the_case->events) {
         ret += "$I$6=   " +
                capitalize(NOMIC_HANDLER->query_event_name(event->type)) +
                " " +
                "by " + event->person + " at " + ctime(event->event_time) +
                " " +
                event->mess + "\n";
      }
   }
   if (sizeof(the_case->notes)) {
      ret += "\n";
      ret += "$I$0=%^YELLOW%^Notes%^RESET%^:\n";
      foreach (id in the_case->notes) {
         note = NOMIC_HANDLER->query_note(id);
         ret += "$I$6=   Note by " + note->person + " at " +
                ctime(note->time_created) +
                ".\n" + note->text + "\n\n";
      }
   }
   this_player()->more_string(ret, "closed case");
   return 1;
}
int do_list_citizens() {
    object* cits;
    string ret;
    string area;
    area = this_object()->query_council_area();
    cits = filter( users(), (: NOMIC_HANDLER->is_citizen_of(
       this_object()->query_council_area(), $1->query_name() ) &&
       $1->query_visible( this_player() ) :) );
    cits = sort_array(cits, (: strcmp($1->query_name(), $2->query_name()) :));
    ret = "The online citizens (and magistrates) of " + area + " are:\n\n";
    ret += query_multiple_short(cits);
    write("$P$Citizens Online$P$" + ret);
    return 1;
}
void init() {
   add_command("list", "", (: do_list_all_cases() :));
   add_command("list", "[case] <number>", (: do_list_case($4[0]) :));
   add_command("list", "citizens", (: do_list_citizens() :));
}

==================================================
FILE: room/council_cases.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/room/inherit/council_base";
#define NOMIC_SYSTEM_CASE_CLASSES
#include <nomic_system.h>
#include <player_handler.h>
#include <mail.h>
void add_punishment_type(string name, string file);
string query_punishment_type(string name);
private mapping _types;
void create() {
   _types = ([ ]);
   ::create();
   if (!query_punishment_type("not guilty")) {
      add_punishment_type("not guilty", NOMIC_PUNISHMENT_DIR + "not_guilty");
   }
   if (!query_punishment_type("dismissed")) {
      add_punishment_type("dismissed", NOMIC_PUNISHMENT_DIR + "dismissed");
   }
   if (!query_punishment_type("lose citizenship")) {
      add_punishment_type("lose citizenship",
                          NOMIC_PUNISHMENT_DIR + "lose_citizenship");
   }
   add_help_file("cases");
}
void add_punishment_type(string name, string file) {
   _types[name] = file;
}
string query_punishment_type(string name) {
   return _types[name];
}
void start_punishment(string name, class nomic_case the_case, function finish) {
   string bing;
   bing = query_punishment_type(name);
   if (bing) {
      call_other(bing, "start_punishment", query_council_area(),
                 the_case, name, finish);
   } else {
      write("Big hairy error.\n");
   }
}
void complete_punishment(string name, class nomic_case the_case, mixed data) {
   string bing;
   bing = query_punishment_type(name);
   if (bing) {
      call_other(bing, "complete_punishment", query_council_area(),
                 the_case, name, data);
   } else {
      write("Big hairy error.\n");
   }
}
void suspend_punishment(class nomic_case the_case) {
   string bing;
   class nomic_case_event event;
   string type;
   mixed data;
   foreach (event in the_case->events) {
      if (event->type == NOMIC_CASE_EVENT_CLOSE) {
         type = event->data[0];
         data = event->data[1];
      }
   }
   bing = query_punishment_type(type);
   if (bing) {
      call_other(bing, "suspend_punishment", query_council_area(),
                 the_case, type, data);
   } else {
      write("Big hairy error.\n");
   }
}
string query_punishment_short(string name, class nomic_case the_case,
                              mixed data) {
   string bing;
   bing = query_punishment_type(name);
   if (bing) {
      return call_other(bing, "query_short", query_council_area(), the_case, name, data);
   } else {
      return "Big hairy error.\n";
   }
}
string query_punishment_mail_info(string name, class nomic_case the_case,
                              mixed data) {
   string bing;
   bing = query_punishment_type(name);
   if (bing) {
      return call_other(bing, "query_mail_information", query_council_area(), the_case,
                        name, data);
   } else {
      return "Big hairy error.\n";
   }
}
string* query_all_punishment_types() {
   return keys(_types);
}
string query_extra_player_status(string player) {
   return 0;
}
string query_last_appealer(class nomic_case the_case) {
   class nomic_case_event event;
   string ret;
   ret = 0;
   foreach (event in the_case->events) {
      if (event->type == NOMIC_CASE_EVENT_APPEAL) {
         ret = event->person;
      }
   }
   return ret;
}
int is_last_appealer(class nomic_case the_case, string person) {
   return query_last_appealer(the_case) == person;
}
string query_last_closer(class nomic_case the_case) {
   class nomic_case_event event;
   string ret;
   ret = 0;
   foreach (event in the_case->events) {
      if (event->type == NOMIC_CASE_EVENT_CLOSE) {
         ret = event->person;
      }
   }
   return ret;
}
int is_last_closer(class nomic_case the_case, string person) {
   return query_last_closer(the_case) == person;
}
int do_list_punishments() {
   string punish;
   string file;
   write("Punishments:\n");
   foreach (punish, file in _types) {
      write("   " + punish + "\n");
   }
   return 1;
}
int do_list_punishments_desc(string type) {
   string file;
   write("Punishments:\n");
   file = _types[type];
   if (!file) {
      add_failed_mess("No punishment of type " + type + ".\n");
      return 0;
   }
   this_player()->more_string(file->query_description(), "punishment");
   return 1;
}
int do_open_case(string people, string short) {
   string* bits;
   string* bad;
   string person;
   people = replace_string(people, " and ", ",");
   people = replace_string(people, " ", "");
   bits = explode(lower_case(people), ",");
   bad = ({ });
   foreach (person in bits) {
      if (!PLAYER_HANDLER->test_user(person)) {
         bad += ({ person });
      }
   }
   if (member_array(this_player()->query_name(), bits) != -1) {
      bits = bits - ({ this_player()->query_name() });
   }
   if (sizeof(bad) == 1) {
      add_failed_mess("The player " + query_multiple_short(bad) +
                      " does not exist.\n", bad);
      return 0;
   } else if (sizeof(bad)) {
      add_failed_mess("The players " + query_multiple_short(bad) +
                      " do not exist.\n", bad);
      return 0;
   }
   if (!sizeof(bits)) {
      add_failed_mess("There have to be some people involved in the case.\n");
      return 0;
   }
   write("For the case with the people " + query_multiple_short(bits) +
         " and a short of " + short + ", please type in an intial "
         "description of the case.\n");
   this_player()->do_edit("", "open_case_desc", this_object(), 0,
                          ({ bits, short }));
   return 1;
}
void open_case_desc(string desc, mixed* extra) {
   string* bits;
   string short;
   bits = extra[0];
   short = extra[1];
   if (!desc) {
      write("Aborted.\n");
      return ;
   }
   write("Adding in a case with " + query_multiple_short(bits) +
         " people and a short description of " + short + ".\nYour note is:\n");
   write(desc);
   write("\nAre you sure you wish to add this? ");
   input_to("open_case_desc_confirm", 0, bits, short, desc);
}
void open_case_desc_confirm(string response, string* bits,
                            string short, string desc) {
   int id;
   string* magistrates;
   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborting the addition of the case.\n");
      return ;
   }
   id = NOMIC_HANDLER->add_new_case(query_council_area(),
                                    this_player()->query_name(), short,
                                    bits);
   if (id) {
      NOMIC_HANDLER->add_note_to_case(query_council_area(),
                                      id, this_player()->query_name(),
                                      desc);
      write("Added the case into the system.\n");
      magistrates = NOMIC_HANDLER->query_magistrates(query_council_area());
      MAILER->do_mail_message(implode(magistrates + bits, ","),
                           query_council_area() + " magistrates",
                           "New case against " + implode(bits, ","),
                           "",
                           "A new case is opened against " +
                           implode(bits, ",") +
                           " by " + this_player()->query_cap_name() +
                           "\nwith a reason of:\n" +
                           desc);
      tell_room(this_object(),
           this_player()->the_short() + " opens a case against " +
           query_multiple_short(bits) + ".\n", ({ this_player() }) );
   } else {
      write("Unable to add the case for some reason.\n");
   }
}
string query_case_short(class nomic_case the_case) {
   string ret;
   ret = "Case #" + the_case->id + " \"" +
         the_case->short + "\" opened by " + the_case->opener +
         " against " + query_multiple_short(the_case->people) + " at " +
         ctime(the_case->time_opened);
   return ret;
}
int do_list_open_cases() {
   int* cases;
   string ret;
   class nomic_case the_case;
   int id;
   cases = NOMIC_HANDLER->query_open_cases(query_council_area());
   if (!sizeof(cases)) {
      add_failed_mess("There are no open cases.\n");
      return 0;
   }
   ret = "Currently open cases:\n";
   foreach (id in cases) {
      the_case = NOMIC_HANDLER->query_open_case(query_council_area(), id);
      ret += "$I$5=$C$" + query_case_short(the_case);
      ret += "\n";
   }
   this_player()->more_string(ret, "open cases");
   return 1;
}
int do_list_closed_cases() {
   int* cases;
   string ret;
   class nomic_case the_case;
   int id;
   cases = NOMIC_HANDLER->query_recently_closed_cases(query_council_area());
   if (!sizeof(cases)) {
      add_failed_mess("There are no recently closed cases.\n");
      return 0;
   }
   ret = "Recently closed cases:\n";
   foreach (id in cases) {
      the_case = NOMIC_HANDLER->query_recently_closed_case(query_council_area(), id);
      ret += "$I$5=$C$" + query_case_short(the_case);
      ret += "\n";
   }
   this_player()->more_string(ret, "closed cases");
   return 1;
}
int do_list_case(int case_id) {
   string ret;
   class nomic_case the_case;
   class nomic_case_note note;
   class nomic_case_event event;
   int id;
   ret = "";
   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   if (!the_case) {
      add_failed_mess("Unable to find the case.\n");
      return 0;
   }
   ret += "$I$3=" + query_case_short(the_case);
   if (sizeof(the_case->events)) {
      ret += "\n";
      ret += "$I$0=%^YELLOW%^Events%^RESET%^:\n";
      foreach (event in the_case->events) {
         ret += "$I$6=   " +
                capitalize(NOMIC_HANDLER->query_event_name(event->type)) +
                " " +
                "by " + event->person + " at " + ctime(event->event_time) +
                " " +
                event->mess + "\n";
      }
   }
   if (sizeof(the_case->notes)) {
      ret += "\n";
      ret += "$I$0=%^YELLOW%^Notes%^RESET%^:\n";
      foreach (id in the_case->notes) {
         note = NOMIC_HANDLER->query_note(id);
         ret += "$I$6=   Note by " + note->person + " at " +
                ctime(note->time_created) +
                ".\n" + note->text + "\n\n";
      }
   }
   this_player()->more_string(ret, "open cases");
   return 1;
}
int do_list_closed_case(int case_id) {
   string ret;
   class nomic_case the_case;
   class nomic_case_note note;
   class nomic_case_event event;
   int id;
   int* cases;
   ret = "";
   cases = NOMIC_HANDLER->query_recently_closed_cases(query_council_area());
   if (member_array(case_id, cases) == -1) {
      add_failed_mess("Unable to find the case.\n");
      return 0;
   }
   the_case = NOMIC_HANDLER->query_recently_closed_case(query_council_area(),
                                                        case_id);
   if (!the_case) {
      add_failed_mess("Unable to find the case.\n");
      return 0;
   }
   ret += "$I$3=" + query_case_short(the_case);
   if (sizeof(the_case->events)) {
      ret += "\n";
      ret += "$I$0=%^YELLOW%^Events%^RESET%^:\n";
      foreach (event in the_case->events) {
         ret += "$I$6=   " +
                capitalize(NOMIC_HANDLER->query_event_name(event->type)) +
                " " +
                "by " + event->person + " at " + ctime(event->event_time) +
                " " + event->mess + ".\n";
      }
   }
   if (sizeof(the_case->notes)) {
      ret += "\n";
      ret += "$I$0=%^YELLOW%^Notes%^RESET%^:\n";
      foreach (id in the_case->notes) {
         note = NOMIC_HANDLER->query_note(id);
         ret += "$I$6=   Note by " + note->person + " at " +
                ctime(note->time_created) +
                ".\n" + note->text + "\n\n";
      }
   }
   this_player()->more_string(ret, "open cases");
   return 1;
}
int do_add_person(int case_id, string person) {
   class nomic_case the_case;
   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   if (!the_case) {
      add_failed_mess("Unable to find the id of the case.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("You must be a magistrate to add a person from "
                      "the case.\n");
      return 0;
   }
   if (member_array(this_player()->query_name(), the_case->people) != -1 ||
       this_player()->query_name() == the_case->opener) {
      add_failed_mess("You cannot add a person to a case involving you or "
                      "started by you.\n");
      return 0;
   }
   write("What reason to wish to give for adding this person?\n");
   this_player()->do_edit("", "person_desc", this_object(), 0,
                          ({ case_id, person, "add" }));
   return 1;
}
void person_desc(string desc, mixed* stuff) {
   int case_id;
   string person;
   string type;
   class nomic_case the_case;
   case_id = stuff[0];
   person = stuff[1];
   type = stuff[2];
   if (!desc) {
      write("Aborted " + type + "ing " + person + ".\n");
      return ;
   }
   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   write("Are you sure you wish to " + type + " " + person + " to the "
        "case " + query_case_short(the_case) + ".\n");
   input_to("person_confirm", 0, case_id, person, type, desc);
}
void person_confirm(
   string response,
   int case_id,
   string person,
   string type,
   string desc
) {
   string* people;
   class nomic_case the_case;
   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborted " + type + "ing " + person + ".\n");
      return ;
   }
   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   people = the_case->people;
   if (type == "add") {
      if (NOMIC_HANDLER->add_person_to_case(query_council_area(), case_id,
                                            this_player()->query_name(),
                                            person, "\n" + desc)) {
         write("Sucessfully added " + person + " to the case.\n");
         people += ({ person });
      } else {
         write("Unable to add " + person + " to the case.\n");
         return ;
      }
   } else {
      if (NOMIC_HANDLER->remove_person_from_case(query_council_area(), case_id,
                                            this_player()->query_name(),
                                            person, "\n" + desc)) {
         write("Sucessfully removed " + person + " from the case.\n");
      } else {
         write("Unable to remove " + person + " from the case.\n");
         return ;
      }
   }
   MAILER->do_mail_message(implode(people, ","),
                           query_council_area() + " magistrates",
                           capitalize(type) + " person",
                           "",
                           "From the desk of " +
                           this_player()->query_cap_name() + ":\n"
                           "The " + type + "ing the person " + person +
                           " to the case " +
                           query_case_short(the_case) +
                           "\nwith a reason of:\n" +
                           desc);
   tell_room(this_object(),
           this_player()->the_short() + " " + type + "s " + person +
           " to case #" + the_case->id + ".\n", ({ this_player() }) );
}
int do_remove_person(int case_id, string person) {
   class nomic_case the_case;
   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   if (!the_case) {
      add_failed_mess("Unable to find the id of the case.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("You must be a magistrate to remove a person "
                      "from the case.\n");
      return 0;
   }
   if (member_array(this_player()->query_name(), the_case->people) != -1 ||
       this_player()->query_name() == the_case->opener) {
      add_failed_mess("You cannot remove a person to a case involving you or "
                      "started by you.\n");
      return 0;
   }
   if (sizeof(the_case->people) == 1) {
      add_failed_mess("You cannot remove everyone from the case.\n");
      return 0;
   }
   write("What reason to wish to give for removeing this person?\n");
   this_player()->do_edit("", "person_desc", this_object(), 0,
                          ({ case_id, person, "remove" }));
   return 1;
}
int do_add_note(int case_id) {
   class nomic_case the_case;
   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   if (!the_case) {
      add_failed_mess("Unable to find the id of the case.\n");
      return 0;
   }
   write(query_case_short(the_case));
   write("\nAdd note:\n");
   this_player()->do_edit("", "note_case_desc", this_object(), 0,
                          the_case);
   return 1;
}
void note_case_desc(string desc, class nomic_case the_case) {
   if (!desc) {
      write("Aborted.\n");
   }
   write("Do you wish to add the note to the case " +
         query_case_short(the_case) + ".\n");
   write(desc + "\nAre you sure you wish to add this note? ");
   input_to("note_case_desc_confirm", 0, desc, the_case);
}
void note_case_desc_confirm(string response, string desc,
                            class nomic_case the_case) {
   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborting the addition of the note.\n");
      return ;
   }
   if (NOMIC_HANDLER->add_note_to_case(query_council_area(), the_case->id,
                                       this_player()->query_name(), desc)) {
      write("Added the note to the case.\n");
      tell_room(this_object(),
           this_player()->the_short() + " adds a note "
           " to case #" + the_case->id + ".\n", ({ this_player() }) );
   } else {
      write("Unable to add the note to the case for some reason.\n");
   }
}
void close_case_bit(class nomic_case the_case, string type, mixed data) {
   write("Please add in your closing summary.\n");
   this_player()->do_edit("", "close_case_desc", this_object(), 0,
                          ({ the_case, type, data }));
}
int do_close_case(int case_id, string type) {
   class nomic_case the_case;
   the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
   if (!the_case) {
      add_failed_mess("Cannot find the case.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("You must be a magistrate to close the case.\n");
      return 0;
   }
   if (!query_punishment_type(type)) {
      add_failed_mess("This is not an allowed type for closing the case, "+
                      "it must be one of " +
                      query_multiple_short(query_all_punishment_types()) + ".\n");
      return 0;
   }
   if (member_array(this_player()->query_name(), the_case->people) != -1 ||
       this_player()->query_name() == the_case->opener) {
      add_failed_mess("You cannot close a case involving you or started "
                      "by you.\n");
      return 0;
   }
   if (is_last_appealer(the_case, this_player()->query_name())) {
      add_failed_mess("You cannot close a case you appealed.\n");
      return 0;
   }
   start_punishment(type, the_case, (: close_case_bit :));
   return 1;
}
void close_case_desc(string desc, mixed* extra) {
   class nomic_case the_case;
   string type;
   mixed data;
   if (!desc) {
      write("Aborted.\n");
      return ;
   }
   the_case = extra[0];
   type = extra[1];
   data = extra[2];
   write("Closing the case " +
         query_case_short(the_case) +  " with the type of " +
         query_punishment_short(type, the_case, data) + ".\n");
   write("Are sure you wish you wish to close this case? ");
   input_to("close_case_desc_confirm", 0, the_case, type, data, desc);
}
void close_case_desc_confirm(string response, class nomic_case the_case,
                             string type, mixed* data, string desc) {
   string* people;
   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborting the closing of the note.\n");
      return ;
   }
   if (NOMIC_HANDLER->close_case(query_council_area(), the_case->id,
                                this_player()->query_name(),
                                query_punishment_short(type, the_case, data) +
                                "\n" + desc, ({ type, data }))) {
      complete_punishment(type, the_case, data);
      write("Completed closing the case.\n");
      people = the_case->people + ({ the_case->opener }) +
               NOMIC_HANDLER->query_magistrates(query_council_area());
      if (query_last_appealer(the_case)) {
         people += ({ query_last_appealer(the_case) });
      }
      MAILER->do_mail_message(implode(people, ","),
                              query_council_area() + " magistrates",
                              "Case closed against " +
                              implode(the_case->people, ","),
                              "",
                              "From the desk of " +
                              this_player()->query_cap_name() + ":\n"
                              "The case " +
                              query_case_short(the_case) +
                              "\nhas been closed with a verdict of " +
                              query_punishment_short(type, the_case, data) +
                              "\nWith a reason of:\n" +
                              desc +
                              query_punishment_mail_info(type, the_case, data));
      tell_room(this_object(),
           this_player()->the_short() + " closes the case #" +
           the_case->id + " against " + query_multiple_short(the_case->people) +
           " with a result of " +
           query_punishment_short(type, the_case, data) +
           ".\n", ({ this_player() }) );
   } else {
      write("Unable to complete closing the case.\n");
   }
}
int do_appeal_case(int case_id) {
   class nomic_case the_case;
   the_case = NOMIC_HANDLER->query_recently_closed_case(query_council_area(),
                                                        case_id);
   if (!the_case) {
      add_failed_mess("Cannot find the case.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("You must be a magistrate to appeal the case.\n");
      return 0;
   }
   if (member_array(this_player()->query_name(), the_case->people) != -1 ||
       this_player()->query_name() == the_case->opener) {
      add_failed_mess("You cannot appeal a case involving you or started "
                      "by you.\n");
      return 0;
   }
   if (is_last_closer(the_case, this_player()->query_name())) {
      add_failed_mess("You cannot appeal a case you closed.\n");
      return 0;
   }
   write("What is the detailed reason for appealing this case?\n");
   this_player()->do_edit("", "appeal_case_desc", this_object(), 0, case_id);
   return 1;
}
void appeal_case_desc(string desc, int case_id) {
   class nomic_case the_case;
   if (!desc) {
      write("Aborted.\n");
      return ;
   }
   the_case = NOMIC_HANDLER->query_recently_closed_case(query_council_area(),
                                                        case_id);
   write("Appealing the case " +
         query_case_short(the_case) +  " because:\n" + desc + "\nAre you sure "
         "you wish to do this? ");
   input_to("appeal_case_desc_confirm", 0, case_id, desc);
}
void appeal_case_desc_confirm(string response, int case_id, string desc) {
   class nomic_case the_case;
   string* people;
   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborting the closing of the note.\n");
      return ;
   }
   the_case = NOMIC_HANDLER->query_recently_closed_case(query_council_area(),
                                                        case_id);
   if (NOMIC_HANDLER->appeal_case(query_council_area(), case_id,
                                  this_player()->query_name(),
                                  "\n" + desc)) {
      write("Appealed the case successfully.\n");
      the_case = NOMIC_HANDLER->query_open_case(query_council_area(), case_id);
      suspend_punishment(the_case);
      people = the_case->people + ({ the_case->opener });
      MAILER->do_mail_message(implode(people, ","),
                              query_council_area() + " magistrates",
                              "Case appealed",
                              "",
                              "The case " +
                              query_case_short(the_case) +
                              "\nhas been appealed by " +
                              this_player()->query_cap_name() + " because:\n" +
                              desc);
      tell_room(this_object(),
           this_player()->the_short() + " appeals the case #" +
           the_case->id + " against " + query_multiple_short(the_case->people) +
           ".\n", ({ this_player() }) );
   } else {
      write("Error trying to appeal the case!\n");
   }
}
int do_player_status(string person) {
   int* cases;
   class nomic_case the_case;
   int id;
   int found;
   int *open_defendant;
   int *open_opener;
   int *open_appealed;
   int *closed_defendant;
   int *closed_opener;
   int *closed_closed;
   string ret;
   string bing;
   person = lower_case(person);
   cases = NOMIC_HANDLER->query_open_cases(query_council_area());
   if (!sizeof(cases)) {
      add_failed_mess("There are no open cases.\n");
      return 0;
   }
   open_defendant = ({ });
   open_opener = ({ });
   foreach (id in cases) {
      the_case = NOMIC_HANDLER->query_open_case(query_council_area(), id);
      if (member_array(person, the_case->people) != -1) {
         found = 1;
         open_defendant += ({ id + "" });
      }
      if (the_case->opener == person) {
         found = 1;
         open_opener += ({ id + "" });
      }
      bing = query_last_appealer(the_case);
      if (bing == person) {
         found = 1;
         open_appealed += ({ id + "" });
      }
   }
   cases = NOMIC_HANDLER->query_recently_closed_cases(query_council_area());
   closed_defendant = ({ });
   closed_opener = ({ });
   foreach (id in cases) {
      the_case = NOMIC_HANDLER->query_recently_closed_case(query_council_area(), id);
      if (member_array(person, the_case->people) != -1) {
         found = 1;
         closed_defendant += ({ id + " (closed)"  });
      }
      if (the_case->opener == person) {
         found = 1;
         closed_opener += ({ id + " (closed)" });
      }
      bing = query_last_closer(the_case);
      if (bing == person) {
         found = 1;
         closed_closed += ({ id + "" });
      }
   }
   ret = "Status for " + capitalize(person) + ":\n";
   if (sizeof(open_opener) || sizeof(closed_opener)) {
      ret += "Opened the cases      : " +
             query_multiple_short(open_opener + closed_opener) + "\n";
   }
   if (sizeof(open_defendant) || sizeof(closed_defendant)) {
      ret += "Defendant in the cases: " +
             query_multiple_short(open_defendant + closed_defendant) + "\n";
   }
   bing = query_extra_player_status(person);
   if (bing) {
      ret += bing;
   } else if (!found) {
      add_failed_mess("The player " + person + " has no record.\n");
      return 0;
   }
   write("$P$Status$P$" + ret);
   return 1;
}
void init() {
   add_command("list", "", (: do_list_open_cases() :));
   add_command("list", "[case] <number>", (: do_list_case($4[0]) :));
   add_command("list", "closed", (: do_list_closed_cases() :));
   add_command("list", "{punishments|results}", (: do_list_punishments :));
   add_command("list", "{punishment|punishments|results} <string'type'>", (: do_list_punishments_desc($4[1]) :));
   add_command("list", "closed [case] <number>", (: do_list_closed_case($4[0]) :));
   add_command("case", "add person <string'person'> to <number'case id'>",
               (: do_add_person($4[1], $4[0]) :));
   add_command("case", "remove person <string'person'> from <number'case id'>",
               (: do_remove_person($4[1], $4[0]) :));
   add_command("case", "[add] note <number'case id'>", (: do_add_note($4[0]) :));
   add_command("case", "open [with] <string'people'> about <string'short descripion'>",
                       (: do_open_case($4[0], $4[1]) :));
   add_command("case", "close <number'case id'> result <string'result'>",
                       (: do_close_case($4[0], $4[1]) :));
   add_command("case", "appeal <number'case id'>",
                       (: do_appeal_case($4[0]) :));
   add_command("status", "[of] <string'player'>",
                       (: do_player_status($4[0]) :));
}

==================================================
FILE: room/council_chambers.c
==================================================

#include <nomic_system.h>
inherit "/std/room/basic_room";
inherit "/std/room/inherit/council_base";
void create() {
   ::create();
}
int do_list_rules() {
   class nomic_rule* rules;
   class nomic_rule rule;
   string ret;
   int cur_type;
   rules = NOMIC_HANDLER->query_all_nomic_rules(query_council_area());
   if (!sizeof(rules)) {
      add_failed_mess("There are no rules, oh no!  Lawlessness!\n");
      return 0;
   }
   rules = sort_array(rules, (: $1->id - $2->id :) );
   ret = "";
   cur_type = -1;
   foreach (rule in rules) {
      if (rule->type != cur_type) {
         switch (rule->type) {
         case NOMIC_TYPE_IMMUTABLE :
            ret += "%^BOLD%^Immutable Rules%^RESET%^\n";
            break;
         case NOMIC_TYPE_CITIZEN :
            ret += "%^BOLD%^Citizen Rules%^RESET%^\n";
            break;
         case NOMIC_TYPE_GENERAL :
            ret += "%^BOLD%^General Rules%^RESET%^\n";
            break;
         }
         cur_type = rule->type;
      }
      ret += NOMIC_HANDLER->rule_as_string(0, rule);
      ret += "\n";
   }
   write("$P$Nomic rules$P$" + ret);
   return 1;
}
int do_list_one_rule(int num) {
   class nomic_rule rule;
   string ret;
   rule = NOMIC_HANDLER->query_nomic_rule(query_council_area(), num);
   if (!rule) {
      add_failed_mess("There is no rule number " + num + ".\n");
      return 0;
   }
   ret = "";
   switch (rule->type) {
   case NOMIC_TYPE_IMMUTABLE :
      ret += "%^BOLD%^Immutable Rules%^RESET%^\n";
      break;
   case NOMIC_TYPE_CITIZEN :
      ret += "%^BOLD%^Citizen Rules%^RESET%^\n";
      break;
   case NOMIC_TYPE_GENERAL :
      ret += "%^BOLD%^General Rules%^RESET%^\n";
      break;
   }
   ret += NOMIC_HANDLER->rule_as_string(0, rule);
   ret += "\n";
   write("$P$Nomic rules$P$" + ret);
   return 1;
}
int do_list_single_motion(int num) {
   class nomic_motion* rules;
   class nomic_motion rule;
   int is_mag;
   string ret;
   rules = NOMIC_HANDLER->query_all_motions(query_council_area());
   is_mag = NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name());
   if (!is_mag) {
      rules = filter(rules, (: $1->state == NOMIC_STATE_CITIZEN_VOTE :));
   }
   if (!sizeof(rules)) {
      add_failed_mess("No motion to look at or vote on.\n");
      return 0;
   }
   ret = "";
   foreach (rule in rules) {
      if (rule->identifier == num) {
         ret += NOMIC_HANDLER->motion_as_string(0, query_council_area(), rule,
                                             0);
         ret += "\n";
      }
   }
   if (ret == "") {
      add_failed_mess("The motion " + num + " was not found.\n");
      return 0;
   }
   write("$P$New Nomic Rules$P$" + ret);
   return 1;
}
int do_list_motions(int brief) {
   class nomic_motion* rules;
   class nomic_motion rule;
   int is_mag;
   string ret;
   rules = NOMIC_HANDLER->query_all_motions(query_council_area());
   is_mag = NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name());
   if (!is_mag) {
      rules = filter(rules, (: $1->state == NOMIC_STATE_CITIZEN_VOTE :));
   }
   if (!sizeof(rules)) {
      add_failed_mess("No motion to look at or vote on.\n");
      return 0;
   }
   ret = "";
   foreach (rule in rules) {
      ret += NOMIC_HANDLER->motion_as_string(0, query_council_area(), rule,
                                             brief);
      ret += "\n";
   }
   write("$P$New Nomic Rules$P$" + ret);
   return 1;
}
int do_comment_on(int num) {
   class nomic_motion rule;
   int is_mag;
   rule = NOMIC_HANDLER->query_motion(query_council_area(), num);
   is_mag = NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name());
   if (!rule || !is_mag && rule->state != NOMIC_STATE_CITIZEN_VOTE) {
      add_failed_mess("Could not find the motion " + num + ".\n");
      return 0;
   }
   write("You are commenting on:\n" +
         NOMIC_HANDLER->motion_as_string(0, query_council_area(), rule) +
         "\n");
   this_player()->do_edit("", "finish_comment_on", this_object(), 0, rule);
   return 1;
}
void finish_comment_on(string comment, class nomic_motion rule) {
   if (!comment) {
      write("Aborting comment.\n");
      return ;
   }
   if (NOMIC_HANDLER->comment_on_motion(query_council_area(), rule->identifier,
                                       comment, this_player()->query_name())) {
      write("Succeeded in making a comment on the rule.\n");
   } else {
      write("Could not make a comment on the rule for some reason.\n");
   }
}
int do_amend_motion(int num) {
   class nomic_motion rule;
   int is_mag;
   is_mag = NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name());
   if (!is_mag) {
      add_failed_mess("You cannot amend rules.\n");
      return 0;
   }
   rule = NOMIC_HANDLER->query_motion(query_council_area(), num);
   if (!rule) {
      add_failed_mess("Could not find the motion " + num + ".\n");
      return 0;
   }
   if (rule->state != NOMIC_STATE_COUNCIL_REVIEW) {
      add_failed_mess("You cannot amend the motion " + num + ".\n");
      return 0;
   }
   if (rule->motion_type != NOMIC_MOTION_TYPE_RULE_ADD &&
       rule->motion_type != NOMIC_MOTION_TYPE_RULE_AMEND) {
      add_failed_mess("You cannot amend the motion " + num + ".\n");
      return 0;
   }
   write("You are adding an amendment to:\n" +
         NOMIC_HANDLER->motion_as_string(0, query_council_area(), rule) +
         "\n\nWARNING!  Ammending the motion replaces the current text.\n");
   this_player()->do_edit("", "finish_amend_motion", this_object(), 0, rule);
   return 1;
}
void finish_amend_motion(string amendment, class nomic_motion rule) {
   if (!amendment) {
      write("Aborting amendment.\n");
      return ;
   }
   if (NOMIC_HANDLER->amend_motion(query_council_area(), rule->identifier,
                                   amendment, this_player()->query_name())) {
      write("Succeeded in adding an amendment to the motion.\n");
   } else {
      write("Could not add an amendment to the rule for some reason.\n");
   }
}
int do_vote_on(int num, string vote) {
   class nomic_motion rule;
   int is_mag;
   int vote_id;
   rule = NOMIC_HANDLER->query_motion(query_council_area(), num);
   is_mag = NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name());
   if (!rule || (!is_mag && rule->state != NOMIC_STATE_CITIZEN_VOTE)) {
      add_failed_mess("Could not find the motion " + num + ".\n");
      return 0;
   }
   if (rule->state != NOMIC_STATE_CITIZEN_VOTE &&
       rule->state != NOMIC_STATE_COUNCIL_VOTE) {
      add_failed_mess("The rule is not in a state that you can vote on.\n");
      return 0;
   }
   switch (vote) {
   case "yes" :
      vote_id = NOMIC_VOTE_YES;
      break;
   case "no" :
      vote_id = NOMIC_VOTE_NO;
      break;
   case "abstain" :
      vote_id = NOMIC_VOTE_ABSTAIN;
      break;
   default :
      add_failed_mess("Unknown type of vote, must be one of yes, no or "
                      "abstain.\n");
      return 0;
   }
   if (NOMIC_HANDLER->has_voted_for_motion(query_council_area(), num,
                     this_player()->query_name())) {
      add_failed_mess("You have already voted for this rule!\n");
      return 0;
   } else if (NOMIC_HANDLER->vote_for_motion(query_council_area(), num, vote_id,
                     this_player()->query_name())) {
      add_succeeded_mess(({ "$N $V for " + vote + " in motion id " + num +
                            ".\n",
                            "$N $V for a motion.\n" }));
      return 1;
   }
   add_failed_mess("Could not vote for the rule for some reason.\n");
   return 0;
}
int do_amend_current_rule(int num) {
   class nomic_rule rule;
   rule = NOMIC_HANDLER->query_nomic_rule(query_council_area(), num);
   if (!rule) {
      add_failed_mess("The rule " + num + " does not exist.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name())) {
      add_failed_mess("You cannot do this until you are a magistrate.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->query_can_change_rule(query_council_area(), rule)) {
      add_failed_mess("You cannot change that rule.\n");
      return 0;
   }
   write("What amendment would you like to make to the rule:\n" +
         NOMIC_HANDLER->rule_as_string(0, rule) + "\n");
   this_player()->do_edit("", "amend_current_rule", this_object(), 0, rule);
   return 1;
}
void amend_current_rule(string str, class nomic_rule rule) {
   if (!str) {
      write("Aborting the addition of an amendment.\n");
      return ;
   }
   write("Adding the amendment:\n" +
         str + "\nTo the rule:\n" +
         NOMIC_HANDLER->rule_as_string(0, rule) + "\nAre you sure you wish to do this? ");
   input_to("amend_current_rule_check", 0, rule, str);
}
void amend_current_rule_check(string str,
                               class nomic_rule rule,
                               string amend) {
   str = lower_case(str);
   if (!strlen(str) || str[0] != 'y') {
      write("Aborting the addition of an amendment.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->add_amend_rule_motion(query_council_area(), rule->id, amend,
                                          this_player()->query_name())) {
      write("Cannot add the rule amendment.\n");
   } else {
      write("Added a motion to amend the rule.\n");
   }
}
int do_remove_current_rule(int num) {
   class nomic_rule rule;
   rule = NOMIC_HANDLER->query_nomic_rule(query_council_area(), num);
   if (!rule) {
      add_failed_mess("The rule " + num + " does not exist.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name())) {
      add_failed_mess("You cannot do this until you are a magistrate.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->query_can_change_rule(query_council_area(), rule)) {
      add_failed_mess("You cannot change that rule.\n");
      return 0;
   }
   write("Would you like to remove the rule:\n" +
         NOMIC_HANDLER->rule_as_string(0, rule) +
         "\nYou must be sure about removing this.   Do you wish to "
         "remove the rule? ");
   input_to("remove_current_rule_check", 0, rule);
   return 1;
}
void remove_current_rule_check(string str,
                               class nomic_rule rule) {
   str = lower_case(str);
   if (!strlen(str) || str[0] != 'y') {
      write("Aborting the removal of the rule.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->add_remove_rule_motion(query_council_area(), rule->id,
                                          this_player()->query_name())) {
      write("Cannot remove the rule.\n");
   } else {
      write("Added a motion to remove the rule.\n");
   }
}
int do_create_motion(string type) {
   int type_no;
   type_no = NOMIC_HANDLER->query_type_number(type);
   if (type_no == NOMIC_ERROR ||
       type_no == NOMIC_TYPE_IMMUTABLE) {
      add_failed_mess("The type " + type + " is invalid.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name())) {
      add_failed_mess("You cannot do this until you are a magistrate.\n");
      return 0;
   }
   write("What rule would you like to create?\n");
   this_player()->do_edit("", "create_motion", this_object(), 0, type_no);
   return 1;
}
void create_motion(string str, int type_no) {
   if (!str) {
      write("Aborting the creation of the rule.\n");
      return ;
   }
   write("Adding the motion of type " +
         NOMIC_HANDLER->query_type_name(type_no) + ":\n" +
         str +
         "\nAre you sure you wish to do this? ");
   input_to("create_motion_check", 0, type_no, str);
}
void create_motion_check(string str,
                         int type_no,
                         string motion) {
   str = lower_case(str);
   if (!strlen(str) || str[0] != 'y') {
      write("Aborting the creation of the rule.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->add_create_rule_motion(query_council_area(), type_no, motion,
                                          this_player()->query_name())) {
      write("Cannot create the rule.\n");
   } else {
      write("Added a motion to create the rule.\n");
   }
}
int do_transmogrify_current_rule(int num, string new_type) {
   class nomic_rule rule;
   int new_type_no;
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name())) {
      add_failed_mess("You cannot do this until you are a magistrate.\n");
      return 0;
   }
   rule = NOMIC_HANDLER->query_nomic_rule(query_council_area(), num);
   if (!rule) {
      add_failed_mess("The rule " + num + " does not exist.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->query_can_change_rule(query_council_area(), rule)) {
      add_failed_mess("You cannot change that rule.\n");
      return 0;
   }
   new_type_no = NOMIC_HANDLER->query_type_number(new_type);
   if (new_type_no == NOMIC_ERROR ||
       new_type_no == NOMIC_TYPE_IMMUTABLE) {
      add_failed_mess("The type " + new_type + " is not valid.\n");
      return 0;
   }
   write("Would you like to transmogrify the rule:\n" +
         NOMIC_HANDLER->rule_as_string(0, rule) +
         "\nYou must be sure about transmogrifying this.   Do you wish to "
         "transmogrify the rule? ");
   input_to("transmogrify_current_rule_check", 0, rule, new_type_no);
   return 1;
}
void transmogrify_current_rule_check(string str,
                               class nomic_rule rule,
                               int new_type_no) {
   str = lower_case(str);
   if (!strlen(str) || str[0] != 'y') {
      write("Aborting the removal of the rule.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->add_move_rule_type_motion(query_council_area(), rule->id,
                                          new_type_no,
                                          this_player()->query_name())) {
      write("Cannot transmogrify the rule.\n");
   } else {
      write("Added a motion to transmogrify the rule.\n");
   }
}
void init() {
   ::init();
   add_command("list", "[rules]", (: do_list_rules() :) );
   add_command("list", "rule <number>", (: do_list_one_rule($4[0]) :) );
   add_command("list", "motion <number'motion id'>",
               (: do_list_single_motion($4[0]) :));
   add_command("list", "motions", (: do_list_motions(1) :));
   add_command("list", "motions {verbose|brief}",
               (: do_list_motions($4[0] == "brief") :));
   add_command("comment", "on <number'motion id'>",
                (: do_comment_on($4[0]) :) );
   add_command("amend", "motion <number'motion id'>",
                (: do_amend_motion($4[0]) :) );
   add_command("vote", "{yes|no|abstain} for <number'motion id'>",
               (: do_vote_on($4[1], $4[0]) :));
   add_command("motion", "amend rule <number'rule id'>",
                (: do_amend_current_rule($4[0]) :) );
   add_command("motion", "create new rule <string'type'>",
                (: do_create_motion($4[0]) :) );
   add_command("motion", "remove rule <number'rule id'>",
                (: do_remove_current_rule($4[0]) :) );
   add_command("motion", "move rule <number'rule id'> to <string'type'>",
                (: do_transmogrify_current_rule($4[0], $4[1]) :) );
}

==================================================
FILE: room/council_citizenship.c
==================================================

#define EXPRESSION_NO_CLASSES 1
#include <expressions.h>
inherit "/std/basic/expressions";
inherit "/std/room/basic_room";
inherit "/std/room/inherit/council_base";
inherit "/std/room/inherit/honours";
#include <nomic_system.h>
#include <player_handler.h>
#include <mail.h>
#define WEEK (7 * (24 * 60 * 60))
class approval_list {
   string* sponsors;
   mapping against;
   int time_added;
}
class approved_person {
   class approval_list info;
   int time_approved;
   string approver;
   int denied;
}
class blacklist {
   string blacklister;
   string reason;
}
class denied {
   string denier;
   string deny_reason;
   int time_denied;
}
private mapping _waiting_approval;
private mapping _blacklist;
private mapping _denied;
private class parse_node* _expression;
private class parse_node* _sponsor_expression;
private mapping _approved;
private int _last_posted;
private nosave string _save_file;
int variable_age_in_days(object player);
int variable_age_in_hours(object player);
int variable_level(object player);
int variable_denied_in_days(object player);
int function_citizen_of(string area, object player);
int function_magistrate_of(string area, object player);
int do_apply();
int do_sponsor(string person);
int do_approve(string person);
int do_deny(string person, string reason);
int do_list();
int do_add_blacklist(string person, string reason);
int do_remove_blacklist(string person);
int do_list_blacklist(int verbose);
int do_list_expression();
int do_set_expression(string expr, int applicant);
int do_list_denied();
void load_me();
void create() {
   _waiting_approval = ([ ]);
   _blacklist = ([ ]);
   _denied = ([ ]);
   _approved = ([ ]);
   _last_posted = time();
   honours::create();
   expressions::create();
   add_allowed_variable("ageindays", EXPRESSION_TYPE_INTEGER,
                        (: variable_age_in_days :));
   add_allowed_variable("ageinhours", EXPRESSION_TYPE_INTEGER,
                        (: variable_age_in_hours :));
   add_allowed_variable("level", EXPRESSION_TYPE_INTEGER,
                        (: variable_level :));
   add_allowed_variable("timesincedeniedindays", EXPRESSION_TYPE_INTEGER,
                        (: variable_denied_in_days :));
   add_allowed_function("citizenof", EXPRESSION_TYPE_BOOLEAN,
                        ({ EXPRESSION_TYPE_STRING }),
                        (: function_citizen_of :));
   add_allowed_function("magistrateof", EXPRESSION_TYPE_BOOLEAN,
                        ({ EXPRESSION_TYPE_STRING }),
                        (: function_citizen_of :));
   add_help_file("citizenship");
   basic_room::create();
}
void init() {
   add_command("apply", "[for] [citizenship]", (: do_apply() :));
   add_command("sponsor", "<string'person'> for citizenship",
               (: do_sponsor($4[0]) :));
   add_command("deny", "<string'person'> for citizenship because <string'reason'>",
               (: do_deny($4[0], $4[1]) :));
   add_command("list", "", (: do_list() :));
   add_command("expression", "list",
               (: do_list_expression() :));
   if (NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                      this_player()->query_name()) ||
       master()->query_lord(this_player()->query_name())) {
      add_command("blacklist", "add <string'person'> for <string'reason'>",
                  (: do_add_blacklist($4[0], $4[1]) :));
      add_command("blacklist", "remove <string'person'>",
                  (: do_remove_blacklist($4[0]) :));
      add_command("blacklist", "list {verbose|brief}",
                  (: do_list_blacklist($4[0] == "verbose") :));
      add_command("expression", "citizen <string'citizenship'>",
                   (: do_set_expression($4[0], 0) :));
      add_command("expression", "sponsor <string'citizenship'>",
                   (: do_set_expression($4[0], 1) :));
      add_command("list", "denied", (: do_list_denied :));
      add_command("approve", "<string'person'> for citizenship",
                  (: do_approve($4[0]) :));
   }
   honours::init();
}
void set_save_file(string fname) {
   _save_file = fname;
   load_me();
}
string query_save_file() {
   return _save_file;
}
void load_me() {
   if (!_save_file) {
      return ;
   }
   unguarded( (: restore_object(_save_file, 1) :));
   if (!_expression) {
      _expression = parse_boolean_string("ageindays >= 2 and timesincedeniedindays > 14");
   }
   if (!_sponsor_expression) {
      _sponsor_expression = parse_boolean_string("ageindays >= 10");
   }
   if (!_approved) {
      _approved = ([ ]);
   }
   remove_call_out("post_weekly_results");
   call_out("post_weekly_results", _last_posted + WEEK - time());
}
void save_me() {
   if (!_save_file) {
      return ;
   }
   unguarded( (: save_object(_save_file, 1) :));
}
void post_weekly_results() {
   string post;
   string* cit;
   string person;
   string denied;
   cit = sort_array(keys(_approved), 1);
   if (sizeof(cit) > 0) {
      post = "Here are the weekly citizenship application results:\n\n";
      denied = "";
      foreach (person in cit) {
         if (!_approved[person]->denied) {
            if (sizeof(_approved[person]->info->sponsors)) {
               post += "  " + capitalize(person) + " " +
                      ctime(((class approval_list)_approved[person]->info)->time_added)[4..9] +
                      " sponsors " +
                      query_multiple_short(map(_approved[person]->info->sponsors,
                                               (: capitalize($1) :)));
            } else {
               post += "  " + person + " no sponsor";
            }
            post += " approved " +
                    ctime(_approved[person]->time_approved)[4..9] +
                    " by " + capitalize(_approved[person]->approver) + ".\n";
         } else {
            if (sizeof(_approved[person]->info->sponsors)) {
               denied += "  " + capitalize(person) + " " +
                      ctime(((class approval_list)_approved[person]->info)->time_added)[4..9] +
                      " sponsors " +
                      query_multiple_short(map(_approved[person]->info->sponsors,
                                               (: capitalize($1) :)));
            } else {
               denied += "  " + person + " no sponsor";
            }
            denied += " denied " +
                    ctime(_denied[person]->time_denied)[4..9] +
                    " by " + capitalize(_denied[person]->denier) + ".\n";
         }
      }
      if (strlen(denied) > 0) {
         post += "\n\nThese people have been denied citizenship:\n" +
                 denied;
      }
      NOMIC_HANDLER->post_citizen_message(query_council_area(),
                                         "Citizenship results.",
                                         post);
      _approved = ([ ]);
      save_me();
   }
   _last_posted = time();
   remove_call_out("post_weekly_results");
   call_out("post_weekly_results", _last_posted + WEEK - time());
}
int do_apply() {
   class approval_list womble;
   string str;
   if (NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                           this_player()->query_name())) {
      add_failed_mess("You are already a citizen.\n");
      return 0;
   }
   if (_blacklist[this_player()->query_name()]) {
      add_failed_mess("You are not allowed to become a citizen here.\n");
      return 0;
   }
   if (_waiting_approval[this_player()->query_name()]) {
      add_failed_mess("You are already asking for approval.\n");
      return 0;
   }
   if (!evaluate_expression(_expression, this_player())->value) {
      str = query_expression_string(_expression, 0);
      add_failed_mess("You do not meet the requirements to be a citizen, the "
                      "requirements currently are:\n" + str + "\n");
      return 0;
   }
   if (this_player()->query_creator()) {
      add_failed_mess("Creators cannot be citizens.\n");
      return 0;
   }
   if (NOMIC_HANDLER->is_grace_phase(query_council_area())) {
      str = NOMIC_HANDLER->query_citizen(this_player()->query_name());
      if (str) {
         add_failed_mess("You are already a citizen of " + str +
                         " and cannot join here.\n");
         return 0;
      }
      NOMIC_HANDLER->add_citizen(query_council_area(), this_player()->query_name());
      add_succeeded_mess("$N become$s a citizen of " + query_council_area() +
                          ".\n");
      return 1;
   }
   womble = new(class approval_list);
   womble->sponsors = ({ });
   womble->against = ([ ]);
   womble->time_added = time();
   _waiting_approval[this_player()->query_name()] = womble;
   save_me();
   send_council_inform(1,
              this_player()->query_cap_name() + " applied for citizenship in " +
              query_council_area());
   add_succeeded_mess(({ "You apply for citizenship.\n",
                         "$N applies for citizenship.\n" }));
   return 1;
}
int do_sponsor(string person) {
   string str;
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("Sorry, " + person + " is not a player.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                           this_player()->query_name())) {
      add_failed_mess("Only citizens can sponsor someone.\n");
      return 0;
   }
   if (_blacklist[this_player()->query_name()]) {
      add_failed_mess("You are not allowed to sponsor citizens.\n");
      return 0;
   }
   if (!_waiting_approval[person]) {
      add_failed_mess("I am sorry, " + person + " is not currently "
                      "awaiting citizenship.\n");
      return 0;
   }
   if (!evaluate_expression(_sponsor_expression, this_player())->value) {
      str = query_expression_string(_sponsor_expression, 0);
      add_failed_mess("You do not meet the requirements to sponsor citizen, the "
                      "requirements currently are:\n" + str + "\n");
      return 0;
   }
   if (member_array(this_player()->query_name(),
                    _waiting_approval[person]->sponsors) != -1) {
      add_failed_mess("You are already sponsoring " + person + ".\n");
      return 0;
   }
   if (_waiting_approval[person]->against[this_player()->query_name()]) {
      add_failed_mess("You have already put in a reason for deny "
                      "citizenship to " + person + ".\n");
      return 0;
   }
   _waiting_approval[person]->sponsors += ({ this_player()->query_name() });
   save_me();
   add_succeeded_mess("$N $V someone for citizenship.\n");
   return 1;
}
int do_approve(string person) {
   person = lower_case( person );
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("Sorry, " + person + " is not a player.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                           this_player()->query_name())) {
      add_failed_mess("Only citizens can sponsor someone.\n");
      return 0;
   }
   if (!_waiting_approval[person]) {
      add_failed_mess("I am sorry, " + person + " is not currently "
                      "awaiting citizenship.\n");
      return 0;
   }
   if (NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                       this_player()->query_name())) {
      NOMIC_HANDLER->add_citizen(query_council_area(), person);
      _approved[person] = new(class approved_person);
      _approved[person]->info = _waiting_approval[person];
      _approved[person]->time_approved = time();
      _approved[person]->approver = this_player()->query_name();
      map_delete(_waiting_approval, person);
      save_me();
      send_council_inform(1, person + " granted citizenship by " +
              this_player()->query_cap_name() + " in " +
              query_council_area());
      add_succeeded_mess("$N add$s " + person + " as a citizen.\n");
      if (find_player(person)) {
         tell_object(find_player(person), "%^RED%^You have been granted "
                     "citizenship of " + query_council_area() +
                     "%^RESET%^.\n");
      } else {
         AUTO_MAILER->auto_mail(person, "Council of " + query_council_area(),
                                "Citizenship of " + query_council_area(),
                                "",
                                "Morning,\n\nYou have been granted "
                                "citizenship in " + query_council_area() +
                                ".\n\n"
                                "Good luck!\nCouncil Administrator.\n");
      }
      return 1;
   }
   add_failed_mess("You are not a magistrate of " + query_council_area() +
                   ".\n");
   return 0;
}
int do_deny(string person, string reason) {
   class denied fluff;
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("Sorry, " + person + " is not a player.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                           this_player()->query_name())) {
      add_failed_mess("Only citizens can deny someone.\n");
      return 0;
   }
   if (!_waiting_approval[person]) {
      add_failed_mess("I am sorry, " + person + " is not currently "
                      "awaiting citizenship.\n");
      return 0;
   }
   if (NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                       this_player()->query_name())) {
      map_delete(_waiting_approval, person);
      fluff = new(class denied);
      fluff->deny_reason = reason;
      fluff->denier = this_player()->query_name();
      fluff->time_denied = time();
      _denied[person] = fluff;
      save_me();
      if (find_player(person)) {
         tell_object(find_player(person), "%^RED%^You have been denied "
                     "citizenship of " + query_council_area() +
                     "%^RESET%^.\n");
      } else {
         AUTO_MAILER->auto_mail(person, "Council of " + query_council_area(),
                                "Citizenship of " + query_council_area(),
                                "",
                                "Morning,\n\nYou have been denied as a "
                                "citizen of " + query_council_area() + ".\n\n"
                                "Bad luck!\nCouncil Administrator.\n");
      }
      add_succeeded_mess(({ "$N deny " + person + " as a citizen.\n",
                            "$N denies " + person + " as a citizen.\n"
                             }) );
      return 1;
   }
   if (member_array(this_player()->query_name(),
                    _waiting_approval[person]->sponsors) != -1) {
      add_failed_mess("You are already sponsoring " + person + ".\n");
      return 0;
   }
   if (_waiting_approval[person]->against[this_player()->query_name()]) {
      add_failed_mess("You have already put in a reason for deny "
                      "citizenship to " + person + ".\n");
      return 0;
   }
   _waiting_approval[person]->against[this_player()->query_name()] = reason;
   save_me();
   add_succeeded_mess("$N $V someone for citizenship.\n");
   return 1;
}
int do_list() {
   string ret;
   string ret_tmp;
   string ret_no_sponsor;
   int magistrate;
   string* people;
   string person;
   string denier;
   string reason;
   int index;
   int last;
   int no_sponsor;
   if (!sizeof(_waiting_approval)) {
      add_failed_mess("No one is waiting for citizenship approval.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                           this_player()->query_name())) {
      add_failed_mess("Only citizens can see who is applying for "
                      "citizenship.\n");
      return 0;
   }
   magistrate = NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                                this_player()->query_name());
   people = keys(_waiting_approval);
   people = sort_array(people, (: ((class approval_list)_waiting_approval[$1])->time_added -
                                  ((class approval_list)_waiting_approval[$2])->time_added :));
   ret = "";
   ret_no_sponsor = "";
   foreach (person in people) {
      if (!PLAYER_HANDLER->test_user(person)) {
         map_delete(_waiting_approval, person);
         continue;
      }
      if (sizeof(_waiting_approval[person]->sponsors)) {
         ret += "$I$6=   " +
                ctime(((class approval_list)_waiting_approval[person])->time_added)[4..9] + ": " +
                capitalize(person) + " sponsored by " +
                query_multiple_short(map(_waiting_approval[person]->sponsors,
                                         (: capitalize($1) :)));
         no_sponsor = 0;
      } else {
         ret_no_sponsor += "$I$6=   " +
                ctime(((class approval_list)_waiting_approval[person])->time_added)[4..9] + ": " +
                capitalize(person) + " not sponsored by anyone";
         no_sponsor = 1;
      }
      ret_tmp = "";
      if (sizeof(_waiting_approval[person]->against)) {
         if (magistrate) {
             ret_tmp += ";\n";
             index = 1;
             last = sizeof(_waiting_approval[person]->against);
             foreach (denier, reason in _waiting_approval[person]->against) {
                ret_tmp += "- " + denier + " denied '" + reason + "'";
                if( index == last ) {
                   ret_tmp += "\n";
                } else {
                   ret_tmp += ",\n";
                   index++;
                }
             }
         } else {
             ret_tmp += " denied by " +
                    query_num(sizeof(_waiting_approval[person]->against)) +
                    ".\n";
         }
      } else {
         ret_tmp += ".\n";
      }
      if (no_sponsor) {
         ret_no_sponsor += ret_tmp;
      } else {
         ret += ret_tmp;
      }
   }
   if (ret != "") {
      ret = "$I$0=Waiting for approval:\n" + ret;
   }
   if (ret_no_sponsor != "") {
      ret = "$I$0=Waiting for sponsorship:\n" + ret_no_sponsor + "\n" + ret;
   }
   this_player()->more_string(ret, "citizenship");
   return 1;
}
int do_list_denied() {
   string* people;
   string person;
   string ret;
   if (!sizeof(_denied)) {
      add_failed_mess("No one has been denied yet.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                           this_player()->query_name())) {
      add_failed_mess("Only magistrates can see the denied list.\n");
      return 0;
   }
   people = keys(_denied);
   people = sort_array(people, 1);
   ret = "";
   foreach (person in people) {
      ret += "$I$5=" + person + " at " + ctime(_denied[person]->time_denied) +
             " by " + _denied[person]->denier +
             " for " + _denied[person]->deny_reason + ".\n";
   }
   this_player()->more_string(ret, "denied");
   return 1;
}
int do_list_expression() {
   string str;
   str = query_expression_string(_expression, 0);
   write("The expression to check to make sure someone is allowed to "
         "apply for citizenship is:\n" + str + "\n");
   str = query_expression_string(_sponsor_expression, 0);
   write("The expression to check to make sure someone is allowed to "
         "sponsor an application for citizenship is:\n" + str + "\n");
   return 1;
}
int do_set_expression(string expression, int sponsor_expr) {
   class parse_node* expr;
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("Only magistrates can set an expression string.\n");
      return 0;
   }
   expr = parse_boolean_string(expression);
   if (!sizeof(expr)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   }
   if (!sponsor_expr) {
      _expression = expr;
   } else {
      _sponsor_expression = expr;
   }
   save_me();
   add_succeeded_mess("$N set$s the citizenship requirements.\n");
   return 1;
}
int do_add_blacklist(string person, string reason) {
   class blacklist bing;
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("Only magistrates can manipulate the blacklist.\n");
      return 0;
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("You cannot blacklist someone that does not exist.\n");
      return 0;
   }
   bing = new(class blacklist);
   bing->blacklister = this_player()->query_name();
   bing->reason = reason;
   _blacklist[person] = bing;
   save_me();
   add_succeeded_mess("$N add$s someone to the blacklist.\n");
   return 1;
}
int do_remove_blacklist(string person) {
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                        this_player()->query_name())) {
      add_failed_mess("Only magistrates can manipulate the blacklist.\n");
      return 0;
   }
   if (!_blacklist[person]) {
      add_failed_mess("You cannot remove someone from a blacklist that is not "
                      "black listed already!\n");
      return 0;
   }
   map_delete(_blacklist, person);
   save_me();
   add_succeeded_mess("$N remove$s someone from the blacklist.\n");
   return 1;
}
int do_list_blacklist(int verbose) {
   string ret;
   string* people;
   string person;
   people = keys(_blacklist);
   people = sort_array(people, 1);
   if (!sizeof(people)) {
      add_failed_mess("There is no one in the blacklist currently.\n");
      return 0;
   }
   ret = "";
   if (!verbose) {
      ret += "$I$5=Blacklist is: " + query_multiple_short(people);
   } else {
      ret += "Blacklist:\n";
      foreach (person in people) {
         ret += "$I$5=" + person + " by " + _blacklist[person]->blacklister +
                " for " + _blacklist[person]->reason + ".\n";
      }
   }
   this_player()->more_string(ret, "blacklist");
   return 1;
}
int variable_age_in_days(object player) {
   int bing;
   bing = -player->query_time_on();
   return bing / (60 * 60 * 24);
}
int variable_age_in_hours(object player) {
   int bing;
   bing = -player->query_time_on();
   return bing / (60 * 60);
}
int variable_level(object player) {
   return player->query_level();
}
int variable_denied_in_days(object player) {
   if (_denied[player->query_name()]) {
      return (time() - _denied[player->query_name()]->time_denied) / (60 * 60 * 24);
   }
   return 10000;
}
int function_citizen_of(string area, object player) {
   return NOMIC_HANDLER->is_citizen_of(area, player->query_name());
}
int function_magistrate_of(string area, object player) {
   return NOMIC_HANDLER->is_magistrate_of(area, player->query_name());
}
int is_allowed_to_change(string person) {
   return NOMIC_HANDLER->is_magistrate_of(query_council_area(), person);
}
void inform_of_honour_change(string type, string person,
                             string reason, string changed_by) {
   string subject;
   string mess;
   if (type == "add") {
      subject = PLAYER_HANDLER->query_cap_name(person) +
                " added to the honour roll.";
      mess = PLAYER_HANDLER->query_cap_name(person) + " is added to the "
             "honour roll for this council.\n\nThis means they gain the "
             "honour of using the title(s) " +
             query_multiple_short(map(query_controlled_titles(),
                                      (: capitalize :))) +  ".\n\n" +
             "They were added by " +
             PLAYER_HANDLER->query_cap_name(changed_by) +
             " for:\n" + reason + "\n";
   } else {
      subject = PLAYER_HANDLER->query_cap_name(person) +
                " removed from the honour roll.";
      mess = PLAYER_HANDLER->query_cap_name(person) + " is removed from the "
             "honour roll for this council.\n\nThis means they lose the "
             "privilege of using the title " +
             query_multiple_short(map(query_controlled_titles(),
                                      (: capitalize :))) +  ".\n\n" +
             "They were removed by " +
             PLAYER_HANDLER->query_cap_name(changed_by) +
             " for:\n" + reason + "\n";
   }
   NOMIC_HANDLER->post_citizen_message(query_council_area(),
                                       subject,
                                       mess);
}

==================================================
FILE: room/council_document.c
==================================================

inherit "/std/room/document_handler";
inherit "/std/room/inherit/council_base";
#include <nomic_system.h>
int is_open_for(string type, string name) {
   switch (type) {
   case "document_add" :
   case "document_delete" :
      return NOMIC_HANDLER->is_magistrate_of(query_council_area(), name);
   default :
      return 1;
   }
}

==================================================
FILE: room/council_fine.c
==================================================

#include <money.h>
#include <nomic_system.h>
#include <player_handler.h>
inherit "/std/room/basic_room";
inherit "/std/room/inherit/council_base";
private string _fine_handler;
void create() {
   ::create();
   add_help_file("fines");
}
void set_fine_handler(string fine) {
   _fine_handler = fine;
}
string query_fine_handler() {
   return _fine_handler;
}
int do_pay() {
   string place;
   mixed* m_array;
   int fine;
   int value;
   fine = _fine_handler->query_current_fine(this_player()->query_name());
   if (!fine) {
      add_failed_mess("You do not have any fines due here.\n");
      return 0;
   }
   place = query_property("place");
   value = this_player()->query_value_in(place);
   if (value >= fine) {
      m_array = MONEY_HAND->create_money_array(fine, place);
      this_player()->pay_money(m_array, place);
      _fine_handler->pay_fine(this_player()->query_name(), fine);
      write("You pay off all of your fine of " +
            MONEY_HAND->money_value_string(fine, place) + ".\n");
   } else {
      m_array = MONEY_HAND->create_money_array(value, place);
      this_player()->pay_money(m_array, place);
      _fine_handler->pay_fine(this_player()->query_name(), value);
      write("You pay off " +
            MONEY_HAND->money_value_string(value, place) +
            " of your fine of " +
            MONEY_HAND->money_value_string(fine, place) + ".\n");
   }
   add_succeeded_mess(({ "", "$N $V $p fine.\n" }));
   return 1;
}
string query_fine_information(string person) {
   string ret;
   int fine;
   string place;
   place = query_property("place");
   ret = "";
   fine = _fine_handler->query_current_fine(person);
   if (!fine) {
      ret += "No current fine.\n";
   } else {
      ret += "Current fine of " +
            MONEY_HAND->money_value_string(fine, place) + ".\n";
   }
   fine = _fine_handler->query_total_fine(person);
   if (!fine) {
      ret += "No fines ever.\n";
   } else {
      ret += "Total fines of " +
            MONEY_HAND->money_value_string(fine, place) + ".\n";
   }
   fine = _fine_handler->query_total_payments(person);
   if (!fine) {
   } else {
      ret += "Total fine payments of " +
            MONEY_HAND->money_value_string(fine, place) + ".\n";
   }
   return ret;
}
int do_fine() {
   write(query_fine_information(this_player()->query_name()));
   add_succeeded_mess(({ "", "$N look$s up a fine.\n" }));
   return 1;
}
int do_show_fine(string person) {
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("You must find a fine for an existing person.\n");
      return 0;
   }
   write(person + ":\n" + query_fine_information(person));
   add_succeeded_mess(({ "", "$N look$s up a fine.\n" }));
   return 1;
}
int do_show_all_fines() {
   string ret;
   int fine;
   ret = "";
   foreach (string person in _fine_handler->query_people_with_fines()) {
      fine = _fine_handler->query_current_fine(person);
      if (fine) {
         ret += person + " " + query_fine_information(person) + "\n";
      }
   }
   write("$P$Fines$P$" + ret);
}
void init() {
   add_command("pay", "fine", (: do_pay() :));
   add_command("fine", "", (: do_fine() :));
   if (NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                       this_player()->query_name())) {
      add_command("fine", "<string'player'>", (: do_show_fine($4[0]) :));
      add_command("fine", "all", (: do_show_all_fines :));
      add_command("list", "fines", (: do_show_all_fines :));
   }
}

==================================================
FILE: room/council_treasury.c
==================================================

inherit "/std/room";
inherit "/std/room/inherit/council_base";
#define TWO_WEEKS (60 * 60 * 24 * 7 * 2)
#define READ_LOG 1
#define DEPOSIT 2
#define MAGISTRATE 2
#define CITIZEN 1
#define ANYONE 0
#define COUNCIL_LOG_WITHDRAW_INDEX 0
#define COUNCIL_LOG_DEPOSIT_INDEX  1
#include <money.h>
#include <move_failures.h>
#include <nomic_system.h>
private nosave string _save_file;
private nosave string _archive;
private int _balance = 200;
private int _read;
private int _dep;
private int *_log;
int do_withdraw(int,
                string,
                string);
int do_deposit(int);
int do_check();
class transaction {
   string person;
   int amount;
   string reason;
   int date;
   string action;
}
class transaction *transactions = ({ });
void save_me()
{
   if (!_save_file) {
      debug_printf("Error: No save file set.\n");
      return;
   }
   unguarded((: save_object, _save_file :));
   return;
}
void load_me()
{
   if (!_save_file)
      return;
   if (file_size(_save_file + ".o") > 0) {
      unguarded((: restore_object, _save_file :));
      return;
   }
   return;
}
int security_check(object player,
                   int type)
{
   int person;
   int tmp;
   if (!type)
      return -1;
   if (!player)
      return -1;
   if (NOMIC_HANDLER->is_magistrate_of(query_council_area(), this_player()->query_name())) {
      person = 2;
   }
   if (NOMIC_HANDLER->is_citizen_of(query_council_area(), this_player()->query_name())) {
      person = 1;
   } else {
      person = 0;
   }
   if (type == READ_LOG)
      tmp = _read;
   if (type == DEPOSIT)
      tmp = _dep;
   switch (tmp) {
   case MAGISTRATE:
      return (person == 2);
      break;
   case CITIZEN:
      return (person >= 1);
      break;
   case ANYONE:
      return 1;
   }
}
void check_time()
{
   string str;
   while (transactions[0]->date + TWO_WEEKS < time()) {
      str =
         capitalize(transactions[0]->person) + " " + transactions[0]->action +
         " " + MONEY_HAND->money_value_string(transactions[0]->amount, query_property("place"));
      str +=
         (transactions[0]->action ==
          "withdrew" ? " for " + transactions[0]->reason : "");
      str += " on " + amtime(transactions[0]->date) + ".\n";
      log_file(_archive, str, 0);
      transactions = transactions[1..];
   }
}
void log_action(object player,
                int amount,
                string action,
                string word)
{
   string reason = (word ? word : "no reason specified");
   class transaction new_trans;
   if (!player)
      return;
   if (!amount)
      return;
   if (!action)
      return;
 new_trans = new (class transaction, person: player->query_name(), amount: amount, reason: reason, date: time(), action:action);
   transactions += ({ new_trans });
   check_time();
   save_me();
}
varargs int view_transactions(string player)
{
   int i;
   int f;
   string ret;
   if (!security_check(this_player(), READ_LOG)) {
      return
         add_failed_mess("You aren't allowed to view the transactions.\n");
   }
   ret = "A peek at the log book reveals:\nTransactions\n---\n\n";
   if (!sizeof(transactions)) {
      ret += "None so far.\n";
      write("$P$Transactions$P$" + ret);
      return 1;
   }
   if(player) {
      for(i = 0; i <sizeof(transactions); i++) {
         if (transactions[i]->person != lower_case(player)) {
            continue;
         }
            ret += capitalize(transactions[i]->person) + " " +
                transactions[i]->action + " " +
                MONEY_HAND->money_value_string(transactions[i]->amount,
                query_property("place")) +
                (transactions[i]->action ==
                "withdrew" ? " for " + transactions[i]->reason : "") +
                " on " + amtime(transactions[i]->date)
                + ".\n";
      }
   } else {
      for (i = 0; i < sizeof(transactions); i++) {
      ret += capitalize(transactions[i]->person) + " " +
          transactions[i]->action + " " +
          MONEY_HAND->money_value_string(transactions[i]->amount,
          query_property("place")) +
          (transactions[i]->action ==
          "withdrew" ? " for " + transactions[i]->reason : "") +
          " on " + amtime(transactions[i]->date)
          + ".\n";
      }
   }
   write("$P$Transactions$P$" + ret);
   return 1;
}
void create()
{
   set_short("council treasury");
   set_long("This is the treasury for the council.\n");
   ::create();
   load_me();
   add_help_file( "council_treasury" );
}
void init()
{
   ::init();
   this_player()->add_command("withdraw", this_object(), "<number'amount'> "
                              "<string'type'> for <string'reason'>",
                              (: do_withdraw($4[0], $4[1], $4[2]) :));
   this_player()->add_command("deposit", this_object(), "<string>",
                              (: do_deposit($4[0]) :));
   this_player()->add_command("check", this_object(), "balance");
   this_player()->add_command("view", this_object(),
                              "transactions",
                              (: view_transactions() :));
   this_player()->add_command("view", this_object(),
                              "transactions [by] <word'player'>",
                              (: view_transactions($4[0]) :));
}
void set_save_file(string file)
{
   _save_file = file;
}
void set_place(string word)
{
   add_property("place", word);
}
int do_check()
{
   write("The treasury contains " + MONEY_HAND->money_value_string(_balance,
                                                                   query_property("place")) +
         ".\n");
   return 1;
}
int do_withdraw(int number,
                string type,
                string reason)
{
   int amount;
   int best;
   object money;
   if (!NOMIC_HANDLER->is_magistrate_of(query_council_area(), this_player()->query_name())) {
      notify_fail("You must be a magistrate to withdraw funds.\n");
      return 0;
   }
   if (number <= 0) {
      notify_fail("You must withdraw something.\n");
      return 0;
   }
   money = clone_object(MONEY_OBJECT);
   money->set_money_array((mixed *) MONEY_HAND->query_values_in(query_property("place")));
   if ((best = (int) money->find_best_fit(type)) == -1) {
      notify_fail("That currency is not legal tender here.  Sorry.\n");
      money->dest_me();
      return 0;
   }
   type = ((mixed *) money->query_money_array())[best];
   amount = number * ((mixed *) money->query_money_array())[best + 1];
   if ((amount > _balance) || (amount < 0)) {
      notify_fail("There isn't that much in the account.\n");
      money->dest_me();
      return 0;
   }
   money->set_money_array(({ type, number }));
   _balance -= amount;
   save_me();
   this_player()->add_succeeded_mess(this_object(),
                                     ({ "You withdraw " +
                                        (string) money->short() + ".\n" +
                                        "There is " +
                                        (string) MONEY_HAND->
                                        money_value_string(_balance,
                                                           query_property("place")) +
                                        " in your account after the withdrawal.\n",
                                        "$N withdraws some money from the treasury.\n" }),
                                     ({ }));
   if ((int) money->move(this_player()) != MOVE_OK) {
      write
         ("You are too heavily burdened to collect the money, so the teller "
          + "puts it on the counter for you.\n");
      money->move(this_object());
   }
   if (_log[COUNCIL_LOG_WITHDRAW_INDEX]) {
      log_action(this_player(), amount, "withdrew", reason);
   }
   this_player()->save();
   return 1;
}
int do_deposit(string words)
{
   int amount;
   mixed money;
   object *tender;
   object legal;
   object illegal;
   string howmuch;
   if (!security_check(this_player(), DEPOSIT)) {
      return add_failed_mess("You are not allowed to deposit.\n");
   }
   money = (mixed) MONEY_HAND->parse_money(words, this_player(), query_property("place"));
   if (intp(money)) {
      switch (money) {
      case NO_MATCH:
         return notify_fail("You do not have \"" + words + "\".\n");
      case NO_MONEY:
         return notify_fail("You can only deposit money.\n");
      default:
         return notify_fail("You can only deposit legal tender.\n");
      }
   }
   tender = MONEY_HAND->filter_legal_tender(money, query_property("place"));
   legal = tender[0];
   illegal = tender[1];
   if (legal) {
      amount = legal->query_value_in(query_property("place"));
      if (amount < 200) {
         legal->move(this_player());
         if (illegal) {
            illegal->move(this_player());
         }
         add_failed_mess("That is too small an amount to deposit.\n");
         return 0;
      }
      _balance += amount;
      save_me();
   }
   if (illegal) {
      illegal->move(this_player());
   }
   if (legal) {
      howmuch = legal->the_short();
      legal->move("/room/rubbish");
      this_player()->save();
   } else {
      add_failed_mess("Unable to find any legal money to deposit.\n");
      return 0;
   }
   write("You give the teller " + howmuch + ".\n");
   this_player()->add_succeeded_mess(this_object(),
                                     ({ "$N $V " + words + ".\n"
                                        "This gives a total of " +
                                        MONEY_HAND->
                                        money_value_string(_balance,
                                                           query_property("place")) +
                                        " in the treasury.\n",
                                        "$N deposits some money into the treasury.\n" }),
                                     ({ }));
   if (_log[COUNCIL_LOG_DEPOSIT_INDEX])
      log_action(this_player(), amount, "deposited", "");
   return 1;
}
void set_security_levels(int read_log,
                         int deposits,
                         int *logging)
{
   _read = read_log;
   _dep = deposits;
   _log = logging;
}
void set_archive(string word)
{
   _archive = word;
}

==================================================
FILE: room/council_vote.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/room/inherit/council_base";
inherit "/std/room/inherit/voting_room";
#include <nomic_system.h>
#include <player_handler.h>
void post_results(string type, string desc, string* choices,
                  mixed* votes, string* voted);
void create() {
   voting_room::create();
   set_vote_conditions( (: NOMIC_HANDLER->is_citizen_of(query_council_area(),
                            $1->query_name()) :));
   set_completion_action( (: post_results :));
   set_vote_duration( 7 * 24 * 60 * 60);
   basic_room::create();
   add_help_file("voting_booth");
   setup_after_load();
}
int do_status() {
   string person;
   string* nominated;
   string* magistrates;
   string ret;
   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                     this_player()->query_name())) {
      add_failed_mess("You must be a citizen to see this information.\n");
      return 0;
   }
   magistrates = NOMIC_HANDLER->query_magistrates(query_council_area());
   if (!sizeof(magistrates)) {
      ret = "There are no current magistrates.\n\n";
   } else {
      ret = "The current magistrates of " + query_council_area() +
            " are " +
            query_multiple_short(map(magistrates, (: capitalize($1) :))) +
            ".\n\n";
   }
   if (NOMIC_HANDLER->is_nomination_phase(query_council_area())) {
      ret += "The citizens of " + query_council_area() + " are currently "
            "accepting nominations for the " +
            query_num(NOMIC_HANDLER->query_number_of_magistrates(query_council_area())) +
            " magistrate positions.  The "
            "currently nominated people are:\n";
      nominated = sort_array(NOMIC_HANDLER->query_people_nominated(query_council_area()), 0);
      if (!sizeof(nominated)) {
         ret += "No one is currently nominated.\n";
      } else {
         foreach (person in nominated) {
            ret += "$I$6=   " + capitalize(person) + " nominated by " +
                   query_multiple_short(map(NOMIC_HANDLER->query_nominated_by(
                                          query_council_area(), person),
                                          (: capitalize($1) :)));
            if (NOMIC_HANDLER->is_nomination_accepted(query_council_area(),
                                                      person)) {
               ret += " (accepted)\n";
            } else {
               ret += "\n";
            }
         }
      }
      ret += "\n\n$I$0=The phase ends at " +
         ctime(NOMIC_HANDLER->query_end_of_phase_time(query_council_area())) +
             "\n";
   } else if (NOMIC_HANDLER->is_election_phase(query_council_area())) {
      ret += "The citizens of " + query_council_area() + " are currently "
            "voting for people in the " +
            query_num(NOMIC_HANDLER->query_number_of_magistrates(query_council_area())) +
            " magistrate positions.  The people "
            "you can vote for are:\n";
      nominated = sort_array(NOMIC_HANDLER->query_can_vote_for(query_council_area()), 0);
      foreach (person in nominated) {
         ret += "   * " + capitalize(person) + "\n";
      }
      ret += "\n\n$I$0=The phase ends at " +
         ctime(NOMIC_HANDLER->query_end_of_phase_time(query_council_area())) +
             "\n";
      if (NOMIC_HANDLER->has_voted(query_council_area(),
                                this_player()->query_name())) {
         ret += "You have already voted.\n";
      } else {
         ret += "You have not yet voted.\n";
      }
   } else {
      ret += "\n\nThe next election is at " +
         ctime(NOMIC_HANDLER->query_next_election_time(query_council_area())) +
             "\n";
   }
   this_player()->more_string(ret, "Status");
   return 1;
}
int do_vote(string person, int force) {
   string* bits;
   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                     this_player()->query_name())) {
      add_failed_mess("You must be a citizen to vote.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_election_phase(query_council_area())) {
      add_failed_mess("There is no election at the moment.\n");
      return 0;
   }
   if (NOMIC_HANDLER->has_voted(query_council_area(),
                                this_player()->query_name())) {
      add_failed_mess("You have already voted.  You cannot vote twice!\n");
      return 0;
   }
   bits = explode(replace_string(lower_case(person), " ", ""), ",");
   bits = uniq_array(bits);
   foreach (person in bits) {
      if (!NOMIC_HANDLER->is_eligible_to_vote_for(query_council_area(),
                                                  person)) {
         add_failed_mess("You cannot vote for " + person + " as they are not "
                         "running or not a citizen.\n");
         return 0;
      }
   }
   if (!force &&
       sizeof(bits) <
            NOMIC_HANDLER->query_number_of_magistrates(query_council_area())) {
      add_failed_mess("You must vote for at least " +
            query_num(NOMIC_HANDLER->query_number_of_magistrates(query_council_area())) +
            " magistrates or use the 'force' option to vote for less.\n");
      return 0;
   }
   if (sizeof(bits) >
            NOMIC_HANDLER->query_number_of_magistrates(query_council_area())) {
      add_failed_mess("You can only vote for " +
            query_num(NOMIC_HANDLER->query_number_of_magistrates(query_council_area())) +
            " magistrates, not more.\n");
      return 0;
   }
   if (NOMIC_HANDLER->vote_for_people(query_council_area(), bits,
                                      this_player()->query_name())) {
      add_succeeded_mess(({ "You successfully vote for " +
                            query_multiple_short(bits) + ".\n",
                            "$N votes for someone.\n" }));
      return 1;
   }
   add_failed_mess("Unable to vote for some reason.\n");
   return 0;
}
int do_nominate(string person) {
   person = lower_case(person);
   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(),
                                     this_player()->query_name())) {
      add_failed_mess("You must be a citizen to nominate someonej.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_citizen_of(query_council_area(), person)) {
      add_failed_mess("You can only nominate someone who is a citizen.\n");
      return 0;
   }
   if (!NOMIC_HANDLER->is_nomination_phase(query_council_area())) {
      add_failed_mess("There is no election at the moment.\n");
      return 0;
   }
   if (PLAYER_HANDLER->test_creator(person)) {
      add_failed_mess("You cannot nominate a creator.\n");
      return 0;
   }
   if (member_array(this_player()->query_name(),
                    NOMIC_HANDLER->query_nominated_by(query_council_area(),
                                                      person)) != -1) {
      add_failed_mess("You have already nominated " + person + ".\n");
      return 0;
   }
   if (NOMIC_HANDLER->nominate_magistrate(query_council_area(), person,
                                          this_player()->query_name())) {
      add_succeeded_mess(({ "You successfully nominated " +
                            upper_case( person ) + ".\n",
                            "$N nominates " + person + ".\n" }));
      return 1;
   }
   add_failed_mess("Unable to nominate for some reason.\n");
   return 0;
}
int do_list_motions() {
   class nomic_motion* rules;
   class nomic_motion rule;
   int is_mag;
   string ret;
   rules = NOMIC_HANDLER->query_all_motions(query_council_area());
   is_mag = NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name());
   if (!is_mag) {
      rules = filter(rules, (: $1->state == NOMIC_STATE_CITIZEN_VOTE :));
   }
   if (!sizeof(rules)) {
      add_failed_mess("No motion to look at or vote on.\n");
      return 0;
   }
   ret = "";
   foreach (rule in rules) {
      ret += NOMIC_HANDLER->motion_as_string(0, query_council_area(), rule);
      ret += "\n";
   }
   write("$P$New Nomic Rules$P$" + ret);
   return 1;
}
int do_vote_on(int num, string vote) {
   class nomic_motion rule;
   int is_mag;
   int vote_id;
   rule = NOMIC_HANDLER->query_motion(query_council_area(), num);
   is_mag = NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                      this_player()->query_name());
   if (!rule || (!is_mag && rule->state != NOMIC_STATE_CITIZEN_VOTE)) {
      add_failed_mess("Could not find the motion " + num + ".\n");
      return 0;
   }
   if (rule->state != NOMIC_STATE_CITIZEN_VOTE &&
       rule->state != NOMIC_STATE_COUNCIL_VOTE) {
      add_failed_mess("The rule is not in a state that you can vote on.\n");
      return 0;
   }
   switch (vote) {
   case "yes" :
      vote_id = NOMIC_VOTE_YES;
      break;
   case "no" :
      vote_id = NOMIC_VOTE_NO;
      break;
   case "abstain" :
      vote_id = NOMIC_VOTE_ABSTAIN;
      break;
   default :
      add_failed_mess("Unknown type of vote, must be one of yes, no or "
                      "abstain.\n");
      return 0;
   }
   if (NOMIC_HANDLER->has_voted_for_motion(query_council_area(), num,
                     this_player()->query_name())) {
      add_failed_mess("You have already voted for this rule!\n");
      return 0;
   } else if (NOMIC_HANDLER->vote_for_motion(query_council_area(), num, vote_id,
                     this_player()->query_name())) {
      add_succeeded_mess(({ "$N $V for " + vote + " in motion id " + num +
                            ".\n",
                            "$N $V for a motion.\n" }));
      return 1;
   }
   add_failed_mess("Could not vote for the rule for some reason.\n");
   return 0;
}
void post_results(string type, string desc, string* choices,
                  mixed* votes, string* voted) {
   string mess;
   int i;
   mess = "The results of the poll on:\n" + desc + "\n.\n";
   for (i = 0; i < sizeof(choices); i++) {
      if (arrayp(votes[i])) {
         mess += choices[i] + ":  " + sizeof(votes[i]) + "\n";
      } else {
         mess += choices[i] + ":  " + votes[i] + "\n";
      }
   }
   mess += "\n\nPlease note: This is not a new law, just an opinion poll.\n";
   NOMIC_HANDLER->post_citizen_message(query_council_area(), "Results of Poll",
                                          mess);
}
void add_vote(string type, string description, string *choices, int ending) {
   string mess;
   ::add_vote(type, description, choices, ending);
   mess = "New vote on:\n" + description + "\nWith choices of " +
          query_multiple_short(choices) + ".\n",
   NOMIC_HANDLER->post_citizen_message(query_council_area(), "New vote by " +
                    this_player()->query_cap_name(),
                                          mess);
}
void init() {
   basic_room::init();
   voting_room::init();
   add_command("list", "elections", (: do_status() :));
   add_command("list", "motions", (: do_list_motions() :));
   add_command("information", "", (: do_status() :));
   add_command("status", "", (: do_status() :));
   add_command("vote", "{yes|no|abstain} in [motion] <number'id'>",
               (: do_vote_on($4[1], $4[0]) :));
   add_command("vote", "for <string'people'>", (: do_vote($4[0], 0) :));
   add_command("vote", "force for <string'people'>", (: do_vote($4[0], 1) :));
   add_command("nominate", "<string'person'>", (: do_nominate($4[0]) :));
   if (NOMIC_HANDLER->is_magistrate_of(query_council_area(),
                                      this_player()->query_name())) {
      init_add_vote();
   }
}

==================================================
FILE: room/delivery_room.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/delivery";
void create() {
    delivery::create();
    basic_room::create();
}
void dest_me() {
    delivery::dest_me();
    basic_room::dest_me();
}
mixed *stats() {
    return delivery::stats() + basic_room::stats();
}
int query_delivery_room() {
    return 1;
}

==================================================
FILE: room/graffbase.c
==================================================

#include <language.h>
#define GRAFFITI "graffiti"
#define ETP environment(this_player())
#define TO this_object()
object writing_on;
string type;
object old;
string olds;
string query_drawingwith();
int do_check();
int done_check();
string query_drawingwith() { return "something"; }
int do_check() { return 0; }
int done_check() { return 0; }
void init() {
 this_player()->add_command( "scrawl", this_object(), "with charcoal on wall");
 this_player()->add_command( "scrawl", this_object(), "on wall with charcoal");
}
int do_scrawl( object *things ) {
    string language;
    if ( !ETP->query_property( GRAFFITI) ) {
        this_player()->add_failed_mess( this_object(), "You can't scrawl on "+
          "this wall.\n");
        return 0;
    }
    language = (string)this_player()->query_current_language();
    if ( !LANGUAGE_HAND->query_language_written( language ) ) {
        this_player()->add_failed_mess( this_object(), "You can't scrawl on "
          "a wall when you're not using a language that can be "+
          "scrawling on a wall with.\n",({writing_on}));
        return 0;
    }
    if(( old = present("graffiti",ETP)) && !interactive(old))
    {
        olds = old->query_property("graffiti");
    }
    if ( writing_on ) {
        this_player()->add_failed_mess( this_object(), "The writing "+
          "spot seems to be busy at the moment.\n",
          ({writing_on}));
        return 0;
    }
    this_player()->add_succeeded_mess( this_object(), ({"You start scrawling "+
      "on a wall with some charcoal.\n", "$N starts scrawling on a wall with "
      "some charcoal.\n"}) );
    writing_on = ETP;
    call_out( "begin_writing", 0, this_player() );
    return 1;
}
void begin_writing( object writer ) {
    if ( !writer ) {
        writing_on = 0;
        return;
    }
    writer->do_edit( 0, "end_writing" );
}
void end_writing( string words ) {
    string language;
    string extra;
    if ( !words || ( words == "" ) ) {
        write( "You don't scrawl anything on "+
         "the wall.\n");
        say( (string)this_player()->the_short() +" doesn't "+
          "scrawl anything after all.\n" );
        writing_on = 0;
        return;
    }
    language = (string)this_player()->query_current_language();
    if ( !LANGUAGE_HAND->query_language_written( language ) ) {
        write( "You seem to have changed to using a non-written language.\n" );
        say( (string)this_player()->the_short() +" seems "+
          "linguistically-challenged.\n" );
        writing_on = 0;
        return;
    }
    if ( !writing_on ) {
        write( "You seem to have lost what you were scrawling on.\n" );
        say( (string)this_player()->the_short() +" looks around "+
          "in puzzlement.\n" );
        return;
    }
    if (  writing_on != ETP ) {
        write("The wall seems to have run away from you.\n" );
        say( (string)this_player()->the_short() +" looks like "+
          (string)this_player()->query_pronoun() +"'s lost something.\n" );
        writing_on = 0;
        return;
    }
    if(!stringp(olds)) olds = "";
    words = olds +"\n"+"%^MAGENTA%^Scrawled with rough charcoal, you "
             "read the words:%^RESET%^\n\n"+
    words;
    if(old) old->move("/room/rubbish");
    extra = TO->extra_stuff();
    if(!strlen(extra))extra = "Some disreputable character has scrawled "
        "graffiti over this wall.  You may be able to \"read\" it.\n";
    ETP->add_sign(
      extra,
      words,
      "graffiti",
      ({"graffiti","scrawl"}),
      language
    );
    old = present("graffiti",ETP);
    old->add_property("determinate","some ");
    old->add_property("there","on the wall");
    if(old) old->add_property("graffiti",words);
    write( "As you finish scrawling on the wall, the piece of charcoal "
           "breaks.\n" );
    say( (string)this_player()->the_short() +" finishes scrawling "+
      "on the wall.\n" );
    this_object()->done_check();
    writing_on = 0;
}

==================================================
FILE: room/guild-outside.c
==================================================

inherit "/std/room/outside";
inherit "/std/room/inherit/guild";
void create() {
  guild::create();
  outside::create();
}
void init() {
  outside::init();
  guild::init();
}

==================================================
FILE: room/guild.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/room/inherit/guild";
void create() {
  guild::create();
  basic_room::create();
}
void init() {
  basic_room::init();
  guild::init();
}

==================================================
FILE: room/meeting.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/room/inherit/meeting";
void create() {
   add_help_file("meeting");
   basic_room::create();
   meeting::create();
}
void init() {
   basic_room::init();
   meeting::init();
}

==================================================
FILE: room/newspaper_office.c
==================================================

inherit "/std/room/inherit/newspaper_office";
inherit "/std/room/basic_room";
void create() {
   newspaper_office::create();
   basic_room::create();
   add_help_file("newspaper_office");
}
void init() {
   basic_room::init();
   newspaper_office::init();
}

==================================================
FILE: room/newspaper_subscription.c
==================================================

#define USE_LOGIN 1
#include <room/newspaper.h>
#include <move_failures.h>
#include <mail.h>
#include <money.h>
#include <player_handler.h>
#define ISSUES_PER_BOX 12
inherit "/std/room/basic_room";
private mapping _subscribers;
private string _region;
private string _paper;
private string _parcel;
private nosave string _savefile;
void create() {
   ::create();
   add_help_file( "newspaper_subscription" );
   if( !_subscribers ) {
      _subscribers = ([ ]);
   }
}
int query_price_per_issue_subscriber() {
   int deposit_cost = 400;
   return deposit_cost + ( NEWSPAPER_HANDLER->query_paper_cost( _paper ) * 2 );
}
int query_price_per_issue_box() {
   return NEWSPAPER_HANDLER->query_paper_cost( _paper );
}
int query_price_newspaper_box() {
   return load_object( NEWSPAPER_SUBSCRIPTION_OB )->query_value() +
           ISSUES_PER_BOX * NEWSPAPER_HANDLER->query_paper_cost( _paper );
}
int query_price_international_newspaper_box() {
   return (load_object( NEWSPAPER_SUBSCRIPTION_OB )->query_value() +
           ISSUES_PER_BOX * NEWSPAPER_HANDLER->query_paper_cost( _paper )) * 2;
}
private void load_me() {
   if( !_savefile ||
       ( file_size( _savefile ) <= 0 && file_size( _savefile + ".o" ) <= 0 ) ) {
      return;
   }
   unguarded( (: restore_object( _savefile + ".o", 1 ) :) );
}
private void save_me() {
   if( !_savefile ) {
      return;
   }
   unguarded( (: save_object( _savefile, 1 ) :) );
}
void dest_me() {
   save_me();
   ::dest_me();
}
private void send_termination_mail( string name, string mess ) {
   object player;
   if( ( player = find_living( name ) ) &&
       environment( player ) ) {
      tell_room( environment( player ),
                 "An imp zips past " + player->the_short() + " screaming \"You "
                 "have mail!\" in its high-pitched voice.\n" );
   }
   AUTO_MAILER->auto_mail( name,
                           _paper,
                           "Your subscription for " + _paper,
                           0,
                           "Greetings.\n"
                           "\n"
                           "Your subscription for " + _paper +
                           " has ended.\n"
                           "\n" +
                           mess + "\n" );
}
private int withdraw_from_account( string name, int price ) {
   string bank;
   int amount = 0;
   int amount_in_account;
   foreach( bank in BANK_HANDLER->query_accounts( name ) ) {
      if( BANK_HANDLER->query_account( name, bank ) >= price ) {
         BANK_HANDLER->adjust_account( name, bank, -price );
         return 1;
      } else {
         amount += BANK_HANDLER->query_account( name, bank );
      }
   }
   if( amount >= price ) {
      foreach( bank in BANK_HANDLER->query_accounts( name ) ) {
         amount_in_account = BANK_HANDLER->query_account( name, bank );
         if( amount_in_account < amount ) {
            amount -= amount_in_account;
            BANK_HANDLER->adjust_account( name, bank, -amount_in_account );
         } else {
            BANK_HANDLER->adjust_account( name, bank, -amount );
            return 1;
         }
      }
   }
   send_termination_mail( name, "You failed to pay for an issue of " + _paper +
                                "." );
   return 0;
}
private void deliver_issue( string name, int issue ) {
   int* editions;
   object player;
   object ob;
   editions = PLAYER_HANDLER->test_property( name, "Paper " + _paper );
   if( !editions ) {
      editions = ({ });
   }
   if( member_array( issue, editions ) == -1 ) {
      editions += ({ issue });
#ifdef USE_LOGIN
      "/secure/login"->special_add_property( name, "Paper " + _paper,
                                             editions );
#endif
#ifdef USE_PLAYER_HANDLER
      PLAYER_HANDLER->special_add_property( name, "Paper " + _paper,
                                             editions );
#endif
      NEWSPAPER_HANDLER->add_edition_paper_sold( _paper, issue,
                         NEWSPAPER_HANDLER->query_paper_cost( _paper ) );
   } else {
      NEWSPAPER_HANDLER->add_edition_revenue( _paper, issue,
                         NEWSPAPER_HANDLER->query_paper_cost( _paper ) );
   }
   ob = clone_object( NEWSPAPER_OB );
   ob->set_paper( _paper );
   ob->set_edition( issue );
   if( _parcel ) {
      MAIL_PARCEL_HANDLER->deposit( name, _paper, _parcel, ({ ob }) );
   }
   if( ( player = find_living( name ) ) &&
       environment( player ) ) {
      tell_room( environment( player ),
                 "An imp rushes up to " + player->the_short() + " and squeaks "
                 "something that very much sounds like \"You have mail!\" "
                 "before zipping away again.\n" );
   }
   AUTO_MAILER->auto_mail( name,
                           _paper,
                           "A new issue of " + _paper,
                           0,
                           "Greetings.\n"
                           "\n"
                           "Issue " + issue + " of " + _paper + " has been "
                           "deposited for you at the " + _parcel +
                           " post-office.\n"
                           "\n"
                           "Enjoy.\n" );
}
void event_publish_paper(string paper) {
   string name;
   int issues;
   int price;
   int last_issue = NEWSPAPER_HANDLER->query_last_edition_num( _paper );
   if (paper != _paper) {
      return ;
   }
   price = query_price_per_issue_subscriber();
   if( _subscribers ) {
      foreach( name in keys( _subscribers ) ) {
         if( !PLAYER_HANDLER->test_user( name ) ) {
            map_delete( _subscribers, name );
         } else {
            issues = _subscribers[ name ];
            if( issues == -1 ) {
               if( withdraw_from_account( name, price ) ) {
                  deliver_issue( name, last_issue );
               } else {
                  map_delete( _subscribers, name );
               }
            } else if( issues >= 1 ) {
               deliver_issue( name, last_issue );
               _subscribers[ name ]--;
               if( _subscribers[ name ] == 0 ) {
                  map_delete( _subscribers, name );
                  send_termination_mail( name,
                                         "All issues of " + _paper + " that "
                                         "you have paid for have been "
                                         "delivered." );
               }
            }
         }
      }
   }
}
void set_money_place( string new_region ) {
   _region = new_region;
}
string query_money_place() {
   return _region;
}
protected void set_paper( string new_paper ) {
   if (_paper) {
      NEWSPAPER_HANDLER->remove_newspaper_inform(_paper, file_name(this_object()));
   }
   _paper = new_paper;
   NEWSPAPER_HANDLER->add_newspaper_inform(_paper, file_name(this_object()));
}
protected void set_savefile( string filename ) {
   _savefile = filename;
   if (_savefile) {
      load_me();
   }
}
protected void set_parcel( string parcel_region ) {
   _parcel = parcel_region;
}
int do_subscribe( int numbers ) {
   string name;
   int price;
   string mess;
   if( !numbers || !this_player() || numbers < -1 ) {
      return 0;
   }
   name = this_player()->query_name();
   price = query_price_per_issue_subscriber();
   if( !_subscribers ) {
      _subscribers = ([ ]);
   }
   if( !undefinedp( _subscribers[ name ] ) && _subscribers[ name ] == -1 ) {
      add_failed_mess( "You already have a subscription for " + _paper +
                       ", so there is no need to re-subscribe.\n" );
      return 0;
   }
   if( numbers == -1 ) {
      _subscribers[ name ] = -1;
      add_succeeded_mess( ({"You subscribe to " + _paper + ".\n"
                            "Your bank-account(s) will be billed whenever a "
                            "new issue is released, until you unsubscribe.\n",
                            "$N fill$s out a subscription form.\n"
                          }) );
      save_me();
      return 1;
   }
   price *= numbers;
   if( this_player()->query_value_in( _region ) < price ) {
      add_failed_mess( "You cannot afford to pay for this many issues of " +
                       _paper + ".  It would cost you " +
                       MONEY_HAND->money_value_string( price, _region ) +
                       ".\n" );
      return 0;
   }
   if( undefinedp( _subscribers[ name ] ) ) {
      _subscribers[ name ] = numbers;
      if( numbers == 1 ) {
         mess = "one issue ";
      } else {
         mess = numbers + " issues ";
      }
   } else {
      _subscribers[ name ] += numbers;
      if( numbers == 1 ) {
         mess = "an additional issue ";
      } else {
         mess = "an additional " + numbers + " issues ";
      }
   }
   this_player()->pay_money( MONEY_HAND->create_money_array( price, _region ),
                            _region );
   add_succeeded_mess( ({"You subscribe to " + mess + "of " + _paper +
                         " and pay " + MONEY_HAND->money_value_string( price,
                         _region ) + ".\n",
                         "$N fill$s out a subscription form.\n"
                       }) );
   save_me();
   return 1;
}
int do_unsubscribe() {
   if( undefinedp( _subscribers[ this_player()->query_name() ] ) ) {
      add_failed_mess( "You don't have a subscription for " + _paper +
                       ", so you cannot unsubscribe.\n" );
      return 0;
   }
   map_delete( _subscribers, this_player()->query_name() );
   add_succeeded_mess( ({"You successfully unscubscribe from " + _paper + ".\n",
                         "$N fill$s out a subscription form.\n"
                       }) );
   save_me();
   return 1;
}
int do_buy( int international ) {
   object box;
   int price;
   if( international == 1 ) {
      price = query_price_international_newspaper_box();
   } else {
      price = query_price_newspaper_box();
   }
   if( !this_player() ) {
      return 0;
   }
   if( this_player()->query_value_in( _region ) < price ) {
      add_failed_mess( "You are too poor to afford this.\n" );
      return 0;
   } else {
      this_player()->pay_money( MONEY_HAND->create_money_array(
                                  price, _region ), _region );
      add_succeeded_mess( "$N purchase$s a newspaper box.\n" );
      box = clone_object( NEWSPAPER_SUBSCRIPTION_OB );
      box->set_paper( _paper );
      box->set_international( international );
      box->set_issues_left( ISSUES_PER_BOX );
      box->set_last_issue( NEWSPAPER_HANDLER->query_last_edition_num( _paper ));
      if( box->move( this_player() ) != MOVE_OK ) {
         box->move( environment( this_player() ) );
         write( "You cannot carry the box.  It has been put on the "
                      "floor.\n" );
      }
      return 1;
   }
}
int do_check() {
   int i;
   if( !this_player() ) {
      return 0;
   }
   if( undefinedp( _subscribers[ this_player()->query_name() ] ) ) {
      add_succeeded_mess( ({"You have no subscription for " + _paper + ".\n",
                            "$N check$s something on a list.\n"
                          }) );
      return 1;
   }
   i = _subscribers[ this_player()->query_name() ];
   if( i == -1 ) {
      add_succeeded_mess( ({"Your subscription for " + _paper +
                            " will continue until you unsubscribe again.\n",
                            "$N check$s something on a list.\n"
                          }) );
      return 1;
   } else if( i == 1 ) {
      add_succeeded_mess( ({"Your subscription for " + _paper +
                            " will expire after the next issue.\n",
                            "$N check$s something on a list.\n"
                          }) );
      return 1;
   } else {
     add_succeeded_mess( ({ "Your subscription for " + _paper + " covers " + i +
                            " more issues.\n",
                            "$N check$s something on a list.\n"
                         }) );
      return 1;
   }
}
int do_list( string subscription_type ) {
   string* subscriber_list;
   string name;
   subscriber_list = ({ });
   if( !this_player() || !subscription_type ) {
      return 0;
   }
   if( subscription_type == "all" ) {
      foreach( name in keys( _subscribers ) ) {
         subscriber_list += ({ name });
      }
   } else if( subscription_type == "pre-paid" ) {
      foreach( name in keys( _subscribers ) ) {
         if( _subscribers[ name ] > 0 ) {
            subscriber_list += ({ name });
         }
      }
   } else if( subscription_type == "unlimited" ) {
      foreach( name in keys( _subscribers ) ) {
         if( _subscribers[ name ] == -1 ) {
            subscriber_list += ({ name });
         }
      }
   }
   if( sizeof( subscriber_list ) == 0 ) {
      subscriber_list += ({ "none" });
   }
   add_succeeded_mess( ({"The following people have a this kind of "
                         "subscription for " + _paper + ":\n" +
                         query_multiple_short( subscriber_list ) +
                         "\n",
                         "$N check$s some lists.\n"
                       }) );
   return 1;
}
void init() {
   string _office;
   object office = 0;
   add_command( "subscribe",
                "[to] <number> [issue|issues] of " + _paper,
                (: do_subscribe( $4[0] ) :) );
   add_command( "subscribe",
                "[to] " + _paper,
                (: do_subscribe( -1 ) :) );
   add_command( "unsubscribe",
                "[from] " + _paper,
                (: do_unsubscribe() :) );
   add_command( "buy",
                "[a] newspaper box",
                (: do_buy( 0 ) :) );
   add_command( "buy",
                "[an] international newspaper box",
                (: do_buy( 1 ) :) );
   add_command( "check",
                "subscription",
                (: do_check() :) );
   if( _office = NEWSPAPER_HANDLER->query_paper_office( _paper ) ) {
      office = load_object( _office );
   }
   if( this_player()->query_creator() ||
       ( office && office->is_editor(this_player()->query_name()) ) ) {
      add_command( "list",
                   "{all|unlimited|pre-paid} subscriptions",
                   (: do_list( $4[0] ) :) );
   }
   if( !this_player()->query_creator() ) {
      return;
   }
   if( !_parcel ) {
      write("%^WHITE%^%^BOLD%^Warning: This room's _parcel - variable "
                   "isn't set.%^RESET%^\n" );
   }
   if( !_region ) {
      write("%^WHITE%^%^BOLD%^Warning: This room's _region - variable "
                   "isn't set.%^RESET%^\n" );
   }
   if( !_paper ) {
      write("%^WHITE%^%^BOLD%^Warning: This room's _paper - variable "
                   "isn't set.%^RESET%^\n" );
   }
      if( !_savefile ) {
      tell_object( this_player(),
                   "%^WHITE%^%^BOLD%^Warning: This room's _savefile - variable "
                   "isn't set.%^RESET%^\n" );
   }
   ::init();
}

==================================================
FILE: room/npcroom.c
==================================================

#define FLAG 0
#define DELAY 1
#define CLONE 2
#define MESS 3
#define REMOVABLE 0
#define FIXED 1
#define UNIQUE 2
nosave mixed  *reset_definitions;
nosave object *reset_objects;
void add_cloned_object( int flag, int delay, mixed clone_info,
                       string entry_mess ) {
   if ( !sizeof( reset_definitions ) )
      reset_definitions = ({ ({ flag, delay, clone_info, entry_mess }) });
   else
      reset_definitions += ({ ({ flag, delay, clone_info, entry_mess }) });
}
mixed *query_cloned_objects() {
   return reset_objects + ({ });
}
mixed *query_cloned_definitions() {
   return reset_definitions + ({ });
}
private object make_clone( mixed func ) {
   if ( stringp( func ) ) {
      return clone_object( func );
   } else if ( functionp( func ) ) {
      return evaluate( func );
   } else
      return 0;
}
private void make_object( int i ) {
   switch ( reset_definitions[ i ][ FLAG ] ) {
    case REMOVABLE:
    case FIXED:
      reset_objects[ i ] = make_clone( reset_definitions[ i ][ CLONE ] );
      reset_objects[ i ]->move( this_object(),
            reset_definitions[ i ][ MESS ] );
      break;
    case UNIQUE:
      if ( !stringp( reset_definitions[ i ][ CLONE ] ) )
         return;
      reset_definitions[ i ][ CLONE ]->move( this_object(),
            reset_definitions[ i ][ MESS ] );
      reset_objects[ i ] = find_object( reset_definitions[ i ][ CLONE ] );
   }
}
void reset() {
   int i;
   if ( !sizeof( reset_definitions ) )
      return;
   if ( !sizeof( reset_objects ) )
      reset_objects = allocate( sizeof( reset_definitions ) );
   for ( i = sizeof( reset_definitions ); i--; ) {
      switch ( reset_definitions[ i ][ FLAG ] ) {
       case REMOVABLE:
         if ( !reset_objects[ i ] ||
             ( environment( reset_objects[ i ] ) != this_object() ) ) {
            if ( reset_definitions[ i ][ DELAY ] >= 0 )
               call_out( "make_object", reset_definitions[ i ][ DELAY ], i );
            else
               make_object( i );
         }
         break;
       case FIXED:
       case UNIQUE:
         if ( !reset_objects[ i ] ) {
            if ( reset_definitions[ i ][ DELAY ] >= 0 )
               call_out( "make_object", reset_definitions[ i ][ DELAY ], i );
            else
               make_object( i );
         }
      }
   }
}

==================================================
FILE: room/outside.c
==================================================

#include <weather.h>
inherit "/std/room/basic_room";
#define FAST_CLEAN_UP 15
nosave int current_day;
nosave object sunlight;
nosave int day_light;
nosave string _climate;
nosave int next_weather_update;
nosave string weather_str;
private nosave string _weather_handler;
nosave int callout_handle;
nosave int room_stabilize;
private nosave int room_create_time;
private nosave int _fast_clean_up;
int clean_up_room( int flag );
int query_fast_clean_up();
void set_fast_clean_up(int fast_clean_up);
void set_weather_handler( string handler ) {
    _weather_handler = handler ;
}
string query_weather_handler() {
    return _weather_handler ;
}
int set_climate(string climate) {
  if(member_array(climate, CLIMATES) == -1)
    return 0;
  _climate = climate;
  return 1;
}
string query_climate() {
  if(!_climate)
    return DEFAULT_CLIMATE;
  return _climate;
}
void set_light_change(string s) {
    add_property("light change", s);
}
string query_light_change() {
    return query_property("light change");
}
string snow_look() {
   return _weather_handler->snow_string(this_object()) + ".";
}
string rain_look() {
   return _weather_handler->rain_string(this_object()) + ".";
}
string sleet_look() {
   return _weather_handler->sleet_string(this_object()) + ".";
}
string cloud_look() {
   return _weather_handler->cloud_string(this_object()) + ".";
}
void create() {
  set_fast_clean_up(1);
  do_setup++;
  ::create();
  do_setup--;
  set_room_size( 50 );
  add_property( "location", "outside" );
  add_property( "here", "on the ground" );
  _weather_handler = WEATHER ;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  room_create_time = time();
  room_stabilize = 0;
}
int query_light() {
  int new_light;
  new_light = ( day_light * (int)_weather_handler->query_darkness
    ( this_object() ) ) / 100;
  if ( new_light != query_my_light() ) {
    ::set_light(new_light);
  }
  return ::query_light();
}
int query_visibility() {
   return _weather_handler->query_visibility(this_object());
}
int query_day_light() { return day_light; }
int set_light( int number ) {
  ::set_light(number);
  day_light = number;
}
string long( string word, int dark ) {
   int day_time;
   string ret;
   string obscure;
   mixed bit;
   ret = ::long( word, dark );
   day_time = (int)_weather_handler->query_day( this_object() );
   if ( day_time != current_day ) {
      if ( query_light_change() ) {
         call_other( this_object(), query_light_change(), current_day );
      }
   }
   obscure = this_object()->query_weather_obscured(day_time);
   if ( !day_time )
   {
      bit = query_night_long();
      if (functionp(bit)) {
         bit = evaluate(bit, word, dark);
      }
      ret = replace(ret, "$long$", bit);
      if (!obscure) {
         ret = (string)_weather_handler->query_moon_string() + ret;
      }
   } else {
      bit = query_long();
      if (functionp(bit)) {
         bit = evaluate(bit, word, dark);
      }
      ret = replace( ret, "$long$", bit);
   }
   if ( time() > next_weather_update ) {
      weather_str = _weather_handler->weather_string(this_object(), obscure) +".\n";
      next_weather_update = (int)_weather_handler->next_update();
   }
   return replace(ret, "$weather$",
                  this_player()->colour_event("weather", "%^ORANGE%^")+
                  weather_str+ "%^RESET%^");
}
mixed *stats() {
  return ::stats() + ({
    ({ "day light", day_light, }),
  });
}
object *find_inv_match( string word, object looker ) {
  int daylight;
  if((word == "sunlight") || (word == "daylight"))
  {
    daylight = this_object()->query_light();
    if(daylight == 0)
    {
      if(sunlight)
      {
        remove_hidden_object(sunlight);
        sunlight->dest_me();
        sunlight = 0;
      }
      return ::find_inv_match( word, looker );
    }
    if(!sunlight)
    {
      sunlight = clone_object("/std/object");
      sunlight->set_name("sunlight");
      sunlight->set_weight(0);
      sunlight->reset_get();
      sunlight->add_alias("daylight");
      add_hidden_object(sunlight);
    }
    if(daylight < 25)
    {
      sunlight->set_long("The light here is currently quite dim.\n");
    } else {
      sunlight->set_long("What do you want to look at the light for?  "+
        "It's... well, light really.\n");
    }
  }
  return ::find_inv_match( word, looker );
}
void dest_me() {
  if(sunlight) {
    sunlight->dest_me();
  }
  ::dest_me();
}
#ifdef FAST_CLEAN_UP
void event_exit(object ob, string message, object to) {
  if(!room_stabilize) {
    remove_call_out(callout_handle);
    callout_handle = call_out("clean_up_room", FAST_CLEAN_UP, 0);
  }
}
string *query_zones() {
  if(!room_stabilize)
    callout_handle = call_out("clean_up_room", FAST_CLEAN_UP, 0) ;
  return ::query_zones();
}
int clean_up_room(int flag) {
  object *obs, ob;
  int elapsed_time = time() - room_create_time;
  if(room_stabilize || !query_fast_clean_up() ||
     this_object()->query_keep_room_loaded())
    return 0;
  callout_handle = 0 ;
  obs = filter(all_inventory(this_object()),
               (: !living($1) || (userp($1)) ||
                !$1->query_property("transient") ||
                sizeof($1->query_attacker_list()) ||
                $1->cannot_walk() :));
  if(sizeof(all_inventory(this_object())) ||
     elapsed_time > (FAST_CLEAN_UP * 3)) {
    room_stabilize = 1;
    return 1;
  }
  obs = filter(all_inventory(this_object()),
               (: $1->query_property("transient") :));
  foreach(ob in obs)
    if(ob->query_property("hospital"))
      ob->move(ob->query_property("hospital"), "$N wander$s in.",
               "$N wander$s out.");
  dest_me();
  return 0;
}
void set_fast_clean_up(int number) {
   _fast_clean_up = number;
}
int query_fast_clean_up() {
   return _fast_clean_up;
}
#endif

==================================================
FILE: room/parcel_inherit.c
==================================================

#include <money.h>
#include <mail.h>
#include <player_handler.h>
#include <player.h>
inherit "/std/room/basic_room";
string loc;
string where;
object shelf;
int cost;
varargs int do_deposit( object *obs, string name, int show_sender );
int do_collect();
void make_shelf( string short, string long ) {
  shelf = clone_object( "/std/surface" );
  shelf->set_name( short );
  shelf->set_long( long );
  shelf->set_max_weight( 10000 );
  shelf->move( this_object() );
  shelf->add_property( "there", "fixed to one wall" );
  shelf->reset_get();
}
void set_location( string _loc ) { loc = _loc; }
void set_cost( int _cost ) { cost = _cost; }
void set_currency( string temp ) { where = temp; }
string query_location() { return loc; }
int query_cost() { return cost; }
string query_currency() { return where; }
void init() {
    ::init();
  this_player()->add_command( "deposit", this_object(),
                  "<indirect:object> for <string>",
                  (: do_deposit( $1, $4[1] ) :) );
  this_player()->add_command( "collect", this_object(), "",
                  (: do_collect() :) );
}
int deposit_parcel( object *obs, string name, int show_sender ) {
  if ( obs == 0 || name == 0 ) {
    return 0;
  }
  if ( !PLAYER_HANDLER->test_user( name ) )  {
    return -2;
  }
  if ( !sizeof( obs ) ) {
    return 0;
  }
  if ( PLAYER_MULTIPLAYER_HANDLER->member_denied_parcel( this_player()->query_name() ) ) {
    return -4;
  }
  if ( PLAYER_MULTIPLAYER_HANDLER->member_denied_parcel( lower_case(name) ) ) {
    return -5;
  }
  MAIL_PARCEL_HANDLER->deposit( name, this_player()->query_name(),
                   loc, obs );
  AUTO_MAILER->auto_mail( name, "the parcel clerk",
       "Parcel Deposit Notification", "",
       "Please come to the " + loc + " Post Office parcel counter to\n"
       "collect " + ( sizeof( obs ) == 1 ? "a parcel which has" :
       query_num( sizeof( obs ) ) +" parcels which have" ) +
       " been deposited for you" +
       ( show_sender ? " by " + this_player()->query_short() : "" ) + ".\n\n"
       "Due to limited space in our warehouse you have two weeks to collect\n"
       "your parcels, if you do not collect them within this time they will\n"
       "will be destroyed.\n\n   The parcel clerk, " +
       loc + " Post Office.", 0, 0 );
  return 1;
}
varargs int do_deposit( object *obs, string name, int show_sender ) {
  int ret;
  int total_cost;
  object* total_obs;
  object ob;
  total_obs = obs;
  foreach (ob in obs) {
     total_obs += deep_inventory(ob);
  }
  if (sizeof(total_obs) > 20) {
     add_failed_mess("You are depositing too many items.  The maximum is "
                     "20.\n");
     return -6;
  }
  total_cost = cost * sizeof(total_obs);
  if ( this_player()->query_value_in( where ) < total_cost )  {
    add_failed_mess("You do not have enough money to deposit these "
                    "items, you need " +
                    MONEY_HAND->money_value_string(total_cost,
                            query_property("place")) + ".\n");
    return -1;
  }
  if ( lower_case(name) == this_player()->query_name() ) {
    add_failed_mess("You cannot deposit things for yourself!\n");
    return -3;
  }
  ret = deposit_parcel(obs, name, show_sender);
  switch (ret) {
  case 0 :
  case -1 :
  case -2 :
     return ret;
  case -3 :
    add_failed_mess("You cannot deposit things for yourself!\n");
    return -3;
  case -4 :
    add_failed_mess("You are not allowed to deposit parcels.\n");
    return -4;
  case -5 :
    add_failed_mess(upper_case(name)+" is not allowed to recieve parcels.\n");
    return -5;
  case 1 :
     this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
                                total_cost, where ), where );
     return 1;
  }
  return ret;
}
int do_collect() {
  string this_player_name;
  this_player_name = lower_case(this_player()->query_name());
  if( PLAYER_MULTIPLAYER_HANDLER->member_denied_parcel(this_player_name) ) {
    add_failed_mess("You are not allowed to collect things.\n");
    return 0;
  }
  if ( !MAIL_PARCEL_HANDLER->collect( this_player()->query_name(), loc,
                        (shelf) ? shelf : this_object(), 0 ) ) {
    return 0;
  }
  return 1;
}
void set_shelf( object ob ) {
    shelf = ob;
}
object query_shelf() {
    return shelf;
}

==================================================
FILE: room/player_housing.c
==================================================

#include <dirs.h>
#include <housing.h>
#include <login_handler.h>
#include <player_handler.h>
inherit "/std/room/basic_room";
inherit "/std/room/inherit/player_housing";
void create() {
  add_help_file("player_housing");
  do_setup++;
  basic_room::create();
  player_housing::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  seteuid("Room");
  add_property("no burial", 1);
  add_property("no teleport", 1);
}
string query_long() {
  return player_housing::query_long();
}
int add_exit(string direc, mixed dest, string type) {
  int tmp;
  tmp = ::add_exit(direc, dest, type);
  setup_exit(direc, 1);
  return tmp;
}
string query_address() {
   return HOUSING->query_address(file_name(this_object()));
}
string process_non_living(object *int_non_livings, int start) {
  object *not_positioned;
  not_positioned = player_housing::my_process_non_living(int_non_livings);
  return ::process_non_living(not_positioned, start);
}
void init() {
  player_housing::init();
  basic_room::init();
}
void event_exit(object ob, string message, object to) {
  player_housing::event_exit(ob, message, to);
}
int query_keep_room_loaded() {
  player_housing::query_keep_room_loaded();
}
void dest_me() {
  player_housing::dest_me();
  basic_room::dest_me();
}
int test_remove(object thing, int flag, mixed dest) {
  object thief;
  mixed *stuff;
  if(!basic_room::test_remove(thing, flag, dest))
    return 0;
  thief = this_player();
  if(!thief)
    return player_housing::test_remove(thing, flag, dest);
  if(thief->query_caster())
    thief = find_player(thief->query_caster());
  else if(thief->query_owner())
    thief = thief->query_owner();
  stuff = thing->query_property("dropped");
  if(thief &&
     test_save(thing) && PLAYER_HANDLER->test_user(query_owner()) &&
     !this_object()->test_occupier(thief->query_name()) &&
     (!stuff || stuff[0] != thief->query_name())) {
    log_file("HOUSING_THEFT", "%s: %s stole %s from %s in %s\n",
             ctime( time() )[4..18], (string)thief->query_short(),
             thing->query_short(),
             (string)query_owner(), file_name());
    event(this_object(), "theft", thief, this_object(), ({ thing }));
  }
  return player_housing::test_remove(thing, flag, dest);
}
int test_add( object ob, int flag) {
  int retval;
  retval = basic_room::test_add(ob, flag);
  if(retval)
    retval = player_housing::test_add(ob, flag);
  return retval;
}

==================================================
FILE: room/player_housing_outside.c
==================================================

#include <dirs.h>
#include <housing.h>
#include <login_handler.h>
#include <player.h>
inherit "/std/room/outside";
inherit "/std/room/inherit/player_housing";
void create() {
  add_help_file("player_housing");
  do_setup++;
  outside::create();
  player_housing::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  seteuid("Room");
  add_property("no burial", 1);
}
string query_long() {
  return player_housing::query_long();
}
string query_owner() {
   return HOUSING->query_owner(base_name(this_object()));
}
int add_exit(string direc, mixed dest, string type) {
  int tmp;
  tmp = ::add_exit(direc, dest, type);
  setup_exit(direc, 0);
  return tmp;
}
string process_non_living(object *int_non_livings, int start) {
  object *not_positioned;
  not_positioned = player_housing::my_process_non_living(int_non_livings);
  return ::process_non_living(not_positioned, start);
}
void init() {
  player_housing::init();
  outside::init();
}
void event_exit(object ob, string message, object to) {
  outside::event_exit(ob, message, to);
  player_housing::event_exit(ob, message, to);
}
int query_keep_room_loaded() { return 1; }
void dest_me() {
  player_housing::dest_me();
  outside::dest_me();
}
int test_remove(object thing, int flag, mixed dest) {
  object thief;
  mixed *stuff;
  if(!outside::test_remove(thing, flag, dest))
    return 0;
  thief = this_player();
  if(!thief)
    return player_housing::test_remove(thing, flag, dest);
  if(thief->query_caster())
    thief = find_player(thief->query_caster());
  else if(thief->query_owner())
    thief = thief->query_owner();
  stuff = thing->query_property("dropped");
  if(thief &&
     test_save(thing) &&
     !test_occupier(thief->query_name()) &&
     (!stuff || stuff[0] != thief->query_name())) {
    log_file("HOUSING_THEFT", "%s: %s stole %s from %s in %s\n",
             ctime( time() )[4..18], (string)thief->query_short(),
             thing->query_short(),
             (string)query_owner(), file_name());
    event(this_object(), "theft", thief, this_object(), ({ thing }));
  }
  return player_housing::test_remove(thing, flag, dest);
}
int test_add( object ob, int flag) {
  int retval;
  retval = outside::test_add(ob, flag);
  if(retval)
    retval = player_housing::test_add(ob, flag);
  return retval;
}

==================================================
FILE: room/rooftop.c
==================================================

#include <tasks.h>
#define TOO_SOON "too soon to proceed from rooftop"
inherit "/std/room/outside";
#define DEBUG
#define ROCK "other.movement.climbing.rock"
#define ROPE "other.movement.climbing.rope"
void   set_death_reason( string );
void   set_fall_damage( string, int );
mixed  query_fall_damage( string );
int    calc_fall_damage( string );
void   set_weak_roof( int, string );
void   set_slope( int, string, string );
string process_string( string, mapping );
string process_mess( string, object, string );
mapping  damages;
string * damage_types;
int      roof_max_weight;
int      gradient;
string   weak_roof_dest;
string   slope_dest;
string   place;
string   death_reason;
string * weak_messages;
string * slope_messages;
string * step_messages;
string * jump_tm_messages;
string * jump_success_messages;
string * jump_failure_messages;
string * ghost_fall_messages;
string * item_slope_messages;
string * corpse_slope_messages;
mapping jump_info;
mapping translations;
void init() {
   ::init();
   add_command( "jump", "<word'direction'>",
     (: this_object()->do_roofjump( $4[0] ) :) );
}
void create() {
   do_setup++;
   ::create();
   do_setup--;
   weak_messages = ({
     "The roof collapses! This is going to be painful...\n",
     "$short$ crashes down through a weak spot in the roof.",
     "$short$ comes crashing to the ground, landing in a rain of debris.",
     "You hear an ominous creak.\n"
   });
   slope_messages = ({
     "The roof is too steep for you to stand on! It's time to make friends "
       "with the floor...\n",
     "$short$ gets in touch with gravity and slides over the edge of the "
       "roof.",
     "$short$ comes crashing to the ground, landing in a heap."
   });
   step_messages = ({
     "You step off the edge of the roof into midair.\n",
     "$short$ steps off the edge of the roof and plummets earthwards.",
     "$short$ comes crashing to the ground, landing in a heap."
   });
   jump_tm_messages = ({
     "You leap more gracefully through the air.",
     "You feel more able to leap tall buildings in a single bound.",
     "You jump like a mountain goat."
   });
   jump_success_messages = ({
     "You launch yourself off the edge of the roof and land gracefully on "
       "the other side.\n",
     "$short$ jumps gracefully across the gap to the $dir$.",
     "$short$ jumps in from across the gap to the $opp_dir$."
   });
   jump_failure_messages = ({
     "You launch yourself off the edge of the roof!\nUnfortunately you "
       "misjudge the distance and plummet earthwards. This is going to "
       "hurt...\n",
     "$short$ jumps off to the $dir$, but misjudges and plummets "
       "earthwards.",
     "$short$ plummets to the ground, landing in a heap."
   });
   ghost_fall_messages = ({
      "You find your consciousness drifting earthwards.\n",
      "$the_short$ drifts earthwards.",
      "$the_short$ drifts in from above, looking somewhat dazed."
   });
   item_slope_messages = ({
     "$the_short$ tumbles over the edge and plummets to the ground.\n",
     "Hearing a noise, you look up just as $a_short$ falls off the edge "
       "of the roof and hits the ground.\n"
   });
   corpse_slope_messages = ({
     "$the_short$ tumbles over the edge and plummets to the ground with "
       "a sickening thud.\n",
     "Hearing a noise, you look up just as $the_short$ tumbles over the "
       "edge of the roof and hits the ground with a sickening thud.\n"
   });
   damages = ([ ]);
   damage_types = ({ "weak", "slope", "step", "jump" });
   translations = ([ ]);
   jump_info = ([ ]);
   this_object()->setup();
}
void set_weak_messages( string player, string from, string to, string warn ) {
   weak_messages = ({ player, from, to, warn });
}
void set_slope_messages( string player, string from, string to ) {
   slope_messages = ({ player, from, to });
}
void set_step_messages( string player, string from, string to ) {
   step_messages = ({ player, from, to });
}
void set_jump_tm_messages( string * messages ) {
   jump_success_messages = messages;
}
void set_jump_success_messages( string player, string from, string to ) {
   jump_success_messages = ({ player, from, to });
}
void set_jump_failure_messages( string player, string from, string to ) {
   jump_failure_messages = ({ player, from, to });
}
void set_ghost_fall_messages( string player, string from, string to ) {
   ghost_fall_messages = ({ player, from, to });
}
void set_corpse_slope_messages( string from, string to ) {
  corpse_slope_messages = ({ from, to });
}
void set_item_slope_messages( string from, string to ) {
   item_slope_messages = ({ from, to });
}
void set_fall_damage( string type, int damage ) {
   if( damage < 0 )
      damage = -damage;
   if( type == "all" ) {
      foreach( type in damage_types )
         damages[type] = damage;
   } else if( member_array( type, damage_types ) >= 0 ) {
      damages[type] = damage;
   } else
      return;
}
mixed query_fall_damage( string type ) {
   if( type == "all" )
      return damages;
   else
      return damages[type];
}
int calc_fall_damage( string type ) {
   if( type == "all" )
      return 0;
   return query_fall_damage( type ) + random( query_fall_damage( type ) );
}
void set_weak_roof( int maxweight, string dest ) {
   roof_max_weight = maxweight;
   weak_roof_dest = dest;
}
void set_slope( int angle, string loc, string dest ) {
   gradient = ( angle * 100 ) / 90;
   place = loc;
   slope_dest = dest;
}
int set_jump( mixed dir, string dest, string fall_dest, int distance ) {
   string * dirs;
   mixed foo;
   string bar;
   if( stringp( dir ) ) {
      dirs = ({ dir });
   } else if( arrayp(dir) ) {
      foreach( foo in dir )
         if( !stringp( foo ) )
            return 0;
      dirs = sort_array( dir, 1 );
   }
   foreach( bar in dir )
      if( !undefinedp( translations[bar] ) )
         return -1;
   jump_info[ dir[0] ] = ({ dest, fall_dest, distance });
   foreach( bar in dir )
      translations[bar] = dir[0];
   if( !query_exit( dir[0] ) )
      add_exit( dir[0], dest, "roof" );
   modify_exit( dir[0], ({
     "closed", 1,
     "function", (: this_object()->silly_move( $1, $2, $3,
       jump_info[ translations[$1] ][1], "step", step_messages ) :),
     "look", "You'll have to jump across to see what's on the other side."
   }) );
   return 1;
}
int silly_move( string verb, object ob, string special, mixed dest,
  string dam_type, string * messages ) {
   this_object()->do_fall( ob, dest, dam_type, messages, 0 );
   return notify_fail( "" );
}
void do_fall( object obj, mixed dest, string dam_type, string * messages,
  string dir ) {
   int damage, i;
   object destob;
   obj->remove_property( TOO_SOON );
   for( i = 0; i < sizeof( messages ); i++ )
      messages[i] = process_mess( messages[i], obj, dir );
   if( stringp( dest ) ) {
      if( !(destob = load_object( dest ) ) ) {
         tell_object( obj, "Cannot find " + dest + ".\n"
           "Moving you to the void - Please contact a creator.\n" );
         obj->move_with_look( "/room/void", "Poof. $N appears.\n",
           "$N plummets earthwards.\n" );
         return;
      }
   } else if( objectp( dest ) ) {
      destob = dest;
   } else {
      return;
   }
   tell_object( obj, messages[0] );
   obj->move_with_look( destob, messages[2], messages[1] );
   if( obj->query_property( "dead" ) )
      return;
   damage = calc_fall_damage( dam_type );
   if( damage >= obj->query_hp() ) {
      set_death_reason( "plummeting from the rooftops" );
      obj->attack_by( this_object() );
      obj->do_death();
   } else
      obj->adjust_hp( -damage );
}
void event_enter( object obj, object from ) {
   int totalweight, objectweight, i;
   float encum, diff;
   int fall;
   object * contents;
   object destination;
   if( !obj ) return;
   if( obj->query_property( "demon" )
     || obj->query_property( "floating" ) ) {
      return;
   }
   obj->add_property( TOO_SOON, 1, 5 );
   if( roof_max_weight ) {
      contents = all_inventory( this_object() );
      for( i = 0; i < sizeof(contents); i++ ) {
         objectweight = contents[i]->query_weight();
         objectweight += contents[i]->query_loc_weight();
         totalweight += objectweight;
#ifdef DEBUG
         debug_printf( "event_enter: Total weight of %s is %d units.\n",
           obj->query_name(), objectweight );
#endif
      }
#ifdef DEBUG
      debug_printf( "event_enter: The current weight on this roof is %d "
        "units. Max weight is set to %d.\n", totalweight, roof_max_weight );
#endif
      if( totalweight > roof_max_weight ) {
         fall = 1;
         tell_room( environment( obj ), weak_messages[3] );
         if( !(destination = load_object( weak_roof_dest ) ) ) {
            tell_room( this_object(), "Error loading room "
              + weak_roof_dest + ", moving you to the void.\n"
              "Please contact a creator.\n" );
            for( i = 0; i < sizeof(contents); i++ )
               contents[i]->move_with_look( "/room/void" );
            return;
         }
         for( i = 0; i < sizeof(contents); i++ ) {
            call_out( "do_fall", 1, contents[i], destination, "weak",
              weak_messages, 0 );
         }
         return;
      }
   }
   if( gradient && !fall ) {
      if( living( obj ) ) {
         if( ( obj->query_property( "dead" ) )
           || !( obj->query_max_weight() ) ) {
            call_out( "do_fall", 1, obj, slope_dest, "step",
              ghost_fall_messages );
            return;
         }
         encum = ( 100 * to_float( obj->query_loc_weight() ) )
           / to_float( obj->query_max_weight() );
         diff = to_int( sin( ( 3.1415926536 / 180.0 ) * gradient )
           * ( encum * 10 ) );
         call_out( "gradient_check", 1, obj, slope_dest,
           to_int( diff + ( gradient * 2 ) ) );
      } else {
         if( member_array( obj->query_name(),
           ({ "death", "binky" }) ) >= 0 )
            return;
         if( gradient > 3 ) {
            if( obj->query_corpse() ) {
               obj->move( slope_dest,
                 process_mess( corpse_slope_messages[1], obj, 0 ),
                 process_mess( corpse_slope_messages[0], obj, 0 ) );
            } else {
               obj->move( slope_dest,
                 process_mess( item_slope_messages[1], obj, 0 ),
                 process_mess( item_slope_messages[0], obj, 0 ) );
            }
         }
      }
      return;
   }
   obj->remove_property( TOO_SOON );
}
void gradient_check( object obj, string destination, int diff ) {
   object destob;
#ifdef DEBUG
   debug_printf( "gradient_check( %s, \"%s\", %d )",
     obj->query_name(), destination, diff );
#endif
   obj->remove_property( TOO_SOON );
   switch( TASKER->perform_task( obj, ROCK, diff + 1, TM_FIXED ) ) {
   case AWARD:
      tell_object( obj, "%^YELLOW%^" + ({
        "You balance more confidently on the " + place + ".",
        "Climbing becomes easier."
      })[ random(2) ] + "%^RESET%^\n" );
   case SUCCEED:
      tell_object( obj, "The " + place + " is steep, but you manage "
        "not to fall.\n" );
      break;
   case FAIL:
      if( !( destob = load_object( destination ) ) ) {
         tell_object( obj, "Error loading room " + destination +
           ", moving you to the void.\nPlease contact a creator.\n" );
         obj->move_with_look( "/room/void" );
      } else
         do_fall( obj, destob, "slope", slope_messages, 0 );
      break;
   default:
      write( "Gnaaaaaaaaaaaah! You should not be getting this message.  "
        "Please contact a creator.\n" );
      break;
   }
}
int do_roofjump( string dir ){
   mixed * info;
   int distance;
   float weight, max_weight;
   object destination, fall_destination;
   string key;
   if( !( key = translations[dir] ) || !( info = jump_info[key] ) ) {
      add_failed_mess( "You can't jump there!\n" );
      return 0;
   }
   if( !(destination = load_object( info[0] ) ) ) {
      add_failed_mess( "Error! The file " + info[0] + " does not exist "
        "or does not load. Please contact a creator.\n" );
      return 0;
   }
   if( !(fall_destination = load_object( info[1] ) ) ) {
      add_failed_mess( "Error! The file " + info[1] + " does not exist "
        "or does not load. Please contact a creator.\n" );
      return 0;
   }
   distance = info[2];
   if( distance ) {
      weight = to_float( this_player()->query_loc_weight() );
      max_weight = to_float( this_player()->query_max_weight() );
      distance *= to_float( ( to_float(weight) * 7) /
           to_float(max_weight) ) + 15;
      switch( TASKER->perform_task( this_player(), ROCK, distance, TM_FIXED ) ) {
         case AWARD:
            write( "%^YELLOW%^"
              + jump_tm_messages[ random( sizeof( jump_tm_messages ) ) ]
              + "%^RESET%^\n" );
         case SUCCEED:
            write( process_mess( jump_success_messages[0], this_player(), dir ) );
            this_player()->move_with_look( destination,
              process_mess( jump_success_messages[2], this_player(), dir ),
              process_mess( jump_success_messages[1], this_player(), dir ), );
            break;
         case FAIL:
            write( process_mess( jump_failure_messages[0], this_player(), dir ) );
            do_fall( this_player(), fall_destination, "jump",
              jump_failure_messages, dir );
            break;
         default:
            write( "Oh dear. Something is broken. Please inform a "
              "creator.\n" );
      }
      return 1;
   }
}
string query_death_reason() {
   call_out( (: death_reason = 0 :), 2 );
   if( death_reason )
      return "/global/player"->convert_message( death_reason );
   return "a rooftop (" + file_name( this_object() )
     + ") with an incorrectly set death message";
}
void set_death_reason( string str ) {
   death_reason = str;
}
string process_string( string str, mapping transforms ) {
   string foo, bar;
   foreach( foo, bar in transforms )
      if( bar ) str = replace_string( str, foo, bar );
   return "/global/player"->convert_message( str );
}
string process_mess( string str, object ob, string direction ) {
   string opp_dir;
   string * directions = ({ "north", "northeast", "east", "southeast",
     "south", "southwest", "west", "northwest" });
   if( !str || ( str == "" ) )
      return "";
   if( stringp( direction ) ) {
      if( member_array( direction, directions ) < 0 ) {
         opp_dir = 0;
      } else {
         opp_dir =
           directions[ ( member_array( direction, directions ) + 4 ) % 8 ];
      }
   }
   str = process_string( str, ([
     "$dir$"       : direction,
     "$opp_dir$"   : opp_dir,
     "$short$"     : ob->query_short(),
     "$poss$"      : ob->query_possessive(),
     "$pronoun$"   : ob->query_pronoun(),
     "$obj$"       : ob->query_objective(),
     "$a_short$"   : ob->a_short(),
     "$the_short$" : ob->the_short(),
     "$one_short$" : ob->one_short()
   ]) );
   return implode( explode( str, ". " ),
     (: "$C$" + $1 + ". " + "$C$" + $2 :) );
}
int test_remove( object ob, int flag, mixed dest ) {
   if( !living(ob) ) {
      return ::test_remove( ob, flag, dest );
   }
   if( objectp(dest) )
      dest = file_name(dest);
   if( !stringp(dest) || dest == "/room/rubbish" )
      return 1;
   if( ob->query_property( TOO_SOON ) ) {
      tell_object( ob, "You haven't quite caught your balance yet.\n" );
      notify_fail( "" );
      return 0;
   }
   return ::test_remove( ob, flag, dest );
}

==================================================
FILE: room/room_rental.c
==================================================

#include <room/room_rental.h>
inherit "/std/room/basic_room";
inherit ROOM_RENTAL_INHERIT_ROOM;
void create() {
   basic_room::create();
}
void init() {
   basic_room::init();
}

==================================================
FILE: room/room_rental_office.c
==================================================

#include <room/room_rental.h>
inherit "/std/room/basic_room";
inherit ROOM_RENTAL_INHERIT_OFFICE;
void create() {
   basic_room::create();
   room_rental_office::create();
}
void init() {
   basic_room::init();
   room_rental_office::init();
}

==================================================
FILE: room/room_save.c
==================================================

#include <move_failures.h>
#include <player.h>
inherit "/std/room/basic_room";
inherit "/std/room/inherit/room_save";
inherit "/std/basic/auto_load";
void create() {
   do_setup++;
   basic_room::create();
   room_save::create();
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
     this_object()->reset();
   }
}
int test_remove(object thing, int flag, mixed dest) {
  int result;
  result = basic_room::test_remove(thing, flag, dest);
  if(result) {
    room_save::test_remove(thing, flag, dest);
  }
  return result;
}
int test_add( object ob, int flag) {
  room_save::test_add(ob, flag);
  return basic_room::test_add(ob, flag);
}
#ifdef DONT_USE
void dest_me() {
  room_save::dest_me();
  basic_room::dest_me();
}
#endif

==================================================
FILE: room/safe_room.c
==================================================

#include <armoury.h>
#define TP this_player()
#define SHAD "/std/shadows/misc/davidshad"
inherit "/std/room/basic_room";
object keeper;
void create() {
    do_setup++;
    ::create();
    do_setup--;
    set_light(90);
    add_property("warmth", 3);
    add_property( "los", "closed" );
    add_property("calm room", 1);
    if(!do_setup) {
      this_object()->setup();
      this_object()->reset();
  }
}
int trap_action( string str ) {
    string st1;
    if( sscanf( str,"%s %s",str,st1 ) );
    switch(str) {
    case "ambush":
    case "attack":
    case "backstab":
    case "behead":
    case "bury":
    case "cast":
    case "circle":
    case "conflagrate":
    case "crush":
    case "decompose":
    case "drag":
    case "eat":
    case "ensumpf":
    case "fade":
    case "filch":
    case "fire":
    case "fuel":
    case "guard":
    case "hedgehog":
    case "hide":
    case "hurl":
    case "iai":
    case "inhume":
    case "inpale":
    case "invoke":
    case "kill":
    case "mock":
    case "order":
    case "tempt":
    case "palm":
    case "perform":
    case "plant":
    case "pyroscipate":
    case "scathe":
    case "scribe":
    case "scry":
    case "shroud":
    case "slip":
    case "snatch":
    case "sneak":
    case "steal":
    case "recharge":
    case "rifle":
    case "throw":
    case "twist":
    case "use":
    case "ventisepelate":
    case "zap":
    case "skick":
    case "sburn":
    case "slap":
    case "spunch":
    case "berserk":
        tell_object( this_player(), "You feel too peaceful to do that.\n");
        return 1;
    default:
        return 0;
    }
}
void event_exit(object ob, string message, object to);
void init() {
    this_player()->remove_hide_invis( "hiding" );
    clone_object( SHAD )->setup_shadow(TP);
    this_player()->command_override( (: trap_action :) );
    this_player()->add_command( "dream", this_object(), "" );
    this_player()->add_command( "rest", this_object(), "" );
    ::init();
}
void set_keeper(object ob) { keeper = ob; }
void event_exit(object ob, string message, object to){
    ob->dest_shadow();
}
void event_enter( object ob, string stringy, string stringy2 ) {
    object thing;
    if ( base_name( ob ) == "/d/guilds/priests/summoned/dust_devil" ) {
        ob->do_leave();
    }
    if ( base_name( ob ) == "/d/am/chars/herrena" ) {
            int *enums = ob->effects_matching( "fighting.combat" );
            foreach( int i in enums ) ob->delete_effect( i );
    }
    foreach( thing in all_inventory(ob)) {
        if( base_name( thing ) == "/d/sur/items/crystal_ball" )
            thing->do_rub();
    }
    if ( living( ob ) )
        call_out("make_calm", 1, ob );
        call_out( "stop_sneaking", 1, ob );
}
int do_rest( string str ) {
    this_player()->adjust_hp( 4 );
    this_player()->adjust_gp( -( 2 + random( 4 ) ) );
    this_player()->adjust_social_points( -( 2 + random(8)));
    tell_object( this_player() ,
      "You rest on one of the pillows, and feel much "
      "better for it.\n");
    return 1;
}
int do_dream( string str ) {
    this_player()->adjust_hp( 4 );
    this_player()->adjust_gp( -( 2 + random( 4 ) ) );
    this_player()->adjust_social_points( -( 2 + random(8)));
    tell_object( this_player(), ({
      "You dream of a world where cabbages roam free.\n",
      "You have a vision of penguin waiters serving giraffes in white leisure "
         "suits.\n",
      "You dream of imp-powered sheep leaping over fences.\n",
      "You dream uneasily of creators with cuddly teddy-bears.\n",
      "Visions of sugar-plums dance through your head.\n",
      "You count lemons as you try to get to sleep.\n" }) [ random(4) ] );
    return 1;
}
void event_fight_in_progress( object ob1, object ob2 ) {
    if ( keeper ) { tell_room ( this_object(),
    keeper->the_short() + " hums a peaceful tune softly and calm fils the "
      "room." ); }
    ob2->stop_all_fight();
    ob1->stop_all_fight();
}
void make_calm( object blue ) {
    int *enums;
    int wibble;
    enums = blue->effects_matching("fighting.combat");
    if ( sizeof( enums ) ) {
        foreach( wibble in enums ) { blue->delete_effect( wibble ); }
        keeper->do_command("smile "+ blue->query_name() );
        tell_object( blue, "You feel a lot calmer.\n");
    }
}
void stop_sneaking( object sneaker ) {
    int *enums;
    int wibble;
    enums = sneaker->effects_matching( "covert.sneaking" );
    if ( sizeof( enums ) ) {
        foreach( wibble in enums ) { sneaker->delete_effect( wibble ); }
        keeper->do_command("hug "+ sneaker->query_name() );
        tell_object( sneaker, "You feel less sneaky.\n");
    }
}

==================================================
FILE: room/stable.c
==================================================

#include <money.h>
#include <player.h>
inherit "/std/room/basic_room";
void load_me();
class stable {
   int date_in;
   int last_paid;
   string name;
   mixed* save_info;
}
private nosave string _directory;
private nosave int _start_cost;
private nosave int _cost_per_week;
private nosave mapping _stable_cache;
private nosave string* _stable_types;
private mapping _accounts;
int do_list();
int do_stable( object *obs );
int do_deposit( string mon );
int do_return( string num );
void create() {
  _start_cost = 400;
  _cost_per_week = 400;
  _stable_cache = ([ ]);
  _accounts = ([ ]);
  _stable_types = ({ });
  add_help_file( "stable" );
  ::create();
}
void init() {
  add_command( "list", "", (: do_list() :) );
  add_command( "stable", "<indirect:object:here>", (: do_stable($1) :) );
  add_command( "deposit", "<string'money'>", (: do_deposit($4[0]) :) );
  add_command( "return", "<string'horse num'>", (: do_return($4[0]) :) );
}
void set_save_directory( string directory ) {
  if ( directory[<1] != '/' )
    directory += "/";
  _directory = directory;
  load_me();
}
string query_save_directory() {
  return _directory;
}
void set_start_cost( int start_cost ) {
  _start_cost = start_cost;
}
int query_start_cost() {
  return _start_cost;
}
void set_cost_per_week( int cost_per_week ) {
  _cost_per_week = cost_per_week;
}
int query_cost_per_week() {
  return _cost_per_week;
}
void save_me() {
  unguarded( (: save_object(_directory + "main_account") :) );
}
void load_me() {
  unguarded( (: restore_object(_directory + "main_account", 1) :) );
}
int query_balance( string name ) {
  return _accounts[name];
}
void set_balance( string name, int amt ) {
  _accounts[name] = amt;
   save_me();
}
void adjust_balance( string name, int amt ) {
  _accounts[name] += amt;
  save_me();
}
int query_player_money( object player, string place ) {
  return player->query_value_in( place ) +
         query_balance( player->query_name() );
}
void remove_player_money( object player, int amt, string place ) {
  int balance;
  balance  = query_balance( player->query_name() );
  if ( balance < 0 ) {
     amt += -balance;
     balance = 0;
  } else {
    if ( amt <= balance ) {
      balance -= amt;
      amt = 0;
    } else {
      amt -= balance;
      balance = 0;
    }
  }
  if ( amt > 0 ) {
    player->pay_money( MONEY_HAND->create_money_array( amt, place ),
                       place );
   }
   set_balance( player->query_name(), balance );
}
void add_stable_type( string type ) {
  if ( member_array( type, _stable_types ) == -1) {
    _stable_types += ({ type });
  }
}
string* query_stable_types() {
  return _stable_types;
}
int can_stable_type( string type ) {
  if ( member_array( type, _stable_types ) != -1 ) {
    return 1;
  }
  return 0;
}
protected class stable* query_stable( string name ) {
  string str;
  if ( !_stable_cache[name] && file_size( _directory + name + ".o" ) > 0 ) {
    str = read_file( _directory + name + ".o" );
    if ( str ) {
      _stable_cache[name] = restore_variable( str );
    }
  }
  return _stable_cache[name];
}
protected void set_stable( string name, class stable* value ) {
  _stable_cache[name] = value;
  if ( !value || !sizeof( value ) ) {
    unguarded( (: rm(_directory + $(name) + ".o") :) );
  } else {
    unguarded( (: write_file( _directory + $(name) + ".o",
                  save_variable( $(value) ), 1 ) :) );
  }
}
int query_stabling_cost( string name, int pos ) {
  class stable* bing;
  bing = query_stable( name );
  if ( pos < 0 || pos >= sizeof( bing ) ) {
    return 0;
  }
  return ( ( time() - bing[pos]->last_paid ) * _cost_per_week ) /
           (7 * 24 * 60 * 60);
}
int add_to_stable( string name, object* horses ) {
  class stable* bing;
  class stable womble;
  object horse;
  bing = query_stable( name );
  if ( !bing ) {
    bing = ({ });
  }
  foreach ( horse in horses ) {
    womble = new( class stable );
    womble->date_in = time();
    womble->last_paid = time();
    womble->name = horse->query_short();
    womble->save_info = AUTO_LOAD_OB->create_auto_load( ({ horse }) );
    bing += ({ womble });
  }
  set_stable( name, bing );
  horses->move("/room/rubbish");
  return 1;
}
void print_ok_message( object me, object* horses ) {
  write( "You stable " + query_multiple_short( horses ) + " into " +
         the_short() + ".\n" );
  say( this_player()->the_short() + " stables " +
       query_multiple_short( horses ) + " into " + the_short() + ".\n" );
}
int do_stable( object *obs ) {
  class stable* bing;
  int cost;
  object horse;
  object *ok;
  string place;
  place = query_property( "place" );
  if ( !place )
    place = "default";
  bing = query_stable( this_player()->query_name() );
  ok = ({ });
  foreach ( horse in obs ) {
    if ( !can_stable_type( horse->query_transport_type() ) ) {
      add_failed_mess( "$I is not able to be stabled here.\n", ({ horse }) );
    } else if ( horse->query_owner() != this_player()->query_name() ) {
      add_failed_mess( "You do not own $I and therefore cannot stable them.\n",
                       ({ horse }) );
    } else {
      ok += ({ horse });
      cost += _start_cost;
    }
  }
  if ( sizeof( ok ) ) {
    if ( query_player_money( this_player(), place ) < cost ) {
      add_failed_mess( "You do not have enough money to stable $I, you "
                       "need " + MONEY_HAND->money_value_string(cost, place) +
                       ".\n", ok );
      return 0;
    }
    write( "It will cost you " + MONEY_HAND->money_value_string( cost, place ) +
           " to stable " + query_multiple_short( ok ) + " here and " +
           MONEY_HAND->money_value_string( _cost_per_week, place ) +
           " for each horse for every week it stays here.\nDo you accept "
           "this? " );
    input_to( "check_stable", 0, cost, ok, place );
    add_succeeded_mess( "" );
  }
  return sizeof( ok );
}
protected void check_stable( string mess, int cost, object *ok, string place ) {
  if ( strlen( mess ) && lower_case( mess )[0] == 'y' ) {
    if ( query_player_money( this_player(), place ) < cost ) {
      write("Oops!  You seem to have run out of money.\n" );
    } else {
      remove_player_money( this_player(), cost, place );
      add_to_stable( this_player()->query_name(), ok );
      print_ok_message( this_player(), ok );
    }
  } else {
    write( "Ok, abandoning the check in.\n" );
  }
}
int do_list() {
  class stable* bing;
  int i;
  int cost;
  int balance;
  string debt;
  string place;
  place = query_property( "place" );
  if ( !place )
    place = "default";
  bing = query_stable( this_player()->query_name() );
  balance = query_balance( this_player()->query_name() );
  if ( !bing || !sizeof( bing ) ) {
    if( !balance ) {
      add_failed_mess( "You do not have any horses stabled here.\n" );
      return 0;
    }
    write( "You have a balance of " +
           MONEY_HAND->money_value_string( cost, place ) +
           " in your stabling account.\n" );
    return 1;
  }
  for ( i = 0; i < sizeof( bing ); i++ ) {
    cost = query_stabling_cost( this_player()->query_name(), i );
    if ( cost == 0 ) {
      debt = "paid up";
    } else if (cost < 0) {
      debt = "in credit " + MONEY_HAND->money_value_string( -cost, place );
    } else {
      debt = "in debt " + MONEY_HAND->money_value_string( cost, place );
    }
    write( sprintf( " %c) %s; %s\n ", 'A' + i, bing[i]->name, debt ) );
  }
  if ( balance > 0 ) {
    write( "You have a stable balance of " +
           MONEY_HAND->money_value_string( balance, place ) + ".\n" );
  } else if ( balance < 0 ) {
    write( "You have a stable balance of " +
           MONEY_HAND->money_value_string( balance, place ) + " in debt.\n" );
  } else {
    write( "You do not have a balance at this time.\n" );
  }
  add_succeeded_mess( ({ "", "$N checks out $p horses.\n" }) );
  return 1;
}
int do_return( string num ) {
  class stable* bing;
  int pos;
  int cost;
  object* horses;
  string place;
  place = query_property( "place" );
  if ( !place )
    place = "default";
  bing = query_stable( this_player()->query_name() );
  if ( !sizeof( bing ) ) {
    add_failed_mess( "You do not have any horses stabled here.\n" );
    return 0;
  }
  num = lower_case( num );
  pos = num[0] - 'a';
  if ( pos < 0 || pos > sizeof( bing ) ) {
    add_failed_mess( "You must return a horse in the range 'A' - '" +
                     sprintf( "%c", 'A' + sizeof( bing ) - 1 ) + "'.\n" );
    return 0;
  }
  cost = query_stabling_cost( this_player()->query_name(), pos );
  if ( query_player_money( this_player(), place ) < cost ) {
    add_failed_mess( "You do not have enough money to return this horse "
                     "you need " +
                     MONEY_HAND->money_value_string( cost, place ) +
                     ".\n" );
    return 0;
  }
  horses = AUTO_LOAD_OB->load_auto_load_to_array( bing[pos]->save_info );
  horses->move( this_object() );
  horses->set_owner( this_player()->query_name() );
  bing = bing[0..pos - 1] + bing[pos + 1..];
  set_stable( this_player()->query_name(), bing );
  if ( cost > 0 ) {
    remove_player_money( this_player(), cost, place );
  }
  add_succeeded_mess( "$N $V $I from " + the_short() + ".\n", horses );
  return 1;
}
int do_deposit( string mon ) {
  string place;
  mixed money;
  int amt;
  place = query_property( "place" );
  if ( !place )
    place = "default";
  if ( undefinedp( query_balance( this_player()->query_name() ) ) ) {
    add_failed_mess( "You do not currently have a balance here.\n" );
    return 0;
  }
  money = MONEY_HAND->parse_money( mon, this_player(), place );
  if ( intp( money ) ) {
    switch ( money ) {
      case NO_MATCH :
        add_failed_mess( "You do not have '" + mon + "'.\n" );
        return 0;
      case NO_MONEY :
        add_failed_mess( "You can only deposit money.\n" );
        return 0;
      default :
        add_failed_mess( "You can only deposit legal tender.\n" );
        return 0;
    }
  }
  amt = money->query_value_in( place );
  if ( place != "default" ) {
    amt += money->query_value_in( "default" );
  }
  adjust_balance( this_player()->query_name(), amt );
  add_succeeded_mess( ({ "You deposit " +
                      MONEY_HAND->money_string( money->query_money_array() ) +
                      " into your stable account.\n",
                      "$N deposits some money into $p account.\n" }) );
  return 1;
}

==================================================
FILE: room/voting_room.c
==================================================

#include <board.h>
#define DEFAULT_VOTE_DURATION 2600*24*7
inherit "/std/room/basic_room";
inherit "/std/room/inherit/voting_room";
void create() {
  voting_room::create();
  do_setup++;
  add_help_file("voting_room");
  basic_room::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  seteuid("Room");
}
void init() {
   basic_room::init();
   voting_room::init();
}

==================================================
FILE: room/water_inside.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/room/basic/water";
private int _setting_water_light = 0;
void init() {
  water::init();
  basic_room::init();
}
int is_allowed_position(string poss) {
  return water::is_allowed_position(poss);
}
mixed *query_default_position(object ob) {
  return water::query_default_position(ob);
}
int add_exit(string direc, mixed dest, string type) {
  int retval = basic_room::add_exit(direc, dest, type);
  water::add_exit(direc, dest, type);
  return retval;
}
int query_light() {
  update_water_light();
  if (query_surface()) {
    return ::query_light();
  }
  return ::query_light()*query_clarity()/100;
}
int set_water_light(int number) {
  _setting_water_light = 1;
  set_light(number);
  _setting_water_light = 0;
}
int adjust_light(int number) {
  if (!_setting_water_light) {
    set_use_surface_light(0);
  }
  return ::adjust_light(number);
}
mixed query_property(string tag) {
  if ("location" == tag && !query_surface()) {
    return "underwater";
  }
  return ::query_property(tag);
}
int attack_speed() { return 5; }

==================================================
FILE: room/water_outside.c
==================================================

inherit "/std/room/outside";
inherit "/std/room/basic/water";
private int _setting_water_light = 0;
void init() {
  water::init();
  outside::init();
}
int is_allowed_position(string poss) {
  return water::is_allowed_position(poss);
}
mixed *query_default_position(object ob) {
  return water::query_default_position(ob);
}
int add_exit(string direc, mixed dest, string type) {
  int retval = outside::add_exit(direc, dest, type);
  water::add_exit(direc, dest, type);
  return retval;
}
int query_light() {
  update_water_light();
  if (query_surface()) {
    return ::query_light();
  }
  return ::query_light()*query_clarity()/100;
}
int set_water_light(int number) {
  _setting_water_light = 1;
  set_light(number);
  _setting_water_light = 0;
}
int adjust_light(int number) {
  if (!_setting_water_light) {
    set_use_surface_light(0);
  }
  return ::adjust_light(number);
}
mixed query_property(string tag) {
  if ("location" == tag && !query_surface()) {
    return "underwater";
  }
  return ::query_property(tag);
}
int attack_speed() { return 5; }

==================================================
FILE: room/basic/chatter.c
==================================================

#include <room.h>
nosave int _off;
nosave object _room;
nosave mixed *_chats;
void set_chat_min_max( int min,int  max ) {
  if (_chats) {
    _chats[0]=min;
    _chats[1]=max;
  }
}
void setup_chatter( object my_room,  mixed *chat_args ) {
   _off = 1;
   _room = my_room;
   if( !arrayp( chat_args ) ) {
      chat_args = ({ chat_args });
   }
   _chats = chat_args + ({ 0 });
}
void dest_me() {
  destruct( this_object() );
}
void make_chat() {
   int saying;
   mixed stuff;
   if(!_room) {
     dest_me();
     return;
   }
   if ( !_chats || sizeof(_chats) < 3 || !sizeof(_chats[2]) ||
        !sizeof( filter( all_inventory( _room ), (: interactive($1) :),
         this_object() ) ) ) {
      _off = 1;
      return;
   }
   saying = random( sizeof( _chats[ 2 ] ) );
   if ( saying == _chats[ 3 ] ) {
     saying = ( saying + 1 ) % sizeof( _chats[ 2 ] );
   }
   _chats[ 3 ] = saying;
   stuff = _chats[ 2 ][ saying ];
   if (stringp(stuff)) {
      if ( stuff[ 0 ] == '#' ) {
         call_other( _room, stuff[ 1 .. 99 ] );
      } else {
         tell_room( _room, _chats[ 2 ][ saying ] +"\n" );
      }
   }
   if ( intp( stuff ) ) {
      map( filter( all_inventory( _room ), (: $1 && living( $1 )
         && $1->query_creator() :) ), (: tell_creator( $1, "Warning: "
         "room_chat array contains integer argument. Did you mix up "
         "the syntax with load_chat()'s?\n" ) :) );
   }
   ROOM_HANDLER->add_chatter( this_object(), _chats[ 0 ] +
         random( _chats[ 1 ] - _chats[ 0 ] + 1 ) );
}
void check_chat() {
   if ( !_off || !pointerp( _chats ) ) {
      return;
   }
   _off = 0;
   ROOM_HANDLER->add_chatter( this_object(), ( _chats[ 0 ] +
         random( _chats[ 1 ] - _chats[ 0 ] + 1 ) ) / 2 );
}
void add_room_chats( string *new_chats ) {
   if (sizeof(new_chats)) {
     if (sizeof(_chats[2])) {
        _chats[2] = _chats[2] + new_chats;
     } else {
        _chats[2]= new_chats;
     }
   }
}
void remove_room_chats( string *dead_chats ) {
   if (sizeof(_chats[2])) {
      _chats[2] = _chats[2] - dead_chats;
   }
   if (!sizeof(_chats[2])) {
      destruct(this_object());
   }
}
mixed *query_room_chats() { return _chats; }
int clean_up( int parent ) {
  if (parent)
    return 0;
  if (!_room || _room->query_chatter() != this_object())
    dest_me();
}

==================================================
FILE: room/basic/door.c
==================================================

#include <door.h>
#include <room.h>
#include <parse_command.h>
#include <dirs.h>
#define BEVERB ({ " is ", " are " })
#define PRONOUN ({ "it", "them" })
#define CLOSED        2
#define CLOSED_LOCKED 3
inherit "/std/basic/enchant";
inherit "/std/basic/hide_invis";
inherit "/std/basic/property";
inherit "/std/basic/close_lock";
inherit "/std/basic/trap";
inherit "/std/basic/id_match";
private int how_many;
private int one_way;
private string _lock_owner;
private string shrt;
private string lng;
private string my_id;
private string other_id;
private string *name;
private string *adjs;
private string *plu;
private string dest;
private string _door_name;
private object key;
private object my_room;
void create() {
   hide_invis::create();
   property::create();
   close_lock::create();
   name = ({ "door" });
   lng = "It's just a door.\n";
   shrt = "door";
   adjs = ({ });
   plu = ({ });
   add_property( "determinate", "the " );
   set_unlocked();
}
int query_how_many() {
    return how_many;
}
void set_how_many( int number ) {
  if(number)
    add_property("group object", 1);
  else
    remove_property("group object");
  how_many = number;
}
int query_one_way() {
    return one_way;
}
void set_one_way( int number ) {
    one_way = number;
}
string query_short() {
    return shrt;
}
void set_short( string words ) {
   string *bits;
   shrt = words;
   bits = explode( words, " " );
   bits += implode( map( bits, (: explode( $1, "-" ) :) ), (: $1 + $2 :) );
   bits = uniq_array( bits );
   name += ({ bits[ sizeof( bits ) - 1 ] });
   adjs += bits[ 0 .. sizeof( bits ) - 2 ];
   plu += ({ pluralize( bits[ sizeof( bits ) - 1 ] ) });
}
string query_door_name() {
    return _door_name;
}
void set_door_name( string word ) {
    _door_name = word;
}
void set_lock_owner(string owner) {
    _lock_owner = owner;
}
mixed query_lock_owner() {
    return _lock_owner;
}
string query_long() { return lng; }
void set_long( string word ) {lng = word;}
string query_my_id() { return my_id; }
void set_my_id( string word ) { my_id = word; }
string query_other_id() { return other_id; }
void set_other_id( string word ) { other_id = word; }
string *query_name() { return name; }
string *query_adjs() { return adjs; }
string *query_plu() { return plu; }
string query_dest() { return dest; }
void set_dest( string word ) { dest = word; }
object query_my_room() { return my_room; }
void init() {
   add_command( "knock", "on <direct:object>" );
   close_lock::init();
}
string query_determinate() { return "the "; }
string short() { return query_short(); }
string a_short() { return "$a_short:"+ file_name( this_object() ) +"$"; }
string one_short() { return "$one_short:"+ file_name( this_object() ) +"$"; }
string poss_short() { return "$poss_short:"+ file_name( this_object() ) +"$"; }
string the_short() { return "$the_short:"+ file_name( this_object() ) +"$"; }
string pretty_short() { return query_short(); }
string query_plural() { return pluralize( query_short() ); }
string pretty_plural() { return pluralize( query_short() ); }
string long() {
  return lng + ( ( this_player()->query_see_octarine() ) ? enchant_string() :
                 "" ) + long_status();
}
int drop() { return 1; }
int get() { return 1; }
void setup_door( string word, object mine, string his, mixed *args,
                 string type) {
   string *bits;
   my_id = word;
   my_room = mine;
   dest = his;
   switch(type) {
   case "window":
     if(word != "window")
       shrt = word + " window";
     else
       shrt = word;
     lng = "It's just the " + shrt + ".\n";
     name = ({ shrt, "window" });
     plu = ({ "windows" });
     break;
   default:
     if ( word[ 0 .. 5 ] == "enter " ) {
       if(SHORTEN[word[6..100]])
         name += ({ SHORTEN[word[6..100]] });
       shrt = word[ 6 .. 100 ] +" door";
       lng = "It's just the " + shrt + ".\n";
       name += ({ shrt });
       if(!args[D_SECRET ])
         plu = ({ "doors" });
     } else {
       if(SHORTEN[word])
         name += ({ SHORTEN[word] });
       shrt = word +" door";
       lng = "It's just the " + shrt + ".\n";
       name += ({ shrt });
       if(!args[D_SECRET ])
         plu = ({ "doors" });
     }
     break;
   }
   bits = explode( word, " " );
   name += ({ bits[ sizeof( bits ) - 1 ] });
   adjs +=  bits;
   plu += ({ pluralize( bits[ sizeof( bits ) - 1 ] ) });
   (!args[ D_CLOSED ]) ? set_closed() : set_open();
   (args[ D_LOCKED ]) ? set_locked() : set_unlocked();
   set_key(args[ D_KEY ] );
   set_difficulty(args[ D_DIFFICULTY ] );
   if ( args[ D_SECRET ] )
      add_hide_invis( "secret", 0, 200, 0 );
   if(sizeof(args) >= D_TRANSPARENT && args[D_TRANSPARENT])
     set_transparent();
   set_door_name(args[D_NAME]);
}
void add_alias( string word ) {
   string *bits;
   bits = explode( word, " " );
   name += ({ bits[ sizeof( bits ) - 1 ] });
   adjs +=  bits[ 0 .. sizeof( bits ) - 2 ];
   plu += ({ pluralize( bits[ sizeof( bits ) - 1 ] ) });
}
int force_other() {
  string door_name, direc;
  if(!find_object(dest)) {
    if(!load_object(dest))
      return 0;
    dest->query_door( my_room, _door_name );
  }
  if(!other_id) {
    door_name = my_room->call_door(my_id, "query_door_name");
    direc = dest->query_door(my_room, door_name);
    my_room->modify_exit( my_id, ({ "other", direc }) );
  }
  if(!other_id)
    return 0;
  return 1;
}
int do_open() {
  if(!::do_open())
    return 0;
  if(!force_other() && !one_way) {
    set_closed();
    return 0;
  }
  if(((string)my_room->query_property( "location" ) == "outside") &&
     (member_array(find_object(ROOM_HANDLER), previous_object(-1)) == -1))
    ROOM_HANDLER->add_door( this_object() );
  if(!one_way && find_object(dest)) {
    dest->modify_exit(other_id, ({ "closed", 0 }));
    if(this_player())
      dest->tell_door(other_id, (string)this_player()->a_short() +
                      " opens the $D.\n", 0);
    else
      dest->tell_door(other_id, "Someone opens the $D.\n", 0);
  }
  return 1;
}
int do_close() {
  if(!::do_close())
    return 0;
  if(!force_other() && !one_way) {
    set_open();
    return 0;
  }
  if(!one_way && find_object(dest)) {
    if(query_autolock()) {
      dest->modify_exit( other_id, ({ "closed", 1, "locked", 1 }) );
      dest->tell_door( other_id, "Someone closes the $D which "
                       "lock$s as $p close$s.\n", 0 );
    } else {
      dest->modify_exit( other_id, ({ "closed", 1 }) );
      dest->tell_door( other_id, "Someone closes the $D.\n", 0 );
    }
  }
  return 1;
}
int do_lock(object *obs) {
  if(!::do_lock(obs))
    return 0;
  if(!force_other() && !one_way) {
    set_unlocked();
    return 0;
  }
  if(!one_way && find_object(dest)) {
    dest->modify_exit(other_id, ({ "locked", 1 }));
    dest->tell_door(other_id, "Someone locks the $D.\n", 0);
  }
  return 1;
}
int do_unlock(object *obs) {
  if(!::do_unlock(obs))
    return 0;
  if(!force_other() && !one_way) {
    set_locked();
    return 0;
  }
  if(!one_way && find_object(dest)) {
    dest->modify_exit(other_id, ({ "locked", 0 }));
    dest->tell_door(other_id, "Someone unlocks the $D.\n", 0);
  }
  return 1;
}
int do_knock() {
  if(this_player()->query_property("dead"))
    return 0;
  if ( !other_id && !one_way ) {
    ROOM_HANDLER->check_door( ({ my_room, my_id }) );
    if ( !other_id )
      return 0;
  }
  if ( one_way )
    return 1;
  if(query_transparent())
    dest->tell_door(other_id, this_player()->a_short() +
                    " knocks on the $D.\n", 0);
  else
    dest->tell_door( other_id, "Someone knocks on the $D.\n", 0 );
  event(find_object(dest), "door_knock", this_player(), other_id);
  return 1;
}
int pick_unlock(object thing) {
  if (stringp(_lock_owner)) {
     if (pk_check(_lock_owner, thing, 1)) {
        return 0;
     }
  }
  if(!::pick_unlock(thing)) {
    return 0;
  }
  if(!force_other() && !one_way ) {
    set_locked();
    return 0;
  }
  if(!one_way && find_object(dest)) {
    dest->modify_exit( other_id, ({ "locked", 0 }) );
    dest->tell_door( other_id, "Someone unlocks the $D.\n", 0 );
  }
  return 1;
}
int pick_lock( object thing ) {
  if (stringp(_lock_owner)) {
     if (pk_check(_lock_owner, thing, 1)) {
        return 0;
     }
  }
  if(!::pick_lock(thing))
    return 0;
  if(!force_other() && !one_way ) {
    set_unlocked();
    return 0;
  }
  if(!one_way && find_object(dest)) {
    dest->modify_exit( other_id, ({ "locked", 1 }) );
    dest->tell_door( other_id, "Someone locks the $D.\n", 0 );
  }
  return 1;
}
string *parse_command_id_list() {
  return (this_player() ? name + ({ this_player()->find_rel(my_id) }) : name);
}
string *parse_command_adjectiv_id_list() { return adjs; }
string *parse_command_plural_id_list() { return plu; }
object query_parse_id( mixed *arr ) {
   if (arr[P_THING] == 0) {
      return this_object();
   }
   if (arr[P_THING] < 0) {
      arr[P_THING]++;
      if (arr[P_THING] != 0) {
         return 0;
      }
      arr[P_THING] = -10321;
      return this_object();
   }
   arr[P_THING]--;
   if (arr[P_THING] != 0) {
      return this_object();
   }
   arr[P_THING] = -10101;
   return this_object();
}
mixed parse_match_object( string* input,
                          object viewer,
                          class obj_match_context context )
{
   if (input[<1] == "all") {
      return 0;
   }
   return ::parse_match_object(input, viewer, context);
}
void dest_me() {
  destruct( this_object() );
}
void dwep() { destruct( this_object() ); }
void go_away() { call_out("dest_me", 0); }
int move() { return 1; }
int moving_open( object thing ) {
  if(!::do_open())
    return 0;
  if(!force_other() && !one_way) {
    set_closed();
    return 0;
  }
  if(!one_way && find_object(dest)) {
    dest->modify_exit(other_id, ({ "closed", 0 }));
    dest->tell_door(other_id, (string)thing->a_short() + " opens the $D.\n", 0);
  }
  tell_object( thing, "You open the "+ shrt +".\n" );
  tell_room( my_room, (string)thing->the_short() +
             " opens the "+ shrt +".\n", thing );
  return 1;
}
int moving_close( object thing ) {
  if(!::do_close())
    return 0;
  if(!force_other() && !one_way) {
    set_open();
    return 0;
  }
  if(!one_way && find_object(dest))
    if(query_autolock()) {
      dest->modify_exit( other_id, ({ "closed", 1, "locked", 1 }) );
      dest->tell_door(other_id, (string)thing->the_short() +
                      " closes the $D which lock$s as $p close$s.\n", thing );
    } else {
      dest->modify_exit( other_id, ({ "closed", 1 }) );
      if ( thing->short() )
        dest->tell_door( other_id, capitalize( (string)thing->the_short() ) +
                         " closes the $D.\n", thing );
    }
  if(query_autolock()) {
    tell_object( thing, "You close the "+
                 (string)dest->call_door( other_id, "query_short" ) +
                 " which locks as it closes.\n" );
    tell_room( my_room, (string)thing->the_short() +
               " closes the "+ shrt +" which locks as it closes.\n", thing );
  } else {
    tell_object( thing, "You close the "+
                 (string)dest->call_door( other_id, "query_short" ) +".\n" );
    tell_room( my_room, (string)thing->the_short() +
               " closes the "+ shrt +".\n", thing );
  }
  return 1;
}
int moving_unlock(object thing) {
  if(!::do_unlock(all_inventory(thing)))
    return 0;
  if(!one_way && find_object(dest))
    dest->modify_exit(other_id, ({ "locked", 0 }));
  tell_object(thing, "You unlock the "+ shrt +".\n");
  if (thing->short())
    tell_room( my_room, capitalize( (string)thing->the_short() ) +
               " unlocks the "+ shrt +".\n", thing );
  return 1;
}
int moving_lock(object thing) {
  if(!::do_lock(all_inventory(thing)))
    return 0;
  if(!one_way && find_object(dest))
    dest->modify_exit(other_id, ({ "locked", 1 }));
  tell_object( thing, "You lock the "+
               (string)dest->call_door( other_id, "query_short" ) +".\n" );
  if (thing->short())
    dest->tell_door( other_id, capitalize( (string)thing->the_short() ) +
                     " locks the $D.\n", thing );
  return 1;
}
void tell_door(string words, object thing) {
  tell_room(my_room, replace( words, ({
    "$D", shrt, "$p", PRONOUN[how_many], "$s", ({ "s", "" })[how_many] })),
            ({ thing }));
}
mixed *stats() {
  return property::stats() + close_lock::stats() +
         ({ ({ "lock owner", _lock_owner }),
            ({ "other id", other_id }),
            ({ "dest", dest }) });
}
string long_status() {
   string str;
   if (!query_stuck()) {
      if(query_how_many() > 0)
      {
        str = "They are";
      }
      else
      {
        str = "It is";
      }
      switch (query_closed_locked_status()) {
         case CLOSED_LOCKED :
            return str + " closed and locked.\n";
         case CLOSED :
            return str + " closed.\n";
         default :
            return str + " open.\n";
      }
   } else {
      return "";
   }
}

==================================================
FILE: room/basic/graffbase.c
==================================================

#include <language.h>
#define GRAFFITI "graffiti"
#define ETP environment(this_player())
#define TO this_object()
object writing_on;
object old;
string olds;
string query_drawingwith();
int do_check();
int done_check();
string query_drawingwith() { return "something"; }
int do_check() { return 0; }
int done_check() { return 0; }
void init() {
 this_player()->add_command( "scrawl", this_object(), "with charcoal on wall");
 this_player()->add_command( "scrawl", this_object(), "on wall with charcoal");
}
int do_scrawl( object *things ) {
    string language;
    if ( !ETP->query_property( GRAFFITI) ) {
        this_player()->add_failed_mess( this_object(), "You can't scrawl on "+
          "this wall.\n");
        return 0;
    }
    language = (string)this_player()->query_current_language();
    if ( !LANGUAGE_HAND->query_language_written( language ) ) {
        this_player()->add_failed_mess( this_object(), "You can't scrawl on "
           "a wall when you're not using a language that can be used for "
          "scrawling on a wall with.\n",({writing_on}));
        return 0;
    }
    if(( old = present("graffiti",ETP)) && !interactive(old))
    {
        olds = old->query_property("graffiti");
    }
    if ( writing_on ) {
        this_player()->add_failed_mess( this_object(), "The writing "+
          "spot seems to be busy at the moment.\n",
          ({writing_on}));
        return 0;
    }
    this_player()->add_succeeded_mess( this_object(), ({"You start scrawling "+
      "on a wall with some charcoal.\n", "$N starts scrawling on a wall with "
      "some charcoal.\n"}) );
    writing_on = ETP;
    call_out( "begin_writing", 0, this_player() );
    return 1;
}
void begin_writing( object writer ) {
    if ( !writer ) {
        writing_on = 0;
        return;
    }
    writer->do_edit( 0, "end_writing" );
}
void end_writing( string words ) {
    string language;
    string extra;
    if ( !words || ( words == "" ) ) {
        write( "You don't scrawl anything on "+
         "the wall.\n");
        say( (string)this_player()->the_short() +" doesn't "+
          "scrawl anything after all.\n" );
        writing_on = 0;
        return;
    }
    language = (string)this_player()->query_current_language();
    if ( !LANGUAGE_HAND->query_language_written( language ) ) {
        write( "You seem to have changed to using a non-written language.\n" );
        say( (string)this_player()->the_short() +" seems "+
          "linguistically-challenged.\n" );
        writing_on = 0;
        return;
    }
    if ( !writing_on ) {
        write( "You seem to have lost what you were scrawling on.\n" );
        say( (string)this_player()->the_short() +" looks around "+
          "in puzzlement.\n" );
        return;
    }
    if (  writing_on != ETP ) {
        write("The wall seems to have run away from you.\n" );
        say( (string)this_player()->the_short() +" looks like "+
          (string)this_player()->query_pronoun() +"'s lost something.\n" );
        writing_on = 0;
        return;
    }
    if(!stringp(olds)) olds = "";
    words = olds +"\n"+"%^MAGENTA%^Scrawled with rough charcoal, you "
             "read the words:%^RESET%^\n\n"+
    words;
    if(old) old->move("/room/rubbish");
    extra = TO->extra_stuff();
    if(!strlen(extra))extra = "Some disreputable character has scrawled "
        "graffiti over this wall.  You may be able to \"read\" it.\n";
    ETP->add_sign(
      extra,
      words,
      "graffiti",
      ({"graffiti","scrawl"}),
      language
    );
    old = present("graffiti",ETP);
    old->add_property("determinate","some ");
    old->add_property("there","on the wall");
    if(old) old->add_property("graffiti",words);
    write( "As you finish scrawling on the wall, the piece of charcoal "
           "breaks.\n" );
    say( (string)this_player()->the_short() +" finishes scrawling "+
      "on the wall.\n" );
    this_object()->done_check();
    writing_on = 0;
}

==================================================
FILE: room/basic/item.c
==================================================

#define DEBUG 1;
#include <parse_command.h>
#include <obj_parser.h>
#define POSITION_SIZE 2
#define POSITION_DESC 0
#define POSITION_MULT 1
private mixed *_lng;
private string *_shrt;
private string *_adjs;
private string *_plu;
private string *_name;
#ifdef DEBUG
private string _creator_room;
#endif
private mapping _verb;
private mapping _plural;
private mapping _other_things;
private mapping _pattern;
private int *_cur_desc;
private mapping _gather;
private mapping _position_stuff;
private mapping _count;
void init() {
    string name;
    mixed rest;
    foreach (name, rest in _other_things) {
            this_player()->add_command(name, this_object(), _pattern[name]);
    }
}
#ifdef DEBUG
string query_creator_room() { return _creator_room; }
void print_stuff() {
    printf("lng = %O\nshrt = %O\nadjs = %O\nplu = %O\nname = %O\n" +
      "verb = %O\nplural = %O\nother_things = %O\npattern = %O\n" +
      "cur_desc = %O\ngather = %O\n", _lng, _shrt, _adjs, _plu, _name, _verb,
      _plural, _other_things, _pattern, _cur_desc, _gather);
}
#endif
void create() {
#ifdef DEBUG
    _creator_room = file_name(previous_object());
#endif
    _adjs = ({ });
    _lng = ({ "" });
    _shrt = ({ "" });
    _gather = ([ ]);
    _plu = ({ });
    _name = ({ });
    _verb = ([ ]);
    _plural = ([ ]);
    _pattern = ([ ]);
    _cur_desc = ({ });
    _count = ([ ]);
    _other_things = ([ "smell" : 0, "taste" : 0, "read" : 0 ]);
}
int query_visible( object thing ) { return 1; }
string hide_invis_string() { return ""; }
string *query_short_array() {
    string *ret;
    int i;
    ret = ({ });
    foreach (i in _cur_desc) {
        ret += ({ _shrt[i] });
    }
    return ret;
}
string short() {
    return query_multiple_short(query_short_array());
}
string pretty_short() {
    string *ret;
    ret = query_short_array();
    if (sizeof(ret)) {
        return query_multiple_short(ret);
    } else {
        return "something";
    }
}
string a_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:" + add_a( $1 ) + "$" :)), "");
}
string the_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:the " +  $1 + "$" :)), "");
}
string one_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:the " + $1 + "$" :)), "");
}
string poss_short() {
    return implode(map(query_short_array(),
        (: "$mirror_short:the " + $1 + "$" :)), "");
}
string query_read_short() {
    return "$name$";
}
string query_plural() {
    string *ret;
    int i;
    ret = ({ });
    foreach (i in _cur_desc) {
        ret += ({ pluralize(_shrt[i]) });
    }
    return query_multiple_short(ret);
}
string pretty_plural() {
    int i;
    foreach (i in _cur_desc) {
        return pluralize(_shrt[i]);
    }
    return 0;
}
string long( string name, int dark ) {
    int i;
    string *ret;
    ret = ({ });
    foreach (i in _cur_desc) {
        if ( !_lng[ i ] ) {
            continue;
        }
        if (functionp(_lng[ i ])) {
            ret += ({ evaluate(_lng[ i ]) });
        } else {
            ret += ({ _lng[ i ] });
        }
    }
    if ( !sizeof( ret ) ) {
        return "You don't think that the "+name+" is here.\n";
    }
    return implode( evaluate(ret), "\n")+"\n";
}
int *query_cur_desc() { return _cur_desc; }
mapping query_verbs() { return _verb; }
mapping query_plurals() { return _plural; }
string *query_lng() { return _lng; }
string *query_shrt() { return _shrt; }
mixed *query_gather() {
    mixed *g = ({ });
    int i;
    foreach (i in _cur_desc) {
        if (_gather[i]) {
            g += ({ _gather[i] });
        }
    }
    return g;
}
int drop() { return 1; }
int get() { return 1; }
int query_item(string str) { return _verb[str]; }
private void setup_bits_for_item(int index, mixed bits) {
    int i;
    string str;
    mixed pat;
    if (!pointerp(bits)) {
        _lng[index] = bits;
        return ;
    }
    _lng[index] = "You see nothing special.\n";
    for (i = 0; i < sizeof(bits); i += 2) {
        if ((arrayp( bits[i + 1] ) && sizeof( bits[i + 1] ) == 3) ||
          (sizeof( bits[i + 1] ) == 2 && functionp( bits[i + 1][0] ))) {
            pat = bits[i + 1][<1];
            if (!arrayp(pat)) {
                pat = ({ pat });
            }
        }
        else {
            pat = ({ "<direct:object>" });
        }
        if (!pointerp(bits[i])) {
            bits[i] = ({ bits[i] });
        }
        foreach (str in bits[i]) {
            if (str == "long") {
                _lng[index] = bits[i+1];
            } else if (str == "gather") {
                _gather[index] = bits[i+1];
            } else if (str == "item_count")  {
               if (!_count[index])  _count[index] = bits[i + 1];
            } else if (str == "position" ||
              str == "position multiple") {
                if (!_position_stuff)
                    _position_stuff = ([ ]);
                if (!_position_stuff[index]) {
                    _position_stuff[index] = allocate(POSITION_SIZE);
                }
                if (str == "position") {
                    _position_stuff[index][POSITION_DESC] = bits[i + 1];
                } else {
                    _position_stuff[index][POSITION_MULT] = bits[i + 1];
                }
            } else if (!_other_things[str]) {
                _pattern[str] = pat;
                _other_things[str] = ([ index : bits[i+1] ]);
            } else {
                if (member_array(pat, _pattern[str]) == -1) {
                    _pattern[str] += pat - (string *)_pattern[str];
                }
                _other_things[str][index]   = bits[i+1];
            }
        }
    }
}
private void remove_bits_for_item(int index) {
    string str;
    string adj;
    mixed value;
    int frog;
    int bing;
    int i;
    int j;
    map_delete(_gather, index);
    foreach (frog, bing in _gather) {
        if (frog > index) {
            map_delete(_gather, frog);
            _gather[frog - 1] = bing;
        }
    }
    if (_position_stuff) {
        map_delete(_position_stuff, index);
        foreach (frog, bing in _position_stuff) {
            if (frog > index) {
                map_delete(_position_stuff, frog);
                _position_stuff[frog - 1] = bing;
            }
        }
    }
    foreach (str, value in _other_things) {
        if (value) {
            map_delete(value, index);
            if (!sizeof(value)) {
                map_delete(_other_things, str);
                map_delete(_pattern, str);
            } else {
                foreach (frog, bing in value) {
                    if (frog > index) {
                        map_delete(value, frog);
                        value[frog - 1] = bing;
                    }
                }
            }
        }
    }
    foreach (str, value in _verb) {
        for (i = 0; i < sizeof(value); i += 2) {
            if (value[i + 1] > index) {
                value[i + 1] -= 1;
            } else if (value[i + 1] == index) {
                foreach (adj in value[i]) {
                    j = member_array(adj, _adjs);
                    if (j != -1) {
                        _adjs = _adjs[0..i - 1] + _adjs[i + 1..];
                    }
                }
                value = value[0.. i - 1] + value[i + 2..];
                i -= 2;
                j = member_array(str, _name);
                if (j != -1) {
                    _name = _name[0..j - 1] + _name[j + 1..];
                }
            }
        }
        _verb[str] = value;
    }
    foreach (str, value in _plural) {
        for (i = 0; i < sizeof(value); i += 2) {
            if (value[i + 1] > index) {
                value[i + 1] -= 1;
            } else if (value[i + 1] == index) {
                value = value[0.. i - 1] + value[i + 2..];
                i -= 2;
            }
        }
        _plural[str] = value;
    }
}
private void add_name_reference(int index, string name, int no_plural) {
    string *bits;
    string plural;
    string s;
    bits = explode(name, " ");
    s = bits[<1];
    if (member_array(s, _name) == -1) {
        _name += ({ s });
    }
    if (!_verb[s]) {
        _verb[s] = ({ bits[0..<2], index });
    } else {
        _verb[s] += ({ bits[0..<2], index });
    }
    if (!no_plural) {
        plural = pluralize(s);
        if (member_array(plural, _plu) == -1) {
            _plu += ({ plural });
        }
        if (!_plural[plural]) {
            _plural[plural] = ({ bits[0..<2], index });
        } else {
            _plural[plural] += ({ bits[0..<2], index });
        }
    }
    _adjs += bits[0..<2];
}
int setup_item(mixed nam, mixed long, int no_plural) {
    int index;
    string str;
    index = sizeof(_lng);
    if (pointerp(nam)) {
        if (sizeof(nam) > 0) {
            _shrt += ({ nam[0] });
            if (no_plural) {
                _plu += ({ "no plural" });
            } else {
                _plu += ({ pluralize(nam[0]) });
            }
        }
        foreach (str in nam) {
            add_name_reference(index, str, no_plural);
        }
    } else {
        _shrt += ({ nam });
        if (no_plural) {
            _plu += ({ "no plural" });
        } else {
            _plu += ({ pluralize(nam) });
        }
        add_name_reference(index, nam, no_plural);
    }
    _lng += ({ 0 });
    setup_bits_for_item(index, long);
    return index;
}
int modify_item_by_index(int index, mixed long) {
    if (index >= sizeof(_lng)) {
        return 0;
    }
    setup_bits_for_item(index, long);
    return 1;
}
int modify_item_by_name(string str, mixed long) {
    int index;
    index = member_array(str, _shrt);
    if (index == -1) {
        return 0;
    }
    return modify_item_by_index(index, long);
}
int modify_item(mixed str, mixed long) {
    if (stringp(str)) {
        return modify_item_by_name(str, long);
    }
    if (intp(str)) {
        return modify_item_by_index(str, long);
    }
    return 0;
}
int remove_item_by_index(int index) {
    if (index >= sizeof(_lng)) {
        return 0;
    }
    _shrt = _shrt[0..index - 1] + _shrt[index + 1..];
    _adjs = _adjs[0..index - 1] + _adjs[index + 1..];
    _lng = _lng[0..index - 1] + _lng[index + 1..];
    _plu = _plu[0..index - 1] + _plu[index + 1..];
    remove_bits_for_item(index);
}
int remove_item_by_name(string str) {
    int index;
    index = member_array(str, _shrt);
    if (index == -1) {
        return 0;
    }
    return remove_item_by_index(index);
}
int remove_item(mixed str) {
    if (stringp(str)) {
        return remove_item_by_name(str);
    }
    if (intp(str)) {
        return remove_item_by_index(str);
    }
    return 0;
}
string *parse_command_id_list() { return _name; }
string *parse_command_plural_id_list() { return _plu; }
string *parse_command_adjectiv_id_list() { return _adjs; }
object query_parse_id(mixed *arr)
{
    string *bits;
    mixed stuff;
    int i, j, match, all_match;
    bits = explode(arr[P_STR], " ");
    bits -= ({ "a", "an", "the" });
    if (arr[P_THING] == 0)
    {
        stuff = _plural[bits[<1]];
        if (!stuff) {
            stuff = _verb[bits[<1]];
            if (!stuff) {
                return 0;
            }
        }
        _cur_desc = ({ });
        all_match = 0;
        for (j = 0; j < sizeof(stuff); j += 2) {
            match = 1;
            for (i = 0; i < sizeof(bits) - 1; i++) {
                if (member_array(bits[i], stuff[j]) == -1) {
                    match = 0;
                    break;
                }
            }
            if (match) {
                all_match = 1;
                if (member_array(stuff[j+1], _cur_desc) == -1) {
                    _cur_desc += ({ stuff[j+1] });
                }
            }
        }
        if (all_match) {
            return this_object();
        } else {
            return 0;
        }
    }
    if (arr[P_THING] < 0) {
        stuff = _verb[bits[<1]];
        if (!stuff) {
            return 0;
        }
        for (j = 0; j < sizeof(stuff); j += 2) {
            match = 1;
            for (i = 0; i < sizeof(bits) - 1; i++) {
                if (member_array(bits[i], stuff[j]) == -1) {
                    match = 0;
                    break;
                }
            }
            if (++arr[P_THING] != 0) {
                continue;
            }
            if (match) {
                _cur_desc = ({ stuff[j+1] });
                arr[P_THING] = -10321;
                return this_object();
            }
        }
        return 0;
    }
    stuff = _plural[bits[<1]];
    if (!stuff) {
        stuff = _verb[bits[<1]];
        if (!stuff) {
            return 0;
        }
    }
    _cur_desc = ({ });
    for (j = 0; j < sizeof(stuff); j += 2) {
        match = 1;
        for (i=0;i<sizeof(bits)-1;i++) {
            if ( member_array( bits[ i ], stuff[ j ] ) == -1 ) {
                match = 0;
                break;
            }
        }
        if (match) {
            if (member_array(stuff[j+1], _cur_desc) == -1) {
                _cur_desc += ({ stuff[j+1] });
            }
            arr[P_THING]--;
            if (arr[P_THING] <= 0) {
                arr[P_THING] = -10786;
                return this_object();
            }
        }
    }
    return 0;
}
mixed* parse_match_object(string* input,
                          object player,
                          class obj_match_context context) {
   int *stuff;
   mixed *plural;
   mixed *sing;
   string *its, *thems;
   string item;
   int i;
   int j;
   int match;
   int ret;
   if (input[<1] == "here" && sizeof(input) > 1) {
      input = input[0..<2];
   }
   if ( this_object() == context->it &&
        input[<1] == "it" ) {
      sing = ({ });
      its = map(_cur_desc, (: explode(_shrt[$1], " ")[<1] :));
      foreach( item in its ) {
          if ( arrayp( _verb[ item ] ) ) {
             sing += ({ ({ item }), _verb[ item ][ 1 ] });
          }
      }
      plural = ({ });
   } else if( input[<1] == "them" &&
              context->plural &&
              member_array( this_object(), context->plural ) != -1) {
      plural = ({ });
      thems = map(_cur_desc, (: explode(_shrt[$1], " ")[<1] :));
      foreach( item in thems ) {
          if ( arrayp( _verb[ item ] ) ) {
             plural += ({ ({ item }), _verb[ item ][ 1 ] });
          }
      }
      sing = ({ });
   } else {
      plural = _plural[input[<1]];
      sing = _verb[input[<1]];
   }
   if (!sizeof(plural) && !sizeof(sing)) {
      return 0;
   }
   stuff = ({ });
   for (i = 0; i < sizeof(sing); i += 2) {
      match = 1;
      for (j = 0; j < sizeof(input) - 1; j++) {
         if (member_array(input[j], sing[i]) == -1) {
            match = 0;
            break;
         }
      }
      if (match) {
         if (member_array(sing[i+1], stuff) == -1) {
            stuff += ({ sing[i+1] });
            ret |= OBJ_PARSER_MATCH_SINGULAR;
         }
      }
   }
   for (i = 0; i < sizeof(plural); i += 2) {
      match = 1;
      for (j = 0; j < sizeof(input) - 1; j++) {
         if (member_array(input[j], plural[i]) == -1) {
            match = 0;
            break;
         }
      }
      if (match) {
         if (member_array(plural[i+1], stuff) == -1) {
            stuff += ({ plural[i+1] });
            ret |= OBJ_PARSER_MATCH_PLURAL;
         }
      }
   }
   if (sizeof(stuff)) {
       if (context->ordinal) {
          if (context->ordinal > sizeof(stuff)) {
             context->ordinal -= sizeof(stuff);
             return 0;
          }
          context->ignore_rest = 1;
          context->ordinal--;
          _cur_desc = stuff[context->ordinal..context->ordinal];
       } else if (context->number_included) {
          _cur_desc = stuff[0..context->number_included];
          context->number_included -= sizeof(stuff);
          if (context->number_included <= 0) {
             context->ignore_rest = 1;
          }
       } else if (ret & OBJ_PARSER_MATCH_PLURAL) {
          _cur_desc = stuff;
       } else {
          _cur_desc = stuff[0..0];
       }
       return ({ ret, ({ this_object() }) });
   } else {
      return 0;
   }
}
void dest_me() {
    destruct(this_object());
    return ;
}
void dwep() {
    destruct(this_object());
    return ;
}
int move() { return 1; }
int command_control(string command, object *indir, string id_arg,
  string ii_arg, string *args, string pattern) {
    int desc, size, num;
    mixed temp;
    if (!_other_things[command]) {
        return 0;
    }
    size = sizeof(_cur_desc);
    foreach (desc in _cur_desc) {
        temp = _other_things[command][desc];
        if (arrayp(temp)) {
            if (sizeof(temp) == 3 || (sizeof(temp) == 2 && !functionp(temp[0]))) {
                num += call_other(temp[0], temp[1], command, indir, id_arg,
                  ii_arg, args, pattern);
            }
            else {
                if (sizeof(temp) == 2 && functionp(temp[0])) {
                        num += evaluate(temp[0], command, indir, id_arg, ii_arg,
                            args, pattern);
                }
            }
        }
        else {
            if (functionp(temp)) {
                temp = evaluate(temp, command, indir, id_arg, ii_arg, args,
                    pattern);
            }
            if (stringp(temp)) {
                write(temp);
                num++;
                add_succeeded_mess(({ "", "$N $V $D.\n" }));
            }
            else {
                if ( intp( temp ) ) {
                    num += temp;
                }
            }
        }
    }
    return num;
}
mapping query_other_things() { return _other_things; }
mapping query_pattern() { return _pattern; }
string query_position_string(string pos) {
    int i;
    if (!_position_stuff) {
        return 0;
    }
    for (i = 0; i < sizeof(_cur_desc); i++) {
        if (_position_stuff[_cur_desc[i]]) {
            return _position_stuff[_cur_desc[i]][POSITION_DESC];
        }
    }
    return 0;
}
int query_position_multiple(string pos) {
    int i;
    if (!_position_stuff) {
        return 0;
    }
    for (i = 0; i < sizeof(_cur_desc); i++) {
        if (_position_stuff[_cur_desc[i]]) {
            return _position_stuff[_cur_desc[i]][POSITION_MULT];
        }
    }
    return 0;
}
mapping query_position_stuff() { return _position_stuff; }
int query_count()  {
   int i;
   int ret = 0;
   foreach (i in _cur_desc)  {
      ret += evaluate(_count[i]);
   }
   return ret;
}

==================================================
FILE: room/basic/linker.c
==================================================

#include <room.h>
nosave int av_flag, ad_flag, rm_flag;
string d_prep, s_prep, r_name, *rooms;
object room;
void setup_shadow(object thing, string *words, string word1,
  string word2, string word3) {
  shadow(thing, 1);
  room = thing;
  rooms = words;
  if(!word1) {
    d_prep = "into";
  } else {
    d_prep = word1;
  }
  if(!word2) {
    s_prep = "in";
  } else {
    s_prep = word2;
  }
  r_name = word3;
}
void destruct_shadow(object thing) {
  if(thing == this_object()) {
    destruct(this_object());
  } else {
    thing->destruct_shadow(thing);
  }
}
string *query_rooms() {
  return rooms;
}
string query_dynamic_preposition() {
  return d_prep;
}
string query_static_preposition() {
  return s_prep;
}
string query_room_name() {
  return r_name;
}
string area_name() {
  string *bits;
  if(r_name) {
    return r_name;
  }
  bits = explode((string)room->query_short(), " of ");
  if(sizeof(bits) > 1) {
    return bits[ sizeof( bits ) - 1];
  }
  return "the area";
}
string compose_start() {
  if(s_prep == "") {
    return capitalize((string)room->the_short());
  }
  return capitalize(s_prep)+" "+(string)room->the_short();
}
void event_person_say( object person, string start, string rest,
      string language, string accent ) {
   int i;
   if ( start[ 0 .. 3 ] == "the " )
      start = explode( (string)person->a_short(), " " )[ 0 ] +
            start[ 3 .. strlen( start ) - 1 ];
   for ( i = 0; i < sizeof( rooms ); i++ )
      if ( find_object( rooms[ i ] ) )
         all_inventory( find_object( rooms[ i ] ) )->event_person_say( person,
                compose_start() +", "+ start, rest, language, accent );
    room->event_person_say( person, start, rest, language, accent );
}
private string conjugate_verbs(string mess) {
  string *words, verb, part;
  int i;
  if(strsrch(mess, "$s") == -1)
    return mess;
  words = explode( mess, " " );
  for ( i = sizeof( words ) - 1; i > -1; i-- ) {
    if ( ( sscanf( words[ i ], "%s$s%s", verb, part ) == 2 ) &&
         ( ( part[ 0 ] < 97 ) || ( part[ 0 ] > 122 ) ) ) {
      words[ i ] = "$V$0="+ pluralize( verb ) +","+ verb +"$V$"+ part;
    }
    if ( sscanf( words[ i ], "%%%s%%%s", verb, part ) == 3 ) {
      words[ i ] = "$V$0="+ pluralize( verb ) +","+ verb +"$V$"+ part;
    }
  }
  return implode( words, " " );
}
void event_exit(object person, string message, object to) {
  int ad_flag, rm_flag, i;
  string arrive, direc, *exits, link_mess, *link_array;
  room->event_exit(person, message, to);
  if(!message) {
    return;
  }
  arrive = "";
  exits = (string *)room->query_dest_dir();
  for(i = 1; i < sizeof(exits); i += 2) {
    if(to == find_object(exits[i])) {
      direc = exits[i - 1];
      ad_flag = 1;
    }
  }
  if(arrayp(room->query_dest_other())) {
    if(member_array(direc, room->query_dest_other()) != -1) {
      i = member_array(direc, room->query_dest_other());
      link_array = room->query_dest_other()[i + 1][11];
    }
  }
  if(arrayp(link_array)) {
    link_mess = link_array[0];
    link_mess = replace(link_mess, ({
      "$N", person->a_short(),
      "$A", area_name(),
      "$D", direc,
      "$P", query_dynamic_preposition(),
      "$S", query_static_preposition(),}));
    link_mess = conjugate_verbs(link_mess);
  }
  if(link_mess) {
    for(i = 0; i < sizeof(rooms); i++) {
      if(to != find_object(rooms[i])) {
        tell_room(find_object(rooms[i]), link_mess);
      }
    }
    return;
  }
  for(i = 0; i < sizeof(rooms); i++) {
    if(to == find_object(rooms[i])) {
      arrive = (string)to->query_dynamic_preposition()+" "+
        (string)to->the_short();
      rm_flag = 1;
    }
  }
  if(ad_flag) {
    message = (string)person->a_short()+" $V$0=moves,move$V$ "+direc;
    message += " "+arrive;
    if(rm_flag) {
      message += ".\n";
    } else {
      message += "and $V$0=leaves,leave$V$ "+ area_name() +".\n";
    }
  } else {
    message = (string)person->a_short() +" $V$0=teleports,teleport$V$";
    if(rm_flag) {
      message += " "+ arrive +".\n";
    } else {
      message += " out of "+area_name()+".\n";
    }
  }
  for(i = 0; i < sizeof(rooms); i++) {
    if(to != find_object(rooms[i])) {
      tell_room(find_object(rooms[i]), message);
    }
  }
}
void event_enter( object person, string message, object from ) {
  int ad_flag, rm_flag, i;
  string direc, *exits, link_mess, *link_array;
  room->event_enter(person, message, from);
  if(!message || !from) {
    return;
  }
  for(i = 0; i < sizeof(rooms); i++) {
    if(from == find_object(rooms[i])) {
      rm_flag = 1;
    }
  }
  if(rm_flag) {
    return;
  }
  exits = (string *)room->query_dest_dir();
  for(i = 1; i < sizeof(exits); i += 2) {
    if(from == find_object(exits[i])) {
      direc = exits[i - 1];
      ad_flag = 1;
    }
  }
  if(member_array(direc, room->query_dest_other()) != -1) {
    i = member_array(direc, room->query_dest_other());
    link_array = room->query_dest_other()[i + 1][11];
  }
  if(arrayp(link_array)) {
    link_mess = link_array[1];
    link_mess = replace(link_mess, ({
      "$N", person->a_short(),
      "$A", area_name(),
      "$D", direc,
      "$P", query_dynamic_preposition(),
      "$S", query_static_preposition(),}));
    link_mess = conjugate_verbs(link_mess);
  }
  if(link_mess) {
    for(i = 0; i < sizeof(rooms); i++) {
      tell_room(find_object(rooms[i]), link_mess);
    }
    return;
  }
  if(ad_flag) {
    message = (string)person->a_short()+" $V$0=moves,move$V$ into "+
      area_name()+" from the "+direc+".\n";
  } else {
    message = (string)person->a_short()+
      " $V$0=teleports,teleport$V$ into "+area_name() +".\n";
  }
  for(i = 0; i < sizeof(rooms); i++) {
    tell_room(find_object(rooms[i] ), message);
  }
}
int query_linked() { return 1; }

==================================================
FILE: room/basic/multichatter.c
==================================================

#include <room.h>
nosave int off;
nosave object room;
nosave mixed *chats;
void set_chat_min_max( int min,int  max ) {
  if (chats) {
    chats[0]=min;
    chats[1]=max;
  }
}
void setup_chatter( object my_room,  mixed *chat_args ) {
   off = 1;
   room = my_room;
   if (sizeof(chats)) chats += chat_args + ({0,0});
   else chats = chat_args + ({0,0});
}
void dest_me() {
  destruct( this_object() );
}
int query_multichatter() { return 1; }
int check_interactive( object thing ) { return interactive( thing ); }
void make_chat() {
  int saying;
  string stuff;
  int set,nextt,t;
  if (!sizeof( filter_array( all_inventory( room ), "check_interactive",
        this_object() ) ) ) {
    off = 1;
    return;
  }
  nextt=2147483647;
  t=time();
  for (set=0;set<sizeof(chats);set+=5) {
    if (sizeof(chats[set+2])) {
      if (t>=chats[set+4]) {
        saying = random( sizeof( chats[ set+2 ] ) );
        if ( saying == chats[ set+3 ] )
        saying = ( saying + 1 ) % sizeof( chats[ set+2 ] );
        chats[ set+3 ] = saying;
        stuff = chats[ set+2 ][ saying ];
        if ( stuff[ 0 ] == '#' )
          call_other( room, stuff[ 1 .. 99 ] );
        else
          tell_room( room, chats[ set+2 ][ saying ] +"\n" );
        chats[ set+4 ]=time()+chats[ set ]
            +random(chats[ set+1 ] - chats[ set ] + 1)-4;
      }
      if (chats[ set+4 ]<nextt) nextt=chats[ set+4 ];
    }
  }
  if (nextt!=2147483647) {
    if ((nextt+=4-t)<5) nextt=5;
    ROOM_HANDLER->add_chatter( this_object(), nextt );
  }
}
void check_chat() {
  int set,t,nextt;
  if ( !off || !pointerp( chats ) )
      return;
  off = 0;
  t=time();
  nextt=2147483647;
  for (set=0; set<sizeof(chats); set+=5) {
    if (t>=chats[set+4]+chats[set]) chats[set+4]=t+random(chats[set+1]);
    if (chats[set+4]<nextt) nextt=chats[set+4];
  }
  if ((nextt+=4-t)<5) nextt=5;
  ROOM_HANDLER->add_chatter( this_object(), nextt );
}
void add_room_chats( string *new_chats ) {
   if (sizeof(new_chats)) {
     if (sizeof(chats[2])) chats[2] = chats[2] + new_chats;
     else chats[2]= new_chats;
   }
}
void remove_room_chats( string *dead_chats ) {
  int set;
  mixed *new_chats;
  new_chats=({ });
  for (set=0;set<sizeof(chats);set+=5) {
    if (sizeof(chats[set+2])) chats[set+2] = chats[set+2] - dead_chats;
    if (set==0 || sizeof(chats[set+2]))
       new_chats=new_chats+chats[(set)..(set+4)];
  }
  chats=new_chats;
}
mixed *query_room_chats() { return chats; }
int clean_up( int parent ) {
  if (parent) {
    return 0;
  }
  if (!room) dest_me();
}

==================================================
FILE: room/basic/multiroom_situation_changer.c
==================================================

#include <am_time.h>
#include <situations.h>
#define RANDOM(a,b) ("/obj/handlers/random_num.c"->random(a,b))
#define MIN_DURATION  1
#define SECTOCHECK    15
#define INSTALLDELAY  15
#define MAXROOMS      30
nosave mapping roominfo;
nosave mixed *rooms;
nosave mapping sitdata;
int query_status() { return 1; }
int *query_current_situations(object room)
{
  if (!roominfo[file_name(room)]) return 0;
  return (roominfo[file_name(room)])[0];
}
void dest_me() {
  destruct(this_object());
}
void add_situation(int num, function *func, string startmess, string endmess,
                   string extralookstring, string *chats, mixed *add_items ) {
  if (!sizeof(sitdata))
    sitdata= ([ num :
              ({ startmess, endmess, extralookstring, chats, add_items, func }) ]);
  else
    sitdata+= ([ num :
               ({ startmess, endmess, extralookstring, chats, add_items, func }) ]);
}
void start_situation(int num, int do_start_mess, object room) {
  mixed *sdata;
  string *chats;
  mixed item,*items;
  int *currentsits;
  string *els;
  object chatter;
  if (!(sdata=sitdata[num]) || !room) return;
  if (!roominfo[file_name(room)]) roominfo[file_name(room)]=
                 ({ 0,0,0,0,60,120,1 });
  currentsits=(roominfo[file_name(room)])[0];
  els=(roominfo[file_name(room)])[1];
  if (!currentsits) currentsits=({ num });
  else currentsits=currentsits+({ num });
  if (sizeof(sdata[2])) {
    if (els && sizeof(els)) els+=({ sdata[2] });
    else {
      els=({ sdata[2] });
      room->add_extra_look(this_object());
    }
  }
  if (do_start_mess && sizeof(sdata[0]))
    tell_room(room, sdata[0]+"\n");
  chats=sdata[3];
  if (chats && sizeof(chats)) {
    if (!(chatter=room->query_chatter())) {
      room->room_chat( ({ (roominfo[file_name(room)])[4],(roominfo[file_name(room)])[5], chats }) );
      chatter=room->query_chatter();
      chatter->check_chat();
    }
    else chatter->add_room_chats(chats);
  }
  items=sdata[4];
  if (sizeof(items)) {
    foreach(item in items) room->add_item(item[0],item[1]);
  }
  if (sdata[5]) {
    if (functionp(sdata[5])) (*(sdata[5]))(num,do_start_mess);
    else if (arrayp(sdata[5]) && functionp((sdata[5])[0]))
      (*((sdata[5])[0]))(num,do_start_mess);
  }
  (roominfo[file_name(room)])[0]=currentsits;
  (roominfo[file_name(room)])[1]=els;
}
void end_situation(int num, object room) {
  mixed *sdata;
  string *chats;
  mixed item,*items;
  int *currentsits;
  string *els;
  object chatter;
  if (!(sdata=sitdata[num]) || !room) return;
  if (!roominfo[file_name(room)]) return;
  currentsits=(roominfo[file_name(room)])[0];
  els=(roominfo[file_name(room)])[1];
  if (currentsits) currentsits=currentsits-({ num });
  if (els && sizeof(sdata[2])) {
    els-=({ sdata[2] });
    if (!sizeof(els)) room->remove_extra_look(this_object());
  }
  chats=sdata[3];
  if (chats && sizeof(chats) && (chatter=room->query_chatter())) {
    chatter->remove_room_chats(chats);
  }
  items=sdata[4];
  if (sizeof(items)) {
    foreach(item in items) room->remove_item(item[0],item[1]);
  }
  if (sizeof(sdata[1]))
    tell_room(room,sdata[1]+"\n");
  if (sdata[5]) {
    if (arrayp(sdata[5]) && functionp((sdata[5])[1]))
      (*((sdata[5])[1]))(num);
  }
  (roominfo[file_name(room)])[0]=currentsits;
  (roominfo[file_name(room)])[1]=els;
}
void manage_situations(object room) {
  mixed *sit;
  int num,t,it,cnt,possible;
  int *currentsits,*newsits,*changes;
  int ttmp,tstep,offset,awake;
  mixed data;
  if (!room || !(data=roominfo[file_name(room)])) return;
  if (!sizeof(filter_array( all_inventory( room ),(: interactive($1) :)))) {
    (roominfo[file_name(room)])[6]=0;
    return;
  }
  currentsits=data[0];
  offset=data[2];
  awake=data[6];
  t=time()+offset;
  newsits=({});
  tstep=2147483647;
  cnt=0;
  foreach(sit in data[3]) {
    cnt++;
    ttmp=sit[1];
    it=t/ttmp;
    possible=0;
    if (sit[2]) {
      if (functionp(sit[2])) possible=(*(sit[2]))();
      else possible=sit[2];
      possible=
	(possible&(1<<((AM_TIME_HANDLER)->query_am_hour(it*ttmp-offset))))
	&&
	(RANDOM(1000,it*1147483647+cnt*2047483243) < sit[3]);
    }
    if (possible) {
      if (arrayp(sit[0])) {
	num=(sit[0]) [((t % ttmp)*sizeof(sit[0]))/ttmp];
	ttmp=ttmp/sizeof(sit[0]);
      }
      else num=sit[0];
      if (member_array(num,newsits)==-1) newsits=newsits+({ num });
    }
    if (ttmp<tstep) tstep=ttmp;
  }
  if (currentsits && sizeof(currentsits)) {
    changes=currentsits-newsits;
    if (sizeof(changes)) foreach(num in changes) {
      if (awake) call_out("end_situation",random(INSTALLDELAY),
        num,room);
      else end_situation(num,room);
    }
    changes=newsits-currentsits;
    }
  else changes=newsits;
  if (sizeof(changes)) foreach(num in changes) {
    if (awake) call_out("start_situation",random(INSTALLDELAY),
       num,awake,room);
    else start_situation(num,awake,room);
  }
  if ((tstep/=SECTOCHECK)>=MAXROOMS) tstep=MAXROOMS-1;
  if (!rooms[tstep]) rooms[tstep]=({ room });
  else rooms[tstep]=rooms[tstep]+({ room });
  (roominfo[file_name(room)])[6]=1;
}
void manage_rooms_situations() {
  object room,*current_rooms;
  current_rooms = rooms[ 0 ];
  rooms[ 0 .. <2 ] = rooms[ 1 .. <1 ];
  rooms[ <1 ] = 0;
  call_out("manage_rooms_situations",SECTOCHECK);
  if ( !pointerp( current_rooms ) ) return;
  foreach ( room in current_rooms ) manage_situations(room);
}
void check_situations(object room) {
  if (room && roominfo[file_name(room)]
    && !((roominfo[file_name(room)])[6])
    && interactive(this_player())) manage_situations(room);
}
void automate_situations(mixed *chatargs, int xval, int yval, mixed *edata,
  object room) {
  mixed sit;
  mixed *sittiming;
  int offset;
  offset=xval*38547+yval*1232444311;
  if ( pointerp(chatargs[2]) && sizeof(chatargs[2])) {
    room->room_chat( chatargs );
  }
  if (sizeof(edata)) {
    foreach(sit in edata) {
      if (sit[1]<MIN_DURATION) {
        write("Invalid situation duration: "+sit[1]+"\n");
        return;
      }
      sit[1]*=60;
      if (!sittiming) sittiming=({ sit });
      else sittiming=sittiming+({ sit });
    }
  }
  roominfo[file_name(room)]=({  0,0, offset, sittiming,
       chatargs[0], chatargs[1], 0 });
  manage_situations(room);
}
void shutdown_situations(object room) {
  int num, *currentsits;
  currentsits=(roominfo[file_name(room)])[0];
  if (currentsits && sizeof(currentsits)) {
    foreach(num in currentsits) end_situation(num, room);
  }
}
string extra_look(object room) {
  string *els;
  if (!roominfo[file_name(room)]) return "";
  els=(roominfo[file_name(room)])[1];
  if (!els || !sizeof(els)) {
    return "";
  }
  return implode(els,"  ")+"\n";
}
void create() {
   rooms = allocate( MAXROOMS );
   manage_rooms_situations();
   roominfo= ([ ]);
}
object *query_rooms() { return rooms; }

==================================================
FILE: room/basic/npcroom.c
==================================================

#define FLAG 0
#define DELAY 1
#define CLONE 2
#define MESS 3
#define REMOVABLE 0
#define FIXED 1
#define UNIQUE 2
nosave mixed  *reset_definitions;
nosave object *reset_objects;
void add_cloned_object( int flag, int delay, mixed clone_info,
                       string entry_mess ) {
   if ( !sizeof( reset_definitions ) )
      reset_definitions = ({ ({ flag, delay, clone_info, entry_mess }) });
   else
      reset_definitions += ({ ({ flag, delay, clone_info, entry_mess }) });
}
mixed *query_cloned_objects() {
   return reset_objects + ({ });
}
mixed *query_cloned_definitions() {
   return reset_definitions + ({ });
}
private object make_clone( mixed func ) {
   if ( stringp( func ) ) {
      return clone_object( func );
   } else if ( functionp( func ) ) {
      return evaluate( func );
   } else
      return 0;
}
private void make_object( int i ) {
   switch ( reset_definitions[ i ][ FLAG ] ) {
    case REMOVABLE:
    case FIXED:
      reset_objects[ i ] = make_clone( reset_definitions[ i ][ CLONE ] );
      reset_objects[ i ]->move( this_object(),
            reset_definitions[ i ][ MESS ] );
      break;
    case UNIQUE:
      if ( !stringp( reset_definitions[ i ][ CLONE ] ) )
         return;
      reset_definitions[ i ][ CLONE ]->move( this_object(),
            reset_definitions[ i ][ MESS ] );
      reset_objects[ i ] = find_object( reset_definitions[ i ][ CLONE ] );
   }
}
void reset() {
   int i;
   if ( !sizeof( reset_definitions ) )
      return;
   if ( !sizeof( reset_objects ) )
      reset_objects = allocate( sizeof( reset_definitions ) );
   for ( i = sizeof( reset_definitions ); i--; ) {
      switch ( reset_definitions[ i ][ FLAG ] ) {
       case REMOVABLE:
         if ( !reset_objects[ i ] ||
             ( environment( reset_objects[ i ] ) != this_object() ) ) {
            if ( reset_definitions[ i ][ DELAY ] >= 0 )
               call_out( "make_object", reset_definitions[ i ][ DELAY ], i );
            else
               make_object( i );
         }
         break;
       case FIXED:
       case UNIQUE:
         if ( !reset_objects[ i ] ) {
            if ( reset_definitions[ i ][ DELAY ] >= 0 )
               call_out( "make_object", reset_definitions[ i ][ DELAY ], i );
            else
               make_object( i );
         }
      }
   }
}

==================================================
FILE: room/basic/situation_changer.c
==================================================

#include <am_time.h>
#include <situations.h>
#define RANDOM(a,b) ("/obj/handlers/random_num.c"->random(a,b))
class situation_timing {
  mixed label;
  mixed duration;
  mixed when;
  int chance;
  int *endat;
  mixed background;
  mixed category;
  int it;
  mapping it_data;
}
nosave int offset;
nosave string *els;
nosave mixed *currentsits,*autosits;
nosave mapping sitdata;
nosave mapping sitwords;
nosave class situation_timing *sittiming;
nosave int chatmin=60,chatmax=120;
nosave object ownerroom;
nosave int automate=0;
nosave mixed cco;
varargs mixed change_situation( mixed label, mixed duration,
  mixed words, mixed handle );
object set_room(object room_o) {
  ownerroom=room_o;
  return this_object();
}
object query_room() { return ownerroom; }
void choose_words( mixed label, mixed choice )
{
  int i;
  class situation sit;
  string *wc;
  sit = sitdata[ label ];
  if (sizeof(sit->random_words)) {
    if (!sitwords) sitwords= ([ ]);
    if (intp(choice)) {
      wc=({ });
      for (i=0;i<sizeof(sit->random_words);i++) {
        wc+=({ "#"+(i+1),
          ((sit->random_words)[i])[
          RANDOM(sizeof((sit->random_words)[i]),choice+i*3347483647)] });
      }
      sitwords[label] = wc;
    }
    else
      sitwords[label] = choice;
  }
}
string *insert_words_chats(class situation sit, string *words) {
  string *outarray=({ });
  string s1;
  if (!sizeof(sit->chats)) return ({ });
  foreach (s1 in sit->chats) outarray+= ({ replace(s1,words) });
  return outarray;
}
mixed *insert_words_items(class situation sit, string *words) {
  mixed *outarray=({ });
  mixed ai,e0,e1;
  if (!sizeof(sit->add_items)) return ({ });
  foreach (ai in sit->add_items) {
    if (sizeof(ai)>=2) {
      e0=ai[0];
      if (arrayp(e0)) e0=explode(lower_case(replace(implode(e0,"|"),words)),"|");
      else e0=lower_case(replace(e0,words));
      e1=ai[1];
      if (arrayp(e1)) e1=explode(replace(implode(e1,"|"),words),"|");
      else e1=replace(e1,words);
      ai = ({ e0,e1 })+ai[2..];
    }
    outarray+= ({ ai });
  }
  return outarray;
}
int query_status() { return automate; }
int *query_current_situations() { return ({ currentsits, autosits }); }
mixed *query_sittiming() { return sittiming; }
mapping query_situations() { return sitdata; }
void dest_me() {
  destruct(this_object());
}
int clean_up( int parent ) {
  if (parent) {
    return 0;
  }
  return 1;
}
void add_situation( mixed label, class situation sit ) {
  if (!sizeof(sitdata)) {
    sitdata= ([ label : sit ]);
    sitwords= ([ ]);
  }
  else {
    sitdata+= ([ label : sit ]);
  }
}
void start_situation(mixed label, int do_start_mess) {
  class situation sdata;
  string *chats;
  mixed item,*items;
  object chatter;
  string *words;
  sdata=sitdata[ label ];
  words=sitwords[ label ];
  if (!currentsits) currentsits=({ label });
  else currentsits=currentsits+({ label });
  if (sizeof(sdata->extra_look)) {
    if (els && sizeof(els))
      els+=({ replace(sdata->extra_look,words) });
    else {
      els=({ replace(sdata->extra_look,words) });
      ownerroom->add_extra_look(this_object());
    }
  }
  if (do_start_mess && sizeof(sdata->start_mess))
    tell_room(ownerroom, replace(sdata->start_mess,words)+"\n");
  chats=insert_words_chats(sdata,words);
  if (chats && sizeof(chats)) {
    if (!(chatter=ownerroom->query_chatter())) {
      if (sdata->chat_rate) {
        ownerroom->room_chat( ({ chatmin,chatmax, ({ }) }),
                      clone_object("/std/room/basic/multichatter")  );
        chatter=ownerroom->query_chatter();
        chatter->setup_chatter( ownerroom,
        ({ (sdata->chat_rate)[0],(sdata->chat_rate)[1], chats }) );
      } else {
        ownerroom->room_chat( ({ chatmin,chatmax, chats }) );
        chatter=ownerroom->query_chatter();
      }
      chatter->check_chat();
    } else {
      if (sdata->chat_rate) {
        if (!(chatter->query_multichatter())) {
          mixed *args;
          args=(chatter->query_room_chats())[0..2];
          chatter->dest_me();
          ownerroom->room_chat( args,
                        clone_object("/std/room/basic/multichatter")  );
          chatter = ownerroom->query_chatter();
        }
        chatter->setup_chatter( ownerroom,
          ({ (sdata->chat_rate)[0],(sdata->chat_rate)[1], chats }) );
        chatter->check_chat();
      }
      else chatter->add_room_chats(chats);
    }
  }
  items=insert_words_items(sdata,words);
  if (sizeof(items)) {
    foreach(item in items) {
      ownerroom->add_item(item[0],item[1]);
    }
  }
  if (sdata->start_func) {
    (*(sdata->start_func))(label,do_start_mess,ownerroom);
  }
}
void end_situation(mixed label) {
  class situation sdata;
  string *chats;
  mixed item,*items;
  object chatter;
  string *words;
  sdata=sitdata[ label ];
  words=sitwords[ label ];
  if (currentsits) currentsits=currentsits-({ label });
  if (els && sizeof(sdata->extra_look)) {
    els-=({ replace(sdata->extra_look,words) });
    if (!sizeof(els)) ownerroom->remove_extra_look(this_object());
  }
  chats=insert_words_chats(sdata,words);
  if (chats && sizeof(chats) && (chatter=ownerroom->query_chatter())) {
    chatter->remove_room_chats(chats);
  }
  items=insert_words_items(sdata,words);
  if (sizeof(items)) {
    foreach(item in items) {
      if (arrayp(item[0]))
        ownerroom->remove_item((item[0])[0]);
      else
        ownerroom->remove_item(item[0]);
    }
  }
  if (sizeof(sdata->end_mess))
    tell_room(ownerroom,replace(sdata->end_mess,words)+"\n");
  if (sdata->end_func) {
    (*(sdata->end_func))(label,ownerroom);
  }
}
varargs mixed change_situation( mixed label, mixed duration,
     mixed words, mixed handle  ) {
  mixed frog,bing;
  mixed ending;
  if (!cco) cco=({ 1, 0 });
  if (!handle) {
    handle=member_array(0,cco[1..<1])+1;
    if (!handle) {
      cco+=({ 0 });
      handle=sizeof(cco)-1;
    }
  }
  cco[0]=handle;
  if (!duration) {
    if (arrayp(label)) frog=label[0];
    else frog=label;
    if (stringp(frog)) frog=explode(frog,",");
    else frog=({ frog });
    foreach(bing in frog) end_situation(bing);
    cco[handle]=0;
    return 0;
  }
  if (!arrayp(duration)) {
    if (arrayp(label)) {
      bing=duration/sizeof(label);
      duration=({ });
      foreach (frog in label) duration+=({ bing });
    }
    else duration=({ duration });
  }
  if (arrayp(label) && sizeof(label)>1 && sizeof(label)>sizeof(duration)) {
    frog=label[0];
    if (stringp(frog)) ending=explode(frog,",");
    else ending=({ frog });
    label=label[1..<1];
  }
  if (sizeof(duration)==1) {
    if (arrayp(label)) frog=label[0];
    else frog=label;
    if (stringp(frog)) frog=explode(frog,",");
    else frog=({ frog });
    if (ending) {
      ending-=frog;
      foreach(bing in ending) end_situation(bing);
    }
    if (currentsits) frog=frog-currentsits;
    foreach(bing in frog) {
      if (!sizeof(words)) choose_words( bing, time()*335423611 );
      else choose_words( bing, words );
      start_situation(bing,1);
    }
    if (duration[0]!=-1)
      cco[handle]=call_out("change_situation",duration[0],
                           label,0,words,handle);
    return handle;
  }
  if (arrayp(label)) frog=label[0];
  else frog=label;
  if (stringp(frog)) frog=explode(frog,",");
  else frog=({ frog });
  if (ending) {
    ending-=frog;
    foreach(bing in ending) end_situation(bing);
  }
  if (currentsits) frog=frog-currentsits;
  foreach(bing in frog) start_situation(bing,1);
  if (duration[0]!=-1)
    cco[handle]=
    call_out("change_situation",duration[0],
             label,duration[1..<1],words,handle);
  return handle;
}
int query_possible(class situation_timing sit, int it, int tod, int cnt)
{
  int possible;
  class situation_timing sit2;
  int cnt2,it2,tod2,possible2;
  if (functionp(sit->when)) possible=(*(sit->when))(tod);
  else possible=sit->when;
  possible=
    (possible&(1<<((AM_TIME_HANDLER)->query_am_hour(tod))))
    &&
    (RANDOM(1000,it*1147483647+cnt*2047483243) < sit->chance);
  if (possible && sit->category) {
    cnt2=0;
    foreach (sit2 in sittiming) {
      cnt2++;
      if (cnt2!=cnt && sit2->category == sit->category) {
	it2=(tod+offset+(cnt2*234231))/sit2->duration;
	tod2=it2*sit2->duration-offset-(cnt2*234231);
	if (functionp(sit2->when)) possible2=(*(sit2->when))(tod2);
	else possible2=sit2->when;
	possible2=
	  (possible2&(1<<((AM_TIME_HANDLER)->query_am_hour(tod2))))
	  &&
	  (RANDOM(1000,it2*1147483647+cnt2*2047483243) < sit2->chance);
	if (possible2 && (tod2<tod || (tod==tod2 && cnt2<cnt))) {
	  possible=0;
	  break;
	}
      }
    }
  }
  return possible;
}
void manage_situations() {
  class situation_timing sit;
  int t,t0,it,tod,cnt,possible,dt,tc,i;
  mixed label,lb;
  mixed *newsits;
  mixed *changes;
  mixed *background_on,*background_off;
  int ttmp,tstep;
  if (!automate) return;
  if (!sizeof(filter_array( all_inventory( ownerroom ),(: interactive($1) :)))) {
    automate=2;
    return;
  }
  t0=time()+offset;
  newsits=({});
  tstep=2147483648;
  background_on=({ });
  background_off=({ });
  cnt=0;
  foreach (sit in sittiming) {
    cnt++;
    t=t0+(cnt*234231);
    ttmp=sit->duration;
    it=t/ttmp;
    tod=it*ttmp-offset-(cnt*234231);
    possible=sit->it_data[ it ];
    if (undefinedp(possible)) {
      possible=query_possible(sit, it, tod, cnt);
      sit->it_data[ it ]=possible;
      if (!undefinedp(sit->it_data[ it-1 ]))
	map_delete(sit->it_data,it-1);
    } else {
    }
    if (possible) {
      if (sit->background) background_off+=explode(sit->background,",");
      if (arrayp(sit->label)) {
	dt=(t % ttmp);
	i=0;
	foreach (tc in sit->endat) {
	  if (tc>dt) break;
	  i++;
	}
	label=(sit->label)[i];
	ttmp=tc-dt;
      }
      else label=sit->label;
      if (stringp(label)) {
	label=explode(label,",");
	newsits=newsits+label;
	foreach(lb in label) choose_words(lb,it*1147483647+cnt*2047555777);
      }
      else {
	newsits=newsits+({ label });
	choose_words(label,it*1147483647+cnt*2047555777);
      }
    }
    else {
      if (sit->background) background_on+=explode(sit->background,",");
      possible=sit->it_data[ it+1 ];
      if (undefinedp(possible)) {
	possible=query_possible(sit, it+1, tod+sit->duration, cnt);
	sit->it_data[ it+1 ]=possible;
	if (!undefinedp(sit->it_data[ it-1 ]))
	  map_delete(sit->it_data,it-1);
      }
      if (possible)
	ttmp=ttmp-(t % ttmp);
      else
	ttmp=2*ttmp-(t % ttmp);
    }
    if (ttmp<tstep) tstep=ttmp;
  }
  call_out("manage_situations",tstep+1);
  newsits = newsits+(background_on-background_off);
  if (autosits && sizeof(autosits)) {
    changes=autosits-newsits;
    if (sizeof(changes)) {
      foreach(label in changes) end_situation(label);
      autosits=autosits-changes;
    }
    changes=newsits-autosits;
  }
  else changes=newsits;
  if (sizeof(changes)) {
    foreach(label in changes) start_situation(label,2-automate);
    if (autosits) autosits=autosits+changes;
    else autosits=changes;
  }
  automate=1;
}
void check_situations() {
  if (automate==2 && interactive(this_player())) manage_situations();
}
void make_seed(int xval, int yval) {
  offset=(xval*38547+yval*1232444311)>>2;
}
void automate_situation( mixed label, mixed duration, mixed when, mixed chance,
     mixed category ) {
  mixed chatargs,endat,background,labels;
  int i,d;
  string ook;
  if (!offset) {
    ook=file_name(ownerroom);
    if (!ook || ook=="") {
      write( "Bad file name" );
      return;
    }
    offset=1;
    foreach (i in ook) offset*=i;
    offset=(offset>>2)+1;
  }
  if (ownerroom->query_chatter()) {
    chatargs=(ownerroom->query_chatter())->query_room_chats();
    if (sizeof(chatargs)==3) {
      chatmin=chatargs[0];
      chatmax=chatargs[1];
    }
  }
  endat=({ });
  if (arrayp(duration)) {
    if (!arrayp(label) || sizeof(duration)!=sizeof(label)) {
      write("Duration must be an array of the same length as label");
      return;
    }
    d=0;
    labels=({ });
    for (i=0;i<sizeof(duration);i++) {
      if (duration[i]!=-1) {
	d+=duration[i];
        endat+=({ d });
	labels=labels+({ label[i] });
      }
      else {
	if (background) background=implode(explode(background,",")+({ label[i] }),",");
        else background=label[i];
      }
    }
  } else {
    labels=label;
    d=duration;
    if (arrayp(label)) {
      for (i=0;i<sizeof(label);i++) {
        endat+=({ ((i+1)*duration)/sizeof(label) });
      }
    } else {
      endat=({ duration });
    }
  }
  if (!sittiming)
    sittiming=
      ({ new(class situation_timing, label: labels, duration: d,
             when: when, chance: chance, endat: endat, background: background,
             category: category, it: 0, it_data: ([ ]) ) });
  else
    sittiming=sittiming+
      ({ new(class situation_timing, label: labels, duration: d,
             when: when, chance: chance, endat: endat, background: background,
             category: category, it: 0, it_data: ([ ]) ) });
  automate=2;
}
void shutdown_all_situations() {
  int label;
  mixed h;
  if (sizeof(cco)>1) {
    foreach (h in cco[1..<1]) {
       if (h) remove_call_out(h);
    }
  }
  cco=({ 0 });
  if (currentsits && sizeof(currentsits)) {
    foreach(label in currentsits) end_situation(label);
  }
  autosits=0;
  automate=0;
}
void shutdown_situation(int handle, mixed label) {
  mixed frog,bing;
  if (sizeof(cco)) {
    if (!handle) handle=cco[0];
    if (handle && cco[handle]) remove_call_out(cco[handle]);
    cco[handle]=0;
  }
  if (arrayp(label)) {
    frog=({ });
    foreach(bing in label) {
      if (stringp(bing)) frog+=explode(bing,",");
      else frog+=({ bing });
    }
  }
  else if (stringp(label)) label=explode(label,",");
  else label=({ label });
}
string extra_look() {
  if (!els || !sizeof(els)) {
    return "";
  }
  return implode(els,"  ")+"\n";
}

==================================================
FILE: room/basic/situation_changer_handler.c
==================================================

#include <situations.h>
inherit "/std/room/basic/situation_changer";
void add_situation( mixed label, class situation sit ) {
  if (!clonep()) ::add_situation( label, sit );
  else write("You can't add situations to a clone of this object.");
}
object set_room(object room_o) {
  if (clonep() ) {
    object base;
    base = find_object(base_name(this_object()));
    if (!base) {
      (base_name(this_object()))->parp();
      base = find_object(base_name(this_object()));
    }
    if (!(base->query_room())) {
      call_out( "dest_me", 2 );
      return room_o->set_situation_changer( base );
    }
    sitdata = base->query_situations();
  }
  return ::set_room( room_o );
}
void dest_me() {
  if (clonep()) ::dest_me();
  else if (sizeof(children(base_name(this_object())))==1) ::dest_me();
  return;
}
void create() {
  if (!clonep()) this_object()->setup_situations();
}

==================================================
FILE: room/basic/terrain.c
==================================================

#include <dirs.h>
#include <terrain.h>
string terrain_name;
object room;
void setup_shadow(object thing, string word) {
  shadow(thing, 1);
  TERRAIN_MAP->setup_location(thing, word);
  thing->add_property("terrain name", word);
  terrain_name = word;
  room = thing;
}
void destruct_shadow(object thing) {
  if (thing == this_object()) {
    TERRAIN_MAP->delete_cloned_location(terrain_name, file_name(room));
    destruct(this_object());
  } else {
    thing->destruct_shadow( thing );
  }
}
void event_exit(object thing, string message, object to) {
  if (!objectp(room)) {
    room = query_shadowing(this_object());
  }
  if (clonep(room)) {
    if (find_call_out("free_location") == -1) {
      call_out("free_location", 10);
    }
  }
  room->event_exit(thing, message, to);
}
void free_location() {
  if (sizeof(all_inventory(room)) || (int)this_object()->dont_free())
    return;
  TERRAIN_MAP->delete_cloned_location(terrain_name, file_name(room));
  room->dest_me();
}
void set_destination(string direc) {
  int i, j, delta, *co_ords, *new_co_ords = allocate(3);
  string dest_name;
  object destination;
  if ((i = member_array(direc, STD_ORDERS)) == -1) {
    return;
  }
  if (!objectp(room)) {
    room = query_shadowing(this_object());
  }
  dest_name = (string)room->query_destination(direc);
  delta = (int)room->query_room_size() + TERRAIN_MAP->get_room_size(dest_name);
  co_ords = room->query_co_ord();
  for (j = 0; j < 3; j++) {
    new_co_ords[j] = co_ords[j] - delta * STD_ORDERS[i+1][j];
  }
  destination = TERRAIN_MAP->find_location(terrain_name, new_co_ords);
  if (!destination) {
    return;
  }
  room->modify_exit(direc, ({ "dest", file_name(destination) }));
}
string query_quit_handler() { return TERRAIN_LOG; }
mixed *query_cloning_info() {
  return ({ TERRAIN_MAP, "find_location",
            terrain_name, (int *)room->query_co_ord() });
}

==================================================
FILE: room/basic/twilight.c
==================================================

#include <twilight.h>
#include <climate.h>
int last_updated;
mixed roomitems;
string *roomlong;
mixed roomchats;
object shadowed_obj;
void set_current_long();
string return_long( mixed desc );
void do_change();
void change( int time_now );
void create() {
  seteuid( (string)"/secure/master"->creator_file( file_name(
    this_object() ) ) );
}
void destruct_shadow( object thing ) {
  if( thing == this_object() )
    destruct( thing );
  else
    thing->destruct_shadow( thing );
}
void setup_shadow( object this_room ) {
  shadow( this_room, 1 );
  shadowed_obj = this_room;
  if( WEATHER_HANDLER->query_day() ) {
    call_out( "changing_to_day", 0, 1 );
    last_updated = DAY;
  } else {
    call_out( "changing_to_night", 0, 1 );
    last_updated = NIGHT;
  }
  roomitems = ({ ({ }), ({ }) });
  roomlong = allocate( 2 );
  roomlong = ({ 0, 0 });
  roomchats = allocate( 2 );
  WEATHER_HANDLER->weather_notify( this_room, NOTIFY_DAY );
}
void event_weather(int whats_changed) {
  if (WEATHER_HANDLER->query_day()) {
    if (last_updated == NIGHT)
      change( DAY );
  } else if (last_updated == DAY)
    change( NIGHT );
  shadowed_obj->event_weather( whats_changed );
}
void change( int time_now ) {
  int i;
  last_updated = time_now;
  set_current_long();
  for ( i = 0; i < sizeof( roomitems[ last_updated ] ); i += 2 )  {
    shadowed_obj->modify_item( roomitems[ last_updated ][ i ],
                               roomitems[ last_updated ][ i + 1 ] );
  }
  for ( i = 0; i < sizeof( roomitems[ 1 - last_updated ] ); i += 2 )  {
    if ( member_array( roomitems[ 1 - last_updated ][ i ],
                       roomitems[ last_updated ] ) == -1 )  {
      shadowed_obj->modify_item( roomitems[ 1 - last_updated ][ i ],
                                 "You can't see that now.\n" );
    }
  }
  shadowed_obj->stop_room_chats();
  if( sizeof(roomchats[last_updated]) )
    shadowed_obj->room_chat( roomchats[last_updated] );
  if( last_updated == DAY )
    shadowed_obj->changing_to_day( 0 );
  else
    shadowed_obj->changing_to_night( 0 );
}
void set_day_long( string str ) {
  roomlong[DAY] = str;
  set_current_long();
}
void set_night_long( string str ) {
  roomlong[NIGHT] = str;
  set_current_long();
}
void set_current_long() {
  if (roomlong[last_updated] != 0 && roomlong[last_updated] != "")
    shadowed_obj->set_long( roomlong[last_updated] );
}
varargs int add_day_item( mixed shorts, mixed desc, mixed no_plural ) {
  string the_item;
  if( pointerp( shorts ) )
    the_item = shorts[0];
  else
    the_item = shorts;
  roomitems[DAY] += ({ the_item, return_long( desc ) });
  if( last_updated == DAY )
    return this_object()->add_item( shorts, desc, no_plural );
  return 1;
}
varargs int add_night_item( mixed shorts, mixed desc, mixed no_plural ) {
  string the_item;
  if( pointerp( shorts ) )
    the_item = shorts[0];
  else
    the_item = shorts;
  roomitems[NIGHT] += ({ the_item, return_long( desc ) });
  if( last_updated == NIGHT )
    return shadowed_obj->add_item( shorts, desc, no_plural );
  return 1;
}
void room_day_chat( mixed *args ) {
  roomchats[DAY] = args;
  if( last_updated == DAY )
    shadowed_obj->room_chat( args );
}
void room_night_chat( mixed *args ) {
  roomchats[NIGHT] = args;
  if( last_updated == NIGHT )
    shadowed_obj->room_chat( args );
}
string return_long( mixed desc ) {
  int ma;
  if( !pointerp( desc ) )
    return (string)desc;
  ma = member_array( "long", desc );
  if( ma < 0 )
    return "Error: No long found.";
  return (string)desc[ma+1];
}
int query_time() { return last_updated; }
mixed query_roomitems() { return roomitems; }
string *query_roomlong() { return roomlong; }
mixed query_roomchats() { return roomchats; }

==================================================
FILE: room/basic/wall.c
==================================================

string *belows, death_mess, old_here;
mixed *bottom, *moves;
mixed ghost_action;
int no_drop;
object room;
void create() {
   belows = ({ });
   bottom = 0;
   ghost_action = 0;
   moves = ({ });
   no_drop = 0;
   death_mess = 0;
}
void setup_shadow( object thing ) {
   shadow( thing, 1 );
   room = thing;
}
void destruct_shadow( object thing ) {
   if ( thing == this_object() )
      destruct( this_object() );
   else
      thing->destruct_shadow( thing );
}
string *query_belows() { return copy( belows ); }
mixed *query_bottom() { return copy( bottom ); }
mixed query_ghost_action() { return copy( ghost_action ); }
mixed *query_moves() { return copy( moves ); }
int query_no_drop() { return copy( no_drop ); }
string query_death_mess() { return death_mess; }
int query_at_bottom() { return !bottom; }
mixed *query_move( string word ) {
   int i;
   i = member_array( word, moves );
   if ( i == -1 )
      return 0;
   return moves[ i + 1 .. i + 3 ];
}
void calc_co_ord() {
   int i, delta, *co_ord;
   string word, other;
   room->calc_co_ord();
   if ( co_ord )
      return;
   foreach ( word in ({ "down", "up" }) ) {
      i = member_array( word, moves );
      if ( i == -1 )
         continue;
      other = moves[ i + 2 ];
      if ( !find_object( other ) )
         continue;
      co_ord = copy( (int *)other->query_co_ord() );
      if ( !co_ord )
         continue;
      delta = (int)room->query_room_size_array()[2] +
         (int)other->query_room_size_array()[2];
      if ( word == "down" )
         co_ord[ 2 ] += delta;
      else
         co_ord[ 2 ] -= delta;
      room->set_co_ord( co_ord );
      return;
   }
}
void set_wall( mixed *args ) {
   int i, j;
   mixed arg;
   for ( i = sizeof( args ) - 2; i > -1; i -= 2 ) {
      arg = args[ i + 1 ];
      switch ( args[ i ] ) {
         case "bottom" :
            bottom = arg;
            if ( ! no_drop ) {
                old_here = room->query_property( "here" );
                room->add_property( "here", "falling past you" );
            }
            break;
         case "below" :
            belows += arg;
            break;
         case "move" :
            j = member_array( arg[ 0 ], moves );
            if ( j == -1 )
               moves += arg;
            else
               moves[ j + 1 .. j + 3 ] = arg[ 1 .. 3 ];
            break;
         case "death mess" :
         case "death_mess" :
            death_mess = arg;
            break;
         case "ghost action" :
         case "ghost_action" :
             ghost_action = arg;
             break;
         case "no drop" :
         case "no_drop" :
             no_drop = arg;
             if ( bottom ) {
                 if ( old_here )
                     room->add_property( "here", old_here );
                 else
                     room->remove_property( "here" );
             }
             break;
      }
   }
}
void event_enter( object thing, string mess, object from ) {
   room->event_enter( thing, mess, from );
   if ( !living( thing ) && bottom && ( ! no_drop ) )
      call_out( "fall_down", 0, thing );
}
void fall_down( object thing ) {
   int damage;
   string word;
   if ( !thing )
      return;
   if ( environment( thing ) != room )
      return;
   damage = (int)room->query_room_size_array()[2];
   if ( sizeof( belows ) )
      foreach ( word in belows ) {
         tell_room( find_object( word ), (string)thing->a_short() +
               " $V$0=falls,fall$V$ past you and $V$0=is,are$V$ gone.\n" );
         damage += 2 * (int)word->query_room_size_array()[2];
      }
   if ( stringp( bottom ) ) {
      if ( living( thing ) )
         thing->move_with_look( bottom,
               "$N fall$s from above with a loud thump.",
               "$N drop$s downwards out of sight." );
      else
         thing->move( bottom,
               "$N fall$s from above with a loud thump.",
               "$N drop$s downwards out of sight." );
      return;
   }
   word = bottom[ 0 ];
   damage += (int)word->query_room_size_array()[2];
   if ( sizeof( bottom ) > 1 && stringp( bottom[ 1 ] ) )
      if ( living( thing ) )
         thing->move_with_look( word, call_other( word, bottom[ 1 ], thing,
               room ), "$N drop$s downwards out of sight." );
      else
         thing->move( word, call_other( word, bottom[ 1 ], thing, room ),
               "$N drop$s downwards out of sight." );
   else
      if ( living( thing ) ) {
         thing->move_with_look( word,
               "$N fall$s from above with a loud crunch.",
               "$N drop$s downwards out of sight." );
         damage *= bottom[ 1 ] * (int)thing->query_complete_weight();
         damage /= 10000;
         damage -= (int)thing->query_ac( "blunt", damage );
         if ( damage > 0 ) {
            if ( damage > thing->query_hp() ) {
               tell_object( thing, !death_mess ? "You hit the ground "
                  "with a sickening crunch.\n" : death_mess );
               thing->attack_by( room );
               thing->adjust_hp(-damage, room);
            } else {
               thing->adjust_hp(-damage, room);
               tell_object( thing, "Ouch, that hurt!\n" );
            }
         }
      } else
         thing->move( word,
               "$N fall$s from above with a loud thump.",
               "$N drop$s downwards out of sight." );
}

==================================================
FILE: room/basic/water.c
==================================================

#include <armoury.h>
#include <position.h>
#include <room.h>
#include <tasks.h>
#define ANCHOR_PROP "anchor"
#define GILLS_PROP "gills"
#define FLOATING_PROP "floating"
#define LIVES_IN_WATER_PROP "lives in water"
#define SWIMMING_SKILL "other.movement.swimming"
#define OBJECT_WET_EFFECT "/std/effects/object/wet"
#define LIVING_WET_EFFECT "/std/effects/other/wetness"
#define SWIM_EFFECT "/std/effects/other/water_effect"
mixed query_property(string);
varargs mixed *query_dest_other(string);
varargs int add_property(string, mixed, int);
int modify_exit(mixed, mixed*);
string query_destination(string);
string *query_exits();
int set_water_light(int);
int query_my_light();
varargs string *query_dest_dir(object);
int lives_in_water( object ob );
varargs void soak(object, int);
object get_water();
int water_override(string);
int do_float();
int do_drift();
int do_swim();
int get_swim_enum(object);
int query_bottom();
int query_surface();
string get_exit_mess(object, string);
string get_enter_mess(object, string);
object query_above_room();
void update_water_light();
private string on_bottom = "lying on the bottom",
        non_float = "drifting nearby",
        floating = "floating nearby",
        sinking = "sinking nearby",
        s_in_mess = "$N sink$s $down$ from $F.",
        s_out_mess = "$N sink$s $down$.",
        f_in_mess = "$N float$s $up$ from $F.",
        f_out_mess = "$N float$s $up$.",
        c_in_mess = "$N $V$0=is,are$V$ swept in from $F by the current.",
        c_out_mess = "$N $V$0=is,are$V$ swept $T by the current.",
        up_dir = "up", down_dir = "down";
private int bottom = -1, surface = -1, clarity = 90, salinity = 0,
        turbulence = 100, update_light = 1, light_first_queried = 0,
        last_speech_volume = 0;
private mapping flows = ([ ]), exit_messes = ([ ]), enter_messes = ([ ]),
        origins = ([ ]);
string* query_default_search_description() {
   return ({
       "Funnily enough there is nothing interesting in the water.\n",
       "You search around and discover a whole bunch of water.\n",
       "You look up and down, left and right, then up and down again but "
       "all you can find is water.\n"
           });
}
mixed *query_default_position(object ob) {
  return ({SWIMMING, "%^BOLD%^You start to swim.%^RESET%^\n",
           "$C$"+ob->one_short()+" "
           "$V$0=starts,start$V$ to swim.\n"});
}
int is_allowed_position(string poss) {
  if (poss == SWIMMING) {
    return 1;
  }
  return 0;
}
void set_bottom_mess(string mess) {
  on_bottom = mess;
}
string query_bottom_mess() {
  return on_bottom;
}
void set_nonfloat_mess(string mess) {
   non_float = mess;
}
string query_nonfloat_mess() {
  return non_float;
}
void set_float_mess(string mess) {
  floating = mess;
}
string query_float_mess() {
  return floating;
}
void set_sinking_mess(string mess) {
  sinking = mess;
}
string query_sinking_mess() {
  return sinking;
}
void set_sink_in_mess(string mess) {
  s_in_mess = mess;
}
string query_sink_in_mess() {
  return replace(s_in_mess, ({"$down$", down_dir}));
}
void set_sink_out_mess(string mess) {
  s_out_mess = mess;
}
string query_sink_out_mess() {
  return replace(s_out_mess, ({"$down$", down_dir}));;
}
void set_float_in_mess(string mess) {
  f_in_mess = mess;
}
string query_float_in_mess() {
  return replace(f_in_mess, ({"$up$", up_dir}));
}
void set_float_out_mess(string mess) {
  f_out_mess = mess;
}
string query_float_out_mess() {
  return replace(f_out_mess, ({"$up$", up_dir}));
}
void set_sweep_in_mess(string mess) {
  c_in_mess = mess;
}
string query_sweep_in_mess() {
  return c_in_mess;
}
void set_sweep_out_mess(string mess) {
  c_out_mess = mess;
}
string query_sweep_out_mess() {
  return c_out_mess;
}
void set_up_dir(string dir) {
  up_dir = dir;
}
string query_up_dir() {
  return up_dir;
}
void set_down_dir(string dir) {
  down_dir = dir;
}
string query_down_dir() {
  return down_dir;
}
void set_bottom(int val) {
  bottom = val;
  if (bottom > 1 || bottom < -1) {
    bottom = 1;
  }
}
void set_surface(int val) {
  surface = val;
  if (surface > 1 || surface < -1) {
    surface = 1;
  }
}
void set_clarity(int how_clear) {
  clarity = how_clear;
  if (clarity > 100) {
    clarity = 100;
  }
  else if (clarity < 0) {
    clarity = 0;
  }
  if (!query_property("dark mess")) {
    if (clarity < 20) {
      add_property("dark mess", "The water here is very murky.");
    }
    else if (clarity < 50) {
      add_property("dark mess", "The water here is quite murky.");
    }
    else if (clarity < 80) {
      add_property("dark mess", "The water here is slightly murky.");
    }
  }
}
int query_clarity() {
  return clarity;
}
void set_turbidity(int how_murky) {
  set_clarity(100 - how_murky);
}
int query_turbidity() {
  return 100 - query_clarity();
}
void set_salinity(int how_salty) {
  salinity = how_salty;
  if (salinity > 100) {
    salinity = 100;
  }
  else if (salinity < 0) {
    salinity = 0;
  }
}
int query_salinity() {
  return salinity;
}
void set_turbulence(int how_turbulent) {
  turbulence = how_turbulent;
  if (turbulence < 0) {
    turbulence = 0;
  }
}
int query_turbulence() {
  return turbulence;
}
void set_use_surface_light(int val) {
  int surface_light;
  object above;
  update_light = 0;
  if (!val) {
    return;
  }
  above = query_above_room();
  if (!above) {
    set_water_light(0);
    return;
  }
  if (function_exists("query_day_light", above) ||
           above->water_surface_light_varies()) {
    update_light = 1;
    return;
  }
  if (function_exists("query_water_surface_light", above)) {
    surface_light = above->query_water_surface_light();
  }
  else {
    surface_light = above->query_my_light();
  }
  set_water_light(surface_light);
}
int query_water_surface_light() {
  update_water_light();
  return query_my_light()*query_clarity()/100;
}
int get_water_surface_light() {
  object above = query_above_room();
  if (!above) {
    return 0;
  }
  if (function_exists("query_water_surface_light", above)) {
    return above->query_water_surface_light();
  }
  return above->query_my_light();
}
void update_water_light() {
  if (!update_light) {
    return;
  }
  if (!light_first_queried) {
    set_use_surface_light(1);
    light_first_queried = 1;
    update_water_light();
    return;
  }
  set_water_light(get_water_surface_light());
}
void add_flow(string dir, int rate) {
  flows[dir] = rate;
}
void delete_flow(string dir) {
  map_delete(flows, dir);
}
mapping query_flows() {
  return copy(flows);
}
int query_flow(string dir) {
  return flows[dir];
}
int query_water_traction_bonus(object thing, int buoyancy) {
  if (buoyancy < 0) {
    buoyancy = -buoyancy;
    return buoyancy/3 + random(buoyancy/3);
  }
  return 0;
}
object query_above_room() {
  string destination = query_destination(up_dir);
  if (!destination) {
    return 0;
  }
  return load_object(destination);
}
object query_below_room() {
  string destination = query_destination(down_dir);
  if (!destination) {
    return 0;
  }
  return load_object(destination);
}
object query_surface_room() {
  object next;
  if (query_surface()) {
    return this_object();
  }
  next = query_above_room();
  if (next && next->query_water()) {
    return next->query_surface_room();
  }
  return 0;
}
object query_bottom_room() {
  object next;
  if (query_bottom()) {
    return this_object();
  }
  next = query_below_room();
  if (next && next->query_water()) {
    return next->query_bottom_room();
  }
  return 0;
}
void event_enter(object ob, string mess, object from)  {
  int effnum, buoyancy, *effects, *args;
  effects = ob->effects_matching(SWIM_EFFECT->query_classification());
  if (!effects || !sizeof(effects)) {
    if (from && !from->query_water() ) {
      if( !lives_in_water( ob ) )
        ob->add_effect(SWIM_EFFECT, 2);
    }
  }
  if ( !lives_in_water( ob ) ) {
      effnum = get_swim_enum(ob);
      args = ob->arg_of(effnum);
      if (living(ob) && query_surface() && !ob->query_property("dead") && from &&
               from->query_water() && !from->query_surface()) {
        if (args[1] < 150 || ob->query_property(GILLS_PROP)) {
          tell_object(ob, "You break the surface.\n");
        }
        else {
          tell_object(ob, "You break the surface and take a deep breath.\n");
        }
        if (args[1] != 0) {
          ob->set_arg_of(effnum, ({args[0], 0}));
        }
      }
  }
  if (!living(ob)) {
    buoyancy = SWIM_EFFECT->calc_buoyancy(ob);
    if (buoyancy < 0 && query_bottom()) {
      ob->add_property("there", on_bottom);
    }
    else if (buoyancy >= 0 && (buoyancy > ob->query_property(ANCHOR_PROP)
           || query_surface())) {
      ob->add_property("there", floating);
    }
    else if (buoyancy < 0 && buoyancy < -ob->query_property(ANCHOR_PROP)) {
      ob->add_property("there", sinking);
    }
    else {
      ob->add_property("there", non_float);
    }
  } else {
    ob->return_to_default_position();
  }
}
varargs void soak(object ob, int ignore_location) {
  int wetness = 0, *effects;
  object env, water, *things;
  env = ob;
  if (!ignore_location) {
    while (env && env = environment(env)) {
      if (env == this_object()) {
        break;
      }
      if ((env->query_closed() && env->query_waterproof()) ||
           env->query_dry_cargo()) {
        env = 0;
        break;
      }
    }
  }
  if (!env) {
    return;
  }
  if (ob->query_property(FLOATING_PROP) && query_surface()) {
    return;
  }
  if (living(ob)) {
    if (ob->query_property("dead") || lives_in_water( ob ) ) {
      return;
    }
    effects = ob->effects_matching(LIVING_WET_EFFECT->query_classification());
    if (effects && sizeof(effects)) {
      wetness = ob->arg_of(effects[0]);
    }
    wetness = ob->query_weight() - wetness;
    if (wetness > 0) {
      ob->add_effect(LIVING_WET_EFFECT, wetness);
    }
  }
  else if (ob->id("towel")) {
    effects = ob->effects_matching(OBJECT_WET_EFFECT->query_classification());
    if (effects && sizeof(effects)) {
      wetness = ob->arg_of(effects[0]);
    }
    wetness = 200*ob->query_weight() - wetness;
    if (wetness > 0) {
      ob->add_effect(OBJECT_WET_EFFECT, wetness);
    }
  }
  if (ob->query_max_volume() && !ob->query_closed() &&
           ob->query_max_volume() - ob->query_volume() > 0) {
    water = get_water();
    water->set_amount(ob->query_max_volume() - ob->query_volume());
    water->move(ob);
  }
  if (!(ob->query_closed() && ob->query_waterproof()) &&
           !ob->query_dry_cargo()) {
    things = all_inventory(ob);
    if (things && sizeof(things)) {
      map(things, (: soak($1, 1) :));
    }
  }
}
object get_water() {
  object water = ARMOURY->request_item("water");
  switch (query_clarity()) {
  case 0..20:
    water->set_short("very muddy water");
    water->add_adjective(({"very", "muddy"}));
    water->set_long("This is $amount_size$ of very muddy water.\n");
    return water;
  case 21..50:
    water->set_short("muddy water");
    water->add_adjective("muddy");
    water->set_long("This is $amount_size$ of muddy water.\n");
    return water;
  case 51..80:
    water->set_short("slightly muddy water");
    water->add_adjective(({"slightly", "muddy"}));
    water->set_long("This is $amount_size$ of slightly muddy water.\n");
  }
  switch (query_salinity()) {
  case 51..100:
    water->set_short("brine");
    water->add_alias("brine");
    water->set_long("This is $amount_size$ of very salty water.\n");
    return water;
  case 11..50:
    water->set_short("salty water");
    water->add_adjective("salty");
    water->set_long("This is $amount_size$ of salty water.\n");
  }
  return water;
}
int swim_exit(string dir, object ob, string mess) {
  int difficulty, buoyancy = 0, place, this_turb, gp_cost, effnum, *arg;
  string *places_to_go, *tm_messes;
  object destination;
  if (!living(ob) || ob->query_property("dead") || lives_in_water( ob ) ) {
    return 1;
  }
  effnum = get_swim_enum(ob);
  arg = ob->arg_of(effnum);
  if (-2 == arg[0]) {
    return 1;
  }
  difficulty = -flows[dir];
  buoyancy = SWIM_EFFECT->calc_buoyancy(ob);
  if (ob->query_weight()) {
    buoyancy /= ob->query_weight();
  }
  places_to_go = query_dest_dir();
  place = member_array(dir, places_to_go);
  if (-1 == place || !(destination = load_object(places_to_go[place+1]))) {
    return 0;
  }
  if (dir == up_dir) {
    difficulty -= buoyancy + 50;
  } else if (dir == down_dir) {
    difficulty += buoyancy - 50;
  } else if (buoyancy < 0) {
    difficulty -= buoyancy/5;
  } else {
    difficulty += buoyancy/5;
  }
  if (query_bottom() && (!destination->query_water() ||
           destination->query_bottom())) {
    difficulty -= query_water_traction_bonus(ob, buoyancy);
  }
  this_turb = random(query_turbulence());
  difficulty += this_turb;
  if (arg[0] == -1) {
    difficulty -= 50;
  }
  if (!destination->query_water()) {
    difficulty -= 50;
  }
  difficulty *= SWIM_EFFECT->swim_difficulty(ob);
  difficulty /= 100;
  if (difficulty <= 0) {
    return 1;
  }
  if (arg[0] != -1) {
    gp_cost = difficulty/20;
    if (gp_cost > 50) {
      gp_cost = 50;
    }
    else if (gp_cost < 1) {
      gp_cost = 1;
    }
    if (ob->query_specific_gp("other") < gp_cost) {
      tell_object(ob, "You're too "+({"fatigued", "tired", "weary",
           "exhausted"})[random(4)]+" to swim "+dir+" at the moment.\n");
      notify_fail("");
      return 0;
    }
  }
  ob->adjust_gp(-gp_cost);
  switch (TASKER->perform_task(ob, SWIMMING_SKILL, difficulty,
           TM_CONTINUOUS)) {
  case AWARD:
    tm_messes = ({"You move more surely as you glide through the water.",
                  "You discover a more efficient stroke.",
                  "You find a better way to streamline your body.",
                  "You find a more efficient swimming rhythm.",
                  "You begin to move more confidently through the water."});
    tell_object(ob, "%^YELLOW%^"+tm_messes[random(sizeof(tm_messes))]+
           "%^RESET%^\n");
  case SUCCEED:
    return 1;
  }
  notify_fail("");
  if (dir == up_dir && buoyancy < -50) {
    tell_object(ob, "You struggle to leave "+up_dir+" but, with the load "
           "you're carrying, you can't make any headway.\n");
    tell_room(this_object(), "$C$"+ob->one_short()+" "
           "$V$0=struggles,struggle$V$ to leave "+up_dir+", but can't make "
           "any headway.\n", ob);
    return 0;
  }
  if (dir == down_dir && buoyancy > 50) {
    tell_object(ob, "You struggle to leave "+down_dir+" but, with your "
           "buoyancy, you can't make any headway.\n");
    tell_room(this_object(), "$C$"+ob->one_short()+" "
           "$V$0=struggles,struggle$V$ to leave "+down_dir+", but can't make "
           "any headway.\n", ob);
    return 0;
  }
  if (flows[dir] < 0) {
    tell_object(ob, "You struggle to leave "+dir+", but you can't make any "
           "headway against the current.\n");
    tell_room(this_object(), "$C$"+ob->one_short()+" "
           "$V$0=struggles,struggle$V$ to leave "+dir+", but can't make any "
           "headway against the current.\n", ob);
    return 0;
  }
  if (this_turb > 0) {
    tell_object(ob, "You struggle to leave "+dir+", but you can't make any "
           "headway in the turbulent waters.\n");
    tell_room(this_object(), "$C$"+ob->one_short()+" "
           "$V$0=struggles,struggle$V$ to leave "+dir+", but can't make any "
           "headway.\n", ob);
    return 0;
  }
  tell_object(ob, "You struggle to leave "+dir+", but you can't make any "
           "headway.\n");
  tell_room(this_object(), "$C$"+ob->one_short()+" $V$0=struggles,struggle$V$ "
           "to leave "+dir+", but can't make any headway.\n", ob);
  return 0;
}
string query_death_reason() {
  return "drowning";
}
int add_exit(string direc, mixed dest, string type) {
    mixed *messy = query_dest_other(direc);
    if (messy && arrayp(messy[ROOM_ENTER]) && sizeof(messy[ROOM_ENTER]) == 2){
        origins[direc] = messy[ROOM_ENTER][1];
    }
    modify_exit(direc, ({"function", "swim_exit",
                       "exit mess", (: get_exit_mess($1, $(direc)) :),
                       "enter mess", (: get_enter_mess($1, $(direc)) :)}));
    if( direc == "down" ) {
        add_property("no burial", 1);
    }
}
string query_origin(string dir) {
  if (origins[dir]) {
    return origins[dir];
  }
  return "elsewhere";
}
void add_exit_mess(object ob, string mess) {
  exit_messes[file_name(ob)] = mess;
}
void add_enter_mess(object ob, string mess) {
  enter_messes[file_name(ob)] = mess;
}
string get_exit_mess(object ob, string direc) {
  string retval;
  if (retval = exit_messes[file_name(ob)]) {
    map_delete(exit_messes, file_name(ob));
    return retval;
  }
  return "$N $V$0=swims,swim$V$ $T.";
}
string get_enter_mess(object ob, string direc) {
  string retval;
  if (retval = enter_messes[file_name(ob)]) {
    map_delete(enter_messes, file_name(ob));
  }
  else if (direc == up_dir) {
    retval = "$N $V$0=swims,swim$V$ up from $F.";
  }
  else if (direc == down_dir) {
    retval = "$N $V$0=swims,swim$V$ down from $F.";
  }
  else {
    retval = "$N $V$0=swims,swim$V$ in from $F.";
  }
  retval = replace(retval, "$F", query_origin(direc));
  return retval;
}
void init()  {
  add_command("float", "", (: do_float() :));
  add_command("drift", "", (: do_drift() :));
  add_command("swim", "", (: do_swim() :));
}
string mangle_speech(string type, string words, mixed target) {
  int drown;
  string garbled = "";
  if (query_surface() || !this_player() ||
           this_player()->query_property("dead")) {
    return words;
  }
  switch (type) {
  case "whisper":
    drown = 20 + random(20);
    break;
  case "lsay":
  case "mock":
    drown = 80 + random(80);
    break;
  case "shout":
    drown = 120 + random(120);
    break;
  default:
    drown = 40 + random(40);
  }
  for (int inc = (strlen(words) / 10) + 1;inc > 0;--inc) {
    garbled += ({"blub", "glub", "gloog", "arrrble"})[random(4)]+" ... ";
  }
  if (drown > 70) {
    garbled = garbled[0..(strlen(garbled) - 6)]+"!";
  } else {
    garbled = garbled[0..(strlen(garbled) - 2)];
  }
  garbled = capitalize(garbled);
  last_speech_volume = drown;
  return garbled;
}
void event_person_say(object ob, string start, string mess, string lang,
           string accent) {
  int effnum, *args;
  if (!ob || ob->query_property("dead") || ob->query_property(GILLS_PROP) ||
      lives_in_water( ob ) || environment(ob) != this_object() || query_surface()) {
    last_speech_volume = 0;
    return;
  }
  if (!last_speech_volume) {
    last_speech_volume = 40 + random(40);
  }
  effnum = get_swim_enum(ob);
  args = ob->arg_of(effnum);
  args[1] += last_speech_volume;
  ob->set_arg_of(effnum, args);
  ob->adjust_tmp_con(-random((last_speech_volume / 50) + 1));
  switch (last_speech_volume) {
  case 0..30:
    tell_object(ob, "You inhale a bit of water.\n");
    break;
  case 31..80:
    tell_object(ob, "You inhale some water.\n");
    break;
  case 81..150:
    tell_object(ob, "You inhale a fair amount of water.\n");
    break;
  default:
    tell_object(ob, "You inhale about a lungful of water.\n");
  }
  last_speech_volume = 0;
}
int do_float()  {
  int *args, effnum = get_swim_enum(this_player());
  args = this_player()->arg_of(effnum);
  if (!args[0]) {
    if (sizeof(filter(query_flows(), (: $2 :)))) {
      add_failed_mess("You are already floating on the current.\n");
    }
    else {
      add_failed_mess("You are already floating freely.\n");
    }
    return 0;
  }
  this_player()->set_arg_of(effnum, ({0, args[1]}));
  if (sizeof(filter(query_flows(), (: $2 :)))) {
    add_succeeded_mess(({"You begin to float freely on the current.\n", ""}));
  }
  else {
    add_succeeded_mess(({"You begin to float freely.\n", ""}));
  }
  return 1;
}
int do_drift()  {
  int *args, effnum = get_swim_enum(this_player());
  args = this_player()->arg_of(effnum);
  if (!args[0]) {
    if (sizeof(filter(query_flows(), (: $2 :)))) {
      add_failed_mess("You are already drifting with the current.\n");
    }
    else {
      add_failed_mess("You are already drifting freely.\n");
    }
    return 0;
  }
  this_player()->set_arg_of(effnum, ({0, args[1]}));
  if (sizeof(filter(query_flows(), (: $2 :)))) {
    add_succeeded_mess(({"You begin to drift freely with the current.\n",
           ""}));
  }
  else {
    add_succeeded_mess(({"You begin to drift freely.\n", ""}));
  }
  return 1;
}
int do_swim()  {
  int *args, effnum = get_swim_enum(this_player());
  args = this_player()->arg_of(effnum);
  if (args[0]) {
    if (sizeof(filter(query_flows(), (: $2 :)))) {
      add_failed_mess("You are already swimming against the current.\n");
    }
    else {
      add_failed_mess("You are already swimming.\n");
    }
    return 0;
  }
  this_player()->set_arg_of(effnum, ({1, args[1]}));
  if (sizeof(filter(query_flows(), (: $2 :)))) {
    add_succeeded_mess(({"You begin to swim against the current.\n", ""}));
  }
  else {
    add_succeeded_mess(({"You begin to swim.\n", ""}));
  }
  return 1;
}
int get_swim_enum(object thing) {
  int *effects = thing->effects_matching(SWIM_EFFECT->query_classification());
  if (!effects || !sizeof(effects)) {
    thing->add_effect(SWIM_EFFECT, 1);
    effects = thing->effects_matching(SWIM_EFFECT->query_classification());
    call_out("soak", 1, thing);
  } else if (!random(50)) {
    call_out("soak", 1, thing);
  }
  return effects[0];
}
int query_bottom()  {
  if (bottom == -1) {
    return member_array(down_dir, query_exits()) == -1;
  }
  return bottom;
}
int query_surface() {
    if (surface == -1) {
        return member_array(up_dir, query_exits()) == -1;
    }
    return surface;
}
int query_underwater() {
  return !query_surface();
}
int query_water()  {
  return 1;
}
int lives_in_water( object ob ) {
  string race_ob = ob->query_race_ob();
  if ( !living( ob ) ) {
    return 0;
  }
  if(ob->query_property(LIVES_IN_WATER_PROP) ||
     ob->lives_in_water() ||
     (race_ob && race_ob->lives_in_water()))
    return 1;
  return 0;
}
string query_terrain_map_colour() { return "%^CYAN%^"; }

==================================================
FILE: room/basic/topography/fixed_shadow.c
==================================================

#include <dirs.h>
#include <room.h>
string topo_handler;
object fixed_room;
mapping topo_barriers = ([ ]);
mapping dirs = ([
  "north": ({ 1, 0, 0 }), "south": ({ -1, 0, 0 }),
  "east": ({ 0, 1, 0 }), "west" : ({ 0, -1, 0 }),
  "northeast": ({ 1, 1, 0 }), "northwest": ({ 1, -1, 0 }),
  "southeast": ({ -1, 1, 0 }), "southwest": ({ -1, -1, 0 }),
  "up": ({ 0, 0, 1 }), "down": ({ 0, 0, -1 })
]);
void set_area_handler(string s) { topo_handler = s; }
void set_topo_handler(string s) { topo_handler = s; }
string query_area_handler() { return topo_handler; }
string query_topo_handler() { return topo_handler; }
void add_topo_barriers(mapping m) { topo_barriers += m; }
mapping query_topo_barriers() { return topo_barriers; }
mixed query_topo_barrier(string direc) { return topo_barriers[direc]; }
int query_fixed_room() { return 1; }
varargs mixed *query_dest_other( string direc ) {
  object room;
  mixed ret;
  if (!stringp(direc)) {
    return fixed_room->query_dest_other(direc);
  }
  ret = fixed_room->query_dest_other(direc);
  if (!sizeof(ret)) {
    return 0;
  }
  if (!stringp(ret[ROOM_DEST]) || (ret[ROOM_DEST] == "/") ||
  (ret[ROOM_DEST] == "/terrain") || (ret[ROOM_DEST] == "/topography")) {
    room = (topo_handler)->find_room_at_exit(this_object(),
                           dirs[direc], direc);
    if (!objectp(room)) {
      return 0;
    }
    ret[ROOM_DEST] = file_name(room);
  }
  return ret;
}
void attach(object ob) {
  shadow(ob);
  fixed_room = ob;
}
void add_topo_exits(string *other_exits, string other_types) {
  string s;
  foreach (s in other_exits) {
    if ((s == "compass4") || (s == "compass8")) {
      if (!this_object()->query_exit("north"))
        this_object()->add_exit("north", "/topography", other_types);
      if (!this_object()->query_exit("south"))
        this_object()->add_exit("south", "/topography", other_types);
      if (!this_object()->query_exit("east"))
        this_object()->add_exit("east", "/topography", other_types);
      if (!this_object()->query_exit("west"))
        this_object()->add_exit("west", "/topography", other_types);
      if (s == "compass8") {
        if (!this_object()->query_exit("northeast"))
          this_object()->add_exit("northeast", "/topography", other_types);
        if (!this_object()->query_exit("northwest"))
          this_object()->add_exit("northwest", "/topography", other_types);
        if (!this_object()->query_exit("southeast"))
          this_object()->add_exit("southeast", "/topography", other_types);
        if (!this_object()->query_exit("southwest"))
          this_object()->add_exit("southwest", "/topography", other_types);
      }
    } else {
      this_object()->add_exit(s, "/topography", other_types);
    }
  }
}

==================================================
FILE: room/topography/area/mountain.c
==================================================

inherit "/std/outsides/mountain";
inherit "/std/room/inherit/topography/aroom";
mixed* query_dest_other(string direc) {
   return aroom::query_dest_other(direc, mountain::query_dest_other(direc));
}
string query_look(string direc) {
   return aroom::query_look(direc, mountain::query_look(direc));
}
void create() {
   set_not_replaceable(1);
   ::create();
}
string query_room_letter() {
   return "^";
}

==================================================
FILE: room/topography/area/outside.c
==================================================

inherit "/std/room/outside";
inherit "/std/room/inherit/topography/aroom";
mixed* query_dest_other(string direc) {
   return aroom::query_dest_other(direc, outside::query_dest_other(direc));
}
string query_look(string direc) {
   return aroom::query_look(direc, outside::query_look(direc));
}
void create() {
   set_not_replaceable(1);
   ::create();
}
string query_room_letter() {
   return ".";
}

==================================================
FILE: room/topography/area/plain.c
==================================================

inherit "/std/outsides/plain";
inherit "/std/room/inherit/topography/aroom";
mixed* query_dest_other(string direc) {
   return aroom::query_dest_other(direc, plain::query_dest_other(direc));
}
string query_look(string direc) {
   return aroom::query_look(direc, plain::query_look(direc));
}
void create() {
   set_not_replaceable(1);
   ::create();
}
string query_room_letter() {
   return ".";
}

==================================================
FILE: room/topography/area/room.c
==================================================

inherit "/std/room/basic_room";
inherit "/std/room/inherit/topography/aroom";
mixed* query_dest_other(string direc) {
   return aroom::query_dest_other(direc, basic_room::query_dest_other(direc));
}
string query_look(string direc) {
   return aroom::query_look(direc, basic_room::query_look(direc));
}
void create() {
   set_not_replaceable(1);
   ::create();
}
string query_room_letter() {
   return "b";
}

==================================================
FILE: room/topography/area/water_inside.c
==================================================

inherit "/std/room/water_inside";
inherit "/std/room/inherit/topography/aroom";
mixed* query_dest_other(string direc) {
   mixed*fluff;
   fluff =  water_inside::query_dest_other(direc);
printf("%O\n", fluff);
   return aroom::query_dest_other(direc, fluff);
}
string query_look(string direc) {
   return aroom::query_look(direc, water_inside::query_look(direc));
}
void create() {
   set_not_replaceable(1);
   ::create();
}
string query_room_letter() {
   return "~";
}

==================================================
FILE: room/topography/area/water_outside.c
==================================================

inherit "/std/room/water_outside";
inherit "/std/room/inherit/topography/aroom";
mixed* query_dest_other(string direc) {
   mixed*fluff;
   fluff =  water_outside::query_dest_other(direc);
printf("%O\n", fluff);
   return aroom::query_dest_other(direc, fluff);
}
string query_look(string direc) {
   return aroom::query_look(direc, water_outside::query_look(direc));
}
void create() {
   set_not_replaceable(1);
   ::create();
}
string query_room_letter() {
   return "~";
}

==================================================
FILE: room/topography/area/woodland.c
==================================================

inherit "/std/outsides/woodland";
inherit "/std/room/inherit/topography/aroom";
mixed* query_dest_other(string direc) {
   return aroom::query_dest_other(direc, woodland::query_dest_other(direc));
}
string query_look(string direc) {
   return aroom::query_look(direc, woodland::query_look(direc));
}
void create() {
   set_not_replaceable(1);
   ::create();
}
string query_room_letter() {
   return "%";
}

==================================================
FILE: room/topography/iroom/mountain.c
==================================================

inherit "/std/outsides/mountain";
#include "/std/room/inherit/topography/iroom.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
}

==================================================
FILE: room/topography/iroom/outside.c
==================================================

inherit "/std/outside";
#include "/std/room/inherit/topography/iroom.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
}

==================================================
FILE: room/topography/iroom/plain.c
==================================================

inherit "/std/outsides/plain";
#include "/std/room/inherit/topography/iroom.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
}

==================================================
FILE: room/topography/iroom/room.c
==================================================

inherit "/std/room";
#include "/std/room/inherit/topography/iroom.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
}

==================================================
FILE: room/topography/iroom/woodland.c
==================================================

inherit "/std/outsides/woodland";
#include "/std/room/inherit/topography/iroom.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
}

==================================================
FILE: room/topography/milestone/mountain.c
==================================================

inherit "/std/outsides/mountain";
#include "/std/room/inherit/topography/milestone.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
  call_out("setup_milestone", 0);
}

==================================================
FILE: room/topography/milestone/outside.c
==================================================

inherit "/std/outside";
#include "/std/room/inherit/topography/milestone.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
  call_out("setup_milestone", 0);
}

==================================================
FILE: room/topography/milestone/plain.c
==================================================

inherit "/std/outsides/plain";
#include "/std/room/inherit/topography/milestone.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
  call_out("setup_milestone", 0);
}

==================================================
FILE: room/topography/milestone/room.c
==================================================

inherit "/std/room";
#include "/std/room/inherit/topography/milestone.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
  call_out("setup_milestone", 0);
}

==================================================
FILE: room/topography/milestone/woodland.c
==================================================

inherit "/std/outsides/woodland";
#include "/std/room/inherit/topography/milestone.c"
void create() {
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  add_exit(motion_verb, "interroom", "hidden");
  call_out("setup_milestone", 0);
}

==================================================
FILE: room/inherit/bath_house.c
==================================================

#include <effect.h>
#define SOAP_EFFECT "/std/effects/healing/antiseptic_soap"
#define WET_EFFECT "/std/effects/other/wetness"
protected int add_wash_effect( string classification, function func );
protected int add_finished_func( function func );
protected void advanced_antiseptic( object ob, string classification, mixed arg, int effect_enum, object effect_ob );
protected void basic_cleaning( object ob, int effect_enum, string message );
protected void apply_soap( object ob, string *applied_effects );
protected void wet_person( object ob, string *applied_effects );
private mapping _wash;
private function *_finished_funcs;
void create() {
    _wash = ([ ]);
    _finished_funcs = ({ });
    add_wash_effect( "body.smell", (: advanced_antiseptic :) );
    add_wash_effect( "misc.ketchup", (: basic_cleaning( $1, $3,
        "The soap rinses the ketchup off your face." ) :) );
    add_wash_effect( "object.label", (: basic_cleaning( $1, $3,
        "The labels stuck to your body peel off in the water." ) :) );
    add_wash_effect( "body.frog-adhesive", (: basic_cleaning( $1, $3,
        "The frantic ribbiting fades away as the frog adhesive washes "
        "off." ) :) );
    add_finished_func( (: apply_soap :) );
    add_finished_func( (: wet_person :) );
    this_object()->add_setup_wash_command();
}
void init() {
    this_object()->add_init_wash_command();
}
protected int add_wash_effect( string classification, function func ) {
    if ( !_wash[ classification ] ) {
        _wash[ classification ] = func;
        return 1;
    }
    return 0;
}
protected int add_finished_func( function func ) {
    _finished_funcs += ({ func });
    return 1;
}
public string *query_wash_classifications() {
    return keys( _wash );
}
protected int remove_wash_effect( string classification ) {
    if ( _wash && _wash[ classification ] ) {
        map_delete( _wash, classification );
        return 1;
    }
    return 0;
}
protected void advanced_antiseptic( object ob, string classification, int effect_enum, mixed arg, object effect_ob ) {
    tell_object( ob,
        "The antiseptic power of the soap defeats " +
        effect_ob->smell_string( ob, arg ) + ".\n" );
    ob->delete_effect( effect_enum );
}
protected void basic_cleaning( object ob, int effect_enum, string message ) {
    tell_object( ob, message + "\n" );
    ob->delete_effect( effect_enum );
}
protected void apply_soap( object ob, string *applied_effects ) {
    ob->add_effect( SOAP_EFFECT, 10000 );
}
protected void wet_person( object ob, string *applied_effects ) {
    ob->add_effect( WET_EFFECT, 250 );
}
public int wash_player( object ob ) {
    function func;
    string eff;
    string *cleaned;
    int *enums, eff_enum;
    cleaned = ({ });
    if ( !objectp( ob ) ) {
        return 0;
    }
    foreach( eff, func in _wash ) {
        enums = ob->effects_matching( eff );
        if ( sizeof( enums ) ) {
            foreach( eff_enum in enums ) {
                evaluate( func, ob, eff, eff_enum, ob->arg_of( eff_enum ),
                    ob->eff_of( eff_enum ) );
            }
            cleaned += ({ eff });
        }
    }
    foreach( func in _finished_funcs ) {
        evaluate( func, ob, cleaned );
    }
    return 1;
}
int query_baths() {
    return 1;
}

==================================================
FILE: room/inherit/club_control_room.c
==================================================

#include <clubs.h>
#include <money.h>
#include <move_failures.h>
#include <player_handler.h>
inherit "/std/basic/club_listing";
inherit "/std/room/inherit/club_discuss";
private int _percentage_cut;
private int _room_type;
private string _region;
protected int do_create(string name);
protected int do_create_family(string name);
protected int do_replace(string name);
protected int do_vote(string name, string position, string club);
protected int do_nominate(string name, string position, string club);
protected int do_balance(string name);
protected int do_deposit(string mon, string name, string account, string reason);
protected int do_change(string name, string type);
protected int do_change_option(string name, string type);
protected int do_disband(string name);
protected int do_insignia(string number, int num);
protected int do_recruiter_add(string name, string recruit);
protected int do_recruiter_remove(string name, string recruit);
protected int do_financials(string name, string account);
protected int do_describe(string name);
protected int do_club_list_member(string name);
protected int do_withdrawl(string money, string club, string account, string reason);
protected int do_transfer(string money, string club, string from_account,
                          string to_account, string reason);
protected int do_force_election(string name);
protected void finish_description(string describe, string name);
protected int do_announcement(string name);
private int check_member_func(string club, string person, string mem);
mixed query_property(string name);
void add_help_file(string name);
void create() {
   _percentage_cut = 5;
   _room_type = CLUB_ROOM_CLUB_OR_FAMILY;
}
private int club_commands_allowed() {
   return _room_type != CLUB_ROOM_FAMILY_ONLY;
}
private int family_commands_allowed() {
   return _room_type != CLUB_ROOM_CLUB_ONLY;
}
void init() {
   string bit;
   if (club_commands_allowed()) {
      add_help_file("club_control_room");
      bit = "club name";
      add_command("create", "club called <string'club name'>",
                  (: do_create($4[0]) :));
      add_command("list", "clubs",
                  (: club_list(this_player()->query_name(), 0, 0) :) );
      add_command("list", "clubs [with member] <string'member name'>",
                  (: do_club_list_member($4[0]) :));
      add_command("list", "club <string'club name'>",
                  (: club_info($4[0], 1, this_player()->query_name()) :) );
      add_command("vote",
                  "<word'person'> for <string:small'position'> in <string'club name'>",
                  (: do_vote($4[0], $4[1], $4[2]) :));
      add_command("nominate",
                  "<word'person'> for <string:small'position'> in <string'club name'>",
                  (: do_nominate($4[0], $4[1], $4[2]) :));
      add_command("disband", "<string'club name'>", (: do_disband($4[0]) :));
      add_command("change", "<string'club name'> to {elected}",
                   (: do_change($4[0], "elected") :) );
      add_command("change", "<string'club name'> option {secret|open}",
                      (: do_change_option($4[0], $4[1]) :) );
      add_command("replace", "<number> insignia for <string'club name'>",
                      (: do_insignia($4[1], $4[0]) :));
      add_command("replace", "insignia for <string'club name'>",
                      (: do_insignia($4[0], 1) :));
      add_command("recruiter", "add <string'member'> for <string'club'>",
                      (: do_recruiter_add($4[1], $4[0]) :));
      add_command("recruiter", "remove <string'member'> for <string'club'>",
                      (: do_recruiter_remove($4[1], $4[0]) :));
      add_command("financials", "<string'club'>",
                      (: do_financials($4[0], CLUB_DEFAULT_ACCOUNT_NAME) :));
      add_command("financials", "<string'club'> account <string'account name'>",
                      (: do_financials($4[0], $4[1]) :));
      add_command("description", "of club <string'club name'>",
                   (: do_describe($4[0]) :));
      add_command("announce", "for club <string'club name'>",
                  (: do_announcement($4[0]) :));
      add_command("withdraw", "<string'money'> from <string'club name'> for <string:small'reason'>",
                  (: do_withdrawl($4[0], $4[1], CLUB_DEFAULT_ACCOUNT_NAME, $4[2]) :));
      add_command("withdraw", "<string'money'> from <string'club name'> for <string:quoted'reason'>",
                  (: do_withdrawl($4[0], $4[1], CLUB_DEFAULT_ACCOUNT_NAME, $4[2]) :));
      add_command("withdraw", "<string'money'> from <string'club name'> account <string'account name'> for <string:small'reason'>",
                  (: do_withdrawl($4[0], $4[1], $4[2], $4[3]) :));
      add_command("withdraw", "<string'money'> from <string'club name'> account <string'account name'> for <string:quoted'reason'>",
                  (: do_withdrawl($4[0], $4[1], $4[2], $4[3]) :));
      add_command("transfer", "<string'money'> from <string'club name'> account <string'source account'> to <string'desination account'> for <string:small'reason'>",
                  (: do_transfer($4[0], $4[1], $4[2], $4[3], $4[4]) :));
      add_command("transfer", "<string'money'> from <string'club name'> account <string'source account'> to <string'desination account'> for <string:quoted'reason'>",
                  (: do_transfer($4[0], $4[1], $4[2], $4[3], $4[4]) :));
      add_command("election", "force in <string'club'>",
                  (: do_force_election($4[0]) :));
      club_discuss::init();
   }
   if (family_commands_allowed()) {
      add_help_file("family_control_room");
      if (bit) {
         bit += "|family name";
      } else {
         bit = "family name";
      }
      add_command("create", "family called <string'family name'>",
                  (: do_create_family($4[0]) :));
      add_command("list", "families",
                  (: club_list(this_player()->query_name(), 1, 0) :) );
      add_command("list", "family <string'family name'>",
                  (: family_info($4[0], this_player()->query_name()) :) );
   }
   add_command("description", "of <string'" + bit + "'>",
                (: do_describe($4[0]) :));
   add_command("balance", "[of] <string'" + bit  +"'>",
               (: do_balance($4[0]) :));
   add_command("deposit", "<string:small'money'> to <string'" + bit + "'>",
               (: do_deposit($4[0], $4[1], CLUB_DEFAULT_ACCOUNT_NAME, 0) :));
   add_command("deposit", "<string:small'money'> to <string'" + bit + "'> for <string:small'reason'>",
               (: do_deposit($4[0], $4[1], CLUB_DEFAULT_ACCOUNT_NAME, $4[2]) :));
   add_command("deposit", "<string:small'money'> to <string'" + bit + "'> account <string'account name'>",
               (: do_deposit($4[0], $4[1], $4[2], 0) :));
   add_command("deposit", "<string:small'money'> to <string'" + bit + "'> account <string'account name'> for <string:small'reason'>",
               (: do_deposit($4[0], $4[1], $4[2], $4[3]) :));
}
int is_valid_club_name(string name) {
   int i;
   if (strlen(name) > CLUB_MAX_NAME_LEN) {
      return 0;
   }
   for (i = 0; i < strlen(name); i++) {
      if (!((name[i] >= 'a' && name[i] <= 'z') ||
            (name[i] >= 'A' && name[i] <= 'Z') ||
            name[i] == '\'' ||
            name[i] == ' ' ||
            name[i] == '_')) {
          return 0;
       }
   }
   return 1;
}
void set_club_control_type(int room_type) {
   _room_type = room_type;
}
int query_club_control_type() {
   return _room_type;
}
void set_club_region(string region) {
   _region = region;
}
string query_club_region() {
   return _region;
}
protected int do_create(string name) {
   string place;
   if (CLUB_HANDLER->is_club(name)) {
      add_failed_mess("Cannot create '" + name + "' as the name already "
                      "exists.\n");
      return 0;
   }
   if (!is_valid_club_name(name)) {
      add_failed_mess("The club name '" + name + "' has invalid characters in "
                      "it.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (this_player()->query_value_in(place) < CLUB_STARTUP_COST) {
      add_failed_mess("You need " +
                      MONEY_HAND->money_value_string(CLUB_STARTUP_COST, place) +
                      " to start a club.\n");
      return 0;
   }
   write("It will cost you " +
         MONEY_HAND->money_value_string(CLUB_STARTUP_COST, place) +
         " to create a club.  Double check the capitalization of " +
         name + ", you cannot change it after it is created.  "
         "Do you wish to continue? ");
   input_to("confirm_create", 0, name);
   return 1;
}
protected void confirm_create(string str, string name) {
   object badge;
   string place;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   str = lower_case(str);
   if (strlen(str) < 1 ||
       (str[0] != 'n' && str[0] != 'y' && str[0] != 'q')) {
      write("Please answer yes or no.\nDo you wish to continue creating "
            "the club " + name + " for " +
            MONEY_HAND->money_value_string(CLUB_STARTUP_COST, place) +
            "? ");
      input_to("confirm_create", 0, name);
      return ;
   }
   if (str[0] == 'n' || str[0] == 'q') {
      write("Aborted.\n");
      return ;
   }
   if (this_player()->query_value_in(place) < CLUB_STARTUP_COST) {
      write("Your money appears to have evaporated.  You need " +
                      MONEY_HAND->money_value_string(CLUB_STARTUP_COST, place) +
                      " to start a club.\nAborting club creation.\n");
      return 0;
   }
   if (CLUB_HANDLER->create_club(name,
                                 this_player()->query_name(),
                                 CLUB_PERSONAL,
                                 query_club_region())) {
      this_player()->pay_money(MONEY_HAND->create_money_array(CLUB_STARTUP_COST,
                                                           place), place);
      write("Created the club called '" + name + "'.\n");
      badge = clone_object(CLUB_BADGE);
      badge->set_club(name);
      if (badge->move(this_player()) == MOVE_OK) {
         if (!this_player()->wear_armour(badge)) {
            write("You notice a badge turn up and wear itself, this is your "
                  "membership badge.\n");
         } else {
            write("You notice a badge turn up and attempt to wear itself, "
                  "this is your membership badge.\n");
         }
      } else {
         badge->move(environment(this_player()));
         badge->set_worn_by(this_player());
         write("You notice a badge turn up and wear itself, this is your "
               "membership badge.\n");
      }
      event(users(), "inform", this_player()->query_cap_name() +
                     " created the club " + name, "club");
   }
}
int is_valid_family_name(string name) {
  if (PLAYER_HANDLER->test_user(lower_case(name))) {
    add_failed_mess("Cannot use the family name '" + name + "' since "
        "a player is already using it.\n");
    return 0;
  }
  if(!PLAYER_HANDLER->test_valid(name)) {
    add_failed_mess("The family name '" + name + "' is invalid.\n");
    return 0;
  }
  if (!is_valid_club_name(name)) {
    if (this_player()->query_creator()) {
      add_failed_mess("invalid.\n");
    }
    add_failed_mess("The family name '" + name + "' has invalid characters "
                    "in it.\n");
    return 0;
  }
  if (strlen(name) > MAX_FAMILY_NAME_LEN) {
    if (this_player()->query_creator()) {
      add_failed_mess("too long!\n");
    }
    add_failed_mess("The maximum length of a family name is " +
                    MAX_FAMILY_NAME_LEN + ".\n");
    return 0;
  }
  return 1;
}
protected int do_create_family(string name) {
   string place;
   if (CLUB_HANDLER->is_club(name)) {
      if (this_player()->query_creator()) {
         write("exist\n");
      }
      add_failed_mess("Cannot create '" + name + "' as the name already "
                      "exists.\n");
      return 0;
   }
   if(!is_valid_family_name(name))
     return 0;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (this_player()->query_value_in(place) < FAMILY_STARTUP_COST) {
      add_failed_mess("You need " +
                      MONEY_HAND->money_value_string(FAMILY_STARTUP_COST,
                                                     place) +
                      " to start a family.\n");
      return 0;
   }
   write("It will cost you " +
         MONEY_HAND->money_value_string(FAMILY_STARTUP_COST, place) +
         " to create a family.  Do you wish to continue? ");
   input_to("confirm_create_family", 0, name);
   return 1;
}
protected void confirm_create_family(string str, string name) {
   string place;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   str = lower_case(str);
   if (strlen(str) < 1 ||
       (str[0] != 'n' && str[0] != 'y' && str[0] != 'q')) {
      write("Please answer yes or no.\nDo you wish to continue creating "
            "the family " + name + " for " +
            MONEY_HAND->money_value_string(FAMILY_STARTUP_COST, place) +
            "? ");
      input_to("confirm_create_family", 0, name);
      return ;
   }
   if (str[0] == 'n' || str[0] == 'q') {
      write("Aborted.\n");
      return ;
   }
   if (this_player()->query_value_in(place) < FAMILY_STARTUP_COST) {
      write("Your money appears to have evaporated.  You need " +
            MONEY_HAND->money_value_string(FAMILY_STARTUP_COST, place) +
            " to start a family.\nAborting family creation.\n");
      return 0;
   }
   if (CLUB_HANDLER->create_club(name,
                                 this_player()->query_name(),
                                 CLUB_FAMILY,
                                 query_club_region())) {
      if (this_player()->query_family_name()) {
         CLUB_HANDLER->move_family_member(this_player()->query_family_name(),
                                          this_player()->query_name(),
                                          name);
      } else {
         CLUB_HANDLER->add_member(name, this_player()->query_name());
      }
      this_player()->pay_money(MONEY_HAND->create_money_array(FAMILY_STARTUP_COST,
                                                              place), place);
      write("Created the family called '" + name + "'.\n");
      this_player()->set_family_name(name);
      event(users(), "inform", this_player()->query_cap_name() +
                     " created the family " + name, "club");
   }
}
protected int do_nominate(string person, string position, string club_name) {
   string our_name;
   our_name = this_player()->query_name();
   if (!CLUB_HANDLER->is_member_of(club_name, our_name)) {
      add_failed_mess("You can only nominate people in a club your a "
                      "member of.\n");
      return 0;
   }
   person = lower_case(person);
   if (!CLUB_HANDLER->is_member_of(club_name, person)) {
      person = this_player()->expand_nickname(person);
   }
   if (!CLUB_HANDLER->is_member_of(club_name, person)) {
      add_failed_mess("You can only nominate people in the club.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_election_in_progress(club_name)) {
      add_failed_mess("This club is not having an election right now.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_voting_in_progress(club_name)) {
      add_failed_mess("This club is not accepting nominations right now, "
                      "it is past the nomination phase.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_nomination_in_progress(club_name)) {
      add_failed_mess("This club not in the nomination phase of "
                      "voting.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_valid_position(club_name, position)) {
      add_failed_mess("You must nominate them in a valid position.\n"
                      "Valid positions are " +
                      sort_and_capitalise(CLUB_HANDLER->query_valid_positions(club_name)) +
                      ".\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_nomination_in_progress(club_name)) {
      add_failed_mess("This club is not accepting nominations for positions "
                      "right now.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_creator_club(club_name) &&
       PLAYER_HANDLER->test_creator(person)) {
      add_failed_mess("You cannot nominate a creator to a position in a "
                      "non-creator club.\n");
      return 0;
   }
   if (CLUB_HANDLER->has_nominated_person(club_name,
                                           position,
                                           person,
                                           our_name)) {
      add_failed_mess("You have already nominated " + capitalize(person) +
                      " for the position " + capitalize(position) + " in '" +
                      CLUB_HANDLER->query_club_name(club_name) + "'.\n");
      return 0;
   }
   if (CLUB_HANDLER->nominate_person(club_name,
                                     position,
                                     person,
                                     our_name)) {
      add_succeeded_mess( ({
                      "$N nominated " + capitalize(person) + " to " +
            capitalize(position) + " in " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n",
                      "$N nominated " + capitalize(person) + " to " +
            capitalize(position) + " in " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n" }) );
      if (find_player(lower_case(person)) &&
          environment(find_player(lower_case(person))) != this_object()) {
         tell_object(find_player(lower_case(person)),
                     "You have a weird feeling that " +
                     this_player()->the_short() +
                     " just nominated you for " + capitalize(position) +
                     ".\n");
      }
      return 1;
   }
   add_failed_mess("Unable to nominate " + person + " to " +
                   position + " in '" +
                   CLUB_HANDLER->query_club_name(club_name) + "'.\n");
   return 0;
}
protected int do_vote(string person, string position, string club_name) {
   string our_name;
   string *stuff;
   our_name = this_player()->query_name();
   if (!CLUB_HANDLER->is_member_of(club_name, our_name)) {
      add_failed_mess("You can only vote for people in a club you're a "
                      "member of.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_member_of(club_name, person)) {
      person = this_player()->expand_nickname(person);
   }
   if (!CLUB_HANDLER->is_member_of(club_name, person)) {
      add_failed_mess("You can only vote for people in the club.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_election_in_progress(club_name)) {
      add_failed_mess("This club is not having an election at the moment.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_nomination_in_progress(club_name)) {
      add_failed_mess("This club is accepting nominations right now, "
                      "it is not ready for votes.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_voting_in_progress(club_name)) {
      add_failed_mess("This club is not accepting votes right now.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_valid_position(club_name, position)) {
      add_failed_mess("You must vote for them in a valid position.\n"
                      "Valid positions are " +
                      sort_and_capitalise(CLUB_HANDLER->query_valid_positions(club_name)) +
                      ".\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_nominated_for(club_name, position, person)) {
      stuff =  CLUB_HANDLER->query_nominated_for(club_name, position);
      if (sizeof(stuff)) {
         add_failed_mess("You must vote for a person that has been "
                         "nominated for the position.\n" +
                         sort_and_capitalise(stuff) +
                         " have been nominated for " + position + " in " +
                         club_name + ".\n");
      } else {
         add_failed_mess("No one has been nominated for the position "
                         + position + " in " + club_name + ".\n");
      }
      return 0;
   }
   if (CLUB_HANDLER->has_person_voted(club_name, position, our_name)) {
      add_failed_mess("You can only vote for each position once.\n");
      return 0;
   }
   if (CLUB_HANDLER->vote_for_person(club_name,
                                     position,
                                     person,
                                     our_name)) {
      add_succeeded_mess(({
                      "$N vote for $C$" + person + " to " + position + " in " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n",
                      "$N voted for " + position + " in " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n" }));
      return 1;
   }
   add_failed_mess("Unable vote for " + person + " to " +
                   position + " in " + club_name +
            CLUB_HANDLER->query_club_name(club_name) + ".\n");
   return 0;
}
protected int do_balance(string name) {
   string place;
   int amount;
   string bit;
   string *accounts;
   string account;
   string account_name;
   string ret;
   if (club_commands_allowed()) {
      bit = "club";
   }
   if (family_commands_allowed()) {
      if (bit) {
         bit += " or family";
      } else {
         bit = "family";
      }
   }
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must get a balance of an existing " + bit + ".\n");
      return 0;
   }
   if (CLUB_HANDLER->is_family(name)) {
      bit = "family";
   } else {
      bit = "club";
   }
   if (!CLUB_HANDLER->is_member_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a member of the " + bit +
                      " to get the balance.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   accounts = CLUB_HANDLER->query_account_names(name);
   ret = "";
   foreach (account in accounts) {
      if (account == CLUB_DEFAULT_ACCOUNT_NAME) {
         account_name = "main " + bit + " account";
      } else {
         account_name = "special " + bit + " account " + account;
      }
      amount = CLUB_HANDLER->query_balance(name, account);
      if (amount < 0) {
         ret += "The balance of the " + account_name + " in '" +
                CLUB_HANDLER->query_club_name(name) +
                "' is in remission by " +
                MONEY_HAND->money_value_string(-amount, place) + ".\n";
      } else {
         ret += "The balance of the " + account_name + " in '" +
                CLUB_HANDLER->query_club_name(name) + "' is " +
                MONEY_HAND->money_value_string(amount, place) + ".\n";
      }
   }
   ret += "The next pay period ends at " +
          ctime(CLUB_HANDLER->query_time_fees_due(name)) +
          ", which will cost " +
          MONEY_HAND->money_value_string(CLUB_HANDLER->query_club_cost_per_period(name), place) + " from the main " + bit + " account.\n",
   add_succeeded_mess(({ ret,
                      "$N checks the balance of '" +
                      CLUB_HANDLER->query_club_name(name) + "'.\n" }));
   return 1;
}
protected int do_deposit(string mon, string name, string account, string reason) {
   int amt;
   int after;
   int total;
   string place;
   mixed money;
   string bit;
   string account_name;
   if (club_commands_allowed()) {
      bit = "club";
   }
   if (family_commands_allowed()) {
      if (bit) {
         bit += " or family";
      } else {
         bit = "family";
      }
   }
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must deposit into an existing " + bit + ".\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_member_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a member of the " + bit +
                      " to deposit into the clubs coffers.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_creator_club(name) &&
       this_player()->query_creator()) {
      add_failed_mess("Creators can only deposit to creator " + bit + "s.\n");
      return 0;
   }
   if (account == CLUB_DEFAULT_ACCOUNT_NAME) {
      account_name = "main " + bit + " account";
   } else {
      account_name = "special " + bit + " account " + account;
   }
   if (!CLUB_HANDLER->is_account_of(name, account)) {
      add_failed_mess("The account " + account_name + " is not in the " +
                      bit + " '" + CLUB_HANDLER->query_club_name(name) + "'\n");
      return 0;
   }
   if (strlen(reason) > 60) {
      add_failed_mess("The reason must be less than 60 characters.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   money = MONEY_HAND->parse_money(mon, this_player(), place);
   if (intp(money)) {
      switch (money) {
         case NO_MATCH :
            add_failed_mess("You do not have '" + mon + "'.\n");
            return 0;
         case NO_MONEY :
            add_failed_mess("You can only deposit money.\n");
            return 0;
         default :
            add_failed_mess("You can only deposit legal tender.\n");
            return 0;
      }
   }
   amt = money->query_value_in(place);
   if (place != "default") {
      amt += money->query_value_in("default");
   }
   after = amt - ((amt * _percentage_cut) / 100);
   CLUB_HANDLER->add_money(name,
                           after,
                           CLUB_TRANSACTION_DEPOSIT,
                           this_player()->query_name(),
                           account,
                           reason);
   total = CLUB_HANDLER->query_balance(name, account);
   money->move("/room/rubbish");
   add_succeeded_mess(({ "$N deposit " +
                         MONEY_HAND->money_value_string(amt, place) +
                         ", which after expenses is " +
                         MONEY_HAND->money_value_string(after, place) +
                         ", to the " +
                         (CLUB_HANDLER->is_family(name) ? "family" : "club") +
                         " '" +
                         CLUB_HANDLER->query_club_name(name) +
                         "' for a total of " +
                         MONEY_HAND->money_value_string(total, place) + ".\n",
                         "$N deposits some money to the " +
                         (CLUB_HANDLER->is_family(name) ? "family" : "club") +
                         " '" +
                         CLUB_HANDLER->query_club_name(name) +
                         "'.\n" }));
   return 1;
}
protected int do_withdrawl(string money,
                           string name,
                           string account,
                           string reason) {
   string place;
   int value;
   string bit;
   object obj;
   string account_name;
   string* stuff;
   string ret;
   if (club_commands_allowed()) {
      bit = "club";
   }
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must withdraw from an existing " + bit + ".\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_member_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a member of the " + bit +
                      " to withdraw money from the club.\n");
      return 0;
   }
   if (account == CLUB_DEFAULT_ACCOUNT_NAME) {
      account_name = "main " + bit + " account";
   } else {
      account_name = "special " + bit + " account " + account;
   }
   if (!CLUB_HANDLER->is_account_of(name, account)) {
      add_failed_mess("The account " + account_name + " is not in the " +
                      bit + " '" + CLUB_HANDLER->query_club_name(name) + "'\n");
      return 0;
   }
   if (strlen(reason) > 60) {
      add_failed_mess("The reason must be less than 60 characters.\n");
      return 0;
   }
    if(!CLUB_HANDLER->is_elected_club(name)) {
        add_failed_mess("You may only withdraw funds from an elected "
            "club.\n");
        return 0;
    }
   if (!CLUB_HANDLER->is_allowed_to_modify_account(name,
                                                   account,
                                                   this_player()->query_name())) {
      stuff = CLUB_HANDLER->query_account_allowed_positions(name, account);
      ret = "Only the positions " + query_multiple_short(stuff);
      stuff = CLUB_HANDLER->query_account_allowed_people(name, account);
      if (sizeof(stuff)) {
         ret += " and the people " + query_multiple_short(stuff);
      }
      add_failed_mess(ret + " can withdraw from this account.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   value = MONEY_HAND->value_from_string(money, place);
   if (value > CLUB_HANDLER->query_balance(name, account)) {
      add_failed_mess("The " + account_name +
                      " does not have that much money!\n");
      return 0;
   }
   obj = MONEY_HAND->make_new_amount(value, place);
   if (!obj) {
      add_failed_mess("Unable to create the money object.\n");
      return 0;
   }
   if (CLUB_HANDLER->remove_money(name,
                              value,
                              CLUB_TRANSACTION_WITHDRAWL,
                              this_player()->query_name(),
                              account,
                              reason)) {
      obj->move(this_player());
      add_succeeded_mess(({ "$N withdraw " +
                            MONEY_HAND->money_value_string(value, place) +
                            " from the " +
                            (CLUB_HANDLER->is_family(name) ? "family" : "club") +
                            " '" +
                            CLUB_HANDLER->query_club_name(name) +
                            "'.\n",
                            "$N withdraws some money from the " +
                            (CLUB_HANDLER->is_family(name) ? "family" : "club") +
                            " '" +
                            CLUB_HANDLER->query_club_name(name) +
                            "'.\n" }));
      return 1;
   } else {
      obj->dest_me();
      add_failed_mess("Unable to remove the money from the account.\n");
      return 0;
   }
}
protected int do_transfer(string money,
                           string name,
                           string from_account,
                           string to_account,
                           string reason) {
   string place;
   int value;
   string bit;
   object obj;
   string from_account_name;
   string to_account_name;
   string* stuff;
   string ret;
   if (club_commands_allowed()) {
      bit = "club";
   }
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must transfer money in an existing " + bit + ".\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_member_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a member of the " + bit +
                      " to transfer money.\n");
      return 0;
   }
   if (from_account == CLUB_DEFAULT_ACCOUNT_NAME) {
      from_account_name = "main " + bit + " account";
   } else {
      from_account_name = "special " + bit + " account " + from_account;
   }
   if (to_account == CLUB_DEFAULT_ACCOUNT_NAME) {
      to_account_name = "main " + bit + " account";
   } else {
      to_account_name = "special " + bit + " account " + to_account;
   }
   if (!CLUB_HANDLER->is_account_of(name, from_account)) {
      add_failed_mess("The account " + from_account_name + " is not in the " +
                      bit + " '" + CLUB_HANDLER->query_club_name(name) + "'\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_account_of(name, to_account)) {
      add_failed_mess("The account " + to_account_name + " is not in the " +
                      bit + " '" + CLUB_HANDLER->query_club_name(name) + "'\n");
      return 0;
   }
   if (strlen(reason) > 60) {
      add_failed_mess("The reason must be less than 60 characters.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_allowed_to_modify_account(name,
                                                   from_account,
                                                   this_player()->query_name())) {
      stuff = CLUB_HANDLER->query_account_allowed_positions(name, from_account);
      ret = "Only the positions " + query_multiple_short(stuff);
      stuff = CLUB_HANDLER->query_account_allowed_people(name, from_account);
      if (sizeof(stuff)) {
         ret += " and the people " + query_multiple_short(stuff);
      }
      add_failed_mess(ret + " can withdraw from this account.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   value = MONEY_HAND->value_from_string(money, place);
   if (value > CLUB_HANDLER->query_balance(name, from_account)) {
      add_failed_mess("The " + from_account_name +
                      " does not have that much money!\n");
      return 0;
   }
   if (CLUB_HANDLER->remove_money(name,
                              value,
                              CLUB_TRANSACTION_TRANSFER,
                              this_player()->query_name(),
                              from_account,
                              "to " + to_account_name + ": " + reason)) {
      CLUB_HANDLER->add_money(name,
                              value,
                              CLUB_TRANSACTION_TRANSFER,
                              this_player()->query_name(),
                              to_account,
                              "from " + from_account_name + ": " + reason);
      add_succeeded_mess(({ "$N transfer " +
                            MONEY_HAND->money_value_string(value, place) +
                            " between the " +
                            (CLUB_HANDLER->is_family(name) ? "family" : "club") +
                            " '" +
                            CLUB_HANDLER->query_club_name(name) +
                            "' accounts " + from_account_name + " and " +
                            to_account_name + ".\n",
                            "$N transfers some money between accounts in the " +
                            (CLUB_HANDLER->is_family(name) ? "family" : "club") +
                            " '" +
                            CLUB_HANDLER->query_club_name(name) +
                            "'.\n" }));
      return 1;
   } else {
      obj->dest_me();
      add_failed_mess("Unable to remove the money from the account.\n");
      return 0;
   }
}
private void do_change_inform(string club_name) {
   object *people;
   object person;
   people = map(CLUB_HANDLER->query_members(club_name), (: find_player :));
   people -= ({ 0 });
   foreach (person in people) {
      all_inventory(person)->event_club_change(this_player(), club_name);
   }
}
protected int do_change(string name, string type) {
   int ret;
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must change a club that exists.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_personal_club(name)) {
      add_failed_mess("The club must be a founder type before you can change "
                      "it to another type.\n");
      return 0;
   }
   switch (type) {
      case "elected" :
         if (CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
            if (sizeof(CLUB_HANDLER->query_members(name)) <
                CLUB_MINIMUM_ELECTED_MEMBERS) {
               add_failed_mess("You must have at least " +
                               query_num(CLUB_MINIMUM_ELECTED_MEMBERS) +
                               " members to change to an elected club.\n");
            } else if (CLUB_HANDLER->change_club_type(name, CLUB_ELECTED)) {
               ret = 1;
               add_succeeded_mess("$N change$s the type of '" +
                                  CLUB_HANDLER->query_club_name(name) +
                                  "' to elected.\n");
               call_out((: do_change_inform :), 0, name);
            } else {
               add_failed_mess("You are unable to change the club type.\n");
            }
         } else {
            add_failed_mess("You must be the founder to change the "
                            "club type.\n");
         }
         break;
   }
   return ret;
}
protected int do_change_option(string name, string option) {
   int ret;
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must change a club that exists.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_elected_club(name)) {
      add_failed_mess("You must change options through discussion items.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_personal_club(name) &&
       !CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
      add_failed_mess("You must be the founder of the club to change the "
                      "options of the club.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_personal_club(name)) {
      add_failed_mess("The club must be a personal club before the options "
                      "can be changed in this way.\n");
      return 0;
   }
   switch (option) {
      case "secret" :
         if (CLUB_HANDLER->set_club_secret(name)) {
            add_succeeded_mess("$N wipe$s the records on the club '" +
                            CLUB_HANDLER->query_club_name(name) + "'.\n");
            ret = 1;
         } else {
            add_failed_mess("Unable to change the club to a secret type.\n");
         }
         break;
      case "open" :
         if (CLUB_HANDLER->reset_club_secret(name)) {
            add_succeeded_mess("$N replace$s the records of the club '" +
                            CLUB_HANDLER->query_club_name(name) + "'.\n");
            ret = 1;
         } else {
            add_failed_mess("Unable to change the club to an open type.\n");
         }
         break;
   }
   return ret;
}
protected int do_disband(string name) {
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must disband a club that exists.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_elected_club(name)) {
      add_failed_mess("You cannot disband an elected club.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_personal_club(name)) {
      add_failed_mess("The club must be a personal club type for you to "
                      "be able to disband it.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
      add_failed_mess("You must be the founder of the club to disband it.\n");
      return 0;
   }
   write("Are you sure you wish to disband the club '" +
         CLUB_HANDLER->query_club_name(name) +
         "'? ");
   input_to("disband_confirm", 0, name);
   add_succeeded_mess("");
   return 1;
}
protected void disband_confirm(string str, string name) {
   string club_name;
   str = lower_case(str);
   if (str == "" ||
       str[0] == 'n' ||
       str[0] == 'q') {
      write("Canceling disbanding of the club '" + name + "'.\n");
      return ;
   }
   if (str[0] == 'y') {
      if (!CLUB_HANDLER->is_club(name)) {
         write("The club appears to have been disbanded already.\n");
         return 0;
      }
      if (CLUB_HANDLER->is_elected_club(name)) {
         write("The club has changed to an elected club and you cannot "
               "disband it.\n");
         return 0;
      }
      if (!CLUB_HANDLER->is_personal_club(name)) {
         write("The club must be a personal club for you to be able to "
                         "disband it.\n");
         return 0;
      }
      if (!CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
         write("You must be the founder of the club to disband it.\n");
         return 0;
      }
      club_name = CLUB_HANDLER->query_club_name(name);
      CLUB_HANDLER->disband_club(name);
      write("You disband the club '" + club_name + "'.\n");
      say(this_player()->the_short() + " disbands the club '" +
                      club_name + "'.\n");
   } else {
      write("You must answer yes or no.\n");
      write("Are you sure you wish to disband the club '" +
            CLUB_HANDLER->query_club_name(name) +
            "'? ");
      input_to("disband_confirm", 0, name);
   }
}
protected int do_insignia(string name, int num) {
   int i;
   object *insignias;
   object ob;
   string place;
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must create the insignia for a club that exists.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_family(name)) {
      add_failed_mess("You cannot create insignia for a family.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_member_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a member of the club to create the "
                      "insignia for it.\n");
      return 0;
   }
   if (num > 1 &&
       !CLUB_HANDLER->is_recruiter_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a recruiter to ask for more than one "
                      "insignia.\n");
      return 0;
   }
   if (num > 20) {
      add_failed_mess("You cannot ask for more than 20 insignia.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (this_player()->query_value_in(place) < (num * CLUB_COST_INSIGNIA)) {
      add_failed_mess("You need " +
                      MONEY_HAND->money_value_string(CLUB_COST_INSIGNIA * num, place) +
                      " to pay for " +
                      query_num(num) + " insignia.\n");
      return 0;
   }
   insignias = ({ });
   for (i = 0; i < num; i++) {
      ob = clone_object(CLUB_HANDLER->query_insignia_path(name));
      ob->set_cond(ob->query_max_cond());
      ob->set_club(name);
      if (ob->move(this_player()) == MOVE_OK) {
         insignias += ({ ob });
         this_player()->pay_money(MONEY_HAND->create_money_array(CLUB_COST_INSIGNIA,
                                                           place), place);
      } else {
         ob->dest_me();
      }
   }
   if (!sizeof(insignias)) {
      add_failed_mess("Unable to move the insignia into your inventory, "
                      "insignia not created.\n");
      return 0;
   } else {
      add_succeeded_mess("$N create$s " + query_num(sizeof(insignias)) +
                         " club '" + CLUB_HANDLER->query_club_name(name) +
                         "' insignia.\n");
      return 1;
   }
}
protected int do_recruiter_remove(string name,
                                  string recruit) {
   string *all_names;
   string one_name;
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must remove a recruiter to a club that exists.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_personal_club(name)) {
      if (!CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
         add_failed_mess("Only the founder can remove recruiters.\n");
         return 0;
      }
   } else if (CLUB_HANDLER->is_elected_club(name)) {
      if (!CLUB_HANDLER->is_president_of(name, this_player()->query_name()) &&
          !CLUB_HANDLER->is_vice_president_of(name, this_player()->query_name())) {
         add_failed_mess("Only the president and vice president can remove "
                         "recruiters.\n");
         return 0;
      }
   } else {
      add_failed_mess("Unknown club type.\n");
      return 0;
   }
   all_names = map(explode(recruit, ","),
                   (: this_player()->expand_nickname($1) :));
   if (recruit == "all") {
      all_names = CLUB_HANDLER->query_recruiters(name);
   }
   foreach (one_name in all_names) {
      if (!CLUB_HANDLER->is_recruiter_of(name, one_name)) {
         add_failed_mess("The person(s) you are removeing must be a recruiter "
                         " of the club.\n");
         all_names -= ({ name });
         continue;
      }
      CLUB_HANDLER->remove_recruiter(name, one_name);
      one_name = lower_case(one_name);
      if (find_player(one_name) &&
          environment(find_player(one_name)) != this_object()) {
         tell_object(find_player(one_name), "You feel suddenly feel like "
                     "you are unable to "
                     "recruit people into the club '" +
                     CLUB_HANDLER->query_club_name(name) +
                     "'.\n");
      }
   }
   if (!sizeof(all_names)) {
      return 0;
   }
   add_succeeded_mess("$N remove$s " + query_multiple_short(all_names) +
                      " as " +
                      (sizeof(all_names) > 1 ? "recruiters " : "a recruiter ") +
                      "to the club '" + CLUB_HANDLER->query_club_name(name) +
                      "'.\n");
   return 1;
}
protected int do_recruiter_add(string name, string recruit) {
   string *all_names;
   string one_name;
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("You must add a recruiter to a club that exists.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_personal_club(name)) {
      if (!CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
         add_failed_mess("Only the founder can add recruiters.\n");
         return 0;
      }
   } else if (CLUB_HANDLER->is_elected_club(name)) {
      if (!CLUB_HANDLER->is_president_of(name, this_player()->query_name()) &&
          !CLUB_HANDLER->is_vice_president_of(name, this_player()->query_name())) {
         add_failed_mess("Only the president and vice president can add "
                         "recruiters.\n");
         return 0;
      }
   } else {
      add_failed_mess("Unknown club type.\n");
      return 0;
   }
   all_names = map(explode(recruit, ","),
                   (: this_player()->expand_nickname($1) :));
   if (recruit == "all") {
      all_names = CLUB_HANDLER->query_members(name);
   }
   foreach (one_name in all_names) {
      if (!CLUB_HANDLER->is_member_of(name, one_name)) {
         add_failed_mess("The person you are making a recruiter must be a "
                         "member of the club.\n");
         all_names -= ({ one_name });
         continue;
      }
      if (CLUB_HANDLER->is_recruiter_of(name, one_name)) {
         add_failed_mess("The person you are making a recruiter is already a "
                         "recruiter of the club.\n");
         all_names -= ({ one_name });
         continue;
      }
      CLUB_HANDLER->add_recruiter(name, one_name);
      one_name = lower_case(one_name);
      if (find_player(one_name) &&
          environment(find_player(one_name)) != this_object()) {
         tell_object(find_player(one_name), "You feel suddenly empowered to "
                     "recruit people into the club '" +
                     CLUB_HANDLER->query_club_name(name) +
                     "'.\n");
      }
   }
   if (!sizeof(all_names)) {
      return 0;
   }
   add_succeeded_mess("$N add$s " + query_multiple_short(all_names) +
                      (sizeof(all_names) == 1? " as a recruiter " : " as recruiters ") +
                      "to the club '" + CLUB_HANDLER->query_club_name(name) +
                      "'.\n");
   return 1;
}
protected int do_financials(string name, string account) {
   string place;
   class club_transaction* transactions;
   int i;
   int deposit_total;
   int withdrawl_total;
   string ret;
   string account_name;
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("The club '" + name + "' does not exist.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_member_of(name, this_player()->query_name())) {
      add_failed_mess("You must be a member of a club to see its "
                      "financials.\n");
      return 0;
   }
   if (account == CLUB_DEFAULT_ACCOUNT_NAME) {
      account_name = "main club account";
   } else {
      account_name = "special club account " + account;
   }
   if (!CLUB_HANDLER->is_account_of(name, account)) {
      add_failed_mess("The account " + account_name + " is not in the "
                      "club '" + CLUB_HANDLER->query_club_name(name) + "'\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   ret = "The club '" + CLUB_HANDLER->query_club_name(name) +
         "' " + account_name + " has a current balance of " +
         MONEY_HAND->money_value_string(CLUB_HANDLER->query_balance(name, account), place) +
         " and the next pay period ends at " +
         ctime(CLUB_HANDLER->query_time_fees_due(name)) +
         ", which will cost " +
         MONEY_HAND->money_value_string(CLUB_HANDLER->query_club_cost_per_period(name), place) +
         ".\n";
   transactions =  CLUB_HANDLER->query_transactions(name, account);
   for (i = 0; i < sizeof(transactions); i++) {
      if (transactions[i]->amount > 0) {
         ret += i + ": DEPOSIT " +
               MONEY_HAND->money_value_string(transactions[i]->amount, place) +
               " from " + transactions[i]->who +
               " at " + ctime(transactions[i]->date) + " (" +
               CLUB_HANDLER->query_transaction_type_name(transactions[i]->transaction_type) +
               ")\n";
         if (transactions[i]->information) {
            ret += "   - " + transactions[i]->information + "\n";
         }
         deposit_total += transactions[i]->amount;
      } else {
         ret += i + ": WITHDRAWL " +
               MONEY_HAND->money_value_string(-transactions[i]->amount, place) +
               " from " + transactions[i]->who +
               " at " + ctime(transactions[i]->date) + " (" +
               CLUB_HANDLER->query_transaction_type_name(transactions[i]->transaction_type) +
               ")\n";
         if (transactions[i]->information) {
            ret += "   - " + transactions[i]->information + "\n";
         }
         withdrawl_total += -transactions[i]->amount;
      }
   }
   ret += "\nTotal withdrawals: " +
         MONEY_HAND->money_value_string(withdrawl_total, place) + "\n";
   ret += "Total deposits  : " +
         MONEY_HAND->money_value_string(deposit_total, place) + "\n";
   write("$P$Club Financials$P$" + ret);
   return 1;
}
protected int do_describe(string name) {
   string bit;
   if (club_commands_allowed()) {
      bit = "club";
   }
   if (family_commands_allowed()) {
      if (bit) {
         bit += " or family";
      } else {
         bit = "family";
      }
   }
   if (!CLUB_HANDLER->is_club(name)) {
      add_failed_mess("The " + bit + " '" + name +
                      "' must exist for you to describe it.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_elected_club(name)) {
      add_failed_mess("You cannot change the description of an elected club, "
                      "it must be done as a discussion item.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_personal_club(name) &&
       !CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
      add_failed_mess("You must be the founder of a personal club to "
                      "change the description.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_family(name) &&
       !CLUB_HANDLER->is_founder_of(name, this_player()->query_name())) {
      add_failed_mess("Only the founder of the family can set the "
                      "description of the family.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_personal_club(name) &&
       !CLUB_HANDLER->is_family(name)) {
      add_failed_mess("Unknown club type.\n");
      return 0;
   }
   write("What do you wish to change the description of '" +
         CLUB_HANDLER->query_club_name(name) + "' to?\n");
   this_player()->do_edit("", (: finish_description($1, $(name)) :));
   add_succeeded_mess("");
   return 1;
}
protected void finish_description(string describe, string name) {
   if (!describe ||
       describe == "") {
      write("Aborting setting the description.\n");
      return ;
   }
   CLUB_HANDLER->set_club_description(name, describe);
   if (CLUB_HANDLER->is_family(name)) {
      write("Set the description of the family '" +
             CLUB_HANDLER->query_club_name(name) + "' to:\n" +
             CLUB_HANDLER->query_club_description(name) + "\n");
   } else {
      write("Set the description of the club '" +
             CLUB_HANDLER->query_club_name(name) + "' to:\n" +
             CLUB_HANDLER->query_club_description(name) + "\n");
   }
}
void set_percentage_cut(int value) {
   _percentage_cut = value;
}
int query_percentage_cut() {
   return _percentage_cut;
}
string query_club_warning_message() {
   string place;
   string ret;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   ret = "";
   if (club_commands_allowed()) {
      ret += "Clubs have a few rules and regulations associated with "
         "them.  They cost " +
         MONEY_HAND->money_value_string(CLUB_STARTUP_COST, place) +
         " to start.  Every quarter of a " + mud_name() + " year the club "
         "costs " +
         MONEY_HAND->money_value_string(CLUB_COST_PER_YEAR, place) +
         " plus " +
         MONEY_HAND->
            money_value_string(CLUB_COST_PER_MEMBER_PER_YEAR, place) +
         " per member.  Each insignia will cost " +
         MONEY_HAND->money_value_string(CLUB_COST_INSIGNIA, place) +
         " to be made, and the cost an insignia is taken from the "
         "person requesting the insignia, not the club.\n\n"
         "If the club goes into remission for 2 pay periods then the "
         "club will be disbanded.  If the club is not touched for 8 "
         "real weeks then the club will be disbanded.  A club is "
         "considered touched if a member is added or removed, if an "
         "election is held or nominations are added or if money is "
         "deposited into the account.\n\n"
         "Clubs default to being founder controlled clubs, meaning "
         "that the founder has all the control of the club.  Once a "
         "club gets over " +
         CLUB_MINIMUM_ELECTED_MEMBERS +
         " members it can change to an elected club.  In this mode "
         "the committee members of the club are elected to their "
         "positions.  Once a club gets over " +
         CLUB_MAXIMUM_ELECTED_MEMBERS + " it must become an elected "
         "club.  A new election is held every " + mud_name() + " year for all "
         "the positions.  If the founder of a founder base club leaves "
         "the mud or is idle is for 8 real weeks then the club will be "
         "disbanded.\n\n"
         "In this room, clubs can be created and disbanded.  Money can "
         "be deposited into a club, or withdrawn from a club.  It is "
         "possible to see the balance of a given club, and also to see "
         "various lists of clubs.  It is also possible to nominate "
         "someone for position, vote for someone and to force an "
         "election in a particular club.  Furthermore, announcements "
         "and discussion items for clubs can be added here.  Club "
         "insignias can be replaced, and types and options of a club "
         "can be changed.  Finding out more about a club's financials "
         "is also possible, as well as changing the description of a "
         "club.  Last, but not least, a recruiter can be added to a "
         "club.\n";
   }
   if (family_commands_allowed()) {
      ret += "Families have a few rules and regulations associated "
        "with them.  They cost " +
       MONEY_HAND->money_value_string(FAMILY_STARTUP_COST, place) +
       " to start and cost " +
       MONEY_HAND->money_value_string(FAMILY_COST_PER_YEAR, place) +
       " in upkeep every quarter of a " + mud_name() + " year, plus " +
       MONEY_HAND->
         money_value_string(FAMILY_COST_PER_MEMBER_PER_YEAR, place) +
       " per member.\n\n"
       "You can create relationships between people, and also create "
       "families.  It is possible to list families, or details about "
       "any particular "
       "family.  On a family of yours, you can set the description, "
       "see its bank balance and deposit more money into its account.  "
       "If your family balance is less than the required amount when "
       "it is time for your family to pay for its fees, the family "
       "will be disbanded.\n\n"
       "You cannot choose a family name from the books for "
       "your families.\n";
   }
   return ret;
}
protected int do_club_list_member(string name) {
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess(name + " does not play " + mud_name() + ".\n");
      return 0;
   }
   if (club_list(this_player()->query_name(),
                 0,
                 (: check_member_func($1, $2, $(name)) :))) {
      return 1;
   }
   add_failed_mess("Could not find any clubs with " + name +
                   " as a member.\n");
   return 0;
}
private void finish_announcement(string str, string name) {
   if (!str) {
      write("Aborting.\n");
      return ;
   }
   if (CLUB_HANDLER->set_announcement(name,
                                      str)) {
      write("Added the announcement to the club " +
            CLUB_HANDLER->query_club_name(name) +
            ".\n");
   } else {
      write("Unable to add the announcement to the club " +
            CLUB_HANDLER->query_club_name(name) +
            " for some reason.\n");
   }
}
protected int do_announcement(string name) {
   if (!CLUB_HANDLER->is_elected_club(name)) {
      add_failed_mess("The club must be an elected club for an announcement "
                      "to be set.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_president_of(name, this_player()->query_name()) &&
       !CLUB_HANDLER->is_secretary_of(name, this_player()->query_name())) {
      add_failed_mess("Only the president and secretary can set an "
                      "announcement.\n");
      return 0;
   }
   write("What announcement do you wish to set?\n");
   this_player()->do_edit(0,
                          (: finish_announcement :),
                          0,
                          0,
                          name);
   return 1;
}
private int check_member_func(string club,
                              string person,
                              string mem) {
   if (!CLUB_HANDLER->is_member_of(club, mem)) {
      return 0;
   }
   if (CLUB_HANDLER->query_club_secret(club) &&
       !CLUB_HANDLER->is_member_of(club, person)) {
      return 0;
   }
   return 1;
}
protected int do_force_election(string name) {
   if (!CLUB_HANDLER->is_elected_club(name)) {
      add_failed_mess("The club must be elected for you to force an "
                      "election in it.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_president_of(name, this_player()->query_name())) {
      add_failed_mess("You must be the president of the club to force an "
                      "election.\n");
      return 0;
   }
   if (CLUB_HANDLER->is_election_in_progress(name) > time()) {
      add_failed_mess("There is already an election in progress, you cannot "
                      "start another one!\n");
      return 0;
   }
   if (CLUB_HANDLER->query_minimum_next_election(name) > time()) {
      add_failed_mess("It is too soon to force an election, that cannot "
                      "be done until " +
                       ctime(CLUB_HANDLER->query_minimum_next_election(name)) +
                       ".\n");
      return 0;
   }
   if (!CLUB_HANDLER->start_election(name)) {
      add_failed_mess("Could not start the election for some reason.\n");
      return 0;
   }
   add_succeeded_mess("$N start$s an election in " +
                      CLUB_HANDLER->query_club_name(name) + ".\n");
   return 1;
}

==================================================
FILE: room/inherit/club_discuss.c
==================================================

#include <clubs.h>
#define MAX_SUBJECT_LEN 40
#define MAX_CHOICE_LEN 10
#define MIN_TIMEOUT 1
#define MAX_TIMEOUT 30
#define MIN_POSITION_LEN 5
#define SAVE_START "club_discuss -- "
#define CLUB_ALL_POSITIONS "all positions"
private void discuss_finish_description(string str, int open);
protected int do_discuss(int open, string type, string club_name);
class memo_item {
   string club_name;
   string subject;
   string description;
   string *choices;
   int timeout;
   int open;
}
void init() {
   add_command("discuss",
               "[open] {description|add position|"
               "change position name|memo|secret|"
               "remove member|no confidence|remove position|"
               "create account|remove account} in <string'club name'>",
                (: do_discuss(1, $4[0], $4[1]) :));
   add_command("discuss",
               "committee {description|add position|"
               "change position name|memo|secret|remove member|"
               "no confidence|remove position|"
               "create account|remove account} in <string'club name'>",
                     (: do_discuss(0, $4[0], $4[1]) :));
}
protected void discussion_finish_information(string info,
                                             mixed *data) {
   int type;
   string short;
   string name;
   string optional;
   string club_name;
   club_name = data[0];
   short = data[1];
   type = data[2];
   name = data[3];
   optional = data[4];
   write("Discussion item: " + short + ".\n");
   if (!info) {
      write("No description used.\n");
   } else {
      write(info);
   }
   write("\nDo you wish to add this? ");
   input_to("discussion_finish_confirm",
            0,
            club_name,
            short,
            type,
            name,
            info,
            optional);
}
protected void discussion_finish_confirm(string str,
                                         string club_name,
                                         string short,
                                         int type,
                                         string name,
                                         string info,
                                         string optional) {
   str = lower_case(str);
   if (!strlen(str) ||
       str[0] != 'y') {
      write("Aborting.\n");
      return ;
   }
   if (CLUB_HANDLER->add_discussion_item(club_name,
                                         type,
                                         this_player()->query_cap_name(),
                                         name,
                                         info,
                                         ({ }),
                                         2 * (7 * 24 * 60 * 60),
                                         optional)) {
      write("Added in the discussion item: " + short + ".\n");
   } else {
      write("Unable to add in the discussion item: " + short + ".\n");
   }
}
protected int do_discuss_description(int open,
                                     string club_name) {
   if (CLUB_HANDLER->query_discussion_item_by_type(club_name,
                                                   CLUB_DISCUSS_DESCRIPTION,
                                                   0)) {
      add_failed_mess("A description is already being discussed, you can only "
                      "discuss one description at a time.\n");
      return 0;
   }
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee "
            "only!\n%^RESET%^");
   }
   write("Please enter the description you wish to have discussed as the "
         "new description of the club '" +
         CLUB_HANDLER->query_club_name(club_name) + "'.\n");
   this_player()->do_edit(CLUB_HANDLER->query_description(club_name),
                          (: discuss_finish_description :),
                          0,
                          0,
                          ({ open,
                             club_name }));
   return 1;
}
private void discuss_finish_description(string str, mixed *junk) {
   int open;
   string club_name;
   if (!str) {
      write("Description aborted.\n");
      return ;
   }
   open = junk[0];
   club_name = junk[1];
   write("Adding the description:\n" + str +
         "\nIs this the correct description (yes/no/edit)? ");
   input_to("description_confirm", 0, str, open, club_name);
}
protected void description_confirm(string confirm, string str, int open, string club_name) {
   confirm = lower_case(confirm);
   if (strlen(confirm) &&
       confirm[0] == 'e') {
      this_player()->do_edit(str,
                             (: discuss_finish_description :),
                             0,
                             0,
                             ({ open, club_name }));
      return ;
   }
   if (!strlen(confirm) ||
       confirm[0] != 'y') {
      write("Aborting.\n");
      return ;
   }
   if (CLUB_HANDLER->add_discussion_item(club_name,
                                         CLUB_DISCUSS_DESCRIPTION | open,
                                         this_player()->query_name(),
                                         "Change club description",
                                         str,
                                         ({ }),
                                         2 * (7 * 24 * 60 * 60),
                                         0)) {
      write("Successfuly added the item for discussion.\n");
   } else {
      write("Unable to add the item for discussion.\n");
   }
}
protected int do_discuss_add_position(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("What committee position do you wish to add to the club '" +
         club_name + "'? ");
   input_to("discussion_add_name", 0, open, club_name);
   return 1;
}
protected void discussion_add_name(string str, int open, string club_name) {
   if (!str ||
       !strlen(str)) {
      write("Aborting.\n");
      return ;
   }
   str = strip_colours(str);
   if (CLUB_HANDLER->is_valid_position(club_name,
                                       str)) {
      write("The position '" + str + "' already exists in the club.  You "
            "cannot add it.\nAborting.\n");
      return ;
   }
   if (strlen(str) > CLUB_MAX_POSITION_NAME) {
      write("The position name '" + str + "' is too long, it can be a "
            "maximum length of " + CLUB_MAX_POSITION_NAME +
            ".\nAborting.\n");
      return ;
   }
   if (strlen(str) < MIN_POSITION_LEN) {
      write("The position name '" + str + "' is too short, the minimum is " +
            MIN_POSITION_LEN + ".\n");
      return;
   }
   write("What message do you wish display as to why you wish this position "
         "added?\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Adding the position " + str,
                                CLUB_DISCUSS_NEW_POSITION | open,
                                str,
                                0 }) );
}
protected int do_discuss_remove_member(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("Which member to do you wish to try and remove? ");
   input_to("discussion_remove_member_name", 0, open, club_name);
   return 1;
}
protected void discussion_remove_member_name(string str, int open, string club_name) {
   if (!str ||
       !strlen(str)) {
      write("Aborting.\n");
      return ;
   }
   if (!CLUB_HANDLER->is_member_of(club_name,
                                   str)) {
      write("The person " + str + " is not a member of the club " +
            CLUB_HANDLER->query_club_name(club_name) +
            " and therefor you cannot remove them.\nAborting.\n");
      return ;
   }
   write("What do you want to say about removing " + str + "?\n");
   this_player()->do_edit(CLUB_HANDLER->query_description(club_name),
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Removing the member " + str,
                                CLUB_DISCUSS_MEMBER_REMOVE | open,
                                str,
                                0 }) );
}
protected int do_discuss_secret(int open, string club_name) {
   string short;
   if (CLUB_HANDLER->query_discussion_item_by_type(club_name,
                                                   CLUB_DISCUSS_SECRET_TYPE)) {
      notify_fail("There is already a discussion item to change this club's "
                  "secret status.\n");
      return 0;
   }
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   if (CLUB_HANDLER->query_club_secret(club_name)) {
      write("What description to wish to use to make the club open?\n");
      short = "make the club open";
   } else {
      write("What description to wish to use to make the club secret?\n");
      short = "make the club secret";
   }
   this_player()->do_edit(CLUB_HANDLER->query_description(club_name),
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                short,
                                CLUB_DISCUSS_SECRET_TYPE | open,
                                "Change to be secret",
                                0 }) );
   return 1;
}
protected int do_discuss_remove_position(int open, string club_name) {
   string *choices;
   string *ok;
   string bing;
   choices = CLUB_HANDLER->query_valid_positions(club_name);
   ok = filter(choices, (: !CLUB_HANDLER->is_basic_position($(club_name),
                                                            $1) :));
   if (!sizeof(ok)) {
      add_failed_mess("You cannot remove the basic positions of " +
                      query_multiple_short(choices) + ".\n");
      return 0;
   }
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("Which one of the positions do you wish to remove?\n");
   foreach (bing in ok) {
      write("   " + bing + "\n");
   }
   write("Choice? ");
   input_to("remove_position", 0, open, club_name, ok);
   return 1;
}
protected void remove_position(string str, int open, string club_name) {
   str = lower_case(str);
   if (!CLUB_HANDLER->is_valid_position(club_name,
                                        str)) {
      write("The position '" + str + "' does not exist in the club " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n");
      return ;
   }
   if (CLUB_HANDLER->is_basic_position(club_name,
                                       str)) {
      write("Unable to remove the basic positions from the club.\n");
      return ;
   }
   write("What description do you wish to associate with removing the "
         "position " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Remove the positon " + str,
                                CLUB_DISCUSS_POSITION_REMOVE | open,
                                str,
                                0 }) );
}
protected int do_discuss_change_position_name(int open, string club_name) {
   string *choices;
   string bing;
   choices = CLUB_HANDLER->query_valid_positions(club_name);
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("Which one of the positions do you wish to change?\n");
   foreach (bing in choices) {
      write("   " + bing + "\n");
   }
   write("Choice? ");
   input_to("change_position", 0, open, club_name);
   return 1;
}
protected void change_position(string str, int open, string club_name) {
   str = lower_case(str);
   if (!CLUB_HANDLER->is_valid_position(club_name,
                                        str)) {
      write("The position '" + str + "' does not exist in the club " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n");
      return ;
   }
   write("What name do you wish to change '" + str + "' to? ");
   input_to("change_position_new_name", 0, str, open, club_name);
}
protected void change_position_new_name(string str,
                                        string position,
                                        int open, string club_name) {
   str = strip_colours(str);
   if (CLUB_HANDLER->is_valid_position(club_name,
                                       str)) {
      write("The name '" + str + "' already exists in the club " +
            CLUB_HANDLER->query_club_name(club_name) + ".\n");
      return ;
   }
   if (strlen(str) > CLUB_MAX_POSITION_NAME) {
      write("The position name '" + str + "' is too long, the maximum is " +
            CLUB_MAX_POSITION_NAME + ".\n");
      return ;
   }
   if (strlen(str) < MIN_POSITION_LEN) {
      write("The position name '" + str + "' is too short, the minimum is " +
            MIN_POSITION_LEN + ".\n");
      return;
   }
   write("What description to you wish to give for changing the position " +
         position + " to " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "change the position " + position + " to " + str,
                                CLUB_DISCUSS_POSITION_NAME | open,
                                position,
                                str }) );
}
protected int do_discuss_no_confidence(int open, string club_name) {
   string *choices;
   string bing;
   choices = CLUB_HANDLER->query_valid_positions(club_name);
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee "
            "only!\n%^RESET%^");
   }
   write("Which one of the positions do you wish to add a no confidence "
         "vote in?\n");
   foreach (bing in choices) {
      write("   " + bing + "\n");
   }
   write("   " + CLUB_ALL_POSITIONS + "\n");
   write("Choice? ");
   input_to("no_confidence", 0, open, club_name);
   return 1;
}
protected void no_confidence(string str,
                             int open, string club_name) {
   string bing;
   str = lower_case(str);
   if (!CLUB_HANDLER->is_valid_position(club_name, str) &&
       str != CLUB_ALL_POSITIONS) {
      write("Sorry, '" + str + "' is not a valid position in " +
            CLUB_HANDLER->query_club_name(club_name) +
            ".\n");
      return ;
   }
   if (str == CLUB_ALL_POSITIONS) {
      bing = 0;
   } else {
      bing = str;
   }
   write("What description do you wish to give for a vote of no confidence "
         "in " + str + "?\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "no confidence in " + str,
                                CLUB_DISCUSS_NO_CONFIDENCE | open,
                                bing,
                                0 }) );
}
protected int do_discuss_remove_account(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("What is the name of the special account you wish to close? ");
   input_to("remove_account", 0, open, club_name);
   return 1;
}
protected void remove_account(string str, int open, string club_name) {
   str = lower_case(str);
   if (!CLUB_HANDLER->is_account(club_name, str)) {
      write("You cannot remove an account that doesn't exist.\n");
      return ;
   }
   if (str == CLUB_DEFAULT_ACCOUNT_NAME) {
      write("You cannot remove the default account name.\n");
      return ;
   }
   write("What description do you wish to associate with createing the "
         "account " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Create the special account " + str,
                                CLUB_DISCUSS_REMOVE_ACCOUNT | open,
                                str,
                                0 }) );
}
protected int do_discuss_create_account(int open, string club_name) {
   if (!open) {
      write("%^YELLOW%^This discussion item will be committee only!\n%^RESET%^");
   }
   write("What is the name of the special account you wish to open? ");
   input_to("create_account", 0, open, club_name);
   return 1;
}
protected void create_account(string str, int open, string club_name) {
   str = lower_case(str);
   if (CLUB_HANDLER->is_account(club_name, str)) {
      write("You cannot create an account that already exists.\n");
      return ;
   }
   write("What description do you wish to associate with createing the "
         "account " + str + ".\n");
   this_player()->do_edit("",
                          (: discussion_finish_information :),
                          0,
                          0,
                          ({ club_name,
                                "Create the special account " + str,
                                CLUB_DISCUSS_CREATE_ACCOUNT | open,
                                str,
                                0 }) );
}
protected void discuss_memo_show(class memo_item memo) {
   write("The memo in club " +
         CLUB_HANDLER->query_club_name(memo->club_name) +
         " will complete in " + memo->timeout + " days.\n");
   if (memo->subject) {
      write("Subject: " + memo->subject + "\n");
   } else {
      write("No subject set.\n");
   }
   if (sizeof(memo->choices)) {
      write("Choices: " + query_multiple_short(memo->choices) + "\n");
   } else {
      write("No choices set.\n");
   }
   if (memo->description) {
      write("Description:\n" + memo->description + "\n");
   } else {
      write("No description set.\n");
   }
}
protected void discuss_memo_menu(class memo_item memo) {
   discuss_memo_show(memo);
   write("\n");
   write("a) Set subject\n");
   write("b) Make a yes/no memo item\n");
   write("c) Add new choice\n");
   write("d) Remove choice\n");
   write("e) Set completion time\n");
   if (memo->description) {
      write("f) Change description\n");
      write("g) Zap description\n");
   } else {
      write("f) Add description\n");
   }
   write("m) Redisplay this menu\n");
   write("s) Save and Quit\n");
   write("q) Quit\n\n");
   write("Choice: ");
   input_to("discuss_memo_menu_choice", 0, memo);
}
protected void discuss_memo_subject(class memo_item memo) {
   write("What do you wish the new subject to be? ");
   input_to("discuss_memo_subject_name", 0, memo);
}
protected void discuss_memo_subject_name(string name,
                                         class memo_item memo) {
   if (!strlen(name)) {
      write("Not changing the subject.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (strlen(name) > MAX_SUBJECT_LEN) {
      write("The subject name is too long, the maximum "
            "length is " + MAX_SUBJECT_LEN + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->subject = name;
   discuss_memo_menu(memo);
}
protected void discuss_memo_add_choice(class memo_item memo) {
   write("What is the name of the choice you wish to add? ");
   input_to("discuss_memo_add_choice_response", 0, memo);
}
protected void discuss_memo_add_choice_response(string response,
                                                class memo_item memo) {
   response = lower_case(implode(explode(response, " ") - ({ "" }), " "));
   response = strip_colours(response);
   if (!strlen(response)) {
      write("Not adding any choices.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (strlen(response) > MAX_CHOICE_LEN) {
      write("The choice name " + response + " is too long, maximum "
            "length is " + MAX_CHOICE_LEN + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (member_array(response, memo->choices) != -1) {
      write("The choice name " + response + " is already in the list of "
            "choices.  Current choices are " +
            query_multiple_short(memo->choices) + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->choices += ({ response });
   discuss_memo_menu(memo);
}
protected void discuss_memo_remove_choice(class memo_item memo) {
   write("What is the name of the choice you wish to remove? ");
   input_to("discuss_memo_remove_choice_response", 0, memo);
}
protected void discuss_memo_remove_choice_response(string response,
                                                   class memo_item memo) {
   response = lower_case(implode(explode(response, " ") - ({ "" }), " "));
   if (member_array(response, memo->choices) == -1) {
      write("The choice '" + response + "' is not in current memo.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->choices -= ({ response });
   discuss_memo_menu(memo);
}
protected void discuss_memo_timeout(class memo_item memo) {
   write("What do you wish to change the length of the item to (in days)? ");
   input_to("discuss_memo_timeout_response", 0, memo);
}
protected void discuss_memo_timeout_response(string str,
                                             class memo_item memo) {
   int tim;
   if (sscanf(str, "%d", tim) != 1) {
      write("Must specify a number.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (tim < MIN_TIMEOUT) {
      write("The timeout " + tim + " is lower than the minimum allowed "
            "length of " + MIN_TIMEOUT + " days.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (tim > MAX_TIMEOUT) {
      write("The timeout " + tim + " is higher than the maximum allowed "
            "length of " + MAX_TIMEOUT + " days.\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   memo->timeout = tim;
   discuss_memo_menu(memo);
}
protected void discuss_memo_finish_description(string desc,
                                               class memo_item memo) {
   if (!desc) {
      write("Not changing the description.\n");
   } else {
      memo->description = desc;
   }
   discuss_memo_menu(memo);
}
protected void discuss_memo_description(class memo_item memo) {
   if (memo->description) {
      write("Edit your description.\n");
   } else {
      write("Add your description.\n");
   }
   this_player()->do_edit(memo->description,
                          (: discuss_memo_finish_description :),
                          0,
                          0,
                          memo);
}
protected void discuss_memo_save(class memo_item memo) {
   if (!memo->subject) {
      write("The memo must have a subject to save it!\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (sizeof(memo->choices) < 2) {
      write("The memo must have at least two choices!  Currently you have " +
            sizeof(memo->choices) + ".\n");
      write("Choice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   if (CLUB_HANDLER->add_discussion_item(memo->club_name,
                                         CLUB_DISCUSS_MEMO | memo->open,
                                         this_player()->query_name(),
                                         memo->subject,
                                         memo->description,
                                         memo->choices,
                                         memo->timeout * 24 * 60 * 60,
                                         0)) {
      write("Successfuly added the memo item.\n");
   } else {
      write("Unable to add the memo item for some reason.\n");
   }
}
protected void discuss_memo_menu_choice(string str, class memo_item memo) {
   str = lower_case(str);
   if (!strlen(str)) {
      write("Invalid choice\nChoice: ");
      input_to("discuss_memo_menu_choice", 0, memo);
      return ;
   }
   switch (str[0]) {
      case 'a' :
         discuss_memo_subject(memo);
         break;
      case 'b' :
         memo->choices = ({ "yes", "no", "abstain" });
         discuss_memo_menu(memo);
         break;
      case 'c' :
         discuss_memo_add_choice(memo);
         break;
      case 'd' :
         discuss_memo_remove_choice(memo);
         break;
      case 'e' :
         discuss_memo_timeout(memo);
         break;
      case 'f' :
         discuss_memo_description(memo);
         break;
      case 'g' :
         memo->description = 0;
         write("Description zapped.\n");
         discuss_memo_menu(memo);
         break;
      case 'q' :
         write("Quiting memo addition!\n");
         break;
      case 's' :
         discuss_memo_save(memo);
         break;
      case 'm' :
         discuss_memo_menu(memo);
         break;
      default :
         write("Invalid choice\nChoice: ");
         input_to("discuss_memo_menu_choice", 0, memo);
         break;
   }
}
protected int do_discuss_memo(int op, string club_name) {
   discuss_memo_menu(new(class memo_item, choices : ({ }),
                                          timeout : 14,
                                          club_name : club_name,
                                          open : op));
   return 1;
}
int do_discuss(int open, string type, string club_name) {
   if (open) {
      open = CLUB_DISCUSS_OPEN;
   }
   if (!CLUB_HANDLER->is_club(club_name)) {
      add_failed_mess("No such club '" + club_name + "'.\n");
      return 0;
   }
   if (!CLUB_HANDLER->is_elected_club(club_name)) {
      add_failed_mess("The club " + CLUB_HANDLER->query_club_name(club_name) +
                      " is not an elected club.\n");
      return 0;
   }
   if (!CLUB_HANDLER->holds_any_position_of(club_name, this_player()->query_name())) {
      if (type != "no confidence" &&
          type != "remove member") {
         add_failed_mess("Non elected officals can only add discussion items "
                         "of 'no confidence' and 'remove member'.\n");
         return 0;
      }
   }
   switch (type) {
      case "description" :
         return do_discuss_description(open, club_name);
      case "add position" :
         return do_discuss_add_position(open, club_name);
      case "change position name" :
         return do_discuss_change_position_name(open, club_name);
      case "memo" :
         return do_discuss_memo(open, club_name);
      case "remove member" :
         return do_discuss_remove_member(open, club_name);
      case "secret" :
         return do_discuss_secret(open, club_name);
      case "remove position" :
         return do_discuss_remove_position(open, club_name);
      case "no confidence" :
         return do_discuss_no_confidence(open, club_name);
      case "create account" :
         return do_discuss_create_account(open, club_name);
      case "remove account" :
         return do_discuss_remove_account(open, club_name);
      default :
         add_failed_mess("Horrible, horrible error.  The worms!  "
                         "The worms!\n");
         return 0;
   }
}

==================================================
FILE: room/inherit/club_owned_room.c
==================================================

inherit "/std/room/inherit/owned_room";
private nosave string _club_controller;
private nosave string _club_owned_id;
string query_owner() {
   return _club_controller->query_owner_of(_club_owned_id);
}
void set_club_controller(string club_controller) {
   _club_controller = club_controller;
}
string query_club_controller() {
   return _club_controller;
}
void set_owned_id(string id) {
   _club_owned_id = id;
}
string query_owned_id() {
   return _club_owned_id;
}

==================================================
FILE: room/inherit/complaints_room.c
==================================================

#include <complaints_handler.h>
#include <board.h>
void init() {
    add_command( "complain", "" );
}
int do_complain() {
    if ( this_player()->query_property( "guest" ) )
        return add_failed_mess( "Guest characters cannot lodge "
                                "complaints.\n" );
    tell_object( this_player(), "You are lodging an official complaint about "
                 "something or someone.\n"
                 "Do not take this action lightly.\n"
                 "Complaints should be about serious Disc-related matters.  "
                 "Please note that this complaint is submitted anonymously.  "
                 "If you wish to receive a reply, make sure you place your "
                 "character name in the complaint so we know who to respond "
                 "to.\n"
                 "Feedback for the general populous also often appears on "
                 "various bulletin boards.\n" );
    this_player()->do_edit( 0, "finish_complaint", this_object() );
    return 1;
}
void finish_complaint( string str ) {
    if ( !str ) {
        tell_object( this_player(), "Complaint aborted.\n" );
    } else {
        if ( COMPLAINTS_HANDLER->do_submit_complaint( str ) ) {
            tell_object( this_player(), "Complaint posted.  Thank you for "
                         "your complaint.  If you submitted your name in "
                         "your complaint, you should receive a response in "
                         "the near future.  Please be patient, as there may "
                         "be in-depth discussions as a result of your "
                         "complaint.\n" );
        } else {
            tell_object( this_player(), "There has been a problem posting "
                         "your complaint.  As a result it has NOT been "
                         "submitted.  You should contact a liaison or other "
                         "creator to get this rectified immediately.\n" );
        }
    }
}
int board_access_check( int type, string, object previous, string name ) {
    tell_creator("arienne",file_name(previous)+"\n");
    switch ( type ) {
    case B_ACCESS_READ:
        return ( "/secure/master"->query_lord( name ) );
    case B_ACCESS_WRITE:
        return ( ( previous == this_object() ) ||
                 ( "/secure/master"->query_lord( name ) ) );
    case B_ACCESS_DELETE :
        return 0;
    }
}

==================================================
FILE: room/inherit/council_base.c
==================================================

#define NOMIC_SYSTEM_NO_CLASSES
#include <nomic_system.h>
private nosave string _council_area;
string query_council_area() {
   return _council_area;
}
void set_council_area(string area) {
   _council_area = area;
}
void send_council_inform(int magistrate_only, string message) {
   NOMIC_HANDLER->send_council_inform(query_council_area(),
                                       magistrate_only, message);
}

==================================================
FILE: room/inherit/guild.c
==================================================

#include <money.h>
#include <skills.h>
#include <tune.h>
#include <config.h>
private int cost_div;
private int cost_mult;
private string our_guild;
private string start_pos;
private mapping spells;
private mapping commands;
private object teaching_person;
void check_spells_commands(string *sk, int lvl);
int do_cost_primaries();
int do_cost_all(int brief);
int do_cost_to(string skill, int level);
int do_cost_by(string skill, int level);
int do_cost(string skill);
int do_advance(string skill);
int do_advance_to(string skill, int num);
int do_advance_by(string skill, int num);
void create()
{
   cost_div = COST_DIV;
   cost_mult = 100;
   spells = ([ ]);
   commands = ([ ]);
   this_object()->add_help_file("guild");
}
void init()
{
   this_player()->add_command("advance", this_object(),
                              "<string>", (: do_advance($4[0]) :));
   this_player()->add_command("advance", this_object(),
                              "<string> to <number>",
                              (: do_advance_to($4[0], $4[1]) :));
   this_player()->add_command("advance", this_object(),
                              "<string> by <number>",
                              (: do_advance_by($4[0], $4[1]) :));
   this_player()->add_command("join", this_object(), "");
   this_player()->add_command("info", this_object(), "");
   this_player()->add_command("cost", this_object(),
                              "primaries", (: do_cost_primaries() :));
   this_player()->add_command("cost", this_object(),
                              "all", (: do_cost_all(0) :));
   this_player()->add_command("cost", this_object(),
                              "all brief", (: do_cost_all(1) :));
   this_player()->add_command("cost", this_object(),
                              "<string>", (: do_cost($4[0]) :));
   this_player()->add_command("cost", this_object(),
                              "<string> to <number>",
                              (: do_cost_to($4[0], $4[1]) :));
   this_player()->add_command("cost", this_object(), "<string> by <number>",
                              (: do_cost_by($4[0], $4[1]) :));
   if ((string) this_player()->query_guild_ob() == our_guild) {
      if (stringp(start_pos) && !clonep(this_object())) {
         this_player()->add_start(file_name(this_object()), start_pos);
      }
   }
}
varargs void set_guild(string word1, string word2)
{
   our_guild = word1;
   start_pos = word2;
}
void set_cost_div(int number)
{
   cost_div = number;
   if (!cost_div)
      cost_mult = 1000;
   else
      cost_mult = 10 + (990 * cost_div) / (10 * COST_DIV + cost_div);
}
int query_skill_cost(string skill, int offset)
{
   int i;
   int total;
   string *next;
   next = (string *) SKILL_OB->query_immediate_children(skill);
   if (!sizeof(next)) {
      if (!this_player()->query_guild_ob())
         total = DEFAULT_COST;
      else
         total = (int) our_guild->query_skill_cost(skill);
      total *= (STD_COST * cost_mult) / 500;
      total *= ((int) this_player()->query_skill(skill) + offset) /
         LEVEL_DIV + 1;
      total = to_int(total * exp((this_player()->query_skill(skill) +
                                  offset) / 150.0));
      return total;
   }
   for (i = 0; i < sizeof(next); i++)
      total += query_skill_cost(next[i], offset);
   return total;
}
int do_advance_internal(string skill, int to, int by)
{
   string *bits;
   string skill_name;
   string outer_name;
   string place;
   int lvl;
   int max_lvl;
   int tmp;
   int total_xp;
   int total_cost;
   int tmp_cost;
   int p_val;
   int i, j;
   int round_value;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You cannot advance here!  Go to your own guild.\n");
      return 0;
   }
   place = this_object()->query_property("place");
   if (!place)
      place = "default";
   bits = explode(implode(explode(skill, " "), "."), ".");
   if (!(skill_name = (string) SKILL_OB->query_skill(bits))) {
      add_failed_mess("The skill " + skill + " does not exist.\n");
      return 0;
   }
   bits = SKILL_OB->query_inactive_skills();
   for(j=0; j<sizeof(bits); j++)
     if(strsrch(skill, bits[j]) != -1)
       return add_failed_mess("The skill " + skill + " is inactive at "
                              "present and cannot be taught.\n");
   lvl = (int) this_player()->query_skill(skill_name);
   if (!by && to)
      by = to - lvl;
   if (by <= 0) {
      if (by == 0) {
         add_failed_mess("You are already at level " + lvl + " at " +
                         skill_name + ".\n");
      } else {
         add_failed_mess("You cannot regress below your current "
                         "skill level!\n");
      }
      return 0;
   }
   if (SKILL_OB->query_only_leaf(skill_name)) {
      if (sizeof((mixed *)SKILL_OB->query_immediate_children(skill_name))) {
         add_failed_mess("You can only advance the outer skills "
                         "(eg: other.movement.riding.horse), "
                         "not the internal "
                         "skills (eg: other.movement.riding, or other).\n");
         return 0;
      }
   } else {
      bits = explode(skill_name, ".");
      if (sizeof(bits) > 1) {
         outer_name = implode(bits[0..<2], ".");
         if (!SKILL_OB->is_skill_ignored(outer_name) &&
             ((sizeof(bits) - 1) * 5) >
             (int) this_player()->query_skill(outer_name)) {
            add_failed_mess("You are not at a high enough level in " +
                            outer_name +
                            " to advance " + skill_name + " yet.\n");
            return 0;
         }
      }
   }
   if (!SKILL_OB->query_allowed_to_teach(skill_name)) {
      add_failed_mess("You cannot learn '" + skill_name +
                      "' from your guild.\n");
      return 0;
   }
   max_lvl = (int) our_guild->query_skill_max_level(skill_name);
   if (lvl >= max_lvl) {
      add_failed_mess("You cannot advance in " + skill_name +
                      " any further here.\n");
      return 0;
   }
   p_val = (int) this_player()->query_value_in(place);
   if (place != "default") {
      p_val += (int) this_player()->query_value_in("default");
   }
   round_value = MONEY_HAND->query_smallest_value_in(place);
   total_cost = 0;
   for (i = 0; i < by; i++) {
      tmp = query_skill_cost(skill_name, i);
      if ((int) this_player()->query_xp() < tmp + total_xp) {
         if (!i) {
            add_failed_mess("Your lack of experience prevents you improving "
                            + skill_name + ".\n");
            return 0;
         } else {
            write("Your lack of experience prevents you taking all the "
                  "advancement you requested in " + skill_name + ".  You are "
                  "only trained up to level " + (i + lvl) + ".\n");
         }
         break;
      }
      if ((lvl + i) >= max_lvl) {
         write("Your guild hasn't the resources to train you as far as " +
               "you requested in " + skill_name +
               ".  It trains you to level " + max_lvl + ".\n");
         break;
      }
      if (cost_div) {
         tmp_cost = ( total_xp + tmp ) / cost_div;
         tmp_cost -= (tmp_cost % round_value);
         if ( tmp_cost > p_val ) {
            if (!i) {
               add_failed_mess
                  ("Due to your lack of money, the guild cannot train " +
                   "you in " + skill_name + ": it would have cost you " +
                   MONEY_HAND->money_value_string( tmp_cost, place ) + ".\n" );
               return 0;
            } else {
               write("Due to your sad lack of money the guild cannot train " +
                     "you in " + skill_name + " to level " + (by + lvl) +
                     ".  It trains you to level " + (i + lvl) + " instead.\n");
            }
            break;
         }
      }
      total_xp += tmp;
      total_cost = tmp_cost;
   }
   if (!total_xp) {
      return add_failed_mess("Oops, something has gone wrong.\n");
   }
   this_player()->adjust_xp(-total_xp);
   if (total_cost) {
      this_player()->pay_money((mixed *) MONEY_HAND->
                               create_money_array(total_cost, place), place);
   }
   this_player()->add_skill_level(skill_name, i, total_xp);
   this_player()->reset_all();
   this_player()->dest_hide_shadow();
   event(this_object(), "guild_advance", bits, lvl, lvl + i);
   check_spells_commands(bits, lvl + i);
   write("You advance your skill in " + skill_name + " from " + lvl + " to " +
         (lvl + i) + " for " + total_xp + " xp" + (total_cost ? " and " +
                                                   (string) MONEY_HAND->
                                                   money_value_string
                                                   (total_cost,
                                                    place) : "") + ".\n");
   say((string) this_player()->one_short() + " $V$0=advances,advance$V$ " +
       "$V$0=" + this_player()->query_possessive() + ",their$V$ skills.\n");
   return 1;
}
int do_advance(string skill)
{
   return do_advance_internal(skill, 0, 1);
}
int do_advance_by(string skill,
                  int num)
{
   return do_advance_internal(skill, 0, num);
}
int do_advance_to(string skill,
                  int num)
{
   return do_advance_internal(skill, num, 0);
}
int do_join(string str)
{
   if ((string) this_player()->query_guild_ob() == our_guild) {
      add_failed_mess("You're already in this guild.\n");
      return 0;
   }
   if (this_player()->query_guild_ob()) {
      add_failed_mess("You cannot join a guild while a member of another.\n");
      return 0;
   }
   write("You will only ever get to join one guild.  Are you sure? ");
   input_to("join2");
   return 1;
}
int join2(string str)
{
   str = lower_case(str);
   if (str[0] != 'n' && str[0] != 'y') {
      write("I do not understand.  Yes or no? ");
      input_to("join2");
      return 1;
   }
   if (str[0] == 'n') {
      write("Ok, not joining the " + our_guild->query_name() + " guild.\n");
      return 1;
   }
   this_player()->set_guild_ob(our_guild);
   if (stringp(start_pos) && !clonep(environment(this_player())))
      this_player()->add_start(file_name(environment(this_player())),
                               start_pos);
   this_player()->race_guild_commands();
   write("You are now a member of the " + our_guild->query_name() +
         " guild.\n");
   say(this_player()->one_short() + " joins the " + our_guild->query_name() +
       " guild.\n");
   event(this_object(), "guild_join");
   event(users(), "inform",
         this_player()->query_cap_name() + " is now a member " + "of " +
         our_guild->query_name(), "guild");
   return 1;
}
int do_leave(string str)
{
   if (str != "guild") {
      add_failed_mess("Syntax : leave guild\n");
      return 0;
   }
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("How can you leave a guild if you aren't in it.\n");
      return 0;
   }
   if ((int) this_player()->query_level() > 5) {
      add_failed_mess("You are too high a level to leave this guild.\n");
      return 0;
   }
   write("Are you sure you want to leave the guild (Y/N) : ");
   input_to("confirm_leave");
   return 1;
}
void confirm_leave(string str)
{
   str = lower_case(str);
   if (str != "y") {
      write("You are still in the guild.\n");
      return;
   }
   write("Goodbye.\n");
   call_other(our_guild, "leaving_guild");
   this_player()->set_start_pos(CONFIG_START_LOCATION);
   this_player()->set_guild_ob(0);
   this_player()->set_guild_data(0);
   this_player()->guild_commands();
   this_player()->save_me();
}
int check_primaries(string lpath, string g_o)
{
   int i;
   string dummy,
    *primaries;
   primaries = (string *) g_o->query_skills();
   if (member_array(lpath, primaries) != -1)
      return 1;
   for (i = 0; i < sizeof(primaries); i++)
      if (sscanf(primaries[i], lpath + ".%s", dummy))
         return 1;
   return 0;
}
mixed *filter_primaries(mixed *tmp_skills, string skill_path,
                        string *primaries)
{
   int i;
   string test_skill;
   for (i = 0; i < sizeof(tmp_skills); i += SKILL_ARR_SIZE)  {
      test_skill = skill_path + tmp_skills[i];
      if (sizeof(tmp_skills[i + SKILL_BIT]) != 0)
         tmp_skills[i + SKILL_BIT] =
            filter_primaries(tmp_skills[i + SKILL_BIT], test_skill + ".",
                             primaries);
      if (member_array(test_skill, primaries) == -1  &&
          sizeof(tmp_skills[i + SKILL_BIT]) == 0)
      {
         tmp_skills = tmp_skills[0 .. (i - 1)] +
                      tmp_skills[(i + SKILL_ARR_SIZE) .. ];
         i -= SKILL_ARR_SIZE;
      }
   }
   return tmp_skills;
}
private string rec_cost(mixed *arr, string path, int depth, string guild,
                        int brief)
{
   int i;
   int depth_gap;
   int ndots;
   int lvl;
   int max_lvl;
   int only_leaf;
   int tmp;
   string str;
   string sub_str;
   string lpath;
   str = "";
   depth_gap = (depth - 1) * 2;
   ndots = 19 - depth_gap;
   for (i = 0; i < sizeof(arr); i += SKILL_ARR_SIZE) {
      lpath = path + arr[i];
      lvl = this_player()->query_skill(lpath);
      if (!guild) {
         max_lvl = 5;
      } else {
         max_lvl = guild->query_skill_max_level(lpath);
      }
      only_leaf = SKILL_OB->query_only_leaf(lpath);
      if (only_leaf  &&  sizeof(arr[i + SKILL_BIT]) > 0)  {
         sub_str = rec_cost(arr[i + SKILL_BIT], lpath + ".", depth + 1,
                            guild, brief);
         if (sub_str != "")  {
            str += sprintf("%*'| 's%-*'.'s\n", depth_gap, "",
                           ndots + 18, arr[i]) + sub_str;
            continue;
         }
      }
      else if (SKILL_OB->query_allowed_to_teach(lpath))  {
         if (lvl >= max_lvl)  {
            if (brief)  {
               sub_str = rec_cost(arr[i + SKILL_BIT], lpath + ".", depth + 1,
                                  guild, brief);
               if (sub_str != "")  {
                  str += sprintf("%*'| 's%-*'.'s\n", depth_gap, "",
                                 ndots + 18, arr[i]) + sub_str;
                  continue;
               }
            }
            else str += sprintf("%*'| 's%-*'.'s%4d/%3d  mastered\n", depth_gap,
                                "", ndots, arr[i], lvl, max_lvl);
         }
         else if (SKILL_OB->query_allowed_to_teach(lpath))  {
            tmp = query_skill_cost(lpath, 0);
            str += sprintf("%*'| 's%-*'.'s%4d/%3d %6d xp\n", depth_gap, "",
                           ndots, arr[i], lvl, max_lvl, tmp);
         }
      }
      if (lvl >= depth * 5  ||  only_leaf) {
         reset_eval_cost();
         str += rec_cost(arr[i + SKILL_BIT], lpath + ".", depth + 1, guild,
                         brief);
      }
   }
   return str;
}
int do_cost_all(int brief)
{
   mixed *arr;
   string list;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   arr = (mixed *) SKILL_OB->query_skills();
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }
   list = sprintf("%-*'='s\n", (int) this_player()->query_cols(),
                  "======SKILLS=======Cur/Max==For Next");
   list += sprintf("%#*-s\n", (int) this_player()->query_cols() + 1,
                   rec_cost(arr, "", 1, our_guild, brief));
   list += sprintf("%*'='|s\n", (int) this_player()->query_cols(),
                   "> You have " + (int) this_player()->query_xp() +
                   " points to spend <");
   this_player()->more_string(list, "All", 1);
   return 1;
}
int do_cost_primaries()
{
   mixed *arr;
   string list;
   string *primaries;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   arr = copy((mixed *)SKILL_OB->query_skills());
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }
   primaries = our_guild->query_skills();
   arr = filter_primaries(arr, "", primaries);
   list = sprintf("%-*'='s\n", (int) this_player()->query_cols() - 1,
                  "======SKILLS=======Cur/Max==For Next");
   list += sprintf("%#*-s\n", (int) this_player()->query_cols(),
                   rec_cost(arr, "", 1, our_guild, 0));
   list += sprintf("%*'='|s\n", (int) this_player()->query_cols() - 1,
                   "> You have " + (int) this_player()->query_xp() +
                   " points to spend <");
   this_player()->more_string(list, "Primaries", 1);
   return 1;
}
int do_cost_internal(string skill, int to, int by)  {
   string *bits;
   string skill_name;
   string outer_name;
   string place;
   string cost_str;
   int lvl;
   int max_lvl;
   int i;
   int tmp;
   int cost;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   bits = explode(implode(explode(skill, " "), "."), ".");
   if (!(skill_name = (string) SKILL_OB->query_skill(bits))) {
      add_failed_mess("There is no such skill as " + skill + ".\n");
      return 0;
   }
   lvl = (int) this_player()->query_skill(skill_name);
   if (!by && to)
      by = to - lvl;
   if (by == 0) {
      add_failed_mess
         ("It won't cost you anything to stay at the same level!\n");
      return 0;
   }
   if (by < 0) {
      add_failed_mess("We can't give refund xp for regressing skills!\n");
      return 0;
   }
   bits = explode(skill_name, ".");
   if (sizeof(bits) > 1  &&  !SKILL_OB->query_only_leaf(skill_name)) {
      outer_name = implode(bits[0 .. <2], ".");
      if (!SKILL_OB->is_skill_ignored(outer_name) &&
          ((sizeof(bits) - 1) * 5) > this_player()->query_skill(outer_name))
      {
         add_failed_mess("You are not at a high enough level in " +
                         outer_name + " to advance " + skill_name +
                         " yet.\n");
         return 0;
      }
   }
   if (!SKILL_OB->query_allowed_to_teach(skill_name)) {
      add_failed_mess("You cannot learn '" + skill_name +
                      "' from your guild.\n");
      return 0;
   }
   max_lvl = (int) our_guild->query_skill_max_level(skill_name);
   if (lvl >= max_lvl) {
      add_failed_mess("Your guild prevents you even considering advancing " +
                      skill_name + " above level " + max_lvl + ".\n");
      return 0;
   }
   for (i = 0; i < by; i++) {
      if ((lvl + i) >= max_lvl) {
         write("Your guild prevents you considering all the advancement you "
               + "requested.  You can only advance up to level " + max_lvl +
               " in " + skill_name + " here.\n");
         break;
      }
      tmp += query_skill_cost(skill_name, i);
   }
   place = this_object()->query_property("place");
   if (!place)
      place = "default";
   cost_str = "";
   if (cost_div) {
      cost = tmp / cost_div;
      cost += cost % MONEY_HAND->query_smallest_value_in(place);
      if (cost)
         cost_str = " and " + MONEY_HAND->money_value_string(cost, place);
   }
   printf("It would cost you %d xp%s to raise %s from level %d to %d.\n",
          tmp, cost_str, skill_name, lvl, (lvl + i));
   return 1;
}
int do_cost(string skill)
{
   mixed *arr;
   int i;
   int depth;
   string list;
   string exp_skill;
   string *sub_skills;
   int only_leaf;
   if ((string) this_player()->query_guild_ob() != our_guild) {
      add_failed_mess("You are not a member of this guild.\n");
      return 0;
   }
   arr = (mixed *) SKILL_OB->query_skills();
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }
   exp_skill =
      SKILL_OB->query_skill(explode(implode(explode(skill, " "), "."), "."));
   if (!exp_skill)  {
      add_failed_mess("There is no such skill as " + skill + ".\n");
      return 0;
   }
   if (SKILL_OB->query_allowed_to_teach(exp_skill))  {
      i = member_array(exp_skill, arr);
      only_leaf = SKILL_OB->query_only_leaf(exp_skill);
      if (only_leaf)  {
         sub_skills = explode(exp_skill, ".");
         foreach (skill in sub_skills[0 .. < 2])  {
            i = member_array(skill, arr);
            arr = arr[i + 3];
         }
         i = member_array(sub_skills[<1], arr);
         depth = sizeof(sub_skills) + 1;
      }
      else depth = 2;
      if (sizeof(arr[i + 3]) > 0)  {
         list = sprintf("%-*'='s\n", (int) this_player()->query_cols() - 1,
                        "======SKILLS=======Cur/Max==For Next") +
                sprintf("%#*-s\n", (int) this_player()->query_cols(),
                         rec_cost(arr[i + SKILL_BIT], exp_skill + ".", depth,
                         our_guild, 0)) +
                sprintf("%*'='|s\n", (int) this_player()->query_cols() - 1,
                         "> You have " + (int) this_player()->query_xp() +
                         " points to spend <");
         this_player()->more_string(list, capitalize(exp_skill), 1);
         return 1;
      }
   }
   return do_cost_internal(exp_skill, 0, 1);
}
int do_cost_to(string skill, int num)
{
   return do_cost_internal(skill, num, 0);
}
int do_cost_by(string skill, int num)
{
   return do_cost_internal(skill, 0, num);
}
int do_info()
{
   mixed *arr;
   string *primaries;
   write(our_guild->long() +
         "\nThis guild's primary skills and costs are:\n");
   arr = copy((mixed *)SKILL_OB->query_skills());
   if (!arr) {
      add_failed_mess("Hmmm, we appear to have an error here.\n");
      return 0;
   }
   primaries = our_guild->query_skills();
   arr = filter_primaries(arr, "", primaries);
   printf("%-*'='s\n", this_player()->query_cols() - 1,
          "======SKILLS=======Cur/Max==For Next");
   printf("%#*-s\n", this_player()->query_cols(),
          rec_cost(arr, "", 1, our_guild, 0));
   printf("%*'='|s\n", this_player()->query_cols() - 1, "> You have " +
          this_player()->query_xp() + " points to spend <");
   return 1;
}
void set_teaching_person(object ob)
{
   teaching_person = ob;
}
object query_teaching_person()
{
   return teaching_person;
}
void add_spell(string name, string *blue, int lvl)
{
   string path;
   path = implode(blue, ".");
   if (!spells[path])
      spells[path] = ({ name, lvl });
   else
      spells[path] += ({ name, lvl });
}
void add_command(string name, string *blue, int lvl)
{
   string path;
   path = implode(blue, ".");
   if (!commands)
      commands = ([ ]);
   if (!commands[path])
      commands[path] = ({ name, lvl });
   else
      commands[path] += ({ name, lvl });
}
void check_spells_commands(string *sk, int lvl)
{
   string *bits;
   int val;
   int i;
   int j;
   if (!teaching_person)
      return;
   bits = keys(spells);
   for (i = 0; i < sizeof(bits); i++) {
      val = this_player()->query_skill(bits[i]);
      for (j = 0; j < sizeof(spells[bits[i]]); j += 2)
         if ((spells[bits[i]][j + 1] < val) &&
             !(this_player()->query_spell(spells[bits[i]][j])))
            teaching_person->init_command("teach " + spells[bits[i]][j] +
                                          " to " +
                                          this_player()->query_name());
   }
   bits = keys(commands);
   for (i = 0; i < sizeof(bits); i++) {
      val = this_player()->query_skill(bits[i]);
      for (j = 0; j < sizeof(commands[bits[i]]); j += 2)
         if ((commands[bits[i]][j + 1] < val) &&
             !(this_player()->query_known_command(commands[bits[i]][j])))
            teaching_person->init_command("teach " + commands[bits[i]][j] +
                                          " to " +
                                          this_player()->query_name());
   }
}
mapping query_spells()
{
   return spells + ([ ]);
}
mapping query_commands()
{
   return commands + ([ ]);
}
string query_start_pos()
{
   return start_pos;
}
string query_our_guild()
{
   return our_guild;
}

==================================================
FILE: room/inherit/honours.c
==================================================

#include <player_handler.h>
#include <player.h>
class honour {
   int time_added;
   string reason;
   string cap_name;
   string added_by;
}
private nosave string* _titles;
mapping _honours;
int is_allowed_to_change(string person);
void save_me();
void create() {
   _honours = ([ ]);
   _titles = ({ });
}
void inform_of_honour_change(string type, string person,
                      string reason, string changed_by) {
}
void set_controlled_titles(string* title) {
   _titles = title;
}
string* query_controlled_titles() {
   return _titles;
}
void add_to_honour_roll(string person, string reason, string added_by) {
   string title;
   if (_honours[person]) {
      return ;
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      return ;
   }
   _honours[person] = new(class honour);
   _honours[person]->time_added = time();
   _honours[person]->reason = reason;
   _honours[person]->added_by = added_by;
   _honours[person]->cap_name = PLAYER_HANDLER->query_cap_name(person);
   foreach (title in _titles) {
      PLAYER_TITLE_HANDLER->add_title_to_player(person, title);
   }
   save_me();
}
void remove_from_honour_roll(string person) {
   string title;
   if (!_honours[person]) {
      return ;
   }
   map_delete(_honours, person);
   if (find_player(person)) {
      foreach (title in _titles) {
         find_player(person)->remove_player_title(title);
      }
   }
   save_me();
}
int is_on_honour_roll(string person) {
   return classp(_honours[person]);
}
int do_list_honour() {
   string person;
   class honour roll;
   string ret;
   string* people;
   if (!_honours) {
      _honours = ([ ]);
   }
   if (!sizeof(_honours)) {
      add_failed_mess("There is no one on the honour roll.\n");
      return 0;
   }
   ret = "";
   people = sort_array(keys(_honours), (: _honours[$1]->time_added - _honours[$2]->time_added :));
   foreach (person in people) {
      roll = _honours[person];
      ret += "$I$3=%^YELLOW%^" + roll->cap_name + "%^RESET%^ at " +
             amtime(roll->time_added) +
             " for " + roll->reason + " by " + roll->added_by + "\n";
   }
   write("$P$Honour Roll$P$" + ret);
   return 1;
}
int do_honour_add(string person) {
   if (!is_allowed_to_change(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add people to the honour "
                      "roll.\n");
      return 0;
   }
   if (is_on_honour_roll(person)) {
      add_failed_mess("They are already on the honour roll.\n");
      return 0;
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("The person " + person + " does not exist.\n");
      return 0;
   }
   write("Enter the reason for adding " + person + " to the honour roll:\n");
   this_player()->do_edit("", "end_honour_add", this_object(), 0, person);
   add_succeeded_mess("");
   return 1;
}
void end_honour_add(string reason, string person, string bing) {
   if (reason == "" || !reason) {
      write("Aborting.\n");
      return ;
   }
   write("Adding the person " + person + " to the honour roll with a reason "
         "of:\n" + reason + "\nAre you sure? ");
   input_to("honour_roll_confirm", 0, person, reason);
}
void honour_roll_confirm(string response, string person, string reason) {
   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Aborting.\n");
      return ;
   }
   add_to_honour_roll(person, reason, this_player()->query_cap_name());
   inform_of_honour_change("add", person, reason,
                           this_player()->query_name());
   add_succeeded_mess("$N add$s " + person + " to the honour roll.\n");
   return ;
}
int do_honour_remove(string person, string reason) {
   if (!is_allowed_to_change(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add people to the honour "
                      "roll.\n");
      return 0;
   }
   if (!is_on_honour_roll(person)) {
      add_failed_mess("They are not on the honour roll.\n");
      return 0;
   }
   remove_from_honour_roll(person);
   inform_of_honour_change("remove", person, reason,
                           this_player()->query_cap_name());
   add_succeeded_mess("$N remove$s " + person + " to the honour roll.\n");
   return 1;
}
void readd_all_titles() {
   string person;
   class honour roll;
   foreach (person, roll in _honours) {
      foreach (string title in _titles) {
         PLAYER_TITLE_HANDLER->add_title_to_player(person, title);
      }
   }
}
void init() {
   if (!sizeof(_titles)) {
      return 0;
   }
   add_command("list", "honour [roll]", (: do_list_honour() :));
   if (is_allowed_to_change(this_player()->query_name())) {
      add_command("add",
                  "<string'person'> to honours",
                  (: do_honour_add($4[0]) :));
      add_command("remove",
                  "<string'person'> from honours because <string'reason'>",
                  (: do_honour_remove($4[0], $4[1]) :));
   }
}

==================================================
FILE: room/inherit/meeting.c
==================================================

private object _floor;
private string _leader;
int do_bang();
int do_recover();
int do_start();
int do_finish();
object create_floor();
void add_property(string name, mixed data);
void create() {
   _floor = create_floor();
   _floor->move(this_object());
}
void init() {
   add_command("bang", "gavel", (: do_bang() :));
   add_command("recover", "floor", (: do_recover() :));
   add_command("start", "meeting", (: do_start() :));
   add_command("finish", "meeting", (: do_finish() :));
}
object create_floor() {
   object floor;
   floor = clone_object("/std/object");
   floor->set_name("floor");
   floor->set_short( "floor" );
   floor->add_property( "determinate", "the " );
   floor->add_property( "no burial", 1);
   floor->set_long("This is the floor of the meeting.  It gives you the "
                   "right to speak during the meeting.  Please give this "
                   "to the next person to speak after you have finished.\n");
   return floor;
}
int do_start() {
   if (_leader &&
       find_player(_leader) &&
       environment(find_player(_leader)) == this_object()) {
      add_failed_mess("There is already a meeting started with " +
                      find_player(_leader)->the_short() +
                      " as the leader.\n");
      return 0;
   }
   _leader = this_player()->query_name();
   add_succeeded_mess("$N $V the meeting.\n");
   return 1;
}
int do_bang() {
   if (this_player()->query_name() != _leader) {
      add_failed_mess("Only the leader can bang the gavel!\n");
      return 0;
   }
   add_succeeded_mess("$N $V the gavel.\n\nSTOP STOP!\n\n");
   return 1;
}
int do_recover() {
   if (this_player()->query_name() != _leader) {
      add_failed_mess("Only the leader can recover the floor.\n");
      return 0;
   }
   _floor->move(this_player());
   add_succeeded_mess("$N recovers the floor.\n");
   return 1;
}
int do_finish() {
   if (this_player()->query_name() != _leader) {
      add_failed_mess("Only the leader can stop the meeting!\n");
      return 0;
   }
   _leader = 0;
   add_succeeded_mess("$N $V the meeting.\n");
   return 1;
}
void event_exit(object ob,
                string mess,
                object to) {
   object *inv;
   if (living(ob)) {
      if (userp(ob) &&
          ob->query_name() == _leader) {
         tell_room(this_object(),
                   "The meeting finishes abruptly as the leader leaves.\n");
      }
      inv = deep_inventory(ob);
      if (member_array(_floor, inv) != -1) {
         _floor->move(this_object());
         tell_room(this_object(),
                      "The floor zips out of " + ob->the_short() +
                      "'s hands and flops onto the floor.\n", ({ ob }));
         tell_object(ob, "The floor zips out of your hands.\n");
      }
   }
}
void event_dest_me(object ob) {
   object *inv;
   if (living(ob)) {
      if (userp(ob) &&
          ob->query_name() == _leader) {
         tell_room(this_object(),
                   "The meeting finishes abruptly as the leader leaves.\n");
      }
      inv = deep_inventory(ob);
      if (member_array(_floor, inv) != -1) {
         _floor->move(this_object());
         tell_room(this_object(),
                      "The floor zips out of " + ob->the_short() +
                      " hands into flops onto the floor.\n", ({ ob }));
         tell_object(ob, "The floor zips out of your hands.\n");
      }
   }
}
void event_quit(object ob) {
   object *inv;
   if (living(ob)) {
      if (userp(ob) &&
          ob->query_name() == _leader) {
         tell_room(this_object(),
                   "The meeting finishes abruptly as the leader leaves.\n");
      }
      inv = deep_inventory(ob);
      if (member_array(_floor, inv) != -1) {
         _floor->move(this_object());
         tell_room(this_object(),
                      "The floor zips out of " + ob->the_short() +
                      " hands into flops onto the floor.\n", ({ ob }));
         tell_object(ob, "The floor zips out of your hands.\n");
      }
   }
}

==================================================
FILE: room/inherit/newspaper_office.c
==================================================

#include <mail.h>
#include <money.h>
#include <move_failures.h>
#include <player_handler.h>
#include <room/newspaper.h>
#include <nroff.h>
#include <board.h>
#include <housing.h>
#define NEWSPAPER_POSTPONE_FLAG 1
#define NEWSPAPER_LOCK_FLAG 2
class our_article {
   class article art;
   int flags;
   int length;
   int suggested_payment;
}
class reporter {
   int date_added;
   int num_articles;
   int total_payed;
}
class category_data {
   int cost_per_add;
   int cost_per_ten_chars;
   int open;
}
class payee_data {
   int paid;
   string message;
}
private mapping _reporters;
private string* _editors;
private string* _setters;
private string* _sponsors;
private string _owner;
private mapping _payees;
private int _published_time;
private class our_article* _articles;
private class advert* _adverts;
private int _next_article_num;
private int _edition_number;
private int _locked;
private int _owner_extra_cash;
private mapping _category;
private nosave string _save_dir;
private nosave string _paper_name;
private string _bank_branch;
private nosave string _proxy;
int show_article(class our_article art, int source);
string* query_all_reporters();
string* query_all_setters();
string* query_all_editors();
string* query_all_sponsors();
mapping query_all_payees();
int is_reporter(string word);
int is_setter(string word);
int is_editor(string word);
int is_sponsor(string word);
void add_reporter(string word);
void add_setter(string word);
void add_editor(string word);
void add_sponsor(string word);
void remove_reporter(string word);
void remove_setter(string word);
void remove_editor(string word);
void remove_sponsor(string word);
void update_commands(string word);
string query_log_file_name();
string query_article_log_file_name();
int query_current_edition();
string query_paper_name();
string query_next_article_file_name();
string query_bank_branch();
mixed query_property(string);
string query_owner();
int is_owner(string word);
void create()
{
   _reporters = ([ ]);
   _editors = ({ });
   _payees = ([ ]);
   _articles = ({ });
   _category = ([ ]);
   _adverts = ({ });
   _setters = ({ });
   _sponsors = ({ });
   _next_article_num = 2;
}
protected void save_me()
{
   if (_save_dir && !_proxy) {
      unguarded( (: save_object(_save_dir + "main") :) );
   }
}
protected void load_me()
{
   class article fluff;
   int i;
printf("%O %O\n", _save_dir, _proxy);
   if (_save_dir && !_proxy) {
      unguarded( (: restore_object(_save_dir + "main", 1) :) );
printf("%O %O\n", _save_dir, _proxy);
      if (!_articles) {
         _articles = ({ });
      }
      if (!_setters) {
         _setters = ({ });
      }
      if (!_sponsors) {
         _sponsors = ({ });
      }
      if (!_adverts) {
         _adverts = ({ });
      }
      for (i = 0; i < sizeof(_articles); i++) {
         if (sizeof(_articles[i]->art) == 6) {
            fluff = new(class article);
            fluff->file_name = _articles[i]->art->file_name;
            fluff->title = _articles[i]->art->title;
            fluff->author = _articles[i]->art->author;
            fluff->date_written = _articles[i]->art->date_written;
            fluff->type = _articles[i]->art->type;
            fluff->shown_name = _articles[i]->art->shown_name;
            fluff->colour = 0;
            _articles[i]->art = fluff;
         }
      }
   }
}
private int a_type(int data) {
   return data & NEWSPAPER_ARTICLE_TYPE_MASK;
}
private int a_flags(int data) {
   return data & ~NEWSPAPER_ARTICLE_TYPE_MASK;
}
void set_save_directory(string dir) {
   if (dir[<1] != '/') {
      dir += "/";
   }
   _save_dir = dir;
   load_me();
}
void save_article_text(class our_article art, string text) {
   if (a_type(art->art->type) != NEWSPAPER_ARTICLE_TYPE_HTML &&
       a_type(art->art->type) != NEWSPAPER_ARTICLE_TYPE_PLAIN) {
      return ;
   }
   unguarded( (:
       write_file(_save_dir + $(art->art->file_name), save_variable(({ $(art), $(text) })), 1) :) );
   unguarded( (: rm(_save_dir + $(art->art->file_name) + ".proc" ) :) );
   unguarded( (: rm(_save_dir + $(art->art->file_name) + ".nroff.o" ) :) );
}
private void update_article_info(class our_article art, string text) {
   int fsize;
   fsize = strlen(text);
   art->length = fsize;
   if (fsize < 0) {
      fsize = 0;
   }
   if (fsize > 4000) {
      fsize = 4000;
   }
   fsize = fsize / 100;
   art->suggested_payment = fsize;
}
string load_article_text(class our_article art) {
   mixed* bits;
   string str;
   str = unguarded( (: read_file(_save_dir + $(art->art->file_name)) :) );
   if (str) {
      bits = restore_variable(str);
      return bits[1];
   }
   return "Error loading the article.";
}
string load_article_text_by_file(string fname) {
   int i;
   for (i = 0; i < sizeof(_articles); i++) {
      if (_articles[i]->art->file_name == fname) {
         return load_article_text(_articles[i]);
      }
   }
   return "Lost the article.\n";
}
void save_article_text_by_file(string fname, string text) {
   int i;
   for (i = 0; i < sizeof(_articles); i++) {
      if (_articles[i]->art->file_name == fname) {
         update_article_info(_articles[i], text);
         return save_article_text(_articles[i], text);
      }
   }
    return ;
}
void set_article_title_by_file(string fname, string title) {
   int i;
   for (i = 0; i < sizeof(_articles); i++) {
      if (_articles[i]->art->file_name == fname) {
         _articles[i]->art->title = title;
         save_me();
         return ;
      }
   }
    return ;
}
void delete_article(class our_article article) {
   unguarded( (: rm(_save_dir + $(article->art->file_name)) :) );
   unguarded( (: rm(_save_dir + $(article->art->file_name) + ".proc" ) :) );
   unguarded( (: rm(_save_dir + $(article->art->file_name) + ".nroff.o" ) :) );
}
int query_article_index(string match) {
   int index;
   match = lower_case(match);
   if (strlen(match) && (match[0] >= '0' && match[0] <= '9')) {
      sscanf(match, "%d", index);
      index--;
      if (index < 0 || index >= sizeof(_articles)) {
         return -1;
      }
      return index;
   }
   if (strlen(match) == 1) {
      index = match[0] - 'a';
      if (index < 0 || index >= sizeof(_articles)) {
         return -1;
      }
      return index;
   }
   return -1;
}
class our_article* query_articles() {
   return _articles;
}
class our_article query_article(string match) {
   int index;
   index = query_article_index(match);
   if (index == -1) {
      return 0;
   }
   return _articles[index];
}
string query_category(string category) {
   string name;
   category = lower_case(category);
   foreach (name in keys(_category)) {
      if (lower_case(name) == category ||
          lower_case(name)[0..strlen(category) - 1] == category) {
         return name;
      }
   }
   return 0;
}
string query_log_file_name() {
   return _save_dir + "event.log";
}
string query_article_log_file_name() {
   return _save_dir + "aritcle.log";
}
int query_current_edition()
{
   return NEWSPAPER_HANDLER->query_current_edition_num(query_paper_name());
}
string query_paper_name()
{
   return _paper_name;
}
string query_the_paper_name()
{
   if (lower_case(_paper_name[0..3]) == "the") {
      return _paper_name;
   }
   return "the " + _paper_name;
}
string set_paper_name(string name)
{
   _paper_name = name;
}
string query_next_article_file_name()
{
   while (file_size(_save_dir + _next_article_num + ".txt") != -1) {
      _next_article_num++;
   }
   return (_next_article_num++) + ".txt";
}
string query_bank_branch()
{
   return _bank_branch;
}
void set_bank_branch(string bank) {
   _bank_branch = bank;
}
int do_apply()
{
   if (_proxy) {
      return _proxy->do_apply();
   }
   tell_object(this_player(), "To apply for a job at " + query_the_paper_name() + ", please write "
               "us a letter outlining your areas of interest and what you think you "
               "would be able to contribute to the newspaper.  It will be sent to the "
               "editors of " + query_the_paper_name() +
               ", who will get back to you with an answer "
               "within a few days.\n");
   this_player()->do_edit(0, "mail_application");
   add_succeeded_mess(({ "", "$N start$s writing an application.\n" }));
   return 1;
}
int mail_application(string text)
{
   string word;
   string *eds;
   if (!text) {
      tell_object(this_player(), "You decide not to apply just yet.\n");
      return 0;
   }
   eds = ({ });
   foreach(word in query_all_editors()) {
      if (PLAYER_HANDLER->test_user(word)) {
         eds += ({ word });
      }
   }
   if (!sizeof(eds)) {
      eds = ({ "pinkfish" });
   }
   AUTO_MAILER->auto_mail(implode(eds, ","), this_player()->query_name(),
                          "" + query_paper_name() + " application", "", text, 0, 0);
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " applied for a job at " + query_the_paper_name() + ".\n");
   tell_object(this_player(), "Your application has been submitted.  Thanks!\n");
   tell_room(this_object(),
             this_player()->the_short() + " finishes " + this_player()->query_possessive() +
             " application for a job at " + query_the_paper_name() + ".\n", this_player());
   return 1;
}
int part_two(string str, string author, int html)
{
   if (!sizeof(str)) {
      tell_object(this_player(), "The article must have a name!\n");
      tell_room(this_object(), this_player()->the_short() +
                " stops writing to think of a name.\n",
                this_player());
      return 0;
   }
   if (!html) {
      tell_object(this_player(), "Please enter the text of your story.  It will make "
               "everyone's life much easier if it is less than 75 characters per "
               "line!\n\n"
               "%^BOLD%^<--------+10-------+20-------+30-------+40-------+50-------+60-"
               "------+70-->%^RESET%^\n");
   }
   this_player()->do_edit(0, "write_it", this_object(), 0, ({ str, author, html }));
   return 1;
}
int do_submit(string str, string author, int html)
{
   if (_proxy) {
      return _proxy->do_submit(str, author, html);
   }
   if (_locked) {
      add_failed_mess("The newspaper office is currently locked for "
                      "submissions.\n");
      return 0;
   }
   if (!str) {
      add_failed_mess("Please enter the name of the article you wish "
                       "to submit.  A short but descriptive name would be good, and it will "
                       "automagically have your name appended to the end of it.\n");
      return 0;
   }
   if (!author) {
      author = this_player()->query_cap_name();
   }
   add_succeeded_mess(({ "", "$N start$s writing an article.\n" }));
   part_two(str, author, html);
   return 1;
}
varargs int write_it(string article,
                     mixed *stuff,
                     class our_article cur_art)
{
   int fsize;
   string person;
   string title;
   string author;
   int html;
   title = stuff[0];
   author = stuff[1];
   html = stuff[2];
   if (!article) {
      tell_object(this_player(), "You decide not to submit your story after all.\n");
      tell_room(this_object(), this_player()->the_short() +
                    " stops writing the article.\n", this_player());
      return 0;
   }
   person = this_player()->query_cap_name();
   if (!cur_art) {
      cur_art = new(class our_article);
      cur_art->art = new(class article);
      cur_art->art->title = title;
      cur_art->art->shown_name = author;
      cur_art->art->file_name = query_next_article_file_name();
      cur_art->art->author = person;
      cur_art->art->date_written = time();
      if (html) {
         cur_art->art->type = NEWSPAPER_ARTICLE_TYPE_HTML;
      } else {
         cur_art->art->type = NEWSPAPER_ARTICLE_TYPE_PLAIN;
      }
      update_article_info(cur_art, article);
      cur_art->flags = 0;
   }
   _articles += ({ cur_art });
   save_article_text(cur_art, article);
   save_me();
   log_file(query_article_log_file_name(),
                 "On " + ctime(time()) + " " + person +
                 " submitted the story " + title + ".\n");
   log_file(query_article_log_file_name(), "Recommended payment for above "
                           "article: $" + fsize + ".\n");
   tell_object(this_player(), "Article submitted!\n");
   tell_room(this_object(), this_player()->the_short() +
              " submits an article to the newspaper.\n",
             this_player());
}
int do_retrieve(string edn, int source)
{
   class our_article article;
   if (_proxy) {
      return _proxy->do_retrieve(edn, source);
   }
   add_succeeded_mess("");
   if (!sizeof(_articles)) {
      add_failed_mess("There do not seem to have be any articles "
                      "submitted for this edition yet.\n");
      return 0;
   }
   article = query_article(edn);
   if (!article) {
      add_failed_mess("Sorry, " + edn + " is an incorrect article "
                      "reference.\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       !is_setter(this_player()->query_name()) &&
       lower_case(article->art->author) != this_player()->query_name()) {
      add_failed_mess("You can only read your own articles.\n");
      return 0;
   }
   show_article(article, source);
   return 1;
}
int show_article(class our_article article, int source)
{
   string text;
   mixed* bits;
   int i;
   mixed* stuff;
   class advert data;
   switch (a_type(article->art->type)) {
   case NEWSPAPER_ARTICLE_TYPE_SECTION :
      text = "%^BOLD%^" + article->art->title + "%^RESET%^\n\n";
      for (i = 0; i < sizeof(_articles); i++) {
         if (_articles[i] == article) {
            i++;
            break;
         }
      }
      for (; i < sizeof(_articles); i++) {
         if (a_type(_articles[i]->art->type) != NEWSPAPER_ARTICLE_TYPE_SECTION) {
            text += sprintf("%2d .... %70-=s\n", i + 1,
                            _articles[i]->art->title);
         }
      }
      break;
   case NEWSPAPER_ARTICLE_TYPE_ADVERTS :
      text = "%^BOLD%^" + article->art->title + "%^RESET%^\n";
      stuff = unique_array(_adverts, (: $1->category :));
      foreach (bits in stuff) {
         text += "\n$I$0=" + bits[0]->category + "\n$I$3=   ";
         foreach (data in bits) {
            text += data->text + "\n-- " + data->author + "\n\n";
         }
      }
      break;
   case NEWSPAPER_ARTICLE_TYPE_HTML :
      if (!source) {
         text = unguarded( (: NROFF_HAND->cat_file(_save_dir +
                              $(article->art->file_name) + ".nroff", 1) :) );
         if (!text) {
            text = unguarded( (: read_file(_save_dir +
                                           $(article->art->file_name)) :) );
            if (text) {
               bits = restore_variable(text);
               bits[1] = NEWSPAPER_HANDLER->convert_html(bits[1]);
               unguarded( (: write_file(_save_dir + $(article->art->file_name) +
                              ".proc", $(bits[1]), 1) :) );
               if (unguarded( (: NROFF_HAND->create_nroff(_save_dir +
                               $(article->art->file_name) + ".proc",
                           _save_dir + $(article->art->file_name) + ".nroff") :) )) {
                  text = unguarded( (: NROFF_HAND->cat_file(_save_dir +
                                   $(article->art->file_name) + ".nroff") :) );
               } else {
                  text = "Unable to make nroff file.\n";
               }
            } else {
               text = "Unable to read the article.  Opps.\n";
            }
         }
         break;
      }
   case NEWSPAPER_ARTICLE_TYPE_PLAIN :
      text = load_article_text(article);
      break;
   }
   this_player()->more_string("The article you requested reads as follows:\n" +
                   text + "\n");
   return 1;
}
int do_logs(int article_log)
{
   string logfile;
   if (_proxy) {
      return _proxy->do_logs(article_log);
   }
   if (article_log) {
      logfile = read_file(query_article_log_file_name());
   } else {
      logfile = read_file(query_log_file_name());
   }
   if (!logfile) {
      add_failed_mess("There don't appear to be any logs.\n");
      return 0;
   }
   this_player()->more_string("The log contains:\n" + logfile + "\n");
   add_succeeded_mess("");
   return 1;
}
int do_articles(int scroll)
{
   string str;
   class our_article article;
   int pos;
   int editor;
   if (_proxy) {
      return _proxy->do_articles(scroll);
   }
   str = "";
   editor = is_editor(this_player()->query_name());
   if (sizeof(_articles)) {
      str = "The articles for edition " + query_current_edition() + " are:\n";
      pos = 1;
      foreach(article in _articles) {
         if (article->art->colour) {
            str += "%^" + article->art->colour + "%^";
         }
         switch (a_type(article->art->type)) {
         case NEWSPAPER_ARTICLE_TYPE_HTML :
         case NEWSPAPER_ARTICLE_TYPE_PLAIN :
            str += sprintf("$I$5=Page %2d) %s by %s (shown author %s) submitted at %s; length %d%s%s%s\n",
               pos, article->art->title,
               (editor || article->art->author == this_player()->query_name()?article->art->author:article->art->shown_name),
               article->art->shown_name,
               ctime(article->art->date_written),
               article->length,
               (editor?" suggested payment $" + article->suggested_payment:""),
               (article->flags & NEWSPAPER_POSTPONE_FLAG?" (postponed)":""),
               (article->flags & NEWSPAPER_LOCK_FLAG?" (locked)":""),
               (a_flags(article->art->type) & NEWSPAPER_ARTICLE_NO_XP_FLAG?" (no xp)":"") );
            break;
         case NEWSPAPER_ARTICLE_TYPE_SECTION :
            str += sprintf("$I$5=Page %2d) Section Header '%s'\n",
                           pos,
                           article->art->title);
            break;
         case NEWSPAPER_ARTICLE_TYPE_ADVERTS :
            str += sprintf("$I$5=Page %2d) Adverts\n", pos);
            break;
         }
         if (article->art->colour) {
            str += "%^RESET%^";
         }
         pos++;
      }
   } else {
      str = "There are no articles in this edition yet.\n";
   }
   if (!scroll) {
      write("$P$Articles$P$" + str);
   } else {
      write(str);
   }
   return 1;
}
int do_resign()
{
   object *inv;
   object ob;
   string person;
   if (_proxy) {
      return _proxy->do_resign();
   }
   person = this_player()->query_name();
   remove_reporter(person);
   if (is_editor(person)) {
      remove_editor(person);
   }
   if (is_setter(person)) {
      remove_setter(person);
   }
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " resigned from " + query_the_paper_name() + ".\n");
   inv = match_objects_for_existence("press credentials", ({ this_player() }),
                                     this_player());
   foreach (ob in inv) {
      if (ob->query_paper_name() == query_paper_name()) {
         ob->dest_me();
      }
   }
   add_succeeded_mess(({ "You hand in your badge, and tender your "
                         "resignation from " + query_the_paper_name() +
                         ".  You can't help but feel a little "
                         "saddened as a result.\n",
                         "$N $V from " + query_the_paper_name() + ".\n" }));
   return 1;
}
int do_delete(string str)
{
   class our_article article;
   int i;
   if (_proxy) {
      return _proxy->do_delete(str);
   }
   article = query_article(str);
   if (!article) {
      add_failed_mess("There is no article referenced by " + str + ".\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       this_player()->query_name() != lower_case(article->art->author)) {
      add_failed_mess("You cannot delete this article.\n");
      return 0;
   }
   delete_article(article);
   for (i = 0; i < sizeof(_articles); i++) {
      if (_articles[i] == article) {
         _articles = _articles[0..i - 1] + _articles[i+1..];
      }
   }
   save_me();
   log_file(query_article_log_file_name(),
                    "On " + ctime(time()) + " " + this_player()->query_short() +
                    " deleted the article " + article->art->title + ".\n");
   add_succeeded_mess(({ "Article deleted!\n",
                         "$N $V an article from "
                         "the current edition.\n" }));
   return 1;
}
int do_hire(string person, int setter)
{
   string bing;
   object thatguy;
   if (_proxy) {
      return _proxy->do_hire(person, setter);
   }
   person = lower_case(person);
   if (setter) {
      if (is_setter(person)) {
         add_failed_mess("That person is already employed as a setter by " +
                         query_the_paper_name() + "!\n");
         return 0;
      }
      bing = "setter";
   } else {
      if (is_reporter(person)) {
         add_failed_mess("That person is already employed by " +
                         query_the_paper_name() + "!\n");
         return 0;
      }
      bing = "reporter";
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("There is nobody called " + capitalize(person) + "!\n");
      return 0;
   }
   thatguy = find_player(person);
   if (thatguy) {
      tell_object(thatguy, "You have "
                  "just been hired by " + this_player()->the_short() +
                  " as a " + bing + " for " +
                  query_the_paper_name() + ".\n");
   }
   if (setter) {
      add_setter(person);
   } else {
      add_reporter(person);
   }
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " employed " + capitalize(person) + " as a " + bing + ".\n");
   add_succeeded_mess(capitalize(person) +
                      " is now employed by " +
                      query_the_paper_name() + " as a " + bing + ".\n");
   return 1;
}
int do_dismiss(string person)
{
   object thatguy;
   if (_proxy) {
      return _proxy->do_dismiss(person);
   }
   if (!is_reporter(person)) {
      add_failed_mess("That person is not employed by " +
                      query_the_paper_name() + "!\n");
      return 0;
   }
   remove_reporter(person);
   remove_editor(person);
   remove_setter(person);
   thatguy = find_player(person);
   if (thatguy) {
      tell_object(thatguy, "You have "
                  "been fired from " + query_the_paper_name() + " by " + this_player()->the_short() +
                  "!\n");
   }
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " fired " + capitalize(person) + ".\n");
   add_succeeded_mess(capitalize(person) +
                      " is no longer employed by " +
                      query_the_paper_name() + ".\n");
   return 1;
}
int do_sponsor_add(string person)
{
   if (_proxy) {
      return _proxy->do_sponsor_add(person);
   }
   person = lower_case(person);
   if (is_sponsor(person)) {
      add_failed_mess(person + " is already a sponsor of " +
                      query_the_paper_name() + "!\n");
      return 0;
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess("I am sorry, but " + person + " does not exist.\n");
      return 0;
   }
   add_sponsor(person);
   add_succeeded_mess(capitalize(person) +
                      " is now a sponsor of " + query_the_paper_name() + ".\n");
   return 1;
}
int do_sponsor_remove(string person)
{
   if (_proxy) {
      return _proxy->do_sponsor_remove(person);
   }
   person = lower_case(person);
   if (!is_sponsor(person)) {
      add_failed_mess(person + " is not a sponsor of " +
                      query_the_paper_name() + "!\n");
      return 0;
   }
   remove_sponsor(person);
   add_succeeded_mess(capitalize(person) +
                      " is not a sponsor of " +
                      query_the_paper_name() + " anymore.\n");
   return 1;
}
int do_promote(string person)
{
   object thatguy;
   if (_proxy) {
      return _proxy->do_promote(person);
   }
   person = lower_case(person);
   if (!is_reporter(person)) {
      add_failed_mess("There is nobody by that name currently employed at " +
                      query_the_paper_name() + "!\n");
      return 0;
   }
   if (is_editor(person)) {
      add_failed_mess(capitalize(person) + " is already an editor!\n");
      return 0;
   }
   add_editor(person);
   thatguy = find_player(person);
   if (thatguy) {
      tell_object(thatguy, "You have "
                  "been promoted to editor of " + query_the_paper_name() + " by " +
                  this_player()->the_short() + "!\n");
   }
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " promoted " + capitalize(person) + " to " +
                 "editor.\n");
   add_succeeded_mess(capitalize(person) +
                      " is now an editor of " + query_the_paper_name() + ".\n");
   return 1;
}
int do_demote(string person, int editor)
{
   object thatguy;
   if (_proxy) {
      return _proxy->do_demote(person, editor);
   }
   person = lower_case(person);
   if (editor) {
      if (!is_editor(person)) {
         add_failed_mess
            ("There is nobody by that name currently employed as an "
             "editor at " + query_the_paper_name() + "!\n");
         return 0;
      }
      remove_editor(person);
   } else {
      if (!is_setter(person)) {
         add_failed_mess
            ("There is nobody by that name currently employed as a "
             "setter at " + query_the_paper_name() + "!\n");
         return 0;
      }
      remove_setter(person);
   }
   add_reporter(person);
   thatguy = find_player(person);
   if (thatguy) {
      tell_object(thatguy,
                  this_player()->the_short() +
                  " just demoted you as an editor of " + query_the_paper_name() + "!\n");
   }
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " demoted " + capitalize(person) +
                 " to reporter.\n");
   add_succeeded_mess(capitalize(person) +
                      " is no longer an editor of " + query_the_paper_name() + ".\n");
   return 1;
}
int do_everyone_status() {
   string ret;
   if (_proxy) {
      return _proxy->do_everyone_status();
   }
   ret = query_the_paper_name() + " has the following employees:\n";
   ret += "$I$3=Owner: " +
          query_owner() +
          "\n";
   ret += "$I$3=Reporters: " +
          query_multiple_short(sort_array(query_all_reporters(), 0)) +
          "\n";
   ret += "$I$3=Setters  : " +
          (sizeof(query_all_setters())?
          query_multiple_short(sort_array(query_all_setters(), 0)):"no one") +
          "\n";
   ret += "$I$3=Editors  : " +
          (sizeof(query_all_setters())?
          query_multiple_short(sort_array(query_all_editors() - ({ query_owner() }), 0)):"no one") +
          "\n";
   write("$P$Status$P$" + ret);
   return 1;
}
int do_status()
{
   string ret;
   int i;
   int last_num;
   if (_proxy) {
      return _proxy->do_status();
   }
   ret = query_the_paper_name() + " has the following employees:\n";
   ret += "$I$3=Owner: " +
          query_owner() +
          "\n";
   ret += "$I$3=Reporters: " +
          query_multiple_short(sort_array(query_all_reporters(), 0)) +
          "\n";
   ret += "$I$3=Setters  : " +
          (sizeof(query_all_setters())?
          query_multiple_short(sort_array(query_all_setters(), 0)):"no one") +
          "\n";
   ret += "$I$3=Editors  : " +
          (sizeof(query_all_setters())?
          query_multiple_short(sort_array(query_all_editors() - ({ query_owner() }), 0)):"no one") +
          "\n";
   ret += "$I$3=Sponsors : " +
          (sizeof(query_all_setters())?
          query_multiple_short(sort_array(query_all_sponsors(), 0)):"no one") +
          "\n";
   ret += "\n$I$0=Sale Statistics:\n";
   last_num = NEWSPAPER_HANDLER->query_last_edition_num(_paper_name);
   for (i = last_num - 5; i <= last_num; i++) {
      if (i >= 1) {
         ret += "Edition " + i + " sold to " +
             NEWSPAPER_HANDLER->query_edition_num_sold(_paper_name, i) +
             " people.\n";
      }
   }
   ret += "\n";
   ret += "Using Bank  : " + _bank_branch + "\n";
   write("$P$Status$P$" + ret);
   return 1;
}
int do_claim()
{
   object badge;
   object *deepinv;
   object *inv;
   if (_proxy) {
      return _proxy->do_claim();
   }
   deepinv = deep_inventory(this_player()) + ({ this_player() });
   inv = filter(deepinv, (: $1->query_paper_name() == query_paper_name() :));
   if (sizeof(inv)) {
      add_failed_mess
         ("You already have a set of credentials!  Why would you "
          "want another?\n");
      return 0;
   }
   badge = clone_object(NEWSPAPER_PRESS_CREDITIALS);
   badge->set_drop();
   badge->set_paper_name(query_paper_name());
   if (badge->move(this_player()) != MOVE_OK) {
      badge->move(this_object());
      tell_object(this_player(),
                  "The credentials are too heavy for you, so they fall "
                  "to the floor.\n");
   }
   badge->reset_drop();
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " claimed some new credentials.\n");
   add_succeeded_mess(({ "A new set of credentials appear from thin air, as "
                         "if by magic!\n",
                         "$N $V a set of credentials.\n" }));
   return 1;
}
int do_publish(string headline)
{
   class our_article* bing;
   if (_proxy) {
      return _proxy->do_publish(headline);
   }
   bing = filter(_articles, (: !$1->flags & NEWSPAPER_POSTPONE_FLAG :));
   if (!sizeof(bing)) {
      add_failed_mess("You cannot publish with no articles!\n");
      return 0;
   }
   write("Do you wish to publish this edition with a headline of:\n" +
          headline + "\nResponse [y/n]? ");
   add_succeeded_mess("");
   input_to("really_publish", 0, headline);
   return 1;
}
int query_total_profit(int num_articles) {
   int last_pub;
   int amount;
   int edition;
   int adds;
   class advert data;
   class our_article bing;
   string text;
   if (num_articles == -1) {
      num_articles = 0;
      foreach (bing in _articles) {
         if (!(bing->flags & NEWSPAPER_POSTPONE_FLAG)) {
            text = load_article_text(bing);
            if (strlen(text) > 500) {
               num_articles++;
            }
         }
      }
   }
   foreach (data in _adverts) {
      adds += data->value;
   }
   edition = NEWSPAPER_HANDLER->query_last_edition_num(_paper_name);
   last_pub = NEWSPAPER_HANDLER->query_edition_date(_paper_name, edition);
   amount = NEWSPAPER_HANDLER->query_edition_num_sold(_paper_name, edition) * 100;
   amount = amount * 400 + adds;
   if ((time() - last_pub) < 42 * 24 * 60 * 60) {
      return amount;
   }
   last_pub = (time() - last_pub) - 42 * 24 * 60 * 60;
   last_pub = last_pub / (24 * 60 * 60);
   amount = ( amount / 150 ) * (150 - last_pub);
   return amount + _owner_extra_cash;
}
void really_publish(string char, string headline)
{
   int article_count;
   int amount;
   int total;
   string *things;
   string temp;
   class article* to_publish;
   string* text;
   class our_article bing;
   class payee_data data;
   string stuff;
   string place;
   int i;
   int editor_bonus;
   int num_editors;
   place = query_property("place");
   char = lower_case(char);
   things = ({ });
   if (strlen(char) && char[0] == 'y') {
      tell_object(this_player(),
                  "Okay, warm up the frogs, let's see if everything is "
                  "sorted out.\n");
   } else {
      tell_object(this_player(), "Okay, publishing aborted.\n");
      return 0;
   }
   to_publish = ({ });
   text = ({ });
   foreach (bing in _articles) {
      if (!(bing->flags & NEWSPAPER_POSTPONE_FLAG)) {
         to_publish += ({ copy(bing->art) });
         text += ({ load_article_text(bing) });
         if (strlen(text[<1]) > 500) {
            article_count++;
         }
      }
   }
   amount = query_total_profit(article_count);
   foreach (temp, data in _payees) {
      total += data->paid;
   }
   num_editors = sizeof(query_all_editors() - ({ query_owner() }));
   editor_bonus = (amount * 5 / 100) / num_editors;
   total += (amount * 5 / 100) * num_editors;
   if (amount < total) {
      add_failed_mess("You have allocated paying your reporters " + total +
                      " when you only have " + amount + " total profit.\n");
      return 0;
   }
   if (!NEWSPAPER_HANDLER->publish_paper(query_paper_name(),
                                         headline,
                                         to_publish,
                                         text,
                                         _adverts,
                                         query_all_editors())) {
      tell_object(this_player(), "There was an error making the new issue!\n");
      return ;
   }
   _adverts = ({ });
   _owner_extra_cash = 0;
   stuff = "Edition summary.\nArticles posted:\n";
   foreach (bing in _articles) {
      if (!(bing->flags & NEWSPAPER_POSTPONE_FLAG)) {
         stuff += bing->art->title + " by " + bing->art->shown_name + "\n";
         delete_article(bing);
      }
   }
   _articles = filter(_articles, (: $1->flags & NEWSPAPER_POSTPONE_FLAG :));
   stuff += "\nTotal profit " +
            MONEY_HAND->money_value_string(amount, place) +
            ".\n";
   BANK_HANDLER->adjust_account(query_owner(), query_bank_branch(),
                                (amount - total));
   amount = editor_bonus;
   if (sizeof(query_all_editors() - ({ query_owner() })) > 0) {
      stuff += "\nEditors bonus " +
               query_multiple_short(query_all_editors() - ({ query_owner() })) +
               " paid " +
               MONEY_HAND->money_value_string(amount, place) + "each.\n";
      foreach (temp in query_all_editors()) {
         if (temp != query_owner()) {
            BANK_HANDLER->adjust_account(temp, query_bank_branch(),
                                         (amount));
            _reporters[temp]->total_payed += amount;
         }
      }
   }
   stuff += "\nReporters paid:\n";
   foreach (temp, data in _payees) {
      BANK_HANDLER->adjust_account(temp, query_bank_branch(), data->paid);
      if (is_reporter(temp)) {
         _reporters[temp]->total_payed += data->paid;
         stuff += temp + " " +
               MONEY_HAND->money_value_string(data->paid, place) + ".\n";
         i++;
         call_out((: AUTO_MAILER->auto_mail($1, $2, $3, $4, $5) :), i * 4,
                   temp,
                                this_object()->query_short(),
                                "Payment for new edition.",
                                "",
                                "A new edition has been released and "
                                "you have been paid!\n\n"
                                "For your work on the newspaper you "
                                "have been paid " +
                                MONEY_HAND->money_value_string(data->paid, place) +
                                ".\n\n" +
                                (data->message?data->message:"") );
      }
   }
   call_out((: AUTO_MAILER->auto_mail($1, $2, $3, $4, $5) :), i * 4,
                          implode(query_all_editors(), ","),
                          this_object()->query_short(),
                          "Published new edition.",
                          implode(query_all_editors(), ","),
                          stuff);
   log_file(query_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " published an edition of " + query_the_paper_name() + ".\n");
   _published_time = time();
   _payees = ([ ]);
   rename(query_article_log_file_name(),
             _save_dir + "article" + query_current_edition() + ".log");
   save_me();
   write("$P$Summary$P$" +
               "The pages have been sent to the printery, and another "
               "edition of " + query_the_paper_name() +
               " is about to hit the streets!  You feel rather "
               "impressed with your efforts.\n\n" + stuff);
   return;
}
int do_summary() {
   int amount;
   int adds;
   string person;
   int total;
   class our_article bing;
   class payee_data payee_data;
   string text;
   string ret;
   int article_count;
   string place;
   class advert data;
   int i;
   int last_num;
   int num_editors;
   int editor_bonus;
   if (_proxy) {
      return _proxy->do_summary();
   }
   ret = "";
   last_num = NEWSPAPER_HANDLER->query_last_edition_num(_paper_name);
   for (i = last_num - 5; i <= last_num; i++) {
      if (i >= 1) {
         ret += "Edition " + i + " sold to " +
             NEWSPAPER_HANDLER->query_edition_num_sold(_paper_name, i) +
             " people.\n";
      }
   }
   ret += "\n";
   place = query_property("place");
   foreach (bing in _articles) {
      if (!(bing->flags & NEWSPAPER_POSTPONE_FLAG)) {
         text = load_article_text(bing);
         if (strlen(text) > 500) {
            article_count++;
         }
      }
   }
   ret += "Article count of " + article_count + "\n";
   if (!_adverts) {
      _adverts = ({ });
   }
   foreach (data in _adverts) {
      adds += data->value;
   }
   amount = query_total_profit(article_count);
   foreach (person, payee_data in _payees) {
      total += payee_data->paid;
   }
   num_editors = sizeof(query_all_editors() - ({ query_owner() }));
   editor_bonus = (amount * 5 / 100) / num_editors;
   total += editor_bonus * num_editors;
   ret += "Using Bank  : " + _bank_branch + "\n";
   ret += "Total Profit: " +
         MONEY_HAND->money_value_string(amount, place) +
         ", total editor bonus " +
         MONEY_HAND->money_value_string(editor_bonus * num_editors, place) +
         ", total paid to reporters " +
         MONEY_HAND->money_value_string(total, place) +
         ", profit from adverts " +
         MONEY_HAND->money_value_string(adds, place) +
         (_owner_extra_cash > 0 ?
         ", " + MONEY_HAND->money_value_string(_owner_extra_cash, place) +
            " extra added by the owner":"") +
         ".\n\n";
   ret += "Owner/Editors:\n";
   ret += "   " + query_owner() + " " +
          MONEY_HAND->money_value_string((amount - total), place) +
          " (owner)\n";
   ret += "Reporters:\n";
   foreach (person, payee_data in _payees) {
      if (!is_editor(person)) {
         ret += "$I$6=   " + person + " " +
                MONEY_HAND->money_value_string(payee_data->paid, place) +
                (payee_data->message?" " + payee_data->message:"") + ".\n";
      }
   }
   ret += "$I$0=Editor Bonuses:\n";
   foreach (person in query_all_editors()) {
      if (person != query_owner()) {
         if (!_payees[person]) {
            _payees[person] = new(class payee_data);
         }
         ret += "   " + person  + " " +
                MONEY_HAND->money_value_string(editor_bonus, place) +
                " Total " +
                MONEY_HAND->money_value_string((editor_bonus + _payees[person]->paid), place) +
                "\n";
      }
   }
   write("$P$Profits$P$" + ret);
   return 1;
}
int do_deposit(string amt) {
   int amt_int;
   string place;
   if (_proxy) {
      return _proxy->do_deposit(amt);
   }
   if (this_player()->query_name() != query_owner()) {
      add_failed_mess("Only the owner can do this.\n");
      return 0;
   }
   place = query_property("place");
   amt_int = MONEY_HAND->value_from_string(amt, place);
   if (amt_int <= 0) {
      add_failed_mess("The amount " + amt + " is invalid.\n");
      return 0;
   }
   if (BANK_HANDLER->query_account(this_player()->query_name(), query_bank_branch()) <
       amt_int) {
      add_failed_mess("You do not have " +
                      MONEY_HAND->money_value_string(amt_int, place) +
                      " in " + query_bank_branch() + ".\n");
      return 0;
   }
   _owner_extra_cash += amt_int;
   save_me();
   BANK_HANDLER->adjust_account(this_player()->query_name(), _bank_branch, -amt_int);
   add_succeeded_mess(({ "$N deposit " +
                      MONEY_HAND->money_value_string(amt_int, place) +
                      " for extra cash to pay reporters.\n",
                      "$N deposits some extra cash for reporters.\n" }));
   return 1;
}
int do_set_bank_branch(string branch)
{
   string* accounts;
   if (_proxy) {
      return _proxy->do_set_bank_branch(branch);
   }
   accounts = BANK_HANDLER->query_accounts(this_player()->query_name());
   if (member_array(branch, accounts) == -1) {
      add_failed_mess("You need to specify a bank you have an account "
                      "with: " + query_multiple_short(accounts) +
                      ".\n");
      return 0;
   }
   _bank_branch = branch;
   save_me();
   add_succeeded_mess("$N set$s the bank branch to " + branch + ".\n");
   return 1;
}
int do_pay(string person,
           string amt)
{
   string place;
   string fluff;
   int amount;
   int profit;
   int total;
   class payee_data data;
   if (_proxy) {
      return _proxy->do_pay(person, amt);
   }
   place = query_property("place");
   if (amt == "none" || amt == "0") {
      amount = 0;
   } else {
      amount = MONEY_HAND->value_from_string(amt, place);
      if (amount <= 0) {
         add_failed_mess("Sorry, you must pay reporters a "
                         "positive amount.\n");
         return 0;
      }
   }
   if (!is_reporter(person)) {
      add_failed_mess("There is nobody by that name currently employed at " +
                       query_the_paper_name() + "!\n");
      return 0;
   }
   if (person == query_owner()) {
      add_failed_mess("The owner gets paid anyway.\n");
      return 0;
   }
   profit = query_total_profit(-1);
   profit = profit * 95 / 100;
   foreach (fluff, data in _payees) {
      total += data->paid;
   }
   if (profit - total - amount < 0) {
      add_failed_mess("You are not making enough money to pay " +
                      person + " " +
                      MONEY_HAND->money_value_string(amount, place) +
                      ".\n");
      return 0;
   }
   if (!_payees[person]) {
      _payees[person] = new(class payee_data);
   }
   _payees[person]->paid = amount;
   if (_payees[person]->paid < 0) {
      add_succeeded_mess(({ "You can't pay anybody less than nothing!  "
                            "Amount owing reset to nothing.\n", "" }));
      map_delete(_payees, person);
      save_me();
      return 1;
   }
   if (!_payees[person]->paid) {
      add_succeeded_mess(({ "Ok, amount owing set to nothing.\n", "" }));
      map_delete(_payees, person);
      save_me();
      return 1;
   }
   add_succeeded_mess(({ "Ok, " + capitalize(person) + " will be paid a "
                         "total of " +
                     MONEY_HAND->money_value_string(_payees[person]->paid, place) +
                         " for this edition.\n", "" }));
   save_me();
   return 1;
}
int do_pay_tag(string person,
               string tag)
{
   if (_proxy) {
      return _proxy->do_pay_tag(person, tag);
   }
   if (tag == "none") {
      tag = 0;
   }
   if (!is_reporter(person)) {
      add_failed_mess("There is nobody by that name currently employed at " +
                       query_the_paper_name() + "!\n");
      return 0;
   }
   if (person == query_owner()) {
      add_failed_mess("The owner gets paid anyway.\n");
      return 0;
   }
   if (!_payees[person]) {
      add_failed_mess("You can only set a reason for someone who is "
                      "being paid.\n");
      return 0;
   }
   _payees[person]->message = tag;
   if (!tag) {
      add_succeeded_mess(({ "You remove the message from " +
                            capitalize(person) + ".\n", "" }));
   } else {
      add_succeeded_mess(({ "You set a message to " + capitalize(person) +
                            " of " + tag + ".\n", "" }));
   }
   save_me();
   return 1;
}
int do_title(string id, string title)
{
   class our_article art;
   if (_proxy) {
      return _proxy->do_title(id, title);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article you wish to edit doesn't exist!\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       !is_setter(this_player()->query_name()) &&
       lower_case(art->art->author) != this_player()->query_name()) {
      add_failed_mess("You can only edit your own articles.\n");
      return 0;
   }
   art->art->title = title;
   save_me();
   add_succeeded_mess(({ "You set the title to " + title + ".\n",
                         "$N sets the title of an article.\n" }));
   return 1;
}
int do_author(string id, string author)
{
   class our_article art;
   if (_proxy) {
      return _proxy->do_author(id, author);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article you wish to edit doesn't exist!\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       !is_setter(this_player()->query_name()) &&
       lower_case(art->art->author) != this_player()->query_name()) {
      add_failed_mess("You can only edit your own articles.\n");
      return 0;
   }
   art->art->shown_name = author;
   save_me();
   add_succeeded_mess(({ "You set the author to " + author + ".\n",
                         "$N sets the author of an article.\n" }));
   return 1;
}
int do_change(string id, string type)
{
   class our_article art;
   if (_proxy) {
      return _proxy->do_change(id, type);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article you wish to edit doesn't exist!\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       !is_setter(this_player()->query_name()) &&
       lower_case(art->art->author) != this_player()->query_name()) {
      add_failed_mess("You can only edit your own articles.\n");
      return 0;
   }
   if (type == "html") {
      art->art->type = NEWSPAPER_ARTICLE_TYPE_HTML | a_flags(art->art->type);
   } else {
      art->art->type = NEWSPAPER_ARTICLE_TYPE_PLAIN | a_flags(art->art->type);
   }
   save_me();
   unguarded( (: rm(_save_dir + $(art->art->file_name) + ".proc" ) :) );
   unguarded( (: rm(_save_dir + $(art->art->file_name) + ".nroff.o" ) :) );
   add_succeeded_mess(({ "You set the article type to " + type + ".\n",
                         "$N sets the type of an article.\n" }));
   return 1;
}
int do_change_xp(string id, string type)
{
   class our_article art;
   if (_proxy) {
      return _proxy->do_change_xp(id, type);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article you wish to edit doesn't exist!\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name())) {
      add_failed_mess("Only the editors can do this.\n");
      return 0;
   }
   if (type == "none") {
      art->art->type |= NEWSPAPER_ARTICLE_NO_XP_FLAG;
   } else {
      art->art->type &= ~NEWSPAPER_ARTICLE_NO_XP_FLAG;
   }
   save_me();
   add_succeeded_mess(({ "You set the article xp return to " + type + ".\n",
                         "$N sets the xp return of an article.\n" }));
   return 1;
}
int do_change_colour(string id, string colour)
{
   class our_article art;
   if (_proxy) {
      return _proxy->do_change_colour(id, colour);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article you wish to edit doesn't exist!\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       !is_setter(this_player()->query_name()) &&
       lower_case(art->art->author) != this_player()->query_name()) {
      add_failed_mess("You can only edit your own articles.\n");
      return 0;
   }
   if (colour != "none") {
      art->art->colour = upper_case(colour);
   } else {
      art->art->colour = 0;
   }
   save_me();
   add_succeeded_mess(({ "You set the article colour to " + colour + ".\n",
                         "$N sets the colour of an article.\n" }));
   return 1;
}
int do_editing(string id)
{
   class our_article art;
   string contents;
   if (_proxy) {
      return _proxy->do_editing(id);
   }
   if (_locked) {
      add_failed_mess("The newspaper office is currently locked for "
                      "submissions.\n");
      return 0;
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article you wish to edit doesn't exist!\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name()) &&
       lower_case(art->art->author) != this_player()->query_name()) {
      add_failed_mess("You can only edit your own articles.\n");
      return 0;
   }
   if (art->flags & NEWSPAPER_LOCK_FLAG) {
      add_failed_mess("This article is locked.\n");
      return 0;
   }
   contents = load_article_text(art);
   add_succeeded_mess("");
   this_player()->do_edit(contents, "finish_editing", this_object(), 0, art);
   return 1;
}
int move_article(int index, string up_down) {
   class our_article womble;
   if (index == -1) {
      return 0;
   }
   womble = _articles[index];
   if (up_down == "up") {
      if (index > 0) {
         _articles = _articles[0..index - 1] + _articles[index+1..];
         _articles = _articles[0..index - 2] + ({ womble }) +
                     _articles[index - 1..];
         save_me();
      } else {
         return 0;
      }
   } else {
      if (index < sizeof(_articles) - 1) {
         _articles = _articles[0..index - 1] + _articles[index+1..];
         _articles = _articles[0..index] + ({ womble }) +
                     _articles[index + 1..];
         save_me();
      } else {
         return 0;
      }
   }
   return 1;
}
int do_move(string article, string up_down) {
   int index;
   class our_article womble;
   if (_proxy) {
      return _proxy->do_move(article, up_down);
   }
   index = query_article_index(article);
   if (index == -1) {
      add_failed_mess("Article reference " + index + " is out of bounds.\n");
      return 0;
   }
   womble = _articles[index];
   if (!move_article(index, up_down)) {
      add_failed_mess("Unable to move the article.\n");
      return 0;
   }
   add_succeeded_mess(({ "You moved the article " + womble->art->title + " " +
                         up_down + ".\n", "" }));
   return 1;
}
int do_move_pos(string article, string pos) {
   int index;
   int to_index;
   class our_article womble;
   if (_proxy) {
      return _proxy->do_move_pos(article, pos);
   }
   index = query_article_index(article);
   if (index == -1) {
      add_failed_mess("Article reference " + index + " is out of bounds.\n");
      return 0;
   }
   to_index = query_article_index(pos);
   if (to_index == -1) {
      add_failed_mess("Article reference " + pos + " is out of bounds.\n");
      return 0;
   }
   if (to_index == index) {
      add_failed_mess("You cannot move the article there, it is already "
                      "there.\n");
      return 0;
   }
   womble = _articles[index];
   if (index < to_index) {
      _articles = _articles[0..index - 1] + _articles[index + 1..to_index] +
                  ({ _articles[index] }) + _articles[to_index+1..];
   } else {
      _articles = _articles[0..to_index - 1] +
                  ({ _articles[index] }) +
                  _articles[to_index..index - 1] +
                  _articles[index+1..];
   }
   save_me();
   add_succeeded_mess(({ "You moved the article " + womble->art->title +
                         " to " + pos + ".\n", "" }));
   return 1;
}
int do_postpone(string id, string on_off) {
   class our_article art;
   if (_proxy) {
      return _proxy->do_postpone(id, on_off);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article reference " + id + " does not exist.\n");
      return 0;
   }
   if (on_off == "on") {
      art->flags |= NEWSPAPER_POSTPONE_FLAG;
      add_succeeded_mess(({ "You postpone the article " + art->art->title +
                            " to a later issue.\n",
                            "" }));
   } else {
      art->flags &= ~NEWSPAPER_POSTPONE_FLAG;
      add_succeeded_mess(({ "You unpostpone the article " + art->art->title +
                            " so it will be in this issue.\n",
                            "" }));
   }
   save_me();
   return 1;
}
int do_lock_article(string id, string on_off) {
   class our_article art;
   if (_proxy) {
      return _proxy->do_lock_article(id, on_off);
   }
   art = query_article(id);
   if (!art) {
      add_failed_mess("The article reference " + id + " does not exist.\n");
      return 0;
   }
   if (on_off == "on") {
      art->flags |= NEWSPAPER_LOCK_FLAG;
      add_succeeded_mess(({ "You lock the article " + art->art->title +
                            ".\n",
                            "" }));
   } else {
      art->flags &= ~NEWSPAPER_LOCK_FLAG;
      add_succeeded_mess(({ "You unlock the article " + art->art->title +
                            ".\n",
                            "" }));
   }
   save_me();
   return 1;
}
int do_category_list() {
   string ret;
   string place;
   string name;
   class category_data data;
   if (_proxy) {
      return _proxy->do_category_list();
   }
   if (!sizeof(_category)) {
      add_failed_mess("There are no categories.\n");
      return 0;
   }
   ret = "";
   place = query_property("place");
   foreach (name, data in _category) {
      ret += "$I$5=" + name + " costs ";
      if (data->cost_per_add) {
         ret += MONEY_HAND->money_value_string(data->cost_per_add, place);
      } else {
         ret += "nothing";
      }
      ret += " per add and ";
      if (data->cost_per_ten_chars) {
         ret += MONEY_HAND->money_value_string(data->cost_per_ten_chars,
                                               place);
      } else {
         ret += "nothing";
      }
      ret += " for every ten characters.";
      if (!data->open) {
         ret += "  The category is currently closed.\n";
      } else {
         ret += "\n";
      }
   }
   write("$P$Category$P$" + ret);
   return 1;
}
int do_advert_list() {
   string ret;
   string place;
   class advert data;
   int editor;
   int found;
   int pos;
   if (_proxy) {
      return _proxy->do_advert_list();
   }
   if (!sizeof(_adverts)) {
      add_failed_mess("There are no adverts.\n");
      return 0;
   }
   ret = "";
   place = query_property("place");
   editor = is_editor(this_player()->query_name());
   pos = 1;
   foreach (data in _adverts) {
      if (editor ||
          lower_case(data->author) == this_player()->query_name()) {
         if (editor) {
            ret += "$I$5=" + pos + ") ";
         } else {
            ret += "$I$5=";
         }
         ret += data->author + " cost " +
                MONEY_HAND->money_value_string(data->value, place) +
                " written at " + ctime(data->date_written) + ":\n" +
                data->text + "\n";
         found = 1;
      }
      pos++;
   }
   if (!found) {
      add_failed_mess("There are no adverts.\n");
      return 0;
   }
   write("$P$Category$P$" + ret);
   return 1;
}
int do_advert_remove(int id) {
   class advert fluff;
   if (_proxy) {
      return _proxy->do_advert_remove(id);
   }
   if (!sizeof(_adverts)) {
      add_failed_mess("There are no adverts.\n");
      return 0;
   }
   if (!is_editor(this_player()->query_name())) {
      add_failed_mess("You must be an editor to remove adverts.\n");
      return 0;
   }
   if (id < 1 || id > sizeof(_adverts)) {
      add_failed_mess("The id " + id + " is invalid.\n");
      return 0;
   }
   fluff = _adverts[id - 1];
   _adverts = _adverts[0..id-2] + _adverts[id..];
   add_succeeded_mess("$N remove$s an advert by " + fluff->author + ".\n");
   return 1;
}
int do_category_remove(string category) {
   if (_proxy) {
      return _proxy->do_category_remove(category);
   }
   category = query_category(category);
   if (!category) {
      add_failed_mess("You must have a category to delete it.\n");
      return 0;
   }
   if (sizeof(filter(_adverts, (: $1->category == $2 :), category))) {
      add_failed_mess("You have adverts in that category, you cannot "
                      "remove it.\n");
      return 0;
   }
   map_delete(_category, category);
   save_me();
   add_succeeded_mess(({ "You delete the category " + category + ".\n",
                          "" }));
   return 1;
}
int do_category_add(string category) {
   string new_category;
   if (_proxy) {
      return _proxy->do_category_add(category);
   }
   new_category = query_category(category);
   if (new_category) {
      add_failed_mess("You must have a category to delete it.\n");
      return 0;
   }
   _category[category] = new(class category_data,
                             open : 0,
                             cost_per_add : 40,
                             cost_per_ten_chars : 40);
   save_me();
   add_succeeded_mess(({ "You add the category " + category + ".\n",
                          "" }));
   return 1;
}
int do_category_open(string category, string open) {
   if (_proxy) {
      return _proxy->do_category_open(category, open);
   }
   category = query_category(category);
   if (!category) {
      add_failed_mess("You must have a category to delete it.\n");
      return 0;
   }
   _category[category]->open = open == "open";
   save_me();
   add_succeeded_mess(({ "You " + open + " the category " + category + ".\n",
                          "" }));
   return 1;
}
int do_category_cost(string category, string cost) {
   int value;
   string place;
   if (_proxy) {
      return _proxy->do_category_cost(category, cost);
   }
   category = query_category(category);
   if (!category) {
      add_failed_mess("You must change a cost for a category.\n");
      return 0;
   }
   place = query_property("place");
   if (lower_case(cost) == "none") {
      value = 0;
   } else {
      value = MONEY_HAND->value_from_string(cost, place);
      if (!value) {
         add_failed_mess("The value " + cost + " is not a valid money "
                         "value.\n");
         return 0;
      }
   }
   _category[category]->cost_per_add = value;
   save_me();
   add_succeeded_mess(({ "You set the cost per add in category " +
                         category + " to " +
                         MONEY_HAND->money_value_string(value, place) +
                         ".\n",
                          "" }));
   return 1;
}
int do_category_cost_per_ten_chars(string category, string cost) {
   int value;
   string place;
   if (_proxy) {
      return _proxy->do_category_cost_per_ten_chars(category, cost);
   }
   category = query_category(category);
   if (!category) {
      add_failed_mess("You must change a cost for a category.\n");
      return 0;
   }
   place = query_property("place");
   if (lower_case(cost) == "none") {
      value = 0;
   } else {
      value = MONEY_HAND->value_from_string(cost, place);
      if (!value) {
         add_failed_mess("The value " + cost + " is not a valid money "
                         "value.\n");
         return 0;
      }
   }
   _category[category]->cost_per_ten_chars = value;
   save_me();
   add_succeeded_mess(({ "You set the cost per ten characters in category " +
                         category + " to " +
                         MONEY_HAND->money_value_string(value, place) +
                         ".\n",
                          "" }));
   return 1;
}
int do_submit_section(string name) {
   class our_article cur_art;
   if (_proxy) {
      return _proxy->do_submit_section(name);
   }
   if (_locked) {
      add_failed_mess("The newspaper office is currently locked.\n");
      return 0;
   }
   cur_art = new(class our_article);
   cur_art->art = new(class article);
   cur_art->art->title = name;
   cur_art->art->shown_name = this_player()->query_name();
   cur_art->art->author = this_player()->query_name();
   cur_art->art->date_written = time();
   cur_art->art->type = NEWSPAPER_ARTICLE_TYPE_SECTION;
   _articles += ({ cur_art });
   save_me();
   add_succeeded_mess("$N $V a section.\n");
   return 1;
}
int do_submit_add(string category) {
   if (_proxy) {
      return _proxy->do_submit_add(category);
   }
   if (_locked) {
      add_failed_mess("The newspaper office is currently locked.\n");
      return 0;
   }
   category = query_category(category);
   if (!category) {
      add_failed_mess("You must specify an existing category to "
                      "submit an add in.\n");
      return 0;
   }
   if (!_category[category]->open) {
      add_failed_mess("The category must be open to submit an add "
                      "for it.\n");
      return 0;
   }
   add_succeeded_mess(({ "", "$N starts submiting an add to " +
                 this_object()->the_short() +
                      ".\n" }));
   write("Please submit the text of your add:\n");
   this_player()->do_edit(0, "finish_add", this_object(), 0, category);
   return 1;
}
int do_lock(int locked) {
   if (_proxy) {
      return _proxy->do_lock(locked);
   }
   _locked = locked;
   if (_locked) {
      add_succeeded_mess("$N lock$s " + this_object()->the_short() + ".\n");
   } else {
      add_succeeded_mess("$N unlock$s " + this_object()->the_short() + ".\n");
   }
   return 1;
}
void finish_add(string str, string category) {
   int value;
   string place;
   if (!str || !strlen(str)) {
      write("Ok, Aborted writing an add.\n");
      return ;
   }
   if (is_sponsor(this_player()->query_name())) {
      write("You add in the category " + category + " with a text of:\n" +
             str + "\n\nThis will cost you nothing since you are a sponsor.\n"
               ", do you want to do this? ");
      input_to("confirm_add", 0, str, category, 0);
   } else {
      place = query_property("place");
      value = _category[category]->cost_per_add +
              _category[category]->cost_per_ten_chars * strlen(str) / 10;
      if (this_player()->query_value_in(place) < value) {
         write("You add in the category " + category + " with a text of:\n" +
               str + "\n\nThis will cost you " +
               MONEY_HAND->money_value_string(value, place) +
               ", but you do not have enough money!  Sorry.\n");
      } else {
         write("You add in the category " + category + " with a text of:\n" +
               str + "\n\nThis will cost you " +
               MONEY_HAND->money_value_string(value, place) +
               ", do you want to do this? ");
         input_to("confirm_add", 0, str, category, value);
      }
   }
}
void confirm_add(string str, string text, string category, int value) {
   class advert add;
   string place;
   int found;
   class our_article bing;
   if (!str || !strlen(str)) {
      return 0;
   }
   if (lower_case(str)[0] != 'y') {
      write("Ok, aborting.\n");
      return ;
   }
   if (!is_sponsor(this_player()->query_name())) {
      place = query_property("place");
      if (this_player()->query_value_in(place) < value) {
         add_failed_mess("You do not have " +
            MONEY_HAND->money_value_string(value, place) +
            " to pay for the add.\n");
         return ;
      }
      this_player()->pay_money(MONEY_HAND->create_money_array(value, place),
                               place);
   }
   add = new(class advert);
   add->author = this_player()->query_cap_name();
   add->text = text;
   add->category = category;
   add->value = value;
   add->date_written = time();
   _adverts += ({ add });
   foreach (bing in _articles) {
      if (a_type(bing->art->type) == NEWSPAPER_ARTICLE_TYPE_ADVERTS) {
         found = 1;
         break;
      }
   }
   if (!found) {
      _articles += ({ new(class our_article,
                          art : new(class article,
                                    title : "Adverts",
                                    author : query_owner(),
                                    shown_name : query_owner(),
                                    date_written : time(),
                                    type : NEWSPAPER_ARTICLE_TYPE_ADVERTS
                                   )
                          ) });
   }
   save_me();
   write("Ok, your advertisement is added.\n");
}
int finish_editing(string story, class our_article art)
{
   if (!story) {
      tell_object(this_player(), "Ok, no editing saved.\n");
      return 0;
   }
   save_article_text(art, story);
   log_file(query_article_log_file_name(),
                 "On " + ctime(time()) + " " + this_player()->query_short() +
                 " edited the story " + art->art->title + ".\n");
}
int do_transfer_ownership(string new_owner) {
   int value;
   string place;
   if (!is_owner(this_player()->query_name())) {
      add_failed_mess("You must be the owner to transfer the ownership.\n");
      return 0;
   }
   if (_proxy) {
      add_failed_mess("You must be in the main office to transfer ownership.\n");
      return 0;
   }
   if (!PLAYER_HANDLER->test_user(new_owner)) {
      add_failed_mess("You must transfer ownership to someone that exists.\n");
      return 0;
   }
   place = query_property("place");
   value = HOUSING->query_value(base_name(this_object()));
   if (this_player()->query_value_in(place) < value &&
       BANK_HANDLER->query_account(this_player()->query_name(), query_bank_branch()) <
       value) {
      add_failed_mess("You need at least " +
                      MONEY_HAND->money_value_string(value, place)  +
                      " to transfer the ownership, in hand or in the bank.\n");
      return 0;
   }
   write("It will cost you " + MONEY_HAND->money_value_string(value, place)  +
         " in fees to transfer ownership to " +
         new_owner + ".\nDo you want to do this? ");
   input_to("check_transfer", 0, new_owner, value);
   add_succeeded_mess("");
   return 1;
}
void check_transfer(string test, string new_owner, int value) {
   string place;
   test = lower_case(test);
   if (!strlen(test) || test[0] != 'y') {
      write("Aborted.\n");
      return 0;
   }
   place = query_property("place");
   if (this_player()->query_value_in(place) < value  &&
       BANK_HANDLER->query_account(this_player()->query_name(), query_bank_branch()) <
       value) {
      write("You need at least " +
                      MONEY_HAND->money_value_string(value, place)  +
                      " to transfer the ownership.\n");
      return 0;
   }
   if (this_player()->query_value_in(place) >= value ) {
      this_player()->pay_money(MONEY_HAND->create_money_array(value, place), place);
   } else {
       BANK_HANDLER->adjust_account(this_player()->query_name(), query_bank_branch(), -value);
   }
   write("Transfering the ownership from " +
         query_owner() + " to " + new_owner + ".\n");
   HOUSING->set_owner(base_name(this_object()), new_owner);
}
string* query_all_reporters()
{
   return keys(_reporters);
}
string* query_all_setters()
{
   return copy(_setters);
}
string* query_all_sponsors()
{
   return copy(_sponsors);
}
string* query_all_editors()
{
   return _editors + ({ query_owner() });
}
mapping query_all_payees()
{
   return copy(_payees);
}
class article* query_all_articles() {
   return map(_articles, (: copy($1->art) :) );
}
int is_postponed(class article art) {
   class our_article rabbit;
   foreach (rabbit in _articles) {
      if (rabbit->art->file_name == art->file_name) {
         return rabbit->flags & NEWSPAPER_POSTPONE_FLAG;
      }
   }
   return 0;
}
int is_locked(class article art) {
   class our_article rabbit;
   foreach (rabbit in _articles) {
      if (rabbit->art->file_name == art->file_name) {
         return rabbit->flags & NEWSPAPER_LOCK_FLAG;
      }
   }
   return 0;
}
int is_reporter(string word)
{
   if (_proxy) {
      return _proxy->is_reporter(word);
   }
   return classp(_reporters[word]);
}
int is_setter(string word)
{
   if (_proxy) {
      return _proxy->is_setter(word);
   }
   return member_array(word, _setters) != -1;
}
int is_sponsor(string word)
{
   if (_proxy) {
      return _proxy->is_sponsor(word);
   }
   return member_array(word, _sponsors) != -1;
}
int is_editor(string word)
{
   if (_proxy) {
      return _proxy->is_editor(word);
   }
   if (master()->query_administrator(word)) {
      return 1;
   }
   if (word == query_owner()) {
      return 1;
   }
   return member_array(word, _editors) != -1;
}
int is_owner(string word)
{
   if (_proxy) {
      return _proxy->is_owner(word);
   }
   if (master()->query_administrator(word)) {
      return 1;
   }
   if (word == query_owner()) {
      return 1;
   }
   return 0;
}
void add_reporter(string word)
{
   if (!_reporters[word]) {
      _reporters[word] = new(class reporter);
      _reporters[word]->date_added = time();
      update_commands(word);
      save_me();
   }
}
void add_sponsor(string word)
{
   if (!is_sponsor(word)) {
      _sponsors += ({ word });
      update_commands(word);
      save_me();
   }
}
void add_setter(string word)
{
   if (!is_setter(word)) {
      if (!is_reporter(word)) {
         add_reporter(word);
      }
      _setters += ({ word });
      update_commands(word);
      save_me();
   }
}
void add_editor(string word)
{
   if (!is_editor(word)) {
      if (!is_reporter(word)) {
         add_reporter(word);
      }
      _editors += ({ word });
      update_commands(word);
      save_me();
   }
}
void remove_reporter(string word)
{
   if (!is_reporter(word)) {
      return;
   }
   map_delete(_reporters, word);
   update_commands(word);
   save_me();
}
void remove_editor(string word)
{
   if (!is_editor(word)) {
      return;
   }
   _editors -= ({ word });
   update_commands(word);
   save_me();
}
void remove_setter(string word)
{
   if (!is_setter(word)) {
      return;
   }
   _setters -= ({ word });
   update_commands(word);
   save_me();
}
void remove_sponsor(string word)
{
   if (!is_sponsor(word)) {
      return;
   }
   _sponsors -= ({ word });
   save_me();
}
void update_commands(string word)
{
   object player;
   player = find_player(word);
   if (player && environment(player) == this_object()) {
      player->move("/room/void");
      player->move(file_name(this_object()));
   }
}
string query_owner() {
   if (_proxy) {
      return _proxy->query_owner();
   }
   return _owner;
}
void set_owner(string person) {
   _owner = person;
   save_me();
}
void ownership_change(string old_owner, string new_owner) {
   set_owner(new_owner);
}
void set_proxy(string proxy) {
   _proxy = proxy;
}
string query_proxy() {
   return _proxy;
}
int board_access_check(int type, string board, object previous, string name) {
   switch (type) {
   case B_ACCESS_READ :
      return is_reporter(lower_case(name));
   case B_ACCESS_WRITE :
      return is_reporter(lower_case(name));
   case B_ACCESS_DELETE :
      return is_editor(name);
   }
}
void init()
{
   string person;
   person = this_player()->query_name();
   add_command("advert", "categories", (: do_category_list() :));
   add_command("advert", "list", (: do_advert_list() :));
   add_command("category", "list", (: do_category_list() :));
   add_command("submit", "advert {in|to|into} <string'category'>",
               (: do_submit_add($4[1]) :));
   add_command("submit", "advert <string'category'>",
               (: do_submit_add($4[0]) :));
   if (!is_editor(person) && !is_reporter(person) && !is_setter(person)) {
      add_command("apply", "", (: do_apply() :));
      add_command("status", "", (: do_everyone_status() :));
      return;
   }
   add_command("submit", "text <string:quoted'article name'> as <string'author'>",
               (: do_submit($4[0], $4[1], 0) :));
   add_command("submit", "html <string:quoted'article name'> as <string'author'>",
               (: do_submit($4[0], $4[1], 1) :));
   add_command("submit", "text <string'article name'>",
               (: do_submit($4[0], 0, 0) :));
   add_command("submit", "html <string'article name'>",
               (: do_submit($4[0], 0, 1) :));
   add_command("retrieve", "<string'article'>", (: do_retrieve($4[0], 0) :));
   add_command("retrieve", "source <string'article'>",
               (: do_retrieve($4[0], 1) :));
   add_command("resign", "", (: do_resign() :));
   add_command("status", "", (: do_status() :));
   add_command("status", "room", (: do_status() :));
   add_command("claim", "", (: do_claim() :));
   add_command("articles", "", (: do_articles(0) :));
   add_command("articles", "scroll", (: do_articles(1) :));
   add_command("edit", "<string'article'>", (: do_editing($4[0]) :));
   add_command("delete", "<string'article'>", (: do_delete($4[0]) :));
   add_command("title", "<string'article'> <string'new title'>",
               (: do_title($4[0], $4[1]) :));
   add_command("author", "<string'article'> <string'new author name'>",
               (: do_author($4[0], $4[1]) :));
   add_command("change", "type of <string'article'> to {html|plain}",
               (: do_change($4[0], $4[1]) :));
   if (!is_setter(person) && !is_editor(person)) {
      return;
   }
   add_command("change", "colour of <string'article'> to {red|blue|green|cyan|magenta|yellow|brown|none}",
               (: do_change_colour($4[0], $4[1]) :));
   add_command("move", "<string'article'> {up|down}",
               (: do_move($4[0], $4[1]) :));
   add_command("move", "<string'article'> to <string'position'>",
               (: do_move_pos($4[0], $4[1]) :));
   if (!is_editor(person)) {
      return;
   }
   add_command("change", "xp [return] of <string'article'> to {none|normal}",
               (: do_change_xp($4[0], $4[1]) :));
   add_command("submit", "section <string'section name'>",
               (: do_submit_section($4[0]) :));
   add_command("add", "reporter <string'person'>", (: do_hire($4[0], 0) :));
   add_command("add", "setter <string'person'>", (: do_hire($4[0], 1) :));
   add_command("add", "editor <string'person'>", (: do_promote($4[0]) :));
   add_command("add", "sponsor <string'person'>", (: do_sponsor_add($4[0]) :));
   add_command("remove", "editor <string'person'>", (: do_demote($4[0], 1) :));
   add_command("remove", "setter <string'person'>", (: do_demote($4[0], 0) :));
   add_command("remove", "reporter <string'person'>", (: do_dismiss($4[0]) :));
   add_command("remove", "sponsor <string'person'>", (: do_sponsor_remove($4[0]) :));
   add_command("log", "", (: do_logs(0) :));
   add_command("log", "article", (: do_logs(1) :));
   add_command("pay", "bank branch <string'bank name'>",
               (: do_set_bank_branch($4[0]) :));
   add_command("pay", "<word'person'> <string'amount|none'>",
               (: do_pay($4[0], $4[1]) :));
   add_command("pay", "<word'person'> message <string'message|none'>",
               (: do_pay_tag($4[0], $4[1]) :));
   add_command("profit", "", (: do_summary() :));
   add_command("profit", "deposit extra <string'cash'>",
               (: do_deposit($4[0]) :));
   add_command("postpone", "<string'article'> {on|off}",
               (: do_postpone($4[0], $4[1]) :));
   add_command("lock", "articles {on|off}", (: do_lock($4[0] == "on") :));
   add_command("lock", "article <string'article'> {on|off}",
               (: do_lock_article($4[0], $4[1]) :));
   add_command("publish", "with headline <string'headline'>",
               (: do_publish($4[0]) :));
   add_command("category", "{open|close} <string'catgory'>",
               (: do_category_open($4[1], $4[0]) :));
   add_command("category", "add <string'catgory'>",
               (: do_category_add($4[0]) :));
   add_command("category", "remove <string'catgory'>",
               (: do_category_remove($4[0]) :));
   add_command("category", "cost <string'category'> per add <string'cost|none'>",
               (: do_category_cost($4[0], $4[1]) :));
   add_command("category", "cost <string'category'> per ten characters <string'cost|none'>",
               (: do_category_cost_per_ten_chars($4[0], $4[1]) :));
   add_command("advert", "remove <number'id'>", (: do_advert_remove($4[0]) :));
   if (!is_owner(this_player()->query_name())) {
      return ;
   }
   add_command("transfer", "paper ownership to <string'name'>",
               (: do_transfer_ownership($4[0]) :));
}
class advert* query_ads() { return _adverts; }

==================================================
FILE: room/inherit/owned_room.c
==================================================

#include <room.h>
private string _owner;
private string* _allowed;
private nosave string _save_file;
private nosave string _front_door;
protected int do_allow(string name);
protected int do_throwout(string name);
protected int do_disallow(string name);
void load_room();
varargs mixed call_door( string direc,
                         string func,
                         mixed arg1,
                         mixed arg2,
                         mixed arg3);
string query_owner();
void create() {
   _allowed = ({ });
   load_room();
}
void init() {
   if (this_player()->query_name() == query_owner()) {
      add_command("room",
                  "allow <string'person'>",
                  (: do_allow($4[0]) :));
      add_command("room",
                  "disallow <string'person'>",
                  (: do_disallow($4[0]) :));
      add_command("room",
                  "throwout <indirect:living'person'>",
                  (: do_throwout($4[0]) :));
   }
}
void set_save_file(string name) {
   _save_file = name;
}
string query_save_file() {
   return _save_file;
}
string *query_allowed() {
   return _allowed;
}
protected void set_allowed(string *allowed) {
   _allowed = allowed;
}
string query_owner() {
   return _owner;
}
void set_owner(string owner) {
   _owner = owner;
}
protected int do_allow(string name) {
   name = lower_case(name);
   if (member_array(name, _allowed) != -1) {
      add_failed_mess("The person " + name + " is already allowed.\n");
      return 0;
   }
   _allowed += ({ name });
   write("Ok, you have allowed " + name + " to enter your room.\n");
   return 1;
}
protected int do_disallow(string name) {
   name = lower_case(name);
   if (member_array(name, _allowed) == -1) {
      add_failed_mess("The person " + name + " is not allowed to disallow.\n");
      return 0;
   }
   _allowed -= ({ name });
   write("Ok, you have disallowed " + name + " from entering your room.\n");
   return 1;
}
protected int do_throwout(object *people) {
   object per;
   object *moved;
   moved = ({ });
   foreach (per in people) {
      if ( ROOM_HANDLER->exit_move( _front_door, 0, 0, per) ) {
         moved += ({ per });
      }
   }
   if (!sizeof(moved)) {
      add_failed_mess("Unable to move $I for some reason.\n", people);
      return 0;
   }
   add_succeeded_mess("$N throw$s $I out of the room.\n", moved);
   return 1;
}
void set_front_door(string exit) {
   _front_door = exit;
}
string query_front_door() {
   return _front_door;
}
int is_allowed_in(string person) {
   person = lower_case(person);
   if (person != query_owner()) {
      if (call_door(_front_door,
                    "query_locked")) {
         if (member_array(person, _allowed) != -1) {
            return 0;
         }
      }
   }
   return 1;
}
int is_allowed(string person) {
   if (person == query_owner() ||
       member_array(person, query_allowed()) != -1) {
      return 1;
   }
   return 0;
}
void load_room() {
   if (_save_file) {
      restore_object(_save_file);
      call_door(_front_door,
                "set_locked",
                1);
   }
}
void save_room() {
   if (_save_file) {
      save_object(_save_file);
   }
}

==================================================
FILE: room/inherit/p_library.c
==================================================

#include <book_handler.h>
#include <money.h>
#include <language.h>
#include <player.h>
#include <player_handler.h>
#include <am_time.h>
#define BASE_PATHS ({ "/std/book", "/std/book_dir", "/std/leaflet", \
                      "/obj/misc/paper", "/obj/misc/nroff_paper" })
#define TITLE_PROP          "title"
#define AUTHOR_PROP         "author"
#define FROM_LIBRARY_PROP   "from library"
#define BORROWED_BY_PROP    "borrowed by"
#define DUE_BACK_PROP       "due back"
#define REFERENCE_ONLY_PROP "reference only"
#define USER_ACCESS      1
#define LIBRARIAN_ACCESS 2
inherit "/std/room/basic_room";
nosave int       _player_contributable;
nosave string    _library_name;
nosave string    _save_file;
nosave function  _borrow_func;
nosave function  _test_allowed;
int       _loan_length;
int       _fine_per_day;
int       _lost_damaged_fine;
int       _max_loans;
mapping _catalog;
mapping _accounts;
mapping _fines;
mapping _access;
nosave mapping _catalog_by_title;
nosave mapping _catalog_by_author;
class _book {
    string     path;
    string     auto_load;
    string     cap_title;
    string     cap_author;
    mapping    loaned;
    int        borrowable;
    int        copies;
    int        total_borrowed;
}
class _loan {
    int       id;
    int       due_back;
}
class _account {
    int           total_fines_paid;
    int           lost_damaged;
    class _loan   *loans;
}
int do_add( object *obs, string title, string author );
int do_remove_book( int id );
int do_borrow( mixed arg );
int do_return( object *obs );
int do_list( string arg, string to, string from, string specific );
int do_status( string player );
int do_book_status( int id );
int do_set( string player, string type );
int do_mark( int id, int flag );
int do_set_fine( int i );
int do_set_loan_length( int days );
int do_set_max_loans( int i );
int do_lost_damaged_fine( int i );
int do_report( int id, string arg, string player );
mapping query_loans( string name );
mapping query_borrowed_by( int id );
int query_fine( string name );
void clear_loan( mixed player, int id, int calc_fines );
varargs int add_book_to_library( mixed thing, int copies, string cap_title,
                                 string cap_author, int borrowable );
void set_access( string player, int access );
int query_access( mixed player );
int do_set( string player, string type );
void save_me();
protected string make_pretty_catalog( string arg, string from, string to, string specific );
protected int compare_widgets( object new_ob, int existing_id );
protected void build_catalogs(){
  int id;
  class _book book;
  foreach( id, book in _catalog ){
    if( _catalog_by_author[ lower_case(book->cap_author) ] )
      _catalog_by_author[ lower_case(book->cap_author) ] += ({ id });
    else
      _catalog_by_author[ lower_case(book->cap_author) ] = ({ id });
    if( _catalog_by_title[ lower_case(book->cap_title) ] )
      _catalog_by_title[ lower_case(book->cap_title) ] += ({ id });
    else
      _catalog_by_title[ lower_case(book->cap_title) ] = ({ id });
  }
}
void create(){
  object sign;
  ::create();
  _catalog_by_author = ([ ]);
  _catalog_by_title = ([ ]);
  _player_contributable = 1;
  _library_name = "The illustrious library of fluff";
  _save_file = base_name( this_object() ) + ".o";
  if( master()->file_exists(_save_file) ){
    unguarded( (: restore_object, _save_file :) );
  } else {
    _catalog = ([ ]);
    _accounts = ([ ]);
    _fines = ([ ]);
    _access = ([ ]);
    _loan_length = 3 * 24 * 60 * 60;
    _fine_per_day = 400;
    _lost_damaged_fine = 1050;
    _max_loans = 5;
  }
  build_catalogs();
  add_help_file("p_library_user");
  add_help_file("p_library_librarian");
  sign = add_sign(
      "The plaque is a traditional brass plate, set on top a piece "
      "of cherry oak. It looks very formal.\n",
      "For some reason, reading this sign doesn't give you as much "
      "information as looking at it would.\n",
      "brass plaque", "plaque", "common" );
  sign->add_extra_look( this_object() );
  sign->set_read_mess( 0, 0, 0 );
}
int query_library(){  return 1;  }
void init(){
  if( _player_contributable ){
    add_command( "add", "<indirect:object:me'book'> with "
        "title <string'title'> by author <word'author'>",
        (: do_add( $1, $4[1], $4[2] ) :) );
    add_command( "remove", "<number'book id'>",
        (: do_remove_book( $4[0] ) :));
  }
  add_command( "borrow", "<number'book id'>", (: do_borrow( $4[0] ) :) );
  add_command( "return", "<indirect:object:me-here>" );
  add_command( "pay", "[fine]"  );
  add_command( "view", "catalogue by {author|title}", (: do_list( $4[0], "a", "z", 0 ) :) );
  add_command( "view", "catalogue by {author|title} from "
      "<word'letter'> to <word'letter'>", (: do_list( $4[0], $4[1], $4[2], 0 ) :) );
  add_command( "view", "works by <string'author'>",
      (: do_list( "author", 0, 0, $4[0] ) :) );
  add_command( "view", "works titled <string'title'>",
      (: do_list( "title", 0, 0, $4[0] ) :) );
  add_command( "status", "", (: do_status(0) :) );
  add_command( "status", "book <number'book id'>",
               (: do_book_status( $4[0] ) :) );
  add_command( "report", "<number'book id'> as {damaged|lost}",
               (: do_report( $4[0], $4[1], 0 ) :) );
  add_command( "set", "access for <word'player'> to {allowed|disallowed}",
               (: do_set( $4[0], $4[1] ) :) );
  add_command( "set", "fine per day to <number'amount'>",
               (: do_set_fine( $4[0] ) :) );
  add_command( "set", "loan length to <number'number of days'>",
               (: do_set_loan_length( $4[0] ) :) );
  add_command( "set", "maximum number of loans to <number'number'>",
               (: do_set_max_loans( $4[0] ) :) );
  add_command( "set", "lost or damaged fine to <number'amount'>",
               (: do_lost_damaged_fine( $4[0] ) :) );
  add_command( "mark", "<number'book id'> as reference only",
    (: do_mark( $4[0], 1) :) );
  add_command( "mark", "<number'book id'> as not reference only",
    (: do_mark( $4[0], 0) :) );
  add_command( "status", "<word'player'>", (: do_status($4[0]) :) );
  add_command( "report", "<number'book id'> as {damaged|lost} for <word'player'>",
               (: do_report( $4[0], $4[1], $4[2] ) :) );
}
protected string id_to_name( int id ){
  if( !_catalog[id] )
    return 0;
  return "'" +_catalog[id]->cap_title+ "' by " + _catalog[id]->cap_author;
}
protected int valid_media( object ob ){
  if( ob->query_book() || ob->query_paper() || ob->query_leaflet() )
    return 1;
}
int do_add( object *obs, string title, string author ){
  object t_p, t_o;
  int num, id, *ids;
  t_p = this_player();
  t_o = this_object();
  debug_printf( "Obs: %O\n", obs );
  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("Only librians can do this.\n");
    return 0;
  }
  if( strlen(author) > 14 ){
    add_failed_mess("The author's name is too long. It has to be less than 13 characters.\n");
    return 0;
  }
  if( strlen(title) > 26 ){
    add_failed_mess("The title is too long. It can only use less than 27 characters.\n");
    return 0;
  }
  if( sizeof(obs) > 1 ){
    add_failed_mess("You can only add one item at a time.\n");
    return 0;
  }
  if( !t_o->valid_media(obs[0]) ){
    add_failed_mess( "The library does not lend items like $I.\n", obs);
    return 0;
  }
  if( obs[0]->query_magic_scroll() || obs[0]->query_spell_book() ){
    add_failed_mess( "This library does not deal in magical works.\n" );
    return 0;
  }
  if( obs[0]->query_property(FROM_LIBRARY_PROP) ){
    add_failed_mess( "This item belongs to a library and cannot be added.\n" );
    return 0;
  }
  if( (num = obs[0]->query_book_num()) ){
    if( lower_case(author) != BOOK_HANDLER->query_book_owner(num) ){
      add_failed_mess( "The book has been authored by " +
        capitalize(BOOK_HANDLER->query_book_owner(num)) + " and not " +
        author + ".\n");
      return 0;
    }
  }
  if( (ids = _catalog_by_title[ lower_case(title) ]) ){
    foreach( id in ids ){
      if( lower_case(_catalog[id]->cap_author) == lower_case(author) ){
        if( compare_widgets( obs[0], id ) ){
          add_book_to_library( id, 1 );
          add_succeeded_mess( "$N add$s another copy of "
              +id_to_name(id)+ " to the library.\n" );
          obs[0]->move( "/room/rubbish" );
          return 1;
        } else {
          add_failed_mess("$I doesn't seem to be the same as the copy held "
            "in the library. Catalogue it under a different title or author.\n", obs );
          return 0;
        }
      }
    }
  }
  if( member_array(base_name(obs[0]), BASE_PATHS) == -1 )
    add_book_to_library( base_name(obs[0]), 1, title, author, 1 );
  else
    add_book_to_library( obs[0], 1, title, author, 1 );
  add_succeeded_mess( "$N $V an item to the library.\n" );
  obs[0]->move( "/room/rubbish" );
  return 1;
}
void remove_book( int id ){
  object ob;
  class _book book;
  int i;
  if( !_catalog[id] )
    return;
  book = _catalog[id];
  for( i = 0; i < (book->copies - sizeof(book->loaned)); i++ ){
    if( book->path )
      ob = clone_object( book->path );
    if( book->auto_load )
      ob = PLAYER_OB->load_auto_load_to_array( book->auto_load, this_player() )[0];
    ob->move( this_object() );
  }
  _catalog_by_title[lower_case(book->cap_title)] -= ({ id });
  _catalog_by_author[lower_case(book->cap_author)] -= ({ id });
  if( !sizeof( _catalog_by_title[lower_case(book->cap_title)] ) )
    map_delete( _catalog_by_title, lower_case(book->cap_title) );
  if( !sizeof( _catalog_by_author[lower_case(book->cap_author)] ) )
    map_delete( _catalog_by_author, lower_case(book->cap_author) );
  map_delete( _catalog, id );
  save_me();
}
int do_remove_book( int id ){
  int out;
  string player, bit;
  class _account account;
  class _loan loan;
  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("Only librians can do this.\n");
    return 0;
  }
  id = to_int(id);
  if( !_catalog[id] ){
    add_failed_mess("There is no item with that id.\n");
    return 0;
  }
  foreach( player, account in _accounts ){
    foreach( loan in account->loans ){
      if( loan->id == id )
        out++;
    }
  }
  if( out ){
    if( out > 1 )
      bit = "are " +query_num(out)+ " ";
    else
      bit = "is one"+" ";
    add_failed_mess( "There " +bit+ id_to_name(id) +
        ", out on loan already. You can only remove a book if all "
        "copies are in the library.\n" );
    return 0;
  } else {
    add_succeeded_mess("$N $V " +id_to_name(id) + " from the library.\n" );
    remove_book(id);
    tell_object( this_player(), "Any remaining copies will be placed on the floor.\n");
    return 1;
  }
}
int do_borrow( mixed arg ){
  int id, ret, t;
  object ob;
  class _book book;
  class _loan loan;
  string name;
  name = this_player()->query_name();
  id = to_int(arg);
  if( query_access(this_player()) < USER_ACCESS ){
    add_failed_mess("You do not have access to this library.\n");
    return 0;
  }
  if( _borrow_func ){
    ret = evaluate( _borrow_func, this_player(), id );
    if( ret != 1 )
      return ret;
  }
  if( _fines[name] ){
    add_failed_mess("You can't borrow a book whilst having outstanding fines.\n" );
    return 0;
  }
  if( !_catalog[id] ){
    add_failed_mess("There is no book with an id of " +id+ ".\n" );
    return 0;
  } else {
    book = _catalog[id];
  }
  if( _accounts[name] && sizeof(_accounts[name]->loans) >= _max_loans ){
    add_failed_mess("You have already borrowed the maximum number of books.\n");
    return 0;
  }
  if( (book->copies - sizeof(book->loaned)) < 1 ){
    add_failed_mess("Unfortunately, all copies of " +
        id_to_name(id) + " are out on loan.\n");
    return 0;
  }
  if( _accounts[name] && sizeof( _accounts[name]->loans ) ){
    foreach( loan in _accounts[name]->loans ){
      if( loan->id == id ){
        add_failed_mess("You have already borrowed a copy of " +
            id_to_name(id) + ".\n");
        return 0;
      }
    }
  }
  if( book->path )
    ob = clone_object( book->path );
  if( book->auto_load )
    ob = PLAYER_OB->load_auto_load_to_array( book->auto_load, this_player() )[0];
  if( !ob ){
    add_failed_mess("Uh oh, something buggered with book id: " + id +
      ". Please tell a creator.\n" );
    return 0;
  }
  t = time() + _loan_length;
  ob->add_property( TITLE_PROP, book->cap_title );
  ob->add_property( AUTHOR_PROP, book->cap_author );
  ob->add_property( FROM_LIBRARY_PROP, _library_name );
  ob->add_property( BORROWED_BY_PROP, name );
  ob->add_property( DUE_BACK_PROP, t );
  book->loaned[name] = t;
  book->total_borrowed++;
  _catalog[id] = book;
  loan = new( class _loan, id : id, due_back : t );
  if( _accounts[name] )
    _accounts[name]->loans += ({ loan });
  else {
    _accounts[name] = new( class _account, total_fines_paid : 0,
                           lost_damaged : 0,
                           loans : ({ loan }) );
  }
  if( !book->borrowable ){
    tell_object( this_player(), id_to_name(id)+ " is a reference only book. "
      "It will be placed on "
      "a lecturn for you to read and cannot be removed from the library. Please return it "
      "in the normal way after use.\n");
    ob->move( this_object() );
    ob->reset_get();
    ob->add_property( "there", "sitting on a lecturn" );
    ob->add_property( REFERENCE_ONLY_PROP, 1 );
  } else {
    tell_object( this_player(), "You have until "+ am_time(t) +
        " to return it.\n");
    ob->move( this_player() );
  }
  save_me();
  add_succeeded_mess( "$N $V " +id_to_name(id)+ ".\n");
  return 1;
}
int do_return( object *obs ){
  string name, bit;
  int id, *owed, i, *ours, due;
  class _loan loan;
  class _book book;
  object ob, *not_ours, *wrong_player, *returned;
  name = this_player()->query_name();
  owed = ({ });
  ours = not_ours = wrong_player = returned = ({ });
  if( !sizeof(_accounts[name]->loans) ){
    add_failed_mess( "You don't have any books out on loan.\n" );
    return 0;
  }
  foreach( loan in _accounts[name]->loans ){
    owed += ({ loan->id });
  }
  foreach( ob in obs ){
    if( ob->query_property( FROM_LIBRARY_PROP ) == _library_name ){
      if( ob->query_property( BORROWED_BY_PROP ) == name ){
        foreach( id in owed ){
          if( (book = _catalog[id]) ){
            if( ob->query_property( TITLE_PROP ) == book->cap_title &&
                ob->query_property( AUTHOR_PROP ) == book->cap_author ){
              map_delete( _catalog[id]->loaned, name );
              ob->move("/room/rubbish");
              returned += ({ ob });
              ours += ({ id });
            }
          } else {
            ob->move("/room/rubbish");
            returned += ({ ob });
          }
        }
      } else {
        wrong_player += ({ ob });
      }
    } else {
      not_ours += ({ ob });
    }
  }
  if( sizeof(returned) ){
    foreach( i in ours )
      clear_loan( this_player(), i, 1 );
    if( _fines[name] )
      tell_object(this_player(), "Note: You have fines that are due.\n");
    add_succeeded_mess( "$N $V $I.\n", returned );
    return 1;
  }
  if( (i=sizeof(not_ours)) ){
    if( i > 1 ) bit = "do not"; else bit = "does not";
    add_failed_mess( "$I " +bit+ " belong to this library.\n", not_ours );
    return 0;
  }
  if( (i=sizeof(wrong_player)) ){
    if( i > 1 ) bit = "were not"; else bit = "was not";
    add_failed_mess( "$I " +bit+ " were not loaned to you. Only the borrower may "
        "return items.\n", wrong_player );
    return 0;
  }
}
int do_list( string arg, string from, string to, string specific ){
  if( (to && !stringp(to)) || (from && !stringp(from)) ){
    add_failed_mess( "The ranges must be letters.\n");
    return 0;
  }
  if( specific ){
    tell_object( this_player(), make_pretty_catalog( arg, 0, 0, lower_case(specific) ) );
    return 1;
  } else {
    tell_object( this_player(), make_pretty_catalog( arg, from, to, 0 ) );
    return 1;
  }
}
int do_pay(){
  int cash, fine;
  string place, str;
  place = query_property( "place" );
  if ( !place || ( place == "" ) )
    place = "default";
  cash = this_player()->query_value_in( place );
  if ( place != "default" )
    cash += this_player()->query_value_in( "default" );
  if( !cash ){
    add_failed_mess("You have money!.\n");
    return 0;
  }
  fine = _fines[this_player()->query_name()];
  if( fine <= 0 ){
    add_failed_mess("You have no outstanding fines to pay.\n");
    return 0;
  }
  if( cash >= fine )
    cash = fine;
  this_player()->pay_money( MONEY_HAND->create_money_array(cash, place), place );
  _fines[this_player()->query_name()] -= cash;
  _accounts[this_player()->query_name()]->total_fines_paid += cash;
  if( _fines[this_player()->query_name()] <= 0 ){
    str = MONEY_HAND->money_value_string( cash, place );
    add_succeeded_mess("$N pay$s all $p fines ("+str+").\n");
    map_delete( _fines, this_player()->query_name() );
    save_me();
    return 1;
  } else {
    str = MONEY_HAND->money_value_string( fine - cash, place );
    add_succeeded_mess("$N pay$s some of $p fine, but sill owe$s ("+str+").\n");
    save_me();
    return 1;
  }
}
int do_status( string player ){
  int fine;
  string place, str, bit;
  class _loan loan;
  if( !player )
    player = this_player()->query_name();
  player = lower_case(player);
  if( player != this_player()->query_name() &&
      query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You do not have access to see other accounts.\n");
    return 0;
  }
  str = "Account status for " + PLAYER_HANDLER->query_cap_name(player) +".\n";
  if( _accounts[player] && sizeof(_accounts[player]->loans)  ){
    str += "Loaned items:\n";
    str += sprintf( "%|4s%|=30s%|=20s%|9s\n", "Id", "Item", "Due back", "Overdue" );
    foreach( loan in _accounts[player]->loans ){
      if( loan->due_back - time() > 0 )
        bit = "";
      else
        bit = "*Yes*";
      str += sprintf( "%|4d%|=30s%|=20s%|9s\n", loan->id,
          id_to_name(loan->id), am_time( loan->due_back ), bit );
    }
  } else {
    str += "No items currently on loan.\n";
  }
  place = query_property( "place" );
  if ( !place || ( place == "" ) )
    place = "default";
  fine = _fines[player];
  if( fine >= 0 ){
    str += sprintf( "%-15s%-6s\n", "Fines Due:",
           MONEY_HAND->money_value_string( fine, place ) );
  } else {
    str += "No fines due.\n";
  }
  if( _accounts[player] ){
    str += "Total previously paid fines: " +
      MONEY_HAND->money_value_string( _accounts[player]->total_fines_paid, place );
    str += ".\nBooks lost or damaged: " + _accounts[player]->lost_damaged + ".\n";
  }
  tell_object( this_player(), str );
  add_succeeded_mess("");
  return 1;
}
int do_book_status( int id ){
  string str, name, date;
  class _book book;
  id = to_int(id);
  if( !_catalog[id] ){
    add_failed_mess("The id " +id+ ", does not point to an item.\n");
    return 0;
  }
  book = _catalog[id];
  str = "Status for id: " +id+ " - " + id_to_name(id) + ".\n";
  if( sizeof(book->loaned) ){
    str += sprintf( "%|=14s%|=30s\n", "On loan to", "Date Due Back " );
    foreach( name, date in book->loaned ){
      str += sprintf( "%|=12s%|=30s\n",
             PLAYER_HANDLER->query_cap_name(name), am_time(date) );
    }
  } else {
    str += "Currently, no copies of the item are on loan.";
  }
  str += "The library holds " + (string)book->copies;
  if( book->copies == 1 ) str += " copy "; else str += " copies ";
  str += "in total, " + (string)( book->copies - sizeof(book->loaned) ) +
         " of which are available.\n";
  str += "It has been borrowed a total of " + book->total_borrowed;
  if( book->total_borrowed == 1 ) str += " time.\n"; else str += " times.\n";
  if( !book->borrowable )
    str += "It is a reference only item.\n";
  tell_object( this_player(), str);
  add_succeeded_mess("$N look$s at the status of a library item.\n");
  return 1;
}
int do_set( string player, string type ){
  player = lower_case(player);
  if( query_access(this_object()) <= query_access(player) ){
    add_failed_mess( "You do not have permission to do this.\n");
    return -1;
  }
  if( type == "allowed" ){
    if( query_access(player) < USER_ACCESS ){
      set_access( player, USER_ACCESS );
      add_succeeded_mess("$N allow$s " + PLAYER_HANDLER->query_cap_name(player) +
        " to use the library.\n");
      save_me();
      return 1;
    }
  }
  if( type == "disallowed" ){
    if( query_access(player) == USER_ACCESS ){
      set_access( player, 0 );
      add_succeeded_mess("$N disallow$s " + PLAYER_HANDLER->query_cap_name(player) +
        " from using the library.\n");
      save_me();
      return 1;
    }
  }
}
int do_mark( int id, int flag ){
  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You do not have permission to do this.\n");
    return 0;
  }
  if( !_catalog[id] ){
    add_failed_mess("There is no item with that id.\n");
    return 0;
  }
  if( flag ){
    add_succeeded_mess("$N $V " + id_to_name(id) + " to reference only.\n");
    _catalog[id]->borrowable = 0;
    return 1;
  } else {
    add_succeeded_mess("$N $V " + id_to_name(id) + " to not reference only.\n");
    _catalog[id]->borrowable = 1;
    return 1;
  }
  save_me();
}
int do_set_fine( int i ){
  string place;
  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You do not have permission to do this.\n");
    return 0;
  }
  place = query_property( "place" );
  if( !place || ( place == "" ) )
    place = "default";
  i = to_int(i);
  if( i < 0 ){
    add_failed_mess("Don't be silly, thats a negative value!\n");
    return 0;
  }
  if( i > 4000 ){
    add_failed_mess("The maximum fine you can set per day is 4000 units (" +
        MONEY_HAND->money_value_string( 4000, place ) + ").\n" );
    return 0;
  }
  add_succeeded_mess("$N set$s the fine per day to " + i +
    " ("+ MONEY_HAND->money_value_string( i, place ) + ").\n" );
  _fine_per_day = i;
  save_me();
  return 1;
}
int do_set_loan_length( int days ){
  string str;
  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You do not have permission to do this.\n");
    return 0;
  }
  days = to_int(days);
  if( days > 10 ){
    add_failed_mess("The maximum loan length is 10 days.\n");
    return 0;
  }
  if( days < 1 ){
    add_failed_mess("The minimum loan length is 1 day.\n");
    return 0;
  }
  if( days == 1 )  str = " day"; else str = " days";
  add_succeeded_mess("$N set$s the loan length to "
     + query_num(days) + str + ".\n" );
  _loan_length = days * AM_SECONDS_PER_DAY;
  save_me();
  return 1;
}
int do_set_max_loans( int i ){
  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You do not have permission to do this.\n");
    return 0;
  }
  i = to_int(i);
  if( i < 1 ){
    add_failed_mess("The minimum amount of loans is one.\n");
    return 0;
  }
  if( i > 10 ){
    add_failed_mess("The maximum amount of loans a player can have is ten.\n");
    return 0;
  }
  add_succeeded_mess("$N set$s the maximum number of loans to "
     + query_num(i) + " items.\n" );
  _max_loans = i;
  save_me();
  return 1;
}
int do_lost_damaged_fine( int i ){
  string place;
  if( query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You do not have permission to do this.\n");
    return 0;
  }
  i = to_int(i);
  place = query_property( "place" );
  if( !place || ( place == "" ) )
    place = "default";
  if( i < 0 ){
    add_failed_mess("Don't be silly, thats a negative value!\n");
    return 0;
  }
  if( i > 20000 ){
    add_failed_mess("The maximum fine you can set per day is 20000 units (" +
        MONEY_HAND->money_value_string( 20000, place ) + ").\n" );
    return 0;
  }
  add_succeeded_mess("$N set$s the lost or damaged fine to " + i +
    " ("+ MONEY_HAND->money_value_string( i, place ) + ").\n" );
  _lost_damaged_fine = i;
  save_me();
  return 1;
}
int do_report( int id, string arg, string player ){
  string str;
  class _loan loan, match;
  if( player && query_access(this_player()) < LIBRARIAN_ACCESS ){
    add_failed_mess("You can only report your damaged or lost books.\n");
    return 0;
  }
  if( player ){
    str = PLAYER_HANDLER->query_cap_name(player)+ " does";
    player = lower_case(player);
  } else {
    str = "You do";
    player = this_player()->query_name();
  }
  if( !_accounts[player] ){
    add_failed_mess(str + " not have any items on loan.\n");
    return 0;
  }
  if( !_catalog[id] ){
    add_failed_mess("The id " + id + " does not exist.\n");
    return 0;
  }
  foreach( loan in _accounts[player]->loans ){
    if( loan->id == id ){
      match = loan;
    }
  }
  if( !match ){
    add_failed_mess(str + " not have " + id_to_name(id) + " out on loan.\n");
    return 0;
  }
  _accounts[player]->loans -= ({ match });
  map_delete( _catalog[id]->loaned, player );
  _catalog[id]->copies--;
  if( player == this_player()->query_name() )
    str = "";
  else
    str = " for " + PLAYER_HANDLER->query_cap_name(player);
  if( _fines[player] )
    _fines[player] += _lost_damaged_fine;
  else
    _fines[player] = _lost_damaged_fine;
  if( arg == "lost" ){
    add_succeeded_mess("You report the loss of " + id_to_name(id) + str + ".\n");
    _accounts[player]->lost_damaged++;
    save_me();
    return 1;
  }
  if( arg == "damaged" ){
    add_succeeded_mess("You report the damaging of " +id_to_name(id) + str + ".\n");
    _accounts[player]->lost_damaged++;
    save_me();
    return 1;
  }
}
protected string make_pretty_catalog( string arg, string from, string to, string specific ){
  string widget, c_widget, str, *list;
  int id, *ids;
  if( !from )
    from = "a";
  else
    from = lower_case(from);
  if( !to )
    to = "z";
  else
    to = lower_case(to);
  if( from > to ){
    widget = to;
    to = from;
    from = widget;
  }
  if( specific ){
    if( _catalog_by_title[specific] || _catalog_by_author[specific] )
      list = ({ specific });
    else
      list = ({ });
  }
  if( arg == "title" ){
    str = sprintf( "%|=4s%|=26s%|=12s%|=9s%|=8s\n",
            "Id", "Title", "Author", "Copies", "On Loan" );
    if( !list )
      list = sort_array( keys(_catalog_by_title), 0 );
    foreach( widget in list ){
      ids = _catalog_by_title[ widget ];
      if( widget && sizeof(ids) && (widget[0..0] >= from) && (widget[0..0] <= to) ){
        foreach( id in ids ){
          c_widget = _catalog[ id ]->cap_title;
          str += sprintf( "%|=4d%|=26s%|=12s%|=9d%|=8d\n",
                   id, c_widget, _catalog[id]->cap_author,
                   _catalog[id]->copies, sizeof(_catalog[id]->loaned) );
        }
      }
    }
    return str;
  }
  if( arg == "author" ){
    str = sprintf( "%|=4s%|=12s%|=26s%|=9s%|=8s\n",
            "Id", "Author", "Title", "Copies", "On Loan" );
    if( !list )
      list = sort_array( keys(_catalog_by_author), 0 );
    foreach( widget in list ){
      ids = _catalog_by_author[ widget ];
      if( widget && sizeof(ids) && (widget[0..0] >= from) && (widget[0..0] <= to) ){
        foreach( id in ids ){
          c_widget = _catalog[ id ]->cap_title;
          str += sprintf( "%|=4d%|=12s%|=26s%|=9d%|=8d\n",
                   id, _catalog[id]->cap_author, c_widget,
                   _catalog[id]->copies, sizeof(_catalog[id]->loaned) );
        }
      }
    }
    return str;
  }
}
void clear_loan( mixed player, int id, int calc_fines ){
  int fine;
  class _loan loan;
  if( objectp(player) && userp(player) )
    player = player->query_name();
  if( !stringp(player) )  return;
  if( !_accounts[player] || !sizeof(_accounts[player]->loans) )  return;
  foreach( loan in _accounts[player]->loans ){
    if( loan->id == id ){
      if( calc_fines && (loan->due_back - time() < 0) ){
        fine = (((time() - loan->due_back) / AM_SECONDS_PER_DAY) + 1) * _fine_per_day;
        if( _fines[player] )
          _fines[player] += fine;
        else
          _fines[player] = fine;
      }
      _accounts[player]->loans -= ({ loan });
    }
  }
  save_me();
}
protected int find_blank_id(){
  int *ids;
  int unused_id, i;
  ids = sort_array( keys(_catalog), -1 );
  if( !sizeof(ids) ){
    unused_id = 1;
  } else {
    if( ids[0] > sizeof(ids) ){
      for( i = 0; i < sizeof(ids); i++ ){
        if( undefinedp(_catalog[i]) ){
          unused_id = i;
          break;
        }
      }
    } else {
      unused_id = sizeof(ids) + 1;
    }
  }
  if( unused_id == 0 )
    unused_id = 1;
  return unused_id;
}
protected void add_book_to_catalogs( class _book new_book, int id ){
  _catalog[id] = new_book;
  save_me();
  if( _catalog_by_author[lower_case(new_book->cap_author)] )
    _catalog_by_author[lower_case(new_book->cap_author)] += ({ id });
  else
    _catalog_by_author[lower_case(new_book->cap_author)] = ({ id });
  if( _catalog_by_title[lower_case(new_book->cap_title)] )
    _catalog_by_title[lower_case(new_book->cap_title)] += ({ id });
  else
    _catalog_by_title[lower_case(new_book->cap_title)] = ({ id });
}
varargs int add_book_to_library( mixed thing, int copies, string cap_title,
                                 string cap_author, int borrowable ){
  class _book book;
  int id, *ids;
  if( intp(thing) ){
    if( _catalog[thing] ){
      _catalog[thing]->copies += copies;
      return 1;
    } else {
      return 0;
    }
  }
  if( !cap_title || !cap_author || cap_title == "" || cap_author == "" )
    return 0;
  if( (ids = _catalog_by_title[ lower_case(cap_title) ]) ){
    foreach( id in ids ){
      if( lower_case(_catalog[id]->cap_author) == lower_case(cap_author) )
          return add_book_to_library( id, 1 );
    }
  }
  if( stringp(thing) ){
    book = new( class _book );
    book->path = thing;
    book->cap_author = cap_author;
    book->cap_title = cap_title;
    book->borrowable = 1;
    book->copies = copies;
    book->loaned = ([ ]);
    book->total_borrowed = 0;
    id = find_blank_id();
    add_book_to_catalogs( book, id );
    return 1;
  }
  if( objectp(thing) ){
    book = new( class _book );
    book->auto_load = AUTO_LOAD_OB->create_auto_load( ({ thing }) );
    book->cap_author = cap_author;
    book->cap_title = cap_title;
    book->borrowable = 1;
    book->copies = copies;
    book->loaned = ([ ]);
    book->total_borrowed = 0;
    id = find_blank_id();
    add_book_to_catalogs( book, id );
    return 1;
  }
}
protected int compare_widgets( object new_ob, int existing_id ){
  class _book book;
  object ob;
  mixed info;
  int perc;
  book = _catalog[existing_id];
  if( !book )  return 0;
  if( book->path )
    ob = clone_object( book->path );
  if( book->auto_load )
    ob = PLAYER_OB->load_auto_load_to_array( book->auto_load, this_player() )[0];
  if( !ob ){
    return 0;
  }
  if( base_name(ob) != base_name(new_ob) )
    return 0;
  if( inherits("/std/book.c", new_ob) ){
    perc = BOOK_HANDLER->compare_pages(
             BOOK_HANDLER->query_pages( new_ob ),
             BOOK_HANDLER->query_pages( ob )
           );
  }
  if( inherits("/std/leaflet.c", new_ob) ){
    perc = BOOK_HANDLER->compare_pages(
             map( new_ob->query_pages(), (: $1[0][0] :) ),
             map( ob->query_pages(), (: $1[0][0] :) )
           );
  }
  if( inherits("/obj/misc/paper", new_ob) ||
      inherits("/obj/misc/nroff_paper", new_ob) ){
    perc = BOOK_HANDLER->compare_pages(
      map( new_ob->query_read_mess(), (: $1[0] :) ),
      map( ob->query_read_mess(), (: $1[0] :) )
    );
  }
  ob->move( "/room/rubbish" );
  if( perc > 97 )
    return 1;
  else
    return 0;
}
string extra_look( object ob ){
  string *libs, str, place;
  str = "Welcome to " + _library_name + ".\n";
  libs = filter( keys(_access), (: _access[$1] == LIBRARIAN_ACCESS :) );
  if( !sizeof(libs) )
    str += "Currently there are no caretakers of the books.\n";
  if( sizeof(libs) == 1 )
    str += PLAYER_HANDLER->query_cap_name(libs[0]) + " is the sole caretaker "
          " of the books.\n";
  if( sizeof(libs) > 1 ){
    libs = map( libs, (: PLAYER_HANDLER->query_cap_name($1) :) );
    str += query_multiple_short(libs) + " are caretakers of the books.\n";
  }
  place = query_property("place");
  if( !place || place == "" )
    place = "default";
  str += "Books may be borrowed for a maximum of " +
         (_loan_length / AM_SECONDS_PER_DAY) +
         " Disc days, before fines are levied.\n";
  str += "Fines currently stand at " +
         MONEY_HAND->money_value_string( _fine_per_day, place ) +
         " per day the book is overdue.\n";
  str += "A charge of " + MONEY_HAND->money_value_string( _lost_damaged_fine, place ) +
         " will be incurred if you lose or damage a book.\n";
  str += "The maximum number of items you can borrow at one time currently stands at "+
         query_num(_max_loans) + ".\n";
  return str;
}
protected void save_it(){
  unguarded( (: save_object, _save_file :) );
}
void save_me(){
  if( find_call_out("save_it") == -1 )
    call_out( "save_it", 2 );
}
mapping query_loans( string name ){
  class _loan loan;
  mapping m = ([ ]);
  if( !_accounts[name] )
    return ([ ]);
  foreach( loan in _accounts[name]->loans ){
    m[ loan->id ] = loan->due_back;
  }
  return m;
}
mapping query_borrowed_by( int id ){
  if( _catalog[id] )
    return _catalog[id]->loaned;
  else
    return ([ ]);
}
int query_fine( string name ){  return _fines[name];  }
mapping query_catalog(){
  return _catalog;
}
mapping query_catalog_by_title(){
  return _catalog_by_title;
}
mapping query_catalog_by_author(){
  return _catalog_by_author;
}
mapping query_all_accounts(){
  return _accounts;
}
void set_library_name( string str ){  _library_name = str;  }
string query_library_name(){  return _library_name;  }
void set_player_contributable( int i ){  _player_contributable = i;  }
int query_player_contributable(){  return _player_contributable;  }
void set_max_loans( int i ){  _max_loans = i;  }
int query_max_loans(){  return _max_loans;  }
void set_loan_length( int i ){  _loan_length = i;  }
int query_loan_length(){  return _loan_length;  }
void set_fine_per_day( int i ){  _fine_per_day = i;  }
int query_fine_per_day(){  return _fine_per_day;  }
void set_lost_damaged_fine( int i ){ _lost_damaged_fine = i;  }
int query_lost_damaged_fine(){ return _lost_damaged_fine;  }
void set_save_file( string s ){  _save_file = s;  }
string query_save_file(){  return _save_file;  }
void set_borrow_func( function f ){  _borrow_func = f;  }
function query_borrow_func(){  return _borrow_func;  }
void set_access( string player, int access ){
  if( !access ){
    map_delete( _access, player );
  } else {
    _access[player] = access;
  }
  save_me();
}
int query_access( mixed player ){
  return LIBRARIAN_ACCESS;
}

==================================================
FILE: room/inherit/placement.c
==================================================

#include <obj_parser.h>
#include <dirs.h>
#include <room/placement.h>
#define PLAYTESTING
#define MAX_PLACED 10
#define PLACEMENT_CURRENT_ROOM_HIDDEN "current room hidden"
#define OPPOSITE 0
#define ABOVE    1
#define BELOW    2
#define RIGHT    3
#define LEFT     4
#define OPPOSITE_DESCS ({ \
  "opposite which", \
  "facing which", \
})
#define ABOVE_DESCS ({ \
  "above which", \
  "over which", \
})
#define BELOW_DESCS ({ \
  "under which", \
  "below which", \
})
#define RIGHT_DESCS ({ \
  "to the right of which", \
})
#define LEFT_DESCS ({ \
  "to the left of which", \
})
#define HANGING_VERBS ({ \
  "hanging", \
  "suspended", \
  "dangling", \
})
#define HANGING_PREPOSITIONS ({ \
  "from", \
  "on", \
})
#define WALL_PREPOSITIONS ({ \
  "beside", \
  "against", \
})
#define CORNER_PREPOSITIONS ({ \
  "in", \
})
#define ABOUT_PREPOSITIONS ({ \
  "near", \
  "at", \
})
string get_pos_desc(int pos_int);
int do_place(object *obs, string, string, mixed *args, string);
int do_help(object *);
int get_pos_int(string str);
string extra_look(object);
string object_position_desc(object thing);
string object_desc(object thing);
string object_desc2(object thing);
object *build_structure();
int find_opposite(int pos, object *structure);
int find_above(int pos, object *structure);
int find_below(int pos, object *structure);
int find_left(int pos, object *structure);
int find_right(int pos, object *structure);
int get_structure_index(object ob);
varargs int is_beside_wall(int pos, int flag);
varargs int is_in_corner(int pos, int flag);
nosave object *needs_described;
nosave object *have_described;
nosave int orientation;
nosave mapping _wall_names;
nosave string furniture_long = "";
void init() {
 if(!this_player() || !interactive(this_player()))
     return;
  this_player()->add_command("place", this_object(),
    "<indirect:object'furniture'> so it is <word'verb'> "
    "{"+implode(ABOUT_PREPOSITIONS+HANGING_PREPOSITIONS+WALL_PREPOSITIONS+CORNER_PREPOSITIONS, "|")+"} "
    "the <string:'location'> [wall|corner]");
  this_player()->add_command("place", this_object(),
    "<indirect:object'furniture'> "
    "{"+implode(ABOUT_PREPOSITIONS+HANGING_PREPOSITIONS+WALL_PREPOSITIONS+CORNER_PREPOSITIONS, "|")+"} the <string'location'> [wall|corner]");
  this_player()->add_command("displace", this_object(),
    "<indirect:object'furniture'>");
  this_player()->add_command("place", this_object(),
                             "help", (: do_help(0) :));
  this_player()->add_command("place", this_object(),
                             "help <indirect:object'furniture'>",
                             (: do_help($1[0]) :));
}
void set_wall_name(string direction, string name) {
   int pos;
   if (!_wall_names) {
      _wall_names = ([ ]);
   }
   pos = get_pos_int(direction);
   _wall_names[pos] = name;
}
string query_wall_name_pos(int pos) {
   if (!_wall_names) {
      _wall_names = ([ ]);
   }
   if (_wall_names[pos]) {
      return _wall_names[pos];
   }
   if(!orientation)
   {
      if(pos % 2)
      {
         return "corner";
      }
      return "wall";
   }
   if(pos % 2)
   {
      return "wall";
   }
   return "corner";
}
string query_wall_name(string direction) {
   int pos;
   pos = get_pos_int(direction);
   return query_wall_name_pos(pos);
}
string query_another(object ob)
{
  object *obs;
  string another;
  obs = filter(have_described,
    (: $1->query_plural() == $(ob->query_plural()) :));
  switch(sizeof(obs))
  {
    case 0 :
      another = " a";
      break;
    case 1 :
      another = " another";
      break;
    default :
      another = " yet another";
      break;
  }
  return another;
}
string query_more(object ob)
{
  object *obs;
  string more;
  obs = filter(have_described,
    (: $1->query_plural() == $(ob->query_plural()) :));
  switch(sizeof(obs))
  {
    case 0 :
      more = "";
      break;
    default :
      more = " more";
      break;
  }
  return more;
}
string clutter_string(object ob) {
  mixed *things;
  string cluttered = "";
  if(ob->query_has_surface()) {
    things = ob->find_inv_match("all", ob);
    things = unique_array(things, (: $1->query_plural() :));
    switch(sizeof(things)) {
      case 1 :
        if(sizeof(things[0]) == 1)
          cluttered = " is";
        else
          cluttered = " are";
        cluttered += " " + query_multiple_short(things[0]);
        break;
      default :
        break;
    }
  }
  return cluttered;
}
string query_multiple_furniture_short(object *obs) {
  object *group;
  mixed *things;
  string str;
  string *strs;
  strs = ({ });
  things = unique_array(obs, (: $1->query_plural() :));
  foreach(group in things)
  {
    switch(sizeof(group))
    {
      case 0 :
        break;
      case 1 :
        str = query_another(group[0])[1..];
        str += " " + group[0]->query_short();
        break;
      default :
        str = query_num(sizeof(group));
        str += query_more(group[0]);
        str += " " + group[0]->query_plural();
        break;
    }
    strs += ({ str });
  }
  return query_multiple_short(strs);
}
varargs int is_in_corner(int pos, int flag)
{
  if(orientation && !flag)
    return is_beside_wall(pos, 1);
  if(member_array(pos, ({ 3, 5, 7, 9 })) != -1)
    return 1;
  return 0;
}
varargs int is_beside_wall(int pos, int flag)
{
  if(orientation && !flag)
  {
    return is_in_corner(pos, 1);
  }
  if(member_array(pos, ({ 2, 4, 6, 8 })) != -1)
  {
    return 1;
  }
  return 0;
}
int is_wall_hanging(int pos)
{
  if(orientation)
  {
    if(member_array(pos, ({ 13, 15, 17, 19 })) != -1)
    {
      return 1;
    }
    return 0;
  }
  if(member_array(pos, ({ 12, 14, 16, 18 })) != -1)
  {
    return 1;
  }
  return 0;
}
int is_in_centre(int pos)
{
  if(pos == 1)
  {
    return 1;
  }
  return 0;
}
int query_max_space_around(int pos)
{
  if(is_in_corner(pos))
  {
    return 2;
  }
  if(is_beside_wall(pos))
  {
    return 3;
  }
  if(is_in_centre(pos))
  {
    return 4;
  }
  return 0;
}
int do_help(object ob) {
  string str;
  string *bits;
  if(ob && !ob->query_furniture())
    return this_player()->add_failed_mess(this_object(),
                                          "$I is not a piece of furniture.\n",
                                          ({ ob }));
  str = "The place command requires a furniture object, an optional verb, "
    "a preposition and a location.  ";
  if(!ob) {
    str += "Which verbs are available depends on the furniture.  Hanging "
      "furniture can use " + query_multiple_short(HANGING_VERBS) + ".  ";
  } else {
    if(ob->query_allowed_room_verbs())
      bits = filter(keys(ob->query_allowed_room_verbs()), (: $1 != "" :));
    switch(sizeof(bits)) {
    case 0:
      str += "The " + ob->the_short() + " has no verbs.\n";
      break;
    case 1:
      str += "The verb for " + ob->the_short() + " is " +
        query_multiple_short(bits) + ".\n";
      break;
    default:
      str += "The verbs available for " + ob->the_short() + " are " +
        query_multiple_short(bits) + ".\n";
    }
  }
  str += "The prepositions for hanging things are " +
    query_multiple_short(HANGING_PREPOSITIONS) + ", while items may be "
    "placed " + query_multiple_short(WALL_PREPOSITIONS) + " walls, " +
    query_multiple_short(CORNER_PREPOSITIONS) + " corners, or " +
    query_multiple_short(ABOUT_PREPOSITIONS) + " other objects.  "
    "The " + query_multiple_short(({"ceiling", "floor", "centre", "north",
                                      "south", "east", "west", "northeast",
                                      "southeast", "northwest", "southwest"}))+
    " may be used as locations.\n";
  write(str);
  return 1;
}
int do_place(object *obs, string, string, mixed *args, string)
{
  int pos, allowed;
  string k, v;
  mapping allowed_verbs;
  object *things;
  object *placed;
  object* already_around;
  class obj_match result;
#ifdef DEBUG
  debug_printf("Obs: %O, args: %O", obs, args);
#endif
  if(this_player() &&
     !this_object()->test_occupier(this_player()->query_name()) &&
     !this_player()->query_creator()) {
    this_player()->add_failed_mess(this_object(),
                                   "You don't own this house.\n", ({ }));
    return 0;
  }
  if(sizeof(obs) > 1) {
    this_player()->add_failed_mess(this_object(),
      "You may only place one object at a time.\n", ({ }));
    return 0;
  }
  if(!obs[0]->query_furniture()) {
    this_player()->add_failed_mess(this_object(),
      "$I is not suitable furniture.\n", ({ obs[0] }));
    return 0;
  }
  placed = filter(all_inventory(this_object()),
    (: $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) :));
  if(!obs[0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION))
  {
    if(sizeof(placed) >= MAX_PLACED)
    {
      if(this_player())
         this_player()->add_failed_mess(this_object(),
                                        "$C$"+this_object()->the_short() +
                                        " is too cluttered to place anything "
                                        "else.\n", ({ }));
      return 0;
    }
  }
  if(obs[0]->query_property(PLACEMENT_IMMOVABLE)) {
    this_player()->add_failed_mess(this_object(),
                                   "Try as you might you cannot move $I.\n",
                                   ({ obs[0] }));
    return 0;
  }
  if(member_array(args[1], HANGING_PREPOSITIONS + WALL_PREPOSITIONS
    + CORNER_PREPOSITIONS + ABOUT_PREPOSITIONS) != -1)
  {
    args[2] = replace_string(args[2], "ern ", " ");
    if((member_array(EXPAND_EXIT(args[2]), ({"north", "south", "east",
      "west", "northeast", "southeast", "southwest", "northwest",
      "centre"})) != -1) || sizeof(match_objects_for_existence(args[2],
      ({ this_object() }) )))
    {
      int i;
      string *new_args;
      new_args = ({ });
      new_args += ({ args[0] });
      new_args += ({ "" });
      for(i = 1; i < sizeof(args); i++)
      {
        new_args += ({ args[i] });
      }
      args = new_args;
    }
  }
  allowed_verbs = obs[0]->query_allowed_room_verbs();
  if(allowed_verbs)
  {
    allowed_verbs += ([ "" : "" ]);
    foreach(k, v in allowed_verbs)
    {
      if(k == args[1] || v == args[1])
      {
        allowed = 1;
        break;
      }
    }
  }
  if(!allowed)
  {
    string *verb_keys;
    string extra = "";
    if(allowed_verbs)
    {
      verb_keys = keys(allowed_verbs);
      verb_keys -= ({ "" });
      verb_keys = map(verb_keys, (: ("\"" + $1 + "\"") :));
      extra = "  You may only place $I " +
        query_multiple_short(verb_keys) + ".";
    }
    if(this_player())
      this_player()->add_failed_mess(this_object(),
      "You can't place $I with that verb."
      + extra + "\n", ({ obs[0] }));
    return 0;
  }
  if(sizeof(args) == 3)
  {
    string *shrapnel;
    shrapnel = explode(args[2], " ");
    args -= ({ args[2] });
    args += shrapnel;
  }
  if(args[1] != "")
  {
    args[1] = " " + args[1];
  }
  pos = get_pos_int(args[3]);
  if(args[3] == "floor" && args[2] == "on")
    args[2] = "in";
  if(member_array(args[2], ABOUT_PREPOSITIONS) != -1)
  {
    if(!pos)
    {
      result = (class obj_match)match_objects_in_environments(args[3], ({ this_object() }));
      if (result->result != OBJ_PARSER_SUCCESS) {
         if(this_player()) {
            add_failed_mess( match_objects_failed_mess( result ));
         }
         return 0;
      }
      things = result->objects;
      pos = things[0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION);
      if(pos < -1)
      {
        if(this_player())
        this_player()->add_failed_mess(this_object(),
          "$I is placed around another piece of "
          "furniture.\n", ({ things[0]->the_short() }));
        return 0;
      }
      if(pos == get_structure_index(obs[0]))
      {
        if(this_player()) {
          if(sizeof(args) >= 4)
            this_player()->add_failed_mess(this_object(),
                   "You can't place $I " + args[2] + " the " + args[3] + ".\n",
                                           ({ obs[0] }));
          else
            this_player()->add_failed_mess(this_object(),
                   "You can't place $I " + args[2] + " itself.\n", ({ obs[0] }));
        }
        return 0;
      }
      if(pos > 9)
      {
        if(this_player())
        this_player()->add_failed_mess(this_object(),
          "You can't place $I " + args[2] + " " +
          things[0]->the_short() + ".\n", ({ obs[0] }));
        return 0;
      }
      if(pos == -1)
      {
        if(this_player())
        this_player()->add_failed_mess(this_object(),
          "$I isn't placed.\n", ({ things[0] }));
        return 0;
      }
    }
    already_around = filter(all_inventory(this_object()),
      (: $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) == -($(pos)) :));
    if(sizeof(already_around) > query_max_space_around(pos))
    {
      if(this_player())
      this_player()->add_failed_mess(this_object(),
        "There isn't enough room to place " + obs[0]->the_short()
        + " there.\n", ({ }));
      return 0;
    }
    pos = -(pos);
  }
  if(pos > 0)
  {
    object *already_there;
    if(member_array(args[1][1..], HANGING_VERBS) != -1)
    {
      if(is_in_corner(pos))
      {
        if(this_player())
        this_player()->add_failed_mess(this_object(),
          "You may not place $I" + args[1] + " in a "
          "corner.\n", ({ obs[0] }));
        return 0;
      }
      pos += 10;
    }
    already_there = filter(all_inventory(this_object()),
      (: $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) == $(pos) :));
    if((sizeof(already_there)) && (already_there[0] != obs[0]))
    {
      if(this_player())
      this_player()->add_failed_mess(this_object(),
        "$I is already"
        + already_there[0]->query_property(PLACEMENT_CURRENT_ROOM_VERB) + " "
        + already_there[0]->query_property(PLACEMENT_CURRENT_ROOM_OTHER) + " "
        + get_pos_desc(pos) + ".\n", ({ already_there[0] }));
      return 0;
    }
  }
  if(is_wall_hanging(pos))
  {
    if(member_array(args[2], HANGING_PREPOSITIONS) == -1)
    {
      string *preps;
      string extra = "";
      preps = HANGING_PREPOSITIONS;
      preps = map(preps, (: ("\"" + $1 + "\"") :));
      extra = "  You may only use " + query_multiple_short(preps) +
        " as prepositions.";
#ifdef PLAYTESTING
      extra += "  Mail suggestions for more to Gototh.";
#endif
      if(this_player())
      this_player()->add_failed_mess(this_object(),
        "You may not place $I"+ args[1] + " \"" + args[2] + "\" "
        + get_pos_desc(pos) + "." + extra + "\n", ({ obs[0] }));
      return 0;
    }
  }
  if(is_beside_wall(pos))
  {
    if(member_array(args[2], WALL_PREPOSITIONS) == -1)
    {
      string *preps;
      string extra = "";
      preps = WALL_PREPOSITIONS;
      preps = map(preps, (: ("\"" + $1 + "\"") :));
      extra = "  You may only use " + query_multiple_short(preps) +
        " as prepositions.";
#ifdef PLAYTESTING
      extra += "  Mail suggestions for more to Gototh.";
#endif
      if(this_player())
      this_player()->add_failed_mess(this_object(),
        "You may not place $I"+ args[1] + " \"" + args[2] + "\" "
        + get_pos_desc(pos) + "." + extra + "\n", ({ obs[0] }));
      return 0;
    }
  }
  if(is_in_corner(pos))
  {
    if(member_array(args[2], CORNER_PREPOSITIONS) == -1)
    {
      string *preps;
      string extra = "";
      preps = CORNER_PREPOSITIONS;
      preps = map(preps, (: ("\"" + $1 + "\"") :));
      extra = "  You may only use " + query_multiple_short(preps) +
        " as a preposition.";
#ifdef PLAYTESTING
      extra += "  Mail suggestions for more to Gototh.";
#endif
      if(this_player())
      this_player()->add_failed_mess(this_object(),
        "You may not place $I"+ args[1] + " \"" + args[2] + "\" "
        + get_pos_desc(pos) + "." + extra + "\n", ({ obs[0] }));
      return 0;
    }
  }
  if(!pos)
  {
    if(this_player())
       this_player()->add_failed_mess(this_object(),
      "You may not place $I"+ args[1] + " " + args[2] + " the \""
      + args[3] + "\".\n", ({ obs[0] }));
    return 0;
  }
  obs[0]->add_property(PLACEMENT_CURRENT_ROOM_VERB, args[1]);
  obs[0]->add_property(PLACEMENT_CURRENT_ROOM_OTHER, args[2]);
  obs[0]->add_property(PLACEMENT_CURRENT_ROOM_POSITION, pos);
  if(environment(obs[0]) != this_object())
  {
    obs[0]->move(this_object());
  }
  if(pos > 0)
  {
    if(this_player())
      this_player()->add_succeeded_mess(this_object(),
      "$N $V $I so that it is" + args[1] + " " + args[2]
      + " " + get_pos_desc(pos) + ".\n", ({ obs[0] }));
  }
  else
  {
    if(sizeof(things))
    {
      if(this_player())
        this_player()->add_succeeded_mess(this_object(),
        "$N $V $I so that it is" + args[1] + " " + args[2] +
        " " + things[0]->the_short() + ".\n", ({ obs[0] }));
    }
    else
    {
      pos = -(pos);
      if(this_player())
      this_player()->add_succeeded_mess(this_object(),
        "$N $V $I so that it is" + args[1] + " " + args[2] +
        " " + get_pos_desc(pos) + ".\n", ({ obs[0] }));
    }
  }
  event(this_object(), "save", this_object());
  furniture_long = "";
  return 1;
}
int get_pos_int(string str)
{
  string dir;
  int pos_int;
  dir = explode(str, " ")[0];
  dir = EXPAND_EXIT(dir);
  switch(dir)
  {
    case "ceiling" :
    case "floor" :
    case "centre" :
      pos_int = 1;
      break;
    case "north" :
      pos_int = 2;
      break;
    case "south" :
      pos_int = 6;
      break;
    case "east" :
      pos_int = 4;
      break;
    case "west" :
      pos_int = 8;
      break;
    case "northeast" :
      pos_int = 3;
      break;
    case "southeast" :
      pos_int = 5;
      break;
    case "southwest" :
      pos_int = 7;
      break;
    case "northwest" :
      pos_int = 9;
      break;
  }
  return pos_int;
}
int find_opposite(int pos, object *structure)
{
  int opp;
  if(pos == 1 || pos == 11)
  {
    return 0;
  }
  if((pos > 5 && pos < 10) || (pos > 11 && pos > 15))
  {
    opp = pos - 4;
  }
  else
  {
    opp = pos + 4;
  }
  return opp;
}
int find_above(int pos, object *structure)
{
  int above;
  if(pos < 10)
  {
    above = pos + 10;
  }
  return above;
}
int find_below(int pos, object *structure)
{
  int below;
  if(pos > 10)
  {
    below = pos - 10;
  }
  return below;
}
int find_left(int pos, object *structure)
{
  int left;
  if(pos == 1 || pos == 11)
  {
    return 0;
  }
  left = pos - 1;
  if(left == 1)
  {
    left = 9;
  }
  if(left == 11)
  {
    left = 19;
  }
  return left;
}
int find_right(int pos, object *structure)
{
  int right;
  if(pos == 1 || pos == 11)
  {
    return 0;
  }
  right = pos + 1;
  if(right == 10)
  {
    right = 2;
  }
  if(right == 20)
  {
    right = 12;
  }
  return right;
}
string query_furniture_ordinal(object ob)
{
  int index;
  string str_num;
  object *obs;
  str_num = "";
  obs = match_objects_for_existence(ob->query_plural(), ({ this_object() }));
  index = member_array(ob, obs);
  if((index != -1) && (sizeof(obs) != 1))
  {
    str_num = " " + word_ordinal(index + 1);
  }
  if((index != -1) && (sizeof(obs) != 1))
  {
    str_num = " " + word_ordinal(index + 1);
  }
  return str_num;
}
string object_position_desc(object thing)
{
  string verb;
  string other;
  string position;
  string str;
  verb = thing->query_property(PLACEMENT_CURRENT_ROOM_VERB);
  other = thing->query_property(PLACEMENT_CURRENT_ROOM_OTHER);
  position = get_pos_desc(thing->query_property(PLACEMENT_CURRENT_ROOM_POSITION));
  if(verb == "")
  {
    str = other + " " + position;
  }
  else
  {
    str = verb[1..] + " " + other + " " + position;
  }
  return str;
}
string describe_relative_position(int index)
{
  string relative_desc;
  switch(index)
  {
    case OPPOSITE :
      relative_desc = OPPOSITE_DESCS[random(sizeof(OPPOSITE_DESCS))];
      break;
    case ABOVE :
      relative_desc = ABOVE_DESCS[random(sizeof(ABOVE_DESCS))];
      break;
    case BELOW :
      relative_desc = BELOW_DESCS[random(sizeof(BELOW_DESCS))];
      break;
    case RIGHT :
      relative_desc = RIGHT_DESCS[random(sizeof(RIGHT_DESCS))];
      break;
    case LEFT :
      relative_desc = LEFT_DESCS[random(sizeof(LEFT_DESCS))];
      break;
  }
  return relative_desc;
}
string object_desc2(object thing)
{
  string verb;
  string other;
  string position;
  string str;
  mapping allowed_verbs;
  verb = thing->query_property(PLACEMENT_CURRENT_ROOM_VERB);
  allowed_verbs = thing->query_allowed_room_verbs();
  if (!allowed_verbs) {
     allowed_verbs = ([ ]);
  }
  verb = allowed_verbs[verb[1..]];
  if(!verb || verb == "")
  {
    verb = "is";
  }
  other = thing->query_property(PLACEMENT_CURRENT_ROOM_OTHER);
  position = get_pos_desc(thing->query_property(PLACEMENT_CURRENT_ROOM_POSITION));
  str = verb + " " + thing->a_short();
  return str;
}
string object_desc(object thing)
{
  string str;
  switch(random(2))
  {
    case 0 :
      str = object_position_desc(thing) + " is " + thing->a_short();
      break;
    default :
      str = object_position_desc(thing) + " is " + thing->a_short();
      break;
  }
  return str;
}
int *find_relative_indexes(int index, mixed structure)
{
  int *relatives;
  relatives = allocate(5);
  relatives[OPPOSITE] = find_opposite(index, structure);
  relatives[ABOVE] = find_above(index, structure);
  relatives[BELOW] = find_below(index, structure);
  relatives[RIGHT] = find_right(index, structure);
  relatives[LEFT] = find_left(index, structure);
  return relatives;
}
string desc_around_with(object ob, object *around)
{
  around -= have_described;
  if(sizeof(around) == 1)
  {
    return "$C$" + object_desc(ob) + " " +
      around[0]->query_property(PLACEMENT_CURRENT_ROOM_OTHER) +
      " which is " + query_multiple_furniture_short(around) + ".  ";
  }
  return "$C$" + object_desc(ob) + " around which are " +
    query_multiple_furniture_short(around) + ".  ";
}
string desc_around_without(object *around, object *structure,
  int location)
{
  if(location < 0)
  {
    location = -(location);
  }
  if(!structure[location])
  {
    if(sizeof(around) == 1)
    {
      return "$C$" + around[0]->query_property(PLACEMENT_CURRENT_ROOM_OTHER)
        + " " + get_pos_desc(location) + " is" +
        query_another(around[0]) + " " + around[0]->query_short() +
        ".  ";
    }
    else
    {
      return "Around " + get_pos_desc(location) +
        " are " + query_multiple_furniture_short(around) + ".  ";
    }
  }
  else
  {
    if(sizeof(around) == 1)
    {
      return "$C$" + around[0]->query_property(PLACEMENT_CURRENT_ROOM_OTHER) +
        " the" + query_furniture_ordinal(structure[location]) + " " +
        structure[location]->query_short() + " is" +
        query_another(around[0]) + " " +
        around[0]->query_short() + ".  ";
    }
    else
    {
      return "Around " + structure[location]->the_short() +
        " are " + query_multiple_furniture_short(around) + ".  ";
    }
  }
}
string trim_trailing_spaces(string str)
{
  int i;
  if(!sizeof(str))
  {
    return str;
  }
  for(i = (sizeof(str)) - 1; str[i] == ' '; i--);
  return str[0..i];
}
int choose_relative(int *relatives, object *structure) {
  int num, found;
  int *rands;
  rands = ({ 0, 1, 2, 3, 4 });
  while(sizeof(rands)) {
    num = rands[random(sizeof(rands))];
    if(objectp(structure[relatives[num]])) {
      if(member_array(structure[relatives[num]], needs_described) != -1) {
        found = 1;
        break;
      }
    }
    rands -= ({ num });
  }
  if(found)
    return num;
  return -1;
}
object *get_around(object ob) {
  object *around;
  around = filter(all_inventory(this_object()),
    (: $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) &&
       $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) ==
       -($(ob->query_property(PLACEMENT_CURRENT_ROOM_POSITION))) :));
  return around;
}
void set_orientation(int num)
{
  orientation = num;
}
int query_orientation()
{
  return orientation;
}
string wall_or_corner(int pos)
{
   return query_wall_name_pos(pos);
}
string desc_obs_relatively(int *indexes, object *structure)
{
  int i;
  int *relatives;
  string desc;
  object *around;
  int rel_num;
  object rel_ob;
  desc = "";
  while(sizeof(indexes)) {
    i = indexes[random(sizeof(indexes))];
    indexes -= ({ i });
    if(member_array(structure[i], needs_described) == -1) {
      continue;
    }
    needs_described -= ({ structure[i] });
    have_described += ({ structure[i] });
    relatives = find_relative_indexes(i, structure);
    rel_num = choose_relative(relatives, structure);
    if(rel_num == -1)
      rel_ob = 0;
    else
      rel_ob = structure[relatives[rel_num]];
    around = get_around(structure[i]);
    if(!rel_ob) {
      if(sizeof(around)) {
        desc += desc_around_with(structure[i], around);
        needs_described -= around;
        have_described += around;
        continue;
      } else {
        if(clutter_string(structure[i]) == "") {
          desc += "$C$" + object_desc(structure[i]) + ".  ";
        } else {
          desc += "$C$" + object_desc(structure[i]) +
            " upon which" + clutter_string(structure[i]) + ".  ";
        }
        continue;
      }
    }
    needs_described -= ({ rel_ob });
    have_described += ({ rel_ob });
    indexes -= ({ relatives[rel_num] });
    desc += "$C$" + object_desc(structure[i]) + " " +
      describe_relative_position(rel_num) + " " +
      object_desc2(rel_ob) + ".  ";
    if(clutter_string(structure[i]) != "") {
      desc += "On " + structure[i]->the_short() +
        clutter_string(structure[i]);
      if(clutter_string(rel_ob) != "") {
        desc += " while on " + rel_ob->the_short() +
          clutter_string(rel_ob) + ".  ";
      } else {
        desc += ".  ";
      }
    } else if(clutter_string(rel_ob) != "") {
      desc += "On " + rel_ob->the_short() +
        clutter_string(rel_ob) + ".  ";
    }
    if(sizeof(around)) {
      desc += desc_around_without(around, structure, i);
      needs_described -= around;
      have_described += around;
      continue;
    }
    around = get_around(rel_ob);
    if(sizeof(around)) {
      desc += desc_around_without(around, structure, relatives[rel_num]);
      needs_described -= around;
      have_described += around;
      continue;
    }
  }
  return desc;
}
int room_order(object *obs1, object *obs2, object *structure)
{
  int pos1, pos2;
  object ob1, ob2;
  int order1, order2;
  pos1 = -(obs1[0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION));
  pos2 = -(obs2[0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION));
  if (pos1 < 0) {
     ob1 = 0;
  } else {
     ob1 = structure[pos1];
  }
  if (pos2 < 0) {
     ob2 = 0;
  } else {
     ob2 = structure[pos2];
  }
  if(!ob1 || !ob2)
  {
    return 0;
  }
  if(ob1->query_plural() != ob2->query_plural())
  {
    return 0;
  }
  order1 = member_array(ob1, match_objects_for_existence(ob1->query_plural(),
    ({ this_object() })));
  order2 = member_array(ob2, match_objects_for_existence(ob2->query_plural(),
    ({ this_object() })));
  if(order1 > order2)
  {
    return 1;
  }
  return -1;
}
string describe_remaining_objects(object *structure)
{
  int pos;
  string desc;
  object *group;
  mixed *orphans;
  desc = "";
  if(sizeof(needs_described))
  {
    orphans = unique_array(needs_described,
      (: $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) :));
    if(sizeof(orphans))
    {
      orphans = sort_array(orphans, (: room_order($1, $2, $(structure)) :));
      foreach(group in orphans)
      {
        pos = group[0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION);
        desc += desc_around_without(group, structure, pos);
        needs_described -= group;
        have_described += group;
      }
    }
  }
  return desc;
}
string get_group_verb(object *obs)
{
  mixed *verbs;
  verbs = map(obs, (: $1->query_property(PLACEMENT_CURRENT_ROOM_VERB) :));
  verbs = unique_array(verbs, (: $1 :));
  if(sizeof(verbs) == 1)
  {
    return verbs[0][0];
  }
  return "";
}
string get_group_other(object *obs)
{
  mixed *others;
  others = map(obs, (: $1->query_property(PLACEMENT_CURRENT_ROOM_OTHER) :));
  others = unique_array(others, (: $1 :));
  if(sizeof(others) == 1)
  {
    return others[0][0];
  }
  return others[random(sizeof(others))][0];
}
string describe_plural_objects(int *indexes, object *structure)
{
  int i, j;
  int flag;
  int rel_num;
  int used_pos;
  mixed *things;
  string desc = "";
  string *strs;
  strs = ({ });
  things = ({ });
  for(i = 0; i < sizeof(indexes); i++) {
    things += ({ structure[indexes[i]] });
  }
  things = unique_array(things, (: $1->query_plural() :));
  things = filter(things, (: sizeof($1) > 1 :) );
  if(sizeof(things) > 0) {
    for(i = 0; i < sizeof(things); i++) {
      needs_described -= things[i];
      have_described += things[i];
      if(sizeof(things[i]) == 4) {
        int they_are = 1;
        int *rel_nums;
        int num;
        rel_nums = map(things[i],
          (: $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) :));
#ifdef DEBUG
        debug_printf("rel_nums: %O", rel_nums);
#endif
        foreach(num in rel_nums)
          if(is_in_corner(num))
            they_are = 0;
        if(they_are) {
          desc += "$C$" + things[i][0]->query_plural() + " are" +
            get_group_verb(things[i]) + " " +
            get_group_other(things[i]) + " each " +
            wall_or_corner(rel_nums[0]) + ".  ";
#ifdef DEBUG
          debug_printf("4 corner: %s\n", desc);
#endif
          continue;
        }
        they_are = 1;
        foreach(num in rel_nums)
        {
          if(is_beside_wall(num))
          {
            they_are = 0;
          }
        }
        if(they_are)
        {
          desc += "$C$" + things[i][0]->query_plural() + " are" +
            get_group_verb(things[i]) + " " +
            get_group_other(things[i]) + " each " +
            wall_or_corner(3) + ".  ";
          continue;
        }
      }
      if(sizeof(things[i]) == 3)
      {
        int *rel_nums;
        rel_nums = map(things[i],
          (: $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) :));
        rel_nums = sort_array(rel_nums, 1);
        if(rel_nums[2] == 9)
        {
          rel_nums -= ({ 9 });
          rel_nums = ({ 1 }) + rel_nums;
        }
        if(is_beside_wall(rel_nums[1]) &&
          rel_nums[0] == rel_nums[1] - 1 &&
          rel_nums[2] == rel_nums[1] + 1)
        {
          desc += "$C$" + query_multiple_short(things[i]) +
            " are" + get_group_verb(things[i]) + " beside each other " +
            structure[rel_nums[1]]->query_property(PLACEMENT_CURRENT_ROOM_OTHER)
            + " the " + get_pos_desc(rel_nums[1]) + ".  ";
          continue;
        }
      }
      if(sizeof(things[i]) == 2)
      {
        rel_num = member_array(get_structure_index(things[i][1]),
          find_relative_indexes(get_structure_index(things[i][0]),
          structure));
        if(rel_num != -1)
        {
          desc += "$C$" + query_multiple_short(things[i]);
          switch(rel_num)
          {
            case OPPOSITE :
              desc += " face each other across the room.  ";
              continue;
              break;
            case RIGHT :
            case LEFT :
              desc += " are" + get_group_verb(things[i]) +
                " beside each other ";
              break;
            default :
              break;
          }
          if(!orientation)
          {
            if(get_structure_index(things[i][0]) & 1)
            {
              used_pos =
                things[i][1]->query_property(PLACEMENT_CURRENT_ROOM_POSITION);
            }
            else
            {
              used_pos =
                things[i][0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION);
            }
          }
          else
          {
            if(get_structure_index(things[i][0]) & 1)
            {
              used_pos =
                things[i][0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION);
            }
            else
            {
              used_pos =
                things[i][1]->query_property(PLACEMENT_CURRENT_ROOM_POSITION);
            }
          }
          desc +=
            structure[used_pos]->query_property(PLACEMENT_CURRENT_ROOM_OTHER) +
            " the " + get_pos_desc(used_pos) + ".  ";
          continue;
        }
      }
      desc += "$C$" + query_num(sizeof(things[i]), 4) + " "
        + things[i][0]->query_plural() + " are positioned "
        "around the room.  ";
#ifdef DEBUG
      debug_printf("2 items: %s\n", desc);
#endif
      if(sizeof(things[i]) > 4)
      {
        flag = 1;
      }
      else
      {
        desc += "They are ";
      }
      for(j = 0; j < sizeof(things[i]); j++)
      {
        if(!flag)
        {
          strs += ({ object_position_desc(things[i][j]) });
        }
        indexes -=
          ({ things[i][j]->query_property(PLACEMENT_CURRENT_ROOM_POSITION) });
      }
      if(!flag)
      {
        desc += query_multiple_short(strs)+".  ";
#ifdef DEBUG
        debug_printf("position: %s [%s]\n",
                     query_multiple_short(strs), desc);
#endif
        strs = ({ });
      }
    }
  }
  return desc;
}
string furniture_long()
{
  string desc, d1, d2, d3;
  object *structure;
  int i, *indexes;
  if(furniture_long != "") {
    return furniture_long;
  }
  structure = build_structure();
  indexes = ({ });
  for(i = 0; i < sizeof(structure); i++)
  {
    if(objectp(structure[i]))
    {
      indexes += ({ i });
    }
  }
  needs_described = filter(all_inventory(this_object()),
    (: $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) :));
  have_described = ({ });
  d1 = describe_plural_objects(indexes, structure);
  d2 = desc_obs_relatively(indexes, structure);
  d3 = describe_remaining_objects(structure);
#ifdef DEBUG
  debug_printf("1: %s\n2:%s\n3:%s\n",d1, d2, d3);
#endif
  desc = d1 + d2 + d3;
  if(desc == "")
    desc = "$C$" + this_object()->the_short() + "$C$" + " is completely empty.";
  furniture_long = trim_trailing_spaces(desc);
  return furniture_long;
}
string get_pos_desc(int pos_int)
{
  string str;
  switch(pos_int)
  {
    case 1 :
      str = "the centre of " + this_object()->the_short();
      break;
    case 2 :
    case 12 :
      str = "the north " + wall_or_corner(pos_int);
      break;
    case 3 :
    case 13 :
      str = "the northeast " + wall_or_corner(pos_int);
      break;
    case 4 :
    case 14 :
      str = "the east " + wall_or_corner(pos_int);
      break;
    case 5 :
    case 15 :
      str = "the southeast " + wall_or_corner(pos_int);
      break;
    case 6 :
    case 16 :
      str = "the south " + wall_or_corner(pos_int);
      break;
    case 7 :
    case 17 :
      str = "the southwest " + wall_or_corner(pos_int);
      break;
    case 8 :
    case 18 :
      str = "the west " + wall_or_corner(pos_int);
      break;
    case 9 :
    case 19 :
      str = "the northwest " + wall_or_corner(pos_int);
      break;
    case 11 :
      str = "the centre of the ceiling";
      break;
  }
  return str;
}
object *build_structure()
{
  int i;
  object *positions, *obs, *dummies;
  positions = allocate(20);
  obs = all_inventory(this_object());
  for(i = 1; i < sizeof(positions); i++)
  {
    dummies = filter(obs,
      (: $1->query_property(PLACEMENT_CURRENT_ROOM_POSITION) == $(i) :));
    if(sizeof(dummies))
    {
      positions[i] = dummies[0];
    }
  }
  return positions;
}
int get_structure_index(object ob)
{
  return member_array(ob, build_structure());
}
string desc_surface(string dir)
{
  int i;
  int pos;
  int *indexes;
  int current_pos;
  string desc;
  object *structure;
  object *around;
  structure = build_structure();
  needs_described = ({ });
  have_described = ({ });
  if(dir == "ceiling")
  {
    pos = 11;
  }
  else
  {
    pos = get_pos_int(dir);
  }
  desc = "";
  indexes = ({ });
  for(i = 1; i < sizeof(structure); i++)
  {
    if(!objectp(structure[i]))
    {
      continue;
    }
    current_pos = structure[i]->query_property(PLACEMENT_CURRENT_ROOM_POSITION);
    if(current_pos != pos)
    {
      if(pos != 1 && pos != 11)
      {
        if((current_pos != pos + 10) && (current_pos != pos - 10))
        {
          structure[i] = 0;
        }
        else
        {
          needs_described += ({ structure[i] });
          indexes += ({ i });
        }
      }
    }
    else
    {
      needs_described += ({ structure[i] });
      around = get_around(structure[i]);
      if(around)
      {
        needs_described += around;
      }
      indexes += ({ i });
    }
  }
  desc += desc_obs_relatively(indexes, structure);
  return desc;
}
void displace_object(object ob)
{
  if (ob->query_property(PLACEMENT_CURRENT_ROOM_POSITION)) {
    ob->remove_property(PLACEMENT_CURRENT_ROOM_VERB);
    ob->remove_property(PLACEMENT_CURRENT_ROOM_OTHER);
    ob->remove_property(PLACEMENT_CURRENT_ROOM_POSITION);
    furniture_long = "";
  }
}
int do_displace(object *obs)
{
  if(this_player() &&
     !this_object()->test_occupier(this_player()->query_name()) &&
     !this_player()->query_creator()) {
    this_player()->add_failed_mess(this_object(),
                                   "You don't own this house.\n");
    return 0;
  }
  if(sizeof(obs) > 1)
  {
    this_player()->add_succeeded_mess(this_object(),
      "You may only displace one thing at a time.\n", ({ }));
    return 1;
  }
  if(!obs[0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION))
  {
    this_player()->add_failed_mess(this_object(),
      "$C$" + obs[0]->the_short() + " is not placed.\n", ({ }));
    return 0;
  }
  if(obs[0]->query_property(PLACEMENT_IMMOVABLE)) {
    this_player()->add_failed_mess(this_object(),
                                   "Try as you might you cannot move $I.\n",
                                   ({ obs[0] }));
    return 0;
  }
  displace_object(obs[0]);
  this_player()->add_succeeded_mess(this_object(),
    "$N drag$s " + obs[0]->a_short() + " out of position.\n", ({ }));
  furniture_long = "";
  return 1;
}
void event_exit(object ob, string, object)
{
  displace_object(ob);
}
int test_remove(object thing, int flag, mixed dest) {
  if(thing->query_property(PLACEMENT_IMMOVABLE))
    return 0;
  if(thing->query_property(PLACEMENT_CURRENT_ROOM_HIDDEN))
    thing->removed();
  return 1;
}

==================================================
FILE: room/inherit/player_housing.c
==================================================

#include <dirs.h>
#include <housing.h>
#include <login_handler.h>
#include <player_handler.h>
inherit "/std/room/inherit/placement";
inherit "/std/room/inherit/room_save";
#define STANDARD_EXITS ({ "north", "northeast", "east", "southeast", \
                          "south", "southwest", "west", "northwest"})
#undef PLAYTESTING
#define DEBUG
private nosave int _setup_callout;
varargs string* query_direc(object thing);
int query_relative(string direc);
varargs mixed query_door_control(string direc);
varargs mixed* query_dest_other(string direc);
int modify_exit(string dir, mixed* arr);
varargs int add_item(mixed shorts, mixed desc, int no_plural);
string the_short();
string* query_exits();
int query_exit(string direc);
void setup_doors();
void update_doors();
private void update_short_cache(string direc);
int test_occupier(string name);
string show_surface(string direc);
int allow_list();
int do_deny(string player, string location);
int do_allow(object player, string location);
int add_allowed(string pname);
int remove_allowed(string pname);
string query_owner();
class decoration {
  string short;
  string covering;
}
class exit_data {
  string long;
  string key;
  int difficulty;
  int closed;
  int locked;
  int autolock;
  int transparent;
  mixed trap_data;
}
class exit_shorts {
  string one_short;
  string a_short;
}
private class decoration *decorations;
private string base_long;
private mapping exits;
private mapping exit_shorts;
private nosave mapping coverings;
private nosave string owner;
private string *allowed = ({ });
private string *tell_denied = ({ });
private nosave string decoration_desc = "";
private nosave string quit_location;
private nosave int done_setup;
private nosave int setup_counter;
private nosave string *surfaces;
#ifdef DEBUG
void debug_log(string fmt, mixed args ...) {
    debug_printf(fmt + "\n", args ...);
  if(base_name(this_object()) == "/d/cwc/Bes_Pelargic/Pong_Ping/roads/phoenix_avenue/housing/05entrycorridor") {
    log_file("HOUSING_DEBUG", "%s (%s): " + fmt + "\n",
       ctime(time())[4..18], base_name(this_object()), args ...);
  }
}
#endif
void create() {
  room_save::create();
  exits = ([ ]);
  exit_shorts = ([ ]);
  decorations = ({ });
  tell_denied = ({ });
  this_object()->add_item("left", (: show_surface("left") :));
  this_object()->add_item("right", (: show_surface("right") :));
  this_object()->add_item("forward", (: show_surface("forward") :));
  this_object()->add_item("backward", (: show_surface("backward") :));
  this_object()->add_item("up", (: show_surface("up") :));
  this_object()->add_item("down", (: show_surface("down") :));
  done_setup = 0;
  setup_doors();
  call_out("setup_doors", 0);
}
string show_surface(string direc) {
  class decoration tmp;
  int found;
  string lstr, dstr;
  mixed tmp2;
  switch(direc) {
  case "left":
  case "right":
  case "forward":
  case "backward":
    tmp2 = this_player()->query_facing();
    direc = (string)this_player()->find_abs(direc, tmp2[0]);
    break;
  case "up":
    direc = "ceiling";
    break;
  case "down":
    direc = "floor";
    break;
  }
  if(!decorations) {
    decorations = ({ });
  } else {
    foreach(tmp in decorations) {
      if(member_array(tmp->short, surfaces) == -1)
        decorations -= ({ tmp });
      if(tmp->short == direc || tmp->short == direc + " wall") {
        found = 1;
        break;
      }
    }
  }
  if(found) {
    direc = replace(direc, ({ " wall", "" }));
    if(member_array(direc, query_direc()) != -1) {
      lstr = "$C$";
      update_short_cache(direc);
      if(exit_shorts[direc] && exit_shorts[direc]->one_short) {
        if(query_door_control(direc))
          lstr += query_door_control(direc)->one_short() + " leads";
        else
          lstr = "an exit leads";
        lstr += " to " + exit_shorts[direc]->one_short;
      } else {
        if(query_door_control(direc))
          lstr += "is the " + query_door_control(direc)->one_short();
        else
          lstr += "is an exit";
      }
      lstr += " and the ";
    } else
      lstr = "The ";
    dstr = desc_surface(direc);
    if(dstr != "")
      dstr = "  " + dstr;
    return lstr + tmp->short + " is " + tmp->covering + "." + dstr;
  }
  return "";
}
string show_corner(string direc) {
  string tmp;
  tmp = desc_surface(direc);
  if(tmp == "") {
    tmp = "The " + direc + " corner is empty.";
  }
  return tmp;
}
string exit_long() {
  string *direcs, lstr;
  int i, j;
  object door;
  direcs = query_direc();
  if(!sizeof(direcs))
    return "";
  lstr = "  $C$";
  for(i=0; i<sizeof(direcs); i++) {
    update_short_cache(direcs[i]);
    if(query_relative(direcs[i])) {
      j = member_array(this_player()->find_rel(direcs[i]), REL_DIRS);
      lstr += REL_DIRS[j+2];
      if(exit_shorts[direcs[i]]) {
        if(query_door_control(direcs[i]))
          lstr += " " + query_door_control(direcs[i])->a_short() + " leads "
            "to " + exit_shorts[direcs[i]]->a_short;
        else
          lstr += " an exit leads to " + exit_shorts[direcs[i]]->a_short;
      } else {
        if(query_door_control(direcs[i]))
          lstr += " is " + query_door_control(direcs[i])->a_short();
        else
          lstr += " is an exit";
      }
    } else {
      door = query_door_control(direcs[i]);
      if(door) {
        if(member_array("window", door->query_name()) != -1)
          lstr += door->a_short() + " looks out";
        else
          lstr += door->a_short() + " leads " + direcs[i];
      } else
        lstr += "an exit leads " + direcs[i];
    }
    if(i < sizeof(direcs)-2)
      lstr += ", ";
    if(i == sizeof(direcs)-2)
      lstr += " and ";
    if(i == sizeof(direcs)-1)
      lstr += ".";
  }
  return lstr;
}
string decoration_long() {
  class decoration tmp;
  string lstr, wstr, tmpstr, *tmparray, *names;
  int i;
#ifdef 0
  if(decoration_desc != "")
    return decoration_desc;
#endif
  lstr = "";
  if(sizeof(decorations)) {
    coverings = ([ ]);
    names = ({ "walls" });
    foreach ( tmp in decorations ) {
      if(!coverings[tmp->covering])
        coverings[tmp->covering] = ({ tmp->short });
      else
        coverings[tmp->covering] += ({ tmp->short });
      if(classp(tmp) && strsrch(tmp->short, "wall") == -1)
        names += ({ tmp->short });
    }
    i = 0;
    tmparray = sort_array(keys(coverings),
                        (: sizeof(coverings[$1]) - sizeof(coverings[$2]) :));
    if(sizeof(tmparray) > 3) {
      lstr += "  The " + query_multiple_short(names) + " are multicoloured.  ";
    } else if(sizeof(tmparray) == 1) {
      lstr += "  The surfaces are all " + decorations[0]->covering + ".  ";
    } else {
      foreach(tmpstr in tmparray) {
        if(i == 0)
          wstr = "  The ";
        else
          wstr = "the ";
        if(i == sizeof(tmparray)-1 && sizeof(coverings[tmpstr]) > 1)
          wstr += "other surfaces";
        else
          wstr += query_multiple_short(coverings[tmpstr], "", 1);
        if(sizeof(coverings[tmpstr]) > 1)
          wstr += " are ";
        else
          wstr += " is ";
        wstr += tmpstr;
        if(i < sizeof(tmparray) -2)
          wstr += ", ";
        else if(i == sizeof(tmparray) -2)
          wstr += " and ";
        else if(i == sizeof(tmparray) -1)
          wstr += ".  ";
        i++;
        lstr += wstr;
      }
    }
  }
  decoration_desc = lstr;
  return decoration_desc;
}
string query_long() {
  string lstr, tmp;
  if(base_long)
    lstr = "This is " + base_long + ".";
  else
    lstr = "";
  tmp = decoration_long();
  if(tmp != "")
    lstr += tmp;
  else
    lstr += "  ";
  return (lstr + furniture_long() + exit_long() + "\n");
}
int setup_exit(string direc, int relative) {
  if(member_array(direc, STANDARD_EXITS) != -1 && relative)
    modify_exit(direc, ({ "relative", 1 }));
  modify_exit(direc, ({ "closed", 1 }));
  return 1;
}
void set_base_desc(string desc) {
  base_long = desc;
}
string query_base_desc() {
  return base_long;
}
void set_quit_handler(string filename) {
  quit_location = filename;
}
string query_quit_handler() {
  if(this_player() && !test_occupier(this_player()->query_name()) &&
     quit_location)
    return quit_location;
  return base_name(this_object());
}
void add_surface(string short, string covering ){
  class decoration tmp;
  string dir;
  if(!surfaces)
    surfaces = ({ });
  surfaces += ({ short });
  if(!decorations)
    decorations = ({ });
  else {
    foreach(tmp in decorations)
      if(tmp->short == short) {
        add_item(tmp->short, (: show_surface($(tmp->short)) :));
        short = replace(short, ({" wall", ""}));
        foreach(dir in keys(ABS_FACING)) {
          if(ABS_FACING[short] &&
             ABS_FACING[dir] == (ABS_FACING[short] % 8 ) + 1) {
            add_item(dir+" corner", (: show_corner($(dir)) :));
            break;
          }
        }
        return;
      }
  }
  tmp = new(class decoration );
  tmp->short = short;
  tmp->covering = covering;
  decorations += ({ tmp });
  add_item(tmp->short, (: show_surface($(tmp->short)) :));
  short = replace(short, ({" wall", ""}));
  foreach(dir in keys(ABS_FACING))
    if(ABS_FACING[short] &&
       ABS_FACING[dir] == (ABS_FACING[short] + 1) % 8) {
      add_item(dir+" corner", (: show_corner($(dir)) :));
      break;
    }
  decoration_desc = "";
}
string *query_surfaces() {
  string *stmp;
  class decoration tmp;
  stmp = ({ });
  foreach(tmp in decorations) {
    stmp += ({ replace(tmp->short, ({" wall", ""})) });
  }
  return stmp;
}
int decorate_surface(string short, string covering ){
  class decoration tmp;
  foreach(tmp in decorations)
    if(tmp->short == short) {
      tmp->covering = covering;
      event(this_object(), "save");
      decoration_desc = "";
      return 1;
    }
  return 0;
}
void query_decorations() {
  printf("%O\n", decorations);
}
int test_save(object thing) {
  return thing->query_furniture() || thing->query_missing_item_receipt();
}
int test_remove(object thing, int flag, mixed dest) {
  if(!placement::test_remove(thing, flag, dest))
    return 0;
  return room_save::test_remove(thing, flag, dest);
}
object *my_process_non_living(object *int_non_livings, int start) {
  object *not_positioned;
  not_positioned = filter(int_non_livings,
                          (: !$1->query_property("current room position") &&
                           !$1->query_property("current room hidden") :) );
  return not_positioned;
}
void init() {
  placement::init();
  if(!allowed) {
    allowed = ({ });
  }
  add_command("allow", "list", (: allow_list() :));
  if(test_occupier(this_player()->query_name()) ||
     this_player()->query_creator()) {
    if(!HOUSING->query_house(base_name(this_object()))) {
      add_command("allow", "<indirect:player:here>",
                  (: do_allow($1[0], "room") :));
      add_command("deny", "<word'player'>",
                  (: do_deny($4[0], "room") :));
    } else {
      add_command("allow", "<indirect:player:here> <word'house|room'>",
                  (: do_allow($1[0], $4[1]) :));
      add_command("deny", "<word'player'> <word'house|room'>",
                  (: do_deny($4[0], $4[1]) :));
    }
  }
}
protected void event_enter_checks(object ob) {
  if(!tell_denied) {
    tell_denied = ({ });
  }
  if(ob && interactive(ob) &&
     member_array(ob->query_name(), tell_denied) != -1) {
    write("%^YELLOW%^%^BOLD%^You are no longer allowed to control this "
          "room.%^RESET%^\n");
    tell_denied -= ({ ob->query_name() });
  }
}
void event_enter(object ob, string message, object from) {
#ifdef PLAYTESTING
  if(interactive(ob) &&
     (!ob->query_creator() &&
     !"/obj/handlers/playtesters"->query_playtester(ob->query_name())) &&
     ob->query_name() != "gumboot") {
    tell_object(ob, "Sorry, this area is only open to playtesters.\n");
    ob->move(from);
  }
#endif
  event_enter_checks(ob);
}
int allow_list() {
  string *tmp;
  if(owner && owner != "For Sale" && owner != "Under Offer") {
    tmp = ({ owner }) + allowed;
  } else {
    tmp = allowed;
  }
  if (!test_occupier(this_player()->query_name()) &&
      !this_player()->query_creator()) {
    add_failed_mess("You are not allowed to control this room.\n", ({ }));
    return 0;
  }
  switch(sizeof(tmp)) {
  case 0:
    add_succeeded_mess(({"Noone is allowed to control this room.\n",
                           "$N messes with something in " + the_short() +
                           ".\n"}));
    break;
  case 1:
    add_succeeded_mess(({query_multiple_short(tmp) +
                           " is allowed to control this room.\n",
                           "$N messes with something in " + the_short() +
                           ".\n"}));
    break;
  default:
    add_succeeded_mess(({query_multiple_short(tmp) +
                           " are allowed to control this room.\n",
                           "$N messes with something in " + the_short() +
                           ".\n"}));
  }
  return 1;
}
int do_allow(object player, string location) {
  string pname;
  string *rooms;
  string room;
  int failed;
  if((query_owner() != this_player()->query_name()) &&
     !this_player()->query_creator()) {
    add_failed_mess("You are not allowed to control this room.\n", ({ }));
    return 0;
  }
  if(environment(player) != this_object()) {
    return add_failed_mess("$I is not here.\n", ({ player }));
  }
  pname = lower_case(player->query_name());
  if(test_occupier(pname)) {
    add_failed_mess("$I is already able to control this room.\n");
    return 0;
  }
  if(location == "house") {
    rooms = HOUSING->query_rooms(base_name(this_object()));
    failed = 1;
    foreach(room in rooms) {
      failed &= room->add_allowed(pname);
    }
  } else {
    failed = add_allowed(pname);
  }
  if (failed) {
     add_failed_mess("Failed to add " + pname + " as being able to control "
                     "the " + location + ".\n");
     return 0;
  }
  tell_object(player, "You are now permitted to control this " + location +
              ".\n");
  add_succeeded_mess(({ pname + " is allowed to control this " + location +
                          ".\n", ""}));
  return 1;
}
int do_deny(string player, string location) {
  object ob;
  string *rooms, room;
  if(member_array(player, allowed) == -1) {
    add_failed_mess(player + " is not on the allow list.\n");
    return 0;
  }
  if (!test_occupier(this_player()->query_name()) &&
      !this_player()->query_creator()) {
    add_failed_mess("You are not allowed to control this room.\n");
    return 0;
  }
  if(!test_occupier(player)) {
    add_failed_mess(player + " is already not allowed to control this room.\n");
    return 0;
  }
  if(location == "house") {
    rooms = HOUSING->query_rooms(base_name(this_object()));
    foreach(room in rooms)
      room->remove_allowed(player);
  } else {
    remove_allowed(player);
  }
  ob = find_player(player);
  if(ob && environment(ob) == this_object()) {
    tell_object(ob, "%^YELLOW%^%^BOLD%^You are no longer allowed to control " +
                the_short() + ".\n%^RESET%^");
  } else {
    tell_denied += ({ player });
  }
  add_succeeded_mess(({player + " is no longer allowed to control this " +
                     location + ".\n", "" }));
  return 1;
}
private void update_short_cache(string direc) {
  string ostr, astr;
  if(!exit_shorts)
    exit_shorts = ([ ]);
  if(find_object(query_dest_other(direc)[0])) {
    ostr = query_dest_other(direc)[0]->one_short();
    if(this_player())
      ostr = this_player()->convert_message(ostr);
    astr = query_dest_other(direc)[0]->a_short();
    if(this_player())
      astr = this_player()->convert_message(astr);
    if(!exit_shorts[direc] ||
       ostr != exit_shorts[direc]->one_short ||
       astr != exit_shorts[direc]->a_short) {
      exit_shorts[direc] = new(class exit_shorts,
                               one_short : ostr,
                               a_short : astr);
    }
  }
}
void update_doors() {
  string exit;
  object door_ob;
  if(!done_setup)
    setup_doors();
  if(!exits)
    exits = ([ ]);
  foreach(exit in query_exits()) {
    door_ob = query_door_control(exit);
    if(door_ob) {
      if(door_ob->query_key() == "generic_key") {
#ifdef DEBUG
        if(exits[exit])
          debug_log("update_doors", "Door %s has generic_key, exit data "
                    "has %s", exit, exits[exit]->key);
        else
          debug_log("update_doors", "Door %s has generic_key, no existing "
                    "exit data.", exit);
#endif
      }
      exits[exit] = new(class exit_data,
                        long : door_ob->query_long(),
                        key : door_ob->query_key(),
                        difficulty: door_ob->query_difficulty(),
                        closed : door_ob->query_closed(),
                        locked : door_ob->query_locked(),
                        autolock : door_ob->query_autolock(),
                        transparent : door_ob->query_transparent(),
                        trap_data : door_ob->query_trap_data());
#ifdef DEBUG2
      debug_log("update_doors: Door %s: key: %s, difficulty: %d, closed: %d, "
                "locked: %d, owner: %s", exit, exits[exit]->key,
                exits[exit]->difficulty, exits[exit]->closed,
                exits[exit]->locked, owner);
#endif
    }
  }
}
void setup_doors() {
  string exit;
  object door;
  string other, other_id;
#ifdef DEBUG2
  debug_log("Setup doors called.");
#endif
  if(!this_object()->query_exits()) {
    this_object()->calc_exits();
  }
  if(!exits || !sizeof(exits)) {
    if(!this_object()->query_exits()) {
#ifdef DEBUG2
      debug_log("Leaving setup_doors, No exits to setup.");
#endif
    } else if(query_inventory_loaded()) {
#ifdef DEBUG
      debug_log("Leaving setup_doors, exits not setup %O, autoloading: %d "
                "inventory loaded: %d.",
                exits, query_auto_loading(), query_inventory_loaded());
#endif
    }
    return;
  }
  foreach(exit in keys(exits)) {
    door = query_door_control(exit);
    if(!door) {
      if(!query_exit(exit)) {
        map_delete(exits, exit);
      }
      continue;
    }
    if(!owner)
      catch(owner = HOUSING->query_owner(base_name(this_object())));
#ifdef DEBUG2
      if(exit == "out")
        debug_log("Setting up %s: key: %s, difficulty: %d, closed: %d, "
                  "locked: %d, owner: %s", exit, exits[exit]->key,
                  exits[exit]->difficulty, exits[exit]->closed,
                  exits[exit]->locked, owner);
#endif
      modify_exit(exit, ({ "key", exits[exit]->key,
                             "difficulty", exits[exit]->difficulty,
                             "closed", exits[exit]->closed,
                             "locked", exits[exit]->locked,
                             "autolock", exits[exit]->autolock,
                             "lock owner", owner,
                             }));
      if(exits[exit]->trap_data && arrayp(exits[exit]->trap_data)) {
        door->setup_trap(exits[exit]->trap_data[0],
                         exits[exit]->trap_data[1],
                         exits[exit]->trap_data[2],
                         exits[exit]->trap_data[3],
                         exits[exit]->trap_data[4]);
        if(exits[exit]->trap_data[5])
          door->set_trap_armed(1);
      }
    other = door->query_dest();
    other_id = door->query_other_id();
#ifdef NO_SLOW_LOAD
    if(!find_object(other) && exit != "out")
      continue;
#endif
    if(!other_id) {
      door->force_other();
      other_id = door->query_other_id();
    }
    if(!other_id) {
#ifdef DEBUG2
      debug_log("No other_id, adding call_out.");
#endif
      if(!_setup_callout) {
        _setup_callout = call_out("setup_doors", 0);
        return;
      }
    }
    other->modify_exit(other_id, ({ "key", exits[exit]->key,
                                      "difficulty", exits[exit]->difficulty,
                                      "closed", exits[exit]->closed,
                                      "locked", exits[exit]->locked,
                                      "autolock", exits[exit]->autolock,
                                      "lock owner", owner,
                                      }));
    if(exits[exit]->trap_data && arrayp(exits[exit]->trap_data)) {
      door = other->query_door_control(other_id);
      if(door && objectp(door)) {
        door->setup_trap(exits[exit]->trap_data[0],
                         exits[exit]->trap_data[1],
                         exits[exit]->trap_data[2],
                         exits[exit]->trap_data[3],
                         exits[exit]->trap_data[4]);
        if(exits[exit]->trap_data[5])
          door->set_trap_armed();
      }
    }
  }
  done_setup = 1;
}
string query_owner() {
  if(owner)
    return owner;
  return HOUSING->query_owner(base_name(this_object()));
}
string set_owner(string who) { owner = who; }
int add_allowed(string pname) {
  if(test_occupier(pname))
    return 0;
  allowed += ({ pname });
  event(this_object(), "save");
  return 0;
}
int remove_allowed(string pname) {
  if(!test_occupier(pname))
    return 0;
  allowed -= ({ pname });
  event(this_object(), "save");
  return 1;
}
int test_occupier(string name) {
  if(!owner)
    catch(owner = HOUSING->query_owner(base_name(this_object())));
  if(!owner || lower_case(owner) == "for sale" ||
     lower_case(owner) == "under offer")
    return 1;
  if(PLAYER_HANDLER->test_creator(name))
    return 1;
  if(!allowed)
    allowed = ({ });
  return (owner == name || (member_array(name, allowed) != -1));
}
int ownership_change(string old_owner, string new_owner) {
  if(old_owner != new_owner) {
    owner = new_owner;
    allowed = ({ });
    return 1;
  }
  return 0;
}
string *query_allowed() {
   if (allowed) {
     return allowed;
   }
   return ({ });
}
int is_allowed(string name) {
  if((query_owner() && (lower_case(name) == lower_case(query_owner()))) ||
     (member_array(lower_case(name), query_allowed()) != -1) ||
     PLAYER_HANDLER->test_creator(name)) {
    return 1;
  }
   return 0;
}
void dest_me() {
#ifdef NOT_USED
  if (base_name(this_object()) + ".c" != __FILE__)
    update_doors();
#endif
  ::dest_me();
}
void event_open(object door, object opener) {
#ifdef DEBUG2
  debug_log("door opened by %s [%d]", opener->query_name(), done_setup);
#endif
  if(done_setup) {
    ::event_open(door, opener);
    update_doors();
  }
}
void event_close(object door, object closer) {
#ifdef DEBUG2
    debug_log("door closed by %s [%d]", closer->query_name(), done_setup);
#endif
  if(done_setup) {
    ::event_close(door, closer);
    update_doors();
  }
}
void event_unlock(object door, object unlocker) {
#ifdef DEBUG2
  debug_log("door unlocked by %s [%d]",
            unlocker?unlocker->query_name():"noone", done_setup);
#endif
  if(done_setup) {
    ::event_unlock(door, unlocker);
    update_doors();
  }
}
void event_lock(object door, object locker) {
#ifdef DEBUG2
  debug_log("door locked by %s [%d]", locker?locker->query_name():"noone",
            done_setup);
#endif
  if(done_setup) {
    ::event_lock(door, locker);
    update_doors();
  }
}

==================================================
FILE: room/inherit/punishment_inherit.c
==================================================

#define NOMIC_SYSTEM_CASE_CLASSES
#include <nomic_system.h>
#include <nroff.h>
private nosave string _short;
private nosave string _mail_information;
private nosave string _desc_file;
void create() {
   _mail_information = "";
   this_object()->setup();
}
void set_short(string short) {
   _short = short;
}
void set_description_file(string str) {
   _desc_file = str;
}
string query_description_file() {
   return _desc_file;
}
void set_mail_information(string mail) {
   _mail_information = mail;
}
string query_short(string area, class nomic_case the_case, string type, mixed data) {
   return _short;
}
string query_description(string area, string type) {
   string str;
   if (_desc_file) {
      str = unguarded( (: NROFF_HAND->cat_file(_desc_file+"_nroff", 1) :) );
      if (!str) {
         unguarded( (: NROFF_HAND->create_nroff(_desc_file, _desc_file+"_nroff") :) );
         str = unguarded( (: NROFF_HAND->cat_file(_desc_file+"_nroff", 1) :) );
      }
      if (str) {
         return str;
      }
   }
   return "Nothing particularly special.\n";
}
void start_punishment(string area, class nomic_case the_case, string type, function finish) {
   evaluate(finish, the_case, type, 0);
}
void complete_punishement(string area, class nomic_case the_case, string type, mixed data) {
   return ;
}
void suspend_punishment(string area, class nomic_case the_case, string type, mixed data) {
   return ;
}
string query_mail_information(string area, class nomic_case the_case,
                              string type, mixed data) {
   return _mail_information;
}

==================================================
FILE: room/inherit/room_rental.c
==================================================

#include <room/room_rental.h>
string *query_exits();
int check_entry( object player_ob, object room_ob ) {
  return ROOM_RENTAL_HANDLER->check_tenant( player_ob, room_ob );
}
string query_costume_mess( object costume ) {
  return "The imp takes the " + costume->query_short() + ".\n";
}
void evict_tenant( object* tenants ) {
  string exit = query_exits()[0];
  foreach (object person in tenants) {
     tell_object( person, "You hear the soft tinkling of a bell.  As the "
               "sound resounds throughout the room it shatters your "
               "illusions.  A small imp hurries into the room and gently but "
               "firmly propels you outside the door.\n" );
  }
  tenants->move_with_look( exit, "$N appears from $F as though he's been "
                                "pushed in rather abruptly.\n" );
}
void event_exit( object ob, string message, object to ) {
  object *costumes;
  costumes = filter( deep_inventory( ob ),
                     (: $1->query_property( "costume" ) :) );
  foreach( object costume in costumes )
    costume->move( "/room/rubbish", query_costume_mess( costume ) );
}

==================================================
FILE: room/inherit/room_rental_office.c
==================================================

#include <money.h>
#include <room/room_rental.h>
private string _location;
private string _domain;
int do_rental( string room );
int add_room( string room, int cost );
int delete_room( string room );
int clear_rooms();
void set_domain( string dom ) {
  _domain = dom;
}
string query_domain() {
  return _domain;
}
void set_location( string loc ) {
  _location = loc;
}
string query_location() {
  return _location;
}
void create() {
  set_location( "default" );
  set_domain( "default" );
}
void init() {
  add_command( "list", "[rooms]" );
  add_command( "rent", "<string'room'>",
               (: do_rental( $4[0] ) :) );
  if ( this_player()->query_creator() ) {
    add_command( "add", "<string> for <number>",
                 (: add_room( $4[0], $4[1] ) :) );
    add_command( "remove", "<string>", (: delete_room( $4[0] ) :) );
  }
}
string query_list() {
   string room;
   string list = "";
   string tenant;
   object room_ob;
   object office_ob = this_object();
   tell_creator( "goldenthread", "getting list for %s ( %O )\n",
                 office_ob->short(), office_ob );
   foreach( room in ROOM_RENTAL_HANDLER->query_rooms_to_rent( office_ob ) ) {
      tenant = ROOM_RENTAL_HANDLER->query_who_rents( room, office_ob );
      tell_creator( "goldenthread", "found %s\n", room );
      if ( room_ob = load_object( room ) ) {
         list += room_ob->query_short();
         if ( tenant != "nobody" )
            list += " (rented by " + tenant + ")\n";
         else
            list += " (available for " + MONEY_HAND->money_value_string(
               to_int( ROOM_RENTAL_HANDLER->query_rental_value( room ) ),
               _domain ) + ")\n";
      }
   }
   if ( list != "")
      list = "/global/events"->convert_message(list) + "\n";
   else
      list = "There are no rooms available here.\n";
   return list;
}
int do_list() {
  string list = "Here are the rooms available to rent in " + _location
                + ":\n\n";
  this_player()->add_succeeded_mess( this_object(), "$N ask$s for a list "
                                     "of available rooms.\n", ({ }) );
  list += query_list();
  tell_object( this_player(), list );
  return 1;
}
int add_room( string room, int cost ) {
  if ( ROOM_RENTAL_HANDLER->add_room( room, cost, this_object() ) ) {
    this_player()->add_succeeded_mess( this_object(),
                   ({ "$N $V a room.\n", "" }), ({ }) );
    return 1;
  }
  this_player()->add_failed_mess( this_object(),
                                  "That room cannot be added.\n", ({ }) );
  return 0;
}
int delete_room( string room ) {
  if( ROOM_RENTAL_HANDLER->delete_room( room, this_object() ) ) {
    this_player()->add_succeeded_mess( this_object(),
                   ({ "$N $V a room.\n", "" }), ({ }) );
    return 1;
  }
  return 0;
}
int clear_rooms() {
  if( ROOM_RENTAL_HANDLER->clear_rooms( this_object() ) ) {
    this_player()->add_succeeded_mess( this_object(),
                   ({ "$N $V the list of rooms.\n", "" }), ({ }) );
    return 1;
  }
  return 0;
}
int do_rental( string room ) {
  object ob = this_player();
  int ret = ROOM_RENTAL_HANDLER->do_rental( ob, room, this_object() );
  switch( ret ) {
    case RENTAL_SUCCESS:
      ob->pay_money( MONEY_HAND->create_money_array(
          ROOM_RENTAL_HANDLER->query_rental_value( room ), query_domain() ),
          query_domain() );
      ob->add_succeeded_mess( this_object(), ({ "$N $V a room.\n", "" }),
                              ({ }) );
      return 1;
    case RENTAL_NO_SUCH_ROOM:
      ob->add_failed_mess( this_object(), "There is no such room here.\n",
                           ({ }) );
      return 0;
    case RENTAL_ALREADY_RENTED:
      ob->add_failed_mess( this_object(), "The room has already been rented.\n",
                           ({ }) );
      return 0;
    case RENTAL_NO_MONEY:
      ob->add_failed_mess( this_object(), "You don't have enough money for "
                           "that.\n", ({ }) );
      return 0;
    default:
      ob->add_failed_mess( this_object(), "Something has gone wrong.  Please "
                           "contact a creator.\n", ({ }) );
      return 0;
  }
}
void init_dynamic_arg( mapping map, object ob ) {
   _domain = map[ "domain" ];
   _location = map[ "location" ];
}
mapping query_dynamic_auto_load( void ) {
   return ([ "domain" : _domain,
           "location" : _location, ]);
}

==================================================
FILE: room/inherit/room_save.c
==================================================

#include <move_failures.h>
#include <player.h>
inherit "/global/auto_load";
#define SAVE_TIME 10
#if 0
#undef AUTO_LOAD_OB
#define AUTO_LOAD_OB "/global/auto_load_debug"
#endif
varargs void set_save_file( string file, object thing );
varargs void do_load(object thing);
mapping query_dynamic_auto_load();
void init_dynamic_arg(mapping bing);
private mapping details;
private nosave string _save_file, _ram_file;
private nosave object _effects;
private nosave int _inventory_loaded;
private nosave int _last_saved;
private nosave int _door_opened, _door_unlocked;
#ifdef DEBUG_SAVE
void debug_log(string fmt, mixed args ...) {
    debug_printf(fmt + "\n", args ...);
#ifdef DISABLED
  if(base_name(this_object()) == "/d/cwc/Bes_Pelargic/Shoo_Li/roads/pang_ho_street/housing/03flat") {
    log_file("HOUSING_DEBUG", "%s (%s): " + fmt + "\n",
             ctime(time())[4..18], base_name(this_object()), args ...);
  }
#endif
}
#endif
void create() {
   _save_file = "";
   details = ([ ]);
   _last_saved = time();
}
void set_save_file( string file) {
#ifdef USE_RAMDISK
  string *bits, fname;
  int i;
#endif
  _save_file = file;
#ifdef USE_RAMDISK
  if(strsrch(_save_file, "/save/player_housing") != -1) {
    _ram_file = replace_string(_save_file, "/save/player_housing",
                               "/save/ramdisk/player_housing");
    fname = "";
    bits = explode(_ram_file, "/");
    for(i=0; i<sizeof(bits)-1; i++) {
      fname += "/" + bits[i];
      if(file_size(fname) == -1) {
        debug_printf("Creating %s", fname);
        mkdir(fname);
      }
    }
  }
#endif
  do_load();
}
int test_save(object ob) { return 1; }
string query_save_file() {
   return _save_file;
}
void event_save(object thing) {
  if(!thing || !_inventory_loaded || !_save_file || _save_file == "") {
    if(find_call_out("do_save") != -1)
      remove_call_out("do_save");
    return;
  }
  if(thing == this_object() || base_name(thing) == "/std/room/basic/door" ||
     test_save(thing)) {
    if (find_call_out("do_save") == -1)
      call_out("do_save", SAVE_TIME);
  }
}
void door_action() {
  if(_door_opened || _door_unlocked) {
    event_save(this_object());
#ifdef DEBUG_SAVE
    debug_log("saving opened %d unlocked %d", _door_opened,
        _door_unlocked);
  } else {
    debug_log("not saving %s door has returned "
        "to original state.\n", base_name(this_object()));
#endif
  }
  _door_opened = 0;
  _door_unlocked = 0;
}
void event_open(object door, object opener) {
  _door_opened++;
  if(find_call_out("door_action") != -1)
    remove_call_out("door_action");
  call_out("door_action", 5);
}
void event_close(object door, object closer) {
  _door_opened--;
  if(find_call_out("door_action") != -1)
    remove_call_out("door_action");
  call_out("door_action", 5);
}
void event_unlock(object door, object unlocker) {
  debug_printf("Event unlock called %O", door);
  _door_unlocked++;
  if(find_call_out("door_action") != -1)
    remove_call_out("door_action");
  call_out("door_action", 5);
}
void event_lock(object door, object locker) {
  debug_printf("Event lock called %O", door);
  _door_unlocked--;
  if(find_call_out("door_action") != -1)
    remove_call_out("door_action");
  call_out("door_action", 5);
}
void do_save() {
  int saved;
#ifdef DEBUG_SAVE
  object ob;
#endif
  remove_call_out("do_save");
  if(!_save_file || _save_file == "") {
#ifdef DEBUG_SAVE
    log_file("ROOM_SAVE", "%s no save file for %s\n", ctime(time())[4..18],
             base_name(this_object()));
#endif
    return;
  }
  details = ([ ]);
  details = query_dynamic_auto_load();
#ifdef USE_RAMDISK
  if(_ram_file)
    saved = unguarded((: save_object, _ram_file, 3 :));
  else
#endif
    saved = unguarded((: save_object, _save_file, 3 :));
#ifdef DEBUG_SAVE
  if (saved) {
    log_file("HOUSING_DEBUG",
             "%s %s saved.\n", ctime(time())[4..18],
             base_name(this_object()));
  } else {
    log_file("HOUSING_DEBUG",
             "%s %s failed to save.\n", ctime(time())[4..18],
             base_name(this_object()));
  }
#endif
#ifdef DEBUG_INVENTORY
  foreach(ob in all_inventory(this_object())) {
    if(test_save(ob))
      log_file(base_name(this_object()) + ".log",
               "%s %s contained %d items.\n", ctime(time())[4..18],
               ob->query_short(), sizeof(deep_inventory(ob)));
  }
#endif
  _last_saved = time();
}
void do_load( object thing ) {
  mapping tmp;
  string fname;
  if(_save_file) {
    if(_ram_file &&
       (file_size(_ram_file + ".o.gz") > 0 || file_size(_ram_file + ".o") > 0))
      fname = _ram_file;
    else
      fname = _save_file;
    if(file_size(fname + ".o.gz") > 0 || file_size(fname + ".o") > 0) {
      tmp = this_object()->query_properties();
      unguarded((: restore_object, fname :));
      this_object()->set_properties(tmp);
      if ( sizeof( details ) ) {
        init_dynamic_arg( details );
      } else {
        _inventory_loaded = 1;
      }
    } else {
      _inventory_loaded = 1;
    }
  }
  _last_saved = time();
  remove_call_out("do_save");
  remove_call_out("door_action");
  _door_opened = 0;
  _door_unlocked = 0;
}
int test_remove(object thing, int flag, mixed dest) {
  if(test_save(thing))
    event(this_object(), "save", thing);
  return 1;
}
int test_add( object ob, int flag) {
  if(!query_auto_loading() && test_save(ob))
    event(this_object(), "save", ob);
  return 1;
}
int query_prevent_insert() { return 1; }
mapping query_dynamic_auto_load() {
  mapping map;
  string *obs;
  map = ([ ]);
#ifdef DISABLED
  if ( _effects ) {
    if ( sizeof( (mixed *)_effects->query_effs() ) ) {
      _effects->effect_freeze();
      _effects->effects_saving();
      map += ([
               "effects" : ({
                 (mixed *)_effects->query_effs(),
                 (int *)_effects->query_eeq()
               })
      ]);
      _effects->effect_unfreeze();
    }
  }
#endif
  obs = filter(all_inventory(this_object()), "test_save");
  catch(obs = AUTO_LOAD_OB->create_auto_load( obs, 0 ) );
  map["inv"] = obs;
  return map;
}
private int move_to_dest(object ob) {
   if (base_name(ob) == PLAYER_RECEIPT) {
      ob->reset_get();
   }
   return ob->move(this_object());
}
void init_dynamic_arg( mapping bing ) {
#ifdef DEBUG_INVENTORY
  object ob;
  log_file(base_name(this_object()) + ".log",
           "%s Loading.\n", ctime(time())[4..18]);
#endif
  if ( !mapp( bing ) ) {
#ifdef DEBUG_INVENTORY
  log_file(base_name(this_object()) + ".log",
           "%s no mapping to load.\n", ctime(time())[4..18]);
#endif
    return;
  }
  if ( bing[ "effects" ] ) {
    _effects->set_effs( bing[ "effects" ][ 0 ] );
    _effects->set_eeq( bing[ "effects" ][ 1 ] );
    if ( environment() && shadow( this_object(), 0 ) )
       move_object( environment() );
    _effects->init_after_save();
  }
#ifdef DEBUG_INVENTORY
  log_file(base_name(this_object()) + ".log",
           "%s done effects.\n", ctime(time())[4..18]);
#endif
  if ( bing[ "inv" ] && !_inventory_loaded) {
#ifdef DEBUG_INVENTORY
  log_file(base_name(this_object()) + ".log",
           "%s starting inventory.\n", ctime(time())[4..18]);
#endif
    AUTO_LOAD_OB->load_auto_load_to_inventory( bing["inv"], this_object(),
                                               this_player(),
                                               (: move_to_dest($1) :) );
    _inventory_loaded = 1;
  } else {
#ifdef DEBUG_INVENTORY
  log_file(base_name(this_object()) + ".log",
           "%s inventory_loaded already set.\n", ctime(time())[4..18]);
#endif
  }
#ifdef DEBUG_INVENTORY
  log_file(base_name(this_object()) + ".log",
           "%s done inventory.\n", ctime(time())[4..18]);
  foreach(ob in all_inventory(this_object())) {
    if(test_save(ob))
      log_file(base_name(this_object()) + ".log",
               "%s %s contains %d items.\n", ctime(time())[4..18],
               ob->query_short(), sizeof(deep_inventory(ob)));
  }
  if(!sizeof(all_inventory(this_object())))
    log_file(base_name(this_object()) + ".log",
             "%s room has no inventory.\n", ctime(time())[4..18]);
#endif
}
void check_euid() {
  if ( previous_object() ) {
    seteuid( geteuid( previous_object() ) );
  }
}
int query_keep_room_loaded() { return 1; }
void dest_me() {
  if(find_call_out("do_save") != -1)
    do_save();
}
int query_inventory_loaded() { return _inventory_loaded; }

==================================================
FILE: room/inherit/scripting.c
==================================================

#include <expressions.h>
#include "nroff.h";
inherit "/std/basic/expressions";
#define SCRIPTING_WAIT_COMMAND  1
#define SCRIPTING_COMMAND       2
#define SCRIPTING_EXPRESSION    3
#define SCRIPTING_GOTO          4
#define SCRIPTING_TRIGGER_EVENT 5
class script_data {
   int type;
   string actor;
   string str;
   class parse_node* expr;
   int number;
}
class script {
   string* valid_actors;
   class script_data* data;
   int priority;
}
class running_script {
   class script script;
   int position;
   object who;
   string who_name;
   string who_short;
   int run_priority;
}
private mapping _script_data;
private nosave int _callout_tag;
private nosave class running_script* _running_scripts;
object find_npc( string what );
int is_allowed( string name );
void event_save( object ob );
class script query_script( string name ){
   return _script_data[name];
}
private void add_running_script(class running_script script) {
   if (!sizeof(_running_scripts)) {
      _running_scripts += ({ script });
      return ;
   }
}
void trigger_script( string event, object who, int override ){
   int i;
   class script this_script;
   class running_script running;
   this_script = query_script( event );
   if (!this_script || !objectp(who)) {
      return;
   }
   running = new(class running_script);
   running->script = this_script;
   running->who = who;
   running->position = 0;
   running->who_name = who->query_name();
   running->who_short = who->the_short();
   if (undefinedp(override)) {
      running->run_priority = this_script->priority;
   } else {
      running->run_priority = override;
   }
   add_running_script(running);
}
void repeat_loop() {
   object npc;
   class script_data data;
   string str;
   class parse_node node;
   if (!sizeof( _running_scripts ) ) {
      return;
   }
   if (_running_scripts[0]->position >= sizeof(_running_scripts[0]->script)) {
      _running_scripts = _running_scripts[1..];
      if (!sizeof( _running_scripts ) ) {
         return;
      }
   }
   data = _running_scripts[0]->script->data[_running_scripts[0]->position];
   _running_scripts[0]->position++;
   _callout_tag = call_out( "repeat_loop", 2);
   switch ( data->type) {
   case SCRIPTING_WAIT_COMMAND :
      remove_call_out(_callout_tag);
      _callout_tag = call_out( "repeat_loop",  data->number);
      return;
   case SCRIPTING_COMMAND :
      npc = find_npc( data->actor );
      if( !npc ){
         repeat_loop();
         return;
      }
      npc->do_command( data->str );
      break;
   case SCRIPTING_EXPRESSION :
      node = evaluate_expresion(data->expr);
      if (node->type == EXPRESSION_TYPE_STRING) {
         npc = find_npc( data->actor );
         if (!npc) {
            repeat_loop();
            return ;
         }
         npc->do_command( data-> str );
      }
      break;
   case SCRIPTING_GOTO :
      _running_script[0]->position = data->number;
      break;
   case SCRIPTING_TRIGGER_EVENT :
      trigger_script(data->name, _running_script[0]->npc,
                     _running_script[0]->run_priority | PRIORITY_FRONT);
      break;
   }
   call_out("repeat_loop");
}
void set_script(string name, class script script) {
   _script_data[name] = script;
   event_save(this_object());
}
void set_script_data(string name, class script_data* data) {
   if (_script_data[name]) {
      _script_data[name]->data = data;
      event_save(this_object());
   }
}
void set_script_actors(string name, string* actors) {
   if (_script_data[name]) {
      _script_data[name]->actors = actors;
      event_save(this_object());
   }
}
int set_script_data_location(string name, int pos, class script_data data) {
   if (_script_data[name] &&
       pos >= 0 && pos < sizeof(_script_data[name]->data)) {
      _script_data[name]->data[pos] = data;
      event_save(this_object());
      return 1;
   }
   return 0;
}
int delete_script_data_location(string name, int pos) {
   if (_script_data[name] &&
       pos >= 0 && pos < sizeof(_script_data[name]->data)) {
      _script_data[name]->data = _script_data[name]->data[0..pos-1] +
                                 _script_data[name]->data[pos+1..];
      event_save(this_object());
      return 1;
   }
   return 0;
}
int insert_script_data_before(string name, int pos, class script_data data) {
   if (_script_data[name]) {
      _script_data[name]->data = _script_data[name]->data[0..pos-1] +
                                 ({ data }) +
                                 _script_data[name]->data[pos..];
      event_save(this_object());
      return 1;
   }
   return 0;
}
void menu_prompt(string name, class* script) {
   tell_object( this_player(), "Enter the name of the person who should "
      "perform an action ( or another command such as \"wait\" ).\n" );
   print_commands();
   input_to( "menu_input", 0, name, script );
}
private int query_pos_from_string(string str) {
   if (bits[2] == "begining") {
      return 0;
   } else if (bits[2] == "end") {
      return sizeof(script->data);
   } else {
      pos = to_int(bits[2]);
   }
   if (pos < 0 || pos > sizeof(script->data)) {
      return -1;
   }
   return pos;
}
void menu_input( string input, string name, class script script ){
   string* bits;
   bits = explode(lower_case(input), " ");
   switch (lower_case(bits[0])) {
   case "h" :
   case "help" :
      show_help();
      break;
   case "s" :
   case "save" :
      set_script(name, script);
      break;
   case "q" :
   case "quit" :
      write("Are you sure you want to quit and "
         "lose the current script?\n" );
      input_to( "check_quit", 0, name, script );
      return ;
   case "l" :
   case "list" :
      write(query_script_string(script));
      break;
   case "a" :
   case "add" :
      if (sizeof(bits) != 3) {
         write("Syntax: add <person> <pos|end|begining>\n");
      } else if (lower_case(bits[1]) != "wait" &&
                 member_array(bits[1], script->actors) == -1) {
         write("The actor must be one of " +
               query_multiple_short(script->actors)  + " not " +
               bits[1] + ".\n");
      } else {
         pos = query_pos_from_string(bits[2]);
         if (pos != -1) {
            write("Which command do you want to execute for " + bits[1] +
                  "?\n: ");
            input_to("enter_command", 0, name, script, bits[1], pos);
         } else {
            write("The position must be in the range 0.." +
                  sizeof(script->data) + " or 'begining' or 'end'.\n");
         }
      }
      break;
   case "d" :
   case "delete" :
      if (sizeof(bits) != 2) {
         write("Syntax: delete <pos|end|begining>\n");
      } else {
         pos = query_pos_from_string(bits[2]);
         if (pos != -1) {
         } else {
            write("The position must be in the range 0.." +
                  sizeof(script->data) + " or 'begining' or 'end'.\n");
         }
      }
      break;
   default :
      write("Invalid command " + bits[1] + ".\n");
   }
   menu_prompt(name, script);
}
protected void enter_command( string input, string name, class script script ) {
   if( _temp_script->script[sizeof( _temp_script->script ) - 1] == "wait" ){
      if( !to_int(input) ){
         tell_object( this_player(), "%^BOLD%^For the wait command you "
            "must enter a whole value for the number of seconds "
            "to wait%^RESET%^.\n" );
         prompt_command();
         return;
      }
   }
   _temp_script->script = _temp_script->script + ({input});
   tell_object( this_player(), "Enter the name of the person who should "
      "perform an action ( or another command such as \"wait\" ).\n" );
   print_commands();
   input_to( "input_name" );
}
void print_commands(){
   tell_object( this_player(), "Command [ h for help ]:\n" );
}
void show_help(){
   string str;
   str = unguarded((: NROFF_HAND->cat_file("/doc/room/scripting_nroff", 1) :));
   if(!str){
     unguarded((: NROFF_HAND->create_nroff(PATH +"scripting_online_help",
        PATH +"scripting_nroff") :));
     str = unguarded((:NROFF_HAND->cat_file(PATH +"scripting_nroff", 0):));
   }
   write(str);
}
void query_quit( string input, string func ){
   if( (input == "y") || (input == "yes") || (input == "Y") ){
      write("Okay, quitting.\n" );
   }else{
      write("%^BOLD%^You did not enter \"y\" "
         "or \"yes\" so you are not being quitted.%^RESET%^\n" );
      call_other( this_object(), func );
   }
}
void set_script(string name, class scripting* script) {
   write("Saving current script and exiting.\n" );
   _scripts[name] = script;
   event_save( this_object() );
}
string query_script_string( class scripting* script ){
   int i;
   string str;
   if( _temp_script->tag == "" ) {
      return;
   }
   str = "\nScript name \""+ _temp_script->tag + ":\n\n";
   for( i = 0; i < sizeof(_temp_script->script); i++ ){
      str += _temp_script->script[i]->name +"  :  ";
      str += _temp_script->script[i]->action +"\n";
   }
   str += "\n";
   return str;
}
void query_delete( string input, int num ){
   if( (input == "y") || (input == "yes") || (input == "Y") ){
      tell_object( this_player(), "Okay, removing script.\n" );
      if( sizeof(_script_data) == 1 ){
         _script_data = ({});
      }else if( sizeof(_script_data) == 2 ){
         _script_data = ({_script_data[!num]});
      }else{
         if( !num ){
            _script_data = _script_data[1..];
         }else{
            _script_data = _script_data[0..(num - 1)] +
               _script_data[(num + 1)..];
         }
      }
      event_save( this_object() );
   }else{
      tell_object( this_player(), "%^BOLD%^You did not enter \"y\" or "
         "\"yes\" so the script will not be deleted.%^RESET%^\n" );
   }
   _temp_script->tag = "";
   _temp_script->script = ({});
}
int get_index( mixed input ){
   int i;
   if( to_int( input ) ){
      i = to_int( input );
      if( i > sizeof(_script_data) ){
         tell_object( this_player(), "Invalid option, quitting.\n" );
         return -1;
      }else{
         return i - 1;
      }
   }else{
      for( i = 0; i < sizeof(_script_data); i++ ){
         if( _script_data[i]->tag == input ) return i;
      }
      tell_object( this_player(), "Invalid option, quitting.\n" );
      return -1;
   }
}
void edit_script( string input, int which ){
   string *comm, command, text;
   int line, i;
   if( input == "" ){
      input_to( "edit_script", 0, which );
      tell_object( this_player(), "Command [ R(eplace), D(elete), "
         "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" );
      return;
   }
   command = "";
   line = -1;
   text = "";
   comm = explode( input, " " );
   if( sizeof(comm) ) command = comm[0];
   if( sizeof(comm) > 1) line = to_int(comm[1]) - 1;
   if( sizeof(comm) > 2){
      comm = comm[2..];
      text = implode(comm, " ");
   }
   switch (command){
      case "s" :
      case "S" :
         tell_object( this_player(), "Done editing script.\n" );
         _script_data[which]->script = _temp_script->script;
         return;
      case "q" :
      case "Q" :
         tell_object( this_player(), "Quitting without saving changes.\n");
         return;
      case "v" :
      case "V" :
         for( i = 0; i < sizeof(_temp_script->script); i++ )
            tell_object(this_player(),(i+1) +"  "+
               _temp_script->script[i] +"\n");
            input_to( "edit_script", 0, which );
            tell_object( this_player(), "Command [ R(eplace), D(elete), "
               "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" );
            return;
      case "d" :
      case "D" :
         if( (line < 0) || ((line +1) > sizeof(_temp_script->script)) ){
            tell_object( this_player(), "For this command you need to "
               "enter a valid line number.\n" );
            input_to( "edit_script", 0, which );
            tell_object( this_player(), "Command [ R(eplace), D(elete), "
               "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n");
            return;
         }
         if( sizeof(_temp_script->script) == 1 ){
            _temp_script->script = ({});
         }else if( sizeof(_temp_script->script) == 2 ){
            _temp_script->script = ({_temp_script->script[!line]});
         }else{
            _temp_script->script = _temp_script->script[0..(line-1)] +
                _temp_script->script[line+1..];
         }
         tell_object( this_player(), "Line "+ (line+1) +" deleted.  "
            "Please note that the line numbers for the rest of the "
            "script may have been effected by this change.\n" );
         input_to( "edit_script", 0, which );
         tell_object( this_player(), "Command [ R(eplace), D(elete), "
            "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" );
         return;
      case "r" :
      case "R" :
         if( (line < 0) || ((line +1) > sizeof(_temp_script->script)) ){
            tell_object( this_player(), "For this command you need to "
               "enter a valid line number.\n" );
            input_to( "edit_script", 0, which );
            tell_object( this_player(), "Command [ R(eplace), D(elete), "
               "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" );
            return;
         }
         tell_object( this_player(), "Replacing line "+ (line+1) +" with \""+
            text +"\".\n" );
         _temp_script->script[line] = text;
         input_to( "edit_script", 0, which );
         tell_object( this_player(), "Command [ R(eplace), D(elete), "
            "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" );
         return;
      case "i" :
      case "I" :
         if( (line < 0) || ((line +1) > sizeof(_temp_script->script)) ){
            tell_object( this_player(), "For this command you need to "
               "enter a valid line number.\n" );
            input_to( "edit_script", 0, which );
            tell_object( this_player(), "Command [ R(eplace), D(elete), "
               "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" );
            return;
         }
         tell_object( this_player(), "Inserting \""+ text +"\" at line "+
            (line+1) +".  Please note that the line numbers for the rest "
            "of the script may have been effected by this change.\n" );
         if( !line ){
            _temp_script->script = ({text}) + _temp_script->script;
         }else{
            _temp_script->script = _temp_script->script[0..(line-1)] +
               ({text}) + _temp_script->script[line..];
         }
         input_to( "edit_script", 0, which );
         tell_object( this_player(), "Command [ R(eplace), D(elete), "
            "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" );
         return;
      default :
         tell_object( this_player(),"%^BOLD%^Unknown command.\n%^RESET%^");
         input_to( "edit_script", 0, which );
         tell_object( this_player(), "Command [ R(eplace), D(elete), "
            "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" );
         return;
   }
}
int do_add_script( string input ){
   if( input == "" ){
      tell_object( this_player(),
         "You must enter a name for the script.\n" );
      add_succeeded_mess( "" );
      return 1;
   }
   if( return_script( input ) != ({}) ){
      tell_object( this_player(), "%^BOLD%^There is already a script for \""+
         input +"\", if you wish to keep the existing version then quit "
         "now and start over, if you continue the new version will "
         "replace the old one.%^RESET%^\n" );
   }else{
      tell_object( this_player(), "This script will be known as \""+
         input +"\".\n" );
   }
   _temp_script = new(class fancy_hat, tag : input, script : ({}) );
    tell_object( this_player(), "Enter the name of the person who should "
      "perform an action, or another command such as \"wait\". eg\n\n"
      "  \"mike\"\n"
      "  \"thug1\"\n"
      "  \"wait\"\n" );
   print_commands();
   input_to( "input_name" );
   add_succeeded_mess( "$N begin$s to write a new script.\n" );
   return 1;
}
int do_list_scripts(){
   int i;
   if( !sizeof(_script_data) ){
      this_player()->add_failed_mess( this_object(),
         "No scripts found.\n" );
      return 0;
   }
   tell_object(this_player(), sizeof(_script_data) +" scripts found:\n\n");
   for( i = 0; i < sizeof(_script_data); i++ )
      tell_object( this_player(), (i +1) +"  "+ _script_data[i]->tag +"\n");
   add_succeeded_mess( "" );
   return 1;
}
int do_view_script( mixed input ){
   int num;
   num = get_index( input );
   if( num == -1 ){
      add_succeeded_mess( "" );
      return 1;
   }
   if( undefinedp( _temp_script ) ){
      _temp_script = new( class fancy_hat,
      tag : _script_data[num]->tag, script : _script_data[num]->script );
   }else{
      _temp_script->tag = _script_data[num]->tag;
      _temp_script->script = _script_data[num]->script;
   }
   view_script(1);
   add_succeeded_mess( "" );
   return 1;
}
int do_test_script( mixed input ){
   int num;
   num = get_index( input );
   if( num == -1 ){
      add_succeeded_mess( "" );
      return 1;
   }
   tell_object( this_player(), "Triggering event \""+
      _script_data[num]->tag +"\".\n" );
   trigger_thingy( _script_data[num]->tag, file_name( this_player()) );
   add_succeeded_mess( "" );
   return 1;
}
int do_delete_script( mixed input ){
   int num;
   num = get_index( input );
   if( num == -1 ){
      add_succeeded_mess( "" );
      return 1;
   }
   if( undefinedp( _temp_script ) ){
      _temp_script = new( class fancy_hat,
      tag : _script_data[num]->tag, script : _script_data[num]->script );
   }else{
      _temp_script->tag = _script_data[num]->tag;
      _temp_script->script = _script_data[num]->script;
   }
   tell_object( this_player(), "Are you sure that you want to "
      "permanently remove the script \""+ _temp_script->tag +"\"?\n" );
   input_to( "query_delete", 0, num );
   add_succeeded_mess( "" );
   return 1;
}
int do_edit_script( mixed input ){
   int num, i;
   num = get_index( input );
   if( num == -1 ){
      add_succeeded_mess( "" );
      return 1;
   }
   if( undefinedp( _temp_script ) ){
      _temp_script = new( class fancy_hat,
      tag : _script_data[num]->tag, script : _script_data[num]->script );
   }else{
      _temp_script->tag = _script_data[num]->tag;
      _temp_script->script = _script_data[num]->script;
   }
   tell_object( this_player(), "Editing script \""+ _temp_script->tag +
      "\".\n\nThis is a complete listing of the script:\n" );
   for( i = 0; i < sizeof(_temp_script->script); i++ ){
      tell_object(this_player(),(i+1) +"  "+ _temp_script->script[i] +"\n");
   }
   tell_object( this_player(), "Command [ R(eplace), D(elete), I(nsert), "
      "V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" );
   input_to( "edit_script", 0, num );
   add_succeeded_mess( "" );
   return 1;
}
void init(){
   if( !is_allowed( this_player()->query_name() ) ) {
      return;
   }
   add_command( "add",
      "script <string'name'>", (: do_add_script( $4[0] ) :) );
   add_command( "list", "scripts",
      (: do_list_scripts() :) );
   add_command( "view",
      "script <string'name'>", (: do_view_script( $4[0] ) :) );
   add_command( "view",
      "script <number>", (: do_view_script( $4[0] ) :) );
   add_command( "test",
      "script <string'name'>", (: do_test_script( $4[0] ) :) );
   add_command( "test", this_object(),
      "script <number>", (: do_test_script( $4[0] ) :) );
   add_command( "delete",
      "script <string'name'>", (: do_delete_script( $4[0] ) :) );
   add_command( "delete",
      "script <number>", (: do_delete_script( $4[0] ) :) );
   add_command( "edit",
      "script <string'name'>", (: do_edit_script( $4[0] ) :) );
   add_command( "edit",
      "script <number>", (: do_edit_script( $4[0] ) :) );
}

==================================================
FILE: room/inherit/terrain_map_room.c
==================================================

#include <room.h>
#include <login_handler.h>
private int     _x_coord = -1;
private int     _y_coord = -1;
private int     _installed = 0;
private string  _extra_long = "";
private object  _map_handler;
private mapping _features = ([ ]);
private string  _outside_types;
string query_feature_item_desc(string title);
int    do_gocoords(int x, int y);
void add_extra_look(object ob);
void setup_room_chat();
object query_chatter();
varargs void room_chat(mixed* args, object chatob);
void add_item(mixed type, mixed desc);
void remove_item(string name);
mixed *query_coords() { return ({ _x_coord, _y_coord }); }
void create()
{
   _x_coord = -1;
   _y_coord = -1;
}
void setup_room() {
   add_extra_look(this_object());
   setup_room_chat();
}
void set_coords(int x, int y)
{
   _x_coord = x;
   _y_coord = y;
}
void init()
{
   tell_creator(this_player(), "Coords: (%d, %d)\n", _x_coord, _y_coord);
   if (this_player()->query_creator()) {
      add_command("gocoords", "<number'x'> <number'y'>", (: do_gocoords($4[0], $4[1]) :));
   }
}
object query_map_handler()
{
   return _map_handler;
}
int    do_gocoords(int x, int y)
{
   object   room = query_map_handler()->load_room_at(x, y);
   string   msgin = this_player()->query_mmsgin();
   string   msgout = this_player()->query_mmsgout();
   if (!room) {
     this_player()->add_failed_mess(this_object(),
                           "No room at those coordinates.\n", ({ }));
     return 0;
   }
   msgin = replace(msgin, ({ "$N", this_player()->a_short() }) );
   msgout = replace(msgout, ({ "$N", this_player()->a_short() }) );
   if (!this_player()->move_with_look(room, msgin, msgout))
      add_succeeded_mess("Move attempt failed.\n");
   return 1;
}
void reset_handler()
{
   if (query_map_handler())
      query_map_handler()->reset_handler();
}
void receive_message(string mess_class, string message)
{
   string   *bits = explode(mess_class, ":");
   mapping  feature;
   int      range = -1;
   if (bits[0] == "feature") {
      feature = _features[bits[1]];
      if (!feature)
         return;
      if (sizeof(bits) >= 3)
         range = to_int(bits[2]);
         if ((range >= 0) && (range != feature["range"]))
            return;
      message = replace(message, ({ "$D", feature["direc"] }));
   }
   tell_creator("dek", "receive_message\n");
   tell_room(this_object(), message);
}
void do_a_feature_chat()
{
   string   *chats = ({ });
   string   feature_chat;
   string   title;
   mapping  feature;
   object   handler = query_map_handler();
   foreach(title, feature in _features) {
      feature_chat = handler->get_a_feature_chat(title, feature["range"],
                                                        feature["direc"]);
      if (feature_chat) {
         chats += ({ feature_chat });
      }
   }
   if (sizeof(chats)) {
      tell_room(this_object(), chats[random(sizeof(chats))] + "\n");
   }
}
void do_an_outside_chat()
{
   string chat = query_map_handler()->get_an_outside_chat(_outside_types);
   if (chat && strlen(chat))
      tell_room(this_object(), chat + "\n");
}
void set_map_handler(mixed handler)
{
   if (objectp(handler))
      _map_handler = handler;
   else
      _map_handler = load_object(handler);
}
int can_view_feature(string type)
{
   return 1;
}
int can_exit_to(string type)
{
   return 1;
}
int can_enter_from(string type)
{
   return 1;
}
int do_outside_chats()
{
   return 1;
}
varargs void setup_room_chat(mixed *args, object chatobj)
{
   if (do_outside_chats() && !query_chatter()) {
      room_chat(({ 60, 120, ({ "#do_a_feature_chat",
                                  "#do_an_outside_chat" }) }) );
   }
   call_out("make_chat", 10);
}
void make_chat()
{
  if (query_chatter()) {
     query_chatter()->make_chat();
  }
}
mixed *query_to_same(string type) { return 0; }
mixed *query_to_other(string type) { return 0; }
mixed *query_from_other(string type) { return 0; }
mixed *get_to_same(string from, string to, string type)
{
   mixed *result = query_to_same(type);
   if (arrayp(result))
      return map(result, (: replace($1, ({ "$T", $2, "$F", $3 }) ) :), to, from);
   return 0;
}
mixed *get_to_other(string from, string to, string type)
{
   mixed *result = query_to_other(type);
   if (arrayp(result))
      return map(result, (: replace($1, ({ "$T", $2, "$F", $3 }) ) :), to, from);
   return 0;
}
mixed *get_from_other(string from, string to, string type)
{
   mixed *result = query_from_other(type);
   if (arrayp(result))
      return map(result, (: replace($1, ({ "$T", $2, "$F", $3 }) ) :), to, from);
   return 0;
}
void set_extra_long(string extra)
{
   _extra_long = extra;
}
void set_outside_types(string types)
{
   _outside_types = types;
}
string extra_look()
{
   string   result = _extra_long;
   string   title;
   mapping  feature;
   foreach (title, feature in _features) {
      result += query_map_handler()->query_feature_desc(title, feature["range"],
                                    feature["direc"]) + "\n";
   }
   return result;
}
mixed query_room(string room_path)
{
   string   *bits = explode(room_path, ":");
   object   room;
   object   handler;
   if (sizeof(bits) < 3)
      return room_path;
   room = load_object(bits[0]);
   handler = room->query_map_handler();
   return handler->query_room(room_path);
}
void add_feature(string title, string direc, int range, mixed items)
{
   _features[title] = (["direc":direc, "range":range, "items":items]);
   add_item(items, (: query_feature_item_desc($(title)) :));
}
void remove_feature(string title)
{
   mapping  feature = _features[title];
   mixed    items;
   if (!feature)
      return;
   map_delete(_features, title);
   items = feature["items"];
   if (stringp(items))
      remove_item(items);
   else
      remove_item(items[0]);
}
int query_feature_range(string title)
{
   mapping   feature = _features[title];
   if (!feature)
      return -1;
   return feature["range"];
}
string query_feature_item_desc(string title)
{
   return query_map_handler()->query_feature_item_desc(title);
}
mapping query_features() { return _features; }
void login_restore( string name, string l_event)
{
   object player;
   string path = explode(file_name(this_object()), "#")[0];
   int    *coords, x, y;
   if (l_event != LOGIN)
      return;
   player = find_player(name);
   if (!player)
      return;
   coords = player->query_property("area_map_coords");
   player->remove_property("area_map_coords");
   if (!coords)
      return;
   x = coords[0];
   y = coords[1];
   LOGIN_HANDLER->remove_static_login_call(name, "login_restore", path);
   player->move(query_map_handler()->load_room_at(x, y));
}
void event_quit(object player)
{
   string name;
   string path = explode(file_name(this_object()), "#")[0];
   if (!player)
      return;
   if (!interactive(player))
      return;
   if ((_x_coord < 0) || (_y_coord < 0))
      return;
   name = player->query_name();
   player->add_property("area_map_coords", query_coords());
   LOGIN_HANDLER->add_static_login_call(name, "login_restore", path);
}
int query_installed() { return _installed; }
void set_installed() { _installed = 1; }

==================================================
FILE: room/inherit/voting_room.c
==================================================

#include <board.h>
#define DEFAULT_VOTE_DURATION (2600*24*7)
class vote {
  string type;
  string desc;
  string *choices;
  mixed *votes;
  int ending;
  string *voted;
}
class election {
  mixed *candidates;
  int closes;
}
private int vote_counter;
private mapping votes;
private mapping elections;
private nosave string _vote_file;
private nosave mixed _vote_cond;
private nosave mixed _comp_action;
private nosave int _vote_duration;
private nosave int _open_voting;
private nosave int _no_elections;
private nosave string _proxy;
private nosave mixed _stand_cond;
private nosave mixed _second_cond;
private nosave mixed _election_announcement;
int list_votes();
int cast_vote( string words, int num );
int stand_for_election(string position);
int second_candidate(string who, string position);
int list_elections();
int do_create_vote(string choices);
void create() {
  seteuid("Room");
  votes = ([ ]);
  elections = ([ ]);
}
void init() {
   add_command("vote", "<string> on <number>", (: cast_vote($4[0], $4[1]) :) );
   add_command("list", "votes", (: list_votes :));
   add_command("votes", "", (: list_votes :));
   if (!_no_elections) {
      add_command( "stand", "[for] <string>", (: stand_for_election($4[0]) :));
      add_command( "second", "<string> [for] <string>",
                   (: second_candidate($4[0], $4[1]) :) );
      add_command("list", "elections", (: list_elections :));
      add_command("elections", "", (: list_elections :));
   }
}
protected mapping query_our_votes() {
   if (_proxy) {
      return _proxy->query_votes();
   }
   if (votes) {
      return votes;
   }
   return ([ ]);
}
protected void add_our_vote(int id, class vote data) {
   if (!votes) {
      votes = ([ ]);
   }
   votes[id] = data;
}
protected mapping query_our_elections() {
   if (_proxy) {
      return _proxy->query_elections();
   }
   if (elections) {
      return elections;
   }
   return ([ ]);
}
protected void add_our_election(string name, class election data) {
   if (!elections) {
      elections = ([ ]);
   }
   elections[name] = data;
}
void init_add_vote() {
   add_command( "add", "vote with <string'choices'>",
               (: do_create_vote($4[0]) :));
}
void setup_after_load() {
  int i;
  string election;
  int *vote_ids;
  if (_proxy) {
    return ;
  }
  vote_ids = m_indices( query_our_votes() );
  for ( i = 0; i < sizeof( vote_ids ); i++ ) {
    if ( query_our_votes()[ vote_ids[ i ] ]->ending < time() ) {
      call_out( "end_vote", 10 * ( i + 1 ), vote_ids[ i ] );
    } else {
      call_out( "end_vote", query_our_votes()[ vote_ids[ i ] ]->ending - time(),
                vote_ids[ i ] );
    }
  }
  foreach(election in keys(query_our_elections())) {
    if(query_our_elections()[election]->closes < time()) {
      call_out( "start_election_vote", 30 * random(5), election);
    } else {
      call_out( "start_election_vote", query_our_elections()[election]->closes - time(),
                election);
    }
  }
}
void set_save_file(string file) {
  _vote_file = file;
  if( file_size( _vote_file + ".o" ) > 0 ) {
    unguarded( (: restore_object, _vote_file :) );
    setup_after_load();
  } else {
    elections = ([ ]);
    votes = ([ ]);
  }
}
string query_save_file() { return _vote_file; }
protected void save_room() {
   if (_vote_file) {
      unguarded( (: save_object, _vote_file :) );
   }
}
void set_proxy(string proxy) {
   _proxy = proxy;
}
void set_no_elections(int no_elections) {
   _no_elections = no_elections;
}
void set_open_voting(int open) {
   _open_voting = open;
}
int query_open_voting(int open) {
   return _open_voting;
}
void set_vote_conditions(mixed cond) { _vote_cond = cond; }
void set_completion_action(mixed cond) { _comp_action = cond; }
void set_vote_duration(int duration) { _vote_duration = duration; }
int query_vote_duration() {
   if (!_vote_duration) {
      return DEFAULT_VOTE_DURATION;
   }
   return _vote_duration;
}
void set_stand_conditions(mixed cond) { _stand_cond = cond; }
void set_second_conditions(mixed cond) { _second_cond = cond; }
void set_election_announcement(string board, string person, string subject,
                               string prefix, string suffix) {
  _election_announcement = ({ board, person, subject, prefix, suffix });
}
int cast_vote( string which_str, int vote_id ) {
  string pname;
  int which, ok;
  class vote this_vote;
  if (_proxy) {
     return _proxy->cast_vote(which_str, vote_id);
  }
  if ( undefinedp(query_our_votes()[vote_id])) {
    add_failed_mess("There is no vote " + vote_id + ".\n");
    return 0;
  }
  this_vote = query_our_votes()[vote_id];
  which = member_array(which_str, this_vote->choices);
  if (which == -1) {
    if(strlen(which_str) > 1) {
      add_failed_mess("There is no choice " + which_str + " for vote id " +
           vote_id + ".\n");
      return 0;
    }
     which = upper_case( which_str )[ 0 ] - 65;
  }
  if(which < 0 || which > sizeof(this_vote->choices) -1) {
    add_failed_mess("There is no choice " + which_str + " for vote id " +
                           vote_id + ".\n");
    return 0;
  }
  ok = 1;
  if (functionp(_vote_cond)) {
    ok = evaluate(_vote_cond, this_player(), this_vote->desc);
  }
  if(arrayp(_vote_cond)) {
    ok = call_other(_vote_cond[0], _vote_cond[1], this_player(), this_vote->desc);
  }
  if(!intp(ok)) {
    ok = 0;
  }
  if(!ok) {
    add_failed_mess("Sorry, but you are not allowed to vote on this "
                       "subject.\n");
    return 0;
  }
  pname = this_player()->query_name();
  if(member_array(pname, this_vote->voted) != -1) {
    add_succeeded_mess(({"You have already voted on this subject.\n", ""}));
    return 1;
  }
  this_vote->voted += ({ pname });
  if (_open_voting) {
     this_vote->votes[which] += ({ pname });
  } else {
     if (arrayp(this_vote->votes[which])) {
        this_vote->votes[which] = sizeof(this_vote->votes[which]);
     }
     this_vote->votes[which]++;
  }
  save_room();
  add_succeeded_mess(({ "You cast your vote for "+which_str + " on " +
                        vote_id+".\n",
                        "$N casts a vote.\n" }));
  return 1;
}
int list_votes() {
  int i, j, *vote_ids;
  string text;
  class vote this_vote;
  if ( !m_sizeof( query_our_votes() ) ) {
    write( "There are no votes in progress.\n" );
    return 1;
  }
  vote_ids = m_indices( query_our_votes() );
  if ( sizeof( vote_ids ) > 1 )
    write( "The following votes are in progress:\n" );
  else
    write( "The following vote is in progress:\n" );
  text = "";
  for ( i = 0; i < sizeof( vote_ids ); i++ ) {
    this_vote = query_our_votes()[vote_ids[i]];
    text += "  "+ vote_ids[i] + ". " + this_vote->desc +"\n Choices are :\n";
    for(j=0; j<sizeof(this_vote->choices); j++) {
      text += sprintf("    %c. %s\n", 'A'+j, this_vote->choices[j]);
    }
    text += " Voting closes at "+ ctime( this_vote->ending ) +".\n\n";
  }
  this_player()->more_string(sprintf( "%-=*s",
                                      (int)this_player()->query_cols(),
                                      text ));
  return 1;
}
void add_vote(string type, string description, string *choices, int ending) {
  class vote new_vote;
  if (_proxy) {
     return _proxy->add_vote(type, description, choices, ending);
  }
  vote_counter++;
  new_vote = new(class vote);
  new_vote->type = type;
  new_vote->desc = description;
  new_vote->choices = choices;
  if (_open_voting) {
    new_vote->votes = allocate(sizeof(choices), (: ({ }) :));
  } else {
    new_vote->votes = allocate(sizeof(choices));
  }
  if(ending) {
    new_vote->ending = ending;
  } else if(_vote_duration) {
    new_vote->ending = (_vote_duration + time());
  } else {
    new_vote->ending = (DEFAULT_VOTE_DURATION + time());
  }
  new_vote->voted = ({ });
  add_our_vote(vote_counter, new_vote);
  call_out( "end_vote", new_vote->ending - time(), vote_counter );
  save_room();
}
mapping query_votes() { return query_our_votes() + ([ ]); }
mapping query_elections() { return query_our_elections() + ([ ]); }
void end_vote( int which ) {
  if ( !query_our_votes()[ which ] ) {
      return;
  }
  if(functionp(_comp_action)) {
      evaluate(_comp_action, query_our_votes()[which]->type, query_our_votes()[which]->desc,
               query_our_votes()[which]->choices, query_our_votes()[which]->votes,
               query_our_votes()[which]->voted);
  } else if(arrayp(_comp_action)) {
    call_other(_comp_action[0], _comp_action[1], query_our_votes()[which]->type,
               query_our_votes()[which]->desc, query_our_votes()[which]->choices, query_our_votes()[which]->votes,
               query_our_votes()[which]->voted);
  }
  map_delete(query_our_votes(), which);
  save_room();
}
void make_announcement(string board, string name, string subject,
                       string message ) {
  BOARD_HAND->add_message(board, name, subject,
                          sprintf( "%-=*s", 64, message));
}
void initiate_election(string position) {
  class election tmp;
  if (_proxy) {
     return _proxy->initiate_election(position);
  }
  if(query_our_elections()[position])
    return;
  tmp = new(class election);
  tmp->candidates = ({});
  if(_vote_duration) {
    tmp->closes = time() + _vote_duration;
  } else {
    tmp->closes = time() + DEFAULT_VOTE_DURATION;
  }
  add_our_election(position, tmp);
  call_out("start_election_vote", tmp->closes + 60, position);
  save_room();
}
int query_election_in_progress(string position) {
   if (classp(query_our_elections()[position])) {
       return 1;
   }
   return 0;
}
int stand_for_election(string position) {
  int ok, i;
  if (_proxy) {
     return _proxy->stand_for_election(position);
  }
  ok = 1;
  if(functionp(_stand_cond)) {
    ok = evaluate(_stand_cond, this_player(), position);
  } else if(arrayp(_stand_cond)) {
    ok = call_other(_stand_cond[0], _stand_cond[1], this_player(), position);
  }
  if(!intp(ok))
    ok = 0;
  if(!ok) {
    add_succeeded_mess(({ "Sorry, but you are not allowed to stand for this "
                            "election.\n", ""}));
    return 1;
  }
  if(!query_our_elections()[position]) {
    add_succeeded_mess(({"There is no election in progress for the post of " +
                    position + ".\n", ""}));
    return 1;
  }
  for(i=0; i<sizeof(query_our_elections()[position]->candidates); i++) {
    if(query_our_elections()[position]->candidates[i][0] == this_player()->query_name()) {
      add_succeeded_mess(({"You are already standing in this "
                             "election.\n", ""}));
      return 1;
    }
  }
  query_our_elections()[position]->candidates += ({({ this_player()->query_name(), "" })});
  save_room();
  add_succeeded_mess(({"You have been added to the list of candidates for "
                         "the position of " + position + ".  You must now "
                         "find someone to second your candidacy.\n",
                         "$N stands for election.\n"}));
  return 1;
}
int second_candidate(string who, string position) {
  mixed *candidates;
  int i, found, ok;
  if (_proxy) {
     return _proxy->second_candidate(who, position);
  }
  ok = 1;
  if(functionp(_second_cond)) {
    ok = evaluate(_second_cond, this_player(), position);
  } else if(arrayp(_second_cond)) {
    ok = call_other(_second_cond[0], _second_cond[1], this_player(), position);
  }
  if(!intp(ok))
    ok = 0;
  if(!ok) {
    add_succeeded_mess(({"Sorry, but you are not allowed to second candidates "
                           "in this election.\n", ""}));
    return 1;
  }
  if(!query_our_elections()[position]) {
    add_succeeded_mess(({"There is no election in progress for " + position +
                           ".\n", ""}));
    return 1;
  }
  candidates = (query_our_elections()[position])->candidates;
  for(i=0; i< sizeof(candidates); i++) {
    if(candidates[i][0] == who)
      found = i+1;
  }
  if(!found) {
    add_succeeded_mess(({who + " is not standing for the position of " +
                           position + ".\n", ""}));
    return 1;
  }
  if(this_player()->query_name() == who) {
    add_succeeded_mess(({"You cannot second yourself.\n", ""}));
    return 1;
  }
  if(candidates[found-1][1] != "") {
    add_succeeded_mess(({candidates[found-1][0] +
                           " has already been seconded by " +
                           candidates[found-1][1] + ".\n", ""}));
    return 1;
  }
  candidates[found-1][1] = this_player()->query_name();
  save_room();
  add_succeeded_mess(({candidates[found-1][0] +
                         " has been seconded in the election for "+
                         position+".\n", ""}));
  return 1;
}
void start_election_vote(string post) {
  string str, *choices;
  int i;
  if(!query_our_elections()[post])
    return;
  if(_election_announcement[3])
    str = _election_announcement[3];
  else
    str = "All eligible persons are requested to vote for the position of ";
  str += post + "\n\nThe candidates are:\n";
  choices = ({ });
  for(i=0; i<sizeof(query_our_elections()[post]->candidates); i++) {
    if(query_our_elections()[post]->candidates[i][1] != "") {
      str += sprintf("  %s seconded by %s.\n",
                     query_our_elections()[post]->candidates[i][0],
                     query_our_elections()[post]->candidates[i][1]);
      choices += ({ query_our_elections()[post]->candidates[i][0] });
    }
  }
  if(!sizeof(choices)) {
    str = "In the election for the position of " + post +
      " no candidate stood for election therefore the election "
      "is null and void.\n";
  } else if(sizeof(choices) < 2) {
    str = "In the election for the position of " + post +
      " only one candidate stood for election therefore the election "
      "is null and void.\n";
  } else {
    if(_election_announcement[4])
      str += _election_announcement[4];
    add_vote("election", "Election for the post of " + post + "\n", choices,
             0);
  }
  make_announcement(_election_announcement[0], _election_announcement[1],
                    _election_announcement[2], str);
  map_delete(query_our_elections(), post);
  save_room();
}
int list_elections() {
  class election this_election;
  string *posts, text;
  int i, j;
  if ( !m_sizeof( query_our_elections() ) ) {
    write( "There are no elections in progress.\n" );
    return 1;
  }
  posts = m_indices( query_our_elections() );
  if ( sizeof( posts ) > 1 )
    write( "The following elections are in progress:\n" );
  else
    write( "The following election is in progress:\n" );
  text = "";
  for ( i = 0; i < sizeof( posts ); i++ ) {
    this_election = query_our_elections()[posts[i]];
    text += "  Election to the post of "+ posts[i] + ".\n";
    if(!sizeof(this_election->candidates)) {
      text += "  No candidates have declared yet.\n";
    } else {
      text += "    Current candidates are :\n";
      for(j=0; j<sizeof(this_election->candidates); j++) {
        if(this_election->candidates[j][1] != "")
          text += sprintf("    %c. %s seconded by %s.\n", 'A'+j,
                          this_election->candidates[j][0],
                          this_election->candidates[j][1]);
        else
          text += sprintf("    %c. %s not yet seconded.\n", 'A'+j,
                          this_election->candidates[j][0]);
      }
    }
    text += " Candidacies must be declared by "+
      ctime( this_election->closes ) +".\n\n";
  }
  this_player()->more_string(sprintf( "%-=*s",
                                      (int)this_player()->query_cols(),
                                      text ));
  return 1;
}
string strip_spaces(string str) {
   if (!strlen(str)) {
      return str;
   }
   while (str[0] == ' ') {
      str = str[1..];
   }
   if (!strlen(str)) {
      return str;
   }
   while (str[<1] == ' ') {
      str = str[0..<2];
   }
   return str;
}
int do_create_vote(string choices) {
   string* bits;
   bits = map(explode(choices, ","), (: strip_spaces($1) :)) - ({ "" });
   write("Choices: " + query_multiple_short(bits) + ".\n");
   write("What description would you like for your vote?\n");
   this_player()->do_edit("", "create_vote_desc", this_object(), 0, bits);
   add_succeeded_mess(({ "", "$N starts to create a new vote.\n" }));
   return 1;
}
void create_vote_desc(string str, string* choices) {
   if (!str) {
      write("Aborting.\n");
      return ;
   }
   write("Are you sure you wish to create a vote with a description of:\n" +
         str + "\nWith vote choices of " + query_multiple_short(choices) +
         ".\n");
   write("Please answer yes or no: ");
   input_to("create_vote_desc_confirm", 0, str, choices);
}
void create_vote_desc_confirm(string str, string desc, string* choices) {
   str = lower_case(str);
   if (!strlen(str) ||
       (str[0] != 'y' && str[0] != 'n' && str[0] != 'q')) {
      write("Please answer yes or no: ");
      input_to("create_vote_desc_confirm", 0, str, choices);
   }
   if (str[0] == 'q' || str[0] == 'n') {
      write("Ok, quitting.\n");
      return ;
   }
   add_vote("freeform", desc, choices, 0);
   write("Added in the vote.\n");
}
int delete_election(string election) {
  if(!query_our_elections()[election])
    return 0;
  map_delete(query_our_elections(), election);
  save_room();
  return 1;
}
int delete_vote(int vote_id) {
  if(!query_our_votes()[vote_id])
    return 0;
  map_delete(query_our_votes(), vote_id);
  save_room();
  return 1;
}

==================================================
FILE: room/inherit/topography/aroom.c
==================================================

#include <dirs.h>
#include <room.h>
private string _topo_handler;
private mapping _look_mess = ([ ]);
mapping dirs = ([
  "north": ({ 1, 0, 0 }), "south": ({ -1, 0, 0 }),
  "east": ({ 0, 1, 0 }), "west" : ({ 0, -1, 0 }),
  "northeast": ({ 1, 1, 0 }), "northwest": ({ 1, -1, 0 }),
  "southeast": ({ -1, 1, 0 }), "southwest": ({ -1, -1, 0 }),
  "up": ({ 0, 0, 1 }), "down": ({ 0, 0, -1 })
]);
int* query_co_ord();
mixed* query_dest_other(string direc);
int query_door_open(string direc);
int query_exit(string str);
void add_exit(string dir, string location, string type);
void set_area_handler(string s) { _topo_handler = s; }
void set_topo_handler(string s) { _topo_handler = s; }
string query_topo_handler() { return _topo_handler; }
void add_look_mess(mapping m) { _look_mess += m; }
mapping query_look_mess() { return _look_mess; }
mixed query_quit_handler() {
  string s;
  s = explode(file_name(environment(this_player())), "#")[0];
  return ({ s, query_co_ord() });
}
void enter(object player) {
  object new_room;
  if (sizeof(explode(file_name(this_object()), "#")) > 1) {
    return;
  }
  new_room = (_topo_handler)->find_room_at_coord(
                 player->query_saved_co_ords());
  if (!objectp(new_room)) {
    tell_creator("jeremy", "Couldn't find area room for %O at %O...\n",
                 player, player->query_saved_co_ords());
    player->move(player->query_start_pos());
    return;
  }
  tell_creator("jeremy", "Moving %O to %O...\n",
               player, new_room);
  player->move(new_room);
}
varargs mixed *query_dest_other( string direc, mixed* other_res) {
  object room;
  mixed ret;
  if (!stringp(direc)) {
    return other_res;
  }
  room = (_topo_handler)->find_room_at_exit(this_object(), dirs[direc],
                                           direc);
  if (!objectp(room)) {
    return 0;
  }
  ret = other_res;
  if (!sizeof(ret)) {
    return 0;
  }
  ret[ROOM_DEST] = file_name(room);
  return ret;
}
string query_look(string direc, string other_result) {
  int dark;
  string s;
  string direc_s;
  mixed dest;
  direc_s = direc;
  if (other_result) {
    return s;
  }
  s = _look_mess[direc_s];
  if (s) {
    return evaluate(s);
  }
  dest = query_dest_other(direc_s);
  if (!dest) {
    return 0;
  }
  dest = dest[ROOM_DEST];
  if (!dest) {
    return 0;
  }
  if (query_door_open(direc_s) != 0) {
    dest->force_load();
    this_player()->set_looked( find_object( dest ) );
    dark = (int)this_player()->check_dark((int)dest->query_light());
    s = (string)dest->long( 0, dark );
    if (s[<1] == '\n') {
      return s[0..<2];
    }
    return s;
  }
  return 0;
}
void add_topo_exits(string *other_exits, string other_types) {
  string s;
  foreach (s in other_exits) {
    if ((s == "compass4") || (s == "compass8")) {
      if (!query_exit("north")) {
        add_exit("north", "/topography", other_types);
      }
      if (!query_exit("south")) {
        add_exit("south", "/topography", other_types);
      }
      if (!query_exit("east")) {
        add_exit("east", "/topography", other_types);
      }
      if (!query_exit("west")) {
        add_exit("west", "/topography", other_types);
      }
      if (s == "compass8") {
        if (!query_exit("northeast")) {
          add_exit("northeast", "/topography", other_types);
        }
        if (!query_exit("northwest")) {
          add_exit("northwest", "/topography", other_types);
        }
        if (!query_exit("southeast")) {
          add_exit("southeast", "/topography", other_types);
        }
        if (!query_exit("southwest")) {
          add_exit("southwest", "/topography", other_types);
        }
      }
    } else {
      add_exit(s, "/topography", other_types);
    }
  }
}

==================================================
FILE: room/inherit/topography/iroom.c
==================================================

#include <dirs.h>
#include <room.h>
int *milestone_index;
string *milestone_dirs = ({ });
string iroom_handler;
mapping shorten = SHORTEN;
string topo_handler;
string motion_verb = "walk", exit_type = "road", short_mse;
string iroom_exit_mess = "$N $V$s away to the $T.";
string iroom_enter_mess = "$N $V$s in from the $F.";
string iroom_move_mess = "You $V a little to the $T.\n";
string *pass_mess = ({
  "You $V a long while.",
  "$N passes by heading $T.",
  "  On the way you pass $O.\n"
});
mixed other_exits = ({ });
string *other_types = ({ });
mapping look_mess = ([ ]);
mapping dirs = ([
  "north": ({ 1, 0, 0 }), "south": ({ -1, 0, 0 }),
  "east": ({ 0, 1, 0 }), "west" : ({ 0, -1, 0 }),
  "northeast": ({ 1, 1, 0 }), "northwest": ({ 1, -1, 0 }),
  "southeast": ({ -1, 1, 0 }), "southwest": ({ -1, -1, 0 }),
  "up": ({ 0, 0, 1 }), "down": ({ 0, 0, -1 })
]);
mapping opposites = ([
  "north": "south", "south": "north", "west": "east",
  "east": "west", "northeast": "southwest", "southwest": "northeast",
  "northwest": "southeast", "southeast": "northwest", "up": "down",
  "down": "up"
]);
void set_area_handler(string s) { topo_handler = s; }
void set_topo_handler(string s) { topo_handler = s; }
string query_topo_handler() { return topo_handler; }
void set_iroom_handler(string s) { iroom_handler = s; }
string query_iroom_handler() { return iroom_handler; }
void set_motion_verb(string s) { motion_verb = s; }
string query_motion_verb() { return motion_verb; }
void set_iroom_exit_mess(string s) { iroom_exit_mess = s; }
string query_iroom_exit_mess() { return iroom_exit_mess; }
void set_iroom_enter_mess(string s) { iroom_enter_mess = s; }
string query_iroom_enter_mess() { return iroom_enter_mess; }
void set_iroom_move_mess(string s) { iroom_move_mess = s; }
string query_iroom_move_mess() { return iroom_move_mess; }
void set_pass_mess(string *s) { pass_mess = s; }
string *query_pass_mess() { return pass_mess; }
void add_look_mess(mapping m) { look_mess += m; }
mapping query_look_mess() { return look_mess; }
void set_exit_type(string s) { exit_type = s; }
string query_exit_type() { return exit_type; }
void set_milestone_index(int *i) { milestone_index = i; }
int *query_milestone_index() { return milestone_index; }
void add_milestone_dir(string s) {
  int i;
  string ss, em, xm, mm;
  i = sizeof(milestone_dirs);
  milestone_dirs += ({ s });
  if (!(iroom_handler)->query_endpoint(milestone_index[0],
                                       milestone_index[1], i)) {
    modify_exit(s, ({ "function", "passing_mess" }) );
  }
  add_exit(motion_verb + " " + s, "interroom", "hidden");
  if (!undefinedp(shorten[s])) {
    ss = shorten[s];
    add_alias(motion_verb + " " + ss, motion_verb + " " + s);
  } else {
    ss = s;
  }
  remove_exit(motion_verb + " <" + short_mse + ">");
  if (!short_mse) {
    short_mse = ss;
  } else {
    short_mse += "/" + ss;
  }
  add_exit(motion_verb + " <" + short_mse + ">", "interroom", exit_type);
  em = replace(iroom_enter_mess, ({ "$V", motion_verb, "$T", s, "$F",
                              opposites[s] }));
  xm = replace(iroom_exit_mess, ({ "$V", motion_verb, "$T", s, "$F",
                              opposites[s] }));
  mm = replace(iroom_move_mess, ({ "$V", motion_verb, "$T", s, "$F",
                              opposites[s] }));
  modify_exit(motion_verb + " " + s, ({
    "exit mess", xm,
    "enter mess", em,
    "move mess", mm
  }));
}
string *query_milestone_dirs() { return milestone_dirs; }
int passing_mess(string dir, object ob, string special_mess) {
  int i;
  object *obs, passed;
  string mess1, mess2;
  i = member_array(dir, milestone_dirs);
  if (i < 0) {
    return 0;
  }
  obs = (iroom_handler)->query_irooms_inv(milestone_index[0],
                                          milestone_index[1], i);
  if (stringp(pass_mess[0])) {
    mess1 = replace(pass_mess[0], ({ "$V", motion_verb, "$T", dir, "$F",
                                       opposites[dir] }));
    if (stringp(pass_mess[2]) && sizeof(obs)) {
      mess1 += replace(pass_mess[2], "$O", query_multiple_short(obs));
    }
    mess1 += "\n";
    tell_object(ob, mess1);
  }
  if (stringp(pass_mess[1])) {
    mess2 = replace(pass_mess[1], ({ "$V", motion_verb, "$T", dir, "$F",
                                       opposites[dir], "$N", ob->a_short() }));
    foreach (passed in obs) {
      if (living(passed) && ob->query_visible(passed)) {
        tell_object(passed, mess2 + "\n");
      }
    }
  }
  return 1;
}
mixed query_quit_handler() {
  string s;
  s = explode(file_name(environment(this_player())), "#")[0];
  return ({ s, query_co_ord() });
}
void enter(object player) {
  object new_room;
  if (sizeof(explode(file_name(this_object()), "#")) > 1) {
    return;
  }
  new_room = (iroom_handler)->find_room_at_coord(
                 player->query_saved_co_ords());
  if (!objectp(new_room)) {
    tell_creator("jeremy", "Couldn't find iroom for %O at %O...\n",
                 player, player->query_saved_co_ords());
    player->move(player->query_start_pos());
    return;
  }
  tell_creator("jeremy", "Moving %O to %O...\n",
               player, new_room);
  player->move(new_room);
}
varargs mixed *query_dest_other( string direc ) {
  int i;
  string verb, rest, *words;
  object room;
  mixed ret;
  if (!stringp(direc)) {
    return ::query_dest_other(direc);
  }
  words = explode(direc, " ");
  verb = words[0];
  if (verb != motion_verb) {
    ret = ::query_dest_other(direc);
    if (!stringp(ret[ROOM_DEST]) || (ret[ROOM_DEST] == "/") ||
    (ret[ROOM_DEST] == "/terrain") || (ret[ROOM_DEST] == "/topography")) {
      room = (topo_handler)->find_room_at_exit(this_object(), dirs[direc],
                                               direc);
      if (!objectp(room)) {
        return 0;
      }
      ret[ROOM_DEST] = file_name(room);
    }
    return ret;
  }
  if (sizeof(words) < 2) {
    notify_fail(motion_verb + " which way?\n");
    return 0;
  }
  rest = implode(words[1..], " ");
  i = member_array(rest, milestone_dirs);
  if (i < 0) {
    notify_fail("You can't " + motion_verb + " that way.\n");
    return 0;
  }
  room = (iroom_handler)->find_room_at_index(milestone_index[0],
                                              milestone_index[1]+2*i-1);
  if (!objectp(room)) {
    return 0;
  }
  ret = ::query_dest_other(direc);
  if (!sizeof(ret)) {
    return 0;
  }
  ret[ROOM_DEST] = file_name(room);
  return ret;
}
string query_look(string direc) {
  int i, dark;
  string s, direc_s;
  mixed dest;
  direc_s = direc;
  i = member_array(direc_s, milestone_dirs);
  if (i >= 0) {
    direc_s = motion_verb + " " + direc_s;
  }
  if (s = ::query_look(direc_s)) {
    return s;
  }
  if (s = look_mess[direc_s]) {
    return evaluate(s);
  }
  dest = query_dest_other(direc_s);
  if (!dest) {
    return 0;
  }
  dest = dest[ROOM_DEST];
  if (!dest) {
    return 0;
  }
  if (query_door_open(direc_s) != 0) {
    dest->force_load();
    this_player()->set_looked( find_object( dest ) );
    dark = (int)this_player()->check_dark((int)dest->query_light());
    s = (string)dest->long( 0, dark );
    if (s[<1] == '\n') {
      return s[0..<2];
    }
    return s;
  }
  return 0;
}
void add_topo_exits(string *e, string type) {
  other_exits += ({ e });
  other_types += ({ type });
}
void add_topo_exits_int() {
  int i;
  string s;
  for (i = 0; i < sizeof(other_exits); i++) {
    foreach (s in other_exits[i]) {
      if ((s == "compass4") || (s == "compass8")) {
        if (!query_exit("north")) add_exit("north", "/topography",
                                           other_types[i]);
        if (!query_exit("south")) add_exit("south", "/topography",
                                           other_types[i]);
        if (!query_exit("east")) add_exit("east", "/topography",
                                          other_types[i]);
        if (!query_exit("west")) add_exit("west", "/topography",
                                          other_types[i]);
        if (s == "compass8") {
          if (!query_exit("northeast")) add_exit("northeast", "/topography",
                                                 other_types[i]);
          if (!query_exit("northwest")) add_exit("northwest", "/topography",
                                                 other_types[i]);
          if (!query_exit("southeast")) add_exit("southeast", "/topography",
                                                 other_types[i]);
          if (!query_exit("southwest")) add_exit("southwest", "/topography",
                                                 other_types[i]);
        }
      } else {
        add_exit(s, "/topography", other_types[i]);
      }
    }
  }
}

==================================================
FILE: room/inherit/topography/milestone.c
==================================================

#include <dirs.h>
#include <room.h>
mapping milestone_dirs = ([ ]);
mapping milestone_index = ([ ]);
mapping shorten = SHORTEN;
string topo_handler;
int *actual_room_size;
string motion_verb = "walk", short_mse;
string iroom_exit_mess = "$N $V$s away to the $T.";
string iroom_enter_mess = "$N $V$s in from the $F.";
string iroom_move_mess = "You $V a little to the $T.\n";
string *pass_mess = ({
  "You $V a long while.",
  "$N passes by heading $T.",
  "  On the way you pass $O.\n"
});
mixed other_exits = ({ });
string *other_types = ({ });
mapping look_mess = ([ ]);
mapping dirs = ([
  "north": ({ 1, 0, 0 }), "south": ({ -1, 0, 0 }),
  "east": ({ 0, 1, 0 }), "west" : ({ 0, -1, 0 }),
  "northeast": ({ 1, 1, 0 }), "northwest": ({ 1, -1, 0 }),
  "southeast": ({ -1, 1, 0 }), "southwest": ({ -1, -1, 0 }),
  "up": ({ 0, 0, 1 }), "down": ({ 0, 0, -1 })
]);
mapping opposites = ([
  "north": "south", "south": "north", "west": "east",
  "east": "west", "northeast": "southwest", "southwest": "northeast",
  "northwest": "southeast", "southeast": "northwest", "up": "down",
  "down": "up"
]);
void add_topo_exits_int();
void set_area_handler(string s) { topo_handler = s; }
void set_topo_handler(string s) { topo_handler = s; }
string query_topo_handler() { return topo_handler; }
void set_actual_room_size(int *s) { actual_room_size = copy(s); }
int *query_actual_room_size() { return actual_room_size; }
void set_motion_verb(string s) { motion_verb = s; }
string query_motion_verb() { return motion_verb; }
void set_iroom_exit_mess(string s) { iroom_exit_mess = s; }
string query_iroom_exit_mess() { return iroom_exit_mess; }
void set_iroom_enter_mess(string s) { iroom_enter_mess = s; }
string query_iroom_enter_mess() { return iroom_enter_mess; }
void set_iroom_move_mess(string s) { iroom_move_mess = s; }
string query_iroom_move_mess() { return iroom_move_mess; }
void set_pass_mess(string *s) { pass_mess = s; }
string *query_pass_mess() { return pass_mess; }
void add_look_mess(mapping m) { look_mess += m; }
mapping query_look_mess() { return look_mess; }
void add_milestone_dir(string handler, string dir) {
  if (undefinedp(milestone_dirs[handler])) {
    milestone_dirs[handler] = ({ dir });
  } else {
    milestone_dirs[handler] += ({ dir });
  }
}
mixed query(string s) { return fetch_variable(s); }
varargs void set_milestone_index(string handler, int index) {
  milestone_index[handler] = index;
}
void setup_milestone() {
  string handler;
  foreach (handler in keys(milestone_index)) {
    handler->setup_milestone(this_object());
  }
  add_topo_exits_int();
}
int add_milestone_exit(string s, string dest, string type) {
  string ss, em, xm, mm;
  add_exit(s, dest, type);
  add_exit(motion_verb + " " + s, "interroom", "hidden");
  if (!undefinedp(shorten[s])) {
    ss = shorten[s];
    add_alias(motion_verb + " " + ss, motion_verb + " " + s);
  } else {
    ss = s;
  }
  if (type != "hidden") {
    remove_exit(motion_verb + " <" + short_mse + ">");
    if (!short_mse) {
      short_mse = ss;
    } else {
      short_mse += "/" + ss;
    }
    add_exit(motion_verb + " <" + short_mse + ">", "interroom", type);
  }
  em = replace(iroom_enter_mess, ({ "$V", motion_verb, "$T", s, "$F",
                              opposites[s] }));
  xm = replace(iroom_exit_mess, ({ "$V", motion_verb, "$T", s, "$F",
                              opposites[s] }));
  mm = replace(iroom_move_mess, ({ "$V", motion_verb, "$T", s, "$F",
                              opposites[s] }));
  modify_exit(motion_verb + " " + s, ({
    "exit mess", "$N " + motion_verb + "$s away to the " + s + ".",
    "enter mess", "$N " + motion_verb + "$s in from the " + opposites[s] + ".",
    "move mess", "You " + motion_verb + " a little to the " + s + ".\n"
  }));
  return modify_exit(s, ({ "function", "passing_mess" }) );
}
int passing_mess(string dir, object ob, string special_mess) {
  int i;
  object *obs, passed;
  string mess1, mess2, handler;
  foreach (handler in keys(milestone_dirs)) {
    i = member_array(dir, milestone_dirs[handler]);
    if (i < 0) {
      continue;
    }
    obs = handler->query_irooms_inv(milestone_index[handler], -1, i);
    if (stringp(pass_mess[0])) {
      mess1 = replace(pass_mess[0], ({ "$V", motion_verb, "$T", dir, "$F",
                                         opposites[dir] }));
      if (stringp(pass_mess[2]) && sizeof(obs)) {
        mess1 += replace(pass_mess[2], "$O", query_multiple_short(obs));
      }
      mess1 += "\n";
      tell_object(ob, mess1);
    }
    if (stringp(pass_mess[1])) {
      mess2 = replace(pass_mess[1], ({ "$V", motion_verb, "$T", dir, "$F",
                                         opposites[dir], "$N",
                                         ob->a_short() }));
      foreach (passed in obs) {
        if (living(passed) && ob->query_visible(passed)) {
          tell_object(passed, mess2 + "\n");
        }
      }
    }
    return 1;
  }
  return 1;
}
varargs mixed *query_dest_other( string direc ) {
  int i;
  string verb, rest, *words, handler;
  object room;
  mixed ret;
  if (!stringp(direc)) {
    return ::query_dest_other(direc);
  }
  words = explode(direc, " ");
  verb = words[0];
  if (verb != motion_verb) {
    ret = ::query_dest_other(direc);
    if (!stringp(ret[ROOM_DEST]) || (ret[ROOM_DEST] == "/") ||
    (ret[ROOM_DEST] == "/terrain") || (ret[ROOM_DEST] == "/topography")) {
      room = (topo_handler)->find_room_at_exit(this_object(), dirs[direc],
                                               direc);
      if (!objectp(room)) {
        return 0;
      }
      ret[ROOM_DEST] = file_name(room);
    }
    return ret;
  }
  if (sizeof(words) < 2) {
    notify_fail(motion_verb + " which way?\n");
    return 0;
  }
  rest = implode(words[1..], " ");
  foreach (handler in keys(milestone_dirs)) {
    i = member_array(rest, milestone_dirs[handler]);
    if (i < 0) {
      continue;
    }
    if (i == 0) {
      room = handler->find_room_at_index(milestone_index[handler] - 1, -2);
    } else {
      room = handler->find_room_at_index(milestone_index[handler], 0);
    }
    if (!objectp(room)) {
      return 0;
    }
    ret = ::query_dest_other(direc);
    if (!sizeof(ret)) {
      return 0;
    }
    ret[ROOM_DEST] = file_name(room);
    return ret;
  }
  return 0;
}
string query_look(string direc) {
  int i, dark;
  string s, direc_s, h;
  mixed dest;
  direc_s = direc;
  foreach (h in keys(milestone_dirs)) {
    i = member_array(direc_s, milestone_dirs[h]);
    if (i >= 0) {
      direc_s = motion_verb + " " + direc_s;
      break;
    }
  }
  if (s = ::query_look(direc_s)) {
    return s;
  }
  if (s = look_mess[direc_s]) {
    return evaluate(s);
  }
  dest = query_dest_other(direc_s);
  if (!dest) {
    return 0;
  }
  dest = dest[ROOM_DEST];
  if (!dest) {
    return 0;
  }
  if (query_door_open(direc_s) != 0) {
    dest->force_load();
    this_player()->set_looked( find_object( dest ) );
    dark = (int)this_player()->check_dark((int)dest->query_light());
    s = (string)dest->long( 0, dark );
    if (s[<1] == '\n') {
      return s[0..<2];
    }
    return s;
  }
  return 0;
}
void add_topo_exits(string *e, string type) {
  other_exits += ({ e });
  other_types += ({ type });
}
void add_topo_exits_int() {
  int i;
  string s;
  for (i = 0; i < sizeof(other_exits); i++) {
    foreach (s in other_exits[i]) {
      if ((s == "compass4") || (s == "compass8")) {
        if (!query_exit("north")) add_exit("north", "/topography",
                                           other_types[i]);
        if (!query_exit("south")) add_exit("south", "/topography",
                                           other_types[i]);
        if (!query_exit("east")) add_exit("east", "/topography",
                                          other_types[i]);
        if (!query_exit("west")) add_exit("west", "/topography",
                                          other_types[i]);
        if (s == "compass8") {
          if (!query_exit("northeast")) add_exit("northeast", "/topography",
                                                 other_types[i]);
          if (!query_exit("northwest")) add_exit("northwest", "/topography",
                                                 other_types[i]);
          if (!query_exit("southeast")) add_exit("southeast", "/topography",
                                                 other_types[i]);
          if (!query_exit("southwest")) add_exit("southwest", "/topography",
                                                 other_types[i]);
        }
      } else {
        add_exit(s, "/topography", other_types[i]);
      }
    }
  }
}

==================================================
FILE: room/inherit/terrain_map/air_base.c
==================================================

#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>
inherit "/std/room/outside";
inherit TERRAIN_MAP_ROOM_BASE;
void create() {
   set_not_replaceable(1);
   terrain_room::create();
   outside::create();
}
void init() {
   terrain_room::init();
   outside::init();
}
varargs mixed* query_dest_other(string exit) {
   mixed* data;
   data = outside::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}
mixed* query_dest_dir(object thing) {
   mixed* data;
   data = outside::query_dest_dir(thing);
   return terrain_room::query_dest_dir(data);
}
mixed stats() {
   return outside::stats() + terrain_room::stats();
}

==================================================
FILE: room/inherit/terrain_map/distance_str.c
==================================================

#include <terrain_map.h>
private string query_distance_str_int(int dist, int show_one) {
   if (dist < 3) {
      if (dist > 1) {
         return query_num(dist) + " feet";
      } else if (show_one) {
         return "one foot";
      } else {
         return "foot";
      }
   } else if (dist < TERRAIN_MAP_HALF_MILE) {
      dist /= 3;
      if (dist > 50) {
         dist = dist / 50 * 50;
      }
      if (dist > 1) {
         return query_num(dist) + " yards";
      }
      if (show_one) {
         return "one yard";
      } else {
         return "yard";
      }
   } else if (dist < TERRAIN_MAP_ONE_MILE) {
      return "half mile";
   } else {
      dist /= TERRAIN_MAP_ONE_MILE;
      if (dist > 10) {
         dist = dist / 10 * 10;
      }
      if (dist > 100) {
         dist = dist / 50 * 50;
      }
       if (dist > 1000) {
         dist = dist / 500 * 500;
      }
      if (dist > 1) {
         return query_num(dist) + " miles";
      } else {
         if (show_one) {
            return "one mile";
         } else {
            return "mile";
         }
      }
   }
}
string query_distance_str(int dist) {
   return query_distance_str_int(dist, 1);
}
string query_distance_str_no_ones(int dist) {
   return query_distance_str_int(dist, 0);
}

==================================================
FILE: room/inherit/terrain_map/factory.c
==================================================

#include <terrain_map.h>
inherit TERRAIN_MAP_FACTORY_BASE;
void create() {
   ::create();
   this_object()->setup();
}

==================================================
FILE: room/inherit/terrain_map/factory_base.c
==================================================

#include <terrain_map.h>
private int _room_jump_size;
private int _follow_road;
private int _default_height;
private int _min_height;
private string _adjacent_desc;
private mapping _height_info;
private mapping _adjacent_items;
void create() {
   _adjacent_items = ([ ]);
}
void set_room_jump_size(int jump) {
   _room_jump_size = jump;
}
int query_room_jump_size() {
   return _room_jump_size;
}
void set_follow_road(int follow) {
  _follow_road = follow;
}
int query_follow_road() {
   return _follow_road;
}
void set_default_height(int height) {
   _default_height = height;
}
void set_adjacent_description(string desc) {
   _adjacent_desc = desc;
}
string query_adjacent_description() {
   return _adjacent_desc;
}
int query_default_height() {
   return _default_height;
}
void set_minimum_height(int height) {
   _min_height = height;
}
int query_minimum_height() {
   return _min_height;
}
void set_height_rooms(mapping map) {
   _height_info = map;
}
string find_base_terrain_room(int x, int y, int z, string base_name, int map_room, string ref base) {
   if (_height_info && _height_info[z]) {
      return _height_info[z];
   }
   if (z > _default_height) {
      if (map_room == TERRAIN_MAP_ROOM_CLIMB) {
         return 0;
      }
      if (map_room == TERRAIN_MAP_ROOM_EXACT) {
         return TERRAIN_MAP_DEFAULT_AIR_ROOM;
      }
      if (!_height_info) {
         return base_name;
      }
      return _height_info[_default_height];
   }
   if (!_height_info) {
      if (z == _default_height) {
         return base_name;
      }
      return 0;
   }
   if (_min_height > z) {
      return 0;
   }
   if (z == _default_height) {
      return base_name;
   }
   return _height_info["default"];
}
void add_adjacent_item(string name, string desc) {
   _adjacent_items[name] = desc;
}
mapping query_adjacent_items() {
   return _adjacent_items;
}
mixed stats() {
   return ({
  ({ "room jump", _room_jump_size }),
  ({ "follow road", _follow_road }),
  ({ "adjacent desc", _adjacent_desc }) });
}

==================================================
FILE: room/inherit/terrain_map/feature_base.c
==================================================

inherit "/std/room/inherit/terrain_map/distance_str";
private int _max_range;
private int _max_day_range;
private int _max_night_range;
private int _min_range = -1;
private int _range_offset;
private int _blocking;
private object _region;
class feature_pos {
   int xstart;
   int ystart;
   int width;
   int height;
}
void set_region(mixed region) {
   if (_region) {
      _region->dest_me();
   }
   if (stringp(region)) {
      _region = clone_object(region);
   } else if (objectp(region)) {
      _region = region;
   }
}
object query_region_ob() {
   return _region;
}
void set_range_offset(int offset) {
   _range_offset = offset;
}
int query_range_offset() {
   return _range_offset;
}
void set_max_day_range(int range) {
  _max_day_range = range;
   if (_max_day_range > _max_range) {
      _max_range = _max_day_range;
   }
}
int query_max_day_range() {
   return _max_day_range;
}
void set_max_night_range(int range) {
   _max_night_range = range;
   if (_max_night_range > _max_range) {
      _max_range = _max_night_range;
   }
}
int query_max_night_range() {
   return _max_night_range;
}
void set_min_range(int range) {
  _min_range = range;
}
int query_min_range() {
   return _min_range;
}
int query_max_range() {
   return _max_range;
}
int set_blocking(int blocking) {
   _blocking = blocking;
}
int query_blocking() {
   return _blocking;
}
string calc_feature_desc(mapping direc, int night, int visibility) {
   return "This needs to be set.";
}
mapping filter_distances(mapping direcs) {
   return filter(direcs, (: $2 <= _max_range :));
}
mapping query_feature_desc_from(int x, int y, int z, int no_filter) {
   mapping bits;
   if (_region) {
      bits = _region->query_feature_desc_from(x, y, z);
      if (bits) {
        if(no_filter)
          return bits;
        else
          return filter_distances(bits);
      }
   }
   return ([ ]);
}
int is_inside_region(int x1, int y1, int x2, int y2) {
   return _region->is_inside_region(x1, y1, x2, y2, query_max_range());
}
void dest_me() {
   if (_region) {
      _region->dest_me();
   }
   destruct(this_object());
}

==================================================
FILE: room/inherit/terrain_map/feature_local.c
==================================================

#include <terrain_map.h>
inherit TERRAIN_MAP_SIMPLE_FEATURE_BASE;
inherit "/std/basic/setup";
private string* _items;
private string* _night_descs;
private string* _day_descs;
void create() {
   _items = ({ });
   _night_descs = ({ });
   _day_descs = ({ });
   do_setup();
   do_reset();
}
void add_item(string item, string day, string night) {
   _items += ({ item });
   _night_descs += ({ night });
   _day_descs += ({ day });
}
string* query_items() {
   return _items;
}
string* query_day_items() {
   return _day_descs;
}
string* query_night_items() {
   return _night_descs;
}

==================================================
FILE: room/inherit/terrain_map/geometry.c
==================================================

class point {
   int x;
   int y;
}
#define SMALL_NUM 0.00001
class point intersection_of_line_and_segment(int lx1, int ly1, int lx2, int ly2,
                                             int sx1, int sy1, int sx2, int sy2) {
   float den;
   float uanum;
   float ubnum;
   float ua;
   float ub;
   class point p;
   den = to_float(sy2 - sy1) * to_float(lx2 - lx1) - to_float(sx2 - sx1) * to_float(ly2 - ly1);
   if (den == 0.0) {
      return 0;
   }
   ubnum = to_float(lx2 - lx1) * to_float(ly1 - sy1) - to_float(ly2 - ly1) * to_float(lx1 - sx1);
   ub = ubnum / den;
   if (ub < 0.0 || ub > 1.0) {
      return 0;
   }
   uanum = to_float(sx2 - sx1) * to_float(ly1 - sy1) - to_float(sy2 - sy1) * to_float(lx1 - sx1);
   ua = uanum / den;
   p = new(class point);
   p->x = lx1 + to_int(ua * (lx2 - lx1));
   p->y = ly1 + to_int(ub * (ly2 - ly1));
   return p;
}
int distance_point_to_line_segment(int x1, int y1, int x2, int y2,
                           int point_x, int point_y) {
   float v1_x;
   float v1_y;
   float v2_x;
   float v2_y;
   float distance;
   float dot1;
   float dot2;
   float b;
   float vm_x;
   float vm_y;
   v1_x = to_float(x1 - x2);
   v1_y = to_float(y1 - y2);
   v2_x = to_float(point_x - x2);
   v2_y = to_float(point_y - y2);
   dot1 = v1_x * v2_x + v1_y * v2_y;
   if (dot1 <= 0.0) {
      distance = sqrt(pow(x2 - point_x, 2) + pow(y2 - point_y, 2));
   } else {
      dot2 = v1_x * v1_x + v1_y * v1_y;
      if (dot2 <= dot1) {
         distance = sqrt(pow(x1 - point_x, 2) + pow(y1 - point_y, 2));
      } else {
         b = dot1 / dot2;
         vm_x = to_float(x2) + b * v1_x;
         vm_y = to_float(y2) + b * v1_y;
         distance = sqrt(pow(vm_x - point_x, 2) + pow(vm_y - point_y, 2));
      }
   }
   return to_int(distance);
}
int distance_between_two_line_segments(
     int x1_1, int y1_1, int x2_1, int y2_1,
     int x1_2, int y1_2, int x2_2, int y2_2) {
   float ux;
   float uy;
   float vx;
   float vy;
   float wx;
   float wy;
   float dpx;
   float dpy;
   float a;
   float b;
   float c;
   float d;
   float e;
   float dist;
   float sc;
   float sn;
   float sd;
   float tc;
   float tn;
   float td;
   ux = to_float(x2_1) - to_float(x1_1);
   uy = to_float(y2_1) - to_float(y1_1);
   vx = to_float(x2_2) - to_float(x1_2);
   vy = to_float(y2_2) - to_float(y1_2);
   wx = to_float(x1_1) - to_float(x1_2);
   wy = to_float(y1_1) - to_float(y1_2);
   a = ux * ux + uy * uy;
   b = ux * vx + uy * vy;
   c = vx * vx + vy * vy;
   d = ux * wx + uy * wy;
   e = vx * wx + vy * wy;
   dist = a * c - b * b;
   sd = dist;
   td = dist;
   if (dist < SMALL_NUM) {
      sn = 0.0;
      sd = 1.0;
      tn = e;
      td = c;
   } else {
      sn = b * e - c * d;
      tn = a * e - b * d;
      if (sn < 0.0) {
         sn = 0.0;
         tn = e;
         td = c;
      } else if (sn > sd) {
         sn = sd;
         tn = e + b;
         td = c;
      }
      if (tn < 0.0) {
         tn = 0.0;
         if (-d < 0.0) {
            sn = 0.0;
         } else if (-d > a) {
            sn = sd;
         } else {
            sn = -d;
            sd = a;
         }
      } else if (tn > td) {
         tn = td;
         if ((-d + b) < 0) {
            sn = 0.0;
         } else if ((-d + b) > a) {
            sn = sd;
         } else {
            sn = -d + b;
            sd  = a;
         }
      }
   }
   sc = sn / sd;
   tc = tn / td;
   dpx = wx + (sc * ux) - (tc * vx);
   dpy = wy + (sc * uy) - (tc * vy);
   dist = sqrt(dpx * dpx + dpy * dpy);
   if (dist > pow(2, 30)) {
      return to_int(pow(2, 30));
   }
   return to_int(sqrt(dpx  * dpx + dpy * dpy));
}

==================================================
FILE: room/inherit/terrain_map/handler_base.c
==================================================

#include <weather.h>
#include <terrain_map.h>
#include <player.h>
#define   AREA_OBSTACLE    0
#define   AREA_ROOM        1
#define   AREA_ROAD        2
#define   AREA_WORLD       3
#define   RANDOM_HANDLER   "/obj/handlers/random_num"
inherit "/std/room/inherit/terrain_map/distance_str";
#define X_DIFF 1
#define Y_DIFF 0
#define XY_DIFF 2
class char_map_data {
   string char;
   string colour;
   string path;
   string room_desc;
   mixed items;
   mixed item_desc;
   mixed chats;
   int type;
   int height;
   mapping height_rooms;
   int whole_sentance;
   string adjacent_desc;
   int room_jump;
   int room_jump_matching;
}
class feature_data {
   int range;
   string* descs;
   string* night_descs;
   mixed f_items;
   mixed f_item_desc;
   mixed f_item_night_desc;
   int whole_sentance;
   mixed chats;
   mixed night_chats;
   object feature_ob;
}
class sign_data {
   string long;
   string read_mess;
   string short;
   string name;
   string language;
}
class real_coords {
   int x1;
   int y1;
   int x2;
   int y2;
   int xdiff;
   int ydiff;
   int xydiff;
   int zdiff;
   int in_world_map;
}
private mixed     *_room_map = 0;
private mixed     *_area_map = 0;
private mixed     *_zone_map = 0;
private int       _visible_distance;
private int       _width = 0;
private int       _height = 0;
private int       _normal_skip_size = 1;
private int       _random_desc_limit = 2;
private int       _random_chat_limit = 4;
private int       _newline_mode = 1;
private mapping   _room_zones = ([ ]);
private mapping   _feature_rooms = ([ ]);
private mapping   _char_map = ([ ]);
private mapping   _zone_types = ([ ]);
private mapping   _features = ([ ]);
private mapping   _signposts = ([ ]);
private mapping   _standard_exits = ([ ]);
private mapping   _adjacent_terrains = ([ ]);
private mapping   _random_descs = ([ ]);
private mapping   _random_chats = ([ ]);
private class real_coords _real_coords;
private mapping _key = ([ ]);
private mapping   _direcs = ([ "north":     ({ 0, 1, "south", Y_DIFF, 0 }),
                       "northeast": ({ 1, 1, "southwest", XY_DIFF, ({ "obvious", 0 }) }),
                       "east":      ({ 1, 0, "west", X_DIFF, 0 }),
                       "southeast": ({ 1, -1, "northwest", XY_DIFF, ({ "obvious", 0 }) }),
                       "south":     ({ 0, -1, "north", Y_DIFF, 0 }),
                       "southwest": ({ -1, -1, "northeast", XY_DIFF, ({ "obvious", 0 }) }),
                       "west":      ({ -1, 0, "east", X_DIFF, 0 }),
                       "northwest": ({ -1, 1, "southeast", XY_DIFF, ({ "obvious", 0 }) }) ]);
private string* _direc_order = ({
                        "north", "east", "south", "west",
                        "northeast", "southeast", "southwest", "northwest" });
private mixed    *_feature_direcs = ({ ({ "southwest", "south", "southeast" }),
                               ({ "west", "Oops", "east" }),
                               ({ "northwest", "north", "northeast" }) });
void load_area_map();
void load_zone_map();
class char_map_data query_char_map(int x, int y);
void setup_area_map();
void setup_room(object room, string base_path);
string find_adjacent_terrain(int x, int y);
mixed   *query_room_map() { return _room_map; }
mixed   *query_area_map() { return _area_map; }
mixed   *query_zone_map() { return _zone_map; }
mapping query_zone_types() { return _zone_types; }
mapping query_feature_rooms() { return _feature_rooms; }
mapping query_features() { return _features; }
mapping query_room_zones() { return _room_zones; }
mapping query_char_maps() { return _char_map; }
mapping query_signposts() { return _signposts; }
mapping query_random_descs() { return _random_descs; }
mapping query_random_chats() { return _random_chats; }
mapping query_standard_exits() { return _standard_exits; }
mapping query_adjacent_terrains() { return _adjacent_terrains; }
class real_coords query_debug_real_coord() { return _real_coords; }
mixed* query_real_coords() { return ({ ({ _real_coords->x1, _real_coords->y1 }), ({ _real_coords->x2, _real_coords->y2 }) }); }
int     *query_dimensions() { return ({ _width, _height }); }
void    setup_handler() { }
string  query_map_file() { return ""; }
void set_real_coordinates_no_inform(int x1, int y1, int x2, int y2) {
   int tmp;
   if (x1 > x2) {
      tmp = x1;
      x1 = x2;
      x2 = tmp;
   }
   if (y1 > y2) {
      tmp = y1;
      y1 = y2;
      y2 = tmp;
   }
   _real_coords = new(class real_coords, x1:x1, y1:y1, x2:x2, y2:y2);
   _real_coords->xdiff = (x2 - x1) / _width;
   _real_coords->ydiff = (y2 - y1) / _height;
   _real_coords->zdiff = 15;
   _real_coords->xydiff = to_int(sqrt(to_float(_real_coords->xdiff) * to_float(_real_coords->xdiff)+
                               to_float(_real_coords->ydiff) * to_float(_real_coords->ydiff)));
}
void set_real_coordinates(int x1, int y1, int x2, int y2) {
   set_real_coordinates_no_inform(x1, y1, x2, y2);
   _real_coords->in_world_map = TERRAIN_MAP_WORLD_MAP->add_terrain(base_name(this_object()),
                                      _real_coords->x1, _real_coords->y1,
                                      _real_coords->x2, _real_coords->y2);
}
void set_real_offsets(int xoff, int yoff, int zoff) {
   _real_coords = new(class real_coords);
   _real_coords->xdiff = xoff;
   _real_coords->ydiff = yoff;
   _real_coords->xydiff = to_int(sqrt(to_float(_real_coords->xdiff) * to_float(_real_coords->xdiff)+
                               to_float(_real_coords->ydiff) * to_float(_real_coords->ydiff)));
}
class coord query_terrain_from_real_coord(int x, int y, int z) {
   return new(class coord,
       x: (x - _real_coords->x1)  / _real_coords->xdiff,
       y: (y - _real_coords->y1) / _real_coords->ydiff,
       z: z / _real_coords->zdiff
        );
}
class coord query_real_from_terrain_coord(int x, int y, int z) {
   if (!_real_coords) {
      return new(class coord, x : 0, y : 0);
   }
   return new(class coord,
      x: _real_coords->x1 + x * _real_coords->xdiff,
      y: _real_coords->y1 + y * _real_coords->ydiff,
      z: z * _real_coords->zdiff
     );
}
int query_newline_mode() { return _newline_mode; }
void set_newline_mode(int mode)
{
  _newline_mode = mode;
}
void set_visible_distance(int distance) {
   _visible_distance = distance;
}
int query_visible_distance() {
   return _visible_distance;
}
void create()
{
   setup_area_map();
   setup_handler();
}
void setup_area_map()
{
   int   index;
   load_area_map();
   load_zone_map();
   if (!arrayp(_room_map)) {
      _room_map = ({ });
      for (index = 0; index < _width; index++)
         _room_map += ({ allocate(_width) });
   }
}
object query_feature_ob(string name) {
   return _features[name]->feature_ob;
}
mapping calc_features(object room)
{
   class feature_data    feature;
   string     title;
   int        *room_coords = room->query_terrain_coords();
   int        x = room_coords[0];
   int        y = room_coords[1];
   int        z = room_coords[2];
   mapping    data;
   string direc;
   int range;
   mapping block_feature;
   mixed* features;
   mixed* tmp;
   block_feature = ([ ]);
   features = ({ });
   foreach(title, feature in _features) {
      if (!room->can_view_feature(title)) {
         continue;
      }
      if (!feature || !feature->feature_ob) {
         debug_printf("Unable to find feature object for %O\n", title);
         continue;
      }
      data = feature->feature_ob->query_feature_desc_from(x, y, z);
      if (!data || !sizeof(data)) {
         continue;
      }
      if (feature->feature_ob->query_blocking()) {
         foreach (direc, range in data) {
            if (!block_feature[direc]) {
               if (block_feature[direc] > range) {
                  block_feature[direc] = range;
               } else {
                  map_delete(data, direc);
               }
            }
         }
      }
      if (sizeof(data)) {
         features += ({ ({ title, feature, data }) });
      }
   }
   foreach (tmp in features) {
      data = tmp[2];
      if (sizeof(block_feature)) {
         foreach (direc, range in data) {
            if (block_feature[direc] && block_feature[direc] < range) {
               map_delete(data, direc);
            }
         }
      }
      if (sizeof(data)) {
         feature = tmp[1];
         title = tmp[0];
         room->add_feature(title, data, feature->f_items, feature->whole_sentance);
         if (!_feature_rooms[title]) {
            _feature_rooms[title] = ({ });
         } else {
            _feature_rooms[title] = filter(_feature_rooms[title], (: $1 && objectp($1) :));
         }
         _feature_rooms[title] |= ({ room });
      }
   }
}
void add_signposts(object room)
{
   class sign_data sign;
   int     *coords = room->query_terrain_coords();
   int     x = coords[0];
   int     y = coords[1];
   string  title = sprintf("%d:%d", x, y);
   object  sign_ob;
   sign = _signposts[title];
   if (!sign) {
      return;
   }
   sign_ob = room->add_sign(sign->long, sign->read_mess,
                  sign->short, sign->name,
                  sign->language);
   sign_ob->move(room);
}
void setup_zones(object room)
{
   string  *zones;
   int     *coords = room->query_terrain_coords();
   int     x = coords[0];
   int     y = coords[1];
   string  type;
   string  zone;
   if (!sizeof(_zone_map)) {
      return;
   }
   type = _zone_map[y][x..x];
   zones = _zone_types[type];
   if (!zones) {
      return;
   }
   foreach (zone in zones) {
      room->add_zone(zone);
   }
}
void calc_random_descs(object room, string key)
{
   int      limit = _random_desc_limit;
   int      *indices = ({ });
   int      *coords = room->query_terrain_coords();
   int      seed = (coords[0] * 2) + coords[1];
   mapping  desc;
   mixed    *descs = _random_descs[key];
   int      index;
   if (limit > sizeof(descs)) {
      limit = sizeof(descs);
   }
   if (!limit) {
      return;
   }
   while (sizeof(indices) < limit) {
      index = RANDOM_HANDLER->random(sizeof(descs), seed++);
      if (member_array(index, indices) >= 0) {
         continue;
      }
      indices += ({ index });
   }
   for (index = 0; index < limit; index++) {
      desc = descs[indices[index]];
      room->add_random_desc(desc["desc"]);
      room->add_item(desc["items"], desc["item_desc"]);
   }
}
void calc_random_chats(object room, string key)
{
}
string query_dest_coordinate_string(int x, int y, int z, string direc, string key) {
   class char_map_data  room_setup;
   room_setup = query_char_map(x, y);
   if (room_setup->type == AREA_WORLD) {
      return room_setup->path->query_dest_coordinate_string(x, y, z, direc, key);
   }
   return 0;
}
int* query_ground_room_co_ords(int x, int y) {
   class char_map_data  room_setup;
   room_setup = query_char_map(x, y);
   return ({ x, y, room_setup->height });
}
string query_ground_room(int x, int y) {
   int* co_ords;
   co_ords = query_ground_room_co_ords(x, y);
   return base_name(this_object()) + ":" + co_ords[0] + ":" + co_ords[1] + ":" + co_ords[2];
}
string query_climb_base_room(int x, int y, int z, int map_room, string ref base) {
   class char_map_data  room_setup;
   string *tmp;
   room_setup = query_char_map(x, y);
   if (!room_setup) {
      return 0;
   }
   if (room_setup->type == AREA_WORLD) {
     if(file_size(room_setup->path + ".c") == -1) {
       tmp = explode(room_setup->path, "_edge");
       if(sizeof(tmp) && file_size(tmp[0] + ".c") > 0)
         room_setup->path = tmp[0];
     }
     return room_setup->path->find_base_terrain_room(x, y, z, room_setup->path, map_room, ref base);
   } else if (room_setup->height_rooms) {
      if (z > room_setup->height) {
         if (map_room == TERRAIN_MAP_ROOM_MAP) {
            return room_setup->path;
         }
         if (map_room != TERRAIN_MAP_ROOM_CLIMB) {
            return TERRAIN_MAP_DEFAULT_AIR_ROOM;
         }
         return 0;
      }
      if (z == room_setup->height) {
         return room_setup->path;
      }
      if (room_setup->height_rooms[z]) {
         return room_setup->height_rooms[z];
      }
      if (room_setup->height_rooms["minimum"] > z) {
         return 0;
      }
      return room_setup->height_rooms["default"];
   } else if (z == room_setup->height) {
      return room_setup->path;
   } else if (map_room && z > room_setup->height) {
      return room_setup->path;
   } else if (z > room_setup->height) {
      if (map_room != TERRAIN_MAP_ROOM_CLIMB) {
         return TERRAIN_MAP_DEFAULT_AIR_ROOM;
      }
   }
   return 0;
}
string query_base_room(int x, int y, int z, int map_room) {
   string dest;
   dest = "bing";
   return query_climb_base_room(x, y, z, map_room, ref dest);
}
void setup_room(object room, string base_path)
{
   string main_base;
   string base;
   int      *room_coords = room->query_terrain_coords();
   mixed    *coords;
   int      x;
   int      y;
   string   direc;
   class char_map_data  room_setup;
   string*  dirs;
   mapping  adjacent_descs = ([ ]);
   mapping  adjacent_sent = ([ ]);
   mapping  distant;
   string   adjacent;
   string   key;
   string   room_long = "";
   string   key_here;
   mixed    *exit_mods;
   object   new_room;
   string   outside_types = "";
   mixed    *exits;
   mapping  exit;
   string   *sentances;
   mixed   tmp;
   int z;
   int road_jump;
   class coord fluff;
   string* miss_road;
   mapping ignore_exits;
   string  walk_pre;
   string  walk_full;
   string  journey_pre;
   string  new_base_path;
   if (!arrayp(room_coords)) {
      debug_printf("Unable to find room coordinates from %O\n", file_name(room));
      return ;
   }
   room_setup = query_char_map(room_coords[0], room_coords[1]);
   key_here = room_setup->char;
   if (room_setup->room_desc) {
      adjacent_descs[room_setup->room_desc] = ({ "here" });
      adjacent_sent[room_setup->char] = 1;
      if( room_setup->items ) {
          if( stringp( room_setup->items ) &&
              stringp( room_setup->item_desc ) ) {
              room->add_item( room_setup->items, room_setup->item_desc );
          } else if( arrayp( room_setup->items ) &&
              arrayp( room_setup->item_desc ) && sizeof( room_setup->items ) ) {
              if( sizeof( room_setup->items ) !=
                  sizeof( room_setup->item_desc ) ) {
                  debug_printf( "Error, unequal arrays.  Item not set." );
              } else {
                  int i;
                  for( i = 0; i < sizeof( room_setup->items ); i++ ) {
                      room->add_item( room_setup->items[i],
                          room_setup->item_desc[i] );
                  }
              }
          }
      }
   }
   if (room_setup->room_jump_matching) {
      road_jump = room_setup->room_jump;
   }
   walk_pre = room->query_terrain_map_walk_exit();
   journey_pre = room->query_terrain_map_journey_exit();
   exits = _standard_exits[sprintf("%d:%d:%d", room_coords[0], room_coords[1], room_coords[2])];
   ignore_exits = ([ ]);
   if (exits) {
      foreach(exit in exits) {
         room->add_exit(exit["direc"], exit["dest"], exit["type"]);
         if (exit["modifiers"]) {
            room->modify_exit(exit["direc"], exit["modifiers"]);
         }
         ignore_exits[exit["direc"]] = 1;
      }
   }
   main_base = base_name(this_object());
   if (room_setup->height_rooms ||
       room_setup->type == AREA_WORLD) {
      int i;
      x = room_coords[0];
      y = room_coords[1];
      for (i = 0; i < 2; i++) {
         z = room_coords[2];
         if (!i) {
            direc = "up";
            tmp = "down";
            z++;
         } else {
            direc = "down";
            tmp = "up";
            z--;
         }
         base = query_base_room(x, y, z, TERRAIN_MAP_ROOM_EXACT);
         if (base) {
            new_room = load_object(base);
            new_base_path = base;
            if (!new_room) {
               continue;
            }
            if (new_room->can_enter_from(key_here, direc, base_path) &&
                room->can_exit_to(key_here, direc, new_base_path)) {
               room->add_exit(direc, main_base + ":" + x + ":" + y + ":" + z, "path");
               exit_mods = room->get_to_same(tmp, direc, key, new_base_path);
               if (exit_mods) {
                   room->modify_exit(direc, exit_mods);
               }
            }
         }
      }
   }
   miss_road = allocate(3 * 3);
   foreach(direc in _direc_order) {
      coords = _direcs[direc];
      x = coords[0] + room_coords[0];
      y = coords[1] + room_coords[1];
      z = room_coords[2];
      if ((x < 0) || (x >= _width) || (y < 0) || (y >= _height)) {
         base = find_adjacent_terrain(x, y);
         if (!base) {
            continue;
         }
         fluff = query_real_from_terrain_coord(x, y, z);
         fluff = base->query_terrain_from_real_coord(fluff->x, fluff->y, fluff->z);
         room_setup = base->query_char_map(fluff->x, fluff->y);
         if (room_setup && room_setup->type != AREA_OBSTACLE) {
            tmp = base->query_base_room(fluff->x, fluff->y, z, TERRAIN_MAP_ROOM_EXACT);
            if (tmp) {
               new_base_path = tmp;
               new_room = load_object(tmp);
               base += ":" + fluff->x + ":" + fluff->y + ":" + z;
            } else {
               new_room = 0;
               new_base_path = 0;
            }
         }
      } else {
         room_setup = query_char_map(x, y);
         if (room_setup && room_setup->type != AREA_OBSTACLE) {
            tmp = query_base_room(x, y, z, TERRAIN_MAP_ROOM_EXACT);
            new_base_path = tmp;
            if (tmp) {
               new_room = load_object(tmp);
               base = main_base + ":" + x + ":" + y + ":" + z;
            } else {
               new_room = 0;
            }
         }
      }
      if (!room_setup || !new_room) {
         continue;
      }
      key = room_setup->char;
      if (!coords[0] || !coords[1]) {
         miss_road[(coords[0] + 1) * 3 + coords[1] + 1] = new_base_path;
      } else {
         if ((miss_road[(coords[0] + 1) * 3 + 1] != new_base_path ||
              miss_road[coords[1] + 4] != new_base_path) &&
             miss_road[coords[1] + 4] &&
             miss_road[(coords[0] + 1) * 3 + 1] &&
             !miss_road[coords[1] + 4]->can_move_between(key, direc,
                                    miss_road[(coords[0] + 1) * 3 + 1],
                                    miss_road[coords[1] + 4], new_base_path)) {
            continue;
         }
      }
      switch(room_setup->type) {
         case AREA_OBSTACLE   :
            break;
         case AREA_ROAD       :
         case AREA_ROOM       :
         case AREA_WORLD      :
           if (ignore_exits[direc]) {
              break;
           }
           if (new_room->can_enter_from(key_here, direc, base_path) &&
                room->can_exit_to(key, direc, new_base_path)) {
              tmp = new_room->query_enter_exit_direction(key, key_here, direc, room, base_path);
              if (tmp) {
                 room->add_exit(tmp, base, "road");
                 walk_full = tmp;
              } else {
                 room->add_exit(direc, base, "road");
                 room->add_exit(walk_pre + direc, base, "road");
                 room->add_default_exit(direc, base);
                 walk_full = walk_pre + direc;
              }
              if (coords[4]) {
                 room->modify_exit(walk_full, coords[4]);
                 room->modify_exit(direc, coords[4]);
              }
              if (key_here == key ||
                  (road_jump &&
                   room_setup->room_jump_matching &&
                   room_setup->room_jump == road_jump)) {
                 exit_mods = room->get_to_same(_direcs[direc][2], direc, key, new_base_path);
                 if (exit_mods) {
                    room->modify_exit(direc, exit_mods);
                    room->modify_exit(walk_full, exit_mods);
                 }
                 if (room_setup->room_jump > 1) {
                    room->modify_exit(walk_full, ({ "obvious", 0 }));
                    room->add_variable_exit(journey_pre + direc);
                    room->add_exit(journey_pre + direc, base, "road");
                    exit_mods = room->get_to_same(walk_full, journey_pre + direc, key, new_base_path);
                    if (coords[4]) {
                       room->modify_exit(journey_pre + direc, coords[4]);
                    }
                    if (exit_mods) {
                        room->modify_exit(journey_pre + direc, exit_mods);
                    }
                 }
              } else {
                 exit_mods = room->get_to_other(_direcs[direc][2], direc, key, new_base_path);
                 if (exit_mods) {
                     room->modify_exit(walk_full, exit_mods);
                 }
                 exit_mods = new_room->
                             get_from_other(_direcs[direc][2], direc, key_here, base_path);
                 if (exit_mods) {
                     room->modify_exit(walk_full, exit_mods);
                 }
              }
              room->modify_exit(direc, ({ "obvious", 0 }));
           }
           break;
      }
      if ((key_here != key) && (member_array(key[0], outside_types) < 0)) {
         outside_types += key;
      }
      adjacent = room_setup->adjacent_desc;
      if (adjacent && strlen(adjacent) > 1) {
         if (room->can_view_adjacent_desc(room_setup->char,
                                          key_here,
                                          room_setup->path,
                                          z,
                                          direc)) {
            if (!room_setup->whole_sentance) {
               adjacent_sent[adjacent] = 1;
            }
            if (!adjacent_descs[adjacent]) {
               adjacent_descs[adjacent] = ({ });
               if( room_setup->items ) {
                   if (!adjacent_sent[room_setup->char]) {
                      adjacent_sent[room_setup->char] = 1;
                      if( stringp( room_setup->items ) &&
                          stringp( room_setup->item_desc ) ) {
                          room->add_item( room_setup->items,
                              room_setup->item_desc );
                      } else if( arrayp( room_setup->items ) &&
                          arrayp( room_setup->item_desc ) &&
                          sizeof( room_setup->items ) ) {
                          if( sizeof( room_setup->items ) !=
                              sizeof( room_setup->item_desc ) ) {
                              debug_printf( "Error, unequal arrays.  Item not "
                                  "set." );
                          } else {
                              int i;
                              for( i = 0; i < sizeof( room_setup->items ); i++) {
                                  room->add_item( room_setup->items[i],
                                      room_setup->item_desc[i] );
                              }
                          }
                      }
                   }
               }
            }
            adjacent_descs[adjacent] += ({ direc });
         }
      }
   }
   sentances = ({ });
   foreach(adjacent, dirs in adjacent_descs) {
      tmp = replace_string(adjacent,
                "$D", query_multiple_short(dirs, "the", 1));
      if (adjacent_sent[adjacent]) {
         if (strlen(tmp) > 1) {
            sentances += ({ tmp });
         }
      } else if (tmp != "") {
         if (query_newline_mode()) {
            room_long += tmp + "\n";
         } else {
            room_long += "  " + tmp;
         }
      }
   }
   if (sizeof(sentances)) {
      if (!query_newline_mode()) {
         room_long += "  ";
      }
      room_long += capitalize(query_multiple_short(sentances, "the", 1)) + ".";
      if (query_newline_mode()) {
         room_long += "\n";
      }
   }
   room->set_outside_types(outside_types);
   add_signposts(room);
   setup_zones(room);
   exit = calc_features(room);
   if (_real_coords && (_real_coords->x1 || _real_coords->x2)) {
      fluff = query_real_from_terrain_coord(room_coords[0], room_coords[1], 0);
      foreach (string title in TERRAIN_MAP_WORLD_MAP->query_features_at(fluff->x, fluff->y)) {
         if (!room->can_view_feature(title)) {
            continue;
         }
         distant = title->query_feature_desc_from(fluff->x, fluff->y, fluff->z);
         if (sizeof(distant)) {
            if (sizeof(exit)) {
               foreach (direc, int range in distant) {
                  if (exit[direc] && exit[direc] < range) {
                     map_delete(distant, direc);
                  }
               }
            }
            if (sizeof(distant)) {
               room->add_distant_feature(title, distant);
            }
         }
      }
   }
   calc_random_descs(room, key_here);
   calc_random_chats(room, key_here);
   room->set_extra_long(room_long);
   room->set_installed(1);
   room->calc_exits();
}
string find_adjacent_terrain(int x, int y)
{
   string index;
   class coord real;
   if (!_real_coords || !_real_coords->in_world_map) {
      return 0;
   }
   index = x + ":" + y;
   if (!undefinedp(_adjacent_terrains[index])) {
      return _adjacent_terrains[index];
   }
   real = query_real_from_terrain_coord(x, y, 0);
   _adjacent_terrains[index] = TERRAIN_MAP_WORLD_MAP->find_terrain_at(real->x, real->y);
   return _adjacent_terrains[index];
}
void find_all_adjacent_terrains() {
   find_adjacent_terrain(-1,-1);
   find_adjacent_terrain(-1,0);
   find_adjacent_terrain(-1,40);
   find_adjacent_terrain(0,40);
   find_adjacent_terrain(40,40);
   find_adjacent_terrain(40,0);
   find_adjacent_terrain(40,-1);
   find_adjacent_terrain(0,-1);
}
string* debug_adjacent_terrains() {
   return ({ find_adjacent_terrain(-1, 0),
             find_adjacent_terrain(0, -1),
             find_adjacent_terrain(0, _height),
             find_adjacent_terrain(_width, 0) });
}
mixed* query_rooms_to(int x, int y, int z, string direc, int len,
                       string main_key, int jump_len, int road_type ) {
   class char_map_data  room_setup;
   class coord real;
   string new_direc;
   string found_direc;
   string terr;
   string bit;
   int num;
   int found;
   int old_x;
   int old_y;
   int new_x;
   int new_y;
   mixed* ret;
   mixed* data;
   ret = ({ ({ }), ({ }) });
   do {
      data = _direcs[direc];
      if (!data) {
         debug_printf("Bad direction %O\n", direc);
         continue;
      }
      old_x = x;
      old_y = y;
      x += data[0];
      y += data[1];
      if ((x < 0) || (x >= _width) || (y < 0) || (y >= _height)) {
         terr = find_adjacent_terrain(x, y);
         if (!terr) {
            return ret;
         }
         real = query_real_from_terrain_coord(x, y, 0);
         data = terr->query_more_terrains_rooms_from(real->x, real->y, real->z, direc,
                                 len - num, jump_len,
                                 main_key, road_type);
         if (sizeof(data)) {
            ret[0] += data[0];
            ret[1] += data[1];
         }
         return ret;
      }
      ret[0] += ({ direc });
      bit = sprintf("%d:%d:%d", x, y, z);
      ret[1] += ({ sprintf("%s:%s", base_name(this_object()), bit) });
      if (_standard_exits[bit]) {
         break;
      }
      if (road_type) {
         found = 0;
         foreach (new_direc, data in _direcs) {
            new_x = x + data[0];
            new_y = y + data[1];
            if (new_x != old_x || new_y != old_y) {
               if ((new_x < 0) || (new_x >= _width) || (new_y < 0) || (new_y >= _height)) {
                  terr = find_adjacent_terrain(new_x, new_y);
                  if (terr) {
                     real = query_real_from_terrain_coord(new_x, new_y, z);
                     real = terr->query_terrain_from_real_coord(real->x, real->y, z);
                     room_setup = terr->query_char_map(real->x, real->y);
                  } else {
                     room_setup = 0;
                  }
               } else {
                  room_setup = query_char_map(new_x, new_y);
               }
               if (room_setup && room_setup->room_jump == jump_len) {
                  found_direc = new_direc;
                  found++;
               }
            }
         }
         if (found == 1) {
            direc = found_direc;
         } else {
            break;
         }
      } else {
         room_setup = query_char_map(x + data[0], y + data[1]);
         if (!room_setup || room_setup->char != main_key) {
            break;
         }
      }
   } while (num++ < len);
   return ret;
}
mixed* query_more_terrains_rooms_from(int x, int y, int z, string direc,
                                       int moves_left, int jump,
                                       string main_key, int road_jump) {
   class coord bing;
   class char_map_data  room_setup;
   int found;
   string found_direc;
   string new_direc;
   mixed* data;
   int new_x;
   int new_y;
   bing = query_terrain_from_real_coord(x, y, 0);
   room_setup = query_char_map(bing->x, bing->y);
   if (road_jump) {
      if (room_setup->room_jump != jump) {
         data = _direcs[direc];
         bing->x -= data[0];
         bing->y -= data[1];
         foreach (new_direc, data in _direcs) {
            new_x = bing->x + data[0];
            new_y = bing->y + data[1];
            room_setup = query_char_map(new_x, new_y);
            if (room_setup && room_setup->room_jump == jump) {
               found = 1;
               found_direc = new_direc;
               break;
            }
         }
         if (!found) {
            return ({ });
         }
         direc = found_direc;
      } else {
         data = _direcs[direc];
         bing->x -= data[0];
         bing->y -= data[1];
      }
      return query_rooms_to(bing->x, bing->y, bing->z, direc, moves_left,
                            main_key, jump, road_jump);
   } else {
      if (room_setup->char == main_key) {
         data = _direcs[direc];
         bing->x -= data[0];
         bing->y -= data[1];
         return query_rooms_to(bing->x, bing->y, bing->z, direc, moves_left,
                            main_key, jump, road_jump);
      }
      return ({ });
   }
}
string* find_next_room_from(int x, int y, int z, string direc) {
   class char_map_data  room_setup;
   string test;
   object ob;
   object* obs;
   mixed* stuff;
   int pos;
   room_setup = query_char_map(x, y);
   stuff = query_rooms_to(x, y, z, direc, room_setup->room_jump,
                          room_setup->char, room_setup->room_jump,
                          room_setup->room_jump_matching);
   foreach (test in stuff[0]) {
      ob = find_object(test);
      if (ob) {
         obs = filter(all_inventory(ob), (: living($1) :));
         if (sizeof(obs) > 0) {
            return ({ test }) + stuff[0..pos];
         }
      }
      pos++;
   }
   if (sizeof(stuff[1])) {
      return ({ stuff[1][<1] }) + stuff[0];
   }
   return 0;
}
void add_room_to_zone(object room, string zone)
{
   object *zones = _room_zones[zone];
   if (!zones)
      zones = ({ room });
   else if (member_array(room, zones) == -1)
      zones += ({ room });
   _room_zones[zone] = zones - ({ 0 });
}
mixed query_room(int x, int y, int z)
{
   class char_map_data room_map = query_char_map(x, y);
   string base_path;
   object room;
   class coord real;
   base_path = query_base_room(x, y, z, TERRAIN_MAP_ROOM_EXACT);
   if (!base_path) {
      return 0;
   }
   room = clone_object(base_path);
   if (!room) {
      debug_printf("Unable to create room from %O at %O %O %O\n", base_path, x, y, z);
   } else {
      room->create_terrain_room();
      room->set_terrain_coords(x, y, z);
      real = query_real_from_terrain_coord(x, y, z);
      room->set_co_ord(({ real->x, real->y, real->z }));
      if (classp(_real_coords)) {
         room->set_room_size(({ _real_coords->xdiff, _real_coords->ydiff, _real_coords->zdiff }));
      }
      room->set_terrain_handler(base_name(this_object()));
      room->terrain_setup();
      room->add_property("base path", base_path);
      _room_map[y][x] = room;
      setup_room(room, base_path);
      if (room_map->type == AREA_WORLD && base_path != room_map->path) {
         room_map->path->setup_in_terrain(room, x, y, z);
      }
   }
   return room;
}
object query_room_at(int x, int y, int z)
{
   if ((x < 0) || (y < 0) || (x >= _width) || (y >= _height))
      return 0;
   return find_object(sprintf("%s:%d:%d:%d", base_name(this_object()), x, y, z));
}
object *query_rooms_in_block(int x, int y, int z, int width, int height)
{
   int      h, v;
   mixed    *result = ({ });
   object   room;
   for (h = x; h < (x + width); h++) {
      for (v = y; v < (y + height); v++) {
         room = query_room_at(h, v, z);
         if (room)
            result = result + ({ room });
      }
   }
   return result;
}
varargs object *query_rooms_in_range(int x, int y, int z, int max, int min)
{
   int      h, v;
   mixed    *result = ({ });
   object   room;
   int    dist;
   for (h = x - max; h <= (x + max); h++) {
      for (v = y - max; v <= (y + max); v++) {
        dist = to_int(sqrt(pow(x - h, 2) + pow(y - v, 2)) + 0.4999);
        if ((dist > max) || (dist < min))
           continue;
         room = query_room_at(h, v, z);
         if (room)
            result = result + ({ room });
      }
   }
   return result;
}
object load_room_at(int x, int y, int z)
{
   class char_map_data room_map = query_char_map(x, y);
   if (!room_map) {
      debug_printf("Unable to load room at %d %d\n", x, y);
      return 0;
   }
   if (room_map->type == AREA_OBSTACLE) {
      return 0;
   }
   return load_object(sprintf("%s:%d:%d:%d", base_name(this_object()), x, y, z));
}
class char_map_data query_char_map(int x, int y)
{
   string   type;
   class char_map_data  room_map;
   if ((x < 0) || (x >= _width) || (y < 0) || (y >= _height)) {
      return 0;
   }
   if (x >= sizeof(_area_map[y])) {
      debug_printf("The x value is out of range: %d > %d", x, sizeof(_area_map[y]));
      return 0;
   }
   type = _area_map[y][x..x];
   room_map = copy(_char_map[type]);
   if (!room_map) {
      debug_printf("There is no char type for '%s'", type);
      return 0;
   }
   room_map->char = type;
   return room_map;
}
string query_debug_map(int x, int y, int width, int showx, int showy) {
   int i;
   int j;
   int sx;
   int sy;
   int ny;
   string ret;
   string base;
   string new_base;
   string colour;
   ret = "";
   sx = x - width / 2;
   sy = y + width / 2;
   for (j = 0; j < width; j++) {
      if (sy - j >= 0 && sy - j < _height) {
         for (i = 0; i < width; i++) {
            if (sx + i >= 0 && sx + i < _width) {
               if (sx +i == showx && sy - j == showy) {
                  ret += "%^YELLOW%^" + _area_map[sy - j][sx + i..sx + i] +
                         "%^RESET%^";
                  colour = 0;
               } else {
                  if (colour) {
                     ret += "%^RESET%^";
                     colour = 0;
                  }
                  ret += _area_map[sy - j][sx + i..sx + i];
               }
            } else {
               if (sx + i >= _width) {
                  base = find_adjacent_terrain(_width + 1, sy - j);
               } else {
                  base = find_adjacent_terrain(-1, sy - j);
               }
               if (base) {
                  if (colour != "%^CYAN%^") {
                     ret += "%^BOLD%^%^CYAN%^";
                     colour = "%^CYAN%^";
                  }
                  if (sx + i >= _width) {
                     ret += base->query_debug_map_char(sx + i - _width, sy - j);
                  } else {
                     ret += base->query_debug_map_char(sx + i + _width, sy - j);
                  }
               } else {
                  ret += " ";
               }
            }
         }
         if (colour) {
            ret += "%^RESET%^";
            colour = 0;
         }
         ret += "\n";
      } else {
         base = find_adjacent_terrain(sx + i, sy - j);
         if (base) {
            if (sy - j < 0) {
               ny = sy - j + _height;
            } else {
               ny = sy - j - _height;
            }
            for (i = 0; i < width; i++) {
               if (sx + i >= 0 && sx + i < _width) {
                  if (colour != "%^MAGENTA%^") {
                     ret += "%^BOLD%^%^MAGENTA%^";
                     colour = "%^MAGENTA%^";
                  }
                  ret += base->query_debug_map_char(sx + i, ny);
               } else {
                  new_base = find_adjacent_terrain(sx + i, sy - j);
                  if (new_base) {
                     if (colour != "%^RED%^") {
                        ret += "%^BOLD%^%^RED%^";
                        colour = "%^RED%^";
                     }
                     if (sx + i >= _width) {
                        ret += new_base->query_debug_map_char(sx + i - _width, ny);
                     } else {
                        ret += new_base->query_debug_map_char(sx + i + _width, ny);
                     }
                  } else {
                     ret += " ";
                  }
               }
            }
            ret += "%^RESET%^\n";
            colour = 0;
         }
      }
   }
   return ret;
}
string query_debug_map_char(int x, int y) {
   return _area_map[y][x..x];
}
string query_debug_map_feature(string name) {
   int x;
   int y;
   class feature_data feature;
   mixed data;
   string ret;
   int colour;
   int found;
   feature = _features[name];
   ret = "";
   colour = 0;
   for (y = _height - 1; y >= 0; y--) {
      for (x = 0; x < _width; x++) {
         data = feature->feature_ob->query_feature_desc_from(x, y, 0, 1);
         found = sizeof(data);
         if (found) {
            if (!colour) {
               ret += "%^YELLOW%^";
               colour = 1;
            }
         } else {
            if (colour) {
               ret += "%^RESET%^";
               colour = 0;
            }
         }
         ret += _area_map[y][x..x];
      }
      ret += "%^RESET%^\n";
      colour = 0;
   }
   return ret;
}
string query_debug_map_feature_distant(string feature) {
   int x;
   int y;
   mixed data;
   string ret;
   int colour;
   class coord fluff;
   ret = "";
   colour = 0;
   for (y = _height - 1; y >= 0; y--) {
      for (x = 0; x < _width; x++) {
         fluff = query_real_from_terrain_coord(x, y, 0);
         data = feature->query_feature_desc_from(fluff->x, fluff->y, fluff->z);
         if (data && sizeof(data)) {
            if (!colour) {
               ret += "%^YELLOW%^";
               colour = 1;
            }
         } else {
            if (colour) {
               ret += "%^RESET%^";
               colour = 0;
            }
         }
         ret += _area_map[y][x..x];
      }
      ret += "%^RESET%^\n";
      colour = 0;
   }
   return ret;
}
private void add_key(mapping key, string char, string str) {
  if(strsrch(str, "intersection") != -1)
    return;
  if(!key[char])
    key[char] = str;
  else if(strsrch(key[char], str) == -1 ) {
    key[char] += ", " + str;
  }
}
private int update_map(mapping data, mixed* map, mapping key, mixed *colours,
                       int x, int y, int z, int offx, int offy) {
   class char_map_data info;
   string char, colour, tmp;
   string room;
   int block;
   object ob;
   if (x < 0) {
      if (y < 0) {
         data["-y-x"] = 1;
      } else if (y >= _height) {
         data["+y-x"] = 1;
      } else {
         data["-x"] = 1;
      }
      return 0;
   } else if (x >= _width) {
      if (y < 0) {
         data["-y+x"] = 1;
      } else if (y >= _height) {
         data["+y+x"] = 1;
      } else {
         data["+x"] = 1;
      }
      return 0;
   } else if (y < 0) {
      data["-y"] = 1;
      return 0;
   } else if (y >= _height) {
      data["+y"] = 1;
      return 0;
   }
   info = query_char_map(x, y);
   if (!info) {
      return 1;
   }
   if (info->type == AREA_OBSTACLE) {
      map[y - offy][x - offx] = info->char;
      colours[y - offy][x - offx] = info->colour;
      if(!info->colour) {
        colours[y - offy][x - offx] = "%^BLUE%^";
      }
      if (info->room_desc == "Obstacle" && stringp(info->items)) {
        add_key(key, info->char, info->items);
      } else if (info->room_desc != "") {
        add_key(key, info->char, info->room_desc);
      } else {
         map[y - offy][x - offx] = " ";
      }
      data["block" + info->char] = 1;
      return 1;
   } else {
      char = data[info->char];
      colour = data[info->colour];
      if (!char || !colour) {
         room = query_base_room(x, y, z, TERRAIN_MAP_ROOM_MAP);
         if (room) {
            ob = load_object(room);
            if (ob) {
               char = ob->query_terrain_map_character();
               colour = ob->query_terrain_map_colour();
               block = ob->query_terrain_map_block();
               if(char && ob) {
                  tmp = ob->query_key_desc();
                  if(!tmp) {
                     tmp = ob->query_short();
                  }
                  if(!tmp) {
                     debug_printf("Room %s has no short.", base_name(ob));
                  } else {
                     add_key(key, char, tmp);
                  }
               }
               if (block || info->height > z) {
                  data["block" + info->char] = 1;
               }
            } else {
               debug_printf("Unable to find %O\n", room);
            }
         }
         if (!char) {
            char = info->char;
         }
         if(!colour) {
            colour = info->colour;
         }
         data[info->char] = char;
      }
      map[y - offy][x - offx] = char;
      colours[y - offy][x - offx] = colour;
   }
   if(char && !key[char] && !data["nokey"+info->char]) {
      data["nokey" + info->char] = 1;
      debug_printf("No key for %s", char);
   }
   return data["block" + info->char];
}
private string line_in_map(mapping data, mixed* map, mapping key,
                           mixed *colours, int offx, int offy,
                           int sx, int sy, int ex, int ey, int z) {
   int x;
   int y;
   int dx;
   int dy;
   int incx;
   int incy;
   int balance;
   if (ex >= sx) {
      dx = ex - sx;
      incx = 1;
   } else {
      dx = sx - ex;
      incx = -1;
   }
   if (ey >= sy) {
      dy = ey - sy;
      incy = 1;
   } else {
      dy = sy - ey;
      incy = -1;
   }
   x = sx;
   y = sy;
   if (dx >= dy) {
      dy <<= 1;
      balance = dy - dx;
      dx <<= 1;
      while (x != ex) {
         if (update_map(data, map, key, colours, x, y, z, offx, offy)) {
            break;
         }
         if (balance >= 0) {
            y += incy;
            balance -= dx;
         }
         balance += dy;
         x += incx;
      }
   } else {
      dx <<= 1;
      balance = dx - dy;
      dy <<= 1;
      while (y != ey) {
         if (update_map(data, map, key, colours, x, y, z, offx, offy)) {
            break;
         }
         if (balance >= 0) {
            x += incx;
            balance -= dy;
         }
         balance += dx;
         y += incy;
      }
   }
   update_map(data, map, key, colours, x, y, z, offx, offy);
}
private void update_blocking(mapping data,
                             mixed* map, mixed* colours, int x, int y,
                             int distance) {
   int dx;
   int dy;
   int adx;
   int ady;
   int dist;
   int nx;
   int ny;
   int tx;
   int ty;
   int incx;
   int incy;
   string* template;
   string str;
   dx = (x - distance);
   dy = (y - distance);
   str = " ";
   if (dx < 0) {
      adx = - dx;
      incx = -1;
   } else {
      adx = dx;
      incx = 1;
   }
   if (dy < 0) {
      ady = - dy;
      incy = -1;
   } else {
      ady = dy;
      incy = 1;
   }
   if (incx != incy) {
      incx = -incx;
      incy = - incy;
   }
   if (adx > ady) {
      template = TERRAIN_MAP_WORLD_MAP->query_blocking_template(ady, adx, 0);
   } else {
      template = TERRAIN_MAP_WORLD_MAP->query_blocking_template(adx, ady, 0);
   }
   if (!template) {
      debug_printf("Error with the template");
      return ;
   }
   dist = distance + 1;
   for (tx = 0; tx < dist; tx++) {
      for (ty = 0; ty < dist; ty++) {
         if (template[tx][ty] == '*') {
            if (adx > ady) {
               nx = distance + tx * incx;
               ny = distance + ty * incy;
            } else {
               nx = distance + ty * incx;
               ny = distance + tx * incy;
            }
            if (nx < sizeof(map) && ny < sizeof(map[nx]) &&
                nx >= 0 && ny >= 0) {
               map[nx][ny] = str;
               colours[nx][ny] = 0;
            }
            if (adx == ady) {
               nx = distance + tx * incx;
               ny = distance + ty * incy;
               map[nx][ny] = str;
               colours[nx][ny] = 0;
            } else if (adx == 0) {
               nx = distance + ty * incx;
               ny = distance - tx * incy;
               map[nx][ny] = str;
            } else if (ady == 0) {
               nx = distance - tx * incx;
               ny = distance + ty * incy;
               map[nx][ny] = str;
               colours[nx][ny] = 0;
            }
         }
      }
   }
}
mapping query_player_map_internal_template(mixed* map, mapping key,
                                  mixed *colours, int x_c, int y_c, int z_c,
                                  int distance) {
   int offx;
   int offy;
   int x;
   int y;
   mapping data;
   data = ([ ]);
   offx = x_c - distance;
   offy = y_c - distance;
   for (x = 0; x < sizeof(map); x++) {
      for (y = 0; y < sizeof(map[x]); y++) {
         if (map[y][x] == 1) {
            if (update_map(data, map, key, colours, x + offx, y + offy, z_c, offx, offy)) {
               if (x > 0) {
                  if (y > 0 && data["block" + map[y-1][x-1]]) {
                     update_blocking(data, map, colours, x, y, distance);
                     update_blocking(data, map, colours, x, y-1, distance);
                  } else if (y < sizeof(map) - 1 && data["block" + map[y+1][x-1]]) {
                     update_blocking(data, map, colours, x, y, distance);
                     update_blocking(data, map, colours, x, y + 1, distance);
                  } else if (y > 0 && data["block" + map[y-1][x]]) {
                     update_blocking(data, map, colours, x, y, distance);
                     update_blocking(data, map, colours, x - 1, y - 1, distance);
                  } else {
                     update_blocking(data, map, colours, x, y, distance);
                  }
               } else {
                  update_blocking(data, map, colours, x, y, distance);
               }
            }
         }
      }
   }
   return data;
}
string query_player_map_template(int x_c, int y_c, int z_c, int visibility,
             int max_size) {
   string ret, item, base, current, *keys;
   mixed *map, *colours;
   mapping data, key;
   int i, j;
   int distance;
   distance = _visible_distance * visibility / 100;
   if (!distance) {
      distance = 1;
   }
   data = ([ ]);
   key = ([ ]);
   map = ({ });
   colours = ({ });
   map = TERRAIN_MAP_WORLD_MAP->query_map_template(distance);
   colours = TERRAIN_MAP_WORLD_MAP->query_map_template(distance);
   if (max_size && (max_size % 2) != 1) {
      max_size--;
   }
   if (max_size && sizeof(map) > max_size) {
      j = (max_size - 1) / 2;
      map = map[distance - j..distance + j];
      colours = colours[distance - j..distance + j];
      for (i = 0; i < sizeof(map); i++) {
         map[i] = map[i][distance - j..distance + j];
         colours[i] = colours[i][distance - j..distance + j];
      }
      x_c += (distance - j);
      y_c += (distance - j);
   }
   data = query_player_map_internal_template(map, key, colours, x_c, y_c, z_c,
                                    distance);
   if (data["-y"]) {
     base = find_adjacent_terrain(x_c, -1);
     if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c,
                                            y_c + _height, z_c, distance);
         }
      }
   }
   if (data["+y"]) {
      base = find_adjacent_terrain(x_c, _height + 1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c,
                                            y_c - _height, z_c, distance);
         }
      }
   }
   if (data["-x"]) {
      base = find_adjacent_terrain(-1, y_c);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c + _width,
                                            y_c, z_c, distance);
         }
      }
   }
   if (data["+x"]) {
      base = find_adjacent_terrain(_width + 1, y_c);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c - _width,
                                            y_c, z_c, distance);
         }
      }
   }
   if (data["-y+x"]) {
      base = find_adjacent_terrain(_width + 1, -1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c - _width,
                                            y_c + _height, z_c,
                                            distance);
         }
      }
   }
   if (data["+y+x"]) {
      base = find_adjacent_terrain(_width + 1, _height + 1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c - _width,
                                            y_c - _height, z_c,
                                            distance);
         }
      }
   }
   if (data["+y-x"]) {
      base = find_adjacent_terrain(-1, _height + 1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c + _width,
                                            y_c - _height, z_c,
                                            distance);
         }
      }
   }
   if (data["-y-x"]) {
      base = find_adjacent_terrain(-1, -1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal_template(map, key, colours, x_c + _width,
                                            y_c + _height, z_c,
                                            distance);
         }
      }
   }
   map[sizeof(map) / 2][sizeof(map) / 2] = "@";
   if(!this_player()->query_property(PLAYER_PLAIN_MAPS)) {
     colours[sizeof(map) / 2][sizeof(map) / 2] = "%^YELLOW%^";
     for(i=0; i<sizeof(map); i++) {
       current = "";
       for(j=0; j<sizeof(map); j++) {
         if(map[i][j] == "\r" || !stringp(map[i][j])) {
           map[i][j] = " ";
         }
         if (!current || current == " ") {
           current = "";
         }
         if(!colours[i][j] || colours[i][j] == " ") {
           colours[i][j] = "";
         }
         if(colours[i][j] != current) {
           if (colours[i][j] == "" || !stringp(colours[i][j])) {
             if(current != "" && current != " ") {
               map[i][j] = "%^RESET%^" + map[i][j];
               current = "";
             }
           } else if (colours[i][j] != "\r") {
             map[i][j] = colours[i][j] + map[i][j];
             current = colours[i][j];
           }
         }
         if(i == x_c && j == y_c && current != "") {
           map[i][j] += current;
         }
       }
       if(current) {
         map[i][j-1] += "%^RESET%^";
       }
     }
   }
   if(_key && !max_size) {
     keys = ({ });
     foreach(item in keys(key)) {
       keys += map(explode(sprintf("%s %-=40s", item, key[item]), "\n"),
                   (: "     " + $1 :));
     }
   }
   ret = "";
   for(i = sizeof(map) - 1; i >= 0; i--) {
     ret += implode(map(map[i], (: stringp($1) ? $1 : " " :)), "");
     if(!max_size && sizeof(map)-2-i>= 0 && sizeof(map)-2-i < sizeof(keys)) {
       ret += keys[sizeof(map)-2-i];
     }
     ret += "\n";
   }
   return ret;
}
mapping query_player_map_internal(mixed* map, mapping key, mixed *colours,
                                  int x_c, int y_c, int z_c, int distance) {
   int x, y, e, u, v;
   int endx, endy, offx, offy;
   mapping data;
   data = ([ ]);
   offx = x_c - distance;
   offy = y_c - distance;
   x = 0;
   y = distance;
   u = 1;
   v = 2 * distance - 1;
   e = 0;
   while (x < y) {
      endx = x_c + x;
      endy = y_c + y;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      endx = x_c + y;
      endy = y_c - x;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      endx = x_c - x;
      endy = y_c - y;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      endx = x_c - y;
      endy = y_c + x;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      x++;
      e += u;
      u += 2;
      if (v < 2 * e) {
         y--;
         e -= v;
         v -= 2;
      }
      if (x > y) {
         break;
      }
      endx = x_c + y;
      endy = y_c + x;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      endx = x_c + x;
      endy = y_c - y;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      endx = x_c - y;
      endy = y_c - x;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
      endx = x_c - x;
      endy = y_c + y;
      line_in_map(data, map, key, colours, offx, offy, x_c, y_c, endx, endy, z_c);
   }
   for(y=0; y<sizeof(map); y++)
     for(x=1; x<sizeof(map[y])-1; x++)
       if(map[y][x] == "\r" && map[y][x-1] != "\r" && map[y][x+1] != "\r") {
         update_map(data, map, key, colours, x + offx, y + offy, z_c, offx,
                    offy);
       }
   return data;
}
string query_player_map(int x_c, int y_c, int z_c, int visibility) {
   string ret, item, base, current, *keys;
   mixed *map, *colours;
   mapping data, key, colour_key;
   int i, j;
   int distance;
   distance = _visible_distance * visibility / 100;
   if (!distance) {
      distance = 1;
   }
   data = ([ ]);
   key = ([ ]);
   map = ({ });
   colours = ({ });
   for (i = 0; i < distance * 2 + 1; i++) {
      map += ({ allocate(distance * 2 + 1, "\r") });
      colours += ({ allocate(distance * 2 + 1, "\r") });
   }
   data = query_player_map_internal(map, key, colours, x_c, y_c, z_c,
                                    distance);
   if (data["-y"]) {
     base = find_adjacent_terrain(x_c, -1);
     if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c,
                                            y_c + _height, z_c, distance);
         }
      }
   }
   if (data["+y"]) {
      base = find_adjacent_terrain(x_c, _height + 1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c,
                                            y_c - _height, z_c, distance);
         }
      }
   }
   if (data["-x"]) {
      base = find_adjacent_terrain(-1, y_c);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c + _width,
                                            y_c, z_c, distance);
         }
      }
   }
   if (data["+x"]) {
      base = find_adjacent_terrain(_width + 1, y_c);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c - _width,
                                            y_c, z_c, distance);
         }
      }
   }
   if (data["-y+x"]) {
      base = find_adjacent_terrain(_width + 1, -1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c - _width,
                                            y_c + _height, z_c,
                                            distance);
         }
      }
   }
   if (data["+y+x"]) {
      base = find_adjacent_terrain(_width + 1, _height + 1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c - _width,
                                            y_c - _height, z_c,
                                            distance);
         }
      }
   }
   if (data["+y-x"]) {
      base = find_adjacent_terrain(-1, _height + 1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c + _width,
                                            y_c - _height, z_c,
                                            distance);
         }
      }
   }
   if (data["-y-x"]) {
      base = find_adjacent_terrain(-1, -1);
      if (base) {
         if (!load_object(base)) {
            debug_printf("Unable to load %O\n", base);
         } else {
            base->query_player_map_internal(map, key, colours, x_c + _width,
                                            y_c + _height, z_c,
                                            distance);
         }
      }
   }
   y_c -= y_c - distance;
   x_c -= x_c - distance;
   if(!this_player()->query_property(PLAYER_PLAIN_MAPS)) {
     colour_key = ([ ]);
     map[y_c][x_c] = "%^YELLOW%^@%^RESET%^";
     for(i=0; i<sizeof(map); i++) {
       current = "";
       for(j=0; j<sizeof(map); j++) {
         if(map[i][j] == "\r")
           map[i][j] = " ";
         if(!current || current == " ") current = "";
         if(!colours[i][j] || colours[i][j] == " ") colours[i][j] = "";
         if(key[map[i][j]])
           colour_key[colours[i][j] + map[i][j] + "%^RESET%^"] =
             key[map[i][j]];
         if(colours[i][j] != current) {
           if(colours[i][j] == "") {
             if(current != "" && current != " ") {
               map[i][j] = "%^RESET%^" + map[i][j];
               current = "";
             }
           } else if(colours[i][j] != "\r") {
             map[i][j] = colours[i][j] + map[i][j];
             current = colours[i][j];
           }
         }
         if(i == x_c && j == y_c && current != "")
           map[i][j] += current;
       }
       if(current)
         map[i][j-1] += "%^RESET%^";
     }
   } else {
     map[y_c][x_c] = "@";
     colour_key = key;
   }
   if(_key) {
     keys = ({ });
     foreach(item in keys(colour_key)) {
       keys += map(explode(sprintf("%s %-=40s", item, colour_key[item]), "\n"),
                           (: "     " + $1 :));
     }
   }
   ret = "";
   for(i = sizeof(map) - 1; i >= 0; i--) {
     ret += implode(map[i], "");
     if(sizeof(map)-2-i>= 0 && sizeof(map)-2-i < sizeof(keys))
       ret += keys[sizeof(map)-2-i];
     ret += "\n";
   }
   if(this_player()->query_property(PLAYER_PLAIN_MAPS))
     ret = replace_string(ret, "\r", " ");
   return ret;
}
class char_map_data query_char_map_real_coord(int x, int y)
{
   class coord our;
   our = query_terrain_from_real_coord(x, y, 0);
   return query_char_map(our->x, our->y);
}
object *query_rooms_in_zone(string zone)
{
   if (_room_zones[zone]) {
      _room_zones[zone] -= ({ 0 });
      return _room_zones[zone];
   }
   return ({ });
}
varargs void tell_zones(mixed zones, string message, mixed mess_class)
{
   object  *rooms = ({ });
   string  zone;
   if (!mess_class)
      mess_class = "zone_shout";
   if (stringp(zones))
      zones = ({ zones });
   foreach (zone in zones)
      rooms += query_rooms_in_zone(zone);
   if (sizeof(rooms))
      message(mess_class, message, rooms);
}
varargs void tell_feature(string title, mixed message)
{
   int     index;
   string  mess_class = sprintf("feature:%s", title);
   if (!_feature_rooms[title]) {
      return;
   }
   _feature_rooms[title] -= ({ 0 });
   if (!sizeof(_feature_rooms[title])) {
      return;
   }
   if (stringp(message)) {
      message(mess_class, message, _feature_rooms[title]);
   }
   if (arrayp(message)) {
      for (index = 0; index < sizeof(message); index++) {
         message(sprintf("%s:%d", mess_class, index), message[index],
         _feature_rooms[title]);
      }
   }
}
varargs string* query_distant_feature_desc(string title, mapping direcs,
                                           int visibility) {
   int       night = (WEATHER->query_tod() == "night");
   string str;
   str = title->calc_feature_desc(direcs, night, visibility);
   if (str) {
      return ({ str });
   }
   return ({ });
}
varargs string* query_feature_desc(string title, mapping direcs,
                                   int visibility) {
   class feature_data   feature;
   string*   item_desc;
   string*   dirs;
   int       night = (WEATHER->query_tod() == "night");
   string    direc;
   int       range;
   mapping   bits;
   int       index;
   string    str;
   int       new_range;
   if (!feature) {
      feature = _features[title];
   }
   if (!feature) {
      return ({ });
   }
   if( visibility == 0 ) {
      return ({ });
   }
   if (!sizeof(feature->descs)) {
      str = feature->feature_ob->calc_feature_desc(direcs, night,
                                                       visibility);
      if (str) {
         return ({ str });
      }
      return ({ });
   }
   bits = ([ ]);
   foreach (direc, range in direcs) {
      if (night) {
         item_desc = feature->night_descs;
      } else {
         item_desc = feature->descs;
      }
      if (!item_desc) {
         debug_printf("Bad night description for %O", title);
         continue;
      }
      new_range = range * 100 / visibility;
      if (feature->range > new_range && sizeof(item_desc)) {
         index = sizeof(item_desc) * new_range / feature->range;
         str = item_desc[index];
         if (str && str != "") {
            if (!bits[str]) {
               bits[str] = ({ });
            }
            bits[str] += ({ direc });
         }
      }
   }
   item_desc = ({ });
   foreach (str, dirs in bits) {
      item_desc += ({ replace_string(str, "$D", query_multiple_short(dirs)) });
   }
   return item_desc;
}
varargs string query_feature_item_desc(string title) {
   class feature_data   feature;
   mixed   item_desc;
   int       night = (WEATHER->query_tod() == "night");
   if (!feature) {
      feature = _features[title];
   }
   if (!feature) {
      return "";
   }
   if (night) {
      item_desc = feature->f_item_night_desc;
   } else {
      item_desc = feature->f_item_desc;
   }
   if (!pointerp(item_desc)) {
      return item_desc;
   }
   return item_desc[0];
}
varargs string get_a_feature_chat(string title, int range, string direc)
{
   class feature_data   feature;
   mixed     chat;
   int       night = (WEATHER->query_tod() == "night");
   if (!feature) {
      feature = _features[title];
   }
   if (!feature) {
      return "";
   }
   if (night) {
      chat = feature->night_chats;
   } else {
      chat = feature->chats;
   }
   if (!chat) {
      return "";
   }
   if (arrayp(chat)) {
      chat = chat[random(sizeof(chat))];
   }
   if (arrayp(chat)) {
      if ((range < 0) || (range >= sizeof(chat))) {
         return "";
      }
      chat = chat[range];
   }
   if (!stringp(chat)) {
      return "";
   }
   if (direc) {
      chat = replace(chat, ({ "$D", direc }));
   }
   return chat;
}
string get_an_outside_chat(string types)
{
   class char_map_data   item;
   string    *chats = ({ });
   int       index;
   mixed     *item_chats;
   for (index = 0; index < sizeof(types); index++) {
      item = _char_map[types[index..index]];
      if (!item) {
         continue;
      }
      item_chats = item->chats;
      if (!item_chats) {
         continue;
      }
      if (stringp(item_chats))
         chats += ({ item_chats });
      else if (arrayp(item_chats))
         chats += item_chats;
   }
   if (!sizeof(chats))
      return "";
   return chats[random(sizeof(chats))];
}
varargs void add_obstacle_type(string type, string description, mixed items, mixed item_desc, string room_desc)
{
   if (!type) {
      throw("Bad type");
   }
   if (!items) {
      items = ({ });
      item_desc = ({ });
   }
   if (!room_desc) {
      room_desc = "Obstacle";
   }
   _char_map[type] = new(class char_map_data,
                         type: AREA_OBSTACLE, adjacent_desc:description,
                         room_desc : room_desc,
                         items:items, item_desc:item_desc);
}
void add_special_type(string type, string base_path, int size, int road_skip, int height,
                      mapping height_rooms)
{
   _char_map[type] = new(class char_map_data,
                         type: AREA_ROOM, path:base_path,
                         room_jump : size,
                         room_jump_matching : road_skip,
                         height : height,
                         height_rooms : height_rooms);
}
void add_room_type(string type, string base_path)
{
   _char_map[type] = new(class char_map_data,
                         type: AREA_ROOM, path:base_path);
}
varargs void add_road_type(string type, string base_path, string room_desc,
              string description, mixed items, mixed item_desc)
{
   _char_map[type] = new(class char_map_data,
                        type: AREA_ROAD, adjacent_desc:description,
                        items:items, item_desc:item_desc,
                        room_desc:room_desc, path:base_path);
}
varargs void add_world_room_type(string type, string base_path) {
   mapping bits;
   string *tmp;
   if(file_size(base_path + ".c") == -1) {
     tmp = explode(base_path, "_edge");
     if(sizeof(tmp) && file_size(tmp[0] + ".c") > 0) {
       debug_printf("%s doesn't exist, using %s",
                    base_path, tmp[0]);
       base_path = tmp[0];
     }
   }
   if (file_size(base_path + ".c") > 0) {
      bits = base_path->query_adjacent_items();
      if (!mapp(bits)) {
         debug_printf("Incorrect room type %O", type);
      } else {
         _char_map[type] = new(class char_map_data,
                        type: AREA_WORLD,
                        path: base_path,
                        adjacent_desc:base_path->query_adjacent_description(),
                        items:keys(bits),
                        item_desc:values(bits),
                         room_jump : base_path->query_room_jump_size(),
                         height : base_path->query_default_height(),
                         room_jump_matching : base_path->query_follow_road());
      }
   } else {
      debug_printf("Unable to add %O since %O doesn't exist.", type, base_path);
   }
}
varargs void add_road_special_type(string type, string base_path,
              int size, int road_skip, int height,
              string room_desc,
              string description, mixed items, mixed item_desc,
              mapping height_rooms)
{
   _char_map[type] = new(class char_map_data,
                        type: AREA_ROAD, adjacent_desc:description,
                        items:items, item_desc:item_desc,
                        room_desc:room_desc, path:base_path,
                         room_jump : size,
                         height : height,
                         height_rooms : height_rooms,
                         room_jump_matching : road_skip);
}
varargs void add_exit_at(int x, int y, string direc, string dest,
                         string type, mixed modifiers)
{
   string   title = sprintf("%d:%d:%d", x, y, 0);
   if (!dest)
      return;
   if (!type)
      type = "road";
   if (!_standard_exits[title])
      _standard_exits[title] = ({ });
   _standard_exits[title] += ({ ([ "direc":direc, "dest":dest,
                                   "type":type, "modifiers":modifiers ]) });
}
varargs void add_z_exit_at(int x, int y, int z, string direc, string dest,
                         string type, mixed modifiers)
{
   string   title = sprintf("%d:%d:%d", x, y, z);
   if (!dest)
      return;
   if (!type)
      type = "road";
   if (!_standard_exits[title])
      _standard_exits[title] = ({ });
   _standard_exits[title] += ({ ([ "direc":direc, "dest":dest,
                                   "type":type, "modifiers":modifiers ]) });
}
void set_random_desc_limit(int new_limit)
{
   _random_desc_limit = new_limit;
}
void set_random_chat_limit(int new_limit)
{
   _random_chat_limit = new_limit;
}
void add_random_desc(string types, string description, mixed items, mixed item_desc)
{
   int   index;
   for (index = 0; index < sizeof(types); index++) {
      if (!_random_descs[types[index..index]])
         _random_descs[types[index..index]] = ({ });
      _random_descs[types[index..index]] += ({ ([ "desc": description,
                               "items":items, "item_desc":item_desc ]) });
   }
}
void add_random_chat(string types, string *chats)
{
   int   index;
   for (index = 0; index < sizeof(types); index++) {
      if (!_random_chats[types[index..index]])
         _random_chats[types[index..index]] = ({ });
      _random_chats[types[index..index]] += chats;
   }
}
void set_external_chats(string type, mixed chats)
{
   if (!_char_map[type]) {
      return;
   }
   ((class char_map_data)_char_map[type])->chats = chats;
}
void add_feature(string title, int x, int y, int width, int height,
                 int range, string *descs, mixed items, mixed item_desc,
                 string* night_descs,
                 mixed night_items)
{
   object region;
   object feature;
   region = clone_object(TERRAIN_MAP_REGION_RECTANGULAR);
   region->add_feature_position(x, y, width, height);
   feature = clone_object(TERRAIN_MAP_FEATURE_BASE);
   feature->set_region(region);
   feature->set_max_day_range(range);
   feature->set_max_night_range(range);
   _features[title] = new(class feature_data,
                         range:range, descs:descs,
                         f_items:items, f_item_desc:item_desc,
                         f_item_night_desc : night_items,
                         whole_sentance:1,
                         feature_ob : feature,
                         night_descs : night_descs);
}
void add_feature_sentance(string title, int x, int y, int width, int height,
                 int range, string *descs, mixed items, mixed item_desc,
                 string* night_descs, mixed night_items)
{
   object region;
   object feature;
   region = clone_object(TERRAIN_MAP_REGION_RECTANGULAR);
   region->add_feature_position(x, y, width, height);
   feature = clone_object(TERRAIN_MAP_FEATURE_BASE);
   feature->set_region(region);
   feature->set_max_day_range(range);
   feature->set_max_night_range(range);
   _features[title] = new(class feature_data,
                         feature_ob : feature,
                         range:range, descs:descs,
                         f_items:items, f_item_desc:item_desc,
                         f_item_night_desc : night_items,
                         whole_sentance:0,
                         night_descs : night_descs);
}
void add_feature_region(string title, object region,
                 int range, string *descs, mixed items, mixed item_desc,
                 string* night_descs,
                 mixed night_items,
                 int whole_sentance)
{
   object feature;
   feature = clone_object(TERRAIN_MAP_FEATURE_BASE);
   feature->set_region(region);
   feature->set_max_day_range(range);
   feature->set_max_night_range(range);
   _features[title] = new(class feature_data,
                         range:range, descs:descs,
                         f_items:items, f_item_desc:item_desc,
                         whole_sentance:whole_sentance,
                         f_item_night_desc : night_items,
                         feature_ob : feature,
                         night_descs : night_descs);
}
void add_feature_ob(string title, object feature) {
   if (_real_coords && _real_coords->xdiff) {
      feature->set_distance_multiplier(_real_coords->xdiff);
   }
   _features[title] = new(class feature_data,
                          f_items : feature->query_items(),
                          f_item_desc : feature->query_day_items(),
                          f_item_night_desc : feature->query_night_items(),
                          feature_ob : feature);
}
varargs void modify_feature(string title, string *descs, mixed item_desc)
{
   if (!_features[title]) {
      return;
   }
   if (descs) {
      _features[title]->descs = descs;
   }
   if (item_desc) {
      _features[title]->f_item_desc = item_desc;
   }
}
void set_feature_chats(string title, mixed *chats, mixed* night_chats)
{
   if (!_features[title]) {
      return;
   }
   ((class feature_data)_features[title])->chats = chats;
   ((class feature_data)_features[title])->night_chats = night_chats;
}
void remove_feature(string title)
{
   object room;
   if (!_features[title]) {
      return;
   }
   map_delete(_features, title);
   if (!_feature_rooms[title]) {
      return;
   }
   _feature_rooms[title] -= ({ 0 });
   foreach(room in _feature_rooms[title]) {
      room->remove_feature(title);
   }
   map_delete(_feature_rooms, title);
}
void add_sign(int x, int y, string sign_long, mixed sign_read_mess,
              string sign_short, mixed sign_name, string sign_language)
{
   string   title = sprintf("%d:%d", x, y);
   _signposts[title] = new(class sign_data,
                         long:sign_long, read_mess:sign_read_mess,
                         short:sign_short, name:sign_name,
                         language:sign_language);
}
void add_zones(string type, string *zone_names)
{
   _zone_types[type] = zone_names;
}
void reset_handler()
{
   mixed *rooms;
   if (arrayp(_room_map)) {
      foreach(rooms in _room_map) {
         rooms->dest_me();
      }
   }
   _room_map = 0;
   _area_map = 0;
   setup_area_map();
}
void load_zone_map()
{
   string   map_path = query_map_file() + ".zones";
   int      index = 1;
   string   line;
   int      width;
   int      height;
   _zone_map = ({ });
   while (line = read_file(map_path, index++, 1)) {
      if (width < sizeof(line))
         width = sizeof(line);
      _zone_map += ({ line });
   }
   height = index - 1;
   if ((width != _width) || (height != _height))
      _zone_map = ({ });
}
void load_area_map()
{
   string   map_path = query_map_file() + ".map";
   int      index = 1;
   int      height;
   string   line;
   _area_map = ({ });
   while (line = read_file(map_path, index++, 1)) {
      if (sizeof(line)) {
         line = line[0..<2];
         if (_width < sizeof(line)) {
            _width = sizeof(line);
         }
         _area_map = ({ line }) + _area_map;
         height++;
      }
   }
   _height = height;
   if (!height) {
      printf("Unable to open %O\n", map_path);
   }
}
object create_virtual_object(string x_str, string y_str, string z_str)
{
   int x = to_int(x_str);
   int y = to_int(y_str);
   int z = to_int(z_str);
   if (!stringp(x_str) || !stringp(y_str) || !stringp(z_str)) {
      return 0;
   }
   return query_room(x, y, z);
}
string find_room_at_real_coord(int x, int y, int z) {
   class char_map_data room_map;
   class coord our;
   our = query_terrain_from_real_coord(x, y, z);
   if (!our) {
      return 0;
   }
   room_map = query_char_map(our->x, our->y);
   if (!room_map) {
      debug_printf("Unable to load room at %d %d (%d %d)\n", our->x, our->y, x, y);
      return 0;
   }
   if (room_map->type == AREA_OBSTACLE) {
      return 0;
   }
   return sprintf("%s:%d:%d:%d", base_name(this_object()), our->x, our->y, our->z);
}
int query_direction_distance(string dir) {
  switch (_direcs[dir][3]) {
   case X_DIFF :
      return _real_coords->xdiff;
   case Y_DIFF :
      return _real_coords->ydiff;
   case XY_DIFF :
      return _real_coords->xydiff;
   }
   return 0;
}
void dest_me() {
   class feature_data womble;
   string name;
   foreach (name, womble in _features) {
      if (womble->feature_ob) {
         womble->feature_ob->dest_me();
      }
   }
   destruct(this_object());
}

==================================================
FILE: room/inherit/terrain_map/inside_base.c
==================================================

#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>
inherit "/std/room/basic_room";
inherit TERRAIN_MAP_ROOM_BASE;
void create() {
   set_not_replaceable(1);
   terrain_room::create();
   basic_room::create();
}
void init() {
   terrain_room::init();
   basic_room::init();
}
varargs mixed* query_dest_other(string exit) {
   mixed* data;
   data = basic_room::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}
mixed* query_dest_dir(object thing) {
   mixed* data;
   data = basic_room::query_dest_dir(thing);
   return terrain_room::query_dest_dir();
}
mixed stats() {
   return basic_room::stats() + terrain_room::stats();
}

==================================================
FILE: room/inherit/terrain_map/outside_base.c
==================================================

#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>
inherit "/std/room/outside";
inherit TERRAIN_MAP_ROOM_BASE;
void create() {
   set_not_replaceable(1);
   do_setup++;
   terrain_room::create();
   outside::create();
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
     this_object()->reset();
   }
}
void init() {
   terrain_room::init();
   outside::init();
}
varargs mixed* query_dest_other(string exit) {
   mixed* data;
   data = outside::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}
mixed* query_dest_dir(object thing) {
   mixed* data;
   data = outside::query_dest_dir(thing);
   return terrain_room::query_dest_dir(data);
}
mixed stats() {
   return outside::stats() + terrain_room::stats();
}
void dest_me() {
  terrain_room::dest_me();
  outside::dest_me();
}

==================================================
FILE: room/inherit/terrain_map/region_line.c
==================================================

inherit "/std/room/inherit/terrain_map/geometry";
class vertex {
   int x;
   int y;
}
private mixed    *_feature_direcs = ({ ({ "southwest", "south", "southeast" }),
                               ({ "west", "Oops", "east" }),
                               ({ "northwest", "north", "northeast" }) });
private class vertex* _vertexes = ({ });
void add_vertex(int x, int y) {
   class vertex vertex;
   vertex = new(class vertex, x : x, y : y);
   _vertexes += ({ vertex });
}
mapping query_feature_desc_from(int x, int y, int z) {
   class vertex vert1;
   class vertex vert2;
   int i;
   float v1_x;
   float v1_y;
   float v2_x;
   float v2_y;
   float vm_x;
   float vm_y;
   float b;
   float dot1;
   float dot2;
   float min_distance;
   float distance;
   float xmod;
   float ymod;
   int xd;
   int yd;
   string direc;
   mapping dirs;
   class point p;
   dirs = ([ ]);
   for (i = 0; i < sizeof(_vertexes) - 1; i++) {
      vert1 = _vertexes[i];
      vert2 = _vertexes[(i + 1) % sizeof(_vertexes)];
      v1_x = to_float(vert1->x - vert2->x);
      v1_y = to_float(vert1->y - vert2->y);
      v2_x = to_float(x - vert2->x);
      v2_y = to_float(y - vert2->y);
      dot1 = v1_x * v2_x + v1_y * v2_y;
      if (dot1 <= 0.0) {
         distance = sqrt(pow(vert2->x - x, 2) + pow(vert2->y - y, 2));
         if ((!min_distance || distance < min_distance) && distance > 0.0001) {
            xmod = ((vert2->x - x) < 0) ? -0.5 : 0.5;
            ymod = ((vert2->y - y) < 0) ? -0.5 : 0.5;
            xd = to_int(xmod + to_float(vert2->x - x) / distance) + 1;
            yd = to_int(ymod + to_float(vert2->y - y) / distance) + 1;
            direc = _feature_direcs[yd][xd];
            min_distance = distance;
         }
      } else {
         dot2 = v1_x * v1_x + v1_y * v1_y;
         if (dot2 <= dot1) {
            distance = sqrt(pow(vert1->x - x, 2) + pow(vert1->y - y, 2));
            if ((!min_distance || distance < min_distance) && distance > 0.0001) {
               xmod = ((vert1->x - x) < 0) ? -0.5 : 0.5;
               ymod = ((vert1->y - y) < 0) ? -0.5 : 0.5;
               xd = to_int(xmod + to_float(vert1->x - x) / distance) + 1;
               yd = to_int(ymod + to_float(vert1->y - y) / distance) + 1;
               direc = _feature_direcs[yd][xd];
               min_distance = distance;
            }
         } else {
            b = dot1 / dot2;
            vm_x = to_float(vert2->x) + b * v1_x;
            vm_y = to_float(vert2->y) + b * v1_y;
            distance = sqrt(pow(vm_x - x, 2) + pow(vm_y - y, 2));
            if ((!min_distance || distance < min_distance) && distance > 0.0001) {
               xmod = ((vm_x - x) < 0) ? -0.5 : 0.5;
               ymod = ((vm_y - y) < 0) ? -0.5 : 0.5;
               xd = to_int(xmod + to_float(vm_x - x) / distance) + 1;
               yd = to_int(ymod + to_float(vm_y - y) / distance) + 1;
               direc = _feature_direcs[yd][xd];
               min_distance = distance;
            }
         }
      }
      p = intersection_of_line_and_segment(0,0, 1,0, vert1->x, vert1->y,
                                           vert2->x, vert2->y);
      if (p) {
         if (p->x > x) {
            if (dirs["east"] && dirs["east"] > p->x) {
               dirs["east"] = p->x;
            }
         } else {
            if (dirs["west"] && dirs["west"] > p->x) {
               dirs["west"] = p->x;
            }
         }
      }
      p = intersection_of_line_and_segment(0,0, 0,1, vert1->x, vert1->y,
                                           vert2->x, vert2->y);
      if (p) {
         if (p->y > y) {
            if (dirs["north"] && dirs["north"] > p->y) {
               dirs["north"] = to_int(p->y);
            }
         } else {
            if (dirs["south"] && dirs["south"] > p->y) {
               dirs["south"] = to_int(p->y);
            }
         }
      }
      p = intersection_of_line_and_segment(0,0, 1,1, vert1->x, vert1->y,
                                           vert2->x, vert2->y);
      if (p) {
         if (p->x > x) {
            if (dirs["northeast"] && dirs["northeast"] > p->x) {
               dirs["northeast"] = to_int(p->x);
            }
         } else {
            if (dirs["southwest"] && dirs["southwest"] > p->x) {
               dirs["southwest"] = to_int(p->x);
            }
         }
      }
      p = intersection_of_line_and_segment(0,0, 1,-1, vert1->x, vert1->y,
                                           vert2->x, vert2->y);
      if (p) {
         if (p->y > y) {
            if (dirs["northwest"] && dirs["northwest"] > p->y) {
               dirs["northwest"] = p->y;
            }
         } else {
            if (dirs["southeast"] && dirs["southeast"] > p->y) {
               dirs["southeast"] = p->y;
            }
         }
      }
   }
   dirs[direc] = to_int(min_distance);
   return dirs;
}
int is_inside_region(int x1, int y1, int x2, int y2, int range) {
   class vertex vertex;
   class vertex vert1;
   class vertex vert2;
   int i;
   foreach (vertex in _vertexes) {
      if (vertex->x >= x1 && vertex->x <= x2 &&
          vertex->y >= y1 && vertex->y <= y2) {
         return 1;
      }
   }
   for (i = 0; i < sizeof(_vertexes); i++) {
      vert1 = _vertexes[i];
      vert2 = _vertexes[(i + 1) % sizeof(_vertexes)];
      if (distance_between_two_line_segments(x1, y1, x1, y2,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x1, y1, x2, y1,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x2, y1, x2, y2,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x1, y2, x2, y2,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
   }
   return 0;
}
void dest_me() {
   destruct(this_object());
}

==================================================
FILE: room/inherit/terrain_map/region_poly.c
==================================================

inherit "/std/room/inherit/terrain_map/geometry";
class vertex {
   int x;
   int y;
}
private mixed    *_feature_direcs = ({ ({ "southwest", "south", "southeast" }),
                               ({ "west", "Oops", "east" }),
                               ({ "northwest", "north", "northeast" }) });
private class vertex* _vertexes = ({ });
private int _inside;
void set_inside(int flag) {
   _inside = flag;
}
void add_vertex(int x, int y) {
   class vertex vertex;
   vertex = new(class vertex, x : x, y : y);
   _vertexes += ({ vertex });
}
mapping query_feature_desc_from(int x, int y, int z, int only_shortest) {
   class vertex vert1;
   class vertex vert2;
   int i;
   float v1_x;
   float v1_y;
   float v2_x;
   float v2_y;
   float vm_x;
   float vm_y;
   float b;
   float dot1;
   float dot2;
   float min_distance;
   float distance;
   float xmod;
   float ymod;
   int xd;
   int yd;
   string direc;
   int counter;
   mapping dirs;
   class point p;
   dirs = ([ ]);
   if (_vertexes[0]->y == y && _vertexes[0]->x == x) {
      return 0;
   }
   for (i = 0; i < sizeof(_vertexes); i++) {
      vert1 = _vertexes[i];
      vert2 = _vertexes[(i + 1) % sizeof(_vertexes)];
      v1_x = to_float(vert1->x - vert2->x);
      v1_y = to_float(vert1->y - vert2->y);
      v2_x = to_float(x - vert2->x);
      v2_y = to_float(y - vert2->y);
      if (vert2->y == y && vert2->x == x) {
         return 0;
      }
      if (vert1->y == vert2->y) {
         if (y == vert1->y &&
             ((vert1->x <= x && x <= vert2->x) ||
              (vert1->x >= x && x >= vert2->x))) {
            return 0;
         }
      }
      if ((((vert1->y < y) && (y <= vert2->y)) ||
           ((vert2->y < y) && (y <= vert1->y))) &&
          (x < (vert2->x - vert1->x) * (y - vert1->y) / (vert2->y - vert1->y) + vert1->x)) {
         counter = !counter;
      }
      dot1 = v1_x * v2_x + v1_y * v2_y;
      if (dot1 <= 0.0) {
         distance = sqrt(pow(vert2->x - x, 2) + pow(vert2->y - y, 2));
         if (distance <= 0.0001) {
            return 0;
         }
         if ((!min_distance || distance < min_distance) && distance > 0.0001) {
            xmod = ((vert2->x - x) < 0) ? -0.5 : 0.5;
            ymod = ((vert2->y - y) < 0) ? -0.5 : 0.5;
            xd = to_int(xmod + to_float(vert2->x - x) / distance) + 1;
            yd = to_int(ymod + to_float(vert2->y - y) / distance) + 1;
            direc = _feature_direcs[yd][xd];
            min_distance = distance;
         }
      } else {
         dot2 = v1_x * v1_x + v1_y * v1_y;
         if (dot2 <= dot1) {
            distance = sqrt(pow(vert1->x - x, 2) + pow(vert1->y - y, 2));
            if (distance <= 0.0001) {
               return 0;
            }
            if ((!min_distance || distance < min_distance) && distance > 0.0001) {
               xmod = ((vert1->x - x) < 0) ? -0.5 : 0.5;
               ymod = ((vert1->y - y) < 0) ? -0.5 : 0.5;
               xd = to_int(xmod + to_float(vert1->x - x) / distance) + 1;
               yd = to_int(ymod + to_float(vert1->y - y) / distance) + 1;
               direc = _feature_direcs[yd][xd];
               min_distance = distance;
            }
         } else {
            b = dot1 / dot2;
            vm_x = to_float(vert2->x) + b * v1_x;
            vm_y = to_float(vert2->y) + b * v1_y;
            distance = sqrt(pow(vm_x - x, 2) + pow(vm_y - y, 2));
            if (distance <= 0.0001) {
               return 0;
            }
            if ((!min_distance || distance < min_distance) && distance > 0.0001) {
               xmod = ((vm_x - x) < 0) ? -0.5 : 0.5;
               ymod = ((vm_y - y) < 0) ? -0.5 : 0.5;
               xd = to_int(xmod + to_float(vm_x - x) / distance) + 1;
               yd = to_int(ymod + to_float(vm_y - y) / distance) + 1;
               direc = _feature_direcs[yd][xd];
               min_distance = distance;
            }
         }
      }
      if (!only_shortest) {
         p = intersection_of_line_and_segment(0,0, 1,0, vert1->x, vert1->y,
                                              vert2->x, vert2->y);
         if (p) {
            if (p->x > x) {
               if (dirs["east"] && dirs["east"] > p->x) {
                  dirs["east"] = p->x;
               }
            } else {
               if (dirs["west"] && dirs["west"] > p->x) {
                  dirs["west"] = p->x;
               }
            }
         }
         p = intersection_of_line_and_segment(0,0, 0,1, vert1->x, vert1->y,
                                              vert2->x, vert2->y);
         if (p) {
            if (p->y > y) {
               if (dirs["north"] && dirs["north"] > p->y) {
                  dirs["north"] = to_int(p->y);
               }
            } else {
               if (dirs["south"] && dirs["south"] > p->y) {
                  dirs["south"] = to_int(p->y);
               }
            }
         }
         p = intersection_of_line_and_segment(0,0, 1,1, vert1->x, vert1->y,
                                              vert2->x, vert2->y);
         if (p) {
            if (p->x > x) {
               if (dirs["northeast"] && dirs["northeast"] > p->x) {
                  dirs["northeast"] = to_int(p->x);
               }
            } else {
               if (dirs["southwest"] && dirs["southwest"] > p->x) {
                  dirs["southwest"] = to_int(p->x);
               }
            }
         }
         p = intersection_of_line_and_segment(0,0, 1,-1, vert1->x, vert1->y,
                                              vert2->x, vert2->y);
         if (p) {
            if (p->y > y) {
               if (dirs["northwest"] && dirs["northwest"] > p->y) {
                  dirs["northwest"] = p->y;
               }
            } else {
               if (dirs["southeast"] && dirs["southeast"] > p->y) {
                  dirs["southeast"] = p->y;
               }
            }
         }
      }
   }
   if (counter != _inside) {
      return 0;
   }
   dirs[direc] = to_int(min_distance);
   return dirs;
}
int is_inside_region(int x1, int y1, int x2, int y2, int range) {
   class vertex vertex;
   class vertex vert1;
   class vertex vert2;
   int i;
   foreach (vertex in _vertexes) {
      if (vertex->x >= x1 && vertex->x <= x2 &&
          vertex->y >= y1 && vertex->y <= y2) {
         return 1;
      }
   }
   for (i = 0; i < sizeof(_vertexes); i++) {
      vert1 = _vertexes[i];
      vert2 = _vertexes[(i + 1) % sizeof(_vertexes)];
      if (distance_between_two_line_segments(x1, y1, x1, y2,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x1, y1, x2, y1,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x2, y1, x2, y2,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
      if (distance_between_two_line_segments(x1, y2, x2, y2,
          vert1->x, vert1->y, vert2->x, vert2->y) < range) {
         return 1;
      }
   }
   return 0;
}
void dest_me() {
   destruct(this_object());
}

==================================================
FILE: room/inherit/terrain_map/region_rect.c
==================================================

inherit "/std/room/inherit/terrain_map/geometry";
class feature_pos {
   int xstart;
   int ystart;
   int width;
   int height;
}
private mixed    *_feature_direcs = ({ ({ "southwest", "south", "southeast" }),
                               ({ "west", "Oops", "east" }),
                               ({ "northwest", "north", "northeast" }) });
private class feature_pos* _positions = ({ });
void add_feature_position(int x, int y, int width, int height) {
   class feature_pos pos;
   pos = new(class feature_pos, xstart : x, ystart : y,
                                width : width, height : height);
   _positions += ({ pos });
}
mapping query_feature_desc_from(int x, int y, int z) {
   int h;
   int v;
   int width;
   int height;
   float distance;
   float min_distance;
   string direc;
   class feature_pos pos;
   float xmod;
   float ymod;
   int xd;
   int yd;
   foreach (pos in _positions) {
      h = pos->xstart;
      v = pos->ystart;
      width = pos->width;
      height = pos->height;
      if (x >= (h + width)) {
         h = h + width - 1;
      } else if (x >= h) {
         h = x;
      }
      if (y >= (v + height)) {
         v = v + height - 1;
      } else if (y >= v) {
         v = y;
      }
      distance = sqrt(pow(x - h, 2) + pow(y - v, 2));
      if (distance > 0.0000001 && (distance < min_distance || !min_distance)) {
         xmod = ((h - x) < 0) ? -0.5 : 0.5;
         ymod = ((v - y) < 0) ? -0.5 : 0.5;
         xd = to_int(xmod + to_float(h - x) / distance) + 1;
         yd = to_int(ymod + to_float(v - y) / distance) + 1;
         direc = _feature_direcs[yd][xd];
         min_distance = distance;
      }
   }
   if (!direc) {
      return ([ ]);
   }
   return ([ direc : to_int(min_distance) ]);
}
void dest_me() {
   destruct(this_object());
}
int is_inside_region(int x1, int y1, int x2, int y2, int range) {
   class feature_pos position;
   int height;
   int width;
   foreach (position in _positions) {
      height = position->height;
      width = position->width;
      if (position->xstart >= x1 && position->xstart <= x2 &&
          position->ystart >= y1 && position->ystart <= y2) {
         return 1;
      }
      if (position->xstart >= x1 && position->xstart <= x2 &&
          position->ystart + height >= y1 && position->ystart + height <= y2) {
         return 1;
      }
      if (position->xstart +width >= x1 && position->xstart +width <= x2 &&
          position->ystart + height >= y1 && position->ystart + height <= y2) {
         return 1;
      }
      if (position->xstart +width >= x1 && position->xstart +width <= x2 &&
          position->ystart >= y1 && position->ystart <= y2) {
         return 1;
      }
   }
   return 0;
}

==================================================
FILE: room/inherit/terrain_map/simple_feature.c
==================================================

#include <terrain_map.h>
inherit TERRAIN_MAP_FEATURE_BASE;
private string _base_desc;
private int _very_close_distance;
private int _distance_multiplier = 1;
void set_very_close_distance(int close) {
   _very_close_distance = close;
}
string query_base_description() {
   return _base_desc;
}
void set_base_description(string desc) {
   _base_desc = desc;
}
void set_distance_multiplier(int mult) {
   _distance_multiplier = mult;
}
string calc_feature_desc(mapping direcs, int night, int visibility) {
   string direc;
   int dist;
   int new_dist;
   string* bits;
   bits = ({ });
   if(visibility < 1 && visibility != -1)
     visibility = 1;
   foreach (direc, dist in direcs) {
      dist += query_range_offset() ;
      new_dist = dist * 100 / visibility;
      if (visibility == -1 ||
          (new_dist < query_max_range() && dist > query_min_range())) {
         if (dist < _very_close_distance) {
            bits += ({ "very close to the " + direc });
         } else {
            bits += ({ query_distance_str(dist * _distance_multiplier) + " to the " + direc });
         }
      }
   }
   if (sizeof(bits) > 1) {
      return implode(bits[0..<2], ", ") + " and " + bits[<1] + " " +_base_desc;
   }
   if (sizeof(bits)) {
      return bits[0] + " " + _base_desc;
   }
   return 0;
}
string calc_map_feature_desc(mapping direcs, int fudge) {
   string direc;
   int dist;
   string* bits;
   bits = ({ });
   foreach (direc, dist in direcs) {
      dist += query_range_offset();
      if (dist < _very_close_distance * 5) {
        bits += ({ "very close to the " + direc });
      } else {
        bits += ({ ({"approximately ", "about ", "roughly "})[random(3)] +
                     query_distance_str(dist * _distance_multiplier) +
                     " to the " + direc });
      }
   }
   if (sizeof(bits) > 1) {
      return implode(bits[0..<2], ", ") + " and " + bits[<1] + " " +_base_desc;
   }
   if (sizeof(bits)) {
      return bits[0] + " " + _base_desc;
   }
   return 0;
}

==================================================
FILE: room/inherit/terrain_map/terrain_room.c
==================================================

#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>
inherit TERRAIN_MAP_FACTORY_BASE;
#define BLOCKING_FLAG 2
#define INSTALLED_FLAG 1
private nosave int     _x_coord = -1;
private nosave int     _y_coord = -1;
private nosave int     _z_coord = -1;
private nosave int     _flag = 0;
private nosave string  _extra_long = "";
private nosave object  _map_handler;
private nosave mapping _dist_features = ([ ]);
private nosave mapping _features = ([ ]);
private nosave string  _outside_types;
private nosave string  _random_desc = 0;
private nosave object  _terrain_chatter = 0;
private nosave string* _variable_exits;
private nosave mapping _default_exits;
private nosave string  _terrain_handler;
private nosave string  _terrain_char;
varargs int add_property(string var, mixed val, int tim);
string  query_feature_item_desc(string title);
string  query_handler_path();
varargs void terrain_chat( mixed *args, object chatobj );
int do_outside_chats();
void add_zone(string zone);
void add_extra_look(object ob);
int remove_item(string word);
varargs int add_item( mixed shorts, mixed desc, int no_plural );
int* query_co_ord();
int query_visibility();
string long(string str, int dark);
string query_terrain_handler();
class feature {
   mapping direcs;
   mixed items;
   int sentance;
   int index;
   int visible;
}
void create() {
   _variable_exits = ({ });
   _default_exits = ([ ]);
   this_object()->add_help_file("terrain_room");
   ::create();
}
string long_test(string str, int dark) {
   string ret;
   string map;
   string* map_lines;
   ret = long(str, dark);
   map = query_terrain_handler()->query_player_map_template(_x_coord,
             _y_coord, _z_coord, query_visibility(), 9);
   map_lines = map(explode(map, "\n"), (: $1 + "   " :));
   ret = "$COLUMN$12=" + implode(map_lines, "\n") + "$COLUMN$" +
         ret;
   return ret;
}
int hash(int mod) {
   mixed* my_coord;
   int x;
   int y;
   int z;
   int grid;
   int val;
   string str;
   my_coord = query_co_ord();
   if (!my_coord) {
      return 0;
   }
   grid = TERRAIN_MAP_GRID_SIZE / 10;
   x = (my_coord[0]) / grid;
   y = (my_coord[1]) / grid;
   z = (my_coord[2]) / grid;
   str = "" + x + ":" + y + ":" + z;
   val = crc32(str) % mod;
   if (val < 0) {
      return - val;
   }
   return val;
}
int hash_time(int mod, int period) {
   mixed* my_coord;
   int x;
   int y;
   int z;
   int grid;
   int val;
   string str;
   my_coord = query_co_ord();
   if (!my_coord) {
      return 0;
   }
   grid = TERRAIN_MAP_GRID_SIZE / 10;
   x = (my_coord[0]) / grid;
   y = (my_coord[1]) / grid;
   z = (my_coord[2]) / grid;
   str = x + ":" + y + ":" + z + ":" + (time() /period);
   val = crc32(str) % mod;
   if (val < 0) {
      return - val;
   }
   return val;
}
string query_terrain_handler() {
   return _terrain_handler;
}
void set_terrain_handler(string handler) {
   _terrain_handler = handler;
}
mixed *query_terrain_coords() { return ({ _x_coord, _y_coord, _z_coord }); }
void create_terrain_room()
{
   _x_coord = -1;
   _y_coord = -1;
   _z_coord = -1;
   add_property("terrain_map", 1);
   add_extra_look(this_object());
   if (do_outside_chats())
      terrain_chat(({ 60, 120, ({ "#do_a_feature_chat",
                             "#do_an_outside_chat" }) }) );
}
void terrain_setup()
{
}
void set_terrain_coords(int x, int y, int z)
{
   _x_coord = x;
   _y_coord = y;
   _z_coord = z;
}
object query_map_handler()
{
   return load_object(query_terrain_handler());
}
void reset_handler()
{
   if (query_map_handler())
      query_map_handler()->reset_handler();
}
void receive_message(string mess_class, string message, string title)
{
   class    feature feature;
   if (mess_class == "feature") {
      feature = _features[title];
      if (!feature) {
         return;
      }
   } else if (mess_class == "direction") {
   }
   tell_room(this_object(), message);
}
void do_a_feature_chat()
{
   string   *chats = ({ });
   string   feature_chat;
   string   title;
   class  feature feature;
   if ((_x_coord < 0) || (_y_coord < 0)) {
      return;
   }
   foreach(title, feature in _features) {
      if (feature_chat) {
         chats += ({ feature_chat });
      }
   }
   if (sizeof(chats)) {
      tell_room(this_object(), chats[random(sizeof(chats))] + "\n");
   }
}
void do_an_outside_chat()
{
   string chat = query_map_handler()->get_an_outside_chat(_outside_types);
   if (chat && strlen(chat)) {
      tell_room(this_object(), chat + "\n");
   }
}
int can_view_adjacent_desc(string char, string key_here, string path,
                           int z, string direc) {
   return char != key_here;
}
int can_view_feature(string name)
{
   return 1;
}
int can_view_feature_from(string name, string direc, int distance)
{
   return 1;
}
int can_exit_to(string type, string direc, string base_path)
{
   return 1;
}
int can_enter_from(string type, string direc, string base_path)
{
   return 1;
}
int can_move_between(string my_type, string direc,
                     string first_type, string second_type,
                     string new_base_path)
{
   return 1;
}
string query_enter_exit_direction(string key, string key_here,
                                  string direc, object room, string base_path) {
   return 0;
}
int do_outside_chats()
{
   return 1;
}
varargs void terrain_chat( mixed *args, object chatobj ) {
   if (!args)  {
      return;
   }
   if ( !pointerp( args[ 2 ] ) ) {
      write( "Error: second argument of room_chat args is not an array.\n" );
      return;
   }
  if ( _terrain_chatter ) {
    _terrain_chatter->setup_chatter( this_object(), args );
    return;
  }
  if (objectp(chatobj)) {
    _terrain_chatter = chatobj;
    log_file("CHATTER", "%s cloned set terrain chatter: %O\n",
             file_name(this_object()), chatobj);
  } else {
    _terrain_chatter = clone_object( CHATTER_OBJECT );
    log_file("CHATTER", "%s cloned terrain chatter: %O\n",
             file_name(this_object()), _terrain_chatter);
  }
  _terrain_chatter->setup_chatter( this_object(), args );
}
void add_random_desc(string desc)
{
   if (!_random_desc) {
      _random_desc = "";
   }
   _random_desc += desc + " ";
}
void terrain_add_zone(string zone)
{
   add_zone(zone);
   query_map_handler()->add_room_to_zone(this_object(), zone);
}
string query_dest_coordinate_string(int x, int y, int z,
                                    string direc, string key) {
   return ":" + x + ":" + y + ":" + z;
}
varargs mixed *query_to_same(string type, string to_direc, string from_direc, string path_to) {
   return 0;
}
varargs mixed *query_to_other(string type, string to_direc, string from_direc, string path_to) {
   return 0;
}
varargs mixed *query_from_other(string type, string to_direc, string from_direc, string path_from) {
   return 0;
}
mixed *get_to_same(string from, string to, string type, string path_to)
{
   mixed *result = query_to_same(type, to, from);
   if (arrayp(result)) {
      return map(result, (: stringp($1)?replace($1, ({ "$T", $2, "$F", $3 }) ):$1 :), to, from);
   }
   return 0;
}
mixed *get_to_other(string from, string to, string type, string path_to)
{
   mixed *result = query_to_other(type, to, from);
   if (arrayp(result)) {
      return map(result, (: stringp($1)?replace($1, ({ "$T", $2, "$F", $3 }) ):$1 :), to, from);
   }
   return 0;
}
mixed *get_from_other(string from, string to, string type, string path_from)
{
   mixed *result = query_from_other(type, to, from);
   if (arrayp(result)) {
      return map(result, (: stringp($1)?replace($1, ({ "$T", $2, "$F", $3 }) ):$1 :), to, from);
   }
   return 0;
}
void set_extra_long(string extra)
{
   _extra_long = extra;
}
void set_outside_types(string types)
{
   _outside_types = types;
}
string query_my_real_file_name() {
   return __FILE__;
}
string extra_look() {
   string   result = _extra_long;
   string   title;
   string*   tmp;
   class  feature feature;
   int new_line;
   string* descs;
   int visibility;
   new_line = query_map_handler()->query_newline_mode();
   descs = ({ });
   visibility = query_visibility();
   foreach (title, feature in _features) {
      tmp = query_map_handler()->query_feature_desc(title,
                                          feature->direcs, visibility);
      if (sizeof(tmp)) {
         feature->visible = 1;
         descs += tmp;
      }
   }
   foreach (title, feature in _dist_features) {
      tmp = query_map_handler()->query_distant_feature_desc(title,
                                        feature, visibility);
      if (sizeof(tmp)) {
         descs += tmp;
      }
   }
   if (sizeof(descs)) {
      result += "  " + capitalize(query_multiple_short(descs)) + ".";
   }
   if (_random_desc) {
      result = result + _random_desc;
   }
   if (new_line) {
      return result;
   } else {
      return result + "\n";
   }
}
void add_feature(string title, mapping bits, mixed items, int sentance)
{
   _features[title] = new(class feature,
                          items : items, direcs : bits);
   if (items) {
      add_item(items, (: query_feature_item_desc($(title)) :));
   }
}
void add_distant_feature(string title, mapping bits) {
   _dist_features[title] = bits;
}
void remove_feature(string title)
{
   class feature  feature = _features[title];
   mixed    items;
   if (!feature) {
      return;
   }
   map_delete(_features, title);
   items = feature->items;
   if (stringp(items)) {
      remove_item(items);
   } else {
      remove_item(items[0]);
   }
}
string query_feature_item_desc(string title)
{
   if (_features[title]->visible) {
      return query_map_handler()->query_feature_item_desc(title);
   }
   return 0;
}
mapping query_features() { return _features; }
int query_installed() { return _flag & INSTALLED_FLAG; }
void set_installed() { _flag |= INSTALLED_FLAG; }
void set_terrain_map_block(int blocking) {
   if (blocking) {
      _flag |= BLOCKING_FLAG;
   } else {
      _flag &= ~BLOCKING_FLAG;
   }
}
int query_terrain_map_block() {
   return _flag & BLOCKING_FLAG;
}
void set_terrain_map_character(string terr) {
   _terrain_char = terr;
}
string query_terrain_map_character() {
   return _terrain_char;
}
string query_cloning_info()
{
  return file_name(this_object());
}
object create_virtual_object(string x_str, string y_str)
{
   int x = to_int(x_str);
   int y = to_int(y_str);
   return query_map_handler()->load_room_at(x, y);
}
void add_variable_exit(string exit) {
   _variable_exits += ({ exit });
}
void add_default_exit(string exit, string location) {
   _default_exits[exit] = location;
}
mapping query_default_exits() {
   return _default_exits;
}
string query_terrain_map_walk_exit() {
   return TERRAIN_MAP_WALK_EXIT;
}
string query_terrain_map_journey_exit() {
   return TERRAIN_MAP_JOURNEY_EXIT;
}
string query_room_path(int x, int y, int z) {
   return sprintf("%s:%d:%d:%d", query_terrain_handler(), x, y, z);
}
string query_direction_distance_str(int num, string dir) {
   int dist;
   string dist_mess;
   dist = query_map_handler()->query_direction_distance(dir);
   switch (dist) {
   case 0..2 :
      if (dist > 1) {
         dist_mess = query_num(dist) + " foot section";
      } else {
         dist_mess = "foot";
      }
      break;
   case 3..TERRAIN_MAP_ONE_MILE / 2 - 1 :
      dist /= 3;
      if (dist > 1) {
         dist_mess = query_num(dist) + " yard section";
      } else {
         dist_mess = "yard";
      }
      break;
   case TERRAIN_MAP_ONE_MILE / 2..TERRAIN_MAP_ONE_MILE - 1 :
      dist /= TERRAIN_MAP_ONE_MILE / 2;
      if (dist > 1) {
         dist_mess = query_num(dist) + " miles section";
      } else {
         dist_mess = "mile";
      }
      break;
   default:
      dist /= TERRAIN_MAP_ONE_MILE;
      if (dist > 1) {
         dist_mess = query_num(dist) + " miles section";
      } else {
         dist_mess = "mile";
      }
      break;
   }
   switch(num) {
   case 0:
      return dist_mess + " " + dir;
   case 1:
      return query_num(num) + " " + dist_mess + " " +dir;
   default:
      return query_num(num) + " " + dist_mess + "s " + dir;
   }
}
mixed* query_dest_other(string exit, mixed* data) {
   mixed* bing;
   string cur;
   string dir;
   int num;
   string* bits;
   int dist;
   if(!stringp(exit) || !_default_exits) {
     return data;
   }
   if (_default_exits[exit]) {
      if (this_player() &&
          this_player()->query_property(TERRAIN_MAP_LONG_JUMP_PROPERTY) &&
          member_array(query_terrain_map_journey_exit() + exit, _variable_exits) != -1) {
         exit = query_terrain_map_journey_exit() + exit;
      } else {
         data[ROOM_DEST] = _default_exits[exit];
         return data;
      }
   }
   if (member_array(exit, _variable_exits) != -1) {
      bing = query_map_handler()->find_next_room_from(_x_coord, _y_coord, _z_coord, exit[strlen(query_terrain_map_journey_exit())..]);
      if (bing) {
         if (data[ROOM_DEST] != bing[0]) {
            data[ROOM_DEST] = bing[0];
            bits = ({ });
            foreach (dir in bing[1..]) {
               if (dir == cur) {
                  num++;
               } else {
                  if (cur) {
                     bits += ({ query_direction_distance_str(num, cur) });
                  }
                  cur = dir;
                  num = 1;
               }
            }
            dist = query_map_handler()->query_direction_distance(dir);
            bits += ({ query_direction_distance_str(num, dir) });
            if (sizeof(bits) > 1) {
               data[ROOM_MESS] = "You arrive after having journeyed " +
                                 implode(bits[0..<2], ", ") +
                                 " and " + bits[<1] +
                                 ".\n";
            } else {
               data[ROOM_MESS] = "You arrive after having journeyed " +
                                 bits[0] +
                                 ".\n";
            }
            if (!arrayp(data[ROOM_ENTER]) ||
                !data[ROOM_ENTER][0]) {
               data[ROOM_ENTER] = "$N journey$s in from " +
                        ROOM_HANDLER->query_opposite_direction(bing[<1]) + ".\n";
            }
            if (!data[ROOM_EXIT]) {
               data[ROOM_EXIT] = "$N journey$s to the " + bing[1] + ".\n";
            }
         }
      }
   }
   return data;
}
mixed* query_dest_dir(mixed* data) {
   int i;
   int jump;
   mixed* bits;
   if (this_player() &&
       this_player()->query_property(TERRAIN_MAP_LONG_JUMP_PROPERTY)) {
      jump = 1;
   }
   if (sizeof(_variable_exits)) {
      for (i = 0; i < sizeof(data); i += 2) {
         if (_default_exits[data[i]]) {
            if (jump) {
               bits = query_map_handler()->find_next_room_from(_x_coord, _y_coord, _z_coord, data[i]);
               if (bits) {
                  data[i+1] = bits[0];
               }
            } else {
               data[i+1] = _default_exits[data[i]];
            }
         } else if (member_array(data[i], _variable_exits) != -1) {
            bits = query_map_handler()->find_next_room_from(_x_coord, _y_coord, _z_coord, data[i][strlen(query_terrain_map_journey_exit())..]);
            if (bits) {
               data[i+1] = bits[0];
            }
         }
      }
   }
   return data;
}
int do_map() {
   string map;
   map = query_map_handler()->query_debug_map(_x_coord, _y_coord, 13, _x_coord, _y_coord);
   write(map);
   add_succeeded_mess("");
   return 1;
}
int do_map_terrain() {
   string map;
   map = query_map_handler()->query_debug_map(20, 20, 40, _x_coord, _y_coord);
   write(map);
   add_succeeded_mess("");
   return 1;
}
void init()
{
   tell_creator(this_player(), "Coords: (%d, %d, %d)\n", _x_coord, _y_coord, _z_coord);
   if (this_player()->query_creator()) {
      add_command("cremap", "", (: do_map :));
      add_command("cremap", "all", (: do_map_terrain :));
   }
}
mixed stats() {
   return ::stats() +
          ({ ({ "file", query_my_real_file_name() }),
             ({ "blocking", query_terrain_map_block() }) });
}
void dest_me() {
  if(_terrain_chatter) {
    log_file("CHATTER", "%s dested terrain chatter: %O\n",
             file_name(this_object()), _terrain_chatter);
    _terrain_chatter->dest_me();
  }
}

==================================================
FILE: room/inherit/terrain_map/water_inside_base.c
==================================================

#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>
inherit "/std/room/water_inside";
inherit TERRAIN_MAP_ROOM_BASE;
void create() {
   set_not_replaceable(1);
   terrain_room::create();
   water_inside::create();
}
void init() {
   terrain_room::init();
   water_inside::init();
}
varargs mixed* query_dest_other(string exit) {
   mixed* data;
   data = water_inside::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}
mixed* query_dest_dir(object thing) {
   mixed* data;
   data = water_inside::query_dest_dir(thing);
   return terrain_room::query_dest_dir(data);
}
mixed stats() {
   return water_inside::stats() + terrain_room::stats();
}
string query_terrain_map_walk_exit() {
   return "swim ";
}
object query_surface_room() {
  string dest_path;
  object destination;
  if (query_surface()) {
    return this_object();
  }
  dest_path = file_name(this_object());
  dest_path = implode(explode(dest_path, ":")[0..<2], ":")+":0";
  destination = load_object(dest_path);
  if (destination && destination->query_water()) {
    return destination->query_surface_room();
  }
  return ::query_surface_room();
}
int get_water_surface_light() {
  float their_light, their_clarity, our_depth;
  string above_path = file_name(this_object());
  object above;
  above_path = implode(explode(above_path, ":")[0..<2], ":")+":0";
  above = load_object(above_path);
  if (!above) {
    return 0;
  }
  if (function_exists("query_water_surface_light", above)) {
    their_light = to_float(above->query_water_surface_light());
  } else {
    their_light = to_float(above->query_my_light());
  }
  their_clarity = to_float(above->query_clarity())/100.0;
  our_depth = to_float(-query_terrain_coords()[2]);
  return to_int(their_light * pow(their_clarity, our_depth));
}

==================================================
FILE: room/inherit/terrain_map/water_outside_base.c
==================================================

#include <room.h>
#include <login_handler.h>
#include <terrain_map.h>
inherit "/std/room/water_outside";
inherit TERRAIN_MAP_ROOM_BASE;
void create() {
   set_not_replaceable(1);
   terrain_room::create();
   water_outside::create();
}
void init() {
   terrain_room::init();
   water_outside::init();
}
varargs mixed* query_dest_other(string exit) {
   mixed* data;
   data = water_outside::query_dest_other(exit);
   return terrain_room::query_dest_other(exit, data);
}
mixed* query_dest_dir(object thing) {
   mixed* data;
   data = water_outside::query_dest_dir(thing);
   return terrain_room::query_dest_dir(data);
}
mixed stats() {
   return water_outside::stats() + terrain_room::stats();
}
string query_terrain_map_walk_exit() {
   return "swim ";
}
object query_surface_room() {
  string dest_path;
  object destination;
  if (query_surface()) {
    return this_object();
  }
  dest_path = file_name(this_object());
  dest_path = implode(explode(dest_path, ":")[0..<2], ":")+":0";
  destination = load_object(dest_path);
  if (destination && destination->query_water()) {
    return destination->query_surface_room();
  }
  return ::query_surface_room();
}
int get_water_surface_light() {
  float their_light, their_clarity, our_depth;
  string above_path = file_name(this_object());
  object above;
  above_path = implode(explode(above_path, ":")[0..<2], ":")+":0";
  above = load_object(above_path);
  if (!above) {
    return 0;
  }
  if (function_exists("query_water_surface_light", above)) {
    their_light = to_float(above->query_water_surface_light());
  } else {
    their_light = to_float(above->query_my_light());
  }
  their_clarity = to_float(above->query_clarity())/100.0;
  our_depth = to_float(-query_terrain_coords()[2]);
  return to_int(their_light * pow(their_clarity, our_depth));
}
string query_enter_exit_direction(string key, string key_here, string direct,
                                  object room, string base_path) {
   if (!room->query_water()) {
      return "wade " + direct;
   }
   return 0;
}
int can_move_between(string my_type, string direc,
                     string first_type, string second_type, string new_base_path)
{
   return first_type->query_water() && second_type->query_water() &&
          new_base_path->query_water() ||
          (!new_base_path->query_water() &&
           (!first_type->query_water() || !second_type->query_water()));
}

==================================================
FILE: room/inherit/carriage/carriage.c
==================================================

#include <room/carriage.h>
#define DEFAULT_WAIT 60
#define DEFAULT_TRAVEL 45
inherit "/std/room/basic_room";
private class route_details _route_info;
private string _carriage_name;
private string _exit_name;
private int _current_stop;
private int _next_stop;
private object _outside;
private object _fake_carriage;
private object _bell;
private object _car_driver;
private object _handler;
private string _n_name;
private string _p_name;
int do_ring();
string query_environ_long();
void create() {
    do_setup++;
    ::create();
    do_setup--;
    set_light(60);
    set_keep_room_loaded(1);
    set_short( "inside a carriage" );
    add_property( "no teleport", 1 );
    add_property("determinate", "");
    add_property("no map", 1);
    add_property("no godmother", 1);
   add_item("window", (: query_environ_long :) );
   add_item( "carriage", "The carriage looks fairly old and barely "
     "road worthy." );
   _bell = clone_object("/std/object");
   _bell->set_name("bell");
   _bell->set_short("bell");
   _bell->add_property("there","hanging here");
   _bell->set_long("This is a bell you could probably ring if the "
                 "driver has fallen asleep and you want the carriage to go "
                 "somewhere.\n");
   _bell->reset_get();
   _bell->reset_drop();
   _bell->move( this_object() );
   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   }
}
void init() {
  this_player()->add_command("ring", _bell, "<direct:object>", (: do_ring :) );
}
object create_carriage_driver() {
   return 0;
}
string query_carriage_name() { return _carriage_name; }
class stop_list_details query_current_stop() { return _route_info->stops[_current_stop]; }
class stop_list_details query_next_stop() { return _route_info->stops[_next_stop]; }
object query_outside() { return _outside; }
class route_details query_route_map() { return _route_info; }
int *query_stop_info() { return ({ _current_stop, _next_stop }); }
void update_route( string name,
                  class route_details new_route_info,
                  object handler)
{
   _handler = handler;
   _route_info = new_route_info;
   if (_current_stop >= sizeof(_route_info)) {
      _current_stop = _current_stop % sizeof(_route_info->stops);
   }
   _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
}
int make_carriage( string name,
                   class route_details new_route_info,
                   object handler)
{
    _handler = handler;
    _carriage_name = name;
    _route_info = new_route_info;
    _current_stop = 0;
    _next_stop = 1;
  if (!stringp( _carriage_name )) {
     log_file("NEW_CARRIAGE","%O: Invalid name: %O", this_object(),_carriage_name);
     return 0;
  }
  if (!classp( _route_info )) {
     log_file("NEW_CARRIAGE","%O: Invalid class: %O", this_object(), _route_info);
     return 0;
  }
  call_out("make_stop",5);
  _current_stop = 0;
  _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
  if(!_car_driver) {
    _car_driver = create_carriage_driver();
    if(objectp(_car_driver)) {
      _car_driver->route_setup(_carriage_name);
      _car_driver->move(this_object());
    }
  }
  return 1;
}
void make_stop() {
   string name;
   string* name_parts;
   string np;
   string n_path;
   string path;
   int travel_time;
   int stop_time;
   name = _handler->query_stop_name(_route_info->stops[ _current_stop ]->id);
   path = _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
   _p_name = name;
   travel_time = _route_info->stops[ _next_stop ]->travel_time;
   stop_time = _handler->query_stop_delay(_route_info->stops[ _current_stop ]->id);
   _n_name = _handler->query_stop_name(_route_info->stops[ _next_stop ]->id);
   n_path = _handler->query_stop_location(_route_info->stops[ _next_stop ]->id);
   _outside = load_object(path);
   if (!_outside) {
      log_file("NEW_CARRIAGE", ctime(time())+" (%O): problem with "
        + path +" (" + name + ", " + _route_info->stops[ _current_stop ]->id + ")\n", this_object());
      _route_info->stops = _route_info->stops[0.._current_stop - 1] +
                    _route_info->stops[_current_stop + 1..];
      call_out("make_stop", 1);
      return;
   }
   tell_room(this_object(), "The carriage comes to a grinding "
     "halt.\n");
   if(objectp(_car_driver) && (environment(_car_driver) == this_object())) {
     _car_driver->arrived_at_to_carriage( name, _n_name );
   } else {
     tell_room(this_object(), "The carriage has arrived at " + name + ".\n");
   }
   if (!_fake_carriage) {
     _fake_carriage = clone_object("/std/object");
     _fake_carriage->set_name("carriage");
     _fake_carriage->add_property("determinate", "the " );
     _fake_carriage->set_short(_carriage_name + " Carriage");
     _fake_carriage->add_adjective( map(explode(_carriage_name, " "),
                       (: lower_case($1) :) ) );
     _fake_carriage->set_long("The carriage looks fairly old "
       "and barely road worthy.  You could probably enter "
       "it if you fancy a bumpy ride.\n");
     _fake_carriage->reset_get();
   }
   _fake_carriage->move( _outside );
   _fake_carriage->add_property("there","waiting here");
   add_exit("leave carriage", path, "corridor");
   modify_exit("leave carriage", ({
                "function", "check_can_leave",
                "enter", "$N climb$s out of the carriage.\n",
                "message", "$N climb$s out of the carriage.\n",
                "move mess", "\nYou climb out of the carriage.\n",
                "size", 190}));
   add_alias("out", "leave carriage");
   tell_room(_outside, "The "+ _carriage_name + " carriage arrives and "
      "pulls to a stop.\n"
      "The driver opens the carriage door.\n");
   if(objectp(_car_driver)) {
     _car_driver->do_command("leave carriage");
     if( environment(_car_driver) != _outside ) {
       _car_driver->move(_outside, "The " + _carriage_name +
                         " carriage driver hops out of the carriage.",
                         "The driver opens the door and leaps out.");
     }
     _car_driver->arrived_at_to_stop( capitalize(_n_name) );
   } else {
     tell_room(this_object(), "The carriage's next stop is " + _n_name
               + ".\n");
   }
   _exit_name = "enter " + lower_case(_carriage_name) + " carriage";
   _outside->add_exit(_exit_name, this_object(), "corridor");
   name_parts = explode(lower_case(_carriage_name), " ");
   foreach(np in name_parts) {
      _outside->add_alias("enter " + np + " carriage", _exit_name);
      _outside->add_alias("enter " + np + "s carriage", _exit_name);
   }
   _outside->add_alias("enter carriage", _exit_name);
   if(!_outside->query_linker()) {
      _outside->modify_exit(_exit_name, ({
                   "enter", "$N enter$s the carriage.\n",
                   "message", "$N climb$s aboard the carriage.\n",
                   "move mess", "\nYou climb aboard the carriage.\n",
                   "size", 190 }) );
   } else {
      string *linked_rooms;
      _outside->modify_exit(_exit_name, ({
                   "enter", "$N enter$s the carriage.\n",
                   "message", "$N climb$s aboard the carriage.\n",
                   "move mess", "\nYou climb aboard the carriage.\n",
                   "linker mess", ({
                      "At the carriage stop, $N $V$0=enters,enter$V$ "
                      "the carriage\n", "At the carriage stop, $N "
                      "$V$0=gets off,get off$V$ the carriage.\n"}) ,
                   "size", 190 }) );
      linked_rooms = ( _outside->query_linker() )->query_rooms()
                         - ({ base_name( _outside ) });
      foreach( string raum in linked_rooms ) {
         tell_room( raum ,
                "A carriage draws to a halt at the carriage stop.\n");
      }
   }
   stop_room_chats();
   call_out("give_warning", stop_time - 30, name, _n_name);
   call_out("move_on", stop_time );
}
int check_can_leave(string exit, object person) {
   return !_outside->check_cannot_leave_carriage(person);
}
void give_warning(string this_stop_name, string next_stop_name) {
  if(objectp(_outside) && objectp(_car_driver) &&
     (environment(_car_driver) == _outside)) {
    _car_driver->leaving_again_to_stop(next_stop_name);
  } else {
    tell_room(this_object(), "The carriage is about to leave for " +
                             next_stop_name + ".\n");
  }
}
void move_on() {
  string np;
  string* name_parts;
  if(objectp(_car_driver)) {
    _car_driver->do_command("mutter");
    _car_driver->do_command("enter " + lower_case(_carriage_name) +
                            " carriage");
    if( environment(_car_driver) != this_object() ) {
      debug_printf("Driver: Tried to \"enter " +
                   lower_case(_carriage_name) + " carriage\" and "
                   "failed.");
      _car_driver->move(this_object(), "The driver hops back in to the "
                        "carriage and gets ready to drive again.",
                        "The " + _carriage_name + " driver hops back "
                        "onto " + _car_driver->query_possessive() +
                        " carriage.");
    }
    _car_driver->next_stop_from_carriage(_n_name);
    tell_room(this_object(), "The carriage starts moving again.\n");
  } else {
    tell_room(this_object(), "The carriage leaves the current stop.\n");
  }
  remove_exit("leave carriage");
  remove_alias("out", "leave carriage");
  if(objectp(_outside)) {
    tell_room(_outside, "The driver closes the carriage door.\n"
                         "The carriage starts moving again.\n");
    _outside->remove_exit(_exit_name);
    name_parts = explode(lower_case(_carriage_name), " ");
    foreach(np in name_parts) {
      _outside->remove_alias("enter " + np + " carriage", _exit_name);
      _outside->remove_alias("enter " + np + "s carriage", _exit_name);
    }
    _outside->remove_alias("enter carriage", _exit_name);
    if (_fake_carriage) {
      _fake_carriage->move("/std/room");
    }
    _outside->modify_item("carriage", 0);
  }
  _current_stop = _next_stop;
  _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
  _outside = 0;
  room_chat(({15, 30, ({
    "The carriage seems to be on the verge of falling apart "
      "as it shakes.",
    "The carriage hits a bump in the road and you almost "
      "fall out.",
    "The driver seems to have a talent for hitting every "
      "pothole.",
    "The driver falls off, and just manages to get back on "
      "the carriage."
  }) }) );
  this_object()->check_chat();
  call_out("make_stop", 30 );
}
void dest_me() {
  string path;
  object ob;
  string np;
  string* name_parts;
  if(objectp(_outside)) {
    _outside->remove_exit(_exit_name);
    name_parts = explode(lower_case(_carriage_name), " ");
    foreach(np in name_parts) {
      _outside->remove_alias("enter " + np + " carriage", _exit_name);
      _outside->remove_alias("enter " + np + "s carriage", _exit_name);
    }
    _outside->remove_alias("enter carriage", _exit_name);
    _outside->remove_extra_look(this_object());
    _outside->modify_item("carriage", 0);
  }
  if (_fake_carriage) _fake_carriage->dest_me();
  if (_bell) _bell->dest_me();
  if (_car_driver) _car_driver->dest_me();
  if (_current_stop < sizeof(_route_info)) {
     path = _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
     foreach (ob in all_inventory()) {
        if (living(ob)) {
          ob->move(path, "$N appears looking a little shocked.",
                         "$N disappears in a cloud of shockedness.");
        }
     }
  }
  ::dest_me();
}
string query_quit_handler() {
   return _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
}
mixed *co() {
  return filter(call_out_info(),(: $1[0] == this_object() :));
}
int do_ring() {
  if ( sizeof( co() ) != 0 ) {
    add_succeeded_mess(({"You ring the bell.\n", "$N $V the "
      "bell.\n"}));
    if(objectp(_car_driver) && environment(_car_driver) == this_object()) {
      _car_driver->bell_ring(_n_name);
    } else {
      tell_room(this_object(), "Nothing much happens.\n");
    }
    return 1;
  }
  call_out("move_on",2);
  if(objectp(_car_driver) && environment(_car_driver) == this_object()) {
    _car_driver->do_command(":wakes with a start.");
  }
  tell_object( this_player(), "The carriage starts rolling again.\n");
  return 1;
}
string query_environ_long() {
  if ( !_outside ) {
    return "Outside the carriage, the road from " + _p_name + " to "
      + _n_name + " swishes by.";
  } else {
  return "Outside the window you can see:\n" + _outside->long();
  }
}

==================================================
FILE: room/inherit/carriage/carriage_note.c
==================================================

inherit "/std/object";
void setup_route(string* a, string b, string c, string d);
void setup() {
  set_name( "note" );
  set_short(  "Test note" ) ;
  set_long( "This note is probably broken, please contact a "
    "creator. :)\n" );
  reset_get();
  add_alias( "table" );
}
void setup_route(string* stops, string colour, string route, string language) {
  string prettystops = "";
  int i;
  set_short(route + " table");
  add_adjective(map(explode(route, " "), (: lower_case($1) :)));
  add_adjective(colour);
  add_alias("table");
  add_alias("cardboard");
  add_adjective(({"piece", "of", colour}));
  set_long("This is the table for the " + route + " route.  It is "
    "printed on a piece of sturdy " + colour + " cardboard, and stuck "
    "firmly to the pole.\n");
  for(i = 0; i < sizeof(stops) - 1; i++) {
    prettystops += capitalize(stops[i]) + "\n";
  }
  prettystops += "and back to " + stops[sizeof(stops) - 1];
  add_read_mess("\nThe " + route + " route:\n" +
    prettystops + ".\n",
    "bold letters", language);
}

==================================================
FILE: room/inherit/carriage/carriage_pole.c
==================================================

inherit "/std/object";
void setup_route(string *ss, string c, string r);
string *notes = ({});
void setup() {
  set_name( "pole" );
  set_short("wooden pole");
  add_adjective( "wooden" );
  set_long("This is a wooden pole.  It's fairly unexciting.\n");
  set_weight( 10000 );
  add_property( "there", ( ({"casually placed in a corner",
                             "here",
                             "standing on the side of the road",
                             "trying to be noticed"})
                          [random(4)]));
  add_extra_look(this_object());
  reset_get();
}
void setup_route( string *stops, string colour, string route) {
  object note;
  string language;
  string pathofhere;
  if(member_array(colour + " note", notes) != -1) {
    return;
  }
  notes += ({ colour + " note" });
  pathofhere = file_name(environment(this_object()));
  if(strsrch(pathofhere, "/d/am/") != -1)
    language = "morporkian";
  if(strsrch(pathofhere, "/d/cwc/") != -1)
    language = "agatean";
  if(strsrch(pathofhere, "/d/klatch/") != -1)
    language = "djelian";
  if(strsrch(pathofhere, "/d/ram/") != -1)
    language = "morporkian";
  if(strsrch(pathofhere, "/d/ram/Uberwald/") != -1)
    language = "uberwaldean";
  if(strsrch(pathofhere, "/d/sur/") != -1)
    language = "morporkian";
  note = clone_object(__DIR__ + "carriage_note");
  note->setup_route(stops, colour, route, language);
  environment(this_object())->add_hidden_object(note);
  environment(this_object())->add_property("carriage pole",
    this_object());
  if(sizeof(notes)) {
    set_short("wooden pole with " + (query_multiple_short(map( notes,
    (: add_a($1) :)))) + " attached to it") ;
  }
}
string extra_look() {
  if(sizeof(notes)) {
    return capitalize((query_multiple_short(map( notes, (: add_a($1) :)))) +
      ((sizeof(notes) > 1) ? " are" : " is") + " attached to the pole.\n") ;
  }
  return "";
}

==================================================
FILE: room/inherit/carriage/handler.c
==================================================

#include <room.h>
#include <data.h>
#include <room/carriage.h>
#define CARRIAGE ITEMS "carriage"
private mapping _routedetails = ([ ]);
private mapping _routesactual = ([ ]);
private nosave mapping _carriages = ([ ]);
private nosave string _base_dir;
private nosave string _carriage;
private nosave string _pole;
private nosave string _data_dir;
private nosave string _save_file;
private mapping _file_modified_time;
private void load_data();
private void map_carriages();
private void save_file() {
   unguarded((: save_object(_save_file) :));
}
void create() {
   seteuid(getuid());
   _file_modified_time = ([ ]);
   this_object()->setup();
}
void setup_carriage(string dir, string base_dir,
                    string carriage, string pole, string save_file) {
   _data_dir = dir;
   _base_dir = base_dir;
   _carriage = carriage;
   _pole = pole;
   _save_file = save_file;
   unguarded((: restore_object(_save_file) :));
   if (!_file_modified_time) {
      _file_modified_time = ([ ]);
   }
   load_data();
   map_carriages();
}
mapping query_route_details() { return _routedetails; }
mapping query_route_actual() { return _routesactual; }
string* query_route_names() { return keys(_routesactual); }
string query_stop_location(string name) {
   if (_routedetails[name]) {
     return _routedetails[name]->path;
   }
   return "bad stop " + name;
}
string query_stop_name(string name) {
   if (_routedetails[name]) {
      return _routedetails[name]->name;
   }
   return "Broken Position " + name;
}
int query_stop_delay(string name) {
   if (_routedetails[name]) {
      return _routedetails[name]->delay;
   }
   return 60;
}
class stop_list_details* query_route_stops(string route) {
   return _routesactual[route]->stops;
}
object query_carriage_on_route(string route) {
   return _carriages[route];
}
private void parse_stop(string fname, mapping data) {
   string name;
   class stop_details info;
   if (!data["id"]) {
      debug_printf("No id for stop %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   if (!data["name"]) {
      debug_printf("No name for stop %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   name = data["name"];
   if (!data["path"]) {
      log_file("COMPILE_ERROR", "Required path field not present for stop %s\n", name);
      return 0;
   }
   info = new(class stop_details);
   info->name = data["name"];
   if (data["path"][0] == '/') {
      info->path = data["path"];
   } else {
      info->path = _base_dir + data["path"];
   }
   info->delay = data["delay"];
   _routedetails[data["id"]] = info;
   save_file();
}
private void parse_route(string fname, mapping data) {
   string name;
   class route_details info;
   mixed bing;
   if (!data["name"]) {
      debug_printf("No id for route %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   if (!data["colour"]) {
      debug_printf("No colour for route %O\n", data);
      log_file("COMPILE_ERROR", "No name for stop %O\n", data);
      return 0;
   }
   name = data["name"];
   info = new(class route_details, stops : ({ }));
   info->colour = data["colour"];
   info->return_along = data["samereturnpath"];
   foreach (bing in data["stop"]) {
      if (!mapp(bing) || !stringp(bing["id"]) || !intp(bing["travel"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         log_file("COMPILE_ERROR", "Invalid data for route (%s) %O\n", name,  bing);
      } else {
         info->stops += ({ new(class stop_list_details, id : bing["id"],
                                             travel_time : bing["travel"]) });
      }
   }
   _routesactual[data["name"]] = info;
   save_file();
}
protected void finish_compiling(string fname, mapping data) {
   mixed* bits;
   mapping thing;
   string name;
   foreach (name, bits in data) {
      switch (name) {
      case "stop" :
         foreach (thing in bits) {
            parse_stop(fname, thing);
         }
         break;
      case "route" :
         foreach (thing in bits) {
            parse_route(fname, thing);
         }
         break;
      default :
         debug_printf("Unknown data area %s in %s\n", name, fname);
         log_file("COMPILE_ERROR", "Unknown data area %s in %s\n", name, fname);
         break;
      }
   }
   _file_modified_time[fname] = unguarded( (: stat($(fname)) :))[1];
   save_file();
   map_carriages();
}
void scan_for_new_data() {
   string *files;
   string fname;
   string *bits;
   debug_printf("Scan for new data.");
   if (unguarded( (: stat(__FILE__)[1] :)) !=
       _file_modified_time[__FILE__]) {
      _file_modified_time = ([ ]);
   }
   files = ({ _data_dir });
   while (sizeof(files)) {
      fname = files[0];
      files = files[1..];
      if (unguarded( (: file_size($(fname)) :)) == -2) {
         bits = get_dir(fname + "/");
         if (bits) {
            bits -= ({ "RCS", ".", ".." });
            bits = filter(bits, (: $1[0] != '.' :));
            files += map(bits, (: $2 + "/" + $1 :), fname);
         }
      } else {
         if (unguarded( (: stat($(fname)) :))[1] != _file_modified_time[fname]) {
            debug_printf("Compiling: %s", fname);
            DATA_HANDLER->compile_file(fname,
                     (: finish_compiling :));
         }
      }
   }
   _file_modified_time[__FILE__] =
                unguarded( (: stat(__FILE__)[1] :));
}
private string trim(string str) {
   while (strlen(str) && str[0] == ' ') {
      str = str[1..];
   }
   while (strlen(str) && str[<1] == ' ') {
      str = str[0..<2];
   }
   return str;
}
void load_data() {
   scan_for_new_data();
}
private void map_carriages() {
  string route;
  int i, j;
  class route_details rods;
  class route_details new_rods;
  string *locshorts;
  object carriage;
  object car;
  object room;
  object pole;
  class stop_list_details loc;
  string str;
  foreach( route, rods in _routesactual) {
    carriage = 0;
    if (!_carriages[route]) {
      foreach( car in children( _carriage ) ) {
        if (clonep(car) && car->query_carriage_name() == route) {
          carriage = car;
          break;
        }
      }
    } else {
      carriage = _carriages[route];
    }
    locshorts = ({ });
    foreach (loc in rods->stops) {
       str = query_stop_name(loc->id);
       if (str) {
          locshorts += ({ str });
       }
    }
    j = 0;
    foreach (loc in rods->stops) {
      str = query_stop_location(loc->id);
      room = load_object(str);
      if(objectp(room)) {
        if( room->query_property("carriage pole")) {
          pole = room->query_property("carriage pole");
        } else {
          pole = clone_object(_pole);
          if(objectp(pole)) {
            pole->move(room);
            room->add_property(ROOM_KEEP_PROP);
          }
        }
        if(objectp(pole)) {
          pole->setup_route(
                  locshorts[(j+1)..] + locshorts[0..j],
                  _routesactual[route]->colour,
                  route);
        }
      j++;
      }
    }
    if (rods->return_along) {
       new_rods = copy(rods);
       for (i = sizeof(rods->stops) - 2; i >= 1; i--) {
          new_rods->stops += ({ rods->stops[i] });
       }
    } else {
       new_rods = rods;
    }
    if (!carriage) {
      carriage = clone_object( _carriage );
      carriage->make_carriage( route, new_rods, this_object() );
      carriage->setup();
    } else {
      carriage->update_route( route, new_rods, this_object() );
      carriage->setup();
    }
    if(objectp(carriage)) {
      _carriages[route] = carriage;
    }
  }
}
mixed* stats() {
   mixed* ret;
   string route;
   object ob;
   ret = ({ });
   foreach (route in query_route_names()) {
      ob = query_carriage_on_route(route);
      if (ob) {
         ret += ({ ({ route + "-carriage", file_name(ob) })  });
      }
      ret += ({ ({ route + "-colour", _routesactual[route]->colour }) });
      ret += ({ ({ route + "-current stop", ob->query_current_stop()->name })  });
      ret += ({ ({ route + "-next stop", ob->query_next_stop()->name })  });
      if (ob && ob->query_outside()) {
         ret += ({ ({ route + "-outside", file_name(ob->query_outside()) }) });
      }
   }
   return ret;
}

==================================================
FILE: room/inherit/carriage/testcar.c
==================================================

#include <room/carriage.h>
#define DEFAULT_WAIT 60
#define DEFAULT_TRAVEL 45
inherit "/std/room/basic_room";
private class route_details _route_info;
private string _carriage_name;
private string _exit_name;
private int _current_stop;
private int _next_stop;
private object _outside;
private object _fake_carriage;
private object _bell;
private object _car_driver;
private object _handler;
private string _n_name;
private string _p_name;
int do_ring();
string query_environ_long();
void create() {
    do_setup++;
    ::create();
    do_setup--;
    set_light(60);
    set_keep_room_loaded(1);
    set_short( "inside a carriage" );
    add_property( "no teleport", 1 );
    add_property("determinate", "");
    add_property("no map", 1);
    add_property("no godmother", 1);
   add_item("window", (: query_environ_long :) );
   add_item( "carriage", "The carriage looks fairly old and barely "
     "road worthy." );
   _bell = clone_object("/std/object");
   _bell->set_name("bell");
   _bell->set_short("bell");
   _bell->add_property("there","hanging here");
   _bell->set_long("This is a bell you could probably ring if the "
                 "driver has fallen asleep and you want the carriage to go "
                 "somewhere.\n");
   _bell->reset_get();
   _bell->reset_drop();
   _bell->move( this_object() );
   if (!do_setup) {
      this_object()->setup();
      this_object()->reset();
   }
}
void init() {
  this_player()->add_command("ring", _bell, "<direct:object>", (: do_ring :) );
}
object create_carriage_driver() {
   return 0;
}
string query_carriage_name() { return _carriage_name; }
class stop_list_details query_current_stop() { return _route_info->stops[_current_stop]; }
class stop_list_details query_next_stop() { return _route_info->stops[_next_stop]; }
object query_outside() { return _outside; }
class route_details query_route_map() { return _route_info; }
int *query_stop_info() { return ({ _current_stop, _next_stop }); }
void update_route( string name,
                  class route_details new_route_info,
                  object handler)
{
   _handler = handler;
   _route_info = new_route_info;
   if (_current_stop >= sizeof(_route_info)) {
      _current_stop = _current_stop % sizeof(_route_info->stops);
   }
   _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
}
int make_carriage( string name,
                   class route_details new_route_info,
                   object handler)
{
    _handler = handler;
    _carriage_name = name;
    _route_info = new_route_info;
    _current_stop = 0;
    _next_stop = 1;
  if (!stringp( _carriage_name )) {
     log_file("NEW_CARRIAGE","%O: Invalid name: %O", this_object(),_carriage_name);
     return 0;
  }
  if (!classp( _route_info )) {
     log_file("NEW_CARRIAGE","%O: Invalid class: %O", this_object(), _route_info);
     return 0;
  }
  call_out("make_stop",5);
  _current_stop = 0;
  _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
  if(!_car_driver) {
    _car_driver = create_carriage_driver();
    if(objectp(_car_driver)) {
      _car_driver->route_setup(_carriage_name);
      _car_driver->move(this_object());
    }
  }
  return 1;
}
void make_stop() {
   string name;
   string* name_parts;
   string np;
   string n_path;
   string path;
   int travel_time;
   int stop_time;
   name = _handler->query_stop_name(_route_info->stops[ _current_stop ]->id);
   path = _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
   _p_name = name;
   travel_time = _route_info->stops[ _next_stop ]->travel_time;
   stop_time = _handler->query_stop_delay(_route_info->stops[ _current_stop ]->id);
   _n_name = _handler->query_stop_name(_route_info->stops[ _next_stop ]->id);
   n_path = _handler->query_stop_location(_route_info->stops[ _next_stop ]->id);
   _outside = load_object(path);
   if (!_outside) {
      log_file("NEW_CARRIAGE", ctime(time())+" (%O): problem with "
        + path +" (" + name + ", " + _route_info->stops[ _current_stop ]->id + ")\n", this_object());
      _route_info->stops = _route_info->stops[0.._current_stop - 1] +
                    _route_info->stops[_current_stop + 1..];
      call_out("make_stop", 1);
      return;
   }
   tell_room(this_object(), "The carriage comes to a grinding "
     "halt.\n");
   if(objectp(_car_driver) && (environment(_car_driver) == this_object())) {
     _car_driver->arrived_at_to_carriage( name, _n_name );
   } else {
     tell_room(this_object(), "The carriage has arrived at " + name + ".\n");
   }
   if (!_fake_carriage) {
     _fake_carriage = clone_object("/std/object");
     _fake_carriage->set_name("carriage");
     _fake_carriage->add_property("determinate", "the " );
     _fake_carriage->set_short(_carriage_name + " Carriage");
     _fake_carriage->add_adjective( map(explode(_carriage_name, " "),
                       (: lower_case($1) :) ) );
     _fake_carriage->set_long("The carriage looks fairly old "
       "and barely road worthy.  You could probably enter "
       "it if you fancy a bumpy ride.\n");
     _fake_carriage->reset_get();
   }
   _fake_carriage->move( _outside );
   _fake_carriage->add_property("there","waiting here");
   add_exit("leave carriage", path, "corridor");
   modify_exit("leave carriage", ({
                "function", "check_can_leave",
                "enter", "$N climb$s out of the carriage.\n",
                "message", "$N climb$s out of the carriage.\n",
                "move mess", "\nYou climb out of the carriage.\n",
                "size", 190}));
   add_alias("out", "leave carriage");
   tell_room(_outside, "The "+ _carriage_name + " carriage arrives and "
      "pulls to a stop.\n"
      "The driver opens the carriage door.\n");
   if(objectp(_car_driver)) {
     _car_driver->move(_outside, "The " + _carriage_name + " carriage "
       "driver hops out of the carriage.", "The driver opens the door "
       "and leaps out.");
     _car_driver->arrived_at_to_stop( capitalize(_n_name) );
   } else {
     tell_room(this_object(), "The carriage's next stop is " + _n_name + ".\n");
   }
   _exit_name = "enter " + lower_case(_carriage_name) + " carriage";
   _outside->add_exit(_exit_name, this_object(), "corridor");
   name_parts = explode(lower_case(_carriage_name), " ");
   foreach(np in name_parts) {
      _outside->add_alias("enter " + np + " carriage", _exit_name);
      _outside->add_alias("enter " + np + "s carriage", _exit_name);
   }
   _outside->add_alias("enter carriage", _exit_name);
   if(!_outside->query_linker()) {
      _outside->modify_exit(_exit_name, ({
                   "enter", "$N enter$s the carriage.\n",
                   "message", "$N climb$s aboard the carriage.\n",
                   "move mess", "\nYou climb aboard the carriage.\n",
                   "size", 190 }) );
   } else {
      string *linked_rooms;
      _outside->modify_exit(_exit_name, ({
                   "enter", "$N enter$s the carriage.\n",
                   "message", "$N climb$s aboard the carriage.\n",
                   "move mess", "\nYou climb aboard the carriage.\n",
                   "linker mess", ({
                      "At the carriage stop, $N $V$0=enters,enter$V$ "
                      "the carriage\n", "At the carriage stop $N "
                      "$V$0=gets off,get off$V$ the carriage.\n"}) ,
                   "size", 190 }) );
      linked_rooms = ( _outside->query_linker() )->query_rooms()
                         - ({ base_name( _outside ) });
      foreach( string raum in linked_rooms ) {
         tell_room( raum ,
                "A carriage draws to a halt at the carriage stop.\n");
      }
   }
   stop_room_chats();
   call_out("give_warning", stop_time - 30, name, _n_name);
   call_out("move_on", stop_time );
}
int check_can_leave(string exit, object person) {
   return !_outside->check_cannot_leave_carriage(person);
}
void give_warning(string this_stop_name, string next_stop_name) {
  if(objectp(_outside) && objectp(_car_driver) &&
     (environment(_car_driver) == _outside)) {
    _car_driver->leaving_again_to_stop(next_stop_name);
  } else {
    tell_room(this_object(), "The carriage is about to leave to " +
                             next_stop_name + ".\n");
  }
}
void move_on() {
  string* name_parts;
  if(objectp(_car_driver)) {
    _car_driver->do_command("mutter");
    _car_driver->move(this_object(), "The driver hops back in to the carriage "
      "and gets ready to drive again.", "The " + _carriage_name +
      " driver hops back onto " + _car_driver->query_possessive() +
      " carriage.");
  } else {
    tell_room(this_object(), "The carriage leaves the current stop.\n");
  }
  remove_exit("leave carriage");
  remove_alias("out", "leave carriage");
  if(objectp(_outside)) {
    tell_room(_outside, "The driver closes the carriage door.\n"
                         "The carriage starts moving again.\n");
    _outside->remove_exit(_exit_name);
    name_parts = explode(lower_case(_carriage_name), " ");
    foreach(np in name_parts) {
      _outside->remove_alias("enter " + np + " carriage", _exit_name);
      _outside->remove_alias("enter " + np + "s carriage", _exit_name);
    }
    _outside->remove_alias("enter carriage", _exit_name);
    if (_fake_carriage) {
      _fake_carriage->move("/std/room");
    }
    _outside->modify_item("carriage", 0);
  }
  if (objectp(_car_driver)) {
     _car_driver->next_stop_from_carriage(_n_name);
  }
  _current_stop = _next_stop;
  _next_stop = (_current_stop + 1) % sizeof(_route_info->stops);
  _outside = 0;
  room_chat(({15, 30, ({
    "The carriage seems to be on the verge of falling apart "
      "as it shakes.",
    "The carriage hits a bump in the road and you almost "
      "fall out.",
    "The driver seems to have a talent for hitting every "
      "pothole.",
    "The driver falls off, and just manages to get back on "
      "the carriage."
  }) }) );
  this_object()->check_chat();
  call_out("make_stop", 30 );
}
void dest_me() {
  string path;
  object ob;
  string* name_parts;
  if(objectp(_outside)) {
    _outside->remove_exit(_exit_name);
    name_parts = explode(lower_case(_carriage_name), " ");
    foreach(np in name_parts) {
      _outside->remove_alias("enter " + np + " carriage", _exit_name);
      _outside->remove_alias("enter " + np + "s carriage", _exit_name);
    }
    _outside->remove_alias("enter carriage", _exit_name);
    _outside->remove_extra_look(this_object());
    _outside->modify_item("carriage", 0);
  }
  if (_fake_carriage) _fake_carriage->dest_me();
  if (_bell) _bell->dest_me();
  if (_car_driver) _car_driver->dest_me();
  if (_current_stop < sizeof(_route_info)) {
     path = _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
     foreach (ob in all_inventory()) {
        if (living(ob)) {
          ob->move(path, "$N appears looking a little shocked.",
                         "$N disappears in a cloud of shockedness.");
        }
     }
  }
  ::dest_me();
}
string query_quit_handler() {
   return _handler->query_stop_location(_route_info->stops[ _current_stop ]->id);
}
mixed *co() {
  return filter(call_out_info(),(: $1[0] == this_object() :));
}
int do_ring() {
  if ( sizeof( co() ) != 0 ) {
    add_succeeded_mess(({"You ring the bell.\n", "$N $V the "
      "bell.\n"}));
    if(objectp(_car_driver) && environment(_car_driver) == this_object()) {
      _car_driver->do_command("scowl");
      _car_driver->do_command("'We won't reach " + _n_name + " any faster just "
        "cause you ring that danged bell!");
    }
    return 1;
  }
  call_out("move_on",2);
  _car_driver->do_command(":wakes with a start.");
  tell_object( this_player(), "The carriage starts rolling again.\n");
  return 1;
}
string query_environ_long() {
  if ( !_outside ) {
    return "Outside the carriage, the road from " + _p_name + " to "
      + _n_name + " swishes by.";
  } else {
  return "Outside the window you can see:\n" + _outside->long();
  }
}

==================================================
FILE: room/inherit/carriage/testhandler.c
==================================================

#include <room.h>
#include <data.h>
#include <room/carriage.h>
#define CARRIAGE ITEMS "carriage"
private mapping _routedetails = ([ ]);
private mapping _routesactual = ([ ]);
private nosave mapping _carriages = ([ ]);
private nosave string _base_dir;
private nosave string _carriage;
private nosave string _pole;
private nosave string _data_dir;
private nosave string _save_file;
private mapping _file_modified_time;
private void load_data();
private void map_carriages();
private void save_file() {
   unguarded((: save_object(_save_file) :));
}
void create() {
   seteuid(getuid());
   _file_modified_time = ([ ]);
   this_object()->setup();
}
void setup_carriage(string dir, string base_dir,
                    string carriage, string pole, string save_file) {
   _data_dir = dir;
   _base_dir = base_dir;
   _carriage = carriage;
   _pole = pole;
   _save_file = save_file;
   unguarded((: restore_object(_save_file) :));
   if (!_file_modified_time) {
      _file_modified_time = ([ ]);
   }
   load_data();
   map_carriages();
}
mapping query_route_details() { return _routedetails; }
mapping query_route_actual() { return _routesactual; }
string* query_route_names() { return keys(_routesactual); }
string query_stop_location(string name) {
   if (_routedetails[name]) {
     return _routedetails[name]->path;
   }
   return "bad stop " + name;
}
string query_stop_name(string name) {
   if (_routedetails[name]) {
      return _routedetails[name]->name;
   }
   return "Broken Position " + name;
}
int query_stop_delay(string name) {
   if (_routedetails[name]) {
      return _routedetails[name]->delay;
   }
   return 60;
}
class stop_list_details* query_route_stops(string route) {
   return _routesactual[route]->stops;
}
object query_carriage_on_route(string route) {
   return _carriages[route];
}
private void parse_stop(string fname, mapping data) {
   string name;
   class stop_details info;
   if (!data["id"]) {
      debug_printf("No id for stop %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   if (!data["name"]) {
      debug_printf("No name for stop %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   name = data["name"];
   if (!data["path"]) {
      log_file("COMPILE_ERROR", "Required path field not present for stop %s\n", name);
      return 0;
   }
   info = new(class stop_details);
   info->name = data["name"];
   if (data["path"][0] == '/') {
      info->path = data["path"];
   } else {
      info->path = _base_dir + data["path"];
   }
   info->delay = data["delay"];
   _routedetails[data["id"]] = info;
   save_file();
}
private void parse_route(string fname, mapping data) {
   string name;
   class route_details info;
   mixed bing;
   if (!data["name"]) {
      debug_printf("No id for route %O\n", data);
      log_file("COMPILE_ERROR", "No name for npc %O\n", data);
      return 0;
   }
   if (!data["colour"]) {
      debug_printf("No colour for route %O\n", data);
      log_file("COMPILE_ERROR", "No name for stop %O\n", data);
      return 0;
   }
   name = data["name"];
   info = new(class route_details, stops : ({ }));
   info->colour = data["colour"];
   info->return_along = data["samereturnpath"];
   foreach (bing in data["stop"]) {
      if (!mapp(bing) || !stringp(bing["id"]) || !intp(bing["travel"])) {
         debug_printf("Invalid data for zone (%s) %O\n", name, bing);
         log_file("COMPILE_ERROR", "Invalid data for route (%s) %O\n", name,  bing);
      } else {
         info->stops += ({ new(class stop_list_details, id : bing["id"],
                                             travel_time : bing["travel"]) });
      }
   }
   _routesactual[data["name"]] = info;
   save_file();
}
protected void finish_compiling(string fname, mapping data) {
   mixed* bits;
   mapping thing;
   string name;
   foreach (name, bits in data) {
      switch (name) {
      case "stop" :
         foreach (thing in bits) {
            parse_stop(fname, thing);
         }
         break;
      case "route" :
         foreach (thing in bits) {
            parse_route(fname, thing);
         }
         break;
      default :
         debug_printf("Unknown data area %s in %s\n", name, fname);
         log_file("COMPILE_ERROR", "Unknown data area %s in %s\n", name, fname);
         break;
      }
   }
   _file_modified_time[fname] = unguarded( (: stat($(fname)) :))[1];
   save_file();
   map_carriages();
}
void scan_for_new_data() {
   string *files;
   string fname;
   string *bits;
   debug_printf("Scan for new data.");
   if (unguarded( (: stat(__FILE__)[1] :)) !=
       _file_modified_time[__FILE__]) {
      _file_modified_time = ([ ]);
   }
   files = ({ _data_dir });
   while (sizeof(files)) {
      fname = files[0];
      files = files[1..];
      if (unguarded( (: file_size($(fname)) :)) == -2) {
         bits = get_dir(fname + "/");
         if (bits) {
            bits -= ({ "RCS", ".", ".." });
            bits = filter(bits, (: $1[0] != '.' :));
            files += map(bits, (: $2 + "/" + $1 :), fname);
         }
      } else {
         if (unguarded( (: stat($(fname)) :))[1] != _file_modified_time[fname]) {
            debug_printf("Compiling: %s", fname);
            DATA_HANDLER->compile_file(fname,
                     (: finish_compiling :));
         }
      }
   }
   _file_modified_time[__FILE__] =
                unguarded( (: stat(__FILE__)[1] :));
}
private string trim(string str) {
   while (strlen(str) && str[0] == ' ') {
      str = str[1..];
   }
   while (strlen(str) && str[<1] == ' ') {
      str = str[0..<2];
   }
   return str;
}
void load_data() {
   scan_for_new_data();
}
private void map_carriages() {
  string route;
  int i, j;
  class route_details rods;
  class route_details new_rods;
  string *locshorts;
  object carriage;
  object car;
  object room;
  object pole;
  class stop_list_details loc;
  string str;
  foreach( route, rods in _routesactual) {
    carriage = 0;
    if (!_carriages[route]) {
      foreach( car in children( _carriage ) ) {
        if (clonep(car) && car->query_carriage_name() == route) {
          carriage = car;
          break;
        }
      }
    } else {
      carriage = _carriages[route];
    }
    locshorts = ({ });
    foreach (loc in rods->stops) {
       str = query_stop_name(loc->id);
       if (str) {
          locshorts += ({ str });
       }
    }
    j = 0;
    foreach (loc in rods->stops) {
      str = query_stop_location(loc->id);
      room = load_object(str);
      if(objectp(room)) {
        if( room->query_property("test pole")) {
          pole = room->query_property("test pole");
        } else {
          pole = clone_object(_pole);
          if(objectp(pole)) {
            pole->move(room);
            room->add_property(ROOM_KEEP_PROP);
          }
        }
        if(objectp(pole)) {
          pole->setup_route(
                  locshorts[(j+1)..] + locshorts[0..j],
                  _routesactual[route]->colour,
                  route);
        }
      j++;
      }
    }
    if (rods->return_along) {
       new_rods = copy(rods);
       for (i = sizeof(rods->stops) - 2; i >= 1; i--) {
          new_rods->stops += ({ rods->stops[i] });
       }
    } else {
       new_rods = rods;
    }
    if (!carriage) {
      carriage = clone_object( _carriage );
      carriage->make_carriage( route, new_rods, this_object() );
      carriage->setup();
    } else {
      carriage->update_route( route, new_rods, this_object() );
      carriage->setup();
    }
    if(objectp(carriage)) {
      _carriages[route] = carriage;
    }
  }
}
mixed* stats() {
   mixed* ret;
   string route;
   object ob;
   ret = ({ });
   foreach (route in query_route_names()) {
      ob = query_carriage_on_route(route);
      if (ob) {
         ret += ({ ({ route + "-carriage", file_name(ob) })  });
      }
      ret += ({ ({ route + "-colour", _routesactual[route]->colour }) });
      ret += ({ ({ route + "-current stop", ob->query_current_stop()->name })  });
      ret += ({ ({ route + "-next stop", ob->query_next_stop()->name })  });
      if (ob && ob->query_outside()) {
         ret += ({ ({ route + "-outside", file_name(ob->query_outside()) }) });
      }
   }
   return ret;
}

==================================================
FILE: room/controller/club_room_controller.c
==================================================

inherit "/std/basic/setup";
#include <clubs.h>
#include <room/club_room.h>
private nosave string _save_directory;
private mapping _options;
private string _club;
private mapping _ownership;
private nosave mapping _default_ownership;
private int _board_contained;
class ownership {
   string name;
   int type;
   int control_type;
}
private void setup_discussions();
void save_me();
void load_me();
void create() {
   _options = ([ ]);
   _ownership = ([ ]);
   _default_ownership = ([ ]);
   do_setup();
   call_out((: load_me() :), 0);
}
private void add_board_to(string club) {
   int board_count;
   board_count = CLUB_HANDLER->query_elected_option(club,
                                                    CLUB_ROOM_BOARD_COUNT);
   board_count++;
   if (board_count == 1) {
      CLUB_HANDLER->create_club_board(club);
   }
   CLUB_HANDLER->set_elected_option(club,
                                    CLUB_ROOM_BOARD_COUNT,
                                    board_count);
}
private void remove_board_from(string club) {
   int board_count;
   board_count = CLUB_HANDLER->query_elected_option(club,
                                                    CLUB_ROOM_BOARD_COUNT);
   board_count--;
   if (board_count == 0 &&
       CLUB_HANDLER->query_club_board(club)) {
      CLUB_HANDLER->remove_club_board(club);
   }
   if (board_count <= 0) {
      CLUB_HANDLER->remove_elected_option(club,
                                          CLUB_ROOM_BOARD_COUNT);
   } else {
      CLUB_HANDLER->set_elected_option(club,
                                       CLUB_ROOM_BOARD_COUNT,
                                       board_count);
   }
}
int set_club(string club) {
   class ownership bing;
   class ownership fluff;
   string name;
   if (!CLUB_HANDLER->is_elected_club(club)) {
      return 0;
   }
   if (_club &&
       CLUB_HANDLER->query_club_name(club) ==
       CLUB_HANDLER->query_club_name(_club)) {
      return 1;
   }
   if (_board_contained) {
      if (_club) {
         remove_board_from(_club);
      }
      add_board_to(club);
   }
   _club = club;
   foreach (name, bing in _ownership) {
      if (bing->control_type != CLUB_ROOM_CONTROLLED_FIXED) {
         if (_default_ownership[name]) {
            fluff = _default_ownership[name];
            bing->type = fluff->type;
            if (functionp(fluff->name)) {
               bing->name = evaluate(fluff->name,
                                     name,
                                     club);
            } else {
               bing->name = fluff->name;
            }
         }
      }
   }
   call_out((: setup_discussions :), 1);
   save_me();
   return 1;
}
string query_club() {
   return _club;
}
void set_board_associated(int board_associated) {
   board_associated = board_associated != 0;
   if (_club) {
      if (_board_contained != board_associated) {
         if (board_associated) {
            add_board_to(_club);
         } else {
            remove_board_from(_club);
         }
      }
   }
   _board_contained = board_associated;
}
int query_board_associated() {
   return _board_contained;
}
int is_option(string name) {
   return !undefinedp(_options[name]);
}
mixed query_option(string name) {
   return _options[name];
}
int remove_option(string name) {
   if (is_option(name)) {
      map_delete(_options, name);
      return 1;
   }
   return 0;
}
int set_option(string name, mixed value) {
   _options[name] = value;
}
int add_controlled_ownership(string name,
                             int type,
                             int default_type,
                             mixed default_name) {
   class ownership bing;
   if (!_ownership[name]) {
      bing = new(class ownership);
      bing->name = CLUB_UNKNOWN_MEMBER;
      bing->type = CLUB_ROOM_OWNED_PERSON;
      bing->control_type = type;
      _ownership[name] = bing;
      bing = new(class ownership);
      bing->name = default_name;
      bing->type = default_type;
      bing->control_type = type;
      _default_ownership[name] = bing;
      return 1;
   }
   return 0;
}
int set_controlled_ownership_owner(string controlled,
                                   string owner,
                                   int type) {
   class ownership bing;
   if (!_ownership[controlled]) {
      return 0;
   }
   bing = _ownership[controlled];
   bing->type = type;
   bing->name = owner;
   save_me();
   return 1;
}
mixed discuss_nominate_ownership(string message,
                                 string club_name,
                                 class discussion_idea frog,
                                 string arg1,
                                 string arg2) {
   string *nominated;
   string body;
   string *nom;
   string name;
   int ret;
   switch (message) {
   case CLUB_DISCUSS_MESSAGE_VERIFY :
      if (CLUB_HANDLER->query_club_name(club_name) !=
          CLUB_HANDLER->query_club_name(_club)) {
         return 0;
      }
      if (!_ownership[frog->information]) {
         return 0;
      }
      return 1;
   case CLUB_DISCUSS_MESSAGE_COMPLETE :
      body = "Hello!\n\nThe discussion item "
         "added at " + ctime(frog->time_added) + ", finished at " +
         ctime(time()) + " and added by " + frog->added_by +
         " has finished.";
      body += "  The vote for nominations for the ownership of " +
         frog->information + " in the club " +
         CLUB_HANDLER->query_club_name(club_name) +
         " has been completed and the "
         "results are:\n";
      nominated = ({ });
      foreach (name, nom in frog->choices) {
         body += name + ": " + query_multiple_short(nom);
         if ((member_array(name, nom) != -1 ||
              name[0..strlen(CLUB_ROOM_POSITION_START)] == CLUB_ROOM_POSITION_START) &&
              sizeof(nom) >= 2) {
            body += " (accepted)\n";
            nominated += ({ name });
         } else {
            body += "\n";
         }
      }
      if (frog->information) {
         body += frog->information;
      }
      if (sizeof(nominated)) {
         if (_ownership[frog->information]) {
            if (sizeof(nominated) != 1) {
               body += "Therefor we had added an election with " +
                  query_multiple_short(nominated) +
                  " for the ownership of " +
                  frog->information + ".\n";
               CLUB_HANDLER->add_discussion_item(club_name,
                                   CLUB_DISCUSS_FUNCTION,
                                   frog->added_by,
                                   ({ file_name(this_object()),
                                      "discuss_elect_ownership" }),
                                   frog->information,
                                   nominated,
                                   7 * (24 * 60 * 60),
                                   0);
            } else {
               body += "Only " + nominated[0] +
                  " was nominated, so they are given ownership immediately.\n";
               if (name[0..strlen(CLUB_ROOM_POSITION_START)] == CLUB_ROOM_POSITION_START) {
                  set_controlled_ownership_owner(frog->information,
                                                 nominated[0][strlen(CLUB_ROOM_POSITION_START)..],
                                                 CLUB_ROOM_OWNED_POSITION);
               } else {
                  set_controlled_ownership_owner(frog->information,
                                                 nominated[0],
                                                 CLUB_ROOM_OWNED_PERSON);
               }
            }
         } else {
            body += "The ownership item appears to have vanished!\n";
         }
      } else {
         if (_ownership[frog->information]) {
            body += "No one accepted their nomination, so nothing "
               "happened.\n";
            CLUB_HANDLER->add_discussion_item(club_name,
                                CLUB_DISCUSS_FUNCTION,
                                frog->added_by,
                                frog->name,
                                frog->information,
                                ({ }),
                                7 * (24 * 60 * 60),
                                frog->optional_data);
         } else {
            body += "The position in the club appears to have vanished!\n";
         }
      }
      return body;
   case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
      return "Nominations for ownership of " + frog->information;
   case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
      body = "Nominations for the ownership of " + frog->information +
         ", positions or people can be nominated to have ownership.  "
         "Positions are nominated by putting the word 'position' in front "
         "ie: 'position president'.\n"
         "Currently nominated are:\n";
      foreach (name, nom in frog->choices) {
         body += name + ": " + query_multiple_short(nom);
         if ((member_array(name, nom) != -1 ||
              name[0..strlen(CLUB_ROOM_POSITION_START) - 1] == CLUB_ROOM_POSITION_START) &&
              sizeof(nom) >= 2) {
            body += " (accepted)\n";
         } else {
            body += "\n";
         }
      }
      return body;
   case CLUB_DISCUSS_MESSAGE_NOMINATION :
      if (CLUB_HANDLER->is_member_of(_club, arg1)) {
         if (CLUB_HANDLER->is_member_of(_club, arg2) ||
             (name[0..strlen(CLUB_ROOM_POSITION_START) - 1] == CLUB_ROOM_POSITION_START &&
              CLUB_HANDLER->is_valid_position(_club,
                                              name[strlen(CLUB_ROOM_POSITION_START)..]))) {
            if (!frog->choices[arg2]) {
               frog->choices[arg2] = ({ arg1 });
               return 1;
            } else if (member_array(arg1,
                                    frog->choices[arg2]) == -1) {
               frog->choices[arg2] += ({ arg1 });
               return 1;
            }
         }
      }
      return 0;
   case CLUB_DISCUSS_MESSAGE_TYPE :
      return CLUB_DISCUSS_MESSAGE_TYPE_NOMINATE;
   case CLUB_DISCUSS_MESSAGE_REMOVE_MEMBER :
      if (frog->choices[arg1]) {
         map_delete(frog->choices, arg1);
         ret = 1;
      }
      foreach (name, nom in frog->choices) {
         if (member_array(arg1, nom) != -1) {
            frog->choices[name] = nom - ({ arg1 });
            if (!sizeof(frog->choices[name])) {
               map_delete(frog->choices, name);
            }
            ret = 1;
         }
      }
      return ret;
   case CLUB_DISCUSS_MESSAGE_REMOVE_POSITION :
      if (frog->choices[CLUB_ROOM_POSITION_START + arg1]) {
         map_delete(frog->choices, CLUB_ROOM_POSITION_START + arg1);
         ret = 1;
      }
      return ret;
   case CLUB_DISCUSS_MESSAGE_CHANGE_POSITION :
      if (frog->choices[CLUB_ROOM_POSITION_START + arg1]) {
         frog->choices[CLUB_ROOM_POSITION_START + arg2] = frog->choices[CLUB_ROOM_POSITION_START + arg1];
         map_delete(frog->choices, CLUB_ROOM_POSITION_START + arg1);
         ret = 1;
      }
      return ret;
   case CLUB_DISCUSS_MESSAGE_NOMINATION_QUERY :
      return frog->choices;
   }
}
mixed discuss_elect_ownership(string message,
                              string club_name,
                              class discussion_idea frog,
                              string arg1,
                              string arg2) {
   string body;
   string name;
   int votes;
   int ret;
   int max_votes;
   string *names;
   switch (message) {
   case CLUB_DISCUSS_MESSAGE_VERIFY :
      if (CLUB_HANDLER->query_club_name(club_name) !=
          CLUB_HANDLER->query_club_name(_club)) {
         return 0;
      }
      if (!_ownership[frog->information]) {
         return 0;
      }
      return 1;
   case CLUB_DISCUSS_MESSAGE_COMPLETE :
      body = "Hello!\n\nThe discussion item "
         "added at " + ctime(frog->time_added) + ", finished at " +
         ctime(time()) + " and added by " + frog->added_by +
         " has finished.";
      body += "  The vote for elections of the ownership of " +
              frog->information +
         " in the club " +
         CLUB_HANDLER->query_club_name(club_name) +
         " has been completed and the "
         "results are:\n";
      names = ({ });
      max_votes = 0;
      foreach (name, votes in frog->choices) {
         body += name + ": " + votes + "\n";
         if (votes > max_votes) {
            max_votes = votes;
            names = ({ name });
         } else if (votes == max_votes) {
            names += ({ name });
         }
      }
      if (_ownership[frog->information]) {
         if (sizeof(names) == 1) {
            body += "Therefor we set " + names[0] +
                  " as owning " + frog->information + ".\n";
            if (names[0][0..strlen(CLUB_ROOM_POSITION_START) - 1] == CLUB_ROOM_POSITION_START) {
               set_controlled_ownership_owner(frog->information,
                                              names[0][strlen(CLUB_ROOM_POSITION_START)..],
                                              CLUB_ROOM_OWNED_POSITION);
             } else {
               set_controlled_ownership_owner(frog->information,
                                              names[0],
                                              CLUB_ROOM_OWNED_PERSON);
             }
         } else {
            body += "There was a tie for the results of the position, readding "
                    "a discussion with the tied members: " +
                    query_multiple_short(names) + ".\n";
            CLUB_HANDLER->add_discussion_item(club_name,
                                   CLUB_DISCUSS_FUNCTION,
                                   frog->added_by,
                                   ({ file_name(this_object()),
                                      "discuss_elect_ownership" }),
                                   frog->information,
                                   names,
                                   7 * (24 * 60 * 60),
                                   frog->optional_data);
         }
      } else {
         body += "The ownership item appears to have vanished!\n";
      }
      return body;
   case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
      return "Election for ownership of " + frog->information;
   case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
      body = "Election for the ownership of " + frog->information +
         ".\n";
      return body;
   case CLUB_DISCUSS_MESSAGE_TYPE :
      return CLUB_DISCUSS_MESSAGE_TYPE_VOTE;
   case CLUB_DISCUSS_MESSAGE_REMOVE_MEMBER :
      if (frog->choices[arg1]) {
         map_delete(frog->choices, arg1);
         ret = 1;
      }
      return ret;
   case CLUB_DISCUSS_MESSAGE_REMOVE_POSITION :
      if (frog->choices[CLUB_ROOM_POSITION_START + arg1]) {
         map_delete(frog->choices, CLUB_ROOM_POSITION_START + arg1);
         ret = 1;
      }
      return ret;
   case CLUB_DISCUSS_MESSAGE_CHANGE_POSITION :
      if (frog->choices[CLUB_ROOM_POSITION_START + arg1]) {
         frog->choices[CLUB_ROOM_POSITION_START + arg2] = frog->choices[CLUB_ROOM_POSITION_START + arg1];
         map_delete(frog->choices, CLUB_ROOM_POSITION_START + arg1);
         ret = 1;
      }
      return ret;
   }
}
private void setup_discussions() {
   string name;
   class ownership bing;
   foreach (name, bing in _ownership) {
      if (bing->control_type != CLUB_ROOM_CONTROLLED_FIXED) {
         CLUB_HANDLER->add_discussion_item(_club,
                                           CLUB_DISCUSS_FUNCTION,
                                           ({ file_name(this_object()),
                                              "discuss_nominate_ownership" }),
                                           name,
                                           ({ }),
                                           7 * 24 * 60 * 60,
                                           0);
      }
   }
}
void load_me() {
   if (_save_directory) {
      unguarded( (: restore_object(_save_directory + CLUB_ROOM_CONTROLLER_SAVE_FILE ) :) );
   }
}
void save_me() {
   if (_save_directory) {
      unguarded( (: save_object(_save_directory + CLUB_ROOM_CONTROLLER_SAVE_FILE ) :) );
   }
}
void set_save_directory(string save_directory) {
   while (save_directory[<1] == '/') {
      save_directory = save_directory[0..<2];
   }
   _save_directory = save_directory;
}
string query_save_directory() {
   return _save_directory;
}
string query_room_save_file_name(mixed fname) {
   if (objectp(fname)) {
      fname = file_name(fname);
   }
   fname = fname[strsrch(fname, '/', -1)..];
   return _save_directory + fname;
}

==================================================
FILE: room/controller/topography/area.c
==================================================

#include <dirs.h>
#include <image.h>
inherit "/std/room";
mapping direction_bits = ([
    "north": 1,
    "northeast": 2,
    "east": 4,
    "southeast": 8,
    "south": 16,
    "southwest": 32,
    "west": 64,
    "northwest": 128,
    "up": 256,
    "down": 512,
]);
class AREA_INFO {
  string base;
  int *origin;
  int *size;
  mixed *bbox;
  mixed *vertices;
  class IMAGE_INFO height;
  class IMAGE_INFO exits;
}
private int dbg_lvl = 0;
private string debugger = "jeremy";
private string _handler;
private class AREA_INFO *areas = ({ });
private mapping room_cache = ([ ]);
private mapping area_cache = ([ ]);
void set_handler(string handler) {
   _handler = handler;
}
string query_handler() {
   return _handler;
}
void set_debugger(string s) { debugger = s; }
string query_debugger() { return debugger; }
void set_debug_level(int l) { dbg_lvl = l; }
int query_debug_level() { return dbg_lvl; }
mixed query(string s) { return fetch_variable(s); }
void set_base(int i, string s) { areas[i]->base = s; }
string query_base(int i) { return areas[i]->base; }
void set_origin(int i, int *o) { areas[i]->origin = copy(o); }
int *query_origin(int i) { return copy(areas[i]->origin); }
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_keep_room_loaded(1);
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
int *quantize_to_origin(int *coord_r, int a) {
  int size2, i, *coord_q;
  coord_q = allocate(3);
  for (i = 0; i < 3; i++) {
    size2 = areas[a]->size[i] * 2;
    if (coord_r[i] < areas[a]->origin[i]) {
      coord_q[i] = coord_r[i] - areas[a]->size[i];
    } else {
      coord_q[i] = coord_r[i] + areas[a]->size[i];
    }
    coord_q[i] = ((coord_q[i] - areas[a]->origin[i]) / size2) * size2
      + areas[a]->origin[i];
  }
  return coord_q;
}
void set_size(int i, mixed s) {
  if (intp(s)) {
    areas[i]->size = ({ s, s, s });
  } else if (arrayp(s) && (sizeof(s) == 3)) {
    areas[i]->size = copy(s);
  } else {
    error("Illegal size; must be int or 3-element array.\n");
  }
}
varargs void set_height_map(int i, string map_file, int rle) {
  int *nw;
  areas[i]->height = IMAGE_HANDLER->load_image(map_file, rle);
  if (arrayp(areas[i]->bbox)) {
    nw = copy(areas[i]->bbox[0]);
    nw[0] = areas[i]->bbox[1][0] - 1;
    nw[1] += 1;
    nw[2] += 1;
    areas[i]->height->nw_coord = quantize_to_origin(nw, i);
  }
}
varargs void set_exits_map(int i, string map_file, int rle) {
  int *nw;
  areas[i]->exits = IMAGE_HANDLER->load_image(map_file, rle);
  if (arrayp(areas[i]->bbox)) {
    nw = copy(areas[i]->bbox[0]);
    nw[0] = areas[i]->bbox[1][0] - 1;
    nw[1] += 1;
    nw[2] += 1;
    areas[i]->exits->nw_coord = quantize_to_origin(nw, i);
  }
}
int new_area() {
  areas += ({ new(class AREA_INFO) });
}
void set_vertices(int a, mixed *vs) {
  int v, i;
  if (!arrayp(areas[a]->origin)) {
    error("Origin unset - setting to (0,0,0).\n");
    areas[a]->origin = ({ 0, 0, 0 });
  }
  areas[a]->vertices = copy(vs);
  areas[a]->bbox = ({ copy(vs[0]), copy(vs[0]) });
  for (i = 0; i < 3; i++) {
    areas[a]->bbox[0][i] += areas[a]->origin[i];
    areas[a]->bbox[1][i] += areas[a]->origin[i];
  }
  for (v = 0; v < sizeof(areas[a]->vertices); v++) {
    for (i = 0; i < 3; i++) {
      areas[a]->vertices[v][i] += areas[a]->origin[i];
      if (areas[a]->vertices[v][i] < areas[a]->bbox[0][i]) {
        areas[a]->bbox[0][i] = areas[a]->vertices[v][i];
      } else if (areas[a]->vertices[v][i] > areas[a]->bbox[1][i]) {
        areas[a]->bbox[1][i] = areas[a]->vertices[v][i];
      }
    }
  }
}
int in_bbox(int *coord, mixed *bbox) {
  if ((coord[0] < bbox[0][0]) || (coord[0] > bbox[1][0])) {
    return 0;
  }
  if ((coord[1] < bbox[0][1]) || (coord[1] > bbox[1][1])) {
    return 0;
  }
  if ((coord[2] < bbox[0][2]) || (coord[2] > bbox[1][2])) {
    return 0;
  }
  return 1;
}
int in_area(int a, int *v) {
  int crossings, i, i0, i1, de, int_n, below_vertex;
  mixed *vs;
  if (!in_bbox(v, areas[a]->bbox)) {
    return 0;
  }
  vs = allocate(2);
  for (i = 0; i < sizeof(areas[a]->vertices); i++) {
    below_vertex = 0;
    vs[0] = areas[a]->vertices[i];
    if (i < sizeof(areas[a]->vertices)-1) {
      vs[1] = areas[a]->vertices[i+1];
    } else {
      vs[1] = areas[a]->vertices[0];
    }
    if ((v[1] < vs[0][1]) && (v[1] < vs[1][1])) {
      continue;
    }
    if ((v[1] > vs[0][1]) && (v[1] > vs[1][1])) {
      continue;
    }
    if ((v[0] > vs[0][0]) && (v[0] > vs[1][0])) {
      continue;
    }
    if ((v[0] < vs[0][0]) && (v[0] < vs[1][0])) {
      if (v[1] != vs[0][1]) {
        if (v[1] != vs[1][1]) {
          crossings++;
        }
        continue;
      } else {
        below_vertex = 1;
      }
    }
    if (vs[0][1] == vs[1][1]) {
      if (!below_vertex) {
        return 1;
      }
      continue;
    }
    if ((v[0] == vs[0][0]) && (v[1] == vs[0][1])) {
      return 1;
    }
    if ((vs[0][0] == vs[1][0]) && !below_vertex) {
      return 1;
    }
    if (v[1] == vs[1][1]) {
      continue;
    }
    if (v[1] == vs[0][1]) {
      if (v[0] > vs[0][0]) {
        continue;
      }
      i0 = i;
      while (areas[a]->vertices[i0][1] == v[1]) {
        i0--;
        if (i0 < 0) i0 = sizeof(areas[a]->vertices) - 1;
      }
      i1 = i;
      while (areas[a]->vertices[i1][1] == v[1]) {
        i1++;
        if (i1 >= sizeof(areas[a]->vertices)) i1 = 0;
      }
      crossings++;
      if (((areas[a]->vertices[i0][1] > v[1]) &&
           (areas[a]->vertices[i1][1] > v[1])) ||
          ((areas[a]->vertices[i0][1] < v[1]) &&
           (areas[a]->vertices[i1][1] < v[1]))) {
        crossings++;
      }
      continue;
    }
    de = vs[1][1] - vs[0][1];
    int_n = ceil(to_float(vs[1][0] - vs[0][0])*(v[1] - vs[0][1])/de
                 + vs[0][0] + 0.5);
    if (int_n > v[0]) {
      crossings++;
    }
  }
  return (crossings & 1);
}
object clone_room(int a, int *coord_q, string coord_s) {
  int i, j, e, bit;
  string dir;
  object room;
  room = clone_object(areas[a]->base);
  room_cache[coord_s] = room;
  area_cache[coord_s] = a;
  room->set_room_size(areas[a]->size);
  room->set_co_ord(coord_q);
  if (areas[a]->exits) {
    i = (areas[a]->origin[0] - coord_q[0])/(2*areas[a]->size[0]);
    j = (coord_q[1] - areas[a]->origin[1])/(2*areas[a]->size[1]);
    if ((i < areas[a]->exits->size[0]) && (j < areas[a]->exits->size[1])
        && (i >= 0) && (j >= 0)) {
      e = areas[a]->exits->image[i][j];
      foreach (dir, bit in direction_bits) {
        if (e & bit) {
          room->add_exit(dir, "", "path");
        }
      }
      room->add_property("image_cell", ({ i, j }));
    }
  }
  return room;
}
object find_room_at_coord(int *coord) {
  int a, ac, *coord_q;
  string coord_s;
  object room;
  coord_s = sprintf("%d:%d:%d", coord[0], coord[1], coord[2]);
  if (objectp(room = room_cache[coord_s])) {
    return room;
  }
  if (!undefinedp(ac = area_cache[coord_s])) {
    return clone_room(ac, coord, coord_s);
  }
  for (a = 0; a < sizeof(areas); a++) {
    coord_q = quantize_to_origin(coord, a);
    coord_s = sprintf("%d:%d:%d", coord_q[0], coord_q[1], coord_q[2]);
    if (objectp(room = room_cache[coord_s])) {
      return room;
    }
    if (!undefinedp(ac = area_cache[coord_s])) {
      return clone_room(ac, coord_q, coord_s);
    }
    if (!in_area(a, coord_q)) {
      continue;
    }
    return clone_room(a, coord_q, coord_s);
  }
  return 0;
}
object find_room_at_exit(object r, int *d, string direc) {
  int a, ac, i, *coord, *coord_r, *coord_q;
  string coord_s;
  object room;
  mixed size_r;
  if (dbg_lvl > 0) {
    tell_creator(debugger, "%s::find_room_at_exit()\n"
                 "  r: %O\n"
                 "  d: %O\n"
                 "  direc: %O\n",
                 file_name(this_object()), r, d, direc);
  }
  if (!arrayp(d)) {
    return 0;
  }
  coord = r->query_co_ord();
  size_r = r->query_actual_room_size();
  if (!arrayp(size_r)) {
    size_r = r->query_room_size();
    if (!arrayp(size_r)) {
      size_r = ({ size_r, size_r, size_r });
    }
  }
  coord_r = allocate(3);
  for (a = 0; a < sizeof(areas); a++) {
    for (i = 0; i < 3; i++) {
      coord_r[i] = coord[i] + (size_r[i] + areas[a]->size[i]) * d[i];
    }
    coord_s = sprintf("%d:%d:%d", coord_r[0], coord_r[1], coord_r[2]);
    return load_object(_handler + ":" + coord_s);
#if 0
    if (objectp(room = room_cache[coord_s])) {
      if (dbg_lvl > 0) {
        tell_creator(debugger, "%s::find_room_at_exit()\n"
                 "  found room %O cached at %s...\n",
                 file_name(this_object()), room, coord_s);
      }
      return room;
    }
    if (!undefinedp(ac = area_cache[coord_s])) {
      if (dbg_lvl > 0) {
        tell_creator(debugger, "%s::find_room_at_exit()\n"
                 "  found area %O cached at %s...\n",
                 file_name(this_object()), ac, coord_s);
      }
      return clone_room(ac, coord_r, coord_s);
    }
    coord_q = quantize_to_origin(coord_r, a);
    coord_s = sprintf("%d:%d:%d", coord_q[0], coord_q[1], coord_q[2]);
    if (objectp(room = room_cache[coord_s])) {
      return room;
    }
    if (!undefinedp(ac = area_cache[coord_s])) {
      return clone_room(ac, coord_q, coord_s);
    }
    if (!in_area(a, coord_q)) {
      continue;
    }
    return clone_room(a, coord_q, coord_s);
#endif
  }
  return 0;
}
int goto_room_at_coord(int *coord) {
  return this_player()->move_with_look(find_room_at_coord(coord));
}
int goto_room_at_exit(int *d, string direc) {
  return this_player()->move_with_look(find_room_at_exit(
                        environment(this_player()), d, direc));
}
void print_images(int a) {
  if (areas[a]->height) {
    printf("-------- Height:\n");
    IMAGE_HANDLER->print_image(areas[a]->height);
  }
  if (areas[a]->exits) {
    printf("-------- Exits:\n");
    IMAGE_HANDLER->print_image(areas[a]->exits);
  }
}
void print_map(int a) {
  int s, e;
  string l = "";
  class IMAGE_INFO exits;
  if (areas[a]->exits) {
    exits = areas[a]->exits;
    for (s = 0; s < exits->size[1]; s++) {
      for (e = 0; e < exits->size[0]; e++) {
        l += (exits->image[s][e] & 128)?"\\":" ";
        l += (exits->image[s][e] & 1)  ?"|":" ";
        l += (exits->image[s][e] & 2)  ?"/":" ";
      }
      l += "\n";
      for (e = 0; e < exits->size[0]; e++) {
        l += (exits->image[s][e] & 64) ?"-":" ";
        l += "*";
        l += (exits->image[s][e] & 4)  ?"-":" ";
      }
      l += "\n";
      for (e = 0; e < exits->size[0]; e++) {
        l += (exits->image[s][e] & 32) ?"/":" ";
        l += (exits->image[s][e] & 16) ?"|":" ";
        l += (exits->image[s][e] & 8)  ?"\\":" ";
      }
      l += "\n";
    }
    write(l);
  }
}

==================================================
FILE: room/controller/topography/interroom.c
==================================================

#include <map.h>
inherit "/std/room";
class IROOM_INFO {
  string base;
  int *size;
  mixed *bbox;
  int sgn_n;
  int sgn_e;
  string *exits;
}
int closed;
nosave int dbg_lvl = 0;
mixed *irooms;
string *milestones;
mixed *milestone_coords;
mapping milestone_idx = ([ ]);
class IROOM_INFO *iroom_info;
mixed *overall_bbox;
string save_file;
nosave string debugger = "jeremy";
mixed *bbox(int *coord_a, int *coord_b);
int in_bbox(int *coord_a, mixed bbox);
void set_debugger(string s) { debugger = s; }
string query_debugger() { return debugger; }
void set_debug_level(int l) { dbg_lvl = l; }
int query_debug_level() { return dbg_lvl; }
mixed query(string s) { return fetch_variable(s); }
int abs(int i) {
  return (i<0)?-i:i;
}
float fabs(float i) {
  return (i<0)?-i:i;
}
void set_save_file(string s) { save_file = s; }
string query_save_file() { return save_file; }
void set_milestones(string *s) {
  int i;
  milestones = copy(s);
  if (milestones[0] == milestones[<1]) {
    closed = 1;
  }
  for (i = 0; i < sizeof(milestones) - closed; i++) {
    milestone_idx[s[i]] = i;
  }
  milestone_coords = allocate(sizeof(milestones));
  irooms = allocate(sizeof(milestones)-1);
  iroom_info = allocate(sizeof(milestones)-1);
  for (i = 0; i < sizeof(iroom_info); i++) {
    iroom_info[i] = new(class IROOM_INFO);
    iroom_info[i]->exits = allocate(2);
  }
  overall_bbox = 0;
}
string *query_milestones() { return milestones; }
string query_milestone(int i) { return milestones[i]; }
void set_milestone_coords(int i, int *c) {
  if (!arrayp(c) || (sizeof(c) != 3)) {
    return;
  }
  if (!arrayp(milestone_coords[i]) || (milestone_coords[i][0] != c[0])
  || (milestone_coords[i][1] != c[1]) || (milestone_coords[i][2] != c[2])) {
    milestone_coords[i] = copy(c);
    if ((i > 0) && arrayp(milestone_coords[i-1])) {
      iroom_info[i-1]->bbox = bbox(milestone_coords[i-1], milestone_coords[i]);
      if (milestone_coords[i-1][0] < milestone_coords[i][0]) {
        iroom_info[i-1]->sgn_n = 1;
      } else if (milestone_coords[i-1][0] > milestone_coords[i][0]) {
        iroom_info[i-1]->sgn_n = -1;
      } else {
        iroom_info[i-1]->sgn_n = 0;
      }
      if (milestone_coords[i-1][1] < milestone_coords[i][1]) {
        iroom_info[i-1]->sgn_e = 1;
      } else if (milestone_coords[i-1][1] > milestone_coords[i][1]) {
        iroom_info[i-1]->sgn_e = -1;
      } else {
        iroom_info[i-1]->sgn_e = 0;
      }
      if (!arrayp(overall_bbox)) {
        overall_bbox = copy(iroom_info[i-1]->bbox);
      } else {
        if (iroom_info[i-1]->bbox[0][0] < overall_bbox[0][0]) {
          overall_bbox[0][0] = iroom_info[i-1]->bbox[0][0];
        }
        if (iroom_info[i-1]->bbox[0][1] < overall_bbox[0][1]) {
          overall_bbox[0][1] = iroom_info[i-1]->bbox[0][1];
        }
        if (iroom_info[i-1]->bbox[1][0] > overall_bbox[1][0]) {
          overall_bbox[1][0] = iroom_info[i-1]->bbox[1][0];
        }
        if (iroom_info[i-1]->bbox[1][1] > overall_bbox[1][1]) {
          overall_bbox[1][1] = iroom_info[i-1]->bbox[1][1];
        }
      }
    }
    if ((i < sizeof(iroom_info)) && arrayp(milestone_coords[i+1])) {
      iroom_info[i]->bbox = bbox(milestone_coords[i], milestone_coords[i+1]);
      if (milestone_coords[i][0] < milestone_coords[i+1][0]) {
        iroom_info[i]->sgn_n = 1;
      } else if (milestone_coords[i][0] > milestone_coords[i+1][0]) {
        iroom_info[i]->sgn_n = -1;
      } else {
        iroom_info[i]->sgn_n = 0;
      }
      if (milestone_coords[i][1] < milestone_coords[i+1][1]) {
        iroom_info[i]->sgn_e = 1;
      } else if (milestone_coords[i][1] > milestone_coords[i+1][1]) {
        iroom_info[i]->sgn_e = -1;
      } else {
        iroom_info[i]->sgn_e = 0;
      }
      if (!arrayp(overall_bbox)) {
        overall_bbox = copy(iroom_info[i]->bbox);
      } else {
        if (iroom_info[i]->bbox[0][0] < overall_bbox[0][0]) {
          overall_bbox[0][0] = iroom_info[i]->bbox[0][0];
        }
        if (iroom_info[i]->bbox[0][1] < overall_bbox[0][1]) {
          overall_bbox[0][1] = iroom_info[i]->bbox[0][1];
        }
        if (iroom_info[i]->bbox[1][0] > overall_bbox[1][0]) {
          overall_bbox[1][0] = iroom_info[i]->bbox[1][0];
        }
        if (iroom_info[i]->bbox[1][1] > overall_bbox[1][1]) {
          overall_bbox[1][1] = iroom_info[i]->bbox[1][1];
        }
      }
    }
  }
}
mixed query_milestone_coords() { return milestone_coords; }
void set_bases(string *s) {
  int i;
  if (sizeof(s) != sizeof(iroom_info)) {
    error("Wrong number of bases (" + sizeof(s) + ") for given milestones (" +
          sizeof(milestones) + ").\n");
    return;
  }
  for (i = 0; i < sizeof(s); i++) {
    iroom_info[i]->base = s[i];
  }
}
void set_sizes(mixed *s) {
  int i;
  if (sizeof(s) != sizeof(iroom_info)) {
    error("Wrong number of sizes (" + sizeof(s) + ") for given milestones (" +
          sizeof(milestones) + ").\n");
    return;
  }
  for (i = 0; i < sizeof(s); i++) {
    iroom_info[i]->size = allocate(3);
    if (intp(s[i])) {
      iroom_info[i]->size[0] = s[i];
      iroom_info[i]->size[1] = s[i];
      iroom_info[i]->size[2] = s[i];
    } else if (arrayp(s[i])) {
      iroom_info[i]->size[0] = s[i][0];
      iroom_info[i]->size[1] = s[i][1];
      iroom_info[i]->size[2] = s[i][2];
    } else {
      error("Illegal room size given (" + i + ").\n");
      continue;
    }
  }
}
class IROOM_INFO *query_iroom_info() { return iroom_info; }
int query_endpoint(int i, int j, int dir) {
  if ((dir && (j == sizeof(irooms[i])-1)) || (!dir && (j == 0))) {
    return 1;
  }
  return 0;
}
object *query_irooms_inv(int i, int j, int dir) {
  int k;
  object *invs;
  invs = ({ });
  if (dir) {
    if (!arrayp(irooms[i])) {
      return invs;
    }
    for (k = j+1; k < sizeof(irooms[i]); k++) {
      if (objectp(irooms[i][k])) {
        invs += all_inventory(irooms[i][k]);
      }
    }
  } else {
    if (j == -1) {
      if (closed) {
        i = sizeof(milestones) - 2;
      } else {
        i--;
      }
      if (!arrayp(irooms[i])) {
        return invs;
      } else {
        j = sizeof(irooms[i]);
      }
    } else if (!arrayp(irooms[i])) {
      return invs;
    }
    for (k = j-1; k >= 0; k--) {
      if (objectp(irooms[i][k])) {
        invs += all_inventory(irooms[i][k]);
      }
    }
  }
  return invs;
}
mixed *bbox(int *coord_a, int *coord_b) {
  int c;
  mixed *bbox;
  bbox = allocate(2);
  bbox[0] = allocate(3);
  bbox[1] = allocate(3);
  for (c = 0; c < 3; c++) {
    if (coord_a[c] < coord_b[c]) {
      bbox[0][c] = coord_a[c];
      bbox[1][c] = coord_b[c];
    } else {
      bbox[0][c] = coord_b[c];
      bbox[1][c] = coord_a[c];
    }
  }
  return bbox;
}
int in_bbox(int *coord_a, mixed bbox) {
  if ((coord_a[0] < bbox[0][0]) || (coord_a[0] > bbox[1][0])
  || (coord_a[1] < bbox[0][1]) || (coord_a[1] > bbox[1][1]))
    return 0;
  return 1;
}
int number_of_irooms(int i) {
  int n;
  mixed bbox;
  class IROOM_INFO ir;
  ir = iroom_info[i];
  bbox = ir->bbox;
  if (ir->sgn_n == 0) {
    n = (bbox[1][1] - bbox[0][1])/(ir->size[1]*2);
  } else if (ir->sgn_e == 0) {
    n = (bbox[1][0] - bbox[0][0])/(ir->size[0]*2);
  } else {
    n = (bbox[1][1] - bbox[0][1])/(ir->size[1]*2);
    if (n != (bbox[1][0] - bbox[0][0])/(ir->size[0]*2)) {
      error("Interroom sizes don't match diagonal.\n");
      return 0;
    }
  }
  return n-1;
}
object clone_iroom(int i, int idx, int *icoord) {
  object iroom;
  iroom = clone_object(iroom_info[i]->base);
  iroom->set_room_size(iroom_info[i]->size);
  iroom->set_co_ord(icoord);
  iroom->set_milestone_index( ({ i, idx }) );
  iroom->add_exit(iroom_info[i]->exits[0], milestones[i], "road");
  iroom->add_exit(iroom_info[i]->exits[1], milestones[i+1], "road");
  iroom->add_milestone_dir(iroom_info[i]->exits[0]);
  iroom->add_milestone_dir(iroom_info[i]->exits[1]);
  iroom->add_topo_exits_int();
  return iroom;
}
void setup_milestone(object ms) {
  int *coord, i, j, idir;
  string *dir;
  if (undefinedp(i = milestone_idx[file_name(ms)])) {
    error("This room (" + file_name(ms) + ") is not a milestone.\n");
    return;
  }
  ms->set_milestone_index(file_name(this_object()), i);
  coord = ms->query_co_ord();
  if (arrayp(coord)) {
    set_milestone_coords(i, coord);
  } else {
    if (arrayp(milestone_coords[i])) {
      coord = milestone_coords[i];
    } else {
      coord = MAP->static_query_co_ord(file_name(ms));
      set_milestone_coords(i, coord);
    }
    ms->set_co_ord(coord);
  }
  if (closed && (i == 0)) {
    milestone_coords[<1] = milestone_coords[0];
  }
  dir = ms->query_dest_dir();
  if ((i > 0) || closed) {
    if (closed && i == 0) {
      j = sizeof(milestones) - 2;
    } else {
      j = i - 1;
    }
    if ((idir = member_array(milestones[j], dir)) < 0) {
      ms->add_milestone_dir(file_name(this_object()), 0);
    } else {
      iroom_info[j]->exits[0] = dir[idir-1];
      ms->add_milestone_dir(file_name(this_object()), dir[idir-1]);
    }
  } else {
    ms->add_milestone_dir(file_name(this_object()), 0);
  }
  if (i < sizeof(irooms)) {
    j = i + 1;
    if ((idir = member_array(milestones[j], dir)) < 0) {
      ms->add_milestone_dir(file_name(this_object()), 0);
    } else {
      iroom_info[i]->exits[1] = dir[idir-1];
      ms->add_milestone_dir(file_name(this_object()), dir[idir-1]);
    }
  }
}
varargs object find_room_at_coord(int *coord_a, int hint_idx) {
  int i, idx, in_bbox;
  int start_i, stop_i;
  int *icoord = ({ 0, 0, 0 });
  mixed bbox;
  float slope;
  class IROOM_INFO ir;
  if (dbg_lvl > 0) {
    tell_creator(debugger, "%s::find_room_at_coord()\n"
                 "  coord_a: %O\n"
                 "  hint_idx: %s\n",
                 file_name(this_object()), coord_a,
                 undefinedp(hint_idx)?"NULL":hint_idx+"");
  }
  if (!in_bbox(coord_a, overall_bbox)) {
    return 0;
  }
  in_bbox = 0;
  if (undefinedp(hint_idx)) {
    start_i = 0;
    stop_i = sizeof(iroom_info);
  } else {
    start_i = hint_idx;
    stop_i = hint_idx + 1;
  }
  for (i = start_i; i < stop_i; i++) {
    ir = iroom_info[i];
    bbox = ir->bbox;
    if (dbg_lvl > 1) {
      tell_creator(debugger, "%s::find_room_at_coord()\n"
                   "  Checking bbox(%d,%d): %O\n",
                   file_name(this_object()), i, i+1, bbox);
    }
    if (in_bbox(coord_a, bbox)) {
      if (dbg_lvl > 1) {
        tell_creator(debugger, "%s::find_room_at_coord()\n"
                     "  In bbox(%d,%d)...\n",
                     file_name(this_object()), i, i+1);
      }
      if (ir->sgn_e == 0) {
        if (abs(coord_a[1]-milestone_coords[i][1]) < ir->size[1]) {
          if (dbg_lvl > 2) {
            tell_creator(debugger, "%s::find_room_at_coord()\n"
                         "  On vline between (%d,%d)...\n",
                         file_name(this_object()), i, i+1);
          }
          break;
        }
      } else {
        slope = to_float(milestone_coords[i][0] - milestone_coords[i+1][0])
          / to_float(milestone_coords[i][1] - milestone_coords[i+1][1]);
        if (abs(slope * (coord_a[1] - milestone_coords[i+1][1]) +
            milestone_coords[i+1][0] - coord_a[0]) < ir->size[0]) {
          if (dbg_lvl > 2) {
            tell_creator(debugger, "%s::find_room_at_coord()\n"
                         "  On line between (%d,%d)...\n",
                         file_name(this_object()), i, i+1);
          }
          break;
        }
      }
    }
  }
  if (i == stop_i) {
    if (dbg_lvl > 2) {
      tell_creator(debugger, "%s::find_room_at_coord()\n"
                   "  Couldn't find a room...\n",
                   file_name(this_object()));
    }
    return 0;
  }
  if (ir->sgn_n == 0) {
    idx = abs(coord_a[1] - milestone_coords[i][1]
              + ir->size[1]*ir->sgn_e)/(ir->size[1]*2);
    icoord[0] = milestone_coords[i][0];
    icoord[1] = milestone_coords[i][1] + idx*ir->sgn_e*ir->size[1]*2;
  } else {
    idx = abs(coord_a[0] - milestone_coords[i][0]
              + ir->size[0]*ir->sgn_n)/(ir->size[0]*2);
    icoord[0] = milestone_coords[i][0] + idx*ir->sgn_n*ir->size[0]*2;
    if (ir->sgn_e == 0) {
      icoord[1] = milestone_coords[i][1];
    } else {
      icoord[1] = milestone_coords[i][1] + idx*ir->sgn_e*ir->size[1]*2;
    }
  }
  if (dbg_lvl > 2) {
    tell_creator(debugger, "%s::find_room_at_coord()\n"
                 "  idx: %O\n",
                 file_name(this_object()), idx);
  }
  if (idx == 0) {
    return load_object(milestones[i]);
  }
  if (!arrayp(irooms[i])) {
    irooms[i] = allocate(number_of_irooms(i));
  }
  if (idx == sizeof(irooms[i])+1) {
    return load_object(milestones[i+1]);
  }
  idx--;
  if (!objectp(irooms[i][idx])) {
    icoord[2] = (milestone_coords[i+1][2] - milestone_coords[i][2])
      * idx / sizeof(irooms[i]) + milestone_coords[i][2];
    irooms[i][idx] = clone_iroom(i, idx, icoord);
  }
  return irooms[i][idx];
}
object find_room_at_index(int i, int idx) {
  int *icoord = ({ 0, 0, 0 });
  class IROOM_INFO ir;
  if (dbg_lvl > 0) {
    tell_creator(debugger, "%s::find_room_at_index()\n"
                 "  i: %O, idx: %O\n",
                 file_name(this_object()), i, idx);
  }
  if (closed && (i == -1)) {
    i = sizeof(milestones) - 2;
  }
  if ((i < 0) || (i >= sizeof(irooms))) {
    return 0;
  }
  if (idx == -1) {
    return load_object(milestones[i]);
  }
  if (!arrayp(irooms[i])) {
    irooms[i] = allocate(number_of_irooms(i));
  }
  if (idx == sizeof(irooms[i])) {
    return load_object(milestones[i+1]);
  }
  if (idx == -2) {
    idx = sizeof(irooms[i]) - 1;
  }
  if ((idx < 0) || (idx >= sizeof(irooms[i]))) {
    return 0;
  }
  if (!objectp(irooms[i][idx])) {
    ir = iroom_info[i];
    if (ir->sgn_n == 0) {
      icoord[0] = milestone_coords[i][0];
      icoord[1] = milestone_coords[i][1] + (idx+1)*ir->sgn_e*ir->size[1]*2;
    } else {
      icoord[0] = milestone_coords[i][0] + (idx+1)*ir->sgn_n*ir->size[0]*2;
      if (ir->sgn_e == 0) {
        icoord[1] = milestone_coords[i][1];
      } else {
        icoord[1] = milestone_coords[i][1] + (idx+1)*ir->sgn_e*ir->size[1]*2;
      }
    }
    icoord[2] = (milestone_coords[i+1][2] - milestone_coords[i][2])
      * idx / sizeof(irooms[i]) + milestone_coords[i][2];
    irooms[i][idx] = clone_iroom(i, idx, icoord);
  }
  return irooms[i][idx];
}
int query_region(int *coord, mixed bbox) {
  int ret;
  if (coord[0] < bbox[0][0]) {
    ret += 1;
  } else if (coord[0] > bbox[1][0]) {
    ret += 2;
  }
  if (coord[1] < bbox[0][1]) {
    ret += 4;
  } else if (coord[1] > bbox[1][1]) {
    ret += 8;
  }
  return ret;
}
object find_room_at_crossing(int *coord_a, int *coord_b) {
  int i, a, b, c, d, dist2, ret_dist2;
  float e, f, det;
  int *isect;
  object ret;
  mixed bbox, road_a, road_b;
  if (dbg_lvl > 0) {
    tell_creator(debugger, "%s::find_room_at_crossing()\n"
                 "  coord_a: %O\n"
                 "  coord_b: %O\n",
                 file_name(this_object()), coord_a, coord_b);
  }
  if (query_region(coord_a, overall_bbox)
      & query_region(coord_b, overall_bbox)) {
    return 0;
  }
  for (i = 0; i < sizeof(iroom_info); i++) {
    bbox = iroom_info[i]->bbox;
    if (query_region(coord_a, iroom_info[i]->bbox)
        & query_region(coord_b, iroom_info[i]->bbox)) {
      continue;
    }
    road_a = allocate(3);
    road_b = allocate(3);
    if (iroom_info[i]->sgn_n > 0) {
      road_a[0] = bbox[0][0];
      road_b[0] = bbox[1][0];
    } else {
      road_a[0] = bbox[1][0];
      road_b[0] = bbox[0][0];
    }
    if (iroom_info[i]->sgn_e > 0) {
      road_a[1] = bbox[0][1];
      road_b[1] = bbox[1][1];
    } else {
      road_a[1] = bbox[1][1];
      road_b[1] = bbox[0][1];
    }
    a = coord_b[0] - coord_a[0];
    b = coord_a[1] - coord_b[1];
    c = road_b[0] - road_a[0];
    d = road_a[1] - road_b[1];
    e = to_float(a)*coord_a[1] + to_float(b)*coord_a[0];
    f = to_float(c)*road_a[1] + to_float(d)*road_a[0];
    det = a*d - b*c;
    if (fabs(det) < 0.0000000000001) {
      continue;
    }
    isect = allocate(3);
    isect[0] = to_int(floor((a*f - e*c)/det + 0.5));
    isect[1] = to_int(floor((e*d - b*f)/det + 0.5));
    if (!in_bbox(isect, bbox) || !in_bbox(isect, bbox(coord_a, coord_b))) {
      continue;
    }
    dist2 = (isect[0]-coord_a[0])*(isect[0]-coord_a[0]) +
      (isect[1]-coord_a[1])*(isect[1]-coord_a[1]);
    if (objectp(ret) && (dist2 >= ret_dist2)) {
      continue;
    }
    ret = find_room_at_coord(isect, i);
    if (dbg_lvl > 0) {
      tell_creator(debugger, "%s::find_room_at_crossing()\n"
                   "  find_room_at_coord() returned %O\n",
                   file_name(this_object()), ret);
    }
    ret_dist2 = dist2;
    if (!objectp(ret)) {
      error("Couldn't find a room where there should be one!\n");
    }
  }
  return ret;
}
void create() {
  string std_euid;
  std_euid = "/secure/master"->creator_file(file_name(this_object()));
  seteuid(std_euid);
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
  set_keep_room_loaded(1);
}
void dest_me() {
  if (stringp(save_file)) {
    unguarded( (: save_object, save_file :) );
  }
  ::dest_me();
}
int goto_room_at_coord(int *coord) {
  return this_player()->move_with_look(find_room_at_coord(coord));
}
int goto_room_at_index(int i, int j) {
  return this_player()->move_with_look(find_room_at_index(i, j));
}
int goto_room_at_crossing(int *a, int *b) {
  return this_player()->move_with_look(find_room_at_crossing(a, b));
}
void recalc_milestones(int idx, int callouts, object tp) {
  int *c;
  string ms;
  if (callouts > 10) {
    error(sprintf("Too many callouts in %s:recalc_iroom_info(%d, %d)\n",
          file_name(this_object()), idx, callouts));
    return;
  }
  if (!idx && !callouts && !tp) {
    rm(save_file);
    this_object()->setup();
    idx = 0;
    tp = this_player();
  }
  ms = milestones[idx];
  if (!arrayp(c = ms->query_co_ord())) {
    call_out("recalc_milestones", 0, idx, callouts+1, tp);
    tell_object(tp, sprintf("Waiting on %s (%d, %d)...\n",
                          ms, idx, callouts));
    return;
  }
  ms->setup_milestone(ms);
  tell_object(tp, sprintf("Loaded room %s at (%d, %d, %d)...\n",
                          ms, c[0], c[1], c[2]));
  idx++;
  if (idx < sizeof(milestones)) {
    call_out("recalc_milestones", 0, idx, 0, tp);
    return;
  }
  tell_object(tp, "IRoom info successfully recalculated.\n");
}
void clear_map_handler() {
  int i;
  string ms, directory, troom;
  for (i = 0; i < sizeof(milestones); i++) {
    ms = milestones[i];
    directory = implode( explode( ms, "/" )[ 0..<2 ], "/" );
    troom = explode( ms, "/" )[ <1 ];
    if ( troom[ <2.. ] == ".c" ) {
      troom = troom[ 0..<3];
    }
    MAP->del(directory, troom);
    printf("Deleting %s in %s from map handler.\n", directory, troom);
  }
}
int sanity_checks() {
  int i, success = 1;
  for (i = 0; i < sizeof(milestone_coords); i++) {
    if (sizeof(milestone_coords[i]) != 3) {
      printf("Milestone %d (%s) doesn't have proper coordinates: %O\n",
             i, milestones[i], milestone_coords[i]);
      success = 0;
    }
  }
  for (i = 0; i < sizeof(iroom_info); i++) {
    if (sizeof(iroom_info[i]->size) != 3) {
      printf("Interroom segment %d has improper size: %O\n",
             i, iroom_info[i]->size);
      success = 0;
    }
    if ((sizeof(iroom_info[i]->bbox) != 2) ||
        (sizeof(iroom_info[i]->bbox[0]) != 3) ||
        (sizeof(iroom_info[i]->bbox[1]) != 3)) {
      printf("Interroom segment %d has improper bounding box: %O\n",
             i, iroom_info[i]->bbox);
      success = 0;
    }
  }
  return success;
}

==================================================
FILE: room/controller/topography/topography.c
==================================================

#include <dirs.h>
#include "path.h"
inherit "/std/basic/setup";
class bounding_box {
   int* topleft;
   int* bottomright;
}
class FIXED_INFO {
  string path;
  object ob;
  int *coord;
  mixed bbox;
}
private mapping opposites = ([
  "north": "south", "south": "north", "west": "east",
  "east": "west", "northeast": "southwest", "southwest": "northeast",
  "northwest": "southeast", "southeast": "northwest", "up": "down",
  "down": "up"
]);
private int _dbg_lvl = 0;
private string _debugger;
private object *_area_handlers = ({ });
private object *_iroom_handlers = ({ });
private class FIXED_INFO *_fixed_rooms = ({ });
private mapping _fixed_room_index = ([ ]);
private class bounding_box _topo_box;
void set_debugger(string s) { _debugger = s; }
string query_debugger() { return _debugger; }
void set_debug_level(int l) { _dbg_lvl = l; }
int query_debug_level() { return _dbg_lvl; }
void create() {
  do_setup();
}
class bounding_box query_bounding_box() {
   return _topo_box;
}
int in_bbox(int *coord, class bounding_box bbox) {
  if ((coord[0] < bbox->topleft[0]) || (coord[0] > bbox->bottomright[0])) {
    return 0;
  }
  if ((coord[1] < bbox->topleft[1]) || (coord[1] > bbox->bottomright[1])) {
    return 0;
  }
  return 1;
}
class bounding_box bounding_box(int *coord, mixed s) {
  int *size;
  class bounding_box bbox;
  if (sizeof(coord) != 3) {
    return 0;
  }
  if (arrayp(s)) {
    if (sizeof(s) == 3) {
      size = s;
    } else {
      return 0;
    }
  } else if (intp(s)) {
    size = ({ s, s, s });
  } else {
    return 0;
  }
  bbox = new(class bounding_box);
  bbox->topleft = ({ coord[0]-size[0], coord[1]-size[1], coord[2]-size[2] });
  bbox->bottomright = ({ coord[0]+size[0], coord[1]+size[1], coord[2]+size[2] });
  return bbox;
}
void add_area_handler(mixed h) {
  object oh;
  if (stringp(h)) {
    oh = load_object(h);
    oh->set_handler(base_name(this_object()));
    if (objectp(oh)) {
      _area_handlers += ({ oh });
    } else {
      error(sprintf("Couldn't find area handler %s.\n", h));
    }
  } else if (objectp(h)) {
    h->set_handler(base_name(this_object()));
    _area_handlers += ({ h });
  } else {
    error(sprintf("Couldn't find area handler %O.\n", h));
  }
}
void add_iroom_handler(mixed h) {
  object oh;
  if (stringp(h)) {
    oh = load_object(h);
    oh->set_handler(base_name(this_object()));
    if (objectp(oh)) {
      _iroom_handlers += ({ oh });
    } else {
      error(sprintf("Couldn't find interroom handler %s.\n", h));
    }
  } else if (objectp(h)) {
    h->set_handler(base_name(this_object()));
    _iroom_handlers += ({ h });
  } else {
    error(sprintf("Couldn't find interroom handler %O.\n", h));
  }
}
private void add_internal_fixed_room(string path,
                                     object ob,
                                     int* coord,
                                     class bounding_box bbox) {
  class FIXED_INFO cf;
  cf = new(class FIXED_INFO);
  cf->path = path;
  cf->ob = ob;
  cf->coord = coord;
  cf->bbox = bbox;
  _fixed_room_index[cf->path] = sizeof(_fixed_rooms);
  _fixed_rooms += ({ cf });
}
void add_fixed_room(string f) {
  object of;
  of = load_object(f);
  if (!objectp(of)) {
    error(sprintf("Couldn't load fixed room %s.\n", f));
    return;
  }
  add_internal_fixed_room(f, of, of->query_co_ord(),
                      bounding_box(of->query_co_ord(), of->query_room_size()));
}
void add_fixed_room_object(object of) {
  add_internal_fixed_room(file_name(of), of, of->query_co_ord(),
                    bounding_box(of->query_co_ord(), of->query_room_size()));
}
void add_fixed_room_coordinate(string f, int* coord, int* size) {
    add_internal_fixed_room(f, 0, coord, bounding_box(coord, size));
}
void setup_fixed_room() {
  object shad, r;
  int i;
  r = previous_object();
  shad = clone_object(FIXED_SHADOW);
  if (!objectp(shad)) {
    error(sprintf("Couldn't create shadow for fixed room %O.\n", r));
    return;
  }
  shad->attach(r);
  shad->set_area_handler(file_name(this_object()));
  if (undefinedp(i = _fixed_room_index[file_name(r)])) {
    error(sprintf("Couldn't find entry for fixed room %O.\n", r));
  }
  r->set_co_ord(_fixed_rooms[i]->coord);
}
object find_room_at_coord(int *coord) {
  int i;
  object ob;
  if (_dbg_lvl > 0) {
    tell_creator(_debugger, "%s::find_room_at_coord()\n"
                 "  coord: %O\n",
                 file_name(this_object()), coord);
  }
  for (i = 0; i < sizeof(_fixed_rooms); i++) {
    if (in_bbox(coord, _fixed_rooms[i]->bbox)) {
      if (!objectp(_fixed_rooms[i]->ob)) {
        _fixed_rooms[i]->ob = load_object(_fixed_rooms[i]->path);
      }
      return _fixed_rooms[i]->ob;
    }
  }
  for (i = 0; i < sizeof(_iroom_handlers); i++) {
    if (objectp(ob = _iroom_handlers[i]->find_room_at_coord(coord))) {
      return ob;
    }
  }
  for (i = 0; i < sizeof(_area_handlers); i++) {
    if (objectp(ob = _area_handlers[i]->find_room_at_coord(coord))) {
      return ob;
    }
  }
  return 0;
}
object create_virtual_object(int x, int y, int z) {
   if (undefinedp(x) || undefinedp(y) || undefinedp(z)) {
      return 0;
   }
   return find_room_at_coord(({ x, y, z }));
}
object find_room_at_exit(object r, int *d, string direc) {
  int i, s, dist, max_dist, max_iroom, *coord, *coord_r, *coord_ob;
  string msg;
  object ob, *irooms = ({ });
  mixed size_r;
  class bounding_box bbox_r;
  if (_dbg_lvl > 0) {
    tell_creator(_debugger, "%s::find_room_at_exit()\n"
                 "  r: %O\n"
                 "  d: %O\n"
                 "  direc: %O\n",
                 file_name(this_object()), r, d, direc);
  }
  if (!arrayp(d)) {
    return 0;
  }
  coord = r->query_co_ord();
  size_r = r->query_actual_room_size();
  if (!arrayp(size_r)) {
    size_r = r->query_room_size();
    if (!arrayp(size_r)) {
      size_r = ({ size_r, size_r, size_r });
    }
  }
  coord_r = allocate(3);
  for (i = 0; i < 3; i++) {
    coord_r[i] = coord[i] + 2 * size_r[i] * d[i];
  }
  for (i = 0; i < sizeof(_fixed_rooms); i++) {
    if (in_bbox(coord_r, _fixed_rooms[i]->bbox)) {
      if (!objectp(_fixed_rooms[i]->ob)) {
        _fixed_rooms[i]->ob = load_object(_fixed_rooms[i]->path);
      }
      msg = evaluate(_fixed_rooms[i]->ob->query_topo_barrier(direc));
      if (!undefinedp(msg)) {
        if (!stringp(msg)) {
          msg = "You can't go that way.\n";
        }
        notify_fail(msg);
        return 0;
      }
      return _fixed_rooms[i]->ob;
    }
  }
  bbox_r = bounding_box(coord, size_r);
  for (i = 0; i < sizeof(_iroom_handlers); i++) {
    ob = _iroom_handlers[i]->find_room_at_crossing(coord, coord_r);
    tell_creator("rhinehold", "ob = %O\n", ob);
    if (objectp(ob )
        && (ob != r)) {
      if (_dbg_lvl > 1) {
        tell_creator(_debugger, "%s::find_room_at_exit()\n"
                     "  %O->find_room_at_crossing() returned %O\n",
                     file_name(this_object()), _iroom_handlers[i], ob);
      }
      if (!arrayp(ob->query_co_ord())) {
        return ob;
      }
      if (r->query_fixed_room() && in_bbox(ob->query_co_ord(), bbox_r)) {
        continue;
      }
      irooms += ({ ob });
    }
  }
  if ((s = sizeof(irooms)) > 0) {
    if (s == 1) {
      return irooms[0];
    } else {
      max_dist = 0;
      max_iroom = -1;
      for (i = 0; i < s; i++) {
        coord_ob = irooms[i]->query_co_ord();
        dist = (coord[0] - coord_ob[0])*(coord[0] - coord_ob[0]) +
          (coord[1] - coord_ob[1])*(coord[1] - coord_ob[1]);
        if (dist > max_dist) {
          max_dist = dist;
          max_iroom = i;
        }
      }
      if (max_iroom >= 0) {
        return irooms[max_iroom];
      }
    }
  }
  for (i = 0; i < sizeof(_area_handlers); i++) {
    if (objectp(ob = _area_handlers[i]->find_room_at_exit(r, d))) {
      if (_dbg_lvl > 1) {
        tell_creator(_debugger, "%s::find_room_at_exit()\n"
                     "  %O->find_room_at_exit() returned %O\n",
                     file_name(this_object()), _area_handlers[i], ob);
      }
      return ob;
    }
  }
  return 0;
}
int goto_room_at_coord(int *coord) {
  return this_player()->move_with_look(find_room_at_coord(coord));
}
string query_text_map(int width) {
   int x;
   int y;
   int maxy;
   string map;
   object room;
   map = "";
   for (y = 0; y < maxy; y++) {
      for (x = 0; x < width; x++) {
         room = find_room_at_coord( ({ x, y, 0 }) );
         if (!room) {
            map += " ";
         } else if (!room->query_room_letter()) {
            map += "?";
         } else {
            map += room->query_room_letter();
         }
      }
      map += "\n";
   }
   return map;
}

==================================================
FILE: room/punishments/banishment.c
==================================================

#include <nomic_system.h>
inherit "/std/room/inherit/punishment_inherit";
private nosave string _banish_handler;
void create() {
   set_short("banishment");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "banishment");
   ::create();
}
void set_banish_handler(string hand) {
   _banish_handler = hand;
}
string query_banish_handler() {
   return _banish_handler;
}
string query_short(string area, class nomic_case the_case, string type, mixed data) {
   return ::query_short() + " for " + data + " days";
}
void start_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      function finish) {
   if (sizeof(filter(the_case->people,
                    (: NOMIC_HANDLER->is_magistrate_of($2, $1) :), area))) {
      write("You cannot banish a magistrate.\n");
      return ;
   }
   write("How long do you want the person banished from the city for (in "
         "days, 0 means forever)? ");
   input_to("days_of_banishment", 0, area, the_case, type, finish);
}
void days_of_banishment(string input,
                        string area,
                        class nomic_case the_case,
                        string type,
                        function finish) {
   int num;
   input = lower_case(input);
   if (input == "" || input[0] == 'q') {
      write("Aborting banishment.\n");
      return ;
   }
   if (input[0] >= '0' && input[0] <= '9') {
      if (sscanf(input, "%d", num) == 1) {
         evaluate(finish, the_case, type, num);
         return ;
      }
   }
   write("Invalid input.\n");
   write("How long do you want the person banished from the city for (in "
         "days, 0 means forever)? ");
   input_to("days_of_banishment", 0, area, the_case, type, finish);
}
void complete_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;
   foreach (person in the_case->people) {
      _banish_handler->banish_person(person, data);
   }
   return ;
}
void suspend_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;
   foreach (person in the_case->people) {
      _banish_handler->banish_person_suspend(person);
   }
   return ;
}

==================================================
FILE: room/punishments/dismissed.c
==================================================

#include <nomic_system.h>
inherit "/std/room/inherit/punishment_inherit";
void setup() {
   set_short("dismissed");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "dismissed");
}

==================================================
FILE: room/punishments/fine.c
==================================================

#include <money.h>
#include <nomic_system.h>
#include <player_handler.h>
inherit "/std/room/inherit/punishment_inherit";
#define TIMEOUT (4 * 7 * 24 * 60 * 60)
private mapping _fines;
private nosave string _money_area;
private nosave string _save_file;
class fine_type {
   int paid;
   int fines;
   int last_touched;
}
void load_me();
void setup() {
   _fines = ([ ]);
   set_short("fine");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "fine");
   seteuid(getuid());
   load_me();
}
void load_me() {
   if (_save_file) {
      unguarded((: restore_object( _save_file ) :));
      call_out("remove_old_fines", 2);
   }
}
void save_me() {
   unguarded((: save_object( _save_file ) :));
}
void remove_old_fines() {
   class fine_type fine;
   string player;
   int changed;
   foreach (player, fine in _fines) {
      if (!PLAYER_HANDLER->test_user(player)) {
         map_delete(_fines, player);
         changed = 1;
      }
      if (sizeof(fine) == 2) {
         fine = new(class fine_type, paid : fine->paid, fines : fine->fines,
                                last_touched : time());
         _fines[player] = fine;
         changed = 1;
      }
      if (fine->fines <= 0 && fine->last_touched + TIMEOUT < time()) {
         map_delete(_fines, player);
         changed = 1;
      }
   }
   if (changed) {
      save_me();
   }
}
void set_money_area(string area) {
   _money_area = area;
}
string query_money_area() {
   return _money_area;
}
void set_save_file(string fname) {
   _save_file = fname;
}
string query_save_file() {
   return _save_file;
}
void start_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      function finish) {
   write("How much do you wish to fine " +
         query_multiple_short(the_case->people) + "? ");
   input_to("fine_amount", 0, area, the_case, type, finish);
}
string query_short(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   return "fined " +
          MONEY_HAND->money_value_string(data, _money_area);
}
void fine_amount(string amt, string area, class nomic_case the_case,
                 string type, function finish) {
   int value;
   amt = lower_case(amt);
   if (!strlen(amt) || amt[0] == 'q') {
      write("Aborting the fine.\n");
      return ;
   }
   value = MONEY_HAND->value_from_string(amt, _money_area);
   if (value <= 0) {
      write("You did not specify a positive money value.\n");
      write("How much do you wish to fine " +
            query_multiple_short(the_case->people) + "? ");
      input_to("fine_amount", 0, area, the_case, type, finish);
      return ;
   }
   evaluate(finish, the_case, type, value);
}
void complete_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;
   foreach (person in the_case->people) {
      if (!_fines[person]) {
         _fines[person] = new(class fine_type);
      }
      _fines[person]->fines += data;
      _fines[person]->last_touched = time();
   }
   save_me();
   return ;
}
void suspend_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;
   foreach (person in the_case->people) {
      if (!_fines[person]) {
         _fines[person] = new(class fine_type);
      }
      _fines[person]->fines -= data;
      _fines[person]->last_touched = time();
   }
   save_me();
   return ;
}
int pay_fine(string person, int amount) {
   if (_fines[person]) {
      _fines[person]->paid += amount;
      _fines[person]->last_touched = time();
      save_me();
      return 1;
   }
   return 0;
}
int query_current_fine(string person) {
   if (_fines[person]) {
      return _fines[person]->fines - _fines[person]->paid;
   }
   return 0;
}
int query_total_fine(string person) {
   if (_fines[person]) {
      return _fines[person]->fines;
   }
   return 0;
}
int query_total_payments(string person) {
   if (_fines[person]) {
      return _fines[person]->paid;
   }
   return 0;
}
string* query_people_with_fines() {
   return keys(_fines);
}

==================================================
FILE: room/punishments/lose_citizenship.c
==================================================

#include <nomic_system.h>
inherit "/std/room/inherit/punishment_inherit";
void setup() {
   set_short("lose citizenship");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "lose_citizenship");
}
void start_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      function finish) {
   string* not_citizens;
   string* magistrates;
   not_citizens = filter(the_case->people,
                     (: !NOMIC_HANDLER->is_citizen_of($2, $1) :), area);
   if (sizeof(not_citizens)) {
      write(query_multiple_short(not_citizens) + " cannot lose "
            "their citizenship since they are not citizens.\n");
      return ;
   }
   magistrates = filter(the_case->people,
                    (: NOMIC_HANDLER->is_magistrate_of($2, $1) :), area);
   if (sizeof(magistrates)) {
      write(query_multiple_short(magistrates) + " cannot lose "
            "their citizenship since they are magistrates.\n");
      return ;
   }
   evaluate(finish, the_case, type, 0);
}
void complete_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string citizen;
   foreach (citizen in the_case->people) {
      NOMIC_HANDLER->remove_citizen(area, citizen);
   }
   return ;
}
void suspend_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string citizen;
   foreach (citizen in the_case->people) {
      NOMIC_HANDLER->add_citizen(area, citizen);
   }
   return ;
}

==================================================
FILE: room/punishments/not_guilty.c
==================================================

#include <nomic_system.h>
inherit "/std/room/inherit/punishment_inherit";
void setup() {
   set_short("not guilty");
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "not_guilty");
}

==================================================
FILE: room/punishments/title.c
==================================================

#include <money.h>
#include <nomic_system.h>
#include <player_handler.h>
#include <player.h>
inherit "/std/room/inherit/punishment_inherit";
private nosave string* _titles;
void create() {
   _titles = ({ });
   set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "title");
   set_short("title");
   ::create();
}
void set_titles(string* titles) {
   _titles = titles;
}
string* query_titles() {
   return _titles;
}
void start_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      function finish) {
   int i;
   for (i = 0; i < sizeof(_titles); i++) {
      write(sprintf("%c) %s\n", i + 'A', _titles[i]));
   }
   write("Which title do you wish " +
         query_multiple_short(the_case->people) + " to have? ");
   input_to("choose_title", 0, area, the_case, type, finish);
}
string query_short(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   return "set to a title of " + data[0] + " for " + data[1] + " hours";
}
void choose_title(string title, string area, class nomic_case the_case,
                 string type, function finish) {
   int i;
   int pos;
   if (!strlen(title) || title[0] == 'q') {
      write("Aborting the title setting.\n");
      return ;
   }
   title = lower_case(title);
   if (strlen(title) == 1) {
      pos = title[0] = 'a';
      if (pos >= 0 && pos < sizeof(_titles)) {
         title = _titles[pos];
      }
   }
   if (member_array(title, _titles) == -1) {
      write("You did not specify a valid title.\n");
      for (i = 0; i < sizeof(_titles); i++) {
         write(sprintf("%c) %s\n", i + 'A', _titles[i]));
      }
      write("What title do you want to give " +
            query_multiple_short(the_case->people) + "? ");
      input_to("choose_title", 0, area, the_case, type, finish);
      return ;
   }
   write("How long do you wish " +
            query_multiple_short(the_case->people) + " to keep the title " +
         title +
         "(this is in hours and is online time, not real time)? ");
   input_to("choose_timeout", 0, area, the_case, type, finish, title);
}
void choose_timeout(string str, string area, class nomic_case the_case,
                 string type, function finish, string title) {
   int timeout;
   if (!strlen(str) || str[0] == 'q') {
      write("Aborting the title setting.\n");
      return ;
   }
   timeout = to_int(str);
   if (timeout <= 0) {
      write("The timeout must be greator than 0 hours.\n");
      write("How long do you wish " +
            query_multiple_short(the_case->people) + " to keep the title " +
            title + "?");
      input_to("choose_timeout", 0, area, the_case, type, finish, title);
      return ;
   }
   if (timeout > 30) {
      write("The timeout must be less than 30 hours.\n");
      write("How long do you wish " +
            query_multiple_short(the_case->people) + " to keep the title " +
            title + "?");
      input_to("choose_timeout", 0, area, the_case, type, finish, title);
      return ;
   }
   evaluate(finish, the_case, type, ({ title, timeout }));
}
void complete_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;
   foreach (person in the_case->people) {
      PLAYER_TITLE_HANDLER->set_forced_title_on_player(person, data[0], data[1] * (60 * 60));
   }
   return ;
}
void suspend_punishment(string area,
                      class nomic_case the_case,
                      string type,
                      mixed data) {
   string person;
   foreach (person in the_case->people) {
      PLAYER_TITLE_HANDLER->remove_forced_title(person, data[0]);
   }
   return ;
}

==================================================
FILE: room/furniture/bank_franchise.c
==================================================

inherit "/std/room/furniture/commercial";
inherit "/std/shops/inherit/bank_franchise";
#include <money.h>
#include <am_time.h>
#define SAVE_TIME 300
#define OBJECT_TAG "bank franchise"
#define MONTH_LENGTH (AM_SECONDS_PER_WEEK * 4)
private nosave int _maximum_total_difference;
private int _last_paid;
void create() {
   _maximum_total_difference = 4000;
   _last_paid = time();
   bank_franchise::create();
   set_shop_use_types(({ "use", "buy" }));
   commercial::create();
   set_commercial_name("bank");
   set_commercial_information("A franchise is connected up to a main "
          "bank.  You will pay a monthly fee to the main bank that is "
          "settable by the owner of the main bank.  The maximum balance "
          "of the bank counter is variable, but it is controlled at purchase "
          "time.  The bank balance and the float of the shop are tied "
          "together.");
   add_help_file("bank_franchise");
}
int query_player_bank() {
   return 1;
}
void set_maximum_total_difference(int max) {
   _maximum_total_difference = max;
}
int query_maximum_total_difference() {
   return _maximum_total_difference;
}
void set_last_paid(int paid) {
   _last_paid = paid;
}
int query_last_paid() {
   return _last_paid;
}
void adjust_account(string person, int amount) {
   adjust_float(amount);
}
object find_main_bank() {
   object office;
   object* obs;
   office = load_object(BANK_HANDLER->query_bank_master_office(query_bank_name()));
   if (!office) {
      return 0;
   }
   if (office->query_bank()) {
      return office;
   }
   obs = filter(office->find_commercial_items(query_commercial_name()),
                (: $1->query_bank_name() == query_bank_name() :));
   if (!sizeof(obs)) {
      return 0;
   }
   return obs[0];
}
int can_adjust_account(string person, int amount) {
   int amt;
   amt = query_total_difference() + amount;
   if (amt < -query_maximum_total_difference()  ||
       amt > query_maximum_total_difference()) {
      if (amt < 0) {
         add_failed_mess("This bank does not have the funds to handle "
                            "your request.\n");
      } else {
         add_failed_mess("This bank does not have the vault space to handle "
                            "your request.\n");
      }
      return 0;
   }
   return ::can_adjust_account(person, amount);
}
string query_commercial_information() {
   string* bits;
   string bank;
   string place;
   place = previous_object()->query_money_place();
   bits = ({ });
   foreach (bank in BANK_HANDLER->query_banks()) {
      bits += ({ bank + " costs " +
                 MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_default_cost_per_month(bank), place) +
                 " per month and " +
                 MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_default_cost_to_open(bank), place) +
                 " to open" });
   }
   return ::query_commercial_information() +
          "This counter has a fixed maximum bank balance of " +
          MONEY_HAND->money_value_string(query_maximum_total_difference(), place) +
          ".  The costs of the franchises are " + query_multiple_short(bits) +
          ".";
}
int do_set_cut(int percent) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (percent < 0) {
      add_failed_mess("You cannot set the cut less than 0.\n");
      return 0;
   }
   if (percent > 100) {
      add_failed_mess("You cannot set the cut to greator than 100%.\n");
      return 0;
   }
   set_percentage(percent);
   add_succeeded_mess("$N set$s the cut to " + percent + "% on $D.\n");
   return 1;
}
int do_set_open_cost(string str) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   set_account_cost(value);
   add_succeeded_mess("$N set$s the account open cost to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   return 1;
}
int is_allowed(string name) {
   return commercial::is_allowed(name);
}
void init() {
   bank_franchise::init();
   commercial::init();
   if (is_allowed(this_player()->query_name())) {
      add_command("set", "percentage <number> on <direct:object>",
                  (: do_set_cut($4[0]) :));
      add_command("set", "account cost <string'open cost'> on <direct:object>",
                  (: do_set_open_cost($4[0]) :));
   }
}
string query_franchise() {
   return file_name(environment());
}
void event_save(object ob) {
   environment()->event_save(ob);
}
mapping query_commercial_options() {
   string bank;
   mapping ret;
   ret = ([ ]);
   foreach (bank in BANK_HANDLER->query_banks()) {
      ret[bank] = BANK_HANDLER->query_bank_default_cost_to_open(bank);
   }
   return ([ "branch" : ret ]);
}
void set_commercial_option(string type, string name, object room) {
   switch (type) {
   case "branch" :
      set_bank_name(name);
      BANK_HANDLER->add_new_franchise(name,
                                      file_name(room->query_main_room()));
      break;
   }
}
int query_monthly_fee() {
   return BANK_HANDLER->query_bank_franchise_cost_per_month(
             query_bank_name(), query_franchise());
}
int is_open_for(string type, string name) {
   if (query_monthly_fee() == -1) {
      return 0;
   }
   return ::is_open_for(type, name);
}
void setup_call_out() {
   int tim;
   if (!_last_paid) {
      _last_paid = time();
   }
   tim = _last_paid + MONTH_LENGTH - time();
   call_out("make_payment", tim);
}
void make_payment() {
   _last_paid += MONTH_LENGTH;
   adjust_float(-query_monthly_fee());
   setup_call_out();
}
string query_main_status(int hints) {
   string ret;
   string place;
   add_help_file("bank_franchise");
   place = query_money_place();
   ret = "$I$0=" + the_short() + ":\n"
         "$I$6=   Bank Branch                  : " + query_bank_name() + "\n"
         "$I$6=   Revenue                      : " +
             MONEY_HAND->money_value_string(query_revenue(), place) + "\n"
           "$I$6=   Master Address               : " +
             BANK_HANDLER->query_bank_master_office(query_bank_name())->query_address() +
         "\n$I$6=   Maximum allowed bank balance : " +
             MONEY_HAND->money_value_string(query_maximum_total_difference(), place) +
         " (fixed)\n$I$6=   Bank Balance                 : " +
             MONEY_HAND->money_value_string(query_total_difference(), place) +
         "\n$I$6=   Credit Notes Outstanding     : " +
             MONEY_HAND->money_value_string(query_outstanding_credit_value(), place) + "\n";
   if (hints) {
      ret += "$I$6=     Hint: list credit notes\n";
      ret += "$I$6=     Hint: create credit note\n";
      ret += "$I$6=     Hint: recind credit note <id>\n";
   }
   ret += "$I$6=   Monthly Fee                  : " +
             MONEY_HAND->money_value_string(query_monthly_fee(), place) +
         " (set by bank owner)\n"
         "$I$6=   Next Pay Day                 : " +
             AM_TIME_HANDLER->query_am_time(_last_paid + MONTH_LENGTH) +
             " (" + ctime(_last_paid + MONTH_LENGTH) + ")\n"
         "$I$6=   Percentage                   : " +
             query_percentage() + "%"
         "\n$I$6=   Open account cost            : " +
             MONEY_HAND->money_value_string(query_account_cost(), place) +
       "\n";
   if (hints) {
      ret += "$I$6=     Hint: set open cost <amount> on <bank>\n";
   }
   return ret;
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, OBJECT_TAG, "bank", query_bank_name());
   add_auto_load_value(map, OBJECT_TAG, "open", query_account_cost());
   add_auto_load_value(map, OBJECT_TAG, "percentage", query_percentage());
   add_auto_load_value(map, OBJECT_TAG, "difference", query_total_difference());
   add_auto_load_value(map, OBJECT_TAG, "notes", query_credit_notes());
   add_auto_load_value(map, OBJECT_TAG, "credit num", query_credit_num());
   add_auto_load_value(map, OBJECT_TAG, "last paid", query_last_paid());
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   set_bank_name(query_auto_load_value(map, OBJECT_TAG, "bank"));
   set_account_cost(query_auto_load_value(map, OBJECT_TAG, "open"));
   set_percentage(query_auto_load_value(map, OBJECT_TAG, "percentage"));
   set_total_difference(query_auto_load_value(map, OBJECT_TAG, "difference"));
   set_credit_notes(query_auto_load_value(map, OBJECT_TAG, "notes"));
   set_credit_num(query_auto_load_value(map, OBJECT_TAG, "credit num"));
   set_last_paid(query_auto_load_value(map, OBJECT_TAG, "last paid"));
   setup_call_out();
}
mixed* stats() {
   return bank_franchise::stats() + commercial::stats() + ({
          ({ "last paid", ctime(_last_paid) }) });
}

==================================================
FILE: room/furniture/bank_master.c
==================================================

#include <money.h>
#include <move_failures.h>
nosave inherit "/std/room/furniture/commercial";
nosave inherit "/std/shops/inherit/bank_master";
#define OBJECT_TAG "bank master"
private nosave string _place;
void create() {
  add_help_file("bank_master");
  commercial::create();
  bank_master::create();
  set_commercial_name("bank");
}
void event_save(object ob) {
   environment()->event_save(ob);
}
mixed *stats() {
  return commercial::stats() +
         bank_master::stats();
}
object find_bank_object(string franchise) {
   object* obs;
   object room;
   room = load_object(franchise);
   if (room->query_bank()) {
      return room;
   }
   obs = filter(room->find_commercial_items(query_commercial_name()),
                (: $1->query_bank_name() == query_bank_name() :));
   if (sizeof(obs)) {
      return obs[0];
   }
   return 0;
}
int do_list_franchises() {
   string franchise;
   int pos;
   object bank_ob;
   string ret;
   string place;
   if (!sizeof(BANK_HANDLER->query_franchises(query_bank_name()))) {
      add_failed_mess("This bank has no franchises.\n");
      return 0;
   }
   place = query_money_place();
   ret = "Franchises:\n";
   foreach (franchise in BANK_HANDLER->query_franchises(query_bank_name())) {
      bank_ob = find_bank_object(franchise);
      ret += sprintf("$I$6=   %c %s Balance %s (cost per month %s)\n",
                      pos + 'A', franchise->the_short(),
                      MONEY_HAND->money_value_string(bank_ob->query_total_difference(), place),
                      MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_franchise_cost_per_month(query_bank_name(), franchise), place));
      pos++;
   }
   write("$P$Franchises$P$" + ret);
   return 1;
}
int do_set_franchise_cost(string cost) {
   int amount;
   string place;
   place = query_money_place();
   amount = MONEY_HAND->value_from_string(cost, place);
   if (amount <= 0) {
      add_failed_mess("Unknown amount " + cost + ".\n");
      return 0;
   }
   BANK_HANDLER->set_bank_default_cost_to_open(query_bank_name(), amount);
   add_succeeded_mess("$N set$s the cost to open a franchise to " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_default_cost_to_start(query_bank_name()), place) + "\n");
   return 1;
}
int do_set_default_monthly_cost(string cost) {
   int amount;
   string place;
   place = query_money_place();
   amount = MONEY_HAND->value_from_string(cost, place);
   if (amount <= 0) {
      add_failed_mess("Unknown amount " + cost + ".\n");
      return 0;
   }
   BANK_HANDLER->set_bank_default_cost_per_month(query_bank_name(), amount);
   add_succeeded_mess("$N set$s the cost to open a franchise to " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_default_cost_to_start(query_bank_name()), place) + "\n");
   return 1;
}
int do_set_main_bank_name(string new_name) {
   string* names;
   string name;
   if (query_bank_name()) {
      add_failed_mess("This bank already has a name.\n");
      return 0;
   }
   names = BANK_HANDLER->query_banks();
   foreach (name in names) {
      if (lower_case(name) == lower_case(new_name)) {
         add_failed_mess("There is already a bank called " +
                         name + ".\n");
         return 0;
      }
   }
   write("Do you really want to set the bank name to " + new_name +
         " (Make sure you have correct capitalisation)? ");
   input_to("check_bank_name", 0, new_name);
   add_succeeded_mess("");
   return 1;
}
void check_bank_name(string response, string new_name) {
   if (!strlen(response) || lower_case(response)[0] != 'y') {
      write("Ok, aborting.\n");
      return ;
   }
   write("You set the bank name to " + new_name + ".\n");
   BANK_HANDLER->create_new_bank(new_name, file_name(environment()));
   ::set_bank_name(new_name);
}
int do_set_cut(int percent) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (percent < 0) {
      add_failed_mess("You cannot set the cut less than 0.\n");
      return 0;
   }
   if (percent > 100) {
      add_failed_mess("You cannot set the cut to greator than 100%.\n");
      return 0;
   }
   set_percentage(percent);
   add_succeeded_mess("$N set$s the cut to " + percent + "% on $D.\n");
   return 1;
}
int do_set_open_cost(string str) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   set_account_cost(value);
   add_succeeded_mess("$N set$s the account open cost to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   return 1;
}
int do_set_franchise_cost_per_month(string id, string amount) {
   string *franchises;
   int id_num;
   int amt;
   id = lower_case(id);
   if (strlen(id) != 1) {
      add_failed_mess("Must be one letter.\n");
      return 0;
   }
   franchises = BANK_HANDLER->query_franchises(query_bank_name());
   id_num = id[0] - 'a';
   if (id_num < 0 || id_num >= sizeof(franchises)) {
      add_failed_mess("The id of the franchises must be between 'A' and '" +
                      sprintf("%c", 'A' + sizeof(franchises) - 1) + ".\n");
      return 0;
   }
   amt = MONEY_HAND->value_from_string(amount, query_money_place());
   if (amt <= 0) {
      add_failed_mess("The amount " + amount + " is invalid.\n");
      return 0;
   }
   BANK_HANDLER->set_bank_franchise_cost_per_month(query_bank_name(),
               franchises[id_num], amt);
   add_succeeded_mess(({ "You set the cost per month for the franchise " +
                         franchises[id_num]->query_address() + " to " +
                         MONEY_HAND->money_value_string(amt, query_money_place()) + ".\n",
                         "" }));
   return 1;
}
string query_main_status(int hints) {
   string ret;
   string place;
   place = query_money_place();
   ret = "$I$0=" + the_short() + ":\n";
   ret += "$I$6=   Bank Name             : " +
          query_bank_name() + "\n";
   ret += "$I$6=   Revenue               : " +
          MONEY_HAND->money_value_string(query_revenue(), place) + "\n";
   ret += "$I$6=   Cost to buy franchise : " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_default_cost_to_open(query_bank_name()), place) + "\n";
   if (hints) {
      ret += "$I$9=      Hint: set buy franchise cost <amount> on <object>\n";
   }
   ret += "$I$6=   Franchise cost per month : " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_default_cost_per_month(query_bank_name()), place) + "\n";
   if (hints) {
      ret += "$I$9=      Hint: set default franchise monthly cost <amount> on <object>\n";
   }
   ret += "$I$6=   Percentage            : " +
             query_percentage() + "%\n";
   if (hints) {
      ret += "$I$9=      Hint: set percentage <number> on <counter>\n";
   }
   ret += "$I$6=   Cost to open account  : " +
          MONEY_HAND->money_value_string(query_account_cost(), place) + "\n";
   if (hints) {
      ret += "$I$9=      Hint: set account cost <amount> on <object>\n";
   }
   ret += "$I$6=   Number of Franchises  : " +
          sizeof(BANK_HANDLER->query_franchises(query_bank_name())) + "\n";
   return ret;
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, OBJECT_TAG, "bank", query_bank_name());
   add_auto_load_value(map, OBJECT_TAG, "open", query_account_cost());
   add_auto_load_value(map, OBJECT_TAG, "percentage", query_percentage());
   add_auto_load_value(map, OBJECT_TAG, "difference", query_total_difference());
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   set_bank_name(query_auto_load_value(map, OBJECT_TAG, "bank"));
   set_account_cost(query_auto_load_value(map, OBJECT_TAG, "open"));
   set_percentage(query_auto_load_value(map, OBJECT_TAG, "percentage"));
   set_total_difference(query_auto_load_value(map, OBJECT_TAG, "difference"));
}
void init() {
   commercial::init();
   bank_master::init();
   if (is_allowed(this_player()->query_name())) {
      add_command("set", "bank name <string'name'> on <direct:object>",
                  (: do_set_main_bank_name($4[0]) :));
      add_command("set", "buy franchise cost <string'cost'> on <direct:object>",
                  (: do_set_franchise_cost($4[0]) :));
      add_command("set", "franchise monthly cost <string'cost'> on <direct:object>",
                  (: do_set_default_monthly_cost($4[0]) :));
      add_command("set", "percentage <number> on <direct:object>",
                  (: do_set_cut($4[0]) :));
      add_command("set", "account cost <string'open cost'> on <direct:object>",
                  (: do_set_open_cost($4[0]) :));
      add_command("set", "franchise monthly cost <string'cost'> for <string'franchise id'> on <direct:object>",
                  (: do_set_franchise_cost_per_month($4[1], $4[0]) :));
      add_command("list", "franchises on <direct:object>",
                  (: do_list_franchises :));
   }
}

==================================================
FILE: room/furniture/basic.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <room/placement.h>
inherit "/std/object";
inherit "/std/basic/item_chat";
inherit "/std/room/furniture/inherit/furniture_base";
void create() {
  do_setup++;
  object::create();
  furniture_base::create();
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
  }
  set_no_all(1);
}
varargs int move( mixed dest, string messin, string messout ) {
  int i, t, f;
  object from;
  if(stringp(dest)) {
    dest = find_object(dest);
  }
  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if(living(dest)) {
    t = (int)this_object()->query_complete_weight() * 2;
    if(!(dest->add_weight(t))) {
      return MOVE_TOO_HEAVY;
    }
  }
  i = ::move(dest, messin, messout);
  if(i != MOVE_OK) {
    dest->add_weight(-t);
    return i;
  }
  from = environment();
  if(from && living(from)) {
    f = (int)this_object()->query_complete_weight() * 2;
    from->add_weight(-f);
  }
  return i;
}
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}
mixed query_dynamic_auto_load() {
   mapping junk;
   junk = object::query_dynamic_auto_load();
   if (!junk) {
      junk = ([ ]);
   }
   junk["bonded"] = query_bonded();
   return junk;
}
void init_dynamic_arg(mapping map) {
   object::init_dynamic_arg(map);
   set_bonded(map["bonded"]);
}
string query_help_file_directory() {
   return "/doc/furniture/";
}
mixed *stats() {
   return ::stats() +
          ({ ({ "bonded", query_bonded() }) });
}

==================================================
FILE: room/furniture/bath.c
==================================================

#include <effect.h>
inherit "/std/room/furniture/surface";
#define WET_EFFECT "/std/effects/other/wetness"
#define SOAP_EFFECT "/std/effects/healing/antiseptic_soap"
int water = 0;
int dirt = 0;
string* dirt_messages = ({
    "clear",
    "almost clear",
    "soapy",
    "foamy",
    "slightly dirty",
    "fairly dirty",
    "dirty",
    "very dirty",
    "muddy"
});
void zap_bad_effects( object who );
int do_wash(object *indirect_obs );
void create(){
    ::create();
    add_property( "no recycling", 1 );
    this_object()->add_extra_look( this_object() );
    add_help_file("bath");
}
string extra_look() {
    object *stuff;
    string answer = "";
    stuff = all_inventory( this_object() );
    if (water) {
        if (dirt >= sizeof(dirt_messages)) {
            dirt = sizeof(dirt_messages) - 1;
        }
        answer = answer + "It's about three quarters full of " +
            dirt_messages[dirt] + " water.\n";
    }
    if( sizeof( stuff ) ) {
        answer = answer + "It has "+ query_multiple_short( stuff ) +" in it.\n";
    }
   return answer;
}
string long_status() {
    return "";
}
void init(){
    ::init();
    add_command( "lie", "in <direct:object>");
    add_command( "sit", "in <direct:object>");
    add_command( "kneel", "in <direct:object>");
    add_command( "stand", "in <direct:object>");
    add_command( "leave", "<direct:object>");
    add_command( "fill", "<direct:object>");
    add_command( "empty", "<direct:object>");
    add_command( "splash", "<indirect:living:here>");
    add_command( "wash", "<indirect:living:here>");
}
int can_player_get_in_it() {
    if (environment(this_object())!=environment(this_player())) {
      this_player()->add_failed_mess(this_object(), "The " + this_object()->short() + " needs to "
      "be on the floor for you to get in it.\n");
      return 0;
    }
    if( environment( this_object() ) == this_player() ){
        this_object()->move(environment(this_player() ));
        tell_object(this_player(), "You drop the "+
            this_object()->short()+".\n");
        tell_room(environment(this_player()), this_player()->short()+" drops "
        "a "+this_object()->short()+".\n", this_player() );
    }
    return 1;
}
void wet_everyone_in() {
    object *victims;
    if (!water) {
        return;
    }
    victims = filter(all_inventory(environment(this_object())),
        (: living($1) :) );
    foreach( object victim in victims ) {
        if (victim -> query_position_type() == "in" &&
            victim -> query_position_on() == "the "+this_object()->short()) {
            victim->add_effect( WET_EFFECT, 500 );
        }
    }
}
void reset() {
    wet_everyone_in();
}
int do_fill() {
    object player;
    player=this_player();
    if (water) {
        player->add_failed_mess(this_object(), "The " + this_object()->short() + " is "
            "already full of water.\n");
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    tell_object(player, "You fill the " + this_object()->short() + " with clean water.\n" );
    tell_room(environment(player), player->short()+" fills "
        "the " + this_object()->short() + " with clean water.\n", player );
    water=1;
    dirt=0;
    wet_everyone_in();
    return 1;
}
int do_empty() {
    object player;
    player=this_player();
    if (!water) {
        player->add_failed_mess(this_object(), "The " + this_object()->short() + " is "
            "already as empty as it gets.\n");
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    tell_object(player, "You reach into the " + this_object()->short() + " and "
                "pull the plug, allowing the water to drain away.\n" );
    tell_room(environment(player), player->short()+" reaches into "
        "the " + this_object()->short() + " and pulls the plug, allowing "
        "the water to flow away.\n", player );
    water=0;
    dirt=0;
    return 1;
}
int do_lie() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    player=this_player();
    add_succeeded_mess( "", ({ }) );
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "lying") {
            tell_object(player, "You are already lying in the pool.\n" );
            return 1;
        }
        tell_object(player, "You lie in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" lies "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + " and lie down.\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + " and lies down.\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "lying" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
int do_sit() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    player=this_player();
    add_succeeded_mess( "", ({ }) );
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "sitting") {
            tell_object(player, "You are already sitting in the " + this_object()->short() + ".\n" );
            return 1;
        }
        tell_object(player, "You sit in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" sits "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + " and sit down.\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + " and sits down.\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "sitting" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
int do_kneel() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    player=this_player();
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "kneeling") {
            tell_object(player, "You are already kneeling in the " + this_object()->short() + ".\n" );
            return 1;
        }
        tell_object(player, "You kneel in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" kneels "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + " and kneel down.\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + " and kneel down.\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "kneeling" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
int do_stand() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    player = this_player();
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "standing") {
            tell_object(player, "You are already standing in the " + this_object()->short() + ".\n" );
            return 1;
        }
        tell_object(player, "You stand in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" stands "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + ".\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "lying" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
void event_exit(object ob, string message, object to) {
  if (ob==this_player() && this_player()->query_position_on() == this_object()) {
    this_player()->return_to_default_position(1);
  }
}
int do_leave(){
    if (this_player()->query_position_on() == "the "+this_object()->short()) {
        this_player()->return_to_default_position(1);
        tell_object(this_player(), "You clamber out of the " + this_object()->short() + ".\n" );
        tell_room(environment(this_object()), this_player()->short()+" clambers "
            "out of the " + this_object()->short() + ".\n", this_player() );
    }
    else {
        tell_object(this_player(), "Umm... You're not in the " + this_object()->short() + " in the "
            "first place.\n" );
    }
    add_succeeded_mess( "", ({ }) );
    return 1;
}
int do_splash( object *indirect_obs ) {
    if (environment(this_object())!=environment(this_player())) {
      this_player()->add_failed_mess(this_object(), "The " + this_object()->short() + " needs to "
      "be on the floor for you to splash with it.\n");
      return 0;
    }
    if (!water) {
        this_player()->add_failed_mess(this_object(), "It's not a bad idea,  "
            " but maybe you'd need some water in the " + this_object()->short() +
            " before you can splash.\n");
        return 0;
    }
    if ( sizeof( indirect_obs ) ) {
        add_succeeded_mess( "$N splash$es $I.\n", indirect_obs );
        return 1;
    }
    this_player()->add_succeeded_mess( this_object(),
        "$N splash$es $oself.\n", ({ }) );
    return 1;
}
int do_wash( object *indirect_obs ) {
    if (!can_player_get_in_it()) {
        return 0;
    }
    if (this_player() -> query_position_type() != "in" &&
        this_player()->query_position_on() != "the "+this_object()->short()) {
      this_player()->add_failed_mess(this_object(), "You need to get "
                                     "into the " + this_object()->short() +
                                     " first.\n");
      return 0;
    }
    if (!water) {
        this_player()->add_failed_mess(this_object(), "It's not a bad idea,  "
            " but maybe you'd need some water in the " + this_object()->short() +
            " before you can wash.\n");
        return 0;
    }
    if (dirt >= sizeof(dirt_messages) - 1) {
        this_player()->add_failed_mess(this_object(), "The water in the " +
            this_object()->short() +
            " looks so muddy, it probably would just soil anyone.  Maybe " +
            " it would be a better idea to empty it and fill it again " +
            " with fresh water.\n");
        return 0;
    }
    if ( sizeof( indirect_obs ) ) {
        foreach( object victim in indirect_obs ) {
            call_out( (: zap_bad_effects( $1 ) :), 0, victim );
        }
        add_succeeded_mess( "$N wash$es $I using a bar of pleasant smelling soap.\n", indirect_obs );
        return 1;
    }
    call_out( (: zap_bad_effects( $1 ) :), 0, this_player() );
    this_player()->add_succeeded_mess( this_object(),
        "$N wash$es $oself using a bar of pleasant smelling soap.\n", ({ }) );
    return 1;
}
int query_baths() {
    return 1;
}
void zap_bad_effects( object who ) {
    int i, flag, *enums;
    class effect *effs;
    dirt++;
    effs = (class effect *)who->query_effs();
    enums = (int *)who->effects_matching( "body.smell" );
    i = sizeof( enums );
    if ( !random(dirt) && i ) {
        i = random( i );
        flag = 1;
        write( "The antiseptic power of the soap defeats "+
          (string)effs[ enums[ i ] ]->ob_name->smell_string( who,
            effs[ enums[ i ] ]->arg ) +".\n" );
        who->delete_effect( enums[ i ] );
        dirt ++;
    }
    enums = who->effects_matching("pie.cream");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The cream washes right off your body.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = (int *)who->effects_matching( "misc.ketchup" );
    i = sizeof( enums );
    if ( !random(dirt) && i ) {
        i = random( i );
        flag = 1;
        write( "The soap rinses the ketchup off your face.\n" );
        who->delete_effect( enums[ i ] );
        dirt ++;
    }
    enums = who->effects_matching("exploded.apples");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The apples wash right off your body.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = (int *)who->effects_matching("object.label");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The labels stuck on you peel off in "
          "the water.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = who->effects_matching("body.frog-adhesive");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The frog adhesive washes off in the water.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = who->effects_matching("body.writing.soap");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The rest of the words wash off without a single "
            "bubble in sight.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    if (!random(dirt)) {
        who->add_effect( SOAP_EFFECT, 10000 );
    }
    who->add_effect( WET_EFFECT, 250 );
}

==================================================
FILE: room/furniture/chime_inherit.c
==================================================

inherit "/std/object";
inherit "/std/room/furniture/inherit/furniture_base";
#include <weather.h>
#define TIME 120
string chimes_short();
string chimes_long();
void set_chime_type( string type );
string chime_type();
void jingle();
string chime_verb();
void add_chime_verb( string verb );
void remove_chime_verb( string verb );
string *query_chime_verbs();
void set_hung_up( int up );
int hung_up();
void set_hook( object hook );
object hook();
int do_hang( object hook );
int do_unhang();
private string _chime_type = "metal";
private string *_chime_verbs = ({ "jingles", "tinkles" });
private int _hung_up = 0;
private object _hook;
void create() {
   furniture_base::create();
   object::create();
}
void setup() {
  set_name( "chime" );
  set_short( (: chimes_short() :) );
  set_long( (: chimes_long() :) );
  add_adjective( ({ "wind", chime_type() }) );
  set_value( 420 );
}
void init() {
  add_command( "hang", "<direct:object'chime'> {on|from} "
      "<indirect:object'hook'>", (: do_hang( $1[0] ) :) );
  add_command( "unhang", "<direct:object'chime'>" );
}
string chimes_short() {
  return chime_type() + " wind chime";
}
string chimes_long() {
  return "This little wind chime is nothing more than bits of "
             + chime_type() + " dangling from strings tied to a "
             "ring.\n";
}
void set_chime_type( string type ) {
  remove_adjective( _chime_type );
  add_adjective( type );
  _chime_type = type;
}
string chime_type() { return _chime_type; }
void jingle() {
  object env = environment();
  int wind;
  if( !env )
    return;
  if( !hung_up() )
    return;
  if( !inherits( "/std/room", env ) )
    return;
  wind = env->query_wind_speed();
  if( undefinedp( wind ) ) {
    if( env->query_property( "location" ) == "outside" ||
        env->query_property( "windy" ) )
      wind = WEATHER->query_windsp( this_object() );
    else
      return;
  }
  if( random( wind ) )
    tell_room( env, the_short() + chime_verb() + " in the "
        "wind.\n" );
  call_out( "jingle", TIME );
}
string chime_verb() {
  return " " + _chime_verbs[ random( sizeof( _chime_verbs ) ) ];
}
void add_chime_verb( string verb ) {
  _chime_verbs += ({ verb });
}
void remove_chime_verb( string verb ) {
  _chime_verbs -= ({ verb });
}
void set_chime_verbs( string *verbs ) { _chime_verbs = verbs; }
string *query_chime_verbs() { return _chime_verbs; }
void set_hung_up( int up ) {
  remove_call_out( "jingle" );
  if( up )
    call_out( "jingle", 30 );
  _hung_up = up;
}
int hung_up() { return _hung_up; }
void set_hook( object hook ) { _hook = hook; }
object hook() { return _hook; }
int jingling() { return find_call_out( "jingle" ); }
void init_dynamic_arg( mapping arg ) {
  set_chime_type( arg[ "type" ] );
  set_chime_verbs( arg[ "chime verbs" ] );
  set_hook( arg[ "hook" ] );
  set_hung_up( arg[ "hung up" ] );
  if( undefinedp( hook() ) || !hung_up() ||
      !sizeof( match_objects_for_existence( hook(), ({ environment() }) ) ) ) {
    remove_property( "there" );
    set_hung_up( 0 );
  }
}
mixed query_dynamic_auto_load() {
  return ([ "::" : ::query_dynamic_auto_load(),
            "type" : chime_type(),
            "chime verbs" : query_chime_verbs(),
            "hung up" : hung_up(),
            "hook" : hook() ]);
}
int do_hang( object hook ) {
  string where = hook->a_short();
  if( hung_up() ) {
    add_failed_mess( "The chime is already hanging up.\n" );
    return 0;
  }
  if( !hook->query_hook() && !hook->query_property( "hook" ) )
    return 0;
  if( move( environment( this_player() ) ) )
    return 0;
  if( where )
    where = "on " + where;
  else
    where = "up";
  add_property( "there", "hanging "+ where );
  reset_get();
  set_hung_up( 1 );
  set_hook( hook );
  this_player()->add_succeeded_mess( this_object(), "$N $V $D on "
      "$I.\n", ({ hook }) );
  return 1;
}
int do_unhang() {
  if( !hung_up() ) {
    add_failed_mess( "The chime isn't hanging from anything.\n" );
    return 0;
  }
  remove_property( "there" );
  set_get();
  set_hung_up( 0 );
  move( this_player() );
  return 1;
}

==================================================
FILE: room/furniture/clock.c
==================================================

#include <move_failures.h>
#include <position.h>
inherit "/obj/clock";
inherit "/std/room/furniture/inherit/furniture_base";
void chime(string mess) {
  int *co_ords;
  if(environment(this_object())) {
    co_ords = (int *)environment(this_object())->query_co_ord();
    "/obj/handlers/broadcaster"->broadcast_event(users(), co_ords,
                                                 mess, 20, 1, 0 );
    tell_room(environment(this_object()), mess);
  }
}
void create() {
   do_setup++;
   clock::create();
   add_alias( "furniture" );
   add_plural( "furniture" );
   set_opaque();
   furniture_base::create();
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
   }
}
private int do_real_move(mixed dest, string messin, string messout) {
   return clock::move(dest, messin, messout);
}
varargs int move( mixed dest, string messin, string messout ) {
  int i, t, f;
  object from;
  if(stringp(dest)) {
    dest = find_object(dest);
  }
  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if(living(dest)) {
    t = (int)this_object()->query_complete_weight() * 2;
    if(!(dest->add_weight(t))) {
      return MOVE_TOO_HEAVY;
    }
    debug_printf("Added %d", t);
  }
  i = ::move(dest, messin, messout);
  if(i != MOVE_OK) {
    dest->add_weight(-t);
    return i;
  }
  from = environment();
  if(from && living(from)) {
    f = (int)this_object()->query_complete_weight() * 2;
    from->add_weight(-f);
  }
  return i;
}
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}

==================================================
FILE: room/furniture/commercial.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <money.h>
inherit "/std/object";
inherit "/std/basic/item_chat";
inherit "/std/room/furniture/inherit/furniture_base";
string query_main_status(int hints);
private nosave int _commercial_size;
private nosave string _commercial_type;
private nosave string _commercial_name;
private nosave string* _use_types;
private nosave string _info;
private int _revenue;
private int _weekly_revenue;
private int _commercial_id;
private int _weekly_upkeep_cost;
#define OBJECT_TAG "commercial inh"
void create() {
   _commercial_size = 100;
   if (!_use_types) {
      _use_types = ({ });
   }
   do_setup++;
   object::create();
   furniture_base::create();
   add_alias( "furniture" );
   add_plural( "furniture" );
   add_property("talisman", "no one");
   set_opaque();
   if ( !query_property( "shop type" ) ) {
      add_property( "shop type", "furniture" );
   }
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
   }
   set_no_all(1);
   reset_get();
}
void set_weekly_upkeep_cost(int cost) {
   _weekly_upkeep_cost = cost;
}
int query_weekly_upkeep_cost() {
   return _weekly_upkeep_cost;
}
int query_revenue() {
   return _revenue;
}
void set_revenue(int revenue) {
   _revenue = revenue;
}
string query_save_dir() {
   return environment()->query_save_dir();
}
string query_owner() {
  return environment()->query_owner();
}
string query_language() {
  return environment()->query_language();
}
string query_money_place() {
   if (!environment()) {
      return "default";
   }
   return environment()->query_property("place");
}
int is_allowed(string person) {
   return environment()->is_allowed(person);
}
string query_allowed() {
   return environment()->query_allowed();
}
int query_float() {
   return environment()->query_royalty(query_owner());
}
int query_royalty(string person) {
   return environment()->query_royalty(person);
}
int adjust_royalty(string person, int amount) {
   if (person == query_owner()) {
      _revenue += amount;
      _weekly_revenue += amount;
   }
   environment()->adjust_royalty(person, amount);
}
int adjust_float(int amt) {
   adjust_royalty(query_owner(), amt);
}
int is_open_for(string type, string person) {
   if (!environment()->query_commercial_property()) {
      return 0;
   }
   return environment()->is_open_for(type, person);
}
void set_commercial_size(int size) {
   _commercial_size = size;
}
string query_commercial_type() {
   return _commercial_type;
}
void set_commercial_type(string type) {
   _commercial_type = type;
}
void set_commercial_information(string info) {
   _info = info;
}
string query_commercial_information() {
   return _info;
}
void set_commercial_name(string name) {
   _commercial_name = name;
}
string query_commercial_name() {
   return _commercial_name;
}
int query_commercial_size() {
   return _commercial_size;
}
int query_commercial_id() {
   return _commercial_id;
}
void setup_new_commercial_id() {
   _commercial_id = environment()->find_next_commercial_id();
}
void set_commercial_id(int id) {
   _commercial_id = id;
}
string query_parcel_post() {
   return environment()->query_parcel_post();
}
void set_shop_use_types(string* types) {
   _use_types = types;
}
string* query_shop_use_types() {
   return _use_types;
}
void reset_weekly_status() {
   _weekly_revenue = 0;
}
string query_weekly_status_string() {
   string ret;
   string place;
   place = query_money_place();
   if (query_weekly_upkeep_cost()) {
      ret = "Weekly Upkeep : " +
            MONEY_HAND->money_value_string(_weekly_upkeep_cost, place) + "\n" +
            "Weekly Revenue: " +
            MONEY_HAND->money_value_string(_weekly_revenue, place) + "\n" +
            "Profit        : " +
            MONEY_HAND->money_value_string(_weekly_revenue - _weekly_upkeep_cost, place) + "\n";
   } else {
      ret = "Weekly Revenue: " +
            MONEY_HAND->money_value_string(_weekly_revenue, place) + "\n";
   }
   return ret;
}
int can_trash_furniture() {
   return 1;
}
int query_commercial_furniture() {
   return 1;
}
varargs int move( mixed dest, string messin, string messout ) {
   int i;
   int t;
   int f;
   object from;
   if(stringp(dest)) {
      dest = find_object(dest);
   }
   if (!move_check(dest)) {
      write(the_short() + " resists being picked up and shocks you slightly.\n");
      return MOVE_INVALID_DEST;
   }
   if(!dest) {
      return MOVE_INVALID_DEST;
   }
   if(living(dest)) {
      t = (int)this_object()->query_complete_weight() * 5;
      if(!(dest->add_weight(t))) {
         return MOVE_TOO_HEAVY;
      }
      debug_printf("Added %d", t);
   }
   from = environment();
   i = ::move(dest, messin, messout);
   if(i != MOVE_OK) {
      dest->add_weight(-t);
      return i;
   }
   if(from && living(from)) {
      f = (int)this_object()->query_complete_weight() * 5;
      from->add_weight(-f);
   }
   if (from) {
      from->remove_commercial_thing(this_object());
   }
   dest->add_commercial_thing(this_object());
   dest->register_use_types(_use_types);
   return i;
}
int get(mixed dest) {
   if(!move_check(dest)) {
      write("You feel it would be wrong to take " + the_short() + ".\n");
      return 2;
   }
   return ::get(dest);
}
int do_status(int hint) {
   string ret;
   ret = query_main_status(hint);
   write("$P$Status$P$" + ret);
   add_succeeded_mess("$N get$s the status of $D.\n");
   return 1;
}
int do_reset() {
   string place;
   int old_revenue;
   place = query_money_place();
   old_revenue = _revenue;
   _revenue = 0;
   add_succeeded_mess("$N clear$s the revenue of " +
                      MONEY_HAND->money_value_string(old_revenue, place) +
                      " on $D.\n");
   return 1;
}
void init() {
   ::init();
   if (is_allowed(this_player()->query_name())) {
      add_command("status", "<direct:object>", (: do_status, 0 :));
      add_command("status", "hints <direct:object>", (: do_status, 1 :));
      add_command("status", "hint <direct:object>", (: do_status, 1 :));
      add_command("reset", "revenue on <direct:object>", (: do_reset :));
   }
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}
mixed query_dynamic_auto_load() {
   mapping junk;
   junk = object::query_dynamic_auto_load();
   if (!junk) {
      junk = ([ ]);
   }
   junk["bonded"] = query_bonded();
   add_auto_load_value(junk, OBJECT_TAG, "revenue", query_revenue());
   add_auto_load_value(junk, OBJECT_TAG, "commercial id", query_commercial_id());
   return junk;
}
void init_dynamic_arg(mapping map) {
   object::init_dynamic_arg(map);
   if (map) {
      set_bonded(map["bonded"]);
      set_revenue(query_auto_load_value(map, OBJECT_TAG, "revenue"));
      if (query_auto_load_value(map, OBJECT_TAG, "commercial id")) {
         set_commercial_id(query_auto_load_value(map, OBJECT_TAG, "commercial id"));
      }
   }
}
string query_help_file_directory() {
   return "/doc/furniture/";
}
mixed *stats() {
   return ::stats() +
          ({ ({ "revenue", query_revenue() }),
             ({ "bonded", query_bonded() }),
             ({ "commercial id", query_commercial_id() }) });
}

==================================================
FILE: room/furniture/curtains.c
==================================================

#include <move_failures.h>
#include <position.h>
inherit "/std/room/furniture/basic";
private nosave object _window;
private string _window_id;
private string _window_old_long;
void create() {
  do_setup++;
  ::create();
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  if ( !query_property( "shop type" ) ) {
    add_property( "shop type", "furniture" );
  }
  set_allowed_room_verbs((["hanging" : "hangs" ]));
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
  }
}
void init() {
  if(!_window_id) {
    this_player()->add_command("hang", this_object(),
        "<direct:object> [on|at] <indirect:object:here>");
  }
  this_player()->add_command("open", this_object(), "<direct:object>");
  this_player()->add_command("close", this_object(), "<direct:object>");
}
int do_open() {
  if(!_window)
    _window = environment(this_object())->query_door_control(_window_id);
  if(!_window_id || !_window) {
    this_player()->add_failed_mess(this_object(),
        "$D aren't hanging at a window.\n");
    return 0;
  }
  if(_window->query_transparent()) {
    this_player()->add_failed_mess(this_object(),
        "$D are already open.\n");
    return 0;
  }
  _window->set_transparent();
  this_player()->add_succeeded_mess(this_object(), "$N $V $D.\n", ({}));
  return 1;
}
int do_close() {
  if(!_window)
    _window = environment(this_object())->query_door_control(_window_id);
  if(!_window_id || !_window) {
    this_player()->add_failed_mess(this_object(),
        "$D aren't hanging at a window.\n");
    return 0;
  }
  if(!_window->query_transparent()) {
    this_player()->add_failed_mess(this_object(),
        "$D are already closed.\n");
    return 0;
  }
  _window->reset_transparent();
  this_player()->add_succeeded_mess(this_object(), "$N $V $D.\n", ({}));
  return 1;
}
int do_hang(mixed *in_dir, string direct, string indirect, mixed *args) {
  if(member_array("window", in_dir[0]->parse_command_id_list()) == -1) {
    this_player()->add_failed_mess(this_object(),
        "You can only $V $D at windows.\n",
        ({ }));
    return 0;
  }
  if(this_object()->move(environment(this_player())) != MOVE_OK) {
    this_player()->add_failed_mess(this_object(),
        "You seem to be unable to $V $D "
        "at $I.\n", ({ in_dir[0] }));
    return 0;
  }
  this_object()->add_property("current room hidden", 1);
  _window_id = in_dir[0]->query_my_id();
  _window_old_long = in_dir[0]->query_long();
  in_dir[0]->set_long(in_dir[0]->query_long()+"It has " +
                      this_object()->query_short() +
                      " hanging round it.\n");
  event(environment(), "save", this_object());
  this_player()->add_succeeded_mess(this_object(),
                                   "$N $V $D at $I.\n", ({ in_dir[0] }));
  return 1;
}
void removed() {
  this_object()->remove_property("current room hidden");
  if(!_window)
    _window = environment(this_object())->query_door_control(_window_id);
  _window->set_long(_window_old_long);
  _window->set_transparent();
  _window_id = 0;
}
int query_furniture() { return 1; }
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load() +
      ([ "window" : _window_id,
       "window_old_long" : _window_old_long ]);
  return ([ "window" : _window_id,
          "window_old_long" : _window_old_long ]);
}
void init_static_arg( mapping map ) {
  if ( !mapp( map ) ) {
    return;
  }
  ::init_static_arg(map);
  if ( !undefinedp( map[ "window" ] ) )
    _window_id = map["window"];
  if(!undefinedp(map["window_old_long"]))
    _window_old_long = map["window_old_long"];
}

==================================================
FILE: room/furniture/dividor.c
==================================================

inherit "/std/room/furniture/commercial";
#include <room.h>
#define SIZE_OF_FURNITURE 5
#define TAG "dividor"
#define TEMPLATE_DIVIDOR_ROOM "/mudlib/data/dividor_template.c"
private int _size;
private string _exit_direction;
private string _our_room;
int query_furniture_size() {
   return _size + SIZE_OF_FURNITURE;
}
int query_commercial_id() {
   if (!::query_commercial_id()) {
      setup_new_commercial_id();
   }
   return ::query_commercial_id();
}
string query_exit_direction() {
   return _exit_direction;
}
string query_exit_destination() {
   return _our_room;
}
int create_room() {
   string path;
   string *bits;
   string room_path;
   string stuff;
   path = environment()->query_save_dir();
   path += "/division" + query_commercial_id();
   if (file_size(path) == -2) {
      mkdir(path);
   }
   bits = explode(base_name(environment()), "/");
   room_path = implode(bits[0..<2], "/");
   room_path += "/" + bits[<1] + "_dividor";
   if (file_size(room_path) == -2) {
      mkdir(room_path);
   }
   room_path += "/" + query_commercial_id();
   if (file_size(room_path + ".c") > 0) {
      return 0;
   }
   _our_room = room_path;
   stuff = "inherit \"/std/room/furniture/dividor_room\";\n\n"
           "void setup() {\n"
           "   set_base_desc(\"" + environment()->query_base_desc() + "\");\n"
           "   set_main_room(\"" + base_name(environment()) + "\");\n"
           "   set_save_dir(\"" + path + "\");\n"
           "   set_theft_handler(\"" + environment()->query_theft_handler() + "\");\n"
           "   add_exit(\"" + ROOM_HANDLER->query_opposite_direction(query_exit_direction()) + "\", \"" + base_name(environment() + "\", \"door\");\n"
           "   set_property_size(" + _size + ");\n"
           "   add_property(\"place\", \"" + environment()->query_property("place") + "\");\n"
           "}";
   write_file(room_path + ".c", stuff, 1);
   return 1;
}
void add_exit_to_room() {
   environment()->add_exit(query_exit_direction(), query_exit_destination(), "door");
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, TAG, "exit", _exit_direction);
   add_auto_load_value(map, TAG, "room", _our_room);
   add_auto_load_value(map, TAG, "size", _size);
   return map;
}
void init_dynamic_arg(mapping map) {
   _exit_direction = query_auto_load_value(map, TAG, "exit");
   _our_room = query_auto_load_value(map, TAG, "room");
   _size = query_auto_load_value(map, TAG, "size");
   ::init_dynamic_arg(map);
}

==================================================
FILE: room/furniture/dividor_room.c
==================================================

inherit "/std/shops/commercial";
private string _main_room;
void set_main_room(string room) {
   _main_room = room;
}
string query_main_room() {
   return _main_room;
}
string query_parcel_post() {
   return _main_room->query_parcel_post();
}

==================================================
FILE: room/furniture/document_handler.c
==================================================

inherit "/std/room/furniture/commercial";
inherit "/std/room/furniture/inherit/document_handler";
#include <room/document_handler.h>
void create() {
   document_handler::create();
   commercial::create();
   add_help_file("document_handler");
   set_shop_use_types( ({ "document_view",
                          "document_add",
                          "document_delete" }) );
}
string query_save_dir() {
   return commercial::query_save_dir() + "/" + query_commercial_id();
}
void load_me() {
   if (!query_commercial_id()) {
      setup_new_commercial_id();
   }
   if (unguarded( (: file_size(query_save_dir()) :) ) != -2) {
      unguarded( (: mkdir(query_save_dir()) :));
   }
}
void save_me() {
   environment()->event_save(this_object());
}
void init() {
   add_command("list", "documents [from] <direct:object>", (: do_list() :));
   add_command("view", "document <string'id'> [from] <direct:object>",
                (: do_display($4[0]) :));
   add_command("add", "documents {html|plain} called <string:quoted'title'> to <direct:object>",
               (: do_add_document($4[1], ($4[0] == "html"?DOCUMENT_HTML:DOCUMENT_PLAIN)) :));
   add_command("delete", "document <string'id'> [from] <direct:object>",
                (: do_delete_document($4[0]) :));
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   document_handler::query_dynamic_auto_load(map);
   return map;
}
void init_dynamic_arg(mapping map) {
   document_handler::init_dynamic_arg(map);
   commercial::init_dynamic_arg(map);
}

==================================================
FILE: room/furniture/fireplace.c
==================================================

#include <fuel_handler.h>
#include <move_failures.h>
#define WIZARD "/std/guilds/wizard"
#define CMD "/cmds/"
#define BURN_PER_TICK   1
#define BRIGHT 30
#define K      1
inherit "/std/room/furniture/surface";
private nosave int _light_produced;
private nosave int _is_lit;
private nosave int _frequency;
private nosave string _lit_mess;
private nosave string _unlit_mess;
private nosave string *_lit_chats;
private nosave string *_dying_chats;
private nosave string _turn_on_mess;
private nosave string _turn_off_mess;
private nosave string _out_of_fuel_mess;
void set_light_produced(int b);
void set_lit_mess(string str);
void set_unlit_mess(string str);
void set_frequency(int i);
void set_lit_chats(string *str);
void add_lit_chat(string str);
string request_lit_chat();
void set_dying_chats(string *str);
void add_dying_chat(string str);
string request_dying_chat();
void set_turn_on_mess(string mess);
void set_turn_off_mess(string mess);
void set_out_of_fuel_mess(string mess);
int do_light(object *obs);
int do_zap();
int turn_on();
int do_dowse(object *obs);
int turn_off();
int calc_fuel();
void create() {
  do_setup++;
  surface::create();
  do_setup--;
  set_name("fireplace");
  add_alias( ({ "fireplace", "furniture", "hearth", "fire" }) );
  add_plural( "fireplaces" );
  add_property( "shop type", "furniture" );
  add_property( "degrees", 0 );
  set_light_produced( BRIGHT );
  set_lit_mess("A fire blazes happily in the hearth, providing "
      "a soft red glow and pleasant warmth. It crackles and spits "
      "occasionally, giving the room that homely feel.\n");
  set_unlit_mess("The hearth is blackened with ashes and old embers.\n");
  set_frequency(5);
  set_lit_chats( ({
      "The fire crackles and spits cheerfully.",
      "The warm fire soothes your weariness.",
      "An enchanting orange glow radiates from the hearth.",
      "Small glowing embers dance over the fire.",
      "The fire blazes in the grate." }) );
  set_dying_chats( ({
      "The fire splutters.",
      "The warm red glow flickers.",
      "A whisp of smoke from the fire trails around the room." }) );
  set_turn_on_mess("Soon a roaring fire is blazing in the grate.\n");
  set_turn_off_mess("The embers smoke slightly and their glow dims.\n");
  set_out_of_fuel_mess("The fire flickers and dies away.\n");
  if ( !do_setup ) {
      this_object()->setup();
  }
  this_object()->add_extra_look( this_object() );
  add_help_file("fireplace");
}
void init() {
  this_player()->add_command("light", this_object(), "<direct:object> with <indirect:object>");
  this_player()->add_command("extinguish", this_object(), "<direct:object>", (: do_dowse :) );
  this_player()->add_command("dowse", this_object(), "<direct:object>");
  if( this_player()->query_guild_ob() == WIZARD ){
    this_player()->add_command("zap", this_object(), "<direct:object>");
    this_player()->add_command("point", this_object(), "[finger] at <direct:object>", (: do_zap :) );
  }
}
int query_fuel_left(){  return calc_fuel();  }
void set_light_produced(int b){  _light_produced = b;  }
int query_light_produced(){  return _light_produced;  }
void set_frequency(int i){  _frequency = i + 1;  }
int query_frequency(){  return _frequency;  }
int do_light(object *obs){
  string q_n;
  q_n = obs[0]->query_name();
  if( _is_lit ){
    this_player()->add_failed_mess( this_object(),
         "$D is already ablaze.\n", ({ }) );
    return 0;
  }
  if( q_n != "flint" && q_n != "match" && q_n != "lighter" ){
    this_player()->add_failed_mess(this_object(),
         "You can't light $D with $I.\n", ({ obs[0] }) );
    return 0;
  }
  if( this_player()->query_dex() < random(18) ){
    this_player()->add_failed_mess(this_object(),
      "You strike $I, but can't quite get the spark to catch.\n", ({ obs[0] }) );
    return 0;
  }
  if ( calc_fuel() <= 0 ) {
    this_player()->add_failed_mess( this_object(),
        "There is nothing in the fireplace to burn.\n", ({ }) );
    return 0;
  }
  this_player()->add_succeeded_mess(this_object(),
    "$N $V $D with $I.\n", ({ obs[0] }) );
  return turn_on();
}
int do_zap(){
  object tp;
  tp = this_player();
  if(tp->query_gp() < 10){
    tell_object(tp, "You don't even have the energy for such a small task!\n");
    return 1;
  }
  if(_is_lit){
    tell_object(tp, "There is already a merry fire burning in the fireplace.\n");
    return 1;
  } else {
    tp->add_succeeded_mess(this_object(),
      "$N extend$s an arm towards $D.\nA small fireball leaps from $p "
      "index finger and throws itself onto the hearth.\n", ({ }) );
    tp->adjust_gp( -10 );
    return turn_on();
  }
}
void set_turn_on_mess(string mess){  _turn_on_mess = mess;  }
string query_turn_on_mess(){  return _turn_on_mess;  }
void set_turn_off_mess(string mess){  _turn_off_mess = mess;  }
string query_turn_off_mess(){  return _turn_off_mess;  }
void msg_on(){
  if(_is_lit){
    tell_room(environment( this_object() ), query_turn_on_mess() );
  }
}
int turn_on(){
  int x;
  FUEL_HANDLER->add_burner( this_object() );
  _is_lit = 1;
  adjust_light( query_light_produced() );
    x = query_light_produced() / 4;
    add_property("degrees", query_light_produced() * 4);
    environment( this_object() )->add_property("warmth", x );
  call_out( "msg_on", 7 );
  return 1;
}
int do_dowse(object *obs){
  if( !_is_lit ){
    this_player()->add_failed_mess( this_object(),
         "There is no fire to put out.\n", ({ }) );
    return 0;
  } else {
    this_player()->add_succeeded_mess(this_object(),
      "$N $V $D and the room loses its warm glow.\n", ({ }) );
    return turn_off();
  }
}
void msg_off() {
  if(!_is_lit){
    tell_room(environment( this_object() ), query_turn_off_mess() );
  }
}
int turn_off(){
  FUEL_HANDLER->remove_burner( this_object() );
  _is_lit = 0;
  adjust_light( -query_light_produced() );
  add_property( "degrees", 0 );
  environment( this_object() )->remove_property("warmth");
  call_out( "msg_off", 10 );
  return 1;
}
void set_out_of_fuel_mess(string mess){  _out_of_fuel_mess = mess;  }
string query_out_of_fuel_mess(){  return _out_of_fuel_mess;  }
void out_of_fuel() {
  turn_off();
  tell_room(environment( this_object() ), query_out_of_fuel_mess() );
}
void set_lit_chats(string *str){  _lit_chats = str;  }
void add_lit_chat(string str){
  if( !_lit_chats ){
    _lit_chats = ({ });
  }
  _lit_chats += ({ str });
}
string request_lit_chat(){
  return _lit_chats[random( sizeof(_lit_chats) - 1 )];
}
void set_dying_chats(string *str){  _dying_chats = str;  }
void add_dying_chat(string str){
  if( !_dying_chats ){
    _dying_chats = ({ });
  }
  _dying_chats += ({ str });
}
string request_dying_chat(){
  return _dying_chats[random( sizeof(_dying_chats) - 1 )];
}
void set_lit_mess(string str){  _lit_mess = str;  }
string query_lit_mess(){  return _lit_mess;  }
void set_unlit_mess(string str){  _unlit_mess = str;  }
string query_unlit_mess(){  return _unlit_mess;  }
void consume_fuel() {
  int x;
  int q;
  int z;
  int w;
  int amount;
  string r;
  object *inv;
  object ashes;
  object thing;
  object env;
  inv = filter(all_inventory( this_object() ),
              (:$1->query_property("fuel") :));
  if( !inv || inv == ({ }) || calc_fuel() < 1){
    out_of_fuel();
    return;
  }
  x = sizeof(inv);
  foreach(thing in inv){
      q = thing->query_amount_left();
      w = thing->query_weight();
      z = q - ( ( BURN_PER_TICK * 100 / x ) / w );
      if ( z < 1 ){
          thing->move("/room/rubbish");
          amount = roll_MdN(4, 20);
          ashes = clone_object("/obj/cont_medium");
          ashes->set_name("ash");
          ashes->set_short("fine grey ash");
          ashes->add_property("determinate", "some ");
          ashes->add_adjective(({"some", "fine", "grey", "pinch", "pinches",
           "handful", "handfuls", "bucketful", "bucketfuls", "of"}));
          ashes->add_plural("ash");
          ashes->set_long("This is $pile_size$ of fine grey ash, "
            "$amount_size$. It looks like it was the leftovers "
            "from someone's camp fire.\n");
          ashes->set_weight_unit(({ 1, 50 }));
          ashes->set_medium_alias("FiNeGrEyAsH");
          ashes->set_amount_types((["pinch" : ({1, "pinches"}),
           "handful" : ({50, "handfuls"}),
           "bucketful" : ({1000, "bucketfuls"})]));
          ashes->set_pile_types(({50, "small", 100, "medium",
            200, "large", "huge"}));
          ashes->set_continuous();
          ashes->set_amount(amount);
          ashes->move(this_object());
      } else {
        thing->set_amount_left( z );
      }
  }
  calc_fuel();
  env = environment( this_object() );
  if( random( query_frequency() ) == 1 ){
    if( calc_fuel() > 10 ){
      r = request_lit_chat();
      tell_room( env, r + "\n");
    } else {
      r = request_dying_chat();
      tell_room( env, r + "\n");
    }
  }
}
int calc_fuel(){
  object *inv;
  object thing;
  int tot_fuel = 0;
  int w;
  int amt;
  inv = all_inventory( this_object() );
  if( !inv || inv == ({ }) ) { return 0; }
  foreach(thing in inv){
    if( thing->query_property("fuel") ){
      w =  thing->query_weight();
      amt = thing->query_amount_left();
      tot_fuel += w * amt * K / 100 ;
    }
  }
  return tot_fuel;
}
int test_remove( object thing, int flat, mixed dest){
  object tp;
  object *prev;
  tp = this_player();
  prev = previous_object(-1);
  if(_is_lit && tp && strsrch( file_name(prev[1]), CMD ) != -1 ){
    tell_object(tp, "You reach out towards the fire but "
       "you can't brave the flames and quickly pull away.\n");
    tell_room( environment(tp), tp->query_short() + " tries to take something "
      "from the fire but pulls back sucking " + tp->query_possessive() +
      " fingers.\n", tp);
    tp->adjust_hp( -random(120) );
    return 0;
  }
  return ::test_remove(thing, flat, dest);
}
int test_add( object thing, int flag ) {
  if( !thing->query_property("fuel") && environment(thing) ){
    tell_object(this_player(), "You don't think " + thing->the_short() +
      " would be a suitable fuel.\n");
    return 0;
  }
  if( _is_lit ){
    tell_room(environment( this_object() ),
      ({ "The fire crackles.\n",
         "A shower of glowing embers tumble around the hearth.\n" })[random(2)] );
  }
  call_out("calc_fuel",1);
  return 1;
}
string extra_look( object ob ){
  if( _is_lit ) {
      return query_lit_mess();
  }
  else {
      return query_unlit_mess();
  }
}
void pre_dest_me() {
  int tmp;
  if(_is_lit && environment()) {
    FUEL_HANDLER->remove_burner( this_object() );
    _is_lit = 0;
    adjust_light( -query_light_produced() );
    tmp = environment()->query_property("warmth");
    if(tmp > query_light_produced() / 4)
      environment()->add_property("warmth", tmp -
                            (query_light_produced() / 4));
    else
      environment()->remove_property("warmth");
  }
  return;
}
void dest_me() {
  FUEL_HANDLER->remove_burner( this_object() );
  _is_lit = 0;
   ::dest_me();
}

==================================================
FILE: room/furniture/fireplace_inherit.c
==================================================

inherit "/std/room/furniture/fireplace";

==================================================
FILE: room/furniture/fuel_inherit.c
==================================================

inherit "/std/object";
private nosave int _amount;
private nosave string *_shorts;
private nosave string *_longs;
string fuel_short();
string fuel_long();
void create(){
   ::create();
   if(!_amount){
     _amount = 100;
   }
   set_short( (: fuel_short :) );
   set_long( (: fuel_long :) );
   add_property("no recycling", 1);
   add_property("fuel", 1);
}
void set_amount_left(int i){  _amount = i;  }
void adjust_amount_left(int i){  _amount += i;  }
int query_amount_left(){  return _amount;  }
void set_shorts(string *desc){  _shorts = desc;  }
void set_longs(string *desc){  _longs = desc;  }
string fuel_short(){
   int i;
   int x;
   x = sizeof(_shorts);
   for(i = 1; i <= x; i++){
      if( (_amount + 1) > 100 - ( i * 100 / x ) ){
         return _shorts[(i-1)];
      }
   }
   return "fuel";
}
string fuel_long(){
   int i;
   int x;
   x = sizeof(_longs);
   for(i = 1; i <= x; i++){
      if( ( _amount + 1 ) > ( 100 - ( i * 100 / x )) ){
         return _longs[(i-1)];
      }
   }
   return "fuel";
}
mixed query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "amount" : _amount
          ]);
}
void init_dynamic_arg(mapping arg) {
   _amount = arg[ "amount" ];
   ::init_dynamic_arg(arg["::"]);
}

==================================================
FILE: room/furniture/furniture.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <tasks.h>
inherit "/obj/cont_save";
inherit "/std/basic/trap";
inherit "/std/room/furniture/inherit/furniture_base";
private nosave string _drawer_mess;
private nosave mixed *_drawers;
private nosave int _biggest;
private nosave int _drawers_inside;
private nosave object *_on_top;
private nosave int _has_surface;
#define DEBUG
void create() {
  do_setup++;
  ::create();
  _drawer_mess = "a drawer in $ob_short$";
  _drawers = ({ });
  _on_top = ({ });
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  if (!query_property("shop type"))
    add_property( "shop type", "furniture" );
   do_setup--;
   if(!do_setup)
     this_object()->setup();
}
string query_drawer_mess() { return _drawer_mess; }
void set_drawer_mess( string words ) { _drawer_mess = words; }
mixed *query_drawers() { return _drawers; }
void add_drawer( string type, int amount ) {
   if ( !type || ( type == "" ) || ( amount < 1 ) ) {
      return;
   }
   _drawers += ({ type, amount });
   set_max_weight(query_max_weight() + amount);
   if ( amount > _biggest ) {
      _biggest = amount;
   }
}
int query_has_surface() { return _has_surface; }
void set_has_surface(int i) { _has_surface = i; }
void set_drawers_inside(int i) { _drawers_inside = i; }
int query_drawers_inside() { return _drawers_inside; }
varargs int move( mixed dest, string messin, string messout ) {
  int i, w;
  object from;
  w = (int)this_object()->query_complete_weight() * 5;
  if ( from = environment() ) {
    from->add_weight( -w );
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if (!( dest->add_weight( w ) ) ) {
    if ( from ) {
      from->add_weight( w );
    }
    return MOVE_TOO_HEAVY;
  }
  if ( stringp( dest ) ) {
    dest = find_object( dest );
  }
  i = ::move( dest, messin, messout );
  if ( i != MOVE_OK ) {
    if ( from ) {
      from->add_weight( w );
    }
    dest->add_weight( -w );
  } else if (query_light_needs_inform()) {
    if ( from ) {
      inform_of_light_level_change(from);
    }
    inform_of_light_level_change(dest);
  }
  return i;
}
string long( string word, int dark ) {
   int i;
   string ret, *sizes;
   mapping types;
  ret = ::long( word, dark );
   if ( sizeof( _drawers ) && !dark &&
        (!query_closed() || !_drawers_inside)) {
     types = ([ ]);
     for ( i = 0; i < sizeof( _drawers ); i += 2 ) {
       types[ _drawers[ i ] ]++;
     }
     sizes = m_indices( types );
     for ( i = 0; i < sizeof( sizes ); i++ ) {
       sizes[ i ] = query_num( types[ sizes[ i ] ] ) +" "+ sizes[ i ] +
         " drawer"+ ( types[ sizes[ i ] ] > 1 ? "s" : "" );
     }
     ret += "It has "+ query_multiple_short( sizes ) +".\n";
   }
   if(sizeof(_on_top))
     ret += query_contents( "On " + the_short() + " " +
                            (sizeof(_on_top) == 1 ? "is " : "are " ), _on_top);
   return ret;
}
varargs string query_contents( string start, object *things,
  int ignore_living) {
  if(!arrayp(things)) {
    things = this_object()->find_inv_match( "", this_player() );
    things -= ({ this_player() });
    things = filter_array( things, (: environment( $1 ) == this_object() :) );
    things -= _on_top;
  }
  return ::query_contents(start, things, ignore_living);
}
int test_remove(object thing, int flag, mixed dest) {
  int result;
  mixed *stuff;
  result = ::test_remove(thing, flag, dest);
  if(result) {
    stuff = thing->query_property("dropped");
    if(environment() &&
       dest == this_player() &&
       function_exists("test_occupier", environment()) &&
       !environment()->test_occupier(this_player()->query_name()) &&
       (!sizeof(stuff) || stuff[0] != this_player()->query_name())) {
      event(environment(this_player()), "theft", this_player(), this_object(),
            ({ thing }));
    }
    if(dest) {
      _on_top -= ({ thing });
      thing->remove_property("_on_top");
    }
    event(environment(), "save");
  }
  return result;
}
int test_add( object thing, int flag ) {
  int i;
  int result;
  if ( flag )
    return 0;
  if(!environment(thing))
    return 1;
  result = ::test_add(thing, flag);
  if(!result)
    return 0;
  if("/cmds/living/put"->query_con() == "on" && _has_surface) {
    _on_top += ({ thing });
    thing->add_property("_on_top", 1);
  } else if(sizeof(_drawers)) {
    if ( !_biggest )
      for ( i = 0; i < sizeof( _drawers ); i+= 2 )
        if ( _drawers[ i + 1 ] > _biggest )
          _biggest = _drawers[ i + 1 ];
    if ( (int)thing->query_complete_weight() > _biggest )
      return write( (string)thing->the_short() +" is too big "+
                    "to fit in any of "+ the_short() +"'s drawers.\n" );
  }
  event(environment(), "save", this_object());
  return result;
}
int pick_unlock(object player) {
  mixed owner;
  if(!environment())
    return ::pick_unlock(player);
  if(!environment() || !function_exists("query_owner", environment()))
    return ::pick_unlock(player);
  owner = environment()->query_owner();
  if(stringp(owner) && pk_check(player, owner, 1)) {
    write("You feel it would be wrong to try to break into "+
          this_object()->query_short() + ".\n");
    return 0;
  }
  return ::pick_unlock(player);
}
mapping int_query_static_auto_load() {
  return ([
           "::" : ::int_query_static_auto_load(),
           "drawer mess" : _drawer_mess,
           "drawers" : _drawers,
           "allowed_positions" : query_allowed_positions(),
           "trap" : query_trap_data(),
           "trap armed": query_trap_armed(),
           ]);
}
mapping query_static_auto_load() {
  return int_query_static_auto_load();
}
void init_static_arg( mapping map ) {
  if ( !mapp( map ) )
    return;
  if ( map[ "::" ] )
    ::init_static_arg( map[ "::" ] );
  if ( !undefinedp( map[ "drawer mess" ] ) )
    _drawer_mess = map[ "drawer mess" ];
  if ( !undefinedp( map[ "drawers" ] ) )
    _drawers = map[ "drawers" ];
  if(!undefinedp(map["allowed_positions"]))
    set_allowed_positions( map["allowed_positions"]);
  if(!undefinedp(map["trap"]))
    setup_trap(map["trap"][0],
                   map["trap"][1],
                   map["trap"][2],
                   map["trap"][3],
                   map["trap"][4]);
  if(!undefinedp(map["trap armed"]))
    set_trap_armed(map["trap armed"]);
}
void init_dynamic_arg(mapping bing) {
  object item;
  ::init_dynamic_arg(bing);
  foreach(item in all_inventory(this_object())) {
    if(item->query_property("_on_top"))
      _on_top += ({ item });
  }
}
string query_help_file_directory() {
  return "/doc/furniture/";
}
mixed *stats() {
  int i;
  mixed *ret;
  ret = ::stats();
  ret += ({ ({ "surface", _has_surface }) });
  for ( i = 0; i < sizeof( _drawers ); i += 2 )
    ret += ({ ({ _drawers[ i ] +" drawer", _drawers[ i + 1 ] }) });
  return ret;
}

==================================================
FILE: room/furniture/mirror.c
==================================================

#include <effect.h>
inherit "/std/room/furniture/basic";
int _in_extra;
void create(){
	::create();
	add_extra_look(this_object());
}
string extra_look(object ob) {
	int dark;
	object env;
	env = environment(ob);
	if(living(env))
		return "You can see yourself in the mirror.";
	dark = (int) this_player()->check_dark((int)env->query_light());
	if(dark)
		return "It is too dark to see much in the room.";
	return "Reflected in the mirror is " +
		query_multiple_short(all_inventory(env) - ({ ob }), "a", 0, 1, dark) +
		".";
}

==================================================
FILE: room/furniture/poker.c
==================================================

inherit "/std/room/furniture/games/card_base";
inherit "/std/room/furniture/games/multiplayer_base";
inherit "/std/room/furniture/commercial";
#include <money.h>
#include <room/card_base.h>
#define HAND_TYPE_HIGH_CARD  1
#define HAND_TYPE_PAIR       2
#define HAND_TYPE_TWO_PAIR   3
#define HAND_TYPE_THREE      4
#define HAND_TYPE_STRAIGHT   5
#define HAND_TYPE_FLUSH      6
#define HAND_TYPE_FULL_HOUSE 7
#define HAND_TYPE_FOUR       8
#define HAND_TYPE_STRAIGHT_FLUSH 9
#define POKER_STATE_ANTE      0
#define POKER_STATE_PAID_ANTE 1
#define POKER_STATE_DEALT     2
#define POKER_STATE_BET       3
#define POKER_STATE_DISCARD   4
#define POKER_STATE_AFTER_DISCARD   5
#define POKER_STATE_FINAL_BET 6
#define POKER_STATE_FOLDED    7
#define POKER_STATE_END       8
#define TIE -1
class hand_type {
   int hand_type;
   class playing_card* kickers;
   class playing_card duplicate_1;
   class playing_card duplicate_2;
   class playing_card high_card;
}
class player_data {
   class playing_card* hand;
   class hand_type hand_type;
   int bet;
   int state;
}
#define BOARD_TAG "poker"
private int _return;
private int _ante_amount;
private int _ante_house;
private int _house_cut;
private int _min_bet;
private int _max_bet;
private int _current_bet;
private int _pot;
private int _finished;
private int _poker_phase;
private int _turn_timeout;
private int _draw_round;
private int _max_draw_rounds;
private class playing_card* _deck;
private class playing_card* _discard;
private mapping _player_stats;
int query_hand_value(class playing_card* cards);
class hand_type query_hand_type(class playing_card* hand);
void create() {
   multiplayer_base::create();
   set_minimum_needed(2);
   add_help_file("poker");
   _ante_house = 400;
   _ante_amount = 400;
   _min_bet = 400;
   _max_bet = 1200;
   _max_draw_rounds = 1;
   _player_stats = ([ ]);
   set_shop_use_types(({ "poker" }));
   commercial::create();
   set_commercial_type("gambling");
   set_commercial_name("poker");
}
string query_hand_type_string(class hand_type bing) {
   string ret;
   switch (bing->hand_type) {
   case HAND_TYPE_FULL_HOUSE :
      ret = "Full house";
      break;
   case HAND_TYPE_THREE :
      ret = "Three of a kind";
      break;
   case HAND_TYPE_FLUSH :
      ret = "Flush";
      break;
   case HAND_TYPE_STRAIGHT :
      ret = "Straight";
      break;
   case HAND_TYPE_STRAIGHT_FLUSH :
      ret = "Straight flush";
      break;
   case HAND_TYPE_PAIR :
      ret = "Pair";
      break;
   case HAND_TYPE_FOUR :
      ret = "Four of a kind";
      break;
   case HAND_TYPE_TWO_PAIR :
      ret = "Two pairs";
      break;
   case HAND_TYPE_HIGH_CARD :
      ret = "High card " + query_card_string(bing->high_card);
      break;
   default :
      ret = "Nothing";
      break;
   }
   return ret;
}
string query_card_status(string id) {
   string id_bing;
   string ret;
   string* not_playing;
   class player_data data;
   string* womble;
   string place;
   int left;
   ret = "";
   not_playing = ({ });
   womble = query_player_ids();
   place = query_money_place();
   foreach (id_bing in womble) {
      if (is_person_playing(id_bing)) {
         ret += capitalize(id_bing) + " (" +
                query_player_cap_name(id_bing) + ")";
         data = query_player_data(id_bing);
         if (data) {
            if (data->state == POKER_STATE_FOLDED) {
               ret += " Folded!\n";
            } else {
               if (data->state == POKER_STATE_PAID_ANTE) {
                  ret += " (paid ante) ";
               }
               if (data->state == POKER_STATE_AFTER_DISCARD) {
                  ret += " (discarded) ";
               }
               if (data->state == POKER_STATE_BET ||
                   data->state == POKER_STATE_FINAL_BET) {
                  if (id_bing == query_current_player()) {
                     ret += " <-- Their bet ";
                  }
               }
               if (data->bet) {
                  ret += "  Current bet " +
                         MONEY_HAND->money_value_string(data->bet, place);
                  ret += "\n";
               } else {
                  ret += "  No bet yet.\n";
               }
            }
         } else {
            ret += "\n";
         }
      } else {
         not_playing += ({ id_bing });
      }
   }
   if (sizeof(not_playing) > 1) {
      ret += query_multiple_short(map(not_playing, (: capitalize($1) :))) +
                                  " are not playing.\n";
   } else if (sizeof(not_playing) == 1) {
      ret += query_multiple_short(map(not_playing, (: capitalize($1) :))) +
                                  " is not playing.\n";
   }
   ret += "The pot is " +
          MONEY_HAND->money_value_string(_pot, place) + ".\n";
   if (is_game_started()) {
      if (_draw_round < _max_draw_rounds) {
         left = _max_draw_rounds - _draw_round;
         ret += left + " draw round" + (left>1?"s":"") + " left.\n";
      }
   }
   ret += "\n";
   if (id) {
      if (!_finished) {
         data = query_player_data(id);
         if (data && sizeof(data->hand)) {
            ret += "Your hand (" +
                   query_hand_type_string(data->hand_type) +
                   (data->state == POKER_STATE_FOLDED?" -- Folded":"") +
                   "):\n";
            if (data->state != POKER_STATE_FOLDED) {
               ret += query_hand_string(data->hand,
                                     CARD_HAND_THREE|CARD_HAND_LETTERS,
                                     this_player()->query_cols());
            }
         }
         if (_finished) {
            tell_all_players(query_player_cap_name(id) + " peeks at their hand on " +
                         the_short() + ".\n", ({ id }));
         }
      } else {
         foreach (id in query_started_player_ids()) {
            data = query_player_data(id);
            if (data && sizeof(data->hand)) {
               ret += query_player_cap_name(id);
               if (data->state == POKER_STATE_FOLDED) {
                  ret += " folded, so the cards are hidden.\n";
               } else {
                  ret += " hand (" +
                         query_hand_type_string(data->hand_type) + ":\n";
                  ret += query_hand_string(data->hand, CARD_HAND_SINGLE,
                                        this_player()->query_cols());
               }
            }
         }
      }
   }
   return ret;
}
string long(string str, int dark) {
   if (dark) {
      return ::long() +
             "It is too dark to make out the pieces on the board.\n";
   }
   return ::long() + query_card_status(find_player_id_of_person(this_player()));
}
int check_end_round() {
   int bet;
   string id;
   class player_data data;
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state != POKER_STATE_FOLDED) {
         if (!data->bet) {
            return 0;
         } else if (!bet && data->bet) {
            bet = data->bet;
         } else if (bet != data->bet) {
            return 0;
         }
      }
   }
   if (bet) {
      call_out("complete_round", 2);
      _poker_phase = POKER_STATE_END;
      return 1;
   }
}
void next_person_turn() {
   class player_data data;
   string start_id;
   start_id = query_current_player();
   do {
      increment_current_player();
      data = query_player_data(query_current_player());
   } while (data->state == POKER_STATE_FOLDED &&
            query_current_player() != start_id);
   if (query_current_player() == start_id) {
      printf("Force end of game.\n");
      call_out("complete_round", 2, 1);
      _poker_phase = POKER_STATE_END;
   } else {
      call_out("tell_current_player", 0, "%^BOLD%^Your turn!%^RESET%^\n");
   }
}
void deal_cards() {
   string id;
   class player_data data;
   _deck = make_deck(1, 0);
   _deck = shuffle_deck(_deck);
   foreach (id in query_currently_playing_ids()) {
      data = query_player_data(id);
      data->hand = sort_cards(_deck[0..4], 3);
      data->bet = 0;
      if (data->state != POKER_STATE_FOLDED) {
         if (!_max_draw_rounds) {
            data->state = POKER_STATE_FINAL_BET;
         } else {
            data->state = POKER_STATE_BET;
         }
      }
      data->hand_type = query_hand_type(data->hand);
      _deck = _deck[5..];
      if (query_player_object(id)) {
         tell_player(id, "Your hand:\n" +
                query_hand_string(data->hand, CARD_HAND_THREE|CARD_HAND_LETTERS,
                                  query_player_object(id)->query_cols()) +
            query_hand_type_string(data->hand_type) + ".\n");
      }
   }
   if (!_max_draw_rounds) {
      _poker_phase = POKER_STATE_FINAL_BET;
   } else {
      _poker_phase = POKER_STATE_BET;
   }
   next_person_turn();
   tell_all_players(query_player_cap_name(query_current_player()) +
                    " goes first.\n");
   _current_bet = 0;
}
int start_game() {
   class player_data data;
   string id;
   randomise_player_numbers();
   if (!::start_game()) {
      return 0;
   }
   foreach (id in query_player_ids()) {
      data = new(class player_data);
      data->bet = 0;
      data->hand = ({ });
      data->state = POKER_STATE_ANTE;
      set_player_data(id, data);
   }
   _poker_phase = POKER_STATE_ANTE;
   _pot = 0;
   _finished = 0;
   _draw_round = 0;
   _discard = ({ });
   tell_all_players("%^BOLD%^Place your ante to start playing.%^RESET%^\n");
   return 1;
}
void check_for_finish_ante() {
   string id;
   class player_data data;
   object ob;
   foreach (id in query_currently_playing_ids()) {
      data = query_player_data(id);
      ob = query_player_object(id);
      if (ob && !interactive(ob)) {
         data->state = POKER_STATE_FOLDED;
      }
      if (ob && interactive(ob) && data->state == POKER_STATE_ANTE) {
         return ;
      }
   }
   _poker_phase = POKER_STATE_BET;
   call_out("deal_cards", 2);
}
int is_card_higher(class playing_card card_new, class playing_card card_old) {
   if (card_new->number == card_old->number) {
      return 0;
   }
   if (card_new->number == CARD_NUMBER_ACE) {
      return 1;
   }
   if (card_old->number == CARD_NUMBER_ACE) {
      return 0;
   }
   if (card_new->number > card_old->number) {
      return 1;
   }
   return 0;
}
class hand_type query_hand_type(class playing_card* hand) {
   int high_num;
   int num;
   int id;
   int i;
   int j;
   class playing_card* tmp_hand;
   class hand_type ret_type;
   class playing_card tmp_card;
   ret_type = new(class hand_type);
   high_num = 0;
   for (i = 1; i < sizeof(hand); i++) {
      if (is_card_higher(hand[i], hand[high_num])) {
         high_num = i;
      }
   }
   ret_type->hand_type = HAND_TYPE_HIGH_CARD;
   ret_type->high_card = hand[high_num];
   high_num = 1;
   for (i = 0; i < sizeof(hand) - 1; i++) {
      num = 1;
      for (j = 0; j < sizeof(hand) - i - 1; j++) {
         if (hand[i]->number == hand[i + j + 1]->number) {
            num++;
         }
      }
      if (num > high_num) {
         high_num = num;
         id = hand[i]->number;
      }
   }
   tmp_hand = hand;
   if (high_num > 1) {
      for (i = 0; i < sizeof(tmp_hand); i++) {
         if (tmp_hand[i]->number == id) {
            ret_type->duplicate_1 = tmp_hand[i];
            tmp_hand = tmp_hand[0..i-1] + tmp_hand[i+1..];
            i--;
         }
      }
   }
   if (high_num == 2) {
      high_num = 1;
      for (i = 0; i < sizeof(tmp_hand) - 1; i++) {
         num = 1;
         for (j = 0; j < sizeof(tmp_hand) - i - 1; j++) {
            if (tmp_hand[i]->number == tmp_hand[i + j + 1]->number) {
               num++;
            }
         }
         if (num > high_num) {
            high_num = num;
            id = tmp_hand[i]->number;
         }
      }
      if (high_num == 2) {
         ret_type->hand_type = HAND_TYPE_TWO_PAIR;
         for (i = 0; i < sizeof(tmp_hand); i++) {
            if (tmp_hand[i]->number == id) {
               ret_type->duplicate_2 = tmp_hand[i];
               tmp_hand = tmp_hand[0..i-1] + tmp_hand[i+1..];
            }
         }
         if (is_card_higher(ret_type->duplicate_2, ret_type->duplicate_1)) {
            tmp_card = ret_type->duplicate_1;
            ret_type->duplicate_1 = ret_type->duplicate_2;
            ret_type->duplicate_2 = tmp_card;
         }
         ret_type->kickers = sort_cards(tmp_hand, 3);
      } else {
         ret_type->hand_type = HAND_TYPE_PAIR;
         high_num = 0;
         for (i = 1; i < sizeof(tmp_hand); i++) {
            if (is_card_higher(tmp_hand[i], tmp_hand[high_num])) {
               high_num = i;
            }
         }
         ret_type->kickers = sort_cards(tmp_hand, 3);
      }
      return ret_type;
   } else if (high_num == 3) {
      if (tmp_hand[0]->number == tmp_hand[1]->number) {
         ret_type->hand_type = HAND_TYPE_FULL_HOUSE;
         ret_type->duplicate_2 = tmp_hand[0];
         ret_type->kickers = ({ });
      } else {
         ret_type->hand_type = HAND_TYPE_THREE;
         ret_type->kickers = sort_cards(tmp_hand, 3);
      }
      return ret_type;
   } else if (high_num == 4) {
      ret_type->hand_type = HAND_TYPE_FOUR;
      ret_type->high_card = tmp_hand[0];
      return ret_type;
   }
   for (i = 0; i < sizeof(hand) - 1; i++) {
      if (hand[i + 1]->suit != hand[0]->suit) {
         break;
      }
   }
   if (i == sizeof(hand) - 1) {
      ret_type->hand_type = HAND_TYPE_FLUSH;
      ret_type->kickers = sort_cards(hand, 3);
      high_num = 0;
      for (i = 1; i < sizeof(hand); i++) {
         if (is_card_higher(hand[i], hand[high_num])) {
            high_num = i;
         }
      }
      ret_type->high_card = hand[high_num];
   }
   tmp_hand = sort_array(hand, (: ((class playing_card)$1)->number -
                                  ((class playing_card)$2)->number :));
   if (tmp_hand[0]->number == CARD_NUMBER_ACE) {
      if (tmp_hand[1]->number == 2) {
         j = 1;
      } else {
         j = 0;
         tmp_hand = tmp_hand[1..] + ({ tmp_hand[0] });
      }
   } else {
      j = 0;
   }
   for (i = j; i < sizeof(tmp_hand) - 1; i++) {
      if (tmp_hand[i]->number + 1 != tmp_hand[i + 1]->number) {
         if (tmp_hand[i + 1]->number != CARD_NUMBER_ACE ||
             tmp_hand[i]->number != CARD_NUMBER_KING) {
            break;
         }
      }
   }
   if (i == sizeof(tmp_hand) - 1) {
      if (ret_type->hand_type == HAND_TYPE_FLUSH) {
         ret_type->hand_type = HAND_TYPE_STRAIGHT_FLUSH;
         ret_type->high_card = tmp_hand[<1];
      } else {
         ret_type->hand_type = HAND_TYPE_STRAIGHT;
         ret_type->high_card = tmp_hand[<1];
      }
   }
   if (ret_type->hand_type == HAND_TYPE_HIGH_CARD) {
      ret_type->kickers = sort_cards(hand, 3);
   }
   return ret_type;
}
int is_greator_hand(class hand_type new_hand,
                    class hand_type old_hand) {
   int i;
   if (new_hand->hand_type > old_hand->hand_type) {
      return 1;
   }
   if (new_hand->hand_type < old_hand->hand_type) {
      return 0;
   }
   if (new_hand->hand_type == old_hand->hand_type) {
      switch (new_hand->hand_type) {
      case HAND_TYPE_HIGH_CARD :
         if (is_card_higher(new_hand->high_card,
                            old_hand->high_card)) {
            return 1;
         }
         if (is_card_higher(old_hand->high_card,
                            new_hand->high_card)) {
            return 0;
         }
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_FLUSH :
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_PAIR :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_TWO_PAIR :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         if (is_card_higher(new_hand->duplicate_2,
                            old_hand->duplicate_2)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_2,
                            new_hand->duplicate_2)) {
            return 0;
         }
         if (is_card_higher(new_hand->kickers[0],
                            old_hand->kickers[0])) {
            return 1;
         }
         if (is_card_higher(old_hand->kickers[0],
                            new_hand->kickers[0])) {
            return 0;
         }
         break;
      case HAND_TYPE_THREE :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         for (i = 1; i <= sizeof(new_hand->kickers); i++) {
            if (is_card_higher(new_hand->kickers[<i],
                               old_hand->kickers[<i])) {
               return 1;
            } else if (is_card_higher(old_hand->kickers[<i],
                                      new_hand->kickers[<i])) {
               return 0;
            }
         }
         break;
      case HAND_TYPE_FOUR :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         if (is_card_higher(new_hand->kickers[0],
                            old_hand->kickers[0])) {
            return 1;
         }
         if (is_card_higher(old_hand->kickers[0],
                            new_hand->kickers[0])) {
            return 0;
         }
         break;
      case HAND_TYPE_FULL_HOUSE :
         if (is_card_higher(new_hand->duplicate_1,
                            old_hand->duplicate_1)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_1,
                            new_hand->duplicate_1)) {
            return 0;
         }
         if (is_card_higher(new_hand->duplicate_2,
                            old_hand->duplicate_2)) {
            return 1;
         }
         if (is_card_higher(old_hand->duplicate_2,
                            new_hand->duplicate_2)) {
            return 0;
         }
         break;
      case HAND_TYPE_STRAIGHT :
      case HAND_TYPE_STRAIGHT_FLUSH :
         if (is_card_higher(new_hand->high_card,
                            old_hand->high_card)) {
            return 1;
         }
         if (is_card_higher(new_hand->high_card,
                            old_hand->high_card)) {
            return 0;
         }
         break;
      }
   }
   return TIE;
}
void test_hand_type() {
   class playing_card* other_tmp_hand;
   class playing_card* tmp_hand;
   other_tmp_hand = ({ new(class playing_card, suit: CARD_SUIT_HEARTS, number : 11),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 11),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 12),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 13),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 13) });
   tmp_hand = ({ new(class playing_card, suit: CARD_SUIT_HEARTS, number : 2),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 3),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 4),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 1),
                 new(class playing_card, suit: CARD_SUIT_HEARTS, number : 5) });
write(query_hand_type_string(query_hand_type(tmp_hand)) + " --\n" +
      query_hand_type_string(query_hand_type(other_tmp_hand)));
printf("%O\n", sizeof(query_hand_type(tmp_hand)->kickers));
printf("%O\n", sizeof(query_hand_type(other_tmp_hand)->kickers));
write("Result: " + is_greator_hand(query_hand_type(tmp_hand),
      query_hand_type(other_tmp_hand)) + "\n");
}
void complete_round(int force_end) {
   string stuff;
   object ob;
   class player_data data;
   string id;
   string place;
   string* winner;
   class hand_type winning_hand_type;
   class playing_card* winning_hand;
   int paid;
   int discard;
   int result;
   int num;
   if (_finished) {
      return 0;
   }
   place = query_money_place();
   stuff = "";
   winner = ({ });
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if ((data->state == POKER_STATE_BET || discard) && !force_end) {
         if (data->state != POKER_STATE_FOLDED) {
            data->state = POKER_STATE_DISCARD;
            data->bet = 0;
         }
         discard = 1;
      } else if (data->state != POKER_STATE_FOLDED) {
         num++;
         if (!winning_hand) {
            winning_hand = data->hand;
            winning_hand_type = data->hand_type;
            winner = ({ id });
         } else {
            data->hand_type = query_hand_type(data->hand);
            result = is_greator_hand(data->hand_type, winning_hand_type);
            if (result == TIE) {
               winner += ({ id });
            } else if (result) {
               winning_hand = data->hand;
               winning_hand_type = data->hand_type;
               winner = ({ id });
            }
         }
         stuff += query_player_cap_name(id) + "'s hand (" +
                  query_hand_type_string(data->hand_type) + "):\n" +
                  query_hand_string(data->hand, CARD_HAND_SINGLE,
                                     this_player()->query_cols()) + "\n";
      }
   }
   if (num == 1) {
      stuff = "All but one person folded so the cards are not revealed.\n";
   }
   if (discard) {
      foreach (id in query_started_player_ids()) {
         data = query_player_data(id);
         if (data->state == POKER_STATE_FOLDED) {
            tell_player(id, "%^BOLD%^Now into the discard phase.%^RESET%^\n"
               "You have folded.\n");
         } else {
            data->bet = 0;
            tell_player(id, "%^BOLD%^Now into the discard phase.%^RESET%^\n"
               "Your hand:\n" +
               query_hand_string(data->hand, CARD_HAND_THREE | CARD_HAND_LETTERS,
                                    80));
         }
      }
   } else {
      if (_house_cut) {
         stuff += "House takes " +
            MONEY_HAND->money_value_string((_pot * _house_cut) / 100, place) +
                  ".\n";
        adjust_float((_pot * _house_cut) / 100);
        _pot -= (_pot * _house_cut) / 100;
      }
      if (sizeof(winner) > 1) {
         stuff += "Tie for winning between " +
           query_multiple_short(map(winner, (: query_player_cap_name($1) :))) +
                  ", they each win " +
                  MONEY_HAND->money_value_string(_pot / sizeof(winner), place) +
                  ".\n";
         paid = _pot / sizeof(winner);
         foreach (id in winner) {
            ob = query_player_object(id);
            if (ob) {
               ob->adjust_money(MONEY_HAND->create_money_array(paid, place), place);
               _player_stats[ob->query_name()] += paid;
            } else {
               stuff += "Unable to find " + id + " to pay them, money "
                               "going to the house.\n";
               adjust_float(paid);
            }
         }
      } else {
         stuff += "Winner is " +
           query_multiple_short(map(winner, (: query_player_cap_name($1) :))) +
                  ", and they win " +
                  MONEY_HAND->money_value_string(_pot, place) +
                  ".\n";
         ob = query_player_object(winner[0]);
         ob->adjust_money(MONEY_HAND->create_money_array(_pot, place), place);
         _player_stats[ob->query_name()] += _pot;
      }
      tell_all_players("The players reveal their cards as:\n" +
                       stuff);
      tell_room(environment(), "The game ends with " + query_multiple_short(winner) +
                               " as the winner.\n");
      finish_game(query_multiple_short(winner));
      _finished = 1;
   }
}
void finish_discard() {
   string id;
   class player_data data;
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state != POKER_STATE_AFTER_DISCARD &&
          data->state != POKER_STATE_FOLDED) {
         return 0;
      }
   }
   _draw_round++;
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state == POKER_STATE_AFTER_DISCARD) {
         if (_draw_round >= _max_draw_rounds) {
            data->state = POKER_STATE_FINAL_BET;
         } else {
            data->state = POKER_STATE_BET;
         }
      }
   }
   _current_bet = 0;
   _poker_phase = POKER_STATE_FINAL_BET;
   call_out("tell_all_players", 0,
            "Discard round completed.  Now onto the " +
            (_draw_round >= _max_draw_rounds?"final ":"") + "betting round.\n");
   next_person_turn();
}
int do_ante() {
   string place;
   string id;
   int amount;
   class player_data data;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }
   data = query_player_data(id);
   if (data->state != POKER_STATE_ANTE) {
      add_failed_mess("You have already put in your ante.\n");
      return 0;
   }
   place = query_money_place();
   amount = _ante_house + _ante_amount;
   if (this_player()->query_value_in(place) < amount) {
      add_failed_mess("You do not have the needed " +
                      MONEY_HAND->money_value_string(amount, place) +
                      " to meet the ante.\n");
      return 0;
   }
   _player_stats[this_player()->query_name()] -= amount;
   this_player()->pay_money(MONEY_HAND->create_money_array(amount, place),
                            place);
   adjust_float(_ante_house);
   _pot += _ante_amount;
   data->state = POKER_STATE_PAID_ANTE;
   environment()->event_save(this_object());
   check_for_finish_ante();
   add_succeeded_mess("$N $V " +
                      MONEY_HAND->money_value_string(amount, place) +
                      " on $D.\n");
   return 1;
}
int do_discard(string throw_away) {
   int i;
   string id;
   class player_data data;
   string* bits;
   int* new_bits;
   throw_away = lower_case(throw_away);
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }
   data = query_player_data(id);
   if (!sizeof(data->hand)) {
      add_failed_mess("You cannot discard before you have been dealt "
                      "cards.\n");
      return 0;
   }
   if (data->state != POKER_STATE_DISCARD) {
      add_failed_mess("You are not in the discard phase.\n");
      return 0;
   }
   if (throw_away && throw_away != "none") {
      throw_away = lower_case(replace_string(throw_away, " ", ""));
      bits = explode(throw_away, ",");
      if (sizeof(filter(bits, (: strlen($1) > 1 :))) > 0) {
         add_failed_mess("Some of the card references " + throw_away +
                         " are invalid.  Use a command seperated list of "
                         "card ids.\n");
         return 0;
      }
      new_bits = map(bits, (: $1[0] - 'a' :));
      if (sizeof(filter(new_bits, (: $1 < 0 || $1 >= 5 :))) > 0) {
         add_failed_mess("Some of the card references " + throw_away +
                         " are invalid.  Use a command seperated list of "
                         "card ids.\n");
         return 0;
      }
      for (i = 0; i < sizeof(new_bits); i++) {
         if (member_array(new_bits[i],
                          new_bits[0..i-1] + new_bits[i+1..]) != -1) {
            add_failed_mess("You have referenced the card " +
                            sprintf("%c", 'A' + new_bits[i]) + " twice.\n");
            return 0;
         }
      }
      new_bits = sort_array(new_bits, (: $2 - $1 :));
      for (i = 0; i < sizeof(new_bits); i++) {
         _discard += ({ data->hand[new_bits[i]] });
         data->hand = data->hand[0..new_bits[i]-1] +
                      data->hand[new_bits[i]+1..];
      }
      i = 5 - sizeof(data->hand) - 1;
      if (sizeof(_deck) < i) {
         _deck += _discard;
         _deck = shuffle_array(_deck);
         _discard = ({ });
      }
      data->hand += _deck[0..i];
      _deck = _deck[i + 1..];
      data->hand = sort_cards(data->hand, 3);
      data->hand_type = query_hand_type(data->hand);
      add_succeeded_mess(({ "", "$N draw$s " + query_num(sizeof(new_bits)) +
                                " new card" +
                               (sizeof(new_bits) > 1?"s":"") + " on $D.\n" }));
      write("Your new hand (" +
            query_hand_type_string(data->hand_type) +
            "):\n" +
            query_hand_string(data->hand, CARD_HAND_THREE,
                                  this_player()->query_cols()));
      data->state = POKER_STATE_AFTER_DISCARD;
   } else {
      new_bits = ({ });
      data->state = POKER_STATE_AFTER_DISCARD;
      add_succeeded_mess("$N do$es not discard any cards on $D.\n");
   }
   finish_discard();
   return 1;
}
int do_check() {
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   if (_current_bet) {
      add_failed_mess("You cannot check since betting has started.\n");
      return 0;
   }
   add_succeeded_mess("$N check$s on $D.\n");
   next_person_turn();
   return 1;
}
int do_call() {
   class player_data data;
   int amt;
   string place;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   if (!_current_bet) {
      add_failed_mess("No one has bet anything for you to call.\n");
      return 0;
   }
   place = query_money_place();
   data = query_player_data(query_current_player());
   if (_current_bet && data->bet == _current_bet) {
      call_out("complete_round", 2);
      if (_poker_phase == POKER_STATE_ANTE) {
         _poker_phase = POKER_STATE_DISCARD;
      } else {
         _poker_phase = POKER_STATE_ANTE;
      }
   } else {
      amt = _current_bet - data->bet;
      if (this_player()->query_value_in(place) < amt) {
         add_failed_mess("You do not have the necessary " +
                         MONEY_HAND->money_value_string(amt, place) +
                         " to call the bet.\n");
         return 0;
      }
      _player_stats[this_player()->query_name()] -= amt;
      this_player()->pay_money(MONEY_HAND->create_money_array(amt, place),
                               place);
      _pot += amt;
      data->bet = _current_bet;
      if (!check_end_round()) {
         next_person_turn();
      }
   }
   add_succeeded_mess("$N call$s the bet by adding " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to the pot for a total bet of " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " on $D.\n");
   return 1;
}
int do_raise(string amount) {
   class player_data data;
   string place;
   int amt;
   int raise_amt;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   place = query_money_place();
   amt = MONEY_HAND->value_from_string(amount, place);
   raise_amt = amt;
   if (!amt) {
      add_failed_mess("The value " + amount + " is not a valid "
                      "money amount.\n");
      return 0;
   }
   if (amt < _min_bet) {
      add_failed_mess("The minimum bet is " +
                      MONEY_HAND->money_value_string(_min_bet, place) +
                      ".\n");
      return 0;
   }
   if (amt > _max_bet) {
      add_failed_mess("The maximum bet is " +
                      MONEY_HAND->money_value_string(_max_bet, place) +
                      ".\n");
      return 0;
   }
   data = query_player_data(query_current_player());
   amt = _current_bet + amt - data->bet;
   if (this_player()->query_value_in(place) < amt) {
      add_failed_mess("You do not have the nessessary " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to raise the bet.\n");
      return 0;
   }
   _player_stats[this_player()->query_name()] -= amt;
   this_player()->pay_money(MONEY_HAND->create_money_array(amt, place),
                               place);
   _current_bet = data->bet + amt;
   data->bet = _current_bet;
   _pot += amt;
   add_succeeded_mess("$N raise$s the bet by " +
                      MONEY_HAND->money_value_string(raise_amt, place) +
                      " to " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " on $D.\n");
   next_person_turn();
   return 1;
}
int do_bet(string amount) {
   class player_data data;
   string place;
   int amt;
   int raise_amt;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (_poker_phase != POKER_STATE_BET &&
       _poker_phase != POKER_STATE_FINAL_BET) {
      add_failed_mess("Not a betting phase.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   place = query_money_place();
   amt = MONEY_HAND->value_from_string(amount, place);
   if (!amt) {
      add_failed_mess("The value " + amount + " is not a valid "
                      "money amount.\n");
      return 0;
   }
   if (amt == _current_bet) {
      return do_call();
   }
   if (amt < _current_bet) {
      add_failed_mess("You have to bet higher than the current bet of " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " money amount.\n");
      return 0;
   }
   amt = amt - _current_bet;
   raise_amt = amt;
   if (amt < _min_bet) {
      add_failed_mess("The minimum bet is " +
                      MONEY_HAND->money_value_string(_min_bet, place) +
                      ".\n");
      return 0;
   }
   if (amt > _max_bet) {
      add_failed_mess("The maximum bet is " +
                      MONEY_HAND->money_value_string(_max_bet, place) +
                      ".\n");
      return 0;
   }
   data = query_player_data(query_current_player());
   amt = _current_bet + amt - data->bet;
   if (this_player()->query_value_in(place) < amt) {
      add_failed_mess("You do not have the nessessary " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to raise the bet.\n");
      return 0;
   }
   _player_stats[this_player()->query_name()] -= amt;
   this_player()->pay_money(MONEY_HAND->create_money_array(amt, place),
                               place);
   _current_bet = data->bet + amt;
   data->bet = _current_bet;
   _pot += amt;
   add_succeeded_mess("$N raise$s the bet by " +
                      MONEY_HAND->money_value_string(raise_amt, place) +
                      " to " +
                      MONEY_HAND->money_value_string(_current_bet, place) +
                      " on $D.\n");
   next_person_turn();
   return 1;
}
int do_fold() {
   class player_data data;
   string id;
   int not_folded;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   if (!is_current_player(this_player())) {
      add_failed_mess("Not your turn to bet.\n");
      return 0;
   }
   data = query_player_data(query_current_player());
   data->state = POKER_STATE_FOLDED;
   add_succeeded_mess("$N fold$s on $D.\n");
   foreach (id in query_started_player_ids()) {
      data = query_player_data(id);
      if (data->state != POKER_STATE_FOLDED) {
         not_folded++;
      }
   }
   if (not_folded == 1) {
      call_out("complete_round", 0, 1);
      _poker_phase = POKER_STATE_END;
   } else if (!check_end_round()) {
      next_person_turn();
   }
   return 1;
}
int do_start() {
   int old_pot;
   if (!is_open_for("poker", this_player()->query_name())) {
      add_failed_mess("The poker table is not open.\n");
      return 0;
   }
   if (!is_playing(this_player())) {
      add_failed_mess("You must be playing the game to start it.\n");
      return 0;
   }
   old_pot = _pot;
   if (!start_game()) {
      add_failed_mess("You need at least two people to play poker.\n");
      return 0;
   }
   adjust_float(old_pot);
   add_succeeded_mess("$N $V a game on $D.\n");
   return 1;
}
int do_finish() {
   string person;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   person = find_player_id_of_person(this_player());
   if (!person) {
      add_failed_mess("You must actually be playing to finish the game.\n");
      return 0;
   }
   finish_game(0);
   reset_game();
   return 1;
}
string query_main_status(int hint) {
   string place;
   string ret;
   string name;
   int amt;
   place = query_money_place();
   ret = "$I$0=Poker table:\n"
          "$I$6=   Maximum bet: " +
              MONEY_HAND->money_value_string(_max_bet, place) +
          "\n$I$6=   Minimum bet: " +
              MONEY_HAND->money_value_string(_min_bet, place) +
          "\n$I$6=   Ante       : " +
              MONEY_HAND->money_value_string(_ante_amount, place) +
          "\n$I$6=   House Ante : " +
              MONEY_HAND->money_value_string(_ante_house, place) +
          "\n$I$6=   Draw Rounds: " + _max_draw_rounds +
          "\n$I$6=   Cut        : " + _house_cut + "%"
          "\n$I$6=   Revenue    : " +
              MONEY_HAND->money_value_string(query_revenue(), place) +
          "\n$I$0=";
   foreach (name, amt in _player_stats) {
      ret += sprintf(" %-13s: %s\n" , name,
                     MONEY_HAND->money_value_string(amt, place));
   }
   return ret + "\n";
}
int do_set_ante(string str, int ante_game) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (lower_case(str) == "none" && !ante_game) {
      value = 0;
   } else {
      place = query_money_place();
      value = MONEY_HAND->value_from_string(str, place);
      if (!value) {
         add_failed_mess("Unable to parse the string " + str + ".\n");
         return 0;
      }
   }
   if (ante_game) {
      _ante_amount = value;
      add_succeeded_mess("$N set$s the ante amount to play to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   } else {
      _ante_house = value;
      add_succeeded_mess("$N set$s the ante amount for the house to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   }
   return 1;
}
int do_set_bet(string str, int max_bet) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   if (max_bet) {
      _max_bet = value;
      add_succeeded_mess("$N set$s the maximum bet to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   } else {
      _min_bet = value;
      add_succeeded_mess("$N set$s the minimum bet to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   }
   return 1;
}
int do_set_cut(int percent) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (percent < 0) {
      add_failed_mess("You cannot set the cut less than 0.\n");
      return 0;
   }
   if (percent > 100) {
      add_failed_mess("You cannot set the cut to greator than 100%.\n");
      return 0;
   }
   _house_cut = percent;
   add_succeeded_mess("$N set$s the cut to " + percent + "% on $D.\n");
   return 1;
}
int do_set_draw(int draw) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (draw < 0) {
      add_failed_mess("You cannot set the number of draws less than 0.\n");
      return 0;
   }
   if (draw > 5) {
      add_failed_mess("You cannot set the draw to greator than 5.\n");
      return 0;
   }
   _max_draw_rounds = draw;
   add_succeeded_mess("$N set$s the number of draw rounds to " + draw + " on $D.\n");
   return 1;
}
int do_rules() {
   string ret;
   string place;
   place = query_money_place();
   ret = "The rules for this table are:\n";
   ret += "$I$6=   Maximum amount that can be raised " +
              MONEY_HAND->money_value_string(_max_bet, place) +
          "\n$I$6=   Minimum amount that can be raised " +
              MONEY_HAND->money_value_string(_min_bet, place) +
          "\n$I$6=   Total ante " +
              MONEY_HAND->money_value_string(_ante_amount + _ante_house, place) +
          "\n$I$6=   Cut of the pool : " + _house_cut +
          "\n$I$6=   Draw Rounds     : " + _max_draw_rounds +
          "\n$I$6=   House Ante      : " +
              MONEY_HAND->money_value_string(_ante_house, place);
   write("$P$Rules$P$" + ret);
}
int do_reset() {
   if (::do_reset()) {
      _player_stats = ([ ]);
      add_succeeded_mess("$N clear$s the player stats.\n");
      return 1;
   }
}
void init() {
   multiplayer_base::init();
   commercial::init();
   add_command("discard", "<string'card'> on <direct:object>",
               (: do_discard($4[0]) :));
   add_command("ante", "on <direct:object>",
               (: do_ante() :));
   add_command("check", "on <direct:object>",
               (: do_check() :));
   add_command("call", "on <direct:object>",
               (: do_call() :));
   add_command("bet", "<string'total bet'> on <direct:object>",
               (: do_bet($4[0]) :));
   add_command("raise", "<string'raise'> on <direct:object>",
               (: do_raise($4[0]) :));
   add_command("fold", "on <direct:object>",
               (: do_fold() :));
   add_command("finish", "game on <direct:object>",
               (: do_finish() :));
   add_command("start", "game on <direct:object>",
               (: do_start() :));
   add_command("rules", "<direct:object>",
               (: do_rules() :));
   add_command("rules", "{for|on|of} <direct:object>",
               (: do_rules() :));
   if (environment()->is_allowed(this_player()->query_name())) {
      add_command("set", "draw <number'rounds'> on <direct:object>",
                  (: do_set_draw($4[0]) :));
      add_command("set", "cut <number'percentage'> on <direct:object>",
                  (: do_set_cut($4[0]) :));
      add_command("set", "ante house <string'amount|none'> on <direct:object>",
                  (: do_set_ante($4[0], 0) :));
      add_command("set", "ante game <string'amount'> on <direct:object>",
                  (: do_set_ante($4[0], 1) :));
      add_command("set", "minimum bet <string'amount'> on <direct:object>",
                  (: do_set_bet($4[0], 0) :));
      add_command("set", "maximum bet <string'amount'> on <direct:object>",
                  (: do_set_bet($4[0], 1) :));
   }
}
void resign_person(string id) {
   class player_data data;
   int not_folded;
   data = query_player_data(id);
   if (data && data->state != POKER_STATE_FOLDED) {
      tell_all_players(query_player_cap_name(id) +
                       " resigns and folds.\n");
      data->state = POKER_STATE_FOLDED;
      foreach (id in query_started_player_ids()) {
         data = query_player_data(id);
         if (data->state != POKER_STATE_FOLDED) {
            not_folded++;
         }
      }
      if (not_folded == 1) {
         call_out("complete_round", 0, 1);
         _poker_phase = POKER_STATE_END;
      }
   } else {
      switch (_poker_phase) {
      case POKER_STATE_ANTE :
         check_for_finish_ante();
         break;
      case POKER_STATE_BET :
         check_end_round();
         break;
      case POKER_STATE_DISCARD :
         finish_discard();
         break;
      }
   }
}
void event_exit(object ob, string mess, object to) {
   string id;
   if (userp(ob) && to != environment()) {
      id = find_player_id_of_person(ob);
      if (id) {
         resign_person(id);
      }
   }
}
void multiplayer_someone_resigns(string id, string name) {
   resign_person(id);
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   multiplayer_base::query_dynamic_auto_load(map);
   add_auto_load_value(map, BOARD_TAG, "return", _return);
   add_auto_load_value(map, BOARD_TAG, "ante amount", _ante_amount);
   add_auto_load_value(map, BOARD_TAG, "house cut", _house_cut);
   add_auto_load_value(map, BOARD_TAG, "ante house", _ante_house);
   add_auto_load_value(map, BOARD_TAG, "min bet", _min_bet);
   add_auto_load_value(map, BOARD_TAG, "max bet", _max_bet);
   add_auto_load_value(map, BOARD_TAG, "current bet", _current_bet);
   add_auto_load_value(map, BOARD_TAG, "pot", _pot);
   add_auto_load_value(map, BOARD_TAG, "deck", _deck);
   add_auto_load_value(map, BOARD_TAG, "poker phase", _poker_phase);
   add_auto_load_value(map, BOARD_TAG, "draw round", _draw_round);
   add_auto_load_value(map, BOARD_TAG, "max draw rounds", _max_draw_rounds);
   add_auto_load_value(map, BOARD_TAG, "discard", _discard);
   add_auto_load_value(map, BOARD_TAG, "player stats", _player_stats);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   multiplayer_base::init_dynamic_arg(map, player);
   _return = query_auto_load_value(map, BOARD_TAG, "return");
   _ante_amount = query_auto_load_value(map, BOARD_TAG, "ante amount");
   _ante_house = query_auto_load_value(map, BOARD_TAG, "ante house");
   _house_cut = query_auto_load_value(map, BOARD_TAG, "house cut");
   _deck = query_auto_load_value(map, BOARD_TAG, "deck");
   _current_bet = query_auto_load_value(map, BOARD_TAG, "current bet");
   _pot = query_auto_load_value(map, BOARD_TAG, "pot");
   _min_bet = query_auto_load_value(map, BOARD_TAG, "min bet");
   _max_bet = query_auto_load_value(map, BOARD_TAG, "max bet");
   _poker_phase = query_auto_load_value(map, BOARD_TAG, "poker phase");
   _draw_round = query_auto_load_value(map, BOARD_TAG, "draw round");
   _max_draw_rounds = query_auto_load_value(map, BOARD_TAG, "max draw rounds");
   _discard = query_auto_load_value(map, BOARD_TAG, "discard");
   _player_stats = query_auto_load_value(map, BOARD_TAG, "player stats");
   if (!_player_stats) {
      _player_stats = ([ ]);
   }
}

==================================================
FILE: room/furniture/shop_base.c
==================================================

inherit "/std/room/furniture/commercial";
inherit "/std/shops/inherit/player_craft_shop_base";
#define SAVE_TIME 1
private int _save_call;
private int _last_saved;
private string _counter_short;
#define OBJECT_TAG "shop base"
void create() {
   player_craft_shop_base::create();
   set_shop_use_types(({ "use", "buy" }));
   commercial::create();
   set_commercial_name("craft shop");
}
int query_player_craft_shop() {
   return 1;
}
int disallow_sale_here(object room) {
   object* obs;
   obs = room->find_commercial_items(query_commercial_name());
   return sizeof(obs);
}
int query_royalty(string person) {
   return commercial::query_royalty(person);
}
string query_craft_shop_save_dir() {
   return environment()->query_save_dir() + "craft_shop";
}
void adjust_royalty(string person, int amount) {
   commercial::adjust_royalty(person, amount);
}
string query_parcel_post() {
   return commercial::query_parcel_post();
}
void reset_weekly_status() {
   player_craft_shop_base::reset_weekly_status();
}
string query_weekly_status_string() {
   return player_craft_shop_base::query_weekly_status_string();
}
void load_me() {
  string fname, tmp;
#ifdef USE_RAMDISK
  tmp = replace_string(query_save_dir() + "craft_shop_file", "/save/",
                       "/save/ramdisk/");
  if(unguarded((: file_size($(tmp) = ".o.gz") :)) > 0 ||
     unguarded((: file_size($(tmp) = ".o") :)) > 0) {
    fname = tmp;
  }
#endif
  if(!fname) {
    fname = query_save_dir() + "craft_shop_file";
  }
   unguarded( (: restore_object($(fname)) :));
#ifdef USE_RAMDISK
   tmp = replace_string(query_craft_shop_save_dir(), "/save/",
                        "/save/ramdisk/");
   unguarded( (: mkdir($(tmp)) :));
#endif
   unguarded( (: mkdir(query_craft_shop_save_dir()) :));
   reload_shop();
   add_property("place", environment()->query_property("place"));
}
void init() {
   player_craft_shop_base::init();
   commercial::init();
}
void do_save() {
  string fname;
  string dir;
   _save_call = 0;
   if (environment() && query_save_dir()) {
#ifdef USE_RAMDISK
     dir = replace_string(query_save_dir(), "/save/",
                            "/save/ramdisk/");
     if (file_size(dir) == -2) {
        fname = dir + "craft_shop_file";
     }
#endif
     if(!fname) {
       fname = query_save_dir() + "craft_shop_file";
     }
     debug_printf("Saving to %O\n", fname);
     unguarded( (: save_object($(fname), 2) :));
   }
}
void dest_me() {
   do_save();
   player_craft_shop_base::dest_me();
   commercial::dest_me();
}
string query_commercial_information() {
   return "This shop can have a maximum of " + query_maximum_inventory_size() +
          " items for sale.  "
          "You can only have "
          "one shop counter in any room, more than one will not be "
          "able to be bought.";
}
void event_save(object ob) {
   if (!_save_call) {
      if(_last_saved > time() - SAVE_TIME) {
         _save_call = call_out("do_save", SAVE_TIME - (time() - _last_saved));
      } else {
         _save_call = call_out("do_save", SAVE_TIME);
      }
#ifdef DEBUG
      debug_printf("Adding call_out");
#endif
   }
}
mapping query_commercial_options() {
   return ([
    "counter type" : ([
       "polished hardwood counter" : 500000,
       "shiny polished counter" : 150000,
       "unfinished pine counter" : 0,
      ]),
   "stockroom size" : ([
       "50" : 0,
       "100" : 1000000,
       "150" : 2500000,
      ]),
   ]);
}
void set_commercial_option(string type, string name) {
   string* bits;
   int size;
   switch (type) {
   case "counter type" :
      _counter_short = name;
      set_short(_counter_short);
      bits = explode(lower_case(_counter_short), " ");
      add_adjective(bits[0..<2]);
      add_alias(bits[<1]);
      break;
   case "stockroom size" :
      sscanf(name, "%d", size);
      set_maximum_waiting_queue_size(size);
      break;
   }
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, OBJECT_TAG, "stocksize", query_maximum_waiting_queue_size());
   add_auto_load_value(map, OBJECT_TAG, "counter short", _counter_short);
}
void init_dynamic_arg(mapping map, object player) {
   string* bits;
   int size;
   commercial::init_dynamic_arg(map, player);
   size = query_auto_load_value(map, OBJECT_TAG, "stocksize");
   _counter_short = query_auto_load_value(map, OBJECT_TAG, "counter short");
   if (size) {
      set_maximum_waiting_queue_size(size);
   }
   if (_counter_short) {
      bits = explode(lower_case(_counter_short), " ");
      add_adjective(bits[0..<2]);
      add_alias(bits[<1]);
   }
}

==================================================
FILE: room/furniture/sink_inherit.c
==================================================

#include <effect.h>
inherit "/std/room/furniture/surface";
#define WET_EFFECT "/std/effects/other/wetness"
#define SOAP_EFFECT "/std/effects/healing/antiseptic_soap"
int water = 0;
int dirt = 0;
string* dirt_messages = ({
    "clear",
    "almost clear",
    "soapy",
    "foamy",
    "slightly dirty",
    "fairly dirty",
    "dirty",
    "very dirty",
    "muddy"
});
void zap_bad_effects( object who );
int do_wash(object *indirect_obs );
void create(){
    ::create();
    add_property( "no recycling", 1 );
    this_object()->add_extra_look( this_object() );
}
string extra_look() {
    object *stuff;
    string answer = "";
    stuff = all_inventory( this_object() );
    if (water) {
        if (dirt >= sizeof(dirt_messages)) {
            dirt = sizeof(dirt_messages) - 1;
        }
        answer = answer + "It's about three quarters full of " +
            dirt_messages[dirt] + " water.\n";
    }
    if( sizeof( stuff ) ) {
        answer = answer + "It has "+ query_multiple_short( stuff ) +" in it.\n";
    }
   return answer;
}
string long_status() {
    return "";
}
void init(){
    ::init();
    add_command( "fill", "<direct:object>");
    add_command( "empty", "<direct:object>");
    add_command( "splash", "<indirect:living:here>");
    add_command( "wash", "<indirect:living:here>");
}
void wet_everyone_in() {
    object *victims;
    if (!water) {
        return;
    }
    victims = filter(all_inventory(environment(this_object())),
        (: living($1) :) );
    foreach( object victim in victims ) {
        if (victim -> query_position_type() == "in" &&
            victim -> query_position_on() == "the "+this_object()->short()) {
            victim->add_effect( WET_EFFECT, 500 );
        }
    }
}
void reset() {
    wet_everyone_in();
}
int do_fill() {
    object player;
    player=this_player();
    if (water) {
        player->add_failed_mess(this_object(), "The " + this_object()->short() + " is "
            "already full of water.\n");
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    tell_object(player, "You fill the " + this_object()->short() + " with clean water.\n" );
    tell_room(environment(player), player->short()+" fills "
        "the " + this_object()->short() + " with clean water.\n", player );
    water=1;
    dirt=0;
    wet_everyone_in();
    return 1;
}
int do_empty() {
    object player;
    player=this_player();
    if (!water) {
        player->add_failed_mess(this_object(), "The " + this_object()->short() + " is "
            "already as empty as it gets.\n");
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    tell_object(player, "You reach into the " + this_object()->short() + " and "
                "pull the plug, allowing the water to drain away.\n" );
    tell_room(environment(player), player->short()+" reaches into "
        "the " + this_object()->short() + " and pulls the plug, allowing "
        "the water to flow away.\n", player );
    water=0;
    dirt=0;
    return 1;
}
int do_splash( object *indirect_obs ) {
    if (!water) {
        this_player()->add_failed_mess(this_object(), "It's not a bad idea,  "
            "but maybe you'd need some water in the " + this_object()->short() +
            "before you can splash.\n");
        return 0;
    }
    if ( sizeof( indirect_obs ) ) {
        add_succeeded_mess( "$N splash$es $I.\n", indirect_obs );
        return 1;
    }
    this_player()->add_succeeded_mess( this_object(),
        "$N splash$es $oself.\n", ({ }) );
    return 1;
}
int do_wash( object *indirect_obs ) {
    if (!water) {
        this_player()->add_failed_mess(this_object(), "It's not a bad idea,  "
            "but maybe you'd need some water in the " + this_object()->short() +
            "before you can wash.\n");
        return 0;
    }
    if (dirt >= sizeof(dirt_messages) - 1) {
        this_player()->add_failed_mess(this_object(), "The water in the " +
            this_object()->short() +
            " looks so muddy, it probably would just soil anyone.  Maybe " +
            " it would be a better idea to empty it and fill it again " +
            " with fresh water.\n");
        return 0;
    }
    if ( sizeof( indirect_obs ) ) {
        foreach( object victim in indirect_obs ) {
            call_out( (: zap_bad_effects( $1 ) :), 0, victim );
        }
        add_succeeded_mess( "$N wash$es $I using a bar of pleasant smelling soap.\n", indirect_obs );
        return 1;
    }
    call_out( (: zap_bad_effects( $1 ) :), 0, this_player() );
    this_player()->add_succeeded_mess( this_object(),
        "$N wash$es $oself using a bar of pleasant smelling soap.\n", ({ }) );
    return 1;
}
void zap_bad_effects( object who ) {
    int i, flag, *enums;
    class effect *effs;
    dirt++;
    effs = (class effect *)who->query_effs();
    enums = (int *)who->effects_matching( "body.smell" );
    i = sizeof( enums );
    if ( !random(dirt) && i ) {
        i = random( i );
        flag = 1;
        write( "The antiseptic power of the soap defeats "+
          (string)effs[ enums[ i ] ]->ob_name->smell_string( who,
            effs[ enums[ i ] ]->arg ) +".\n" );
        who->delete_effect( enums[ i ] );
        dirt ++;
    }
    enums = who->effects_matching("pie.cream");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The cream washes right off your body.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = (int *)who->effects_matching( "misc.ketchup" );
    i = sizeof( enums );
    if ( !random(dirt) && i ) {
        i = random( i );
        flag = 1;
        write( "The soap rinses the ketchup off your face.\n" );
        who->delete_effect( enums[ i ] );
        dirt ++;
    }
    enums = who->effects_matching("exploded.apples");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The apples wash right off your body.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = (int *)who->effects_matching("object.label");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The labels stuck on you peel off in "
          "the water.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = who->effects_matching("body.frog-adhesive");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The frog adhesive washes off in the water.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    if (!random(dirt)) {
        who->add_effect( SOAP_EFFECT, 10000 );
    }
    who->add_effect( WET_EFFECT, 250 );
}

==================================================
FILE: room/furniture/storage.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <tasks.h>
inherit "/obj/cont_save";
inherit "/std/basic/trap";
inherit "/std/room/furniture/inherit/furniture_base";
private nosave string _drawer_mess;
private nosave mixed *_drawers;
private nosave int _biggest;
private nosave int _drawers_inside;
#undef DEBUG
void create() {
   do_setup++;
   furniture_base::create();
   cont_save::create();
   _drawer_mess = "a drawer in $ob_short$";
   _drawers = ({ });
   add_alias( "furniture" );
   add_plural( "furniture" );
   set_opaque();
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
   }
   set_no_all(1);
}
string query_drawer_mess() { return _drawer_mess; }
void set_drawer_mess( string words ) { _drawer_mess = words; }
mixed *query_drawers() { return _drawers; }
void add_drawer( string type, int amount ) {
   if ( !type || ( type == "" ) || ( amount < 1 ) ) {
      return;
   }
   _drawers += ({ type, amount });
   set_max_weight(query_max_weight() + amount);
   if ( amount > _biggest ) {
      _biggest = amount;
   }
}
void set_drawers_inside(int i) { _drawers_inside = i; }
int query_drawers_inside() { return _drawers_inside; }
varargs int move( mixed dest, string messin, string messout ) {
  int i, w;
  object from;
  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }
  w = (int)this_object()->query_complete_weight() * 5;
  if ( from = environment() ) {
    from->add_weight( -w );
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if (!( dest->add_weight( w ) ) ) {
    if ( from ) {
      from->add_weight( w );
    }
    return MOVE_TOO_HEAVY;
  }
  if ( stringp( dest ) ) {
    dest = find_object( dest );
  }
  i = ::move( dest, messin, messout );
  if ( i != MOVE_OK ) {
    if ( from ) {
      from->add_weight( w );
    }
    dest->add_weight( -w );
  } else if (query_light_needs_inform()) {
    if ( from ) {
      inform_of_light_level_change(from);
    }
    inform_of_light_level_change(dest);
  }
  return i;
}
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}
string long( string word, int dark ) {
   int i;
   string ret, *sizes;
   mapping types;
  ret = ::long( word, dark );
   if ( sizeof( _drawers ) && !dark &&
        (!query_closed() || !_drawers_inside)) {
     types = ([ ]);
     for ( i = 0; i < sizeof( _drawers ); i += 2 ) {
       types[ _drawers[ i ] ]++;
     }
     sizes = m_indices( types );
     for ( i = 0; i < sizeof( sizes ); i++ ) {
       sizes[ i ] = query_num( types[ sizes[ i ] ] ) +" "+ sizes[ i ] +
         " drawer"+ ( types[ sizes[ i ] ] > 1 ? "s" : "" );
     }
     ret += "It has "+ query_multiple_short( sizes ) +".\n";
   }
   return ret;
}
int test_remove(object thing, int flag, mixed dest) {
  int result;
  mixed *stuff;
  object thief;
  result = ::test_remove(thing, flag, dest);
  if(result && environment() && this_player()) {
    thief = this_player();
    if(thief->query_caster())
      thief = find_player(thief->query_caster());
    else if(thief->query_owner())
      thief = thief->query_owner();
    stuff = thing->query_property("dropped");
    if(function_exists("test_occupier", environment()) &&
       !environment()->test_occupier(thief->query_name()) &&
       (!sizeof(stuff) || stuff[0] != thief->query_name()) &&
       thief && environment(thief)) {
      event(environment(thief), "theft", thief, this_object(), ({ thing }));
    }
#ifdef DEBUG
    if(base_name(environment()) != "/room/rubbish")
      log_file(base_name(environment()) + ".log",
               "%s %s moved from %s to %s.\n", ctime(time())[4..18],
               thing->query_short(), this_object()->query_short(),
               dest->query_short());
#endif
    event(environment(), "save");
  }
  return result;
}
int test_add( object thing, int flag ) {
  int i;
  if ( flag )
    return 0;
  if(!environment(thing))
    return 1;
  if(sizeof(_drawers)) {
    if ( !_biggest )
      for ( i = 0; i < sizeof( _drawers ); i+= 2 )
        if ( _drawers[ i + 1 ] > _biggest )
          _biggest = _drawers[ i + 1 ];
    if ( (int)thing->query_complete_weight() > _biggest )
      return write( (string)thing->the_short() +" is too big "+
                    "to fit in any of "+ the_short() +"'s drawers.\n" );
  }
  event(environment(), "save", this_object());
  i = ::test_add(thing, flag);
#ifdef DEBUG
  if(environment() && base_name(environment()) != "/room/rubbish")
    log_file(base_name(environment()) + ".log",
             "%s %s put in %s by %s [%d].\n", ctime(time())[4..18],
             thing->query_short(), this_object()->query_short(),
             this_player() ? this_player()->query_name() : "Unknown",
             i);
#endif
  return i;
}
private int pick_ok(object player) {
  mixed owner;
  if(!environment() ||
     !function_exists("query_owner", environment()) ||
     environment()->test_occupier(player->query_name()))
    return ::pick_unlock(player);
  owner = environment()->query_owner();
  if(stringp(owner) && pk_check(player, owner, 1)) {
    write("You feel it would be wrong to try to break into "+
          this_object()->query_short() + ".\n");
    return 0;
  }
  return ::pick_unlock(player);
}
int pick_unlock(object player) {
  if(!pick_ok(player))
    return 0;
  return ::pick_unlock(player);
}
int pick_lock(object player) {
  if(!pick_ok(player))
    return 0;
  return ::pick_lock(player);
}
mixed *stats() {
  int i;
  mixed *ret;
  ret = ::stats();
  for ( i = 0; i < sizeof( _drawers ); i += 2 )
    ret += ({ ({ _drawers[ i ] +" drawer", _drawers[ i + 1 ] }) });
  return ret;
}
mapping int_query_static_auto_load() {
  return ([
           "::" : ::int_query_static_auto_load(),
           "drawer mess" : _drawer_mess,
           "drawers" : _drawers,
           "allowed_positions" : query_allowed_positions(),
           "trap" : query_trap_data(),
           "trap armed": query_trap_armed(),
           ]);
}
mapping query_static_auto_load() {
  return int_query_static_auto_load();
}
void init_static_arg( mapping map ) {
  if ( !mapp( map ) )
    return;
  if ( map[ "::" ] )
    ::init_static_arg( map[ "::" ] );
  if ( !undefinedp( map[ "drawer mess" ] ) )
    _drawer_mess = map[ "drawer mess" ];
  if ( !undefinedp( map[ "drawers" ] ) )
    _drawers = map[ "drawers" ];
  if(!undefinedp(map["allowed_positions"]))
    set_allowed_positions(map["allowed_positions"]);
  if(!undefinedp(map["trap"]))
    setup_trap(map["trap"][0],
                   map["trap"][1],
                   map["trap"][2],
                   map["trap"][3],
                   map["trap"][4]);
  if(!undefinedp(map["trap armed"]))
    set_trap_armed(map["trap armed"]);
}
string query_help_file_directory() {
   return "/doc/furniture/";
}
mixed query_dynamic_auto_load() {
   mapping junk;
   junk = cont_save::query_dynamic_auto_load();
   if (!junk) {
      junk = ([ ]);
   }
   junk["bonded"] = query_bonded();
   return junk;
}
void init_dynamic_arg(mapping map, object) {
   cont_save::init_dynamic_arg(map, 0);
   set_bonded(map["bonded"]);
}

==================================================
FILE: room/furniture/surface.c
==================================================

#include <move_failures.h>
#include <player.h>
inherit "/std/object";
inherit "/std/basic/cute_look";
inherit "/std/basic/item_chat";
inherit "/std/room/furniture/inherit/furniture_base";
private nosave int _loc_weight, _max_weight;
private nosave string *_shadows;
private nosave object _player;
private nosave string *_aliases;
private nosave int _use_internals;
void create() {
  do_setup++;
  furniture_base::create();
  object::create();
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
  }
  set_no_all(1);
}
void init() {
  string alias;
  if(_aliases)
    foreach(alias in _aliases) {
      add_command(alias, "<indirect:object:me> {in|on|into} <indirect:object>",
                  (: "/cmds/living/put"->cmd($1, $3, $4) :) );
    }
  ::init();
}
void set_put_aliases(string *aliases) {
  _aliases = aliases;
}
void set_allow_use_internals(int allow) {
   _use_internals = allow;
}
int query_allow_use_internals() {
   return _use_internals;
}
varargs int move( mixed dest, string messin, string messout ) {
  int i, w;
  object from;
  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }
  w = (int)this_object()->query_complete_weight() * 5;
  if ( from = environment() ) {
    from->add_weight( -w );
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if (!( dest->add_weight( w ) ) ) {
    if ( from ) {
      from->add_weight( w );
    }
    return MOVE_TOO_HEAVY;
  }
  if ( stringp( dest ) ) {
    dest = find_object( dest );
  }
  i = ::move( dest, messin, messout );
  if ( i != MOVE_OK ) {
    if ( from ) {
      from->add_weight( w );
    }
    dest->add_weight( -w );
  } else {
    if (_use_internals) {
      if (from) {
        from->remove_use_internal_object(this_object());
      }
      dest->add_use_internal_object(this_object());
    }
    if (query_light_needs_inform()) {
      if ( from ) {
        inform_of_light_level_change(from);
      }
      inform_of_light_level_change(dest);
    }
  }
  return i;
}
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}
int test_remove(object thing, int flag, mixed dest) {
  mixed *stuff;
  object thief;
  if(environment() && this_player()) {
    thief = this_player();
    if(thief->query_caster())
      thief = find_player(thief->query_caster());
    else if(thief->query_owner())
      thief = thief->query_owner();
    stuff = thing->query_property("dropped");
    if(function_exists("test_occupier", environment()) &&
       !environment()->test_occupier(thief->query_name()) &&
       (!sizeof(stuff) || stuff[0] != thief->query_name()) &&
       thief && environment(thief)) {
      event(environment(thief), "theft", thief, this_object(), ({ thing }));
    }
#ifdef DEBUG
    if(base_name(environment()) != "/room/rubbish")
      log_file(base_name(environment()) + ".log",
               "%s %s moved from %s to %s.\n", ctime(time())[4..18],
               thing->query_short(), this_object()->query_short(),
               dest->query_short());
#endif
    event(environment(), "save");
  }
  return 1;
}
int test_add( object thing, int flag ) {
  if(environment())
    event(environment(), "save");
#ifdef DEBUG
  if(environment() && base_name(environment()) != "/room/rubbish")
    log_file(base_name(environment()) + ".log",
             "%s %s put on %s by %s.\n", ctime(time())[4..18],
             thing->query_short(), this_object()->query_short(),
             this_player() ? this_player()->query_name() : "Unknown");
#endif
  return 1;
}
void set_max_weight(int arg) { _max_weight = arg; }
int query_max_weight() { return _max_weight; }
int query_loc_weight() { return _loc_weight; }
int query_has_surface() { return 1; }
void update_loc_weight() {
  int i;
  object *contents;
  _loc_weight = 0;
  contents = all_inventory( this_object() );
  for ( i = 0; i < sizeof( contents ); i++ )
    _loc_weight += (int)contents[ i ]->query_complete_weight();
}
int query_complete_weight() {
  return ::query_complete_weight() + query_loc_weight();
}
int add_weight( int n ) {
  if ( !_max_weight ) return 1;
  if ( n + _loc_weight > _max_weight ) return 0;
  if ( !environment() ) {
    _loc_weight += n;
    return 1;
  }
  if ( !( environment()->add_weight( n ) ) ) return 0;
  _loc_weight += n;
  return 1;
}
int transfer_all_to(object dest) {
  object *ob;
  int i;
  ob = all_inventory(this_object());
  for (i=0;i<sizeof(ob);i++)
    ob[i]->move(dest);
  if (first_inventory(this_object())) return 0;
  return 1;
}
string long( string word, int dark ) {
   object *things;
   things = (object *)this_object()->find_inv_match( "all", this_player() );
   if ( !sizeof( things ) )
      return object::long( word, dark ) +"There is nothing on "+
            the_short() +".\n";
   return object::long( word, dark ) + query_contents( "On " +
            the_short() +" "+ ( sizeof( things ) == 1 ? "is " :
            "are " ), things );
}
object *find_inv_match( string words, object looker ) {
   int i;
   object *things;
   things = all_inventory( this_object() );
   for ( i = sizeof( things ) - 1; i > -1; i-- ) {
      if ( !things[ i ]->short( 0 ) ) {
         things = delete( things, i, 1 );
         continue;
      }
      if ( !looker )
         continue;
      if ( !things[ i ]->query_visible( looker ) )
         things = delete( things, i, 1 );
   }
   return things;
}
void set_player( object thing ) { _player = thing; }
object query_player() { return _player; }
mixed stats() {
  return ::stats() + ({
    ({ "loc_weight", query_loc_weight(), }),
    ({ "max_weight", query_max_weight(), }),
  });
}
mapping int_query_static_auto_load() {
  return ([
    "::" : ::int_query_static_auto_load(),
    "max weight" : _max_weight,
    "allowed positions" : query_allowed_positions(),
  ]);
}
mapping query_dynamic_auto_load() {
  mixed inventory;
  if (!inventory) {
    catch(inventory = PLAYER_OB->
        create_auto_load( all_inventory( this_object() ) ) );
  }
  return ([ "::" : ::query_dynamic_auto_load(),
            "inv" : inventory,
            "bonded" : query_bonded()
         ]);
}
int handle_restore_inventory(object ob) {
  return (int)ob->move(this_object());
}
void init_dynamic_arg( mapping bing ) {
  function f;
  if ( bing[ "::" ] ) {
    ::init_dynamic_arg( bing[ "::" ] );
  }
  if ( bing[ "inv" ] ) {
    f = (: handle_restore_inventory($1) :);
    if (_player) {
      _player->load_auto_load_to_inventory( bing["inv"], this_object(),
                                            _player, f);
    } else {
      PLAYER_OB->load_auto_load_to_inventory( bing["inv"], this_object(),
                                              this_player(), f);
    }
  }
  set_bonded(bing["bonded"]);
}
void init_static_arg(mapping bing) {
  if (bing["::"]) {
     ::init_static_arg(bing["::"]);
  }
  if (!undefinedp(bing["max weight"])) {
    _max_weight = bing["max weight"];
  if(!undefinedp(bing["allowed_positions"]))
    set_allowed_positions(bing["allowed_positions"]);
  }
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}
void dest_me() {
  int i;
  object shadow;
  for ( i = 0; i < sizeof( _shadows ); i++ ) {
    if ( shadow = find_object( _shadows[ i ] ) ) {
      shadow->destruct_shadow( shadow );
    }
  }
  all_inventory()->dest_me();
  object::dest_me();
}
string query_help_file_directory() {
   return "/doc/furniture/";
}

==================================================
FILE: room/furniture/vessel.c
==================================================

#include <move_failures.h>
#include <position.h>
inherit "/obj/vessel";
inherit "/std/basic/item_chat";
inherit "/std/room/furniture/inherit/furniture_base";
void create() {
   do_setup++;
   vessel::create();
   furniture_base::create();
   add_alias( "furniture" );
   add_plural( "furniture" );
   add_property("talisman", "no one");
   set_opaque();
   if ( !query_property( "shop type" ) ) {
      add_property( "shop type", "furniture" );
   }
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
   }
   set_no_all(1);
}
void init() {
   item_chat::init();
}
varargs int move( mixed dest, string messin, string messout ) {
  int i, t, f;
  object from;
  if(stringp(dest)) {
    dest = find_object(dest);
  }
  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if(living(dest)) {
    t = (int)this_object()->query_complete_weight() * 2;
    if(!(dest->add_weight(t))) {
      return MOVE_TOO_HEAVY;
    }
    debug_printf("Added %d", t);
  }
  i = ::move(dest, messin, messout);
  if(i != MOVE_OK) {
    dest->add_weight(-t);
    return i;
  }
  from = environment();
  if(from && living(from)) {
    f = (int)this_object()->query_complete_weight() * 2;
    from->add_weight(-f);
  }
  return i;
}
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}
mixed query_dynamic_auto_load() {
   mapping junk;
   junk = vessel::query_dynamic_auto_load();
   if (!junk) {
      junk = ([ ]);
   }
   junk["bonded"] = query_bonded();
   return junk;
}
void init_dynamic_arg(mapping map) {
   vessel::init_dynamic_arg(map);
   set_bonded(map["bonded"]);
}
string query_help_file_directory() {
   return "/doc/furniture/";
}
mixed *stats() {
   return ::stats() +
          ({ ({ "bonded", query_bonded() }) });
}

==================================================
FILE: room/furniture/inherit/document_handler.c
==================================================

#include <move_failures.h>
#include <nroff.h>
#include <room/newspaper.h>
#include <room/document_handler.h>
#define TAG "document__h"
class document {
   string title;
   string fname;
   string added_by;
   int time_added;
   int type;
}
private mapping _documents;
private int _next_doc_id;
string query_save_dir();
void save_me();
int is_open_for(string type, string name);
void add_auto_load_value(mapping map, string tag, string name, mixed value);
mixed query_auto_load_value(mapping map, string tag, string name);
void create() {
   _documents = ([ ]);
}
string query_document_file_name(string id) {
   if (_documents[id]) {
      return query_save_dir() + "/" + _documents[id]->fname;
   }
   return 0;
}
string query_document_data(string id) {
   string fname;
   fname = query_document_file_name(id);
   if (fname) {
      return unguarded( (: read_file($(fname)) :) );
   }
   return 0;
}
int is_document(string id) {
   return _documents[id] != 0;
}
string query_document_readable(string id) {
   string fname;
   string text;
   fname = query_document_file_name(id);
   if (fname) {
      switch (_documents[id]->type) {
      case DOCUMENT_PLAIN :
         text = unguarded( (: read_file($(fname)) :) );
         break;
      case DOCUMENT_HTML :
         text = unguarded( (: NROFF_HAND->cat_file($(fname) + ".nroff", 1) :) );
         if (!text) {
            text = unguarded( (: read_file( $(fname)) :) );
            if (text) {
               text = NEWSPAPER_HANDLER->convert_html(text);
               unguarded( (: write_file($(fname) + ".proc", $(text), 1) :) );
               if (unguarded( (: NROFF_HAND->create_nroff($(fname) + ".proc",
                           $(fname) + ".nroff")
:) )) {
                  text = unguarded( (: NROFF_HAND->cat_file($(fname) +
                                                            ".nroff") :) )
;
               } else {
                  text = "Unable to make nroff file.\n";
               }
            } else {
               text = "Unable to read the file, opps!\n";
            }
         }
         break;
      }
   }
   return text;
}
string query_document_html(string id) {
   string fname;
   string text;
   fname = query_document_file_name(id);
   if (fname) {
      switch (_documents[id]->type) {
      case DOCUMENT_PLAIN :
         text = unguarded( (: read_file($(fname)) :) );
         text = replace(fname, ({ "&", "&amp;", "<", "&lt;", ">", "&gt;",
                                  " ", "&nbsp;", "\n", "<br>" }) );
         break;
      case DOCUMENT_HTML :
         text = unguarded( (: read_file($(fname)) :) );
         if (!text) {
            text = unguarded( (: read_file( $(fname)) :) );
            if (text) {
               text = NEWSPAPER_HANDLER->convert_html(text);
               unguarded( (: write_file($(fname) + ".proc", $(text), 1) :) );
               if (unguarded( (: NROFF_HAND->create_nroff($(fname) + ".proc",
                           $(fname) + ".nroff")
:) )) {
                  text = unguarded( (: NROFF_HAND->cat_file($(fname) +
                                                            ".nroff") :) )
;
               } else {
                  text = "Unable to make nroff file.\n";
               }
            } else {
               text = "Unable to read the file, opps!\n";
            }
         }
         break;
      }
   }
   return text;
}
void update_document_text(string id, string text) {
   string fname;
   fname = query_document_file_name(id);
   if (fname) {
      unguarded( (: write_file($(fname), $(text), 1) :));
   }
}
void delete_document(string id) {
   string fname;
   fname = query_document_file_name(id);
   if (fname) {
      unguarded( (: rm($(fname) + ".proc") :));
      unguarded( (: rm($(fname) + ".nroff.o") :));
      unguarded( (: rm($(fname)) :));
      map_delete(_documents, id);
      save_me();
   }
}
string add_document(string title, string text, string person, int type) {
   class document bing;
   string id;
   id = _next_doc_id + "";
   bing = new(class document);
   bing->title = title;
   bing->added_by = person;
   bing->type = type;
   bing->time_added = time();
   bing->fname = id + ".txt";
   _next_doc_id++;
   _documents[id] = bing;
   update_document_text(id, text);
   save_me();
   return id;
}
int do_list() {
   string ret;
   class document info;
   string id;
   if (!is_open_for("document_view", this_player()->query_name())) {
      add_failed_mess("You cannot list documents on $I.\n",
                      ({ this_object() }));
      return 0;
   }
   if (!sizeof(_documents)) {
      add_failed_mess("Cannot find any documents to list on $I.\n",
                      ({ this_object() }));
      return 0;
   }
   ret = "";
   foreach (id, info in _documents) {
      ret += "$I$3=" + id + ") " + info->title + " [" + info->added_by +
             "] - " + ctime(info->time_added)[4..9] + " " +
             ctime(info->time_added)[<4..] + "\n";
   }
   write("$P$Documents$P$" + ret);
   add_succeeded_mess(({ "", "$N lists the documents in $I.\n" }),
                      ({ this_object() }));
   return 1;
}
int do_display(string id) {
   string ret;
   class document info;
   if (!is_open_for("document_view", this_player()->query_name())) {
      add_failed_mess("You cannot view documents on $I.\n",
                      ({ this_object() }));
      return 0;
   }
   ret = query_document_readable(id);
   if (!ret) {
      add_failed_mess("Cannot find the document " + id + " on $I.\n",
                      ({ this_object() }));
      return 0;
   }
   info = _documents[id];
   ret = "Document #" + id + " " + info->title + " [" + info->added_by +
             "] - " + ctime(info->time_added)[4..9] + " " +
             ctime(info->time_added)[<4..] + "\n" + ret;
   write("$P$Document " + id + "$P$" + ret);
   add_succeeded_mess(({ "", "$N reads a document from $I.\n" }),
                      ({ this_object() }));
   return 1;
}
int do_add_document(string title, int type) {
   if (!is_open_for("document_add", this_player()->query_name())) {
      add_failed_mess("You cannot add documents to $I.\n",
                      ({ this_object() }));
      return 0;
   }
   this_player()->do_edit("", "finish_edit", this_object(), 0,
                          ({ title, type }));
   return 1;
}
void finish_edit(string str, mixed* args) {
   string title;
   int type;
   title = args[0];
   type = args[1];
   if (!str || str == "") {
      write("Abandoning adding the document.\n");
      return ;
   }
   add_document(title, str, this_player()->query_cap_name(), type);
   write("Added the document into the collection.\n");
}
int do_delete_document(string id) {
   if (!is_open_for("document_delete", this_player()->query_name())) {
      add_failed_mess("You cannot delete documents from $I.\n",
                      ({ this_object() }));
      return 0;
   }
   if (!is_document(id)) {
      add_failed_mess("The document " + id + " does not exist in $I.\n",
                      ({ this_object() }));
      return 0;
   }
   delete_document(id);
   add_succeeded_mess("$N delete$s a document from $I.\n", ({ this_object() }));
   return 1;
}
mapping query_dynamic_auto_load(mapping map) {
   if (file_name(this_object()) != "/std/room/furniture/inherit/document_handler" && map) {
      add_auto_load_value(map, TAG, "documents", _documents);
      add_auto_load_value(map, TAG, "doc id", _next_doc_id);
      return map;
   }
}
void init_dynamic_arg(mapping map) {
   if (file_name(this_object()) != "/std/room/furniture/inherit/document_handler" && map) {
      _documents = query_auto_load_value(map, TAG, "documents");
      if (!_documents) {
         _documents = ([ ]);
      }
      _next_doc_id = query_auto_load_value(map, TAG, "doc id");
   }
}
void init_object() {
   add_command("list", "documents [from] <direct:object>", (: do_list() :));
   add_command("view", "document <string'id'> [from] <direct:object>",
                (: do_display($4[0]) :));
   add_command("add", "documents {html|plain} called <string:quoted'title'> to <direct:object>",
               (: do_add_document($4[1], ($4[0] == "html"?DOCUMENT_HTML:DOCUMENT_PLAIN)) :));
   add_command("delete", "document <string'id'> [from] <direct:object>",
                (: do_delete_document($4[0]) :));
}
void init_room() {
   add_command("list", "[documents]", (: do_list() :));
   add_command("view", "[document] <string'id'>",
                (: do_display($4[0]) :));
   add_command("add", "[document] {html|plain} called <string:quoted'title'>",
               (: do_add_document($4[1], ($4[0] == "html"?DOCUMENT_HTML:DOCUMENT_PLAIN)) :));
   add_command("delete", "[document] <string'id'>",
                (: do_delete_document($4[0]) :));
}

==================================================
FILE: room/furniture/inherit/furniture_base.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <housing.h>
#include <room/placement.h>
void add_property(string name, mixed type);
mixed query_property(string name);
string one_short();
int query_light_needs_inform();
void inform_of_light_level_change(object ob);
private nosave mapping _allowed_room_verbs;
private nosave string *_allowed_positions;
private nosave string _bonded;
void create() {
  _allowed_positions = ({ });
  if (base_name(this_object()) + ".c" != __FILE__) {
    if ( !query_property( "shop type" ) ) {
      add_property( "shop type", "furniture" );
    }
    this_object()->set_max_cond(100000);
    this_object()->set_cond(100000);
  }
  if(clonep(this_object()) &&
     base_name(this_object())[0..14] != "/obj/furnitures" &&
     base_name(this_object())[0..2] != "/w/" &&
     strsrch (base_name(this_object()), "_dev") == -1 &&
     strsrch (base_name(this_object()), "_pt") == -1) {
    call_out("move", 2, "/room/void");
  }
}
int query_furniture() {
   return 1;
}
void set_allowed_positions(string *positions) {
   _allowed_positions = positions;
}
void remove_allowed_positions( string *positions ){
  _allowed_positions -= positions;
}
string* query_allowed_positions() {
   return _allowed_positions;
}
void set_allowed_room_verbs( mapping allowed ) {
  _allowed_room_verbs = allowed;
}
mapping query_allowed_room_verbs() {
   return _allowed_room_verbs;
}
string query_position_string(string position_type) {
  if(member_array(position_type, _allowed_positions) != -1) {
    return one_short();
  }
  return 0;
}
void set_bonded(string person) {
   _bonded = person;
}
string query_bonded() {
   return _bonded;
}
string query_owner() {
   return _bonded;
}
int is_allowed_to_mess(object player) {
  mixed *stuff;
  string occupier;
  if(environment() && !function_exists("query_owner", environment()))
    return 1;
  if(player->query_creator())
    return 1;
  if(player->query_caster())
    player = find_player(player->query_caster());
  if(player->query_owner())
    player = player->query_owner();
  if (player && player->query_name() == _bonded)
    return 1;
  stuff = this_object()->query_property("dropped");
  if(player && sizeof(stuff) && stuff[0] == player->query_name())
    return 1;
  if(player && environment()) {
    if(environment()->test_occupier(player->query_name()))
      return 1;
    if(environment()->query_owner() == "For Sale" ||
       environment()->query_owner() == "Under Offer")
      return 1;
    occupier = HOUSING->query_owner(base_name(environment()));
    if(pk_check(player, occupier, 1))
      return 0;
  }
  return (!_bonded);
}
int move_check(object dest) {
  if (living(dest)) {
    if (!is_allowed_to_mess(dest)) {
       return 0;
    }
  } else if (this_player() && environment()) {
    if (!(living(environment()) && dest == environment(environment()))) {
       if (!is_allowed_to_mess(this_player())) {
          return 0;
       }
    }
  }
  return 1;
}
string query_placement_verb() {
   return query_property(PLACEMENT_CURRENT_ROOM_VERB);
}
string query_placement_other() {
   return query_property(PLACEMENT_CURRENT_ROOM_OTHER);
}
string query_placement_position() {
   return query_property(PLACEMENT_CURRENT_ROOM_POSITION);
}
int query_placement_immovable() {
   return query_property(PLACEMENT_IMMOVABLE);
}
int is_placed() {
   return query_placement_position() &&
     stringp(query_placement_verb()) &&
     stringp(query_placement_other());
}
void set_placement_verb(string verb) {
   add_property(PLACEMENT_CURRENT_ROOM_VERB, verb);
}
void set_placement_other(string other) {
   add_property(PLACEMENT_CURRENT_ROOM_OTHER, other);
}
void set_placement_position(string position) {
   add_property(PLACEMENT_CURRENT_ROOM_POSITION, position);
}
int set_placement_immovable() {
   return query_property(PLACEMENT_IMMOVABLE);
}

==================================================
FILE: room/furniture/inherit/one_armed_bandit_inherit.c
==================================================

#include <money.h>
int do_slot();
int do_pull_lever();
int do_read_dial();
int set_coin_type( string coin );
int set_chances( int c1, int c2, int c3, int c4, int c5 );
int set_prizes( int p1, int p2, int p3, int p4, int p5, int jackpot );
int* query_prizes();
int* query_chances();
string query_coin_type();
void rollem( object player );
string my_short();
private string *animal = ({"albatross", "frog", "hippo", "turtle", "cabbage"});
private string *adject = ({"A crazy", "A dancing", "A sad", "A floopy", "A bemused",
    "A sarcastic", "A quizzical", "A startled", "A friendly", "A mindless"});
private string _coin = "Ankh-Morpork pence", _coin_short = "pence",
    _coin_pl = "Ankh-Morpork pence";
private int _busy = 0;
private int* _chances = ({1,1,1,1,1});
private int* _prizes = ({2,2,2,2,2,3});
void init(){
    this_player()->add_command( "slot", this_object(),
        _coin_short + " into <direct:object>", (: do_slot() :) );
    this_player()->add_command( "pull", this_object(),
        "lever on <direct:object>", (: do_pull_lever() :) );
    this_player()->add_command( "read", this_object(),
        "dial on <direct:object>", (: do_read_dial() :) );
}
int set_coin_type( string coin ) {
    if( member_array( coin, MONEY_HAND->query_valid_types() ) == -1 )
        return 0;
    _coin = coin;
    _coin_short = MONEY_HAND->query_aliases_for( coin )[0];
    _coin_pl = MONEY_HAND->query_main_plural_for( coin );
    return 1;
}
int set_chances( int c1, int c2, int c3, int c4, int c5 ) {
    if( !( c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c5 > 0 ) )
        return 0;
    _chances = ({ c1, ( c1 + c2 ), ( c1 + c2 + c3 ), ( c1 + c2 + c3 + c4 ),
        ( c1 + c2 + c3 + c4 + c5 ) });
    return 1;
}
int set_prizes( int p1, int p2, int p3, int p4, int p5, int jackpot ) {
    if( !( p1 > 1 && p2 > 1 && p3 > 1 && p4 > 1 && p5 > 1 && jackpot > 1 ) ||
        ( jackpot <= p1 || jackpot <= p2 || jackpot <= p3 ||
        jackpot <= p4 || jackpot <= p5 ) )
        return 0;
    _prizes = ({p1, p2, p3, p4, p5, jackpot});
    return 1;
}
int do_slot() {
    if( member_array( _coin, this_player()->query_money_array() ) == -1 ) {
        this_player()->add_failed_mess( this_object(),
            "You need " + add_a( _coin ) + " to play.\n", ({ }) );
        return 0;
    }
    if( _busy == 1 ) {
        this_player()->add_failed_mess( this_object(),
            "There is already a coin inserted.\n", ({ }) );
        return 0;
    }
    if( _busy == 2 ) {
        this_player()->add_failed_mess( this_object(),
            "The wheels of $D are still spinning.\n", ({ }) );
        return 0;
    }
    this_player()->adjust_money( -1, _coin );
    this_object()->adjust_money( 1 );
    _busy = 1;
    this_player()->add_succeeded_mess( this_object(),
        "$N insert$s " + add_a( _coin_short ) + " into $D.\n", ({ }) );
    return 1;
}
int do_pull_lever() {
    if( _busy == 0 ) {
        this_player()->add_failed_mess( this_object(),
            "You must put a coin in the slot before you can play.\n", ({ }) );
        return 0;
    }
    if( _busy == 2 ) {
        this_player()->add_failed_mess( this_object(),
            "The wheels of $D are already spinning.\n", ({ }) );
        return 0;
    }
    this_player()->add_succeeded_mess( this_object(),
        ({"You pull the lever.  The pictures behind the windows blur... one by "
             "one they are replaced by a new picture that appears with a sharp "
             "click.\n",
        "$N pull$s the lever on $D and the machine whirs softly.  The sound is "
        "cut short by three sharp clicks.\n"
        }), ({ }) );
    call_out( "rollem", 0, this_player() );
    _busy = 2;
    return 1;
}
void rollem( object player ) {
    int a1, a2, a3, c;
    int adj1 = random( 10 ),
        adj2 = random( 10 ),
        adj3 = random( 10 );
    c = random( _chances[4] );
    if( c < _chances[0] )
        a1 = 0;
    else if( c < _chances[1] )
        a1 = 1;
    else if( c < _chances[2] )
        a1 = 2;
    else if( c < _chances[3] )
        a1 = 3;
    else
        a1 = 4;
    c = random( _chances[4] );
    if( c < _chances[0] )
        a2 = 0;
    else if( c < _chances[1] )
        a2 = 1;
    else if( c < _chances[2] )
        a2 = 2;
    else if( c < _chances[3] )
        a2 = 3;
    else
        a2 = 4;
    c = random( _chances[4] );
    if( c < _chances[0] )
        a3 = 0;
    else if( c < _chances[1] )
        a3 = 1;
    else if( c < _chances[2] )
        a3 = 2;
    else if( c < _chances[3] )
        a3 = 3;
    else
        a3 = 4;
    tell_object( player,
        "The windows now show these pictures :\n\n"
         "        " + adject[ adj1 ] + " " + animal[ a1 ] +
         "    " + adject[ adj2 ] + " " + animal[ a2 ] +
         "    " + adject[ adj3 ] + " "+animal[ a3 ] + "\n\n" );
    if( a1 == a2 && a1 == a3 ) {
        if( adj1 == adj2 && adj1 == adj3 ) {
            tell_object( player,
                "WOW!!  A triple " + adject[ adj1 ] + " " + animal[ a1 ] +
                "!!  You really hit the jackpot this time!\n\n"
                "Whistles and bells start sounding like crazy, the whole " +
                this_object()->short() +  " glows with flashing lights.  There "
                "is a loud tingling as " + _prizes[5] + " " +
                MONEY_HAND->query_plural_for( _coin ) + " drop into the tray "
                "of " + my_short() + ".  Slightly stunned you quickly scoop "
                "it up and cackle with delight.\n" );
            tell_room( environment( this_object() ),
                "Whistles and bells start sounding and " + my_short() +
                " starts to flash with coloured lights.  Someone must have "
                "won the jackpot...lucky buggers.  As you watch some coins "
                "drop into the tray at the bottom of " + my_short() + ", " +
                player->one_short() + " snatches it up and cackles with "
                "delight.\n", ({player}) );
            player->adjust_money( _prizes[5] ,_coin );
            this_object()->adjust_money( -(_prizes[ 5 ]) );
            _busy = 0;
            return;
        }
        tell_object( player,
            "Congratulations!  You scored a triple " + animal[ a1 ] + "!\n" );
        player->adjust_money( _prizes[ a1 ], _coin );
        tell_object( player,
            _prizes[ a1 ]+ " " + MONEY_HAND->query_plural_for( _coin ) +
            " fall into the tray at the bottom of " + my_short() + ".  You "
            "quickly scoop them up before anyone else can snaffle them.\n" );
        tell_room( environment( this_object() ),
            player->one_short() + " deftly scoops some coins from the tray at "
            "the bottom of " + my_short() + ".\n", ({player}) );
        this_object()->adjust_money( -(_prizes[ a1 ]) );
        _busy = 0;
        return;
    }
    tell_object( player,
        "You didn't win.  Why not have another go and attempt to recoup your "
        "losses?\n" );
    _busy = 0;
}
int* query_chances() {
    int* tmp = ({ });
    tmp += ({ _chances[0] });
    tmp += ({ _chances[1] - _chances[0] });
    tmp += ({ _chances[2] - _chances[1] });
    tmp += ({ _chances[3] - _chances[2] });
    tmp += ({ _chances[4] - _chances[3] });
    return tmp;
}
int* query_prizes() {
    return _prizes;
}
string query_coin_type() {
    return _coin;
}
string my_short() {
    return this_object()->the_short();
}
int do_read_dial() {
    string tmp =
        "Stake        : 1 " + _coin_pl + "\n"
        "3x Albatross : " + _prizes[0] + " " + _coin_pl + "\n"
        "3x Frog      : " + _prizes[1] + " " + _coin_pl + "\n"
        "3x Hippo     : " + _prizes[2] + " " + _coin_pl + "\n"
        "3x Turtle    : " + _prizes[3] + " " + _coin_pl + "\n"
        "3x Cabbage   : " + _prizes[4] + " " + _coin_pl + "\n"
        "JACKPOT      : " + _prizes[5] + " " + _coin_pl + "\n";
    this_player()->add_succeeded_mess( this_object(),
        ({tmp, "$N read$s the dial on $D.\n"}), ({ }) );
    return 1;
}

==================================================
FILE: room/furniture/games/card_base.c
==================================================

#include <room/card_base.h>
#define CARD_NUM_MAX CARD_NUMBER_KING
int is_card_red(class playing_card card);
class playing_card* make_deck(int number_of_decks,
                              int number_of_jokers) {
   class playing_card* deck;
   class playing_card card;
   int i;
   int suit;
   int num;
   deck = ({ });
   for (i = 0; i < number_of_decks; i++) {
      for (suit = CARD_SUIT_HEARTS; suit <= CARD_SUIT_SPADES; suit++) {
         for (num = 1; num <= CARD_NUM_MAX; num++) {
            card = new(class playing_card);
            card->suit = suit;
            card->number = num;
            deck += ({ card });
         }
      }
   }
   for (i = 0; i < number_of_jokers; i++) {
      card = new(class playing_card);
      card->suit = CARD_SUIT_JOKER;
      deck += ({ card });
   }
   return deck;
}
class playing_card* shuffle_deck(class playing_card* deck) {
   class playing_card* new_deck;
   int pos;
   int i;
   for (i = 0; i < 2; i++) {
      new_deck = ({ });
      while (sizeof(deck)) {
         pos = random(sizeof(deck));
         new_deck += deck[pos..pos];
         deck = deck[0..pos - 1] + deck[pos+1..];
      }
      deck = new_deck;
   }
   return deck;
}
string query_suit_letter(int suit) {
   switch (suit) {
   case CARD_SUIT_SPADES :
      return "S";
      break;
   case CARD_SUIT_HEARTS :
      return "H";
      break;
   case CARD_SUIT_DIAMONDS :
      return "D";
      break;
   case CARD_SUIT_CLUBS :
      return "C";
      break;
   case CARD_SUIT_JOKER :
      return "J";
   }
}
string query_card_string(class playing_card card) {
   string ret;
   string colour;
   if (card->suit == CARD_SUIT_JOKER) {
      return "*J*";
   }
   ret = query_suit_letter(card->suit) + "%^RESET%^";
   if (is_card_red(card)) {
      colour = "%^BOLD%^%^RED%^";
   } else {
      colour = "%^BOLD%^";
   }
   if (card->number > 10 || card->number == CARD_NUMBER_ACE) {
      switch (card->number) {
      case CARD_NUMBER_JACK :
         ret = colour + "J " + ret;
         break;
      case CARD_NUMBER_QUEEN :
         ret = colour + "Q " + ret;
         break;
      case CARD_NUMBER_KING :
         ret = colour + "K " + ret;
         break;
      case CARD_NUMBER_ACE :
         ret = colour + "A " + ret;
         break;
      }
   } else {
      ret = sprintf("%s%-2d%s", colour, card->number, ret);
   }
   return ret + "%^RESET%^";
}
int is_card_red(class playing_card card) {
   return card->suit == CARD_SUIT_HEARTS || card->suit == CARD_SUIT_DIAMONDS;
}
int is_card_black(class playing_card card) {
   return card->suit == CARD_SUIT_SPADES || card->suit == CARD_SUIT_CLUBS;
}
int is_card_joker(class playing_card card) {
   return card->suit == CARD_SUIT_JOKER;
}
string* query_card_three(class playing_card card) {
   string* lines;
   if (is_card_red(card)) {
      lines = allocate(3, "%^BOLD%^%^RED%^");
   } else {
      lines = allocate(3, "%^BOLD%^");
   }
   switch (card->suit) {
   case CARD_SUIT_HEARTS :
      lines[0] += "H  %^RESET%^";
      lines[2] += "  H%^RESET%^";
      break;
   case CARD_SUIT_DIAMONDS :
      lines[0] += "D  %^RESET%^";
      lines[2] += "  D%^RESET%^";
      break;
   case CARD_SUIT_CLUBS :
      lines[0] += "C  %^RESET%^";
      lines[2] += "  C%^RESET%^";
      break;
   case CARD_SUIT_SPADES :
      lines[0] += "S  %^RESET%^";
      lines[2] += "  S%^RESET%^";
      break;
   case CARD_SUIT_JOKER :
      lines[0] += "J *%^RESET%^";
      lines[1] += " O %^RESET%^";
      lines[2] += "* K%^RESET%^";
      return lines;
   }
   if (card->number <= 10 && card->number != CARD_NUMBER_ACE) {
      if (card->number == 10) {
         lines[1] += " 10%^RESET%^";
      } else {
         lines[1] += " " + card->number + " %^RESET%^";
      }
   } else {
      switch (card->number) {
      case CARD_NUMBER_KING :
         lines[1] += " K %^RESET%^";
         break;
      case CARD_NUMBER_QUEEN :
         lines[1] += " Q %^RESET%^";
         break;
      case CARD_NUMBER_JACK :
         lines[1] += " J %^RESET%^";
         break;
      case CARD_NUMBER_ACE :
         lines[1] += " A %^RESET%^";
         break;
      }
   }
   return lines;
}
string* query_card_two(class playing_card card) {
   string* lines;
   lines = allocate(2);
   switch (card->suit) {
   case CARD_SUIT_HEARTS :
      lines[0] = "H ";
      break;
   case CARD_SUIT_DIAMONDS :
      lines[0] = "D ";
      break;
   case CARD_SUIT_CLUBS :
      lines[0] = "C ";
      break;
   case CARD_SUIT_SPADES :
      lines[0] = "S ";
      break;
   case CARD_SUIT_JOKER :
      lines[0] = "J*";
      lines[1] = "*O";
      return lines;
   }
   if (card->number <= 10 && card->number != CARD_NUMBER_ACE) {
      lines[1] = sprintf("%2d", card->number);
   } else {
      switch (card->number) {
      case CARD_NUMBER_KING :
         lines[1] = " K";
         break;
      case CARD_NUMBER_QUEEN :
         lines[1] = " Q";
         break;
      case CARD_NUMBER_JACK :
         lines[1] = " J";
         break;
      case CARD_NUMBER_ACE :
         lines[1] = " A";
         break;
      }
   }
   return lines;
}
string query_hand_string(class playing_card* hand, int flags, int cols) {
   string hand_str;
   int i;
   int j;
   int width;
   int start_pos;
   string top;
   string line;
   string start;
   string end;
   string start_space;
   string end_space;
   mixed card_str;
   if (!sizeof(hand)) {
      return "No cards\n";
   }
   hand_str = "";
   if (!(flags & CARD_HAND_NO_ADORNMENTS)) {
      if (flags & CARD_HAND_THREE ||
          flags & CARD_HAND_SINGLE) {
         top = "+---+";
         width = 5;
      } else {
         top = "+--+";
         width = 4;
      }
      start = "|";
      end = "|";
      start_space = " ";
      end_space = " ";
   } else {
      top = 0;
      line = "";
      start = " ";
      end = " ";
      start_space = " ";
      end_space = " ";
      if (flags & CARD_HAND_THREE ||
          flags & CARD_HAND_SINGLE) {
         width = 3;
      } else {
         width = 2;
      }
   }
   start_pos = 0;
   if (flags & CARD_HAND_THREE) {
      card_str = map(hand, (: query_card_three :));
   } else if (flags & CARD_HAND_SINGLE) {
      card_str = map(hand, (: ({ query_card_string($1) }) :));
   } else {
      card_str = map(hand, (: query_card_two :));
   }
   while (start_pos < sizeof(hand)) {
      if (top) {
         line = "";
         for (i = 0; i + start_pos < sizeof(hand) && (i + 1) * width < cols; i++) {
            line += top;
         }
         line += "\n";
      }
      if (flags & CARD_HAND_LETTERS) {
         for (i = 0; i + start_pos < sizeof(hand) && (i + 1) * width < cols; i++) {
            if (flags & CARD_HAND_THREE) {
               hand_str += start_space + sprintf(" %c ", 'A' + i + start_pos) + end_space;
            } else {
               hand_str += start_space + sprintf("%c ", 'A' + i + start_pos) + end_space;
            }
         }
      }
      hand_str += "\n" + line;
      for (j = 0; j < sizeof(card_str[0]); j++) {
         for (i = 0; i + start_pos < sizeof(card_str) && (i + 1) * width < cols; i++) {
            hand_str += start + (card_str[i + start_pos][j]) + end;
         }
         hand_str += "\n";
      }
      hand_str += line;
      start_pos += cols / width;
   }
   return hand_str;
}
private int compare_cards(class playing_card card1, class playing_card card2,
                          int flags) {
   if (card1->suit == card2->suit ||
       (flags & 2)) {
      if (!(flags & 1)) {
         return card1->number - card2->number;
      }
      if (card1->number == CARD_NUMBER_ACE) {
         return 1;
      }
      if (card2->number == CARD_NUMBER_ACE) {
         return -1;
      }
      return card1->number - card2->number;
   }
   return card1->suit - card2->suit;
}
class playing_card* sort_cards(class playing_card* deck, int flags) {
   return sort_array(deck,
                (: compare_cards($1, $2, $(flags)) :));
}

==================================================
FILE: room/furniture/games/multiplayer_base.c
==================================================

private inherit "/std/basic/auto_load";
#define LOAD_TAG "multiplayer base"
class player_info {
   int number;
   string cap_name;
   string name;
   mixed data;
}
private mapping _players;
private string _winner;
private string* _ids_when_started;
private string _current_player;
private int _minimum_needed;
private int _maximum_allowed;
private int _can_join_as_new;
private int _game_started;
string* query_currently_playing_ids();
void delete_gone_players();
string find_player_id_of_person(object person);
void create() {
   _players = ([ ]);
   _ids_when_started = ({ });
}
void reset_game() {
}
int start_game() {
   delete_gone_players();
   if (sizeof(query_currently_playing_ids()) < _minimum_needed) {
      return 0;
   }
   _winner = 0;
   _game_started = 1;
   _ids_when_started = query_currently_playing_ids();
   _current_player = _ids_when_started[random(sizeof(_ids_when_started))];
   return 1;
}
void finish_game(string winner) {
   _winner = winner;
   _game_started = 0;
}
string query_winner() {
   return _winner;
}
int is_game_started() {
   return _game_started;
}
int can_join_as_new_player() {
   return _can_join_as_new;
}
void set_can_join_as_new_player(int join) {
   _can_join_as_new = join;
}
int is_person_playing(string id) {
   if (_players[id]->name) {
      if (find_player(_players[id]->name) &&
          is_in_me_or_environment(this_object(),
                                  find_player(_players[id]->name)) &&
          interactive(find_player(_players[id]->name))) {
         return 1;
      }
   }
   return 0;
}
int is_playing(object ob) {
   string id;
   id = find_player_id_of_person(ob);
   return id != 0;
}
int is_current_player(object ob) {
   string id;
   id = find_player_id_of_person(ob);
   return id == _current_player;
}
int add_person_to_game(string id, object person) {
   class player_info info;
   if (is_person_playing(id)) {
      return 0;
   }
   info = _players[id];
   info->name = person->query_name();
   info->cap_name = person->query_cap_name();
   return 1;
}
int remove_person_object_from_game(object person) {
   class player_info info;
   string id;
   foreach (id, info in _players) {
      if (find_player(info->name) == person) {
         info->name = 0;
         info->cap_name = 0;
         return 1;
      }
   }
   return 0;
}
int remove_person_id_from_game(string id) {
   if (_players[id]->name) {
      _players[id]->name = 0;
      return 1;
   }
   return 0;
}
void randomise_player_numbers() {
   string* ids;
   int num;
   int pos;
   ids = keys(_players);
   num = 0;
   while (sizeof(ids)) {
      pos = random(sizeof(ids));
      _players[ids[pos]]->number = num;
      ids = ids[0..pos-1] + ids[pos+1..];
      num++;
   }
}
void add_player_id_type(string id, int number) {
   _players[id] = new(class player_info);
   _players[id]->number = number;
}
void remove_player_id_type(string id) {
   map_delete(_players, id);
}
class player_info find_player_info_from_number(int num) {
   class player_info info;
   string id;
   foreach (id, info in _players) {
      if (info->number == num) {
         return info;
      }
   }
   return 0;
}
string find_player_id_from_number(int num) {
   class player_info info;
   string id;
   foreach (id, info in _players) {
      if (info->number == num) {
         return id;
      }
   }
   return 0;
}
string* query_player_ids() {
   return keys(_players);
}
string* query_currently_playing_ids() {
   return filter(keys(_players), (: is_person_playing($1) :));
}
string* query_started_player_ids() {
   return _ids_when_started;
}
string query_player_cap_name(string id) {
   if (_players[id] && _players[id]->name) {
      return _players[id]->cap_name;
   }
   return "No one";
}
object query_player_object(string id) {
   return find_player(_players[id]->name);
}
string query_player_the_short(string id) {
   object ob;
   if (_players[id]->name) {
      ob = query_player_object(id);
      if (ob) {
         return ob->the_short();
      }
   }
   return "No one";
}
string query_player_poss_short(string id) {
   object ob;
   if (_players[id]->name) {
      ob = query_player_object(id);
      if (ob) {
         return ob->poss_short();
      }
   }
   return "No one";
}
void delete_gone_players() {
   string id;
   class player_info info;
   foreach (id, info in _players) {
      if (info->name) {
         if (!find_player(info->name) ||
             !is_in_me_or_environment(this_object(), find_player(info->name))) {
            info->name = 0;
         }
      }
   }
}
void set_minimum_needed(int minimun) {
   _minimum_needed = minimun;
}
int can_start_game() {
   if (sizeof(query_currently_playing_ids()) > _minimum_needed) {
      return 1;
   }
   return 0;
}
string find_next_player(string id) {
   class player_info info;
   int start;
   int cur;
   string new_id;
   if (!id) {
      id = _current_player;
   }
   start = _players[id]->number;
   cur = start;
   do {
      cur = (cur + 1) % sizeof(_players);
      new_id = find_player_id_from_number(cur);
      info = _players[new_id];
   } while (((_can_join_as_new && !info->name) ||
            (!_can_join_as_new &&
                member_array(new_id, _ids_when_started) == -1)) &&
            cur != start);
   return new_id;
}
string find_previous_player(string id) {
   class player_info info;
   int start;
   string new_id;
   int cur;
   if (!id) {
      id = _current_player;
   }
   start = _players[id]->number;
   cur = start;
   do {
      cur = (cur - 1 + sizeof(_players)) % sizeof(_players);
      new_id = find_player_id_from_number(cur);
      info = _players[new_id];
   } while (((_can_join_as_new && !info->name) ||
            (!_can_join_as_new &&
               member_array(new_id, _ids_when_started) == -1)) &&
            cur != start);
   return new_id;
}
void increment_current_player() {
   _current_player = find_next_player(_current_player);
}
string find_player_id_of_person(object person) {
   class player_info info;
   string id;
   foreach (id, info in _players) {
      if (find_player(info->name) == person) {
         return id;
      }
   }
   return 0;
}
string query_current_player() {
   if (!_current_player) {
      _current_player = find_player_id_from_number(0);
   }
   return _current_player;
}
string set_current_player(string id) {
   _current_player = id;
}
void tell_player(string id, string message) {
   object player;
   player = find_player(_players[id]->name);
   if (player && (environment(player) == environment() ||
                  player == environment())) {
      tell_object(player, message);
   }
}
void tell_current_player(string message) {
   tell_player(_current_player, message);
}
varargs void tell_all_players(string message, string* exclude) {
   class player_info info;
   string id;
   if (!exclude) {
      exclude = ({ });
   }
   foreach (id, info in _players) {
      if (member_array(id, exclude) == -1) {
         tell_player(id, message);
      }
   }
}
mixed query_player_data(string id) {
   return _players[id]->data;
}
void set_player_data(string id, mixed data) {
   _players[id]->data = data;
}
void multiplayer_someone_joins(string id) {
}
void multiplayer_someone_resigns(string id, string name) {
}
mixed* shuffle_array(mixed *arr) {
   int i;
   int pos;
   mixed* new_arr;
   for (i = 0; i < 2; i++) {
      new_arr = ({ });
      while (sizeof(arr)) {
         pos = random(sizeof(arr));
         new_arr += arr[pos..pos];
         arr = arr[0..pos - 1] + arr[pos + 1..];
      }
      arr = new_arr;
   }
   return arr;
}
int do_join(string id) {
   if (is_person_playing(id)) {
      add_failed_mess("Someone is already playing " + id + " on $D.\n");
      return 0;
   }
   if (is_playing(this_player())) {
      add_failed_mess("You are already playing on $D.\n");
      return 0;
   }
   if (is_game_started() &&
       !can_join_as_new_player() &&
       member_array(id, query_started_player_ids()) == -1) {
      add_failed_mess("You can only take over one of the spots vacated by "
                      "someone else.\n");
      return 0;
   }
   if (add_person_to_game(id, this_player())) {
      add_succeeded_mess("$N $V as " + id + " on $D.\n");
      multiplayer_someone_joins(id);
      return 1;
   }
   add_failed_mess("Some weird error joining game on $D.\n");
   return 0;
}
int do_resign() {
   string id;
   id = find_player_id_of_person(this_player());
   if (remove_person_object_from_game(this_player())) {
      add_succeeded_mess("$N $V from the game on $D.\n");
      multiplayer_someone_resigns(id, this_player()->query_cap_name());
      if (id == query_current_player()) {
         increment_current_player();
      }
      return 1;
   }
   add_failed_mess("You are not playing on $D to resign.\n");
   return 0;
}
void init() {
   string ids;
   ids = implode(keys(_players), "|");
   add_command("join", "[game] [as] {" + ids + "} on <direct:object>",
                (: do_join($4[0]) :));
   add_command("resign", "[from] [game] on <direct:object>",
               (: do_resign() :));
}
mapping query_dynamic_auto_load(mapping map) {
   if (!map) {
      return 0;
   }
   add_auto_load_value(map, LOAD_TAG, "players", _players);
   add_auto_load_value(map, LOAD_TAG, "current player", _current_player);
   add_auto_load_value(map, LOAD_TAG, "started ids", _ids_when_started);
   add_auto_load_value(map, LOAD_TAG, "winner", _winner);
   add_auto_load_value(map, LOAD_TAG, "game started", _game_started);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   if (!map) {
      return ;
   }
   _players = query_auto_load_value(map, LOAD_TAG, "players");
   _current_player = query_auto_load_value(map, LOAD_TAG, "current player");
   _ids_when_started = query_auto_load_value(map, LOAD_TAG, "started ids");
   _winner = query_auto_load_value(map, LOAD_TAG, "winner");
   _game_started = query_auto_load_value(map, LOAD_TAG, "game started");
}

==================================================
FILE: liquids/ink.c
==================================================

int splash_func(object ob) {
  ob->add_extra_look(this_object());
  ob->add_property("splashed with", previous_object()->query_liquid_name());
  return 1;
}
int query_ink() { return 1; }
string extra_look() {
  return capitalize((string)previous_object()->query_name())+
         " has been splashed with "+
         previous_object()->query_property("splashed with");
}

==================================================
FILE: shadows/peace_shadow.c
==================================================

inherit "/std/effect_shadow";
#define GCR peacenpc->get_combat_reason()
#define GER peacenpc->get_escape_reason()
#define GFR peacenpc->get_fighting_reason()
#define GMR peacenpc->get_magic_reason()
#define GOR peacenpc->get_other_reason()
#define GRR peacenpc->get_ritual_reason()
#define GSR peacenpc->get_stealth_reason()
#define TO this_object()
#define TP this_player()
object peacenpc;
void setup_shadow(object person, object thing) {
    shadow( person, 1 );
    peacenpc=thing;
}
void dest_peace_shadow() { destruct(TO); }
void event_exit(object ob, string message, object to) {
    if (ob==peacenpc)
        dest_peace_shadow();
}
void event_move_object(mixed from, mixed to) {
    dest_peace_shadow();
}
int command_shadowed( string verb, string args ) {
    switch(verb) {
        case "attack":
        case "behead":
        case "berserk":
        case "bob":
        case "crush":
        case "disarm":
        case "fire":
        case "guard":
        case "hack":
        case "hurl":
        case "iai":
        case "impale":
        case "kill":
        case "punch":
        case "riposte":
        case "slash":
        case "throw":
        case "warcry":
            tell_object(TP, GFR);
            return 1;
        case "cast":
        case "circle":
        case "educe":
        case "forget":
        case "invoke":
        case "remember":
        case "scribe":
        case "scry":
        case "spellcheck":
        case "twist":
        case "use":
        case "zap":
            tell_object(TP, GMR);
            return 1;
        case "bodyguard":
        case "bury":
        case "drag":
        case "eye":
        case "fuel":
        case "hedgehog":
        case "judge":
        case "leatherwork":
        case "mock":
        case "tempt":
        case "scathe":
        case "vurdere":
            tell_object(TP, GOR);
            return 1;
        case "conflagrate":
        case "consecrate":
        case "decompose":
        case "ensumpf":
        case "envalise":
        case "imbue":
        case "perform":
        case "pray":
        case "pyroscipate":
        case "shroud":
        case "suffuse":
        case "ventisepelate":
            tell_object(TP, GRR);
            return 1;
        case "abscond":
        case "ambush":
        case "case":
        case "conceal":
        case "crack":
        case "disable":
        case "filch":
        case "hide":
        case "inhume":
        case "lpick":
        case "palm":
        case "peek":
        case "plant":
        case "probe":
        case "scope":
        case "shoplift":
        case "slip":
        case "snatch":
        case "sneak":
        case "steal":
        case "unhide":
            tell_object(TP, GSR);
            return 1;
        default:
            return 0;
    }
}
int run_away() {
    tell_object(TO, GER);
}

==================================================
FILE: shadows/object/basic_trap.c
==================================================

inherit "/std/effect_shadow";
int trap_lock(string type) {
  if(type != "pick")
    return 0;
  tell_object(this_player(), "Trap triggered.\n");
  return 0;
}

==================================================
FILE: shadows/object/death_ward.c
==================================================

inherit "/std/effect_shadow";
void event_death( object thing, object *killers, object killer,
      string room_mess, string killer_mess ) {
   int damage;
   object twit;
   player->event_death( thing, killers, killer, room_mess, killer_mess );
   if ( thing != (object)player->query_worn_by() )
      return;
   tell_room( environment( thing ), (string)player->the_short() +
         " explodes in a ball of flame!\n" );
   thing->remove_armour( player );
   player->move( "/room/rubbish" );
   foreach ( twit in killers ) {
      if ( environment( twit ) != environment( thing ) )
         continue;
      damage = arg();
      if ( twit == killer )
         damage *= 2;
      damage -= (int)twit->query_ac( "fire", damage );
      if ( damage > 0 )
         twit->adjust_hp( -damage );
      if ( (int)twit->query_hp() < 0 )
         twit->attack_by( player );
   }
   remove_this_effect();
}

==================================================
FILE: shadows/object/identity_hold.c
==================================================

inherit "/std/effect_shadow";
#include <move_failures.h>
private int _keep;
private string _identifier;
private string* _adjs;
private object _owner;
int query_keep() { return _keep; }
void set_keep_value(int keep) { _keep = keep; }
void set_keep() { _keep = 1; }
void reset_keep() {
   _keep = 0;
   if (!_identifier)
      remove_this_effect();
}
string query_identifier() { return _identifier; }
string query_full_identifier() {
    string tmp;
    tmp = "";
    if ( sizeof( _adjs ) ) {
        tmp += implode( _adjs, " " ) + " ";
    }
    if ( _identifier ) {
       tmp += _identifier;
    }
    if ( strlen( tmp ) > 0 ) {
       return tmp;
    }
    return 0;
}
void set_identifier( string word ) {
   string* bits;
   if (word) {
      bits = explode(word, " ");
      _identifier = bits[<1];
      _adjs = bits[0..<2];
   } else {
      _identifier = 0;
      _adjs = ({ });
      if (!_keep)
         remove_this_effect();
   }
}
void set_identity_hold_owner(object ob) {
   _owner = ob;
}
object query_identity_hold_owner() {
   return _owner;
}
string *parse_command_id_list() {
   string *words;
   words = (string *)player->parse_command_id_list();
   if ( ( this_player() == _owner ) && stringp( _identifier ) &&
         !sizeof( filter_array( previous_object( -1 ),
         (: $1 && $1->ignore_identifier() :) ) ) ) {
      words += ({ _identifier });
   }
   return words;
}
string *parse_command_adjectiv_id_list() {
   string *words;
   words = (string *)player->parse_command_adjectiv_id_list();
   if ( ( this_player() == _owner ) && pointerp( _adjs ) &&
         !sizeof( filter_array( previous_object( -1 ),
         (: $1->ignore_identifier() :) ) ) ) {
      words += _adjs;
   }
   return words;
}
private void check_move_stuff() {
   object ob;
   ob = environment(player);
   while (ob &&
          ob != _owner) {
      ob = environment(ob);
   }
   if (ob != _owner) {
      remove_this_effect();
   }
}
varargs int move( mixed dest, string messin, string messout ) {
   int flag;
   flag = player->move( dest, messin, messout );
   if ( flag == MOVE_OK &&
        objectp( dest ) ) {
      call_out((: check_move_stuff :), 2);
   }
   return flag;
}

==================================================
FILE: shadows/object/newbie_shoes.c
==================================================

#include <move_failures.h>
#include "path.h"
inherit "/std/effect_shadow";
int query_orthopaedic_shoes() { return 1; }
string query_msgin()
{
return "$N stagger$s clumsily from $F.";
}
string query_msgout()
{
return "$N stagger$s $T clumsily.";
}
int move(mixed dest, string inmsg, string outmsg)
{
  int ret;
  ret = player->move(dest, inmsg, outmsg);
  if (ret == MOVE_OK) {
    tell_object( player, "You wince as spikes seem to drive themselves "
      "into the balls of your feet, but you get there eventually.\n" );
  }
  return ret;
}
int test_for_effect( object thing ) {
   return member_array( EFFECTS +"newbie_shoes",
      (string *)thing->query_wear_effects() ) != -1;
}
void taken_off(object what, string eff)
{
  if (eff != EFFECTS + "newbie_shoes")
    player->taken_off(what, eff);
  else {
    remove_this_effect();
  }
}

==================================================
FILE: shadows/object/no_save.c
==================================================

inherit "/std/effect_shadow";
mixed query_auto_load() {
   return 0;
}
mixed query_dynamic_auto_load() {
   return 0;
}
mixed query_static_auto_load() {
   return 0;
}

==================================================
FILE: shadows/object/owned_weapon.c
==================================================

inherit "/std/effect_shadow";
mixed set_holder( object thing, int pos ) {
   this_object()->remove_hide_invis( "concealed" );
   if ( objectp( thing ) )
      if ( !thing->query_corpse() &&
            ( (string)thing->query_name() != arg() ) )
         return 0;
   return (mixed)player->set_holder( thing, pos );
}
string query_owner(){
   return (string) arg();
}

==================================================
FILE: shadows/object/swim_fins.c
==================================================

inherit "/std/effect_shadow";
int query_skill_bonus(string skill, int true) {
  if ((skill != "other.movement.swimming") || true)
    return player->query_skill_bonus(skill);
  return player->query_skill_bonus(skill)+50;
}

==================================================
FILE: shadows/object/talker.c
==================================================

#include "path.h"
#include <talker.h>
#include <network.h>
#include <term.h>
#include <playtesters.h>
#include <language.h>
#include <cmds/options.h>
#define EMOTE_ENABLED 1
#define BEEP sprintf("%c",7)
#define CTRL sprintf("%c", 13)
inherit "/std/effect_shadow";
int do_talker_control(mixed *args, string pattern);
int do_chat(string message, string pattern, string verb);
int handle_status_command(string mode, class talker_args args);
int handle_verbose_command(string mode, class talker_args args);
int handle_history_command(string channel, class talker_args args);
int handle_colour_list(mixed *colour_args, class talker_args args);
int handle_colour_command(string channel, string new_colour, class talker_args args);
int handle_colour_on_off_command( string str_status, class talker_args args);
int handle_colour_toggle_command( class talker_args args);
int handle_echo_command( string mode, class talker_args args);
void init() {
  mixed args;
  object where;
  string channel;
  where = environment(player);
#ifdef DEBUG
  tell_creator("taffyd", "%O, %O, %O.\n", player, this_player(), where);
#endif
  if( !where )
    return;
  if (!living(where)) {
    player->init();
    return;
  }
  args = arg();
  if (!classp(args)) {
    args = new(class talker_args, status : 0, channels : ({ "one" }),
               verbose : 1, local_echo : 0, colour : 0 );
    set_arg(args);
  }
  where->add_command("talker", player,
                     ({ON_PATTERN,
                         VERBOSE_PATTERN,
                         CHANNEL_PATTERN,
                         DELETE_CHANNEL_PATTERN,
                         HISTORY_PATTERN,
                         HISTORY_CHANNEL_PATTERN,
                         LIST_PATTERN,
                         LIST_CHANNEL_PATTERN,
                         LIST_CHANNEL_PATTERN_BRIEF,
                         SET_COLOUR_PATTERN,
                         COLOUR_ON_OFF_PATTERN,
                         COLOUR_LIST,
                         TOGGLE_COLOUR_PATTERN,
                         NEW_CHANNEL_PATTERN,
                         ECHO_PATTERN,
                         "delete <string'channel'> from <direct:object'talker'>",
                         "help" }),
                     (: do_talker_control($4, $5) :) );
  where->add_command("chat", player,
                     ({ "<string'message'>" }),
                     (: do_chat($4[0], $5, $6) :) );
#ifdef EMOTE_ENABLED
  where->add_command("chat:", player,
                     ({ "<string'message'>" }),
                     (: do_chat(":" + $4[0], $5, $6) :) );
#endif
  if ( !( EFFECTS + "talker" )->valid( args->channels, where ) ) {
    args->channels = ({ "one" });
    set_arg(args);
  }
  foreach (channel in args->channels) {
#ifdef DEBUG
    tell_creator("taffyd", "Adding channel. %O.\n", channel);
#endif
    where->add_command(lower_case(channel), player,
                       "<string'message'>", (: do_chat($4[0], $5, $6) :) );
#ifdef EMOTE_ENABLED
    where->add_command( lower_case(channel) + ":", player,
                        "<string'message'>",
                        (: do_chat(":" + $4[0], $5, $6) :) );
#endif
  }
  player->init();
}
object query_player() {
  if(player && environment(player) && living(environment(player)))
    return environment(player);
  return 0;
}
int do_talker_control(mixed *args, string pattern) {
  class talker_args t_args;
  int position;
  string full_name;
#ifdef DEBUG
  tell_creator("taffyd", "Args to talker control is %O. Pattern is %O.\n",
               args, pattern);
#endif
  t_args = arg();
  switch (pattern) {
  case ON_PATTERN:
    return handle_status_command(args[0], t_args);
  case VERBOSE_PATTERN:
    return handle_verbose_command(args[0], t_args);
  case CHANNEL_PATTERN:
    if ( !t_args->status ) {
      tell_object(this_player(), "The eyes are asleep.\n");
      return 1;
    }
    tell_object(this_player(), "You may use the following channels:\n" +
                (string)( EFFECTS +"talker" )->channels() +
                "You are on channel(s) " +
                query_multiple_short( t_args->channels ) + ".\n" );
    return 1;
    break;
  case ECHO_PATTERN:
    return handle_echo_command( args[0], t_args );
  case "delete <string'channel'> from <direct:object'talker'>":
    add_succeeded_mess( ({ "", "" }) );
  case DELETE_CHANNEL_PATTERN:
    if ( !t_args->status ) {
      tell_object(this_player(),  "The eyes are asleep.\n");
      return 1;
    }
    full_name = (EFFECTS + "talker")->normalise_name( args[ 0 ] );
    if ( !(EFFECTS +"talker")->valid( full_name ) ) {
      tell_object(this_player(), "The eyes are not aware of that "
                  "channel.\n");
      return 1;
    }
    position = member_array(full_name, t_args->channels);
    if (position == -1) {
      tell_object(this_player(), "The eyes are not listening to "
                  "that channel.\n");
      return 1;
    }
    if (sizeof(t_args->channels) > 1) {
      t_args->channels = t_args->channels[0..position-1] +
        t_args->channels[position+1..];
      tell_object(this_player(), "The eyes sigh with relief as they "
                  "can now ignore what happens on "
                  "channel \"" + full_name + "\".\n");
    }
    else {
      tell_object(this_player(), "The eyes are bored with not listening "
                  "to any channel at all, and add channel \"one\" to their "
                  "list again.\n");
      t_args->channels = ({ "one" });
    }
    set_arg(t_args);
    break;
  case NEW_CHANNEL_PATTERN:
    if ( !t_args->status ) {
      tell_object(this_player(),  "The eyes are asleep.\n");
      return 1;
    }
    full_name = (EFFECTS + "talker")->normalise_name( args[ 0 ] );
    (EFFECTS+"talker")->clear_cache(this_player()->query_name());
    if ( ( EFFECTS +"talker" )->valid( full_name ) ) {
      if ( member_array( full_name, t_args->channels ) != -1 ) {
        tell_object(this_player(), "The eyes frown at you; they are "
                    "already listening to that channel.\n");
        return 1;
      }
      tell_object(this_player(),  "You whisper to " +
                  player->the_short() + " and the eyes add "
                  "channel \""+ full_name +"\" to the list.\n");
      t_args->channels += ({ full_name });
      set_arg(t_args);
      this_object()->init();
    } else {
      tell_object(this_player(), "You whisper to " +
                  player->the_short() + ", but the eyes "
                  "refuse to give you that channel.\n");
      return 1;
    }
    break;
  case SET_COLOUR_PATTERN:
  case SET_COLOUR_FULL_PATTERN:
    args[ 0 ] = (EFFECTS+"talker")->normalise_name( args[0] );
    return handle_colour_command( args[0], args[1], t_args );
  case COLOUR_ON_OFF_PATTERN:
    return handle_colour_on_off_command( args[0], t_args );
  case TOGGLE_COLOUR_PATTERN:
    return handle_colour_toggle_command(t_args);
  case COLOUR_LIST:
    return handle_colour_list( args, t_args );
    break;
  case HISTORY_CHANNEL_PATTERN:
    args[ 0 ] = (EFFECTS+"talker")->normalise_name( args[0] );
    return handle_history_command(args[0], t_args);
  case HISTORY_PATTERN:
    return handle_history_command("one", t_args);
  case LIST_PATTERN:
  case LIST_CHANNEL_PATTERN:
  case LIST_CHANNEL_PATTERN_BRIEF:
    if ( !t_args->status ) {
      tell_object(this_player(),  "The eyes are asleep.\n");
      return 1;
    }
    if (sizeof(args) == 1) {
      args[ 0 ] = (EFFECTS + "talker")->normalise_name( args[ 0 ] );
      tell_object(this_player(), "The following people are using "
                  "channel \""+ args[0] + "\":\n" +
                  ( EFFECTS +"talker" )->list( args[0],
                                 pattern == LIST_CHANNEL_PATTERN_BRIEF) );
    } else
      tell_object(this_player(), "The following people are using "
                  "talkers:\n" + (string)( EFFECTS +"talker" )->list() );
    return 1;
    break;
  case "help":
  default:
    write( "Talker commands:\n\n"
           "help               : give this help file\n"
           "on|off             : switch talker on or off\n"
           "brief              : make talker use shorter messages\n"
           "verbose            : make talker use longer messages\n"
           "channels           : list valid channels\n"
           "<channel>          : switch to <channel> if valid\n"
           "delete <channel>   : switch <channel> off if valid\n"
           "list [channel]     : list users of the talker\n"
           "history [channel]  : show chat history of <channel>\n"
           "Prefix commands with \"talker\" to use, e.g. "
           "\"talker help\".  For a more detailed description type "
           "\"help talker\".\n" );
    break;
  }
  return 1;
}
int handle_history_command(string channel, class talker_args args) {
  mixed *history;
  string result;
  if (!args->status) {
    tell_object(this_player(), "The eyes are asleep.\n");
    return 1;
  }
  if (!channel)
    channel = "one";
  if ( !( EFFECTS +"talker" )->valid( channel ) ) {
    tell_object(this_player(), "The eyes are not aware of that "
                "channel.\n");
    return 1;
  }
  tell_object(this_player(), "You whisper to " + player->the_short() +
              ", asking for the last few chats on channel " + channel + ".\n");
  history = HIST->query_chat_history(lower_case( channel ) );
  if ( !arrayp( history ) || !sizeof( history ) ) {
    tell_object(this_player(), "The eyes mutter that nothing has "
                "been said on this channel, or it is not being remembered.\n");
    return 1;
  }
  result = "$P$Channel " + channel + "$P$The eyes mutter about your bad "
    "memory.\n";
  result += implode(map(history, (: "$I$5=$C$" + $1[0] + ($1[1] ? $1[1] : "") +
                                  "%^RESET%^" :)), "\n");
  tell_object(this_player(), result);
  return 1;
}
string query_colour_status( class talker_args args ) {
  if ( !mapp( args->colour ) ) {
    return "off";
  }
  return args->colour[ "status" ];
}
int set_colour_status( class talker_args args, string status ) {
  if ( !args->colour ) {
    args->colour = DEFAULT_COLOUR_SETTINGS;
  } else {
    if ( stringp( args->colour ) ) {
      args->colour = DEFAULT_COLOUR_WITH( args->colour );
    }
  }
  args->colour[ "status" ] = status;
  set_arg( args );
  return 1;
}
int set_channel_colour(class talker_args args, string channel, string colour) {
  if ( !channel || !colour )
    return 0;
  if ( !mapp( args->colour ) ) {
    args->colour = DEFAULT_COLOUR_WITH(colour);
  }
  args->colour[ channel ] = colour;
  set_arg( args );
  return 1;
}
varargs string query_channel_colour( class talker_args args, string channel ) {
  string colour;
  if ( !mapp( args ) ) {
    return DEFAULT_COLOUR;
  }
  if ( colour = args->colour[ channel ] ) {
    return colour;
  } else {
    if ( colour = args->colour[ "default" ] ) {
      return colour;
    }
  }
  return DEFAULT_COLOUR;
}
int handle_colour_toggle_command( class talker_args args ) {
  if ( query_colour_status( args ) == "on" ) {
    return handle_colour_on_off_command( "off", args );
  }
  return handle_colour_on_off_command( "on", args );
}
int handle_colour_on_off_command( string str_status, class talker_args args ) {
  string status;
  status = query_colour_status( args );
  switch( str_status ) {
  case "on":
    if ( status == "on" ) {
      add_failed_mess( "Talker colours for $D are already on!\n" );
      return -1;
    }
    set_colour_status( args, "on" );
    add_succeeded_mess( ({ "The eyes on $D flash with " +
                             query_channel_colour( args, "default" ) +
                             "colour%^RESET%^.\n", "" }) );
    break;
  case "off":
    if ( status == "off" ) {
      add_failed_mess("Talker colours for $D have already been turned off!\n");
      return -1;
    }
    set_colour_status( args, "off" );
    add_succeeded_mess( ({ "The eyes on $D blink sadly.\n", "" }) );
    break;
  default:
    args->colour = DEFAULT_COLOUR_SETTINGS;
    set_arg( args );
    add_succeeded_mess( ({ "Talker colour settings for $D have been reset.\n",
                             "" }) );
  }
  return 1;
}
mapping create_valid_colours( string my_colours ) {
  string *colours;
  string *valid_colours = TERM_HANDLER->query_colour_codes();
  colours = map( explode( my_colours, " " ),
                 (: upper_case( $1 ) :) );
  return unique_mapping( colours,
                         (: member_array( $1, $(valid_colours) ) > -1 :) );
}
int handle_colour_command(string channel, string new_colour,
                          class talker_args args) {
  mapping colours;
  string valid_colour;
  if ( !(EFFECTS + "talker")->valid( channel ) && channel != "default" ) {
    tell_object( this_player(), "You cannot set that "
                 "channel! Use the channel name \"default\" to set "
                 "the default channel colour.\n" );
    return 1;
  }
  colours = create_valid_colours( new_colour );
  switch( sizeof( colours[ 0 ] ) ) {
  case 0:
    valid_colour = implode( map( colours[ 1 ], (: "%^" + $1 + "%^" :) ), "" );
    set_channel_colour( args, channel, valid_colour );
    add_succeeded_mess( ({ "The eyes flash with" + valid_colour +
                             " colour.%^RESET%^\n", "" }) );
    return 1;
  case 1:
    add_failed_mess( "The colour $I is invalid.\n", colours[ 0 ] );
    return -1;
  default:
    add_failed_mess( "The colours $I are invalid.\n", colours[ 0 ] );
    return -1;
  }
}
int handle_status_command(string mode, class talker_args args) {
  switch (mode) {
  case "on" :
    if ( args->status ) {
      tell_object(this_player(),  "The eyes are already alert "
                  "and listening to your every word.\n");
    } else {
      tell_object(this_player(), "The eyes open and light up "
                  "eagerly, then dim to a dull glow.\n");
      args->status = 1;
    }
    break;
  case "off" :
    if ( !args->status ) {
      tell_object(this_player(), "You notice that the eyes are "
                  "already closed, so you wake them up again "
                  "in order to tell them to go to sleep.\n");
    } else {
      tell_object(this_player(), "The eyes slowly lose their "
                  "glow as they close.\n");
      args->status = 0;
    }
    break;
  }
  set_arg(args);
  return 1;
}
int handle_verbose_command(string mode, class talker_args args) {
  if (!args->status) {
    tell_object(this_player(), "The eyes are asleep.\n");
    return 1;
  }
  switch (mode) {
  case "brief":
    if ( !args->verbose ) {
      tell_object(this_player(), "The eyes ignore you completely.\n");
    } else {
      tell_object(this_player(), "The eyes seem sad as they dim "
                  "slightly.\n");
      args->verbose = 0;
    }
    break;
  case "verbose":
    if ( args->verbose ) {
      tell_object(this_player(),  "The eyes glitter at you "
                  "angrily.  They already know that they are to "
                  "be verbose.\n");
    } else {
      tell_object(this_player(), "The eyes light up happily for "
                  "a moment.\n");
      args->verbose = 1;
    }
    break;
  }
  set_arg(args);
  return 1;
}
void receive(string channel, string sender, string text, object *receivers) {
  class talker_args args;
  string *ignoring;
  object where;
  string colour;
  string txt;
  if(!player || !environment(player) )
    return;
  where = environment(player);
  args = arg();
  if (args && !classp(args))
    return;
  if (!args || !args->status || !living(where) || !interactive(where))
    return;
  if(member_array(channel, map(args->channels, (: lower_case($1) :)) ) == -1) {
    return;
   }
  if ( channel == "intermud" && where->query_creator() ) {
    return;
  }
  if ( file_name( previous_object( 1 ) ) == "/secure/cmds/creator/exe_c" ||
       file_name( previous_object( 1 ) ) == "/secure/cmds/creator/ca_ll" ) {
    if ( this_player(1) && this_player(1)->query_creator() &&
         !this_player(1)->query_property( "talker cheat" ) ) {
      txt = this_player(1)->query_name() +
        " made " + sender + " chat \"" + text + "\" on "
        "channel " + channel;
      user_event( "inform", txt, "cheat" );
      log_file( "/d/admin/log/TALKER", txt + "\n" );
      this_player(1)->add_property( "talker cheat", 1, 3 );
    }
  }
  ignoring = where->query_property("ignoring");
  if (ignoring && member_array(lower_case(sender), ignoring) != -1 ) {
    return;
  }
  if(player->query_property(SHORTHAND_OUTPUT_PROP))
    text = LANGUAGES->fix_shorthand(text);
  if ( args->verbose ) {
#ifdef EMOTE_ENABLED
    if ( text[0] == '@' || text[0] == ':' ) {
      text = ( channel == "one" ? "" : "("+ capitalize(channel) +
               ") " ) +
        sender +"'s wispy voice comes from " +
        player->the_short()+", saying that " +
        (this_player()?this_player()->query_pronoun():"they") +
        " " + text[1..];
    } else {
#endif
      text = ( channel == "one" ? "" : "("+ capitalize(channel) +
               ") " ) +
        sender +"'s wispy voice comes from " +
        player->the_short()+", saying: " + text;
#ifdef EMOTE_ENABLED
    }
#endif
  } else {
#ifdef EMOTE_ENABLED
    if ( text[0] == '@' || text[0] == ':' ) {
      text = ( channel == "one" ? "" : "("+ capitalize(channel) +
               ") " ) +
        sender +" wisps that " +
        (this_player()?this_player()->query_pronoun():"they") +
        " " + text[1..];
    } else {
#endif
      text = ( channel == "one" ? "" : "("+ capitalize(channel) +
               ") " ) +
        sender +" wisps: " +text;
#ifdef EMOTE_ENABLED
    }
#endif
  }
  if ( stringp( args->colour ) ) {
    colour = args->colour;
  }
  if(mapp(args->colour) && query_colour_status( args ) == "on") {
    if (!( colour = args->colour[ channel ] ) ) {
      if(!(colour = args->colour[(EFFECTS + "talker")->
                                normalise_name(channel)])) {
        colour = args->colour[ "default" ];
        if ( !colour ) {
          colour = DEFAULT_COLOUR;
        }
      }
    }
  } else {
    colour = "";
  }
  tell_object(where, colour +  "$I$5=$C$"+ text + "%^RESET%^\n" );
#ifdef NOISY
  if(receivers && sizeof(receivers) && !where->query_invis() &&
     environment(where) && base_name(environment(where)) != "/room/rubbish") {
    receivers = map(receivers, (: $1->query_player() :));
    receivers += ({ this_player() });
    tell_room(environment(where),
              "A wispy voice comes from " + player->poss_short(1) + ".\n",
              receivers);
  }
#endif
}
int do_chat(string message, string pattern, string verb) {
  class talker_args args;
  object *things, *receivers;
  string sender;
#ifdef DEBUG
  tell_creator("taffyd", "Message is %s, pattern is %s, verb is "
               "%s.\n", message, pattern, verb);
#endif
#ifdef EMOTE_ENABLED
  if ( verb[ <1 ] == ':' ) {
    verb = verb[0..<2];
  }
#endif
  if (pattern == "into <direct:object>") {
    add_succeeded_mess("$N whisper$s lovingly to $D.\n");
    return 1;
  }
  args = arg();
  if (!args->status) {
    tell_object(this_player(), "The eyes are asleep.\n");
    return 1;
  }
  while (strsrch(message, "%^") != -1) {
    message = replace(message, ({ "%^", "" }) );
  }
  if(member_array( verb, map(args->channels, (: lower_case($1) :)) ) == -1 &&
     verb != "chat") {
    return 0;
  }
  if(this_player()->query_property("no talker")) {
    add_failed_mess("Sorry, you are not allowed to use a talker.\n");
    return 0;
  }
  if(environment(this_player()) &&
     environment(this_player())->query_property("no talker")) {
    if(stringp(environment(this_player())->query_property("no talker")))
      add_failed_mess(environment(this_player())->query_property("no talker"));
    else
      add_failed_mess("Your talker doesn't seem to work here.\n");
    return 0;
  }
  if (this_player()->query_property("gagged")) {
    add_failed_mess("You have been gagged!  You cannot chat until "
                    "your gag is removed.  Perhaps you should talk to a "
                    "creator about this.\n");
    return 0;
  }
  if (environment(player) != this_player()) {
    add_failed_mess("You're too far away from $D to whisper into it.\n");
    return 0;
  }
  if (verb == "chat") {
    if (member_array("one", args->channels) == -1) {
      verb = args->channels[0];
    }
    else {
      verb = "one";
    }
  }
  sender = this_player()->query_cap_name();
  message = replace(message,
                    ({ BEEP, "", CTRL, "", "[A", "", "[B", "", "[C", "",
                         "[D", "", "%^", " " }));
  if(this_player()->query_property(SHORTHAND_PROP))
    message = LANGUAGES->fix_shorthand(message);
  things = children( PATH + "talker" );
  if ( args->local_echo ) {
    things -= ({ find_object( PATH + "talker" ) });
  } else {
    things -= ({ this_object(), find_object( PATH + "talker" ) });
  }
  tell_object(this_player(), "You whisper into " + player->the_short() +
              ".\n");
  if(!this_player()->query_invis() &&
     base_name(environment(this_player())) != "/room/rubbish" ) {
    receivers = map(things, (: $1->query_player() :));
    receivers += ({ this_player() });
    tell_room(environment(this_player()), this_player()->one_short(1) +
              " whispers into " + this_player()->query_possessive() +
              " " + player->short() + ".\n", receivers);
  }
  things->receive(verb, sender, message, things);
  if( verb == "intermud" ) {
    if (message[0] == '@' || message[0] == ':') {
      user_event( "intermud_tell", sender + " ", message[1..], "dwchat" );
      message = "$N " + message[1..];
      SERVICES_D->eventSendChannel(sender, "discworld-chat", message, 1);
    } else {
      SERVICES_D->eventSendChannel( sender, "discworld-chat", message, 0 );
      user_event( "intermud_tell", sender +": ", message, "dwchat" );
    }
  }
  if ( verb == "playtesters" ) {
    if ( !this_player()->query_creator() &&
         !PLAYTESTER_HAND->query_playtester(this_player()->query_name()) ) {
      args->channels -= ({ "playtesters" });
      set_arg(args);
      add_failed_mess("You're no longer a playtester!\n");
      return 0;
    }
  }
#ifdef EMOTE_ENABLED
  if ( message[0] == '@' || message[0] == ':' ) {
    HIST->add_chat_history( verb , sender +" wisped that " +
                            this_player()->query_pronoun() + " ",
                            message[1..] );
  } else {
#endif
    HIST->add_chat_history( verb , sender +" wisped: ", message );
#ifdef EMOTE_ENABLED
  }
#endif
  return 1;
}
void remove_effect_shadow( int i ) {
  if ( i == id ) {
    if ( player && environment( player ) ) {
      environment( player )->remove_object( player, 1 );
      init();
    }
  }
  ::remove_effect_shadow( i );
}
protected string format_channel_colour( string colour ) {
  return colour +
    lower_case( replace_string( implode( explode( colour, "%^%^" ), " " ),
                                "%^", "" ) ) + "%^RESET%^";
}
int handle_colour_list(mixed *colour_args, class talker_args args) {
  string channel;
  if (!mapp(args->colour) || query_colour_status( args ) == "off" ) {
    add_failed_mess( "You currently have talker colours disabled.  Use "
                     "\"talker colour on\" to turn them on.\n" );
    return 0;
  }
  foreach( channel in args->channels ) {
    if ( args->colour[ channel ] ) {
      tell_object( this_player(),
                   "Channel " + channel + " is " +
                   format_channel_colour( args->colour[ channel ] ) + ".\n");
    }
  }
  if ( args->colour[ "default" ] ) {
    tell_object( this_player(),
                 "The default talker colour is " +
                 format_channel_colour( args->colour[ "default" ] ) + ".\n");
  }
  return 1;
}
int handle_echo_command( string mode, class talker_args args) {
  int current;
  current = args->local_echo;
  if ( current ) {
    if ( mode == "on" ) {
      add_failed_mess( "Talker echo is already on for $D!\n" );
      return -1;
    }
    args->local_echo = 0;
    add_succeeded_mess( ({ "The eyes on $D flash slowly.\n", "" }) );
  } else {
    if ( mode == "off" ) {
      add_failed_mess( "Talker echo is already off for $D!\n" );
      return -1;
    }
    args->local_echo = 1;
    add_succeeded_mess( ({ "The eyes on $D flash twice rapidly.\n",
                             "" }) );
  }
  set_arg( args );
  return 1;
}

==================================================
FILE: shadows/disease/flu_shadow.c
==================================================

inherit "/std/effect_shadow";
string *soulverb;
string *souladverb;
int query_flu(){ return 1; }
string flusoul(){
   string flu;
   soulverb = ({"sneeze",
                "cough"
   });
   souladverb = ({"violently",
                "loudly",
                "suddenly"
   });
this_player()->force_soul_command(soulverb[random(sizeof(soulverb))]+" "+souladverb[random(sizeof(souladverb))]);
   return flu;
}
int look_me(string arg){
   if(!arg){
      if (random(100) > 30){
         tell_object(player, "You feel dizzy and bleary eyed.\n");
      }
      else{
         player->look_me();
      }
      return 1;
   }
   return 1;
}
int attack_ob(object obj){
   object *contents;
   object target;
   if(random(100) > 30){
      tell_object(player, "You feel too ill, and can't be bothered to attack.\n");
      return 1;
   }
   player->attack_ob(target);
   return 1;
}
int cast(string str){
   if(random(100) > 50){
      tell_object(player, "You lose your concentration as you feel a "+
                          "sneeze coming on.\n");
      this_player()->force_soul_command("sneeze");
      return 1;
   }
   player->cast(str);
   return 1;
}

==================================================
FILE: shadows/disease/headache_shadow.c
==================================================

inherit "/std/effect_shadow";
int query_special_manoeuvre() {
   tell_object(player, "Your head hurts too much to try anything.\n");
   return 0;
}
int command_shadowed(string verb, string arg){
   if(verb=="cast"){
     write("Your head hurts too much to muster your might.\n");
     return 1;
   }
   return player->command_shadowed(verb, arg);
}

==================================================
FILE: shadows/curses/alone.c
==================================================

inherit "/std/effect_shadow";
int query_blinded() {
   return 1;
}

==================================================
FILE: shadows/curses/antisqeal.c
==================================================

inherit "/std/effect_shadow";
string *replace_matrix =  ({
"kewl", "cool",
"l33t", "elite",
" ur ", "your",
" r ", " are ",
" u ", " you ",
" y ", " why ",
"2", "two",
"4", "for",
"sum", "some",
"wut", "what",
"z", "s",
"Z", "s",
"k", "c",
"K", "c",
"wif", "with",
"werk", "work" });
#ifdef 0
string mangle_speech( string s ) {
    string s1;
    s1 = player->mangle_speech( s ); return replace( " " + (stringp(s1)?s1:s),
    replace_matrix)[1..10000]; }
#endif
string mangle_chat( string s ) {
  return replace(s, replace_matrix);
}

==================================================
FILE: shadows/curses/chef_curse.c
==================================================

inherit "/std/effect_shadow";
string *replace_matrix =  ({
"the", "zee",
"The", "Zee",
"ir", "ur",
"ow", "oo",
"th", "t",
"au", "oo",
"Au", "Oo",
"u", "oo",
"U", "Oo",
"tion", "shun",
"an", "un",
"An", "Un",
"en ", "ee ",
"ew", "oo",
"a", "e*",
"A", "E*",
"e* ", "e ",
"E* ", "E ",
"e*", "e",
"E*", "E",
"e ", "e-a ",
"f", "ff",
" o", " oo",
" O", " Oo",
"v", "f",
"V", "F",
"w", "v",
"W", "V", });
string mangle_speech( string s ) {
    string s1;
    s1 = player->mangle_speech( s );
    return replace( " " + (stringp(s1)?s1:s), replace_matrix)[1..10000];
}

==================================================
FILE: shadows/curses/deaf_shadow.c
==================================================

inherit "/std/effect_shadow";
#include "effect.h"
void event_whisper(object ob, string start, string mess, object *d, string lang) {
   int i;
   i = (int)arg() / 2;
   if (random(100) < i) {
      player->event_whisper(ob, start, mess, d, lang);
   } else {
      player->add_message(ob, "$N %hiss% something at you, but you just "+
"can't make it out.\n", 1);
   }
}
void event_person_say(object ob, string start, string mess, string lang) {
   string dum1, dum2;
   if (sscanf(start, "%sloud%s", dum1, dum2)) {
      if (random(100) > (100 - (int)arg()) / 2) {
         player->event_person_say(ob, start, mess, lang);
      } else {
         player->add_message(ob, "$N say$s something loudly, but "+
"you fail to hear it properly.\n", 1);
      }
   } else {
      if (random(100) < arg()) {
         player->event_person_say(ob, start, mess, lang);
      } else {
         player->add_message(ob, "$N say$s something, but you just can't "+
   "hear it properly.\n", 1);
      }
   }
}
void event_person_say_new(object ob, string start, string mess, string lang,
  mixed avoid) {
   tell_object(player, sprintf("New Say: %O %O %O %O %O\n", ob, start, mess, lang, avoid));
}

==================================================
FILE: shadows/curses/ensmurfed.c
==================================================

inherit "/std/effect_shadow";
varargs string short(int dark) {
   if (player)
     return player->short(dark)+"smurf";
   return "Smurf curse shadow";
}
mixed query_short() { return player->query_short()+"smurf"; }
mixed query_long() { return "This is a small blue humanoid.\n"; }
int query_female() { return 0; }
int query_gender() { return 0; }
int query_male() { return 0; }
int query_neuter() { return 1; }
string query_gender_string() { return "smurf"; }
string query_gender_title() { return "smurf"; }
string query_objective() { return "it"; }
string query_possessive() { return "its"; }
string query_pronoun() { return "it"; }
string long(string str, int dark) {
   string s, guild_ob;
   s = "You see "+ query_short();
   guild_ob = player->query_guild_ob();
   if (guild_ob)
      s += " "+ (string)guild_ob->query_title( this_object() ) +".\n";
   else
      s += ".\n";
   s += "It is a small blue humanoid wearing white trousers.\n";
   s += capitalize(query_pronoun())+" "+player->health_string()+".\n";
   s += player->calc_extra_look();
   s += player->weather_extra_look();
   s += player->query_living_contents(0);
   return s;
}
string smurf( string str ) {
   string str1;
   if ( sscanf( str, "%s,", str ) ) str1 = ",";
   else if ( sscanf( str, "%s.", str ) ) str1 = ".";
   else if ( sscanf( str, "%s!", str ) ) str1 = "!";
   else if ( sscanf( str, "%s;", str ) ) str1 = ";";
   else str1 = "";
   if ( sscanf( str, "%sing", str ) ) str = "smurfing";
   else if ( sscanf( str, "%sd", str ) ) str = "smurfed";
   else if ( sscanf( str, "%ss", str ) ) str = "smurfs";
   else str = "smurf";
   return str + str1;
}
string mangle_speech( string str ) {
   string tmp, *bits;
   int i;
   tmp = player->mangle_speech( str );
   if( !tmp ) tmp = str;
   bits = explode(tmp, " ");
   for (i=1;i<sizeof(bits);i+=3) {
      bits[i] = smurf( bits[i] );
   }
   tmp = implode(bits, " ");
   return tmp;
}

==================================================
FILE: shadows/curses/ken_curse.c
==================================================

inherit "/std/effect_shadow";
string *replace_matrix;
mapping trans;
void create() {
  replace_matrix = ({
  "Aren't you ", "Aintcha ",
  "aren't you ", "aintcha ",
  "You are", "Yer ",
  "you are ", "yer ",
  "Are not ", "Ain't",
  "are not ", "ain't ",
  "Is not ", "Ain't ",
  " is not ", " ain't ",
  "What is ", "Woss",
  "what is ", "woss",
  "What are you ", "Wotcher ",
  "what are you ", "wotcher ",
  "What you are", "Wotcher",
  "what you are", "wotcher",
  "What you're", "Wotcher",
  "what you're", "wotcher",
  "What are your", "Wotcher",
  "what are your", "wotcher",
  "What do you ", "Wotcher ",
  "what do you ", "wotcher ",
  "What do your", "Wotcher",
  "what do your", "wotcher",
  "a h", "an '",
  "A h", "An '",
  " h", " '",
  " H", " '",
  "Th", "F",
  "Wh", "W",
  "wh", "w",
  "aw", "or",
  "ing ", "in' ",
  " th", " f",
  "th", "ff",
  ".", " .",
  "?", " ?",
  "!", " !",
  });
  trans = ([ ]);
  trans["stairs"] = "apples and pears";
  trans["Downstairs"] = "Down the apples and pears";
  trans["downstairs"] =	"down the apples and pears";
  trans["Upstairs"] = "Up the apples and pears";
  trans["upstairs"] = "up the apples and pears";
  trans["mouth"] = "North and South";
  trans["Mouth"] = "North and South";
  trans["Face"] = "Boat Race";
  trans["face"] = "Boat Race";
  trans["Trouble"] = "Barney Rubble";
  trans["trouble"] = "Barney Rubble";
  trans["wife"] = ({ "trouble and strife", "ole lady" });
  trans["Road"] = "Frog and Toad";
  trans["road"] = "frog and toad";
  trans["pub"] = "rub-a-dub ";
  trans["bar"] = "boozer";
  trans["husband"] = "ole man";
  trans["Party"] = "Knees-up";
  trans["party"] = "knees-up";
  trans["Parties"] = "Knees-ups";
  trans["parties"] = "knees-ups";
  trans["My"] = "Me";
  trans["my"] = "me";
  trans["Your"] = "Yer";
  trans["your"] = "yer";
  trans["You"] = "Yer";
  trans["you"] = "yer";
  trans["Those"] = "Them";
  trans["those"] = "them";
  trans["those"] = "them";
  trans["(those"] = "(them";
  trans["The"] = ({ "The bleedin'", "The" });
  trans["Fe"] = ({ "The bleedin'", "The" });
  trans["the"] = ({ "the bleedin'", "the" });
  trans["fe"] = ({ "the bleedin'", "the" });
  trans["Thus"] = "So";
  trans["thus"] = "so";
  trans["(thus"] = "(so";
  trans["thus"] = "so";
  trans["old"] = "ole";
  trans["to"] = "ter";
  trans["Aren't"] = "Ain't";
  trans["aren't"] = "ain't";
  trans["Isn't"] = "Ain't";
  trans["isn't"] = "ain't";
  trans["Hallo"] = "Wotcher";
  trans["Hello"] = "Wotcher";
  trans["Hullo"] = "Wotcher";
  trans["Hi"] = "Wotcher";
  trans["hallo"] = "wotcher";
  trans["hello"] = "wotcher";
  trans["hullo"] = "wotcher";
  trans["hi"] = "wotcher";
  trans["What"] = "Wot";
  trans["what"] = "wot";
  trans["Were"] = "Was";
  trans["were "] = "was";
  trans["Bother"] = "Ars";
  trans["bother"] = "ars";
  trans["Mother"] = "Muvver";
  trans["Other"] = "Uvver";
  trans["other"] = "uvver";
  trans["Father"] = "Favver";
  trans["father"] = "favver";
  trans["Rather"] = "Ravver";
  trans["rather"] = "ravver";
  trans["Weather"] = "Wevver";
  trans["weather"] = "wevver";
  trans["Leather"] = "Levver";
  trans["leather"] = "levver";
  trans["Wither"] = "Wivver";
  trans["wither"] = "wivver";
  trans["Either"] = "Eever";
  trans["either"] = "eever";
  trans["With"] = "Wiv";
  trans["with"] = "wiv";
  trans["Anything"] = "Anyfink";
  trans["anything"] = "anyfink";
  trans["Something"] = "Sumfink";
  trans["something"] = "sumfink";
  trans["Nothing"] = "Nuffink";
  trans["nothing"] = "nuffink";
  trans["guitars"] = "spoons";
  trans["guitar"] = "spoons";
  trans["drums"] = "spoons";
  trans["drum"] = "spoons";
  trans["trumpets"] = "spoons";
  trans["trumpet"] = "spoons";
  trans["violins"] = "spoons";
  trans["violin"] = "spoons";
  trans["clarinets"] = "spoons";
  trans["clarinet"] = "spoons";
  trans["trombones"] = "spoons";
  trans["trombone"] = "spoons";
  trans["oboes"] = "spoons";
  trans["oboe"] = "spoons";
  trans["flutes"] = "spoons";
  trans["flute"] = "spoons";
  trans["tubas"] = "spoons";
  trans["tuba"] = "spoons";
  trans["Data"] = "Info";
  trans["data"] = "info";
  trans["Directory"] = "Lockup";
  trans["directory"] = "lockup";
  trans["Directories"] = "Lockups";
  trans["directories"] = "lockups";
  trans["Stopped"] = "'Ad the mockers put on";
  trans["stopped"] = "'ad the mockers put on";
  trans["Stopping"] = "Putting the mockers on";
  trans["stopping"] = "putting the mockers on";
  trans["stops"] = "puts the mockers on";
  trans["stop"] = "put the mockers on";
  trans["STOP"] = "Put The Mockers On";
  trans["Londoner"] = "Cockney";
  trans["londoner"] = "Cockney";
  trans["friend"] = ({ "mucker", "mate", "china" });
  trans["sin'"] = "sing";
  trans["rin'"] = "ring";
}
string mangle_speech(string str) {
  string tmp, *bits;
  mixed erp;
  int i;
  tmp = player->mangle_speech( str );
  tmp = replace(" "+(stringp(tmp)?tmp:str)+" ", replace_matrix);
  bits = explode(tmp, " ");
  for (i=0;i<sizeof(bits);i++) {
    if (erp = trans[bits[i]])
      if (stringp(erp))
        bits[i] = erp;
      else
        bits[i] = erp[random(sizeof(erp))];
  }
  tmp = implode(bits, " ");
  while (tmp[strlen(tmp)-1] == ' ')
    tmp = tmp[0..strlen(tmp)-2];
  switch (tmp[strlen(tmp)-1]) {
    case '?' :
      tmp = tmp[0..strlen(tmp)-3]+ ({ ", mate? ", ", guv? ",
                                      ", squire? " })[random(3)];
      break;
    case '!' :
      tmp = tmp[0..strlen(tmp)-3]+ ({ ", cor blimey!", "! Struth!",
		    ", guv!", " ! Honest guv!", ", mate! ", "!", })[random(6)];
      break;
    case '.' :
      tmp = tmp[0..strlen(tmp)-3];
    default :
      tmp += ({
		    ". I'll get out me spoons. ",
		    ". Yer can't 'ave a knees-up wivout a joanna. ",
		    ". Cor blimey guv, would I lie to you. ",
		    ". I'll make us all a nice cup of tea. ",
               })[random(4)];
  }
  return replace(tmp, ({ " !", "!", " .", ".", " ?", "?" }));
}

==================================================
FILE: shadows/curses/no_player_title.c
==================================================

#include <effect.h>
inherit "/std/effect_shadow";
varargs int add_property(string var, mixed val, int tim) {
    if ( var == "player_title" ) {
        tell_object( player, "You are not allowed to have a player title.\n" );
        return 0;
    }
    return player->add_property( var, val, tim );
}
mixed query_property( string prop ) {
    if ( prop == "player_title" ) {
        return 0;
    }
    return player->query_property( prop );
}
void bing() {
player->submit_ee2( player->sid_to_enum( id ), "spam", 5, EE_CONTINUOUS );
}

==================================================
FILE: shadows/room/hat_tent.c
==================================================

inherit "/std/effect_shadow";
int query_keep_room_loaded() {
   return 1;
}
int dont_free() {
   return 1;
}
int clean_up() {
   return 1;
}
void tent_collapsed() {
   remove_this_effect();
}

==================================================
FILE: shadows/room/terrain_dont_unload.c
==================================================

inherit "/std/effect_shadow";
#define BP tell_object( find_player("gerbil"), "BP.\n");
int i;
int dont_free() {return 1;}
void setup_shad() {
    i++;
}
string test_my_effect() {return "Yup!";}
void ditch_room() {
    if( !--i ) {
        remove_this_effect();
    }
}

==================================================
FILE: shadows/npc/basilisk_stare.c
==================================================

#include <move_failures.h>
inherit "/std/effect_shadow";
int query_basil_stare_shad(){ return 1; }
string query_passed_out_message()
{
  string *msgs = ({
    "The eyes!  They're burning!  Can't think!\n",
    "Your concentration is too fragmented.\n",
    "Why do that when you can just sit here and fall into those eyes?\n",
    "Arrrrgghhhh!  Too much pain!\n"
    }) ;
  return msgs[random(sizeof(msgs))];
}
int move_with_look(object dest, string messin, string messout)
{
   tell_object(player, "Your mind is not here to help you control "+
                       "your movement.\n");
   return MOVE_NO_DROP;
}
int attack_by(object obj)
{
   if( !obj || ( !obj->one_short() ) ) {
      tell_room( environment( player ), player->one_short() + " is totally "
         "helpless.\n", player );
   }
   else {
      tell_room(environment(player), player->one_short()+
        " is totally helpless against "+obj->one_short()+"'s attack.\n",
        player);
   }
   tell_object(player, "Oh dear! How do I defend myself? I forgot!\n") ;
   return 1;
}
int query_special_manoeuvre() { return 0; }

==================================================
FILE: shadows/npc/controlled_monster.c
==================================================

inherit "/std/effect_shadow";
int turn_chance;
object my_owner;
object my_enemy;
string leave_msg;
string enter_msg;
int summoned;
int set_enemy( object enemy );
object query_owner() { return my_owner; }
object query_enemy() { return my_enemy; }
void set_leave_msg( string mess ) { leave_msg = mess; }
void set_enter_msg( string mess ) { enter_msg = mess; }
void set_summoned( int summ ) { summoned = summ; }
void init() {
   player->init();
   if( this_player() != my_owner )
      return;
   this_player()->add_command( "help", this_object(), "<direct:living:here>" );
   this_player()->add_command( "order", this_object(),
                              "<direct:living:here> to {kill|attack} <indirect:living:here>" );
   this_player()->add_command( "order", this_object(),
                              "<direct:living:here> to protect <indirect:living:here>" );
   this_player()->add_command( "order", this_object(),
                              "<direct:living:here> to leave" );
}
int do_order( object *indir, string indir_match, string dir_match,
             mixed *args, string pattern ) {
   if( this_player() != my_owner )
      return 0;
   if( pattern == "<direct:living:here> to leave" ) {
      my_owner->add_succeeded_mess( this_object(),
                                   "$D smiles happily.\n", ({ }) );
      tell_object( my_owner,
                  (string)this_object()->the_short() +
		   " tells you: Thank you.\n");
      if ( summoned ) {
         call_out( "go_away", 1 );
      } else {
         my_owner = 0;
         call_out( "run_away", 1 );
      }
   } else if ( pattern == "<direct:living:here> to protect <indirect:living:here>" ) {
      if ( !indir ) {
         my_owner->add_failed_mess( this_object(),
                                   "$D asks you: Who do you want me to protect?\n", ({ }) );
         return 0;
      }
      tell_object( indir[ 0 ], (string)this_object()->the_short() +" tells you:  "+
                  (string)my_owner->the_short()
                  +" has asked me to protect you.\n" );
      tell_object( my_owner, (string)this_object()->the_short()
                  +" tells you: Fine.\n" );
      this_player()->add_succeeded_mess( this_object(),
                                        "$N $V $D to protect $I.\n ", ({ indir[ 0 ] }) );
      this_object()->do_command( "protect "+
				 (string)indir[ 0 ]->query_name() );
   } else {
      if ( !indir ) {
         my_owner->add_failed_mess( this_object(),
                                   "$D asks you: Who do you want me to kill?\n", ({ }) );
         return 0;
      }
      if ( !set_enemy( indir[ 0 ] ) ) {
         my_owner->add_failed_mess( this_object(),
                                   "$D tells you: There is no way you can force me to attack $I.\n",
                                   ({ indir[ 0 ] }));
         return 0;
      };
      tell_object( my_enemy, (string)this_object()->the_short() +
		   " tells you:  "+
                  (string)my_owner->the_short()
                  +" has asked me to kill you.\nPrepare to die!\n" );
      tell_object( my_owner, this_object()->the_short() +
		   " tells you: Fine.\n" );
   }
   return 1;
}
int do_help( object *indir, string indir_match, string dir_match,
            mixed *args, string pattern ) {
   if ( this_player() != my_owner )
     return 0;
   this_player()->add_succeeded_mess( this_object(),
                                     "You can \"order\" "+
				      this_object()->the_short()
                                     +" to kill someone or to leave.\n ", ({ }) );
   return 1;
}
int set_enemy( object enemy ) {
   object *list;
   int i;
   my_enemy = enemy;
   if( my_enemy == my_owner ) {
      my_owner = 0;
      list = this_object()->query_attacker_list();
      for( i = 0; i < sizeof(list); i++ ) {
         this_object()->stop_fight( list[i] );
         (list[ i ])->stop_fight( this_object() );
         if ( !pk_check( list[ i ], my_enemy ) ) {
            (list[ i ])->attack_ob( my_enemy );
            my_enemy->attack_ob( list[ i ] );
            tell_object( list[ i ], (string)this_object()->the_short()
                        +" tells you: I will help you fight "+
                        (string)my_enemy->the_short() +".\n");
         }
      }
   } else {
      if ( pk_check( my_owner, my_enemy ) ) {
         if ( turn_chance )
           call_out( "set_enemy", 1, my_owner );
         else
           call_out( "go_away", 1);
         return 0;
      }
   }
   this_object()->attack_ob( my_enemy );
   call_out( "move_me", 1 );
   return 1;
}
int set_owner( object owner, int time, int turn) {
   if ( !owner ) return 0;
   my_owner = owner;
   turn_chance = turn;
   if ( summoned )
     call_out( "do_leave", time ) ;
   call_out( "move_me", 1 );
   return 1;
}
void event_dest_me( object ob ) {
   if ( ob == my_owner )
     call_out( "go_away", 0 );
   if ( ob == my_enemy ) {
      if ( !my_owner )
        call_out( "go_away", 0 );
      if ( my_enemy )
        tell_object( my_owner, (string)my_enemy->the_short() +" has left DiscWorld\n" );
      my_enemy = 0;
      call_out( "move_me",0);
   }
}
void event_death( object ob ) {
   if ( ob == my_enemy ) {
      if ( !my_owner ) call_out( "go_away", 0 );
      call_out( "do_tell", 0, my_owner, this_object()->query_short() +" tells you: "+
               my_enemy->the_short() +" has been killed!\n");
      my_enemy = 0;
      call_out( "move_me", 0 );
   }
}
void do_tell( object ob, string str ) {
   tell_object( ob, str );
}
void move_me() {
   if ( my_enemy ) {
      if ( environment() == environment( my_enemy ) ) return;
      player->move( environment( my_enemy ), enter_msg, leave_msg );
      tell_object( my_enemy, this_object()->the_short() +" says: You cannot escape me!\n" );
      return;
   }
   if ( my_owner ) {
      if ( environment() == environment( my_owner ) ) return;
      player->move( environment( my_owner ), enter_msg, leave_msg );
      this_object()->do_command( "protect "+ (string)my_owner->query_name() );
      this_object()->do_command( "follow "+ (string)my_owner->query_name() );
      return;
   }
   if ( summoned )
     call_out( "go_away", 0 );
   else
     call_out( "run_away", 1 );
}
int do_leave() {
   if ( my_owner ) {
      tell_object( my_owner, this_object()->the_short()
                  +" tells you:  It is time for me to leave.\n" );
      say( this_object()->the_short() +" smiles happily.\n" );
   }
   call_out( "go_away", 2 );
   return 1;
}
int attack_by( object ob ) {
   if ( summoned && !my_owner ) {
      say( this_object()->the_short()
	   +" says: I will not fight without an owner!\n");
      call_out("go_away",0);
      return 1;
   }
   if ( interactive( my_owner ) ) {
      if ( (string) ob->query_guild_ob() == "/std/guilds/priest" ) {
         tell_object( my_owner, this_object()->the_short() +" tells you: "
                     "I do not wish to kill "+ ob->the_short()+".\n");
         if ( !turn_chance ) {
            call_out( "go_away", 1 );
            return 1;
         }
         if ( random( 100 ) < turn_chance ) {
            set_enemy( my_owner );
            return 1;
         }
      }
      if ( random( 100 ) < ( turn_chance / 5 ) ) {
         set_enemy( my_owner );
         return 1;
      }
   }
   return player->attack_by( ob );
}
void event_exit( object ob ) {
   if( ob != my_owner && ob != my_enemy ) return;
   call_out( "move_me", 1 );
}
void go_away() {
  write( leave_msg );
  player->move( "/room/rubbish" );
}

==================================================
FILE: shadows/npc/death.c
==================================================

inherit "/std/effect_shadow";
int second_life() {
   mixed *bit;
   int ret;
   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player);
   }
   if (!pointerp(bit) || sizeof(bit) < 3 || !bit[2]) {
      ret = player->second_life();
   }
   remove_this_effect();
   return ret;
}

==================================================
FILE: shadows/npc/dont_move.c
==================================================

inherit "/std/effect_shadow";
int cannot_walk() {
   return 1;
}

==================================================
FILE: shadows/npc/eat_corpse.c
==================================================

inherit "/std/effect_shadow";
mixed move( mixed dest, string messin, string messout ) {
   int ret;
   ret = player->move( dest, messin, messout );
   if( ret == 0 ) {
      call_out( "find_corpse", 0 );
   }
   return ret;
}
string *query_valid_bits( object corpse ) {
   object race_obj;
   string *edible_bits;
   if( !corpse )
      return ({ });
   if( !corpse->query_corpse() )
      return ({ });
   edible_bits = corpse->query_edible_bits_left();
   if( !sizeof( edible_bits ) )
      return ({ });
   race_obj = corpse->query_race_ob();
   if( !race_obj )
      return ({ });
   return filter( edible_bits,
                  (: sizeof( $(race_obj)->query_bit($1)[2] ) == 3 :) );
}
protected void find_corpse() {
   object ob, *obs;
   obs = all_inventory( environment(player) );
   foreach( ob in obs ) {
      if( sizeof( query_valid_bits(ob) ) ) {
         remove_call_out( "eat_corpse" );
         call_out( "eat_corpse", 1 + random(120), ob );
         break;
      }
   }
}
protected void eat_corpse( object corpse ) {
   string which_bit;
   string *valid_bits;
   if( !corpse ) {
      call_out( "find_corpse", 1 + random(2*60) );
      return ;
   }
   valid_bits = query_valid_bits( corpse );
   if( sizeof( valid_bits ) && environment(corpse) == environment(player) ) {
      which_bit = valid_bits[ random( sizeof( valid_bits ) ) ];
      corpse->add_bit_gone( which_bit );
      tell_room( environment( player ), "$C$" + player->the_short() +
         " tears the " + which_bit + " from " + corpse->the_short() + " and "
         "begins eating.\n" );
   }
   if( sizeof( valid_bits ) > 1 ) {
      remove_call_out( "eat_corpse" );
      call_out( "eat_corpse", 1 + random(2*60), corpse );
   } else {
      call_out( "find_corpse", 1 + random(2*60) );
   }
}
void event_enter( object ob, string mess, object from ) {
   player->event_enter( ob, mess, from );
   if( sizeof( query_valid_bits(ob) ) ) {
      remove_call_out( "eat_corpse" );
      call_out( "eat_corpse", 10, ob );
   }
}

==================================================
FILE: shadows/npc/eat_edible.c
==================================================

inherit "/std/effect_shadow";
protected void real_eat(object ob);
protected void do_eat_edible();
mixed move(mixed dest, string messin, string messout) {
  int ret;
  ret = player->move(dest, messin, messout);
  if (ret == 0) {
    call_out((: do_eat_edible :), 0);
  }
  return ret;
}
protected void do_eat_edible() {
  int i;
  object *obs;
  obs = all_inventory(player);
  for (i=0;i<sizeof(obs);i++) {
    if (obs[i]->query_edible()) {
      call_out((: real_eat :), 1, obs[i]);
    }
  }
}
protected void real_eat(object ob) {
  if (ob && player) {
    player->do_command("eat "+ob->query_name());
  }
}
void event_enter(object ob, string mess, object from) {
  player->event_enter(ob, mess, from);
  if (ob->query_edible()) {
    call_out("real_eat", 2, ob);
  }
}

==================================================
FILE: shadows/npc/enter.c
==================================================

inherit "/std/effect_shadow";
void event_enter(object ob, string mess) {
   mixed *bit;
   int ret;
   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player, ob, mess);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player, ob, mess);
   }
   player->event_enter(ob, mess);
}

==================================================
FILE: shadows/npc/exit.c
==================================================

inherit "/std/effect_shadow";
void event_exit(object ob, string mess) {
   mixed *bit;
   int ret;
   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player, ob, mess);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player, ob, mess);
   }
   player->event_exit(ob, mess);
}

==================================================
FILE: shadows/npc/given.c
==================================================

inherit "/std/effect_shadow";
void event_enter(object ob, string mess, object from) {
   mixed *bit = ({ });
   int ret;
   if (environment(ob) == player) {
      if(sizeof(arg()) > 1)
        bit = arg();
          else
        bit = ({ arg() });
           if (sizeof(bit) < 2)
              ret = evaluate(bit[0], player, ob, mess, from);
           else
              ret = call_other(bit[0], bit[1], player, ob, mess, from);
   }
   player->event_enter(ob, mess, from);
}

==================================================
FILE: shadows/npc/good_fighter.c
==================================================

#include <good_fighter.h>
#define LOGFILE "good_fighter"
#define CMDS "/cmds/guild-race/fighting/"
#define DEBUG
inherit "/std/effect_shadow";
#define W_ATTACKS ([ "crush"   : "crush $N with $W", \
                     "behead"  : "behead $N with $W", \
                     "impale"  : "impale $N with $W", \
                     "stab"    : "stab $N with $W", \
                     "pierce"  : "pierce $N with $W", \
                     "bash"    : "bash $N with $W", \
                     "smash"   : "smash $N with $W", \
                     "slash"   : "slash $N with $W", \
                     "slice"   : "slice $N with $W", \
                     "hack"    : "hack $N with $W", \
                     "chop"    : "chop $N with $W", \
                     "feint"   : "feint at $N with $W" ])
#define U_ATTACKS ([ "trip"    : "trip $N", \
                     "shove"   : "shove $N" ])
string *specials;
mapping weapons;
int bluntorsharp;
int dodgeorparry;
object victim;
void create()
{
  specials = ({ });
  weapons = ([ ]);
}
protected void check_skill(string skill, int level)
{
  int cur;
  cur = player->query_skill(skill);
  if (cur < level)
    player->add_skill_level(skill, level - cur);
}
protected void check_add_command(string command, string skill, int level)
{
  int cur;
  cur = player->query_skill(skill);
  if (cur >= level) {
    player->add_known_command(command);
    specials += ({ command });
  }
}
void good_fighter_setup()
{
  int adjust;
  int lvl;
  int *args = arg();
  if (!args || !arrayp(args) || sizeof(args) != 2)
    return;
  specials = ({ });
  bluntorsharp = args[0];
  dodgeorparry = args[1];
  lvl = player->query_level();
  check_skill("other.perception", lvl / 2);
  check_skill("other.health", lvl);
  adjust += (lvl / 3);
  if (bluntorsharp == USE_PIERCE) {
    check_skill("fighting.combat.melee.blunt", lvl - adjust);
    check_skill("fighting.combat.melee.sharp", lvl - adjust);
    check_skill("fighting.combat.melee.pierce", lvl + adjust);
    check_skill("fighting.combat.melee.unarmed", lvl - adjust);
  } else if (bluntorsharp == USE_BLUNT) {
    check_skill("fighting.combat.melee.blunt", lvl + adjust);
    check_skill("fighting.combat.melee.sharp", lvl - adjust);
    check_skill("fighting.combat.melee.pierce", lvl - adjust);
    check_skill("fighting.combat.melee.unarmed", lvl - adjust);
  } else if (bluntorsharp == USE_SHARP) {
    check_skill("fighting.combat.melee.blunt", lvl - adjust);
    check_skill("fighting.combat.melee.sharp", lvl + adjust);
    check_skill("fighting.combat.melee.pierce", lvl - adjust);
    check_skill("fighting.combat.melee.unarmed", lvl - adjust);
  } else if (bluntorsharp == USE_UNARMED) {
    check_skill("fighting.combat.melee.blunt", lvl - adjust);
    check_skill("fighting.combat.melee.sharp", lvl - adjust);
    check_skill("fighting.combat.melee.pierce", lvl - adjust);
    check_skill("fighting.combat.melee.unarmed", lvl + adjust);
  } else {
    check_skill("fighting.combat.melee.blunt", lvl);
    check_skill("fighting.combat.melee.sharp", lvl);
    check_skill("fighting.combat.melee.pierce", lvl);
    check_skill("fighting.combat.melee.unarmed", lvl);
  }
  adjust = lvl * 2 / 3;
  if (dodgeorparry == DEFEND_DODGE) {
    check_skill("fighting.combat.dodging", lvl + adjust);
    check_skill("fighting.combat.parry", lvl - adjust);
    player->init_command("tactics response dodge", 1);
  } else if (dodgeorparry == DEFEND_PARRY) {
    check_skill("fighting.combat.dodging", lvl - adjust);
    check_skill("fighting.combat.parry", lvl + adjust);
    player->init_command("tactics response parry", 1);
  } else {
    check_skill("fighting.combat.dodging", lvl);
    check_skill("fighting.combat.parry", lvl);
    player->init_command("tactics response neutral", 1);
  }
  check_skill("fighting.combat.special", lvl / 2);
  check_skill("fighting.points", lvl * 2);
  player->init_command("tactics attitude offensive", 1);
  if (bluntorsharp != USE_BLUNT) {
    if (dodgeorparry == DEFEND_PARRY)
      check_add_command("riposte", "fighting.combat.special", 15);
    if (bluntorsharp == USE_SHARP || bluntorsharp == USE_BALANCED)  {
      check_add_command("hack", "fighting.combat.special", 15);
      check_add_command("slash", "fighting.combat.special", 15);
      check_add_command("slice", "fighting.combat.special", 75);
      check_add_command("chop", "fighting.combat.special", 75);
      if (player->query_guild_ob() == "/std/guilds/warrior")
        check_add_command("behead", "fighting.combat.special", 150);
    }
    if (bluntorsharp == USE_PIERCE) {
      check_add_command("stab", "fighting.combat.special", 15);
      check_add_command("pierce", "fighting.combat.special", 75);
      if (player->query_guild_ob() == "/std/guilds/warrior")
        check_add_command("impale", "fighting.combat.special", 150);
    }
  } else {
    check_add_command("bash", "fighting.combat.special", 15);
    check_add_command("smash", "fighting.combat.special", 75);
    if (player->query_guild_ob() == "/std/guilds/warrior")
      check_add_command("crush", "fighting.combat.special", 150);
  }
  check_add_command("feint", "fighting.combat.special", 15);
  check_add_command("trip", "fighting.combat.special", 15);
  check_add_command("shove", "fighting.combat.special", 15);
  player->add_known_command("concentrate");
}
protected int check_weapon(object weapon, string command) {
  if(!weapon->query_attack_names())
    return 0;
  switch(command) {
  case "crush":
    command = "smash";
    break;
  case "behead":
    command = "slice";
    break;
  case "impale":
    command = "impale";
    break;
  case "riposte":
    command = "slash";
    break;
  case "feint":
    return 1;
  }
  return (member_array(command, weapon->query_attack_names()) != -1);
}
void event_fight_in_progress(object attacker, object opponent)
{
  object ts, weapon;
  int chance;
  string cmd;
  ts = player;
  ts->event_fight_in_progress(attacker, opponent);
  if(ts->query_specific_gp("fighting") < 50)
    return;
  if (victim && !objectp(victim))
    victim = 0;
  if (victim && !interactive(victim))
    victim = 0;
  if (victim && environment(victim) != environment(player))
    victim = 0;
  if (victim && victim != attacker)
    return;
  if (!victim) {
    if(member_array(attacker, ts->query_attacker_list()) != -1)
       victim = attacker;
    if (!victim)
      return;
  }
  if(!sizeof(player->query_weapons()) &&
     player->query_combat_attitude() != "wimp" &&
     arg()[0] != USE_UNARMED) {
    object *shields;
    player->queue_command("tactics attitude wimp", 1);
    shields = filter(player->query_holding(), (: $1 && $1->id("shield") :));
    if(!sizeof(shields)) {
      if(player->query_race_ob() == "/std/races/troll") {
        if(!player->query_unarmed_parry())
          player->queue_command("tactics parry unarmed");
      } else {
        player->queue_command("tactics response dodge", 2);
      }
    }
  }
  chance = (player->query_level() / 12) + 5;
  if(chance > 25)
    chance = 25;
  if(sizeof(player->query_specials()))
    chance /= (sizeof(player->query_specials()) * 10);
  if(random(100) + 1 < chance) {
    string *candidates;
    int i;
    candidates = ({ });
    foreach(weapon in player->query_weapons()) {
      if(!weapons[weapon]) {
        weapons[weapon] = ({ });
        for (i = 0; i < sizeof(specials); i++)
          if(W_ATTACKS[specials[i]] && check_weapon(weapon, specials[i])) {
            weapons[weapon] += ({ replace(W_ATTACKS[specials[i]], "$W",
                                          weapon->query_short()) });
          }
      }
      candidates += weapons[weapon];
    }
    if(!weapons["unarmed"]) {
      weapons["unarmed"] = ({ });
      for(i=0; i<sizeof(specials); i++)
        if(U_ATTACKS[specials[i]])
          weapons["unarmed"] += ({ U_ATTACKS[specials[i]] });
    }
    candidates += weapons["unarmed"];
#ifdef DEBUG
#endif
    if(sizeof(candidates)) {
      cmd = replace(candidates[random(sizeof(candidates))], "$N",
                    victim->query_name());
#ifdef DEBUG
      debug_printf("Trying to perform: %O", cmd);
#endif
      player->do_command(cmd, 1);
    } else {
#ifdef DEBUG
      debug_printf("No command to perform");
#endif
    }
  }
}
mixed *stats()
{
  if (!player || !objectp(player))
    return ({ ({ "good fighter", "unattached" }) });
  return player->stats() + ({
    ({ "good fighter",
      ((bluntorsharp == USE_BLUNT) ? "blunt" :
        ((bluntorsharp == USE_PIERCE) ? "pierce" :
          ((bluntorsharp == USE_SHARP) ? "sharp" : "balanced"))) +
      ((dodgeorparry == DEFEND_DODGE) ? " dodger" :
        ((dodgeorparry == DEFEND_PARRY) ? " parrier" : " fighter")) }),
    ({ "managed commands", implode(specials, ", ") })
  });
}

==================================================
FILE: shadows/npc/gossip.c
==================================================

inherit "/std/effect_shadow";
#include <gossip.h>
mixed *_says;
private void fixup_says() {
   int i;
   int num;
   if (!_says) {
      _says = ({
    ({ "Pinkfish", "Chickens look good under ultra violet light.", }),
    ({ "Deutha", "In the woods there is a singing lemon.  It has the "
                 "answers to all the quests." }),
    ({ "Turrican", "I am not a number, I am a free womble." }),
    ({ "Ceres", "I want to be a cabbage, I want to see the sea, I want "
                "to live in rabbit land, I want to be with thee.", }),
      });
      num = random(sizeof(_says));
      while (num > 0) {
         i = random(sizeof(_says));
         _says = _says[0..i-1] + _says[i+1..];
         num--;
      }
   }
}
void event_person_say(object ob, string start, string mess, string lang) {
   int i;
   string *bits;
   string *filter;
   player->event_person_say(ob, start, mess, lang);
   if (!userp(ob)) {
      return ;
   }
   fixup_says();
   filter = GOSSIP_HANDLER->query_filter();
   bits = explode(mess, " ");
   for (i = 0; i < sizeof(bits); i++) {
      if (member_array(bits[i], filter) != -1) {
         player->event_person_say(ob, start, mess, lang);
         return ;
      }
   }
   if (_says[<1][0] != ob->query_cap_name() ||
       _says[<1][1] != mess) {
      _says += ({ ({ ob->query_cap_name(), mess }) });
   }
   if (!random(50)) {
      GOSSIP_HANDLER->add_gossip(ob->query_cap_name(), mess);
   }
}
void do_gossip_say(string str) {
   int i;
   string *stuff;
   int chance;
   if (!str) {
      str = "$name$ said: $mess$";
   }
   chance = arg();
   if (!intp(chance)) {
      chance = 5;
   }
   fixup_says();
   if (sizeof(_says) > 0 && random(chance)) {
      i = random(sizeof(_says));
      stuff = _says[i];
   } else {
      stuff = GOSSIP_HANDLER->query_random_gossip();
   }
   if (!stuff) {
      i = random(sizeof(_says));
      stuff = _says[i];
   }
   if (!stuff) {
      str = replace(str, ({ "$name$", "fluff",
                            "$mess$", "big fluff" }));
   } else {
      str = replace(str, ({ "$name$", stuff[0],
                            "$mess$", stuff[1] }));
   }
   player->do_command("say "+str);
}
mixed *query_gossip_says() {
   return _says;
}

==================================================
FILE: shadows/npc/goto_destination.c
==================================================

inherit "/std/effect_shadow";
object womble;
int done, moved;
void stopped_route() {
   if (!done) {
      mixed *rabbit;
      rabbit = arg();
      if (objectp(rabbit[0])) {
         womble = rabbit[0];
      }
      done = 1;
   }
   if (womble && environment(womble) != environment(player)) {
      if (!moved) {
         player->move(environment(womble),
                      (string)player->query_mmsgin(),
                      (string)player->query_mmsgout() );
         call_out("remove_this_effect", 0);
      } else {
         player->move_me_to(file_name(environment(womble)));
      }
   } else {
      call_out("remove_this_effect", 0);
   }
}
int move(object ob, string in_thing, string out_thing) {
   int ret;
   if (!done) {
      mixed *rabbit;
      rabbit = arg();
      done = 1;
      if (arrayp(rabbit) && objectp(rabbit[0])) {
         womble = rabbit[0];
         done = 2;
      }
   }
   ret = player->move(ob, in_thing, out_thing);
   if (!ret && womble && environment(womble) == environment(player)) {
      player->stop_following_route();
      remove_this_effect();
   }
   if (done == 2 && !womble) {
      call_out("remove_this_effect", 4);
   }
   if (!ret)
      moved = 1;
   return ret;
}

==================================================
FILE: shadows/npc/guard_duty.c
==================================================

inherit "/std/effect_shadow";
int id;
#define GOTO_DEST "/std/effects/npc/goto_destination"
int move(object ob, string in_thing, string out_thing) {
   int ret;
   ret = player->move(ob, in_thing, out_thing);
   if (ret) {
      if (id) {
         remove_call_out(id);
      }
      if  (!sizeof(player->query_following_route()) &&
           file_name(environment(player)) != arg()) {
         id = call_out(function() {
                       object *arr;
                       arr = filter(player->query_attacker_list(),
                              (: environment($1) == environment(player) :));
                       if (!sizeof(arr)) {
                          player->add_effect(GOTO_DEST, arg());
                       }
                    }, 10);
      }
   }
   return ret;
}

==================================================
FILE: shadows/npc/i_died.c
==================================================

#include <effect.h>
inherit "/std/effect_shadow";
#define CLASS "npc.death.me"
int second_life() {
   mixed *bit;
   int ret;
   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player);
   }
   if (!pointerp(bit) || sizeof(bit) < 3 || !bit[2]) {
      ret = player->second_life();
   }
   player->submit_ee2( player->effects_matching(CLASS)[0], 0, 0, EE_REMOVE );
   return ret;
}

==================================================
FILE: shadows/npc/light_change.c
==================================================

inherit "/std/effect_shadow";
void event_light_change(object ob, int delta) {
   call_out("delayed_event_light_change",0, ob, delta );
}
void delayed_event_light_change(object ob, int delta) {
   mixed *bit;
   int ret;
   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player, ob, delta);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player, ob, delta);
   }
   player->event_light_change(ob, delta);
}

==================================================
FILE: shadows/npc/mock_block.c
==================================================

inherit "/std/effect_shadow";
string *unblock_skills( string *skills ) {
  set_arg( arg() - skills );
  if( !sizeof( arg() ) ) {
    remove_this_effect();
    return ({});
  }
  return arg();
}
int query_mock_block( string mocked ) {
  if( member_array( "all", arg() ) != -1 ) {
    return 1;
  }
  foreach( string skill in arg() ) {
    if( !strsrch( mocked, skill ) ) {
      return 1;
    }
  }
}

==================================================
FILE: shadows/npc/ngood_fighter.c
==================================================

#include <good_fighter.h>
#define LOGFILE "good_fighter"
#define CMDS "/cmds/guild-race/fighting/"
#define DEBUG
inherit "/std/effect_shadow";
#define W_ATTACKS ([ "crush"   : "crush $N with $W", \
                     "behead"  : "behead $N with $W", \
                     "impale"  : "impale $N with $W", \
                     "riposte" : "riposte $N with $W", \
                     "stab"    : "stab $N with $W", \
                     "pierce"  : "pierce $N with $W", \
                     "bash"    : "bash $N with $W", \
                     "smash"   : "smash $N with $W", \
                     "slash"   : "slash $N with $W", \
                     "slice"   : "slice $N with $W", \
                     "hack"    : "hack $N with $W", \
                     "chop"    : "chop $N with $W", \
                     "feint"   : "feint at $N with $W" ])
#define U_ATTACKS ([ "trip"    : "trip $N", \
                     "shove"   : "shove $N" ])
string *specials;
mapping weapons;
int bluntorsharp;
int dodgeorparry;
object victim;
void create()
{
  specials = ({ });
  weapons = ([ ]);
}
protected void check_skill(string skill, int level)
{
  int cur;
  cur = player->query_skill(skill);
  if (cur < level)
    player->add_skill_level(skill, level - cur);
}
protected void check_add_command(string command, string skill, int level)
{
  int cur;
  cur = player->query_skill(skill);
  if (cur >= level) {
    player->add_known_command(command);
    specials += ({ command });
  }
}
void good_fighter_setup()
{
  int adjust;
  int lvl;
  int *args = arg();
  if (!args || !arrayp(args) || sizeof(args) != 2)
    return;
  specials = ({ });
  bluntorsharp = args[0];
  dodgeorparry = args[1];
  lvl = player->query_level();
  check_skill("other.perception", lvl / 2);
  check_skill("other.health", lvl);
  adjust = lvl * 3 / 4;
  if (bluntorsharp == USE_PIERCE) {
    check_skill("fighting.combat.melee.blunt", lvl - adjust);
    check_skill("fighting.combat.melee.sharp", lvl - adjust);
    check_skill("fighting.combat.melee.pierce", lvl + adjust);
    check_skill("fighting.combat.melee.unarmed", lvl - adjust);
  } else if (bluntorsharp == USE_BLUNT) {
    check_skill("fighting.combat.melee.blunt", lvl + adjust);
    check_skill("fighting.combat.melee.sharp", lvl - adjust);
    check_skill("fighting.combat.melee.pierce", lvl - adjust);
    check_skill("fighting.combat.melee.unarmed", lvl - adjust);
  } else if (bluntorsharp == USE_SHARP) {
    check_skill("fighting.combat.melee.blunt", lvl - adjust);
    check_skill("fighting.combat.melee.sharp", lvl + adjust);
    check_skill("fighting.combat.melee.pierce", lvl - adjust);
    check_skill("fighting.combat.melee.unarmed", lvl - adjust);
  } else if (bluntorsharp == USE_UNARMED) {
    check_skill("fighting.combat.melee.blunt", lvl - adjust);
    check_skill("fighting.combat.melee.sharp", lvl - adjust);
    check_skill("fighting.combat.melee.pierce", lvl - adjust);
    check_skill("fighting.combat.melee.unarmed", lvl + adjust);
  } else {
    check_skill("fighting.combat.melee.blunt", lvl);
    check_skill("fighting.combat.melee.sharp", lvl);
    check_skill("fighting.combat.melee.pierce", lvl);
    check_skill("fighting.combat.melee.unarmed", lvl);
  }
  adjust = lvl * 2 / 3;
  if (dodgeorparry == DEFEND_DODGE) {
    check_skill("fighting.combat.dodging", lvl + adjust);
    check_skill("fighting.combat.parry", lvl - adjust);
    player->init_command("tactics response dodge", 1);
  } else if (dodgeorparry == DEFEND_PARRY) {
    check_skill("fighting.combat.dodging", lvl - adjust);
    check_skill("fighting.combat.parry", lvl + adjust);
    player->init_command("tactics response parry", 1);
  } else {
    check_skill("fighting.combat.dodging", lvl);
    check_skill("fighting.combat.parry", lvl);
    player->init_command("tactics response neutral", 1);
  }
  check_skill("fighting.combat.special", lvl / 2);
  check_skill("fighting.points", lvl * 2);
  player->init_command("tactics attitude offensive", 1);
  if (bluntorsharp != USE_BLUNT) {
    if (dodgeorparry == DEFEND_PARRY)
      check_add_command("riposte", "fighting.combat.special", 15);
    if (bluntorsharp == USE_SHARP) {
      check_add_command("hack", "fighting.combat.special", 15);
      check_add_command("slash", "fighting.combat.special", 15);
      check_add_command("slice", "fighting.combat.special", 75);
      check_add_command("chop", "fighting.combat.special", 75);
      if (player->query_guild_ob() == "/std/guilds/warrior")
        check_add_command("behead", "fighting.combat.special", 150);
    }
    if (bluntorsharp == USE_PIERCE) {
      check_add_command("stab", "fighting.combat.special", 15);
      check_add_command("pierce", "fighting.combat.special", 75);
      if (player->query_guild_ob() == "/std/guilds/warrior")
        check_add_command("impale", "fighting.combat.special", 150);
    }
  }
  if (bluntorsharp == USE_BLUNT || bluntorsharp == USE_BALANCED) {
    check_add_command("bash", "fighting.combat.special", 15);
    check_add_command("smash", "fighting.combat.special", 75);
    if (player->query_guild_ob() == "/std/guilds/warrior")
      check_add_command("crush", "fighting.combat.special", 150);
  }
  check_add_command("feint", "fighting.combat.special", 15);
  check_add_command("trip", "fighting.combat.special", 15);
  check_add_command("shove", "fighting.combat.special", 15);
  player->add_known_command("concentrate");
}
protected int check_weapon(object weapon, string command) {
  if (member_array(weapon->query_command_names(), ({ command })) != -1)
    return 1;
  return 0;
}
protected int check_crush(object weapon)
{
  if (member_array(weapon->query_commands_names(), ({ "smash" })) != -1)
    return 1;
  return 0;
}
protected int check_behead(object weapon)
{
  if (member_array(weapon->query_commands_names(), ({ "slice" })) != -1)
    return 1;
  return 0;
}
protected int check_impale(object weapon)
{
  if (member_array(weapon->query_commands_names(), ({ "pierce" })) != -1)
    return 1;
  return 0;
}
protected int check_riposte(object weapon)
{
  if (member_array(weapon->query_commands_names(), ({ "slash" })) != -1)
    return 1;
  return 0;
}
void event_fight_in_progress(object attacker, object opponent)
{
  object ts, temp, weapon;
  int chance;
  string cmd, str;
  ts = player;
  ts->event_fight_in_progress(attacker, opponent);
  if (victim && !objectp(victim))
    victim = 0;
  if (victim && !interactive(victim))
    victim = 0;
  if (victim && environment(victim) != environment(player))
    victim = 0;
  if (victim && victim != attacker)
    return;
  if (!victim) {
    victim = attacker;
    if (!victim)
      return;
  }
  chance = (player->query_level() / 12) + 5;
  if(chance > 25)
    chance = 25;
  if (random(100) + 1 < chance) {
    object *holding;
    string *candidates;
    int i, j;
    candidates = ({ });
    holding = player->query_holding() - ({ 0 });
    foreach(weapon in holding) {
      if(!weapons[weapon]) {
        weapons[weapon] = ({ });
        for (i = 0; i < sizeof(specials); i++)
          if(W_ATTACKS[specials[i]]) {
            weapons[weapon] += ({ replace(W_ATTACKS[specials[i]], "$W",
                                          weapon->query_short()) });
          }
      }
      candidates += weapons[weapon];
    }
    if(weapons["unarmed"]) {
      for(i=0; i<sizeof(specials); i++)
        weapons["unarmed"] = ({ });
        if(U_ATTACKS[specials[i]])
          weapons["unarmed"] += ({ U_ATTACKS[specials[i]] });
    }
    candidates += weapons["unarmed"];
#ifdef DEBUG
#endif
    if(sizeof(candidates)) {
      cmd = replace(candidates[random(sizeof(candidates))], "$N",
                    opponent->query_name());
#ifdef DEBUG
      debug_printf("Trying to perform: %O", cmd);
#endif
      player->do_command(cmd, 1);
    } else {
#ifdef DEBUG
      debug_printf("No command to perform");
#endif
    }
  } else {
#ifdef DEBUG
    debug_printf("Not doing a special this time");
#endif
  }
}
mixed *stats()
{
  if (!player || !objectp(player))
    return ({ ({ "good fighter", "unattached" }) });
  return player->stats() + ({
    ({ "good fighter",
      ((bluntorsharp == USE_BLUNT) ? "blunt" :
        ((bluntorsharp == USE_PIERCE) ? "pierce" :
          ((bluntorsharp == USE_SHARP) ? "sharp" : "balanced"))) +
      ((dodgeorparry == DEFEND_DODGE) ? " dodger" :
        ((dodgeorparry == DEFEND_PARRY) ? " parrier" : " fighter")) }),
    ({ "managed commands", implode(specials, ", ") })
  });
}

==================================================
FILE: shadows/npc/no_follow.c
==================================================

inherit "/std/effect_shadow";
int add_follower(object ob) {
   call_out("do_command", 0, "lose everyone");
   return player->add_follower(ob);
}

==================================================
FILE: shadows/npc/pub_brawl.c
==================================================

inherit "/std/effect_shadow";
void event_pub_brawl(object ob, string mess) {
   mixed *bit;
   int ret;
   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player, ob, mess);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player, ob, mess);
   }
   player->event_pub_brawl(ob, mess);
}

==================================================
FILE: shadows/npc/savage_corpse.c
==================================================

inherit "/std/effect_shadow";
mixed move(mixed dest, string messin, string messout) {
   int ret;
   ret = player->move(dest, messin, messout);
   if (ret == 0) {
      call_out("do_savage_corpse", 0);
   }
   return ret;
}
protected void do_savage_corpse() {
   int i;
   object *obs;
   obs = all_inventory(environment(player));
   for (i = 0; i < sizeof(obs); i++) {
      if (obs[i]->query_corpse() &&
          sizeof(obs[i]->query_edible_bits_left()) > 0) {
         remove_call_out("real_savage");
         call_out("real_savage", 1 + random(120), obs[i]);
         break;
      }
   }
}
protected void real_savage(object ob) {
   string *bits;
   object bit;
   int i;
   if (!ob) {
      call_out("do_savage_corpse", 1 + random(2*60));
      return ;
   }
   bits = ob->query_edible_bits_left();
   if (sizeof(bits) > 0 && environment(ob) == environment(player)) {
      i = random(sizeof(bits));
      bit = ob->make_bit(bits[i]);
      tell_room(environment(player), capitalize(player->the_short()) +
                " rips apart " + ob->the_short() +
                " pulling off " + bit->a_short() + ".\n");
      bit->move(environment(player));
   }
   if (sizeof(bits) > 1) {
      remove_call_out("real_savage");
      call_out("real_savage", 1 + random(2*60), ob);
   } else {
      call_out("do_savage_corpse", 1 + random(2*60));
   }
}
void event_enter(object ob, string mess, object from) {
   player->event_enter(ob, mess, from);
   if (ob->query_corpse()) {
      remove_call_out("real_savage");
      call_out("real_savage", 10, ob);
   }
}

==================================================
FILE: shadows/npc/sell_stuff.c
==================================================

inherit "/std/effect_shadow";
void stopped_route() {
  object *obs;
  int i;
  mixed room;
  room = arg();
  if (pointerp(room)) {
    room = room[0];
  }
  if (file_name(environment(player)) == room) {
    obs = all_inventory(player);
    for (i=0;i<sizeof(obs);i++) {
      if (!obs[i]->query_property("start equipment"))
        call_out("sell_the_stuff", 1, obs[i]);
        call_out( "drop_the_stuff", 2, obs[ i ] );
    }
    call_out( "bury_the_stuff", 3, query_multiple_short( obs ) );
  }
  call_out("remove_this_effect", 4);
}
protected void sell_the_stuff(object ob) {
  player->do_command("sell "+ob->query_name());
}
protected void drop_the_stuff( object thing ) {
   player->do_command( "drop "+ (string)thing->query_name() );
}
protected void bury_the_stuff( string words ) {
   player->do_command( "bury "+ words );
}

==================================================
FILE: shadows/npc/spell_effects.c
==================================================

inherit "/std/effect_shadow";
void do_spell_effects(object ob) {
   mixed *bit;
   int ret;
   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player, ob);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player, ob);
   }
   player->do_spell_effects(ob);
}

==================================================
FILE: shadows/npc/they_died.c
==================================================

inherit "/std/effect_shadow";
void event_death(object ob, string mess) {
   mixed *bit;
   int ret;
   bit = arg();
   if (functionp(bit)) {
      ret = evaluate(bit, player, ob, mess);
   } else if (pointerp(bit)) {
      ret = call_other(bit[0], bit[1], player, ob, mess);
   }
   player->event_exit(ob, mess);
}

==================================================
FILE: shadows/npc/uu_staff_protection.c
==================================================

inherit "/std/effect_shadow";
#define HANDLER "/obj/handlers/guild_things/punishment_handler"
mixed info = ({":thinks you should contact a creator. Something is wrong.",
     ":thinks you should contact a creator. Something is wrong.",
     ":thinks you should contact a creator. Something is wrong.", 0});
int attack_by(object thing){
      info = arg();
      if(!thing->query_property("player")){
         return 1;
      }
      if(thing->query_property("Wizard attack") != player->query_name()){
         if(info[0] != 0)
            player->do_command(info[0]);
         if(info[3] <= 0)
            info[3] = 1;
         HANDLER->add_offender(thing->query_name(), "attacking "+
            player->the_short(), info[3]);
         thing->add_property("Wizard attack", player->query_name(), 600);
   }
   return 1;
}
void event_enter(object ob, string mess, object from){
      string name = ob->query_name();
      int bing;
      if(!ob->query_property("player")){
         return;
      }
      bing = (HANDLER->query_no_offences(name));
      info = arg();
      if(bing){
         if(info[1] != 0)
            player->init_command(info[1], 1);
         if(HANDLER->query_unpunished(name)){
            if(info[2] != 0)
               player->init_command(info[2], 1);
            HANDLER->punishment(name);
         }
      }
     player->event_enter(ob, mess, from);
}

==================================================
FILE: shadows/npc/vampirebite_shadow.c
==================================================

inherit "/std/effect_shadow";
object vamp_corpse( object corpse ) {
   string player_name;
   if( corpse && objectp( corpse )
       && !corpse->query_property( "vampire corpse" )
       && corpse->query_race_name() == "human" ) {
      corpse->add_property( "no burial", 1 );
      corpse->add_property( "vampire corpse", 1 );
      if( stringp( player->query_property( "determinate" ) ) )
         player_name = player->query_property( "determinate" ) +
            player->query_short();
      else
         player_name =
            "/global/events"->convert_message( player->a_short() );
      corpse->add_effect( "/std/effects/npc/vampirecorpse_effect",
         ({ player_name, copy( player->query_gender() ),
            copy( player->query_level() ), 0 }) );
   }
   return corpse;
}
varargs object do_death( object thing, object weapon, string attack ) {
   int *effs;
   object corpse;
   effs = player->effects_matching( "body.bite.vampire" );
   call_out( "remove_this_effect", 2 );
   corpse = player->do_death( thing, weapon, attack );
   vamp_corpse( corpse );
   return corpse;
}
object make_corpse() {
   object corpse;
   corpse = player->make_corpse();
   vamp_corpse( corpse );
   return corpse;
}

==================================================
FILE: shadows/misc/concealment.c
==================================================

object shadowed, *concealed;
void setup_shadow( object thing ) {
   shadow( thing, 1 );
   shadowed = thing;
   concealed = ({ });
}
void destruct_shadow( object thing ) {
   if ( thing == this_object() )
      destruct( this_object() );
   else
      thing->destruct_shadow( thing );
}
void add_concealed( object thing ) {
   concealed -= ({ 0 });
   if ( member_array( thing, concealed ) == -1 )
      concealed += ({ thing });
}
int set_worn_by( object thing ) {
   int weight;
   if ( thing == (object)shadowed->query_worn_by() )
      return 1;
   if ( !shadowed->set_worn_by( thing ) )
      return 0;
   weight = (int)shadowed->query_weight();
   concealed -= ({ 0 });
   foreach ( thing in concealed ) {
      if ( (int)thing->query_complete_weight() > random( weight ) )
         thing->remove_hide_invis( "concealed" );
   }
   call_out( "destruct_shadow", 0, this_object() );
   return 1;
}
mixed *stats() {
   concealed -= ({ 0 });
   return ({
      ({ "concealing", array_to_string( concealed ) })
   }) + (mixed *)shadowed->stats();
}
int query_concealing() { return 1; }

==================================================
FILE: shadows/misc/davidshad.c
==================================================

object player;
void setup_shadow( object thing ) {
   shadow( thing, 1 );
   player = thing;
}
void dest_shadow() { destruct( this_object() ); }
void run_away() {
  tell_object(player, "You feel too peaceful to run away.\n");
}
int pk_check( mixed thing1, mixed thing2, int off_line ) {
  return 1;
}
void start_attack(){}
void adjust_hp( int number, object attacker ) {
  if(player->query_attacker_list()) {
    foreach(attacker in player->query_attacker_list()) {
      attacker->stop_fight(player);
      player->stop_fight(attacker);
    }
  }
    return;
}
void adjust_gp( int number ) {
  if ( number < 0 )
    return player->adjust_gp( number );
  return;
}
int attack_by(object ob) {
  ob->stop_fight(player);
  player->stop_fight(ob);
  return 1;
}

==================================================
FILE: shadows/misc/death_shadow.c
==================================================

object my_player;
int cost_life, resurrect_adds_life;
int test_add(object ob) {
   if (ob->query_property("dead usable"))
      return 1;
   return 0;
}
void set_death_cost_life( int i ) { cost_life = i; }
int query_death_cost_life() { return cost_life; }
void set_resurrect_adds_life( int i ) { resurrect_adds_life = i; }
int query_resurrect_adds_life() { return resurrect_adds_life; }
void attack() {
}
void adjust_hp() {
}
void set_hp() {
}
void do_death() {
}
void setup_shadow( object ob ) {
   shadow( ob, 1 );
   my_player = ob;
   cost_life = my_player->query_property( "death cost life" );
   my_player->remove_property( "death cost life" );
   resurrect_adds_life = my_player->query_property( "resurrect should add life" );
   my_player->remove_property( "resurrect should add life" );
}
int attack_by( object ob ) {
   tell_object( ob, "This person is a ghost... You cannot attack them.\n" );
   ob->stop_fight( my_player );
   return 1;
}
int attack_ob( object ob ) {
   write( "Your hand passes right through it!  You are just a ghost!\n" );
   return 0;
}
string short() {
   if ( !my_player )
      return "Death shadow";
   return "the ghost of "+my_player->short();
}
void dest_death_shadow() {
   destruct( this_object() );
}
int cast() {
   write( "Casting spells when you are dead?\n" );
   return 1;
}
int do_shout() {
   write( "You are dead, that is not possible.\n" );
   return 1;
}
int do_echo() {
   write( "You are dead...\n" );
   return 1;
}
int do_guild_command() {
   write( "You are dead!\n" );
   return 1;
}
int do_race_command() {
   write( "You are dead!\n" );
   return 1;
}
int score() {
   write( "You are just a disembodied spirit.  What use has a wispy thing "
         "like you have for a collection of meaningless numbers?\n" );
   return 1;
}
void second_life() {
}
mapping query_dynamic_auto_load() {
   if ( my_player ) {
      my_player->add_property( "death cost life", cost_life );
      my_player->add_property( "resurrect should add life",
                              resurrect_adds_life );
      return my_player->query_dynamic_auto_load();
   } else
      return ([ ]);
}

==================================================
FILE: shadows/misc/effects.c
==================================================

#define EFF_OB_NAME 0
#define EFF_ARG 1
#define EEQ_INCTIME 0
#define EEQ_FUNC 1
#define EEQ_EFF_OB 2
#define EEQ_INTERVAL 3
#define EEQ_FLAGS 4
#define EFF_SIZE 2
#define EEQ_SIZE 5
inherit "/std/basic/effects";
private object shadowed;
void setup_shadow( object thing ) {
   shadow( thing, 1 );
   shadowed = thing;
}
void destruct_shadow( object thing ) {
   if ( thing == this_object() ) {
      destruct( this_object() );
   } else {
      thing->destruct_shadow( thing );
   }
}
void set_effs( mixed *args ) {
  ::set_effs(args);
}
void set_eeq( mixed *args ) {
  ::set_eeq(args);
}
mixed *stats() {
  mixed *tmp = (mixed *)shadowed->stats();
  if(!arrayp(tmp)) {
    tmp = ({});
  }
  return ::stats() + tmp;
}

==================================================
FILE: shadows/misc/harry_shadow.c
==================================================

#include <player.h>
int protecting;
string protector;
object player;
void setup_shadow( object thing, string word ) {
   shadow( thing, 1 );
   player = thing;
   protector = word;
   protecting = 1;
   call_out( "dest_harry_shadow", 60 * 20 );
}
string query_harry_protector() { return protector; }
void dest_harry_shadow() { destruct( this_object() ); }
void zap_harry_shadow() {
   protecting = 0;
   tell_object( player, "You lose "+ protector +"'s protection.\n" );
   call_out( "dest_harry_shadow", 1 );
}
int adjust_hp( int number, object thing, object weapon, string attack ) {
   if ( ( number > 0 ) || !protecting ||
       !thing || !pk_check(thing, player ) || player == this_player() )
      return (int)player->adjust_hp( number, thing, weapon, attack );
   return (int)player->query_hp();
}
int set_hp( int number, object thing ) {
   int current;
   current = (int)player->query_hp();
   if ( ( number > current ) || !protecting || !thing || !thing->query_player_killer() )
      return (int)player->set_hp( number, thing );
   return current;
}
int attack_by( object thing ) {
   if ( !protecting || !thing->query_player_killer( ) )
      return (int)player->attack_by( thing );
   tell_object( thing, (string)player->the_short() +
         " are protected from combat by "+ protector +".\n" );
   tell_object( player, "You are protected from combat by "+
         protector +".\n" );
   thing->stop_fight( player );
   return 0;
}
int attack_ob( object thing ) {
   if ( protecting )
      zap_harry_shadow();
   return (int)player->attack_ob( thing );
}
int query_unambushable() { return 1; }
void do_ambushed() {
   write( protector +" stops you from harming "+
         (string)player->the_short() +".\n" );
   tell_object( player, protector +" stops "+
         (string)this_player()->the_short() +" from harming you.\n" );
}
int no_offense() {
   if ( protecting )
      zap_harry_shadow();
   return (int)player->no_offense();
}
int query_player_killer() {
   return 0;
}
int command_shadowed( string verb, string args ) {
   if ( member_array( verb, ({ "cast", "scathe", "perform" }) ) == -1 )
      return (int)player->command_shadowed( verb, args );
   if ( protecting )
      zap_harry_shadow();
   return (int)player->command_shadowed( verb, args );
}
varargs int adjust_xp( int number, int shared ) {
#ifdef DEBUG
  log_file( "PROTECTED", ctime( time() ) +": "+ (string)player->query_name() +
         " gained "+ number +"xp ["+ implode( map_array( previous_object( -1 ),
         (: file_name( $1 ) :) ), ", " ) +"]\n" );
#endif
   return (int)player->adjust_xp( number, shared );
}
varargs int add_skill_level( string skill, int lvl, mixed exp ) {
   string what;
   if ( !exp )
      exp = previous_object();
   if ( objectp( exp ) )
      what = " from "+ file_name( exp );
   else
      what = " for "+ exp +"xp";
#ifdef DEBUG
   log_file( "PROTECTED", ctime( time() ) +": "+ (string)player->query_name() +
         " gained "+ lvl +" in "+ skill + what +" ["+
         implode( map_array( previous_object( -1 ), (: file_name( $1 ) :) ),
         ", " ) +"]\n" );
#endif
   return (int)player->add_skill_level( skill, lvl, exp );
}

==================================================
FILE: shadows/misc/marry_shadow.c
==================================================

#include "/cmds/guild-race/masters/marry.h"
#define RING "/obj/misc/wedding_ring.c"
#define LOG "/w/olorin/responselog"
#define MAXLOG 8000
object player, marry1, marry2, ring1, ring2;
int found, response_index;
string asking, askingwho, *words, *yes_array, *no_array;
mapping local_prop, yes_response, no_response;
void do_accept();
void do_refuse();
void create() {
   yes_response = ([ "say":({ "yes", "yep", "sure", "ok",
                     ({ "will" , "i" }), ({ "do" , "i" }) }),
                     "soul":({ "nod" , "ack", }) ]);
   no_response = ([ "say":({ "no", "nope", ({ "won't", "i" }),
                          ({ "don't", "i" }), ({ "can't", "i" }),
                    "cannot" }),
                    "soul":({ ({ "shake" , "head" }), "panic", "puke" }) ]);
   local_prop = ([ MARRYPROP : 1, ]);
}
object add_marry_shadow( object p, object m1, object m2 ) {
   player = p;
   marry1 = m1;
   marry2 = m2;
   askingwho = (string)marry1->query_name();
   asking = ASKFIRST;
   tell_object( player, "Now you should ask " +
         (string) marry1->query_short() + " whether " +
         (string) marry1->query_pronoun() + " will marry " +
         (string) marry2->query_short() + "\n");
   return shadow( p, 1 );
}
string remove_read_marks(string str) {
   int index, size;
   string result;
   string temp;
   index = 0;
   size = strlen(str);
   result = "";
   while (index < size) {
      temp = str[index..index];
      if (((temp >= "a") && (temp <= "z")) ||
    (temp == " ") || (temp == "'")) result += temp;
      else result += " ";
      index++;
   }
  return result;
}
void check_response( string resptype, string mess ) {
   if ( mess && strlen( mess ) ) {
      mess = lower_case( mess );
      mess = remove_read_marks(mess);
      words = explode( mess, " " );
      yes_array = yes_response[ resptype ];
      no_array = no_response[ resptype ];
      response_index = sizeof( yes_array );
      while ( response_index-- ) {
   if ( !stringp( yes_array[ response_index ] ) ) {
      if ( ( member_array( yes_array[ response_index ][ 0 ],
         words ) != -1 ) &&
     ( member_array( yes_array[ response_index ][ 1 ],
         words ) != -1 ) ) {
         do_accept();
         return;
      }
   } else {
      if ( member_array( yes_array[ response_index ], words ) != -1 ) {
             do_accept();
         return;
      }
   }
      }
      response_index = sizeof( no_array );
      while ( response_index-- ) {
   if ( !stringp( no_array[ response_index ] ) ) {
      if ( ( member_array( no_array[ response_index ][ 0 ],
         words ) != -1 ) &&
     ( member_array( no_array[ response_index ][ 1 ],
         words ) != -1 ) ) {
         do_refuse();
         return;
      }
   } else {
      if ( member_array( no_array[ response_index ], words ) != -1 ) {
         do_refuse();
         return;
      }
   }
      }
#ifdef LOG
      if ( file_size( LOG ) <= MAXLOG)
  unguarded((: write_file, LOG ,
             "MARRY response: "+resptype+": '"+mess+"'\n" :));
#endif
   }
}
void event_person_say( object ob, string start, string mess, string lang ) {
   if ( ob->query_name() == askingwho ) {
      check_response("say", mess);
   }
   player->event_person_say( ob, start, mess, lang );
   return;
}
void event_person_tell(object ob, string start, string mess, string lang) {
   if ( ob->query_name() == askingwho ) {
      check_response("say", mess);
   }
   player->event_person_tell( ob, start, mess, lang );
   return;
}
void event_soul(object ob, string mess, object *avoid, string verb,
                string last, mixed at) {
   if ( sizeof( avoid ) &&
       avoid[0]->query_name() == askingwho ) {
      check_response( "soul", mess );
   }
   response_index = sizeof( avoid );
   while ( response_index-- ) {
      if ( avoid[ response_index ] == player ) {
   return;
      }
   }
   tell_object( player, mess );
   return;
}
void do_accept() {
   if ( asking == ASKFIRST ) {
      asking = ASKSECOND;
      askingwho = (string) marry2->query_name();
      tell_object( player, (string) marry1->query_pronoun() +
      " accepted. Now you should ask " +
      (string) marry2->query_short() + " whether " +
      (string) marry2->query_pronoun() + " will marry " +
      (string) marry1->query_short() + "\n" );
      tell_object( marry1, "You accepted.\n" );
   } else if ( asking == ASKSECOND ) {
      asking = DONEASK;
      askingwho = "*NoOne*";
      tell_object( player, (string) marry2->query_pronoun() +
      " accepted. Now you can ask if there are any objections or" +
      " you can finalize the wedding with 'marry them'.\n" );
      tell_object( marry2, "You accepted.\n" );
   } else {
      tell_object( player, "Something is wrong here, please tell Olorin " +
      "what you where doing.\n" );
#ifdef LOG
     unguarded((: write_file, LOG ,
                "marry_error "+
     "in accept:" + asking + ";" + askingwho + "(" +
     (string) marry1->query_short() + " to " +
     (string) marry2->query_short() + ")" :));
#endif
      call_out( "remove_propose_shadow", 0 );
   }
}
void do_refuse() {
   if ( asking == ASKFIRST ) {
      tell_object( player, (string) marry1->query_pronoun() +
      " wimpied out.\n" );
      tell_object( marry1, "You refused, the marriage is off.\n" );
   } else if ( asking == ASKSECOND ) {
      tell_object( player , (string) marry2->query_pronoun() +
      " wimpied out.\nYou'd better try to console " +
      (string) marry1->query_short() + "\n" );
      tell_object( marry2, "You refused, how will you explain that to "+
      (string) marry1->query_short() + ".\n" );
   } else {
      tell_object( player, "Something is wrong here, please tell Olorin " +
      "what you where doing.\n" );
#ifdef LOG
      unguarded((: write_file, LOG ,
                 "marry_error"+
     "in refuse:" + asking + ";" + askingwho + "(" +
     (string) marry1->query_short() + " to " +
     (string) marry2->query_short() + ")" :));
#endif
   }
   call_out( "remove_marry_shadow", 0 );
}
mixed query_property( string str ) {
   if ( str == MARRYPROP ) {
      return 1;
   } else {
      return player->query_property( str );
   }
}
int do_wedding() {
   if ( environment( player ) == environment( marry1 ) ) {
      if ( environment( player ) == environment( marry2 ) ) {
   marry1->add_property( "spouse", marry2->query_name() );
   marry2->add_property( "spouse", marry1->query_name() );
   ring1 = clone_object( RING );
   ring1->set_owner( marry1->query_short() );
   ring1->set_giver( marry2->query_short() );
   ring1->move( marry1 );
   ring2 = clone_object( RING );
   ring2->set_owner( marry2->query_short() );
   ring2->set_giver( marry1->query_short() );
   ring2->move( marry2 );
   tell_object( player, "They are now married, you'd better tell them.\n" );
   call_out( "remove_marry_shadow", 0 );
   return 1;
      } else {
   tell_object( player, marry2->query_short() +
         " seems to have wandered off.\n" +
         "Perhaps you should try to console " +
         (string) marry1->query_short() + "\n" );
      }
   } else {
      tell_object( player, marry2->query_short() +
      " seems to have wandered off.\n" +
      "Perhaps you should try to console " +
      (string) marry2->query_short()+"\n" );
   }
   call_out( "remove_marry_shadow", 0 );
   return 0;
}
int abort_wedding() {
   call_out( "remove_marry_shadow", 0 );
   return 0;
}
void remove_marry_shadow() {
   destruct( this_object() );
   return;
}

==================================================
FILE: shadows/misc/offler_shadow.c
==================================================

object player;
void setup_shadow( object thing ) {
   shadow( thing, 1 );
   player = thing;
}
void dest_offler_shadow() { destruct( this_object() ); }
int adjust_hp( int number, object thing, object weapon, string attack ) {
   if ( number > 0 )
      return (int)player->adjust_hp( number, thing, weapon, attack );
   else
      return (int)player->query_hp();
}
int set_hp( int number, object thing ) {
   int current;
   current = (int)player->query_hp();
   if ( number > current )
      return (int)player->set_hp( number, thing );
   else
      return current;
}
void do_death() { return; }
int second_life() { return 1; }
int attack_by( object thing ) {
   tell_object( thing, (string)player->the_short() +
         " is prevented from fighting by Offler.\n" );
   thing->stop_fight( this_object() );
   return 0;
}
int attack_ob( object thing ) {
   tell_object( player, "You are prevented from fighting by Offler.\n" );
   thing->stop_fight( this_object() );
   return 0;
}
int query_unambushable() { return 1; }
void do_ambushed() {
   write( "You suddenly see a terrifying image of a huge crocodile!\n" );
   this_player()->run_away();
}
int no_offense() {
   write( "You are prevented from offensive actions by Offler.\n" );
   return 1;
}
int cast() {
   write( "You are about to start when Offler stops you.\n" );
   return 1;
}

==================================================
FILE: shadows/misc/poker_shadow.c
==================================================

#define FEAR "/std/spells/priest/fear.c"
#define BLIND "/std/effects/religious/blind"
object this_gambler;
void setup_shadow( object gambler )  {
   shadow( gambler, 1 );
   this_gambler = gambler;
   return;
}
void net_dead()  {
   this_gambler->net_dead();
   if ( !environment( this_gambler )->query_status()  &&
        !environment( this_gambler )->query_anted( this_gambler ) )  {
      tell_room( environment( this_gambler ), "One of the imps taps " +
                 this_gambler->short() + " on the chalky forehead, "
                 "pulls out a small hourglass, and begins watching it "
                 "intently.\n" );
      call_out( "do_leave", 30 );
   }
   else if ( this_gambler ==
             (object)environment( this_gambler )->query_player() )  {
      tell_room( environment( this_gambler ), "One of the imps taps " +
                 this_gambler->short() + " on the chalky forehead, "
                 "pulls out a small hourglass, and begins watching it "
                 "intently.\n" );
      call_out( "do_fold", 30 );
   }
   return;
}
void inform_reconnect_game()  {
    tell_room( environment( this_gambler ), "The imp puts away its "
               "hourglass, nods happily at " +
               this_gambler->short() + ", and returns to the "
               "corner.\n", this_gambler );
    tell_object( this_gambler, "An imp puts away its hourglass, nods "
                 "happily at you, and returns to the corner.\n");
   return;
}
void do_fold()  {
   tell_room( environment( this_gambler ), "The imp gently takes the cards "
              "from " + this_gambler->short() + " and returns to the "
              "corner.\n" );
   environment( this_gambler )->do_fold( this_gambler );
   return;
}
void do_leave()  {
   if ( environment( this_gambler )->query_status() )
      tell_room( environment( this_gambler ), "The imp gently takes the "
                 "cards from " + this_gambler->short() + ", props " +
                 this_gambler->query_objective() +
                 " against the wall, and returns to the corner.\n" );
   else
      tell_room( environment( this_gambler ), "The imp props " +
                 this_gambler->short() + " against the wall and "
                 "returns to the corner.\n" );
   environment( this_gambler )->do_leave( this_gambler );
   return;
}
void do_check()  {
   tell_room( environment( this_gambler ), "The imp says, \"Time's up!\"\n" );
   environment( this_gambler )->do_check();
   return;
}
void do_idle()  {
   tell_room( environment( this_gambler ), "The imp announces, \"Time's up!  "
              "Continue without " + this_gambler->query_short() +
              ".\"\n" );
   tell_room( environment( this_gambler ), "The imp whispers something to " +
              this_gambler->query_short() + ".\n" );
   tell_object( this_gambler, "The imp whispers to you, \"If you can get "
                "some money before the cards are dealt, you can still "
                "play.\"\n" );
   environment( this_gambler )->sit_out( this_gambler );
   return;
}
void do_death()  {
   tell_object( this_gambler, "As you breathe your last, one of the imps "
                "leaps on your head screaming, \"Dead people are not allowed "
                "to play!\"\n" );
   tell_room( environment( this_gambler ), "As " +
              this_gambler->short() + " keels over, one of the imps "
              "leaps on " + this_gambler->query_possessive() +
              " head and screeches, \"Dead people are not allowed to "
              "play!\"\n", this_gambler );
   environment( this_gambler )->do_leave( this_gambler );
   this_gambler->do_death();
   return;
}
void dest_poker_shadow()  {
   call_out( "zap", 0 );
   return;
}
void zap()  {
   destruct( this_object() );
   return;
}
void prepare_to_leave()  {
   call_out( "do_leave", 30 );
   return;
}
void prepare_to_fold( int delay )  {
   call_out( "do_fold", delay );
   return;
}
void prepare_to_check( int delay )  {
   call_out( "do_check", delay );
   return;
}
void prepare_to_idle( int delay )  {
   call_out("do_idle", delay);
   return;
}
void cancel_fold()  {
   int i;
   i = 0;
   while( remove_call_out( "do_fold" )  != -1  ||
          remove_call_out( "do_check" ) != -1  ||
          remove_call_out( "do_idle" )  != -1   )  i = 1;
   if ( i )
      tell_room( environment( this_gambler ), "The imp nods, puts away its "
                 "hourglass, and returns to the corner.\n" );
   return;
}
void run_away()  {
   if ( previous_object() == find_object( FEAR ) )
      tell_object( this_player( 1 ), "One of the imps screeches, \"Quit "
                   "trying to scare " + this_gambler->short() +
                   "away!\"\n" );
   else this_gambler->run_away();
   return;
}
void add_effect( string eff, int duration )  {
   if ( eff == BLIND )  {
      write( "One of the imps jumps up and pokes you in the eyes screaming, "
             "\"How do YOU like it?\"\n" );
      say( "One of the imps pokes " + this_player()->query_short() + "in the "
           "eyes screaming, \"How do YOU like it?\"\n" );
   }
   else this_gambler->add_effect( eff, duration );
   return;
}
void event_quit(object me)  {
   environment( this_gambler )->event_exit( this_gambler, 0, 0 );
   return;
}

==================================================
FILE: shadows/misc/surface.c
==================================================

object shadowed, surface;
void setup_shadow( object thing1, object thing2 ) {
  shadow( thing1, 1 );
  shadowed = thing1;
  surface = thing2;
}
object query_shadowed( object thing ) {
  if ( thing == this_object() ) return shadowed;
  return (object)thing->query_shadowed( thing );
}
object *find_inv_match( string words ) {
  object *things;
  things = (object *)shadowed->find_inv_match( words );
  if ( surface )
    things += (object *)surface->find_inv_match( words );
  else
    call_out( "destruct_shadow", 1, this_object() );
  return things;
}
void destruct_shadow( object thing ) {
  if ( thing == this_object() ) destruct( this_object() );
  else thing->destruct_shadow( thing );
}

==================================================
FILE: shadows/misc/surrender_shadow.c
==================================================

#include <player.h>
int protecting;
string protector;
object player;
object *allowed = ({ });
void setup_shadow(object thing, object *victors)
{
  string *bits;
  protector = 0;
  if (environment(thing)) {
    bits = explode(file_name(environment(thing)), "/") - ({ "", "." });
    if (sizeof(bits) > 1 && bits[0] == "d") {
      object mast;
      mast = load_object(implode(bits[0..1] + ({ "master" }), "/"));
      if (mast)
        protector = mast->query_protector_string();
    }
  }
  if (!protector) protector = "The Rules of Fair Play";
  shadow( thing, 1 );
  player = thing;
  protecting = 1;
  call_out( "dest_surrender_shadow", 60 * 5 );
  allowed = victors;
}
int can_be_nasty()
{
  object who;
  object *inv;
  if (!protecting)
    return 1;
  if (!environment(player))
    return 1;
  inv = all_inventory(environment(player));
  foreach (who in allowed)
    if (member_array(who, inv) != -1)
      return 0;
  return 1;
}
string query_surrender_protector() { return protector; }
void zap_surrender_shadow() {
   protecting = 0;
   tell_object( player, "You lose "+ protector +"'s protection.\n" );
   call_out( "dest_surrender_shadow", 1 );
}
int adjust_hp( int number, object thing, object weapon, string attack ) {
   if ( ( number > 0 ) || !protecting ||
       !thing || !pk_check(thing, player ) || player == this_player() )
      return (int)player->adjust_hp( number, thing, weapon, attack );
   return (int)player->query_hp();
}
int set_hp( int number, object thing ) {
   int current;
   current = (int)player->query_hp();
   if (number > current || !protecting || !thing)
      return (int)player->set_hp( number, thing );
   return current;
}
int cannot_walk()
{
  if (!can_be_nasty()) {
    notify_fail("You can't leave while your subduer is here.\n");
    return 1;
  }
  zap_surrender_shadow();
  return player->cannot_walk();
}
int attack_by( object thing ) {
   if (!protecting)
      return (int)player->attack_by( thing );
   tell_object( thing, (string)player->the_short() +
         " is protected from combat by "+ protector +".\n" );
   tell_object( player, "You are protected from combat by "+
         protector +".\n" );
   thing->stop_fight( player );
   return 0;
}
int attack_ob( object thing ) {
  if (!can_be_nasty())
    return 0;
  zap_surrender_shadow();
  return (int)player->attack_ob( thing );
}
int query_unambushable() { return 1; }
void do_ambushed() {
   write( protector +" stops you from harming "+
         (string)player->the_short() +".\n" );
   tell_object( player, protector +" stops "+
         (string)this_player()->the_short() +" from harming you.\n" );
}
int no_offense() {
  if (!can_be_nasty())
    return 1;
  zap_surrender_shadow();
  return (int)player->no_offense();
}
mixed query_property( string word ) {
  if (protecting && word == "no attack")
    return 1;
  return (mixed)player->query_property( word );
}
int query_player_killer() {
   return 0;
}
int command_shadowed( string verb, string args ) {
  if ( member_array( verb, ({ "cast", "scathe" }) ) == -1 )
    return (int)player->command_shadowed( verb, args );
  if (!can_be_nasty())
    return notify_fail("You can't do that while you're subdued\n");
  zap_surrender_shadow();
  return (int)player->command_shadowed( verb, args );
}
varargs int adjust_xp( int number, int shared ) {
#ifdef DEBUG
  log_file( "PROTECTED", ctime( time() ) +": "+ (string)player->query_name() +
         " gained "+ number +"xp ["+ implode( map_array( previous_object( -1 ),
         (: file_name( $1 ) :) ), ", " ) +"]\n" );
#endif
   return (int)player->adjust_xp( number, shared );
}
varargs int add_skill_level( string skill, int lvl, mixed exp ) {
   string what;
   if ( !exp )
      exp = previous_object();
   if ( objectp( exp ) )
      what = " from "+ file_name( exp );
   else
      what = " for "+ exp +"xp";
#ifdef DEBUG
   log_file( "PROTECTED", ctime( time() ) +": "+ (string)player->query_name() +
         " gained "+ lvl +" in "+ skill + what +" ["+
         implode( map_array( previous_object( -1 ), (: file_name( $1 ) :) ),
         ", " ) +"]\n" );
#endif
   return (int)player->add_skill_level( skill, lvl, exp );
}
int test_remove(object thing, int flag, mixed dest)
{
  allowed -= ({ 0 });
  if (member_array(this_player(), allowed) != -1)
    return 1;
  else
    return player->test_remove(thing, flag, dest);
}
int allowed_to_loot(object who, object obj)
{
  if (member_array(who, allowed) != -1) {
    object wb;
    if (!obj)
      return 1;
    wb = obj->query_worn_by();
    if (wb == player && player->remove_armour(obj))
      return 0;
    return 1;
  } else
    return player->allowed_to_loot(who);
}
void dest_surrender_shadow()
{
  if (!player->query_property("player")) {
    player->move("/room/rubbish", "",
      player->one_short() + " runs off to recuperate.");
  } else {
    tell_object(player, "You feel that you can leave now.\n");
  }
  destruct(this_object());
}
int query_sanctuary()
{
  if (protecting) return 1;
  else return player->query_sanctuary();
}
int do_quit()
{
  if (!can_be_nasty()) {
    write("You cannot quit while your subduer is here.\n");
    return 1;
  }
  return player->do_quit();
}
int quit_alt()
{
  if (!can_be_nasty()) {
    write("You cannot quit while your subduer is here.\n");
    return 1;
  }
  return player->do_quit();
}

==================================================
FILE: shadows/misc/team.c
==================================================

#define TEAM "/obj/handlers/team"
object player;
void setup_shadow( object thing ) {
   shadow( thing, 1 );
   player = thing;
}
void destruct_team_shadow() { destruct( this_object() ); }
string extra_score() {
   string team;
   team = (string)TEAM->query_group( player );
   if ( !team ) {
      call_out( "destruct_team_shadow", 1 );
      return (string)player->extra_score();
   }
   return (string)player->extra_score() +
         "You are a team member of "+ team +".\n";
}
varargs int adjust_xp( int number, int shared ) {
   int plvl, olvl, divisor;
   string team;
   object other, *others;
   if ( ( number < 0 ) || !shared )
      return (int)player->adjust_xp( number );
   team = (string)TEAM->query_group( player );
   if ( !team ) {
      call_out( "destruct_team_shadow", 1 );
      return (int)player->adjust_xp( number );
   }
   others = (object *)TEAM->query_members( team );
   if ( !others ) {
      call_out( "destruct_team_shadow", 1 );
      return (int)player->adjust_xp( number );
   }
   if ( sizeof( others ) == 1 )
      return (int)player->adjust_xp( number );
   divisor = (sizeof(others)-1/ 2);
   if(divisor)
     number /= divisor;
   plvl = (int)player->query_level() / 2;
   foreach ( other in others - ({ player }) )
      if ( objectp( other ) ) {
         if ( environment( other ) != environment( player ) )
            continue;
         olvl = (int)other->query_level();
         if ( ( olvl > plvl ) || !plvl )
            other->adjust_xp( number, 0 );
         else
            other->adjust_xp( ( number * ( 1 +
                  ( 99 * olvl ) / plvl ) ) / 100, 0 );
      }
   return (int)player->adjust_xp(number * divisor);
}
varargs int add_skill_level( string skill, int lvl, mixed exp ) {
  int diff_0, diff_1, diff, width_0, width;
  string team;
  object other, *others;
  if ( ( lvl != 1 ) || intp(exp) ||
       (objectp(exp) && base_name(exp) == base_name(this_object())))
    return (int)player->add_skill_level( skill, lvl, exp );
  if(!exp)
    exp = previous_object();
  team = (string)TEAM->query_group( player );
  if ( !team ) {
    call_out( "destruct_team_shadow", 1 );
    return (int)player->add_skill_level( skill, lvl, exp );
  }
  others = (object *)TEAM->query_members( team );
  if ( !others ) {
    call_out( "destruct_team_shadow", 1 );
    return (int)player->add_skill_level( skill, lvl, exp );
  }
  if(skill == "other.perception" || skill[<7..] == ".points")
    return (int)player->add_skill_level( skill, lvl, exp );
  if ( sizeof( others ) == 1 )
    return (int)player->add_skill_level( skill, lvl, exp );
  if(!player->add_skill_level(skill, lvl, exp))
     return 0;
  diff_0 = (int)player->query_skill_bonus(skill);
  diff_1 = (int)player->query_skill(skill);
  width_0 = (int)player->stat_modify( 25 * 25, skill );
  foreach ( other in others - ({ player }) ) {
    if (!objectp( other ) )
      continue;
    if ( environment( other ) != environment( player ) )
      continue;
    if(diff_0 - (int)other->query_skill_bonus(skill) >
       diff_1 - (int)other->query_skill(skill))
      diff = diff_0 - (int)other->query_skill_bonus( skill );
    else
      diff = diff_1 - (int)other->query_skill(skill);
    width = (int)other->stat_modify( width_0, skill );
    if (random( width + diff * diff + sqrt(other->query_skill(skill)))
        < (width/2) &&
        other->add_skill_level( skill, lvl, this_object())) {
      tell_object( other, "%^YELLOW%^By watching "+
                   (string)player->the_short() +
                   ", you feel you've learnt something.%^RESET%^\n" );
    }
  }
  return 1;
}

==================================================
FILE: shadows/misc/water.c
==================================================

#include <move_failures.h>
#define SWIMMING_SKILL "other.movement.swimming"
#define STAMINA_SKILL "other.health"
#define BUOYANT_PROP "buoyancy"
#define ANCHOR_PROP "anchor"
#define GILLS_PROP "gills"
#define TROLL_RACE "troll"
object swimmer;
int bonus, buoyancy, drown_stage, swimming = 0, recheck_delay = -1;
string sweep_dir = "";
void calc_swim_bonus();
int abs( int i );
void test_sweep();
void test_float();
void test_drown();
string sweep_string( mixed *dest_other_info, int pos );
varargs int exit_command( string word, mixed verb, object thing );
int abs( int i )  {  return i < 0 ? -i : i;  }
int start_floating();
int start_swimming();
void setup_shadow( object this_swimmer )  {
   shadow( this_swimmer, 1 );
   swimmer = this_swimmer;
   calc_swim_bonus();
}
void event_enter( object ob, string message, object from )  {
   int old_bonus, old_buoy;
   if (swimmer) {
      swimmer->event_enter( ob, message, from );
   }
   old_bonus = bonus;
   old_buoy = buoyancy;
   calc_swim_bonus();
   if ( bonus != old_bonus )  test_sweep();
   if ( buoyancy != old_buoy )  {
      buoyancy += (int)ob->query_property( BUOYANT_PROP );
      test_float();
   }
   return;
}
void event_exit( object ob, string message, object to )  {
   int old_bonus, old_buoy;
   if (swimmer) {
      swimmer->event_exit(ob, message, to);
   }
   old_bonus = bonus;
   old_buoy = buoyancy;
   calc_swim_bonus();
   if ( bonus != old_bonus )  test_sweep();
   if ( buoyancy != old_buoy )  {
      buoyancy -= (int)ob->query_property( BUOYANT_PROP );
      test_float();
   }
   return;
}
void calc_swim_bonus()  {
   float pct;
   object *held;
   if ( living( swimmer )  &&
        ( held = (object *)swimmer->query_holding() ) )  {
      swimmer->calc_burden();
      bonus = (int)swimmer->query_skill_bonus( SWIMMING_SKILL ) /
                            ( sizeof( held - (object *)({ 0 }) ) + 1 );
      buoyancy = bonus - (int)swimmer->query_loc_weight() +
                      (int)swimmer->query_property( BUOYANT_PROP );
      if ( (string)swimmer->query_race() == TROLL_RACE )  buoyancy -= 300;
      if ( buoyancy < 0  &&  bonus )  {
         pct = -buoyancy / bonus;
         if ( pct < 1.0 )  {
            bonus += buoyancy;
            buoyancy = 0;
         }
         else  {
            pct -= 1.0;
            buoyancy *= pct;
            bonus = 0;
         }
      }
   } else  {
      if (swimmer) {
         bonus = (int)swimmer->query_property( ANCHOR_PROP );
         buoyancy = (int)swimmer->query_property( BUOYANT_PROP ) -
                    (int)swimmer->query_weight();
      }
   }
   return;
}
void add_property( string prop, mixed val, int time )  {
   if (swimmer) {
      swimmer->add_property( prop, val, time );
   }
   if ( prop == GILLS_PROP  &&  val > 0 )  remove_call_out("do_drown");
   if ( prop == BUOYANT_PROP  &&  val )  {
      calc_swim_bonus();
      test_float();
   }
   return;
}
void remove_property( string prop )  {
   if (swimmer) {
     swimmer->remove_property( prop );
   }
   if ( prop == GILLS_PROP )  test_drown();
   else if ( prop == BUOYANT_PROP )  {
      calc_swim_bonus();
      test_float();
   }
   return;
}
int add_skill_level( string skill, int lev )  {
   int lvl;
   if ( living(swimmer) )  {
      lvl = (int)swimmer->add_skill_level( skill, lev );
      if ( skill == SWIMMING_SKILL  &&  lev )  {
         calc_swim_bonus();
         test_sweep();
         test_float();
      }
      return lvl;
   }
   else return 0;
}
varargs int query_skill_bonus( string skill, int use_base_stats ) {
  if( ( skill == SWIMMING_SKILL ) &&
      ( !use_base_stats ) &&
      ( query_verb() != "skills" ) ) {
    calc_swim_bonus();
    return bonus;
  }
  return swimmer->query_skill_bonus(skill, use_base_stats);
}
int query_swim_bonus()  {  return bonus;  }
int query_buoyancy()  {  return buoyancy;  }
void test_sweep()  {
   mapping flows, possible;
   int total_flow, r, f, s, flow_rate;
   string *dirs, dir, *dest_dir_info;
   object room;
   s = find_call_out( "do_sweep" );
   room = environment( swimmer );
   flows = (mapping)room->query_flows();
   dest_dir_info = (string *)room->query_dest_dir();
   f = ( 300 - ( evaluate( flows[ sweep_dir ] ) - swimming * bonus ) ) / 30;
   if ( f < 0 )  f = 0;
   f += room->query_min_sweep_delay( sweep_dir );
   if ( s > f )  {
      remove_call_out( "do_sweep" );
      call_out( "do_sweep", f,
                dest_dir_info[ member_array( sweep_dir,
                                             dest_dir_info ) + 1 ] );
   }
   else if ( s == -1  ||
             (int)room->query_flow( sweep_dir ) - swimming * bonus <= 0 )  {
      remove_call_out( "do_sweep" );
      dirs = keys( flows );
      total_flow = 0;
      possible = ([ ]);
      foreach ( dir in dirs )  {
         flow_rate = evaluate( flows[ dir ] );
         if ( ( f = flow_rate - swimming * bonus ) > 0  &&  flow_rate > 0)  {
            total_flow += f;
            possible += ([ dir : f ]);
         }
      }
      r = random( total_flow );
      dirs = keys( possible );
      total_flow = 0;
      foreach ( dir in dirs )  {
         if ( r < total_flow + possible[ dir ] )  {
            sweep_dir = dir;
            f = ( 300 - possible[ dir ] ) / 30;
            if ( f < 0 )  f = 0;
            f += room->query_min_sweep_delay( dir );
            call_out( "do_sweep", f,
                      dest_dir_info[ member_array( sweep_dir,
                                                   dest_dir_info ) + 1 ] );
            return;
         }
         else total_flow += possible[ dir ];
      }
   }
   return;
}
void test_float()  {
   object room;
   int s, t;
   room = environment( swimmer );
   if ( buoyancy < 0 )  {
      remove_call_out( "do_rise" );
      s = find_call_out( "do_sink" );
      if ( !( room->query_bottom() ) )  {
         t = (300 + buoyancy) / 30;
         if ( s > t )  {
            remove_call_out( "do_sink" );
            s = -1;
         }
         if ( s == -1 )  {
            call_out( "do_sink", t + room->query_min_sweep_delay( room->
                         query_down_dir() ) );
            swimmer->add_property( "there",
                                   (string)room->query_nonfloat_mess() );
         }
      }
      else  {
         swimmer->add_property( "there", (string)room->query_bottom_mess() );
         if ( s > -1 )  remove_call_out( "do_sink" );
      }
   }
   else if ( buoyancy > bonus )  {
      remove_call_out( "do_sink" );
      s = find_call_out( "do_rise" );
      if ( !( room->query_surface() ) )  {
         t = (300 - buoyancy) / 30;
         if ( s > t )  {
            remove_call_out( "do_rise" );
            s = -1;
         }
         if ( s == -1 )  {
            call_out( "do_rise", t + room->query_min_sweep_delay( room->
                         query_up_dir() ) );
            swimmer->add_property( "there",
                                   (string)room->query_float_mess() );
         }
      }
      else if ( s > -1 )  remove_call_out( "do_rise" );
   }
   else  {
      remove_call_out( "do_rise" );
      remove_call_out( "do_sink" );
      swimmer->add_property( "there", (string)room->query_float_mess() );
   }
   return;
}
void test_drown()  {
   int delay;
   if ( environment( swimmer )->query_surface() )
      remove_call_out("do_drown");
   else if ( find_call_out( "do_drown" ) == -1  &&
             !( swimmer->query_property( GILLS_PROP ) ) )  {
      delay = (int)swimmer->query_skill_bonus( STAMINA_SKILL ) / 20;
      if ( delay < 15 )  delay = 15;
      call_out( "do_drown", delay );
      drown_stage = 0;
   }
   return;
}
void do_sweep( string dest )  {
   mixed *dest_other_info;
   object room;
   room = environment(swimmer);
   if ( environment( swimmer )->query_terrain() )
      environment( swimmer )->set_destination( sweep_dir );
   dest_other_info = (mixed *)room->query_dest_other();
   if ( !( swimmer->query_property("player") ) )
      swimmer->move( dest,
                     replace_string( (string)room->query_sweep_in_mess(),
                                     "$F",sweep_string( dest_other_info,
                                        member_array( sweep_dir,
                                          dest_other_info ) + 1 ) ),
                     replace_string( (string)room->query_sweep_out_mess(),
                                     "$T", sweep_dir ) );
   else  {
      tell_object( swimmer, "The current pulls you " + sweep_dir + ".\n" );
      swimmer->move_with_look( dest,
                               replace_string( (string)room->
                                               query_sweep_in_mess(), "$F",
                                               sweep_string( dest_other_info,
                                                 member_array( sweep_dir,
                                                   dest_other_info ) + 1 ) ),
                               replace_string( (string)room->
                                               query_sweep_out_mess(), "$T",
                                               sweep_dir ) );
   }
   return;
}
void do_sink()  {
   string dir;
   mixed *dest_other_info;
   int i;
   object room;
   room = environment(swimmer);
   dir = (string)room->query_down_dir();
   if ( environment( swimmer )->query_terrain() )
      environment( swimmer )->set_destination( dir );
   dest_other_info = (mixed *)room->query_dest_other();
   if ( ( i = member_array( dir, dest_other_info ) ) > -1 )  {
      if ( !( swimmer->query_property("player") ) )
         swimmer->move( dest_other_info[ i + 1 ][0],
                        replace_string( (string)room->query_sink_in_mess(),
                                        "$F", sweep_string( dest_other_info,
                                          i + 1 ) ),
                        replace_string( (string)room->query_sink_out_mess(),
                                        "$T", dir ) );
      else  {
         tell_object( swimmer, "You sink toward the bottom.\n" );
         swimmer->move_with_look( dest_other_info[ i + 1 ][0],
                                  replace_string( (string)room->
                                                          query_sink_in_mess(),
                                        "$F", sweep_string( dest_other_info,
                                          i + 1 ) ),
                                  replace_string( (string)room->
                                                     query_sink_out_mess(),
                                                  "$T", dir ) );
      }
   }
   return;
}
void do_rise()  {
   string dir;
   mixed *dest_other_info;
   int i;
   object room;
   room = environment( swimmer );
   dir = (string)room->query_up_dir();
   if ( environment( swimmer )->query_terrain() )
      environment( swimmer )->set_destination( dir );
   dest_other_info = (mixed *)room->query_dest_other();
   if ( ( i = member_array( dir, dest_other_info ) ) > -1 )  {
      if ( !( swimmer->query_property("player") ) )
         swimmer->move( dest_other_info[ i + 1 ][0],
                        replace_string( (string)room->query_float_in_mess(),
                                        "$F", sweep_string( dest_other_info,
                                          i + 1 ) ),
                        replace_string( (string)room->query_float_out_mess(),
                                        "$T", dir ) );
      else  {
         tell_object( swimmer, "You drift toward the surface.\n" );
         swimmer->move_with_look( dest_other_info[ i + 1 ][0],
                                  replace_string( (string)room->
                                                     query_float_in_mess(),
                                     "$F", sweep_string( dest_other_info,
                                       i + 1 ) ),
                                  replace_string( (string)room->
                                                     query_float_out_mess(),
                                                  "$T", dir ) );
      }
   }
   return;
}
void do_drown()  {
   string *exits, up;
   int delay;
   delay = (int)swimmer->query_skill_bonus( STAMINA_SKILL ) / 5;
   if ( delay < 15 )  delay = 15;
   switch ( drown_stage )  {
      case 0:
         tell_object( swimmer, "Your lungs start to feel a bit heavy.\n" );
         tell_room( environment( swimmer ), (string)swimmer->query_short() +
                    " begins to look a bit uncomfortable.\n", swimmer );
         call_out( "do_drown", delay );
         break;
      case 1:
         tell_object( swimmer, "Your lungs are starting to burn.\n" );
         tell_room( environment( swimmer ), (string)swimmer->query_short() +
                    " starts to look slightly blue.\n", swimmer );
         call_out( "do_drown", delay );
         break;
      case 2:
         tell_object( swimmer, "Your lungs are fairly bursting.\n" );
         tell_room( environment( swimmer ), (string)swimmer->query_short() +
                    " begins to look panicky.\n", swimmer);
         call_out( "do_drown", delay );
         break;
      default:
         swimmer->adjust_hp( ( 2 - drown_stage ) * 5 *
                             ( 30 - (int)swimmer->query_con() ) );
         if ( swimmer->query_hp() > 0 )  {
            call_out( "do_drown", delay );
            exits = (string *)environment( swimmer )->query_dest_dir();
            if ( member_array( up = (string)environment( swimmer )->
                                            query_up_dir(),
                               exits ) > -1 )  {
               tell_object( swimmer, "You panic and try to flee for the "
                            "surface.\n" );
               tell_room( environment( swimmer ),
                          (string)swimmer->query_short() + " panics and madly "
                          "tries to flee for the surface.\n", swimmer );
               swimmer->exit_command( up );
            }
            else  {
               up = exits[ random( sizeof( exits ) ) / 2 ];
               tell_object( swimmer, "You panic and try to flee " + up +
                            ".\n" );
               tell_room( environment( swimmer ),
                          (string)swimmer->query_short() + " panics and tries "
                          "to flee " + up + ".\n", swimmer );
               swimmer->exit_command( up );
            }
         }
         else swimmer->attack_by( environment( swimmer ) );
         break;
   }
   ++drown_stage;
   return;
}
void do_soak()  {
   swimmer->add_effect("/std/effects/other/wetness", swimmer->query_weight());
   swimmer->do_soak();
}
void cancel_sweep()  {
   remove_call_out( "do_sweep" );
   sweep_dir = "";
   return;
}
void dest_water_shadow()  {
   remove_call_out( "do_sweep" );
   remove_call_out( "do_rise" );
   remove_call_out( "do_sink" );
   remove_call_out( "do_drown" );
   remove_call_out( "do_soak" );
   remove_call_out( "test_again" );
   if (swimmer) {
      swimmer->remove_property("there");
   }
   destruct( this_object() );
   return;
}
object find_water_shadow()  {  return this_object();  }
int command_shadowed( string verb, string args )  {
   string my_mess, others_mess;
   my_mess = 0;
   if ( !( environment( swimmer )->query_surface() ) )  {
      if ( verb == "say"  ||  verb == "'" )  {
         my_mess = "You try to talk, but only generate some bubbles.";
         others_mess = (string)swimmer->query_short() + " emits a 'glub glub' "
                       "noise.";
         if ( !( swimmer->query_property( GILLS_PROP ) ) )  {
            my_mess += "  In the process you inhale some water.\n";
            others_mess += "  In the process, " +
                           (string)swimmer->query_pronoun() + " inhales "
                           "some water.\n";
            ++drown_stage;
         }
         else  {
            my_mess += "\n";
            others_mess += "\n";
         }
      }
      else if ( verb == "lsay" )  {
         my_mess = "You try to speak loudly, but can only produce a lot of "
                   "bubbles.";
         others_mess = (string)swimmer->query_short() + " produces a sort "
                       "of 'glooob gloob' sound.";
         if ( !( swimmer->query_property( GILLS_PROP ) ) )  {
            my_mess += "  You also inhale a fair amount of water.\n";
            others_mess += "  " + (string)swimmer->query_pronoun() + "also "
                           "inhales a fair amount of water.\n";
            drown_stage += 2;
         }
         else  {
            my_mess += "\n";
            others_mess += "\n";
         }
      }
      else if ( verb == "shout" )  {
         my_mess = "You try to shout, but your main effects are a muffled "
                   "'arrrble' and a lot of bubbles.";
         others_mess = (string)swimmer->query_short() + " open " +
                       (string)swimmer->query_possessive() + " mouth and "
                       "emits a muffled 'arrrble' noise.";
         if ( !( swimmer->query_property( GILLS_PROP ) ) )  {
            my_mess += "  You also inhale about a lungful of water.\n";
            others_mess += "  " + (string)swimmer->query_pronoun() + " sucks "
                           "in a large amount of water in the process.\n";
            drown_stage += 3;
         }
         else  {
            my_mess += "\n";
            others_mess += "\n";
         }
      }
   }
   if ( my_mess )  {
      tell_object( swimmer, my_mess );
      tell_object( environment( swimmer ), others_mess );
      return 1;
   }
   else return (int)swimmer->command_shadowed( verb, args );
}
int *set_hold( object ob, int pos )  {
   int *other, old_bonus;
   old_bonus = bonus;
   other = (int *)swimmer->set_hold( ob, pos );
   calc_swim_bonus();
   if ( old_bonus != bonus )  {
      test_sweep();
      test_float();
   }
   return other;
}
void do_death( object thing )  {
   if (swimmer) {
      swimmer->do_death( thing );
   }
   remove_call_out( "do_sweep" );
   remove_call_out( "do_rise" );
   remove_call_out( "do_sink" );
   remove_call_out( "do_drown" );
   remove_call_out( "do_soak" );
   swimmer->remove_property("there");
   return;
}
void remove_ghost()  {
  swimmer->remove_ghost();
  environment( swimmer )->event_enter( swimmer, "", 0 );
  return;
}
int *set_unhold( object ob )  {
   int *other, old_bonus;
   old_bonus = bonus;
   other = (int *)swimmer->set_unhold( ob );
   calc_swim_bonus();
   if ( old_bonus != bonus )  {
      test_sweep();
      test_float();
   }
   return other;
}
int move( mixed dest, string messin, string messout )  {
   string where, *dest_dir_info;
   int pos;
   if ( !swimmer->query_property( "dead" )  &&  living( swimmer ) )  {
      if ( objectp( dest ) )  where = file_name( dest );
      else where = dest;
      dest_dir_info = (string *)environment( swimmer )->query_dest_dir();
      pos = member_array( where, dest_dir_info ) - 1;
      if ( pos > -1  &&
           !(int)environment( swimmer )->
                    attempt_exit( dest_dir_info[ pos ], swimmer ) )  {
         notify_fail( "" );
         return MOVE_NO_DROP;
      }
   }
   return swimmer->move( dest, messin, messout );
}
int do_float()  {
   if ( !swimming )  {
      tell_object( swimmer, "You are already drifting with the current.\n" );
   }
   else  {
      tell_object( swimmer, "You stop resisting the current.\n" );
      swimming = 0;
      test_sweep();
   }
   return 1;
}
int do_swim()  {
   if ( swimming )  {
      tell_object( swimmer, "You are already fighting the current.\n" );
   }
   else  {
      tell_object( swimmer, "You start to resist the current.\n" );
      swimming = 1;
      test_sweep();
   }
   return 1;
}
void test_again()  {
   test_float();
   test_sweep();
   call_out( "test_again", recheck_delay );
}
void update_recheck( int time_out )  {
   int t;
   recheck_delay = time_out;
   if ( time_out == -1 )  {
      remove_call_out( "test_again" );
   }
   else if ( ( t = find_call_out( "test_again" ) ) == -1 )  {
      call_out( "test_again", time_out );
   }
   else if ( time_out < t )  {
      remove_call_out( "test_again" );
      call_out( "test_again", time_out );
   }
   return;
}
string sweep_string( mixed *dest_other_info, int pos )  {
   if ( pointerp( dest_other_info[pos][5] ) )  {
      return dest_other_info[pos][5][1];
   }
   else  {
      return dest_other_info[pos][5];
   }
}

==================================================
FILE: shadows/fighting/bob.c
==================================================

#include <tasks.h>
#include <weapon.h>
#define QUEST_MAX 570
#define DIFFICULTY 100
inherit "/std/effect_shadow";
string *data;
void set_data( string *words ) { data = words; }
mapping special_attack( object target ) {
    int damage;
    int skill;
    int difficulty;
    object *args;
    args = arg();
    if((object)environment(target) != (object)environment(player)) {
        tell_object(player, "Where did "+target->short()+" go?\n");
        remove_this_effect();
        return ([ ]);
    }
    if (!sizeof(match_objects_for_existence("bucket", ({ this_player() }))) &&
        !sizeof(match_objects_for_existence("apple", ({ this_player() })))) {
       add_failed_mess("You must have an apple and a bucket to use bob.\n");
       return 0;
    }
    difficulty += target->query_str() * 10;
    skill = (int)player->query_skill_bonus("fighting.combat.melee."+ data[1]);
    damage = 4 + sqrt( damage ) / 2;
    damage = 2 * damage + 8 * (random(damage)) +
             2 * damage + 8 * (random(damage));
    switch( (int)TASKER->perform_task(player, "fighting.combat.melee."+ data[1],
        difficulty, TM_COMMAND)) {
    case AWARD :
        tell_object( player, "%^YELLOW%^"+ replace( ({ "You feel that "+
              "your skill with a bucket has increased.", "You feel "+
              "more able to use a bucket.", "You seem to be a step "+
              "closer to mastering a bucket." })[ random( 3 ) ],
            "$weapon$", ( args[ 1 ] == player ? "unarmed combat" :
              (string)args[ 1 ]->a_short() ) ) +"%^RESET%^\n" );
    case SUCCEED :
        tell_object( player, "You grab hold of " +
          (string)target->the_short() + "'s head and shove it down "
          "into the bucket.\nYou scream out 'Bob for this!'\n"
          "You try and drown " + target->the_short() + ".\n");
        tell_room( environment(player),
          player->the_short() + " grabs hold of " +
          (string)target->the_short() + "'s head and shoves it down "
          "into the bucket.\n" + player->the_short() +
          " scream out 'Bob for this!'\n" +
          player->the_short() + " tries to drown " + target->the_short() +
          ".\n", ({ player, }));
        set_arg(0);
        break;
    default:
        tell_object( player, "You manage to botch your use of a bucket.\n");
        remove_this_effect();
        return 0;
    }
#ifdef DEBUG
    tell_creator("ceres", sprintf("Crush: player: %s, weapon: %s (%d), Diff: %d, Dam: %d Ski: %d\n",
        player->query_name(),
        args[ 1 ]->query_name(),
        args[1]->query_enchant(),
        difficulty, damage, skill));
#endif
    remove_this_effect();
    return ([ args[ 1 ] : ({ damage }) + data ]);
}
int tasking_done() { return 1; }
void event_death(object killed, object * others, object killer, string rmess,
                      string kmess) {
  object *args;
  player->event_death(killed, others, killer, rmess, kmess);
  args = arg();
  if ( killed == args[ 0 ] ) remove_this_effect();
}

==================================================
FILE: shadows/fighting/combat.c
==================================================

#include <obj_parser.h>
inherit "/std/effect_shadow";

==================================================
FILE: shadows/fighting/special_attack.c
==================================================

#include <tasks.h>
#define QUEST_MAX 570
#define INFORM
inherit "/std/effect_shadow";
string *data;
void set_data( string *words ) { data = words; }
mapping special_attack( object target ) {
   int i, damage, skill;
   object *args;
   mixed *attacks;
   args = arg();
   if (!args) {
      return 0;
   }
   if ( !data || ( (string)player->query_combat_attitude() != "offensive" ) ||
         ( target != args[ 0 ] ) || !args[ 1 ] ) {
      tell_object( player, "You lose the moment!\n" );
      set_arg( 0 );
      remove_this_effect();
      return ([ ]);
   }
   if ( ( (object)args[ 1 ]->query_wielded() != player ) &&
         ( args[ 1 ] != player ) ) {
      tell_object( player, "What did you do with "+
            (string)args[ 1 ]->the_short() +"?\n" );
      set_arg( 0 );
      remove_this_effect();
      return ([ ]);
   }
   if((object)environment(target) != (object)environment(player)) {
     tell_object(player, "Where did "+target->short()+" go?\n");
     remove_this_effect();
     return ([ ]);
   }
   attacks = (mixed *)args[ 1 ]->weapon_attacks( 100, target );
   if ( !sizeof( attacks ) )
   {
      return 0;
   }
   for ( i = 0; i < sizeof( attacks ); i += 4 ) {
      if (attacks[i + 2] == data[1] ||
            attacks[i + 2][0..sizeof(data[1])] == data[1] + "-")
        damage += attacks[ i ];
   }
   if ( !damage ) {
     tell_object( player, "You manage to botch your use of "+
                  ( args[ 1 ] == player ? "unarmed combat" :
                    (string)args[ 1 ]->the_short() ) +
                  " and barely launch a mediocre attack at "+
                  (string)target->the_short() +".\n" );
#ifdef INFORM
    event(environment(player), "inform", (string)player->query_name() +
          " special manoeuvre failed (no damage)", "combat");
#endif
     return 0;
   }
   skill = (int)player->query_skill_bonus( "fighting.combat.melee."+
         data[ 0 ] );
   switch( (int)TASKER->perform_task(player, "fighting.combat.melee."+data[0],
                                     damage, TM_COMMAND) ) {
      case AWARD :
        tell_object( player, "%^YELLOW%^"+ replace( ({ "You feel that "+
               "your skill with $weapon$ has increased.", "You feel "+
               "more able to use $weapon$.", "You seem to be a step "+
               "closer to mastering $weapon$." })[ random( 3 ) ],
               "$weapon$", ( args[ 1 ] == player ? "unarmed combat" :
               (string)args[ 1 ]->a_short() ) ) +"%^RESET%^\n" );
      case SUCCEED :
         tell_object( player, "You launch a powerful attack on "+
               (string)target->the_short() + ( args[ 1 ] == player ? "" :
               " with "+ (string)args[ 1 ]->the_short() ) +".\n" );
         damage = sqrt( ((damage*2/3)) * skill ) + ( damage * skill ) /
           QUEST_MAX;
#ifdef INFORM
    event(environment(player), "inform", (string)player->query_name() +
          " special manoeuvre success, damage: " +damage, "combat");
#endif
         break;
      default :
        damage = 1;
         tell_object( player, "You manage to botch your use of "+
               ( args[ 1 ] == player ? "unarmed combat" :
               (string)args[ 1 ]->the_short() ) +
               " and barely launch a mediocre attack at "+
               (string)target->the_short() +".\n" );
#ifdef INFORM
    event(environment(player), "inform", (string)player->query_name() +
          " special manoeuvre failed", "combat");
#endif
   }
   set_arg( 0 );
   remove_this_effect();
   return ([ args[ 1 ] : ({ damage }) + data ]);
}
int tasking_done() { return 1; }

==================================================
FILE: shadows/attached/single_shoulder.c
==================================================

#include "path.h"
inherit "/std/effect_shadow";
private int test_sash( object thing ) {
   return (string)thing->query_type() == "sash" &&
          sizeof(thing->query_pockets());
}
private int test_for_effect( object thing ) {
   return member_array( EFFECTS +"single_shoulder",
      (string *)thing->query_wear_effects() ) != -1;
}
void check_handicap() {
   int new_arg;
   mixed old_arg;
   object *things;
   things = (object *)player->query_wearing() - ({ 0 });
   old_arg = arg();
   if (objectp(old_arg)) {
      old_arg = 0;
   }
   new_arg = sizeof( filter_array( things, (: test_sash :), this_object() ) ) *
         sizeof( filter_array( things, (: test_for_effect :), this_object() ) );
   if ( !new_arg ) {
      remove_this_effect();
      return;
   }
   new_arg /= 2;
   if ( old_arg == new_arg ) {
      return;
   }
   player->adjust_bonus_dex( old_arg - new_arg );
   set_arg( new_arg );
}
void now_worn( object thing ) {
   player->now_worn( thing );
   if ( find_call_out( "check_handicap" ) == -1 ) {
      call_out( "check_handicap", 0 );
   }
}
void now_removed( object thing ) {
   player->now_removed( thing );
   if ( find_call_out( "check_handicap" ) == -1 ) {
      call_out( "check_handicap", 0 );
   }
}

==================================================
FILE: shadows/attached/talker_response.c
==================================================

class response {
    string  sender;
    string *triggers;
    string *responses;
    int     probability;
    int     delay;
}
inherit "/std/effect_shadow";
public          object  query_listener      ( );
public  varargs void    query_responses     ( string );
public  varargs void    add_respond_to_talker_with( string, string,
                                                        string *, int, int );
public          int     delete_response     ( string, string, string * );
public          void    receive             ( string, string, string,
                                                        object * );
public          void    process_response    ( string *, string * );
private varargs int     register_listener   ( object );
private         int     compare_arrays      ( mixed *, mixed *);
mapping responses = ([ ]);
object listener;
private varargs int register_listener(object target) {
  if(objectp(target)) {
    listener = target;
  }
  else
    listener = this_object()->arg_of(this_object()->
                                effects_matching("object.talker.response")[0]);
  if(!objectp(listener))
    this_object()->delete_effect(this_object()->
                                effects_matching("object.talker.response")[0]);
  return 1;
}
public object query_listener() {
  return listener;
}
public varargs void query_responses(string key) {
  if(stringp(key)) {
    class response *womble = responses[key];
    foreach(class response cabbage in womble) {
      printf("Channel: %s\n\tChatter: %s\n", key, cabbage->sender);
      printf("\tTrigger:\n");
      foreach(string trigger in cabbage->triggers)
        printf("\t\t\"%s\"\n",trigger);
      printf("\tResponse:\n");
      foreach(string resp in cabbage->responses)
        printf("\t\t\"%s\"\n", resp);
      printf("\tProbability:\t%d\n\tDelay:\t%d\n\n",
             cabbage->probability, cabbage->delay);
    }
    return;
  } else {
    foreach(string nextkey in keys(responses)) {
      query_responses(nextkey);
    }
    return;
  }
}
public varargs void add_respond_to_talker_with(string channel, string sender,
                                               string *trigger,
                                               string *response, int probability,
                                               int delay ) {
  class response new_item;
  if(!listener)
    register_listener();
  if (!channel || !sender || !trigger || !response ){
    listener->call_out("do_command", 3, "'Err. I haven't been setup "
                       "correctly in regards to my talker!");
    return;
  }
  channel = lower_case(channel);
  if (undefinedp(responses[channel]))
    responses[channel] = ({});
  else {
      foreach(class response item in responses[channel]) {
        if(item->sender == sender && item->triggers - trigger == ({}) &&
           item->responses - response == ({}) && item->probability == probability)
            return;
      }
  }
  if(!probability)
    probability = 10;
  if(!delay)
    delay = 1;
  if(delay == -1)
    delay = 0;
  if(probability > 100)
    probability = 100;
  new_item = new(class response, sender : sender, triggers : trigger,
                 responses : response, probability : probability, delay : delay);
  responses[channel] += ({ new_item });
  return;
}
public int delete_response( string channel, string sender, string *triggers ) {
  if( sizeof(responses[channel]) !=
      sizeof(responses[channel]   = responses[channel] -
             filter(filter(responses[channel], (: $1->sender == $(sender) :)),
                    (: compare_arrays( $1->triggers, $(triggers) ) :)) ) )
    return 1;
  return 0;
}
public void receive(string channel, string sender, string text,
                    object *receivers) {
  class response response;
  if(!listener) {
    register_listener();
    return;
  }
  if(sizeof(responses) && listener->query_name() != lower_case(sender) ) {
    if(member_array(lower_case(channel), keys(responses)) > -1 &&
       responses[channel]) {
      foreach( response in responses[channel]) {
        if(response->sender == sender ||
           response->sender == "anyone" ) {
          foreach( string trigger in response->triggers ) {
            if(regexp(text, trigger)) {
              if(random(100) < response->probability) {
                call_out("process_response", response->delay,
                         response->responses,
                         ({ channel, sender, text }));
              }
              break;
            }
          }
        }
      }
    }
  } else {
    query_shadowing(this_object())->receive(channel, sender, text, receivers);
  }
}
private int compare_arrays( mixed *ar1, mixed *ar2 ) {
  int i;
  if ( !ar1 && !ar2 )
    return 0;
  if ( sizeof( ar1 ) != sizeof( ar2 ) )
    return 1;
  i = sizeof( ar1 );
  while ( i-- ) {
    if ( ar1[ i ] != ar2[ i ] ) {
      return 1;
    }
  }
  return 0;
}
public void process_response( string *commands, string *arguments) {
  if(!query_listener()) return;
  foreach(string response in commands) {
    if(response[0] == '#') {
      if(function_exists(response[1..], listener)) {
        call_other( listener, ({ response[1..] }) + arguments);
      }
    } else {
      listener->do_command(response);
    }
  }
}

==================================================
FILE: house/tworoomflat/flatN.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/flat%N%");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("front room");
   set_base_desc("a small and cosy front room" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit("out", %out%, "door");
   modify_exit("out", ({ "door short", "front door"}));
   add_exit("%2%", PATH+"flat%N%bed", "door");
   modify_exit("%2%", ({ "door short", "bedroom door"}));
   modify_exit("out", ({"exit mess", "$N leaves the flat.",
                         "enter mess",
                           ({ 1,
                              "$N enters from a flat.",
                              "$N enter from a flat."
                           }),
                       }) );
   modify_exit( "out", ({ "closed", 1 }) );
}

==================================================
FILE: house/tworoomflat/flatNbed.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/flat%N%bed");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "%6%", PATH +"flat%N%", "door" );
   modify_exit("%6%", ({ "door short", "livingroom door" }));
}

==================================================
FILE: house/onebedhouse/Nbed.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "down", PATH +"%N%livingroom", "stair" );
   modify_exit("down", ({ "downgrade", 9 }));
}

==================================================
FILE: house/onebedhouse/Nhall.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%hall");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("front room");
   set_base_desc("a small hallway" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit("out", %out%, "door");
   modify_exit("out", ({"door short", "front door",
                          "exit mess", "$N leaves the house.",
                          "closed", 1,
                          "enter mess",
                          ({ 1,
                               "$N enters from a house.",
                               "$N enter from a house."
                               }),
                          }) );
   add_exit("%0%", PATH+"%N%livingroom", "door");
   modify_exit("%0%", ({ "door short", "livingroom door"}));
}

==================================================
FILE: house/onebedhouse/Nlivingroom.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%livingroom");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("livingroom");
   set_base_desc("a comfortable livingroom");
   add_surface("floor", "finished pine board" );
   add_surface("ceiling", "plain plaster" );
   add_surface("%0% wall", "plain plaster");
   add_surface("%2% wall", "plain plaster");
   add_surface("%4% wall", "plain plaster");
   add_surface("%6% wall", "plain plaster");
   add_exit("%4%", PATH+"%N%hall", "door");
   modify_exit("%4%", ({"door short", "hallway door"}));
   add_exit("up", PATH+"%N%bed", "stair");
   modify_exit("up", ({ "upgrade", 9 }));
}

==================================================
FILE: house/onebedhut/Nbed.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "stone paving" );
   add_surface( "ceiling", "roughly finished wood" );
   add_surface( "%0% wall", "roughly finished wood" );
   add_surface( "%2% wall", "roughly finished wood" );
   add_surface( "%4% wall", "roughly finished wood" );
   add_surface( "%6% wall", "roughly finished wood" );
   add_exit( "%4%", PATH +"%N%livingroom", "door" );
   modify_exit("%4%", ({ "door short", "living room door" }));
}

==================================================
FILE: house/onebedhut/Nlivingroom.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%livingroom");
   set_orientation(%orientation%);
   set_quit_handler(%out%);
   set_short("livingroom");
   set_base_desc("a small cramped livingroom");
   add_surface("floor", "stone paving" );
   add_surface("ceiling", "roughly finished wood" );
   add_surface("%0% wall", "roughly finished wood" );
   add_surface("%2% wall", "roughly finished wood" );
   add_surface("%4% wall", "roughly finished wood" );
   add_surface("%6% wall", "roughly finished wood" );
   add_exit("out", %out%, "door");
   modify_exit("out", ({"door short", "front door",
                          "exit mess", "$N leaves the hut.",
                          "closed", 1,
                          "enter mess",
                          ({ 1,
                               "$N enters from a hut.",
                               "$N enter from a hut."
                               }),
                          }) );
   add_exit("%0%", PATH+"%N%bed", "door");
   modify_exit("%0%", ({"door short", "bedroom door"}));
}

==================================================
FILE: house/fourbedhouse/Nbed2.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed2");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "%0%", PATH +"%N%landing1", "door" );
   modify_exit("%0%", ({ "door short", "bedroom door" }));
   add_exit("window", PATH + "%N%half-roof", "window");
}

==================================================
FILE: house/fourbedhouse/Nbed3.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed3");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "%0%", PATH +"%N%landing2", "door" );
   modify_exit("%0%", ({ "door short", "bedroom door" }));
   add_exit("window", PATH + "%N%half-roof", "window");
}

==================================================
FILE: house/fourbedhouse/Nbed4.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%bed4");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a small bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "%4%", PATH +"%N%landing2", "door" );
   modify_exit("%4%", ({ "door short", "livingroom door" }));
}

==================================================
FILE: house/fourbedhouse/Ndiningroom.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%diningroom");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("spacious dining room");
   set_base_desc("a spacious dining room");
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit("%3%", PATH+"%N%livingroom", "corridor");
   add_exit("%2%", PATH+"%N%kitchen", "corridor");
   add_exit("window", PATH+"%N%garden", "window");
}

==================================================
FILE: house/fourbedhouse/Nfamilyroom.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/flat%N%study");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("small study");
   set_base_desc("a small study");
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit("%6%", PATH+"%N%kitchen", "corridor");
   add_exit("%0%", PATH+"%N%garden", "door");
}

==================================================
FILE: house/fourbedhouse/Ngarden.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE_OUTSIDE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%garden");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("small garden");
   set_base_desc("a quiet and secluded garden");
   add_surface("floor", "grass");
   add_surface("%0% wall", "red brick" );
   add_surface( "%2% wall", "red brick" );
   add_surface( "%6% wall", "red brick" );
   add_exit("%4%", PATH+"%N%familyroom", "door");
   modify_exit("%4%", ({ "door short", "garden door" }));
   add_exit("window", PATH+"%N%diningroom", "window");
}

==================================================
FILE: house/fourbedhouse/Nhalf-roof.c
==================================================

#include "path.h";
inherit "/std/rooftop";
void setup() {
  set_light(100);
  set_short("half-roof");
  set_long("This is a half-roof, a piece of sloping roof halfway up the "
           "front of the house.  There is a window to the %2% and another "
           "to the %6%.\n");
  set_slope(30, "half-roof", %out%);
  add_exit("%6% window", PATH+"%N%bed2", "window");
  add_exit("%2% window", PATH+"%N%bed3", "window");
  set_wall( ({ "bottom", ({ %out", 250 }), }) );
  set_wall( ({ "move", ({ "down", 30, %out%,
                            "$N climb$s down from above to join you." }) }) );
}

==================================================
FILE: house/fourbedhouse/Nkitchen.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%kitchen");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("large kitchen");
   set_base_desc("a large kitchen");
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit("%6%", PATH+"%N%diningroom", "corridor");
   add_exit("%4%", PATH+"%N%livingroom", "corridor");
   add_exit("%2%", PATH+"%N%familyroom", "corridor");
}

==================================================
FILE: house/fourbedhouse/Nlanding1.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%landing1");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("landing");
   set_base_desc( "a landing at the top of the stairs" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "%0%", PATH +"%N%masterbed", "door" );
   modify_exit("%0%", ({ "door short", "bedroom door" }));
   add_exit( "%4%", PATH +"%N%bed2", "door" );
   modify_exit("%4%", ({ "door short", "bedroom door" }));
   add_exit("%2%", PATH+"%N%landing2", "corridor");
   add_exit("down", PATH+"%N%livingroom", "corridor");
   modify_exit("down", ({"downgrade", 9 }));
}

==================================================
FILE: house/fourbedhouse/Nlanding2.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/flat%N%bed");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("hallway");
   set_base_desc( "a hallway" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_exit( "%0%", PATH +"%N%bed4", "door" );
   modify_exit("%0%", ({ "door short", "bedroom door" }));
   add_exit( "%4%", PATH +"%N%bed3", "door" );
   modify_exit("%4%", ({ "door short", "bedroom door" }));
   add_exit( "%6%", PATH +"%N%landing1", "corridor" );
}

==================================================
FILE: house/fourbedhouse/Nlivingroom.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%livingroom");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("livingroom");
   set_base_desc("a large, comfortable, and sunny livingroom");
   add_surface("floor", "finished pine board" );
   add_surface("ceiling", "plain plaster" );
   add_surface("%0% wall", "plain plaster");
   add_surface("%2% wall", "plain plaster");
   add_surface("%4% wall", "plain plaster");
   add_surface("%6% wall", "plain plaster");
   add_exit("out", %out%, "door");
   modify_exit("out", ({"door short", "front door"}));
   add_exit("%7%", PATH+"%N%diningroom", "corridor");
   add_exit("%0%", PATH + "%N%kitchen", "corridor");
   add_exit("up", PATH + "%N%landing1", "corridor");
   modify_exit("up", ({"upgrade", 9}));
   modify_exit("out", ({"message", "$N leaves the house.",
                          "enter",
                          ({ 1,
                             "$N enters from a house.",
                             "$N enter from a house." }),
                          "closed", 1,
                          "door long", "This is the front door to a house.  "
                          "It has the numerals '%N%' in brass lettering.\n",
                          }) );
}

==================================================
FILE: house/fourbedhouse/Nmasterbed.c
==================================================

#include "path.h";
inherit PLAYER_HOUSE;
void setup() {
   set_light(50);
   set_theft_handler( HOSPITAL );
   set_save_file("%savedir%/%N%masterbed");
   set_orientation(%orientation%);
  set_quit_handler(%out%);
   set_short("bedroom");
   set_base_desc( "a huge master bedroom" );
   add_surface( "floor", "finished pine board" );
   add_surface( "ceiling", "plain plaster" );
   add_surface( "%0% wall", "plain plaster" );
   add_surface( "%2% wall", "plain plaster" );
   add_surface( "%4% wall", "plain plaster" );
   add_surface( "%6% wall", "plain plaster" );
   add_exit( "%4%", PATH +"%N%landing1", "door" );
   modify_exit("%4%", ({ "door short", "bedroom door" }));
}

==================================================
FILE: effects/basic.c
==================================================

#include "potion_attrs.h"
int x1, x2, y1, y2;
void set_boundaries(int *min, int *max)
{
   x1 = min[0];
   x2 = max[0];
   y1 = min[1];
   y2 = max[1];
}
int *query_coordinate()
{
   return ({ (x1 + x2) / 2, (y1 + y2) / 2 });
}
#pragma no_warnings
mixed *query_attrs(int *coord)
{
   return ({ 0, 100, ({ }), ({ }), ({ }), ({ }) });
}
int query_pass_through(int *coord)
{
   return 100;
}
void install_effect()
{
   (void)POTION_SPACE_HANDLER->remove_effect(file_name(this_object()));
   (void)POTION_SPACE_HANDLER->add_effect(file_name(this_object()), x1, x2, y1, y2);
}
int sqrt(int p)
{
   int i;
   for (i = 1; i < 500; i++) if (i * i > p) return i-1;
}
int distance_within_region(int *coord)
{
   int dx, dy;
   if (x1 < 0) {
      if (x2 > 0)
         dx = (coord[0] < 0) ? -coord[0] : coord[0];
      else
         dx = (x2 - coord[0]);
   } else
      dx = coord[0] - x1;
   if (y1 < 0) {
      if (y2 > 0)
         dy = (coord[1] < 0) ? -coord[1] : coord[1];
      else
         dy = (y2 - coord[1]);
   } else
      dy = coord[1] - y1;
   return sqrt(dx * dx + dy * dy);
}
int distance_from_origin(int *coord)
{
   return sqrt(coord[0] * coord[0] + coord[1] * coord[1]);
}

==================================================
FILE: effects/object/basic_trap.c
==================================================

#include "path.h"
string query_classification() { return "object.trap.basic"; }
string query_shadow_ob() { return SHADOWS +"basic_trap"; }
int query_indefinite() { return 1; }
int beginning( object thing, int amount, int id ) {
	tell_object(find_player("ceres"), sprintf("Adding trap to %O\n",
																						thing));
	thing->set_lock_trap(thing, "trap_lock");
	return 0;
}

==================================================
FILE: effects/object/bug_effect.c
==================================================

#include <effect.h>
void beginning( object player, int time, int id ) {
   if (time == 0) {
      time = 30*60;
   }
   player->submit_ee( "create_bug", ({ 5*60, 5*60 }), EE_CONTINUOUS );
   player->submit_ee( 0, time, EE_REMOVE );
}
void end( object player, int time, int id ) {
}
void create_bug( object player, int time, int id ) {
   object bug;
   object room;
   string env_string;
   object *ignore;
   bug = clone_object("/obj/monster/cockroach");
   room = environment(player);
   env_string = player->the_short();
   ignore = ({ });
   while (room) {
      if (room == environment(player) && living(player)) {
         tell_object(player, env_string+" have "+bug->a_short()+
                             " suddenly pop out of your "
                             "ear.\n");
         ignore += ({ player });
         tell_room(room, env_string+" has "+bug->a_short()+
                         " suddenly pop out of "+
                         player->query_possessive()+
                         " ear.\n", ignore);
      } else if (living(player)) {
         tell_room(room, env_string+" has "+bug->a_short()+
                         " suddenly pop out of "+
                         player->query_possessive()+
                         " ear.\n", ignore);
      } else {
         tell_room(room, env_string+" has "+bug->a_short()+
                         " suddenly pop out of it.\n", ignore);
      }
      if (living(room))
        ignore += ({ room });
      env_string = env_string + " in " + room->the_short();
      if (!environment(room))
        bug->move(room);
      room = environment(room);
   }
}
string query_classification() { return "object.bug"; }

==================================================
FILE: effects/object/cabbage.c
==================================================

#include <effect.h>
void beginning( object player, int time, int id ) {
   player->submit_ee( "make_stink", ({ 20, 20 }), EE_CONTINUOUS );
   player->submit_ee( 0, time, EE_REMOVE );
}
int merge_effect( object player, int time1, int time2, int id ) {
   player->submit_ee( 0, time1 + time2 - (int)player->expected_tt(),
         EE_REMOVE );
   return time1 + time2;
}
void end( object player, int time, int id ) {
   tell_object( player, "Your stomach calms down at last.\n" );
}
void make_stink( object player, int time, int id ) {
   tell_object( player, "A huge trumpeting noise comes from your "
   "rear, closely followed by a stench of boiled cabbage.\n" );
   tell_room( environment( player ), "The smell of sprouts and cabbages from "
   + (string)player->one_short() +
         " wafts over you and you find yourself thinking of school dinners."
         "\n", player );
}
string query_classification() { return "body.smell.scent"; }
string smell_string( object player, int time ) {
   return "the delicious doughnutty smell";
}

==================================================
FILE: effects/object/death_ward.c
==================================================

#include "path.h"
string query_classification() { return "magic.ward.death"; }
string query_shadow_ob() { return SHADOWS +"death_ward"; }
int query_indefinite() { return 1; }
int beginning( object thing, int amount, int id ) { return 0; }

==================================================
FILE: effects/object/extra_description.c
==================================================

#include <effect.h>
string query_classification() {
    return "object.extra_description";
}
void beginning( object thing , mixed *args ) {
    string description;
    int duration;
    description = args[ 0 ];
    duration = args[ 1 ];
    if( !stringp( description ) || !intp( duration ) ) return;
    thing->add_extra_look( this_object() );
    thing->submit_ee( 0 , duration , EE_REMOVE );
}
string extra_look( object thing ) {
    int *enums;
    string message, temp;
    enums = thing->effects_matching( query_classification() );
    if( !sizeof( enums ) ) {
        thing->remove_extra_look( this_object() );
        return "";
    }
    message = "";
    foreach( int elem in enums ) {
        temp =  ( thing->arg_of( elem ) ) [ 0 ];
        if( !stringp( temp ) ) {
            temp = "";
        } else {
           if( strlen( temp ) < 2 || temp[ <2 .. ] != "\n" ) temp += "\n";
        }
        message += temp;
    }
    return message;
}
void end( object thing , mixed *args , int id ) {
    if( sizeof( args ) == 3 && stringp( args[ 2 ] ) ) {
         string end_mess = args[ 2 ];
         if( end_mess[<2 .. ] != "\n" ) end_mess += "\n";
         tell_object( thing , end_mess );
    }
}

==================================================
FILE: effects/object/heat.c
==================================================

#include "path.h"
#include <effect.h>
string query_classification()
{
  return "object.heat";
}
string query_shadow_ob()
{
  return SHADOWS+"heat_shadow";
}
int beginning(object ob, int heat, int id)
{
  ob->submit_ee("change_temperature", ({ 45, 15 }), EE_CONTINUOUS);
  ob->add_extra_look(this_object());
  return heat;
}
void restart(object ob)
{
  ob->add_extra_look(this_object());
}
int merge_effect(object ob, int new_heat, int old_heat, int id)
{
  int heat;
  heat = new_heat + old_heat;
  if(heat < 21)
  {
    ob->submit_ee(0, 0, EE_REMOVE);
  }
  return heat;
}
void end(object ob, int heat, int id)
{
  ob->remove_extra_look(this_object());
}
void change_temperature(object ob, int heat, int id)
{
  int shift;
  int env_temp;
  int new_heat;
  env_temp = environment(ob)->query_heat();
  if(!env_temp)
  {
    env_temp = 20;
  }
  if(env_temp > heat)
  {
    shift = 100 + ((env_temp - heat) / 10);
    if((heat + shift) > env_temp)
    {
      shift = env_temp - heat;
    }
  }
  else
  {
    shift = -100 - ((heat - env_temp) / 10);
    if((heat + shift) < env_temp)
    {
      shift = env_temp - heat;
    }
  }
  tell_creator(find_living("gototh"), "Heat shift: %O\n", shift);
  new_heat = heat + shift;
  if(heat > ob->query_property("red hot at") &&
    new_heat < (ob->query_property("red hot at") + 1))
  {
    tell_room(environment(ob),
      "$C$" + ob->one_short() + " stops glowing red hot.\n");
  }
  if((heat > 80) && (new_heat < 81))
  {
    tell_room(environment(ob),
      "$C$" + ob->one_short() + " seems to have cooled down.\n");
  }
  if(new_heat < 21)
  {
    ob->submit_ee(0, 0, EE_REMOVE);
  }
  else
  {
    ob->set_arg_of(ob->sid_to_enum(id), new_heat);
  }
}
string extra_look(object ob)
{
  int heat;
  int *enums;
  int red_hot;
  enums = ob->effects_matching("object.heat");
  if(!sizeof(enums))
  {
    return "";
  }
  heat = ob->arg_of(enums[0]);
  red_hot = ob->query_property("red hot at");
  if(red_hot)
  {
    if(heat > red_hot)
    {
      return "It is red hot.\n";
    }
    if(heat > 80)
    {
      return "It looks hot.\n";
    }
  }
  return "";
}

==================================================
FILE: effects/object/horse.c
==================================================

#include <effect.h>
#define SHADOWS "/std/effects/object/"
string query_classification(){return "object.horse"; }
void beginning(object player, int amount){
    player->submit_ee(0, amount, EE_REMOVE);
    player->add_extra_look(this_object());
}
int merge_effect(object player, int old_amount, int new_amount){
   if (old_amount > new_amount)
      return old_amount;
   return new_amount;
}
string query_shadow_ob(){
   return SHADOWS+"shadow_horse";
}
int survive_death(){
   return 0;
}
string extra_look(object player){
   return capitalize((string)player->the_short()) +
         " is mounted on a large, black horse.\n";
}
void end(object player, int amount, int id){
   player->remove_extra_look(this_object());
}

==================================================
FILE: effects/object/identity_hold.c
==================================================

#include <effect.h>
#include "path.h"
class special_stuff {
   int keep;
   string identity;
}
int query_indefinite() { return 1; }
string query_classification() { return "object.identify"; }
string query_shadow_ob() { return SHADOWS + "identity_hold"; }
class special_stuff beginning( object thing, mapping data, int id ) {
   class special_stuff special_stuff;
   special_stuff = new(class special_stuff);
   special_stuff->keep = data["keep"];
   special_stuff->identity = data["identity"];
   thing->set_keep_value(special_stuff->keep);
   thing->set_identifier(special_stuff->identity);
   thing->set_identity_hold_owner(this_player());
   return special_stuff;
}
class special_stuff merge_effect( object thing,
                                  class special_stuff data,
                                  mapping arg,
                                  int id ) {
   if (!nullp(arg["keep"])) {
      data->keep = arg["keep"];
   }
   if (!nullp(arg["identity"])) {
      data->identity = arg["identity"];
   }
   thing->set_keep_value(data->keep);
   thing->set_identifier(data->identity);
   return data;
}
void end( object thing, mixed* store, int id ) {
}
class special_stuff restart( object thing, class special_stuff data, int id ) {
   thing->set_keep_value(data->keep);
   thing->set_identifier(data->identity);
   thing->set_identity_hold_owner(this_player());
   return data;
}

==================================================
FILE: effects/object/label.c
==================================================

#include <effect.h>
int query_indefinite() { return 1; }
object create_store(mapping map,
                    object player) {
   object store;
   store = clone_object( "/std/container" );
   if ( objectp( player ) ) {
      store->set_player( player );
   }
   if ( mapp( map ) ) {
      store->init_dynamic_arg( map );
   }
   return store;
}
string query_classification() { return "object.label"; }
mixed* beginning( object thing, object label, int id ) {
   object store;
   store = clone_object( "/std/container" );
   label->move( store );
   thing->add_extra_look( file_name(this_object()) );
   return ({ store, store->query_dynamic_auto_load() });
}
mixed* merge_effect( object thing, mixed* store, object label, int id ) {
   if (!store) {
      store = ({ 0, ([ ]) });
   }
   if (mapp(store)) {
      store = ({ 0, store });
   }
   if ( !store[0] ) {
      store[0] = create_store(store[1], environment(thing));
   }
   label->move( store[0] );
   store[1] = store[0]->query_dynamic_auto_load();
   return store;
}
void end( object thing, mixed* store, int id ) {
  int i;
  if (arrayp(store)) {
    for(i=0; i<sizeof(store); i++)
      if(objectp(store[i]))
         store[i]->dest_me();
  } else if(objectp(store))
    store->dest_me();
   thing->remove_extra_look( this_object() );
}
mixed* restart( object thing, mixed stuff, int id ) {
   object player;
   object store;
   mapping map;
   int enum;
   if (mapp(stuff)) {
      map = stuff;
   } else if (stuff) {
      map = stuff[1];
   } else {
      map = ([ ]);
   }
   player = environment( thing );
   thing->add_extra_look( file_name(this_object()) );
   store = create_store(map, environment(thing));
   enum = thing->sid_to_enum(id);
   thing->set_arg_of(enum, ({ store, map }));
}
string extra_look( object thing ) {
   int *enums;
   object store;
   object *labels;
   mixed *bing;
   enums = (int *)thing->effects_matching( "object.label" );
   if ( !sizeof( enums ) ) {
      return "";
   }
   bing = thing->arg_of( enums[ 0 ] );
   if (pointerp(bing)) {
      store = bing[0];
      if (!store) {
         store = create_store(bing[1], environment(thing));
         thing->set_arg_of(enums[0], ({ store, bing[1] }));
      }
   }
   if ( !objectp( store ) ) {
      return "";
   }
   labels = (object *)store->find_inv_match( "" );
   if ( !sizeof( labels ) ) {
      return "";
   }
   return capitalize( (string)thing->query_pronoun() ) +" has "+
         query_multiple_short( labels ) +" stuck on "+
         (string)thing->query_objective() +".\n";
}

==================================================
FILE: effects/object/newbie_shoes.c
==================================================

#include "path.h"
#include <effect.h>
#define CLASS "misc.worn.shoes.orthopaedic"
string query_classification() { return CLASS; }
int query_indefinite() { return 1; }
string query_shadow_ob() { return SHADOWS + "newbie_shoes"; }
void chat(object player, mixed arg, int id)
{
  string *mechats = ({
    "Something's crawling inside the shoes.\n",
    "The Cobblers of Sek must've made these things!\n",
    "Did that vice just screw down tighter?\n",
    "*OUCH* that stung!\n",
    "You not-so-idly wonder who came up with these shoes.\n"
    });
  string *youchats = ({
    " winces in pain.\n",
    " mutters something about shoes.\n",
    " stumbles.\n"
    });
  if (!interactive(player)) return;
  tell_object(player, mechats[random(sizeof(mechats))]);
  tell_room(environment(player),
    player->query_cap_name() + youchats[random(sizeof(youchats))],
    ({ player }) );
}
void notify(object player, mixed arg, int id)
{
  tell_object(player,
    "A fiery pain shoots up your legs from your feet.\n");
}
void beginning( object player, int amount, int id )
{
  player->add_extra_look( this_object() );
  player->adjust_bonus_dex(-1);
  player->submit_ee("chat", ({ 10, 30 }), EE_CONTINUOUS);
  player->submit_ee("notify", 1, EE_ONCE);
}
void restart( object player, int amount, int id )
{
  beginning(player, amount, id);
}
void merge_effect(object player, mixed oldarg, mixed newarg, int id)
{
  return;
}
void end( object player, int amount, int id )
{
  player->remove_extra_look( this_object() );
  player->adjust_bonus_dex(1);
  tell_object(player, "Ahhhh!  Free from those evil shoes!\n");
}
string extra_look( object player )
{
  int *enums;
  enums = (int *)player->effects_matching( CLASS );
  if ( !sizeof( enums ) )
     return "";
  return(capitalize(player->query_pronoun()) +
    " looks embarrassed and uncomfortable.\n");
}

==================================================
FILE: effects/object/no_save.c
==================================================

#include "path.h"
string query_classification() { return "mudlib.object.nosave"; }
string query_shadow_ob() { return SHADOWS +"no_save"; }
int query_indefinite() { return 1; }
void beginning( object thing, string owner, int id ) { return; }
string merge_effect( object thing, string old_owner, string new_owner,
      int id ) {
   return old_owner;
}

==================================================
FILE: effects/object/object_desc.c
==================================================

#include <effect.h>
string query_classification(){return "crafts.description"; }
string* beginning(object thing, string* desc){
   switch(sizeof(desc)){
      case 5:
         thing->add_property("determinate", desc[4]);
      case 4:
         thing->add_alias(desc[3]);
      case 3:
         thing->add_adjective(desc[2]);
      case 2:
         thing->set_long(desc[1]);
      case 1:
         thing->set_short(desc[0]);
   }
   return desc;
}
string* merge_effect(object player, string* old_desc, string* new_desc){
   return new_desc;
}
mixed* restart(object thing, string* description, int id){
   switch(sizeof(description)){
      case 5:
         thing->add_property("determinate", description[4]);
      case 4:
         thing->add_alias(description[3]);
      case 3:
         thing->add_adjective(description[2]);
      case 2:
         thing->set_long(description[1]);
      case 1:
         thing->set_short(description[0]);
   }
   return ({thing, description, id});
}

==================================================
FILE: effects/object/owned_weapon.c
==================================================

#include "path.h"
string query_classification() { return "mudlib.owned.weapon"; }
string query_shadow_ob() { return SHADOWS +"owned_weapon"; }
int query_indefinite() { return 1; }
void beginning( object thing, string owner, int id ) { return; }
string merge_effect( object thing, string old_owner, string new_owner,
      int id ) {
   write( "There is a bug with the ownership of "+
         (string)thing->the_short() +" ("+ file_name( thing ) +
         ")!  Please bug report it and contact a creator!\n" );
   return old_owner;
}

==================================================
FILE: effects/object/swim_fins.c
==================================================

#include <effect.h>
#define SHADOW "/std/shadows/object/swim_fins"
string query_classification() { return "clothing.swim_fins"; }
string query_shadow_ob() { return SHADOW; }
void beginning(object player, int time ) {
   player->submit_ee( "test_worn", 1, EE_ONCE );
   player->submit_ee( "test_worn", 20, EE_CONTINUOUS );
}
void restart( object player ) {
}
int merge_effect( object player, int old_state, int new_state ) {
   return old_state | new_state;
}
int test_for_effect( object thing ) {
   if ( !thing )
      return 0;
   return member_array( file_name( this_object() ),
         (string *)thing->query_wear_effects() ) != -1;
}
void test_worn( object player ) {
   if ( player->still_auto_loading() )
      return;
   if ( !sizeof( filter_array( (object *)player->query_armours(),
         "test_for_effect", this_object() ) ) ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return;
   }
}

==================================================
FILE: effects/object/talker.c
==================================================

#include "path.h"
#include <library.h>
#include <talker.h>
#include <player.h>
#include <playtesters.h>
#include <deity.h>
#include <nomic_system.h>
#define HELP_CMD "/cmds/player/help"
nosave mapping _channel_cache;
nosave string *valid_channels = ({"one", "two", "A'Tuin", "Intermud", "Apex",
    "Adventurers", "Priests", "Wizards",
    "Assassins", "Warriors", "Thieves",
    "Witches", "playerkillers",
    "playtesters", "Catfish", "Fish",
    "Gapp", "Gufnork", "Hat",
    "Pishe", "Sandelfon", "Sek",
      "theAgateanEmpireCouncil",
     "KlatchCouncil", "KlatchCouncilMagistrate",
    "Ankh-MorporkCouncil",
    "Ankh-MorporkCouncilMagistrate" });
string query_classification() { return "magic.talker"; }
string query_shadow_ob() { return SHADOWS +"talker"; }
int query_indefinite() { return 1; }
protected class talker_args new_talker_args() {
    return new(class talker_args, status : 1, channels : ({ "one" }),
        verbose : 1, local_echo : 0, colour : 0 );
}
class talker_args beginning( object thing, mixed args, int id ) {
    if ( environment( thing ) )
        tell_object( environment( thing ), "Somewhere inside " +
            thing->the_short() + " a pair of glittering eyes swirl "
            "into being.\n" );
    thing->add_extra_look( this_object() );
    thing->add_alias( "talker" );
    thing->add_plural( "talkers" );
    if (arrayp(args)) {
        args = new_talker_args();
        return args;
    }
    if (!classp(args)) {
        return new_talker_args();
    }
}
class talker_args merge_effect(object thing, mixed old_args, mixed new_args) {
    class talker_args args;
    if (!classp(old_args) || !classp(new_args))
        return new_talker_args();
    args = copy(old_args);
    args->channels += new_args->channels;
    args->channels = uniq_array(args->channels);
    return args;
}
void restart( object thing, mixed args, int id ) {
    if (!classp(args)) {
        thing->set_arg_of(thing->sid_to_enum(id), new_talker_args());
        tell_object( environment( thing ), "Your talker quivers "
            "uncontrollably and starts to jump around.  You will have "
            "to re-add your talker channels and reconfigure your talker.\n" );
    }
    thing->add_extra_look( this_object() );
    thing->add_alias( "talker" );
    thing->add_plural( "talkers" );
}
void end( object thing, mixed *args, int id ) {
    if ( environment( thing ) )
        tell_object( environment( thing ), "The pair of glittering eyes in "+
          (string)thing->the_short() +" close and fade away forever.\n" );
    thing->remove_extra_look( this_object() );
    thing->remove_alias( "talker" );
    thing->remove_plural( "talkers" );
}
string extra_look( object thing ) {
    int *enums;
    mixed args;
    enums = (int *)thing->effects_matching( "magic.talker" );
    if ( !sizeof( enums ) ) {
        return "";
    }
    args = thing->arg_of( enums[ 0 ] );
    if (!classp(args)) {
         return "";
    }
    if ( args->status ) {
        return "Just beneath the surface, you can make out what looks like a "
        "pair of glittering eyes.\n";
    }
    return "Just beneath the surface, you can make out what looks like a "
    "pair of closed eyes.\n";
}
string *all_channels( object player ) {
    string word, *list;
    string p_name;
    class cache_data settings;
    string* areas;
    if ( player->query_property("gagged") ) {
        return ({ });
    }
    list = ({ "one", "two" });
    word = (string)player->query_guild_ob();
    if ( file_size( word +".c" ) > 0 ) {
        if (word != "disavowed") {
            list += ({ capitalize(word->query_name()) });
        }
    }
    else {
        list += ({ "Adventurers" });
    }
    word = (string)player->query_deity();
    if ( stringp( word ) ) {
        list += ({ capitalize( word ) });
    }
    word = (string)player->query_name();
    p_name = player->query_name();
    if (!_channel_cache) {
        _channel_cache = ([ ]);
    }
    if (undefinedp(_channel_cache[p_name])) {
        _channel_cache[p_name] = new(class cache_data,
          talker_quest : LIBRARY->query_quest_done(p_name, "talker quest"),
          playtester : PLAYTESTER_HAND->query_playtester(p_name),
          apex_member : "/d/am/buildings/apex/admin_office"->query_member(p_name)
        );
    }
    settings = _channel_cache[p_name];
    if (settings->talker_quest) {
        list += ({ "A'Tuin", "Intermud" });
    }
    if (settings->apex_member) {
        list += ({ "Apex" });
    }
    if (settings->playtester) {
        list += ({ "playtesters" });
    }
    if ( player->query_player_killer()) {
        list += ({ "playerkillers" });
    }
    areas = NOMIC_HANDLER->query_citizenship_areas();
    foreach (word in areas) {
       if (NOMIC_HANDLER->is_citizen_of(word, p_name)) {
          list += ({ replace_string(word, " ", "") + "Council" });
       }
       if (NOMIC_HANDLER->is_magistrate_of(word, p_name)) {
          list += ({ replace_string(word, " ", "") + "CouncilMagistrate" });
       }
    }
    return list;
}
string channels() {
    return sprintf( "%#-*s\n", (int)this_player()->query_cols(),
      implode( all_channels( this_player() ), "\n" ) );
}
varargs int valid( mixed word, object who) {
    if (!who) {
        who = this_player();
    }
    if (arrayp(word) && arrayp(valid_channels)) {
        if (sizeof( word - valid_channels ) != 0) {
            return 0;
        }
    } else {
        if (member_array( word, valid_channels ) == -1) {
            return 0;
        }
    }
    if (who->query_lord()) {
       return 1;
    }
    if ( who->query_creator() ) {
        if (stringp(word) &&
            word[<7..] != "Council" &&
            word[<10..] != "Magistrate") {
            return 1;
        } else if (arrayp(word)) {
            if (!sizeof(filter(word, (: $1[<7..] == "Council" &&
                                        $1[<10..] == "Magistrate" :)))) {
                return 1;
            }
        }
    }
    if ( arrayp( word ) ) {
        return sizeof( word - all_channels( who ) ) == 0;
    }
    return ( member_array( word, all_channels( who ) ) != -1 );
}
object find_actual_talker( object thing ) {
    object talker;
    while ( thing ) {
        talker = thing;
        thing = query_shadowing( thing );
    }
    return talker;
}
string list( string word, int brief ) {
    int space;
    int *enums;
    string sender;
    string table;
    object thing;
    object *ok;
    object *things;
    object holder;
    class talker_args args;
    table = "";
    space = (int)this_player()->query_cols() - 20;
    things = children( SHADOWS + "talker" ) -
        ({ find_object( SHADOWS + "talker" ) });
    things = filter( map( things, (: find_actual_talker( $1 ) :) ),
        (: $1 && environment($1) && living(environment($1)) &&
           (!userp($1) || interactive($1)) :) );
    things = uniq_array(things);
    things = sort_array( things,
        (: strcmp( environment($1)->query_name(),
            environment($2)->query_name() ) :) );
    ok = ({ });
    foreach( thing in things ) {
        holder = environment( thing );
        if (userp(holder)) {
            sender = capitalize( holder->query_cap_name() );
        } else {
            sender = capitalize( holder->query_name() );
        }
        if ( holder->query_invis() ) {
            continue;
        }
        enums = (int *)thing->effects_matching( "magic.talker" );
        if ( !sizeof( enums ) ) {
            if ( !word ) {
                table += sprintf( LIST_FORMAT, sender, space, "(barfed)" );
            }
            continue;
        }
        args = thing->arg_of( enums[ 0 ] );
        if (!classp(args)) {
            continue;
        }
        if ( !args->status) {
            if ( !word ) {
                table += sprintf( LIST_FORMAT, sender, space, "(asleep)" );
            }
            continue;
        }
        if ( !word || ( member_array( word, args->channels ) != -1 ) ) {
            if (brief) {
                ok += ({ sender });
            } else {
                table += sprintf( LIST_FORMAT, sender, space,
                    query_multiple_short( args->channels ) );
            }
        }
    }
    if (brief) {
       return "$I$5=People listing to the channel " + word + " are: " +
              query_multiple_short(ok) + "\n";
    }
    if ( table == "" ) {
        return sprintf( LIST_FORMAT, "None", space, "" );
    }
    return table;
}
string normalise_name( string channel ) {
    int position;
    mixed *details;
    string *lower_names;
    string lower_channel;
    lower_channel = lower_case( channel );
    lower_names = map( valid_channels, (: lower_case($1) :) );
    position = member_array( lower_channel, lower_names );
    if ( position == -1 ) {
        details = HELP_CMD->find_match_in_array( lower_channel,
            lower_names );
        if ( details[ 1 ] > 70 ) {
            return valid_channels[ details[ 0 ] ];
        }
        return channel;
    }
    return valid_channels[ position ];
}
varargs mapping query_channel_cache(string person) {
    if (!_channel_cache)
        return ([ ]);
    if (stringp(person) && classp(_channel_cache[person])) {
        return copy(_channel_cache[person]);
    }
    return copy(_channel_cache);
}
void reset() {
    _channel_cache = ([ ]);
}
void clear_cache(string person) {
    if (_channel_cache) {
        map_delete(_channel_cache, person);
    }
}

==================================================
FILE: effects/object/wet.c
==================================================

#include <effect.h>
string query_classification() { return "object.wet"; }
void beginning( object thing, int amount, int id ) {
   thing->submit_ee( "dry_off", ({ 30, 90 }), EE_CONTINUOUS );
   thing->add_extra_look( this_object() );
   thing->add_adjective("wet");
}
int merge_effect( object thing, int old_amount, int new_amount, int id ) {
   return old_amount + new_amount;
}
void end( object thing, int amount, int id ) {
   thing->remove_extra_look( this_object() );
   thing->remove_adjective("wet");
}
void restart( object thing, int amount, int id ) {
   thing->add_extra_look( this_object() );
}
void dry_off( object thing, int amount, int id ) {
   amount -= 100 + amount / 10;
   if ( amount > 0 )
      thing->set_arg_of( (int)thing->sid_to_enum( id ), amount );
   else
      thing->submit_ee( 0, 0, EE_REMOVE );
}
string wet_string( object thing ) {
   int *enums;
   string wetness;
   enums = (int *)thing->effects_matching( "object.wet" );
   if ( !sizeof( enums ) )
      return "";
   switch ( (int)thing->arg_of( enums[ 0 ] ) / ( 1 +
         (int)thing->query_weight() ) ) {
      case 0 :
         return "just barely damp";
      case 1 .. 5 :
         wetness = "slightly wet";
         break;
      case 6 .. 10 :
         wetness = "wet";
         break;
      case 11 .. 30 :
         wetness = "very wet";
         break;
      case 31 .. 80 :
         wetness = "sopping wet";
         break;
      default :
          wetness = "absolutely soaking wet";
   }
   return wetness;
}
string extra_look(object thing)  {
   return "It is " + wet_string(thing) + ".\n";
}

==================================================
FILE: effects/external/coffee_nose.c
==================================================

#include <effect.h>
void beginning( object player, int time ) {
    if (time > 1800)
        time = 1800;
    tell_object( player, "\n" );
    tell_room( environment( player ), (string)player->the_short() + " drinks some of his coffee and ends up with a small amount of froth on "+player->query_possessive()+" nose.\n", player);
    player->submit_ee( 0, time, EE_REMOVE );
    player->add_extra_look( this_object() );
}
int merge_effect( object player, int time1, int time2 ) {
    int newtime;
     newtime = (time1 > time2 ) ? time1 : time2;
     newtime = ( newtime > 1800 ) ? 1800 : newtime;
    player->submit_ee( 0, newtime, EE_REMOVE );
    return newtime;
}
void end( object player, int time ) {
    if ( !player->query_property( "dead" ) )
        tell_object( player, "A small amount of frothy Coffee drops onto the floor.\n" );
    player->remove_extra_look( this_object() );
}
string query_classification() { return "coffee.nose"; }
string extra_look( object player ) {
    return capitalize( player->query_pronoun()+" looks "
      "like "+player->query_pronoun()+" has a small amount of creamy, frothy coffee on "+player->query_possessive()+" nose.\n" );
}

==================================================
FILE: effects/external/flea_cure.c
==================================================

#include <effect.h>
int infested;
int cleanse( object thing, int bonus ) {
    int i, flag, *effnums;
    class effect *effs;
    if ( !thing )
      return 0;
    if ( !living( thing ) )
      return 0;
    effnums = (int *)thing->effects_matching(
              "disease.parasite.external.flea");
    if ( !sizeof( effnums ) )
      return 0;
    effs = (class effect *)thing->query_effs();
    for ( i = sizeof( effnums ) - 1; i >= 0; i-- )
      if ( effs[ effnums[ i ] ]->ob_name->test_remove( thing,
          effs[ effnums[ i ] ]->arg, effnums[ i ], bonus ) ) {
          thing->delete_effect( effnums[ i ] );
          flag = 1;
      }
    infested = flag;
    return flag;
}
void beginning( object player, int time ) {
   player->submit_ee( "make_smell", ({ 20, 30 }), EE_CONTINUOUS );
   player->submit_ee( "kill_flea", ({ 30, 40 }), EE_CONTINUOUS );
   call_out("cleanse", 0, player, time/10);
   player->submit_ee( 0, time, EE_REMOVE );
}
int merge_effect( object player, int time1, int time2 ) {
   player->submit_ee( 0, time1 + time2 - (int)player->expected_tt(),
         EE_REMOVE );
   if (!infested)
       call_out("cleanse", 0, player, (time1+time2)/10);
   return time1 + time2;
}
void end( object player, int time ) {
   tell_object( player, "The odd odour is gone now.\n" );
}
void kill_flea( object player ) {
    if (infested && random(2)) {
        tell_object( player, "You hear a faint scream and see a small dot " +
                    "fall past your eyes.\n" );
        tell_room( environment( player ), "You see a tiny speck leap from " +
                  (string)player->short() + "'s head, screaming pitifully.\n",
                  player );
    }
}
void make_smell( object player ) {
    tell_object( player, "You notice a strange odour, like wet Grflx "
              "and rotting cabbage, in the air.\n" );
    tell_room( environment( player ),  "A smell reminiscent of a wet Grflx "+
              "and rotting cabbages seems to emanate from "+
              (string)player->short() + ".\n", player );
}
string query_classification() { return "body.smell.insecticide"; }
string smell_string( object player, int time ) {
   return "the odd odour of wet Grflx and rotting cabbage";
}

==================================================
FILE: effects/external/insect_repellent.c
==================================================

#include "effect.h"
string query_classification() {
  return "herb.insect.repellent";
}
int beginning(object them, int power, int id) {
  if (power <= 0) {
    them->submit_ee(0, 1, EE_REMOVE);
    return 0;
  }
  them->add_property("insect", power);
  them->submit_ee("start_mess", 2, EE_ONCE);
  them->submit_ee("smell", ({30, 60}), EE_CONTINUOUS);
  return power;
}
int merge_effect(object them, int power, int adjust) {
  power += adjust;
  if (power <= 0) {
    them->submit_ee(0, 1, EE_REMOVE);
    return 0;
  }
  them->submit_ee(0, -1, EE_REMOVE);
  return power;
}
void start_mess(object them, int power, int id) {
  string start_mess;
  switch (power) {
  case 1:
    start_mess = "You smell rather pleasant, much as you might wish to for a "
           "date.";
    break;
  case 2..3:
    start_mess = "A pungent smell envelops you.";
    break;
  default:
    start_mess = "A horribly pungent smell envelops you, sufficient to make "
           "anyone with a sense of smell keep their distance.";
  }
  tell_object(them, start_mess+"\n");
}
void smell(object them, int power, int id) {
  string self_mess, other_mess;
  object env;
  if (--power <= 0) {
    tell_object(them, "The herbal odour around you fades away.\n");
    them->remove_property("insect");
    them->submit_ee(0, 1, EE_REMOVE);
    return 0;
  }
  switch (power) {
  case 1:
    self_mess = "A pleasant smell emanates from your body.";
    other_mess = "A pleasant smell emanates from "+them->one_short()+".";
    break;
  case 2..3:
    self_mess = "A pungent herbal smell emanates from your body.";
    other_mess = "A pungent herbal smell emanates from "+them->one_short()+".";
    break;
  default:
    self_mess = "You reek of pungent herbs.";
    other_mess = "$C$"+them->one_short()+" $V$0=reeks,reek$V$ of pungent "
           "herbs.";
  }
  tell_object(them, self_mess+"\n");
  if ((env = environment(them)) && env->query_property("location")) {
    tell_room(env, other_mess+"\n", them);
  }
}

==================================================
FILE: effects/external/snowball.c
==================================================

#include <effect.h>
string query_classification() { return "mudlib.snowball"; }
void beginning( object player, int amount, int id ) {
   player->add_extra_look( this_object() );
   player->submit_ee( "decrease_amount", 15, EE_CONTINUOUS );
}
void restart( object player, int amount, int id ) {
   player->add_extra_look( this_object() );
}
int merge_effect( object player, int old_amount, int new_amount, int id ) {
   return old_amount + new_amount;
}
void end( object player, int amount, int id ) {
   player->remove_extra_look( this_object() );
}
void decrease_amount( object player, int amount, int id ) {
   amount -= 3 + random( random(amount) );
   if ( amount < 0 ) {
      amount = 0;
      player->submit_ee( 0, 1, EE_REMOVE );
   }
   player->set_arg_of( (int)player->sid_to_enum( id ), amount );
   player->add_effect("/std/effects/other/wetness", roll_MdN( 10, 10 ) );
}
string extra_look( object player ) {
   int *enums;
   string desc;
   enums = (int *)player->effects_matching( "mudlib.snowball" );
   if ( !sizeof( enums ) )
      return "";
   switch ( (int)player->arg_of( enums[ 0 ] ) ) {
      case 0 .. 99 :
         desc = " has a little bit of snow";
         break;
      case 100 .. 199 :
         desc = " has a bit of snow";
         break;
      case 200 .. 299 :
         desc = " has a few small lumps of snow";
         break;
      case 300 .. 399 :
         desc = " has a few lumps of snow";
         break;
      case 400 .. 499 :
         desc = " has a number of lumps of snow";
         break;
      case 500 .. 599 :
         desc = " has quite a lot of snow";
         break;
      case 600 .. 699 :
         desc = " has a lot of snow";
         break;
      default :
         desc = " has a thick layer of snow";
   }
   return capitalize( (string)player->query_pronoun() ) + desc +" on "+
         (string)player->query_possessive() +" face.\n";
}

==================================================
FILE: effects/disease/basic_disease.c
==================================================

#include <effect.h>
#include <disease.h>
int do_setup;
string name, classification, shadow_ob;
void set_name( string str ) { name = str; }
string query_name() { return name; }
void set_classification( string str ) { classification = str; }
string query_classification() { return classification; }
void create() {
   name = "Some undefined disease";
   classification = "disease.unset";
   if ( !do_setup )
      this_object()->setup();
}
int cure( object person, string cure_classification, int power, int enum ) {
   int arg, i, scale;
   string *cure_class, *disease_class;
   arg = person->arg_of( enum );
   disease_class = explode( classification, "." )[ 1 .. <1 ];
   cure_class = explode( cure_classification, "." )[ 1 .. <1 ];
   while ( sizeof( disease_class ) && sizeof( cure_class ) &&
          ( disease_class[ 0 ] == cure_class[ 0 ] ) ) {
      disease_class = disease_class[ 1 .. <1 ];
      cure_class = cure_class[ 1 .. <1 ];
   }
   scale = 1;
   i = sizeof( disease_class );
   while ( i-- )
      scale *= DISEASE_SCALE[ i ];
   i = sizeof( cure_class );
   while ( i-- )
      scale *= CURE_SCALE[ i ];
   arg -= power / scale;
   power = -arg * scale;
   person->set_arg_of( enum, arg );
   if ( arg > 0 )
      this_object()->disease_better( person, arg );
   return power;
}

==================================================
FILE: effects/disease/common_cold.c
==================================================

#include <disease.h>
#include <effect.h>
inherit SIMPLE_DISEASE;
void setup() {
   set_name( "Common Cold" );
   set_cure_rate( 6 );
   set_classification( "disease.infection.respiratory.cold" );
}
int disease_start( object player, int arg, int sid ) {
   tell_object( player, "You realise that your nose is running.\n" );
   player->submit_ee2( sid, "sap_strength", ({ 600, 600 }), EE_CONTINUOUS );
   return arg;
}
void disease_end( object player, int arg, int sid ) {
   if ( !player->query_property( "dead" ) )
      tell_object( player, "You realise that your nose is clear again.\n" );
}
void disease_action( object player, int arg ) {
   switch ( random( 3 ) ) {
      case 0 :
         player->new_parser( "sniff" );
         break;
      case 1 :
         player->new_parser( "cough" );
         break;
      default :
         player->new_parser( "sneeze" );
   }
}
void sap_strength( object player ) {
   tell_object( player, "You feel your strength being sapped by the cold.\n" );
   player->adjust_tmp_str( -1 );
}

==================================================
FILE: effects/disease/flea_infestation.c
==================================================

#include <effect.h>
#include <disease.h>
inherit SIMPLE_DISEASE;
void setup() {
   set_name( "Fleas" );
   set_classification( "disease.parasite.external.flea" );
  set_infection_chance( 2 );
   set_infection_check( (: living( $1 ) &&
               ( ( !userp( $1 ) && !$1->query_property( "unique" ) ) ||
               $1->query_mature() ) && !$1->query_property( "dead" ) :) );
}
int disease_start( object player, int arg, int ) {
   string race_ob;
   race_ob = (string)player->query_race_ob();
   if ( ( (string)race_ob->query_name() == "troll" ) ||
         player->query_property( "no fleas" ) ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return 0;
   }
   return arg;
}
void disease_action( object player, int, int ) {
   switch( random( 14 ) ) {
      case 0 .. 3 :
         player->remove_hide_invis( "hiding" );
         tell_object( player, "Something itches.  You scratch yourself.\n" );
         tell_room( environment( player ), (string)player->one_short() +
               " scratches "+ (string)player->query_objective() +"self.\n",
               player );
         break;
      case 4 .. 7 :
         player->remove_hide_invis( "hiding" );
         tell_object( player, "Ouch!  Something bit you!\n" );
         tell_room( environment( player ), (string)player->one_short() +
               " starts as if bitten.\n", player );
         player->adjust_hp( -10 - random( 10 ) );
         break;
      case 8 .. 11 :
         tell_object( player, "You notice a small red welt on your skin.\n" );
         break;
      default:
   }
   if(!random(10) && !userp(player))
     player->submit_ee(0, 0, EE_REMOVE);
}
int test_remove( object player, int arg, int enum, int bonus ) {
   log_file( "OLD_CURE", file_name( previous_object() ) +" "+
            file_name( this_object() ) +"\n" );
   if ( arg + bonus < 30 ) {
      player->set_arg_of( enum, arg + bonus );
      return 0;
   }
   return 1;
}

==================================================
FILE: effects/disease/flu.c
==================================================

#include <effect.h>
#include "path.h"
int query_secs_between_hb() { return 1; }
string query_classification() { return "disease.infection.general.flu"; }
int beginning(object player, mixed arg) {
   tell_object(player, "You shiver.\n");
   return arg;
}
int effect_heart_beat(object player, int hbnum, mixed arg, int id){
   if (hbnum == arg) return REMOVE_THIS_EFFECT;
   return arg;
}
void end(object player) {
   tell_object(player, "You feel altogether healthy again.\n");
}
string query_shadow_ob(){ return SHADOWS+"flu_shadow"; }

==================================================
FILE: effects/disease/general_hypothermia.c
==================================================

#include <effect.h>
#include <weather.h>
#include <clothing.h>
#define DEBUG 1
#define COMFORTABLE 20
#define DEATH -500
void shiver(object player, int temperatureess, int id);
int calc_personal_temp(object player);
string query_classification() { return "disease.hypothermia"; }
int beginning( object player, int temperature, int id ) {
  if(temperature + calc_personal_temp(player) < COMFORTABLE) {
    tell_object(player, "You feel a bit chilly.\n");
    player->submit_ee( "shiver", ({ 20, 20 }), EE_CONTINUOUS );
    player->submit_ee( "stat_adjusts", ({ 240, 240 }), EE_CONTINUOUS );
    player->add_extra_look( this_object() );
  } else {
    player->submit_ee(0, 0, EE_REMOVE );
  }
  return temperature + calc_personal_temp(player) - COMFORTABLE;
}
int merge_effect( object player, int new_temperature, int old_temperature,
                  int id ) {
  return old_temperature + (new_temperature + calc_personal_temp(player) -
                            COMFORTABLE);
}
void restart(object player) {
  player->add_extra_look( this_object() );
}
void end( object player ) {
  tell_object( player, "You don't feel cold anymore.\n" );
  player->remove_extra_look( this_object() );
}
void shiver(object player, int temperature, int id) {
  int *enums, pwet, personal;
  int room_temp, min;
  if (!environment(player))
    return;
  room_temp = WEATHER->temperature_index(environment(player));
  personal = calc_personal_temp(player);
  if(room_temp + personal > COMFORTABLE)
    temperature += (room_temp + personal - COMFORTABLE);
  min = 100 * (personal + room_temp - COMFORTABLE);
  if(min > COMFORTABLE)
    min = personal + room_temp - COMFORTABLE;
  if(temperature < min)
    temperature = min;
  if(temperature >= COMFORTABLE)
    player->submit_ee(0, 0, EE_REMOVE );
  if ( temperature < DEATH ) {
    player->dest_hide_shadow();
    tell_object( player, "The cold is just too much for you.\n" );
    tell_room( environment( player ), "Frost riming "+
              (string)player->query_possessive() +" skin in a thick crust, "+
              (string)player->the_short() +" expires.\n", player );
    player->do_death();
    return;
  }
  switch(random(4)) {
  case 0 :
    player->new_parser("shiver");
    tell_object(player, "You feel cold to your bones.\n");
    break;
  case 1 :
    player->dest_hide_shadow();
    tell_object( player, "You rub your arms briskly in an attempt to "+
                "keep warm.\n" );
    tell_room( environment( player ),
              capitalize( (string)player->short() ) +" rubs "+
              (string)player->query_possessive() +" arms briskly.\n",
              player );
    break;
  case 2 :
    player->new_parser("shiver");
    enums = (int *)player->effects_matching("body.wetness");
    if ( sizeof( enums ) )
      pwet = (int)player->arg_of( enums[ 0 ] );
    if ( (int)pwet > 25 ) {
      tell_object( player, "You dislodge a lump of ice, which falls "+
                  "to the ground and shatters.\n" );
      tell_room( environment( player ),
                capitalize( (string)player->short() ) +" dislodges a lump "+
                "of ices, which falls to the ground and shatters.\n",
                player );
      player->add_effect("/std/effects/other/wetness", -25 );
    }
    break;
  default :
    player->new_parser("shiver");
    tell_object(player, "You feel really cold.\n" );
  }
  player->set_arg_of( (int)player->sid_to_enum( id ), temperature );
  return;
}
int calc_personal_temp(object player) {
  object where;
  string item, zone, type, *types, *zones;
  int count;
  zones = ({ });
  where = environment(player);
  count = 0;
  if(where->query_property("location") == "inside")
    count += 20;
  count += where->query_property("warmth");
  foreach(item in player->query_wearing()) {
    types = item->query_type();
    if(!arrayp(types))
      types = ({ item->query_type() });
    foreach(type in types) {
      foreach(zone in CLOTHING_HANDLER->query_zone_names(type)) {
        if(member_array(zone, zones) == -1)
          zones += ({ zone });
        if(item->query_property("warmth"))
          count += item->query_property("warmth");
        else
          count ++;
      }
    }
  }
  count += sizeof(zones);
  count += environment(player)->query_property("warmth");
  return count;
}
void stat_adjusts(object player, int temperature, int id ) {
  if(WEATHER->temperature_index(environment(player)) > 0 ||
     temperature > -100)
    return;
  switch(player->query_race()) {
  case "troll":
    tell_object( player, "You feel a tingling between your ears and "+
                 "new and strangely clever thoughts race along the "+
                 "superconducting neural pathways of your brain.\n" );
    player->adjust_int( 1 );
    break;
  default:
    tell_object( player, "You feel your strength being drained by the "+
                 "freezing temperatures.\n" );
    player->adjust_tmp_str( -1 );
    player->adjust_tmp_con( -1 );
    break;
  }
}
string extra_look( object player ) {
  string desc;
  int temperature;
  int *enums;
  enums = (int *)player->effects_matching( "disease.hypothermia" );
  if ( !sizeof( enums ) )
    return "";
  temperature = (int)player->arg_of(enums[0]);
  switch(temperature/5) {
    case -5 .. 100 :
      desc = "looks a bit cold.\n";
      break;
    case -10 .. -6 :
      desc = "looks rather cold.\n";
      break;
    case -30 .. -11 :
      desc = "looks very cold.\n";
      break;
    case -80 .. -31 :
      desc = "appears to be suffering from extreme hypothermia.\n";
      break;
    case -100 .. -81 :
      desc = "looks close to death from hypothermia.\n";
      break;
    default :
      return "";
  }
  return capitalize( (string)player->query_pronoun() ) +" "+ desc;
}

==================================================
FILE: effects/disease/gp_drain_effect.c
==================================================

#include <effect.h>
#include "path.h"
#include "/std/living/stats.c"
#define CLASS "general.gp.drain"
string query_classification(){
  return CLASS;
}
string query_death_reason(){
  return "wasting away slowly";
}
void adjust_health( object player ){
  int damage,
    *enums = player->effects_matching( query_classification() );
  mixed *args;
  if( sizeof( enums ) ){
    args = player->arg_of( enums[ 0 ] );
  }
  tell_object( player, "You feel woozy.\n" );
  damage = roll_MdN( 2, ( ( args[0] ) / 2 ) );
  ( player )->adjust_gp( -damage );
  tell_creator( player,
                "Drain: " + damage + "\n" );
}
mixed  *beginning( object player, mixed *arg ){
  tell_object( player, arg[2][0] + "\n" );
  player->submit_ee( "adjust_health", ({ 5, 10 }),
                     EE_CONTINUOUS, player );
  player->submit_ee( 0, arg[1], EE_REMOVE );
  return arg;
}
mixed *merge_effect( object player, mixed *old_arg, mixed *arg ){
  arg[0] = ( old_arg[0] + arg[0] ) / 2;
  player->submit_ee( 0, arg[1] + player->expected_tt(), EE_REMOVE );
  return arg;
}
void end( object player, mixed *arg ){
  string *message = arg[2];
  tell_object( player, message[1] + "\n" );
}
void restart( object player, mixed *arg ){
  string *message = arg[2];
  tell_object( player, message[0] + "\n" );
}

==================================================
FILE: effects/disease/headache.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "disease.pain.headache"; }
int beginning(object player, mixed arg) {
   tell_object(player, "Your head hurts.\n");
   player->submit_ee(0, arg, EE_REMOVE);
   player->submit_ee("pains", ({30, 60}), EE_CONTINUOUS);
   player->adjust_bonus_con(-1);
   player->adjust_bonus_dex(-1);
   player->adjust_bonus_int(-1);
   player->adjust_bonus_wis(-1);
   return arg;
}
int restart(object player, mixed arg) {
   player->submit_ee("pains", ({30, 60}), EE_CONTINUOUS);
   player->adjust_bonus_con(-1);
   player->adjust_bonus_dex(-1);
   player->adjust_bonus_int(-1);
   player->adjust_bonus_wis(-1);
   return arg;
}
int merge_effect( object player, int time1, int time2 ) {
   int duration;
   duration = time2 + player->expected_tt();
   player->submit_ee( "end", duration, EE_REMOVE );
   player->submit_ee("pains", ({30, 60}), EE_CONTINUOUS);
   return duration;
}
void pains( object player) {
   switch (random(5)) {
    case 0:
      tell_object( player, "Your head hurts.\n");
      tell_room( environment( player ), player->the_short()
           + " looks pained.\n",  ({ player }) );
      break;
    case 1:
      tell_object( player, "You clutch your aching head.\n");
      tell_room( environment( player ), player->the_short()
           + " clutches " + player->query_possessive() + " head.\n",
          ({ player }) );
      break;
    case 2:
      tell_object( player, "Owwwwwwwwwwww!\n");
      tell_room( environment( player ), player->the_short()
           + " moans.\n",  ({ player }) );
      break;
    case 3:
      tell_object( player, "Your head pounds!\n");
      tell_room( environment( player ), player->the_short()
           + " clutches " + player->query_possessive()
           + " head and moans.\n",  ({ player }) );
      break;
    case 4:
      tell_object( player, "Arrrrgh!  Migraine!\n");
      tell_room( environment( player ), player->the_short()
           + " whimpers.\n",  ({ player }) );
      break;
   }
}
void end(object player) {
   tell_object(player, "Your head feels better.\n");
   player->adjust_bonus_con(1);
   player->adjust_bonus_dex(1);
   player->adjust_bonus_wis(1);
   player->adjust_bonus_int(1);
}
string query_shadow_ob(){ return SHADOWS+"disease/headache_shadow"; }

==================================================
FILE: effects/disease/hp_drain_effect.c
==================================================

#include <effect.h>
#include "path.h"
#include "/std/living/stats.c"
#define CLASS "general.hp.drain"
string query_classification(){
  return CLASS;
}
string query_death_reason(){
  return "wasting away slowly";
}
void adjust_health( object player ){
  int damage,
    *enums = player->effects_matching( query_classification() );
  mixed *args;
  if( sizeof( enums ) ){
    args = player->arg_of( enums[ 0 ] );
  }
  tell_object( player, "You feel weak.\n" );
  damage = roll_MdN( 2, ( ( args[0] ) / 2 ) );
  if( ( player )->adjust_hp( -damage ) < 0 ){
    ( player )->attack_by( this_object() );
  }
  tell_creator( player,
                "Damage: " + damage + "\n" );
}
mixed  *beginning( object player, mixed *arg ){
  tell_object( player, arg[2][0] + "\n" );
  player->submit_ee( "adjust_health", ({ 5, 10 }),
                     EE_CONTINUOUS, player );
  player->submit_ee( 0, arg[1], EE_REMOVE );
  return arg;
}
mixed *merge_effect( object player, mixed *old_arg, mixed *arg ){
  arg[0] = ( old_arg[0] + arg[0] ) / 2;
  player->submit_ee( 0, arg[1] + player->expected_tt(), EE_REMOVE );
  return arg;
}
void end( object player, mixed *arg ){
  string *message = arg[2];
  tell_object( player, message[1] + "\n" );
}
void restart( object player, mixed *arg ){
  string *message = arg[2];
  tell_object( player, message[0] + "\n" );
}

==================================================
FILE: effects/disease/hypothermia.c
==================================================

#include <effect.h>
string query_classification() { return "disease.hypothermia"; }
int beginning( object player, int index, int id ) {
    if ( !index )
        index = 100;
   tell_object( player, "You feel a bit chilly.\n" );
   player->submit_ee( "change_index", ({ 60, 60 }), EE_CONTINUOUS );
   player->submit_ee( "stat_adjusts", ({ 90, 90 }), EE_CONTINUOUS );
   return index;
}
int merge_effect( object player, int index ) { return index; }
void end( object player ) {
   tell_object( player, "You feel a lot warmer now.\n" );
}
void change_index( object player, int index, int id ) {
  int *enums, pwet;
   if ( !environment( player ) )
      return;
   if ( !environment( player )->query_property( "freezer" ) ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return;
   }
   index -= 7 - (int)player->query_con() / 7;
   if ( index < 0 ) {
      player->dest_hide_shadow();
      tell_object( player, "The cold is just too much for you.\n" );
      tell_room( environment( player ), "Frost riming "+
            (string)player->query_possessive() +" skin in a thick crust, "+
            (string)player->the_short() +" expires.\n", player );
      player->do_death();
      return;
   }
   switch( random( 4 ) ) {
      case 0 :
         player->dest_hide_shadow();
         tell_object( player, "You shiver.\n" );
         tell_room( environment( player ),
               capitalize( (string)player->short() ) +" shivers.\n", player );
         break;
      case 1 :
         player->dest_hide_shadow();
         tell_object( player, "You rub your arms briskly in an attempt to "+
               "keep warm.\n" );
         tell_room( environment( player ),
               capitalize( (string)player->short() ) +" rubs "+
               (string)player->query_possessive() +" arms briskly.\n",
               player );
         break;
      case 2 :
        enums = (int *)player->effects_matching("body.wetness");
         if ( sizeof( enums ) )
           pwet = (int)player->arg_of( enums[ 0 ] );
         if ( (int)pwet > 25 ) {
            player->dest_hide_shadow();
            tell_object( player, "You dislodge a lump of ice, which falls "+
                  "and shatters on the floor.\n" );
            tell_room( environment( player ),
                  capitalize( (string)player->short() ) +" dislodges a lump "+
                  "of ices, which falls and shatters on the floor.\n",
                  player );
            player->add_effect("/std/effects/wetness", -25 );
         }
         break;
      default :
         tell_object( player, "You're getting really cold in here.\n" );
   }
   player->set_arg_of( (int)player->sid_to_enum( id ), index );
}
void stat_adjusts( object player ) {
   switch ( random( 3 ) ) {
      case 0 :
         tell_object( player, "You feel your strength being drained by the "+
               "below freezing temperatures.\n" );
         player->adjust_tmp_str( -1 );
         return;
      case 1 :
         tell_object( player, "You really don't feel at all well stuck in "+
               "here.\n" );
         player->adjust_tmp_con( -1 );
         return;
      default :
         if ( (string)player->query_race() == "troll" ) {
            tell_object( player, "You feel a tingling between your ears and "+
                  "new and strangely clever thoughts race along the "+
                  "superconducting neural pathways of your brain.\n" );
            player->adjust_int( 1 );
         }
   }
}

==================================================
FILE: effects/disease/rabies.c
==================================================

#include <effect.h>
#define COMBAT_EFFECT "/std/effects/fighting/combat"
string *wretch_msg = ({
    "You start to froth at the mouth and your head spins.\n",
    "The pain is so intense you want to rip your eyes out.\n",
    "The pain from your ripped flesh radiates through your body.\n",
    "You feel like howling at the moon in rabid madness.\n",
    "You spray rabid froth everywhere.\n"
});
string *room_msg = ({
    " starts to froth at the mouth and looks crazed.\n",
    "'s eyes roll in crazed fury.\n",
    " seethes in agony.\n",
    " howls at the moon in rabid agony.\n",
    " sprays froth everywhere.\n"
});
string query_classification() { return "body.disease.rabies"; }
int beginning( object player, int time ) {
   if( player->query_property( "undead" ) ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return -1;
   }
   player->submit_ee( "wretch", ({ 30, 60 }), EE_CONTINUOUS );
   player->submit_ee( 0, time, EE_REMOVE );
   player->adjust_bonus_wis( -2 );
   player->adjust_bonus_int( -2 );
   tell_object( player, "Throbbing pains radiate from your bite wound, and "
      "you feel your sanity slip away.\n" );
   return time;
}
int merge_effect( object player, int time1, int time2 ) {
    return time1;
}
int restart( object player, int time ) {
   player->adjust_bonus_wis( -2 );
   player->adjust_bonus_int( -2 );
   return time;
}
void end( object player, int time ) {
   player->adjust_bonus_int( 2 );
   player->adjust_bonus_wis( 2 );
   tell_object( player, "You feel the madness leave you, and stop frothing"
      ".\n" );
}
void wretch( object player, int time ) {
    int msg_no;
    msg_no = random( sizeof( wretch_msg ) );
    tell_object( player, wretch_msg[ msg_no ] );
    tell_room( environment( player ), (string)player->the_short() +
              room_msg[ msg_no ], player );
    player->adjust_hp( - ( ( (int)player->query_hp() / 10 ) +
                           ( random( 50 ) ) ) );
    COMBAT_EFFECT->monitor_points( player, 1 );
}
string query_death_reason() {
   return "a nasty case of rabies";
}

==================================================
FILE: effects/disease/simple_disease.c
==================================================

#include <effect.h>
#include <disease.h>
inherit BASIC_DISEASE;
int cure_rate, infection_chance;
string shadow_ob;
function infection_check;
void set_cure_rate( int i ) { cure_rate = i; }
int query_cure_rate() { return cure_rate; }
void set_infection_chance( int i ) { infection_chance = i; }
int query_infection_chance() { return infection_chance; }
void set_infection_check( function f ) { infection_check = f; }
void set_shadow_ob( string str ) { shadow_ob = str; }
string query_shadow_ob() { return shadow_ob; }
void create() {
   do_setup++;
   ::create();
   do_setup--;
   shadow_ob = 0;
   infection_chance = 0;
   infection_check = 0;
   cure_rate = 0;
   if ( !do_setup )
      this_object()->setup();
}
int beginning( object person, int arg, int id ) {
  id = person->sid_to_enum( id );
   arg = this_object()->disease_start( person, arg, id );
   if ( !arg ) {
      person->submit_ee( 0, 0, EE_REMOVE );
      return 0;
   }
   person->submit_ee( "disease_tick", ( arg > 60 ) ? 60 : arg, EE_ONCE );
   return arg;
}
int merge_effect( object person, int old_arg, int new_arg, int id ) {
   if ( old_arg < new_arg ) {
      old_arg = new_arg;
      this_object()->disease_worse( person, old_arg, id );
   }
   return old_arg;
}
void end( object person, int arg, int id ) {
   this_object()->disease_end( person, arg, id );
}
void disease_tick( object person, int arg, int id ) {
   object *things;
   int i;
   if ( arg > 100000 )
      arg = 10000;
   arg -= ( cure_rate*( (int)person->query_con() + 7 ) ) / 20 ;
   person->set_arg_of( (int)person->sid_to_enum( id ), arg );
   if ( arg < 0) {
      person->submit_ee( 0, 0, EE_REMOVE );
      return;
   }
   if (person && environment(person) &&
       file_name(environment(person)) != "/room/void" &&
       file_name(environment(person)) != "/room/rubbish" &&
       infection_chance > 0 &&
       (random( 100 ) < infection_chance) ) {
     if ( functionp( infection_check ) ) {
       things = filter_array( all_inventory( environment( person ) ),
                             infection_check ) - ({ person });
     } else {
       things = filter_array( all_inventory( environment( person ) ),
                  (: living( $1 ) &&
                   ( ( !userp( $1 ) && !$1->query_property( "unique" ) ) ||
                   userp( $1 ) ) && !$1->query_property( "dead" ) :) )
            - ({ person });
     }
     i = sizeof( things );
     if ( i ) {
       i = random( i );
       things[ i ]->add_effect( file_name( this_object() ), arg );
#ifdef DEBUG
       log_file( "INFECTION", "%s, %s infected with %s by %s\n",
                ctime( time() ),
                things[ i ]->query_name(),
                this_object()->query_name(),
                person->query_name() );
#endif
     }
   }
   person->submit_ee( "disease_tick", ( arg > 60 ) ? 60 : arg, EE_ONCE );
   if ( !query_heart_beat( person ) )
      return;
   this_object()->disease_action( person, arg, id );
}
int test_remove( object, int, int, int ) {
#ifdef DEBUG
  log_file( "OLD_CURE", file_name( previous_object() ) +" "+
            file_name( this_object() ) +"\n" );
#endif
}

==================================================
FILE: effects/curses/alone.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "misc.curse.alone"; }
string query_shadow_ob() { return SHADOWS+"alone"; }
int beginning( object player, int time ) {
   player->add_extra_look( this_object() );
}
void merge_effect( object player, int time1, int time2 ) {
}
void end(object player) {
   player->remove_extra_look( this_object() );
}
string extra_look( object player ) {
   if ( player == this_player() )
     return "";
   return capitalize( (string)player->query_pronoun() )+
     " can't see you.\n";
}

==================================================
FILE: effects/curses/antisqeal.c
==================================================

#include <effect.h>
int beginning( object player, int time ) {
    player->submit_ee( 0, time, EE_REMOVE );
    return time;
}
int merge_effect( object player, int time1, int time2 ) {
   int duration;
   duration = time2 + player->expected_tt();
   player->submit_ee( 0, duration, EE_REMOVE );
   return duration;
}
void end( object player, int time ) {
    tell_object( player, "Your ability to mangle the english language "
                         "returns.\n");
}
string query_classification() { return "misc.curse.antisqeal"; }
string query_shadow_ob() { return "/std/shadows/curses/antisqeal"; }

==================================================
FILE: effects/curses/chef_curse.c
==================================================

#include <effect.h>
int beginning( object player, int time ) {
    player->submit_ee( 0, time, EE_REMOVE );
    return time;
}
int merge_effect( object player, int time1, int time2 ) {
   int duration;
   duration = time2 + player->expected_tt();
   player->submit_ee( 0, duration, EE_REMOVE );
   return duration;
}
void end( object player, int time ) {
    tell_object( player, "Your craving for swedish meatballs goes away.\n");
}
string query_classification() { return "misc.curse.chef"; }
string query_shadow_ob() { return "/std/shadows/curses/chef_curse"; }

==================================================
FILE: effects/curses/deaf_effect.c
==================================================

#include "effect.h"
string query_classification() { return "misc.curse.deafness"; }
int query_indefinite() { return 1; }
string query_shadow_ob() { return "/std/shadows/curses/deaf_shadow"; }
mixed beginning( object player, mixed arg ) {
   tell_object( player, "Sounds seem dim and muffled.\n" );
   if ( pointerp( arg ) ) {
      player->submit_ee( "hear_better", arg[ 1 ], EE_CONTINUOUS );
      return arg[ 0 ];
   } else {
      return arg;
   }
}
void end( object player ) {
   tell_object( player, "Your hearing has returned to normal.\n" );
}
void hear_better( object player, mixed arg, int id ) {
   player->add_message(this_object(), "Your hearing improves somewhat.\n", 0);
   arg = 100 - ((100 - arg) * 2/3);
   if (arg == 100) player->delete_effect( player->sid_to_enum( id ) );
   else
      player->set_arg_of( player->sid_to_enum( id ), arg );
}
mixed merge_effect( object player, mixed old_arg, mixed new_arg, int id ) {
   player->add_message( this_object(), "Your hearing gets worse.\n", 0 );
   player->set_arg_of( player->sid_to_enum( id ), new_arg );
}

==================================================
FILE: effects/curses/ken_curse.c
==================================================

#include <effect.h>
int beginning( object player, int time ) {
    player->submit_ee( 0, time, EE_REMOVE );
    return time;
}
int merge_effect( object player, int time1, int time2 ) {
   int duration;
   duration = time2 + player->expected_tt();
   player->submit_ee( 0, duration, EE_REMOVE );
   return duration;
}
void end( object player, int time ) {
    tell_object( player, "Your craving for fish & chips passes.\n");
}
string query_classification() { return "misc.curse.ken"; }
string query_shadow_ob() { return "/std/shadows/curses/ken_curse"; }

==================================================
FILE: effects/curses/no_player_title.c
==================================================

#include <effect.h>
#include "path.h"
void beginning( object ob, int time, int id ) {
    if ( time > 0 ) {
        ob->submitt_ee( 0, time, EE_REMOVE );
    }
}
void end( object ob, int time, int id ) {
}
string query_classification() {
    return "player.no-title-allowed";
}
string query_shadow_ob() {
    return SHADOWS + "no_player_title";
}
void spam( object player, mixed args, int id ) {
tell_creator ("taffyd", "Spam\n" );
}

==================================================
FILE: effects/curses/ridcullian_curse.c
==================================================

#include <effect.h>
string query_classification() { return "misc.curse.ridcullian"; }
int merge_effect( object player, int old_arg, int new_arg, int id ) {
   player->submit_ee( 0, player->expected_tt() + new_arg, EE_REMOVE );
   tell_object(player, "You feel more concerned about your hair loss.\n");
}
int test_remove( object player, int a, int id, int bonus) {
   if (bonus > 150) return 1;
   tell_object(player, "You feel less concerned about your hair loss.\n");
   player->submit_ee(0, player->expected_tt() - bonus, EE_REMOVE);
   return 0;
}
int beginning( object player, int a, int id) {
   player->submit_ee("hair_worry", ({ 10, 20 }), EE_CONTINUOUS);
   player->submit_ee(0, a, EE_REMOVE);
   tell_object( player, "You reach up to smooth your hair, and a large "+
               "chunk of hair comes out.\n");
   tell_room( environment( player ), player->the_short() + " smooths " +
             player->query_possessive() + " hair and then stares in "+
             "horror at " + player->query_possessive() + " hands.\n",
             ({ player }) );
}
void end( object player, mixed a, int id ) {
   tell_object( player, "Ahhhh.  Your hair seems to have stopped "
               "falling out so prematurely.\n");
}
void hair_worry( object player, mixed a, int id ) {
   switch (random(5)) {
    case 0:
      player->do_say("I'm not going bald!  I mean it's "+
                     "ridiculous!  My family have never gone "+
                     "bald, except for one of my aunts!");
      break;
    case 1:
      player->do_say("I mean it wasn't there yesterday!");
      break;
    case 2:
      player->do_say("I have NOT got a bald spot!");
      break;
    case 3:
      player->do_say("Something's definitely happening, "+
                     "I can feel it in my water.");
      break;
    case 4:
      player->do_say("What about this, then?");
      break;
   }
}

==================================================
FILE: effects/curses/smurf.c
==================================================

#include <effect.h>
string query_classification() { return "misc.curse.smurf"; }
string query_shadow_ob() { return "/std/shadows/curses/ensmurfed"; }
int beginning( object player, int time ) {
   tell_object( player, "You suddenly find yourself filled with a strange "
               "fear of someone called \"Gargamel\".\n");
   if (time)
     player->submit_ee( 0, time, EE_REMOVE );
   return time;
}
int merge_effect( object player, int time1, int time2 ) {
   int duration;
   duration = time2 + player->expected_tt();
   player->submit_ee( 0, duration, EE_REMOVE );
   return duration;
}
void end( object player, int time ) {
   tell_object( player, "Your fear of Gargamel has abated.\n");
}

==================================================
FILE: effects/room/albatross_attack.c
==================================================

#include <effect.h>
#define BLIND "/std/effects/religious/blind"
#define CLASS "auriental.punishment.albatross"
#define COMBAT "/std/effects/fighting/combat"
string query_classification(){ return CLASS; }
int query_indefinite(){ return 1; }
void damage_player( object pl, int damage ){
  if( damage > 0 )
    damage = damage * -1;
  if( pl->adjust_hp( damage ) <= 0 )
    pl->attack_by( this_object() );
  COMBAT->monitor_points( pl, 1 );
}
void pecking( object pl ){
  int damage = roll_MdN( 3, 150 );
  object room = environment( pl );
  if( room->query_property( "location" ) != "outside" ){
    if( pl->expected_tt() )
      pl->submit_ee( 0, ( pl->expected_tt() + 15 + random( 20 ) ), EE_REMOVE );
    tell_object( pl,
      "The albatrosses pace around the area, glaring at you.\n" );
    tell_room( room,
      "Albatrosses pace underfoot, looking quite upset.\n",
      pl );
    return;
  }
  switch( roll_MdN( 2, 3 ) ){
    case 2:
      tell_object( pl,
        "The albatrosses peck at your eyes, blinding you.\n" );
      tell_room( room,
        "A flock of albatrosses peck at " + pl->the_short() + "'s eyes.\n",
        ({ pl }) );
      damage_player( pl, damage * 3 / 2 );
      pl->add_effect( BLIND, damage / 2 );
      break;
    case 3:
      tell_object( pl,
        "A lone albatross dive-bombs you, skewering you with its beak.\n" );
      tell_room( room,
        "A single albatross dives at " + pl->the_short() + ", impaling " +
        pl->query_objective() + " with its beak.\n",
        ({ pl }) );
      damage_player( pl, damage );
      break;
    case 4:
      tell_room( room,
        "The albatrosses circle, watching you with cold, beady eyes.\n" );
      break;
    case 5:
      tell_object( pl,
        "One of the albatrosses swoops low above you, dropping an oyster "
        "shell directly on your head.\n" );
      tell_room( room,
        "A large oyster shell drops from the sky, splitting open on " +
        pl->the_short() + "'s head.\n",
        ({ pl }) );
      damage_player( pl, damage / 2 );
      break;
    default:
      tell_object( pl,
        "Several albatrosses land on your shoulders, spearing their beaks "
        "into you.\n" );
      tell_room( room,
        "Several albatrosses drop onto " + pl->the_short() + "'s shoulders, "
        "skewering " + pl->query_objective() + " with their beaks before "
        "taking off again.\n",
        ({ pl }) );
      damage_player( pl, damage * 2 );
      break;
  }
}
int beginning( object pl, int args ){
  tell_object( pl,
    "A flock of albatrosses forms above you.  They don't look pleased to see "
    "you at all.\n" );
  tell_room( environment( pl ),
    "A flock of albatrosses circles above " + pl->the_short() + "\n",
    ({ pl }) );
  pl->submit_ee( "pecking", ({ 15, 45 }), EE_CONTINUOUS, pl );
  pl->submit_ee( 0, args, EE_REMOVE );
  pl->add_extra_look( this_object() );
  return args;
}
int merge_effect( object pl, int old_args, int new_args ){
  pl->submit_ee( 0, new_args, EE_REMOVE );
  return new_args;
}
int restart( object pl, int args ){
  tell_object( pl,
    "The flock of albatrosses returns, apparently not finished with their "
    "attack.\n" );
  tell_room( environment( pl ),
    "A flock of albatrosses forms above " + pl->the_short() + "\n",
    ({ pl }) );
  pl->add_extra_look( this_object() );
  return args;
}
void end( object pl, int args ){
  tell_room( environment( pl ),
    "The albatrosses lose interest and slowly fly away, trying to remember "
    "how to be properly pointless.\n" );
  pl->remove_extra_look( this_object() );
}
string extra_look( object pl ){
  if( environment( pl )->query_property( "location" ) != "outside" ){
    return capitalize( pl->query_pronoun() ) +
      " is surrounded by angry albatrosses.\n";
  }
  return capitalize( pl->query_pronoun() ) +
    " has an angry flock of albatrosses around " +
    pl->query_objective() + ".\n";
}
string query_death_reason(){
  return "being pecked to death by albatrosses";
}

==================================================
FILE: effects/room/bubble_bath.c
==================================================

#include <effect.h>
#define PATH __DIR__
string query_classification() { return "room.bubblebath"; }
int query_surface_water(object room) {
    return room->query_surface() ||
     sizeof(filter(all_inventory(room), (: $1->query_baths() :)));
}
void beginning( object room, mixed *args) {
    object uproom;
   tell_room( room, "As the liquid enters the water it diffuses into "
         "a "+ args[1][0] +" coloured cloud.\n" );
   if(query_surface_water(room))
       tell_room( room, "A gentle fragrance of " + args[1][1] +
          " fills the room.\n");
   else if(uproom = find_object(room->query_destination(room->query_up_dir())))
       uproom->add_effect(PATH + "bubble_bath", args);
   room->submit_ee( "bubblebubble", ({10,30}), EE_CONTINUOUS );
   room->submit_ee( 0, args[0], EE_REMOVE );
   room->add_extra_look( this_object() );
   room->add_item(args[1][0] + " bubbles", "These " + args[1][0] + " coloured "
           "bubbles fill the room.");
}
mixed *merge_effect( object room, mixed *old_arg, mixed *new_arg, int id ) {
  int index,count,copy=0;
  string type;
  object uproom;
   tell_room( room, "The bubbles surge as more bubble bath is added.\n" );
   room->submit_ee( 0, new_arg[0] + (int)room->expected_tt(), EE_REMOVE );
   count = sizeof(old_arg);
   for( index = 1; index < count; index++) {
     if( new_arg[1][0] == old_arg[index][0] ) {
       copy = 1;
       break;
     }
   }
   if(!copy) {
     old_arg += ({ new_arg[1] });
     room->add_extra_look(this_object());
     type = (room->query_surface()?"air":"water");
     room->add_item( new_arg[1][0] + " bubbles", "These " + new_arg[1][0] +
        " coloured bubbles fill the " + type + ".");
     tell_room( room, "As the liquid enters the water it diffuses into "
         "a "+ new_arg[1][0] +" coloured cloud.\n" );
     if(query_surface_water(room))
     tell_room( room, "A gentle fragrance of " + new_arg[1][1] +
          " fills the air.\n");
     else if(uproom = find_object(room->query_destination(room->query_up_dir()))) {
         uproom->add_item( new_arg[1][0] + " bubbles", "These " + new_arg[1][0] +
        " coloured bubbles fill the " + type + ".");
         uproom->add_effect(PATH + "bubble_bath", new_arg);
     }
     return old_arg;
   }
   return 0;
}
void end( object room, mixed *args, int id) {
    int index, count;
    string type =(room->query_surface()?"fragrant":"colourful");
    tell_room( room, "The last of the bubbles disappear with a " + type +
             " *pop*.\n" );
    room->remove_extra_look( this_object() );
    count = sizeof(args);
    for (index = 1; index < count; index++ )
       room->remove_item( args[index][0] + " bubbles" );
}
string extra_look( object room ) {
  int *enums;
  int count, size;
  mixed  shades=({});
  string bubblez;
  string type;
  enums = room->effects_matching( query_classification() );
  type = (room->query_surface()?"smelling":"looking");
  if ( !sizeof ( enums )) return "";
  shades = room->arg_of( enums[0] );
  if ( !sizeof ( shades )) return "";
  if ( sizeof ( shades ) == 1 )
      bubblez = "A multitude of " + shades[1][0] +" coloured bubbles fill the "
      "room, " + type +  " delicately of " + shades[1][1] + ".\n";
  if ( sizeof ( shades ) > 1 ) {
    size = sizeof ( shades );
    bubblez = "The room is filled with " + shades[1][0];
    for ( count = 2; count < size; count++ ) {
        if ( count != size-1 ) {
            bubblez += ", ";
        }
        else {
            bubblez += " and ";
        }
            bubblez += shades[count][0];
    }
    bubblez += " coloured bubbles, floating everywhere.\n";
  }
      return bubblez;
}
void bubblebubble( object room, mixed *args) {
    int index = 0;
    string type = (query_surface_water(room)?"fragrance":"colours");
    string where= (query_surface_water(room)?"air":"water");
    while (!index) index = random(sizeof(args));
    tell_room( room, "The gentle " + type + " of " + args[index][1] + " floats "
               "through the " + where + " as some of the " + args[index][0] + " bubbles "
               "pop.\n");
}

==================================================
FILE: effects/room/burial.c
==================================================

#include <effect.h>
#include <cmds/bury.h>
class arg_stuff {
   object cont;
   object* obs;
   int* added;
}
private mapping _stuff;
private int _call_id;
int timeout_ob(object room, int enum, object ob);
void check_buried();
void create() {
   _stuff = ([ ]);
}
string query_classification() { return "room.burial"; }
mixed beginning( object room, object ob ) {
   if (!_stuff[room]) {
      _stuff[room] = new(class arg_stuff);
      _stuff[room]->cont = clone_object("/std/container");
      _stuff[room]->cont->add_property("burial object", 1);
      _stuff[room]->obs = ({ });
      _stuff[room]->added = ({ });
   }
   ob->move(_stuff[room]->cont);
   event (ob, "bury", ob, room);
   _stuff[room]->obs += ({ ob });
   _stuff[room]->added += ({ time() });
   if (!_call_id) {
      _call_id = call_out("check_buried", BURY_TIMEOUT);
   }
   return room;
}
mixed merge_effect( object room, class arg_stuff womble, object ob ) {
   if (!_stuff[room]) {
      _stuff[room] = new(class arg_stuff);
      _stuff[room]->cont = clone_object("/std/container");
      _stuff[room]->obs = ({ });
      _stuff[room]->added = ({ });
      _stuff[room]->cont->add_property("burial object", 1);
   }
   ob->move(_stuff[room]->cont);
   event (ob, "bury", ob, room);
   _stuff[room]->obs += ({ ob });
   _stuff[room]->added += ({ time() });
   if (!_call_id) {
      _call_id = call_out("check_buried", BURY_TIMEOUT);
   }
   return room;
}
void end( object room, class arg_stuff womble ) {
    if ( womble && classp( womble ) ) {
      all_inventory(womble->cont)->move("/room/rubbish");
      womble->cont->dest_me();
    }
}
int query_indefinite() { return 1; }
void check_buried() {
   object room;
   int i;
   class arg_stuff bing;
   _call_id = call_out("check_buried", BURY_TIMEOUT);
   foreach (room, bing in _stuff) {
     if(!classp(bing))
       continue;
     if (!room) {
       bing->obs = filter(bing->obs, (: $1 && environment($1) == $2 :),
                          bing->cont);
       bing->obs->dest_me();
       if(bing->cont)
         bing->cont->dest_me();
       map_delete(_stuff, room);
     } else {
       for (i = 0; i < sizeof(bing->obs); i++) {
         if (!bing->obs[i] ||
             environment(bing->obs[i]) != bing->cont)  {
           bing->obs = bing->obs[0..i-1] + bing->obs[i+1..];
           bing->added = bing->added[0..i-1] + bing->added[i+1..];
         } else if (bing->added[i] + BURY_TIMEOUT < time()) {
           bing->obs[i]->dest_me();
           bing->obs = bing->obs[0..i-1] + bing->obs[i+1..];
           bing->added = bing->added[0..i-1] + bing->added[i+1..];
         }
       }
       if (!sizeof(bing->obs)) {
         if (bing->cont) {
           bing->cont->dest_me();
         }
         map_delete(_stuff, room);
       }
     }
   }
   if (!sizeof(_stuff)) {
     remove_call_out(_call_id);
     _call_id = 0;
   }
}
object* query_buried_objects(object room) {
   if (_stuff[room]) {
      return _stuff[room]->obs;
   }
   return ({ });
}
object query_buried_container(object room) {
   if (_stuff[room]) {
      return _stuff[room]->cont;
   }
   return 0;
}
int remove_from_burial(object room, object ob) {
   int i;
   if (_stuff[room]) {
      i = member_array(ob, _stuff[room]->obs);
      if (i != -1) {
         _stuff[room]->obs = _stuff[room]->obs[0..i-1] +
                             _stuff[room]->obs[i+1..];
         _stuff[room]->added = _stuff[room]->added[0..i-1] +
                               _stuff[room]->added[i+1..];
         return 1;
      }
   }
   return 0;
}
mapping query_dynamic_auto_load() {
   return ([ "stuff" : _stuff ]);
}
void init_dynamic_arg(mapping map) {
   if (map && map["stuff"]) {
      _stuff = map["stuff"];
      if (!_call_id) {
         _call_id = call_out("check_buried", BURY_TIMEOUT);
      }
   }
}

==================================================
FILE: effects/room/crater.c
==================================================

#include <effect.h>
string query_classification() { return "room.crater.broom"; }
string *beginning( object room, string name ) {
  room->add_item( ({ name + " shaped crater", "crater" }),
      "There is a large crater in the ground, as if " +
      capitalize( name ) + " happened here recently, from a "
      "very great height indeed." );
  room->add_extra_look( this_object() );
  return ({ name });
}
string *merge_effect( object room, mixed old_names, string name ) {
  if( member_array( name, old_names ) != -1 ) {
    return old_names;
  }
  room->add_item( ({ name + " shaped crater", "crater" }),
      "There is a large crater in the ground, as if " +
      capitalize( name ) + " happened here recently, "
      "from a very great height indeed." );
  return old_names += ({ name });
}
void end( object room, mixed names ) {
  string name;
  foreach( name in names )  {
    room->remove_item( name + " shaped crater" );
  }
  room->remove_extra_look( this_object() );
}
int query_indefinite() { return 1; }
string extra_look( object room ) {
   int     *enums;
   string  *shapes;
   enums = room->effects_matching( query_classification() );
   if( !sizeof( enums ) )
     return "";
   shapes = room->arg_of( enums[0] );
   if( !sizeof( shapes ) )
     return "";
   if( sizeof( shapes ) == 1 )
     return "There is " + add_a( capitalize( shapes[0] ) ) +
         " shaped crater in the ground.\n";
   else {
     return "There are " + query_multiple_short( map( shapes, (: capitalize(
                $1 ) :) ) ) + " shaped craters in the ground.\n";
   }
}

==================================================
FILE: effects/room/hat_tent.c
==================================================

#include <effect.h>
void beginning() {
}
void end() {
}
string query_shadow_ob() {
   return "/std/shadows/room/hat_tent";
}
string query_classification() {
   return "room.hattent";
}

==================================================
FILE: effects/room/magic_octogram.c
==================================================

#include <effect.h>
string query_classification() { return "magic.octogram"; }
void beginning( object thing, int number, int id ) {
   tell_room( thing, "An octogram begins to glow "+
         (string)thing->query_property( "here" ) +".\n" );
   thing->submit_ee( 0, number, EE_REMOVE );
   thing->add_extra_look( this_object() );
   thing->add_item( "octogram", "The octogram glows in eldritch fashion, "
         "and that has nothing to do with being oblong." );
}
int merge_effect( object thing, int old_arg, int new_arg, int id ) {
   tell_room( thing, "The octogram pulses for a moment.\n" );
   thing->submit_ee( 0, new_arg + (int)thing->expected_tt(), EE_REMOVE );
   return old_arg + new_arg;
}
void end( object thing, int number, int id ) {
   if ( !sizeof( filter_array( previous_object( -1 ),
         (: $1->query_magic_spell() :) ) ) )
      tell_room( thing, "The octogram flickers and disappears.\n" );
   thing->remove_extra_look( this_object() );
}
string extra_look( object thing ) {
   return "An octogram "+ (string)thing->query_property( "here" ) +
         " glows in eldritch fashion.\n";
}

==================================================
FILE: effects/room/swinging.c
==================================================

#include <effect.h>
#define SWINGS "/d/sur/Sto_Lat/hill_street/playground/playground04"
string query_classification() { return "other.swinging"; }
void beginning(object player, int arg) {
  int st, tt;
  player->submit_ee("swinging", ({15, 30}), EE_CONTINUOUS);
  player->submit_ee( 0, arg, EE_REMOVE );
  tt = (int)player->expected_tt();
  st = (tt - 15);
  player->submit_ee("slowing", (st), EE_ONCE);
  if (tt < 61) {
    player->add_succeeded_mess(previous_object(), ({
      "You push off with your feet and start to swing back and "
        "forth.\n",
      "$N push$s off with $p feet and start$s to swing back and "
        "forth.\n"}));
    player->set_position("swinging back and forth");
    player->set_position_type("on");
  }
}
void merge_effect(object player, int old_arg, int new_arg) {
  int tt, st;
  tt = (int)player->expected_tt();
  tell_room(environment(player), capitalize(player->a_short() ) +
    " leans back and pulls on the swing to gain momentum.\n", player);
  tell_object(player, "You lean back and pull on the swing "
    "to gain momentum.\n");
  player->submit_ee(0, new_arg + tt, EE_REMOVE);
  st = (tt -15);
  player->submit_ee("slowing", (st), EE_ONCE);
}
void end(object player) {
  if(file_name(environment(player)) != SWINGS)
      return;
  tell_object(player, "You stop swinging.\n");
  tell_room(environment(player), capitalize(player->a_short()) +
    " stops swinging.\n", player);
  player->set_position("sitting");
  player->set_position_type("in");
}
void swinging(object player) {
   if(file_name(environment(player)) != SWINGS){
      player->submit_ee(0, 0, EE_REMOVE);
      return;
   }
  switch (random(3)) {
  case 1 :
    if (player->query_gender() == 2) {
      tell_room(environment(player), capitalize(player->a_short() ) +
        " seems very happy as she reaches the bottom of her "
        "arc on the swing.\n", player);
      tell_object(player, "You feel a pleasant tickling sensation "
        "in your stomach as you reach the bottom of your arc on "
        "the swing.\n");
    }
    else {
      tell_room(environment(player), capitalize(player->a_short() ) +
        " swings back and forth happily, just like a child again.\n",
        player);
      tell_object(player, "You swing back and forth happily, just "
        "like a child again.\n");
    }
  break;
  case 2 :
    tell_room(environment(player), capitalize(player->a_short() ) +
      " looks at if "+player->query_pronoun()+" could just "
      "fly right off into the sky as "+player->query_pronoun()+
      " reaches the top of "+player->query_possessive()+" arc on "
      "the swing.\n", player);
    tell_object(player, "You feel as if you could just fly right "
      "off into the sky as you reach the top of your arc on the "
      "swing.\n");
  break;
  case 3 :
    tell_room(environment(player), capitalize(player->a_short() ) +
      " arcs through the air like a pendlum.\n", player);
    tell_object(player, "You arc through the air like a "
      "pendlum.\n");
  break;
  default :
    tell_room(environment(player), capitalize(player->a_short() ) +
      " swings back and forth.\n", player);
    tell_object(player, "You swing back and forth.\n");
  }
}
void slowing(object player) {
  if ( (int)player->expected_tt() < 20 ) {
    tell_object(player, "Your swinging is slowing down as you "
      "gradually lose momentum.\n");
    tell_room(environment(player), capitalize(player->a_short()) +
      " slows down a bit as "+player->query_pronoun()+" loses "
      "momentum.\n", player);
  }
}

==================================================
FILE: effects/room/terrain_dont_unload.c
==================================================

#include <effect.h>
string query_classification() {return "terrain.dont.unload"; }
string query_shadow_ob() {return "/std/shadows/room/terrain_dont_unload"; }
mixed beginning( object player, mixed *arg) {
    player->setup_shad();
    return arg;
}
mixed merge_effect( object player, mixed *old, mixed *newish ) {
    player->setup_shad();
    return newish;
}

==================================================
FILE: effects/room/vomit.c
==================================================

#include <effect.h>
void pool_descripts( object room , int pools );
string query_classification () { return "room.vomit"; }
void beginning ( object room, int *args )
{
    int duration, pools ;
    duration = args [ 0 ] ;
    pools    = args [ 1 ] ;
    pool_descripts ( room , pools ) ;
    room -> submit_ee ( 0 , duration , EE_REMOVE ) ;
}
void pool_descripts ( object room , int pools )
{
    room -> remove_item( "pool" );
    room -> add_item( ({ "pool" , "vomit" , "puddle"  }) , "There " +
        ( ( pools == 1 ) ? "is a pool" : "are " + query_num( pools , 10 ) +
        " pools" ) + " of vomit decorating the place.  Inevitably there "
        "are little bits of carrot in it, and it would also be a good "
        "idea to watch one's step." ) ;
    room->add_extra_look( this_object() );
}
int *merge_effect( object room , int *new_args , int *old_args )
{
    int duration , pools ;
    duration = new_args [ 0 ] + room -> expected_tt()  ;
    pools =    new_args [ 1 ] + old_args [ 1 ] ;
    pool_descripts( room , pools ) ;
    return ({ duration , pools }) ;
}
void end( object room, mixed names )
{
    room -> remove_item ( "pool" );
    room -> remove_extra_look( this_object() );
}
string extra_look( object room )
{
    int     *enums;
    int     pools;
    string  look, number;
    enums = room -> effects_matching( query_classification() );
    if( !sizeof( enums ) ) return "";
    pools = ( room -> arg_of( enums[0] ) ) [ 1 ] ;
    number = query_num( pools , 10 );
    look = "There " + ( ( pools == 1 ) ? ( "is a pool " ) : ( "are " +
        number + " pools ") ) + "of vomit here.\n" ;
    return look;
}

==================================================
FILE: effects/room/yellow-green_gas.c
==================================================

#include <effect.h>
#define DAMAGE 1 + random(300)
#define CHOKE_TIME 20
string query_classification()
{
  return "gas.poisonous";
}
void beginning(object room, int time, int)
{
  tell_room(room,
    "A billowing yellow-green gas fills the area!\n");
  room->submit_ee("choke", CHOKE_TIME, EE_CONTINUOUS);
  room->submit_ee("clear", time, EE_REMOVE);
  room->add_extra_look(this_object());
  room->add_item("billowing yellow-green gas",
    "A thick, yellow-green gas swirls around the area.");
}
int merge_effect(object, int new_time, int old_time, int)
{
  int time_left;
  time_left = new_time + old_time;
  return time_left;
}
void clear(object room, int, int)
{
  tell_room(room, "The yellow-green gas clears.\n");
  room->remove_item("gas");
}
void choke(object room, int, int)
{
  int damage;
  object ob, *obs;
  obs = filter(all_inventory(room), (: living($1) :));
  foreach(ob in obs)
  {
    damage = DAMAGE;
    damage -= ob->query_ac("gas", damage, "head");
    if(damage > 0)
    {
      tell_object(ob,
        "You choke as you inhale the noxious gas!\n");
      tell_room(room,
        "$C$"+ob->one_short()+" chokes as "+ob->query_pronoun()+
        " inhales the noxious gas!\n", ob);
      ob->adjust_hp(-damage);
      if(ob->query_monitor())
      {
        ob->monitor_points();
      }
    }
  }
}
void end(object room, int time, int id)
{
  room->remove_extra_look(this_object());
}
string extra_look(object thing)
{
  return "A billowing yellow-green gas swirls around here.\n";
}

==================================================
FILE: effects/npc/basilisk_stare.c
==================================================

#include <effect.h>
#include "path.h"
void do_damage(object to, int amount, object from, int id)
{
  if (!to) return;
  if (to->query_hp() <= amount)
    to->delete_effect(to->sid_to_enum(id));
  to->attack_by(this_object());
  to->adjust_hp(-amount, from);
}
void stop_fighting(object who, mixed arg, int id)
{
  int *fights, i;
  fights = who->effects_matching("fighting");
  if (sizeof(fights))
    for (i = sizeof(fights) - 1; i >= 0; i--)
      who->delete_effect(fights[i]);
}
void doit(object them, int arg, int id)
{
  int dam;
  object basilisk;
  arg--;
  them->set_arg_of(them->sid_to_enum(id), arg);
  if (!arg) {
    them->delete_effect(them->sid_to_enum(id));
    return;
  }
  if (sizeof(match_objects_for_existence("basilisk", environment(them))) == 0) {
    tell_object(them, "You suddenly notice that the basilisk is no "
                "longer here.\n");
    them->delete_effect(them->sid_to_enum(id));
    return;
  }
  tell_object(them,
         ({
      "You cannot stand the deadly stare.\n",
      "Your soul is being drilled through and out the other side.\n",
      "Your eyeballs are being ripped apart.\n",
      "Your brain is being flayed.\n"
      })[random(4)]);
  tell_room(environment(them),
       ({
         them->one_short()+" cannot bear the deadly gaze.\n",
         them->one_short()+"'s soul is being torn apart.\n",
         them->one_short()+"'s brain is afire.\n",
         them->one_short()+"'s eyeballs are being drilled through.\n"
         })[random(4)], them);
  basilisk = find_living("basilisk");
  if (basilisk) {
    dam = random(50)+50;
    call_out("do_damage", 1, them, dam, basilisk, id);
  }
}
int beginning(object them, int arg, int id)
{
  tell_object(them, "You feel a pair of mental diamond drills penetrating "
         "your brain.\n");
  tell_room(environment(them), them->one_short() +
            "'s soul is about to be ripped apart.\n", them) ;
  them->submit_ee("stop_fighting", 1, EE_ONCE);
  them->submit_ee("doit", 10, EE_CONTINUOUS);
  them->add_property("passed out", 1);
  return arg;
}
void end(object them)
{
  tell_object(them, "You are freed from the basilisk's deadly stare.\n");
  them->remove_property("passed out");
}
string query_shadow_ob() {
  return SHADOWS+"basilisk_stare";
}
void merge_effect(object them, int arg1, int arg2, int id)
{
  them->set_arg_of(them->sid_to_enum(id), arg1 + arg2);
}
string query_classification() { return "magic.offensive.paralysis.stare"; }
string query_name()
{
  return "a horrible sight";
}

==================================================
FILE: effects/npc/controlled_monster.c
==================================================

#include "path.h"
string query_shadow_ob() { return SHADOWS + "controlled_monster"; }
void beginning( object player, string dest, int id ) {
}
int merge_effect( object player, int time1, int time2, int id ) {
   return time2;
}
string query_classification() { return "npc.controlled_monster"; }

==================================================
FILE: effects/npc/dont_move.c
==================================================

#include <effect.h>
#include <route.h>
#include <wander.h>
#include "path.h"
void beginning( object player, int arg, int id ) {
   player->submit_ee(0, arg, EE_REMOVE);
}
int merge_effect( object player, int time1, int time2, int id ) {
   player->submit_ee( 0, time1 + time2 - player->expected_tt(),
          EE_REMOVE );
   return time1 + time2;
}
string query_classification() { return "npc.move.no"; }
string query_shadow_ob() { return SHADOWS + "dont_move"; }

==================================================
FILE: effects/npc/drink_silly.c
==================================================

#include <effect.h>
#include <pub.h>
#include <shops/pub_shop.h>
#include "path.h"
mixed normalise(mixed arg, object player) {
   if (stringp(arg)) {
      arg = ({ arg, player });
   } else if (functionp(arg)) {
      arg = ({ arg, player });
   } else if (!pointerp(arg)) {
      arg = ({ });
   }
   return arg;
}
void beginning( object player, mixed arg, int id ) {
   player->submit_ee("buy_something", 5, EE_CONTINUOUS);
   player->do_command("stand at bar");
   return normalise(arg, player);
}
int merge_effect( object player, int time1, int time2, int id ) {
   return normalise(time1, player) + normalise(time2, player);
}
void end(object player, mixed arg, int id) {
   int i;
   for (i = 0; i < sizeof(arg); i += 2) {
      if (functionp(arg[i])) {
         evaluate(arg[i]);
      } else {
         call_other(arg[i], arg[i+1]);
      }
   }
}
string query_classification() { return "npc.drink"; }
void buy_something(object player, mixed arg, int id) {
   mapping items;
   mixed *stuff;
   string *rabbit;
   int i;
   int value;
   mixed ret;
   string place;
   string name;
   class menu_item menu;
   items = environment(player)->query_menu_items();
   rabbit = ({ });
   if (mapp(items)) {
      stuff = keys(items);
      place = environment(player)->query_property( "place" );
      if ( !place || ( place == "" ) ) {
         place = "default";
      }
      value = (int)player->query_value_in( place );
      if ( place != "default" ) {
         value += (int)player->query_value_in( "default" );
      }
      if (environment(player)->query_pub()) {
         foreach (name, menu in items) {
            if (menu->intox > 0 &&
                menu->cost < value) {
               rabbit += ({ name });
            }
         }
      } else {
         foreach (name, stuff in items) {
            if (stuff[DR_INTOX] > 0 &&
                stuff[DR_COST] < value) {
               rabbit += ({ name });
            }
         }
      }
   }
   if (!sizeof(rabbit)) {
      player->delete_effect(player->sid_to_enum(id));
   } else {
      do {
         i = random(sizeof(rabbit));
         ret = player->do_command("buy "+rabbit[i]);
         rabbit = rabbit[0..i-1] + rabbit[i+1..];
      } while (ret <= 0 && sizeof(rabbit));
      if (ret <= 0) {
         player->delete_effect(player->sid_to_enum(id));
      }
   }
}

==================================================
FILE: effects/npc/eat_corpse.c
==================================================

#include <effect.h>
#include "path.h"
void beginning( object player, string dest, int id ) {
}
int merge_effect( object player, int time1, int time2, int id ) {
   return time1;
}
string query_classification() { return "npc.eat.corpse"; }
string query_shadow_ob() { return SHADOWS + "eat_corpse"; }
int query_indefinate() { return 1; }

==================================================
FILE: effects/npc/eat_edible.c
==================================================

#include <effect.h>
#include <route.h>
#include <wander.h>
#include "path.h"
void beginning( object player, string dest, int id ) {
}
int merge_effect( object player, int time1, int time2, int id ) {
   return time1;
}
string query_classification() { return "npc.eat.edible"; }
string query_shadow_ob() { return SHADOWS + "eat_edible"; }

==================================================
FILE: effects/npc/enter.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.enter"; }
string query_shadow_ob() { return SHADOWS + "enter"; }

==================================================
FILE: effects/npc/exit.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.exit"; }
string query_shadow_ob() { return SHADOWS + "exit"; }

==================================================
FILE: effects/npc/given.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.given"; }
string query_shadow_ob() { return SHADOWS + "given"; }

==================================================
FILE: effects/npc/good_fighter.c
==================================================

#include "path.h"
#include <effect.h>
#define CLASS "npc.fighter"
string query_classification() { return CLASS; }
int query_indefinite() { return 1; }
string query_shadow_ob() { return SHADOWS "good_fighter"; }
void gfs(object player)
{
  player->good_fighter_setup();
}
int *beginning(object player, int *arg)
{
  if (!arg || !arrayp(arg) || sizeof(arg) != 2)
    arg = ({ 0, 0 });
  player->submit_ee("gfs", 1, EE_ONCE);
  return arg;
}
void restart(object player, int *arg)
{
  beginning(player, arg);
}
int *merge_effect(object player, int *oldarg, int *newarg)
{
  return oldarg;
}
void end(object player, int *arg)
{
}

==================================================
FILE: effects/npc/gossip.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.gossip"; }
string query_shadow_ob() { return SHADOWS + "gossip"; }

==================================================
FILE: effects/npc/goto_destination.c
==================================================

#include <effect.h>
#include "path.h"
#define LOG_FILE "EFFECTS"
private string standardize(mixed dest);
void call_move_to(object player, string dest)
{
  if (!player) {
#ifdef DEBUG
    log_file(LOG_FILE,
             sprintf("%O %s: player became 0 before call_move_to() called\n",
                     this_object(), ctime(time())));
#endif
    return;
  }
  if(!dest) {
#ifdef DEBUG
    log_file(LOG_FILE,
             sprintf("%O %s: dest became 0 before call_move_to() called\n",
                     this_object(), ctime(time())));
#endif
    return;
  }
  player->move_me_to(dest);
}
void remove_effect(object player, int id)
{
  if (player)
    player->remove_effect(id);
}
void beginning( object player, mixed arg, int id ) {
   mixed dest;
   if (pointerp(arg)) {
      if (sizeof(arg) > 3) {
         arg = arg[0..2];
      } else while (sizeof(arg) < 3) {
         arg += ({ 20 });
      }
   } else {
      arg = ({ arg, 0, 20 });
   }
   arg[0] = standardize(arg[0]);
   if (!dest) {
      while (!arg[0] && sizeof(arg) > 3) {
         arg = arg[3..];
         arg[0] = standardize(arg[0]);
      }
      if (!arg[0]) {
         call_out("remove_effect", 2, player, id);
         return ;
      }
   }
   if (objectp(arg[0])) {
      call_out("call_move_to", 2, player, file_name(environment(arg[0])));
   } else {
      call_out("call_move_to", 2, player, arg[0]);
   }
}
private string standardize(mixed dest) {
   if (objectp(dest)) {
      if (!living(dest)) {
         dest = file_name(dest);
      }
   } else if (stringp(dest)) {
      if (catch(dest->rabbit_well())) {
         dest = 0;
      } else {
         dest = file_name(find_object(dest));
      }
   }
   return dest;
}
mixed merge_effect( object player, mixed arg1, mixed arg2, int id ) {
   if (!pointerp(arg1)) {
      arg1 = ({ arg1, 0, 20 });
   }
   if (sizeof(arg1) > 0) {
      while (sizeof(arg1) < 3) {
         arg1 += ({ 20 });
      }
      arg1[0] = standardize(arg1[0]);
   }
   if (!pointerp(arg2)) {
      arg2 = ({ arg2, 0, 20 });
   }
   if (sizeof(arg2) > 0) {
      while (sizeof(arg2) < 3) {
         arg2 += ({ 20 });
      }
      arg2[0] = standardize(arg2[0]);
   }
   arg1 += arg2;
   while (!arg1[0] && sizeof(arg1) > 3) {
      arg1 = arg1[3..];
      arg1[0] = standardize(arg1[0]);
   }
   if (!arg1[0]) {
      call_out("remove_effect", 2, player, id);
      return ({ });
   }
   return arg1;
}
void effect_womble(object player, mixed *arr) {
  if(!player)
    return;
   player->add_effect(file_name(this_object()), arr);
}
void do_the_sell(object player) {
   object *obs;
   int i;
   obs = all_inventory(player);
   for (i = 0; i < sizeof(obs); i++) {
      if (!obs[i]->query_property("start equipment")) {
         call_out((: $1->do_command("sell "+file_name($2)) :),
                   1, player, obs[i]);
      }
   }
}
void end( object player, mixed room, int id ) {
   int ok;
   if (pointerp(room)) {
      if (sizeof(room) > 3) {
         call_out( "effect_womble", room[2], player, room[3..]);
      }
      if (!room[0]) {
         ok = 0;
      } else if (objectp(room[0])) {
         ok = (environment(room[0]) == environment(player));
      } else {
         ok = file_name(environment(player)) == room[0];
      }
      if (functionp(room[1])) {
         evaluate(room[1], player, room[0], ok, room[1]);
      }
      if (stringp(room[1])) {
         if (ok) {
            switch (room[1]) {
               case "sell" :
                  do_the_sell(player);
                  break;
               default :
                  player->do_command(room[1]);
                  break;
            }
         }
      }
      if (pointerp(room[1])) {
         call_other(room[1][0], room[1][1], player, room[0], ok, room[1]);
      }
   }
}
string query_classification() { return "npc.move"; }
string query_shadow_ob() { return SHADOWS + "goto_destination"; }

==================================================
FILE: effects/npc/i_died.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.death.me"; }
string query_shadow_ob() { return SHADOWS + "i_died"; }

==================================================
FILE: effects/npc/light_change.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.light_change"; }
string query_shadow_ob() { return SHADOWS + "light_change"; }

==================================================
FILE: effects/npc/mock_block.c
==================================================

#include "path.h"
string *beginning( object player, string *skills ) {
  return skills;
}
string *merge_effect( object player, string *old, string *arg ) {
  arg = filter( arg, (: member_array( $1, $2 ) == -1 :), old );
  return old + arg;
}
string query_classification() { return "mock.block.npc"; }
string query_shadow_ob() { return SHADOWS "mock_block"; }
int query_indefinite() { return 1; }

==================================================
FILE: effects/npc/no_follow.c
==================================================

#include <effect.h>
#include <route.h>
#include <wander.h>
#include "path.h"
void beginning( object player, string dest, int id ) {
   player->do_command("lose everyone");
}
int merge_effect( object player, int time1, int time2, int id ) {
   return time1;
}
string query_classification() { return "npc.follow.no"; }
string query_shadow_ob() { return SHADOWS + "no_follow"; }

==================================================
FILE: effects/npc/pub_brawl.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.pub_brawl"; }
string query_shadow_ob() { return SHADOWS + "pub_brawl"; }

==================================================
FILE: effects/npc/savage_corpse.c
==================================================

#include <effect.h>
#include <route.h>
#include <wander.h>
#include "path.h"
void beginning( object player, string dest, int id ) {
}
int merge_effect( object player, int time1, int time2, int id ) {
   return time1;
}
string query_classification() { return "npc.eat.savage"; }
string query_shadow_ob() { return SHADOWS + "savage_corpse"; }

==================================================
FILE: effects/npc/scavenge.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.given"; }
string query_shadow_ob() { return SHADOWS + "given"; }

==================================================
FILE: effects/npc/spell_effects.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.spell_effects"; }
string query_shadow_ob() { return SHADOWS + "spell_effects"; }

==================================================
FILE: effects/npc/they_died.c
==================================================

#include <effect.h>
#include "path.h"
string query_classification() { return "npc.death.them"; }
string query_shadow_ob() { return SHADOWS + "they_died"; }

==================================================
FILE: effects/npc/unsocial_effect.c
==================================================

#include <effect.h>
void beginning( object player,mixed *arg, int id ) {
   tell_object( player, "The spectral image of a "+arg[0]+" appears in front "
         "of you and looks sadly at you through pale eyes.  You shudder "
         "in horror as the image passes through you with tears in its "
         "eyes.  You find your yourself less able to communicate from the "
         "shock.\n");
   tell_room( environment( player ), player->the_short()+" suddenly looks "
         "straight ahead and shudders for no visible reason.\n", player );
   player->submit_ee( "reminder_mess", 20, EE_CONTINUOUS );
   player->submit_ee( 0, arg[1], EE_REMOVE );
   player->set_max_sp( 0 );
}
int merge_effect( object player, int time1, int time2, int id ) {
   player->submit_ee( 0, time1 + time2 - (int)player->expected_tt(),
         EE_REMOVE );
   return time1 + time2;
}
void end( object player, int time, int id ) {
   int number;
   tell_object( player, "You feel you have recovered and are ready to "
         "communicate with the world again.\n");
   number= player->query_real_max_sp();
   player->adjust_max_sp( number );
}
void reminder_mess( object player, mixed *arg, int id ) {
   string message;
   if (!random(4))
       switch(random(2)){
         case 0 :
           message = "The spectral image of a "+arg[0]+" just like you had "
            "as a "
            "child appears in front of you.  Before you know what you are "
            "doing you strike out at the "+arg[0]+" spilling spectral blood "
            "everywhere.\n";
           break;
         default :
           message = "You have a vision of yourself walking down a street "
            "when suddenly a masked "+arg[0]+" jumps out of the shadows "+
            "and cuts you into pieces with its natural weapons.\n";
           break;
       }
   else message = "The pitiful looking ghost of a "+arg[0]+
         " suffering from horrifying wounds drifts past you.\n";
   tell_object( player, message);
   tell_room( environment( player ),player->the_short()+" shudders and "
         "looks worried.\n", player );
   player->run_away();
   if (sizeof(player->effects_matching("priest.paralysis"))){
     tell_object(player,"You look around in panicked confusion, unsure "
                 "of exactly where you are.\n");
     tell_room( environment( player ),player->the_short()+ " stares dazedly "
                "at their surroundings.\n",player);
     tell_object(player,((environment(player)->query_long() )+"\n"));
  }
}
string query_classification() { return "curse.magic.social"; }

==================================================
FILE: effects/npc/vampirebite_effect.c
==================================================

#include <effect.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>
mapping compass = ([ "north" : 1, "northeast" : 1, "east" : 1, "southeast" : 1,
                     "south" : 1, "southwest" : 1, "west" : 1, "northwest" : 1
                    ]);
void come_around( object person );
string query_classification() { return "body.bite.vampire"; }
string query_shadow_ob() { return "/std/shadows/npc/vampirebite_shadow"; }
int survive_death() { return 1; }
int beginning( object person, int extent, int id ) {
   int con, time;
   tell_object( person, "Pain shoots through your veins, exploding inside "
      "your head, making you scream in agony as the effect of the vampire's "
      "bite fills your body.\n" );
   person->add_extra_look( this_object() );
   person->adjust_bonus_int(-2);
   person->adjust_bonus_wis(-2);
   person->adjust_bonus_str(-2);
   person->adjust_bonus_dex(-2);
   person->submit_ee( "bite_pain", ({ 10, 60 }), EE_CONTINUOUS );
   con = person->query_con();
   if( con < 1 ) con = 1;
   time = 2 * extent / con;
   person->submit_ee( 0, time, EE_REMOVE );
   return time;
}
int merge_effect( object person, int old_time, int new_extent, int id ) {
   int con, new_time;
   con = person->query_con();
   if( con < 1 ) con = 1;
   new_time = ( 2 * new_extent / con ) + person->expected_tt();
   person->submit_ee( 0, new_time, EE_REMOVE );
   return new_time;
}
void restart( object person, int time, int id ) {
   person->adjust_bonus_int(-2);
   person->adjust_bonus_wis(-2);
   person->adjust_bonus_str(-2);
   person->adjust_bonus_dex(-2);
}
void end( object person, int time, int id ) {
   if( person->query_property( PASSED_OUT_PROP ) )
      come_around( person );
   person->adjust_bonus_int(2);
   person->adjust_bonus_wis(2);
   person->adjust_bonus_str(2);
   person->adjust_bonus_dex(2);
   tell_object( person, "The firey pain screaming through your veins and "
      "incessant pounding inside your head finally wear off, leaving you "
      "with a mild headache.\n" );
}
void bite_pain( object person, int time, int id ) {
   int timeleft, selector;
   timeleft = (int)person->expected_tt();
   if( person->query_property( PASSED_OUT_PROP ) ) {
      switch( random(3) ) {
      case 0 :
         tell_room( environment(person), person->one_short() + " shakes "
            "slightly in silent agony.\n", person );
         break;
      case 1 :
         tell_room( environment(person), person->one_short() + " moans, "
            "writhing on the ground.\n", person );
         break;
      case 2 :
         tell_room( environment(person), person->one_short() + " opens " +
            person->query_possessive() + " eyes, stares around wildly as if "
            "in a fever, and passes out again with a groan.\n", person );
         break;
      }
      return;
   }
   selector = random( timeleft ) / person->query_con() / 5;
   switch( selector ) {
   case 0 :
      break;
   case 1 :
   case 2 :
      switch( random(4) ) {
      case 0 :
         person->new_parser( "gasp in pain" );
         break;
      case 1 :
         person->new_parser( "moan agonisingly" );
         break;
      case 2 :
         person->new_parser( "stumble" );
         break;
      default :
         person->new_parser( "dloh head in pain" );
         break;
      }
      break;
   case 3 :
   case 4 :
   case 5 :
      switch( random(4) ) {
      case 0 :
         tell_object( person, "You clutch your head and groan in agony as "
            "the effect of the vampires bite burns through you.\n" );
         tell_room( environment( person ), person->the_short() +
            " clutches " + person->query_possessive() + " head and groans "
            "in agony.\n", person );
         break;
      case 1 :
         tell_object( person, "You stagger about, your vision blurring and "
            "fading for a moment while your head throbs with pain.\n" );
         tell_room( environment( person ), person->the_short() +
            " staggers about, " + person->query_possessive() + " eyes "
            "drifting in and out of focus.\n", person );
         break;
      case 2 :
         tell_object( person, "You feel yourself go lightheaded and the "
            "pain fades for just a moment, before slamming back into you "
            "like a hammer to the forehead.\n" );
         tell_room( environment( person ), person->the_short() + " pales "
            "as the blood drains from " + person->query_possessive() +
            " face, then clenches " + person->query_possessive() + " teeth "
            "and groans with pain.\n", person );
         break;
      default :
         tell_object( person, "The fire flooding through your veins causes "
            "you to scream in agony, your body racked with pain.\n" );
         tell_room( environment( person ), person->the_short() + " leans "
            + person->query_possessive() + " head back and screams in "
            "pain.\n", person );
         break;
      }
      break;
   default :
      if( timeleft > 100 ) {
         switch( random(2) ) {
         case 0 :
            tell_object( person, "The world goes black.  You have "+
                "passed out.\n" );
            tell_room( environment( person ), "The blood drains from " +
                person->the_short() + "'s face, and " +
                person->query_pronoun() + " collapses heavily to the "
                "ground.\n", person );
            person->add_property( PASSED_OUT_PROP, 1 );
            person->submit_ee( "come_around", ({ 50, 80 }), EE_ONCE );
            break;
         case 1 :
            person->submit_ee( "wander_about", 3, EE_ONCE );
            break;
         }
      }
   }
}
void come_around( object person ) {
   tell_object( person, "You feel a pounding headache coming on and realise "
      "you are finally conscious.\n" );
   tell_room( environment( person ), person->the_short() + " groans "
      "painfully, opens " + person->query_possessive() + " eyes and slowly "
      "picks " + person->query_objective() + "self up.\n", person );
   person->remove_property( PASSED_OUT_PROP );
}
void wander_about( object person, int time, int id ) {
   int i, flag;
   string *direcs;
   if( person->query_property( PASSED_OUT_PROP ) || !environment( person ) )
      return;
   if( random( 4 ) )
      person->submit_ee( "wander_about", ({ 8, 8 }), EE_ONCE );
   direcs = (string *)environment( person )->query_direc();
   while( sizeof( direcs ) && !flag ) {
      i = random( sizeof( direcs ) );
      if(
          !environment( person )->query_door_open( direcs[ i ] ) ) {
         direcs = delete( direcs, i, 1 );
         continue;
      }
      person->add_property( UNKNOWN_MOVE, 1 );
      if( compass[direcs[i]] )
         flag = person->exit_command( 0, ({ direcs[ i ], "$N attempt$s to "
            "walk in one direction and instead stumble$s off towards the "
            "$T." }) );
      else
         flag = person->exit_command( 0, ({ direcs[ i ], "$N stumble$s off "
            "towards the $T." }) );
      tell_object( person, "You attempt to get up and walk and just "
         "manage to stumble around a bit.\n" );
      person->remove_property( UNKNOWN_MOVE );
      if( !flag )
         direcs = delete( direcs, i, 1 );
   }
}
string extra_look( object player, mixed *args ) {
    return capitalize(player->query_pronoun()+" looks rather pale with cold,"
    " clammy skin and a look of dizziness.\n");
}

==================================================
FILE: effects/npc/vampirecorpse_effect.c
==================================================

#include <effect.h>
string query_classification() { return "corpse.transformation.vampire"; }
void beginning( object corpse, mixed *args ) {
   corpse->add_extra_look( this_object() );
   corpse->submit_ee( "corpse_action", 10, EE_CONTINUOUS );
}
mixed *merge_effect( object corpse, mixed *old_args, mixed *new_args ) {
   return new_args;
}
void end( object corpse, mixed *args ) {
   object ob, vampire;
   tell_room( environment(corpse), "The corpse's eyes snap open, and a "
      "vicious grin spreads across its face.  It rises upwards without "
      "bothering to push away from the ground, standing upright, its eyes "
      "flashing.  You notice that the fangs of the corpse look considerably "
      "longer than they used to.\n" );
   vampire = clone_object( "/d/ram/chars/Uberwald/corpse_vampire" );
   vampire->setup_vampire( args[0], args[1] );
   vampire->move( environment( corpse ), vampire->the_short() + " glances "
      "down at " + vampire->query_objective() + "self and grimaces.  " +
      capitalize( vampire->query_pronoun() ) + " waves one arm and is "
      "instantly clothed in more fitting garments.\n"  );
   vampire->do_command( "grin viciously" );
   corpse->clear_armours();
   foreach( ob in all_inventory( corpse ) ) {
      ob->move( environment( corpse ) );
   }
   corpse->remove_extra_look( this_object() );
   corpse->move( "/room/rubbish" );
}
void corpse_action( object corpse, mixed *args ) {
   int rate;
   object *stuff;
   stuff = all_inventory (corpse);
   rate = (int) (corpse->query_decay());
  if( sizeof( stuff ) ) {
    tell_room( environment(corpse), corpse->one_short() + " twitches "
         "slightly.\n" );
    if (rate < 20) {
      tell_room( environment(corpse), corpse->one_short() + " seems to "
         "arch its back, and a faint gasp comes from its mouth.\n" );
      corpse->submit_ee( 0, 1, EE_REMOVE );
     }
    return;
   }
   switch( args[3] ) {
   case 0 :
      tell_room( environment(corpse), corpse->one_short() + " twitches "
         "slightly.\n" );
      break;
   case 1 :
      tell_room( environment(corpse), corpse->one_short() + " jerks "
         "violently, its limbs quivering.\n" );
      break;
   case 2 :
      tell_room( environment(corpse), corpse->one_short() + " seems to "
         "arch its back, and a faint gasp comes from its mouth.\n" );
      corpse->submit_ee( 0, 1, EE_REMOVE );
      break;
  }
   args[3]++;
}
string extra_look( object corpse, mixed *args ) {
   return "It seems to be twitching slightly, almost as if it's still "
      "alive.  You probably shouldn't get too close.\n";
}
int query_theft_command() { return -1; }

==================================================
FILE: effects/npc/wizards_protection.c
==================================================

#include <effect.h>
#define SHADOWS "/std/shadows/npc/"
#define SHADOW_OB  "uu_staff_protection"
string query_classification(){return "npc.protection.wizards"; }
void beginning(object player, mixed arg){
   player->submit_ee( 0, -1, EE_REMOVE );
}
string query_shadow_ob() {
   return (SHADOWS SHADOW_OB);
}
mixed merge_effect(object player, mixed old_arg, mixed new_arg){
   return new_arg;
}
int query_indefinite() { return 1; }

==================================================
FILE: effects/fighting/bob.c
==================================================

#include "path.h"
#include <effect.h>
#include <player.h>
void beginning( object player, object *things, int id ) {
   tell_object( player, "You prepare to bob "+
         (string)things[ 0 ]->the_short() +".\n" );
   player->set_data( ({ "unarmed", "blunt", "hands" }) );
   player->submit_ee( 0, 10 * COMBAT_SPEED, EE_REMOVE );
}
void end( object player, object *things, int id ) {
   if ( sizeof( things ) )
      tell_object( player, "You missed your opportunity!\n" );
}
void restart( object player, object *things, int id ) {
   player->submit_ee( 0, 0, EE_REMOVE );
}
string query_classification() { return "fighting.combat.special.punch"; }
string query_shadow_ob() { return SHADOWS +"bob"; }

==================================================
FILE: effects/attached/living_light.c
==================================================

#include "path.h"
#include <effect.h>
#define COST_PER_ROUND 30
#define INTENSITY 25
string query_classification() { return "magic.body.light"; }
int beginning( object player ) {
   tell_object( player, "A soft glow spreads out from your middle to "+
         "envelop you.\n" );
   tell_room( environment( player ), "A soft glow spreads out from "+
         (string)player->the_short() +"'s middle to envelop "+
         (string)player->query_objective() +".\n", player );
   player->adjust_light( INTENSITY );
   player->add_extra_look( this_object() );
   player->submit_ee( "decrease_points", 1, EE_ONCE );
   player->submit_ee( "decrease_points", ({ 30, 60 }), EE_CONTINUOUS );
   return INTENSITY;
}
void restart( object player, int light ) {
   player->adjust_light( light );
   player->add_extra_look( this_object() );
}
int merge_effect( object player, int light ) {
   int times;
   times = sizeof( filter_array( (object *)player->query_armours(),
         "test_for_effect", this_object() ) );
   if ( light >= ( INTENSITY * times ) )
      return light;
   tell_object( player, "The light surrounding you intensifies.\n" );
   tell_room( environment( player ), "The light around "+
         (string)player->short() +" grows brighter.\n", player );
   player->adjust_light( INTENSITY );
   return light + INTENSITY;
}
void end( object player, int light ) {
   tell_object( player, "The light surrounding you flickers and winks "+
         "out.\n" );
   tell_room( environment( player ), "The light around "+
         (string)player->short() +" flickers and winks out.\n", player );
   player->adjust_light( -light );
   player->remove_extra_look( this_object() );
}
int test_for_effect( object thing ) {
   if( !thing || !thing->query_wear_effects() )
     return 0;
   return member_array( file_name( this_object() ),
         (string *)thing->query_wear_effects() ) != -1;
}
void decrease_points( object player, int light, int id ) {
   int times;
   if ( player->query_auto_loading() )
      return;
   times = sizeof( filter_array( (object *)player->query_armours(),
         "test_for_effect", this_object() ) );
   if ( !times ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return;
   }
   if ( (int)player->query_gp() < times * COST_PER_ROUND ) {
      player->submit_ee( 0, 0, EE_REMOVE );
      return;
   }
   player->clear_gp_info();
   player->adjust_gp( - times * COST_PER_ROUND );
   if ( light != ( times * INTENSITY ) ) {
      tell_object( player, "The light surrounding you flickers and "+
            "stabilises, only a little dimmer than before.\n" );
      tell_room( environment( player ), "The light around "+
         (string)player->short() +" flickers and stabilises, only a "+
         "little dimmer than before.\n", player );
      player->adjust_light( times * INTENSITY - light );
      light = times * INTENSITY;
      player->set_arg_of( (int)player->sid_to_enum( id ), light );
   }
}
string extra_look( object player ) {
   return capitalize( (string)player->query_pronoun() ) +" is surrounded by "+
         "a soft yellow glow.\n";
}

==================================================
FILE: effects/attached/owned_transport.c
==================================================

#include <player.h>
inherit "/std/basic/virtual_quit_control";
class riding {
   object* transport;
   string* environments;
   mixed save_stuff;
}
private nosave int _transport_id;
void create() {
   _transport_id = random(3000) + 1;
}
string query_classification() {
   return "mudlib.riding.owned";
}
int query_indefinite() {
   return 1;
}
class riding beginning(object player, object transport, int id) {
   class riding bing;
   bing = new(class riding);
   bing->transport = ({ transport });
   bing->save_stuff = 0;
   transport->set_transport_id(_transport_id++);
   return bing;
}
class riding merge_effect(object player, class riding fluff, object transport) {
   if ( member_array(transport, fluff->transport) == -1) {
      if (!transport->query_transport_id()) {
         while(sizeof(filter(fluff->transport,
                             (: $1 && $1->query_transport_id() == $2 :),
                             _transport_id))) {
            _transport_id++;
         }
         transport->set_transport_id(_transport_id++);
      } else if (sizeof(filter(fluff->transport,
                        (: $1 && $1->query_transport_id() == $2 :),
                        transport->query_transport_id()))) {
         transport->dest_me();
         return fluff;
      }
      fluff->transport += ({ transport });
   }
   return fluff;
}
void end(object player, class riding arg) {
}
void restart(object player, class riding bing) {
   int i;
   object* blue;
   object* green;
   blue = filter(bing->transport, (: $1 :));
   if (!sizeof(blue) &&
       bing->save_stuff) {
      green = AUTO_LOAD_OB->load_auto_load_to_array(bing->save_stuff,
                                         player);
      for (i = 0; i < sizeof(bing->transport); i++) {
         if (green) {
            bing->transport[i] = green[i];
            green->move(bing->environments[i],
                        "$N appears with a puff of fluff.");
         }
      }
   }
}
void clear_thingy(class riding bing) {
   bing->save_stuff = 0;
}
void saving(object player, class riding bing) {
   string *env;
   bing->transport -= ({ 0 });
   env = map(bing->transport,
             (: find_start_pos($1, environment($1)) :));
   bing->environments = map(bing->transport,
                            (: find_start_pos($1, environment($1)) :));
   bing->save_stuff = AUTO_LOAD_OB->create_auto_load( bing->transport );
   call_out( (: clear_thingy :), 2, bing);
}
void quiting(object player, class riding bing) {
   call_out((: $1->move("/room/rubbish", 0,
                        "$N vanishes in a puff of fluff.") :),
            2, bing->transport);
}
void remove_owner(object player, class riding bing, int id, object trans) {
   bing->transport -= ({ trans });
   if (!sizeof(bing->transport)) {
      player->delete_effect(id);
   }
}

==================================================
FILE: effects/attached/riding.c
==================================================

class riding {
   object transport;
   mixed saved_info;
}
string extra_look(object player) {
   return player->query_pronoun() + " is riding on " +
          environment(player)->the_short();
}
string query_classification() {
   return "mudlib.riding.transport";
}
int query_indefinate() {
   return 1;
}
class riding beginning(object player, mixed arg, int id) {
   class riding bing;
   bing = new(class riding);
   return bing;
}
class riding end(object player, class riding arg) {
}
void restart(object player, class riding bing) {
}

==================================================
FILE: effects/attached/single_shoulder.c
==================================================

#include "path.h"
#include <effect.h>
string query_classification() { return "mudlib.clothing.single-shoulder"; }
int query_indefinite() { return 1; }
string query_shadow_ob() { return SHADOWS +"single_shoulder"; }
int merge_effect( object, int old_arg, int new_arg ) {
   if (objectp(new_arg)) {
      new_arg = 0;
   }
   if (objectp(old_arg)) {
      old_arg = 0;
   }
   return old_arg + new_arg;
}
void restart( object player, int handicap ) {
   player->adjust_bonus_dex( -handicap );
}
void end( object player, int handicap ) {
   if (intp(handicap)) {
      player->adjust_bonus_dex( handicap );
   }
}

==================================================
FILE: effects/attached/stat_adjustment.c
==================================================

#include "path.h"
#include <effect.h>
class stat_class {
   mapping current_adjustments;
   object* obs;
   mapping* adjs;
   object me;
}
private string* _stats;
void create() {
   _stats = ({ "str", "dex", "wis", "int", "con" });
}
string query_classification() { return "mudlib.clothing.stat"; }
void update_adjustments(object player, class stat_class arg) {
   mapping stats;
   mapping bing;
   string stat;
   int i;
   int num;
   if (sizeof(arg) == 4 && arg->me != player) {
      arg->me = player;
      arg->current_adjustments = ([ ]);
   }
if (player == find_player("presto"))  printf("UPDATE: %O\n", arg);
if (player == find_player("presto"))  printf("UPDATE: %O\n", arg->obs);
   for (i = 0; i < sizeof(arg->obs); i++) {
if (player == find_player("presto"))  {
printf("%O, %d\n", arg->obs, i);
printf( "UPDATE: checkpoint 2: %O\n", arg->obs[i]);
}
      if (!arg->obs[i]) {
         arg->obs = arg->obs[0.. i -1] + arg->obs[i+1..];
         arg->adjs = arg->adjs[0.. i -1] + arg->adjs[i+1..];
      }
   }
if (player == find_player("presto"))
tell_creator("presto", "checkpoint 3\n");
   stats = ([ ]);
   foreach (stat in _stats) {
      num = 0;
      for (i = 0; i < sizeof(arg->adjs); i++) {
         bing = arg->adjs[i];
         if (bing[stat] > 0) {
            if (i > 0) {
               num += bing[stat] / (i + 1);
            } else {
               num += bing[stat];
            }
         } else if (bing[stat] < 0) {
            if (i > 1) {
               num += bing[stat] * i;
            } else {
               num += bing[stat];
            }
         } else if (i > 0) {
            num -= i;
         }
      }
      stats[stat] = num;
   }
if (player == find_player("presto"))
tell_creator("presto", "UPDATE: checkpoint 1\n");
   foreach (stat in _stats) {
      if (stats[stat] != arg->current_adjustments[stat]) {
         call_other(player,
                    "adjust_bonus_" + stat,
                    stats[stat] - arg->current_adjustments[stat]);
         arg->current_adjustments[stat] = stats[stat];
      }
   }
}
class stat_class beginning(object player, mixed arg, int id) {
   class stat_class bing;
   bing = new(class stat_class);
   bing->current_adjustments = ([ ]);
   bing->obs = ({ arg[0] });
   bing->adjs = ({ arg[1] });
   bing->me = player;
if (player == find_player("presto"))  printf("BEFORE: %O\n", bing);
   update_adjustments(player, bing);
if (player == find_player("presto"))
tell_creator("presto", "BEGINNING: bing == %O, player == %s\n", bing, player->short());
   return bing;
}
int query_indefinite() { return 1; }
class stat_class merge_effect( object player, class stat_class old_arg, mixed new_arg ) {
   int i;
   if (pointerp(old_arg)) {
      player->submit_ee(0, 0, EE_REMOVE);
      return old_arg;
   }
   i = member_array(new_arg[0], old_arg->obs);
   if (i != -1) {
      old_arg->adjs[i] = new_arg[1];
   } else {
      old_arg->obs += ({ new_arg[0] });
      old_arg->adjs += ({ new_arg[1] });
   }
   update_adjustments(player, old_arg);
   return old_arg;
}
void restart( object player, class stat_class edible ) {
   update_adjustments(player, edible);
}
void quiting( object player, class stat_class womble ) {
   womble->obs = ({ });
   womble->adjs = ({ });
   update_adjustments(player, womble);
}
void end( object player, class stat_class bing ) {
   bing->obs = ({ });
   bing->adjs = ({ });
   update_adjustments(player, bing);
}
void remove_stat_adjustment_ob(object player, object ob) {
   class stat_class fluff;
   int *ids;
   int i;
   ids = player->effects_matching(query_classification());
   if (sizeof(ids)) {
      fluff = player->arg_of(ids[0]);
      for (i = 0; i < sizeof(fluff->obs); i++) {
         if (fluff->obs[i] == ob) {
            fluff->adjs = fluff->adjs[0..i-1] + fluff->adjs[i+1..];
            fluff->obs = fluff->obs[0..i-1] + fluff->obs[i+1..];
         }
      }
      if (!sizeof(fluff->obs)) {
         player->delete_effect(ids[0]);
      } else {
         update_adjustments(player, fluff);
         player->set_arg_of(ids[0], fluff);
      }
   }
}

==================================================
FILE: effects/attached/talker_response.c
==================================================

#include <effect.h>
#define CLASS "object.talker.response"
#define SHADOW "/std/shadows/attached/"
string query_classification() { return CLASS; }
int query_indefinite() { return 1; }
string query_shadow_ob() { return SHADOW + "talker_response"; }
mixed beginning( object item, mixed arg, int id )
{
}
mixed restart( object player, mixed arg, int id )
{
  return beginning(player, arg, id);
}
mixed merge_effect(object player, mixed oldarg, mixed newarg, int id)
{
	return oldarg;
}
void end( object player, mixed arg, int id )
{}

==================================================
FILE: effects/other/wetness.c
==================================================

#include "path.h"
#include <effect.h>
#include <weather.h>
#define MAX_EFFECT 200
#define MAX_DURATION 120
#define MAX_STRENGTH 240
#define MIN_STRENGTH 20
string query_classification() { return "body.wetness"; }
int beginning( object player, int wetness, int id ) {
  int dryness;
  tell_object( player, "Squelch.\n" );
  player->submit_ee( "squelch", ({ 20, 20 }), EE_CONTINUOUS );
  player->add_extra_look( this_object() );
  if(dryness = (int)player->check_dryness())
    wetness -= dryness;
  if ( wetness > (int)player->query_weight() )
    wetness = (int)player->query_weight();
  return wetness;
}
void restart( object player ) {
  player->add_extra_look( this_object() );
}
int merge_effect( object player, int new_wetness, int old_wetness, int id ) {
  int wetness, dryness;
  wetness = new_wetness + old_wetness;
  if(dryness = (int)player->check_dryness())
    wetness -= dryness;
  if ( wetness > (int)player->query_weight() )
      wetness = (int)player->query_weight();
  if ( wetness <= 0 )
    player->submit_ee(0, 0, EE_REMOVE );
  return wetness;
}
void end( object player, int strength, int id ) {
  tell_object(player, "You feel dry now.\n");
  player->remove_extra_look( this_object() );
}
void squelch(object player, int wetness, int id) {
  string loc;
  object env;
  int bingle;
  env = environment(player);
  if(!env)
    return;
  loc = (string)env->query_property("location");
  if(loc == "outside" && (int)WEATHER->query_temperature(env) > 0) {
    bingle = (int)WEATHER->query_temperature(env) / 2 +
      env->query_property("warmth");
  } else if(loc == "inside")
    bingle = (20 / 2) + env->query_property( "warmth" );
  if(player->query_personal_temp() / 3 > bingle)
    bingle -= (player->query_personal_temp() / 3);
  if(!env->query_water() && bingle > 0)
    wetness -= bingle;
  if(player->query_property("dead"))
    wetness = 0;
  if(wetness <= 0)
    player->submit_ee(0, 0, EE_REMOVE );
  if (wetness > 10 && !random(3) && !env->query_water() ) {
    tell_object(player, "Squelch.\n" );
  }
  player->set_arg_of(player->sid_to_enum(id), wetness);
}
string wet_string( object player, int self ) {
  int wetness;
  int *enums;
  enums = (int *)player->effects_matching( "body.wetness" );
  if ( !sizeof( enums ) )
    return "";
  wetness = (int)player->arg_of(enums[0]);
  if (!intp(wetness)) {
     wetness = 0;
     player->submit_ee(0, 0, EE_REMOVE );
  }
  switch ( ( wetness * 100 ) / ( 1 +
      (int)player->query_weight() ) ) {
    case 0 .. 5 :
      if (self)
        return "look slightly wet";
      else
        return "looks slightly wet";
    case 6 .. 10 :
      if (self)
        return "look rather wet";
      else
        return "looks rather wet";
    case 11 .. 30 :
      if (self)
        return "look wet and bedraggled";
      else
        return "looks wet and bedraggled";
    case 31 .. 80 :
      if (self)
        return "are soaked and don't look that well at all";
      else
        return "is soaked and doesn't look that well at all";
    case 81 .. 100 :
      if (self)
        return "look like you have just been dunked in a lake";
      else
        return "looks like "+ player->query_pronoun() +
          " has just been dunked in a lake";
      break;
    default :
      return "";
  }
}
string extra_look(object player)  {
   return capitalize(player->query_pronoun()) + " " + wet_string(player, 0) +
             ".\n";
}

==================================================
FILE: npc/goals_inherit.c
==================================================

#include <npc/goals.h>
#include "goal_inherit.h"
class goal_information {
   mixed data;
   int priority;
   string *events;
}
class plan_info {
   int priority;
   mixed data;
}
private nosave mapping _goals;
private nosave mapping _events;
private nosave mapping _emotions;
private nosave mixed* _plans;
private nosave string  _current_plan;
private class goal_information query_goal_information(string goal);
void remove_goal_event(string goal, string event);
void add_goal_event(string goal, string event);
int query_goal_priority(string goal);
int check_current_plan_finished();
void create() {
   _goals = ([ ]);
   _events = ([ ]);
   _plans = ({ });
}
mapping query_goals() {
   return _goals;
}
mapping query_events() {
   return _events;
}
void add_goal(string goal, mixed data) {
   class goal_information frog;
   if (!goal->invarient(this_object())) {
      return ;
   }
   if (!_goals[goal]) {
      frog = new(class goal_information);
      frog->data = data;
      frog->priority = goal->query_priority(this_object(), data);
      frog->events = ({ });
      _goals[goal] = frog;
      goal->initialise(this_object(), goal, data);
   } else {
      goal->add_again(this_object(), query_goal_information(goal)->data, data);
   }
}
void remove_goal(string goal) {
   class goal_information frog;
   string event;
   frog = query_goal_information(goal);
   if (frog) {
      goal->finalise(this_object(), frog->data);
      foreach (event in frog->events) {
         remove_goal_event(goal, event);
      }
      map_delete(_goals, goal);
   }
}
private class goal_information query_goal_information(string goal) {
   class goal_information frog;
   frog = _goals[goal];
   return frog;
}
mixed query_goal_data(string goal) {
   class goal_information frog;
   frog = query_goal_information(goal);
   if (frog) {
      return frog->data;
   }
   return 0;
}
int set_goal_data(string goal, mixed data) {
   class goal_information frog;
   frog = query_goal_information(goal);
   if (frog) {
      frog->data = data;
      return 1;
   }
   return 0;
}
int query_goal_priority(string goal) {
   class goal_information frog;
   frog = query_goal_information(goal);
   if (frog) {
      return frog->priority;
   }
   return GOAL_INVALID_PRIORITY;
}
void change_goal_priority(string goal) {
   class goal_information frog;
   int new_priority;
   string evt;
   frog = query_goal_information(goal);
   if (frog) {
      new_priority = goal->query_priority(this_object(), frog->data);
      if (new_priority != frog->priority) {
         frog->priority = new_priority;
      }
      foreach (evt in frog->events) {
         remove_goal_event(goal, evt);
         add_goal_event(goal, evt);
      }
   }
}
void add_goal_event(string goal, string event) {
   class goal_information frog;
   string test_goal;
   int i;
   int priority;
   int found;
   frog = query_goal_information(goal);
   if (frog) {
      if (!_events[event]) {
         _events[event] = ({ goal });
      } else if (member_array(goal, _events[event]) == -1) {
         priority = query_goal_priority(goal);
         while (i < sizeof(_events[event])) {
            test_goal = _events[event][i];
            if (query_goal_priority(_events[event][i]) < priority) {
               _events[event] = _events[event][0..i-1] + ({ goal }) +
                                _events[event][i..];
               found = 1;
               break;
            }
            i++;
         }
         if (!found) {
            _events[event] += ({ goal });
         }
      }
      frog->events += ({ event });
   }
}
void remove_goal_event(string goal, string event) {
   class goal_information frog;
   frog = query_goal_information(goal);
   if (frog && _events[event]) {
      _events[event] -= ({ goal });
      if (!sizeof(_events[event])) {
         map_delete(_events, event);
      }
      frog->events -= ({ event });
   }
}
varargs void notify_npc_event(string event, mixed *information ...) {
   string goal;
tell_creator("pinkfish", "%s %O\n", event, _events[event]);
   if (_events[event]) {
      foreach (goal in _events[event]) {
         if (goal->notify_of_event(this_object(),
                                   query_goal_information(goal)->data,
                                   event,
                                   information)) {
            return ;
         }
      }
   }
   if (sizeof(_plans)) {
      if (_plans[PLAN_PLAN]->notify_of_event(this_object(),
                                      ((class plan_info)_plans[PLAN_INFO])->data,
                                      event,
				      information)) {
         check_current_plan_finished();
      }
   }
}
void activate_plan(string plan,
                   string goal,
                   mixed data) {
   int priority;
   int pos;
   int i;
   int old;
   mixed *tmp;
   class plan_info info;
   priority = query_goal_priority(goal);
   pos = member_array(plan, _plans);
   if (pos != -1) {
      info = _plans[pos + PLAN_INFO];
      info->data = plan->combine_plans(info->data, data);
      if (info->priority != priority) {
         old = -1;
         for (i = pos - PLAN_ARRAY_SIZE; i >= 0; i -= PLAN_ARRAY_SIZE) {
            if (priority > ((class plan_info)_plans[i + PLAN_INFO])->priority) {
               old = i;
            } else {
               break;
            }
         }
         if (old != -1) {
            tmp = _plans[pos..pos + PLAN_ARRAY_SIZE];
            _plans = _plans[0..pos - 1] + _plans[pos + PLAN_ARRAY_SIZE..];
            _plans = _plans[0..old - 1] + tmp + _plans[old..];
         } else {
            for (i = pos + PLAN_ARRAY_SIZE; i < sizeof(_plans);
                 i += PLAN_ARRAY_SIZE) {
               if (priority < ((class plan_info)_plans[i + PLAN_INFO])->priority) {
                  old = i;
               } else {
                  break;
               }
            }
            if (old != -1) {
               tmp = _plans[old..old + PLAN_ARRAY_SIZE];
               _plans = _plans[0..old - 1] + _plans[old + PLAN_ARRAY_SIZE..];
               _plans = _plans[0..pos - 1] + tmp + _plans[pos..];
            }
         }
      }
   } else {
      old = -1;
      info = new(class plan_info);
      info->data = data;
      info->priority = priority;
      for (i = 0; i < sizeof(_plans); i += PLAN_ARRAY_SIZE) {
         if (priority > ((class plan_info)_plans[i + PLAN_INFO])->priority) {
            _plans = _plans[0..i - 1] + ({ plan, info }) +
                     _plans[i..];
            old = i + PLAN_ARRAY_SIZE;
            break;
         }
      }
      if (i >= sizeof(_plans)) {
         _plans += ({ plan, info });
      }
   }
tell_creator("pinkfish", "Activating %O, %O, %O\n", _current_plan, _plans[PLAN_PLAN], _plans[PLAN_INFO]);
   if (_plans[PLAN_PLAN] != _current_plan) {
      if (_current_plan) {
         pos = member_array(_current_plan, _plans);
         if (pos != -1) {
            _plans[pos + PLAN_PLAN]->suspend_plan(this_object(),
                                                  ((class plan_info)_plans[pos + PLAN_INFO])->data);
         }
      }
      _plans[PLAN_PLAN]->activate_plan(this_object(),
                                       ((class plan_info)_plans[PLAN_INFO])->data);
      while (check_current_plan_finished());
   }
}
int check_current_plan_finished() {
   if (sizeof(_plans)) {
      if (_plans[PLAN_PLAN]->finished(this_object(),
                                      ((class plan_info)_plans[PLAN_INFO])->data)) {
         _plans = _plans[PLAN_ARRAY_SIZE..];
         if (sizeof(_plans)) {
            _plans[PLAN_PLAN]->activate_plan(this_object(),
                                             ((class plan_info)_plans[PLAN_INFO])->data);
         }
         return 1;
      }
   }
   return 0;
}
void set_plan_data(string plan, mixed data) {
   int pos;
   pos = member_array(plan, _plans);
   if (pos != -1) {
      ((class plan_info)_plans[pos + PLAN_INFO])->data = data;
   }
}
mixed *stats() {
   mixed *ret;
   string goal;
   class goal_information frog;
   int goal_num;
   int i;
   goal_num = 0;
   ret = ({ });
   foreach (goal in keys(_goals)) {
      frog = query_goal_information(goal);
      ret += ({ ({ "Goal " + goal_num + ") name", goal }) });
      ret += ({ ({ "Goal " + goal_num + ") events",
                   query_multiple_short(frog->events) }) });
      ret += ({ ({ "Goal " + goal_num + ") priority",  frog->priority }) });
      goal_num++;
   }
   for (i = 0; i < sizeof(_plans); i += PLAN_ARRAY_SIZE) {
      ret += ({ ({ "Plan " + goal_num + ") name", _plans[i + PLAN_PLAN] }) });
      ret += ({ ({ "Plan " + goal_num + ") priority",
                   ((class plan_info)_plans[i + PLAN_INFO])->priority }) });
   }
   return ret;
}
void set_goal_plan_data(string goal, string plan, mixed data) {
   mixed goal_data;
   goal_data = query_goal_data(goal);
   goal->set_plan_data(this_object(), goal_data, plan, data);
}
mixed query_goal_plan_data(string goal, string plan) {
   mixed goal_data;
   goal_data = query_goal_data(goal);
   return goal->query_plan_data(this_object(), goal_data, plan);
}

==================================================
FILE: npc/locksmith.c
==================================================

#include <armoury.h>
#include <money.h>
#define LOG "/log/LOCKSMITH"
#define LOGGING 1
inherit "/obj/monster";
private void save_killers();
private void load_killers();
private void remove_killer(string name);
private void clear_false_client();
private void payment_timeout();
private int check_owner();
private void unlock(object door);
private string get_price();
private int calc_price();
private void generic_responses();
private void go_back();
private void unlock_all( string path );
private void delay_opening( string env );
void finish_opening( string path, string env );
public void confirmation(string response, object player);
public void free_for_hire();
public string query_client();
public void move_recording();
public string* query_killers();
public string* query_responses();
public string query_domain();
public string query_last_room();
protected int set_savefile(string file);
protected int set_price(int price);
protected int set_currency_region(string region);
protected int set_responses(string *responses);
protected int set_domain(string domain);
public int do_hire( int all );
public int do_pay();
public int do_ask(string exit);
private string _client;
private string* _killers;
private int _price;
private int _paid;
private int _all_doors;
private object _door;
private string _savefile;
private string _region;
private string* _responses;
private string _domain;
private string _last_room;
void create() {
  generic_responses();
  do_setup++;
  ::create();
  do_setup--;
  if (!do_setup)
    this_object()->setup();
  add_enter_commands("#move_recording");
}
void init() {
  ::init();
  if(interactive(this_player())) {
    this_player()->add_command("hire", this_object(), "<direct>",
                                  (: do_hire( 0 ) :) );
    this_player()->add_command("hire", this_object(),
                                   "<direct> to unlock an entire house",
                                   (: do_hire( 1 ) :) );
    this_player()->add_command("pay", this_object(), "<direct>");
    this_player()->add_command("ask", this_object(),
                                "<direct> to {open|unlock} [the] "
                                "<word'exit'> door",
                                (: do_ask($4[2]) :));
    this_player()->add_command("confirm", this_object(), "");
  }
}
void reset() {
  clear_false_client();
}
public void free_for_hire() {
  _client = 0;
  _paid = 0;
  _door = 0;
  _all_doors = 0;
  set_move_after(60, 60);
}
public string query_client() {
  if(!_client)
    return 0;
  return _client;
}
public void move_recording() {
  object room = environment(this_object());
  if(!room) {
    if(query_name() != "object")
      call_out("dest_me", 5);
    return;
  }
  if(_client) {
    if(_domain && base_name(room)[0..5] == _domain) {
      if(!room->query_owner())
        _last_room = base_name(room);
      return;
    }
    do_command("sayto " + _client + " " + _responses[11]);
    go_back();
  }
}
public string* query_killers() {
  return _killers;
}
public string query_domain() {
  return _domain;
}
public string query_last_room() {
  return _last_room;
}
public void confirmation(string response, object player) {
  if(!response || !player)
    return;
  switch(lower_case(response)) {
  case "yes":
  case "y":
    break;
  case "no":
  case "n":
    do_command("nod");
    do_command("follow " + player->query_name());
    _door = 0;
    return;
  default:
    do_command("sayto " + player->query_name() + " " + _responses[0]);
    return;
  }
  if(!_client || player->query_name() != _client) {
    do_command("sayto " + player->query_name() + " " + _responses[1]);
    return;
  }
  if(!check_owner()) {
    do_command("sayto " + player->query_name() + " " + _responses[2]);
#ifdef LOGGING
    log_file(LOG, "%s: %s tried to get %s to unlock door in %s leading "
              "to %s.\n", ctime(time()), _client, query_short(),
              base_name(environment(this_object())),_door->query_dest());
#endif
  } else if( _all_doors == 0 ) {
    queue_command("emote eyes the lock on the door.", 1);
    queue_command("emote fiddles around on the lock with some wires.", 5);
    queue_command("emote seems satisfied.", 5);
    unlock(_door);
    queue_command("sayto " + player->query_name() + " " + _responses[3], 2);
#ifdef LOGGING
    log_file(LOG,
              "%s: %s successfully got %s to unlock door in %s leading %s.\n",
              ctime(time()), _client, query_short(),
              base_name(environment(this_object())), _door->query_dest());
#endif
  } else {
    queue_command("emote eyes the lock on the door.", 1);
    queue_command("emote fiddles around on the lock with some wires.", 5);
    queue_command("'Stand back and wait for me.", 5 );
    queue_command("emote opens the door and disappears into the house, locking "
                      "the door after " + query_objective() + ".", 2 );
    delay_opening( base_name( environment( this_object() ) ) );
    return;
  }
  free_for_hire();
  go_back();
}
public string* query_responses() {
  return _responses;
}
protected int set_savefile(string file) {
  if(!file)
    return 0;
  _savefile = file;
  load_killers();
  return 1;
}
protected int set_price(int price) {
  if(!price)
    return 0;
  _price = price;
  return 1;
}
protected int set_currency_region(string region) {
  if(!region)
    return 0;
  _region = region;
  return 1;
}
protected int set_domain(string domain) {
  if(sizeof(domain) != 6)
    return 0;
  _domain = domain;
}
protected int set_responses(string* responses) {
  if(sizeof(responses) != 13)
    return 0;
  _responses = responses;
}
public int do_hire( int all ) {
  if(!this_player())
    return 0;
  if(!this_player()->query_visible(this_object())) {
    this_player()->add_failed_mess(this_object(),
                                    "$C$" + this_object()->the_short() +
                                   " cannot even see you.\n", ({ }));
    return 0;
  }
  if(_client && this_player()->query_name() != _client) {
    do_command("sayto " + this_player()->query_name() + " " + _responses[4]);
    this_player()->add_failed_mess(this_object(), "", ({ }));
    return 0;
  }
  if(_client && this_player()->query_name() == _client) {
    if(_paid) {
      if(member_array(this_object(), this_player()->query_followers())
          == -1) {
        do_command("nod " + this_player()->query_name());
        do_command("follow " + this_player()->query_name());
        this_player()->add_succeeded_mess(this_object(), "", ({ }));
        return 1;
      }
      do_command("sayto " + this_player()->query_name() + " " +
                  _responses[12]);
      this_player()->add_failed_mess(this_object(), "", ({ }));
      return 0;
    }
    do_command("sayto " + this_player()->query_name() + " " +
                _responses[5]);
    this_player()->add_failed_mess(this_object(), "", ({ }));
    return 0;
  }
  _client = this_player()->query_name();
  _all_doors = all;
  queue_command("sayto " + this_player()->query_name() + " " +
                 _responses[6], 1);
  if(member_array(_client, _killers) != -1)
    queue_command("sayto " + this_player()->query_name() +
                   " I remember you... for you it'll be " + get_price() +
                   ".  Up front, of course.", 2);
  else
    queue_command("sayto " + this_player()->query_name() + " That'll be "+
                   get_price() + " up front.", 2);
  this_player()->add_succeeded_mess(this_object(), "", ({ }));
  call_out((: payment_timeout() :), 60);
  return 1;
}
public int do_pay() {
  if(!this_player())
    return 0;
  if(!this_player()->query_visible(this_object())) {
    this_player()->add_failed_mess(this_object(),
                                    "$C$" + this_object()->the_short() +
                                   " cannot even see you.\n", ({ }));
    return 0;
  }
  if(!_client || this_player()->query_name() != _client) {
    do_command("whisper " + this_player()->query_name() + " I appreciate "
                "that you want to give away your cash, but don't you think "
                "should 'hire' me first?");
    this_player()->add_failed_mess(this_object(), "", ({ }));
    return 0;
  }
  if(_paid) {
    do_command("sayto " + this_player()->query_name() + " " + _responses[7]);
    this_player()->add_failed_mess(this_object(), "", ({ }));
    return 0;
  }
  if(this_player()->query_value_in(_region) < _price) {
    do_command("sayto " + this_player()->query_name() + " " +
                _responses[8]);
    free_for_hire();
    this_player()->add_failed_mess(this_object(), "", ({ }));
    return 0;
  }
  this_player()->pay_money(MONEY_HAND->create_money_array(calc_price(),
                                                            _region), _region);
  _paid = 1;
  set_move_after(1200, 0);
  do_command("emote puts the money into a pocket.");
  do_command("whisper " + this_player()->query_name() + " " + _responses[10]);
  init_command("follow " + this_player()->query_name(), 1);
  this_player()->add_succeeded_mess(this_object(), "$N pay$s $D.\n", ({ }));
#ifdef LOGGING
  log_file(LOG, "%s: %s hired %s for %s" +
      ( (_all_doors == 1)?" (all doors)":"" ) + "\n",
      ctime(time()), _client, query_short(), get_price() );
#endif
  remove_killer(_client);
  return 1;
}
public int do_ask(string exit) {
  object room, door;
  string dest;
  room = environment(this_object());
  if(!this_player() || !exit || !room)
    return 0;
  if(!this_player()->query_visible(this_object())) {
    this_player()->add_failed_mess(this_object(),
                                    "$C$" + this_object()->the_short() +
                                   " cannot even see you.\n", ({ }));
    return 0;
  }
  if(!_client || this_player()->query_name() != _client) {
    do_command("sayto " + this_player()->query_name() + " " + _responses[1]);
    this_player()->add_failed_mess(this_object(),
                                   "You are not " + the_short() +
                                   "'s client.\n", ({ }));
    return 0;
  }
  do_command("unfollow " + this_player()->query_name());
  dest = this_player()->find_abs(exit);
  if(room->query_destination(dest) == "/room/void") {
    do_command("sayto " + this_player()->query_name() + " " +
                _responses[9]);
    do_command("follow " + this_player()->query_name());
    this_player()->add_failed_mess(this_object(),
                                    "This exit is not valid.\n", ({ }));
    return 0;
  }
  foreach(door in room->query_hidden_objects())
    if(door->query_dest() == room->query_destination(dest)) {
      _door = door;
      break;
    }
  if( _all_doors == 0 )
    do_command("whisper " + this_player()->query_name() + " Can you confirm "
                "that this is your place?  And that you want the " + exit +
                " door opened?");
  else
    do_command("whisper " + this_player()->query_name() + " So that's your "
                "place on the other side?  Can you confirm that you want the " +
                exit + " door and all the others in your house opened?" );
  this_player()->add_succeeded_mess(this_object(), "", ({ }));
  tell_object(this_player(), "[y]es/[n]o: ");
  input_to("confirmation", 0, this_player());
  return 1;
}
void event_enter(object ob, string message, object from) {
  if(from && environment(ob) == this_object()) {
    if(ob->query_name() == "coin") {
      do_command("sayto " + file_name(from) + " You have to pay me.");
      do_command("give coins to " + file_name(from));
      return;
    }
    do_command("sayto " + file_name(from) + " I don't take donations.");
    do_command("give " + file_name(ob) + " to " + file_name(from));
  }
}
private void save_killers() {
  string killerstring, killer;
  if(!_savefile)
    return;
  if(!sizeof(_killers)) {
    unguarded((: write_file($(_savefile), "--- no killers ---", 1) :));
    return;
  }
  killerstring = "";
  foreach(killer in _killers)
    killerstring += killer + " ";
  unguarded((: write_file($(_savefile), $(killerstring), 1) :));
}
private void load_killers() {
  string killerstring;
  if(!_savefile)
    return;
  if(file_size(_savefile) == -1) {
    _killers = ({ });
    return;
  }
  killerstring = unguarded((: read_file($(_savefile)) :));
  if( !killerstring || killerstring == "--- no killers ---" ||
      !_killers = explode(killerstring, " "))
    _killers = ({ });
}
varargs object do_death(object killer, object weapon, string attack) {
  if(killer && interactive(killer)) {
    if(member_array(killer->query_name(), _killers) == -1) {
      if (!_killers) {
         _killers = ({ });
      }
      _killers += ({ killer->query_name() });
    }
  }
  save_killers();
  if(weapon && attack)
    return ::do_death(killer, weapon, attack);
  if(weapon)
    return ::do_death(killer, weapon);
  if(killer)
    return ::do_death(killer);
  return ::do_death();
}
private void remove_killer(string name) {
  int index;
  index = member_array(name, _killers);
  if(index == -1)
    return;
  if(sizeof(_killers) == 1)
    _killers = ({ });
  if(index == 0)
    _killers = _killers[ 1.. ];
  if(index == sizeof(_killers))
    _killers = _killers[ 0..(sizeof(_killers) -1) ];
  _killers = _killers[ 0..(index - 1) ] + _killers[ (index + 1).. ];
}
private void clear_false_client() {
  if(_client && find_living(_client) &&
      environment(find_living(_client)) == environment(this_object()))
    return;
  free_for_hire();
}
private void payment_timeout() {
  if(_client && !_paid)
    free_for_hire();
}
private int check_owner() {
  string dest = _door->query_dest();
  if(load_object(dest)->query_owner() == _client)
    return 1;
  return 0;
}
private void unlock(object door) {
  door->set_unlocked();
  event( load_object( door->query_dest() ), "save");
  event( environment(), "save");
}
private string get_price() {
  int price;
  if(member_array(_client, _killers) != -1)
    price = 2 * _price;
  else
    price = _price;
  if( _all_doors == 1 )
    price*= 5;
  return MONEY_HAND->money_string(MONEY_HAND->create_money_array(price,
                                                                 _region));
}
private int calc_price() {
  int price;
  if(member_array(_client, _killers) != -1)
    price = 2 * _price;
  price = _price;
  if( _all_doors == 1 )
    price *= 5;
  return price;
}
private void go_back() {
  object room, door;
  int i;
  if(!room = environment(this_object()))
    return;
  if(!_last_room || base_name(room) == _last_room) {
    do_command(room->query_exits()[random(sizeof(room->query_exits()))]);
    return;
  }
  i = member_array(_last_room, room->query_dest_dir());
  if(i == -1)
    move(_last_room, "$N walk$s in.", "$N walk$s away.");
  else {
    foreach(door in room->query_hidden_objects())
      if(door->query_dest() == _last_room &&
          door->query_locked()) {
        move(_last_room, "$N walk$s in, locking the door.",
              "$N unlock$s the door and leave$s, locking it "
              "again.");
        return;
      }
    do_command(room->query_dest_dir()[i-1]);
  }
}
private void generic_responses() {
  _responses = ({0,0,0,0,0,0,0,0,0,0,0,0,0});
  _responses[0] = "I do not understand.";
  _responses[1] = "You have to hire me.";
  _responses[2] = "This door does not lead to your house.  I cannot help you.";
  _responses[3] = "It has been a pleasure doing business with you.";
  _responses[4] = "I am already hired by someone else.";
  _responses[5] = "You have to 'pay' me.";
  _responses[6] = "You do require my services?";
  _responses[7] = "You already paid me.";
  _responses[8] = "You do not have enough money.";
  _responses[9] = "I cannot find that door.";
  _responses[10] = "Very well.  Please lead me to your house and 'ask' me to "
    "open the door that troubles you.";
  _responses[11] = "I won't leave my beloved home, sorry.  I'll wait there "
    "for a while, if you change your mind and come back.";
  _responses[12] = "You already hired me.";
}
private void unlock_all( string path ) {
    string* files = get_dir( path + "*.c" );
    string file;
    object room, ob;
    if( !sizeof( files ) )
        return;
    foreach( file in files ) {
        room = load_object( path + file );
        if( room ) {
            foreach( ob in room->query_hidden_objects() )
                if( ob->query_dest() )
                     ob->set_unlocked();
            event( room, "save" );
        }
    }
}
private void delay_opening( string env ) {
    string path;
    string* path_bits;
    path_bits = explode( env, "/" );
    path_bits[ sizeof( path_bits ) -1 ] = "";
    path = "/" + implode( path_bits, "/" );
    move( "/room/void" );
    call_out( "finish_opening", 30, path, env );
}
void finish_opening( string path, string env ) {
    unlock_all( path );
#ifdef LOGGING
    log_file(LOG,
              "%s: %s successfully got %s to unlock all doors in %s.\n",
              ctime(time()), _client, query_short(), path );
#endif
    move( env, "$N leaves the house, rubbing " + query_objective() +
           " hands.\n", "" );
    free_for_hire();
    go_back();
}

==================================================
FILE: npc/npc_intelligent.c
==================================================

#include <npc/events.h>
inherit "/obj/monster";
inherit "/std/npc/goals_inherit";
int _last_hp;
protected int check_heart_beat_results();
void create() {
   goals_inherit::create();
   monster::create();
}
void heart_beat() {
   int hp;
   ::heart_beat();
   call_out((: check_heart_beat_results :), 0);
}
protected int check_heart_beat_results() {
   hp = query_hp();
   if (hp != _last_hp) {
      if (hp > _last_hp) {
         notify_npc_event(EVENT_GAIN_HPS, hp - _last_hp, hp);
      } else {
         notify_npc_event(EVENT_LOSE_HPS, _last_hp - hp, hp);
      }
      _last_hp = hp;
   }
}
mixed *stats() {
   return monster::stats() + goals_inherit::stats();
}
int move(mixed dest, string messin, string messout) {
   int ret;
   object from;
   from = environment();
   ret = ::move(dest, messin, messout);
   if (from) {
      call_out((: notify_npc_event :), 0, EVENT_MOVED, from);
   }
   return ret;
}
void event_enter(object moving, string mess, object from) {
   if (living(from)) {
      call_out((: notify_npc_event :), 0, EVENT_GIVEN, moving);
   }
}

==================================================
FILE: npc/surface_decorator.c
==================================================

#include <money.h>
inherit "/obj/monster";
private mapping fitted_surfaces = ([ ]);
private string *allowed_surfaces = ({ });
private string *allowed_domains = ({ });
private string *responses = ({
        "'I don't fit those kinds of surfaces.",
        "'I don't fit that kind of decor.",
        "'You don't own this place, sorry!",
        "'I can't decorate surfaces here!",
        "'Something went horribly wrong!",
        "'All finished!",
        "'You don't have enough money to pay for the $decor$!  It "
        "will cost you $amount$.",
        "'I can fit $allowed$ with any of the following:",
        "'I don't have any stock right now.",
        "'Ok, I'll get right on with it.",
        "'What?  Did somebody say something?",
        "'I've already been hired by $employer$.",
        "'Ok, take me to the room you want decorated and ask me to "
        "fit something when we get there.",
        "'Sorry, I don't go there."
    });
private string under_construction_mess = "covered in dust and dirt" ;
private int work_time = 10;
private object employer;
private string last_ok;
int do_ask( string surface, string decor );
void create() {
    do_setup++;
    ::create();
    do_setup--;
    if (!do_setup) {
        this_object()->setup();
        this_object()->reset();
    }
    add_help_file("/doc/object/surface_decorator");
    add_enter_commands("#check_domain");
}
void init() {
    ::init();
    this_player()->add_command( "ask", this_object(), "<direct:object> to "
        "fit the <string'surface'> with <string'decor'>",
        (: do_ask($4[1], $4[2])  :) );
    this_player()->add_command( "list", this_object(), "goods from "
        "<direct:object>" );
    this_player()->add_command( "hire", this_object(), "<direct:object>");
}
int do_list() {
    int i;
    string thing;
    i=1;
    if( !sizeof( fitted_surfaces ) ) {
        init_command( responses[8], 1 );
        return 1;
    }
    init_command( replace( responses[7], ({
            "$allowed$", query_multiple_short( map( allowed_surfaces,
                (: pluralize($1) :) ) )
        }) ), i );
    foreach( thing in keys( fitted_surfaces ) ) {
        i++;
        init_command("'" + capitalize(thing) + " for " +
            MONEY_HAND->money_value_string(fitted_surfaces[thing][1],
            query_property("place")) + ".", i);
    }
    return 1;
}
int do_hire() {
    this_player()->add_succeeded_mess( this_object(), "$N ask$s $D about "
        + this_object()->query_possessive() + " services.\n", ({ }) );
    if( !this_player()->query_visible( this_object() ) ) {
        init_command( responses[10], 1 );
        return 1;
    }
    if( employer &&
        environment( employer ) == environment( this_object() ) &&
        this_player() != employer ) {
        init_command( replace( responses[11], ({ "$employer$", "$C$" +
            employer->query_name() }) ), 1 );
        return 1;
    }
    employer = this_player();
    do_command("unfollow everyone");
    employer->add_follower(this_object());
    init_command( responses[12], 1 );
    return 1;
}
int do_ask( string surface, string decor ) {
    string long, allowed, place;
    int fee, can_do;
    object where;
    can_do = 0;
    foreach( allowed in allowed_surfaces ) {
        if( strsrch( surface, allowed ) != -1 ) {
            can_do = 1;
        }
    }
    if( !can_do ) {
        do_command(responses[0]);
        return 1;
    }
    if( member_array( decor, keys( fitted_surfaces ) ) == -1 ) {
        do_command(responses[1]);
        return 1;
    }
    long = fitted_surfaces[decor][0];
    fee  = fitted_surfaces[decor][1];
    where = environment( this_object() );
    if(!where->test_occupier( this_player()->query_name() ) ) {
        do_command(responses[2]);
        return 1;
    }
    if(!function_exists("decorate_surface", where)) {
        do_command(responses[3]);
        return 1;
    }
    place = query_property("place");
    if ( this_player()->query_value_in( place ) < fee ) {
        do_command( replace( responses[6], ({
            "$decor$", decor,
            "$amount$", MONEY_HAND->money_value_string(fee, place)
        }) ) );
        queue_command("stare" + this_player()->query_name());
        return 1;
    }
    if(!where->decorate_surface(surface,under_construction_mess)) {
        do_command(responses[4]);
        return 1;
    }
    call_out( "finish_work", work_time, surface, long, where );
    do_command( responses[9] );
    do_command( "unfollow everyone" );
    this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array( fee,
            place ), place);
    this_player()->add_succeeded_mess( this_object(), "$N pay$s $D some "
        "money and " + this_object()->query_pronoun() + " starts to go "
        "about his work on the " + surface + ".\n", ({ }) );
    return 1;
}
void finish_work( string surface, string long, object where ) {
    do_command(":finishes his work.");
    if( employer ) {
        employer->add_follower(this_object());
    }
    if(!where || !where->decorate_surface(surface, long )) {
        do_command(responses[4]);
        return;
    }
    else {
        do_command(responses[5]);
        return;
    }
}
private void go_back() {
    move("/room/rubbish", "$N walk$s in.", "$N walk$s away.");
    if( last_ok ) {
        move(last_ok, "$N walk$s in.", "$N walk$s away.");
    }
}
void check_domain() {
    string allowed, here;
    int ok;
    here = file_name( environment( this_object() ) );
    ok = 0;
    foreach( allowed in allowed_domains ) {
        if( strsrch( here, allowed ) != -1 ) {
            ok = 1;
        }
    }
    if( ok ) {
        last_ok = here;
        return;
    }
    else {
        do_command("unfollow everyone");
        do_command( responses[13] );
        go_back();
        return;
    }
}
void add_fitted_surface( string short, string long, int cost ) {
    fitted_surfaces[ short ] = ({ long, cost });
}
mapping query_fitted_surfaces() { return fitted_surfaces; }
void remove_fitted_surface( string short ) {
    map_delete( fitted_surfaces, short );
}
void remove_all_fitted_surfaces() {
    fitted_surfaces = ([ ]);
}
void add_allowed_surface( string surface ) {
    if( member_array( surface, allowed_surfaces ) == -1 ) {
        allowed_surfaces += ({ surface });
    }
}
string *query_allowed_surfaces() { return allowed_surfaces; }
void add_allowed_domain( string domain ) {
    if( member_array( domain, allowed_domains ) == -1 ) {
        allowed_domains += ({ domain });
    }
}
string *query_allowed_domains() { return allowed_domains; }
void set_responses( string *the_responses ) {
    if( sizeof(the_responses) != sizeof(responses) ) {
        return 0;
    }
    else {
        responses = the_responses;
    }
}
string *query_responses() { return responses; }
void set_under_construction_mess( string mess ) {
    under_construction_mess = mess;
}
string query_under_construction_mess() { return under_construction_mess; }
void set_work_time( int time ) {
    work_time = time;
}
int query_work_time() { return work_time; }
void set_employer( object player ) {
    employer = player;
}
object query_employer() { return employer; }

==================================================
FILE: npc/taliswoman.c
==================================================

inherit "/obj/clothing";
#include "/d/guilds/witches/include/taliswoman.h"
void setup();
void init();
void high_level();
void set_destination(string city);
int go_granny( string *args );
nosave mapping _city_destinations = ([
   "default" : AM,
   "klk" : KLK,
   "stolat" : STO_LAT,
]);
nosave private string set_destination;
string _city;
void setup() {
    set_name( "taliswoman" );
    add_alias( ({ "stone", "ass", "thong" }) );
    set_short( "taliswoman" );
    add_adjective( ({ "small", "surly", "ass", "smooth", "leather", "thin",
        "witches'", "witches", "guild", "stone" }) );
    add_property( "talisman", "no one" );
    add_property( "no recycling", 1 );
    set_main_plural( "taliswomen" );
    set_long( "This small stone shaped like a small and surly ass has been "
      "worn smooth by frequent handling.  A thin, leather thong has been "
      "threaded through its hole.  " );
    add_extra_look( this_object() );
    set_value(1);
    set_weight(2);
    set_type( "necklace" );
    set_max_cond( 70 );
    set_cond( 70 );
    init_dynamic_arg(query_dynamic_auto_load());
}
string extra_look() {
    if( this_player()->query_name() != query_property( "talisman" ) ) {
        return "\n";
    }
    return "This taliswoman will get you to the Witches Guild to see Granny "
        "Weatherwax if you rub the tail of the ass, and back to "
        "Ankh-Morpork if you rub its head. You can only use it once in "
        "each direction, but you can get a new one from Gennie if you "
        "haven't outgrown them.\n";
}
void init() {
    add_command( "rub" , "{head|tail} of <direct:object'ass'>",
      (: go_granny( $4[0] ) :) );
}
void high_level() {
    string gender;
    switch( this_player()->query_gender() ) {
        case 0:
            gender = "thing";
            break;
        case 1:
            gender = "boy";
            break;
        case 2:
            gender = "girl";
            break;
    }
    add_failed_mess( "$D says \"You are a big " + gender + " now, so you'll "
        "have to manage without me.  Good luck on your adventures!\"\n", );
    set_worn_by(0);
    this_player()->remove_property( "given taliswoman" );
    move( "/room/rubbish", "", "$N vanishes in a puff of smoke." );
}
void set_destination( string city ) {
    _city = "city";
}
mapping query_dynamic_auto_load() {
    return ([
        "::" : ::query_dynamic_auto_load(),
        "new_destination" : _city,
    ]);
}
void init_dynamic_arg( mapping map, object ) {
    if (map["::"]) ::init_dynamic_arg(map["::"]);
    if (map[ "city" ] ]) _city = map["city"];
        else {
            _city = "default";
        }
}
int go_granny( string where ) {
    mixed destination;
    destination = _city;
    if( !query_property( "talisman" ) ) {
        add_failed_mess( "$D blinks rapidly and vanishes in a sudden fit "
            "of quantum insecurity.\n" );
        set_worn_by(0);
        move( "/room/rubbish" );
        return -1;
    }
    if( query_property( "talisman" ) != this_player()->query_name() ) {
        this_player()->add_failed_mess( this_object(), "$D isn't yours!\n"
            "It thumbs its metaphorical nose at you and refuses to do "
            "anything.\n" );
        return -1;
    }
    if( where == "tail" ) {
        if( this_player()->query_level() > 20 ) {
            high_level();
            return -1;
        }
        if( query_property( "been to bad ass" ) ) {
            add_failed_mess( "You have already used $D to travel to the "
                "witches once.\n" );
            return -1;
        }
        if( file_name( environment( this_player() ) ) == destination ) {
            add_failed_mess( "But you are already here!\n" );
            return -1;
        }
        add_succeeded_mess( ({ "$D starts to glow.  The bright glow makes "
            "you blink and when you open your eyes, you're in a new place.\n",
            "$N $V $D.\n" }) );
        if( this_player()->query_guild_ob() != "/std/guilds/witch" ) {
            call_out( (: tell_object( $(this_player()), "The taliswoman "
                "says: To the northwest, then north of here is the home of "
                "Granny Weatherwax.  You need to speak with her about "
                "becoming a witch.  To get into the cottage you will need "
                "the key to the back door; it's hidden in the privy.  To get "
                "back to Ankh-Morpork, you can rub my head or catch the "
                "carriage in Bad Ass to the southeast of here.  "
                "Good luck!\n" ) :), 2 );
            add_property( "been to bad ass", 1 );
        }
    }
    else {
        if( this_player()->query_level() > 20 ) {
            high_level();
            return -1;
        }
        if( query_property( "been to city" ) ) {
            add_failed_mess( "You have already used $D to travel to the "
                "city once.\n" );
            return -1;
        }
        if( file_name( environment( this_player() ) ) == destination ) {
            add_failed_mess( "But you are already here!\n" );
            return -1;
        }
        add_succeeded_mess( ({ "$D starts to glow.  The bright glow makes "
            "you blink and when you open your eyes, you're in a new place.\n",
            "$N $V $D.\n" }) );
        add_property( "been to city", 1 );
    }
    call_out( (: $(this_player())->move_with_look( $(destination),
        "You notice a glimmering light to the side of the road.  As you "
        "watch, the light begins to take the shape of $N as she "
        "arrives from somewhere else.",
        "A bright light surrounds $N.  It dims suddenly, then "
        "vanishes.  It seems to have taken $N with it." ) :), 0 );
    if( query_property( "been to bad ass" ) &&
        query_property( "been to city" ) ) {
        call_out( (: tell_object( $(this_player()), the_short() +
            " says: You have now used me to travel once in each direction, "
            "so our ways part here.  If you need me again, just go see "
            "Gennie.\n" ) :), 1 );
        this_player()->remove_property( "given taliswoman" );
        call_out( (: set_worn_by(0), move( "/room/rubbish", "",
            "$N vanishes in a puff of smoke." ) :), 1 );
    }
    return 1;
}
varargs int add_property( string var, mixed val, int tim ) {
    if( var == "talisman" ) {
        if( query_property( "talisman" ) &&
            query_property( "talisman" ) != "no one" ) {
            call_out( (: tell_object( $(environment()), "The taliswoman "
                "blinks rapidly and vanishes in a sudden fit of quantum "
                "insecurity.\n" ) :), 1 );
            call_out( (: set_worn_by(0), move( "/room/rubbish" ) :), 1 );
        }
    }
    return ::add_property( var, val, tim );
}
string query_destination() {
    return _city;
}

==================================================
FILE: npc/test_npc.c
==================================================

#include <npc/goals.h>
#include <npc/plan.h>
inherit "/std/npc/npc_intelligent";
void setup() {
   string goal;
   set_name("fluff");
   set_short("bit of fluff");
   set_long("A small bit of fluff.");
   set_race("human");
   set_guild("warrior");
   set_level(10);
   goal = GOALS_DIR + "basic/stay_alive_basic";
   goal->add_goal_to_npc(this_object(), ([ ]), 100);
   load_chat(100, ({ 1, "'Scruff!",
                     1, "'Chickens?",
			}));
}

==================================================
FILE: npc/goals/base.c
==================================================

#include <npc/goals.h>
private mapping _default_plans;
private int _default_priority;
#define GOAL_PLAN_ARRAY_SIZE 1
#define GOAL_PLAN_PLAN 0
void setup() {
}
void create() {
   _default_plans = ([ ]);
   _default_priority = GOAL_INVALID_PRIORITY;
   setup();
}
void initialise_plans(object npc,
                      string goal_name,
                      mixed data) {
}
void initialise(object npc,
                string goal_name,
                class goal_control control) {
   string name;
   foreach (name in keys(_default_plans)) {
tell_creator("pinkfish", "Adding event hook for %O\n", name);
      npc->add_goal_event(base_name(this_object()), name);
   }
   foreach (name in keys(control->extra_plans)) {
      npc->add_goal_event(base_name(this_object()), name);
   }
   initialise_plans(npc, goal_name, control->data);
}
string query_current_plan(object npc,
                          class goal_control control) {
   return control->current_plan;
}
mixed create_goal_data(object npc,
                       string goal_name,
                       mixed stuff) {
   return stuff;
}
void add_goal_to_npc(object npc,
                     mapping extra_plans,
		     mixed stuff) {
   class goal_control frog;
   mixed value;
   string goal_name;
tell_creator("pinkfish", "Adding goal %O to npc(%O).\n", base_name(this_object()), stuff);
   if (!mapp(extra_plans)) {
      extra_plans = ([ ]);
   }
   goal_name = base_name(this_object());
   frog = new(class goal_control);
   frog->extra_plans = extra_plans;
   frog->current_plan = 0;
   frog->priority = GOAL_DEFAULT_PRIORITY;
   frog->data = create_goal_data(npc, goal_name, stuff);
   frog->plan_info = ([ ]);
   npc->add_goal(goal_name, frog);
}
int query_priority(object npc,
                   class goal_control control) {
   if (control->priority != GOAL_DEFAULT_PRIORITY) {
      return control->priority;
   }
   return _default_priority;
}
int query_default_priority() {
   return _default_priority;
}
protected void set_default_priority(int priority) {
   _default_priority = priority;
}
int notify_of_event(object npc,
                    class goal_control control,
                    string event,
                    mixed *data) {
   int value;
   string plan;
   int max_value;
   string max_plan;
   mixed max_data;
   int i;
   mixed info;
   if (control->extra_plans[event]) {
      for (i = 0; i < sizeof(control->extra_plans[event]);
           i += GOAL_PLAN_ARRAY_SIZE) {
         plan = control->extra_plans[event][i + GOAL_PLAN_PLAN];
         info = control->plan_info[plan];
         if (plan->pre_condition(npc,
                                 base_name(this_object()),
                                 info,
                                 event,
                                 data)) {
            value = plan->query_sutability(npc,
                                           base_name(this_object()),
                                           info,
                                           event,
                                           data);
            if (value > max_value) {
               max_value = value;
               max_plan = plan;
               max_data = plan->query_data(npc,
                                           base_name(this_object()),
                                           info,
                                           event,
                                           data);
            }
         }
      }
   }
   if (_default_plans[event]) {
      for (i = 0;
           i < sizeof(_default_plans[event]);
           i += GOAL_PLAN_ARRAY_SIZE) {
         plan = _default_plans[event][i + GOAL_PLAN_PLAN];
         info = control->plan_info[plan];
         if (plan->pre_condition(npc,
                                 base_name(this_object()),
                                 info,
                                 event,
                                 data)) {
            value = plan->query_sutability(npc,
                                           base_name(this_object()),
                                           info,
                                           event,
                                           data);
            if (value > max_value) {
               max_value = value;
               max_plan = plan;
               max_data = plan->query_data(npc,
                                           base_name(this_object()),
                                           info,
                                           event,
                                           data);
            }
         }
      }
   }
   if (max_plan) {
      return npc->activate_plan(max_plan,
                                base_name(this_object()),
                                query_priority(npc, control) +
                                   max_plan->query_priority_offset(),
                                max_data);
   }
   return GOAL_EVENT_NOT_HANDLED;
}
mapping query_default_plans() {
   return _default_plans;
}
protected void add_default_plan(string event_name,
                                string plan) {
   if (!_default_plans[event_name]) {
      _default_plans[event_name] = ({ plan });
   } else if (member_array(plan, _default_plans[event_name]) == -1) {
      _default_plans[event_name] += ({ plan });
   }
}
void set_plan_data(object npc,
                   class goal_control control,
                   string plan,
                   mixed plan_data) {
   control->plan_info[plan] = plan_data;
}
mixed query_plan_data(object npc,
                      class goal_control control,
                      string plan) {
   return control->plan_info[plan];
}

==================================================
FILE: npc/goals/basic/stay_alive.c
==================================================

#include <goals.h>
inherit BASE_GOAL;
void create() {
   ::create();
   set_default_priority(GOAL_HIGH_PRIORITY);
   add_default_plan(EVENT_HP_LOST,
                    GOAL_PLAN_DIR + "basic/run_away");
   add_default_plan(EVENT_PLAN_FINISHED,
                    GOAL_PLAN_DIR + "basic/lose_attackers");
}

==================================================
FILE: npc/goals/basic/stay_alive_basic.c
==================================================

#include <npc/goals.h>
#include <npc/events.h>
#include <npc/plan.h>
inherit GOAL_BASE_INHERIT;
void setup() {
   set_default_priority(GOAL_HIGH_PRIORITY);
   add_default_plan(EVENT_LOSE_HPS,
                    PLAN_DIR + "basic/run_away");
}
int invarient(object npc) {
   return 1;
}
mixed initialise_plans(object npc,
                       string goal_name,
                       int wimpy) {
tell_creator("pinkfish", "Initialise_plans(%O, %O, %O)\n", npc, goal_name, wimpy);
   npc->set_goal_plan_data(goal_name,
                           PLAN_DIR + "basic/run_away",
                           wimpy);
   return wimpy;
}

==================================================
FILE: npc/goals/misc/get_drunk.c
==================================================

#include <npc/goals.h>
#include <npc/events.h>
#include <npc/plan.h>
inherit GOAL_BASE_INHERIT;
void setup() {
   set_default_priority(GOAL_LOW_PRIORITY);
   add_default_plan(EVENT_GIVEN_MONEY,
                    PLAN_DIR + "control/goto_location");
}
int invarient(object npc) {
   return 1;
}
mixed initialise_plans(object npc,
                       string goal_name,
                       int wimpy) {
tell_creator("pinkfish", "Initialise_plans(%O, %O, %O)\n", npc, goal_name, wimpy);
   npc->set_goal_plan_data(goal_name,
                           PLAN_DIR + "basic/run_away",
                           wimpy);
   return wimpy;
}

==================================================
FILE: npc/inherit/owned.c
==================================================

private mixed _owner;
object set_owner( mixed owner ){
  if( stringp(owner) )
    _owner = owner;
  if( objectp(owner) && living(owner) ){
    if( userp(owner) )
      _owner = owner->query_name();
    else
      _owner = owner;
  }
  return _owner;
}
object query_owner() {
  if( stringp(_owner) )
    return find_player(_owner);
  else
    return _owner;
}
object query_owner_pk_check() {
   return query_owner();
}
mixed *stats(){
  return ({
    ({ "owner", _owner }),
  });
}

==================================================
FILE: npc/plans/base.c
==================================================

#include <npc/plan.h>
private nosave int _sutability;
private nosave mapping _hooked_events;
void setup() {
}
void create() {
   _sutability = PLAN_INVALID_SUTABILITY;
   _hooked_events = ([ ]);
   setup();
}
int pre_condition(object npc,
		  string goal,
                  mixed goal_info,
		  string event,
		  mixed *data) {
   return 0;
}
int finished(object npc,
             mixed *data) {
   return 1;
}
int query_sutability(object npc,
		     string goal,
                     mixed goal_info,
		     string event,
		     mixed *data) {
   return _sutability;
}
void set_sutability(int sutability) {
   _sutability = sutability;
}
int query_data(object npc,
	       string goal,
               mixed goal_info,
	       string event,
	       mixed *data) {
   return 0;
}
mixed create_plan_data() {
   return 0;
}
void add_hooked_event(string event, function func) {
   _hooked_events[event] = func;
}
void remove_hooked_event(string event) {
   map_delete(_hooked_events, event);
}
int notify_event(object npc,
                 mixed plan_data,
                 string event,
                 mixed *data) {
   if (_hooked_events[event]) {
      return evaluate(_hooked_events[event], npc, plan_data, event, data);
   }
   return 0;
}

==================================================
FILE: npc/plans/basic/run_away.c
==================================================

#include <npc/plan.h>
#include <npc/events.h>
inherit PLAN_BASE_INHERIT;
int moved_event(object npc,
                mixed plan_data,
                string event,
                mixed *data);
void setup() {
   set_sutability(PLAN_MEDIUM_SUTABILITY);
   add_hooked_event(EVENT_MOVED, (: moved_event :));
}
protected int being_attacked(object npc) {
   object *attackers;
   attackers = filter(npc->query_attacker_list(), (: environment($1) ==
                                                 environment($2) :), npc);
   return sizeof(attackers);
}
void activate_plan(object npc,
                   mixed data) {
   npc->run_away();
}
int pre_condition(object npc,
                  string goal,
                  mixed plan_info,
                  string event,
                  mixed *data) {
   int wimpy_level;
   int percent;
tell_creator("pinkfish", "Precondition!\n");
   if (!plan_info) {
      wimpy_level = 50;
   } else {
      wimpy_level = plan_info;
   }
tell_creator("pinkfish", sprintf("%O: %O, %O\n", event, goal, plan_info));
   percent = (npc->query_hp() * 100) / npc->query_max_hp();
   if (percent < wimpy_level) {
      if (being_attacked(npc) ||
          event == EVENT_LOSE_HPS) {
         return 1;
      }
   }
   return 0;
}
int finished(object npc) {
   return !being_attacked(npc);
}
int moved_event(object npc,
                mixed plan_data,
                string event,
                mixed *data) {
   if (finished(npc)) {
      return 1;
   } else {
      npc->run_away();
   }
   return 0;
}

==================================================
FILE: hospital/alignment.c
==================================================

#define TOTAL_CHANCE 150
#define CENTRE 0
#define LIMIT_ONE     35
#define LIMIT_TWO     68
#define LIMIT_THREE   95
#define LIMIT_FOUR   115
#define LIMIT_FIVE   130
#define LIMIT_SIX    139
#define LIMIT_SEVEN  145
#define LIMIT_EIGHT  147
#define LIMIT_NINE   149
int pick_al( int average, int range ) {
   int choice, section, section_width, result;
   if( range < 0 ) {
      range = -range;
   }
   if( range < 10 ) {
      range = 10;
   }
   section_width = floor( range / 10 );
   choice = random( TOTAL_CHANCE );
   switch( choice ) {
      case CENTRE..LIMIT_ONE:
         section = 0;
         break;
      case ( LIMIT_ONE + 1 )..LIMIT_TWO:
         section = 1;
         break;
      case ( LIMIT_TWO + 1 )..LIMIT_THREE:
         section = 2;
         break;
      case ( LIMIT_THREE + 1 )..LIMIT_FOUR:
         section = 3;
         break;
      case ( LIMIT_FOUR + 1 )..LIMIT_FIVE:
         section = 4;
         break;
      case ( LIMIT_FIVE + 1 )..LIMIT_SIX:
         section = 5;
         break;
      case ( LIMIT_SIX + 1 )..LIMIT_SEVEN:
         section = 6;
         break;
      case ( LIMIT_SEVEN + 1 )..LIMIT_EIGHT:
         section = 7;
         break;
      case ( LIMIT_EIGHT + 1 )..LIMIT_NINE:
         section = 8;
         break;
      default:
         section = 9;
         break;
   }
   result = section * section_width;
   result = result + random( section_width );
   switch( random( 2 ) ) {
      case( 0 ):
         result = average + result;
         break;
      default:
         result = average - result;
         break;
   }
   result = result + average;
   return result;
}

==================================================
FILE: guilds/standard.c
==================================================

#include <skills.h>
#include <tune.h>
#include <guilds.h>
#include <config.h>
inherit "/std/object";
nosave string gp_skill;
nosave string start_pos;
nosave mixed *commands;
nosave string *skills;
nosave mixed *spells;
protected void create() {
   gp_skill = "other.points";
   start_pos = CONFIG_START_LOCATION;
   skills = ({ "crafts", "faith", "fighting", "other" });
   commands = ({ });
   spells = ({ });
   ::create();
}
string query_gp_skill() { return gp_skill; }
void set_gp_skill( string word ) { gp_skill = word; }
void set_gp( object thing ) {
   if ( !thing ) {
      return;
   }
   thing->set_max_gp( 50 + (int)thing->query_skill_bonus( gp_skill ) );
}
string query_start_pos( object thing ) { return start_pos; }
void set_start_pos( string word ) { start_pos = word; }
string *query_skills() { return skills; }
void set_skills( string *words ) { skills = words; }
int add_command(string name, int add_if_player) {
   if (member_array(name, commands) != -1) {
      return 0;
   }
   commands += ({ name, ({ add_if_player }) });
   return 1;
}
int remove_command(string name) {
   int i;
   if ((i = member_array(name, commands)) == -1) {
      return 0;
   }
   commands = delete(commands, i, 1);
   return 1;
}
int do_command(string name, mixed param) {
   log_file("BAD_COMMANDS", "do_command() called on /std/guilds/standard.c\n");
   return 0;
}
int add_spell(string name, mixed ob, string func_name, int add_if_player) {
   int i;
   if ((i = member_array(name, spells)) != -1) {
      return 0;
   }
   spells += ({ name, ({ ob, func_name, add_if_player }), });
   return 1;
}
int remove_spell(string name) {
   int i;
   if ((i= member_array(name, spells)) == -1) {
      return 0;
   }
   spells = delete(spells, i, 2);
   return 1;
}
int cast_spell(string name, mixed bing) {
   int i;
   if ((i=member_array(name, spells)) == -1) {
      return 0;
   }
   return (int)call_other(spells[i+1][0], spells[i+1][1], bing);
}
mixed *query_spells() { return spells; }
string *query_commands() { return commands; }
int query_skill_cost( string skill ) { return 10; }
int query_skill_max_level( string skill ) { return 10; }
void start_player(object pl) {
   int i;
   if (!spells) {
      spells = ({ });
   }
   for (i=0;i<sizeof(spells);i+=2) {
      if (spells[i+1][2] || !interactive(pl)) {
         pl->add_spell(spells[i], spells[i+1][0], spells[i+1][1]);
      }
   }
   if (!pointerp(commands)) {
      commands = ({ });
   }
   for (i=0;i<sizeof(commands);i+=2) {
      if (commands[i+1][0] || !interactive(pl)) {
         pl->add_known_command(commands[i]);
      }
   }
}
void leave_guild() { return; }
void player_quit() { return; }
void player_save() { return; }
void player_heart_beat( string guild, object thing ) {
}
void set_level( object thing, int level, string guild ) {
   call_out( "set_new_level", 1, ({ thing, level, guild }) );
}
string adjust_primaries( object thing, int level ) {
  int i;
  string stat_list;
  stat_list = "";
  for ( i = 0; i < sizeof( skills ); i++ ) {
    if(level - thing->query_skill(skills[i]) > 0)
      thing->add_skill_level(skills[i], level - thing->query_skill(skills[i]));
    stat_list += (string)SKILL_OB->query_skill_stat(skills[i]);
    if(random(2)) {
      stat_list += "C";
    }
  }
  return stat_list;
}
void set_new_level( mixed *args ) {
   int i, j, level;
   string stat_list;
   object thing;
   thing = args[ 0 ];
   if ( !thing ) {
      return;
   }
   level = args[ 1 ];
   thing->add_skill_level("fighting", level / 4 );
   thing->add_skill_level("other", level / 4 );
   switch(thing->query_guild_ob()) {
   case "/std/guilds/warrior":
   case "/std/guilds/assassin":
     thing->add_skill_level("other.health", level);
     break;
   case "/std/guilds/thief":
     thing->add_skill_level("other.health", (level * 3) / 4);
     break;
   default:
     thing->add_skill_level("other.health", level / 2);
   }
   thing->add_skill_level("other.perception", level / 3);
   stat_list = adjust_primaries( thing, level );
   if(thing->query_property( "unique" ) ||
      thing->query_property( "keep setup stats" ) ||
      (!thing->query_race_ob() ||
       !(thing->query_race_ob())->query_humanoid()))
     return;
   thing->adjust_con( -6 + random( 3 ) );
   thing->adjust_dex( -6 + random( 3 ) );
   thing->adjust_int( -6 + random( 3 ) );
   thing->adjust_str( -6 + random( 3 ) );
   thing->adjust_wis( -6 + random( 3 ) );
   for ( i = 0; i < 25; i++ ) {
      j = random( strlen( stat_list ) );
      switch ( stat_list[ j .. j ] ) {
         case "C" :
            thing->adjust_con( 1 );
            break;
         case "D" :
            thing->adjust_dex( 1 );
            break;
         case "I" :
            thing->adjust_int( 1 );
            break;
         case "S" :
            thing->adjust_str( 1 );
            break;
         default :
            thing->adjust_wis( 1 );
            break;
      }
   }
}
int query_level( object thing ) {
   int i, lvl;
   if ( !thing || !sizeof( skills ) ) {
      return 0;
   }
   for ( i = 0; i < sizeof( skills ); i++ ) {
      lvl += (int)thing->query_skill( skills[ i ] );
   }
   lvl /= sizeof( skills );
   return lvl;
}
string query_title( object player ) { return "the Adventurer"; }
void skills_advanced( object thing, string skill, int level ) {
   if ( strsrch( skill, "covert" ) != -1 ) {
      if ( ( (int)thing->query_skill( "covert.stealth" ) > 5 ) &&
             !thing->query_known_command( "peek" ) ) {
         tell_object( thing, "You realise that you could use your newly "
                      "improved stealth to \"peek\" covertly at someone, and "
                      "maybe they won't notice...\n" );
         thing->add_known_command( "peek" );
      }
   } else if ( strsrch( skill, "fighting.combat.parry.held" ) != -1 ) {
      if ( ( (int)thing->query_skill( "fighting.combat.parry.held" ) > 50 ) &&
                  !thing->query_known_command( "riposte" ) ) {
         tell_object( thing, "You realise that you could use your newly "
                     "improved parry to \"riposte\" someones attack.\n" );
         thing->add_known_command( "riposte" );
      }
   }
}
int add_position( string sub_guild, string position,
                           int max, string* abilities, mixed* description ) {
    return POSITION_FAIL;
}
int remove_position( string sub_guild, string position ) {
    return POSITION_FAIL;
}
mapping query_positions( string sub_guild, string position ) {
    return 0;
}
string *query_position_appointments( string sub_guild, string position ) {
    return 0;
}
mixed *query_position_description( string sub_guild, string position ) {
    return 0;
}
string *query_position_abilities( string sub_guild, string position ) {
    return 0;
}
void reset_positions( string sub_guild ) {
}
int appoint_position( string sub_guild, string position,
                                 string player_name ) {
    return POSITION_FAIL;
}
int dismiss_position( string sub_guild, string position,
                                 string player_name ) {
    return POSITION_FAIL;
}
string query_position( string sub_guild, string player_name ) {
    return 0;
}
int query_guild_ability( mixed thing, string ability ) {
    return 0;
}

==================================================
FILE: guilds/warrior.c
==================================================

#include <player_handler.h>
#include <top_ten_tables.h>
#include <playtesters.h>
#define SAVE_FILE ( "/save/guilds/warriors/warrior_ob" )
inherit "/std/guilds/standard";
void load_file();
void save_file();
void setup() {
  set_name("warriors");
  set_short("Warriors' Guild");
  set_long("The Warriors' Guild.\n\n"
           "The Warriors' Guild is for the brave and "
           "heroic.  As a member you can expect to "
           "recieve a sound background in beating, "
           "bashing, slicing, and dicing a variety of "
           "opponents up with a wide selection of "
           "weapons.  The evaluation of arms and armour "
           "will also be covered in detail.  Join this "
           "guild if you wish to journey to interesting "
           "places, meet interesting people, and give "
           "them a sound thrashing.\n");
  set_gp_skill("fighting.points");
  set_start_pos("/d/dist/pumpkin/squash/squash5");
  set_skills(({  "fighting.points",
                 "fighting.combat.melee.sharp",
                 "fighting.combat.melee.pierce",
                 "fighting.combat.melee.blunt",
                 "fighting.combat.melee.unarmed",
                 "fighting.combat.range.thrown",
                 "fighting.combat.range.fired",
                 "fighting.combat.parry.melee",
                 "fighting.combat.parry.range",
                 "fighting.combat.dodging.melee",
                 "fighting.combat.dodging.range",
                 "fighting.combat.special.weapon",
                 "fighting.combat.special.unarmed",
                 "other.evaluating.weapons",
                 "other.evaluating.armour"  }));
}
int query_skill_cost(string skill) {
  string *bits;
  if(member_array(skill, skills) != -1)
    return 3;
  bits = explode(skill, ".");
  switch(bits[0]) {
    case "faith" :
      return 15;
    case "fighting" :
      return 5;
    case "magic" :
      return 50;
    default :
      return 10;
  }
}
int query_skill_max_level( string skill ) {
  string *bits;
  if(member_array(skill, skills) != -1)
    return 300;
  bits = explode(skill, ".");
  switch (bits[0]) {
    case "faith" :
      return 25;
    case "fighting" :
      return 50;
    case "magic" :
      return 5;
    case "other" :
      return 25;
    default :
      return 10;
  }
}
string query_title( object player ) {
  int lvl, female;
  female = (int)player->query_gender() == 2;
  lvl = query_level( player );
  switch( lvl ) {
      case 0..15: return "the Novice Fighter";
      case 16..30: return "the Apprentice Fighter";
      case 31..45: return "the Skillful Fighter";
      default: return "the Grave of All Hope";
    }
}
int query_warrior( string player ) {
  if( PLAYER_HANDLER->test_guild( player ) == "/std/guilds/warrior" ) {
    return 1;
  }
  return 0;
}
int query_warrior_ob( object player ) {
  if( player->query_guild_ob() == "/std/guilds/warrior" ) {
    return 1;
  }
  return 0;
}

==================================================
FILE: languages/general.c
==================================================

string long() {
  return
"This is the normal language spoken by most creatures.\n";
}
mixed garble_tell(string start, string mess) {
  return ({ start, mess });
}
mixed garble_shout(string start, string mess) {
  return ({ start, mess });
}
mixed garble_say(string start, string mess) {
  return ({ start, mess });
}
string garble_text( mixed text, object thing, object player, string skill) {
   string bing;
   if (stringp(text)) {
      return text;
   }
   if ( pointerp( text ) ) {
      if ( ( bing = (string)text[ 0 ]->garble_text( text, thing, player ) ) ) {
         return bing;
      }
   }
   return "You cannot read the furry writing.\n";
}

==================================================
FILE: languages/grunt.c
==================================================

string long() {
  return "Consists of grunting noises.\n";
}
mixed garble_say(string start, string rest) {
  string nam, loud;
  sscanf(start, "%s %s:", nam, start);
  if (sscanf(start, "%s loudly", start) == 1)
    loud = " loudly";
  else
    loud = "";
  switch (start) {
    case "asks" :
       nam = nam+" quizzically grunts"+loud;
       break;
    case "exclaims" :
       nam = nam+" pointedly grunts"+loud;
       break;
    default :
       nam = nam+" grunts"+loud;
       break;
  }
  return ({ nam+".", "" });
}

==================================================
FILE: languages/language_inherit.c
==================================================

#include <fixed_random.h>
#include <tasks.h>
#include <living.h>
private string _long;
private string _name;
private string _start_text_bit;
void setup();
void create() {
  setup();
}
void set_long(string str) {
   _long = str;
}
string query_long() {
   return _long;
}
void set_name(string str) {
   _name = str;
}
string query_name() {
   return _name;
}
void setup() {
}
void set_start_text_bit(string str) {_start_text_bit = str; }
string do_garble(string word, string type) {
  string ret;
  int i;
  ret = "";
  for (i=0;i<strlen(word);i++)
    if (word[i] != ' ')
      ret += "*";
    else
      ret += " ";
  return ret;
}
void check_level_increase(object player, int difficulty, int level,
                          string skill, string mess) {
   int chance;
   if(query_verb() == "shout" || player->query_property("dead") ||
      player->query_property(PASSED_OUT) ||
      (userp(player) && !interactive(player)))
     return;
   if(player->query_current_language() !=
      lower_case(this_object()->query_name()))
     return;
   if (player->query_property("last message:" + skill) == mess ||
       player->query_property("dead")) {
      return ;
   }
   if(player->query_specific_gp("other") < difficulty) {
     return;
   } else {
     player->adjust_gp(-(difficulty*2));
   }
   player->add_property("last message:" + skill, mess, 360);
   if (difficulty <= level && level < 100) {
        chance = 800 + ((level - 40) * (level - 40)) / 20;
      chance -= level - difficulty;
      if (random(1000) > chance) {
        if(player->add_skill_level(skill, 1)) {
          tell_object(player, "%^YELLOW%^You feel like the " +
                      capitalize(_name) +
                      " language is less confusing.%^RESET%^\n");
        }
      }
   }
}
string garble_message(string mess, object player, object speaker,
                      string type, string skill, int no_increase) {
  int i, level, num;
  int max_difficulty, diff, difference;
  string *bits;
  int something_garbled;
  level = player->query_skill(skill);
  if (level > 100) {
    player->add_skill_level(skill, 100 - level, 1);
  }
  num = speaker->query_skill(skill);
  if (num > 100) {
    speaker->add_skill_level(skill, 100 - num, 1);
  }
  difference = speaker->query_skill(skill) - player->query_skill(skill);
  if (num < level)
    level = num;
  if (level >= 100) {
    return mess;
  }
  if (level == 0) {
    max_difficulty = 0;
  } else {
    max_difficulty = 1000;
  }
  RANDOM_OBJ->set_seed(crc32(mess));
  bits = explode(mess, " ");
  for (i=0;i<sizeof(bits);i++) {
    if (strlen(mess)) {
      if (level > 0) {
         num = (int)RANDOM_OBJ->random(100);
         if (strlen(mess) < 8) {
           diff = (level*100) / (strlen(mess)*10);
           if (num >= (level*100 / strlen(mess)*10)) {
             if (max_difficulty > diff)
               max_difficulty = diff;
             if (interactive(player)) {
               bits[i] = do_garble(bits[i], type);
               something_garbled = 1;
             } else {
               bits[i] = "";
             }
           }
         } else {
           diff = (level*100) / 90;
           if (num >= diff) {
             max_difficulty = level*100 / 100;
             if (interactive(player)) {
               bits[i] = do_garble(bits[i], type);
               something_garbled = 1;
             } else {
               bits[i] = "";
             }
           }
         }
      } else {
         if (interactive(player)) {
           bits[i] = do_garble(bits[i], type);
           something_garbled = 1;
         } else {
           bits[i] = "";
         }
      }
    }
  }
  if (something_garbled && (difference > -10) && !no_increase) {
    check_level_increase(player, max_difficulty, level, skill, mess);
  }
  return implode(bits, " ");
}
mixed garble_say(string start, string mess, object player,
                 object from, string type, string skill, int no_increase) {
  return ({ start, garble_message(mess, player, from, "speech", skill,
                                  no_increase) });
}
string garble_text( mixed text, object thing, object player, string skill) {
  string bing;
  if (stringp(text)) {
    if (player->query_default_language() != query_name()) {
      return _start_text_bit +
        garble_message(text, player, player, "text", skill, 0);
    } else {
      return garble_message(text, player, player, "text", skill, 0);
    }
  }
  if ( pointerp( text ) ) {
    if ( ( bing = (string)text[ 0 ]->garble_text( text, thing, player ) ) ) {
      if (player->query_default_language() != query_name()) {
        return _start_text_bit + bing;
      } else {
        return bing;
      }
    }
  }
  return "You cannot read the spidery writing.\n";
}
void dest_me() {
  destruct(this_object());
}

==================================================
FILE: languages/rabbit.c
==================================================

#include <language.h>
inherit LANGUAGE_INHERIT;
void setup() {
   set_long( "This is the local language of Rabbit.\n" );
   set_name( "Rabbitian" );
   set_start_text_bit( "Some carefully constructed characters "
                       "that might mean:\n" );
}
mixed do_garble_text( string text ) {
    return ({ "whats", "up", "doc", "carrot" })[random(4)];
}
string do_garble( string text, string text_type )  {
    return ({ "whats", "up", "doc", "carrot" })[random(4)];
}

==================================================
FILE: languages/wommon.c
==================================================

string long() {
  return
"International womens day language.\n";
}
string filter_string(string str) {
  return replace(" "+str,
      ({ " he ", " they ",
         " He ", " They ",
         " HE ", " THEY ",
         " his ", " theirs ",
         " His ", " Theirs ",
         " HIs ", " THEIrs ",
         " HIS ", " THEIRS ",
         " him ", " them ",
         " Him ", " Them ",
         " HIm ", " THem ",
         " HIM ", " THEM ",
         "man", "person",
         "Man", "Person",
         "MAn", "PERson",
         "MAN", "PERSON", }))[1..10000];
}
mixed garble_tell(string start, string mess) {
  return ({ start, filter_string(mess) });
}
mixed garble_shout(string start, string mess) {
  return ({ start, filter_string(mess) });
}
mixed garble_say(string start, string mess) {
  return ({ start, filter_string(mess) });
}
mixed garble_text(string str, object ob) {
  return filter_string(str);
}

==================================================
FILE: dom/base_master.c
==================================================

#include <project_management.h>
#include <player_handler.h>
#include <error_handler.h>
#define LOCK_MASK 8
#define PROJECT_CODE "$project$"
mapping members;
mapping access;
nosave private mapping _project_cache;
private int _use_tracker;
private string _idle_mess;
string *deputies;
private mapping _directory_assignments;
private mapping _rcsforce_allowed;
string query_lord();
int query_use_tracker();
void set_use_tracker(int);
string query_domain() {
  string *words;
  if (!file_name (this_object())) {
    return "";
  }
  words =  explode (file_name(this_object()), "/");
  if (sizeof (words) < 2) {
    return "";
  }
  return words[1];
}
int query_prevent_shadow() {
   return 1;
}
protected void create() {
   members = ([ ]);
   access = ([ ]);
   deputies = ({ });
   _project_cache = ([ ]);
   _rcsforce_allowed = ([ ]);
   _idle_mess = 0;
   unguarded((: restore_object, file_name(this_object()) :));
   if (!deputies) {
      deputies = ({ });
   }
   if (!_directory_assignments) {
      _directory_assignments = ([ ]);
   }
   if ( !_rcsforce_allowed ) {
       _rcsforce_allowed = ([ ]);
   }
}
void save_me() {
   unguarded((: save_object, file_name(this_object()) :));
}
int add_permission(string euid,
                   string path,
                   int mask)
{
   if (previous_object() != master()) {
      return 0;
   }
   if (!access[path]){
      access[path] = ([ euid : mask ]);
   } else {
      access[path][euid] |= mask;
   }
   save_me();
   return 1;
}
int remove_permission(string euid,
                      string path,
                      int mask)
{
   if (previous_object() != master())
      return 0;
   if (!access[path])
      return 0;
   if (!access[path][euid])
      return 0;
   access[path][euid] &= ~mask;
   if (!access[path][euid])
      map_delete(access[path], euid);
   if (!sizeof(access[path]))
      map_delete(access, path);
   save_me();
   return 1;
}
int check_permission(string euid,
                     string *path,
                     int mask)
{
   string p;
   mapping perms;
   if ((sizeof(path) >= 3)
       && (path[2] == "master.c" || path[2] == "master.o"
           || path[2] == "master"))
      return 0;
   p = "/" + implode(path, "/");
   perms = master()->permission_match_path(access, p);
   if (!perms || !sizeof(perms)) {
      return 0;
   }
   if (perms[euid] && ((perms[euid] & mask) || (perms["all"] & mask))) {
      return 1;
   }
   if (perms["all"] & LOCK_MASK) {
      return -1;
   }
   return 0;
}
int valid_read(string,
               string euid,
               string)
{
   return 1;
   return (members[euid] != 0);
}
int valid_write(string *path,
                string euid,
                string)
{
   return 0;
   if ((sizeof(path) >= 3)
       && (path[2] == "master.c" || path[2] == "master.o"
           || path[2] == "master"))
      return 0;
   return (members[euid] != 0);
}
void dest_me()
{
   destruct(this_object());
}
int check_call_tree(int only_lord)
{
   object *obs;
   int found;
   int i;
   obs = previous_object(-1);
   for (i = 0; i < sizeof(obs); i++) {
     if (file_name(obs[i])[0..12] == "/global/lord#" ||
         (file_name(obs[i])[0..15] == "/global/creator#")) {
       if("/secure/master"->query_administrator(obs[i]->query_name()) ||
          obs[i]->query_name() == query_lord() ||
          (!only_lord &&
           (member_array(obs[i]->query_name(), deputies) != -1))) {
         found = 1;
       } else {
         return 0;
       }
     }
   }
   return found;
}
int add_member(string name)
{
   if (!check_call_tree(0)) {
      return 0;
   }
   if (members[name])
      return 0;
   members[name] = "newbie";
   save_me();
   return 1;
}
int remove_member(string name)
{
   int pos;
   if (!check_call_tree(member_array(name, deputies) != -1)) {
      return 0;
   }
   if (!members[name])
      return 0;
   members = m_delete(members, name);
   pos = member_array(name, deputies);
   if (pos != -1) {
      deputies = deputies[0..pos - 1] + deputies[pos + 1..];
   }
   save_me();
   return 1;
}
int add_deputy(string name)
{
   if (!check_call_tree(1)) {
      return 0;
   }
   if (!members[name])
      return 0;
   if (!deputies)
      deputies = ({ });
   if (member_array(name, deputies) != -1)
      return 1;
   deputies += ({ name });
   save_me();
   return 1;
}
int remove_deputy(string name)
{
   int pos;
   if (!check_call_tree(1)) {
      return 0;
   }
   if (!deputies)
      deputies = ({ });
   pos = member_array(name, deputies);
   if (pos == -1)
      return 0;
   deputies = deputies[0..pos - 1] + deputies[pos + 1..];
   save_me();
   return 1;
}
int add_rcsforce_allowed( string creator, string directory ) {
    if (!check_call_tree(1)) {
      return 0;
   }
   if ( _rcsforce_allowed[ creator ] ) {
        _rcsforce_allowed[ creator ] += ({ directory });
   }
   else {
        _rcsforce_allowed[ creator ] = ({ directory });
   }
   save_me();
   return 1;
}
int remove_rcsforce_allowed( string creator, string directory ) {
    if (!check_call_tree(1)) {
      return 0;
   }
   if ( _rcsforce_allowed[ creator ] ) {
        _rcsforce_allowed[ creator ] -= ({ directory });
        if ( sizeof( _rcsforce_allowed ) == 0 ) {
            map_delete( _rcsforce_allowed, creator );
        }
        save_me();
   }
   return 1;
}
string *query_members()
{
   return keys(members);
}
int set_project(string name,
                string pro)
{
   if (!check_call_tree(0)) {
      return 0;
   }
   if (!members[name])
      return 0;
   if (!pro || pro == "")
      pro = "project unset";
   members[name] = pro;
   save_me();
   return 1;
}
string query_project(string name)
{
  string *proj;
  string project;
  project = members[name];
  if (!project) {
    return "project unset";
  }
  if (strsrch (project, PROJECT_CODE) != -1) {
    if (!sizeof (_project_cache)) {
      _project_cache = ([ ]);
    }
   if (undefinedp (_project_cache[name])) {
      proj = PROJECT_HANDLER->query_projects_for_creator_in_domain
        (name, query_domain());
      if (sizeof (proj)) {
        _project_cache[name] = query_multiple_short (proj);
      }
      else {
        _project_cache[name] = members[name];
      }
    }
    return replace (project, ({PROJECT_CODE,
      _project_cache[name]}));
  }
  else {
    return members[name];
  }
}
int query_deputy(string name)
{
   if (!deputies)
      return 0;
   if (member_array(name, deputies) != -1)
      return 1;
   return 0;
}
string *query_deputies()
{
   return copy(deputies);
}
mapping query_access()
{
   return copy(access);
}
string query_lord()
{
   return "Something is broken";
}
int can_rcsforce(string file, string person, string locker) {
    string *directories;
    string fdir;
    if (query_deputy(person)) {
        return 1;
    }
    directories = _rcsforce_allowed[ person ];
    if ( directories ) {
        fdir = file[ 0..strsrch( file, "/", -1 ) -1 ];
        foreach ( string directory in directories ) {
            if ( fdir[ 0.. sizeof( directory ) - 1 ] == directory ) {
                return 1;
            }
        }
    }
    return 0;
}
string query_changelog (string filename) {
  return  "/d/" + query_domain() + "/ChangeLog";
}
void set_use_tracker(int i) {
  _use_tracker = i;
}
int query_use_tracker() {
  return _use_tracker;
}
int nuke_creator_project_cache(string *creators) {
  if (!_project_cache) {
    return 0;
  }
  foreach (string c in creators) {
    map_delete (_project_cache, c);
    return 1;
  }
}
int set_idle_mess( string txt ) {
   if (!check_call_tree(1)) {
        return 0;
   }
   _idle_mess = txt;
   save_me();
   return 1;
}
string query_idle_mess() {
    return _idle_mess;
}
string* query_assigned_to_directory(string* dir) {
   string str;
   int i;
   i = sizeof(dir) - 1;
   do {
      str = "/" + implode(dir[0..<i], "/");
      i--;
   } while (i >= 0 && !_directory_assignments[str]);
   if (_directory_assignments[str]) {
      return _directory_assignments[str];
   }
   return ({ query_lord() });
}
int assign_people_to_directory(string dir, string* people) {
   if (previous_object() != master()) {
      return 0;
   }
   if (sizeof(people)) {
      if (sizeof(people) == 1 && people[0] == ERROR_ASSIGNED_NO_ONE) {
         people = ({ });
      }
      _directory_assignments[dir] = people;
   } else {
      map_delete(_directory_assignments, dir);
   }
   save_me();
   return 1;
}
mapping query_directory_assignments() {
   mapping ret;
   string dir;
   ret = copy(_directory_assignments);
   dir = "/d/" + query_domain();
   if (!ret[dir]) {
      ret[dir] = ({ query_lord() });
   } else {
      ret[dir] |= ({ query_lord() });
   }
   return ret;
}

==================================================
FILE: dom/cmn_mas.c
==================================================

inherit "/std/room/basic_room";
private nosave string _dom_name;
string query_dom() { return _dom_name; }
void set_dom(string str) { _dom_name = str; }
int do_list(string);
int add_creator(string);
int delete_creator(string);
int set_project(string, string);
void create() {
  do_setup++;
  ::create();
  do_setup--;
  add_property ("no scry", 1);
  add_property ("no teleport", 1);
  add_help_file ("/doc/creator/room/commonroom");
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void init() {
  ::init();
  add_command("list", "<word'domain'>", (:do_list($4[0]):));
  add_command("list", "", (:do_list(0):));
  add_command("add", "<word'creator'>", (:add_creator($4[0]):));
  add_command("delete", "<word'creator'>" ,(:delete_creator($4[0]):));
  add_command("project", "<word'name'> <string'project'>",
    (:set_project($4[0], $4[1]):));
}
int do_list(string arg) {
  string *domains, mast, s = "";
  string *members;
  int i, j;
  if(arg == "all")
    domains = get_dir("/d/");
  else if(!arg)
    domains = ({ _dom_name });
  else {
    domains = ({ arg });
  }
  if(sizeof(domains) > 1) {
    write("All domains:\n");
  }
  else {
    write("This domain:\n");
  }
  for(i=0; i<sizeof(domains); i++) {
    mast = "/d/" + domains[i] + "/master";
    if (!load_object (mast)) {
      continue;
    }
    members = mast->query_members();
    if(!members) {
      members = ({ });
    }
    s += sprintf("%s has %s members and is owned by %s.\n", capitalize (domains[i]),
      query_num (sizeof(members)), capitalize((string)mast->query_lord()));
    for(j=0; j<sizeof(members); j++)
      s +=sprintf("* %s's project: %-=*s\n", capitalize(members[j]),
                       this_player()->query_cols()-12-strlen(members[j]),
                       mast->query_project(members[j]));
      s += "\n\n";
  }
  this_player()->set_finish_func(0);
  this_player()->more_string(s);
  return 1;
}
int add_creator(string arg) {
  string mast;
  arg = (string)this_player()->expand_nickname(arg);
  mast = "/d/" + _dom_name + "/master";
  if((string)mast->query_lord() != geteuid(this_player())) {
    this_player()->add_failed_mess(this_object(), "You are not the Lord of "
      "this Domain.\n", ({ }));
    return 0;
  }
  if(!mast->add_member(arg)) {
    this_player()->add_failed_mess(this_object(), sprintf ("%s is already a "
      "member of %s.\n", capitalize (arg), capitalize (query_dom())),
      ({ }));
    return 0;
  }
  write("Creator " + capitalize(arg) + " now added to " + _dom_name + ".\n");
  return 1;
}
int delete_creator(string arg) {
  string mast;
  arg = (string)this_player()->expand_nickname(arg);
  mast = "d/" + _dom_name + "/master";
  if((string)mast->query_lord() != geteuid(this_player())) {
    this_player()->add_failed_mess(this_object(), "You are not the Lord of "
      "this Domain.\n", ({ }));
    return 0;
  }
  if (!mast->remove_member(arg)) {
    this_player()->add_failed_mess(this_object(), sprintf ("%s is not a "
      "member of %s.\n", capitalize (arg), capitalize (query_dom())),
      ({ }));
    return 0;
  }
  write("Member " + capitalize(arg) + " removed from " + _dom_name + ".\n");
  return 1;
}
int set_project(string arg, string project)
{
  string mast;
  mast = "d/" + _dom_name + "/master";
  if((string)mast->query_lord() != geteuid(this_player())) {
    this_player()->add_failed_mess(this_object(), "You are not the Lord of "
      "this Domain.\n", ({ }));
    return 0;
  }
  arg = (string)this_player()->expand_nickname(arg);
  if(!mast->set_project(arg, project)) {
    this_player()->add_failed_mess(this_object(), sprintf ("%s is not a "
      "member of %s.\n", capitalize (arg), capitalize (query_dom())),
      ({ }));
    return 0;
  }
  write(capitalize(arg) + "'s project set to : " + project + ".\n");
  return 1;
}

==================================================
FILE: dom/common.c
==================================================

#include <config.h>
inherit "/std/dom/cmn_mas";
object board;
void setup() {
  set_dom(DOMAIN);
  set_light(100);
  add_exit("drum", CONFIG_START_LOCATION, "door");
  set_short("Common room of "+DOM_TITLE);
  set_long("Large relaxing chairs addorn the room.  The walls are covered "+
           "with strange motifs from different lands and the little shelf "+
           "above the fireplace is chocker block full of strange figurines "+
           "and bits of cloth.  It appears to be the common room of "+
           DOM_TITLE+" the large red letters on the wall were the " +
           "give away.\n");
  add_alias("chairs", "chair");
  add_alias("cloths", "cloth");
  add_alias("motifs", "motif");
  add_alias("figurines", "figurine");
  add_item("chair", "The chairs are lazing around the room relaxing it looks "+
                    "like they come here after a hard days working in "+
                    DOM_TITLE+".\n");
  add_item("fireplace", "A nice little fire place with a cheery fire burning "+
                        "in it keeping every one warm.\n");
  add_item("figurine", "Small figurines, they look strangely familiar "+
                         "until you realise they are the members of "+
                         DOM_TITLE+".\n");
  add_item("cloth", "Strange coloured bits of cloth strewn over the "+
                    "mantlepice for no readily apparent reason.\n");
  add_item("motif", "The motifs on close inspection look like stylised "+
                     "signatures of all the members of "+DOM_TITLE+
                     ".  Some of them are very strange, in fact there "+
                     "seem to be more than there are members of the house.  "+
                     "perhaps it is the members of the future.\n");
  add_item("shelf", "A nice normal sort of shelf thing.  It is like all "+
                    "those ones you see in houses all over the place, "+
                    "execpt... the way it has been burnt... hmm it does "+
                    "not look like the fire did it.\n");
  add_item("fire", "There is a fire happily burning away in the fireplace "+
                   "spluttering and crackling to itself.  The flames almost "+
                   "seem afraid of something.  Looking closer you notice a "+
                   "picture tacked to the side of the fire place.\n");
  add_item("picture", "Tacked to the inside wall of the fire thingy, you "+
                      "know the hole bit at the bottom, is a small picture "+
                      "it looks like it was taken with the best of demon "+
                      "photography.  It is a picture of a person holding "+
                      "a small staff, you think it might be "+LORD+
                      " but you are not sure as the fire light sparkles "+
                      "in your eyes.\n");
  board = clone_object("/obj/misc/board");
  board->set_datafile(DOMAIN);
  board->move(this_object());
}
void dest_me()
{
  if(board) board->dest_me();
  ::dest_me();
}

==================================================
FILE: dom/error_tracker.c
==================================================

inherit "/std/dom/error_tracker_master";
void create()
{
  set_domain("klatch");
  set_name("klatchian error tracker");
  set_other_dirs(({ }));
  set_period(604800);
  ::create();
}

==================================================
FILE: dom/error_tracker_master.c
==================================================

#include <board.h>
#include <db.h>
#include <config.h>
#include <project_management.h>
#define HELPER "/obj/handlers/finderror_helper"
inherit "/global/path";
private void finished_count_errors( object player, int status, mixed data );
private string domain = "unset";
private string _board;
private string tracker_name = "generic error tracker";
private string *other_dirs = ({ });
private int period = 604800;
private int nexttime;
private nosave mapping _messages;
private nosave string *_queue;
private nosave object _tester;
private nosave string _save_file;
private nosave int starttime;
#define ERROR_INDEX 0
#define TYPO_INDEX 1
#define IDEA_INDEX 2
#undef OLD_SYTEM
void do_the_work();
protected void save_me()
{
   if (domain != "unset" && _save_file) {
      unguarded( (: save_object, _save_file, 0 :) );
   }
}
void create()
{
   int retval;
   _messages = ([ ]);
   _tester = 0;
   seteuid(master()->creator_file(file_name()));
   _save_file = file_name();
   if (catch(retval = unguarded((: restore_object, _save_file, 1 :))) ||
         !retval) {
      string temp;
      temp = "/save/" + replace(file_name()[1..], "/", "_");
      if (catch(retval = unguarded((: restore_object, temp, 1 :))) ||
            !retval) {
         if (catch(save_me())) {
            _save_file = temp;
         }
      } else {
         _save_file = temp;
      }
   }
   if (!retval) {
      nexttime = 0;
   }
   if (nexttime < time()) {
      do_the_work();
   } else {
      call_out("do_the_work", nexttime - time());
   }
}
void set_board(string board) {
   _board = board;
}
string query_board() {
   return _board;
}
void dest_me()
{
   save_me();
   destruct(this_object());
}
nomask mixed dwep()
{
   destruct(this_object());
   return "Destructed With Extreme Prejudice";
}
protected varargs int post( string message, string title )
{
   string temp;
   if( undefinedp( title ) ) {
      temp = "Status summary for "+ capitalize( domain ) + ".";
   } else {
      temp = title;
   }
   if (_tester) {
      _tester->more_string(message);
      _tester = 0;
      return 0;
   }
   if (_board) {
      return BOARD_HAND->add_message(_board,
         capitalize(tracker_name), temp ,
         message);
   } else {
      return BOARD_HAND->add_message(domain,
         capitalize(tracker_name), temp ,
         message);
   }
}
string * query_classifications() {
    return ({ "live", "playtesting", "development" });
}
string query_post_message() {
   string message;
   int diff;
   if (!sizeof(_messages)) {
      message = "Congratulations!   There are no errors in all of " +
         capitalize(domain) + "!   Excellent work, everyone.\n";
   }
   else {
       message = "";
         foreach( string key in query_classifications() ) {
            if ( _messages[ key ] ) {
                message += "There are reports in the following " + key +
                    " areas:\n\n" + _messages[ key ] + "\n";
            }
            else {
                if ( key == "live" ) {
                    message += "\n\nThere are no live bugs in all of " +
                        capitalize(domain) + ".   Good work, everyone!\n";
                }
                else {
                    message += "\n\nThere are no outstanding " + key + " bugs.\n";
                }
            }
        }
   }
   diff = (real_time() - starttime);
   message += "\n\nThis message took " + diff +
     " second" + (diff != 1 ? "s" : "") + " to produce.\n";
   return message;
}
string query_project_message() {
   string str;
   class project* projects, *my_projects;
   class project project;
   mapping status;
   str = "\nCurrent Domain Projects:\n\n";
   projects = PROJECT_HANDLER->filter_by_query(([ "domains" : domain ]));
   if (sizeof(projects)) {
        status = unique_mapping( projects, (: STATUS[((class project)$1)->status] :) );
        map_delete( status, "play" );
        if ( !sizeof(status) ){
            str += "This domain is project free.\n";
        }
        foreach( string key in sort_array( keys( status ), 1 ) ) {
            str += "Projects classified as " +
                upper_case(key) + ":\n";
            my_projects = sort_array(status[key],
                (: strcmp(((class project)$1)->name,
                ((class project)$2)->name) :) );
            foreach (project in my_projects) {
                str += "    * " + project->name + " - " +
                    query_multiple_short(sort_array(map(project->creators,
                    (: capitalize :) ), 1)) + "\n";
            }
            str += "\n";
        }
   }
   else {
      str += "This domain is project free.\n";
   }
   return str;
}
protected void iterate()
{
#ifdef OLD
   string message;
   if (sizeof(_queue)) {
      string dir = _queue[0];
      if (sizeof(_queue) > 1) {
         _queue = _queue[1..];
      } else {
         _queue = ({ });
      }
      if (strsrch (dir, "_dev") != -1) {
         dodir(dir, (: _dev_msg += ({ $1 }), iterate() :));
      } else if (strsrch (dir, "_pt") != -1) {
         dodir(dir, (: _pt_msg += ({ $1 }), iterate() :));
      } else {
         dodir(dir, (: _messages += ({ $1 }), iterate() :));
      }
   } else {
      message = query_project_message() + "\n";
      message += query_post_message();
      post(message);
      _messages = ({ });
      if( function_exists( "domain_customisation" , this_object() ) ) {
            call_out( "domain_customisation" , 1 );
      }
   }
#endif
    HELPER->query_errors_in_dirs(_queue, (: finished_count_errors :) );
}
void initialise_variables() {
   _queue = ({ "/d/" + domain + "%" }) + other_dirs;
   _messages = ([ ]);
}
void do_the_work()
{
   if (domain == "unset") return;
   nexttime = time() + period;
   remove_call_out("do_the_work");
   call_out("do_the_work", period);
   save_me();
   starttime = real_time();
   initialise_variables();
   iterate();
}
varargs void test()
{
   _tester = this_player();
   starttime = real_time();
   initialise_variables();
   iterate();
}
void set_name(string name)
{
   tracker_name = name;
   save_me();
}
void set_domain(string name)
{
   domain = name;
   save_me();
}
string query_domain() {
   return domain;
}
void set_period(int length)
{
   remove_call_out("do_the_work");
   nexttime -= period;
   period = length;
   nexttime += period;
   save_me();
}
void set_other_dirs(string *others)
{
   if (arrayp(others)) {
      other_dirs = others;
   } else {
      other_dirs = ({ });
   }
   save_me();
}
mixed stats()
{
   return ({
      ({ "domain", domain }),
      ({ "name", tracker_name }),
      ({ "period", period }),
      ({ "next time", ctime(nexttime) }),
      ({ "testing by", _tester }),
      ({ "queue length", sizeof(_queue) }),
      ({ "message length", sizeof(_messages) }),
      ({ "other dirs", sizeof(other_dirs) ? implode(other_dirs, ", ") : 0 }),
      ({ "save file", _save_file }),
   });
}
protected string classify_directory(string path) {
    if ( strsrch( path, "_pt" ) > -1 ) {
        return "playtesting";
    }
    if ( strsrch( path, "_dev" ) > -1 ) {
        return "development";
    }
    return "live";
}
private int sort_errors( mapping mdata, string key1, string key2 ) {
    int total1, total2;
    total1 = mdata[key1][0] + mdata[key1][1] + mdata[key1][2];
    total2 = mdata[key2][0] + mdata[key2][1] + mdata[key2][2];
    if ( total1 > total2 )  {
        return -1;
    } else {
        if ( total1 == total2 ) {
            return 0;
        } else {
            return 1;
        }
    }
}
private void finished_count_errors( object player, int status, mixed data ) {
    int *count;
    string *paths;
    mapping errors = ([ ]);
    mapping total = ([ ]);
    string txt;
    string classification;
    mapping mdata;
    string message;
    foreach( mapping direc in data ) {
        classification = classify_directory( direc[ "Directory" ] );
        if ( !errors[ classification ] ) {
            errors[ classification ] = ([ ]);
        }
        if ( !total[ classification ] ) {
            total[ classification ] = ({ 0, 0, 0 });
        }
        count = errors[ classification ][ direc[ "Directory" ] ];
        if ( undefinedp( count ) ) {
            count = ({ 0, 0, 0 });
        }
        switch( direc[ "Type" ] ) {
            case "BUG":
                count[ 0 ] = direc[ "C" ];
                total[ classification ][ 0 ] += count[ 0 ];
            break;
            case "TYPO":
                count[ 1 ] = direc[ "C" ];
                total[ classification ][ 1 ] += count[ 1 ];
            break;
            case "IDEA":
            default:
                count[ 2 ] = direc[ "C" ];
                total[ classification ][ 2 ] += count[ 2 ];
        }
        errors[ classification ][ direc[ "Directory" ] ] = count;
    }
    foreach ( classification, mdata in errors ) {
        paths = sort_array( keys( mdata ), (: sort_errors( $(mdata), $1, $2 ) :) );
        txt = "BUGS TYPO IDEA [Assigned] Dir\n";
        foreach( string key in paths ) {
            string* assigned;
            assigned = master()->query_assigned_to_directory(key);
            if (!sizeof(assigned)) {
               assigned = ({ "No one" });
            }
            txt += sprintf( "%4d %4d %4d %-11s %s\n",
                mdata[ key ][ 0 ],
                mdata[ key ][ 1 ],
                mdata[ key ][ 2 ],
                query_multiple_short(assigned),
                key );
        }
        txt += "-------------\n";
        txt += sprintf( "%4d %4d %4d\n",
            total[ classification ][ 0 ], total[ classification ][ 1 ],
            total[ classification ][ 2 ] );
        _messages[ classification ] = txt;
    }
  message = query_project_message() + "\n";
  message += query_post_message();
  if (function_exists("extend_error_message", this_object())) {
      message += this_object()->extend_error_message( copy( errors ) );
  }
  post(message);
  _messages = ([ ]);
  if( function_exists( "domain_customisation" , this_object() ) ) {
        call_out( "domain_customisation" , 1 );
  }
}

==================================================
FILE: dom/interview_inherit.c
==================================================

#include <player_handler.h>
#include <mail.h>
#define LORD capitalize (load_object ("/d/" + query_domain() + "/master")->query_lord())
#define SECURE "/d/" + query_domain() + "/secure/"
#define SAVE query_interview_dir() + "candidate_list"
#define LOG query_interview_dir() + "candidate_log.txt"
#define EVENTS "/global/events"
#define DEBUG 1
inherit "/std/room";
int add_creator (string);
int do_add (string);
int do_confirm (string);
int do_flag (string, string);
varargs int do_interview (object, string);
int do_query_text(string);
int do_list();
int do_read (string);
int flush();
int query_allowed_creators();
int query_interview();
int remove_candidate (string);
int remove_creator (string);
int remove_interviewed (string);
int set_interview_dir (string);
int set_part_two (string);
int query_part_two_required();
void set_acceptance(string);
void set_confirmation(string);
void set_rejection(string);
void set_interview (int);
void set_subject (string);
void set_interviewer(mixed);
void set_cc (string*);
string query_acceptance();
string query_applicants_text();
string query_cc();
string query_confirmation();
string query_domain();
string query_interview_dir();
string query_part_two();
string query_rejection();
string query_subject();
private nosave int _interview;
private nosave int _pt_two = 1;
private nosave string _acceptance_text;
private nosave string _confirmation_text;
private nosave string _domain;
private nosave string _filename;
private nosave string _interview_dir;
private nosave string _rejection_text;
private nosave string _subject;
private nosave string *_int;
private string *_allowed_creators = ({ });
private string *candidates = ({ });
private string *_cc = ({ });
private string *interviewed = ({ });
private string *submitted = ({ });
private string *accepted = ({ });
private string *rejected = ({ });
nosave string *movie = ({
  "First of all, I'd like to congratulate you for getting this far with the "
  "application process.  The second part of the application, in addition to "
  "testing descriptive and coding skills, is also designed to help weed out "
  "those who aren't really serious about becoming creators.  :-)",
  "I should make it clear at this point that getting this far doesn't mean "
  "that you're guaranteed a promotion.  We just want to get a fuller "
  "appreciation of applicants before we reach a decision on whether you are "
  "to be promoted or not.  :-)",
  "Being a creator, regardless of the rumours or jokes to the contrary, is "
  "not an easy option.  Unlike many MUDs, being a creator on " + mud_name() + " is "
  "not the same as early retirement.  You'll be expected to spend time "
  "coming to terms with the mudlib (the body of code that is used to "
  "create the MUD) and your domain (the areas you actually adventure "
  "in).  As a creator, you have considerable power over large segments of "
  "the MUD.  The important thing is learning how to use that power "
  "responsibly.",
  "We have a number of strict rules on " + mud_name() + " .. rules you should be "
  "aware of before you make any decisions as to whether the role is for "
  "you.  Creators aren't allowed to affect the game in any measurable "
  "way.  Chatting is fine... killing NPCs at random or indiscriminately "
  "cloning cash for players is not.",
  "Being a creator is also not about policing the " + mud_name() + "   That falls "
  "under the jurisdiction of Admin and the Liaison domain.  As a coding "
  "creator your responsibilities lie in dealing with the code that "
  "makes up the MUD.  It is quite common that you will be approached by "
  "players with questions, particularly when they are no liaisons "
  "online.  In cases such as this, you are expected to refer them to "
  "a liaison or a Director.  If none are online, you are expected to ask "
  "them to wait until one is.",
  "In rare cases, it will be necessary for immediate action to be "
  "taken... in such cases, it may be acceptable for you to deal with a "
  "player problem yourself.  Always keep in mind however that you are "
  "here to code.  If it is liaising and player interaction that you think "
  "you would enjoy most, it would be best to consider an application "
  "instead to the Liaison domain.",
  "There is also a stern security policy on " + mud_name() + "   As a creator, you "
  "are expected not to violate this policy.  This means:  No passing "
  "creator information on to players, and no revealing what is posted on "
  "creator boards.   As a creator you have access to a lot of information "
  "players do not... this information should be treated as confidential "
  "unless you have Express Permission from your Leader that you may reveal "
  "it.  In short, we have to be able to trust you with sensitive "
  "information.",
  "The most important thing to remember is that you are expected to "
  "create.  If all you're really interested in is coding toys, then this "
  "role is not for you.  " + mud_name() + " is not strict in the sense of 'You have "
  "to code X rooms per day!', but you are expected to make a measurable "
  "and consistent contribution to your domain.  Your Leader and the "
  "deputy immediately supervising you will check up on this on a "
  "regular basis.",
  "It may sound like an awful lot of work to be a creator... and it is.  "
  "But at the same time, it's an awful lot of fun, and provides you with "
  "the means of giving something back to a MUD that has hopefully provided "
  "you with many hours of entertainment.  :-)",
  "Now that the movie is over, are you still willing to continue your "
  "application to be a creator?  If not, then the exit 'drum' will "
  "return you to the " + mud_name() + "   If you are, hang around a while.  :-)"
  });
void save() {
  unguarded ((: save_object (SAVE) :));
}
void load() {
  unguarded ((: restore_object (SAVE) :));
}
void create() {
  do_setup++;
  ::create();
  do_setup--;
  add_property ("no scry", 1);
  add_property ("no teleport", 1);
  add_help_file ("/doc/creator/room/interview_help");
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void init() {
  ::init();
  this_player()->add_command ("show", this_object(), "movie");
  this_player()->add_command ("stop", this_object(), "movie");
  this_player()->add_command ("interview", this_object(),
      "<indirect:living>", (: do_interview ($1[0]) :));
  this_player()->add_command ("interview", this_object(),
      "<indirect:living> with <string>", (: do_interview ($1[0], $4[1]) :));
  this_player()->add_command ("end", this_object(), "interview");
  this_player()->add_command ("add", this_object(), "<string> [as "
      "candidate]", (: do_add ($4[0]) :));
  this_player()->add_command ("query", this_object(), "applicants");
  this_player()->add_command ("query", this_object(), "permitted "
    "[creators]", (: query_allowed_creators () :));
  this_player()->add_command ("query", this_object(),
    "{confirmation|acceptance|rejection} [text]",
    (: do_query_text ($4[0]) :));
  this_player()->add_command ("delete", this_object(), "<string> [from "
      "candidates]", (: remove_candidate ($4[0]) :));
  this_player()->add_command ("clear", this_object(), "[all] candidates",
      (: flush() :));
  this_player()->add_command ("confirm", this_object(), "<string>",
      (: do_confirm ($4[0]) :));
  this_player()->add_command ("grant", this_object(), "[access to] "
    "<string>", (: add_creator ($4[0]) :));
  this_player()->add_command ("remove", this_object(), "<string> "
    "[as allowed]", (: remove_creator ($4[0]) :));
  this_player()->add_command ("flag", this_object(), "<string> as "
    "{accepted|rejected}", (: do_flag ($4[0], $4[1]) :));
  this_player()->add_command ("read", this_object(),
    "interview for <string>",
    (: do_read ($4[0]) :));
  this_player()->add_command ("list", this_object(), "interviews");
}
void set_movie (string *m) {
  movie = m;
}
int query_permitted(string name) {
  object ob = load_object("/d/" + query_domain() + "/master");
  if (!ob) {
    printf ("Erk, this room is horribly borken!!  Please set the domain "
      "correctly.\n");
    return 0;
  }
  if (member_array (ob, previous_object (-1)) != -1) {
    return 2;
  }
  if (master()->high_programmer (name)) {
    return 1;
  }
#ifdef DEBUG
  if (name == "drakkos") {
    return 1;
  }
#endif
  if ((ob->query_lord() != name) &&
    !(ob->query_deputy (name)) && (member_array (name, _allowed_creators)
    == -1)) {
        return 0;
    }
  return 1;
}
private void write_to_file (string text) {
  unguarded ((: write_file (query_interview_dir()
        +query_subject() +".txt",
        sprintf ("%-=*s", 79, $(text) + "\n")) :));
}
void event_person_say(object ob, string start, string mess, string lang) {
  if (query_subject()) {
      write_to_file (sprintf ("%s says: %s\n", ob->short(),
          mess));
  }
}
void event_emote(object ob, string mess) {
  if (query_subject()) {
      write_to_file (replace (EVENTS->convert_message (mess), ({"$C$", ""})));
  }
}
int do_show() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot show a "
        "movie!\n", ({ }));
      return 0;
  }
  else {
    call_out ("play_movie", 5, 0);
  }
  this_player()->add_succeeded_mess (this_object(), "$N dim$s the light "
          "before pulling out a grubby looking movie projector and pointing "
          "it at an empty wall.  After flicking a switch, a thin ray of "
          "light shoots at the wall.\n", ({ }));
  return 1;
}
int do_stop() {
  int i;
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot stop a "
        "movie!\n", ({ }));
      return 0;
  }
  do {
    i = remove_call_out ("play_movie");
  } while (i != -1);
  this_player()->add_succeeded_mess (this_object(), "$N stop$s the movie.\n",
    ({ }));
  return 1;
}
void play_movie (int i) {
  if (movie[i][0] == '#') {
    tell_room (this_object(), "The movie shows " +
      movie[i][1..sizeof(movie[i])] + "\n");
  }
  else {
    event (this_object(), "person_say", "The voice from the movie says: ",
      movie[i], "general");
  }
  if (i < sizeof (movie)) {
    call_out ("play_movie", 15, ++i);
  }
}
varargs int do_interview (object ob, string names) {
  string *inter = ({ });
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot start an "
        "interview!\n", ({ }));
      return 0;
  }
  if (query_subject()) {
      this_player()->add_failed_mess (this_object(), "You'll have to end "
          "the interview with " + query_subject() + " first.\n", ({ }));
      return 0;
  }
  else {
      if (sizeof (names)) {
        names = replace (names, ({" ", ""}));
        inter = explode (names, ",");
        tell_creator ("drakkos", "%O.\n", inter);
        inter = filter (inter, (: find_player ($1)
          && find_player ($1)->query_playtester() :));
        tell_creator ("drakkos", "%O.\n", inter);
      }
      inter += ({ this_player()->query_name() });
      set_subject (ob->query_name());
      set_interviewer (inter);
      write_to_file (sprintf ("Interview with %s, started %s.  Interview "
        "conducted by %s.\n\n", ob->short(), ctime (time()),
        query_multiple_short (inter)));
  }
  this_player()->add_succeeded_mess (this_object(), "$N press$es a button "
      "on $p tape recorder, indicating the interview is now being "
      "recorded.\n", ({ }));
  return 1;
}
int do_end() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot end an "
        "interview!\n", ({ }));
      return 0;
  }
  if (!query_subject()) {
      this_player()->add_failed_mess (this_object(), "You are not currently "
          "interviewing anyone!\n", ({ }));
      return 0;
  }
  else {
      if (member_array (query_subject(), candidates) != -1) {
          candidates -= ({query_subject()});
      }
      if (member_array (query_subject(), submitted) != -1) {
          submitted -= ({query_subject()});
      }
      interviewed += ({query_subject()});
      interviewed = uniq_array (interviewed);
      save();
      write_to_file (sprintf ("Interview with %s, ended %s.\n", query_subject(),
        ctime (time())));
      set_subject (0);
      set_interviewer (0);
      this_player()->add_succeeded_mess (this_object(), "$N switch$es off "
          "$p tape recorder, indicating the interview is at an end.\n", ({ }));
      return 1;
  }
}
void event_soul(object ob, string str, mixed avoid) {
  if (environment (this_player()) != this_object()) {
    return;
  }
  if (query_subject()) {
    write_to_file (EVENTS->convert_message (str));
  }
}
int *query_co_ord() {
  return 0;
}
int do_query() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot query "
        "creator candidates!\n",
          ({ }));
      return 0;
  }
  if (!sizeof (query_applicants_text())) {
    this_player()->add_failed_mess (this_object(), "No information.\n");
  }
  else {
    tell_object (this_player(), this_object()->query_applicants_text());
  }
  return 1;
}
int do_add (string candidate) {
  int i = query_permitted (this_player()->query_name());
  if (!i) {
      this_player()->add_failed_mess (this_object(), "You cannot add a "
        "candidate!\n", ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(candidate)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (query_part_two_required()) {
    if (member_array (candidate, candidates) == -1) {
        unguarded ((: write_file (LOG, sprintf ("%s added %s as a "
            "candidate on %s.\n", ($(i) == 2? "The " + query_domain()
            + " master object" : this_player()->query_name()),
            $(candidate), ctime(time()))) :));
        candidates += ({candidate});
    }
    else {
      this_player()->add_failed_mess (this_object(), "This player has "
          "already been mailed about creatorship.\n", ({ }));
      return 0;
    }
  }
  else if (member_array (candidate, submitted) == -1) {
        unguarded ((: write_file (LOG, sprintf ("%s added %s as a "
            "candidate on %s.\n", ($(i) == 2? "The " + query_domain()
            + " master object" : this_player()->query_name()),
            $(candidate), ctime(time()))) :));
        submitted += ({candidate});
  }
  else {
      this_player()->add_failed_mess (this_object(), "This player has "
          "already been mailed about creatorship.\n", ({ }));
      return 0;
  }
    AUTO_MAILER->auto_mail( candidate, capitalize
      (this_player()->query_name()), "Your application to "
        + capitalize (query_domain()) + ".", query_cc(),
        query_part_two(), 0, 0);
    save();
    this_player()->add_succeeded_mess (this_object(), "$N add$s a "
      "name to the candidate list.\n", ({ }));
    return 1;
}
string* query_submitted() {
  return submitted;
}
string query_applicants_text() {
  string ret = "", *temp = allocate (sizeof (submitted));
  int i;
  if (sizeof (submitted)) {
      for (i = 0; i < sizeof (submitted); i++) {
          if (find_player (submitted[i])) {
              temp [i] = "%^BOLD%^"+submitted[i] + "%^RESET%^";
          }
          else {
              temp [i] = submitted [i];
          }
      }
    }
  if (query_part_two_required()) {
    if (sizeof (candidates)) {
      ret += sprintf ("The candidates for %s still to submit answers to "
          "part two of the application process are: %s.\n",
            capitalize (query_domain()), query_multiple_short (candidates));
    }
  }
  else {
    if (query_interview()) {
      if (sizeof (temp)) {
        ret += sprintf ("The following candidates for %s " +
        (query_part_two_required()? "have submitted "
          "answers to part two of the test and " :  "")
          + "are awaiting an interview.  "
          "Names in bold are currently online: %s.\n",
          capitalize (query_domain()), query_multiple_short (temp));
      }
    }
    else {
      ret += sprintf ("The following candidates for %s have submitted "
        "answers to part two of the test and are awaiting a response.  "
        "Names in bold are currently online: %s.\n",
        capitalize (query_domain()), query_multiple_short (temp));
    }
  }
  if (query_interview()) {
    if (sizeof (interviewed)) {
        ret += sprintf ("The following candidates have been interviewed "
            "for %s, and are awaiting a response: %s.\n",
            capitalize (query_domain()), query_multiple_short (interviewed));
    }
  }
  if (sizeof (accepted)) {
    ret += sprintf ("The following candidates have been accepted "
            "for %s: %s.\n",
            capitalize (query_domain()), query_multiple_short (accepted));
  }
  if (sizeof (rejected)) {
    ret += sprintf ("The following candidates have been rejected from "
            "%s: %s.\n",
            capitalize (query_domain()), query_multiple_short (rejected));
  }
  if (!sizeof (ret)) {
      ret += "There are no outstanding candidates, and no-one has been "
          "interviewed recently.\n";
  }
  return ret;
}
int clear_interviewed() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  interviewed = ({ });
  return 1;
}
int clear_candidates() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  candidates = ({ });
  return 1;
}
int flush() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  candidates = ({ });
  interviewed = ({ });
  submitted = ({ });
  accepted = ({ });
  rejected = ({ });
  return 1;
}
int remove_candidate(string candidate) {
  int i;
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (member_array (candidate, candidates) != -1) {
      candidates -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, submitted) != -1) {
      submitted -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, interviewed) != -1) {
      interviewed -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, accepted) != -1) {
      accepted -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, rejected) != -1) {
      rejected -= ({candidate});
      i = 1;
  }
  if (i == 1) {
    this_player()->add_succeeded_mess (this_object(), "$N delete$s a "
      "name from the candidate list.\n", ({ }));
    save();
    return 1;
  }
  this_player()->add_failed_mess (this_object(), "No candidate by that "
    "name is on the list.\n", ({ }));
  return 0;
}
int add_candidate(string name) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(name)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (member_array (name, candidates) == -1) {
      candidates += ({name});
      return 1;
  }
  return 0;
}
int add_interviewed(string name) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(name)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (member_array (name, interviewed) == -1) {
      interviewed += ({name});
      return 1;
  }
  return 0;
}
int add_confirmed(string name) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(name)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (member_array (name, submitted) == -1) {
      submitted += ({name});
      return 1;
  }
  return 0;
}
int remove_interviewed(string candidate) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (member_array (candidate, interviewed) != -1) {
      interviewed -= ({candidate});
      return 1;
  }
  return 0;
}
int do_confirm (string candidate) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(candidate)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (member_array (candidate, submitted) != -1) {
    this_player()->add_failed_mess (this_object(), "You have already "
      "confirmed receipt of this candidate's submission.\n", ({ }));
    return 0;
  }
  if (member_array (candidate, interviewed) != -1) {
    this_player()->add_failed_mess (this_object(), "This candidate "
      "has already been interviewed.\n", ({ }));
    return 0;
  }
  if (member_array (candidate, candidates) != -1) {
    candidates -= ({candidate});
  }
    submitted += ({candidate});
    AUTO_MAILER->auto_mail( candidate, capitalize
        (this_player()->query_name()), "Thank you for your submission.",
        query_cc(), query_confirmation(), 0, 0);
    save();
  this_player()->add_succeeded_mess (this_object(), "$N confirm$s "
    "receipt of a candidate's application.\n", ({ }));
  return 1;
}
void set_domain(string dom) {
  _domain = dom;
}
string query_domain () {
  if (!_domain) {
    return "unset";
  }
  else {
    return _domain;
  }
}
void set_confirmation(string text) {
  _confirmation_text = text;
}
string query_confirmation() {
  if (!sizeof (_confirmation_text)) {
    if (query_interview()) {
      return sprintf ("Bing!\n\n"
        "Thank you for sending in the second part of the application.  "
        "The next part of the application process will be an interview "
        "to discuss your application to the %s domain.  "
        "This interview is likely to take around an hour of your time, "
        "so if you could mail me with a list of your "
        "common online times, hopefully we'll be able to make an "
        "appointment that is mutually convenient.\n\nRegards,\n%s.",
        query_domain(), LORD);
    }
    else {
      return sprintf ("Bing!\n\n"
        "Thank you for sending in the second part of the application.  "
        "Your application to the %s domain is now being considered, and "
        "you should expect to hear back within a week or two with an "
        "answer.\n\nRegards,\n%s.",
        query_domain(), LORD);
    }
  }
  else {
    return _confirmation_text;
  }
}
string query_lord() {
  return LORD;
}
void set_part_two_required (int i) {
  _pt_two = i;
}
int query_part_two_required () {
  return _pt_two;
}
void set_interview(int i) {
  _interview = i;
}
int query_interview() {
  return _interview;
}
string query_subject(){
  if (_subject) {
    return _subject;
  }
  return 0;
}
private void set_subject (string name) {
    _subject  = name;
}
private void set_interviewer (mixed name) {
  if (arrayp (name)) {
    _int  = name;
  }
  else {
    _int = ({ name });
  }
}
string *query_interviewer() {
  return _int;
}
int query_is_interviewer (string name) {
  if (!sizeof (_int)) {
    return 0;
  }
  if (member_array (name, _int) != -1) {
    return 1;
  }
  return 0;
}
string* query_permitted_creators() {
  return copy (_allowed_creators);
}
private void add_permitted_creator(string name) {
  if (member_array (name, _allowed_creators) == -1) {
    _allowed_creators += ({ name });
  }
}
private void remove_permitted_creator(string name) {
  if (member_array (name, _allowed_creators) != -1) {
    _allowed_creators -= ({ name });
  }
}
int add_creator (string name) {
  object ob = find_object ("/d/" + query_domain() + "/master");
  if (this_player()->query_name() != ob->query_lord()) {
    this_player()->add_failed_mess (this_object(), "Only the lord "
      "may permit creators to use this room.\n", ({ }));
    return 0;
  }
  if (!PLAYER_HANDLER->test_creator (name)) {
      this_player()->add_failed_mess (this_object(), "Only creators "
        "may be permitted to use the interview room.\n", ({ }));
      return 0;
  }
  add_permitted_creator (name);
  save();
  this_player()->add_succeeded_mess (this_object(), "$N add$s a creator "
    "as allowed.\n", ({ }));
  return 1;
}
int remove_creator (string name) {
  object ob = find_object ("/d/" + query_domain() + "/master");
  if (this_player()->query_name() != ob->query_lord()) {
    this_player()->add_failed_mess (this_object(), "Only the lord "
      "may permit creators to use this room.\n", ({ }));
    return 0;
  }
  remove_permitted_creator (name);
  save();
  this_player()->add_succeeded_mess (this_object(), "$N remove$s a creator "
    "as allowed.\n", ({ }));
  return 1;
}
int query_allowed_creators() {
  if (!sizeof (query_permitted_creators())) {
    this_player()->add_failed_mess (this_object(), "Only the domain lord and "
      "the domain deputies are currently permitted to use this room.\n",
      ({ }));
    return 0;
  }
  tell_object (this_player(), sprintf ("In addition to the domain Lord and "
    "the domain deputies, the following creators are permitted "
    "to make use of this room: %s.\n", query_multiple_short
    (query_permitted_creators())));
  return 1;
}
string query_part_two(){
  string temp;
  if (_filename) {
    temp = unguarded ((: read_file (_filename) :));
    if (sizeof (temp)) {
      return temp;
    }
  }
  return sprintf ("Bing!\n\nThank you for your application to the %s domain. "
    "\n\nYour application has been received and is awaiting processing.\n\n"
    "Regards,\n%s.", query_domain(), LORD);
}
int set_part_two(string file) {
  if (!sizeof (file)) {
    printf ("No file given for part two of application.  Aborting.\n");
    return 0;
  }
  if (file_size(file) == -1) {
    printf ("File given for set_part_two() does not exist.  No file set.\n");
    return 0;
  }
  _filename = file;
  return 1;
}
string query_interview_dir(){
  if (sizeof (_interview_dir)) {
    return _interview_dir;
  }
  else {
    return SECURE;
  }
}
int set_interview_dir(string dir) {
  if (!sizeof (dir)) {
    printf ("No directory given for interviews.  Aborting.\n");
    return 0;
  }
  if (file_size(dir) != -2) {
    printf ("Directory given for set_interview_dir does not exist.  "
      "Aborting.\n");
    return 0;
  }
  _interview_dir = dir;
  return 1;
}
int do_query_text(string flag) {
  string temp;
  switch (flag) {
    case "confirmation":
      temp = query_confirmation();
    break;
    case "acceptance":
      temp = query_acceptance();
    break;
    case "rejection":
      temp = query_rejection();
    break;
    default:
      temp = "I'm sorry, there has been an error.\n";
    break;
  }
  tell_object (this_player(), temp);
  return 1;
}
int do_flag(string name, string flag) {
  if (member_array (name, candidates) != -1) {
        candidates -= ({name});
  }
  if (member_array (name, submitted) != -1) {
      submitted -= ({name});
  }
  if (member_array (name, interviewed) != -1) {
      interviewed -= ({name});
  }
  if (flag == "accepted") {
    AUTO_MAILER->auto_mail( name, capitalize
      (this_player()->query_name()), "Congratulations!",
          query_cc(), query_acceptance(), 0, 0);
    if (member_array (name, accepted) == -1) {
      accepted += ({name});
    }
  }
  else {
    AUTO_MAILER->auto_mail( name, capitalize
      (this_player()->query_name()), sprintf ("Your application to the %s "
        "domain.", query_domain()), query_cc(), query_rejection(), 0, 0);
    if (member_array (name, rejected) == -1) {
      rejected += ({name});
    }
  }
  this_player()->add_succeeded_mess (this_object(), sprintf ("$N flag$s a "
    "player as %s.\n", flag), ({ }));
  save();
  unguarded ((: write_file (LOG, sprintf ("%s flagged %s as %s "
          "on %s.\n", this_player()->query_name(),
          $(name), $(flag), ctime(time()))) :));
  return 1;
}
void set_rejection(string text) {
  _rejection_text = text;
}
void set_acceptance(string text) {
  _acceptance_text = text;
}
string query_rejection() {
  if (!sizeof (_rejection_text)) {
    return sprintf ("Hello.\n\n"
      "I'm sorry to say that your application to the %s domain has been "
      "unsuccessful.  My apologies that I cannot hire you at this time.  "
      "I will of course keep your details on file should you wish to "
      "apply again in the future.\n\nRegards,\n%s.",
          query_domain(), LORD);
  }
  else {
    return _rejection_text;
  }
}
string query_acceptance() {
  if (!sizeof (_acceptance_text)) {
    return sprintf ("Bing!\n\n"
      "It is my great pleasure to inform you that your application to the %s "
        "domain has been successful.  Congratulations!\n\nBefore being promoted, "
        "you will need to ensure you repay any debts you have.  If you wish "
        "to bequeath your inventory on a fellow player, this must also be "
        "done before you are employed - you won't get a chance once you're "
        "a creator.\n\nPlease send me a mail letting me know when you will "
        "be available for promotion and your orientation lecture.\n\n"
        "Congratulations,\n%s.",query_domain(), LORD);
  }
  else {
    return _acceptance_text;
  }
}
int do_read (string name) {
  string path;
  if (!query_permitted (this_player()->query_name())) {
    this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
        ({ }));
    return 0;
  }
  path = query_interview_dir() + name + ".txt";
  if (!file_size (path)) {
    this_player()->add_failed_mess (this_object(), "This document does "
      "not exist.\n", ({ }));
    return 0;
  }
  this_player()->more_string (unguarded ((: read_file ($(path)) :)));
  return 1;
}
string query_cc() {
  if (sizeof (_cc)) {
    return implode (_cc, ",");
  }
  return 0;
}
void set_cc (string *i) {
  _cc = i;
}
int do_list() {
  string *list, text;
  if (!query_permitted (this_player()->query_name())) {
    this_player()->add_failed_mess (this_object(), "You are not permitted "
      "to do this.\n", ({ }));
    return 0;
  }
  else {
    list = get_dir (query_interview_dir());
    list -= ({"candidate_list.o", "candidate_log.txt"});
  }
  list = map (list, (: capitalize ($1) :));
  text = replace (query_multiple_short (list), ({".txt", ""}));
  tell_object (this_player(), sprintf ("The following interviews have been "
    "conducted for the %s domain: %s.\n", query_domain(),
      text));
  this_player()->add_succeeded_mess (this_object(), "$N list$s the completed "
    "interviews.\n", ({ }));
  return 1;
}
string* query_all_applicants() {
  return uniq_array (candidates + interviewed + submitted + accepted + rejected);
}
string* query_interviewed() {
  return interviewed;
}

==================================================
FILE: dom/loader.c
==================================================

string *pre_load;
void create() {
  int i;
  string domain;
  foreach(domain in "/secure/master"->query_domains()) {
    unguarded((: restore_object, "/d/"+ domain + "/loader" :));
    if (!pre_load)
      pre_load = ({ });
    for (i=0;i<sizeof(pre_load);i++) {
      if(pre_load && explode(pre_load[i], "/")[1] != domain)
        printf("invalid " + domain + " preload: " + pre_load[i] +
               "\n");
      else {
        printf(domain +" pre_loading "+pre_load[i]+".\n");
        if (catch(call_other(pre_load[i], "??")))
          call_out("do_load", 0, pre_load[i]);
      }
    }
  }
}
void do_load(string str) {
  call_other(str, "??");
}
int add_pre_load(string domain, string str) {
  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return 0;
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  if (member_array(str, pre_load) == -1)
    pre_load += ({ str });
  save_object("/d/" + domain + "/loader");
  return 1;
}
int remove_pre_load(string domain, string str) {
  int i;
  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return 0;
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  if ((i=member_array(str, pre_load)) == -1)
    return 0;
  pre_load = delete(pre_load, i, 1);
  save_object("/d/" + domain + "/loader");
}
string *query_pre_load(string domain) {
  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return ({ });
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  return pre_load;
}

==================================================
FILE: dom/master.c
==================================================

inherit "/std/dom/base_master";
string query_lord() {
  return LORD;
}
string author_file(string *path) {
  return capitalize(DOMAIN);
}
int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}
int valid_read(string *path, string euid, string funct);
int valid_write(string *path, string euid, string funct);
int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
}
string log_who(string where) {
  return LORD;
}
string query_info() {
  return "";
}

==================================================
FILE: environ/snowball.c
==================================================

#include <tasks.h>
inherit "std/object";
int strength;
void set_strength( int number );
void setup() {
   set_name( "snowball" );
   add_alias( "ball" );
   add_adjective( "snow" );
   set_strength( 99 );
   set_heart_beat( 1 );
}
int query_strength() { return strength; }
void set_strength( int number ) { strength = number; }
string long( string word, int dark ) {
   return "This is a "+ ({
      "very small lump of slush",
      "small and rather soggy lump of snow",
      "small snowball",
      "smallish snowball",
      "vaguely small snowball",
      "decent sized snowball",
      "reasonably sized snowball",
      "snowball for throwing at someone",
      "good snowball for throwing at someone",
      "nice, big snowball, just right for throwing at someone"
   })[ strength / 10 ] +".\n";
}
void init() {
    add_command( "throw", "<direct:object> {at|to} <indirect:object>" );
}
void heart_beat() {
   strength--;
   if ( strength < 1 ) {
      set_heart_beat( 0 );
      move( "/room/rubbish" );
   }
}
private object find_person(object ob) {
   if (living(ob)) {
      return ob;
   } else {
      while (ob && !living(ob)) {
         ob = environment(ob);
      }
      if (ob) {
         return ob;
      }
   }
   return 0;
}
int do_throw( object *obs ) {
   object per;
   int chance;
   per = find_person(obs[0]);
   if (per) {
      if (per != obs[0]) {
         chance = 0;
      } else {
         chance = 30;
      }
      if (per == this_player()) {
         per->add_effect( "/std/effects/external/snowball", strength );
      } else {
         switch (TASKER->compare_skills(this_player(),
                                        "fighting.combat.range.thrown",
                                        per,
                                        "fighting.combat.dodging.range",
                                        chance,
                                        TM_FREE,
                                        TM_FREE)) {
         case OFFAWARD :
            tell_object(this_player(), "%^YELLOW%^You feel more able to throw "
                                       "snowballs at people.\n%^YELLOW%^");
         case OFFWIN :
            per->add_effect( "/std/effects/external/snowball", strength );
            add_succeeded_mess( ({ "$N throw$s $D at $I and hit$s!\n",
                "$N throw$s $D at $I and hits!\n" }),  ({ obs[0] }) );
            break;
         case DEFAWARD :
            tell_object(this_player(), "%^YELLOW%^You feel more able to dodge "
                                       "snowball thrown by people.\n%^YELLOW%^");
         case DEFWIN :
            add_succeeded_mess( "$N throw$s $D at $I and miss$es!\n",
                                   ({ obs[0] }) );
            break;
         }
      }
   } else {
      add_succeeded_mess( "$N throw$s $D at $I.\n", ({ obs[ 0 ] }) );
   }
   move( "/room/rubbish" );
   return 1;
}
mapping query_dynamic_auto_load() {
   return ([
      "::" : ::query_dynamic_auto_load(),
      "strength" : strength
   ]);
}
void init_dynamic_arg( mapping map, object ) {
   ::init_dynamic_arg( map[ "::" ] );
   strength = map[ "strength" ];
}

==================================================
FILE: environ/snowman.c
==================================================

#include <move_failures.h>
inherit "/std/object";
private int _call_out_handle;
void setup() {
    reset_get();
    if ( clonep() ) {
        _call_out_handle = call_out("die",400);
    }
}
void set_type(string type) {
    set_name(type);
    set_short(type);
    set_long("A wonderful " + type + " with glowing eyes made of coal and twigs "
      "for ears.\n");
    add_extra_look( this_object() );
}
string extra_look( object ob ) {
    int time_left;
    if ( !_call_out_handle ) {
        return "";
    }
    time_left = find_call_out( _call_out_handle );
    debug_printf( "time left is %d\n", time_left );
    if ( time_left > 300 || time_left < 0 ) {
        return "";
    }
    return "It is " + ({ "mostly", "half", "slightly" })[time_left/100] +
        " melted.\n";
}
void die() {
    string noun;
    switch( environment( this_object() )->query_property( "location" ) ) {
    case "inside":
        noun = "floor";
        break;
    case "outside":
        noun = "ground";
        break;
    case "underwater":
        noun = "seabed";
        break;
    default:
        noun = "floor";
        break;
    }
    tell_room( environment( this_object() ),
      the_short() + " $V$0=melts,melt$V$ into the " + noun + ".\n");
    if ( this_object()->move( "/room/rubbish" ) != MOVE_OK ) {
        dest_me();
    }
}

==================================================
FILE: environ/weather.c
==================================================

#include <config.h>
inherit "std/object";
#include "climate.h"
#define FILE_NAME "/save/environ/weather"
#define HOME "/obj/handlers/weather_room"
#define MAX_DIST 100
#define YEAR 60
#define DAY 60
#define SPEED 40
mixed *coldarr,
      *cloudarr,
      *rainarr;
int timeofyear,
    mooncycle,
    moonoff,
    timeofday,
    intensity;
int distance(mixed *co_ord1,mixed *co_ord);
int cloud_index(object env);
int rain_index(object env);
int temperature_index(object env);
string cloud_string(object env);
string rain_string(object env);
string temperature_string(object env);
void setup() {
  set_name("weather");
  set_short("weather controller extrodinare");
  set_long("The weather controller, at least this one is always right!\n");
  cloudarr = ({ ({ 0,0 }), ({ 50,50 }), ({ -50,-50 }) });
  rainarr = ({ ({ 0,0 }), ({ 50,50 }), ({ -50,-50 }) });
  coldarr = ({ ({ 0,0 }), ({ 50,50 }), ({ -50,-50 }) });
  intensity = 100;
  restore_object(FILE_NAME);
  call_out("update_low",SPEED);
  move("bing");
}
move(arg) {
  ::move(HOME);
}
mixed *query_cold() { return coldarr; }
mixed *query_rain() { return rainarr; }
mixed *query_cloud() { return cloudarr; }
int query_moon() { return mooncycle; }
string query_moon_string(object env) {
  int bing;
  bing = timeofday - (DAY/4) -
         (distance((mixed *)env->query_co_ord(), ({ 0, 0, 0, }))/100);
  if (bing<0) bing += DAY;
  if ((moonoff+(DAY/2)<bing) && (bing<DAY-moonoff))
    return 0;
  return ({ "full moon",
            "waning three quarter moon",
            "waning half moon",
            "waning quarter moon",
            "waning cresent moon",
            "new moon",
            "waxing cresent moon",
            "waxing quarter moon",
            "waxing half moon",
            "waxing three quarter moon" })[mooncycle];
}
int distance(mixed *co_ord1, mixed *co_ord2) {
  int off;
  if (!pointerp(co_ord1) || !pointerp(co_ord2))
    return 0;
  if (co_ord1[0]>co_ord2[0])
    off = co_ord1[0] - co_ord2[0];
  else
    off = co_ord2[0] - co_ord1[0];
  if (co_ord1[1]>co_ord2[1])
    off += co_ord1[1] - co_ord2[1];
  else
    off += co_ord2[1] - co_ord1[1];
  return off;
}
int query_season() { return timeofyear/15; }
int query_time_of_year() { return timeofyear; }
int query_time_of_day() { return timeofday; }
int query_day(object env) {
  int bing, bit;
  if (!env) {
    load_object(CONFIG_START_LOCATION);
    env = find_object(CONFIG_START_LOCATION);
  }
  bing = timeofday - (DAY/4) -
         (distance((mixed *)env->query_co_ord(), ({ 0, 0, 0, }))/100);
  if (bing<0) bing += DAY;
  bit = (DAY/2)-(timeofyear-(YEAR/2))/(YEAR/10);
  if (bing>bit)
    return 0;
  if (bit < 10)
    return bit;
  return -(bing - bit);
}
int query_darkness(object env) {
  int bing, per, i;
  per = -cloud_index(env);
  if (per <-100)
    per = -100;
  if (per > 100)
    per = 100;
  if ((i=query_day(env))) {
    i *= 20;
    if (i>100)
      i = 100;
    return 50+(per+100)*150*i/20000;
  }
  bing = timeofday - (DAY/4) -
         (distance((mixed *)env->query_co_ord(), ({ 0, 0, 0, }))/100);
  if (bing<0) bing += DAY;
  if ((moonoff+(DAY/2)<bing) && (bing<DAY-moonoff))
    return 15+(per+100)*30/200;
  if (timeofday<0) timeofday += DAY;
  i = mooncycle -5;
  if (i<0)
    i = -i;
  return 30+(per+100)*14*i/200;
}
string weather_string(object env) {
  return temperature_string(env)+" with "+cloud_string(env)+
         rain_string(env);
}
int query_raining(object env) {
  int cloud,rain;
  if (temperature_index(env)/(100/7)<2) {
    cloud = cloud_index(env);
    if (cloud<=0)
      return 0;
    rain = rain_index(env);
    if (cloud-rain<=0)
      return 0;
    return cloud-rain;
  }
  return 0;
}
int query_hailing(object env) {
  int cloud, rain;
  if (temperature_index(env)/(100/7)==2) {
    cloud = cloud_index(env);
    if (cloud <=0)
      return 0;
    rain = rain_index(env);
    if (cloud-rain <=0)
      return 0;
    return cloud-rain;
  }
  return 0;
}
int query_snowing(object env) {
  int cloud,rain;
  if ((temperature_index(env)/(100/7))>=3) {
    cloud = cloud_index(env);
    if (cloud<=0)
      return 0;
    rain = cloud_index(env);
    if (cloud-rain<=0)
      return 0;
    return cloud-rain;
  }
  return 0;
}
string rain_string(object env) {
  int cloud, rain, temp;
  string tempstr1,tempstr2;
  cloud = cloud_index(env);
  rain = rain_index(env);
  if (cloud<=0) return "";
  if (cloud-rain<=0) return "";
  temp = temperature_index(env)/(100/7);
  if (temp>3) temp = 3;
  if (temp<-3) temp = -3;
  tempstr1 = ({ "very hot ",
                "hot ",
                "warm ",
                "nice ",
                "cold ",
                "",
                "" })[temp+3];
  tempstr2 = ({ " rain",
                " rain",
                " rain",
                " rain",
                " rain",
                " hail",
                " snow" })[temp+3];
  cloud = (cloud-rain) / 20;
  if (cloud>5) cloud = 5;
  return "\n"+capitalize(tempstr1 + ({ "very light",
                      "light",
                      "medium",
                      "heavy",
                      "very heavy" }) [cloud]+tempstr2);
}
string temperature_string(object env) {
  int inten;
  inten = temperature_index(env);
  inten /= 10;
  if (inten>10)
    inten = 10;
  if (inten<-10)
    inten = -10;
  return ({ "Its one of those baking eggs on the pavement days",
            "So hot that the sun feels like its right next door",
            "Damn hot",
            "Very hot",
            "Hot",
            "Hot",
            "Reasonably hot",
            "Very warm",
            "Warm",
            "Pleasantly warm",
            "Average temerature",
            "A little chilly",
            "A slight nip in the air",
            "Chilly",
            "Very chilly",
            "Cold",
            "Cold",
            "Very cold",
            "Damn cold",
            "Incredibly cold",
            "Freezing cold" })[inten+10];
}
string cloud_string(object env) {
  int off;
  off = cloud_index(env) / 20;
  if (off>5) off = 5;
  if (off<-5) off = -5;
  return ({ "a beatifully clear sky",
            "a few high level sirius clouds",
            "scattered puffy clouds",
            "very thin complete cloud cover",
            "light cloud cover",
            "medium cloud cover",
            "dense cloud cover",
            "packed cloud cover",
            "packed cloud cover",
            "heavy black clouds",
            "thick heavy clouds",
         })[off+5];
}
int temperature_index(object env) {
  int off,i;
  mixed clim, *co_ord;
  for (i=0;i<sizeof(coldarr);i++)
    off += (distance((mixed *)env->query_co_ord(), coldarr[i]) % (MAX_DIST*2));
  off = off / sizeof(coldarr);
  if ((clim = (mixed *)env->query_property("climate")))
    off += clim[C_TEMP];
  if (off>MAX_DIST) off = (MAX_DIST*2) - off;
  off -= (MAX_DIST/2);
  off = 0 - off;
  co_ord = (mixed *)env->query_co_ord();
  if (!co_ord)
    co_ord = ({ 0, 0, 0 });
  return (off + (timeofyear - (YEAR/2)) + (timeofday - (DAY/2)) + co_ord[2]);
}
int cloud_index(object env) {
  int off;
  mixed *clim;
  int i;
  for (i=0;i<sizeof(cloudarr);i++)
    off += (distance((mixed *)env->query_co_ord(), cloudarr[i]) % (MAX_DIST*2));
  off = off / sizeof(cloudarr);
  if ((clim = (mixed *)env->query_property("climate")))
    off += clim[C_CLOUD];
  if (off>MAX_DIST) off = (MAX_DIST*2) - off;
  off -= (MAX_DIST/2);
  off = 0-off;
  return (off + (timeofyear - (YEAR/2)));
}
int rain_index(object env) {
  int off;
  mixed *clim;
  int i;
  for (i=0;i<sizeof(rainarr);i++)
    off += (distance((mixed *)env->query_co_ord(), rainarr[i]) % (MAX_DIST*2));
  off = off / sizeof(rainarr);
  if ((clim = (mixed *)env->query_property("climate")))
    off += clim[C_RAIN];
  if (off>MAX_DIST) off = (MAX_DIST*2) - off;
  off -= MAX_DIST/2;
  off = 0-off;
  return off;
}
void update_low() {
  int i;
  timeofday++;
  if (timeofday>DAY) {
    timeofday = 0;
    timeofyear++;
    mooncycle++;
    if (mooncycle %2) {
      moonoff += 1;
      moonoff = moonoff % (DAY/2);
    }
    timeofyear = timeofyear % YEAR;
    mooncycle = mooncycle % 10;
    save_object(FILE_NAME);
  }
  for (i=0;i<sizeof(rainarr);i++) {
    rainarr[i][0] += random(3)-1;
    rainarr[i][0] = rainarr[i][0] % (MAX_DIST*2);
    rainarr[i][1] += random(3)-1;
    rainarr[i][1] = rainarr[i][1] % (MAX_DIST*2);
  }
  for (i=0;i<sizeof(cloudarr);i++) {
    cloudarr[i][0] += random(3)-1;
    cloudarr[i][0] = cloudarr[i][0] % (MAX_DIST*2);
    cloudarr[i][1] += random(3)-1;
    cloudarr[i][1] = cloudarr[i][1] % (MAX_DIST*2);
  }
  for (i=0;i<sizeof(coldarr);i++) {
    coldarr[i][0] += random(3)-1;
    coldarr[i][0] = coldarr[i][0] % (MAX_DIST*2);
    coldarr[i][1] += random(3)-1;
    coldarr[i][1] = coldarr[i][1] % (MAX_DIST*2);
  }
  intensity += random(3)-1;
  if (intensity<50)
    intensity=50;
  if (intensity>300)
    intensity=300;
  call_out("update_low",SPEED);
}
void dest_me() {
  save_object(FILE_NAME);
  ::dest_me();
}

==================================================
FILE: environ/weather_room.c
==================================================

inherit "std/room";
mixed leverarr;
reset (arg) {
  if (arg) return;
  set_short("The weather room");
  set_long("The weather control center for the entire mud. On the floor should\n"+
           "be the controller itself, scattered around the room are hundred of impresive\n"+
           "flashing lights, dials and levers. You get the feeling however that they dont\n"+
           "actually do anything.\n");
  set_light(1);
  seteuid("pinkfish");
  add_property("inside");
  add_exit("pinkfish","d/Fish/pinkfish/workroom");
  add_item("lights","What did I say? there are lots of them and they are insesantly\n"+
           "flashing.\n");
  add_item("dials","Large dials with all sort of things on them. One you can see says\n"+
           "'Colour of spring', it is currently pointing at purple.\n");
  add_item("levers",
           "The levers are large multicolour protuberances which are scattered around the\n"+
           "room in random profusion.\n");
  leverarr = ({ ({ "blue",
       "The rooms spins and a small bit of printed paper falls from the\n"+
       "Weather controller saying:\n#query_rain" }),
                ({ "white",
       "The ground heaves in a major convulsion and a mound of paper falls onto\n"+
       "You from the ceiling saying:\n#query_cloud" }) });
}
init() {
  ::init();
  add_action("pull","pull");
  add_action("push","push");
}
pull(str) {
  int i;
  string type,rand;
  object lever, weather;
  if (str == "lever" || str == "levers")
    lever = leverarr[random(sizeof(leverarr))];
  else {
    if (!sscanf(str,"%s lever%s",type,rand)) {
      notify_fail("You have to pull a lever.\n");
      return 0;
    }
    for (i=0;i<sizeof(leverarr);i++) {
      if (leverarr[i][0] == type) {
        lever = leverarr[i];
        break;
      }
    }
  }
  if (!lever) {
    notify_fail("You need to choose and existing lever");
    return ;
  }
  weather = present("weather",this_object());
  if (!weather) {
    notify_fail("Opps the weather controller does not exist.\n");
    return 0;
  }
  sscanf(lever[1],"%s#%s",type,rand);
  write(type);
  this_player()->print_object(call_other(weather,rand));
  return 1;
}
push(str) {
  object lever;
  int i;
  string type,bing;
  if (str == "levers" && str == "lever")
    lever = leverarr[random(sizeof(leverarr))];
  else {
    if (!sscanf(str,"%s lever%s",type,bing)) {
      notify_fail("You must push an existing lever.\n");
      return 0;
    }
    for (i=0;i<sizeof(leverarr);i++)
      if (type == leverarr[i][0]) {
        lever = leverarr[i];
        break;
      }
  }
  if (!lever) {
    notify_fail("An existing lever could be usefull...\n");
    return 0;
  }
  write("You huff and you puff, but you just cant push that lever.\n");
}

==================================================
FILE: living/armour.c
==================================================

#include <clothing.h>
#include <function.h>
#include <race.h>
#include <armour.h>
inherit "/std/armour_logic";
#undef INFORM 1
nosave string skin;
nosave object *wearing;
nosave mixed stopped;
nosave mixed *_armour_callbacks;
nosave int *_cids;
void create() {
   skin = "morphological field";
   wearing = ({ });
   if(!_armour_callbacks)
     _armour_callbacks = ({ ({ }), ({ }), ({ }) });
   if(!_cids)
     _cids = ({ 0, 0, 0 });
   ::create();
}
int register_armour_callback(int level, mixed callback, mixed data) {
  _armour_callbacks[level] += ({ new(class armour_callback,
                                     id : ++(_cids[level]),
                                     callback: callback,
                                     data : data) });
  return _cids[level];
}
int remove_armour_callback(int level, int id) {
  int i;
  for(i=0; i<sizeof(_armour_callbacks[level]); i++) {
    if((_armour_callbacks[level][i])->id == id) {
      _armour_callbacks[level] -= ({ _armour_callbacks[level][i] });
      return 1;
    }
  }
  return 0;
}
int update_armour_callback(int level, int id, mixed data) {
  int i;
  for(i=0; i<sizeof(_armour_callbacks[level]); i++) {
    if((_armour_callbacks[level][i])->id == id) {
      _armour_callbacks[level][i]->data = data;
      return 1;
    }
  }
  return 0;
}
mixed *query_armour_callbacks() { return copy(_armour_callbacks); }
string query_skin() { return skin; }
void set_skin( string word ) { skin = word; }
object *query_wearing() {
   wearing = filter(wearing, (: $1 && environment($1) == this_object() :));
   return copy( wearing );
}
object *query_armours() {
   return query_wearing();
}
void clear_armours() {
   wearing->set_worn_by( 0 );
   wearing = ({ });
}
mixed query_stopped() {
   return stopped;
}
void set_stopped( mixed arg ) { stopped = arg; }
protected int equivalent_armour_types( mixed comp, string type ) {
   string word;
   if ( stringp( comp ) ) {
      if ( CLOTHING_HANDLER->query_equivilant_type( comp ) ) {
         return CLOTHING_HANDLER->query_equivilant_type( comp ) == type;
      }
      return comp == type;
   }
   foreach ( word in comp ) {
      if ( equivalent_armour_types( word, type ) )
         return 1;
   }
   return 0;
}
string wear_armour( object armour, int doing_hold ) {
   int no_limbs;
   string type, word, fail_mess;
   mixed types;
   object thing;
   mapping things;
   if (environment(armour) != this_object()) {
      return "must be in your inventory";
   }
   wearing -= ({ 0 });
   if (member_array(armour, wearing) > -1)
     return "since you already have " + armour->query_objective() + " on";
   types = armour->query_type();
   word = this_object()->not_allowed_to_wear( types );
   if ( word ) {
      return word;
   }
   things = ([ ]);
   if ( stringp( types ) ) {
      types = ({ types });
   }
   if ( !pointerp( types ) ) {
      return "oh dear";
   }
   foreach ( type in types ) {
      if ( CLOTHING_HANDLER->query_equivilant_type( type ) ) {
         type = CLOTHING_HANDLER->query_equivilant_type( type );
      }
      things[ type ] = ({ });
      foreach ( thing in wearing ) {
         if ( equivalent_armour_types( (mixed)thing->query_type(), type ) )  {
            things[ type ] += ({ thing });
         }
      }
   }
   word = (string)this_object()->query_race_ob();
   if ( !word )
     return "no race object";
   foreach ( type in keys( things ) ) {
      if ( (int)word->query_number_worn( type ) <= sizeof( things[ type ] ) ) {
         return "since you are already wearing "+
               query_multiple_short( things[ type ] );
      }
   }
   no_limbs = (int)armour->query_no_limbs();
   if ( no_limbs && !doing_hold ) {
      if ( member_array( armour,
            (object *)this_object()->query_holding() ) != -1 ) {
         return "already wearing";
      }
      if( sizeof( (int *)armour->hold_item( this_object(), -1 ) ) ) {
         return 0;
      } else {
         return "already holding";
      }
   }
   if ( !armour->set_worn_by( this_object() ) ) {
      if( fail_mess = armour->query_wear_failure_mess() )
         return fail_mess;
      else
         return "oh dear";
   }
   wearing += ({ armour });
   this_object()->do_burden_call();
   return 0;
}
int remove_armour( object thing ) {
   int i;
   wearing -= ({ 0 });
   i = member_array( thing, wearing );
   if ( i == -1 ) {
      return 1;
   }
   if ( !thing->set_worn_by( 0 ) ) {
      return 1;
   }
   if ( member_array( thing, (object *)this_object()->query_holding() ) != -1 ) {
      if ( !sizeof( (int *)this_object()->set_unhold( thing ) ) ) {
         return 1;
      }
   }
   wearing = delete( wearing, i, 1 );
   this_object()->do_burden_call();
   return 0;
}
varargs int query_ac( string type, int amount, string zone ) {
  int part, total, i, max;
  string word, *types;
  mixed most;
  object thing;
  object *defenses;
  stopped = 0;
#ifdef INFORM
  event( environment(), "inform", "zone "+ zone, "combat" );
#endif
  if ( !zone ) {
    switch(random(21)) {
    case 0..1: zone = "head"; break;
    case 2: zone = "neck"; break;
    case 3..6: zone="chest"; break;
    case 7..9: zone="abdomen"; break;
    case 10..12: zone = "arms"; break;
    case 13..14:
      zone = "hands"; break;
    case 15..18: zone = "legs"; break;
    case 19: zone = "feet"; break;
    case 20: zone = "back"; break;
    }
#ifdef INFORM
    event( environment(), "inform", "picked zone "+ zone,
           "combat" );
#endif
  }
  if(sizeof(_armour_callbacks[ARM_OUTER]) && amount) {
    for(i=0; i<sizeof(_armour_callbacks[ARM_OUTER]); i++) {
      if(!_armour_callbacks[ARM_OUTER][i]->callback[0])
        remove_armour_callback(ARM_OUTER,
                               _armour_callbacks[ARM_OUTER][i]->id);
      else {
        part = call_other(_armour_callbacks[ARM_OUTER][i]->callback[0],
                          _armour_callbacks[ARM_OUTER][i]->callback[1],
                          this_object(),
                          type, amount, zone,
                          _armour_callbacks[ARM_OUTER][i]->data);
        if(part > max) {
          max = part;
          most = stopped;
        }
        total += part;
        amount -= part;
        if(amount < 1)
          break;
      }
    }
  }
  if(zone != "self" && amount > 0) {
    types = CLOTHING_HANDLER->query_clothing_zone( zone );
    if(!types) {
      log_file("ARMOUR_DEBUG", "No types for zone: %s", zone);
      return 0;
    }
    foreach ( word in  types) {
      wearing -= ({ 0 });
      defenses = wearing + filter_array(this_object()->query_holding(),
                                        (: $1 && $1->query_armour() :));
      foreach ( thing in defenses )
        if ( equivalent_armour_types( (mixed)thing->query_type(), word ) ) {
#ifdef INFORM
          event( environment(), "inform", "testing object "+
                 thing->short(), "combat" );
#endif
          part = (int)thing->query_ac( type, amount, zone );
          if (!stopped && part)
            stopped = thing;
          if(part > max) {
            max = part;
            most = stopped;
          }
          total += part;
          amount -= part;
        }
      if (amount < 1)
        break;
    }
  }
  if(sizeof(_armour_callbacks[ARM_INNER]) && amount > 0) {
    for(i=0; i<sizeof(_armour_callbacks[ARM_INNER]); i++) {
      if(!_armour_callbacks[ARM_INNER][i]->callback[0])
        remove_armour_callback(ARM_INNER,
                               _armour_callbacks[ARM_INNER][i]->id);
      else {
        part = call_other(_armour_callbacks[ARM_INNER][i]->callback[0],
                          _armour_callbacks[ARM_INNER][i]->callback[1],
                          this_object(),
                          type, amount, zone,
                          _armour_callbacks[ARM_INNER][i]->data);
        if(part > max) {
          max = part;
          most = stopped;
        }
        total += part;
        amount -= part;
        if(amount < 1)
          break;
      }
    }
  }
  if(amount > 0 && this_object()->query_race_ob() &&
     function_exists("query_ac", load_object(this_object()->query_race_ob()))){
    part = (this_object()->query_race_ob())->query_ac(type, amount, zone);
    if(part > max) {
      max = part;
      most = stopped;
    }
    total += part;
    amount -= part;
  }
  if(amount > 0) {
    if(!stopped && type != "skin")
      stopped = skin;
    if(type == "fire") {
      if(this_object()->effects_matching("body.wetness") &&
         sizeof((int *)this_object()->effects_matching("body.wetness"))) {
        this_object()->add_effect("/std/effects/other/wetness", -amount );
      }
    }
    part = ::query_ac(type, amount, zone);
    if(part > max) {
      max = part;
      most = stopped;
    }
    total += part;
    amount -= part;
  }
  if(amount > 0 && most) {
    stopped = most;
  }
  return total;
}
mixed *stats() {
   return ::stats() + ({
      ({ "skin", skin }),
   });
}

==================================================
FILE: living/carrying.c
==================================================

#include <clothing.h>
#include <money.h>
object* query_wearing();
protected varargs string *query_types_worn( object *things ) {
   int i;
   string *types;
   mixed *stuff;
   types = ({ });
   if ( !things ) {
      things = (object *)this_object()->query_wearing();
   }
   stuff = (mixed *)things->query_type();
   for ( i = sizeof( stuff ) - 1; i > -1; i-- ) {
      if ( stringp( stuff[ i ] ) ) {
         stuff[ i ] = ({ stuff[ i ] });
      }
      if ( !pointerp( stuff[ i ] ) ) {
         printf( "%O (%s) has an invalid type.  Please bug report it.\n",
                 things[ i ], (string)things[ i ]->query_short() );
         stuff[ i ] = ({ "broken" });
      }
      types += stuff[ i ];
   }
   return ({ types, stuff });
}
object* query_wearing_hidden(object looker, object *things) {
   mixed* bing;
   string* types;
   mixed* obj_types;
   object* worn;
   object* ret;
   int i;
   int found_under;
   string fluff;
   string under_type;
   string* under;
   if (!things) {
      worn = query_wearing();
   } else {
      worn = things;
   }
   bing = query_types_worn( worn );
   types = bing[0];
   obj_types = bing[1];
   ret = ({ });
   for (i = 0; i < sizeof(worn); i++) {
      if (worn[i]->query_visible(looker)) {
         found_under = 0;
         foreach (fluff in obj_types[i]) {
            under = CLOTHING_HANDLER->query_clothing_hiding( fluff );
            if ( under && sizeof(under)) {
               foreach (under_type in under) {
                  if (member_array(under_type, types) != -1) {
                     ret += ({ worn[i] });
                     found_under = 1;
                     break;
                  }
               }
            }
            if (found_under) {
               break;
            }
         }
      } else {
         ret += ({ worn[i] });
      }
   }
   return ret;
}
protected string armour_list( object *things, int hidden_only, int self) {
   string word;
   object* hidden;
   hidden = query_wearing_hidden( this_player(), things);
   if (hidden_only) {
      things = filter(hidden, (: $1->query_visible( this_player() ) :));
   } else {
      things = things - hidden;
   }
   if ( !sizeof( things ) ) {
      return 0;
   }
   if (!self) {
      things = sort_array(things,
               (: CLOTHING_HANDLER->query_clothing_depth($2->query_type())  -
                  CLOTHING_HANDLER->query_clothing_depth($1->query_type()) :));
   }
   word = query_multiple_short( things );
   return word;
}
string query_living_contents( int self ) {
   string s;
   string fish;
   string *limbs;
   string *bits;
   string *strs;
   object *holding;
   object *arms;
   object *carry;
   object *conts;
   object money;
   object ob;
   int i;
   int coins;
   int pos;
   s = "";
   strs = ({ });
   conts = ({ });
   limbs = this_object()->query_limbs();
   if (!limbs) {
      limbs = ( this_object()->query_race_ob() )->query_limbs();
   }
   conts = filter(all_inventory(), (: $1->short(0) :) );
   if(!limbs || !sizeof(limbs))
     holding = ({ });
   else
     holding = (object *)this_object()->query_holding() + ({ });
   arms = (object *)this_object()->query_armours() - holding;
   money = present(MONEY_ALIAS, this_object());
   if(!arms) {
      arms = ({ });
   }
   carry = conts - arms - holding - ({ money });
   for (i = 0; i < sizeof(holding); i++) {
     if (holding[i] && environment(holding[i]) == this_object()) {
       bits = ({ limbs[i] });
       ob = holding[i];
       holding[i] = 0;
       while ((pos = member_array(ob, holding)) != -1) {
         bits += ({ limbs[pos] });
         holding[pos] = 0;
       }
       strs += ({  ob->a_short() + " (" +
                     query_multiple_short(bits, "a", 1)+")" });
     }
   }
   if (sizeof(strs)) {
      s += "$I$+10,+0=%^RED%^Holding%^RESET%^ : " +
         query_multiple_short( strs ) +
         ".\n$I$-10,-0=";
   }
   if ( sizeof( arms ) ) {
      if ( fish = armour_list( arms, 0, self) ) {
         s += "$I$+10,+0=%^YELLOW%^Wearing%^RESET%^ : " + fish +
            ".\n$I$-10,-0=";
      }
      if ( self && (fish = armour_list(arms, 1, self) ) ) {
         s += "$I$+10,+0=%^YELLOW%^(under)%^RESET%^ : " + fish +
            ".\n$I$-10,-0=";
      }
   }
   if ( sizeof( carry ) ) {
      fish = this_object()->query_contents(0, carry, 1);
      if ( fish ) {
         if (pointerp(fish)) {
            s += "$I$+10,+0=%^GREEN%^" + fish[1] + "%^RESET%^: " + fish[0] +
               "$I$-10,-0=";
         } else {
            s += "$I$+10,+0=%^GREEN%^Carrying%^RESET%^: " + fish +
               "$I$-10,-0=";
         }
      }
   }
   if ( self && environment() &&
        this_object()->check_dark(environment()->query_light()) > -1) {
      if ( money ) {
         fish = query_multiple_short( (string *)money->half_short( 1 ) );
      } else {
         fish = 0;
      }
      if ( s == "" ) {
         s = "You are empty handed.\n";
      }
      s += "Your purse contains " + (fish?fish:"only moths") + ".\n";
   } else if(money) {
      coins = (int)money->query_number_coins();
      if (self) {
         s += "Your purse is ";
      } else {
         s += capitalize( (string)this_object()->query_possessive() ) +
              " purse is ";
      }
      switch(coins) {
      case 0..10:
         s += "home to only moths!\n";
         break;
      case 11..100:
         s += "tinkling with coins.\n";
         break;
      case 101..300:
         s += "bulging with coins.\n";
         break;
      default:
         s += "fit to burst!\n";
         break;
      }
   }
   return s;
}

==================================================
FILE: living/combat.c
==================================================

inherit "/std/living/corpse";
inherit "/std/weapon_logic";
#include <attack_messages.h>
#include <tasks.h>
#include <player.h>
#include <living.h>
#include <weapon.h>
#ifdef COMBAT_SPEED
#undef COMBAT_SPEED
#endif
#include <combat.h>
#ifdef ABS
#undef ABS
#endif
#define ABS(n) (n) < 0 ? -(n) : (n)
#define DEBUG 1
#undef USE_SURRENDER
class tactics _tactics;
#ifdef USE_SURRENDER
class surrender_information _surrender;
#endif
nosave class combat_information _combat;
nosave string tmpzone;
nosave int _callout;
object *query_attacker_list();
void stop_all_fight();
int query_distance(object);
int set_distance(object, int);
void adjust_action_defecit(int amount);
private void init_tactics();
#ifdef USE_SURRENDER
object *query_surrenderers();
#endif
void create() {
  ::create();
  init_tactics();
  _combat = new(class combat_information,
                in_combat : 0,
                protectors : ({ }),
                defenders : ({ }),
                attacker_list : ([ ]),
                hunting_list : ([ ]),
                specials : ({ })
                );
#ifdef USE_SURRENDER
  _surrender = new(class surrender_information,
                   to : ({ }),
                   from : ({ }),
                   refusers : ({ }));
#endif
}
private void init_tactics() {
  if(!classp(_tactics) || sizeof(_tactics) != 8) {
    _tactics = new(class tactics,
                   attitude : "neutral",
                   response : "neutral",
                   parry : "both",
                   attack : "both",
                   parry_unarmed : 0,
                   mercy : "ask",
                   focus_zone : 0,
                   ideal_distance : 0);
  }
}
#ifdef DEBUG
class combat_information query_combat() { return _combat; }
#ifdef USE_SURRENDER
class surrender_information query_surrender() { return _surrender; }
#endif
#endif
void combat_debug(string fmt, mixed args ...) {
  if(userp(this_object()))
    this_object()->event_inform(this_object(),
                                sprintf("%s " + fmt,
                                        this_object()->query_name(), args ...),
                                      "combat-debug", this_object());
  event(environment(this_object()), "inform",
        sprintf("%s " + fmt, this_object()->query_name(), args ...),
        "combat-debug", this_object());
}
int query_can_attack() {
  if(this_object()->query_property(PASSED_OUT) ||
     this_object()->query_property("dead") ||
     this_object()->query_auto_loading() ||
     this_object()->query_hp() < 0 ||
     this_object()->query_casting_spell() ||
     (userp(this_object()) && !interactive(this_object())) ||
     this_object()->query_property("cannot attack"))
    return 0;
  return 1;
}
int query_can_defend() {
  if(this_object()->query_property(PASSED_OUT) ||
     this_object()->query_property("dead") ||
     this_object()->query_auto_loading() ||
     this_object()->query_hp() < 0 ||
     this_object()->query_casting_spell() ||
     (userp(this_object()) && !interactive(this_object())) ||
     this_object()->query_property("cannot defend"))
    return 0;
  return 1;
}
protected class attack choose_opponent(class attack att) {
  mixed *opponents, opponent;
  int i;
#ifdef USE_DISTANCE
  mixed tmp;
#endif
  opponents = map(keys(_combat->attacker_list),
                  (: $1 && objectp($1) ? $1 : find_player($1) :));
  opponents = filter(opponents, (: $1 && environment($1) == environment($2) &&
                                 $1->query_attackable() :), att->attacker);
#ifdef USE_SURRENDER
  foreach(opponent in query_surrenderers()) {
    if(userp(opponent))
      opponent = opponent->query_name();
    opponents -= ({ opponent });
  }
#endif
  if(!sizeof(opponents))
    return att;
  if(interactive(this_object()) &&
     objectp(att->attacker_concentrating) &&
     member_array(att->attacker_concentrating, opponents) != -1)
    opponent = att->attacker_concentrating;
  else {
#ifdef USE_DISTANCE
    opponent = opponents[0];
    foreach(tmp in opponents)
      if(_combat->attacker_list[tmp] < _combat->attacker_list[opponent])
        opponent = tmp;
#endif
    switch(random(3)) {
    case 2:
      opponent = opponents[0];
      for(i=0; i<sizeof(opponents); i++)
        if((opponent->query_hp() / 10 + random(100)) >
           (opponents[i]->query_hp() / 10 + random(100)))
          opponent = opponents[i];
      break;
    case 1:
      opponent = opponents[0];
      for(i=0; i<sizeof(opponents); i++)
        if((opponent->query_hp() / 10 + random(100)) <
           (opponents[i]->query_hp() / 10 + random(100)))
          opponent = opponents[i];
      break;
    default:
      opponent = opponents[random(sizeof(opponents))];
    }
  }
#ifdef USE_DISTANCE
  att->distance = _combat->attacker_list[opponent];
#endif
  if(stringp(opponent))
    att->opponent = find_player(opponent);
  else
    att->opponent = opponent;
  if(environment(att->opponent) != environment(this_object()))
    return att;
  if(sizeof(opponents) == 1)
    _combat->concentrating = att->opponent;
  return att;
}
void clear_protection(object attacker, object protector) {
  if(attacker->remove_protector(protector))
    protector->event_combat(protector,
                            "You stop protecting "+ attacker->the_short() +
                            " as "+ attacker->query_pronoun() +
                            " moves to attack "+
                            "you!\n", ({ }), 0);
  if(attacker->remove_defender(protector))
    protector->event_combat(protector, "You stop defending "+
                            attacker->the_short() + " as "+
                            attacker->query_pronoun() +" moves to attack "+
                            "you!\n", ({ }), 0);
}
class attack choose_defender(class attack att) {
  object *protectors, *defenders;
  if(!att->person_hit) {
    protectors = filter((att->opponent)->query_protectors(),
                        (: $1 && environment($1) == environment($2) &&
                         $1->query_protect() && !pk_check($1, $2) :),
                        att->attacker);
    if(sizeof(protectors)) {
      protectors->attack_by(att->attacker);
      att->person_hit = protectors[random(sizeof(protectors))];
#if DEBUG == 1
      combat_debug("picked %s to protect", (att->person_hit)->query_name());
#endif
    }
  }
  if(!att->defender) {
    defenders = filter((att->opponent)->query_defenders(),
                       (: $1 && environment($1) == environment($2) &&
                        !pk_check($1, $2) :), att->attacker);
    if(sizeof(defenders)) {
      defenders->attack_by(att->attacker);
      defenders = filter(defenders, (: $1->query_defend() :));
    }
    if(sizeof(defenders)) {
      att->defender = defenders[random(sizeof(defenders))];
#if DEBUG == 1
      combat_debug("picked %s to defend", (att->defender)->query_name());
#endif
    }
  }
  if(!att->person_hit)
    att->person_hit = att->opponent;
  if(!att->defender)
    att->defender = att->opponent;
  return att;
}
int query_attackable() {
  if(this_object()->query_property(PASSED_OUT) ||
     this_object()->dont_attack_me() ||
     this_object()->attack_inhibit() ||
     this_object()->query_property("dead") ||
     this_object()->query_auto_loading() ||
     this_object()->query_hp() < 0 ||
     (userp(this_object()) && !interactive(this_object())))
    return 0;
  return 1;
}
int query_defend() {
  if(!query_attackable() || this_object()->query_casting_spell() ||
     this_object()->query_specific_gp("fighting") < 1)
    return 0;
  return ((_tactics->response == "parry" || _tactics->response == "both") &&
          _combat->action_defecit < (COMBAT_ACTION_TIME * 4));
}
int query_protect() {
  if(!query_attackable() || this_object()->query_casting_spell() ||
     this_object()->query_specific_gp("fighting") < 1)
    return 0;
  return (_combat->action_defecit < (COMBAT_ACTION_TIME * 4));
}
protected class attack choose_attack(class attack att) {
  object weapon, *weapons;
  string hand, *tmp;
  int perc, which_attack, i;
  class tactics tactics;
  mixed *attacks;
  string zone;
  float sz;
  tactics = att->attacker_tactics;
  if(!this_object()->query_can_attack())
    return att;
  if(!OFFENSIVE_DEFECITS[tactics->attitude])
    tactics->attitude = "neutral";
  if(att->attacker_defecit > OFFENSIVE_DEFECITS[tactics->attitude])
    return att;
  weapons = (att->attacker)->query_holding();
  tmp = (att->attacker)->query_limbs();
  hand = (att->attacker_tactics)->attack;
  if(hand && hand != "both") {
    for(i=0; i<sizeof(tmp); i++)
      if(tmp[i] == hand + " hand")
        break;
    if(!weapons[i])
      weapons = ({ });
    else if(weapons[i]->query_weapon())
      weapons = ({ weapons[i] });
  }
  if(sizeof(weapons) > 1)
    weapons = uniq_array(filter(weapons, (: $1 && $1->query_weapon() :)));
  switch(sizeof(weapons)) {
  case 0:
    weapon = att->attacker;
    break;
  case 1:
    weapon = weapons[0];
    break;
  default:
#ifdef USE_DISTANCE
    weapon = weapons[0];
    foreach(wtmp in weapons)
      if(ABS(REACH + weapon->query_length() - att->distance) >
         ABS(REACH + wtmp->query_length() - att->distance))
        weapon = wtmp;
#else
    weapon = weapons[random(sizeof(weapons))];
#endif
  }
  att->attack_weapon = weapon;
  perc = 75 + (att->attacker)->query_str() + (att->attacker)->query_dex();
  if(weapon != att->attacker)
    perc -= weapon->query_weight() / 2;
  if(perc < 25)
    perc = 25;
  attacks = weapon->weapon_attacks(perc, att->defender);
  if(!sizeof(attacks)) {
#if DEBUG == 2
    combat_debug("No attacks with %O, terminating [%d, %O].", weapon,
                 perc, att->defender);
#endif
    return att;
  }
  which_attack = random(sizeof(attacks) / AT_ARRAY_SIZE);
  attacks = attacks[(which_attack * AT_ARRAY_SIZE)..];
  if(attacks[AT_NAME] == "hands" && !(att->attacker)->query_free_limbs())
    return att;
  att->attack_data = attacks;
  att->attack_skill = ATTACK_SKILL + attacks[AT_SKILL];
  if((att->attacker_tactics)->focus_zone == "upper body") {
    tmp = ((att->opponent)->query_race_ob())->query_target_zones();
    zone = tmp[random(sizeof(tmp) / 2)];
  } else  if((att->attacker_tactics)->focus_zone == "lower body") {
    zone = tmp[random(sizeof(tmp) / 2) + sizeof(tmp)/2];
  } else if((att->attacker_tactics)->focus_zone &&
     (att->attacker_tactics)->focus_zone != "none") {
    zone = (att->attacker_tactics)->focus_zone;
    zone = ((att->opponent)->query_race_ob())->map_target_zone(zone);
    att->target_zone = zone;
  } else {
    if(att->attack_data[AT_SKILL] == "unarmed") {
      if(att->attack_data[AT_NAME] == "hands")
        sz = ((att->attacker)->query_height() * 2) /
          (att->opponent)->query_height();
      else if(att->attack_data[AT_NAME] == "feet")
        sz = ((att->attacker)->query_height() / 2) /
          (att->opponent)->query_height();
    } else
      sz = to_float((att->attacker)->query_height()) /
        to_float((att->opponent)->query_height());
    tmp = ((att->opponent)->query_race_ob())->query_target_zones();
    if(sizeof(tmp)) {
      if(sz > 1.5)
        zone = tmp[random(random(sizeof(tmp)))];
      if(sz < 0.75) {
        i = random(sizeof(tmp) + 10);
        if(i > sizeof(tmp)-1)
          i = sizeof(tmp) - 1;
        zone = tmp[i];
      } else {
        zone = tmp[random(sizeof(tmp))];
      }
    }
  }
  att->target_zone = zone;
  return att;
}
class attack choose_defense(class attack att) {
  object defender;
  string response, *hands, hand;
  object *weapons;
  class tactics tactics;
  int i, which;
#ifdef USE_DISTANCE
  int move_cost;
#endif
  defender = att->defender;
  att->defense_action = "none";
  att->defense_skill = DODGE;
  att->defense_weapon = 0;
  tactics = att->defender_tactics;
  if(defender == att->opponent) {
    if(!defender->query_can_defend())
      return att;
    if(!DEFENSIVE_DEFECITS[tactics->attitude])
      tactics->attitude = "neutral";
    if(att->defender_defecit > DEFENSIVE_DEFECITS[tactics->attitude])
      return att;
  }
#ifdef USE_DISTANCE
  else if(att->distance != defender->query_distance(att->attacker) &&
            ABS(defender->query_distance(att->attacker)) >
            MOVE_DISTANCE[tactics->attitude]) {
    defender->set_distance(att->attacker, att->distance);
    move_cost = MOVE_COST;
    move_cost -= defender->query_skill_bonus(MOVE_SKILL) / 50;
    if(move_cost < 0)
      move_cost = 0;
    (att->opponent)->event_combat(att->opponent, defender->one_short() +
                                  " moves to " +
                                  (att->person_hit == defender ?
                                   "protect" : "defend" ) + " you.\n",
                                  ({ }), 0);
    defender->event_combat(defender, "You move to " +
                           (att->person_hit == defender ?
                            "protect" : "defend") + " " +
                           (att->opponent)->one_short() + ".\n",
                           ({ }), 0);
    event(environment(att->opponent), "combat", defender->one_short() +
          " moves to " + (att->person_hit == defender ? "protect" : "defend") +
          " " + (att->opponent)->one_short() + ".\n",
          ({ att->opponent, defender, att->person_hit }), 1);
  }
#endif
  response = tactics->response;
  if(defender != att->opponent) {
    if(response == "dodge")
      return att;
    response = "parry";
  } else if(!response || response == "neutral")
    response = ({"parry", "dodge"})[random(2)];
  if(response == "parry") {
    weapons = (object *)defender->query_holding();
    hand = (att->defender_tactics)->parry;
    which = -1;
    hands = (att->defender)->query_limbs();
    for(i=0; i<sizeof(hands); i++)
      if(hands[i][0..sizeof(hand)-1] == hand)
        which = i;
    if(which != -1) {
      if(weapons[which]) {
        att->defense_action = "parry";
        att->defense_skill = WEAPON_PARRY;
        att->defense_weapon = weapons[which];
      } else if((att->defender_tactics)->parry_unarmed) {
        att->defense_action = "parry";
        att->defense_skill = UNARMED_PARRY;
        att->defense_weapon = att->defender;
        att->defense_limb = (att->defender)->query_limbs()[which];
      }
    } else {
      weapons -= ({ 0 });
      if(!sizeof(weapons)) {
        if((att->defender_tactics)->parry_unarmed) {
          att->defense_action = "parry";
          att->defense_skill = UNARMED_PARRY;
          att->defense_weapon = att->defender;
        }
      } else {
        att->defense_action = "parry";
        att->defense_skill = WEAPON_PARRY;
        att->defense_weapon = weapons[random(sizeof(weapons))];
      }
    }
  } else {
    att->defense_action = "dodge";
    att->defense_skill = DODGE;
    att->defense_weapon = 0;
  }
  return att;
}
protected class attack calc_attack_modifier(class attack att) {
  object attacker, attack_weapon, *holding;
  int mod, wep, hld, lght, mntd, hlth, brdn, dist, tact, targ, oth;
  int tmp, tmp2, limbs, dex, num, actions;
  string zone, *attackers;
  attacker = att->attacker;
  dex = attacker->query_dex();
  attack_weapon = att->attack_weapon;
  mod = wep = hld = lght = mntd = hlth = brdn = dist = tact = 0;
  if(attack_weapon != attacker) {
    holding = attacker->query_holding();
    limbs = tmp2 = 0;
    for(num = 0; num < sizeof(holding); num++) {
      if(holding[num] == attack_weapon)
        limbs++;
      else if(holding[num]) {
        if((holding[num])->id("shield"))
          tmp2 += (holding[num])->query_weight() / 5;
        else
          tmp2 += (holding[num])->query_weight();
      }
    }
    switch((att->attacker_tactics)->response) {
    case "both":
      tmp2 = (tmp2 * 3) / 2;
      break;
    case "dodge":
      if(tmp2 < dex)
        tmp2 /= 2;
    }
    wep = attack_weapon->query_weight() + (tmp2 / 2);
    wep /= (limbs + 1);
    wep -= (att->attacker)->query_str();
    if(wep > 0 ) {
      wep = - to_int(pow(wep, 1.4));
    } else
      wep = 0;
    if(dex < 14 && sizeof(holding) && holding[0] != attack_weapon)
      hld = dex - 14;
  } else {
    wep =  (dex * 2) - attacker->query_burden();
  }
  switch(attacker->check_dark(environment(attacker)->query_light())) {
  case -2:
  case 2:
    lght = -50;
    break;
  case -1:
  case 1:
    lght = -25;
    break;
  }
  mntd = 0;
  hlth -= (50 - (attacker->query_hp() * 50) / attacker->query_max_hp());
  tmp = attacker->query_specific_gp("fighting");
  if(tmp < -50)
    hlth += -25;
  else if(tmp < 0)
    hlth += (tmp / 2);
  brdn -= (attacker->query_burden() / 3);
#ifdef USE_DISTANCE
  if(att->attack_weapon == att->attacker)
    dist = -3 * ABS(REACH - att->distance);
  else
    dist = -3 * ABS(REACH + (att->attack_weapon)->query_length() -
                    att->distance);
#endif
  switch((att->attacker_tactics)->attitude) {
  case "insane":
    tact = 25;
    break;
  case "offensive":
    tact = 15;
    break;
  case "defensive":
    tact = -25;
    break;
  case "wimp":
    tact = -50;
    break;
  }
  switch(att->attacker_tactics->focus_zone) {
  case 0:
  case "none":
    targ = 0;
    break;
  case "upper body":
  case "lower body":
    targ -= 25;
    break;
  default:
    tmp = 0;
    foreach(zone in ((att->opponent)->query_race_ob())->query_target_zones())
      if(zone == att->target_zone)
        tmp++;
    num = sizeof(((att->opponent)->query_race_ob())->query_target_zones());
    targ -= ((num - tmp) * 25 / num);
  }
  if(targ < -25) {
    debug_printf("Targ too small (%s) %d. num: %d, tmp: %d\n",
                 (att->attacker_tactics)->focus_zone, targ, num,tmp);
    targ = -25;
  }
  attackers = filter((att->opponent)->query_attacker_list(),
                     (: $1 && environment($1) == environment(this_object()):));
  num = member_array(this_object(), attackers);
  if(num > 1)
    num += -25 * num;
  if((att->attacker_tactics)->attack == "both")
    oth += 5;
  mod = wep + hld + lght + mntd + hlth + brdn + dist + tact + targ + oth + num;
  att->attack_modifier += mod;
  actions += ATTACK_COST;
  if(attack_weapon != att->attacker)
    actions += (sqrt(attack_weapon->query_weight()) * 3) / (limbs + 1);
  if(sizeof((att->attacker)->query_weapons()) > 1)
    actions -= ATTACK_COST / 4;
  actions -= ((att->attacker)->query_skill_bonus(att->attack_skill) +
              (att->attacker)->query_skill_bonus(TACTICAL_SKILL)) / 50;
  if(actions < ATTACK_COST / 5)
    actions = ATTACK_COST / 5;
  else if(actions > ATTACK_COST * 2)
    actions = ATTACK_COST * 2;
  att->attack_cost = actions;
#if DEBUG == 1
  combat_debug("Attack %s (%s): wep: %d hld: %d lght: %d mntd: %d "
               "hlth: %d brdn: %d dist: %d tact: %d targ: %d oth: %d "
               "num: %d = %d [%d] (actions: %d %d)",
               att->attack_data[AT_NAME],
               (att->attack_weapon)->query_name(),
               wep, hld, lght, mntd, hlth, brdn, dist, tact, targ, oth, num,
               mod, att->attack_modifier, actions, att->attacker_defecit);
#endif
  return att;
}
class attack calc_defense_modifier(class attack att) {
  object defender, attacker, attack_weapon, defense_weapon, *holding;
  int mod, wep, wght, dist, brdn, hnd, lght, hlth, tact, prot, oth;
  int tmp, num, dex, limbs, actions;
  mod = wep = wght = dist = brdn = hnd = lght = hlth = tact = prot = oth = 0;
  defender = att->defender;
  defense_weapon = att->defense_weapon;
  dex = defender->query_dex();
  attacker = att->attacker;
  attack_weapon = att->attack_weapon;
  switch(att->defense_action) {
  case "parry":
    if(defense_weapon != defender && defense_weapon) {
      holding = defender->query_holding();
      if(defense_weapon->id("shield"))
        wep = defense_weapon->query_weight() / 5;
      else
        wep = defense_weapon->query_weight() * 2;
      limbs = 0;
      for(num = 0; num < sizeof(holding); num++)
        if(holding[num] && holding[num] == defense_weapon)
          limbs++;
      wep /= (limbs + 2);
      if(wep > defender->query_str())
        wep = - to_int(pow(wep - defender->query_str(), 1.3));
      if(attack_weapon != attacker)
        wght = 2 * (defense_weapon->query_weight() -
                    attack_weapon->query_weight());
      else
        wght = defense_weapon->query_weight() / 2;
      if(wght > 5)
        wght = 5;
#ifdef USE_DISTANCE
      dist = - ABS(REACH + defense_weapon->query_length() - att->distance);
#endif
    } else {
#ifdef USE_DISTANCE
      dist = - ABS(REACH - att->distance);
#endif
    }
    brdn = -(defender->query_burden() / 3);
    if(sizeof(holding)) {
      if(dex < 14 && holding[0] != defense_weapon)
        hnd = dex - 14;
      holding = uniq_array(filter(holding, (: $1 :)));
      if(dex  < 16 && sizeof(holding) == 1)
        hnd += dex - 16;
    }
    break;
  case "dodge":
    brdn = -(defender->query_burden() / 3);
    if(dex < (defender->query_burden() / 2))
      brdn -= dex - (defender->query_burden() / 2);
    if(att->attack_weapon != att->attacker)
      wght = ((att->attack_weapon)->query_weight() / 10);
    break;
  }
  if(!(att->attacker)->query_visible(defender))
    lght = -100;
  else {
    switch(defender->check_dark(environment(defender)->query_light())) {
    case -2:
    case 2:
      lght = -50;
      break;
    case -1:
    case 1:
      lght = -25;
      break;
    }
  }
  hlth = - (25 - (defender->query_hp() * 25) / defender->query_max_hp());
  tmp = defender->query_specific_gp("fighting");
  if(tmp < -50)
    hlth += -25;
  else if(tmp < 0)
    hlth += (tmp / 2);
  switch((att->defender_tactics)->attitude) {
  case "insane":
    tact = -50;
    break;
  case "offensive":
    tact = -25;
    break;
  case "defensive":
    tact = 15;
    break;
  case "wimp":
    tact = 25;
    break;
  }
  prot = 0;
  if(defender != att->opponent) {
    if(defender != att->person_hit) {
      if(defense_weapon->id("shield"))
        prot -= 15;
      prot -= 15;
    }
    prot -= 15;
  }
  if((att->defender_tactics)->response == "both")
    oth += 5;
  if(defender->query_casting_spell())
    oth -= 25;
  mod = wep + wght + dist + brdn + hnd + lght + hlth + tact + prot + oth;
  att->defense_modifier += mod;
  if(att->defense_action != "none") {
    actions = DEFENSE_COST;
    actions -= ((att->defender)->query_skill_bonus(att->defense_skill) +
      (att->attacker)->query_skill_bonus(TACTICAL_SKILL)) / 50;
    if(att->defense_weapon && att->defense_weapon != att->defender) {
      if((att->defense_weapon)->id("shield"))
        actions += sqrt(att->defense_weapon->query_weight() / 4);
      else {
        actions += sqrt((att->defense_weapon->query_weight() * 2) /
                        (limbs + 1));
        if(sizeof((att->defender)->query_weapons()) > 1)
          actions -= DEFENSE_COST / 4;
      }
    } else if(att->defense_action == "dodge")
      actions += sqrt(defender->query_burden());
    if(actions < DEFENSE_COST / 5)
      actions = DEFENSE_COST / 5;
    else if(actions > DEFENSE_COST * 2)
      actions = DEFENSE_COST * 2;
    att->defense_cost = actions;
  }
#if DEBUG == 1
  combat_debug("Defense %s (%s): wep: %d wght: %d dist: %d "
               "brdn: %d hnd: %d lght: %d hlth: %d tact: %d prot: %d "
               "oth: %d = %d [%d] (actions: %d %d)",
               att->defense_action,
               att->defense_weapon ? (att->defense_weapon)->query_name() : "",
               wep, wght, dist, brdn, hnd, lght, hlth, tact, prot, oth,
               mod, att->defense_modifier, actions, att->defender_defecit);
#endif
  return att;
}
protected class attack calc_damage(class attack att) {
  int damage, weapon_damage;
  object attacker;
  attacker = att->attacker;
  damage = att->attack_data[AT_DAMAGE];
  weapon_damage = damage;
  if(att->attack_weapon != attacker)
    damage = sqrt(damage * attacker->query_skill_bonus(att->attack_skill));
  if(damage > 3 * weapon_damage)
    damage = 3 * weapon_damage;
  damage *= COMBAT_SPEED;
  att->damage = damage;
  switch(att->result) {
  case OFFAWARD:
  case OFFWIN:
    switch(att->degree) {
    case TASKER_CRITICAL:
      att->damage *= 2;
      break;
    case TASKER_EXCEPTIONAL:
      att->damage = (att->damage * 3) / 2;
    case TASKER_MARGINAL:
      att->damage /= 2;
      break;
    }
    break;
  case DEFAWARD:
  case DEFWIN:
    switch(att->degree) {
    case TASKER_CRITICAL:
      att->defense_cost = 0;
      break;
    case TASKER_EXCEPTIONAL:
      att->defense_cost /= 2;
      break;
    case TASKER_MARGINAL:
      att->defense_cost *= 2;
      break;
    }
    att->damage = 0;
  }
  combat_debug("Damage: %d %d",
               att->damage,
               attacker->query_skill_bonus(att->attack_skill));
  return att;
}
class attack calc_armour_protection(class attack att) {
  object person_hit;
  string armour_zone, damage_type;
  if(!att->damage || (att->result != OFFWIN && att->result != OFFAWARD))
    return att;
  person_hit = att->person_hit;
  armour_zone = (person_hit->query_race_ob())->
    map_armour_zone(att->target_zone);
  damage_type = att->attack_data[AT_TYPE];
  if(damage_type == "unarmed")
    damage_type = "blunt";
  att->armour_stopped = (int)person_hit->query_ac(damage_type, att->damage,
                                                  armour_zone);
  if(att->armour_stopped < 0) {
    debug_printf("armour stopped %d for %s %d %s",
                 att->armour_stopped, damage_type, att->damage, armour_zone);
    att->armour_stopped = 0;
  }
  return att;
}
protected class attack damage_weapon(class attack att) {
  int off_damage, def_damage;
  switch(att->result) {
  case OFFAWARD:
  case OFFWIN:
    if(att->armour_stopped && att->degree)
      off_damage = att->armour_stopped / att->degree;
    break;
  case DEFWIN:
  case DEFAWARD:
    if(att->defense_action == "parry" && att->damage && att->degree) {
      off_damage = att->damage * (att->degree - 1);
      def_damage = att->damage / att->degree;
    }
    break;
  }
  if(off_damage) {
    if(att->attack_weapon == att->attacker)
      if((att->attack_weapon)->query_hp() > (off_damage / 10))
        (att->attack_weapon)->adjust_hp(- (off_damage / 10), att->defender,
                                        att->defense_weapon,
                                        "hitting someone.");
    else if(function_exists("hit_weapon", att->attack_weapon))
      (att->attack_weapon)->hit_weapon(off_damage, att->attack_data[AT_SKILL]);
    else
      (att->attack_weapon)->do_damage(att->attack_data[AT_SKILL], off_damage);
  }
  if(def_damage) {
    if(att->defense_weapon == att->defender)
      (att->defense_weapon)->adjust_hp(- def_damage, att->attacker,
                                       att->attack_weapon,
                                       "parrying an attack with a limb.");
    else if(function_exists("hit_weapon", att->defense_weapon))
      (att->defense_weapon)->hit_weapon(def_damage,
                                        att->attack_data[AT_SKILL]);
    else
      (att->defense_weapon)->do_damage(att->attack_data[AT_SKILL], def_damage);
  }
  return att;
}
protected class attack prepare_messages(class attack att) {
  object attacker, opponent, defender, person_hit;
  string *verb, def_short, margin;
  string *def_mess, *att_mess;
  int damage, armour_stopped;
  attacker = att->attacker;
  opponent = att->opponent;
  defender = att->defender;
  person_hit = att->person_hit;
  damage = att->damage;
  armour_stopped = att->armour_stopped;
  switch(att->result) {
  case OFFAWARD:
    tell_object(att->attacker,
                "%^YELLOW%^"+ replace(({ "You feel "
                "that your skill with $weapon$ has increased.", "You "
                "feel more able to use $weapon$.", "You seem to be a "
                "step closer to mastering $weapon$." })[random(3)],
                "$weapon$", (att->attack_weapon == att->attacker ?
                "unarmed combat" : (string)(att->attack_weapon)->a_short())) +
                "%^RESET%^\n" );
  case OFFWIN:
    if(person_hit == opponent) {
      att_mess = ATTACK_MESSAGE->query_message(damage - armour_stopped,
                                               att->attack_data[AT_SKILL],
                                               opponent, attacker,
                                               att->attack_data[AT_NAME],
                                               att->attack_weapon,
                                               att->target_zone);
      if(sizeof(att_mess) != 3) {
        att_mess = ({"You hit "+opponent->the_short()+"",
                       attacker->the_short()+" hits you",
                       attacker->the_short()+" hits "+opponent->the_short()});
      }
      att_mess += ({ att_mess[M_SPECTATORS], att_mess[M_SPECTATORS] });
    } else {
      att_mess = ATTACK_MESSAGE->query_message(damage - armour_stopped,
                                               att->attack_data[AT_SKILL],
                                               opponent, attacker,
                                               att->attack_data[AT_NAME],
                                               att->attack_weapon,
                                               att->target_zone);
      if(sizeof(att_mess) != 3) {
        att_mess = ({"You almost hit "+opponent->the_short()+"",
                       attacker->the_short()+" almost hits you",
                       attacker->the_short()+" almost hits "+
                       opponent->the_short()});
      }
      att_mess += ({ att_mess[M_SPECTATORS], att_mess[M_SPECTATORS] });
      att_mess[M_ATTACKER] += " but at the last second " +
        person_hit->the_short() + " leaps in and protects " +
        opponent->query_objective();
      att_mess[M_OPPONENT] += " but at the last second " +
        person_hit->the_short() + " leaps in and protects you";
      att_mess[M_SPECTATORS] += " but at the last second " +
        person_hit->the_short() + " leaps in and protects " +
        opponent->query_objective();
      if(defender == person_hit)
        att_mess[M_DEFENDER] += " but at the last second " +
          person_hit->the_short() + " leap in and protect " +
          opponent->query_objective();
      else
        att_mess[M_DEFENDER] += " but at the last second " +
          person_hit->the_short() + " leaps in and protects " +
          opponent->query_objective();
      att_mess[M_PERSON_HIT] += " but at the last second you leap in and "
        "protect " + opponent->query_objective();
    }
    break;
  case DEFAWARD:
  case DEFWIN:
    att_mess = ATTACK_MESSAGE->query_message(0,
                                             att->attack_data[AT_SKILL],
                                             opponent, attacker,
                                             att->attack_data[AT_NAME],
                                             att->attack_weapon,
                                             att->target_zone);
    if(sizeof(att_mess) != 3) {
      att_mess = ({"You try to hit "+opponent->the_short()+"",
                     attacker->the_short()+" tries to hit you",
                     attacker->the_short()+" tries to hit "+
                     opponent->the_short()});
    }
    att_mess += ({ att_mess[M_SPECTATORS], att_mess[M_SPECTATORS] });
    break;
  }
  def_mess = allocate(5);
  def_mess[M_ATTACKER] = def_mess[M_OPPONENT] = def_mess[M_SPECTATORS] =
    def_mess[M_DEFENDER] = def_mess[M_PERSON_HIT] = "";
  switch(att->result) {
  case OFFAWARD:
  case OFFWIN:
    if(armour_stopped && armour_stopped > damage / 3) {
      if(objectp(att->stopped_by)) {
        def_mess[M_ATTACKER] = " but " + (att->stopped_by)->poss_short();
        def_mess[M_OPPONENT] = def_mess[M_ATTACKER];
        def_mess[M_SPECTATORS] = def_mess[M_ATTACKER];
        def_mess[M_DEFENDER] = def_mess[M_ATTACKER];
        def_mess[M_PERSON_HIT] = def_mess[M_ATTACKER];
      } else if(att->stopped_by) {
        def_mess[M_ATTACKER] = " but " + person_hit->query_possessive() +
          " " + att->stopped_by;
        if(person_hit == opponent)
          def_mess[M_OPPONENT] = " but your " + att->stopped_by;
        else
          def_mess[M_OPPONENT] = def_mess[M_ATTACKER];
        def_mess[M_SPECTATORS] = def_mess[M_ATTACKER];
        if(person_hit == defender)
          def_mess[M_DEFENDER] = " but your " + att->stopped_by;
        else
          def_mess[M_DEFENDER] = def_mess[M_ATTACKER];
        def_mess[M_PERSON_HIT] = " but your " + att->stopped_by;
      }
      if(!damage || armour_stopped >= damage) {
        def_mess[M_ATTACKER] += " absorbs all of";
        def_mess[M_OPPONENT] += " absorbs all of";
        def_mess[M_SPECTATORS] += " absorbs all of";
        def_mess[M_DEFENDER] += " absorbs all of";
        def_mess[M_PERSON_HIT] += " absorbs all of";
      } else if(armour_stopped > (damage * 2 / 3)) {
        def_mess[M_ATTACKER] += " absorbs most of";
        def_mess[M_OPPONENT] += " absorbs most of";
        def_mess[M_SPECTATORS] += " absorbs most of";
        def_mess[M_DEFENDER] += " absorbs most of";
        def_mess[M_PERSON_HIT] += " absorbs most of";
      } else {
        def_mess[M_ATTACKER] += " absorbs some of";
        def_mess[M_OPPONENT] += " absorbs some of";
        def_mess[M_SPECTATORS] += " absorbs some of";
        def_mess[M_DEFENDER] += " absorbs some of";
        def_mess[M_PERSON_HIT] += " absorbs some of";
      }
      def_mess[M_ATTACKER] += " the blow";
      def_mess[M_OPPONENT] += " the blow";
      def_mess[M_SPECTATORS] += " the blow";
      def_mess[M_DEFENDER] += " the blow";
      def_mess[M_PERSON_HIT] += " the blow";
    }
    break;
  case DEFAWARD:
    if(att->defense_action == "parry") {
      if(att->defense_weapon && (att->defense_weapon)->query_weapon())
        verb = ({ "parry", "parries", "parrying" });
      else
        verb = ({ "block", "blocks", "blocking" });
      tell_object(att->defender,
                  "%^YELLOW%^"+ replace( ({ "You move more surely "
               "than you thought you could in $verbing$ $attacker$'s attack",
               "You just manage to $verb$ $attacker$'s attack, but you'll "
               "know better next time", "You feel better at $verbing$ as "
               "you $verb$ $attacker$'s attack" })[ random( 3 ) ],
               ({ "$verb$", verb[ 0 ], "$verbing$", verb[ 2 ], "$attacker$",
               (string)(att->attacker)->the_short() }) ) +".%^RESET%^\n" );
    } else if(att->defense_action == "dodge") {
      tell_object(att->defender,
                   "%^YELLOW%^"+ replace( ({ "You move more nimbly "
               "than you thought you could in dodging $attacker$", "You "
               "managed to predict $attacker$'s attack, letting you dodge it "
               "more easily", "You feel better at dodging as you avoid "
               "$attacker$'s attack" })[ random( 3 ) ], "$attacker$",
               (string)(att->attacker)->the_short() ) +".%^RESET%^\n" );
    }
  case DEFWIN:
    def_mess = allocate(5);
    def_mess[M_ATTACKER] = "";
    def_mess[M_OPPONENT] = "";
    def_mess[M_SPECTATORS] = "";
    def_mess[M_DEFENDER] = "";
    def_mess[M_PERSON_HIT] = "";
    switch(att->degree) {
    case TASKER_MARGINAL:
      margin = "just ";
      break;
    case TASKER_EXCEPTIONAL:
      margin = "deftly ";
      break;
    case TASKER_MARGINAL:
      margin = "easily ";
      break;
    default:
      margin = "";
      break;
    }
    if(att->defense_action == "parry" && att->defense_weapon) {
      if(defender == opponent)
        def_mess[M_ATTACKER] = " but " + defender->query_pronoun() + " " +
          margin;
      else
        def_mess[M_ATTACKER] = " but " + defender->the_short() + " " + margin;
      if(defender == opponent)
        def_mess[M_OPPONENT] = " but you " + margin;
      else
        def_mess[M_OPPONENT] = def_mess[M_ATTACKER];
      def_mess[M_SPECTATORS] = def_mess[M_ATTACKER];
      def_mess[M_DEFENDER] = " but you " + margin;
      def_mess[M_PERSON_HIT] = def_mess[M_ATTACKER];
      if(att->defense_weapon != defender &&
         !(att->defense_weapon)->id("shield")) {
        def_mess[M_ATTACKER] += "parries";
        if(defender == opponent)
          def_mess[M_OPPONENT] += "parry";
        else
          def_mess[M_OPPONENT] += "parries";
        def_mess[M_SPECTATORS] += "parries";
        def_mess[M_DEFENDER] += "parry";
        if(att->person_hit == att->defender)
          def_mess[M_PERSON_HIT] += "parry";
        else
          def_mess[M_PERSON_HIT] += "parries";
      } else {
        def_mess[M_ATTACKER] += "blocks";
        if(defender == opponent)
          def_mess[M_OPPONENT] += "block";
        else
          def_mess[M_OPPONENT] += "blocks";
        def_mess[M_SPECTATORS] += "blocks";
        def_mess[M_DEFENDER] += "block";
        if(att->person_hit == att->defender)
          def_mess[M_PERSON_HIT] += "block";
        else
          def_mess[M_PERSON_HIT] += "blocks";
      }
      if(att->defense_weapon != defender) {
        def_short = (att->defense_weapon)->short();
      } else if(att->defense_limb) {
        def_short = att->defense_limb;
      } else
        def_short = (defender->query_race_ob())->map_target_zone("hands");
      def_mess[M_ATTACKER] += " the blow with " +
        defender->query_possessive() + " " + def_short;
      if(defender == opponent)
        def_mess[M_OPPONENT] += " the blow with your " + def_short;
      else
        def_mess[M_OPPONENT] += " the blow with " +
          defender->query_possessive() + " " + def_short;
      def_mess[M_SPECTATORS] += " the blow with " +
        defender->query_possessive() + " " + def_short;
      def_mess[M_DEFENDER] += " the blow with your " + def_short;
      if(defender == person_hit)
        def_mess[M_PERSON_HIT] += " the blow with your " + def_short;
            else
        def_mess[M_PERSON_HIT] += " the blow with " +
          defender->query_possessive() + " " + def_short;
    } else if(att->defense_action == "dodge") {
      def_mess[M_ATTACKER] = " but " + defender->query_pronoun() + " " +
        margin + "dodges out of the way";
      def_mess[M_OPPONENT] = " but you " + margin + "dodge out of the way";
      def_mess[M_SPECTATORS] = " but " + defender->query_pronoun() + " " +
        margin + "dodges out of the way";
    } else {
      def_mess[M_ATTACKER] = " but, although unable to defend, " +
        defender->query_pronoun() + " somehow avoids the attack";
      def_mess[M_OPPONENT] = " but, although unable to defend, you somehow "
        "avoid the attack";
      def_mess[M_SPECTATORS] = " but, although unable to defend, " +
        defender->query_pronoun() + " somehow avoids the attack";
    }
  }
  att->attack_messages = att_mess;
  att->defense_messages = def_mess;
  if(att->result == DEFAWARD || att->result == DEFWIN || !damage ||
     armour_stopped >= damage)
    att->verbose = 1;
  return att;
}
protected class attack write_messages(class attack att) {
  int verbose;
  verbose = att->verbose;
  (att->attacker)->event_combat(att->attacker,
                                att->attack_messages[M_ATTACKER] +
                                att->defense_messages[M_ATTACKER] + ".\n",
                                ({ }), verbose);
  (att->opponent)->event_combat(att->opponent,
                                att->attack_messages[M_OPPONENT] +
                                att->defense_messages[M_OPPONENT] + ".\n",
                                ({ }), verbose);
  if(att->defender != att->opponent &&
     sizeof(att->attack_messages) > M_DEFENDER)
    (att->defender)->event_combat(att->defender,
                                  att->attack_messages[M_DEFENDER] +
                                  att->defense_messages[M_DEFENDER] + ".\n",
                                  ({ }), verbose);
  if(att->person_hit != att->opponent && att->person_hit != att->defender &&
     sizeof(att->attack_messages) > M_PERSON_HIT)
    (att->person_hit)->event_combat(att->person_hit,
                                    att->attack_messages[M_PERSON_HIT] +
                                    att->defense_messages[M_PERSON_HIT] +
                                    ".\n", ({ }), verbose);
  event(environment(att->attacker), "combat",
        att->attack_messages[M_SPECTATORS] +
        att->defense_messages[M_SPECTATORS] + ".\n",
        ({ att->attacker, att->opponent, att->defender, att->person_hit }),
        verbose);
  return att;
}
protected void adjust_actions(class attack att) {
  int tmp;
  if((att->attacker)->query_time_left() > 0)
    (att->attacker)->adjust_time_left(-DEFAULT_TIME);
  (att->attacker)->adjust_action_defecit(att->attack_cost);
  (att->opponent)->adjust_action_defecit(att->defense_cost);
  if(att->defender != att->opponent)
    (att->defender)->adjust_action_defecit(DEFENSE_COST);
  if(att->person_hit != att->opponent)
    (att->person_hit)->adjust_action_defecit(DEFENSE_COST);
  tmp = ATTACK_GP[(att->attacker_tactics)->attitude];
  (att->attacker)->adjust_gp(-tmp);
  if(att->defender != att->opponent) {
    tmp = DEFENDER_GP[(att->defender_tactics)->attitude];
    (att->defender)->adjust_gp(-tmp);
  } else if(att->defense_action != "none") {
    tmp = DEFENSE_GP[(att->defender_tactics)->attitude];
    (att->opponent)->adjust_gp(-tmp);
  }
  if(att->person_hit != att->opponent) {
    tmp = DEFENDER_GP[(att->person_hit)->query_combat_attitude()];
    (att->person_hit)->adjust_gp(-tmp);
  }
}
protected class attack perform_movement(class attack att) {
  int ideal, move_cost, closer;
  ideal = DISTANCES[(att->attacker_tactics)->ideal_distance];
  if(ABS(ideal - att->distance) >
     MOVE_DISTANCE[(att->attacker_tactics)->attitude]) {
    if(att->distance > ideal)
      closer = 1;
    move_cost = MOVE_COST;
    move_cost -= (att->attacker)->query_skill_bonus(MOVE_SKILL) / 30;
    if(move_cost > 0)
      att->attack_cost += MOVE_COST;
    switch(TASKER->compare_skills(att->attacker, MOVE_SKILL,
                                  att->defender, MOVE_SKILL,
                                  att->attack_modifier -
                                  att->defense_modifier,
                                  TM_CONTINUOUS, TM_CONTINUOUS, 0)) {
    case OFFAWARD:
      tell_object(att->attacker,
                  "%^YELLOW%^You feel that your tactical skill has increased."
                  "%^RESET%^\n");
    case OFFWIN:
      if(closer) {
        (att->attacker)->event_combat(att->attacker, "You move in closer to " +
                                      (att->opponent)->one_short() + ".\n",
                                      ({ }), 0);
        (att->opponent)->event_combat(att->opponent,
                                      (att->attacker)->one_short() +
                                      " moves in closer to you.\n", ({ }), 0);
        event(environment(att->attacker), "combat",
              (att->attacker)->one_short() +
              " moves in closer to " + (att->opponent)->one_short() + ".\n",
              ({ att->attacker, att->opponent }), 1);
        set_distance(att->opponent, query_distance(att->opponent) -
                     DISTANCE_STEP);
        (att->opponent)->set_distance(att->attacker,
                                      query_distance(att->opponent));
      } else {
        (att->attacker)->event_combat(att->attacker,
                                      "You move further away from " +
                                      (att->opponent)->one_short() + ".\n",
                                      ({ }), 0);
        (att->opponent)->event_combat(att->opponent,
                                     (att->attacker)->one_short() +
                                     " moves further away from you.\n",
                                     ({ }), 0);
        event(environment(att->attacker), "combat",
              (att->attacker)->one_short() + " moves further away from " +
              (att->opponent)->one_short() + ".\n",
              ({ att->attacker, att->opponent }), 1);
        set_distance(att->opponent, query_distance(att->opponent) +
                     DISTANCE_STEP);
        (att->opponent)->set_distance(att->attacker,
                                      query_distance(att->opponent));
      }
      break;
    case DEFAWARD:
      tell_object(att->opponent,
                  "%^YELOW%^You feel that your tactical skill has increased."
                  "%^RESET%^\n");
    case DEFWIN:
      if(closer) {
        (att->attacker)->event_combat(att->attacker,
                                      "You try to move in closer to " +
                                      (att->opponent)->one_short() +
                                      " but cannot find "
                                      "an opportunity.\n", ({ }), 1);
        (att->opponent)->event_combat(att->opponent,
                                      (att->attacker)->one_short() +
                                      " tries to move in closer to you "
                                      "but you don't give " +
                                      (att->attacker)->query_objective() +
                                      " an opporunity.\n", ({ }), 1);
        event(environment(att->attacker), (att->attacker)->one_short() +
              " tries to move in closer to " +
              (att->opponent)->one_short() + " but " +
              (att->opponent)->query_pronoun() + " doesn't give " +
              (att->attacker)->query_objective() + " an opportunity.\n",
              ({ att->attacker, att->opponent }), 1);
      } else {
        (att->attacker)->event_combat(att->attacker,
                                      "You try to move further away from  " +
                                      (att->opponent)->one_short() +
                                      " but cannot find an opportunity.\n",
                                      ({ }), 1);
        (att->opponent)->event_combat(att->opponent,
                                      (att->attacker)->one_short() +
                                      " tries to move further away from you "
                                      "but you don't give " +
                                      (att->attacker)->query_objective() +
                                      " an opporunity.\n", ({ }) , 1);
        event(environment(att->attacker), "combat",
              (att->attacker)->one_short() +
              " tries to move further away from " +
              (att->opponent)->one_short() + " but " +
              (att->opponent)->query_pronoun() + " doesn't give " +
              (att->attacker)->query_objective() + " an opportunity.\n",
              ({ att->attacker, att->opponent }), 1);
      }
    }
  }
  return att;
}
protected class attack after_attack(class attack att) {
  string *locations;
  int total, count, lperc, hperc;
#ifdef USE_DISTANCE
  if((att->result == OFFWIN || att->result == OFFAWARD) &&
     (att->attacker_tactics)->ideal_distance &&
     environment(att->attacker) == environment(att->opponent))
    att = perform_movement(att);
#endif
  adjust_actions(att);
  if((att->damage - att->armour_stopped) <= 0)
    return att;
  if((environment(att->person_hit) == environment(att->attacker)) &&
     (att->result == OFFWIN || att->result == OFFAWARD)) {
    (att->attack_weapon)->attack_function(att->attack_data[AT_NAME],
                                          att->damage - att->armour_stopped,
                                          att->person_hit, att->attacker);
  }
  locations = (att->defender->query_race_ob())->query_target_zones();
  total = sizeof(locations);
  tmpzone = att->target_zone;
  locations = filter(locations, (: $1 == tmpzone :));
  count = sizeof(locations);
  lperc = (count * 100) / total;
  if(att->degree == TASKER_CRITICAL) {
    hperc = ((att->damage - att->armour_stopped) * 100) /
      (att->opponent)->query_max_hp();
    if(lperc < hperc) {
      switch(att->target_zone) {
      case "head":
        break;
      case "chest":
      case "stomach":
        break;
      case "arm":
        break;
      case "leg":
        break;
      }
    }
  }
  return att;
}
protected mixed *call_special(int stage, class attack att) {
  class combat_special *tmp;
  mixed *result;
  int i;
  if(!this_object()->query_no_specials()) {
    tmp = att->attacker_specials;
    for(i=0; i<sizeof(tmp); i++) {
      if((tmp[i]->type & T_OFFENSIVE) && (tmp[i]->events & stage)) {
        if(functionp(tmp[i]->callback))
          result = evaluate(tmp[i]->callback, stage, att, tmp[i]->data);
        else if(arrayp(tmp[i]->callback)) {
          if(!tmp[i]->callback[0] || !tmp[i]->callback[1]) {
            (att->attacker)->remove_special(tmp[i]->id);
          } else
            result = call_other(tmp[i]->callback[0], tmp[i]->callback[1],
                                stage, att, tmp[i]->data);
        }
        if(sizeof(result)) {
          if(!classp(result[1])) {
            debug_printf("Error, call_special received invalid return "
                         "data. %O when calling %O stage %d\n", result,
                         tmp[i]->callback, stage);
            result[0] = R_REMOVE_ME | R_ABORT;
          }
          if(result[0] & R_REMOVE_ME) {
            (att->attacker)->remove_special(tmp[i]->id);
          } else {
            tmp[i]->data = result[2];
            (att->attacker)->set_special_data(tmp[i]->id, result[2]);
          }
          if(result[0] & R_ABORT)
            return result;
          if((result[0] & R_DONE) || (result[0] & R_CONTINUE))
            break;
        }
      }
    }
  }
  if(att->defender && !(att->defender)->query_no_specials()) {
    tmp = att->defender_specials;
    for(i=0; i<sizeof(tmp); i++) {
      if((tmp[i]->type & T_DEFENSIVE) && (tmp[i]->events & stage)) {
        if(functionp(tmp[i]->callback))
          result = evaluate(tmp[i]->callback, stage, att, tmp[i]->data);
        else if(arrayp(tmp[i]->callback)) {
          if(!tmp[i]->callback[0] || !tmp[i]->callback[1]) {
            (att->defender)->remove_special(tmp[i]->id);
          } else
            result = call_other(tmp[i]->callback[0], tmp[i]->callback[1],
                                stage, att, tmp[i]->data);
        }
        if(sizeof(result)) {
          if(!classp(result[1])) {
            debug_printf("Error, call_special received invalid return "
                         "data. %O when calling %O stage %d", result,
                         tmp[i]->callback, stage);
            result[0] = R_REMOVE_ME | R_ABORT;
          }
          if(result[0] & R_REMOVE_ME) {
            (att->defender)->remove_special(tmp[i]->id);
          } else {
            (att->defender)->set_special_data(tmp[i]->id, result[2]);
          }
          if(result[0] & R_ABORT)
            return result;
          if((result[0] & R_DONE) || (result[0] & R_CONTINUE))
            break;
        }
      }
    }
  }
  return result;
}
void do_attack() {
  class tasker_result result;
  class attack att;
  mixed *sp_result;
  int modifier, tmp;
  init_tactics();
  if(_callout)
    _callout = remove_call_out("announce_intent");
  att = new(class attack,
            attacker : this_object(),
            attacker_tactics : this_object()->query_tactics(),
            attacker_specials : this_object()->query_specials(),
            attacker_concentrating : this_object()->query_concentrating(),
            attacker_defecit : this_object()->query_action_defecit(),
            attacker_last_opponent : this_object()->query_last_opponent(),
            attacker_last_weapon : this_object()->query_last_weapon(),
            attacker_last_action : this_object()->query_last_action(),
            attacker_last_result : this_object()->query_last_result(),
            repeat : 0
            );
  sp_result = call_special(E_OPPONENT_SELECTION, att);
  if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
    att = this_object()->choose_opponent(att);
  else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
    att = (class attack)sp_result[1];
  else
    return;
  if(!(att->opponent) || !(att->opponent)->attack_by(att->attacker)) {
    combat_debug("No opponent chosen, aborting attack");
    return;
  }
  event(environment(att->attacker), "fight_in_progress", att->opponent);
  clear_protection(att->attacker, att->opponent);
  _combat->last_opponent = att->opponent;
  do {
    sp_result = call_special(E_DEFENDER_SELECTION, att);
    if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
      att = (att->opponent)->choose_defender(att);
    else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
      att = (class attack)sp_result[1];
    else
      return;
    att->defender_tactics = (att->defender)->query_tactics();
    att->defender_concentrating = (att->defender)->query_concentrating();
    att->defender_last_opponent = (att->defender)->query_last_opponent();
    att->defender_last_action = (att->defender)->query_last_action();
    att->defender_last_result = (att->defender)->query_last_result();
    att->defender_defecit = (att->defender)->query_action_defecit();
    att->defender_specials = (att->defender)->query_specials();
    clear_protection(att->attacker, att->defender);
    sp_result = call_special(E_ATTACK_SELECTION, att);
    if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
      att = this_object()->choose_attack(att);
    else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
      att = (class attack)sp_result[1];
    else
      return;
    if(!att->attack_weapon || !sizeof(att->attack_data) || !att->attack_skill){
      combat_debug("Missing attack weapon, attack data or attack skill, "
                   "aborting attack.");
      return;
    }
    _combat->last_action = att->attack_data[AT_NAME];
    _combat->last_weapon = att->attack_weapon;
    sp_result = call_special(E_DEFENSE_SELECTION, att);
    if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
      att = (att->defender)->choose_defense(att);
    else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
      att = (class attack)sp_result[1];
    else
      return;
    (att->opponent)->set_last_opponent(att->attacker);
    if(att->opponent != att->defender)
      (att->defender)->set_last_opponent(att->attacker);
    (att->defender)->set_last_action(att->defense_action);
    (att->defender)->set_last_weapon(att->defense_weapon);
    if(att->person_hit != att->opponent && att->person_hit != att->defender)
      (att->person_hit)->set_last_opponent(att->attacker);
    sp_result = call_special(E_ATTACK_MODIFIER, att);
    if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU) {
      att = this_object()->calc_attack_modifier(att);
    } else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1])) {
      att = (class attack)sp_result[1];
    } else
      return;
    if(!att->defense_action || att->defense_action == "none")
      att->defense_modifier += -1000;
    else {
      sp_result = call_special(E_DEFENSE_MODIFIER, att);
      if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
        att = (att->defender)->calc_defense_modifier(att);
      else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
        att = (class attack)sp_result[1];
      else
        return;
    }
    tmp = att->attack_modifier - att->defense_modifier + BALANCE_MOD;
    modifier = tmp;
    if(modifier > 25)
      modifier = sqrt(modifier * 25);
    else if(modifier < -25)
      modifier = -sqrt(-modifier * 25);
    result = TASKER->compare_skills(att->attacker, att->attack_skill,
                                    att->defender, att->defense_skill,
                                    modifier,
                                    TM_CONTINUOUS, TM_CONTINUOUS, 1);
    att->result = result->result;
    att->degree = result->degree;
    _combat->last_result = att->result;
    (att->defender)->set_last_result(att->result);
    if((att->result == OFFWIN || att->result == OFFAWARD) &&
       att->defender != att->opponent && !att->repeat) {
      (att->defender)->adjust_action_defecit(att->defense_cost);
      (att->defender)->adjust_gp(-(DEFENSE_GP[att->defender_tactics->attitude]));
      att->defender = att->opponent;
      att->repeat = 1;
    } else
      att->repeat = 0;
  } while(att->repeat);
  sp_result = call_special(E_DAMAGE_CALCULATION, att);
  if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
    att = this_object()->calc_damage(att);
  else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
    att = (class attack)sp_result[1];
  else
    return;
  sp_result = call_special(E_ARMOUR_CALCULATION, att);
  if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
    att = (att->opponent)->calc_armour_protection(att);
  else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
    att = (class attack)sp_result[1];
  else
    return;
#if DEBUG == 1
  combat_debug("Outcome: mod: %d, res: %d, deg: %d dam: %d arm: %d",
               att->attack_modifier - att->defense_modifier + BALANCE_MOD,
               att->result, att->degree, att->damage, att->armour_stopped);
#endif
  if(att->result == OFFWIN || att->result == OFFAWARD) {
    att->stopped_by = (att->person_hit)->query_stopped();
#if DEBUG == 2
    combat_debug("hit: %s, weapon: %s damage: %d, armour: %d, reducing hp by "
                 "%d to %d",
                 (att->person_hit)->query_name(),
                 (att->attack_weapon)->query_name(),
                 att->damage,
                 att->armour_stopped,
                 (att->damage - att->armour_stopped),
                 (att->person_hit)->query_hp());
#endif
  }
  att = this_object()->prepare_messages(att);
  if(sizeof(att->attack_messages) != 5 || sizeof(att->defense_messages) != 5) {
    debug_printf("No attack or defense messages.\n");
    return;
  }
  sp_result = call_special(E_WRITE_MESSAGES, att);
  if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
    att = this_object()->write_messages(att);
  else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
    att = (class attack)sp_result[1];
  else
    return;
  if(att->damage - att->armour_stopped > 0)
    (att->person_hit)->adjust_hp(-(att->damage - att->armour_stopped),
                                 att->attacker, att->attack_weapon,
                                 _combat->last_action);
  sp_result = call_special(E_WEAPON_DAMAGE, att);
  if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
    att = this_object()->damage_weapon(att);
  else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
    att = (class attack)sp_result[1];
  else
    return;
  sp_result = call_special(E_AFTER_ATTACK, att);
  if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
    att = this_object()->after_attack(att);
  else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
    att = (class attack)sp_result[1];
  else
    return;
}
void recalc_hunting_list() {
  mixed ob;
  object tmp;
  tmp = 0;
  foreach(ob in keys(_combat->attacker_list)) {
    if(stringp(ob) && find_player(ob))
      tmp = find_player(ob);
    else if(ob && objectp(ob))
      tmp = ob;
    if(!tmp) {
      _combat->attacker_list = filter_mapping(_combat->attacker_list,(: $1 :));
    } else if(tmp->query_property("dead") ||
              !environment(tmp) ||
               base_name(environment(tmp)) == "/room/rubbish") {
      map_delete(_combat->attacker_list, ob);
    } else if(environment(tmp) != environment() ||
              !tmp->query_visible(this_object())) {
      _combat->hunting_list[ob] = time();
      map_delete(_combat->attacker_list, ob);
    }
  }
  tmp = 0;
  foreach(ob in keys(_combat->hunting_list)) {
    if(stringp(ob) && find_player(ob))
      tmp = find_player(ob);
    else if(ob && objectp(ob))
      tmp = ob;
    if(!tmp) {
      _combat->hunting_list = filter_mapping(_combat->hunting_list, (: $1 :));
      map_delete(_combat->hunting_list, ob);
    } else if(tmp->query_property("dead") ||
              base_name(environment(tmp)) == "/room/rubbish") {
      map_delete(_combat->hunting_list, ob);
    } else if(environment(tmp) == environment() &&
              tmp->query_visible(this_object())) {
      _combat->attacker_list[ob] = INITIAL_DISTANCE;
      map_delete(_combat->hunting_list, ob);
    } else if(_combat->hunting_list[ob] < time() - HUNTING_TIME) {
      this_object()->event_combat(this_object(), "You stop hunting " +
                                  tmp->one_short() + ".\n", ({ }), 1);
      map_delete(_combat->hunting_list, ob);
    }
  }
}
void monitor_points() {
   int hp;
   int max;
   string colour;
#ifdef UNUSED
   this_object()->clear_gp_info();
   if ( (int)this_object()->adjust_gp( -1 ) < 0 )
     return;
#endif
   hp = (int)this_object()->query_hp();
   if(hp < 0)
     hp = 0;
   max = (int)this_object()->query_max_hp();
   switch ( ( hp * 100 ) / max) {
      case 50 .. 100 :
         colour = "%^GREEN%^";
         break;
      case 20 .. 49 :
         colour = "%^YELLOW%^";
         break;
      default :
         colour = "%^RED%^";
   }
   tell_object( this_object(), colour +"Hp: "+ hp +" (" + max + ") Gp: "+
         (int)this_object()->query_gp() +" (" + this_object()->query_max_gp() +
         ") Xp: " + this_object()->query_xp() + "%^RESET%^\n" );
}
void announce_intent(object opponent) {
  int difficulty = 50;
  object *things, ob;
  if(environment(opponent) != environment(this_object()))
    return;
  switch(this_object()->check_dark((int)environment(this_object())->query_light())) {
   case -2:
   case 2:
     difficulty *= 4;
     break;
   case -1:
   case 1:
     difficulty *= 2;
   }
   things = ({ });
   foreach(ob in filter(all_inventory(environment(this_object())),
                        (: $1 &&living($1) :))) {
     switch(TASKER->perform_task(ob, "other.perception", difficulty, TM_FREE)){
     case AWARD:
       tell_object(ob, "%^YELLOW%^You feel very perceptive."
                   "%^RESET%^\n");
     case SUCCEED:
       if(interactive(ob) && !ob->query_verbose("combat"))
         things += ({ ob });
       break;
     case FAIL:
       things += ({ ob });
     }
   }
   opponent->add_message((string)this_object()->one_short() +
                      " $V$0=moves,move$V$ aggressively towards you!\n",
                      ({ }));
   event(environment(opponent), "see", (string)this_object()->one_short() +
          " $V$0=moves,move$V$ aggressively towards "+
          (string)opponent->one_short() +"!\n", this_object(),
          ({ opponent, this_object() }) + things);
}
void start_combat(object opponent) { return; }
void end_combat() { return; }
void heart_beat() {
  int i;
  if(!_combat->in_combat)
    return;
  recalc_hunting_list();
  if(!sizeof(keys(_combat->attacker_list)) &&
     !sizeof(keys(_combat->hunting_list))) {
    for(i=0; i<sizeof(_combat->specials); i++)
      if(!((_combat->specials[i])->type & T_CONTINUOUS))
        _combat->specials -= ({ (_combat->specials)[i] });
    _combat->in_combat = 0;
    adjust_action_defecit(-MAX_ACTION_DEFECIT);
    end_combat();
    return;
  }
  if(!query_attackable() || !sizeof(keys(_combat->attacker_list)))
    return;
  if((!userp(this_object()) ||
     this_object()->query_time_left() == ROUND_TIME) &&
     !this_object()->query_casting_spell()) {
    adjust_action_defecit(-(ACTIONS_PER_HB / (COMBAT_SPEED + 1)));
  }
  if(_combat->hbc++ % COMBAT_SPEED)
    return;
  _combat->hbc = 0;
  if(this_object()->query_monitor() &&
     this_object()->query_monitor() <= ++(_combat->mbc)) {
    monitor_points();
    _combat->mbc = 0;
  }
  do_attack();
  if(!this_object()->query_casting_spell()) {
    adjust_action_defecit(-(ACTIONS_PER_HB / (COMBAT_SPEED + 1)));
    if(_combat->action_defecit < (OFFENSIVE_DEFECITS[_tactics->attitude] / 2)) {
#if DEBUG == 1
      combat_debug("Adding bonus attack for %s", this_object()->query_name());
      debug_printf("Bonus attack for %s [%d, %d]",
                   this_object()->query_name(), _combat->action_defecit,
                   OFFENSIVE_DEFECITS[_tactics->attitude]);
#endif
      call_out("do_attack", 1);
    }
  }
}
int register_special(int type, int events, mixed callback, mixed data) {
  _combat->specials += ({ new(class combat_special,
                              id : ++(_combat->special_id),
                              type : type,
                              events : events,
                              callback : callback,
                              data : data) });
  return _combat->special_id;
}
int remove_special(int id) {
  int i;
  for(i=0; i<sizeof(_combat->specials); i++) {
    if((_combat->specials[i])->id == id) {
      _combat->specials -= ({ (_combat->specials)[i] });
      return 1;
    }
  }
  debug_printf("Failed to remove special %d", id);
  return 0;
}
class combat_special *query_specials() {
  return copy(_combat->specials);
}
void set_specials(class combat_special *specials) {
  _combat->specials = specials;
}
int set_special_data(int id, mixed data) {
  int i;
  for(i=0; i<sizeof(_combat->specials); i++) {
    if((_combat->specials[i])->id == id) {
      _combat->specials[i]->data = data;
      return 1;
    }
  }
  return 0;
}
void adjust_action_defecit(int amount) {
  _combat->action_defecit += amount;
  if(_combat->action_defecit > MAX_ACTION_DEFECIT)
    _combat->action_defecit = MAX_ACTION_DEFECIT;
  else if(_combat->action_defecit < MIN_ACTION_DEFECIT)
    _combat->action_defecit = MIN_ACTION_DEFECIT;
}
int query_action_defecit() { return _combat->action_defecit; }
class tactics query_tactics() {
  init_tactics();
  return copy(_tactics);
}
void set_tactics(class tactics new_tactics) { _tactics = new_tactics; }
string query_combat_attitude() { return _tactics->attitude; }
void set_combat_attitude(string attitude) { _tactics->attitude = attitude; }
string query_combat_response() { return _tactics->response; }
void set_combat_response(string response) { _tactics->response = response; }
string query_combat_attack() { return _tactics->attack; }
void set_combat_attack(string attack) { _tactics->attack = attack; }
string query_combat_parry() { return _tactics->parry; }
void set_combat_parry(string parry) { _tactics->parry = parry; }
int query_unarmed_parry() { return _tactics->parry_unarmed; }
void set_unarmed_parry(int parry) {  _tactics->parry_unarmed = parry; }
string query_combat_mercy() { return _tactics->mercy; }
void set_combat_mercy(string mercy) { _tactics->mercy = mercy; }
string query_combat_focus() { return _tactics->focus_zone; }
void set_combat_focus(string focus) { _tactics->focus_zone = focus; }
string query_combat_distance() { return _tactics->ideal_distance; }
void set_combat_distance(string distance) { _tactics->ideal_distance = distance; }
object *query_protectors() {
  _combat->protectors -= ({ 0 });
   return copy(_combat->protectors + ({ }));
}
int add_protector( object thing ) {
  if(thing == this_object() ||
     thing->query_property("dead") ||
     member_array(this_object(), thing->query_protectors() +
                  thing->query_defenders()) != -1 ||
     member_array(thing, query_attacker_list())  != -1)
    return 0;
  if(member_array(thing, _combat->protectors) == -1)
    _combat->protectors += ({ thing });
  return 1;
}
int remove_protector(object protector) {
  if(member_array(protector, _combat->protectors) == -1)
    return 0;
  _combat->protectors -= ({ protector });
  return 1;
}
void reset_protectors() {
  _combat->protectors = ({ });
}
object *query_defenders() {
  _combat->defenders -= ({ 0 });
   return copy(_combat->defenders + ({ }));
}
int add_defender( object thing ) {
  if(thing == this_object() ||
     thing->query_property("dead") ||
     member_array(this_object(), thing->query_defenders() +
                  thing->query_protectors()) != -1 ||
     member_array(thing, query_attacker_list())  != -1)
    return 0;
  if(member_array(thing, _combat->defenders) == -1)
    _combat->defenders += ({ thing });
  return 1;
}
int remove_defender(object defender) {
  if(member_array(defender, _combat->defenders) == -1)
    return 0;
  _combat->defenders -= ({ defender });
  return 1;
}
void reset_defenders() {
  _combat->defenders = ({ });
}
#ifdef USE_DISTANCE
int set_distance(object opponent, int distance) {
  if(userp(opponent)) {
    if(!_combat->attacker_list[opponent->query_name()])
      return 0;
    _combat->attacker_list[opponent->query_name()] = distance;
  } else {
    if(!_combat->attacker_list[opponent])
      return 0;
    _combat->attacker_list[opponent] = distance;
  }
  return 1;
}
int query_distance(object opponent) {
  if(userp(opponent)) {
    if(!_combat->attacker_list[opponent->query_name()])
      return 0;
    return _combat->attacker_list[opponent->query_name()];
  } else {
    if(!_combat->attacker_list[opponent])
      return 0;
    return _combat->attacker_list[opponent];
  }
}
#endif
object *query_attacker_list() {
  return uniq_array(map(keys(_combat->attacker_list) +
                        keys(_combat->hunting_list),
                        (: $1 && objectp($1) ? $1 : find_player($1) :)) -
                    ({ 0 }));
}
void remove_attacker_list(object ob) {
  if(userp(ob)) {
    map_delete(_combat->attacker_list, ob->query_name());
    map_delete(_combat->hunting_list, ob->query_name());
  } else {
    map_delete(_combat->attacker_list, ob);
    map_delete(_combat->hunting_list, ob);
  }
}
int attack_by(object opponent) {
  int starting;
  if(!objectp(opponent) ||
     opponent == this_object() ||
     !this_object()->query_attackable() ||
     pk_check(this_object(), opponent))
    return 0;
  if(member_array(opponent, _combat->protectors) != -1)
    _combat->protectors -= ({ opponent });
  if(member_array(opponent, _combat->defenders) != -1)
    _combat->defenders -= ({ opponent });
  if(!sizeof(query_attacker_list()))
    starting = 1;
#ifdef USE_DISTANCE
  if(userp(opponent)) {
    if(!_combat->attacker_list[opponent->query_name()])
      _combat->attacker_list[opponent->query_name()] =
        opponent->query_distance(this_object());
  } else if(!_combat->attacker_list[opponent])
    _combat->attacker_list[opponent] = opponent->query_distance(this_object());
#else
  if(userp(opponent)) {
    if(!_combat->attacker_list[opponent->query_name()])
      _combat->attacker_list[opponent->query_name()] = 1;
  } else if(!_combat->attacker_list[opponent])
    _combat->attacker_list[opponent] = 1;
#endif
  if(starting) {
    _combat->action_defecit = (MAX_ACTION_DEFECIT - MIN_ACTION_DEFECIT) / 3;
    start_combat(opponent);
  }
  _combat->in_combat = 1;
  return 1;
}
int attack_ob(object opponent) {
  int starting, new_opponent;
  if(!objectp(opponent) ||
     opponent == this_object() ||
     !opponent->query_attackable() ||
     !this_object()->query_attackable() ||
     pk_check(this_object(), opponent))
    return 0;
  if(member_array(opponent, _combat->protectors) != -1)
    _combat->protectors -= ({ opponent });
  if(member_array(opponent, _combat->defenders) != -1)
    _combat->defenders -= ({ opponent });
  if(!sizeof(query_attacker_list()))
    starting = 1;
  else if(member_array(opponent, query_attacker_list()) == -1)
    new_opponent = 1;
#ifdef USE_DISTANCE
  if(userp(opponent)) {
    if(!_combat->attacker_list[opponent->query_name()])
      _combat->attacker_list[opponent->query_name()] = INITIAL_DISTANCE;
  } else {
    if(!_combat->attacker_list[opponent])
      _combat->attacker_list[opponent] = INITIAL_DISTANCE;
  }
#else
  if(userp(opponent)) {
    if(!_combat->attacker_list[opponent->query_name()])
      _combat->attacker_list[opponent->query_name()] = 1;
  } else {
    if(!_combat->attacker_list[opponent])
      _combat->attacker_list[opponent] = 1;
  }
#endif
  if((new_opponent || starting) &&
     opponent->query_visible(this_object()))
    _callout = call_out("announce_intent", 0, opponent);
  this_object()->remove_hide_invis("hiding");
  if(starting) {
    _combat->action_defecit = (MAX_ACTION_DEFECIT - MIN_ACTION_DEFECIT) / 3;
    start_combat(opponent);
  }
  _combat->in_combat = 1;
  return 1;
}
void stop_fight(object opponent) {
  class combat_special tmp;
#if DEBUG == 2
  combat_debug("stop_fight called against %s", opponent->query_name());
#endif
  if(!objectp(opponent))
    return;
  if(userp(opponent)) {
    map_delete(_combat->attacker_list, opponent->query_name());
    map_delete(_combat->hunting_list, opponent->query_name());
  } else {
    map_delete(_combat->attacker_list, opponent);
    map_delete(_combat->hunting_list, opponent);
  }
#ifdef USE_SURRENDER
  _surrender->from -= ({ 0, opponent });
  _surrender->refusers -= ({ 0, opponent });
  _surrender->to -= ({ 0, opponent });
#endif
  if(!sizeof(query_attacker_list())) {
    foreach(tmp in _combat->specials)
      if(!(tmp->type & T_CONTINUOUS))
        remove_special(tmp->id);
    end_combat();
  }
}
void stop_all_fight() {
  class combat_special tmp;
#if DEBUG == 2
  combat_debug("stop_all_fight called");
#endif
  _combat->attacker_list = ([ ]);
  _combat->hunting_list = ([ ]);
  _combat->in_combat = 0;
#ifdef USE_SURRENDER  _surrender->from = ({ });
  _surrender->refusers = ({ });
  _surrender->to = ({ });
#endif
  foreach(tmp in _combat->specials)
    if(!(tmp->type & T_CONTINUOUS))
      remove_special(tmp->id);
  end_combat();
}
void stop_hunting(object opponent) {
  if(userp(opponent))
    map_delete(_combat->hunting_list, opponent->query_name());
  else
    map_delete(_combat->hunting_list, opponent);
  if(!sizeof(query_attacker_list()))
    end_combat();
}
#ifdef USE_SURRENDER
object do_surrender(object thing) {
   mixed *attackers;
   mixed att;
   if(this_object()->query_property("dead"))
      return 0;
   death_helper(thing, 0);
   catch(DEATH->someone_surrendered(this_object()));
   attackers = query_attacker_list();
   foreach(att in attackers) {
     att->stop_fight(this_object());
   }
   stop_all_fight();
   return 0;
}
int dont_attack_me() {
  if(sizeof(_surrender->to))
    return 1;
  else
    return 0;
}
void event_surrender(object victim, object *attackers) {
  object *offer;
  offer = ({ });
  if (this_object() == victim) {
    _surrender->refusers -= ({ 0 });
    _surrender->to -= ({ 0 });
    offer = filter(attackers, (: member_array($1, _surrender->refusers +
                                              _surrender->to) == -1 :));
    if(sizeof(offer)) {
      event(environment(), "combat",
            sprintf("%s kneels down and surrenders to %s.\n",
                    this_object()->one_short(), query_multiple_short(offer)),
            ({ this_object() }) + _surrender->to + _surrender->refusers, 0);
      this_object()->event_combat(this_object(),
                                sprintf("%s kneel down and surrender to %s.\n",
                                        this_object()->one_short(),
                                        query_multiple_short(offer)), ({ }), 0);
      offer->offered_surrender(victim);
      _surrender->to += offer;
    }
  }
}
object *query_surrenderers() {
  _surrender->from -= ({ 0 });
  return copy(_surrender->from);
}
void remove_surrenderer(object victim) {
  _surrender->from -= ({ 0, victim });
  return;
}
void offered_surrender(object victim) {
  string mercy = this_object()->query_combat_mercy();
  switch(mercy) {
  case "ask":
    if (interactive(this_object())) {
      _surrender->from -= ({ 0, victim });
      _surrender->from += ({ victim });
      this_object()->event_combat(this_object(),
                                  victim->one_short() + " has surrendered to "
                                  "you.  Either \"accept " +
                                  victim->query_name() + "\" or \"reject " +
                                  victim->query_name() + ".\n", ({ }), 0);
    } else {
      if (this_object()->query_accept_surrender(victim))
        victim->accepted_surrender(this_object());
      else
        victim->refused_surrender(this_object());
    }
    break;
  case "always":
    this_object()->event_combat(this_object(),
                                "You accept the surrender of " +
                                victim->one_short() + ".\n", ({ }), 0);
    victim->accepted_surrender(this_object());
    break;
  default:
    this_object()->event_combat(this_object(),
                                sprintf("You refuse the surrender of %s.\n",
                                        victim->one_short()), ({ }), 0);
    victim->refused_surrender(this_object());
  }
}
void refused_surrender(object attacker) {
  _surrender->to -= ({ 0 });
  if (member_array(attacker, _surrender->to) == -1)
    return;
  _surrender->to -= ({ attacker });
  _surrender->refusers -= ({ 0 });
  _surrender->refusers += ({ attacker });
  this_object()->event_combat(this_object(), attacker->one_short() +
                              " refused your surrender\n", ({ }), 0);
}
void accepted_surrender(object attacker) {
  _surrender->to -= ({ 0 });
  if(member_array(attacker, _surrender->to) == -1) {
    return;
  }
  _surrender->to -= ({ attacker });
  this_object()->event_combat(this_object(), attacker->one_short() +
                              " accepts your surrender.\n", ({ }));
  this_object()->do_surrender(attacker);
}
#endif
void stopped_fighting(object thing) {
  event( environment(), "stopped_fighting", thing );
}
void fight_in_progress(object thing) {
  event(environment(), "fight_in_progress", thing );
}
int set_concentrating(object thing) {
  if(userp(thing)) {
    if(!_combat->attacker_list[thing->query_name()])
      return 0;
#ifdef USE_DISTANCE
    _combat->attacker_list[thing->query_name()] =
      thing->query_distance(this_object());
#else
    _combat->attacker_list[thing->query_name()] = 1;
#endif
  } else {
    if(!_combat->attacker_list[thing])
      return 0;
#ifdef USE_DISTANCE
    _combat->attacker_list[thing] = thing->query_distance(this_object());
#else
    _combat->attacker_list[thing] = 1;
#endif
  }
  _combat->concentrating = thing;
  return 1;
}
object query_concentrating() {
  object thing;
  thing = _combat->concentrating;
  if(!thing || !objectp(thing))
    return 0;
  if(userp(thing) && !_combat->attacker_list[thing->query_name()])
    return 0;
  else if(!_combat->attacker_list[thing])
    return 0;
  return thing;
}
object query_attacker() {
  return _combat->last_opponent;
}
object query_last_opponent() {
  return _combat->last_opponent;
}
void set_last_opponent(object last) { _combat->last_opponent = last; }
object query_last_weapon() {
  return _combat->last_weapon;
}
void set_last_weapon(object last) { _combat->last_weapon = last; }
string query_last_action() { return _combat->last_action; }
void set_last_action(string last) { _combat->last_action = last; }
int query_last_result() { return _combat->last_result; }
void set_last_result(int last) { _combat->last_result = last; }
varargs int is_fighting(object ob, int actively) {
  if(!objectp(ob))
    return 0;
  if(actively)
    return userp(ob) ? _combat->attacker_list[ob->query_name()] :
      _combat->attacker_list[ob];
  return userp(ob) ? _combat->attacker_list[ob->query_name()] ||
    _combat->hunting_list[ob->query_name()] :
    _combat->attacker_list[ob] || _combat->hunting_list[ob];
}
int query_fighting() {
  if(!environment() || base_name(environment()) == "/room/rubbish")
    return 0;
  if(sizeof(filter(query_attacker_list(),
                   (: environment($1) == environment(this_object()) :))))
    return 1;
  if(sizeof(filter(all_inventory(environment(this_object())),
                   (: $1 && living($1) && $1->is_fighting(this_object(), 1) :))))
    return 1;
  return 0;
}
mixed stats() {
  int i;
  int j;
  object *weapons;
  mixed ret;
  init_tactics();
  ret = ({
    ({ "attitude", _tactics->attitude }),
      ({ "response", _tactics->response }),
      ({ "mercy", _tactics->mercy }),
      ({ "parry", _tactics->parry }),
      ({ "attack", _tactics->attack }),
      ({ "unarmed parry", ({ "no", "yes" })[ _tactics->parry_unarmed ] }),
      ({ "attack zone", _tactics->focus_zone ? _tactics->focus_zone :
        "none" }),
      ({ "distance", _tactics->ideal_distance ? _tactics->ideal_distance :
        "none" }),
      });
  weapons = (object *)this_object()->query_weapons();
  if(!sizeof(weapons))
    return ret + weapon_logic::stats();
  for ( i = 0; i < sizeof( weapons ); i++ )
    ret += ({ ({ "weapon #"+ i, weapons[ i ]->short() }) }) +
      (mixed)weapons[ j ]->weapon_stats();
  return ret + weapon_logic::stats();
}

==================================================
FILE: living/corpse.c
==================================================

#include <player.h>
int alter_corpse( object corpse, object weapon, string attack ) {
  object head;
  string *heads;
  string behead_message = "";
  if (!attack) attack = "attack";
  switch (attack) {
    case "behead" :
      heads =
        this_object()->query_race_ob( this_object() )->query_possible_bits( "head" );
      if (sizeof(heads) == 0)
        break;
      head = corpse->make_bit(heads[random(sizeof(heads))] );
      head->move( environment( corpse ) );
      switch(random(6)) {
        case 0 : behead_message = head->a_short() +
          " drops onto the ground and rolls head over, well, head "
          "for a bit before coming to a rest.\n";
           break;
        case 1 : behead_message = head->a_short() +
          " sails through the air in a graceful arc before landing "
          "with a very soggy *squish*.\n";
          break;
        case 2 : behead_message = head->a_short() +
          " quivers a bit as it remains in place, perched atop its owner's "
          "corpse for a moment, then falls to pieces.\n";
          break;
        case 3 : behead_message = head->a_short() +
          " tips off to the left to hang by a small bit of flesh, before "
          "gravity has something to say about the matter and pulls it "
          "completely off the corpse, landing with a small bounce.\n";
          break;
        case 4 : behead_message = head->a_short() +
          " slides off its owner's corpse, upends, and lands upside "
          "down, helping to keep some of the blood from spilling.\n";
          break;
        case 5 : behead_message = head->a_short() +
          " drops onto the ground like a ball, *bouncy* *bouncy*.\n";
          break;
        case 6 :
        case 7 :
        case 8 :
        case 9 :
        default : behead_message = "oops, the mushrooms have turned.\n";
      }
      tell_room( environment( corpse ), behead_message );
      break;
    default :
      break;
  }
  return 1;
}
object make_corpse() {
   int i;
   object corpse, *armour, *weapons, race;
   race = find_object(this_object()->query_race_ob());
   if(race && function_exists("make_corpse", race))
     return race->make_corpse();
   corpse = clone_object( "/obj/corpse" );
   corpse->set_owner( 0, this_object() );
   corpse->set_ownership( (string)this_object()->query_name() );
   if ( this_object()->query_property( "player" ) ) {
      corpse->add_property( "player", 1 );
   }
   corpse->set_race_name( (string)this_object()->query_race() );
   if ( !this_object()->query_race_ob() ) {
      corpse->set_race_ob( "/std/races/unknown" );
   } else {
      corpse->set_race_ob( (string)this_object()->query_race_ob() );
   }
   corpse->add_adjective( (string *)this_object()->query_adjectives() );
   corpse->add_adjective("dead");
   corpse->remove_adjective("living");
   corpse->start_decay();
   corpse->set_max_weight(this_object()->query_max_weight());
   corpse->set_length(this_object()->query_height() / 2);
   armour = (object *)this_object()->query_armours();
   this_object()->clear_armours();
   weapons = (object *)this_object()->query_weapons();
   all_inventory( this_object() )->set_tracked_item_status_reason( "DIED" );
   all_inventory( this_object() )->move( corpse );
   armour -= ({ 0 });
   for ( i = 0; i < sizeof( armour ); i++ ) {
      if ( environment( armour[ i ] ) != corpse ) {
         armour = delete( armour, i, 1 );
         i--;
      }
   }
   corpse->set_armours( armour );
   armour->set_worn_by( corpse );
   weapons -= ({ 0 });
   for ( i = 0; i < sizeof( weapons ); i++ ) {
      if ( environment( weapons[ i ] ) != corpse ) {
         weapons = delete( weapons, i, 1 );
         i--;
      }
   }
   corpse->set_holding( weapons );
   weapons->set_holder( corpse );
   return corpse;
}
mixed *death_helper(object thing, int death) {
   int shift, my_level, att_wimpy, att_level, xp, txp;
   string *messages;
   object *things, tmp;
   mixed *retval;
   retval = ({ });
   this_object()->remove_property(PASSED_OUT_PROP);
   this_object()->remove_hide_invis( "hiding" );
#ifdef USE_SURRENDER
   _surrender->refusers = ({ });
   _surrender->to = ({ });
#endif
   things = filter(this_object()->query_attacker_list(),
                   (:  living($1) && !$1->query_property("dead") :));
   if(environment()) {
     if (death) {
       messages = this_object()->query_property("death messages");
       if(!messages)
         messages = ({ "$K dealt the death blow to $D.\n",
                         "You killed $D.\n", "$D dies.\n" });
     } else {
       messages = this_object()->query_property( "surrender messages" );
       if (!messages)
         messages = ({ "$K accepted the surrender of $D.\n",
                         "You subdued $D.\n", "$D surrenders.\n" });
     }
     event( ({ environment() }) + deep_inventory( environment() ), "death",
            things, thing, (thing ? messages[0] : messages[2]), messages[1]);
   }
   if(sizeof(things)) {
     foreach(tmp in things) {
#if DEBUG == 2
       int x, y;
       x = tmp->query_al();
#endif
       shift = (int)this_object()->query_al() ;
       if (!death)
         shift -= (shift / 2);
       tmp->adjust_alignment(shift);
#if DEBUG == 2
       y = tmp->query_al();
       if(interactive(tmp))
         log_file("DEATH_ALIGN", "%s %s adjusted from %d to %d by %s [%d]\n",
                  ctime(time()), tmp->query_name(), x, y,
                  this_object()->query_name(), shift);
#endif
     }
     xp = this_object()->query_death_xp();
     if(xp > 0) {
       shift = 50 + xp / sizeof( things );
       debug_printf("%O Death XP: %O", this_object(), xp);
       my_level = this_object()->query_level();
       foreach(tmp in things) {
         att_wimpy = tmp->query_wimpy();
         att_level = tmp->query_level();
         if(att_level <= my_level)
           txp = shift / 2;
         else
           txp = ((shift/2) * my_level) / att_level;
         if(att_wimpy > 0)
           txp -= (txp * att_wimpy) / 100;
         tmp->adjust_xp(txp, 1);
       }
       return ({ ({ things }), shift/2 });
     }
   }
   return ({ });
}
varargs object do_death(object thing, object weapon, string attack) {
  object corpse, ob;
  mixed xp_leftover, sec_life;
#if DEBUG == 2
  combat_debug("Do death called.");
#endif
  this_object()->reset_callingdeath();
  if ( this_object()->query_property( "dead" ) ) {
    if ( !userp( this_object() ) ) {
      if(file_name(environment()) != "/room/rubbish") {
        this_object()->move("/room/rubbish");
      }
      return 0;
    }
    else
      return 0;
  }
  this_object()->end_combat();
  this_object()->add_property("xp before death", this_object()->query_xp());
  xp_leftover = death_helper(thing, 1);
  catch(sec_life = this_object()->second_life());
  if(sec_life) {
    if(xp_leftover && sizeof(xp_leftover) == 2 && xp_leftover[1] > 0) {
      foreach(ob in xp_leftover[0]) {
        ob->adjust_xp(xp_leftover[1], 1);
      }
    }
    this_object()->stop_all_fight();
    if( objectp( sec_life ) ) {
      return sec_life;
    } else {
      return 0;
    }
  }
  this_object()->add_property( "dead", time() );
  catch(DEATH->someone_died( this_object() ) );
  catch(this_object()->effects_thru_death() );
  this_object()->reset_protectors();
  if ( environment() ) {
    corpse = this_object()->make_corpse();
    if (corpse) {
      corpse->move(environment());
      corpse->add_property("XP", xp_leftover, 300);
      debug_printf("Command: %O", this_object()->query_last_action());
      if (!(alter_corpse( corpse, weapon, attack ))) {
      }
    }
  }
  this_object()->move( "/room/rubbish" );
  this_object()->stop_all_fight();
  return corpse;
}

==================================================
FILE: living/crafts.c
==================================================

private mixed _processes;
void create() {
   _processes = ([ ]);
}
mapping query_processes() {
   return _processes;
}
mapping query_processes_nocase() {
  mapping lc_processes = ([]);
  filter( this_object()->query_processes(),
                 (: $3 += ([ lower_case( $1 ) : $2 ]) :), lc_processes );
  return lc_processes;
}
int add_process(string name, string ob) {
   _processes[name] = ob;
   return 1;
}
int remove_process(string name) {
  string process, name_lc;
  name_lc = lower_case(name);
  foreach (process in keys(_processes)) {
     if (lower_case(process) == name_lc) {
        map_delete(_processes, process);
     }
  }
  return 1;
}
string query_process( string word ) {
   return _processes[word];
}
protected void reset_processes() {
   _processes = ([ ]);
}

==================================================
FILE: living/effects.c
==================================================

#include <effect.h>
inherit "/std/basic/effects";

==================================================
FILE: living/force.c
==================================================

#include <player.h>
#define FORCE_COST 1
#define ILLEGAL_FORCE ({ "alias", "unalias", "mv", "mkdir", "call", "rm", \
                         "force", "kill", "gauge", "exec", "promote", \
                         "new_domain", "rmdir", "cd", "history", "echoall", \
                         "shout" })
nosave string fname;
nosave int no_force_me;
protected int no_force(string str);
protected int do_force(object *obs, string str);
void force_commands() {
  fname = base_name(this_object());
  if ((!this_object()->query_property("npc") &&
      master()->query_senior( geteuid(this_object()) ) ) || fname == LORD_OB) {
    add_command("force", "<indirect:distant-living> <string'command'>",
                (: do_force($1, $4[1]) :));
 }
  if (fname == LORD_OB) {
    add_command("noforce", "{on|off}", (: no_force($4[0]) :));
    add_command("noforce", "", (: no_force(0) :));
  }
}
protected int no_force(string str) {
  if (str == "on") {
    no_force_me = 1;
    write("Ok, forcing you disabled.\n");
    return 1;
  }
  if (str == "off") {
    no_force_me = 0;
    write("Ok, forcing you enabled.\n");
    return 1;
  }
  write("Forcing you is currently ");
  if (no_force_me) {
    write("disabled.\n");
  }
  else {
    write("enabled.\n");
  }
  return 1;
}
protected int do_force(object *obs, string str) {
  object ob;
#ifdef PLAYERS_CAN_FORCE
  if (fname == PLAYER_OB && !this_player()->query_property("force")) {
    notify_fail("You do not have the ability to do that yet.\n");
    return 0;
  }
  if (this_player()->adjust_social_points(-FORCE_COST) < 0) {
    notify_fail("Insufficient social points.\n");
    return 0;
  }
#endif
  foreach( ob in obs ) {
    if(!ob->do_force_on_me( str )) {
      write(capitalize( ob->query_name() ) + " didn't want to do that.\n");
    }
  }
  write("Ok.\n");
  return 1;
}
nomask int do_force_on_me(string str) {
  string temp1, temp2;
  object forcer;
  forcer = this_player(1);
  if (!forcer || (this_player() != previous_object())) {
    if (interactive(previous_object())) {
      forcer = previous_object();
    } else {
      log_file("FORCE", "Attempted illegal force from "+
               file_name(previous_object())+"\n");
      return 0;
    }
  }
  log_file("FORCE", ctime(time()) + " " + forcer->query_name() + " " +
                    this_object()->query_name() + " : " + str);
  tell_object(this_object(), forcer->query_cap_name() +
        " tries to force you to " + str + "\n");
  if (no_force_me || (string)this_object()->query_name() == "pinkfish") {
    event(users(), "inform", forcer->query_cap_name()+" forces "+
          this_object()->query_name()+" to "+str+" (failed)", "force");
    log_file("FORCE", " (failed)\n");
    return 0;
  }
  if (sscanf(str, "%s %s", temp1, temp2) != 2) {
    temp1 = str;
  }
  if (member_array(temp1, ILLEGAL_FORCE) != -1 &&
      !master()->high_programmer(geteuid(forcer))) {
    event(users(), "inform", forcer->query_cap_name()+" forces "+
          this_object()->query_name()+" to "+str+" (failed)", "force");
    log_file("FORCE", " (failed)\n");
    return 0;
  }
  if (function_exists("eventForce", this_object())) {
    command(str);
  } else {
    this_object()->eventForce(str);
  }
  event(users(), "inform", forcer->query_cap_name()+" forces "+
        this_object()->query_name()+" to "+str, "force");
  log_file("FORCE", " (succeeded)\n");
  return 1;
}

==================================================
FILE: living/gender.c
==================================================

int gender;
nosave int womens_day;
int query_female() { return (gender == 2) || womens_day; }
int query_gender() { return (womens_day?2:gender); }
int query_male() { return gender == 1 && !womens_day; }
int query_neuter() { return !gender && !womens_day; }
string query_gender_string() {
    if (!gender && !womens_day) return "neuter";
    else if (gender == 1 && !womens_day) return "male";
    else return "female";
}
string query_gender_title() {
    if (!gender && !womens_day) return "creature";
    else if (gender == 1 && !womens_day) return "sir";
    else return "madam";
}
string query_gender_name() {
    if (!gender && !womens_day) return "neuter";
    else if (gender == 1 && !womens_day) return "man";
    else return "woman";
}
string query_objective() {
    if (!gender && !womens_day)
        return "it";
    else if (gender == 1 && !womens_day)
        return "him";
    else return "her";
}
string query_possessive() {
    if (!gender && !womens_day)
        return "its";
    else if (gender == 1 && !womens_day)
        return "his";
    else return "her";
}
string query_pronoun() {
    if (!gender && !womens_day)
        return "it";
    else if (gender == 1 && !womens_day)
        return "he";
    else return "she";
}
void set_gender(mixed arg) {
  if(stringp(arg)) {
    if(arg == "male")
      gender = 1;
    else if(arg == "female")
      gender = 2;
    else
      gender = 0;
  } else {
    gender = arg;
  }
}
void set_womens_day(int bing) {
  womens_day = bing;
}
int query_womens_day() {
    return womens_day;
}
nomask int query_real_gender() {
   return gender;
}

==================================================
FILE: living/health.c
==================================================

#include <drinks.h>
#include <living.h>
#undef POINTS_LOG
#ifdef USE_SURRENDER
#define SURRENDER_SHADOW "/std/shadows/misc/surrender_shadow"
#endif
varargs int adjust_xp( int number, int shared );
int hp, max_hp, gp, max_gp, xp, wimpy, *drink_info;
#ifdef USE_SURENDER
int surrender;
#endif
nosave int max;
nosave int* runaway_callout_handles;
nosave string which;
nosave mapping counts;
mapping verbs;
nosave int callingdeath;
void create() {
   max_hp = 1;
   max_gp = 1;
#ifdef USE_SURRENDER
   surrender = -1;
#endif
   drink_info = allocate( D_SIZEOF );
   counts = ([ ]);
   verbs = ([ ]);
   callingdeath = 0;
   runaway_callout_handles = ({ });
}
int query_hp() { return hp; }
varargs int set_hp( int number, object attacker ) {
   if ( number > max_hp )
      number = max_hp;
   hp = number;
   if ( ( hp < 0 ) && ( find_call_out( "do_death" ) == -1 ) )
      call_out( "do_death", 0, attacker );
   return hp;
}
protected int check_wimpy() {
    int hp;
    hp = this_object()->query_hp();
    if ( hp < 1 )
        return 0;
    if( 100 * hp < this_object()->query_wimpy() *
        this_object()->query_max_hp()) {
        if(find_call_out("run_away") == -1) {
            runaway_callout_handles += ({ call_out("run_away", 0) });
        }
        return 1;
    }
    return 0;
}
#ifdef USE_SURRENDER
protected int check_surrender() {
   int hp;
   object *attackers, *all, shad;
   hp = this_object()->query_hp();
   if (hp < 1)
      return 0;
   if (hp * 100 < this_object()->query_surrender() *
       this_object()->query_max_hp()) {
     attackers = filter(this_object()->query_attacker_list(),
                        (: $1 && !$1->query_property("dead") &&
                         environment($1) == environment($2) :),
                        this_object());
     all = attackers + ({ this_object() });
     all->event_surrender(this_object(), attackers);
     shad = clone_object(SURRENDER_SHADOW);
     if (shad) {
       shad->setup_shadow(this_object(), attackers);
     }
     return 1;
   }
   return 0;
}
#endif
void reset_callingdeath() {
  callingdeath = 0;
}
int query_callingdeath() {
    return callingdeath;
}
varargs int adjust_hp(int number, object attacker, object weapon,
                      string attack) {
    int i;
    hp += number;
    if ( hp > max_hp )
        hp = max_hp;
    if (hp <= 0 && !callingdeath) {
        callingdeath = time();
        call_out("do_death", 0, attacker, weapon, attack);
        for( i=0; i<sizeof(runaway_callout_handles); i++ ) {
            remove_call_out( runaway_callout_handles[i] );
        }
        runaway_callout_handles = ({ });
    }
    if (hp > 0 && number < 0 && attacker && attacker != this_object()) {
#ifdef USE_SURRENDER
        if(this_object()->query_surrender() >= this_object()->query_wimpy()) {
            if (!check_surrender())
                check_wimpy();
        }
        else {
            if (!check_wimpy())
                check_surrender();
        }
#else
        check_wimpy();
#endif
    }
    return hp;
}
varargs string health_string(int flag, int ref health_level) {
   int level;
   string ret;
   if ( this_object()->query_property( "dead" ) )  {
      ret = "appears to be dead";
      level = 0;
   }
   else if ( hp < max_hp / 10 )  {
      ret = "is in very bad shape";
      level = 1;
   }
   else if ( hp < max_hp / 5 )  {
      ret = "is in bad shape";
      level = 2;
   }
   else if ( hp < max_hp / 2 )  {
      ret = "is not in good shape";
      level = 3;
   }
   else if ( hp < ( max_hp - 200 ) )  {
      ret = "is slightly hurt";
      level = 4;
   }
   else  {
      ret = "is in good shape";
      level = 5;
   }
   if (!undefinedp(flag))   health_level = level;
   return ret;
}
int query_max_hp() { return max_hp; }
int set_max_hp( int number ) {
  int old_hp;
  old_hp = hp;
  if ( max_hp == hp )
    hp = number;
  else
    if ( max_hp )
      hp = ( hp * number ) / max_hp;
    else
      hp = number;
  max_hp = number;
  if ( hp > max_hp )
    hp = max_hp;
  if ( ( hp < 0 ) && ( old_hp > 0 ) )
    hp = max_hp;
  return max_hp;
}
int query_gp() { return gp; }
int query_specific_gp( string gp_type ) {
   int now;
   if ( !gp_type )
      return 0;
   max = (int)this_object()->query_skill_bonus( gp_type
         +".points" ) + 50;
   if ( max >= max_gp )
      max = max_gp;
   now = gp + max - max_gp;
   which = gp_type;
   if ( find_call_out( "clear_gp_info" ) == -1 )
      call_out( "clear_gp_info", 1 );
   return now;
}
void clear_gp_info() { which = 0; }
int set_gp( int number ) {
   gp = number;
   if ( gp > max_gp )
      gp = max_gp;
   return gp;
}
int adjust_gp( int number ) {
  int tmp, diff;
  string guild_ob, current_verb;
  mixed *bits;
  if ( gp + number < 0 )
    return -1;
  gp += number;
  if ( gp > max_gp )
    gp = max_gp;
  tmp = number;
  if((number < 0) && stringp(which)) {
    if (number > ( GP_ADVANCE_MOD * max ) / MIN_TIMES)
      number = (GP_ADVANCE_MOD * max) / MIN_TIMES;
    counts[ which ] -= number;
    if (counts[ which ] > GP_ADVANCE_MOD * max) {
      counts[ which ] = 0;
      number = this_object()->query_skill(which +".points");
      if(!random(to_int(exp(number/150.0))) &&
         this_object()->add_skill_level( which +".points", 1,
                                         this_object())) {
        tell_object( this_object(), "%^YELLOW%^You find yourself "
                     "more able to concentrate on this task than you "
                     "thought.%^RESET%^\n" );
      }
#ifdef POINTS_LOG
      log_file( "POINTS", time() +" "+
                (string)this_object()->query_name() +" gets "+
                which +" ("+ max +")\n" );
#endif
    }
    number = tmp;
    guild_ob = this_object()->query_guild_ob();
    if(guild_ob && member_array(query_verb(), guild_ob->query_commands()) != -1)
      number *= -10;
    else
      number *= -4;
    if(query_verb() == "pray" || query_verb() == "berserk" ||
       query_verb() == "spellcheck" || query_verb() == "octograve")
      number /= 2;
    current_verb = query_verb();
    if(current_verb == "cast" || current_verb == "perform") {
      current_verb = this_object()->query_current_cmd();
    }
    if(verbs[current_verb]) {
      bits = verbs[current_verb];
      diff = time() - bits[0];
      if(diff > 300)
        bits[1] /= 2;
      if(bits[1] < 1)
        bits[1] = 1;
      if(bits[1] > 1 && bits[2] == environment())
        bits[1] += 1;
      if(bits[1] < 10)
         number /= (random(bits[1]) + 1);
      else
        number = 0;
      verbs[current_verb] = ({ time(), bits[1]+1, environment() });
    } else {
      verbs[current_verb] = ({ time(), 1, environment() });
    }
    if(number)
      adjust_xp(number, 1);
#ifdef GUILD_XP
    log_file("GUILD_XP", "%s Gave %s %d points for %s [%s, %d]\n",
             ctime(time()), this_object()->query_name(), number,
             current_verb, verbs[current_verb][0], verbs[current_verb][1]);
#endif
  }
  return gp;
}
int query_max_gp() { return max_gp; }
int set_max_gp( int number ) {
  if ( max_gp ) gp = ( gp * number ) / max_gp;
  else gp = number;
  max_gp = number;
  if ( gp > max_gp ) gp = max_gp;
  return max_gp;
}
int query_xp() { return xp; }
varargs int adjust_xp( int number, int shared ) {
  if(number > 0 && (xp > 10000000 || xp + number > 10000000))
    return xp;
  if(number > 10000 && previous_object() &&
     explode(file_name(previous_object()), "/")[0] == "w")
    log_file("/d/admin/log/CHEAT", ctime(time()) + " " +
             file_name(previous_object()) +
             " gave " + number + " Xp for " + this_object()->query_name() +
             "\n");
   xp += number;
   return xp;
}
int query_wimpy() { return wimpy < 30 ? wimpy : 30; }
int set_wimpy( int number ) {
  if ( ( number < 0 ) || ( number > 30 ) ) return -1;
  return wimpy = number;
}
#ifdef USE_SURRENDER
int query_surrender() {
  if (surrender == -1) {
    if (wimpy > 94)
      return 100;
    else
      return wimpy + 5;
  } else
    return surrender;
}
int set_surrender( int number ) {
  if ( ( number < 0 ) || ( number > 100 ) ) return -1;
  return surrender = number;
}
#endif
int *query_drink_info() { return drink_info; }
int query_volume( int type ) {
  if ( type >= D_SIZEOF ) return 0;
  return drink_info[ type ];
}
int adjust_volume( int type, int amount ) {
  if ( type >= D_SIZEOF ) return 0;
  return drink_info[ type ] += amount;
}
void update_volumes() {
  int i, delta;
  delta = (int)this_object()->query_con();
  for ( i = 0; i < sizeof( drink_info ); i++ ) {
    if ( drink_info[ i ] > delta ) {
      drink_info[ i ] -= delta;
      if(this_object()->query_personal_temp() >  0 && i == D_DRINK)
  this_object()->adjust_personal_temp(-(delta/3));
      else if(this_object()->query_personal_temp() <  0 && i == D_FOOD)
  this_object()->adjust_personal_temp(delta/3);
    } else
      if ( drink_info[ i ] < -delta )
        drink_info[ i ] += delta;
      else
        drink_info[ i ] = 0;
  }
}
mapping query_counts() { return counts; }

==================================================
FILE: living/holding.c
==================================================

nosave mixed *_using;
nosave mixed *_weapons;
#define START_VALUE "1"
int *set_hold(object ob, int location, int limbs);
int *set_unhold(object ob);
private int sub_hold(object ob, int pos, int first);
void create()
{
   _weapons = ({ });
}
string *query_limbs()
{
   string race_ob;
   string *limbs;
   race_ob = this_object()->query_race_ob();
   if (!race_ob) {
      _using = ({ });
      return ({ });
   }
   limbs = race_ob->query_limbs();
   if (!_using) {
      _using = allocate(sizeof(limbs));
   }
   return limbs;
}
string* query_using_array() {
   return copy(_using);
}
object *query_holding()
{
   if (!arrayp(_using)) {
      query_limbs();
   }
   _using =
      map(_using, (: $1 ? (environment($1) == this_object()? $1 : 0) : 0 :));
   return copy(_using);
}
string* query_holding_limbs(object ob) {
   string* ret;
   int i;
   object* holding;
   string* limbs;
   ret = ({ });
   holding = query_holding();
   limbs = query_limbs();
   for (i = 0; i < sizeof(holding); i++) {
      if (holding[i] == ob) {
         ret += ({ limbs[i] });
      }
   }
   return ret;
}
int query_free_limbs()
{
   if (!arrayp(_using)) {
      query_limbs();
   }
   return
      sizeof(filter(_using, (: !$1 || environment($1) != this_object() :)));
}
object *query_weapons()
{
   return filter(_weapons, (: $1 :));
}
int *set_unhold(object ob)
{
   int *pos;
   if (!objectp(ob)) {
      return ({ });
   }
   if (member_array(ob, _using) == -1) {
      return ({ });
   }
   if (!ob->set_holder(0)) {
      return ({ });
   }
   pos = find_member(ob, _using);
   if (ob->query_weapon()) {
      _weapons = filter(_weapons, (: $1 != $(ob) :));
   }
   if (ob->query_armour()) {
      this_object()->remove_armour(ob);
   }
   _using = map(_using, (: $1 == $(ob) ? 0 : $1 :));
   this_object()->do_burden_call();
   return pos;
}
int *set_hold(object ob, int pos, int limbs)
{
   int limb_count;
   int *free = ({ });
   int *used = ({ });
   int total = 0;
   int temp = 0;
   int ok;
   int failed;
   if (environment(ob) != this_object()) {
      debug_printf("Bad environment");
      return ({ });
   }
   limb_count = sizeof(this_player()->query_limbs());
   if (!arrayp(_using)) {
      query_limbs();
   }
   if (pos == -1) {
      total = ob->query_no_limbs();
      if (total > this_object()->query_free_limbs()) {
         debug_printf("Too many limbs");
         return ({ });
      }
      free = find_member(0, _using);
      if (!sizeof (free)) {
        return ({ });
      }
      pos = free[0];
   }
   if (objectp(_using[pos]) && environment(_using[pos]) == this_object()) {
      return ({ });
   }
   ok = sub_hold(ob, pos, 1);
   if (ok) {
      used += ({ pos });
   } else {
      return ({ });
   }
   if(limbs)
     total = limbs - 1;
   else
     total = ob->query_no_limbs() - 1;
   free = find_member(0, _using);
   temp = 0;
   while (temp < total && temp < sizeof(free)) {
      if (temp > limb_count) {
         set_unhold(ob);
         return ({ });
      }
      sub_hold(ob, free[temp], 0);
      if (ok) {
         used += ({ free[temp] });
         temp++;
      } else {
         failed = 1;
      }
   }
   if (failed) {
      set_unhold(ob);
      return ({ });
   } else {
     this_object()->do_burden_call();
      return used;
   }
}
private int sub_hold(object ob,
                     int pos,
                     int first)
{
   int success;
   if (environment(ob) != this_object()) {
      return 0;
   }
   if (first) {
      success = ob->set_holder(this_object(), pos);
      if (!success) {
         return 0;
      }
   }
   _using[pos] = ob;
   if (ob->query_weapon()) {
      if (member_array(ob, _weapons) == -1) {
         _weapons += ({ ob });
      }
   }
   return 1;
}

==================================================
FILE: living/living.c
==================================================

#include <dirs.h>
#include <drinks.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>
#include <tune.h>
#include <position.h>
#include <obj_parser.h>
inherit "/std/container";
inherit "/std/living/armour";
inherit "/std/living/carrying";
inherit "/std/living/combat";
inherit "/std/living/force";
inherit "/std/living/gender";
inherit "/std/living/health";
inherit "/std/living/holding";
inherit "/std/living/money";
inherit "/std/living/skills";
inherit "/std/living/spells";
inherit "/std/living/crafts";
inherit "/std/living/stats";
inherit "/std/living/respond_cmd";
inherit "/std/living/nationality";
#define VERBOSE_TYPES ({"combat", "look", "score", "names", "htell", "finger", "errors", "quit"})
#define MAX_FAVOUR 100
class living_data {
  int handicap;
  int burden;
  object* followers;
  class obj_match_context it_them;
  object* to_drop;
  int burden_call;
}
class messages {
   string msgout;
   string msgin;
   string mmsgout;
   string mmsgin;
}
private int alignment;
private class messages _messages;
private mixed *facing;
private mapping verbose;
private mapping abs_facing = ABS_FACING;
private mapping lengthen = LENGTHEN;
private string deity;
private mapping deity_favour;
private nosave class living_data _liv_data;
void return_to_default_position(int leaving);
void set_position(string name);
void set_position_on(mixed ob);
void set_position_multiple(int mult);
void set_position_type(string type);
object query_position_on();
protected mixed command(string);
private nosave string position;
private nosave mixed default_position;
private
nosave int always_use_default_position;
private nosave mixed position_on;
void create() {
   string t;
   _liv_data = new(class living_data);
   _messages = new(class messages);
   crafts::create();
   container::create();
   armour::create();
   combat::create();
   health::create();
   holding::create();
   skills::create();
   spells::create();
   respond_cmd::create();
   enable_commands();
   reset_can_export_inventory();
   reset_effects();
   _messages->msgin = "$N arrive$s from $F.";
   _messages->msgout = "$N leave$s $T.";
   _messages->mmsgin = "$N appear$s out of the ground.";
   _messages->mmsgout = "$N disappear$s in a puff of smoke.";
   _liv_data->followers = ({ });
   verbose = ([ ]);
   set_max_items(50);
   _liv_data->to_drop = ({ });
   foreach(t in VERBOSE_TYPES) {
      verbose[t] = 1;
   }
   facing = ({ 0, ({ "north", "northeast", "east", "southeast", "south",
         "southwest", "west", "northwest" }), ({ "up", "down" }) });
   position = STANDING;
   add_adjective("living");
}
void heart_beat() {
  stats::heart_beat();
  combat::heart_beat();
}
string query_pronoun() {
   return gender::query_pronoun();
}
string query_possessive() {
   return gender::query_possessive();
}
string query_objective() {
   return gender::query_objective();
}
varargs int query_weight(int actual) {
  if(!actual && this_object()->query_property("dead"))
    return 0;
  return stats::query_weight();
}
int query_burden() {
  return _liv_data->burden;
}
int query_handicap() { return _liv_data->handicap; }
void calc_burden() {
  int new_handicap;
  int burden;
  object thing;
  mapping hands;
  _liv_data->burden_call = 0;
  update_loc_weight();
  burden = query_loc_weight();
  foreach(thing in query_wearing())
    burden -= (int)thing->query_complete_weight() / 2;
  hands = ([ ]);
  foreach(thing in query_holding())
    if(objectp(thing))
      hands[thing]++;
  foreach(thing in keys(hands))
    burden += (int)thing->query_complete_weight() / hands[thing];
  if(!query_max_weight()) {
    this_object()->reset_carry_cap();
    _liv_data->burden = 50;
  } else
    _liv_data->burden = (100 * burden) / query_max_weight();
  new_handicap = (_liv_data->burden / 25) - 1;
  if(new_handicap < 0)
    new_handicap = 0;
  if ( _liv_data->handicap != new_handicap ) {
    adjust_bonus_dex( _liv_data->handicap - new_handicap );
    _liv_data->handicap = new_handicap;
  }
}
string burden_string() {
  switch (_liv_data->handicap) {
  case 0 :
    return "unburdened";
  case 1 :
    return "burdened";
  case 2 :
    return "heavily burdened";
  case 3 :
    return "very heavily burdened";
  default :
    return "incredibly heavily burdened";
  }
}
void living_commands() {
#if efun_defined(add_action)
   add_action( "exit_command", "*", 1 );
#endif
}
void eat_this( object food ) {
  this_object()->bypass_queue();
  command( "eat " + file_name( food ) );
}
int test_add(object ob, int flag) {
  if(sizeof(all_inventory(this_object())) > query_max_items())
    return 0;
  return !flag;
}
int test_remove( object ob, int flag, mixed dest ) {
   object thing;
   if ( flag ) {
      return 0;
   }
   if ( !this_player() || ( this_player() == this_object() ) ) {
      return !flag;
   }
   if ( stringp( dest ) ) {
      thing = find_object( dest );
   }
   if ( objectp( dest ) ) {
      thing = dest;
      dest = file_name( dest );
   }
   if ( thing->query_corpse() || ( dest == "/room/rubbish" ) ) {
      return !flag;
   }
   if ( sizeof( filter_array( previous_object( -1 ),
         (: $1->query_theft_command() :) ) ) ) {
      return !flag;
   }
   if ( !query_property( PASSED_OUT ) ) {
      return 0;
   }
   if ( !pk_check( this_player(), this_object() ) ) {
      event( environment( this_player() ), "theft", this_player(),
            this_object(), ob );
      return !flag;
   }
   write( "An unseen force stays your hand.\n" );
   return 0;
}
int query_al() { return alignment; }
void set_al( int number ) { alignment = number; }
int adjust_al( int number ) {
   alignment += number;
   if ( alignment < -MAX_AL ) {
      alignment = -MAX_AL;
   }
   if ( alignment > MAX_AL ) {
      alignment = MAX_AL;
   }
   return alignment;
}
int adjust_alignment( int number ) {
  int change;
  change = - (number + alignment/5);
  change /= 20;
  return adjust_al( change );
}
string align_string() {
   switch ( alignment ) {
      case -MAX_AL .. -5001 : return "extremely good"; break;
      case -5000 .. -2501 : return "very good"; break;
      case -2500 .. -1251 : return "quite good"; break;
      case -1250 .. -601 : return "good"; break;
      case -600 .. -301 : return "barely good"; break;
      case -300 .. 300 : return "neutral"; break;
      case 301 .. 600 : return "barely evil"; break;
      case 601 .. 1250 : return "evil"; break;
      case 1251 .. 2500 : return "quite evil"; break;
      case 2501 .. 5000 : return "very evil"; break;
      default : return "extremely evil"; break;
   }
}
string query_deity() { return deity; }
void set_deity( string word ) { deity = word; }
string query_msgin() { return _messages->msgin; }
string query_msgout() { return _messages->msgout; }
int set_msgin(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$F") == -1) {
      return 0;
   }
   _messages->msgin = str;
   return 1;
}
int set_msgout(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$T") == -1) {
      return 0;
   }
   _messages->msgout = str;
   return 1;
}
string query_mmsgin() { return _messages->mmsgin; }
string query_mmsgout() { return _messages->mmsgout; }
int set_mmsgin(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgin = str;
   return 1;
}
int set_mmsgout(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgout = str;
   return 1;
}
mixed *query_facing() { return copy( facing ); }
void set_facing( mixed *args ) { facing = args; }
string find_rel( string word, int from ) {
  int i;
  i = member_array( word, facing[ 1 ] );
  if ( i != -1 ) {
    i = ( i + 8 - facing[ 0 ] ) % 8;
    return REL_DIRS[ 3 * i + from ];
  }
  i = member_array( word, facing[ 2 ] );
  if ( i != -1 ) {
    return ({ "up", "down" })[ i ];
  }
  return word;
}
string find_abs( string word ) {
  int i;
  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ]) % 8;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
}
string reorient_rel( string word ) {
  int i;
  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ] ) % 8;
    facing[ 0 ] = i;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
}
void reorient_abs( string verb ) {
  if ((ABS_FACING)[verb]) {
    facing[0] = (ABS_FACING)[verb] % 8;
  }
}
void set_dragging( object thing ) { add_property("dragging", thing); }
object query_dragging() { return query_property("dragging"); }
void reset_dragging() { add_property("dragging", 0); }
int room_look() {
   if ( query_property( UNKNOWN_MOVE ) || !( interactive( this_object() ) ||
         this_object()->query_slave() ) )
      return 0;
   if(!mapp(verbose))
     verbose = ([ ]);
   if(verbose && verbose["look"]) {
      this_object()->ignore_from_history( "look" );
      this_object()->bypass_queue();
      command( "look" );
   } else {
      this_object()->ignore_from_history( "glance" );
      this_object()->bypass_queue();
      command( "glance" );
   }
   return 1;
}
int query_verbose(string type) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  return verbose[type];
}
void set_verbose(string type, int val) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  if(member_array(type, VERBOSE_TYPES) != -1) {
    verbose[type] = val;
  }
}
string *query_verbose_types() {
  return VERBOSE_TYPES;
}
varargs int move_with_look( mixed dest, string messin, string messout ) {
   return_to_default_position(1);
   if ( (int)this_object()->move( dest, messin, messout ) != MOVE_OK )
      return 0;
   room_look();
   return_to_default_position(1);
   return 1;
}
varargs int exit_command( string word, mixed verb, object thing, int redirection ) {
   string special_mess, *bits, *exits, redirect;
   int temp;
   if ( !environment() ) {
      return 0;
   }
   if ( !verb ) {
      verb = word;
      bits = explode( word, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   } else {
      if ( pointerp( verb ) ) {
         special_mess = verb[ 1 ];
         verb = verb[ 0 ];
      }
      bits = explode( verb, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   }
   if ( lengthen[ verb ] ) {
      verb = lengthen[ verb ];
   }
   exits = (string *)environment()->query_exits();
   if ( !exits ) {
      return 0;
   }
   if ( member_array( verb, exits ) != -1 ) {
     if ( environment()->query_relative( verb ) ) {
       return 0;
     }
     if ((abs_facing)[verb]) {
       facing[0] = (abs_facing)[verb] % 8;
     }
   } else {
     if (member_array(find_abs(verb), exits ) == -1 ) {
       return 0;
     }
     verb = reorient_rel(verb);
   }
   if ( !thing ) {
      thing = this_object();
   }
    if ( !redirection ) {
        if ( stringp( redirect = thing->query_exit_redirection( word ) ) ) {
            if ( temp = this_object()->exit_command( verb, redirect, thing, 1 ) )
                return temp;
        }
    }
   return (int)"/obj/handlers/room_handler"->exit_move( verb, word,
         special_mess, thing );
}
void become_flummoxed() {
   int will;
   will = query_int() * query_wis();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_ritual();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_spell();
   if ( will < random( WILL_POWER ) )
      this_object()->stop_all_fight();
}
int run_away() {
   int i;
   object old_env;
   mixed *direcs;
   direcs = (mixed *)environment()->query_dest_dir(this_object());
   old_env = environment();
   while ( sizeof( direcs ) ) {
      i = random( sizeof( direcs ) / 2 ) * 2;
      if ( exit_command( direcs[i] ) ) {
          event( old_env, "run_away", direcs[ i ], direcs[ i + 1 ] );
          return 1;
      }
      direcs = delete( direcs, i, 2 );
   }
   return 0;
}
mixed *stats() {
   return container::stats() + stats::stats() + ({
           ({ "max_hp", max_hp }),
           ({ "hp",  hp }),
           ({ "max_gp", max_gp }),
           ({ "gp", gp }),
           ({ "alcohol", drink_info[ D_ALCOHOL ] }),
           ({ "food", drink_info[ D_FOOD ] }),
           ({ "drink", drink_info[ D_DRINK ] }),
           ({ "gender", query_gender_string() }),
           ({ "alignment", this_object()->query_al() }),
           ({ "deity", deity }),
           ({ "total money", query_value() }),
           ({ "xp", query_xp() }),
   }) + armour::stats() + combat::stats();
}
class obj_match_context query_it_them() { return _liv_data->it_them; }
void set_it_them( class obj_match_context args) { _liv_data->it_them = args; }
int add_follower(object ob) {
  if (ob == this_object()) {
    return 0;
  }
  if (member_array(ob, _liv_data->followers) == -1) {
    _liv_data->followers += ({ ob });
  }
  return 1;
}
int remove_follower(object ob) {
  int i;
  i = member_array(ob, _liv_data->followers);
  if (i != -1) {
    _liv_data->followers = delete(_liv_data->followers, i, 1);
    return 1;
  }
  return 0;
}
int check_doing_follow(object thing, string verb, string special) {
   return 1;
}
object query_current_room() { return environment(); }
mixed *query_followers() { return copy(_liv_data->followers - ({ 0 })); }
varargs void adjust_money(mixed amt, string type) {
  return money::adjust_money(amt, type);
}
mixed *query_money_array() {
  return money::query_money_array();
}
int query_money(string type) {
  return money::query_money(type);
}
int query_value() { return money::query_value(); }
void do_burden_call() {
  if(_liv_data->burden_call)
    remove_call_out(_liv_data->burden_call);
  _liv_data->burden_call = call_out("calc_burden", 1);
}
int query_burden_limit() {
  if (this_object()->query_creator()) {
    return MAX_CREATOR_INVEN;
  } else {
    return MAX_INVEN;
  }
}
void event_enter( object thing, string mess, object from ) {
  if(environment( thing ) == this_object()) {
    do_burden_call();
    if(sizeof(all_inventory()) > query_burden_limit() ) {
      _liv_data->to_drop += ({ thing });
      remove_call_out("test_number_of_items");
      call_out("test_number_of_items", 5 + random(5));
    }
  }
}
void event_exit( object thing, string mess, object to ) {
  if(environment(thing) == this_object()) {
    do_burden_call();
  }
}
void test_number_of_items() {
   int how_many;
   object thing, *things, *dropped;
   things = all_inventory() - query_armours() - query_holding();
   how_many = sizeof(things) - query_burden_limit();
   if ( how_many < 1 ) {
      return;
   }
   _liv_data->to_drop -= ({ 0 });
   dropped = ({ });
   while(how_many > 0 && sizeof(things)) {
      if (sizeof(_liv_data->to_drop)) {
         thing = _liv_data->to_drop[random(sizeof(_liv_data->to_drop))];
      } else {
         thing = things[random(sizeof(things))];
      }
      things -= ({ thing });
      _liv_data->to_drop -= ({ thing });
      if(!thing || !thing->short() || thing->drop() ||
         thing->query_property("cannot fumble") ||
         thing->id("coin") ||
         environment(thing) != this_object()) {
        continue;
      }
      if((int)thing->move(environment()) == MOVE_OK) {
        how_many--;
        dropped += ({ thing });
      }
   }
   _liv_data->to_drop = ({ });
   if(sizeof(dropped)) {
     tell_object( this_object(), "Whoops!  You tried to carry too many "
                  "things and fumbled "+
                  query_multiple_short( dropped ) +".\n" );
     this_object()->dest_hide_shadow();
     tell_room( environment(), capitalize( the_short() ) +" juggles "+
                "around "+ query_possessive() +" stuff and fumbles "+
                query_multiple_short( dropped ) +".\n", this_object() );
   }
}
void force_burden_recalculate() {
   do_burden_call();
   remove_call_out("test_number_of_items");
   call_out("test_number_of_items", 5 + random(5));
}
object *find_inv_match( string words, object looker ) {
   return sort_array( container::find_inv_match( words, looker ),
         (: ( member_array( $1, query_holding() ) != -1 ? -1 : 0 ) :) );
}
int attack_by(object ob) {
   return_to_default_position(0);
   return ::attack_by(ob);
}
int attack_ob(object ob) {
   return_to_default_position(0);
   return ::attack_ob(ob);
}
void set_always_use_default_position(int flag) {
   always_use_default_position = flag;
}
int query_always_use_default_position() {
   return always_use_default_position;
}
string query_default_position() {
   mixed pos;
   if (stringp(default_position) &&
              default_position->query_position_command()) {
      pos = default_position;
   } else if (pointerp(default_position) &&
              (sizeof(default_position) == POSITION_MESS_SIZE ||
               sizeof(default_position) == POSITION_ONLY_TYPE_SIZE)) {
      pos = default_position;
   } else if (functionp(default_position)) {
      pos = default_position;
   }
   if (!pos) {
      pos = STANDING_CMD;
   }
   return pos;
}
void set_default_position(mixed str) {
   if (stringp(str) && str->query_position_command() && str != STANDING_CMD) {
      default_position = str;
   } else if (!str || str == STANDING_CMD) {
      default_position = 0;
   } else if (pointerp(str) && (sizeof(str) == POSITION_ONLY_TYPE_SIZE ||
                                sizeof(str) == POSITION_MESS_SIZE)) {
      default_position = str;
   } else if (functionp(str)) {
      default_position = str;
   }
}
void return_to_default_position(int leaving) {
   mixed pos;
   if (query_always_use_default_position()) {
      pos = query_default_position();
   } else {
      pos = 0;
      if (environment()) {
         pos = environment()->query_default_position(this_object());
      }
      if (!pos) {
         pos = query_default_position();
      }
   }
   if (functionp(pos)) {
      if (!evaluate(pos, this_object(), leaving)) {
         pos = 0;
         if (environment()) {
            pos = environment()->query_default_position(this_object());
         }
         if (!pos) {
            pos = STANDING_CMD;
         }
      }
   }
   if (stringp(pos)) {
      if (position != pos->query_position_type() ||
          (leaving && query_position_on())) {
         if (leaving) {
            catch(pos->position_floor(this_object()));
         } else {
            catch(pos->position(this_object()));
         }
      }
   } else if (pointerp(pos) && position != pos[POSITION_TYPE_INDEX]) {
      if (sizeof(pos) > 1) {
         if (pos[POSITION_ME_MESS_INDEX]) {
            tell_object(this_object(), pos[POSITION_ME_MESS_INDEX]);
         }
         if (pos[POSITION_REST_MESS]) {
            tell_room(environment(), pos[POSITION_REST_MESS], this_object());
         }
      }
      set_position(pos[POSITION_TYPE_INDEX]);
      set_position_on(0);
      set_position_type(0);
      set_position_multiple(0);
   }
}
void set_position(string name) {
   position = name;
}
string query_position() {
   return position;
}
void set_position_on(mixed ob) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_ON_OBJECT] = ob;
}
void set_position_multiple(int mult) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_MULTIPLE] = mult;
}
int query_position_multiple() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_MULTIPLE];
}
void set_position_type(string type) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_TYPE] = type;
}
string query_position_type() {
   if (!position_on ||
       !position_on[POS_TYPE]) {
      return "on";
   }
   return position_on[POS_TYPE];
}
object query_position_on() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_ON_OBJECT];
}
string query_position_on_short() {
   if (!position_on || !position_on[POS_ON_OBJECT]) {
      return "";
   }
   if (stringp(position_on[POS_ON_OBJECT])) {
      return position_on[POS_ON_OBJECT];
   }
   return position_on[POS_ON_OBJECT]->the_short();
}
string query_position_long() {
   if (position != STANDING || position_on) {
      if (position_on) {
         return query_pronoun() + " is " + query_position_type() + " "+
                query_position_on_short()+".\n";
      }
      return query_pronoun()+" is "+position+" on the floor.\n";
   }
   return "";
}
string query_position_short() {
   if (!position_on ||
       !position_on[POS_ON_OBJECT]) {
      return position;
   }
   return position + " " + query_position_type() + " " +
          query_position_on_short();
}
varargs int cannot_walk( string verb, mixed *dest_other) {
   return 0;
}
string *query_arcane_shields() { return ({ }); }
int can_find_match_reference_inside_object(object thing, object looker) {
   if (member_array(thing, query_wearing_hidden(looker, 0)) != -1) {
      return 0;
   }
   return 1;
}
int query_deity_favour( string god ) {
  if ( !mapp( deity_favour ) )
    return 0;
  if ( !undefinedp( deity_favour[ god ] ) )
    return 0;
  return deity_favour[ god ];
}
void adjust_deity_favour( string god, int amount ) {
  if ( !mapp( deity_favour ) )
    deity_favour = ([ ]);
  if ( !undefinedp( deity_favour[ god ] ) )
    deity_favour[ god ] = amount;
  deity_favour[ god ] += amount;
  if ( deity_favour[ god ] > MAX_FAVOUR )
    deity_favour[ god ] = MAX_FAVOUR;
  if ( deity_favour[ god ] < -MAX_FAVOUR )
    deity_favour[ god ] = -MAX_FAVOUR;
  return;
}
mapping query_all_deity_favour() { return deity_favour; }

==================================================
FILE: living/living.eff_shad.c
==================================================

#include <dirs.h>
#include <drinks.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>
#include <tune.h>
#include <position.h>
#include <obj_parser.h>
inherit "/std/container";
inherit "/std/living/armour";
inherit "/std/living/carrying";
inherit "/std/living/combat";
inherit "/std/living/effects";
inherit "/std/living/force";
inherit "/std/living/gender";
inherit "/std/living/health";
inherit "/std/living/holding";
inherit "/std/living/money";
inherit "/std/living/skills";
inherit "/std/living/spells";
inherit "/std/living/crafts";
inherit "/std/living/stats";
inherit "/std/living/respond_cmd";
inherit "/std/living/nationality";
#define VERBOSE_TYPES ({"combat", "look", "score", "names", "htell", "finger"})
#define MAX_FAVOUR 100
class living_data {
  int handicap;
  int burden;
  object* followers;
  class obj_match_context it_them;
  object* to_drop;
  int burden_call;
}
class messages {
   string msgout;
   string msgin;
   string mmsgout;
   string mmsgin;
}
private int alignment;
private class messages _messages;
private mixed *facing;
private mapping verbose;
private mapping abs_facing = ABS_FACING;
private mapping lengthen = LENGTHEN;
private string deity;
private mapping deity_favour;
private nosave class living_data _liv_data;
void return_to_default_position(int leaving);
void set_position(string name);
void set_position_on(mixed ob);
void set_position_multiple(int mult);
void set_position_type(string type);
object query_position_on();
protected mixed command(string);
private nosave string position;
private nosave mixed default_position;
private
nosave int always_use_default_position;
private nosave mixed position_on;
void create() {
   string t;
   _liv_data = new(class living_data);
   _messages = new(class messages);
   crafts::create();
   container::create();
   armour::create();
   combat::create();
   effects::create();
   health::create();
   holding::create();
   skills::create();
   spells::create();
   respond_cmd::create();
   enable_commands();
   reset_can_export_inventory();
   reset_effects();
   _messages->msgin = "$N arrive$s from $F.";
   _messages->msgout = "$N leave$s $T.";
   _messages->mmsgin = "$N appear$s out of the ground.";
   _messages->mmsgout = "$N disappear$s in a puff of smoke.";
   _liv_data->followers = ({ });
   verbose = ([ ]);
   set_max_items(50);
   _liv_data->to_drop = ({ });
   foreach(t in VERBOSE_TYPES) {
      verbose[t] = 1;
   }
   facing = ({ 0, ({ "north", "northeast", "east", "southeast", "south",
         "southwest", "west", "northwest" }), ({ "up", "down" }) });
   position = STANDING;
   add_adjective("living");
}
void heart_beat() {
  stats::heart_beat();
  combat::heart_beat();
}
string query_pronoun() {
   return gender::query_pronoun();
}
string query_possessive() {
   return gender::query_possessive();
}
string query_objective() {
   return gender::query_objective();
}
varargs int query_weight(int actual) {
  if(!actual && this_object()->query_property("dead"))
    return 0;
  return stats::query_weight();
}
int query_burden() {
  return _liv_data->burden;
}
int query_handicap() { return _liv_data->handicap; }
void calc_burden() {
  int new_handicap;
  int burden;
  object thing;
  mapping hands;
  _liv_data->burden_call = 0;
  update_loc_weight();
  burden = query_loc_weight();
  foreach(thing in query_wearing())
    burden -= (int)thing->query_complete_weight() / 2;
  hands = ([ ]);
  foreach(thing in query_holding())
    if(objectp(thing))
      hands[thing]++;
  foreach(thing in keys(hands))
    burden += (int)thing->query_complete_weight() / hands[thing];
  if(!query_max_weight()) {
    this_object()->reset_carry_cap();
    _liv_data->burden = 50;
  } else
    _liv_data->burden = (100 * burden) / query_max_weight();
  new_handicap = (_liv_data->burden / 25) - 1;
  if(new_handicap < 0)
    new_handicap = 0;
  if ( _liv_data->handicap != new_handicap ) {
    adjust_bonus_dex( _liv_data->handicap - new_handicap );
    _liv_data->handicap = new_handicap;
  }
}
string burden_string() {
  switch (_liv_data->handicap) {
  case 0 :
    return "unburdened";
  case 1 :
    return "burdened";
  case 2 :
    return "heavily burdened";
  case 3 :
    return "very heavily burdened";
  default :
    return "incredibly heavily burdened";
  }
}
void add_effect( string eff, mixed arg ) { effects::add_effect( eff, arg ); }
void living_commands() {
#if efun_defined(add_action)
   add_action( "exit_command", "*", 1 );
#endif
}
void eat_this( object food ) {
  this_object()->bypass_queue();
  command( "eat " + file_name( food ) );
}
int test_add(object ob, int flag) {
  if(sizeof(all_inventory(this_object())) > query_max_items())
    return 0;
  return !flag;
}
int test_remove( object ob, int flag, mixed dest ) {
   object thing;
   if ( flag ) {
      return 0;
   }
   if ( !this_player() || ( this_player() == this_object() ) ) {
      return !flag;
   }
   if ( stringp( dest ) ) {
      thing = find_object( dest );
   }
   if ( objectp( dest ) ) {
      thing = dest;
      dest = file_name( dest );
   }
   if ( thing->query_corpse() || ( dest == "/room/rubbish" ) ) {
      return !flag;
   }
   if ( sizeof( filter_array( previous_object( -1 ),
         (: $1->query_theft_command() :) ) ) ) {
      return !flag;
   }
   if ( !query_property( PASSED_OUT ) ) {
      return 0;
   }
   if ( !pk_check( this_player(), this_object() ) ) {
      event( environment( this_player() ), "theft", this_player(),
            this_object(), ob );
      return !flag;
   }
   write( "An unseen force stays your hand.\n" );
   return 0;
}
int query_al() { return alignment; }
void set_al( int number ) { alignment = number; }
int adjust_al( int number ) {
   alignment += number;
   if ( alignment < -MAX_AL ) {
      alignment = -MAX_AL;
   }
   if ( alignment > MAX_AL ) {
      alignment = MAX_AL;
   }
   return alignment;
}
int adjust_alignment( int number ) {
  int change;
  change = - (number + alignment/5);
  change /= 20;
  return adjust_al( change );
}
string align_string() {
   switch ( alignment ) {
      case -MAX_AL .. -5001 : return "extremely good"; break;
      case -5000 .. -2501 : return "very good"; break;
      case -2500 .. -1251 : return "quite good"; break;
      case -1250 .. -601 : return "good"; break;
      case -600 .. -301 : return "barely good"; break;
      case -300 .. 300 : return "neutral"; break;
      case 301 .. 600 : return "barely evil"; break;
      case 601 .. 1250 : return "evil"; break;
      case 1251 .. 2500 : return "quite evil"; break;
      case 2501 .. 5000 : return "very evil"; break;
      default : return "extremely evil"; break;
   }
}
string query_deity() { return deity; }
void set_deity( string word ) { deity = word; }
string query_msgin() { return _messages->msgin; }
string query_msgout() { return _messages->msgout; }
int set_msgin(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$F") == -1) {
      return 0;
   }
   _messages->msgin = str;
   return 1;
}
int set_msgout(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$T") == -1) {
      return 0;
   }
   _messages->msgout = str;
   return 1;
}
string query_mmsgin() { return _messages->mmsgin; }
string query_mmsgout() { return _messages->mmsgout; }
int set_mmsgin(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgin = str;
   return 1;
}
int set_mmsgout(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgout = str;
   return 1;
}
mixed *query_facing() { return copy( facing ); }
void set_facing( mixed *args ) { facing = args; }
string find_rel( string word, int from ) {
  int i;
  i = member_array( word, facing[ 1 ] );
  if ( i != -1 ) {
    i = ( i + 8 - facing[ 0 ] ) % 8;
    return REL_DIRS[ 3 * i + from ];
  }
  i = member_array( word, facing[ 2 ] );
  if ( i != -1 ) {
    return ({ "up", "down" })[ i ];
  }
  return word;
}
string find_abs( string word ) {
  int i;
  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ]) % 8;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
}
string reorient_rel( string word ) {
  int i;
  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ] ) % 8;
    facing[ 0 ] = i;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
}
void reorient_abs( string verb ) {
  if ((ABS_FACING)[verb]) {
    facing[0] = (ABS_FACING)[verb] % 8;
  }
}
void set_dragging( object thing ) { add_property("dragging", thing); }
object query_dragging() { return query_property("dragging"); }
void reset_dragging() { add_property("dragging", 0); }
int room_look() {
   if ( query_property( UNKNOWN_MOVE ) || !( interactive( this_object() ) ||
         this_object()->query_slave() ) )
      return 0;
   if(!mapp(verbose))
     verbose = ([ ]);
   if(verbose && verbose["look"]) {
      this_object()->ignore_from_history( "look" );
      this_object()->bypass_queue();
      command( "look" );
   } else {
      this_object()->ignore_from_history( "glance" );
      this_object()->bypass_queue();
      command( "glance" );
   }
   return 1;
}
int query_verbose(string type) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  return verbose[type];
}
void set_verbose(string type, int val) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  if(member_array(type, VERBOSE_TYPES) != -1) {
    verbose[type] = val;
  }
}
string *query_verbose_types() {
  return VERBOSE_TYPES;
}
varargs int move_with_look( mixed dest, string messin, string messout ) {
   return_to_default_position(1);
   if ( (int)this_object()->move( dest, messin, messout ) != MOVE_OK )
      return 0;
   room_look();
   return_to_default_position(1);
   return 1;
}
varargs int exit_command( string word, mixed verb, object thing, int redirection ) {
   string special_mess, *bits, *exits, redirect;
   int temp;
   if ( !environment() ) {
      return 0;
   }
   if ( !verb ) {
      verb = word;
      bits = explode( word, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   } else {
      if ( pointerp( verb ) ) {
         special_mess = verb[ 1 ];
         verb = verb[ 0 ];
      }
      bits = explode( verb, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   }
   if ( lengthen[ verb ] ) {
      verb = lengthen[ verb ];
   }
   exits = (string *)environment()->query_exits();
   if ( !exits ) {
      return 0;
   }
   if ( member_array( verb, exits ) != -1 ) {
     if ( environment()->query_relative( verb ) ) {
       return 0;
     }
     if ((abs_facing)[verb]) {
       facing[0] = (abs_facing)[verb] % 8;
     }
   } else {
     if (member_array(find_abs(verb), exits ) == -1 ) {
       return 0;
     }
     verb = reorient_rel(verb);
   }
   if ( !thing ) {
      thing = this_object();
   }
    if ( !redirection ) {
        if ( stringp( redirect = thing->query_exit_redirection( word ) ) ) {
            if ( temp = this_object()->exit_command( verb, redirect, thing, 1 ) )
                return temp;
        }
    }
   return (int)"/obj/handlers/room_handler"->exit_move( verb, word,
         special_mess, thing );
}
void become_flummoxed() {
   int will;
   will = query_int() * query_wis();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_ritual();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_spell();
   if ( will < random( WILL_POWER ) )
      this_object()->stop_all_fight();
}
int run_away() {
   int i;
   object old_env;
   mixed *direcs;
   direcs = (mixed *)environment()->query_dest_dir(this_object());
   old_env = environment();
   while ( sizeof( direcs ) ) {
      i = random( sizeof( direcs ) / 2 ) * 2;
      if ( exit_command( direcs[i] ) ) {
          event( old_env, "run_away", direcs[ i ], direcs[ i + 1 ] );
          return 1;
      }
      direcs = delete( direcs, i, 2 );
   }
   return 0;
}
mixed *stats() {
   return container::stats() + stats::stats() + ({
           ({ "max_hp", max_hp }),
           ({ "hp",  hp }),
           ({ "max_gp", max_gp }),
           ({ "gp", gp }),
           ({ "alcohol", drink_info[ D_ALCOHOL ] }),
           ({ "food", drink_info[ D_FOOD ] }),
           ({ "drink", drink_info[ D_DRINK ] }),
           ({ "gender", query_gender_string() }),
           ({ "alignment", this_object()->query_al() }),
           ({ "deity", deity }),
           ({ "total money", query_value() }),
           ({ "xp", query_xp() }),
   }) + armour::stats() + combat::stats() + (mixed *)effects::stats();
}
class obj_match_context query_it_them() { return _liv_data->it_them; }
void set_it_them( class obj_match_context args) { _liv_data->it_them = args; }
int add_follower(object ob) {
  if (ob == this_object()) {
    return 0;
  }
  if (member_array(ob, _liv_data->followers) == -1) {
    _liv_data->followers += ({ ob });
  }
  return 1;
}
int remove_follower(object ob) {
  int i;
  i = member_array(ob, _liv_data->followers);
  if (i != -1) {
    _liv_data->followers = delete(_liv_data->followers, i, 1);
    return 1;
  }
  return 0;
}
int check_doing_follow(object thing, string verb, string special) {
   return 1;
}
object query_current_room() { return environment(); }
mixed *query_followers() { return copy(_liv_data->followers - ({ 0 })); }
varargs void adjust_money(mixed amt, string type) {
  return money::adjust_money(amt, type);
}
mixed *query_money_array() {
  return money::query_money_array();
}
int query_money(string type) {
  return money::query_money(type);
}
int query_value() { return money::query_value(); }
void do_burden_call() {
  if(_liv_data->burden_call)
    remove_call_out(_liv_data->burden_call);
  _liv_data->burden_call = call_out("calc_burden", 1);
}
int query_burden_limit() {
  if (this_object()->query_creator()) {
    return MAX_CREATOR_INVEN;
  } else {
    return MAX_INVEN;
  }
}
void event_enter( object thing, string mess, object from ) {
  if(environment( thing ) == this_object()) {
    do_burden_call();
    if(sizeof(all_inventory()) > query_burden_limit() ) {
      _liv_data->to_drop += ({ thing });
      remove_call_out("test_number_of_items");
      call_out("test_number_of_items", 5 + random(5));
    }
  }
}
void event_exit( object thing, string mess, object to ) {
  if(environment(thing) == this_object()) {
    do_burden_call();
  }
}
void test_number_of_items() {
   int how_many;
   object thing, *things, *dropped;
   things = all_inventory() - query_armours() - query_holding();
   how_many = sizeof(things) - query_burden_limit();
   if ( how_many < 1 ) {
      return;
   }
   _liv_data->to_drop -= ({ 0 });
   dropped = ({ });
   while(how_many > 0 && sizeof(things)) {
      if (sizeof(_liv_data->to_drop)) {
         thing = _liv_data->to_drop[random(sizeof(_liv_data->to_drop))];
      } else {
         thing = things[random(sizeof(things))];
      }
      things -= ({ thing });
      _liv_data->to_drop -= ({ thing });
      if(!thing || !thing->short() || thing->drop() ||
         thing->query_property("cannot fumble") ||
         thing->id("coin") ||
         environment(thing) != this_object()) {
        continue;
      }
      if((int)thing->move(environment()) == MOVE_OK) {
        how_many--;
        dropped += ({ thing });
      }
   }
   _liv_data->to_drop = ({ });
   if(sizeof(dropped)) {
     tell_object( this_object(), "Whoops!  You tried to carry too many "
                  "things and fumbled "+
                  query_multiple_short( dropped ) +".\n" );
     this_object()->dest_hide_shadow();
     tell_room( environment(), capitalize( the_short() ) +" juggles "+
                "around "+ query_possessive() +" stuff and fumbles "+
                query_multiple_short( dropped ) +".\n", this_object() );
   }
}
void force_burden_recalculate() {
   do_burden_call();
   remove_call_out("test_number_of_items");
   call_out("test_number_of_items", 5 + random(5));
}
object *find_inv_match( string words, object looker ) {
   return sort_array( container::find_inv_match( words, looker ),
         (: ( member_array( $1, query_holding() ) != -1 ? -1 : 0 ) :) );
}
int attack_by(object ob) {
   return_to_default_position(0);
   return ::attack_by(ob);
}
int attack_ob(object ob) {
   return_to_default_position(0);
   return ::attack_ob(ob);
}
void set_always_use_default_position(int flag) {
   always_use_default_position = flag;
}
int query_always_use_default_position() {
   return always_use_default_position;
}
string query_default_position() {
   mixed pos;
   if (stringp(default_position) &&
              default_position->query_position_command()) {
      pos = default_position;
   } else if (pointerp(default_position) &&
              (sizeof(default_position) == POSITION_MESS_SIZE ||
               sizeof(default_position) == POSITION_ONLY_TYPE_SIZE)) {
      pos = default_position;
   } else if (functionp(default_position)) {
      pos = default_position;
   }
   if (!pos) {
      pos = STANDING_CMD;
   }
   return pos;
}
void set_default_position(mixed str) {
   if (stringp(str) && str->query_position_command() && str != STANDING_CMD) {
      default_position = str;
   } else if (!str || str == STANDING_CMD) {
      default_position = 0;
   } else if (pointerp(str) && (sizeof(str) == POSITION_ONLY_TYPE_SIZE ||
                                sizeof(str) == POSITION_MESS_SIZE)) {
      default_position = str;
   } else if (functionp(str)) {
      default_position = str;
   }
}
void return_to_default_position(int leaving) {
   mixed pos;
   if (query_always_use_default_position()) {
      pos = query_default_position();
   } else {
      pos = 0;
      if (environment()) {
         pos = environment()->query_default_position(this_object());
      }
      if (!pos) {
         pos = query_default_position();
      }
   }
   if (functionp(pos)) {
      if (!evaluate(pos, this_object(), leaving)) {
         pos = 0;
         if (environment()) {
            pos = environment()->query_default_position(this_object());
         }
         if (!pos) {
            pos = STANDING_CMD;
         }
      }
   }
   if (stringp(pos)) {
      if (position != pos->query_position_type() ||
          (leaving && query_position_on())) {
         if (leaving) {
            catch(pos->position_floor(this_object()));
         } else {
            catch(pos->position(this_object()));
         }
      }
   } else if (pointerp(pos) && position != pos[POSITION_TYPE_INDEX]) {
      if (sizeof(pos) > 1) {
         if (pos[POSITION_ME_MESS_INDEX]) {
            tell_object(this_object(), pos[POSITION_ME_MESS_INDEX]);
         }
         if (pos[POSITION_REST_MESS]) {
            tell_room(environment(), pos[POSITION_REST_MESS], this_object());
         }
      }
      set_position(pos[POSITION_TYPE_INDEX]);
      set_position_on(0);
      set_position_type(0);
      set_position_multiple(0);
   }
}
void set_position(string name) {
   position = name;
}
string query_position() {
   return position;
}
void set_position_on(mixed ob) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_ON_OBJECT] = ob;
}
void set_position_multiple(int mult) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_MULTIPLE] = mult;
}
int query_position_multiple() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_MULTIPLE];
}
void set_position_type(string type) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_TYPE] = type;
}
string query_position_type() {
   if (!position_on ||
       !position_on[POS_TYPE]) {
      return "on";
   }
   return position_on[POS_TYPE];
}
object query_position_on() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_ON_OBJECT];
}
string query_position_on_short() {
   if (!position_on || !position_on[POS_ON_OBJECT]) {
      return "";
   }
   if (stringp(position_on[POS_ON_OBJECT])) {
      return position_on[POS_ON_OBJECT];
   }
   return position_on[POS_ON_OBJECT]->the_short();
}
string query_position_long() {
   if (position != STANDING || position_on) {
      if (position_on) {
         return query_pronoun() + " is " + query_position_type() + " "+
                query_position_on_short()+".\n";
      }
      return query_pronoun()+" is "+position+" on the floor.\n";
   }
   return "";
}
string query_position_short() {
   if (!position_on ||
       !position_on[POS_ON_OBJECT]) {
      return position;
   }
   return position + " " + query_position_type() + " " +
          query_position_on_short();
}
varargs int cannot_walk( string verb, mixed *dest_other) {
   return 0;
}
string *query_arcane_shields() { return ({ }); }
int can_find_match_reference_inside_object(object thing, object looker) {
   if (member_array(thing, query_wearing_hidden(looker, 0)) != -1) {
      return 0;
   }
   return 1;
}
int query_deity_favour( string god ) {
  if ( !mapp( deity_favour ) )
    return 0;
  if ( !undefinedp( deity_favour[ god ] ) )
    return 0;
  return deity_favour[ god ];
}
void adjust_deity_favour( string god, int amount ) {
  if ( !mapp( deity_favour ) )
    deity_favour = ([ ]);
  if ( !undefinedp( deity_favour[ god ] ) )
    deity_favour[ god ] = amount;
  deity_favour[ god ] += amount;
  if ( deity_favour[ god ] > MAX_FAVOUR )
    deity_favour[ god ] = MAX_FAVOUR;
  if ( deity_favour[ god ] < -MAX_FAVOUR )
    deity_favour[ god ] = -MAX_FAVOUR;
  return;
}
mapping query_all_deity_favour() { return deity_favour; }

==================================================
FILE: living/living.no_eff_shad.c
==================================================

#include <dirs.h>
#include <drinks.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>
#include <tune.h>
#include <position.h>
#include <obj_parser.h>
inherit "/std/container";
inherit "/std/living/armour";
inherit "/std/living/carrying";
inherit "/std/living/combat";
inherit "/std/living/force";
inherit "/std/living/gender";
inherit "/std/living/health";
inherit "/std/living/holding";
inherit "/std/living/money";
inherit "/std/living/skills";
inherit "/std/living/spells";
inherit "/std/living/crafts";
inherit "/std/living/stats";
inherit "/std/living/respond_cmd";
inherit "/std/living/nationality";
#define VERBOSE_TYPES ({"combat", "look", "score", "names", "htell", "finger"})
#define MAX_FAVOUR 100
class living_data {
  int handicap;
  int burden;
  object* followers;
  class obj_match_context it_them;
  object* to_drop;
  int burden_call;
}
class messages {
   string msgout;
   string msgin;
   string mmsgout;
   string mmsgin;
}
private int alignment;
private class messages _messages;
private mixed *facing;
private mapping verbose;
private mapping abs_facing = ABS_FACING;
private mapping lengthen = LENGTHEN;
private string deity;
private mapping deity_favour;
private nosave class living_data _liv_data;
void return_to_default_position(int leaving);
void set_position(string name);
void set_position_on(mixed ob);
void set_position_multiple(int mult);
void set_position_type(string type);
object query_position_on();
protected mixed command(string);
private nosave string position;
private nosave mixed default_position;
private
nosave int always_use_default_position;
private nosave mixed position_on;
void create() {
   string t;
   _liv_data = new(class living_data);
   _messages = new(class messages);
   crafts::create();
   container::create();
   armour::create();
   combat::create();
   health::create();
   holding::create();
   skills::create();
   spells::create();
   respond_cmd::create();
   enable_commands();
   reset_can_export_inventory();
   reset_effects();
   _messages->msgin = "$N arrive$s from $F.";
   _messages->msgout = "$N leave$s $T.";
   _messages->mmsgin = "$N appear$s out of the ground.";
   _messages->mmsgout = "$N disappear$s in a puff of smoke.";
   _liv_data->followers = ({ });
   verbose = ([ ]);
   set_max_items(50);
   _liv_data->to_drop = ({ });
   foreach(t in VERBOSE_TYPES) {
      verbose[t] = 1;
   }
   facing = ({ 0, ({ "north", "northeast", "east", "southeast", "south",
         "southwest", "west", "northwest" }), ({ "up", "down" }) });
   position = STANDING;
   add_adjective("living");
}
void heart_beat() {
  stats::heart_beat();
  combat::heart_beat();
}
string query_pronoun() {
   return gender::query_pronoun();
}
string query_possessive() {
   return gender::query_possessive();
}
string query_objective() {
   return gender::query_objective();
}
varargs int query_weight(int actual) {
  if(!actual && this_object()->query_property("dead"))
    return 0;
  return stats::query_weight();
}
int query_burden() {
  return _liv_data->burden;
}
int query_handicap() { return _liv_data->handicap; }
void calc_burden() {
  int new_handicap;
  int burden;
  object thing;
  mapping hands;
  _liv_data->burden_call = 0;
  update_loc_weight();
  burden = query_loc_weight();
  foreach(thing in query_wearing())
    burden -= (int)thing->query_complete_weight() / 2;
  hands = ([ ]);
  foreach(thing in query_holding())
    if(objectp(thing))
      hands[thing]++;
  foreach(thing in keys(hands))
    burden += (int)thing->query_complete_weight() / hands[thing];
  if(!query_max_weight()) {
    this_object()->reset_carry_cap();
    _liv_data->burden = 50;
  } else
    _liv_data->burden = (100 * burden) / query_max_weight();
  new_handicap = (_liv_data->burden / 25) - 1;
  if(new_handicap < 0)
    new_handicap = 0;
  if ( _liv_data->handicap != new_handicap ) {
    adjust_bonus_dex( _liv_data->handicap - new_handicap );
    _liv_data->handicap = new_handicap;
  }
}
string burden_string() {
  switch (_liv_data->handicap) {
  case 0 :
    return "unburdened";
  case 1 :
    return "burdened";
  case 2 :
    return "heavily burdened";
  case 3 :
    return "very heavily burdened";
  default :
    return "incredibly heavily burdened";
  }
}
void living_commands() {
#if efun_defined(add_action)
   add_action( "exit_command", "*", 1 );
#endif
}
void eat_this( object food ) {
  this_object()->bypass_queue();
  command( "eat " + file_name( food ) );
}
int test_add(object ob, int flag) {
  if(sizeof(all_inventory(this_object())) > query_max_items())
    return 0;
  return !flag;
}
int test_remove( object ob, int flag, mixed dest ) {
   object thing;
   if ( flag ) {
      return 0;
   }
   if ( !this_player() || ( this_player() == this_object() ) ) {
      return !flag;
   }
   if ( stringp( dest ) ) {
      thing = find_object( dest );
   }
   if ( objectp( dest ) ) {
      thing = dest;
      dest = file_name( dest );
   }
   if ( thing->query_corpse() || ( dest == "/room/rubbish" ) ) {
      return !flag;
   }
   if ( sizeof( filter_array( previous_object( -1 ),
         (: $1->query_theft_command() :) ) ) ) {
      return !flag;
   }
   if ( !query_property( PASSED_OUT ) ) {
      return 0;
   }
   if ( !pk_check( this_player(), this_object() ) ) {
      event( environment( this_player() ), "theft", this_player(),
            this_object(), ob );
      return !flag;
   }
   write( "An unseen force stays your hand.\n" );
   return 0;
}
int query_al() { return alignment; }
void set_al( int number ) { alignment = number; }
int adjust_al( int number ) {
   alignment += number;
   if ( alignment < -MAX_AL ) {
      alignment = -MAX_AL;
   }
   if ( alignment > MAX_AL ) {
      alignment = MAX_AL;
   }
   return alignment;
}
int adjust_alignment( int number ) {
  int change;
  change = - (number + alignment/5);
  change /= 20;
  return adjust_al( change );
}
string align_string() {
   switch ( alignment ) {
      case -MAX_AL .. -5001 : return "extremely good"; break;
      case -5000 .. -2501 : return "very good"; break;
      case -2500 .. -1251 : return "quite good"; break;
      case -1250 .. -601 : return "good"; break;
      case -600 .. -301 : return "barely good"; break;
      case -300 .. 300 : return "neutral"; break;
      case 301 .. 600 : return "barely evil"; break;
      case 601 .. 1250 : return "evil"; break;
      case 1251 .. 2500 : return "quite evil"; break;
      case 2501 .. 5000 : return "very evil"; break;
      default : return "extremely evil"; break;
   }
}
string query_deity() { return deity; }
void set_deity( string word ) { deity = word; }
string query_msgin() { return _messages->msgin; }
string query_msgout() { return _messages->msgout; }
int set_msgin(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$F") == -1) {
      return 0;
   }
   _messages->msgin = str;
   return 1;
}
int set_msgout(string str) {
   if (strsrch(str, "$N") == -1 || strsrch(str, "$T") == -1) {
      return 0;
   }
   _messages->msgout = str;
   return 1;
}
string query_mmsgin() { return _messages->mmsgin; }
string query_mmsgout() { return _messages->mmsgout; }
int set_mmsgin(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgin = str;
   return 1;
}
int set_mmsgout(string str) {
   if (strsrch(str, "$N") == -1) {
      return 0;
   }
   _messages->mmsgout = str;
   return 1;
}
mixed *query_facing() { return copy( facing ); }
void set_facing( mixed *args ) { facing = args; }
string find_rel( string word, int from ) {
  int i;
  i = member_array( word, facing[ 1 ] );
  if ( i != -1 ) {
    i = ( i + 8 - facing[ 0 ] ) % 8;
    return REL_DIRS[ 3 * i + from ];
  }
  i = member_array( word, facing[ 2 ] );
  if ( i != -1 ) {
    return ({ "up", "down" })[ i ];
  }
  return word;
}
string find_abs( string word ) {
  int i;
  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ]) % 8;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
}
string reorient_rel( string word ) {
  int i;
  i = member_array( word, REL_DIRS );
  if ( i != -1 ) {
    i = ( i / 3 + facing[ 0 ] ) % 8;
    facing[ 0 ] = i;
    return facing[ 1 ][ i ];
  }
  i = member_array( word, ({ "up", "down" }) );
  if ( i != -1 ) {
    return facing[ 2 ][ i ];
  }
  return word;
}
void reorient_abs( string verb ) {
  if ((ABS_FACING)[verb]) {
    facing[0] = (ABS_FACING)[verb] % 8;
  }
}
void set_dragging( object thing ) { add_property("dragging", thing); }
object query_dragging() { return query_property("dragging"); }
void reset_dragging() { add_property("dragging", 0); }
int room_look() {
   if ( query_property( UNKNOWN_MOVE ) || !( interactive( this_object() ) ||
         this_object()->query_slave() ) )
      return 0;
   if(!mapp(verbose))
     verbose = ([ ]);
   if(verbose && verbose["look"]) {
      this_object()->ignore_from_history( "look" );
      this_object()->bypass_queue();
      command( "look" );
   } else {
      this_object()->ignore_from_history( "glance" );
      this_object()->bypass_queue();
      command( "glance" );
   }
   return 1;
}
int query_verbose(string type) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  return verbose[type];
}
void set_verbose(string type, int val) {
  if(!verbose || !mapp(verbose)) {
    verbose = ([ ]);
  }
  if(member_array(type, VERBOSE_TYPES) != -1) {
    verbose[type] = val;
  }
}
string *query_verbose_types() {
  return VERBOSE_TYPES;
}
varargs int move_with_look( mixed dest, string messin, string messout ) {
   return_to_default_position(1);
   if ( (int)this_object()->move( dest, messin, messout ) != MOVE_OK )
      return 0;
   room_look();
   return_to_default_position(1);
   return 1;
}
varargs int exit_command( string word, mixed verb, object thing, int redirection ) {
   string special_mess, *bits, *exits, redirect;
   int temp;
   if ( !environment() ) {
      return 0;
   }
   if ( !verb ) {
      verb = word;
      bits = explode( word, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   } else {
      if ( pointerp( verb ) ) {
         special_mess = verb[ 1 ];
         verb = verb[ 0 ];
      }
      bits = explode( verb, " " );
      if ( sizeof( bits ) > 1 ) {
         word = implode( bits[ 1 .. ], " " );
      } else {
         word = "";
      }
   }
   if ( lengthen[ verb ] ) {
      verb = lengthen[ verb ];
   }
   exits = (string *)environment()->query_exits();
   if ( !exits ) {
      return 0;
   }
   if ( member_array( verb, exits ) != -1 ) {
     if ( environment()->query_relative( verb ) ) {
       return 0;
     }
     if ((abs_facing)[verb]) {
       facing[0] = (abs_facing)[verb] % 8;
     }
   } else {
     if (member_array(find_abs(verb), exits ) == -1 ) {
       return 0;
     }
     verb = reorient_rel(verb);
   }
   if ( !thing ) {
      thing = this_object();
   }
    if ( !redirection ) {
        if ( stringp( redirect = thing->query_exit_redirection( word ) ) ) {
            if ( temp = this_object()->exit_command( verb, redirect, thing, 1 ) )
                return temp;
        }
    }
   return (int)"/obj/handlers/room_handler"->exit_move( verb, word,
         special_mess, thing );
}
void become_flummoxed() {
   int will;
   will = query_int() * query_wis();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_ritual();
   if ( will < random( WILL_POWER ) )
      this_object()->interrupt_spell();
   if ( will < random( WILL_POWER ) )
      this_object()->stop_all_fight();
}
int run_away() {
   int i;
   object old_env;
   mixed *direcs;
   direcs = (mixed *)environment()->query_dest_dir(this_object());
   old_env = environment();
   while ( sizeof( direcs ) ) {
      i = random( sizeof( direcs ) / 2 ) * 2;
      if ( exit_command( direcs[i] ) ) {
          event( old_env, "run_away", direcs[ i ], direcs[ i + 1 ] );
          return 1;
      }
      direcs = delete( direcs, i, 2 );
   }
   return 0;
}
mixed *stats() {
   return container::stats() + stats::stats() + ({
           ({ "max_hp", max_hp }),
           ({ "hp",  hp }),
           ({ "max_gp", max_gp }),
           ({ "gp", gp }),
           ({ "alcohol", drink_info[ D_ALCOHOL ] }),
           ({ "food", drink_info[ D_FOOD ] }),
           ({ "drink", drink_info[ D_DRINK ] }),
           ({ "gender", query_gender_string() }),
           ({ "alignment", this_object()->query_al() }),
           ({ "deity", deity }),
           ({ "total money", query_value() }),
           ({ "xp", query_xp() }),
   }) + armour::stats() + combat::stats();
}
class obj_match_context query_it_them() { return _liv_data->it_them; }
void set_it_them( class obj_match_context args) { _liv_data->it_them = args; }
int add_follower(object ob) {
  if (ob == this_object()) {
    return 0;
  }
  if (member_array(ob, _liv_data->followers) == -1) {
    _liv_data->followers += ({ ob });
  }
  return 1;
}
int remove_follower(object ob) {
  int i;
  i = member_array(ob, _liv_data->followers);
  if (i != -1) {
    _liv_data->followers = delete(_liv_data->followers, i, 1);
    return 1;
  }
  return 0;
}
int check_doing_follow(object thing, string verb, string special) {
   return 1;
}
object query_current_room() { return environment(); }
mixed *query_followers() { return copy(_liv_data->followers - ({ 0 })); }
varargs void adjust_money(mixed amt, string type) {
  return money::adjust_money(amt, type);
}
mixed *query_money_array() {
  return money::query_money_array();
}
int query_money(string type) {
  return money::query_money(type);
}
int query_value() { return money::query_value(); }
void do_burden_call() {
  if(_liv_data->burden_call)
    remove_call_out(_liv_data->burden_call);
  _liv_data->burden_call = call_out("calc_burden", 1);
}
int query_burden_limit() {
  if (this_object()->query_creator()) {
    return MAX_CREATOR_INVEN;
  } else {
    return MAX_INVEN;
  }
}
void event_enter( object thing, string mess, object from ) {
  if(environment( thing ) == this_object()) {
    do_burden_call();
    if(sizeof(all_inventory()) > query_burden_limit() ) {
      _liv_data->to_drop += ({ thing });
      remove_call_out("test_number_of_items");
      call_out("test_number_of_items", 5 + random(5));
    }
  }
}
void event_exit( object thing, string mess, object to ) {
  if(environment(thing) == this_object()) {
    do_burden_call();
  }
}
void test_number_of_items() {
   int how_many;
   object thing, *things, *dropped;
   things = all_inventory() - query_armours() - query_holding();
   how_many = sizeof(things) - query_burden_limit();
   if ( how_many < 1 ) {
      return;
   }
   _liv_data->to_drop -= ({ 0 });
   dropped = ({ });
   while(how_many > 0 && sizeof(things)) {
      if (sizeof(_liv_data->to_drop)) {
         thing = _liv_data->to_drop[random(sizeof(_liv_data->to_drop))];
      } else {
         thing = things[random(sizeof(things))];
      }
      things -= ({ thing });
      _liv_data->to_drop -= ({ thing });
      if(!thing || !thing->short() || thing->drop() ||
         thing->query_property("cannot fumble") ||
         thing->id("coin") ||
         environment(thing) != this_object()) {
        continue;
      }
      if((int)thing->move(environment()) == MOVE_OK) {
        how_many--;
        dropped += ({ thing });
      }
   }
   _liv_data->to_drop = ({ });
   if(sizeof(dropped)) {
     tell_object( this_object(), "Whoops!  You tried to carry too many "
                  "things and fumbled "+
                  query_multiple_short( dropped ) +".\n" );
     this_object()->dest_hide_shadow();
     tell_room( environment(), capitalize( the_short() ) +" juggles "+
                "around "+ query_possessive() +" stuff and fumbles "+
                query_multiple_short( dropped ) +".\n", this_object() );
   }
}
void force_burden_recalculate() {
   do_burden_call();
   remove_call_out("test_number_of_items");
   call_out("test_number_of_items", 5 + random(5));
}
object *find_inv_match( string words, object looker ) {
   return sort_array( container::find_inv_match( words, looker ),
         (: ( member_array( $1, query_holding() ) != -1 ? -1 : 0 ) :) );
}
int attack_by(object ob) {
   return_to_default_position(0);
   return ::attack_by(ob);
}
int attack_ob(object ob) {
   return_to_default_position(0);
   return ::attack_ob(ob);
}
void set_always_use_default_position(int flag) {
   always_use_default_position = flag;
}
int query_always_use_default_position() {
   return always_use_default_position;
}
string query_default_position() {
   mixed pos;
   if (stringp(default_position) &&
              default_position->query_position_command()) {
      pos = default_position;
   } else if (pointerp(default_position) &&
              (sizeof(default_position) == POSITION_MESS_SIZE ||
               sizeof(default_position) == POSITION_ONLY_TYPE_SIZE)) {
      pos = default_position;
   } else if (functionp(default_position)) {
      pos = default_position;
   }
   if (!pos) {
      pos = STANDING_CMD;
   }
   return pos;
}
void set_default_position(mixed str) {
   if (stringp(str) && str->query_position_command() && str != STANDING_CMD) {
      default_position = str;
   } else if (!str || str == STANDING_CMD) {
      default_position = 0;
   } else if (pointerp(str) && (sizeof(str) == POSITION_ONLY_TYPE_SIZE ||
                                sizeof(str) == POSITION_MESS_SIZE)) {
      default_position = str;
   } else if (functionp(str)) {
      default_position = str;
   }
}
void return_to_default_position(int leaving) {
   mixed pos;
   if (query_always_use_default_position()) {
      pos = query_default_position();
   } else {
      pos = 0;
      if (environment()) {
         pos = environment()->query_default_position(this_object());
      }
      if (!pos) {
         pos = query_default_position();
      }
   }
   if (functionp(pos)) {
      if (!evaluate(pos, this_object(), leaving)) {
         pos = 0;
         if (environment()) {
            pos = environment()->query_default_position(this_object());
         }
         if (!pos) {
            pos = STANDING_CMD;
         }
      }
   }
   if (stringp(pos)) {
      if (position != pos->query_position_type() ||
          (leaving && query_position_on())) {
         if (leaving) {
            catch(pos->position_floor(this_object()));
         } else {
            catch(pos->position(this_object()));
         }
      }
   } else if (pointerp(pos) && position != pos[POSITION_TYPE_INDEX]) {
      if (sizeof(pos) > 1) {
         if (pos[POSITION_ME_MESS_INDEX]) {
            tell_object(this_object(), pos[POSITION_ME_MESS_INDEX]);
         }
         if (pos[POSITION_REST_MESS]) {
            tell_room(environment(), pos[POSITION_REST_MESS], this_object());
         }
      }
      set_position(pos[POSITION_TYPE_INDEX]);
      set_position_on(0);
      set_position_type(0);
      set_position_multiple(0);
   }
}
void set_position(string name) {
   position = name;
}
string query_position() {
   return position;
}
void set_position_on(mixed ob) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_ON_OBJECT] = ob;
}
void set_position_multiple(int mult) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_MULTIPLE] = mult;
}
int query_position_multiple() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_MULTIPLE];
}
void set_position_type(string type) {
   if (!position_on) {
      position_on = allocate(POSITION_ARRAY_SIZE);
   }
   position_on[POS_TYPE] = type;
}
string query_position_type() {
   if (!position_on ||
       !position_on[POS_TYPE]) {
      return "on";
   }
   return position_on[POS_TYPE];
}
object query_position_on() {
   if (!position_on) {
      return 0;
   }
   return position_on[POS_ON_OBJECT];
}
string query_position_on_short() {
   if (!position_on || !position_on[POS_ON_OBJECT]) {
      return "";
   }
   if (stringp(position_on[POS_ON_OBJECT])) {
      return position_on[POS_ON_OBJECT];
   }
   return position_on[POS_ON_OBJECT]->the_short();
}
string query_position_long() {
   if (position != STANDING || position_on) {
      if (position_on) {
         return query_pronoun() + " is " + query_position_type() + " "+
                query_position_on_short()+".\n";
      }
      return query_pronoun()+" is "+position+" on the floor.\n";
   }
   return "";
}
string query_position_short() {
   if (!position_on ||
       !position_on[POS_ON_OBJECT]) {
      return position;
   }
   return position + " " + query_position_type() + " " +
          query_position_on_short();
}
varargs int cannot_walk( string verb, mixed *dest_other) {
   return 0;
}
string *query_arcane_shields() { return ({ }); }
int can_find_match_reference_inside_object(object thing, object looker) {
   if (member_array(thing, query_wearing_hidden(looker, 0)) != -1) {
      return 0;
   }
   return 1;
}
int query_deity_favour( string god ) {
  if ( !mapp( deity_favour ) )
    return 0;
  if ( !undefinedp( deity_favour[ god ] ) )
    return 0;
  return deity_favour[ god ];
}
void adjust_deity_favour( string god, int amount ) {
  if ( !mapp( deity_favour ) )
    deity_favour = ([ ]);
  if ( !undefinedp( deity_favour[ god ] ) )
    deity_favour[ god ] = amount;
  deity_favour[ god ] += amount;
  if ( deity_favour[ god ] > MAX_FAVOUR )
    deity_favour[ god ] = MAX_FAVOUR;
  if ( deity_favour[ god ] < -MAX_FAVOUR )
    deity_favour[ god ] = -MAX_FAVOUR;
  return;
}
mapping query_all_deity_favour() { return deity_favour; }

==================================================
FILE: living/mon-shadow.c
==================================================

object npc;
void setup_shadow(object ob) {
  shadow(ob,1);
  npc = ob;
}
void death_shadow() { destruct( this_object() ); }
object query_npc() { return npc; }

==================================================
FILE: living/mon_actions.c
==================================================

#include "monster.h"
#undef DEBUG
mixed *mon_actions;
void create() {
  mon_actions = ({ });
}
void do_shadow() {
  int i;
  object ob;
  string fname;
  this_object()->shadow_death();
  fname = (string)MONSTER_HAND->query_shadow_name();
  rm(fname+".c");
  for (i=0;i<sizeof(mon_actions);i+=2)
    write_file(fname+".c",
               "inherit \"/std/trigger/"+mon_actions[i]+"\";\n");
  write_file(fname+".c", read_file("/std/living/mon-shadow.c"));
  ob = clone_object(fname);
  ob->setup_shadow(this_object());
  rm(fname+".c");
}
int add_triggered_action(string name, string trigger, mixed ob,
                         string func) {
  int i, j;
#ifdef DEBUG
  log_file("TRIGGERED", ctime(time())+": "+
           file_name(this_object())+"  prev: "+
      implode( map_array( previous_object( -1 ), (: file_name( $1 ) :) ),
      ", " ) +"\n" );
#endif
  if ((i=member_array(trigger, mon_actions)) == -1) {
    mon_actions += ({ trigger, ({ name, ({ ob, func }) }) });
    do_shadow();
  } else if ((j=member_array(name, mon_actions[i+1])) == -1)
    mon_actions[i+1] += ({ name, ({ ob, func }) });
  else
    mon_actions[i+1][j+1] = ({ ob, func });
}
int remove_trigger(string name) {
  int i;
  if ((i=member_array(name, mon_actions)) == -1)
    return 0;
  mon_actions = delete(mon_actions, i, 2);
  if (!sizeof(mon_actions))
    this_object()->shadow_death();
  else
    do_shadow();
  return 1;
}
int remove_triggered_action(string trigger, string name) {
  int i, j;
  if ((i=member_array(trigger, mon_actions)) == -1)
    return 0;
  if ((j=member_array(name, mon_actions[i+1])) == -1)
    return 0;
  mon_actions[i+1] = delete(mon_actions[i+1], i, 2);
  if (!sizeof(mon_actions[i+1]))
    remove_trigger(trigger);
  return 1;
}
mixed *query_actions(string trigger) {
  int i;
  if ((i=member_array(trigger, mon_actions)) == -1)
    return ({ });
  return mon_actions[i+1];
}
mixed *query_mon_actions() { return mon_actions; }

==================================================
FILE: living/money.c
==================================================

#include "money.h"
object query_money_object(int force) {
   object money;
   money = present( MONEY_ALIAS, this_object() );
   if (!money && force) {
      money = MONEY_VAULT->get_money_ob();
      money->move( this_object() );
   }
   return money;
}
varargs void adjust_money( mixed amount, string type ) {
   if (!amount) return;
   query_money_object( 1 )->adjust_money( amount, type );
   this_object()->do_burden_call();
}
mixed *query_money_array() {
   return query_money_object(1)->query_money_array();
}
void set_money_array( mixed *new_array ) {
   query_money_object(1)->set_money_array( new_array );
}
int query_value() {
   object money;
   money = query_money_object(0);
   if ( ! money ) {
      return 0;
   }
   return money->query_value();
}
int query_value_in( string where ) {
   object money;
   money = query_money_object(0);
   if ( ! money ) {
      return 0;
   }
   return (int)money->query_value_in( where );
}
int query_money( string type ) {
   object money;
   money = query_money_object(0);
   if ( ! money ) {
      return 0;
   }
   return (int)money->query_money( type );
}
varargs void pay_money( mixed m_array, string where ) {
   int i, j;
   object money;
   mixed *p_array;
   money = query_money_object(0);
   if ( !money ) {
      return;
   }
   for ( i = 0; i < sizeof( m_array ); i += 2 ) {
      p_array = (mixed *)MONEY_HAND->make_payment( m_array[ i ],
         m_array[ i + 1 ], money, where );
      if ( !pointerp( p_array ) ) {
         continue;
      }
      if ( sizeof( p_array[ 1 ] ) ) {
         money->adjust_money( p_array[ 1 ] );
      }
      for ( j = 0; j < sizeof( p_array[ 0 ] ); j += 2 ) {
         money->adjust_money( - p_array[ 0 ][ j + 1 ], p_array[ 0 ][ j ] );
      }
   }
}

==================================================
FILE: living/nationality.c
==================================================

#include <living.h>
#include <config.h>
private class living_nationality _nationality_data;
string query_nationality() {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality;
   }
   return 0;
}
string query_nationality_region() {
   if (_nationality_data && _nationality_data->region) {
      return _nationality_data->region;
   }
   return 0;
}
mixed query_nationality_data() {
   if (_nationality_data && _nationality_data->data) {
      return _nationality_data->data;
   }
   return 0;
}
void set_nationality(string nationality) {
   if (!_nationality_data) {
      _nationality_data = new(class living_nationality);
   }
   _nationality_data->nationality = nationality;
}
void set_nationality_region(string region) {
   if (!_nationality_data) {
      _nationality_data = new(class living_nationality);
   }
   _nationality_data->region = region;
}
void set_nationality_data(mixed data) {
   if (!_nationality_data) {
      _nationality_data = new(class living_nationality);
   }
   _nationality_data->data = data;
}
string query_nationality_name() {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality->query_name();
   }
   return 0;
}
string query_nationality_description(object looker) {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality->query_look_description(this_object(), looker);
   }
   return 0;
}
string query_nationality_accent_ob() {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality->query_region_accent_ob(_nationality_data->region);
   }
}
string query_nationality_start_location() {
   if (_nationality_data && _nationality_data->nationality) {
      return _nationality_data->nationality->query_start_location(_nationality_data->region);
   }
   return CONFIG_START_LOCATION;
}

==================================================
FILE: living/respond_cmd.c
==================================================

private nosave mapping _respond_cmd;
class respond_data {
   object ob;
   mixed data;
}
void remove_respond_command(string type, object ob);
mapping query_respond_cmd_data() { return _respond_cmd; }
void create() {
   _respond_cmd = ([ ]);
}
void add_respond_command(string type, object ob, mixed data) {
   class respond_data frog;
   remove_respond_command(type, ob);
   frog = new (class respond_data);
   frog->ob = ob;
   frog->data = data;
   if (!_respond_cmd[type]) {
      _respond_cmd[type] = ({ });
   }
   _respond_cmd[type] += ({ frog });
}
mixed query_respond_command(string type, object ob) {
   class respond_data frog;
   if (_respond_cmd[type]) {
      foreach (frog in _respond_cmd[type]) {
         if (frog->ob == ob) {
            return frog->data;
         }
      }
   }
   return 0;
}
void remove_respond_command(string type, object ob) {
   class respond_data frog;
   int i;
   if (_respond_cmd[type]) {
      for (i = 0; i < sizeof(_respond_cmd[type]); i++) {
         frog = _respond_cmd[type][i];
         if (frog->ob == ob) {
            _respond_cmd[type] = _respond_cmd[type][0..i - 1] +
                                 _respond_cmd[type][i+1..];
            i--;
         }
      }
   }
}
void clear_respond_commands() {
   _respond_cmd = ([ ]);
}

==================================================
FILE: living/response_mon.c
==================================================

#include <soul.h>
#include <language.h>
#define SPECIAL_DAY "/obj/handlers/special_day"
class response_data {
   object last_ob;
   string last_mess;
   int stop_responding;
   int use_regexp;
   int last_count;
   int last_time;
   int understand_anything;
   object* only_respond_to;
}
mixed *_respond_to_with;
nosave class response_data _response_data;
int match(string str, mixed str2);
void event_soul(object per, string mess, object *avoid, string verb,
                string last, mixed at) ;
void create() {
  _respond_to_with = ({ });
  _response_data = new(class response_data);
  _response_data->only_respond_to = ({ });
}
void set_response_mon_understand_anything(int flag) {
   _response_data->understand_anything = flag;
}
void set_response_mon_regexp(int flag) { _response_data->use_regexp = flag; }
int query_response_mon_regexp() { return _response_data->use_regexp; }
int query_response_mon_debug_mode() {
  return this_object()->query_property("respon mon debug");
}
void set_response_mon_debug_mode(int flag) {
  this_object()->add_property("respon mon debug", flag);
}
void set_stop_responding(int i) { _response_data->stop_responding = i; }
int query_stop_responding() { return _response_data->stop_responding; }
int query_response_allowed(object ob,
                           string *response) {
  if (!this_object()->query_visible(ob)) {
    return 0;
  }
  return 1;
}
void set_respond_to_with( mixed map ) {
  mixed *old_keys;
  int i;
  if ( mapp( map ) ) {
#ifdef DEBUG
    log_file("BAD_RESPONSE", "set_respond_to_with() called by %O (%s)\n",
             previous_object(), previous_object()->query_name());
#endif
    old_keys = keys(map);
    _respond_to_with = allocate(sizeof(old_keys) * 2);
    for (i = sizeof(old_keys); i--; ) {
      _respond_to_with[2*i] = old_keys[i];
      _respond_to_with[2*i+1] = map[old_keys[i]];
    }
    return;
  }
  _respond_to_with = map;
}
mixed *query_respond_to_with() { return _respond_to_with; }
void add_respond_to_with( mixed *trigger, mixed response ) {
  _respond_to_with += ({ trigger, response });
}
void add_only_respond_to(object person) {
  _response_data->only_respond_to += ({ person });
}
void remove_only_respond_to(object person) {
   _response_data->only_respond_to -= ({ person });
}
object* query_only_respond_to() {
   return _response_data->only_respond_to;
}
protected mixed *check_sub_sequence( mixed *words ) {
  int word_index;
  int format_index;
  int format_size;
  int word_size;
  int match_counter;
  int cu_format_size;
  string word_str;
  mixed data;
  string *patterns;
  string pattern;
  string extra;
  format_index = 0;
  word_size = sizeof( words );
  word_str = implode(words, " ");
  format_size = sizeof( _respond_to_with );
  while (format_index < format_size) {
    if ( _response_data->use_regexp ) {
        data = _respond_to_with[ format_index ];
        if ( arrayp( data ) && sizeof( data ) > 1 ) {
            if ( arrayp( data[0] ) ) {
                extra = "(" + implode( data, "|" ) + ")+";
            }
            else {
                extra = data[0];
            }
            patterns = map( data[1], (: $(extra) + " " + $1 :) );
        }
        else {
            patterns = ({ data });
        }
        foreach( pattern in patterns ) {
            if ( regexp( word_str, pattern ) ) {
                return _respond_to_with[ format_index + 1 ];
            }
        }
    }
    else {
        word_index = 0;
        match_counter = 0;
        cu_format_size = sizeof(_respond_to_with[format_index]);
        while ((word_index < word_size) && (match_counter < cu_format_size)) {
          match_counter += match(words[word_index],
                                 _respond_to_with[format_index][match_counter]);
          word_index++;
        }
        if (match_counter == (cu_format_size)) {
          return _respond_to_with[format_index + 1];
        }
    }
    format_index += 2;
  }
  return 0;
}
protected int match(string str, mixed format) {
  if (pointerp(format)) {
    return (member_array(str, format) != -1);
  }
  if (str == format) {
    return 1;
  }
  return 0;
}
protected string remove_read_marks(string str) {
  int blij;
  string result;
  int size;
  string temp;
  size = strlen(str);
  blij = 0;
  result = "";
  while (blij < size) {
    temp = str[blij..blij];
    if (((temp >= "a") && (temp <= "z")) ||
        ((temp >= "0") && (temp <= "9")) ||
        (temp == " ")) {
      result += temp;
    } else {
      result += " ";
    }
    blij++;
  }
  return result;
}
protected void senddstr(string str, object per) {
  if ( environment( this_object() ) ) {
    if ( per ) {
      command(replace(str, ({ "$hname$", per->query_name(), "$hcname$",
                                per->query_short(),
                              "$hshort$", per->query_short() })));
    } else {
      command( str );
    }
  }
}
protected void exec_response(mixed rep, object per, string mess) {
  string *rabbit;
  if (pointerp(rep)) {
    return exec_response(rep[random(sizeof(rep))], per, mess);
  }
  if (functionp(rep)) {
    evaluate(rep, per, mess);
  } else if (stringp(rep)) {
    if (rep[0..0] == "#") {
      rabbit = explode(rep[1..], "#");
      if (sizeof(rabbit) > 1) {
        call_out((: call_other($1, $2, $3, $4) :), 0,
                 rabbit[0], rabbit[1], per, mess);
      } else {
        call_out(rabbit[0], 0, per, mess);
      }
    } else {
      call_out("senddstr", 0, rep, per);
    }
  }
}
private void do_delay_thingy(string *extra, string mess, object per) {
  mixed *response;
  mess = lower_case(mess);
  if (!_response_data->use_regexp) {
    mess = remove_read_marks(mess);
  }
  if (query_response_mon_debug_mode()) {
    tell_object(per, "Parsing the text: " + implode(extra, " ") + " " + mess + "\n");
  }
  response = check_sub_sequence(extra + explode(mess, " "));
  if (query_response_mon_debug_mode()) {
    tell_object(per, sprintf("Responding with %O\n", response));
  }
  if (response) {
    if (query_response_allowed(per, response)) {
      exec_response(response, per, mess);
    }
  }
}
int check_loop(object per, string mess) {
  if(interactive(per)) {
    return 0;
  }
  if (_response_data->last_ob == per &&
      (_response_data->last_mess = mess) &&
      _response_data->last_time > time() - 10)
  {
    if(_response_data->last_count > 1) {
      return 1;
    } else {
      _response_data->last_count++;
    }
    _response_data->last_time = time();
  } else {
    _response_data->last_ob = per;
    _response_data->last_mess = mess;
    _response_data->last_count = 1;
    _response_data->last_time = time();
  }
  return 0;
}
private void do_response(string *extra, string mess, object per) {
  if (sizeof(_response_data->only_respond_to)) {
     _response_data->only_respond_to -= ({ 0 });
     if (sizeof(_response_data->only_respond_to) &&
         member_array(per, _response_data->only_respond_to) == -1) {
        return ;
     }
  }
  call_out((: do_delay_thingy($1, $2, $3) :), 2, extra, mess, per);
}
void event_person_sayto(object per, string mess, string lang, object* targets) {
  string skill;
  if(_response_data->stop_responding ||
     !sizeof(_respond_to_with) ||
     environment() == find_object( "/room/rubbish" ) ||
     environment() == find_object( "/room/void" ) ||
     !per || per == this_object()) {
    return ;
  }
  if(check_loop(per, mess)) {
    return;
  }
  skill = LANGUAGES->query_language_spoken_skill(lang);
  if (this_object()->query_skill(skill) < 90 ||
      per->query_skill(skill) < 60) {
    return;
  }
  do_response(({ "@sayto" }), mess, per);
}
void event_person_say(object per, string start, string mess, string lang) {
  string skill;
  if(_response_data->stop_responding ||
     !sizeof(_respond_to_with) ||
     environment() == find_object( "/room/rubbish" ) ||
     environment() == find_object( "/room/void" ) ||
     !per || per == this_object()) {
    return ;
  }
  if(check_loop(per, mess))
    return;
  if (!_response_data->understand_anything) {
     skill = LANGUAGES->query_language_spoken_skill(lang);
     if (this_object()->query_skill(skill) < 90 ||
         per->query_skill(skill) < 60) {
       return;
     }
  }
  do_response(({ "@say" }), mess, per);
}
varargs void event_soul(object per, string mess, object *avoid, string verb,
                        string last, mixed at) {
  if (per == find_object(SOUL_OBJECT))
    per = previous_object(2);
  if(!interactive(per) ||
     _response_data->stop_responding ||
     environment() == find_object( "/room/rubbish" ) ||
     environment() == find_object( "/room/void" ) ||
      member_array(this_object(), avoid) != -1 ||
     !sizeof(_respond_to_with)) {
    return ;
  }
  if((!objectp(at) || (objectp(at) && at != this_object())) &&
     environment(per) != environment() ) {
    return;
  }
  mess = this_object()->convert_message( mess );
  if(check_loop(per, mess))
    return;
  if (objectp(at)) {
    do_response(({ "@" + verb, "#" + last, at->query_name() }), mess, per);
  } else {
    do_response(({ "@" + verb, "#" + last }), mess, per);
  }
}
varargs void event_whisper(object per, string mess, object *obs, string lang,
                           object me) {
  string skill;
  if (!interactive(per) || _response_data->stop_responding ||
      environment() == find_object( "/room/rubbish" ) ||
      !sizeof(_respond_to_with)) {
    return ;
  }
  if(check_loop(per, mess)) {
    return;
  }
  if (!_response_data->understand_anything) {
    skill = LANGUAGES->query_language_spoken_skill(lang);
    if (this_object()->query_skill(skill) < 90 ||
        per->query_skill(skill) < 60) {
      return;
    }
  }
  if (member_array(this_object(), obs) == -1) {
    do_response(({ "@whisper", map(obs, (: $1->query_name() :)) }),
                "", per);
  } else {
    mess = this_object()->convert_message( mess );
    do_response(({ "@whisper", map(obs, (: $1->query_name() :)) }),
                mess, per);
  }
}

==================================================
FILE: living/skills.c
==================================================

#include <skills.h>
#include <tasks.h>
#include <tune.h>
#undef LOGGING
varargs int calc_bonus( int lvl, string skill, int use_base_stats );
varargs int stat_modify( int bonus, string skill, int use_base_stats );
mixed recursive_skill_add(mixed skil, string *path, int avr, int lvl, int exp,
                           mixed standard);
private void convert_skills(mixed *skills, string path);
int query_skill(string skill);
mapping new_skills;
nosave mapping _bonus_cache,
               _stat_cache,
               _teach_offer;
mapping _last_info;
mapping query_skills() { return copy( new_skills ); }
void set_skills( mapping map ) { new_skills = map; }
int calc_level(string *path);
void create() {
  _bonus_cache = ([ ]);
  _teach_offer = ([ ]);
  _stat_cache = ([ ]);
  new_skills = ([ ]);
  if(!_last_info)
    _last_info = ([ "time" : time() ]);
}
int not_there( string skill ) {
   return undefinedp(new_skills[skill]);
}
mapping query_bonus_cache() { return copy(_bonus_cache); }
mapping query_stat_cache() { return copy(_stat_cache); }
void zap_stat_cache() {
   int i;
   string word, *list, stat;
   stat = this_object()->stats_to_zap();
   if ( !stat ) {
      return;
   }
   if ( find_call_out( "reset_all2" ) == -1 ) {
      call_out( "reset_all2", 1 );
   }
   foreach( i in stat ) {
      list = _stat_cache[ i ];
      if ( !list )
         continue;
      foreach( word in list ) {
         map_delete( _stat_cache, word );
      }
   }
   word = (string)this_object()->query_race_ob();
   if ( word ) {
      word->set_unarmed_attacks( this_object() );
   }
}
void totaly_zap_bonus_cache() {
   _bonus_cache = ([ ]);
}
protected void totaly_zap_stat_cache() {
   _stat_cache = ([ ]);
}
varargs int query_skill_bonus( string skill, int use_base_stats ) {
#ifdef 0
   int tmp, lvl;
   string *path;
   object guild, race;
#endif
  if (!stringp(skill) || !strlen(skill)) {
    return 0;
  }
  if (!new_skills) {
    new_skills = ([ ]);
  }
  if (skill[0] == '.') {
    skill = skill[1..];
  }
  TASKER->set_control( ({ this_object(), skill }) );
  if ( _bonus_cache[ skill ] )
     return stat_modify( _bonus_cache[ skill ], skill, use_base_stats );
  return calc_bonus( query_skill(skill), skill, use_base_stats );
#ifdef 0
  lvl = query_skill(skill);
  guild = (object)this_object()->query_guild_ob();
  race = (object)this_object()->query_race_ob();
  if (race) {
    tmp = (int)race->query_skill_bonus(lvl, skill);
  }
  if (guild) {
    tmp += (int)guild->query_skill_bonus(lvl, skill);
  }
  return calc_bonus( lvl + tmp, skill, use_base_stats );
#endif
}
int query_skill(string skill) {
   string *path;
   if (!new_skills) {
      new_skills = ([ ]);
   }
   if (!stringp(skill)) {
      return 0;
   }
   if (skill[0] == '.') {
      skill = skill[1..];
   }
   TASKER->set_control( ({ this_object(), skill }) );
   if ( not_there( skill ) ) {
      int i;
      path = (string *)SKILL_OB->query_skill_tree(skill);
      if (path) {
         for (i=0;i<sizeof(path);i++) {
            if ( !not_there( path[ i ] ) ) {
               return new_skills[path[i]];
            }
         }
      }
   } else {
      return new_skills[skill];
   }
   return 0;
}
mapping query_complete_skill_branch( string branch ) {
  string *skills = SKILL_OB->query_all_children( branch );
  if ( !arrayp( skills ) || !sizeof( skills ) )
    return ([ ]);
  return allocate_mapping( skills, (: query_skill( $1 ) :) );
}
protected void flatten_it(string skill) {
   int value;
   int i;
   string *same;
   reset_eval_cost();
   value = new_skills[skill];
   same = (mixed *)SKILL_OB->query_immediate_children(skill);
   for (i=0;i<sizeof(same);i++) {
      if ( not_there( same[ i ] ) ) {
         new_skills[same[i]] = value;
      }
      flatten_it(same[i]);
   }
   if (sizeof(same)) {
      map_delete(new_skills, skill);
   }
}
int tm_check_ok(string skill, object exp) {
  string *history, *bits, *abits;
  int i, j, last, delay;
  if ( !_last_info ) {
    _last_info = ([ "time" : time() ]);
  }
#ifdef LOGGING
  if(base_name(previous_object()) != "/obj/handlers/taskmaster" &&
     base_name(previous_object()) != "/std/effects/fighting/combat" &&
     base_name(previous_object()) != "/std/shadows/misc/team" &&
     base_name(previous_object()) != "/std/shadows/other/group" &&
     base_name(previous_object()) != "/global/player" &&
     base_name(previous_object())[0..2] != "/w/") {
     log_file("ATTEMPT_TASK", "Object %s gave skill increase without using "
              "the taskmaster.\n", base_name(previous_object()));
   }
#endif
  history = this_object()->get_history();
  if(sizeof(history)) {
    for(i=0; i<sizeof(history) && history[i]; i++)
      ;
    last = i - 1;
    if(!this_object()->is_alias(history[last]))
      last -= this_object()->query_queued_commands();
    if(last > 0 && sizeof(history[last]) > 1 && skill[<7..] != ".points") {
      for(i=0; i<sizeof(history) && history[i]; i++) {
        if(history[last] == history[i]) {
          j++;
        }
      }
      if(j > 5 || j * 100 / i > 30) {
#ifdef BAD_TM
        log_file(BAD_TM, "%s %s in %s by %O too many attempts at %s [%s]\n",
                 ctime(time())[4..18], this_object()->query_name(), skill,
                 exp, history[last], history[i-1]);
#endif
        if(!_last_info["skill"] || _last_info["skill"][0] != skill)
          _last_info["skill"] = ({ skill, 2 });
        else
          _last_info["skill"][1] += 1;
        _last_info["time"] = time();
        if(!_last_info["object"] || _last_info["object"][0] != base_name(exp))
          _last_info["object"] = ({ base_name(exp), 2 });
        else
          _last_info["object"][1] += 1;
        if(!_last_info["env"] || _last_info["env"][0] != environment())
          _last_info["env"] = ({ environment(), 2 });
        else
          _last_info["env"][1] += 1;
        return 0;
      }
    }
  }
  delay = 30 + random(this_object()->query_level()) +
    random(this_object()->query_skill(skill));
  if(_last_info["object"] && base_name(exp) == _last_info["object"][0])
    delay *= _last_info["object"][1];
  if(this_object()->query_level() * 2 < this_object()->query_skill(skill))
    delay *= 2;
  if(_last_info["env"] && environment(this_object()) == _last_info["env"][0]) {
    delay *= _last_info["env"][1];
  }
  bits = explode(skill, ".");
  if(_last_info["skill"])
    abits = explode(_last_info["skill"][0], ".");
  else
    abits = ({ });
  for(i=0; i<sizeof(bits) && i<sizeof(abits) && bits[i] == abits[i]; i++)
    ;
  if(i && _last_info["skill"])
    delay *= (i * _last_info["skill"][1]);
  else
    delay = 60;
  if(_last_info["time"] > (time() - delay)) {
#ifdef BAD_TM
    log_file(BAD_TM, "%s %s in %s by %O last %d secs ago, delay %d.\n",
             ctime(time())[4..18], this_object()->query_name(), skill,
             exp, (time() - _last_info["time"]), delay);
#endif
    if(!_last_info["skill"] || _last_info["skill"][0] != skill)
      _last_info["skill"] = ({ skill, 2 });
    else
      _last_info["skill"][1] += 1;
    _last_info["time"] = time();
    if(!_last_info["object"] || _last_info["object"][0] != base_name(exp))
      _last_info["object"] = ({ base_name(exp), 2 });
    else
      _last_info["object"][1] += 1;
    if(!_last_info["env"] || _last_info["env"][0] != environment())
      _last_info["env"] = ({ environment(), 2 });
    else
      _last_info["env"][1] += 1;
    return 0;
  }
  if(!_last_info["skill"] || _last_info["skill"][0] != skill)
    _last_info["skill"] = ({ skill, 2 });
  else
    _last_info["skill"][1] += 1;
  _last_info["time"] = time();
  if(!_last_info["object"] || _last_info["object"][0] != base_name(exp))
    _last_info["object"] = ({ base_name(exp), 2 });
  else
    _last_info["object"][1] += 1;
  if(!_last_info["env"] || _last_info["env"][0] != environment())
    _last_info["env"] = ({ environment(), 2 });
  else
    _last_info["env"][1] += 1;
  return 1;
}
varargs int add_skill_level( string skill, int lvl, mixed exp ) {
   string guild, *recursive_skills, *same_level, *bits, *tree;
   int i;
   reset_eval_cost();
   if (!stringp(skill) || !intp(lvl) || lvl > 1000) {
      return 0;
   }
   if (!new_skills || (!mapp(new_skills))) {
      new_skills = ([ ]);
   }
   if (skill[0] == '.') {
      skill = skill[1..];
   }
   recursive_skills = (string *)SKILL_OB->query_related_skills(skill);
   if (!recursive_skills) {
      return 0;
   }
   bits = explode(skill, ".");
   if ( not_there( skill ) && !SKILL_OB->query_only_leaf(skill)) {
      int tmp_lvl, j;
      if (sizeof(bits) > 1) {
         tmp_lvl = 0;
         for (i=sizeof(bits)-1;!tmp_lvl && i>=0;i--) {
            if ( !not_there( implode( bits[ 0 .. i ], "." ) ) ) {
               tmp_lvl = new_skills[implode(bits[0..i], ".")];
               break;
            }
         }
         if (i>=0) {
            for (;i<sizeof(bits);i++) {
               same_level = (string *)
                 SKILL_OB->query_immediate_children(implode(bits[0..i], "."));
               for ( j = 0; j < sizeof( same_level ); j++ ) {
                  new_skills[ same_level[ j ] ] = tmp_lvl;
                  map_delete( _bonus_cache, same_level[ j ] );
               }
            }
         } else {
            tmp_lvl = 0;
         }
      }
   }
   for (i=0;i<sizeof(recursive_skills);i++) {
      if ( !not_there( recursive_skills[ i ] ) ) {
         new_skills[recursive_skills[i]] += lvl;
         if (new_skills[recursive_skills[i]] < 0) {
            new_skills[recursive_skills[i]] = 0;
         }
      }
      map_delete(_bonus_cache, recursive_skills[i]);
   }
   if ( not_there( skill ) ) {
      new_skills[skill] = lvl;
   }
   tree = (string *)SKILL_OB->query_skill_tree(skill);
   for (i=1;i<sizeof(tree);i++) {
      int total, j;
      same_level = (string *)SKILL_OB->query_immediate_children(tree[i]);
      if (sizeof(same_level)) {
         total = 0;
         for (j=0;j<sizeof(same_level);j++) {
            if ( not_there( same_level[ j ] ) ) {
               new_skills[ same_level[ j ] ] = new_skills[ tree[ i ] ];
               map_delete( _bonus_cache, same_level[ j ] );
            }
            total += new_skills[same_level[j]];
         }
         new_skills[tree[i]] = total/sizeof(same_level);
         map_delete( _bonus_cache, tree[ i ] );
      }
   }
   if ( interactive( this_object() ) &&
         ( guild = (string)this_object()->query_guild_ob() ) ) {
      if ( stringp( guild ) ) {
         guild->skills_advanced( this_object(), skill, new_skills[ skill ] );
      }
  }
  if((lvl == 1) && userp(this_object()) && (!exp || objectp(exp))) {
    if(!exp)
      exp = previous_object();
    if(!tm_check_ok(skill, exp)) {
      new_skills[skill] -= 1;
      return 0;
    } else {
      TASKER->award_made( (string)this_object()->query_name(),
                          base_name( exp ), skill, new_skills[ skill ] );
    }
  }
  if ( find_call_out( "reset_all" ) == -1 ) {
    call_out( "reset_all", 1 );
  }
  if(interactive(this_object()) && !this_object()->query_auto_loading())
     this_object()->save();
  return 1;
}
varargs int stat_modify( int lvl, string skill, int use_base_stats ) {
   int i, stat;
   string stat_bonus;
   float bonus;
   bonus = 0.0;
   if ( !_stat_cache[ skill ] || use_base_stats ) {
      stat_bonus = (string)SKILL_OB->query_skill_stat(skill);
      foreach ( i in stat_bonus ) {
         switch( i ) {
            case 'C' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_con();
               else
                  stat = (int)this_object()->query_con();
               break;
            case 'D' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_dex();
               else
                  stat = (int)this_object()->query_dex();
               break;
            case 'I' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_int();
               else
                  stat = (int)this_object()->query_int();
               break;
            case 'S' :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_str();
               else
                  stat = (int)this_object()->query_str();
               break;
            case 'W' :
            default :
               if ( use_base_stats )
                  stat = (int)this_object()->query_real_wis();
               else
                  stat = (int)this_object()->query_wis();
         }
         if (stat > 0) {
            bonus += (log(stat) / 9.8) - 0.25;
         } else if (stat < 0) {
            bonus -= (log(-stat) / 9.8) + 0.25;
         } else {
            bonus -= 0.25;
         }
         if ( !_stat_cache[ i ] ) {
            _stat_cache[ i ] = ({ skill });
         } else {
            _stat_cache[ i ] |= ({ skill });
         }
      }
      if ( !use_base_stats ) {
         _stat_cache[ skill ] = ({ bonus, stat_bonus });
      }
   } else {
      bonus = _stat_cache[ skill ][ 0 ];
      stat_bonus = _stat_cache[ skill ][ 1 ];
   }
   i = strlen( stat_bonus );
   if ( i ) {
      stat = to_int(lvl + ( lvl * bonus ));
      if (stat < 0) {
         return 0;
      }
      return stat;
   }
   return lvl;
}
varargs int calc_bonus( int lvl, string skill, int use_base_stats ) {
   if (lvl > 60) {
      lvl = 170 + ((lvl-60) >> 1);
   } else if (lvl > 40) {
      lvl = 150 + (lvl-40);
   } else if (lvl > 20) {
      lvl = 100 + ( ((lvl-20)*5) >> 1);
   } else {
      lvl = lvl * 5;
   }
   if ( !use_base_stats ) {
      _bonus_cache[ skill ] = lvl;
   }
   return stat_modify( lvl, skill, use_base_stats );
}
int query_skill_successful(string str, int mod) {
  return (query_skill_bonus(str, 0) + mod >= random(200));
}
void add_teach_offer(object ob, string skill, int num, int lvl, int xp) {
  _teach_offer[ob] = ({ skill, num, lvl, xp });
}
mapping query_teach_offer() { return copy(_teach_offer); }
void stop_teaching_skills(int left, mixed bing) {
   object ob;
   if (left > 0) {
      if (bing[O_OTHER_PER] == this_object()) {
         say(this_object()->short() + " stops teaching themselves some "
             "skills.\n");
      } else if (previous_object() == this_object()) {
         ob = bing[O_OTHER_PER];
         tell_object(ob, this_object()->short() + " interupts your "
                         "training.\n");
      } else {
         ob = this_object();
         tell_object(ob, bing[O_OTHER_PER]->short() + " interupts your "
                         "training.\n");
      }
      say(bing[O_OTHER_PER]->short() + " stops teaching some skills to " +
          this_object()->short() + ".\n",
          ({ this_object(), bing[O_OTHER_PER] }));
      this_object()->adjust_time_left(-((int)this_object()->query_time_left()));
      this_object()->set_interupt_command(0);
      return ;
   }
   if (previous_object() != this_object()) {
      return ;
   }
   if(this_object()->query_xp() < bing[O_XP]) {
      write("Something has gone wrong. :(\n");
      return;
   }
   if (this_object() != bing[O_OTHER_PER]) {
      bing[O_OTHER_PER]->adjust_xp(bing[O_XP]/10);
   }
   this_object()->adjust_xp(-bing[O_XP]);
   add_skill_level(bing[O_SKILL], bing[O_NUM], bing[O_XP]);
   if (this_object() != bing[O_OTHER_PER]) {
      tell_object(this_object(), "You finish learning " + bing[O_NUM] +
                  " levels of "
                  + bing[O_SKILL] + " from " + bing[O_OTHER_PER]->short() +
                  ".\n");
      tell_object(bing[O_OTHER_PER], this_object()->short() + " finishes " +
                  "learning " + bing[O_NUM] + " levels of "
                  +bing[O_SKILL] + " from you.\n");
      say(this_object()->short() + " finishes learning some skills "+
          "from "+bing[O_OTHER_PER]->short()+".\n",
          ({ this_object(), bing[O_OTHER_PER] }));
   } else {
      tell_object(this_object(), "You finish teaching yourself " + bing[O_NUM] +
                  " levels of " + bing[O_SKILL] + ".\n");
      say(this_object()->short() + " finishes learning some skills "
          "from " + this_object()->query_objective() + "self.\n",
          ({ this_object(), bing[O_OTHER_PER] }));
   }
}

==================================================
FILE: living/spells.c
==================================================

#include <spells.h>
class spell_process {
   mapping spells;
   mapping process;
}
private mixed spells;
void create() {
   spells = ([ ]);
}
string help_spell(string str) {
   if (!mapp(spells)) {
     spells = ([ ]);
   }
   if (!m_sizeof(spells)) {
      return 0;
   }
   if (!spells[str]) {
      return 0;
   }
   return (string)spells[str][S_OBJECT]->help(str);
}
mapping query_spells() {
   if (!mapp(spells)) {
      spells = ([ ]);
   }
   return spells;
}
mapping query_spells_nocase() {
  mapping lc_spells = ([]);
  filter( this_object()->query_spells(),
                 (: $3 += ([ lower_case( $1 ) : $2 ]) :), lc_spells );
  return lc_spells;
}
int add_spell(string name, mixed ob, mixed func) {
   int i;
   mapping tmp;
   if (pointerp(spells)) {
      tmp = ([ ]);
      for (i=0;i<sizeof(spells);i+=2)
         tmp[spells[i]] = spells[i+1];
      spells = tmp;
   }
   if (!mapp(spells)) {
      spells = ([ ]);
   }
   spells[name] = ({ ob, func });
   return 1;
}
int remove_spell(string name) {
  string spell, name_lc;
  if ( !name ) {
      map_delete( spells, 0 );
      return 1;
  }
  name_lc = lower_case(name);
  foreach (spell in keys(spells)) {
     if (lower_case(spell) == name_lc) {
        map_delete(spells, spell);
     }
  }
  return 1;
}
mixed query_spell( string word ) {
   mapping tmp_spells;
   string test_spell;
   if ( !mapp( spells ) ) {
      return 0;
   }
   tmp_spells = query_spells_nocase();
   test_spell = lower_case(this_object()->expand_nickname(word));
   return tmp_spells[test_spell];
}
protected void reset_spells() {
   spells = ([ ]);
}

==================================================
FILE: living/stats.c
==================================================

#include <move_failures.h>
#include <skills.h>
#include <living.h>
#include <config.h>
#define BASE 20
#define ORD1T 1
#define ORD1B 1
#define ORD2T 1
#define ORD2B 5
#define SCALING_DATA ({ 650, 150, 10, 5 })
#define DIVISOR 700
#define DEATH_WAIT_TIME 5
#define INIT_GP_INC -20
int Con, Dex, Int, Str, Wis,
    contmp, dextmp, inttmp, strtmp, wistmp,
    height, base_weight;
nosave int conbon, dexbon, intbon, strbon, wisbon, no_check;
nosave string to_zap;
nosave int gp_inc = INIT_GP_INC, hp_inc;
mixed query_property(string name);
string stats_to_zap() {
   string temp;
   temp = to_zap;
   to_zap = 0;
   return temp;
}
void zap_stat( string word ) {
   string dummy;
   if ( !to_zap ) {
      to_zap = word;
      if ( find_call_out( "zap_stat_cache" ) == -1 )
         call_out( "zap_stat_cache", 1 );
   }
   if ( sscanf( to_zap, "%s"+ word +"%s", dummy, dummy ) != 2 )
      to_zap += word;
}
int query_no_check() { return no_check; }
void set_no_check( int i ) { no_check = i; }
int hp_base() {
  int base;
  base = 150 + 10 * (int)this_object()->query_con();
  if ( base < 5 ) base = 5;
  return base;
}
int hp_gradient() { return 4; }
int scaled_weight() {
  int i, actual, scaled;
  actual = (int)this_object()->query_weight(1);
  if ( actual < SCALING_DATA[ 0 ] )
    return actual;
  scaled += SCALING_DATA[ 0 ];
  actual -= SCALING_DATA[ 0 ];
  i = 1;
  while ( actual && ( ( i * SCALING_DATA[ 2 ] ) < 100 ) ) {
    if ( actual >= SCALING_DATA[ 1 ] ) {
      scaled += ( ( 100 - SCALING_DATA[ 2 ] * i ) * SCALING_DATA[ 1 ] )
          / 100;
      scaled += ( SCALING_DATA[ 3 ] * SCALING_DATA[ 1 ] ) / 1000;
      actual -= SCALING_DATA[ 1 ];
    } else {
      scaled += ( ( 100 - SCALING_DATA[ 2 ] * i ) * actual ) / 100;
      scaled += ( SCALING_DATA[ 3 ] * actual ) / 1000;
      actual = 0;
    }
    i += 1;
  }
  if ( actual )
    scaled += ( SCALING_DATA[ 3 ] * actual ) / 1000;
  return scaled;
}
void reset_hp() {
  int new_max, skill_bon;
  string report;
  if ( no_check )
    return;
  skill_bon = (int)this_object()->query_skill_bonus( "other.health" );
  new_max = hp_base() + skill_bon * hp_gradient();
  if ( !base_weight ) {
    if ( (string)this_object()->query_name() == "object" )
      return;
    report = file_name( this_object() ) +" ("+
        (string)this_object()->query_name() +"): race object is "+
        (string)this_object()->query_race_ob();
    if ( environment() ) {
      if ( file_name( environment() ) == "/room/void" )
        return;
      report += "; in "+ file_name( environment() );
      this_object()->move( "/room/void", "$N gets booted into the void for "+
          "being a bad NPC." );
    }
    report += ".\n";
    log_file( "BAD_NPC", ctime(time()) + " " + report );
    return;
  }
   new_max = ( new_max * scaled_weight() ) / DIVISOR;
   if ( new_max < 1 )
      this_object()->set_max_hp( 1 );
   else
      this_object()->set_max_hp( new_max );
}
void reset_gp() {
   string guild_ob;
   if ( no_check )
      return;
   guild_ob = (string)this_object()->query_guild_ob();
   if (!guild_ob) {
      guild_ob = query_property("backup guild");
   }
   if ( !guild_ob ) {
      this_object()->set_max_gp( 50 +
            (int)this_object()->query_skill_bonus( "other.points" ) );
   } else {
      guild_ob->set_gp( this_object() );
   }
}
void calc_inc_rates() {
   string guild_ob;
   hp_inc = sqrt((int)this_object()->stat_modify(100, "other.health")) - 7;
   guild_ob = (string)this_object()->query_guild_ob();
   if ( !guild_ob ) {
     guild_ob = query_property("backup guild");
     if (!guild_ob) {
       guild_ob = CONFIG_DEFAULT_GUILD;
     }
   }
   gp_inc = sqrt((int)this_object()->stat_modify(100,
         (string)guild_ob->query_gp_skill())) - 7;
   if(hp_inc < 0) {
     hp_inc = 0;
   }
   if(gp_inc < 0) {
     gp_inc = 0;
   }
}
int *query_inc_rates() { return ({ gp_inc, hp_inc }); }
void heart_beat() {
   int hp;
   int calling_death;
   hp = this_object()->query_hp();
   if ( hp < 0 ) {
       calling_death = this_object()->query_callingdeath();
        if ( calling_death ) {
           if ( time() > calling_death + DEATH_WAIT_TIME ) {
                this_object()->do_death();
            }
        } else {
            this_object()->do_death();
        }
   }
   else {
      if ( gp_inc == INIT_GP_INC ) {
         calc_inc_rates();
      }
      this_object()->adjust_gp( gp_inc );
      this_object()->adjust_hp( hp_inc );
   }
}
void reset_carry_cap() {
   int i, hst_num, hst_wei, new_cap, old_loc, tot_str;
   object *contents, *dropped;
   if ( no_check ) return;
   old_loc = (int)this_object()->query_loc_weight();
   tot_str = Str + strtmp + strbon;
   new_cap = BASE;
   new_cap += ( ORD1T * tot_str ) / ORD1B;
   new_cap += ( ORD2T * tot_str * tot_str ) / ORD2B;
   new_cap = ( new_cap * (int)this_object()->query_weight(1) ) / 100;
   if ( !new_cap )
      new_cap = 1;
   this_object()->set_max_weight( new_cap );
   if ( new_cap >= old_loc ) return;
   this_object()->dest_hide_shadow();
   contents = all_inventory( this_object() ) -
      (object *)this_object()->query_armours();
   dropped = ({ });
   while ( ( old_loc > new_cap ) && sizeof( contents ) ) {
      hst_num = 0;
      hst_wei = 0;
      for ( i = 0; i < sizeof( contents ); i++ )
         if ( (int)contents[ i ]->query_complete_weight() > hst_wei ) {
            hst_wei = (int)contents[ i ]->query_complete_weight();
            hst_num = i;
         }
      if ( (int)contents[ hst_num ]->move( environment() ) == MOVE_OK ) {
         dropped += ({ contents[ hst_num ] });
         old_loc -= hst_wei;
      }
      contents = delete( contents, hst_num, 1 );
   }
   if ( sizeof( dropped ) ) {
      tell_room( environment(), capitalize( (string)this_object()->short() ) +
                " drops "+ query_multiple_short( dropped ) +" under strain.\n",
                this_object() );
      tell_object( this_object(), "Your fading strength makes you drop "+
                  query_multiple_short( dropped ) +".\n" );
   }
   this_object()->update_loc_weight();
   this_object()->calc_burden();
   if ( new_cap >= old_loc ) return;
   return;
}
void check_stats_zero() {
   if ( Int + inttmp + intbon <= 0 ||
        Wis + wistmp + wisbon <= 0 ) {
      this_object()->add_property( PASSED_OUT, 1, 500 );
      tell_object( this_object(), "You fall asleep.\n" );
   }
}
void reset_all() { zap_stat( "CDISW" ); }
void reset_all2() {
   no_check = 0;
   reset_hp();
   reset_gp();
   reset_carry_cap();
   calc_inc_rates();
   check_stats_zero();
   this_object()->do_burden_call();
}
int query_con() { return Con + contmp + conbon; }
int query_dex() { return Dex + dextmp + dexbon; }
int query_int() { return Int + inttmp + intbon; }
int query_str() { return Str + strtmp + strbon; }
int query_wis() { return Wis + wistmp + wisbon; }
int query_real_con() { return Con; }
int query_real_dex() { return Dex; }
int query_real_int() { return Int; }
int query_real_str() { return Str; }
int query_real_wis() { return Wis; }
int check( int number ) { return ( number <= 28 ); }
int set_con( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Con != number )
    zap_stat( "C" );
  Con = number;
  return Con;
}
int set_dex( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Dex != number )
    zap_stat( "D" );
  Dex = number;
  return Dex;
}
int set_int( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Int != number )
    zap_stat( "I" );
  Int = number;
  return Int;
}
int set_str( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Str != number )
    zap_stat( "S" );
  Str = number;
  return Str;
}
int set_wis( int number ) {
  if ( !check( number ) ) number = 28;
  if ( Wis != number )
    zap_stat( "W" );
  Wis = number;
  return Wis;
}
int adjust_con( int number ) {
  if ( check( number + Con ) ) {
    Con += number;
    if ( number )
      zap_stat( "C" );
  }
  return Con;
}
int adjust_dex( int number ) {
  if ( check( number + Dex ) ) {
    Dex += number;
    if ( number )
      zap_stat( "D" );
  }
  return Dex;
}
int adjust_int( int number ) {
  if ( check( number + Int ) ) {
    Int += number;
    if ( number )
      zap_stat( "I" );
  }
  return Int;
}
int adjust_str( int number ) {
  if ( check( number + Str ) ) {
    Str += number;
    if ( number )
      zap_stat( "S" );
  }
  return Str;
}
int adjust_wis( int number ) {
  if ( check( number + Wis ) ) {
    Wis += number;
    if ( number )
      zap_stat( "W" );
  }
  return Wis;
}
int query_tmp_con() { return contmp; }
int query_tmp_dex() { return dextmp; }
int query_tmp_int() { return inttmp; }
int query_tmp_str() { return strtmp; }
int query_tmp_wis() { return wistmp; }
int adjust_tmp_con( int number ) {
  contmp += number;
  if ( number )
    zap_stat( "C" );
   if ( contmp && !dextmp && !inttmp && !strtmp && !wistmp )
      call_out( "update_tmps", 900 );
  return contmp;
}
int adjust_tmp_dex( int number ) {
  dextmp += number;
  if ( number )
    zap_stat( "D" );
   if ( !contmp && dextmp && !inttmp && !strtmp && !wistmp )
      call_out( "update_tmps", 900 );
  return dextmp;
}
int adjust_tmp_int( int number ) {
  inttmp += number;
  if ( number )
    zap_stat( "I" );
   if ( !contmp && !dextmp && inttmp && !strtmp && !wistmp )
      call_out( "update_tmps", 900 );
  return inttmp;
}
int adjust_tmp_str( int number ) {
  strtmp += number;
  if ( number )
    zap_stat( "S" );
   if ( !contmp && !dextmp && !inttmp && strtmp && !wistmp )
      call_out( "update_tmps", 900 );
  return strtmp;
}
int adjust_tmp_wis( int number ) {
  wistmp += number;
  if ( number )
    zap_stat( "W" );
   if ( !contmp && !dextmp && !inttmp && !strtmp && wistmp )
      call_out( "update_tmps", 900 );
  return wistmp;
}
int query_bonus_con() { return conbon; }
int query_bonus_dex() { return dexbon; }
int query_bonus_int() { return intbon; }
int query_bonus_str() { return strbon; }
int query_bonus_wis() { return wisbon; }
int adjust_bonus_con( int number ) {
  conbon += number;
  if ( number )
    zap_stat( "C" );
  return conbon;
}
int adjust_bonus_dex( int number ) {
  dexbon += number;
  if ( number )
    zap_stat( "D" );
  return dexbon;
}
int adjust_bonus_int( int number ) {
  intbon += number;
  if ( number )
    zap_stat( "I" );
  return intbon;
}
int adjust_bonus_str( int number ) {
  strbon += number;
  if ( number )
    zap_stat( "S" );
  return strbon;
}
int adjust_bonus_wis( int number ) {
  wisbon += number;
  if ( number )
    zap_stat( "W" );
  return wisbon;
}
void update_tmps() {
  if ( contmp ) {
    zap_stat( "C" );
    contmp = contmp / 2;
  }
  if ( dextmp ) {
    zap_stat( "D" );
    dextmp = dextmp / 2;
  }
  if ( inttmp ) {
    zap_stat( "I" );
    inttmp = inttmp / 2;
  }
  if ( strtmp ) {
    zap_stat( "S" );
    strtmp = strtmp / 2;
  }
  if ( wistmp ) {
    zap_stat( "W" );
    wistmp = wistmp / 2;
  }
   if ( contmp || dextmp || inttmp || strtmp || wistmp )
      call_out( "update_tmps", 900 );
}
int query_height() { return height; }
void set_height( int number ) {
  if ( number > 0 ) height = number;
}
int query_base_weight() { return base_weight; }
void set_base_weight( int number ) {
   if ( number > 0 )
      base_weight = number;
}
int query_weight(int) {
  int adjust_weight;
  adjust_weight = ( ( ( Con + 3 * Str ) / 4 ) - 13 ) * ( base_weight / 30 );
  return base_weight + adjust_weight;
}
mixed *stats() {
  return ({
    ({ "Con", Con + conbon + contmp }),
    ({ "Dex", Dex + dexbon + dextmp }),
    ({ "Int", Int + intbon + inttmp }),
    ({ "Str", Str + strbon + strtmp }),
    ({ "Wis", Wis + wisbon + wistmp }),
    ({ "tmp Con", contmp }),
    ({ "tmp Dex", dextmp }),
    ({ "tmp Int", inttmp }),
    ({ "tmp Str", strtmp }),
    ({ "tmp Wis", wistmp }),
    ({ "bonus Con", conbon }),
    ({ "bonus Dex", dexbon }),
    ({ "bonus Int", intbon }),
    ({ "bonus Str", strbon }),
    ({ "bonus Wis", wisbon }),
    ({ "hp rate", hp_inc }),
    ({ "gp rate", gp_inc }),
    ({ "height", height }),
  });
}

==================================================
FILE: outsides/basic.c
==================================================

#include <terrain_map.h>
#define CREATOR "Ceres"
inherit TERRAIN_MAP_OUTSIDE_BASE;
mixed do_get_rock( string verb, object *dest ) {
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    return ( rock = clone_object( (string)query_property( "rock object" ) ) );
  if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
    rock_size = 3;
  if ( !rock_size ) return 0;
  rock = clone_object( "/obj/mineral" );
  if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
    rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                   "slate" })[ random( 6 ) ];
  rock->make_mineral( rock_type, 1 + random( rock_size ) );
  if ( !( rock->move( this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}

==================================================
FILE: outsides/desert.c
==================================================

#define CREATOR "Ceres"
#include <weather.h>
#include <move_failures.h>
#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
void create() {
  ::create();
  set_climate("Bw");
  add_item("sand", "There is a lot of sand here, tons of it just lying "
     "about the place.");
  add_item("rock", "There are small rocks here and there in the sand.");
  room_chat(({120, 240, ({"Grains of sand are blown about in the slight "
          "breeze."})}));
  add_property("rock size", 2+random(5));
  add_property("track type", "desert");
  add_property("sand object", "/obj/media/sand");
}
string query_terrain_map_colour() { return "%^ORANGE%^"; }
int do_get_rock(object *indirs, string dir, string indir, mixed *args,
    string pattern)
{
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    rock = clone_object(query_property("rock object"));
  else {
    if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
      rock_size = 3;
    if ( !rock_size ) return 0;
    rock = clone_object( "/obj/mineral" );
    if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
      rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                     "slate" })[ random( 6 ) ];
    rock->make_mineral(rock_type, 1 + random(rock_size));
  }
  if (!(rock->move(this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}
int do_get_sand(object *indirs, string dir, string indir, mixed *args,
    string pattern)
{
  object sand;
  sand = clone_object(query_property("sand object"));
  if (!sand) return 0;
  if (sand->move(this_player()) == MOVE_OK) {
    this_player()->add_succeeded_mess(sand, "$N $V $D.\n", ({ }) );
    return 1;
  }
  sand->dest_me();
  return 0;
}

==================================================
FILE: outsides/mountain.c
==================================================

#define CREATOR "Ceres"
#include <weather.h>
#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
void create() {
  ::create();
  add_property("climate", ({-10, 0, 0 }) );
  switch((string)WEATHER->query_season()) {
  case "spring":
    add_item("flower", ({"long", "Very occasionally there are beautiful "+
                           "snowdrops nestled in the shadow of a boulder.",
                         "get", ({this_object(), "do_get_flower"}),
                         "pick", ({this_object(), "do_get_flower"}),
                         "smell", "The flowers smell wonderful."
                         }));
    add_item("tree", "There are only a few stunted trees here clinging "+
             "to life on the steep slopes.  New leaves poke cautiously "+
             "from their gnarled branches");
    add_item(({"floor", "ground", "earth"}), "The ground is mostly covered "+
             "by hardy grass interspersed by small shrubs, however there "+
             "are large patches of bare rock or gravel.  "+
             "Here and there larger rocks protrude from the ground.");
    room_chat(({120, 240, ({"A bird of prey swoops overhead.",
                            "A small insect flies past your face."})}));
    add_property("flower type", "snowdrop");
    break;
  case "summer":
  case "autumn":
    add_item(({"floor", "ground", "earth"}), "The ground is largely "+
             "covered with a hardy grass interspersed with small shrubs, "+
             "however there are large patches of bare rock and gravel.  Here "+
             "and there larger rocks protrude from the ground.");
    add_item("tree", "There are a few small trees clinging to life in this "+
             "harsh environment.");
    room_chat(({120, 240, ({"The wind whistles through the mountain passes.",
                            "A bird of prey swoops overhead.",
                            "An insect brushes against your face."})}));
    break;
  case "winter":
    add_item(({"floor", "ground", "earth"}), "The ground is bare earth "+
             "apart from the occasional hardy shrub.");
    add_item("tree", "There are a few trees dotted around their bare "+
             "branches making them look like ghouhlish skeletons.");
    room_chat(({120, 240, ({"The cold wind whistles over the mountains."
                            })}));
    break;
  }
  add_item("rock", ({ "long", "A nice rock looking thingy.",
                      "get",  ({ this_object(), "do_get_rock" }) }) );
  add_item("shrub", "Dotted here and there these hardy plants struggle "+
           "to survive on the thin soil.");
  add_item("grass", "A particularly wiry kind of grass obviously suited "+
           "to the harsh conditions and thins soil.");
  add_property("rock size", 5+random(20));
  add_property("track type", "mountain");
}
mixed do_get_rock(string verb, object *dest ) {
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    return ( rock = clone_object( (string)query_property( "rock object" ) ) );
  if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
    rock_size = 3;
  if ( !rock_size ) return 0;
  rock = clone_object( "/obj/mineral" );
  if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
    rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                   "slate" })[ random( 6 ) ];
  rock->make_mineral(rock_type, 1 + random(rock_size));
  if (!(rock->move(this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}
mixed do_get_flower( string verb, object *dest ) {
  string flower_type;
  object flower;
  printf("Verb: %s\n", verb);
  if ( query_property( "flower object" ) )
    return (flower = clone_object((string)query_property("flower object")));
  if ((int)query_property("noflowers"))
    return 0;
  flower = clone_object("/std/plant");
  if(undefinedp(flower_type = (string)query_property("flower type")))
    flower_type = ({"forgetmenot", "violet"})[ random(2) ];
  flower->set_plant(flower_type);
  flower->set_plant_type(flower_type);
  flower->set_plant_desc("A beautiful "+flower_type+" picked before its "+
                         "time.\n");
  flower->add_plural( capitalize( flower_type ) );
  if (!(flower->move(this_player()))) return 1;
  flower->dest_me();
  return 0;
}

==================================================
FILE: outsides/plain.c
==================================================

#define CREATOR "Ceres"
#include <weather.h>
#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_light(80);
  set_climate("Aw");
  add_zone("plain");
  switch((string)WEATHER->query_season()) {
  case "spring":
    add_item("flower", ({"long", "Some pretty flowers.",
                         "get", ({this_object(), "do_get_flower"}),
                         "pick", ({this_object(), "do_get_flower"}),
                         "smell", "The flowers smell wonderful."
                         }));
    add_item("tree", "There is the occasional tree here and there covered "
             "with new leaves at this time of year.");
    add_item(({"floor", "ground", "earth"}),
             "The ground is mostly grassy "
             "with the occasional clump of wild flowers.");
    room_chat(({120, 240, ({"Birds sing loudly announcing their presence.",
                              "Bees buzz busily from flower to flower.",
                              "A butterfly alights on a nearby flower.",
                              "A bird takes off from a tree and flies low "
                              "across the fields."})}));
    break;
  case "summer":
    add_item(({"floor", "ground", "earth"}), "The ground is mostly grassy.  "
               "The grass is long and sways gently in the breeze.  Here and "
               "there amongst the grass are wild flowers and other plants.");
    add_item("tree", "There are a few trees which are in their full "
             "foliage right now.");
    add_item(({"flower", "plant"}),
             ({"long", "Some pretty flowers.",
                 "get", ({this_object(), "do_get_flower"}),
                 "pick", ({this_object(), "do_get_flower"}),
                   "smell", "The flowers smell wonderful."
                     }));
    room_chat(({120, 240,
                  ({"The wind stirs the grass which sways reminding "
                      "you of waves on an ocean.",
                      "A small animal rustles in the long grass.",
                      "A butterfly alights on a nearby flower.",
                      "A bee buzzes around looking for nectar."})}));
    break;
  case "autumn":
    add_item(({"floor", "ground", "earth"}), "The ground is mostly grassy.");
    add_item("tree", "The occasional trees are gold and brown as their "
             "leaves die before winter.");
    room_chat(({120, 240, ({"A squirrel rushes up a nearby tree trunk.",
                              "A bird of prey soars high overhead looking "
                              "for something to eat."})}));
    break;
  case "winter":
    add_item(({"floor", "ground", "earth"}), "The ground is mostly grassy "+
               "apart from the occasional hardy shrub.");
    add_item("tree", "Dotted here and there are skeletal trees bare of "
             "leaves waiting for spring.");
    room_chat(({120, 240, ({"Somewhere a small animal forages in the "
                              "undergrowth for winter food."})}));
    break;
  }
  add_item("rock", ({ "long", "A nice rock looking thingy.",
                        "get",  ({ this_object(), "do_get_rock" }) }) );
  if (!do_setup) {
    this_object()->setup();
    this_object()->reset();
  }
}
mixed do_get_rock( string verb, object *dest ) {
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    return ( rock = clone_object( (string)query_property( "rock object" ) ) );
  if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
    rock_size = 3;
  if ( !rock_size ) return 0;
  rock = clone_object( "/obj/mineral" );
  if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
    rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                   "slate" })[ random( 6 ) ];
  rock->make_mineral( rock_type, 1 + random( rock_size ) );
  if ( !( rock->move( this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}
mixed do_get_flower( string verb, object *dest ) {
  string flower_type;
  object flower;
  if ( query_property( "flower object" ) )
    return (flower = clone_object((string)query_property("flower object")));
  if ((int)query_property("noflowers"))
    return 0;
  flower = clone_object("/std/plant");
  if(undefinedp(flower_type = (string)query_property("flower type")))
    flower_type = ({"forgetmenot", "buttercup", "daisy"})[ random(2) ];
  flower->set_plant(flower_type);
  flower->set_plant_type(flower_type);
  flower->set_plant_desc("A beautiful "+flower_type+" picked before its "
                         "time.");
  flower->add_plural( pluralize( flower_type ) );
  if (!(flower->move(this_player()))) return 1;
  flower->dest_me();
  return 0;
}

==================================================
FILE: outsides/road.c
==================================================

#define CREATOR "Ceres"
#include <weather.h>
#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
void create() {
  do_setup++;
  ::create();
  do_setup--;
  add_property("track type", "road");
  add_zone("road");
  if(!do_setup) {
    this_object()->setup();
    this_object()->reset();
  }
}
string query_terrain_map_colour() { return "%^RED%^"; }
string query_terrain_map_character() { return "#"; }

==================================================
FILE: outsides/woodland.c
==================================================

#define CREATOR "Ceres"
#include <weather.h>
#include <terrain_map.h>
inherit TERRAIN_MAP_OUTSIDE_BASE;
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_light(80);
  add_zone("woodland");
  switch((string)WEATHER->query_season()) {
  case "spring":
    add_item("flower", ({"long", "Some pretty flowers.",
                         "get", ({this_object(), "do_get_flower"}),
                         "pick", ({this_object(), "do_get_flower"}),
                         "smell", "The flowers smell wonderful.\n"
                         }));
    add_item("tree", "There are trees everywhere here, you have "+
             "to pick your way between them.  They are budding with "+
             "new leaves at this time of year.");
    add_item(({"floor", "ground", "earth"}), "The ground is covered "+
             "by a beautiful carpet of flowers interspersed with small "+
             "shrubs.");
    add_item("shrub", "Dotted here and there among the carpet of flowers "+
             "are small shrubs, some thorny, all green.");
    room_chat(({120, 240, ({"Birds sing loudly announcing their presence.",
                            "Bees buzz busily from flower to flower.",
                            "A squirrel rushes up a nearby tree trunk.",
                            "A butterfly alights on a nearby flower.",
                            "A bird takes off from a tree with a furious "+
                              "beating of wings."})}));
    add_property("flower type", "bluebell");
    break;
  case "summer":
    add_item(({"floor", "ground", "earth"}), "You can barely see the "+
             "ground because of the waist-high ferns.  Dotted among the "+
             "ferns are small shrubs.");
    add_item("shrub", "Dotted here and there among the ferns "+
             "are small shrubs, some thorny, all green.");
    add_item("fern", "Everywhere you look there are ferns growing "+
                         "almost waist high between the trees.");
    add_item("tree", "The trees are in their full foliage right now.");
    room_chat(({120, 240, ({"The wind stirs the leaves of the trees making "+
                              "a sound like falling rain.",
                            "A squirrel rushes up a nearby tree trunk.",
                            "A butterfly alights on a nearby flower.",
                            "A bird takes off from a tree with a furious "+
                              "beating of wings."})}));
    break;
  case "autumn":
    add_item(({"floor", "ground", "earth"}), "The ground is littered "+
             "with dead leaves and the stems of dying ferns.");
    add_item("tree", "You are surrounded by trees, they are resplendent "+
             "with their autumn colours of red, gold and brown.");
    add_item("shrub", "Dotted here and there among the ferns "+
             "are small shrubs many with brightly coloured berries.");
    add_item(({"berry", "berries"}),
               ({"long", "There are a variety of berries hanging from the "+
                   "shrubs here.",
                 "get", ({this_object(), "do_get_berry"}),
                 "pick", ({this_object(), "do_get_berry"})}));
    add_item(({"leaf", "leaves"}),
             ({"long", "The ground is littered with dead leaves.",
               "get", ({this_object(), "do_get_leaf"})}));
    add_item("fern", "Here and there are the stems of ferns which have "+
             "died back and will survive the coming winter underground.");
    room_chat(({120, 240, ({"The wind stirs the leaves of the trees causing "+
                              "some to fall gently to earth.",
                            "A squirrel rushes up a nearby tree trunk.",
                            "A bird takes off from a tree with a furious "+
                              "beating of wings."})}));
    add_extra_look(this_object());
    break;
  case "winter":
    add_item(({"floor", "ground", "earth"}), "The ground is bare earth "+
             "apart from the occasional hardy shrub.");
    add_item("shrub", "Dotted here and there among the trees are small "+
             "shrubs trying to survive the winter.");
    add_item("tree", "There are bare trees everywhere here waiting for the "+
             "coming of spring.");
    room_chat(({120, 240, ({"The wind stirs the dry branches of the trees "+
                              "causing them to rustle eerily.",
                            "Somewhere a small animal forages in the "+
                              "undergrowth for winter food."})}));
    break;
  }
  add_item("rock", ({ "long", "A nice rock looking thingy.",
                      "get",  ({ this_object(), "do_get_rock" }) }) );
  add_property("track type", "woodland");
  if(!do_setup) {
    this_object()->setup();
    this_object()->reset();
  }
}
string query_terrain_map_colour() { return "%^GREEN%^"; }
string extra_look() {
  string extra;
  extra = ::extra_look();
  switch((string)WEATHER->query_season()) {
  case "spring":
    return extra + "Spring flowers are everywhere you look.\n";
  case "autumn":
    return extra + "The ground is littered with fallen leaves.\n";
    break;
  default:
    return extra;
  }
}
mixed do_get_rock( string verb, object *dest ) {
  int rock_size;
  string rock_type;
  object rock;
  if ( query_property( "rock object" ) )
    return ( rock = clone_object( (string)query_property( "rock object" ) ) );
  if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
    rock_size = 3;
  if ( !rock_size ) return 0;
  rock = clone_object( "/obj/mineral" );
  if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
    rock_type = ({ "cinnabar", "coal", "rosy-quartz", "chalk", "flint",
                   "slate" })[ random( 6 ) ];
  rock->make_mineral( rock_type, 1 + random( rock_size ) );
  if ( !( rock->move( this_player() ) ) ) return 1;
  rock->dest_me();
  return 0;
}
mixed do_get_flower( string verb, object *dest ) {
  string flower_type;
  object flower;
  if ( query_property( "flower object" ) )
    return (flower = clone_object((string)query_property("flower object")));
  if ((int)query_property("noflowers"))
    return 0;
  flower = clone_object("/std/plant");
  if(undefinedp(flower_type = (string)query_property("flower type")))
    flower_type = ({"forgetmenot", "violet"})[ random(2) ];
  flower->set_plant(flower_type);
  flower->set_plant_type(flower_type);
  flower->set_plant_desc("A beautiful "+flower_type+" picked before its "+
                         "time.\n");
  flower->set_main_plural(flower_type + "s");
  if (!(flower->move(this_player()))) return 1;
  flower->dest_me();
  return 0;
}
mixed do_get_berry( string verb, object *dest ) {
  object berry;
  string berry_type;
  if ((int)query_property("noflowers"))
    return 0;
  berry_type = ({"blackberry", "raspberry", "blueberry", "strawberry",
                 "blackcurrant"})[random(5)];
   berry = clone_object( "/obj/food" );
  berry->set_name(berry_type);
  berry->set_short(berry_type);
  berry->set_long("This is a lovely, plump "+berry_type+" it looks good "+
                  "enough to eat.\n");
  berry->add_alias("berry");
  if (!(berry->move(this_player()))) return 1;
  berry->dest_me();
  return 0;
}
mixed do_get_leaf( string verb, object *dest ) {
  object leaf;
  string leaf_type;
  if ((int)query_property("noflowers"))
    return 0;
  leaf_type = ({"maple", "oak", "sycamore", "ash", "silver birch"})[random(5)];
  leaf = clone_object("/std/object");
  leaf->set_name("leaf");
  leaf->set_short(leaf_type+" leaf");
  leaf->set_long("This is a dead "+leaf_type+" leaf.  Its natural green "+
                 "has turned to shades of gold, red and brown.\n");
  leaf->add_adjective(leaf_type);
  if (!(leaf->move(this_player()))) return 1;
  leaf->dest_me();
  return 0;
}

==================================================
FILE: creator/workroom.c
==================================================

#include <config.h>
inherit "/std/room/basic_room";
object button, bookcase, board;
void setup() {
  set_short("workroom of "+ CREATOR);
  add_property( "determinate", "the ");
  set_light(100);
  set_long("This is the workroom of "+CREATOR+".  You can see a small "
     "wooden desk sulking in the corner of the room, it has a "
     "beautifully carved wooden rolly chair in front of it.  It "
     "looks like this was just newly created, there is a smell "
     "of paint and leather in the air.\n");
  add_item("chair",
        ({ "long", "The teak rolly chair has amazing carvings of dragons "
                   "and ... other things on it.  They almost seem alive, "
                   "you especially don't note the way the dragon "
                   "blinks at you.",
                   "position",
                   "the teak rolly chair" }) );
  add_item("desk", "The desk is made of mahogany with a touch of "
     "mountain ash.  The top has two little basket things "
     "on it labelled \"in\" and \"out\".  The in basket "
     "is rather small." );
  add_item( "dragon", "I told you, you don't notice it winking at you." );
  add_item("in basket", "The in basket is full of small yellow forms "
     "with large red letters on them saying "
     "\"Important read me first\" and then not "
     "appearing to actually have any thing else on "
     "them." );
  add_item( "out basket", "The out basket is completely empty." );
  add_item("basket", "There are two baskets sitting on top of the desk.  "
     "They have the words \"in\" and \"out\" written "
     "on them." );
  add_item("paint", "You look around to see the source of the paint "
     "smell and you can't find it.  The walls? of the room "
     "ummm seem to be well shall we just twisting in a "
     "confused mish mash of shapes, you are sure they are "
     "not threatening." );
  add_item("wall", "The walls are made up of a cloudy substance, white "
     "in nature that is roiling around the place where "
     "you are standing.  Great magic must be holding it "
     "back, every now and then you see a demonic head "
     "push its way out of the cloud roll its eyes and fade "
     "back into the cloud." );
  add_item("cloud", "The cloud is white coloured with a few flashes "
     "of light bursting in it." );
  add_item("demon", "The demonic heads that pop out are pretty nasty "
     "looking, they disapear with a snarl of strain." );
  add_exit("common", "/w/common", "door");
  add_exit("drum", CONFIG_START_LOCATION, "path");
  add_exit("learning", "/d/learning/main", "path");
  modify_exit( ({ "common", "drum", "learning" }),
      ({ "function", "check_player" }) );
  add_alias("north", "drum");
  add_alias("south", "common");
  "/w/common"->add_exit(CREATOR, "/w/"+CREATOR+"/workroom", "door");
}
void reset() {
  if (!button) {
    button = clone_object("/obj/misc/button");
    button->move(this_object());
  }
  if (!board) {
    board = clone_object("/obj/misc/board_mas");
    board->move(this_object() );
  }
  if (!bookcase) {
    bookcase = clone_object("/obj/cont_save");
    bookcase->set_name( "bookcase" );
    bookcase->set_short( "oaken bookcase" );
    bookcase->add_adjective( "wooden" );
    bookcase->add_adjective( "oak" );
    bookcase->add_adjective( "oaken" );
    bookcase->add_property( "there", "standing against the wall" );
    bookcase->set_long( "This bookcase is made from oak and "
      "varnished to bring out the glow.  It has 2 "
      "shelves, upon which you can see some books, and "
      "other objects.\n" );
    bookcase->set_weight( 2000 );
    bookcase->set_max_weight( 4000 );
    bookcase->reset_get();
    bookcase->check_euid();
    bookcase->set_save_file( "/w/"+CREATOR+"/creator_kit" );
    bookcase->move( this_object() );
  }
}
object *query_non_destable()  {
  return ({ bookcase, board });
}
int check_player( string verb, object player, string special ) {
    if ( interactive( player ) ) {
        return 1;
    }
    notify_fail( "" );
    return 0;
}

==================================================
FILE: races/amphibian.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "your standard amphibian" );
   set_height( 40 );
   set_weight( 600 );
   bits = ({
      "head", "head", ({ 0, 40, 0,
         "skull", "left eye", "right eye" }),
      "skull", "skull", ({ "head", 15, 0, "brain" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "brain", "brain", ({ "skull", 5, 0 }),
      "torso", "guts", ({ 0, 400, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen" }),
      "heart", "heart", ({ "guts", 10, 0 }),
      "liver", "liver", ({ "guts", 5, 0 }),
      "left kidney", "kidney", ({ "guts", 5, 0 }),
      "right kidney", "kidney", ({ "guts", 5, 0 }),
      "spleen", "spleen", ({ "guts", 5, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "right front leg", "leg", ({ 0, 200, 0 }),
      "left front leg", "leg", ({ 0, 200, 0 }),
      "right back leg", "leg", ({ 0, 200, 0 }),
      "left back leg", "leg", ({ 0, 200, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   inedible = ({ "skull" });
   unrottable = ({ "skull" });
   set_skin( "skin" );
   set_stats( ({ -4, 10, -4, -4, -6 }) );
   if( !do_setup )
      this_object()->setup();
}
int lives_in_water() { return 1; }

==================================================
FILE: races/ape.c
==================================================

inherit "/std/races/humanoid";
void setup() {
   set_name( "ape" );
   set_long( "The apes are any members of the family Pongidae of large "
      "semi-erect primates, including the chimpanzee, gorilla, orangutan "
      "and gibbon.\n" );
   set_weight( 2500 );
   set_height( 175 );
   set_stats( ({ 4, 4, 0, 4, 0 }) );
}
int query_eat( string type ) { return 1; }
string query_desc( object thing ) {
   if( (int)thing->query_gender() == 1 )
      return "He is your average hairy young male ape.\n";
   return "She is your average hairy young female ape.\n";
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_ac( "blunt", "blunt", 15 + level / 10 );
   thing->add_ac( "sharp", "sharp", 10 + level / 15 );
   thing->add_ac( "pierce", "pierce", 12 + level / 12 );
   thing->reset_all();
}
int query_dark( int light ) {
   if( light < 10 ) return 1;
   if( light > 200 ) return 2;
   return 0;
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 10 + ( 3 * sqrt( number ) ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->add_attack( "hands", 75, ({ 2 * number, 8, number }),
      "blunt", "unarmed", "unarmed_hands" );
   thing->add_attack( "feet", 25, ({ 3 * number, 10, number }),
      "blunt", "unarmed", 0 );
}

==================================================
FILE: races/arachnid.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "A creature like scorpion, spider, daddy longlegs, mite, "
      "tick, and certain other invertebrate animals.  This file should "
      "be inherited by a more specialised race object." );
   bits = ({
      "cephalothorax", "head", ({ 0, 200, 0,
         "middle right upper eye", "middle right lower eye",
         "middle left upper eye", "middle left lower eye",
         "right upper eye", "right lower eye",
         "left upper eye", "left lower eye", "brain", "ganglion",
         "left fang", "right fang", "stomach", "mandible" }),
      "middle right upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "middle right lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "middle left upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "middle left lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "right upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "right lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "left upper eye", "eye", ({ "cephalothorax", 25, 0 }),
      "left lower eye", "eye", ({ "cephalothorax", 25, 0 }),
      "brain", "brain", ({ "cephalothorax", 25, 0 }),
      "ganglion", "ganglion", ({ "cephalothorax", 50, 0 }),
      "left fang", "fang", ({ "cephalothorax", 25, 0 }),
      "right fang", "fang", ({ "cephalothorax", 25, 0 }),
      "stomach", "stomach", ({ "cephalothorax", 50, 0 }),
      "mandible", "mandible", ({ "cephalothorax", 25, 0 }),
      "abdomen", "abdomen", ({ 0, 500, 0, "lung", "stomach",
         "heart", "right front leg", "right middle front leg",
         "left front leg", "left middle front leg", "right back leg",
         "right middle back leg", "left back leg", "left middle back leg" }),
      "left middle back leg", "leg", ({ "abdomen", 25, 0 }),
      "left back leg", "leg", ({ "abdomen", 25, 0 }),
      "right middle back leg", "leg", ({ "addomen", 25, 0 }),
      "right back leg", "leg", ({ "abdomen", 25, 0 }),
      "right middle front leg", "leg", ({ "abdomen", 25, 0 }),
      "right front leg", "leg", ({ "abdomen", 25, 0 }),
      "left middle front leg", "leg", ({ "abdomen", 25, 0 }),
      "left front leg", "leg", ({ "abdomen", 25, 0 }),
      "lung", "lung", ({ "abdomen", 100, 0 }),
      "stomach", "stomach", ({ "abdomen", 100, 0 }),
      "heart", "heart", ({ "abdomen", 100, 0 }),
      "pedicel", "pedicel", ({ 0, 100, 0 })
   });
   inedible = ({ "left fang", "right fang", "mandible" });
   unrottable = ({ "left fang", "right fang", "mandible" });
   set_stats( ({ -6, 4, -6, -6, -6 }) );
   if( !do_setup )
      this_object()->setup();
}

==================================================
FILE: races/badger.c
==================================================

inherit "/std/races/mustelidae_base";
void setup() {
   set_name( "badger" );
   set_long( "A big black white and grey burowing animal.\n" );
   set_height( 30 );
   set_weight( 500 );
   set_desc( "small brown meateater" );
   set_stats( ({ 2, -2, -2, 2, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 3 + ( 2 * level + random( level ) ) / 8;
   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "chew" );
   thing->add_attack( "claws", 50, ({ ( 4 * number ) / 2, 8, 2 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 100, ({ 2 * number, 10, ( 3 * number )/2 }),
      "chew", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/base.c
==================================================

#define QUEST_AVE 140
#define QUEST_MAX 570
#define BASE 50
#define SCALE 10
#define NORM 15
#define EXPERT 20
#define A_TYPES ([ \
      "claws" : "sharp", \
      "chew" : "sharp", \
      "beak" : "pierce", \
      "bite" : "pierce", \
      "horn" : "pierce", \
      "hands" : "blunt", \
      "feet" : "blunt", \
      "tail" : "blunt", \
      "hoof" : "blunt", \
      "wrestle" : "blunt", \
   ])
inherit "/std/object";
private int height;
private int *sight;
private int *stats;
private string desc;
private string skin;
string *inedible;
string *unrottable;
string *pluckable;
private string *limbs;
private mixed *acs;
private mixed *attacks;
private mapping _fixed_bits;
mixed *bits;
void create() {
   do_setup++;
   ::create();
   do_setup--;
   sight = ({ 5, 20, 200, 300 });
   stats = allocate( 5 );
   desc = "a small non-descript thing";
   inedible = ({  });
   unrottable = ({  });
   pluckable = ({  });
   acs = ({ });
   attacks = ({ });
   bits = ({ });
   if ( !do_setup )
      this_object()->setup();
}
int query_height() { return height; }
void set_height( int number ) { height = number; }
int *query_sight() { return copy(sight); }
void set_sight( int *numbers ) { sight = numbers; }
int query_dark( int light ) {
   if ( light < sight[ 0 ] ) {
      return -2;
   }
   if ( light < sight[ 1 ] ) {
      return -1;
   }
   if ( light > sight[ 3 ] ) {
      return 2;
   }
   if ( light > sight[ 2 ] ) {
      return 1;
   }
   return 0;
}
int *query_stats() { return copy(stats); }
void set_stats( int *numbers ) { stats = numbers; }
string query_skin() { return skin; }
void set_skin( string word ) { skin = word; }
string query_desc( object thing ) {
   return capitalize( (string)thing->query_pronoun() ) +" is "+ desc +".\n";
}
void set_desc( string words ) { desc = words; }
string *query_limbs() {
   if ( !limbs ) {
      this_object()->find_limbs();
   }
   return copy(limbs);
}
void find_limbs() {
   int i;
   string limb;
   limbs = ({ });
   for ( i = 0; i < sizeof( bits ); i += 3 ) {
     if ( sscanf( bits[ i ], "%s hand", limb ) == 1 ) {
       limbs += ({ bits[ i ] });
     }
   }
}
mixed *query_acs() { return copy(acs); }
void add_ac( string ac_name, string ac_type, mixed ac_amount ) {
   acs += ({ ac_name, ac_type, ac_amount });
}
mixed *query_attacks() { return copy(attacks); }
void add_attack( string attack_name, int attack_chance, int *attack_data ) {
   attacks += ({ attack_name, attack_chance, attack_data });
}
mixed *query_bits() { return bits; }
mixed *query_bit( string word ) {
   int i;
   i = member_array( word, bits );
   if ( ( i == -1 ) || ( i % 3 ) ) {
      return ({ });
   }
   return bits[ i .. i + 2 ];
}
private void fixup_bits() {
   string* str_bits;
   string pl;
   int i;
   if (_fixed_bits) {
      return ;
   }
   _fixed_bits = ([ ]);
   for ( i = sizeof( bits ) - 3; i > -1; i -= 3 ) {
      str_bits = explode(bits[i], " ");
      pl = pluralize(str_bits[<1]);
      if (!_fixed_bits[str_bits[<1]]) {
         _fixed_bits[str_bits[<1]] = ({ });
      }
      _fixed_bits[str_bits[<1]] += ({ ({ str_bits[0..<2], i, 0 }) });
      if (!_fixed_bits[pl]) {
         _fixed_bits[pl] = ({ });
      }
      _fixed_bits[pl] += ({ ({ str_bits[0..<2], i, 1 }) });
   }
}
private string *query_old_possible_bits( string word ) {
   int i;
  int j;
  string *possibles;
  possibles = ({ });
  for ( i = sizeof( bits ) - 3; i > -1; i -= 3 ) {
    if ( ( bits[ i ] == word ) ||
          ( bits[ i + 1 ] == word ) ||
          !word) {
       if (arrayp( bits[i+2][2] )) {
         for ( j = 0; j < bits[i + 2][2][1]; j++) {
           possibles += ({ bits[ i ] });
         }
       } else {
         possibles += ({ bits[ i ] });
       }
     }
   }
   return possibles;
}
string *query_possible_bits( string word ) {
  string* str_bits;
  string* adj;
  string *possibles;
  mixed* bing;
  if(!word) {
    return query_old_possible_bits( word );
  }
  fixup_bits();
  str_bits = explode(word, " ");
  possibles = ({ });
  if (_fixed_bits[str_bits[<1]]) {
     adj = str_bits[0..<2];
     foreach (bing in _fixed_bits[str_bits[<1]]) {
        if (!bing[2] &&
            sizeof(adj) == sizeof(adj & bing[0])) {
           possibles += ({ bits[bing[1]] });
        }
     }
  }
  return possibles;
}
string *query_possible_plural_bits( string word ) {
  string* str_bits;
  string* adj;
  string *possibles;
  mixed* bing;
  fixup_bits();
  str_bits = explode(word, " ");
  possibles = ({ });
  if (_fixed_bits[str_bits[<1]]) {
     adj = str_bits[0..<2];
     foreach (bing in _fixed_bits[str_bits[<1]]) {
        if (bing[2] &&
            sizeof(adj) == sizeof(adj & bing[0])) {
           possibles += ({ bits[bing[1]] });
        }
     }
  }
  return possibles;
}
void add_bit( string bit_short, string bit_name, mixed *bit_array ) {
   int i;
   i = member_array( bit_short, bits );
   if ( !( i % 3 ) ) {
      bits[ i ] = bit_short;
      bits[ i + 1 ] = bit_name;
      bits[ i + 2 ] = bit_array;
      return;
   }
   bits += ({ bit_short, bit_name, bit_array });
}
void remove_bit( string word ) {
   int i;
   i = member_array( word, bits );
   if ( ( i == -1 ) || ( i % 3 ) ) {
      return;
   }
   bits = delete( bits, i, 3 );
}
int modifier( int number ) {
   return ( number * ( roll_MdN( 20, 21 ) - 220 ) ) / 2000;
}
void start_player( object thing ) {
   if ( !thing->query_base_weight() ) {
      thing->set_base_weight( 1 + weight + modifier( weight ) );
   }
   if ( !thing->query_height() ) {
      thing->set_height( 1 + height + modifier( height ) );
   }
   thing->adjust_bonus_con( stats[ 0 ] );
   thing->adjust_bonus_dex( stats[ 1 ] );
   thing->adjust_bonus_int( stats[ 2 ] );
   thing->adjust_bonus_str( stats[ 3 ] );
   thing->adjust_bonus_wis( stats[ 4 ] );
   thing->reset_all();
   if ( skin ) {
      thing->set_skin( skin );
   }
}
int query_number_worn( string type ) {
   switch ( type ) {
      case "armband" :
         return 2;
      case "badge" :
         return 15;
      case "bracelet" :
         return 4;
      case "earring" :
        return 2;
      case "garter" :
         return 2;
      case "shoulder" :
         return 2;
      case "necklace" :
         return 5;
      case "ring" :
         return 8;
      case "sash" :
         return 2;
      case "shirt" :
         return 2;
      case "belt scabbard" :
         return 2;
      case "small scabbard" :
         return 2;
      case "bandaid" :
         return 5;
      default :
         return 1;
   }
}
int query_number_wielded( string type ) { return 1; }
int query_skill_bonus( int number, string word ) { return 0; }
int player_start( object thing ) { return 1; }
int player_quit( object thing ) { return 1; }
void set_level( object thing, int level ) {
   int i;
   if ( !thing ) {
      return;
   }
   for ( i = sizeof( acs ) - 3; i > -1; i -= 3 ) {
      thing->add_ac( acs[ i ], acs[ i + 1 ], acs[ i + 2 ] );
   }
}
int *calc_attack( int *data, int number ) {
   int base;
   int num;
   int rand;
   int rating;
   int scale;
   base =  data[ 0 ] * ( BASE + SCALE * number );
   num = data[ 1 ];
   rand = data[ 2 ] * ( BASE + SCALE * number );
   rating = QUEST_AVE * ( base + num * rand ) +
         QUEST_MAX * ( base + ( num * ( 1 + rand ) ) / 2 );
   scale = BASE + SCALE * NORM;
   rating /= scale;
   rating = ( ( BASE + SCALE * EXPERT ) * rating + QUEST_AVE * QUEST_MAX ) /
         ( 2 * QUEST_AVE * QUEST_MAX );
   if ( rating > scale ) {
      scale = ( rating + scale ) / 2;
   }
   return ({ base / scale, num, rand / scale });
}
void set_unarmed_attacks( object thing ) {
   int i, number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   for ( i = sizeof( attacks ) - 3; i > -1; i -= 3 ) {
      thing->remove_attack( attacks[ i ] );
      thing->add_attack( attacks[ i ], attacks[ i + 1 ],
            calc_attack( attacks[ i + 2 ], number ), A_TYPES[ attacks[ i ] ],
            "unarmed", "unarmed_"+ attacks[ i ] );
   }
}
int query_eat( string bit ) {
  if (member_array( bit, inedible) == -1) {
    return 1;
  }
  return 0;
}
int query_unrottable( string bit ) {
  if (member_array( bit, unrottable) == -1) {
    return 0;
  }
  return 1;
}
int query_pluckable( string bit ) {
  if (member_array( bit, pluckable) == -1) {
    return 0;
  }
  return 1;
}
string *query_all_inedible() {
   return inedible;
}
string *query_all_unrottable() {
   return unrottable;
}
string *query_all_pluckable() {
   return pluckable;
}
string *query_target_zones() {
  return ({ "head", "head", "neck",
              "chest", "back", "back", "back", "lower back",
              "left front leg", "left front leg",
              "stomach", "stomach",
              "right front leg", "right front leg",
              "left rear leg", "left rear leg",
              "right rear leg", "right rear leg",});
}
string map_target_zone(string zone) {
  switch(zone) {
  case "abdomen":
    return "stomach";
  case "hands":
  case "arms":
    return (random(2) ? "left " : "right ") + "front leg";
  case "feet":
  case "legs":
    return (random(2) ? "left " : "right ") + "rear leg";
  default:
    return zone;
  }
}
string map_armour_zone(string zone) {
  switch(zone) {
  case "thorax":
  case "body":
  case "breast":
  case "trunk":
    return "chest";
  case "tail":
    return "back";
  case "stomach":
    return "abdomen";
  case "left arm":
  case "right arm":
  case "left front leg":
  case "right front leg":
  case "left petral fin":
  case "right petral fin":
  case "left wing":
  case "right wing":
  case "branches":
    return "arms";
  case "left hand":
  case "right hand":
  case "left middle leg":
  case "right middle leg":
  case "left front paw":
  case "right front paw":
    return "hands";
  case "left leg":
  case "right leg":
  case "left back leg":
  case "right back leg":
  case "left rear leg":
  case "right rear leg":
  case "dorsal fin":
    return "legs";
  case "left foot":
  case "right foot":
  case "left rear paw":
  case "left rear paw":
  case "left rear foot":
  case "left rear foot":
  case "left claw":
  case "right claw":
  case "root":
    return "feet";
  default:
    return zone;
  }
}

==================================================
FILE: races/bat.c
==================================================

inherit "/std/races/rodent_base";
void setup() {
   set_name( "bat" );
   set_long( "This is a small flying rodent." );
   set_desc( "a small, flying rodent" );
   set_height( 20 );
   set_weight( 40 );
   remove_bit( "torso" );
   remove_bit( "left front leg" );
   remove_bit( "right front leg" );
   remove_bit( "left rear leg" );
   remove_bit( "right rear leg" );
   add_bit( "torso", "torso", ({ 0, 20, 0,
      "heart", "liver", "left kidney", "right kidney", "spleen",
      "right lung", "left lung", "right wing", "left wing" }) );
   add_bit( "right wing", "wing", ({ "torso", 20, 0 }) );
   add_bit( "left wing", "wing", ({ "torso", 20, 0 }) );
   add_bit( "left leg", "leg", ({ 0, 5, 0 }) );
   add_bit( "right leg", "leg", ({ 0, 5, 0 }) );
   set_sight( ({ -20, 0, 80, 120 }) );
   set_stats( ({ 0, 14, -4, -4, -6 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number ) / 4;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->remove_attack( "claws" );
   thing->add_attack( "bite", 75, ({ 0, 3, number }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 50, ({ 0, 5, number / 2 }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/bear.c
==================================================

inherit "/std/races/carnivore";
void setup() {
   set_name( "bear" );
   set_desc( "a furry bear" );
   set_height( 200 );
   set_weight( 8000 );
   set_stats( ({ 6, 4, -2, 8, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 2 + ( 2 * level + random( level ) ) / 8;
   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );
   thing->add_attack( "claws", 100, ({ 2 * number, 10, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 50, ({ 3 * number, 8, number }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude offensive" );
}

==================================================
FILE: races/beetle.c
==================================================

inherit "/std/races/insect_base";
void setup() {
   set_name( "beetle" );
   set_desc( "a hard-carapaced insect that scuttles along the ground" );
   set_height( 5 );
   set_weight( 2 );
   add_bit( "left wing cover", "cover", ({ "thorax", 1, 0 }) );
   add_bit( "right wing cover", "cover", ({ "thorax", 1, 0 }) );
   inedible += ({ "left wing cover", "right wing cover" });
   set_stats( ({ -6, 4, -6, -6, -6 }) );
}
void start_player( object thing ) {
   ::start_player( thing );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude defensive" );
}

==================================================
FILE: races/bird.c
==================================================

inherit "/std/races/bird_base";
void setup() {
   set_name( "bird" );
   set_long( "A general, unspecified bird.\n" );
   set_height( 15 );
   set_weight( 60 );
   set_stats( ({ 0, 14, -4, -4, -6 }) );
}
void new_set_level( mixed *args ) {
   int weight;
   object thing;
   thing = args[ 1 ];
   if ( !thing )
     return;
   weight = (thing->query_weight() / 20);
   thing->add_ac( "blunt", "blunt", weight / 2 );
   thing->add_ac( "pierce", "pierce", weight );
   thing->add_ac( "sharp", "sharp", weight );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number / 4 ) + ( thing->query_weight() / 20 );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "beak" );
   thing->remove_attack( "claws" );
   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 75, ({ number, 5, number / 2 }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/bird_base.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "a general, unspecified bird.  This should not be used since "
      "it is a base race" );
   bits = ({
      "head", 0, ({ 0, 150, 0,
         "left eye", "right eye", "beak", "skull" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({"head", 1, 0 }),
      "beak", 0, ({ "head", 20, 0 }),
      "skull", "cranium", ({ "head", 30, 0, "brain" }),
      "brain", 0, ({ "skull", 10, 0 }),
      "neck", 0, ({ 0, 25, 0, "gizzard" }),
      "gizzard", "gullet", ({ "neck", 5, 0 }),
      "torso", "body", ({ 0, 500, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "intestine", "pancreas", "wishbone",
         "body feather" }),
      "heart", 0, ({ "torso", 50, 0 }),
      "liver", 0, ({ "torso", 25, 0 }),
      "left kidney", "kidney", ({ "torso", 15, 0 }),
      "right kidney", "kidney", ({ "torso", 15, 0 }),
      "left lung", "lung", ({ "torso", 25, 0 }),
      "right lung", "lung", ({ "torso", 25, 0 }),
      "spleen", 0, ({ "torso", 15, 0 }),
      "intestine", "gut", ({ "torso", 50, 0 }),
      "pancreas", 0, ({ "torso", 15, 0 }),
      "wishbone", 0, ({ "torso", 5, 0 }),
      "body feather", "feather", ({ "torso", 1, ({"/std/bit", 6}) }),
      "tail", 0, ({ 0, 50, 0, "tail feather" }),
      "tail feather", "feather", ({ "tail", 1, ({"/std/bit", 4}) }),
      "left wing", "wing", ({ 0, 150, 0,
         "left wing feather" }),
      "left wing feather", "feather", ({ "left wing", 1,
         ({"/std/bit", 5}) }),
      "right wing", "wing", ({ 0, 150, 0,
         "right wing feather" }),
      "right wing feather", "feather", ({ "right wing", 1,
         ({"/std/bit", 5}) }),
      "left leg", "leg", ({ 0, 100, 0, "left claw" }),
      "left claw", "claw", ({ "left leg", 25, 0 }),
      "right leg", "leg", ({ 0, 100, 0, "right claw" }),
      "right claw", "claw", ({ "right leg", 25, 0 })
   });
   inedible = ({ "beak", "skull", "body feather", "left wing feather",
      "right wing feather", "tail feather", "left claw", "right claw",
      "wishbone" });
   unrottable = ({ "beak", "skull", "body feather", "left wing feather",
      "right wing feather", "tail feather", "left claw", "right claw",
      "wishbone" });
   pluckable = ({ "body feather", "left wing feather", "right wing feather",
      "tail feather" });
   set_skin( "feathers" );
   if( !do_setup )
      this_object()->setup();
}
string *query_target_zones() {
  return ({ "head", "head", "neck",
              "breast", "breast", "breast", "breast", "back",
              "left wing", "left wing", "left wing", "left wing",
              "right wing", "right wing", "right wing", "right wing",
              "stomach", "stomach", "stomach",
              "left leg", "left leg", "left claw",
              "right leg", "right leg", "right claw" });
}
string map_target_zone(string zone) {
  switch(zone) {
  case "chest":
    return "breast";
  case "abdomen":
    return "stomach";
  case "hands":
  case "arms":
    return (random(2) ? "left " : "right ") + "wing";
  case "feet":
    return (random(2) ? "left " : "right ") + "claw";
  default:
    return zone;
  }
}

==================================================
FILE: races/bufonid.c
==================================================

inherit "/std/races/humanoid";
void setup() {
   set_name( "bufonid" );
   set_long( "The bufonids are rare species of humanoid toad-like beings.  "
      "It is rumoured that they were created by wizards as part of a "
      "heinous series of experiments of unknown intent and subsequently "
      "escaped from their creators.  Little is known of them, except that "
      "they keep themselves well hidden from humans.\n" );
   set_height( 150 );
   set_weight( 1800 );
   set_desc( "a strange creature, with webbed feet and warty green skin, "
      "that gives you the impression of being a humanoid toad" );
   remove_bit( "left ear" );
   remove_bit( "right ear" );
   remove_bit( "nose" );
   remove_bit( "scalp" );
   remove_bit( "teeth" );
   add_ac( "blunt", "blunt", 15 );
   add_ac( "pierce", "pierce", 12 );
   add_ac( "sharp", "sharp", 10 );
   add_attack( "hands", 75, ({ 40, 5, 10 }) );
   add_attack( "feet", 25, ({ 30, 5, 20 }) );
   set_stats( ({ 2, 2, 0, 2, 0 }) );
}

==================================================
FILE: races/cabbage.c
==================================================

inherit "/std/races/base";
void setup() {
   set_name( "cabbage" );
   set_long("A green, leafy vegetable.  Probably full of vitamins and "+
      "minerals, and plenty of roughage.\n" );
   set_height( 20 );
   set_weight( 40 );
   set_desc( "a cute little green-fronded cabbage.  Awww" );
   set_skin( "fronds" );
   bits = ({
      "frond", "frond", ({ 0, 100, ({"/std/bit", 10}) }),
      "stalk", "stalk", ({ 0, 500, 0 })
   });
   inedible = ({ });
   unrottable = ({ });
   set_stats( ({ -4, -4, -6, -4, -6 }) );
}
void player_heart_beat( string word, object brassica ) {
   object *caterpillars;
   if( !environment( brassica ) ) {
      return;
   }
   caterpillars = match_objects_for_existence( "caterpillar",
      environment( brassica ) );
   if( !sizeof( caterpillars ) ) {
      return;
   }
   if( brassica->caterpillars_here( caterpillars ) ) {
      return;
   }
   brassica->do_command( "gibber" );
   brassica->run_away();
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "fronds" );
   thing->add_attack( "fronds", 160, ({ 4 * number, 5, 3 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack_message( "fronds", "sharp", ({
      50, "$N scratch$es $P $z with a frond.\n",
      100, "$N jab$s a sharp frond into $P $z.\n",
      140, "$N chew$s on $P $z.\n",
      180, "$N slash$es $P $z with $p fronds.\n",
      230, "$N climb$s onto %I and cuts $P $z with a sharp frond.\n",
      0, "$N bite$s $P $z off!\n" }) );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude offensive" );
}

==================================================
FILE: races/camel.c
==================================================

inherit "/std/races/ruminant";
void setup() {
   set_name( "camel" );
   set_long( "The camel is an animal living in desert regions.  It has two "
      "humps, a mean temper and a good eye for numbers.  They are usually "
      "named things like \"You Bastard\", \"Evil-smelling Bugger\" and so "
      "on, something that might seem strange to anyone who hasn't "
      "actually met one of the beasts.\n" );
   set_height( 170 );
   set_weight( 12000 );
   set_desc( "a camel that looks less interested in you than in sand" );
   add_bit( "tail", "tail", ({ 0, 18, 0 }) );
   add_bit( "fore hump", "hump", ({ 0, 75, 0 }) );
   add_bit( "aft hump", "hump", ({ 0, 50, 0 }) );
   inedible += ({ "tail" });
   add_ac( "blunt", "blunt", 50 );
   add_ac( "pierce", "pierce", 20 );
   add_ac( "sharp", "sharp", 20 );
   add_attack( "bite", 50, ({ 40, 8, 10 }) );
   add_attack( "feet", 50, ({ 60, 10, 40 }) );
   set_stats( ({ 4, 2, 10, 6, 8 }) );
}
void start_player( object thing ) {
   ::start_player( thing );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/carnivore.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_weight( 700 );
   set_height( 50 );
   set_desc( "your standard carnivore.  This should not be used as it is a "
      "base race" );
   bits = ({
      "head", "head", ({ 0, 40, 0,
         "left eye", "right eye", "nose", "skull", "left ear", "right ear",
         "tongue" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "skull", "cranium", ({ "head", 20, 0, "brain", "teeth" }),
      "brain", "brain", ({ "skull", 20, 0 }),
      "left ear", "ear", ({"head", 1, 0 }),
      "right ear", "ear", ({"head", 1, 0 }),
      "nose", "nose", ({ "head", 3, 0 }),
      "teeth", "teeth", ({ "skull", 3, ({"/std/bit_set", 1}), "tooth" }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 48}) }),
      "tongue", "tongue", ({ "head", 2, 0 }),
      "neck", "neck", ({ 0, 15, 0 }),
      "torso", "body", ({ 0, 350, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "intestine", "pancreas" }),
      "heart", "heart", ({ "torso", 10, 0 }),
      "liver", "liver", ({ "torso", 5, 0 }),
      "left kidney", "kidney", ({ "torso", 5, 0 }),
      "right kidney", "kidney", ({ "torso", 5, 0 }),
      "left lung", "lung", ({ "torso", 10, 0 }),
      "right lung", "lung", ({ "torso", 10, 0 }),
      "spleen", "spleen", ({ "torso", 5, 0 }),
      "intestine", "gut", ({ "torso", 15, 0 }),
      "pancreas", "pancreas", ({ "torso", 5, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "left front leg", "leg", ({ 0, 130, 0, "left front paw" }),
      "left front paw", "paw", ({ "left front leg", 30, 0, "claw" }),
      "claw", "claw", ({ "left front paw", 1, ({"/std/bit", 4}) }),
      "right front leg", "leg", ({ 0, 130, 0, "right front paw" }),
      "right front paw", "paw", ({ "right front leg", 30, 0, "claw" }),
      "claw", "claw", ({ "right front paw", 1, ({"/std/bit", 4}) }),
      "left rear leg", "leg", ({ 0, 275, 0, "left rear paw" }),
      "left rear paw", "paw", ({ "left rear leg", 30, 0, "claw" }),
      "claw", "claw", ({ "left rear paw", 1, ({"/std/bit", 4}) }),
      "right rear leg", "leg", ({ 0, 275, 0, "right rear paw" }),
      "right rear paw", "paw", ({ "right rear leg", 30, 0, "claw" }),
      "claw", "claw", ({ "right rear paw", 1, ({"/std/bit", 4}) }),
      "tail", "tail", ({ 0, 18, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   inedible = ({ "skull", "claw", "tail", "teeth", "tooth", "skin" });
   unrottable = ({ "skull", "claw", "teeth", "tooth" });
   set_skin( "pelt" );
   set_stats( ({ 6, 10, -2, 6, -4 }) );
   if( !do_setup )
      this_object()->setup();
}
string *query_target_zones() {
  return ({ "head", "head", "neck",
              "chest", "back", "back", "back", "lower back",
              "left front leg", "left front leg", "left front paw",
              "stomach", "stomach", "tail",
              "right front leg", "right front leg", "right front paw",
              "left rear leg", "left rear leg", "left rear paw",
              "right rear leg", "right rear leg", "right rear paw"});
}
string map_target_zone(string zone) {
  switch(zone) {
  case "chest":
    return random(4) ? "back" : "chest";
  case "abdomen":
    return random(4) ? "stomach" : "lower back";
  case "arms":
    return (random(2) ? "left " : "right ") + "front leg";
  case "hands":
    return (random(2) ? "left " : "right ") + "front paw";
  case "legs":
    return (random(2) ? "left " : "right ") + "rear leg";
  case "feet":
    return (random(2) ? "left " :"right ") + "rear paw";
  default:
    return zone;
  }
}

==================================================
FILE: races/cat.c
==================================================

inherit "/std/races/carnivore";
void setup() {
   set_name( "cat" );
   set_long( "A carnivorous mammal (Felis catus) long domesticated and kept "+
         "by man as a pet or for catching rats and mice.\n" );
   set_height( 20 );
   set_weight( 100 );
   set_desc( "a furry cat, on the hunt for a mouse to play with" );
   set_stats( ({ 0, 10, 2, -2, 2 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 1 + ( 2 * level + random( level ) ) / 10;
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->remove_attack( "claws" );
   thing->add_attack( "bite", 100, ({ number, 5, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "claws", 150, ({ number / 2, 7, number }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/caterpillar.c
==================================================

inherit "/std/races/insect_base";
void setup() {
   set_name( "caterpillar" );
   set_long( "The elongated wormlike larva of a butterfly or moth.\n" );
   set_height( 5 );
   set_weight( 2 );
   set_desc( "a caterpillar, crawling along the ground" );
   set_stats( ({ -6, -6, -6, -6, -6 }) );
}
void player_heart_beat( string word, object eater ) {
   int i, time;
   object flowers, *things;
   if( !environment( eater ) ) return;
   if( eater->query_property( "eating" ) ) return;
   things = all_inventory( environment( eater ) ) - ({ eater });
   if( !sizeof( things ) ) return;
   for( i = 0; i < sizeof( things ); i++ ) {
      if( !(int)things[ i ]->id( "flowers" ) ) {
         things -= ({ things[ i ] });
         i--;
      } else {
         if( things[ i ]->query_property( "being eaten" ) ) {
            things -= ({ things[ i ] });
            i--;
         }
      }
   }
   if( !sizeof( things ) ) return;
   flowers = things[ random( sizeof( things ) ) ];
   tell_room( environment( eater ), "The " + (string)eater->query_short() +
      " discovers the " + (string)flowers->query_short() + " and starts to "
      + "munch.\n" );
   eater->add_property( "eating", 1 );
   flowers->add_property( "being eaten", 1 );
   time = (int)flowers->query_weight();
   time += random( time );
   call_out( "done_eating", time, eater, flowers );
}
void done_eating( object eater, object flowers ) {
   if( !eater ) return;
   eater->remove_property( "eating" );
   if( !environment( eater ) ) return;
   if( !flowers ) return;
   if( member_array( flowers, all_inventory( environment( eater ) ) ) == -1 )
      return;
   tell_room( environment( eater ), "The " + (string)eater->query_short() +
      " finishes the " + (string)flowers->query_short() + " and burps " +
      "contentedly.\n" );
   flowers->dest_me();
}

==================================================
FILE: races/chicken.c
==================================================

inherit "/std/races/bird_base";
void setup() {
   set_name( "chicken" );
   set_long( "Chickens.  That's all there is to say.  Chickens, chickens, "
      "chickens, chickens, chickens.  Thank you.\n" );
   set_weight( 80 );
   set_height( 30 );
   set_desc( "an ordinary brain-dead chicken" );
   add_ac( "feather_blow", "blunt", 10 );
   add_ac( "feather_slash", "sharp", 2 );
   add_ac( "feather_pierce", "pierce", 2 );
   set_stats( ({ 0, 8, -6, -4, -6 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number / 4 ) + ( thing->query_weight() / 20 );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "beak" );
   thing->remove_attack( "claws" );
   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 75, ({ number, 5, number / 2 }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/cockroach.c
==================================================

inherit "/std/races/insect_base";
void setup() {
   set_desc( "a nasty cockroach, ugh" );
   set_name( "cockroach" );
   set_height( 5 );
   set_weight( 2 );
   add_ac( "blunt", "blunt", 40 );
   add_ac( "sharp", "sharp", 20 );
   add_ac( "pierce", "pierce", 10 );
   set_stats( ({ -6, 4, -4, -6, -6 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );
   thing->add_attack( "claws", 100, ({ ( 3 * number ) / 2, 5, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 50, ({3 * number, 2, number }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude defensive" );
}

==================================================
FILE: races/cow.c
==================================================

inherit "/std/races/ruminant";
void setup() {
   mixed *new_head;
   set_name( "cow" );
   set_long( "A large hoofed mammal.  Surprise.\n" );
   set_height( 175 );
   set_weight( 16000 );
   set_desc( "a large, hairy quadruped reminding you very much of a cow" );
   new_head = query_bit( "head" );
   new_head[ 2 ] += ({ "left horn", "right horn" });
   remove_bit( "head" );
   add_bit( "head", "head", new_head[ 2 ] );
   add_bit( "left horn", "horn", ({ "head", 10, 0 }) );
   add_bit( "right horn", "horn", ({ "head", 10, 0 }) );
   add_bit( "udders", "udders", ({ 0, 60, 0 }) );
   add_bit( "tail", "tail", ({ 0, 15, 0 }) );
   inedible += ({ "left horn", "right horn", "tail" });
   unrottable += ({ "left horn", "right horn" });
   add_ac( "blunt", "blunt", 50 );
   add_ac( "pierce", "pierce", 20 );
   add_ac( "sharp", "sharp", 20 );
   add_attack( "bite", 20, ({ 40, 8, 10 }) );
   add_attack( "feet", 50, ({ 60, 10, 40 }) );
   set_stats( ({ 4, -2, -4, 6, -6 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "horns" );
   thing->remove_attack( "hoof" );
   if( number < 10 )
      number = 10;
   thing->add_attack( "horns", 40, ({ 60, 10, 40 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "hoof", 60, ({ 40, 8, 10 }),
      "blunt", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/crab.c
==================================================

inherit "/std/races/base";
void setup() {
    set_name( "crab" );
    set_long( "A scuttling crab.\n" );
    set_height( 10 );
    set_weight( 18 );
    set_desc( "a scuttling crab" );
    bits = ({
        "head", "head", ({ 0, 200, 0,
            "left antenna", "right antenna", "left antennule", "right "
            "antennule", "brain", "left eye", "right eye", "left eyestalk",
            "right eyestalk", "jaw", "skull" }),
        "left antenna", "antenna", ({ "head", 2, 0 }),
        "right antenna", "antenna", ({ "head", 2, 0 }),
        "left antennule", "antennule", ({ "head", 1, 0 }),
        "right antennule", "antennule", ({ "head", 1, 0 }),
        "brain", "brain", ({ "head", 50, 0 }),
        "skull", "skull", ({ "head", 50, 0 }),
        "left eye", "eye", ({ "head", 5, 0 }),
        "right eye", "eye", ({ "head", 5, 0 }),
        "left eyestalk", "eyestalk", ({ "head", 2, 0 }),
        "right eyestalk", "eyestalk", ({ "head", 2, 0 }),
        "jaw", "mouth", ({ "head", 25, 0 }),
        "carapace", "carapace", ({ 0, 25, 0 }),
        "thorax", "thorax", ({ 0, 500, 0,
            "left cheliped", "right cheliped", "left second leg",
            "right second leg", "left third leg", "right third leg", "left "
            "fourth leg", "right fourth leg", "left back leg", "right back "
            "leg", "heart", "hepatopancreas", "intestine", "stomach" }),
        "left cheliped", "cheliped", ({ "thorax", 75, 0 }),
        "right cheliped", "cheliped", ({ "thorax", 75, 0 }),
        "left second leg", "leg", ({ "thorax", 50, 0 }),
        "right second leg", "leg", ({ "thorax", 50, 0 }),
        "left third leg", "leg", ({ "thorax", 50, 0 }),
        "right third leg", "leg", ({ "thorax", 50, 0 }),
        "left fourth leg", "leg", ({ "thorax", 50, 0 }),
        "right fourth leg", "leg", ({ "thorax", 50, 0 }),
        "left back leg", "leg", ({ "thorax", 50, 0 }),
        "right back leg", "leg", ({ "thorax", 50, 0 }),
        "heart", "heart", ({ "thorax", 50, 0 }),
        "hepatopancreas", "hepatopancreas", ({ "thorax", 10, 0 }),
        "intestine", "intestine", ({ "thorax", 30, 0 }),
        "stomach", "stomach", ({ "thorax", 30, 0 }),
        "apron", "apron", ({ 0, 100, 0, "left pleopod", "right pleopod" }),
        "left pleopod", "pleopod", ({ "apron", 20, 0 }),
        "right pleopod", "pleopod", ({ "apron", 20, 0 })
    });
    inedible = ({ "jaw", "carapace", "skull" });
    unrottable = ({ "jaw", "carapace", "skull" });
    set_skin( "shell" );
    set_stats( ({ -6, 4, -6, -4, -6 }) );
}
int query_eat( string type ) {
   return ( member_array( type, inedible ) == -1 );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_skill_level( "other.health", level * 2 );
   thing->add_ac( "blunt", "blunt", level / 2 );
   thing->add_ac( "pierce", "pierce", level / 4 );
   thing->add_ac( "sharp", "sharp", level / 3 );
}
void set_unarmed_attacks( object thing ) {
    int number;
    number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
    number = 4 + sqrt( number );
    thing->remove_attack( "hands" );
    thing->remove_attack( "feet" );
    thing->remove_attack( "pincers" );
    thing->add_attack( "pincers", 100, ({ number, 10, number }),
        "unarmed", "unarmed", 0 );
    thing->add_attack_message( "pincers", "unarmed", ({
       20, "$N bat$s $I with $p pincer",
       60, "$N nip$s $P $z with $p pincer",
       100, "$N scratch$es $I deeply with $p pincer",
       140, "$N cut$s $P $z deeply with $p pincer",
       180, "$N dig$s $p pincer into $P $z",
       220, "$N gouge$s $I with $p pincer",
       0, "$N slice$s $P $z up with $p pincer" }) );
   thing->tactics( "response dodge" );
}
int lives_in_water() { return 1; }

==================================================
FILE: races/crocodile.c
==================================================

inherit "/std/races/reptile_base";
void setup() {
   set_name( "crocodile" );
   set_long( "Any of several large voracious thick-skinned long-bodied "
      "aquatic reptiles (as of the genus Crocodylus) of tropical and "
      "subtropical waters.\n" );
   set_height( 30 );
   set_weight( 5000 );
   set_desc( "a crocodile, sharp of tooth and vicious of temper." );
   add_ac( "blunt", "blunt", 80 );
   add_ac( "pierce", "pierce", 80 );
   add_ac( "sharp", "sharp", 80 );
   set_stats( ({ 6, 4, -4, 8, -4 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "chew" );
   thing->remove_attack( "tail" );
   thing->add_attack( "chew", 75, ({ 3 * number, number, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "tail", 75, ({ number, number, number }),
      "blunt", "unarmed", 0 );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude offensive" );
}

==================================================
FILE: races/deer.c
==================================================

inherit "/std/races/base";
void setup() {
   set_name( "deer" );
   set_long( "A medium-sized hoofed mammal.  Surprise.\n" );
   set_height( 250 );
   set_weight( 4000 );
   bits= ({
      "head", "head", ({ 0, 120, 0,
         "left eye", "right eye", "skull", "brain", "left ear",
         "right ear", "tongue" }),
      "left antler", "antler", ({ "head", 30, 0 }),
      "right antler", "antler", ({ "head", 30, 0 }),
      "left eye", "eye", ({ "head", 2, 0 }),
      "right eye", "eye", ({ "head", 2, 0 }),
      "skull", "cranium", ({ "head", 45, 0, "teeth" }),
      "brain", "brain", ({ "head", 20, 0 }),
      "left ear", "ear", ({"head", 4, 0 }),
      "right ear", "ear", ({"head", 4, 0 }),
      "teeth", "teeth", ({ "skull", 5, ({"/std/bit_set", 1}) }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 18}) }),
      "tongue", "tongue", ({ "head", 9, 0 }),
      "neck", "neck", ({ 0, 120, 0 }),
      "torso", "body", ({ 0, 400, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "intestine", "pancreas" }),
      "heart", "heart", ({ "torso", 35, 0 }),
      "liver", "liver", ({ "torso", 35, 0 }),
      "left kidney", "kidney", ({ "torso", 20, 0 }),
      "right kidney", "kidney", ({ "torso", 20, 0 }),
      "left lung", "lung", ({ "torso", 35, 0 }),
      "right lung", "lung", ({ "torso", 35, 0 }),
      "spleen", "spleen", ({ "torso", 20, 0 }),
      "intestine", "gut", ({ "torso", 75, 0 }),
      "pancreas", "pancreas", ({ "torso", 20, 0 }),
      "left front leg", "leg", ({ 0, 140, 0, "left front hoof" }),
      "left front hoof", "hoof", ({ "left front leg", 20, 0 }),
      "right front leg", "leg", ({ 0, 140, 0, "right front hoof" }),
      "right front hoof", "hoof", ({ "right front leg", 20, 0 }),
      "left rear leg", "leg", ({ 0, 160, 0, "left rear hoof" }),
      "left rear hoof", "hoof", ({ "left rear leg", 20, 0 }),
      "right rear leg", "leg", ({ 0, 160, 0, "right rear hoof" }),
      "right rear hoof", "hoof", ({ "right rear leg", 20, 0 }),
      "tail", "tail", ({ 0, 15, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   inedible = ({ "skull", "left front hoof", "right front hoof", "left antler", "right antler",
      "left rear hoof", "right rear hoof", "tail", "teeth", "tooth" });
   unrottable = ({ "skull", "left front hoof", "right front hoof", "left antler", "right antler",
      "left rear hoof", "right rear hoof", "teeth", "tooth" });
   set_desc( "a medium-sized, hairy quadruped.  It looks like a deer" );
   add_ac( "blunt", "blunt", 50 );
   add_ac( "sharp", "sharp", 20 );
   add_ac( "pierce", "pierce", 20 );
   set_skin( "skin" );
   set_stats( ({ 4, 4, -2, 6, -2 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "antlers" );
   thing->remove_attack( "hoof" );
   thing->add_attack( "antlers", 40, ({ number, 2, number }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "hoof", 60, ({ number / 2, 5, number }),
      "blunt", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/demon.c
==================================================

inherit "/std/races/demonic";
void setup() {
   set_long( "This is one of the denizens of the Underworld.\n" );
   set_name( "demon" );
   set_height( 250 );
   set_weight( 5000 );
   set_desc( "a nasty-looking demon" );
   add_ac( "fire", "fire", 100 );
   set_stats( ({ 10, 0, -2, 10, 4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_skill_level( "other.health", level * 2 );
   thing->add_ac( "blunt", "blunt", level / 2 );
   thing->add_ac( "pierce", "pierce", level / 4 );
   thing->add_ac( "sharp", "sharp", level / 3 );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );
   thing->add_attack( "claws", 75, ({ 2 * number, 8, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 25, ({ 3 * number, 10, number }),
      "pierce", "unarmed", 0 );
}

==================================================
FILE: races/dog.c
==================================================

inherit "/std/races/carnivore";
void setup() {
   set_name( "dog" );
   set_long( "A street dog. I wouldn't stay too near, it could bite.\n" );
   set_desc( "a nasty dog" );
   set_height( 50 );
   set_weight( 700 );
   set_stats( ({ 4, 10, -2, 6, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_ac( "blunt", "blunt", 40 );
   thing->add_ac( "sharp", "sharp", 20 );
   thing->add_ac( "pierce", "pierce", 10 );
   thing->add_skill_level( "other.perception", 200 );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );
   thing->add_attack( "claws", 100, ({ ( 3 * number ) / 2, 5, number } ),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 50, ({ 3 * number, 2, number }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/duck.c
==================================================

inherit "/std/races/bird_base";
void setup() {
   set_name( "duck" );
   set_long( "Ducks.  That's all there is to say.  Ducks, ducks, ducks, "
      "ducks, ducks.  Thank you.\n" );
   set_weight( 80 );
   set_height( 30 );
   set_desc( "an ordinary brain-dead duck" );
   add_ac( "feather_blow", "blunt", 10 );
   add_ac( "feather_slash", "sharp", 2 );
   add_ac( "feather_pierce", "pierce", 2 );
   set_stats( ({ 0, 14, -6, -4, -6 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number / 4 ) + ( thing->query_weight() / 20 );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "beak" );
   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "feet", 75, ({ number, 5, number / 2 }),
      "blunt", "unarmed", 0 );
   thing->tactics( "response dodge" );
}
int lives_in_water() { return 1; }

==================================================
FILE: races/duckling.c
==================================================

inherit "/std/races/bird_base";
void setup() {
   set_name( "duckling" );
   set_long( "Awwwwwwww it's SUCH a cute little duckling!\n" );
   set_weight( 10 );
   set_height( 15 );
   set_desc( "an cute ickle duckling" );
   add_ac( "feather_blow", "blunt", 10 );
   add_ac( "feather_slash", "sharp", 2 );
   add_ac( "feather_pierce", "pierce", 2 );
   set_stats( ({ 0, 14, -6, -4, -6 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number / 4 ) + ( thing->query_weight() / 20 );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "beak" );
   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "feet", 75, ({ number, 5, number / 2 }),
      "blunt", "unarmed", 0 );
   thing->tactics( "response dodge" );
}
int lives_in_water() { return 1; }

==================================================
FILE: races/elephant.c
==================================================

inherit "/std/races/ruminant";
void setup() {
   set_name( "elephant" );
   set_long( "This is an elephant.  A large creature with a thick grey "
      "hide.  He seems to weigh a lot so don't let him step on your "
      "toe.\n" );
   set_height( 280 );
   set_weight( 100000 );
   set_desc( "an elephant that looks back at you with small nice eyes" );
   remove_bit( "nose" );
   remove_bit( "head" );
   add_bit( "head", "head", ({ 0, 135, 0,
      "left eye", "right eye", "skull", "tongue", "left ear", "right ear",
      "right tusk" "left tusk", "trunk" }) );
   add_bit( "right tusk", "tusk", ({ "head", 20, ({ "/std/bit", 2 }) }) );
   add_bit( "left tusk", "tusk", ({ "head", 20, ({ "/std/bit", 2 }) }) );
   add_bit( "trunk", "trunk", ({ "head", 30, 0 }) );
   remove_bit( "left front leg" );
   remove_bit( "right front leg" );
   remove_bit( "left rear leg" );
   remove_bit( "right rear leg" );
   remove_bit( "left front hoof" );
   remove_bit( "right front hoof" );
   remove_bit( "left rear hoof" );
   remove_bit( "right rear hoof" );
   add_bit( "left front leg", "leg", ({ 0, 150, 0, "left front foot" }) );
   add_bit( "right front leg", "leg", ({ 0, 150, 0, "right front foot" }) );
   add_bit( "left rear leg", "leg", ({ 0, 150, 0, "left rear leg" }) );
   add_bit( "right rear leg", "leg", ({ 0, 150, 0, "right rear leg" }) );
   add_bit( "left front foot", "foot", ({ "left front leg", 30, 0 }) );
   add_bit( "right front foot", "foot", ({ "right front leg", 30, 0 }) );
   add_bit( "left rear foot", "foot", ({ "left rear leg", 30, 0 }) );
   add_bit( "right rear foot", "foot", ({ "right rear leg", 30, 0 }) );
   add_bit( "tail", "tail", ({ 0, 15, 0 }) );
   inedible += ({ "tail", "right tusk", "left tusk" });
   unrottable += ({ "left tusk", "right tusk" });
   add_ac( "blunt", "blunt", ({ 40, 20}) );
   add_ac( "pierce", "pierce", ({ 30, 20 }) );
   add_ac( "sharp", "sharp", ({ 50, 20 }) );
   add_ac( "acid", "acid", 20 );
   add_ac( "fire", "fire", 20 );
   set_stats( ({ 30, -6, -4, 16, -2 }) );
}
void set_unarmed_attacks( object thing ) {
   thing->remove_attack( "hands" );
   thing->remove_attack( "tusks" );
   thing->remove_attack( "crush" );
   thing->remove_attack( "ram" );
   thing->add_attack( "tusks", 25, ({200, 10, 30}), "pierce", "unarmed", 0 );
   thing->add_attack( "crush", 10, ({300, 10, 50}), "blunt", "unarmed", 0 );
   thing->add_attack_message( "crush", "unarmed", ({
     0, "$N stand$s on $p hind legs and attempt$s to crash down on $I",
      200, "$N stand$s on $p hind legs and crash$es down, striking $I "
       "a glancing blow",
      400, "$N stand$s on $p hind legs and crash$es down on $I, crushing "
            "$P $z",
      5000, "$N stand$s on $p hind legs and crash$es down on $I, crushing "
            "$P $z into a bloody mess" }) );
   thing->add_attack( "ram", 25, ({200, 10, 20}), "blunt", "unarmed", 0 );
   thing->add_attack_message( "ram", "unarmed", ({
     0, "$N charge$s at $I",
      200, "$N charge$s $I and strike$s $I",
      400, "$N charge$s $I and strike$s $P $z hard, making $I stagger "
            "around",
      5000, "$N charge$s $I and strike$s $I to the ground.  $I "
            "stumbles around a little groggily" }) );
   thing->add_attack( "trunk", 50, ({100, 5, 20}), "blunt", "unarmed", 0 );
   thing->add_attack_message( "trunk", "unarmed", ({
     0, "$N swing$s $p trunk at $I",
      200, "$N swing$s $p trunk at $I, hitting $P $z hard",
      400, "$N swing$s $p trunk, which thumps forcefully into $P $z",
      5000, "$N swing$s $p trunk at $I, nearly knocking $I down" }) );
}
string *query_target_zones() {
  return ({ "head", "head", "neck",
              "chest", "back", "back", "back", "lower back",
              "left front leg", "left front leg", "left front foot",
              "stomach", "stomach", "tail",
              "right front leg", "right front leg", "right front foot",
              "left rear leg", "left rear leg", "left rear foot",
              "right rear leg", "right rear leg", "right rear foot"});
}
string map_target_zone(string zone) {
  switch(zone) {
  case "chest":
    return random(4) ? "back" : "chest";
  case "abdomen":
    return random(4) ? "stomach" : "lower back";
  case "arms":
    return (random(2) ? "left " : "right ") + "front leg";
  case "hands":
    return (random(2) ? "left " : "right ") + "front foot";
  case "legs":
    return (random(2) ? "left " : "right ") + "rear leg";
  case "feet":
    return (random(2) ? "left " :"right ") + "rear foot";
  default:
    return zone;
  }
}

==================================================
FILE: races/ferret.c
==================================================

inherit "/std/races/mustelidae_base";
void setup() {
   set_name( "ferret" );
   set_long( "A small black white and grey animal.\n" );
   set_height( 15 );
   set_weight( 30 );
   set_desc( "small brown meateater" );
   set_stats( ({ -2, 8, -2, -4, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 1 + ( 2 * level + random( level ) ) / 8;
   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );
   thing->add_attack( "claws", 50, ({ ( 4 * number ) / 2, 8, 2 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 100, ({ 2 * number, 10, ( 3 * number ) / 2 }),
      "pierce", "unarmed", 0  );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/fish.c
==================================================

inherit "/std/races/fish_base";
void setup() {
   set_name( "fish" );
   set_long( "Fish,  yes.  A fish.  Nice generic standard fish thing.\n" );
   set_height( 15 );
   set_weight( 40 );
   set_desc( "a fish, the kind with fins" );
   set_stats( ({ -2, 14, -4, -4, -6 }) );
}
void check_water( object player ) {
   if( !environment( player )->query_water() )
      call_out( "do_drown", 4, player );
}
void do_drown( object player ) {
   int i;
   if( environment( player )->query_water() )
      return;
   tell_room( environment( player ) , player->one_short() + " gasps for "
      "air.\n" );
   i = player->query_max_hp() / 5;
   if( i < 20 ) i = 20;
   player->adjust_hp( -i );
   call_out( "do_drown", 4, player );
}
void start_player( object thing ) {
   ::start_player( thing );
   thing->add_property( "gills", 1 );
   thing->add_property("lives in water", 1);
   thing->add_enter_commands( (: check_water :) );
   thing->set_default_position( ({ "lying" }) );
   thing->return_to_default_position( 0 );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->add_attack( "bite", 100, ({ 2 * number, 5, number }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
}
int lives_in_water() { return 1; }

==================================================
FILE: races/fish_base.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "your standard fish.  This should not be used since it is a "
      "base race" );
   bits = ({
      "head", "head", ({ 0, 200, 0,
         "left eye", "right eye", "left gill", "right gill" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "left gill", "gill", ({ "head", 50, 0 }),
      "right gill", "gill", ({ "head", 50, 0 }),
      "torso", "guts", ({ 0, 800, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen" }),
      "heart", "heart", ({ "guts", 50, 0 }),
      "liver", "liver", ({ "guts", 50, 0 }),
      "left kidney", "kidney", ({ "guts", 25, 0 }),
      "right kidney", "kidney", ({ "guts", 25, 0 }),
      "spleen", "spleen", ({ "guts", 25, 0 }),
      "genitals", "genitals", ({ 0, 10, 0 }),
      "left petral fin", "fin", ({ 0, 100, 0, }),
      "right petral fin", "fin", ({ 0, 100, 0, }),
      "dorsal petral fin", "fin", ({ 0, 100, 0 }),
      "tail", "tail", ({ 0, 150, 0 })
   });
   inedible = ({ "left petral fin", "right petral fin", "dorsal petral fin",
      "tail" });
   unrottable = ({  });
   set_skin( "scales" );
   if( !do_setup )
      this_object()->setup();
}
string *query_target_zones() {
  return ({ "head", "head",
              "body","body", "body", "body", "body", "body",
              "left petral fin", "right petral fin",
              "dorsal fin", "body",
              "body", "body",
              "body", "body",
              "body", "body", "body", "body", "body"
              "body", "body",
              "tail", "tail" });
}
string map_target_zone(string zone) {
  switch(zone) {
  case "head":
    return zone;
  case "arms":
    return (random(2) ? "left " : "right ") + "petral fin";
  case "hands":
    return "dorsal fin";
  case "feet":
    return "tail";
  default:
    return "body";
  }
}
int lives_in_water() { return 1; }

==================================================
FILE: races/fox.c
==================================================

inherit "/std/races/carnivore";
void setup() {
   set_name( "fox" );
   set_long( "A cat-like creature with red fur, hunts small, "
             "animals like mice and rabbits.\n" );
   set_height( 30 );
   set_weight( 400 );
   set_desc( "A small red fox" );
   set_stats( ({ 0, 10, -2, 4, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 1 + ( 2 * level + random( level ) ) / 10;
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
}
void set_unarmed_attacks(object thing) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->remove_attack( "claws" );
   thing->add_attack( "bite", 100, ({ number / 2, 2, number }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 150, ({ number / 2, 2, number }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/frog.c
==================================================

inherit "/std/races/amphibian";
void setup() {
   set_name( "frog" );
   set_long( "Frogs are amphibians" );
   set_height(10);
   set_weight(10);
   set_desc( "an innocent little froggie" );
   add_ac( "blunt", "blunt", 5 );
   add_ac( "pierce", "pierce", 4 );
   add_ac( "sharp", "sharp", 3 );
   add_attack( "bite", 50, ({ 10, 2, 6 }) );
   set_sight( ({ 5, 20, 200, 300 }) );
   set_stats( ({ -4, 10, -4, -4, -6 }) );
}
void start_player( object thing ) {
   ::start_player( thing );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/gnome.c
==================================================

inherit "/std/races/humanoid";
void setup() {
   set_name( "gnome" );
   set_long( "This is the race for gnomes.\n" );
   set_desc( "a short-looking gnome" );
   set_weight( 25 );
   set_height( 20 );
   set_sight( ({ 0, 5, 150, 200 }) );
   set_stats( ({ -2, 8, 0, 6, 0 }) );
}

==================================================
FILE: races/goat.c
==================================================

inherit "/std/races/ruminant";
void setup() {
   set_name( "goat" );
   set_long( "A cloven-hoofed, horned mammal closely related to the "
      "sheep.\n" );
   set_desc( "a cloven-hoofed, horned mammal" );
   set_weight( 800 );
   set_height( 80 );
   remove_bit( "head" );
   add_bit( "head", "head", ({ 0, 135, 0,
      "left eye", "right eye", "nose", "skull", "tongue", "left ear",
      "right ear", "left horn", "right horn" }) );
   add_bit( "left horn", "horn", ({ "head", 5, 0 }) );
   add_bit( "right horn", "horn", ({ "head", 5, 0 }) );
   inedible += ({ "left horn", "right horn" });
   set_stats( ({ 4, 8, 0, 2, -4 }) );
}
void set_unarmed_attacks( object thing ) {
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "standard" );
   thing->remove_attack( "horns" );
   thing->remove_attack( "hoof" );
   thing->add_attack( "horns", 60, ({ 21, 8, 11 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "hoof", 60, ({ 32, 10, 11 }),
      "blunt", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/golem.c
==================================================

inherit "/std/races/humanoid";
#include <armoury.h>
void knock_out( object player, object golem );
void unarmed_hands( int damage, object him, object me, string a_type,
    string a_name );
object make_corpse();
void setup() {
    set_name( "golem" );
    set_long( "Golems are artifical shaped of clay to resemble humanoids and "
        "animated using religious rituals.  If they are actually alive is a "
        "question under constant debate.\n" );
    set_height( 200 );
    set_weight( 40000 );
    set_desc( "a tall, human-shaped creature made of clay" );
    add_property( "no scry", 1 );
    add_ac( "blunt", "pierce", ({150}) );
    add_ac( "pierce", "pierce", ({250}) );
    add_ac( "sharp", "sharp", ({250}) );
    add_ac( "fire", "fire", ({10000}) );
    add_ac( "cold", "cold", ({10000}) );
    add_ac( "acid", "acid", ({10000}) );
    add_ac( "magic", "magic", ({10000}) );
    set_sight( ({ 0, 5, 100, 125 }) );
    set_stats( ({ 30, 10, 0, 40, 0 }) );
}
varargs int query_ac( string type, int damage, string zone, int amount ) {
    object attacker, weapon;
    if( type == "blunt" )
        return amount;
    attacker = (object)previous_object()->query_attacker();
    if( attacker ) {
        weapon = (object)attacker->query_weapon();
        if( weapon && weapon != attacker )
            weapon->adjust_cond( -(int)weapon->query_cond() / 15 );
    }
    return amount;
}
object make_corpse() {
    object corpse, owner;
    owner = previous_object();
    corpse = ARMOURY->request_item( "golem corpse", 100 );
    all_inventory( owner )->move( corpse );
    return corpse;
}
void set_unarmed_attacks( object thing ) {
    if( !thing )
        return;
    thing->remove_attack( "hands" );
    thing->remove_attack( "feet" );
    thing->add_attack( "hands", 75, ({ 50, 10, 15 }),
        "blunt", "unarmed", ({ "unarmed_hands", this_object() }) );
}
void unarmed_hands( int damage, object him, object me, string a_type,
    string a_name ) {
    if( damage > 130 || damage >= him->query_hp() ) {
        damage = 0;
        knock_out( him, me );
    }
}
void knock_out( object player, object golem ) {
    object room, target;
    string *all_exits, *no_doors = ({ });
    string exit;
    int i;
    if( !player || !golem )
        return;
    player->stop_all_fight();
    golem->stop_fight( player );
    if( !( room = environment( golem ) ) )
        return;
    all_exits = room->query_dest_dir();
    for( i = 0; i < sizeof( all_exits ); i += 2 )
        if( !room->query_door( all_exits[i], "door" ) )
            no_doors += ({ all_exits[i + 1]  });
    target = load_object( no_doors[ random( sizeof( no_doors ) ) ] );
    tell_object( player,
        golem->the_short() + "' blow lifts you off your feet and hurls "
        "you through the air.\n"
        "You see the world race past you and then the ground approaching very "
        "fast.\n" );
    if( target ) {
        exit = all_exits[ member_array( file_name( target ), all_exits ) - 1 ];
        player->move( target,
            "$N come$s flying through the air from $F in a high arc and "
            "thump$s onto the ground.",
            "$N is lifted off " + player->query_possessive() + " feet by " +
            golem->the_short() + "'s blow and sail$s out of the room "
            "to the " + exit + "." );
    } else
        tell_room( room,
            player->the_short() + " is lifted off " +
            player->query_possessive() + " feet by " +
            golem->the_short() + "'s blow and smashes to the "
            "ground.\n", ({player}) );
    player->set_position( "lying on the ground unconscious" );
    player->add_property( "passed out", 1, ( 150 + random( 150 ) ) );
}
int stone_skinned() {
    return 1;
}

==================================================
FILE: races/guppy.c
==================================================

inherit "/std/races/fish_base";
void setup() {
   set_name( "guppy" );
   set_long( "Fish,  yes.  A fish.  Nice generic standard fish thing.\n" );
   set_height( 15 );
   set_weight( 40 );
   set_desc( "a beautiful looking guppy" );
   set_stats( ({ -2, 14, -4, -4, -6 }) );
}
void start_player( object thing ) {
   ::start_player( thing );
   thing->add_property( "gills", 1 );
   thing->tactics( "response dodge" );
}
int lives_in_water() { return 1; }

==================================================
FILE: races/hare.c
==================================================

inherit "/std/races/lagomorpha_base";
void setup() {
   set_name( "hare" );
   set_long( "This is a hare with long ears.\n" );
   set_height( 50 );
   set_weight( 100 );
   set_desc( "a large and meaty hare" );
   set_stats( ({ -2, 8, -4, -4, -6 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number ) / 6;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->add_attack( "bite", 75, ({ 0, 3, 5 }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude defensive" );
}

==================================================
FILE: races/hedgehog.c
==================================================

inherit "/std/races/carnivore";
void setup() {
   set_name( "hedgehog" );
   set_long( "A snail and worm eating little bugger.\n" );
   set_height( 30 );
   set_weight( 150 );
   set_desc( "A small spiny hedgehog" );
   set_stats( ({ 2, -2, -4, -2, -6 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 1 + ( 2 * level + random( level ) ) / 10;
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->remove_attack( "claws" );
   thing->add_attack( "bite", 100, ({ number / 2, 2, number }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 150, ({ number / 2, 2, number }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/hippo.c
==================================================

inherit "/std/races/ruminant";
void setup() {
   set_name( "elephant" );
   set_long( "This is an elephant.  A large creature with a thick grey "
      "hide.  He seems to weigh a lot so don't let him step on your "
      "toe.\n" );
   set_height( 280 );
   set_weight( 100000 );
   set_desc( "an elephant that looks back at you with small nice eyes" );
   remove_bit( "nose" );
   remove_bit( "head" );
   add_bit( "head", "head", ({ 0, 135, 0,
      "left eye", "right eye", "skull", "tongue", "left ear", "right ear",
      "tusk", "tusks", "trunk" }) );
   add_bit( "tail", "tail", ({ 0, 15, 0 }) );
   add_bit( "tusk", "tusk", ({ "head", 20, ({"/std/bit_set", 1}),
      "tusks" }) );
   add_bit( "tusks", "tusks", ({ "head", 40, ({"/std/bit", 2}) }) );
   add_bit( "trunk", "trunk", ({ "head", 30, 0 }) );
   inedible += ({ "tail", "tusk", "tusks" });
   unrottable += ({ "tusk", "tusks" });
   add_ac( "blunt", "blunt", ({ 40, 20}) );
   add_ac( "pierce", "pierce", ({ 30, 20 }) );
   add_ac( "sharp", "sharp", ({ 50, 20 }) );
   add_ac( "acid", "acid", 20 );
   add_ac( "fire", "fire", 20 );
   set_stats( ({ 10, -6, -4, 16, -2 }) );
}
void set_unarmed_attacks( object thing ) {
   thing->remove_attack( "hands" );
   thing->remove_attack( "tusks" );
   thing->remove_attack( "crush" );
   thing->remove_attack( "ram" );
   thing->add_attack( "tusks", 20, ({75, 5, 30}),
      "pierce", "unarmed", 0 );
   thing->add_attack( "crush", 10, ({100, 5, 50}),
      "blunt", "unarmed", 0 );
   thing->add_attack_message( "crush", "unarmed", ({
     0, "$N stand$s on $p hind legs and attempt$s to crash down on $I",
      100, "$N stand$s on $p hind legs and crash$es down stricking $I "
       "a glancing blow ",
      150, "$N stand$s on $p hind legs and crash$es down on $I, crushing "
            "$P $z",
      350, "$N stand$s on $p hind legs and crash$es down on $I, crushing "
            "$P $z into a bloody mess" }) );
   thing->add_attack( "ram", 10, ({50, 3, 20}),
      "blunt", "unarmed", 0 );
   thing->add_attack_message( "ram", "unarmed", ({
     0, "$N charge$s at $I",
      100, "$N charge$s $I and strike$s $I",
      150, "$N charge$s $I and strike$s $P $z hard, making $I stagger "
            "around",
      350, "$N charge$s $I and strike$s $I to the ground.  $I "
            "stumbles around a little groggily" }) );
   thing->add_attack( "trunk", 20, ({50, 3, 20}),
      "blunt", "unarmed", 0 );
   thing->add_attack_message( "trunk", "unarmed", ({
     0, "$N swing$s $p trunk at $I",
      100, "$N swing$s $p trunk at $I, hitting $P $z hard",
      150, "$N swing$s $p trunk, which thumps forcefully into $P $z",
      350, "$N swing$s $p trunk at $I, knocking $I down.  $I "
            "gets up groggily" }) );
}

==================================================
FILE: races/horse.c
==================================================

inherit "/std/races/base";
void setup() {
   set_name( "horse" );
   set_long( "A large hoofed mammal.  Surprise.\n" );
   set_height( 200 );
   set_weight( 7000 );
   bits= ({
      "head", "head", ({ 0, 120, 0,
         "left eye", "right eye", "skull", "brain", "left ear",
         "right ear", "tongue" }),
      "left eye", "eye", ({ "head", 2, 0 }),
      "right eye", "eye", ({ "head", 2, 0 }),
      "skull", "cranium", ({ "head", 45, 0, "teeth" }),
      "brain", "brain", ({ "head", 20, 0 }),
      "left ear", "ear", ({"head", 4, 0 }),
      "right ear", "ear", ({"head", 4, 0 }),
      "teeth", "teeth", ({ "skull", 5, ({"/std/bit_set", 1}) }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 18}) }),
      "tongue", "tongue", ({ "head", 9, 0 }),
      "neck", "neck", ({ 0, 120, 0 }),
      "torso", "body", ({ 0, 400, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "intestine", "pancreas" }),
      "heart", "heart", ({ "torso", 35, 0 }),
      "liver", "liver", ({ "torso", 35, 0 }),
      "left kidney", "kidney", ({ "torso", 20, 0 }),
      "right kidney", "kidney", ({ "torso", 20, 0 }),
      "left lung", "lung", ({ "torso", 35, 0 }),
      "right lung", "lung", ({ "torso", 35, 0 }),
      "spleen", "spleen", ({ "torso", 20, 0 }),
      "intestine", "gut", ({ "torso", 75, 0 }),
      "pancreas", "pancreas", ({ "torso", 20, 0 }),
      "left front leg", "leg", ({ 0, 140, 0, "left front hoof" }),
      "left front hoof", "hoof", ({ "left front leg", 20, 0 }),
      "right front leg", "leg", ({ 0, 140, 0, "right front hoof" }),
      "right front hoof", "hoof", ({ "right front leg", 20, 0 }),
      "left rear leg", "leg", ({ 0, 160, 0, "left rear hoof" }),
      "left rear hoof", "hoof", ({ "left rear leg", 20, 0 }),
      "right rear leg", "leg", ({ 0, 160, 0, "right rear hoof" }),
      "right rear hoof", "hoof", ({ "right rear leg", 20, 0 }),
      "tail", "tail", ({ 0, 15, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   inedible = ({ "skull", "left front hoof", "right front hoof",
      "left rear hoof", "right rear hoof", "tail", "teeth", "tooth" });
   unrottable = ({ "skull", "left front hoof", "right front hoof",
      "left rear hoof", "right rear hoof", "teeth", "tooth" });
   set_desc( "a large, hairy quadruped.  It looks like a horse" );
   add_ac( "blunt", "blunt", 50 );
   add_ac( "sharp", "sharp", 20 );
   add_ac( "pierce", "pierce", 20 );
   set_skin( "skin" );
   set_stats( ({ 4, 4, -2, 6, -2 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "chew" );
   thing->remove_attack( "hoof" );
   thing->add_attack( "chew", 50, ({ number, 2, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "hoof", 70, ({ number / 2, 5, number }),
      "blunt", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/human.c
==================================================

inherit "/std/races/humanoid";
void setup() {
   set_long("The human race.  The standard by which all the races are set, "+
           "this is race can be considered the norm.\n");
   set_name("human");
   set_weight(1600);
   set_height(175);
   add_ac( "blunt", "blunt", 3 );
   add_ac( "pierce", "pierce", 2 );
   add_ac( "sharp", "sharp", 2 );
   set_sight( ({ 5, 25, 200, 300 }) );
}
string query_desc( object thing ) {
  if ( (int)thing->query_gender() == 1 )
    return "He is a strapping young human lad.\n";
  if ( (int)thing->query_gender() == 2 )
    return "She is a strapping young human lass.\n";
  return "It is a strapping young human.\n";
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->add_attack( "hands", 75, ({ 2 * number, 5, number }), "blunt",
         "unarmed", "unarmed_hands" );
   thing->add_attack( "feet", 25, ({ 3 * number, 7, number }), "blunt",
         "unarmed", 0 );
}
string temperature_effects(object thing, int temperature) {
  string temperature_str;
  switch(temperature/3) {
  case 101 .. 1000:
    thing->dest_hide_shadow();
    tell_object( thing, "The heat is just too much for you.\n" );
    tell_room( environment( thing ), "Sweating profusely and turning "
               "a nasty red-purple colour "+
               (string)thing->the_short() +" expires.\n", thing );
    thing->do_death();
    temperature_str = "";
    break;
  case 81 .. 100:
    temperature_str = "close to death from extreme heatstroke";
    thing->adjust_tmp_wis(-1);
    thing->adjust_tmp_int(-1);
    break;
  case 51 .. 80:
    temperature_str = "sick from heatstroke";
    if(!random(2))
      thing->adjust_tmp_wis(-1);
    if(!random(2))
      thing->adjust_tmp_int(-1);
    break;
  case 21 .. 50:
    temperature_str = "very hot";
    tell_object(thing, "You feel really hot.\n");
    break;
  case 11 .. 20:
    temperature_str = "rather warm";
    tell_object(thing, "You feel quite warm.\n");
    break;
  case -10 .. 10:
    temperature_str = "";
    break;
  case -20 .. -11 :
    temperature_str = "rather cold";
    tell_object(thing, "You feel quite cold.\n");
    break;
  case -50 .. -21 :
    temperature_str = "very cold";
    tell_object(thing, "You feel cold to your bones.\n");
    break;
  case -80 .. -51 :
    temperature_str = "sick from hypothermia";
    tell_object(thing, "You're so cold you feel your energy being drained.\n");
    if(!random(2))
      thing->adjust_tmp_str(-1);
    if(!random(2))
      thing->adjust_tmp_con(-1);
    break;
  case -100 .. -81 :
    temperature_str = "close to death from extreme hypothermia";
    tell_object(thing, "You're so cold you feel as though you're about to "
                "expire.\n");
    thing->adjust_tmp_str(-1);
    thing->adjust_tmp_con(-1);
    break;
  case -1000 .. -101:
    thing->dest_hide_shadow();
    tell_object( thing, "The cold is just too much for you.\n" );
    tell_room( environment( thing ), "Frost riming "+
               (string)thing->query_possessive() +" skin in a thick crust, "+
               (string)thing->the_short() +" expires.\n", thing );
    thing->do_death();
    temperature_str = "";
    break;
  }
  if(temperature /5 >  10) {
    thing->new_parser("sweat");
    thing->add_effect("/std/effects/other/wetness",
                      temperature);
  } else if(temperature/5 < -10) {
    thing->new_parser("shiver");
    if(temperature < -30 && !random(250))
      thing->add_effect( "/std/effects/disease/common_cold",
                         -(temperature*10));
  }
  return temperature_str;
}

==================================================
FILE: races/humanoid.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "a humanoid-type being.  This should not be used since it is a "
      "base race" );
   bits = ({
      "head", "head", ({ 0, 40, 0,
         "left ear", "right ear", "left eye", "right eye", "nose", "scalp",
         "tongue", "skull" }),
      "left ear", "ear", ({ "head", 1, 0 }),
      "right ear", "ear", ({ "head", 1, 0 }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "nose", "nose", ({ "head", 1, 0 }),
      "scalp", "scalp", ({ "head", 3, 0 }),
      "tongue", "tongue", ({ "head", 2, 0 }),
      "skull", "skull", ({ "head", 20, 0, "teeth", "brain" }),
      "brain", "brain", ({ "skull", 40, 0 }),
      "teeth", "teeth", ({ "skull", 2, ({"/std/bit_set", 1}), "tooth" }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 32}) }),
      "left arm", "arm", ({ 0, 80, 0, "left hand" }),
      "right arm", "arm", ({ 0, 80, 0, "right hand" }),
      "torso", "torso", ({ 0, 400, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "rib" }),
      "left hand", "hand", ({ "left arm", 15, 0,
         "left little finger", "left third finger", "left index finger",
         "left ring finger", "left thumb" }),
      "right hand", "hand", ({ "right arm", 15, 0,
         "right little finger", "right third finger", "right index finger",
         "right ring finger", "right thumb" }),
      "left little finger", "finger", ({ "left hand", 1, 0 }),
      "left third finger", "finger", ({ "left hand", 1, 0 }),
      "left index finger", "finger", ({ "left hand", 1, 0 }),
      "left ring finger", "finger", ({ "left hand", 1, 0 }),
      "left thumb", "thumb", ({ "left hand", 1, 0 }),
      "right little finger", "finger", ({ "right hand", 1, 0 }),
      "right third finger", "finger", ({ "right hand", 1, 0 }),
      "right index finger", "finger", ({ "right hand", 1, 0 }),
      "right ring finger", "finger", ({ "right hand", 1, 0 }),
      "right thumb", "thumb", ({ "right hand", 1, 0 }),
      "heart", "heart", ({ "torso", 10, 0 }),
      "liver", "liver", ({ "torso", 5, 0 }),
      "left kidney", "kidney", ({ "torso", 5, 0 }),
      "right kidney", "kidney", ({ "torso", 5, 0 }),
      "left lung", "lung", ({ "torso", 5, 0 }),
      "right lung", "lung", ({ "torso", 5, 0 }),
      "spleen", "spleen", ({ "torso", 5, 0 }),
      "rib", "rib", ({ "torso", 1, ({"/std/bit", 16}) }),
      "genitals", "genitals", ({ 0 , 5, ({"/std/bit_set", 1}), "genitals" }),
      "left leg", "leg", ({ 0, 300, 0, "left foot", "left femur" }),
      "right leg", "leg", ({ 0, 300, 0, "right foot", "right femur" }),
      "left femur", "femur", ({ "left leg", 1, 0 }),
      "right femur", "femur", ({ "right leg", 1, 0 }),
      "left foot", "foot", ({ "left leg", 50, 0,
         "left big toe", "left second toe", "left third toe",
         "left fourth toe", "left little toe" }),
      "right foot", "foot", ({ "right leg", 50, 0,
         "right big toe", "right second toe", "right third toe",
         "right fourth toe", "right little toe" }),
      "right little toe", "toe", ({ "right foot", 1, 0 }),
      "right second toe", "toe", ({ "right foot", 1, 0 }),
      "right third toe", "toe", ({ "right foot", 1, 0 }),
      "right fourth toe", "toe", ({ "right foot", 1, 0 }),
      "right big toe", "toe", ({ "right foot", 1, 0 }),
      "left little toe", "toe", ({ "left foot", 1, 0 }),
      "left second toe", "toe", ({ "left foot", 1, 0 }),
      "left third toe", "toe", ({ "left foot", 1, 0 }),
      "left fourth toe", "toe", ({ "left foot", 1, 0 }),
      "left big toe", "toe", ({ "left foot", 1, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   inedible = ({ "skull", "teeth", "tooth", "rib", "left femur", "right femur" });
   unrottable = ({ "skull", "teeth", "tooth", "rib", "left femur", "right femur" });
   set_skin( "skin" );
   if( !do_setup )
      this_object()->setup();
}
int query_humanoid() {
   return 1;
}
string *query_target_zones() {
  return ({ "head", "head", "neck",
              "chest", "chest", "chest", "chest", "back",
              "left arm", "left arm", "left hand",
              "stomach", "stomach", "stomach",
              "right arm", "right arm", "right hand",
              "left leg", "left leg", "left foot",
              "right leg", "right leg", "right foot"});
}
string map_target_zone(string zone) {
  switch(zone) {
  case "abdomen":
    return "stomach";
  case "arms":
    return (random(2) ? "left " : "right ") + "arm";
  case "hands":
    return (random(2) ? "left " : "right ") + "hand";
  case "legs":
    return (random(2) ? "left " : "right ") + "leg";
  case "feet":
    return (random(2) ? "left " :"right ") + "foot";
  default:
    return zone;
  }
}

==================================================
FILE: races/imp.c
==================================================

inherit "/std/races/demonic";
void setup() {
   set_long( "This is one of the smaller denizens of the Underworld.\n" );
   set_name( "imp" );
   set_height( 50 );
   set_weight( 400 );
   set_desc( "a crafty-looking imp" );
   set_stats( ({ 2, 8, 2, 2, 2 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_skill_level( "other.health", level * 4 );
   thing->add_ac( "blunt", "blunt", level / 4 );
   thing->add_ac( "pierce", "pierce", level / 8 );
   thing->add_ac( "sharp", "sharp", level / 6 );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 6 + sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->add_attack( "hands", 75, ({ 2 * number, 8, number }),
      "blunt", "unarmed", 0 );
   thing->add_attack( "feet", 25, ({ 3 * number, 10, number }),
      "blunt", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/insect.c
==================================================

inherit "/std/races/insect_base";
void setup() {
   set_name( "insect" );
   set_long( "A nondescript insect.\n" );
   set_height( 5 );
   set_weight( 2 );
   set_desc( "a nondescript insect" );
   set_stats( ({ -6, 4, -6, -6, -6 }) );
}
int query_eat( string type ) {
   return ( member_array( type, inedible ) == -1 );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_skill_level( "other.health", level * 2 );
   thing->add_ac( "blunt", "blunt", level / 2 );
   thing->add_ac( "pierce", "pierce", level / 4 );
   thing->add_ac( "sharp", "sharp", level / 3 );
}
int query_dark( int light ) { return 0; }
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->add_attack( "bite", 75, ({ 3 * number, 10, number }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/insect_base.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "your standard insect.  This should not be used since it is a "
      "base race" );
   bits = ({
      "head", "head", ({ 0, 200, 0,
         "left feeler", "right feeler", "brain", "left eye", "right eye",
         "mandible" }),
      "left feeler", "feeler", ({ "head", 10, 0 }),
      "right feeler", "feeler", ({ "head", 10, 0 }),
      "brain", "brain", ({ "head", 50, 0 }),
      "left eye", "eye", ({ "head", 10, 0 }),
      "right eye", "eye", ({ "head", 10, 0 }),
      "mandible", "mouth", ({ "head", 25, 0 }),
      "thorax", "thorax", ({ 0, 500, 0,
         "left front leg", "right front leg", "left middle leg",
         "right middle leg", "left back leg", "right back leg" }),
      "left front leg", "leg", ({ "thorax", 50, 0 }),
      "right front leg", "leg", ({ "thorax", 50, 0 }),
      "left middle leg", "leg", ({ "thorax", 50, 0 }),
      "right middle leg", "leg", ({ "thorax", 50, 0 }),
      "left back leg", "leg", ({ "thorax", 50, 0 }),
      "right back leg", "leg", ({ "thorax", 50, 0 }),
      "abdomen", "abdomen", ({ 0, 500, 0 })
   });
   inedible = ({ "mandible" });
   unrottable = ({ "mandible" });
   set_skin( "carapace" );
   if( !do_setup )
      this_object()->setup();
}
string *query_target_zones() {
  return ({ "head", "head",
              "thorax","thorax", "thorax", "thorax", "thorax", "thorax",
              "left front leg", "left front leg",
              "left middle leg", "left middle leg",
              "right front leg", "right front leg",
              "right middle leg", "right middle leg",
              "abdomen", "abdomen", "abdomen", "abdomen", "abdomen",
              "left back leg", "left back leg",
              "right back leg", "right back leg" });
}
string map_target_zone(string zone) {
  switch(zone) {
  case "neck":
  case "chest":
    return "thorax";
  case "arms":
  case "hands":
    return (random(2) ? "left " : "right ") +
      (random(2) ? "front " : "middle ") + "leg";
  case "feet":
  case "legs":
    return (random(2) ? "left " : "right ") + "rear leg";
  default:
    return zone;
  }
}

==================================================
FILE: races/jellyfish.c
==================================================

inherit "/std/races/base";
#define STINGEFFECT "/std/effects/disease/jellyfish_sting"
void setup() {
   set_name( "jellyfish" );
   set_long( "A jelly-like blob with tendrils.\n" );
   set_height( 15 );
   set_weight( 20 );
   set_desc( "a jelly-like blob with tendrils." );
   bits = ({
      "tendril", "tendril", ({ 0, 1, ({ "/std/bit", 10 }) }),
      "bell", "bell", ({ 0, 10, 0 })
   });
   inedible = ({ "bell", "tendril" });
   unrottable = ({ });
   set_skin( "exocuticule" );
   add_ac( "acid", "acid", 100 );
   add_ac( "poison", "poison", 100 );
   add_ac( "blunt", "blunt", 75 );
   add_ac( "sharp", "sharp", 25 );
   add_ac( "pierce", "pierce", 25 );
   set_stats( ({ -5, -5, -5, -5, -5 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 2 + (sqrt( number ) / 10);
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "tendrils" );
   thing->add_attack( "tendrils", 100, ({ number, 10, number }),
      "blunt", "blunt", ({ "sting", this_object() }) );
   thing->add_attack_message( "tendrils", "blunt", ({
      20, "$N brush$es $P $z with $p tendrils",
      60, "$N slap$s $P $z with $p tendrils",
      100, "$N knock$s $I with $p tendrils",
      140, "$N thwack$s $I with $p tendrils",
      180, "$N smack$s $p tendrils into $P $z",
      220, "$N wallop$s $I with $p tendrils",
      0, "$N hammer$s $I with $p tendrils" }) );
}
void start_player( object thing ) {
   ::start_player( thing );
   thing->add_property( "gills", 1 );
   thing->add_property("lives in water", 1);
}
int lives_in_water() { return 1; }
void sting( int damage, object him, object me, string atype, string aname ) {
   him->add_effect(STINGEFFECT, damage);
}

==================================================
FILE: races/lagomorpha_base.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "a generic lagomorph animal.  It shouldn't be used since "
      "this is just a base race" );
   bits = ({
      "head", "head", ({ 0, 40, 0,
         "left eye", "right eye", "left ear", "right ear", "skull" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "left ear", "ear", ({ "head", 20, 0 }),
      "right ear", "ear", ({ "head", 20, 0 }),
      "skull", "skull", ({ "head", 20, 0, "brain", "teeth" }),
      "brain", "brain", ({ "skull", 10, 0 }),
      "teeth", "teeth", ({ "skull", 5, ({"/std/bit_set", 1}), "tooth" }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 20}) }),
      "torso", "torso", ({ 0, 100, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen",
         "right lung", "left lung", "intestine" }),
      "heart", "heart", ({ "torso", 15, 0 }),
      "liver", "liver", ({ "torso", 15, 0 }),
      "left kidney", "kidney", ({ "torso", 10, 0 }),
      "right kidney", "kidney", ({ "torso", 10, 0 }),
      "spleen", "spleen", ({ "torso", 10, 0 }),
      "right lung", "lung", ({ "torso", 15, 0 }),
      "intestine", "gut", ({ "torso", 100, 0 }),
      "genitalia", "genitalia", ({ 0, 5, 0 }),
      "left front leg", "leg", ({ 0, 100, 0, "left front paw" }),
      "left front paw", "paw", ({ "left front leg", 30, 0 }),
      "right front leg", "leg", ({ 0, 100, 0, "right front paw" }),
      "right front paw", "paw", ({ "right front leg", 30, 0 }),
      "left rear leg", "leg", ({ 0, 300, 0, "left rear paw" }),
      "left rear paw", "paw", ({ "left rear leg", 50, 0 }),
      "right rear leg", "leg", ({ 0, 300, 0, "right rear paw" }),
      "right rear paw", "paw", ({ "right rear leg", 50, 0 }),
      "tail", "tail", ({ 0, 25, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   inedible = ({ "skull", "teeth", "tooth", "tail", "skin" });
   unrottable = ({ "skull", "teeth", "tooth" });
   set_skin( "fur" );
   if( !do_setup )
      this_object()->setup();
}
string *query_target_zones() {
  return ({ "head", "head", "neck",
              "chest", "back", "back", "back", "lower back",
              "left front leg", "left front leg", "left front paw",
              "stomach", "stomach", "tail",
              "right front leg", "right front leg", "right front paw",
              "left rear leg", "left rear leg", "left rear paw",
              "right rear leg", "right rear leg", "right rear paw"});
}
string map_target_zone(string zone) {
  switch(zone) {
  case "chest":
    return random(4) ? "back" : "chest";
  case "abdomen":
    return random(4) ? "stomach" : "lower back";
  case "arms":
    return (random(2) ? "left " : "right ") + "front leg";
  case "hands":
    return (random(2) ? "left " : "right ") + "front paw";
  case "legs":
    return (random(2) ? "left " : "right ") + "rear leg";
  case "feet":
    return (random(2) ? "left " :"right ") + "rear paw";
  default:
    return zone;
  }
}

==================================================
FILE: races/light.c
==================================================

inherit "/std/races/base";
void setup() {
   set_name( "light" );
   set_long( "A small sphere of magical blue light.\n" );
   set_weight( 1 );
   set_height( 1 );
   set_desc( "a small ball of blue light hovering in the air." );
   bits = ({ });
   inedible = ({ });
   unrottable = ({ });
   add_ac( "fire", "fire", 1000 );
   add_ac( "sound", "sound", 1000 );
   add_ac( "acid", "acid", 1000 );
   add_ac( "gas", "gas", 1000 );
   add_ac( "mental", "mental", 100 );
   set_stats( ({ 0, 14, -6, -6, -6 }) );
}
void start_player( object thing ) {
   ::start_player( thing );
   thing->tactics( "response dodge" );
}
int lives_in_water() { return 1; }

==================================================
FILE: races/lion.c
==================================================

inherit "/std/races/carnivore";
void setup() {
   set_name( "lion" );
   set_long( "A carnivorous mammal.  This is the real thing though, not "
         "your domesticated house cat, but the king of its kind.  It leaps "
         "over the ground in huge bounding strides, power that other cats "
         "can only dream about.\n" );
   set_height( 150 );
   set_weight( 3500 );
   set_desc( "a rather large lion, bounding vigorously towards you" );
   add_bit( "bile duct", "duct", ({ "torso", 1, 0 }) );
   set_stats( ({ 6, 10, -4, 10, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );
   if( number < 10 )
      number = 10;
   thing->add_attack( "claws", 100, ({ number, 10, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 75, ({ 3 * number, number / 2, number }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/lobster.c
==================================================

inherit "/std/races/base";
void setup() {
    set_name( "lobster" );
    set_long( "A cranky lobster.\n" );
    set_height( 10 );
    set_weight( 18 );
    set_desc( "a cranky lobster" );
    bits = ({
        "head", "head", ({ 0, 200, 0,
            "left antenna", "right antenna", "left antennule", "right "
            "antennule", "brain", "left eye", "right eye", "left eyestalk",
            "right eyestalk", "jaw", "skull" }),
        "left antenna", "antenna", ({ "head", 2, 0 }),
        "right antenna", "antenna", ({ "head", 2, 0 }),
        "left antennule", "antennule", ({ "head", 1, 0 }),
        "right antennule", "antennule", ({ "head", 1, 0 }),
        "brain", "brain", ({ "head", 50, 0 }),
        "skull", "skull", ({ "head", 50, 0 }),
        "left eye", "eye", ({ "head", 5, 0 }),
        "right eye", "eye", ({ "head", 5, 0 }),
        "left eyestalk", "eyestalk", ({ "head", 2, 0 }),
        "right eyestalk", "eyestalk", ({ "head", 2, 0 }),
        "jaw", "mouth", ({ "head", 25, 0 }),
        "carapace", "carapace", ({ 0, 25, 0 }),
        "thorax", "thorax", ({ 0, 500, 0,
            "left cheliped", "right cheliped", "left second leg",
            "right second leg", "left third leg", "right third leg", "left "
            "fourth leg", "right fourth leg", "left back leg", "right back "
            "leg", "heart", "hepatopancreas", "intestine", "stomach" }),
        "left cheliped", "cheliped", ({ "thorax", 75, 0 }),
        "right cheliped", "cheliped", ({ "thorax", 75, 0 }),
        "left second leg", "leg", ({ "thorax", 50, 0 }),
        "right second leg", "leg", ({ "thorax", 50, 0 }),
        "left third leg", "leg", ({ "thorax", 50, 0 }),
        "right third leg", "leg", ({ "thorax", 50, 0 }),
        "left fourth leg", "leg", ({ "thorax", 50, 0 }),
        "right fourth leg", "leg", ({ "thorax", 50, 0 }),
        "left back leg", "leg", ({ "thorax", 50, 0 }),
        "right back leg", "leg", ({ "thorax", 50, 0 }),
        "heart", "heart", ({ "thorax", 50, 0 }),
        "hepatopancreas", "hepatopancreas", ({ "thorax", 10, 0 }),
        "intestine", "intestine", ({ "thorax", 30, 0 }),
        "stomach", "stomach", ({ "thorax", 30, 0 }),
        "apron", "apron", ({ 0, 100, 0, "left pleopod", "right pleopod" }),
        "left pleopod", "pleopod", ({ "apron", 20, 0 }),
        "right pleopod", "pleopod", ({ "apron", 20, 0 })
    });
    inedible = ({ "jaw", "carapace", "skull" });
    unrottable = ({ "jaw", "carapace", "skull" });
    set_skin( "shell" );
    set_stats( ({ -6, 4, -6, -4, -6 }) );
}
int query_eat( string type ) {
   return ( member_array( type, inedible ) == -1 );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_skill_level( "other.health", level * 2 );
   thing->add_ac( "blunt", "blunt", level / 2 );
   thing->add_ac( "pierce", "pierce", level / 4 );
   thing->add_ac( "sharp", "sharp", level / 3 );
}
void set_unarmed_attacks( object thing ) {
    int number;
    number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
    number = 4 + sqrt( number );
    thing->remove_attack( "hands" );
    thing->remove_attack( "feet" );
    thing->remove_attack( "pincers" );
    thing->add_attack( "pincers", 100, ({ number, 10, number }),
        "unarmed", "unarmed", 0 );
    thing->add_attack_message( "pincers", "unarmed", ({
       20, "$N bat$s $I with $p pincer.\n",
       60, "$N nip$s $P $z with $p pincer.\n",
       100, "$N scratch$es $I deeply with $p pincer.\n",
       140, "$N cut$s $P $z deeply with $p pincer.\n",
       180, "$N dig$s $p pincer into $P $z.\n",
       220, "$N gouge$s $I with $p pincer.\n",
       0, "$N slice$s $P $z up with $p pincer.\n" }) );
   thing->tactics( "response dodge" );
}
int lives_in_water() { return 1; }

==================================================
FILE: races/luggage.c
==================================================

inherit "/std/races/base";
void setup() {
   set_name( "luggage" );
   set_long( "A sapient pearwood luggage.\n" );
   set_desc( "a nice set of luggage" );
   set_height( 75 );
   set_weight( 5000 );
   bits = ({
      "trunk", "trunk", ({ 0, 400, 0 }),
      "lid", "lid", ({ 0, 1000, 0 }),
      "leg", "leg", ({ 0, 5, ({"/std/bit", 50}) })
   });
   inedible = ({ "trunk", "lid" });
   unrottable = ({ "trunk", "lid" });
   set_skin( "casing" );
   add_ac( "blunt", "blunt", 25 );
   add_ac( "pierce", "pierce", 25 );
   add_ac( "sound", "sound", 1000 );
   add_ac( "gas", "gas", 1000 );
   set_stats( ({ 10, 6, -2, 10, -2 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->add_attack( "feet", 75, ({ 5 * number, 10, number }), "blunt",
      "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/mole.c
==================================================

inherit "/std/races/rodent_base";
void setup() {
  set_name( "mole" );
  set_long( "Any insectivore of the family Talpidae, which includes moles, "
     "shrew moles, and desmans.  They have no ears and tiny eyes, and live "
     "in small burrows.\n" );
  set_height( 30 );
  set_weight( 10 );
  set_desc( "This is a blind and deaf mole." );
  set_sight( ({ -100, -60, 40, 60 }) );
  set_stats( ({ -2, 2, -6, -2, -6 }) );
}
void set_unarmed_attacks( object thing ) {
  int number;
  number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
  number = sqrt( number ) / 6;
  thing->remove_attack( "hands" );
  thing->remove_attack( "feet" );
  thing->remove_attack( "bite" );
  thing->remove_attack( "claws" );
  thing->add_attack( "bite", 75, ({ 0, 3, number }),
    "pierce", "unarmed", 0 );
  thing->add_attack( "claws", 50, ({ 10, 5, number / 2 }),
    "sharp", "unarmed", 0 );
  thing->tactics( "response dodge" );
}

==================================================
FILE: races/moose.c
==================================================

inherit "/std/races/ruminant";
void setup() {
   mixed *new_head;
   set_name( "moose" );
   set_long( "The moose is a large woodland animal.\n" );
   set_height( 200 );
   set_weight( 7000 );
   set_desc( "a large, hairy quadruped reminding you very much of a moose" );
   new_head = query_bit( "head" );
   new_head[ 2 ] += ({ "left horn", "right horn" });
   remove_bit( "head" );
   add_bit( "head", "head", new_head[ 2 ] );
   add_bit( "left horn", "horn", ({ "head", 20, 0 }) );
   add_bit( "right horn", "horn", ({ "head", 20, 0 }) );
   add_bit( "tail", "tail", ({ 0, 15, 0 }) );
   inedible += ({"left horn", "right horn", "tail" });
   unrottable += ({ "left horn", "right horn" });
   add_ac( "blunt", "blunt", 50 );
   add_ac( "pierce", "pierce", 20 );
   add_ac( "sharp", "sharp", 20 );
   set_stats( ({ 4, -2, -4, 8, -4 }) );
}
void set_unarmed_attacks( object thing ) {
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "standard" );
   thing->remove_attack( "chew" );
   thing->remove_attack( "hoof" );
   thing->add_attack( "chew", 20, ({ 40, 8, 10 }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "hoof", 50, ({ 60, 10, 40 }),
      "blunt", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/mouse.c
==================================================

inherit "/std/races/rodent_base";
void setup() {
   set_name( "mouse" );
   set_long( "Any of numerous small rodents (as of the genus Mus) with "
      "pointed snout, rather small ears, elongated body and slender "
      "tail.\n" );
   set_height( 10 );
   set_weight( 5 );
   set_desc( "a little mouse, scurrying about for food." );
   set_stats( ({ -4, 8, -4, -4, -6 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number ) / 6;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->remove_attack( "claws" );
   thing->add_attack( "bite", 75, ({ 0, 3, number }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 50, ({ 0, 5, number / 2 }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/mustelidae.c
==================================================

inherit "/std/races/mustelidae_base";
void setup() {
   set_name( "mustelidae" );
   set_long( "The typical weasel like animal.\n" );
   set_height( 15 );
   set_weight( 30 );
   set_desc( "small brown meateater" );
   set_stats( ({ -2, 8, -2, -4, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 2 + ( 2 * level + random( level ) ) / 8;
   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );
   thing->add_attack( "claws", 50, ({ ( 4 * number ) / 2, 8, 2 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 100, ({ 2 * number, 10, ( 3 * number ) / 2 }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/mustelidae_base.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "the usual mustelidae.  This should not be used as it is a "
      "base race" );
   bits = ({
      "head", "head", ({ 0, 40, 0,
         "left eye", "right eye", "left ear", "right ear", "skull",
         "tongue", "nose" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "left ear", "ear", ({ "head", 1, 0 }),
      "right ear", "ear", ({ "head", 1, 0 }),
      "skull", "skull", ({ "head", 20, 0, "brain", "teeth" }),
      "brain", "brain", ({ "skull", 20, 0 }),
      "teeth", "teeth", ({ "skull", 1, ({"/std/bit_set", 1}), "tooth" }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 20}) }),
      "tongue", "tongue", ({ "head", 2, 0 }),
      "nose", "nose", ({ "head", 1, 0 }),
      "torso", "torso", ({ 0, 350, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "intestine" }),
      "heart", "heart", ({ "torso", 10, 0 }),
      "liver", "liver", ({ "torso", 5, 0 }),
      "left kidney", "kidney", ({ "torso", 5, 0 }),
      "right kidney", "kidney", ({ "torso", 5, 0 }),
      "left lung", "lung", ({ "torso", 10, 0 }),
      "right lung", "lung", ({ "torso", 10, 0 }),
      "spleen", "spleen", ({ "torso", 5, 0 }),
      "intestine", "gut", ({ "torso", 15, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "left front leg", "leg", ({ 0, 5, 0 }),
      "right front leg", "leg", ({ 0, 5, 0 }),
      "left rear leg", "leg", ({ 0, 5, 0 }),
      "right rear leg", "leg", ({ 0, 5, 0 }),
      "tail", "tail", ({ 0, 5, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   inedible = ({ "skull", "teeth", "tooth", "tail", "skin" });
   unrottable = ({ "skull", "teeth", "tooth" });
   set_skin( "fur" );
   if( !do_setup )
      this_object()->setup();
}

==================================================
FILE: races/panda.c
==================================================

inherit "/std/races/carnivore";
void setup() {
   set_name( "panda" );
   set_desc( "a black and white fluffy panda" );
   set_height( 200 );
   set_weight( 8000 );
   set_stats( ({ 6, 4, -2, 8, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 2 + ( 2 * level + random( level ) ) / 8;
   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );
   thing->add_attack( "claws", 100, ({ 2 * number, 10, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 50, ({ 3 * number, 8, number }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude offensive" );
}

==================================================
FILE: races/parrot.c
==================================================

inherit "/std/races/bird_base";
void setup() {
   set_name( "parrot" );
   set_long( "This is a vicious, evil-looking parrot with a glint of mischief "
      "in its eye.\n" );
   set_weight( 25 );
   set_height( 20 );
   set_desc( "an ordinary parrot" );
   add_ac( "feather_blow", "blunt", 10 );
   add_ac( "feather_slash", "sharp", 2 );
   add_ac( "feather_pierce", "pierce", 2 );
   set_stats( ({ 0, 8, -6, -4, -6 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number / 4 ) + ( thing->query_weight() / 20 );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "beak" );
   thing->remove_attack( "claws" );
   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 75, ({ number, 5, number / 2 }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/penguin.c
==================================================

inherit "/std/races/bird_base";
void setup() {
   set_name( "penguin" );
   set_long( "Penguins are always rather formal.\n" );
   set_weight( 600 );
   remove_bit( "gizzard" );
   set_stats( ({ 2, 8, -4, -4, -6 }) );
}
string query_desc( object ob ) {
   return "Penguins are always rather formally dressed.\n";
}

==================================================
FILE: races/pig.c
==================================================

inherit "/std/races/ruminant";
void setup() {
   set_name( "pig" );
   set_long( "A domesticated mammal, of the swine family.\n" );
   set_desc( "a domesticated mammal, of the swine family" );
   set_weight( 1200 );
   set_height( 50 );
   remove_bit( "nose" );
   remove_bit( "head" );
   remove_bit( "left front leg" );
   remove_bit( "right front leg" );
   remove_bit( "left rear leg" );
   remove_bit( "right rear leg" );
   add_bit( "head", "head", ({ 0, 135, 0,
      "left eye", "right eye", "snout", "skull", "tongue", "left ear",
      "right ear" }) );
   add_bit( "snout", "snout", ({ "head", 12, 0 }) );
   add_bit( "left front trotter", "trotter", ({ 0, 180, 0, "left front hoof" }) );
   add_bit( "right front trotter", "trotter", ({ 0, 180, 0, "right front hoof" }) );
   add_bit( "left rear trotter", "trotter", ({ 0, 180, 0, "left rear hoof" }) );
   add_bit( "right rear trotter", "trotter", ({ 0, 180, 0, "right rear hoof" }) );
   add_bit( "chop", "chop", ({ 0, 1, 0 }) );
   add_bit( "tail", "tail", ({ 0, 1, 0 }) );
   inedible += ({ "left front trotter", "right front trotter",
      "left rear trotter", "right rear trotter" });
   unrottable += ({ "left front trotter", "right front trotter",
      "left rear trotter", "right rear trotter" });
   set_stats( ({ 2, 0, -2, 4, -4 }) );
}
void set_unarmed_attacks( object thing ) {
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "standard" );
   thing->remove_attack( "hoof" );
   thing->add_attack( "hoof", 60, ({ 32, 10, 11 }),
      "blunt", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/rabbit.c
==================================================

inherit "/std/races/lagomorpha_base";
void setup() {
   set_name( "rabbit" );
   set_long( "A small furry and fluffy rabbit.\n" );
   set_height( 30 );
   set_weight( 25 );
   set_desc( "a cute and fluffy little bunny" );
   set_stats( ({ -3, 8, -4, -5, -6 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number ) / 7;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->add_attack( "bite", 75, ({ 1, 3, 4 }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude defensive" );
}

==================================================
FILE: races/raptor.c
==================================================

inherit "/std/races/bird_base";
void setup() {
   set_name( "raptor" );
   set_long( "A carnivorous bird (as a hawk or falcon) that feeds wholly on "
      "meat taken by hunting.\n" );
   set_height( 65 );
   set_weight( 200 );
   set_desc( "a sharp-eyed raptor" );
   remove_bit( "gizzard" );
   set_stats( ({ 0, 14, -4, 2, -6 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 2 * level + random( level );
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "pierce", "pierce", level / 4 );
   thing->add_ac( "sharp", "sharp", level / 4 );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "beak" );
   thing->remove_attack( "claws" );
   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 75, ({ number, 5, number / 2 }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/rat.c
==================================================

inherit "/std/races/rodent_base";
void setup() {
   set_name( "rat" );
   set_long( "A rodent of the genus Rattus, distinguished from a mouse "
      "by its larger size and by structural details, as of the teeth.\n" );
   set_height( 15 );
   set_weight( 10 );
   set_desc( "a vicious-looking rat, scurrying about for food." );
   set_stats( ({ -4, 8, -2, -4, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->remove_attack( "claws" );
   thing->add_attack( "bite", 75, ({ 3*number, 3, number }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 50, ({ 3*number, 5, number / 2 }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/reptile.c
==================================================

inherit "/std/races/reptile_base";
void setup() {
   set_name( "reptile" );
   set_long( "A normal reptile, wiv scales on.\n" );
   set_weight( 1000 );
   set_height( 20 );
   set_desc( "your standard reptile" );
   set_stats( ({ -2, 2, -4, -2, -6 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "chew" );
   thing->remove_attack( "tail" );
   thing->add_attack( "chew", 75, ({ 3 * number, number / 2, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "tail", 75, ({ number, 5, number }),
      "blunt", "unarmed", 0 );
   thing->tactics( "response dodge" );
   thing->tactics( "attitude offensive" );
}

==================================================
FILE: races/reptile_base.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "your standard reptile.  This should not be used as it is a "
      "base race" );
   bits = ({
      "head", "head", ({ 0, 50, 0,
         "left eye", "right eye", "skull", "tongue", "snout" }),
      "left eye", "eye", ({ "head", 2, 0 }),
      "right eye", "eye", ({ "head", 2, 0 }),
      "skull", "skull", ({ "head", 50, 0, "brain", "teeth" }),
      "brain", "brain", ({ "skull", 25, 0 }),
      "teeth", "teeth", ({ "skull", 5, ({"/std/bit_set", 1}), "tooth" }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 48}) }),
      "tongue", "tongue", ({ "head", 10, 0 }),
      "snout", "snout", ({ "head", 10, 0 }),
      "neck", "neck", ({ 0, 50, 0 }),
      "torso", "body", ({ 0, 400, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "intestine", "pancreas" }),
      "heart", "heart", ({ "torso", 15, 0 }),
      "liver", "liver", ({ "torso", 15, 0 }),
      "left kidney", "kidney", ({ "torso", 10, 0 }),
      "right kidney", "kidney", ({ "torso", 10, 0 }),
      "left lung", "lung", ({ "torso", 15, 0 }),
      "right lung", "lung", ({ "torso", 15, 0 }),
      "spleen", "spleen", ({ "torso", 10, 0 }),
      "intestine", "gut", ({ "torso", 100, 0 }),
      "pancreas", "pancreas", ({ "torso", 10, 0 }),
      "left front leg", "leg", ({ 0, 180, 0, "left front foot" }),
      "left front foot", "foot", ({ "left front leg", 27, 0 }),
      "right front leg", "leg", ({ 0, 180, 0, "right front foot" }),
      "right front foot", "foot", ({ "right front leg", 27, 0 }),
      "left rear leg", "leg", ({ 0, 180, 0, "left rear foot" }),
      "left rear foot", "foot", ({ "left rear leg", 27, 0 }),
      "right rear leg", "leg", ({ 0, 180, 0, "right rear foot" }),
      "right rear foot", "foot", ({ "right rear leg", 27, 0 }),
      "tail", "tail", ({ 0, 100, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   inedible = ({ "skull", "left front foot", "right front foot",
      "left rear foot", "right rear foot", "tail", "teeth", "tooth",
      "skin" });
   unrottable = ({ "skull", "teeth", "tooth" });
   set_skin( "scales" );
   if( !do_setup )
      this_object()->setup();
}

==================================================
FILE: races/rodent.c
==================================================

inherit "/std/races/rodent_base";
void setup() {
   set_name( "rodent" );
   set_long( "A generic rodent object.\n" );
   set_height( 10 );
   set_weight( 10 );
   set_desc( "a small rodent" );
   set_stats( ({ -4, 8, -4, -4, -6 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 1 + ( 2 * args[ 0 ] + random( level ) ) / 10;
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->add_attack( "bite", 100, ({ number, 5, number }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/rodent_base.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "a generic rodent.  It shouldn't be used since this is just a "
      "base race" );
   bits = ({
      "head", "head", ({ 0, 40, 0,
         "left eye", "right eye", "left ear", "right ear", "skull" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "left ear", "ear", ({ "head", 10, 0 }),
      "right ear", "ear", ({ "head", 10, 0 }),
      "skull", "skull", ({ "head", 20, 0, "brain", "teeth" }),
      "brain", "brain", ({ "skull", 10, 0 }),
      "teeth", "teeth", ({ "skull", 5, ({"/std/bit_set", 1}), "tooth" }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 20}) }),
      "torso", "torso", ({ 0, 600, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen",
         "right lung", "left lung", "intestine" }),
      "heart", "heart", ({ "torso", 15, 0 }),
      "liver", "liver", ({ "torso", 15, 0 }),
      "left kidney", "kidney", ({ "torso", 10, 0 }),
      "right kidney", "kidney", ({ "torso", 10, 0 }),
      "spleen", "spleen", ({ "torso", 10, 0 }),
        "left lung", "lung", ({ "torso", 16, 0 }),
      "right lung", "lung", ({ "torso", 15, 0 }),
      "intestine", "gut", ({ "torso", 100, 0 }),
      "genitalia", "genitalia", ({ 0, 5, 0 }),
      "left front leg", "leg", ({ 0, 100, 0, "left front paw" }),
      "left front paw", "paw", ({ "left front leg", 30, 0 }),
      "right front leg", "leg", ({ 0, 100, 0, "right front paw" }),
      "right front paw", "paw", ({ "right front leg", 30, 0 }),
      "left rear leg", "leg", ({ 0, 100, 0, "left rear paw" }),
      "left rear paw", "paw", ({ "left rear leg", 30, 0 }),
      "right rear leg", "leg", ({ 0, 100, 0, "right rear paw" }),
      "right rear paw", "paw", ({ "right rear leg", 30, 0 }),
      "tail", "tail", ({ 0, 25, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   inedible = ({ "skull", "teeth", "tooth", "tail", "skin" });
   unrottable = ({ "skull", "teeth", "tooth" });
   set_skin( "fur" );
   if( !do_setup )
      this_object()->setup();
}

==================================================
FILE: races/ruminant.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_weight( 800 );
   set_height( 50 );
   set_desc( "a four-legged ruminant.  It shouldn't be used since this is "
      "just a base race" );
   bits = ({
      "head", "head", ({ 0, 100, 0,
         "left eye", "right eye", "nose", "skull", "tongue", "left ear",
         "right ear" }),
      "left eye", "eye", ({ "head", 2, 0 }),
      "right eye", "eye", ({ "head", 2, 0 }),
      "skull", "skull", ({ "head", 40, 0, "brain", "teeth" }),
      "brain", "brain", ({ "skull", 20, 0 }),
      "left ear", "ear", ({"head", 5, 0 }),
      "right ear", "ear", ({"head", 5, 0 }),
      "nose", "nose", ({ "head", 15, 0 }),
      "teeth", "teeth", ({ "skull", 5, ({"/std/bit_set", 1}), "tooth" }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 18}) }),
      "tongue", "tongue", ({ "head", 10, 0 }),
      "neck", "neck", ({ 0, 100, 0 }),
      "torso", "chest", ({ 0, 300, 0,
         "heart", "liver", "left kidney", "right kidney", "left lung",
         "right lung", "spleen", "first stomach", "second stomach",
         "third stomach", "fourth stomach", "intestine", "pancreas" }),
      "heart", "heart", ({ "torso", 15, 0 }),
      "liver", "liver", ({ "torso", 15, 0 }),
      "left kidney", "kidney", ({ "torso", 10, 0 }),
      "right kidney", "kidney", ({ "torso", 10, 0 }),
      "left lung", "lung", ({ "torso", 15, 0 }),
      "right lung", "lung", ({ "torso", 15, 0 }),
      "spleen", "spleen", ({ "torso", 10, 0 }),
      "intestine", "gut", ({ "torso", 50, 0 }),
      "pancreas", "pancreas", ({ "torso", 10, 0 }),
      "first stomach", "stomach", ({ "torso", 20, 0 }),
      "second stomach", "stomach", ({ "torso", 20, 0 }),
      "third stomach", "stomach", ({ "torso", 20, 0 }),
      "fourth stomach", "stomach", ({ "torso", 20, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "left front leg", "leg", ({ 0, 150, 0, "left front hoof" }),
      "left front hoof", "hoof", ({ "left front leg", 30, 0 }),
      "right front leg", "leg", ({ 0, 150, 0, "right front hoof" }),
      "right front hoof", "hoof", ({ "right front leg", 30, 0 }),
      "left rear leg", "leg", ({ 0, 150, 0, "left rear hoof" }),
      "left rear hoof", "hoof", ({ "left rear leg", 30, 0 }),
      "right rear leg", "leg", ({ 0, 150, 0, "right rear hoof" }),
      "right rear hoof", "hoof", ({ "right rear leg", 30, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   inedible = ({ "skull", "neck", "genitals", "teeth", "left front hoof",
      "right front hoof", "left rear hoof", "right rear hoof", "tooth",
      "skin" });
   unrottable = ({ "skull", "teeth", "tooth" });
   set_skin( "hide" );
   set_stats( ({ 0, 0, -4, 2, -6 }) );
   if( !do_setup )
      this_object()->setup();
}
string *query_target_zones() {
  return ({ "head", "head", "neck",
              "chest", "back", "back", "back", "lower back",
              "left front leg", "left front leg", "left front hoof",
              "stomach", "stomach", "tail",
              "right front leg", "right front leg", "right front hoof",
              "left rear leg", "left rear leg", "left rear hoof",
              "right rear leg", "right rear leg", "right rear hoof"});
}
string map_target_zone(string zone) {
  switch(zone) {
  case "chest":
    return random(4) ? "back" : "chest";
  case "abdomen":
    return random(4) ? "stomach" : "lower back";
  case "arms":
    return (random(2) ? "left " : "right ") + "front leg";
  case "hands":
    return (random(2) ? "left " : "right ") + "front hoof";
  case "legs":
    return (random(2) ? "left " : "right ") + "rear leg";
  case "feet":
    return (random(2) ? "left " :"right ") + "rear hoof";
  default:
    return zone;
  }
}

==================================================
FILE: races/scorpion.c
==================================================

#define POISON_EFFECT "/std/effects/poisons/spider_venom"
inherit "/std/races/arachnid";
void poison( int damage, object him, object me, string atype, string aname );
void setup() {
   set_name( "scorpion" );
   set_long( "A nasty little poisonous creature, of the arachnid family.\n" );
   set_height( 5 );
   set_weight( 2 );
   set_desc( "a nasty little poisonous creature, of the arachnid family" );
   bits = ({
      "head", "head", ({ 0, 200, 0,
           "left eye", "right eye", "mandible", "brain" }),
      "left eye", "eye", ({ "head", 10, 0 }),
      "right eye", "eye", ({ "head", 10, 0 }),
      "mandible", "mouth", ({ "head", 50, 0 }),
      "brain", "brain", ({ "head", 25, 0 }),
      "thorax", "thorax", ({ 0, 500, 0, "heart", "poison sac" }),
      "heart", "heart", ({ "thorax", 50, 0 }),
      "poison sac", "sac", ({ "thorax", 50, 0 }),
      "tail", "tail", ({ 0, 300, 0, "sting" }),
      "sting", "sting", ({ "tail", 25, 0 }),
      "left claw", "claw", ({ 0, 100, 0 }),
      "right claw", "claw", ({ 0, 100, 0 }),
      "left front leg", "leg", ({ 0, 50, 0 }),
      "left middle leg", "leg", ({ 0, 50, 0 }),
      "left back leg", "leg", ({ 0, 50, 0 }),
      "right front leg", "leg", ({ 0, 50, 0 }),
      "right middle leg", "leg", ({ 0, 50, 0 }),
      "right back leg", "leg", ({ 0, 50, 0 })
   });
   inedible = ({ "mandible", "left claw", "right claw" });
   unrottable = ({ "mandible", "left claw", "right claw" });
   set_stats( ({ -6, 4, -6, -6, -6 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_skill_level( "other.health", level * 3 );
   thing->add_ac( "blunt", "blunt", level / 2 );
   thing->add_ac( "pierce", "pierce", level / 4 );
   thing->add_ac( "sharp", "sharp", level / 3 );
   thing->add_ac( "fire", "fire", level );
}
int query_dark( int light ) { return 0; }
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "poison" );
   thing->remove_attack( "bite" );
   thing->add_attack( "sting", 70, ({ 5 * number, 10, number }),
      "pierce", "unarmed", ({ "poison", this_object() }) );
   thing->add_attack( "bite",  20, ({ 3 * number, 10, number }),
      "pierce", "unarmed", 0 );
   thing->add_attack_message( "sting", "pierce", ({
      0, "$N sting$s $P $z.\n" }) );
   thing->tactics( "response dodge" );
}
void poison( int damage, object him, object me, string a_type,
             string a_name ) {
   tell_object( me, "You stab " + him->one_short() + " with your tail, "
      "injecting " + him->query_objective() + " with venom.\n" );
   tell_object( him, me->one_short() + " stabs you with " +
      me->query_possessive() + " tail!  You seethe in agony.\n" );
   tell_room( environment( me ), me->one_short() + " visciously stabs " +
      him->one_short() + " with " + me->query_possessive() + " tail!  " +
      him->one_short() + " seethes in agony.\n", ({ me, him }) );
   him->add_effect( POISON_EFFECT, 100 );
}

==================================================
FILE: races/shark.c
==================================================

inherit "/std/races/fish_base";
void setup() {
   set_name( "shark" );
   set_long( "A big mean shark.\n" );
   set_height( 15 );
   set_weight( 8000 );
   set_desc( "a fish, the kind with fins" );
   set_stats( ({ 10, 14, 2, 21, -4 }) );
}
void check_water( object player ) {
   if( player && !environment( player )->query_water() )
      call_out( "do_drown", 4, player );
}
void do_drown( object player ) {
   int i;
  if(!player || !environment(player) || environment(player)->query_water() )
      return;
   tell_room( environment( player ) , player->one_short() + " gasps for "
      "air.\n" );
   i = player->query_max_hp() / 5;
   if( i < 20 ) i = 20;
   player->adjust_hp( -i );
   call_out( "do_drown", 4, player );
}
void start_player( object thing ) {
   ::start_player( thing );
   thing->add_property( "gills", 1 );
   thing->add_enter_commands( (: check_water :) );
   thing->set_default_position( ({ "lying" }) );
   thing->return_to_default_position( 0 );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) * 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->add_attack( "bite", 100, ({ 2 * number, 5, number }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/sheep.c
==================================================

inherit "/std/races/ruminant";
void setup() {
   set_name( "sheep" );
   set_long( "The sheep is a wooly mammal.  It is possibly the most stupid "
      "animal in the universe, with the possible exception of the duck.\n" );
   set_height( 50 );
   set_weight( 800 );
   set_skin( "fleece" );
   set_desc( "a wooly sheep" );
   add_ac( "blunt", "blunt", 50 );
   add_ac( "pierce", "pierce", 20 );
   add_ac( "sharp", "sharp", 20 );
   set_stats( ({ 0, 0, -6, -2, -6 }) );
}
void set_unarmed_attacks( object thing ) {
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "standard" );
   thing->remove_attack( "chew" );
   thing->remove_attack( "hoof" );
   thing->add_attack( "chew", 50, ({ 40, 8, 10 }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "hoof", 50, ({ 60, 10, 40 }),
      "blunt", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/skunk.c
==================================================

inherit "/std/races/mustelidae_base";
void setup() {
   set_name( "skunk" );
   set_long( "A small black and white animal.\n" );
   set_height( 15 );
   set_weight( 30 );
   set_desc( "small brown meateater" );
   set_stats( ({ -2, 8, -2, -4, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 1 + ( 2 * level + random( level ) ) / 8;
   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );
   thing->add_attack( "claws", 50, ({ ( 4 * number ) / 2, 8, 2 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 100, ({ 2 * number, 10, ( 3 * number ) / 2 }),
      "pierce", "unarmed", 0  );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/snake.c
==================================================

inherit "/std/races/reptile_base";
void setup() {
   set_name( "snake" );
   set_long( "Snake, Serpent, Legless thingy that crawls on its belly all "
      "day long.\n" );
   set_height( 5 );
   set_weight( 60 );
   set_desc( "a serpent, the type with no legs but with scales." );
   bits = ({
      "head", "head", ({ 0, 50, 0,
         "left eye", "right eye", "poison sac", "tongue", "skull" }),
      "left eye", "eye", ({ "head", 5, 0 }),
      "right eye", "eye", ({ "head", 5, 0 }),
      "poison sac", "sac", ({ "head", 10, 0 }),
      "skull", "skull", ({ "head", 40, 0, "tooth", "brain" }),
      "tooth", "tooth", ({ "skull", 5, ({"/std/bit", 2}) }),
      "brain", "brain", ({ "skull", 10, 0 }),
      "torso", "torso", ({ 0, 600, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen",
         "bladder", "intestine" }),
      "heart", "heart", ({ "torso", 20, 0 }),
      "liver", "liver", ({ "torso", 20, 0 }),
      "left lung", "lung", ({ "torso", 20, 0 }),
      "right lung", "lung", ({ "torso", 20, 0 }),
      "left kidney", "kidney", ({ "torso", 10, 0 }),
      "right kidney", "kidney", ({ "torso", 10, 0 }),
      "spleen", "spleen", ({ "torso", 10, 0 }),
      "bladder", "bladder", ({ "torso", 10, 0 }),
      "intestine", "gut", ({ "torso", 100, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "tail", "tail", ({ 0, 500, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   inedible = ({ "poison sac", "tooth" });
   unrottable = ({ "tooth" });
   add_ac( "blunt", "blunt", 40 );
   add_ac( "sharp", "sharp", 20 );
   add_ac( "pierce", "pierce", 10 );
   set_stats( ({ 0, 0, -4, 4, -4 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->remove_attack( "crush" );
   thing->add_attack( "bite", 75, ({ ( 3 * number ) / 2, 5, number * 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "squeeze", 50, ({ 3 * number, 2, number }),
      "blunt", "unarmed", 0 );
   thing->add_attack_message( "squeeze", "unarmed", ({
     0, "$N attempt$s to wrap $oself around $P $z",
      40, "$N wrap$s $oself around $P $z and squeeze$s",
      80, "$N wrap$s $oself tightly around $P $z and squeeze$s",
      120, "$N wrap$s $oself tightly around $P $z and squeeze$s firmly",
      160, "$N wrap$s $oself around $P $z and squeeze$s tightly, crushing "
           "$I in $p grip",
      0, "$N wrap$s tightly around $I and crush$es $I to a pulp" }) );
   thing->tactics( "response dodge" );
}
string *query_target_zones() {
  return ({ "head", "body", "body", "body", "tail", "tail", "tail" });
}
string map_target_zone(string zone) {
  switch(zone) {
  case "head":
    return "head";
  case "neck":
  case "chest":
    return "body";
  default:
    return "tail";
  }
}

==================================================
FILE: races/spider.c
==================================================

#define POISON_EFFECT "/std/effects/poisons/spider_venom"
inherit "/std/races/arachnid";
void setup() {
   set_name( "spider" );
   set_long( "A small, poisonous, hairy spider.\n" );
   set_desc( "a hairy arachnid" );
   set_height( 5 );
   set_weight( 2 );
   add_bit( "silk gland", "gland", ({ "abdomen", 10,
      ({"/std/bit", 1, 400}) }) );
   add_bit( "poison gland", "gland", ({ "cephalothorax", 5,
      ({"/std/bit", 1, 400}) }) );
   inedible += ({ "poison gland" });
   set_stats( ({ -6, 4, -6, -6, -6 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_skill_level( "other.health", level * 2 );
   thing->add_ac( "blunt", "blunt", level / 2 );
   thing->add_ac( "pierce", "pierce", level / 4 );
   thing->add_ac( "sharp", "sharp", level / 3 );
}
void set_unarmed_attacks( object thing ) {
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "standard" );
   thing->remove_attack( "bite" );
   thing->remove_attack( "chew" );
   thing->add_attack( "bite", 80, ({ 10, 2, 5 }),
      "pierce", "unarmed", ({ "poison", this_object() }) );
   thing->add_attack( "chew", 100, ({ 2, 2, 10 }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}
void poison( int damage, object him, object me, string a_type,
             string a_name ) {
   tell_room( me->one_short() + " visciously sinks its fangs into " +
      him->one_short() + " who seethes in agony!\n" );
   tell_object( him, me->one_short() + " sinks its fangs into you!  You "
      "seethe in agony.\n" );
   him->add_effect( POISON_EFFECT, 100 );
}

==================================================
FILE: races/stoat.c
==================================================

inherit "/std/races/mustelidae_base";
void setup() {
   set_name( "stoat" );
   set_long( "A small black and white animal.\n" );
   set_height( 15 );
   set_weight( 30 );
   set_desc( "small brown meateater" );
   set_stats( ({ -2, 8, -2, -4, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 1 + ( 2 * level + random( level ) ) / 8;
   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );
   thing->add_attack( "claws", 50, ({ ( 4 * number ) / 2, 8, 2 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 100, ({ 2 * number, 10, ( 3 * number ) /2 }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/toad.c
==================================================

inherit "/std/races/amphibian";
void setup() {
   set_name( "toad" );
   set_long( "Toads are amphibians" );
   set_height(10);
   set_weight(10);
   set_desc( "an warty toad" );
   add_ac( "blunt", "blunt", 5 );
   add_ac( "pierce", "pierce", 4 );
   add_ac( "sharp", "sharp", 3 );
   add_attack( "bite", 50, ({ 10, 2, 6 }) );
   set_sight( ({ 5, 20, 200, 300 }) );
   set_stats( ({ -4, 10, -4, -4, -6 }) );
}
void start_player( object thing ) {
   ::start_player( thing );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/tortoise.c
==================================================

inherit "/std/races/base";
void setup() {
   set_name( "tortoise" );
   set_long( "A tortoise.\n" );
   set_height( 40 );
   set_weight( 600 );
   set_desc( "a tortoise, slow and steady" );
   bits = ({
      "head", "head", ({ 0, 100, 0,
         "left eye", "right eye", "skull", "tongue" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "skull", "skull", ({ "head", 50, 0, "brain" }),
      "beak", 0, ({ "skull", 20, 0 }),
      "brain", "brain", ({ "skull", 30, 0 }),
      "torso", "torso", ({ 0, 450, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen",
         "right lung", "left lung", "intestine" }),
      "heart", "heart", ({ "torso", 20, 0 }),
      "liver", "liver", ({ "torso", 20, 0 }),
      "left kidney", "kidney", ({ "torso", 10, 0 }),
      "right kidney", "kidney", ({ "torso", 10, 0 }),
      "spleen", "spleen", ({ "torso", 10, 0 }),
      "right lung", "lung", ({ "torso", 20, 0 }),
      "left lung", "lung", ({ "torso", 20, 0 }),
      "intestine", "gut", ({ "torso", 50, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "left front leg", "leg", ({ 0, 150, 0, "left front claw" }),
      "left front claw", "claw", ({ "left front leg", 25, 0 }),
      "right front leg", "leg", ({ 0, 150, 0, "right front claw" }),
      "right front claw", "claw", ({ "right front leg", 25, 0 }),
      "left rear leg", "leg", ({ 0, 150, 0, "left rear claw" }),
      "left rear claw", "claw", ({ "left rear leg", 25, 0 }),
      "right rear leg", "leg", ({ 0, 150, 0, "right rear claw" }),
      "right rear claw", "claw", ({ "right rear leg", 25, 0 }),
      "tail", "tail", ({ 0, 25, 0 }),
      "shell", 0, ({ 0, 275, 0 })
   });
   inedible = ({ "skull", "beak", "shell" });
   unrottable = ({ "skull", "beak", "shell" });
   set_skin( "skin" );
   set_stats( ({ 2, 4, -2, 6, -4 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "chew" );
   thing->remove_attack( "claws" );
   thing->add_attack( "chew", 100, ({ 3 * number, 0, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "claws", 50, ({ ( 3 * number ) / 2, number, number }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/tree.c
==================================================

inherit "/std/races/tree_base";
void setup() {
   set_name( "tree" );
   set_long( "A tree.\n" );
   set_height( 800 );
   set_weight( 40000 );
   set_desc( "a large tree" );
   add_ac( "blunt", "blunt", 500 );
   add_ac( "sharp", "sharp", 50 );
   add_ac( "pierce", "pierce", 250 );
   add_ac( "fire", "fire", 100 );
   add_ac( "sound", "sound", 1000 );
   add_ac( "gas", "gas", 1000 );
   set_stats( ({ 10, -6, -2, 10, 4 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 2 + sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "branches" );
   thing->add_attack( "branches", 100, ({ number / 2, 10, number }),
      "blunt", "blunt", 0 );
   thing->add_attack_message( "branches", "blunt", ({
      0, "$N swing$s at $I with $p branches",
        20, "$N tap$s $I in the $z with $p branches",
        60, "$N hit$s $I in the $z with $p branches",
        100, "$N bruise$s $P $z with $p branches",
        140, "$N hit$s $I hard in the $z with $p branches",
        180, "$N smash$es $I in the $z with $p branches",
        220, "$N crush$es $P $z with $p branches",
        5000, "$N mash$es $P $z with $p branches" }));
   thing->set_unarmed_parry(1);
}
varargs int query_ac( string type, int damage, string zone, int amount ) {
   object attacker, weapon;
   if( ( type != "pierce" ) && ( type != "sharp" ) )
      return amount;
   attacker = (object)previous_object()->query_last_opponent();
   if( attacker ) {
      weapon = (object)attacker->query_last_weapon();
      if( weapon && ( weapon != attacker ) )
         if( !weapon->id( "axe" ) )
            weapon->adjust_cond( -(int)weapon->query_max_cond() / 20 );
   }
   return amount;
}

==================================================
FILE: races/tree_base.c
==================================================

inherit "/std/races/base";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_desc( "your standard tree.  Shouldn't be used since this is a base "
      "race" );
   bits = ({
      "trunk", "trunk", ({ 0, 1000, 0 }),
      "branch", "branch", ({ 0, 20, ({"/std/bit", 20}) }),
      "root", "root", ({ 0, 20, ({"/std/bit", 10}) })
   });
   inedible = ({ "trunk", "branch", "root" });
   unrottable = ({ });
   set_skin( "bark" );
   if( !do_setup )
      this_object()->setup();
}
string *query_target_zones() {
  return ({ "branch", "branch", "branch", "branch", "branch",
            "branch", "branch", "branch", "branch", "branch",
              "trunk", "trunk", "trunk", "trunk", "trunk",
              "trunk", "trunk", "trunk", "trunk", "trunk",
              "base", "base", "base", "base", "root"});
}
string map_target_zone(string zone) {
  switch(zone) {
  case "chest":
  case "abdomen":
  case "back":
    return "trunk";
  case "hands":
  case "neck":
  case "head":
  case "arms":
  case "legs":
    return "branches";
  case "feet":
    return "root";
  }
}

==================================================
FILE: races/unknown.c
==================================================

inherit "/std/races/human";

==================================================
FILE: races/venomous_snake.c
==================================================

inherit "/std/races/reptile_base";
void setup() {
   set_name( "snake" );
   set_long( "Snake, Serpent, Legless thingy that crawls on its belly all "
      "day long.\n" );
   set_height( 5 );
   set_weight( 60 );
   set_desc( "a serpent, the type with no legs but with scales." );
   bits = ({
      "head", "head", ({ 0, 50, 0,
         "left eye", "right eye", "poison sac", "tongue", "skull" }),
      "left eye", "eye", ({ "head", 5, 0 }),
      "right eye", "eye", ({ "head", 5, 0 }),
      "poison sac", "sac", ({ "head", 10, 0 }),
      "skull", "skull", ({ "head", 40, 0, "tooth", "brain" }),
      "tooth", "tooth", ({ "skull", 5, ({"/std/bit", 2}) }),
      "brain", "brain", ({ "skull", 10, 0 }),
      "torso", "torso", ({ 0, 600, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen",
         "bladder", "intestine" }),
      "heart", "heart", ({ "torso", 20, 0 }),
      "liver", "liver", ({ "torso", 20, 0 }),
      "left lung", "lung", ({ "torso", 20, 0 }),
      "right lung", "lung", ({ "torso", 20, 0 }),
      "left kidney", "kidney", ({ "torso", 10, 0 }),
      "right kidney", "kidney", ({ "torso", 10, 0 }),
      "spleen", "spleen", ({ "torso", 10, 0 }),
      "bladder", "bladder", ({ "torso", 10, 0 }),
      "intestine", "gut", ({ "torso", 100, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "tail", "tail", ({ 0, 500, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   inedible = ({ "poison sac", "tooth" });
   unrottable = ({ "tooth" });
   add_ac( "blunt", "blunt", 40 );
   add_ac( "sharp", "sharp", 20 );
   add_ac( "pierce", "pierce", 10 );
   set_stats( ({ 0, 0, -4, 4, -4 }) );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number );
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "bite" );
   thing->remove_attack( "crush" );
   thing->add_attack( "bite", 80, ({ ( 3 * number ) / 2, 5, number * 2 }),
      "pierce", "unarmed", ({ "poison", this_object() }) );
   thing->tactics( "response dodge" );
}
void poison( int damage, object him, object me, string a_type,
             string a_name ) {
   tell_room( me->one_short() + " visciously sinks its fangs into " +
      him->one_short() + " who seethes in agony!\n" );
   tell_object( him, me->one_short() + " sinks its fangs into you!  You "
      "seethe in agony.\n" );
   him->add_effect( POISON_EFFECT, random(200) );
}
string *query_target_zones() {
  return ({ "head", "body", "body", "body", "tail", "tail", "tail" });
}
string map_target_zone(string zone) {
  switch(zone) {
  case "head":
    return "head";
  case "neck":
  case "chest":
    return "body";
  default:
    return "tail";
  }
}

==================================================
FILE: races/vulture.c
==================================================

inherit "/std/races/bird_base";
void setup() {
   set_name( "vulture" );
   set_long( "A largish, rather scruffy-looking bird with an ugly, "
      "featherless head and a big crooked beak.\n" );
   set_desc( "a somewhat evil-looking old vulture\n" );
   set_height( 40 );
   set_weight( 200 );
   set_stats( ({ 0, 14, -4, 2, -6 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   thing->add_ac( "blunt", "blunt", level / 2 );
   thing->add_ac( "pierce", "pierce", level );
   thing->add_ac( "sharp", "sharp", level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "beak" );
   thing->remove_attack( "claws" );
   thing->add_attack( "beak", 50, ({ number / 2, 2, number / 2 }),
      "pierce", "unarmed", 0 );
   thing->add_attack( "claws", 75, ({ number, 5, number / 2 }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/weasel.c
==================================================

inherit "/std/races/mustelidae_base";
void setup() {
   set_name( "weasel" );
   set_long( "A small brown furred animal.\n" );
   set_height( 15 );
   set_weight( 30 );
   set_desc( "small brown meateater" );
   set_stats( ({ -2, 8, -2, -4, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 2 + ( 2 * level + random( level ) ) / 8;
   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );
   thing->add_attack( "claws", 50, ({ ( 4 * number ) / 2, 8, 2 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 100, ({ 2 * number, 10, ( 3 * number ) / 2 }),
      "pierce", "unarmed", 0  );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/wolf.c
==================================================

inherit "/std/races/carnivore";
void setup() {
   set_name( "wolf" );
   set_desc( "a really nasty, hungry looking canine" );
   set_height( 75 );
   set_weight( 1000 );
   set_stats( ({ 6, 12, -4, 8, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 2 + ( 2 * level + random( level ) ) / 8;
   thing->add_ac( "blunt", "blunt", 20 + level / 3 );
   thing->add_ac( "sharp", "sharp", 50 + level );
   thing->add_ac( "pierce", "pierce", 60 + 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "claws" );
   thing->remove_attack( "bite" );
   thing->add_attack( "claws", 50, ({ ( 5 * number ) / 2, 8, 2 * number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "bite", 100, ({ 3 * number, 10, ( 3 * number ) / 2 }),
      "pierce", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/wombat.c
==================================================

inherit "/std/races/base";
void setup() {
   set_name( "wombat" );
   set_long( "One of several stocky marsupials (family Vombatidae) "
      "resembling small bears.\n" );
   set_height( 40 );
   set_weight( 600 );
   set_desc( "a stocky wombat, looking for something to nibble" );
   bits = ({
      "head", "head", ({ 0, 100, 0,
         "left eye", "right eye", "left ear", "right ear", "skull" }),
      "left eye", "eye", ({ "head", 1, 0 }),
      "right eye", "eye", ({ "head", 1, 0 }),
      "left ear", "ear", ({ "head", 15, 0 }),
      "right ear", "ear", ({ "head", 15, 0 }),
      "skull", "skull", ({ "head", 50, 0, "teeth", "brain" }),
      "brain", "brain", ({ "skull", 30, 0 }),
      "teeth", "teeth", ({ "skull", 1, ({"/std/bit_set", 1}), "tooth" }),
      "tooth", "tooth", ({ "teeth", 1, ({"/std/bit", 18}) }),
      "torso", "torso", ({ 0, 450, 0,
         "heart", "liver", "left kidney", "right kidney", "spleen",
         "right lung", "left lung", "intestine" }),
      "heart", "heart", ({ "torso", 20, 0 }),
      "liver", "liver", ({ "torso", 20, 0 }),
      "left kidney", "kidney", ({ "torso", 10, 0 }),
      "right kidney", "kidney", ({ "torso", 10, 0 }),
      "spleen", "spleen", ({ "torso", 10, 0 }),
      "right lung", "lung", ({ "torso", 20, 0 }),
      "left lung", "lung", ({ "torso", 20, 0 }),
      "intestine", "gut", ({ "torso", 50, 0 }),
      "genitals", "genitals", ({ 0, 5, 0 }),
      "left front leg", "leg", ({ 0, 150, 0, "left front paw" }),
      "left front paw", "paw", ({ "left front leg", 25, 0 }),
      "right front leg", "leg", ({ 0, 150, 0, "right front paw" }),
      "right front paw", "paw", ({ "right front leg", 25, 0 }),
      "left rear leg", "leg", ({ 0, 150, 0, "left rear paw" }),
      "left rear paw", "paw", ({ "left rear leg", 25, 0 }),
      "right rear leg", "leg", ({ 0, 150, 0, "right rear paw" }),
      "right rear paw", "paw", ({ "right rear leg", 25, 0 }),
      "tail", "tail", ({ 0, 25, 0 }),
      "skin", "skin", ({ 0, 175, 0 })
   });
   inedible = ({ "skull", "teeth", "tail", "skin" });
   unrottable = ({ "skull", "teeth" });
   set_skin( "fur" );
   set_stats( ({ 2, 4, -2, 6, -4 }) );
}
void new_set_level( mixed *args ) {
   int level;
   object thing;
   if( sizeof(args) < 2 || !args[1] )
      return;
   level = args[ 0 ];
   thing = args[ 1 ];
   level = 1 + ( 2 * level + random( level ) ) / 10;
   thing->add_ac( "blunt", "blunt", level );
   thing->add_ac( "sharp", "sharp", 2 + level );
   thing->add_ac( "pierce", "pierce", 2 * level );
}
void set_unarmed_attacks( object thing ) {
   int number;
   number = (int)thing->query_skill_bonus( "fighting.combat.melee.unarmed" );
   number = 4 + sqrt( number ) / 2;
   thing->remove_attack( "hands" );
   thing->remove_attack( "feet" );
   thing->remove_attack( "chew" );
   thing->remove_attack( "claws" );
   thing->add_attack( "chew", 100, ({ 3 * number, 0, number }),
      "sharp", "unarmed", 0 );
   thing->add_attack( "claws", 50, ({ ( 3 * number ) / 2, number, number }),
      "sharp", "unarmed", 0 );
   thing->tactics( "response dodge" );
}

==================================================
FILE: races/shadows/fish_shadow.c
==================================================

object my_player;
void init_shadow(object ob) {
  my_player = ob;
  shadow(ob, 1);
}
int query_ac(string type, int dam) {
  int i;
  i = (int)my_player->query_ac(type);
  if (environment(my_player)->query_underwater())
    return i*100;
  return i;
}
int move(object ob, string s1, string s2) {
  int i;
  i = (int)my_player->move(ob, s1, s2);
  if (!i && !ob->query_underwater())
    call_out("do_drown", 2);
  else
    remove_call_out("do_drown");
  return i;
}
void do_drown() {
  tell_room(my_player, my_player->one_short()+" gasps for air.\n");
  my_player->adjust_hp(random(50)+50);
  call_out("do_drown", 2);
}
