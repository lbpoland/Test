
==================================================
FILE: misc/eel_skin.c
==================================================

inherit "/std/object";
void setup()
{
  set_name( "skin" );
  set_short( "eel skin" );
  add_adjective( "eel" );
  set_main_plural( "eel skins" );
  set_long( "This is the skin of an eel.  It is very greasy and "
        "glistens prettily when you tilt it towards the light.\n" );
  set_weight( 3 );
  set_value( 100 );
}

==================================================
FILE: misc/envelope.c
==================================================

#define SMALL   3
#define MEDIUM  5
#define LARGE   8
#define UNSEALED  1
#define SEALED    2
#define OPENED    3
inherit "/obj/baggage";
nosave int status;
void make_envelope( string description, int size ) {
   string adjective, noun;
   if( size < 2 )
      size = 2;
   switch( size ) {
      case 0..SMALL:
         adjective = "small";
         noun = "envelope";
         break;
      case SMALL + 1..MEDIUM:
         adjective = "medium sized";
         noun = "envelope";
         break;
      case MEDIUM + 1..LARGE:
         adjective = "large";
         noun = "envelope";
         break;
      default:
         adjective = "large";
         noun = "packet";
         add_alias("packet");
   }
   set_name( "envelope" );
   set_short( adjective + " " + description + " " + noun );
   add_adjective( adjective );
   add_adjective( explode( description, " " ) );
   set_long( "This is a " + adjective + " " + description + " envelope.  " );
   set_weight( 1 );
   set_value( 300 + size * 20 );
   set_max_weight( size );
   set_material( "paper" );
   add_property( "writeable", 1 );
   add_extra_look( this_object() );
   status = UNSEALED;
}
void init() {
   ::init();
   this_player()->add_command( "seal", this_object(),
      "<direct:object:me>" );
   this_player()->add_command( "unseal", this_object(),
      "<direct:object:me>" );
}
string long( string str, int dark ) {
   string desc;
   switch( status ) {
   case UNSEALED :
      desc = "It has a sticky flap at one end with which you could "
         "probably seal it if you wanted to, though it might be wise to put "
         "something into it first or you're going to feel rather silly.\n";
      break;
   case SEALED :
      desc = "The sticky flap seems to have been sealed down.\n";
      break;
   case OPENED :
      desc = "It looks like it has been sealed and then opened up.\n";
      break;
   default :
      desc = "It is completely broken - you'd better tell a liaison.\n";
   }
   return ::long( str, dark ) + desc;
}
int do_seal() {
   if( status != UNSEALED ) {
      return notify_fail( this_object()->the_short() + " has already been "
         "sealed.\n" );
   }
   do_close();
   set_stuck( 1 );
   status = SEALED;
   this_player()->add_succeeded_mess( this_object(), "$N lick$s the flap on "
      "$D and seal$s it down.\n", ({ }) );
   return 1;
}
int do_unseal() {
   if( status != SEALED ) {
      return notify_fail( this_object()->the_short() + " has not been "
         "sealed.\n" );
   }
   set_stuck( 0 );
   do_open();
   status = OPENED;
   this_player()->add_succeeded_mess( this_object(), "$N tear$s back the "
      "flap on $D and open$s it.\n", ({ }) );
   return 1;
}
int query_envelope_status() {
   return status;
}
mixed *stats() {
   return ::stats() + ({
      ({ "status", status, }),
   });
}
mapping int_query_static_auto_load() {
   return ([
      "::" : ::int_query_static_auto_load(),
      "status" : status,
   ]);
}
void init_static_arg( mapping map ) {
   if( map["::"] )
      ::init_static_arg( map["::"] );
   if( !undefinedp( map["status"] ) )
      status = map["status"];
}
mixed query_static_auto_load() {
   if( base_name( this_object() ) + ".c" == __FILE__ )
      return int_query_static_auto_load();
   return ([ ]);
}

==================================================
FILE: misc/fire_cracker.c
==================================================

inherit "/std/object";
#define EFFECT "/w/dogbolter/cracker_eff"
#define DURATION 180
void setup() {
    set_name( "firecracker" );
    add_alias( "cracker" );
    add_adjective( "fire" );
    add_plural( "crackers" );
    set_short( "fire cracker" );
    set_long( "This is a large red fire cracker of Auriental manufacture"
      ".  It's the sort of thing that is thrown at weddings.  You may "
      "'light' it, and 'throw' it.\n" );
    set_weight( 2 );
    set_value( 500 );
    set_read_mess("ACME Firecracker", "agatean");
}
void explosion() {
    object victim;
    if( !environment() )
        return;
    if( living( environment() ) ) {
        victim = environment();
        tell_object( environment(), "%^BOLD%^%^RED%^$C$"+ the_short()
          +" explodes in your face!\nMeep meep!%^RESET%^\n" );
        environment()->add_effect (EFFECT, DURATION);
        if( environment( environment() ) ) {
            tell_room( environment( environment() ), "%^BOLD%^%^RED%^$C$"+
              the_short() +" explodes in "+
              environment()->the_short() +"'s face!\nMeep meep!%^RESET%^\n",
              environment() );
        }
    } else {
        tell_room( environment(), "%^BOLD%^%^RED%^$C$"+ the_short()
          +" explodes!%^RESET%^\n" );
    }
    move( "/room/rubbish" );
}
int do_light() {
    call_out( (: explosion :), 10 );
    add_succeeded_mess( "$N $V $D and smoke begins to pour out.\n",
      ({ }) );
    return 1;
}
int do_throw() {
    if( environment() && environment( environment() ) ) {
        add_succeeded_mess( "$N $V $D on the ground.\n", ({ }) );
        move( environment( environment() ) );
        return 1;
    } else {
        add_failed_mess( "There is no ground to $V $D on.  How very odd\n",
          ({ }) );
        return 0;
    }
}
void init() {
    add_command( "light", "<direct:object:me>", (: do_light :) );
    add_command( "throw", "<direct:object:me>", (: do_throw :) );
}
string query_death_reason() {
    return "being blown up by a fire cracker, in true Road Runner Style.\n"
    "%^BOLD%^Meep meep!%^RED%^";
}

==================================================
FILE: misc/football.c
==================================================

inherit "/std/object";
string me, him;
void setup() {
     set_name("football");
     set_short("leather football");
     add_adjective("leather");
     add_alias("ball");
     set_long("This is a leather football, pumped up hard.  Looks like you could"
             " kick it to people.\n");
     set_weight(10);
     set_value(1);
     add_plural("footballs");
     add_plural("balls");
}
void init() {
  this_player()->add_command("kick", this_object(),
        "<direct:object:me> to <indirect:player>");
  add_command( "kickup", "<direct:object>" );
}
int do_kickup()  {
   write( "You kick the football into the air a few times, stopping it from "
   "hitting the floor by bouncing it off your knee, your chest and your feet."
   "  A rare display of skill!\n" );
tell_room( environment( this_player() ),
     this_player()->query_cap_name() + " expertly kicks the ball into the "
     "air, heads it back up, bounces it a few times on their chest and displays "
     "an uncanny level of skill.\n", this_player());
   return 1;
}
int do_kick(object *in_dir) {
  if (!sizeof(in_dir))
    return 0;
  if (move(in_dir[0])) {
    tell_object(in_dir[0], this_player()->query_cap_name()+" kicks "+
        this_object()->query_short()+" at you, but it falls on the floor.\n");
    tell_room(environment(in_dir[0]), "A leather football flies "
        "through the air, "+ in_dir[0]->query_name()+" tries to trap it "
        "but fails and it lands next to them.", ({ in_dir[0], this_player() }) );
    move(environment(in_dir[0]));
  } else {
    tell_object(in_dir[0], this_player()->query_cap_name()+" kicks a "
           "leather football at you.  It curls towards you at speed but you "
           "manage to " +
           ({ "trap it with your foot.",
           "bounce it off your chest and trap it underfoot.",
           "head it to the ground, juggle it a few times and eventually stand"
           " on it",
           "catch it. HANDBALL!",
           "look like the famous footballer Fele and trap it.",
           "trap it easily.  You should sign up for Ankh Morpork Wanderers."})
           [random (6) ]+"\n");
    tell_room(environment(in_dir[0]), "A leather football curls "
           "gracefully towards "+ in_dir[0]->query_cap_name()+", who "+
                "manages to "+
                ({ "trap it with their foot.",
           "bounce it off their chest and trap it underfoot.",
           "head it to the ground, juggle it a few times and eventually stands"
           " on it",
           "catches it. HANDBALL!",
           "look like the famous footballer Fele and trap it.",
           "trap it easily.  They should sign up for Ankh Morpork Wanderers."})
           [random (6) ]+
                "\n",
          ({ in_dir[0], this_player() }));
  }
  this_player()->add_succeeded(in_dir[0..0]);
  return 1;
}

==================================================
FILE: misc/football.s
==================================================



==================================================
FILE: misc/fountain.c
==================================================

#include <volumes.h>
#define FOUNTAIN_SIZE 150000
#define DEFAULT_CYCLE_TIME 60 * ( 2 + random( 2 ) )
inherit "/obj/vessel";
string _liquid_path;
int _liquid_volume;
int _time;
void setup() {
  set_name( "fountain" );
  set_short( "fountain" );
  set_long( "This is a fountain.\n" );
  set_max_volume( FOUNTAIN_SIZE );
  set_weight( 100000 );
  set_stuck( 1 );
}
varargs void initialise( string path, int amount, int time) {
  if ( !stringp( path ) )
    error( "Path not set in initialise.\n" );
  if ( !intp( amount ) )
    amount = VOLUME_LITRE;
  if ( !time )
    time = DEFAULT_CYCLE_TIME;
  _liquid_path = path;
  _liquid_volume = amount;
  _time = time;
  call_out( "make_water", 5 );
  return;
}
varargs void reinitialise( string path, int amount, int time) {
  if ( !stringp( path ) )
    error( "Path not set in initialise.\n" );
  if ( !intp( amount ) )
    amount = VOLUME_LITRE;
  if ( !time )
    time = DEFAULT_CYCLE_TIME;
  _liquid_path = path;
  _liquid_volume = amount;
  _time = time;
  return;
}
void make_water() {
object water;
  if ( !( query_max_volume() - query_volume() ) ) {
    tell_room( environment(), sprintf( "Some of the %s in %s sloshes over the sides.\n",
      query_multiple_short( all_inventory() ), this_object()->the_short() ) );
    remove_volume( -VOLUME_QUART * random( 4 ) * 2 );
  }
  water = clone_object( _liquid_path );
  water->set_amount( _liquid_volume );
  call_out( (: $(water)->move( this_object() ) :), 1 );
  switch( water->query_amount() ) {
	case 0 .. VOLUME_SHOT:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
  	  water->a_short(), ({ "trickles", "seeps", "dribbles" })[random(3)],
	  this_object()->the_short() ) );
      break;
    case VOLUME_SHOT + 1 .. VOLUME_PINT:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
		water->a_short(),  ({ "flows", "splashes", "pours" })[random(3)],
		this_object()->the_short() ) );
      break;
    case VOLUME_PINT + 1 .. VOLUME_LITRE:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
		water->a_short(), ({ "streams", "cascades", "sloshes" })[random(3)],
		this_object()->the_short() ) );
      break;
    case VOLUME_LITRE + 1 .. VOLUME_QUART:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
	    water->a_short(), ({ "gushes", "courses", "swirls" })[random(3)],
        this_object()->the_short() ) );
      break;
    default:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
        water->a_short(), ({ "floods", "surges", "washes" })[random(3)],
  	    this_object()->the_short() ) );
      break;
  }
  call_out( "make_water", _time );
}

==================================================
FILE: misc/frisbee.c
==================================================

inherit "/std/object";
string me, him;
void setup() {
  set_name("frisbee");
  set_short("black frisbee");
  add_adjective("black");
  set_long("This is a small black frisbee.  It looks like you could "
           "throw it to "
           "people.\n");
  add_property("feeding_frenzy", "frisbee");
  set_weight(10);
  set_value(200);
  set_main_plural("black frisbees");
  add_plural("frisbees");
}
void init() {
  this_player()->add_command("throw", this_object(),
                             "<direct:object:me> to <indirect:player>");
}
int do_throw(object *in_dir) {
  if (!sizeof(in_dir))
    return 0;
  if (move(in_dir[0])) {
    tell_object(in_dir[0], this_player()->one_short()+" throws "+
                this_object()->short()+" at you, but it falls on the floor.\n");
    tell_room(environment(in_dir[0]), "A frisbee arcs through the air, "+
              in_dir[0]->query_name()+" tries to catch it but fails and it "+
              "falls on the floor.\n", ({ in_dir[0], this_player() }) );
    move(environment(in_dir[0]));
  } else {
    tell_object(in_dir[0], this_player()->one_short()+" throws a frisbee "+
                "at you, you catch it... just.\n");
    tell_room(environment(in_dir[0]), in_dir[0]->one_short()+
          " fumbles the catch of the "+
          short(0)+" but manages to keep hold of it.\n",
          ({ in_dir[0], this_player() }));
  }
  this_player()->add_succeeded(in_dir[0..0]);
  return 1;
}

==================================================
FILE: misc/glass.c
==================================================

inherit "/obj/vessel";
nosave string description, actual_drink, actual_glass_size;
void create() {
    do_setup++;
    ::create();
    do_setup--;
    set_name("glass");
    set_weight(1);
    set_value(400);
    set_stuck(1);
    set_leak_rate(0);
    set_material("glass");
    add_property("fragile", 200);
    if (!do_setup) {
        this_object()->setup();
    }
}
void make_glass(string drink, string glass_description, string glass_size,
   int amount, int has_contents)
{
    string *glass_adjectives;
    object contents;
    description = glass_description;
    actual_drink = drink;
    actual_glass_size = glass_size;
    glass_adjectives = explode( glass_size, " " )[0..<2];
    set_short( glass_size );
    set_long( (: this_object()->query_volume() ? description : "This is "
        "a dirty " + actual_glass_size + ", one that used to hold some "
        " " + actual_drink + ".\n" :) );
    glass_adjectives = explode( glass_size, " " );
    if (sizeof(glass_adjectives) > 1)
        add_alias(glass_adjectives[<1..]);
    else
        add_alias(glass_size);
    add_adjective(glass_adjectives);
    set_max_volume(amount);
    if (has_contents) {
        contents = clone_object("/obj/reagents/generic_liquid.ob");
        contents->set_name("drink");
        contents->set_short(drink);
        contents->set_long("This is some delicious looking " + drink + ".\n" );
        contents->add_adjectives(explode(drink, " ")[0..<2]);
        contents->add_alias( explode( drink, " " )[ sizeof(
           explode( drink, " " ) ) - 1 ] );
        contents->set_amount(amount);
        contents->move(this_object());
    }
}
mapping int_query_static_auto_load() {
    return ([
        "::": ::int_query_static_auto_load(),
        "description": description,
        "actual_drink" : actual_drink,
        "actual_glass_size" : actual_glass_size,
    ]);
}
void init_static_arg(mapping map) {
    if (map["::"])
        ::init_static_arg(map["::"]);
    if (!undefinedp(map["description"]))
        description = map["description"];
    if (!undefinedp(map["actual_drink"]))
        actual_drink = map["actual_drink"];
    if (!undefinedp(map["actual_glass_size"]))
        actual_glass_size = map["actual_glass_size"];
    set_long((: this_object()->query_volume() ? description : "This is "
        "a dirty " + actual_glass_size + ", one that used to hold some "
        "sort of " + actual_drink + ".\n" :));
}
mixed query_static_auto_load() {
    if (base_name(this_object()) == "/obj/misc/glass" )
        return int_query_static_auto_load();
    return ([ ]);
}

==================================================
FILE: misc/golem_corpse.c
==================================================

#include <armoury.h>
inherit "/obj/container";
void make_fragments();
void setup() {
    set_name( "rubble" );
    set_short( "heap of clay rubble" );
    add_alias( ({"heap", "clay"}) );
    add_adjective( ({"heap of", "clay"}) );
    set_main_plural( "heaps of clay rubble" );
    add_plural( "heaps" );
    set_weight( 40000 );
    set_max_weight( 50000 );
    set_value( 0 );
    set_stuck( 1 );
    make_fragments();
    add_property( "no recycling", 1 );
}
void make_fragments() {
    int amount = random( 8 );
    int i;
    for( i = 1; i <= amount; i++ )
        switch( random( 11 ) ) {
           case 0..5:
               ARMOURY->request_item( "golem shard", 100 )->
                   move( this_object() );
               break;
           case 6..7:
               ARMOURY->request_item( "golem finger", 100 )->
                   move( this_object() );
               break;
           case 8..9:
               ARMOURY->request_item( "golem toe", 100 )->
                   move( this_object() );
               break;
           case 10:
               ARMOURY->request_item( "golem eye", 100 )->
                   move( this_object() );
               break;
        }
}
string long( string word, int dark ) {
    string inv = query_multiple_short( all_inventory( this_object() ) );
    string tmp = "";
    switch( sizeof( all_inventory( this_object() ) ) ) {
        case 0:
           break;
        case 1:
            tmp = "Something that looks like " + inv + " protrudes from it.  ";
            break;
        default:
            tmp = "It looks like " + inv + " are buried in it.  ";
    }
    return "This is a large heap of shattered clay.  " + tmp + "Whatever this "
        "was before, it is destroyed thouroughly and beyond any means of "
        "repair.\n";
}

==================================================
FILE: misc/golem_eye.c
==================================================

inherit "/std/object";
void setup() {
    set_name( "triangle" );
    set_short( "clay triangle" );
    add_adjective( ({"clay"}) );
    set_long( "This is a cracked piece of clay.  A hole in the shape of a "
       "triangle is in its middle.\n" );
    set_main_plural( "clay triangles" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
}

==================================================
FILE: misc/golem_finger.c
==================================================

inherit "/std/object";
void setup() {
    set_name( "fingertip" );
    set_short( "broken clay fingertip" );
    add_adjective( ({"broken", "clay"}) );
    set_long( "This looks like a crude fingertip made of clay.  It is broken "
       "in the middle.\n" );
    set_main_plural( "broken clay fingertips" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
}

==================================================
FILE: misc/golem_shard.c
==================================================

inherit "/std/object";
void setup() {
    set_name( "shard" );
    set_short( "cracked clay shard" );
    add_adjective( ({"clay"}) );
    set_long( "This is a heavily cracked clay shard." );
    set_main_plural( "cracked clay shards" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
}

==================================================
FILE: misc/golem_toe.c
==================================================

inherit "/std/object";
void setup() {
    set_name( "toe" );
    set_short( "remains of a clay toe" );
    add_adjective( ({"remains", "of", "a", "clay"}) );
    set_long( "This looks part of a toe made of clay.\n" );
    set_main_plural( "remains of clay toes" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
    add_property( "determinate", "the " );
}

==================================================
FILE: misc/grinder.c
==================================================

#include <move_failures.h>
#define STATE_CHANGE "/obj/handlers/state_change"
inherit "/obj/container";
int test_add(object ob, int flag);
int do_grind( string what );
int do_empty(object *dest, string me, string him, string prep);
void set_max_grindable( int i );
int query_max_grindable();
string long_status();
private int _max_grind = 0;
void setup() {
  set_name( "grinder" );
  set_short( "food grinder" );
  add_adjective( "food" );
  set_main_plural( "food grinders" );
  set_long( "This is a mechanical contraption to grind food into small "
      "pieces.  There is a funnel-type piece at the top, a crank on one "
      "side and on the other a pipe where the ground food comes out and "
      "is caught in a small tray.\n" );
  set_value( 4000 );
  set_weight( 100 );
  set_max_weight( 100 );
}
void init() {
  this_player()->add_command( "grind", this_object(),
      "<string'object'> in <direct:object'" + query_short() + "'>",
      (: do_grind( $4[0] ) :) );
  add_command( "empty", "<direct:object>" );
}
int test_add(object ob, int flag) {
  object stuff = first_inventory();
  if (stuff) {
    add_failed_mess( "There is already some " + stuff->query_short()
      + " in the grinder.  You'll have to empty it first.\n");
    return 0;
  } else return 1;
}
int do_grind( string what ) {
  object *things, thing;
  object ground;
  object contents;
  things = match_objects_for_existence( what, ({ this_object(),
                                                 this_player() }) );
  if( !sizeof( things ) ) {
    add_failed_mess( "You must be holding something or put it in $D in "
                     "order to $V it.\n" );
    return -1;
  }
  thing = things[0];
  if( ( contents = first_inventory() ) && contents != thing ) {
    add_failed_mess( "$D isn't empty.\n" );
    return -1;
  }
  if( query_max_grindable() &&
      ( thing->query_amount() > query_max_grindable() ||
        thing->query_weight() > query_max_grindable() ) ) {
    add_failed_mess( "You cannot grind that much with $D at once.\n" );
    return -1;
  }
  ground = STATE_CHANGE->transform( thing, "grind" );
  if ( !objectp( ground ) ) {
    add_failed_mess( "You cannot $V $I in $D.\n", ({ thing }) );
    return -1;
  }
  thing->move( "/room/rubbish" );
  if( ground->move( this_object() ) != MOVE_OK ) {
    ground->move( environment( this_player() ) );
    add_succeeded_mess( "$N grind$s $I with $D, spilling it onto the " +
        ( environment( this_player() )->query_property( "location" ) ==
        "inside" ? "floor" : "ground" ) + ".\n" );
    return 1;
  }
  this_player()->add_succeeded_mess( this_object(), "$N grind$s $I "
    "in $D.\n", ({ thing }) );
  return 1;
}
int do_empty(object *dest, string me, string him, string prep) {
  object ground = first_inventory( this_object() );
  if( !ground ) {
    add_failed_mess( "There is nothing in $D.\n" );
    return 0;
  }
  if( ground->move( this_player() ) != MOVE_OK ) {
    ground->move( environment( this_player() ) );
    add_succeeded_mess( "$N $V $D onto the " +
        ( environment( this_player() )->query_property( "location" ) ==
        "inside" ? "floor" : "ground" ) + ".\n" );
    return 1;
  }
  return 1;
}
void set_max_grindable( int i ) { _max_grind = i; }
int query_max_grindable() { return _max_grind; }
string long_status() { return ""; }

==================================================
FILE: misc/housing_creator.c
==================================================

inherit "/std/object";
#include <housing.h>
#define ORIENTATION ({ "north", "northeast", "east", "southeast", "south", "southwest", "west", "northwest", "up" })
#define OPP_ORIENTATION ({ "south", "southwest", "west", "northwest", "north", "northeast", "east", "southeast", "down" })
#define PATH "/std/houses/"
int do_create(string type, string orientation, string location, string out,
              string region, string address, int overwrite,
              int test);
string list_plans();
void setup() {
  set_name("ball");
  set_short("small jade ball");
  add_adjective(({"small", "jade"}));
  set_long("This non-descript jade ball can be used to make player houses.\n");
  set_read_mess((: list_plans() :));
  set_weight(1);
  set_value(0);
  seteuid("Room");
}
void init() {
  this_player()->add_command("make", this_object(),
           "<word'floor plan'> <word'orientation'> "
           "<word'location'> <word'outside'> <word'region'> <string:quoted'address'>",
           (: do_create($4[0], $4[1], $4[2], $4[3], $4[4], $4[5], 0, 1) :) );
  this_player()->add_command("makereal", this_object(),
           "<word'floor plan'> <word'orientation'> "
           "<word'location'> <word'outside'> <word'region'> <string:quoted'address'>",
           (: do_create($4[0], $4[1], $4[2], $4[3], $4[4], $4[5], 0, 0) :) );
  this_player()->add_command("maketest", this_object(),
           "<word'floor plan'> <word'orientation'> "
           "<word'location'> <word'outside'> <word'region'> <string:quoted'address'>",
           (: do_create($4[0], $4[1], $4[2], $4[3], $4[4], $4[5], 1, 1) :) );
}
string list_plans() {
  string ret, str;
  string plan;
  ret = "To create a house use:\n"
    "  'make <floor plan> <orientation> <location> <outside> <region>\n"
    "        <address>' where:\n"
    "  'makereal <floor plan> <orientation> <location> <outside> <region>\n"
    "        <address>' where:\n"
    "  'makeforce <floor plan> <orientation> <location> <outside> <region>\n"
    "        <address>' where:\n"
    "  floor plan is one of the standard floor plans\n"
    "  orientation is its orientation (ie. the direction you enter it to)\n"
    "  location is the directory to write the houses files into\n"
    "  address is a the unique address for the house\n"
    "  region is the region of the house\n"
    "The 'makereal' command will add the house into the housing handler, "
    "the 'make' command will do a normal test make and the 'makeforce' "
    "will overwrite any existing housing files.\n\n"
    "Example:\n"
    "$I$5=   makereal twobedhouse south /d/am/fluff/housing OUT+room1 am \"12 Fluff Street\"\n\n$I$0="
    "The following floorplans are available:\n";
  str = "";
  foreach(plan in get_dir(PATH + "*")) {
    if(plan != "." && plan != ".." && file_size(PATH + plan) == -2 )
      str += plan + "\n";
  }
  ret += sprintf("%-#*s", this_player()->query_cols(), str);
  return ret;
}
int do_create(string type, string orientation, string location, string out,
              string region, string address, int overwrite,
              int test) {
  string room;
  string tmp;
  string fname;
  mapping files;
  mapping main_file;
  string number;
  int orient;
  int i;
  if(file_size(PATH+type) != -2) {
    return notify_fail("No such floor plan\n");
  }
  orient = member_array(orientation, ORIENTATION);
  if(orient == -1) {
    return notify_fail("No such orientation.\n");
  }
  if(file_size(location) != -2) {
    return notify_fail("No such location.\n");
  }
  if (address[0] < '0' || address[0] > '9') {
     add_failed_mess("Address must start with a number.\n");
     return 0;
  }
  i = 0;
  do {
     i++;
  } while (address[i] != ' ');
  number = address[0..i-1];
  address = address[i..];
  if (out[0] == '/') {
     if (out[<2..] == ".c") {
        out = out[0..<3];
     }
     out = "\"" + out + "\"";
  } else {
     if (member_array('+', out) == -1) {
        out = "PATH+\"" + out + "\"";
     }
  }
  files = ([ ]);
  main_file = ([ ]);
  if (type[<1] != 'M') {
     main_file[""] = 0;
  }
  foreach(room in get_dir(PATH+type+"

==================================================
FILE: misc/ink_well.c
==================================================

inherit "/obj/container";
void create() {
  ::create();
  set_name("well");
  add_adjective("ink");
  set_short("ink well");
  set_long("A nice, small ink well.\n");
  set_value( 500 );
  set_leak_rate(0);
  set_max_volume(250);
  set_volume(200);
  set_water_volume(200);
  set_ps_coord_quantity((int *)"/std/effects/other/ink"->query_coordinate(), 200);
}

==================================================
FILE: misc/juicer.c
==================================================

#include  <bit.h>
inherit "/obj/vessel";
int juice_bit( object ob, string fn );
mapping juice_funs = ([
  "/std/bit" : (: juice_bit :),
]);
void setup() {
  set_name( "juicer" );
  set_short( "juicer" );
  set_main_plural( "juicers" );
  set_long( "This is a device for extracting the juice or liquid from " +
            "objects.  It has a hole at the top for inserting things, " +
            "and a small bowl at the bottom to catch the juice.  You " +
            "could probably \"juice\" something and then \"pour\" " +
            "the juicer into another container.\n" );
  set_value( 4000 );
  set_weight( 100 );
  set_max_volume( 19200 );
}
void init() {
  ::init();
  this_player()->add_command( "juice", this_object(), "%I 'in' %D" );
}
int do_juice( object *things ) {
  int i, amount, *weight_unit, percent;
  string medium_short, *types, fn;
  mapping amount_types;
  if ( living( environment() ) ) {
    this_player()->add_failed_mess( this_object(), "You have to put down "+
        "$D to use it.\n", ({ }) );
    return 0;
  }
  for ( i = 0; i < sizeof( things ); i++ )
    if ( environment( things[ i ] ) != this_player() ) {
      things = delete( things, i, 1 );
      i--;
    }
  if ( !sizeof( things ) ) {
    this_player()->add_failed_mess( this_object(), "You should be carrying "+
        "whatever you want to $V in $D", ({ }) );
    return 0;
  }
  if ( sizeof( things ) > 1 ) {
    this_player()->add_failed_mess( this_object(), "You should only $V "+
        "one thing at a time in $D in case they get mixed up.\n", ({ }) );
    return 0;
  }
  if ( !function_exists( "query_continuous", things[ 0 ] ) ) {
    if ( fn = things[ 0 ]->query_property("juice")
        && functionp( juice_funs[ fn ] )) {
      return evaluate( juice_funs[ fn ], things[ 0 ], fn );
    }
    fn = explode(file_name(things[ 0 ]), "#")[ 0 ];
    if (functionp( juice_funs[ fn ] )) {
      return evaluate( juice_funs[ fn ], things[ 0 ], fn );
    }
    this_player()->add_failed_mess( this_object(), "You cannot $V $I "+
        "in $D.  Trust me on this.\n", ({ things[ 0 ] }) );
    return 0;
  }
  if ( !(percent = things[ 0 ]->query_property("%liquid")) ) {
    this_player()->add_failed_mess( this_object(), "$I apparently doesn't " +
        "contain much juice.\n", ({ things[ 0 ] }) );
    things[ 0 ]->move("/room/rubbish");
    return 0;
  }
  things[ 0 ]->add_plural( (string)things[ 0 ]->query_name() );
  if ((amount = (int)things[ 0 ]->query_amount()) == 0) {
    weight_unit = (int *)things[ 0 ]->query_weight_unit();
    amount = ( weight_unit[ 1 ] * (int)things[ 0 ]->query_weight() ) /
      weight_unit[ 0 ];
    amount = ( ( 50 + random( 21 ) ) * amount ) / 80;
  }
  things[ 0 ]->set_amount( amount*percent/100 );
  things[ 0 ]->set_weight_per_bite( 0 );
  things[ 0 ]->set_bites_gone( 0 );
  medium_short = (string)things[ 0 ]->query_medium_short();
  if ( !medium_short )
    medium_short = (string)things[ 0 ]->query_short();
  if ( !things[ 0 ]->query_medium_alias() )
    things[ 0 ]->set_medium_alias( "Ground"+ capitalize( medium_short ) );
  amount_types = ([ "drop" : ({ 1, "drops" }), "ounce" :
        ({ 120, "ounces" }), "pint" : ({ 2400, "pints" }) ]);
  things[ 0 ]->set_amount_types( amount_types );
  types = m_indices( amount_types );
  for ( i = 0; i < sizeof( types ); i++ )
    things[ 0 ]->add_adjective( ({ types[ i ],
        amount_types[ types[ i ] ][ 1 ] }) );
  things[ 0 ]->add_adjective( "of" );
  if ( !sizeof( (mixed *)things[ 0 ]->query_pile_types() ) )
    things[ 0 ]->set_pile_types( ({ 50, "small", 2400, "medium", 19200,
        "large", "huge" }) );
  things[ 0 ]->add_property( "determinate", "some " );
  things[ 0 ]->grind();
  things[ 0 ]->move( this_object() );
  this_player()->add_succeeded_mess( this_object(), "$N $V $D to make $I.\n",
      ({ things[ 0 ] }) );
  return 1;
}
int juice_bit( object ob, string fn ) {
    object juice_ob;
    mixed *bit_data;
    string *m, s;
    int i;
    juice_ob = clone_object("/obj/reagents/generic_liquid.ob");
    juice_ob->set_name("juice");
    if (s = ob->query_race_name())
      s = capitalize(s);
    bit_data = ob->query_bit_data();
    m = explode(bit_data[ BIT_NAME ], " ");
    for ( i = 0; i < sizeof(m); i++ )
      s += capitalize(m[i]?m[i]:"");
    juice_ob->set_medium_alias(s+"Juice");
    switch ( bit_data[ BIT_ALIAS ] ) {
      case "eye":
        juice_ob->add_adjective("eye");
        juice_ob->add_alias("ichor");
        juice_ob->set_short("clear liquid");
        juice_ob->set_long("This is a clear liquid, slightly tinged" +
                           "with blood.\n");
        juice_ob->set_amount(10*(int)ob->query_weight() + 10);
        break;
      default:
        juice_ob->set_short("liquid");
        juice_ob->set_long("This is a non-descript liquid.  It's probably " +
                           "useless.\n");
        break;
    }
    juice_ob->move(this_object());
    ob->move("/room/rubbish");
    this_player()->add_succeeded_mess( this_object(), "$N $V $D to make $I.\n",
                                      ({ juice_ob }) );
    return 1;
}

==================================================
FILE: misc/keyring.c
==================================================

inherit "/std/container";
void create() {
   do_setup++;
   container::create();
   set_name( "keyring" );
   set_short( "keyring" );
   add_property( "determinate", "a " );
   set_main_plural( "keyrings" );
   add_property("shop type", "jewellers");
   set_long( "This is a ring of metal that overlaps itself at one point, "
         "allowing keys to be strung onto it and be kept together.  It's "
         "amazing how useful a ring of metal can be.\n" );
   set_weight( 2 );
   set_value( 20 );
   set_max_weight( 1 );
   do_setup--;
   if (!do_setup)
      this_object()->setup();
}
string long( string word, int dark ) {
   return ::long( word, dark ) +
         query_contents( "$C$"+ the_short() +" holds: " );
}
mapping query_properties() {
   object thing;
   mixed arg, *args;
   mapping props, map;
   props = ::query_properties();
   args = copy( keys( props ) );
   foreach ( thing in find_inv_match( "", this_player() ) ) {
      map = (mapping)thing->query_properties();
      foreach ( arg in keys( map ) ) {
         if ( !stringp( arg ) ) {
            continue;
         }
         if ( member_array( arg, args ) != -1 ) {
            continue;
         }
         props[ arg ] = map[ arg ];
         args += ({ arg });
      }
   }
   return props;
}
mixed query_property( string word ) {
   object thing;
   mixed arg;
   arg = ::query_property( word );
   if ( arg ) {
      return arg;
   }
   foreach ( thing in find_inv_match( "", this_player() ) ) {
      arg = (mixed)thing->query_property( word );
      if ( arg ) {
         return arg;
      }
   }
   return 0;
}
int test_add( object thing, int flag ) {
   if ( !thing->id( "key" ) && environment( thing ) ) {
      return 0;
   }
   return 1;
}
int add_weight(int n) {
  int tmp, ret;
  if(sizeof(all_inventory(this_object())) >= 15)
    return 0;
  return ::add_weight(n);
}
mapping query_static_auto_load() {
   if ( explode( file_name(), "#" )[ 0 ] == "/obj/misc/keyring" ) {
      return int_query_static_auto_load();
   }
   return ([ ]);
}

==================================================
FILE: misc/label.c
==================================================

inherit "/std/object";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_name( "label" );
   set_short( "small label" );
   add_adjective( "small" );
   set_main_plural( "small labels" );
   set_long( "This is a small label made from paper with some sort of "+
         "dried glue smeared on one side.  You could probably \"stick\" "+
         "it onto something.\n" );
   set_value( 100 );
   add_property( "writeable", 1 );
   add_property( "label", 1 );
   set_max_size( 200 );
   if ( !do_setup )
      this_object()->setup();
}
void init() {
   this_player()->add_command( "stick", this_object(),
         "<direct:object:me> to <indirect:object>" );
}
int do_stick( mixed *things ) {
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can't stick $D to more than one thing at a time.\n");
      return 0;
   }
   if ( things[ 0 ] == this_object() ) {
      add_failed_mess("You cannott stick $D to itself!\n");
      return 0;
   }
   things[ 0 ]->add_effect( "/std/effects/object/label", this_object() );
   add_succeeded_mess("$N lick$s $D and stick$s it to $I.\n", things[0..0]);
   return 1;
}
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/misc/label" ) {
      return ([ ]);
   }
   return int_query_static_auto_load();
}

==================================================
FILE: misc/lantern.c
==================================================

inherit "/obj/lantern";
void setup() {
   fuel_left = 3600;
   is_lit    = 0;
   set_name( "lantern" );
   set_main_plural( "lanterns");
   set_short( "lantern" );
   add_help_file("torch");
   set_long(function() {
     string str;
     str = "This is a camping lantern, which smells of lamp oil.\n";
     if ( is_lit ) {
       return str + "The wick flickers inside spreading a dull "
         "glow.\n";
     }
     str += "The lantern is not lit, and ";
     if ( !fuel_left )
       return str + "is out of oil.\n";
     return str + "has some oil left in it.\n";
   } );
   set_weight( 60 );
   set_value( 150 );
}

==================================================
FILE: misc/lock.c
==================================================

inherit "/std/object";
#include <move_failures.h>
void create() {
  add_help_file("door_lock");
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void init() {
  this_player()->add_command("change", this_object(),
      "[lock in] <indirect:object:here'door or furniture'> for "
                             "<indirect:object:me'lock'>");
}
int do_change(mixed *in_dir, string direct, string indirect, mixed *args,
              string) {
  object lock;
  object ob;
  object item;
  object other;
  string other_id;
  item = in_dir[0][0];
  lock = in_dir[1][0];
  if(function_exists("query_my_room", item) &&
     (query_property("locktype") != "door"))
    return notify_fail("This lock is not suitable for a door.\n");
  if(item->query_furniture()) {
    switch(item->query_pick_skill()) {
    case "covert.lockpick.door":
      if(query_property("locktype") != "furniture")
        return notify_fail("This lock is not suitable for furniture.\n");
    case "covert.lockpick.safes":
      if(query_property("locktype") != "safe")
        return notify_fail("This lock is not suitable for safes.\n");
    }
  }
  if(function_exists("query_my_room", item) &&
     !function_exists("test_occupier", environment(this_player())))
    return notify_fail("You cannot change the locks here.\n");
  if(function_exists("test_occupier", environment(this_player())) &&
     !environment(this_player())->test_occupier(this_player()->query_name())
     && !this_player()->query_creator())
    return notify_fail("Sorry, only the owner of the house can change the "
                       "locks on items in the house.\n");
  if(!function_exists("pick_lock", item))
    return notify_fail("Sorry, that object can't take a lock.\n");
  if(!item->query_unlocked())
    return notify_fail("Sorry, the item must be unlocked in order to change "
                       "its lock.\n");
  if(!lock->query_property("key prop")) {
    this_player()->add_failed_mess(this_object(),
      "$I doesn't appear to have a key.\n", ({ lock }));
    return 0;
  }
  if(!lock->query_property("difficulty")) {
    this_player()->add_failed_mess(this_object(),
      "$I doesn't appear to have a difficulty.\n", ({ lock }));
    return 0;
  }
  item->set_key(lock->query_property("key prop"));
  item->set_difficulty(lock->query_property("difficulty"));
  item->set_lock_owner(environment(this_player())->query_owner());
  item->set_trap_armed(0);
  if(function_exists("query_my_room", item)) {
    other = load_object(item->query_dest());
    other_id = item->query_other_id();
    other->modify_exit(other_id, ({ "key", lock->query_property("key prop")}));
    other->modify_exit(other_id, ({ "difficulty",
                                      lock->query_property("difficulty")}));
    other->modify_exit(other_id, ({ "lock owner",
                                      environment(this_player())->query_owner()
                                      }));
    environment(this_player())->update_doors();
    other->update_doors();
    environment(this_player())->do_save();
    other->do_save();
  }
  ob = clone_object("/std/object");
  ob->set_name("lock");
  ob->set_short("busted lock");
  ob->add_adjective("busted");
  ob->set_main_plural("busted locks");
  ob->set_long("A broken door lock.\n");
  ob->set_value(0);
  ob->set_weight(lock->query_weight());
  ob->move(environment());
  if(lock->move("/room/rubbish") != MOVE_OK)
    lock->dest_me();
  this_player()->add_succeeded_mess(this_object(),
                                    "$N remove$s the existing, and now "
                                    "broken, lock from $I and replace$s it "
                                    "with the new one.\n", ({ item }));
  return 1;
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}

==================================================
FILE: misc/mailer_ob.c
==================================================

inherit "/std/object";
int do_mail(string str);
void setup() {
  set_name("mailer");
  set_short( "mailer object" );
  set_long("It is a small black box with pictures of small red demons "
           "painted on "+
           "the front.  Though, some of them look suspicously like frogs.\n");
  set_weight(1);
  reset_drop();
}
void init() {
  add_command("mail", "", (: do_mail(0) :) );
  add_command("mail", "<string>", (: do_mail($4[0]) :) );
}
int do_mail(string str) {
  return (int)"/obj/handlers/mail_track"->mail(str);
}

==================================================
FILE: misc/menu.c
==================================================

inherit "/std/object";
#include <language.h>
object our_pub;
void create() {
  ::create();
  set_name("menu");
  set_long("This is a menu.\n");
  reset_get();
}
void set_pub(object pub) {
  our_pub = pub;
  add_read_mess(our_pub->read(), "printed letters", our_pub->query_language());
}
object query_pub() { return our_pub; }
void init() {
  this_player()->add_command( "list", this_object(), "" );
}
string query_readable_message(object player) {
   string lang;
   string mess;
   mess = our_pub->read();
   lang = our_pub->query_language();
   mess = LANGUAGES->garble_text(lang, mess, this_object(), player);
   return mess;
}
int do_list() {
  write(query_readable_message(this_player()));
  add_succeeded_mess(({ "", "$N read$s $D.\n" }));
  return 1;
}

==================================================
FILE: misc/mortar_pestle.c
==================================================

inherit "/obj/misc/grinder";
void setup() {
  set_name( "pestle" );
  set_short( "mortar and pestle" );
  set_long( "Roughly hewn from stone, the mortar's bowl has been "
      "smoothed from long use.  The stone pestle used for grinding "
      "herbs within the bowl is smooth as well and hangs from a "
      "leather thong tied through a ring in the side of the bowl.\n" );
  set_main_plural( "mortars and pestles" );
  add_adjective( ({ "mortar and", "rough", "stone", "smooth" }) );
  add_alias( ({ "mortar", "pestle", "bowl" }) );
  set_value( 800 );
  set_weight( 44 );
  set_max_grindable( 8 );
  set_max_weight( 8 );
}

==================================================
FILE: misc/newspaper.c
==================================================

inherit "/std/book";
#include <room/newspaper.h>
#define AUTO_LOAD_TAG "newspaper"
private string _paper;
private int _edition;
void setup() {
  set_name("newspaper");
  set_short("newspaper");
  add_alias("paper");
  add_plural("papers");
  set_long("A bunch of nice newspapers.\n");
  set_main_plural("newspapers");
  set_weight(10);
  set_value(10);
  set_ignore_saved_pages(1);
}
int query_binding_force() {
  return 100;
}
void setup_paper() {
   class article* articles;
   class advert* adverts;
   class advert data;
   string* bits;
   int i;
   int j;
   string header;
   string index;
   string fluff;
   int page;
   mixed* stuff;
   object ob;
   if (_paper && _edition) {
      bits = explode(_paper, " ");
      if (bits[0] != "The") {
         set_short("copy of the " + _paper);
         add_adjective( ({ "the" }) );
         set_main_plural("copies of the " + _paper);
      } else {
         set_short("copy of " + _paper);
         set_main_plural("copies of " + _paper);
         add_plural_adjective("copies");
      }
      bits = map(bits, (: lower_case($1) :));
      add_adjective( ({ "copy", "of" }) );
      add_adjective(bits[0..<2]);
      add_alias(lower_case(bits[<1]));
      add_property("determinate", "a ");
      page = query_open_page();
      articles = NEWSPAPER_HANDLER->query_edition_articles(_paper, _edition);
      set_no_pages(sizeof(articles) + 1);
      index = "Edition #" + _edition + " of " + _paper + ".\n%^BOLD%^" +
              NEWSPAPER_HANDLER->query_paper_headline(_paper, _edition) +
              "%^RESET%^\n\n";
      index += sprintf("%2d .... %70-=s\n", 1, "Contents");
      for (i = 0; i < sizeof(articles); i++) {
         set_open_page(i + 2);
         ob = query_current_page();
         ob->set_value(0);
         if (articles[i]->colour) {
            index += "%^" + articles[i]->colour + "%^";
         }
         switch (articles[i]->type) {
         case NEWSPAPER_ARTICLE_TYPE_ADVERTS :
            header = "%^BOLD%^%^CYAN%^'Adverts'%^RESET%^\n\n";
            adverts = NEWSPAPER_HANDLER->query_edition_adverts(_paper, _edition);
            stuff = unique_array(adverts, (: $1->category :) );
            foreach (adverts in stuff) {
               header += "\n$I$0=" + adverts[0]->category + "\n$I$3=   ";
               foreach (data in adverts)  {
                  header += data->text + "\n-- " + data->author + "\n\n";
               }
            }
            index += sprintf("%2d .... %70-=s\n", i + 2, articles[i]->title);
            break;
         case NEWSPAPER_ARTICLE_TYPE_SECTION :
            header = "%^BOLD%^" + articles[i]->title + "'%^RESET%^\n\n";
            for (j = i + 1; j < sizeof(articles); j++) {
               if (articles[j]->type == NEWSPAPER_ARTICLE_TYPE_SECTION) {
                  break;
               }
               header += sprintf("%2d .... %70-=s\n", i + 2, articles[j]->title);
            }
            index += sprintf("%2d -=== %65|=s ===-\n", i + 2, articles[i]->title);
            break;
         case NEWSPAPER_ARTICLE_TYPE_HTML :
         case NEWSPAPER_ARTICLE_TYPE_PLAIN :
            header = "%^BOLD%^%^CYAN%^'" + articles[i]->title + "'%^RESET%^ at " +
                     ctime(articles[i]->date_written)[0..10] + "\n" +
                     "by " + articles[i]->shown_name;
            header += NEWSPAPER_HANDLER->query_article_text_plain(articles[i]);
            index += sprintf("%2d .... %70-=s\n", i + 2, articles[i]->title);
            break;
         }
         if (articles[i]->colour) {
            index += "%^RESET%^";
         }
         set_read_mess( header, NEWSPAPER_HANDLER->query_language_for( _paper ),
             0 );
      }
      set_open_page(1);
      set_read_mess( index, NEWSPAPER_HANDLER->query_language_for( _paper ), 0);
      ob = query_current_page();
      ob->set_value(0);
      fluff = NEWSPAPER_HANDLER->query_paper_long(_paper);
      if (fluff[<1] != '\n') {
         fluff += "\n";
      }
      set_long(fluff + "Edition " + _edition + " of " + _paper + ".\n");
      set_open_page(page);
   }
}
void set_paper(string paper) {
   _paper = paper;
   set_long(NEWSPAPER_HANDLER->query_paper_long(_paper));
   setup_paper();
}
void set_edition(int edition) {
   _edition = edition;
   setup_paper();
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, AUTO_LOAD_TAG, "paper", _paper);
   add_auto_load_value(map, AUTO_LOAD_TAG, "edition", _edition);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   ::init_dynamic_arg(map);
   set_paper(query_auto_load_value(map, AUTO_LOAD_TAG, "paper"));
   set_edition(query_auto_load_value(map, AUTO_LOAD_TAG, "edition"));
}

==================================================
FILE: misc/newspaper_box.c
==================================================

inherit "/std/object";
#include <room/newspaper.h>
#include <money.h>
#include <move_failures.h>
private string _paper;
void setup() {
   set_name("box");
   set_short("newspaper box");
   add_adjective("box");
   add_help_file("newspaper_box");
   reset_get();
}
void set_paper(string paper) {
   int cost;
   string place;
   string* bits;
   _paper = paper;
   place = query_property("place");
   if (!place) {
      if (environment()) {
         place = environment()->query_property("place");
      } else if (previous_object()) {
         place = previous_object()->query_property("place");
      }
   }
   cost = NEWSPAPER_HANDLER->query_paper_cost(paper);
   set_short(_paper + " box");
   set_long("This is a battered looking metal box that is full of copies of " +
            (lower_case(paper)[0..3] == "the "?"":"the ") +
            paper + ".  There is a door on the front you could pull open "
            "beside which is small white writing saying " +
            MONEY_HAND->money_value_string(cost, place) + ".\n");
   if (lower_case(_paper)[0..3] == "the ") {
      add_property("determinate", "");
   }
   bits = explode(lower_case(_paper), " ");
   add_adjective(bits);
}
int do_buy() {
   int cost;
   int edition;
   string place;
   object ob;
   int *editions;
   place = query_property("place");
   if (!place) {
      place = environment()->query_property("place");
   }
   cost = NEWSPAPER_HANDLER->query_paper_cost(_paper);
   edition = NEWSPAPER_HANDLER->query_last_edition_num(_paper);
   if (!edition) {
      add_failed_mess("There is no edition to buy.\n");
      return -1;
   }
   if (this_player()->query_value_in(place) < cost) {
      add_failed_mess("You do not have enough money to pay for " +
                      _paper + ", you need " +
                      MONEY_HAND->money_value_string(cost, place) +
                      ".\n");
      return -1;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);
   ob = clone_object("/obj/misc/newspaper");
   ob->set_paper(_paper);
   ob->set_edition(edition);
   if (ob->move(this_player()) != MOVE_OK) {
      ob->move(environment(this_player()));
      write("Unable to move the paper into your inventory, putting it on "
            "the ground.\n");
   }
   editions = this_player()->query_property("Paper " + _paper);
   if (!editions) {
      editions = ({ });
   }
   if (member_array(edition, editions) == -1) {
      editions += ({ edition });
      this_player()->add_property("Paper " + _paper, editions);
      NEWSPAPER_HANDLER->add_edition_paper_sold(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   } else {
      NEWSPAPER_HANDLER->add_edition_revenue(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   }
   add_succeeded_mess("$N $V a paper from $D.\n");
   return 1;
}
void init() {
   add_command("buy", "paper from <direct:object>", (: do_buy() :));
   add_command("pull", "[door] [on] <direct:object>", (: do_buy() :));
   add_command("pull", "open <direct:object>", (: do_buy() :));
}

==================================================
FILE: misc/nroff_paper.c
==================================================

inherit "/obj/misc/paper";
#include "nroff.h"
private nosave mixed *stuff = ({ });
string file_name = 0;
string language = 0;
void create() {
  seteuid(getuid());
  ::create();
}
void set_file_name(string fname) {
  file_name = fname;
}
string query_file_name() { return file_name; }
void set_language(string lang) { language = lang; }
string query_language() { return language; }
mixed *query_read_mess() {
  string str;
  if(sizeof(stuff) == 0) {
    if (file_name) {
      str = unguarded( (: NROFF_HAND->cat_file(file_name+"_nroff", 1) :) );
      if (!str) {
        unguarded((: NROFF_HAND->create_nroff(file_name, file_name+"_nroff") :));
        str = unguarded( (: NROFF_HAND->cat_file(file_name+"_nroff", 1) :) );
      }
      if(!str)
        return ::query_read_mess() +
          ({ ({ "Unable to nroff file.\n", 0, "common", 0 }) });
      if( language ) {
         return stuff = ({ ({ str, 0, language, 0 }) });
      }
      return stuff = ({ ({ str, 0, "common", 0 }) });
    }
  }
  return stuff + ::query_read_mess();
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   map["read mess"] = ::query_read_mess();
   return map;
}

==================================================
FILE: misc/paper.c
==================================================

#include <playtesters.h>
#define AUTO_LOAD_TAG "paper"
inherit "/std/object";
int do_uncrumple();
int do_crumple();
int do_eat();
private int _crumpled;
private string _old_short;
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_name( "paper" );
   set_short( "piece of writing paper" );
   add_adjective( ({ "piece of", "writing" }) );
   set_main_plural( "pieces of writing paper" );
   add_plural( "pieces of writing paper" );
   add_adjective(({ "piece", "pieces", "of", "writing" }));
   set_long( "This is a nice sheet of writing paper.\n" );
   set_value( 25 );
   set_weight( 0 );
   add_property( "writeable", 1 );
   add_property( "paper", 1 );
   set_max_size( 1000 );
   if ( !do_setup ) {
      this_object()->setup();
   }
}
void init() {
   if ( !this_player() ) {
       return;
   }
   add_command( "eat", "<direct:object>", (: do_eat :) );
   add_command( "crumple", "<direct:object>", (: do_crumple :) );
   add_command( "untangle", "<direct:object>", (: do_uncrumple :) );
   add_command( "uncrumple", "<direct:object>", (: do_uncrumple :) );
}
public int query_edible() {
    return 1;
}
public int query_paper() {
   return 1;
}
int do_crumple() {
   if (_crumpled) {
      add_failed_mess("$D is already crumpled.\n");
      return 0;
   }
   _old_short = query_short();
   call_out( (: set_short :), 1, "crumpled up " + query_short() );
   _crumpled = 1;
   return 1;
}
int do_uncrumple() {
    if (!_crumpled) {
        add_failed_mess("$D is already uncrumpled.\n");
        return 0;
    }
    call_out( (: set_short :), 1, _old_short );
   _crumpled = 0;
   return 1;
}
int do_eat() {
   string *flavours = ({ "red ink", "green ink", "black ink",
       "blue ink", "orange", "apple", "cinnamon", "banana",
       "monkey", "cabbage", "hat" });
   add_succeeded_mess( ({ "You open your mouth up widely and pop $D into "
      "your mouth.  After a moment's deliberation, you chew and consume "
      "$D.\n", "$N $V $D.\n" }) );
   call_out( (: tell_object( $1, $2 ) :), 1,
       this_player(), "Mmm! " +
       capitalize( flavours[random( sizeof( flavours ) ) ] ) +
       " flavoured!\n" );
   move( "/room/rubbish" );
   return 1;
}
string query_readable_message(object player, int ignore_labels) {
   if (!_crumpled) {
      return ::query_readable_message(player, ignore_labels);
   }
   return "Only bits of ink can be seen on the crumpled paper.\n";
}
string *parse_command_adjectiv_id_list() {
   if (_crumpled) {
      return ::parse_command_adjectiv_id_list() + ({ "crumpled", "up" });
   }
   return ::parse_command_adjectiv_id_list();
}
mapping query_dynamic_auto_load() {
    mapping map;
    map = ::query_dynamic_auto_load();
    add_auto_load_value( map, AUTO_LOAD_TAG, "crumpled", _crumpled );
    add_auto_load_value( map, AUTO_LOAD_TAG, "old short", _old_short );
    return map;
}
void init_dynamic_arg( mapping map, object ) {
    ::init_dynamic_arg(map);
    if (map) {
        _crumpled = query_auto_load_value( map, AUTO_LOAD_TAG, "crumpled" );
        _old_short = query_auto_load_value( map, AUTO_LOAD_TAG, "old short" );
        if ( map[ "paper - crumpled" ] ) {
            _crumpled = map[ "paper - crumpled" ];
        }
        if ( map[ "paper - short" ] ) {
            _old_short = map[ "paper - short" ];
        }
    }
}
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/misc/paper" )
      return ([ ]);
   return int_query_static_auto_load();
}

==================================================
FILE: misc/paper_packet.c
==================================================

inherit "/obj/baggage";
void setup() {
   set_name( "packet" );
   set_short( "waxed paper packet" );
   add_adjective( ({ "waxed", "paper" }) );
   set_main_plural( "waxed paper packets" );
   set_long( "This is a small packet, rather like an envelope, of thick "+
         "paper that has been waxed to make it more resilient.\n" );
   set_weight( 1 );
   set_value( 10 );
   set_max_weight( 3 );
   set_transparent();
   add_property("writeable", 1);
}
int test_add( object thing, int flag ) {
   string word;
   object *things;
   if ( !this_player() )
      return ::test_add( thing, flag );
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return ::test_add( thing, flag );
   word = (string)things[ 0 ]->query_medium_alias();
   if ( word == (string)thing->query_medium_alias() )
      return ::test_add( thing, flag );
   write( "You don't want to contaminate "+ ( stringp( word ) ?
         (string)things[ 0 ]->the_short() :
         (string)thing->the_short() ) +", do you?\n" );
   return 0;
}
object query_substance() {
   object *things;
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return 0;
   if ( !stringp( (string)things[ 0 ]->query_medium_alias() ) )
      return 0;
   return things[ 0 ];
}
string short( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::short( dark );
   return ::short( dark ) +" of "+ (string)thing->short( dark );
}
string query_plural( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::query_plural( dark );
   return ::query_plural( dark ) +" of "+ (string)thing->short( dark );
}
string *parse_command_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_id_list();
   return ::parse_command_id_list() +
         ({ ::short( 0 ) +" of "+ (string)thing->short( 0 ) });
}
string *parse_command_plural_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_plural_id_list();
   return ::parse_command_plural_id_list() +
         ({ ::query_plural( 0 ) +" of "+ (string)thing->short( 0 ) });
}
string *parse_command_adjectiv_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_adjectiv_id_list();
   return ::parse_command_adjectiv_id_list() +
         (string *)thing->parse_command_adjectiv_id_list() +
         (string *)thing->parse_command_id_list();
}

==================================================
FILE: misc/pawn_receipt.c
==================================================

#include <am_time.h>
#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <player.h>
#include <virtual.h>
#define TO this_object()
#define TP this_player()
inherit "/obj/misc/paper" ;
private int    _expired ;
private int    _expired_sold ;
private int    _expiry_time ;
private int    _item_value, _obplural ;
private int    _timestamp;
private mixed  _static_save;
private string _obname, _obpath, _obshort ;
private string _shop_path, _virt_name ;
object do_kiss();
void setup() {
    set_name( "receipt" );
    set_short( "pawned item receipt" ) ;
    add_adjective( ({ "pawned", "item" }) );
    set_long( "This is a small slip of paper, with a black border.\n" );
    set_main_plural( "pawned item receipts" ) ;
    add_plural( "receipts" );
    add_adjective( "pawned" ) ;
    set_value( 0 ) ;
    set_weight( 1 );
    _obname = "unknown object";
    _obpath = "***";
    _timestamp = time();
}
void init() {
    add_command( "reclaim", "<direct:object:me'receipt'>" ) ;
}
void reset() {
    object item ;
    if ( ( ! _expired ) && time() > _expiry_time ) {
        _expired = 1 ;
        set_short( "expired pawned item receipt" ) ;
        add_adjective( "expired" ) ;
        if ( ! _expired_sold ) {
            _expired_sold = 1 ;
            item = do_kiss() ;
            if ( item ) {
                item->move( _shop_path->query_store_room() ) ;
            }
        }
    }
}
void set_obshort( string s ) {
  _obshort = s;
}
string query_obshort() {
  return _obshort;
}
void set_expiry_time( int time ) {
    _expiry_time = time ;
}
int query_expiry_time() {
    return _expiry_time ;
}
void set_item_value( int value ) {
    _item_value = value ;
}
int query_item_value() {
    return _item_value ;
}
void set_shop_path( mixed shop ) {
    if ( objectp( shop ) ) {
        _shop_path = base_name( shop ) ;
        return ;
    }
    _shop_path = shop ;
    return ;
}
string query_shop_path() {
    return _shop_path ;
}
void set_obname( string name ) {
    _obname = name;
}
void set_object( string path ) {
    _obpath = path;
}
void set_virtobname( string name ) {
    _virt_name = name;
}
string query_obname() {
    return _obname;
}
string query_obpath() {
    return _obpath;
}
int query_timestamp() {
    return _timestamp;
}
string query_virt_obname() {
    return _virt_name;
}
mixed query_static_save() {
  return _static_save;
}
int query_pawned_item_receipt() {
    return 1 ;
}
void set_static_save( mixed args ) {
  mixed p;
  _static_save = args;
  if (_obname != "unknown object") {
    return;
  }
  p = args[0];
  while (mapp(p)) {
    if (!undefinedp(p["short"])) {
      _obname = p["short"];
      return;
    }
    p = p["::"];
  }
}
void set_object_plural( object ob ) {
  if ( ob->query_collective() && ob->query_amount() > 1 ) {
    _obplural = 1;
  } else {
    _obplural = 0;
  }
}
int query_object_plural() {
  return _obplural;
}
string query_correct_short( object ob ) {
    if ( ! ob ) {
      return 0;
    }
    set_object_plural( ob );
    if ( _obplural ) {
      return pluralize( ob->query_short() );
    }
    return ob->query_short();
}
void setup_receipt( object ob ) {
   mixed* bits;
   bits = AUTO_LOAD_OB->fragile_auto_str_ob(ob);
   set_obname(ob->query_name());
   set_obshort( query_correct_short( ob ) );
   set_object(bits[1]);
   set_static_save(bits[2]);
}
string pluralize_sentence( string text, int plural ) {
  if ( plural ) {
    return replace( text, ({
      "$o", "them",
      "$r", "they",
      "$ve", "ve"
    }) );
  }
  return replace( text, ({
    "$o", "it",
    "$r", "it",
    "$ve", "s"
  }) );
}
string query_details() {
    if ( _expired ) {
        return pluralize_sentence(
          "This is a receipt for your pawned " + query_obshort() + ".\n"
          "Sadly, you have left it too long to collect $o and $r ha$ve "
          "expired, so the shop will put $o up for sale.  Better hurry to "
          + _shop_path->the_short() + " sharpish and try to buy $o back!",
          _obplural );
    }
    return pluralize_sentence(
      "This is a receipt for your pawned " + query_obshort() + ".\n"
      "You must reclaim $o from " + _shop_path->the_short() + " before "
      + AM_TIME_HANDLER->query_am_time( _expiry_time ) + " or $r will "
      "be sold.", _obplural );
}
mixed *query_read_mess() {
  string lang;
  if ( _shop_path ) {
    lang = _shop_path->query_language();
  } else {
    lang = "general";
  }
  return ::query_read_mess()
    + ({ ({ (: query_details() :), "neat printing", lang, 0 }) });
}
mapping query_dynamic_auto_load()
{
   return ([
     "::"         : ::query_dynamic_auto_load(),
     "obname"     : _obname,
     "obpath"     : _obpath,
     "obvalue"    : value,
     "virt"       : _virt_name,
     "timestamp"  : _timestamp,
     "static"     : _static_save,
     "been sold"  : _expired_sold,
     "expired"    : _expired,
     "expires on" : _expiry_time,
     "item value" : _item_value,
     "item short" : _obshort,
     "item plural": _obplural,
     "shop path"  : _shop_path
  ]);
}
void init_dynamic_arg(mapping arg, object) {
   _obname = arg["obname"];
   if ( stringp( _obname ) ) {
       add_adjective( explode( lower_case( _obname ), " " ) );
   }
   _obpath = arg["obpath"];
   set_value(arg["obvalue"]);
   _virt_name = arg["virt"];
   _timestamp = arg["timestamp"];
   _static_save = arg["static"];
   _expired = arg["expired"] ;
   _expired_sold = arg["been sold"] ;
   _expiry_time = arg["expires on"] ;
   _item_value = arg["item value"] ;
   _obshort = arg["item short"];
   _obplural = arg["item plural"];
   _shop_path = arg["shop path"] ;
   ::init_dynamic_arg(arg["::"]);
   if ( _expired ) {
       set_short( "expired pawned item receipt" ) ;
       add_adjective( "expired" ) ;
       set_main_plural( "expired pawned item receipts" ) ;
       add_plural( "pawned item receipts" ) ;
   }
}
mixed *stats() {
  mixed *stuff;
  stuff = ::stats() + ({
      ({ "obname", _obname }),
      ({ "obpath", _obpath }),
      ({ "timestamp", _timestamp + " (" + ctime(_timestamp) + ")" }),
      ({ "been sold", _expired_sold }),
      ({ "expired", _expired }),
      ({ "expires on", _expiry_time }),
      ({ "item short", _obshort }),
      ({ "item value", _item_value }),
      ({ "item plural", _obplural }),
      ({ "shop path", _shop_path })
   });
  if (_virt_name)
    stuff += ({ ({ "virtname", _virt_name }) });
  return stuff;
}
object do_kiss() {
    object thing;
    if (sizeof(_static_save) < 2) {
        if (this_player()->query_creator()) {
            write("This receipt has no auto-load information, possibly "
                  "because the object was broken when the player logged "
                  "out.  It will have to be replaced by hand.\n");
        } else {
            write("Sorry, but this object is too broken to repair "
                  "with a kiss.  You'll have to contact a creator.\n");
        }
        return 0;
    }
    if (_virt_name) {
       _virt_name = CLONER->other_file( _virt_name );
       if (file_size(_virt_name) <= 0) {
          _virt_name = ARMOURY->remap_file_path(_virt_name);
       }
       if (file_size(_virt_name) <= 0) {
           write("The receipt whispers: Sorry, I'm still broken.  "
                 "Try again some other time, or contact a creator.\n");
           return 0;
       }
    }
    if ( !catch( thing = (object)CLONER->clone( _obpath ) ) ) {
        if ( thing ) {
            thing->init_static_arg(_static_save[0]);
            thing->init_dynamic_arg(_static_save[1]);
            thing->add_property(VIRTUAL_NAME_PROP, _virt_name);
            move("/room/rubbish");
            return thing;
        } else {
            write("The receipt whispers: I'm going to need some "
                  "creator help.\n");
            thing->dest_me();
        }
    } else {
         write("The receipt whispers: Sorry, I'm still broken.  "
               "Try again some other time, or contact a creator.\n");
    }
    return 0;
}
int do_reclaim() {
    int cost, i ;
    object change, item ;
    string change_str, place ;
    if ( ! query_pawned_item_receipt() ) {
        add_failed_mess( "$D is not a pawned item receipt.\n" ) ;
        return 0 ;
    }
    if ( base_name( environment( TP ) ) != _shop_path ) {
        add_failed_mess(
            "This is not the right place for you to reclaim $D.  "
            "Try a pawn shop.\n" ) ;
        return 0 ;
    }
    if ( ! environment( TP )->is_open( TP, 0 ) ) {
        return 0;
    }
    if ( _expired ) {
        add_failed_mess( "Oh dear, your receipt has expired.  With luck, your "
            + query_obshort() + " will be available for sale in the shop.\n" ) ;
        return 0 ;
    }
    place = query_property( "place" ) ;
    if ( ! place || ( place == "" ) ) {
        place = "default" ;
    }
    cost = ( ( 100 + _shop_path->query_pawn_markup() ) * _item_value ) / 100 ;
    debug_printf( "cost = %d, _item_value = %d, markup = %d",
        cost, _item_value, _shop_path->query_pawn_markup() ) ;
    if ( TP->query_value_in( place ) < cost ) {
        add_failed_mess( "You don't have enough money to reclaim $D.  "
            "It would cost you "
            + MONEY_HAND->money_value_string( cost, place ) + "\n" ) ;
        return 0 ;
    }
    change = MONEY_HAND->pay_amount_from( cost, TP, place ) ;
    if ( change ) {
        change->move( TP ) ;
        change_str = change->short() ;
    }
    item = do_kiss();
    if ( ! item ) {
        add_failed_mess(
          "Oh dear, your item doesn't seem to be here any more.  "
          "Please contact a liaison.\n" );
        return 0;
    }
    i = item->move( TP );
    if ( i != MOVE_OK ) {
        tell_object( TP, "You're too heavily burdened to accept "
          + item->the_short() + ", so it is placed on the floor for you.\n" );
        item->move( environment(TP) );
    }
    add_succeeded_mess( ({
        "$N $V " + item->the_short() + " for "
          + MONEY_HAND->money_value_string( cost, place )
          + ( change_str ? " and receive " + change_str + " in change" : "" )
          + ".\n",
        "$N $V $D and receives " + item->the_short() + " in exchange.\n"
    }) ) ;
    return 1 ;
}

==================================================
FILE: misc/perfume_bottle.c
==================================================

#include <move_failures.h>
inherit "/std/object";
inherit "/std/basic/holdable";
int squirts;
string glass, scent, scent_plural;
void create() {
   object::create();
   holdable::create();
}
void setup() {
   set_name( "bottle" );
   set_short( "perfume bottle" );
   add_adjective( "perfume" );
   set_value( 4000 );
   set_weight( 2 );
   squirts = 12;
}
void set_glass( string word ) {
   set_short( word +" perfume bottle" );
   add_adjective( word );
   set_main_plural( word +" perfume bottles" );
   glass = word;
}
void set_scent( string words ) { scent = words; }
void set_scent_plural( string words ) { scent_plural = words; }
string long( string word, int dark ) {
   string words;
   words = "This is a perfume bottle made out of "+ glass +" crystal.  "+
         "It is ";
   switch( squirts ) {
      case 0 :
         return words +"empty.\n";
      case 1 .. 3 :
         words += "about a quarter full";
         break;
      case 4 .. 6 :
         words += "about half full";
         break;
      case 7 .. 9 :
         words += "about three-quarters full";
         break;
      default :
         words += "almost full";
   }
   words += " of "+ scent +" perfume which can be sprayed onto "+
         "someone.\n";
   return words;
}
void init() {
   this_player()->add_command( "spray", this_object(), "<direct:object> at <indirect:object>" );
}
int do_spray( object *things ) {
  if ( query_wielded() != this_player() ) {
    this_player()->add_failed_mess( this_object(), "You must be holding "+
        "$D to use it.\n", ({ }) );
    return 0;
  }
  if ( sizeof( things ) > 1 ) {
    this_player()->add_failed_mess( this_object(), "You can only spray $D "+
        "at one person at a time.\n", ({ }) );
    return 0;
  }
  if ( things[ 0 ] == this_object() ) {
    this_player()->add_failed_mess( this_object(), "You cannot spray $D at "+
        "itself!\n", ({ }) );
    return 0;
  }
  if ( !living( things[ 0 ] ) ) {
    this_player()->add_failed_mess( this_object(), "SI would probably not "+
        "benefit from being sprayed.\n", ({ things[ 0 ] }) );
    return 0;
  }
  if ( !squirts ) {
    this_player()->add_failed_mess( this_object(), "There is no perfume in "+
        "$D to spray at $I.\n", ({ things[ 0 ] }) );
    return 0;
  }
  squirts--;
  things[ 0 ]->add_effect( "/std/effects/other/perfume", ({ 300, scent,
      scent_plural }) );
  this_player()->add_succeeded( things[ 0 ] );
  return 1;
}
mapping query_dynamic_auto_load() {
  return ([
    "::" : ::query_dynamic_auto_load(),
    "squirts" : squirts
  ]);
}
mapping query_static_auto_load() {
  if ( explode( file_name( this_object() ), "#" )[ 0 ] !=
      "/obj/misc/perfume_bottle" )
    return 0;
  return ([
    "::" : int_query_static_auto_load(),
    "glass" : glass,
    "scent" : scent,
    "scent_plural" : scent_plural
  ]);
}
void init_dynamic_arg( mapping map ) {
  if ( map[ "::" ] )
    ::init_dynamic_arg( map[ "::" ] );
  squirts = map[ "squirts" ];
}
void init_static_arg( mapping map ) {
  if ( map[ "::" ] )
    ::init_static_arg( map[ "::" ] );
  if ( map[ "glass" ] )
    set_glass( map[ "glass" ] );
  if ( map[ "scent" ] )
    scent = map[ "scent" ];
  if ( map[ "scent_plural" ] )
    scent_plural = map[ "scent_plural" ];
}
void dest_me() {
   holdable::dest_me();
   object::dest_me();
}
varargs int move( mixed ob, string mess1, string mess2 ) {
   int ret;
   ret = holdable::move(ob);
   if (ret != MOVE_OK) {
      return ret;
   }
   return object::move( ob, mess1, mess2 );
}

==================================================
FILE: misc/plate.c
==================================================

inherit "/std/surface";
void init() {
  this_player()->add_command( "eat", this_object(),
    "<indirect:object:direct-obs> {from|on} <direct:object:me>" );
  this_player()->add_command( "eat", this_object(),
    "from <direct:object:me>" );
}
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_long( "This is a nice plate for keeping food on.\n" );
  if ( ! do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
int do_eat( object *obs, string dir, string indir, mixed *args ) {
  object ob;
  object *food;
  if( sizeof( obs ) )
    food = copy( obs );
  else
    food = all_inventory();
  if( sizeof( food ) ) {
    food = filter( food, (: $1->query_edible() :) );
  } else {
    this_player()->add_failed_mess( this_object(),
      "There's nothing on $D\n", ({ }) );
    return 0;
  }
  if( !sizeof( food ) ) {
    if( sizeof( obs ) )
      this_player()->add_failed_mess( this_object(),
        "You can't eat $I on $D!\n", obs );
    else
      this_player()->add_failed_mess( this_object(),
        "There's nothing edible on $D\n", ({ }) );
    return 0;
  }
  foreach( ob in food ) {
    ob->do_eat();
  }
  return 1;
}
mapping query_static_auto_load() {
  return int_query_static_auto_load();
}

==================================================
FILE: misc/present.c
==================================================

#include <move_failures.h>
#define PAPER_LONG "This is a lovely big piece of " + _colour + " " + _type + " paper.  It looks like it could be used to wrap up something as a present.  Try \"wrap <objects> in paper\".\n"
#define PRESENT_LONG "This lovely piece of " + _colour + " paper has been used to wrap up something as a present.  Try \"unwrap\".\n"
inherit "/obj/baggage";
int do_wrap( object *things );
int do_unwrap();
private int wrapped;
private string _colour;
private string _type;
void setup() {
   set_name( "wrappingpaper" );
   set_short( "piece of wrapping paper" );
   add_alias( "paper" );
   add_adjective( ({ "piece of", "wrapping" }) );
   set_main_plural( "pieces of wrapping paper" );
   add_plural( ({ "pieces of wrapping paper", "pieces of paper",
                  "papers" }) );
   set_long( PAPER_LONG );
   set_weight( 2 );
   set_max_weight( 225 );
   set_value( 600 );
   set_stuck(1);
   add_property( "writeable", 1 );
   add_property( "paper", 1);
}
void set_colour( string word ) {
   if( _colour ) {
      return;
   }
   _colour = word;
   if (!_colour) {
      return;
   }
   set_short( "piece of " + _colour + " " + _type + " paper" );
   add_adjective( explode( _colour, " " ) );
   set_main_plural( "pieces of " + _colour + " " + _type + " paper" );
   set_long( PAPER_LONG );
}
void set_type( string word ) {
   if( _type ) {
      return;
   }
   _type = word;
   if (!_type) {
      return;
   }
   set_short( "piece of " + _colour + " " + _type + " paper" );
   add_adjective( explode( _type, " " ) );
   set_main_plural( "pieces of " + _colour + " " + _type + " paper" );
   set_long( PAPER_LONG );
}
#ifdef MY_TEST_FUNC
int test_remove( object thing, int flag ) {
   if( ( query_verb() == "get" ) || ( query_verb() == "take" ) ) {
      return !wrapped;
   }
   return 1;
}
int test_add( object thing, int flag ) {
   if( ( query_verb() == "put" ) || ( query_verb() == "give" ) ) {
      return 0;
   }
   return 1;
}
#endif
void init() {
   add_command( "wrap", "<indirect:object:me> in <direct:object'present'>" );
   add_command( "unwrap", "<direct:object:'present'>", (: do_unwrap :) );
   add_command( "open", "<direct:object:'present'>", (: do_unwrap :) );
}
int do_wrap( object *things ) {
   object *valid, *failed;
   things -= ({ this_object() });
   if( wrapped ) {
      add_failed_mess( "The paper has already been used to wrap something.\n" );
      return 0;
   }
   if( !( sizeof( things ) ) ) {
      add_failed_mess( "You must wrap something!\n" );
      return 0;
   }
   valid = filter( things, (: !living( $1 ) &&
                              $1->move( this_object() ) == MOVE_OK :) );
   failed = things - valid;
   if( sizeof( failed ) ) {
      tell_object( this_player(), "You could not wrap " +
         query_multiple_short( failed ) + " in " + the_short() + ".\n" );
   }
   if( sizeof( valid ) ) {
      wrapped = 1;
      remove_alias( "paper" );
      remove_adjective( "piece of" );
      remove_adjective( "wrapping" );
      remove_plural( "pieces of wrapping paper" );
      remove_plural( "pieces of paper" );
      remove_plural( "papers" );
      call_out( "set_short", 1, _colour + " present" );
      add_alias( "present" );
      set_main_plural( _colour + " presents" );
      add_plural( "presents" );
      set_long( PRESENT_LONG );
      add_succeeded_mess( "$N $V $I in $D.\n", valid );
   } else {
      add_succeeded_mess( "" );
   }
   return 1;
}
int do_unwrap() {
   int i;
   object *things;
   if( !wrapped ) {
      write( "There is nothing wrapped in the paper.\n" );
      return 0;
   }
   wrapped = 0;
   things = all_inventory();
   write( "You open the present and find "+ query_multiple_short( things ) +
      " inside.\n" );
   for( i = 0; i < sizeof( things ); i++ ) {
      if( things[ i ]->move( environment() ) ) {
         if( environment( environment() ) ) {
            things[ i ]->move( environment( environment() ) );
            write( "The " + things[ i ]->short() + " falls onto the " +
               "floor as you unwrap the present.\n" );
         }
      }
   }
   remove_alias( "present" );
   remove_plural( "presents" );
   call_out( "set_short", 1, "piece of " + _colour + " " + _type + " paper" );
   add_alias( "paper" );
   add_adjective( ({ "piece of", "wrapping" }) );
   set_main_plural( "pieces of " + _colour + " " + _type + " paper" );
   add_plural( ({ "pieces of " + _type + " paper", "pieces of paper",
                  "papers" }) );
   set_long( PAPER_LONG );
   add_succeeded_mess("$N unwrap$s $D.\n");
   return 1;
}
mixed *stats() {
    return ::stats() + ({
      ({ "colour", _colour }),
      ({ "type", _type }),
      ({ "wrapped", wrapped }),
    });
}
mapping query_static_auto_load() {
    return ([
      "colour": _colour,
      "type": _type,
      "::": ::int_query_static_auto_load(),
    ]);
}
void init_static_arg( mapping args ) {
    _colour = args[ "colour" ];
    ::init_static_arg( args[ "::" ] );
}
mapping query_dynamic_auto_load() {
    return ([
      "colour": _colour,
      "type": _type,
      "wrapped": wrapped,
      "::": ::query_dynamic_auto_load(),
    ]);
}
void init_dynamic_arg( mapping args ) {
    _colour = args[ "colour"  ];
    _type   = args[ "type"    ];
    wrapped = args[ "wrapped" ];
    ::init_dynamic_arg( args[ "::" ] );
    if(!_colour) {
        _colour = "plain";
    }
    if(!_type) {
        _type = "wrapping";
    }
}
int query_closed() {
    return 1;
}
string long_status() {
    return "";
}

==================================================
FILE: misc/press_credentials.c
==================================================

inherit "/obj/clothing";
private string _owner = "someone";
private string _paper;
void set_owner_stuff();
void update_stuff();
void setup() {
   add_property("press credentials",1);
   set_name( "badge" );
   set_short( "press credentials badge" );
   add_adjective( ({ "press", "credentials" }) );
   add_alias( "badge" );
   add_property( "nosteal", 1 );
   add_alias( "credentials" );
   set_type( "badge" );
   setup_clothing( 1000 );
   set_weight( 1 );
   reset_drop();
   set_wear_remove_func(base_name(this_object()), "wear_badge");
}
void init() {
   if( _owner == "someone" ) {
      update_stuff();
   }
   if( this_player()->query_name() == lower_case(_owner) ) {
      add_command( "show", "<direct:object:me'credentials'>");
   }
}
void wear_badge(object ob, object player) {
   if (!ob) {
      if (player) {
         player->remove_title("newspaper");
      }
   } else if (_paper) {
      player->set_title("newspaper", "Reporter for " + _paper);
   }
}
void set_owner_stuff() {
   set_long( "This is a small badge with a hand-drawn picture of " +
     _owner + " on it, underneath the logo of " + _paper + ".  "
     "Emblazoned along the bottom are the words \"Official Reporter\".\n");
   if (query_worn_by()) {
      query_worn_by()->set_title("newspaper", "Reporter for " + _paper);
   }
}
int do_show() {
   add_succeeded_mess( ({ "With a practiced flick of your wrist, you display "
     "your press credentials to the room.\n", "With a practiced flick of $p "
     "wrist, $N whips out $p press credentials for " + _paper +
     " and shows them to "
     "everybody.\n" }) );
   return 1;
}
void set_paper_name(string paper) {
   _paper = paper;
}
string query_paper_name() {
   return _paper;
}
void update_stuff() {
   object ob;
   ob = environment();
   if( ob && living( ob ) ) {
      _owner = ob->query_cap_name();
   }
   set_owner_stuff();
}
mapping query_dynamic_auto_load() {
   return ([
     "::" : ::query_dynamic_auto_load(),
     "cred owner" : _owner,
     "paper" : _paper
   ]);
}
void init_dynamic_arg( mapping map ) {
   _paper = map["paper"];
   _owner = map["cred owner"];
   ::init_dynamic_arg( map[ "::" ] );
   set_owner_stuff();
}

==================================================
FILE: misc/quest_info_utils.c
==================================================

#include <library.h>
string _quest_name;
void set_quest_name(string quest_name)
{
   _quest_name = quest_name;
}
void set_quest_param(mixed player, string key, mixed value)
{
   mixed info;
   if (!stringp(player))
      player = player->query_name();
   info = LIBRARY->query_player_quest_info(player, _quest_name);
   if (!mapp(info))
      info = ([ ]);
   info[key] = value;
   LIBRARY->set_player_quest_info(player, _quest_name, info);
}
mixed query_quest_param(mixed player, string key)
{
   mixed info;
   if (!stringp(player))
      player = player->query_name();
   info = LIBRARY->query_player_quest_info(player, _quest_name);
   if (!mapp(info))
      return 0;
   return info[key];
}
void clear_quest_info(mixed player)
{
   if (!stringp(player))
      player = player->query_name();
   LIBRARY->set_player_quest_info(player, _quest_name, 0);
}

==================================================
FILE: misc/quill.c
==================================================

#include <language.h>
inherit "/obj/weapon";
int do_scribble( object *things, string mess);
object writing_on;
string type;
void setup() {
   set_name( "quill" );
   set_long( "This is a nice, long, feathery quill.  You could \"write\" "
         "on things with it.\n");
   set_weight( 3 );
   set_value( 1000 );
   new_weapon( 240 );
   add_help_file("quill");
   set_damage_chance( 100 );
   add_attack( "stab", 90, ({ 10, 2, 10 }), "pierce", "sharp", 0 );
   add_property( "paper writer", 1 );
   type = "ink";
}
void init() {
   add_command( "write", "on <indirect:object> with <direct:object>" );
   add_command( "write", "with <direct:object> on <indirect:object>" );
   add_command( "sign", "<indirect:object> with <direct:object>");
   add_command( "scribble",
                "<string'message'> on <indirect:object> with <direct:object>",
                (: do_scribble($1, $4[0]) :));
}
int do_scribble( object *things, string mess) {
   string language;
   if ( query_wielded() != this_player() ) {
      this_player()->add_failed_mess( this_object(), "You need to be "+
            "holding $D to $V with it.\n", ({ }) );
      return 0;
   }
   things = filter(things, (: is_in_me_or_environment($1, this_player()) :));
   if (!sizeof(things)) {
      add_failed_mess("You can only $V on objects you are holding or are "
                      "in the room with $D.\n");
      return 0;
   }
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can only $V on one object at once with $D.\n");
      return 0;
   }
   if ( !things[ 0 ]->query_property( "writeable" ) ) {
      add_failed_mess("You cannot $V on $I with $D.\n", things );
      return 0;
   }
   language = (string)this_player()->query_current_language();
   if ( !LANGUAGE_HAND->query_language_written( language ) ) {
      add_failed_mess("You cannot $V on "+
            "$I with $D when you're not using a language that can be "+
            "written.\n", things );
      return 0;
   }
   if (things[0]->is_current_page_torn_out()) {
      add_failed_mess( "The page of " + things[0]->the_short() +
            " you were writing on appears to have been torn out.\n" );
      return 0;
   }
   things[0]->add_read_mess( mess, type, language, 0 );
   add_succeeded_mess("$N $V something on $I.\n", things);
   return 1;
}
int do_write( object *things ) {
   string language;
   if ( query_wielded() != this_player() ) {
      this_player()->add_failed_mess( this_object(), "You need to be "+
            "holding $D to $V with it.\n", ({ }) );
      return 0;
   }
   things = filter(things, (: is_in_me_or_environment($1, this_player()) :));
   if (!sizeof(things)) {
      add_failed_mess("You can only $V on objects you are holding or are "
                      "in the room with $D.\n");
      return 0;
   }
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can only $V on one object at once with $D.\n");
      return 0;
   }
   if ( !things[ 0 ]->query_property( "writeable" ) ) {
      add_failed_mess("You cannot $V on $I with $D.\n", things );
      return 0;
   }
   language = (string)this_player()->query_current_language();
   if ( !LANGUAGE_HAND->query_language_written( language ) ) {
      add_failed_mess("You cannot $V on "+
            "$I with $D when you're not using a language that can be "+
            "written.\n", things );
      return 0;
   }
   if ( writing_on ) {
      add_failed_mess("You are already writing on $I with $D.\n", ({ writing_on }) );
      return 0;
   }
   add_succeeded_mess("$N start$s writing on $I with $D.\n", things );
   writing_on = things[ 0 ];
   call_out( "begin_writing", 0, this_player() );
   return 1;
}
void begin_writing( object writer ) {
   if ( !writer ) {
      writing_on = 0;
      return;
   }
   writer->do_edit( 0, "end_writing" );
}
void end_writing( string words ) {
   string language;
   if ( !words || ( words == "" ) ) {
      write( "You don't write anything on "+
            (string)writing_on->the_short() +".\n" );
      say( (string)this_player()->the_short() +" doesn't "+
            "write anything after all.\n" );
      writing_on = 0;
      return;
   }
   language = (string)this_player()->query_current_language();
   if ( !LANGUAGE_HAND->query_language_written( language ) ) {
      write( "You seem to have changed to using a non-written language.\n" );
      say( (string)this_player()->the_short() +" seems "+
            "linguistically-challenged.\n" );
      writing_on = 0;
      return;
   }
   if ( !writing_on ) {
      write( "You seem to have lost what you were writing on.\n" );
      say( (string)this_player()->the_short() +" looks around "+
            "in puzzlement.\n" );
      return;
   }
   if ( member_array( environment( writing_on ), ({ environment(),
         environment( this_player() ) }) ) == -1 ) {
      write( (string)writing_on->the_short() +
            " seems to have run away from you.\n" );
      say( (string)this_player()->the_short() +" looks like "+
            (string)this_player()->query_pronoun() +"'s lost something.\n" );
      writing_on = 0;
      return;
   }
   if (writing_on->is_current_page_torn_out()) {
      write( "The page of " + (string)writing_on->the_short() +
            " you were writing on appears to have been torn out.\n" );
      say( (string)this_player()->the_short() +" looks like "+
            (string)this_player()->query_pronoun() +"'s lost something.\n" );
      writing_on = 0;
      return;
   }
   writing_on->add_read_mess( words, type, language, 0 );
   write( "You finish writing on "+
         (string)writing_on->the_short() +".\n" );
   say( (string)this_player()->the_short() +" finishes writing "+
         "on "+ (string)writing_on->a_short() +".\n" );
   writing_on = 0;
}
int do_sign(object* things) {
   object ob;
   string language;
   if ( query_wielded() != this_player() ) {
      add_failed_mess( "You need to be "+
            "holding $D to $V with it.\n", ({ }) );
      return 0;
   }
   things = filter(things, (: is_in_me_or_environment($1, this_player()) :));
   if (!sizeof(things)) {
      add_failed_mess("You can only $V on objects you are holding or are "
                      "in the room with $D.\n");
      return 0;
   }
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can only $V on one object at once with $D.\n");
      return 0;
   }
   if ( !things[ 0 ]->query_property( "writeable" ) ) {
      add_failed_mess("You cannot $V on $I with $D.\n", things );
      return 0;
   }
   language = (string)this_player()->query_current_language();
   if ( !LANGUAGE_HAND->query_language_written( language ) ) {
      add_failed_mess("You cannot $V $I with $D when you're not "
            "using a language that can be written.\n", things );
      return 0;
   }
   things[ 0 ]->add_read_mess(this_player()->short(0, 1), "cursive, "
        "signed by", language, 0);
   add_succeeded_mess("$N $V $I with $D.\n", things);
   return 1;
}
int do_copy( mixed *in_dir, string direct, string indirect, mixed *args ) {
    mixed src_mess, mess;
    string lang, cur_lang;
    int i, c, siz, perr;
    if ( !present(direct, this_player()) ) return 0;
    if ( query_wielded() != this_player() ) {
        this_player()->add_failed_mess( this_object(), "You need to be "
                                       "holding $D to $V with it.\n", ({ }) );
        return 0;
    }
    if ((sizeof(in_dir) != 2) ||
        (sizeof(in_dir[0]) != 1) || (sizeof(in_dir[1]) != 1)) {
        this_player()->add_failed_mess(this_object(),
                                       "You can only $V to/from one object "
                                       "at a time.\n", ({ }));
        return 0;
    }
    if ( !in_dir[1][0]->query_property( "writeable" ) ) {
        this_player()->add_failed_mess( this_object(), "You can't write on "
                                       "$I.\n", in_dir[1] );
        return 0;
    }
    if ( sizeof(args) == 4 ) {
        if ( !LANGUAGE_HAND->query_language_written(args[3]) ) {
            this_player()->add_failed_mess(this_object(),
                               args[3] + " is not a written language.\n",
                               ({ }));
            return 0;
        }
        if ( LANGUAGE_HAND->query_language_magic(args[3])) {
            this_player()->add_failed_mess(this_object(),
                               "You can't write " + args[3] + " like this.\n",
                               ({ }));
            return 0;
        }
        if ( !this_player()->query_language(args[3]) ) {
            this_player()->add_failed_mess(this_object(),
                               "You don't know " + args[3] + ".\n", ({ }));
            return 0;
        }
        cur_lang = args[3];
    }
    src_mess = in_dir[0][0]->query_read_mess();
    if (!sizeof(src_mess)) {
        write("There is nothing written on " + in_dir[0][0]->the_short() +
              ".\n");
        this_player()->add_failed_mess(this_object(),
                                       "There is nothing written on $I.\n",
                                       in_dir[0]);
        return 0;
    }
    for (i = 0; i < sizeof(src_mess); i++) {
        mess = src_mess[i][0];
        lang = src_mess[i][2];
        siz = src_mess[i][3];
        if (LANGUAGE_HAND->query_language_magic(lang)) {
            mess = "A series of unintelligible scribbles.";
            lang = "common";
        } else if (!this_player()->query_language(lang) && stringp(mess)) {
            perr = this_player()->query_int() + this_player()->query_dex()
              - 20;
            for (c = random(perr); c < sizeof(mess); c += random(perr)+1) {
                if ((mess[c] >= 'a') && (mess[c] <= 'z')) {
                    mess[c] = 'a' + random(26);
                } else if ((mess[c] >= 'A') && (mess[c] <= 'Z')) {
                    mess[c] = 'A' + random(26);
                }
            }
        } else if ( stringp(cur_lang) ) {
            lang = cur_lang;
        }
        in_dir[1][0]->add_read_mess(mess, type, lang, siz);
    }
    this_player()->add_succeeded_mess(this_object(),
                                      "$N $V the writing on $I with $D.\n",
                                      in_dir[0]);
    return 1;
}

==================================================
FILE: misc/s_badge.c
==================================================

#include <mail.h>
#define DOMAIN explode( theres[ i ], "/" )[ 1 ]
#define LORD capitalize( (string)( "/d/"+ DOMAIN +"/master" )->query_lord() )
#define MASTER "/secure/master"
#define HANDLER "/obj/handlers/playtesters"
#define PROTECTION_EFFECT "/d/playtesters/effects/pt_protection"
inherit "/obj/armour";
mapping routes;
int access_mail(string str);
int list_destinations();
int list_transits();
int do_goto(string destination);
void setup() {
   set_name( "badge" );
   set_short( "bejewelled gold badge" );
   add_adjective( "gold" );
   set_long( "This bejewelled gold badge is the mark of a Senior Playtester."
           "  It has a drawing of a womble on the front; it seems to be using"
           " a magnifying glass to examine something.  On the back is "
           "engraved a scroll with some words on it.\n" );
   setup_armour( 100 );
   set_damage_chance( 0 );
   set_type( "badge" );
   reset_drop();
   call_out( (: add_wear_effect :), 0, PROTECTION_EFFECT );
   routes = ([
      "/d/klatch/djel/city/port/riverwalk09" : ({
         "/d/klatch/djel/city/port/pier1",
       }),
      "/d/klatch/djel/city/port/pier1" : ({
        "/d/klatch/djel/city/port/riverwalk09",
       }),
       "/d/am/isle_gods/siege/siege4" : ({
           "/d/am/isle_gods/buildings/parlour/parlor",
       }),
       "/d/am/ninth/ninth1" : ({
          "/d/am/blood/blood01",
       }),
       "/d/ram/ohulan/market/market_c" : ({
         "/d/ram/rambling_trail",
       }),
      "/d/klatch/djel/city/roads/widder35" : ({
         "/d/klatch/ephebe/desert/roads/road5",
       }),
      "/d/am/gates/hubwards" : ({
         "/d/sur/beta/topography/Sto_Plains/s_caravan/entrance",
      }),
    ]);
   set_read_mess( "This badge allows the bearer to move into certain areas "
         "to be playtested from certain entry locations (near to where the "
         "areas will be eventually connected).  To see the possible "
         "destinations from your current room, use the command "
         "\"destinations\", and to move into one of them, use the command "
         "\"goto <label>\" where <label> will be A, B, C, etc..  You can "
         "get a list of all transit points with \"transits\", although no "
         "guarantee is made that each item on this list will be "
         "recognisable.  Please report any problems with rooms not "
         "loading to the relevant domain Lord or Liaison(s)." );
}
void init() {
   string word;
   if ( !environment() )
      return;
   if ( !living( environment() ) )
      return;
   if ( !environment()->query_creator() ) {
      word = (string)environment()->query_name();
      if ( !HANDLER->query_playtester( word ) ) {
         tell_object( environment(), "You are not a playtester.  "
               "The playtester's badge disappears in a flurry of fluff.\n" );
         set_drop();
         move( "/room/rubbish" );
         return;
      }
      if ( HANDLER->query_senior_playtester( word ) ) {
         add_command( "mail", "", (: access_mail(0) :) );
         add_command( "mail", "<string>", (: access_mail($4[0]) :) );
      }
   }
   add_command("destinations", "", (: list_destinations() :) );
   add_command("transits", "", (: list_transits() :) );
   add_command("goto", "<string>", (: do_goto($4[0]) :) );
}
int access_mail( string words ) {
   return (int)MAIL_TRACK->mail( words );
}
int list_destinations() {
  int i;
  string here, *theres;
  object there;
  here = file_name( environment( this_player() ) );
  if ( !sizeof ( theres = routes[ here ] ) )
    return notify_fail( "You cannot use the badge to move from here.\n" );
  write( "From here you can use the badge to move to:\n" );
  for ( i = 0; i < sizeof( theres ); i++ ) {
    if ( !( there = find_object( theres[ i ] ) ) ) {
      if ( file_size( theres[ i ] +".c" ) < 0 ) {
        write( sprintf( "%c: %s cannot be found; please contact %s.\n", 65 + i,
            theres[ i ], LORD ) );
        continue;
      }
      catch( theres[ i ]->force_load() );
      if ( !( there = find_object( theres[ i ] ) ) ) {
        write( sprintf( "%c: %s will not load, please contact %s.\n", 65 + i,
            theres[ i ], LORD ) );
        continue;
      }
    }
    write( sprintf( "%c: %s\n", 65 + i, (string)there->a_short() ) );
  }
  return 1;
}
int list_transits() {
   int i;
   string *theres;
   object there;
   theres = keys( routes );
   if ( !sizeof( theres ) )
      return notify_fail( "There are no transit points at the moment.\n" );
   write( "You can use the badge to move from:\n" );
   for ( i = 0; i < sizeof( theres ); i++ ) {
    if ( !( there = find_object( theres[ i ] ) ) ) {
      if ( file_size( theres[ i ] +".c" ) < 0 ) {
        write( sprintf( "%s cannot be found; please contact %s.\n",
            theres[ i ], LORD ) );
        continue;
      }
      catch( theres[ i ]->force_load() );
      if ( !( there = find_object( theres[ i ] ) ) ) {
        write( sprintf( "%s will not load, please contact %s.\n",
            theres[ i ], LORD ) );
        continue;
      }
    }
    write( sprintf( "   %s\n", (string)there->a_short() ) );
  }
  return 1;
}
int do_goto( string destination ) {
  int i;
  string here, *theres;
  object there;
  i = destination[ 0 ] - 65;
  if ( ( i < 0 ) || ( i > 25 ) ) {
    notify_fail( "The destination label needs to be a capital letter "+
        "between A and Z.\n" );
    return 0;
  }
  here = file_name( environment( this_player() ) );
  if ( !sizeof ( theres = routes[ here ] ) ) {
    notify_fail( "You cannot use the badge to move from here.\n" );
    return 0;
  }
   if ( i >= sizeof( theres ) )
      return notify_fail( "That is not a valid label from here.\n" );
  if ( !( there = find_object( theres[ i ] ) ) ) {
    if ( file_size( theres[ i ] +".c" ) < 0 ) {
      write( theres[ i ] +" cannot be found; please contact "+ LORD +".\n" );
      return 1;
    }
    catch( theres[ i ]->force_load() );
    if ( !( there = find_object( theres[ i ] ) ) ) {
      write( theres[ i ] +" will not load; please contact "+ LORD +".\n" );
      return 1;
    }
  }
  write( "Moving you to "+ (string)there->the_short() +"...\n" );
  this_player()->move_with_look( there, "$N appear$s in a flurry of fluff "
             "that only $N could muster.", "$N disappear$s in a flurry of fluff." );
  return 1;
}

==================================================
FILE: misc/shell.c
==================================================

#include "potion_attrs.h"
#include "library.h"
inherit "/std/object";
#define MY_ROOM "/d/sur/Sto_Plains/n_caravan/picnic_area"
object *demons, cauldron, coin;
void setup() {
  set_weight(10);
  set_value(5);
  set_name("shell");
  add_adjective("sea");
  add_alias("seashell");
  set_short("sea shell");
  set_long("A large conch shell.  It looks like it has been hollowed "+
           "out so that it can be played.  Perhaps if you blew into "+
           "it it might work.\n");
}
void init() {
  this_player()->add_command("blow", this_object());
}
int finish_quest();
int do_blow(object *indir, string s1, string s2, string prep) {
  if (sizeof(indir)) {
    write("Blow "+short(0)+" "+prep+" "+indir->short(0)+"????\n");
    return 0;
  }
  if (file_name(environment(this_player())) == MY_ROOM)
    return finish_quest();
  add_succeeded_mess("$N $V $D and make$s a horrible noise.\n");
  return 1;
}
int finish_quest() {
  object *obs, *obs2, *obs3, ob, fish, frisbee, ladle;
  mixed *attrs;
  string failure;
  int i, j;
  write("The "+short(0)+" blows amazing loudly.\n");
  say(this_player()->one_short()+" blows the "+short(0)+
      " amazingly loudly.\n");
  if (demons) {
    write("Demons glare at you.\n");
    say("Demons glare at "+this_player()->one_short()+".\n");
    return 1;
  }
  obs = all_inventory(environment(this_player()));
  obs3 = obs;
  obs = map_array(obs, "bingle_bit", this_object());
  if ((i=member_array("ladle", obs)) == -1) {
    failure = "no ladle";
  } else {
    ladle = obs3[i];
  }
  if ((i=member_array("frisbee", obs)) == -1) {
    failure = "no frisbee";
  } else {
    frisbee = obs3[i];
  }
  if ((i=member_array("cauldron", obs)) == -1) {
    failure = "no caldron";
  } else {
    cauldron = obs3[i];
      obs2 = match_objects_for_existence("cauldrons", environment(this_player()));
    for (i=0;i<sizeof(obs2);i++) {
      if ((int)obs2[i]->query_volume() < 100 ||
          (int)obs2[i]->query_volume() < (int)obs2[i]->query_max_volume() / 2) continue;
      attrs = (mixed *)obs2[i]->query_misc_attrs();
      if (pointerp(attrs)) attrs = attrs[POTION_NAMES];
      if (pointerp(attrs) && sizeof(attrs) && attrs[0][0] == "yucky ankh water") {
        j++;
      }
    }
    if (!j) {
      failure = "no cauldron full of anhk river water";
    }
  }
  if ((i = member_array("coin", obs)) == -1) {
    failure = "no coin";
  } else {
    coin = obs3[i];
  }
  if ((i=member_array("fish", obs)) == -1) {
    failure = "no fish";
  } else {
    fish = obs3[i];
  }
      obs2 = match_objects_for_existence("toadstools", environment(this_player()));
  obs2 = filter_array(obs2, "bongle_array", this_object());
  if (sizeof(obs2) < 4) {
    failure = "not enough toadstools to sit on";
  }
  if (failure) {
    write("A bunch of hungry looking demons show up.\n");
    write("They look around the clearing.\n");
    write("Mutter to themselves about there being "+failure+".\n");
    write("Demon glares at you.\n");
    say("A bunch of hungry looking demons show up.\n");
    say("They look around the clearing.\n");
    say("Mutter to themselves about there being "+failure+".\n");
    say("Demon glares at "+this_player()->one_short()+".\n");
    return 1;
  }
  demons = allocate(4);
  for (i=0;i<sizeof(demons);i++) {
    demons[i] = clone_object("/std/container");
    demons[i]->set_name("demon");
    demons[i]->reset_get();
    demons[i]->set_long("A small demon with a manic look in his eyes "+
                        "cooking soup.\n");
    demons[i]->move(environment(this_player()));
    obs2[i]->move(demons[i]);
  }
  coin->reset_get();
  cauldron->reset_get();
  fish->dest_me();
  ladle->move(demons[2]);
  frisbee->move(demons[1]);
  say("The demons grab the fish and stick it into the cauldron.  "+
        "They then put the frisbee on the top of the cauldron as a "+
        "lid.  One of the demons grabs the ladle and stirs the "+
        "mixture around a bit whilst the other demons blow on "+
        "cauldron to heat it up.\n");
  call_out("do_finish_it", 10);
  write("The demons grab the fish and stick it into the cauldron.  "+
        "They then put the frisbee on the top of the cauldron as a "+
        "lid.  One of the demons grabs the ladle and stirs the "+
        "mixture around a bit whilst the other demons blow on "+
        "cauldron to heat it up.\n");
  return 1;
}
void do_finish_it() {
  object *obs;
  int i, j;
  say("The soup is obviously hot now, and all the demons sit down "+
        "on their toadstools to enjoy the meal.  After finishing the "+
        "meal, they smile happily.  You hear one of the say on the "+
        "way out, \"Great way to get a meal, it works every time\".\n"+
       "The demons leave taking the table, cauldron and ladle with them.\n");
  write("The soup is obviously hot now, and all the demons sit down "+
        "on their toadstools to enjoy the meal.  After finishing the "+
        "meal, they smile happily and leave.  You hear one of the "+
        "demons say on the "+
        "way out, \"Great way to get a meal, it works every time\".\n"+
       "The demons leave taking the table, cauldron and ladle with them.\n");
  cauldron->dest_me();
  coin->dest_me();
  obs = all_inventory(environment(demons[0]));
  for (i=0;i<sizeof(obs);i++)
    if (interactive(obs[i])) {
      if (!LIBRARY->set_quest(obs[i]->query_name(), "feeding frenzy"))
        continue;
      obs[i]->adjust_xp(5000);
    }
  for (i=0;i<sizeof(demons);i++) {
    obs = all_inventory(demons[i]);
    for (j=0;j<sizeof(obs);j++)
      obs[j]->dest_me();
    demons[i]->dest_me();
  }
  demons = 0;
}
mixed bingle_bit(object ob) {
  return (mixed)ob->query_property("feeding_frenzy");
}
int bongle_array(object ob) {
  return (int)ob->query_property("feeding_frenzy") != 0;
}

==================================================
FILE: misc/shop_owners_guide.c
==================================================

inherit "/std/book_dir";
void setup() {
  set_name("book");
  set_short("brilliant vermillion book");
  add_adjective(({"brilliant", "vermillion"}));
  add_alias("guide");
  set_long("This is a brilliant vermillion coloured book with lots of "
           "pictures of money on the front cover.\n");
  set_read_mess("                   DIY\n\n"
                "          A guide for shop owners.\n");
  set_main_plural("brilliant vermillion books");
  set_weight(10);
  set_value(10);
  set_book_language( "general");
  set_book_dir("/save/books/shop_owner/page");
  set_open_page(0);
  set_ignore_saved_pages(1);
}
int do_tear() {
  return 0;
}
int query_binding_force() {
  return 100;
}

==================================================
FILE: misc/suggestion_box.c
==================================================

inherit "/std/object";
int do_fill();
string _savedir, _savefile;
void setup() {
  set_short( "suggestion box" );
  set_long( "This is a suggestion box.  It is sitting on a pole which puts"
	    " the box at a convienient height for writing.  It has a pile "
	    "of small papers on it on which you can write suggestions.  "
	    "There is a slot in the top for stuffing the suggestion in "
	    "when you're done.\n" );
  set_name( "box" );
  set_main_plural( "boxes" );
  set_read_mess( "\nPlease fill in a suggestion form", "common" );
  add_property( "there", "sitting in the middle of the floor" );
  set_weight( 1000 );
  reset_get();
}
void init() {
  add_command( "fill", "in a suggestion form", (: do_fill() :) );
}
void set_save_file ( string file ) {
  _savefile = file;
  return;
}
void set_save_dir ( string dir ) {
  _savedir = dir;
  return;
}
string query_save_file () {
  return _savefile;
}
string query_save_dir () {
  return _savedir;
}
int do_fill() {
  tell_object( this_player(), "Please fill in your suggestion below.\n" );
  this_player()->do_edit( 0, "end_suggestion", this_object() );
  add_succeeded_mess( ({"", "$N fill$s in a suggestion form and stuff$s "
			  "it in the box.\n" }) );
  return 1;
}
void end_suggestion( string text ) {
  string player, file;
  if( _savefile ) {
    file = _savefile;
  } else if( _savedir ) {
    player = previous_object()->query_name();
    file = sprintf( query_save_dir() + "/%s-%d.txt", player, time() );
  }
  debug_printf( "File: %s", file );
  if( !(unguarded( (: write_file, file, text :) ) ) ) {
    tell_object( previous_object(), "Sorry, your suggestion was not recorded."
		 "  Please use the 'bug object' command to bug report the "
		 "suggestion box.\n" );
    return;
  }
  tell_object( previous_object(), "You fill in a suggestion form and stuff "
	       "it in the box.\n" );
}

==================================================
FILE: misc/teddy.c
==================================================

#define TP this_player()
#define TPCAP this_player()->one_short()
#define TO this_object()
inherit "std/object";
void setup(){
   set_name("bear");
   set_short("teddy bear");
   add_alias("teddy");
   add_adjective("teddy");
   set_long("This is a cute and cuddly teddy bear.  Just the sort to give "
     +"someone you love to remind them of you.  It looks very soft and "
     +"huggable.\n");
   set_weight(10);
   set_value(25);
   set_main_plural("teddy bears");
   add_plural(({"bears", "teddys"}));
}
void init() {
   TP->add_command("hug", TO);
   TP->add_command("cuddle", TO);
}
int do_hug() {
   write("You hug the teddy bear close to you and feel all warm and fuzzy "
     "inside.\n");
   say(TP->one_short()+ " hugs the teddy bear close and smiles happily.\n");
   TP->add_succeeded_mess(TO, "", ({ }) );
   return 1;
}
int do_cuddle() {
  do_hug();
   TP->add_succeeded_mess(TO, "", ({ }) );
   return 1;
}

==================================================
FILE: misc/terrain_shovel.c
==================================================

#include <dirs.h>
#include <terrain.h>
inherit "/std/object";
void setup() {
   set_name( "shovel" );
   set_short( "ceremonial shovel" );
   add_adjective( "ceremonial" );
   set_long( "This is a small ceremonial shovel, carried by those "+
         "responsible for the care, upkeep and expansion of "+
         "dungeons.\n" );
}
void init() {
   if ( this_player()->query_creator() ) {
      add_action( "do_add", "add" );
      add_action( "do_remove", "remove" );
      add_action( "do_visit", "visit" );
   }
}
int do_add( string words ) {
   int i, distance, level, *new_co_ord, *old_co_ord, *vector;
   string direc, file, terrain, type;
   object room, *things;
   if ( !words )
      return notify_fail( "Add what?\n" );
   if ( sscanf( words, "%s %s %s", type, file, direc ) != 3 )
      return notify_fail( "Syntax: add fixed|floating <file> <direction>\n" );
   i = member_array( direc, STD_ORDERS );
   if ( i == -1 )
      return notify_fail( capitalize( direc ) +" is not a valid "+
            "direction.\n" );
   room = environment( this_player() );
   if ( room->query_exit( direc ) )
      return notify_fail( "There is already an exit to the "+
            direc +".\n" );
   vector = STD_ORDERS[ i + 1 ];
   if ( file_size( file +".c" ) < 0 )
      return notify_fail( capitalize( file ) +" does not exist.\n" );
   file->force_load();
   if ( !find_object( file ) )
      return notify_fail( capitalize( file ) +" will not load.\n" );
   distance = (int)file->query_room_size() +
         (int)room->query_room_size();
   old_co_ord = (int *)room->query_co_ord();
   if ( sizeof( old_co_ord ) != 3 )
      return notify_fail( "Environment does not have coordinates.\n" );
   new_co_ord = allocate( 3 );
   for ( i = 0; i < 3; i++ )
      new_co_ord[ i ] = old_co_ord[ i ] - distance * vector[ i ];
   terrain = (string)room->query_property( "terrain name" );
   if ( !terrain )
      return notify_fail( "Environment is not in the terrain "+
            "handling system.\n" );
   switch( type ) {
      case "fixed" :
         i = (int)TERRAIN_MAP->add_fixed_location( terrain,
               file, new_co_ord );
         break;
      case "floating" :
         i = (int)TERRAIN_MAP->add_floating_location( terrain,
               file, new_co_ord, level );
         break;
      default :
         return notify_fail( "Type must be fixed or floating.\n" );
   }
   if ( !i )
      return notify_fail( "Failed to add "+ file +" ("+ type +
            ") to "+ terrain +" at "+ new_co_ord[ 0 ] +", "+
            new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +".\n" );
   write( "Added "+ file +" ("+ type +") to "+ terrain +" at "+
         new_co_ord[ 0 ] +", "+ new_co_ord[ 1 ] +", "+
         new_co_ord[ 2 ] +".\n" );
   if ( type == "fixed" )
      file->dest_me();
   TERRAIN_MAP->clear_connections( terrain );
   TERRAIN_MAP->delete_cloned_location( terrain, file_name( room ) );
   things = all_inventory( room );
   things->move( "/room/void" );
   room->dest_me();
   room = (object)TERRAIN_MAP->find_location( terrain, old_co_ord );
   things->move( room );
   return 1;
}
int do_remove() {
   write( "This function has not been written yet.\n" );
   return 1;
}
int do_visit( string words ) {
   int x, y, z;
   string terrain;
   object room;
   if ( !words )
      return notify_fail( "Visit where?\n" );
   if ( sscanf( words, "%s %d %d %d", terrain, x, y, z ) != 4 )
      return notify_fail( "Syntax: visit <terrain> <x co-ord> "+
            "<y co-ord> <z co-ord>\n" );
   room = (object)TERRAIN_MAP->find_location( terrain, ({ x, y, z }) );
   if ( !objectp( room ) )
      return notify_fail( "There is no location at ("+ x +","+ y +","+ z +
            ") in \""+ terrain +"\".\n" );
   this_player()->move_with_look( room, "There is a strange smell, like "+
         "freshly broken earth, and $N appear$s.", "With a squelch, "+
         "$N vanish$s." );
   return 1;
}

==================================================
FILE: misc/tin_of_paint.c
==================================================

inherit "/obj/vessel";
#define VOLUME 5000
private nosave string _colour;
varargs int do_paint(string, object);
void setup() {
  set_name( "tin" );
  set_short( "tin of paint" );
  set_main_plural( "tins of paint");
  add_adjective( ({ "tin", "of"}));
  add_alias(({"paint"}));
  set_long( "A tin of paint.  It has a picture of a man with "
            "a big smile on his face painting a wall.\n");
  set_leak_rate( 0 );
  set_max_volume( VOLUME );
  set_value( 30 );
  set_weight( 10 );
  set_max_weight( 30 );
}
void setup_attribs() {
  set_short( "tin of " + _colour + " paint" );
  set_main_plural( "tins of " + _colour + " paint");
  add_adjective( ({ _colour}));
  set_long( "A tin of " + _colour + " paint.  It has a picture of a man with "
            "a big smile on his face painting a wall.\n");
}
void make_tin( string colour ) {
  object liquid;
  liquid = clone_object( "/obj/reagents/generic_liquid.ob" );
  liquid->set_name( "paint" );
  liquid->set_short( colour + " paint" );
  liquid->add_adjective(({colour }));
  liquid->set_amount( VOLUME );
  liquid->set_continuous();
  liquid->set_long( "This is " + colour + " paint, it's thick and gloopy.\n");
  liquid->set_pile_name( "puddle" );
  liquid->add_eat_effect( "/std/effects/ingested/poison", 10 );
  liquid->move( this_object() );
  set_closed();
  _colour = colour;
  setup_attribs();
}
void init() {
  ::init();
  this_player()->add_command("paint", this_object(),
           "<indirect:object:here'cardinal direction'> with <direct:object'paint'>",
                        (: do_paint( $4[0] ) :));
  this_player()->add_command("paint", this_object(),
                        "<string'part'> on <indirect:object:here> with <direct:object'paint'>",
                        (: do_paint( $4[0], $1[0] ) :));
  this_player()->add_command("paint", this_object(),
            "<indirect:object:here> help",
            (: do_paint( 0, $1[0] ) :));
}
varargs int do_paint(string indirect, object target) {
  object *obs;
  if(!indirect && target) {
      if(function_exists("what_to_paint", target))
          printf(target->what_to_paint());
      else
          printf("Help: paint " + target->short() + " with paint\n");
      return 1;
  }
  obs = match_objects_for_existence("paint", this_object());
  if(!query_volume() || !sizeof(obs)) {
    this_player()->add_failed_mess(this_object(), "$D appears to be empty.\n",
                                   ({ }));
    return 0;
  }
  if(query_closed()) {
    this_player()->add_failed_mess(this_object(), "$D is closed.\n", ({ }));
    return 0;
  }
  if(!sizeof(filter(this_player()->query_holding() - ({ 0 }),
                    (: $1->id("paint brush") :)))) {
    this_player()->add_failed_mess(this_object(), "You must be holding a "
                                   "paint brush to paint the walls.\n", ({ }));
    return 0;
  }
  if(!environment(this_player())->test_occupier(this_player()->query_name())) {
    this_player()->add_failed_mess(this_object(),
                                   "You don't own this house.\n", ({ }));
    return 0;
  }
  if(target) {
      if(!target->query_short()) return 0;
          if(!function_exists("decorate_part", target)) {
                  this_player()->add_failed_mess(this_object(), "You can't $V the " +
                                indirect + " on the " + target->query_short() + "!\n", ({ }));
                  return 0;
          }
          if(!target->decorate_part( indirect, obs[0]->query_short() )) {
                  this_player()->add_failed_mess(this_object(), "You can't $V the " +
                                                                        indirect + ".\n", ({ }));
                  return 0;
          }
          this_player()->add_succeeded_mess(this_object(), "$N $V the " +
                                    indirect + " on the " + target->query_short() +
                                                                        " with the brush using light, smooth strokes.\n", ({ }));
          return 1;
  }
  if(!function_exists("decorate_surface", environment(this_player()))) {
    this_player()->add_failed_mess(this_object(), "You can't $V the walls "
                                   "here.\n", ({ }));
    return 0;
  }
  if(!environment(this_player())->
     decorate_surface(indirect, "covered with " + obs[0]->query_short())) {
    this_player()->add_failed_mess(this_object(), "You can't $V the " +
                                   indirect + ".\n", ({ }));
    return 0;
  }
  remove_volume(query_volume());
  this_player()->add_succeeded_mess(this_object(), "$N $V the " +
                                    indirect + " with $D using "
                                    "broad, smooth strokes.\n", ({ }));
  return 1;
}
mapping int_query_static_auto_load() {
  mapping tmp;
  tmp = ::int_query_static_auto_load();
  return ([ "::" : tmp,
          "colour" : _colour,
          ]);
}
mapping query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}
void init_static_arg(mapping args) {
  if (args["::"])
    ::init_static_arg(args["::"]);
  if (!undefinedp(args["colour"]))
    _colour = args["colour"];
  if(_colour)
    setup_attribs();
}

==================================================
FILE: misc/top_clubs.c
==================================================

#include <top_ten_tables.h>
#include <clubs.h>
inherit "/std/object";
private string _lang = "morporkian";
string _long();
void setup() {
   set_name( "table" );
   set_short( "top club table" );
   set_long("This is a table listing those clubs that are most "
            "advanced in certain aspects.\n");
   add_adjective( ({ "top", "club", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
   call_out("setup_read_mess", 5);
}
void setup_read_mess() {
   add_read_mess((: _long() :), 0, _lang, 0);
}
void set_language(string lang) {
  _lang = lang;
}
string query_language() { return _lang; }
string club_name(string str) {
   if (!str) {
      return "Unknown";
   }
   return CLUB_HANDLER->query_club_name(str);
}
string _long() {
   mixed *stuff;
   string bing, str;
   string guild;
   string *g_sorted;
   mapping g_info;
   stuff = TOP_TEN_HANDLER->query_club_info();
   str = "The club with:\n"
         "The most members          : " +
         club_name(stuff[TOP_TEN_LARGEST_FAMILY])  + "\n"
         "The oldest average age    : " +
         club_name(stuff[TOP_TEN_OLDEST_FAMILY]) + "\n"
         "Most average quest points : " +
         club_name(stuff[TOP_TEN_MOST_QUEST_POINTS]) + "\n"
         "Most player killers       : " +
         club_name(stuff[TOP_TEN_MOST_PKS]) + "\n"
         "Largest single gender     : " +
         club_name(stuff[TOP_TEN_SINGLE_GENDER]) + "\n"
         "Oldest start DW time      : " +
         club_name(stuff[TOP_TEN_OLDEST_LOGONS]) + "\n"
         ;
   g_info = stuff[TOP_TEN_MOST_GUILD];
   g_sorted = sort_array(filter(keys(g_info), (: stringp($1) &&
                                                 file_size($1 + ".c") > 0 :)),
                         (: strcmp($1->query_name(), $2->query_name()) :));
   foreach (guild in g_sorted) {
      if (stringp(guild)) {
         bing = g_info[guild];
         str += sprintf("%-26s: %s\n",
               "Most " + (guild->query_name()),
               club_name(bing));
      }
   }
   str += "\nTo get onto the average list the club must have more than "
          "3 members that are not creators.\n";
   return str;
}

==================================================
FILE: misc/top_families.c
==================================================

#include <top_ten_tables.h>
#include <clubs.h>
inherit "/std/object";
private string _lang = "morporkian";
string _long();
void setup() {
   set_name( "table" );
   set_short( "top family table" );
   set_long("This is a table listing those families that are most "
            "advanced in certain aspects.\n");
   add_adjective( ({ "top", "family", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
   call_out("setup_read_mess", 5);
}
void setup_read_mess() {
   add_read_mess((: _long() :), 0, _lang, 0);
}
void set_language(string lang) {
  _lang = lang;
}
string query_language() { return _lang; }
string club_name(string str) {
   if (!str) {
      return "Unknown";
   }
   return CLUB_HANDLER->query_club_name(str);
}
string _long() {
   mixed *stuff;
   string bing, str;
   string guild;
   mapping g_info;
   string *g_sorted;
   stuff = TOP_TEN_HANDLER->query_family_info();
   str = "The family with:\n"
         "The most members          : " +
         club_name(stuff[TOP_TEN_LARGEST_FAMILY])  + "\n"
         "The oldest average age    : " +
         club_name(stuff[TOP_TEN_OLDEST_FAMILY]) + "\n"
         "Most average quest points : " +
         club_name(stuff[TOP_TEN_MOST_QUEST_POINTS]) + "\n"
         "Most player killers       : " +
         club_name(stuff[TOP_TEN_MOST_PKS]) + "\n"
         "Largest single gender     : " +
         club_name(stuff[TOP_TEN_SINGLE_GENDER]) + "\n"
         "Oldest start DW time      : " +
         club_name(stuff[TOP_TEN_OLDEST_LOGONS]) + "\n"
         "Most average relationships: " +
         club_name(stuff[TOP_TEN_MOST_RELATIONSHIPS]) + "\n";
   g_info = stuff[TOP_TEN_MOST_GUILD];
   g_sorted = sort_array(filter(keys(g_info), (: stringp($1) &&
                                                 file_size($1 + ".c") > 0 :)),
                         (: strcmp($1->query_name(), $2->query_name()) :));
   foreach (guild in g_sorted) {
      if (stringp(guild)) {
         bing = g_info[guild];
         str += sprintf("%-26s: %s\n",
               "Most " + (guild->query_name()),
               club_name(bing));
      }
   }
   str += "\nTo get onto the average list the family must have more than "
          "3 members that are not creators.\n";
   return str;
}

==================================================
FILE: misc/top_ten_tables.c
==================================================

#include <top_ten_tables.h>
inherit "/std/object";
string generate_list( mixed *args );
string generate_table_message();
nosave string table_name;
nosave string language = "morporkian";
void setup() {
   table_name = 0;
   set_name( "table" );
   set_short( "top ten table" );
   set_long( "This is a perfectly rectangular wooden board, "
     "nailed to another piece of wood.\n" );
   add_adjective( ({ "top", "ten", "score" }) );
   reset_get();
   add_property( "there", "in one corner" );
   add_property( "survive fire", 1 );
   call_out( "setup_read_mess", 5 );
   call_out("dest_me", 30);
}
string query_table_name() { return table_name; }
void set_table_name( string word ) { table_name = word; }
void set_language( string lang ) {
  language = lang;
}
void setup_read_mess() {
   add_read_mess((: generate_table_message() :), 0, language, 0);
}
string generate_table_message() {
   string long;
   mixed *args;
   long = "\nHigh Score Table: ";
   args = (mixed *)TOP_TEN_HANDLER->query_ordered_table( table_name );
   if ( !table_name ) {
      long += "All Players";
      if ( !sizeof( args ) )
         return long +": There is no overall top ten at present.\n";
   } else {
      if ( file_size( "/std/guilds/"+ table_name +".c" ) < 0 )
         return "*Barf!* Can't find /std/guilds/"+ table_name +".\n";
      long += capitalize( (string)( "/std/guilds/"+ table_name )->
                     query_name() ) + "' Guild";
      if ( !sizeof( args ) )
         return long +": There is no top ten for this guild at present.\n";
   }
   return sprintf( "%|*s\n", table_name ? 40 : 50, long ) +
          sprintf( "%|*s\n", table_name ? 40 : 50, "Sorted by rating" ) +
          sprintf( "%|*s\n\n", table_name ? 40 : 50,
                   "-=- " + ctime(time()) + " -=-" ) +
          generate_list(args) + "\n";
}
string convert_age( int number ) {
   if ( number > 86400 )
      return ( number / 86400 ) +"D";
   if ( number > 3600 )
      return ( number / 3600 ) +"h";
   if ( number > 60 )
      return ( number / 60 ) +"m";
   return number +"s";
}
string generate_list( mixed *args ) {
   int i, number, sum;
   string format, list;
   if ( table_name )
      format = "  %2d. %-13s: level %4d  %5s";
   else
      format = "  %2d. %-23s: level %4d  %5s";
   format += "\n";
   list = "";
   number = sizeof( args );
   sum = 0;
   for ( i = 0; i < number; i++ )  {
      list += sprintf( format, i + 1, capitalize( args[ i ][ TOP_TEN_NAME ] ),
            args[ i ][ TOP_TEN_LEVEL ],
            convert_age( args[ i ][ TOP_TEN_AGE ] ) );
      if ( i > 0  &&  i < number - 1 )  {
         sum += args[i][TOP_TEN_RATING];
      }
   }
   return list;
}

==================================================
FILE: misc/torch.c
==================================================

#include <fuel_handler.h>
#include <move_failures.h>
inherit "/std/object";
inherit "/std/basic/holdable";
#define BRIGHTNESS 30
#define MAX_FUEL 2000
#define FUEL_PER_TICK ( FUEL_TIME * 2 )
private int amount_of_fuel;
private int is_lit;
int finish_it();
void setup_shorts();
void create() {
   object::create();
   holdable::create();
}
void setup() {
   amount_of_fuel = MAX_FUEL;
   set_name( "torch" );
   add_plural( "torches" );
   setup_shorts();
   add_help_file("torch");
   set_long( function() {
      string str;
      if ( is_lit && amount_of_fuel) {
         call_out( (: setup_shorts() :), 2 );
         str = "This is a fire burning out of control on the end "
            "of a stick of wood.  There is a lot of smoke coming "
            "off the fire, of the kind that, no matter which "
            "way you turn, will go up your nose.";
         switch ( amount_of_fuel / ( MAX_FUEL / 10 ) ) {
          case 10 :
          case 9  :
            return str+"  The torch looks brand new, it will burn for "
               "ages yet.\n";
          case 8 :
          case 7 :
          case 6 :
            return str+"  Not yet burning for very long, this torch is "
               "pretty happy with itself.  It doesn't seem "
               "to care about its short life span.\n";
          case 5 :
          case 4 :
            return str+"  The torch is happily burning.  It is in the "
               "prime of its life.\n";
          case 3 :
            return str+"  The torch has a little way to go yet, as it is "
               "now burning the light wood.\n";
          case 2 :
            return str+"  It looks like this torch won't "
               "last much longer.  Buying a new one would "
               "probably be a good investment.\n";
          case 1 :
          case 0 :
            return str+"  The torch is spluttering, there are huge "
               "amounts of smoke coming off it.  It looks like "
               "it is about to go out.\n";
         }
      }
      if ( amount_of_fuel >= MAX_FUEL )
         return "This lump of what looks like some sort of tree has a few "
         "dirty rags wrapped around the end of it, and it looks as "
         "though it might be possible to light them.  The dirty rags "
         "have some sort of stuff covering them, probably "
         "to make them burn better.\n";
      if ( amount_of_fuel > MAX_FUEL / 2 )
         return "Someone has cut down a tree, chopped it up into smaller "
         "chunks and then wrapped the end in some rags.  "
         "The rags are blackened and it looks like someone set "
         "fire to them.  Perhaps you can too?\n";
      str = "This lump of what looks like some sort of tree has a few "
         "dirty rags wrapped around the end.  ";
      if ( !amount_of_fuel )
         return str +"The end is completely blackened.  You would "
         "have to be extremely clever to get this torch "
         "going again.\n";
      switch (amount_of_fuel/(MAX_FUEL/10)) {
       case 5 :
       case 4 :
         return str +"The end has been blackened quite a bit, "
            "but it looks like there is a fair bit of "
            "go still left in it.\n";
       case 3 :
       case 2 :
         return str +"A few rags here and there cling to a meager "
            "existence.  You could set fire to them and "
            "make their life hell for a little while, but "
            "not for very long.\n";
       case 1 :
       case 0 :
         return str +"You can just see the remains of some rags "
            "attached to the blackened and burnt end of "
            "the torch.  It will last only for a short while "
            "longer.\n";
      }
      return "Whoops.  Tell a creator if you see this.\n";
   }
            );
   is_lit = 0;
   set_weight( 6 );
   set_value( 50 );
}
void set_fuel(int f) {
   amount_of_fuel = f;
   if(amount_of_fuel < 0)
     amount_of_fuel = 0;
   setup_shorts();
}
void init() {
  this_player()->add_command( "light", this_object() );
  this_player()->add_command( "extinguish", this_object() );
  this_player()->add_command( "dowse", this_object() );
}
void setup_shorts() {
   if ( is_lit && amount_of_fuel) {
      set_short( "lit torch" );
      set_main_plural( "lit torches" );
      remove_adjective( ({ "lightable", "burnt", "out" }) );
      add_adjective( "lit" );
   } else if ( amount_of_fuel > 0 ) {
      set_short( "lightable torch" );
      set_main_plural( "lightable torches" );
      remove_adjective( ({ "lit", "burnt", "out" }) );
      add_adjective( "lightable" );
   } else {
      set_short( "burnt torch" );
      set_main_plural( "burnt torches" );
      remove_adjective( ({ "lit", "lightable" }) );
      add_adjective( ({ "burnt", "out" }) );
   }
}
int do_light() {
   if (environment(this_object()) != this_player()) {
      this_player()->add_failed_mess( this_object(),
                                     "You are not carrying $D.\n", ({ }) );
      return 0;
   }
   if (amount_of_fuel <= 0) {
      this_player()->add_failed_mess( this_object(), "$D is burnt out.\n",
                                     ({ }) );
      return 0;
   }
   if (is_lit) {
      this_player()->add_failed_mess( this_object(), "$D is already lit.\n",
                                     ({ }) );
      return 0;
   }
   if (!query_holder() &&
       !sizeof( this_object()->hold_item( this_player(), -1 ) ) ) {
     this_player()->add_failed_mess( this_object(), "Unable to hold $D, "
         "your arms are probably full.\n", ({ }) );
      return 0;
   }
   is_lit = 1;
   FUEL_HANDLER->add_burner( this_object() );
   set_light( BRIGHTNESS );
   call_out( "setup_shorts", 2);
   return 1;
}
void out_of_fuel() {
   is_lit = amount_of_fuel = 0;
   set_light( 0 );
   set_value( 0 );
   FUEL_HANDLER->remove_burner( this_object() );
   tell_room( environment(), one_short() +" splutters violently "
     "for the last time before it crumbles to dust.\n" );
   call_out( "finish_it", 2 );
}
void do_warning() {
   tell_room( environment(), poss_short() +" starts to sputter and smoke a "
             "lot as it is now burning the light wood.  It is on its last "
             "legs.\n");
   return;
}
void consume_fuel() {
   amount_of_fuel -= FUEL_PER_TICK;
   if(amount_of_fuel < 0)
     amount_of_fuel = 0;
   switch ( amount_of_fuel ) {
    case (200-FUEL_PER_TICK) .. 200:
      do_warning();
      break;
    case 0:
      out_of_fuel();
      break;
    default:
   }
}
int do_extinguish(object *, string, string, string) {
   if ( !is_lit && objectp( this_player() ) ) {
      this_player()->add_failed_mess(this_object(), "$D is not lit.\n", ({ }) );
      return 0;
   } else if ( !is_lit ) {
      return 0;
   }
   FUEL_HANDLER->remove_burner( this_object() );
   is_lit = 0;
   set_light( 0 );
   call_out( "setup_shorts", 2);
   return 1;
}
int do_dowse() {
   return do_extinguish(({ }), 0, 0, 0);
}
void dest_me() {
   FUEL_HANDLER->remove_burner( this_object() );
   set_light( 0 );
   holdable::dest_me();
   object::dest_me();
}
mixed *stats() {
  return ::stats() + ({
    ({ "fuel" , amount_of_fuel, }),
    ({ "is lit", is_lit, }),
   });
}
mixed query_dynamic_auto_load() {
  return ([ "::" : object::query_dynamic_auto_load(),
            "amount of fuel" : amount_of_fuel,
            "hold" : holdable::query_dynamic_auto_load(),
            "is lit" : is_lit,
          ]);
}
int held_this_item(int type, object holder, mixed arg) {
   if (!type) {
      if (holder && is_lit) {
         tell_object( holder,
                     "You extinguish the "+ short() +" as you put it down.\n");
         tell_room( environment(holder ),
                   holder->short() +" extinguishes the "+
                   short() +" as "+ holder->query_pronoun()
                   +" puts it down.\n", ({ holder }));
      }
      do_extinguish( ({ }), "", "", "");
   } else if (type == 2) {
      if (arg && holder && amount_of_fuel > 0) {
         set_light( BRIGHTNESS );
         FUEL_HANDLER->add_burner( this_object() );
         is_lit = 1;
      } else {
         is_lit = 0;
      }
      setup_shorts();
   }
   return 1;
}
void init_dynamic_arg( mapping arg ) {
   amount_of_fuel = arg["amount of fuel"];
   is_lit = arg["is lit"];
   if (arg["hold"]) {
      holdable::init_dynamic_arg(arg["hold"], arg["is lit"]);
   }
   ::init_dynamic_arg(arg["::"]);
}
void init_static_arg(mapping arg) {
}
mapping query_static_auto_load() {
   return 0;
}
varargs int move( mixed ob, string mess1, string mess2 ) {
   int ret;
   ret = holdable::move(ob);
   if (ret != MOVE_OK) {
      return ret;
   }
   return object::move( ob, mess1, mess2 );
}
void self_light() {
   is_lit = 1;
   FUEL_HANDLER->add_burner( this_object() );
   set_light( BRIGHTNESS );
   call_out( (: setup_shorts() :), 2);
   return;
}
  int finish_it () {
    this_object()->move( "/room/rubbish" );
    return 1;
}
int query_torch() {
  return 1;
}
int query_lit() {
  return is_lit;
}
int query_fuel() {
  return amount_of_fuel;
}

==================================================
FILE: misc/trap.c
==================================================

#include <move_failures.h>
#include <tasks.h>
inherit "/std/object";
int difficulty;
string trigger;
string description;
mixed message;
mixed effect;
void create() {
  add_help_file("door_trap");
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void make_trap(int diff, string trig, string desc, mixed mess, mixed eff) {
  difficulty = diff;
  trigger = trig;
  description = desc;
  message = mess;
  effect = eff;
}
void init() {
  this_player()->add_command("rig", this_object(),
           "<indirect:object:here> with <direct:object:me>");
}
int do_rig(mixed *in_dir, string direct, string indirect, mixed *args,
             string) {
  object ob;
  object other;
  if(sizeof(in_dir) > 1) {
    this_player()->add_failed_mess(this_object(), "A trap can only be rigged "
                                   "on a single item.\n");
    return 0;
  }
  if(!difficulty) {
    this_player()->add_failed_mess(this_object(), "$D appears to be "
                                   "broken.\n");
    return 0;
  }
  ob = in_dir[0];
  if(ob->query_trap_difficulty() && ob->query_trap_armed()) {
    this_player()->add_failed_mess(this_object(),
                                   "$I already has an armed trap on it.\n",
                                   ({ in_dir[0] }));
    return 0;
  }
  if(!function_exists("setup_trap", ob, 0)) {
    this_player()->add_failed_mess(this_object(), "$I cannot be $Ved with "
                                   "$D.\n", ({ ob }));
    return 0;
  }
  if((trigger == "pick" || trigger == "unlock") &&
     (!ob->query_key() || ob->query_key() == "generic_key")) {
    this_player()->add_failed_mess(this_object(), "$I doesn't have a lock "
                                   "so $Vging it with $D which is triggered "
                                   "by " + trigger + "ing makes no sense.\n",
                                   ({ ob }));
    return 0;
  }
  switch(TASKER->perform_task(this_player(), "covert.items.traps", difficulty,
                              TM_FREE)) {
  case AWARD:
    write("%^YELLOW%^You feel you have learned something about rigging "
          "traps.%^RESET%^\n");
  case SUCCEED:
    difficulty +=
      random(this_player()->query_skill_bonus("covert.items.traps") / 10);
    break;
  default:
    if(random(difficulty) >
       this_player()->query_skill_bonus("covert.items.traps") ||
       difficulty >
       this_player()->query_skill_bonus("covert.items.traps") * 2) {
      if(arrayp(message)) {
        write(message[0]);
        say(message[1], this_player());
      } else
        write(message);
      if(intp(effect)) {
        if(effect > this_player()->query_hp())
          this_player()->do_death();
        else
          this_player()->adjust_hp(-(effect));
      } else if(arrayp(effect)) {
        switch(sizeof(effect)) {
        case 1:
          this_player()->add_effect(effect[0]);
          break;
        case 2:
          this_player()->add_effect(effect[0], effect[1]);
          break;
        default:
          this_player()->add_effect(effect[0], effect[1..]);
        }
      } else
        this_player()->add_effect(effect);
      this_object()->move("/room/rubbish");
      this_player()->add_succeeded_mess(this_object(), "As $N attempt$s to "
                                        "$V $D it goes off!\n");
      return 1;
    } else {
      difficulty -= random(difficulty -
                    this_player()->query_skill_bonus("covert.items.traps"));
    }
  }
  ob->setup_trap(difficulty, trigger, description, message, effect);
  if(function_exists("query_my_room", ob)) {
    other = load_object( (string)( ob->query_dest() ) );
    other = other->query_door_control( (string)( ob->query_other_id() ) );
    other->setup_trap(difficulty, trigger, description, message, effect);
    environment(this_player())->update_doors();
  }
  this_player()->add_succeeded_mess(this_object(), "$N carefully $V $I "
                                    "with $D.\n",
                                    ({ ob }));
  call_out("break_me", 1);
  return 1;
}
void break_me() {
  object ob;
  ob = clone_object("/std/object");
  ob->set_name("trap");
  ob->set_short("busted trap");
  ob->set_long("A broken trap.\n");
  ob->set_value(0);
  ob->set_weight(this_object()->query_weight());
  ob->move(environment());
  if(this_object()->move("/room/rubbish") != MOVE_OK)
    this_object()->dest_me();
}
mapping int_query_static_auto_load() {
  mapping tmp;
  tmp = ::int_query_static_auto_load();
  return ([ "::" : tmp,
            "difficulty" : difficulty,
            "trigger" : trigger,
            "description" : description,
            "message" : message,
            "effect" : effect
            ]);
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}
void init_static_arg(mapping map) {
  if(!mapp(map))
    return;
  if(!undefinedp(map["::"]))
    ::init_static_arg(map["::"]);
  if(!undefinedp(map["difficulty"]))
    difficulty = map["difficulty"];
  if(!undefinedp(map["trigger"]))
    trigger = map["trigger"];
  if(!undefinedp(map["description"]))
    description = map["description"];
  if(!undefinedp(map["message"]))
    message = map["message"];
  if(!undefinedp(map["effect"]))
    effect = map["effect"];
}

==================================================
FILE: misc/tray.c
==================================================

#include <move_failures.h>
inherit "/std/surface";
inherit "/std/basic/holdable";
inherit "/std/basic/wearable";
void create() {
  wearable::create();
  holdable::create();
  surface::create();
}
void setup() {
  set_name( "tray" );
  set_short( "wooden tray" );
  set_long( "This is a small wooden tray, similar in style to the ones used by "
    "many vendors and travelling salespeople. Only a small quantity of items will "
    "fit on top of it.\n" );
  add_adjective(({ "small", "wooden" }));
  set_material("wood");
  set_weight(5);
  set_max_weight(40);
  set_no_limbs(2);
  set_type("sash");
  set_cond(1000);
  set_max_cond(1000);
  add_wear_effect( "/std/effects/attached/single_shoulder" );
}
string long( string word, int dark ) {
  return surface::long() + wearable::long();
}
varargs int move( mixed dir, string messin, string messout ) {
  if ( holdable::move( dir, messin, messout ) == MOVE_OK ) {
	  return surface::move( dir, messin, messout );
  }
  return MOVE_NO_UNHOLD;
}
mapping query_static_auto_load() {
mapping map = ([ ]);
  map["holdable"] = holdable::query_static_auto_load();
  map["surface"] = surface::query_static_auto_load();
  map["wearable"] = wearable::query_static_auto_load();
  return map;
}
void init_static_arg( mapping map ) {
  if (!undefinedp( map["holdable"] ) )
	holdable::init_static_arg( map["holdable"] );
  if ( !undefinedp( map["surface"] ) && map["surface"] )
	surface::init_static_arg( map["surface"] );
  if ( !undefinedp( map["wearable"] ) && map["wearable"] )
	surface::init_static_arg( map["wearable"] );
}
void dest_me() {
  holdable::dest_me();
  surface::dest_me();
}
mapping query_dynamic_auto_load() {
mapping map = ([ ]);
  map["holdable"] = holdable::query_dynamic_auto_load();
  map["surface"] = surface::query_dynamic_auto_load();
  map["wearable"] = wearable::query_dynamic_auto_load();
  return map;
}
varargs void init_dynamic_arg( mapping map, mixed new_arg ) {
  if (!undefinedp( map["holdable"] ) )
	holdable::init_dynamic_arg( map["holdable"] );
  if ( !undefinedp( map["surface"] ) && map["surface"] )
	surface::init_dynamic_arg( map["surface"] );
  if ( !undefinedp( map["wearable"] ) && map["wearable"] )
	surface::init_dynamic_arg( map["wearable"] );
}
mixed stats() {
	return surface::stats() + wearable::stats();
}

==================================================
FILE: misc/wallpaper.c
==================================================

inherit "/std/object";
private nosave string _design;
varargs int do_paper(string indirect, object pot);
void setup() {
    set_name( "wallpaper" );
    set_short( "roll of wallpaper" );
    set_main_plural( "rolls of wallpaper");
    add_adjective( ({ "roll", "of"}));
    add_plural_adjective("rolls");
    add_alias(({"paper"}));
    set_long( "This is a large roll of wallpaper, probably enough to "
        "cover a single wall completely.\n");
    set_value( 480 );
    set_weight( 10 );
}
void make_roll( string design ) {
    _design = design;
    set_short( "roll of " + _design + " wallpaper" );
    set_main_plural( "rolls of " + _design + " wallpaper");
    add_adjective( ({ _design })) ;
    set_long( "This is a large roll of " + _design + " wallpaper.  It "
        "looks like there's just enough of it to cover a single wall "
        "completely.  If you had some wallpaper glue you could probably "
        "paste it to the wall.\n");
}
void init() {
    this_player()->add_command("paste", this_object(),
       "<direct:object> to <indirect:object:here'cardinal direction'> using <indirect:object'pot'>", (: do_paper( $4[1], $1[1][0] ) :));
}
string query_paper_mess() {
    if( _design ) {
        return _design + " wallpaper";
    }
    else {
        return "strangely featureless wallpaper";
    }
}
varargs int do_paper(string indirect, object pot) {
    object *obs;
    if(!indirect && pot) {
        if(function_exists("what_to_paint", pot))
            printf(pot->what_to_paint());
        else
            printf("Help: paste " + pot->short() + " with wallpaper\n");
            return 1;
    }
    obs = match_objects_for_existence("glue", pot);
    if(pot->query_closed()) {
        this_player()->add_failed_mess(this_object(), "$I is "
            "closed.\n", ({ pot }));
        return 0;
    }
    if(!pot->query_volume(obs) || !sizeof(obs)) {
        this_player()->add_failed_mess(this_object(), "$I appears to "
            "be empty.\n", ({ pot }));
        return 0;
    }
    if(!sizeof(filter(this_player()->query_holding() - ({ 0 }),
        (: $1->id("brush") :)))) {
        this_player()->add_failed_mess(this_object(), "You must be holding a "
            "paint brush to paint the walls with glue.\n", ({ }));
        return 0;
    }
    if(!environment( this_player() )->test_occupier( this_player()->
        query_name() ) ) {
        this_player()->add_failed_mess(this_object(), "You don't own this "
            "house.\n", ({ }));
        return 0;
    }
    if(!function_exists("decorate_surface", environment(this_player()))) {
        this_player()->add_failed_mess(this_object(), "You can't $V the "
            "walls here.\n", ({ }));
        return 0;
    }
    if(!environment(this_player())->decorate_surface(indirect,
        "papered with " + query_paper_mess())) {
        this_player()->add_failed_mess(this_object(), "You can't $V the $D"
            " to the " + indirect + " using $I for some reason.\n",
            ({ pot }));
        return 0;
    }
    pot->remove_volume(pot->query_volume());
    this_object()->move("/room/rubbish");
    this_player()->add_succeeded_mess(this_object(), "$N $V $D to the " +
        indirect + ", dawbing it with paste from $I and pressing it firmly "
        "against the surface.\n", ({ pot }) );
    return 1;
}
mapping int_query_static_auto_load() {
    mapping tmp;
    tmp = ::int_query_static_auto_load();
    return ([ "::" : tmp,
              "design" : _design,
            ]);
}
mapping query_static_auto_load() {
    if ( base_name(this_object()) + ".c" == __FILE__ )
        return int_query_static_auto_load();
    return ([ ]);
}
void init_static_arg(mapping args) {
    if (args["::"])
    ::init_static_arg(args["::"]);
    if(!undefinedp(args["design"]))
        _design = args["design"];
    if(_design)
        make_roll(_design);
}

==================================================
FILE: misc/wallpaper_glue.c
==================================================

inherit "/obj/vessel";
#define VOLUME 5000
object add_glue();
void setup() {
    set_name("glue");
    set_short("pot of wallpapering glue");
    add_adjective( ({ "pot", "of", "wallpapering", "wallpaper" }) );
    add_alias("pot");
    add_plural("pots");
    set_max_volume(VOLUME);
    set_long("This is a small pot of wallpapering glue, essential "
        "for anybody who's going to be doing anything involving "
        "sticking paper to walls or playing mean tricks on their "
        "friends.\n");
    set_value(480);
    set_closed();
}
object add_glue() {
    object glue;
    glue = clone_object( "/obj/reagents/generic_liquid.ob" );
    glue->set_name( "glue" );
    glue->set_short( "sticky white wallpapering glue" );
    glue->add_adjective( ({ "sticky", "white", "wallpapering",
        "wallpaper"  }));
    glue->set_amount( VOLUME );
    glue->set_continuous();
    glue->set_long( "This is some thick and gloopy wallpapering glue.  "
        "Along with some wallpaper and a brush, you could probably "
        "do some fine home decorating.\n");
    glue->set_pile_name( "puddle" );
    glue->add_eat_effect( "/std/effects/ingested/poison", 10 );
    glue->move( this_object() );
    return glue;
}

==================================================
FILE: misc/watch.c
==================================================

inherit "/obj/clock";
int our_offset,
    their_offset,
    last_time,
    cur_alarm,
    offset_alarm,
    alarm;
mixed *alarms;
string *alarm_write,
       alarm_name;
object our_player;
varargs int get_text(string line);
void setup() {
  set_name("watch");
  add_adjective("demonic");
  add_alias("watch");
  set_main_plural("demonic watches");
  set_short("demonic watch");
  set_long("A small wrist attackable living quaters for a demon "+
           "the demon looks pretty harried about giveing out the "+
           "time all the time, and the pay is lousy..\n");
  set_value(20000);
  our_offset = 0;
  their_offset = 8;
  last_time = time();
  call_out("check_alarm",60);
  alarms = ({ });
}
void init() {
  add_command("time", "");
  add_command("gmt", "<word'offset'>", (:this_object()->set_gmt($4[0]):));
  add_command("use", "<direct:object>", (:this_object()->use():));
  this_player()->add_command("read", this_object());
}
int use(string arg) {
  if (!alarms)
    alarms = ({ });
  printf("%-=80s","You look into the watch and fiddle with several buttons, "+
                  "Finally a light lights up in the top corner say you have "+
                  "the security clearance to modify the settings.\n"+
                  "You can \"set\" an alarm \"remove\" an alarm \"list\" the "+
                  "set alarms. You can \"quit\" also.\n");
  write("What do you wish to do ? ");
  input_to("the_command");
  return 1;
}
int the_command(string arg) {
  string s1;
  int i;
  if (arg == "quit") {
    write("Thank you for using this wonderful watch.\n");
    return 1;
  }
  if (sscanf(arg,"set%s",s1)) {
    int hour, min;
    string name;
    if (sscanf(s1," %s %d:%d%s",name,hour,min,s1)!=4)
      write("Usage: set <name> <hour>:<min> [+]\n");
    else {
      if ((i=member_array(name,alarms))<0)
        alarms += ({ name, hour, min, 0 });
      else
        if (i%4)
          write("Oooooopps, you cannot use that name as an alarm\n");
        else {
          alarms[i+1] = hour;
          alarms[i+2] = min;
        }
      if (s1 == " +") {
        if (i==-1)
          i = sizeof(alarms)-4;
        cur_alarm = i;
        get_text();
        return 1;
      }
    }
  }
  if (sscanf(arg,"remove%s",s1)) {
    string frog;
    if (sscanf(s1," %s",frog)!=1)
      write("Usage: remove <name>\n");
    else
      if ((i=member_array(frog,alarms))<0)
        write("You must remove an existing alarm\n");
      else
        if (i%4)
          write("Ohhh dear.\n");
        else {
          alarms = delete(alarms,i);
          alarms = delete(alarms,i);
          alarms = delete(alarms,i);
          alarms = delete(alarms,i);
        }
  }
  if (sscanf(arg,"list%s",s1)) {
    string chicken;
    if (sscanf(s1," %s",chicken)!=1) {
      for (i=0;i<sizeof(alarms);i+=4) {
        write("Alarm "+alarms[i]+" is set for "+alarms[i+1]+":"+alarms[i+2]+"\n");
      }
    } else {
      if ((i=member_array(chicken,alarms))<0)
        write("That alarm does not exist.\n");
      else
        if (i%4)
          write("Bing basicly");
        else
          write("You have set alarm "+chicken+" to go off at "+alarms[i+1]+":"+
                 alarms[i+2]+"\n");
    }
  }
  return 1;
}
varargs int get_text(string line) {
   string text;
  if (!line) {
    text = "";
    write(sprintf("%-=80s","Please enter the text you wish to be displayed "+
          "when the alarm goes off (. to finish)"));
  } else if (line==".") {
    alarms[cur_alarm+3] = text+"\n";
    write("What do you wish to do ? ");
    input_to("the_command");
    return 1;
  } else
    text += line+"\n";
  write("] ");
  input_to("get_text");
  return 1;
}
mixed query_auto_load() {
  mixed ret;
  if (!alarms)
    alarms = ({ });
  ret = ({ their_offset, alarms });
  return ret;
}
void init_arg(mixed *arg) {
  their_offset = arg[0];
  alarms = arg[1];
  if (!alarms)
    alarms = ({ });
}
void check_alarm() {
   int the_time, offset, i;
   int tmp;
   the_time = time();
   offset = (the_time/(3600*24))*3600*24 - our_offset*3600;
   for (i=0;i<sizeof(alarms);i+=4) {
      tmp = offset + (alarms[i+1]-our_offset+their_offset)*3600 + alarms[i+2]*60;
      if (the_time>tmp && tmp>last_time) {
         alarm = 6;
         alarm_name = alarms[i];
         if (alarms[i+3])
         alarm_write = explode(alarms[i+3],"\n");
      else
         alarm_write = ({
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
            "Beep Beep Beep, Your "+alarms[i]+" alarm has gone off.\n",
         });
         offset_alarm = 0;
         set_heart_beat(1);
      }
   }
   last_time = the_time;
   call_out("check_alarm",60);
}
void heart_beat() {
   if (our_player)
     our_player->event_say(this_object(), "The watch goes: "+
                           alarm_write[offset_alarm++]+"\n");
   if (offset_alarm>sizeof(alarm_write))
     set_heart_beat(0);
}
int move(object ob) {
  int i;
  i = ::move(ob);
  our_player = environment();
  return i;
}

==================================================
FILE: misc/wearable_corpse.c
==================================================

inherit "/obj/corpse";
inherit "/std/basic/wearable";
void create() {
  corpse::create();
  wearable::create();
}
string long( string word, int dark ) {
  return corpse::long( word, dark ) + wearable::long( word, dark );
}
void init_static_arg( mapping map ) {
   if ( map[ "corpse" ] )
      corpse::init_static_arg( map[ "corpse" ] );
   if ( map[ "wearable" ] )
      corpse::init_static_arg( map[ "wearable" ] );
}
void init_dynamic_arg( mapping map ) {
 if ( !undefinedp( map[ "corpse" ] ) )
      corpse::init_dynamic_arg( map[ "corpse" ] );
 if ( !undefinedp( map[ "wearable" ] ) )
      wearable::init_dynamic_arg( map[ "wearable" ] );
}
mapping query_static_auto_load() {
   return ([
      "corpse" : corpse::query_static_auto_load(),
      "wearable" : wearable::query_static_auto_load(),
   ]);
}
mapping query_dynamic_auto_load() {
   return ([
      "corpse" : corpse::query_dynamic_auto_load(),
      "wearable" : wearable::query_dynamic_auto_load()
   ]);
}
mixed *stats() {
	return corpse::stats() + wearable::stats();
}

==================================================
FILE: misc/wearable_pet.c
==================================================

#include <gossip.h>
#include <armoury.h>
#define CHAT_FREQ 200
inherit "/obj/monster";
inherit "/std/basic/wearable";
varargs int wear_remove_function(object);
void expand_mon_string( mixed str ) {
    object room;
    string *args, *stuff;
    if ( functionp( str ) ) {
        evaluate( str, this_object() );
    }
    if(strsrch(str, "$name$") > 0) {
        stuff = GOSSIP_HANDLER->query_random_gossip();
        str = replace(str, ({ "$name$", stuff[0],
            "$mess$", stuff[1] }));
    }
    str = expand_string(str, 0);
    switch( str[0] ) {
    case '#':
        args = explode(str[ 1..], ":");
        switch (sizeof(args)) {
        case 1 :
            call_other( this_object(), args[0] );
            return;
        case 2 :
            call_other( this_object(), args[0], args[1] );
            return;
        case 3 :
            call_other( this_object(), args[0], args[1], args[2] );
            return;
        case 4 :
            call_other( this_object(), args[0], args[1], args[2],
              args[3] );
            return;
        default :
            call_other( this_object(), args[0], args[1], args[2],
              args[3], args[4] );
            return;
        }
    case ':' :
        str = str[1..];
        break;
    case '\'' :
        str = "says " + str;
        break;
    case '"' :
        str = "says loudly " + str;
        break;
    }
    if(living(environment())) {
        room = environment(environment());
        str = capitalize(environment()->poss_short()) +" "
        + this_object()->query_short()  + " " + str;
        tell_room( room,  str +"\n" );
    } else {
        room = environment();
        str = "The " + this_object()->query_short() + " " + str;
        tell_room( room, expand_string( str, 0 ) +"\n" );
    }
}
int check_anyone_here() {
object holder, *people;
    if(!(::check_anyone_here()))
        if ( living(holder = environment(this_object())) ) {
            if(environment(holder) &&
                    sizeof(people = all_inventory(environment(holder))))
            if(sizeof(filter(people, (: userp($1) :))))
                return 1;
            else
                return 0;
    }
    return ::check_anyone_here();
}
varargs int wear_remove_function(object pet, object thing) {
    object *wearing;
    object worn;
    if(pet && thing) {
        wearing = this_player()->query_wearing();
        foreach(worn in wearing) {
            if( (worn != previous_object())
                && inherits("/obj/misc/wearable_pet", worn)) {
                previous_object()->init_command(sprintf("kill %O",worn));
            }
        }
    }
}
void create() {
    wearable::create();
    monster::create();
}
string long(string str, int dark) {
    return monster::long(str, dark);
}
void init_dynamic_arg(mapping map) {
    wearable::init_dynamic_arg(map);
    monster::init_dynamic_arg(map);
}
mapping query_dynamic_auto_load() {
    return
    wearable::query_dynamic_auto_load() +
    monster::query_dynamic_auto_load();
}
void init_static_arg(mapping map) {
    wearable::init_static_arg(map);
    monster::init_static_arg(map);
}
mixed query_static_auto_load() {
    wearable::query_static_auto_load() +
    monster::query_static_auto_load();
}
int query_value() {
    return query_base_value();
}
mixed stats() {
    return wearable::stats() + monster::stats();
}
void break_me() {
    do_death();
}
string cond_string() {
   health_string();
}
int adjust_cond( int i ) {
    adjust_hp( i );
}
varargs int adjust_hp( int number, object attacker, object weapon,
    string attack ) {
    if(::adjust_cond( number ))
      return ::adjust_hp( number, attacker, weapon, attack);
}
int set_max_hp( int number ) {
    set_max_cond(number);
    set_cond(number);
    set_damage_chance( 15 );
    set_lowest_cond(1);
    return ::set_max_hp(number);
}

==================================================
FILE: misc/wedding_ring.c
==================================================

inherit "obj/armour";
string owner, giver;
void setup() {
   set_name( "ring" );
   set_short( "wedding ring" );
   add_adjective( "wedding" );
   set_long( "This is a wedding ring crafted from the purest gold from the "+
      "mines of Rimward Klatch.\n" );
   set_main_plural( "wedding rings" );
   set_type( "ring" );
   add_property( "shop type", "jewellers" );
   add_property( "no recycling", 1 );
   set_weight( 1 );
   setup_armour( 1000 );
   set_percentage( 100 );
   set_damage_chance( 0 );
   owner = giver = "nobody";
   set_wear_remove_func( file_name( this_object() ), "wear_remove" );
}
void do_inscription() {
   string language;
   object player;
   player = find_player( giver );
   if( !player ) {
      player = find_player( owner );
   }
   language = player->query_default_language();
   set_read_mess( "\"For you, "+ capitalize( owner ) +
         ", with eternal love, "+ capitalize( giver ) +".\"", language );
}
string query_owner() { return owner; }
void set_owner( string word ) {
  owner = lower_case( word );
  do_inscription();
}
string query_giver() { return giver; }
void set_giver( string word ) {
  giver = lower_case( word );
  do_inscription();
}
void wear_remove( int wear ) {
   if( environment() != this_player() )
      return;
   if ( living( environment() )  &&  wear ) {
      if ( (string)this_player()->query_name() != owner )
         write( "The ring feels uncomfortable on your finger.\n" );
      else
         write( "You are warmed anew by "+ capitalize( giver ) +"'s love.\n" );
   }
}
mixed *stats() {
   return ::stats() + ({
      ({ "owner", owner }),
      ({ "giver", giver }),
   });
}
void init_dynamic_arg( mapping args ) {
   if ( args[ "::" ] )
      ::init_dynamic_arg( args[ "::" ] );
   if ( args[ "owner" ] )
      owner = lower_case( args[ "owner" ] );
   if ( args[ "giver" ] )
      giver = lower_case( args[ "giver" ] );
}
mapping query_dynamic_auto_load() {
   return ([
      "::" : ::query_dynamic_auto_load(),
      "owner" : owner,
      "giver" : giver
   ]);
}

==================================================
FILE: misc/oddsnends/beeswax_candle.c
==================================================

inherit "/std/lightable";
void setup() {
   set_name( "candle" );
   set_short( "beeswax candle" );
   add_adjective( "beeswax" );
   set_long( "This is a small candle, like you'd "
         "see on a birthday cake.  It is quite soft and "
         "squidgy.\n" );
   set_fuel_messages( ({
         "It is almost burnt to a stub.", 10,
         "It is more than halfway burnt.", 50,
         "It is not yet halfway burnt.", 85,
	 "It is almost new.", 99,
         "It is new.", 100
         }) );
   set_empty_mess( "is burnt to a stub." );
   set_max_fuel( 900 );
   set_fuel( 900 );
   set_brightness( 60 );
   set_value( 24 );
   set_hold_required( 1 );
   add_property( "no recycling", 1 );
   new_weapon( 10 );
   set_weight( 1 );
   set_hide_cond( 1 );
}

==================================================
FILE: misc/oddsnends/book_end.c
==================================================

inherit "/std/object";
void setup(){
    set_name("end");
    set_short("book end");
    set_main_plural("book ends");
    set_long("A glittering book end wrought in iron.  Just the thing"
	     " for Auntie's Hogswatchday present.\n" );
    set_value(35);
    set_weight(40);
}

==================================================
FILE: misc/oddsnends/bottleopener.c
==================================================

inherit "/std/object";
void setup(){
    set_name("opener");
    set_short("bottle opener");
    add_adjective("bottle");
    set_main_plural("bottle openers");
    set_long("This is a multipurpose bottle opener that "
             "works for left- and right-handed people.\n");
    set_value(15);
    set_weight(5);
}

==================================================
FILE: misc/oddsnends/buffing_cloth.c
==================================================

inherit "/std/object";
void setup(){
    set_name("cloth");
    set_short("buffing cloth");
    set_main_plural("buffing cloths");
    add_adjective( "buffing" );
    set_long("This is a small, soft cloth that might be used for polishing"
	     " metal objects.\n" );
    set_value(32);
    set_weight(2);
}

==================================================
FILE: misc/oddsnends/glass.c
==================================================

#include <volumes.h>
inherit "/obj/vessel";
void setup(){
    set_name("glass");
    set_short("glass");
    set_long("This is a limited edition authentic "
             "scumble measure glass, as produced by the "
             "ancient scumble brewers.  It is very exclusive.\n");
    set_max_volume(VOLUME_HALFPINT);
    set_max_weight(10);
    set_leak_rate(0);
    set_value(30);
    set_weight(5);
    set_stuck(1);
}

==================================================
FILE: misc/oddsnends/hair_brush.c
==================================================

inherit "/std/object";
void setup(){
    set_name("brush");
    set_short("stiff hair brush");
    add_adjective("hair");
    add_adjective("stiff");
    set_long("This is a small brush with rather stiff tines "
             "sticking out from it.  It looks like just the thing to "
             "straighten out your hair after a sandstorm.\n");
    set_value(10);
    set_weight(20);
}

==================================================
FILE: misc/oddsnends/nail.c
==================================================

inherit "/std/object";
void setup(){
    set_name("nail");
    set_short("nail");
    set_main_plural("nails");
    set_long("A typical nail for nailing bits of wood together."
	     "  Quite exciting really.\n" );
    set_value(4);
    set_weight(1);
}

==================================================
FILE: misc/oddsnends/paint_brush.c
==================================================

inherit "/std/object";
void setup(){
    set_name("brush");
    set_short("camel hair brush");
    add_adjective("hair");
    add_adjective("camel");
    add_adjective("paint");
    set_long("This is a small paint brush with fine camel hairs sticking "
             "out.  It looks to be better suited to the finer arts than for"
             " painting wagons with.\n");
    set_value(15);
    set_weight(15);
}

==================================================
FILE: misc/oddsnends/picframe.c
==================================================

inherit "/obj/container";
void setup(){
    set_name("frame");
    set_short("picture frame");
    add_adjective("picture");
    set_long("A lovely gold painted picture frame.\n");
    set_value(20);
    set_weight(30);
    set_max_weight(1);
    set_open();
    set_stuck(1);
}

==================================================
FILE: misc/oddsnends/safety_clip.c
==================================================

inherit "/std/object";
void setup(){
    set_name("clip");
    set_short("safety clip");
    add_adjective("safety");
    set_long("This is a high technology item.  "
             "It is designed to be used as a buckle, and "
             "will safeguard you from much harm if used "
             "properly.\n");
    set_value(25);
    set_weight(2);
}

==================================================
FILE: misc/oddsnends/shoehorn.c
==================================================

inherit "/std/object";
void setup(){
    set_name("horn");
    set_short("shoe horn");
    add_adjective("shoe");
    set_long("A normal shoe horn.\n");
    set_value(10);
    set_weight(5);
}

==================================================
FILE: misc/oddsnends/shoelace.c
==================================================

inherit "/std/object";
void setup(){
    set_name("lace");
    set_short("shoe lace");
    add_adjective("shoe");
    add_alias("shoelace");
    set_main_plural("shoe laces");
    add_plural("shoelaces");
    set_long("A bright yellow coloured shoelace, "
             "just the kind of thing a teenage kid would wear.\n");
    set_value(15);
    set_weight(2);
}

==================================================
FILE: misc/oddsnends/small_keyring.c
==================================================

inherit "/obj/misc/keyring";
void setup(){
    set_name("keyring");
    set_short("small keyring");
    set_main_plural("small keyrings");
    add_adjective( "small" );
    set_long("This is a small keyring, suitable for holding a few "
     "small keys.\n" );
    set_weight(1);
    set_max_weight( 10 );
    set_value( 200 );
}

==================================================
FILE: misc/oddsnends/wedge.c
==================================================

inherit "/std/object";
void setup(){
    set_name("wedge");
    set_short("door wedge");
    add_adjective("door");
    set_main_plural("door wedges");
    set_long("A common wooden door wedge.  "
             "You use them to hold a door open.\n");
    set_value(10);
    set_weight(10);
}

==================================================
FILE: misc/shops/item_shop_safe.c
==================================================

inherit "/obj/baggage";
void set_max_float( int );
int query_max_float();
void setup() {
  set_name( "safe" );
  set_short( "cash safe" );
  set_long( "This safe is used to keep the shop's float in.  It's securely set "
    "in the wall.\n" );
  add_adjective( "float" );
  add_property( "there", "in the wall" );
  set_difficulty( 10 );
  reset_get();
  set_closed();
  set_locked();
  set_key( "non-existent key" );
  add_property( "no recycling", 1 );
  set_pick_skill( "covert.lockpick.safes" );
  set_weight( 2000 );
  set_max_weight( 5000 );
  set_value( 120000 );
}
int pick_unlock( object player ){
  this_object()->set_unlocked();
    return 1;
}
int query_accept_money() {
  return 1;
}

==================================================
FILE: misc/locks/basic_door_lock.c
==================================================

inherit "/obj/misc/lock";
void setup() {
   set_name("lock");
   set_short("basic door lock");
   add_adjective( ({ "basic", "door" }));
   set_long("A basic brass door lock.\n");
   add_property("difficulty", 2);
   set_weight(19);
   set_value(20000);
}
void set_key_number(int num) {
   add_property("key prop", "door_lock_"+num);
   add_property("locktype", "door");
}

==================================================
FILE: misc/locks/basic_furniture_lock.c
==================================================

inherit "/obj/misc/lock";
void setup() {
   set_name("lock");
   set_short("basic furniture lock");
   add_adjective( ({ "basic", "furniture" }));
   set_long("A basic brass furniture lock.\n");
   add_property("difficulty", 1);
   set_weight(19);
   set_value(10000);
}
void set_key_number(int num) {
   add_property("key prop", "furniture_lock_"+num);
   add_property("locktype", "furniture");
}

==================================================
FILE: misc/locks/brass_door_key.c
==================================================

inherit "/std/key";
void set_key_number(int num) {
   set_key("small brass", "door_lock_" + num);
   set_long("A small brass key.  It has a serial number " +
            num + " engraved on it.\n");
   set_value(10);
}
mapping query_static_auto_load() {
   return int_query_static_auto_load();
}
int query_duplicatable_key() {
   return 1;
}

==================================================
FILE: misc/locks/chubby_special_door_lock.c
==================================================

inherit "/obj/misc/lock";
void setup() {
   set_name("lock");
   set_short("chubby special door lock");
   add_adjective( ({ "chubby", "special", "door" }));
   set_long("A chubby special brass door lock.  These high-quality "
                     "locks are made by Grabthroat Shinkicker and Sons.  "
                     "Contrary to popular belief the locks are called "
                     "chubby's not because of their thickness but because "
                     "Grabthroat's real name is Charles and his "
                     "nickname is Chubby.\n");
   add_property("difficulty", 8);
   set_weight(19);
   set_value(160000);
}
void set_key_number(int num) {
   add_property("key prop", "door_lock_"+num);
   add_property("locktype", "door");
}

==================================================
FILE: misc/locks/chubby_standard_door_lock.c
==================================================

inherit "/obj/misc/lock";
void setup() {
   set_name("lock");
   set_short("chubby standard door lock");
   add_adjective( ({ "chubby", "standard", "door" }));
   set_long("A chubby standard brass door lock.  These "
                     "high-quality "
                     "locks are made by Grabthroat Shinkicker and Sons.  "
                     "Contrary to popular belief the locks are called "
                     "chubby's not because of their thickness but because "
                     "Grabthroat's real name is Charles and his "
                     "nickname is Chubby.\n");
   add_property("difficulty", 6);
   set_weight(19);
   set_value(80000);
}
void set_key_number(int num) {
   add_property("key prop", "door_lock_"+num);
   add_property("locktype", "door");
}

==================================================
FILE: misc/locks/chubby_ultra_door_lock.c
==================================================

inherit "/obj/misc/lock";
void setup() {
   set_name("lock");
   set_short("chubby ultra door lock");
   add_adjective( ({ "ultra", "chubby", "door" }));
   set_long("A chubby ultra brass door lock.  These high-quality "
                     "locks are made by Grabthroat Shinkicker and Sons.  "
                     "Contrary to popular belief the locks are called "
                     "chubby's not because of their thickness but because "
                     "Grabthroat's real name is Charles and his "
                     "nickname is Chubby.\n");
   add_property("difficulty", 10);
   set_weight(19);
   set_value(300000);
}
void set_key_number(int num) {
   add_property("key prop", "door_lock_"+num);
   add_property("locktype", "door");
}

==================================================
FILE: misc/locks/flimsy_door_lock.c
==================================================

inherit "/obj/misc/lock";
void setup() {
   set_name("lock");
   set_short("flimsy door lock");
   add_adjective( ({ "flimsy", "door" }));
   set_long("A flimsy brass door lock.\n");
   add_property("difficulty", 1);
   set_weight(19);
   set_value(10000);
}
void set_key_number(int num) {
   add_property("key prop", "door_lock_"+num);
   add_property("locktype", "door");
}

==================================================
FILE: misc/locks/furniture_key.c
==================================================

inherit "/std/key";
void set_lock_number(int num) {
   set_key("small furniture", "furniture_lock_" + num);
   set_long("A small key, it looks like it would be "
            "suitable for a piece of furniture.\n");
   set_value(10);
}
void set_key_number( int num ){
  set_lock_number(num);
}
mapping query_static_auto_load() {
   return int_query_static_auto_load();
}
int query_duplicatable_key() {
   return 1;
}

==================================================
FILE: misc/locks/standard_door_lock.c
==================================================

inherit "/obj/misc/lock";
void setup() {
   set_name("lock");
   set_short("standard door lock");
   add_adjective( ({ "standard", "door" }));
   set_long("A standard brass door lock.\n");
   add_property("difficulty", 4);
   set_weight(19);
   set_value(40000);
}
void set_key_number(int num) {
   add_property("key prop", "door_lock_"+num);
   add_property("locktype", "door");
}

==================================================
FILE: misc/locks/standard_furniture_lock.c
==================================================

inherit "/obj/misc/lock";
void setup() {
   set_name("lock");
   set_short("standard furniture lock");
   add_adjective( ({ "standard", "furniture" }));
   set_long("A standard brass furniture lock.\n");
   add_property("difficulty", 2);
   set_weight(19);
   set_value(10000);
}
void set_key_number(int num) {
   add_property("key prop", "furniture_lock_"+num);
   add_property("locktype", "furniture");
}

==================================================
FILE: misc/papers/paper_file.c
==================================================

inherit "/obj/misc/paper";
string file_name;
void create() {
  seteuid(getuid());
  ::create();
}
void set_file_name(string fname) {
  file_name = fname;
}
string query_file_name() {
  return file_name;
}
mixed *query_read_mess() {
  return read_file(file_name);
}
void init() {
  this_player()->add_command("read", this_object());
  ::init();
}

==================================================
FILE: misc/player_shop/mgr_book.c
==================================================

#include "player_shop.h"
inherit "/std/book";
private string _office;
void setup() {
    set_name( "book" );
    add_alias( "handbook" );
    set_short( "manager handbook");
    set_main_plural( "manager handbooks" );
    add_adjective( "manager" );
    set_weight( 5 );
    set_value( 5 );
    set_no_pages( 11 );
    add_property( "no recycling", 1 );
}
private string cap_name(string name)
{
   if (test_player(name))
      return PLAYER_HANDLER->query_cap_name(name);
   else return capitalize(name);
}
void set_office( string office ) {
   _office = office;
   if ( !query_property( "office" ) ) {
      add_property( "office", office );
   }
   set_long( "This is a handbook for Managers of "+ office->query_shop_name()+
     ", "+ office->query_place()+ ".  It covers those aspects of "
     "the managers' job not covered by the staff handbook.\n"
     "You may <read book>, <open book to page #> and "
     "<turn a page of book>.\n" );
    set_open_page( 1 );
    set_read_mess( "\n"
      "                            TABLE OF CONTENTS                    Page 1\n"
      "                    .o0o.o0o.o0o.o0o.o0o.o0o.o0o.o0o.\n\n"
      "       Introduction............................................2\n"
      "       The job.................................................3\n"
      "       The way things work.....................................4\n"
      "       Specific commands.......................................5-7\n"
      "       Hiring new employees....................................8-9\n"
      "       Disciplinary procedures.................................10-11\n",
      "common", 100 );
    set_open_page( 2 );
    set_read_mess( "\n"
      "                               Introduction                      Page 2\n"
      "                           -=-=-=-=-==-=-=-=-=-\n\n"
      " This handbook has been written specifically for managers to detail\n"
      " your role in the shop.  You will find details of commands specific\n"
      " to managers, and a more detailed explanation of the workings of the\n"
      " shop.  This book is to be treated as a confidential document, and its\n"
      " contents only to be discussed with other managers.\n",
      "common", 100 );
    set_open_page( 3 );
    set_read_mess( "\n"
      "                                 The Job                         Page 3\n"
      "                               -=-=-=-=-=-\n\n"
      " It is the responsibility of managers to ensure the smooth operation\n"
      " of the shop.  This includes staff motivation, advertising, pay and\n"
      " staffing levels, accounts, discipline and personnel.\n"
      " Motivation and advertisements are left to the judgement of managers,\n"
      " whilst the personnel issues should follow strict guidelines detailed\n"
      " later.\n\n"
      " As you should be aware, since you now hold the highest position in the\n"
      " store, there is nothing to work towards regarding your promotion.  You\n"
      " are paid at a higher rate, however, so there are still benefits to be\n"
      " obtained from carrying out the more 'mundane' tasks within the shop.\n\n"
      " Finally, managers are allowed to \"retire\" and continue in an advisory\n"
      " capacity.  Whilst having very limited functional control over the\n"
      " shop, retired managers are still able to keep their badge, and use\n"
      " the notice board and \"memo\" facility.\n",
      "common", 100 );
    set_open_page( 4 );
    set_read_mess( "\n"
      "                           The way things work                   Page 4\n"
      "                         -=-=-=-=-=-=-=-=-=-=-=-\n\n"
      " On being hired, employees are paid according to the amount of work\n"
      " they do.  Along with their pay, they accumulate points towards\n"
      " promotion in the shop.  The pay and points depend on the amount of\n"
      " work done, and not on the amount of time spent in the shop.  Precisely,\n"
      " employees receive a set amount per transaction, with a maximum of one\n"
      " paid transaction every minute.\n"
      " Each employee's status is reviewed every 3 DW days, their points added,\n"
      " and their pay awarded.  This pay is transferred into their bank account\n"
      " every month, and a written confirmation of the amount is sent.\n"
      " Employees are paid according to their status.  This is done in a ratio\n"
      " of 2:3:4 so that managers will be paid twice as much as employees, with\n"
      " supervisors halfway in between.  The bonuses are calculated in the same\n"
      " way.\n",
      "common", 100 );
    set_open_page( 5 );
    set_read_mess( "\n"
      "                              Specific commands                  Page 5\n"
      "                           -=-=-=-=-=-=-=-=-=-=-=-\n\n"
      " There are a number of additional commands once promotion to manager\n"
      " is gained.  The majority of these are rather self-explanatory, and\n"
      " so will only be covered briefly.  The remainder merit an explanation.\n\n"
      " accounts - Check the current value of the accounts\n"
      " list - As in the main office, with the addition of baddies & applicants\n"
      " mail - Yes, you now have access to your mail from the managers' office\n"
      " memo - Send a memo to the other managers of the shop\n"
      " retire - The alternative to resignation\n"
      " view - View a person's record with this shop.  This is extremely useful\n"
      "        when deciding on disciplinary matters, or before hiring applicants\n"
      " query - Check the current settings for maximum number of employees and\n"
      "         pay rates\n"
      " project - Gives a projection of the months' pay packet based on the\n"
      "           employees' activity so far, and also the projected bonus amounts\n"
      "           based on the current value of the bonus fund.  Useful when setting\n"
      "           these values\n"
      " transfer - Transfer money between two accounts                (Continued...)\n",
      "common", 100 );
    set_open_page( 6 );
    set_read_mess( "\n"
      "                                                                 Page 6\n\n"
      " set - This command sets the maximum number of employees (speaks for\n"
      "       itself), or the base pay rate.  The base pay rate is the amount\n"
      "       that each employee will receive per transaction.  This rate is\n"
      "       then adjusted accordingly for supervisors and managers.\n"
      "       Changing this amount will not affect transactions already made\n"
      "       by employees, but will affect all subsequent transactions.\n"
      " buy/sell - These commands are used to buy and sell storeroom cabinets.\n"
      "            Cabinets are sold for 50% of the buying price, so make sure\n"
      "            you really do want a cabinet before buying it as they can be\n"
      "            expensive.\n"
      " (un)ban - These commands are used to ban or unban a person from the shop.\n"
      "           A person can be banned automatically, and will also be unbanned\n"
      "           automatically after 28 days.  If, however, you wish to unban\n"
      "           someone sooner, you may do so with this command.\n"
      " vote - Allows you to vote for, against, or abstain on an applicant.  This\n"
      "        will be your only chance to vote on this applicant, so make sure it\n"
      "        is the right decision.\n"
      " check - Allows you to check your current votes               (Continued...)\n",
      "common", 100 );
    set_open_page( 7 );
    set_read_mess( "\n"
      "                                                                 Page 7\n\n"
      " leave - Allows you to place an employee on leave for up to 14 days\n"
      " commend - Allows you to commend an outstanding employee.  This will\n"
      "           place an entry in their employment record, and award them\n"
      "           extra promotion points.\n"
      " warn - Officially reprimand an employee.  Will place an entry in their\n"
      "        record, and deduct promotion points.\n"
      " suspend - Suspend an employee's bonus entitlement for a specified\n"
      "           number of months following the current month.\n"
      " demote - Demote a supervisor to employee.  Will start them off as if\n"
      "          they were a new employee, but with their employment record\n"
      "          reflecting their history.\n"
      " fire - Terminate someone's employment with this shop.\n",
      "common", 100 );
    set_open_page( 8 );
    set_read_mess( "\n"
      "                            Hiring new employees                Page 8\n"
      "                        -=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n"
      " This is a brief description of the process involved in hiring a\n"
      " new employee.\n\n"
      " 1) Prospective employees \"apply\" in the shop and a mail is sent\n"
      "    to each manager.  The application is saved and viewable from\n"
      "    within the managers' office.\n"
      " 2) Managers check the list in the office which will show applicants\n"
      "    waiting for employment, applicants yet to confirm their offer,\n"
      "    and new applicants yet to be voted upon (with votes so far).\n"
      " 3) Managers \"vote\" on each prospective employee.  Only one vote\n"
      "    per employee per manager is allowed, and the first vote counts.\n"
      " 4) As soon as the number of votes for employment equals 50% of the\n"
      "    current manager base, the candidate is accepted.  If votes against\n"
      "    exceeds 50%, the candidate is rejected.\n"
      " 5) If 50% hasn't been reached after 7 days, then the candidate is\n"
      "    hired/rejected on the basis of votes received so far.  (Continued...)\n",
      "common", 100 );
    set_open_page( 9 );
    set_read_mess( "\n"
      "                                                                Page 9\n\n"
      " 6) The approved candidate has 7 days from being accepted to confirm\n"
      "    their offer, otherwise they are removed from the list.\n"
      " 7) Once confirmed, the employee is kept advised of their current\n"
      "    position in the waiting list, and hired as soon as a position\n"
      "    becomes vacant in the shop.\n"
      " 8) The candidate can \"cancel\" their application at any time until\n"
      "    they are hired.\n\n"
      " Since the candidates are hired in order of being accepted, please make\n"
      " sure you vote for the oldest applications first.\n",
      "common", 100 );
    set_open_page( 10 );
    set_read_mess( "\n"
      "                           Disciplinary procedures              Page 10\n"
      "                         -=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n"
      " This section is intended as a guide to disciplinary procedures.  It\n"
      " is ultimately down to managers to set their own policies within the\n"
      " shop.\n"
      " The first step in any action is to verbally warn an employee before\n"
      " taking any formal action.  This avoids any unpleasant comebacks on\n"
      " the manager involved.\n"
      " The next stage is either a warning, or suspending an employee's bonus.\n"
      " Whilst a warning reduces an employee's promotion points, bonuses can\n"
      " be suspended indefinitely.\n"
      " If the employee is a supervisor, the next stage is probably demotion.\n"
      " Following demotion, or if the employee is not a supervisor, dismissal\n"
      " may be the only course of action open to you.\n"
      " It is important to check the employee's history before taking any\n"
      " action as this will allow you to see what action has already been\n"
      " taken, and when.                                       (Continued...)\n",
      "common", 100 );
    set_open_page( 11 );
    set_read_mess( "\n"
      "                                                                Page 11\n\n"
      " Again, it is the responsibility of managers to develop a policy as\n"
      " to what merits disciplinary action.  A few guidelines are set out in\n"
      " the staff handbook, but more can be added.\n\n"
      " Finally, if there are any changes that need making to this, or indeed\n"
      " the staff handbook, please let me know.  I am open to comments and\n"
      " suggestions on content as well as shop policy.\n"
      " (c) "+ cap_name(CREATOR)+ " 2001",
      "common", 100 );
    set_open_page( 0 );
}
void init () {
   set_open_page( 0 );
   if ( !_office || _office == "" ) {
      if ( !query_property( "office" ) ) {
         return;
      }
      _office = query_property( "office" );
      set_office( _office );
   }
   if ( !_office->query_manager( environment( this_object() )->query_name() ) &&
     !_office->query_retired( environment( this_object() )->query_name() ) &&
     !environment( this_object() )->query_creator() ) {
      return;
   }
   ::init();
}

==================================================
FILE: misc/player_shop/shop_badge.c
==================================================

#include <player_shop.h>
inherit "/obj/armour";
private int do_badge(string);
private int do_chat(string);
private int get_properties();
private string cap_name(string);
private string _office,
_title,
_channel,
_owner;
private int _echo;
void setup()
{
    set_name("badge");
    set_short("employee badge");
    add_adjective("employee");
    add_adjective("tin");
    add_adjective("small");
    set_main_plural("employee badges");
    set_weight(1);
    set_value(0);
    set_type("badge");
    setup_armour(640);
    set_damage_chance(5);
    set_wear_remove_func(file_name(this_object()),
      "wear_remove_badge");
    add_property("no recycling", 1);
    add_extra_look(this_object());
    if (!query_property("office") || !query_property("owner"))
    {
        return;
    }
    _office = query_property("office");
    _owner = query_property("owner");
    _echo = query_property("echo");
    _title = _office->shop_very_short();
    _channel = _office->query_channel();
    set_long( "This is a small tin badge which marks " +
      cap_name(_owner) + " as an employee of "+
      _office->query_shop_name()+ ", "+ _office->query_place()+ ".\n");
    add_adjective(_channel);
}
private string cap_name(string name)
{
    if (test_player(name))
        return PLAYER_HANDLER->query_cap_name(name);
    else return capitalize(name);
}
void init()
{
    object tp;
    if (!_office || !_owner)
    {
        if (!get_properties()) return;
        set_long("This is a small tin badge which marks "+
          cap_name(_owner) + " as an employee of "+
          _office->query_shop_name()+ ", "+ _office->query_place()+ ".\n");
        add_adjective(_channel);
    }
    tp = this_player();
    if (!_office->query_employee(tp->query_name()) &&
      !_office->query_retired(tp->query_name()) &&
      !tp->query_creator())
    {
        return;
    }
    add_command("badge", ({ "help", "echo" }), (: do_badge($5) :));
    add_command("h"+ _channel, "", (: do_badge("hist") :));
    add_command(_channel+"?", "", (: do_badge("who") :));
    add_command(_channel, "<string'text'>", (: do_chat($4[0]) :));
    add_command(_channel+"@", "<string'text'>", (: do_chat("@"+$4[0]) :));
}
private int do_badge(string args)
{
    if (!_office || !_owner)
    {
        if (!get_properties()) return 1;
    }
    add_succeeded_mess("");
    if (args == "who")
    {
        tell_object(this_player(),
          "The following employees from "+ _office->query_shop_name()+
          " are logged on: \n" + _office->badge_list());
        return 1;
    }
    else if (args == "hist")
    {
        string result = "$P$"+ _channel+ " channel$P$\n";
        mixed *hist = HISTORY_HANDLER->query_chat_history(lower_case(_channel));
        tell_object(this_player(),
          "You ask the badge for the last few chats on the "+ _channel+
          " channel\n");
        if (!arrayp(hist) || !sizeof(hist))
        {
            tell_object(this_player(),
              "The badge mutters that nothing has been said on this channel, "
              "or it is not being remembered.\n");
            return 1;
        }
        result += implode(map(hist, (: "$I$5=$C$" + $1[0] + $1[1] +
              "%^RESET%^" :)), "\n" );
        tell_object(this_player(), result);
    }
    else if (args == "echo")
    {
        if (_echo)
        {
            tell_object(this_player(), "Local echo now off.\n");
            _echo = 0;
        }
        else
        {
            tell_object(this_player(), "Local echo now on.\n");
            _echo = 1;
        }
        add_property("echo", _echo);
    }
    else
    {
        string result = sprintf("Commands for this badge:\n\n"
          "   %-13s - chat a message to the other employees\n"
          "   %-13s - emote a message to the other employees\n"
          "   %-13s - list employees logged on\n"
          "   h%-12s - show recent chat history\n"
          "   badge echo    - Turn local echo on/off\n\n"
          "You can also set your preferred chat colour using the \"colour "
          "shopchat <colour>\" command.\n", _channel, _channel + "@",
          _channel + "?", _channel, _channel);
        tell_object(this_player(), result);
    }
    return 1;
}
private int do_chat(string wisp)
{
    string sender;
    object *things, tp;
    add_succeeded_mess("");
    if (!_office || !_owner)
    {
        if (!get_properties()) return 1;
    }
    tp = this_player();
    if (!tp->query_property(_channel+ "_on"))
    {
        return notify_fail("You are not wearing the " + _channel+
          " badge!\n");
    }
    if (tp->query_property("gagged"))
    {
        return notify_fail("You have been gagged!  You cannot chat until "
          "your gag is removed.  Perhaps you should talk to a creator about "
          "this.\n");
    }
    if (!tp->query_creator())
    {
        wisp = replace_string(wisp, "%^", "");
    }
    if (!wisp || ( wisp == "" ) || wisp == "@")
    {
        return notify_fail("Chat what?\n");
    }
    if (environment(this_object()) != tp)
    {
        return notify_fail("You're too far from the badge to whisper into "
          "it.\n");
    }
    tell_object(tp,  "You whisper into the badge.\n");
    sender = tp->query_cap_name();
    if (tp->query_name() == CREATOR && tp->query_invis())
    {
        sender = tp->query_short();
    }
    wisp = replace(wisp, sprintf("%c", 7), "!");
    things = children(BADGE);
    if (_echo)
    {
        things -= ({find_object(BADGE)});
    }
    else
    {
        things -= ({this_object(), find_object(BADGE)});
    }
    things->receive(_channel ,sender, wisp);
    if (wisp[0] == '@')
    {
        if (wisp[1] == ''')
      {
         HISTORY_HANDLER->add_chat_history(_channel, sender, wisp[1..1000]);
      }
      else
      {
         HISTORY_HANDLER->add_chat_history(_channel, sender+ " ", wisp[1..1000]);
      }
   }
   else
   {
      HISTORY_HANDLER->add_chat_history(_channel, sender +": ", wisp);
   }
   return 1;
}
string extra_look(object thing)
{
   object tp;
   tp = this_player();
   if (!_office || !_owner)
   {
      if (!get_properties()) return "";
   }
   if (!_office->query_employee(tp->query_name()) &&
      !_office->query_retired(tp->query_name()) && !tp->query_creator())
   {
      return "";
   }
   return "You can get a list of commands by typing \"badge help\"\n";
}
private int get_properties()
{
   if (!query_property("office") || !query_property("owner"))
   {
      tell_object(environment(), "This badge is broken.  "
         "Please claim another.\n");
      move("/room/rubbish");
      return 0;
   }
   _office = query_property("office");
   _owner = query_property("owner");
   _echo = query_property("echo");
   _title = _office->shop_very_short();
   _channel = _office->query_channel();
   return 1;
}
string query_channel() { return copy(_channel); }
void receive(string channel, string sender, string text)
{
   object owner = environment();
   string *ignoring, prev_ob;
   if (!_office || !_owner)
   {
      if (!get_properties()) return;
   }
   prev_ob = base_name(previous_object());
   if (prev_ob != BADGE && prev_ob != _office->query_shop_front()
      && prev_ob != "/d/am/square/emporium/TARNACH/consumables")
   {
      LOG_ERROR("shop_badge.c", "receive("+channel+","+sender+","+text+")");
      return;
   }
   if (!owner || (!living(owner)))
   {
      return;
   }
   if (!_office->query_employee(owner->query_name()) &&
      !_office->query_retired(owner->query_name()) &&
      !owner->query_creator())
   {
      return;
   }
   ignoring = owner->query_property("ignoring");
   if (ignoring && member_array(lower_case(sender), ignoring) != -1)
   {
      return;
   }
   if (channel != _channel || !owner->query_property(_channel+ "_on"))
   {
      return;
   }
   if (text[0] == '@')
   {
      if (text[1] == ''')
      {
         text = "["+ lower_case( _channel )+ "] "+ sender + text[1..1000];
      }
      else
      {
         text = "["+ lower_case( _channel )+ "] "+ sender +" "+ text[1..1000];
      }
   }
   else
   {
      text = "["+ lower_case( _channel )+ "] "+ sender +": "+ text;
   }
   tell_object(owner, owner->colour_event("shopchat", "%^CYAN%^") +
      "$I$5=$C$"+ text + "%^RESET%^\n");
   return;
}
void set_props(string path, string owner)
{
   if (!path || path == "")
   {
      return;
   }
   if (previous_object() && previous_object() != find_object(path))
   {
      LOG_ERROR("shop_badge.c", "set_props("+path+","+owner+")");
      return;
   }
   set_long("This is a small tin badge which marks " +
      cap_name( owner ) + " as an employee of "+
      path->query_shop_name()+ ", "+ path->query_place()+ ".\n");
   add_property("office", path);
   add_property("owner", owner);
   _office = path;
   _owner = owner;
   _title = _office->shop_very_short();
   _channel = _office->query_channel();
   add_adjective( _channel );
}
void wear_remove_badge(object thing)
{
   if (!_office || !_owner)
   {
      if (!get_properties()) return;
   }
   if (thing)
   {
      int level;
      string start;
      if (!living(thing))
      {
         return;
      }
if (thing->query_creator())
{
thing->add_property(_channel+ "_on", 1);
return;
}
      level = _office->query_employee(thing->query_name());
      if (!level || level == -1)
      {
         if (_office->query_retired(thing->query_name()))
         {
            start = "Retired manager of ";
         }
         else return;
      }
      else if (level & MANAGER)
      {
         start = "Manager of ";
      }
      else if (level & SUPERVISOR)
      {
         start = "Supervisor of ";
      }
      else
      {
         start = "Employee of ";
      }
      thing->add_property(_channel+ "_on", 1);
      thing->set_title(_title, start + _office->query_shop_name());
      return;
   }
   thing = previous_object()->query_worn_by();
   if (thing)
   {
      thing->remove_property(_channel+ "_on");
      thing->remove_title(_title);
   }
}

==================================================
FILE: misc/player_shop/shop_cabinet.c
==================================================

#include <move_failures.h>
inherit "/std/container";
private mapping _stock = ([]);
private nosave string _save_file = "";
private nosave int _call_save = 0;
private void do_save();
void create()
{
   do_setup++;
   ::create();
   do_setup--;
   if (!do_setup)
   {
      this_object()->setup();
      this_object()->reset();
   }
}
object *add_items(object *items, object player)
{
   object *failed = ({});
   foreach( object item in items )
   {
      if (item->move(this_object()) != MOVE_OK)
      {
         failed += ({ item });
      }
   }
   if (sizeof(failed))
   {
      failed->move(player);
   }
   remove_call_out(_call_save);
   _call_save = call_out((: do_save() :), 1);
   return failed;
}
void dest_me()
{
   if (remove_call_out(_call_save) != -1)
   {
      do_save();
   }
   ::dest_me();
}
private void do_load()
{
   if (_save_file)
   {
      if (file_size(_save_file + ".o") > 0)
      {
         unguarded((: restore_object, _save_file :));
         if (sizeof(_stock))
         {
            init_dynamic_arg(_stock,0);
         }
      }
   }
}
private void do_save()
{
   if (_save_file && _save_file != "")
   {
#ifdef DEBUG
      debug_printf("Saving cabinet data to %s.\n", _save_file);
#endif
      _stock = query_dynamic_auto_load();
      unguarded((: save_object, _save_file :));
   }
}
object *remove_items(object *items, object player)
{
   object *failed = ({});
   foreach(object item in items)
   {
      if (item->move(player) != MOVE_OK)
      {
         failed += ({ item });
      }
   }
   if (sizeof(failed))
   {
      failed->move(environment(player));
   }
   remove_call_out(_call_save);
     _call_save = call_out((: do_save() :), 1);
   return failed;
}
void set_save_file(string filename)
{
   _save_file = filename;
   do_load();
}

==================================================
FILE: misc/player_shop/shop_chart.c
==================================================

#include <player_shop.h>
#include <money.h>
inherit "/std/object";
private nosave string _office;
void setup()
{
   set_name("chart");
   set_short("items chart");
   add_adjective("items");
   reset_get();
}
string long(string word, int dark)
{
   mapping list = _office->query_list_mapping();
   string chart, *items = sort_array(keys(list),1);
   if (!m_sizeof(list))
   {
      return "There are no items on the list.\n";
   }
   chart = sprintf("\n%-2s  %-25s  %-3s  %-5s  %-4s  %-4s  %-3s  %-4s  %-8s\n",
      "no", "items", "max", "stock", "avst", "avsl", "buy", "sell", "cabinets");
   chart += sprintf("%-2s  %-25s  %-3s  %-5s  %-4s  %-4s  %-3s  %-4s  %-8s\n",
      "--", "-----", "---", "-----", "----", "----", "---", "----", "--------");
   for (int i = 0; i < sizeof( items ); i++)
   {
      reset_eval_cost();
      chart += sprintf("%2d  %-25s  %3d  %5d  %4d  %4d  %3d  %4d  %8s\n",
         i + 1, items[i], list[items[i]][CHART_MAX],
         _office->query_stock(items[i]), list[items[i]][CHART_AVE],
         list[items[i]][CHART_AVESALE], list[items[i]][CHART_BUY],
         list[items[i]][CHART_SELL],
         implode(list[items[i]][CHART_CAB], (: $1+","+$2 :), "")[1..]);
   }
   return sprintf("%s%s", ::long(word,dark), chart);
}
void set_office(string office)
{
   _office = office;
   set_long("This chart lists the items of interest to the shop.  All "
      "prices are in "+ pluralize(MONEY_HAND->smallest_in(_office->
      query_place()))+ ".\n");
}

==================================================
FILE: misc/player_shop/shop_notice.c
==================================================

inherit "/std/object";
private nosave string _office, _stock_policy;
private nosave int _type = 0;
void setup()
{
   set_name("notice");
   set_short("policy notice");
   set_long("");
   add_adjective("policy");
   reset_get();
}
string long(string word, int dark)
{
   mapping policies= _office->get_policies(_type);
   int i = 1;
   string display;
   if (!_type)
   {
      display = sprintf("This is the list of shop's policies.  The policies "
         "on this notice are definitive and final.  This shop deals strictly "
         "in %s.  Items that do not fit this description should not be "
         "stocked.\n\n", "%^BOLD%^"+ _stock_policy+ "%^RESET%^");
   }
   else
   {
      display = "This is the list of management policies.\n\n";
   }
   if (!m_sizeof(policies))
   {
      return display;
   }
   foreach(string policy in m_indices(policies))
   {
      if(_office->query_manager(this_player()->query_name()) ||
         _office->query_retired(this_player()->query_name()) ||
         this_player()->query_creator())
      {
         display += sprintf("%d [%s]. %s\n", i++, policy,
            policies[policy][0]);
      }
      else
      {
         display += sprintf("%d. %s\n", i++, policies[policy][0]);
      }
   }
   return display;
}
void set_office(string office)
{
   _office = office;
   _stock_policy = _office->get_stock_policy();
}
void set_type(int type) { _type = type; }

==================================================
FILE: misc/player_shop/shopping_bag.c
==================================================

#include <move_failures.h>
#include <player_shop.h>
inherit "/obj/baggage";
void setup()
{
   set_name("bag");
   set_short("shopping bag");
   add_adjective("shopping");
   set_main_plural("shopping bags");
   set_long("This is a small paper shopping bag, designed to "
      "hold a number of small items.  It doesn't look very sturdy.\n");
   set_value(3);
   set_transparent();
   add_property("no recycling",1);
   set_weight(1);
   set_max_weight(MAX_BAG_WEIGHT);
}
void change_condition()
{
   adjust_cond(-(10 + random(10)));
}
int test_add(object thing, int flag)
{
   if (sizeof(all_inventory()) >= MAX_BAG_ITEMS)
   {
      tell_object(this_player(), "The bag can only hold "+
         query_num(MAX_BAG_ITEMS)+ " items.\n");
      return 0;
   }
   if (!query_cond()) set_cond(20);
   call_out((: change_condition() :), 1);
   return ::test_add(thing,flag);
}
int test_remove(object thing, int flag, mixed dest)
{
   if (!query_cond()) set_cond(20);
   call_out((: change_condition() :), 1);
   return ::test_remove(thing,flag,dest);
}

==================================================
FILE: misc/player_shop/staff_book.c
==================================================

#include <player_shop.h>
inherit "/std/book";
private string _office = "";
void setup()
{
   set_name( "book" );
   add_alias( "handbook" );
   set_short( "staff handbook");
   set_main_plural( "staff handbooks" );
   add_adjective( "staff" );
   set_weight( 5 );
   set_value( 5 );
   set_no_pages( 12 );
   add_property( "no recycling", 1 );
}
private string cap_name(string name)
{
   if (test_player(name))
      return PLAYER_HANDLER->query_cap_name(name);
   else return capitalize(name);
}
void set_office( string office )
{
   _office = office;
   if ( !query_property( "office" ) )
   {
      add_property( "office", office );
   }
   set_long( "This is a handbook for staff of "+
     office->query_shop_name()+ ", " + office->query_place()+
     ".  It covers all aspects of the job.\n"
     "You may <read book>, <open book to page #> and "
     "<turn a page of book>.\n" );
   set_open_page( 1 );
   set_read_mess( "\n"
     "                            TABLE OF CONTENTS                    Page 1\n"
     "                    .o0o.o0o.o0o.o0o.o0o.o0o.o0o.o0o.\n\n"
     "       Introduction............................................2-4\n"
     "       The job.................................................5-6\n"
     "       The office..............................................6-7\n"
     "       The counter.............................................8\n"
     "       The storeroom...........................................9\n"
     "       The shopkeeper..........................................10\n"
     "       Promotion and pay.......................................11\n"
     "       Termination of employment...............................12\n\n",
     "common", 100 );
   set_open_page( 2 );
   set_read_mess( "\n"
     "                               Introduction                      Page 2\n"
     "                           -=-=-=-=-==-=-=-=-=-\n\n"
     " Welcome to "+ office->query_shop_name()+ ".\n"
     " This is a player-run shop, designed to operate interactively with its\n"
     " employees with minimal input from creators.\n"
     " Players are able to sell items to and buy them from the shop, just like\n"
     " a regular shop, but prices should be set such that it is advantageous\n"
     " to deal with us,  rather than some other general shop.\n\n"
     " A list of items in which the shop deals is maintained in the shop's\n"
     " office, where a chart shows the buying and selling prices of items,\n"
     " as well as how many are in stock, the maximum number that the shop\n"
     " will keep in stock and the average number that has recently been in\n"
     " stock; the stock itself is saved over a reboot.        (Continued...)",
     "common", 100 );
   set_open_page( 3 );
   set_read_mess( "\n"
     "                                                                 Page 3\n\n"
     " The most important feature of the shop is that it is run by players,\n"
     " with a non-player employee who stands in when there are no player\n"
     " employees about.  Players who work faithfully for the shop will be\n"
     " promoted to supervisor and then to manager, as well as receiving a\n"
     " regular wage which increases with employment level.\n\n"
     " As well as hiring new employees, managers are also responsible for\n"
     " firing employees who break trust.  Supervisors (and managers) are\n"
     " responsible for keeping the shop running efficiently by adding new\n"
     " items to those in which the shop deals, by adjusting selling and\n"
     " buying prices and inventory limits to reflect supply and demand and\n"
     " by removing items in which it is no longer reasonable to deal.\n\n"
     " Supervisors are also given access to the shop's log books which\n"
     " contain details of everything that happens.           (Continued...)",
     "common", 100 );
   set_open_page( 4 );
   set_read_mess( "\n"
     "                                                                 Page 4\n\n"
     " Finally, while it is intended, and hoped, that the shop will run\n"
     " autonomously under player control, it is inevitable that problems\n"
     " will arise from time to time which cannot be solved by the shop's\n"
     " player managers and supervisors.  Should such problems arise, please\n"
     " don't hesitate to contact myself or another creator.\n"
     " Enjoy your time with "+ _office->query_shop_name()+ ".\n "+
     cap_name( _office->query_creator() )+ " (caretaker)\n", "common", 100 );
   set_open_page( 5 );
   set_read_mess( "\n"
     "                                 The Job                         Page 5\n"
     "                               -=-=-=-=-=-\n\n"
     " It is the responsibility of employees to ensure that the shop is\n"
     " kept as fully stocked as possible.  This may be achieved by buying\n"
     " items from players, or by collecting the items yourself.  Although\n"
     " you are not expected to come running to the shop every time a\n"
     " customer walks in, once you are clocked in, you should not leave\n"
     " the shop until you clock out again.\n\n"
     " All of the commands that are available to the shop's employees\n"
     " should be obvious from the various rooms of the shop; those available\n"
     " in the office are described by giving the command %^B_RED%^office%^RESET%^.\n"
     " Possibly the most important command is %^B_RED%^log%^RESET%^, which must be "
     "used to record\n"
     " each transaction.  All activity within the shop is logged, and so it is\n"
     " vital to record each sale and purchase in the correct manner so that the\n"
     " shop's supervisors and managers can see what happened when they examine\n"
     " the logs.  Examples of the \"log\" command are given in the section\n"
     " dealing with the counter.\n",
     "common", 100 );
   set_open_page( 6 );
   set_read_mess( "\n"
     "                               The Office                          Page 6\n"
     "                             -=-=-=-==-=-=-\n\n"
     " The office of the shop is the nerve-centre.  This is where you can\n"
     " obtain most of your information, and is where you clock in and out.\n"
     " A description of the \"office\" commands you can use from here is\n"
     " given below.\n\n"
     " clock - Clock in or out of work.  You are only paid for the work\n"
     "         you do whilst you are clocked in.\n"
     " claim - Claim a staff badge, a copy of this book, or your monthly\n"
     "         bonus.  The badge itself has some nifty functions - look\n"
     "         at one for further information.\n"
     " list - List the employees of the shop, and find out your current\n"
     "        standing for promotion.  This shows the percentage of points\n"
     "        you have achieved towards your next promotion.\n"
     " bank - Change, or check your banking details.  Your pay can be paid\n"
     "        into the bank of your choice.  Your bonus is given in cash when\n"
     "        you \"claim\" it.\n"
     " promotion - Allows you to specify whether to be automatically promoted\n"
     "             or not.  If not, you will not be promoted once gaining the\n"
     "             required points until you specify otherwise.\n"
     " resign - End your employment with the shop.             (Continued...)\n",
     "common", 100 );
   set_open_page( 7 );
   set_read_mess( "\n"
     "                                                                 Page 7\n\n"
     " Supervisors receive two additional commands - \"chart\" and \"logs\".\n"
     " The \"logs\" command allows a supervisor to review the logs, whilst the\n"
     " \"chart\" command allows them to add and remove items from the shop's\n"
     " list, set the maximum stock level, buy & sell prices, and assign them\n"
     " to a cabinet.  If an item is not assigned to a cabinet, it cannot be\n"
     " stored.  The \"check\" command allows supervisors to check which items\n"
     " are allocated to each cabinet.\n"
     " It is important to note that an item can be assigned to more than one\n"
     " cabinet, and that a cabinet can be assigned more than one item.  It is\n"
     " the supervisor's responsibility to ensure that items are judiciously\n"
     " assigned to ensure that the most efficient use is made of the available\n"
     " storage space.\n"
     " To view details of items stocked by the shop, simply \"look\" at the\n"
     " chart in the office.\n\n"
     " In addition, if there is no notice board in the shop, employees may use\n"
     " the \"memo\" command to send a mail to all the employees of the shop.\n",
     "common", 100 );
   set_open_page( 8 );
   set_read_mess( "\n"
     "                               The Counter                        Page 8\n"
     "                             -=-=-=-=-=-=-=-\n\n"
     " The counter houses the shop's cash register, and allows employees to\n"
     " \"log\" transactions.  There is also a \"calc\"ulator for use in those\n"
     " difficult situations.  All monies entering or exiting the register are\n"
     " logged, so if you are tempted, please bear in mind that supervisors can\n"
     " see exactly who took that $1000 from the till ;-)\n\n"
     " The log command can be confusing, so the following examples have been\n"
     " provided.  All entries are made from the point of view of the shop with\n"
     " the syntax: %^B_RED%^log shop bought|sold <quantity> <item> for <amount>%^RESET%^.\n"
     " Examples:\n\n"
     " A customer sells 5 gizmos to the shop at 20 pence each. The log entry is:\n"
     " %^B_RED%^log shop bought 5 gizmos for 100p%^RESET%^ (or $1 instead of 100p)\n\n"
     " A customer buys 20 elephants from the shop at 10 pence each.\n"
     " The log entry is:\n"
     " %^B_RED%^log shop sold 20 elephants for 200p%^RESET%^ (or $2 instead of 200p)\n\n"
     " If you do happen to make an error whilst logging a transaction, you\n"
     " may use the \"correction\" facility to note the error.  This will\n"
     " not erase the error, but will clarify that an error has been made.\n"
     " The syntax is the same as that of \"log\".\n\n"
	  " Please note that these are examples only, and you may be using a different\n"
	  " currency.\n\n",
     "common", 100 );
   set_open_page( 9 );
   set_read_mess( "\n"
     "                               The Storeroom                      Page 9\n"
     "                             -=-=-=-=-=-=-=-=-\n\n"
     " The storeroom, unsurprisingly, is where the shop's stock is stored.\n"
     " The stock itself is stored in several store cabinets, located in this\n"
     " room.  Each cabinet has a maximum stock capacity of "+ STOCK_PER_CABINET+ ".\n"
     " There are three commands available for dealing with the stock:\n\n"
     "   add - add items to the stock\n"
     "   remove - remove items from the stock\n"
     "   list - list all stock, or individual items\n\n"
     " These commands can be used relative to the whole stock, or by an\n"
     " individual cabinet.  For example, to add 10 beans to the stock, you\n"
     " could let the storeroom decide where to put the items by saying:\n"
     "   \"add 10 beans\"\n"
     " or specify a cabinet in which to place the beans:\n"
     "   \"add 10 beans to cabinet 1\"\n"
     " Generally, it is easier to use the first syntax and let the storeroom\n"
     " decide things for you.  Be aware that it will not let you place an item\n"
     " in the wrong cabinet, or in a cabinet that is full.\n"
     " For more information, see \"syntax <command>\"\n\n", "common", 100 );
    set_open_page( 10 );
    set_read_mess( "\n"
     "                              The Shopkeeper                     Page 10\n"
     "                           -=-=-=-=-=-=-=-=-=-\n\n"
     " With regard to the shopkeeper, when you leave the shop for other\n"
     " activities, it is important to clock out in order that they can be\n"
     " summoned from their home to staff the shop.  Conversely, when you clock\n"
     " in for work, say to them that you'll take over, and they will return\n"
     " home. Please also make sure that the cash register always contains\n"
     " plenty of the lowest denomination coins as, for religious reasons,\n"
     " they are incapable of handling the larger denominations of coinage.\n",
     "common", 100 );
   set_open_page( 11 );
   set_read_mess( "\n"
     "                              Promotion and pay                  Page 11\n"
     "                           -=-=-=-=-=-=-=-=-=-=-=-\n\n"
     " Promotion within the shop depends entirely on how much work an\n"
     " employee does.  Once an employee has done the required amount,\n"
     " they will be promoted automatically unless they have requested\n"
     " otherwise.  When you are promoted to supervisor, you will gain\n"
     " access to the shop's logs and also be able to add/remove items\n"
     " from the chart as well as adjust the buy/sell and maximum stock\n"
     " level of those items.  After even more work, the dedicated employees\n"
     " will be promoted to manager.\n"
     " Pay is also based on the amount of work that you do.  You will be\n"
     " paid each month directly into your bank account at whichever bank\n"
     " you specify in the office.  As a supervisor or manager, you will\n"
     " enjoy a higher rate of pay.\n"
     " Managers are responsible for allocating funds towards the monthly\n"
     " bonus fund.  This fund will be divided up between employees at the\n"
     " end of each month as long as those employees have been employed for\n"
     " the full month, and have not had their bonus suspended.\n"
     " It is up to each individual to claim their bonus during that month.\n"
     " All unclaimed bonuses will be added to the next month's fund.\n",
     "common", 100 );
   set_open_page( 12 );
   set_read_mess( "\n"
     "                         Termination of employment                Page 12\n"
     "                      -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-\n\n"
     " If you no longer wish to work at the shop then you can resign from\n"
     " your position.  This can be done from the shop office.  If you do\n"
     " resign, please remember to return your employee badge.\n\n"
     " Managers have the power to fire employees for breach of trust.\n"
     " Reasons for dismissal include (but are not restricted to):\n"
     "     Dishonesty (Stealing items or cash from the shop)\n"
     "     Inactivity (Not working in the shop for prolonged periods)\n"
     "     The killing of any employee on duty\n"
     "     The killing of anybody whilst on duty\n"
     "     Not returning to the shop whilst on duty\n"
     "     Teleporting into or encoding the location of employee areas\n\n"
     " If you are fired without good reason, then you can appeal to any\n"
     " manager.  Bear in mind though, that all decisions taken with regard\n"
     " to the hiring and firing of employees will normally have been\n"
     " discussed by the managers beforehand and will usually have been\n"
     " preceded by a warning.\n", "common", 100 );
   set_open_page( 0 );
}
void init ()
{
   set_open_page( 0 );
   if ( !_office || _office == "" )
   {
      if ( !query_property( "office" ) )
      {
         return;
      }
      _office = query_property( "office" );
      set_office( _office );
   }
   if ( !_office->query_employee( environment( this_object() )->query_name() ) &&
     !_office->query_retired( environment( this_object() )->query_name() ) &&
     !environment( this_object() )->query_creator() )
   {
      return;
   }
   ::init();
}

==================================================
FILE: misc/traps/fast_acting_needle_trap.c
==================================================

inherit "/obj/misc/trap";
void setup() {
   set_name("trap");
   set_weight(1);
   set_short("fast-acting needle trap");
   add_adjective(({ "fast-acting", "fast", "acting", "needle" }));
   set_long("This is a needle trap suitable for rigging inside "
            "the lock of a door. It uses a small needle that "
            "will inject a fast acting poison into anyone "
            "clumsily picking "
            "the lock.\n");
   make_trap(250, "pick",
             "Hidden inside the lock is a small mechanism "
             "which, if touched by an clumsily wielded tool "
             "will cause a small needle to swing out and poison "
             "an unwary thief.\n",
             ({"A small needle swings out of the lock injecting "
                 "poison.\n",
                 "A small needle sings out of the lock.\n" }),
             500);
   set_value(80000);
}

==================================================
FILE: misc/traps/gas_trap.c
==================================================

inherit "/obj/misc/trap";
void setup() {
   set_name("trap");
   set_weight(1);
   set_short("gas trap");
   add_adjective("gas");
   set_long("This is a gas trap suitable for rigging inside "
            "the lock of a door. It uses a small ampule of "
            "poison gas that is ejected by someone attempting "
            "to pick the lock.\n");
   make_trap(300, "pick",
             "Hidden inside the lock is a small ampule which, "
             "if touched by an unwary tool would trigger a "
             "puff of poisonous gas.",
             ({"A small cloud of gas puffs out of the lock.\n",
                 "A small cloud of gas puffs out of the lock.\n"}),
             ({"/std/effects/poisons/poison_gas", 600}));
   set_value(120000);
}

==================================================
FILE: misc/traps/leg_trap.c
==================================================

inherit "/obj/misc/trap";
void setup() {
   set_name("trap");
   set_weight(1);
   set_short("leg trap");
   add_adjective("leg");
   set_long("This trap has a trigger suitable for rigging inside "
            "the lock of a door. It uses a small portion of the floor "
            "in front of the door to conceal a blunt leg trap that will "
            "shatter the femurs of any clumsy thief that attempt to "
            "pass through.\n");
   make_trap(350, "pick",
             "Hidden inside the lock is a trigger that leads down to a "
             "concealed panel on the floor. Carefully lifting the panel "
             "you see a vicious blunt man trap, designed to break any "
             "unskilled questionable entrant.\n",
             ({"A small click is heard, and the floor beneath your feet "
               "snaps away to reveal a leg trap which snaps together "
               "violently, shattering both your legs at once!\n",
               "A small click is heard and the jaws of a man trap burst out "
               "of the ground below " + this_player()->query_short() + "'s "
               "feet and shatters both of their legs!\n" }),
             ({ "/std/effects/disease/broken_leg", ({ "left", "right"}) }));
   set_value(1000000);
}

==================================================
FILE: misc/traps/needle_trap.c
==================================================

inherit "/obj/misc/trap";
void setup() {
   set_name("trap");
   set_weight(1);
   set_short("needle trap");
   add_adjective("needle");
   set_long("This is a needle trap suitable for rigging inside "
            "the lock of a door. It uses a small needle that "
            "will inject poison into anyone clumsily picking "
            "the lock.\n");
   make_trap(200, "pick",
             "Hidden inside the lock is a small mechanism "
             "which, if touched by an clumsily wielded tool "
             "will cause a small needle to swing out and poison "
             "an unwary thief.\n",
             ({"A small needle swings out of the lock injecting "
                 "poison.\n",
                 "A small needle sings out of the lock.\n" }),
             ({ "/std/effects/poisons/spider_venom", 30 }));
   set_value(20000);
}

==================================================
FILE: misc/traps/powder_trap.c
==================================================

inherit "/obj/misc/trap";
void setup() {
   set_name("trap");
   set_weight(1);
   set_short("anthrax trap");
   add_adjective("anthrax");
   set_long("This is a anthrax trap suitable for rigging inside "
            "the lock of a door. It uses a small envelope that "
            "will open in the face of anyone clumsily picking "
            "the lock.\n");
   make_trap(200, "pick",
             "Hidden inside the lock is a small envelope "
             "which, if touched by an clumsily wielded tool "
             "will open up and infect an unwary thief.\n",
             ({"A small envelope opens up and a puff of powder "
                "explodes into your face, which you inadvertantly "
                "inhale. The envelope has \"Congratulations! You've "
                "Been Infected With Anthrax!\" written in bold "
                "cheery letters.\n",
                 "A cloud of powder puffs out of the lock.\n" }),
             ({ "/std/effects/disease/common_cold", 6000 }));
   set_value(10000);
}

==================================================
FILE: misc/buckets/.bucket_small.ob_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/vessel.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/misc/buckets/bucket_small.ob#1" );
  call_other( clone, "set_name",  "bucket"  );
  call_other( clone, "set_short",  "small bucket"  );
  call_other( clone, "set_long",  "This is a small metal bucket.  It is not very shiny.\n"  );
  call_other( clone, "set_main_plural",  "small buckets"  );
  call_other( clone, "add_adjective",  "small"  );
  call_other( clone, "add_plural",  "buckets"  );
  call_other( clone, "set_stuck",  1  );
  call_other( clone, "set_leak_rate",  0  );
  call_other( clone, "set_max_volume",  3000  );
  call_other( clone, "set_max_weight",  30  );
  call_other( clone, "set_full_weight",  30  );
  call_other( clone, "set_value",  85  );
  call_other( clone, "set_weight",  10  );
  call_other( clone, "set_material",  "metal" );
   return clone;
}

==================================================
FILE: monster/cabbage.c
==================================================

inherit "/obj/monster";
#define SCATHE "/cmds/guild-race/magic/scathe"
#define LANCE "/obj/spells/mental_lance"
#include <config.h>
#ifndef __DISTRIBUTION_LIB__
#include <special_day.h>
#endif
#include <move_failures.h>
#include <armoury.h>
object query_owner();
void check_env();
void zap_cabbage();
string long_desc();
int eaten;
string owner_name, owner_short, language;
object owner;
void setup() {
  set_name( "cabbage" );
  set_short( "cabbage" );
  set_long( "A small cute looking cabbage.\n" );
  set_race( "cabbage" );
  set_level( 1 );
  add_respond_to_with( ({ ({ "@hug", "@snuggle", "@cuddle", "@nestle",
    "@snuffle", "@smooch", "@fondle", "@huggle", "@squeeze", "@wuffle"
    "@hop", "@lick", "@snog", "@fluff", "@nuzzle" }), "you" }),
    "#respond_nice");
  add_respond_to_with( ({ ({ "@skick", "@spunch", "@sburn", "@jump", }),
    "you" }), "#respond_nasty");
#ifndef __DISTRIBUTION_LIB__
  if (SPECIAL_DAY_HANDLER->query_special_day() == CABBAGE_DAY) {
    add_property( "player", 1 );
    set_get();
  }
#endif
}
void init() {
  ::init();
  this_player()->add_command("eat", this_object(), "<direct:object'cabbage'>" );
  call_out( "check_env", 3 );
}
void set_owner( object thing ) {
  if (!objectp( thing ) )
    return;
  set_long( (: long_desc :) );
  owner = thing;
  owner_name  = owner->query_name();
  owner_short = owner->query_short();
  language = owner->query_default_language();
  add_language( language );
  set_language( language );
  load_chat(30, ({
    1, "@roll up",
    1, "@purr",
    1, ":$V$0=ruffles its,ruffle their$V$ fronds.",
    1, ":$V$0=looks,look$V$ green.",
    3, "#soul_owner",
    1, "@roll over",
    1, "#check_env" }) );
  check_env();
}
string long_desc() {
  if ( owner && environment( owner ) == environment() ) {
    return "This small, cute-looking cabbage stares adoringly at "
      + owner->the_short() + ".\n";
  }
  return "This small, cute-looking cabbage is looking off into the "
    "distance.  It is obviously hopelessly lost.\n";
}
void respond_nice( object souler ) {
  if ( !souler->query_visible(this_object()) )
    return;
  if ( owner && souler == owner) {
    do_command("nestle " + souler->query_name() );
  } else {
    do_command("peer curiously " + souler->query_name() );
  }
}
void respond_nasty( object souler ) {
  if ( !souler->query_visible(this_object()) )
    return;
  if ( owner && souler == owner) {
    do_command("gasp");
    do_command("cry");
  } else {
    do_command( "sburn " + souler->query_name() + " dreams");
  }
}
int do_eat() {
  if ( this_player() != owner || eaten) {
    this_player()->add_failed_mess( this_object(), "You cannot eat this "
      "cabbage!\n" );
  return -1;
  }
  if( this_player()->query_property("dead") ) {
    this_player()->add_failed_mess( this_object(), "You are dead.  You "
      "cannot eat.\n" );
  }
#ifndef __DISTRIBUTION_LIB__
    if (SPECIAL_DAY_HANDLER->query_special_day() == CABBAGE_DAY) {
      this_player()->add_failed_mess(this_object(), "This is *my* day, "
      "how can you even think of eating me, your faithful cabbage!\n" );
      return -1;
    }
#endif
  this_player()->add_succeeded_mess( this_object(),
    ({ "The cabbage lovingly and "
       "adoringly purrs quietly as you viciously rip off its fronds and "
       "eat it.  It dies looking wonderingly into your face.\n",
       "$N $V $D.\n" }) );
    this_player()->add_effect("/std/effects/object/cabbage", 150);
    call_out("zap_cabbage", 2 );
    return 1;
}
void zap_cabbage() {
  if ( environment() ) {
    all_inventory()->move( environment() );
  }
  if ( owner ) {
    do_command( "unfollow " + owner_name );
  }
  eaten = 1;
  owner = 0;
  owner_name = 0;
  owner_short = 0;
  move( "/room/rubbish" );
}
int attack_by(object ob) {
  if( ( !query_owner() || ob == query_owner() ) &&
        base_name( previous_object() ) == LANCE )
    call_out( "coleslaw", 2 );
  ob->stop_fight(this_object());
  tell_object(ob, "The cabbage is a terrible pacifist.\n");
}
int attack_ob(object ob) {
  ob->stop_fight(this_object());
  tell_object(ob, "The cabbage is a terrible pacifist.\n");
}
int adjust_hp(int number, object attacker) {
  return 0;
}
void soul_owner() {
  string *souls = ({ "snuggle ", "nestle ", "stare dreamily ", "snuffle " });
  if(!owner)
    return;
  if ( environment() != environment( owner ) ) {
    do_command( "sniffle sadly" );
    return;
  }
  if ( !owner->query_visible(this_object()) )
    return;
  do_command( souls[random(sizeof(souls))] + owner_name );
}
void check_env() {
  object my_env, owner_env, *caterpillars;
  if ( !owner_name )
    return;
  my_env = environment();
    if ( !my_env ) {
        return;
    }
  if ( owner_name && !owner ) {
    do_command( "cry" );
    do_command( "'Woe is me! Where art thou, " + owner_short + "?" );
    call_out("zap_cabbage", 1);
    return;
  }
  owner_env = environment( owner );
  if ( !owner_env ) {
    return;
  }
  if ( file_name( my_env ) == "/room/rubbish" ) {
    return;
  }
  if ( this_object()->query_property( "dead" ) ) {
    return;
  }
  if (my_env == owner) {
    return ;
  }
  if (owner_env == my_env) {
    return ;
  }
  if (owner_env->query_mirror_room() == my_env) {
    return ;
  }
  caterpillars = match_objects_for_existence( "caterpillar", ({ owner_env }) );
  if ( my_env != owner_env && !sizeof(caterpillars)) {
    move( owner_env, "$N appear$s with a squelch.",
      "$N disappear$s with a squelch." );
    do_command( "follow " + owner_name );
  }
}
object query_owner() {
    return owner;
}
int query_theft_command() {
    return -1;
}
void coleslaw() {
  object ob;
  tell_room( environment(), the_short() + " explodes in a shower of "
      "fronds.\n" );
  ob = ARMOURY->request_object("coleslaw", 100);
  if (ob) {
     ob->move( environment() );
  }
  zap_cabbage();
}

==================================================
FILE: monster/cockroach.c
==================================================

inherit "/obj/monster";
void setup() {
   set_name("cockroach");
   set_short("cockroach");
   set_race("cockroach");
   set_level( random( 1 + random( 3 ) ) );
   set_main_plural("cockroaches");
   add_alias( "roach" );
   add_plural( "roaches" );
   add_adjective("dirty");
   set_long("This is a huge dirty great big cockroach, the size of your "
            "hand at least.  It waves it feelers at you and looks "
            "horrible and black.  Not only can cockroaches survive "
            "a nuclear blast, they can survive in Ankh-Morpork!\n");
   load_chat( 5, ({
         10, ":scuttles around a bit.",
         10, ":cleans its feelers.",
         10, ":rushes around in circles.",
         1,  ":jerks off in a strange direction.",
      }) );
   set_wimpy( 30 );
   load_a_chat( 50, ({
         1, ":oozes horrible white stuff.",
         1, ":makes a sort of scraping noise."
      }) );
}

==================================================
FILE: monster/commercial.c
==================================================

inherit "/obj/monster";
#include <money.h>
private object _sell_to;
private string* _furniture;
private string _commercial_type;
int do_list(int force);
void setup() {
   set_name("spulluf");
   set_gender(1 + random(2) );
   set_long("A nice happy person with a nice smile.\n");
   add_property("demon", 1);
   set_race( "human" );
   set_level( 1 );
   add_help_file("spulluf");
   add_respond_to_with(({ "@say", "browse" }), "#do_browse");
   add_respond_to_with(({ "@say", "buy" }), "#do_buy");
   _furniture = ({
        "/obj/furnitures/commercial/smithy",
        "/obj/furnitures/commercial/money_changer",
        "/obj/furnitures/commercial/blackjack",
        "/obj/furnitures/commercial/small_shop",
        "/obj/furnitures/commercial/pickler",
        "/obj/furnitures/commercial/blackboard",
        "/obj/furnitures/commercial/newspaper_box",
        "/obj/furnitures/commercial/newspaper_archive_box",
        "/obj/furnitures/commercial/bank_master",
        "/obj/furnitures/commercial/bank_franchise_small",
        "/obj/furnitures/commercial/postal",
        "/obj/furnitures/commercial/poll_data",
      });
}
string query_money_place() {
   return environment()->query_property("place");
}
void set_commercial_type(string commercial_type) {
   _commercial_type = commercial_type;
}
void do_start_speil(object sellto) {
   setup_nationality(sellto->query_nationality(), sellto->query_nationality_region());
   _sell_to = sellto;
   queue_command("sayto " + file_name(_sell_to) +
                 " Hello!  So you are looking at some commercial "
                 "furniture?");
}
int do_list(int force) {
   string furn;
   string place;
   int num;
   int size;
   object ob;
   if (!_sell_to) {
      call_out("leave_room", 5);
      return 0;
   }
   if (!force && this_player() != _sell_to) {
      queue_command("sayto " + file_name(this_player()) +
                 " I am dealing with " + _sell_to->the_short() +
                 " right now.");
      return 1;
   }
   queue_command("sayto " + file_name(_sell_to) +
                 " I have the following items available.");
   num = 0;
   place = query_money_place();
   foreach (furn in _furniture) {
      if (!_commercial_type ||
          furn->query_commercial_type() == _commercial_type) {
         queue_command("sayto " + file_name(_sell_to) +
                    sprintf(" %c) %s costs %s (%d square yards)",
                            num + 'A', furn->the_short(),
                            MONEY_HAND->money_value_string(furn->query_value(), place),
                            furn->query_commercial_size()));
         num++;
      }
   }
   foreach (ob in all_inventory(environment())) {
      size += ob->query_commercial_size();
   }
   queue_command("sayto " + file_name(_sell_to) +
                  " The size of your shop is " +
                  environment()->query_property_size() +
                  " square yards and you have " +
                  (environment()->query_property_size() - size) +
                  " square yards of empty space.");
   return 1;
}
string strip_spaces(string str) {
   while (strlen(str) && str[0] == ' ') {
      str = str[1..];
   }
   while (strlen(str) && str[<1] == ' ') {
      str = str[0..<2];
   }
   return str;
}
void leave_room() {
   move("/room/rubbish", "$N shuffles away.");
}
int do_browse(string str) {
   mapping options;
   mapping values;
   string option_name;
   string thing;
   string* bits;
   string place;
   int cost;
   int pos;
   string* furns;
   if (!_sell_to) {
      call_out("leave_room", 5);
      return 0;
   }
   place = query_money_place();
   if (this_player() != _sell_to) {
      queue_command("sayto " + file_name(this_player()) +
                 " I am dealing with " + _sell_to->the_short() +
                 " right now.");
      return 1;
   }
   str = lower_case(str);
   pos = str[0] - 'a';
   if (_commercial_type) {
      furns = filter(_furniture, (: $1->query_commercial_type() == _commercial_type :));
   } else {
      furns = _furniture;
   }
   if (strlen(str) > 1 || pos < 0 || pos >= sizeof(furns)) {
      queue_command("sayto " + file_name(_sell_to) +
                    " Sorry, I do not understand which thing "
                    "you want to browse.\n");
      return 1;
   }
   queue_command("sayto " + file_name(_sell_to) + " " +
                 furns[pos]->the_short() + " costs " +
                 MONEY_HAND->money_value_string(furns[pos]->query_value(), place) +
                 " and takes up " + furns[pos]->query_commercial_size() +
                 " square yards.");
   if (furns[pos]->query_weekly_upkeep_cost()) {
      queue_command("sayto " + file_name(_sell_to) +
                    " Costs " +
                    MONEY_HAND->money_value_string(furns[pos]->query_weekly_upkeep_cost(), place) +
                    " per week in upkeep.");
   }
   queue_command("sayto " + file_name(_sell_to) +
                 " " +
                 furns[pos]->long()[0..<2]);
   thing = furns[pos]->query_commercial_information();
   if (thing) {
      queue_command("sayto " + file_name(_sell_to) +
                    " " + thing);
   }
   options = furns[pos]->query_commercial_options();
   if (options) {
      queue_command("sayto " + file_name(_sell_to) +
                    " You have the following options for " +
                    furns[pos]->the_short());
      foreach (option_name, values in options) {
         bits = ({ });
         foreach (thing, cost in values) {
            bits += ({ "'" + thing + "' costs " +
                       MONEY_HAND->money_value_string(cost, place) });
         }
         queue_command("sayto " + file_name(_sell_to) +
                       " The options for '" + option_name  + "' are " +
                       query_multiple_short(bits));
      }
   }
   return 1;
}
int do_buy(string str, string options) {
   string place;
   string* bits;
   string name;
   string value;
   string thing;
   string option_name;
   string my_option;
   int pos;
   int size;
   int cost;
   int total_cost;
   int bad_option;
   int found;
   mapping option_types;
   object ob;
   string* furns;
   mapping values;
   mapping option_values;
   if (!_sell_to) {
      call_out("leave_room", 5);
      return 0;
   }
   place = query_money_place();
   if (this_player() != _sell_to) {
      queue_command("sayto " + file_name(this_player()) +
                 " I am dealing with " + _sell_to->the_short() +
                 " right now.");
      return 0;
   }
   str = lower_case(str);
   pos = str[0] - 'a';
   if (_commercial_type) {
      furns = filter(_furniture, (: $1->query_commercial_type() == _commercial_type :));
   } else {
      furns = _furniture;
   }
   if (strlen(str) > 1 || pos < 0 || pos >= sizeof(furns)) {
      queue_command("sayto " + file_name(_sell_to) +
                    " Sorry, I do not understand which thing "
                    "you want to buy.\n");
      return 1;
   }
   if (furns[pos]->disallow_sale_here(environment())) {
      queue_command("sayto " + file_name(_sell_to) +
                    " Sorry, this room disallows the purchase of that item.");
      return 0;
   }
   bits = explode(options, ",");
   option_types = ([ ]);
   foreach (thing in bits) {
      if (sscanf(thing, "%s=%s", name, value) == 2) {
         name = strip_spaces(name);
         value = strip_spaces(value);
         option_types[lower_case(name)] = lower_case(value);
      }
   }
   foreach (ob in all_inventory(environment())) {
      size += ob->query_commercial_size();
   }
   if (size + furns[pos]->query_commercial_size() >
       environment()->query_property_size()) {
      queue_command("sayto " + file_name(_sell_to) +
                    " The item " + furns[pos]->the_short() +
                    " is too big to fit into " + environment()->the_short());
      return 0;
   }
   option_values = furns[pos]->query_commercial_options();
   if (option_values) {
      foreach (option_name, values in option_values) {
         my_option = option_types[lower_case(option_name)];
         if (!my_option) {
            queue_command("sayto " + file_name(_sell_to) +
                    " The option '" + option_name + "' needs to be "
                    "specified.");
            bad_option = 1;
         } else {
            foreach (thing, cost in values) {
               if (lower_case(thing) == my_option) {
                  total_cost += cost;
                  found = 1;
                  option_types[lower_case(option_name)] = thing;
               }
            }
            if (!found) {
               queue_command("sayto " + file_name(_sell_to) +
                       " The option " + option_name + " has options "
                       "of " + query_multiple_short(keys(values)) + ".");
               bad_option = 1;
            }
         }
      }
   }
   if (bad_option) {
      return 0;
   }
   total_cost += furns[pos]->query_value();
   if (this_player()->query_value_in(place) < total_cost) {
      queue_command("sayto " + file_name(_sell_to) +
              " You do not have the " +
              MONEY_HAND->money_value_string(total_cost, place) +
              " to buy " + furns[pos]->the_short() + ".");
      return 0;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(total_cost, place),
                            place);
   ob = clone_object(furns[pos]);
   foreach (name, thing in option_types) {
      ob->set_commercial_option(name, thing, environment());
   }
   ob->move(environment());
   return 1;
}
int do_dismiss() {
   if (_sell_to && this_player() != _sell_to) {
      queue_command("sayto " + file_name(this_player()) +
                 " I am dealing with " + _sell_to->the_short() +
                 " right now.");
      return 1;
   }
   queue_command("sayto " + file_name(this_player()) +
                 " Goodbye, see you next time.");
   call_out("leave_room", 5);
   return 1;
}
int do_trash(object* obs) {
   object* ok;
   object* bad;
   ok = filter(obs, (: $1->query_commercial_furniture() :));
   if (!sizeof(ok)) {
      queue_command("sayto " + file_name(_sell_to) +
                    " None of " + query_multiple_short(obs) + " are "
                    "commercial items, so I cannot remove them.");
      return 0;
   }
   bad = filter(ok, (: !$1->can_trash_furniture() :));
   if (sizeof(bad)) {
      this_player()->add_failed_mess(this_object(),
                      "The items $I are unable to be trashed.  Perhaps they "
                      "still have something in them?\n");
      return 0;
   }
   write("Are you sure you want to trash " + query_multiple_short(ok) +
         "; this will get rid of them completely? ");
   input_to("complete_trash", 0, ok);
   this_player()->add_succeeded_mess(this_object(), "", ({ }));
   return 1;
}
void complete_trash(string str, object* obs) {
   str = lower_case(str);
   if (!strlen(str) || str[0] != 'y') {
      write("Aborting trash.\n");
   }
   queue_command("sayto " + file_name(_sell_to) + " Trashing " +
                 query_multiple_short(obs) + " for you.\n");
   obs->move("/room/rubbish", "", the_short() + " points at $N and it rips "
             "apart then vanishes.");
}
void init() {
   ::init();
   this_player()->add_command("trash", this_object(),
                              "<indirect:object> with <direct:object>",
                              (: do_trash :));
   this_player()->add_command("dismiss", this_object(),
                              "<direct:object>",
                              (: do_dismiss() :));
   this_player()->add_command("list", this_object(),
                              "<direct:object>",
                              (: do_list(0) :));
   this_player()->add_command("list", this_object(),
                              "{on|from} <direct:object>",
                              (: do_list(0) :));
   this_player()->add_command("browse", this_object(),
                              "<string'name'> on <direct:object>",
                              (: do_browse($4[0]) :));
   this_player()->add_command("buy", this_object(),
                              "<string'name'> {on|from} <direct:object>",
                              (: do_buy($4[0], "") :));
   this_player()->add_command("buy", this_object(),
                              "<string'name'> with <string'options'> {on|from} <direct:object>",
                              (: do_buy($4[0], $4[1]) :));
}

==================================================
FILE: monster/greco.c
==================================================

#define ITEM_TRACKER ("/obj/handlers/item_tracker")
inherit "/obj/monster";
object my_player;
mixed total_als;
object *save_obs;
object *unhandled_obs;
object *done_obs;
int grecos_day_off;
void setup() {
  seteuid("Root");
  if (!grecos_day_off) {
    set_name("greco");
    set_short("Greco the Departure Gecko");
    set_long("A small mottled grey gecko whose job it is to record all of "
             "the baggage of players so they can be restocked when they "
             "come back.  Greco is currently scribbling in "
             + query_possessive() + " notebook furiously.\n");
  } else {
    set_name("gumboot");
    set_short("Gumboot");
    set_long("A big black lizard who looks rather confused about what "
             + query_pronoun() + " is supposed to be doing.  Nevertheless, "
             + query_pronoun() + " is trying to look busy, scrawling "
             "something into a huge log book.\n");
  }
  add_property("determinate", "");
  add_property("no_attack", 1);
  set_gender(1+random(2));
  basic_setup("gnome", "warrior", 30);
  set_language("general");
}
void set_grecos_day_off(int day_off) {
  grecos_day_off = day_off;
  setup();
}
int query_grecos_day_off() {
  return grecos_day_off;
}
void get_rid_of(object player, int verbose) {
  int i;
  catch(set_grecos_day_off("/obj/monster/greco"->query_grecos_day_off()));
  if (verbose) {
    if (!grecos_day_off) {
      tell_object(player, "Greco the Departure Gecko starts inspecting "
                          "all your items and scribbling on a "
                          "notepad.\n");
    } else {
      tell_object(player, "This is Greco's day off.\nGumboot, Greco's "
                          "distant relative, is here to take your "
                          "information.  Gumboot looks very confused "
                          "and sticks the pencil in "+
                          query_possessive()+" ear.\n");
    }
  }
  my_player = player;
  unhandled_obs = save_obs = all_inventory(player);
  total_als = ({ });
  done_obs = ({ });
  for (i = 0; i < sizeof(save_obs); i++)
    call_out("get_ob_al", 1, save_obs[i], verbose);
  call_out("finish_player", 2, verbose);
}
void get_ob_al(object ob, int verbose)
{
  mixed *als;
  unhandled_obs -= ({ ob });
  als = my_player->fragile_auto_str_ob(ob);
  done_obs += ({ ob });
  if (sizeof(als) == 0) return;
  total_als += als;
}
void handle_dead_ob(object ob) {
  int value;
  mixed *als;
  string obname;
  catch(ob->move("/room/broken"));
  value = 1000;
  catch(value = ob->query_value());
  obname = "unknown object";
  catch(obname = ob->short(1));
  catch("/obj/misc/al_receipt"->set_object(file_name(ob)));
  "/obj/misc/al_receipt"->set_obname(obname);
  "/obj/misc/al_receipt"->set_value(value);
  als = "/global/auto_load"->
    fragile_auto_str_ob(find_object("/obj/misc/al_receipt"));
  als[0] = 1;
  if (!undefinedp(als[2][1]["::"]["cloned by"])) {
    als[2][1]["::"]["cloned by"] = "greco";
  }
  log_file("GRECO", "%s: %s - Broken object at logout: %O\n",
           ctime(time()), my_player?my_player->query_name():"0", ob);
  total_als += als;
}
void finish_player(int verbose) {
  int i, one_more;
  object *missing_obs;
  if (find_call_out("get_ob_al") != -1) {
    call_out("finish_player", 2, verbose);
    return;
  }
  if ( sizeof( unhandled_obs ) ) {
    call_out("finish_player", 2, verbose);
    return;
  }
  missing_obs = save_obs - done_obs;
  if (sizeof(missing_obs)) {
    one_more = sizeof(missing_obs);
    if (!grecos_day_off) {
      do_command("'"+(one_more==1?"One":"Some")+
                 " of your objects "+(one_more==1?"is":"are")+" broken and "
                 "will not save properly, so I will give you "+
                 (one_more==1?"a receipt for it.  This":
                              "receipts for them.  These")+
                 " can either be "
                 "sold for something vaguely like the replacement value of "
                 "the object or taken to a creator as proof of ownership "
                 "so you can ask very nicely to have it replaced.");
    } else {
      do_command("'Ummm.  I think some of these things of yours might "
                 "be broken.  Ummmm.....  Here, have some of these "
                 "receipt things.  Give them to a creator and they will "
                 "help you in trying to replace them.  Ummmm....  "
                 "Good luck.");
    }
    for (i = 0; i < sizeof(missing_obs); i++)
      handle_dead_ob(missing_obs[i]);
  }
  my_player->save_with_auto_load(total_als);
  if (verbose) {
    if (!grecos_day_off) {
      do_command( "smile brightly" );
      do_command( "'Well, everything seems to be in order.  Bye bye!" );
      do_command( "wave" );
      switch (random(3)) {
      case 0:
        tell_object(my_player, "You clamber aboard the giant spider.  It "
                    "opens the door, releases a thread of silk out into space "
                    "and, after a brief pause, climbs out after it possibly "
                    "never to be seen again ...\n");
        say(my_player->short(1) + " clambers aboard the giant spider.  It "
            "opens the door, releases a thread of silk out into space and, after "
            "a brief pause, climbs out after it.\n", my_player);
        break;
      case 1:
        tell_object(my_player, "The giant bird grabs you in its talons and leaps "
                    "out of the now open door to fly at great speed into the "
                    "black unknown ...\n");
        say(my_player->short(1) + " is grabbed by the talons of the giant bird "
            "and dragged out a door into the blackness of space.\n", my_player);
        break;
      case 2:
        tell_object(my_player, "You are thrown on to the back of the chimera.  "
                    "Clinging desperately to its mane you follow the beast out "
                    "into the inky depths.\n");
        say(my_player->short(1) + " is thrown onto the back of the chimera and "
            "dragged out into the inky depths.\n", my_player);
        break;
      }
    } else {
      do_command("smile strangely");
      do_command("'Well.  Uhhhh.  Thats it.");
      do_command("'I...  Umm.  Hope.");
      switch (random(3)) {
        case 0 :
          tell_object(my_player,
             "You clamber about a giant spider.  Gumboot starts to walk out "
             "the door and stands on one of it's feet.  You are flung from "
             "the back of the giant spider out through the door and "
             "floating meaninglessly through space.  You hope you will "
             "be seen again...\n");
          say(my_player->short(1)+" clambers aboard the giant spider.  It "
             "moves towards the door when something happens.  "+
             my_player->short(1)+" gets flung out through the door.\n");
          break;
        case 1 :
          tell_object(my_player,
             "The giant bird grabs you in it's talons and leaps out towards "
             "the now open door.\nGumboot exclaims: Wait!  I forgot to get your "
             "name!\nThe bird pauses confused and you thud into the side of "
             "the door and tumble backwards out into space, you try not "
             "notice the huge rents in your shoulder from where the talons "
             "ripped about your flesh.  Just a flesh wound.\n");
          say(my_player->short(1)+" is grabbed by the talons of the giant "
             "bird.  As they are heading for the door, Gumboot yells "
             "something at them, the bird gets disconcerted and rams "+
             my_player->short(1)+" into the door.  They tumble out into "
             "space a red line of blood showing their path.\n");
          break;
        case 2 :
          tell_object(my_player,
             "You are thrown towards the back of a chimera, you completely "
             "fail to get a hold on the mane and falls off it onto the "
             "floor.  The chimera steps backwards, convenient impaling you "
             "on a foot.  It then leaps through the door, you clutch your "
             "stomach hoping it is not permanent.\n");
          say(my_player->short(1)+" is thrown at a chimera, they don't catch "
             "hold of it, but they get impaled on it's foot when it steps "
             "back.  The chimera with a look of satisfaction dives through "
             "the door.\n");
          break;
      }
    }
  }
  tell_object(my_player, "Do come again!\n");
  foreach( object saved_ob in done_obs ) {
     reset_eval_cost();
     catch(saved_ob->set_tracked_item_status_reason("PLAYER_QUIT"));
     catch(saved_ob->dest_me());
     if ( saved_ob ) {
         catch(saved_ob->dwep());
     }
  }
  reset_eval_cost();
  catch( ITEM_TRACKER->save_all_item_states_delete_cache( my_player->query_name() ));
  catch(my_player->effects_quiting());
  catch(my_player->dest_me());
  if ( my_player ) {
    catch( my_player->dwep() );
  }
  if (my_player) {
    say(short(1) + " sighs deeply.\n");
  }
  move( "/room/rubbish", "$N appear$s.",
        "$N disappear$s in a puff of smoke." );
}

==================================================
FILE: monster/path.h
==================================================

#define PATH "/obj/monster/"

==================================================
FILE: monster/godmother/granny.c
==================================================

inherit "/obj/monster";
#include <panic.h>
#include <armoury.h>
void finish_up();
int state, start_time, prodded;
object lost;
string safeplace;
void setup() {
  start_time = time();
  set_name( "godmother" );
  set_short( "fairy godmother" );
  add_adjective( "fairy" );
  set_long( "This fairy godmother isn't quite what you expected.  She is "
    "tall and forbidding; not in the slightest bit cuddly or smiley.  She "
    "looks slightly uncomfortable and is currently glaring at her wand, "
    "which appears to be malfunctioning.  If you cross her, you might find "
    "yourself turned into a wombat or worse.\n" );
  set_race( "human" );
  set_guild( "witch" );
  set_level( 300 );
  set_gender( 2 );
  set_language("general");
  set_response_mon_understand_anything(1);
  add_property( "anchor", 1);
  ARMOURY->request_item("hobnailed boots", 100)->move( this_object() );
  ARMOURY->request_item("antique black dress", 100)->move( this_object() );
  ARMOURY->request_item("witchs pointy hat", 100)->move( this_object() );
  ARMOURY->request_item("black witches cloak", 100)->move( this_object() );
  init_equip();
  add_respond_to_with(({ "yes" }), "#yes_response");
  add_respond_to_with(({ "@nod" }), "#yes_response");
  add_respond_to_with(({ "no" }), "#no_response");
  add_respond_to_with(({ "@shake" }), "#no_response");
  add_respond_to_with(({ "@think", "somewhere", "safe" }), "#think_safe");
  add_respond_to_with(({ "@think", "safe" }), "#think_safe");
  add_respond_to_with(({ "@think", "safety" }), "#think_safe");
  add_respond_to_with(({ "@womble" }), "#think_mended_drum");
}
void do_panic(object pl) {
  string home;
  string nationality;
  nationality = pl->query_nationality();
  if ( !nationality ) {
      queue_command( "say Oops.. you haven't got a nationality, I can't "
        "send you home!");
      finish_up();
      return;
  }
  home = nationality->query_default_start_location();
  safeplace = home->query_short();
  queue_command( "say I hope you're not foreign.  You know, where "
    "you gabble at me in heathen lingo and eat foreign muck and "
    "worship objects." );
  queue_command( "say So.  You want some help to get back to the "
    + safeplace + "?" );
  queue_command( "glare "+pl->query_name() );
  lost = pl;
  start_time = time();
}
int query_waiting() { return time()-start_time; }
void yes_response(object ob) {
  if (ob != lost)
    return ;
  queue_command( "say Right then.  Close your eyes and concentrate." );
  queue_command( "say Think of somewhere safe." );
  prodded = 0;
  call_out("check_think", 30);
}
void no_response(object ob) {
  if (ob != lost)
    return ;
  queue_command( "say So why did you call me up then?", 1 );
  queue_command( "roll eyes "+lost->query_name() );
  queue_command( "pinch "+lost->query_name()+" cheek" );
  PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
  lost = 0;
}
void think_safe(object ob) {
  if (ob != lost)
    return ;
  queue_command( "say Now the world will just rearrange itself "
    "to suit you." );
  PANIC_HANDLER->finish_panic(lost, PANIC_OK);
  lost = 0;
}
void check_think() {
  if(!lost)
    return;
  if (prodded < 3 ) {
    queue_command( "say Come on, I haven't got all day.  Just think of "
      "safety." );
    queue_command( "tap" );
    prodded ++ ;
    call_out("check_think", 60);
  } else {
    queue_command( "say Young people of today..." );
    queue_command( "mutter no manners" );
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
}
void event_exit(object ob, string message, object to) {
  if (ob == lost) {
    queue_command("hrmph");
    queue_command("tell "+lost->query_name()+" Thats right!  Just walk "
      "out on me.");
    queue_command("glare "+lost->query_name() );
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
}
void event_fight_in_progress(object attacker, object attackee) {
  if (attackee == this_object()) {
    attacker->adjust_tmp_str(-4);
    attacker->adjust_tmp_con(-4);
    attacker->adjust_tmp_dex(-4);
    attacker->adjust_tmp_int(-4);
    attacker->adjust_tmp_wis(-4);
    queue_command( "say What is this travesty!  Attacking your fairy "
               "godmother, Well I never." );
    queue_command( "say "+attacker->one_short()+" I here by curse you!" );
    queue_command( "say Don't expect me to help you again." );
    queue_command( "glare "+attacker->query_name() );
    attacker->add_property("attacked godmother", time());
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
}
void hurry_up() {
  if (!lost) {
    queue_command( "blink" );
    queue_command( "say Where'd that bugger go?  Oh well.");
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
  else  check_think();
}
void finish_up() {
  if (lost) {
    queue_command( "say Well.  You took too long.  What a complete "
      "waste of time." );
    queue_command( "glare " + lost->query_name() );
    lost = 0;
  }
  else  {
    queue_command( "peer" );
    queue_command( "say Damn, they buggered off somewhere.  I hate "
      "it when they do that." );
    queue_command( "scowl" );
  }
  PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
}
void event_dest(object ob) {
  if (ob == lost) {
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
}
void dest_me() {
  if (lost) {
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
  ::dest_me();
}
int unambushable() {
  return 1;
}

==================================================
FILE: monster/godmother/magrat.c
==================================================

inherit "/obj/monster";
#include <panic.h>
#include <armoury.h>
void finish_up();
int state, start_time, prodded;
object lost;
string safeplace;
void setup() {
  start_time = time();
  set_name("garlick");
  set_short("fairy godmother");
  add_alias("godmother");
  add_adjective("fairy");
  set_long( "In the realm of Fairy Godmothers, this one must certainly "
    "take honours in a Division Yet To Be Announced.  Grimly determined "
    "to do things properly, she has woven wild flowers in her "
    "windswept, golden locks, powdered her face to a fashionable pallor "
    "and has attired herself in numerous fluttering shawls, bangles, "
    "and a vivid green gown.  The overall effect is that of a maypole "
    "with a flower box emptied over its head that happens to jingle like "
    "a tinker's wagon with a broken wheel.  With one hand she clutches her "
    "regulation wand and with the other she dabs at her red and dripping "
    "nose with a damp scrap of lace.\n");
  set_race("human");
  set_guild("witch");
  set_level(200);
  set_gender(2);
  set_language("general");
  set_response_mon_understand_anything(1);
  add_property( "anchor", 1);
  ARMOURY->request_item("startling green dress", 100)->move( this_object() );
  ARMOURY->request_item("spiderweb shawl", 100)->move( this_object() );
  ARMOURY->request_item("pumps", 50)->move( this_object() );
  init_equip();
  add_respond_to_with(({ "yes" }), "#yes_response");
  add_respond_to_with(({ "@nod" }), "#yes_response");
  add_respond_to_with(({ "no" }), "#no_response");
  add_respond_to_with(({ "@shake" }), "#no_response");
}
void do_panic(object pl) {
  string home;
  string nationality;
  nationality = pl->query_nationality();
  if ( !nationality ) {
      queue_command( "say Oops.. you haven't got a nationality, I can't "
        "send you home!");
      finish_up();
      return;
  }
  home = nationality->query_default_start_location();
  safeplace = home->query_short();
  queue_command( "say Umm.  Hi.  You are lost?  Would you like me to get "
             "you back to " + safeplace + "?" );
  queue_command( "emote waves her wand around a bit." );
  tell_room(environment(),
            "A puff of smoke drifts away from where something else used to "
            "be.  Now residing there is a pumpkin.\n");
  ARMOURY->request_item("pumpkin", 100)->move(environment());
  queue_command( "say Whoops." );
  lost = pl;
  start_time = time();
  prodded = 0;
  call_out("do_prod", 30);
}
int query_waiting() { return time()-start_time; }
void yes_response(object ob) {
  if (ob != lost)
    return ;
  queue_command( "say Oh, ahhh.  Good." );
  queue_command( "peer wor" );
  tell_object( lost, the_short() + " waves her wand in your direction.\n");
  tell_room( environment(), the_short() + " waves her wand in " +
    lost->the_short() + "'s direction.\n", lost );
  PANIC_HANDLER->finish_panic(lost, PANIC_OK);
  ARMOURY->request_item("pumpkin", 100)->move(lost);
  ARMOURY->request_item("pumpkin", 100)->move(environment(lost));
  lost = 0;
}
void no_response(object ob) {
  if(ob != lost)
    return;
  queue_command( "say Oh, I must have got lost somewhere then." );
  queue_command( "wave" );
  queue_command( "say Oh dear." );
  ARMOURY->request_item("pumpkin", 100)->move(lost);
  ARMOURY->request_item("pumpkin", 100)->move(environment(lost));
  PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
  lost = 0;
}
void do_prod() {
  if(!lost)
    return;
  if (prodded < 3 ) {
    queue_command( "say Umm....so....what do you think?  Do you want "
      "my help?" );
    queue_command( "expect "+lost->query_name() );
    prodded ++ ;
    call_out("do_prod", 60);
  } else {
    queue_command( "say Oh well.  I guess it wasn't me you wanted after all" );
    queue_command( "sigh" );
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
}
void event_exit(object ob, string message, object to) {
    if (ob == lost) {
    queue_command( "say Bye..." );
    queue_command( "wave" );
    queue_command( "say Whoops." );
    queue_command( "tell "+lost->query_name()+" Sorry to have bothered you." );
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    ARMOURY->request_item("pumpkin", 100)->move(environment(lost));
    lost = 0;
  }
}
void hurry_up() {
  if (!lost) {
    queue_command( "blink twice" );
    queue_command( "say I guess my help wasn't wanted, then..." );
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
  else do_prod();
}
void event_fight_in_progress(object attacker, object attackee) {
  if (attackee == this_object()) {
    queue_command( "say Look, this is really not very nice." );
    queue_command( "frown" );
    queue_command( "say I know the art of self defence you know!" );
    set_hp(query_max_hp(), attacker);
    attackee->adjust_tmp_str(-2);
    attackee->adjust_tmp_dex(-2);
    attackee->adjust_tmp_wis(-2);
    attackee->adjust_tmp_int(-2);
    attackee->adjust_tmp_con(-2);
    attackee->add_property("attacked godmother", time());
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
}
void finish_up() {
  queue_command( "shuffle" );
  queue_command( "say Umm.  I have to go." );
  queue_command( "smile appol" );
  queue_command( "wave" );
  PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
  lost = 0;
}
void dest_me() {
  if (lost) {
    PANIC_HANDLER->finish_panic(lost, PANIC_NOT_OK);
    lost = 0;
  }
  ::dest_me();
}
int unambushable() {
    return 1;
}

==================================================
FILE: monster/transport/camel.c
==================================================

#include <npc/transport.h>
inherit "/obj/monster/transport/camel_base";
void setup() {
   set_race("camel");
   set_level(20);
   set_name("camel");
   set_long( "A ratty old camel with seemingly more knees than it should "
             "have.\n");
   set_inside_long( "Nothing smells worse than a camel.  Not even something "
                    "from Dibbler's tray.\n");
   set_value(40000 * 12);
   set_maximum_speed(RIDE_GALLOP);
   set_transport_type( "camel" );
   set_default_mount_difficulty(150);
   set_default_direction_difficulty(150);
   set_wander_time( 60 + random(20) );
   set_gender( 1 + random(2) );
   set_transport_speed(1);
   set_maximum_exhaustion(400);
  set_transport_colour("off-yellow");
}

==================================================
FILE: monster/transport/camel_base.c
==================================================

#include <npc/transport.h>
#include <broadcaster.h>
inherit TRANSPORT_INHERIT;
private int _quiet;
void set_quiet( int quiet ) {
   _quiet = quiet;
}
int query_quiet() {
   return _quiet;
}
void hear_name( object player, string mess ) {
   string *bits;
   string str;
   int allowed;
   if ( !player ) {
      return ;
   }
   if ( is_allowed_to_use( player->query_name() ) ) {
      bits = explode( mess, " " ) - ({ "" });
      foreach ( str in bits ) {
         switch ( str ) {
         case "follow" :
            do_command( "follow " + player->query_name() );
            break;
         case "stop" :
            do_command( "unfollow " + player->query_name() );
            break;
         case "stay" :
            do_command( "unfollow all" );
            break;
         case "quiet" :
            set_quiet(1);
            break;
         case "speak" :
         case "talk" :
            set_quiet(0);
            break;
         }
      }
      allowed = 1;
   }
   if ( !query_quiet() ) {
      if ( allowed ) {
        if( player->query_visible( this_object() ) )
          do_command( "slook " + player->query_name() );
      }
      switch ( random(3) ) {
      case 0:
         do_command( "spit" );
         break;
      case 1:
         do_command( ":ruminates." );
         break;
      case 2:
         do_command( ":looks thoughtful." );
         break;
      }
   }
}
void event_person_shout( object thing, string start, string mess, string lang,
                         int *co_ord, int range ) {
   if ( !environment() )
      return;
   if ( environment()->query_property( "shout zone" ) !=
        environment( this_player() )->query_property( "shout zone" ) ||
        !thing ) {
      return;
   }
   mess = lower_case( mess );
   if ( is_allowed_to_use( thing->query_name() ) ) {
      if ( strsrch( mess, lower_case( query_transport_name() ) )  != -1 ) {
         if (strsrch( mess, "come here" ) != -1) {
            if ( !query_quiet() ) {
               do_command( "grumble" );
            }
            add_effect( "/std/effects/npc/goto_destination",
                        environment(thing) );
         }
      }
   }
}
mapping query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "quiet" : query_quiet() ]);
}
void setup_responses() {
  add_respond_to_with( explode(
                       lower_case( query_transport_base_name() ), " " ),
                       (: hear_name :) );
  BROADCASTER->npc_hear_shouts( this_object() );
}
void init_dynamic_arg( mapping map ) {
   ::init_dynamic_arg( map["::"] );
   if ( map["quiet"] ) {
      set_quiet( map["quiet"] );
   }
   if ( query_transport_name() ) {
      setup_responses();
      set_short( query_transport_name() );
      add_adjective( explode( lower_case( query_transport_name() ), " " )
                     - ({ "the" }) );
      add_property( "determinate", "" );
      add_alias( explode( lower_case( query_transport_name() ), " " )
                 - ({ "the" }) );
   }
}
int do_name( string name ) {
   if ( ::do_name( name ) ) {
      setup_responses();
      set_short( query_transport_name() );
      return 1;
   }
   return 0;
}

==================================================
FILE: monster/transport/horse.c
==================================================

#include <npc/transport.h>
inherit "/obj/monster/transport/horse_base";
void setup() {
   set_race("horse");
   set_level(20);
   set_name("horse");
   set_gender( query_mount_gender() );
   set_long( "A nice dark dashing horse, " + query_pronoun() + " looks "
             "strong and happy as its brown eyes stare into your own.\n" );
   set_inside_long( "You can see the horses hair and ear's flicking at the "
                    "slightest sounds.  The smell of horse is quite "
                    "strong.\n" );
   set_value(40000 * 10);
   set_maximum_speed(RIDE_GALLOP);
   set_transport_type("horse");
   set_default_mount_difficulty(100);
   set_default_direction_difficulty(100);
   set_wander_time( 40 + random(10) );
   set_transport_speed(2);
   set_maximum_exhaustion(300);
}

==================================================
FILE: monster/transport/horse_base.c
==================================================

#include <npc/transport.h>
#include <broadcaster.h>
inherit TRANSPORT_INHERIT;
private int _quiet;
void set_quiet( int quiet ) {
   _quiet = quiet;
}
int query_quiet() {
   return _quiet;
}
void hear_name( object player, string mess ) {
   string *bits;
   string str;
   int allowed;
   if ( !player ) {
      return ;
   }
   if ( is_allowed_to_use( player->query_name() ) ) {
      bits = explode( mess, " " ) - ({ "" });
      foreach ( str in bits ) {
         switch ( str ) {
         case "follow" :
            do_command( "follow " + player->query_name() );
            break;
         case "stop" :
            do_command( "unfollow " + player->query_name() );
            break;
         case "stay" :
            do_command( "unfollow all" );
            break;
         case "quiet" :
            set_quiet(1);
            break;
         case "speak" :
         case "talk" :
            set_quiet(0);
            break;
         }
      }
      allowed = 1;
   }
   if ( !query_quiet() ) {
      if ( allowed ) {
         do_command( "nuzzle " + player->query_name() );
      }
      switch ( random(3) ) {
      case 0:
         do_command( "whicker" );
         break;
      case 1:
         do_command( "nicker" );
         break;
      case 2:
         do_command( "whinny" );
         break;
      }
   }
}
void event_person_shout( object thing, string start, string mess, string lang,
                         int *co_ord, int range ) {
   if( !environment() )
    return;
   if ( environment()->query_property( "shout zone" ) !=
        environment( this_player() )->query_property( "shout zone" ) ||
        !thing ) {
      return;
   }
   mess = lower_case( mess );
   if ( is_allowed_to_use( thing->query_name() ) ) {
      if ( strsrch( mess, lower_case( query_transport_name() ) )  != -1 ) {
         if (strsrch( mess, "come here" ) != -1) {
            if ( !query_quiet() ) {
               do_command( "whicker" );
            }
            add_effect( "/std/effects/npc/goto_destination",
                        environment(thing) );
         }
      }
   }
}
mapping query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "quiet" : query_quiet() ]);
}
void setup_responses() {
  add_respond_to_with( explode(
                       lower_case( query_transport_base_name() ), " " ),
                       (: hear_name :) );
  BROADCASTER->npc_hear_shouts( this_object() );
}
void init_dynamic_arg( mapping map, object ob ) {
   ::init_dynamic_arg( map["::"] );
   if ( map["quiet"] ) {
      set_quiet( map["quiet"] );
   }
}
int do_name( string name ) {
   if ( ::do_name( name ) ) {
      setup_responses();
      return 1;
   }
   return 0;
}

==================================================
FILE: monster/transport/warhorse.c
==================================================

#include <npc/transport.h>
inherit "/obj/monster/transport/horse_base";
void setup() {
   set_race("horse");
   set_level(50);
   set_name("horse");
   add_adjective("war");
   set_gender( query_mount_gender() );
   set_long( "This horse has an air of calmness about " + query_objective() + ", "
             + query_pronoun() + " just stands there and looks very calm.\n" );
   set_inside_long( "You can see the horses mane and " + query_objective() + " "
                    "looking calmly as possible into the distance.\n");
   set_value(40000 * 10);
   set_maximum_speed(RIDE_GALLOP);
   set_transport_type("horse");
   set_default_mount_difficulty(100);
   set_default_direction_difficulty(20);
   set_wander_time( 50 + random(10) );
   set_transport_speed(3);
   set_maximum_exhaustion(600);
   adjust_bonus_str(5);
   adjust_bonus_con(5);
}

==================================================
FILE: reactions/base.hdr_dc.c
==================================================

#include <reaction.h>
void dest_me() { destruct( this_object() ); }
class reaction item;
mapping data = ([ ]);
mixed data_return_0() {
  if (!mapp(data["TeaLeaf"])) data["TeaLeaf"] = ([]);
  item = new( class reaction );
  item->ratio = 1.0/100;
  item->result = "/obj/reagents/weak_black_tea.ob";
  item->result_amt = 1.0;
  item->func = ({ });
  data["TeaLeaf"]["Water"] = item;
  if (!mapp(data["BatGuano"])) data["BatGuano"] = ([]);
  item = new( class reaction );
  item->ratio = ({ 0.8, 1.2 });
  item->result = "/obj/reagents/generic_liquid.ob";
  item->result_amt = 1;
  item->func = ({ (:
   $3->set_decay_speed(0),
   $3->set_medium_alias( "GuanoSolution" ),
   $3->set_name( "guano_solution" ),
   $3->add_alias( "sludge" ),
   $3->set_short( "thick brown sludge" ),
   $3->add_adjective( ({ "thick", "brown" }) ),
   $3->set_long( "This is some thick brown sludge, streaked through with "
     "white.  The smell is... prominent.\n" )
:) })
;
  data["BatGuano"]["Water"] = item;
  if (!mapp(data["BlueHealingWater"])) data["BlueHealingWater"] = ([]);
  item = new( class reaction );
  item->ratio = ({ 1.0, 1.0 });
  item->result = "/obj/reagents/generic_liquid.ob";
  item->result_amt = 1.0;
  item->func = ({
        (: $3->set_name( "ooze" ) :),
        (: $3->add_alias( "green ooze" ) :),
        (: $3->set_short( "thick green ooze" ) :),
        (: $3->set_main_plural( "thick green oozes" ) :),
        (: $3->add_plural( "oozes" ) :),
        (: $3->add_adjective( "green" ) :),
        (: $3->set_long( "This is a thick, green "
                        "mush, $amount_size$.  It smells "
                        "terrible, and is bubbling slightly.\n" ) :),
        (: $3->set_medium_alias( "ThickGreenOoze" ) :),
        (: $3->add_eat_effect( "/std/effects/ingested/drunk", 50 ) :),
    });
  data["BlueHealingWater"]["BrewedComfreyYarrowTea"] = item;
  if (!mapp(data["BlueHealingWater"])) data["BlueHealingWater"] = ([]);
  item = new( class reaction );
  item->ratio = ({ 1.0, 1.0 });
  item->result = "/obj/reagents/generic_liquid.ob";
  item->result_amt = 1.0;
  item->func = ({
        (: $3->set_name( "ooze" ) :),
        (: $3->add_alias( "green ooze" ) :),
        (: $3->set_short( "thick green ooze" ) :),
        (: $3->set_main_plural( "thick green oozes" ) :),
        (: $3->add_plural( "oozes" ) :),
        (: $3->add_adjective( "green" ) :),
        (: $3->set_long( "This is a thick, green "
                        "mush, $amount_size$.  It smells "
                        "terrible, and is bubbling slightly.\n" ) :),
        (: $3->set_medium_alias( "ThickGreenOoze" ) :),
        (: $3->add_eat_effect( "/std/effects/ingested/drunk", 50 ) :),
    });
  data["BlueHealingWater"]["ComfreyYarrowTea"] = item;
}
mixed data_return() {
  data_return_0();
  return data;
}

==================================================
FILE: reactions/blue_water.rcn_dc.c
==================================================

}
mixed data_return() {
  return data;
}

==================================================
FILE: furnitures/chairs/chintz_chair.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
  set_name( "chair" );
  set_short( "overstuffed chintz chair" );
  add_adjective( ({ "overstuffed", "chintz" }) );
  set_long("This is the type of fat, comfortable chair typically found "
    "in the parlours of fat, comfortable ladies.  The fabric covering "
    "it is bright yellow decorated with a rather aggressive-looking "
    "rose and cabbage design.\n");
  set_allowed_positions(({ "sitting", "meditating", "lounging" }));
  set_allowed_room_verbs(([
    "sitting" : "sits",
  ]));
  set_weight(400);
  set_value(6000);
}

==================================================
FILE: furnitures/cupboards/pine_kitchen_cupboards.c
==================================================

inherit "/std/room/furniture/storage";
void setup() {
    set_name("cupboard");
    set_short("set of white pine kitchen cupboards");
    add_adjective( ({ "set", "of", "white", "pine", "kitchen" }) );
    set_long("This is a set of kitchen cupboards made from white "
        "pine.  Four sets of doors hide the shelves within, and fluted "
        "columns with triple crowned tops make the structure a little "
        "less plain.  A simple design which still "
        "manages to radiate elegance, this set of cupboards is practial "
        "and functional, but still manages to be pleasing to the senses.\n");
    set_weight(250);
    set_max_weight(100);
    set_value(80000);
    set_allowed_room_verbs((["hanging" : "hangs" ]));
}

==================================================
FILE: furnitures/sideboards/marquetry_sideboard.c
==================================================

inherit "/std/room/furniture/surface";
void setup() {
  set_name( "sideboard" );
  set_short( "marquetry sideboard" );
  add_alias( "table" );
  add_adjective( ({ "marquetry"}) );
  set_long("This is a long table specifically designed to rest "
    "against a wall.  The marquetry effect on the top surface has been "
    "arranged to represent the Assassins' Guild coat of arms. \n");
  set_allowed_positions(({ "sitting", "lying", "squatting", "standing"}));
  set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands"]));
  set_weight(360);
  set_max_weight(200);
  set_value(100000);
  set_allow_use_internals(1);
}

==================================================
FILE: furnitures/commercial/bank_franchise_small.c
==================================================

inherit "/std/room/furniture/bank_franchise";
void setup() {
   set_name( "counter" );
   set_short( "small bank counter" );
   add_alias("bank");
   add_adjective( ({ "small", "bank" } ));
   set_long( "A heavily armoured and hardwood counter "
             "with a safe embedded into the surface.\n");
   set_allowed_positions(({"sitting", "standing" }));
   set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
   set_weight(1000);
   set_value(400000);
   set_commercial_size(10);
   set_maximum_total_difference(200000);
}

==================================================
FILE: furnitures/commercial/bank_master.c
==================================================

inherit "/std/room/furniture/bank_master";
void setup() {
   set_name( "counter" );
   set_short( "master bank counter" );
   add_alias("bank");
   add_adjective( ({ "master", "bank" } ));
   set_long( "A heavily armoured and hardwood counter "
             "with a safe embedded into the surface.\n");
   set_allowed_positions(({"sitting", "standing" }));
   set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
   set_weight(1000);
   set_value(16000000);
   set_commercial_size(91);
   set_shop_use_types(({ "bank", "withdraw", "deposit" }));
}

==================================================
FILE: furnitures/commercial/blackboard.c
==================================================

#include <language.h>
#define DEFAULT_LANGUAGE "morporkian"
#define BOARD_TAG "blackboard"
inherit "/std/room/furniture/commercial";
int do_write( string language );
void setup() {
    set_name ("blackboard");
    set_short ("blackboard");
    add_alias (({"board", "sign"}));
    set_long ("The residue of faded chalk-dust and long forgotten "
        "doodles lies heavily on the blackboard.  The grain of the "
        "board is worn and slightly mottled with age, hinting at "
        "a long and dignified history of classrooms and university "
        "lecterns.  Or perhaps just hinting at cheap wood and "
        "bad upkeep.\n");
    set_allowed_room_verbs( (["standing" : "stands",
                            "hanging"  : "hangs"]) );
    set_commercial_size(1);
    set_weight(2000);
    set_value(240000);
}
void init() {
    add_command ("write", "[on] <direct:object'blackboard'> in <string'language'>",
        (: do_write($4[1]) :) );
    add_command ("clean", "<direct:object>");
}
string query_readable_message(object player, int ignore_labels) {
    if (!sizeof(query_read_mess())) {
        return "A few random letters that escaped cleaning can be seen on "
            "the blackboard";
    }
    return ::query_readable_message(player, ignore_labels);
}
int do_clean() {
    if (!is_allowed (this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "You cannot clean "
            +  capitalize (query_owner()) + "'s blackboard!\n", ({ }));
        return 0;
    }
    set_read_mess( 0 );
    return 1;
}
string find_words( string language ) {
    string words;
    words = implode( map( filter( query_read_mess(),
        (: $1[READ_LANG] == $(language) :) ), (: $1[READ_MESS] :) ), "\n" );
    return words;
}
int do_write(string language)
{
    string existing_text;
    if (!is_allowed (this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "You cannot write on "
            +  capitalize (query_owner()) + "'s blackboard!\n", ({ }));
        return 0;
    }
    language = lower_case( language );
    if ( !this_player()->query_skill(
        LANGUAGE_HAND->query_language_written_skill(language)) ) {
        this_player()->add_failed_mess(this_object(), "You can't write in " +
           language + ".\n" );
        return -1;
    }
    existing_text = find_words( language );
    this_player()->do_edit(existing_text, "blackboard_text",
        this_object(), 0, language);
    this_player()->add_succeeded_mess (this_object(), "$N find$s a handy "
        "piece of chalk and start$s to write on the blackboard.\n", ({ }));
    return 1;
}
void blackboard_text(string text, string language)
{
    if (!text)
    {
        tell_room (environment (this_object()), this_player()->one_short()
            + " steps back from the blackboard without making any "
            "changes.\n", this_player());
        tell_object (this_player(), "Okay, nothing has been changed.\n");
        return;
    }
    set_read_mess( filter( query_read_mess(),
        (: $1[READ_LANG] != $(language) :) ) );
    add_read_mess( text, "chalk", language );
    tell_room(environment (this_object()), this_player()->one_short()
            + " finishes writing on the blackboard.\n", this_player());
}
void init_dynamic_arg(mapping map) {
   string my_words;
   commercial::init_dynamic_arg(map, player);
   my_words = query_auto_load_value(map, BOARD_TAG, "words");
   if ( stringp(my_words) ) {
       add_read_mess(my_words, "chalk", DEFAULT_LANGUAGE);
   }
     set_read_mess( filter( query_read_mess(), (: $1[READ_LANG] != "common" :) ) );
}

==================================================
FILE: furnitures/commercial/blackjack.c
==================================================

inherit "/std/room/furniture/games/card_base";
inherit "/std/room/furniture/games/multiplayer_base";
inherit "/std/room/furniture/commercial";
#include <money.h>
#define BLACKJACK_BET 0
#define BLACKJACK_PLAYING 1
#define BLACKJACK_BUST 2
#define BLACKJACK_STAND 3
class player_data {
   class playing_card* hand;
   int starting_bet;
   int state;
}
#define BOARD_TAG "blackjack"
private int _cost;
private int _finished;
private int _max_bet;
private int _min_bet;
private int _timeout_call;
private int _timeout_length;
private int _num_decks;
private int _soft_seventeen;
private int _double_on_doubles;
private class playing_card* _dealer_hand;
private class playing_card* _deck;
private class playing_card* _discard;
int query_hand_value(class playing_card* cards);
void create() {
   multiplayer_base::create();
   commercial::create();
}
void setup() {
   set_name( "table" );
   set_short( "blackjack table" );
   add_adjective( ({ "blackjack" } ));
   add_alias("blackjack");
   set_long( "The green felt of the table looks nice and soft, there is "
             "a single deck of cards sitting in the middle of the table.  "
             "The table looks like it will seat 4 people.\n");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits" ]));
   set_weight(2000);
   set_value(240000);
   _timeout_length = 5 * 60;
   _cost = 400;
   _num_decks = 1;
   add_player_id_type("green", 0);
   add_player_id_type("red", 0);
   add_player_id_type("blue", 0);
   add_player_id_type("maroon", 0);
   set_minimum_needed(1);
   add_help_file("blackjack");
   set_commercial_size(15);
   set_commercial_type("gambling");
   set_shop_use_types(({ "blackjack" }));
}
string query_card_status() {
   string id_bing;
   string ret;
   string* not_playing;
   class player_data data;
   class playing_card card;
   string* womble;
   string place;
   ret = "";
   not_playing = ({ });
   womble = query_player_ids();
   place = environment()->query_property("place");
   foreach (id_bing in womble) {
      if (is_person_playing(id_bing) ||
          is_game_started()) {
         ret += capitalize(id_bing) + " (" +
                query_player_cap_name(id_bing) + ")";
         data = query_player_data(id_bing);
         if (data) {
            if (data->starting_bet) {
               ret += "  " +
                      MONEY_HAND->money_value_string(data->starting_bet, place);
               if (sizeof(data->hand)) {
                  foreach (card in data->hand) {
                     ret += "  " + query_card_string(card);
                  }
               }
               if (data->state == BLACKJACK_STAND) {
                  ret += " (stand)";
               } else if (data->state == BLACKJACK_BUST) {
                  ret += " (bust)";
               }
               ret += "\n";
            } else {
               ret += "  No bet yet.\n";
            }
         } else {
            ret += "\n";
         }
      } else {
         not_playing += ({ id_bing });
      }
   }
   if (sizeof(not_playing)) {
      ret += query_multiple_short(map(not_playing, (: capitalize($1) :))) +
                               " are not playing.\n";
   }
   ret += "\n";
   if (sizeof(_dealer_hand)) {
      ret += "Dealer's cards ";
      if (!_finished) {
         ret += "XXXX";
      }
      foreach (card in _dealer_hand[(_finished?0:1)..]) {
         ret += "  " + query_card_string(card);
      }
      if (query_hand_value(_dealer_hand) > 21) {
         ret += " (bust)";
      }
      ret += "\n";
   }
   return ret;
}
string long(string str, int dark) {
   if (dark) {
      return ::long() +
             "It is too dark to make out the pieces on the board.\n";
   }
   return ::long() + query_card_status();
}
class playing_card query_next_card() {
   class playing_card card;
   if (!sizeof(_deck)) {
      if (!sizeof(_discard)) {
         _deck = make_deck(_num_decks, 0);
         _deck = shuffle_deck(_deck);
      } else {
         _deck = make_deck(_num_decks, 0);
         _deck = shuffle_deck(_deck);
      }
      tell_all_players("The dealer shuffles the deck before the next card "
                       "is dealt.\n");
      _discard = ({});
   }
   card = _deck[0];
   _deck = _deck[1..];
   return card;
}
void deal_cards(string id) {
   class player_data data;
   string hands;
   if (!sizeof(_dealer_hand)) {
      _dealer_hand = ({ query_next_card(), query_next_card() });
   }
   hands = "";
      data = query_player_data(id);
      data->hand = ({ query_next_card(), query_next_card() });
      hands += query_player_cap_name(id) + " hand is: "+
                      query_card_string(data->hand[0]) + "  " +
                      query_card_string(data->hand[1]) +
                      "  (total " +
                      query_hand_value(data->hand) + ")\n";
   hands += "Dealer's cards: XXXX " +
             query_card_string(_dealer_hand[0]) + "\n"
             "You need to stay or hit yourself for more cards.\n";
   tell_all_players(hands);
}
int start_game() {
   class player_data data;
   string id;
   randomise_player_numbers();
   if (!::start_game()) {
      return 0;
   }
   foreach (id in query_player_ids()) {
      data = new(class player_data);
      data->starting_bet = 0;
      data->hand = ({ });
      data->state = BLACKJACK_BET;
      set_player_data(id, data);
   }
   _dealer_hand = ({ });
   _finished = 0;
   tell_all_players("Place your starting bets.\n");
   return 1;
}
int query_hand_value(class playing_card* cards) {
   class playing_card bing;
   int value;
   int no_aces;
   foreach (bing in cards) {
      if (bing->number == 1) {
         no_aces++;
      } else if (bing->number >= 10) {
         value +=  10;
      } else {
         value += bing->number;
      }
   }
   if (no_aces > 0) {
      if (no_aces > 1) {
         value += no_aces - 1;
      }
      if (value <= 10) {
         value += 11;
      } else {
         value += 1;
      }
   }
   return value;
}
int is_soft_result(class playing_card* cards) {
   class playing_card bing;
   int value;
   int no_aces;
   foreach (bing in cards) {
      if (bing->number == 1) {
         no_aces++;
      } else if (bing->number >= 10) {
         value +=  10;
      } else {
         value += bing->number;
      }
   }
   if (no_aces > 0) {
      if (no_aces > 1) {
         value += no_aces - 1;
      }
      if (value <= 10) {
         return 1;
      }
   }
   return 0;
}
void finish_bet(string id) {
   class player_data data;
   data = query_player_data(id);
   call_out("deal_cards", 2, id);
}
void complete_round() {
   int value;
   string stuff;
   object ob;
   int new_value;
   class playing_card card;
   class player_data data;
   string id;
   string place;
   int paid;
   string* winners;
   string* losers;
   remove_call_out(_timeout_call);
   _timeout_call = 0;
   place = environment()->query_property("place");
   value = query_hand_value(_dealer_hand);
   while (value < 17 ||
          (value == 17 && _soft_seventeen && is_soft_result(_dealer_hand))) {
      _dealer_hand += ({ query_next_card() });
      value = query_hand_value(_dealer_hand);
   }
   stuff = "";
   foreach (card in _dealer_hand) {
      stuff += "  " + query_card_string(card);
   }
   if (value > 21) {
      stuff += "  Total " + value + " (bust)\n";
      value = 0;
   } else {
      stuff += "  Total " + value + "\n";
   }
   winners = ({ });
   losers = ({ });
   foreach (id in query_currently_playing_ids()) {
      data = query_player_data(id);
      if (data->state == BLACKJACK_STAND) {
         new_value = query_hand_value(data->hand);
         if (new_value == 21 && sizeof(data->hand) == 2) {
            winners += ({ id });
            ob = query_player_object(id);
            if (ob) {
               ob->adjust_money(MONEY_HAND->create_money_array((data->starting_bet * 5) / 2,
                                           place), place);
            }
            adjust_float(-(data->starting_bet * 3) / 2);
            if (ob) {
               stuff += ob->query_cap_name();
            } else {
               stuff += id;
            }
            stuff += " gets a payout of " +
                     MONEY_HAND->money_value_string((data->starting_bet * 3) / 2, place) +
                     " (plus their original money back).\n";
            paid = 1;
         } else if (new_value > value) {
            winners += ({ id });
            ob = query_player_object(id);
            if (ob) {
               ob->adjust_money(MONEY_HAND->create_money_array(data->starting_bet * 2,
                                           place), place);
            }
            adjust_float(-data->starting_bet);
            if (ob) {
               stuff += ob->the_short();
            } else {
               stuff += id;
            }
            stuff += " gets a payout of " +
                     MONEY_HAND->money_value_string(data->starting_bet, place) +
                     " (plus their original money back).\n";
            paid = 1;
         } else {
            losers += ({ id });
         }
      }
   }
   if (!paid) {
      stuff += "No one gets paid anything.\n";
   }
   tell_all_players("The dealer reveals their cards as " +
                    stuff);
   if (sizeof(winners)) {
      tell_room(environment(),
                query_multiple_short(winners) + " win" +
                (sizeof(winners) > 1?"":"s") + " the blackjack hand.\n");
   } else {
      tell_room(environment(),  "No one wins the blackjack hand.\n");
   }
   finish_game(0);
   _finished = 1;
}
void force_finish() {
   if (is_game_started()) {
      complete_round();
   }
}
int do_bet(string str) {
   string place;
   string id;
   int amount;
   class player_data data;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }
   place = environment()->query_property("place");
   amount = MONEY_HAND->value_from_string(str, place);
   if (!amount) {
      add_failed_mess("Invalid bet amount.\n");
      return 0;
   }
   if (this_player()->query_value_in(place) < amount) {
      add_failed_mess("You do not have that much to bid.\n");
      return 0;
   }
   if (amount < _min_bet) {
      add_failed_mess("The minimum bet for $D is " +
         MONEY_HAND->money_value_string(_min_bet, place) + ".\n");
      return 0;
   }
   if (amount > _max_bet) {
      add_failed_mess("The maximum bet for $D is " +
         MONEY_HAND->money_value_string(_max_bet, place) + ".\n");
      return 0;
   }
   data = query_player_data(id);
   if (data->starting_bet) {
      add_failed_mess("You have already bet on $D.\n");
      return 0;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(amount, place),
                            place);
   adjust_float(amount);
   data->starting_bet = amount;
   data->state = BLACKJACK_PLAYING;
   finish_bet(id);
   add_succeeded_mess("$N $V " +
                      MONEY_HAND->money_value_string(amount, place) +
                      " on $D.\n");
   return 1;
}
int do_hit() {
   int value;
   int not_done;
   string id;
   class player_data data;
   class playing_card card;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }
   data = query_player_data(id);
   if (data->state != BLACKJACK_PLAYING) {
      add_failed_mess("You are out of the game and cannot get any more "
                      "cards.\n");
      return 0;
   }
   if (!sizeof(data->hand)) {
      add_failed_mess("You cannot hit before you have been dealt cards.\n");
      return 0;
   }
   card = query_next_card();
   data->hand += ({ card });
   value = query_hand_value(data->hand);
   if (value > 21) {
      add_succeeded_mess("$N $V and get$s " + query_card_string(card) +
                         " giving a total of " + value +
                         " and going bust on $D.\n");
      data->state = BLACKJACK_BUST;
      foreach (id in query_currently_playing_ids()) {
         data = query_player_data(id);
         if (data->state != BLACKJACK_BUST &&
             data->state != BLACKJACK_STAND) {
            not_done = 1;
         }
      }
      if (!not_done) {
          remove_call_out(_timeout_call);
          _timeout_call = call_out("complete_round", 2);
      }
   } else {
      add_succeeded_mess("$N $V and gets " + query_card_string(card) +
                         " giving a total of " + value + " on $D.\n");
   }
   return 1;
}
int do_stand() {
   int value;
   string id;
   class player_data data;
   int not_done;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   id = find_player_id_of_person(this_player());
   if (!id) {
      add_failed_mess("You are not playing.\n");
      return 0;
   }
   data = query_player_data(id);
   if (data->state != BLACKJACK_PLAYING) {
      add_failed_mess("You are not playing and set yourself to stand.\n");
      return 0;
   }
   value = query_hand_value(data->hand);
   data->state = BLACKJACK_STAND;
   foreach (id in query_currently_playing_ids()) {
      data = query_player_data(id);
      if (data->state != BLACKJACK_BUST &&
          data->state != BLACKJACK_STAND) {
         not_done = 1;
      }
   }
   if (!not_done) {
       remove_call_out(_timeout_call);
       _timeout_call = call_out("complete_round", 2);
   }
   add_succeeded_mess("$N $V with a total of " + value +
                      " on $D.\n");
   return 1;
}
int do_start() {
   if (!is_open_for("blackjack", this_player()->query_name())) {
      add_failed_mess("The blackjack table is not open.\n");
      return 0;
   }
   if (_timeout_call) {
      add_failed_mess("Someone is still playing, you cannot start a "
                      "new game yet.\n");
      return 0;
   }
   if (query_float() < (_max_bet * 3 * 4) / 2) {
      if (is_allowed(this_player()->query_name())) {
         add_failed_mess("The float is too low for the table to open.\n");
         return 0;
      }
      add_failed_mess("The blackjack table is not open.\n");
      return 0;
   }
   if (!is_playing(this_player())) {
      add_failed_mess("You must be playing the game to start it.\n");
      return 0;
   }
   if (!start_game()) {
      add_failed_mess("You need at least three people to play modern art.\n");
      return 0;
   }
   add_succeeded_mess("$N $V a game on $D.\n");
   remove_call_out(_timeout_call);
   _timeout_call = call_out("force_finish", _timeout_length);
   tell_all_players("Timeout for this game is " + (_timeout_length / 60) +
                    " minutes.\n");
   return 1;
}
int do_finish() {
   string person;
   if (!is_game_started()) {
      add_failed_mess("The game has not started.\n");
      return 0;
   }
   person = find_player_id_of_person(this_player());
   if (!person) {
      add_failed_mess("You must actually be playing to finish the game.\n");
      return 0;
   }
   force_finish();
   return 1;
}
string query_main_status(int hint) {
   string place;
   string ret;
   place = query_money_place();
   ret = "$I$0=Blackjack table:\n"
          "$I$6=   Table is " +
             (query_float() >= (_max_bet * 3 * 4) / 2?"open.\n":
              "closed! (Float needed: " +
              MONEY_HAND->money_value_string((_max_bet * 3 * 4) / 2, place) +
              "; current: " +
              MONEY_HAND->money_value_string(query_float(), place) + ")\n") +
          "$I$6=   Timeout length: " + (_timeout_length / 60) + " minutes.\n";
   if (hint) {
      ret += "$I$6=      set timeout <number> on <table>\n";
   }
   ret += "$I$6=   Maximum bet: " +
              MONEY_HAND->money_value_string(_max_bet, place) + "\n";
   if (hint) {
      ret += "$I$6=      set maximum bet <amount> on <table>\n";
   }
   ret += "$I$6=   Minimum bet: " +
              MONEY_HAND->money_value_string(_min_bet, place) + "\n";
   if (hint) {
      ret += "$I$6=      set minimum bet <amount> on <table>\n";
   }
   ret += "$I$6=   Num Decks  : " + _num_decks + "\n";
   if (hint) {
      ret += "$I$6=      set num decks <amount> on <table>\n";
   }
   ret += "$I$6=   Soft 17    : " + (_soft_seventeen?"on":"off") + "\n";
   if (hint) {
      ret += "$I$6=      set hit on soft seventeen {on|off} on <table>\n";
   }
   ret += "$I$6=   Float needed: " +
              MONEY_HAND->money_value_string((_max_bet * 3 * 4) / 2, place) +
          " (max players * max bet * 3 / 2)\n$I$6=   Revenue: " +
          MONEY_HAND->money_value_string(query_revenue(), place) +
          "\n\n";
   return ret;
}
int do_set_bet(string str, int max_bet) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   if (max_bet) {
      _max_bet = value;
      add_succeeded_mess("$N set$s the maximum bet to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   } else {
      _min_bet = value;
      add_succeeded_mess("$N set$s the minimum bet to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   }
   return 1;
}
int do_set_timeout(int length) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (length <= 0) {
      add_failed_mess("The timeout must be greator than 0.\n");
      return 0;
   }
   _timeout_length = length * 60;
   add_succeeded_mess("$N set$s the timeout on $D to " + length + " minutes.\n");
   return 1;
}
int do_set_soft_seventeen(int value) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   _soft_seventeen = value;
   add_succeeded_mess("$N set$s the soft seventeen dealer hit on $D " +
                      (value?"on":"off") + ".\n");
   return 1;
}
int do_set_double_on_doubles(int value) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   _double_on_doubles = value;
   add_succeeded_mess("$N set$s the double on doubles on $D " +
                      (value?"on":"off") + ".\n");
   return 1;
}
int do_set_num_decks(int num_decks) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (num_decks <= 0) {
      add_failed_mess("The timeout must be greator than 0.\n");
      return 0;
   }
   if (num_decks >= 10) {
      add_failed_mess("The number of decks must be less than 10.\n");
      return 0;
   }
   _num_decks = num_decks;
   add_succeeded_mess("$N set$s the number of decks on $D to " + num_decks +
                      ".\n");
   return 1;
}
void init() {
   multiplayer_base::init();
   commercial::init();
   add_command("bet", "<string'amount'> on <direct:object>",
               (: do_bet($4[0]) :));
   add_command("hit", "on <direct:object>",
               (: do_hit() :));
   add_command("stay", "on <direct:object>",
               (: do_stand() :));
   add_command("start", "[new] game on <direct:object>",
               (: do_start() :));
   if (environment()->is_allowed(this_player()->query_name())) {
      add_command("set", "minimum bet <string'amount'> on <direct:object>",
                  (: do_set_bet($4[0], 0) :));
      add_command("set", "maximum bet <string'amount'> on <direct:object>",
                  (: do_set_bet($4[0], 1) :));
      add_command("set", "timeout <number'minutes'> on <direct:object>",
                  (: do_set_timeout($4[0]) :));
      add_command("set", "num decks <number'num decks'> on <direct:object>",
                  (: do_set_num_decks($4[0]) :));
      add_command("set", "hit on soft seventeen {on|off} on <direct:object>",
                  (: do_set_soft_seventeen($4[0] == "on") :));
   }
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   multiplayer_base::query_dynamic_auto_load(map);
   add_auto_load_value(map, BOARD_TAG, "cost", _cost);
   add_auto_load_value(map, BOARD_TAG, "dealer hand", _dealer_hand);
   add_auto_load_value(map, BOARD_TAG, "deck", _deck);
   add_auto_load_value(map, BOARD_TAG, "discard", _discard);
   add_auto_load_value(map, BOARD_TAG, "finished", _finished);
   add_auto_load_value(map, BOARD_TAG, "max bet", _max_bet);
   add_auto_load_value(map, BOARD_TAG, "min bet ", _min_bet);
   add_auto_load_value(map, BOARD_TAG, "timeout", _timeout_length);
   add_auto_load_value(map, BOARD_TAG, "num decks", _num_decks);
   add_auto_load_value(map, BOARD_TAG, "soft seventeen", _soft_seventeen);
   add_auto_load_value(map, BOARD_TAG, "double on doublet", _double_on_doubles);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   multiplayer_base::init_dynamic_arg(map, player);
   _cost = query_auto_load_value(map, BOARD_TAG, "cost");
   _dealer_hand = query_auto_load_value(map, BOARD_TAG, "dealer hand");
   _deck = query_auto_load_value(map, BOARD_TAG, "deck");
   _discard = query_auto_load_value(map, BOARD_TAG, "discard");
   _finished = query_auto_load_value(map, BOARD_TAG, "finished");
   _min_bet = query_auto_load_value(map, BOARD_TAG, "min bet");
   _max_bet = query_auto_load_value(map, BOARD_TAG, "max bet");
   _timeout_length = query_auto_load_value(map, BOARD_TAG, "timeout");
   _num_decks = query_auto_load_value(map, BOARD_TAG, "num decks");
   _soft_seventeen = query_auto_load_value(map, BOARD_TAG, "soft seventeen");
   _double_on_doubles = query_auto_load_value(map, BOARD_TAG, "double on doublet");
   if (!_num_decks) {
      _num_decks = 1;
   }
   if (is_game_started()) {
      remove_call_out(_timeout_call);
      _timeout_call = call_out("force_finish", _timeout_length);
   }
}

==================================================
FILE: furnitures/commercial/filing_cabinet.c
==================================================

inherit "/std/room/furniture/document_handler";
void setup() {
   set_short("filing cabinet");
   set_name("cabinet");
   add_alias("filing");
   set_long("A big grey wooden box with draws that slide in and out.  It "
            "looks like it could hold bunches of documents, nicely order "
            "and available for quick retrieval.");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits" ]));
   set_weight(2000);
   set_value(240000);
   set_commercial_size(5);
   set_commercial_type("utility");
}

==================================================
FILE: furnitures/commercial/medium_shop.c
==================================================

inherit "/std/room/furniture/shop_base";
void setup() {
   set_name( "counter" );
   set_short( "medium shop counter" );
   add_adjective( ({ "medium", "shop" } ));
   set_long( "The smooth polished surface of the medium counter shines and "
             "glows at you.\n");
   set_allowed_positions(({"sitting", "standing" }));
   set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
   set_weight(1000);
   set_value(1200000);
   set_maximum_inventory_size(100);
   set_commercial_size(60);
}

==================================================
FILE: furnitures/commercial/money_changer.c
==================================================

inherit "/std/room/furniture/commercial";
#include <money.h>
#include <move_failures.h>
private mapping _money;
private int _cut;
private int _cost;
#define BOARD_TAG "money changer"
void setup() {
   set_name( "counter" );
   set_short( "money changer counter" );
   add_adjective( ({ "money", "changer" } ));
   add_alias("changer");
   set_long( "A box with a bunch of holes in it, it looks like it will "
             "change coins into other types of coins.\n");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits" ]));
   set_weight(2000);
   set_value(240000);
   add_help_file("money_changer");
   set_commercial_size(5);
   _cut = 10;
   _cost = 400;
   _money = ([ ]);
}
int change( string words, string type ) {
   int val_index;
   int value;
   int value_type;
   int value_unit;
   int value_change;
   int value_num;
   int i;
   string place;
   mixed money;
   object changed;
   object *monies;
   mixed *change;
   mixed *values;
   mixed *money_bits;
   place = query_money_place();
   if ( !place || ( place == "" ) ) {
      place = "default";
   }
   values = (mixed *)MONEY_HAND->query_values_in( place );
   MONEY_OBJECT->set_money_array( values );
   val_index = (int)MONEY_OBJECT->find_best_fit( type );
   if ( val_index == -1 ) {
      return notify_fail( "The coin type \""+ type +
            "\" is not legal tender here.\n" );
   }
   money = (mixed)MONEY_HAND->parse_money( words, this_player(), place );
   if ( intp( money ) ) {
      switch( money ) {
         case NO_MATCH :
            return notify_fail( "You do not have \""+ words +"\".\n" );
         case NO_MONEY :
            return notify_fail( "You can only change money here.\n" );
         default :
            return notify_fail( "You can only change legal tender.\n" );
      }
   }
   if (place != "default")  {
      monies = MONEY_HAND->filter_legal_tender(money, "default");
      if (monies[0])  monies[0]->move(this_player());
      if (!monies[1])  {
         return notify_fail( "You can only change legal tender.\n" );
      }
      money = monies[1];
   }
   money_bits = money->query_money_array();
   value = (int)money->query_value_in( place );
   i = member_array(values[val_index], money->query_money_array());
   if (i != -1) {
      value_type = money->query_money_array()[i + 1] * values[val_index + 1];
   }
   value_unit = (values[val_index + 1] * (100 + _cut)) / 100;
   value_change = (value - value_type) % value_unit;
   value_num = (value - value_type) / value_unit;
   value = value_num * values[val_index + 1] + value_type;
   if ( value < values[ val_index + 1 ] ) {
      money->move( this_player() );
      return notify_fail( MONEY_HAND->money_string(money->query_money_array(), place) +
                         " is not even worth one "+ values[ val_index ] +
                       ".\n" );
   }
   if (_money[values[val_index]] < value_num) {
      money->move( this_player() );
      add_failed_mess("The money changer does not have enough " +
                      MONEY_HAND->query_main_plural_for(values[val_index]) +
                      " to pay you.\n");
      return 0;
   }
   _money[values[val_index]] -= value_num;
   for (i = 0; i < sizeof(money_bits); i += 2) {
      _money[money_bits[i]] += money_bits[i + 1];
   }
   changed = clone_object( MONEY_OBJECT );
   changed->set_money_array( ({ values[ val_index ],
                                value / values[ val_index + 1 ] }));
   change = (mixed *)MONEY_HAND->create_money_array( value_change, place );
   for (i = 0; i < sizeof(changed); i += 2) {
      _money[change[i]] -= change[i + 1];
   }
   this_player()->add_succeeded_mess(this_object(),
    ({ "You changed "+query_multiple_short(money->half_short( 1 ) ) +
         " into "+
         query_multiple_short( changed->half_short( 1 ) ) +".\n",
       "$N $V some money into "+type+".\n" }), ({ }) );
   money->move( "/room/rubbish" );
   if ( sizeof( change ) ) {
      changed->adjust_money( change );
      write( "You were returned "+ (string)MONEY_HAND->money_string( change )
            +" in change.\n" );
   }
   if ( (int)changed->move( this_player() ) != MOVE_OK ) {
      write( "Unfortunately, you're too heavily burdened to accept all that "+
            "money, so it's put on the table for you.\n" );
      changed->move( this_object() );
   }
   return 1;
}
string query_main_status(int hint) {
   string type;
   string place;
   int num;
   string str;
   place = query_money_place();
   str = "$I$0=Money Changer:\n";
   str += "$I$6=   Percentage cut " + _cut + "%\n";
   foreach (type, num in _money) {
      str += "$I$6=   " + num + " " + type + "\n";
   }
   return str;
}
int do_set_cost(string str) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   _cost = value;
   add_succeeded_mess("$N set$s the cost of each use of $D to " +
          MONEY_HAND->money_value_string(value, place) + ".\n");
   return 1;
}
int do_set_cut(int number) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (number < 0) {
      add_failed_mess("You need to set the cut to a number greator than 0.\n");
      return 0;
   }
   if (number > 500) {
      add_failed_mess("You need to set the cut to a number less than 500.\n");
      return 0;
   }
   _cut = number;
   add_succeeded_mess("$N set$s the cut for $D to " + _cut + "%.\n");
   return 1;
}
int do_deposit(int num, string str) {
   mixed* values;
   int i;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   values = this_player()->query_money_array();
   for (i = 0; i < sizeof(values); i += 2) {
      if (lower_case(values[i]) == lower_case(str)) {
         break;
      }
   }
   if (i >= sizeof(values)) {
      add_failed_mess("You do not have any " + str + " to deposit.\n");
      return 0;
   }
   if (values[i + 1] < num) {
      add_failed_mess("You do not have " + num + " of " + values[i] +
                      ", you only have " + values[i+1] + ".\n");
      return 0;
   }
   _money[values[i]] += num;
   this_player()->adjust_money(-num, values[i]);
   add_succeeded_mess("$N deposit$s " + num + " of " + str + " in $D.\n");
   return 1;
}
int do_withdraw(int num, string str) {
   string tmp;
   int bing;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   foreach (tmp, bing in _money) {
      if (lower_case(str) == lower_case(tmp)) {
         if (num > bing) {
            add_failed_mess("The $D does not have " +
                            num + " of " + tmp + " it only has " +
                            bing + ".\n");
            str = tmp;
         }
      }
   }
   if (!_money[str]) {
      add_failed_mess("You do not appear to have any " + str + " in $D.\n");
      return 0;
   }
   _money[str] -= num;
   if (!_money[str]) {
      map_delete(_money, str);
   }
   this_player()->adjust_money(num, str);
   add_succeeded_mess("$N withdraw$s " + num + " of " + str + " from $D.\n");
   return 1;
}
void init() {
   commercial::init();
   add_command("change", "<string'money'> into <string'type'> on <direct:object>",
                  (: change($4[0], $4[1]) :));
   if (environment()->is_allowed(this_player()->query_name())) {
      add_command("set", "cut <number'percentage'> on <direct:object>",
                  (: do_set_cut($4[0]) :));
      add_command("deposit", "<number> of <string'type'> on <direct:object>",
                  (: do_deposit($4[0], $4[1]) :));
      add_command("withdraw", "<number> of <string'type'> on <direct:object>",
                  (: do_withdraw($4[0], $4[1]) :));
   }
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   add_auto_load_value(map, BOARD_TAG, "cut", _cut);
   add_auto_load_value(map, BOARD_TAG, "money", _money);
   add_auto_load_value(map, BOARD_TAG, "cost", _cost);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   _cut = query_auto_load_value(map, BOARD_TAG, "cut");
   _money = query_auto_load_value(map, BOARD_TAG, "money");
   _cost = query_auto_load_value(map, BOARD_TAG, "cost");
}

==================================================
FILE: furnitures/commercial/newspaper_archive_box.c
==================================================

inherit "/std/room/furniture/commercial";
#include <room/newspaper.h>
#include <money.h>
#include <move_failures.h>
#define BOARD_TAG "newspaper box"
private string _paper;
private int _cost;
private int _back_issue_cost;
void setup() {
   set_name("box");
   set_short("newspaper archive box");
   add_adjective(({ "archive", "box" }));
   add_help_file("newspaper_archive_box");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
   set_value(2700);
   set_commercial_size(5);
   reset_get();
}
void set_paper(string paper) {
   string place;
   string* bits;
   if (!paper) {
      return ;
   }
   _paper = paper;
   place = query_money_place();
   set_short(_paper + " box");
   set_long("This is a very large battered looking metal box that is full "
            "of old and new copies of " +
            (lower_case(paper)[0..3] == "the "?"":"the ") +
            paper + ".  There is a door on the front you could pull open "
            "beside which is small white writing saying " +
            MONEY_HAND->money_value_string(_cost, place) + " for the current "
            "issue and " +
            MONEY_HAND->money_value_string(_back_issue_cost, place) +
            " for back issues.\n");
   if (lower_case(_paper)[0..3] == "the ") {
      add_property("determinate", "");
   }
   bits = explode(lower_case(_paper), " ");
   add_adjective(bits);
}
int do_buy(int issue) {
   int paper_cost;
   int cost;
   int edition;
   string place;
   object ob;
   int *editions;
   place = query_money_place();
   if (issue == -1) {
      edition = NEWSPAPER_HANDLER->query_last_edition_num(_paper);
      if (!edition) {
         add_failed_mess("There is no edition to buy.\n");
         return 0;
      }
      cost = _cost;
      paper_cost = (NEWSPAPER_HANDLER->query_paper_cost(_paper) * 2) / 3;
   } else {
      edition = NEWSPAPER_HANDLER->query_last_edition_num(_paper);
      if (issue <= 0 || issue > edition) {
         add_failed_mess("The issue numberm ust be between 1 and " +
                         edition + ".\n");
         return 0;
      }
      edition = issue;
      paper_cost = NEWSPAPER_HANDLER->query_paper_cost(_paper) * 2;
      cost = _back_issue_cost;
   }
   if (this_player()->query_value_in(place) < cost) {
      add_failed_mess("You do not have enough money to pay for " +
                      _paper + ", you need " +
                      MONEY_HAND->money_value_string(cost, place) +
                      ".\n");
      return 0;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);
   adjust_float(cost - paper_cost);
   ob = clone_object("/obj/misc/newspaper");
   ob->set_paper(_paper);
   ob->set_edition(edition);
   if (ob->move(this_player()) != MOVE_OK) {
      ob->move(environment(this_player()));
      write("Unable to move the paper into your inventory, putting it on "
            "the ground.\n");
   }
   editions = this_player()->query_property("Paper " + _paper);
   if (!editions) {
      editions = ({ });
   }
   if (member_array(edition, editions) == -1) {
      editions += ({ edition });
      this_player()->add_property("Paper " + _paper, editions);
      NEWSPAPER_HANDLER->add_edition_paper_sold(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   } else {
      NEWSPAPER_HANDLER->add_edition_revenue(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   }
   add_succeeded_mess("$N pull$s a newspaper from $D.\n");
   return 1;
}
string query_main_status(int hints) {
   string ret;
   int paper_cost;
   int back_issue_cost;
   string place;
   place = query_money_place();
   paper_cost = NEWSPAPER_HANDLER->query_paper_cost(_paper);
   back_issue_cost = paper_cost * 2;
   paper_cost = (paper_cost * 2) / 3;
   ret = "$I$0=" + the_short() + ":\n";
   ret +=   "$I$6=   Revenue                        : " +
          MONEY_HAND->money_value_string(query_revenue(), place) +
          "\n$I$6=   Cost from publisher            : " +
          MONEY_HAND->money_value_string(paper_cost, place) +
          "\n$I$6=   Sale price                     : " +
          MONEY_HAND->money_value_string(_cost, place) +
          "\n$I$6=   Back Issue Cost from publisher : " +
          MONEY_HAND->money_value_string(back_issue_cost, place) +
          "\n$I$6=   Back Issue Sale price          : " +
          MONEY_HAND->money_value_string(_back_issue_cost, place) +
          "\n";
   if (hints) {
      ret += "$I$6=      set cost <amount> on <box>\n";
   }
   return ret;
}
int do_set_cost(string amount, int back_issue) {
   int amt;
   string place;
   place = query_money_place();
   amt = MONEY_HAND->value_from_string(amount, place);
   if (amt <= 0) {
      add_failed_mess("The value " + amount + " is invalid.\n");
      return 0;
   }
   if (back_issue) {
      _back_issue_cost = amt;
   } else {
      _cost = amt;
   }
   set_long("This is a very large battered looking metal box that is full "
            "of old and new copies of " +
            (lower_case(_paper)[0..3] == "the "?"":"the ") +
            _paper + ".  There is a door on the front you could pull open "
            "beside which is small white writing saying " +
            MONEY_HAND->money_value_string(_cost, place) + " for the current "
            "issue and " +
            MONEY_HAND->money_value_string(_back_issue_cost, place) +
            " for back issues.\n");
   if (back_issue) {
      add_succeeded_mess("$N set$s the cost to buy back issue of the paper "
                         "from $D to " +
                         MONEY_HAND->money_value_string(amt, place) + ".\n");
   } else {
      add_succeeded_mess("$N set$s the cost to buy papers from $D to " +
                         MONEY_HAND->money_value_string(amt, place) + ".\n");
   }
   return 1;
}
void init() {
   add_command("buy", "issue <number> from <direct:object>",
               (: do_buy($4[0]) :));
   add_command("pull", "[door] [on] <direct:object>", (: do_buy(-1) :));
   add_command("pull", "open <direct:object>", (: do_buy(-1) :));
   if (is_allowed(this_player()->query_name())) {
      add_command("set", "cost <string'amount'> on <direct:object>",
                  (: do_set_cost($4[0], 0) :));
      add_command("set", "back issue cost <string'amount'> on <direct:object>",
                  (: do_set_cost($4[0], 1) :));
   }
   ::init();
}
mapping query_commercial_options() {
   mapping ret;
   string paper;
   ret = ([ ]);
   foreach (paper in NEWSPAPER_HANDLER->query_all_papers()) {
      ret[paper] = 0;
   }
   return ([ "paper" : ret ]);
}
void set_commercial_option(string type, string name) {
   switch (type) {
   case "paper" :
      _cost = NEWSPAPER_HANDLER->query_paper_cost(name);
      _back_issue_cost = NEWSPAPER_HANDLER->query_paper_cost(name) * 3;
      call_out("set_paper", 1, name);
      break;
   }
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   add_auto_load_value(map, BOARD_TAG, "cost", _cost);
   add_auto_load_value(map, BOARD_TAG, "paper", _paper);
   add_auto_load_value(map, BOARD_TAG, "back cost", _back_issue_cost);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   string name;
   commercial::init_dynamic_arg(map, player);
   _cost = query_auto_load_value(map, BOARD_TAG, "cost");
   _back_issue_cost = query_auto_load_value(map, BOARD_TAG, "back cost");
   name = query_auto_load_value(map, BOARD_TAG, "paper");
   call_out("set_paper", 1, name);
}

==================================================
FILE: furnitures/commercial/newspaper_box.c
==================================================

inherit "/std/room/furniture/commercial";
#include <room/newspaper.h>
#include <money.h>
#include <move_failures.h>
#define BOARD_TAG "newspaper box"
private string _paper;
private int _cost;
void setup() {
   set_name("box");
   set_short("newspaper box");
   add_adjective("box");
   add_help_file("newspaper_box");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
   set_value(900);
   set_commercial_size(1);
   reset_get();
}
void set_paper(string paper) {
   string place;
   string* bits;
   if (!paper) {
      return ;
   }
   _paper = paper;
   place = query_money_place();
   set_short(_paper + " box");
   set_long("This is a battered looking metal box that is full of copies of " +
            (lower_case(paper)[0..3] == "the "?"":"the ") +
            paper + ".  There is a door on the front you could pull open "
            "beside which is small white writing saying " +
            MONEY_HAND->money_value_string(_cost, place) + ".\n");
   if (lower_case(_paper)[0..3] == "the ") {
      add_property("determinate", "");
   }
   bits = explode(lower_case(_paper), " ");
   add_adjective(bits);
}
int do_buy() {
   int paper_cost;
   int cost;
   int edition;
   string place;
   object ob;
   int *editions;
   place = query_money_place();
   cost = _cost;
   paper_cost = (NEWSPAPER_HANDLER->query_paper_cost(_paper) * 2) / 3;
   edition = NEWSPAPER_HANDLER->query_last_edition_num(_paper);
   if (!edition) {
      add_failed_mess("There is no edition to buy.\n");
      return 0;
   }
   if (this_player()->query_value_in(place) < cost) {
      add_failed_mess("You do not have enough money to pay for " +
                      _paper + ", you need " +
                      MONEY_HAND->money_value_string(cost, place) +
                      ".\n");
      return 0;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);
   adjust_float(cost - paper_cost);
   ob = clone_object("/obj/misc/newspaper");
   ob->set_paper(_paper);
   ob->set_edition(edition);
   if (ob->move(this_player()) != MOVE_OK) {
      ob->move(environment(this_player()));
      write("Unable to move the paper into your inventory, putting it on "
            "the ground.\n");
   }
   editions = this_player()->query_property("Paper " + _paper);
   if (!editions) {
      editions = ({ });
   }
   if (member_array(edition, editions) == -1) {
      editions += ({ edition });
      this_player()->add_property("Paper " + _paper, editions);
      NEWSPAPER_HANDLER->add_edition_paper_sold(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   } else {
      NEWSPAPER_HANDLER->add_edition_revenue(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   }
   add_succeeded_mess("$N pull$s a newspaper from $D.\n");
   return 1;
}
string query_main_status(int hints) {
   string ret;
   int paper_cost;
   string place;
   place = query_money_place();
   paper_cost = (NEWSPAPER_HANDLER->query_paper_cost(_paper) * 2) / 3;
   ret = the_short() + ":\n";
   ret +=   "$I$6=   Revenue             : " +
          MONEY_HAND->money_value_string(query_revenue(), place) +
          "\n$I$6=   Cost from publisher : " +
          MONEY_HAND->money_value_string(paper_cost, place) +
          "\n$I$6=   Sale price          : " +
          MONEY_HAND->money_value_string(_cost, place) +
          "\n";
   if (hints) {
      ret += "$I$6=      set cost <amount> on <box>\n";
   }
   return ret;
}
int do_set_cost(string amount) {
   int amt;
   string place;
   place = query_money_place();
   amt = MONEY_HAND->value_from_string(amount, place);
   if (amt <= 0) {
      add_failed_mess("The value " + amount + " is invalid.\n");
      return 0;
   }
   _cost = amt;
   set_long("This is a battered looking metal box that is full of copies of " +
            (lower_case(_paper)[0..3] == "the "?"":"the ") +
            _paper + ".  There is a door on the front you could pull open "
            "beside which is small white writing saying " +
            MONEY_HAND->money_value_string(_cost, place) + ".\n");
   add_succeeded_mess("$N set$s the cost of buy papers from $D to " +
                      MONEY_HAND->money_value_string(amt, place) + ".\n");
   return 1;
}
void init() {
   add_command("buy", "paper from <direct:object>", (: do_buy() :));
   add_command("pull", "[door] [on] <direct:object>", (: do_buy() :));
   add_command("pull", "open <direct:object>", (: do_buy() :));
   if (is_allowed(this_player()->query_name())) {
      add_command("set", "cost <string'amount'> on <direct:object>",
                  (: do_set_cost($4[0]) :));
   }
   ::init();
}
mapping query_commercial_options() {
   mapping ret;
   string paper;
   ret = ([ ]);
   foreach (paper in NEWSPAPER_HANDLER->query_all_papers()) {
      ret[paper] = 0;
   }
   return ([ "paper" : ret ]);
}
void set_commercial_option(string type, string name) {
   switch (type) {
   case "paper" :
      _cost = NEWSPAPER_HANDLER->query_paper_cost(name);
      call_out("set_paper", 1, name);
      break;
   }
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   add_auto_load_value(map, BOARD_TAG, "cost", _cost);
   add_auto_load_value(map, BOARD_TAG, "paper", _paper);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   string name;
   commercial::init_dynamic_arg(map, player);
   _cost = query_auto_load_value(map, BOARD_TAG, "cost");
   name = query_auto_load_value(map, BOARD_TAG, "paper");
   call_out("set_paper", 1, name);
}

==================================================
FILE: furnitures/commercial/pickler.c
==================================================

inherit "/std/room/furniture/commercial";
#include <money.h>
#define FEE_PER_USE 40
#define BOARD_TAG "pickler"
private int _revenue;
private int _cost;
void setup() {
   set_name( "pickler" );
   set_short( "pickler" );
   set_long( "A small wooden box with a handle on it, it has some words "
             "written on it.\n");
   add_read_mess("Pickler, pull for results", 0, "common");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits" ]));
   set_weight(2000);
   set_value(240000);
   add_help_file("pickler");
   set_commercial_size(2);
   set_commercial_type("utility");
   set_shop_use_types(({ "pickler" }));
   _cost = 80;
}
int do_pickle(object* obs) {
   object* pickleable;
   string place;
   int amt;
   int here_amt;
   if (!is_open_for("pickler", this_player()->query_name())) {
      add_failed_mess("The pickler is not open.\n");
      return 0;
   }
   place = query_money_place();
   pickleable = filter(obs, (: !$1->query_cured() &&
                               ($1->query_property("cureable") ||
                                $1->query_decay_speed()) :));
   if (!sizeof(pickleable)) {
      add_failed_mess("You cannot pickle any of " +
                      query_multiple_short(obs) + ".\n");
      return 0;
   }
   amt = sizeof(pickleable) * _cost;
   here_amt = amt - sizeof(pickleable) * FEE_PER_USE;
   if (here_amt < 0) {
      if (query_float() < -here_amt) {
          add_failed_mess(environment()->the_short() + " does not "
                          "have enough money to pickle anything.\n");
          return 0;
      }
   }
   if (this_player()->query_value_in(place) < amt) {
      add_failed_mess("You do not have the needed " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to pay for $I to be pickled.\n", pickleable);
      return 0;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(amt, place), place);
   pickleable->do_cure();
   adjust_float(here_amt);
   _revenue += here_amt;
   add_succeeded_mess("$N pickle$s $I on $D.\n", pickleable);
   return 1;
}
int do_set_cost(string amount) {
   int amt;
   string place;
   place = query_money_place();
   amt = MONEY_HAND->value_from_string(amount, place);
   if (amt <= 0) {
      add_failed_mess("The value " + amount + " is invalid.\n");
      return 0;
   }
   _cost = amt;
   add_succeeded_mess("$N set$s the cost of using $D to " +
                      MONEY_HAND->money_value_string(amt, place) + ".\n");
   return 1;
}
string query_main_status(int hint) {
   string place;
   place = query_money_place();
   return the_short() + " status:\n"
          "\n$I$6=   Fee Per Use : " +
              MONEY_HAND->money_value_string(FEE_PER_USE, place) + " (fixed)"
          "\n$I$6=   Cost Per Use: " +
              MONEY_HAND->money_value_string(_cost, place) +
          "\n$I$6=   Profit      : " +
             MONEY_HAND->money_value_string(_revenue, place) + "\n";
}
int do_stats() {
   string ret;
   ret = query_main_status(0);
   write(ret);
   add_succeeded_mess("");
   return 1;
}
void init() {
   commercial::init();
   add_command("use", "<direct:object> to [pickle] <indirect:object>",
               (: do_pickle :));
   add_command("use", "<direct:object> with <indirect:object>",
               (: do_pickle :));
   add_command("pickle", "<indirect:object> with <direct:object>",
               (: do_pickle :));
   add_command("pull", "[handle] [on] <direct:object> with <indirect:object>",
               (: do_pickle :));
   if (environment()->is_allowed(this_player()->query_name())) {
      add_command("status", "<direct:object>",
                  (: do_stats() :));
      add_command("set", "cost <string'cost'> on <direct:object>",
                  (: do_set_cost($4[0]) :));
   }
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   add_auto_load_value(map, BOARD_TAG, "revenue", _revenue);
   add_auto_load_value(map, BOARD_TAG, "cost", _cost);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   _revenue = query_auto_load_value(map, BOARD_TAG, "revenue");
   _cost = query_auto_load_value(map, BOARD_TAG, "cost");
}

==================================================
FILE: furnitures/commercial/poll_data.c
==================================================

inherit "/std/room/inherit/voting_room";
inherit "/std/room/furniture/commercial";
#include <money.h>
#define BOARD_TAG "poll data"
#define POLL_DATA_MAXIMUM_RESULTS 10
private int _allow_open_voting;
private string* _finished_votes;
void finish_vote(string type, string description, string* choices,
                 mapping votes, string* voted);
void create() {
   voting_room::create();
   commercial::create();
   _finished_votes = ({ });
}
void setup() {
   set_name( "poll" );
   set_short( "opinion poll" );
   add_adjective( ({ "opinion" } ));
   set_long( "A box with a bunch of pieces paper sitting on it.  It seems "
             "to be keeping a tally of something.\n");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits" ]));
   set_weight(2000);
   set_value(240000);
   set_commercial_size(2);
   set_commercial_type("misc");
   set_shop_use_types(({ "poll add", "poll vote" }));
   set_completion_action((: finish_vote :));
   set_no_elections(1);
   set_vote_conditions((: is_open_for("poll vote", $1->query_name()) :));
   add_help_file("poll_data");
}
int load_me() {
   if (!query_commercial_id()) {
      setup_new_commercial_id();
   }
   set_save_file(query_save_dir() + query_commercial_id());
   if (!_finished_votes) {
      _finished_votes = ({ });
   }
}
int do_show_results() {
   string ret;
   string result;
   ret = "";
   foreach (result in _finished_votes) {
      ret += result + "\n\n";
   }
   write("$P$Vote Archive$P$" + ret);
   add_succeeded_mess("");
   return 1;
}
int do_create_vote(string choices) {
   if (!is_open_for("poll add", this_player()->query_name())) {
      add_failed_mess("Unable to add a vote.\n");
      return 0;
   }
  return ::do_create_vote(choices);
}
void finish_vote(string type, string description, string* choices,
                 int* votes, string* voted)
{
   string ret;
   int i;
   ret = "Vote finished at " + ctime(time()) + ":\n";
   ret += "$I$3=   " + description + "\n\n";
   ret += "$I$0=Results:\n$I$3=   ";
   for (i = 0; i < sizeof(choices); i++) {
      ret += choices[i] + ": " + votes[i] + "\n";
   }
   if (!_finished_votes) {
      _finished_votes = ({ ret });
   } else {
      _finished_votes += ({ ret });
   }
   if (sizeof(_finished_votes) > POLL_DATA_MAXIMUM_RESULTS) {
      _finished_votes = _finished_votes[0..POLL_DATA_MAXIMUM_RESULTS];
   }
   save_room();
}
int do_set_duration(int hours) {
   if (hours <= 0) {
      add_failed_mess("The duration must be positive.\n");
      return 0;
   }
   set_vote_duration(hours * 60 * 60);
   add_succeeded_mess("Set the vote duration to " + hours + " hours.\n");
   return 1;
}
int do_delete_vote(int id) {
   if (!::delete_vote(id)) {
      add_failed_mess("Cannot delete the vote id #" + id + ".\n");
      return 0;
   }
   add_succeeded_mess("Deleted the vote id#" + id + ".\n");
   return 1;
}
int do_end_vote(int id) {
   if ( !query_our_votes()[ id ] ) {
      add_failed_mess("Cannot end the vote id #" + id + ".\n");
      return 0;
   }
   end_vote(id);
   add_succeeded_mess("Finished the vote id#" + id + ".\n");
   return 1;
}
string query_main_status() {
   string ret;
   ret = "Vote duration:    " + (query_vote_duration() / (60 * 60)) +
         " hours\n";
   return ret;
}
void init() {
   commercial::init();
   voting_room::init();
   voting_room::init_add_vote();
   add_command("results", "of votes", (: do_show_results() :));
   if (environment()->is_allowed(this_player()->query_name())) {
      add_command("set", "vote duration <number'hours'> on <direct:object>",
                  (: do_set_duration($4[0]) :));
      add_command("delete", "vote <number'vote id'>",
                  (: do_delete_vote($4[0]) :));
      add_command("finish", "vote <number'vote id'>",
                  (: do_end_vote($4[0]) :));
   }
}

==================================================
FILE: furnitures/commercial/postal.c
==================================================

inherit "/std/room/furniture/commercial";
#include <money.h>
#include <mail.h>
#define BOARD_TAG "postal"
int _num_uses;
void setup() {
   set_name( "counter" );
   set_short( "postal counter" );
   add_adjective("postal");
   set_long( "A wooden counter that looks like a place you could write "
             "and read mail.\n");
   set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
   set_allowed_room_verbs((["sitting" : "sits" ]));
   set_weight(2000);
   set_value(6400000);
   add_help_file("postal");
   set_commercial_size(25);
   set_commercial_type("utility");
   set_shop_use_types(({ "pickler" }));
}
int do_mail(string to) {
   if (MAIL_TRACK->mail(to)) {
      _num_uses++;
      return 1;
   }
   return 0;
}
string query_main_status(int hint) {
   string place;
   place = query_money_place();
   return the_short() + " status:\n"
          "\n$I$6=   Number of  uses : " + _num_uses + "\n";
}
void init() {
   commercial::init();
   add_command("mail", "<string'to'>",
               (: do_mail($4[0]) :));
   add_command("mail", "[handle] [on] <direct:object> with <indirect:object>",
               (: do_mail(0) :));
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   add_auto_load_value(map, BOARD_TAG, "uses", _num_uses);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   _num_uses = query_auto_load_value(map, BOARD_TAG, "uses");
}

==================================================
FILE: furnitures/commercial/small_shop.c
==================================================

inherit "/std/room/furniture/shop_base";
void setup() {
   set_name( "counter" );
   set_short( "small shop counter" );
   add_adjective( ({ "small", "shop" } ));
   set_long( "The smooth polished surface of the small counter shines and "
             "glows at you.\n");
   set_allowed_positions(({"sitting", "standing" }));
   set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
   set_weight(1000);
   set_value(480000);
   set_maximum_inventory_size(50);
   set_commercial_size(40);
}

==================================================
FILE: furnitures/artwork/mountain_painting.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "painting" );
    set_short( "painting of a misty mountain range" );
    add_adjective( ({ "of", "a", "misty", "mountain", "range" }) );
    set_long( "This is a watercolour painting of a range of "
        "mountains skirting a misty lake.  Fiery red trees "
        "border the indescript water's edge, snaking their "
        "branches out horizontally more than vertically.  "
        "The mountains have been painted complementing "
        "shades of steel grey and persian blue, while the "
        "water itself is a strangely creamy white.\n" );
    set_weight( 40 );
    set_value( 46775 );
    set_allowed_positions( ({"hanging"}) );
    set_allowed_room_verbs((["hanging" : "hangs",
                             "sitting" : "sits",
                             "dangling" : "dangles",
                             "standing" : "stands" ]));
}

==================================================
FILE: furnitures/fake_plants/silk_cabbage_plant.c
==================================================

inherit "/std/room/furniture/basic";
void setup () {
    set_name( "plant" );
    add_adjective( ({ "silk", "potted", "cabbage" }) );
    set_short( "potted silk cabbage plant" );
    add_alias( "cabbage" );
    set_main_plural ( "potted silk cabbage plants" );
    add_property( "determinate", "a " );
    set_long( "Rare and magnificent!  Strange and exotic!  Potted in a "
        "subtley plain pot, this fine silk-leafed brassica has been "
        "created in Sum Dim by none other than Brown Fingers Dibbler, "
        "purveyor of the finest silken forn plants.  Its leaves even look "
        "as though they have been nibbled slightly by a caterpillar, "
        "for the authentic touch.\n" );
    set_value( 35000 );
    set_weight( 150 );
    set_allowed_room_verbs(([ "sitting" : "sits",
                              "standing" : "stands",
                              "lying" : "lies" ]));
}

==================================================
FILE: furnitures/safes/small_safe.c
==================================================

inherit "/std/room/furniture/storage";
void setup() {
  set_name("safe");
  set_short("small iron safe");
  add_adjective(({"small", "iron"}));
  set_long("This is a small iron safe.  It bears the logo of "
           "Joseph Thighbiter a renowned safe maker.  It appears "
           "to feature one of his patented locks.\n");
  add_drawer("top", 50);
  add_drawer("middle", 25);
  add_drawer("bottom", 25);
  set_drawers_inside(1);
  set_weight(900);
  set_value(120000);
  set_allowed_room_verbs((["squatting" : "squats" ]));
  set_pick_skill("covert.lockpick.safes");
  set_difficulty(4);
  setup_trap(300, "pick",
             "Hidden inside the lock is a small ampule which, if touched by "
             "an unwary tool would trigger a puff of poisonous gas.",
             ({"A small cloud of gas puffs out of the safe.\n",
                 "A small cloud of gas puffs out of the safe.\n"}),
             ({"/std/effects/poisons/poison_gas", 600}));
}
void init() {
  string key_id;
  object key;
  if(!query_key()) {
    key_id = "safe"+random(10000);
    set_key(key_id);
    key = clone_object("/std/key");
    key->set_key("small iron", key_id);
    key->set_long("This small, yet sturdy, key looks like it is for a "
                  "safe.\n");
    key->move(this_object());
    set_closed();
  }
  ::init();
}

==================================================
FILE: furnitures/chests/pine_chest_of_drawers.c
==================================================

inherit "/std/room/furniture/storage";
void setup() {
    set_name("chest");
    set_short("Agatean pine chest of drawers");
    add_adjective(({"agatean", "pine", "chest", "of", "drawers"}));
    add_alias("chest of drawers");
    set_long("A simple chest of drawers formed of genuine Agatean pine, "
        "sturdy and functional.  The grain of the wood is a little "
        "mismatched testifying to the desire of the manufacturer to "
        "create something functional rather than beautiful.  Five drawers "
        "are set into the front each bearing two knobs of the same "
        "material. Very slight ornamentation has been added in the form "
        "of gentle curves deliniating the edges and unornamented top.\n");
    set_weight(900);
    set_max_weight(400);
    set_value(200000);
    set_allowed_room_verbs((["squatting" : "squats" ]));
    set_pick_skill("covert.lockpick.doors");
    set_difficulty(4);
}
void init() {
    string key_id;
    object key;
    if(!query_key()) {
        key_id = "furniture_lock_"+random(1000);
        set_key(key_id);
        key = clone_object("/std/key");
        key->set_key("small iron", key_id);
        key->set_long("This small, yet sturdy, key looks like it is for a "
                  "piece of furniture.\n");
        key->move(this_object());
        set_closed();
    }
  ::init();
}

==================================================
FILE: furnitures/chests/pumpkin_chest.c
==================================================

inherit "/std/room/furniture/storage";
void setup() {
  set_name("chest");
  set_short("pumpkin chest");
  add_adjective(({"pumpkin","fairytale"}));
  set_long(
    "Shaped and painted like a perfectly ripe pumpkin, this chest is "
    "held just off the ground by four sturdy wooden wheels.  "
    "Unfortunately, these appear to be merely decorative in nature, and "
    "don't actually turn.  A deep green stem has been attached to the "
    "top of the chest to act as a handle.\n");
  set_weight(1200);
  set_max_weight(200);
  set_value(590000);
  set_allowed_room_verbs((["squatting" : "squats",
                               "sitting" : "sits"
  ]));
}

==================================================
FILE: furnitures/outdoor/bird_bath.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
  set_name( "birdbath" );
  set_short( "stone bird bath" );
  add_adjective( ({ "stone", "bird", "bath" }) );
  add_alias( ({ "bath", "bird bath" }) );
  set_long( "This is a block of stone that has been chiseled and hacked into "
   "a vaguely bird bath shape.  It is really quite ugly.  Fortunately, birds "
   "don't seem to be art critics.  The base of the bird bath is made of some "
   "sort of porous stone that resembles Dwarf Bread in texture.\n" );
  set_allowed_positions(({"sitting","standing"}));
  set_allowed_room_verbs((["standing" : "stands" ]));
  set_weight(200);
  set_value(4000);
}

==================================================
FILE: furnitures/cushions/frog_cushion.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
  set_name( "cushion" );
  set_short( "frog cushion" );
  add_adjective( ({ "frog", "green" }) );
  add_alias( "pillow" );
  set_long( "This is a cushion that is the approximate shape of a "
    "frog that has been flattened by a cart.  It is covered in vivid "
    "green cordueroy.\n" );
  set_allowed_positions(({"sitting", "lying", "kneeling", "meditating",
                            "crouching", "standing"}));
  set_allowed_room_verbs((["lying" : "lays", "hanging" : "hangs"]));
  set_weight(2);
  set_value(8000);
}

==================================================
FILE: furnitures/shelves/pine_nightstand.c
==================================================

inherit "/std/room/furniture/storage";
void setup() {
  set_name( "nightstand" );
  set_short( "pine nightstand" );
  add_adjective( ({ "pine", "bedside" }) );
  add_alias("cabinet");
  set_long( "This is a small bedside cabinet, made of thick hublandish "
            "pine planks.  The wood is oiled, to bring out the characteristic "
            "colour, and the stripes and knots texture in it.  It's just the "
            "kind of thing that is thought to have a rustic look, by "
            "people who don't have much of a clue what rustic is.\n" );
  add_drawer( "top", 50 );
  set_weight(135);
  set_value(10000);
  set_allowed_positions(({"sitting"}));
  set_allowed_room_verbs((["sitting" : "sits" ]));
}
void init() {
    string key_id;
  object key;
  if(!query_key()) {
    key_id = "nightstand_"+random(100);
    set_key(key_id);
    set_difficulty(1);
    key = clone_object("/std/key");
    key->set_key("small", key_id);
    key->set_long("This small key looks like it is probably for a piece of "
                  "furniture.\n");
    key->move(this_object());
    set_closed();
  }
  ::init();
}

==================================================
FILE: furnitures/crockery/happiness_jar.c
==================================================

inherit "/std/room/furniture/storage";
void setup(){
    set_name( "happiness" );
    set_short( "jar of double happiness" );
    add_adjective( ({ "jar", "of", "double" }) );
    set_long("In Agatea, this elegant blue and white porcelain jar is "
        "often presented as a wedding gift.  The pictogram for happiness "
        "is drawn twice in parallel to make the Double Happiness sign, "
        "which is used in wedding decorations.  With a tight lid, this "
        "porcelain jar is excellent for storing anything you wish.\n");
    set_weight( 140 );
    set_max_weight(27);
    set_value( 25000 );
    set_allowed_room_verbs(([ "sitting" : "sits",
                              "standing" : "stands",
                              "leaning" : "leans",
                              "lying" : "lies",
                              "squatting" : "squats" ]));
}

==================================================
FILE: furnitures/mirrors/jasmine_mirror.c
==================================================

inherit "/std/room/furniture/mirror";
string reflect();
void setup(){
  set_name( "mirror" );
  set_short( "jasmine mirror" );
  add_adjective( ({ "jasmine", "flower", "oval" }) );
  set_long("Delicately carved jasmine flowers and bead trim surround this "
           "oval mirror.  The flowers are so detailed that they almost "
           "appear to be real.\n");
  set_allowed_room_verbs( (["hanging" : "hangs",
                            "gracing"  : "graces"   ]) );
  set_weight(60);
  set_value(50000);
}

==================================================
FILE: furnitures/cabinets/rose_display_cabinet.c
==================================================

inherit "/std/room/furniture/storage";
void setup() {
    set_name("cabinet");
    set_short("rosewood display cabinet");
    add_adjective( ({ "rosewood", "display" }) );
    set_long("This is a tall rosewood display cabinet that has a glass "
        "front to ensure that its contents are well protected.  Supported "
        "by various delicate geometric shelves on the inside, the outside "
        "is inlaid with mother of pearl that has been shaped into "
        "blossoming cherry trees.\n");
    set_transparent();
    set_weight(1200);
    set_max_weight(200);
    set_value(590000);
    set_allowed_room_verbs((["squatting" : "squats" ]));
}

==================================================
FILE: furnitures/tables/pedestal_table.c
==================================================

inherit "/std/room/furniture/surface";
void setup() {
    set_name( "table" );
    set_short( "pedestal table" );
    add_adjective( "pedestal" );
    set_long("Finished in warm antique hues, this pedestal table is a "
        "roughly triangular object which ends abruptly in a flat plateau "
        "which looks to be the ideal place for placing a few books or "
        "a reading lantern.  Rising along its height are a series of "
        "drawers with brass handles, which narrow in width with the table "
        "as it rises.\n");
    set_allowed_positions( ({ "on" }) );
    set_allowed_room_verbs( ([ "standing" : "stands" ]) );
    set_weight( 250 );
    set_max_weight( 50 );
    set_value( 88000 );
    set_allow_use_internals( 1 );
}

==================================================
FILE: furnitures/misc/antique_food_basket.c
==================================================

inherit "/std/room/furniture/storage";
void setup(){
    set_name( "basket" );
    set_short( "antique food basket" );
    add_adjective( ({ "antique", "food", "basket" }) );
    set_long("Used for carrying food in the older times, now refurbished, "
        "this antique food basket is now a curious ornament to a "
        "contemporary eye.  Still usable for storage, if not for food, the "
        "handle is made of bamboo that has been bent into shape.  "
        "Retrieved from the Sum Dim countryside, no two of these baskets "
        "are alike.\n");
    set_weight( 60 );
    set_max_weight(38);
    set_value( 62000 );
    set_allowed_room_verbs(([ "sitting" : "sits",
                              "standing" : "stands",
                              "leaning" : "leans",
                              "lying" : "lies",
                              "squatting" : "squats" ]));
}

==================================================
FILE: furnitures/misc/bamboo_screen.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "screen" );
    set_short( "bamboo matchstick screen" );
    add_adjective( ({ "bamboo", "matchstick" }) );
    set_long( "This double-sided screen has been constructed by "
        "lashing long bamboo poles together so that "
        "four distinct interconnected panels are hinged "
        "together when it is standing.  A lovely tan colour, "
        "the texture is rough and the knots in the wood give it "
        "a rustic minimalist look.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(20);
    set_value(400000);
}

==================================================
FILE: furnitures/misc/blackboard.c
==================================================

inherit "/std/room/furniture/basic";
int query_allowed (string);
string read_stuff();
string query_words();
string _owner = "";
string _words = "";
void setup() {
  set_name ("blackboard");
  set_short ("blackboard");
  add_alias (({"board", "sign"}));
  set_long ("The residue of faded chalk-dust and long forgotten "
      "doodles lies heavily on the blackboard.  The grain of the "
      "board is worn and slightly mottled with age, hinting at "
      "a long and dignified history of classrooms and university "
      "lecterns.  Or perhaps just hinting at cheap wood and "
      "bad upkeep.\n");
  set_read_mess ((: read_stuff :));
  set_allowed_room_verbs( (["standing" : "stands",
                          "hanging"  : "hangs"]) );
  set_value(0);
}
void init() {
  this_player()->add_command ("write", this_object(), "[on] <direct:object>");
  this_player()->add_command ("clean", this_object(), "<direct:object>");
}
void set_words (string bing) {
    _words = bing;
}
string query_words () {
    return _words;
}
string read_stuff() {
    string bing = "";
    if (sizeof (query_words())) {
        bing += query_words();
    }
    if (!sizeof (bing)) {
        bing = "A few random letters that escaped cleaning can be seen on "
            "the blackboard.";
    }
    return bing;
}
int do_clean() {
    if (!query_allowed (this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "You cannot clean "
            "the blackboard!\n", ({ }));
        return 0;
    }
    set_words ("");
    return 1;
}
int do_write() {
    string bean;
    if (!query_allowed (this_player()->query_name())) {
        this_player()->add_failed_mess (this_object(), "You cannot write on "
            "the blackboard!\n", ({ }));
        return 0;
    }
    bean = query_words();
    this_player()->do_edit(bean, "blackboard_text", this_object());
    this_player()->add_succeeded_mess (this_object(), "$N find$s a handy "
        "piece of chalk and start$s to write on the blackboard.\n", ({ }));
    return 1;
}
void blackboard_text(string text) {
    if (!text) {
      tell_room (environment (this_object()), this_player()->one_short()
          + " steps back from the blackboard without making any "
          "changes.\n", this_player());
      tell_object (this_player(), "Okay, nothing has been changed.\n");
      return;
    }
    set_words (text);
    tell_room(environment (this_object()), this_player()->one_short()
      + " finishes writing on the blackboard.\n", this_player());
}
int query_allowed (string name) {
    if (function_exists ("query_owner", environment (this_object()))) {
      if (name == environment (this_object())->query_owner()) {
        return 1;
      }
    }
    if (function_exists ("query_allowed", environment (this_object()))) {
      if (member_array (name, environment(this_object())->query_allowed())
          != -1) {
        return 1;
      }
      else {
        return 0;
      }
    }
    return 1;
}
mapping query_dynamic_auto_load() {
   return ([
     "::" : ::query_dynamic_auto_load(),
      "words" : query_words(),
   ]);
}
void init_dynamic_arg( mapping map ) {
   ::init_dynamic_arg( map[ "::" ] );
   set_words (map["words"]);
   set_read_mess ((: read_stuff :));
}

==================================================
FILE: furnitures/misc/brass_gong.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name("gong");
    set_short("brass gong");
    add_adjective( "brass" );
    set_long("This is a medium-sized brass gong, hanging from a brass "
        "frame.  Lazy pandas roll around the surface of the gong, "
        "the occasional one actually doing something other than "
        "eating or chewing on a stalk of bamboo.  The gong can be hit "
        "to make a loud ringing sound and annoy everyone in the room.\n");
    set_weight( 60 );
    set_value( 10000 );
    set_material( "brass" );
    set_allowed_positions( ({"hanging"}) );
    set_allowed_room_verbs((["hanging" : "hangs",
                             "sitting" : "sits",
                             "dangling" : "dangles",
                             "standing" : "stands" ]));
}
void init() {
    this_player()->add_command( "hit", this_object(), "<direct:object:me>" );
}
int do_hit(){
    this_player()->add_succeeded_mess(this_object(), "$N $V $p "
        +this_object()->short()+" loudly, filling the room with a "
        "deafening ringing sound.\n", ({ }));
    return 1;
}

==================================================
FILE: furnitures/misc/burnt_bamboo_screen.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "screen" );
    set_short( "burnt bamboo screen" );
    add_adjective( ({ "burnt", "bamboo" }) );
    set_long( "This screen has been constructed by "
        "weaving hundreds of lashes of bamboo together to form a tight "
        "mesh that blocks out any chance of peeking through to see what's "
        "on the other side.  The bamboo, lovely in differing shades of "
        "tan through to chocolate brown, is supported by long poles which "
        "make up the frame and hinge the entire structure together.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(400000);
}

==================================================
FILE: furnitures/misc/calligraphy_fishbowl.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "fishbowl" );
    set_short( "calligraphised fishbowl" );
    add_adjective( ({ "calligraphised", "fish" }) );
    add_alias("bowl");
    add_plural( ({ "bowls", "fishbowls" }) );
    set_long("Calligraphy is the soul of Agatean culture.  On this 16-inch "
        "fishbowl a Zing Dynasty poem is strikingly carved in "
        "and then gold leafed against an equally striking black background.  "
        "The black lacquer is hand-painted over porcelain to create a matte "
        "effect.  A matching solid wood stand holds the bowl's weight, "
        "and several goldfish swim quietly beneath the water it holds.\n" );
    set_weight( 110 );
    set_value( 48000 );
    set_allowed_positions(({"sitting"}));
    set_allowed_room_verbs(([ "sitting" : "sits",
                              "standing" : "stands",
                              "leaning" : "leans",
                              "lying" : "lies",
                              "squatting" : "squats" ]));
}

==================================================
FILE: furnitures/misc/cherryblossom_screen.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "screen" );
    set_short( "cherry blossom shoji screen" );
    add_adjective( ({ "cherry", "blossom", "shoji" }) );
    set_long( "A stunning cherry blossom tree adorns the "
        "silk panelling of this double-sided shoji "
        "screen.  Four panels with black wooden trim fold "
        "out to make this screen stand tall, its blossoms "
        "painted on with the most precise hand, the thickness "
        "of the paint still showing on the silk panels.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(20);
    set_value(400000);
}

==================================================
FILE: furnitures/misc/crackled_fishbowl.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "fishbowl" );
    set_short( "fishbowl with crackled blue enamel" );
    add_adjective( ({ "with", "crackled", "blue", "enamel" }) );
    add_alias("bowl");
    add_plural( ({ "bowls", "fishbowls" }) );
    set_main_plural("fishbowls with cracked blue enamel");
    set_long("Peace and serenity, the foundation for a good life considered "
        "in Agatean philosophy, are reflected in this 16-inch blue and "
        "white porcelain fishbowl.  A special pottery heating technique is "
        "applied in this product.  Looking closely one can see the small "
        "crackles throughout the entire fishbowl, which is more interesting "
        "to the eye than just a plain surface.  The interior is an "
        "underwater scene of gold fish swimming in circular along the edge "
        "of the bowl.  Resting on a beautiful hand-polished cherry wood "
        "base, the shapes of several goldfish can be seen swishing back and "
        "forth beneath the water it holds.\n" );
    set_weight( 120 );
    set_value( 46000 );
    set_allowed_positions(({"sitting"}));
    set_allowed_room_verbs(([ "sitting" : "sits",
                              "standing" : "stands",
                              "leaning" : "leans",
                              "lying" : "lies",
                              "squatting" : "squats" ]));
}

==================================================
FILE: furnitures/misc/crane_umbrella_stand.c
==================================================

inherit "/std/room/furniture/storage";
void setup() {
    set_name("stand");
    set_short("lacquered umbrella stand");
    add_adjective( ({ "lacquered", "umbrella" }) );
    set_long("This is a conical umbrella stand that raises in an eight-sided "
        "cylinder.  Often placed by front doors to house the clothing "
        "accessories that are most-loathed, this particular stand is "
        "especially peculiar and eye-catching.  Lacquered with several "
        "shades of beige, green, and brown enamel, its faces boast an "
        "elegant crane taking off from a marshy landscape.\n");
    set_open();
    set_stuck(1);
    set_weight(90);
    set_max_weight(55);
    set_value(40000);
    set_allowed_room_verbs( ([ "squatting" : "squats",
                               "resting" : "rests",
                               "sitting" : "sits",
                               "standing" : "stands" ]) );
}

==================================================
FILE: furnitures/misc/dragon_umbrella_stand.c
==================================================

inherit "/std/room/furniture/storage";
void setup() {
    set_name("stand");
    set_short("enamelled umbrella stand");
    add_adjective( ({ "enamelled", "umbrella" }) );
    set_long("To keep the floors clean on rainy days, this hexagonal "
        "decorative umbrella stand suits that purpose perfectly.  A "
        "tin liner sits inside its base to catch inevitable drips and to "
        "protect its wood.  Handpainted with in blacks, golds and reds with "
        "a ferocious looking dragon design, it boasts a brass handle on "
        "each side for ease of lifting.\n");
    add_read_mess("\nMade in Sum Dim.", "tiny golden lettering around the "
        "base", "agatean");
    set_open();
    set_stuck(1);
    set_weight(90);
    set_max_weight(55);
    set_value(44000);
    set_allowed_room_verbs( ([ "squatting" : "squats",
                               "resting" : "rests",
                               "sitting" : "sits",
                               "standing" : "stands" ]) );
}

==================================================
FILE: furnitures/misc/fine_fireplace.c
==================================================

inherit "/std/room/furniture/fireplace";
void setup(){
  set_allowed_positions(({"sitting"}));
  set_allowed_room_verbs((["sitting" : "sits" ]));
  set_weight(700);
  set_max_weight(100);
  set_short("finely crafted fireplace");
  set_long("This fireplace is surrounded by an ornately carved mahogany "
     "framework and has a beautifully finished brass hearth.\n");
  set_value(900000);
}

==================================================
FILE: furnitures/misc/flint.c
==================================================

inherit "/std/object";
void setup(){
  set_name("flint");
  set_short("flint stone");
  set_long("This is a flint stone.  It looks slightly worn and chipped "
    "but it's still keen enough to serve its purpose.\n");
  add_property("no recycling", 1);
  add_alias("stone");
  set_value( 600 );
}

==================================================
FILE: furnitures/misc/garden_fishbowl.c
==================================================

inherit "/std/room/furniture/basic";
void setup(){
    set_name( "fishbowl" );
    set_short( "gold-leafed garden fishbowl" );
    add_adjective( ({ "gold", "leafed", "leaf", "gold-leaf", "gold-leafed",
        "garden" }) );
    add_alias("bowl");
    add_plural( ({ "bowls", "fishbowls" }) );
    set_long("Reading a story that is visualized on an art object is a "
        "particular kind of enjoyment.  A scene from the Agatean classic, "
        "'The Dream of Red Chamber' is hand-painted on this sixteen-inch "
        "fishbowl, in which the heroine expresses forbidden love in her "
        "poetry.  In this scene one also has a glimpse of traditional "
        "Agatean house garden.  The colorful scenery is painted over "
        "multi-layered gold leaf which has been carefully applied by hand.  "
        "Resting on a beautiful hand-polished rosewood base, "
        "the shapes of several goldfish can be seen swishing back and "
        "forth beneath the water it holds.\n" );
    set_weight( 110 );
    set_value( 52000 );
    set_allowed_positions(({"sitting"}));
    set_allowed_room_verbs(([ "sitting" : "sits",
                              "standing" : "stands",
                              "leaning" : "leans",
                              "lying" : "lies",
                              "squatting" : "squats" ]));
}

==================================================
FILE: furnitures/misc/geisha_screen.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "screen" );
    set_short( "rice paper geisha screen" );
    add_adjective( ({ "rice", "paper", "geisha" }) );
    set_long("This is a simple screen that would fit in most traditional "
        "homes.  Quiet geishas relax on "
        "its rice paper panelling, hand-drawn on a bamboo balcony, "
        "they sit and sip tea in peace and solitude or play mandolin-like "
        "instruments which sit silently in their laps.  The frame is made "
        "of a strange combination of walnut and spruce woods, their "
        "differing colours blending well with the shades of the panels.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(320000);
}

==================================================
FILE: furnitures/misc/hatstand.c
==================================================

inherit "/std/room/furniture/surface";
void setup(){
  set_name("stand");
  set_short("tall hat stand");
  add_adjective( ({"tall", "hat"}) );
  add_alias( "hatstand" );
  add_plural("tall hat stands");
  set_long("This is a tall, serious looking hatstand.  It is made of "
    "dark sturdy teak wood and stands proud on four lavishly decorated "
    "legs.  The top has been carved into the grand shape of A'Tuin, "
    "upon which the elephants and the Disc have been elaborately "
    "sculpted, capturing the true beauty of the scene.  The turtle's "
    "flippers extend outwards and are where the coats and hats "
    "are hung.\n");
  set_weight(150);
  set_max_weight(200);
  set_allowed_room_verbs((["standing" : "stands",
                           "looming"  : "looms"  ]));
	set_put_aliases(({"hang"}));
  set_value(75000);
}

==================================================
FILE: furnitures/misc/huge_gong.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name("gong");
    set_short("huge brass gong");
    add_adjective( ({ "huge", "brass" }) );
    set_long("This is a huge brass gong, which hangs from an equally "
        "huge frame.  Prancing peacocks strut around each other on the "
        "surface of the disc, ruffling their tails as they "
        "stretch.  The gong can be hit to make a loud ringing "
        "sound and annoy everyone in the room.\n");
    set_weight( 100 );
    set_value( 42000 );
    set_material( "brass" );
    set_allowed_positions( ({"hanging"}) );
    set_allowed_room_verbs((["hanging" : "hangs",
                             "sitting" : "sits",
                             "dangling" : "dangles",
                             "standing" : "stands" ]));
}
void init() {
    this_player()->add_command( "hit", this_object(), "<direct:object:me>" );
}
int do_hit(){
    this_player()->add_succeeded_mess(this_object(), "$N $V $p "
        +this_object()->short()+" loudly, filling the room with a "
        "deafening crashing ring which reverberates for a few "
        "moments before finally fading away.\n", ({ }));    return 1;
}

==================================================
FILE: furnitures/misc/hunghungese_screen.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "screen" );
    set_short( "HungHungese screen" );
    add_adjective( ({ "hunghungese", "HungHungese", "hunghung",
        "HungHung" }) );
    set_long( "This is a contemporary double-sided screen for the home.  "
        "Framed in a light spruce, the panels of the screen have been "
        "included in the main construction of the frame and form a "
        "checkerboard pattern across its length.  Inside the "
        "checkerboard are long panels of cotton that have depictions "
        "of life in a hectic HungHung market.  There are several "
        "ducks, a few sheep, some dried fish and a lot of people "
        "that look like they are shouting at one another.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(325000);
}

==================================================
FILE: furnitures/misc/iron_hatstand.c
==================================================

inherit "/std/room/furniture/surface";
void setup(){
  set_name( "stand" );
  set_short( "wrought iron hat stand" );
  add_adjective( ({ "wrought", "iron", "hat" }) );
  add_alias( ({ "hatstand", "rack", "hat rack", "hatrack" }) );
  add_plural( "wrought iron hat stands" );
  set_long("This is a solid hat stand made of gracefully designed "
    "wrought iron.  It rests on four clawed feet, while the base "
    "of the stand wraps around itself in a spiral.  There are "
    "plenty of hooks at the top.\n");
  set_weight(250);
  set_max_weight(200);
  set_allowed_room_verbs(([ "standing" : "stands" ]));
	set_put_aliases( ({ "hang" }) );
  set_value(9000);
}

==================================================
FILE: furnitures/misc/landscape_screen.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "screen" );
    set_short( "watercolour landscape screen" );
    add_adjective( ({ "watercolour", "landscape" }) );
    set_long( "This beautiful screen has a lovely honey rosewood frame that "
        "pales in comparison to the panelling it holds.  Three rice "
        "paper panels sit in the hinged frame, each one handpainted in "
        "watercolours and depicting "
        "one third of a Agatean mountain landscape.  The frame is "
        "double-hinged so it can bend both backwards and forward to suit "
        "its placement, and the rice paper panelling has been ribbed with "
        "matchstick-like strings of wood to give it more support. \n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(400000);
}

==================================================
FILE: furnitures/misc/large_gong.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name("gong");
    set_short("large brass gong");
    add_adjective( ({ "large", "brass" }) );
    set_long("This is a large brass gong, which hangs from an equally "
        "large frame.  Tiny dragons writhe around each other on the "
        "surface of the disc, nipping each others' tails as they "
        "stretch.  The gong can be hit to make a loud ringing "
        "sound and annoy everyone in the room.\n");
    set_weight( 80 );
    set_value( 38000 );
    set_material( "brass" );
    set_allowed_positions( ({"hanging"}) );
    set_allowed_room_verbs((["hanging" : "hangs",
                             "sitting" : "sits",
                             "dangling" : "dangles",
                             "standing" : "stands" ]));
}
void init() {
    this_player()->add_command( "hit", this_object(), "<direct:object:me>" );
}
int do_hit(){
    this_player()->add_succeeded_mess(this_object(), "$N $V $p "
        +this_object()->short()+" loudly, filling the room with a "
        "loud crashing ring.\n", ({ }));    return 1;
}

==================================================
FILE: furnitures/misc/latticed_screen.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "screen" );
    set_short( "latticed shoji screen" );
    add_adjective( ({ "latticed", "shoji" }) );
    set_long( "This double-sided shoji screen has a latticed "
        "wood pattern made of ramin hardwood.  A lovely honey "
        "oak colour, the panelling is broken up by rice paper "
        "dividers which checker the screen from the top all "
        "the way down to the solid kick panel which runs along "
        "the bottom.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(20);
    set_value(400000);
}

==================================================
FILE: furnitures/misc/lava_lamp.c
==================================================

#define CREATOR "Rue"
inherit "/std/room/furniture/basic";
#define MEDITATION "/std/effects/other/meditate_effect"
void setup() {
    set_name("lamp");
    set_short("lava lamp");
    set_light(25);
    add_adjective( ({ "lava", "red" }) );
    add_alias( ({ "lamp" }) );
    set_long( "This is an odd looking lamp, roughly the shape of an "
        "hourglass, with a brass base.  It is filled with murky pink "
        "liquid and large blobs of red goo that ooze this way and that.  "
        "The exact nature of the red goo is a mystery.  Some say it is "
        "a primitive type of troll that is still in its magma stage.  "
        "Others reckon it is something that got away from the Alchemists' "
        "Guild.  It gives off a faint light.\n" );
    item_chat( ({ 120, 360, ({
        "A rather disgusting wet popping noise comes from the lava lamp.",
        "A strange sucking noise seems to be coming from the lava lamp."
    }) }) );
    set_allowed_positions(({"sitting","standing"}));
    set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
    set_weight(82);
    set_value(20500);
}
void init() {
    ::init();
    add_command( "stare", "at <direct:object'lamp'>" );
}
int do_stare() {
    call_out( (: $(this_player())->add_effect( MEDITATION ) :), 1 );
    add_succeeded_mess( "$N $V dreamily at $D and zone$s out.\n");
    return 1;
}

==================================================
FILE: furnitures/misc/lectern.c
==================================================

inherit "/std/room/furniture/surface";
void setup() {
  set_name("lectern");
  set_short("oak lectern");
  add_adjective(({"oak", "ornate"}));
  set_long("The lectern has a heavy wooden base carved with"
					 " twining leaves and a flat top perfect for a book.\n");
  set_allowed_positions(({"sitting"}));
  set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
  set_weight(350);
  set_max_weight(50);
  set_value(1400);
}

==================================================
FILE: furnitures/misc/log.c
==================================================

#define WEIGHT 25
inherit "/std/room/furniture/fuel_inherit";
void setup(){
  set_name("log");
  set_shorts( ({ "small log",
                 "slightly burnt log",
                 "blackened log",
                 "black, charred log" }) );
  set_longs( ({
    "This is a small dumpy log.  It looks as though it would burn well.\n",
    "This is a small dumpy log.  It has been charred around the edges "
      "but would still burn for a while yet.\n",
    "This is a black lump of charred wood, which is just about holding "
      "its shape together as a log.\n" }) );
  set_weight( WEIGHT );
  set_value( 400 );
}

==================================================
FILE: furnitures/misc/mado_screen.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "screen" );
    set_short( "mado screen" );
    add_adjective( "mado" );
    set_long( "This traditional mado screen has a double-sided "
        "latticework frame made of lacquered red cedar.  Between "
        "the two sides of the frame lies a large sheet of smooth "
        "white rice paper that looks quite delicate and "
        "fragile.  \n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(350000);
}

==================================================
FILE: furnitures/misc/mandarin_fan_screen.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "screen" );
    set_short( "mandarin fan screen" );
    add_adjective( ({ "mandarin", "fan", "hana" }) );
    set_long( "This beautiful screen has a lovely walnut oak frame which "
        "pales in comparison to the panelling it holds.  Three smooth silk "
        "panels, each divided into eighteen square segments, sit "
        "in the hinged frame, each one handpainted in brilliant mandarin, "
        "lilac, cream and peridot watercolours with a mandarin orange "
        "hana fan design.  The frame is double-hinged so it can bend both "
        "backwards and forward to suit its placement.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(395000);
}

==================================================
FILE: furnitures/misc/muslin_screen.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "screen" );
    set_short( "muslin screen" );
    add_adjective( "muslin" );
    set_long( "This is a simple and traditional double-hinged "
        "screen, its panels filled in with a long sheet of roughly "
        "textured cream-coloured muslin fabric.  A lightly coloured "
        "construction, the material has been gathered at the top "
        "and bottom ends to produce a eye-pleasing loosely pleated "
        "effect which continues down its length.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(225000);
}

==================================================
FILE: furnitures/misc/newspaper_box.c
==================================================

inherit "/std/room/furniture/storage";
#include <room/newspaper.h>
#include <move_failures.h>
#include <housing.h>
#include <player_handler.h>
void check_for_new_papers();
void set_paper( string _paper );
void set_issues_left( int _issues );
void set_international( int value );
void set_last_issue( int _issue );
mapping query_dynamic_auto_load();
varargs void init_dynamic_arg( mapping map, object thing );
int query_last_issue();
int query_international();
int query_issues_left();
string query_paper();
private string _paper = "a given newspaper";
private int _last_issue = 0;
private int _issues_left = 1;
private int _international = 0;
void setup() {
   set_name( "box" );
   set_short( "newspaper box" );
   add_adjective( "newspaper" );
   set_long( "It's a large box impregnated with an oil designed to attract "
             "delivery-imps.\n" );
   set_allowed_positions( ({ "hanging", "standing" }) );
   set_allowed_room_verbs( ([ "standing": "stands", "hanging": "hangs" ]) );
   add_extra_look( this_object() );
   set_weight( 100 );
   set_max_weight( 300 );
   set_value( 10000 );
   set_open();
   set_stuck( 1 );
   call_out( "check_for_new_papers", 5 );
}
string extra_look() {
   if( !_paper || _paper == "a given newspaper" ) {
      return "The variables of this newspaper box are broken.  Please ask a "
             "creator to re-set them.\n";
   };
   return "This particular one works for " + _paper + ".\n";
}
void check_for_new_papers() {
   object newspaper;
   object room = environment( this_object() );
   int i, x, latest_issue;
   int* editions_bought;
   string name;
   if( !is_placed() && _issues_left > 0 ) {
      call_out( "check_for_new_papers", 3600 );
      return;
   };
   if( ( _international == 0 &&
         member_array( _paper, NEWSPAPER_HANDLER->query_papers_in_area(
           HOUSING->query_region( file_name( room ) ) ) ) != -1 ) ||
       ( _international == 1 &&
         member_array( _paper, NEWSPAPER_HANDLER->query_all_papers() ) != -1 ) ){
      latest_issue = NEWSPAPER_HANDLER->query_last_edition_num( _paper );
      name = environment( this_object() )->query_owner();
      if( latest_issue > _last_issue ) {
         tell_room( room,
                    "A " + ({"red", "green", "purple", "blue", "yellow",
                             "drunk", "smelly", "large", "tiny"})[random(9)] +
                    " imp rushes in with some newpapers in its hands and "
                      "disappears in the box.\n" );
         x = latest_issue - _last_issue;
         for( i = 0; i < x; i++ ) {
            newspaper = clone_object( NEWSPAPER_OB );
            newspaper->set_paper( _paper );
            newspaper->set_edition( _last_issue + 1 );
            if( !newspaper->move( this_object() ) == MOVE_OK ) {
               tell_room( room,
                          "Something in the box curses and a newspaper is "
                          "thrown to the floor from inside it.\n" );
               newspaper->move( room );
            };
            _last_issue++;
            _issues_left--;
            editions_bought = PLAYER_HANDLER->test_property( name, "Paper " +
                                                              _paper );
            if( !editions_bought ) {
               editions_bought = ({ });
            };
            if( member_array( _last_issue + 1, editions_bought ) == -1 ) {
               editions_bought += ({ _last_issue });
               PLAYER_HANDLER->special_add_property( name,
                 "Paper " + _paper, editions_bought );
               NEWSPAPER_HANDLER->add_edition_paper_sold( _paper,
                  _last_issue + 1,
                  NEWSPAPER_HANDLER->query_paper_cost( _paper ) );
            } else {
               NEWSPAPER_HANDLER->add_edition_revenue( _paper, _last_issue + 1,
                  NEWSPAPER_HANDLER->query_paper_cost( _paper ) );
            };
            tell_room( room,
                       "You hear some " + ({"giggling", "ranting", "quacking",
                                            "thumping", "cursing", "swearing",
                                            "snickering"})[random(7)] +
                       " emerging, the imp jumps out and runs off again.\n" );
         };
      };
   };
   if( _issues_left == 0 ) {
      set_long( query_long() +
                "It appears the imp-bait is no longer working.\n" );
   } else {
      call_out( "check_for_new_papers", 3600 );
   };
}
void set_paper( string new_paper ) {
   _paper = new_paper;
}
void set_issues_left( int _issues ) {
   _issues_left = _issues;
}
void set_last_issue( int _issue ) {
   _last_issue = _issue;
}
mapping query_dynamic_auto_load() {
   return ([
            "::": ::query_dynamic_auto_load(),
            "_paper": _paper,
            "_issues_left": _issues_left,
            "_last_issue": _last_issue,
            "_international": _international
        ]);
}
varargs void init_dynamic_arg( mapping map, object thing ) {
   if( map[ "::" ] && thing ) {
      ::init_dynamic_arg( map[ "::" ], thing );
   } else if( map[ "::" ] ) {
      ::init_dynamic_arg( map[ "::" ] );
   };
   if( map[ "_paper" ] ) {
      set_paper( map[ "_paper" ] );
   };
   if( map[ "_issues_left" ] ) {
      set_issues_left( map[ "_issues_left" ] );
   };
      if( map[ "_last_issue" ] ) {
      set_last_issue( map[ "_last_issue" ] );
   };
      if( map[ "_international" ] ) {
      set_international( map[ "_international" ] );
   };
}
int query_last_issue() {
   return _last_issue;
}
int query_issues_left() {
   return _issues_left;
}
int query_international() {
   return _international;
}
string query_paper() {
   return _paper;
}
void set_international( int i ) {
   _international = i;
}

==================================================
FILE: furnitures/misc/peony_fishbowl.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "fishbowl" );
    set_short( "gold-leafed peony fishbowl" );
    add_adjective( ({ "gold", "leafed", "leaf", "gold-leaf", "gold-leafed",
        "peony" }) );
    add_plural( ({ "bowls", "fishbowls" }) );
    add_alias("bowl");
    set_long( "Richly designed with blooming peonies, the flower that "
        "symbolizes peace and prosperity in Agatean culture, this grand "
        "16-inch fishbowl is carefully hand-layered with gold leaf over "
        "porcelain and hand-painted in exuberant colors.  This fishbowl "
        "matches any kind of foliage or simply stands alone as an art "
        "object.  Resting on a beautiful hand-polished rosewood base, "
        "the shapes of several goldfish can be seen swishing back and "
        "forth beneath the water it holds.\n" );
  set_weight( 110 );
  set_value( 51000 );
  set_allowed_positions(({"sitting"}));
  set_allowed_room_verbs((["sitting" : "sits",
                           "standing" : "stands",
                           "leaning" : "leans",
                           "lying" : "lies",
                           "squatting" : "squats" ]));
}

==================================================
FILE: furnitures/misc/platinum_gong.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name("gong");
    set_short("platinum gong");
    add_adjective( "platinum" );
    set_long("This is a smallish platinum gong, hanging from a platinum "
        "frame.  Leaping lions writhe around each other on the "
        "surface of the disc, showing their teeth as they "
        "run across the etchings.  The gong can be hit to make a "
        "loud ringing sound and annoy everyone in the room.\n");
    set_weight( 30 );
    set_value( 28000 );
    set_material( "platinum" );
    set_allowed_positions( ({"hanging"}) );
    set_allowed_room_verbs((["hanging" : "hangs",
                             "sitting" : "sits",
                             "dangling" : "dangles",
                             "standing" : "stands" ]));
}
void init() {
    this_player()->add_command( "hit", this_object(), "<direct:object:me>" );
}
int do_hit(){
    this_player()->add_succeeded_mess(this_object(), "$N $V $p "
        +this_object()->short()+" loudly, filling the room with a "
        "deafening ringing sound.\n", ({ }));
    return 1;
}

==================================================
FILE: furnitures/misc/samurai_screen.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "screen" );
    set_short( "rice paper samurai screen" );
    add_adjective( ({ "rice", "paper", "samurai" }) );
    set_long("This is a simple screen that would fit in most traditional "
        "homes.  A stoic samurai in full traditional Agatean armour and "
        "dress storms across the panelling, hand-drawn in shades of orange, "
        "blue, brown, cream and black.  The frame is made "
        "of a strange combination of walnut and spruce woods, their "
        "differing colours blending well with the shades of the panels.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(329000);
}

==================================================
FILE: furnitures/misc/satsuma_fishbowl.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "fishbowl" );
    set_short( "satsuma fishbowl" );
    add_adjective( ({ "satsuma" }) );
    add_alias("bowl");
    add_plural( ({ "bowls", "fishbowls" }) );
    set_long("Learning is regarded the highest virtue in Agatean "
        "culture.  The picture on this "
        "fishbowl depicts a group of scholars in a session of discussion.  "
        "This fishbowl is made of porcelain and hand-painted with dark-green "
        "lacquer.  On top of the lacquer gold threads are woven in "
        "decorative design.  One intriguing detail about this particular  "
        "fishbowl is that thousands of tiny dots are meticulously painted "
        "one by one over the entire 16-inch fishbowl.  The interior is an "
        "underwater scene of gold fish swimming in circular along the edge "
        "of the bowl.  Resting on a beautiful hand-polished mahogany base, "
        "the shapes of several goldfish can be seen swishing back and "
        "forth beneath the water it holds.\n" );
    set_weight( 110 );
    set_value( 56000 );
    set_allowed_positions(({"sitting"}));
    set_allowed_room_verbs(([ "sitting" : "sits",
                              "standing" : "stands",
                              "leaning" : "leans",
                              "lying" : "lies",
                              "squatting" : "squats" ]));
}

==================================================
FILE: furnitures/misc/silver_gong.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name("gong");
    set_short("silver gong");
    add_adjective( "silver" );
    set_long("This is a smallish silver gong, hanging from a silver "
        "frame.  Tiny goldfish swim around each other on the "
        "surface of the disc, nipping each others' tails as they "
        "go.  The gong can be hit to make a loud ringing "
        "sound and annoy everyone in the room.\n");
    set_weight( 40 );
    set_value( 22000 );
    set_material( "silver" );
    set_allowed_positions( ({"hanging"}) );
    set_allowed_room_verbs((["hanging" : "hangs",
                             "sitting" : "sits",
                             "dangling" : "dangles",
                             "standing" : "stands" ]));
}
void init() {
    this_player()->add_command( "hit", this_object(), "<direct:object:me>" );
}
int do_hit(){
    this_player()->add_succeeded_mess(this_object(), "$N $V $p "
        +this_object()->short()+" loudly, filling the room with a "
        "deafening ringing sound.\n", ({ }));
    return 1;
}

==================================================
FILE: furnitures/misc/small_stove.c
==================================================

inherit "/std/room/furniture/surface";
void setup() {
  set_name("stove");
  set_short("small stove");
  add_adjective("small");
  set_long("This is a small stove.\n");
  set_allowed_room_verbs(([
    "sitting" : "sits",
    "squatting" : "squats",
  ]));
  set_weight(495);
  set_max_weight(45);
  set_value(8000);
}

==================================================
FILE: furnitures/misc/spruce_screen.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "screen" );
    set_short( "double cross spruce screen" );
    add_adjective( ({ "double", "cross", "spruce" }) );
    set_long( "This double-sided screen has been constructed by "
        "lashing pairs of long spruce strips together so that "
        "three distinct interconnected panels are hinged "
        "together when it is standing.  The frame, decorated with "
        "criss-crossed pairs of spruce poles, is covered by a "
        "thin layer of rice paper that breaks up light and "
        "sheds a warm glow on a room when a lamp is placed behind it.\n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(400000);
}

==================================================
FILE: furnitures/misc/sung_umbrella_stand.c
==================================================

inherit "/std/room/furniture/storage";
void setup() {
    set_name("stand");
    set_short("Sung umbrella stand");
    add_adjective( ({ "Sung", "umbrella" }) );
    set_long("This is a conical umbrella stand that raises itself up in an "
        "smooth-sided cylinder.  Often placed by front doors to house the "
        "clothing accessories that are most-loathed, this particular "
        "stand has been lacquered with several shades of gold, red, blue, "
        "green and cream and depicts the Sung Estate as it is seen from the "
        "banks of the Pearl River in the Sum Bing district of Bes Pelargic.  "
        "Several white ceramic lions border the estate, guarding it and "
        "bestowing several thousand years of good luck upon its "
        "inhabitants.\n");
    set_open();
    set_stuck(1);
    set_weight(90);
    set_max_weight(55);
    set_value(51000);
    set_allowed_room_verbs( ([ "squatting" : "squats",
                               "resting" : "rests",
                               "sitting" : "sits",
                               "standing" : "stands" ]) );
}

==================================================
FILE: furnitures/misc/textured_leaf_screen.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name( "screen" );
    set_short( "textured leaf screen" );
    add_adjective( ({ "textured", "leaf" }) );
    set_long( "This beautiful screen has a lovely honey oak frame which "
        "pales in comparison to the panelling it holds.  Three textured rice "
        "paper panels, each divided into six vertical segments, sit "
        "in the hinged frame, each one handpainted in "
        "watercolours with a tan leaf design.  The frame is "
        "double-hinged so it can bend both backwards and forward to suit "
        "its placement, and the rice paper panelling has been ribbed with "
        "matchstick-like strings of wood to give it more support. \n");
    set_allowed_positions( ({ "standing", "sitting" }) );
    set_allowed_room_verbs((["standing" : "stands", "sitting" : "sits" ]) );
    set_weight(150);
    set_value(290000);
}

==================================================
FILE: furnitures/misc/tiny_gong.c
==================================================

inherit "/std/room/furniture/basic";
void setup() {
    set_name("gong");
    set_short("tiny brass gong");
    add_adjective( ({ "tiny", "brass" }) );
    set_long("This is a tiny brass gong, which hangs from an equally "
        "tiny frame.  Fluttering butterflies flit around each other on the "
        "disc, flying aimlessly across its smooth "
        "surface.  The gong can be hit to make a loud ringing "
        "sound and annoy everyone in the room.\n");
    set_weight( 20 );
    set_value( 15000 );
    set_material( "brass" );
    set_allowed_positions( ({"hanging"}) );
    set_allowed_room_verbs((["hanging" : "hangs",
                             "sitting" : "sits",
                             "dangling" : "dangles",
                             "standing" : "stands" ]));
}
void init() {
    this_player()->add_command( "hit", this_object(), "<direct:object:me>" );
}
int do_hit(){
    this_player()->add_succeeded_mess(this_object(), "$N $V $p "
        +this_object()->short()+" loudly, filling the room with a"
        " tiny tinkling chime.\n", ({ }));
    return 1;
}

==================================================
FILE: furnitures/misc/waterbuffalo_dung.c
==================================================

inherit "/std/room/furniture/fuel_inherit";
void setup() {
  set_name("dung");
  set_shorts( ({ "small lump of dried waterbuffalo dung",
                 "slightly burnt lump of waterbuffalo dung",
                 "blackened lump of waterbuffalo dung",
                 "black, charred lump of dung" }) );
  set_longs( ({
    "This is a small lump of dried waterbuffalo dung.  It looks as "
        "though it would burn well.\n",
    "This is a small lump of dried waterbuffalo dung.  It has been "
        "charred around the edges but would still burn for a while yet.\n",
    "This is a black lump of charred dung, which is barely able to still "
        "hold itself together.\n" }) );
  set_weight( 9 );
  set_value( 200 );
}

==================================================
FILE: furnitures/lamps/teahouse_stone_lamp.c
==================================================

inherit "/std/room/furniture/basic";
#define BRIGHTNESS      60
#define FUEL_PER_TICK  FUEL_TIME
int     fuel_left;
int     is_lit;
int     has_tealight;
mapping vars = (["is lit": 0, "fuel left": 20, "has tealight" : 1 ]);
void    dest_me();
int     do_dowse();
int     do_extinguish();
int     do_light();
void    init();
void    init_arg( mixed arg );
void    out_of_fuel();
string  pretty_plural(string str);
mixed   query_auto_load();
void    setup();
string  short( int i );
int     do_replace();
void setup() {
    fuel_left = 3600;
    is_lit    = 0;
    has_tealight = 0;
    set_name("lamp");
    set_short("stone teahouse lamp");
    set_weight( 40 );
    set_value( 50000 );
    add_adjective( ({ "stone", "teahouse" }) );
    add_alias( ({ "teahouse lamp", "stone lamp" }) );
    set_long( function() {
    string str;
    str = "Shaped like an Agatean teahouse, this lantern creates "
        "a peaceful ambiance of Auriental tradition in your home as "
        "it casts a beautiful soft glow through its calligraphed rice "
        "paper windows.  Exquisitely handcrafted in the shape of an "
        "Agatean teahouse, the front door of the lantern swings open "
        "to reveal the tealight inside.  ";
        if(has_tealight && is_lit) {
            fuel_left = find_call_out("out_of_fuel");
            return str + "The tealight is burning with a steady yellow "
                "light.";
        }
        if(has_tealight) {
            return str + "An unlit tealight is sitting in the base.";
        }
        if(!fuel_left) {
            return str + "The tealight has burned itself out.";
        }
        else {
            return str + "There is no tealight in the lamp.";
        }
    } );
    set_allowed_positions(({"sitting","standing"}));
    set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
    set_weight(9);
    set_value(20500);
    init_dynamic_arg( query_dynamic_auto_load() );
}
void init() {
    add_command("replace", "tealight in <direct:object:me>");
    this_player()->add_command("light", this_object());
    this_player()->add_command("extinguish", this_object());
}
void dest_me() {
    set_light( 0 );
    ::dest_me();
}
int do_extinguish() {
    if ( !has_tealight ) {
        this_player()->add_failed_mess( this_object(), "There is no "
            "tealight in $D\n", ({ }) );
        return 0;
    }
    if ( !is_lit ) {
        this_player()->add_failed_mess( this_object(), "$D is not "
        "lit.\n", ({ }));
        return 0;
    }
    this_player()->add_succeeded_mess( this_object(), "$N $V the "
        "remnants of the tealight in the $De.\n");
    fuel_left = remove_call_out( "out_of_fuel" );
    is_lit = 0;
    has_tealight = 1;
    set_light( 0 );
    return 1;
}
int do_light() {
    if ( is_lit ) {
        this_player()->add_failed_mess( this_object(), "$D is already "
            "lit.\n", ({ }) );
        return 0;
    }
    if( !has_tealight && fuel_left <= 0 ) {
        return this_player()->add_failed_mess( this_object(), "The "
            "tealight has burned itself out and needs to be replaced.\n",
            ({ }) );
        return 0;
    }
    if( !has_tealight ) {
        this_player()->add_failed_mess( this_object(), "There is no tealight "
            "in $D.\n", ({ }) );
        return 0;
    }
    call_out( "out_of_fuel" , fuel_left );
    is_lit = 1;
    has_tealight = 1;
    set_light( BRIGHTNESS );
    return 1;
}
int do_replace() {
    int i;
    object *things;
    things = all_inventory( this_player() );
    for( i = 0; i < sizeof( things ); i++ ){
        if( !has_tealight && things[ i ]->query_name() == "tealight" ) {
            fuel_left = 3600;
            is_lit = 0;
            has_tealight = 1;
            destruct( things[ i ] );
            this_player()->add_succeeded_mess( this_object(), "$N $V the "
                "tealight in the $D.\n", ({ }) );
            return 1;
        }
        if( has_tealight && things [ i ]->query_name() == "tealight" ) {
            return this_player()->add_failed_mess( this_object(), "There is "
                "already a tealight in $D.\n", ({ }) );
            return 1;
        }
    }
    return notify_fail( "You do not have a tealight to put in the lamp.\n" );
}
mapping query_dynamic_auto_load() {
    return ([ "::" : ::query_dynamic_auto_load(),
            "fuel left" : fuel_left,
            "is lit" : is_lit,
            "has tealight" : has_tealight
        ]);
}
void init_dynamic_arg(mapping arg) {
    if (arg["::"]) ::init_dynamic_arg(arg["::"]);
    if (arg["fuel left"]) {
        fuel_left = arg["fuel left"];
    }
    else {
        fuel_left = 0;
    }
    if (arg["is lit"]) {
        call_out("out_of_fuel", fuel_left);
        is_lit = 1;
        set_light(BRIGHTNESS);
    }
    if (arg["has tealight"]) {
        has_tealight = 1;
        set_light(0);
    }
    else {
        has_tealight = 0;
        is_lit = 0;
    }
}
void out_of_fuel() {
    object env;
    env = environment(this_object());
    is_lit = 0;
    has_tealight = 0;
    fuel_left = 0;
    set_light( 45 );
    tell_room(env, "The tealight in the lamp burns out.\n" );
}
string pretty_plural(object str) {
    if ( is_lit )
        return ::pretty_plural( str) + " (lit)";
    return ::pretty_plural( str);
}
string short( int i ) {
    if ( is_lit )
        return ::short( 0 ) + " (lit)";
    return ::short( 0 );
}

==================================================
FILE: furnitures/clocks/owl_clock.c
==================================================

inherit "/std/room/furniture/clock";
void setup() {
  set_name("clock");
  set_short("owl clock");
  add_adjective("owl");
  set_long("This is a wooden clock carved roughly into the shape of an owl.  "
    "The tail twitches back and forth, somewhat like a pendulum, and the owl's "
    "eyes roll cheerfully left and right with each tick of the clock.  A small "
    "set of tiles, strung on a metal rod and affixed to the owl's feet, tells "
    "the date.\n"+
    "According to the clock it is ");
  set_allowed_positions(({}));
  set_allowed_room_verbs((["hanging" : "hangs" ]));
  set_weight(50);
  set_value(42000);
  add_property("no recycling", 1);
  set_chimes(2, "The owl clock opens its beak and hoots twice.\n");
  set_chimes(1, "The owl clock opens its beak and hoots once.\n");
  set_show_date();
}
void chime(string mess) {
  int *co_ords;
  if(environment(this_object())) {
    co_ords = (int *)environment(this_object())->query_co_ord();
    "/obj/handlers/broadcaster"->broadcast_event(users(), co_ords,
                                                 mess, 20, 1, 0 );
    tell_room(environment(this_object()), mess);
  }
}

==================================================
FILE: furnitures/bathroom/bath.c
==================================================

inherit "/std/room/furniture/bath";
void setup() {
  set_name("bathtub");
  set_short("cast iron bathtub");
  add_adjective(({"cast", "iron"}));
  add_alias( ({ "tub", "bath" }) );
  set_long("The white porcelain sparkles on this cast iron bathtub, it looks "
           "heavy but large enough for a couple of people to have a nice "
           "bath in.\n");
  set_allowed_positions( ({"sitting", "standing", "lying" }) );
  set_allowed_room_verbs((["sitting" : "sits", "standing" : "stands" ]));
  set_weight(350);
  set_value(14000);
}

==================================================
FILE: furnitures/sofas/red_futon.c
==================================================

inherit "/std/room/furniture/basic";
int folded;
int do_unfold(object ob);
int do_fold(object ob);
void setup() {
    folded = 0;
    set_name( "futon" );
    set_short( "traditional red futon" );
    add_adjective( ({ "traditional", "red" } ));
    add_alias( "couch" );
    add_alias( "sofa" );
    set_long( "This red mattressed futon is made of a pad of tufted "
        "cotton batting covered with red cotton cloth, set in a "
        "lacquered oaken frame.  The frame allows the futon to rest "
        "comfortably a few inches above the ground, its hard mattress "
        "a must for those craving a little punishment combined with "
        "a good night's sleep.  It looks comfortable and is the perfect "
        "thing to have if you are into the whole minimalistic trend "
        "for your home.\n");
    set_allowed_positions(({"sitting", "lying", "kneeling", "meditating"}));
    set_allowed_room_verbs((["sitting" : "sits" ]));
    set_weight(150);
    set_value(650000);
    add_extra_look( this_object() );
}
void init() {
    add_command("unfold", "<indirect:object'futon'>" );
    add_command("fold", "<indirect:object'futon'>" );
    ::init();
}
int do_unfold(object ob) {
    if(folded ) {
        add_failed_mess("$D is already folded.\n", ({ }) );
        return 0;
    }
    add_succeeded_mess("$N $V $D back into a sofa.\n", ({ }) );
    folded = 1;
    return 1;
}
int do_fold(object ob) {
    if(!folded) {
        add_failed_mess("$D is already folded.\n", ({ }) );
	    return 0;
    }
    add_succeeded_mess("$N $V $D out into a bed.\n", ({ }) );
    folded = 0;
    return 1;
}
string extra_look() {
    if(!folded) {
        return "The futon has been folded out into a bed.\n";
    }
    return "The futon is folded into a sofa.\n";
}

==================================================
FILE: furnitures/beds/foot_bed.c
==================================================

#include <forn.h>
inherit "/std/room/furniture/basic";
void setup(){
  set_name("bed");
  set_short ("duck-footed bed");
  add_alias ("duck-footed");
  set_long(
    "A fairly solid timber bed, with intricate scrollwork around the "
    "headboard.  It is supported by four duck's feet, presumably made from "
    "painted wood.  The dark wood that form its sides is inset with short "
    "strips made from a lighter wood, creating an interestingly random "
    "pattern.\n");
  set_weight( 800 );
  set_value( 100000 );
  set_allowed_positions(({"sitting", "meditating", "lying", "standing",
                          "kneeling", "crouching"}));
  set_allowed_room_verbs((["sitting" : "sits" ]));
}

==================================================
FILE: furnitures/stoves/large_wood_stove.c
==================================================

inherit "/std/room/furniture/fireplace";
void setup() {
    set_name("oven");
    set_short("large wood oven");
    add_adjective( ({ "large", "wood" }) );
    set_long("A tastefully decorated door bears the name 'Wun Chi Puffin' "
        "and a temperature gauge monitors the large wood oven.  "
        "Resting on a smooth base, this range has a thirty-two inch cook "
        "surface and carries six burners and a water reservoir.  A top "
        "mounted nickel trimmed shelf on the back of the stove is "
        "complemented by dual warming shelves.  Subtle and sophisticated, "
        "this stovetop would compliment most tasteful homes.\n");
    set_allowed_room_verbs(([
                            "sitting" : "sits",
                            "squatting" : "squats",
                            "crouching" : "crouches",
                            "resting" : "rests",
                            "lying" : "lies"
                          ]));
    set_weight(495);
    set_max_weight(100);
    set_value(120000);
}

==================================================
FILE: furnitures/wardrobes/golden_ebony_wardrobe.c
==================================================

inherit "/std/room/furniture/storage";
void setup() {
    set_name("wardrobe");
    set_short("golden ebony wood wardrobe");
    add_adjective(({"golden", "ebony", "wood"}));
    set_long("Tall and imposing this wardrobe looms towards the ceiling.  "
        "The crafter obviously gave a great deal of thought to its "
        "construction in selecting different woods to present constrasts "
        "and blends.  The darkest of ebony seems to swallow the light "
        "highlighting minature scrollwork picked out in gold across its "
        "surface, giving way to dusky madrona the spirals and knots give "
        "the impression of smoke curling slowly around the borders of "
        "the doors and around the brass handles.\n");
    set_weight(900);
    set_max_weight(500);
    set_value(740000);
    set_allowed_room_verbs((["squatting" : "squats" ]));
    set_pick_skill("covert.lockpick.doors");
    set_difficulty(4);
}
void init() {
    string key_id;
    object key;
    if(!query_key()) {
        key_id = "furniture_lock_"+random(1000);
        set_key(key_id);
        key = clone_object("/std/key");
        key->set_key("small iron", key_id);
        key->set_long("This small, yet sturdy, key looks like it is for a "
                  "piece of furniture.\n");
        key->move(this_object());
        set_closed();
    }
    ::init();
}

==================================================
FILE: weapons/knives/.black_handled_ceremonial_bronze_knife.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/black_handled_ceremonial_bronze_knife.wep#1" );
  call_other( clone, "set_name", "knife"  );
  call_other( clone, "set_short", "black handled ceremonial bronze knife"  );
  call_other( clone, "add_adjective", ({ "black", "handled", "ceremonial", "bronze" })  );
  call_other( clone, "set_main_plural", "black handled ceremonial bronze knives"  );
  call_other( clone, "add_plural", "knives"  );
  call_other( clone, "set_long", "This is a ceremonial knife, for use in magic rituals.  Its ornate handle is made of ebony and its long bronze blade has been carved with mystic runes.\n"  );
  call_other( clone, "set_weight", 11  );
  call_other( clone, "set_length", 13  );
  call_other( clone, "set_width", 4  );
  call_other( clone, "set_material", "copper"  );
  call_other( clone, "set_value", 1000  );
  call_other( clone, "new_weapon", 2000  );
  call_other( clone, "add_attack", "slash", 70, ({ 10, 2, 20 }), "sharp", "sharp", 0  );
  call_other( clone, "add_attack", "stab", 40, ({ 20, 2, 60 }), "pierce", "pierce", 0 );
   return clone;
}

==================================================
FILE: weapons/knives/.carving_knife.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/carving_knife.wep#1" );
  call_other( clone, "set_name", "knife"  );
  call_other( clone, "set_short", "carving knife"  );
  call_other( clone, "add_adjective", ({ "carving" })  );
  call_other( clone, "add_alias", "utensil"  );
  call_other( clone, "add_plural", "utensils"  );
  call_other( clone, "set_long", "This is a knife such as you might use to carve up your Octeday roast, and then use to substantiate your arguments with your spouse as to who should do the washing up.\n"  );
  call_other( clone, "set_weight", 9  );
  call_other( clone, "set_length", 12  );
  call_other( clone, "set_width", 2  );
  call_other( clone, "set_material", "steel"  );
  call_other( clone, "set_value", 500  );
  call_other( clone, "new_weapon", 2000  );
  call_other( clone, "add_attack", "slash", 70, ({ 10, 2, 20 }), "sharp", "sharp", 0  );
  call_other( clone, "add_attack", "stab", 40, ({ 20, 2, 60 }), "pierce", "pierce", 0 );
   return clone;
}

==================================================
FILE: weapons/knives/.chisel.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/chisel.wep#1" );
  call_other( clone, "set_name", "chisel"  );
  call_other( clone, "set_short", "chisel"  );
  call_other( clone, "set_long", "This is a tool with a sharp edge which is used to shape and cut metal, wood, or stone.\n"  );
  call_other( clone, "set_weight", 11  );
  call_other( clone, "set_length", 6  );
  call_other( clone, "set_width", 3  );
  call_other( clone, "set_material",  "steel"  );
  call_other( clone, "set_value", 300  );
  call_other( clone, "new_weapon", 19200  );
  call_other( clone, "set_damage_chance", 5  );
  call_other( clone, "add_attack", "slash", 30, ({ 10, 3, 10 }), "sharp", "sharp", 0  );
  call_other( clone, "add_attack", "stab", 30, ({ 10, 3, 10 }), "pierce", "pierce", 0 );
   return clone;
}

==================================================
FILE: weapons/knives/.copper_fighting_knife.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/copper_fighting_knife.wep#1" );
  call_other( clone, "set_name", "knife"  );
  call_other( clone, "set_short", "copper fighting knife"  );
  call_other( clone, "set_main_plural", "copper fighting knives"  );
  call_other( clone, "add_adjective", ({ "copper", "fighting" })  );
  call_other( clone, "set_long", "This Djelian copper knife is designed for fighting.  Its straight blade and hilt are undecorated, clean and functional.\n"  );
  call_other( clone, "set_weight", 9  );
  call_other( clone, "set_length", 10  );
  call_other( clone, "set_width", 2  );
  call_other( clone, "set_material", "copper"  );
  call_other( clone, "set_value", 180  );
  call_other( clone, "new_weapon", 32000  );
  call_other( clone, "add_attack", "slash", 100, ({ 10, 5, 15 }), "sharp", "sharp"  );
  call_other( clone, "add_attack", "stab", 50, ({ 10, 2, 20 }), "pierce", "pierce" );
   return clone;
}

==================================================
FILE: weapons/knives/.dagger.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/dagger.wep#1" );
  call_other( clone, "set_name", "dagger"  );
  call_other( clone, "set_short", "dagger"  );
  call_other( clone, "add_adjective", ({ })  );
  call_other( clone, "add_alias", ({ })  );
  call_other( clone, "add_plural", ({ "daggers" })  );
  call_other( clone, "set_long",  "This is a largish looking knife.\n"  );
  call_other( clone, "set_material", "steel"  );
  call_other( clone, "set_weight", 10  );
  call_other( clone, "set_length", 11  );
  call_other( clone, "set_width", 2  );
  call_other( clone, "set_value",  200  );
  call_other( clone, "new_weapon", 12800  );
  call_other( clone, "set_damage_chance", 5  );
  call_other( clone, "add_attack", "slash", 75, ({ 10, 5, 15 }), "sharp", "sharp"  );
  call_other( clone, "add_attack", "stab", 50, ({ 10, 2, 25 }), "pierce", "pierce" );
   return clone;
}

==================================================
FILE: weapons/knives/.howondalandish_throwing_knife.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/howondalandish_throwing_knife.wep#1" );
  call_other( clone, "set_name", "knife"  );
  call_other( clone, "add_adjective", ({ "howondalandish", "throwing" })  );
  call_other( clone, "set_short", "howondalandish throwing knife"  );
  call_other( clone, "set_main_plural", "howondalandish throwing knives"  );
  call_other( clone, "set_long", "From one of the more remote Howondalandish tribes, this knife "   "doesn't look throwable, much less a knife.  From a short handle, "   "spiky steel blades jut out at all angles, sure to deliver a nasty "   "shock to whoever gets hit with it.\n"  );
  call_other( clone, "set_weight", 9  );
  call_other( clone, "set_length", 9  );
  call_other( clone, "set_width", 3  );
  call_other( clone, "set_material", "steel"  );
  call_other( clone, "new_weapon", 200  );
  call_other( clone, "set_damage_chance", 10  );
  call_other( clone, "add_attack", "stab", 60, ({ 40, 3, 30 }), "pierce", "pierce", 0  );
  call_other( clone, "add_attack", "slash", 60, ({ 25, 5, 30 }), "sharp", "sharp", 0  );
  call_other( clone, "set_value", 7000 );
   return clone;
}

==================================================
FILE: weapons/knives/.klatchian_steel_dirk.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/klatchian_steel_dirk.wep#1" );
  call_other( clone, "set_name", "dirk"  );
  call_other( clone, "set_short", "Klatchian steel dirk"  );
  call_other( clone, "add_adjective", ({ "klatchian", "steel" })  );
  call_other( clone, "add_alias", "dagger"  );
  call_other( clone, "add_plural", "daggers"  );
  call_other( clone, "set_long", "This is a very long, curving knife with a wickedly sharp point.  It is made of Klatchian steel.\n"  );
  call_other( clone, "set_weight", 12  );
  call_other( clone, "set_length", 18  );
  call_other( clone, "set_width", 3  );
  call_other( clone, "set_material", "steel"  );
  call_other( clone, "set_value", 400  );
  call_other( clone, "new_weapon", 32000  );
  call_other( clone, "set_damage_chance", 5  );
  call_other( clone, "add_attack", "slash", 75, ({ 10, 5, 20 }), "sharp", "sharp"  );
  call_other( clone, "add_attack", "stab", 50, ({ 10, 2, 27 }), "pierce", "pierce" );
   return clone;
}

==================================================
FILE: weapons/knives/.knife.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/knife.wep#1" );
  call_other( clone, "set_name", "knife"  );
  call_other( clone, "set_short", "knife"  );
  call_other( clone, "add_adjective", ({ "medium-sized", "medium" })  );
  call_other( clone, "set_main_plural", "knives"  );
  call_other( clone, "set_long", "This is a medium-sized knife, the sort of thing someone might keep in a boot to ward off a would-be attacker.  You just have to hope that it's not then used to prepare your dinner.\n"  );
  call_other( clone, "set_weight", 8  );
  call_other( clone, "set_length", 7  );
  call_other( clone, "set_width", 2  );
  call_other( clone, "set_material",  "steel"  );
  call_other( clone, "set_value", 100  );
  call_other( clone, "new_weapon", 9000  );
  call_other( clone, "add_attack",  "slash", 70, ({ 10, 3, 20 }), "sharp", "sharp", 0  );
  call_other( clone, "add_attack",  "stab", 40, ({ 15, 3, 30 }), "pierce", "pierce", 0 );
   return clone;
}

==================================================
FILE: weapons/knives/.letter_opener.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/letter_opener.wep#1" );
  call_other( clone, "set_name", "opener"  );
  call_other( clone, "set_short", "pearl-handled letter opener"  );
  call_other( clone, "add_adjective", ({ "pearl-handled", "pearl", "handled", "letter" })  );
  call_other( clone, "set_main_plural", "pearl-handled letter openers"  );
  call_other( clone, "set_long", "This letter opener has a lovely pearl handle.  It has a pointy blade that could come in handy in a crunch.\n"  );
  call_other( clone, "set_weight", 4  );
  call_other( clone, "set_length", 8  );
  call_other( clone, "set_width", 1  );
  call_other( clone, "set_material", "steel"  );
  call_other( clone, "set_value", 5000  );
  call_other( clone, "new_weapon", 1600  );
  call_other( clone, "set_damage_chance", 8  );
  call_other( clone, "add_attack", "stab", 40, ({ 30, 3, 10 }), "pierce", "pierce", 0 );
   return clone;
}

==================================================
FILE: weapons/knives/.meat_cleaver.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/meat_cleaver.wep#1" );
  call_other( clone, "set_name", "cleaver"  );
  call_other( clone, "set_short", "meat cleaver"  );
  call_other( clone, "add_alias", ({ "utensil", "knife" })  );
  call_other( clone, "add_adjective", "meat"  );
  call_other( clone, "set_main_plural", "meat cleavers"  );
  call_other( clone, "add_plural", ({ "utensils", "knives" })  );
  call_other( clone, "set_long", "This is a butcher's implement for cutting animal carcasses into joints or pieces.  It is a large, rectangular knife and is quite heavy.\n"  );
  call_other( clone, "set_weight", 16  );
  call_other( clone, "set_length",  11  );
  call_other( clone, "set_width", 5  );
  call_other( clone, "set_material",  "steel"  );
  call_other( clone, "set_value", 400  );
  call_other( clone, "new_weapon", 750  );
  call_other( clone, "set_damage_chance", 5  );
  call_other( clone, "add_attack", "slash", 50, ({ 10, 4, 10 }), "sharp", "sharp", 0  );
  call_other( clone, "add_attack", "hack", 90, ({ 20, 3, 20 }), "sharp", "sharp", 0 );
   return clone;
}

==================================================
FILE: weapons/knives/.sharp_butter_knife.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/sharp_butter_knife.wep#1" );
  call_other( clone, "set_name", "knife"  );
  call_other( clone, "set_short", "sharp butter knife"  );
  call_other( clone, "set_main_plural", "sharp butter knives"  );
  call_other( clone, "add_adjective", ({ "sharp", "butter" })  );
  call_other( clone, "add_alias", ({ "utensil" })  );
  call_other( clone, "add_plural", "knives"  );
  call_other( clone, "set_long",  "This is a butter knife that has been sharpened a bit.\n"  );
  call_other( clone, "set_weight",  3  );
  call_other( clone, "set_length",  6  );
  call_other( clone, "set_width",  1  );
  call_other( clone, "set_material",  "steel"  );
  call_other( clone, "set_value",  75  );
  call_other( clone, "new_weapon",  500  );
  call_other( clone, "add_attack",  "slash", 70, ({ 15, 2, 20 }), "sharp", "sharp", 0  );
  call_other( clone, "add_attack",  "stab", 40, ({ 20, 2, 30 }), "pierce", "pierce", 0 );
   return clone;
}

==================================================
FILE: weapons/knives/.silver_sickle.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/silver_sickle.wep#1" );
  call_other( clone, "set_name", "sickle"  );
  call_other( clone, "set_short", "silver sickle"  );
  call_other( clone, "add_adjective", "silver"  );
  call_other( clone, "set_long", "This is a dagger with a crescent shaped blade cast from silver.\n"  );
  call_other( clone, "set_weight", 9  );
  call_other( clone, "set_length", 12  );
  call_other( clone, "set_width", 8  );
  call_other( clone, "set_material",  "silver"  );
  call_other( clone, "set_value",  2000  );
  call_other( clone, "new_weapon", 12800  );
  call_other( clone, "set_damage_chance", 5  );
  call_other( clone, "add_attack",  "slash", 75, ({ 10, 5, 15 }), "sharp", "sharp"  );
  call_other( clone, "add_attack",  "stab", 50, ({ 10, 2, 25 }), "pierce", "pierce" );
   return clone;
}

==================================================
FILE: weapons/knives/.small_copper_knife.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/small_copper_knife.wep#1" );
  call_other( clone, "set_name", "knife"  );
  call_other( clone, "set_short", "small copper knife"  );
  call_other( clone, "set_main_plural", "small copper knives"  );
  call_other( clone, "add_adjective", ({ "small", "copper" })  );
  call_other( clone, "set_long", "This is a small, Djelian, copper knife.  Its straight blade and hilt are undecorated, clean and functional.\n"  );
  call_other( clone, "set_weight", 5  );
  call_other( clone, "set_length", 8  );
  call_other( clone, "set_width", 3  );
  call_other( clone, "set_material",  "copper"  );
  call_other( clone, "set_value", 100  );
  call_other( clone, "new_weapon", 16000  );
  call_other( clone, "add_attack", "slash", 100, ({ 10, 5, 10 }), "sharp", "sharp"  );
  call_other( clone, "add_attack", "stab", 50, ({ 10, 2, 15 }), "pierce", "pierce" );
   return clone;
}

==================================================
FILE: weapons/knives/.small_knife.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/small_knife.wep#1" );
  call_other( clone, "set_name", "knife"  );
  call_other( clone, "set_short", "small knife"  );
  call_other( clone, "add_adjective", ({ "small" })  );
  call_other( clone, "add_alias", "utensil"  );
  call_other( clone, "add_plural", "utensils"  );
  call_other( clone, "set_long", "This small knife might be the sort of thing " "you'd use to peel an apple, slice carrots or " "stab in someone's kidney.  You could say " "that it's a multi-purpose utensil.\n"  );
  call_other( clone, "set_weight", 6  );
  call_other( clone, "set_length", 7  );
  call_other( clone, "set_width", 1  );
  call_other( clone, "set_material",  "steel"  );
  call_other( clone, "set_value", 50  );
  call_other( clone, "new_weapon", 500  );
  call_other( clone, "add_attack", "slash", 70, ({ 5, 2, 20 }), "sharp", "sharp", 0  );
  call_other( clone, "add_attack", "stab", 40, ({ 10, 2, 30 }), "pierce", "pierce", 0 );
   return clone;
}

==================================================
FILE: weapons/knives/.stiletto.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/stiletto.wep#1" );
  call_other( clone, "set_name", "stiletto"  );
  call_other( clone, "set_short", "stiletto"  );
  call_other( clone, "add_alias", "knife"  );
  call_other( clone, "add_adjective", "slender"  );
  call_other( clone, "set_main_plural", "stilettoes"  );
  call_other( clone, "add_plural", "knives"  );
  call_other( clone, "set_long", "This is a slender knife with a dark steel blade, and sharp tip.  "         "It's perfect for slipping between someone's ribs.\n"  );
  call_other( clone, "set_weight", 7  );
  call_other( clone, "set_length", 10  );
  call_other( clone, "set_width", 1  );
  call_other( clone, "set_material",  "steel"  );
  call_other( clone, "set_value", 2000  );
  call_other( clone, "new_weapon",  5000  );
  call_other( clone, "set_damage_chance",  5  );
  call_other( clone, "add_attack",  "stab", 70, ({ 40, 4, 20 }), "pierce", "pierce"  );
  call_other( clone, "add_attack",  "stabstab", 70, ({ 40, 4, 20 }), "pierce", "pierce"  );
  call_other( clone, "set_no_limbs", 1 );
   return clone;
}

==================================================
FILE: weapons/knives/.tanto.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/tanto.wep#1" );
  call_other( clone, "set_name", "tanto"  );
  call_other( clone, "set_short", "tanto"  );
  call_other( clone, "add_alias", "dagger"  );
  call_other( clone, "add_plural", ({"daggers","tantos"})  );
  call_other( clone, "set_main_plural", "tantos"  );
  call_other( clone, "set_long", "This large auriental dagger is an excellent weapon for close-in fighting.  It is short, well crafted and looks pretty durable.\n"  );
  call_other( clone, "set_weight", 9  );
  call_other( clone, "set_length", 10  );
  call_other( clone, "set_width", 3  );
  call_other( clone, "set_material", "steel"  );
  call_other( clone, "set_value", 4000  );
  call_other( clone, "new_weapon", 50000  );
  call_other( clone, "set_damage_chance", 2  );
  call_other( clone, "add_attack", "slash", 75, ({ 0, 2, 40 }), "sharp", "sharp", 0  );
  call_other( clone, "add_attack", "stab", 50, ({ 9, 4, 30 }), "pierce", "pierce", 0 );
   return clone;
}

==================================================
FILE: weapons/knives/.white_handled_ceremonial_bronze_knife.wep_virtual_.c
==================================================

#include <virtual.h>
void dest_me() { destruct( this_object() ); }
void create()
{
  seteuid( (string)"/secure/master"->creator_file( file_name( this_object() ) ) );
}
object create_virtual_ob() {
   object clone;
  clone = (object)SERVER->create_virtual_object( "/obj/weapon.c", 1 );
  clone->add_property( VIRTUAL_NAME_PROP, "/obj/weapons/knives/white_handled_ceremonial_bronze_knife.wep#1" );
  call_other( clone, "set_name", "knife"  );
  call_other( clone, "set_short", "white handled ceremonial bronze knife"  );
  call_other( clone, "add_adjective", ({ "white", "handled", "ceremonial", "bronze" })  );
  call_other( clone, "set_main_plural", "white handled ceremonial bronze knives"  );
  call_other( clone, "add_plural", "knives"  );
  call_other( clone, "set_long", "This is a ceremonial knife, for use in magic rituals.  Its ornate handle is made of ivory and its long bronze blade has been carved with mystic runes.\n"  );
  call_other( clone, "set_weight", 11  );
  call_other( clone, "set_length", 18  );
  call_other( clone, "set_width", 3  );
  call_other( clone, "set_material",  "bronze"  );
  call_other( clone, "set_value", 1000  );
  call_other( clone, "new_weapon", 2000  );
  call_other( clone, "add_attack", "slash", 70, ({ 10, 2, 20 }), "sharp", "sharp", 0  );
  call_other( clone, "add_attack", "stab", 40, ({ 20, 2, 60 }), "pierce", "pierce", 0 );
   return clone;
}
