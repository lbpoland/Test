
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/options_control.c ===
#define PLAYER_OPTIONS_CLASS
#include <player.h>
mixed query_property(string);
varargs void add_property(string,mixed,int);
private class player_options_control query_player_options() {
   class player_options_control options;
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      return new(class player_options_control);
   }
   if (sizeof(options) == 4) {
      class player_options_control newbit;
      newbit = new(class player_options_control);
      newbit->follow_everyone = options->follow_everyone;
      newbit->follow_groups = options->follow_groups;
      newbit->follow_friends = options->follow_friends;
      newbit->lead_behind = options->lead_behind;
      options = newbit;
   }
   return options;
}
int query_auto_follow_group() {
   class player_options_control options;
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      return 0;
   }
   return options->follow_groups;
}
int query_auto_follow_friends() {
   class player_options_control options;
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      return 0;
   }
   return options->follow_friends;
}
int query_auto_follow_everyone() {
   class player_options_control options;
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      return 0;
   }
   return options->follow_everyone;
}
int query_lead_from_behind() {
   class player_options_control options;
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      return 0;
   }
   return options->lead_behind;
}
void set_auto_follow_group(int flag) {
   class player_options_control options;
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      options = new(class player_options_control);
   }
   options->follow_groups = flag;
   add_property(PLAYER_OPTIONS_CONTROL_PROP, options);
}
void set_auto_follow_friends(int flag) {
   class player_options_control options;
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      options = new(class player_options_control);
   }
   options->follow_friends = flag;
   add_property(PLAYER_OPTIONS_CONTROL_PROP, options);
}
void set_auto_follow_everyone(int flag) {
   class player_options_control options;
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      options = new(class player_options_control);
   }
   options->follow_everyone = flag;
   add_property(PLAYER_OPTIONS_CONTROL_PROP, options);
}
void set_lead_from_behind(int flag) {
   class player_options_control options;
   options = query_property(PLAYER_OPTIONS_CONTROL_PROP);
   if (!options) {
      options = new(class player_options_control);
   }
   options->lead_behind = flag;
   add_property(PLAYER_OPTIONS_CONTROL_PROP, options);
}
void set_mxp_disable(int flag) {
   class player_options_control options;
   options = query_player_options();
   options->mxp_disable = 1;
   add_property(PLAYER_OPTIONS_CONTROL_PROP, options);
}
int query_mxp_disable() {
   class player_options_control options;
   options = query_player_options();
   return options->mxp_disable;
}
int is_mxp_enabled() {
#if efun_defined(has_mxp)
   if (has_mxp(this_object())) {
      return !query_mxp_disable();
   }
#endif
   return 0;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/command.c ===
#include <command.h>
nosave string current_verb, current_cmd;
private nosave int Forced;
private nosave string *SearchPath;
protected void create() {
   current_verb = "";
  SearchPath = ({ DIR_LIVING_CMDS });
}
string query_current_verb() { return current_verb; }
string query_current_cmd() { return current_cmd; }
protected int cmdAll(string args) {
  class command verb;
  mixed tmp;
  verb = new(class command);
  verb->args = args;
  current_cmd = args;
  if( !((int)CMD_D->GetCommand(verb, SearchPath)) ) {
    return 0;
  }
   current_verb = verb->verb;
  if (CMD_D->IsGRCommand(verb->filepart) &&
      !this_object()->query_known_command(verb->verb))
    return 0;
  if (this_object()->command_shadowed(verb->verb, verb->args))
    return 1;
  if( !(tmp = (mixed)call_other(verb->file, "cmd", verb->args, verb->verb)) )
    return 0;
  else if( stringp(tmp) ) {
    write("Error: "+tmp+"\n");
    return 1;
  }
  else return 1;
}
protected mixed *cmdPatterns(string verb) {
  if (CMD_D->IsGRCommand(verb) &&
      !this_object()->query_known_command(verb))
    return 0;
  return CMD_D->GetCommandPatterns(verb, SearchPath);
}
protected void command_commands() {
#if efun_defined(add_action)
  add_action( "cmdAll", "*", -1 );
#endif
}
int eventForce(string cmd) {
  string err;
  int res;
  if(member_array(call_stack(0)[1],
                  ({  "/cmds/creator/show_help.c",
                      "/d/am/broad_way/cryer_order.c",
                      "/obj/handlers/new_soul.c",
                      "/std/living/force.c"
                        })) == -1)
    error("illegal force");
  Forced = 1;
  err = catch(res = command(cmd));
  Forced = 0;
  if(err) error(err);
  return res;
}
string *AddSearchPath(mixed val) {
  if (stringp(val)) {
     val = ({ val });
  } else if(!pointerp(val)) {
     error("Bad argument 1 to AddSearchPath()\n");
  }
  SearchPath = uniq_array(SearchPath + val);
  return SearchPath;
}
string *RemoveSearchPath(mixed val) {
  if(stringp(val)) {
    val = ({ val });
  } else if(!pointerp(val)) {
    error("Bad argument 1 to RemoveSearchPath()\n");
  }
  SearchPath -= val;
  return SearchPath;
}
string *GetSearchPath() { return SearchPath; }
int GetForced() { return Forced; }
string GetClient() { return 0; }

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/parser.h ===
#define TOKENISER "/obj/handlers/tokeniser"
#include "tokenise.h"

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/history.c ===
#define COLS (int)this_object()->query_cols()
nosave string *history;
nosave int hoffset, numoff;
nosave int in_alias_command;
nosave string ignore_history;
void history_commands() {}
string substitute_history(string arg) {
  string s1, s2;
  if (sscanf(arg, "%s^%s", s1, s2) != 2)
    return arg;
  sscanf(s2, "%s^", s2);
  if (hoffset)
    return replace(history[hoffset-1], s1, s2);
  else
    return replace(history[sizeof(history)-1], s1, s2);
}
protected string expand_history( string arg ) {
   int num, i;
   if (arg[0] == '.' || strlen(arg) == 0) {
      if (hoffset) {
         return history[hoffset-1]+arg[1..strlen(arg)];
      } else {
         return history[sizeof(history)-1]+arg[1..strlen(arg)];
      }
   }
   if (sscanf(arg,"%d",num)==1) {
      num = num % sizeof(history);
      if (num<0) {
         num += hoffset;
         if (num<0) {
            num += sizeof(history);
         }
      }
      return history[num];
   }
   for (i=hoffset-1;i>=0;i--) {
      if (stringp(history[i])) {
         if (strsrch(history[i],arg)==0) {
            return history[i];
         }
      }
   }
   for (i=sizeof(history)-1;i>hoffset;i--) {
      if (stringp(history[i])) {
         if (strsrch(history[i],arg)==0) {
            return history[i];
         }
      }
   }
   return arg;
}
void ignore_from_history(string str) {
  ignore_history = str;
}
void add_history( string arg ) {
   if (ignore_history) {
      if (ignore_history == arg) {
         ignore_history = 0;
         return ;
      }
      ignore_history = 0;
   }
   if (arg == "" || arg[0] == '.' || arg[0] == '^')
      return;
   if (in_alias_command)
      return;
   if (!history) {
      history = allocate(40);
      numoff = -40;
   }
   history[hoffset++] = arg;
   if (hoffset>=sizeof(history)) {
      numoff += sizeof(history);
      hoffset = 0;
   }
}
nomask int print_history( string arg ) {
   int i, from, to, num;
   if(this_player()!=this_object()) {
      if(!interactive(this_player())) {
         return 0;
      }
      if(!(master()->query_lord(geteuid(this_player()))) &&
         !master()->is_liaison_deputy(geteuid(this_player()))) {
         return 0;
      }
   }
  if(this_object()!=this_player(1)) {
   user_event( this_object(), "inform",
               "Print history called on " + this_object()->query_name() +
               " by " + this_player()->query_name(),
               "calls", this_player());
  }
   from = hoffset;
   num = sizeof(history);
   if (!arg) {
      arg = "";
   }
   if (sscanf(arg,"%d,%d",from,to)==2) {
      num = to-from;
      if (num<0) {
         from = from+num;
         num = -num;
      }
   } else if (sscanf(arg,",%d",to)==1) {
      from = hoffset+1+num;
      num = from - (to%sizeof(history))+sizeof(history);
   } else if (sscanf(arg,"%d,",from)==1) {
      from = from % sizeof(history);
      num = from - hoffset;
      if (num<0) {
         num += sizeof(history);
      }
   } else if (sscanf(arg,"%d",num)!=1) {
         num = sizeof(history);
   }
   if(sizeof(history)) {
     from = from % sizeof(history);
   } else {
     from = 0;
   }
   if (num>sizeof(history)) {
     num = sizeof(history);
   }
   if (num <= 0) {
     add_failed_mess("Range out of bounds.\n");
     return 0;
   }
   for (i=from;i<sizeof(history);i++,num--) {
     if (history[i]) {
       printf( "%s%-=*s\n", sprintf( "% 4d", i + numoff ) +": ", COLS - 6,
               history[ i ] );
     }
     if (!num) {
       return 1;
     }
   }
   for (i=0;i<from;i++,num--) {
     if (history[i]) {
       printf( "%s%-=*s\n", sprintf( "% 4d", i + numoff + sizeof( history ) ) +
               ": ", COLS - 6, history[ i ] );
     }
     if (!num) {
       return 1;
     }
   }
   return 1;
}
nomask protected string *get_history() {
  return history;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/le.c ===
private nosave int line;
private nosave string *cfile, cfile_name, last_search;
protected int le(string s);
int add_command(string str, object ob, string format, function funct);
void create() {
  seteuid("PLAYER");
}
private void print_line() {
   if (line > sizeof(cfile)) {
      line = sizeof(cfile);
   }
   if (!line) {
      write("No line.\n");
      return;
   }
   write(extract("   ", 0, 3 - strlen(line + "")) + line + ":" + cfile[line-1] + "\n");
}
protected void le_commands() {
   add_command("le", this_object(), "<string>", (: le($4[0]) :));
}
protected int le(string s) {
   int j;
   string sB;
   if (!pointerp(cfile)) { cfile = ({ }); line = 0; }
   if (!s || s == "") { print_line(); return 1; }
   if (sscanf(s, "%d", j)) { line = j; print_line(); return 1; }
   switch (s[0]) {
   case 'd':
      if (!line) { notify_fail("Not on a line.\n"); return 0; }
      cfile = delete(cfile, line-1, 1);
      print_line();
      return 1;
   case 'N':
      cfile = ({ });
      line = 0;
      cfile_name = 0;
      write("Line editor cleared.\n");
      return 1;
   case '/':
      s = extract(s, 1);
      if (s == "") {
         s = last_search;
      }
      last_search = s;
      {
         int i, s1, s2;
         for (i = line+1; i<= sizeof(cfile); i++) {
            if (sscanf(cfile[i-1], "%s"+s+"%s", s1, s2)) { line = i; print_line(); return 1; }
         }
         write("Search failed.\n");
         return 1;
      }
   case '>':
      s = extract(s, 1);
      {
         string *tmp1, *tmp2;
         tmp1 = (line > 1) ? cfile[0..line-2] : ({ });
         tmp2 = (line <= sizeof(cfile)) ? cfile[line-1..sizeof(cfile)-1] : ({ });
         cfile = tmp1 + ({ s }) + tmp2;
      }
      line++;
      print_line();
      return 1;
   case 'r':
      {
         string sA;
         sA = extract(s, 1);
         while (sA[0] == ' ') sA = extract(sA,1);
         sB = this_player()->get_path(sA);
         if (!sB) sB = sA;
         if (file_size(sB) < 0) { notify_fail("File doesn't exist.\n"); return 0; }
         sA = read_file(sB);
         cfile = explode(sA, "\n");
         line = 1;
      }
      write("Read file "  + sB + ": " + sizeof(cfile) + " lines.\n");
      cfile_name = sB;
      print_line();
      return 1;
   case '+':
      if (line < sizeof(cfile)) line++;
      print_line();
      return 1;
   case '-':
      if (line > 1) line --;
      print_line();
      return 1;
   case 'w':
      if (s == "w") {
         if (!cfile_name) { notify_fail("No file name.\n"); return 0; }
      } else {
         s = extract(s,1);
         while (s[0] == ' ') s = extract(s, 1);
         if (this_player()->get_path(s)) s = this_player()->get_path(s);
         cfile_name = s;
      }
      rm(cfile_name);
      write_file(cfile_name, implode(cfile, "\n"));
      write("Tried to write file " + cfile_name + ": " + sizeof(cfile) + " lines.\n");
      return 1;
   case 'z':
      {
         int q;
         q = 20;
         while (q-- && line <= sizeof(cfile)) { print_line(); line++; }
         line --;
      }
      return 1;
   }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/start_position.c ===
inherit "/std/basic/virtual_quit_control";
#include <playerinfo.h>
#include <config.h>
#define MULTIPLAYER "/obj/handlers/multiplayer"
private int  *saved_co_ords;
private string last_pos;
private string *starts;
protected void inform_entered_game();
int query_creator();
string query_name();
string query_cap_name();
string the_short();
varargs int move(string pos, string messin, string messout);
string query_nationality_start_location();
void create() {
   starts = ({ });
}
int *query_saved_co_ords() { return saved_co_ords; }
protected void set_last_pos(string pos) {
  if(pos[0..4] != "/room")
    last_pos = pos;
}
string query_last_pos() {
   return last_pos;
}
string query_start_pos() {
   string start_pos;
   if ( !sizeof( starts ) ) {
      start_pos = query_nationality_start_location();
   } else {
      start_pos = starts[ 0 ];
   }
   if ( !find_object( start_pos ) ) {
      if ( catch( call_other( start_pos, "??" ) ) ) {
         start_pos = query_nationality_start_location();
      }
   }
   return start_pos;
}
string *query_starts() {
   return starts;
}
void reset_starts() { starts = ({ }); }
void add_start( string start_file, string start_desc ) {
   if ( !starts ) {
      starts = ({ });
   }
   if ( member_array( start_file, starts ) != -1 ) {
      return;
   }
   starts += ({ start_file, start_desc });
}
void remove_start( string start_file ) {
   int i;
   if ( !starts ) {
      return;
   }
   i = member_array( start_file, starts );
   if ( i == -1 ) {
      return;
   }
   starts = delete( starts, i, 2 );
}
void set_start_location( string start_file ) {
  int i;
  if ( !starts) {
    return ;
  }
  i = member_array(start_file, starts);
  if (i <= 0) {
    return ;
  }
  starts = starts[i..i + 1] + starts[0..i - 1] + starts[i + 2..];
}
protected void move_to_start_pos() {
   if (!last_pos || catch(call_other(last_pos, "??"))) {
      last_pos = query_start_pos();
      saved_co_ords = 0;
   }
   move(last_pos);
   if ( !last_pos->query_co_ord() && !last_pos->query_property( "no map" ) &&
         saved_co_ords && !query_creator() ) {
      last_pos->set_co_ord( saved_co_ords );
   }
   inform_entered_game();
}
private function query_extra_login_stuff(string start) {
   string ip_str;
   object *obs;
   object mph;
   string alert;
   int num;
   string *dups;
   switch (this_object()->query_invis()) {
      case 3 :
         start += " (trustee invisible)";
         break;
      case 2 :
         start += " (director invisible)";
         break;
      case 1 :
         start += " (invisible)";
         break;
   }
   mph = load_object(MULTIPLAYER);
   obs = filter(users() - ({ this_object() }),
                (: query_ip_number($1) == query_ip_number(this_object()) &&
                   !$1->query_login_ob() :));
   if (sizeof(obs) &&
       sizeof((dups = mph->check_allowed(this_object(), obs)))) {
      ip_str = " (" + query_ip_name(this_object()) + ")";
      ip_str += " Duplicate: " + query_multiple_short(dups);
   }
   if (!catch(num = PLAYERINFO_HANDLER->query_alerts_for(query_name()))) {
      if (num > 0) {
         alert = " %^BOLD%^%^RED%^" + num + " alert";
         if (num > 1) {
            alert += "s";
         }
         alert += "%^RESET%^";
      }
   }
   if (ip_str) {
      if (!alert) {
         alert = "";
      }
      return (: $(start) +
                       ($1->query_creator()?$(ip_str) + $(alert):"") :);
   } else {
      if (alert) {
         return (: $(start) + ($1->query_creator()?$(alert):"") :);
      } else {
         return (: $(start) :);
      }
   }
}
protected void inform_entered_game() {
   string logon_str;
   if ("/d/liaison/master"->query_member( query_name() ) ) {
      logon_str = query_cap_name() + " enters "
           "" + mud_name() + " %^YELLOW%^(Liaison)";
   } else {
      logon_str = query_cap_name() + " enters " +
           ( this_object()->query_property( "guest" ) ? "as a guest of " : "" ) +"" + mud_name() + ""+
           ( this_object()->query_property( "new player!" ) ? " (new player)" : "" );
   }
   user_event( this_object(), "inform",
               query_extra_login_stuff(logon_str),
               "logon", this_object());
   say(the_short()+" enters the game.\n", 0);
   last_pos->enter(this_object());
}
void inform_reconnect_game() {
   user_event( "inform",
         query_extra_login_stuff(query_cap_name() +
         " reconnects"), "link-death", this_object() );
}
void check_last_pos() {
   last_pos = find_start_pos(this_object(), environment());
   saved_co_ords = find_start_coord(this_object(), environment());
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/family.c ===
#include <clubs.h>
#include <player.h>
class family_information {
   string name;
   string* adjectives;
   string id;
   string* titles;
   string cur_title;
   string* clubs;
   string force_title;
   int force_timeout;
}
#define FAMILY_CLASS_SIZE 8
private class family_information _family_name;
string query_name();
int set_family_name(string name);
int add_player_title(string title);
void remove_player_title(string title);
private class family_information create_family_info() {
   class family_information bing;
   bing = new(class family_information);
   bing->adjectives = ({ });
   bing->titles = ({ "mr", "miss", "mrs", "ms" });
   bing->clubs = ({ });
   return bing;
}
protected void setup_default_titles() {
   if (!_family_name) {
       return;
   }
   _family_name->titles = ({ "mr", "miss", "mrs", "ms" });
}
private void update_adjectives() {
   if (!_family_name) {
      return ;
   }
   _family_name->adjectives = ({ });
   _family_name->id = 0;
   if (_family_name &&
       _family_name->name) {
      _family_name->adjectives = explode(lower_case(_family_name->name), " ")[0..<2];
      _family_name->id = explode(lower_case(_family_name->name), " ")[<1];
   }
   if (_family_name &&
       _family_name->cur_title) {
      _family_name->adjectives += explode(_family_name->cur_title, " ");
   }
}
void check_family_name() {
   class family_information frog;
   string bing;
   if (!classp(_family_name) &&
       _family_name) {
      bing = (string)_family_name;
      _family_name = create_family_info();
      set_family_name(bing);
   }
   if (classp(_family_name) &&
       sizeof(_family_name) == 5) {
      frog = new(class family_information);
      frog->adjectives = _family_name->adjectives;
      frog->id = _family_name->id;
      frog->cur_title = _family_name->cur_title;
      frog->name = _family_name->name;
      frog->titles = _family_name->titles;
      frog->clubs = ({ });
      _family_name = frog;
   }
   if (classp(_family_name) &&
       sizeof(_family_name) == 6) {
      frog = new(class family_information);
      frog->adjectives = _family_name->adjectives;
      frog->id = _family_name->id;
      frog->cur_title = _family_name->cur_title;
      frog->name = _family_name->name;
      frog->titles = _family_name->titles;
      frog->clubs = _family_name->clubs;
      _family_name = frog;
   }
   if (_family_name &&
       _family_name->name) {
      if (!CLUB_HANDLER->is_family(_family_name->name) ||
          !CLUB_HANDLER->is_member_of(_family_name->name, query_name())) {
         _family_name->name = 0;
      }
   }
   if (_family_name &&
       strlen(_family_name->cur_title) > 20) {
      tell_object(this_object(),
                  "%^YELLOW%^Your title is too long!  Resetting.\n%^RESET%^");
      _family_name->cur_title = 0;
   }
   if (_family_name &&
       _family_name->cur_title) {
      if (member_array(lower_case(_family_name->cur_title),
                       _family_name->titles) == -1) {
         tell_object(this_object(),
                  "%^YELLOW%^Your title is invalid!  Resetting.\n%^RESET%^");
         _family_name->cur_title = 0;
      }
   }
   update_adjectives();
   if (_family_name && _family_name->clubs) {
       _family_name->clubs = filter(_family_name->clubs,
           (: CLUB_HANDLER->is_club($1) :));
   }
}
int set_family_name(string name) {
   if (name && (!CLUB_HANDLER->is_family(name) ||
                !CLUB_HANDLER->is_member_of(name, query_name()))) {
      return 0;
   }
   if (!classp(_family_name)) {
      _family_name = create_family_info();
   }
   if (_family_name->name) {
      CLUB_HANDLER->remove_member(_family_name->name, query_name());
   }
   if (name) {
      _family_name->name = CLUB_HANDLER->query_club_name(name);
   } else {
      _family_name = 0;
   }
   update_adjectives();
   return 1;
}
string query_family_name() {
   if (stringp(_family_name)) {
      return (string)_family_name;
   }
   if (_family_name) {
      return _family_name->name;
   }
   return 0;
}
string query_player_title() {
   check_family_name();
   if (_family_name && classp(_family_name) &&
       _family_name->force_title) {
      if (-this_object()->query_time_on() > _family_name->force_timeout) {
         _family_name->force_title = 0;
      } else {
         return capitalize(_family_name->force_title);
      }
   }
   if (_family_name && classp(_family_name) &&
       _family_name->cur_title) {
      return capitalize(_family_name->cur_title);
   }
   return 0;
}
string* query_all_player_titles() {
   if (!_family_name) {
      _family_name = create_family_info();
   }
   return _family_name->titles;
}
int set_player_title(string title) {
   string* bits;
   if (!_family_name) {
      _family_name = create_family_info();
   }
   if (strlen(title) > 20) {
      return 0;
   }
   if (!title ||
       member_array(lower_case(title), _family_name->titles) != -1) {
      if (title) {
         bits = explode(title, " ");
         _family_name->cur_title = implode(map(bits, (: capitalize($1) :)), " ");
      } else {
         _family_name->cur_title = 0;
      }
      update_adjectives();
      return 1;
   }
   return 0;
}
int set_forced_title(string title, int timeout) {
   _family_name->force_title = title;
   _family_name->force_timeout = -this_object()->query_time_on() + timeout;
   tell_object(this_object(), "%^CYAN%^You feel that other peoples perception "
               "of you has changed and you title is being "
               "misinterpreted.%^RESET%^\n");
   return 1;
}
string query_forced_title() {
   return _family_name->force_title;
}
int add_player_title(string title) {
   title = lower_case(title);
   if (!_family_name) {
      _family_name = create_family_info();
   }
   if (member_array(title, _family_name->titles) == -1) {
      _family_name->titles += ({ title });
      return 1;
   }
   return 0;
}
void remove_player_title(string title) {
   title = lower_case(title);
   if (!_family_name) {
      _family_name = create_family_info();
   }
   if (member_array(title, _family_name->titles) != -1) {
      _family_name->titles -= ({ title });
   }
   if (_family_name->cur_title == title) {
      _family_name->cur_title = 0;
   }
}
int add_player_club(string club) {
   class family_information frog;
   if (!club) {
      return 0;
   }
   club = CLUB_HANDLER->normalise_name(club);
   if (!CLUB_HANDLER->is_club(club)) {
      return 0;
   }
   if (!_family_name) {
      _family_name = create_family_info();
   }
   if (classp(_family_name) &&
       sizeof(_family_name) == 5) {
      frog = new(class family_information);
      frog->adjectives = _family_name->adjectives;
      frog->id = _family_name->id;
      frog->cur_title = _family_name->cur_title;
      frog->name = _family_name->name;
      frog->titles = _family_name->titles;
      frog->clubs = ({ });
      _family_name = frog;
   }
   if (member_array(club, _family_name->clubs) == -1) {
      _family_name->clubs += ({ club });
      return 1;
   }
   return 0;
}
void remove_player_club(string club) {
   if (!club) {
      return 0;
   }
   club = CLUB_HANDLER->normalise_name(club);
   if (!_family_name) {
      return ;
   }
   _family_name->clubs -= ({ club });
}
string* query_player_clubs() {
   if (!_family_name) {
      return ({ });
   }
   return _family_name->clubs;
}
string *parse_command_id_list() {
   if (_family_name &&
       _family_name->id) {
      return ({ _family_name->id });
   }
   return ({ });
}
string *parse_command_plural_id_list() {
   if (_family_name &&
       _family_name->id) {
      return ({ pluralize(_family_name->id) });
   }
   return ({ });
}
string *parse_command_adjectiv_id_list() {
   if (_family_name) {
      return _family_name->adjectives;
   }
   return ({ });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/auto_load.c ===
#include <move_failures.h>
#include <virtual.h>
#include <player.h>
#define AUTO_STR_LENGTH 3
#define AUTO_LOAD_TYPE 0
#define AUTO_LOAD_NAME 1
#define AUTO_LOAD_DATA 2
#define AUTO_LOAD_STATIC_ARG  0
#define AUTO_LOAD_DYNAMIC_ARG 1
private mixed auto_load;
private nosave int _no_calls;
private nosave function _finished;
private void auto_clone_alt( object thing, mixed *load_info,
                     object dest, object tell_pl, function move_f, string name);
private object *int_auto_load(int type, string name, mixed *load_info,
                              object dest, object tell_pl, int now,
                              function move_f);
private void move_to_destination(object thing, object dest, object tell_pl,
                                 function move_f);
string *fragile_auto_str_ob(object ob) {
   mixed static_arg;
   mixed dynamic_arg;
   string fname;
   static_arg = ob->query_static_auto_load();
   dynamic_arg = ob->query_dynamic_auto_load();
   if (!static_arg && !dynamic_arg) {
      return ({ });
   }
   if ( sscanf( file_name( ob ), "%s#%*d", fname) == 2 ) {
      return  ({ 1, fname, ({ static_arg, dynamic_arg }) });
   } else {
      return ({ 0, file_name(ob), ({ static_arg, dynamic_arg }) });
   }
}
private string *auto_str_ob(object ob) {
   string static_arg;
   string dynamic_arg;
   string catch_static;
   string catch_dynamic;
   string fname;
   int value;
   string ob_name;
   mixed* tmp;
   catch_static = catch(static_arg = (string)ob->query_static_auto_load());
   catch_dynamic = catch(dynamic_arg = (string)ob->query_dynamic_auto_load());
   if (!static_arg && !dynamic_arg) {
      if (catch_static || catch_dynamic) {
         catch(value = ob->query_value());
         ob_name = "unknown object";
         catch(ob_name = ob->short(1));
         catch(PLAYER_RECEIPT->set_object(file_name(ob)));
         PLAYER_RECEIPT->set_obname(ob_name);
         PLAYER_RECEIPT->set_value(value);
         catch(PLAYER_RECEIPT->set_static_data(({ static_arg, dynamic_arg })));
         tmp = fragile_auto_str_ob(find_object("/obj/misc/al_receipt"));
         tmp[0] = 1;
         if (!undefinedp(tmp[2][1]["::"]["cloned by"])) {
           tmp[2][1]["::"]["cloned by"] = "greco";
         }
      } else {
         tmp = ({ });
      }
      return tmp;
   }
   if ( sscanf( file_name( ob ), "%s#%*d", fname ) == 2 ) {
      return  ({ 1, fname, ({ static_arg, dynamic_arg }) });
   } else {
      return ({ 0, file_name( ob ), ({ static_arg, dynamic_arg }) });
   }
}
string *create_auto_load(object *obs, int into_array) {
  int i;
  string *tmp;
  string *al_tmp;
  if (into_array) {
    auto_load = ({ });
  } else {
    tmp = ({ });
  }
  for (i = sizeof(obs) - 1; i >= 0; i--) {
    reset_eval_cost();
    if (!objectp(obs[i])) {
       continue;
    }
    if (!catch(al_tmp = auto_str_ob(obs[i]))) {
      if (into_array) {
         auto_load += al_tmp;
      } else {
         tmp += al_tmp;
      }
    }
  }
  return tmp;
}
void load_auto_load_alt( mixed *auto_string, object dest,
                                   object tell_pl, function finished) {
   int i;
   reset_eval_cost();
   if ( !auto_string || !sizeof( auto_string ) ) {
      return;
   }
   if ( !pointerp( auto_string ) ) {
      return;
   }
   if ( ( dest == this_object() ) &&
        ( tell_pl == this_object() ) &&
        !this_object()->query_no_check() ) {
      this_object()->set_no_check( 1 );
      this_object()->set_max_weight( 100 + this_object()->query_max_weight() );
   }
   _finished = finished;
   reset_eval_cost();
   for ( i = 0; i < sizeof( auto_string ); i += AUTO_STR_LENGTH) {
      _no_calls++;
      call_out( (: int_auto_load :), i / 6,
                                     auto_string[ i + AUTO_LOAD_TYPE ],
                                     auto_string[ i + AUTO_LOAD_NAME ],
                                     auto_string[ i + AUTO_LOAD_DATA ],
                                     dest, tell_pl, 0, (: $1->move($2) :));
   }
}
object *load_auto_load_to_array( mixed *auto_string, object tell_pl ) {
   object *obs;
   int i;
   obs = ({ });
   if (!tell_pl) {
      tell_pl = this_player();
   }
   if (!tell_pl) {
      tell_pl = this_object();
   }
   for ( i = 0; i < sizeof( auto_string ); i += AUTO_STR_LENGTH) {
      _no_calls++;
      obs += int_auto_load(auto_string[ i + AUTO_LOAD_TYPE ],
                           auto_string[ i + AUTO_LOAD_NAME ],
                           auto_string[ i + AUTO_LOAD_DATA ],
                           0, tell_pl, 1, (: MOVE_OK :));
   }
   return obs - ({ 0 });
}
void load_auto_load_to_inventory(mixed *auto_string, object dest,
                                 object tell_pl, function move_f) {
   int i;
   if (!tell_pl) {
      tell_pl = this_player();
   }
   if (!tell_pl) {
      tell_pl = this_object();
   }
   for ( i = 0; i < sizeof( auto_string ); i += AUTO_STR_LENGTH) {
      _no_calls++;
      int_auto_load(auto_string[ i + AUTO_LOAD_TYPE ],
                    auto_string[ i + AUTO_LOAD_NAME ],
                    auto_string[ i + AUTO_LOAD_DATA ],
                    dest, tell_pl, 0, move_f);
   }
}
private object create_auto_load_object( string name,
                                        mixed *load_info,  object dest,
                                        object tell_pl, function move_f) {
   object thing;
   catch(name = (string)CLONER->other_file( name ));
   if ( !catch( thing = (object)CLONER->clone( name ) ) ) {
      if ( thing ) {
         if ( base_name( thing ) == name ) {
            auto_clone_alt(thing, load_info, dest, tell_pl, move_f, name);
         } else {
            move_to_destination(thing, dest, tell_pl, move_f);
         }
      } else {
  tell_object( tell_pl, "%^RED%^Could not clone "+ name +
         ".%^RESET%^\n" );
  thing = clone_object( PLAYER_RECEIPT );
  thing->set_object( name );
  thing->set_static_save( load_info );
  move_to_destination(thing, dest, tell_pl, move_f);
      }
   } else {
      tell_object( tell_pl, "%^RED%^Error in loading "+ name +
       ".%^RESET%^\n" );
      thing = clone_object( PLAYER_RECEIPT );
      thing->set_object( name );
      thing->set_static_save( load_info );
      move_to_destination(thing, dest, tell_pl, move_f);
   }
   return thing;
}
private object *int_auto_load(int type, string name, mixed *load_info,
                              object dest, object tell_pl, int now,
                              function move_f) {
   object thing;
   object new_thing;
   mixed *stuff;
   int reduce;
   _no_calls--;
   if ( type ) {
      thing = create_auto_load_object(name, load_info, dest, tell_pl, move_f);
      if ( name == PLAYER_RECEIPT) {
         stuff = thing->query_static_save();
         if (stuff) {
            new_thing = create_auto_load_object(name, load_info, dest,
                                         tell_pl, move_f);
            if (new_thing) {
               thing->dest_me();
               thing = new_thing;
            }
         }
      }
   } else {
      if ( !find_object( name ) ) {
         if ( !catch( load_object( name ) ) ) {
            thing = find_object( name );
            if ( thing ) {
               auto_clone_alt(thing, load_info, dest, tell_pl, move_f, name);
            } else {
               tell_object( tell_pl, "%^RED%^Could not load "+ name +
          ".%^RESET%^\n" );
            }
         } else {
            tell_object( tell_pl, "%^RED%^Error in loading "+ name +
       ".%^RESET%^\n" );
         }
      } else {
         tell_object( tell_pl, "%^RED%^Object "+ name +
          " exists.%^RESET%^\n" );
      }
   }
   if (_no_calls == 0 && _finished) {
      evaluate(_finished, this_object());
      _finished = 0;
      this_object()->set_no_check( 0 );
      reduce = (int)this_object()->query_max_weight() -
             (int)this_object()->query_loc_weight();
      if ( reduce > 1 ) {
         if ( reduce > 100 ) {
            reduce = 100;
         }
         this_object()->set_max_weight( (int)this_object()->query_max_weight() -
                                 reduce );
      }
      this_object()->calc_burden();
   }
   if (thing) {
      return ({ thing });
   }
   return ({ });
}
private string ident( object thing ) {
   mixed word;
   catch(word = (string)thing->query_short());
   if ( stringp( word ) ) {
      return "\""+ word +"\"";
   }
   return file_name( thing );
}
private void auto_clone_alt( object thing, mixed *load_info,
                     object dest, object tell_pl, function move_f, string name) {
   string ob_path;
   reset_eval_cost();
   if ( load_info[ AUTO_LOAD_STATIC_ARG ] ) {
      catch( thing->init_static_arg( load_info[ AUTO_LOAD_STATIC_ARG ],
                                     tell_pl ) );
   }
   catch( thing->set_player( tell_pl ) );
   if ( load_info[ AUTO_LOAD_DYNAMIC_ARG ] ) {
      catch( thing->init_dynamic_arg( load_info[ AUTO_LOAD_DYNAMIC_ARG ],
                                      tell_pl ));
   }
   ob_path = thing->query_property(VIRTUAL_NAME_PROP);
   if (ob_path) {
      ob_path = CLONER->other_file( ob_path );
      if (file_size(ob_path) < 0) {
         thing->dest_me();
         thing = clone_object( PLAYER_RECEIPT );
         thing->set_object( name );
         thing->set_static_save( load_info );
         thing->set_virtobname( ob_path );
      } else {
         thing->add_property(VIRTUAL_NAME_PROP, ob_path);
      }
   }
   ob_path = CLONER->illegal_thing(base_name(thing), thing->query_short());
   if(ob_path) {
     thing->dest_me();
     thing = clone_object( ob_path );
   }
   move_to_destination(thing, dest, tell_pl, move_f);
}
private void move_to_destination(object thing, object dest, object tell_pl,
                                 function move_f) {
   object place;
   int ret_val;
   string catch_str;
   place = dest;
   ret_val = MOVE_OK - 1;
   while ( place && ret_val != MOVE_OK) {
      catch_str = catch( ret_val =  evaluate(move_f, thing, place ) );
      if(catch_str) {
        tell_object(tell_pl, "%^RED%^Error moving object: " + catch_str +
        ".%^RESET%^\n");
        ret_val = MOVE_OK - 1;
      }
      if (ret_val != MOVE_OK) {
         if ( environment( place ) ) {
            tell_object( tell_pl, "%^RED%^Cannot move "+ ident( thing ) +
       " into "+
       ident( place ) +" (move returned " +
                         catch_str + "); attempting to move it into "+
                  ident( environment( place ) ) +".%^RESET%^\n" );
            place = environment( place );
         } else if ( ( place != environment(tell_pl) ) &&
                     environment( tell_pl ) ) {
            tell_object( tell_pl, "%^RED%^Cannot move "+ ident( thing ) +
       " into "+
       ident( place ) +" (move returned " +
                         ret_val + "); attempting to move it into "
       "environment of " + tell_pl->query_name() +
       ".%^RESET%^\n" );
            place = environment( tell_pl );
         } else  if (place != find_object("/room/broken")) {
            tell_object( tell_pl, "%^RED%^Cannot move "+ ident( thing ) +
       " into "+
       ident( place ) +" (move returned " + ret_val +
                         "); moving it to the room for broken objects "+
                         "--- please ask a creator for help.%^RESET%^\n" );
            load_object("/room/broken");
            place = find_object( "/room/broken" );
         } else {
            tell_object( tell_pl, "%^RED%^Cannot move "+ ident( thing ) +
       " into "+
       " the room for broken objects "+
       "--- This is a serious errror!  Please tell a "
       "creator immediately.%^RESET%^\n");
            place = 0;
         }
         move_f = (: $1->move($2) :);
      }
   }
}
int query_auto_loading() {
   return _no_calls > 0;
}
protected mixed query_auto_load_string() {
   return auto_load;
}
protected void set_auto_load_string(mixed str) {
   auto_load = str;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/telnet.c ===
#include "telnet.h"
nosave string last_term;
nosave int got_terminal;
void check_terminal_type(string type);
void telnet_suboption(string str) {
  switch (str[0]) {
    case TELOPT_TTYPE :
      if (str[1] != TELQUAL_IS)
        return ;
      check_terminal_type(str[2..1000]);
      break;
  }
}
void player_connected() {
  printf("%c%c%c", IAC, DO, TELOPT_TTYPE);
  printf("%c%c%c%c%c%c", IAC, SB, TELOPT_TTYPE, TELQUAL_SEND, IAC, SE);
}
void check_terminal_type(string type) {
  if (last_term == type) {
    if (!got_terminal)
      this_object()->set_network_terminal_type(0);
    return ;
  }
  if (!got_terminal && this_object()->set_network_terminal_type(type))
    got_terminal = 1;
  printf("%c%c%c%c%c%c", IAC, SB, TELOPT_TTYPE, TELQUAL_SEND, IAC, SE);
  last_term = type;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/wiz_inter_comm.c ===
#include <network.h>
private nosave string *imud_ignored;
int do_block(string);
int do_unblock(string);
void wiz_commands() {
  add_command("block", "", (:do_block(0):));
  add_command("block", "<word'name'>", (:do_block($4[0]):));
  add_command("unblock", "<word'name'>", (:do_unblock($4[0]):));
}
int do_block(string str) {
  if (!str) {
    if (!sizeof(imud_ignored)) {
      write("Not blocking anyone.\n");
      return 1;
    }
    write("Blocking "+query_multiple_short(imud_ignored)+".\n");
    return 1;
  }
  if (!pointerp(imud_ignored))
    imud_ignored = ({ lower_case(str) });
  else
    imud_ignored += ({ lower_case(str) });
  write("Okay, now ignoring intermud channel messages from "+str+".\n");
  write("Use \"unblock\" to remove.\n");
  return 1;
}
int do_unblock(string str) {
  int idx;
  if (!str)
    return notify_fail("Syntax: unblock <name>|all\n");
  if (!pointerp(imud_ignored) || !sizeof(imud_ignored))
    return notify_fail("You are not blocking anyone.\n");
  if (str == "all") {
    imud_ignored = 0;
    write("Okay, unblocked everyone.\n");
    return 1;
  }
  if ((idx = member_array(lower_case(str), imud_ignored)) == -1)
    return notify_fail("You are not blocking "+str+".\n");
  imud_ignored = delete(imud_ignored, idx, 1);
  write("Okay, removed "+str+" from your blocked list.\n");
  return 1;
}
int check_not_ignored(string who) {
  if (!pointerp(imud_ignored))
    return 1;
  return member_array(lower_case(who), imud_ignored) == -1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/line_ed.c ===
#include "ed.h"
#include <player_handler.h>
private nosave string *_lines;
private nosave mixed _end_func;
private nosave object _ed_ob = 0;
private nosave int _insertion_point;
private string editor;
private nosave string _filename;
private nosave int _in_editor;
private void main_bit(string str);
int set_editor(string name);
private void editor_do_quit(string str);
private void editor_loop(string str);
private void editor_insert(string str);
private void editor_delete(string str);
private void editor_modify(string str);
private void editor_check_quit(string str);
private void editor_modify2(string str, int range1, int range2);
private void editor_modify3(string str, int range1, int range2,
                            string modify_string);
protected void create()  {
  editor = "menu";
}
protected void editor_commands()  {
  add_command("editor", "{menu|magic|ed|command}", (: set_editor($4[0]) :));
}
varargs int do_edit(string str, mixed end_f, object end_o, string fname,
                    mixed extra)  {
  if (!end_f) {
    printf("Someone has stuffed up - there is no end function.\n");
    return 0;
  } else {
    _end_func = end_f;
  }
  if (!end_o) {
    end_o = previous_object();
  }
  if (!str) {
    str = "";
  }
  if (!strlen(fname)) {
    _filename = TMP_FILE;
  } else {
    _filename = fname;
  }
  if (!functionp(end_f)) {
    if (extra) {
      _end_func = (: call_other($(end_o), $(end_f), $1, $(extra)) :);
    } else {
      _end_func = (: call_other($(end_o), $(end_f), $1) :);
    }
  } else {
    if (extra) {
      _end_func = (: evaluate($(end_f), $1, $(extra)) :);
    } else {
      _end_func = (: evaluate($(end_f), $1) :);
    }
  }
  switch (editor) {
  case "menu":
    _lines = explode(str, "\n") - ({ 0 });
    printf("Enter your text.  Use ** on a line by itself to exit.\n");
    _insertion_point = sizeof(_lines);
    printf("%-2d] ", _insertion_point + 1);
    _in_editor = 1;
    input_to((: editor_loop :));
    return 1;
  case "ed":
    if (strlen(str) && (_filename == TMP_FILE))
      write_file(_filename, str);
    _in_editor = 1;
    ed(_filename, "editor_finish_ed", !this_object()->query_creator());
    return 1;
  case "magic":
    if (strlen(str) && (_filename == TMP_FILE))
      write_file(_filename, str);
    _in_editor = 1;
    _ed_ob = new(PRESTOS_ED, _filename, _filename != TMP_FILE);
    return 1;
  case "command":
    _lines = explode(str, "\n") - ({ 0 });
    printf("Enter your text.  Use ** on a line by itself to exit or "
           "~h for help.\n");
    _insertion_point = sizeof(_lines);
    printf("%-2d] ", _insertion_point + 1);
    _in_editor = 1;
    input_to((: editor_loop :));
    return 1;
  }
}
private void main_bit(string str) {
  int i;
  string s;
  if (str != "") {
    while (str[0] == ' ') {
      str = str[1..];
    }
    switch (str[0]) {
    case 'i':
    case 'I':
      printf("Insert before line: ");
      input_to((: editor_insert :));
      return;
    case 'd':
    case 'D':
      printf("Delete (line no, or n..m ie 1..2): ");
      input_to((: editor_delete :));
      return;
    case 'l':
    case 'L':
      if (!sizeof(_lines))  {
        main_bit("");
      } else {
        s = "";
        for (i = 0; i < sizeof(_lines); i++)
          s += sprintf("%3d: %s\n", i + 1, _lines[i]);
        this_object()->set_finish_func("end_of_edit_more");
        this_object()->more_string(s);
      }
      return;
    case 'm':
    case 'M':
      printf("Modify which line (line no, or n..m ie 1..2): ");
      input_to((: editor_modify :));
      return;
    case 'c':
    case 'C':
      _insertion_point = sizeof(_lines);
      printf("Okay, back into insertion mode.  Use ** on a line "
             "by itself to exit.\n%-2d] ", _insertion_point + 1);
      input_to((: editor_loop :));
      return;
    case 'e':
    case 'E':
      printf("Entering ed... Use \"q\" to quit, \"x\" to save and "
             "quit, \"Q\" to quite without saving changes and \"h\" "
             "for help.\n");
      write_file(_filename, implode(_lines, "\n"));
      ed(_filename, "editor_exit_ed", !this_object()->query_creator());
      return;
    case 's':
    case 'S':
      printf("Quitting and saving.\n");
      editor_do_quit(implode(_lines, "\n"));
      return;
    case 'q':
    case 'Q':
      printf("Are you sure you want to quit? (Y/N) ");
      input_to((: editor_check_quit :));
      return;
    case 'h':
    case 'H':
      s = read_file(ED_HELP_FILE);
      this_object()->set_finish_func("end_of_edit_more");
      this_object()->more_string(s);
      return;
    default:
      printf("I do not understand you.  Try %s for help.\n",
             (editor == "command" ? "~h" : "h" ));
      main_bit("");
      return;
    }
  }
  if (editor == "menu") {
    printf(sizeof(_lines) +" lines - Choose from IDLMCESQ or H for help.");
    input_to((: main_bit :));
  }
  else {
    printf("%-2d] ", _insertion_point + 1);
    input_to((: editor_loop :));
  }
  return;
}
void end_of_edit_more()  {
  this_object()->set_finish_func(0);
  main_bit("");
}
private void editor_delete(string str)  {
  int num1, num2, tmp;
  if (sscanf(str, "%d..%d", num1, num2) == 2)  {
    if (num1 > num2)  {
      tmp = num1;
      num1 = num2;
      num2 = tmp;
    }
    if ((num1 < 1) || (num2 > (sizeof(_lines) + 1))) {
      printf("Out of bounds.\n");
      main_bit("");
    }
    printf("Deleting from line %d to line %d.\n", num1, num2);
    _lines = delete(_lines, num1 - 1, num2 - num1 + 1);
    printf("Okay.\n");
    main_bit("");
    return;
  }
  if (sscanf(str, "%d", num1) == 1)  {
    if ((num1 < 1) || (num1 > (sizeof(_lines) + 1)))  {
      printf("Line number out of range.\n");
      main_bit("");
      return;
    }
    printf("Deleting line %d.\n", num1);
    _lines = delete(_lines, num1 - 1, 1);
    printf("Okay.\n");
    main_bit("");
    return;
  }
  printf("Error: invalid data %s.\n", str);
  main_bit("");
  return;
}
private void editor_insert(string str)  {
  int num;
  if (sscanf(str, "%d", num) != 1)  {
    printf("Error: must be a number.\n");
    main_bit("");
    return;
  }
  if ((num < 1) || (num > (sizeof(_lines) + 1))) {
    printf("Error: number out of bounds.\n");
    main_bit("");
    return;
  }
  _insertion_point = num - 1;
  printf("Inserting before line %d.  Entering insertion mode.  Use ** on a "
         "line by itself to exit\n%-2d] ", num, num);
  input_to((: editor_loop :));
  return;
}
private void editor_loop(string str) {
  if ((strlen(str) > 1) && (str[0] == '~') && (editor == "command")) {
    main_bit(str[1..]);
    return;
  }
  if (str == "**") {
    if (editor == "menu") {
      main_bit("");
    } else if (sizeof(_lines)) {
      editor_do_quit(implode(_lines, "\n"));
    } else {
      editor_do_quit(0);
    }
    return;
  }
  _lines = _lines[0.._insertion_point - 1] + ({ str }) +
    _lines[_insertion_point..];
  ++_insertion_point;
  printf("%-2d] ", _insertion_point + 1);
  input_to((: editor_loop :));
  return;
}
private void editor_modify(string str)  {
  int num1, num2, tmp;
  if (sscanf(str, "%d..%d", num1, num2) == 2)  {
    if (num1 > num2)  {
      tmp = num1;
      num1 = num2;
      num2 = tmp;
    }
    if ((num1 < 1) || (num2 > (sizeof(_lines) + 1))) {
      printf("Error: number out of bounds.\n");
      main_bit("");
    }
    printf("Modifying from line %d to line %d.\n", num1, num2);
    printf("Text to change? ");
    input_to((: editor_modify2 :), 0, num1, num2);
    return;
  }
  if (sscanf(str, "%d", num1) == 1)  {
    if ((num1 < 1) || (num1 > (sizeof(_lines) + 1)))  {
      printf("Error: line number out of range.\n");
      main_bit("");
      return;
    }
    printf("Modifying line %d.\n", num1);
    printf("Text to change? ");
    input_to((: editor_modify2 :), 0, num1, num1);
    return;
  }
  printf("Error: invalid data %s.\n", str);
  main_bit("");
  return;
}
private void editor_modify2(string str, int range1, int range2)  {
  if (!strlen(str))  {
    printf("Aborting.\n");
    main_bit("");
    return;
  }
  printf("Change to: ");
  input_to((: editor_modify3 :), 0, range1, range2, str);
  return;
}
private void editor_modify3(string str, int range1, int range2,
                            string modify_string) {
  int i;
  printf("Changing all occurrences of \"%s\" to \"%s\" from line %d to "
         "line %d.\n", modify_string, str, range1, range2);
  for (i = range1 - 1; (i < range2) && (i < sizeof(_lines)); i++) {
    _lines[i] = replace_string(_lines[i], modify_string, str);
      printf("%3d: %s\n", i + 1, _lines[i]);
  }
  printf("Done.\n");
  main_bit("");
  return;
}
void editor_exit_ed()  {
  string str;
  str = read_file(_filename);
  if ((file_size(_filename) >= 0) && !rm(_filename))
    log_file(LOG_FILE, "ed: couldn't rm %s\n", _filename);
  _lines = explode("#" + str, "\n");
  _lines[0] = _lines[0][1..];
  main_bit("");
  return;
}
void editor_finish_ed()  {
  string str;
  str = read_file(_filename);
  if ((file_size(_filename) >= 0) && (_filename == TMP_FILE) &&
      !rm(_filename)) {
    log_file(LOG_FILE, "ed: couldn't rm %s\n", _filename);
  }
  if (!str)  {
    printf("Aborted.\n");
    editor_do_quit(0);
    return;
  }
  if (_filename == TMP_FILE)  {
    editor_do_quit(str);
  } else {
    editor_do_quit(0);
  }
  return;
}
void editor_do_quit(string str)  {
  _lines = ({ });
  if ((editor == "magic") && (_filename == TMP_FILE) &&
      (file_size(_filename) >= 0) && !rm(_filename))  {
    printf("magic: couldn't remove %s\n" , _filename);
    str = 0;
  }
  _in_editor = 0;
  if (_ed_ob) {
    destruct(_ed_ob);
  }
  evaluate(_end_func, str);
}
private void editor_check_quit(string str)  {
  if ((str != "") && (str[0] != 'y') && (str[0] != 'Y')) {
    printf("Returning to the editor.\n");
    main_bit("");
    return;
  }
  printf("Quitting.\n");
  editor_do_quit(0);
  return;
}
int set_editor(string str)  {
  editor = str;
  printf("Editor set to %s.\n", str);
  return 1;
}
string append_signature() {
  return PLAYER_HANDLER->query_signature(this_object()->query_name());
}
void editor_check_do_quit()  {
  if (_in_editor)  {
    printf("Saving what you are editing.\n");
    if (editor != "ed") {
      editor_do_quit(implode(_lines, "\n"));
    } else {
      editor_finish_ed();
    }
  }
}
string query_editor() {
  return editor;
}
int query_in_editor() {
  return _in_editor;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/more_string.c ===
#define COLS (int)this_object()->query_cols()
#define ROWS ( (int)this_object()->query_rows() - 1 )
class more_string_info {
   int fsize;
   int topl;
   int botl;
   string last_search;
   string *the_bit;
   string finish_func;
   string more_bit;
   string stat_line;
   object finish_ob;
}
private nosave mixed *_pending_more;
private class more_string_info _current_info;
int internal_more_string();
void create() {
   add_command("Internal_More_String", "<string>", (:internal_more_string:));
}
private void string_display_file(class more_string_info info) {
  int i;
  string stuff;
  info->botl = info->topl + ROWS;
  stuff = "";
  for ( i = info->topl; ( i < info->botl ) && ( i < info->fsize ); i++ ) {
    stuff += info->the_bit[ i ] +"\n";
  }
  efun::tell_object( this_object(), stuff );
}
private void more_string_status_line(class more_string_info info) {
   string *frog;
   string s;
   int i;
   int percentage;
   if (!info->stat_line) {
      info->stat_line = "$N From $T to $B of $S ($%%) - h for help. ";
   }
   s = "";
   frog = explode(info->stat_line, "$");
   for (i=0;i<sizeof(frog);i++) {
      if (frog[i] == "") {
         s += "$";
         i ++;
      } else switch (frog[i][0]) {
         case 'N' :
            s += info->more_bit+frog[i][1..];
            break;
         case 'T' :
            s += ( info->topl + 1 ) + frog[ i ][ 1 .. ];
            break;
         case 'B' :
            if (info->botl > info->fsize)
               s += info->fsize+frog[i][1..];
            else
               s += info->botl+frog[i][1..];
            break;
         case '%' :
            percentage = (info->botl*100)/info->fsize;
            if (percentage > 100) {
               percentage = 100;
            }
            s += percentage + frog[i][1..];
            break;
         case 'S' :
            s += info->fsize + frog[i][1..];
            break;
      }
   }
   efun::tell_object( this_object(), (string)this_object()->fix_string( s ) );
   return;
}
private void string_next_page(string str, class more_string_info info) {
   int num;
   int noargs;
   int i;
   int redraw;
   string s1;
   if (!str) {
     str = "";
   }
   if (sscanf(str,"%d%s", num, str) != 2) {
     noargs = 1;
   }
   s1 = str[1..];
   if (str == "") {
      str = "f";
   }
   switch(str[0]) {
      case 'h' :
         cat("/doc/helpdir/more");
         break;
      case 'q' :
         if (info->finish_func) {
            if (functionp(info->finish_func)) {
               evaluate(info->finish_func);
            } else {
               call_other(info->finish_ob, info->finish_func);
            }
         }
         info->finish_func = 0;
         _current_info = 0;
         return;
      case 'f' :
      case 'F' :
         info->topl += ROWS;
         redraw = 1;
         break;
      case 'b' :
      case 'B' :
         info->topl -= ROWS;
         redraw = 1;
         break;
      case '/' :
         i = info->topl + 4;
         if (!s1 || s1 == "") {
            s1 = info->last_search;
         }
         if (!s1 || s1 == "") {
            s1 = "bing!";
         }
         for (i = info->topl + 4; i < info->fsize; i++) {
            if (strsrch(info->the_bit[i], s1) != -1) {
               if (num-- <= 0) {
                  break;
               }
            }
         }
         if (i == info->fsize) {
            tell_object( this_object(), "Sorry "+ s1 +" not found.\n" );
         } else {
            tell_object( this_object(), "Found " + s1 + " on line "+ i +".\n");
            info->topl = i - 3;
         }
         redraw = 1;
         break;
      case '?' :
         if (!s1 || s1 == "") {
            s1 = info->last_search;
         }
         if (!s1 || s1 == "") {
            s1 = "bing!";
         }
         for (i = info->topl + 2; i > 0; i--) {
            if (strsrch(info->the_bit[i], s1) != -1) {
               if (num-- <= 0) {
                  break;
               }
            }
         }
         if (i == 0) {
            tell_object(this_object(), "Sorry " + s1 + " not found.\n");
         } else {
            info->topl = i - 3;
         }
         redraw = 1;
         break;
      case 'b' :
         if (info->topl > 0) {
            info->topl -= ROWS;
            redraw = 1;
            if (info->topl < 0) {
               info->topl = 0;
            }
         }
         break;
      case 'g' :
         info->topl = num;
         if (info->topl >= info->fsize)
            info->topl = info->fsize - 2;
         redraw = 1;
         break;
      case 'G' :
         redraw = 1;
         if (noargs)
            info->topl = info->fsize - ROWS;
         else
            info->topl = num;
         if (info->topl > info->fsize)
            info->topl = info->fsize - 2;
         break;
   }
   if (info->topl < 0) {
      info->topl = 0;
   }
   if (redraw) {
      string_display_file(info);
      if ( info->botl < info->fsize ) {
         more_string_status_line(info);
         input_to((: string_next_page :), 0, info);
      } else {
         if (info->finish_func) {
            if ( info->finish_ob ) {
               call_other(info->finish_ob, info->finish_func);
            }
            info->finish_func = 0;
         }
         _current_info = 0;
      }
   } else {
      more_string_status_line(info);
      input_to((: string_next_page :), 0, info);
   }
}
varargs int more_string( string text, string bity, int noreline ) {
  int i, ncols;
  string *bits;
  class more_string_info info;
  mixed func;
  if ( this_player() != this_object() ){
     if ( !_pending_more ) {
        _pending_more = ({ ({ text, bity, noreline }) });
     } else {
        _pending_more += ({ ({ text, bity, noreline }) });
     }
     this_object()->ignore_from_history("Internal_More_String something");
     command( "Internal_More_String something" );
     return 1;
  }
  if (!_current_info) {
     _current_info = new(class more_string_info);
  }
  info = _current_info;
  if ( bity ) {
    info->more_bit = bity;
  } else {
    info->more_bit = "--- MORE";
  }
  info->last_search = "";
  if ( !stringp( text ) || !strlen( text ) ) {
    return notify_fail( "Empty string.\n" );
  }
  if ( noreline ) {
    info->the_bit = explode( this_object()->fix_string( text ), "\n" );
  } else {
    text = this_object()->convert_message( text );
    text = this_object()->fit_message( text );
    text = this_object()->fix_string( text );
    info->the_bit = ({ });
    ncols = COLS;
    bits = explode( text, "\n" );
    for ( i = 0; i < sizeof( bits ); i++ ) {
      reset_eval_cost();
      if ( bits[ i ] == "" ) {
        info->the_bit += ({ "" });
      } else {
        info->the_bit +=
          explode( this_object()->fix_string( bits[ i ], ncols ), "\n" );
      }
    }
  }
  info->fsize = sizeof( info->the_bit );
  info->topl = 0;
  string_display_file(info);
  if ( info->botl < info->fsize ) {
    more_string_status_line(info);
    input_to( (: string_next_page :), 0, info );
  } else {
      if ( info->finish_func ) {
         if ( !info->finish_ob ) {
            info->finish_func = 0;
            return 1;
         }
         func = info->finish_func;
         info->finish_func = 0;
         call_other( info->finish_ob, func );
      }
      _current_info = 0;
  }
  return 1;
}
varargs void set_finish_func(string str, object ob) {
  if (!_current_info) {
     _current_info = new(class more_string_info);
  }
  _current_info->finish_func = str;
  if (!ob) {
    _current_info->finish_ob = previous_object();
  } else {
    _current_info->finish_ob = ob;
  }
}
private int internal_more_string() {
   string text, bity;
   int noreline;
   if ( sizeof( _pending_more ) ) {
      text = _pending_more[ 0 ][ 0 ];
      bity = _pending_more[ 0 ][ 1 ];
      noreline = _pending_more[ 0 ][ 2 ];
      _pending_more = _pending_more[ 1 .. <1 ];
      more_string( text, bity, noreline );
   }
   return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/wiz_present.c ===
#include <obj_parser.h>
string desc_object(mixed o){
  string str;
  if (!o) return "** Null-space **";
  if (!catch(str = (string)o->short()) && str) return str;
  if (!catch(str = (string)o->query_name()) && str) return str;
  return file_name(o);
}
string desc_f_object(object o){
  string str, tmp;
  str = desc_object(o);
  if (o && str != file_name(o)) {
    if (tmp)
      str += " (" + tmp + ")";
    else
      str += " (" + file_name(o) + ")";
  }
  return str;
}
object *wzpresent2(string str, mixed onobj) {
  object *obs, ob, *obs2, obj;
  string s1;
  class obj_match result;
  if (pointerp(onobj)) {
    obs = ({ });
    foreach(ob in onobj)
      obs += wzpresent2(str,ob);
    return obs;
  }
  if (str == "all")
    return all_inventory(onobj);
  if (sscanf(str,"every %s",s1) == 1) {
    obs2 = all_inventory(onobj);
    obs = ({ });
    foreach (ob in obs2)
      if (ob->id(s1)) obs += ({ ob });
    return obs;
  }
  result = (class obj_match)match_objects_in_environments(str,onobj);
  if (result->result == OBJ_PARSER_SUCCESS ||
      result->result == OBJ_PARSER_AMBIGUOUS) {
    return result->objects;
  }
  if (obj = present(str,onobj)) return ({ obj });
  for (obj = first_inventory(onobj); obj; obj = next_inventory(obj)) {
    s1 = file_name(obj);
    if (sscanf(s1, "%*s/"+str+"#%*d") || sscanf(s1, "%*s#"+str))
      return ({ obj });
  }
  return ({ });
}
varargs object *wiz_present(string str, object onobj, int nogoout) {
  int j;
  object ob, *obs, *obs2;
  string s1, s2, *sts;
  mixed thing;
  class obj_match result;
  if (!str || !onobj)
    return ({ });
  seteuid(geteuid(this_player()));
  if(str[0] == '@') {
    if (ob = find_living(
        (string)this_player()->expand_nickname(extract(str, 1))))
      return ({ ob });
    notify_fail("Unable to find living object: "+extract(str,1)+".\n");
    return ({ });
  }
  if (str == "me") return ({ this_player() });
  if (str == "here") return ({ environment(this_player()) });
  if( str == "everyone") {
    if(!this_object()->query_lord())
      return ({ });
    obs = users();
    if(nogoout)
      return filter( obs, (: environment( $1 ) == $(onobj) :) );
    return obs;
  }
  if( str == "creators" ) {
    obs = filter( users(), (: $1->query_creator() :) );
    if(nogoout)
      return filter( obs, (: environment( $1 ) == $(onobj) :) );
    return obs;
  }
  if(str[0] == '/') {
    if (ob = find_object(str)) return ({ ob });
    if (sizeof((sts = (string *)this_player()->get_cfiles(str))))  {
      obs = ({ });
      obs = map(sts, (: find_object($1) :)) - ({0});
      return obs;
    }
    notify_fail("No loaded object: "+str+".\n");
    return ({ });
  }
  if (str[0] == '(' && str[strlen(str) - 1] == ')') {
    obs = wiz_present(extract(str,1,strlen(str) - 2),onobj);
    if (!sizeof(obs)) return obs;
    obs = map(obs, (: environment($1) :)) - ({0});
    return obs;
  }
  if (sscanf(str,"%s on %s",s1,s2) == 2 ||
      sscanf(str,"%s in %s",s1,s2) == 2) {
    obs = wiz_present(s2, onobj);
    if (!sizeof(obs)) return obs;
    obs2 = ({ });
    foreach (ob in obs)
      obs2 += wiz_present(s1, ob, 1);
    return obs2;
  }
  if (sscanf(str,"%s and %s",s1,s2) == 2) {
    obs = wiz_present(s1, onobj);
    obs2= wiz_present(s2, onobj);
    obs2 += filter(obs, (: member_array($1, $(obs2)) < 0 :));
    return obs2;
  }
  if (sscanf(str,"%s except %s",s1,s2) == 2 ||
      sscanf(str,"%s but %s",s1,s2) == 2) {
    obs = wiz_present(s1, onobj);
    obs2= wiz_present(s2, onobj);
    foreach (ob in obs2)
      while ((j=member_array(ob, obs)) > -1)
        obs = delete(obs,j--,1);
    return obs;
  }
  if (sscanf(str, "env of %s", s1) == 1) {
    obs = wiz_present(s1, onobj);
    if (!sizeof(obs)) {
       return obs;
    }
    return map(obs, (: environment($1) :)) - ({0});
  }
  if (sscanf(str, "children of %s", s1) == 1) {
    obs = wiz_present(s1, onobj);
    obs2 = ({ });
    foreach (ob in obs) {
      s1 = file_name(ob);
      sscanf(s1, "%s#%*d", s1);
      obs2 += children(s1);
    }
    return obs2;
  }
  if (sscanf(str,"player %s",s1)) {
    return ({ find_player(s1) });
  }
  if (!sizeof(obs2 = wzpresent2(str,onobj)) && !nogoout) {
    obs2 = wzpresent2(str, environment(onobj));
  }
  if (sizeof(obs2)) {
    return obs2;
  }
  result = (class obj_match)match_objects_in_environments(str,onobj);
  if (result->result == OBJ_PARSER_SUCCESS ||
      result->result == OBJ_PARSER_AMBIGUOUS) {
    return result->objects;
  }
  ob = find_living( this_player()->expand_nickname(str) );
  if( ob && ( !nogoout || ( environment(ob) == onobj ) ) )
    return ({ ob });
  if (thing = this_player()->get_obvar(str)) {
    if (objectp(thing)) return ({ thing });
    if (pointerp(thing)) {
      return filter( thing, (: objectp( $1 ) :) );
    }
  }
  if (sizeof((sts = (string *)this_player()->get_cfiles(str))))  {
    obs = ({ });
    obs = map(sts, (: find_object($1) :)) - ({0});
    return obs;
  }
  return ({ });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/wiz_info_comm.c ===
#define PEOPLER "/obj/handlers/peopler"
protected int do_gauge(string str);
int add_command(string name, object ob, string format, function func);
protected void wiz_commands() {
  add_command("gauge", this_object(), "<string>", (: do_gauge($4[0]) :));
  if(clonep())
    call_out("driver_version", 20);
}
int driver_version(){
  string old = this_object()->query_property("driver_version");
  if(!old) {
    return this_object()->add_property("driver_version", __VERSION__);
  }
  if(old != __VERSION__){
    this_object()->add_property("driver_version", __VERSION__);
    write("%^RED%^The driver has been changed to version " +
          __VERSION__ + ", see /doc/driver/Changes for more information.%^RESET%^\n");
  }
  return 1;
}
int review() {
  PEOPLER->review();
  return 1;
}
protected int do_gauge(string str) {
  int eval_cost;
  if (this_player(1) != this_object()) return 0;
  if(!str) {
    notify_fail("Usage : gauge command.\n");
    return 0;
  }
  eval_cost = command(str);
  write("\nThe command '" + str + "' took: " + eval_cost + " CPU cycles.\n");
  return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/guild-race.c ===
#include <player.h>
#include <command.h>
string race_ob, guild_ob,  *known_commands;
mixed *guild_data;
nosave string _race;
void race_guild_commands() {
  string command;
  string *bing;
  string *paths = ({ });
  if (!known_commands) {
    known_commands = ({ "skills", "rearrange", "gp", "newbie" });
  }
  foreach (command in known_commands) {
    bing = CMD_D->GetPaths(command);
    if (sizeof(bing)) {
      bing = filter(bing, (: $1[0..15] == "/cmds/guild-race" :));
      paths += bing;
    }
  }
  this_object()->AddSearchPath(paths);
  if (guild_ob) {
    catch(guild_ob->start_player(this_object()));
  }
  catch(race_ob->start_player(this_object()));
  this_object()->query_limbs();
}
string query_gtitle() {
  string tmp;
  if (guild_ob)
    if (catch((tmp = (string)guild_ob->query_title(this_object()))))
        tmp = "Has a broken guild";
  return tmp;
}
void set_race_ob(string str) {
  string frog;
  if(sscanf(str, "/%s", frog)==1)
    str = extract(str, 1);
  if (str[0..strlen("std/races")-1]!="std/races") {
    write("Illegal path to set_race_ob.\n");
    return;
  }
  if(str[0..strlen("std/races/god")-1] == "std/races/god" &&
     !"/secure/master"->god(geteuid())) {
    write("The heavens rumble and the earth shakes.  You stop.\n");
  }
  else
    race_ob = str;
}
string query_race_ob() { return race_ob; }
void set_guild_ob( string str ) {
  if(str) {
    if(str[0..10] != "/std/guilds") {
      tell_object(this_object(), "Attempt to set invalid guild object " +
                  str + "\n");
      return;
    } else if(!find_object(str)) {
      tell_object(this_object(), "No such object "+ str +"\n");
      return;
    }
  }
  guild_ob = str;
}
 string query_guild_ob() {
   if ( !guild_ob ) {
      return 0;
   }
   if(guild_ob[0..10] != "/std/guilds")
     return 0;
   return guild_ob;
}
void set_guild_data(mixed *dat) { guild_data = dat; }
mixed *query_guild_data() {
  return guild_data;
}
string query_race() {
  if(!_race)
    _race = (string)race_ob->query_name();
  return _race;
}
string help_command(string str) {
  class command cmd = new(class command, verb : str);
  string path;
  mixed func;
  if ((member_array(str, known_commands) != -1 ||
       this_object()->query_creator()) &&
      CMD_D->HandleStars(cmd)) {
    path =  CMD_D->GetPaths(cmd->verb)[0] + "/" + cmd->verb;
    func = path->help_function();
    if (func) {
       return func;
    }
    return path->help();
  }
  return 0;
}
string *query_known_commands() { return copy(known_commands); }
int query_known_command( string word ) {
   return ( member_array( word, known_commands ) != -1 );
}
int add_known_command(string str) {
  string *paths;
  if (member_array(str, known_commands) != -1) {
    return 0;
  }
  if (!CMD_D->IsGRCommand(str)) {
    return 0;
  }
  paths = CMD_D->GetPaths(str);
  paths = filter(paths, (: $1[0..15] == "/cmds/guild-race" :));
  if (sizeof(paths)) {
    this_object()->AddSearchPath(paths);
  }
  known_commands += ({ str });
  if ( interactive( this_object() ) )
    log_file( "ADD_KNOWN_COMMAND", "%s: %s was added to %s by: %O.\n", ctime( time() ),
        str, this_player()->query_name(), map( previous_object( -1 ), (: ({ $1,  $1->query_name() }) :) ) );
  return 1;
}
int remove_known_command(string str) {
  int i;
  i = member_array(str, known_commands);
  if (i == -1) {
    return 0;
  }
  known_commands = known_commands[0..i-1] + known_commands[i+1..];
  return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/parser.c ===
#include <creator.h>
#include <parser.h>
#define LMASTER "/d/liaison/master"
int pos, force_string;
mixed func;
protected void create() {
  seteuid("Root");
}
mixed *parse_args(string str, string close) {
  mixed *args, *m, *m2;
  object *obs;
  string s1, s2, s3, s4, s5, s6, s7;
  int i;
  mapping map;
  args = ({ });
  while (strlen(str)) {
    while (strlen(str) && str[0] == ' ') str = str[1..<1];
    if (!strlen(str) || str[0..0] == close) return ({ args, str[1..<1] });
    switch (str[0]) {
      case '\'' :
        if (sscanf(str, "'%s'%s", s1, s2) != 2) {
          printf("Unterminated string.\n");
          return 0;
        }
        args += ({ replace_string(s1, "\\n", "\n") });
        str = s2;
        break;
      case '`' :
        if (sscanf(str, "`%s`%s", s1, s2) != 2) {
          printf("Unterminated string.\n");
          return 0;
        }
        args += ({ replace_string(s1, "\\n", "\n") });
        str = s2;
        break;
      case '"' :
        if (sscanf(str, "\"%s\"%s", s1, s2) != 2) {
          printf("Unterminated string.\n");
          return 0;
        }
        args += ({ replace_string(s1, "\\n", "\n") });
        str = s2;
        break;
      case '{' :
        m = parse_args(str[1..<1], "}");
        if (!m) {
          return 0;
        }
        args += ({ m[0] });
        str = m[1];
        break;
      case '[' :
       if (sscanf(str[1..<1], "%s]%s", s1, s2) != 2) {
          printf("Unmatched [.\n");
          return 0;
        }
        str = str[1..<1];
        map = ([ ]);
        while (1) {
          m = parse_args(str, ":");
          if (!m) {
            while (strlen(str) && str[0] == ' ') {
               str = str[1..<1];
            }
            if (str[0] == ']') {
              break;
            }
          }
          if (!(m2 = parse_args(str, ","))) {
            if (!(m2 = parse_args(str, "]"))) {
              return 0;
            }
            if (sizeof(m[0])) {
              map[m[0][0]] = (sizeof(m2[0])?m2[0][0]:0);
            }
            break;
          }
          if (sizeof(m[0])) {
            map[m[0][0]] = (sizeof(m2[0])?m2[0][0]:0);
          }
        }
        args += ({ map });
        break;
      case '|' :
        if (sscanf(str, "|%s|%s", s1, s2) != 2) {
          printf("Unmatched |\n");
          return 0;
        }
        obs = WIZ_PRESENT->wiz_present(str, this_player());
        if (!sizeof(obs)) {
          args += ({ this_player() });
        } else if (sizeof(obs) == 1) {
          args += ({ obs[0] });
        } else {
          args += ({ obs });
        }
        str = s2;
        break;
      case '0'..'9' :
      case '-' :
        if (sscanf(str, "%d%s", i, str) != 2) {
          printf("Number expected.\n");
          return 0;
        }
        args += ({ i });
        break;
      default :
        s2 = s3 = 0;
        sscanf(str, "%s,%s", s4, s2);
        sscanf(str, "%s"+close+"%s", s5, s3);
        if (sscanf(str, "%s->%s", s6, s7) == 2 &&
            (!s3 || strlen(s5) > strlen(s6)) &&
            (!s2 || strlen(s4) > strlen(s6))) {
          while (s7[0] == ' ') s7 = s7[1..<1];
          if (sscanf(s7, "%s(%s", s1, s7) != 2) {
            printf("'(' expected.\nLine left unprocessed %s\n", s7);
            return 0;
          }
          obs = WIZ_PRESENT->wiz_present(s6, this_player());
          if (!sizeof(obs)) {
            printf("The object %s needs to exist.\n", s6);
            return 0;
          }
          m = parse_args(s7, ")");
          if (!m) {
             return 0;
          }
          if (sizeof(m[0]) < 6) {
             m[0] += allocate(6-sizeof(m[0]));
          }
          obs = map_array(obs, "mapped_call", this_object(), s1, m[0]);
          if (sizeof(obs) == 1) {
            args += obs;
          } else {
            args += ({ obs });
          }
          str = m[1];
          break;
        } else if (s2 && s3)
          if (strlen(s4) < strlen(s5)) {
            s1 = ",";
            str = s4;
          } else {
            s1 = close;
            s2 = s3;
            str = s5;
          } else if (s2) {
            s1 = ",";
            str = s4;
          } else if (s3) {
            s1 = close;
            s2 = s3;
            str = s5;
          } else {
            s1 = "";
            s2 = "";
          }
          obs = WIZ_PRESENT->wiz_present(str, this_player());
          if (!sizeof(obs)) {
            if (str[0] >= '0' && str[0] <= '9' || str[0] == '-') {
              sscanf(str, "%d%s", i, str);
              args += ({ i });
            } else
              args += ({ replace_string(str, "\\n", "\n") });
          } else if (sizeof(obs) == 1)
            args += ({ obs[0] });
          else
            args += ({ obs });
          str = s1+s2;
          break;
    }
    while (strlen(str) && str[0] == ' ') {
       str = str[1..<1];
    }
    if (!strlen(str)) {
      return ({ args, str });
    }
    if (str[0..0] == close) {
      return ({ args, str[1..<1] });
    }
    if (str[0] != ',') {
      printf("Parse error reading arguments, ',' or '%s' expected.\n", close);
      printf("Line left unprocessed %s\n", str);
      return 0;
    }
    str = str[1..<1];
  }
  return ({ args, str });
}
#ifdef NOPE
void inform_of_call(object ob, mixed *argv) {
  string str;
  int i;
  str = this_object()->query_cap_name() + " calls " + argv[0] + "(";
  for (i=1; i<sizeof(argv); ) {
    str += replace(sprintf("%O", argv[i]), "\n", " ");
    if (++i < sizeof(argv)) str += ",";
  }
}
#endif
protected mixed mapped_call(object ob, string func, mixed *argv) {
  return call_other(ob, func, argv ...);
}
protected int parse_frogs(string str) {
  mixed junk;
  junk = parse_args(str, ";");
  if (!junk)
    return 1;
  write("The line "+str+" returns: \n");
  printf("%O\n", junk[0]);
  return 1;
}
mixed expr();
protected mixed bit4() {
  mixed val1, val2, val3;
  if (pos < sizeof(func)) {
    if (pointerp(func[pos])) {
      return func[pos++][0];
    }
    if (stringp(func[pos])) {
      if (func[pos][0] == '$') {
        val1 = (object)this_player()->get_obvar(func[pos][1..<1]);
        pos++;
        return val1;
      }
      if (force_string) {
        force_string = 0;
        return func[pos++];
      }
      val1 = (object *)WIZ_PRESENT->wiz_present(func[pos], this_player());
      if (!sizeof(val1)) {
        return func[pos++];
      }
      pos++;
      if (sizeof(val1) == 1) {
        return val1[0];
      }
      return val1;
    }
    switch (func[pos]) {
      case TOK_OBRAC :
        pos++;
        val1 = expr();
        if (func[pos] != TOK_CBRAC) {
          printf("Mismatched brackets.\n");
        } else {
          pos++;
        }
        break;
      case TOK_SARRAY :
        pos++;
        val1 = ({ });
        while (pos < sizeof(func) &&
            func[pos] != TOK_EARRAY) {
          if (func[pos] == TOK_COMMA) {
             pos++;
          }
          val2 = expr();
          if (func[pos] != TOK_COMMA &&
              func[pos] != TOK_EARRAY) {
            printf("Error processing array.\n");
            return 0;
          }
          val1 += ({ val2 });
        }
        pos++;
        break;
      case TOK_SMAPPING :
        pos++;
        val1 = ([ ]);
        while (pos < sizeof(func) && func[pos] != TOK_EMAPPING) {
          if (func[pos] == TOK_COMMA) pos++;
          val2 = expr();
          if (func[pos] != TOK_COLON) {
            printf("Error processing mapping, expected :.\n");
            return 0;
          }
          pos++;
          val3 = expr();
          if (func[pos] != TOK_EMAPPING && func[pos] != TOK_COMMA) {
            printf("Error processing mapping, expected , or ].\n");
            return 0;
          }
          val1[val2] = val3;
        }
        printf("End of mapping.\n");
        pos++;
        break;
      default :
        printf("Broken parser....\n");
        break;
    }
  }
  return val1;
}
protected mixed do_function_call(object ob, string name, mixed stuff) {
  string found;
  object shad;
  if (objectp(ob)) {
    shad = ob;
    while ((shad = shadow(shad, 0))) {
      if ((found = function_exists(name, ob)))
        break;
    }
    if (!found && !(found = function_exists(name, ob))) {
      printf("*** function %s not found in %s ***\n",
          name, file_name(ob));
      return 0;
    } else {
      printf("*** function %s on %s found in %s ***\n", name, file_name(ob),
          found);
    }
    if ((ob != this_player()) && ob->query_property("player") &&
        !ob->query_property("no score")) {
        unguarded((: write_file,
                   (LMASTER->query_member(this_player()->query_name()) ?
                    "/d/admin/log/CALL_LIAISONS.log" :
                    "/d/admin/log/CALL_CREATORS.log" ),
                   sprintf("%s: %s (%O) called %s(%s) on %s (%O)\n",
                           ctime(time()),
                           this_player()->query_name(), this_player(),
                           name,
                           implode(stuff - ({0}), ", "), ob->query_name(),
                           ob) :));
        user_event( this_object(), "inform",
              sprintf("%s called %s(%s) on %s",
            this_player()->query_name(), name, implode(stuff - ({0}), ", "),
            ob->query_name()), "calls");
    }
    return call_other(ob, name, stuff[0], stuff[1], stuff[2],
        stuff[3], stuff[4], stuff[5]);
  }
  return 0;
}
protected mixed bit3() {
  mixed *tmp, val1, val2, val3;
  int i;
  val1 = bit4();
  while (pos < sizeof(func)) {
    switch (func[pos]) {
      case TOK_CALL :
        pos++;
        force_string = 1;
        val2 = bit4();
        force_string = 0;
        if (func[pos] != TOK_OBRAC) {
          printf("Open bracket expected.\n");
        } else {
          tmp = ({ });
          pos++;
          while (pos < sizeof(func) && func[pos] != TOK_CBRAC) {
            if (func[pos] == TOK_COMMA) pos++;
            val3 = expr();
            if (func[pos] != TOK_COMMA && func[pos] != TOK_CBRAC) {
              printf("Error in function arguments.\n");
              return 0;
            }
            tmp += ({ val3 });
          }
          pos++;
        }
        if (objectp(val1)) {
          val1 = ({ val1 });
        }
        if (!pointerp(val1)) {
          printf("Array or object expected for function call.\n");
          break;
        }
        if (!stringp(val2)) {
          printf("String expected for the function call name.\n");
          break;
        }
        if (sizeof(tmp) < 6) {
          tmp += allocate(6-sizeof(tmp));
        }
        for (i=0;i<sizeof(val1);i++) {
          val1[i] = do_function_call(val1[i], val2, tmp);
        }
        if (sizeof(val1) == 1) {
          val1 = val1[0];
        }
        break;
      case TOK_SMAPPING :
        pos++;
        val2 = expr();
        if (func[pos] == TOK_DOTDOT) {
          pos++;
          val3 = expr();
          if (func[pos] != TOK_EMAPPING) {
            printf("Expected closeing ].\n");
            break;
          }
          pos++;
          if (!pointerp(val1)) {
            printf("Can only use the .. syntax on arrays.\n");
            break;
          }
          if (!intp(val2) || !intp(val3)) {
            printf("Indexes must be integers.\n");
            break;
          }
          val1 = val1[val2..val3];
          break;
        }
        if (func[pos] != TOK_EMAPPING) {
          printf("Expected closeing ].\n");
          break;
        }
        pos++;
        if (mapp(val1)) {
          val1 = val1[val2];
        } else if (pointerp(val1)) {
          if (!intp(val2)) {
            printf("Can only use integers as an index on an array.\n");
          } else if (val2 < 0 || val2 >= sizeof(val1)) {
            printf("Index out of bounds.\n");
          } else {
            val1 = val1[val2];
          }
        } else {
          printf("Can only index off arrays or mappings.\n");
        }
        break;
      default :
        return val1;
    }
  }
  return val1;
}
protected mixed bit2() {
  mixed val1, val2;
  val1 = bit3();
  while (pos < sizeof(func)) {
    switch (func[pos]) {
      case TOK_MULT :
        pos ++;
        val2 = bit3();
        if ((!intp(val1) && !floatp(val1)) || (!intp(val2) && !floatp(val2))) {
          printf("Incompatible types in multiply, both must be integers.\n");
          val1 = 0;
        } else {
          val1 = val1*val2;
        }
        break;
      case TOK_DIV :
        pos ++;
        val2 = bit3();
        if ((!intp(val1) && !floatp(val1)) || (!intp(val2) && !floatp(val2))) {
          printf("Incompatible types in division, both must be integers.\n");
          val1 = 0;
        } else if (!val2) {
          printf("Division by 0 error.\n");
        } else {
          val1 = val1/val2;
        }
        break;
      default :
        return val1;
    }
  }
  return val1;
}
mixed expr() {
  mixed val1, val2;
  val1 = bit2();
  while (pos < sizeof(func)) {
    switch (func[pos]) {
      case TOK_PLUS :
        pos ++;
        val2 = bit2();
        if (pointerp(val1) && !pointerp(val2)) {
          printf("Incompatible types in addition, array and something "
                 "else.\n");
          val1 = 0;
        } else {
          val1 = val1 + val2;
        }
        break;
      case TOK_MINUS :
        pos ++;
        val2 = bit2();
        if (pointerp(val1) && !pointerp(val2)) {
          printf("Incompatible types in addition, array and something "
                 "else.\n");
          val1 = 0;
        } else {
          val1 = val1 + val2;
        }
        break;
      case TOK_ASSIGN :
        pos++;
        val2 = expr();
        if (pointerp(val1) || mapp(val1)) {
          printf("Cannot use an array or mapping as a variable name.\n");
        } else {
          this_player()->set_obvar(val1, val2);
        }
        val1 = val2;
        break;
      default :
        return val1;
    }
  }
  return val1;
}
void init_expr(string expr) {
  pos = 0;
  force_string = 0;
  func = TOKENISER->tokenise(expr);
}
void finish_expr() {
  func = 0;
}
#ifdef BOOLEAN
mixed eval() {
  mixed *tmp, val1, val2;
  int i, j;
  val1 = bit2();
  while (pos < sizeof(func))
    switch(func[pos]) {
      case TOK_EQUAL :
      case TOK_GREATOR :
      case TOK_LESS :
      case TOK_GREATOREQ :
      case TOK_LESSEQ :
    }
}
#endif

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/global/wiz_object_comm.c ===
#include <creator.h>
private nosave mapping obvar;
void create() {
   obvar = ([ ]);
}
protected void wiz_commands() {
}
int affirmative(string s)
{
    s = lower_case(s);
    return (s == "y" || s == "yes" || s == "ok" || s == "please");
}
void handle_error(string erm, string desc) {
    if (erm) {
         write(desc + " failed : " + erm);
    }
}
void set_obvar(string key, object value) {
  obvar[key] = value;
}
void del_obvar(string key) {
  map_delete(obvar, key);
}
object get_obvar(string key) {
  return obvar[key];
}
mapping get_obvars() {
  return obvar;
}
string desc_object(mixed o) {
  log_file("WIZ_PRESENT", sprintf("desc_object() called by %O.\n",
      previous_object()));
  return "";
}
string desc_f_object(mixed o) {
  log_file("WIZ_PRESENT", sprintf("desc_f_object() called by %O.\n",
      previous_object()));
  return "";
}
object *wiz_present(string str, object onobj, int nogoout) {
  log_file("WIZ_PRESENT", sprintf("wiz_present() called by %O.\n",
      previous_object()));
  return ({});
}
