
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/attack_messages.c ===
mapping weapon_mess;
void create() {
  weapon_mess = ([
    "blunt" : ({
      0, "$N swing$s at $I with $D",
        20, "$N tap$s $I in the $z with $D",
        60, "$N hit$s $I in the $z with $D",
        100, "$N bruise$s $P $z with $D",
        140, "$N hit$s $I hard in the $z with $D",
        180, "$N smash$es $I in the $z with $D",
        220, "$N crush$es $P $z with $D",
        5000, "$N mash$es $P $z with $D",
        }),
    "blunt-tail" : ({
      0, "$N swing$s $p tail at $I",
        20, "$N tap$s $I in the $z with $p tail",
        60, "$N slap$s $I in the $z with $p tail",
        100, "$N bruise$s $P $z with $p tail",
        140, "$N hit$s $I hard in the $z with $p tail",
        180, "$N bash$es $I in the $z with $p tail",
        220, "$N smash$es $p tail into $P $z",
        5000, "$N send$s $I reeling with a powerful blow to the $z with $p tail"
        }),
    "blunt-hoof" : ({
      0, "$N kick$s out at $I",
        20, "$N tap$s $I in the $z with $p hoof",
        60, "$N kick$s $I in the $z with $p hoof",
        100, "$N bruise$s $P $z with $p hoof",
        140, "$N hit$s $I hard in the $z with $p hoof",
        180, "$N smash$es $I in the $z with $p hoof",
        220, "$N crush$es $p hoof into $P $z",
        5000, "$N mash$es $P $z with $p hoof"
        }),
    "blunt-wrestle" : ({
      0, "$N grab$s for $I",
        25, "$N grapple$s with $I",
        50, "$N catch$es $I in an arm lock",
        75, "$N grab$s $I around the neck",
        100, "$N poke$s $I in the face",
        125, "$N throw$s $I to the ground",
        150, "$N fling$s $I over $p shoulder",
        175, "$N punch$es $I in the stomach",
        200, "$N twist$s $P arm painfully",
        225, "$N thump$s $P head hard",
        250, "$N kick$s $I in the back",
        275, "$N jump$s up and down on $I",
        5000, "$N slam$s $P head against the ground"
        }),
    "blunt-hands" : ({
      0, "$N punch$es at $I",
        10, "$N poke$s $I in the $z",
        40,"$N tickle$s $I in the $z",
        70, "$N jab$s $I in the $z",
        100, "$N hit$s $I in the $z with an uppercut",
        130, "$N hit$s $I in the $z with a cross",
        160, "$N hit$s $I in the $z with a vicious hook",
        5000, "$N beat$s $P $z to a pulp",
        }),
    "blunt-feet" : ({
      0, "$N kick$s out at $I",
        10, "$N poke$s $I",
        40, "$N tickle$s $I in the $z with $p toes",
        70, "$N kick$s $I in the $z",
        100, "$N viciously boot$s $I in the $z",
        130, "$N kick$s $I in the $z",
        160, "$N viciously kick$s $I in the $z",
        5000, "$N kick$s $P $z into a bloody mess"
        }),
    "blunt-pommel": ({
      0, "$N strike$s at $I with the pommel of $D",
        20, "$N tap$s $I in the $z with the pommel of $D",
        60, "$N knock$s $P $z with the hilt of $D",
        100, "$N bruise$s $P $z with the pommel of $D",
        140, "$N bash$es $I in the $z with the hilt of $D",
        180, "$N beat$s $I in the $z with the pommel of $D",
        220, "$N smash$es the hilt of $D into $P $z",
        5000, "$N smash$es $I in the $z with the pommel of $D",
        }),
    "blunt-cane" : ({
      0, "$N strike$s at $I with $D",
        20, "$N tap$s $P $z with $D",
        60, "$N knock$s $P $z with $D",
        100, "$N strike$s $I lightly in the $z with $D",
        140, "$N strike$s $I in the $z with $D",
        180, "$N strike$s $I hard in the $z with $D",
        220, "$N batter$s $P $z with $D",
        5000, "$N bludgeon$s $P $z with $D",
        }),
    "blunt-self" : ({
      0, "$N swing$s at $I",
        20, "$N tap$s $I in the $z",
        60, "$N hit$s $I in the $z",
        100, "$N bruise$s $P $z",
        140, "$N hit$s $I hard in the $z",
        180, "$N smash$es $I in the $z",
        220, "$N crush$es $P $z",
        5000, "$N mash$es $P $z",
        }),
    "sharp" : ({
      0, "$N slash$es at $I with $D",
        20, "$N snick$s $P $z with $D",
        60, "$N scratch$es $P $z with $D",
        100, "$N nick$s $P $z with $D",
        140, "$N cut$s $P $z with $D",
        180, "$N slice$s $P $z with $D",
        220, "$N hack$s $P $z with $D",
        5000, "$N chop$s up $P $z with $D"
        }),
    "sharp-claws" : ({
      0, "$N rake$s at $I with $p claws",
        10, "$N snick$s $P $z with $p claws",
        40, "$N scratch$es $P $z with $p claws",
        70, "$N nick$s $P $z with $p claws",
        100, "$N claw$s $P $z",
        130, "$N slice$s $P $z up with $p claws",
        160, "$N hack$s $P $z up with $p claws",
        5000, "$N cut$s $P $z into small pieces with $p claws",
        }),
    "sharp-chew" : ({
      0, "$N bite$s at $I",
        10, "$N chew$s on $P $z",
        40, "$N munch$es on $P $z",
        70, "$N gash$es $P $z with $p teeth",
        100, "$N rip$s flesh off $P $z",
        130, "$N tear$s deeply into $P $z",
        160, "$N rip$s $P $z to pieces with $p teeth",
        5000,  "$N rend$s huge chunks of flesh from $P $z",
        }),
    "sharp-slice": ({
      0, "$N slice$s at $I with $D",
        20, "$N just manage$s to slice $P $z with $D",
        60, "$N slice$s $D across $P $z",
        100, "$N shred$s $P $z with $D",
        140, "$N slice$s $D into $P $z",
        180, "$N take$s a sliver off $P $z with $D",
        220, "$N slice$s $D deeply into $P $z",
        5000, "$N neatly fillet$s $P $z with $D",
        }),
    "sharp-chop": ({
      0, "$N swing$s $D at $I",
        20, "$N attempt$s to chop $P $z with $D",
        60, "$N chop$s at $P $z with $D",
        100, "$N chop$s $P $z with $D",
        140, "$N chop$s $D into $P $z",
        180, "$N hack$s into $P $z with $D",
        220, "$N chop$s $D deeply into $P $z",
        5000, "$N chop$s $P $z into pieces with $D",
        }),
    "pierce": ({
      0, "$N thrust$s at $I with $D",
        20, "$N barely hit$s $I in the $z with $D",
        60, "$N jab$s $D into $P $z",
        100, "$N pierce$s $P $z with $D",
        140, "$N impale$s $P $z on $D",
        180, "$N skewer$s $P $z with $D",
        220, "$N run$s $I through the $z with $D",
        5000, "$N make$s a kebab of $P $z with $D",
        }),
    "pierce-spike": ({
      0, "$N swing$s at $I with $D",
        20, "$N barely hit$s $I in the $z with $D",
        60, "$N jab$s $D into $P $z",
        100, "$N spike$s $P $z with $D",
        140, "$N impale$s $P $z on $D",
        180, "$N ventilate$s $P $z with $D",
        220, "$N perforate$s $P $z with $D",
        5000, "$N make$s a mess of $P $z with $D",
        }),
    "pierce-beak" : ({
      0, "$N pecks at $I with $p beak",
        10, "$N snick$s $P $z",
        40, "$N scratch$es $P $z with $p beak",
        70, "$N peck$s $P $z",
        100, "$N viciously peck$s $P $z",
        130, "$N gouge$s a hole in $P $z with $p beak",
        160, "$N slice$s $P $z with $p beak",
        5000, "$N slice$s $P $z into small bits with $p beak",
        }),
    "pierce-stab": ({
      0, "$N thrust$s at $I with $D",
        20, "$N barely stab$s $I in the $z with $D",
        60, "$N stab$s $I in the $z with $D",
        100, "$N messily stab$s $I in the $z with $D",
        140, "$N stab$s $I deeply in the $z with $D",
        180, "$N perforate$s $P $z with $D",
        220, "$N pierce$s $P $z with $D",
        5000, "$N stab$s $D right through $P $z",
        }),
    "pierce-horns": ({
      0, "$N attempt$s to gore $I with $p horns",
        20, "$N prod$s $I in the $z with $p horns",
        60, "$N poke$s $I in the $z with $p horns",
        100, "$N butt$s $I in the $z with $p horns",
        140, "$N pierce$s $I deeply in the $z with $p horns",
        180, "$N ram$s $I in the $z with $p horns",
        220, "$N gore$s $P $z with $p horns",
        5000, "$N impale$s $P $z on $p horns",
        }),
    "pierce-tusks": ({
      0, "$N attempt$s to gore $I with $p tusks",
        20, "$N prod$s $P $z with $p tusks",
        60, "$N poke$s $I in the $z with $p tusks",
        100, "$N jab$s $p tusks into $P $z",
        140, "$N pierce$s $P $z with $p tusks",
        180, "$N stab$s $p tusks deeply into $P $z",
        220, "$N gore$s $P $z with $p tusks",
        5000, "$N impale$s $P $z on $p tusks",
        }),
    "pierce-bite" : ({
      0, "$N attempt$s to bite $I",
        10, "$N nip$s $I in the $z",
        40, "$N nibble$s at $P $z",
        70, "$N bite$s $I in the $z",
        100, "$N sink$s $p teeth into $P $z",
        130, "$N bite$s into $P $z",
        160, "$N sink$s $p teeth deep into $P $z",
        5000, "$N bite$s deeply into $P $z, splintering $P bones",
        }),
    "fire" : ({
      20, "$N smoke$s $I",
        60, "$N toast$s $I",
        100, "$N scorch$es $I",
        140, "$N crisp$s $I",
        180, "$N singe$s $I",
        220, "$N fry$s $I",
        260, "$N roast$s $I",
        300, "$N melt$s $I",
        340, "$N char$s $I",
        380, "$N burn$s $I",
        420, "$N incinerate$s $I",
        460, "$N cremate$s $I",
        5000, "$N vapourise$s $I",
        }),
    ]);
}
string parse_string(string mess, object him, object me, object wep,
                    string zone) {
   return replace( replace( mess, ({
      "$mposs$ $D", (string)wep->poss_short() }) ),
         ({ "$hname$", (string)him->query_name(),
            "$mname$", (string)me->query_name(),
            "$hcname$", (string)him->the_short(),
            "$mcname$", (string)me->the_short(),
            "$hposs$", (string)him->query_possessive(),
            "$mposs$", (string)me->query_possessive(),
            "$hpname$", (string)him->poss_short(),
            "$mpname$", (string)me->poss_short(),
            "$hpron$", (string)him->query_pronoun(),
            "$mpron$", (string)me->query_pronoun(),
            "$hobj$", (string)him->query_objective(),
            "$mobj$", (string)me->query_objective(),
            "$wname$", (string)wep->query_name(),
            "$wcname$", (string)wep->short(0),
            "$zname$", zone})
   );
}
mixed query_message( int dam, string type, object him, object me,
                     string name, object wep, string zone) {
  int j;
  mixed ind;
  string tmp;
  if(!zone) {
    zone = "body";
  } else {
    if(zone[sizeof(zone)]-1 == 's')
      zone = zone[0..<2];
  }
  ind = wep->query_attack_message(name, type);
  if (!ind) {
    if(type == "unarmed") {
      switch(name) {
      case "bite":
      case "beak":
      case "stab":
      case "horns":
      case "tusks":
        type = "pierce";
        break;
      case "claws":
      case "chew":
      case "slice":
      case "chop":
        type = "sharp";
        break;
      default:
        type = "blunt";
      }
    }
    ind = weapon_mess[type+"-"+name];
    if(!ind) {
      ind = weapon_mess[type];
      if (!ind) {
        return 0;
      }
    }
  }
  while (j < sizeof(ind) && dam > ind[j]) {
    j += 2;
  }
  if (j >= sizeof(ind)) {
    j = sizeof(ind)-2;
  }
  ind = ind[j+1];
  if (stringp(ind)) {
    tmp = replace(ind,
                  ({ "$N", (string)me->the_short(),
                       "$p ", (string)me->query_possessive() +" ",
                       "$r", (string)me->query_pronoun(),
                       "$o", (string)me->query_objective(),
                       "$z", zone,
                       "$D", wep->poss_short(),
                       "$I", him->the_short(),
                       "$P", (string)him->the_poss_short(),
                       "$O", (string)him->query_objective(),
                       "$es", "es", "$s", "s" }) );
    ind = ({ replace( ind, ({ "$N", "you", "$p ", "your ",
                                "$r", "you", "$o", "you",
                                "$es", "", "$s", "",
                                "$D", wep->poss_short(),
                                "$z", zone,
                                "$I",  him->the_short(),
                                "$P", him->the_poss_short(),
                                "$O", him->query_objective(),
                                }) ),
               tmp,
               tmp });
    return ind;
  }
  return ({
    parse_string(ind[0], him, me, wep, zone),
      parse_string(ind[1], him, me, wep, zone),
      parse_string(ind[2], him, me, wep, zone)});
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/livings.c ===
private nosave mapping _lnames = ([]);
private nosave mapping _players = ([]);
#ifdef 0
void create() {
  object player, *players;
  players = filter(efun::users(), (: $1 && inherits("/std/container", $1) :));
  foreach(player in players) {
    _players[player->query_name()] = player;
  }
}
#endif
private void check_lnames(string* names) {
   string key;
   foreach (key in names) {
      mixed bing = _lnames[key];
      if (arrayp(bing)) {
         bing -= ({ 0 });
         if (sizeof(bing)) {
            _lnames[key] = bing;
         }
         else {
            map_delete(_lnames, key);
         }
      }
      else {
         map_delete(_lnames, key);
      }
   }
}
private void check_players(string* names) {
   string key;
   foreach (key in names) {
      mixed bing = _players[key];
      if (arrayp(bing)) {
         bing -= ({ 0 });
         if (sizeof(bing)) {
            _players[key] = bing;
         }
         else {
            map_delete(_players, key);
         }
      }
      else {
         map_delete(_players, key);
      }
   }
}
void remove_garbage(){
  string* names;
  int i;
  names = keys(_lnames);
  for (i = 0; i < sizeof(names); i += 50) {
     call_out((: check_lnames :), i / 25, names[i..i+50]);
  }
  names = keys(_players);
  for (i = 0; i < sizeof(names); i += 50) {
     call_out((: check_players :), i / 25, names[i..i+50]);
  }
}
void enable_commands(object ob){
}
void set_living_name(string name, object ob){
  if (!stringp(name) || !objectp(ob)) {
    return ;
  }
  if(!_lnames[name]) {
    _lnames[name] = ({ob});
  } else {
    _lnames[name] += ({ob});
  }
  if ( ob == master() ) {
     log_file( "LIVINGS", "%O (%s) became a living. %O\n", ob,
         name, call_stack(0) );
  }
}
object *named_livings(){
  object *ret;
  ret = keys(_lnames);
  ret = map(ret, (:$1?(_lnames)[$1]:0:));
  reset_eval_cost();
  ret = filter(ret, (:$1:));
  reset_eval_cost();
  ret = implode(ret, (:$1 + $2:));
  reset_eval_cost();
  ret = filter(ret, (:$1:));
  return ret;
}
object find_living(string it) {
  if(_lnames[it]) {
    _lnames[it] = filter(_lnames[it], (: $1 :));
    if(sizeof(_lnames[it]))
      return _lnames[it][<1];
  }
  return 0;
}
object find_player(string it) {
  object *people;
  int t = real_time();
  object *tmp;
  if(_players[it]) {
      return _players[it];
    return 0;
  }
  people = filter(efun::users(), (: $1 && $1->query_name() == $(it) &&
                                  inherits("/std/container", $1):));
  if(sizeof(people)) {
    _players[it] = people[0];
    if(real_time() - t > 1)
      log_file("GARBAGE", "find_player took %d seconds to find %s (1)\n",
               real_time() - t, it);
      return _players[it];
  }
  if(!_lnames[it]) {
    if(real_time() - t > 1)
      log_file("GARBAGE", "find_player took %d seconds to find %s (2)\n",
               real_time() - t, it);
    return 0;
  }
  tmp = filter(_lnames[it], (: $1 && userp($1) :));
  if(real_time() - t > 1)
    log_file("GARBAGE", "find_player took %d seconds to find %s (3)\n",
             real_time() - t, it);
  if(sizeof(tmp))
    return tmp[0];
  return 0;
}
mapping query_dynamic_auto_load() {
   mapping tmp;
   tmp = ([ "lnames" : _lnames,
            "players" : _players,
          ]);
   return tmp;
}
void init_dynamic_arg(mapping maps) {
   object ob;
   string name;
   if (maps["lnames"])
      _lnames = maps["lnames"];
   if (maps["players"])
      _players = maps["players"];
   foreach(ob in efun::users()){
      if ( !ob ) {
        continue;
      }
      name = ob->query_name();
      _players[name] = ob;
      if(!_lnames[name]){
        _lnames[name] = ({ob});
      } else {
        _lnames[name] |= ({ob});
      }
   }
}
mixed *stats() {
  return ({ ({ "lnames", sizeof(keys(_lnames)) }),
              ({ "players", sizeof(keys(_players)) })});
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/reaction.c ===
#include <move_failures.h>
#include <reaction.h>
#define REACTIONS "/obj/reactions/"
#define SUBSTANCES 10
mapping substance = allocate_mapping(SUBSTANCES);
int debug_rh = 0;
void restore_from_files();
void write_dbg(string str) { if (debug_rh) write(str); }
void create() {
    seteuid("/secure/master"->creator_file(file_name(this_object())));
    restore_from_files();
}
mapping merge_effects(mapping effects_a, mapping effects_m, int q_a, int q_m) {
    int q_t, strength;
    string key;
    mapping ret = ([ ]);
    if(!mapp(effects_a) || !mapp(effects_m))
      return 0;
    q_t = q_a + q_m;
    if ( !q_t ) {
        return 0;
    }
    foreach (key in keys(effects_a)) {
        if (!intp(effects_a[key]) || !intp(effects_m[key])) {
            continue;
        }
        if (undefinedp(effects_m[key])) {
            strength = (effects_a[key]*q_a)/q_t;
        } else {
            strength = (effects_a[key]*q_a + effects_m[key]*q_m)/q_t
                - effects_m[key];
            map_delete(effects_m, key);
        }
        ret += ([key: strength]);
    }
    foreach (key in keys(effects_m)) {
        if (!intp(effects_m[key])) {
            continue;
        }
        strength = (effects_a[key]*q_a + effects_m[key]*q_m)/q_t
            - effects_m[key];
        ret += ([key: strength]);
    }
    return ret;
}
object merge_cont_medium(object a, string medium_alias) {
    object medium;
    int no_join, q_a, q_m;
    mapping effects_a, effects_m, eff;
    string key;
    a->remove_alias(medium_alias);
    no_join = a->query_no_join();
    if ((medium = present(medium_alias, environment(a))) && !no_join) {
        a->set_no_join();
        a->move("/room/void");
        q_a = a->query_amount();
        q_m = medium->query_amount();
        medium->adjust_amount(q_a);
        effects_a = copy(a->query_eat_effects());
        effects_m = copy(medium->query_eat_effects());
        eff = merge_effects(effects_a, effects_m, q_a, q_m);
        if (mapp(eff)) {
           foreach (key in keys(eff)) {
               medium->add_eat_effect(key, eff[key]);
           }
        }
        effects_a = copy(a->query_external_effects());
        effects_m = copy(medium->query_external_effects());
        eff = merge_effects(effects_a, effects_m, q_a, q_m);
        if(eff) {
          foreach (key in keys(eff)) {
            medium->add_external_effect(key, eff[key]);
          }
        }
        call_out("dest_substance", 0, a);
        return medium;
    } else {
        a->add_alias(medium_alias);
        return a;
    }
}
void check_reaction(object a) {
    int amt_a, need_amt_a, amt_b, need_amt_b;
    string name_a, name_b, i_a, i_b, msg, fcn;
    mixed *fcns;
    int i, j, amt_result;
    object x, *bs, ob_a, ob_b;
    float ratio;
    class reaction rcn;
    if (objectp(this_player()))
      debug_rh = this_player()->query_property("debug_rh");
    else
      debug_rh = 0;
    write_dbg("Entering reaction_handler.\n");
    name_a = a->query_medium_alias();
    if (!name_a || !a->query_continuous()) {
        write_dbg("Leaving reaction_handler because there is no A or it is not "
        "continous.\n");
        return;
    }
    if ( a->query_medium_alias() == a->query_name() ) {
        debug_printf( "WARNING: Your cont_medium alias must "
          "not be the same as your name.\n" );
        return;
    }
    a = merge_cont_medium(a, name_a);
    bs = all_inventory(environment(a));
    debug_printf( "A is %O at %O. Bs are: %O.\n", a, environment( a ), bs );
    if ((sizeof(bs) < 2) || (!a->query_amount())) {
        write_dbg("Leaving reaction_handler because there is no B, or there is "
        "0 amounts of A.\n");
        return;
    }
    write_dbg("Checking the following: ");
    for (i = 0; i < sizeof(bs); i++) {
        write_dbg(bs[i]->query_medium_alias() + ", ");
    }
    write_dbg("\n");
    for (i = 0; i < sizeof(bs); i++) {
        if (!a->query_amount()) {
            write_dbg("Leaving reaction_handler.\n");
            return;
        }
        name_b = bs[i]->query_medium_alias();
        if (!name_b || !bs[i]->query_continuous() || !bs[i]->query_amount()) {
            continue;
        }
        if (name_a < name_b) {
            i_a = name_a;
            i_b = name_b;
            ob_a = a;
            ob_b = bs[i];
        } else {
            i_a = name_b;
            i_b = name_a;
            ob_a = bs[i];
            ob_b = a;
        }
        write_dbg("Checking " + i_a + " against " + i_b + ".\n");
        if (!substance[i_a] || !substance[i_a][i_b]) {
            continue;
        }
        write_dbg("...they react.\n");
        rcn = substance[i_a][i_b];
        amt_a = ob_a->query_amount();
        amt_b = ob_b->query_amount();
        ratio = to_float(amt_a) / amt_b;
        if (intp(rcn->ratio)) {
            rcn->ratio = to_float(rcn->ratio);
        }
        if (floatp(rcn->ratio)) {
            write_dbg("Single ratio...\n");
            if (ratio > rcn->ratio) {
                need_amt_b = amt_b;
                need_amt_a = to_int(ceil(amt_b*rcn->ratio));
                write_dbg("Setting amt_a to "+ to_int(ceil(amt_b*rcn->ratio)) +".\n" );
            } else {
                need_amt_a = amt_a;
                need_amt_b = to_int(ceil(amt_a/rcn->ratio));
                write_dbg("Setting amt_b to "+ to_int(ceil(amt_a/rcn->ratio)) +".\n" );
            }
        } else if (arrayp(rcn->ratio) && (sizeof(rcn->ratio) == 2)) {
            write_dbg("Range of ratios...");
            if (intp(rcn->ratio[0])) {
                rcn->ratio[0] = to_float(rcn->ratio[0]);
            }
            if (intp(rcn->ratio[1])) {
                rcn->ratio[1] = to_float(rcn->ratio[1]);
            }
            if (ratio > rcn->ratio[1]) {
                write_dbg("above range...(" + ratio + ")\n");
                need_amt_b = amt_b;
                need_amt_a = to_int(ceil(amt_b*rcn->ratio[1]));
                write_dbg("Setting amt_a to "+ to_int(ceil(amt_b*rcn->ratio[1])) +".\n" );
                write_dbg("This is because amta is: "+ amt_b +" and ratio is "+ rcn->ratio[1] + ".\n" );
            } else if (ratio < rcn->ratio[0]) {
                write_dbg("below range...(" + ratio + ")\n");
                need_amt_a = amt_a;
                need_amt_b = to_int(ceil(amt_a/rcn->ratio[0]));
                write_dbg("Setting amt_b to "+ to_int(ceil(amt_a/rcn->ratio[0])) +".\n" );
                write_dbg("This is because amta is: "+ amt_a +" and ratio is "+ rcn->ratio[0] + ".\n" );
            } else {
                write_dbg("within range...(" + ratio + ")\n");
                need_amt_a = amt_a;
                need_amt_b = amt_b;
            }
        } else {
            error("Illegal reaction ratio; expecting float, int, or "
                  "array of two floats or ints.");
        }
        amt_result = to_int((need_amt_a + need_amt_b)*rcn->result_amt);
        write_dbg("...got ("+amt_a+","+amt_b+"), taking ("+need_amt_a+","+
                  need_amt_b+"), creating " + amt_result + ".\n");
        write_dbg("...creating "+rcn->result+".\n");
        x = clone_object(rcn->result);
        if (rcn->result_amt) {
            if (function_exists("set_amount", x)) {
                x->set_amount(amt_result);
            } else {
                x->set_weight(amt_result);
            }
        }
        msg = rcn->message;
        if (msg) {
            msg = replace(rcn->message, ({
                "#env#", file_name(environment(a)),
                "#env2#", file_name(environment(environment(a))),
                "#obj_a#", file_name(ob_a),
                "#obj_b#", file_name(ob_b),
                "#obj_x#", file_name(x)
              }));
            tell_room(environment(environment(a)), msg);
        }
        fcns = rcn->func;
        if (fcns) {
            for (j = 0; j < sizeof(fcns); j++) {
                if (stringp(fcns[j])) {
                    fcn = replace(fcns[j], ({
                        "#env#", file_name(environment(a)),
                        "#env2#", file_name(environment(environment(a))),
                        "#obj_a#", file_name(ob_a),
                        "#obj_b#", file_name(ob_b),
                        "#obj_x#", file_name(x)
                      }));
                } else if (functionp(fcns[j])) {
                    evaluate(fcns[j], ob_a, ob_b, x, environment(a),
                             environment(environment(a)), need_amt_a,
                             need_amt_b);
                }
            }
        }
        call_out("move_substance", 0, ({x, environment(a)}));
        ob_a->adjust_amount( -need_amt_a );
        ob_b->adjust_amount( -need_amt_b );
    }
    write_dbg("Leaving reaction_handler.\n");
}
void move_substance(object *ob) {
    int vol, vol_left, cont, closed, i, mv_stat;
    object *contents;
    if (!ob[0] || !ob[1]) return;
    vol_left = (int)ob[1]->query_max_volume() - (int)ob[1]->query_volume();
    if (cont = ob[0]->query_continuous()) {
        vol = ob[0]->query_amount();
    } else {
        vol = (int)ob[0]->query_weight()*200;
    }
    closed = ob[1]->query_closed();
    ob[1]->set_open();
    if ((mv_stat = ob[0]->move(ob[1])) != MOVE_OK) {
        write_dbg(sprintf("Move error (%d)...", vol));
        if ((vol > vol_left) && cont && !closed) {
            write_dbg("too much...\n");
            ob[0]->set_amount(vol_left);
            tell_room(environment(ob[1]), ob[0]->short(0) +
                      " leaks out of the " + ob[1]->short(0) + ".\n");
            mv_stat = ob[0]->move(ob[1]);
        }
        if (mv_stat == MOVE_OK) {
            if (closed) ob[1]->set_closed();
        } else {
            contents = all_inventory(ob[1]);
            write_dbg(sprintf("contents = %O\n", contents));
            for (i = 0; i < sizeof(contents); i++) {
                contents[i]->dest_me();
            }
            if (!living(ob[1]) && !function_exists("query_co_ord", ob[1])) {
                tell_room(environment(ob[1]), ob[1]->the_short(0) +
                          " explodes, splattering the contents all over.\n");
                ob[1]->move("/room/rubbish");
            }
            ob[0]->move("/room/rubbish");
        }
    } else {
        if (closed) ob[1]->set_closed();
    }
}
void dest_substance(object ob) {
    if (ob) {
        ob->dest_me();
    }
}
mixed *query_reaction(string name_a, string name_b) {
    if (!substance[name_a] || !substance[name_a][name_b]) {
        return 0;
    }
    return substance[name_a][name_b];
}
mapping query_reactions() { return substance; }
void restore_from_files() {
    string *files;
    int i;
    files = ({ "base.hdr" });
    files += get_dir(REACTIONS + "*.rcn");
    for (i = 0; i < sizeof(files); i++) {
        files[i] = REACTIONS + files[i];
    }
    substance = "/obj/handlers/data"->compile_data(files);
}
void update_from_files(string fn) {
    mapping new_substance;
    string a, b;
    new_substance = "/obj/handlers/data"->compile_data( ({ fn }) );
    foreach (a in keys(new_substance)) {
      if (undefinedp(substance[a])) {
        substance[a] = ([ ]);
      }
      foreach (b in keys(new_substance[a])) {
        substance[a][b] = new_substance[a][b];
      }
    }
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/money_handler.c ===
#include <money.h>
#define DEF_VALUE 1
#define SAVE_FILE "/save/money_handler"
#define USE_VAULT DEF_VALUE
mapping values;
mapping symbols;
mapping details;
mapping aliases;
mapping adjectives;
mixed *merge_money_arrays(mixed *m_array1, mixed *m_array2);
varargs object *filter_legal_money_array(mixed *m_array, string where);
varargs mixed *filter_legal_money_to_array(mixed *m_array, string where);
void create() {
   seteuid( (string)"/secure/master"->
      creator_file( file_name( this_object() ) ) );
   values = ([ "default": ({ "brass", 1, "copper", 10, "silver", 100,
                                          "gold", 2000, "platinum", 6000 }) ]);
   symbols = ([ ]);
   details = ([
      "brass": ({ "heads", "tails", "a head", "a tail", "brass", 0 }),
      "copper": ({ "heads", "tails", "a head", "a tail", "copper", 0 }),
      "silver": ({ "heads", "tails", "a head", "a tail", "silver", 0 }),
      "gold": ({ "heads", "tails", "a head", "a tail", "gold", 0 }),
      "platinum": ({ "heads", "tails", "a head", "a tail", "platinum", 0 }) ]);
   aliases = ([ ]);
   adjectives = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 ) {
      unguarded((: restore_object, SAVE_FILE :));
   }
   if ( !symbols ) {
      symbols = ([ ]);
   }
   if ( !aliases ) {
      aliases = ([ ]);
   }
   if ( !adjectives ) {
      adjectives = ([ ]);
   }
}
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }
mapping query_all_values() { return copy( values ); }
string *query_all_places() {
   return keys(values);
}
mixed *query_values() { return copy( values[ "default" ] ); }
mixed *query_values_in( string where ) {
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   return copy( values[ where ] );
}
mixed *query_weighted_values_in( string where, int backwards ) {
    mixed *bits;
    int i, j;
    int max_size;
    int len;
    mixed *arr, *reversed;
    if ( !where || ( where == "" ) ) {
        return 0;
    }
    bits = copy( values[ where ] );
    arr = ({ });
    max_size = 0;
    for ( i = 0; i < sizeof( bits ); i += 2 ) {
        len = sizeof( bits[ i ] );
        if ( len > max_size ) {
            arr += ({ bits[ i ], bits[ i + 1 ] });
            max_size = len;
            continue;
        }
        for ( j = 0; j < sizeof( arr ); j += 2 ) {
            if ( len <= sizeof( arr[ j ] ) ) {
                arr = arr[ 0..j-1] + ({ bits[ i ], bits[ i + 1 ] }) + arr[j..];
                break;
            }
        }
    }
    if ( backwards ) {
        reversed = ({ });
        for ( i = sizeof( arr ) - 1; i > 0; i -= 2) {
            reversed += ({ arr[ i - 1 ], arr[ i ] });
        }
        return reversed;
    }
    else {
       return arr;
    }
}
int query_smallest_value_in(string where) {
   mixed* values;
   int value;
   int i;
   if (! where) {
      where = "default";
   }
   values = query_values_in(where);
   value = values[1];
   for (i = 2; i < sizeof(values); i += 2) {
      if (values[i + 1] < value) {
         value = values[i + 1];
      }
   }
   return value;
}
void add_type( string where, string type, int value ) {
   int i;
   if ( !values[ where ] ) {
      values[ where ] = ({ type, value });
      save_me();
      return;
   }
   if ( member_array( type, values[ where ] ) != -1 ) {
      return;
   }
   for ( i = 0; i < sizeof( values[ where ] ); i += 2 ) {
      if ( value < values[ where ][ i + 1 ] ) {
         values[ where ] = values[ where ][ 0 .. i - 1 ] + ({ type, value })
                           + values[ where ][ i .. sizeof( values ) ];
         save_me();
         return;
      }
   }
   values[ where ] += ({ type, value });
   save_me();
}
void remove_type( string where, string type ) {
   int i;
   if ( !values[ where ] ) {
      return;
   }
   i = member_array( type, values[ where ] );
   if ( i == -1 ) {
      return;
   }
   values[ where ] = delete( values[ where ], i, 2 );
   if ( !sizeof( values[ where ] ) ) {
      map_delete( values, where );
   }
   save_me();
}
mapping query_details() { return copy( details ); }
mixed *query_details_for( string word ) {
   if ( !details[ word ] ) {
      return ({ "heads", "tails", "a head", "a tail", "unknown", 0 });
   }
   return copy( details[ word ] );
}
void add_details( string word, string hd_sht, string tl_sht, string hd_lng,
                  string tl_lng, mixed composition, string plural ) {
   if ( details[ word ] ) {
      return;
   }
   details[ word ] = ({ hd_sht, tl_sht, hd_lng, tl_lng, composition, plural });
   save_me();
}
void remove_details( string word ) {
   if ( !details[ word ] ) {
      return;
   }
   map_delete( details, word );
   save_me();
}
mapping query_symbols() { return copy( symbols ); }
string query_symbol_for( string word ) {
   if ( !symbols[ word ] ) {
      return 0;
   }
   return copy( symbols[ word ] );
}
void add_symbol( string word, string symboliser ) {
   if ( symbols[ word ] ) {
      return;
   }
   symbols[ word ] = symboliser;
   save_me();
}
void remove_symbol( string word ) {
   if ( !symbols[ word ] ) {
      return;
   }
   map_delete( symbols, word );
   save_me();
}
string query_alias_for( string type ) {
   log_file("OBSOLETE_CALLS",
      sprintf("%O %s: %O called query_alias_for\n",
         this_object(),
         ctime(time()),
         previous_object()
         ));
   if ( !details[ type ] ) return "coin";
   if ( !details[ type ][ 5 ] ) return "coin";
   return explode( type, " " )[ sizeof( explode( type, " " ) ) - 1 ];
}
void set_aliases_for(string type, string *words) {
   if (!words || !sizeof(words)) {
      if (aliases[type]) {
         map_delete(aliases, type);
      }
   } else {
      aliases[type] = words;
   }
   save_me();
   return;
}
string *query_aliases_for( string type ) {
   string *ret;
   if ( !details[ type ] || !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      ret = ({ "coin" });
   } else {
      ret = ({ explode(type, " ")[<1] });
   }
   if ( aliases[ type ] ) {
      ret += aliases[ type ];
   }
   return ret;
}
void set_adjectives_for(string type, string *words) {
   if (!words || !sizeof(words)) {
      if (adjectives[type]) {
         map_delete(adjectives, type);
      }
   } else {
      adjectives[type] = words;
   }
   save_me();
   return;
}
string *query_adjectives_for( string type ) {
   string *ret;
   if ( adjectives[ type ] ) {
      ret = adjectives[ type ];
   }
   else {
      ret = ({ });
   }
   return ret;
}
string query_short_for( string type ) {
   if ( !details[ type ] ) {
      return type +" coin";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return type +" coin";
   }
   return type;
}
string query_plural_for( string type ) {
   if ( !details[ type ] ) {
      return "coins";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return "coins";
   }
   return details[ type ][ MONEY_DETAILS_PLURAL ];
}
void set_plural_for( string type, string plural ) {
   if ( !details[ type ] ) {
      return;
   }
   details[ type ][ MONEY_DETAILS_PLURAL ] = plural;
   save_me();
}
string query_main_plural_for( string type ) {
   string *type_exp;
   if ( !details[ type ] ) {
      return type +" coins";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return type +" coins";
   }
   type_exp = explode(type, " ");
   return implode(type_exp[0 .. <2] +
      ({ details[ type ][ MONEY_DETAILS_PLURAL ] }), " " );
}
varargs int query_value( string type, string where ) {
   int i, j, count, total;
   string *places;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( where == "mean" ) {
      places = m_indices( values );
      for ( i = 0; i < sizeof( places ); i++ ) {
         if ( ( j = member_array( type, values[ places[ i ] ] ) ) != -1 ) {
            count++;
            total += values[ places[ i ] ][ j + 1 ];
         }
      }
      if ( !count ) {
         return 0;
      }
      if ( !( total / count ) ) {
         return 0;
      }
      return total / count;
   }
   if ( !values[ where ] ) {
      return 0;
   }
   i = member_array( type, values[ where ] );
   if ( i == -1 ) {
      return 0;
   }
   return values[ where ][ i + 1 ];
}
varargs int query_total_value( mixed mon_array, string where ) {
   int i, amt;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   for ( i = 0; i < sizeof( mon_array ); i += 2 ) {
      amt += mon_array[ i + 1 ] * query_value( mon_array[ i ], where );
   }
   return amt;
}
string money_string( mixed mon_array ) {
   int i;
   string ret;
   if ( !sizeof( mon_array ) ) {
      return "nothing";
   }
   ret = "";
   while( i < sizeof( mon_array ) ) {
      if ( !mon_array[ i + 1 ] ) {
         mon_array = delete( mon_array, i, 2 );
      } else {
         i += 2;
      }
   }
   for ( i = 0; i < sizeof( mon_array ); i += 2 ) {
      ret += mon_array[ i + 1 ] +" ";
      if ( mon_array[ i + 1 ] == 1 ) {
         ret += query_short_for( mon_array[ i ] );
      } else {
         ret += query_main_plural_for( mon_array[ i ] );
      }
      if ( i == sizeof( mon_array ) - 4 ) {
         ret += " and ";
      } else if ( i != sizeof( mon_array ) - 2 ) {
         ret += ", ";
      }
   }
   return ret;
}
varargs mixed *create_money_array( int value, string where ) {
   int i, amt;
   mixed *mon_array;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( !value ) {
      return ({ });
   }
   mon_array = ({ });
   for ( i = sizeof( values[ where ] ) - 2; i >= 0; i -= 2 ) {
      if ( value >= values[ where ][ i + 1 ] ) {
         mon_array += ({ values[ where ][ i ], amt = value /
                         values[ where ][ i + 1 ] });
         value -= amt * values[ where ][ i + 1];
      }
   }
   return mon_array;
}
varargs string money_value_string( int value, string where ) {
   string symboliser;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( !symbols[ where ] ) {
      if (value < 0) {
         return "negative " + money_string( create_money_array( -value,
                                                                where ) );
      } else {
         return money_string( create_money_array( value, where ) );
      }
   }
   symboliser = symbols[ where ];
   return (string)symboliser->symbolise_value( value );
}
mixed* money_array_from_string(string str, string where) {
   int value;
   int number;
   int i;
   int pos;
   int frog;
   int match;
   int max_match;
   string plural;
   string *bits;
   string type;
   string match_name;
   mixed *stuff;
   mixed* ret_arr;
   if (!where) {
      where = "default";
   }
   if (symbols[ where ]) {
      value = symbols[ where ]->unsymbolise_string( str );
      if (value) {
         return create_money_array(value, where);
      }
   }
   ret_arr = ({ });
   stuff = query_weighted_values_in( where, 1 );
   if (!value && stuff) {
      bits = explode(str, " ") - ({ "and", ",", "" });
      for (i = 0; i < sizeof(bits); i++) {
         if (sscanf(bits[i], "%d", number) == 1 &&
             i + 1 < sizeof(bits)) {
            i++;
            type = bits[i];
            max_match = 0;
            do {
               match = 0;
               if (type[<1] == ',') {
                  type = type[0..<2];
               }
               type = lower_case(type);
               for (pos = 0; pos < sizeof(stuff); pos += 2) {
                  plural = query_plural_for(stuff[pos]);
                  frog = strsrch(stuff[pos], " ", -1);
                  if (frog) {
                     plural = stuff[pos][0..frog] + plural;
                  }
                  if (lower_case(stuff[pos]) == type ||
                      strsrch(lower_case(stuff[pos]), type) != -1 ||
                      lower_case(plural) == type ||
                      strsrch(lower_case(plural), type) != -1) {
                     match = stuff[pos + 1];
                     match_name = stuff[pos];
                  }
               }
               if (match) {
                  i++;
                  max_match = match;
                  if (i < sizeof(bits)) {
                     type += " " + bits[i];
                  }
               }
            } while (match && i < sizeof(bits));
            if (max_match) {
               ret_arr += ({ match_name, number });
            }
            i--;
         } else {
            i++;
         }
      }
   }
   return ret_arr;
}
int value_from_string(string str, string where) {
   return query_total_value(money_array_from_string(str, where), where);
}
mixed *calc_change( int value, mixed *mon_array ) {
   int i, num;
   mixed *ret;
   ret = ({ });
   for ( i = sizeof( mon_array ) - 2; i >= 0; i -= 2 ) {
      if ( value >= mon_array[ i + 1 ] ) {
         num = value / mon_array[ i + 1 ];
         value = value % mon_array[ i + 1 ];
         ret += ({ mon_array[ i ], num });
         if ( !value ) {
            return ret;
         }
      }
   }
   return ret;
}
mixed *make_money_array_payment( string type,
                                 int value,
                                 mixed *mon_array,
                                 string where,
                                 int use_default) {
   int i;
   int j;
   int num;
   int total;
   int cur_match;
   string mon_name;
   mixed *poss_values;
   mixed *ret;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if (type) {
      i = member_array( type, mon_array );
      if ( i != -1 ) {
         if ( value <= mon_array[ i + 1 ] ) {
            mon_array[ i + 1] -= value;
            return ({ ({ type, value }), 0, mon_array });
         }
      }
      value *= query_value( type, where );
   }
   if (!value) {
      return 0;
   }
   total = query_total_value( mon_array, where );
   if (use_default  &&  where != "default") {
      total += query_total_value( mon_array, "default" );
   }
   if ( value > total ) {
      return 0;
   }
   poss_values = ({ });
   if ( where != "default" && use_default ) {
      poss_values += values[ "default" ];
   }
   poss_values += values[ where ];
   ret = ({ });
   for ( i = ( sizeof( poss_values ) - 2 ); i >= 0; i -= 2 ) {
      j = member_array( poss_values[ i ], mon_array );
      if ( j != - 1 ) {
         if ( poss_values[ i + 1 ] <= value ) {
            num = value / poss_values[ i + 1 ];
            if ( num > mon_array[ j + 1 ] ) {
               num = mon_array[ j + 1 ];
            }
            mon_array[ j + 1] -= num;
            value -= num * poss_values[ i + 1 ];
            ret += ({ poss_values[ i ], num });
            if ( !value ) {
               return ({ ret, value, mon_array });
            }
         }
      }
   }
   cur_match = value + 10000000;
   for (i = 0; i < sizeof(poss_values); i +=2 ) {
      j = member_array( poss_values[ i ], mon_array);
      if (j != -1 &&
          mon_array[j + 1] > 0 &&
          poss_values[i + 1] >= value &&
          poss_values[i + 1] - value <= cur_match - value) {
         cur_match = poss_values[i + 1];
         mon_name = poss_values[i];
      }
   }
   if (mon_name) {
      j = member_array(mon_name, mon_array);
      i = member_array(mon_name, poss_values);
      mon_array[j + 1] -= 1;
      value = poss_values[i + 1] - value;
      ret += ({ poss_values[ i ], 1 });
   } else {
      return 0;
   }
   return ({ ret, value, mon_array });
}
varargs mixed *make_payment( string type, int value, object thing,
                             string where ) {
   mixed *mon_array;
   mixed *stuff;
   if (!type) {
     return 0;
   }
   mon_array = copy(thing->query_money_array());
   stuff = make_money_array_payment( type, value, mon_array, where, 1);
   if (!stuff) {
      return stuff;
   }
   if (stuff[MONEY_PAY_CHANGE]) {
      return ({ stuff[MONEY_PAY_RETURN], calc_change(stuff[MONEY_PAY_CHANGE],
                                                     values[where]) });
   }
   return ({ stuff[MONEY_PAY_RETURN], stuff[MONEY_PAY_CHANGE] });
}
varargs object pay_amount_from(int value, object money, string where) {
   int i;
   object change;
   mixed *m_array, *p_array;
   mixed *change_array;
   mixed *pay_array;
   if (!where || where == "") {
      where = "default";
   }
   change_array = ({ });
   pay_array = ({ });
   m_array = create_money_array(value, where);
   for (i = 0; i < sizeof(m_array); i += 2) {
      p_array = make_payment(m_array[i], m_array[i + 1], money, where);
      if (!pointerp(p_array)) {
         continue;
      }
      if (sizeof(p_array[0]) > 0)
         pay_array = merge_money_arrays(pay_array, p_array[0]);
      if (sizeof(p_array[1]) > 0) {
         change_array = merge_money_arrays(change_array, p_array[1]);
      }
   }
   if (sizeof(pay_array) > 0)  {
      for (i = 0; i < sizeof(pay_array); i += 2) {
         pay_array[i + 1] = -pay_array[i + 1];
      }
      money->adjust_money(pay_array);
   }
   if (sizeof(change_array) == 0) {
      return 0;
   }
#ifdef USE_VAULT
   change = MONEY_VAULT->get_money_ob();
   change->set_money_array(change_array);
#else
   change = clone_object(MONEY_OBJECT);
#endif
   return change;
}
varargs object make_new_amount( int value, string where ) {
   object money;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
#ifdef USE_VAULT
   money = MONEY_VAULT->get_money_ob();
#else
   money = clone_object( MONEY_OBJECT );
#endif
   money->set_money_array( create_money_array( value, where ) );
   if ( !(int)money->query_value_in( where ) ) {
      money->dest_me();
      return 0;
   }
   return money;
}
varargs object *filter_legal_tender(object money, string where) {
   mixed *m_array;
   object *monies;
   m_array = money->query_money_array();
   monies = filter_legal_money_array(m_array, where);
#ifdef USE_VAULT
   MONEY_VAULT->add_to_list(money);
#else
   money->move("/room/rubbish");
#endif
   return monies;
}
varargs object *filter_legal_money_array(mixed *m_array, string where) {
   object good, no_good;
   mixed *money_arrays;
   money_arrays = filter_legal_money_to_array(m_array, where);
   if (sizeof(money_arrays[0]) == 0) {
      good = 0;
   } else  {
#ifdef USE_VAULT
      good = MONEY_VAULT->get_money_ob();
#else
      good = clone_object(MONEY_OBJECT);
#endif
      good->set_money_array(money_arrays[0]);
   }
   if (sizeof(money_arrays[1]) == 0) {
      no_good = 0;
   } else  {
#ifdef USE_VAULT
     no_good = MONEY_VAULT->get_money_ob();
#else
     no_good = clone_object(MONEY_OBJECT);
#endif
     no_good->set_money_array(money_arrays[1]);
   }
   return ({ good, no_good });
}
varargs mixed *filter_legal_money_to_array(mixed *m_array, string where) {
   int i;
   mixed *poss_values;
   mixed *good_array = ({ });
   mixed *no_good_array = ({ });
   if (sizeof(m_array) == 0) {
      return ({ ({ }), ({ }) });
   }
   if (!where || where == "") {
     where = "default";
   }
   if (!(poss_values = values[where])) {
      return ({ ({ }), copy(m_array) });
   }
   for (i = 0; i < sizeof(m_array); i += 2) {
      if (member_array(m_array[i], poss_values) != -1) {
         good_array += ({ m_array[i], m_array[i + 1] });
      } else {
         no_good_array += ({ m_array[i], m_array[i + 1] });
      }
   }
   return ({ good_array, no_good_array });
}
mixed *merge_money_arrays(mixed *m_array1, mixed *m_array2)  {
   int i;
   int idx;
   mixed *new_m_array;
   if (!m_array1)
      m_array1 = ({ });
   if (!m_array2)
      m_array2 = ({ });
   if (sizeof(m_array1) < sizeof(m_array2))  {
      new_m_array = copy(m_array2);
      for (i = 0; i < sizeof(m_array1); i += 2)  {
         idx = member_array(m_array1[i], new_m_array);
         if (idx > -1)  {
            new_m_array[idx + 1] += m_array1[i + 1];
            if (new_m_array[idx + 1] <= 0)
               new_m_array = delete(new_m_array, idx, 2);
         }
         else
            new_m_array += ({ m_array1[i], m_array1[i + 1] });
      }
   }
   else  {
      new_m_array = copy(m_array1);
      for (i = 0; i < sizeof(m_array2); i += 2)  {
         idx = member_array(m_array2[i], new_m_array);
         if (idx > -1)  {
            new_m_array[idx + 1] += m_array2[i + 1];
            if (new_m_array[idx + 1] <= 0)
               new_m_array = delete(new_m_array, idx, 2);
         }
         else
            new_m_array += ({ m_array2[i], m_array2[i + 1] });
      }
   }
   return new_m_array;
}
varargs mixed parse_money(string words, object player, string place) {
   object  thing;
   object *monies;
   object *things;
   mixed  *m_array;
   mixed  *m_array2;
   int     i;
   int     adjust_flag;
   things = match_objects_for_existence(words, ({ player }));
   if (sizeof(things) == 0) {
      m_array = money_array_from_string(words, place);
       if (sizeof(m_array) == 0) {
         return NO_MATCH;
      }
      thing = present(MONEY_ALIAS, player);
      if (!thing) {
         return NO_MATCH;
      }
      for (i = 0; i < sizeof(m_array); i += 2) {
         if (thing->query_money(m_array[i]) < m_array[i + 1]) {
            return NO_MATCH;
         }
      }
      adjust_flag = 1;
   }
   else {
      things = filter(things, (: $1->query_property("money") :));
      if (sizeof(things) == 0)
         return NO_MONEY;
      adjust_flag = 0;
      m_array = ({ });
      foreach (thing in things) {
         m_array = merge_money_arrays(m_array, thing->query_money_array());
#ifdef USE_VAULT
         MONEY_VAULT->add_to_list(thing);
#else
         thing->move("/room/rubbish");
#endif
      }
   }
   monies = filter_legal_money_array(m_array, place);
   if(monies[1])  {
      tell_object(player, monies[1]->the_short() +
            (monies[1]->query_number_coins() == 1 ? " is" : " are") +
            " not legal tender here.\n");
      m_array = monies[1]->query_money_array();
      if (!adjust_flag)
         this_player()->adjust_money(m_array);
#ifdef USE_VAULT
      MONEY_VAULT->add_to_list(monies[1]);
#else
      monies[1]->dest_me();
#endif
   }
   if (monies[0])  {
      if (adjust_flag)  {
         m_array2 = copy(monies[0]->query_money_array());
         for (i = 0; i < sizeof(m_array2); i += 2)
            m_array2[i + 1] = -m_array2[i + 1];
         this_player()->adjust_money(m_array2);
      }
      return monies[0];
   }
   else  {
      return NO_LEGAL;
   }
}
mixed *query_person_payments(int value, string place,
                             object payer, object payee) {
   mixed *stuff;
   mixed *mon_array;
   mixed *rabbit;
   mon_array = copy(payer->query_money_array());
   stuff = make_money_array_payment( 0, value, mon_array, place, 0);
   if (!stuff) {
      return 0;
   }
   if (stuff[MONEY_PAY_CHANGE]) {
      mon_array = copy(payee->query_money_array());
      rabbit = make_money_array_payment( 0, stuff[MONEY_PAY_CHANGE],
                                         mon_array, place, 0);
      if (!rabbit || rabbit[MONEY_PAY_CHANGE]) {
         return 0;
      }
      return ({ stuff[MONEY_PAY_RETURN], rabbit[MONEY_PAY_RETURN] });
   }
   return ({ stuff[MONEY_PAY_RETURN], ({ }) });
}
string * query_valid_types(){
  mixed *tmp;
  string *elem, *valid_types = ({ });
  int i;
  tmp = values(query_all_values());
  foreach( elem in tmp ){
    for( i = 0; i < sizeof( elem ); i += 2 ){
      if ( stringp( elem[i] ) )
        valid_types += ({ elem[i] });
    }
  } return valid_types;
}
string query_origin_of( string type ){
  string elem, *places;
  if( member_array( type, query_valid_types() ) == -1 )
    return 0;
  places = query_all_places();
  foreach( elem in places ){
    if( member_array( type,query_values_in( elem ) ) != -1 )
      return elem;
  }
}
string * query_aliases_of( string word ){
  string *types, elem, *aliases = ({ });
  types = query_valid_types();
  foreach( elem in types ){
    if( member_array( word,query_aliases_for( elem ) ) != -1 )
      aliases += ({ elem });
  } return aliases;
}
int query_value_of( string type ){
  if( member_array( type, query_valid_types() ) == -1 )
    return 0;
   return query_value( type, query_origin_of( type ) );
}
string smallest_in( string place ) {
   int i, smallest, r;
   mixed *values;
   values = query_values_in( place );
   smallest = values[1];
   r = 1;
   for ( i = 3; i < sizeof( values ); i += 2 ) {
      if ( values[i] < smallest ) {
         smallest = values[i];
         r = i;
      }
   }
   return values[r-1];
}
int smallest_value_in( string place ) {
   int i, smallest;
   mixed *values;
   values = query_values_in( place );
   smallest = values[1];
   for ( i = 3; i < sizeof( values ); i += 2 ) {
      if ( values[i] < smallest ) {
         smallest = values[i];
      }
   }
   return smallest;
}
mapping query_mapped_values_in( string where ) {
   mapping values = ([]);
  mixed * array;
  int i;
   if ( !where || ( where == "" ) )
      where = "default";
  array = query_values_in(where);
   for ( i = 1; i < sizeof(array); i += 2 )
  {
      values += ([array[i-1]:array[i]]);
   }
   return values;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/state_change.c ===
#include <state_change.h>
#define PROP "state name"
#define DATA_DIR "/obj/state_change/"
mapping table = ([ ]);
void set_amount_of_ob( object ob, int amount );
mixed query_table() { return table; }
void create() {
    string *files;
    int i;
    seteuid("/secure/master"->creator_file(file_name(this_object())));
    files = ({ "base.hdr" });
    files += get_dir(DATA_DIR + "*.dat");
    for (i = 0; i < sizeof(files); i++) {
        files[i] = DATA_DIR + files[i];
    }
    table += "/obj/handlers/data"->compile_data(files);
}
varargs object transform( object ob, string transformation, object player ) {
    string index, name;
    object ret;
    class state_change c;
    function f;
    int *weight_unit;
    if (!stringp(name = ob->query_property(PROP)))
      if (!stringp(name = ob->query_medium_alias()))
        name = ob->short();
    if ( !player )
      player = this_player();
    index = transformation + ":" + name;
    if (undefinedp(table[index]))
      return 0;
    c = table[index];
    ret = clone_object(c->result);
    foreach (f in c->func)
      evaluate(f, ob, ret, player);
    if (ret->query_continuous()) {
        if ( ob->query_continuous() || ob->query_collective() ) {
            ret->set_amount(to_int(ob->query_amount() * c->factor));
        } else {
            weight_unit = ret->query_weight_unit();
            set_amount_of_ob( ret, to_int( ob->query_weight() * c->factor *
              weight_unit[1] / weight_unit[0] ) );
        }
    } else {
        if ( ob->query_continuous() || ob->query_collective() ) {
            weight_unit = ob->query_weight_unit();
            ret->set_weight(to_int(ob->query_amount() * c->factor *
                                   weight_unit[0] / weight_unit[1]));
        } else {
            ret->set_weight(to_int(ob->query_weight() * c->factor));
        }
    }
    log_file( "STATE_CHANGE", "Changed %d amount of %s to %d amount of %s via %s.\n",
      ob->query_amount(), ob->query_medium_alias(), ret->query_amount(),
      ret->query_medium_alias(), transformation );
    return ret;
}
void set_amount_of_ob( object ob, int amount ) {
  if ( !ob )
      return;
  if ( !amount )
      ob->dest_me();
  ob->set_amount( amount );
  return;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/title_handler.c ===
#include <login.h>
private mapping _pending;
private mapping _titles;
private nosave string* _allowed_multiple;
#define SAVE_FILE "/save/titles"
void load_me();
void save_me();
class blob {
   string ob;
   string func;
}
void create() {
   _pending = ([ ]);
   _titles = ([ ]);
   load_me();
   _allowed_multiple = ({ "very reverend", "mostly reverend",
                          "reverend mother", "mad granny",
                          "mad nanny", "mad mr", "mad ms", "mad miss",
                          "mad mrs" });
}
int is_allowed_multiple_title(string title) {
   return member_array(lower_case(title), _allowed_multiple) != -1;
}
string* query_allowed_multiple_titles() {
   return _allowed_multiple;
}
void add_title_to_player(string person, string title) {
   object ob;
   ob = find_player(person);
   if (ob) {
      ob->add_player_title(title);
      return ;
   }
   if (!_pending[person]) {
      _pending[person] = ({ });
   }
   _pending[person] += ({ title });
   save_me();
}
string* query_pending_titles(string person) {
   if (_pending[person]) {
      return _pending[person];
   }
   return ({ });
}
void add_controlled_title(string title, string ob, string func) {
   class blob fluff;
   fluff = new(class blob);
   fluff->ob = ob;
   fluff->func = func;
   _titles[title] = fluff;
   save_me();
}
protected class blob query_controlled_title(string title) {
   return _titles[title];
}
void check_player(object player) {
   string* titles;
   string title;
   if (!player) {
      return ;
   }
   if (_pending[player->query_name()]) {
      foreach (title in _pending[player->query_name()]) {
         player->add_player_title(title);
      }
      map_delete(_pending, player->query_name());
      save_me();
   }
   titles = player->query_all_player_titles();
   foreach (title in titles) {
      if (_titles[title]) {
         if(!find_object(_titles[title]->ob) ||
            !call_other(_titles[title]->ob, _titles[title]->func,
                        player->query_name())) {
           player->remove_player_title(title);
         }
      }
   }
}
void login_handler_call(string person, string type) {
   if (type == LOGIN) {
      call_out((: check_player(find_player($1)) :), 2, person);
   }
}
void save_me() {
   unguarded((: save_object(SAVE_FILE) :));
}
void load_me() {
   unguarded((: restore_object(SAVE_FILE, 1) :));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/group_handler.c ===
#include <group_handler.h>
#include <broadcaster.h>
#include <login_handler.h>
int _loaded;
int _groups_formed;
mapping _groups;
class group
{
   int start_time;
   string short;
   string leader_name;
   object leader;
   object *members;
   object *invited;
}
int is_group( string group );
int is_member( string name, object person );
int is_invited( string name, object person );
object *invitations_to( string name );
string query_group_short( string name );
object *members_of( string name );
object leader_of( string name );
string short_to_name( string short );
int create_group( string name );
int remove_group( string name );
int add_invite( string name, object person, int flag );
int remove_invite( string name, object person );
int add_member( string name, object person );
int remove_member( string name, object person );
varargs int set_leader( string name, object person, object appointer );
void notify_group( string name, object broadcaster, mixed message );
varargs void disband_group( string name, mixed message );
varargs object shuffle_new_leader( string group, int way, object *exclude );
void leader_goes_linkdead( string player, string event_type );
void handle_group_follow( string group, object who, object *what,
   int unfollow, int silent );
void broadcast_to_groups( string *name, string message );
string *query_groups();
int set_group_short( string, string);
void create()
{
   _groups = ([ ]);
   _loaded = time();
   _groups_formed = 0;
}
void dest_me() {
   string name;
   broadcast_to_groups( 0, "%^BOLD%^WARNING%^RESET%^: The group handler is being destructed."
      "  All active groups will be disbanded.  It should be possible to "
      "recreate the group almost immediately afterwards.  If not, please "
      "file a bug report for the \"group\" command." );
   foreach( name in query_groups() ) {
      disband_group( name, 0 );
   }
}
void stats_please() {
   printf( "The handler was loaded on %s.  Since then, "
      "%i groups have been formed.\n", ctime( _loaded ),
      _groups_formed );
}
string *query_groups() {
   return keys( _groups );
}
int is_group( string group ) {
   return !undefinedp( _groups[ group ] );
}
int is_member( string name, object person ) {
   if( !is_group( name ) ) {
      return 0;
   }
   if( member_array( person, _groups[ name ]->members ) == -1 ) {
      return 0;
   }
   return 1;
}
int is_invited( string name, object person )
{
   if( member_array( person, _groups[ name ]->invited ) != -1 )
   {
      return 1;
   }
   return 0;
}
object *invitations_to( string name )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   return _groups[ name ]->invited;
}
string query_group_short( string name )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   return _groups[ name ]->short;
}
object *members_of( string name )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   return _groups[ name ]->members;
}
object leader_of( string name )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   return _groups[ name ]->leader;
}
int query_start_time( string name )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   return _groups[ name ]->start_time;
}
string short_to_name( string short )
{
   string *words;
   short = lower_case( short );
   words = explode( short, " " );
   words -= INVALID_WORDS;
   if( !sizeof( words ) ) {
      return "";
   }
   short = implode( words, " " );
   if( BROADCASTER->query_channel_members( "group_" + short ) ) {
      return "";
   }
   return short;
}
int create_group( string name )
{
   if( is_group( name ) ) {
      return 0;
   }
   _groups += ([ name : new( class group ) ]);
   _groups[ name ]->members = ({ });
   _groups[ name ]->invited = ({ });
   _groups[ name ]->start_time = time();
   _groups_formed++;
   return 1;
}
int rename_group(string group, string new_group) {
   object member;
   if (is_group(new_group) || new_group == group) {
      return 0;
   }
   _groups[new_group] = _groups[group];
   map_delete(_groups, group);
   set_group_short(new_group, new_group);
   foreach (member in _groups[new_group]->members) {
      if (!member) {
         continue;
      }
      BROADCASTER->remove_object_from_channel( "group_" + group, member );
      member->group_membership_removed();
      member->add_effect( EFFECT, new_group);
      BROADCASTER->add_object_to_channel( "group_" + new_group, member );
      member->set_title( GROUP_TITLE, "a member of " +
      query_group_short( new_group ) );
   }
   notify_group( new_group, this_object(), ({ "", "The group has been renamed to " +
      new_group + "." }) );
   return 1;
}
int set_group_short( string name, string short_desc )
{
   if( !is_group( name ) ) {
      return 0;
   }
   _groups[ name ]->short = short_desc;
   return 1;
}
int remove_group( string name )
{
   if( !is_group( name ) ) {
      return 0;
   }
   if( _groups[ name ]->leader_name ) {
      LOGIN_HANDLER->remove_login_call(
         _groups[ name ]->leader_name, "leader_goes_linkdead",
         this_object() );
   }
   map_delete( _groups, name );
   return 1;
}
int add_invite( string name, object person, int flag )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   if( is_member( name, person ) )
   {
      return 0;
   }
   if( member_array( person, _groups[ name ]->invited ) != -1 )
   {
      return 0;
   }
   _groups[ name ]->invited += ({ person });
   if( !flag )
   {
      call_out( (: remove_invite, name, person :), INVITE_TIMEOUT );
   }
   return 1;
}
int remove_invite( string name, object person )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   if( !is_invited( name, person ) )
   {
      return 0;
   }
   _groups[ name ]->invited -= ({ person, 0 });
   return 1;
}
int add_member( string name, object person )
{
   if( !is_group( name ) )
   {
      return 0;
   }
   if( is_member( name, person ) )
   {
      return 0;
   }
   _groups[ name ]->members += ({ person });
   _groups[ name ]->invited -= ({ person });
   person->add_effect( EFFECT, name );
   BROADCASTER->add_object_to_channel( "group_" + name, person );
   notify_group( name, person, ({ "You have joined the group.",
      person->query_cap_name() + " has joined the group." }) );
   if( sizeof( _groups[ name ]->members ) > 1 )
   {
      handle_group_follow( name, person, ({ _groups[ name ]->leader }), 0, 0 );
   }
   person->set_title( GROUP_TITLE, "a member of " +
      query_group_short( name ) );
   return 1;
}
int remove_member( string name, object person )
{
   object member;
   if( !is_group( name ) )
   {
      return 0;
   }
   if( !is_member( name, person ) )
   {
      return 0;
   }
   if( person )
   {
      notify_group( name, person, ({
         "You have left the group.",
      person->query_cap_name() + " has left the group." }) );
      foreach( member in person->query_assisting() )
      {
         if( !member )
         {
            continue;
         }
         member->remove_assister( person );
      }
      foreach( member in person->query_assisters() )
      {
         if( !member )
         {
            continue;
         }
         member->remove_assisting( person );
      }
   }
   _groups[ name ]->members -= ({ person });
   BROADCASTER->remove_object_from_channel( "group_" + name, person );
   if( person )
   {
      person->group_membership_removed();
   }
   if( person == leader_of( name ) && sizeof( members_of( name ) ) )
   {
      if (sizeof(members_of(name)) == 1) {
         notify_group( name, this_object(), "The current leader has left "
            "the group, you are now all alone.  Better start recruiting.");
      } else {
         notify_group( name, this_object(), "The current leader has left "
            "the group.  A new leader will be chosen randomly." );
      }
      if( !shuffle_new_leader( name, 0 ) )
      {
         notify_group( name, this_object(), "The choosing of a new "
            "leader has failed (oh dear).  The group is hereby "
            "disbanded.\n" );
         call_out( "disband_group", 0, name );
         return 1;
      }
   }
   handle_group_follow( name, person, _groups[ name ]->members, 1, 1 );
   foreach( member in _groups[ name ]->members ) {
      handle_group_follow( name, member, ({ person }), 1, 1 );
   }
   if (person && objectp(person)) {
      person->remove_title( GROUP_TITLE );
   }
   if( !sizeof( members_of( name ) ) ) {
      remove_group( name );
   }
   return 1;
}
varargs int set_leader( string name, object person, object appointer )
{
   object *followers, old_leader, member;
   if( !is_group( name ) )
   {
      return 0;
   }
   if( !is_member( name, person ) )
   {
      return 0;
   }
   if( !person )
   {
      return 0;
   }
   if( _groups[ name ]->leader_name )
   {
      LOGIN_HANDLER->remove_dynamic_login_call(
         _groups[ name ]->leader_name, "leader_goes_linkdead",
         base_name( this_object() ) );
   }
   old_leader = _groups[ name ]->leader;
   if( old_leader )
   {
      followers = ( old_leader->query_followers() & _groups[ name ]->members );
      followers -= ({ 0 });
      followers += ({ old_leader });
      foreach( member in followers )
      {
         handle_group_follow( name, member, ({ old_leader }), 1, 1 );
         handle_group_follow( name, member, ({ person }), 0, 1 );
      }
      old_leader->set_title( GROUP_TITLE, "a member of " +
         query_group_short( name ) );
   }
   _groups[ name ]->leader = person;
   if( userp( person ) ) {
      _groups[ name ]->leader_name = person->query_name();
      LOGIN_HANDLER->add_dynamic_login_call( person->query_name(),
         "leader_goes_linkdead", base_name( this_object() ) );
   }
   else
   {
      _groups[ name ]->leader_name = 0;
   }
   if( !appointer )
   {
      notify_group( name, person, ({ "You are now the leader of "
         "the group.", person->query_cap_name() + " is now the leader "
         "of the group." }) );
   }
   else
   {
      notify_group( name, appointer, "By the power vested in " +
         appointer->query_cap_name() + ", " + person->query_cap_name() +
         " has been appointed as the new leader of the group." );
   }
   person->set_title( GROUP_TITLE, "the leader of " +
      GROUP->query_group_short( name ) );
   return 1;
}
void notify_group( string name, object broadcaster, mixed message ) {
   BROADCASTER->broadcast_to_channel( broadcaster, "group_" + name,
      ({ message, time() }) );
}
varargs void disband_group( string name, mixed message ) {
   object bugger, leader, *members;
   if( !is_group( name ) ) {
      return;
   }
   if( message ) {
      notify_group( name, this_object(), message );
   }
   members = members_of( name );
   leader = leader_of( name );
   if( leader ) {
      members -= ({ leader });
   }
   foreach( bugger in members ) {
      remove_member( name, bugger );
   }
   remove_member( name, leader );
   remove_group( name );
}
varargs object shuffle_new_leader( string group, int way, object *exclude ) {
   object leader;
   object *members;
   if( !is_group( group ) ) {
      return 0;
   }
   members = members_of( group );
   if( !sizeof( members ) ) {
      return 0;
   }
   if( exclude ) {
      members -= exclude;
   }
   members = filter( members, (: $1 && interactive( $1 ) :) );
   if( !sizeof( members ) ) {
      return 0;
   }
   switch( way ) {
      case 0:
         leader = members[ random( sizeof( members ) ) ];
         if( set_leader( group, leader ) ) {
            return leader;
         }
         return 0;
      default:
         return 0;
   }
}
void leader_goes_linkdead( string player, string event_type ) {
   string group;
   object player_ob, *members;
   if( event_type != NETDEATH && event_type != RECONNECT ) {
      LOGIN_HANDLER->remove_dynamic_login_call( player,
         "leader_goes_linkdead", base_name( this_object() ) );
      return;
   }
   if( !player_ob = find_player( player ) ) {
      LOGIN_HANDLER->remove_dynamic_login_call( player,
         "leader_goes_linkdead", base_name( this_object() ) );
      return;
   }
   group = player_ob->query_group();
   if( !group ) {
      LOGIN_HANDLER->remove_dynamic_login_call( player,
         "leader_goes_linkdead", base_name( this_object() ) );
      return;
   }
   if( _groups[ group ]->leader_name != player ) {
      LOGIN_HANDLER->remove_dynamic_login_call( player,
         "leader_goes_linkdead", base_name( this_object() ) );
      return;
   }
   members = members_of( group );
   members -= ({ player_ob });
   if( !sizeof( members ) ) {
      return;
   }
   LOGIN_HANDLER->remove_dynamic_login_call( player,
      "leader_goes_linkdead", base_name( this_object() ) );
   notify_group( group, this_object(), "The current leader "
      "has gone netdead.  A new leader will be selected at random." );
   if( !shuffle_new_leader( group, 0, 0 ) ) {
      notify_group( group, this_object(), "No eligible leaders "
         "found.  The group is disbanded." );
      disband_group( group );
   }
}
void handle_group_follow( string group, object who, object *what,
   int unfollow, int silent ) {
   string short, mess_to_me, mess_to_others;
   switch( unfollow ) {
      case 0:
         what = filter( what, (: $1->add_follower( $( who ) ) :) );
         if( !sizeof( what ) ) {
            mess_to_me = "You begin following noone.";
            break;
         }
         short = query_multiple_short( what );
         mess_to_me = "You begin following " + short + ".";
         mess_to_others = who->query_cap_name() + " begins following " +
            short + ".";
         break;
      case 1:
         what = filter( what, (: $1->remove_follower( $( who ) ) :) );
         if( !sizeof( what ) ) {
            mess_to_me = "You stop following noone.";
            mess_to_others = 0;
            break;
         }
         short = query_multiple_short( what );
         mess_to_me = "You stop following " + short + ".";
         mess_to_others = who->query_cap_name() + " stops following " +
            short + ".";
         break;
      default:
         printf( "Barf.\n" );
         return;
   }
   if( !silent ) {
      notify_group( group, who, ({ mess_to_me, mess_to_others }) );
   }
}
void broadcast_to_groups( string *name, string message ) {
   string group;
   string *groups;
   if( name && sizeof( name ) ) {
      groups = name;
   }
   else {
      groups = keys( _groups );
   }
   foreach( group in groups ) {
      notify_group( group, this_player(), message );
   }
}
mapping query_dynamic_auto_load() {
   return ([ "groups" : _groups,
             "groups formed" : _groups_formed ]);
}
void init_dynamic_arg(mapping map) {
   _groups = map["groups"];
   _groups_formed = map["groups formed"];
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/monster_handler.c ===
int num;
void create() {
  seteuid("Room");
  unguarded((: restore_object, "/save/monster-handler" :));
}
string query_shadow_name() {
  num++;
  return "/tmp/mon-shad/frog-"+num;
}
void reset() {
  unguarded((: save_object, "/save/monster-handler" :));
}
void dest_me() {
  unguarded((: save_object, "/save/monster-handler" :));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/non_refuelling_lantern.c ===
#include <fuel_handler.h>
inherit "/std/object";
#define BRIGHTNESS      60
#define FUEL_PER_TICK  FUEL_TIME
#define MAX_FUEL 3600
int  fuel_left;
int  is_lit;
void create(){
  ::create();
}
string short( int i ) {
  if ( is_lit )
    return ::short( 0 ) + " (lit)";
  return ::short( 0 );
}
int do_extinguish() {
   if ( !is_lit ) {
      this_player()->add_failed_mess(this_object(), "$D is not lit.\n", ({ }));
      return 0;
   }
   FUEL_HANDLER->remove_burner( this_object() );
   is_lit = 0;
   set_light( 0 );
   return 1;
}
int do_dowse() {
   return do_extinguish();
}
int do_light() {
   if ( is_lit ) {
      this_player()->add_failed_mess( this_object(), "$D is already lit.\n",
                                     ({ }) );
      return 0;
   }
   if ( fuel_left <= 0 ) {
      this_player()->add_failed_mess( this_object(), "$D is out of fuel.\n",
                                     ({ }) );
      return 0;
   }
   FUEL_HANDLER->add_burner( this_object() );
   is_lit = 1;
   set_light( BRIGHTNESS );
   return 1;
}
void init() {
   this_player()->add_command("light", this_object());
   this_player()->add_command("extinguish", this_object());
   this_player()->add_command("dowse", this_object());
}
void out_of_fuel() {
   object env;
   is_lit    = 0;
   fuel_left = 0;
   env = environment( this_object() );
   FUEL_HANDLER->remove_burner( this_object() );
   set_light( 0 );
   if ( interactive( env ) ) {
      write( poss_short() +" burns out.\n" );
      tell_room( environment(env), poss_short() +" burns out.\n", env );
   } else
      say( poss_short() +" burns out.\n" );
}
void consume_fuel() {
   fuel_left -= FUEL_PER_TICK;
   switch ( fuel_left ) {
    case -10000 .. 0:
      out_of_fuel();
      break;
    default:
   }
}
string pretty_plural( object thing) {
  if ( is_lit )
    return ::pretty_plural(thing) + " (lit)";
  return ::pretty_plural(thing);
}
void dest_me() {
   set_light( 0 );
   FUEL_HANDLER->remove_burner( this_object() );
   ::dest_me();
}
mixed *stats() {
  return ::stats() + ({
    ({ "fuel" , fuel_left, }),
    ({ "is lit", is_lit, }),
   });
}
mapping query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "fuel left" : fuel_left,
             "is lit" : is_lit,
          ]);
}
void init_dynamic_arg( mapping arg ) {
   fuel_left = arg["fuel left"];
   if ( arg[ "is lit" ] ) {
      FUEL_HANDLER->add_burner( this_object() );
      is_lit = 1;
      set_light(BRIGHTNESS);
   }
   ::init_dynamic_arg( arg["::"] );
}
int query_fuel_left() {
    return fuel_left;
}
void set_fuel_left( int i ) {
    if ( i > MAX_FUEL ) {
        i = MAX_FUEL;
    }
    fuel_left = i;
}
int query_max_fuel() {
    return MAX_FUEL;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/map_helper.c ===
#include <map_handler.h>
mapping shorts = ([ ]), movezones = ([ ]), changetimes = ([ ])
#if !efun_defined(db_exec)
, clusters = ([ ]), map = ([ ])
#endif
;
#ifdef COORDS
mapping coords = ([ ]), sizes = ([ ]);
#endif
string directory;
nosave string loaded;
nosave int save;
void create() {
   seteuid( (string)master()->get_bb_uid() );
}
void save_dir() {
#ifdef HELPLOGTO
   tell_object( find_living( LOGTO ), "%^RED%^saving%^RESET%^ "+ loaded +"\n");
#endif
   if (sizeof(shorts) ||
       sizeof(movezones) ||
       sizeof(changetimes) ||
#ifdef COORDS
       sizeof(coords) ||
       sizeof(sizes) ||
#endif
#if !efun_defined(db_exec)
       sizeof(clusters) ||
       sizeof(map) ||
#endif
        0) {
      unguarded((: save_object, "/save/map/" + loaded :));
   } else {
      unguarded((: rm("/save/map/" + loaded) :));
   }
   save = 0;
}
void check_dir( string dir ) {
   string tmp_file;
   if ( dir == directory ) {
      return;
   }
   if ( save )  {
      save_dir();
   }
   tmp_file = replace_string( dir, "/", "_" );
   shorts = ([ ]);
   movezones = ([ ]);
   changetimes = ([ ]);
#if !efun_defined(db_exec)
   clusters = ([ ]);
   map = ([ ]);
#endif
#ifdef COORDS
   coords = ([ ]);
   sizes = ([ ]);
#endif
   if ( file_size( "/save/map/" + tmp_file + ".o" ) > 0 ) {
#ifdef HELPLOGTO
      tell_object( find_living( LOGTO ), "%^GREEN%^loading%^RESET%^ "+ tmp_file
                   +"\n");
#endif
      unguarded((: restore_object, "/save/map/" + tmp_file :));
   } else {
#ifdef HELPLOGTO
      tell_object( find_living( LOGTO ), "%^BLUE%^newmap%^RESET%^ "+ tmp_file +"\n");
#endif
      shorts = ([ ]);
      movezones = ([ ]);
      changetimes = ([ ]);
#if !efun_defined(db_exec)
      clusters = ([ ]);
      map = ([ ]);
#endif
#ifdef COORDS
      coords = ([ ]);
      sizes = ([ ]);
#endif
   }
   loaded = tmp_file;
   directory = dir;
}
#if !efun_defined(db_exec)
void change_map( string dir, string room, string *dd ) {
   check_dir( dir );
   map[ room ] = dd;
   save = 1;
}
mapping query_map( string dir ) {
   check_dir( dir );
   if ( !map )
     return ([ ]);
   return map;
}
#endif
void change_shorts( string dir, string room, string sh ) {
   check_dir( dir );
   shorts[ room ] = sh;
   save = 1;
}
mapping query_shorts( string dir ) {
   check_dir( dir );
   if ( !shorts ) {
     return ([ ]);
   }
   return shorts;
}
void change_movezones( string dir, string room, string *zones ) {
   check_dir( dir );
   movezones[ room ] = zones;
   save = 1;
}
mapping query_movezones( string dir ) {
   check_dir( dir );
   if ( !movezones )
     return ([ ]);
   return movezones;
}
#if !efun_defined(db_exec)
void change_clusters( string dir, string room, int cluster ){
  check_dir( dir );
  if(!clusters)
    clusters = ([]);
  clusters[ room ] = cluster;
  save = 1;
}
mapping query_clusters( string dir ){
  check_dir( dir );
  if( !clusters )
    return ([ ]);
  return clusters;
}
#endif
void change_changetimes( string dir, string room, int time ) {
   check_dir( dir );
   if ( !changetimes )
      changetimes = ([ ]);
   changetimes[ room ] = time;
   save = 1;
}
mapping query_changetimes( string dir ) {
   check_dir( dir );
   if ( !changetimes )
     return ([ ]);
   return changetimes;
}
#ifdef COORDS
void change_co_ords( string dir, string room, int *coord ) {
   check_dir( dir );
   if ( !coords )
      coords = ([ ]);
   coords[ room ] = coord;
   save = 1;
}
mapping query_co_ords( string dir ) {
   check_dir( dir );
   if ( !coords )
     return ([ ]);
   return coords;
}
void change_sizes( string dir, string room, int size ) {
   check_dir( dir );
   if ( !sizes )
      sizes = ([ ]);
   sizes[ room ] = size;
   save = 1;
}
mapping query_sizes( string dir ) {
   check_dir( dir );
   if ( !sizes )
     return ([ ]);
   return sizes;
}
#endif
void del( string dir, string room ) {
   check_dir( dir );
#if !efun_defined(db_exec)
   if (mapp(map)) {
     map_delete( map, room );
   } else {
     map = ([ ]);
   }
#endif
   if (mapp(shorts)) {
     map_delete( shorts, room );
   } else {
     shorts = ([ ]);
   }
   if (mapp(movezones)) {
     map_delete( movezones, room );
   } else {
     movezones = ([ ]);
   }
   if (mapp(changetimes)) {
     map_delete( changetimes, room );
   } else {
     changetimes = ([ ]);
   }
#if !efun_defined(db_exec)
   if (mapp(clusters)) {
     map_delete( clusters, room );
   } else {
     clusters = ([ ]);
   }
#endif
#ifdef COORDS
   if (mapp(coords)) {
     map_delete( coords, room );
   } else {
     coords = ([ ]);
   }
   if (mapp(sizes)) {
     map_delete( sizes, room );
   } else {
     sizes = ([ ]);
   }
#endif
   save = 1;
}
