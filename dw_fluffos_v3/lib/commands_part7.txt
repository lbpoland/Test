
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/climb.c ===
#include <tasks.h>
#define TP this_player()
#define SKILL "other.movement.climbing.rock"
inherit "/cmds/base";
void fall_off( object place, int number ) {
   if ( place->query_at_bottom() ) {
      write( "You try to climb, but you can't seem to get anywhere.\n" );
      say( (string)TP->one_short() + " tries to climb, but fails.\n" );
      return;
   }
   if ( random( (int)TP->query_dex() ) < number / 20 ) {
      write( "You begin to climb, but your fatigue makes you "+
            "clumsily lose your grip.\n" );
      say( (string)TP->one_short() +
            " begins to climb but clumsily loses "+
            (string)TP->query_possessive() +" grip.\n" );
      place->fall_down( TP );
      return;
   }
   write( "You begin to climb but wobble precariously and decide to "+
         "stay put for the moment.\n" );
   say( (string)TP->one_short() +
            " begins to climb, but wobbles precariously and stops.\n" );
}
mixed cmd( string words ) {
   int difficulty;
   object place;
   mixed ghost_action;
   mixed *move;
   string *move_descs = ({ "", "", "" });
   string skill;
   place = environment( TP );
   if ( !place ) {
      add_failed_mess( "You cannot climb anything: you're in limbo!\n" );
      return 0;
   }
   move = (mixed *)place->query_move( words );
   if ( !move ) {
      if( sizeof( place->query_moves() ) )
         add_failed_mess( "You cannot climb \""+ words +"\" from here.\n" );
      else
         add_failed_mess( "There is nothing to climb here.\n" );
      return 0;
   }
   if( stringp( move[2] ) ) {
      move_descs[0] =
         "You climb "+ words +".\n";
      move_descs[1] =
         "$N slowly climb$s "+ words +" and disappears from view.";
      move_descs[2] =
         copy( move[2] );
   } else if( sizeof( move[2] ) == 3 ) {
      move_descs = copy( move[2] );
      move_descs[0] += "\n";
   } else {
      return 0;
   }
   if ( TP->query_property( "dead" ) ) {
      ghost_action = place->query_ghost_action( place );
      if ( ! ghost_action ) {
          TP->move_with_look( move[ 1 ], move_descs[ 2 ], move_descs[ 1 ] );
          add_succeeded_mess("");
          return 1;
      }
      else if ( intp( ghost_action ) && ghost_action == 1 ) {
          add_failed_mess( "How can you climb anything?  You're dead!\n");
          return 0;
      }
      else if ( stringp( ghost_action ) ) {
          write( "As you move to climb the wall, your inherent wispiness gets "
              "the better of you, and you fall through to the other side.\n" );
          TP->move_with_look( ghost_action,
              "$N wisps through the wall with some undue haste.",
              "$N tries to climb the wall, but falls through it." );
          add_succeeded_mess( "" );
          return 1;
      }
      else if ( arrayp( ghost_action ) ) {
          write( ghost_action[ 1 ][ 0 ] + "\n" );
          TP->move_with_look( ghost_action[ 0 ],
              ghost_action[ 1 ][ 1 ], ghost_action[ 1 ][ 2 ] );
          add_succeeded_mess( "" );
          return 1;
      }
      else {
          TP->move_with_look( move[ 1 ], move_descs[ 2 ], move_descs[ 1 ] );
          add_succeeded_mess("");
          return 1;
      }
   }
   if( intp( move[0] ) ) {
      difficulty = move[0] + (int)TP->query_loc_weight() / 10;
      skill = SKILL;
   } else if( arrayp( move[0] ) && sizeof( move[0] ) > 1 ) {
      difficulty = move[0][0] + (int)TP->query_loc_weight() / 10;
      skill = move[0][1];
      debug_printf( "Base difficulty: %d, total difficulty: %d, skill: %s\n",
                    move[0][0], difficulty, move[0][1] );
   }
   if ( (int)TP->query_specific_gp( "other" ) < difficulty ) {
      fall_off( place, difficulty );
      add_succeeded_mess("");
      return 1;
   }
   TP->adjust_gp( -difficulty / 2 );
   switch ( (int)TASKER->perform_task(TP, skill, difficulty,
                                      TM_COMMAND)) {
      case AWARD :
         call_out( "advance_notice", random( 60 ), TP );
      case SUCCEED :
         write( move_descs[ 0 ] );
         TP->move_with_look( move[ 1 ], move_descs[ 2 ],
               move_descs[ 1 ] );
         return 1;
      default :
         break;
   }
   difficulty = random( difficulty );
   if ( (int)TP->query_specific_gp( "other" ) < difficulty ) {
      fall_off( place, difficulty );
      add_succeeded_mess("");
      return 1;
   }
   TP->adjust_gp( -difficulty );
   switch ( (int)TASKER->perform_task(TP, skill,  difficulty / 2,
                                      TM_COMMAND)) {
      case AWARD :
         write( "%^YELLOW%^You manage not to fall off!%^RESET%^\n" );
      case SUCCEED :
         write( "You begin to climb but wobble precariously and decide to "+
               "stay put for the moment.\n" );
         say( (string)TP->one_short() +
               " begins to climb, but wobbles precariously and stops.\n" );
         break;
      default :
         fall_off( place, difficulty );
         break;
   }
   add_succeeded_mess("");
   return 1;
}
void advance_notice( object thing ) {
   if ( !thing )
      return;
   tell_object( thing, "%^YELLOW%^"+ ({
      "In a flash of inspiration, you realise how to balance better "+
            "when climbing.",
      "Thinking about your climb, you realise something important.",
      "You realise that you've been using better grips to climb.",
      "You realise you've discovered how to find better places to "+
            "support your feet.",
      "You find you've worked out a more sensible way to distribute "+
            "your weight as you climb.",
      "With all your climbing, you discover you've found a better way "+
            "to locate handholds."
   })[ random( 6 ) ] +"%^RESET%^\n" );
}
mixed *query_patterns() {
   return ({ "<string'direction'>", (: cmd($4[0]) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/debate.c ===
#include <tasks.h>
#define EFFECT "/std/effects/religious/theological_debate"
#define HANDLER "/obj/handlers/philosophies"
#define DEBATE_MULT 4
inherit "/cmds/base";
mapping _debaters;
void create() {
   _debaters = ([ ]);
}
mixed cmd(object * indirect_obs,
          string indir_match,
          string dir_match,
          mixed *args,
          string pattern)
{
   int bonus;
   string topic;
   string type;
   string needed;
   object target;
   if (sizeof((int *)this_player()->effects_matching("debating"))) {
      return notify_fail("You are already engaged in a debate.\n");
   }
   if (_debaters[this_player()]) {
      tell_object(_debaters[this_player()][0],
                  this_player()->the_short() + " withdraws their debating "
                  "challenge from you.\n");
      map_delete(_debaters, this_player());
   }
   target = indirect_obs[0];
   if (target == this_player()) {
      return notify_fail("Debating with yourself?  Which one of your "
         "personalities are you trying to outwit?\n");
   }
   if (userp(target) && !interactive(target)) {
      return notify_fail("How can you debate anything with a net-dead "
                         "statue?\n");
   }
   topic = args[0];
   if (_debaters[target] && _debaters[target][0] == this_player()) {
      if ((_debaters[target][0] == this_player()) &&
          (_debaters[target][1] == topic)) {
         write("You accept " + (string) target->the_short() +
               "'s challenge to debate " + topic + ".\n");
         say((string) this_player()->the_short() + " accepts " +
             (string) target->the_short() + "'s challenge to debate " +
             topic + ".\n", target);
         tell_object(target, (string) this_player()->the_short() +
                     " accepts your challenge to debate " + topic + ".\n");
         map_delete(_debaters, target);
         this_player()->add_effect(EFFECT, target);
         target->add_effect(EFFECT, this_player());
         return 1;
      }
   }
   if (!HANDLER->query_philosophy(topic)) {
      return notify_fail("You cannot debate \"" + topic + "\".  You can " +
                         "debate " + query_multiple_short((string *) HANDLER->
                                                          query_philosophy_names
                                                          ()) + ".\n");
   }
   type = (string) HANDLER->query_philosophy_type(topic);
   bonus = (int) HANDLER->query_philosophy_bonus(topic);
   needed = (string) HANDLER->query_philosophy_needed(topic);
   if (this_player()->query_skill_bonus(type + ".points") < bonus) {
      return notify_fail(needed + " is not sufficient to debate " +
                         topic + " at the moment.\n");
   }
   if (this_player()->query_specific_gp(type) < bonus) {
      return notify_fail("You are too tired to debate " + topic +
                         " at the moment.\n");
   }
   this_player()->adjust_gp(-(bonus * DEBATE_MULT));
   write("You challenge " + (string) target->the_short() +
         " to a debate on " + topic + ".\n");
   say((string) this_player()->one_short() + " challenges " +
       (string) target->one_short() + " to a debate on " + topic + ".\n",
       target);
   tell_object(target,
               (string) this_player()->one_short() +
               " challenges you to a debate on " + topic + ".\n");
   _debaters[this_player()] = ({ target, topic });
   call_out("answer_challenge", 5, this_player(), target, topic);
   return 1;
}
void answer_challenge(object challenger,
                      object target,
                      string topic)
{
   int bonus;
   int diff;
   string type;
   if (!challenger) {
      return;
   }
   if (!target) {
      return;
   }
   if (environment(challenger) != environment(target)) {
      return;
   }
   if (!_debaters[challenger]) {
      return;
   }
   if ((_debaters[challenger][0] != target) || (_debaters[challenger][1] != topic)) {
      return;
   }
   if (pk_check(challenger, target)) {
      tell_object(target, "Use \"debate " + topic + " with " +
                  (string) challenger->query_name() +
                  "\" to accept the challenge.\n");
      return;
   }
   type = (string) HANDLER->query_philosophy_type(topic);
   bonus = (int) target->query_skill_bonus(type + ".points");
   diff = (int) target->query_skill_bonus(type + ".points") / 3;
   switch ((int) TASKER->perform_task(challenger, type + ".points", 2 * diff,
                                      TM_COMMAND)) {
   case AWARD:
      tell_object(challenger, "You feel " +
                  (string) HANDLER->query_philosophy_needed(topic) +
                  " surge for a moment.\n");
   case SUCCEED:
      tell_object(target, "You find yourself accepting " +
                  (string) challenger->the_short() +
                  "'s challenge to debate " + topic + ".\n");
      tell_room(environment(target),
                (string) target->the_short() + " accepts " +
                (string) challenger->the_short() + "'s challenge to debate " +
                topic + ".\n", ({ target, challenger }));
      tell_object(challenger,
                  (string) target->the_short() +
                  " accepts your challenge to debate " + topic + ".\n");
      map_delete(_debaters, target);
      this_player()->add_effect(EFFECT, target);
      target->add_effect(EFFECT, this_player());
      return;
   default:
      if (userp(target)) {
         tell_object(target, "Use \"debate " + topic + " with " +
                     (string) challenger->query_name() +
                     "\" to accept the challenge.\n");
      }
   }
}
mapping query_debaters()
{
   return _debaters;
}
mixed *query_patterns()
{
   return ({ "<word'topic'> with <indirect:living'person'>",
             (: cmd($1, $2, $3, $4, $5) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/l_ook.c ===
#include <player.h>
#include <weather.h>
#include <dirs.h>
#include <error_handler.h>
#include <db.h>
#include <terrain_map.h>
inherit "/cmds/base";
#define TP this_player()
string weather_long(string str);
int check_exists(string file);
string look_around();
mixed cmd_string(string arg);
void finish_bug_summary(object player, int type, mixed data) {
   class error_complete summ;
   class error_complete* errors;
   string str;
   int pos;
   if (type != DB_SUCCESS) {
      return ;
   }
   errors = data;
   if (!sizeof(errors)) {
      tell_object(player, "No errors for this room.\n");
      return ;
   }
   str = "";
   str = sprintf("#<bug id>  ( <date> ) %5-s %4-s %-4s by %11-s %11-s\n",
                 "Status", "Type", "Cat", "Reporter", "Assigned");
   foreach (summ in errors) {
      pos = strsrch(summ->details->report, "\n");
      if (pos < 0 || pos > player->query_cols() - 5) {
         pos = player->query_cols() - 5;
      } else {
         pos --;
      }
      str += sprintf("$I$3=#%d (%s) %5-s %4-s %-4s by %11-s %11-s\n%s\n",
                     summ->details->summary->id,
                     ctime(summ->details->summary->entry_date)[4..15],
                     summ->details->summary->status[0..4],
                     summ->details->summary->type,
                     summ->details->summary->category[0..3],
                     summ->details->summary->reporter,
                     summ->details->summary->assigned_to,
                     summ->details->report[0..pos]);
   }
   tell_object(player, str);
}
void show_error_summary(object player, string* types) {
   class error_query query;
   if (!arrayp(types) || !sizeof(types)) {
      return ;
   }
   query = new(class error_query);
   query->file_name = file_name(environment(player));
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   query->type = types;
   query->no_extra_details = 1;
   ERROR_HANDLER->do_query_multiple_bug_details(query, (: finish_bug_summary, player :));
}
int cmd_look_room()
{
   object room;
   int dark;
   string ret;
   int *coords;
   room = environment(TP);
   if (!room) {
      add_failed_mess("You are in limbo... sorry you can't look at " +
                      "anything.\n");
      return 0;
   }
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   if (!TP->query_property("dead")) {
      dark = (int) TP->check_dark((int) room->query_light());
   }
   if (TP->query_creator()) {
      coords = room->query_co_ord();
      if (sizeof(coords)) {
         ret = "  (" + coords[0] + "," + coords[1] + "," + coords[2] + ")";
      } else {
         ret = "  (unset)";
      }
      if (virtualp(room)) {
         write("%^CYAN%^" + file_name(room) + " [" +
                room->query_property("base path")  + "]" + ret + "%^RESET%^\n");
      } else {
         write("%^CYAN%^" + file_name(room) + ret + "%^RESET%^\n");
      }
   }
   if ((TP->query_creator() || TP->query_playtester()) &&
       TP->query_property(TERRAIN_MAP_IN_LOOK_PROP)) {
      ret = room->long_test(0, dark);
      if (ret) {
         write("$P$Look$P$" + ret);
      } else {
         write("$P$Look$P$" + (string) room->long(0, dark));
      }
   } else {
      write("$P$Look$P$" + (string) room->long(0, dark));
   }
   if (dark && TP->query_creator()) {
      write("%^YELLOW%^As a creator, you can see:%^RESET%^\n" +
            (string) room->long(0, 0));
   }
   if (TP->query_creator() && TP->query_property(PLAYER_SHOW_ERRORS_PROP)) {
      show_error_summary(this_player(), TP->query_property(PLAYER_SHOW_ERRORS_PROP));
   }
   return 1;
}
string query_look_thing(object thing,
                        object player,
                        int dark,
                        string verb,
                        string arg)
{
   string ret;
   object env;
   string other;
   string replaced;
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   ret = "";
   if (living(thing)) {
      if (thing == player) {
         ret += "Looking at yourself again?  What a narcissist!\n";
      } else {
         tell_object(thing, "$one_short:" + file_name(player) +
                     "$ $V$0=looks,look$V$ at you.\n");
      }
   } else {
      env = environment(thing);
      while (env && !living(env)) {
         env = environment(env);
      }
   }
   if (env && env != player) {
      tell_object(env, player->the_short() + " " + verb + " "
                  "at your " + thing->pretty_short() + ".\n");
      other = thing->query_long(arg, dark);
      if (other) {
         replaced = thing->replace_long_dollars(player, other);
         if (replaced) {
            ret += replaced;
         }
         else {
            ret += other;
         }
      }
      other = thing->query_long_details(arg, dark, player);
      if (other) {
         ret += other;
      }
   } else {
      ret += thing->long(arg, dark);
   }
   return ret;
}
mixed cmd_object(object * obs,
                 string arg)
{
   object thing;
   object room;
   int dark;
   int retval;
   string ret;
   room = environment(TP);
   if (LENGTHEN[arg]) {
     arg = LENGTHEN[arg];
   }
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   if (!room) {
      add_failed_mess("You are in limbo... sorry you can't look at " +
                      "anything.\n");
      return 0;
   }
   if (!TP->query_property("dead")) {
      dark = (int) TP->check_dark((int) room->query_light());
   }
   if (dark == 2) {
      add_failed_mess("It is way too bright to see anything at all.\n");
      return 0;
   }
   if (dark == -2) {
      add_failed_mess("It is way too dark to see anything at all.\n");
      return 0;
   }
   ret = "";
   foreach(thing in obs) {
      ret += query_look_thing(thing, this_player(), dark, "looks", arg);
   }
   if (ret != "") {
      write("$P$Look$P$" + ret);
      retval = 1;
   }
   if (room->query_exit(arg))
      cmd_string(arg);
   else {
      arg = (string) this_player()->find_abs(arg);
      if (room->query_exit(arg))
         cmd_string(arg);
   }
   return 1;
}
mixed cmd_string(string arg)
{
   object room;
   int dark;
   int retval;
   string ret;
   string other;
   string orig_arg;
   mixed *func;
   room = environment(TP);
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   if (!room) {
      add_failed_mess("You are in limbo... sorry you can't look at " +
                      "anything.\n");
      return 0;
   }
   switch (arg) {
   case "soul":
      write((string) "/obj/handlers/new_soul"->help_list());
      return 1;
   case "sun":
   case "moon":
   case "stars":
   case "weather":
   case "sky":
      write(weather_long(arg));
      return 1;
   case "around":
      write(look_around());
      return 1;
   }
   orig_arg = arg;
   if (!TP->query_property("dead")) {
      dark = (int) TP->check_dark((int) room->query_light());
   }
   if (dark == 2) {
      add_failed_mess("It is way too bright to see anything at all.\n");
      return 0;
   }
   if (dark == -2) {
      add_failed_mess("It is way too dark to see anything at all.\n");
      return 0;
   }
   if (LENGTHEN[arg]) {
      arg = LENGTHEN[arg];
   }
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   if (!room->query_exit(arg)) {
      arg = (string) this_player()->find_abs(arg);
   }
   if (room->query_exit(arg)) {
      int tmp_ret_val;
      room->set_destination(arg);
      other = (string) room->query_destination(arg);
      ret = room->query_look(arg);
      if (ret && ret != "") {
         write(ret + "\n");
         retval = 1;
         tmp_ret_val = 1;
      }
      func = room->query_look_func(arg);
      if (pointerp(func) && sizeof(func) >= 1 && func[0] && func[1]) {
         if (call_other(func[0], func[1], 1)) {
            retval = 1;
            tmp_ret_val = 1;
         }
      } else if (functionp(func)) {
         if (evaluate(func, 1)) {
            retval = 1;
            tmp_ret_val = 1;
         }
      }
      if (check_exists(other) && !tmp_ret_val) {
         object door;
         door = room->query_door_control(arg);
         if (room->query_door_open(arg) || door->query_transparent()) {
            other->force_load();
            dark = (int) TP->check_dark((int) other->query_light());
            ret = other->long(0, dark);
            this_player()->set_looked(find_object(other));
            write(ret);
            retval = 1;
         } else {
            add_failed_mess(door->the_short() +
                            " is closed and not transparent.\n");
            retval = 0;
         }
      }
   }
   return retval;
}
int check_exists(string file)
{
   int retval;
   if (objectp(find_object(file))) {
      return 1;
   }
   if (strsrch(file, ":")) {
      return 1;
   }
   if (file_size(file + ".c") > 0) {
      retval = 1;
   } else {
      retval = 0;
   }
   return retval;
}
string weather_long(string str)
{
   object env;
   string temp;
   string whandler;
   env = environment(TP);
   temp = (string) env->query_property("location");
   switch (temp) {
   case ("inside"):
      return "You are not outside.\n";
   }
   whandler = env->query_weather_handler() ;
   if ( ! whandler ) {
       whandler = WEATHER ;
   }
   if (str == "sun") {
      if (whandler->query_day(env)) {
         return "Ouch that hurts.\n";
      } else {
         return "The sun is not up, sorry.\n";
      }
   }
   if (str == "moon") {
      if (whandler->query_day(env)) {
         return "The moon is not up, try at night.\n";
      } else if ( (temp = whandler->query_moon_string(env)) ) {
         return temp;
      } else {
         return "The moon is not up at the moment, try again later.\n";
      }
   }
   if (str == "stars") {
       if (whandler->query_day(env)) {
           return "The stars are not out at the moment - try at night.\n" ;
       } else {
           if ( (temp = whandler->query_star_string(env)) ) {
               return temp ;
           } else {
               return "There aren't any visible stars right now.\n" ;
           }
       }
   }
   return "You look up at the sky.  " + whandler->weather_string(env) + ".\n";
}
string look_around()
{
   int i;
   int j;
   string prep;
   string room;
   string *parts;
   string *rooms;
   object place;
   object thing;
   object *contents;
   mixed *locations;
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   place = environment(this_player());
   if (place->query_linked()) {
      rooms = (string *) place->query_rooms();
   } else {
      rooms = ({ });
   }
   locations = ({ });
   say((string) this_player()->one_short() + " $V$0=looks,look$V$ around.\n");
   foreach(room in rooms) {
      if (!find_object(room)) {
         continue;
      }
      if (this_player()->check_dark((int) room->query_light())) {
         continue;
      }
      contents = ({ });
      foreach(thing in all_inventory(find_object(room))) {
         if (living(thing) && thing->query_visible(this_player()))
            contents += ({ thing });
      }
      if (!sizeof(contents)) {
         continue;
      }
      prep = (string) room->query_static_preposition();
      if (prep != "") {
         if (!stringp(prep)) {
            prep = sprintf("%O", prep);
         }
         prep += " ";
      }
      locations += ({ ({ contents, prep +
                         (string) this_player()->
                         convert_message((string) room->the_short())
                      }) });
   }
   if (!sizeof(locations)) {
      contents = ({ });
      if (this_player()->check_dark((int) place->query_light())) {
         return "You can't see well enough to look around here.\n";
      }
      foreach(thing in all_inventory(place)) {
         if (living(thing) && thing->query_visible(this_player()) &&
             (thing != this_player()))
            contents += ({ thing });
      }
      if (!sizeof(contents)) {
         return "You do not see anyone else about.\n";
      }
      return "$C$" + query_multiple_short(contents) +
         " $V$0=is,are$V$ here.\n";
   }
   for (i = 0; i < sizeof(locations) - 1; i++) {
      for (j = i + 1; j < sizeof(locations); j++) {
         if (locations[i][1] == locations[j][1]) {
            locations[i][0] += locations[j][0];
            locations = delete(locations, j, 1);
            j--;
         }
      }
   }
   parts = ({ });
   for (i = 0; i < sizeof(locations); i++) {
      parts += ({ query_multiple_short(locations[i][0]) + " " +
                  locations[i][1] });
   }
   if (sizeof(parts) == 1) {
      return "You can see " + parts[0] + ".\n";
   }
   return "You can see " + query_multiple_short(parts) + ".\n";
}
mixed *query_patterns()
{
   return ({ "", (: cmd_look_room() :),
             "<string'direction'>", (: cmd_string($4[0]) :),
             "<indirect:object>", (: cmd_object($1, $4[0]) :),
             "at <indirect:object>", (: cmd_object($1, $4[0]) :),
             "in <indirect:object>", (: cmd_object($1, $4[0]) :),
             "inside <indirect:object>", (: cmd_object($1, $4[0]) :),
             "around", (: cmd_string("around") :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/double_quote.c ===
#include "/cmds/living/lsay.c"

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/eq_uip.c ===
#define TP this_player()
inherit "/cmds/base";
int cmd() {
   int no_limbs;
   string stuff;
   object thing;
   object *equipped;
   object *things;
   equipped = ({ });
   things = all_inventory( TP ) - TP->query_wearing() -
            TP->query_holding();
   foreach ( thing in things ) {
      no_limbs = thing->query_no_limbs();
      if ( no_limbs > TP->query_free_limbs() ) {
         continue;
      }
      if ( thing->query_wearable() ) {
         if ( !TP->wear_armour( thing, 0 ) ) {
            equipped += ({ thing });
         }
         continue;
      }
      if (thing->query_weapon() && no_limbs) {
         if ( sizeof( TP->set_hold( thing,
               member_array( 0, TP->query_holding() ) ) ) ) {
            equipped += ({ thing });
         }
      }
   }
   if ( !sizeof( equipped ) ) {
      return notify_fail( "You have no equippable items.\n" );
   }
   stuff = query_multiple_short( equipped );
   say( (string)TP->one_short() +" equips "+ stuff +".\n" );
   write( "You equip "+ stuff +".\n" );
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/sp_eak.c ===
inherit "/cmds/base";
#include <language.h>
#define TP this_player()
int cmd(string which)
{
   string *langs;
   string skill;
   int i;
   mapping skills;
   skills = TP->query_skills();
   if (!which) {
      langs = LANGUAGE_HAND->query_languages();
      for (i = 0; i < sizeof(langs); i++) {
         if (TP->
             query_skill(LANGUAGE_HAND->
                         query_language_spoken_skill(langs[i])) > 1
             || TP->query_skill(LANGUAGE_HAND->
                                query_language_written_skill(langs[i])) > 1) {
         } else {
            langs = langs[0..i - 1] + langs[i + 1..];
            i--;
         }
      }
      write("You are currently speaking " +
            cap_words(TP->query_current_language()) + " and your default "
            "language is " + cap_words(TP->query_default_language()) + ".\n");
      write("You can speak " +
            query_multiple_short(map(langs, (: cap_words :)) +
                                 ({ "Grunt" })) + ".\n");
      write("Please note that the language you are speaking is used for "
            "writing as well, so some of the languages may be just written.\n");
      return 1;
   }
   which = lower_case(which);
   skill = LANGUAGE_HAND->query_language_spoken_skill(which);
   if (!skill) {
      return notify_fail("You cannot speak that language.\n");
   }
   if((!TP->query_skill(skill) && which != "grunt" && which != "general") ||
      (which == "general" && !TP->query_creator() && interactive(TP)))
      return notify_fail("You don't know that language.\n");
   if (which == this_player()->query_current_language()) {
      add_failed_mess("You are already speaking " + cap_words(which) + ".\n");
      return 0;
   }
   if (!TP->set_language(which)) {
      return notify_fail("Argh... something weird happened.\n");
   }
   write("Now using " + cap_words(which) + " for speaking and writing.\n");
   return 1;
}
mixed *query_patterns()
{
   string *languages;
   string tmp;
   languages = LANGUAGE_HAND->query_languages();
   if ( TP->query_womens_day() ) {
       languages += ({ "wommon" });
   }
   tmp = implode(languages + map(languages, (: cap_words :)), "|");
   return ({ "{" + tmp + "}", (: cmd(implode($4, " ")) :),
             "", (: cmd(0) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/facing.c ===
#include <dirs.h>
inherit "/cmds/base";
string find_direction( object who );
int check_reference_point( object where );
int cmd( object *indirect_obs ) {
    mapping details;
    object *oblist;
    string *show, dir;
    if ( !check_reference_point( environment( this_player() ) ) ) {
        add_failed_mess( "You can't make out a point of reference "
            "to use to determine which way you're facing!\n" );
        return 0;
    }
    if ( !indirect_obs || sizeof( indirect_obs ) == 1 &&
        indirect_obs[ 0 ] == this_player()) {
        tell_object( this_player(), "You are facing " +
            find_direction( this_player() ) + ".\n" );
        return 1;
    }
    indirect_obs -= ({ this_player() });
    details = unique_mapping( indirect_obs,
        (: find_direction( $1 ) :) );
    show = ({ });
    foreach(dir, oblist in details)  {
      if (sizeof(oblist) > 1)  {
        show += ({ query_multiple_short(oblist) + " are facing " + dir });
      }
      else  {
        show += ({ oblist[0]->one_short() + " is facing " + dir });
      }
    }
    write(query_multiple_short(show) + ".\n");
    return 1;
}
string find_direction( object who ) {
    int facing;
    mapping directions;
    facing = who->query_facing()[ 0 ];
    directions = filter( ABS_FACING, (: $2 == $(facing) :) );
    if ( !sizeof( directions ) )
        return "north";
    return keys( directions )[ 0 ];
}
int check_reference_point( object where ) {
    string *relatives;
    relatives = map( where->query_direc(),
        (: $(where)->query_relative( $1 ) :) );
    return member_array( 0, relatives ) > -1;
}
mixed *query_patterns() {
    return ({ "", (: cmd( 0 ) :),
        "<indirect:living:here>", (: cmd($1) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/lie.c ===
inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("lie", "down", LYING);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/sit.c ===
inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   if(this_player()->query_position() == "lying")
     setup_position("sit", "up", SITTING);
   else
     setup_position("sit", "down", SITTING);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/get.c ===
#include <obj_parser.h>
#include <move_failures.h>
#include <player.h>
#define DROP_H 40
#define PINCH_H 120
#define MAX_GET_NUMBER 20
inherit "/cmds/base";
#define TP this_player()
object* find_matching_obs(string match_str, object dob) {
   class obj_match result;
   result = (class obj_match)match_objects_in_environments(match_str, dob);
   if (result->result != OBJ_PARSER_SUCCESS) {
      add_failed_mess(match_objects_failed_mess(result));
      return 0;
   }
   return result->objects;
}
mixed cmd(object * obs, string dir, string indir, mixed *args) {
   object *dest;
   object ob;
   object dob;
   object *fail_dest;
   object *too_many;
   mixed *fail;
   mixed *ret;
   mixed amt;
   string sh;
   string hand_unit;
   string match_str;
   int i;
   int num;
   int cap;
   int perc;
   int handful;
   int total_num;
   mixed we;
   object env;
   object *bing;
   fail_dest = ({ });
   cap = (int) TP->query_max_weight();
   if (indir && sizeof(obs) > 10) {
      add_failed_mess("Please be more specific as to what you want "
                      "to get from.\n");
      return 0;
   }
   if (indir) {
      match_str = args[0];
      dest = obs;
   } else {
      if (environment(TP)->query_mirror_room()) {
         dest = ({ environment(TP), environment(TP)->query_mirror_room() });
      } else {
         dest = ({ environment(TP) });
      }
   }
   too_many = ({ });
   foreach(dob in dest) {
     if (!is_in_me_or_environment(dob, this_player())) {
         fail_dest += ({ dob });
         continue;
      }
      if (dob->cannot_get_stuff() || dob->query_closed()) {
         fail_dest += ({ dob });
         continue;
      }
      if (living(dob) && !dob->allowed_to_loot(this_player())) {
        fail_dest += ({ dob });
        continue;
      } else if (indir) {
         obs = find_matching_obs(match_str, dob);
      }
      if (!obs) {
         continue;
      }
      if (total_num + sizeof(obs) > MAX_GET_NUMBER) {
         if (total_num > MAX_GET_NUMBER) {
            too_many += obs;
            obs = ({ });
         } else {
            too_many += obs[MAX_GET_NUMBER - total_num..];
            obs = obs[0..MAX_GET_NUMBER - total_num - 1];
         }
      }
      total_num += sizeof(obs);
      ret = ({ ([ ]), ([ ]), ([ ]), ([ ]), ([ ]), });
      fail = ({ });
      foreach(ob in obs) {
        env = environment(ob);
        if(env != dob) {
          if(ob->query_collective())
            ob->move(dob);
          else
            dob = env;
        }
        if ((living(dob) && !dob->allowed_to_loot(this_player(), ob)) ||
            (ob->query_liquid() && ob->query_food_object())) {
          fail += ({ ob });
          num++;
          continue;
        }
         if (ob->query_continuous()) {
            amt = ob->query_amount_types();
            if (amt["handful"]) {
               hand_unit = "handful";
               handful = amt["handful"][0];
            } else if ((amt["drop"]) && (ob->query_liquid())) {
               hand_unit = "drops";
               handful = amt["drop"][0] * DROP_H;
            } else if (amt["pinch"]) {
               hand_unit = "pinches";
               handful = amt["pinch"][0] * PINCH_H;
            } else {
               handful = ob->query_amount();
            }
            if (ob->query_amount() > handful) {
               if (!match_str) {
                  match_str = ob->query_name();
               }
               if (i = strsrch(match_str, "of") >= 0) {
                  i += 3;
               }
               if (hand_unit == "handful") {
                  handful = 1;
               }
               match_str = handful + " " + hand_unit + " of " +
                  match_str[i..];
               fail += ({ "all of the " + ob->short() });
               ob = ob->query_parse_id(({ handful, match_str }));
               if (!ob) {
                  continue;
               }
               num++;
            }
         }
         if (function_exists("do_get", ob) ||
             function_exists("command_control", ob)) {
            if (function_exists("do_get", ob)) {
               we = (int) call_other(ob, "do_get", dob, 0, match_str,
                                     ({ 0, match_str }),
                                     "<direct:object> from <indirect:object>");
            } else {
               we = ob->command_control("get", dob, 0, match_str,
                                        ({ 0, match_str }),
                                        "<direct:object> from <indirect:object>");
            }
            if (!objectp(we)) {
               if (we) {
                  we = (int) ob->query_weight();
                  perc = (we * 100) / cap;
                  if (perc >= 95) {
                     i = 4;
                  } else {
                     i = perc / 25;
                  }
                  if (!ret[i][env]) {
                     ret[i][env] = ({ ob });
                  } else {
                     ret[i][env] += ({ ob });
                  }
               } else {
                  if (member_array(ob, this_player()->query_succ_mess_indir())
                      == -1 && !query_notify_fail() && !living(ob)) {
                     fail += ({ ob });
                  }
                  num++;
               }
               continue;
            } else {
               ob = we;
            }
         }
#ifndef __DISTRIBUTION_LIB__
         if(interactive(TP) &&
            PLAYER_MULTIPLAYER_HANDLER->check_multiplayers("get", TP, ob)) {
           fail += ({ ob });
           num++;
         } else
#endif
         if ((int) ob->move(TP) == MOVE_OK) {
            we = (int) ob->query_weight();
            perc = (we * 100) / cap;
            if (perc >= 95) {
               i = 4;
            } else {
               i = perc / 25;
            }
            if (!ret[i][env]) {
               ret[i][env] = ({ ob });
            } else {
               ret[i][env] += ({ ob });
            }
         } else {
            fail += ({ ob });
            num++;
         }
      }
      for (i = 0; i < sizeof(ret); i++) {
         if (sizeof(ret[i])) {
            foreach(env, bing in ret[i]) {
               if (this_player()->query_succ_mess_dir()) {
                  bing -= this_player()->query_succ_mess_dir();
               }
               if (sizeof(bing)) {
                  sh = query_multiple_short(bing);
                  write("You " + ({ "get", "get with a bit of difficulty",
                                    "struggle somewhat to get",
                                    "find it very difficult to get",
                                    "use all your strength and just barely manage to get" })
                        [i] + " " + sh + " from " + inside_the_short(dob) +
                        ".\n");
                  say(capitalize((string) TP->one_short()) + " " +
                      ({ "gets", "gets with a bit of difficulty",
                         "struggles somewhat to get",
                         "finds it very difficult to get",
                         "uses all " + TP->query_possessive() +
                         " strength and just barely manages to get" })[i] +
                      " " + sh + " from " + inside_a_short(dob) + ".\n");
               }
            }
         }
      }
      if (sizeof(fail)) {
         add_failed_mess("You cannot get $I.\n", fail);
      }
   }
   if (num == total_num) {
      if (query_notify_fail()) {
         return 0;
      }
      if (indir) {
         if (sizeof(fail_dest)) {
            add_failed_mess("You cannot get anything from $I.\n", fail_dest);
         }
      } else {
         add_failed_mess("You cannot get $I.\n", obs);
      }
      return -1;
   } else {
      if (sizeof(too_many)) {
         add_succeeded_mess(({ "You cannot pick up more than " +
                               query_num(MAX_GET_NUMBER) +
                               " objects at a time; " "discarding $I.\n",
                               "" }), too_many);
      }
   }
   return 1;
}
mixed *
query_patterns()
{
   return ({ "<indirect:object:here>", (: cmd($1, 0, 0, 0) :),
             "<string> from <indirect:object>", (: cmd($1, $2, $3, $4) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/em_ote.c ===
#include <library.h>
#include <player.h>
inherit "/cmds/base";
mixed cmd( string words ) {
  string pad = " ";
  if(!environment(this_player())) {
    return notify_fail("You are in limbo, you cannot emote.\n");
  }
  if ( userp( this_player() ) && !this_player()->query_creator() ) {
    if ( this_player()->query_property( "emote" ) ) {
      LIBRARY->set_quest( (string)this_player()->query_name(), "emote" );
      this_player()->remove_property( "emote" );
    }
    if ( !LIBRARY->query_quest_done( (string)this_player()->query_name(),
                                     "emote" ) ) {
      return notify_fail( NOT_ALLOWED );
    }
    if(this_player()->query_property("no emote")) {
      return notify_fail(NOT_ALLOWED);
    }
    if ( (int)this_player()->adjust_sp( -EMOTE_COST ) < 0 ) {
      return notify_fail( NO_POWER );
    }
  }
  if ( !words || ( words == "" ) ) {
    return notify_fail( "Syntax: emote <text>\n" );
  }
  words = strip_colours(words);
  words = replace(words, ({"        ", " ",
                           "       ", " ",
                           "      ", " ",
                           "     ", " ",
                           "    ", " ",
                           "   ", " ",
                            }) );
  this_player()->adjust_time_left( -5 );
  if (words[0..0] == "'") pad = "";
  environment( this_player() )->event_emote( this_player(),
                                             "$C$" + this_player()->one_short() + pad +
                                             words +"\n" );
  all_inventory( environment( this_player() ) )->
    event_emote( this_player(), "$C$" + this_player()->one_short() +
                                pad + words + "%^RESET%^\n" );
  write( "You emote: $C$"+
         (string)this_player()->pretty_short( this_player() ) + pad + words +
         "%^RESET%^\n" );
  return 1;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/protect.c ===
inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *things) {
  int i;
  object *protectees;
  things -= ({ TP });
  if ( !sizeof( things ) ) {
     add_failed_mess("You cannot protect yourself!\n");
     return 0;
  }
  if ( TP->query_property( "dead" ) ) {
    add_failed_mess("You cannot provide much protection as a ghost.\n" );
    return 0;
  }
  protectees = ({ });
  for ( i = 0; i < sizeof( things ); i++ ) {
    if ( things[ i ]->add_protector( TP ) ) {
      protectees += ({ things[ i ] });
      things = delete( things, i, 1 );
      i--;
    }
  }
  if ( !sizeof( protectees ) ) {
    add_failed_mess("You cannot protect $I.\n", things);
    return 0;
  }
  if ( sizeof( things ) ) {
    write( "You cannot protect "+ query_multiple_short( things ) +".\n" );
  }
  add_succeeded_mess(({ "You will protect $I.\n",
                        "$N moves to protect $I.\n" }),
	                protectees);
  return 1;
}
int show_protectors() {
   object *protect;
   object womble;
   protect = this_player()->query_protectors();
   if (sizeof(protect)) {
      write("You are being protected by " + query_multiple_short(protect) +
            ".\n");
   } else {
      write("You are not being protected by anyone.\n");
   }
   protect = ({ });
   foreach (womble in all_inventory(environment(this_player()))) {
      if (living(womble) && womble != this_player()) {
         if (member_array(this_player(), womble->query_protectors()) != -1) {
            protect += ({ womble });
         }
      }
   }
   if (sizeof(protect)) {
      write("Of the people in this room, you are protecting " +
            query_multiple_short(protect) + ".\n");
   } else {
      write("You are not protecting anyone in this room.\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:living>",
             (: cmd($1) :),
             "",
             (: show_protectors() :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/watch.c ===
#define COST 50
inherit "/cmds/base";
mixed cmd() {
   if ( this_player()->query_blinded() ) {
      add_failed_mess( "How can you watch anything?  You're blind.\n" );
      return 0;
   }
   if (this_player()->query_property("dead")) {
      add_failed_mess( "Dead people don't watch. It is rude!\n");
      return 0;
   }
   if ( sizeof( (int *)this_player()->effects_matching( "mind.alertness" ) ) ) {
      add_failed_mess( "You are already alert and watching "
        "your surroundings.\n" );
      return 0;
   }
   if ( this_player()->query_specific_gp( "other" ) < COST ) {
      add_failed_mess( "You can't concentrate enough to watch "
        "your surroundings.\n" );
      return 0;
   }
   this_player()->adjust_gp( -COST );
   this_player()->add_effect( "/std/effects/other/alertness", 60 +
     (int)this_player()->query_skill_bonus( "other.perception" ) / 2 );
   return 1;
}
int stop_watching() {
   int *enums, id;
   enums = this_player()->effects_matching( "mind.alertness" );
   if ( sizeof( enums ) ) {
      foreach( id in enums ) {
         this_player()->delete_effect( id );
      }
   }
   else {
      add_succeeded_mess( ({ "You are not currently watching!\n", "" }) );
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "stop", (: stop_watching() :),
     "", (: cmd() :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/put.c ===
#include <move_failures.h>
#include <player.h>
#define MAX_PUT_NUMBER 20
inherit "cmds/base";
#define TP this_player()
string con;
mixed cmd(mixed *indir,
          string *indir_match,
          string *args)
{
   string person;
   string thing;
   string sh;
   int tot;
   int max;
   object *per;
   object *ret;
   object *fail;
   object pobj;
   object ob;
   object *obs;
   object *succ;
   object *too_many;
   int num;
   con = args[1];
   per = indir[1];
   thing = indir_match[0];
   person = indir_match[1];
   succ = ({ });
   too_many = ({ });
   foreach(pobj in per) {
      if (living(pobj) && !pobj->query_living_container()) {
         tell_object(TP,
                     "You cannot put things " + con + " living things.\n");
         continue;
      }
      obs = indir[0];
      obs -= per;
      if (!sizeof(obs)) {
         tell_object(TP, "Nothing to " + query_verb() + " " + con + " " +
                     inside_the_short(pobj) + ".\n");
         continue;
      }
      if (!is_in_me_or_environment(pobj, this_player())) {
         add_failed_mess("Cannot $V $I " + con + " " + pobj->the_short() +
                         ".\n", obs);
         continue;
      }
      ret = ({ });
      fail = ({ });
      foreach(ob in obs) {
         if (member_array(ob, succ) > -1) {
            continue;
         }
         if (num > MAX_PUT_NUMBER) {
            too_many += ({ ob });
            continue;
         }
         if (function_exists("do_put", ob) ||
             function_exists("command_control", ob)) {
            if (function_exists("do_put", ob)) {
               max = (int) call_other(ob, "do_put", pobj, thing, person,
                                      ({ thing, person }),
                                      "<direct:object> " + con +
                                      " <indirect:object>");
            } else {
               max = ob->command_control("put", pobj, thing, person,
                                         ({ thing, person }),
                                         "<indirect:object> " +
                                         con + " <indirect:object>");
            }
            if (max == 0) {
               fail += ({ ob });
               continue;
            }
         }
         if (pobj->query_closed() || ob->move(pobj) != MOVE_OK) {
            fail += ({ ob });
         } else {
            ret += ({ ob });
            tot += (int) ob->query_weight();
#ifndef __DISTRUBUTION_LIB__
            if(interactive(TP))
              PLAYER_MULTIPLAYER_HANDLER->record_object("dropped", TP, ob);
#endif
            num++;
         }
      }
      if (sizeof(ret)) {
         succ += ret;
         sh = query_multiple_short(ret);
         add_succeeded_mess("$N $V $I " + con + " " +
                            inside_the_short(pobj) + ".\n", ret);
      }
      if (sizeof(fail)) {
         add_failed_mess("You cannot $V $I " + con + " " +
                         inside_the_short(pobj) + ".\n", fail);
      }
   }
   if (sizeof(too_many)) {
      if (sizeof(succ) > 0) {
         add_succeeded_mess(({ "You cannot handle more than " +
                               query_num(MAX_PUT_NUMBER) +
                               " objects with $V; discarding $I.\n", "" }),
                            too_many);
      } else {
         add_failed_mess("You cannot handle more than " +
                         query_num(MAX_PUT_NUMBER) +
                         " objects with $V; discarding $I.\n", too_many);
      }
   }
   return sizeof(succ) > 0;
}
string query_con() {
  return con;
}
mixed *query_patterns()
{
   return ({ "<indirect:object:me> {in|on|into} <indirect:object>",
             (: cmd($1, $3, $4) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/defend.c ===
inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *things) {
  int i;
  object *defendees;
  things -= ({ TP });
  if ( TP->query_property( "dead" ) ) {
    add_failed_mess("You cannot provide much defense as a ghost.\n" );
    return 0;
  }
  if ( !sizeof( things ) ) {
     add_failed_mess("You cannot defend yourself!\n");
     return 0;
  }
  if(TP->query_combat_response() != "parry") {
    add_failed_mess("Dodging out of the way will not help " +
                    query_multiple_short(things) + ".\n");
    return 0;
  }
  defendees = ({ });
  for ( i = 0; i < sizeof( things ); i++ ) {
    if ( things[ i ]->add_defender( TP ) ) {
      defendees += ({ things[ i ] });
      things = delete( things, i, 1 );
      i--;
    }
  }
  if ( !sizeof( defendees ) ) {
    add_failed_mess("You cannot defend $I.\n", things);
    return 0;
  }
  if ( sizeof( things ) ) {
    write( "You cannot defend "+ query_multiple_short( things ) +".\n" );
  }
  add_succeeded_mess(({ "You will defend $I.\n",
                        "$N moves to defend $I.\n" }),
                  defendees);
  return 1;
}
int show_defenders() {
   object *defend;
   object womble;
   defend = this_player()->query_defenders();
   if (sizeof(defend)) {
      write("You are being defended by " + query_multiple_short(defend) +
            ".\n");
   } else {
      write("You are not being defended by anyone.\n");
   }
   defend = ({ });
   foreach (womble in all_inventory(environment(this_player()))) {
      if (living(womble) && womble != this_player()) {
         if (member_array(this_player(), womble->query_defenders()) != -1) {
            defend += ({ womble });
         }
      }
   }
   if (sizeof(defend)) {
      write("Of the people in this room, you are defending " +
            query_multiple_short(defend) + ".\n");
   } else {
      write("You are not defending anyone in this room.\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:living>",
             (: cmd($1) :),
             "",
             (: show_defenders() :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/sh_out.c ===
#include <player.h>
#include <drinks.h>
#include <language.h>
#include <cmds/options.h>
#include "/d/am/path.h"
inherit "/cmds/base";
inherit "/cmds/speech";
#define TP this_player()
#define BEEP sprintf("%c",7)
#define NO_QUIT_INVENTORY 1
#define NO_QUIT_COMBAT    2
#define BROADCASTER "/obj/handlers/broadcaster"
int query_no_quit();
string query_shout_word_type(string str);
void my_mess(string fish, string erk);
mixed cmd(string str) {
  string s1, s2, s;
  object g;
  string cur_lang;
  object lag;
  int tim, cost;
  if(!str || str == "")
    return notify_fail("Syntax : shout <text>\n");
  if (!environment(this_player()))
    return notify_fail( "You appear to be in limbo...\n" );
  if(TP->query_property("dead") == 1)
    return notify_fail("You don't have any lungs, how can you shout?\n");
  if (TP->check_earmuffs("shout"))
    return notify_fail("Why shout when you can't hear people "
                       "shout back?\n");
  cur_lang = TP->query_current_language();
  if (!LANGUAGE_HAND->query_language_spoken(cur_lang))
    return notify_fail(capitalize(cur_lang)+" is not a spoken language.\n");
  if (!LANGUAGE_HAND->query_language_distance(cur_lang))
    return notify_fail(capitalize(cur_lang)+" is not able to spoken "
                       "at a distance.\n");
  if (TP->query_invis())
    return notify_fail("Invisible people cannot shout, they cannot "
                       "see their arm in front of their face.  Shouting is "
                       "out of the question.\n");
  if (TP->query_property("gagged"))
    return notify_fail("You have been gagged!  You will not be able "
                       "to shout again until the gag is removed.  Perhaps "
                       "you should talk to a creator about this.\n");
  if (TP->query_property("recently shouted")) {
    return notify_fail("You have shouted very recently, perhaps you "
                       "should give your lungs a small break and try again "
                       "in a couple seconds.\n");
  }
  if(TP->query_property("player") == 1 && !TP->query_creator()) {
    cost = SHOUT_COST * ((strlen(str) / 5) + 1);
    cost += sizeof(filter(explode(str, ""), (: $1 <= "Z" :))) / 2;
    if(TP->adjust_sp(-cost) < 0)
      return notify_fail(NO_POWER);
    TP->adjust_max_sp(- (cost / 5));
  }
  if (!interactive(TP)) {
    str = TP->convert_message( str );
    str = TP->fit_message( str );
  }
  s1 = query_shout_word_type(str);
  if (s1 != "yell")
    s = "shouts" + s1;
  else
    s = s1 + "s";
  if(TP->query_property(SHORTHAND_PROP))
    str = fix_shorthand(str);
  if(TP->query_volume( D_ALCOHOL))
    str = drunk_speech( str );
  TP->remove_hide_invis("hiding");
  if (s1 != "yell") {
    if (cur_lang != "common") s1 += " in " + capitalize(cur_lang);
    my_mess("You shout" + s1 + ": ", str);
  } else {
    if (cur_lang != "common") s1 += " in " + capitalize(cur_lang);
    my_mess("You " + s1 + ": ", str);
  }
  s2 =  " " + lower_case(str);
  if (sscanf(" "+s2, "%s eight%s", s1, s1)==2 ||
      sscanf(s2, "%s8%s", s1, s1)==2) {
    s1 = replace(str, ({ "8", "", " eight", "", " ", "" }));
    switch (query_no_quit()) {
    case NO_QUIT_INVENTORY:
      return notify_fail("You only just arrived.  You are far too "
                         "busy strapping on equipment to shout like that.\n");
    case NO_QUIT_COMBAT:
      return notify_fail("You are too busy fighting to shout "
                         "like that.\n");
    default:
      if (s1 == "") {
        write("Oops...\n");
        call_out( "summon_bel_shamharoth", 10, TP );
      }
      else {
        g = (object)TP->query_guild_ob();
        if (random(100) < 40 ||
            (g && (string)g->query_name() == "wizards"))
          write("Oops...\n");
        call_out( "summon_bel_shamharoth", 10, TP );
      }
    }
  }
  lag = load_object(SHORT + "short20")->lag_for_shout();
  if(lag && sscanf(" "+lower_case(s2), "%*s lag%*s") == 2) {
    tim = TP->query_property("lag shout time");
    TP->add_property("lag shout time", time(), 300);
    if((tim + 300 > time()) && lag != TP) {
      switch (query_no_quit()) {
      case NO_QUIT_INVENTORY:
        lag->init_command("hug "+ TP->query_name() +
                          " Welcome to " + mud_name() + "", 0);
        return notify_fail("The air is suddenly squeezed out "
                           "of you.\n");
      case NO_QUIT_COMBAT:
        lag->init_command("wedgie " + TP->query_name(), 0);
        return notify_fail("You are rudely interrupted "
                           "mid-shout.  Fortunately you are not distracted "
                           "from the fight.\n");
      default:
        call_out( "summon_bel_shamharoth", 10, TP, 1);
      }
    }
  }
  if(environment(this_player()) &&
     environment(this_player())->query_property("location") == "inside")
    tim = 10;
  else
    tim = 3;
  user_event( this_player(), "person_shout",
              (string)this_player()->a_short() +" "+ s,
              str, cur_lang,
              (int *)environment( this_player() )->query_co_ord(),
              ( 100 * ( (int)this_player()->query_con() +
                        (int)this_player()->query_str() ) ) / tim );
  environment(TP)->event_person_shout( 0, (string)TP->a_short() +" "+ s,
                                       str + "%^RESET%^", cur_lang );
  BROADCASTER->npc_shout_event(TP, (string)TP->a_short() +" "+ s,
                               str + "%^RESET%^", cur_lang,
                               (int *)environment(TP)->query_co_ord(),
                               (100 * ((int)TP->query_con() +
                                       (int)TP->query_str() ) ) / 3);
  if (TP->query_property("player") == 1 && !TP->query_creator()) {
    TP->add_property("recently shouted", 1, 2);
  }
  return 1;
}
string query_shout_word_type(string str) {
  switch (str[<1]) {
  case '!':
    return "yell";
  case '?':
    return " asking";
  default:
    return "";
  }
}
void my_mess(string fish, string erk) {
  if(!interactive(TP))
    return;
  printf("%s%-=*s\n", fish, TP->query_cols() - strlen(fish),
         TP->fix_string(erk));
}
void summon_bel_shamharoth(object who, int lag_shout) {
  object env;
  if (!who || !objectp(who))
    return;
  if (!random(3))
    who->adjust_tmp_con(-2);
  if (!random(3))
    who->adjust_tmp_int(-2);
  if (!random(3))
    who->adjust_tmp_wis(-2);
  if (!random(3))
    who->adjust_tmp_dex(-2);
  env = environment(who);
  if ("/secure/master"->query_lord(geteuid(who))) {
    BROADCASTER->broadcast_event(users(),
                                 (int *)env->query_co_ord(),
                 "The heavens shake with a hideous roar and just as suddenly "
                 "all is quiet.\n$C$"+ who->query_name() + " chuckles in the "
                 "distance.\n",
                                 ( 100 * ( (int)who->query_con() +
                                           (int)who->query_str() ) ) / 3,
                                 1, 0);
    tell_object(who, "Your lordliness saves you from a grizzly "
                "encounter with the Sender of Eight.\n");
  } else {
    BROADCASTER->broadcast_event(users(),
                                 (int *)env->query_co_ord(),
                             "a sudden chill passes through the land as $C$" +
                           who->query_name() + " is carried off screaming "
                           "to the land of shades.\n",
                                 ( 100 * ( (int)who->query_con() +
                                           (int)who->query_str() ) ) / 3,
                                 1, 0);
    tell_object( who, "You think you'd best be careful what you "
                 "shout in the future as shadowy tentacles drag you "
                 "into the ground...\n" );
    if(lag_shout)
      BROADCASTER->broadcast_event(users(),
                                   (int *)env->query_co_ord(),
                                   ( 100 * ( (int)who->query_con() +
                  "The heavens shake with a hideous chuckle and in the "
                  "distance a booming yet apologetic voice says: Oops.\n",
                                             (int)who->query_str() ) ) / 3,
                                   1, 0);
    if(base_name(env) != "/room/departures")
      who->quit();
  }
}
int query_no_quit() {
  if (TP->query_save_inhibit() || TP->query_auto_loading()) {
    return NO_QUIT_INVENTORY;
  }
  if (sizeof(filter_array(TP->query_attacker_list(), (: living($1) :)))) {
    return NO_QUIT_COMBAT;
  }
  return 0;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/und_efend.c ===
inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *things) {
  object *defendees;
  object ob;
  object *fail;
  if(!things) {
    things = ({ });
  }
  things -= ({ TP });
  if ( !sizeof( things ) ) {
    add_failed_mess("You cannot undefend yourself!\n");
    return 0;
  }
  defendees = ({ });
  fail = ({ });
  foreach ( ob in things) {
    if ( ob->remove_defender( TP ) ) {
      defendees += ({ ob });
    } else  {
       fail += ({ ob });
    }
  }
  if ( sizeof( fail ) ) {
    add_failed_mess( "You are not defending " + query_multiple_short( fail ) +
                     ".\n" );
  }
  if (sizeof(defendees)) {
     add_succeeded_mess("$N stop$s defending $I.\n", defendees);
     return 1;
  } else {
     return 0;
  }
}
mixed *query_patterns() {
   return ({ "<indirect:living>", (: cmd($1) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/crawl.c ===
#define EFFECTPATH "/std/effects/other/"
#define PT "/obj/handlers/playtesters"
inherit "/cmds/base";
int is_in_water( object room );
varargs int cmd( string str ) {
   if( str == "stop" ) {
      if( !this_player()->query_crawling() ) {
         this_player()->add_failed_mess( this_object(),
                                         "You should be crawling first in order"
                                         " to stop doing it, don't you "
                                         "think?\n",
                                         ({ }) );
         return 0;
      };
      this_player()->stop_crawling();
      return 1;
   };
   if( !str ) {
      if( this_player()->query_property( "dead" ) ) {
         this_player()->add_failed_mess( this_object(),
                                         "You appear to be dead.  There is no "
                                         "necessity to torture your morphogenic"
                                         " arms, you know?\n",
                                         ({ }) );
         return 0;
      } else if( this_player()->query_crawling() ) {
         this_player()->add_failed_mess( this_object(),
                                         "You are already crawling.\n",
                                         ({ }) );
         return 0;
      } else if( is_in_water( environment( this_player() ) ) ) {
         this_player()->add_failed_mess( this_object(),
                                         "You are in water at the moment, so "
                                         "crawling is impossible.\n",
                                         ({ }) );
         return 0;
      } else {
         this_player()->add_effect( EFFECTPATH + "crawling" );
         return 1;
      };
   };
}
mixed* query_patterns() {
   return ({
      "", (: cmd() :),
      "stop", (: cmd( "stop" ) :)
   });
}
int is_in_water( object room ) {
   if( inherits( "/std/water_inside.c", room ) ||
       inherits("/std/water_outside.c", room ) ||
       inherits("/std/uwater.c", room ) ) {
      return 1;
   } else
      return 0;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/unf_ollow.c ===
inherit "/cmds/base";
#define TP this_player()
int cmd(object *obs) {
   mapping hide_invis;
   int hiding, sneaking;
  object *ok, ob;
  string s;
  ok = ({ });
  foreach (ob in obs) {
    if (ob->remove_follower(TP)) {
      ok += ({ ob });
    }
  }
  if (!sizeof(ok)) {
    if (member_array(TP, obs) == -1) {
      return notify_fail("You are not following "+query_multiple_short(obs)+
                         ".\n");
    } else {
      return notify_fail("You are not following " +
        query_multiple_short(obs - ({ TP }) + ({ "yourself" })) + ".\n");
    }
  }
  hide_invis = ( mapping )this_player()->query_hide_invis();
  hiding = hide_invis[ "hiding" ] ? 1 : 0;
  sneaking = this_player()->query_sneak_level() ? 1 : 0;
  if( hiding || sneaking )
   write("You stop following "+(s=query_multiple_short(ok))+" unseen.\n");
  else {
    write("You stop following "+(s=query_multiple_short(ok))+".\n");
    say(TP->the_short()+" stops following "+s+".\n", ok);
    foreach (ob in ok) {
      tell_object(ob, TP->the_short() +
                  " stops following "+query_multiple_short((ok + ({"you"})) -
                                                           ({ ob }))+".\n");
    }
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:living>", (: cmd($1) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/remove.c ===
#include <clothing.h>
#include <tasks.h>
#define SKILL "covert.manipulation.sleight-of-hand"
#ifdef DEBUG
#define TELL_ME "presto"
#endif
inherit "cmds/base";
int cmd(object *things)  {
   object  *removed = ({ });
   object  *blocking = ({ });
   object  *blocked;
   object  *total_blocking = ({ });
   object  *succeeded;
   object  *failed;
   object  *failed_rewear;
   object   ob;
   object   blocker;
   mapping  is_blocking = ([ ]);
   mapping  hide_invis;
   string   tmp1;
   string   tmp2;
   int      last_blocking;
   int      limit;
   int      i;
   int      hiding;
   int      sneaking;
   int      difficulty;
   int      light;
   int      my_light;
   succeeded = this_player()->query_wearing();
   failed = filter(things, (: member_array($1, $(succeeded)) == -1 :));
   things -= failed;
   if (sizeof(things) == 0)  {
      write("You are not wearing " + query_multiple_short(failed, "the") +
            ".\n");
      return 1;
   }
   succeeded = things;
   for (i = 0; i < sizeof(succeeded); i++)  {
      ob = succeeded[i];
      blocking = CLOTHING_HANDLER->query_items_blocking(ob, this_player()) -
                 ({ ob });
      if (sizeof(blocking))  {
         foreach (blocker in blocking)  {
            if (undefinedp(is_blocking[blocker]))
               is_blocking[blocker] = ({ ob });
            else
               is_blocking[blocker] |= ({ ob });
         }
         total_blocking |= blocking;
         succeeded = ({ things..., total_blocking... });
      }
   }
   total_blocking = ({ });
   foreach (ob, blocked in is_blocking)  {
#ifdef DEBUG
      if (this_player() == find_player(TELL_ME))
      tell_creator(TELL_ME, "ob == %s, blocked == %O\n",
                   ob->short(), blocked->short());
#endif
      last_blocking = -1;
      for (i = sizeof(total_blocking) - 1; i >= 0; i--)  {
         if (member_array(ob, is_blocking[total_blocking[i]]) > -1)  {
            last_blocking = i;
            break;
         }
      }
      if (last_blocking == -1)  {
         total_blocking = ({ ob, total_blocking... });
#ifdef DEBUG
         if (this_player() == find_player(TELL_ME))
            tell_creator(TELL_ME, "Nothing is blocking ob, adding it to "
                         "the beginning\n%O\n", total_blocking->short());
#endif
         continue;
      }
      total_blocking = ({ total_blocking[0 .. last_blocking]...,
                          ob,
                          total_blocking[(last_blocking + 1) .. ]... });
#ifdef DEBUG
      if (this_player() == find_player(TELL_ME))
         tell_creator(TELL_ME, "Adding ob after last_blocking position "
                      "(%d)\n%O\n",
                      last_blocking, total_blocking->short());
#endif
      limit = last_blocking;
      blocking = copy(blocked);
      for (i = 0; i < limit; i++)  {
         if (member_array(total_blocking[i], blocking) > -1)  {
            blocking += is_blocking[total_blocking[i]];
            if (i == 0)
               total_blocking =
                  ({ total_blocking[1 .. (last_blocking + 1)]...,
                     total_blocking[0],
                     total_blocking[(last_blocking + 2) .. ]... });
            else
               total_blocking =
                  ({ total_blocking[0 .. (i - 1)]...,
                     total_blocking[(i + 1) .. (last_blocking + 1)]...,
                     total_blocking[i],
                     total_blocking[(last_blocking + 2) .. ]... });
            --limit;
            --i;
#ifdef DEBUG
            if (this_player() == find_player(TELL_ME))
               tell_creator(TELL_ME, "Reordered list:\n%O\n",
                            total_blocking->short());
#endif
         }
      }
   }
   foreach (blocker in total_blocking)  {
      tmp1 = CLOTHING_HANDLER->can_wear_or_remove(blocker, this_player());
      if (tmp1)  {
         write("You cannot remove " +
               query_multiple_short(is_blocking[blocker], "the") +
               " " + tmp1 + ".\n");
         things -= is_blocking[blocker];
         break;
      }
      else if (this_player()->remove_armour(blocker))  {
         write("You cannot remove " +
               query_multiple_short(is_blocking[blocker], "the") +
               " because you cannot remove " + blocker->one_short() + ".\n");
         things -= is_blocking[blocker];
         break;
      }
      else removed += ({ blocker });
   }
   succeeded = things & removed;
   failed = ({ });
   foreach (ob in things - removed)  {
      if (this_player()->remove_armour(ob))
         failed += ({ ob });
      else
         succeeded += ({ ob });
   }
   if (sizeof(succeeded) > 0)  {
      removed -= things;
      tmp2 = query_multiple_short(succeeded, "the") ;
      if (sizeof(removed) > 0)  {
         tmp1 = query_multiple_short(removed, "the");
         write("You remove " + tmp1 + " so you can remove " + tmp2 + ".\n");
         say(this_player()->the_short() + " removes " + tmp1 + " so " +
             this_player()->query_pronoun() + " can remove " + tmp2 + ".\n");
      }
      else  {
        hide_invis = ( mapping )this_player()->query_hide_invis();
        hiding = hide_invis[ "hiding" ] ? 1 : 0;
        sneaking = this_player()->query_sneak_level() ? 1 : 0;
        if( hiding || sneaking ) {
          my_light = this_player()->query_light();
          light = environment( this_player() )->query_light();
          difficulty = light + ( 4 * my_light ) / ( light + 1 );
          difficulty += succeeded[0]->query_complete_weight();
          debug_printf( "Difficulty = %d.\n Skill = %s\n Bonus = %d\n",
                        difficulty, SKILL, this_player()->
                        query_skill_bonus( SKILL ) );
          switch( TASKER->perform_task( this_player(), SKILL, difficulty,
            TM_FREE ) ) {
            case AWARD :
              write( "%^YELLOW%^" + ({
                "You discover something that lets your fingers move more "
                  "nimbly.",
                "You find yourself capable of deceiving the eye with greater "
                  "ease than before.",
                "You realise how to deceive the eye more effectively."
              })[ random(3) ] + "%^RESET%^\n" );
            case SUCCEED :
              add_succeeded_mess( ({ "$N $V " + tmp2 + ", managing to stay "
                "unnoticed.\n",
                "" }) );
              break;
            default :
              this_player()->add_succeeded_mess( this_object(), "$N "
                "unsuccessfully tr$y to " + query_verb() + " " + tmp2 +
                " while staying unnoticed.\n", ({ }) );
              break;
          }
        } else {
          this_player()->add_succeeded_mess( this_object(), "$N $V " + tmp2 +
            ".\n", ({ }) );
        }
      }
   }
   succeeded = ({ });
   failed_rewear = ({ });
   foreach (ob in removed)  {
      if (this_player()->wear_armour(ob))
         failed_rewear += ({ ob });
      else
         succeeded += ({ ob });
   }
   if (sizeof(succeeded) > 0)  {
      this_player()->force_burden_recalculate();
      tmp1 = query_multiple_short(succeeded, "the");
      write("You wear " + tmp1 + ".\n");
      say(this_player()->the_short() + " wears " + tmp1 + ".\n");
   }
   if (sizeof(failed_rewear) > 0)  {
      write("You cannot put " +
            query_multiple_short(failed_rewear, "the") + " back on.\n");
   }
   if (sizeof(failed) > 0)  {
      write("You cannot remove " + query_multiple_short(failed, "the") +
            ".\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd($1) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/stand.c ===
inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("stand", "up", STANDING);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/fo_llow.c ===
inherit "/cmds/base";
#define TP this_player()
int cmd(object *obs) {
   object *ok, ob;
   object *already;
   string s;
   mapping hide_invis;
   int hiding, sneaking;
   ok = ({ });
   already = ({ });
   foreach (ob in obs) {
      if (member_array(TP, ob->query_followers()) == -1) {
         if (ob->add_follower(TP)) {
            ok += ({ ob });
         }
      } else {
         already += ({ ob });
      }
   }
   if (!sizeof(ok)) {
      if (sizeof(already)) {
         add_failed_mess("You are already following $I.\n", already);
      }
      obs -= already;
      if (sizeof(obs)) {
         if(member_array(TP, obs) == -1) {
            add_failed_mess("You cannot follow " + query_multiple_short(obs) +
                                          ".\n");
         } else {
            add_failed_mess("You can't follow " +
                          query_multiple_short(obs - ({TP}) + ({"yourself"})) +
                          ".\n");
         }
      }
      return 0;
   }
  hide_invis = ( mapping )this_player()->query_hide_invis();
  hiding = hide_invis[ "hiding" ] ? 1 : 0;
  sneaking = this_player()->query_sneak_level() ? 1 : 0;
  if( hiding || sneaking )
    write("You follow " + ( s = query_multiple_short( ok ) ) + " unseen.\n" );
  else {
   write("You follow "+(s=query_multiple_short(ok))+".\n");
   say(TP->one_short(1)+" follows "+s+".\n", ok);
   foreach (ob in ok)
      tell_object(ob, TP->one_short(1)+
                      " follows "+query_multiple_short((ok + ({"you"})) -
                      ({ ob }))+".\n");
  }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:living>", (: cmd($1) :) });
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/cmds/living/sayto.c ===
#include <language.h>
#include <player.h>
#include <drinks.h>
inherit "cmds/base";
inherit "/cmds/speech";
#define TP this_player()
mixed cmd(object *obs, string str) {
  class message mess;
  obs = filter(obs, (: $1 && $1 != this_player() :));
  if(!sizeof(obs)) {
    return notify_fail("Be serious.\n");
  }
  mess = build_message(str, obs, "say");
  return say_it_to(mess, obs, 0, "person_say");
}
mixed *query_patterns() {
   return ({ "<indirect:living> <string>", (: cmd($1, $4[1]) :) });
}
