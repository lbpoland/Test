# Generated from /mnt/home2/test/Test/dw_fluffos_v3/lib//merged_obj_std.c (2003 FluffOS v3) for Forgotten Realms MUD
# Date: 2025-03-12 12:51:30
from typing import Dict, List, Optional, Any
from .environment import weather_handler
from ..driver import MudObject, Player, driver
from .combat import combat_handler
from .utilities import CLOTHING_HANDLER
import asyncio
from ..driver import MudObject, Player, driver
import asyncio

    def __init__(self):
            self.ac = ([ ])
            self.armour_types = []


    def add_ac(self, name: str, type: str, a_c: Any) -> int:
            int i
            if (!stringp(type))
            return 0
            if (!ac) ac = ([ ])
            if (ac[name])
            return 0
            ac[name] = [a_c, type]
            if ((i=armour_types.index(type) if type in armour_types else -1) == -1)
            armour_types += [type, [name]]
            else
            armour_types[i+1] += [name]
            return 1


    def remove_ac(self, name: str) -> int:
            int j, k
            if (!ac[name])
            return 0
            j = armour_types.index(ac[name][1]) if ac[name][1] in armour_types else -1
            k = armour_types[j+1].index(name) if name in armour_types[j+1] else -1
            armour_types[j+1] = delete(armour_types[j+1], k, 1)
            if (!sizeof(armour_types[j+1]))
            armour_types = delete(armour_types, j, 2)
            map_delete(ac, name)
            return 1


    def calc_value(self, arr: Any) -> int:
            int i, val
            if (intp(arr)) {
            if(!random(10))
            return random(arr)
            else
            return arr


    def calc_string(self, b: Any) -> str:
            if (intp(b))
            return "rand("+b+")"
            if (!pointerp(b))
            return "Dead"
            switch (sizeof(b)) {
            case 1 :
            return ""+b[0]
            case 2 :
            return ""+b[0]+"+rand("+b[1]+")"
            case 3 :
            return ""+b[0]+"+"+b[1]+"d"+b[2]
            default :
            return "Oh hell"


    def set_ac(self, bing: Any) -> None:
            int i
            for (i=0;i<sizeof(ac);i+=A_ARRAY_SIZE)
            add_ac(ac[i], ac[i+1][A_TYPE], ac[i+1][A_AC])


    def __init__(self):
            self.corpse_weight = STD_CORPSE_WEIGHT


    def init(self, ) -> None:
            add_command("eat", "<direct:object>")


    def query_edible(self, ) -> int:
            string bit
            if(!race_ob.query_eat(bit_data[BIT_NAME])) {
            return 0


    def do_eat(self, ) -> int:
            if(!query_edible())
            return 0
            move( "/room/rubbish" )
            return 1


    def no_decay(self, ) -> int:
            if( race_ob && bit_data ) {
            return race_ob.query_unrottable(bit_data[BIT_NAME])


    def set_race_ob(self, s: MudObject) -> None:
            race_ob = s


    def set_race_name(self, s: str) -> None:
            race_name = s


    def setup_long(self, ) -> None:
            if ( !bit_data ) {
            return


    def extra_look(self, ) -> str:
            if(sizeof(bits_gone))
            return "It appears to be missing the " + query_multiple_short(bits_gone) + ".\n"
            return ""


    def set_bit(self, s: str, dec: int) -> None:
            int temp
            bit_data = (mixed *)race_ob.query_bit(s)
            if (!bit_data || !sizeof(bit_data)) {
            return


    def do_decay(self, ) -> int:
            int rate
            if (!environment()) {
            move( "/room/rubbish" )
            return 0


    def dest_me(self, ) -> None:
            BIT_CONTROLLER.remove_bit(self)
            ::dest_me()


    def query_static_auto_load(self, ) -> Any:
            return int_query_static_auto_load()


    def query_dynamic_auto_load(self, ) -> Any:
            return [bit_data, race_ob, corpse_weight, race_name,
            decay, cured, bits_gone, ::query_dynamic_auto_load()]


    def init_dynamic_arg(self, arg: Any, object) -> None:
            if (mapp(arg)) {
            ::init_dynamic_arg(arg)
            return


    def do_cure(self, ) -> None:
            if ( cured ) {
            return


    def query_cured(self, ) -> int:
            int *query_vect() { return bit_data[BIT_EXTRA][EXTRA_VALUE]; }
            string *query_possible_bits( string word ) {
            int i, j
            string *possibles
            possibles = [})
            for ( i = sizeof( bits ) - 3; i > -1; i -= 3 ) {
            if ( ( bits[ i ] == word ) ||
            ( bits[ i + 1 ] == word ) ||
            !word) {
            if (arrayp( bits[i+2][2] )) {
            for ( j = 0; j < bits[ i + 2][2][1]; j++ ) {
            possibles += [bits[ i ]]


    def query_bit_left(self, s: str) -> str:
            string *poss_bits
            poss_bits = query_possible_bits(s)
            if (!poss_bits || !sizeof(poss_bits)) {
            return 0


    def make_bit(self, which_bit: str) -> MudObject:
            mixed *bit
            object bitobj
            int i,j
            bit = race_ob.query_bit(which_bit)
            if ((sizeof(bit[2][2]) > 1) && stringp(bit[2][2][1])) {
            bitobj = clone_object( bit[2][2] )
            } else if (bit[2][2] == 0) {
            bitobj = clone_object("/std/bit")
            } else {
            bitobj = clone_object("/std/bit")


    def set_bits_gone(self, bits: str) -> None:
            int i
            bits_gone = [})
            for ( i = 0; i < sizeof( bits ); i++ ) {
            add_bit_gone( bits[ i ] )


    def set_bits(self, ) -> None:
            int i, j
            mixed *these_bits, *all_bits
            bits = [})
            these_bits = bit_data
            all_bits = race_ob.query_bits()
            for (i=3; i<sizeof(these_bits[2]); i++) {
            for (j=0; j<sizeof(all_bits); j = j+3) {
            if ((these_bits[0] == all_bits[j+2][0]) && (these_bits[2][i] == all_bits[j])) {
            bits += all_bits[j..j+2]
            delete(all_bits, j, 2)
            break


    def query_determinate(self, caller: MudObject) -> str:
            return race_ob.query_determinate(caller)


    def query_medium_alias(self, ) -> str:
            string temp
            string *temp2 = [})
            if ( !sizeof( bit_data ) )
            return ""
            temp = bit_data[0]
            temp2 = explode( temp, " " )
            temp2 = map( temp2, (: capitalize( $1 ) :) )
            temp = implode( temp2, "" )
            return temp + "Of" + capitalize( race_ob.query_name() )


    def query_collective(self, ) -> int:
            if(query_verb() == "get" || query_verb() == "take")
            return 1


    def __init__(self):
            self.corpse_weight = STD_CORPSE_WEIGHT


    def setup_long(self, ) -> None:
            if ( !bit_data )
            return
            if (no_decay()) {
            if (race_name) {
            set_short( "set of "+ race_name +" "+ bit_data[ BIT_NAME ] )
            set_main_plural( "sets of "+ race_name +" "+ bit_data[ BIT_NAME ] )
            set_long("This is a set of " + (bit_data[BIT_NAME]) +
            " from " + add_a(race_name) + ".\n")
            } else {
            set_short( "set of "+ bit_data[ BIT_NAME ] )
            set_main_plural( "sets of "+ bit_data[ BIT_NAME ] )
            set_long("This is a set of " + (bit_data[BIT_NAME]) +
            " from an unknown creature.\n")


    def __init__(self):
            self._pages = []
            self._default_page_object = "/obj/misc/paper"
            self._def_p_obj = find_object(_default_page_object)


    def query_weight(self, ) -> int:
            if (!_def_p_obj) {
            load_object(_default_page_object)
            _def_p_obj = find_object(_default_page_object)


    def init(self, ) -> None:
            add_command("open", "<direct:object>", (: do_open(1) :))
            add_command("open", "<direct:object> to [page] <number>",
            (: do_open($4[1]) :))
            add_command("tear", "page from <direct:object>", (: do_tear(1) :))
            add_command("tear", "[all] pages from <direct:object>", (: do_tear(0) :))
            add_command("tear", "<number> [of] pages from <direct:object>",
            (: do_tear($4[0]) :))
            add_command("rip", "page from <direct:object>", (: do_tear(1) :))
            add_command("rip", "<number> [of] pages from <direct:object>",
            (: do_tear($4[0]) :))
            add_command("rip", "[all] pages from <direct:object>", (: do_tear(0) :))
            add_command("turn", "[a|1] page of <direct:object>", (: do_turn(1) :))
            add_command("turn", "<number> pages of <direct:object>",
            (: do_turn($4[0]) :))
            add_command("turn", "<direct:object> to [page] <number>",
            (: do_open($4[1]) :) )
            add_command("turn", "to page <number> of <direct:object>",
            (: do_open($4[0]) :) )
            add_command("close", "<direct:object>", (: do_close() :))


    def add_weight(self, number: int) -> int:
            adjust_weight( number )
            return 1


    def test_add(self, ob: MudObject, flag: int) -> int:
            return (object)ob.query_property("my book") == self


    def test_remove(self, ob: MudObject, flag: int, dest: Any) -> int:
            return ob.query_property("my book") != self


    def set_no_pages(self, no: int) -> None:
            int i
            int siz
            siz = sizeof(_pages)
            if (no < siz) {
            _pages = _pages[0..no-1]
            if (_open_page >= no) {
            _open_page = no


    def set_open_page(self, i: int) -> None:
            if (i < 0 || i == _open_page) {
            return


    def query_open_page(self, ) -> int:
            return _open_page


    def is_current_page_torn_out(self, ) -> int:
            if (!_open_page) {
            return 0


    def is_page_torn_out(self, page: int) -> int:
            if (page < 1 || page > sizeof(_pages)) {
            return 0


    def query_current_page(self, ) -> MudObject:
            int i
            if (!_open_page) {
            return self


    def query_current_page_clone(self, ) -> MudObject:
            return self


    def is_default_page(self, num: int) -> int:
            if (num > 0 && num <= sizeof(_pages)) {
            if (_pages[num - 1] &&
            !objectp(_pages[num - 1])) {
            return 1


    def query_selected_page(self, num: int) -> MudObject:
            if (!intp(num) || num <= 0 || num > sizeof(_pages)) {
            return 0


    def query_selected_page_clone(self, num: int) -> MudObject:
            return self


    def tear_current_page_out(self, dest: MudObject) -> MudObject:
            object page
            if (is_current_page_torn_out()) {
            return 0


    def add_page_after(self, page: MudObject, after: int) -> int:
            if (after < 0 || after > sizeof(_pages) + 1 ||
            !objectp(page) || !intp(after)) {
            return 0


    def replace_page_with(self, page: MudObject, num: int) -> int:
            if (num < 1 || num > sizeof(_pages) ||
            !objectp(page) || !intp(num)) {
            return 0


    def make_page_blank(self, num: int) -> int:
            if (num < 1 || num > sizeof(_pages) || !intp(num)) {
            return 0


    def short(self, flags: int) -> str:
            if (!flags || _ignore_open_page) {
            return ::short(flags)


    def long(self, str: str, dark: int) -> str:
            string ret
            int i
            if (!_open_page) {
            return ::long(str, dark)+"It is closed.\n"


    def do_tear(self, number: int) -> int:
            int i
            if (_ignore_saved_pages) {
            add_failed_mess("For some reason you cannot seem to tear any pages "
            "from $D.\n")
            return 0


    def add_read_mess(self, str: Any, type: str, lang: str, size: int) -> None:
            if(_open_page) {
            if(!arrayp(_pages[_open_page-1]))
            _pages[_open_page-1] = [})
            _pages[_open_page-1] += [[str, type, lang, size]]
            return


    def query_read_mess(self, ) -> Any:
            if (_open_page) {
            if(!_pages[_open_page-1])
            return [})
            return _pages[_open_page-1]


    def dest_me(self, ) -> None:
            int i
            for (i=0;i<sizeof(_pages);i++) {
            if (objectp(_pages[i])) {
            _pages[i]->dest_me()


    def query_static_auto_load(self, ) -> Any:
            if (file_name(self)[0..8] == "/std/book") {
            return int_query_static_auto_load()


    def init_dynamic_arg(self, map: Any, player: MudObject) -> None:
            int i
            object *tmp
            if (!player) {
            player = _player
            if (!player) {
            player = this_player()


    def set_default_page_object(self, obj: str) -> None:
            load_object(obj)
            if (find_object(obj)) {
            _default_page_object = obj
            _def_p_obj = find_object(obj)


    def query_default_page_object(self, ) -> str:
            return _default_page_object


    def create_default_page_object(self, ) -> MudObject:
            return clone_object(_default_page_object)


    def query_num_pages(self, ) -> int:
            return sizeof(_pages)


    def query_book_num(self, ) -> int:
            return _book_num


    def set_book_num(self, num: int) -> None:
            _book_num = num


    def query_ignore_saved_pages(self, ) -> int:
            return _ignore_saved_pages


    def set_player(self, player: MudObject) -> None:
            _player = player


    def query_player(self, ) -> MudObject:
            return _player


    def query_read_short(self, player: MudObject, ignore_labels: int) -> str:
            if(!::query_read_short(player, 0))
            return 0
            if (!_open_page) {
            return "the cover of " + ::query_read_short(player, 0)


    def query_readable_message(self, player: MudObject, ignore_labels: int) -> str:
            return ::query_readable_message(player, _open_page != 0)


    def set_book_language(self, lang: str) -> None:
            language = lang


    def set_book_dir(self, dir: str) -> None:
            int i, max
            set_no_pages(10)
            set_ignore_saved_pages(1)
            max = 10
            i = 1
            set_default_page_object("/obj/misc/nroff_paper")
            set_open_page (0)
            while (file_size(dir+i) > 0) {
            set_open_page(i)
            set_read_mess("$$" + dir + i + "$$" , language, 0)
            i++
            if (i >= max) {
            max += 10
            set_no_pages(max)


    def __init__(self):
            self.registered_containers = []
            self._n_tracked_items = 0
            self._tracking = 1


    def query_max_items(self, ) -> int:
            if(_max_items)
            return _max_items
            if(_max_weight)
            return 4 * sqrt(_max_weight)
            return -1


    def update_loc_weight(self, ) -> None:
            object thing
            _loc_weight = 0
            foreach ( thing in all_inventory( self ) )
            _loc_weight += (int)thing.query_complete_weight()


    def query_complete_weight(self, ) -> int:
            return ::query_complete_weight() + _loc_weight


    def add_weight(self, n: int) -> int:
            #ifdef 0
            if ( _prevent_insert )
            return 0
            #endif
            if ( !_max_weight ) {
            _loc_weight += n
            return 1


    def set_ownership(self, word: str) -> None:
            if( word )
            _ownership = lower_case( word )
            else
            _ownership = word


    def test_remove(self, thing: MudObject, flag: int, dest: Any) -> int:
            int player
            string str
            if( !_ownership || !this_player() ) {
            return 1


    def test_add(self, ob: MudObject, flag: int) -> int:
            if(!_max_weight && !_max_items)
            return 1
            if(ob.query_max_weight() > _max_weight - _loc_weight) {
            return 0


    def query_prevent_insert(self, ) -> int:
            varargs int move(mixed dest, mixed messin, mixed messout) {
            if (_prevent_insert && _loc_weight && !living(dest) && environment(dest))
            return MOVE_INVALID_DEST
            return object::move( dest, messin, messout )


    def do_restore_inventory_error(self, ob: MudObject, move_flag: int) -> int:
            object receipt
            int ret
            receipt = clone_object(PLAYER_RECEIPT)
            receipt.setup_receipt(ob)
            receipt.set_weight(0)
            ret = receipt.move(self)
            if (ret != MOVE_OK) {
            receipt.dest_me()
            } else {
            move_flag = MOVE_OK
            ob.move("/room/rubbish")


    def stats(self, ) -> Any:
            return ::stats() + ({
            ["loc_weight", query_loc_weight(),],
            ["max_weight", query_max_weight(),],
            ["max_items", query_max_items(),],
            ["export invent", query_can_export_inventory()],
            })


    def set_player(self, thing: MudObject) -> None:
            ::set_player(thing)
            _player = thing


    def query_player(self, ) -> MudObject:
            nomask void enable_item_tracking() { _tracking = 1; }
            nomask void disable_item_tracking() { _tracking = 0; }
            nomask void event_container_move( object mover, mixed from, mixed to ) {
            if (_n_tracked_items)
            all_inventory()->event_container_move( mover, from, to )


    def event_move_object(self, from: Any, to: Any) -> None:
            if (_n_tracked_items && _tracking && !interactive()) {
            all_inventory()->event_container_move( self, from, to )
            if (objectp(from)) from.remove_tracked_items( _n_tracked_items )
            if (objectp( to )) to.add_tracked_items( _n_tracked_items )


    def can_find_match_recurse_into(self, looker: MudObject) -> int:
            object env
            env = environment()
            while (env &&
            !living(env) &&
            env != looker &&
            env != environment(looker)) {
            env = environment(looker)


    def can_find_match_reference_inside_object(self, thing: MudObject, looker: MudObject) -> int:
            return 1


    def init_dynamic_arg(self, bing: Any, object) -> None:
            function f
            if ( bing[ "::" ] ) {
            ::init_dynamic_arg( bing[ "::" ] )


    def init_static_arg(self, bing: Any) -> None:
            if ( bing[ "::" ] ) {
            ::init_static_arg( bing[ "::" ] )


    def query_static_auto_load(self, ) -> Any:
            if (file_name(self)[0..13] == "/std/container") {
            return int_query_static_auto_load()


    def dest_me(self, ) -> None:
            foreach( object ob in all_inventory( self ) ) {
            reset_eval_cost()
            ob.dest_me()


    def __init__(self):
            self._delivery = ([ ])
            self._save_file = ""
            self._delivery_delay = 5
            self._delivery_mess = "\nA small womble wearing a bright green hat "
            self._burdened_mess = "\nA small womble wearing a bright purple "
            self._cont = clone_object("/std/container")


    def add_delivery(self, who: Any, sender: Any, item: MudObject, delay: int) -> None:
            string name, from
            class delivery_item parcel
            if (objectp(who))
            name = who.query_name()
            else
            name = who
            if (objectp(sender))
            from = sender.query_cap_name()
            else
            from = sender
            parcel = new(class delivery_item,
            delivery_ob : item, submit_time : time(), sent_by : from,
            delay_time : delay)
            if (undefinedp(_delivery[name]))
            _delivery[name] = [parcel]
            else
            _delivery[name] += [parcel]
            log_file("DELIVERY", "%s added a new delivery item for %s, %s sent "
            "by %s.\n", previous_object()->short(), name, item.short(),
            from)
            item.move(_cont)
            save_file()


    def query_theft_command(self, ) -> int:
            return -1


    def clean_delivery_mapping(self, ) -> None:
            string *people, person
            people = keys(_delivery)
            foreach (person in people) {
            _delivery[person] = filter(_delivery[person],
            (: objectp($1->delivery_ob) :))


    def load_file(self, ) -> None:
            int i, j, size
            mixed *tmp
            string who
            mixed *items
            if(_save_file == "")
            return
            log_file("DELIVERY", "Attempting to load save file at %s.\n",
            ctime(time()))
            tell_creator("ceres", "Loading: %s\n", _save_file)
            if (file_size(_save_file + ".o") > -1) {
            unguarded((: restore_object, _save_file :))
            if (!_cont)
            _cont = clone_object("/std/container")
            all_inventory(_cont)->move("/room/rubbish")
            for (i = 0; i < sizeof(_item_save); i = i + 2) {
            who = _item_save[i]
            items = _item_save[i + 1]
            if (!_delivery[who])
            return
            tmp = load_auto_load_to_array(items, this_player())
            size = sizeof(tmp)
            for (j = 0; j < size; j++) {
            _delivery[who][j]->delivery_ob = tmp[size - j - 1]
            tmp[j]->move(_cont)


    def dest_me(self, ) -> None:
            if (_cont)
            _cont.dest_me()


    def query_cont(self, ) -> MudObject:
            return _cont


    def tidy_up(self, ) -> None:
            string person
            foreach(person in keys(_delivery)) {
            if(!PLAYER_HANDLER.test_user(person) || !PLAYER_HANDLER.test_active(person)) {
            log_file("DELIVERY", "%s Removing delivery for %s (inactive).\n",
            self.query_short(), person)
            map_delete(_delivery, person)


    def attach_to_player(self, p: MudObject, i: int) -> MudObject:
            player = p
            id = i
            return shadow( player, 1 )


    def remove_effect_shadow(self, i: int) -> None:
            if (i == id) { if( self ) destruct( self ); return; }
            player.remove_effect_shadow(i)


    def set_holder(self, ob: MudObject) -> int:
            holder = ob
            return 1


    def drop(self, dest: Any) -> int:
            holder = 0
            return ::drop(dest)


    def __init__(self):
            self._group_info = ([ ])


    def ok_to_clone(self, ) -> int:
            return 1


    def set_data_directory(self, dir: str) -> None:
            _data_directory = dir
            asyncio.create_task(self."scan_for_new_data", 2)


    def query_data_directory(self, ) -> str:
            return _data_directory


    def set_npc_path(self, path: str) -> None:
            _npc_path = path


    def set_domain(self, domain: str) -> None:
            _domain = domain


    def set_max_cache(self, num: int) -> None:
            _max_cache = num


    def set_disable_npc_generation(self, value: int) -> None:
            _disable_npc_generation = value


    def query_disable_npc_generation(self, ) -> int:
            return _disable_npc_generation


    def npc_path(self, str: str) -> str:
            return _npc_path + "/" + str


    def scan_for_new_data(self, force: int) -> int:
            string *files
            string fname
            string *bits
            debug_printf("Scan for new data.")
            if (unguarded( (: stat(__FILE__)[1] :)) !=
            _file_modified_time[__FILE__]) {
            _file_modified_time = ([ ])


    def roll_dice(self, die: Any) -> int:
            int result
            int i
            if (intp(die)) {
            return die


    def query_npc_max_population(self, npc: str) -> int:
            if (!_npc_info[npc]) {
            return -1


    def query_npc_current_population(self, npc: str, clean: int) -> int:
            class npc_info data
            if (!_npc_info[npc]) {
            return -1


    def is_npc_under_max_population(self, name: str) -> int:
            class npc_info info
            info = _npc_info[name]
            if (!info) {
            return 0


    def is_group_under_max_population(self, name: str) -> int:
            class party_info party
            party = _party_info[name]
            if (!party) {
            return 0


    def npc_died(self, ob: MudObject) -> None:
            string npc_id
            class npc_info info
            int i
            mixed* stuff
            npc_id = ob.query_property("npc_id")
            info = _npc_info[npc_id]
            if (!info || !npc_id) {
            return


    def do_report(self, ) -> int:
            string name
            class party_info party
            class npc_info npc
            string txt
            int total
            int max
            int pop
            txt = ""
            total = 0
            txt += "%^WHITE%^NPCs%^RESET%^\n"
            foreach( name, npc in _npc_info ) {
            reset_eval_cost()
            if(stringp(npc->path) && file_size(npc_path(npc->path) + ".c") > 0) {
            pop = query_npc_current_population(name, 0)
            } else {
            pop = 0


    def init(self, ) -> None:
            object ob
            ob = this_player()
            add_command("report", "", (: do_report :))
            add_command("scan", "", (: scan_for_new_data :))
            if(ob.query_property("npc_id") && ob.query_property("hospital") &&
            ob.query_property("hospital") == base_name(self)) {
            if(!_cache_inventory[ob.query_property("npc_id")])
            _cache_inventory[ob.query_property("npc_id")] = [ob]
            else if(sizeof(_cache_inventory[ob.query_property("npc_id")]) >
            _max_cache)
            ob.move("/room/rubbish")
            else
            _cache_inventory[ob.query_property("npc_id")] += [ob]
            } else if(base_name(ob) == "/obj/corpse")
            ob.move("/room/rubbish")


    def no_attack(self, ) -> int:
            mapping query_dynamic_auto_load() {
            string party_name
            string npc
            class party_info data
            class npc_info npc_data
            mapping tmp
            mapping tmp2
            tmp = allocate_mapping( sizeof( _party_info ) )
            foreach( party_name, data in _party_info ) {
            tmp[ party_name ] = data->storage


    def init_dynamic_arg(self, tmp: Any) -> None:
            string party_name
            object *npcs
            if ( tmp[ file_name( self ) ] ) {
            foreach( party_name, npcs in tmp[ file_name( self ) ] ) {
            if (_party_info[party_name]) {
            _party_info[ party_name ]->storage = npcs


    def query_all_npcs(self, ) -> Any:
            return values( map( _party_info, (: $2->storage :) ) )


    def __init__(self):


    def set_key(self, str: str, prop: str) -> None:
            string *bits
            int i
            set_short( str + " key" )
            set_main_plural( str + " keys" )
            set_name( "key" )
            add_plural( "keys" )
            bits = explode( str, " " )
            for( i = 0; i < sizeof( bits ); i ++ ) {
            add_adjective( bits[i] )


    def query_static_auto_load(self, ) -> Any:
            if ( base_name(self) + ".c" == __FILE__ )
            return int_query_static_auto_load()
            return ([ ])


    def __init__(self):
            self.pages = ['({ })']


    def init(self, ) -> None:
            add_command( "turn", "[a] page of <direct:object>" )
            add_command( "open", "<direct:object> to [page] <number>",
            (: do_open($4[1]) :))


    def set_no_pages(self, number: int) -> None:
            int i
            if ( number < 1 ) {
            number = 1


    def add_read_mess(self, mess: Any, type: str, lang: str, size: int) -> Any:
            mixed ret
            ret = ::add_read_mess( mess, type, lang, size )
            pages[ page ] = query_read_mess()
            return ret


    def set_open_page(self, number: int) -> None:
            if ( ( number < 1 ) || ( number > sizeof( pages ) ) ) {
            number = 1


    def do_turn(self, ) -> int:
            set_open_page( page + 2 )
            return 1


    def do_open(self, page_no: int) -> int:
            if ( ( page_no < 1 ) || ( page_no > sizeof( pages ) ) ) {
            add_failed_mess("The page no " + page_no + " does not exist.\n")
            return 0


    def init_dynamic_arg(self, map: Any) -> None:
            if ( !mapp( map ) ) {
            return


    def query_read_short(self, player: MudObject, ignore_labels: int) -> str:
            string ret
            if (page == 0) {
            ret = ::query_read_short(player, 1)
            } else {
            ret = ::query_read_short(player, 0)


    def lesson_response(self, string, object, int, string) -> int:
            int register_lesson(string name, mapping minimum_skills,
            mapping maximum_skills, string *materials, int cost,
            string currency, string *lesson_ending, object teacher ) {
            if(!_lessons)
            _lessons = ([ ])
            if(_lessons[name])
            return 0
            _lessons[name] = new(class lesson,
            minimum_skills : minimum_skills,
            maximum_skills : maximum_skills,
            materials : materials,
            cost : cost,
            currency : currency,
            lesson_ending : lesson_ending,
            teacher : teacher
            )
            return 1


    def has_required_skills(self, name: str, player: MudObject) -> int:
            string skill
            int p_level
            foreach( skill in (keys(_lessons[name]->minimum_skills)) ){
            p_level = player.query_skill(skill)
            if( p_level < _lessons[name]->minimum_skills[skill] ){
            return 0


    def has_required_materials(self, name: str, player: MudObject) -> int:
            string mat
            foreach( mat in _lessons[name]->materials ) {
            if( sizeof( filter_array(deep_inventory(player),
            (: ($1)->query_short() :) ) ) ){
            return 1


    def has_required_cash(self, name: str, player: MudObject) -> int:
            if(player.query_value_in(_lessons[name]->currency) < _lessons[name]->cost) {
            return 0
            } else {
            return 1


    def start_lesson(self, name: str, player: MudObject) -> int:
            string *needed
            if(!_lessons[name])
            return notify_fail(player, "Sorry, it's not clear what you want to learn "
            "here.\n")
            needed = [})
            if(!has_required_skills(name, player))
            needed += ["skills"]
            if(!has_required_materials( name, player ))
            needed += ["materials"]
            if(!has_required_cash( name, player ))
            needed += ["cash"]
            if(sizeof(needed)) {
            debug_printf( "Player doesn't have the correct %s\n",
            query_multiple_short(needed) )
            return add_failed_mess("Sorry, You don't have the correct " +
            query_multiple_short(needed) + " to learn today.\n")


    def lesson_response(self, name: str, student: MudObject, lessonstep: int, args: str) -> int:
            class step current
            if(this_player() != student)
            return 0
            current = _lessons[name]->plan[lessonstep]
            if(sizeof(current->params) &&
            current->params.index(args[0]) if args[0] in current->params else -1 == -1)
            return student->add_failed_mess(self, "Invalid response.\n",
            [}))
            switch(TASKER->perform_task(student, current->skill, current->difficulty,
            TM_FIXED)) {
            case AWARD:
            await student.send("%^YELLOW%^"+current->award_mess+"%^RESET%^\n")
            case SUCCEED:
            await  student.send(current->succeed_mess + "\n")
            student.remove_object(self, 1)
            if( (sizeof(_lessons[name]->plan)-1) == lessonstep ) {
            tell_creator("belle", "Lesson is on its last step: %d\n", lessonstep )
            asyncio.create_task(self. "lesson_end", 1, name, student )
            return 1
            } else {
            asyncio.create_task(self."lesson_step", 1, name, student, ++lessonstep)


    def lesson_end(self, name: str, student: MudObject) -> int:
            string str
            object teacher = _lessons[name]->teacher
            foreach( str in (_lessons[name]->lesson_ending) ) {
            if( teacher )
            teacher.queue_command(str)
            else
            await student.send(str)


    def __init__(self):


    def init(self, ) -> None:
            this_player()->add_command( "light", self )
            this_player()->add_command( "dowse", self )
            this_player()->add_command( "extinguish", self )


    def out_of_fuel(self, ) -> None:
            object env
            fuel = 0
            lit = 0
            set_lit( 0 )
            FUEL_HANDLER.remove_burner( self )
            if( !environment() ) return
            env = environment()
            if( living( env ) ) {
            await  env.send(the_short() +" goes out.\n" )
            tell_room( environment( env ),
            env.the_short() +"'s "+ short() +" goes out.\n", env )
            } else {
            tell_room( env, the_short() +" goes out.\n" )


    def delayed_light(self, ) -> None:
            lit = 1


    def hold_thing(self, ) -> int:
            if( !query_wielded() )
            return HOLD_COMMAND.cmd( [self] )
            else
            return 1


    def set_lit(self, i: int) -> int:
            if( !i ) {
            if( !query_property( "unextinguishable" ) ) {
            lit = 0
            FUEL_HANDLER.remove_burner( self )
            remove_adjective( "lit" )
            set_light( 0 )
            return 0


    def set_holder(self, ob: MudObject, pos: int) -> Any:
            if( lit && hold && !ob && environment( this_player() )
            && file_name( environment( this_player() ) ) != DEPARTURES )
            if( !set_lit( 0 ) ) {
            await  this_player().send("You extinguish "+ the_short() +".\n" )
            tell_room( environment( this_player() ), this_player()->the_short() +
            " extinguishes "+ the_short() +".\n", this_player() )


    def query_lit(self, ) -> int:
            return lit


    def do_light(self, ) -> int:
            if( lit )
            return notify_fail( the_short() +" is already lit.\n" )
            if( !fuel )
            return notify_fail( the_short() +" "+ empty_mess +"\n" )
            if( !set_lit( 1 ) )
            return notify_fail( "You cannot light "+ the_short() +".\n" )
            this_player()->add_succeeded_mess( self, "$N $V $D.\n", [}) )
            return 1


    def do_dowse(self, ) -> int:
            if( !lit )
            return notify_fail( the_short() +" is not lit.\n" )
            if( set_lit( 0 ) )
            return notify_fail( "You cannot extinguish "+ the_short() +".\n" )
            this_player()->add_succeeded_mess( self, "$N $V $D.\n", [}) )
            return 1


    def do_extinguish(self, ) -> int:
            return do_dowse()


    def set_fuel_messages(self, msgs: Any) -> None:
            fuel_messages = msgs


    def query_fuel_messages(self, ) -> Any:
            return fuel_messages


    def set_max_fuel(self, i: int) -> None:
            max_fuel = i


    def query_max_fuel(self, ) -> int:
            return max_fuel


    def set_fuel(self, i: int) -> None:
            fuel = i
            if( fuel > max_fuel )
            fuel = max_fuel


    def query_fuel(self, ) -> int:
            return fuel


    def current_fuel_message(self, ) -> str:
            mixed messages
            int fuel_percent, size, i
            string fuel_string = ""
            if( fuel < 1 )
            return "It "+ empty_mess
            messages = query_fuel_messages()
            size = sizeof( messages )
            if( !size )
            return "This item needs a creator.  It is broken and lonely."
            if( size < 2 )
            return messages[0]
            fuel_percent = fuel * 99 / max_fuel
            if( intp( messages[1] ) ) {
            for( i = 1; i < size; i += 2 ) {
            if( messages[i] > fuel_percent ) {
            fuel_string = messages[i-1]
            break


    def set_empty_mess(self, msg: str) -> None:
            empty_mess = msg


    def query_empty_mess(self, ) -> str:
            return empty_mess


    def set_brightness(self, i: int) -> None:
            brightness = i


    def query_brightness(self, ) -> int:
            return brightness


    def set_hold_required(self, hands: int) -> None:
            hold = hands


    def query_hold_required(self, ) -> int:
            return hold


    def extra_look(self, ) -> str:
            string lit_str
            if( lit )
            lit_str = "It is lit.  "
            else
            lit_str = "It is not currently lit.  "
            return lit_str + current_fuel_message() +"\n"


    def query_dynamic_auto_load(self, ) -> Any:
            return ([ "::" : ::query_dynamic_auto_load(),
            "fuel" : fuel,
            "lit" : lit,
            ])


    def init_dynamic_arg(self, arg: Any, bing: MudObject) -> None:
            fuel = arg["fuel"]
            ::init_dynamic_arg(arg["::"], bing)
            set_lit(arg["lit"])


    def consume_fuel(self, ) -> None:
            fuel -= FUEL_TIME
            if( fuel < 1 )
            out_of_fuel()


    def query_value(self, ) -> int:
            return (int)( ::query_value() * fuel / max_fuel )


    def __init__(self):
            self._locations = ([ ])


    def extra_look(self, ) -> str:
            return "Marked on the map are " +
            query_multiple_short(_features.query_base_description() +
            keys(_locations)) + "."


    def filter_features(self, feature: str) -> int:
            #ifdef DEBUG
            debug_printf("%s %d %d", feature,
            feature.query_max_range() / TERRAIN_MAP_ONE_MILE,
            _detail / TERRAIN_MAP_ONE_MILE)
            #endif
            return (!feature.query_max_range() ||
            feature.query_max_range() >= _detail)


    def setup_map(self, x1: int, y1: int, x2: int, y2: int, detail: int) -> None:
            _area = [x1, y1, x2, y2]
            _detail = detail
            _features = WORLD_MAP.query_features_in_region(x1, y1, x2, y2)
            _features = filter(_features, "filter_features", self)


    def set_map(self, area: str) -> None:
            int width, height, detail, x1, y1, x2, y2
            switch(area) {
            case "sur":
            width = (TERRAIN_MAP_ONE_MILE * 300)
            height = (TERRAIN_MAP_ONE_MILE * 200)
            x1 = -150575040 - width
            y1 = -2173248 - height
            x2 = -150575040 + width
            y2 = -2173248 + height
            detail = (TERRAIN_MAP_ONE_MILE * 50)
            break
            case "world":
            x1 = TERRAIN_MAP_WORLD_LOW_X / 10
            y1 = TERRAIN_MAP_WORLD_LOW_Y / 10
            x2 = TERRAIN_MAP_WORLD_HIGH_X / 10
            y2 = TERRAIN_MAP_WORLD_HIGH_Y / 10
            detail = (TERRAIN_MAP_ONE_MILE * 200)
            break


    def recalc_coords(self, ) -> None:
            int accuracy
            if(!_co_ords || this_player() != _pl || environment(this_player()) != _env) {
            _pl = this_player()
            _env = environment(_pl)
            _co_ords = _env.query_co_ord()
            accuracy = 500 - _pl.query_skill_bonus("other.direction")
            if(accuracy < 1)
            accuracy = 1
            _fudge = TERRAIN_MAP_ONE_MILE * accuracy
            _co_ords[0] += -(_fudge/2) + random(_fudge)
            _co_ords[1] += -(_fudge/2) + random(_fudge)
            _co_ords[2] += -(_fudge/2) + random(_fudge)


    def do_consult(self, find: str) -> int:
            string feature, *res
            object ob
            mapping direcs
            if(this_player()->check_dark(environment(this_player())->query_light()))
            return notify_fail("Sorry the light levels are not conducive to "
            "reading a map.\n")
            recalc_coords()
            if(_co_ords[0] < _area[0] || _co_ords[1] < _area[1] ||
            _co_ords[0] > _area[2] || _co_ords[1] > _area[3])
            return notify_fail("Sorry, you do not appear to be anywhere on this "
            "map.\n")
            res = [})
            foreach(feature in _features) {
            ob = feature.query_region_ob()
            if(ob) {
            #ifdef DEBUG
            debug_printf("%O max range %d", feature,
            feature.query_max_range()/TERRAIN_MAP_ONE_MILE)
            #endif
            direcs = ob->query_feature_desc_from(_co_ords[0], _co_ords[1],
            _co_ords[2], 1)
            if(direcs) {
            if(find == "" || strsrch(lower_case(feature.query_base_description()),
            lower_case(find)) != -1)
            res += [feature.calc_map_feature_desc(direcs, _fudge)]


    def do_add(self, location: str) -> int:
            if(keys(_locations.index(lower_case(location)) if lower_case(location) in keys(_locations else -1) != -1)
            return notify_fail("A location with the name " + location +
            " already exists on this map.\n")
            _locations[lower_case(location)] = _co_ords
            this_player()->add_succeeded_mess(self, "$N $V a new location "
            "to $D.\n")
            return 1


    def init(self, ) -> None:
            this_player()->add_command("consult", self, "<direct:object>",
            (: do_consult("") :))
            this_player()->add_command("find", self,
            "<string'place'> on <direct:object>",
            (: do_consult($4[0]) :))
            this_player()->add_command("add", self,
            "<string'description'> to <direct:object>",
            (: do_add($4[0]) :))


    def query_static_auto_load(self, ) -> Any:
            if((file_name(self))[0..7] != "/std/map" )
            return 0
            return int_query_static_auto_load()


    def init_static_arg(self, args: Any) -> None:
            if(args["::"])
            ::init_static_arg(args["::"])
            if(args["features"])
            _features = args["features"]
            if(args["detail"])
            _detail = args["detail"]
            if(args["area"])
            _area = args["area"]


    def __init__(self):


    def init(self, ) -> None:
            this_player()->add_command( "chip", self, "<direct:object> 'with' <indirect:object>" )
            this_player()->add_command( "chip", self, "<direct:object> 'using' <indirect:object>" )
            this_player()->add_command( "smash", self, "<direct:object> 'with' <indirect:object>" )
            this_player()->add_command( "smash", self, "<direct:object> 'using' <indirect:object>" )


    def long(self, str: str, dark: int) -> str:
            string bit1, bit2, ret
            sscanf( ::long( str, dark ), "%s$mineral$%s", bit1, bit2 )
            ret = bit1 + (string)HANDLER.identify_material( mineral, this_player(), 1 )
            + bit2
            return ret


    def query_value(self, ) -> int:
            return ( query_weight() * (int)(PRICE_INDEX)->query_price( mineral,
            DEFAULT_MARKET ) )


    def query_value_in(self, word: str) -> int:
            if ( ( !word || ( word == "" ) ) || ( word == "default" ) )
            word = DEFAULT_MARKET
            return ( query_weight() * (int)(PRICE_INDEX)->query_price( mineral, word ) )


    def do_chip(self, tools: MudObject) -> int:
            object chip
            if ( !check_tool( tools ) )
            return 0
            if ( query_weight() == 1 ) {
            write( "This piece of "+ (string)HANDLER->identify_material( mineral,
            this_player(), 0 ) +" is already a chip.\n" )
            return 0


    def do_smash(self, tools: MudObject) -> int:
            int i, j, largest, number, size
            object debris, remains
            if ( !check_tool( tools ) )
            return 0
            largest = this_player()->query_max_weight()
            if ( largest >= query_weight() )
            largest = query_weight()
            else {
            remains = clone_object( MINERAL )
            remains.make_mineral( mineral, query_weight() - largest )
            remains.move( environment() )


    def check_tool(self, tools: MudObject) -> int:
            string tool
            object *held
            if ( sizeof( tools ) > 1 ) {
            write( "You only need to use one tool at a time.\n" )
            return 0


    def init_static_arg(self, map: Any) -> None:
            if ( map["::"] )
            ::init_static_arg( map["::"] )
            if ( !undefinedp( map["mineral"] ) )
            mineral = map["mineral"]


    def query_static_auto_load(self, ) -> Any:
            if ( file_name( self )[ 0 .. 11 ] == "/std/mineral" )
            return int_query_static_auto_load()
            return ([ ])


    def __init__(self):
            self._materials = []
            self.create_me = (string)this_player()->query_name()
            self.create_me = "who knows"


    def set_name(self, word: str) -> None:
            if ( query_name() && ( query_name() != "object" ) ) {
            ::set_name(word)
            return


    def query_long_details(self, arg: str, dark: int, looker: MudObject) -> str:
            string stuff
            stuff = ""
            if ( this_player()->query_see_octarine() ) {
            stuff += enchant_string()


    def replace_long_dollars(self, player: MudObject, text: str) -> str:
            if ( colour ) {
            text = replace( text, "$colour$",
            (string)CMR_HANDLER.identify_colour( colour, player ) )


    def long(self, word: str, dark: int) -> str:
            string stuff
            stuff = ::long( word, dark )
            stuff += calc_extra_look()
            stuff += query_long_details(word, dark, this_player())
            stuff = replace_long_dollars( this_player(), stuff )
            return stuff


    def query_material(self, ) -> str:
            if (sizeof(_materials)) {
            return _materials[0]


    def set_material(self, word: Any) -> None:
            if (!arrayp(word)) {
            word = [word]


    def add_material(self, material: Any) -> None:
            if (pointerp(material)) {
            _materials |= material
            } else if (stringp(material)) {
            _materials += [material]


    def set_quality(self, quality: int) -> None:
            add_property("quality", quality)


    def query_quality(self, ) -> int:
            return query_property("quality")


    def init_static_arg(self, map: Any) -> None:
            if ( !mapp( map ) ) {
            return


    def init_dynamic_arg(self, map: Any, object) -> None:
            int recycle
            if ( !mapp( map ) )
            return
            recycle = query_property("no recycling")
            if ( map[ "properties" ] )
            map_prop = map[ "properties" ]
            if (recycle)
            add_property("no recycling", recycle)
            if ( map[ "timed properties" ] ) {
            timed_properties = map[ "timed properties" ]
            reload_player_properties()


    def query_readable_message(self, player: MudObject, ignore_labels: int) -> str:
            string ret
            string bing
            object *labels
            object ob
            int *enums
            object store
            ret = ::query_readable_message(player)
            if (!ignore_labels) {
            enums = (int *)self.effects_matching( "object.label" )
            if ( !sizeof( enums ) ) {
            labels = [})
            } else {
            store = (object)self.arg_of( enums[ 0 ] )[ 0 ]
            if ( !objectp( store ) ) {
            labels = [})
            } else {
            labels = (object *)store.find_inv_match( "" )


    def query_read_short(self, player: MudObject, ignore_labels: int) -> str:
            string ret
            object *labels
            int *enums
            object store
            ret = ::query_read_short(player)
            if (!ignore_labels) {
            enums = (int *)self.effects_matching( "object.label" )
            if ( !sizeof( enums ) ) {
            labels = [})
            } else {
            store = (object)self.arg_of( enums[ 0 ] )
            if ( !objectp( store ) ) {
            labels = [})
            } else {
            labels = (object *)store.find_inv_match( "" )


    def query_help_file_directory(self, ) -> str:
            return "/doc/object/"


    def clean_up(self, inherited: int) -> int:
            if(inherited) {
            log_file("CLEANUP", "%s %s cleaned up.\n", ctime(time()),
            file_name(self))
            move("/room/rubbish")


    def dest_me(self, ) -> None:
            effects_desting()
            ::dest_me()


    def get_plant_short(self, ) -> str:
            if (plant_name && plant_type)
            return plant_type
            return "plant"


    def get_plant_long(self, ) -> str:
            if (plant_desc)
            return plant_desc
            return "A lovely plant thingy.\n"


    def setup(self, ) -> None:
            set_name("plant")
            set_short((: get_plant_short() :))
            set_long((: get_plant_long() :))
            add_property("plant",1)


    def init_dynamic_arg(self, map: Any, bing: MudObject) -> None:
            if ( map["::"] )
            ::init_dynamic_arg( map["::"], bing )
            if ( !undefinedp( map["plant_name"] ) ) {
            plant_name = map["plant_name"]


    def __init__(self):
            self._races = ([
            self._guilds = ([
            self._race_obs = ([ ])
            self._race_obs[tmp] = load_object(tmp)
            self._guild_obs = ([ ])
            self.catch(_guild_obs[tmp] = load_object(tmp))


    def query_valid_race(self, race: str) -> int:
            return !undefinedp(_races[race])


    def set_level(self, lvl: int, race: str, guild: str) -> None:
            object ob
            string race_ob, class_ob
            if (_races[race]) {
            race_ob = _races[race]
            } else {
            race_ob = _races[0]


    def query_race_path(self, race_name: str) -> str:
            return _races[race_name]


    def query_guild_path(self, guild_name: str) -> str:
            return _classs[class_name]


    def __init__(self):
            self.num_pages = 1
            self.open_page = 1
            self.pages = ['({ 0', '0', '0 })']


    def init(self, ) -> None:
            add_command("scroll", "<word'forward|backward'>", (:self.do_scroll($4[0]):))


    def set_read_mess(self, mess: str, lang: str, size: int) -> None:
            pages[ open_page ] = [mess, lang, size]
            ::set_read_mess( mess, lang, size )


    def add_read_mess(self, mess: str, type: str, lang: str, size: str) -> None:
            pages[ open_page ] = [mess, lang, size]
            ::set_read_mess( mess, lang, size )


    def set_open_page(self, number: int) -> None:
            int size
            string mess, lang
            mixed *text
            if ( ( number < 0 ) || ( number > num_pages ) )
            open_page = 1
            else
            open_page = number
            text = pages[ open_page ]
            if ( !text || ( sizeof( text ) < 3 ) )
            text = [0, 0, 0]
            mess = text[ 0 ]
            lang = text[ 1 ]
            size = text[ 2 ]
            ::set_read_mess( mess, lang, size )


    def do_scroll(self, word: str) -> int:
            if ( ( word != "forward" ) && ( word != "backward" ) ) {
            notify_fail( "Syntax: scroll forward|backward\n" )
            return 0


    def query_static_auto_load(self, ) -> Any:
            if ( ( file_name( self ) )[ 0 .. 10 ] != "/std/scroll" )
            return 0
            return int_query_static_auto_load()


    def init_dynamic_arg(self, args: Any) -> None:
            ::init_dynamic_arg( args[ "::" ] )
            open_page = args[ "open_page" ]


    def init_static_arg(self, args: Any) -> None:
            if ( args[ "::" ] ) ::init_static_arg( args[ "::" ] )
            if ( args[ "num_pages" ] ) num_pages = args[ "num_pages" ]
            if ( args[ "pages" ] ) pages = args[ "pages" ]


    def __init__(self):
            self._skills = STD_SKILLS
            self._skill_tree = ([ ])
            self._immediate_children = ([ ])
            self._not_allowed_to_teach = ([ ])
            self._only_show_if_non_zero = ([ ])
            self._no_bonus = ([ ])
            self.lang_tree = []
            self.languages = LANGUAGE_HAND->query_languages()
            self.for (i = 0;i<sizeof(languages);i++) {
            self.rabbit = []
            self.rabbit + = ['SPOKEN_SKILL', '0', '0', '({ })']


    def __init__(self):
            self._skills = STD_SKILLS
            self._skill_tree = ([ ])
            self._immediate_children = ([ ])
            self._not_allowed_to_teach = ([ ])
            self._only_show_if_non_zero = ([ ])
            self._no_bonus = ([ ])
            self.lang_tree = []
            self.languages = LANGUAGE_HAND->query_languages()
            self.for (i = 0;i<sizeof(languages);i++) {
            self.rabbit = []
            self.rabbit + = ['SPOKEN_SKILL', '0', '0', '({ })']
            if (LANGUAGE_HAND.query_language_written(languages[i]) ||
            LANGUAGE_HAND.query_language_magic(languages[i])) {
            rabbit += [WRITTEN_SKILL, 0, 0, [})]


    def query_skill_stat(self, skill: str) -> str:
            int i
            string *bit, s
            bit = explode(skill, ".")
            i = sizeof(bit)
            while (i >= 0) {
            s = implode(bit[0..i], ".")
            if (_stat_bonus[s])
            return _stat_bonus[s][SKILL_BONUS]
            else
            i--


    def query_skill_cost(self, skill: str) -> int:
            if (_reg_skills[skill]) {
            return _reg_skills[skill][1]


    def query_skill(self, bits: str) -> str:
            mixed *arr
            int i
            string path, s1
            if( !bits || !sizeof(bits) ) {
            return 0


    def query_only_leaf(self, str: str) -> int:
            string *bits
            bits = explode(str, ".")
            return _only_leaf[bits[0]]


    def query_allowed_to_teach(self, str: str) -> int:
            return !_not_allowed_to_teach[str]


    def query_only_show_if_non_zero(self, str: str) -> int:
            return _only_show_if_non_zero[str]


    def query_no_bonus(self, str: str) -> int:
            return _no_bonus[str] || _ignore_bits[str]


    def is_skill_ignored(self, skill: str) -> int:
            return _ignore_bits[skill]


    def query_skill_depth(self, skill: Any) -> int:
            int depth
            int i
            depth = 0
            for (i = 0; i < sizeof(skill) - 1; i++) {
            if (!is_skill_ignored(implode(skill[0..i], "."))) {
            depth++


    def __init__(self):


    def dest_me(self, ) -> None:
            destruct(self)


    def __init__(self):


    def __init__(self):
            self.attack_names = []
            self.attack_types = []
            self.attack_data = []
            self.special_messages = ([ ])


    def add_attack_message(self, name: str, type: str, data: str) -> None:
            string nam
            nam = type
            if (name) {
            nam += "-" + name


    def remove_attack(self, a_name: str) -> None:
            int i
            i = attack_names .index( a_name) if  a_name in attack_names  else -1
            if ( i == -1 )
            return
            attack_names = delete(attack_names, i, 1)
            attack_types = delete(attack_types, i, 1)
            attack_data = delete( attack_data, i * W_ARRAY_SIZE, W_ARRAY_SIZE )


    def calc_attack(self, number: int, percent: int) -> int:
            int damage, *data
            data = attack_data[ number * W_ARRAY_SIZE + W_DAMAGE ]
            damage = data[ F_FIXED ] + roll_MdN( data[ F_NUM ], data[ F_DIE ] )
            damage = (int)self->modify_damage( damage,
            attack_names[ number ] )
            damage = ( damage * percent ) / 100
            return damage


    def query_weapon_type(self, ) -> str:
            int i
            string type
            for ( i = 0; i < sizeof( attack_data ); i += W_ARRAY_SIZE ) {
            if ( !type ) {
            type = attack_data[ i + W_SKILL ]
            continue


    def weapon_stats(self, ) -> Any:
            int i, j
            string bit
            mixed *ret
            ret = [})
            for ( i = 0; i < sizeof( attack_data ); i += W_ARRAY_SIZE, j++ ) {
            ret += ({
            ["attack #"+ j, attack_names[ j ]],
            ["   chance", attack_data[ i + W_CHANCE ]]
            })
            if ( attack_data[ i + W_DAMAGE ][ F_FIXED ] )
            bit = attack_data[ i + W_DAMAGE ][ F_FIXED ] +"+"
            else
            bit = ""
            if ( attack_data[ i + W_DAMAGE ][ F_NUM ] )
            bit += attack_data[ i + W_DAMAGE ][ F_NUM ] +"d"+
            attack_data[ i + W_DAMAGE ][ F_DIE ]
            else
            if ( attack_data[ i + W_DAMAGE ][ F_DIE ] )
            bit += "1d"+ attack_data[ i + W_DAMAGE ][ F_DIE ]
            ret += ({
            ["   damage", bit],
            ["     type", attack_data[ i + W_TYPE ]],
            ["    skill", attack_data[ i + W_SKILL ]]
            })
            if ( stringp( attack_data[ i + W_FUNCTION ] ) )
            ret += [[" function", attack_data[ i + W_FUNCTION ]]]
            else
            if ( pointerp( attack_data[ i + W_FUNCTION ] ) )
            ret += ({
            [" function", attack_data[ i + W_FUNCTION ][ 0 ]],
            ["called on", attack_data[ i + W_FUNCTION ][ 1 ]]
            })


    def adjust_charges(self, number: int) -> int:
            charges += number
            if ( number > 0 )
            total_charges += number
            if ( charges < 0 )
            charges = 0
            return charges


    def set_zapper(self, word: str) -> None:
            zapper = word
            asyncio.create_task(self. "zapper_init", 1, self )


    def zapper_init(self, thing: MudObject) -> None:
            if ( !thing )
            return
            zapper.init_artifact( thing )


    def break_on_charging(self, ) -> int:
            int top, chance
            top = 1000 / ( 32 + level )
            if ( total_charges > top )
            chance = 6 * ( total_charges - top ) * ( total_charges - top )
            top = 14 - level / 7
            if ( top < 0 )
            top = 0
            if ( charges > top )
            chance += 3 * ( charges - top ) * ( charges - top )
            chance += 1
            if ( random( 100 ) < chance )
            return 1
            return 0


    def long(self, word: int, dark: int) -> str:
            string a_name, start
            a_name = (string)call_other( zapper, "query_"+ type +"_name" )
            if ( !ARTIFACT_HAND.query_known( (string)this_player()->query_name(),
            a_name ) )
            return ""
            start = "You recognise "+ self.the_short() +" to be "
            if ( a_name[ 0 .. 0 ] == lower_case( a_name[ 0 .. 0 ] ) )
            return start + add_a( a_name ) +".  "
            return start + a_name +".  "


    def init_dynamic_arg(self, map: Any) -> None:
            charges = map[ "charges" ]
            total_charges = map[ "total charges" ]


    def init_static_arg(self, map: Any) -> None:
            if ( map[ "level" ] )
            level = map[ "level" ]
            if ( map[ "zapper" ] )
            zapper = map[ "zapper" ]


    def __init__(self):
            self._difficulty = 5
            self._pick_skill = "covert.lockpick.doors"


    def set_open(self, ) -> None:
            if (!_closed)
            return
            _closed = 0
            _locked = 0
            if (environment()) {
            event( [environment(), TO,], "open", TP)
            } else if (TO.query_my_room()) {
            event( [TO.query_my_room(), TO,], "open", TP)


    def set_closed(self, ) -> None:
            if (_closed)
            return
            _closed = 1
            if (environment()) {
            event( [environment(), TO,], "close", TP)
            } else if (TO.query_my_room()) {
            event( [TO.query_my_room(), TO,], "close", TP)


    def query_closed(self, ) -> int:
            return _closed


    def query_open(self, ) -> int:
            return !_closed


    def set_locked(self, ) -> None:
            if (!_closed)
            return
            if (_locked)
            return
            _locked = 1
            if (environment()) {
            event( [environment(), TO,], "lock", TP)
            } else if (TO.query_my_room()) {
            event( [TO.query_my_room(), TO,], "lock", TP)


    def set_unlocked(self, ) -> None:
            if (!_locked)
            return
            _locked = 0
            if (environment()) {
            event( [environment(), TO,], "unlock", TP)
            } else if (TO.query_my_room()) {
            event( [TO.query_my_room(), TO,], "unlock", TP)


    def query_locked(self, ) -> int:
            return _locked


    def query_unlocked(self, ) -> int:
            return !_locked


    def set_key(self, val: Any) -> None:
            if (!stringp(val) && !functionp(val))
            return
            _key = val


    def query_key(self, ) -> str:
            if (stringp(_key))
            return _key
            if (functionp(_key))
            return evaluate(_key)
            return 0


    def set_pick_skill(self, str: str) -> None:
            _pick_skill = str


    def query_pick_skill(self, ) -> str:
            return _pick_skill


    def set_difficulty(self, i: int) -> None:
            _difficulty = i


    def query_difficulty(self, ) -> int:
            return _difficulty


    def set_stuck(self, i: int) -> None:
            _stuck = i


    def query_stuck(self, ) -> int:
            return _stuck


    def set_transparent(self, ) -> None:
            _trans = C_TRANS


    def reset_transparent(self, ) -> None:
            _trans = 0


    def query_transparent(self, ) -> int:
            return _trans


    def set_open_trap(self, ob: MudObject, func: str) -> None:
            _trap_open_func =  func
            _trap_open_ob = ob


    def query_open_trap_func(self, ) -> str:
            return _trap_open_func


    def query_open_trap_ob(self, ) -> MudObject:
            return _trap_open_ob


    def set_lock_trap(self, ob: MudObject, func: str) -> None:
            _trap_lock_func = func
            _trap_lock_ob = ob


    def query_lock_trap_func(self, ) -> str:
            return _trap_lock_func


    def query_lock_trap_ob(self, ) -> MudObject:
            return _trap_lock_ob


    def query_closed_locked_status(self, ) -> int:
            if (_closed && _locked) {
            return CLOSED_LOCKED


    def add_close_lock_commands(self, player: MudObject) -> None:
            if(!player)
            return
            player->add_command("open", TO,
            "<direct:object:me-here>",
            (: do_open() :) )
            player->add_command("close", TO,
            "<direct:object:me-here>",
            (: do_close() :) )
            if (TO.query_key()) {
            player->add_command("lock", TO,
            "<direct:object:me-here>",
            (: do_lock(0) :) )
            player->add_command("lock", TO,
            "<direct:object:me-here> with <indirect:object:me>",
            (: do_lock($1) :) )
            player->add_command("unlock", TO,
            "<direct:object:me-here>",
            (: do_unlock(0) :) )
            player->add_command("unlock", TO,
            "<direct:object:me-here> with <indirect:object:me>",
            (: do_unlock($1) :) )


    def init(self, ) -> None:
            add_close_lock_commands(this_player())


    def short_status(self, ) -> str:
            return ""


    def long_status(self, ) -> str:
            if (TO.query_stuck())
            return ""
            switch (query_closed_locked_status()) {
            case CLOSED_LOCKED:
            return "It is closed and locked.\n"
            case CLOSED:
            return "It is closed.\n"
            default:
            return "It is open.\n"


    def check_stealth(self, ) -> int:
            mapping hide_invis
            int hiding, sneaking, difficulty, light, my_light, items_blocking
            hide_invis = (mapping) TP.query_hide_invis()
            hiding = undefinedp(hide_invis["hiding"]) ? 0 : 1
            sneaking = TP.query_sneak_level() ? 1 : 0
            if (!hiding && !sneaking)
            return STEALTH_NONE
            my_light = TP.query_light()
            light = environment(TP)->query_light()
            difficulty = light + (4 * my_light) / (light + 1)
            items_blocking = sizeof(CLOTHING_HANDLER.query_items_blocking(TO, TP))
            if (items_blocking) {
            difficulty += 50 * items_blocking


    def do_unlock(self, keys: MudObject) -> int:
            object *gkeys = [})
            string key = TO.query_key()
            int inv = 0
            if (!_locked) {
            TP->add_failed_mess(TO,
            "$D $V$0=isn't,aren't$V$ locked.\n",
            [}) )
            return 0


    def do_lock(self, keys: MudObject) -> int:
            object *gkeys = [})
            string key = TO.query_key()
            int inv = 0
            if (_locked) {
            TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ already locked.\n",
            [}) )
            return 0


    def pick_lock(self, player: MudObject) -> int:
            if (_trap_lock_ob
            && !_trap_lock_ob, _trap_lock_func.pick(TO, player)) {
            return 0


    def pick_unlock(self, player: MudObject) -> int:
            if (_trap_lock_ob
            && !_trap_lock_ob, _trap_lock_func.pick(TO, player)) {
            return 0


    def do_open(self, ) -> int:
            if (!_closed) {
            TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ already open.\n",
            [}) )
            return 0


    def do_close(self, ) -> int:
            if (_closed) {
            TP->add_failed_mess(TO,
            "$D $V$0=is,are$V$ already closed.\n",
            [}) )
            return 0


    def set_closed(self, ) -> None:
            ::set_closed()
            if (environment()) {
            environment()->remove_inventory_container(self)


    def reset_closed(self, ) -> None:
            ::set_closed()
            if (environment()) {
            environment()->add_inventory_container(self)


    def we_moved(self, from: MudObject, to: MudObject) -> None:
            if (!query_closed()) {
            if (from) {
            from.remove_inventory_container(self)


    def dest_me(self, ) -> None:
            if (environment()) {
            environment()->remove_inventory_container(self)


    def discussion_item_list(self, player: str) -> str:
            class discussion_idea* ideas
            class discussion_idea bing
            string ret
            int no
            ideas = CLUB_HANDLER.query_all_discussion_items(query_club())
            ret = ""
            no = 0
            if (sizeof(ideas)) {
            foreach (bing in ideas) {
            if (CLUB_HANDLER.is_discussion_item_finished(query_club(),
            bing->id)) {
            CLUB_HANDLER.complete_discussion_item(query_club(),
            bing->id)
            } else {
            if (CLUB_HANDLER.can_reference_discussion_item(query_club(),
            bing->id,
            player)) {
            ret += bing->id + ") " +
            CLUB_HANDLER.query_discussion_item_short_description(query_club(),
            bing->id)
            if (CLUB_HANDLER.is_discussion_item_quorum(query_club(),
            bing->id)) {
            ret += " (quorum)"


    def do_list_all(self, ) -> int:
            string ret
            ret = discussion_item_list(this_player()->query_name())
            write("$P$Faernussion items$P$" + ret)
            return 1


    def do_list_item(self, id: int) -> int:
            string ret
            if (!CLUB_HANDLER.query_discussion_item(query_club(), id) ||
            !CLUB_HANDLER.can_reference_discussion_item(query_club(),
            id,
            this_player()->query_name())) {
            add_failed_mess("There is no discussion item #" + id + ".\n")
            return 0


    def do_nominate(self, id: int, person: str) -> int:
            if (!CLUB_HANDLER.query_discussion_item(query_club(), id) ||
            !CLUB_HANDLER.can_reference_discussion_item(query_club(),
            id,
            this_player()->query_name())) {
            add_failed_mess("There is no discussion item #" + id + ".\n")
            return 0


    def do_withdraw(self, id: int) -> int:
            if (!CLUB_HANDLER.query_discussion_item(query_club(), id) ||
            !CLUB_HANDLER.can_reference_discussion_item(query_club(),
            id,
            this_player()->query_name())) {
            add_failed_mess("There is no discussion item #" + id + ".\n")
            return 0


    def do_list_archives(self, ) -> int:
            class club_archive* archives
            string bing
            class club_archive fluff
            int num
            archives = CLUB_HANDLER.query_archives(query_club())
            if (!sizeof(archives)) {
            add_failed_mess("This club has no archives currently.\n")
            return 0


    def do_archive(self, num: int) -> int:
            string bing
            class club_archive fluff
            class club_archive* archives
            archives = CLUB_HANDLER.query_archives(query_club())
            if (!sizeof(archives)) {
            add_failed_mess("This club has no archives currently.\n")
            return 0


    def init_dynamic_arg(self, map: Any) -> None:
            _last_time = map[SAVE_START + "last time"]


    def query_club(self, ) -> str:
            private void add_broadcaster() {
            if (query_club()) {
            BROADCASTER.add_object_to_channel(lower_case(query_club()),
            self)


    def set_club(self, club: str) -> None:
            if (_club) {
            BROADCASTER.remove_object_from_channel(lower_case(_club),
            self)


    def query_club(self, ) -> str:
            return _club


    def init(self, ) -> None:
            if (query_club() &&
            this_player() == environment() &&
            CLUB_HANDLER.is_member_of(query_club(), this_player()->query_name())) {
            this_player()->add_player_club(query_club())
            add_club_commands(this_player())
            } else {
            this_player()->remove_player_club(query_club())


    def query_channel_off(self, ) -> int:
            return _channel_off


    def query_brief_mode(self, ) -> int:
            return _brief_mode


    def query_brief_string(self, ) -> str:
            return _brief_string


    def event_channel_message(self, ob: MudObject, channel: str, data: Any) -> None:
            object our_player
            int emote
            string message
            string player_name
            string channel_name
            string colour
            if (channel != lower_case(query_club())) {
            return


    def init_dynamic_arg(self, map: Any) -> None:
            string fluff
            set_club(map[SAVE_START + "club"])
            _channel_off = map[SAVE_START + "channel off"]
            _last_state = map[SAVE_START + "last state"]
            _last_club_time = map[SAVE_START + "last time"]
            _brief_mode = map[SAVE_START + "brief mode"]
            _brief_string = map[SAVE_START + "brief string"]
            if (query_club()) {
            fluff = CLUB_HANDLER.query_club_name(query_club())


    def event_joined_club(self, person: MudObject, club_name: str) -> None:
            if (CLUB_HANDLER.query_club_name(query_club()) ==
            CLUB_HANDLER.query_club_name(club_name)) {
            add_club_commands(environment())


    def player_relationships_string(self, player: str) -> str:
            string family
            string ret
            string region
            class relationship_data *wombles
            int gender
            int i
            family = PLAYER_HANDLER.test_family(player)
            if (!family) {
            return ""


    def __init__(self):
            self.max_cond = 1


    def break_me(self, ) -> None:
            if(environment(self)) {
            if(living(environment(self)))
            tell_object(environment(self),
            capitalize(self.the_short()) + " shatters under Mystras gaze!\n")
            else
            tell_room(environment(self),
            capitalize(self.the_short()) + " shatters under Mystras gaze!\n")


    def cond_string(self, ) -> str:
            string pronoun
            string verb
            if ( cond > max_cond ) {
            cond = max_cond


    def set_cond(self, i: int) -> None:
            cond = i
            if (cond < 0) {
            cond = 0


    def adjust_cond(self, i: int) -> int:
            cond += i
            if (cond < 0)
            cond = 0
            if ( cond < lowest_cond )
            lowest_cond = cond
            if ( cond > max_cond )
            cond = max_cond
            if ( cond <= 0 ) {
            if ( !environment()->query_property( "don't break contents" ) )
            self.break_me()
            return 0


    def query_cond(self, ) -> int:
            if ( cond > max_cond ) {
            cond = max_cond


    def set_percentage(self, i: int) -> None:
            if (i > 100) {
            i = 100


    async def do_damage(self, type: str, amount: int) -> None:
            int wholes, parts
        # 2025 enchantment resistance
        if hasattr(self, 'attrs') and self.attrs.get('enchantment', 0) > 0:
            amount = max(0, amount - self.attrs['enchantment'])
            wholes = amount * ( 1 + random( damage_chance ) + random( damage_chance ) )
        # 2025 enchantment resistance
        if hasattr(self, 'attrs') and self.attrs.get('enchantment', 0) > 0:
            amount = max(0, amount - self.attrs['enchantment'])
            parts = wholes % DAMAGE_NORM
        # 2025 enchantment resistance
        if hasattr(self, 'attrs') and self.attrs.get('enchantment', 0) > 0:
            amount = max(0, amount - self.attrs['enchantment'])
            wholes /= DAMAGE_NORM
        # 2025 enchantment resistance
        if hasattr(self, 'attrs') and self.attrs.get('enchantment', 0) > 0:
            amount = max(0, amount - self.attrs['enchantment'])
            if ( random( DAMAGE_NORM ) < parts )
        # 2025 enchantment resistance
        if hasattr(self, 'attrs') and self.attrs.get('enchantment', 0) > 0:
            amount = max(0, amount - self.attrs['enchantment'])
            wholes++
        # 2025 enchantment resistance
        if hasattr(self, 'attrs') and self.attrs.get('enchantment', 0) > 0:
            amount = max(0, amount - self.attrs['enchantment'])
            adjust_cond( -wholes )
        # 2025 enchantment resistance
        if hasattr(self, 'attrs') and self.attrs.get('enchantment', 0) > 0:
            amount = max(0, amount - self.attrs['enchantment'])


    def init_static_arg(self, map: Any) -> None:
            if ( !undefinedp( map[ "max cond" ] ) )
            max_cond = map[ "max cond" ]
            if ( !undefinedp( map[ "damage chance" ] ) )
            damage_chance = map[ "damage chance" ]
            if ( !undefinedp( map[ "hide cond" ] ) )
            hide_cond = map[ "hide cond" ]


    def init_dynamic_arg(self, map: Any, object) -> None:
            if ( !undefinedp( map[ "cond" ] ) )
            cond = map[ "cond" ]
            if ( !undefinedp( map[ "lowest cond" ] ) )
            lowest_cond = map[ "lowest cond" ]


    def set_god(self, deity: str) -> None:
            if ( stringp( deity ) )
            deity = lower_case( deity )
            _god =  deity
            return


    def set_deity(self, deity: str) -> None:
            if ( stringp( deity ) )
            deity = lower_case( deity )
            _god = deity
            return


    def query_consecrated(self, god: str) -> int:
            if ( !stringp( god ) )
            return 0
            god = lower_case( god )
            if ( _god )
            return god == _god
            return self.query_property( god )


    def init_static_arg(self, map: Any) -> None:
            if ( !undefinedp( map[ "god" ] ) )
            _god = map[ "god" ]


    def there_check(self, ob): MudObject) -> Any:
            varargs string query_contents( string start, object *things,
            int ignore_living) {
            object *livings = [}), *non_livings = [})
            mixed *bits
            string return_string = ""
            int partys
            if( undefinedp( ignore_living ) )
            ignore_living = ignore_livings_in_inventory()
            if ( stringp( start ) ) return_string = start
            if ( !arrayp( things ) ) {
            things = self.find_inv_match( "", this_player() )
            things -= [this_player()]
            things = filter_array( things, "env_check", self)


    def process_non_living(self, non_livings: MudObject, start: int) -> str:
            mapping positions
            string position
            object *items, item, *bulk
            string here
            string *room_items
            int i
            if(!sizeof(non_livings))
            return ""
            here = self.query_property( "here" )
            if (!here)
            return query_multiple_short( non_livings ) + ".\n"
            positions = unique_mapping( non_livings, "there_check", self)
            if ( positions[ 0 ] ) {
            positions[ here ] = positions[ 0 ]
            map_delete( positions, 0 )


    def query_last(self, ) -> int:
            log_file( "CUTELAST", "(%s) %s called query_last.\n",
            ctime( time() ), file_name( self ) )
            return 0


    def adjust_last(self, wibble: int) -> None:
            log_file( "CUTELAST", "(%s) %s called adjust_last.\n",
            ctime( time() ), file_name( self ) )
            return


    def set_ignore_livings_in_inventory(self, ignore: int) -> None:
            _ignore_livings = !!ignore


    def set_short(self, words: Any) -> None:
            if (functionp(words)) {
            if (!short_d)
            plural_d = (: pluralize(evaluate(short_d)) :)
            } else {
            if ( !short_d && words && ( words != "" ) )
            plural_d = pluralize( words )


    def query_short(self, ) -> Any:
            if ( functionp( short_d ) )  {
            return evaluate(short_d)


    def query_short_desc(self, ) -> str:
            string tmp
            if(!short_desc) {
            short_desc = ""
            if(self.query_str() > 16)
            short_desc += "strapping "
            else if(self.query_dex() > 16)
            short_desc += "nimble "
            else if(self.query_int() > 16)
            short_desc += "studious "
            else if(self.query_wis() > 16)
            short_desc += "pious "
            short_desc += "young "
            switch(self.query_class_ob()) {
            case "/std/classs/warrior":
            short_desc += (self.query_gender() == 2? "female " : "male ") +
            "warrior"
            break
            case "/std/classs/thief":
            tmp = "/std/classs/thief"->query_class_data()
            if(tmp)
            short_desc += (self.query_gender() == 2? "female ": "male ")+
            tmp
            else
            short_desc += (self.query_gender() == 2? "female ": "male ")+
            "thief"
            break
            case "/std/classs/wizard":
            short_desc += (self.query_gender() == 2? "female " : "male ") +
            "wizard"
            break
            case "/std/classs/witch":
            short_desc += "witch"
            break
            case "/std/classs/assassin":
            short_desc += (self.query_gender() == 2? "female " : "male ") +
            "assassin"
            break
            default:
            short_desc += (self.query_gender() == 2? "lass" : "lad")


    def query_plural_desc(self, ) -> str:
            return pluralize( query_short_desc() )


    def query_long_details(self, arg: str, dark: int, looker: MudObject) -> str:
            return 0


    def long(self, str: str, dark: int) -> str:
            if (!long_d)
            return "You see nothing particularly interesting.\n"
            if (functionp(long_d))
            return (string)evaluate(long_d)
            return long_d


    def query_determinate(self, thing: MudObject) -> str:
            if(query_visible(thing)) {
            #ifdef USE_ROLE_PLAYING_SHORTS
            if(interactive(self) &&
            thing.query_role_playing() &&
            !thing.is_friend(self->query_name()))
            return "a "
            #endif
            return (string)self.query_property( "determinate" )


    def query_logging_effects(self, ) -> int:
            #endif
            class effect_data {
            int current_enum
            int next_id
            int next_event_time
            class effect_shadow* shadows


    def __init__(self):
            self.effs = []
            self.eeq = []
            self._data = new(class effect_data)
            self._data->shadows = []
            self._data->next_id = 0
            self._data->current_enum = -1
            self._data->next_event_time = 0
            self.logging_effects = 0


    def reset_effects(self, ) -> None:
            effs = [})
            eeq = [})
            _data->shadows = [})
            _data->current_enum = -1
            _data->next_event_time = 0
            remove_asyncio.create_task(self."effect_timer")
            #ifdef DEBUG
            if ( logging_effects )
            log_file( "EFFECT_WOBBLE",
            "%d:%s(%d) reset_effects:remove_asyncio.create_task(self. \"effect_timer\" )\n",
            time() % 1000,
            self.query_name(),
            _data->current_enum)
            #endif


    def affected_object(self, ) -> MudObject:
            object this, other
            other = self
            this = other
            while (objectp(other)) {
            this = other
            other = query_shadowing(this)


    def effect_freeze(self, ) -> None:
            remove_asyncio.create_task(self. "effect_timer" )
            #ifdef DEBUG
            if ( logging_effects )
            log_file( "EFFECT_WOBBLE",
            "%d:%s(%d) effect_freeze:remove_asyncio.create_task(self. \"effect_timer\" )=%d\n",
            time() % 1000,self.query_name(),_data->current_enum,timeleft)
            #endif
            if ( sizeof( eeq ) && _data->next_event_time) {
            if (_data->next_event_time <= time()) {
            eeq[ 0 ]->inctime = 1
            } else {
            eeq[ 0 ]->inctime = _data->next_event_time - time()


    def effects_saving(self, ) -> None:
            int i, neffs
            string effn
            mixed arg
            neffs = sizeof( effs )
            for ( i = 0; i < neffs; i++ ) {
            effn = effs[ i ]->ob_name
            arg = effs[ i ]->arg
            if ( pointerp( arg ) && ( sizeof( arg ) == 3 ) &&
            ( arg[ 2 ] == BOGUS_OLD_ARG ) ) {
            arg = arg[ 1 ]


    def effects_quiting(self, ) -> None:
            int i, neffs
            string effn
            mixed arg
            neffs = sizeof( effs )
            for ( i = 0; i < neffs; i++ ) {
            effn = effs[ i ]->ob_name
            arg = effs[ i ]->arg
            if ( pointerp( arg ) && ( sizeof( arg ) == 3 ) &&
            ( arg[ 2 ] == BOGUS_OLD_ARG ) ) {
            arg = arg[ 1 ]


    def effects_desting(self, ) -> None:
            int i, neffs
            string effn
            mixed arg
            neffs = sizeof( effs )
            for ( i = 0; i < neffs; i++ ) {
            effn = effs[ i ]->ob_name
            arg = effs[ i ]->arg
            if ( pointerp( arg ) && ( sizeof( arg ) == 3 ) &&
            ( arg[ 2 ] == BOGUS_OLD_ARG ) ) {
            arg = arg[ 1 ]


    def effect_unfreeze(self, ) -> None:
            if ( sizeof( eeq ) ) {
            #ifdef DEBUG
            if ( logging_effects )
            log_file( "EFFECT_WOBBLE",
            "%d:%s(%d) effect_unfreeze:asyncio.create_task(self. \"effect_timer\", %d)\n",
            time() % 1000,self.query_name(),_data->current_enum,eeq[ 0 ]->inctime)
            #endif
            remove_asyncio.create_task(self. "effect_timer" )
            _data->next_event_time = time() + eeq[ 0 ]->inctime
            asyncio.create_task(self. "effect_timer", eeq[ 0 ]->inctime )


    def expected_tt(self, flag: int, new_enum: int) -> int:
            int i, timeleft, enum
            if (flag)
            enum = new_enum
            else
            enum = _data->current_enum
            if (enum < 0)
            return -1
            if (!sizeof(eeq))
            return -1
            effect_freeze()
            for (i = 0; i < sizeof(eeq); i++) {
            timeleft += eeq[i]->inctime
            if ((eeq[i]->eff_ob_num == enum) &&
            (eeq[i]->flags == EE_REMOVE)) {
            effect_unfreeze()
            return timeleft


    def add_effect(self, eff: str, arg: Any) -> None:
            string shad
            object ob, effob
            mixed hbf, res
            int i
            int old_current_enum
            int enum
            #ifdef DEBUG
            if ( logging_effects )
            log_file( "EFFECT_WOBBLE",
            "%d:%s(%d) add_effect:(%s,%O)\n",
            time() % 1000,self.query_name(),current_enum,eff,arg)
            #endif
            hbf = (mixed)eff.query_secs_between_hb()
            if (!hbf) {
            hbf = (mixed) eff.query_heart_beat_frequency()
            if (hbf) {
            if (intp(hbf)) hbf *= 60


    def init_after_save(self, ) -> None:
            int i
            int neffs
            string shad
            string effn
            object ob
            mixed arg
            int *ee_exists
            convert_arrays()
            for( i = 0; i < sizeof( eeq ); i++ ) {
            if( classp( eeq[i] ) && sizeof( eeq[i] ) < 6 ) {
            eeq[i] = new( class effect_event,
            inctime : eeq[i]->inctime ,
            func : eeq[i]->func ,
            eff_ob_num : eeq[i]->eff_ob_num ,
            interval : eeq[i]->interval ,
            flags : eeq[i]->flags ,
            eff_ev_args : 0 )


    def delete_effect(self, i: int) -> None:
            int id, j
            object effect_object, shadow_object
            string effect_file
            mixed arg
            #ifdef DEBUG
            if ( logging_effects )
            log_file( "EFFECT_WOBBLE",
            "%d:%s(%d) delete_effect:(%d) sizeof(eeq)=%d\n",time() % 1000,
            self.query_name(),current_enum,i, sizeof(eeq))
            #endif
            if ((i < 0) || (i >= sizeof( effs ))) {
            return


    def sid_to_enum(self, sid: int) -> int:
            return member_array(1,
            map(_data->shadows, (: classp($1) &&
            ((class effect_shadow)$1)->idnum == $(sid) :)))


    def enum_to_sid(self, enum: int) -> int:
            return _data->shadows[enum]->idnum


    def eff_of(self, enum: int) -> str:
            return effs[enum]->ob_name


    def arg_of(self, enum: int) -> Any:
            mixed arg
            if (sizeof(effs) <= enum)
            return 0
            arg = effs[enum]->arg
            if (arrayp(arg) && sizeof(arg) == 3)
            if (arg[2] == BOGUS_OLD_ARG)
            return copy(arg[1])
            return copy(arg)


    def set_arg_of(self, enum: int, newarg: Any) -> None:
            effs[enum]->arg = newarg


    def effect_timer(self, ) -> None:
            int enum
            object effect_object
            mixed res, last_flags
            class effect_event thisee
            #ifdef DEBUG
            if ( logging_effects )
            log_file( "EFFECT_WOBBLE",
            "%d:%s(%d) effect_timer:() sizeof(eeq)=%d\n",time() % 1000,
            self.query_name(),current_enum,sizeof(eeq))
            #endif
            _data->next_event_time = 0
            if (!sizeof(eeq)) {
            return


    def effects_thru_death(self, ) -> None:
            int i
            int id
            object ob
            i = sizeof( effs )
            while ( i-- ) {
            id = _data->shadows[i]->idnum
            if ( catch( ob = load_object(effs[i]->ob_name)) || !ob ||
            !ob.survive_death( affected_object(), effs[i]->arg, id) ) {
            delete_effect(i)


    def query_current_effect_enum(self, ) -> int:
            return _data->current_enum


    def query_max_enchant(self, ) -> int:
            {
            return 5 + (int) self.query_weight() / 4


    def query_degrade_enchant(self, ) -> int:
            if (!_degrade_enchant) {
            return self.query_max_enchant() / 2


    def set_degrade_enchant(self, enchant: int) -> None:
            if (enchant > self.query_max_enchant()) {
            enchant = self.query_max_enchant()


    def enchant_string(self, ) -> str:
            {
            string tal_msg
            string ench_msg
            if (self.query_property("talisman")) {
            tal_msg = (string) self.query_property("talisman_mess")
            if (!tal_msg)
            tal_msg = "It has the hazy octarine sparkle of a magical talisman."
            tal_msg += "\n"
            } else {
            tal_msg = ""


    def set_enchant(self, number: int) -> None:
            {
            if (number > self.query_max_enchant()) {
            number = self.query_max_enchant()


    def add_enchant(self, number: int) -> int:
            {
            set_enchant(self.query_enchant() + number)
            return _enchanted


    def query_enchant(self, ) -> int:
            {
            int max
            int tmp
            int tmp2
            int degrade
            max = self.query_max_enchant()
            if (_enchanted > max) {
            _enchanted = max


    def query_real_enchant(self, ) -> int:
            {
            return _enchanted


    def query_enchant_set_time(self, ) -> int:
            {
            return _set_enchant_time


    def __init__(self):
            self.registered_containers = []


    def add_inventory_container(self, cont: MudObject) -> None:
            if (registered_containers.index(cont) if cont in registered_containers else -1 == -1 &&
            environment(cont) == self) {
            registered_containers += [cont]


    def remove_inventory_container(self, cont: MudObject) -> None:
            if(!registered_containers || !cont)
            return
            registered_containers -= [cont]


    def set_can_export_inventory(self, ) -> None:
            can_export_inventory = 1


    def reset_can_export_inventory(self, ) -> None:
            can_export_inventory = 0


    def query_can_export_inventory(self, ) -> int:
            return can_export_inventory


    def __init__(self):
            self._variables = ([ ])
            self._functions = ([ ])
            self._user_functions = ([ ])


    def __init__(self):
            self._variables = ([ ])
            self._functions = ([ ])
            self._user_functions = ([ ])
            _func_variables = ([ ])
            _error_string = "no error"
            add_allowed_function("sizeof", EXPRESSION_TYPE_INTEGER,
            [EXPRESSION_TYPE_ARRAY], (: sizeof_function :) )


    def query_last_expression_error(self, ) -> str:
            return _error_string


    def query_last_expression_warning(self, ) -> str:
            return _warning_string


    def add_allowed_variable(self, name: str, type: int, value: Any) -> None:
            class variable_thing bing
            bing = new(class variable_thing)
            bing->type = type
            bing->value = value
            _variables[name] = bing


    def add_allowed_function(self, name: str, type: int, args: Any, value: Any) -> None:
            class function_thing bing
            bing = new(class function_thing)
            bing->type = type
            bing->args = args
            bing->value = value
            _functions[name] = bing


    def query_function_variable_type(self, name: str) -> int:
            if (_func_variables[name]) {
            return ((class func_variable_thing)_func_variables[name])->type


    def query_function_variable_position(self, name: str) -> int:
            if (_func_variables[name]) {
            return ((class func_variable_thing)_func_variables[name])->arg_no


    def query_variable_type(self, name: str) -> int:
            if (_variables[name]) {
            return ((class variable_thing)_variables[name])->type


    def query_function_args_types(self, name: str) -> List[int]:
            if (_functions[name]) {
            return ((class function_thing)_functions[name])->args


    def query_function_type(self, name: str) -> int:
            if (_functions[name]) {
            return ((class function_thing)_functions[name])->type


    def query_user_function_return_type(self, name: str) -> int:
            if (_user_functions[name]) {
            return ((class user_function_thing)_user_functions[name])->type


    def remove_user_expression(self, name: str) -> int:
            if (_user_functions[name]) {
            map_delete(_user_functions, name)
            return 1


    def query_type_value(self, type: str) -> int:
            switch (lower_case(type)) {
            case "integer" :
            case "int"     :
            return EXPRESSION_TYPE_INTEGER
            case "string"  :
            return EXPRESSION_TYPE_STRING
            case "float"   :
            return EXPRESSION_TYPE_FLOAT
            case "boolean" :
            case "bool"    :
            return EXPRESSION_TYPE_BOOLEAN
            case "money" :
            return EXPRESSION_TYPE_MONEY
            case "object" :
            return EXPRESSION_TYPE_OBJECT
            case "array" :
            return EXPRESSION_TYPE_ARRAY
            default :
            return EXPRESSION_TYPE_ERROR


    def query_type_name(self, type: int) -> str:
            if (is_array_type(type)) {
            return "array " + query_type_name(type - EXPRESSION_TYPE_ARRAY_OFFSET)


    def query_operator_name(self, operator: int) -> str:
            switch (operator) {
            case EXPRESSION_AND_NEW   :
            case EXPRESSION_AND       :
            return "and"
            case EXPRESSION_OR_NEW    :
            case EXPRESSION_OR        :
            return "or"
            case EXPRESSION_NOT       :
            return "not"
            case EXPRESSION_FALSE     :
            return "false"
            case EXPRESSION_TRUE      :
            return "true"
            case EXPRESSION_GREATOR_THAN     :
            return ">"
            case EXPRESSION_LESS_THAN        :
            return "<"
            case EXPRESSION_EQUAL_TO         :
            return "="
            case EXPRESSION_NOT_EQUAL_TO         :
            return "<>"
            case EXPRESSION_GREATOR_OR_EQUAL :
            return ">="
            case EXPRESSION_LESS_OR_EQUAL    :
            return "<="
            case EXPRESSION_PLUS             :
            return "+"
            case EXPRESSION_MINUS            :
            return "-"
            case EXPRESSION_MULTIPLY         :
            return "*"
            case EXPRESSION_DIVIDE           :
            return "/"
            case EXPRESSION_IF               :
            return "if"
            default :
            return "unknown"


    def sizeof_function(self, arr: Any, args: Any) -> int:
            return sizeof(arr)


    def query_expression_string(self, parse_node: Any, brief: int) -> str:
            string str
            int i
            string* stack
            int* thing
            string tmp
            string place
            int value
            string indent
            if (!sizeof(expr)) {
            return "No expression set."


    def query_user_function_string(self, func: str) -> str:
            class user_function_thing thing
            int i
            string ret
            thing = _user_functions[func]
            ret = ""
            ret += query_type_name(thing->type) + " " + func + "("
            for (i = 0; i < sizeof(thing->arg_types); i++) {
            ret += query_type_name(thing->arg_types[i]) + " " + thing->arg_names[i]
            if (i < sizeof(thing->arg_types) - 1) {
            ret += ", "


    def __init__(self):
            self.extra_looks = []


    def calc_extra_look(self, ) -> str:
            int i
            string s1, s2
            s1 = ""
            if (!extra_looks) {
            extra_looks = [})


    def add_extra_look(self, ob: MudObject) -> None:
            if(extra_looks.index(ob) if ob in extra_looks else -1 != -1) {
            return


    def remove_extra_look(self, ob: MudObject) -> None:
            int i
            i = extra_looks.index(ob) if ob in extra_looks else -1
            if (i < 0) {
            return


    def add_help_file(self, help_file: str) -> None:
            string* help
            help = query_property(ROOM_HELP_FILE_PROPERTY)
            if (help) {
            if (help.index(help_file) if help_file in help else -1 == -1) {
            help += [help_file]


    def remove_help_file(self, help_file: str) -> None:
            string* help
            help = query_property(ROOM_HELP_FILE_PROPERTY)
            if (help) {
            help -= [help_file]
            add_property(ROOM_HELP_FILE_PROPERTY, help)


    def query_help_files(self, ) -> str:
            return query_property(ROOM_HELP_FILE_PROPERTY)


    def query_help_file_directory(self, ) -> str:
            return "/doc/unknown/"


    def help_string(self, ) -> str:
            string *help
            string str
            string bing
            help = query_property(ROOM_HELP_FILE_PROPERTY)
            if (sizeof(help)) {
            str = ""
            foreach (bing in help) {
            str += nroff_file(bing, 0)


    def __init__(self):
            self._hide_invis = ([])


    def add_hide_invis(self, type: str, who: MudObject, see: Any, gone: str) -> int:
            if( _hide_invis[type] ) {
            return 0


    def perception_check(self, thing: MudObject) -> int:
            int perception
            perception = thing.query_skill_bonus( SKILL )
            if( !environment( thing ) || !perception )
            return perception
            switch( thing.check_dark( (int)environment( thing )->query_light() ) ) {
            case -2:
            case 2:
            perception /= 4
            break
            case -1:
            case 1:
            perception /= 2
            break
            default:
            break


    def query_visible(self, thing: MudObject) -> int:
            int i
            string *types
            mixed see
            if( thing == self ) {
            return 1


    def hide_invis_string(self, ) -> str:
            int i
            string list
            string *types
            types = keys( _hide_invis )
            if( !sizeof( types ) ) {
            return ""


    def __init__(self):
            self._no_limbs = 1


    def query_static_auto_load(self, ) -> Any:
            return ([ "no limbs" : _no_limbs
            ])


    def init_static_arg(self, arg: Any) -> None:
            if (!arg) {
            return


    def query_dynamic_auto_load(self, ) -> Any:
            return ([ "limb"       : (_holder ? _my_limb : -1),
            "limbs used" : (_holder ?
            sizeof(find_member(self,
            _holder.query_holding())) : 0)
            ])


    def init_dynamic_arg(self, arg: Any, new_arg: Any) -> None:
            if (!arg) {
            return


    def held_this_item(self, held: int, holder: MudObject, arg: Any) -> int:
            return 1


    def set_holder(self, ob: MudObject, limb: int) -> int:
            if (ob && environment() != ob) {
            return 0


    def set_no_limbs(self, num: int) -> None:
            if (num < 0) {
            return


    def move(self, ob: Any) -> int:
            if ( ob != _holder && _holder ) {
            if ( !sizeof( _holder.set_unhold( self ) ) ) {
            return MOVE_NO_UNHOLD


    def dest_me(self, ) -> None:
            if (_holder) {
            _holder.set_unhold(self)


    def faux_id_allowed(self, ) -> int:
            private void setup_id_class() {
            if (_id) {
            return


    def set_name(self, str: str) -> None:
            _id->name = str


    def query_name(self, ) -> str:
            if (!_id) {
            return 0


    def query_cap_name(self, ) -> str:
            if (!_id->name) {
            return "Someone"


    def __init__(self):


    def set_aliases(self, str: str) -> None:
            _id->alias = str


    def add_alias(self, str: Any) -> None:
            if (pointerp(str)) {
            _id->alias += str
            return


    def remove_alias(self, str: str) -> int:
            int i
            i = _id->alias.index(str) if str in _id->alias else -1
            if (i == -1) {
            return 0


    def add_faux_alias(self, str: Any) -> None:
            if (pointerp(str)) {
            foreach( string aka in str )
            add_faux_alias( aka )
            return


    def remove_faux_alias(self, str: str) -> int:
            int i
            i = _id->faux_alias.index(str) if str in _id->faux_alias else -1
            if (i == -1) {
            return 0


    def faux_id_allowed(self, ) -> int:
            foreach( object ob in previous_object(-1) ) {
            if( objectp(ob) && ob.ignore_identifier() )
            return 0


    def id(self, str: str) -> int:
            return (str == _id->name ||
            (query_alias(.index(str) if str in query_alias( else -1) != -1) )


    def full_id(self, str: str) -> int:
            string *words
            string name
            string adjective
            words = explode(str, " ") - [""]
            name = words[<1]
            words = words[0.. < 2]
            if (!id(name)) {
            if (!id_plural(name)) {
            return 0


    def set_plurals(self, str: str) -> None:
            _id->plurals = str


    def add_plural(self, str: Any) -> None:
            if (pointerp(str)) {
            _id->plurals += str
            } else if (_id->plurals) {
            if (_id->plurals.index(str) if str in _id->plurals else -1 == -1) {
            _id->plurals += [str]


    def remove_plural(self, str: str) -> None:
            int i
            i = _id->plurals.index(str) if str in _id->plurals else -1
            if (i != -1) {
            _id->plurals = _id->plurals[0..i - 1] + _id->plurals[i + 1..]


    def add_plurals(self, str: str) -> None:
            _id->plurals += str


    def id_plural(self, str: str) -> int:
            return (_id->plurals.index(str) if str in _id->plurals else -1 != -1)


    def set_adjectives(self, str: str) -> None:
            _id->adjectives = str


    def add_adjective(self, str: Any) -> None:
            int i
            if (pointerp(str)) {
            for (i = 0; i < sizeof(str); i++) {
            add_adjective(str[i])


    def remove_adjective(self, str: Any) -> None:
            int i
            if (pointerp(str)) {
            for (i = 0; i < sizeof(str); i++) {
            remove_adjective(str[i])


    def add_faux_adjective(self, str: Any) -> None:
            if (pointerp(str)) {
            foreach( string adj in str )
            add_faux_adjective( adj )
            return


    def remove_faux_adjective(self, str: Any) -> None:
            int i
            if (pointerp(str)) {
            foreach( string adj in str )
            remove_faux_adjective( adj )
            return


    def id_adjective(self, word: str) -> int:
            return (query_adjectives(.index(word) if word in query_adjectives( else -1) != -1)


    def set_plural_adjectives(self, str: str) -> None:
            _id->plural_adjectives = str


    def add_plural_adjective(self, str: Any) -> None:
            int i
            if (pointerp(str)) {
            for (i = 0; i < sizeof(str); i++) {
            add_plural_adjective(str[i])


    def remove_plural_adjective(self, str: Any) -> None:
            int i
            if (pointerp(str)) {
            for (i = 0; i < sizeof(str); i++) {
            remove_plural_adjective(str[i])


    def id_plural_adjective(self, word: str) -> int:
            return (_id->plural_adjectives.index(word) if word in _id->plural_adjectives else -1 != -1)


    def query_parse_id(self, arr: Any) -> MudObject:
            if (arr[P_THING] == 0) {
            return self


    def query_frac_parse_id(self, arr: Any) -> MudObject:
            if (arr[P_THING] < 0) {
            arr[P_THING]++
            if (arr[P_THING] != 0) {
            return 0


    def query_no_all(self, ) -> int:
            return _no_all


    def init(self, ) -> None:
            check_chat()


    def item_chat(self, args: Any) -> None:
            if ( !args || sizeof(args) < 3 || !sizeof(args[2]) ){
            write( "Incorrect args to item_chat.\n" )
            return


    def chat_on(self, ) -> None:
            _off = 0
            check_chat()


    def chat_off(self, ) -> None:
            _off = 1


    def make_chat(self, ) -> None:
            int saying
            string stuff
            object env, *targets
            _already_added = 0
            if( !(env = environment()) || _off )
            return
            saying = random( sizeof(_chats[ 2 ]) )
            if( saying == _chats[ 3 ] )
            saying = ( saying + 1 ) % sizeof( _chats[ 2 ] )
            _chats[ 3 ] = saying
            stuff = _chats[ 2 ][ saying ]
            if( env.query_is_room() ||
            ( interactive(env) && (env = environment(env)) && env.query_is_room() ) ){
            targets = filter( all_inventory(env), (: interactive($1) :) )
            if( !sizeof(targets) )
            return
            if( stuff[0..0] == "#" )
            call_other( self, stuff[ 1 .. ] )
            else
            tell_room( env, stuff + "\n" )
            _already_added = 1
            ROOM_HANDLER->add_chatter( self, _chats[ 0 ] +
            random( _chats[ 1 ] - _chats[ 0 ] + 1 ) )


    def check_chat(self, ) -> None:
            if( !_off && !_already_added && arrayp(_chats) && environment() ){
            if( interactive(environment()) ||
            ( environment(environment()) &&
            interactive(environment(environment()))
            )
            ){
            _already_added = 1
            ROOM_HANDLER->add_chatter( self,
            ( _chats[ 0 ] + random( _chats[ 1 ] - _chats[ 0 ] + 1 ) ) / 2 )


    def fix_saved_chat(self, chat: str) -> str:
            string old_ob
            if( !chat )
            return 0
            sscanf( chat, "%*s$%*s_short:%s$%*s", old_ob )
            if( old_ob )
            chat = replace( chat, old_ob, file_name(self) )
            return chat


    def init_dynamic_arg(self, map: Any) -> None:
            mixed info
            if( !map )
            return
            if( (info = map["_chats"]) && arrayp(info) && sizeof(info) > 2 ){
            info[2] = map( info[2], "fix_saved_chat", self )
            item_chat( info )


    def __init__(self):
            self._inform_of_change = []


    def query_light(self, ) -> int:
            if (_need_recalculate) {
            _need_recalculate = 0
            new_recalc_light()


    def query_light_needs_inform(self, ) -> int:
            return _light || _need_recalculate


    def query_my_light(self, ) -> int:
            varargs void new_recalc_light() {
            object *obs
            object ob
            int tmp_light
            _need_recalculate = 0
            _light = _my_light * _my_light
            if (_my_light < 0)  _light = -_light
            if ( !self.query_opaque() ) {
            obs = all_inventory(self)
            foreach (ob in obs) {
            if (ob.query_opaque()) {
            tmp_light = ob.query_my_light()
            } else {
            tmp_light = ob.query_light()


    def light_level_changed(self, ) -> None:
            _need_recalculate = 1


    def inform_of_light_level_change(self, ob: MudObject) -> None:
            if (ob) {
            ob.light_level_changed()


    def add_inform_light_change(self, ob: MudObject) -> None:
            _inform_of_change += [ob]


    def remove_inform_light_change(self, ob: MudObject) -> None:
            _inform_of_change -= [ob]


    def set_opaque(self, ) -> None:
            add_property( "opaque", 1 )


    def reset_opaque(self, ) -> None:
            remove_property( "opaque" )


    def query_opaque(self, ) -> int:
            return query_property("opaque")


    def adjust_light(self, number: int) -> int:
            if (number) {
            _my_light += number
            inform_of_light_level_change(self)


    def set_light(self, number: int) -> int:
            return adjust_light(number - _my_light)


    def __init__(self):
            self.weight = 1
            self.value_info = ([ ])


    def adjust_weight(self, w: int) -> None:
            if (environment()) {
            environment()->add_weight(w)


    def set_weight(self, w: int) -> None:
            if (environment())
            environment()->add_weight(w-weight)
            weight = w


    def query_complete_weight(self, {: Any) -> int:
            varargs int adjust_money(mixed amt, string coin) {
            if (pointerp(amt)) {
            value += (int)MONEY_HAND.query_total_value(amt)
            if (value < 0) {
            value = 0


    def adjust_value(self, i: int) -> int:
            value += i
            return value


    def query_money(self, type: str) -> int:
            int i
            mixed *m_a
            m_a = (mixed *)MONEY_HAND.create_money_array(value)
            i = m_a.index(type) if type in m_a else -1
            if (i == -1) {
            return 0


    def set_value_info(self, word: str, number: int) -> None:
            value_info[ word ] = number


    def remove_value_info(self, word: str) -> None:
            if ( undefinedp( value_info[ word ] ) )
            return
            value_info = m_delete( value_info, word )


    def query_base_value(self, ) -> int:
            return value


    def query_value_at(self, place: MudObject) -> int:
            int i, total
            string *info
            mixed how
            if ( !value_info ) {
            value_info = ([ ])


    def query_value_real(self, place: str) -> int:
            int i
            int total
            string *info
            if ( !value_info ) {
            value_info = ([ ])


    def dest_me(self, ) -> None:
            if ( environment() ) {
            environment()->add_weight( -(int)self.query_complete_weight() )
            if ( query_my_light() )
            adjust_light( -query_my_light() )


    def check_log_status(self, parray: MudObject) -> None:
            if ( self.query_property( WATCH_DEFINE ) &&
            clonep( self ) &&
            arrayp( parray ) &&
            parray.index(load_object("/secure/cmds/creator/cl_one")) if load_object("/secure/cmds/creator/cl_one") in parray else -1 != -1){
            log_file( "WATCH", "%s TO: %s. TP: %s.\n", ctime(time()),
            base_name( self ), parray[2]->query_name() )
            self.add_property( "CT", time() )
            user_event( "inform", sprintf( "[Restricted] %s cloned %s.",
            parray[2]->query_cap_name(),
            base_name( self ) ), "cheat" )


    def dest_me(self, ) -> None:
            if ( environment() ) {
            event( environment(), "dest_me" )


    def set_move_flag(self, i: int) -> None:
            ==================================================
            FILE: basic/print_object.c
            ==================================================
            varargs string print_object(mixed ob, int off) {
            int i
            write("                   "[0..off])
            if (intp(ob)) {
            write(ob+"\n")
            return "int"


    def __init__(self):


    def remove_property(self, var: str) -> int:
            if (map_prop)
            map_delete(map_prop, var)
            if (timed_properties)
            map_delete(timed_properties, var)
            #ifdef TRACK_PROPERTY_STATS
            if (property_stats)
            map_delete(property_stats, var)
            #endif
            return 1


    def query_property(self, str: str) -> Any:
            if (!map_prop)
            return ([ ])["bing"]
            if (timed_properties && timed_properties[str] &&
            timed_properties[str] < time()) {
            map_delete(timed_properties, str)
            map_delete(map_prop, str)
            #ifdef TRACK_PROPERTY_STATS
            if(property_stats)
            map_delete(property_stats, str)
            #endif
            return map_prop[str]


    def query_is_timed_property(self, str: str) -> int:
            if (timed_properties && timed_properties[str]) {
            if (timed_properties[str] < time()) {
            map_delete(timed_properties, str)
            map_delete(map_prop, str)
            #ifdef TRACK_PROPERTY_STATS
            map_delete(property_stats, str)
            #endif
            return 0


    def query_property_time_left(self, str: str) -> int:
            if (timed_properties &&
            timed_properties[str]) {
            if (timed_properties[str] < time()) {
            map_delete(timed_properties, str)
            map_delete(map_prop, str)
            #ifdef TRACK_PROPERTY_STATS
            map_delete(property_stats, str)
            #endif
            return 0


    def query_property_exists(self, str: str) -> int:
            if (!map_prop)
            return 0
            if (timed_properties &&
            timed_properties[str] &&
            timed_properties[str] < time()) {
            map_delete(timed_properties, str)
            map_delete(map_prop, str)
            #ifdef TRACK_PROPERTY_STATS
            map_delete(property_stats, str)
            #endif
            return map_prop[str]


    def add_properties(self, map: Any) -> None:
            if (!map_prop)
            map_prop = map
            else
            map_prop += map


    def set_properties(self, map: Any) -> None:
            map_prop = map


    def stats(self, ) -> Any:
            int i, bing
            mixed *k, *v, *res
            mapping props
            props = (mapping)self.query_properties()
            if ( !props )
            return [})
            k = keys( props )
            v = values( props )
            res = [})
            for ( i = sizeof( k ) - 1; i > -1; i-- ) {
            bing = 0
            if (timed_properties &&
            timed_properties[ k[ i ] ] &&
            timed_properties[ k[ i ] ] < time()) {
            map_delete(timed_properties, k[ i ])
            map_delete(map_prop, k[ i ])
            #ifdef TRACK_PROPERTY_STATS
            if(property_stats)
            map_delete(property_stats, k[i])
            #endif
            continue


    def query_property_stats(self, var: str) -> Any:
            if (!property_stats || undefinedp( property_stats[var] ) )
            return [})
            return property_stats[ var ]


    def query_cur_size(self, ) -> int:
            varargs void set_read_mess(mixed str, string lang, int size) {
            if ( pointerp( str ) ) {
            _read_mess = str
            return


    def remove_read_mess(self, str: str, type: str, lang: str) -> int:
            int i
            for (i=0;i<sizeof(_read_mess);i++) {
            if (str && _read_mess[i][READ_STR] != str)
            continue
            if (type && _read_mess[i][READ_TYPE] != type)
            continue
            if (lang && _read_mess[i][READ_LANG] != lang)
            continue
            _cur_size -= _read_mess[i][READ_SIZE]
            *((int)LANGUAGE_HAND->query_language_size(lang,
            _read_mess[i][READ_STR]))
            _read_mess = _read_mess[0..i - 1] + _read_mess[i + 1..]
            return 1


    def query_readable_message(self, player: MudObject, ignore_labels: int) -> str:
            string message
            string file
            string type
            string lang
            mixed mess
            mixed *bit
            mixed *read_mess
            int pos
            if(!player)
            player = this_player()
            read_mess = query_read_mess()
            if ( !sizeof( read_mess ) ) {
            return 0


    def query_read_short(self, player: MudObject, ignore_labels: int) -> str:
            string id
            string *read_mess
            read_mess = query_read_mess()
            if ( !arrayp(read_mess) || !sizeof( read_mess ) ) {
            return 0


    def set_repeater_owner(self, owner: MudObject) -> None:
            _repeater = owner


    def query_repeater_owner(self, ) -> MudObject:
            return _repeater


    def event_person_say(self, ob: MudObject, start: str, mess: str, lang: str) -> None:
            if (_repeater) {
            _repeater->repeat_event_person_say(self,
            ob,
            start,
            mess,
            lang)


    def event_emote(self, ob: MudObject, mess: str) -> None:
            if (_repeater) {
            _repeater->repeat_event_emote(self,
            ob,
            mess)


    def event_say(self, ob: MudObject, str: str, avoid: Any) -> None:
            if (_repeater) {
            _repeater->repeat_event_say(self,
            ob,
            str,
            avoid)


    def event_soul(self, ob: MudObject, str: str, avoid: Any) -> None:
            if (_repeater) {
            _repeater->repeat_event_soul(self,
            ob,
            str,
            avoid)


    def long(self, word: str, dark: int) -> str:
            int i
            int j
            int chance
            int level
            int width
            string spell_name
            level = 2 * (int)_spell.query_power_level()
            width = sqrt( level )
            chance = (int)this_player()->query_skill_bonus( SKILL ) - ( level - width )
            chance = ( 100 * chance ) / ( 2 * width + 1 )
            spell_name = "$"+ (string)_spell.query_name() +"$"
            j = strlen( spell_name ) - 1
            for ( i = 1; i < j; i++ ) {
            if ( random( 100 ) > chance ) {
            switch ( spell_name[ i ] ) {
            case 32 :
            break
            case 65 .. 90 :
            spell_name = spell_name[ 0 .. i - 1 ] +
            sprintf( "%c", 65 + random( 26 ) ) +
            spell_name[ i + 1 .. j ]
            break
            case 97 .. 122 :
            spell_name = spell_name[ 0 .. i - 1 ] +
            sprintf( "%c", 97 + random( 26 ) ) +
            spell_name[ i + 1 .. j ]
            break
            default :
            spell_name = spell_name[ 0 .. i - 1 ] +
            spell_name[ i + 1 .. j ]
            j--


    def query_spell_power_level(self, ) -> int:
            if (_spell) {
            return _spell.query_power_level()


    def test_skill(self, ) -> int:
            int level
            level = 2 * (int)( _spell.query_power_level() ) + 1
            return (int)TASKER.perform_task(this_player(), SKILL, level, TM_FREE)


    def clear_spell(self, award: int) -> None:
            if ( award ) {
            write( "%^YELLOW%^"+ ["A piece of lore concerning scrolls becomes "
            "clearer for you", "You manage to grasp one of the principles "
            "of magic scrolls more firmly", "A sudden flash of insight "
            "allows you to understand process of casting a spell from a "
            "scroll a little better"][ random( 3 ) ] +".%^RESET%^\n" )


    def cast_spell(self, words: str) -> int:
            int outcome
            if ( !words ) {
            words = ""


    def cast_spell_new(self, words: str, targets: Any, using: Any) -> int:
            int outcome
            if ( !words ) {
            words = ""


    def query_death_reason(self, ) -> str:
            return " a spell going wild and getting out of control."


    def destroy_this_scroll(self, ) -> None:


    def check_react(self, player: MudObject) -> None:
            object ob
            int level
            int ac
            string check_spell
            object paper
            object *items
            object env
            if (!environment(player)) {
            return


    def query_death_reason(self, ) -> str:
            return " a spell going wild and getting out of control."


    def __init__(self):
            self._adjs = ([ ])


    def set_stat_adjustment(self, player: MudObject, adjs: Any) -> None:
            _adjs[player] = adjs
            player.add_effect(STAT_ADJUSTMENT_EFFECT, [self, adjs])


    def remove_stat_adjustment(self, player: MudObject) -> None:
            STAT_ADJUSTMENT_EFFECT.remove_stat_adjustment_ob(player, self)
            map_delete(_adjs, player)


    def remove_all_stat_adjustments(self, ) -> None:
            mapping adj
            object play
            foreach (play, adj in _adjs) {
            STAT_ADJUSTMENT_EFFECT.remove_stat_adjustment_ob(play, self)
            map_delete(_adjs, play)


    def make_shadow(self, thing: MudObject) -> None:
            object shadow
            shadow = clone_object( SURFACE_SHADOW )
            shadow.setup_shadow( thing, self )
            if ( !surface_shadows ) surface_shadows = [})
            surface_shadows += [shadow]


    def check_shadows(self, ) -> None:
            int i
            for ( i = 0; i < sizeof( surface_shadows ); i++ ) {
            if ( surface_shadows[ i ] ) {
            if ( environment() == (object)surface_shadows[ i ]->
            query_shadowed( surface_shadows[ i ] ) ) {
            surface_shadows[ i ]->destruct_shadow( surface_shadows[ i ] )
            surface_shadows = surface_shadows[0..i-1] + surface_shadows[i + 1..]
            i--


    def check_environment(self, ) -> None:
            if ( environment() ) {
            make_shadow( environment() )


    def dest_me(self, ) -> None:
            int i
            for ( i = 0; i < sizeof( surface_shadows ); i++ )
            if ( surface_shadows[ i ] )
            surface_shadows[ i ]->destruct_shadow( surface_shadows[ i ] )


    def add_theft_callback(self, func_name: str, path: str) -> int:
            class theft_callback temp = new( class theft_callback, func_name: func_name,
            path: path )
            if ( !stringp( func_name ) || !stringp( path ) )
            return -1
            debug_printf( "Added theft callback: %s %s.\n", func_name, path )
            calls += [temp]
            return sizeof( calls ) - 1


    def remove_theft_callback(self, id: int) -> int:
            if ( id >= sizeof( calls ) || id < 0 )
            return -1
            debug_printf( "Deleting callback: %s %s.\n", calls[id]->func_name,
            calls[id]->path )
            calls -= [calls[id]]
            return 1


    def query_theft_callbacks(self, ) -> str:
            string ret = ""
            int count = 0
            if ( !sizeof( calls ) )
            return "No theft callbacks found!\n"
            foreach( class theft_callback temp in calls ) {
            ret += sprintf( "%d. %s: %s.\n", count, temp->func_name, temp->path )
            count++


    def basic_trap(self, action: str) -> int:
            if(!_trap_armed || action != _trap_trigger)
            return 1
            switch(TASKER.perform_task(this_player(), SKILL, _trap_difficulty,
            TM_FREE)) {
            case AWARD:
            write("%^YELLOW%^You feel you have learned something about avoiding "
            "traps.%^RESET%^\n")
            case SUCCEED:
            return 1
            default:
            if(arrayp(_trap_message)) {
            write(_trap_message[0])
            say(_trap_message[1], this_player())
            } else
            write(_trap_message)
            if(intp(_trap_effect)) {
            if(_trap_effect > this_player()->query_hp())
            this_player()->do_death()
            else
            this_player()->adjust_hp(-(_trap_effect))
            } else if(arrayp(_trap_effect)) {
            if(sizeof(_trap_effect) == 2)
            this_player()->add_effect(_trap_effect[0], _trap_effect[1])
            else
            this_player()->add_effect(_trap_effect[0], _trap_effect[1..])
            } else
            this_player()->add_effect(_trap_effect)
            return 0


    def __init__(self):
            self.version_control[ base_name( this_object() ) ] = ctime( time() )
            self.version_control[ base_name( temp ) ] = temp->query_version()


    def query_version_control(self, ) -> None:
            write( "File:\tTime:\n" )
            foreach( string temp in keys( version_control ) )
            printf( "%s\t%s.\n", temp, version_control[ temp ] )
            return


    def query_version(self, ) -> str:
            return version_control[ base_name( self ) ]


    def replace_me(self, ) -> None:
            {
            object receipt
            mixed als
            receipt = clone_object("/obj/misc/al_receipt")
            receipt.set_name("receipt")
            receipt.set_object(file_name(self))
            receipt.set_virtobname(query_property(VIRTUAL_NAME_PROP))
            receipt.set_value(self->query_value())
            als = "/global/auto_load"->fragile_auto_str_ob(self)
            als[0] = 1
            receipt.set_static_save(als)
            receipt.set_short("destructed item receipt")
            receipt.add_adjective(["destructed", "item"])
            receipt.set_long("This seems to be a small piece of paper.\n")
            receipt->set_read_mess("According to our sources, your " +
            self.query_short() +
            " was not " "allowed to exist.  Have a nice day.")
            receipt.move(environment())
            receipt.set_weight(1)
            destruct(self)


    def init_virtual_object(self, ) -> None:
            {
            mapping stat_temp
            string virt_name
            string new_name
            virt_name = query_property(VIRTUAL_NAME_PROP)
            if (virt_name) {
            if (file_size(virt_name) == -1) {
            new_name = (CLONER)->other_file(virt_name)
            if (stringp(new_name) && (new_name != virt_name)) {
            add_property(VIRTUAL_NAME_PROP, new_name)
            virt_name = new_name
            } else {
            if (VIRTUAL_HANDLER.query_forbidden(virt_name)) {
            asyncio.create_task(self."replace_me", 1)
            } else {
            VIRTUAL_HANDLER.add_missing(virt_name)


    def __init__(self):
            self.immune_to = ['cold', 'sound', 'gas', 'mental']
            self.wear_effects = []
            self.wear_remove_func = []


    def long(self, word: str, dark: int) -> str:
            switch ( dark ) {
            case 0 :
            return cond_string()
            default :
            return ""


    def set_wear_remove_func(self, file: Any, func: str) -> None:
            wear_remove_func = [file, func]


    def set_wear_effects(self, effects: str) -> None:
            wear_effects = effects


    def add_wear_effect(self, effect: str) -> None:
            if ( wear_effects .index( effect) if  effect in wear_effects  else -1 == -1 ) {
            wear_effects += [effect]


    async def do_damage(self, type: str, amount: int) -> None:
            if ( immune_to .index( type) if  type in immune_to  else -1 == -1 ) {
        # 2025 enchantment resistance
        if hasattr(self, 'attrs') and self.attrs.get('enchantment', 0) > 0:
            amount = max(0, amount - self.attrs['enchantment'])
            condition::do_damage( type, amount )
        # 2025 enchantment resistance
        if hasattr(self, 'attrs') and self.attrs.get('enchantment', 0) > 0:
            amount = max(0, amount - self.attrs['enchantment'])


    def query_worn_by(self, ) -> MudObject:
            return donned in Faern_by


    def set_worn_by(self, thing: MudObject) -> int:
            int i
            if ( thing == donned in Faern_by ) {
            return 1


    def add_immune_to(self, args: Any) -> None:
            int i
            if ( pointerp( args ) ) {
            for ( i = 0; i < sizeof( args ); i++ ) {
            add_immune_to( args[ i ] )


    def remove_immune_to(self, args: Any) -> None:
            int i
            if ( pointerp( args ) ) {
            for ( i = 0; i < sizeof( args ); i++ ) {
            remove_immune_to( args[ i ] )


    def query_type(self, ) -> str:
            return type


    def set_type(self, word: Any) -> None:
            int i
            if(!stringp(word) && !pointerp(word))
            return log_bad_type(word)
            type = word
            if(stringp(word)) {
            if(CLOTHING_HANDLER.query_equivilant_type(word))
            type = CLOTHING_HANDLER.query_equivilant_type(word)
            if(!CLOTHING_HANDLER.query_valid_type(word))
            log_bad_type( word )
            return


    def modify_value(self, amount: int) -> int:
            return ( amount * ( 10 + ( 90 * query_cond() ) / query_max_cond() ) ) / 100


    def player_wear(self, ) -> None:
            if ( !environment() ) {
            return


    def break_me(self, ) -> None:
            if ( !donned in Faern_by ) {
            return condition::break_me()


    def init_static_arg(self, map: Any) -> None:
            if ( map[ "type" ] )
            type = map[ "type" ]
            if ( map[ "wear remove func" ] )
            wear_remove_func = map[ "wear remove func" ]
            if ( !undefinedp( map[ "condition" ] ) ) {
            condition::init_static_arg( map[ "condition" ] )


    def init_dynamic_arg(self, map: Any, object) -> None:
            if ( map[ "effect" ] )
            wear_effects = [map[ "effect" ]]
            if ( pointerp( map[ "wear effects" ] ) )
            wear_effects = map[ "wear effects" ]
            if ( map[ "immune" ] )
            immune_to = map[ "immune" ]
            if ( map[ "donned in Faern" ] )
            asyncio.create_task(self. "player_wear", 0 )
            if ( !undefinedp( map[ "condition" ] ) ) {
            condition::init_dynamic_arg( map[ "condition" ] )


    def remove_wear_remove_func(self, ) -> None:
            wear_remove_func = [})


    def __init__(self):
            self.connected = 0
            self.verbose = 0


    def disconnected(self, ) -> None:
            {
            self, callback.close()
            connected = 0


    def connected(self, ) -> int:
            {
            self, callback.open()
            connected = 1


    def my_socket_write(self, fd: int, message: str) -> None:
            {
            int ret
            write_message = write_message + message
            if(write_state == WRITE_GO_AHEAD){
            ret = socket_write(fd, write_message)
            write_message = ""
            if(ret == EESUCCESS) write_state = WRITE_GO_AHEAD
            else if(ret == EECALLBACK) write_state = WRITE_WAIT_CALLBACK


    def line(self, str: str) -> int:
            {
            if(connected){
            my_socket_write(conn_fd,s_iac_dont_sga+s_iac_dont_echo)
            write("SENT dont SUPPRESS GO AHEAD\nSENT dont ECHO\n")
            return(1)


    def char(self, str: str) -> int:
            {
            if(connected){
            my_socket_write(conn_fd,s_iac_do_sga+s_iac_do_echo)
            write("SENT do SUPPRESS GO AHEAD\nSENT do ECHO\n")
            return(1)


    def connect(self, str: str) -> int:
            {
            int ret
            if(!str) return(0)
            conn_fd = socket_create(STREAM,"socket_shutdown")
            ret = socket_connect(conn_fd,str,"receive_data","write_data")
            if(ret != EESUCCESS){
            notify_fail("unable to connect: " + socket_error(ret) + "\n")
            return(0)


    def send(self, str: str) -> int:
            {
            if(connected){
            if(!str){
            write("Sending CR.\n")
            my_socket_write(conn_fd,"\n")
            return(1)


    def disconnect(self, str: str) -> int:
            {
            int ret
            ret = socket_close(conn_fd)
            if(ret <= 0){
            notify_fail("unable to disconnect.\n")
            return(0)


    def receive_data(self, rec_fd: int, msg: str) -> None:
            string *chunks
            int i
            object hearer
            self.recieve_message(msg)


    def write_data(self, fd: int) -> None:
            write_state = WRITE_GO_AHEAD
            my_socket_write(fd,"")


    def socket_shutdown(self, fd: int) -> None:
            {
            object hearer
            if(fd == conn_fd){
            hearer = environment(self)
            disconnected()
            return


    def __init__(self):
            self._regions = ([ ])


    def add_region(self, name: str, description: str, start: str, accent: str) -> None:
            class region bing
            bing = new(class region,
            description : description,
            start_location : start,
            accent_ob : accent)
            _regions[name] = bing


    def set_name(self, name: str) -> None:
            _name = name


    def query_name(self, ) -> str:
            return _name


    def set_same_nationality_description(self, description: str) -> None:
            _same_nat_description = description


    def query_same_nationality_description(self, ) -> str:
            return _same_nat_description


    def set_different_nationality_description(self, description: str) -> None:
            _different_nat_description = description


    def query_different_nationality_description(self, ) -> str:
            return _different_nat_description


    def query_look_description(self, person: MudObject, looker: MudObject) -> str:
            return ""
            if (person.query_nationality() == looker.query_nationality()) {
            return capitalize(person.query_pronoun()) + " " +
            _same_nat_description
            } else {
            return capitalize(person.query_pronoun()) + " " +
            _different_nat_description


    def set_default_start_location(self, start_loc: str) -> None:
            _start_loc = start_loc


    def query_default_start_location(self, ) -> str:
            return _start_loc


    def set_language(self, language: str) -> None:
            _language = language


    def query_language(self, ) -> str:
            return _language


    def set_information(self, info: str) -> None:
            _information = info


    def query_information(self, ) -> str:
            if (!_information) {
            _information = "The $C$" + query_name() + " nationality is yet to "
            "be described.\n"


    def query_region_description(self, region: str) -> str:
            return _regions[region]->description


    def query_region_start_location(self, region: str) -> str:
            return _regions[region]->start_location


    def query_start_location(self, region: str) -> str:
            if (_regions[region] && _regions[region]->start_location) {
            return _regions[region]->start_location


    def query_region_accent_ob(self, region: str) -> str:
            if (_regions[region]) {
            return _regions[region]->accent_ob


    def set_currency_area(self, area: str) -> None:
            _currency = area


    def query_currency_area(self, ) -> str:
            return _currency


    def setup(self, ) -> None:
            set_name( "pumpkin" )
            set_information( "Pumpkin is a large orange ball shaped town.\n")
            add_region( "round",
            "Pumpkins which are round.",
            "/d/dist/start/entrance",
            "/std/nationality/accents/regional/round")
            add_region( "square",
            "Sto Lat is the second biggest city in the Morporkian kingdom, "
            "it sits on the river Ankh on the way to the Carrack "
            "Mountains.  It is a harder starting location than "
            "Waterdeep but close enough that it is not that much of an "
            "issue.",
            "/d/dist/start/entrance",
            "/std/nationality/accents/regional/square")
            set_language("pumpkin")
            set_currency_area("Pumpkin")
            set_default_start_location("/d/am/buildings/drum/mendeddrum")


    def query_nat_accent(self, lang: str) -> str:
            return NATIONAL_ACCENT_PATH + lang


    def query_accent_name(self, ) -> str:
            return "Morporkian"


    def query_accent_name(self, ) -> str:
            return "Pumpkian"


    def query_accent_name(self, ) -> str:
            return "Pumpkinian"


    def init_curse(self, pl: MudObject) -> int:
            string str, i
            if (sscanf((str = file_name(self)), "%s#%d", str, i) != 2) {
            seteuid((string)"/secure/master"->creator_file(str))
            return (int)clone_object(str)->init_curse(pl)


    def query_remove(self, name: str) -> int:
            if (name != MY_NAME)
            return (int)my_player.query_remove(name)
            return 1


    def player_start(self, pl: MudObject) -> int:
            object ob
            if (!pl)
            pl = this_player()
            ob = clone_object(HERE+"chef_curse")
            ob.init_curse(pl)


    def destruct_curse(self, str: str) -> int:
            if (str == MY_NAME)
            destruct(self)
            else
            my_player.destruct_curse(str)


    def do_emote_all(self, str: str) -> int:
            return (int)my_player.do_emote_all((HERE+"chef_mangle")->do_transmute(str))


    def do_shout(self, str: str) -> int:
            return (int)my_player.do_shout((HERE+"chef_mangle")->do_transmute(str))


    def do_say(self, str: str) -> int:
            return (int)my_player.do_say((HERE+"chef_mangle")->do_transmute(str))


    def do_loud_say(self, str: str) -> int:
            return (int)my_player.do_loud_say((HERE+"chef_mangle")->do_transmute(str))


    def do_emote(self, str: str) -> int:
            return (int)my_player.do_emote((HERE+"chef_mangle")->do_transmute(str))


    def do_tell(self, str: str) -> int:
            string s1
            if (sscanf(str, "%s %s", s1, str) != 2)
            return (int)my_player.do_tell(str)
            return (int)my_player.do_tell(s1+" "+(HERE+"chef_mangle")->do_transmute(str))


    def __init__(self):
            self.replace_matrix = []


    def do_transmute(self, str: str) -> str:
            return replace(" "+str, replace_matrix)[1..10000]


    def init_curse(self, pl: MudObject) -> int:
            string str, i
            if (sscanf((str = file_name(self)), "%s#%d", str, i) != 2) {
            seteuid((string)"/secure/master"->creator_file(str))
            return (int)clone_object(str)->init_curse(pl)


    def query_remove(self, name: str) -> int:
            if (name != MY_NAME)
            return (int)my_player.query_remove(name)
            return 1


    def player_start(self, pl: MudObject) -> int:
            object ob
            if (!pl)
            pl = this_player()
            ob = clone_object(HERE+"ken_curse")
            ob.init_curse(pl)


    def destruct_curse(self, str: str) -> int:
            if (str == MY_NAME)
            destruct(self)
            else
            my_player.destruct_curse(str)


    def do_emote_all(self, str: str) -> int:
            return (int)my_player.do_emote_all((HERE+"ken_mangle")->do_transmute(str))


    def do_shout(self, str: str) -> int:
            return (int)my_player.do_shout((HERE+"ken_mangle")->do_transmute(str))


    def do_say(self, str: str) -> int:
            return (int)my_player.do_say((HERE+"ken_mangle")->do_transmute(str))


    def do_loud_say(self, str: str) -> int:
            return (int)my_player.do_loud_say((HERE+"ken_mangle")->do_transmute(str))


    def do_emote(self, str: str) -> int:
            return (int)my_player.do_emote((HERE+"ken_mangle")->do_transmute(str))


    def do_tell(self, str: str) -> int:
            string s1
            if (sscanf(str, "%s %s", s1, str) != 2)
            return (int)my_player.do_tell(str)
            return (int)my_player.do_tell(s1+" "+(HERE+"ken_mangle")->do_transmute(str))


    def __init__(self):
            self.replace_matrix = []
            self.trans = ([ ])
            self.trans["stairs"] = "apples and pears"
            self.trans["Downstairs"] = "Down the apples and pears"
            self.trans["downstairs"] = "down the apples and pears"
            self.trans["Upstairs"] = "Up the apples and pears"
            self.trans["upstairs"] = "up the apples and pears"
            self.trans["mouth"] = "North and South"
            self.trans["Mouth"] = "North and South"
            self.trans["Face"] = "Boat Race"
            self.trans["face"] = "Boat Race"
            self.trans["Trouble"] = "Barney Rubble"
            self.trans["trouble"] = "Barney Rubble"
            self.trans["wife"] = ['trouble and strife', 'ole lady']
            self.trans["Road"] = "Frog and Toad"
            self.trans["road"] = "frog and toad"
            self.trans["pub"] = "rub-a-dub "
            self.trans["bar"] = "boozer"
            self.trans["husband"] = "ole man"
            self.trans["Party"] = "Knees-up"
            self.trans["party"] = "knees-up"
            self.trans["Parties"] = "Knees-ups"
            self.trans["parties"] = "knees-ups"
            self.trans["My"] = "Me"
            self.trans["my"] = "me"
            self.trans["Your"] = "Yer"
            self.trans["your"] = "yer"
            self.trans["You"] = "Yer"
            self.trans["you"] = "yer"
            self.trans["Those"] = "Them"
            self.trans["those"] = "them"
            self.trans["those"] = "them"
            self.trans["(those"] = "(them"
            self.trans["The"] = ["The bleedin'", 'The']
            self.trans["Fe"] = ["The bleedin'", 'The']
            self.trans["the"] = ["the bleedin'", 'the']
            self.trans["fe"] = ["the bleedin'", 'the']
            self.trans["Thus"] = "So"
            self.trans["thus"] = "so"
            self.trans["(thus"] = "(so"
            self.trans["thus"] = "so"
            self.trans["old"] = "ole"
            self.trans["to"] = "ter"
            self.trans["Aren't"] = "Ain't"
            self.trans["aren't"] = "ain't"
            self.trans["Isn't"] = "Ain't"
            self.trans["isn't"] = "ain't"
            self.trans["Hallo"] = "Wotcher"
            self.trans["Hello"] = "Wotcher"
            self.trans["Hullo"] = "Wotcher"
            self.trans["Hi"] = "Wotcher"
            self.trans["hallo"] = "wotcher"
            self.trans["hello"] = "wotcher"
            self.trans["hullo"] = "wotcher"
            self.trans["hi"] = "wotcher"
            self.trans["What"] = "Wot"
            self.trans["what"] = "wot"
            self.trans["Were"] = "Was"
            self.trans["were "] = "was"
            self.trans["Bother"] = "Ars"
            self.trans["bother"] = "ars"
            self.trans["Mother"] = "Muvver"
            self.trans["Other"] = "Uvver"
            self.trans["other"] = "uvver"
            self.trans["Father"] = "Favver"
            self.trans["father"] = "favver"
            self.trans["Rather"] = "Ravver"
            self.trans["rather"] = "ravver"
            self.trans["Weather"] = "Wevver"
            self.trans["weather"] = "wevver"
            self.trans["Leather"] = "Levver"
            self.trans["leather"] = "levver"
            self.trans["Wither"] = "Wivver"
            self.trans["wither"] = "wivver"
            self.trans["Either"] = "Eever"
            self.trans["either"] = "eever"
            self.trans["With"] = "Wiv"
            self.trans["with"] = "wiv"
            self.trans["Anything"] = "Anyfink"
            self.trans["anything"] = "anyfink"
            self.trans["Something"] = "Sumfink"
            self.trans["something"] = "sumfink"
            self.trans["Nothing"] = "Nuffink"
            self.trans["nothing"] = "nuffink"
            self.trans["guitars"] = "spoons"
            self.trans["guitar"] = "spoons"
            self.trans["drums"] = "spoons"
            self.trans["drum"] = "spoons"
            self.trans["trumpets"] = "spoons"
            self.trans["trumpet"] = "spoons"
            self.trans["violins"] = "spoons"
            self.trans["violin"] = "spoons"
            self.trans["clarinets"] = "spoons"
            self.trans["clarinet"] = "spoons"
            self.trans["trombones"] = "spoons"
            self.trans["trombone"] = "spoons"
            self.trans["oboes"] = "spoons"
            self.trans["oboe"] = "spoons"
            self.trans["flutes"] = "spoons"
            self.trans["flute"] = "spoons"
            self.trans["tubas"] = "spoons"
            self.trans["tuba"] = "spoons"
            self.trans["Data"] = "Info"
            self.trans["data"] = "info"
            self.trans["Directory"] = "Lockup"
            self.trans["directory"] = "lockup"
            self.trans["Directories"] = "Lockups"
            self.trans["directories"] = "lockups"
            self.trans["Stopped"] = "'Ad the mockers put on"
            self.trans["stopped"] = "'ad the mockers put on"
            self.trans["Stopping"] = "Putting the mockers on"
            self.trans["stopping"] = "putting the mockers on"
            self.trans["stops"] = "puts the mockers on"
            self.trans["stop"] = "put the mockers on"
            self.trans["STOP"] = "Put The Mockers On"
            self.trans["Londoner"] = "Cockney"
            self.trans["londoner"] = "Cockney"
            self.trans["friend"] = ['mucker', 'mate', 'china']
            self.trans["sin'"] = "sing"
            self.trans["rin'"] = "ring"


    def do_transmute(self, str: str) -> str:
            string tmp, *bits
            mixed erp
            int i
            tmp = replace(" "+str+" ", replace_matrix)
            bits = explode(tmp, " ")
            for (i=0;i<sizeof(bits);i++) {
            if (erp = trans[bits[i]])
            if (stringp(erp))
            bits[i] = erp
            else
            bits[i] = erp[random(sizeof(erp))]


    def init_curse(self, pl: MudObject) -> int:
            string str
            int i
            if (sscanf((str = file_name(self)), "%s#%d", str, i) != 2) {
            seteuid((string)"/secure/master"->creator_file(str))
            return (int)clone_object(str)->init_curse(pl)


    def player_start(self, pl: MudObject) -> int:
            object ob
            if (!pl)
            pl = this_player()
            ob = clone_object(file_name(self))
            ob.init_curse(pl)


    def destruct_curse(self, str: str) -> int:
            if (str == MY_NAME)
            destruct(self)
            else
            my_player.destruct_curse(str)


    def do_say(self, str: str) -> int:
            return (int)my_player.do_say(newbie(str))


    def do_tell(self, str: str) -> int:
            return (int)my_player.do_tell(newbie(str))


    def do_loud_say(self, str: str) -> int:
            return (int)my_player.do_loud_say(newbie(str))


    def do_echo(self, str: str) -> int:
            return (int)my_player.do_echo(newbie(str))


    def do_emote_all(self, str: str) -> int:
            return (int)my_player.do_echo_all(newbie_emote(str))


    def do_emote(self, str: str) -> int:
            return (int)my_player.do_emote(newbie_emote(str))


    def do_whisper(self, str: str) -> int:
            return (int)my_player.do_whisper(newbie(str))


    def do_echo_to(self, str: str) -> int:
            return (int)my_player.do_echo_to(newbie(str))


    def do_shout(self, str: str) -> int:
            return (int)my_player.do_shout(newbie(str))


    def do_talk(self, str: str) -> int:
            return (int)my_player.do_talk(newbie(str))


    def remove_effect_shadow(self, i: int) -> None:
            if (i == id) {
            destruct(self)
            return


    def do_say(self, str: str) -> int:
            return (int)my_player.do_say(newbie(str))


    def do_tell(self, str: str) -> int:
            return (int)my_player.do_tell(newbie(str))


    def do_loud_say(self, str: str) -> int:
            return (int)my_player.do_loud_say(newbie(str))


    def do_echo(self, str: str) -> int:
            return (int)my_player.do_echo(newbie(str))


    def do_emote_all(self, str: str) -> int:
            return (int)my_player.do_emote_all(newbie_emote(str))


    def do_emote(self, str: str) -> int:
            return (int)my_player.do_emote(newbie_emote(str))


    def do_whisper(self, str: str) -> int:
            return (int)my_player.do_whisper(newbie(str))


    def do_echo_to(self, str: str) -> int:
            return (int)my_player.do_echo_to(newbie(str))


    def do_shout(self, str: str) -> int:
            return (int)my_player.do_shout(newbie(str))


    def do_talk(self, str: str) -> int:
            return (int)my_player.do_talk(newbie(str))


    def init_curse(self, pl: MudObject) -> int:
            string str, i
            if (sscanf((str = file_name(self)), "%s#%d", str, i) != 2) {
            seteuid((string)"/secure/master"->creator_file(str))
            return (int)clone_object(str)->init_curse(pl)


    def query_remove(self, name: str) -> int:
            return 1


    def player_start(self, pl: MudObject) -> int:
            object ob
            if (!pl)
            pl = this_player()
            ob = clone_object(HERE+"shout_curse")
            ob.init_curse(pl)


    def destruct_curse(self, str: str) -> int:
            if (str == MY_NAME)
            destruct(self)
            else
            my_player.destruct_curse(str)


    def do_emote_all(self, str: str) -> int:
            write("Your voice is too hoarse to shout.\n")
            return 1


    def do_shout(self, str: str) -> int:
            write("Your voice is too hoarse to shout.\n")
            return 1


    def init_curse(self, pl: MudObject) -> int:
            string str
            int i
            if (sscanf((str = file_name(self)), "%s#%d", str, i) != 2) {
            seteuid((string)"/secure/master"->creator_file(str))
            return (int)clone_object(str)->init_curse(pl)


    def player_start(self, pl: MudObject) -> int:
            object ob
            if (!pl)
            pl = this_player()
            ob = clone_object(file_name(self))
            ob.init_curse(pl)


    def destruct_curse(self, str: str) -> int:
            if (str == MY_NAME)
            destruct(self)
            else
            my_player.destruct_curse(str)


    def do_say(self, str: str) -> int:
            return (int)my_player.do_say(upper_case(str))


    def do_tell(self, str: str) -> int:
            return (int)my_player.do_tell(upper_case(str))


    def do_loud_say(self, str: str) -> int:
            return (int)my_player.do_loud_say(upper_case(str))


    def do_echo(self, str: str) -> int:
            return (int)my_player.do_echo(upper_case(str))


    def do_emote_all(self, str: str) -> int:
            return (int)my_player.do_echo_all(upper_case(str))


    def do_emote(self, str: str) -> int:
            return (int)my_player.do_emote(upper_case(str))


    def do_whisper(self, str: str) -> int:
            return (int)my_player.do_whisper(upper_case(str))


    def do_echo_to(self, str: str) -> int:
            return (int)my_player.do_echo_to(upper_case(str))


    def do_shout(self, str: str) -> int:
            return (int)my_player.do_shout(upper_case(str))


    def __init__(self):


    def init(self, ) -> None:
            basic_room::init()
            auction_house::init()


    def __init__(self):
            self.account_cost = 0
            self.percentage = 90
            self.total_account = 0
            self.total_made = 0
            self.bank_name = "Bing's First"
            self.place = "default"


    def init(self, ) -> None:
            add_command( "balance", "" )
            add_command( "withdraw", "<number> <string>",
            (: do_withdraw($4[0], $4[1]) :) )
            add_command( "open", "account" )
            add_command( "close", "account" )
            add_command( "deposit", "<string>", (: do_deposit($4[0]) :) )
            ::init()


    def set_save_file(self, word: str) -> None:
            save_file = word
            if ( file_size( save_file +".o" ) > 0 )
            unguarded((: restore_object, save_file :))


    def do_save(self, ) -> None:
            if ( !save_file ) {
            return


    def get_account(self, ) -> int:
            int amount
            if ( amount = (int)this_player()->query_property( "bank "+ OLD_BANK ) ) {
            HANDLER.adjust_account( NAME, bank_name, amount )
            this_player()->remove_property( "bank "+ OLD_BANK )
            total_account += amount
            do_save()


    def set_account(self, amount: int) -> int:
            HANDLER.set_account( NAME, bank_name, amount )


    def do_balance(self, ) -> int:
            int amount
            amount = get_account()
            if ( amount < 0 ) {
            notify_fail( "You do not have an account here.\n" )
            return 0


    def do_withdraw(self, number: int, type: str) -> int:
            int amount
            int best
            int total
            object money
            total = get_account()
            if ( total < 0 ) {
            notify_fail( "You do not have an account here.\n" )
            return 0


    def do_deposit(self, words: str) -> int:
            int amount
            int total
            int tmp
            mixed money
            object *tender
            object legal
            object illegal
            string howmuch
            total = get_account()
            if ( total < 0 ) {
            notify_fail("You don't have an account here.\n")
            return 0


    def do_open(self, ) -> int:
            int amount
            object money
            if ( get_account() >= 0 ) {
            notify_fail( "You already have an account here.\n" )
            return 0


    def check_open(self, word: str) -> int:
            object money
            word = lower_case( word )
            if (word [ 0 ] ==  110 ) {
            write( "Okay, not opening an account.\n" )
            return 1


    def do_close(self, ) -> int:
            int total
            object money
            total = get_account()
            if ( total < 0 ) {
            notify_fail( "You do not have an account here.\n" )
            return 0


    def make_bank_robbers(self, ) -> int:
            int i, amount, loss, number, percent_loss, total
            string player_name
            object *bags, *money, *players, *robbers
            mixed *mon_array
            percent_loss = 2 + random( 4 )
            players = users()
            for ( i = 0; i < sizeof( players ); i++ ) {
            player_name = (string)players[ i ]->query_name()
            if ( ( amount = (int)HANDLER.query_account( player_name, bank_name ) ) ) {
            switch( amount ) {
            case 1 .. 10:
            loss = 0
            break
            case 11 .. 100:
            loss = ( amount * percent_loss ) / 100
            break
            case 101 .. 1000:
            loss = ( amount * percent_loss * 2 ) / 100
            break
            case 1001 .. 10000:
            loss = ( amount * percent_loss * 3 ) / 100
            break
            case 10001 .. 100000:
            loss = ( amount * percent_loss * 4 ) / 100
            break
            default:
            loss = ( amount * percent_loss * 5 ) / 100


    def __init__(self):
            self._total_account = 0
            self._total_made = 0


    def query_float(self, ) -> int:
            return 2400000


    def adjust_float(self, amt: int) -> None:


    def query_franchise(self, ) -> str:
            return file_name(self)


    def is_open_for(self, type: str, person: str) -> int:
            return 1


    def set_save_file(self, word: str) -> None:
            _save_file = word
            if ( file_size( _save_file +".o" ) > 0 ) {
            unguarded((: restore_object, _save_file :))


    def event_save(self, ob: MudObject) -> None:
            if ( !_save_file ) {
            return


    def make_bank_robbers(self, ) -> int:
            int i, amount, loss, number, percent_loss, total
            string player_name
            object *bags, *money, *players, *robbers
            mixed *mon_array
            percent_loss = 2 + random( 4 )
            players = users()
            for ( i = 0; i < sizeof( players ); i++ ) {
            player_name = (string)players[ i ]->query_name()
            if ( ( amount = BANK_HANDLER.query_account( player_name, query_bank_name() ) ) ) {
            switch( amount ) {
            case 1 .. 10:
            loss = 0
            break
            case 11 .. 100:
            loss = ( amount * percent_loss ) / 100
            break
            case 101 .. 1000:
            loss = ( amount * percent_loss * 2 ) / 100
            break
            case 1001 .. 10000:
            loss = ( amount * percent_loss * 3 ) / 100
            break
            case 10001 .. 100000:
            loss = ( amount * percent_loss * 4 ) / 100
            break
            default:
            loss = ( amount * percent_loss * 5 ) / 100


    def init(self, ) -> None:
            basic_room::init()
            bank_franchise::init()


    def __init__(self):
            self._total_account = 0
            self._total_made = 0


    def query_float(self, ) -> int:
            return 2400000


    def adjust_float(self, amt: int) -> None:


    def is_open_for(self, type: str, person: str) -> int:
            return 1


    def set_save_file(self, word: str) -> None:
            _save_file = word
            if ( file_size( _save_file +".o" ) > 0 ) {
            unguarded((: restore_object, _save_file :))


    def event_save(self, ob: MudObject) -> None:
            if ( !_save_file ) {
            return


    def make_bank_robbers(self, ) -> int:
            int i, amount, loss, number, percent_loss, total
            string player_name
            object *bags, *money, *players, *robbers
            mixed *mon_array
            percent_loss = 2 + random( 4 )
            players = users()
            for ( i = 0; i < sizeof( players ); i++ ) {
            player_name = (string)players[ i ]->query_name()
            if ( ( amount = BANK_HANDLER.query_account( player_name, query_bank_name() ) ) ) {
            switch( amount ) {
            case 1 .. 10:
            loss = 0
            break
            case 11 .. 100:
            loss = ( amount * percent_loss ) / 100
            break
            case 101 .. 1000:
            loss = ( amount * percent_loss * 2 ) / 100
            break
            case 1001 .. 10000:
            loss = ( amount * percent_loss * 3 ) / 100
            break
            case 10001 .. 100000:
            loss = ( amount * percent_loss * 4 ) / 100
            break
            default:
            loss = ( amount * percent_loss * 5 ) / 100


    def init(self, ) -> None:
            basic_room::init()
            bank_master::init()


    def __init__(self):
            self._cost_per_book = 4000
            self._cost_per_page = 400


    def init(self, ) -> None:
            add_command("bind", "<object:indirect:me'pages'> into book")


    def check_for_magic_writing(self, ob: MudObject) -> int:
            mixed *stuff
            int i
            stuff = ob.query_read_mess()
            for (i = 0; i < sizeof(stuff); i++) {
            if (LANGUAGE_HAND.query_language_magic(stuff[i][READ_LANG])) {
            return 1


    def do_bind(self, obs: MudObject) -> int:
            object *magic
            object *paper
            object *fail
            object ob
            object book
            string place
            int cost
            foreach (ob in obs) {
            if (ob.query_paper()) {
            if (check_for_magic_writing(ob)) {
            magic += [ob]
            } else {
            paper += [ob]


    def init(self, ) -> None:
            string storeroom
            ::init()
            storeroom = file_name(query_controller()->query_sell_list())
            add_command("browse", "page of <indirect:object:" + storeroom + ">",
            (: browse_pages($1) :) )
            set_extra_sell_check((: choose_which_page :))


    def browse_pages(self, obs: MudObject) -> int:
            object *real_obs
            object ob
            int number
            string mess
            string read
            object *no_pages
            object *ok
            int i
            if (!check_open(this_player(), "browse")) {
            return 0


    def exchanges_list(self, ) -> str:
            int i, value, smallest
            string list, *places
            if ( !sizeof( exchanges ) )
            return "There are no exchanges to be made here."
            list = ""
            places = keys( exchanges )
            for ( i = 0; i < sizeof( places ); i++ ) {
            list += places[ i ] +":\n      $I$+20,+10="+
            (string)MONEY_HAND.money_value_string( standard, place ) +
            " will buy: "
            value = ( exchanges[ places[ i ] ][ 0 ] * standard ) / 100
            smallest = MONEY_HAND.smallest_value_in( places[ i ] )
            if (value % smallest != 0)  value += smallest - (value % smallest)
            list += (string)MONEY_HAND.money_value_string( value, places[ i ] )
            if ( buy_only ) {
            list += ".$I$-20,-10="
            if ( i < sizeof( places ) - 1 )
            list += "\n"
            } else {
            list += ";$I$-20,-10=\n$I$+20,+10=      for "+
            (string)MONEY_HAND->money_value_string( standard,
            place ) +", sell: "
            value = ( 100 * standard ) / exchanges[ places[ i ] ][ 1 ]
            list += (string)MONEY_HAND->money_value_string( value,
            places[ i ] ) +".$I$-20,-10="
            if ( i < sizeof( places ) - 1 )
            list += "\n"


    def __init__(self):
            self.standard = 100
            self.place = "default"
            self.exchanges = ([ ])


    def init(self, ) -> None:
            ::init()
            add_command("buy", "[from] <string'" + implode(keys(exchanges), "|") +
            "'> with <indirect:object:me>",  (: do_buy( $1, $4[0] ) :) )
            if ( !buy_only ){
            add_command("sell" ,"<indirect:object:me'stuff'>",
            (:self.sell($1):))


    def do_buy(self, things: MudObject, country: str) -> int:
            int     value
            int     smallest
            object  thing
            object  money
            mixed  *change
            mixed  *monies
            mixed  *no_value
            string  word
            change = [})
            foreach (thing in things)  {
            if (thing.query_property("money"))  {
            change = MONEY_HAND->merge_money_arrays(change,
            thing.query_money_array())
            #ifdef USE_VAULT
            MONEY_VAULT.add_to_list(thing)
            #else
            thing.move("/room/rubbish")
            #endif


    def sell(self, things: MudObject) -> int:
            int value
            int test_val
            int first
            string *places
            string  a_place
            object thing
            object money
            mixed *monies
            mixed *change
            mixed *m_array_a
            mixed *m_array_b
            mixed *m_array_c
            m_array_a = [})
            foreach (thing in things)  {
            if (thing.query_property("money")) {
            m_array_a = MONEY_HAND->merge_money_arrays(m_array_a,
            thing.query_money_array())
            #ifdef USE_VAULT
            MONEY_VAULT.add_to_list(thing)
            #else
            thing.move("/room/rubbish")
            #endif


    def list(self, ) -> int:
            write( exchanges_list() +"\n" )
            return 1


    def __init__(self):


    def init(self, ) -> None:
            basic_room::init()
            craft_shop::init()


    def dest_me(self, ) -> None:
            craft_shop::dest_me()
            basic_room::dest_me()


    def __init__(self):


    def init(self, ) -> None:
            basic_room::init()
            craft_shop_category::init()


    def dest_me(self, ) -> None:
            craft_shop_category::dest_me()
            basic_room::dest_me()


    def __init__(self):


    def engrave_init(self, ) -> None:
            add_command( "engrave", "<string> on <indirect:object>",
            (: do_engrave($1, $4[0]) :))


    def engrave_objects(self, obs: MudObject, cost: int) -> int:
            return 0


    def init(self, ) -> None:
            engrave_init()


    def set_engrave_language(self, lang: str) -> None:
            _lingo = lang


    def __init__(self):
            self.buy_mess = []
            self.sell_mess = []
            self.list_mess = "$extra$"
            self.value_mess = "$ob$ is valued at $money$.\n"
            self.too_costly_mess = "$ob$ is worth too much to be sold here.\n"
            self.not_worthy_mess = "$ob$ is not worth enough to be sold here.\n"
            self.browse_mess = "$ob$ costs $money$, it looks like:\n$extra$"
            self.other_shops = []
            self.max_inventory = MAX_INVENTORY
            self.min_amount = 50
            self._strict_currency = 1


    def reset(self, ) -> None:
            if(!random(3)) {
            remove_property("inventory_loss")


    def set_buy_function(self, func: Any) -> None:
            if (stringp(func) || functionp(func)) {
            buy_func = func


    def set_sell_function(self, func: Any) -> None:
            if (stringp(func) || functionp(func)) {
            sell_func = func


    def set_value_function(self, func: Any) -> None:
            if (stringp(func) || functionp(func)) {
            value_func = func


    def set_too_costly_function(self, func: Any) -> None:
            if (stringp(func) || functionp(func)) {
            too_costly_func = func


    def set_cannot_sell_function(self, func: Any) -> None:
            if (stringp(func) || functionp(func)) {
            cannot_sell_func = func


    def set_browse_function(self, func: Any) -> None:
            if (stringp(func) || functionp(func)) {
            browse_func = func


    def set_list_function(self, func: Any) -> None:
            if (stringp(func) || functionp(func)) {
            list_func = func


    def set_sell_message(self, str: Any) -> None:
            sell_mess = str


    def set_buy_message(self, str: Any) -> None:
            buy_mess = str


    def set_value_message(self, str: Any) -> None:
            value_mess = str


    def set_too_costly_message(self, str: Any) -> None:
            too_costly_mess = str


    def set_not_worthy_message(self, str: Any) -> None:
            not_worthy_mess = str


    def set_browse_message(self, str: Any) -> None:
            browse_mess = str


    def set_list_message(self, str: Any) -> None:
            list_mess = str


    def set_open_condition(self, str: Any) -> None:
            if (functionp(str)) {
            ::set_open_function(str)
            } else if (intp(str)) {
            ::set_open_function( (: $(str) :) )
            } else if (pointerp(str)) {
            ::set_open_function( (: call_other($(str[0]), $(str[1]), $1) :) )
            } if ( stringp(str) ) {
            ::set_open_function( (: call_other( self, $(str), $1 ) :) )


    def set_no_steal(self, i: int) -> None:
            no_steal = i


    def set_steal_difficulty(self, i: int) -> None:
            steal_difficulty = i


    def set_sell_stolen(self, i: int) -> None:
            sell_stolen = i
            no_steal = 1


    def query_sell_mess(self, ) -> Any:
            return sell_mess


    def query_list_mess(self, ) -> Any:
            return list_mess


    def query_value_mess(self, ) -> Any:
            return value_mess


    def query_too_costly_mess(self, ) -> Any:
            return too_costly_mess


    def query_not_worthy_mess(self, ) -> Any:
            return not_worthy_mess


    def query_buy_mess(self, ) -> Any:
            return buy_mess


    def query_browse_mess(self, ) -> Any:
            return browse_mess


    def query_no_steal(self, ) -> int:
            return no_steal


    def query_steal_difficulty(self, i: int) -> int:
            return steal_difficulty


    def query_shoplift_response_handler(self, ) -> str:
            return shoplift_handler


    def query_shop(self, ) -> int:
            return 1


    def shoplift_success(self, ob: MudObject) -> MudObject:
            return ob


    def set_shoplift_response_handler(self, word: str) -> None:
            shoplift_handler = word


    def init(self, ) -> None:
            string room
            ::init()
            if(stringp(our_storeroom)) {
            room = our_storeroom
            } else if(our_storeroom) {
            room = file_name(our_storeroom)
            } else {
            tell_room(self,
            "Oh dear, we don't seem to have a storeroom.\n")


    def query_max_amount(self, ) -> int:
            return MAX_AMOUNT


    def query_min_amount(self, ) -> int:
            return min_amount


    def scaled_value(self, n: int) -> int:
            int i, tot, *fish
            fish = PAY_RATES
            if(n < fish[0]) {
            return n
            } else {
            tot = fish[0]
            n -= fish[0]


    def do_sell(self, in_obs: MudObject) -> int:
            int i, amt, total_amt
            string place, filename, *text = [})
            object money, *obs, *selling, *cannot, *stolen, storeob, one_item, *cre
            object thing
            mixed *m_array
            if(!is_open(this_player(), 0)) {
            return 0


    def creator_object(self, ob: MudObject) -> int:
            string path
            if ( file_name( ob )[0..2] == "/w/" ) {
            return 1


    def do_buy(self, obs: MudObject) -> int:
            int i, amt, ob_amt, total_cost
            string place
            object money, *to_buy, *cannot, *too_much
            object *creator_obs
            if(!is_open(this_player(), 0)) {
            return 0


    def do_buy_things(self, obs: MudObject, cost: int, pl: MudObject) -> None:
            int i, j
            string place
            object money, change
            mixed m_array, p_array
            place = query_property("place")
            if(!place || (place == "")) {
            place = "default"


    def do_list(self, ) -> int:
            object ob
            if(!is_open(this_player(), 0)) {
            return 0


    def do_list_these(self, obs: MudObject) -> int:
            if(!is_open(this_player(), 0)) {
            return 0


    def do_browse(self, obs: MudObject) -> int:
            int i, value
            string place
            if (!is_open(this_player(), 0)) {
            return 0


    def do_value(self, obs: MudObject) -> int:
            int i
            int val
            int total
            string place
            int obnum
            if(!is_open(this_player(), 0)) {
            return 0


    def shop_list(self, arr: Any, detail: int) -> str:
            int i, j, value, num
            string s, mon, place, *shorts, *vals
            object *list
            mapping inv, costs
            mixed ind
            if(pointerp(arr)) {
            list = arr
            } else {
            list = all_inventory(self)


    def set_store_room(self, ob: Any) -> None:
            if(stringp(ob)) {
            original_storeroom = ob
            our_storeroom = find_object(ob)
            if(!our_storeroom) {
            our_storeroom = load_object(ob)


    def guards(self, tp: MudObject) -> None:
            object ob
            if(environment(tp) != self && environment(tp) != our_storeroom) {
            return


    def query_store_room(self, ) -> MudObject:
            return our_storeroom


    def add_other_shop(self, shop: Any) -> None:
            other_shops += ({shop})


    def query_shop_type(self, ) -> str:
            return shop_type


    def set_shop_type(self, ty: str) -> None:
            shop_type = ty


    def set_strict_shop(self, i: int) -> None:
            strict_shop = i


    def query_strict_shop(self, ) -> int:
            return strict_shop


    def create_rep(self, ) -> MudObject:
            object ob
            ob = clone_object("/obj/monster")
            ob.set_name("rep")
            ob.set_short("sales rep")
            ob.add_adjective("sales")
            ob->set_long("This is tall strong looking sales rep.  He "
            "stares at you with bright piercing eyes.\n")
            ob.add_alias("Sales rep alias")
            ob.set_class("fighter")
            ob.set_race("human")
            ob.adjust_bon_str(15)
            ob.set_level(60)
            ARMOURY.request_weapon("dagger", 100)->move(ob)
            ARMOURY.request_armour("cloth robe", 100)->move(ob)
            ob.init_equip()
            ob.add_property("rep type", shop_type)
            all_inventory(ob)->add_property("mine", 1)
            return ob


    def send_out_reps(self, ) -> None:
            int i
            object ob
            for(i = 0; i < sizeof(other_shops); i++) {
            ob = (object)self.create_rep()
            ob.add_property("goto destination", other_shops[i])
            ob.add_property("goto property", "shop")
            ob->move(self,
            "$N stride$s determinedly into the room.")
            ob->add_triggered_action("froggy", "goto_destination",
            file_name(self), "rep_made_it")


    def rep_made_it(self, bing: int) -> None:
            object *obs, rep
            int i, cost
            if(!bing) {
            previous_object()->init_command("'Oh no!  I am utterly lost!")
            previous_object()->init_command("sigh")
            asyncio.create_task(self."set_up_return", 5, previous_object())
            return


    def create_mercenary(self, rep: MudObject) -> MudObject:
            object ob
            string nam
            if(rep) {
            nam = implode(rep.query_adjectives(), " ")+" "+rep.query_name()


    def do_rep_buy(self, bing: Any) -> None:
            object rep, *obs
            int cost
            rep = bing[0]
            obs = bing[1]
            cost = bing[2]
            rep.adjust_money(cost, "brass")
            rep.query_current_room()->do_buy(obs, cost, rep)
            obs.move(present("Sales rep alias", rep->query_current_room()))
            asyncio.create_task(self."set_up_return", 5, rep)


    def set_up_return(self, rep: MudObject) -> None:
            rep.add_property("goto destination", file_name(self))
            rep->add_triggered_action("froggy", "goto_destination",
            self, "rep_came_back")


    def rep_came_back(self, ) -> None:
            int i
            object *obs, *obs2, rep
            obs = previous_object()->find_inv_match("all", previous_object())
            obs2 = [})
            for(i = 0; i < sizeof(obs); i++) {
            if(obs[i]->query_property("mine")) {
            continue


    def summon_guards(self, tp: MudObject) -> None:
            object ob
            int i
            if(environment(tp) != self) {
            return


    def set_strict_currency(self, new_strict: int) -> None:
            _strict_currency = new_strict


    def query_strict_currency(self, ) -> int:
            return _strict_currency


    def event_shoplift(self, command_ob: MudObject, thief: MudObject, victim: MudObject) -> None:
            if(stringp(shoplift_handler)) {
            if(shoplift_handler != "none") {
            shoplift_handler.handle_shoplift(thief, victim)


    def tidy_inventory(self, ) -> None:
            object storeob
            object *inventory
            int i, inv_to_leave
            int count
            inv_to_leave = max_inventory - (max_inventory / 4)
            if(objectp(our_storeroom)) {
            storeob = our_storeroom
            } else {
            our_storeroom.rabbit_away()
            storeob = find_object(our_storeroom)


    def dest_me(self, ) -> None:
            if(our_storeroom)
            our_storeroom.dest_me()
            ::dest_me()


    def womble(self, ) -> None:


    def __init__(self):


    def init(self, ) -> None:
            basic_room::init()
            item_shop::init()


    def dest_me(self, ) -> None:
            item_shop::dest_me()
            basic_room::dest_me()


    def womble(self, ) -> None:


    def __init__(self):


    def init(self, ) -> None:
            outside::init()
            item_shop::init()


    def dest_me(self, ) -> None:
            item_shop::dest_me()
            outside::dest_me()


    def set_laundry_exit(self, direc: str, dest: Any, type: str) -> None:
            laundry_room = dest
            add_exit(direc, dest, type)
            modify_exit( direc, ["function", "check_customer"] )
            modify_exit( direc, ["closed", 1}))


    def check_customer(self, verb: str, thing: MudObject, special: str) -> int:
            string owner
            object vroom
            if(!laundryowner || environment(laundryowner) != self)
            return notify_fail("Since the owner of this laundry is missing "
            "you think twice before entering the laundry.\n")
            if( !interactive(thing) )
            return 0
            owner = (string)thing.query_name()
            if ( !( vroom = find_object( laundry_room ) ) )  {
            laundry_room.load_me()
            vroom = find_object( laundry_room )


    def player_quitting(self, who: MudObject, env: MudObject) -> None:


    def __init__(self):


    def init(self, ) -> None:
            ::init()
            add_command("change", "<string> {into|to} <string>",
            (: change($4[0], $4[2]) :) )


    def change(self, words: str, type: str) -> int:
            int val_index
            int value
            int value_type
            int value_unit
            int value_change
            int i
            string place
            mixed money
            object changed
            object *monies
            mixed *change
            mixed *values
            place = query_property( "place" )
            if ( !place || ( place == "" ) ) {
            place = "default"


    def __init__(self):


    def init(self, ) -> None:
            #ifdef __DISTRIBUTION_LIB__
            room::init()
            #else
            player_housing::init()
            #endif
            player_craft_shop::init()


    def dest_me(self, ) -> None:
            #ifdef __DISTRIBUTION_LIB__
            room::dest_me()
            #else
            player_craft_shop::dest_me()
            #endif
            player_housing::dest_me()


    def set_save_dir(self, dir: str) -> None:
            set_save_file(dir + "_main")
            #ifndef __DISTRIBUTION_LIB__
            ::set_save_dir(dir)
            #endif


    def is_allowed(self, name: str) -> int:
            if (name == "pinkfish") {
            return 1


    def event_exit(self, ob: MudObject, mess: str, to: MudObject) -> None:
            #ifdef __DISTRIBUTION_LIB__
            room::event_exit(ob, mess, to)
            #else
            player_housing::event_exit(ob, mess, to)
            #endif
            player_craft_shop::event_exit(ob, mess, to)


    def ownership_change(self, old_owner: str, new_owner: str) -> int:
            player_craft_shop::ownership_change(old_owner, new_owner)
            return player_housing::ownership_change(old_owner, new_owner)


    def __init__(self):


    def init(self, ) -> None:
            basic_room::init()
            pub::init()


    def dest_me(self, ) -> None:
            pub::dest_me()
            basic_room::dest_me()


    def __init__(self):


    def set_message_function(self, wossname: Any) -> None:
            _message_function = wossname


    def set_shopkeeper(self, name: str) -> None:
            _shopkeeper = name


    def query_shopkeeper(self, ) -> str:
            return _shopkeeper


    def shopkeeper_say(self, message: str) -> None:
            object *frog
            if( !message || message == "" )
            message = "Tuppence a bucket, well stamped down!"
            if( _shopkeeper ) {
            frog = match_objects_for_existence( _shopkeeper, self )
            if( sizeof( frog ) == 1 ) {
            frog[0]->init_command( "' "+ message )
            return


    def is_potion_or_salve(self, ob: MudObject) -> int:
            object thing, *contents
            int found_something
            string contents_string
            if( !ob.query_volume() ) {
            tell_creator( this_player(), "ob has 0 volume.\n" )
            if( _message_function )
            evaluate( _message_function,
            CONVERT( "There's nothing in "+ ob.the_short() +" that "
            "can be described as either potion or salve, "+
            this_player()->the_short() +".\n" ) )
            return 0
            } else if( ob.query_volume() < MIN_VOLUME ||
            ob.query_volume() < ( 7 * ob.query_max_volume() / 10 ) ) {
            tell_creator( this_player(), "ob does not contain enough stuff.\n" )
            if( _message_function )
            evaluate( _message_function,
            CONVERT( "We don't deal in quantities smaller than a cup, "+
            this_player()->the_short() +".\n" ) )
            return 0


    def __init__(self):
            self.letter_cost = DEFAULT_LETTER_COST
            self.time_to_collect = DEFAULT_TIME_TO_COLLECT
            self.time_per_copy = DEFAULT_TIME_PER_COPY
            self.collectables = ([ ])
            self.discount_schedule = ['({ 100', '5 })']
            self.default_language = "common"
            self.translation_costs = ([ ])
            self.print_shop_name = "Rabbits happy little printing press"


    def init(self, ) -> None:
            string languages
            if (!office_room) {
            add_command("print", "<indirect:object>",
            (: do_print($1, default_language) :))
            add_command("print", "<number> [copies] of <indirect:object>",
            (: do_print_copies($1, $4[0], default_language) :) )
            add_command("claim", "copyright on <indirect:object>", (: do_claim :))
            if (sizeof(translation_costs)) {
            languages = implode(keys(translation_costs) + [default_language], "|")
            add_command("print", "<indirect:object> in {" + languages + "}",
            (: do_print($1, $4[1]) :))
            add_command("print", "<number> [copies] of <indirect:object> in "
            "{" + languages + "}",
            (: do_print_copies($1, $4[0], $4[2]) :) )


    def check_for_magic_writing(self, ob: MudObject) -> int:
            mixed *stuff
            int i
            stuff = ob.query_read_mess()
            for (i = 0; i < sizeof(stuff); i++) {
            if (LANGUAGE_HAND.query_language_magic(stuff[i][READ_LANG])) {
            return 1


    def check_for_untranslatable_language(self, ob: MudObject) -> int:
            mixed *stuff
            int i
            string lang
            stuff = ob.query_read_mess()
            for (i = 0; i < sizeof(stuff); i++) {
            lang = stuff[i][READ_LANG]
            if (lang != default_language &&
            !translation_costs[lang]) {
            return 1


    def find_book_or_paper(self, obs: MudObject) -> MudObject:
            object *paper
            object *books
            object *magic
            object *torn_out
            object *nothing
            object ob
            int page
            int old_page
            string owner
            paper = [})
            books = [})
            magic = [})
            torn_out = [})
            nothing = [})
            foreach (ob in obs) {
            owner = copyright_holder(ob)
            if (is_copyright(ob) && owner != this_player()->query_name()) {
            add_failed_mess("$I has been copyrighted by " + owner +
            " and cannot be copied.\n", [ob])
            } else if (ob.query_book()) {
            if (ob.query_spell_book()) {
            magic += [ob]
            } else {
            old_page = ob.query_open_page()
            for (page = 0; page <= ob.query_num_pages(); page++) {
            ob.set_open_page(page)
            if (ob.is_current_page_torn_out()) {
            torn_out += [ob]
            break


    def do_print(self, obs: MudObject, language: str) -> int:
            object ob
            if (open_func) {
            if (!evaluate(open_func, obs)) {
            return 0


    def do_print_copies(self, obs: MudObject, number: int, language: str) -> int:
            object ob
            int cost
            int player_money
            string place
            if (open_func) {
            if (!evaluate(open_func, obs)) {
            return 0


    def check_cost(self, str: str, ob: MudObject, number: int, cost: int, language: str) -> None:
            if (strlen(str) < 1 || (str[0] != 'y' && str[0] != 'Y')) {
            write("Ok, don't worry.  See you again.\n")
            return


    def do_print_run(self, ob: MudObject, number: int, cost: int, language: str) -> None:
            string place
            int player_money
            mixed *stuff
            place = query_property( "place" )
            if ( !place || ( place == "" ) ) {
            place = "default"


    def price_object(self, ob: MudObject, num: int, to_language: str) -> int:
            int i
            int num_letters
            int multiplier
            int cost
            mixed *stuff
            if (num <= 0 || !ob) {
            return 0


    def print_pricing(self, ob: MudObject, language: str) -> None:
            int i
            int num
            string place
            int cost
            place = query_property( "place" )
            if ( !place || ( place == "" ) ) {
            place = "default"


    def set_discount_schedule(self, value: Any) -> None:
            discount_schedule = value


    def query_letter_cost(self, ) -> int:
            return letter_cost


    def set_letter_cost(self, value: int) -> None:
            letter_cost = value


    def add_print_run(self, name: str, ob: MudObject, number: int, language: str) -> None:
            mixed *arr
            int num
            if (!collectables[name]) {
            collectables[name] = [})


    def remove_print_run(self, name: str, info: Any) -> None:
            int index
            if (collectables[name]) {
            index = collectables[name].index(info) if info in collectables[name] else -1
            if (index != -1) {
            remove_auto_load_info(info[COLLECT_AUTO_LOAD_NUM])
            collectables[name] = collectables[name][0.. index - 1] +
            collectables[name][index + 1..]
            if (!sizeof(collectables[name])) {
            map_delete(collectables, name)


    def query_static_auto_load_info(self, num: int) -> str:
            string *arr
            string tmp
            if (unguarded( (: file_size(save_dir + "/" + $(num)) :) ) > 0) {
            tmp = unguarded( (: read_file(save_dir + "/" + $(num)) :) )
            if (tmp) {
            arr = restore_variable(tmp)
            return arr[0]


    def set_save_dir(self, name: str) -> None:
            save_dir = name


    def query_save_dir(self, ) -> str:
            return save_dir


    def load_it(self, ) -> None:
            if (save_dir) {
            unguarded((: restore_object(save_dir + "/main") :))
            if (!collectables) {
            collectables = ([ ])


    def save_it(self, ) -> None:
            if (save_dir) {
            unguarded((: save_object(save_dir + "/main") :))


    def set_office_room(self, room: str) -> None:
            office_room = room


    def query_office_room(self, ) -> str:
            return office_room


    def set_no_collection(self, collect: int) -> None:
            no_collection = collect


    def query_no_collection(self, ) -> int:
            return no_collection


    def set_open_func(self, func: Any) -> None:
            open_func = func


    def set_default_language(self, lang: str) -> None:
            default_language = lang


    def query_default_language(self, ) -> str:
            return default_language


    def add_translation_cost(self, lang: str, cost: int) -> None:
            translation_costs[lang] = cost


    def remove_translation_cost(self, lang: str) -> None:
            map_delete(translation_costs, lang)


    def set_print_shop_name(self, name: str) -> None:
            print_shop_name = name


    def query_print_shop_name(self, ) -> str:
            return print_shop_name


    def __init__(self):


    def init(self, ) -> None:
            basic_room::init()
            pub::init()


    def dest_me(self, ) -> None:
            pub::dest_me()
            basic_room::dest_me()


    def __init__(self):


    def init(self, ) -> None:
            outside::init()
            pub::init()


    def dest_me(self, ) -> None:
            pub::dest_me()
            outside::dest_me()


    def __init__(self):
            self._areas = []
            self._city = "Ankh-Morpork"
            self._language = "morporkian"


    def reset(self, ) -> None:
            {
            asyncio.create_task(self."after_reset", 10)


    def add_housing_area(self, area: str) -> None:
            _areas += [area]


    def after_reset(self, ) -> None:
            {
            string house
            string *available
            int i
            string area
            foreach (area in _areas) {
            available = HOUSING.query_vacant(area)
            if (sizeof(available)) {
            i = 1
            foreach(house in available) {
            asyncio.create_task(self."add_house", i++, house)


    def add_house(self, house: str) -> int:
            {
            object agreement
            string text
            int tim
            if (keys(HOUSING.query_houses(.index(house) if house in keys(HOUSING.query_houses( else -1)) == -1) {
            return 0


    def do_agreement(self, ) -> int:
            {
            string *houses
            int i
            string place
            place = query_property("place")
            if (this_player()->query_value_in(place) < NEW_AGREEMENT_COST) {
            add_failed_mess("You need " +
            MONEY_HAND->
            money_value_string(NEW_AGREEMENT_COST,
            place) +
            " to get a new agreement.\n")
            return 0


    def init(self, ) -> None:
            {
            ::init()
            add_command("request", "[agreement]", (: do_agreement() :))


    def reset_auctions_to_under_offer(self, ) -> None:
            class auction auc
            foreach( auc in query_auctions() ) {
            HOUSING.set_under_offer(auc->extra)


    def set_city(self, where: str) -> None:
            _city = where


    def set_language(self, lang: str) -> None:
            _language = lang


    def query_city(self, ) -> str:
            return _city


    def query_language(self, ) -> str:
            return _language


    def __init__(self):
            self._signtypes = []
            self._paintcolours = ([ ])
            self._signs = ([ ])


    def is_open(self, ) -> int:
            if (_open_func) {
            return evaluate(_open_func)


    def set_open_func(self, func: Any) -> None:
            _open_func = func


    def set_language(self, lang: str) -> None:
            _language = lang


    def query_language(self, ) -> str:
            return _language


    def set_save_file_name(self, save: str) -> None:
            _save_file = save


    def query_save_file_name(self, ) -> str:
            return _save_file


    def do_save(self, ) -> None:
            if (_save_file) {
            save_object(_save_file)


    def do_load(self, ) -> None:
            if (_save_file) {
            restore_object(_save_file)


    def add_paint_colour(self, colour: str, cost: int) -> None:
            _paintcolours[colour] = cost


    def do_order(self, type: str) -> int:
            int pos
            int cost
            string place
            if (!is_open()) {
            add_failed_mess(the_short() + " is not currently open.\n")
            return 0


    def finish_editing_message(self, mess: str, type: int) -> None:
            string colour
            int cost
            string place
            class sign_type bing
            if (!mess) {
            write("Aborting sign writing process.\n")
            return


    def finish_sign(self, colour: str, type: int, mess: str) -> None:
            int cost
            string place
            class sign_type bing
            colour = lower_case(colour)
            bing = _signtypes[type]
            if (!strlen(colour)) {
            write("Aborting the sign process.\n")
            return


    def do_collect(self, ) -> int:
            class sign_making sign
            class sign_type type
            object* ok
            string* not_yet
            string* bits
            object ob
            if (!is_open()) {
            add_failed_mess(the_short() + " is not currently open.\n")
            return 0


    def do_browse(self, type: str) -> int:
            class sign_type bing
            string place
            int pos
            if (!is_open()) {
            add_failed_mess(the_short() + " is not currently open.\n")
            return 0


    def do_list(self, ) -> int:
            class sign_type bing
            int i
            string ret
            string place
            string colour
            int cost
            if (!is_open()) {
            add_failed_mess(the_short() + " is not currently open.\n")
            return 0


    def init(self, ) -> None:
            add_command("list", "", (: do_list() :))
            add_command("browse", "<string'sign'>", (: do_browse($4[0]) :))
            add_command("collect", "sign", (: do_collect() :))
            add_command("buy", "<string'sign'>", (: do_order($4[0]) :))
            add_command("order", "<string'sign'>", (: do_order($4[0]) :))


    def __init__(self):
            self.room_cont = ([ ])
            self.shop_type = ([ ])
            self.max_num = 8
            self.loot = random(10)


    def add_thing(self, ob: MudObject) -> None:
            string shr
            if (!ob || environment(ob) != self)
            return
            shr = (string)ob.query_property("shop type")
            if (!shop_type[shr])
            shop_type[shr] = [ob]
            else
            shop_type[shr] += [ob]
            shr = (string)ob.short()
            if (!room_cont[shr]) {
            room_cont[shr] = [ob]
            return


    def test_cont(self, ) -> None:
            int i
            object *obs
            obs = all_inventory()
            for (i=0;i<sizeof(obs);i++)
            add_thing(obs[i])


    def remove_thing(self, ob: MudObject) -> None:
            mixed *arr
            int i
            string sh
            if (!ob || environment(ob) == self)
            return
            sh = (string)ob.query_property("shop type")
            if (shop_type[sh])
            shop_type[sh] = (object *)shop_type[sh] - [ob]
            sh = (string)ob.short()
            if (!room_cont[sh])
            return
            arr = room_cont[sh]
            if ((i = arr.index(ob) if ob in arr else -1) == -1)
            return
            if (sizeof(arr) <= 1) {
            room_cont = m_delete(room_cont, sh)
            } else
            room_cont[sh] = delete(arr, i, 1)


    def event_enter(self, ob: MudObject, string, object) -> None:
            asyncio.create_task(self."add_thing", 1, ob)


    def event_exit(self, ob: MudObject, mesage: str, to: MudObject) -> None:
            asyncio.create_task(self."remove_thing", 1, ob)


    def do_dest(self, thing: MudObject) -> None:
            if ( !thing )
            return
            thing.move( "/room/rubbish" )


    def set_vault_exit(self, direc: str, dest: Any, type: str) -> None:
            _entry = dest
            add_exit(direc, dest, type)
            modify_exit( direc, ["function", "check_done"] )
            modify_exit( direc, ["closed", 1] )


    def init_container(self, person: MudObject) -> MudObject:
            object container
            string owner
            owner = person.query_name()
            container = clone_object( "/obj/cont_save" )
            container.set_max_weight( 1000 )
            container.set_open()
            container.set_stuck( 1 )
            container.set_can_recurse(1)
            container.reset_get()
            container->set_save_file( VAULT_SAVE +_vault_name+ "/"+ owner,
            person )
            if ( !master()->file_exists( VAULT_SAVE +_vault_name+"/"+ owner +".o" ) ) {
            container.add_property( "owner", owner )
            container.do_save()


    def event_enter(self, thing: MudObject, mess: str, from: MudObject) -> None:
            string owner
            if( !userp( thing ) )
            return
            owner = thing.query_name()
            if ( _container ) {
            if((string)_container.query_property( "owner" ) == owner)
            return
            else if(thing.query_creator() &&
            find_player(_container.query_property( "owner" )) &&
            environment(find_player(_container.query_property( "owner" ))) ==
            self)
            return
            else {
            _container.dest_me()
            _container = 0


    def fix_owner(self, owner: str) -> None:
            if (_container) {
            _container.add_property( "owner", owner )
            if(_there) {
            _container.add_property("there", _there)


    def check_done(self, verb: str, thing: MudObject, special: str) -> int:
            if ( thing.query_auto_loading() ) {
            tell_room( self, "The door swings shut.\n" )
            tell_object( thing, "Your vaults's inventory is still being generated.\n"
            "Please wait until it is completed.\n" )
            return notify_fail( "" )


    def event_exit(self, thing: MudObject, message: str, to: MudObject) -> None:
            if(_container && _container.query_property("owner") == thing.query_name()) {
            _container.move("/room/void")
            asyncio.create_task(self.(: _container.dest_me() :), 1)


    def query_quit_handler(self, ) -> str:
            return _entry


    def setup_container(self, container: MudObject) -> None:
            container.set_name( "drawer" )
            container.set_short( "drawer" )
            container.add_alias( "drawer" )
            container->set_long("The single open drawer is sticking straight "
            "out of the wall like...  well, like a drawer sticking "
            "straight out of the wall.  " )


    def trap_action(self, str: str) -> int:
            string st1
            if( sscanf( str,"%s %s", str, st1 ) )
            switch(str) {
            case "circle":
            tell_object( this_player(),
            "Something tells you that drawing a circle in this location "
            "would be a bad idea.\n")
            return 1
            case "erect":
            tell_object( this_player(),
            "You can't seem to get the tent to unfold properly.  "
            "Perhaps you should try it somewhere else.\n")
            return 1
            default:
            return 0


    def event_net_dead(self, ob: MudObject) -> None:
            ob.move_with_look(_entry)


    def init(self, ) -> None:
            ::init()
            this_player()->command_override( (: trap_action :) )


    def query_vault_room(self, ) -> int:
            return 1


    def __init__(self):


    def init(self, ) -> None:
            basic_room::init()
            vault_entry::init()


    def __init__(self):
            self._sell_list = clone_object("/std/container")
            self._current_save_num = 1
            self._current_ids = []
            self._categories = ([ ])


    def set_dont_use_name(self, flag: int) -> None:
            _category_dont_use_name = flag


    def query_dont_use_name(self, ) -> int:
            return _category_dont_use_name


    def remove_list_object(self, name: str, owner: str, craft_object: Any) -> None:
            int i
            object us
            class craft_object *data
            if (_sellables[name] &&
            ((class craft_sellable)_sellables[name])->objects[owner]) {
            data = ((class craft_sellable)_sellables[name])->objects[owner]
            for (i = 0; i < sizeof(data); i++) {
            if (data[i] == ob) {
            break


    def create_real_object(self, player: MudObject, craft_object: Any) -> MudObject:
            return create_real_auto_load_object(craft->ob_num, player)


    def query_owner_of_shop_object(self, ob: MudObject) -> str:
            return ob.query_property(SELL_OBJECT_OWNER_PROP)


    def query_name_of_shop_object(self, ob: MudObject) -> str:
            return ob.query_property(SELL_OBJECT_NAME_PROP)


    def query_id_of_shop_object(self, ob: MudObject) -> str:
            return ob.query_property(SELL_OBJECT_ID_PROP)


    def set_id_of_shop_objects(self, obs: MudObject, id: str) -> None:
            obs.add_property(SELL_OBJECT_ID_PROP, id)
            obs.add_alias(id)


    def query_category_of_shop_object(self, ob: MudObject) -> str:
            class craft_object craft
            craft = query_class_of_shop_object(ob)
            if (craft) {
            return craft->category


    def query_short_of_shop_object(self, ob: MudObject) -> str:
            class craft_object craft
            craft = query_class_of_shop_object(ob)
            if (craft) {
            if (sizeof(craft) == 5) {
            return craft->short


    def update_craft_object(self, craft_ob: MudObject, replacement_ob: MudObject) -> None:
            class craft_object craft
            craft = query_class_of_shop_object(craft_ob)
            if (craft) {
            create_auto_load_file(replacement_ob, craft->ob_num)


    def query_next_shop_id(self, ) -> str:
            int num
            num = 0
            while (_current_ids.index(num) if num in _current_ids else -1 != -1) {
            num++


    def remove_shop_id(self, id: str) -> None:
            int real_id
            real_id = (id[0] * 26) - 'a' + id[1] - 'a'
            _current_ids -= [real_id]


    def find_shop_object(self, craft_object: Any) -> MudObject:
            object ob
            foreach (ob in query_sell_list_obs()) {
            if (query_class_of_shop_object(ob) == frog) {
            return ob


    def change_value_of_shop_object(self, ob: MudObject, value: int) -> None:
            string owner
            string name
            class craft_object wombat
            object* obs
            obs = query_items_with_shop_id(query_id_of_shop_object(ob))
            foreach (ob in obs) {
            owner = query_owner_of_shop_object(ob)
            name = query_name_of_shop_object(ob)
            wombat = query_class_of_shop_object(ob)
            wombat->cost = value
            ob.set_value(value)


    def change_category_of_shop_object(self, ob: MudObject, new_category: str) -> int:
            string owner
            string name
            class craft_object bing
            object* obs
            int do_save
            obs = query_items_with_shop_id(query_id_of_shop_object(ob))
            foreach (ob in obs) {
            owner = query_owner_of_shop_object(ob)
            name = query_name_of_shop_object(ob)
            if (!_sellables[name] ||
            !((class craft_sellable)_sellables[name])->objects[owner]) {
            return 0


    def remove_shop_object(self, ob: MudObject) -> None:
            string name
            string owner
            owner = query_owner_of_shop_object(ob)
            name = query_name_of_shop_object(ob)
            remove_list_object(name, owner, query_class_of_shop_object(ob))


    def value_of_objects(self, obs: MudObject) -> int:
            object ob
            class craft_object craft
            int value
            foreach (ob in obs) {
            craft = query_class_of_shop_object(ob)
            if (craft) {
            value += craft->cost


    def delete_objects(self, id: str) -> None:
            object ob, *obs
            obs = all_inventory( _sell_list )
            obs = filter( obs,
            (: $1.query_property( SELL_OBJECT_ID_PROP ) == $(id) :) )
            foreach( ob in obs ) {
            remove_shop_object( ob )


    def query_sell_list(self, ) -> MudObject:
            return _sell_list


    def query_items_with_shop_id(self, id: str) -> List[MudObject]:
            return filter(query_sell_list_obs(), (: query_id_of_shop_object($1) == $2 :),
            id)


    def query_list_object_cost(self, name: str, owner: str) -> int:
            class craft_sellable sell
            class craft_object wombat
            owner = lower_case(owner)
            if (_sellables[name]) {
            sell = _sellables[name]
            if (sell->objects[owner]) {
            wombat = sell->objects[owner][0]
            return wombat->cost


    def set_save_function(self, func: Any) -> None:
            _save_function = func


    def set_load_function(self, func: Any) -> None:
            _load_function = func


    def set_category_function(self, func: Any) -> None:
            _category_function = func


    def save_it(self, ) -> None:
            if (_has_loaded) {
            evaluate(_save_function, CRAFT_SHOP_MAIN_SAVE_FILE,
            [_sellables, _royalties, _current_save_num, _categories] )


    def load_it(self, ) -> None:
            mixed *map
            string name
            _has_loaded = 1
            map = evaluate(_load_function, CRAFT_SHOP_MAIN_SAVE_FILE)
            if (pointerp(map) && sizeof(map) == 3) {
            _sellables = map[0]
            _royalties = map[1]
            _current_save_num = map[2]
            foreach (name in keys(_sellables)) {
            reset_eval_cost()
            update_sellable(name)


    def adjust_royalty(self, player: str, amt: int) -> None:
            _royalties[player] += amt
            save_it()


    def query_royalty(self, player: str) -> int:
            return _royalties[player]


    def pay_out_royalty(self, player: str, place: str, amount: int) -> None:
            object pl
            pl = find_player(player)
            if (pl && _royalties[player]) {
            if (!amount) {
            amount = _royalties[player]


    def is_valid_category(self, category: str) -> int:
            if (_categories[category] &&
            (_categories[category]->state == CRAFT_CATEGORY_STATE_ACCEPTED ||
            _categories[category]->state == CRAFT_CATEGORY_STATE_DELETEING)) {
            return 1


    def remove_category_accepted(self, category: str) -> int:
            if (_categories[category]) {
            map_delete(_categories, category)
            save_it()
            return 1


    def add_category_accepted(self, name: str) -> int:
            if (!_categories[name]) {
            _categories[name] = new(class craft_category)
            _categories[name]->state = CRAFT_CATEGORY_STATE_ACCEPTED
            _categories[name]->voted = [})
            _categories[name]->description = 0
            _categories[name]->yes = 0
            _categories[name]->no = 0
            _categories[name]->timeout = 0
            save_it()
            return 1


    def set_category_description(self, cat: str, desc: str) -> None:
            if (_categories[cat]) {
            _categories[cat]->description = desc
            save_it()


    def query_category_description(self, cat: str) -> str:
            if (_categories[cat]) {
            if (stringp(_categories[cat]->description)) {
            return _categories[cat]->description


    def set_category_information(self, cat: str, info: str) -> None:
            if (_categories[cat]) {
            _categories[cat]->information = info
            save_it()


    def query_category_information(self, cat: str) -> str:
            if (_categories[cat]) {
            if (stringp(_categories[cat]->information)) {
            return _categories[cat]->information


    def query_category_of(self, name: str, owner: str) -> str:
            if (_sellables[name] &&
            sizeof( ((class craft_sellable)_sellables[name])->objects[owner])) {
            return ((class craft_sellable)_sellables[name])->objects[owner][0]->category


    def query_category_timeout(self, name: str) -> int:
            if (_categories[name]) {
            return _categories[name]->timeout


    def dest_me(self, ) -> None:
            if(_sell_list) {
            all_inventory(_sell_list)->move("/room/rubbish")
            _sell_list.dest_me()


    def __init__(self):
            self._auctions = []
            self._finished_auctions = []
            self._cut = 10
            self._max_auctions = 20
            self._auction_obs = []
            self._royalties = ([ ])
            self._auction_times = ([
            self._retrieval_time = DEFAULT_RETRIEVAL_TIME
            self._max_retries = 5
            self._minimum_bid_increase = 10
            self._allow_add = 1


    def load_me(self, ) -> None:
            unguarded( (: restore_object(_save_file, 1) :))
            _auction_obs = allocate(sizeof(_auctions))
            if (!_royalties) {
            _royalties = ([ ])


    def save_me(self, ) -> None:
            unguarded( (: save_object(_save_file) :))


    def set_save_file(self, fname: str) -> None:
            _save_file = fname
            load_me()


    def query_save_file(self, ) -> str:
            return _save_file


    def set_check_can_bid(self, f: Any) -> None:
            _can_bid = f


    def set_allowed_add(self, flag: int) -> None:
            _allow_add = flag


    def set_auction_time(self, index: str, i: int) -> None:
            if (!i) {
            map_delete(_auction_times, index)
            } else {
            if (!_auction_times[index]) {
            _bid_type_names = 0


    def set_min_bid_increase(self, i: int) -> None:
            int add_item_to_auction(object* obs, string name, int reserve,
            string seller, int length,
            string end_function, mixed extra) {
            class auction new_auct
            if (sizeof(_auctions) + sizeof(_finished_auctions) >= _max_auctions) {
            return 0


    def query_auction_objects(self, auction: Any) -> List[MudObject]:
            int i
            for (i = 0; i < sizeof(_auctions); i++) {
            if (_auctions[i] == auct) {
            if (!_auction_obs[i]) {
            _auction_obs[i] = AUTO_LOAD_OB.load_auto_load_to_array(auct->save_stuff)


    def reset_bid(self, id: str, bid: int, person: str) -> int:
            class auction auct
            if(!(this_player()->query_lord()))
            return 0
            auct = query_auction_item(id)
            if(!auct)
            return 0
            auct->bid = bid
            auct->current_bidder = person
            return 1


    def remove_finished_auction_item(self, auction: Any) -> None:
            int i
            for (i = 0; i < sizeof(_finished_auctions); i++) {
            if (_finished_auctions[i] == auction) {
            _finished_auctions = _finished_auctions[0..i-1] + _finished_auctions[i+1..]


    def remove_auction_item(self, auction: Any) -> None:
            int i
            for (i = 0; i < sizeof(_auctions); i++) {
            if (_auctions[i] == auction) {
            if (i < sizeof(_auction_obs) && _auction_obs[i]) {
            ((_auction_obs[i]) - [0])->move("/room/rubbish")


    def finish_auction(self, auction: Any) -> None:
            string place
            if (auction->end_function) {
            call_other(self, auction->end_function,
            AUCTION_FINISH_PHASE, auction, auction->extra,
            auction->current_bidder, auction->bid)


    def force_finish_auction(self, id: str) -> None:
            string place
            class auction auction
            auction = query_auction_item(id)
            if (auction->end_function) {
            call_other(self, auction->end_function,
            AUCTION_FINISH_PHASE, auction, auction->extra,
            auction->current_bidder, auction->bid)


    def retry_auction(self, auction: Any) -> None:
            string place
            if (auction->end_function) {
            call_other(self, auction->end_function,
            AUCTION_RETRY_PHASE, auction, auction->extra)


    def query_time_end_string(self, left: int) -> str:
            string str
            string extra
            if (left >= AM_SECONDS_PER_DAY) {
            str = (left / AM_SECONDS_PER_DAY) + " day"
            if ((left / AM_SECONDS_PER_DAY) > 1) {
            str += "s"


    def query_auction_end_string(self, auction: Any) -> str:
            return query_time_end_string(auction->time_started +
            auction->auction_length - time())


    def query_last_auction_finish_time(self, ) -> int:
            int tim
            class auction auction
            foreach (auction in _auctions) {
            if (tim < auction->time_started + auction->auction_length) {
            tim = auction->time_started + auction->auction_length


    def next_auction_finish(self, ) -> None:
            class auction auct
            int next
            int tmp
            next = 0
            foreach (auct in _auctions) {
            tmp = auct->time_started + auct->auction_length - time()
            if (tmp <= 0) {
            finish_auction(auct)
            } else if (tmp < next || !next) {
            next = tmp


    def do_list(self, ) -> int:
            string str
            class auction bing
            int pos
            string place
            if (!is_open(this_player(), 0)) {
            add_failed_mess(self.the_short() + " is not open.\n")
            return 0


    def do_browse(self, id: str) -> int:
            class auction bing
            string place
            string str
            object* obs
            object ob
            if (!is_open(this_player(), 0)) {
            add_failed_mess(self.the_short() + " is not open.\n")
            return 0


    def do_bid(self, id: str, bid: str) -> int:
            class auction auct
            string place
            int value
            int inc
            if (!is_open(this_player(), 0)) {
            add_failed_mess(self.the_short() + " is not open.\n")
            return 0


    def do_withdraw(self, id: str) -> int:
            class auction auct
            string place
            int value
            object* obs
            object ob
            if (!is_open(this_player(), 0)) {
            add_failed_mess(self.the_short() + " is not open.\n")
            return 0


    def do_claim(self, ) -> int:
            class auction auction
            int num
            string place
            object* obs
            object ob
            int i
            int value
            if (!is_open(this_player(), 0)) {
            add_failed_mess(self.the_short() + " is not open.\n")
            return 0


    def do_add(self, name: str, obs: Any, res_str: str, length: str) -> int:
            int reserve
            string ret
            string place
            int len
            if (!is_open(this_player(), 0)) {
            add_failed_mess(self.the_short() + " is not open.\n")
            return 0


    def confirm_auction(self, check: str, name: str, obs: Any, reserve: int, len: int) -> None:
            string place
            string ret
            place = query_property("place")
            check = lower_case(check)
            if (!strlen(check) || check[0] != 'y') {
            if (!broadcast_shop_event(AUCTION_EVENT_ADD_ABORT,
            this_player(), name, obs, reserve, len)) {
            write("Ok, Aborting.\n")


    def do_info(self, ) -> int:
            string ret
            string name
            int len
            if (!is_open(this_player(), 0)) {
            add_failed_mess(self.the_short() + " is not open.\n")
            return 0


    def init(self, ) -> None:
            add_command("list", "", (: do_list() :))
            add_command("browse", "<string'auction id'>", (: do_browse($4[0]) :))
            add_command("bid", "<string'auction id'> for <string'money'>",
            (: do_bid($4[0], $4[1]) :))
            add_command("bid", "<string'money'> on <string'auction id'>",
            (: do_bid($4[1], $4[0]) :))
            add_command("claim", "", (: do_claim() :))
            add_command("withdraw", "<string'auction id'> [from auction]",
            (: do_withdraw($4[0]) :))
            if (_allow_add) {
            if (!_bid_type_names) {
            _bid_type_names = implode(keys(_auction_times), "|")


    def __init__(self):
            self._account_cost = 400
            self._total_difference = 0
            self._percentage = 10


    def query_bank(self, ) -> int:
            return 1


    def adjust_total_difference(self, amount: int) -> None:
            _total_difference += amount


    def set_total_difference(self, amount: int) -> None:
            _total_difference = amount


    def get_account(self, player: str) -> int:
            return HANDLER.query_account( player, _bank_name )


    def set_account(self, player: str, amount: int) -> None:
            HANDLER.set_account( player, _bank_name, amount )


    def adjust_account(self, person: str, amount: int) -> None:


    def query_franchise(self, ) -> str:
            return _franchise


    def set_franchise(self, franchise: str) -> None:
            _franchise = franchise


    def can_adjust_account(self, person: str, amount: int) -> int:
            if ( ( get_account( person ) + amount ) >= 0 ) {
            return 1


    def find_main_bank(self, ) -> MudObject:
            object office
            string room
            room = BANK_HANDLER.query_bank_master_office(_bank_name)
            if (!room) {
            return 0


    def query_main_branch_owner(self, ) -> str:
            object branch
            branch = find_main_bank()
            if (!branch) {
            return "no owner"


    def do_balance(self, ) -> int:
            int amount
            if (!query_bank_name()) {
            add_failed_mess("This is a forgotten bank in a dusty land.\n")
            return 0


    def do_withdraw(self, type: str) -> int:
            int amount
            int total
            object money
            if (this_player()->query_property("dead"))  {
            add_failed_mess("You are dead.  You know what they say; you can't take "
            "it with you.\n")
            return 0


    def do_deposit(self, words: str) -> int:
            int amount
            int total
            int tmp
            int howmuch
            mixed money
            if (!query_bank_name()) {
            add_failed_mess("This is a forgotten bank in a dusty land.\n")
            return 0


    def do_open(self, ) -> int:
            int amount
            if (!is_open_for("open account", this_player()->query_name())) {
            add_failed_mess("The bank is not open for new accounts.\n")
            return 0


    def check_open(self, word: str) -> None:
            object money
            int amount
            object main
            word = lower_case( word )
            if (!strlen(word) || word [ 0 ] !=  'y') {
            write( "Okay, not opening an account.\n" )
            return


    def do_close(self, ) -> int:
            int total
            object money
            total = get_account(this_player()->query_name())
            if ( total < 0 ) {
            notify_fail( "You do not have an account here.\n" )
            return 0


    def init(self, ) -> None:
            add_command( "balance", "" )
            add_command( "withdraw", "<string>",
            (: do_withdraw($4[0]) :) )
            add_command( "open", "account" )
            add_command( "close", "account" )
            add_command( "deposit", "<string>", (: do_deposit($4[0]) :) )


    def __init__(self):
            self._notes = []


    def is_allowed(self, name: str) -> int:
            return 0


    def is_allowed_credit(self, name: str) -> int:
            return is_allowed(name) ||
            name == query_main_branch_owner()


    def query_credit_num(self, ) -> int:
            return _credit_num


    def query_outstanding_credit_value(self, ) -> int:
            int diff
            class credit_note note
            foreach (note in _notes) {
            diff += note->amt


    def do_create(self, ) -> int:
            object ob
            int diff
            if (!is_allowed_credit(this_player()->query_name())) {
            add_failed_mess("The bank is not open for creating credit notes.\n")
            return 0


    def do_list(self, ) -> int:
            class credit_note note
            string ret
            string place
            if (!is_allowed_credit(this_player()->query_name())) {
            add_failed_mess("The bank is not open for listing credit notes.\n")
            return 0


    def do_recind(self, id: int) -> int:
            class credit_note note
            int i
            string place
            if (!is_allowed_credit(this_player()->query_name())) {
            add_failed_mess("The bank is not open for listing credit notes.\n")
            return 0


    def is_valid_note(self, id: int) -> int:
            int i
            for (i = 0; i < sizeof(_notes); i++) {
            if (_notes[i]->num == id) {
            return 1


    def process_note(self, id: int) -> int:
            int i
            if (!is_valid_note(id)) {
            return 0


    def init(self, ) -> None:
            ::init()
            add_command("create", "credit note")
            add_command("list", "credit notes")
            add_command("recind", "credit note <number'id'>", (: do_recind($4[0]) :))


    def do_process(self, obs: MudObject) -> int:
            object ob
            int amount
            int found
            object* not_credit
            object* not_valid
            string place
            place = query_money_place()
            not_valid = [})
            not_credit = [})
            foreach (ob in obs) {
            if (ob.query_credit_note() ||
            ob.query_bank_name() != query_bank_name()) {
            not_credit += [ob]
            obs -= [ob]
            } else if (ob.is_valid_note()) {
            amount += ob.query_credit_balance()
            } else {
            not_valid += [ob]
            obs -= [ob]


    def init(self, ) -> None:
            ::init()
            add_command("process", "<indirect:object>")


    def __init__(self):


    def check_cont(self, ) -> None:
            if (!_cont) {
            _cont = clone_object("/std/container")
            _cont.set_name( "clone_on_demand-store" )


    def reset(self, ) -> None:
            object ob
            check_cont()
            foreach( ob in all_inventory(_cont) ){
            ob.remove_property(NUM_REMOVED)


    def set_object_domain(self, domain: str) -> None:
            _domain = domain


    def query_object_domain(self, ) -> str:
            return _domain


    def query_num_items_left(self, ob: MudObject) -> int:
            int max
            int num
            max = ob.query_property( MAX_PROP )
            num = ob.query_property( NUM_REMOVED )
            if( max ){
            return max - num


    def query_number_left(self, name: str) -> int:
            object * things
            things = filter( all_inventory(_cont),
            (: $1.query_short() == $(name) :) )
            if( !sizeof(things) ) {
            return -1


    def dest_me(self, ) -> None:
            if( _cont )
            _cont.dest_me()


    def __init__(self):
            self._commercial_things = []
            self._royalties = ([ ])
            self._use_type_expressions = ([ ])
            self._property_size = 25
            self._black_list = []
            self._last_stats = time()
            self._weekly_status = new(class weekly_status)
            self._weekly_status->withdrawls = []
            self._language = "common"
            self._use_expression = parse_boolean_string("false")


    def short(self, ) -> str:
            if (_property_name) {
            set_short(_property_name)
            add_property("determinate", "")


    def long(self, word: str, dark: int) -> str:
            if (_property_name) {
            set_short(_property_name)
            add_property("determinate", "")


    def is_open_for(self, type: str, person: str) -> int:
            class parse_node ret
            if (is_allowed(person)) {
            return 1


    def query_main_room(self, ) -> MudObject:
            return self


    def add_commercial_thing(self, ob: MudObject) -> None:
            _commercial_things += [ob]
            ob.load_me()


    def remove_commercial_thing(self, thing: MudObject) -> None:
            thing.save_me()
            _commercial_things -= [thing]


    def query_commercial_things(self, ) -> List[MudObject]:
            return _commercial_things


    def query_owners_money(self, ) -> int:
            if (classp(_royalties[query_owner()])) {
            return ((class royalty_data)_royalties[query_owner()])->value


    def adjust_royalty(self, person: str, amount: int) -> None:
            if (is_allowed(person)) {
            if (!_weekly_status) {
            _weekly_status = new(class weekly_status)
            _weekly_status->withdrawls = [})


    def query_royalty(self, person: str) -> int:
            if (classp(_royalties[person])) {
            return ((class royalty_data)_royalties[person])->value


    def query_float(self, ) -> int:
            return query_owners_money()


    def query_commercial_property(self, ) -> int:
            return 1


    def set_parcel_post(self, parcel: str) -> None:
            _parcel_post = parcel


    def query_parcel_post(self, ) -> str:
            return _parcel_post


    def set_language(self, language: str) -> None:
            _language = language


    def query_language(self, ) -> str:
            return _language


    def set_commercial_type(self, name: str) -> None:
            _commercial_type = name


    def query_commercial_type(self, ) -> str:
            return _commercial_type


    def set_property_name(self, name: str) -> None:
            if(strsrch(name, "%^") != -1)
            return 0
            _property_name = name
            add_property("determinate", "")
            set_short(_property_name)


    def query_property_name(self, ) -> str:
            return _property_name


    def event_dest_me(self, ob: MudObject) -> None:
            if (_sign_ob) {
            _sign_ob.dest_me()


    def query_sign_object(self, ) -> MudObject:
            object* obs
            if (!_sign_ob && _auto_load_sign_str && !_broken_sign) {
            if (catch(obs = (PLAYER_OB)->load_auto_load_to_array(_auto_load_sign_str))) {
            _broken_sign = 1
            } else {
            if (sizeof(obs)) {
            _sign_ob = obs[0]
            _sign_ob.reset_get()
            } else {
            _broken_sign = 1


    def set_sign_object(self, ob: MudObject) -> None:
            if (ob) {
            _auto_load_sign_str = (PLAYER_OB)->create_auto_load([ob])
            ob.reset_get()
            } else {
            _auto_load_sign_str = 0


    def set_save_file(self, str: str) -> None:
            printf("ERROR!  Do not use set_save_file.\n")


    def set_save_dir(self, dir: str) -> None:
            if (dir[<1] != '/') {
            dir += "/"


    def query_save_dir(self, ) -> str:
            return _save_dir


    def find_next_commercial_id(self, ) -> int:
            object *obs
            obs = all_inventory()
            while (file_size(query_save_dir() + _commercial_id) >= 0 ||
            file_size(query_save_dir() + _commercial_id + ".o") >= 0 ||
            file_size(query_save_dir() + _commercial_id + ".o.gz") >= 0 ||
            sizeof(filter(obs,
            (: $1.query_commercial_id() == _commercial_id :)))) {
            _commercial_id++


    def set_property_size(self, size: int) -> None:
            _property_size = size


    def query_property_size(self, ) -> int:
            return _property_size


    def reset_weekly_status(self, ) -> None:
            object ob
            _weekly_status = new(class weekly_status)
            _weekly_status->withdrawls = [})
            foreach (ob in _commercial_things) {
            if (ob) {
            ob.reset_weekly_status()


    def query_weekly_status_string(self, ) -> str:
            string place
            string ret
            string str
            object ob
            class float_withdrawls withdrawl
            place = query_property("place")
            if (!_weekly_status) {
            _weekly_status = new(class weekly_status)
            _weekly_status->withdrawls = [})


    def find_commercial_items(self, type: str) -> List[MudObject]:
            object* obs
            obs = filter(all_inventory(self),
            (: $1.query_commercial_name() == $2 :), type)
            return obs


    def register_use_types(self, types: Any) -> None:
            string bing
            if (!_use_type_expressions) {
            _use_type_expressions = ([ ])


    def do_name_property(self, name: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You cannot set the name of " + the_short() + ".\n")
            return 0


    def do_set_sign(self, obs: Any) -> int:
            object ob
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You cannot set the sign for the property.\n")
            return 0


    def do_remove_sign(self, ) -> int:
            object ob
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You cannot set the sign for the property.\n")
            return 0


    def do_status(self, hint: int) -> int:
            string ret
            object ob
            string str
            string place
            string fluff
            class parse_node* expr
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to see the status of this store.\n")
            return 0


    def do_weekly_status(self, ) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to see the status of this store.\n")
            return 0


    def do_use_expression(self, str: str) -> int:
            class parse_node* expr
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to add restrictions to the property.\n")
            return 0


    def do_use_expression_type(self, type: str, str: str) -> int:
            class parse_node* expr
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to add restrictions to the property.\n")
            return 0


    def do_royalties(self, ) -> int:
            string place
            class royalty_data data
            if (!is_open_for("royalty", this_player()->query_name())) {
            add_failed_mess(the_short() + " is not currently open for "
            "customers.\n")
            return 0


    def do_royalty_list(self, ) -> int:
            string place
            mixed value
            class royalty_data data
            string person
            string ret
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("Only the property owners can do this.\n")
            return 0


    def do_collect(self, ) -> int:
            string place
            string name
            class royalty_data data
            if (!is_open_for("royalty", this_player()->query_name())) {
            add_failed_mess(the_short() + " is not currently open for "
            "customers.\n")
            return 0


    def do_collect_partial_royalties(self, amount: str) -> int:
            int amt
            string place
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("Only the owners can do this.\n")
            return 0


    def do_pay_entry(self, ) -> int:
            string place
            class parse_node ret
            if (!_entry_cost) {
            add_failed_mess("Entry into " + the_short() + " is free.\n")
            return 0


    def do_add_royalties(self, amount: str) -> int:
            int amt
            string place
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You cannot add to the float.\n")
            return 0


    def do_purchase(self, ) -> int:
            object ob
            ob = clone_object(COMMERCIAL_SALESPERSON)
            ob.move(self, "$N arrives in a flash.\n")
            ob.set_commercial_type(query_commercial_type())
            ob.do_start_speil(this_player())
            return 1


    def do_deposit(self, obs: Any) -> int:
            object* monies
            object money
            string place
            monies = filter(obs, (: $1.id(MONEY_ALIAS) :))
            if (!sizeof(monies)) {
            add_failed_mess("YOu cannot deposit any of $I.\n", obs)
            return 0


    def do_black_list_add(self, name: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to add people to the black list.\n")
            return 0


    def do_black_list_add_ignore(self, ) -> int:
            string *people
            string *bad
            string *ok
            string name
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to add people to the black list.\n")
            return 0


    def do_black_list_remove(self, name: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to remove people from "
            "the black list.\n")
            return 0


    def do_measure(self, ) -> int:
            this_player()->add_succeeded_mess( self,
            ({
            "$N $V up the size of the property and calculate that it is "
            "about " + query_num(query_property_size()) + " square yards.\n",
            "$N $V up the size of the property.\n"
            }), [}) )
            return 1


    def init(self, ) -> None:
            if (!_royalties) {
            _royalties = ([ ])


    def __init__(self):


    def __init__(self):
            if (!_cut) {
            set_cut(10)


    def value_from_string(self, str: str, place: str) -> int:
            return MONEY_HAND.value_from_string(str, place)


    def reload_shop(self, ) -> None:
            set_controller("/std/shops/controllers/craft_shop_controller")
            _controller.load_it()


    def set_controller(self, name: str) -> None:
            if (_controller) {
            _controller.dest_me()


    def query_controller(self, ) -> MudObject:
            return _controller


    def set_save_dir(self, fname: str) -> None:
            _save_dir_name = fname


    def query_craft_shop_save_dir(self, ) -> str:
            return _save_dir_name


    def set_allowed_to_sell(self, func: Any) -> None:
            _allowed_to_sell = func


    def set_max_sell_per_person(self, num: int) -> None:
            _max_sell_per_person = num


    def query_max_sell_per_person(self, ) -> int:
            return _max_sell_per_person


    def set_always_ask_price(self, ask_price: int) -> None:
            _always_ask_price = ask_price


    def query_always_ask_price(self, ) -> int:
            return _always_ask_price


    def set_use_name(self, flag: int) -> None:
            _use_name = flag


    def query_use_name(self, ) -> int:
            return _use_name


    def query_maximum_sale_value(self, person: str, obs: MudObject) -> int:
            return 0


    def query_extra_price_information(self, person: str, obs: MudObject) -> str:
            return ""


    def query_shop(self, ) -> int:
            return 1


    def query_no_steal(self, ) -> int:
            return 1


    def is_able_to_change(self, ob: MudObject) -> int:
            return _controller.query_owner_of_shop_object(ob) ==
            this_player()->query_name()


    def is_allowed_to_sell(self, obs: Any, name: str, sellable_names: str) -> int:
            if ((sizeof(sellable_names)+sizeof(obs)) > query_max_sell_per_person() &&
            query_max_sell_per_person()) {
            add_failed_mess("Cannot sell $I, since you already have " +
            number_as_string(sizeof(sellable_names)) +
            " items listed with a maximum of " +
            number_as_string(query_max_sell_per_person()) +
            ".\n", obs)
            return 0


    def init(self, ) -> None:
            string storeroom
            add_command("sell", "<indirect:object:me>")
            add_command("list", "")
            if (query_controller()) {
            storeroom = file_name(_controller.query_sell_list())
            add_command("buy", "<indirect:object:" + storeroom + ">",
            (: do_buy($1, 0) :))
            add_command("browse", "<indirect:object:" + storeroom + ">",
            (: do_browse($1) :))
            add_command("change", "price of <indirect:object:" + storeroom +
            "> to <string>", (: do_change($1, $4[1]) :))
            add_command("change", "name of <indirect:object:" + storeroom +
            "> to <string>", (: do_change_name($1, $4[1]) :))


    def do_sell_id(self, obs: Any, id: str, force: int) -> int:
            object *sellable
            object *cannot
            object *donned in Faern
            string name
            string *sellable_names
            if (!check_open(this_player(), "sell")) {
            return 0


    def do_sell(self, obs: MudObject) -> int:
            object *sellable
            object *cannot
            object *donned in Faern
            string name
            string *sellable_names
            int i
            int cost
            string place
            if (!check_open(this_player(), "sell")) {
            return 0


    def do_list(self, ) -> int:
            string place
            object *obs
            object ob
            mixed *stuff
            string ret
            if (!check_open(this_player(), "list")) {
            return 0


    def do_buy(self, obs: MudObject, force: int) -> int:
            int value
            string place
            int player_money
            object *bought
            string *sellers
            string *names
            string *cats
            int *values
            if (!check_open(this_player(), "buy")) {
            return 0


    def do_delete(self, id: str) -> int:
            if( !this_player()->query_director() ) {
            add_failed_mess( "This command is reserved for directors.\n", [}) )
            return 0


    def do_browse(self, obs: MudObject) -> int:
            object *real_obs
            object ob
            string mess
            string read
            if (!check_open(this_player(), "browse")) {
            return 0


    def do_change(self, obs: MudObject, change: str) -> int:
            object *frog
            int value
            string place
            if (!check_open(this_player(), "change")) {
            return 0


    def do_change_name(self, obs: MudObject, new_name: str) -> int:
            object *frog
            if (!check_open(this_player(), "change")) {
            return 0


    def do_collect(self, ) -> int:
            string name
            string place
            int value
            if (!check_open(this_player(), "collect")) {
            return 0


    def do_royalties(self, ) -> int:
            string name
            string place
            int value
            if (!check_open(this_player(), "royalties")) {
            return 0


    def set_cut(self, new_cut: int) -> None:
            _cut = new_cut


    def query_cut(self, ) -> int:
            return _cut


    def set_minimum_cost(self, cost: int) -> None:
            _minimum_cost = cost


    def query_minimum_cost(self, ) -> int:
            return _minimum_cost


    def set_when_sold_function(self, func: Any) -> None:
            _when_sold_func = func


    def check_open(self, player: MudObject, type: str) -> int:
            if (!is_open(player, 0)) {
            add_failed_mess("The shop is not open.\n")
            return 0


    def set_extra_sell_check(self, func: Any) -> None:
            _extra_sell_check = func


    def set_no_royalty_commands(self, flag: int) -> None:
            _no_royalty_commands = flag


    def query_no_royalty_commands(self, ) -> int:
            return _no_royalty_commands


    def dest_me(self, ) -> None:
            if(_controller) {
            _controller.dest_me()


    def __init__(self):
            self._default_category = "General"


    def __init__(self):
            self._default_category = "General"
            ::create()


    def init(self, ) -> None:
            string storeroom
            ::init()
            if (query_controller()) {
            storeroom = file_name(query_controller()->query_sell_list())
            add_command("change", "category of <indirect:object:" + storeroom +
            "> to <string'category'>",
            (: do_change_category($1, $4[1]) :))


    def add_shop_category(self, category: str) -> None:
            query_controller()->add_category_accepted(category)


    def set_category_description(self, category: str, description: str) -> None:
            query_controller()->set_category_description(category, description)


    def set_category_information(self, category: str, information: str) -> None:
            query_controller()->set_category_information(category, information)


    def remove_shop_category(self, category: str) -> None:
            query_controller()->remove_category_accepted(category)


    def query_default_category(self, ) -> str:
            return _default_category


    def set_controller(self, name: str) -> None:
            ::set_controller(name)
            setup_default_category()


    def update_categories(self, ) -> None:
            object *obs
            object ob
            obs = query_controller()->query_sell_list_obs()
            foreach (ob in obs) {
            if (!query_controller()->query_category_of_shop_object(ob)) {
            query_controller()->change_category_of_shop_object(ob, _default_category)


    def query_real_category_name(self, in_cat: str) -> str:
            string* categories
            string cat
            categories = query_controller()->query_categories()
            foreach (cat in categories) {
            if (lower_case(cat)[0..strlen(in_cat)-1] == lower_case(in_cat)) {
            return cat


    def do_list_category(self, category: str) -> int:
            string place
            string info
            object *obs
            object ob
            mixed *morestuff
            string ret
            string list
            if (!check_open(this_player(), "list")) {
            return 0


    def do_list(self, ) -> int:
            string place
            object *obs
            mixed *stuff
            mixed *morestuff
            string ret
            string* categories
            string cat
            string desc
            object ob
            if (!check_open(this_player(), "list")) {
            return 0


    def do_change_category(self, obs: MudObject, new_category: str) -> int:
            object *frog
            if (!check_open(this_player(), "change")) {
            return 0


    def set_extra_sell_check(self, func: Any) -> None:
            _cat_extra_sell_check = func


    def set_default_category(self, category: str) -> None:
            _default_category = category


    def __init__(self):
            self._minimum_age_to_vote = 2 * DAY


    def set_minimum_age_to_vote(self, age: int) -> None:
            _minimum_age_to_vote = age


    def set_minimum_age_to_nominate(self, age: int) -> None:
            _minimum_age_to_nominate = age


    def set_minimum_nomination_number(self, num: int) -> None:
            _minimum_number_nominated = num


    def set_nomination_time(self, tim: int) -> None:
            _nomination_time = tim


    def set_election_time(self, tim: int) -> None:
            _election_time = tim


    def set_deletion_time(self, tim: int) -> None:
            _deletion_time = tim


    def set_expression_type(self, type: str) -> None:
            _type = type


    def query_expression_type(self, ) -> str:
            return _type


    def do_user_function_add(self, def: str, expr: str) -> int:
            string name
            if (this_player()->query_name() != "presto")
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to add functions to this store.\n")
            return 0


    def do_user_function_remove(self, name: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to remove functions from this store.\n")
            return 0


    def do_approve_status_internal_functions(self, ) -> int:
            string* names
            string name
            string ret
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to see the status of this store.\n")
            return 0


    def do_function_help(self, name: str) -> int:
            string nroff_fn
            string str
            string fname
            fname = CRAFT_SHOP_EXPRESSION_HELP_DIR + name
            if (file_size(fname) <= 0) {
            add_failed_mess("There is no help for the function '" + name + "'.\n")
            return 0


    def do_function_help_list(self, ) -> int:
            string *names
            names = get_dir(CRAFT_SHOP_EXPRESSION_HELP_DIR)
            if (!sizeof(names)) {
            add_failed_mess("There is no help on any functions.\n")
            return 0


    def do_approve_status_functions(self, hints: int) -> int:
            string* names
            string name
            string ret
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to see the status of this store.\n")
            return 0


    def init(self, ) -> None:
            if (!is_allowed(this_player()->query_name())) {
            return


    def __init__(self):


    def query_safe(self, ) -> MudObject:
            return _safe


    def setup_safe(self, ) -> None:
            if( !_safe ) {
            _safe = clone_object( ITEM_SHOP_ITEMS + "item_shop_safe" )
            _safe.set_difficulty( 2 + random( 7 ) )
            _safe.set_ownership( "shop" )
            if ( self.query_hidden_safe( _safe ) ) {
            self.add_hidden_object( _safe )
            } else {
            _safe.move( self )


    def set_safe(self, safe: MudObject) -> None:
            _safe = safe
            if ( _safe ) {
            _safe.set_ownership( "shop" )
            if ( self.query_hidden_safe( _safe ) ) {
            self.add_hidden_object( _safe )
            } else {
            _safe.move( self )


    def reset(self, ) -> None:
            ::reset()
            if(!random(3)) {
            remove_property("inventory_loss")


    def query_shop(self, ) -> int:
            return 1


    def shoplift_success(self, ob: MudObject) -> MudObject:
            object real_ob
            real_ob = create_real_object(ob)
            return real_ob


    def set_open_func(self, func: Any) -> None:
            ::set_open_function(func)


    def set_open_condition(self, func: Any) -> None:
            ::set_open_function(func)


    def set_buy_function(self, func: Any) -> None:
            _buy_func = func


    def set_browse_function(self, func: Any) -> None:
            _browse_func = func


    def set_list_function(self, func: Any) -> None:
            _list_func = func


    def set_sort_function(self, func: Any) -> None:
            _sort_func = func


    def init(self, ) -> None:
            if (query_cont()) {
            add_command( "list", "[all]" )
            add_command( "browse", "<indirect:object:"+file_name(query_cont())+">" )
            add_command( "browse", "<word>", (: do_word_browse($4[0]) :) )
            add_command( "buy", "<indirect:object:"+file_name(query_cont())+">" )
            add_command( "buy", "<word>", (: do_word_buy($4[0]) :) )


    def query_cost(self, thing: MudObject) -> int:
            int cost
            string place
            if (!thing) {
            return 0


    def do_list(self, str: str) -> int:
            int i
            int left
            string list
            string place
            string display
            object thing
            object *listed
            object *things
            if (!is_open(this_player(), 0)) {
            if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
            add_failed_mess("The shop is not open.\n")


    def do_word_buy(self, str: str) -> int:
            object thing
            int i
            if (!is_open(this_player(), 0)) {
            if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
            add_failed_mess("The shop is not open.\n")


    def do_buy(self, things: MudObject) -> int:
            int i, cost, value, ret, money_in_safe
            string place
            object thing, money, *sold, ob, *obs
            mixed *money_arr, temp
            if (!is_open(this_player(), 0)) {
            if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
            add_failed_mess("The shop is not open.\n")


    def do_word_browse(self, words: str) -> int:
            int i
            object thing
            if (!is_open(this_player(), 0)) {
            if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
            add_failed_mess("The shop is not open.\n")


    def do_browse(self, things: MudObject) -> int:
            int i
            int num
            string place
            string mess
            if (!is_open(this_player(), 0)) {
            if (!broadcast_shop_event(ITEM_SHOP_EVENT_CLOSE, this_player())) {
            add_failed_mess("The shop is not open.\n")


    def dest_me(self, ) -> None:
            ::dest_me()


    def event_shoplift(self, command_ob: MudObject, thief: MudObject, victim: MudObject) -> None:
            if (stringp(_shoplift_handler)) {
            if(_shoplift_handler != "none" ) {
            _shoplift_handler.handle_shoplift(thief, victim)


    def do_banking(self, ) -> None:
            object ob, *obs
            debug_printf( "Doing banking.\n" )
            if( _safe ) {
            obs = all_inventory( _safe )
            foreach( ob in obs ) {
            if( ob.query_property( "money" ) ) {
            ob.move( "/room/rubbish" )


    def set_max_float(self, f: int) -> None:
            _max_float = f


    def query_max_float(self, ) -> int:
            return _max_float


    def __init__(self):


    def set_paper_area(self, area: str) -> None:
            _area = area


    def query_paper_area(self, ) -> str:
            return _area


    def set_paper(self, paper: str) -> None:
            _paper = paper


    def query_paper(self, ) -> str:
            return _paper


    def do_list_papers(self, ) -> int:
            string paper
            string* papers
            string str
            int cost
            string place
            place = query_property("place")
            if (_paper) {
            papers = [_paper]
            } else {
            papers = NEWSPAPER_HANDLER.query_papers_in_area(_area)


    def do_buy(self, paper: str, edition: int) -> int:
            string found_paper
            int pos
            object ob
            string place
            string* papers
            int cost
            int* editions
            place = query_property("place")
            if (_paper) {
            papers = [_paper]
            } else {
            papers = NEWSPAPER_HANDLER.query_papers_in_area(_area)


    def init(self, ) -> None:
            add_command("list", "[papers]", (: do_list_papers() :))
            add_command("buy", "<number'edition number'> of <string'paper name'>",
            (: do_buy($4[1], $4[0]) :))


    def add_allowed_variable(self, name: str, type: int, value: Any) -> None:
            private int function_object_base_value(object* obs) {
            int value
            object ob
            int tmp
            value = 1000000000
            foreach (ob in obs) {
            tmp = ob.query_base_value()
            if (tmp < value) {
            value = tmp


    def __init__(self):


    def set_open_function(self, func: Any) -> None:
            _open_func = func


    def is_open(self, player: MudObject, type: int) -> int:
            if (_open_func) {
            return evaluate(_open_func, player, type)


    def test_open(self, ) -> int:
            return is_open( this_player(), 0 )


    def set_language(self, lang: str) -> None:
            _shop_language = lang


    def query_language(self, ) -> str:
            return _shop_language


    def set_pawn_markup(self, percent: int) -> None:
            _pawn_markup = percent


    def query_pawn_markup(self, ) -> int:
            return _pawn_markup


    def set_pawn_ttl(self, ttl: int) -> None:
            _pawn_ttl = ttl


    def query_pawn_ttl(self, ) -> int:
            return _pawn_ttl


    def set_pawn_mess(self, mess: Any) -> None:
            _pawn_mess = mess


    def query_pawn_mess(self, ) -> str:
            return _pawn_mess


    def __init__(self):
            self._pawn_mess = []
            self._pawn_markup = 20 
            self._pawn_ttl = 7 * 24 * 60 * 60 
            self._shop_language = "morporkian" 


    def init(self, ) -> None:
            ::init()
            add_command( "pawn", "<indirect:object:me'items'>" )


    def do_pawn(self, in_obs: MudObject) -> int:
            int value, total
            mixed *m_array
            object ob, money, receipt
            object *cheap, *cre, *expensive, *kept, *nobuy, *stolen, *donned in Faern
            string place, fn
            string *text = [})
            if ( ! is_open( TP, 0 ) ) {
            return 0


    def do_sell(self, in_obs: MudObject) -> int:
            add_failed_mess(
            "If you just want to sell items, you'll need to find a general "
            "store.  Pawn shops are for pawning in.\n" )
            return 0


    def add_allowed_variable(self, name: str, type: int, value: Any) -> None:
            private int variable_player_level(string seller) {
            return PLAYER_HANDLER.test_level(seller)


    def __init__(self):


    def __init__(self):
            self._round_value = 1
            self._waiting_for_approval = []


    def __init__(self):
            self._round_value = 1
            self._waiting_for_approval = []
            if (!_approved) {
            _approved = [})


    def set_maximum_waiting_queue_size(self, size: int) -> None:
            _max_items_in_queue = size


    def query_maximum_waiting_queue_size(self, ) -> int:
            return _max_items_in_queue


    def set_maximum_inventory_size(self, size: int) -> None:
            _maximum_inventory = size


    def query_maximum_inventory_size(self, ) -> int:
            return _maximum_inventory


    def set_parcel_post(self, parcel: str) -> None:
            _parcel_post = parcel


    def query_parcel_post(self, ) -> str:
            return _parcel_post


    def set_shop_name(self, name: str) -> None:
            _shop_name = name
            add_property("determinate", "")
            set_short(_shop_name)


    def query_shop_name(self, ) -> str:
            return _shop_name


    def set_round_price(self, round: int) -> None:
            _round_value = round


    def query_round_prices(self, ) -> int:
            return _round_value


    def query_number_of_items_listed(self, name: str) -> int:
            int num
            class approval_obs bing
            name = lower_case(name)
            num = sizeof(query_controller()->query_owner_sellables(name))
            foreach (bing in _waiting_for_approval) {
            if (lower_case(bing->seller) == name) {
            num += sizeof(bing->saved)


    def query_royalty(self, name: str) -> int:
            return query_controller()->query_royalty(name)


    def adjust_royalty(self, name: str, amount: int) -> None:
            query_controller()->adjust_royalty(name, amount)


    def is_allowed_to_use_shop(self, person: str) -> int:
            class parse_node frog
            if (is_allowed(person) || !sizeof(_use_expression)) {
            return 1


    def check_open(self, player: MudObject, type: str) -> int:
            if (!::check_open(player)) {
            return 0


    def set_controller(self, name: str) -> None:
            ::set_controller(name)
            query_controller()->set_dont_use_name(1)


    def is_allowed_to_sell(self, obs: MudObject, name: str, sellable_names: str) -> int:
            int num
            int max
            if (_automatic_approval->num_allowed ||
            _sellers[name]) {
            num = query_number_of_items_listed(name) + sizeof(obs)
            if (_sellers[name] && _sellers[name]->max_sellable) {
            max = _sellers[name]->max_sellable
            } else {
            max = _automatic_approval->num_allowed


    def query_maximum_sale_value_both(self, person: str, item: MudObject) -> List[int]:
            int max_deny
            int max_accept
            string short
            class expression_type stuff
            mixed app_item
            if (_sellers[person]) {
            if (_sellers[person]->value_limit) {
            max_accept = _sellers[person]->value_limit


    def query_maximum_sale_value(self, person: str, obs: Any) -> int:
            int* stuff
            object ob
            int cur_deny
            foreach (ob in obs) {
            stuff = query_maximum_sale_value_both(person, ob)
            if (!cur_deny && stuff[1]) {
            cur_deny = stuff[1]
            } else if (cur_deny && cur_deny > stuff[1]) {
            cur_deny = stuff[1]


    def query_extra_price_information(self, seller: str, obs: MudObject) -> str:
            int* max
            int* max_tmp
            string ret
            string place
            object ob
            max = [0, 0]
            foreach (ob in obs) {
            max_tmp = query_maximum_sale_value_both(seller, ob)
            if (max_tmp[0] && max[0] > max_tmp[0]) {
            max[0] = max_tmp[0]


    def destroy_checkout_object(self, ob: MudObject) -> int:
            int id
            int *ids
            int i
            class approval_obs approve
            if (!ob) {
            return 0


    def is_checkout_object(self, ob: MudObject) -> int:
            return ob.query_property(PLAYER_CRAFT_SHOP_CHECK_PROP)


    def remove_from_approval_list(self, approval_obs: Any) -> None:
            int i
            int pos
            for (i = 0; i < sizeof(_approved); i++) {
            if (_approved[i] == approve) {
            foreach (pos in approve->saved) {
            do_save_file(CRAFT_SHOP_REMOVE_DATA_SAVE_FILE,
            0,
            "app_" + pos)


    def query_transaction_string(self, shop_transaction: Any) -> str:
            string ret
            string amt
            string place
            place = query_property("place")
            if (!place) {
            place = "default"


    def query_letter_value(self, pos: int) -> str:
            return sprintf("%c%c", 'A' + (pos / 26), 'A' + (pos % 26))


    def query_number_value(self, letter: str) -> int:
            if (!strlen(letter)) {
            return -1


    def ownership_change(self, old_owner: str, new_owner: str) -> int:
            class parse_node* expr
            if (old_owner == new_owner) {
            return 0


    def check_for_checkout(self, ob: MudObject) -> List[MudObject]:
            object* obs = [})
            if (_something_checkedout) {
            if (living(ob)) {
            obs = filter(deep_inventory(ob), (: is_checkout_object($1) :))
            } else {
            if (is_checkout_object(ob)) {
            obs = [ob]


    def event_exit(self, ob: MudObject, message: str, to: MudObject) -> None:
            object *obs
            obs = check_for_checkout(ob)
            if (sizeof(obs)) {
            tell_object(ob, "You suddenly find the uncheckout items " +
            query_multiple_short(obs) + " check themselves "
            "back in.\n")
            obs.move("/room/rubbish")


    def event_dest_me(self, ob: MudObject) -> None:
            check_for_checkout(ob)
            if (_sign_ob) {
            _sign_ob.dest_me()


    def return_all_checkedout_objects(self, ) -> None:
            object ob
            object* obs
            if (_something_checkedout) {
            obs = filter(deep_inventory(self), (: is_checkout_object($1) :))
            if (sizeof(obs)) {
            foreach (ob in obs) {
            destroy_checkout_object(ob)


    def dest_me(self, ) -> None:
            ::dest_me()


    def is_able_to_change(self, ob: MudObject) -> int:
            return is_allowed(this_player()->query_name())


    def query_owners_money(self, ) -> int:
            return query_royalty(query_owner())


    def adjust_owners_money(self, amt: int) -> None:
            adjust_royalty(query_owner(), amt)


    def query_sign_object(self, ) -> MudObject:
            object* obs
            if (!_sign_ob && _auto_load_sign_str && !_broken_sign) {
            if (catch(obs = PLAYER_OB.load_auto_load_to_array(_auto_load_sign_str))) {
            _broken_sign = 1
            } else {
            if (sizeof(obs)) {
            _sign_ob = obs[0]
            _sign_ob.reset_get()
            } else {
            _broken_sign = 1


    def set_sign_object(self, ob: MudObject) -> None:
            if (ob) {
            _auto_load_sign_str = PLAYER_OB.create_auto_load([ob])
            ob.reset_get()
            } else {
            _auto_load_sign_str = 0


    def do_buy(self, obs: MudObject) -> int:
            int status
            if (!evaluate_expression(_buy_expression, this_player()->query_name(), 0, [}), 0, 0)->value &&
            !is_allowed_to_use_shop(this_player()->query_name())) {
            add_failed_mess("You cannot buy anything at this shop.\n")
            return 0


    def do_check_sell(self, obs: MudObject) -> int:
            int *stuff
            object ob
            string ret
            string place
            place = query_property("place")
            if (!place) {
            place = "default"


    def do_list_approval(self, approved: int) -> int:
            class approval_obs approve
            int pos
            int shown
            int allowed
            int checkout
            int i
            int fluff
            string place
            string ret
            object* obs
            object *current
            object* result
            string *possible_names
            string start
            mapping result_type
            place = query_property("place")
            if (!place) {
            place = "default"


    def do_return(self, name: str) -> int:
            object *obs
            object *ok
            object *here
            object *fail
            object *checkout
            object money
            class approval_obs approve
            object ob
            int pos
            int i
            int value
            string place
            approve = query_approval_class(name)
            if (!approve) {
            return 0


    def do_approve_item(self, name: str, money_str: str) -> int:
            int cost
            object *obs
            class approval_obs approve
            string place
            int final_cost
            int num
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to approve items.\n")
            return 0


    def do_approve_reject(self, name: str, mess: str, reject_pos: int) -> int:
            object *obs
            object *ok
            object *here
            object *checkout
            object ob
            object play
            class approval_obs approve
            int pos
            int i
            int ret
            string ob_mess
            approve = query_approval_class(name)
            if (!approve) {
            return 0


    def check_reject_note(self, str: str, ob_str: str, name: str) -> None:
            str = lower_case(str)
            if (!strlen(str) ||
            (str[0] != 'y' &&
            str[0] != 'n')) {
            write("Please answer yes or no.\nWould you like to send them "
            "a note about it as well?")
            input_to("check_reject_note", 0, ob_str, name)
            return


    def send_reject_note(self, mess: str, name: str) -> None:
            if (!mess) {
            write("Aborted.\n")
            return


    def do_approve_browse(self, name: str) -> int:
            object *obs
            object ob
            string read
            string ret
            class approval_obs approve
            int pos
            string place
            approve = query_approval_class(name)
            if (!approve) {
            return 0


    def do_approve_checkout(self, name: str) -> int:
            object *obs
            object *bad
            object *checkout
            object ob
            class approval_obs approve
            int pos
            int i
            approve = query_approval_class(name)
            if (!approve) {
            return 0


    def do_approve_checkin(self, obs: Any) -> int:
            object ob
            object* ok
            ok = [})
            foreach (ob in obs) {
            if (is_checkout_object(ob)) {
            destroy_checkout_object(ob)
            ok += [ob]


    def do_approve_name_change(self, name: str, new_name: str) -> int:
            class approval_obs approve
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to approve items.\n")
            return 0


    def do_approve_category_change(self, name: str, new_category: str) -> int:
            class approval_obs approve
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to approve items.\n")
            return 0


    def do_approve_auto_low(self, cost: str) -> int:
            string place
            int value
            place = query_property("place")
            if (!place) {
            place = "default"


    def do_approve_auto_high(self, cost: str) -> int:
            string place
            int value
            place = query_property("place")
            if (!place) {
            place = "default"


    def do_approve_auto_high_deny(self, cost: str) -> int:
            string place
            int value
            place = query_property("place")
            if (!place) {
            place = "default"


    def do_approve_auto_item_test(self, obs: Any) -> int:
            object ob
            string place
            mixed cost
            int found
            int allowed
            class expression_type stuff
            class parse_node frog
            allowed = is_allowed(this_player()->query_name())
            place = query_property("place")
            if (!place) {
            place = "default"


    def do_approve_auto_item_remove(self, item: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to set automatic approval items.\n")
            return 0


    def do_approve_auto_item_remove_object(self, obs: MudObject) -> int:
            object ob
            object *bad
            object *ok
            string name
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to set automatic approval items.\n")
            return 0


    def do_approve_auto_expression_remove(self, idstr: str) -> int:
            class expression_type expr
            int id
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to set automatic approval items.\n")
            return 0


    def do_approve_percentage(self, num: Any) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to set automatic approval items.\n")
            return 0


    def do_approve_limit(self, limit: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to set any limits on selling "
            "items.\n")
            return 0


    def do_approve_limit_person_items(self, name: str, value: str) -> int:
            int amt
            class seller_information info
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to set any limits on selling "
            "items.\n")
            return 0


    def do_approve_limit_person_value(self, name: str, money: str) -> int:
            class seller_information info
            int value
            string place
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to set any limits on selling "
            "items.\n")
            return 0


    def do_approve_limit_person_value_deny(self, name: str, money: str) -> int:
            class seller_information info
            int value
            string place
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to set any limits on selling "
            "items.\n")
            return 0


    def do_approve_limit_person_remove(self, name: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to remove limits "
            "off someone.\n")
            return 0


    def do_approve_black_list_add(self, name: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to add people to the black list.\n")
            return 0


    def do_approve_black_list_add_ignore(self, ) -> int:
            string *people
            string *bad
            string *ok
            string name
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to add people to the black list.\n")
            return 0


    def do_approve_black_list_remove(self, name: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to remove people from "
            "the black list.\n")
            return 0


    def do_user_function_add(self, def: str, expr: str) -> int:
            string name
            if (this_player()->query_name() != "presto")
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to add functions to this store.\n")
            return 0


    def do_user_function_remove(self, name: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to remove functions from this store.\n")
            return 0


    def do_approve_status_internal_functions(self, ) -> int:
            string* names
            string name
            string ret
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to see the status of this store.\n")
            return 0


    def do_function_help(self, name: str) -> int:
            string nroff_fn
            string str
            string fname
            fname = CRAFT_SHOP_EXPRESSION_HELP_DIR + name
            if (file_size(fname) <= 0) {
            add_failed_mess("There is no help for the function '" + name + "'.\n")
            return 0


    def do_function_help_list(self, ) -> int:
            string *names
            names = get_dir(CRAFT_SHOP_EXPRESSION_HELP_DIR)
            if (!sizeof(names)) {
            add_failed_mess("There is no help on any functions.\n")
            return 0


    def do_approve_status_functions(self, hints: int) -> int:
            string* names
            string name
            string ret
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to see the status of this store.\n")
            return 0


    def do_approve_status(self, status: int) -> int:
            string ret
            string place
            mixed expr
            string str
            string name
            class seller_information stuff
            string *bits
            int pos
            int hint
            int show_expr
            class expression_type bing
            class expression_type binger
            class approval_item approval
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to see the status of this store.\n")
            return 0


    def do_approve_pay_deficit(self, ) -> int:
            int cost
            string place
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to pay off the deficit for " +
            the_short() + ".\n")
            return 0


    def do_approve_buy_expression(self, str: str) -> int:
            class parse_node* expr
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to add restrictions to the shop.\n")
            return 0


    def do_approve_use_expression(self, str: str) -> int:
            class parse_node* expr
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to add restrictions to the shop.\n")
            return 0


    def do_add_new_category(self, category: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to add categories.\n")
            return 0


    def do_remove_category(self, category: str) -> int:
            object* obs
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to remove categories.\n")
            return 0


    def do_rename_category(self, category: str, new_category: str) -> int:
            object* obs
            object ob
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to rename categories.\n")
            return 0


    def do_set_default_category(self, default_cat: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to set the default category.\n")
            return 0


    def do_list_categories(self, ) -> int:
            string cat
            string ret
            ret = ""
            foreach (cat in query_controller()->query_categories()) {
            if (cat == query_default_category()) {
            ret += cat + " (default)\n"
            } else {
            ret += cat + "\n"


    def do_name_shop(self, name: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You cannot set the name of " + the_short() + ".\n")
            return 0


    def do_stats_items(self, type: int) -> int:
            class shop_stats stat
            string ret
            string *bits
            string place
            string name
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You cannot read " + the_short() + "'s ledger.\n")
            return 0


    def do_stats_transactions(self, ) -> int:
            class shop_transaction bing
            string ret
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You cannot read " + the_short() + "'s ledger.\n")
            return 0


    def do_stats_money(self, ) -> int:
            string ret
            int stock_value
            string place
            object ob
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You cannot read " + the_short() + "'s ledger.\n")
            return 0


    def do_set_sign(self, obs: Any) -> int:
            object ob
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You cannot set the sign for the shop.\n")
            return 0


    def do_remove_sign(self, ) -> int:
            object ob
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You cannot set the sign for the shop.\n")
            return 0


    def do_collect_partial_royalties(self, amount: str) -> int:
            int amt
            string place
            if (query_owner() != this_player()->query_name()) {
            add_failed_mess("Only the owner can do this.\n")
            return 0


    def inform_of_royalties(self, player: MudObject) -> None:
            if (player && environment(player) == self) {
            await player.send("You have some royalties to pick up.\n")


    def init(self, ) -> None:
            if (query_controller()->query_royalty(this_player()->query_name())) {
            asyncio.create_task(self."inform_of_royalties", 5)


    def __init__(self):
            self._round_value = 1
            self._waiting_for_approval = []


    def __init__(self):
            self._round_value = 1
            self._waiting_for_approval = []
            if (!_approved) {
            _approved = [})


    def is_helper(self, person: str) -> int:
            if (!_helpers) {
            _helpers = [})


    def set_maximum_waiting_queue_size(self, size: int) -> None:
            _max_items_in_queue = size


    def query_maximum_waiting_queue_size(self, ) -> int:
            return _max_items_in_queue


    def set_maximum_inventory_size(self, size: int) -> None:
            _maximum_inventory = size


    def query_maximum_inventory_size(self, ) -> int:
            return _maximum_inventory


    def set_parcel_post(self, parcel: str) -> None:
            _parcel_post = parcel


    def query_parcel_post(self, ) -> str:
            return _parcel_post


    def query_royalty(self, person: str) -> int:
            return query_controller()->query_royalty(person)


    def query_owners_money(self, ) -> int:
            return query_royalty(query_owner())


    def adjust_royalty(self, person: str, amount: int) -> None:
            query_controller()->adjust_royalty(person, amount)


    def adjust_owners_money(self, amount: int) -> int:
            return adjust_royalty(query_owner(), amount)


    def set_round_price(self, round: int) -> None:
            _round_value = round


    def query_round_prices(self, ) -> int:
            return _round_value


    def query_number_of_items_listed(self, name: str) -> int:
            int num
            class approval_obs bing
            name = lower_case(name)
            num = sizeof(query_controller()->query_owner_sellables(name))
            foreach (bing in _waiting_for_approval) {
            if (lower_case(bing->seller) == name) {
            num += sizeof(bing->saved)


    def is_allowed_to_use_shop(self, person: str) -> int:
            return (is_allowed(person) || is_helper(person) ||
            is_open_for("use", person))


    def check_open(self, player: MudObject, type: str) -> int:
            if (!::check_open(player)) {
            return 0


    def set_controller(self, name: str) -> None:
            ::set_controller(name)
            query_controller()->set_dont_use_name(1)


    def is_allowed_to_sell(self, obs: MudObject, name: str, sellable_names: str) -> int:
            int num
            int max
            if (_automatic_approval->num_allowed ||
            _sellers[name]) {
            num = query_number_of_items_listed(name) + sizeof(obs)
            if (_sellers[name] && _sellers[name]->max_sellable) {
            max = _sellers[name]->max_sellable
            } else {
            max = _automatic_approval->num_allowed


    def query_maximum_sale_value_both(self, person: str, item: MudObject) -> List[int]:
            int max_deny
            int max_accept
            string short
            class expression_type stuff
            mixed app_item
            if (_sellers[person]) {
            if (_sellers[person]->value_limit) {
            max_accept = _sellers[person]->value_limit


    def query_maximum_sale_value(self, person: str, obs: Any) -> int:
            int* stuff
            object ob
            int cur_deny
            foreach (ob in obs) {
            stuff = query_maximum_sale_value_both(person, ob)
            if (!cur_deny && stuff[1]) {
            cur_deny = stuff[1]
            } else if (cur_deny && cur_deny > stuff[1]) {
            cur_deny = stuff[1]


    def query_extra_price_information(self, seller: str, obs: MudObject) -> str:
            int* max
            int* max_tmp
            string ret
            string place
            object ob
            max = [0, 0]
            foreach (ob in obs) {
            max_tmp = query_maximum_sale_value_both(seller, ob)
            if (max_tmp[0] && max[0] > max_tmp[0]) {
            max[0] = max_tmp[0]


    def destroy_checkout_object(self, ob: MudObject) -> int:
            int id
            int *ids
            int i
            class approval_obs approve
            if (!ob) {
            return 0


    def is_checkout_object(self, ob: MudObject) -> int:
            return ob.query_property(PLAYER_CRAFT_SHOP_CHECK_PROP)


    def remove_from_approval_list(self, approval_obs: Any) -> None:
            int i
            int pos
            for (i = 0; i < sizeof(_approved); i++) {
            if (_approved[i] == approve) {
            foreach (pos in approve->saved) {
            do_save_file(CRAFT_SHOP_REMOVE_DATA_SAVE_FILE,
            0,
            "app_" + pos)


    def query_transaction_string(self, shop_transaction: Any) -> str:
            string ret
            string amt
            string place
            place = query_property("place")
            if (!place) {
            place = "default"


    def query_letter_value(self, pos: int) -> str:
            return sprintf("%c%c", 'A' + (pos / 26), 'A' + (pos % 26))


    def query_number_value(self, letter: str) -> int:
            if (!strlen(letter)) {
            return -1


    def ownership_change(self, old_owner: str, new_owner: str) -> int:
            class parse_node* expr
            if (old_owner == new_owner) {
            return 0


    def check_for_checkout(self, ob: MudObject) -> List[MudObject]:
            object* obs = [})
            if (_something_checkedout && ob) {
            if (living(ob)) {
            obs = filter(deep_inventory(ob), (: is_checkout_object($1) :))
            if (sizeof(obs)) {
            foreach (ob in obs) {
            if (!destroy_checkout_object(ob)) {
            obs -= [ob]


    def verify_destroy_checkout_object(self, ob: MudObject) -> None:
            if (destroy_checkout_object(ob)) {
            tell_room(environment(), ob.the_short() +
            " magically checks itself back in.\n")


    def event_exit(self, ob: MudObject, message: str, to: MudObject) -> None:
            object *obs
            if (ob.query_property("destroy checkout object")) {
            return


    def event_dest_me(self, ob: MudObject) -> None:
            check_for_checkout(ob)


    def return_all_checkedout_objects(self, ) -> None:
            object ob
            object* obs
            if (_something_checkedout) {
            obs = filter(deep_inventory(self), (: is_checkout_object($1) :))
            if (sizeof(obs)) {
            foreach (ob in obs) {
            destroy_checkout_object(ob)


    def dest_me(self, ) -> None:
            ::dest_me()


    def is_able_to_change(self, ob: MudObject) -> int:
            return is_allowed(this_player()->query_name()) ||
            is_helper(this_player()->query_name())


    def do_buy(self, obs: MudObject, force: int) -> int:
            if (!is_open_for("buy", this_player()->query_name()) ||
            !is_open_for("use", this_player()->query_name())) {
            add_failed_mess("You cannot buy anything at this shop.\n")
            return 0


    def do_check_sell(self, obs: MudObject) -> int:
            int *stuff
            object ob
            string ret
            string place
            place = query_property("place")
            if (!place) {
            place = "default"


    def do_list_approval(self, approved: int) -> int:
            class approval_obs approve
            int pos
            int shown
            int allowed
            int checkout
            string place
            string ret
            object* obs
            object *current
            object* result
            string *possible_names
            string start
            mapping result_type
            int i
            int fluff
            place = query_property("place")
            if (!place) {
            place = "default"


    def do_return(self, name: str) -> int:
            object *obs
            object *ok
            object *here
            object *fail
            object *checkout
            object money
            class approval_obs approve
            object ob
            int pos
            int i
            int value
            string place
            approve = query_approval_class(name)
            if (!approve) {
            return 0


    def do_approve_item(self, name: str, money_str: str) -> int:
            int cost
            object *obs
            class approval_obs approve
            string place
            int final_cost
            int num
            if (!is_allowed(this_player()->query_name()) &&
            !is_helper(this_player()->query_name())) {
            add_failed_mess("You are not allowed to approve items.\n")
            return 0


    def reset_weekly_status(self, ) -> None:
            _weekly_stats = new(class weekly_stats)
            _weekly_stats->num_sold = 0
            _weekly_stats->total_cost = 0
            _weekly_stats->total_made = 0
            _weekly_stats->num_bought = 0
            _weekly_stats->helper = ([ ])


    def query_weekly_status_string(self, ) -> str:
            string ret
            string place
            string player
            class helper_stats helpers
            class item_stats items
            string* item_bits
            string item
            int num
            place = query_property("place")
            ret = "$I$0=Total Outgoing  : " +
            MONEY_HAND.money_value_string(_weekly_stats->total_cost, place) + "\n"
            ret += "$I$0=Total Incoming : " +
            MONEY_HAND.money_value_string(_weekly_stats->total_made, place) + "\n"
            if (_weekly_stats->total_made > _weekly_stats->total_cost) {
            ret += "$I$0=Profit of      : " +
            MONEY_HAND.money_value_string(_weekly_stats->total_made - _weekly_stats->total_cost, place) + "\n"
            } else {
            ret += "$I$0=Loss of        : " +
            MONEY_HAND.money_value_string(-(_weekly_stats->total_made - _weekly_stats->total_cost), place) + "\n"


    def do_approve_reject(self, name: str, mess: str, reject_pos: int) -> int:
            object *obs
            object *ok
            object *here
            object *checkout
            object ob
            object play
            class approval_obs approve
            int pos
            int i
            int ret
            string ob_mess
            approve = query_approval_class(name)
            if (!approve) {
            return 0


    def check_reject_note(self, str: str, ob_str: str, name: str) -> None:
            str = lower_case(str)
            if (!strlen(str) ||
            (str[0] != 'y' &&
            str[0] != 'n')) {
            write("Please answer yes or no.\nWould you like to send them "
            "a note about it as well?")
            input_to("check_reject_note", 0, ob_str, name)
            return


    def send_reject_note(self, mess: str, name: str) -> None:
            if (!mess) {
            write("Aborted.\n")
            return


    def do_approve_browse(self, name: str) -> int:
            object *obs
            object ob
            string read
            string ret
            string bits
            class approval_obs approve
            int pos
            string place
            approve = query_approval_class(name)
            if (!approve) {
            return 0


    def do_approve_checkout(self, name: str) -> int:
            object *obs
            object *bad
            object *checkout
            object ob
            class approval_obs approve
            int pos
            int i
            approve = query_approval_class(name)
            if (!approve) {
            return 0


    def do_approve_checkin(self, obs: Any) -> int:
            object ob
            object* ok
            ok = [})
            foreach (ob in obs) {
            if (is_checkout_object(ob)) {
            destroy_checkout_object(ob)
            ok += [ob]


    def do_approve_name_change(self, name: str, new_name: str) -> int:
            class approval_obs approve
            if (!is_allowed(this_player()->query_name()) &&
            !is_helper(this_player()->query_name())) {
            add_failed_mess("You are not allowed to approve items.\n")
            return 0


    def do_approve_category_change(self, name: str, new_category: str) -> int:
            class approval_obs approve
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to approve items.\n")
            return 0


    def do_approve_auto_low(self, cost: str) -> int:
            string place
            int value
            place = query_property("place")
            if (!place) {
            place = "default"


    def do_approve_auto_high(self, cost: str) -> int:
            string place
            int value
            place = query_property("place")
            if (!place) {
            place = "default"


    def do_approve_auto_high_deny(self, cost: str) -> int:
            string place
            int value
            place = query_property("place")
            if (!place) {
            place = "default"


    def do_approve_auto_item_test(self, obs: Any) -> int:
            object ob
            string place
            mixed cost
            int found
            int allowed
            class expression_type stuff
            class parse_node frog
            allowed = is_allowed(this_player()->query_name()) ||
            is_helper(this_player()->query_name())
            place = query_property("place")
            if (!place) {
            place = "default"


    def do_approve_auto_item_remove(self, item: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to set automatic approval items.\n")
            return 0


    def do_approve_auto_item_remove_object(self, obs: MudObject) -> int:
            object ob
            object *bad
            object *ok
            string name
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to set automatic approval items.\n")
            return 0


    def do_approve_auto_expression_remove(self, idstr: str) -> int:
            class expression_type expr
            int id
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to set automatic approval items.\n")
            return 0


    def do_approve_percentage(self, num: Any) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to set automatic approval items.\n")
            return 0


    def do_approve_limit(self, limit: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to set any limits on selling "
            "items.\n")
            return 0


    def do_approve_limit_person_items(self, name: str, value: str) -> int:
            int amt
            class seller_information info
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to set any limits on selling "
            "items.\n")
            return 0


    def do_approve_limit_person_value(self, name: str, money: str) -> int:
            class seller_information info
            int value
            string place
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to set any limits on selling "
            "items.\n")
            return 0


    def do_approve_limit_person_value_deny(self, name: str, money: str) -> int:
            class seller_information info
            int value
            string place
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to set any limits on selling "
            "items.\n")
            return 0


    def do_approve_limit_person_remove(self, name: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to remove limits "
            "off someone.\n")
            return 0


    def query_main_status(self, hint: int) -> str:
            string ret
            string place
            string name
            class seller_information stuff
            string *bits
            if (!is_allowed(this_player()->query_name()) &&
            !is_helper(this_player()->query_name())) {
            add_failed_mess("You are not allowed to see the status of this store.\n")
            return 0


    def query_expression_status(self, hint: int) -> str:
            string ret
            string place
            mixed expr
            string str
            int pos
            class expression_type bing
            class expression_type binger
            class approval_item approval
            place = query_property("place")
            if (!place) {
            place = "default"


    def do_main_status(self, hint: int) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("Cannot do that!\n")
            return 0


    def do_expression_status(self, hint: int) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("Cannot do that!\n")
            return 0


    def do_approve_pay_deficit(self, ) -> int:
            int cost
            string place
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to pay off the deficit for " +
            the_short() + ".\n")
            return 0


    def do_category_description(self, category: str, desc: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to add categories.\n")
            return 0


    def do_category_information(self, category: str, desc: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to add categories.\n")
            return 0


    def do_add_new_category(self, category: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to add categories.\n")
            return 0


    def do_remove_category(self, category: str) -> int:
            object* obs
            string old_cat
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to remove categories.\n")
            return 0


    def do_rename_category(self, category: str, new_category: str) -> int:
            object* obs
            object ob
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to rename categories.\n")
            return 0


    def do_set_default_category(self, default_cat: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to set the default category.\n")
            return 0


    def do_list_categories(self, ) -> int:
            string cat
            string ret
            ret = ""
            foreach (cat in query_controller()->query_categories()) {
            if (cat == query_default_category()) {
            ret += cat + " (default)\n"
            } else {
            ret += cat + "\n"


    def do_stats_items(self, type: int) -> int:
            class shop_stats stat
            string ret
            string *bits
            string place
            string name
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You cannot read " + the_short() + "'s ledger.\n")
            return 0


    def do_stats_transactions(self, ) -> int:
            class shop_transaction bing
            string ret
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You cannot read " + the_short() + "'s ledger.\n")
            return 0


    def do_stats_money(self, ) -> int:
            string ret
            int stock_value
            string place
            object ob
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You cannot read " + the_short() + "'s ledger.\n")
            return 0


    def do_helper_list(self, ) -> int:
            write("$I$3=The current helpers are: " +
            query_multiple_short(_helpers) + ".\n")
            return 1


    def do_helper_add(self, helper: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to mess with the helpers.\n")
            return 0


    def do_helper_remove(self, helper: str) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to mess with the helpers.\n")
            return 0


    def init(self, ) -> None:
            expression_util::init()
            craft_shop_category::init()
            add_command("waiting", "", (: do_list_approval(1) :))
            add_command("waiting", "unapproved", (: do_list_approval(0) :))
            add_command("reject", "<string'id'>",
            (: do_approve_reject($4[0], 0, -1) :))
            add_command("retrieve", "<string'id'>", (: do_return($4[0]) :) )
            add_command("return", "<string'id'>", (: do_return($4[0]) :) )
            add_command("value", "<indirect:object>",
            (: do_approve_auto_item_test($1) :))
            if (!is_helper(this_player()->query_name())) {
            return


    def __init__(self):
            self._menu_items = ([ ])
            self._menu_aliases = ([ ])
            self._menu_header = "The menu reads:"
            self._display_header = 1
            self._menu_subheadings = ['Appetisers', 'Main Courses', 'Desserts']
            self._display_subheadings = 1
            self._menu_object = clone_object( PUB_MENU_FILE )
            self._counter = make_counter()


    def __init__(self):
            self._menu_items = ([ ])
            self._menu_aliases = ([ ])
            self._menu_header = "The menu reads:"
            self._display_header = 1
            self._menu_subheadings = ['Appetisers', 'Main Courses', 'Desserts']
            self._display_subheadings = 1
            self._menu_object = clone_object( PUB_MENU_FILE )
            self._counter = make_counter()


    def init(self, ) -> None:
            this_player()->add_command( "buy", self, "<string>" )
            this_player()->add_command( "buy", self,
            "<string> for <indirect:living:here>" )
            this_player()->add_command( "order", self, "<string>",
            (: do_buy( $1, $2, $3, $4 ) :) )
            this_player()->add_command( "order", self,
            "<string> for <indirect:living:here>",
            (: do_buy( $1, $2, $3, $4 ) :) )


    def query_pub(self, ) -> int:
            return 1


    def set_language(self, language: str) -> None:
            _language = language


    def query_language(self, ) -> str:
            return _language


    def remove_menu_item(self, name: str) -> int:
            if( !_menu_items[name] ) {
            return 0


    def string_menu(self, items: str) -> str:
            int loop
            string str, place
            str = ""
            place = self.query_property( "place" )
            if( !place || ( place == "" ) ) {
            place = "default"


    def string_menu_of_type(self, type: int) -> str:
            string str
            string *items
            items = query_items_of_type( type )
            if( !sizeof(items) ) {
            return ""


    def read(self, ) -> str:
            string ret
            ret = "\n"
            if( _display_header ) {
            ret += _menu_header + "\n"


    def set_display_header(self, value: int) -> None:
            _display_header = value


    def query_display_header(self, ) -> int:
            return _display_header


    def set_menu_header(self, header: str) -> None:
            _menu_header = header


    def query_menu_header(self, ) -> str:
            return _menu_header


    def set_display_subheadings(self, value: int) -> None:
            _display_subheadings = value


    def query_display_subheadings(self, ) -> int:
            return _display_subheadings


    def set_menu_subheadings(self, subheading: int, text: str) -> None:
            _menu_subheadings[ subheading ] = text


    def add_menu_alias(self, alias: Any, actual: str) -> None:
            string bing
            if (arrayp(alias)) {
            foreach (bing in alias) {
            add_menu_alias(bing, actual)


    def add_menu_aliases(self, aliases: str, actual: str) -> None:
            string alias
            foreach( alias in aliases ) {
            add_menu_alias( alias, actual )


    def remove_menu_alias(self, alias: str) -> int:
            if( !_menu_aliases[alias] ) {
            return 0


    def set_no_standard_alias(self, flag: int) -> None:
            no_standard_alias = flag


    def query_no_standard_alias(self, ) -> int:
            return no_standard_alias


    def create_real_object(self, name: str) -> MudObject:
            object item, container
            if( _menu_items[name]->container ) {
            container = self->create_container(
            _menu_items[name]->container )
            if( !container ) {
            container = clone_object( _menu_items[name]->container )


    def do_buy(self, obs: MudObject, dir: str, indir: str, args: Any) -> int:
            int value, cost
            string str, place
            object person, thing
            object *succeededpeople, *deadpeople, *failedpeople, *poorpeople
            succeededpeople = [})
            deadpeople = [})
            failedpeople = [})
            poorpeople = [})
            str = args[0]
            if( this_player()->query_property( "dead" ) ) {
            add_failed_mess( "How can you expect to buy " + str + " when you're "
            "dead?\n" )
            return 0


    def dest_me(self, ) -> None:
            if( _menu_object ) {
            _menu_object.dest_me()


    def make_counter(self, ) -> MudObject:
            object ob
            ob = clone_object( PUB_COUNTER_FILE )
            add_hidden_object( ob )
            return ob


    def query_counter(self, ) -> MudObject:
            return _counter


    def query_menu(self, ) -> MudObject:
            return _menu_object


    def __init__(self):
            self._events = []


    def add_shop_observer(self, observer: MudObject) -> None:
            if (!_events) {
            _events = [})


    def remove_shop_observer(self, observer: MudObject) -> None:
            _events -= [observer]


    def broadcast_shop_event(self, type: str, player: MudObject, args: Any) -> int:
            debug_printf("Calling %O on %O\n", "event_shop_" + type, _events)
            if (sizeof(filter(call_other(_events, "event_shop_" + type, self,
            player, args ...),
            (: $1 :)))) {
            return 1


    def event_weather(self, whats_changed: int) -> None:
            if(whats_changed >= 8){
            if (_flag) {
            asyncio.create_task(self."night_time_check", 1)
            } else {
            asyncio.create_task(self."day_time_check", 1)


    def close_up(self, ) -> None:
            object *obs
            object *people
            object bing
            object *keeper_ob
            int i
            if (_keeper == "none") {
            event (self, "person_say", "The shopkeeper says: ",
            "I'm sorry, it's time to close!", "common")
            tell_room (self, "The shopkeeper ushers you out of "
            "the store.\n")


    def open_up(self, ) -> None:
            int i
            for(i=0; i<sizeof(_outside_rooms); i++){
            _outside_rooms[i]->modify_exit(_exits[i], ({"open", 1, "locked", 0,
            "difficulty", 4}))


    def event_enter(self, ob: MudObject, message: str, from: MudObject) -> None:
            if (!_burglar) {
            return


    def init_dynamic_arg(self, map: Any) -> None:
            _keeper_ob = map["keeper ob"]


    def set_vault_exit(self, direc: str, dest: Any, type: str) -> None:
            vault_room = dest
            add_exit(direc, dest, type)
            modify_exit( direc, ["function", "check_customer"] )
            modify_exit( direc, ["closed", 1}))


    def apply_for_account(self, ) -> int:
            string owner
            object container
            if(!proprietor || environment(proprietor) != self)
            return notify_fail("The vault is closed since the proprietor is "
            "missing.\n")
            this_player()->add_succeeded_mess( self, "", [}) )
            write("You ask for an account.\n")
            say((string)this_player()->one_short() +" asks for an account.\n")
            owner = (string)this_player()->query_name()
            if ( master()->file_exists( VAULT_SAVE +vault_name+ "/"+ owner +".o" ) ||
            query_property( owner ) )
            {
            if ( this_player()->query_property( "vault warned" ) ) {
            proprietor.do_command( "glare "+ this_player()->query_name() )
            proprietor->do_command( "say I just said, you already have an "
            "account." )
            return notify_fail("")


    def init(self, ) -> None:
            add_command( "apply", "for [an] account", (: apply_for_account :) )


    def check_customer(self, verb: str, thing: MudObject, special: str) -> int:
            string owner
            object vroom
            if(!proprietor || environment(proprietor) != self)
            return notify_fail("The vault is closed since the proprietor is "
            "missing.\n")
            if( !interactive(thing) )
            return 0
            owner = (string)thing.query_name()
            if ( !master()->file_exists( VAULT_SAVE +vault_name+ "/" + owner +".o" ) &&
            !query_property( owner ) )
            {
            tell_object( thing, PTS+
            " intercepts you.\n" )
            tell_room( self, PTS+" intercepts "+
            (string)thing.the_short() +".\n",
            thing )
            if ( thing.query_property( "vault warned" ) ) {
            proprietor.do_command( "glare "+ thing->query_name() )
            proprietor->do_command( "say I just said, you don't have an account "
            "so I won't let you in!" )
            return notify_fail("")


    def check_idler(self, who: MudObject) -> None:
            if(who && base_name(environment(who)) == vault_room) {
            tell_object(who, "You've been in here too long so " + PTS + " comes and "
            "drags you out.\n")
            who->move_with_look(self,
            "$N is dragged out of the vault by the hair.",
            "$N is dragged out of the vault by the hair.")


    def player_quitting(self, who: MudObject, env: MudObject) -> None:


    def __init__(self):


    def clear_item(self, item: MudObject) -> None:
            if( environment( item ) == self
            && !sizeof( all_inventory( item ) ) )
            item.move( "/room/rubbish" )


    def event_enter(self, ob: MudObject, mess: str, from: MudObject) -> None:
            if( ob.query_property( "pub item" )
            && !sizeof( all_inventory( ob ) ) )
            asyncio.create_task(self. "clear_item", 3, ob )


    def __init__(self):


    def __init__(self):
            add_item("calculator", "A standard shop's calculator used to total "
            "up all those difficult prices.  To use, see \"syntax calc\".")
            add_help_file("player_shop_counter")


    def init(self, ) -> None:
            {
            ::init()
            if (!_office || _office == "") return
            this_player()->command_override((: action :))
            add_command("calc", "<number> {+|-|*|/} <number>",
            (: do_calc($4[0],$4[1],$4[2]) :))
            if (_office.query_employee(this_player()->query_name()) ||
            this_player()->query_creator())
            {
            add_command("log",
            "shop {bought|sold} <number> <string'item(s)'> for <word'amount'>",
            (: do_log($4) :))
            add_command("correction",
            "shop {bought|sold} <number> <string'item(s)'> for <word'amount'>",
            (: do_correction($4) :))


    def action(self, str: str) -> int:
            {
            string st1
            if (_office.query_employee(this_player()->query_name()) ||
            this_player()->query_creator())
            return 0
            sscanf(str,"%s %s",str,st1)
            if(str == "get" || str == "take")
            if (strsrch(st1, "register") != -1)
            {
            await this_player().send("You are not an active employee here!\n")
            return 1


    def add_money_ob(self, money: MudObject) -> None:
            {
            if (previous_object() && previous_object() != find_object(_office))
            {
            LOG_ERROR("counter.c", "add_money_ob()")
            return


    def adjust_register(self, player: str, amount: int) -> int:
            {
            int value
            object cash, change
            if (previous_object() && previous_object() != find_object(_office))
            {
            LOG_ERROR("counter.c", "adjust_register(" + player+","+amount+")")
            return 0


    def directions_to(self, place: str) -> str:
            {
            if (place == _storeroom) return _store_dir
            if (place == _office) return _office_dir
            if (place == _shop_front) return _shop_dir
            return "here"


    def event_death(self, k: MudObject, o: MudObject, k2: MudObject, r: str, k3: str) -> None:
            {
            _office.event_death(k, o, k2, r, k3)


    def event_enter(self, ob: MudObject, message: str, from: MudObject) -> None:
            {
            _office.event_enter(ob, message, from)


    def query_register(self, ) -> int:
            {
            object cash = present(MONEY_ALIAS, _register)
            if (!cash) return 0
            _money = cash.query_money_array() + ({})
            return MONEY_HAND.query_total_value(_money, _place)


    def save_register(self, no_player: int) -> None:
            {
            remove_asyncio.create_task(self._call_save)
            _call_save = asyncio.create_task(self.(: save_me($((!no_player)?
            this_player()->query_name():"shop")) :), 1)


    def __init__(self):


    def init(self, ) -> None:
            {
            ::init()
            if (!_office || _office == "") return
            if ( !_office.query_manager(this_player()->query_name()) &&
            !_office.query_retired(this_player()->query_name()) &&
            !this_player()->query_creator()) return
            add_command("list", ({LIST_BLANK, LIST_CHOICE}),
            (: do_list($4) :))
            add_command("memo", "", (: do_memo() :))
            add_command("office", "", (: do_office() :))
            add_command("claim", "", (: do_claim() :))
            add_command("accounts", "", (: do_accounts() :))
            add_command("logs", ({LOG_BLANK, LOG_NUMBER, LOG_MGR}),
            (: do_logs($4,$5) :))
            add_command("mail", ({"", "<string>"}), (: do_mail($4) :))
            add_command("query", "{pay|employees}", (: do_query($4[0]) :))
            add_command("view", ({VIEW_EMP, VIEW_APP}), (: do_view($4[0],$5) :))
            add_command("project", "{pay|bonus}", (: do_project($4[0]) :))
            add_command("vote", VOTE_POLICY, (: do_vote($4,$5) :))
            add_command("policy", ({POLICY_SUGGEST, POLICY_REMOVE}),
            (: do_policy($4,$5) :))
            add_command("policies", "", (: do_policies() :))
            if (_office.query_retired(this_player()->query_name())) return
            add_command("rent", "cabinet", (: do_rent() :))
            add_command("remove", "cabinet", (: do_remove() :))
            add_command("retire", "", (: do_retire() :))
            add_command("vote", VOTE_APPLICANT, (: do_vote($4,$5) :))
            add_command("check", "votes", (: do_check() :))
            add_command("commend", "<word'employee'>", (: do_commend($4[0]) :))
            add_command("fire", "<word'employee'> [for] <string'reason'>",
            (: do_fire($4) :))
            add_command("warn", "<word'employee'> [for] <string'reason'>",
            (: do_warn($4) :))
            add_command("demote", "<word'employee'>", (: do_demote($4[0]) :))
            add_command("suspend", "<word'employee'> [for] <number> [months]",
            (: do_suspend($4) :))
            add_command("leave", "<word'employee'> [for] <number> [days]",
            (: do_leave($4) :))
            add_command("ban", "<word'person'> [for] <string'reason'>",
            (: do_ban($4) :))
            add_command("unban", "<word'person'>", (: do_unban($4[0]) :))
            add_command("set", ({SET_EMPS, SET_PAY}), (: do_set($4,$5) :))
            add_command("transfer", "<number'amount'> <string'type'> [from] "
            "{register|bonus|profit} [to] {register|bonus|profit}",
            (: do_transfer($4) :))


    def dest_me(self, ) -> None:
            {
            if (_notice) _notice.dest_me()
            ::dest_me()


    def event_death(self, k: MudObject, o: MudObject, k2: MudObject, r: str, k3: str) -> None:
            {
            _office.event_death(k, o, k2, r, k3)


    def event_enter(self, ob: MudObject, message: str, from: MudObject) -> None:
            {
            _office.event_enter(ob, message, from)


    def __init__(self):


    def num_employees_in(self, ) -> int:
            {
            int any = 0
            foreach (string word in m_indices(_employees))
            if (_employees[word][EMP_POINTS] & CLOCKED_IN)
            {
            if (_employees[word][EMP_POINTS] & NPC) continue
            if (!find_player(word) || !interactive(find_player(word)))
            {
            reset_employee(word, CLOCKED_IN)
            shop_log(GENERAL, word, "was clocked out", UNPAID)


    def query_applicant(self, player: str) -> int:
            {
            load_applicants()
            clear_applicants()
            if (!sizeof(_applicants)) return FALSE
            if (_applicants[player]) return copy(_applicants[player][APP_TYPE])
            return FALSE


    def query_baddie(self, player: str) -> int:
            {
            if (!m_sizeof(_baddies)) return FALSE
            if (_baddies[player]) return copy(_baddies[player][BAD_TIME])
            return FALSE


    def query_declined(self, player: str) -> int:
            {
            if (!sizeof(_declined)) return FALSE
            if (_declined[player]) return copy(_declined[player])
            return FALSE


    def query_employee(self, player: str) -> int:
            {
            if (_employees[player]) return copy(_employees[player][EMP_POINTS])
            return FALSE


    def query_list_string(self, ) -> str:
            {
            if (!m_sizeof(_list)) return "absolutely nothing at the moment"
            return query_multiple_short(m_indices(_list))


    def query_manager(self, player: str) -> int:
            {
            if (_employees[player]) return (_employees[player][EMP_POINTS] & MANAGER)
            return FALSE


    def query_policy(self, policy: str) -> int:
            {
            load_policies()
            clear_policies()
            if (m_sizeof(_policies) && _policies[policy]) return 2
            load_new_policies()
            clear_new_policies()
            if (m_sizeof(_new_policies) && _new_policies[policy]) return 1
            return 0


    def query_retired(self, player: str) -> int:
            {
            return (_retired.index(player) if player in _retired else -1 == -1)?FALSE:TRUE


    def query_supervisor(self, player: str) -> int:
            {
            if (_employees[player])
            return (_employees[player][EMP_POINTS] & SUPERVISOR)
            return FALSE


    def shop_very_short(self, {: Any) -> str:
            ==================================================
            FILE: shops/player_shop/shop_front.c
            ==================================================
            inherit "/std/room/basic_room"
            private nosave class applying_player
            {
            int step
            string *answers


    def __init__(self):


    def __init__(self):
            add_help_file("player_shop_shopfront")


    def init(self, ) -> None:
            {
            string tp
            ::init()
            if (!_office || _office == "") return
            tp = this_player()->query_name()
            _office.summon_shopkeeper()
            add_command("complain", "", (: do_complain() :))
            add_command("suggestion", "", (: do_suggestion() :))
            if (!check_employee("void", this_player(), "void"))
            add_command("apply", "", (: do_apply() :))
            if ( _office.query_applicant(tp) == HIRED)
            add_command("confirm", "employment", (: do_confirm() :))
            if (_office.query_applicant(tp))
            add_command( "cancel", "application", (: do_cancel() :) )


    def check_employee(self, verb: str, thing: MudObject, special: str) -> int:
            {
            if (thing.query_creator() ||
            _office.query_retired(thing->query_name())) return 1
            return _office.query_employee(thing->query_name())


    def directions_to(self, place: str) -> str:
            {
            if (place == _counter || place == _office || place == _storeroom)
            return copy(_inside)
            return "here"


    def event_death(self, k: MudObject, o: MudObject, k2: MudObject, r: str, k3: str) -> None:
            {
            _office.event_death(k,o,k2,r,k3)


    def event_enter(self, ob: MudObject, message: str, from: MudObject) -> None:
            {
            mapping baddies
            int days
            string name = ob.query_name()
            if (_office.query_baddie(name))
            {
            baddies = _office.get_baddies()
            days = (((BAN_LENGTH*60*60*24) -
            (time() - baddies[name][2])) / (60*60*24)) + 1
            tell_room(self, ob.query_short()+
            " drifts out of the door, seemingly against "+
            ob.query_possessive()+ " will.\n", ({ob}))
            tell_object(ob, "You feel yourself pushed out of the shop by "
            "a mysterious force.\nYou have been banned from this shop for "+
            baddies[name][0]+ " and will not be re-admitted for a maximum of "+
            query_num(days)+ " days.\n")
            ob.move(_outside)


    def long(self, word: str, dark: int) -> str:
            {
            int emps_in = 0
            if (find_object(_office.query_shopkeeper()) &&
            _office.query_employee(_office->query_shopkeeper()->
            query_name()) & CLOCKED_IN)
            {
            emps_in = 1


    def query_outside(self, {: Any) -> str:
            protected void set_exit_counter(string direction)
            {
            _inside = direction
            add_exit(direction, _counter, "hidden")
            modify_exit(direction, ({"function", "check_employee"}))


    def sign_text(self, ) -> str:
            {
            string *eom = _office.query_eom()
            return sprintf("\n%%^YELLOW%%^  Employee Of The Month for %s : %s%%^RESET%%^\n\n",
            eom[0], cap_name(eom[1]))


    def tinkle_bell(self, action: str) -> int:
            {
            tell_room(self, "The bell tinkles as the door "+
            action+ "s.\n")
            tell_room(find_object(_counter), "The bell over the shop door "
            "tinkles.\n")
            tell_room(find_object(_office), "You hear the bell tinkle in "
            "the main room of the shop.\n")
            tell_room(find_object(_storeroom), "You hear the bell tinkle in "
            "the main room of the shop.\n")
            tell_room(find_object(_mgr_office), "You hear the bell tinkle in "
            "the main room of the shop.\n")
            return 1


    def __init__(self):


    def __init__(self):


    def attack_by(self, baddie: MudObject) -> None:
            {
            if (_office == "") return
            self.stop_fight(baddie)
            baddie.stop_fight(self)
            do_command("'Why are you attacking me, "+ baddie.query_cap_name()+ "?")
            do_command("'I'm not staying here for this!")
            do_command(_office.query_channel()+ "@ is being attacked by "+
            baddie.query_cap_name()+ ".")
            asyncio.create_task(self."shuffle_to", NPC_DELAY, _office, (: end_shift() :))
            _office.event_death(self, 0, baddie, 0, 0)
            #ifdef DEBUG
            tell_creator(CREATOR,  "Attacked by %s.\n", baddie.query_short())
            #endif


    def do_buy(self, stuff: str) -> int:
            {
            #ifdef DEBUG
            tell_creator(CREATOR,  "In do_buy()\n")
            #endif
            if (outside_hours(TRUE)) return 1
            say_to_room(this_player(), "say", "I would like to buy "+ stuff +
            ", please.\n%^RESET%^")
            if (query_busy())
            init_command(":seems busy at the moment.", NPC_DELAY)
            else
            {
            set_busy(this_player())
            asyncio.create_task(self.(: sell_something($(stuff)) :), NPC_DELAY)


    def do_browse(self, item: str) -> int:
            {
            #ifdef DEBUG
            tell_creator(CREATOR,  "In do_browse()\n")
            #endif
            if (outside_hours(TRUE)) return 1
            say_to_room(this_player(), "ask", "How much do "+ item +" cost?\n")
            if (query_busy())
            init_command(":seems busy at the moment.", NPC_DELAY)
            else
            {
            set_busy(this_player())
            asyncio.create_task(self.(: how_much($(item)) :), NPC_DELAY)


    def do_list(self, args: Any) -> int:
            {
            #ifdef DEBUG
            tell_creator(CREATOR,  "In do_list()\n")
            #endif
            if (outside_hours(TRUE)) return 1
            if (!sizeof(args) || !args[0] || args[0] == "")
            {
            say_to_room( this_player(), "ask", "What items do you buy and sell?\n")
            if (query_busy())
            init_command(":seems busy at the moment.", NPC_DELAY)
            else
            {
            set_busy(this_player())
            asyncio.create_task(self.(: what_items() :), NPC_DELAY)


    def do_sell(self, obs: MudObject) -> int:
            {
            #ifdef DEBUG
            tell_creator(CREATOR,  "In do_sell()\n" )
            #endif
            if (outside_hours(TRUE)) return 1
            say_to_room(this_player(), "say", "I would like to sell " +
            query_multiple_short(obs, "the")+ ", please.\n%^RESET%^")
            if (query_busy())
            init_command(":seems busy at the moment.", NPC_DELAY)
            else
            {
            set_busy(this_player())
            asyncio.create_task(self.(: buy_something($(obs)) :), NPC_DELAY)


    def event_person_say(self, thing: MudObject, start: str, mess: str, lang: str) -> None:
            {
            string words
            #ifdef DEBUG
            tell_creator(CREATOR,  "In event_person_say()\n" )
            #endif
            if (outside_hours(TRUE)) return
            if (!mess || (mess == "")) return
            mess = lower_case(mess)
            if (query_busy()) return
            set_busy(thing)
            if (sscanf(mess, "%*s buy %s, please.", words) == 2)
            {
            asyncio.create_task(self.(: sell_something($(words)) :), NPC_DELAY)
            return


    def init(self, ) -> None:
            {
            object tp = this_player()
            #ifdef DEBUG
            tell_creator(CREATOR,  "In init()\n" )
            #endif
            if (environment(self) == find_object("/room/rubbish")) return
            #ifdef DEBUG
            tell_creator(CREATOR,  "Not in /room/rubbish\n")
            #endif
            ::init()
            tp.add_command("buy", self, "<string'item(s)'>",
            (: do_buy($4[0]) :))
            tp->add_command("sell", self, "<indirect:object:me>",
            (: do_sell($1) :))
            tp.add_command("list", self, ({"", "<string'item(s)'>"}),
            (: do_list($4) :))
            tp.add_command("browse", self, "<string'item(s)'>",
            (: do_browse($4[0]) :))
            outside_hours(TRUE)


    def query_office(self, {: Any) -> str:
            private void say_to_room(object me, string t, string message)
            {
            await me.send("You "+ t+ ": "+ message)
            foreach(object player in all_inventory(environment(self)))
            if (interactive(player) && player != me)
            await player.send(player.colour_event("say", "%^CYAN%^")+
            me.query_short()+ " "+ t + "s: "+ message)


    def set_failed(self, failed: int) -> None:
            protected void set_office(string path)
            {
            mapping values
            string new_key
            _office = path
            _place = _office.query_place()
            _smallest_in = MONEY_HAND.smallest_in( _place )
            _smallest_value_in = MONEY_HAND.smallest_value_in(_place)
            _smallest_plural_in = MONEY_HAND.query_plural_for(_smallest_in)
            values = MONEY_HAND.query_mapped_values_in(_place)
            foreach(string key in keys(values))
            {
            new_key = MONEY_HAND.query_aliases_for(key)[0]
            _values_sing += ([new_key:values[key]])
            new_key = MONEY_HAND.query_details_for(key)[5]
            _values_plural += ([new_key:values[key]])


    def shuffle_to(self, location: str, next_action: Any) -> None:
            {
            string direc = environment()->directions_to(location)
            if (!direc)
            {
            if (environment() == find_object("/room/rubbish")) return
            if (environment() == _shop_front.query_outside())
            {
            move(_shop_front, "$N enter$s the shop.",
            "$N enter$s _shop_front.query_short().")


    def start_shift(self, ) -> None:
            {
            #ifdef DEBUG
            tell_creator(CREATOR,  "In start_shift()\n" )
            #endif
            if (outside_hours(FALSE)) return
            set_busy(self)
            move(_office, "$N arrive$s for " + query_possessive()+ " shift.")
            if (_office.query_employee(query_name()) & CLOCKED_IN)
            do_command("clock out")
            do_command("claim badge")
            do_command("wear badge")
            do_command("clock in")
            do_command(_office.query_channel()+ "@ is clocking in.")
            asyncio.create_task(self."shuffle_to", NPC_DELAY, _shop_front, 0)


    def __init__(self):


    def __init__(self):
            add_help_file("player_shop_storeroom")


    def init(self, ) -> None:
            {
            ::init()
            if (!_office || _office == "") return
            add_command("add", ({"<indirect:object:me'item(s)'>",
            "<indirect:object:me'item(s)'> to cabinet <number'cabinet'>"}),
            (: do_add($1,$4) :))
            add_command("pull", "roll", (: pull_roll() :))
            if (_office.query_employee(this_player()->query_name()) ||
            this_player()->query_creator())
            {
            add_command("list", ({LIST_BLANK, LIST_CABINET,
            LIST_ITEM, LIST_ITEM_CABINET}),
            (: do_list($4,$5) :))
            add_command("remove", ({"<number> <string'item(s)'>",
            "<number> <string'item(s)'> from cabinet <number'cabinet'>"}),
            (: do_remove($4) :))


    def add_cabinet(self, ) -> int:
            {
            object cabinet
            string cab_name
            if (previous_object() && previous_object() != find_object(_office))
            {
            LOG_ERROR("storeroom.c", "add_cabinet()")
            return 0


    def dest_me(self, ) -> None:
            {
            remove_asyncio.create_task(self._call_cabs_clear)
            clear_cabinets()
            ::dest_me()


    def directions_to(self, place: str) -> str:
            {
            if (place == _counter) return copy(_counter_dir)
            if (place == _office) return copy(_office_dir)
            if (place == _shop_front) return copy(_shop_dir)
            return "here"


    def event_death(self, k: MudObject, o: MudObject, k2: MudObject, r: str, k3: str) -> None:
            {
            _office.event_death(k,o,k2,r,k3)


    def event_enter(self, ob: MudObject, message: str, from: MudObject) -> None:
            {
            _office.event_enter(ob, message, from)


    def long(self, word: str, dark: int) -> str:
            {
            return sprintf("%sThere are currently %d store cabinets "
            "in the room.\n", ::long(word,dark), _num_cabinets)


    def query_num_items(self, item: str, cabinet: int) -> int:
            {
            object *obs
            init_cabinets()
            if (cabinet)
            {
            obs = ((class obj_match)match_objects_in_environments(item,
            _cabinets[cabinet-1]))->objects
            if (!sizeof(obs))
            {
            return 0


    def query_stock(self, item: str) -> int:
            {
            object *obs
            init_cabinets()
            if (!_cache[item])
            {
            #ifdef DEBUG
            tell_creator(CREATOR,"Creating %s cache entry.\n", item)
            #endif
            _cache += ([item:({1,0})])


    def remove_cabinet(self, ) -> str:
            {
            object cabinet
            if (previous_object() && previous_object() != find_object(_office))
            {
            LOG_ERROR("storeroom.c", "remove_cabinet()")
            return ""


    def adjust_takings(self, amt: int) -> None:
            {
            if (previous_object() && previous_object() != find_object(_counter))
            {
            LOG_ERROR("office.c", "adjust_bought("+amt+")")
            return


    def calc_bonus(self, ) -> None:
            {
            int bonus_val, bonus_divisor = 0
            foreach (string str in m_indices(_employees))
            {
            if (_employees[str][EMP_NOBONUS]) continue
            if (_employees[str][EMP_POINTS] & MANAGER)
            {
            bonus_divisor += 4


    def calc_pay(self, ) -> int:
            {
            int amount = 0
            foreach(string word in m_indices(_employees))
            amount += _employees[word][EMP_PAY]
            return amount


    def check_manager(self, action: str) -> int:
            {
            object tp = this_player()
            string tp_name = tp.query_name()
            if (tp.query_creator() || (_employees[tp_name][EMP_POINTS] & MANAGER) ||
            (_retired.index(tp_name) if tp_name in _retired else -1 != -1)) return 1
            return notify_fail( "You are not a manager here!\n" )


    def directions_to(self, place: str) -> str:
            {
            if (place == _counter) return copy(_counter_dir)
            if (place == _storeroom) return copy(_store_dir)
            if (place == _shop_front) return copy(_shop_dir)
            return "here"


    def do_set(self, args: Any, pattern: str) -> int:
            {
            int value, best
            object money
            switch(pattern)
            {
            case SET_EMPS :
            if (args[0] < MIN_EMP || args[0] > MAX_EMP)
            {
            tell_object(this_player(), "Must be between "+ MIN_EMP+
            " and "+ MAX_EMP+ ".\n")
            return 1


    def do_transfer(self, args: Any) -> int:
            {
            int value, best
            object money
            string tp
            if (args[2] == args[3] || !args[0])
            {
            await this_player().send("The point being?\n")
            return 1


    def set_employee(self, word: str, bit: int) -> None:
            {
            if (!_employees[word]) return
            _employees[word][EMP_POINTS] |= bit
            if (bit != CLOCKED_IN) save_emps()


    def summon_shopkeeper(self, ) -> None:
            {
            object shopkeeper = find_object(_shopkeeper)
            if (shopkeeper && environment(shopkeeper)) return
            if (num_employees_in()) return
            _shopkeeper.start_shift()


    def add_applicant(self, player: str, message: str) -> None:
            {
            if (previous_object() && previous_object() != find_object(_shop_front))
            {
            LOG_ERROR("office.c", "add_applicant("+player+","+message+")")
            return


    def check_hire_list(self, ) -> None:
            {
            int count
            string *hirees = ({})
            load_applicants()
            foreach (string word in m_indices(filter(_applicants,
            (: _applicants[$1][APP_TYPE] == HIRED :))))
            if (time() - _applicants[word][APP_TIME] > HIRE_TIMEOUT)
            {
            PLAYER_SHOP->auto_mail(word, _proprietor,
            _shop_name, "", "Since you have not returned to confirm "
            "your employment with us, we have assumed that you are no "
            "longer interested, and removed your name from our files.  "
            "If you wish to re-apply at any time in the future, please "
            "return to the shop to do so.\n")
            employee_log(word, "Lapsed their application")
            remove_applicant(word)


    def do_cancel(self, ) -> int:
            {
            object tp = this_player()
            remove_applicant(tp.query_name())
            employee_log(tp.query_name(), "Cancelled application")
            await tp.send("You cancel your application.\n")
            return 1


    def do_confirm(self, ) -> int:
            {
            object tp = this_player()
            string applicant = lower_case(tp.query_name())
            if (previous_object() && previous_object() != find_object(_shop_front))
            {
            LOG_ERROR("office.c", "do_confirm()")
            return 0


    def do_vote(self, args: Any, pattern: str) -> int:
            {
            int query_app
            string tp = this_player()->query_name()
            if (pattern == VOTE_APPLICANT)
            {
            args[0] = lower_case(args[0])
            if (!(query_app = query_applicant(args[0])))
            {
            await this_player().send(cap_name(args[0])+
            " hasn't applied!\n")
            return 1


    def do_ban(self, args: Any) -> int:
            {
            if (!test_player(lower_case(args[0])))
            {
            await this_player().send(args[0]+ " is not a player.\n")
            return 1


    def do_unban(self, person: str) -> int:
            {
            if (!query_baddie(person))
            {
            await this_player().send(person+ " is not currently banned.\n")
            return 1


    def confirm_cabinet(self, confirm: str, rent: int) -> None:
            {
            if (previous_object() && previous_object() != self)
            {
            LOG_ERROR("office.c", "confirm_cabinet("+confirm+","+rent+")")
            return


    def do_remove(self, ) -> int:
            {
            int stock
            if (!((stock = _num_cabinets) > MIN_CABINETS))
            {
            tell_object(this_player(), "The shop already contains the "
            "minimum number of cabinets.\n")
            return 1


    def do_rent(self, ) -> int:
            {
            if (!(_num_cabinets < MAX_CABINETS))
            {
            tell_object(this_player(), "The shop already contains the "
            "maximum number of cabinets.\n")
            return 1


    def query_cabinet_used(self, cabinet: int) -> int:
            {
            foreach(string word in m_indices(_list))
            if ( _list[word][CHART_CAB].index(cabinet) if cabinet in _list[word][CHART_CAB] else -1 != -1)
            return TRUE
            return FALSE


    def badge_list(self, ) -> str:
            {
            string *results = ({}),
            *creators = ({})
            foreach(object ob in children(BADGE))
            {
            if (ob == find_object(BADGE)) continue
            if (ob.query_channel() != _channel) continue
            if (environment(ob)->query_creator())
            creators += [environment(ob)->query_name()]


    def do_list(self, ) -> int:
            {
            int emps_in
            string results = "   Employees of "+ _shop_name + "\n"
            "     As at " + ctime(time()) + "\n\n"
            foreach (string word in sort_array(_retired, 1))
            {
            object ob = find_player(word)
            if (ob)
            results += "%^GREEN%^"
            results += "     "+ cap_name(word)+
            "%^RESET%^ (retired manager)\n"


    def employees_clocked_in(self, ) -> str:
            {
            object *words = ({}), ob
            if (!num_employees_in()) words = ({"No employees"})
            if (find_object(_shopkeeper) &&
            _employees[_shopkeeper.query_name()][EMP_POINTS] & CLOCKED_IN)
            words = ({_shopkeeper.query_short()})
            foreach (string word in m_indices(_employees))
            {
            ob = find_player(word)
            if (ob && _employees[word][EMP_POINTS] & CLOCKED_IN)
            words += ({ob.query_cap_name()})


    def do_logs(self, args: Any, pattern: str) -> int:
            {
            string start, end, file, *files, words
            add_succeeded_mess("")
            switch (pattern)
            {
            case LOG_BLANK :
            files = get_dir(_savedir +"general.log*")
            words = "Available logs:\n\n"
            if (sizeof(files))
            words += " 1: current log\n"
            for (int i = sizeof(files); i > 1; i--)
            {
            sscanf(unguarded((: read_file, _savedir + files[i-1], 2, 1 :)),
            "%*s, %s:", start)
            sscanf(unguarded((: read_file, _savedir + files[i-1],
            file_length(_savedir + files[i-1]), 1 :)),
            "%*s, %s: %*s", end )
            if (start == end)
            words += sprintf("%2d: %s\n",
            sizeof(files)-(i-2), start)
            else
            words += sprintf("%2d: %s to %s\n",
            sizeof(files)-(i-2), start, end)


    def shop_log(self, logtype: int, word: str, words: str, paid: int) -> None:
            {
            string date, month, colour
            sscanf(amtime(time()), "%*s %*s %*s %s %*s", month)
            if (file_size(_savedir +"general.log") > 0)
            {
            date = ctime(time())[0 .. 9]
            if (date != unguarded((: read_file,
            _savedir +"general.log", 1, 1 :))[0 .. 9])
            {
            string logfile = _savedir +"general.log-"+ time(),
            summary = sprintf( "%sFor the period ending %s:%s\n",
            "%^BOLD%^", amtime(time()), "%^RESET%^" ),
            sign = ""
            _storeroom.force_load()
            asyncio.create_task(self.(: update_averages() :), 60)
            unguarded((: rename, _savedir +"general.log", logfile :))
            asyncio.create_task(self.(: review_employees() :), 5 )
            foreach (string item in m_indices(_list))
            {
            summary += sprintf(" %s - Bought %d, Sold %d\n", capitalize(item),
            _list[item][CHART_BOUGHT], _list[item][CHART_SOLD])
            _list[item][CHART_AVESALE] = (_list[item][CHART_AVESALE] +
            _list[item][CHART_SOLD] + random(2)) / 2
            _list[item][CHART_SOLD] = 0
            _list[item][CHART_BOUGHT] = 0


    def dest_me(self, ) -> None:
            {
            if (_very_short != UNSET_STR)
            {
            if (remove_asyncio.create_task(self._call_save) != -1) do_save()
            if (remove_asyncio.create_task(self._call_apps) != -1) do_save_applicants()
            if (remove_asyncio.create_task(self._call_hist) != -1) do_save_hist()
            if (remove_asyncio.create_task(self._call_newpols) != -1) do_save_new_policies()
            if (remove_asyncio.create_task(self._call_pols) != -1) do_save_policies()
            if (remove_asyncio.create_task(self._call_times) != -1) save_times()
            if (remove_asyncio.create_task(self._call_emps) != -1) do_save_emps()


    def event_enter(self, ob: MudObject, message: str, from: MudObject) -> None:
            {
            string room
            if (!from || ob.query_creator() || from == find_object("/room/void") ||
            !ob.query_player()) return
            room = file_name(from)
            if (room == _counter || room == _shop_front || room == _storeroom ||
            room == _mgr_office || from == self) return
            #ifdef DEBUG
            tell_creator(CREATOR, "%s arrived from %O.\n", ob.query_name(), from)
            #endif
            fire_them(_proprietor, ob.query_name(), "for teleporting into the shop")


    def init(self, ) -> None:
            {
            object tp = this_player()
            string word = tp.query_name()
            ::init()
            if (!tp.query_creator() && !_employees[word] &&
            (_retired.index(word) if word in _retired else -1 == -1)) return
            add_command("claim", "{badge|handbook|bonus}", (: do_claim($4[0]) :))
            add_command("resign", "", (: do_resign() :))
            add_command("list", "", (: do_list() :))
            add_command("office", "", (: do_office() :))
            if (!_board) add_command("memo", "", (: do_memo() :))
            if (_retired.index(word) if word in _retired else -1 != -1) return
            add_command("clock", "{in|out}", (: do_clock($4[0]) :))
            add_command("bank", ["", "<number>"], (: do_bank($4) :))
            if (!this_player()->query_property("no score"))
            add_command( "promotion", "{on|off}", (: do_promote($4[0]) :) )
            if (!tp.query_creator() &&  !(_employees[word][EMP_POINTS] & SUPERVISOR))
            return
            add_command("chart", ({CHART_ADDITEM, CHART_REMITEM, CHART_MAXITEM,
            CHART_BUYITEM, CHART_SELLITEM, CHART_ASSIGN_ITEM, CHART_UNASSIGN_ITEM}),
            (: do_chart($4,$5) :))
            add_command("check", "cabinets", (: do_check() :))
            if (!tp.query_creator() && !(_employees[word][EMP_POINTS] & MANAGER))
            add_command( "logs", ({LOG_BLANK, LOG_NUMBER, LOG_CHART}),
            (: do_logs($4,$5) :))
            else
            add_command("logs", ({LOG_BLANK, LOG_NUMBER,
            LOG_MGR}), (: do_logs($4,$5) :))


    def refresh_function(self, employee: Any, flag: int) -> None:
            {
            string emp_name
            switch (flag)
            {
            case PLAYER_DELETED :
            emp_name = employee
            break
            case TOTAL_REFRESH :
            case PARTIAL_REFRESH :
            emp_name = employee.query_name()
            break


    def do_commend(self, emp: str) -> int:
            {
            string commender
            if (!_employees[emp])
            {
            await this_player().send(cap_name(emp)+
            " is not an active employee!\n")
            return 1


    def do_demote(self, emp: str) -> int:
            {
            object tp = this_player()
            emp = lower_case(emp)
            if (!_employees[emp])
            {
            await tp.send(cap_name(emp)+ " is not an active employee!\n")
            return 1


    def do_fire(self, args: Any) -> int:
            {
            args[0] = lower_case(args[0])
            if (!_employees[args[0]])
            {
            await this_player().send(cap_name(args[0])+
            " doesn't work at the shop!\n")
            return 1


    def do_leave(self, args: Any) -> int:
            {
            object tp = this_player()
            args[0] = lower_case(args[0])
            if (!_employees[args[0]])
            {
            await tp.send(cap_name(args[0])+ " is not an employee!\n")
            return 1


    def do_retire(self, ) -> int:
            {
            string manager = this_player()->query_name()
            if (!(_employees[manager][EMP_POINTS] & MANAGER)) return 0
            remove_employee(manager)
            _retired += ({manager})
            shop_log(PERSONNEL, manager, "retired from management", UNPAID)
            employee_log(manager, "Retired from management")
            save_me()
            add_succeeded_mess("$N retire$s.\n")
            return 1


    def do_suspend(self, args: Any) -> int:
            {
            string suspender
            object tp = this_player()
            args[0] = lower_case(args[0])
            if (!_employees[args[0]])
            {
            await tp.send(cap_name(args[0])+ " is not an active employee!\n")
            return 1


    def do_warn(self, args: Any) -> int:
            {
            string warner
            object tp = this_player()
            int points
            args[0] = lower_case(args[0])
            if (!_employees[args[0]])
            {
            await tp.send(cap_name(args[0])+ " is not an active employee!\n")
            return 1


    def view_record(self, person: str, pattern: str) -> None:
            {
            if (pattern == VIEW_EMP)
            {
            string text = sprintf("Employment history of %s:\n\n", cap_name(person))
            load_history()
            if (!sizeof(_history) || !_history[person])
            {
            await this_player().send("There is no history for that person.\n")
            return


    def add_policy_suggest(self, name: str, text: str, mgr: str, type: int) -> None:
            {
            if (previous_object() && previous_object() != find_object(_mgr_office))
            {
            LOG_ERROR("office.c", "add_policy_suggest("+name+","+text+","+mgr+")")
            return


    def get_stock_policy(self, {: Any) -> str:
            private void remove_policy(string policy)
            {
            load_new_policies()
            PLAYER_SHOP->auto_mail(_new_policies[policy][POLICY_MGR],
            "Tarnach Fendertwin", "Policy proposition - "+ policy, "",
            "Your proposition has been rejected by majority vote.\n")
            shop_log(GENERAL, "Shop", "rejected the "+ policy + " policy.\n", UNPAID)
            map_delete(_new_policies, policy)
            save_new_policies()


    def save_register(self, money: Any) -> None:
            {
            _register = money
            save_me()


    def adjust_bought(self, item: str, amt: int) -> None:
            {
            if (previous_object() && previous_object() != find_object(_storeroom))
            {
            LOG_ERROR("office.c", "adjust_bought("+item+","+amt+")")
            return


    def adjust_sold(self, item: str, amt: int) -> None:
            {
            if (previous_object() && previous_object() != find_object(_storeroom))
            {
            LOG_ERROR("office.c", "adjust_sold("+item+","+amt+")")
            return


    def query_ave(self, item: str) -> int:
            {
            return (!_list[item])?0:copy(_list[item][CHART_AVE])


    def query_buy(self, item: str) -> int:
            {
            return (!_list[item])?0:copy(_list[item][CHART_BUY])


    def query_max(self, item: str) -> int:
            {
            return (!_list[item])?0:copy(_list[item][CHART_MAX])


    def query_sell(self, item: str) -> int:
            {
            return (!_list[item])?0:copy(_list[item][CHART_SELL])


    def __init__(self):


    def __init__(self):
            asyncio.create_task(self. "load_file", 1 )
            asyncio.create_task(self. "load_store", 2 )
            asyncio.create_task(self. "lot_check", 5 )


    def init(self, ) -> None:
            this_player()->add_command( "bid", self,
            "<string'amount'> {on|for} <indirect:object:here'case'>",
            (: do_bid( $4[0], $1 ) :) )
            this_player()->add_command( "collect", self,
            ["successful bids", "money", "expired lots",
            "all"],
            (: do_collect( $5 ) :) )
            this_player()->add_command( "deposit", self,
            "<indirect:object:me'items'> for <number> "
            "{minute|hour|day} auction" ,
            (: do_deposit( $1, $4[1], $4[2], "" ) :) )
            this_player()->add_command( "deposit", self,
            "<indirect:object:me'items'> for <number> "
            "{minute|hour|day} "
            "auction with [a] reserve price of <string'amount'>",
            (: do_deposit( $1, $4[1], $4[2], $4[3] ) :) )
            this_player()->add_command( "list", self, "" )
            this_player()->add_command( "browse", self,
            "<string'object'> in <indirect:object'case'>", (: do_browse( $1, $4[0], 0 ) :) )
            this_player()->add_command( "browse", self,
            "<string'object'> <number> in <indirect:object'case'>",
            (: do_browse( $1, $4[0], $4[1] ) :) )
            this_player()->add_command( "withdraw", self,
            "<indirect:object'case'> from auction",
            (: do_withdraw( $1 ) :) )
            this_player()->add_command( "write", self,
            "<string'text'> on <indirect:object'case'>",
            (: do_describe( $1, $4[0] ) :) )
            this_player()->add_command( "exclude", self,
            "<string'name'> from bidding on <indirect:object'case'>",
            (: do_exclude( $1, $4[0] ) :) )
            this_player()->add_command( "exclude", self,
            "list for <indirect:object'case'>",
            (: do_exclude( $1, "list" ) :) )
            this_player()->add_command( "exclude", self,
            "current ignore list from bidding on <indirect:object'case'>",
            (: do_exclude( $1, "ignore list" ) :) )
            this_player()->add_command( "unexclude", self,
            "<string'name'> from bidding on <indirect:object'case'>",
            (: do_unexclude( $1, $4[0] ) :) )


    def generate_auto_load(self, obs: MudObject) -> Any:
            object box = clone_object( "/obj/baggage" )
            string *temp
            box.set_name( "box" )
            box->set_long( "This is a box used in the auction room inheritable. "
            "How did you get hold of one?\n" )
            box.set_weight( 500000 )
            box.set_max_weight( 500000 )
            box.set_volume( 500000 )
            if ( sizeof( filter( obs.move( box ), (: $1 != 0 :) ) ) )
            return ERROBNOMOVE
            temp = create_auto_load( [box], 0 )
            if ( !arrayp( temp ) )
            return ERRGENFAIL
            obs.dest_me()
            obs -= [0]
            if ( sizeof( obs ) ) {
            #ifdef DEBUG
            log_file( "REAS", "%s: WARNUNDEST generated by object %s.\n", ctime( time() ),
            query_multiple_short( map( obs, (: file_name( $1 ) :) ) ) )
            #endif


    def lot_check(self, ) -> None:
            c_lot temp_lot
            c_store current_store
            object new_case
            object *all_new_cases = [})
            object *obs
            object *exp_cases
            int *active_lots
            string name
            int *bids
            cases = filter( cases, (: objectp( $1 ) :) )
            active_lots = map( filter( lots, (: ( (c_lot) $1)->status == OPEN :) ),
            (: ( (c_lot) $1)->case_code :) )
            if ( sizeof( cases ) < sizeof( active_lots ) ) {
            active_lots = active_lots - values( cases )
            foreach( int temp in active_lots ) {
            temp_lot = filter( lots, (: $1->case_code == $(temp) :) )[0]
            current_store = temp_lot->assoc_store
            new_case = clone_object( "/std/object" )
            new_case.set_name( "case" )
            new_case.set_short( current_store->colour + " case" )
            new_case->set_long( "This is a display case used in this auction shop. "
            "It contains " + current_store->inv_string +".\nYou can \"browse\" these"
            " items.\n" )
            new_case.add_adjective( current_store->colour )
            new_case.move( self )
            new_case.reset_get()
            new_case.add_extra_look( self )
            used_colours += [current_store->colour]
            cases += ([ new_case: temp ])
            all_new_cases += [new_case]


    def do_deposit(self, things: MudObject, auction_time: int, time_type: str, res_price: str) -> int:
            mixed *auto_load_string
            c_lot temp
            c_store temp2
            int value
            int finishtime
            if ( auction_time <= 0 || ( time_type == "day" && auction_time > 10 )
            || ( time_type == "minute" && auction_time > 59 ) ||
            ( time_type == "hour" && auction_time > 23 ) ) {
            this_player()->add_failed_mess( self,
            "That's not a valid length.\n" )
            return 0


    def do_list(self, ) -> int:
            c_lot *_lots
            c_lot _lot
            string str
            if ( !sizeof( cases ) ) {
            write( "There is nothing up for auction in this store.\n" )
            return 1


    def remove_lot(self, ob: MudObject) -> None:
            if ( keys( cases .index( ob) if  ob in keys( cases  else -1 ) == -1 )  {
            return


    def do_bid(self, offer: str, boxes: MudObject) -> int:
            c_lot temp
            c_lot *temps
            c_store temp2
            object box
            int value
            if ( sizeof( boxes ) > 1 ) {
            this_player()->add_failed_mess( self,
            "You can only $V on one case at "
            "a time.\n" )
            return 0


    def do_browse(self, boxes: MudObject, target: str, identifier: int) -> int:
            object box
            c_store container
            c_item temp
            mapping contents = ([ ])
            string *names = [})
            mixed *longadj = [})
            string temp2
            mixed *contenders
            string *contender
            string *adjectives
            string name
            string word
            int keep_flag
            if ( sizeof( boxes ) > 1 ) {
            this_player()->add_failed_mess( self,
            "You can only $V one case at a time.\n" )
            return 0


    def adjust_money(self, amount: int, player: MudObject) -> None:
            object money
            if ( amount < 0 ) {
            player.pay_money(MONEY_HAND->create_money_array(-amount, currency ))
            return


    def load_file(self, ) -> None:
            if ( !stringp( location ) ) return
            if ( file_size( location +".o" ) < 0 ) return
            unguarded( (: restore_object, location :) )
            return


    def save_file(self, ) -> None:
            if ( location == "unset" ) return
            unguarded( (: save_object, location :) )
            return


    def dest_me(self, ) -> None:
            save_file()
            if ( sizeof( cases ) ) keys( cases )->dest_me()
            ::dest_me()


    def recover_lot(self, lot_autoload: Any) -> Any:
            object *boxes
            object *stuff
            boxes = load_auto_load_to_array( lot_autoload, this_player() )
            if ( !objectp( boxes[0] ) ) {
            #ifdef DEBUG
            log_file( "REAS", "%s: Could not recover: %O.\n", ctime( time() ),
            lot_autoload )
            #endif
            return ERRNORECV


    def do_withdraw(self, boxes: MudObject) -> int:
            object box
            c_lot *_lots
            object *obs
            if ( sizeof( boxes ) > 1  ) {
            this_player()->add_failed_mess( self,
            "You can only $V on one case at "
            "a time.\n" )
            return 0


    def do_describe(self, boxes: MudObject, int_desc: str) -> int:
            object box
            c_lot *_lots
            c_lot  _lot
            int code
            if ( sizeof( boxes ) > 1 ) {
            this_player()->add_failed_mess( self,
            "You can only $V on one case at "
            "a time.\n" )
            return 0


    def extra_look(self, ob: MudObject) -> str:
            c_lot temp, *temp2
            mixed bid_info
            string ret
            int code
            if ( keys( cases .index( ob) if  ob in keys( cases  else -1 ) == -1 ) return ""
            code = cases[ ob ]
            temp2 = filter( lots, (: $1->case_code == $(code) :) )
            if ( sizeof( temp2 ) != 1 ) return sizeof( temp2 ) +" found in lot array!\n"
            temp = temp2[0]
            bid_info = temp->current_bid
            ret = ""
            if ( !stringp( bid_info[ AUCTION_PLAYER_NAME ] ) ) {
            if ( temp->reserve_price ) {
            ret += "Reserve price is: "
            ret += MONEY_HAND.money_value_string( temp->reserve_price, currency )
            ret += ".\n"


    def do_collect(self, pattern: str) -> int:
            int amount
            c_lot _lot, *_lots = [}), *_exp_lots
            object *items = [})
            _exp_lots = filter( lots, (: ((c_lot)$1)->status != OPEN :) )
            _exp_lots = filter( _exp_lots, (: ((c_lot)$1)->status != CLOSED :) )
            _exp_lots = filter( _exp_lots, (: ((c_lot)$1)->status != WAIT_CRE_INTERVENTION :) )
            if ( pattern == "all" ) {
            do_collect( "money" )
            do_collect( "successful bids" )
            do_collect( "expired lots" )
            return 1


    def do_exclude(self, boxes: MudObject, excluded: str) -> int:
            object box
            c_lot *_lots
            c_lot  _lot
            int code
            string *ignored = this_player()->query_property( "ignoring" )
            if ( sizeof( boxes ) > 1 ) {
            this_player()->add_failed_mess( self,
            "You can only $V people from one case at "
            "a time.\n" )
            return 0


    def do_unexclude(self, boxes: MudObject, excluded: str) -> int:
            object box
            c_lot *_lots
            c_lot  _lot
            int code
            if ( sizeof( boxes ) > 1 ) {
            this_player()->add_failed_mess( self,
            "You can only $V people from one case at "
            "a time.\n" )
            return 0


    def generate_advertising_string(self, lot: Any) -> str:
            string c_string
            if ( intp( lot->current_bid[ 0 ] ) && ( lot->current_bid[ 0 ] ) )
            c_string = MONEY_HAND.money_value_string( lot->current_bid[ 0 ], currency )
            else
            if ( intp( lot->reserve_price ) && lot->reserve_price )
            c_string = MONEY_HAND.money_value_string( lot->reserve_price, currency )
            else
            c_string = "make an offer"
            if ( c_string == "make an offer" )
            return lot->assoc_store->inv_string + ", " + c_string +
            " but hurry, bidding stops at " + amtime( lot->expiration_time )
            return lot->assoc_store->inv_string + ", currently going for " + c_string +
            " but hurry, bidding stops at " + amtime( lot->expiration_time )


    def generate_random_adv_string(self, ) -> str:
            c_lot temp
            if ( sizeof( lots ) ) {
            temp = lots[ random( sizeof( lots ) ) ]
            if ( temp->status != OPEN )
            return WARNNOLOTS
            else return generate_advertising_string( temp )


    def __init__(self):
            self.aliases = []
            self._exits = []
            self.hidden_objects = []
            self._use_internal_objects = []
            self.door_control = ([ ])
            self.dest_other = []


    def __init__(self):
            self.aliases = []
            self._exits = []
            self.hidden_objects = []
            self._use_internal_objects = []
            self.door_control = ([ ])
            self.dest_other = []
            if ( find_object( "/obj/handlers/map" ) ) {
            catch( "/obj/handlers/map"->check_map( file_name( self ) ) )


    def query_is_room(self, ) -> int:
            {
            return 1


    def query_enchant(self, ) -> int:
            int enchant_level =  to_int( floor( 0.5 + dynamic_enchant *
            exp( -0.693 *
            ( time() - enchant_time ) /
            ENCHANT_HALF)) +
            background_enchant )
            if ( enchant_level > 5000 ) {
            return 5000


    def set_enchant(self, number: int) -> int:
            if (number < 0) {
            number = 0


    def add_enchant(self, number: int) -> int:
            dynamic_enchant = dynamic_enchant * exp( -0.693 *
            ( time() - enchant_time ) /
            ENCHANT_HALF ) + number
            enchant_time = time()
            return floor( 0.5 + dynamic_enchant ) + background_enchant


    def set_background_enchant(self, number: int) -> None:
            background_enchant = number


    def set_dynamic_enchant(self, number: Any) -> None:
            dynamic_enchant = number
            enchant_time = time()


    def query_background_enchant(self, ) -> int:
            return background_enchant


    def set_co_ord(self, new_co_ord: int) -> None:
            if ( !pointerp( new_co_ord ) ) {
            write( "Warning: Co-ordinate must be an array.\n" )
            return


    def flush_co_ord(self, ) -> None:
            co_ord = 0
            co_ord_calculated = 0


    def calc_long_exit(self, ) -> None:
            int i, add
            string *words
            mixed tmp
            words = [})
            for ( i = 0; i < sizeof( dest_other ); i += 2 ) {
            tmp = dest_other[ i + 1 ][ ROOM_OBV ]
            if ( !tmp ) {
            continue


    def add_alias(self, names: Any, word: str) -> None:
            string name
            if ( !aliases ) {
            aliases = [})


    def remove_alias(self, names: Any, word: str) -> None:
            int i
            string name
            if ( !aliases ) {
            return


    def add_hidden_object(self, thing: MudObject) -> int:
            if ( !hidden_objects ) {
            hidden_objects = [})


    def remove_hidden_object(self, thing: MudObject) -> int:
            int i
            i = hidden_objects .index( thing) if  thing in hidden_objects  else -1
            if ( i == -1 ) {
            return 0


    def add_use_internal_object(self, thing: MudObject) -> None:
            _use_internal_objects |= [thing]


    def remove_use_internal_object(self, thing: MudObject) -> None:
            _use_internal_objects -= [thing]


    def query_use_internal_objects(self, ) -> List[MudObject]:
            return _use_internal_objects


    def query_destination(self, exit: str) -> str:
            int i
            i = dest_other .index( exit) if  exit in dest_other  else -1
            if ( ( i < 0 ) && objectp( this_player() ) )
            i = member_array( (string)this_player()->reorient_rel( exit ),
            dest_other )
            if ( i < 0 )
            return ROOM_VOID
            return dest_other[ i + 1 ][ ROOM_DEST ]


    def query_dark_mess(self, ) -> str:
            mixed dark_mess
            if ( !stringp( dark_mess = query_property( "dark mess" ) ) ) {
            return "It's dark here, isn't it?"


    def set_dark_mess(self, word: str) -> None:
            add_property( "dark mess", word )


    def query_bright_mess(self, ) -> str:
            mixed bright_mess
            if ( !stringp( bright_mess = query_property( "bright mess" ) ) ) {
            return "It's too bright to see anything!"


    def query_room_size(self, ) -> Any:
            mixed room_size
            room_size = query_property( "room size" )
            if ( !room_size ) {
            return 10


    def set_room_size(self, number: Any) -> None:
            if ( intp( number ) ) {
            add_property( "room size", number )
            return


    def expand_alias(self, word: str) -> str:
            int i
            if ( !aliases || !sizeof( aliases ) ) {
            return word


    def calc_short_exit_string(self, ) -> str:
            int i, add
            string *words
            int pos
            string tmp_dir
            mixed tmp
            words = [})
            for ( i = 0; i < sizeof( dest_other ); i += 2 ) {
            tmp = dest_other[ i + 1 ][ ROOM_OBV ]
            if ( !tmp ) {
            continue


    def query_short_exit_string(self, ) -> str:
            string tmp
            if(short_exit) {
            return this_player()->colour_event("exits", "%^GREEN%^") +
            short_exit + "%^RESET%^"


    def enchant_string(self, ) -> str:
            string words
            words = (string)self.query_property( "octarine_mess" )
            if ( words ) {
            return words +"\n"


    def long(self, word: str, dark: int) -> str:
            string ret
            if ( !long_exit ) {
            calc_long_exit()


    def pretty_short(self, thing: MudObject) -> str:
            int dark
            if ( thing ) {
            dark = (int)thing.check_dark( (int)self.query_light() )


    def query_visibility(self, ) -> int:
            return 100


    def can_use_for_co_ords(self, other: str) -> int:
            return 1


    def calc_co_ord(self, ) -> None:
            int i, j, k, shift, *delta, *other_co_ord
            string other
            mixed* std_orders = STD_ORDERS
            for ( i = sizeof( dest_other ) - 2; ( i > -1 ) && !co_ord; i -= 2 ) {
            other = dest_other[ i + 1 ][ ROOM_DEST ]
            if ( !find_object( other ) ) {
            continue


    def calc_exits(self, ) -> None:
            int i, j
            string exit, word, *tmp_al
            _exits = [})
            for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
            exit = dest_other[ i ]
            if ( _exits .index( exit) if  exit in _exits  else -1 == -1 ) {
            _exits += [exit]
            word = SHORTEN[ exit ]
            if ( stringp( word ) ) {
            _exits += [word]


    def init(self, ) -> None:
            object ob
            int i
            if(this_player() && interactive(this_player())) {
            if(((!last_visited && uptime() > 1800 + random(3600)) ||
            (last_visited && (time() - last_visited > random(900) + 900)))) {
            if(clonep(self))
            this_player()->adjust_xp(random(random(50)), 0)
            else
            this_player()->adjust_xp(random(random(500)), 0)


    def add_zone(self, zone: str) -> None:
            string *zones
            zones = query_property( "room zone" )
            if ( !zones ) {
            zones = [zone]
            } else {
            zones += [zone]


    def remove_zone(self, zone: str) -> None:
            string *zones
            zones = query_property( "room zone" )
            if ( !zones ) {
            return
            } else {
            zones -= [zone]


    def set_zone(self, zone: str) -> None:
            add_zone(zone)


    def query_exit(self, direc: str) -> int:
            return ( dest_other .index( direc) if  direc in dest_other  else -1 != -1 )


    def add_exit(self, direc: str, dest: Any, type: str) -> int:
            mixed *stuff
            if ( !dest_other ) dest_other = [})
            if ( dest_other .index( direc) if  direc in dest_other  else -1 != -1 ) return 0
            if ( objectp( dest ) )
            dest = file_name( dest )
            if ( dest[ 0 .. 0 ] != "/" )
            dest = "/"+ dest
            stuff = [dest] + (mixed *)ROOM_HANDLER.query_exit_type( type, direc )
            dest_other += [direc, stuff]
            stuff = ROOM_HANDLER->query_door_type( type, direc,
            dest )
            if ( stuff ) {
            door_control[ direc ] = clone_object( DOOR_OBJECT )
            door_control[ direc ]->setup_door( direc, self, dest, stuff,
            type)
            hidden_objects += [door_control[ direc ]]
            if (door_control[ direc ]->query_door_name()) {
            door_control[ dest + " " + door_control[ direc ]->query_door_name()] = direc
            } else {
            door_control[ dest ] = direc


    def modify_exit(self, direc: Any, data: Any) -> int:
            int i, j, k
            if(pointerp(direc)) {
            for(k = 0; k < sizeof(direc); k++) {
            modify_exit(direc[k], data)


    def remove_exit(self, direc: str) -> int:
            int i
            if ( !dest_other ) {
            dest_other = [})
            return 0


    def query_door_open(self, direc: str) -> int:
            if ( !objectp( door_control[ direc ] ) ) {
            return -1


    def query_relative(self, direc: str) -> int:
            int i
            i = dest_other .index( direc) if  direc in dest_other  else -1
            if ( i == -1 ) {
            return 0


    def query_look(self, direc: str) -> str:
            int i
            i = dest_other .index( direc) if  direc in dest_other  else -1
            if ( i == -1 )
            return 0
            if ( !dest_other[ i + 1 ] )
            return 0
            return (string)evaluate(dest_other[ i + 1 ][ ROOM_LOOK ])


    def query_size(self, direc: str) -> int:
            int i
            if ( ( i = dest_other .index( direc) if  direc in dest_other  else -1 ) == -1 ) return 0
            if ( stringp( dest_other[ i + 1 ][ ROOM_SIZE ] ) )
            return (int)call_other( self, dest_other[ i + 1 ][ ROOM_SIZE ] )
            if ( pointerp( dest_other[ i + 1 ][ ROOM_SIZE ] ) )
            return (int)call_other( dest_other[ i + 1 ][ ROOM_SIZE ][ 0 ],
            dest_other[ i + 1 ][ ROOM_SIZE ][ 1 ] )
            return dest_other[ i + 1 ][ ROOM_SIZE ]


    def event_magic(self, channel: MudObject, amount: int, caster: MudObject) -> None:
            add_enchant( amount / 5 )


    def query_last_visited(self, ) -> int:
            varargs int add_item( mixed shorts, mixed desc, int no_plural ) {
            if (!desc) {
            printf("Error!  In %O add_item(%O, 0), not added.\n", file_name(),
            shorts)
            return 0


    def remove_item(self, word: str) -> int:
            if ( !item ) {
            return 1


    def modify_item(self, word: str, new_desc: Any) -> int:
            if ( !item ) {
            return 0


    def set_terrain(self, terrain_name: str) -> int:
            if ( terrain ) {
            return 0


    def set_wall(self, args: Any) -> None:
            if ( !wall ) {
            wall = clone_object( WALL_OBJECT )
            wall.setup_shadow( self )


    def set_default_position(self, stuff: Any) -> None:
            add_property(DEFAULT_POSITION_PROPERTY, stuff)


    def query_default_position(self, ) -> Any:
            return query_property(DEFAULT_POSITION_PROPERTY)


    def is_allowed_position(self, poss: str) -> int:
            switch (poss) {
            case SITTING :
            case STANDING :
            case KNEELING :
            case LYING :
            case MEDITATING :
            case CROUCHING :
            return 1
            default :
            return 0


    def dest_me(self, ) -> None:
            object thing
            if ( file_name( self ) != ROOM_VOID ) {
            foreach( thing in all_inventory( self ) ) {
            if ( userp( thing ) ) {
            thing.move_with_look( ROOM_VOID, "$N fall$s into the void." )
            continue


    def set_keep_room_loaded(self, flag: int) -> None:
            add_property(ROOM_KEEP_PROP, flag)


    def query_keep_room_loaded(self, ) -> int:
            return query_property(ROOM_KEEP_PROP)


    def clean_up(self, parent: int) -> int:
            if (parent) {
            return 0


    def real_clean(self, ) -> int:
            object thing
            foreach ( thing in all_inventory( self ) ) {
            if(thing.query_property("transient")) {
            if(thing.query_property("hospital"))
            thing.move(thing->query_property("hospital"), "$N wander$s in.",
            "$N wander$s out.")
            else
            thing.move("/room/rubbish", "$N wander$s in.", "$N wander$s out.")


    def filter_inventory(self, item: MudObject, looker: MudObject) -> int:
            return item && item.short(0) && (!looker || item.query_visible(looker))


    def tell_door(self, direc: str, message: str, thing: MudObject) -> None:
            if ( objectp( door_control[ direc ] ) )
            door_control[ direc ]->tell_door( message, thing )


    def query_door(self, dest: Any, name: str) -> str:
            int i
            string direc
            mixed bing
            if ( objectp( dest ) ) {
            dest = file_name( dest )


    def stop_room_chats(self, ) -> None:
            if ( chatter ) {
            chatter.dest_me()


    def set_chat_min_max(self, min: int, max: int) -> None:
            if (chatter) chatter.set_chat_min_max(min,max)


    def add_room_chats(self, new_chats: str) -> None:
            if (chatter) {
            chatter.add_room_chats( new_chats )


    def remove_room_chats(self, dead_chats: str) -> None:
            if (chatter) {
            chatter.remove_room_chats( dead_chats )


    def add_situation(self, label: Any, situation: Any) -> None:
            if (!sitchanger) {
            sitchanger = clone_object( SITUATION_CHANGER_OBJECT )
            sitchanger.set_room( self )


    def make_situation_seed(self, xval: int, yval: int) -> None:
            if (sitchanger) sitchanger.set_seed(xval,yval)


    def start_situation(self, label: int, do_start_mess: int) -> None:
            if (sitchanger)
            sitchanger.start_situation( label, do_start_mess )


    def end_situation(self, label: Any) -> None:
            if (sitchanger) sitchanger.end_situation( label )


    def shutdown_all_situations(self, ) -> None:
            if (sitchanger) sitchanger.shutdown_all_situations()


    def shutdown_situation(self, call: int, label: Any) -> None:
            if (sitchanger) sitchanger.shutdown_situation(call,label)


    def query_not_replaceable(self, ) -> int:
            return query_property(ROOM_NOT_REPLACE_PROGRAM_PROP)


    def set_not_replaceable(self, replace: int) -> None:
            add_property(ROOM_NOT_REPLACE_PROGRAM_PROP, replace)


    def stats(self, ) -> Any:
            int i
            mixed *stuff
            stuff = [})
            for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 )
            stuff += ({
            [dest_other[ i ], dest_other[ i + 1 ][ ROOM_DEST ]]
            })
            if ( co_ord )
            stuff += ({
            ["co-ord x", co_ord[ 0 ]],
            ["co-ord y", co_ord[ 1 ]],
            ["co-ord z", co_ord[ 2 ]]
            })
            return light::stats() + property::stats() + effects::stats() + stuff + ({
            ["short", short( 0 )],
            ["enchantment", query_enchant()],
            ["background enchantment", background_enchant],
            ["dynamic enchantment", dynamic_enchant],
            ["enchantment time", enchant_time],
            ["theft handler", theft_handler],
            })


    def set_day_long(self, str: str) -> None:
            if(!variablelongs) {
            variablelongs = allocate(2)


    def query_day_long(self, ) -> str:
            if(variablelongs && strlen(variablelongs[ROOM_DAY_INDEX]))
            return variablelongs[ROOM_DAY_INDEX]
            return self.query_long()


    def set_night_long(self, str: str) -> None:
            if(!variablelongs)
            variablelongs = allocate(2)
            variablelongs[ROOM_NIGHT_INDEX] = str
            if(is_day == -1)
            is_day = (WEATHER_HANDLER.query_day() > 0)
            if(is_day == ROOM_NIGHT_INDEX)
            set_long(str)


    def query_night_long(self, ) -> str:
            if(variablelongs && strlen(variablelongs[ROOM_NIGHT_INDEX]))
            return variablelongs[ROOM_NIGHT_INDEX]
            return self.query_long()


    def room_day_chat(self, args: Any) -> None:
            if(!variablechats) {
            variablechats = allocate(3)


    def room_night_chat(self, args: Any) -> None:
            if(!variablechats) {
            variablechats = allocate(3)


    def query_help_file_directory(self, ) -> str:
            return ROOM_HELP_FILE_DIR


    def __init__(self):
            self.aliases = []
            self.exits = []
            self.hidden_objects = []
            self._use_internal_objects = []
            self.door_control = ([ ])
            self.dest_other = []


    def __init__(self):
            self.aliases = []
            self.exits = []
            self.hidden_objects = []
            self._use_internal_objects = []
            self.door_control = ([ ])
            self.dest_other = []
            if ( find_object( "/obj/handlers/map" ) ) {
            catch( "/obj/handlers/map"->check_map( file_name( self ) ) )


    def query_is_room(self, ) -> int:
            {
            return 1


    def query_enchant(self, ) -> int:
            int enchant_level =  to_int( floor( 0.5 + dynamic_enchant *
            exp( -0.693 *
            ( time() - enchant_time ) /
            ENCHANT_HALF)) +
            background_enchant )
            if ( enchant_level > 5000 ) {
            return 5000


    def set_enchant(self, number: int) -> int:
            if (number < 0) {
            number = 0


    def add_enchant(self, number: int) -> int:
            dynamic_enchant = dynamic_enchant * exp( -0.693 *
            ( time() - enchant_time ) /
            ENCHANT_HALF ) + number
            enchant_time = time()
            return floor( 0.5 + dynamic_enchant ) + background_enchant


    def set_background_enchant(self, number: int) -> None:
            background_enchant = number


    def set_dynamic_enchant(self, number: Any) -> None:
            dynamic_enchant = number
            enchant_time = time()


    def query_background_enchant(self, ) -> int:
            return background_enchant


    def set_co_ord(self, new_co_ord: int) -> None:
            if ( !pointerp( new_co_ord ) ) {
            write( "Warning: Co-ordinate must be an array.\n" )
            return


    def calc_long_exit(self, ) -> None:
            int i, add
            string *words
            mixed tmp
            words = [})
            for ( i = 0; i < sizeof( dest_other ); i += 2 ) {
            tmp = dest_other[ i + 1 ][ ROOM_OBV ]
            if ( !tmp ) {
            continue


    def add_alias(self, names: Any, word: str) -> None:
            string name
            if ( !aliases ) {
            aliases = [})


    def remove_alias(self, names: Any, word: str) -> None:
            int i
            string name
            if ( !aliases ) {
            return


    def add_hidden_object(self, thing: MudObject) -> int:
            if ( hidden_objects .index( thing) if  thing in hidden_objects  else -1 != -1 ) {
            return 0


    def remove_hidden_object(self, thing: MudObject) -> int:
            int i
            i = hidden_objects .index( thing) if  thing in hidden_objects  else -1
            if ( i == -1 ) {
            return 0


    def add_use_internal_object(self, thing: MudObject) -> None:
            _use_internal_objects |= [thing]


    def remove_use_internal_object(self, thing: MudObject) -> None:
            _use_internal_objects -= [thing]


    def query_use_internal_objects(self, ) -> List[MudObject]:
            return _use_internal_objects


    def query_destination(self, exit: str) -> str:
            int i
            i = dest_other .index( exit) if  exit in dest_other  else -1
            if ( ( i < 0 ) && objectp( this_player() ) )
            i = member_array( (string)this_player()->reorient_rel( exit ),
            dest_other )
            if ( i < 0 )
            return ROOM_VOID
            return dest_other[ i + 1 ][ ROOM_DEST ]


    def query_dark_mess(self, ) -> str:
            mixed dark_mess
            if ( !stringp( dark_mess = query_property( "dark mess" ) ) ) {
            return "It's dark here, isn't it?"


    def set_dark_mess(self, word: str) -> None:
            add_property( "dark mess", word )


    def query_bright_mess(self, ) -> str:
            mixed bright_mess
            if ( !stringp( bright_mess = query_property( "bright mess" ) ) ) {
            return "It's too bright to see anything!"


    def query_room_size(self, ) -> Any:
            mixed room_size
            room_size = query_property( "room size" )
            if ( !room_size ) {
            return 10


    def set_room_size(self, number: Any) -> None:
            if ( intp( number ) ) {
            add_property( "room size", number )
            return


    def expand_alias(self, word: str) -> str:
            int i
            if ( !aliases || !sizeof( aliases ) ) {
            return word


    def calc_short_exit_string(self, ) -> str:
            int i, add
            string *words
            mixed tmp
            words = [})
            for ( i = 0; i < sizeof( dest_other ); i += 2 ) {
            tmp = dest_other[ i + 1 ][ ROOM_OBV ]
            if ( !tmp ) {
            continue


    def query_short_exit_string(self, ) -> str:
            string tmp
            if(short_exit) {
            return this_player()->colour_event("exits", "%^GREEN%^") +
            short_exit + "%^RESET%^"


    def enchant_string(self, ) -> str:
            string words
            words = (string)self.query_property( "octarine_mess" )
            if ( words ) {
            return words +"\n"


    def long(self, word: str, dark: int) -> str:
            string ret
            if ( !long_exit ) {
            calc_long_exit()


    def pretty_short(self, thing: MudObject) -> str:
            int dark
            if ( thing ) {
            dark = (int)thing.check_dark( (int)self.query_light() )


    def calc_co_ord(self, ) -> None:
            int i, j, k, shift, *delta, *other_co_ord
            string other
            for ( i = sizeof( dest_other ) - 2; ( i > -1 ) && !co_ord; i -= 2 ) {
            other = dest_other[ i + 1 ][ ROOM_DEST ]
            if ( !find_object( other ) ) {
            continue


    def calc_exits(self, ) -> None:
            int i, j
            string exit, word, *tmp_al
            exits = [})
            for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 ) {
            exit = dest_other[ i ]
            if ( exits .index( exit) if  exit in exits  else -1 == -1 ) {
            exits += [exit]
            word = SHORTEN[ exit ]
            if ( stringp( word ) ) {
            exits += [word]


    def init(self, ) -> None:
            object ob
            int i
            if(is_day != -1 && ((WEATHER_HANDLER.query_day() > 0) != is_day)) {
            is_day = (1 - is_day)
            if(variablelongs && strlen(variablelongs[is_day]))
            set_long(variablelongs[is_day])
            if(variableitems) {
            for(i=0; i<sizeof(variableitems[1-is_day]); i += 2)
            remove_item(variableitems[1-is_day][i])
            for(i=0; i<sizeof(variableitems[is_day]); i += 2)
            add_item(variableitems[is_day][i], variableitems[is_day][i+1])


    def add_zone(self, zone: str) -> None:
            string *zones
            zones = query_property( "room zone" )
            if ( !zones ) {
            zones = [zone]
            } else {
            zones += [zone]


    def set_zone(self, zone: str) -> None:
            add_zone(zone)


    def query_exit(self, direc: str) -> int:
            return ( dest_other .index( direc) if  direc in dest_other  else -1 != -1 )


    def add_exit(self, direc: str, dest: Any, type: str) -> int:
            mixed *stuff
            if ( !dest_other ) dest_other = [})
            if ( dest_other .index( direc) if  direc in dest_other  else -1 != -1 ) return 0
            if ( objectp( dest ) )
            dest = file_name( dest )
            if ( dest[ 0 .. 0 ] != "/" )
            dest = "/"+ dest
            stuff = [dest] + (mixed *)ROOM_HANDLER.query_exit_type( type, direc )
            dest_other += [direc, stuff]
            if ( ( stuff = (mixed *)ROOM_HANDLER->query_door_type( type, direc,
            dest ) ) ) {
            door_control[ direc ] = clone_object( DOOR_OBJECT )
            door_control[ direc ]->setup_door( direc, self, dest, stuff,
            type)
            hidden_objects += [door_control[ direc ]]
            door_control[ dest ] = direc


    def modify_exit(self, direc: Any, data: Any) -> int:
            int i, j, k
            if(pointerp(direc)) {
            for(k = 0; k < sizeof(direc); k++) {
            modify_exit(direc[k], data)


    def remove_exit(self, direc: str) -> int:
            int i
            if ( !dest_other ) {
            dest_other = [})
            return 0


    def query_door_open(self, direc: str) -> int:
            if ( !objectp( door_control[ direc ] ) ) {
            return -1


    def query_relative(self, direc: str) -> int:
            int i
            i = dest_other .index( direc) if  direc in dest_other  else -1
            if ( i == -1 ) {
            return 0


    def query_look(self, direc: str) -> str:
            int i
            i = dest_other .index( direc) if  direc in dest_other  else -1
            if ( i == -1 )
            return 0
            if ( !dest_other[ i + 1 ] )
            return 0
            return (string)evaluate(dest_other[ i + 1 ][ ROOM_LOOK ])


    def query_size(self, direc: str) -> int:
            int i
            if ( ( i = dest_other .index( direc) if  direc in dest_other  else -1 ) == -1 ) return 0
            if ( stringp( dest_other[ i + 1 ][ ROOM_SIZE ] ) )
            return (int)call_other( self, dest_other[ i + 1 ][ ROOM_SIZE ] )
            if ( pointerp( dest_other[ i + 1 ][ ROOM_SIZE ] ) )
            return (int)call_other( dest_other[ i + 1 ][ ROOM_SIZE ][ 0 ],
            dest_other[ i + 1 ][ ROOM_SIZE ][ 1 ] )
            return dest_other[ i + 1 ][ ROOM_SIZE ]


    def event_magic(self, channel: MudObject, amount: int, caster: MudObject) -> None:
            add_enchant( amount / 5 )


    def event_exit(self, ob: MudObject, message: str, to: MudObject) -> None:
            if(interactive(ob))
            last_visited = time()


    def query_last_visited(self, ) -> int:
            varargs int add_item( mixed shorts, mixed desc, int no_plural ) {
            if (!desc) {
            printf("Error!  In %O add_item(%O, 0), not added.\n", file_name(),
            shorts)
            return 0


    def remove_item(self, word: str) -> int:
            if ( !item ) {
            return 1


    def modify_item(self, word: str, new_desc: Any) -> int:
            if ( !item ) {
            return 0


    def add_effect(self, eff: str, arg: Any) -> None:
            effects = clone_object( "/std/shadows/misc/effects" )
            effects.setup_shadow( self )
            effects.add_effect( eff, arg )


    def set_terrain(self, terrain_name: str) -> int:
            if ( terrain ) {
            return 0


    def set_wall(self, args: Any) -> None:
            if ( !wall ) {
            wall = clone_object( WALL_OBJECT )
            wall.setup_shadow( self )


    def set_default_position(self, stuff: Any) -> None:
            add_property(DEFAULT_POSITION_PROPERTY, stuff)


    def query_default_position(self, ) -> Any:
            return query_property(DEFAULT_POSITION_PROPERTY)


    def is_allowed_position(self, poss: str) -> int:
            switch (poss) {
            case SITTING :
            case STANDING :
            case KNEELING :
            case LYING :
            case MEDITATING :
            case CROUCHING :
            return 1
            default :
            return 0


    def dest_me(self, ) -> None:
            int in_armoury, in_void
            object thing, *things
            if ( file_name( self ) == ARMOURY )
            in_armoury = 1
            if ( file_name( self ) == ROOM_VOID )
            in_void = 1
            if ( !in_void ) {
            things = all_inventory( self )
            foreach( thing in things ) {
            if ( userp( thing ) ) {
            thing.move_with_look( ROOM_VOID, "$N fall$s into the void." )
            continue


    def set_keep_room_loaded(self, flag: int) -> None:
            add_property(ROOM_KEEP_PROP, flag)


    def query_keep_room_loaded(self, ) -> int:
            return query_property(ROOM_KEEP_PROP)


    def clean_up(self, parent: int) -> int:
            if (parent) {
            return 0


    def real_clean(self, ) -> int:
            object thing
            foreach ( thing in all_inventory( self ) ) {
            if ( thing.query_property( "player" ) ||
            (thing.query_property( "unique" ) &&
            last_visited > time() - 3600) ||
            thing.query_slave() ||
            thing.query_name() == "corpse") {
            return 0


    def tell_door(self, direc: str, message: str, thing: MudObject) -> None:
            if ( objectp( door_control[ direc ] ) )
            door_control[ direc ]->tell_door( message, thing )


    def query_door(self, dest: Any) -> str:
            int i
            string direc
            mixed bing
            if ( objectp( dest ) ) {
            dest = file_name( dest )


    def stop_room_chats(self, ) -> None:
            if ( chatter ) {
            chatter.dest_me()


    def set_chat_min_max(self, min: int, max: int) -> None:
            if (chatter) chatter.set_chat_min_max(min,max)


    def add_room_chats(self, new_chats: str) -> None:
            if (chatter) chatter.add_room_chats( new_chats )


    def remove_room_chats(self, dead_chats: str) -> None:
            if (chatter) chatter.remove_room_chats( dead_chats )


    def add_situation(self, label: Any, situation: Any) -> None:
            if (!sitchanger) {
            sitchanger = clone_object( SITUATION_CHANGER_OBJECT )
            sitchanger.set_room( self )


    def make_situation_seed(self, xval: int, yval: int) -> None:
            if (sitchanger) sitchanger.set_seed(xval,yval)


    def start_situation(self, label: int, do_start_mess: int) -> None:
            if (sitchanger)
            sitchanger.start_situation( label, do_start_mess )


    def end_situation(self, label: Any) -> None:
            if (sitchanger) sitchanger.end_situation( label )


    def shutdown_all_situations(self, ) -> None:
            if (sitchanger) sitchanger.shutdown_all_situations()


    def shutdown_situation(self, call: int, label: Any) -> None:
            if (sitchanger) sitchanger.shutdown_situation(call,label)


    def query_not_replaceable(self, ) -> int:
            return query_property(ROOM_NOT_REPLACE_PROGRAM_PROP)


    def set_not_replaceable(self, replace: int) -> None:
            add_property(ROOM_NOT_REPLACE_PROGRAM_PROP, replace)


    def stats(self, ) -> Any:
            int i
            mixed *stuff
            stuff = [})
            for ( i = sizeof( dest_other ) - 2; i > -1; i -= 2 )
            stuff += ({
            [dest_other[ i ], dest_other[ i + 1 ][ ROOM_DEST ]]
            })
            if ( co_ord )
            stuff += ({
            ["co-ord x", co_ord[ 0 ]],
            ["co-ord y", co_ord[ 1 ]],
            ["co-ord z", co_ord[ 2 ]]
            })
            return light::stats() + property::stats() + stuff + ({
            ["short", short( 0 )],
            ["enchantment", query_enchant()],
            ["background enchantment", background_enchant],
            ["dynamic enchantment", dynamic_enchant],
            ["enchantment time", enchant_time],
            ["theft handler", theft_handler],
            })


    def set_day_long(self, str: str) -> None:
            if(!variablelongs)
            variablelongs = allocate(2)
            variablelongs[DAY] = str
            if(is_day == -1)
            is_day = (WEATHER_HANDLER.query_day() > 0)
            if(is_day == DAY)
            set_long(str)


    def set_night_long(self, str: str) -> None:
            if(!variablelongs)
            variablelongs = allocate(2)
            variablelongs[NIGHT] = str
            if(is_day == -1)
            is_day = (WEATHER_HANDLER.query_day() > 0)
            if(is_day == NIGHT)
            set_long(str)


    def query_night_long(self, ) -> str:
            if(variablelongs && strlen(variablelongs[NIGHT]))
            return variablelongs[NIGHT]
            return self.query_long()


    def room_day_chat(self, args: Any) -> None:
            if(!variablechats)
            variablechats = allocate(2)
            variablechats[DAY] = args
            if(is_day == -1)
            is_day = (WEATHER_HANDLER.query_day() > 0)
            if(is_day == DAY)
            room_chat(args)


    def room_night_chat(self, args: Any) -> None:
            if(!variablechats)
            variablechats = allocate(2)
            variablechats[NIGHT] = args
            if(is_day == -1)
            is_day = (WEATHER_HANDLER.query_day() > 0)
            if(is_day == NIGHT)
            room_chat(args)


    def query_help_file_directory(self, ) -> str:
            return ROOM_HELP_FILE_DIR


    def __init__(self):


    def init(self, ) -> None:
            basic_room::init()
            bath_house::init()


    def __init__(self):


    def init(self, ) -> None:
            outside::init()
            bath_house::init()


    def __init__(self):


    def init(self, ) -> None:
            basic_room::init()
            club_control_room::init()


    def __init__(self):


    def init(self, ) -> None:
            complaints_room::init()
            basic_room::init()


    def __init__(self):


    def query_case_short(self, nomic_case: Any) -> str:
            string ret
            ret = "Case #" + the_case->id + " \"" +
            the_case->short + "\" opened by " + the_case->opener +
            " against " + query_multiple_short(the_case->people) + " at " +
            ctime(the_case->time_opened)
            return ret


    def do_list_all_cases(self, ) -> int:
            int* cases
            string ret
            int id
            cases = NOMIC_HANDLER.query_closed_cases(query_council_area())
            if (!sizeof(cases)) {
            add_failed_mess("There are no open cases.\n")
            return 0


    def do_list_case(self, case_id: int) -> int:
            string ret
            class nomic_case the_case
            class nomic_case_note note
            class nomic_case_event event
            int id
            ret = ""
            the_case = NOMIC_HANDLER.query_closed_case(query_council_area(), case_id)
            if (!the_case) {
            add_failed_mess("Unable to find the case.\n")
            return 0


    def do_list_citizens(self, ) -> int:
            object* cits
            string ret
            string area
            area = self.query_council_area()
            cits = filter( users(), (: NOMIC_HANDLER->is_citizen_of(
            self.query_council_area(), $1.query_name() ) &&
            $1.query_visible( this_player() ) :) )
            cits = sort_array(cits, (: strcmp($1.query_name(), $2.query_name()) :))
            ret = "The online citizens (and magistrates) of " + area + " are:\n\n"
            ret += query_multiple_short(cits)
            write("$P$Citizens Online$P$" + ret)
            return 1


    def init(self, ) -> None:
            add_command("list", "", (: do_list_all_cases() :))
            add_command("list", "[case] <number>", (: do_list_case($4[0]) :))
            add_command("list", "citizens", (: do_list_citizens() :))


    def __init__(self):
            self._types = ([ ])


    def __init__(self):
            self._types = ([ ])
            if (!query_punishment_type("dismissed")) {
            add_punishment_type("dismissed", NOMIC_PUNISHMENT_DIR + "dismissed")


    def add_punishment_type(self, name: str, file: str) -> None:
            _types[name] = file


    def query_punishment_type(self, name: str) -> str:
            return _types[name]


    def start_punishment(self, name: str, nomic_case: Any, finish: Any) -> None:
            string bing
            bing = query_punishment_type(name)
            if (bing) {
            bing.start_punishment(query_council_area(),
            the_case, name, finish)
            } else {
            write("Big hairy error.\n")


    def complete_punishment(self, name: str, nomic_case: Any, data: Any) -> None:
            string bing
            bing = query_punishment_type(name)
            if (bing) {
            bing.complete_punishment(query_council_area(),
            the_case, name, data)
            } else {
            write("Big hairy error.\n")


    def suspend_punishment(self, nomic_case: Any) -> None:
            string bing
            class nomic_case_event event
            string type
            mixed data
            foreach (event in the_case->events) {
            if (event->type == NOMIC_CASE_EVENT_CLOSE) {
            type = event->data[0]
            data = event->data[1]


    def query_extra_player_status(self, player: str) -> str:
            return 0


    def query_last_appealer(self, nomic_case: Any) -> str:
            class nomic_case_event event
            string ret
            ret = 0
            foreach (event in the_case->events) {
            if (event->type == NOMIC_CASE_EVENT_APPEAL) {
            ret = event->person


    def is_last_appealer(self, nomic_case: Any, person: str) -> int:
            return query_last_appealer(the_case) == person


    def query_last_closer(self, nomic_case: Any) -> str:
            class nomic_case_event event
            string ret
            ret = 0
            foreach (event in the_case->events) {
            if (event->type == NOMIC_CASE_EVENT_CLOSE) {
            ret = event->person


    def is_last_closer(self, nomic_case: Any, person: str) -> int:
            return query_last_closer(the_case) == person


    def do_list_punishments(self, ) -> int:
            string punish
            string file
            write("Punishments:\n")
            foreach (punish, file in _types) {
            write("   " + punish + "\n")


    def do_list_punishments_desc(self, type: str) -> int:
            string file
            write("Punishments:\n")
            file = _types[type]
            if (!file) {
            add_failed_mess("No punishment of type " + type + ".\n")
            return 0


    def do_open_case(self, people: str, short: str) -> int:
            string* bits
            string* bad
            string person
            people = replace_string(people, " and ", ",")
            people = replace_string(people, " ", "")
            bits = explode(lower_case(people), ",")
            bad = [})
            foreach (person in bits) {
            if (!PLAYER_HANDLER.test_user(person)) {
            bad += [person]


    def open_case_desc(self, desc: str, extra: Any) -> None:
            string* bits
            string short
            bits = extra[0]
            short = extra[1]
            if (!desc) {
            write("Aborted.\n")
            return


    def query_case_short(self, nomic_case: Any) -> str:
            string ret
            ret = "Case #" + the_case->id + " \"" +
            the_case->short + "\" opened by " + the_case->opener +
            " against " + query_multiple_short(the_case->people) + " at " +
            ctime(the_case->time_opened)
            return ret


    def do_list_open_cases(self, ) -> int:
            int* cases
            string ret
            class nomic_case the_case
            int id
            cases = NOMIC_HANDLER.query_open_cases(query_council_area())
            if (!sizeof(cases)) {
            add_failed_mess("There are no open cases.\n")
            return 0


    def do_list_closed_cases(self, ) -> int:
            int* cases
            string ret
            class nomic_case the_case
            int id
            cases = NOMIC_HANDLER.query_recently_closed_cases(query_council_area())
            if (!sizeof(cases)) {
            add_failed_mess("There are no recently closed cases.\n")
            return 0


    def do_list_case(self, case_id: int) -> int:
            string ret
            class nomic_case the_case
            class nomic_case_note note
            class nomic_case_event event
            int id
            ret = ""
            the_case = NOMIC_HANDLER.query_open_case(query_council_area(), case_id)
            if (!the_case) {
            add_failed_mess("Unable to find the case.\n")
            return 0


    def do_list_closed_case(self, case_id: int) -> int:
            string ret
            class nomic_case the_case
            class nomic_case_note note
            class nomic_case_event event
            int id
            int* cases
            ret = ""
            cases = NOMIC_HANDLER.query_recently_closed_cases(query_council_area())
            if (cases.index(case_id) if case_id in cases else -1 == -1) {
            add_failed_mess("Unable to find the case.\n")
            return 0


    def do_add_person(self, case_id: int, person: str) -> int:
            class nomic_case the_case
            the_case = NOMIC_HANDLER.query_open_case(query_council_area(), case_id)
            if (!the_case) {
            add_failed_mess("Unable to find the id of the case.\n")
            return 0


    def person_desc(self, desc: str, stuff: Any) -> None:
            int case_id
            string person
            string type
            class nomic_case the_case
            case_id = stuff[0]
            person = stuff[1]
            type = stuff[2]
            if (!desc) {
            write("Aborted " + type + "ing " + person + ".\n")
            return


    def do_remove_person(self, case_id: int, person: str) -> int:
            class nomic_case the_case
            the_case = NOMIC_HANDLER.query_open_case(query_council_area(), case_id)
            if (!the_case) {
            add_failed_mess("Unable to find the id of the case.\n")
            return 0


    def do_add_note(self, case_id: int) -> int:
            class nomic_case the_case
            the_case = NOMIC_HANDLER.query_open_case(query_council_area(), case_id)
            if (!the_case) {
            add_failed_mess("Unable to find the id of the case.\n")
            return 0


    def note_case_desc(self, desc: str, nomic_case: Any) -> None:
            if (!desc) {
            write("Aborted.\n")


    def close_case_bit(self, nomic_case: Any, type: str, data: Any) -> None:
            write("Please add in your closing summary.\n")
            this_player()->do_edit("", "close_case_desc", self, 0,
            [the_case, type, data])


    def do_close_case(self, case_id: int, type: str) -> int:
            class nomic_case the_case
            the_case = NOMIC_HANDLER.query_open_case(query_council_area(), case_id)
            if (!the_case) {
            add_failed_mess("Cannot find the case.\n")
            return 0


    def close_case_desc(self, desc: str, extra: Any) -> None:
            class nomic_case the_case
            string type
            mixed data
            if (!desc) {
            write("Aborted.\n")
            return


    def do_appeal_case(self, case_id: int) -> int:
            class nomic_case the_case
            the_case = NOMIC_HANDLER.query_recently_closed_case(query_council_area(),
            case_id)
            if (!the_case) {
            add_failed_mess("Cannot find the case.\n")
            return 0


    def appeal_case_desc(self, desc: str, case_id: int) -> None:
            class nomic_case the_case
            if (!desc) {
            write("Aborted.\n")
            return


    def appeal_case_desc_confirm(self, response: str, case_id: int, desc: str) -> None:
            class nomic_case the_case
            string* people
            response = lower_case(response)
            if (!strlen(response) || response[0] != 'y') {
            write("Aborting the closing of the note.\n")
            return


    def do_player_status(self, person: str) -> int:
            int* cases
            class nomic_case the_case
            int id
            int found
            int *open_defendant
            int *open_opener
            int *open_appealed
            int *closed_defendant
            int *closed_opener
            int *closed_closed
            string ret
            string bing
            person = lower_case(person)
            cases = NOMIC_HANDLER.query_open_cases(query_council_area())
            if (!sizeof(cases)) {
            add_failed_mess("There are no open cases.\n")
            return 0


    def init(self, ) -> None:
            add_command("list", "", (: do_list_open_cases() :))
            add_command("list", "[case] <number>", (: do_list_case($4[0]) :))
            add_command("list", "closed", (: do_list_closed_cases() :))
            add_command("list", "{punishments|results}", (: do_list_punishments :))
            add_command("list", "{punishment|punishments|results} <string'type'>", (: do_list_punishments_desc($4[1]) :))
            add_command("list", "closed [case] <number>", (: do_list_closed_case($4[0]) :))
            add_command("case", "add person <string'person'> to <number'case id'>",
            (: do_add_person($4[1], $4[0]) :))
            add_command("case", "remove person <string'person'> from <number'case id'>",
            (: do_remove_person($4[1], $4[0]) :))
            add_command("case", "[add] note <number'case id'>", (: do_add_note($4[0]) :))
            add_command("case", "open [with] <string'people'> about <string'short descripion'>",
            (: do_open_case($4[0], $4[1]) :))
            add_command("case", "close <number'case id'> result <string'result'>",
            (: do_close_case($4[0], $4[1]) :))
            add_command("case", "appeal <number'case id'>",
            (: do_appeal_case($4[0]) :))
            add_command("status", "[of] <string'player'>",
            (: do_player_status($4[0]) :))


    def __init__(self):


    def do_list_rules(self, ) -> int:
            class nomic_rule* rules
            class nomic_rule rule
            string ret
            int cur_type
            rules = NOMIC_HANDLER.query_all_nomic_rules(query_council_area())
            if (!sizeof(rules)) {
            add_failed_mess("There are no rules, oh no!  Lawlessness!\n")
            return 0


    def do_list_one_rule(self, num: int) -> int:
            class nomic_rule rule
            string ret
            rule = NOMIC_HANDLER.query_nomic_rule(query_council_area(), num)
            if (!rule) {
            add_failed_mess("There is no rule number " + num + ".\n")
            return 0


    def do_list_single_motion(self, num: int) -> int:
            class nomic_motion* rules
            class nomic_motion rule
            int is_mag
            string ret
            rules = NOMIC_HANDLER.query_all_motions(query_council_area())
            is_mag = NOMIC_HANDLER.is_magistrate_of(query_council_area(),
            this_player()->query_name())
            if (!is_mag) {
            rules = filter(rules, (: $1->state == NOMIC_STATE_CITIZEN_VOTE :))


    def do_list_motions(self, brief: int) -> int:
            class nomic_motion* rules
            class nomic_motion rule
            int is_mag
            string ret
            rules = NOMIC_HANDLER.query_all_motions(query_council_area())
            is_mag = NOMIC_HANDLER.is_magistrate_of(query_council_area(),
            this_player()->query_name())
            if (!is_mag) {
            rules = filter(rules, (: $1->state == NOMIC_STATE_CITIZEN_VOTE :))


    def do_comment_on(self, num: int) -> int:
            class nomic_motion rule
            int is_mag
            rule = NOMIC_HANDLER.query_motion(query_council_area(), num)
            is_mag = NOMIC_HANDLER.is_magistrate_of(query_council_area(),
            this_player()->query_name())
            if (!rule || !is_mag && rule->state != NOMIC_STATE_CITIZEN_VOTE) {
            add_failed_mess("Could not find the motion " + num + ".\n")
            return 0


    def finish_comment_on(self, comment: str, nomic_motion: Any) -> None:
            if (!comment) {
            write("Aborting comment.\n")
            return


    def do_amend_motion(self, num: int) -> int:
            class nomic_motion rule
            int is_mag
            is_mag = NOMIC_HANDLER.is_magistrate_of(query_council_area(),
            this_player()->query_name())
            if (!is_mag) {
            add_failed_mess("You cannot amend rules.\n")
            return 0


    def finish_amend_motion(self, amendment: str, nomic_motion: Any) -> None:
            if (!amendment) {
            write("Aborting amendment.\n")
            return


    def do_vote_on(self, num: int, vote: str) -> int:
            class nomic_motion rule
            int is_mag
            int vote_id
            rule = NOMIC_HANDLER.query_motion(query_council_area(), num)
            is_mag = NOMIC_HANDLER.is_magistrate_of(query_council_area(),
            this_player()->query_name())
            if (!rule || (!is_mag && rule->state != NOMIC_STATE_CITIZEN_VOTE)) {
            add_failed_mess("Could not find the motion " + num + ".\n")
            return 0


    def do_amend_current_rule(self, num: int) -> int:
            class nomic_rule rule
            rule = NOMIC_HANDLER.query_nomic_rule(query_council_area(), num)
            if (!rule) {
            add_failed_mess("The rule " + num + " does not exist.\n")
            return 0


    def amend_current_rule(self, str: str, nomic_rule: Any) -> None:
            if (!str) {
            write("Aborting the addition of an amendment.\n")
            return


    def do_remove_current_rule(self, num: int) -> int:
            class nomic_rule rule
            rule = NOMIC_HANDLER.query_nomic_rule(query_council_area(), num)
            if (!rule) {
            add_failed_mess("The rule " + num + " does not exist.\n")
            return 0


    def do_create_motion(self, type: str) -> int:
            int type_no
            type_no = NOMIC_HANDLER.query_type_number(type)
            if (type_no == NOMIC_ERROR ||
            type_no == NOMIC_TYPE_IMMUTABLE) {
            add_failed_mess("The type " + type + " is invalid.\n")
            return 0


    def create_motion(self, str: str, type_no: int) -> None:
            if (!str) {
            write("Aborting the creation of the rule.\n")
            return


    def do_transmogrify_current_rule(self, num: int, new_type: str) -> int:
            class nomic_rule rule
            int new_type_no
            if (!NOMIC_HANDLER.is_magistrate_of(query_council_area(),
            this_player()->query_name())) {
            add_failed_mess("You cannot do this until you are a magistrate.\n")
            return 0


    def init(self, ) -> None:
            ::init()
            add_command("list", "[rules]", (: do_list_rules() :) )
            add_command("list", "rule <number>", (: do_list_one_rule($4[0]) :) )
            add_command("list", "motion <number'motion id'>",
            (: do_list_single_motion($4[0]) :))
            add_command("list", "motions", (: do_list_motions(1) :))
            add_command("list", "motions {verbose|brief}",
            (: do_list_motions($4[0] == "brief") :))
            add_command("comment", "on <number'motion id'>",
            (: do_comment_on($4[0]) :) )
            add_command("amend", "motion <number'motion id'>",
            (: do_amend_motion($4[0]) :) )
            add_command("vote", "{yes|no|abstain} for <number'motion id'>",
            (: do_vote_on($4[1], $4[0]) :))
            add_command("motion", "amend rule <number'rule id'>",
            (: do_amend_current_rule($4[0]) :) )
            add_command("motion", "create new rule <string'type'>",
            (: do_create_motion($4[0]) :) )
            add_command("motion", "remove rule <number'rule id'>",
            (: do_remove_current_rule($4[0]) :) )
            add_command("motion", "move rule <number'rule id'> to <string'type'>",
            (: do_transmogrify_current_rule($4[0], $4[1]) :) )


    def __init__(self):
            self._waiting_approval = ([ ])
            self._blacklist = ([ ])
            self._denied = ([ ])
            self._approved = ([ ])
            self._last_posted = time()


    def init(self, ) -> None:
            add_command("apply", "[for] [citizenship]", (: do_apply() :))
            add_command("sponsor", "<string'person'> for citizenship",
            (: do_sponsor($4[0]) :))
            add_command("deny", "<string'person'> for citizenship because <string'reason'>",
            (: do_deny($4[0], $4[1]) :))
            add_command("list", "", (: do_list() :))
            add_command("expression", "list",
            (: do_list_expression() :))
            if (NOMIC_HANDLER.is_magistrate_of(query_council_area(),
            this_player()->query_name()) ||
            master()->query_lord(this_player()->query_name())) {
            add_command("blacklist", "add <string'person'> for <string'reason'>",
            (: do_add_blacklist($4[0], $4[1]) :))
            add_command("blacklist", "remove <string'person'>",
            (: do_remove_blacklist($4[0]) :))
            add_command("blacklist", "list {verbose|brief}",
            (: do_list_blacklist($4[0] == "verbose") :))
            add_command("expression", "citizen <string'citizenship'>",
            (: do_set_expression($4[0], 0) :))
            add_command("expression", "sponsor <string'citizenship'>",
            (: do_set_expression($4[0], 1) :))
            add_command("list", "denied", (: do_list_denied :))
            add_command("approve", "<string'person'> for citizenship",
            (: do_approve($4[0]) :))


    def set_save_file(self, fname: str) -> None:
            _save_file = fname
            load_me()


    def query_save_file(self, ) -> str:
            return _save_file


    def load_me(self, ) -> None:
            if (!_save_file) {
            return


    def save_me(self, ) -> None:
            if (!_save_file) {
            return


    def post_weekly_results(self, ) -> None:
            string post
            string* cit
            string person
            string denied
            cit = sort_array(keys(_approved), 1)
            if (sizeof(cit) > 0) {
            post = "Here are the weekly citizenship application results:\n\n"
            denied = ""
            foreach (person in cit) {
            if (!_approved[person]->denied) {
            if (sizeof(_approved[person]->info->sponsors)) {
            post += "  " + capitalize(person) + " " +
            ctime(((class approval_list)_approved[person]->info)->time_added)[4..9] +
            " sponsors " +
            query_multiple_short(map(_approved[person]->info->sponsors,
            (: capitalize($1) :)))
            } else {
            post += "  " + person + " no sponsor"


    def do_apply(self, ) -> int:
            class approval_list womble
            string str
            if (NOMIC_HANDLER.is_citizen_of(query_council_area(),
            this_player()->query_name())) {
            add_failed_mess("You are already a citizen.\n")
            return 0


    def do_sponsor(self, person: str) -> int:
            string str
            if (!PLAYER_HANDLER.test_user(person)) {
            add_failed_mess("Sorry, " + person + " is not a player.\n")
            return 0


    def do_approve(self, person: str) -> int:
            person = lower_case( person )
            if (!PLAYER_HANDLER.test_user(person)) {
            add_failed_mess("Sorry, " + person + " is not a player.\n")
            return 0


    def do_deny(self, person: str, reason: str) -> int:
            class denied fluff
            if (!PLAYER_HANDLER.test_user(person)) {
            add_failed_mess("Sorry, " + person + " is not a player.\n")
            return 0


    def do_list(self, ) -> int:
            string ret
            string ret_tmp
            string ret_no_sponsor
            int magistrate
            string* people
            string person
            string denier
            string reason
            int index
            int last
            int no_sponsor
            if (!sizeof(_waiting_approval)) {
            add_failed_mess("No one is waiting for citizenship approval.\n")
            return 0


    def do_list_denied(self, ) -> int:
            string* people
            string person
            string ret
            if (!sizeof(_denied)) {
            add_failed_mess("No one has been denied yet.\n")
            return 0


    def do_list_expression(self, ) -> int:
            string str
            str = query_expression_string(_expression, 0)
            write("The expression to check to make sure someone is allowed to "
            "apply for citizenship is:\n" + str + "\n")
            str = query_expression_string(_sponsor_expression, 0)
            write("The expression to check to make sure someone is allowed to "
            "sponsor an application for citizenship is:\n" + str + "\n")
            return 1


    def do_set_expression(self, expression: str, sponsor_expr: int) -> int:
            class parse_node* expr
            if (!NOMIC_HANDLER.is_magistrate_of(query_council_area(),
            this_player()->query_name())) {
            add_failed_mess("Only magistrates can set an expression string.\n")
            return 0


    def do_add_blacklist(self, person: str, reason: str) -> int:
            class blacklist bing
            if (!NOMIC_HANDLER.is_magistrate_of(query_council_area(),
            this_player()->query_name())) {
            add_failed_mess("Only magistrates can manipulate the blacklist.\n")
            return 0


    def do_remove_blacklist(self, person: str) -> int:
            if (!NOMIC_HANDLER.is_magistrate_of(query_council_area(),
            this_player()->query_name())) {
            add_failed_mess("Only magistrates can manipulate the blacklist.\n")
            return 0


    def do_list_blacklist(self, verbose: int) -> int:
            string ret
            string* people
            string person
            people = keys(_blacklist)
            people = sort_array(people, 1)
            if (!sizeof(people)) {
            add_failed_mess("There is no one in the blacklist currently.\n")
            return 0


    def variable_age_in_days(self, player: MudObject) -> int:
            int bing
            bing = -player.query_time_on()
            return bing / (60 * 60 * 24)


    def variable_age_in_hours(self, player: MudObject) -> int:
            int bing
            bing = -player.query_time_on()
            return bing / (60 * 60)


    def variable_level(self, player: MudObject) -> int:
            return player.query_level()


    def variable_denied_in_days(self, player: MudObject) -> int:
            if (_denied[player.query_name()]) {
            return (time() - _denied[player.query_name()]->time_denied) / (60 * 60 * 24)


    def function_citizen_of(self, area: str, player: MudObject) -> int:
            return NOMIC_HANDLER.is_citizen_of(area, player->query_name())


    def function_magistrate_of(self, area: str, player: MudObject) -> int:
            return NOMIC_HANDLER.is_magistrate_of(area, player->query_name())


    def is_allowed_to_change(self, person: str) -> int:
            return NOMIC_HANDLER.is_magistrate_of(query_council_area(), person)


    def is_open_for(self, type: str, name: str) -> int:
            switch (type) {
            case "document_add" :
            case "document_delete" :
            return NOMIC_HANDLER.is_magistrate_of(query_council_area(), name)
            default :
            return 1


    def __init__(self):


    def set_fine_handler(self, fine: str) -> None:
            _fine_handler = fine


    def query_fine_handler(self, ) -> str:
            return _fine_handler


    def do_pay(self, ) -> int:
            string place
            mixed* m_array
            int fine
            int value
            fine = _fine_handler.query_current_fine(this_player()->query_name())
            if (!fine) {
            add_failed_mess("You do not have any fines due here.\n")
            return 0


    def query_fine_information(self, person: str) -> str:
            string ret
            int fine
            string place
            place = query_property("place")
            ret = ""
            fine = _fine_handler.query_current_fine(person)
            if (!fine) {
            ret += "No current fine.\n"
            } else {
            ret += "Current fine of " +
            MONEY_HAND.money_value_string(fine, place) + ".\n"


    def do_fine(self, ) -> int:
            write(query_fine_information(this_player()->query_name()))
            add_succeeded_mess(["", "$N look$s up a fine.\n"])
            return 1


    def do_show_fine(self, person: str) -> int:
            if (!PLAYER_HANDLER.test_user(person)) {
            add_failed_mess("You must find a fine for an existing person.\n")
            return 0


    def do_show_all_fines(self, ) -> int:
            string ret
            int fine
            ret = ""
            foreach (string person in _fine_handler.query_people_with_fines()) {
            fine = _fine_handler.query_current_fine(person)
            if (fine) {
            ret += person + " " + query_fine_information(person) + "\n"


    def init(self, ) -> None:
            add_command("pay", "fine", (: do_pay() :))
            add_command("fine", "", (: do_fine() :))
            if (NOMIC_HANDLER.is_magistrate_of(query_council_area(),
            this_player()->query_name())) {
            add_command("fine", "<string'player'>", (: do_show_fine($4[0]) :))
            add_command("fine", "all", (: do_show_all_fines :))
            add_command("list", "fines", (: do_show_all_fines :))


    def do_check(self, ) -> int:
            class transaction {
            string person
            int amount
            string reason
            int date
            string action


    def save_me(self, ) -> None:
            {
            if (!_save_file) {
            debug_printf("Error: No save file set.\n")
            return


    def load_me(self, ) -> None:
            {
            if (!_save_file)
            return
            if (file_size(_save_file + ".o") > 0) {
            unguarded((: restore_object, _save_file :))
            return


    def check_time(self, ) -> None:
            {
            string str
            while (transactions[0]->date + TWO_WEEKS < time()) {
            str =
            capitalize(transactions[0]->person) + " " + transactions[0]->action +
            " " + MONEY_HAND.money_value_string(transactions[0]->amount, query_property("place"))
            str +=
            (transactions[0]->action ==
            "withdrew" ? " for " + transactions[0]->reason : "")
            str += " on " + amtime(transactions[0]->date) + ".\n"
            log_file(_archive, str, 0)
            transactions = transactions[1..]


    def __init__(self):


    def init(self, ) -> None:
            {
            ::init()
            this_player()->add_command("withdraw", self, "<number'amount'> "
            "<string'type'> for <string'reason'>",
            (: do_withdraw($4[0], $4[1], $4[2]) :))
            this_player()->add_command("deposit", self, "<string>",
            (: do_deposit($4[0]) :))
            this_player()->add_command("check", self, "balance")
            this_player()->add_command("view", self,
            "transactions",
            (: view_transactions() :))
            this_player()->add_command("view", self,
            "transactions [by] <word'player'>",
            (: view_transactions($4[0]) :))


    def set_save_file(self, file: str) -> None:
            {
            _save_file = file


    def set_place(self, word: str) -> None:
            {
            add_property("place", word)


    def do_check(self, ) -> int:
            {
            write("The treasury contains " + MONEY_HAND->money_value_string(_balance,
            query_property("place")) +
            ".\n")
            return 1


    def do_deposit(self, words: str) -> int:
            {
            int amount
            mixed money
            object *tender
            object legal
            object illegal
            string howmuch
            if (!security_check(this_player(), DEPOSIT)) {
            return add_failed_mess("You are not allowed to deposit.\n")


    def set_archive(self, word: str) -> None:
            {
            _archive = word


    def __init__(self):


    def do_status(self, ) -> int:
            string person
            string* nominated
            string* magistrates
            string ret
            if (!NOMIC_HANDLER.is_citizen_of(query_council_area(),
            this_player()->query_name())) {
            add_failed_mess("You must be a citizen to see this information.\n")
            return 0


    def do_vote(self, person: str, force: int) -> int:
            string* bits
            if (!NOMIC_HANDLER.is_citizen_of(query_council_area(),
            this_player()->query_name())) {
            add_failed_mess("You must be a citizen to vote.\n")
            return 0


    def do_nominate(self, person: str) -> int:
            person = lower_case(person)
            if (!NOMIC_HANDLER.is_citizen_of(query_council_area(),
            this_player()->query_name())) {
            add_failed_mess("You must be a citizen to nominate someonej.\n")
            return 0


    def do_list_motions(self, ) -> int:
            class nomic_motion* rules
            class nomic_motion rule
            int is_mag
            string ret
            rules = NOMIC_HANDLER.query_all_motions(query_council_area())
            is_mag = NOMIC_HANDLER.is_magistrate_of(query_council_area(),
            this_player()->query_name())
            if (!is_mag) {
            rules = filter(rules, (: $1->state == NOMIC_STATE_CITIZEN_VOTE :))


    def do_vote_on(self, num: int, vote: str) -> int:
            class nomic_motion rule
            int is_mag
            int vote_id
            rule = NOMIC_HANDLER.query_motion(query_council_area(), num)
            is_mag = NOMIC_HANDLER.is_magistrate_of(query_council_area(),
            this_player()->query_name())
            if (!rule || (!is_mag && rule->state != NOMIC_STATE_CITIZEN_VOTE)) {
            add_failed_mess("Could not find the motion " + num + ".\n")
            return 0


    def add_vote(self, type: str, description: str, choices: str, ending: int) -> None:
            string mess
            ::add_vote(type, description, choices, ending)
            mess = "New vote on:\n" + description + "\nWith choices of " +
            query_multiple_short(choices) + ".\n",
            NOMIC_HANDLER.post_citizen_message(query_council_area(), "New vote by " +
            this_player()->query_cap_name(),
            mess)


    def init(self, ) -> None:
            basic_room::init()
            voting_room::init()
            add_command("list", "elections", (: do_status() :))
            add_command("list", "motions", (: do_list_motions() :))
            add_command("information", "", (: do_status() :))
            add_command("status", "", (: do_status() :))
            add_command("vote", "{yes|no|abstain} in [motion] <number'id'>",
            (: do_vote_on($4[1], $4[0]) :))
            add_command("vote", "for <string'people'>", (: do_vote($4[0], 0) :))
            add_command("vote", "force for <string'people'>", (: do_vote($4[0], 1) :))
            add_command("nominate", "<string'person'>", (: do_nominate($4[0]) :))
            if (NOMIC_HANDLER.is_magistrate_of(query_council_area(),
            this_player()->query_name())) {
            init_add_vote()


    def __init__(self):


    def dest_me(self, ) -> None:
            delivery::dest_me()
            basic_room::dest_me()


    def query_delivery_room(self, ) -> int:
            return 1


    def init(self, ) -> None:
            this_player()->add_command( "scrawl", self, "with charcoal on wall")
            this_player()->add_command( "scrawl", self, "on wall with charcoal")


    def do_scrawl(self, things: MudObject) -> int:
            string language
            if ( !ETP.query_property( GRAFFITI) ) {
            this_player()->add_failed_mess( self, "You can't scrawl on "+
            "this wall.\n")
            return 0


    def begin_writing(self, writer: MudObject) -> None:
            if ( !writer ) {
            writing_on = 0
            return


    def end_writing(self, words: str) -> None:
            string language
            string extra
            if ( !words || ( words == "" ) ) {
            write( "You don't scrawl anything on "+
            "the wall.\n")
            say( (string)this_player()->the_short() +" doesn't "+
            "scrawl anything after all.\n" )
            writing_on = 0
            return


    def __init__(self):


    def init(self, ) -> None:
            outside::init()
            class::init()


    def __init__(self):


    def init(self, ) -> None:
            basic_room::init()
            class::init()


    def __init__(self):


    def init(self, ) -> None:
            basic_room::init()
            meeting::init()


    def __init__(self):


    def init(self, ) -> None:
            basic_room::init()
            newspaper_office::init()


    def __init__(self):
            self._subscribers = ([ ])


    def query_price_per_issue_subscriber(self, ) -> int:
            int deposit_cost = 400
            return deposit_cost + ( NEWSPAPER_HANDLER.query_paper_cost( _paper ) * 2 )


    def query_price_per_issue_box(self, ) -> int:
            return NEWSPAPER_HANDLER.query_paper_cost( _paper )


    def query_price_newspaper_box(self, ) -> int:
            return load_object( NEWSPAPER_SUBSCRIPTION_OB )->query_value() +
            ISSUES_PER_BOX * NEWSPAPER_HANDLER.query_paper_cost( _paper )


    def query_price_international_newspaper_box(self, ) -> int:
            return (load_object( NEWSPAPER_SUBSCRIPTION_OB )->query_value() +
            ISSUES_PER_BOX * NEWSPAPER_HANDLER.query_paper_cost( _paper )) * 2


    def dest_me(self, ) -> None:
            save_me()
            ::dest_me()


    def event_publish_paper(self, paper: str) -> None:
            string name
            int issues
            int price
            int last_issue = NEWSPAPER_HANDLER.query_last_edition_num( _paper )
            if (paper != _paper) {
            return


    def set_money_place(self, new_region: str) -> None:
            _region = new_region


    def query_money_place(self, ) -> str:
            return _region


    def do_subscribe(self, numbers: int) -> int:
            string name
            int price
            string mess
            if( !numbers || !this_player() || numbers < -1 ) {
            return 0


    def do_unsubscribe(self, ) -> int:
            if( undefinedp( _subscribers[ this_player()->query_name() ] ) ) {
            add_failed_mess( "You don't have a subscription for " + _paper +
            ", so you cannot unsubscribe.\n" )
            return 0


    def do_buy(self, international: int) -> int:
            object box
            int price
            if( international == 1 ) {
            price = query_price_international_newspaper_box()
            } else {
            price = query_price_newspaper_box()


    def do_check(self, ) -> int:
            int i
            if( !this_player() ) {
            return 0


    def do_list(self, subscription_type: str) -> int:
            string* subscriber_list
            string name
            subscriber_list = [})
            if( !this_player() || !subscription_type ) {
            return 0


    def init(self, ) -> None:
            string _office
            object office = 0
            add_command( "subscribe",
            "[to] <number> [issue|issues] of " + _paper,
            (: do_subscribe( $4[0] ) :) )
            add_command( "subscribe",
            "[to] " + _paper,
            (: do_subscribe( -1 ) :) )
            add_command( "unsubscribe",
            "[from] " + _paper,
            (: do_unsubscribe() :) )
            add_command( "buy",
            "[a] newspaper box",
            (: do_buy( 0 ) :) )
            add_command( "buy",
            "[an] international newspaper box",
            (: do_buy( 1 ) :) )
            add_command( "check",
            "subscription",
            (: do_check() :) )
            if( _office = NEWSPAPER_HANDLER.query_paper_office( _paper ) ) {
            office = load_object( _office )


    def reset(self, ) -> None:
            int i
            if ( !sizeof( reset_definitions ) )
            return
            if ( !sizeof( reset_objects ) )
            reset_objects = allocate( sizeof( reset_definitions ) )
            for ( i = sizeof( reset_definitions ); i--; ) {
            switch ( reset_definitions[ i ][ FLAG ] ) {
            case REMOVABLE:
            if ( !reset_objects[ i ] ||
            ( environment( reset_objects[ i ] ) != self ) ) {
            if ( reset_definitions[ i ][ DELAY ] >= 0 )
            asyncio.create_task(self. "make_object", reset_definitions[ i ][ DELAY ], i )
            else
            make_object( i )


    def set_weather_handler(self, handler: str) -> None:
            _weather_handler = handler


    def query_weather_handler(self, ) -> str:
            return _weather_handler


    def set_climate(self, climate: str) -> int:
            if(CLIMATES.index(climate) if climate in CLIMATES else -1 == -1)
            return 0
            _climate = climate
            return 1


    def query_climate(self, ) -> str:
            if(!_climate)
            return DEFAULT_CLIMATE
            return _climate


    def set_light_change(self, s: str) -> None:
            add_property("light change", s)


    def query_light_change(self, ) -> str:
            return query_property("light change")


    def snow_look(self, ) -> str:
            return _weather_handler.snow_string(self) + "."


    def rain_look(self, ) -> str:
            return _weather_handler.rain_string(self) + "."


    def sleet_look(self, ) -> str:
            return _weather_handler.sleet_string(self) + "."


    def cloud_look(self, ) -> str:
            return _weather_handler.cloud_string(self) + "."


    def __init__(self):
            self._weather_handler = WEATHER 


    def query_light(self, ) -> int:
            int new_light
            new_light = ( day_light * (int)_weather_handler->query_darkness
            ( self ) ) / 100
            if ( new_light != query_my_light() ) {
            ::set_light(new_light)


    def query_visibility(self, ) -> int:
            return _weather_handler.query_visibility(self)


    def set_light(self, number: int) -> int:
            ::set_light(number)
            day_light = number


    def long(self, word: str, dark: int) -> str:
            int day_time
            string ret
            string obscure
            mixed bit
            ret = ::long( word, dark )
            day_time = (int)_weather_handler.query_day( self )
            if ( day_time != current_day ) {
            if ( query_light_change() ) {
            call_other( self, query_light_change(), current_day )


    def dest_me(self, ) -> None:
            if(sunlight) {
            sunlight.dest_me()


    def event_exit(self, ob: MudObject, message: str, to: MudObject) -> None:
            if(!room_stabilize) {
            remove_asyncio.create_task(self.callout_handle)
            callout_handle = asyncio.create_task(self."clean_up_room", FAST_CLEAN_UP, 0)


    def clean_up_room(self, flag: int) -> int:
            object *obs, ob
            int elapsed_time = time() - room_create_time
            if(room_stabilize || !query_fast_clean_up() ||
            self.query_keep_room_loaded())
            return 0
            callout_handle = 0
            obs = filter(all_inventory(self),
            (: !living($1) || (userp($1)) ||
            !$1.query_property("transient") ||
            sizeof($1.query_attacker_list()) ||
            $1.cannot_walk() :))
            if(sizeof(all_inventory(self)) ||
            elapsed_time > (FAST_CLEAN_UP * 3)) {
            room_stabilize = 1
            return 1


    def set_fast_clean_up(self, number: int) -> None:
            _fast_clean_up = number


    def query_fast_clean_up(self, ) -> int:
            return _fast_clean_up


    def make_shelf(self, short: str, long: str) -> None:
            shelf = clone_object( "/std/surface" )
            shelf.set_name( short )
            shelf.set_long( long )
            shelf.set_max_weight( 10000 )
            shelf.move( self )
            shelf.add_property( "there", "fixed to one wall" )
            shelf.reset_get()


    def init(self, ) -> None:
            ::init()
            this_player()->add_command( "deposit", self,
            "<indirect:object> for <string>",
            (: do_deposit( $1, $4[1] ) :) )
            this_player()->add_command( "collect", self, "",
            (: do_collect() :) )


    def deposit_parcel(self, obs: MudObject, name: str, show_sender: int) -> int:
            if ( obs == 0 || name == 0 ) {
            return 0


    def do_collect(self, ) -> int:
            string this_player_name
            this_player_name = lower_case(this_player()->query_name())
            if( PLAYER_MULTIPLAYER_HANDLER.member_denied_parcel(this_player_name) ) {
            add_failed_mess("You are not allowed to collect things.\n")
            return 0


    def set_shelf(self, ob: MudObject) -> None:
            shelf = ob


    def query_shelf(self, ) -> MudObject:
            return shelf


    def __init__(self):


    def query_long(self, ) -> str:
            return player_housing::query_long()


    def add_exit(self, direc: str, dest: Any, type: str) -> int:
            int tmp
            tmp = ::add_exit(direc, dest, type)
            setup_exit(direc, 1)
            return tmp


    def query_address(self, ) -> str:
            return HOUSING.query_address(file_name(self))


    def process_non_living(self, int_non_livings: MudObject, start: int) -> str:
            object *not_positioned
            not_positioned = player_housing::my_process_non_living(int_non_livings)
            return ::process_non_living(not_positioned, start)


    def init(self, ) -> None:
            player_housing::init()
            basic_room::init()


    def event_exit(self, ob: MudObject, message: str, to: MudObject) -> None:
            player_housing::event_exit(ob, message, to)


    def query_keep_room_loaded(self, ) -> int:
            player_housing::query_keep_room_loaded()


    def dest_me(self, ) -> None:
            player_housing::dest_me()
            basic_room::dest_me()


    def test_remove(self, thing: MudObject, flag: int, dest: Any) -> int:
            object thief
            mixed *stuff
            if(!basic_room::test_remove(thing, flag, dest))
            return 0
            thief = this_player()
            if(!thief)
            return player_housing::test_remove(thing, flag, dest)
            if(thief.query_caster())
            thief = find_player(thief.query_caster())
            else if(thief.query_owner())
            thief = thief.query_owner()
            stuff = thing.query_property("dropped")
            if(thief &&
            test_save(thing) && PLAYER_HANDLER.test_user(query_owner()) &&
            !self.test_occupier(thief->query_name()) &&
            (!stuff || stuff[0] != thief.query_name())) {
            log_file("HOUSING_THEFT", "%s: %s stole %s from %s in %s\n",
            ctime( time() )[4..18], (string)thief.query_short(),
            thing.query_short(),
            (string)query_owner(), file_name())
            event(self, "theft", thief, self, [thing])


    def test_add(self, ob: MudObject, flag: int) -> int:
            int retval
            retval = basic_room::test_add(ob, flag)
            if(retval)
            retval = player_housing::test_add(ob, flag)
            return retval


    def __init__(self):


    def query_long(self, ) -> str:
            return player_housing::query_long()


    def query_owner(self, ) -> str:
            return HOUSING.query_owner(base_name(self))


    def add_exit(self, direc: str, dest: Any, type: str) -> int:
            int tmp
            tmp = ::add_exit(direc, dest, type)
            setup_exit(direc, 0)
            return tmp


    def process_non_living(self, int_non_livings: MudObject, start: int) -> str:
            object *not_positioned
            not_positioned = player_housing::my_process_non_living(int_non_livings)
            return ::process_non_living(not_positioned, start)


    def init(self, ) -> None:
            player_housing::init()
            outside::init()


    def event_exit(self, ob: MudObject, message: str, to: MudObject) -> None:
            outside::event_exit(ob, message, to)
            player_housing::event_exit(ob, message, to)


    def dest_me(self, ) -> None:
            player_housing::dest_me()
            outside::dest_me()


    def test_remove(self, thing: MudObject, flag: int, dest: Any) -> int:
            object thief
            mixed *stuff
            if(!outside::test_remove(thing, flag, dest))
            return 0
            thief = this_player()
            if(!thief)
            return player_housing::test_remove(thing, flag, dest)
            if(thief.query_caster())
            thief = find_player(thief.query_caster())
            else if(thief.query_owner())
            thief = thief.query_owner()
            stuff = thing.query_property("dropped")
            if(thief &&
            test_save(thing) &&
            !test_occupier(thief.query_name()) &&
            (!stuff || stuff[0] != thief.query_name())) {
            log_file("HOUSING_THEFT", "%s: %s stole %s from %s in %s\n",
            ctime( time() )[4..18], (string)thief.query_short(),
            thing.query_short(),
            (string)query_owner(), file_name())
            event(self, "theft", thief, self, [thing])


    def test_add(self, ob: MudObject, flag: int) -> int:
            int retval
            retval = outside::test_add(ob, flag)
            if(retval)
            retval = player_housing::test_add(ob, flag)
            return retval


    def init(self, ) -> None:
            ::init()
            add_command( "jump", "<word'direction'>",
            (: self.do_roofjump( $4[0] ) :) )


    def __init__(self):
            self.weak_messages = []
            self.slope_messages = []
            self.step_messages = []
            self.jump_tm_messages = []
            self.jump_success_messages = []
            self.jump_failure_messages = []
            self.ghost_fall_messages = []
            self.item_slope_messages = []
            self.corpse_slope_messages = []
            self.damages = ([ ])
            self.damage_types = ['weak', 'slope', 'step', 'jump']
            self.translations = ([ ])
            self.jump_info = ([ ])


    def set_weak_messages(self, player: str, from: str, to: str, warn: str) -> None:
            weak_messages = [player, from, to, warn]


    def set_slope_messages(self, player: str, from: str, to: str) -> None:
            slope_messages = [player, from, to]


    def set_step_messages(self, player: str, from: str, to: str) -> None:
            step_messages = [player, from, to]


    def set_jump_tm_messages(self, : str) -> None:
            jump_success_messages = messages


    def set_jump_success_messages(self, player: str, from: str, to: str) -> None:
            jump_success_messages = [player, from, to]


    def set_jump_failure_messages(self, player: str, from: str, to: str) -> None:
            jump_failure_messages = [player, from, to]


    def set_ghost_fall_messages(self, player: str, from: str, to: str) -> None:
            ghost_fall_messages = [player, from, to]


    def set_corpse_slope_messages(self, from: str, to: str) -> None:
            corpse_slope_messages = [from, to]


    def set_item_slope_messages(self, from: str, to: str) -> None:
            item_slope_messages = [from, to]


    def set_fall_damage(self, type: str, damage: int) -> None:
            if( damage < 0 )
            damage = -damage
            if( type == "all" ) {
            foreach( type in damage_types )
            damages[type] = damage
            } else if( damage_types .index( type) if  type in damage_types  else -1 >= 0 ) {
            damages[type] = damage
            } else
            return


    def query_fall_damage(self, type: str) -> Any:
            if( type == "all" )
            return damages
            else
            return damages[type]


    def calc_fall_damage(self, type: str) -> int:
            if( type == "all" )
            return 0
            return query_fall_damage( type ) + random( query_fall_damage( type ) )


    def set_weak_roof(self, maxweight: int, dest: str) -> None:
            roof_max_weight = maxweight
            weak_roof_dest = dest


    def set_slope(self, angle: int, loc: str, dest: str) -> None:
            gradient = ( angle * 100 ) / 90
            place = loc
            slope_dest = dest


    def set_jump(self, dir: Any, dest: str, fall_dest: str, distance: int) -> int:
            string * dirs
            mixed foo
            string bar
            if( stringp( dir ) ) {
            dirs = [dir]
            } else if( arrayp(dir) ) {
            foreach( foo in dir )
            if( !stringp( foo ) )
            return 0
            dirs = sort_array( dir, 1 )


    def event_enter(self, obj: MudObject, from: MudObject) -> None:
            int totalweight, objectweight, i
            float encum, diff
            int fall
            object * contents
            object destination
            if( !obj ) return
            if( obj.query_property( "demon" )
            || obj.query_property( "floating" ) ) {
            return


    def gradient_check(self, obj: MudObject, destination: str, diff: int) -> None:
            object destob
            #ifdef DEBUG
            debug_printf( "gradient_check( %s, \"%s\", %d )",
            obj.query_name(), destination, diff )
            #endif
            obj.remove_property( TOO_SOON )
            switch( TASKER.perform_task( obj, ROCK, diff + 1, TM_FIXED ) ) {
            case AWARD:
            tell_object( obj, "%^YELLOW%^" + ({
            "You balance more confidently on the " + place + ".",
            "Climbing becomes easier."
            })[ random(2) ] + "%^RESET%^\n" )
            case SUCCEED:
            tell_object( obj, "The " + place + " is steep, but you manage "
            "not to fall.\n" )
            break
            case FAIL:
            if( !( destob = load_object( destination ) ) ) {
            tell_object( obj, "Error loading room " + destination +
            ", moving you to the void.\nPlease contact a creator.\n" )
            obj.move_with_look( "/room/void" )
            } else
            do_fall( obj, destob, "slope", slope_messages, 0 )
            break
            default:
            write( "Gnaaaaaaaaaaaah! You should not be getting this message.  "
            "Please contact a creator.\n" )
            break


    def do_roofjump(self, dir: str) -> int:
            mixed * info
            int distance
            float weight, max_weight
            object destination, fall_destination
            string key
            if( !( key = translations[dir] ) || !( info = jump_info[key] ) ) {
            add_failed_mess( "You can't jump there!\n" )
            return 0


    def query_death_reason(self, ) -> str:
            asyncio.create_task(self. (: death_reason = 0 :), 2 )
            if( death_reason )
            return "/global/player"->convert_message( death_reason )
            return "a rooftop (" + file_name( self )
            + ") with an incorrectly set death message"


    def set_death_reason(self, str: str) -> None:
            death_reason = str


    def process_string(self, str: str, transforms: Any) -> str:
            string foo, bar
            foreach( foo, bar in transforms )
            if( bar ) str = replace_string( str, foo, bar )
            return "/global/player"->convert_message( str )


    def process_mess(self, str: str, ob: MudObject, direction: str) -> str:
            string opp_dir
            string * directions = ["north", "northeast", "east", "southeast",
            "south", "southwest", "west", "northwest"]
            if( !str || ( str == "" ) )
            return ""
            if( stringp( direction ) ) {
            if( directions .index( direction) if  direction in directions  else -1 < 0 ) {
            opp_dir = 0
            } else {
            opp_dir =
            directions[ ( directions .index( direction) if  direction in directions  else -1 + 4 ) % 8 ]


    def test_remove(self, ob: MudObject, flag: int, dest: Any) -> int:
            if( !living(ob) ) {
            return ::test_remove( ob, flag, dest )


    def __init__(self):


    def init(self, ) -> None:
            basic_room::init()


    def __init__(self):


    def init(self, ) -> None:
            basic_room::init()
            room_rental_office::init()


    def __init__(self):


    def test_remove(self, thing: MudObject, flag: int, dest: Any) -> int:
            int result
            result = basic_room::test_remove(thing, flag, dest)
            if(result) {
            room_save::test_remove(thing, flag, dest)


    def test_add(self, ob: MudObject, flag: int) -> int:
            room_save::test_add(ob, flag)
            return basic_room::test_add(ob, flag)


    def dest_me(self, ) -> None:
            room_save::dest_me()
            basic_room::dest_me()


    def __init__(self):


    def trap_action(self, str: str) -> int:
            string st1
            if( sscanf( str,"%s %s",str,st1 ) )
            switch(str) {
            case "ambush":
            case "attack":
            case "backstab":
            case "behead":
            case "bury":
            case "cast":
            case "circle":
            case "conflagrate":
            case "crush":
            case "decompose":
            case "drag":
            case "eat":
            case "ensumpf":
            case "fade":
            case "filch":
            case "fire":
            case "fuel":
            case "guard":
            case "hedgehog":
            case "hide":
            case "hurl":
            case "iai":
            case "inhume":
            case "inpale":
            case "invoke":
            case "kill":
            case "mock":
            case "order":
            case "tempt":
            case "palm":
            case "perform":
            case "plant":
            case "pyroscipate":
            case "scathe":
            case "scribe":
            case "scry":
            case "shroud":
            case "slip":
            case "snatch":
            case "sneak":
            case "steal":
            case "recharge":
            case "rifle":
            case "throw":
            case "twist":
            case "use":
            case "ventisepelate":
            case "zap":
            case "skick":
            case "sburn":
            case "slap":
            case "spunch":
            case "berserk":
            await  this_player().send("You feel too peaceful to do that.\n")
            return 1
            default:
            return 0


    def init(self, ) -> None:
            this_player()->remove_hide_invis( "hiding" )
            clone_object( SHAD )->setup_shadow(TP)
            this_player()->command_override( (: trap_action :) )
            this_player()->add_command( "dream", self, "" )
            this_player()->add_command( "rest", self, "" )
            ::init()


    def event_exit(self, ob: MudObject, message: str, to: MudObject) -> None:
            ob.dest_shadow()


    def event_enter(self, ob: MudObject, stringy: str, stringy2: str) -> None:
            object thing
            if ( base_name( ob ) == "/d/classs/priests/summoned/dust_devil" ) {
            ob.do_leave()


    def do_rest(self, str: str) -> int:
            this_player()->adjust_hp( 4 )
            this_player()->adjust_gp( -( 2 + random( 4 ) ) )
            this_player()->adjust_social_points( -( 2 + random(8)))
            tell_object( this_player() ,
            "You rest on one of the pillows, and feel much "
            "better for it.\n")
            return 1


    def do_dream(self, str: str) -> int:
            this_player()->adjust_hp( 4 )
            this_player()->adjust_gp( -( 2 + random( 4 ) ) )
            this_player()->adjust_social_points( -( 2 + random(8)))
            tell_object( this_player(), ({
            "You dream of a world where cabbages roam free.\n",
            "You have a vision of penguin waiters serving giraffes in white leisure "
            "suits.\n",
            "You dream of imp-powered sheep leaping over fences.\n",
            "You dream uneasily of creators with cuddly teddy-bears.\n",
            "Visions of sugar-plums dance through your head.\n",
            "You count lemons as you try to get to sleep.\n"] [ random(4) ] )
            return 1


    def event_fight_in_progress(self, ob1: MudObject, ob2: MudObject) -> None:
            if ( keeper ) { tell_room ( self,
            keeper.the_short() + " hums a peaceful tune softly and calm fils the "
            "room." ); }
            ob2.stop_all_fight()
            ob1.stop_all_fight()


    def make_calm(self, blue: MudObject) -> None:
            int *enums
            int wibble
            enums = blue.effects_matching("fighting.combat")
            if ( sizeof( enums ) ) {
            foreach( wibble in enums ) { blue.delete_effect( wibble ); }
            keeper.do_command("smile "+ blue->query_name() )
            await  blue.send("You feel a lot calmer.\n")


    def stop_sneaking(self, sneaker: MudObject) -> None:
            int *enums
            int wibble
            enums = sneaker.effects_matching( "covert.sneaking" )
            if ( sizeof( enums ) ) {
            foreach( wibble in enums ) { sneaker.delete_effect( wibble ); }
            keeper.do_command("hug "+ sneaker->query_name() )
            await  sneaker.send("You feel less sneaky.\n")


    def load_me(self, ) -> None:
            class stable {
            int date_in
            int last_paid
            string name
            mixed* save_info


    def __init__(self):
            self._start_cost = 400
            self._cost_per_week = 400
            self._stable_cache = ([ ])
            self._accounts = ([ ])
            self._stable_types = []


    def init(self, ) -> None:
            add_command( "list", "", (: do_list() :) )
            add_command( "stable", "<indirect:object:here>", (: do_stable($1) :) )
            add_command( "deposit", "<string'money'>", (: do_deposit($4[0]) :) )
            add_command( "return", "<string'horse num'>", (: do_return($4[0]) :) )


    def set_save_directory(self, directory: str) -> None:
            if ( directory[<1] != '/' )
            directory += "/"
            _directory = directory
            load_me()


    def query_save_directory(self, ) -> str:
            return _directory


    def set_start_cost(self, start_cost: int) -> None:
            _start_cost = start_cost


    def query_start_cost(self, ) -> int:
            return _start_cost


    def set_cost_per_week(self, cost_per_week: int) -> None:
            _cost_per_week = cost_per_week


    def query_cost_per_week(self, ) -> int:
            return _cost_per_week


    def save_me(self, ) -> None:
            unguarded( (: save_object(_directory + "main_account") :) )


    def load_me(self, ) -> None:
            unguarded( (: restore_object(_directory + "main_account", 1) :) )


    def query_balance(self, name: str) -> int:
            return _accounts[name]


    def set_balance(self, name: str, amt: int) -> None:
            _accounts[name] = amt
            save_me()


    def adjust_balance(self, name: str, amt: int) -> None:
            _accounts[name] += amt
            save_me()


    def query_player_money(self, player: MudObject, place: str) -> int:
            return player.query_value_in( place ) +
            query_balance( player.query_name() )


    def remove_player_money(self, player: MudObject, amt: int, place: str) -> None:
            int balance
            balance  = query_balance( player.query_name() )
            if ( balance < 0 ) {
            amt += -balance
            balance = 0
            } else {
            if ( amt <= balance ) {
            balance -= amt
            amt = 0
            } else {
            amt -= balance
            balance = 0


    def add_stable_type(self, type: str) -> None:
            if ( _stable_types .index( type) if  type in _stable_types  else -1 == -1) {
            _stable_types += [type]


    def can_stable_type(self, type: str) -> int:
            if ( _stable_types .index( type) if  type in _stable_types  else -1 != -1 ) {
            return 1


    def query_stabling_cost(self, name: str, pos: int) -> int:
            class stable* bing
            bing = query_stable( name )
            if ( pos < 0 || pos >= sizeof( bing ) ) {
            return 0


    def add_to_stable(self, name: str, horses: Any) -> int:
            class stable* bing
            class stable womble
            object horse
            bing = query_stable( name )
            if ( !bing ) {
            bing = [})


    def print_ok_message(self, me: MudObject, horses: Any) -> None:
            write( "You stable " + query_multiple_short( horses ) + " into " +
            the_short() + ".\n" )
            say( this_player()->the_short() + " stables " +
            query_multiple_short( horses ) + " into " + the_short() + ".\n" )


    def do_stable(self, obs: MudObject) -> int:
            class stable* bing
            int cost
            object horse
            object *ok
            string place
            place = query_property( "place" )
            if ( !place )
            place = "default"
            bing = query_stable( this_player()->query_name() )
            ok = [})
            foreach ( horse in obs ) {
            if ( !can_stable_type( horse.query_transport_type() ) ) {
            add_failed_mess( "$I is not able to be stabled here.\n", [horse] )
            } else if ( horse.query_owner() != this_player()->query_name() ) {
            add_failed_mess( "You do not own $I and therefore cannot stable them.\n",
            [horse] )
            } else {
            ok += [horse]
            cost += _start_cost


    def do_list(self, ) -> int:
            class stable* bing
            int i
            int cost
            int balance
            string debt
            string place
            place = query_property( "place" )
            if ( !place )
            place = "default"
            bing = query_stable( this_player()->query_name() )
            balance = query_balance( this_player()->query_name() )
            if ( !bing || !sizeof( bing ) ) {
            if( !balance ) {
            add_failed_mess( "You do not have any horses stabled here.\n" )
            return 0


    def do_return(self, num: str) -> int:
            class stable* bing
            int pos
            int cost
            object* horses
            string place
            place = query_property( "place" )
            if ( !place )
            place = "default"
            bing = query_stable( this_player()->query_name() )
            if ( !sizeof( bing ) ) {
            add_failed_mess( "You do not have any horses stabled here.\n" )
            return 0


    def do_deposit(self, mon: str) -> int:
            string place
            mixed money
            int amt
            place = query_property( "place" )
            if ( !place )
            place = "default"
            if ( undefinedp( query_balance( this_player()->query_name() ) ) ) {
            add_failed_mess( "You do not currently have a balance here.\n" )
            return 0


    def __init__(self):


    def init(self, ) -> None:
            basic_room::init()
            voting_room::init()


    def init(self, ) -> None:
            water::init()
            basic_room::init()


    def is_allowed_position(self, poss: str) -> int:
            return water::is_allowed_position(poss)


    def add_exit(self, direc: str, dest: Any, type: str) -> int:
            int retval = basic_room::add_exit(direc, dest, type)
            water::add_exit(direc, dest, type)
            return retval


    def query_light(self, ) -> int:
            update_water_light()
            if (query_surface()) {
            return ::query_light()


    def set_water_light(self, number: int) -> int:
            _setting_water_light = 1
            set_light(number)
            _setting_water_light = 0


    def adjust_light(self, number: int) -> int:
            if (!_setting_water_light) {
            set_use_surface_light(0)


    def query_property(self, tag: str) -> Any:
            if ("location" == tag && !query_surface()) {
            return "underwater"


    def init(self, ) -> None:
            water::init()
            outside::init()


    def is_allowed_position(self, poss: str) -> int:
            return water::is_allowed_position(poss)


    def add_exit(self, direc: str, dest: Any, type: str) -> int:
            int retval = outside::add_exit(direc, dest, type)
            water::add_exit(direc, dest, type)
            return retval


    def query_light(self, ) -> int:
            update_water_light()
            if (query_surface()) {
            return ::query_light()


    def set_water_light(self, number: int) -> int:
            _setting_water_light = 1
            set_light(number)
            _setting_water_light = 0


    def adjust_light(self, number: int) -> int:
            if (!_setting_water_light) {
            set_use_surface_light(0)


    def query_property(self, tag: str) -> Any:
            if ("location" == tag && !query_surface()) {
            return "underwater"


    def set_chat_min_max(self, min: int, max: int) -> None:
            if (_chats) {
            _chats[0]=min
            _chats[1]=max


    def setup_chatter(self, my_room: MudObject, chat_args: Any) -> None:
            _off = 1
            _room = my_room
            if( !arrayp( chat_args ) ) {
            chat_args = [chat_args]


    def dest_me(self, ) -> None:
            destruct( self )


    def make_chat(self, ) -> None:
            int saying
            mixed stuff
            if(!_room) {
            dest_me()
            return


    def check_chat(self, ) -> None:
            if ( !_off || !pointerp( _chats ) ) {
            return


    def add_room_chats(self, new_chats: str) -> None:
            if (sizeof(new_chats)) {
            if (sizeof(_chats[2])) {
            _chats[2] = _chats[2] + new_chats
            } else {
            _chats[2]= new_chats


    def remove_room_chats(self, dead_chats: str) -> None:
            if (sizeof(_chats[2])) {
            _chats[2] = _chats[2] - dead_chats


    def clean_up(self, parent: int) -> int:
            if (parent)
            return 0
            if (!_room || _room.query_chatter() != self)
            dest_me()


    def __init__(self):
            self.name = ['door']
            self.lng = "It's just a door.\n"
            self.shrt = "door"
            self.adjs = []
            self.plu = []


    def query_how_many(self, ) -> int:
            return how_many


    def set_how_many(self, number: int) -> None:
            if(number)
            add_property("party object", 1)
            else
            remove_property("party object")
            how_many = number


    def query_one_way(self, ) -> int:
            return one_way


    def set_one_way(self, number: int) -> None:
            one_way = number


    def query_short(self, ) -> str:
            return shrt


    def set_short(self, words: str) -> None:
            string *bits
            shrt = words
            bits = explode( words, " " )
            bits += implode( map( bits, (: explode( $1, "-" ) :) ), (: $1 + $2 :) )
            bits = uniq_array( bits )
            name += [bits[ sizeof( bits ) - 1 ]]
            adjs += bits[ 0 .. sizeof( bits ) - 2 ]
            plu += [pluralize( bits[ sizeof( bits ) - 1 ] )]


    def query_door_name(self, ) -> str:
            return _door_name


    def set_door_name(self, word: str) -> None:
            _door_name = word


    def set_lock_owner(self, owner: str) -> None:
            _lock_owner = owner


    def query_lock_owner(self, ) -> Any:
            return _lock_owner


    def init(self, ) -> None:
            add_command( "knock", "on <direct:object>" )
            close_lock::init()


    def long(self, ) -> str:
            return lng + ( ( this_player()->query_see_octarine() ) ? enchant_string() :
            "" ) + long_status()


    def get(self, ) -> int:
            void setup_door( string word, object mine, string his, mixed *args,
            string type) {
            string *bits
            my_id = word
            my_room = mine
            dest = his
            switch(type) {
            case "window":
            if(word != "window")
            shrt = word + " window"
            else
            shrt = word
            lng = "It's just the " + shrt + ".\n"
            name = [shrt, "window"]
            plu = ["windows"]
            break
            default:
            if ( word[ 0 .. 5 ] == "enter " ) {
            if(SHORTEN[word[6..100]])
            name += [SHORTEN[word[6..100]]]
            shrt = word[ 6 .. 100 ] +" door"
            lng = "It's just the " + shrt + ".\n"
            name += [shrt]
            if(!args[D_SECRET ])
            plu = ["doors"]
            } else {
            if(SHORTEN[word])
            name += [SHORTEN[word]]
            shrt = word +" door"
            lng = "It's just the " + shrt + ".\n"
            name += [shrt]
            if(!args[D_SECRET ])
            plu = ["doors"]


    def add_alias(self, word: str) -> None:
            string *bits
            bits = explode( word, " " )
            name += [bits[ sizeof( bits ) - 1 ]]
            adjs +=  bits[ 0 .. sizeof( bits ) - 2 ]
            plu += [pluralize( bits[ sizeof( bits ) - 1 ] )]


    def force_other(self, ) -> int:
            string door_name, direc
            if(!find_object(dest)) {
            if(!load_object(dest))
            return 0
            dest.query_door( my_room, _door_name )


    def do_open(self, ) -> int:
            if(!::do_open())
            return 0
            if(!force_other() && !one_way) {
            set_closed()
            return 0


    def do_close(self, ) -> int:
            if(!::do_close())
            return 0
            if(!force_other() && !one_way) {
            set_open()
            return 0


    def do_lock(self, obs: MudObject) -> int:
            if(!::do_lock(obs))
            return 0
            if(!force_other() && !one_way) {
            set_unlocked()
            return 0


    def do_unlock(self, obs: MudObject) -> int:
            if(!::do_unlock(obs))
            return 0
            if(!force_other() && !one_way) {
            set_locked()
            return 0


    def do_knock(self, ) -> int:
            if(this_player()->query_property("dead"))
            return 0
            if ( !other_id && !one_way ) {
            ROOM_HANDLER.check_door( [my_room, my_id] )
            if ( !other_id )
            return 0


    def pick_unlock(self, thing: MudObject) -> int:
            if (stringp(_lock_owner)) {
            if (pk_check(_lock_owner, thing, 1)) {
            return 0


    def pick_lock(self, thing: MudObject) -> int:
            if (stringp(_lock_owner)) {
            if (pk_check(_lock_owner, thing, 1)) {
            return 0


    def query_parse_id(self, arr: Any) -> MudObject:
            if (arr[P_THING] == 0) {
            return self


    def dest_me(self, ) -> None:
            destruct( self )


    def moving_open(self, thing: MudObject) -> int:
            if(!::do_open())
            return 0
            if(!force_other() && !one_way) {
            set_closed()
            return 0


    def moving_close(self, thing: MudObject) -> int:
            if(!::do_close())
            return 0
            if(!force_other() && !one_way) {
            set_open()
            return 0


    def moving_unlock(self, thing: MudObject) -> int:
            if(!::do_unlock(all_inventory(thing)))
            return 0
            if(!one_way && find_object(dest))
            dest.modify_exit(other_id, ["locked", 0])
            await thing.send("You unlock the "+ shrt +".\n")
            if (thing.short())
            tell_room( my_room, capitalize( (string)thing.the_short() ) +
            " unlocks the "+ shrt +".\n", thing )
            return 1


    def moving_lock(self, thing: MudObject) -> int:
            if(!::do_lock(all_inventory(thing)))
            return 0
            if(!one_way && find_object(dest))
            dest.modify_exit(other_id, ["locked", 1])
            tell_object( thing, "You lock the "+
            (string)dest.call_door( other_id, "query_short" ) +".\n" )
            if (thing.short())
            dest.tell_door( other_id, capitalize( (string)thing.the_short() ) +
            " locks the $D.\n", thing )
            return 1


    def tell_door(self, words: str, thing: MudObject) -> None:
            tell_room(my_room, replace( words, ({
            "$D", shrt, "$p", PRONOUN[how_many], "$s", ["s", ""][how_many]]),
            [thing])


    def long_status(self, ) -> str:
            string str
            if (!query_stuck()) {
            if(query_how_many() > 0)
            {
            str = "They are"


    def init(self, ) -> None:
            this_player()->add_command( "scrawl", self, "with charcoal on wall")
            this_player()->add_command( "scrawl", self, "on wall with charcoal")


    def do_scrawl(self, things: MudObject) -> int:
            string language
            if ( !ETP.query_property( GRAFFITI) ) {
            this_player()->add_failed_mess( self, "You can't scrawl on "+
            "this wall.\n")
            return 0


    def begin_writing(self, writer: MudObject) -> None:
            if ( !writer ) {
            writing_on = 0
            return


    def end_writing(self, words: str) -> None:
            string language
            string extra
            if ( !words || ( words == "" ) ) {
            write( "You don't scrawl anything on "+
            "the wall.\n")
            say( (string)this_player()->the_short() +" doesn't "+
            "scrawl anything after all.\n" )
            writing_on = 0
            return


    def init(self, ) -> None:
            string name
            mixed rest
            foreach (name, rest in _other_things) {
            this_player()->add_command(name, self, _pattern[name])


    def print_stuff(self, ) -> None:
            printf("lng = %O\nshrt = %O\nadjs = %O\nplu = %O\nname = %O\n" +
            "verb = %O\nplural = %O\nother_things = %O\npattern = %O\n" +
            "cur_desc = %O\ngather = %O\n", _lng, _shrt, _adjs, _plu, _name, _verb,
            _plural, _other_things, _pattern, _cur_desc, _gather)


    def __init__(self):
            self._creator_room = file_name(previous_object())
            self._adjs = []
            self._lng = ['']
            self._shrt = ['']
            self._gather = ([ ])
            self._plu = []
            self._name = []
            self._verb = ([ ])
            self._plural = ([ ])
            self._pattern = ([ ])
            self._cur_desc = []
            self._count = ([ ])
            self._other_things = ([ "smell" : 0, "taste" : 0, "read" : 0 ])


    def hide_invis_string(self, ) -> str:
            string *query_short_array() {
            string *ret
            int i
            ret = [})
            foreach (i in _cur_desc) {
            ret += [_shrt[i]]


    def short(self, ) -> str:
            return query_multiple_short(query_short_array())


    def pretty_short(self, ) -> str:
            string *ret
            ret = query_short_array()
            if (sizeof(ret)) {
            return query_multiple_short(ret)
            } else {
            return "something"


    def a_short(self, ) -> str:
            return implode(map(query_short_array(),
            (: "$mirror_short:" + add_a( $1 ) + "$" :)), "")


    def the_short(self, ) -> str:
            return implode(map(query_short_array(),
            (: "$mirror_short:the " +  $1 + "$" :)), "")


    def one_short(self, ) -> str:
            return implode(map(query_short_array(),
            (: "$mirror_short:the " + $1 + "$" :)), "")


    def poss_short(self, ) -> str:
            return implode(map(query_short_array(),
            (: "$mirror_short:the " + $1 + "$" :)), "")


    def query_read_short(self, ) -> str:
            return "$name$"


    def query_plural(self, ) -> str:
            string *ret
            int i
            ret = [})
            foreach (i in _cur_desc) {
            ret += [pluralize(_shrt[i])]


    def pretty_plural(self, ) -> str:
            int i
            foreach (i in _cur_desc) {
            return pluralize(_shrt[i])


    def long(self, name: str, dark: int) -> str:
            int i
            string *ret
            ret = [})
            foreach (i in _cur_desc) {
            if ( !_lng[ i ] ) {
            continue


    def query_item(self, str: str) -> int:
            private void setup_bits_for_item(int index, mixed bits) {
            int i
            string str
            mixed pat
            if (!pointerp(bits)) {
            _lng[index] = bits
            return


    def setup_item(self, nam: Any, long: Any, no_plural: int) -> int:
            int index
            string str
            index = sizeof(_lng)
            if (pointerp(nam)) {
            if (sizeof(nam) > 0) {
            _shrt += [nam[0]]
            if (no_plural) {
            _plu += ["no plural"]
            } else {
            _plu += [pluralize(nam[0])]


    def modify_item_by_index(self, index: int, long: Any) -> int:
            if (index >= sizeof(_lng)) {
            return 0


    def modify_item_by_name(self, str: str, long: Any) -> int:
            int index
            index = _shrt.index(str) if str in _shrt else -1
            if (index == -1) {
            return 0


    def modify_item(self, str: Any, long: Any) -> int:
            if (stringp(str)) {
            return modify_item_by_name(str, long)


    def remove_item_by_index(self, index: int) -> int:
            if (index >= sizeof(_lng)) {
            return 0


    def remove_item_by_name(self, str: str) -> int:
            int index
            index = _shrt.index(str) if str in _shrt else -1
            if (index == -1) {
            return 0


    def remove_item(self, str: Any) -> int:
            if (stringp(str)) {
            return remove_item_by_name(str)


    def query_parse_id(self, arr: Any) -> MudObject:
            {
            string *bits
            mixed stuff
            int i, j, match, all_match
            bits = explode(arr[P_STR], " ")
            bits -= ["a", "an", "the"]
            if (arr[P_THING] == 0)
            {
            stuff = _plural[bits[<1]]
            if (!stuff) {
            stuff = _verb[bits[<1]]
            if (!stuff) {
            return 0


    def dest_me(self, ) -> None:
            destruct(self)
            return


    def dwep(self, ) -> None:
            destruct(self)
            return


    def move(self, ) -> int:
            int command_control(string command, object *indir, string id_arg,
            string ii_arg, string *args, string pattern) {
            int desc, size, num
            mixed temp
            if (!_other_things[command]) {
            return 0


    def query_position_string(self, pos: str) -> str:
            int i
            if (!_position_stuff) {
            return 0


    def query_position_multiple(self, pos: str) -> int:
            int i
            if (!_position_stuff) {
            return 0


    def query_count(self, ) -> int:
            int i
            int ret = 0
            foreach (i in _cur_desc)  {
            ret += evaluate(_count[i])


    def destruct_shadow(self, thing: MudObject) -> None:
            if(thing == self) {
            destruct(self)
            } else {
            thing.destruct_shadow(thing)


    def query_dynamic_preposition(self, ) -> str:
            return d_prep


    def query_static_preposition(self, ) -> str:
            return s_prep


    def query_room_name(self, ) -> str:
            return r_name


    def area_name(self, ) -> str:
            string *bits
            if(r_name) {
            return r_name


    def compose_start(self, ) -> str:
            if(s_prep == "") {
            return capitalize((string)room.the_short())


    def event_exit(self, person: MudObject, message: str, to: MudObject) -> None:
            int ad_flag, rm_flag, i
            string arrive, direc, *exits, link_mess, *link_array
            room.event_exit(person, message, to)
            if(!message) {
            return


    def event_enter(self, person: MudObject, message: str, from: MudObject) -> None:
            int ad_flag, rm_flag, i
            string direc, *exits, link_mess, *link_array
            room.event_enter(person, message, from)
            if(!message || !from) {
            return


    def set_chat_min_max(self, min: int, max: int) -> None:
            if (chats) {
            chats[0]=min
            chats[1]=max


    def setup_chatter(self, my_room: MudObject, chat_args: Any) -> None:
            off = 1
            room = my_room
            if (sizeof(chats)) chats += chat_args + ({0,0})
            else chats = chat_args + ({0,0})


    def dest_me(self, ) -> None:
            destruct( self )


    def make_chat(self, ) -> None:
            int saying
            string stuff
            int set,nextt,t
            if (!sizeof( filter_array( all_inventory( room ), "check_interactive",
            self ) ) ) {
            off = 1
            return


    def check_chat(self, ) -> None:
            int set,t,nextt
            if ( !off || !pointerp( chats ) )
            return
            off = 0
            t=time()
            nextt=2147483647
            for (set=0; set<sizeof(chats); set+=5) {
            if (t>=chats[set+4]+chats[set]) chats[set+4]=t+random(chats[set+1])
            if (chats[set+4]<nextt) nextt=chats[set+4]


    def add_room_chats(self, new_chats: str) -> None:
            if (sizeof(new_chats)) {
            if (sizeof(chats[2])) chats[2] = chats[2] + new_chats
            else chats[2]= new_chats


    def remove_room_chats(self, dead_chats: str) -> None:
            int set
            mixed *new_chats
            new_chats=[})
            for (set=0;set<sizeof(chats);set+=5) {
            if (sizeof(chats[set+2])) chats[set+2] = chats[set+2] - dead_chats
            if (set==0 || sizeof(chats[set+2]))
            new_chats=new_chats+chats[(set)..(set+4)]


    def clean_up(self, parent: int) -> int:
            if (parent) {
            return 0


    def query_status(self, ) -> int:
            int *query_current_situations(object room)
            {
            if (!roominfo[file_name(room)]) return 0
            return (roominfo[file_name(room)])[0]


    def dest_me(self, ) -> None:
            destruct(self)


    def start_situation(self, num: int, do_start_mess: int, room: MudObject) -> None:
            mixed *sdata
            string *chats
            mixed item,*items
            int *currentsits
            string *els
            object chatter
            if (!(sdata=sitdata[num]) || !room) return
            if (!roominfo[file_name(room)]) roominfo[file_name(room)]=
            [0,0,0,0,60,120,1]
            currentsits=(roominfo[file_name(room)])[0]
            els=(roominfo[file_name(room)])[1]
            if (!currentsits) currentsits=[num]
            else currentsits=currentsits+[num]
            if (sizeof(sdata[2])) {
            if (els && sizeof(els)) els+=[sdata[2]]
            else {
            els=[sdata[2]]
            room.add_extra_look(self)


    def end_situation(self, num: int, room: MudObject) -> None:
            mixed *sdata
            string *chats
            mixed item,*items
            int *currentsits
            string *els
            object chatter
            if (!(sdata=sitdata[num]) || !room) return
            if (!roominfo[file_name(room)]) return
            currentsits=(roominfo[file_name(room)])[0]
            els=(roominfo[file_name(room)])[1]
            if (currentsits) currentsits=currentsits-[num]
            if (els && sizeof(sdata[2])) {
            els-=[sdata[2]]
            if (!sizeof(els)) room.remove_extra_look(self)


    def manage_situations(self, room: MudObject) -> None:
            mixed *sit
            int num,t,it,cnt,possible
            int *currentsits,*newsits,*changes
            int ttmp,tstep,offset,awake
            mixed data
            if (!room || !(data=roominfo[file_name(room)])) return
            if (!sizeof(filter_array( all_inventory( room ),(: interactive($1) :)))) {
            (roominfo[file_name(room)])[6]=0
            return


    def manage_rooms_situations(self, ) -> None:
            object room,*current_rooms
            current_rooms = rooms[ 0 ]
            rooms[ 0 .. <2 ] = rooms[ 1 .. <1 ]
            rooms[ <1 ] = 0
            asyncio.create_task(self."manage_rooms_situations",SECTOCHECK)
            if ( !pointerp( current_rooms ) ) return
            foreach ( room in current_rooms ) manage_situations(room)


    def check_situations(self, room: MudObject) -> None:
            if (room && roominfo[file_name(room)]
            && !((roominfo[file_name(room)])[6])
            && interactive(this_player())) manage_situations(room)


    def shutdown_situations(self, room: MudObject) -> None:
            int num, *currentsits
            currentsits=(roominfo[file_name(room)])[0]
            if (currentsits && sizeof(currentsits)) {
            foreach(num in currentsits) end_situation(num, room)


    def extra_look(self, room: MudObject) -> str:
            string *els
            if (!roominfo[file_name(room)]) return ""
            els=(roominfo[file_name(room)])[1]
            if (!els || !sizeof(els)) {
            return ""


    def __init__(self):
            self.rooms = allocate( MAXROOMS )
            self.roominfo = ([ ])


    def reset(self, ) -> None:
            int i
            if ( !sizeof( reset_definitions ) )
            return
            if ( !sizeof( reset_objects ) )
            reset_objects = allocate( sizeof( reset_definitions ) )
            for ( i = sizeof( reset_definitions ); i--; ) {
            switch ( reset_definitions[ i ][ FLAG ] ) {
            case REMOVABLE:
            if ( !reset_objects[ i ] ||
            ( environment( reset_objects[ i ] ) != self ) ) {
            if ( reset_definitions[ i ][ DELAY ] >= 0 )
            asyncio.create_task(self. "make_object", reset_definitions[ i ][ DELAY ], i )
            else
            make_object( i )


    def set_room(self, room_o: MudObject) -> MudObject:
            ownerroom=room_o
            return self


    def choose_words(self, label: Any, choice: Any) -> None:
            {
            int i
            class situation sit
            string *wc
            sit = sitdata[ label ]
            if (sizeof(sit->random_words)) {
            if (!sitwords) sitwords= ([ ])
            if (intp(choice)) {
            wc=[})
            for (i=0;i<sizeof(sit->random_words);i++) {
            wc+=["#"+(i+1),
            ((sit->random_words)[i])[
            RANDOM(sizeof((sit->random_words)[i]),choice+i*3347483647)]]


    def dest_me(self, ) -> None:
            destruct(self)


    def clean_up(self, parent: int) -> int:
            if (parent) {
            return 0


    def add_situation(self, label: Any, situation: Any) -> None:
            if (!sizeof(sitdata)) {
            sitdata= ([ label : sit ])
            sitwords= ([ ])


    def start_situation(self, label: Any, do_start_mess: int) -> None:
            class situation sdata
            string *chats
            mixed item,*items
            object chatter
            string *words
            sdata=sitdata[ label ]
            words=sitwords[ label ]
            if (!currentsits) currentsits=[label]
            else currentsits=currentsits+[label]
            if (sizeof(sdata->extra_look)) {
            if (els && sizeof(els))
            els+=[replace(sdata->extra_look,words)]
            else {
            els=[replace(sdata->extra_look,words)]
            ownerroom.add_extra_look(self)


    def end_situation(self, label: Any) -> None:
            class situation sdata
            string *chats
            mixed item,*items
            object chatter
            string *words
            sdata=sitdata[ label ]
            words=sitwords[ label ]
            if (currentsits) currentsits=currentsits-[label]
            if (els && sizeof(sdata->extra_look)) {
            els-=[replace(sdata->extra_look,words)]
            if (!sizeof(els)) ownerroom.remove_extra_look(self)


    def query_possible(self, situation_timing: Any, it: int, tod: int, cnt: int) -> int:
            {
            int possible
            class situation_timing sit2
            int cnt2,it2,tod2,possible2
            if (functionp(sit->when)) possible=(*(sit->when))(tod)
            else possible=sit->when
            possible=
            (possible&(1<<((AM_TIME_HANDLER)->query_am_hour(tod))))
            &&
            (RANDOM(1000,it*1147483647+cnt*2047483243) < sit->chance)
            if (possible && sit->category) {
            cnt2=0
            foreach (sit2 in sittiming) {
            cnt2++
            if (cnt2!=cnt && sit2->category == sit->category) {
            it2=(tod+offset+(cnt2*234231))/sit2->duration
            tod2=it2*sit2->duration-offset-(cnt2*234231)
            if (functionp(sit2->when)) possible2=(*(sit2->when))(tod2)
            else possible2=sit2->when
            possible2=
            (possible2&(1<<((AM_TIME_HANDLER)->query_am_hour(tod2))))
            &&
            (RANDOM(1000,it2*1147483647+cnt2*2047483243) < sit2->chance)
            if (possible2 && (tod2<tod || (tod==tod2 && cnt2<cnt))) {
            possible=0
            break


    def manage_situations(self, ) -> None:
            class situation_timing sit
            int t,t0,it,tod,cnt,possible,dt,tc,i
            mixed label,lb
            mixed *newsits
            mixed *changes
            mixed *background_on,*background_off
            int ttmp,tstep
            if (!automate) return
            if (!sizeof(filter_array( all_inventory( ownerroom ),(: interactive($1) :)))) {
            automate=2
            return


    def check_situations(self, ) -> None:
            if (automate==2 && interactive(this_player())) manage_situations()


    def make_seed(self, xval: int, yval: int) -> None:
            offset=(xval*38547+yval*1232444311)>>2


    def shutdown_all_situations(self, ) -> None:
            int label
            mixed h
            if (sizeof(cco)>1) {
            foreach (h in cco[1..<1]) {
            if (h) remove_asyncio.create_task(self.h)


    def shutdown_situation(self, handle: int, label: Any) -> None:
            mixed frog,bing
            if (sizeof(cco)) {
            if (!handle) handle=cco[0]
            if (handle && cco[handle]) remove_asyncio.create_task(self.cco[handle])
            cco[handle]=0


    def extra_look(self, ) -> str:
            if (!els || !sizeof(els)) {
            return ""


    def add_situation(self, label: Any, situation: Any) -> None:
            if (!clonep()) ::add_situation( label, sit )
            else write("You can't add situations to a clone of this object.")


    def set_room(self, room_o: MudObject) -> MudObject:
            if (clonep() ) {
            object base
            base = find_object(base_name(self))
            if (!base) {
            (base_name(self))->parp()
            base = find_object(base_name(self))


    def dest_me(self, ) -> None:
            if (clonep()) ::dest_me()
            else if (sizeof(children(base_name(self)))==1) ::dest_me()
            return


    def __init__(self):


    def setup_shadow(self, thing: MudObject, word: str) -> None:
            shadow(thing, 1)
            TERRAIN_MAP.setup_location(thing, word)
            thing.add_property("terrain name", word)
            terrain_name = word
            room = thing


    def destruct_shadow(self, thing: MudObject) -> None:
            if (thing == self) {
            TERRAIN_MAP.delete_cloned_location(terrain_name, file_name(room))
            destruct(self)
            } else {
            thing.destruct_shadow( thing )


    def event_exit(self, thing: MudObject, message: str, to: MudObject) -> None:
            if (!objectp(room)) {
            room = query_shadowing(self)


    def free_location(self, ) -> None:
            if (sizeof(all_inventory(room)) || (int)self.dont_free())
            return
            TERRAIN_MAP.delete_cloned_location(terrain_name, file_name(room))
            room.dest_me()


    def set_destination(self, direc: str) -> None:
            int i, j, delta, *co_ords, *new_co_ords = allocate(3)
            string dest_name
            object destination
            if ((i = STD_ORDERS.index(direc) if direc in STD_ORDERS else -1) == -1) {
            return


    def query_quit_handler(self, ) -> str:
            mixed *query_cloning_info() {
            return [TERRAIN_MAP, "find_location",
            terrain_name, (int *)room.query_co_ord()]


    def __init__(self):


    def destruct_shadow(self, thing: MudObject) -> None:
            if( thing == self )
            destruct( thing )
            else
            thing.destruct_shadow( thing )


    def setup_shadow(self, this_room: MudObject) -> None:
            shadow( this_room, 1 )
            shadowed_obj = this_room
            if( WEATHER_HANDLER.query_day() ) {
            asyncio.create_task(self. "changing_to_day", 0, 1 )
            last_updated = DAY
            } else {
            asyncio.create_task(self. "changing_to_night", 0, 1 )
            last_updated = NIGHT


    def event_weather(self, whats_changed: int) -> None:
            if (WEATHER_HANDLER.query_day()) {
            if (last_updated == NIGHT)
            change( DAY )
            } else if (last_updated == DAY)
            change( NIGHT )
            shadowed_obj.event_weather( whats_changed )


    def change(self, time_now: int) -> None:
            int i
            last_updated = time_now
            set_current_long()
            for ( i = 0; i < sizeof( roomitems[ last_updated ] ); i += 2 )  {
            shadowed_obj->modify_item( roomitems[ last_updated ][ i ],
            roomitems[ last_updated ][ i + 1 ] )


    def set_day_long(self, str: str) -> None:
            roomlong[DAY] = str
            set_current_long()


    def set_night_long(self, str: str) -> None:
            roomlong[NIGHT] = str
            set_current_long()


    def set_current_long(self, ) -> None:
            if (roomlong[last_updated] != 0 && roomlong[last_updated] != "")
            shadowed_obj.set_long( roomlong[last_updated] )


    def room_day_chat(self, args: Any) -> None:
            roomchats[DAY] = args
            if( last_updated == DAY )
            shadowed_obj.room_chat( args )


    def room_night_chat(self, args: Any) -> None:
            roomchats[NIGHT] = args
            if( last_updated == NIGHT )
            shadowed_obj.room_chat( args )


    def return_long(self, desc: Any) -> str:
            int ma
            if( !pointerp( desc ) )
            return (string)desc
            ma = desc .index( "long") if  "long" in desc  else -1
            if( ma < 0 )
            return "Error: No long found."
            return (string)desc[ma+1]


    def __init__(self):
            self.belows = []
            self.bottom = 0
            self.ghost_action = 0
            self.moves = []
            self.no_drop = 0
            self.death_mess = 0


    def setup_shadow(self, thing: MudObject) -> None:
            shadow( thing, 1 )
            room = thing


    def destruct_shadow(self, thing: MudObject) -> None:
            if ( thing == self )
            destruct( self )
            else
            thing.destruct_shadow( thing )


    def query_at_bottom(self, ) -> int:
            mixed *query_move( string word ) {
            int i
            i = moves .index( word) if  word in moves  else -1
            if ( i == -1 )
            return 0
            return moves[ i + 1 .. i + 3 ]


    def calc_co_ord(self, ) -> None:
            int i, delta, *co_ord
            string word, other
            room.calc_co_ord()
            if ( co_ord )
            return
            foreach ( word in ["down", "up"] ) {
            i = moves .index( word) if  word in moves  else -1
            if ( i == -1 )
            continue
            other = moves[ i + 2 ]
            if ( !find_object( other ) )
            continue
            co_ord = copy( (int *)other.query_co_ord() )
            if ( !co_ord )
            continue
            delta = (int)room.query_room_size_array()[2] +
            (int)other.query_room_size_array()[2]
            if ( word == "down" )
            co_ord[ 2 ] += delta
            else
            co_ord[ 2 ] -= delta
            room.set_co_ord( co_ord )
            return


    def set_wall(self, args: Any) -> None:
            int i, j
            mixed arg
            for ( i = sizeof( args ) - 2; i > -1; i -= 2 ) {
            arg = args[ i + 1 ]
            switch ( args[ i ] ) {
            case "bottom" :
            bottom = arg
            if ( ! no_drop ) {
            old_here = room.query_property( "here" )
            room.add_property( "here", "falling past you" )


    def event_enter(self, thing: MudObject, mess: str, from: MudObject) -> None:
            room.event_enter( thing, mess, from )
            if ( !living( thing ) && bottom && ( ! no_drop ) )
            asyncio.create_task(self. "fall_down", 0, thing )


    def fall_down(self, thing: MudObject) -> None:
            int damage
            string word
            if ( !thing )
            return
            if ( environment( thing ) != room )
            return
            damage = (int)room.query_room_size_array()[2]
            if ( sizeof( belows ) )
            foreach ( word in belows ) {
            tell_room( find_object( word ), (string)thing.a_short() +
            " $V$0=falls,fall$V$ past you and $V$0=is,are$V$ gone.\n" )
            damage += 2 * (int)word.query_room_size_array()[2]


    def update_water_light(self, ) -> None:
            private string on_bottom = "lying on the bottom",
            non_float = "drifting nearby",
            floating = "floating nearby",
            sinking = "sinking nearby",
            s_in_mess = "$N sink$s $down$ from $F.",
            s_out_mess = "$N sink$s $down$.",
            f_in_mess = "$N float$s $up$ from $F.",
            f_out_mess = "$N float$s $up$.",
            c_in_mess = "$N $V$0=is,are$V$ swept in from $F by the current.",
            c_out_mess = "$N $V$0=is,are$V$ swept $T by the current.",
            up_dir = "up", down_dir = "down"
            private int bottom = -1, surface = -1, clarity = 90, salinity = 0,
            turbulence = 100, update_light = 1, light_first_queried = 0,
            last_speech_volume = 0
            private mapping flows = ([ ]), exit_messes = ([ ]), enter_messes = ([ ]),
            origins = ([ ])
            string* query_default_search_description() {
            return ({
            "Funnily enough there is nothing interesting in the water.\n",
            "You search around and discover a whole bunch of water.\n",
            "You look up and down, left and right, then up and down again but "
            "all you can find is water.\n"
            })


    def is_allowed_position(self, poss: str) -> int:
            if (poss == SWIMMING) {
            return 1


    def set_bottom_mess(self, mess: str) -> None:
            on_bottom = mess


    def query_bottom_mess(self, ) -> str:
            return on_bottom


    def set_nonfloat_mess(self, mess: str) -> None:
            non_float = mess


    def query_nonfloat_mess(self, ) -> str:
            return non_float


    def set_float_mess(self, mess: str) -> None:
            floating = mess


    def query_float_mess(self, ) -> str:
            return floating


    def set_sinking_mess(self, mess: str) -> None:
            sinking = mess


    def query_sinking_mess(self, ) -> str:
            return sinking


    def set_sink_in_mess(self, mess: str) -> None:
            s_in_mess = mess


    def query_sink_in_mess(self, ) -> str:
            return replace(s_in_mess, ({"$down$", down_dir}))


    def set_sink_out_mess(self, mess: str) -> None:
            s_out_mess = mess


    def query_sink_out_mess(self, ) -> str:
            return replace(s_out_mess, ({"$down$", down_dir}))


    def set_float_in_mess(self, mess: str) -> None:
            f_in_mess = mess


    def query_float_in_mess(self, ) -> str:
            return replace(f_in_mess, ({"$up$", up_dir}))


    def set_float_out_mess(self, mess: str) -> None:
            f_out_mess = mess


    def query_float_out_mess(self, ) -> str:
            return replace(f_out_mess, ({"$up$", up_dir}))


    def set_sweep_in_mess(self, mess: str) -> None:
            c_in_mess = mess


    def query_sweep_in_mess(self, ) -> str:
            return c_in_mess


    def set_sweep_out_mess(self, mess: str) -> None:
            c_out_mess = mess


    def query_sweep_out_mess(self, ) -> str:
            return c_out_mess


    def set_up_dir(self, dir: str) -> None:
            up_dir = dir


    def query_up_dir(self, ) -> str:
            return up_dir


    def set_down_dir(self, dir: str) -> None:
            down_dir = dir


    def query_down_dir(self, ) -> str:
            return down_dir


    def set_bottom(self, val: int) -> None:
            bottom = val
            if (bottom > 1 || bottom < -1) {
            bottom = 1


    def set_surface(self, val: int) -> None:
            surface = val
            if (surface > 1 || surface < -1) {
            surface = 1


    def set_clarity(self, how_clear: int) -> None:
            clarity = how_clear
            if (clarity > 100) {
            clarity = 100


    def query_clarity(self, ) -> int:
            return clarity


    def set_turbidity(self, how_murky: int) -> None:
            set_clarity(100 - how_murky)


    def query_turbidity(self, ) -> int:
            return 100 - query_clarity()


    def set_salinity(self, how_salty: int) -> None:
            salinity = how_salty
            if (salinity > 100) {
            salinity = 100


    def query_salinity(self, ) -> int:
            return salinity


    def set_turbulence(self, how_turbulent: int) -> None:
            turbulence = how_turbulent
            if (turbulence < 0) {
            turbulence = 0


    def query_turbulence(self, ) -> int:
            return turbulence


    def set_use_surface_light(self, val: int) -> None:
            int surface_light
            object above
            update_light = 0
            if (!val) {
            return


    def query_water_surface_light(self, ) -> int:
            update_water_light()
            return query_my_light()*query_clarity()/100


    def get_water_surface_light(self, ) -> int:
            object above = query_above_room()
            if (!above) {
            return 0


    def update_water_light(self, ) -> None:
            if (!update_light) {
            return


    def add_flow(self, dir: str, rate: int) -> None:
            flows[dir] = rate


    def delete_flow(self, dir: str) -> None:
            map_delete(flows, dir)


    def query_flow(self, dir: str) -> int:
            return flows[dir]


    def query_water_traction_bonus(self, thing: MudObject, buoyancy: int) -> int:
            if (buoyancy < 0) {
            buoyancy = -buoyancy
            return buoyancy/3 + random(buoyancy/3)


    def query_above_room(self, ) -> MudObject:
            string destination = query_destination(up_dir)
            if (!destination) {
            return 0


    def query_below_room(self, ) -> MudObject:
            string destination = query_destination(down_dir)
            if (!destination) {
            return 0


    def query_surface_room(self, ) -> MudObject:
            object next
            if (query_surface()) {
            return self


    def query_bottom_room(self, ) -> MudObject:
            object next
            if (query_bottom()) {
            return self


    def event_enter(self, ob: MudObject, mess: str, from: MudObject) -> None:
            int effnum, buoyancy, *effects, *args
            effects = ob.effects_matching(SWIM_EFFECT->query_classification())
            if (!effects || !sizeof(effects)) {
            if (from && !from.query_water() ) {
            if( !lives_in_water( ob ) )
            ob.add_effect(SWIM_EFFECT, 2)


    def get_water(self, ) -> MudObject:
            object water = ARMOURY.request_item("water")
            switch (query_clarity()) {
            case 0..20:
            water.set_short("very muddy water")
            water.add_adjective(({"very", "muddy"}))
            water.set_long("This is $amount_size$ of very muddy water.\n")
            return water
            case 21..50:
            water.set_short("muddy water")
            water.add_adjective("muddy")
            water.set_long("This is $amount_size$ of muddy water.\n")
            return water
            case 51..80:
            water.set_short("slightly muddy water")
            water.add_adjective(({"slightly", "muddy"}))
            water.set_long("This is $amount_size$ of slightly muddy water.\n")


    def swim_exit(self, dir: str, ob: MudObject, mess: str) -> int:
            int difficulty, buoyancy = 0, place, this_turb, gp_cost, effnum, *arg
            string *places_to_go, *tm_messes
            object destination
            if (!living(ob) || ob.query_property("dead") || lives_in_water( ob ) ) {
            return 1


    def query_death_reason(self, ) -> str:
            return "drowning"


    def add_exit(self, direc: str, dest: Any, type: str) -> int:
            mixed *messy = query_dest_other(direc)
            if (messy && arrayp(messy[ROOM_ENTER]) && sizeof(messy[ROOM_ENTER]) == 2){
            origins[direc] = messy[ROOM_ENTER][1]


    def query_origin(self, dir: str) -> str:
            if (origins[dir]) {
            return origins[dir]


    def add_exit_mess(self, ob: MudObject, mess: str) -> None:
            exit_messes[file_name(ob)] = mess


    def add_enter_mess(self, ob: MudObject, mess: str) -> None:
            enter_messes[file_name(ob)] = mess


    def get_exit_mess(self, ob: MudObject, direc: str) -> str:
            string retval
            if (retval = exit_messes[file_name(ob)]) {
            map_delete(exit_messes, file_name(ob))
            return retval


    def get_enter_mess(self, ob: MudObject, direc: str) -> str:
            string retval
            if (retval = enter_messes[file_name(ob)]) {
            map_delete(enter_messes, file_name(ob))


    def init(self, ) -> None:
            add_command("float", "", (: do_float() :))
            add_command("drift", "", (: do_drift() :))
            add_command("swim", "", (: do_swim() :))


    def mangle_speech(self, type: str, words: str, target: Any) -> str:
            int drown
            string garbled = ""
            if (query_surface() || !this_player() ||
            this_player()->query_property("dead")) {
            return words


    def do_float(self, ) -> int:
            int *args, effnum = get_swim_enum(this_player())
            args = this_player()->arg_of(effnum)
            if (!args[0]) {
            if (sizeof(filter(query_flows(), (: $2 :)))) {
            add_failed_mess("You are already floating on the current.\n")


    def do_drift(self, ) -> int:
            int *args, effnum = get_swim_enum(this_player())
            args = this_player()->arg_of(effnum)
            if (!args[0]) {
            if (sizeof(filter(query_flows(), (: $2 :)))) {
            add_failed_mess("You are already drifting with the current.\n")


    def do_swim(self, ) -> int:
            int *args, effnum = get_swim_enum(this_player())
            args = this_player()->arg_of(effnum)
            if (args[0]) {
            if (sizeof(filter(query_flows(), (: $2 :)))) {
            add_failed_mess("You are already swimming against the current.\n")


    def get_swim_enum(self, thing: MudObject) -> int:
            int *effects = thing.effects_matching(SWIM_EFFECT->query_classification())
            if (!effects || !sizeof(effects)) {
            thing.add_effect(SWIM_EFFECT, 1)
            effects = thing.effects_matching(SWIM_EFFECT->query_classification())
            asyncio.create_task(self."soak", 1, thing)
            } else if (!random(50)) {
            asyncio.create_task(self."soak", 1, thing)


    def query_bottom(self, ) -> int:
            if (bottom == -1) {
            return query_exits(.index(down_dir) if down_dir in query_exits( else -1) == -1


    def query_surface(self, ) -> int:
            if (surface == -1) {
            return query_exits(.index(up_dir) if up_dir in query_exits( else -1) == -1


    def query_underwater(self, ) -> int:
            return !query_surface()


    def query_water(self, ) -> int:
            return 1


    def lives_in_water(self, ob: MudObject) -> int:
            string race_ob = ob.query_race_ob()
            if ( !living( ob ) ) {
            return 0


    def query_fixed_room(self, ) -> int:
            varargs mixed *query_dest_other( string direc ) {
            object room
            mixed ret
            if (!stringp(direc)) {
            return fixed_room.query_dest_other(direc)


    def attach(self, ob: MudObject) -> None:
            shadow(ob)
            fixed_room = ob


    def add_topo_exits(self, other_exits: str, other_types: str) -> None:
            string s
            foreach (s in other_exits) {
            if ((s == "compass4") || (s == "compass8")) {
            if (!self.query_exit("north"))
            self.add_exit("north", "/topography", other_types)
            if (!self.query_exit("south"))
            self.add_exit("south", "/topography", other_types)
            if (!self.query_exit("east"))
            self.add_exit("east", "/topography", other_types)
            if (!self.query_exit("west"))
            self.add_exit("west", "/topography", other_types)
            if (s == "compass8") {
            if (!self.query_exit("northeast"))
            self.add_exit("northeast", "/topography", other_types)
            if (!self.query_exit("northwest"))
            self.add_exit("northwest", "/topography", other_types)
            if (!self.query_exit("southeast"))
            self.add_exit("southeast", "/topography", other_types)
            if (!self.query_exit("southwest"))
            self.add_exit("southwest", "/topography", other_types)


    def query_look(self, direc: str) -> str:
            return aroom::query_look(direc, mountain::query_look(direc))


    def __init__(self):


    def query_room_letter(self, ) -> str:
            return "^"


    def query_look(self, direc: str) -> str:
            return aroom::query_look(direc, outside::query_look(direc))


    def __init__(self):


    def query_room_letter(self, ) -> str:
            return "."


    def query_look(self, direc: str) -> str:
            return aroom::query_look(direc, plain::query_look(direc))


    def __init__(self):


    def query_room_letter(self, ) -> str:
            return "."


    def query_look(self, direc: str) -> str:
            return aroom::query_look(direc, basic_room::query_look(direc))


    def __init__(self):


    def query_room_letter(self, ) -> str:
            return "b"


    def query_look(self, direc: str) -> str:
            return aroom::query_look(direc, water_inside::query_look(direc))


    def __init__(self):


    def query_room_letter(self, ) -> str:
            return "~"


    def query_look(self, direc: str) -> str:
            return aroom::query_look(direc, water_outside::query_look(direc))


    def __init__(self):


    def query_room_letter(self, ) -> str:
            return "~"


    def query_look(self, direc: str) -> str:
            return aroom::query_look(direc, woodland::query_look(direc))


    def __init__(self):


    def query_room_letter(self, ) -> str:
            return "%"


    def __init__(self):


    def __init__(self):


    def __init__(self):


    def __init__(self):


    def __init__(self):


    def __init__(self):


    def __init__(self):


    def __init__(self):


    def __init__(self):


    def __init__(self):


    def __init__(self):
            self._wash = ([ ])
            self._finished_funcs = []


    def init(self, ) -> None:
            self.add_init_wash_command()


    def query_baths(self, ) -> int:
            return 1


    def __init__(self):
            self._percentage_cut = 5
            self._room_type = CLUB_ROOM_CLUB_OR_FAMILY


    def __init__(self):
            self._percentage_cut = 5
            self._room_type = CLUB_ROOM_CLUB_OR_FAMILY
            private int club_commands_allowed() {
            return _room_type != CLUB_ROOM_FAMILY_ONLY


    def init(self, ) -> None:
            string bit
            if (club_commands_allowed()) {
            add_help_file("club_control_room")
            bit = "club name"
            add_command("create", "club called <string'club name'>",
            (: do_create($4[0]) :))
            add_command("list", "clubs",
            (: club_list(this_player()->query_name(), 0, 0) :) )
            add_command("list", "clubs [with member] <string'member name'>",
            (: do_club_list_member($4[0]) :))
            add_command("list", "club <string'club name'>",
            (: club_info($4[0], 1, this_player()->query_name()) :) )
            add_command("vote",
            "<word'person'> for <string:small'position'> in <string'club name'>",
            (: do_vote($4[0], $4[1], $4[2]) :))
            add_command("nominate",
            "<word'person'> for <string:small'position'> in <string'club name'>",
            (: do_nominate($4[0], $4[1], $4[2]) :))
            add_command("disband", "<string'club name'>", (: do_disband($4[0]) :))
            add_command("change", "<string'club name'> to {elected}",
            (: do_change($4[0], "elected") :) )
            add_command("change", "<string'club name'> option {secret|open}",
            (: do_change_option($4[0], $4[1]) :) )
            add_command("replace", "<number> insignia for <string'club name'>",
            (: do_insignia($4[1], $4[0]) :))
            add_command("replace", "insignia for <string'club name'>",
            (: do_insignia($4[0], 1) :))
            add_command("recruiter", "add <string'member'> for <string'club'>",
            (: do_recruiter_add($4[1], $4[0]) :))
            add_command("recruiter", "remove <string'member'> for <string'club'>",
            (: do_recruiter_remove($4[1], $4[0]) :))
            add_command("financials", "<string'club'>",
            (: do_financials($4[0], CLUB_DEFAULT_ACCOUNT_NAME) :))
            add_command("financials", "<string'club'> account <string'account name'>",
            (: do_financials($4[0], $4[1]) :))
            add_command("description", "of club <string'club name'>",
            (: do_describe($4[0]) :))
            add_command("announce", "for club <string'club name'>",
            (: do_announcement($4[0]) :))
            add_command("withdraw", "<string'money'> from <string'club name'> for <string:small'reason'>",
            (: do_withdrawl($4[0], $4[1], CLUB_DEFAULT_ACCOUNT_NAME, $4[2]) :))
            add_command("withdraw", "<string'money'> from <string'club name'> for <string:quoted'reason'>",
            (: do_withdrawl($4[0], $4[1], CLUB_DEFAULT_ACCOUNT_NAME, $4[2]) :))
            add_command("withdraw", "<string'money'> from <string'club name'> account <string'account name'> for <string:small'reason'>",
            (: do_withdrawl($4[0], $4[1], $4[2], $4[3]) :))
            add_command("withdraw", "<string'money'> from <string'club name'> account <string'account name'> for <string:quoted'reason'>",
            (: do_withdrawl($4[0], $4[1], $4[2], $4[3]) :))
            add_command("transfer", "<string'money'> from <string'club name'> account <string'source account'> to <string'desination account'> for <string:small'reason'>",
            (: do_transfer($4[0], $4[1], $4[2], $4[3], $4[4]) :))
            add_command("transfer", "<string'money'> from <string'club name'> account <string'source account'> to <string'desination account'> for <string:quoted'reason'>",
            (: do_transfer($4[0], $4[1], $4[2], $4[3], $4[4]) :))
            add_command("election", "force in <string'club'>",
            (: do_force_election($4[0]) :))
            club_discuss::init()


    def is_valid_club_name(self, name: str) -> int:
            int i
            if (strlen(name) > CLUB_MAX_NAME_LEN) {
            return 0


    def set_club_control_type(self, room_type: int) -> None:
            _room_type = room_type


    def query_club_control_type(self, ) -> int:
            return _room_type


    def set_club_region(self, region: str) -> None:
            _region = region


    def query_club_region(self, ) -> str:
            return _region


    def is_valid_family_name(self, name: str) -> int:
            if (PLAYER_HANDLER.test_user(lower_case(name))) {
            add_failed_mess("Cannot use the family name '" + name + "' since "
            "a player is already using it.\n")
            return 0


    def set_percentage_cut(self, value: int) -> None:
            _percentage_cut = value


    def query_percentage_cut(self, ) -> int:
            return _percentage_cut


    def query_club_warning_message(self, ) -> str:
            string place
            string ret
            place = query_property("place")
            if (!place) {
            place = "default"


    def init(self, ) -> None:
            add_command("discuss",
            "[open] {description|add position|"
            "change position name|memo|secret|"
            "remove member|no confidence|remove position|"
            "create account|remove account} in <string'club name'>",
            (: do_discuss(1, $4[0], $4[1]) :))
            add_command("discuss",
            "committee {description|add position|"
            "change position name|memo|secret|remove member|"
            "no confidence|remove position|"
            "create account|remove account} in <string'club name'>",
            (: do_discuss(0, $4[0], $4[1]) :))


    def do_discuss(self, open: int, type: str, club_name: str) -> int:
            if (open) {
            open = CLUB_DISCUSS_OPEN


    def query_owner(self, ) -> str:
            return _club_controller.query_owner_of(_club_owned_id)


    def set_club_controller(self, club_controller: str) -> None:
            _club_controller = club_controller


    def query_club_controller(self, ) -> str:
            return _club_controller


    def set_owned_id(self, id: str) -> None:
            _club_owned_id = id


    def query_owned_id(self, ) -> str:
            return _club_owned_id


    def init(self, ) -> None:
            add_command( "complain", "" )


    def do_complain(self, ) -> int:
            if ( this_player()->query_property( "guest" ) )
            return add_failed_mess( "Guest characters cannot lodge "
            "complaints.\n" )
            tell_object( this_player(), "You are lodging an official complaint about "
            "something or someone.\n"
            "Do not take this action lightly.\n"
            "Complaints should be about serious Faern-related matters.  "
            "Please note that this complaint is submitted anonymously.  "
            "If you wish to receive a reply, make sure you place your "
            "character name in the complaint so we know who to respond "
            "to.\n"
            "Feedback for the general populous also often appears on "
            "various bulletin boards.\n" )
            this_player()->do_edit( 0, "finish_complaint", self )
            return 1


    def finish_complaint(self, str: str) -> None:
            if ( !str ) {
            await  this_player().send("Complaint aborted.\n" )
            } else {
            if ( COMPLAINTS_HANDLER.do_submit_complaint( str ) ) {
            tell_object( this_player(), "Complaint posted.  Thank you for "
            "your complaint.  If you submitted your name in "
            "your complaint, you should receive a response in "
            "the near future.  Please be patient, as there may "
            "be in-depth discussions as a result of your "
            "complaint.\n" )
            } else {
            tell_object( this_player(), "There has been a problem posting "
            "your complaint.  As a result it has NOT been "
            "submitted.  You should contact a liaison or other "
            "creator to get this rectified immediately.\n" )


    def board_access_check(self, type: int, string, previous: MudObject, name: str) -> int:
            tell_creator("arienne",file_name(previous)+"\n")
            switch ( type ) {
            case B_ACCESS_READ:
            return ( "/secure/master"->query_lord( name ) )
            case B_ACCESS_WRITE:
            return ( ( previous == self ) ||
            ( "/secure/master"->query_lord( name ) ) )
            case B_ACCESS_DELETE :
            return 0


    def query_council_area(self, ) -> str:
            return _council_area


    def set_council_area(self, area: str) -> None:
            _council_area = area


    def send_council_inform(self, magistrate_only: int, message: str) -> None:
            NOMIC_HANDLER.send_council_inform(query_council_area(),
            magistrate_only, message)


    def __init__(self):
            self.cost_div = COST_DIV
            self.cost_mult = 100
            self.spells = ([ ])
            self.commands = ([ ])


    def init(self, ) -> None:
            {
            this_player()->add_command("advance", self,
            "<string>", (: do_advance($4[0]) :))
            this_player()->add_command("advance", self,
            "<string> to <number>",
            (: do_advance_to($4[0], $4[1]) :))
            this_player()->add_command("advance", self,
            "<string> by <number>",
            (: do_advance_by($4[0], $4[1]) :))
            this_player()->add_command("join", self, "")
            this_player()->add_command("info", self, "")
            this_player()->add_command("cost", self,
            "primaries", (: do_cost_primaries() :))
            this_player()->add_command("cost", self,
            "all", (: do_cost_all(0) :))
            this_player()->add_command("cost", self,
            "all brief", (: do_cost_all(1) :))
            this_player()->add_command("cost", self,
            "<string>", (: do_cost($4[0]) :))
            this_player()->add_command("cost", self,
            "<string> to <number>",
            (: do_cost_to($4[0], $4[1]) :))
            this_player()->add_command("cost", self, "<string> by <number>",
            (: do_cost_by($4[0], $4[1]) :))
            if ((string) this_player()->query_class_ob() == our_class) {
            if (stringp(start_pos) && !clonep(self)) {
            this_player()->add_start(file_name(self), start_pos)


    def set_cost_div(self, number: int) -> None:
            {
            cost_div = number
            if (!cost_div)
            cost_mult = 1000
            else
            cost_mult = 10 + (990 * cost_div) / (10 * COST_DIV + cost_div)


    def query_skill_cost(self, skill: str, offset: int) -> int:
            {
            int i
            int total
            string *next
            next = (string *) SKILL_OB.query_immediate_children(skill)
            if (!sizeof(next)) {
            if (!this_player()->query_class_ob())
            total = DEFAULT_COST
            else
            total = (int) our_class.query_skill_cost(skill)
            total *= (STD_COST * cost_mult) / 500
            total *= ((int) this_player()->query_skill(skill) + offset) /
            LEVEL_DIV + 1
            total = to_int(total * exp((this_player()->query_skill(skill) +
            offset) / 150.0))
            return total


    def do_advance_internal(self, skill: str, to: int, by: int) -> int:
            {
            string *bits
            string skill_name
            string outer_name
            string place
            int lvl
            int max_lvl
            int tmp
            int total_xp
            int total_cost
            int tmp_cost
            int p_val
            int i, j
            int round_value
            if ((string) this_player()->query_class_ob() != our_class) {
            add_failed_mess("You cannot advance here!  Go to your own class.\n")
            return 0


    def do_advance(self, skill: str) -> int:
            {
            return do_advance_internal(skill, 0, 1)


    def do_join(self, str: str) -> int:
            {
            if ((string) this_player()->query_class_ob() == our_class) {
            add_failed_mess("You're already in this class.\n")
            return 0


    def join2(self, str: str) -> int:
            {
            str = lower_case(str)
            if (str[0] != 'n' && str[0] != 'y') {
            write("I do not understand.  Yes or no? ")
            input_to("join2")
            return 1


    def do_leave(self, str: str) -> int:
            {
            if (str != "class") {
            add_failed_mess("Syntax : leave class\n")
            return 0


    def confirm_leave(self, str: str) -> None:
            {
            str = lower_case(str)
            if (str != "y") {
            write("You are still in the class.\n")
            return


    def check_primaries(self, lpath: str, g_o: str) -> int:
            {
            int i
            string dummy,
            *primaries
            primaries = (string *) g_o.query_skills()
            if (primaries.index(lpath) if lpath in primaries else -1 != -1)
            return 1
            for (i = 0; i < sizeof(primaries); i++)
            if (sscanf(primaries[i], lpath + ".%s", dummy))
            return 1
            return 0


    def do_cost_all(self, brief: int) -> int:
            {
            mixed *arr
            string list
            if ((string) this_player()->query_class_ob() != our_class) {
            add_failed_mess("You are not a member of this class.\n")
            return 0


    def do_cost_primaries(self, ) -> int:
            {
            mixed *arr
            string list
            string *primaries
            if ((string) this_player()->query_class_ob() != our_class) {
            add_failed_mess("You are not a member of this class.\n")
            return 0


    def do_cost_internal(self, skill: str, to: int, by: int) -> int:
            string *bits
            string skill_name
            string outer_name
            string place
            string cost_str
            int lvl
            int max_lvl
            int i
            int tmp
            int cost
            if ((string) this_player()->query_class_ob() != our_class) {
            add_failed_mess("You are not a member of this class.\n")
            return 0


    def do_cost(self, skill: str) -> int:
            {
            mixed *arr
            int i
            int depth
            string list
            string exp_skill
            string *sub_skills
            int only_leaf
            if ((string) this_player()->query_class_ob() != our_class) {
            add_failed_mess("You are not a member of this class.\n")
            return 0


    def do_cost_to(self, skill: str, num: int) -> int:
            {
            return do_cost_internal(skill, num, 0)


    def do_cost_by(self, skill: str, num: int) -> int:
            {
            return do_cost_internal(skill, 0, num)


    def do_info(self, ) -> int:
            {
            mixed *arr
            string *primaries
            write(our_class.long() +
            "\nThis class's primary skills and costs are:\n")
            arr = copy((mixed *)SKILL_OB.query_skills())
            if (!arr) {
            add_failed_mess("Hmmm, we appear to have an error here.\n")
            return 0


    def set_teaching_person(self, ob: MudObject) -> None:
            {
            teaching_person = ob


    def query_teaching_person(self, ) -> MudObject:
            {
            return teaching_person


    def add_spell(self, name: str, blue: str, lvl: int) -> None:
            {
            string path
            path = implode(blue, ".")
            if (!spells[path])
            spells[path] = [name, lvl]
            else
            spells[path] += [name, lvl]


    def add_command(self, name: str, blue: str, lvl: int) -> None:
            {
            string path
            path = implode(blue, ".")
            if (!commands)
            commands = ([ ])
            if (!commands[path])
            commands[path] = [name, lvl]
            else
            commands[path] += [name, lvl]


    def check_spells_commands(self, sk: str, lvl: int) -> None:
            {
            string *bits
            int val
            int i
            int j
            if (!teaching_person)
            return
            bits = keys(spells)
            for (i = 0; i < sizeof(bits); i++) {
            val = this_player()->query_skill(bits[i])
            for (j = 0; j < sizeof(spells[bits[i]]); j += 2)
            if ((spells[bits[i]][j + 1] < val) &&
            !(this_player()->query_spell(spells[bits[i]][j])))
            teaching_person->init_command("teach " + spells[bits[i]][j] +
            " to " +
            this_player()->query_name())


    def query_start_pos(self, ) -> str:
            {
            return start_pos


    def query_our_guild(self, ) -> str:
            {
            return our_class


    def __init__(self):
            self._honours = ([ ])
            self._titles = []


    def __init__(self):
            self._honours = ([ ])
            self._titles = []
            void inform_of_honour_change(string type, string person,
            string reason, string changed_by) {


    def set_controlled_titles(self, title: Any) -> None:
            _titles = title


    def add_to_honour_roll(self, person: str, reason: str, added_by: str) -> None:
            string title
            if (_honours[person]) {
            return


    def remove_from_honour_roll(self, person: str) -> None:
            string title
            if (!_honours[person]) {
            return


    def is_on_honour_roll(self, person: str) -> int:
            return classp(_honours[person])


    def do_list_honour(self, ) -> int:
            string person
            class honour roll
            string ret
            string* people
            if (!_honours) {
            _honours = ([ ])


    def do_honour_add(self, person: str) -> int:
            if (!is_allowed_to_change(this_player()->query_name())) {
            add_failed_mess("You are not allowed to add people to the honour "
            "roll.\n")
            return 0


    def end_honour_add(self, reason: str, person: str, bing: str) -> None:
            if (reason == "" || !reason) {
            write("Aborting.\n")
            return


    def honour_roll_confirm(self, response: str, person: str, reason: str) -> None:
            response = lower_case(response)
            if (!strlen(response) || response[0] != 'y') {
            write("Aborting.\n")
            return


    def do_honour_remove(self, person: str, reason: str) -> int:
            if (!is_allowed_to_change(this_player()->query_name())) {
            add_failed_mess("You are not allowed to add people to the honour "
            "roll.\n")
            return 0


    def readd_all_titles(self, ) -> None:
            string person
            class honour roll
            foreach (person, roll in _honours) {
            foreach (string title in _titles) {
            PLAYER_TITLE_HANDLER.add_title_to_player(person, title)


    def init(self, ) -> None:
            if (!sizeof(_titles)) {
            return 0


    def __init__(self):
            self._floor = create_floor()


    def init(self, ) -> None:
            add_command("bang", "gavel", (: do_bang() :))
            add_command("recover", "floor", (: do_recover() :))
            add_command("start", "meeting", (: do_start() :))
            add_command("finish", "meeting", (: do_finish() :))


    def create_floor(self, ) -> MudObject:
            object floor
            floor = clone_object("/std/object")
            floor.set_name("floor")
            floor.set_short( "floor" )
            floor.add_property( "determinate", "the " )
            floor.add_property( "no burial", 1)
            floor->set_long("This is the floor of the meeting.  It gives you the "
            "right to speak during the meeting.  Please give this "
            "to the next person to speak after you have finished.\n")
            return floor


    def do_start(self, ) -> int:
            if (_leader &&
            find_player(_leader) &&
            environment(find_player(_leader)) == self) {
            add_failed_mess("There is already a meeting started with " +
            find_player(_leader)->the_short() +
            " as the leader.\n")
            return 0


    def do_bang(self, ) -> int:
            if (this_player()->query_name() != _leader) {
            add_failed_mess("Only the leader can bang the gavel!\n")
            return 0


    def do_recover(self, ) -> int:
            if (this_player()->query_name() != _leader) {
            add_failed_mess("Only the leader can recover the floor.\n")
            return 0


    def do_finish(self, ) -> int:
            if (this_player()->query_name() != _leader) {
            add_failed_mess("Only the leader can stop the meeting!\n")
            return 0


    def event_dest_me(self, ob: MudObject) -> None:
            object *inv
            if (living(ob)) {
            if (userp(ob) &&
            ob.query_name() == _leader) {
            tell_room(self,
            "The meeting finishes abruptly as the leader leaves.\n")


    def event_quit(self, ob: MudObject) -> None:
            object *inv
            if (living(ob)) {
            if (userp(ob) &&
            ob.query_name() == _leader) {
            tell_room(self,
            "The meeting finishes abruptly as the leader leaves.\n")


    def __init__(self):
            self._reporters = ([ ])
            self._editors = []
            self._payees = ([ ])
            self._articles = []
            self._category = ([ ])
            self._adverts = []
            self._setters = []
            self._sponsors = []
            self._next_article_num = 2


    def __init__(self):
            self._reporters = ([ ])
            self._editors = []
            self._payees = ([ ])
            self._articles = []
            self._category = ([ ])
            self._adverts = []
            self._setters = []
            self._sponsors = []
            self._next_article_num = 2
            protected void save_me()
            {
            if (_save_dir && !_proxy) {
            unguarded( (: save_object(_save_dir + "main") :) )


    def set_save_directory(self, dir: str) -> None:
            if (dir[<1] != '/') {
            dir += "/"


    def save_article_text(self, our_article: Any, text: str) -> None:
            if (a_type(art->art->type) != NEWSPAPER_ARTICLE_TYPE_HTML &&
            a_type(art->art->type) != NEWSPAPER_ARTICLE_TYPE_PLAIN) {
            return


    def load_article_text(self, our_article: Any) -> str:
            mixed* bits
            string str
            str = unguarded( (: read_file(_save_dir + $(art->art->file_name)) :) )
            if (str) {
            bits = restore_variable(str)
            return bits[1]


    def load_article_text_by_file(self, fname: str) -> str:
            int i
            for (i = 0; i < sizeof(_articles); i++) {
            if (_articles[i]->art->file_name == fname) {
            return load_article_text(_articles[i])


    def save_article_text_by_file(self, fname: str, text: str) -> None:
            int i
            for (i = 0; i < sizeof(_articles); i++) {
            if (_articles[i]->art->file_name == fname) {
            update_article_info(_articles[i], text)
            return save_article_text(_articles[i], text)


    def set_article_title_by_file(self, fname: str, title: str) -> None:
            int i
            for (i = 0; i < sizeof(_articles); i++) {
            if (_articles[i]->art->file_name == fname) {
            _articles[i]->art->title = title
            save_me()
            return


    def delete_article(self, our_article: Any) -> None:
            unguarded( (: rm(_save_dir + $(article->art->file_name)) :) )
            unguarded( (: rm(_save_dir + $(article->art->file_name) + ".proc" ) :) )
            unguarded( (: rm(_save_dir + $(article->art->file_name) + ".nroff.o" ) :) )


    def query_article_index(self, match: str) -> int:
            int index
            match = lower_case(match)
            if (strlen(match) && (match[0] >= '0' && match[0] <= '9')) {
            sscanf(match, "%d", index)
            index--
            if (index < 0 || index >= sizeof(_articles)) {
            return -1


    def query_category(self, category: str) -> str:
            string name
            category = lower_case(category)
            foreach (name in keys(_category)) {
            if (lower_case(name) == category ||
            lower_case(name)[0..strlen(category) - 1] == category) {
            return name


    def query_log_file_name(self, ) -> str:
            return _save_dir + "event.log"


    def query_article_log_file_name(self, ) -> str:
            return _save_dir + "aritcle.log"


    def query_current_edition(self, ) -> int:
            {
            return NEWSPAPER_HANDLER.query_current_edition_num(query_paper_name())


    def query_paper_name(self, ) -> str:
            {
            return _paper_name


    def query_the_paper_name(self, ) -> str:
            {
            if (lower_case(_paper_name[0..3]) == "the") {
            return _paper_name


    def set_paper_name(self, name: str) -> str:
            {
            _paper_name = name


    def query_next_article_file_name(self, ) -> str:
            {
            while (file_size(_save_dir + _next_article_num + ".txt") != -1) {
            _next_article_num++


    def query_bank_branch(self, ) -> str:
            {
            return _bank_branch


    def set_bank_branch(self, bank: str) -> None:
            _bank_branch = bank


    def do_apply(self, ) -> int:
            {
            if (_proxy) {
            return _proxy.do_apply()


    def mail_application(self, text: str) -> int:
            {
            string word
            string *eds
            if (!text) {
            await this_player().send("You decide not to apply just yet.\n")
            return 0


    def part_two(self, str: str, author: str, html: int) -> int:
            {
            if (!sizeof(str)) {
            await this_player().send("The article must have a name!\n")
            tell_room(self, this_player()->the_short() +
            " stops writing to think of a name.\n",
            this_player())
            return 0


    def do_submit(self, str: str, author: str, html: int) -> int:
            {
            if (_proxy) {
            return _proxy.do_submit(str, author, html)


    def do_retrieve(self, edn: str, source: int) -> int:
            {
            class our_article article
            if (_proxy) {
            return _proxy.do_retrieve(edn, source)


    def show_article(self, our_article: Any, source: int) -> int:
            {
            string text
            mixed* bits
            int i
            mixed* stuff
            class advert data
            switch (a_type(article->art->type)) {
            case NEWSPAPER_ARTICLE_TYPE_SECTION :
            text = "%^BOLD%^" + article->art->title + "%^RESET%^\n\n"
            for (i = 0; i < sizeof(_articles); i++) {
            if (_articles[i] == article) {
            i++
            break


    def do_logs(self, article_log: int) -> int:
            {
            string logfile
            if (_proxy) {
            return _proxy.do_logs(article_log)


    def do_articles(self, scroll: int) -> int:
            {
            string str
            class our_article article
            int pos
            int editor
            if (_proxy) {
            return _proxy.do_articles(scroll)


    def do_resign(self, ) -> int:
            {
            object *inv
            object ob
            string person
            if (_proxy) {
            return _proxy.do_resign()


    def do_delete(self, str: str) -> int:
            {
            class our_article article
            int i
            if (_proxy) {
            return _proxy.do_delete(str)


    def do_hire(self, person: str, setter: int) -> int:
            {
            string bing
            object thatguy
            if (_proxy) {
            return _proxy.do_hire(person, setter)


    def do_dismiss(self, person: str) -> int:
            {
            object thatguy
            if (_proxy) {
            return _proxy.do_dismiss(person)


    def do_sponsor_add(self, person: str) -> int:
            {
            if (_proxy) {
            return _proxy.do_sponsor_add(person)


    def do_sponsor_remove(self, person: str) -> int:
            {
            if (_proxy) {
            return _proxy.do_sponsor_remove(person)


    def do_promote(self, person: str) -> int:
            {
            object thatguy
            if (_proxy) {
            return _proxy.do_promote(person)


    def do_demote(self, person: str, editor: int) -> int:
            {
            object thatguy
            if (_proxy) {
            return _proxy.do_demote(person, editor)


    def do_everyone_status(self, ) -> int:
            string ret
            if (_proxy) {
            return _proxy.do_everyone_status()


    def do_status(self, ) -> int:
            {
            string ret
            int i
            int last_num
            if (_proxy) {
            return _proxy.do_status()


    def do_claim(self, ) -> int:
            {
            object badge
            object *deepinv
            object *inv
            if (_proxy) {
            return _proxy.do_claim()


    def do_publish(self, headline: str) -> int:
            {
            class our_article* bing
            if (_proxy) {
            return _proxy.do_publish(headline)


    def query_total_profit(self, num_articles: int) -> int:
            int last_pub
            int amount
            int edition
            int adds
            class advert data
            class our_article bing
            string text
            if (num_articles == -1) {
            num_articles = 0
            foreach (bing in _articles) {
            if (!(bing->flags & NEWSPAPER_POSTPONE_FLAG)) {
            text = load_article_text(bing)
            if (strlen(text) > 500) {
            num_articles++


    def really_publish(self, char: str, headline: str) -> None:
            {
            int article_count
            int amount
            int total
            string *things
            string temp
            class article* to_publish
            string* text
            class our_article bing
            class payee_data data
            string stuff
            string place
            int i
            int editor_bonus
            int num_editors
            place = query_property("place")
            char = lower_case(char)
            things = [})
            if (strlen(char) && char[0] == 'y') {
            tell_object(this_player(),
            "Okay, warm up the frogs, let's see if everything is "
            "sorted out.\n")
            } else {
            await this_player().send("Okay, publishing aborted.\n")
            return 0


    def do_summary(self, ) -> int:
            int amount
            int adds
            string person
            int total
            class our_article bing
            class payee_data payee_data
            string text
            string ret
            int article_count
            string place
            class advert data
            int i
            int last_num
            int num_editors
            int editor_bonus
            if (_proxy) {
            return _proxy.do_summary()


    def do_deposit(self, amt: str) -> int:
            int amt_int
            string place
            if (_proxy) {
            return _proxy.do_deposit(amt)


    def do_set_bank_branch(self, branch: str) -> int:
            {
            string* accounts
            if (_proxy) {
            return _proxy.do_set_bank_branch(branch)


    def do_title(self, id: str, title: str) -> int:
            {
            class our_article art
            if (_proxy) {
            return _proxy.do_title(id, title)


    def do_author(self, id: str, author: str) -> int:
            {
            class our_article art
            if (_proxy) {
            return _proxy.do_author(id, author)


    def do_change(self, id: str, type: str) -> int:
            {
            class our_article art
            if (_proxy) {
            return _proxy.do_change(id, type)


    def do_change_xp(self, id: str, type: str) -> int:
            {
            class our_article art
            if (_proxy) {
            return _proxy.do_change_xp(id, type)


    def do_change_colour(self, id: str, colour: str) -> int:
            {
            class our_article art
            if (_proxy) {
            return _proxy.do_change_colour(id, colour)


    def do_editing(self, id: str) -> int:
            {
            class our_article art
            string contents
            if (_proxy) {
            return _proxy.do_editing(id)


    def move_article(self, index: int, up_down: str) -> int:
            class our_article womble
            if (index == -1) {
            return 0


    def do_move(self, article: str, up_down: str) -> int:
            int index
            class our_article womble
            if (_proxy) {
            return _proxy.do_move(article, up_down)


    def do_move_pos(self, article: str, pos: str) -> int:
            int index
            int to_index
            class our_article womble
            if (_proxy) {
            return _proxy.do_move_pos(article, pos)


    def do_postpone(self, id: str, on_off: str) -> int:
            class our_article art
            if (_proxy) {
            return _proxy.do_postpone(id, on_off)


    def do_lock_article(self, id: str, on_off: str) -> int:
            class our_article art
            if (_proxy) {
            return _proxy.do_lock_article(id, on_off)


    def do_category_list(self, ) -> int:
            string ret
            string place
            string name
            class category_data data
            if (_proxy) {
            return _proxy.do_category_list()


    def do_advert_list(self, ) -> int:
            string ret
            string place
            class advert data
            int editor
            int found
            int pos
            if (_proxy) {
            return _proxy.do_advert_list()


    def do_advert_remove(self, id: int) -> int:
            class advert fluff
            if (_proxy) {
            return _proxy.do_advert_remove(id)


    def do_category_remove(self, category: str) -> int:
            if (_proxy) {
            return _proxy.do_category_remove(category)


    def do_category_add(self, category: str) -> int:
            string new_category
            if (_proxy) {
            return _proxy.do_category_add(category)


    def do_category_open(self, category: str, open: str) -> int:
            if (_proxy) {
            return _proxy.do_category_open(category, open)


    def do_category_cost(self, category: str, cost: str) -> int:
            int value
            string place
            if (_proxy) {
            return _proxy.do_category_cost(category, cost)


    def do_category_cost_per_ten_chars(self, category: str, cost: str) -> int:
            int value
            string place
            if (_proxy) {
            return _proxy.do_category_cost_per_ten_chars(category, cost)


    def do_submit_section(self, name: str) -> int:
            class our_article cur_art
            if (_proxy) {
            return _proxy.do_submit_section(name)


    def do_submit_add(self, category: str) -> int:
            if (_proxy) {
            return _proxy.do_submit_add(category)


    def do_lock(self, locked: int) -> int:
            if (_proxy) {
            return _proxy.do_lock(locked)


    def finish_add(self, str: str, category: str) -> None:
            int value
            string place
            if (!str || !strlen(str)) {
            write("Ok, Aborted writing an add.\n")
            return


    def confirm_add(self, str: str, text: str, category: str, value: int) -> None:
            class advert add
            string place
            int found
            class our_article bing
            if (!str || !strlen(str)) {
            return 0


    def finish_editing(self, story: str, our_article: Any) -> int:
            {
            if (!story) {
            await this_player().send("Ok, no editing saved.\n")
            return 0


    def do_transfer_ownership(self, new_owner: str) -> int:
            int value
            string place
            if (!is_owner(this_player()->query_name())) {
            add_failed_mess("You must be the owner to transfer the ownership.\n")
            return 0


    def check_transfer(self, test: str, new_owner: str, value: int) -> None:
            string place
            test = lower_case(test)
            if (!strlen(test) || test[0] != 'y') {
            write("Aborted.\n")
            return 0


    def is_postponed(self, article: Any) -> int:
            class our_article rabbit
            foreach (rabbit in _articles) {
            if (rabbit->art->file_name == art->file_name) {
            return rabbit->flags & NEWSPAPER_POSTPONE_FLAG


    def is_locked(self, article: Any) -> int:
            class our_article rabbit
            foreach (rabbit in _articles) {
            if (rabbit->art->file_name == art->file_name) {
            return rabbit->flags & NEWSPAPER_LOCK_FLAG


    def is_reporter(self, word: str) -> int:
            {
            if (_proxy) {
            return _proxy.is_reporter(word)


    def is_setter(self, word: str) -> int:
            {
            if (_proxy) {
            return _proxy.is_setter(word)


    def is_sponsor(self, word: str) -> int:
            {
            if (_proxy) {
            return _proxy.is_sponsor(word)


    def is_editor(self, word: str) -> int:
            {
            if (_proxy) {
            return _proxy.is_editor(word)


    def is_owner(self, word: str) -> int:
            {
            if (_proxy) {
            return _proxy.is_owner(word)


    def add_reporter(self, word: str) -> None:
            {
            if (!_reporters[word]) {
            _reporters[word] = new(class reporter)
            _reporters[word]->date_added = time()
            update_commands(word)
            save_me()


    def add_sponsor(self, word: str) -> None:
            {
            if (!is_sponsor(word)) {
            _sponsors += [word]
            update_commands(word)
            save_me()


    def add_setter(self, word: str) -> None:
            {
            if (!is_setter(word)) {
            if (!is_reporter(word)) {
            add_reporter(word)


    def add_editor(self, word: str) -> None:
            {
            if (!is_editor(word)) {
            if (!is_reporter(word)) {
            add_reporter(word)


    def remove_reporter(self, word: str) -> None:
            {
            if (!is_reporter(word)) {
            return


    def remove_editor(self, word: str) -> None:
            {
            if (!is_editor(word)) {
            return


    def remove_setter(self, word: str) -> None:
            {
            if (!is_setter(word)) {
            return


    def remove_sponsor(self, word: str) -> None:
            {
            if (!is_sponsor(word)) {
            return


    def update_commands(self, word: str) -> None:
            {
            object player
            player = find_player(word)
            if (player && environment(player) == self) {
            player.move("/room/void")
            player.move(file_name(self))


    def query_owner(self, ) -> str:
            if (_proxy) {
            return _proxy.query_owner()


    def set_owner(self, person: str) -> None:
            _owner = person
            save_me()


    def ownership_change(self, old_owner: str, new_owner: str) -> None:
            set_owner(new_owner)


    def set_proxy(self, proxy: str) -> None:
            _proxy = proxy


    def query_proxy(self, ) -> str:
            return _proxy


    def board_access_check(self, type: int, board: str, previous: MudObject, name: str) -> int:
            switch (type) {
            case B_ACCESS_READ :
            return is_reporter(lower_case(name))
            case B_ACCESS_WRITE :
            return is_reporter(lower_case(name))
            case B_ACCESS_DELETE :
            return is_editor(name)


    def init(self, ) -> None:
            {
            string person
            person = this_player()->query_name()
            add_command("advert", "categories", (: do_category_list() :))
            add_command("advert", "list", (: do_advert_list() :))
            add_command("category", "list", (: do_category_list() :))
            add_command("submit", "advert {in|to|into} <string'category'>",
            (: do_submit_add($4[1]) :))
            add_command("submit", "advert <string'category'>",
            (: do_submit_add($4[0]) :))
            if (!is_editor(person) && !is_reporter(person) && !is_setter(person)) {
            add_command("apply", "", (: do_apply() :))
            add_command("status", "", (: do_everyone_status() :))
            return


    def __init__(self):
            self._allowed = []


    def init(self, ) -> None:
            if (this_player()->query_name() == query_owner()) {
            add_command("room",
            "allow <string'person'>",
            (: do_allow($4[0]) :))
            add_command("room",
            "disallow <string'person'>",
            (: do_disallow($4[0]) :))
            add_command("room",
            "throwout <indirect:living'person'>",
            (: do_throwout($4[0]) :))


    def set_save_file(self, name: str) -> None:
            _save_file = name


    def query_save_file(self, ) -> str:
            return _save_file


    def query_owner(self, ) -> str:
            return _owner


    def set_owner(self, owner: str) -> None:
            _owner = owner


    def set_front_door(self, exit: str) -> None:
            _front_door = exit


    def query_front_door(self, ) -> str:
            return _front_door


    def is_allowed_in(self, person: str) -> int:
            person = lower_case(person)
            if (person != query_owner()) {
            if (call_door(_front_door,
            "query_locked")) {
            if (_allowed.index(person) if person in _allowed else -1 != -1) {
            return 0


    def is_allowed(self, person: str) -> int:
            if (person == query_owner() ||
            query_allowed(.index(person) if person in query_allowed( else -1) != -1) {
            return 1


    def load_room(self, ) -> None:
            if (_save_file) {
            restore_object(_save_file)
            call_door(_front_door,
            "set_locked",
            1)


    def save_room(self, ) -> None:
            if (_save_file) {
            save_object(_save_file)


    def save_me(self, ) -> None:
            protected string make_pretty_catalog( string arg, string from, string to, string specific )
            protected int compare_widgets( object new_ob, int existing_id )
            protected void build_catalogs(){
            int id
            class _book book
            foreach( id, book in _catalog ){
            if( _catalog_by_author[ lower_case(book->cap_author) ] )
            _catalog_by_author[ lower_case(book->cap_author) ] += [id]
            else
            _catalog_by_author[ lower_case(book->cap_author) ] = [id]
            if( _catalog_by_title[ lower_case(book->cap_title) ] )
            _catalog_by_title[ lower_case(book->cap_title) ] += [id]
            else
            _catalog_by_title[ lower_case(book->cap_title) ] = [id]


    def __init__(self):
            self._catalog_by_author = ([ ])
            self._catalog_by_title = ([ ])
            self._player_contributable = 1
            self._library_name = "The illustrious library of fluff"
            self._save_file = base_name( this_object() ) + ".o"
            self._catalog = ([ ])
            self._accounts = ([ ])
            self._fines = ([ ])
            self._access = ([ ])
            self._loan_length = 3 * 24 * 60 * 60
            self._fine_per_day = 400
            self._lost_damaged_fine = 1050
            self._max_loans = 5


    def init(self, ) -> None:
            if( _player_contributable ){
            add_command( "add", "<indirect:object:me'book'> with "
            "title <string'title'> by author <word'author'>",
            (: do_add( $1, $4[1], $4[2] ) :) )
            add_command( "remove", "<number'book id'>",
            (: do_remove_book( $4[0] ) :))


    def do_add(self, obs: MudObject, title: str, author: str) -> int:
            object t_p, t_o
            int num, id, *ids
            t_p = this_player()
            t_o = self
            debug_printf( "Obs: %O\n", obs )
            if( query_access(this_player()) < LIBRARIAN_ACCESS ){
            add_failed_mess("Only librians can do this.\n")
            return 0


    def remove_book(self, id: int) -> None:
            object ob
            class _book book
            int i
            if( !_catalog[id] )
            return
            book = _catalog[id]
            for( i = 0; i < (book->copies - sizeof(book->loaned)); i++ ){
            if( book->path )
            ob = clone_object( book->path )
            if( book->auto_load )
            ob = PLAYER_OB.load_auto_load_to_array( book->auto_load, this_player() )[0]
            ob.move( self )


    def do_remove_book(self, id: int) -> int:
            int out
            string player, bit
            class _account account
            class _loan loan
            if( query_access(this_player()) < LIBRARIAN_ACCESS ){
            add_failed_mess("Only librians can do this.\n")
            return 0


    def do_borrow(self, arg: Any) -> int:
            int id, ret, t
            object ob
            class _book book
            class _loan loan
            string name
            name = this_player()->query_name()
            id = to_int(arg)
            if( query_access(this_player()) < USER_ACCESS ){
            add_failed_mess("You do not have access to this library.\n")
            return 0


    def do_return(self, obs: MudObject) -> int:
            string name, bit
            int id, *owed, i, *ours, due
            class _loan loan
            class _book book
            object ob, *not_ours, *wrong_player, *returned
            name = this_player()->query_name()
            owed = [})
            ours = not_ours = wrong_player = returned = [})
            if( !sizeof(_accounts[name]->loans) ){
            add_failed_mess( "You don't have any books out on loan.\n" )
            return 0


    def do_list(self, arg: str, from: str, to: str, specific: str) -> int:
            if( (to && !stringp(to)) || (from && !stringp(from)) ){
            add_failed_mess( "The ranges must be letters.\n")
            return 0


    def do_pay(self, ) -> int:
            int cash, fine
            string place, str
            place = query_property( "place" )
            if ( !place || ( place == "" ) )
            place = "default"
            cash = this_player()->query_value_in( place )
            if ( place != "default" )
            cash += this_player()->query_value_in( "default" )
            if( !cash ){
            add_failed_mess("You have money!.\n")
            return 0


    def do_status(self, player: str) -> int:
            int fine
            string place, str, bit
            class _loan loan
            if( !player )
            player = this_player()->query_name()
            player = lower_case(player)
            if( player != this_player()->query_name() &&
            query_access(this_player()) < LIBRARIAN_ACCESS ){
            add_failed_mess("You do not have access to see other accounts.\n")
            return 0


    def do_book_status(self, id: int) -> int:
            string str, name, date
            class _book book
            id = to_int(id)
            if( !_catalog[id] ){
            add_failed_mess("The id " +id+ ", does not point to an item.\n")
            return 0


    def do_set(self, player: str, type: str) -> int:
            player = lower_case(player)
            if( query_access(self) <= query_access(player) ){
            add_failed_mess( "You do not have permission to do this.\n")
            return -1


    def do_mark(self, id: int, flag: int) -> int:
            if( query_access(this_player()) < LIBRARIAN_ACCESS ){
            add_failed_mess("You do not have permission to do this.\n")
            return 0


    def do_set_fine(self, i: int) -> int:
            string place
            if( query_access(this_player()) < LIBRARIAN_ACCESS ){
            add_failed_mess("You do not have permission to do this.\n")
            return 0


    def do_set_loan_length(self, days: int) -> int:
            string str
            if( query_access(this_player()) < LIBRARIAN_ACCESS ){
            add_failed_mess("You do not have permission to do this.\n")
            return 0


    def do_set_max_loans(self, i: int) -> int:
            if( query_access(this_player()) < LIBRARIAN_ACCESS ){
            add_failed_mess("You do not have permission to do this.\n")
            return 0


    def do_lost_damaged_fine(self, i: int) -> int:
            string place
            if( query_access(this_player()) < LIBRARIAN_ACCESS ){
            add_failed_mess("You do not have permission to do this.\n")
            return 0


    def do_report(self, id: int, arg: str, player: str) -> int:
            string str
            class _loan loan, match
            if( player && query_access(this_player()) < LIBRARIAN_ACCESS ){
            add_failed_mess("You can only report your damaged or lost books.\n")
            return 0


    def clear_loan(self, player: Any, id: int, calc_fines: int) -> None:
            int fine
            class _loan loan
            if( objectp(player) && userp(player) )
            player = player.query_name()
            if( !stringp(player) )  return
            if( !_accounts[player] || !sizeof(_accounts[player]->loans) )  return
            foreach( loan in _accounts[player]->loans ){
            if( loan->id == id ){
            if( calc_fines && (loan->due_back - time() < 0) ){
            fine = (((time() - loan->due_back) / AM_SECONDS_PER_DAY) + 1) * _fine_per_day
            if( _fines[player] )
            _fines[player] += fine
            else
            _fines[player] = fine


    def extra_look(self, ob: MudObject) -> str:
            string *libs, str, place
            str = "Welcome to " + _library_name + ".\n"
            libs = filter( keys(_access), (: _access[$1] == LIBRARIAN_ACCESS :) )
            if( !sizeof(libs) )
            str += "Currently there are no caretakers of the books.\n"
            if( sizeof(libs) == 1 )
            str += PLAYER_HANDLER.query_cap_name(libs[0]) + " is the sole caretaker "
            " of the books.\n"
            if( sizeof(libs) > 1 ){
            libs = map( libs, (: PLAYER_HANDLER.query_cap_name($1) :) )
            str += query_multiple_short(libs) + " are caretakers of the books.\n"


    def save_me(self, ) -> None:
            if( find_asyncio.create_task(self."save_it") == -1 )
            asyncio.create_task(self. "save_it", 2 )


    def query_fine(self, name: str) -> int:
            mapping query_catalog(){
            return _catalog


    def set_access(self, player: str, access: int) -> None:
            if( !access ){
            map_delete( _access, player )
            } else {
            _access[player] = access


    def query_access(self, player: Any) -> int:
            return LIBRARIAN_ACCESS


    def init(self, ) -> None:
            if(!this_player() || !interactive(this_player()))
            return
            this_player()->add_command("place", self,
            "<indirect:object'furniture'> so it is <word'verb'> "
            "{"+implode(ABOUT_PREPOSITIONS+HANGING_PREPOSITIONS+WALL_PREPOSITIONS+CORNER_PREPOSITIONS, "|")+"} "
            "the <string:'location'> [wall|corner]")
            this_player()->add_command("place", self,
            "<indirect:object'furniture'> "
            "{"+implode(ABOUT_PREPOSITIONS+HANGING_PREPOSITIONS+WALL_PREPOSITIONS+CORNER_PREPOSITIONS, "|")+"} the <string'location'> [wall|corner]")
            this_player()->add_command("displace", self,
            "<indirect:object'furniture'>")
            this_player()->add_command("place", self,
            "help", (: do_help(0) :))
            this_player()->add_command("place", self,
            "help <indirect:object'furniture'>",
            (: do_help($1[0]) :))


    def set_wall_name(self, direction: str, name: str) -> None:
            int pos
            if (!_wall_names) {
            _wall_names = ([ ])


    def query_wall_name_pos(self, pos: int) -> str:
            if (!_wall_names) {
            _wall_names = ([ ])


    def query_wall_name(self, direction: str) -> str:
            int pos
            pos = get_pos_int(direction)
            return query_wall_name_pos(pos)


    def query_another(self, ob: MudObject) -> str:
            {
            object *obs
            string another
            obs = filter(have_described,
            (: $1.query_plural() == $(ob.query_plural()) :))
            switch(sizeof(obs))
            {
            case 0 :
            another = " a"
            break
            case 1 :
            another = " another"
            break
            default :
            another = " yet another"
            break


    def query_more(self, ob: MudObject) -> str:
            {
            object *obs
            string more
            obs = filter(have_described,
            (: $1.query_plural() == $(ob.query_plural()) :))
            switch(sizeof(obs))
            {
            case 0 :
            more = ""
            break
            default :
            more = " more"
            break


    def clutter_string(self, ob: MudObject) -> str:
            mixed *things
            string cluttered = ""
            if(ob.query_has_surface()) {
            things = ob.find_inv_match("all", ob)
            things = unique_array(things, (: $1.query_plural() :))
            switch(sizeof(things)) {
            case 1 :
            if(sizeof(things[0]) == 1)
            cluttered = " is"
            else
            cluttered = " are"
            cluttered += " " + query_multiple_short(things[0])
            break
            default :
            break


    def query_multiple_furniture_short(self, obs: MudObject) -> str:
            object *party
            mixed *things
            string str
            string *strs
            strs = [})
            things = unique_array(obs, (: $1.query_plural() :))
            foreach(party in things)
            {
            switch(sizeof(party))
            {
            case 0 :
            break
            case 1 :
            str = query_another(party[0])[1..]
            str += " " + party[0]->query_short()
            break
            default :
            str = query_num(sizeof(party))
            str += query_more(party[0])
            str += " " + party[0]->query_plural()
            break


    def is_wall_hanging(self, pos: int) -> int:
            {
            if(orientation)
            {
            if([13, 15, 17, 19].index(pos) if pos in [13, 15, 17, 19] else -1 != -1)
            {
            return 1


    def is_in_centre(self, pos: int) -> int:
            {
            if(pos == 1)
            {
            return 1


    def query_max_space_around(self, pos: int) -> int:
            {
            if(is_in_corner(pos))
            {
            return 2


    def do_help(self, ob: MudObject) -> int:
            string str
            string *bits
            if(ob && !ob.query_furniture())
            return this_player()->add_failed_mess(self,
            "$I is not a piece of furniture.\n",
            [ob])
            str = "The place command requires a furniture object, an optional verb, "
            "a preposition and a location.  "
            if(!ob) {
            str += "Which verbs are available depends on the furniture.  Hanging "
            "furniture can use " + query_multiple_short(HANGING_VERBS) + ".  "
            } else {
            if(ob.query_allowed_room_verbs())
            bits = filter(keys(ob.query_allowed_room_verbs()), (: $1 != "" :))
            switch(sizeof(bits)) {
            case 0:
            str += "The " + ob.the_short() + " has no verbs.\n"
            break
            case 1:
            str += "The verb for " + ob.the_short() + " is " +
            query_multiple_short(bits) + ".\n"
            break
            default:
            str += "The verbs available for " + ob.the_short() + " are " +
            query_multiple_short(bits) + ".\n"


    def do_place(self, obs: MudObject, string, string, args: Any, string) -> int:
            {
            int pos, allowed
            string k, v
            mapping allowed_verbs
            object *things
            object *placed
            object* already_around
            class obj_match result
            #ifdef DEBUG
            debug_printf("Obs: %O, args: %O", obs, args)
            #endif
            if(this_player() &&
            !self.test_occupier(this_player()->query_name()) &&
            !this_player()->query_creator()) {
            this_player()->add_failed_mess(self,
            "You don't own this house.\n", [}))
            return 0


    def get_pos_int(self, str: str) -> int:
            {
            string dir
            int pos_int
            dir = explode(str, " ")[0]
            dir = EXPAND_EXIT(dir)
            switch(dir)
            {
            case "ceiling" :
            case "floor" :
            case "centre" :
            pos_int = 1
            break
            case "north" :
            pos_int = 2
            break
            case "south" :
            pos_int = 6
            break
            case "east" :
            pos_int = 4
            break
            case "west" :
            pos_int = 8
            break
            case "northeast" :
            pos_int = 3
            break
            case "southeast" :
            pos_int = 5
            break
            case "southwest" :
            pos_int = 7
            break
            case "northwest" :
            pos_int = 9
            break


    def find_opposite(self, pos: int, structure: MudObject) -> int:
            {
            int opp
            if(pos == 1 || pos == 11)
            {
            return 0


    def find_above(self, pos: int, structure: MudObject) -> int:
            {
            int above
            if(pos < 10)
            {
            above = pos + 10


    def find_below(self, pos: int, structure: MudObject) -> int:
            {
            int below
            if(pos > 10)
            {
            below = pos - 10


    def find_left(self, pos: int, structure: MudObject) -> int:
            {
            int left
            if(pos == 1 || pos == 11)
            {
            return 0


    def find_right(self, pos: int, structure: MudObject) -> int:
            {
            int right
            if(pos == 1 || pos == 11)
            {
            return 0


    def query_furniture_ordinal(self, ob: MudObject) -> str:
            {
            int index
            string str_num
            object *obs
            str_num = ""
            obs = match_objects_for_existence(ob.query_plural(), [self])
            index = obs.index(ob) if ob in obs else -1
            if((index != -1) && (sizeof(obs) != 1))
            {
            str_num = " " + word_ordinal(index + 1)


    def object_position_desc(self, thing: MudObject) -> str:
            {
            string verb
            string other
            string position
            string str
            verb = thing.query_property(PLACEMENT_CURRENT_ROOM_VERB)
            other = thing.query_property(PLACEMENT_CURRENT_ROOM_OTHER)
            position = get_pos_desc(thing.query_property(PLACEMENT_CURRENT_ROOM_POSITION))
            if(verb == "")
            {
            str = other + " " + position


    def describe_relative_position(self, index: int) -> str:
            {
            string relative_desc
            switch(index)
            {
            case OPPOSITE :
            relative_desc = OPPOSITE_DESCS[random(sizeof(OPPOSITE_DESCS))]
            break
            case ABOVE :
            relative_desc = ABOVE_DESCS[random(sizeof(ABOVE_DESCS))]
            break
            case BELOW :
            relative_desc = BELOW_DESCS[random(sizeof(BELOW_DESCS))]
            break
            case RIGHT :
            relative_desc = RIGHT_DESCS[random(sizeof(RIGHT_DESCS))]
            break
            case LEFT :
            relative_desc = LEFT_DESCS[random(sizeof(LEFT_DESCS))]
            break


    def object_desc2(self, thing: MudObject) -> str:
            {
            string verb
            string other
            string position
            string str
            mapping allowed_verbs
            verb = thing.query_property(PLACEMENT_CURRENT_ROOM_VERB)
            allowed_verbs = thing.query_allowed_room_verbs()
            if (!allowed_verbs) {
            allowed_verbs = ([ ])


    def object_desc(self, thing: MudObject) -> str:
            {
            string str
            switch(random(2))
            {
            case 0 :
            str = object_position_desc(thing) + " is " + thing.a_short()
            break
            default :
            str = object_position_desc(thing) + " is " + thing.a_short()
            break


    def desc_around_with(self, ob: MudObject, around: MudObject) -> str:
            {
            around -= have_described
            if(sizeof(around) == 1)
            {
            return "$C$" + object_desc(ob) + " " +
            around[0]->query_property(PLACEMENT_CURRENT_ROOM_OTHER) +
            " which is " + query_multiple_furniture_short(around) + ".  "


    def trim_trailing_spaces(self, str: str) -> str:
            {
            int i
            if(!sizeof(str))
            {
            return str


    def choose_relative(self, relatives: int, structure: MudObject) -> int:
            int num, found
            int *rands
            rands = [0, 1, 2, 3, 4]
            while(sizeof(rands)) {
            num = rands[random(sizeof(rands))]
            if(objectp(structure[relatives[num]])) {
            if(needs_described.index(structure[relatives[num]]) if structure[relatives[num]] in needs_described else -1 != -1) {
            found = 1
            break


    def set_orientation(self, num: int) -> None:
            {
            orientation = num


    def query_orientation(self, ) -> int:
            {
            return orientation


    def wall_or_corner(self, pos: int) -> str:
            {
            return query_wall_name_pos(pos)


    def desc_obs_relatively(self, indexes: int, structure: MudObject) -> str:
            {
            int i
            int *relatives
            string desc
            object *around
            int rel_num
            object rel_ob
            desc = ""
            while(sizeof(indexes)) {
            i = indexes[random(sizeof(indexes))]
            indexes -= [i]
            if(needs_described.index(structure[i]) if structure[i] in needs_described else -1 == -1) {
            continue


    def room_order(self, obs1: MudObject, obs2: MudObject, structure: MudObject) -> int:
            {
            int pos1, pos2
            object ob1, ob2
            int order1, order2
            pos1 = -(obs1[0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION))
            pos2 = -(obs2[0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION))
            if (pos1 < 0) {
            ob1 = 0
            } else {
            ob1 = structure[pos1]


    def describe_remaining_objects(self, structure: MudObject) -> str:
            {
            int pos
            string desc
            object *party
            mixed *orphans
            desc = ""
            if(sizeof(needs_described))
            {
            orphans = unique_array(needs_described,
            (: $1.query_property(PLACEMENT_CURRENT_ROOM_POSITION) :))
            if(sizeof(orphans))
            {
            orphans = sort_array(orphans, (: room_order($1, $2, $(structure)) :))
            foreach(party in orphans)
            {
            pos = party[0]->query_property(PLACEMENT_CURRENT_ROOM_POSITION)
            desc += desc_around_without(party, structure, pos)
            needs_described -= party
            have_described += party


    def get_group_verb(self, obs: MudObject) -> str:
            {
            mixed *verbs
            verbs = map(obs, (: $1.query_property(PLACEMENT_CURRENT_ROOM_VERB) :))
            verbs = unique_array(verbs, (: $1 :))
            if(sizeof(verbs) == 1)
            {
            return verbs[0][0]


    def get_group_other(self, obs: MudObject) -> str:
            {
            mixed *others
            others = map(obs, (: $1.query_property(PLACEMENT_CURRENT_ROOM_OTHER) :))
            others = unique_array(others, (: $1 :))
            if(sizeof(others) == 1)
            {
            return others[0][0]


    def describe_plural_objects(self, indexes: int, structure: MudObject) -> str:
            {
            int i, j
            int flag
            int rel_num
            int used_pos
            mixed *things
            string desc = ""
            string *strs
            strs = [})
            things = [})
            for(i = 0; i < sizeof(indexes); i++) {
            things += [structure[indexes[i]]]


    def furniture_long(self, ) -> str:
            {
            string desc, d1, d2, d3
            object *structure
            int i, *indexes
            if(furniture_long != "") {
            return furniture_long


    def get_pos_desc(self, pos_int: int) -> str:
            {
            string str
            switch(pos_int)
            {
            case 1 :
            str = "the centre of " + self.the_short()
            break
            case 2 :
            case 12 :
            str = "the north " + wall_or_corner(pos_int)
            break
            case 3 :
            case 13 :
            str = "the northeast " + wall_or_corner(pos_int)
            break
            case 4 :
            case 14 :
            str = "the east " + wall_or_corner(pos_int)
            break
            case 5 :
            case 15 :
            str = "the southeast " + wall_or_corner(pos_int)
            break
            case 6 :
            case 16 :
            str = "the south " + wall_or_corner(pos_int)
            break
            case 7 :
            case 17 :
            str = "the southwest " + wall_or_corner(pos_int)
            break
            case 8 :
            case 18 :
            str = "the west " + wall_or_corner(pos_int)
            break
            case 9 :
            case 19 :
            str = "the northwest " + wall_or_corner(pos_int)
            break
            case 11 :
            str = "the centre of the ceiling"
            break


    def get_structure_index(self, ob: MudObject) -> int:
            {
            return build_structure(.index(ob) if ob in build_structure( else -1)


    def desc_surface(self, dir: str) -> str:
            {
            int i
            int pos
            int *indexes
            int current_pos
            string desc
            object *structure
            object *around
            structure = build_structure()
            needs_described = [})
            have_described = [})
            if(dir == "ceiling")
            {
            pos = 11


    def displace_object(self, ob: MudObject) -> None:
            {
            if (ob.query_property(PLACEMENT_CURRENT_ROOM_POSITION)) {
            ob.remove_property(PLACEMENT_CURRENT_ROOM_VERB)
            ob.remove_property(PLACEMENT_CURRENT_ROOM_OTHER)
            ob.remove_property(PLACEMENT_CURRENT_ROOM_POSITION)
            furniture_long = ""


    def do_displace(self, obs: MudObject) -> int:
            {
            if(this_player() &&
            !self.test_occupier(this_player()->query_name()) &&
            !this_player()->query_creator()) {
            this_player()->add_failed_mess(self,
            "You don't own this house.\n")
            return 0


    def event_exit(self, ob: MudObject, string, object) -> None:
            {
            displace_object(ob)


    def test_remove(self, thing: MudObject, flag: int, dest: Any) -> int:
            if(thing.query_property(PLACEMENT_IMMOVABLE))
            return 0
            if(thing.query_property(PLACEMENT_CURRENT_ROOM_HIDDEN))
            thing.removed()
            return 1


    def query_owner(self, ) -> str:
            class decoration {
            string short
            string covering


    def debug_log(self, fmt: str, args: Any) -> None:
            debug_printf(fmt + "\n", args ...)
            if(base_name(self) == "/d/cwc/Bes_Pelargic/Pong_Ping/roads/phoenix_avenue/housing/05entrycorridor") {
            log_file("HOUSING_DEBUG", "%s (%s): " + fmt + "\n",
            ctime(time())[4..18], base_name(self), args ...)


    def __init__(self):
            self.exits = ([ ])
            self.exit_shorts = ([ ])
            self.decorations = []
            self.tell_denied = []
            self.done_setup = 0


    def show_surface(self, direc: str) -> str:
            class decoration tmp
            int found
            string lstr, dstr
            mixed tmp2
            switch(direc) {
            case "left":
            case "right":
            case "forward":
            case "backward":
            tmp2 = this_player()->query_facing()
            direc = (string)this_player()->find_abs(direc, tmp2[0])
            break
            case "up":
            direc = "ceiling"
            break
            case "down":
            direc = "floor"
            break


    def show_corner(self, direc: str) -> str:
            string tmp
            tmp = desc_surface(direc)
            if(tmp == "") {
            tmp = "The " + direc + " corner is empty."


    def exit_long(self, ) -> str:
            string *direcs, lstr
            int i, j
            object door
            direcs = query_direc()
            if(!sizeof(direcs))
            return ""
            lstr = "  $C$"
            for(i=0; i<sizeof(direcs); i++) {
            update_short_cache(direcs[i])
            if(query_relative(direcs[i])) {
            j = REL_DIRS.index(this_player()->find_rel(direcs[i])) if this_player()->find_rel(direcs[i]) in REL_DIRS else -1
            lstr += REL_DIRS[j+2]
            if(exit_shorts[direcs[i]]) {
            if(query_door_control(direcs[i]))
            lstr += " " + query_door_control(direcs[i])->a_short() + " leads "
            "to " + exit_shorts[direcs[i]]->a_short
            else
            lstr += " an exit leads to " + exit_shorts[direcs[i]]->a_short
            } else {
            if(query_door_control(direcs[i]))
            lstr += " is " + query_door_control(direcs[i])->a_short()
            else
            lstr += " is an exit"


    def decoration_long(self, ) -> str:
            class decoration tmp
            string lstr, wstr, tmpstr, *tmparray, *names
            int i
            #ifdef 0
            if(decoration_desc != "")
            return decoration_desc
            #endif
            lstr = ""
            if(sizeof(decorations)) {
            coverings = ([ ])
            names = ["walls"]
            foreach ( tmp in decorations ) {
            if(!coverings[tmp->covering])
            coverings[tmp->covering] = [tmp->short]
            else
            coverings[tmp->covering] += [tmp->short]
            if(classp(tmp) && strsrch(tmp->short, "wall") == -1)
            names += [tmp->short]


    def query_long(self, ) -> str:
            string lstr, tmp
            if(base_long)
            lstr = "This is " + base_long + "."
            else
            lstr = ""
            tmp = decoration_long()
            if(tmp != "")
            lstr += tmp
            else
            lstr += "  "
            return (lstr + furniture_long() + exit_long() + "\n")


    def setup_exit(self, direc: str, relative: int) -> int:
            if(STANDARD_EXITS.index(direc) if direc in STANDARD_EXITS else -1 != -1 && relative)
            modify_exit(direc, ["relative", 1])
            modify_exit(direc, ["closed", 1])
            return 1


    def set_base_desc(self, desc: str) -> None:
            base_long = desc


    def query_base_desc(self, ) -> str:
            return base_long


    def set_quit_handler(self, filename: str) -> None:
            quit_location = filename


    def query_quit_handler(self, ) -> str:
            if(this_player() && !test_occupier(this_player()->query_name()) &&
            quit_location)
            return quit_location
            return base_name(self)


    def add_surface(self, short: str, covering: str) -> None:
            class decoration tmp
            string dir
            if(!surfaces)
            surfaces = [})
            surfaces += [short]
            if(!decorations)
            decorations = [})
            else {
            foreach(tmp in decorations)
            if(tmp->short == short) {
            add_item(tmp->short, (: show_surface($(tmp->short)) :))
            short = replace(short, ({" wall", ""}))
            foreach(dir in keys(ABS_FACING)) {
            if(ABS_FACING[short] &&
            ABS_FACING[dir] == (ABS_FACING[short] % 8 ) + 1) {
            add_item(dir+" corner", (: show_corner($(dir)) :))
            break


    def decorate_surface(self, short: str, covering: str) -> int:
            class decoration tmp
            foreach(tmp in decorations)
            if(tmp->short == short) {
            tmp->covering = covering
            event(self, "save")
            decoration_desc = ""
            return 1


    def query_decorations(self, ) -> None:
            printf("%O\n", decorations)


    def test_save(self, thing: MudObject) -> int:
            return thing.query_furniture() || thing.query_missing_item_receipt()


    def test_remove(self, thing: MudObject, flag: int, dest: Any) -> int:
            if(!placement::test_remove(thing, flag, dest))
            return 0
            return room_save::test_remove(thing, flag, dest)


    def init(self, ) -> None:
            placement::init()
            if(!allowed) {
            allowed = [})


    def event_enter(self, ob: MudObject, message: str, from: MudObject) -> None:
            #ifdef PLAYTESTING
            if(interactive(ob) &&
            (!ob.query_creator() &&
            !"/obj/handlers/playtesters"->query_playtester(ob.query_name())) &&
            ob.query_name() != "gumboot") {
            await ob.send("Sorry, this area is only open to playtesters.\n")
            ob.move(from)


    def allow_list(self, ) -> int:
            string *tmp
            if(owner && owner != "For Sale" && owner != "Under Offer") {
            tmp = [owner] + allowed
            } else {
            tmp = allowed


    def do_allow(self, player: MudObject, location: str) -> int:
            string pname
            string *rooms
            string room
            int failed
            if((query_owner() != this_player()->query_name()) &&
            !this_player()->query_creator()) {
            add_failed_mess("You are not allowed to control this room.\n", [}))
            return 0


    def do_deny(self, player: str, location: str) -> int:
            object ob
            string *rooms, room
            if(allowed.index(player) if player in allowed else -1 == -1) {
            add_failed_mess(player + " is not on the allow list.\n")
            return 0


    def update_doors(self, ) -> None:
            string exit
            object door_ob
            if(!done_setup)
            setup_doors()
            if(!exits)
            exits = ([ ])
            foreach(exit in query_exits()) {
            door_ob = query_door_control(exit)
            if(door_ob) {
            if(door_ob.query_key() == "generic_key") {
            #ifdef DEBUG
            if(exits[exit])
            debug_log("update_doors", "Door %s has generic_key, exit data "
            "has %s", exit, exits[exit]->key)
            else
            debug_log("update_doors", "Door %s has generic_key, no existing "
            "exit data.", exit)
            #endif


    def setup_doors(self, ) -> None:
            string exit
            object door
            string other, other_id
            #ifdef DEBUG2
            debug_log("Setup doors called.")
            #endif
            if(!self.query_exits()) {
            self.calc_exits()


    def query_owner(self, ) -> str:
            if(owner)
            return owner
            return HOUSING.query_owner(base_name(self))


    def add_allowed(self, pname: str) -> int:
            if(test_occupier(pname))
            return 0
            allowed += [pname]
            event(self, "save")
            return 0


    def remove_allowed(self, pname: str) -> int:
            if(!test_occupier(pname))
            return 0
            allowed -= [pname]
            event(self, "save")
            return 1


    def test_occupier(self, name: str) -> int:
            if(!owner)
            catch(owner = HOUSING.query_owner(base_name(self)))
            if(!owner || lower_case(owner) == "for sale" ||
            lower_case(owner) == "under offer")
            return 1
            if(PLAYER_HANDLER.test_creator(name))
            return 1
            if(!allowed)
            allowed = [})
            return (owner == name || (allowed.index(name) if name in allowed else -1 != -1))


    def ownership_change(self, old_owner: str, new_owner: str) -> int:
            if(old_owner != new_owner) {
            owner = new_owner
            allowed = [})
            return 1


    def is_allowed(self, name: str) -> int:
            if((query_owner() && (lower_case(name) == lower_case(query_owner()))) ||
            (query_allowed(.index(lower_case(name)) if lower_case(name) in query_allowed( else -1) != -1) ||
            PLAYER_HANDLER.test_creator(name)) {
            return 1


    def dest_me(self, ) -> None:
            #ifdef NOT_USED
            if (base_name(self) + ".c" != __FILE__)
            update_doors()
            #endif
            ::dest_me()


    def event_open(self, door: MudObject, opener: MudObject) -> None:
            #ifdef DEBUG2
            debug_log("door opened by %s [%d]", opener.query_name(), done_setup)
            #endif
            if(done_setup) {
            ::event_open(door, opener)
            update_doors()


    def event_close(self, door: MudObject, closer: MudObject) -> None:
            #ifdef DEBUG2
            debug_log("door closed by %s [%d]", closer.query_name(), done_setup)
            #endif
            if(done_setup) {
            ::event_close(door, closer)
            update_doors()


    def event_unlock(self, door: MudObject, unlocker: MudObject) -> None:
            #ifdef DEBUG2
            debug_log("door unlocked by %s [%d]",
            unlocker?unlocker.query_name():"noone", done_setup)
            #endif
            if(done_setup) {
            ::event_unlock(door, unlocker)
            update_doors()


    def event_lock(self, door: MudObject, locker: MudObject) -> None:
            #ifdef DEBUG2
            debug_log("door locked by %s [%d]", locker?locker.query_name():"noone",
            done_setup)
            #endif
            if(done_setup) {
            ::event_lock(door, locker)
            update_doors()


    def __init__(self):
            self._mail_information = ""


    def set_short(self, short: str) -> None:
            _short = short


    def set_description_file(self, str: str) -> None:
            _desc_file = str


    def query_description_file(self, ) -> str:
            return _desc_file


    def set_mail_information(self, mail: str) -> None:
            _mail_information = mail


    def query_short(self, area: str, nomic_case: Any, type: str, data: Any) -> str:
            return _short


    def query_description(self, area: str, type: str) -> str:
            string str
            if (_desc_file) {
            str = unguarded( (: NROFF_HAND.cat_file(_desc_file+"_nroff", 1) :) )
            if (!str) {
            unguarded( (: NROFF_HAND.create_nroff(_desc_file, _desc_file+"_nroff") :) )
            str = unguarded( (: NROFF_HAND.cat_file(_desc_file+"_nroff", 1) :) )


    def start_punishment(self, area: str, nomic_case: Any, type: str, finish: Any) -> None:
            evaluate(finish, the_case, type, 0)


    def complete_punishement(self, area: str, nomic_case: Any, type: str, data: Any) -> None:
            return


    def suspend_punishment(self, area: str, nomic_case: Any, type: str, data: Any) -> None:
            return


    def check_entry(self, player_ob: MudObject, room_ob: MudObject) -> int:
            return ROOM_RENTAL_HANDLER.check_tenant( player_ob, room_ob )


    def query_costume_mess(self, costume: MudObject) -> str:
            return "The imp takes the " + costume.query_short() + ".\n"


    def evict_tenant(self, tenants: Any) -> None:
            string exit = query_exits()[0]
            foreach (object person in tenants) {
            tell_object( person, "You hear the soft tinkling of a bell.  As the "
            "sound resounds throughout the room it shatters your "
            "illusions.  A small imp hurries into the room and gently but "
            "firmly propels you outside the door.\n" )


    def event_exit(self, ob: MudObject, message: str, to: MudObject) -> None:
            object *costumes
            costumes = filter( deep_inventory( ob ),
            (: $1.query_property( "costume" ) :) )
            foreach( object costume in costumes )
            costume.move( "/room/rubbish", query_costume_mess( costume ) )


    def set_domain(self, dom: str) -> None:
            _domain = dom


    def query_domain(self, ) -> str:
            return _domain


    def set_location(self, loc: str) -> None:
            _location = loc


    def query_location(self, ) -> str:
            return _location


    def __init__(self):


    def init(self, ) -> None:
            add_command( "list", "[rooms]" )
            add_command( "rent", "<string'room'>",
            (: do_rental( $4[0] ) :) )
            if ( this_player()->query_creator() ) {
            add_command( "add", "<string> for <number>",
            (: add_room( $4[0], $4[1] ) :) )
            add_command( "remove", "<string>", (: delete_room( $4[0] ) :) )


    def query_list(self, ) -> str:
            string room
            string list = ""
            string tenant
            object room_ob
            object office_ob = self
            tell_creator( "goldenthread", "getting list for %s ( %O )\n",
            office_ob.short(), office_ob )
            foreach( room in ROOM_RENTAL_HANDLER.query_rooms_to_rent( office_ob ) ) {
            tenant = ROOM_RENTAL_HANDLER.query_who_rents( room, office_ob )
            tell_creator( "goldenthread", "found %s\n", room )
            if ( room_ob = load_object( room ) ) {
            list += room_ob.query_short()
            if ( tenant != "nobody" )
            list += " (rented by " + tenant + ")\n"
            else
            list += " (available for " + MONEY_HAND->money_value_string(
            to_int( ROOM_RENTAL_HANDLER.query_rental_value( room ) ),
            _domain ) + ")\n"


    def do_list(self, ) -> int:
            string list = "Here are the rooms available to rent in " + _location
            + ":\n\n"
            this_player()->add_succeeded_mess( self, "$N ask$s for a list "
            "of available rooms.\n", [}) )
            list += query_list()
            await  this_player().send(list )
            return 1


    def add_room(self, room: str, cost: int) -> int:
            if ( ROOM_RENTAL_HANDLER.add_room( room, cost, self ) ) {
            this_player()->add_succeeded_mess( self,
            ["$N $V a room.\n", ""], [}) )
            return 1


    def delete_room(self, room: str) -> int:
            if( ROOM_RENTAL_HANDLER.delete_room( room, self ) ) {
            this_player()->add_succeeded_mess( self,
            ["$N $V a room.\n", ""], [}) )
            return 1


    def clear_rooms(self, ) -> int:
            if( ROOM_RENTAL_HANDLER.clear_rooms( self ) ) {
            this_player()->add_succeeded_mess( self,
            ["$N $V the list of rooms.\n", ""], [}) )
            return 1


    def do_rental(self, room: str) -> int:
            object ob = this_player()
            int ret = ROOM_RENTAL_HANDLER.do_rental( ob, room, self )
            switch( ret ) {
            case RENTAL_SUCCESS:
            ob->pay_money( MONEY_HAND->create_money_array(
            ROOM_RENTAL_HANDLER.query_rental_value( room ), query_domain() ),
            query_domain() )
            ob.add_succeeded_mess( self, ["$N $V a room.\n", ""],
            [}) )
            return 1
            case RENTAL_NO_SUCH_ROOM:
            ob->add_failed_mess( self, "There is no such room here.\n",
            [}) )
            return 0
            case RENTAL_ALREADY_RENTED:
            ob->add_failed_mess( self, "The room has already been rented.\n",
            [}) )
            return 0
            case RENTAL_NO_MONEY:
            ob->add_failed_mess( self, "You don't have enough money for "
            "that.\n", [}) )
            return 0
            default:
            ob->add_failed_mess( self, "Something has gone wrong.  Please "
            "contact a creator.\n", [}) )
            return 0


    def init_dynamic_arg(self, map: Any, ob: MudObject) -> None:
            _domain = map[ "domain" ]
            _location = map[ "location" ]


    def debug_log(self, fmt: str, args: Any) -> None:
            debug_printf(fmt + "\n", args ...)
            #ifdef DISABLED
            if(base_name(self) == "/d/cwc/Bes_Pelargic/Shoo_Li/roads/pang_ho_street/housing/03flat") {
            log_file("HOUSING_DEBUG", "%s (%s): " + fmt + "\n",
            ctime(time())[4..18], base_name(self), args ...)


    def __init__(self):
            self._save_file = ""
            self.details = ([ ])
            self._last_saved = time()


    def set_save_file(self, file: str) -> None:
            #ifdef USE_RAMDISK
            string *bits, fname
            int i
            #endif
            _save_file = file
            #ifdef USE_RAMDISK
            if(strsrch(_save_file, "/save/player_housing") != -1) {
            _ram_file = replace_string(_save_file, "/save/player_housing",
            "/save/ramdisk/player_housing")
            fname = ""
            bits = explode(_ram_file, "/")
            for(i=0; i<sizeof(bits)-1; i++) {
            fname += "/" + bits[i]
            if(file_size(fname) == -1) {
            debug_printf("Creating %s", fname)
            mkdir(fname)


    def query_save_file(self, ) -> str:
            return _save_file


    def event_save(self, thing: MudObject) -> None:
            if(!thing || !_inventory_loaded || !_save_file || _save_file == "") {
            if(find_asyncio.create_task(self."do_save") != -1)
            remove_asyncio.create_task(self."do_save")
            return


    def door_action(self, ) -> None:
            if(_door_opened || _door_unlocked) {
            event_save(self)
            #ifdef DEBUG_SAVE
            debug_log("saving opened %d unlocked %d", _door_opened,
            _door_unlocked)
            } else {
            debug_log("not saving %s door has returned "
            "to original state.\n", base_name(self))
            #endif


    def event_open(self, door: MudObject, opener: MudObject) -> None:
            _door_opened++
            if(find_asyncio.create_task(self."door_action") != -1)
            remove_asyncio.create_task(self."door_action")
            asyncio.create_task(self."door_action", 5)


    def event_close(self, door: MudObject, closer: MudObject) -> None:
            _door_opened--
            if(find_asyncio.create_task(self."door_action") != -1)
            remove_asyncio.create_task(self."door_action")
            asyncio.create_task(self."door_action", 5)


    def event_unlock(self, door: MudObject, unlocker: MudObject) -> None:
            debug_printf("Event unlock called %O", door)
            _door_unlocked++
            if(find_asyncio.create_task(self."door_action") != -1)
            remove_asyncio.create_task(self."door_action")
            asyncio.create_task(self."door_action", 5)


    def event_lock(self, door: MudObject, locker: MudObject) -> None:
            debug_printf("Event lock called %O", door)
            _door_unlocked--
            if(find_asyncio.create_task(self."door_action") != -1)
            remove_asyncio.create_task(self."door_action")
            asyncio.create_task(self."door_action", 5)


    def do_save(self, ) -> None:
            int saved
            #ifdef DEBUG_SAVE
            object ob
            #endif
            remove_asyncio.create_task(self."do_save")
            if(!_save_file || _save_file == "") {
            #ifdef DEBUG_SAVE
            log_file("ROOM_SAVE", "%s no save file for %s\n", ctime(time())[4..18],
            base_name(self))
            #endif
            return


    def do_load(self, thing: MudObject) -> None:
            mapping tmp
            string fname
            if(_save_file) {
            if(_ram_file &&
            (file_size(_ram_file + ".o.gz") > 0 || file_size(_ram_file + ".o") > 0))
            fname = _ram_file
            else
            fname = _save_file
            if(file_size(fname + ".o.gz") > 0 || file_size(fname + ".o") > 0) {
            tmp = self.query_properties()
            unguarded((: restore_object, fname :))
            self.set_properties(tmp)
            if ( sizeof( details ) ) {
            init_dynamic_arg( details )
            } else {
            _inventory_loaded = 1


    def test_remove(self, thing: MudObject, flag: int, dest: Any) -> int:
            if(test_save(thing))
            event(self, "save", thing)
            return 1


    def test_add(self, ob: MudObject, flag: int) -> int:
            if(!query_auto_loading() && test_save(ob))
            event(self, "save", ob)
            return 1


    def query_prevent_insert(self, ) -> int:
            mapping query_dynamic_auto_load() {
            mapping map
            string *obs
            map = ([ ])
            #ifdef DISABLED
            if ( _effects ) {
            if ( sizeof( (mixed *)_effects.query_effs() ) ) {
            _effects.effect_freeze()
            _effects.effects_saving()
            map += ([
            "effects" : ({
            (mixed *)_effects.query_effs(),
            (int *)_effects.query_eeq()
            })
            ])
            _effects.effect_unfreeze()


    def init_dynamic_arg(self, bing: Any) -> None:
            #ifdef DEBUG_INVENTORY
            object ob
            log_file(base_name(self) + ".log",
            "%s Loading.\n", ctime(time())[4..18])
            #endif
            if ( !mapp( bing ) ) {
            #ifdef DEBUG_INVENTORY
            log_file(base_name(self) + ".log",
            "%s no mapping to load.\n", ctime(time())[4..18])
            #endif
            return


    def check_euid(self, ) -> None:
            if ( previous_object() ) {
            seteuid( geteuid( previous_object() ) )


    def dest_me(self, ) -> None:
            if(find_asyncio.create_task(self."do_save") != -1)
            do_save()


    def query_inventory_loaded(self, ) -> int:
            ==================================================
            FILE: room/inherit/scripting.c
            ==================================================
            inherit "/std/basic/expressions"
            #define SCRIPTING_WAIT_COMMAND  1
            #define SCRIPTING_COMMAND       2
            #define SCRIPTING_EXPRESSION    3
            #define SCRIPTING_GOTO          4
            #define SCRIPTING_TRIGGER_EVENT 5
            class script_data {
            int type
            string actor
            string str
            class parse_node* expr
            int number


    def event_save(self, ob: MudObject) -> None:
            class script query_script( string name ){
            return _script_data[name]


    def trigger_script(self, event: str, who: MudObject, override: int) -> None:
            int i
            class script this_script
            class running_script running
            this_script = query_script( event )
            if (!this_script || !objectp(who)) {
            return


    def repeat_loop(self, ) -> None:
            object npc
            class script_data data
            string str
            class parse_node node
            if (!sizeof( _running_scripts ) ) {
            return


    def set_script(self, name: str, script: Any) -> None:
            _script_data[name] = script
            event_save(self)


    def set_script_data(self, name: str, script_data: Any) -> None:
            if (_script_data[name]) {
            _script_data[name]->data = data
            event_save(self)


    def set_script_actors(self, name: str, actors: Any) -> None:
            if (_script_data[name]) {
            _script_data[name]->actors = actors
            event_save(self)


    def set_script_data_location(self, name: str, pos: int, script_data: Any) -> int:
            if (_script_data[name] &&
            pos >= 0 && pos < sizeof(_script_data[name]->data)) {
            _script_data[name]->data[pos] = data
            event_save(self)
            return 1


    def delete_script_data_location(self, name: str, pos: int) -> int:
            if (_script_data[name] &&
            pos >= 0 && pos < sizeof(_script_data[name]->data)) {
            _script_data[name]->data = _script_data[name]->data[0..pos-1] +
            _script_data[name]->data[pos+1..]
            event_save(self)
            return 1


    def insert_script_data_before(self, name: str, pos: int, script_data: Any) -> int:
            if (_script_data[name]) {
            _script_data[name]->data = _script_data[name]->data[0..pos-1] +
            [data] +
            _script_data[name]->data[pos..]
            event_save(self)
            return 1


    def menu_prompt(self, name: str, script: Any) -> None:
            tell_object( this_player(), "Enter the name of the person who should "
            "perform an action ( or another command such as \"wait\" ).\n" )
            print_commands()
            input_to( "menu_input", 0, name, script )


    def menu_input(self, input: str, name: str, script: Any) -> None:
            string* bits
            bits = explode(lower_case(input), " ")
            switch (lower_case(bits[0])) {
            case "h" :
            case "help" :
            show_help()
            break
            case "s" :
            case "save" :
            set_script(name, script)
            break
            case "q" :
            case "quit" :
            write("Are you sure you want to quit and "
            "lose the current script?\n" )
            input_to( "check_quit", 0, name, script )
            return
            case "l" :
            case "list" :
            write(query_script_string(script))
            break
            case "a" :
            case "add" :
            if (sizeof(bits) != 3) {
            write("Syntax: add <person> <pos|end|begining>\n")
            } else if (lower_case(bits[1]) != "wait" &&
            script->actors.index(bits[1]) if bits[1] in script->actors else -1 == -1) {
            write("The actor must be one of " +
            query_multiple_short(script->actors)  + " not " +
            bits[1] + ".\n")
            } else {
            pos = query_pos_from_string(bits[2])
            if (pos != -1) {
            write("Which command do you want to execute for " + bits[1] +
            "?\n: ")
            input_to("enter_command", 0, name, script, bits[1], pos)
            } else {
            write("The position must be in the range 0.." +
            sizeof(script->data) + " or 'begining' or 'end'.\n")


    def print_commands(self, ) -> None:
            await  this_player().send("Command [ h for help ]:\n" )


    def show_help(self, ) -> None:
            string str
            str = unguarded((: NROFF_HAND.cat_file("/doc/room/scripting_nroff", 1) :))
            if(!str){
            unguarded((: NROFF_HAND->create_nroff(PATH +"scripting_online_help",
            PATH +"scripting_nroff") :))
            str = unguarded((:NROFF_HAND.cat_file(PATH +"scripting_nroff", 0):))


    def query_quit(self, input: str, func: str) -> None:
            if( (input == "y") || (input == "yes") || (input == "Y") ){
            write("Okay, quitting.\n" )
            }else{
            write("%^BOLD%^You did not enter \"y\" "
            "or \"yes\" so you are not being quitted.%^RESET%^\n" )
            call_other( self, func )


    def set_script(self, name: str, scripting: Any) -> None:
            write("Saving current script and exiting.\n" )
            _scripts[name] = script
            event_save( self )


    def query_script_string(self, scripting: Any) -> str:
            int i
            string str
            if( _temp_script->tag == "" ) {
            return


    def query_delete(self, input: str, num: int) -> None:
            if( (input == "y") || (input == "yes") || (input == "Y") ){
            await  this_player().send("Okay, removing script.\n" )
            if( sizeof(_script_data) == 1 ){
            _script_data = ({})
            }else if( sizeof(_script_data) == 2 ){
            _script_data = ({_script_data[!num]})
            }else{
            if( !num ){
            _script_data = _script_data[1..]
            }else{
            _script_data = _script_data[0..(num - 1)] +
            _script_data[(num + 1)..]


    def get_index(self, input: Any) -> int:
            int i
            if( to_int( input ) ){
            i = to_int( input )
            if( i > sizeof(_script_data) ){
            await  this_player().send("Invalid option, quitting.\n" )
            return -1
            }else{
            return i - 1


    def edit_script(self, input: str, which: int) -> None:
            string *comm, command, text
            int line, i
            if( input == "" ){
            input_to( "edit_script", 0, which )
            await  this_player().send("Command [ R(eplace), D(elete), "
            "I(nsert), V(iew), S(ave), Q(uit) ]:\nEg \"R 13 rabbit\".\n" )
            return


    def do_add_script(self, input: str) -> int:
            if( input == "" ){
            tell_object( this_player(),
            "You must enter a name for the script.\n" )
            add_succeeded_mess( "" )
            return 1


    def do_list_scripts(self, ) -> int:
            int i
            if( !sizeof(_script_data) ){
            this_player()->add_failed_mess( self,
            "No scripts found.\n" )
            return 0


    def do_view_script(self, input: Any) -> int:
            int num
            num = get_index( input )
            if( num == -1 ){
            add_succeeded_mess( "" )
            return 1


    def do_test_script(self, input: Any) -> int:
            int num
            num = get_index( input )
            if( num == -1 ){
            add_succeeded_mess( "" )
            return 1


    def do_delete_script(self, input: Any) -> int:
            int num
            num = get_index( input )
            if( num == -1 ){
            add_succeeded_mess( "" )
            return 1


    def do_edit_script(self, input: Any) -> int:
            int num, i
            num = get_index( input )
            if( num == -1 ){
            add_succeeded_mess( "" )
            return 1


    def init(self, ) -> None:
            if( !is_allowed( this_player()->query_name() ) ) {
            return


    def __init__(self):
            self._x_coord = -1
            self._y_coord = -1


    def setup_room(self, ) -> None:
            add_extra_look(self)
            setup_room_chat()


    def set_coords(self, x: int, y: int) -> None:
            {
            _x_coord = x
            _y_coord = y


    def init(self, ) -> None:
            {
            tell_creator(this_player(), "Coords: (%d, %d)\n", _x_coord, _y_coord)
            if (this_player()->query_creator()) {
            add_command("gocoords", "<number'x'> <number'y'>", (: do_gocoords($4[0], $4[1]) :))


    def query_map_handler(self, ) -> MudObject:
            {
            return _map_handler


    def do_gocoords(self, x: int, y: int) -> int:
            {
            object   room = query_map_handler()->load_room_at(x, y)
            string   msgin = this_player()->query_mmsgin()
            string   msgout = this_player()->query_mmsgout()
            if (!room) {
            this_player()->add_failed_mess(self,
            "No room at those coordinates.\n", [}))
            return 0


    def reset_handler(self, ) -> None:
            {
            if (query_map_handler())
            query_map_handler()->reset_handler()


    def receive_message(self, mess_class: str, message: str) -> None:
            {
            string   *bits = explode(mess_class, ":")
            mapping  feature
            int      range = -1
            if (bits[0] == "feature") {
            feature = _features[bits[1]]
            if (!feature)
            return
            if (sizeof(bits) >= 3)
            range = to_int(bits[2])
            if ((range >= 0) && (range != feature["range"]))
            return
            message = replace(message, ["$D", feature["direc"]])


    def do_a_feature_chat(self, ) -> None:
            {
            string   *chats = [})
            string   feature_chat
            string   title
            mapping  feature
            object   handler = query_map_handler()
            foreach(title, feature in _features) {
            feature_chat = handler->get_a_feature_chat(title, feature["range"],
            feature["direc"])
            if (feature_chat) {
            chats += [feature_chat]


    def do_an_outside_chat(self, ) -> None:
            {
            string chat = query_map_handler()->get_an_outside_chat(_outside_types)
            if (chat && strlen(chat))
            tell_room(self, chat + "\n")


    def set_map_handler(self, handler: Any) -> None:
            {
            if (objectp(handler))
            _map_handler = handler
            else
            _map_handler = load_object(handler)


    def can_view_feature(self, type: str) -> int:
            {
            return 1


    def can_exit_to(self, type: str) -> int:
            {
            return 1


    def can_enter_from(self, type: str) -> int:
            {
            return 1


    def do_outside_chats(self, ) -> int:
            {
            return 1


    def make_chat(self, ) -> None:
            {
            if (query_chatter()) {
            query_chatter()->make_chat()


    def set_extra_long(self, extra: str) -> None:
            {
            _extra_long = extra


    def set_outside_types(self, types: str) -> None:
            {
            _outside_types = types


    def extra_look(self, ) -> str:
            {
            string   result = _extra_long
            string   title
            mapping  feature
            foreach (title, feature in _features) {
            result += query_map_handler()->query_feature_desc(title, feature["range"],
            feature["direc"]) + "\n"


    def query_room(self, room_path: str) -> Any:
            {
            string   *bits = explode(room_path, ":")
            object   room
            object   handler
            if (sizeof(bits) < 3)
            return room_path
            room = load_object(bits[0])
            handler = room.query_map_handler()
            return handler.query_room(room_path)


    def add_feature(self, title: str, direc: str, range: int, items: Any) -> None:
            {
            _features[title] = (["direc":direc, "range":range, "items":items])
            add_item(items, (: query_feature_item_desc($(title)) :))


    def remove_feature(self, title: str) -> None:
            {
            mapping  feature = _features[title]
            mixed    items
            if (!feature)
            return
            map_delete(_features, title)
            items = feature["items"]
            if (stringp(items))
            remove_item(items)
            else
            remove_item(items[0])


    def query_feature_range(self, title: str) -> int:
            {
            mapping   feature = _features[title]
            if (!feature)
            return -1
            return feature["range"]


    def query_feature_item_desc(self, title: str) -> str:
            {
            return query_map_handler()->query_feature_item_desc(title)


    def login_restore(self, name: str, l_event: str) -> None:
            {
            object player
            string path = explode(file_name(self), "#")[0]
            int    *coords, x, y
            if (l_event != LOGIN)
            return
            player = find_player(name)
            if (!player)
            return
            coords = player.query_property("area_map_coords")
            player.remove_property("area_map_coords")
            if (!coords)
            return
            x = coords[0]
            y = coords[1]
            LOGIN_HANDLER.remove_static_login_call(name, "login_restore", path)
            player.move(query_map_handler()->load_room_at(x, y))


    def event_quit(self, player: MudObject) -> None:
            {
            string name
            string path = explode(file_name(self), "#")[0]
            if (!player)
            return
            if (!interactive(player))
            return
            if ((_x_coord < 0) || (_y_coord < 0))
            return
            name = player.query_name()
            player.add_property("area_map_coords", query_coords())
            LOGIN_HANDLER.add_static_login_call(name, "login_restore", path)


    def set_installed(self, ) -> None:
            ==================================================
            FILE: room/inherit/voting_room.c
            ==================================================
            #define DEFAULT_VOTE_DURATION (2600*24*7)
            class vote {
            string type
            string desc
            string *choices
            mixed *votes
            int ending
            string *voted


    def __init__(self):
            self.votes = ([ ])
            self.elections = ([ ])


    def init(self, ) -> None:
            add_command("vote", "<string> on <number>", (: cast_vote($4[0], $4[1]) :) )
            add_command("list", "votes", (: list_votes :))
            add_command("votes", "", (: list_votes :))
            if (!_no_elections) {
            add_command( "stand", "[for] <string>", (: stand_for_election($4[0]) :))
            add_command( "second", "<string> [for] <string>",
            (: second_candidate($4[0], $4[1]) :) )
            add_command("list", "elections", (: list_elections :))
            add_command("elections", "", (: list_elections :))


    def init_add_vote(self, ) -> None:
            add_command( "add", "vote with <string'choices'>",
            (: do_create_vote($4[0]) :))


    def setup_after_load(self, ) -> None:
            int i
            string election
            int *vote_ids
            if (_proxy) {
            return


    def set_save_file(self, file: str) -> None:
            _vote_file = file
            if( file_size( _vote_file + ".o" ) > 0 ) {
            unguarded( (: restore_object, _vote_file :) )
            setup_after_load()
            } else {
            elections = ([ ])
            votes = ([ ])


    def query_save_file(self, ) -> str:
            protected void save_room() {
            if (_vote_file) {
            unguarded( (: save_object, _vote_file :) )


    def set_proxy(self, proxy: str) -> None:
            _proxy = proxy


    def set_no_elections(self, no_elections: int) -> None:
            _no_elections = no_elections


    def set_open_voting(self, open: int) -> None:
            _open_voting = open


    def query_open_voting(self, open: int) -> int:
            return _open_voting


    def query_vote_duration(self, ) -> int:
            if (!_vote_duration) {
            return DEFAULT_VOTE_DURATION


    def set_second_conditions(self, cond: Any) -> None:
            void set_election_announcement(string board, string person, string subject,
            string prefix, string suffix) {
            _election_announcement = [board, person, subject, prefix, suffix]


    def cast_vote(self, which_str: str, vote_id: int) -> int:
            string pname
            int which, ok
            class vote this_vote
            if (_proxy) {
            return _proxy.cast_vote(which_str, vote_id)


    def list_votes(self, ) -> int:
            int i, j, *vote_ids
            string text
            class vote this_vote
            if ( !m_sizeof( query_our_votes() ) ) {
            write( "There are no votes in progress.\n" )
            return 1


    def add_vote(self, type: str, description: str, choices: str, ending: int) -> None:
            class vote new_vote
            if (_proxy) {
            return _proxy.add_vote(type, description, choices, ending)


    def end_vote(self, which: int) -> None:
            if ( !query_our_votes()[ which ] ) {
            return


    def initiate_election(self, position: str) -> None:
            class election tmp
            if (_proxy) {
            return _proxy.initiate_election(position)


    def query_election_in_progress(self, position: str) -> int:
            if (classp(query_our_elections()[position])) {
            return 1


    def stand_for_election(self, position: str) -> int:
            int ok, i
            if (_proxy) {
            return _proxy.stand_for_election(position)


    def second_candidate(self, who: str, position: str) -> int:
            mixed *candidates
            int i, found, ok
            if (_proxy) {
            return _proxy.second_candidate(who, position)


    def start_election_vote(self, post: str) -> None:
            string str, *choices
            int i
            if(!query_our_elections()[post])
            return
            if(_election_announcement[3])
            str = _election_announcement[3]
            else
            str = "All eligible persons are requested to vote for the position of "
            str += post + "\n\nThe candidates are:\n"
            choices = [})
            for(i=0; i<sizeof(query_our_elections()[post]->candidates); i++) {
            if(query_our_elections()[post]->candidates[i][1] != "") {
            str += sprintf("  %s seconded by %s.\n",
            query_our_elections()[post]->candidates[i][0],
            query_our_elections()[post]->candidates[i][1])
            choices += [query_our_elections()[post]->candidates[i][0]]


    def list_elections(self, ) -> int:
            class election this_election
            string *posts, text
            int i, j
            if ( !m_sizeof( query_our_elections() ) ) {
            write( "There are no elections in progress.\n" )
            return 1


    def strip_spaces(self, str: str) -> str:
            if (!strlen(str)) {
            return str


    def do_create_vote(self, choices: str) -> int:
            string* bits
            bits = map(explode(choices, ","), (: strip_spaces($1) :)) - [""]
            write("Choices: " + query_multiple_short(bits) + ".\n")
            write("What description would you like for your vote?\n")
            this_player()->do_edit("", "create_vote_desc", self, 0, bits)
            add_succeeded_mess(["", "$N starts to create a new vote.\n"])
            return 1


    def create_vote_desc(self, str: str, choices: Any) -> None:
            if (!str) {
            write("Aborting.\n")
            return


    def create_vote_desc_confirm(self, str: str, desc: str, choices: Any) -> None:
            str = lower_case(str)
            if (!strlen(str) ||
            (str[0] != 'y' && str[0] != 'n' && str[0] != 'q')) {
            write("Please answer yes or no: ")
            input_to("create_vote_desc_confirm", 0, str, choices)


    def delete_election(self, election: str) -> int:
            if(!query_our_elections()[election])
            return 0
            map_delete(query_our_elections(), election)
            save_room()
            return 1


    def delete_vote(self, vote_id: int) -> int:
            if(!query_our_votes()[vote_id])
            return 0
            map_delete(query_our_votes(), vote_id)
            save_room()
            return 1


    def query_quit_handler(self, ) -> Any:
            string s
            s = explode(file_name(environment(this_player())), "#")[0]
            return [s, query_co_ord()]


    def enter(self, player: MudObject) -> None:
            object new_room
            if (sizeof(explode(file_name(self), "#")) > 1) {
            return


    def query_look(self, direc: str, other_result: str) -> str:
            int dark
            string s
            string direc_s
            mixed dest
            direc_s = direc
            if (other_result) {
            return s


    def add_topo_exits(self, other_exits: str, other_types: str) -> None:
            string s
            foreach (s in other_exits) {
            if ((s == "compass4") || (s == "compass8")) {
            if (!query_exit("north")) {
            add_exit("north", "/topography", other_types)


    def add_milestone_dir(self, s: str) -> None:
            int i
            string ss, em, xm, mm
            i = sizeof(milestone_dirs)
            milestone_dirs += [s]
            if (!(iroom_handler)->query_endpoint(milestone_index[0],
            milestone_index[1], i)) {
            modify_exit(s, ["function", "passing_mess"] )


    def passing_mess(self, dir: str, ob: MudObject, special_mess: str) -> int:
            int i
            object *obs, passed
            string mess1, mess2
            i = milestone_dirs.index(dir) if dir in milestone_dirs else -1
            if (i < 0) {
            return 0


    def query_quit_handler(self, ) -> Any:
            string s
            s = explode(file_name(environment(this_player())), "#")[0]
            return [s, query_co_ord()]


    def enter(self, player: MudObject) -> None:
            object new_room
            if (sizeof(explode(file_name(self), "#")) > 1) {
            return


    def query_look(self, direc: str) -> str:
            int i, dark
            string s, direc_s
            mixed dest
            direc_s = direc
            i = milestone_dirs.index(direc_s) if direc_s in milestone_dirs else -1
            if (i >= 0) {
            direc_s = motion_verb + " " + direc_s


    def add_topo_exits(self, e: str, type: str) -> None:
            other_exits += [e]
            other_types += [type]


    def add_topo_exits_int(self, ) -> None:
            int i
            string s
            for (i = 0; i < sizeof(other_exits); i++) {
            foreach (s in other_exits[i]) {
            if ((s == "compass4") || (s == "compass8")) {
            if (!query_exit("north")) add_exit("north", "/topography",
            other_types[i])
            if (!query_exit("south")) add_exit("south", "/topography",
            other_types[i])
            if (!query_exit("east")) add_exit("east", "/topography",
            other_types[i])
            if (!query_exit("west")) add_exit("west", "/topography",
            other_types[i])
            if (s == "compass8") {
            if (!query_exit("northeast")) add_exit("northeast", "/topography",
            other_types[i])
            if (!query_exit("northwest")) add_exit("northwest", "/topography",
            other_types[i])
            if (!query_exit("southeast")) add_exit("southeast", "/topography",
            other_types[i])
            if (!query_exit("southwest")) add_exit("southwest", "/topography",
            other_types[i])


    def add_milestone_dir(self, handler: str, dir: str) -> None:
            if (undefinedp(milestone_dirs[handler])) {
            milestone_dirs[handler] = [dir]
            } else {
            milestone_dirs[handler] += [dir]


    def query(self, s): str) -> Any:
            varargs void set_milestone_index(string handler, int index) {
            milestone_index[handler] = index


    def setup_milestone(self, ) -> None:
            string handler
            foreach (handler in keys(milestone_index)) {
            handler.setup_milestone(self)


    def add_milestone_exit(self, s: str, dest: str, type: str) -> int:
            string ss, em, xm, mm
            add_exit(s, dest, type)
            add_exit(motion_verb + " " + s, "interroom", "hidden")
            if (!undefinedp(shorten[s])) {
            ss = shorten[s]
            add_alias(motion_verb + " " + ss, motion_verb + " " + s)
            } else {
            ss = s


    def passing_mess(self, dir: str, ob: MudObject, special_mess: str) -> int:
            int i
            object *obs, passed
            string mess1, mess2, handler
            foreach (handler in keys(milestone_dirs)) {
            i = milestone_dirs[handler].index(dir) if dir in milestone_dirs[handler] else -1
            if (i < 0) {
            continue


    def query_look(self, direc: str) -> str:
            int i, dark
            string s, direc_s, h
            mixed dest
            direc_s = direc
            foreach (h in keys(milestone_dirs)) {
            i = milestone_dirs[h].index(direc_s) if direc_s in milestone_dirs[h] else -1
            if (i >= 0) {
            direc_s = motion_verb + " " + direc_s
            break


    def add_topo_exits(self, e: str, type: str) -> None:
            other_exits += [e]
            other_types += [type]


    def add_topo_exits_int(self, ) -> None:
            int i
            string s
            for (i = 0; i < sizeof(other_exits); i++) {
            foreach (s in other_exits[i]) {
            if ((s == "compass4") || (s == "compass8")) {
            if (!query_exit("north")) add_exit("north", "/topography",
            other_types[i])
            if (!query_exit("south")) add_exit("south", "/topography",
            other_types[i])
            if (!query_exit("east")) add_exit("east", "/topography",
            other_types[i])
            if (!query_exit("west")) add_exit("west", "/topography",
            other_types[i])
            if (s == "compass8") {
            if (!query_exit("northeast")) add_exit("northeast", "/topography",
            other_types[i])
            if (!query_exit("northwest")) add_exit("northwest", "/topography",
            other_types[i])
            if (!query_exit("southeast")) add_exit("southeast", "/topography",
            other_types[i])
            if (!query_exit("southwest")) add_exit("southwest", "/topography",
            other_types[i])


    def __init__(self):


    def init(self, ) -> None:
            terrain_room::init()
            outside::init()


    def stats(self, ) -> Any:
            return outside::stats() + terrain_room::stats()


    def query_distance_str(self, dist: int) -> str:
            return query_distance_str_int(dist, 1)


    def query_distance_str_no_ones(self, dist: int) -> str:
            return query_distance_str_int(dist, 0)


    def __init__(self):


    def __init__(self):
            self._adjacent_items = ([ ])


    def set_room_jump_size(self, jump: int) -> None:
            _room_jump_size = jump


    def query_room_jump_size(self, ) -> int:
            return _room_jump_size


    def set_follow_road(self, follow: int) -> None:
            _follow_road = follow


    def query_follow_road(self, ) -> int:
            return _follow_road


    def set_default_height(self, height: int) -> None:
            _default_height = height


    def set_adjacent_description(self, desc: str) -> None:
            _adjacent_desc = desc


    def query_adjacent_description(self, ) -> str:
            return _adjacent_desc


    def query_default_height(self, ) -> int:
            return _default_height


    def set_minimum_height(self, height: int) -> None:
            _min_height = height


    def query_minimum_height(self, ) -> int:
            return _min_height


    def set_height_rooms(self, map: Any) -> None:
            _height_info = map


    def find_base_terrain_room(self, x: int, y: int, z: int, base_name: str, map_room: int, ref: str) -> str:
            if (_height_info && _height_info[z]) {
            return _height_info[z]


    def add_adjacent_item(self, name: str, desc: str) -> None:
            _adjacent_items[name] = desc


    def stats(self, ) -> Any:
            return ({
            ["room jump", _room_jump_size],
            ["follow road", _follow_road],
            ["adjacent desc", _adjacent_desc]]


    def set_region(self, region: Any) -> None:
            if (_region) {
            _region.dest_me()


    def query_region_ob(self, ) -> MudObject:
            return _region


    def set_range_offset(self, offset: int) -> None:
            _range_offset = offset


    def query_range_offset(self, ) -> int:
            return _range_offset


    def set_max_day_range(self, range: int) -> None:
            _max_day_range = range
            if (_max_day_range > _max_range) {
            _max_range = _max_day_range


    def query_max_day_range(self, ) -> int:
            return _max_day_range


    def set_max_night_range(self, range: int) -> None:
            _max_night_range = range
            if (_max_night_range > _max_range) {
            _max_range = _max_night_range


    def query_max_night_range(self, ) -> int:
            return _max_night_range


    def set_min_range(self, range: int) -> None:
            _min_range = range


    def query_min_range(self, ) -> int:
            return _min_range


    def query_max_range(self, ) -> int:
            return _max_range


    def set_blocking(self, blocking: int) -> int:
            _blocking = blocking


    def query_blocking(self, ) -> int:
            return _blocking


    def calc_feature_desc(self, direc: Any, night: int, visibility: int) -> str:
            return "This needs to be set."


    def is_inside_region(self, x1: int, y1: int, x2: int, y2: int) -> int:
            return _region.is_inside_region(x1, y1, x2, y2, query_max_range())


    def dest_me(self, ) -> None:
            if (_region) {
            _region.dest_me()


    def __init__(self):
            self._items = []
            self._night_descs = []
            self._day_descs = []


    def add_item(self, item: str, day: str, night: str) -> None:
            _items += [item]
            _night_descs += [night]
            _day_descs += [day]


    def set_real_coordinates_no_inform(self, x1: int, y1: int, x2: int, y2: int) -> None:
            int tmp
            if (x1 > x2) {
            tmp = x1
            x1 = x2
            x2 = tmp


    def set_real_coordinates(self, x1: int, y1: int, x2: int, y2: int) -> None:
            set_real_coordinates_no_inform(x1, y1, x2, y2)
            _real_coords->in_world_map = TERRAIN_MAP_WORLD_MAP.add_terrain(base_name(self),
            _real_coords->x1, _real_coords->y1,
            _real_coords->x2, _real_coords->y2)


    def set_real_offsets(self, xoff: int, yoff: int, zoff: int) -> None:
            _real_coords = new(class real_coords)
            _real_coords->xdiff = xoff
            _real_coords->ydiff = yoff
            _real_coords->xydiff = to_int(sqrt(to_float(_real_coords->xdiff) * to_float(_real_coords->xdiff)+
            to_float(_real_coords->ydiff) * to_float(_real_coords->ydiff)))


    def set_newline_mode(self, mode: int) -> None:
            {
            _newline_mode = mode


    def set_visible_distance(self, distance: int) -> None:
            _visible_distance = distance


    def query_visible_distance(self, ) -> int:
            return _visible_distance


    def __init__(self):


    def setup_area_map(self, ) -> None:
            {
            int   index
            load_area_map()
            load_zone_map()
            if (!arrayp(_room_map)) {
            _room_map = [})
            for (index = 0; index < _width; index++)
            _room_map += [allocate(_width)]


    def query_feature_ob(self, name: str) -> MudObject:
            return _features[name]->feature_ob


    def add_signposts(self, room: MudObject) -> None:
            {
            class sign_data sign
            int     *coords = room.query_terrain_coords()
            int     x = coords[0]
            int     y = coords[1]
            string  title = sprintf("%d:%d", x, y)
            object  sign_ob
            sign = _signposts[title]
            if (!sign) {
            return


    def setup_zones(self, room: MudObject) -> None:
            {
            string  *zones
            int     *coords = room.query_terrain_coords()
            int     x = coords[0]
            int     y = coords[1]
            string  type
            string  zone
            if (!sizeof(_zone_map)) {
            return


    def calc_random_descs(self, room: MudObject, key: str) -> None:
            {
            int      limit = _random_desc_limit
            int      *indices = [})
            int      *coords = room.query_terrain_coords()
            int      seed = (coords[0] * 2) + coords[1]
            mapping  desc
            mixed    *descs = _random_descs[key]
            int      index
            if (limit > sizeof(descs)) {
            limit = sizeof(descs)


    def calc_random_chats(self, room: MudObject, key: str) -> None:
            {


    def query_dest_coordinate_string(self, x: int, y: int, z: int, direc: str, key: str) -> str:
            class char_map_data  room_setup
            room_setup = query_char_map(x, y)
            if (room_setup->type == AREA_WORLD) {
            return room_setup->path.query_dest_coordinate_string(x, y, z, direc, key)


    def query_ground_room_co_ords(self, x: int, y: int) -> List[int]:
            class char_map_data  room_setup
            room_setup = query_char_map(x, y)
            return [x, y, room_setup->height]


    def query_ground_room(self, x: int, y: int) -> str:
            int* co_ords
            co_ords = query_ground_room_co_ords(x, y)
            return base_name(self) + ":" + co_ords[0] + ":" + co_ords[1] + ":" + co_ords[2]


    def query_climb_base_room(self, x: int, y: int, z: int, map_room: int, ref: str) -> str:
            class char_map_data  room_setup
            string *tmp
            room_setup = query_char_map(x, y)
            if (!room_setup) {
            return 0


    def query_base_room(self, x: int, y: int, z: int, map_room: int) -> str:
            string dest
            dest = "bing"
            return query_climb_base_room(x, y, z, map_room, ref dest)


    def setup_room(self, room: MudObject, base_path: str) -> None:
            {
            string main_base
            string base
            int      *room_coords = room.query_terrain_coords()
            mixed    *coords
            int      x
            int      y
            string   direc
            class char_map_data  room_setup
            string*  dirs
            mapping  adjacent_descs = ([ ])
            mapping  adjacent_sent = ([ ])
            mapping  distant
            string   adjacent
            string   key
            string   room_long = ""
            string   key_here
            mixed    *exit_mods
            object   new_room
            string   outside_types = ""
            mixed    *exits
            mapping  exit
            string   *sentances
            mixed   tmp
            int z
            int road_jump
            class coord fluff
            string* miss_road
            mapping ignore_exits
            string  walk_pre
            string  walk_full
            string  journey_pre
            string  new_base_path
            if (!arrayp(room_coords)) {
            debug_printf("Unable to find room coordinates from %O\n", file_name(room))
            return


    def find_adjacent_terrain(self, x: int, y: int) -> str:
            {
            string index
            class coord real
            if (!_real_coords || !_real_coords->in_world_map) {
            return 0


    def find_all_adjacent_terrains(self, ) -> None:
            find_adjacent_terrain(-1,-1)
            find_adjacent_terrain(-1,0)
            find_adjacent_terrain(-1,40)
            find_adjacent_terrain(0,40)
            find_adjacent_terrain(40,40)
            find_adjacent_terrain(40,0)
            find_adjacent_terrain(40,-1)
            find_adjacent_terrain(0,-1)


    def add_room_to_zone(self, room: MudObject, zone: str) -> None:
            {
            object *zones = _room_zones[zone]
            if (!zones)
            zones = [room]
            else if (zones.index(room) if room in zones else -1 == -1)
            zones += [room]
            _room_zones[zone] = zones - [0]


    def query_room(self, x: int, y: int, z: int) -> Any:
            {
            class char_map_data room_map = query_char_map(x, y)
            string base_path
            object room
            class coord real
            base_path = query_base_room(x, y, z, TERRAIN_MAP_ROOM_EXACT)
            if (!base_path) {
            return 0


    def query_room_at(self, x: int, y: int, z: int) -> MudObject:
            {
            if ((x < 0) || (y < 0) || (x >= _width) || (y >= _height))
            return 0
            return find_object(sprintf("%s:%d:%d:%d", base_name(self), x, y, z))


    def load_room_at(self, x: int, y: int, z: int) -> MudObject:
            {
            class char_map_data room_map = query_char_map(x, y)
            if (!room_map) {
            debug_printf("Unable to load room at %d %d\n", x, y)
            return 0


    def query_debug_map(self, x: int, y: int, width: int, showx: int, showy: int) -> str:
            int i
            int j
            int sx
            int sy
            int ny
            string ret
            string base
            string new_base
            string colour
            ret = ""
            sx = x - width / 2
            sy = y + width / 2
            for (j = 0; j < width; j++) {
            if (sy - j >= 0 && sy - j < _height) {
            for (i = 0; i < width; i++) {
            if (sx + i >= 0 && sx + i < _width) {
            if (sx +i == showx && sy - j == showy) {
            ret += "%^YELLOW%^" + _area_map[sy - j][sx + i..sx + i] +
            "%^RESET%^"
            colour = 0
            } else {
            if (colour) {
            ret += "%^RESET%^"
            colour = 0


    def query_debug_map_char(self, x: int, y: int) -> str:
            return _area_map[y][x..x]


    def query_debug_map_feature(self, name: str) -> str:
            int x
            int y
            class feature_data feature
            mixed data
            string ret
            int colour
            int found
            feature = _features[name]
            ret = ""
            colour = 0
            for (y = _height - 1; y >= 0; y--) {
            for (x = 0; x < _width; x++) {
            data = feature->feature_ob.query_feature_desc_from(x, y, 0, 1)
            found = sizeof(data)
            if (found) {
            if (!colour) {
            ret += "%^YELLOW%^"
            colour = 1


    def query_debug_map_feature_distant(self, feature: str) -> str:
            int x
            int y
            mixed data
            string ret
            int colour
            class coord fluff
            ret = ""
            colour = 0
            for (y = _height - 1; y >= 0; y--) {
            for (x = 0; x < _width; x++) {
            fluff = query_real_from_terrain_coord(x, y, 0)
            data = feature.query_feature_desc_from(fluff->x, fluff->y, fluff->z)
            if (data && sizeof(data)) {
            if (!colour) {
            ret += "%^YELLOW%^"
            colour = 1


    def query_player_map(self, x_c: int, y_c: int, z_c: int, visibility: int) -> str:
            string ret, item, base, current, *keys
            mixed *map, *colours
            mapping data, key, colour_key
            int i, j
            int distance
            distance = _visible_distance * visibility / 100
            if (!distance) {
            distance = 1


    def get_an_outside_chat(self, types: str) -> str:
            {
            class char_map_data   item
            string    *chats = [})
            int       index
            mixed     *item_chats
            for (index = 0; index < sizeof(types); index++) {
            item = _char_map[types[index..index]]
            if (!item) {
            continue


    def add_room_type(self, type: str, base_path: str) -> None:
            {
            _char_map[type] = new(class char_map_data,
            type: AREA_ROOM, path:base_path)


    def set_random_desc_limit(self, new_limit: int) -> None:
            {
            _random_desc_limit = new_limit


    def set_random_chat_limit(self, new_limit: int) -> None:
            {
            _random_chat_limit = new_limit


    def add_random_desc(self, types: str, description: str, items: Any, item_desc: Any) -> None:
            {
            int   index
            for (index = 0; index < sizeof(types); index++) {
            if (!_random_descs[types[index..index]])
            _random_descs[types[index..index]] = [})
            _random_descs[types[index..index]] += [([ "desc": description,
            "items":items, "item_desc":item_desc ])]


    def add_random_chat(self, types: str, chats: str) -> None:
            {
            int   index
            for (index = 0; index < sizeof(types); index++) {
            if (!_random_chats[types[index..index]])
            _random_chats[types[index..index]] = [})
            _random_chats[types[index..index]] += chats


    def set_external_chats(self, type: str, chats: Any) -> None:
            {
            if (!_char_map[type]) {
            return


    def add_feature_ob(self, title: str, feature: MudObject) -> None:
            if (_real_coords && _real_coords->xdiff) {
            feature.set_distance_multiplier(_real_coords->xdiff)


    def set_feature_chats(self, title: str, chats: Any, night_chats: Any) -> None:
            {
            if (!_features[title]) {
            return


    def remove_feature(self, title: str) -> None:
            {
            object room
            if (!_features[title]) {
            return


    def add_zones(self, type: str, zone_names: str) -> None:
            {
            _zone_types[type] = zone_names


    def reset_handler(self, ) -> None:
            {
            mixed *rooms
            if (arrayp(_room_map)) {
            foreach(rooms in _room_map) {
            rooms.dest_me()


    def load_zone_map(self, ) -> None:
            {
            string   map_path = query_map_file() + ".zones"
            int      index = 1
            string   line
            int      width
            int      height
            _zone_map = [})
            while (line = read_file(map_path, index++, 1)) {
            if (width < sizeof(line))
            width = sizeof(line)
            _zone_map += [line]


    def load_area_map(self, ) -> None:
            {
            string   map_path = query_map_file() + ".map"
            int      index = 1
            int      height
            string   line
            _area_map = [})
            while (line = read_file(map_path, index++, 1)) {
            if (sizeof(line)) {
            line = line[0..<2]
            if (_width < sizeof(line)) {
            _width = sizeof(line)


    def create_virtual_object(self, x_str: str, y_str: str, z_str: str) -> MudObject:
            {
            int x = to_int(x_str)
            int y = to_int(y_str)
            int z = to_int(z_str)
            if (!stringp(x_str) || !stringp(y_str) || !stringp(z_str)) {
            return 0


    def find_room_at_real_coord(self, x: int, y: int, z: int) -> str:
            class char_map_data room_map
            class coord our
            our = query_terrain_from_real_coord(x, y, z)
            if (!our) {
            return 0


    def query_direction_distance(self, dir: str) -> int:
            switch (_direcs[dir][3]) {
            case X_DIFF :
            return _real_coords->xdiff
            case Y_DIFF :
            return _real_coords->ydiff
            case XY_DIFF :
            return _real_coords->xydiff


    def dest_me(self, ) -> None:
            class feature_data womble
            string name
            foreach (name, womble in _features) {
            if (womble->feature_ob) {
            womble->feature_ob.dest_me()


    def __init__(self):


    def init(self, ) -> None:
            terrain_room::init()
            basic_room::init()


    def stats(self, ) -> Any:
            return basic_room::stats() + terrain_room::stats()


    def __init__(self):


    def init(self, ) -> None:
            terrain_room::init()
            outside::init()


    def stats(self, ) -> Any:
            return outside::stats() + terrain_room::stats()


    def dest_me(self, ) -> None:
            terrain_room::dest_me()
            outside::dest_me()


    def add_vertex(self, x: int, y: int) -> None:
            class vertex vertex
            vertex = new(class vertex, x : x, y : y)
            _vertexes += [vertex]


    def is_inside_region(self, x1: int, y1: int, x2: int, y2: int, range: int) -> int:
            class vertex vertex
            class vertex vert1
            class vertex vert2
            int i
            foreach (vertex in _vertexes) {
            if (vertex->x >= x1 && vertex->x <= x2 &&
            vertex->y >= y1 && vertex->y <= y2) {
            return 1


    def dest_me(self, ) -> None:
            destruct(self)


    def set_inside(self, flag: int) -> None:
            _inside = flag


    def add_vertex(self, x: int, y: int) -> None:
            class vertex vertex
            vertex = new(class vertex, x : x, y : y)
            _vertexes += [vertex]


    def is_inside_region(self, x1: int, y1: int, x2: int, y2: int, range: int) -> int:
            class vertex vertex
            class vertex vert1
            class vertex vert2
            int i
            foreach (vertex in _vertexes) {
            if (vertex->x >= x1 && vertex->x <= x2 &&
            vertex->y >= y1 && vertex->y <= y2) {
            return 1


    def dest_me(self, ) -> None:
            destruct(self)


    def add_feature_position(self, x: int, y: int, width: int, height: int) -> None:
            class feature_pos pos
            pos = new(class feature_pos, xstart : x, ystart : y,
            width : width, height : height)
            _positions += [pos]


    def dest_me(self, ) -> None:
            destruct(self)


    def is_inside_region(self, x1: int, y1: int, x2: int, y2: int, range: int) -> int:
            class feature_pos position
            int height
            int width
            foreach (position in _positions) {
            height = position->height
            width = position->width
            if (position->xstart >= x1 && position->xstart <= x2 &&
            position->ystart >= y1 && position->ystart <= y2) {
            return 1


    def set_very_close_distance(self, close: int) -> None:
            _very_close_distance = close


    def query_base_description(self, ) -> str:
            return _base_desc


    def set_base_description(self, desc: str) -> None:
            _base_desc = desc


    def set_distance_multiplier(self, mult: int) -> None:
            _distance_multiplier = mult


    def calc_feature_desc(self, direcs: Any, night: int, visibility: int) -> str:
            string direc
            int dist
            int new_dist
            string* bits
            bits = [})
            if(visibility < 1 && visibility != -1)
            visibility = 1
            foreach (direc, dist in direcs) {
            dist += query_range_offset()
            new_dist = dist * 100 / visibility
            if (visibility == -1 ||
            (new_dist < query_max_range() && dist > query_min_range())) {
            if (dist < _very_close_distance) {
            bits += ["very close to the " + direc]
            } else {
            bits += [query_distance_str(dist * _distance_multiplier) + " to the " + direc]


    def calc_map_feature_desc(self, direcs: Any, fudge: int) -> str:
            string direc
            int dist
            string* bits
            bits = [})
            foreach (direc, dist in direcs) {
            dist += query_range_offset()
            if (dist < _very_close_distance * 5) {
            bits += ["very close to the " + direc]
            } else {
            bits += [({"approximately ", "about ", "roughly "})[random(3)] +
            query_distance_str(dist * _distance_multiplier) +
            " to the " + direc]


    def query_terrain_handler(self, ) -> str:
            class feature {
            mapping direcs
            mixed items
            int sentance
            int index
            int visible


    def __init__(self):
            self._variable_exits = []
            self._default_exits = ([ ])


    def long_test(self, str: str, dark: int) -> str:
            string ret
            string map
            string* map_lines
            ret = long(str, dark)
            map = query_terrain_handler()->query_player_map_template(_x_coord,
            _y_coord, _z_coord, query_visibility(), 9)
            map_lines = map(explode(map, "\n"), (: $1 + "   " :))
            ret = "$COLUMN$12=" + implode(map_lines, "\n") + "$COLUMN$" +
            ret
            return ret


    def hash(self, mod: int) -> int:
            mixed* my_coord
            int x
            int y
            int z
            int grid
            int val
            string str
            my_coord = query_co_ord()
            if (!my_coord) {
            return 0


    def hash_time(self, mod: int, period: int) -> int:
            mixed* my_coord
            int x
            int y
            int z
            int grid
            int val
            string str
            my_coord = query_co_ord()
            if (!my_coord) {
            return 0


    def query_terrain_handler(self, ) -> str:
            return _terrain_handler


    def set_terrain_handler(self, handler: str) -> None:
            _terrain_handler = handler


    def create_terrain_room(self, ) -> None:
            {
            _x_coord = -1
            _y_coord = -1
            _z_coord = -1
            add_property("terrain_map", 1)
            add_extra_look(self)
            if (do_outside_chats())
            terrain_chat([60, 120, ["#do_a_feature_chat",
            "#do_an_outside_chat"]] )


    def terrain_setup(self, ) -> None:
            {


    def set_terrain_coords(self, x: int, y: int, z: int) -> None:
            {
            _x_coord = x
            _y_coord = y
            _z_coord = z


    def query_map_handler(self, ) -> MudObject:
            {
            return load_object(query_terrain_handler())


    def reset_handler(self, ) -> None:
            {
            if (query_map_handler())
            query_map_handler()->reset_handler()


    def receive_message(self, mess_class: str, message: str, title: str) -> None:
            {
            class    feature feature
            if (mess_class == "feature") {
            feature = _features[title]
            if (!feature) {
            return


    def do_a_feature_chat(self, ) -> None:
            {
            string   *chats = [})
            string   feature_chat
            string   title
            class  feature feature
            if ((_x_coord < 0) || (_y_coord < 0)) {
            return


    def do_an_outside_chat(self, ) -> None:
            {
            string chat = query_map_handler()->get_an_outside_chat(_outside_types)
            if (chat && strlen(chat)) {
            tell_room(self, chat + "\n")


    def can_view_feature(self, name: str) -> int:
            {
            return 1


    def can_view_feature_from(self, name: str, direc: str, distance: int) -> int:
            {
            return 1


    def can_exit_to(self, type: str, direc: str, base_path: str) -> int:
            {
            return 1


    def can_enter_from(self, type: str, direc: str, base_path: str) -> int:
            {
            return 1


    def do_outside_chats(self, ) -> int:
            {
            return 1


    def add_random_desc(self, desc: str) -> None:
            {
            if (!_random_desc) {
            _random_desc = ""


    def terrain_add_zone(self, zone: str) -> None:
            {
            add_zone(zone)
            query_map_handler()->add_room_to_zone(self, zone)


    def set_extra_long(self, extra: str) -> None:
            {
            _extra_long = extra


    def set_outside_types(self, types: str) -> None:
            {
            _outside_types = types


    def query_my_real_file_name(self, ) -> str:
            return __FILE__


    def extra_look(self, ) -> str:
            string   result = _extra_long
            string   title
            string*   tmp
            class  feature feature
            int new_line
            string* descs
            int visibility
            new_line = query_map_handler()->query_newline_mode()
            descs = [})
            visibility = query_visibility()
            foreach (title, feature in _features) {
            tmp = query_map_handler()->query_feature_desc(title,
            feature->direcs, visibility)
            if (sizeof(tmp)) {
            feature->visible = 1
            descs += tmp


    def add_feature(self, title: str, bits: Any, items: Any, sentance: int) -> None:
            {
            _features[title] = new(class feature,
            items : items, direcs : bits)
            if (items) {
            add_item(items, (: query_feature_item_desc($(title)) :))


    def add_distant_feature(self, title: str, bits: Any) -> None:
            _dist_features[title] = bits


    def remove_feature(self, title: str) -> None:
            {
            class feature  feature = _features[title]
            mixed    items
            if (!feature) {
            return


    def query_feature_item_desc(self, title: str) -> str:
            {
            if (_features[title]->visible) {
            return query_map_handler()->query_feature_item_desc(title)


    def set_terrain_map_block(self, blocking: int) -> None:
            if (blocking) {
            _flag |= BLOCKING_FLAG
            } else {
            _flag &= ~BLOCKING_FLAG


    def query_terrain_map_block(self, ) -> int:
            return _flag & BLOCKING_FLAG


    def set_terrain_map_character(self, terr: str) -> None:
            _terrain_char = terr


    def query_terrain_map_character(self, ) -> str:
            return _terrain_char


    def query_cloning_info(self, ) -> str:
            {
            return file_name(self)


    def create_virtual_object(self, x_str: str, y_str: str) -> MudObject:
            {
            int x = to_int(x_str)
            int y = to_int(y_str)
            return query_map_handler()->load_room_at(x, y)


    def add_variable_exit(self, exit: str) -> None:
            _variable_exits += [exit]


    def add_default_exit(self, exit: str, location: str) -> None:
            _default_exits[exit] = location


    def query_terrain_map_walk_exit(self, ) -> str:
            return TERRAIN_MAP_WALK_EXIT


    def query_terrain_map_journey_exit(self, ) -> str:
            return TERRAIN_MAP_JOURNEY_EXIT


    def query_room_path(self, x: int, y: int, z: int) -> str:
            return sprintf("%s:%d:%d:%d", query_terrain_handler(), x, y, z)


    def query_direction_distance_str(self, num: int, dir: str) -> str:
            int dist
            string dist_mess
            dist = query_map_handler()->query_direction_distance(dir)
            switch (dist) {
            case 0..2 :
            if (dist > 1) {
            dist_mess = query_num(dist) + " foot section"
            } else {
            dist_mess = "foot"


    def do_map(self, ) -> int:
            string map
            map = query_map_handler()->query_debug_map(_x_coord, _y_coord, 13, _x_coord, _y_coord)
            write(map)
            add_succeeded_mess("")
            return 1


    def do_map_terrain(self, ) -> int:
            string map
            map = query_map_handler()->query_debug_map(20, 20, 40, _x_coord, _y_coord)
            write(map)
            add_succeeded_mess("")
            return 1


    def init(self, ) -> None:
            {
            tell_creator(this_player(), "Coords: (%d, %d, %d)\n", _x_coord, _y_coord, _z_coord)
            if (this_player()->query_creator()) {
            add_command("cremap", "", (: do_map :))
            add_command("cremap", "all", (: do_map_terrain :))


    def stats(self, ) -> Any:
            return ::stats() +
            [["file", query_my_real_file_name()],
            ["blocking", query_terrain_map_block()]]


    def dest_me(self, ) -> None:
            if(_terrain_chatter) {
            log_file("CHATTER", "%s dested terrain chatter: %O\n",
            file_name(self), _terrain_chatter)
            _terrain_chatter.dest_me()


    def __init__(self):


    def init(self, ) -> None:
            terrain_room::init()
            water_inside::init()


    def stats(self, ) -> Any:
            return water_inside::stats() + terrain_room::stats()


    def query_terrain_map_walk_exit(self, ) -> str:
            return "swim "


    def query_surface_room(self, ) -> MudObject:
            string dest_path
            object destination
            if (query_surface()) {
            return self


    def get_water_surface_light(self, ) -> int:
            float their_light, their_clarity, our_depth
            string above_path = file_name(self)
            object above
            above_path = implode(explode(above_path, ":")[0..<2], ":")+":0"
            above = load_object(above_path)
            if (!above) {
            return 0


    def __init__(self):


    def init(self, ) -> None:
            terrain_room::init()
            water_outside::init()


    def stats(self, ) -> Any:
            return water_outside::stats() + terrain_room::stats()


    def query_terrain_map_walk_exit(self, ) -> str:
            return "swim "


    def query_surface_room(self, ) -> MudObject:
            string dest_path
            object destination
            if (query_surface()) {
            return self


    def get_water_surface_light(self, ) -> int:
            float their_light, their_clarity, our_depth
            string above_path = file_name(self)
            object above
            above_path = implode(explode(above_path, ":")[0..<2], ":")+":0"
            above = load_object(above_path)
            if (!above) {
            return 0


    def __init__(self):
            self._bell = clone_object("/std/object")


    def __init__(self):
            self._bell = clone_object("/std/object")


    def init(self, ) -> None:
            this_player()->add_command("ring", _bell, "<direct:object>", (: do_ring :) )


    def create_carriage_driver(self, ) -> MudObject:
            return 0


    def query_outside(self, ) -> MudObject:
            class route_details query_route_map() { return _route_info; }
            int *query_stop_info() { return [_current_stop, _next_stop]; }
            void update_route( string name,
            class route_details new_route_info,
            object handler)
            {
            _handler = handler
            _route_info = new_route_info
            if (_current_stop >= sizeof(_route_info)) {
            _current_stop = _current_stop % sizeof(_route_info->stops)


    def make_stop(self, ) -> None:
            string name
            string* name_parts
            string np
            string n_path
            string path
            int travel_time
            int stop_time
            name = _handler.query_stop_name(_route_info->stops[ _current_stop ]->id)
            path = _handler.query_stop_location(_route_info->stops[ _current_stop ]->id)
            _p_name = name
            travel_time = _route_info->stops[ _next_stop ]->travel_time
            stop_time = _handler.query_stop_delay(_route_info->stops[ _current_stop ]->id)
            _n_name = _handler.query_stop_name(_route_info->stops[ _next_stop ]->id)
            n_path = _handler.query_stop_location(_route_info->stops[ _next_stop ]->id)
            _outside = load_object(path)
            if (!_outside) {
            log_file("NEW_CARRIAGE", ctime(time())+" (%O): problem with "
            + path +" (" + name + ", " + _route_info->stops[ _current_stop ]->id + ")\n", self)
            _route_info->stops = _route_info->stops[0.._current_stop - 1] +
            _route_info->stops[_current_stop + 1..]
            asyncio.create_task(self."make_stop", 1)
            return


    def check_can_leave(self, exit: str, person: MudObject) -> int:
            return !_outside.check_cannot_leave_carriage(person)


    def give_warning(self, this_stop_name: str, next_stop_name: str) -> None:
            if(objectp(_outside) && objectp(_car_driver) &&
            (environment(_car_driver) == _outside)) {
            _car_driver.leaving_again_to_stop(next_stop_name)
            } else {
            tell_room(self, "The carriage is about to leave for " +
            next_stop_name + ".\n")


    def move_on(self, ) -> None:
            string np
            string* name_parts
            if(objectp(_car_driver)) {
            _car_driver.do_command("mutter")
            _car_driver.do_command("enter " + lower_case(_carriage_name) +
            " carriage")
            if( environment(_car_driver) != self ) {
            debug_printf("Driver: Tried to \"enter " +
            lower_case(_carriage_name) + " carriage\" and "
            "failed.")
            _car_driver->move(self, "The driver hops back in to the "
            "carriage and gets ready to drive again.",
            "The " + _carriage_name + " driver hops back "
            "onto " + _car_driver.query_possessive() +
            " carriage.")


    def dest_me(self, ) -> None:
            string path
            object ob
            string np
            string* name_parts
            if(objectp(_outside)) {
            _outside.remove_exit(_exit_name)
            name_parts = explode(lower_case(_carriage_name), " ")
            foreach(np in name_parts) {
            _outside.remove_alias("enter " + np + " carriage", _exit_name)
            _outside.remove_alias("enter " + np + "s carriage", _exit_name)


    def query_quit_handler(self, ) -> str:
            return _handler.query_stop_location(_route_info->stops[ _current_stop ]->id)


    def do_ring(self, ) -> int:
            if ( sizeof( co() ) != 0 ) {
            add_succeeded_mess(({"You ring the bell.\n", "$N $V the "
            "bell.\n"}))
            if(objectp(_car_driver) && environment(_car_driver) == self) {
            _car_driver.bell_ring(_n_name)
            } else {
            tell_room(self, "Nothing much happens.\n")


    def query_environ_long(self, ) -> str:
            if ( !_outside ) {
            return "Outside the carriage, the road from " + _p_name + " to "
            + _n_name + " swishes by."
            } else {
            return "Outside the window you can see:\n" + _outside.long()


    def setup(self, ) -> None:
            set_name( "note" )
            set_short(  "Test note" )
            set_long( "This note is probably broken, please contact a "
            "creator. :)\n" )
            reset_get()
            add_alias( "table" )


    def setup_route(self, stops: Any, colour: str, route: str, language: str) -> None:
            string prettystops = ""
            int i
            set_short(route + " table")
            add_adjective(map(explode(route, " "), (: lower_case($1) :)))
            add_adjective(colour)
            add_alias("table")
            add_alias("cardboard")
            add_adjective(({"piece", "of", colour}))
            set_long("This is the table for the " + route + " route.  It is "
            "printed on a piece of sturdy " + colour + " cardboard, and stuck "
            "firmly to the pole.\n")
            for(i = 0; i < sizeof(stops) - 1; i++) {
            prettystops += capitalize(stops[i]) + "\n"


    def setup(self, ) -> None:
            set_name( "pole" )
            set_short("wooden pole")
            add_adjective( "wooden" )
            set_long("This is a wooden pole.  It's fairly unexciting.\n")
            set_weight( 10000 )
            add_property( "there", ( ({"casually placed in a corner",
            "here",
            "standing on the side of the road",
            "trying to be noticed"})
            [random(4)]))
            add_extra_look(self)
            reset_get()


    def setup_route(self, stops: str, colour: str, route: str) -> None:
            object note
            string language
            string pathofhere
            if(notes.index(colour + " note") if colour + " note" in notes else -1 != -1) {
            return


    def extra_look(self, ) -> str:
            if(sizeof(notes)) {
            return capitalize((query_multiple_short(map( notes, (: add_a($1) :)))) +
            ((sizeof(notes) > 1) ? " are" : " is") + " attached to the pole.\n")


    def __init__(self):
            self._file_modified_time = ([ ])


    def query_stop_location(self, name: str) -> str:
            if (_routedetails[name]) {
            return _routedetails[name]->path


    def query_stop_name(self, name: str) -> str:
            if (_routedetails[name]) {
            return _routedetails[name]->name


    def query_stop_delay(self, name: str) -> int:
            if (_routedetails[name]) {
            return _routedetails[name]->delay


    def query_carriage_on_route(self, route: str) -> MudObject:
            return _carriages[route]


    def scan_for_new_data(self, ) -> None:
            string *files
            string fname
            string *bits
            debug_printf("Scan for new data.")
            if (unguarded( (: stat(__FILE__)[1] :)) !=
            _file_modified_time[__FILE__]) {
            _file_modified_time = ([ ])


    def load_data(self, ) -> None:
            scan_for_new_data()


    def __init__(self):
            self._bell = clone_object("/std/object")


    def __init__(self):
            self._bell = clone_object("/std/object")


    def init(self, ) -> None:
            this_player()->add_command("ring", _bell, "<direct:object>", (: do_ring :) )


    def create_carriage_driver(self, ) -> MudObject:
            return 0


    def query_outside(self, ) -> MudObject:
            class route_details query_route_map() { return _route_info; }
            int *query_stop_info() { return [_current_stop, _next_stop]; }
            void update_route( string name,
            class route_details new_route_info,
            object handler)
            {
            _handler = handler
            _route_info = new_route_info
            if (_current_stop >= sizeof(_route_info)) {
            _current_stop = _current_stop % sizeof(_route_info->stops)


    def make_stop(self, ) -> None:
            string name
            string* name_parts
            string np
            string n_path
            string path
            int travel_time
            int stop_time
            name = _handler.query_stop_name(_route_info->stops[ _current_stop ]->id)
            path = _handler.query_stop_location(_route_info->stops[ _current_stop ]->id)
            _p_name = name
            travel_time = _route_info->stops[ _next_stop ]->travel_time
            stop_time = _handler.query_stop_delay(_route_info->stops[ _current_stop ]->id)
            _n_name = _handler.query_stop_name(_route_info->stops[ _next_stop ]->id)
            n_path = _handler.query_stop_location(_route_info->stops[ _next_stop ]->id)
            _outside = load_object(path)
            if (!_outside) {
            log_file("NEW_CARRIAGE", ctime(time())+" (%O): problem with "
            + path +" (" + name + ", " + _route_info->stops[ _current_stop ]->id + ")\n", self)
            _route_info->stops = _route_info->stops[0.._current_stop - 1] +
            _route_info->stops[_current_stop + 1..]
            asyncio.create_task(self."make_stop", 1)
            return


    def check_can_leave(self, exit: str, person: MudObject) -> int:
            return !_outside.check_cannot_leave_carriage(person)


    def give_warning(self, this_stop_name: str, next_stop_name: str) -> None:
            if(objectp(_outside) && objectp(_car_driver) &&
            (environment(_car_driver) == _outside)) {
            _car_driver.leaving_again_to_stop(next_stop_name)
            } else {
            tell_room(self, "The carriage is about to leave to " +
            next_stop_name + ".\n")


    def move_on(self, ) -> None:
            string* name_parts
            if(objectp(_car_driver)) {
            _car_driver.do_command("mutter")
            _car_driver->move(self, "The driver hops back in to the carriage "
            "and gets ready to drive again.", "The " + _carriage_name +
            " driver hops back onto " + _car_driver.query_possessive() +
            " carriage.")
            } else {
            tell_room(self, "The carriage leaves the current stop.\n")


    def dest_me(self, ) -> None:
            string path
            object ob
            string* name_parts
            if(objectp(_outside)) {
            _outside.remove_exit(_exit_name)
            name_parts = explode(lower_case(_carriage_name), " ")
            foreach(np in name_parts) {
            _outside.remove_alias("enter " + np + " carriage", _exit_name)
            _outside.remove_alias("enter " + np + "s carriage", _exit_name)


    def query_quit_handler(self, ) -> str:
            return _handler.query_stop_location(_route_info->stops[ _current_stop ]->id)


    def do_ring(self, ) -> int:
            if ( sizeof( co() ) != 0 ) {
            add_succeeded_mess(({"You ring the bell.\n", "$N $V the "
            "bell.\n"}))
            if(objectp(_car_driver) && environment(_car_driver) == self) {
            _car_driver.do_command("scowl")
            _car_driver->do_command("'We won't reach " + _n_name + " any faster just "
            "cause you ring that danged bell!")


    def query_environ_long(self, ) -> str:
            if ( !_outside ) {
            return "Outside the carriage, the road from " + _p_name + " to "
            + _n_name + " swishes by."
            } else {
            return "Outside the window you can see:\n" + _outside.long()


    def __init__(self):
            self._file_modified_time = ([ ])


    def query_stop_location(self, name: str) -> str:
            if (_routedetails[name]) {
            return _routedetails[name]->path


    def query_stop_name(self, name: str) -> str:
            if (_routedetails[name]) {
            return _routedetails[name]->name


    def query_stop_delay(self, name: str) -> int:
            if (_routedetails[name]) {
            return _routedetails[name]->delay


    def query_carriage_on_route(self, route: str) -> MudObject:
            return _carriages[route]


    def scan_for_new_data(self, ) -> None:
            string *files
            string fname
            string *bits
            debug_printf("Scan for new data.")
            if (unguarded( (: stat(__FILE__)[1] :)) !=
            _file_modified_time[__FILE__]) {
            _file_modified_time = ([ ])


    def load_data(self, ) -> None:
            scan_for_new_data()


    def __init__(self):
            self._options = ([ ])
            self._ownership = ([ ])
            self._default_ownership = ([ ])


    def __init__(self):
            self._options = ([ ])
            self._ownership = ([ ])
            self._default_ownership = ([ ])
            private void add_board_to(string club) {
            int board_count
            board_count = CLUB_HANDLER->query_elected_option(club,
            CLUB_ROOM_BOARD_COUNT)
            board_count++
            if (board_count == 1) {
            CLUB_HANDLER.create_club_board(club)


    def set_club(self, club: str) -> int:
            class ownership bing
            class ownership fluff
            string name
            if (!CLUB_HANDLER.is_elected_club(club)) {
            return 0


    def query_club(self, ) -> str:
            return _club


    def set_board_associated(self, board_associated: int) -> None:
            board_associated = board_associated != 0
            if (_club) {
            if (_board_contained != board_associated) {
            if (board_associated) {
            add_board_to(_club)
            } else {
            remove_board_from(_club)


    def query_board_associated(self, ) -> int:
            return _board_contained


    def is_option(self, name: str) -> int:
            return !undefinedp(_options[name])


    def query_option(self, name: str) -> Any:
            return _options[name]


    def remove_option(self, name: str) -> int:
            if (is_option(name)) {
            map_delete(_options, name)
            return 1


    def set_option(self, name: str, value: Any) -> int:
            _options[name] = value


    def load_me(self, ) -> None:
            if (_save_directory) {
            unguarded( (: restore_object(_save_directory + CLUB_ROOM_CONTROLLER_SAVE_FILE ) :) )


    def save_me(self, ) -> None:
            if (_save_directory) {
            unguarded( (: save_object(_save_directory + CLUB_ROOM_CONTROLLER_SAVE_FILE ) :) )


    def set_save_directory(self, save_directory: str) -> None:
            while (save_directory[<1] == '/') {
            save_directory = save_directory[0..<2]


    def query_save_directory(self, ) -> str:
            return _save_directory


    def query_room_save_file_name(self, fname: Any) -> str:
            if (objectp(fname)) {
            fname = file_name(fname)


    def set_handler(self, handler: str) -> None:
            _handler = handler


    def query_handler(self, ) -> str:
            return _handler


    def __init__(self):


    def __init__(self):


    def set_size(self, i: int, s: Any) -> None:
            if (intp(s)) {
            areas[i]->size = [s, s, s]
            } else if (arrayp(s) && (sizeof(s) == 3)) {
            areas[i]->size = copy(s)
            } else {
            error("Illegal size; must be int or 3-element array.\n")


    def new_area(self, ) -> int:
            areas += [new(class AREA_INFO)]


    def set_vertices(self, a: int, vs: Any) -> None:
            int v, i
            if (!arrayp(areas[a]->origin)) {
            error("Origin unset - setting to (0,0,0).\n")
            areas[a]->origin = [0, 0, 0]


    def in_bbox(self, coord: int, bbox: Any) -> int:
            if ((coord[0] < bbox[0][0]) || (coord[0] > bbox[1][0])) {
            return 0


    def in_area(self, a: int, v: int) -> int:
            int crossings, i, i0, i1, de, int_n, below_vertex
            mixed *vs
            if (!in_bbox(v, areas[a]->bbox)) {
            return 0


    def clone_room(self, a: int, coord_q: int, coord_s: str) -> MudObject:
            int i, j, e, bit
            string dir
            object room
            room = clone_object(areas[a]->base)
            room_cache[coord_s] = room
            area_cache[coord_s] = a
            room.set_room_size(areas[a]->size)
            room.set_co_ord(coord_q)
            if (areas[a]->exits) {
            i = (areas[a]->origin[0] - coord_q[0])/(2*areas[a]->size[0])
            j = (coord_q[1] - areas[a]->origin[1])/(2*areas[a]->size[1])
            if ((i < areas[a]->exits->size[0]) && (j < areas[a]->exits->size[1])
            && (i >= 0) && (j >= 0)) {
            e = areas[a]->exits->image[i][j]
            foreach (dir, bit in direction_bits) {
            if (e & bit) {
            room.add_exit(dir, "", "path")


    def find_room_at_coord(self, coord: int) -> MudObject:
            int a, ac, *coord_q
            string coord_s
            object room
            coord_s = sprintf("%d:%d:%d", coord[0], coord[1], coord[2])
            if (objectp(room = room_cache[coord_s])) {
            return room


    def find_room_at_exit(self, r: MudObject, d: int, direc: str) -> MudObject:
            int a, ac, i, *coord, *coord_r, *coord_q
            string coord_s
            object room
            mixed size_r
            if (dbg_lvl > 0) {
            tell_creator(debugger, "%s::find_room_at_exit()\n"
            "  r: %O\n"
            "  d: %O\n"
            "  direc: %O\n",
            file_name(self), r, d, direc)


    def goto_room_at_coord(self, coord: int) -> int:
            return this_player()->move_with_look(find_room_at_coord(coord))


    def goto_room_at_exit(self, d: int, direc: str) -> int:
            return this_player()->move_with_look(find_room_at_exit(
            environment(this_player()), d, direc))


    def print_images(self, a: int) -> None:
            if (areas[a]->height) {
            printf("-------- Height:\n")
            IMAGE_HANDLER.print_image(areas[a]->height)


    def print_map(self, a: int) -> None:
            int s, e
            string l = ""
            class IMAGE_INFO exits
            if (areas[a]->exits) {
            exits = areas[a]->exits
            for (s = 0; s < exits->size[1]; s++) {
            for (e = 0; e < exits->size[0]; e++) {
            l += (exits->image[s][e] & 128)?"\\":" "
            l += (exits->image[s][e] & 1)  ?"|":" "
            l += (exits->image[s][e] & 2)  ?"/":" "


    def abs(self, i: int) -> int:
            return (i<0)?-i:i


    def set_milestones(self, s: str) -> None:
            int i
            milestones = copy(s)
            if (milestones[0] == milestones[<1]) {
            closed = 1


    def set_milestone_coords(self, i: int, c: int) -> None:
            if (!arrayp(c) || (sizeof(c) != 3)) {
            return


    def set_bases(self, s: str) -> None:
            int i
            if (sizeof(s) != sizeof(iroom_info)) {
            error("Wrong number of bases (" + sizeof(s) + ") for given milestones (" +
            sizeof(milestones) + ").\n")
            return


    def set_sizes(self, s: Any) -> None:
            int i
            if (sizeof(s) != sizeof(iroom_info)) {
            error("Wrong number of sizes (" + sizeof(s) + ") for given milestones (" +
            sizeof(milestones) + ").\n")
            return


    def query_endpoint(self, i: int, j: int, dir: int) -> int:
            if ((dir && (j == sizeof(irooms[i])-1)) || (!dir && (j == 0))) {
            return 1


    def in_bbox(self, coord_a: int, bbox: Any) -> int:
            if ((coord_a[0] < bbox[0][0]) || (coord_a[0] > bbox[1][0])
            || (coord_a[1] < bbox[0][1]) || (coord_a[1] > bbox[1][1]))
            return 0
            return 1


    def number_of_irooms(self, i: int) -> int:
            int n
            mixed bbox
            class IROOM_INFO ir
            ir = iroom_info[i]
            bbox = ir->bbox
            if (ir->sgn_n == 0) {
            n = (bbox[1][1] - bbox[0][1])/(ir->size[1]*2)
            } else if (ir->sgn_e == 0) {
            n = (bbox[1][0] - bbox[0][0])/(ir->size[0]*2)
            } else {
            n = (bbox[1][1] - bbox[0][1])/(ir->size[1]*2)
            if (n != (bbox[1][0] - bbox[0][0])/(ir->size[0]*2)) {
            error("Interroom sizes don't match diagonal.\n")
            return 0


    def clone_iroom(self, i: int, idx: int, icoord: int) -> MudObject:
            object iroom
            iroom = clone_object(iroom_info[i]->base)
            iroom.set_room_size(iroom_info[i]->size)
            iroom.set_co_ord(icoord)
            iroom.set_milestone_index( [i, idx] )
            iroom.add_exit(iroom_info[i]->exits[0], milestones[i], "road")
            iroom.add_exit(iroom_info[i]->exits[1], milestones[i+1], "road")
            iroom.add_milestone_dir(iroom_info[i]->exits[0])
            iroom.add_milestone_dir(iroom_info[i]->exits[1])
            iroom.add_topo_exits_int()
            return iroom


    def setup_milestone(self, ms: MudObject) -> None:
            int *coord, i, j, idir
            string *dir
            if (undefinedp(i = milestone_idx[file_name(ms)])) {
            error("This room (" + file_name(ms) + ") is not a milestone.\n")
            return


    def find_room_at_index(self, i: int, idx: int) -> MudObject:
            int *icoord = [0, 0, 0]
            class IROOM_INFO ir
            if (dbg_lvl > 0) {
            tell_creator(debugger, "%s::find_room_at_index()\n"
            "  i: %O, idx: %O\n",
            file_name(self), i, idx)


    def query_region(self, coord: int, bbox: Any) -> int:
            int ret
            if (coord[0] < bbox[0][0]) {
            ret += 1
            } else if (coord[0] > bbox[1][0]) {
            ret += 2


    def find_room_at_crossing(self, coord_a: int, coord_b: int) -> MudObject:
            int i, a, b, c, d, dist2, ret_dist2
            float e, f, det
            int *isect
            object ret
            mixed bbox, road_a, road_b
            if (dbg_lvl > 0) {
            tell_creator(debugger, "%s::find_room_at_crossing()\n"
            "  coord_a: %O\n"
            "  coord_b: %O\n",
            file_name(self), coord_a, coord_b)


    def __init__(self):
            self.std_euid = "/secure/master"->creator_file(file_name(this_object()))


    def dest_me(self, ) -> None:
            if (stringp(save_file)) {
            unguarded( (: save_object, save_file :) )


    def goto_room_at_coord(self, coord: int) -> int:
            return this_player()->move_with_look(find_room_at_coord(coord))


    def goto_room_at_index(self, i: int, j: int) -> int:
            return this_player()->move_with_look(find_room_at_index(i, j))


    def goto_room_at_crossing(self, a: int, b: int) -> int:
            return this_player()->move_with_look(find_room_at_crossing(a, b))


    def recalc_milestones(self, idx: int, callouts: int, tp: MudObject) -> None:
            int *c
            string ms
            if (callouts > 10) {
            error(sprintf("Too many callouts in %s:recalc_iroom_info(%d, %d)\n",
            file_name(self), idx, callouts))
            return


    def clear_map_handler(self, ) -> None:
            int i
            string ms, directory, troom
            for (i = 0; i < sizeof(milestones); i++) {
            ms = milestones[i]
            directory = implode( explode( ms, "/" )[ 0..<2 ], "/" )
            troom = explode( ms, "/" )[ <1 ]
            if ( troom[ <2.. ] == ".c" ) {
            troom = troom[ 0..<3]


    def sanity_checks(self, ) -> int:
            int i, success = 1
            for (i = 0; i < sizeof(milestone_coords); i++) {
            if (sizeof(milestone_coords[i]) != 3) {
            printf("Milestone %d (%s) doesn't have proper coordinates: %O\n",
            i, milestones[i], milestone_coords[i])
            success = 0


    def __init__(self):


    def __init__(self):
            class bounding_box query_bounding_box() {
            return _topo_box


    def in_bbox(self, coord: int, bounding_box: Any) -> int:
            if ((coord[0] < bbox->topleft[0]) || (coord[0] > bbox->bottomright[0])) {
            return 0


    def add_area_handler(self, h: Any) -> None:
            object oh
            if (stringp(h)) {
            oh = load_object(h)
            oh.set_handler(base_name(self))
            if (objectp(oh)) {
            _area_handlers += [oh]
            } else {
            error(sprintf("Couldn't find area handler %s.\n", h))


    def add_iroom_handler(self, h: Any) -> None:
            object oh
            if (stringp(h)) {
            oh = load_object(h)
            oh.set_handler(base_name(self))
            if (objectp(oh)) {
            _iroom_handlers += [oh]
            } else {
            error(sprintf("Couldn't find interroom handler %s.\n", h))


    def add_fixed_room(self, f: str) -> None:
            object of
            of = load_object(f)
            if (!objectp(of)) {
            error(sprintf("Couldn't load fixed room %s.\n", f))
            return


    def add_fixed_room_object(self, of: MudObject) -> None:
            add_internal_fixed_room(file_name(of), of, of.query_co_ord(),
            bounding_box(of.query_co_ord(), of.query_room_size()))


    def add_fixed_room_coordinate(self, f: str, coord: Any, size: Any) -> None:
            add_internal_fixed_room(f, 0, coord, bounding_box(coord, size))


    def setup_fixed_room(self, ) -> None:
            object shad, r
            int i
            r = previous_object()
            shad = clone_object(FIXED_SHADOW)
            if (!objectp(shad)) {
            error(sprintf("Couldn't create shadow for fixed room %O.\n", r))
            return


    def find_room_at_coord(self, coord: int) -> MudObject:
            int i
            object ob
            if (_dbg_lvl > 0) {
            tell_creator(_debugger, "%s::find_room_at_coord()\n"
            "  coord: %O\n",
            file_name(self), coord)


    def create_virtual_object(self, x: int, y: int, z: int) -> MudObject:
            if (undefinedp(x) || undefinedp(y) || undefinedp(z)) {
            return 0


    def find_room_at_exit(self, r: MudObject, d: int, direc: str) -> MudObject:
            int i, s, dist, max_dist, max_iroom, *coord, *coord_r, *coord_ob
            string msg
            object ob, *irooms = [})
            mixed size_r
            class bounding_box bbox_r
            if (_dbg_lvl > 0) {
            tell_creator(_debugger, "%s::find_room_at_exit()\n"
            "  r: %O\n"
            "  d: %O\n"
            "  direc: %O\n",
            file_name(self), r, d, direc)


    def goto_room_at_coord(self, coord: int) -> int:
            return this_player()->move_with_look(find_room_at_coord(coord))


    def query_text_map(self, width: int) -> str:
            int x
            int y
            int maxy
            string map
            object room
            map = ""
            for (y = 0; y < maxy; y++) {
            for (x = 0; x < width; x++) {
            room = find_room_at_coord( [x, y, 0] )
            if (!room) {
            map += " "
            } else if (!room.query_room_letter()) {
            map += "?"
            } else {
            map += room.query_room_letter()


    def __init__(self):


    def set_banish_handler(self, hand: str) -> None:
            _banish_handler = hand


    def query_banish_handler(self, ) -> str:
            return _banish_handler


    def query_short(self, area: str, nomic_case: Any, type: str, data: Any) -> str:
            return ::query_short() + " for " + data + " days"


    def setup(self, ) -> None:
            set_short("dismissed")
            set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "dismissed")


    def setup(self, ) -> None:
            _fines = ([ ])
            set_short("fine")
            set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "fine")
            seteuid(getuid())
            load_me()


    def load_me(self, ) -> None:
            if (_save_file) {
            unguarded((: restore_object( _save_file ) :))
            asyncio.create_task(self."remove_old_fines", 2)


    def save_me(self, ) -> None:
            unguarded((: save_object( _save_file ) :))


    def remove_old_fines(self, ) -> None:
            class fine_type fine
            string player
            int changed
            foreach (player, fine in _fines) {
            if (!PLAYER_HANDLER.test_user(player)) {
            map_delete(_fines, player)
            changed = 1


    def set_money_area(self, area: str) -> None:
            _money_area = area


    def query_money_area(self, ) -> str:
            return _money_area


    def set_save_file(self, fname: str) -> None:
            _save_file = fname


    def query_save_file(self, ) -> str:
            return _save_file


    def pay_fine(self, person: str, amount: int) -> int:
            if (_fines[person]) {
            _fines[person]->paid += amount
            _fines[person]->last_touched = time()
            save_me()
            return 1


    def query_current_fine(self, person: str) -> int:
            if (_fines[person]) {
            return _fines[person]->fines - _fines[person]->paid


    def query_total_fine(self, person: str) -> int:
            if (_fines[person]) {
            return _fines[person]->fines


    def query_total_payments(self, person: str) -> int:
            if (_fines[person]) {
            return _fines[person]->paid


    def setup(self, ) -> None:
            set_short("lose citizenship")
            set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "lose_citizenship")


    def setup(self, ) -> None:
            set_short("not guilty")
            set_description_file(NOMIC_PUNISHMENT_DOCS_DIR + "not_guilty")


    def __init__(self):
            self._titles = []


    def set_titles(self, titles: Any) -> None:
            _titles = titles


    def __init__(self):
            self._maximum_total_difference = 4000
            self._last_paid = time()


    def query_player_bank(self, ) -> int:
            return 1


    def set_maximum_total_difference(self, max: int) -> None:
            _maximum_total_difference = max


    def query_maximum_total_difference(self, ) -> int:
            return _maximum_total_difference


    def set_last_paid(self, paid: int) -> None:
            _last_paid = paid


    def query_last_paid(self, ) -> int:
            return _last_paid


    def adjust_account(self, person: str, amount: int) -> None:
            adjust_float(amount)


    def find_main_bank(self, ) -> MudObject:
            object office
            object* obs
            office = load_object(BANK_HANDLER.query_bank_master_office(query_bank_name()))
            if (!office) {
            return 0


    def can_adjust_account(self, person: str, amount: int) -> int:
            int amt
            amt = query_total_difference() + amount
            if (amt < -query_maximum_total_difference()  ||
            amt > query_maximum_total_difference()) {
            if (amt < 0) {
            add_failed_mess("This bank does not have the funds to handle "
            "your request.\n")
            } else {
            add_failed_mess("This bank does not have the vault space to handle "
            "your request.\n")


    def query_commercial_information(self, ) -> str:
            string* bits
            string bank
            string place
            place = previous_object()->query_money_place()
            bits = [})
            foreach (bank in BANK_HANDLER.query_banks()) {
            bits += [bank + " costs " +
            MONEY_HAND.money_value_string(BANK_HANDLER->query_bank_default_cost_per_month(bank), place) +
            " per month and " +
            MONEY_HAND.money_value_string(BANK_HANDLER->query_bank_default_cost_to_open(bank), place) +
            " to open"]


    def do_set_cut(self, percent: int) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to change the paramaters of "
            "$D.\n")
            return 0


    def do_set_open_cost(self, str: str) -> int:
            string place
            int value
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to change the paramaters of "
            "$D.\n")
            return 0


    def is_allowed(self, name: str) -> int:
            return commercial::is_allowed(name)


    def init(self, ) -> None:
            bank_franchise::init()
            commercial::init()
            if (is_allowed(this_player()->query_name())) {
            add_command("set", "percentage <number> on <direct:object>",
            (: do_set_cut($4[0]) :))
            add_command("set", "account cost <string'open cost'> on <direct:object>",
            (: do_set_open_cost($4[0]) :))


    def query_franchise(self, ) -> str:
            return file_name(environment())


    def event_save(self, ob: MudObject) -> None:
            environment()->event_save(ob)


    def set_commercial_option(self, type: str, name: str, room: MudObject) -> None:
            switch (type) {
            case "branch" :
            set_bank_name(name)
            BANK_HANDLER->add_new_franchise(name,
            file_name(room.query_main_room()))
            break


    def query_monthly_fee(self, ) -> int:
            return BANK_HANDLER->query_bank_franchise_cost_per_month(
            query_bank_name(), query_franchise())


    def is_open_for(self, type: str, name: str) -> int:
            if (query_monthly_fee() == -1) {
            return 0


    def setup_call_out(self, ) -> None:
            int tim
            if (!_last_paid) {
            _last_paid = time()


    def make_payment(self, ) -> None:
            _last_paid += MONTH_LENGTH
            adjust_float(-query_monthly_fee())
            setup_asyncio.create_task(self.)


    def query_main_status(self, hints: int) -> str:
            string ret
            string place
            add_help_file("bank_franchise")
            place = query_money_place()
            ret = "$I$0=" + the_short() + ":\n"
            "$I$6=   Bank Branch                  : " + query_bank_name() + "\n"
            "$I$6=   Revenue                      : " +
            MONEY_HAND.money_value_string(query_revenue(), place) + "\n"
            "$I$6=   Master Address               : " +
            BANK_HANDLER.query_bank_master_office(query_bank_name())->query_address() +
            "\n$I$6=   Maximum allowed bank balance : " +
            MONEY_HAND.money_value_string(query_maximum_total_difference(), place) +
            " (fixed)\n$I$6=   Bank Balance                 : " +
            MONEY_HAND.money_value_string(query_total_difference(), place) +
            "\n$I$6=   Credit Notes Outstanding     : " +
            MONEY_HAND.money_value_string(query_outstanding_credit_value(), place) + "\n"
            if (hints) {
            ret += "$I$6=     Hint: list credit notes\n"
            ret += "$I$6=     Hint: create credit note\n"
            ret += "$I$6=     Hint: recind credit note <id>\n"


    def init_dynamic_arg(self, map: Any, player: MudObject) -> None:
            commercial::init_dynamic_arg(map, player)
            set_bank_name(query_auto_load_value(map, OBJECT_TAG, "bank"))
            set_account_cost(query_auto_load_value(map, OBJECT_TAG, "open"))
            set_percentage(query_auto_load_value(map, OBJECT_TAG, "percentage"))
            set_total_difference(query_auto_load_value(map, OBJECT_TAG, "difference"))
            set_credit_notes(query_auto_load_value(map, OBJECT_TAG, "notes"))
            set_credit_num(query_auto_load_value(map, OBJECT_TAG, "credit num"))
            set_last_paid(query_auto_load_value(map, OBJECT_TAG, "last paid"))
            setup_asyncio.create_task(self.)


    def __init__(self):


    def event_save(self, ob: MudObject) -> None:
            environment()->event_save(ob)


    def find_bank_object(self, franchise: str) -> MudObject:
            object* obs
            object room
            room = load_object(franchise)
            if (room.query_bank()) {
            return room


    def do_list_franchises(self, ) -> int:
            string franchise
            int pos
            object bank_ob
            string ret
            string place
            if (!sizeof(BANK_HANDLER.query_franchises(query_bank_name()))) {
            add_failed_mess("This bank has no franchises.\n")
            return 0


    def do_set_franchise_cost(self, cost: str) -> int:
            int amount
            string place
            place = query_money_place()
            amount = MONEY_HAND.value_from_string(cost, place)
            if (amount <= 0) {
            add_failed_mess("Unknown amount " + cost + ".\n")
            return 0


    def do_set_default_monthly_cost(self, cost: str) -> int:
            int amount
            string place
            place = query_money_place()
            amount = MONEY_HAND.value_from_string(cost, place)
            if (amount <= 0) {
            add_failed_mess("Unknown amount " + cost + ".\n")
            return 0


    def do_set_main_bank_name(self, new_name: str) -> int:
            string* names
            string name
            if (query_bank_name()) {
            add_failed_mess("This bank already has a name.\n")
            return 0


    def check_bank_name(self, response: str, new_name: str) -> None:
            if (!strlen(response) || lower_case(response)[0] != 'y') {
            write("Ok, aborting.\n")
            return


    def do_set_cut(self, percent: int) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to change the paramaters of "
            "$D.\n")
            return 0


    def do_set_open_cost(self, str: str) -> int:
            string place
            int value
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to change the paramaters of "
            "$D.\n")
            return 0


    def do_set_franchise_cost_per_month(self, id: str, amount: str) -> int:
            string *franchises
            int id_num
            int amt
            id = lower_case(id)
            if (strlen(id) != 1) {
            add_failed_mess("Must be one letter.\n")
            return 0


    def query_main_status(self, hints: int) -> str:
            string ret
            string place
            place = query_money_place()
            ret = "$I$0=" + the_short() + ":\n"
            ret += "$I$6=   Bank Name             : " +
            query_bank_name() + "\n"
            ret += "$I$6=   Revenue               : " +
            MONEY_HAND.money_value_string(query_revenue(), place) + "\n"
            ret += "$I$6=   Cost to buy franchise : " +
            MONEY_HAND.money_value_string(BANK_HANDLER->query_bank_default_cost_to_open(query_bank_name()), place) + "\n"
            if (hints) {
            ret += "$I$9=      Hint: set buy franchise cost <amount> on <object>\n"


    def init_dynamic_arg(self, map: Any, player: MudObject) -> None:
            commercial::init_dynamic_arg(map, player)
            set_bank_name(query_auto_load_value(map, OBJECT_TAG, "bank"))
            set_account_cost(query_auto_load_value(map, OBJECT_TAG, "open"))
            set_percentage(query_auto_load_value(map, OBJECT_TAG, "percentage"))
            set_total_difference(query_auto_load_value(map, OBJECT_TAG, "difference"))


    def init(self, ) -> None:
            commercial::init()
            bank_master::init()
            if (is_allowed(this_player()->query_name())) {
            add_command("set", "bank name <string'name'> on <direct:object>",
            (: do_set_main_bank_name($4[0]) :))
            add_command("set", "buy franchise cost <string'cost'> on <direct:object>",
            (: do_set_franchise_cost($4[0]) :))
            add_command("set", "franchise monthly cost <string'cost'> on <direct:object>",
            (: do_set_default_monthly_cost($4[0]) :))
            add_command("set", "percentage <number> on <direct:object>",
            (: do_set_cut($4[0]) :))
            add_command("set", "account cost <string'open cost'> on <direct:object>",
            (: do_set_open_cost($4[0]) :))
            add_command("set", "franchise monthly cost <string'cost'> for <string'franchise id'> on <direct:object>",
            (: do_set_franchise_cost_per_month($4[1], $4[0]) :))
            add_command("list", "franchises on <direct:object>",
            (: do_list_franchises :))


    def __init__(self):


    def get(self, dest: Any) -> int:
            if(!move_check(dest)) {
            write("You feel it would be wrong to take " + the_short() + ".\n")
            return 2


    def query_static_auto_load(self, ) -> Any:
            if ( base_name(self) + ".c" == __FILE__ ) {
            return int_query_static_auto_load()


    def query_dynamic_auto_load(self, ) -> Any:
            mapping junk
            junk = object::query_dynamic_auto_load()
            if (!junk) {
            junk = ([ ])


    def init_dynamic_arg(self, map: Any) -> None:
            object::init_dynamic_arg(map)
            set_bonded(map["bonded"])


    def query_help_file_directory(self, ) -> str:
            return "/doc/furniture/"


    def __init__(self):


    def extra_look(self, ) -> str:
            object *stuff
            string answer = ""
            stuff = all_inventory( self )
            if (water) {
            if (dirt >= sizeof(dirt_messages)) {
            dirt = sizeof(dirt_messages) - 1


    def long_status(self, ) -> str:
            return ""


    def init(self, ) -> None:
            ::init()
            add_command( "lie", "in <direct:object>")
            add_command( "sit", "in <direct:object>")
            add_command( "kneel", "in <direct:object>")
            add_command( "stand", "in <direct:object>")
            add_command( "leave", "<direct:object>")
            add_command( "fill", "<direct:object>")
            add_command( "empty", "<direct:object>")
            add_command( "splash", "<indirect:living:here>")
            add_command( "wash", "<indirect:living:here>")


    def can_player_get_in_it(self, ) -> int:
            if (environment(self)!=environment(this_player())) {
            this_player()->add_failed_mess(self, "The " + self.short() + " needs to "
            "be on the floor for you to get in it.\n")
            return 0


    def wet_everyone_in(self, ) -> None:
            object *victims
            if (!water) {
            return


    def reset(self, ) -> None:
            wet_everyone_in()


    def do_fill(self, ) -> int:
            object player
            player=this_player()
            if (water) {
            player.add_failed_mess(self, "The " + self->short() + " is "
            "already full of water.\n")
            return 0


    def do_empty(self, ) -> int:
            object player
            player=this_player()
            if (!water) {
            player.add_failed_mess(self, "The " + self->short() + " is "
            "already as empty as it gets.\n")
            return 0


    def do_lie(self, ) -> int:
            object player
            if (!can_player_get_in_it()) {
            return 0


    def do_sit(self, ) -> int:
            object player
            if (!can_player_get_in_it()) {
            return 0


    def do_kneel(self, ) -> int:
            object player
            if (!can_player_get_in_it()) {
            return 0


    def do_stand(self, ) -> int:
            object player
            if (!can_player_get_in_it()) {
            return 0


    def event_exit(self, ob: MudObject, message: str, to: MudObject) -> None:
            if (ob==this_player() && this_player()->query_position_on() == self) {
            this_player()->return_to_default_position(1)


    def do_leave(self, ) -> int:
            if (this_player()->query_position_on() == "the "+self.short()) {
            this_player()->return_to_default_position(1)
            await this_player().send("You clamber out of the " + self.short() + ".\n" )
            tell_room(environment(self), this_player()->short()+" clambers "
            "out of the " + self.short() + ".\n", this_player() )


    def do_splash(self, indirect_obs: MudObject) -> int:
            if (environment(self)!=environment(this_player())) {
            this_player()->add_failed_mess(self, "The " + self.short() + " needs to "
            "be on the floor for you to splash with it.\n")
            return 0


    def do_wash(self, indirect_obs: MudObject) -> int:
            if (!can_player_get_in_it()) {
            return 0


    def query_baths(self, ) -> int:
            return 1


    def zap_bad_effects(self, who: MudObject) -> None:
            int i, flag, *enums
            class effect *effs
            dirt++
            effs = (class effect *)who.query_effs()
            enums = (int *)who.effects_matching( "body.smell" )
            i = sizeof( enums )
            if ( !random(dirt) && i ) {
            i = random( i )
            flag = 1
            write( "The antiseptic power of the soap defeats "+
            (string)effs[ enums[ i ] ]->ob_name->smell_string( who,
            effs[ enums[ i ] ]->arg ) +".\n" )
            who.delete_effect( enums[ i ] )
            dirt ++


    def __init__(self):


    def setup(self, ) -> None:
            set_name( "chime" )
            set_short( (: chimes_short() :) )
            set_long( (: chimes_long() :) )
            add_adjective( ["wind", chime_type()] )
            set_value( 420 )


    def init(self, ) -> None:
            add_command( "hang", "<direct:object'chime'> {on|from} "
            "<indirect:object'hook'>", (: do_hang( $1[0] ) :) )
            add_command( "unhang", "<direct:object'chime'>" )


    def chimes_short(self, ) -> str:
            return chime_type() + " wind chime"


    def chimes_long(self, ) -> str:
            return "This little wind chime is nothing more than bits of "
            + chime_type() + " dangling from strings tied to a "
            "ring.\n"


    def set_chime_type(self, type: str) -> None:
            remove_adjective( _chime_type )
            add_adjective( type )
            _chime_type = type


    def jingle(self, ) -> None:
            object env = environment()
            int wind
            if( !env )
            return
            if( !hung_up() )
            return
            if( !inherits( "/std/room", env ) )
            return
            wind = env.query_wind_speed()
            if( undefinedp( wind ) ) {
            if( env.query_property( "location" ) == "outside" ||
            env.query_property( "windy" ) )
            wind = WEATHER.query_windsp( self )
            else
            return


    def chime_verb(self, ) -> str:
            return " " + _chime_verbs[ random( sizeof( _chime_verbs ) ) ]


    def add_chime_verb(self, verb: str) -> None:
            _chime_verbs += [verb]


    def remove_chime_verb(self, verb: str) -> None:
            _chime_verbs -= [verb]


    def set_hung_up(self, up: int) -> None:
            remove_asyncio.create_task(self. "jingle" )
            if( up )
            asyncio.create_task(self. "jingle", 30 )
            _hung_up = up


    def init_dynamic_arg(self, arg: Any) -> None:
            set_chime_type( arg[ "type" ] )
            set_chime_verbs( arg[ "chime verbs" ] )
            set_hook( arg[ "hook" ] )
            set_hung_up( arg[ "hung up" ] )
            if( undefinedp( hook() ) || !hung_up() ||
            !sizeof( match_objects_for_existence( hook(), [environment()] ) ) ) {
            remove_property( "there" )
            set_hung_up( 0 )


    def query_dynamic_auto_load(self, ) -> Any:
            return ([ "::" : ::query_dynamic_auto_load(),
            "type" : chime_type(),
            "chime verbs" : query_chime_verbs(),
            "hung up" : hung_up(),
            "hook" : hook() ])


    def do_hang(self, hook: MudObject) -> int:
            string where = hook.a_short()
            if( hung_up() ) {
            add_failed_mess( "The chime is already hanging up.\n" )
            return 0


    def do_unhang(self, ) -> int:
            if( !hung_up() ) {
            add_failed_mess( "The chime isn't hanging from anything.\n" )
            return 0


    def chime(self, mess: str) -> None:
            int *co_ords
            if(environment(self)) {
            co_ords = (int *)environment(self)->query_co_ord()
            "/obj/handlers/broadcaster"->broadcast_event(users(), co_ords,
            mess, 20, 1, 0 )
            tell_room(environment(self), mess)


    def __init__(self):


    def get(self, dest: Any) -> int:
            if(!move_check(dest)) {
            write("You feel it would be wrong to take " + the_short() + ".\n")
            return 2


    def query_static_auto_load(self, ) -> Any:
            if ( base_name(self) + ".c" == __FILE__ ) {
            return int_query_static_auto_load()


    def __init__(self):
            self._commercial_size = 100
            self._use_types = []


    def __init__(self):
            self._commercial_size = 100
            self._use_types = []
            do_setup++
            object::create()
            furniture_base::create()
            add_alias( "furniture" )
            add_plural( "furniture" )
            add_property("talisman", "no one")
            set_opaque()
            if ( !query_property( "shop type" ) ) {
            add_property( "shop type", "furniture" )


    def set_weekly_upkeep_cost(self, cost: int) -> None:
            _weekly_upkeep_cost = cost


    def query_weekly_upkeep_cost(self, ) -> int:
            return _weekly_upkeep_cost


    def query_revenue(self, ) -> int:
            return _revenue


    def set_revenue(self, revenue: int) -> None:
            _revenue = revenue


    def query_save_dir(self, ) -> str:
            return environment()->query_save_dir()


    def query_owner(self, ) -> str:
            return environment()->query_owner()


    def query_language(self, ) -> str:
            return environment()->query_language()


    def query_money_place(self, ) -> str:
            if (!environment()) {
            return "default"


    def is_allowed(self, person: str) -> int:
            return environment()->is_allowed(person)


    def query_allowed(self, ) -> str:
            return environment()->query_allowed()


    def query_float(self, ) -> int:
            return environment()->query_royalty(query_owner())


    def query_royalty(self, person: str) -> int:
            return environment()->query_royalty(person)


    def adjust_royalty(self, person: str, amount: int) -> int:
            if (person == query_owner()) {
            _revenue += amount
            _weekly_revenue += amount


    def adjust_float(self, amt: int) -> int:
            adjust_royalty(query_owner(), amt)


    def is_open_for(self, type: str, person: str) -> int:
            if (!environment()->query_commercial_property()) {
            return 0


    def set_commercial_size(self, size: int) -> None:
            _commercial_size = size


    def query_commercial_type(self, ) -> str:
            return _commercial_type


    def set_commercial_type(self, type: str) -> None:
            _commercial_type = type


    def set_commercial_information(self, info: str) -> None:
            _info = info


    def query_commercial_information(self, ) -> str:
            return _info


    def set_commercial_name(self, name: str) -> None:
            _commercial_name = name


    def query_commercial_name(self, ) -> str:
            return _commercial_name


    def query_commercial_size(self, ) -> int:
            return _commercial_size


    def query_commercial_id(self, ) -> int:
            return _commercial_id


    def setup_new_commercial_id(self, ) -> None:
            _commercial_id = environment()->find_next_commercial_id()


    def set_commercial_id(self, id: int) -> None:
            _commercial_id = id


    def query_parcel_post(self, ) -> str:
            return environment()->query_parcel_post()


    def set_shop_use_types(self, types: Any) -> None:
            _use_types = types


    def reset_weekly_status(self, ) -> None:
            _weekly_revenue = 0


    def query_weekly_status_string(self, ) -> str:
            string ret
            string place
            place = query_money_place()
            if (query_weekly_upkeep_cost()) {
            ret = "Weekly Upkeep : " +
            MONEY_HAND.money_value_string(_weekly_upkeep_cost, place) + "\n" +
            "Weekly Revenue: " +
            MONEY_HAND.money_value_string(_weekly_revenue, place) + "\n" +
            "Profit        : " +
            MONEY_HAND.money_value_string(_weekly_revenue - _weekly_upkeep_cost, place) + "\n"
            } else {
            ret = "Weekly Revenue: " +
            MONEY_HAND.money_value_string(_weekly_revenue, place) + "\n"


    def can_trash_furniture(self, ) -> int:
            return 1


    def query_commercial_furniture(self, ) -> int:
            return 1


    def get(self, dest: Any) -> int:
            if(!move_check(dest)) {
            write("You feel it would be wrong to take " + the_short() + ".\n")
            return 2


    def do_status(self, hint: int) -> int:
            string ret
            ret = query_main_status(hint)
            write("$P$Status$P$" + ret)
            add_succeeded_mess("$N get$s the status of $D.\n")
            return 1


    def do_reset(self, ) -> int:
            string place
            int old_revenue
            place = query_money_place()
            old_revenue = _revenue
            _revenue = 0
            add_succeeded_mess("$N clear$s the revenue of " +
            MONEY_HAND.money_value_string(old_revenue, place) +
            " on $D.\n")
            return 1


    def init(self, ) -> None:
            ::init()
            if (is_allowed(this_player()->query_name())) {
            add_command("status", "<direct:object>", (: do_status, 0 :))
            add_command("status", "hints <direct:object>", (: do_status, 1 :))
            add_command("status", "hint <direct:object>", (: do_status, 1 :))
            add_command("reset", "revenue on <direct:object>", (: do_reset :))


    def query_static_auto_load(self, ) -> Any:
            if ( base_name(self) + ".c" == __FILE__ ) {
            return int_query_static_auto_load()


    def query_dynamic_auto_load(self, ) -> Any:
            mapping junk
            junk = object::query_dynamic_auto_load()
            if (!junk) {
            junk = ([ ])


    def init_dynamic_arg(self, map: Any) -> None:
            object::init_dynamic_arg(map)
            if (map) {
            set_bonded(map["bonded"])
            set_revenue(query_auto_load_value(map, OBJECT_TAG, "revenue"))
            if (query_auto_load_value(map, OBJECT_TAG, "commercial id")) {
            set_commercial_id(query_auto_load_value(map, OBJECT_TAG, "commercial id"))


    def query_help_file_directory(self, ) -> str:
            return "/doc/furniture/"


    def __init__(self):


    def init(self, ) -> None:
            if(!_window_id) {
            this_player()->add_command("hang", self,
            "<direct:object> [on|at] <indirect:object:here>")


    def do_open(self, ) -> int:
            if(!_window)
            _window = environment(self)->query_door_control(_window_id)
            if(!_window_id || !_window) {
            this_player()->add_failed_mess(self,
            "$D aren't hanging at a window.\n")
            return 0


    def do_close(self, ) -> int:
            if(!_window)
            _window = environment(self)->query_door_control(_window_id)
            if(!_window_id || !_window) {
            this_player()->add_failed_mess(self,
            "$D aren't hanging at a window.\n")
            return 0


    def do_hang(self, in_dir: Any, direct: str, indirect: str, args: Any) -> int:
            if(in_dir[0]->parse_command_id_list(.index("window") if "window" in in_dir[0]->parse_command_id_list( else -1) == -1) {
            this_player()->add_failed_mess(self,
            "You can only $V $D at windows.\n",
            [}))
            return 0


    def removed(self, ) -> None:
            self.remove_property("current room hidden")
            if(!_window)
            _window = environment(self)->query_door_control(_window_id)
            _window.set_long(_window_old_long)
            _window.set_transparent()
            _window_id = 0


    def query_static_auto_load(self, ) -> Any:
            if ( base_name(self) + ".c" == __FILE__ )
            return int_query_static_auto_load() +
            ([ "window" : _window_id,
            "window_old_long" : _window_old_long ])
            return ([ "window" : _window_id,
            "window_old_long" : _window_old_long ])


    def init_static_arg(self, map: Any) -> None:
            if ( !mapp( map ) ) {
            return


    def query_furniture_size(self, ) -> int:
            return _size + SIZE_OF_FURNITURE


    def query_commercial_id(self, ) -> int:
            if (!::query_commercial_id()) {
            setup_new_commercial_id()


    def query_exit_direction(self, ) -> str:
            return _exit_direction


    def query_exit_destination(self, ) -> str:
            return _our_room


    def create_room(self, ) -> int:
            string path
            string *bits
            string room_path
            string stuff
            path = environment()->query_save_dir()
            path += "/division" + query_commercial_id()
            if (file_size(path) == -2) {
            mkdir(path)


    def add_exit_to_room(self, ) -> None:
            environment()->add_exit(query_exit_direction(), query_exit_destination(), "door")


    def init_dynamic_arg(self, map: Any) -> None:
            _exit_direction = query_auto_load_value(map, TAG, "exit")
            _our_room = query_auto_load_value(map, TAG, "room")
            _size = query_auto_load_value(map, TAG, "size")
            ::init_dynamic_arg(map)


    def set_main_room(self, room: str) -> None:
            _main_room = room


    def query_main_room(self, ) -> str:
            return _main_room


    def query_parcel_post(self, ) -> str:
            return _main_room.query_parcel_post()


    def __init__(self):


    def query_save_dir(self, ) -> str:
            return commercial::query_save_dir() + "/" + query_commercial_id()


    def load_me(self, ) -> None:
            if (!query_commercial_id()) {
            setup_new_commercial_id()


    def save_me(self, ) -> None:
            environment()->event_save(self)


    def init(self, ) -> None:
            add_command("list", "documents [from] <direct:object>", (: do_list() :))
            add_command("view", "document <string'id'> [from] <direct:object>",
            (: do_display($4[0]) :))
            add_command("add", "documents {html|plain} called <string:quoted'title'> to <direct:object>",
            (: do_add_document($4[1], ($4[0] == "html"?DOCUMENT_HTML:DOCUMENT_PLAIN)) :))
            add_command("delete", "document <string'id'> [from] <direct:object>",
            (: do_delete_document($4[0]) :))


    def init_dynamic_arg(self, map: Any) -> None:
            document_handler::init_dynamic_arg(map)
            commercial::init_dynamic_arg(map)


    def __init__(self):


    def __init__(self):
            self.add_extra_look( self )
            add_help_file("fireplace")


    def init(self, ) -> None:
            this_player()->add_command("light", self, "<direct:object> with <indirect:object>")
            this_player()->add_command("extinguish", self, "<direct:object>", (: do_dowse :) )
            this_player()->add_command("dowse", self, "<direct:object>")
            if( this_player()->query_class_ob() == WIZARD ){
            this_player()->add_command("zap", self, "<direct:object>")
            this_player()->add_command("point", self, "[finger] at <direct:object>", (: do_zap :) )


    def do_light(self, obs: MudObject) -> int:
            string q_n
            q_n = obs[0]->query_name()
            if( _is_lit ){
            this_player()->add_failed_mess( self,
            "$D is already ablaze.\n", [}) )
            return 0


    def do_zap(self, ) -> int:
            object tp
            tp = this_player()
            if(tp.query_gp() < 10){
            await tp.send("You don't even have the energy for such a small task!\n")
            return 1


    def msg_on(self, ) -> None:
            if(_is_lit){
            tell_room(environment( self ), query_turn_on_mess() )


    def turn_on(self, ) -> int:
            int x
            FUEL_HANDLER.add_burner( self )
            _is_lit = 1
            adjust_light( query_light_produced() )
            x = query_light_produced() / 4
            add_property("degrees", query_light_produced() * 4)
            environment( self )->add_property("warmth", x )
            asyncio.create_task(self. "msg_on", 7 )
            return 1


    def do_dowse(self, obs: MudObject) -> int:
            if( !_is_lit ){
            this_player()->add_failed_mess( self,
            "There is no fire to put out.\n", [}) )
            return 0
            } else {
            this_player()->add_succeeded_mess(self,
            "$N $V $D and the room loses its warm glow.\n", [}) )
            return turn_off()


    def msg_off(self, ) -> None:
            if(!_is_lit){
            tell_room(environment( self ), query_turn_off_mess() )


    def turn_off(self, ) -> int:
            FUEL_HANDLER.remove_burner( self )
            _is_lit = 0
            adjust_light( -query_light_produced() )
            add_property( "degrees", 0 )
            environment( self )->remove_property("warmth")
            asyncio.create_task(self. "msg_off", 10 )
            return 1


    def out_of_fuel(self, ) -> None:
            turn_off()
            tell_room(environment( self ), query_out_of_fuel_mess() )


    def add_lit_chat(self, str: str) -> None:
            if( !_lit_chats ){
            _lit_chats = [})


    def request_lit_chat(self, ) -> str:
            return _lit_chats[random( sizeof(_lit_chats) - 1 )]


    def add_dying_chat(self, str: str) -> None:
            if( !_dying_chats ){
            _dying_chats = [})


    def request_dying_chat(self, ) -> str:
            return _dying_chats[random( sizeof(_dying_chats) - 1 )]


    def consume_fuel(self, ) -> None:
            int x
            int q
            int z
            int w
            int amount
            string r
            object *inv
            object ashes
            object thing
            object env
            inv = filter(all_inventory( self ),
            (:$1.query_property("fuel") :))
            if( !inv || inv == [}) || calc_fuel() < 1){
            out_of_fuel()
            return


    def calc_fuel(self, ) -> int:
            object *inv
            object thing
            int tot_fuel = 0
            int w
            int amt
            inv = all_inventory( self )
            if( !inv || inv == [}) ) { return 0; }
            foreach(thing in inv){
            if( thing.query_property("fuel") ){
            w =  thing.query_weight()
            amt = thing.query_amount_left()
            tot_fuel += w * amt * K / 100


    def test_remove(self, thing: MudObject, flat: int, dest: Any) -> int:
            object tp
            object *prev
            tp = this_player()
            prev = previous_object(-1)
            if(_is_lit && tp && strsrch( file_name(prev[1]), CMD ) != -1 ){
            tell_object(tp, "You reach out towards the fire but "
            "you can't brave the flames and quickly pull away.\n")
            tell_room( environment(tp), tp.query_short() + " tries to take something "
            "from the fire but pulls back sucking " + tp.query_possessive() +
            " fingers.\n", tp)
            tp.adjust_hp( -random(120) )
            return 0


    def test_add(self, thing: MudObject, flag: int) -> int:
            if( !thing.query_property("fuel") && environment(thing) ){
            await this_player().send("You don't think " + thing.the_short() +
            " would be a suitable fuel.\n")
            return 0


    def extra_look(self, ob: MudObject) -> str:
            if( _is_lit ) {
            return query_lit_mess()


    def pre_dest_me(self, ) -> None:
            int tmp
            if(_is_lit && environment()) {
            FUEL_HANDLER.remove_burner( self )
            _is_lit = 0
            adjust_light( -query_light_produced() )
            tmp = environment()->query_property("warmth")
            if(tmp > query_light_produced() / 4)
            environment()->add_property("warmth", tmp -
            (query_light_produced() / 4))
            else
            environment()->remove_property("warmth")


    def dest_me(self, ) -> None:
            FUEL_HANDLER.remove_burner( self )
            _is_lit = 0
            ::dest_me()


    def __init__(self):
            self._amount = 100


    def __init__(self):
            self._amount = 100
            set_short( (: fuel_short :) )
            set_long( (: fuel_long :) )
            add_property("no recycling", 1)
            add_property("fuel", 1)


    def fuel_short(self, ) -> str:
            int i
            int x
            x = sizeof(_shorts)
            for(i = 1; i <= x; i++){
            if( (_amount + 1) > 100 - ( i * 100 / x ) ){
            return _shorts[(i-1)]


    def fuel_long(self, ) -> str:
            int i
            int x
            x = sizeof(_longs)
            for(i = 1; i <= x; i++){
            if( ( _amount + 1 ) > ( 100 - ( i * 100 / x )) ){
            return _longs[(i-1)]


    def query_dynamic_auto_load(self, ) -> Any:
            return ([ "::" : ::query_dynamic_auto_load(),
            "amount" : _amount
            ])


    def init_dynamic_arg(self, arg: Any) -> None:
            _amount = arg[ "amount" ]
            ::init_dynamic_arg(arg["::"])


    def __init__(self):
            self._drawer_mess = "a drawer in $ob_short$"
            self._drawers = []
            self._on_top = []


    def add_drawer(self, type: str, amount: int) -> None:
            if ( !type || ( type == "" ) || ( amount < 1 ) ) {
            return


    def query_drawers_inside(self, ) -> int:
            varargs int move( mixed dest, string messin, string messout ) {
            int i, w
            object from
            w = (int)self.query_complete_weight() * 5
            if ( from = environment() ) {
            from.add_weight( -w )


    def long(self, word: str, dark: int) -> str:
            int i
            string ret, *sizes
            mapping types
            ret = ::long( word, dark )
            if ( sizeof( _drawers ) && !dark &&
            (!query_closed() || !_drawers_inside)) {
            types = ([ ])
            for ( i = 0; i < sizeof( _drawers ); i += 2 ) {
            types[ _drawers[ i ] ]++


    def test_remove(self, thing: MudObject, flag: int, dest: Any) -> int:
            int result
            mixed *stuff
            result = ::test_remove(thing, flag, dest)
            if(result) {
            stuff = thing.query_property("dropped")
            if(environment() &&
            dest == this_player() &&
            function_exists("test_occupier", environment()) &&
            !environment()->test_occupier(this_player()->query_name()) &&
            (!sizeof(stuff) || stuff[0] != this_player()->query_name())) {
            event(environment(this_player()), "theft", this_player(), self,
            [thing])


    def test_add(self, thing: MudObject, flag: int) -> int:
            int i
            int result
            if ( flag )
            return 0
            if(!environment(thing))
            return 1
            result = ::test_add(thing, flag)
            if(!result)
            return 0
            if("/cmds/living/put"->query_con() == "on" && _has_surface) {
            _on_top += [thing]
            thing.add_property("_on_top", 1)
            } else if(sizeof(_drawers)) {
            if ( !_biggest )
            for ( i = 0; i < sizeof( _drawers ); i+= 2 )
            if ( _drawers[ i + 1 ] > _biggest )
            _biggest = _drawers[ i + 1 ]
            if ( (int)thing.query_complete_weight() > _biggest )
            return write( (string)thing.the_short() +" is too big "+
            "to fit in any of "+ the_short() +"'s drawers.\n" )


    def pick_unlock(self, player: MudObject) -> int:
            mixed owner
            if(!environment())
            return ::pick_unlock(player)
            if(!environment() || !function_exists("query_owner", environment()))
            return ::pick_unlock(player)
            owner = environment()->query_owner()
            if(stringp(owner) && pk_check(player, owner, 1)) {
            write("You feel it would be wrong to try to break into "+
            self.query_short() + ".\n")
            return 0


    def init_static_arg(self, map: Any) -> None:
            if ( !mapp( map ) )
            return
            if ( map[ "::" ] )
            ::init_static_arg( map[ "::" ] )
            if ( !undefinedp( map[ "drawer mess" ] ) )
            _drawer_mess = map[ "drawer mess" ]
            if ( !undefinedp( map[ "drawers" ] ) )
            _drawers = map[ "drawers" ]
            if(!undefinedp(map["allowed_positions"]))
            set_allowed_positions( map["allowed_positions"])
            if(!undefinedp(map["trap"]))
            setup_trap(map["trap"][0],
            map["trap"][1],
            map["trap"][2],
            map["trap"][3],
            map["trap"][4])
            if(!undefinedp(map["trap armed"]))
            set_trap_armed(map["trap armed"])


    def init_dynamic_arg(self, bing: Any) -> None:
            object item
            ::init_dynamic_arg(bing)
            foreach(item in all_inventory(self)) {
            if(item.query_property("_on_top"))
            _on_top += [item]


    def query_help_file_directory(self, ) -> str:
            return "/doc/furniture/"


    def __init__(self):


    def extra_look(self, ob: MudObject) -> str:
            int dark
            object env
            env = environment(ob)
            if(living(env))
            return "You can see yourself in the mirror."
            dark = (int) this_player()->check_dark((int)env.query_light())
            if(dark)
            return "It is too dark to see much in the room."
            return "Reflected in the mirror is " +
            query_multiple_short(all_inventory(env) - [ob], "a", 0, 1, dark) +
            "."


    def __init__(self):
            self._ante_house = 400
            self._ante_amount = 400
            self._min_bet = 400
            self._max_bet = 1200
            self._max_draw_rounds = 1
            self._player_stats = ([ ])


    def query_hand_type_string(self, hand_type: Any) -> str:
            string ret
            switch (bing->hand_type) {
            case HAND_TYPE_FULL_HOUSE :
            ret = "Full house"
            break
            case HAND_TYPE_THREE :
            ret = "Three of a kind"
            break
            case HAND_TYPE_FLUSH :
            ret = "Flush"
            break
            case HAND_TYPE_STRAIGHT :
            ret = "Straight"
            break
            case HAND_TYPE_STRAIGHT_FLUSH :
            ret = "Straight flush"
            break
            case HAND_TYPE_PAIR :
            ret = "Pair"
            break
            case HAND_TYPE_FOUR :
            ret = "Four of a kind"
            break
            case HAND_TYPE_TWO_PAIR :
            ret = "Two pairs"
            break
            case HAND_TYPE_HIGH_CARD :
            ret = "High card " + query_card_string(bing->high_card)
            break
            default :
            ret = "Nothing"
            break


    def query_card_status(self, id: str) -> str:
            string id_bing
            string ret
            string* not_playing
            class player_data data
            string* womble
            string place
            int left
            ret = ""
            not_playing = [})
            womble = query_player_ids()
            place = query_money_place()
            foreach (id_bing in womble) {
            if (is_person_playing(id_bing)) {
            ret += capitalize(id_bing) + " (" +
            query_player_cap_name(id_bing) + ")"
            data = query_player_data(id_bing)
            if (data) {
            if (data->state == POKER_STATE_FOLDED) {
            ret += " Folded!\n"
            } else {
            if (data->state == POKER_STATE_PAID_ANTE) {
            ret += " (paid ante) "


    def long(self, str: str, dark: int) -> str:
            if (dark) {
            return ::long() +
            "It is too dark to make out the pieces on the board.\n"


    def check_end_round(self, ) -> int:
            int bet
            string id
            class player_data data
            foreach (id in query_started_player_ids()) {
            data = query_player_data(id)
            if (data->state != POKER_STATE_FOLDED) {
            if (!data->bet) {
            return 0
            } else if (!bet && data->bet) {
            bet = data->bet
            } else if (bet != data->bet) {
            return 0


    def next_person_turn(self, ) -> None:
            class player_data data
            string start_id
            start_id = query_current_player()
            do {
            increment_current_player()
            data = query_player_data(query_current_player())
            } while (data->state == POKER_STATE_FOLDED &&
            query_current_player() != start_id)
            if (query_current_player() == start_id) {
            printf("Force end of game.\n")
            asyncio.create_task(self."complete_round", 2, 1)
            _poker_phase = POKER_STATE_END
            } else {
            asyncio.create_task(self."tell_current_player", 0, "%^BOLD%^Your turn!%^RESET%^\n")


    def deal_cards(self, ) -> None:
            string id
            class player_data data
            _deck = make_deck(1, 0)
            _deck = shuffle_deck(_deck)
            foreach (id in query_currently_playing_ids()) {
            data = query_player_data(id)
            data->hand = sort_cards(_deck[0..4], 3)
            data->bet = 0
            if (data->state != POKER_STATE_FOLDED) {
            if (!_max_draw_rounds) {
            data->state = POKER_STATE_FINAL_BET
            } else {
            data->state = POKER_STATE_BET


    def start_game(self, ) -> int:
            class player_data data
            string id
            randomise_player_numbers()
            if (!::start_game()) {
            return 0


    def check_for_finish_ante(self, ) -> None:
            string id
            class player_data data
            object ob
            foreach (id in query_currently_playing_ids()) {
            data = query_player_data(id)
            ob = query_player_object(id)
            if (ob && !interactive(ob)) {
            data->state = POKER_STATE_FOLDED


    def is_card_higher(self, playing_card: Any, playing_card: Any) -> int:
            if (card_new->number == card_old->number) {
            return 0


    def test_hand_type(self, ) -> None:
            class playing_card* other_tmp_hand
            class playing_card* tmp_hand
            other_tmp_hand = [new(class playing_card, suit: CARD_SUIT_HEARTS, number : 11),
            new(class playing_card, suit: CARD_SUIT_HEARTS, number : 11),
            new(class playing_card, suit: CARD_SUIT_HEARTS, number : 12),
            new(class playing_card, suit: CARD_SUIT_HEARTS, number : 13),
            new(class playing_card, suit: CARD_SUIT_HEARTS, number : 13)]
            tmp_hand = [new(class playing_card, suit: CARD_SUIT_HEARTS, number : 2),
            new(class playing_card, suit: CARD_SUIT_HEARTS, number : 3),
            new(class playing_card, suit: CARD_SUIT_HEARTS, number : 4),
            new(class playing_card, suit: CARD_SUIT_HEARTS, number : 1),
            new(class playing_card, suit: CARD_SUIT_HEARTS, number : 5)]
            write(query_hand_type_string(query_hand_type(tmp_hand)) + " --\n" +
            query_hand_type_string(query_hand_type(other_tmp_hand)))
            printf("%O\n", sizeof(query_hand_type(tmp_hand)->kickers))
            printf("%O\n", sizeof(query_hand_type(other_tmp_hand)->kickers))
            write("Result: " + is_greator_hand(query_hand_type(tmp_hand),
            query_hand_type(other_tmp_hand)) + "\n")


    def complete_round(self, force_end: int) -> None:
            string stuff
            object ob
            class player_data data
            string id
            string place
            string* winner
            class hand_type winning_hand_type
            class playing_card* winning_hand
            int paid
            int discard
            int result
            int num
            if (_finished) {
            return 0


    def finish_discard(self, ) -> None:
            string id
            class player_data data
            foreach (id in query_started_player_ids()) {
            data = query_player_data(id)
            if (data->state != POKER_STATE_AFTER_DISCARD &&
            data->state != POKER_STATE_FOLDED) {
            return 0


    def do_ante(self, ) -> int:
            string place
            string id
            int amount
            class player_data data
            if (!is_game_started()) {
            add_failed_mess("The game has not started.\n")
            return 0


    def do_discard(self, throw_away: str) -> int:
            int i
            string id
            class player_data data
            string* bits
            int* new_bits
            throw_away = lower_case(throw_away)
            if (!is_game_started()) {
            add_failed_mess("The game has not started.\n")
            return 0


    def do_check(self, ) -> int:
            if (!is_game_started()) {
            add_failed_mess("The game has not started.\n")
            return 0


    def do_call(self, ) -> int:
            class player_data data
            int amt
            string place
            if (!is_game_started()) {
            add_failed_mess("The game has not started.\n")
            return 0


    def do_raise(self, amount: str) -> int:
            class player_data data
            string place
            int amt
            int raise_amt
            if (!is_game_started()) {
            add_failed_mess("The game has not started.\n")
            return 0


    def do_bet(self, amount: str) -> int:
            class player_data data
            string place
            int amt
            int raise_amt
            if (!is_game_started()) {
            add_failed_mess("The game has not started.\n")
            return 0


    def do_fold(self, ) -> int:
            class player_data data
            string id
            int not_folded
            if (!is_game_started()) {
            add_failed_mess("The game has not started.\n")
            return 0


    def do_start(self, ) -> int:
            int old_pot
            if (!is_open_for("poker", this_player()->query_name())) {
            add_failed_mess("The poker table is not open.\n")
            return 0


    def do_finish(self, ) -> int:
            string person
            if (!is_game_started()) {
            add_failed_mess("The game has not started.\n")
            return 0


    def query_main_status(self, hint: int) -> str:
            string place
            string ret
            string name
            int amt
            place = query_money_place()
            ret = "$I$0=Poker table:\n"
            "$I$6=   Maximum bet: " +
            MONEY_HAND.money_value_string(_max_bet, place) +
            "\n$I$6=   Minimum bet: " +
            MONEY_HAND.money_value_string(_min_bet, place) +
            "\n$I$6=   Ante       : " +
            MONEY_HAND.money_value_string(_ante_amount, place) +
            "\n$I$6=   House Ante : " +
            MONEY_HAND.money_value_string(_ante_house, place) +
            "\n$I$6=   Draw Rounds: " + _max_draw_rounds +
            "\n$I$6=   Cut        : " + _house_cut + "%"
            "\n$I$6=   Revenue    : " +
            MONEY_HAND.money_value_string(query_revenue(), place) +
            "\n$I$0="
            foreach (name, amt in _player_stats) {
            ret += sprintf(" %-13s: %s\n" , name,
            MONEY_HAND.money_value_string(amt, place))


    def do_set_ante(self, str: str, ante_game: int) -> int:
            string place
            int value
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to change the paramaters of "
            "$D.\n")
            return 0


    def do_set_bet(self, str: str, max_bet: int) -> int:
            string place
            int value
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to change the paramaters of "
            "$D.\n")
            return 0


    def do_set_cut(self, percent: int) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to change the paramaters of "
            "$D.\n")
            return 0


    def do_set_draw(self, draw: int) -> int:
            if (!is_allowed(this_player()->query_name())) {
            add_failed_mess("You are not allowed to change the paramaters of "
            "$D.\n")
            return 0


    def do_rules(self, ) -> int:
            string ret
            string place
            place = query_money_place()
            ret = "The rules for this table are:\n"
            ret += "$I$6=   Maximum amount that can be raised " +
            MONEY_HAND.money_value_string(_max_bet, place) +
            "\n$I$6=   Minimum amount that can be raised " +
            MONEY_HAND.money_value_string(_min_bet, place) +
            "\n$I$6=   Total ante " +
            MONEY_HAND.money_value_string(_ante_amount + _ante_house, place) +
            "\n$I$6=   Cut of the pool : " + _house_cut +
            "\n$I$6=   Draw Rounds     : " + _max_draw_rounds +
            "\n$I$6=   House Ante      : " +
            MONEY_HAND.money_value_string(_ante_house, place)
            write("$P$Rules$P$" + ret)


    def do_reset(self, ) -> int:
            if (::do_reset()) {
            _player_stats = ([ ])
            add_succeeded_mess("$N clear$s the player stats.\n")
            return 1


    def init(self, ) -> None:
            multiplayer_base::init()
            commercial::init()
            add_command("discard", "<string'card'> on <direct:object>",
            (: do_discard($4[0]) :))
            add_command("ante", "on <direct:object>",
            (: do_ante() :))
            add_command("check", "on <direct:object>",
            (: do_check() :))
            add_command("call", "on <direct:object>",
            (: do_call() :))
            add_command("bet", "<string'total bet'> on <direct:object>",
            (: do_bet($4[0]) :))
            add_command("raise", "<string'raise'> on <direct:object>",
            (: do_raise($4[0]) :))
            add_command("fold", "on <direct:object>",
            (: do_fold() :))
            add_command("finish", "game on <direct:object>",
            (: do_finish() :))
            add_command("start", "game on <direct:object>",
            (: do_start() :))
            add_command("rules", "<direct:object>",
            (: do_rules() :))
            add_command("rules", "{for|on|of} <direct:object>",
            (: do_rules() :))
            if (environment()->is_allowed(this_player()->query_name())) {
            add_command("set", "draw <number'rounds'> on <direct:object>",
            (: do_set_draw($4[0]) :))
            add_command("set", "cut <number'percentage'> on <direct:object>",
            (: do_set_cut($4[0]) :))
            add_command("set", "ante house <string'amount|none'> on <direct:object>",
            (: do_set_ante($4[0], 0) :))
            add_command("set", "ante game <string'amount'> on <direct:object>",
            (: do_set_ante($4[0], 1) :))
            add_command("set", "minimum bet <string'amount'> on <direct:object>",
            (: do_set_bet($4[0], 0) :))
            add_command("set", "maximum bet <string'amount'> on <direct:object>",
            (: do_set_bet($4[0], 1) :))


    def resign_person(self, id: str) -> None:
            class player_data data
            int not_folded
            data = query_player_data(id)
            if (data && data->state != POKER_STATE_FOLDED) {
            tell_all_players(query_player_cap_name(id) +
            " resigns and folds.\n")
            data->state = POKER_STATE_FOLDED
            foreach (id in query_started_player_ids()) {
            data = query_player_data(id)
            if (data->state != POKER_STATE_FOLDED) {
            not_folded++


    def event_exit(self, ob: MudObject, mess: str, to: MudObject) -> None:
            string id
            if (userp(ob) && to != environment()) {
            id = find_player_id_of_person(ob)
            if (id) {
            resign_person(id)


    def multiplayer_someone_resigns(self, id: str, name: str) -> None:
            resign_person(id)


    def init_dynamic_arg(self, map: Any, player: MudObject) -> None:
            commercial::init_dynamic_arg(map, player)
            multiplayer_base::init_dynamic_arg(map, player)
            _return = query_auto_load_value(map, BOARD_TAG, "return")
            _ante_amount = query_auto_load_value(map, BOARD_TAG, "ante amount")
            _ante_house = query_auto_load_value(map, BOARD_TAG, "ante house")
            _house_cut = query_auto_load_value(map, BOARD_TAG, "house cut")
            _deck = query_auto_load_value(map, BOARD_TAG, "deck")
            _current_bet = query_auto_load_value(map, BOARD_TAG, "current bet")
            _pot = query_auto_load_value(map, BOARD_TAG, "pot")
            _min_bet = query_auto_load_value(map, BOARD_TAG, "min bet")
            _max_bet = query_auto_load_value(map, BOARD_TAG, "max bet")
            _poker_phase = query_auto_load_value(map, BOARD_TAG, "poker phase")
            _draw_round = query_auto_load_value(map, BOARD_TAG, "draw round")
            _max_draw_rounds = query_auto_load_value(map, BOARD_TAG, "max draw rounds")
            _discard = query_auto_load_value(map, BOARD_TAG, "discard")
            _player_stats = query_auto_load_value(map, BOARD_TAG, "player stats")
            if (!_player_stats) {
            _player_stats = ([ ])


    def __init__(self):


    def query_player_craft_shop(self, ) -> int:
            return 1


    def disallow_sale_here(self, room: MudObject) -> int:
            object* obs
            obs = room.find_commercial_items(query_commercial_name())
            return sizeof(obs)


    def query_royalty(self, person: str) -> int:
            return commercial::query_royalty(person)


    def query_craft_shop_save_dir(self, ) -> str:
            return environment()->query_save_dir() + "craft_shop"


    def adjust_royalty(self, person: str, amount: int) -> None:
            commercial::adjust_royalty(person, amount)


    def query_parcel_post(self, ) -> str:
            return commercial::query_parcel_post()


    def reset_weekly_status(self, ) -> None:
            player_craft_shop_base::reset_weekly_status()


    def query_weekly_status_string(self, ) -> str:
            return player_craft_shop_base::query_weekly_status_string()


    def load_me(self, ) -> None:
            string fname, tmp
            #ifdef USE_RAMDISK
            tmp = replace_string(query_save_dir() + "craft_shop_file", "/save/",
            "/save/ramdisk/")
            if(unguarded((: file_size($(tmp) = ".o.gz") :)) > 0 ||
            unguarded((: file_size($(tmp) = ".o") :)) > 0) {
            fname = tmp


    def init(self, ) -> None:
            player_craft_shop_base::init()
            commercial::init()


    def do_save(self, ) -> None:
            string fname
            string dir
            _save_call = 0
            if (environment() && query_save_dir()) {
            #ifdef USE_RAMDISK
            dir = replace_string(query_save_dir(), "/save/",
            "/save/ramdisk/")
            if (file_size(dir) == -2) {
            fname = dir + "craft_shop_file"


    def dest_me(self, ) -> None:
            do_save()
            player_craft_shop_base::dest_me()
            commercial::dest_me()


    def query_commercial_information(self, ) -> str:
            return "This shop can have a maximum of " + query_maximum_inventory_size() +
            " items for sale.  "
            "You can only have "
            "one shop counter in any room, more than one will not be "
            "able to be bought."


    def event_save(self, ob: MudObject) -> None:
            if (!_save_call) {
            if(_last_saved > time() - SAVE_TIME) {
            _save_call = asyncio.create_task(self."do_save", SAVE_TIME - (time() - _last_saved))
            } else {
            _save_call = asyncio.create_task(self."do_save", SAVE_TIME)


    def set_commercial_option(self, type: str, name: str) -> None:
            string* bits
            int size
            switch (type) {
            case "counter type" :
            _counter_short = name
            set_short(_counter_short)
            bits = explode(lower_case(_counter_short), " ")
            add_adjective(bits[0..<2])
            add_alias(bits[<1])
            break
            case "stockroom size" :
            sscanf(name, "%d", size)
            set_maximum_waiting_queue_size(size)
            break


    def init_dynamic_arg(self, map: Any, player: MudObject) -> None:
            string* bits
            int size
            commercial::init_dynamic_arg(map, player)
            size = query_auto_load_value(map, OBJECT_TAG, "stocksize")
            _counter_short = query_auto_load_value(map, OBJECT_TAG, "counter short")
            if (size) {
            set_maximum_waiting_queue_size(size)


    def __init__(self):


    def extra_look(self, ) -> str:
            object *stuff
            string answer = ""
            stuff = all_inventory( self )
            if (water) {
            if (dirt >= sizeof(dirt_messages)) {
            dirt = sizeof(dirt_messages) - 1


    def long_status(self, ) -> str:
            return ""


    def init(self, ) -> None:
            ::init()
            add_command( "fill", "<direct:object>")
            add_command( "empty", "<direct:object>")
            add_command( "splash", "<indirect:living:here>")
            add_command( "wash", "<indirect:living:here>")


    def wet_everyone_in(self, ) -> None:
            object *victims
            if (!water) {
            return


    def reset(self, ) -> None:
            wet_everyone_in()


    def do_fill(self, ) -> int:
            object player
            player=this_player()
            if (water) {
            player.add_failed_mess(self, "The " + self->short() + " is "
            "already full of water.\n")
            return 0


    def do_empty(self, ) -> int:
            object player
            player=this_player()
            if (!water) {
            player.add_failed_mess(self, "The " + self->short() + " is "
            "already as empty as it gets.\n")
            return 0


    def do_splash(self, indirect_obs: MudObject) -> int:
            if (!water) {
            this_player()->add_failed_mess(self, "It's not a bad idea,  "
            "but maybe you'd need some water in the " + self.short() +
            "before you can splash.\n")
            return 0


    def do_wash(self, indirect_obs: MudObject) -> int:
            if (!water) {
            this_player()->add_failed_mess(self, "It's not a bad idea,  "
            "but maybe you'd need some water in the " + self.short() +
            "before you can wash.\n")
            return 0


    def zap_bad_effects(self, who: MudObject) -> None:
            int i, flag, *enums
            class effect *effs
            dirt++
            effs = (class effect *)who.query_effs()
            enums = (int *)who.effects_matching( "body.smell" )
            i = sizeof( enums )
            if ( !random(dirt) && i ) {
            i = random( i )
            flag = 1
            write( "The antiseptic power of the soap defeats "+
            (string)effs[ enums[ i ] ]->ob_name->smell_string( who,
            effs[ enums[ i ] ]->arg ) +".\n" )
            who.delete_effect( enums[ i ] )
            dirt ++


    def __init__(self):
            self._drawer_mess = "a drawer in $ob_short$"
            self._drawers = []


    def add_drawer(self, type: str, amount: int) -> None:
            if ( !type || ( type == "" ) || ( amount < 1 ) ) {
            return


    def query_drawers_inside(self, ) -> int:
            varargs int move( mixed dest, string messin, string messout ) {
            int i, w
            object from
            if (!move_check(dest)) {
            write(the_short() + " resists being picked up and shocks you slightly.\n")
            return MOVE_INVALID_DEST


    def get(self, dest: Any) -> int:
            if(!move_check(dest)) {
            write("You feel it would be wrong to take " + the_short() + ".\n")
            return 2


    def long(self, word: str, dark: int) -> str:
            int i
            string ret, *sizes
            mapping types
            ret = ::long( word, dark )
            if ( sizeof( _drawers ) && !dark &&
            (!query_closed() || !_drawers_inside)) {
            types = ([ ])
            for ( i = 0; i < sizeof( _drawers ); i += 2 ) {
            types[ _drawers[ i ] ]++


    def test_remove(self, thing: MudObject, flag: int, dest: Any) -> int:
            int result
            mixed *stuff
            object thief
            result = ::test_remove(thing, flag, dest)
            if(result && environment() && this_player()) {
            thief = this_player()
            if(thief.query_caster())
            thief = find_player(thief.query_caster())
            else if(thief.query_owner())
            thief = thief.query_owner()
            stuff = thing.query_property("dropped")
            if(function_exists("test_occupier", environment()) &&
            !environment()->test_occupier(thief.query_name()) &&
            (!sizeof(stuff) || stuff[0] != thief.query_name()) &&
            thief && environment(thief)) {
            event(environment(thief), "theft", thief, self, [thing])


    def test_add(self, thing: MudObject, flag: int) -> int:
            int i
            if ( flag )
            return 0
            if(!environment(thing))
            return 1
            if(sizeof(_drawers)) {
            if ( !_biggest )
            for ( i = 0; i < sizeof( _drawers ); i+= 2 )
            if ( _drawers[ i + 1 ] > _biggest )
            _biggest = _drawers[ i + 1 ]
            if ( (int)thing.query_complete_weight() > _biggest )
            return write( (string)thing.the_short() +" is too big "+
            "to fit in any of "+ the_short() +"'s drawers.\n" )


    def pick_unlock(self, player: MudObject) -> int:
            if(!pick_ok(player))
            return 0
            return ::pick_unlock(player)


    def pick_lock(self, player: MudObject) -> int:
            if(!pick_ok(player))
            return 0
            return ::pick_lock(player)


    def init_static_arg(self, map: Any) -> None:
            if ( !mapp( map ) )
            return
            if ( map[ "::" ] )
            ::init_static_arg( map[ "::" ] )
            if ( !undefinedp( map[ "drawer mess" ] ) )
            _drawer_mess = map[ "drawer mess" ]
            if ( !undefinedp( map[ "drawers" ] ) )
            _drawers = map[ "drawers" ]
            if(!undefinedp(map["allowed_positions"]))
            set_allowed_positions(map["allowed_positions"])
            if(!undefinedp(map["trap"]))
            setup_trap(map["trap"][0],
            map["trap"][1],
            map["trap"][2],
            map["trap"][3],
            map["trap"][4])
            if(!undefinedp(map["trap armed"]))
            set_trap_armed(map["trap armed"])


    def query_help_file_directory(self, ) -> str:
            return "/doc/furniture/"


    def query_dynamic_auto_load(self, ) -> Any:
            mapping junk
            junk = cont_save::query_dynamic_auto_load()
            if (!junk) {
            junk = ([ ])


    def init_dynamic_arg(self, map: Any, object) -> None:
            cont_save::init_dynamic_arg(map, 0)
            set_bonded(map["bonded"])


    def __init__(self):


    def init(self, ) -> None:
            string alias
            if(_aliases)
            foreach(alias in _aliases) {
            add_command(alias, "<indirect:object:me> {in|on|into} <indirect:object>",
            (: "/cmds/living/put"->cmd($1, $3, $4) :) )


    def set_put_aliases(self, aliases: str) -> None:
            _aliases = aliases


    def set_allow_use_internals(self, allow: int) -> None:
            _use_internals = allow


    def query_allow_use_internals(self, ) -> int:
            return _use_internals


    def get(self, dest: Any) -> int:
            if(!move_check(dest)) {
            write("You feel it would be wrong to take " + the_short() + ".\n")
            return 2


    def test_remove(self, thing: MudObject, flag: int, dest: Any) -> int:
            mixed *stuff
            object thief
            if(environment() && this_player()) {
            thief = this_player()
            if(thief.query_caster())
            thief = find_player(thief.query_caster())
            else if(thief.query_owner())
            thief = thief.query_owner()
            stuff = thing.query_property("dropped")
            if(function_exists("test_occupier", environment()) &&
            !environment()->test_occupier(thief.query_name()) &&
            (!sizeof(stuff) || stuff[0] != thief.query_name()) &&
            thief && environment(thief)) {
            event(environment(thief), "theft", thief, self, [thing])


    def test_add(self, thing: MudObject, flag: int) -> int:
            if(environment())
            event(environment(), "save")
            #ifdef DEBUG
            if(environment() && base_name(environment()) != "/room/rubbish")
            log_file(base_name(environment()) + ".log",
            "%s %s put on %s by %s.\n", ctime(time())[4..18],
            thing.query_short(), self.query_short(),
            this_player() ? this_player()->query_name() : "Unknown")
            #endif
            return 1


    def update_loc_weight(self, ) -> None:
            int i
            object *contents
            _loc_weight = 0
            contents = all_inventory( self )
            for ( i = 0; i < sizeof( contents ); i++ )
            _loc_weight += (int)contents[ i ]->query_complete_weight()


    def query_complete_weight(self, ) -> int:
            return ::query_complete_weight() + query_loc_weight()


    def add_weight(self, n: int) -> int:
            if ( !_max_weight ) return 1
            if ( n + _loc_weight > _max_weight ) return 0
            if ( !environment() ) {
            _loc_weight += n
            return 1


    def transfer_all_to(self, dest: MudObject) -> int:
            object *ob
            int i
            ob = all_inventory(self)
            for (i=0;i<sizeof(ob);i++)
            ob[i]->move(dest)
            if (first_inventory(self)) return 0
            return 1


    def long(self, word: str, dark: int) -> str:
            object *things
            things = (object *)self.find_inv_match( "all", this_player() )
            if ( !sizeof( things ) )
            return object::long( word, dark ) +"There is nothing on "+
            the_short() +".\n"
            return object::long( word, dark ) + query_contents( "On " +
            the_short() +" "+ ( sizeof( things ) == 1 ? "is " :
            "are " ), things )


    def stats(self, ) -> Any:
            return ::stats() + ({
            ["loc_weight", query_loc_weight(),],
            ["max_weight", query_max_weight(),],
            })


    def handle_restore_inventory(self, ob: MudObject) -> int:
            return (int)ob.move(self)


    def init_dynamic_arg(self, bing: Any) -> None:
            function f
            if ( bing[ "::" ] ) {
            ::init_dynamic_arg( bing[ "::" ] )


    def init_static_arg(self, bing: Any) -> None:
            if (bing["::"]) {
            ::init_static_arg(bing["::"])


    def query_static_auto_load(self, ) -> Any:
            if ( base_name(self) + ".c" == __FILE__ )
            return int_query_static_auto_load()
            return ([ ])


    def dest_me(self, ) -> None:
            int i
            object shadow
            for ( i = 0; i < sizeof( _shadows ); i++ ) {
            if ( shadow = find_object( _shadows[ i ] ) ) {
            shadow.destruct_shadow( shadow )


    def query_help_file_directory(self, ) -> str:
            return "/doc/furniture/"


    def __init__(self):


    def init(self, ) -> None:
            item_chat::init()


    def get(self, dest: Any) -> int:
            if(!move_check(dest)) {
            write("You feel it would be wrong to take " + the_short() + ".\n")
            return 2


    def query_static_auto_load(self, ) -> Any:
            if ( base_name(self) + ".c" == __FILE__ ) {
            return int_query_static_auto_load()


    def query_dynamic_auto_load(self, ) -> Any:
            mapping junk
            junk = vessel::query_dynamic_auto_load()
            if (!junk) {
            junk = ([ ])


    def init_dynamic_arg(self, map: Any) -> None:
            vessel::init_dynamic_arg(map)
            set_bonded(map["bonded"])


    def query_help_file_directory(self, ) -> str:
            return "/doc/furniture/"


    def __init__(self):
            self._documents = ([ ])


    def query_document_file_name(self, id: str) -> str:
            if (_documents[id]) {
            return query_save_dir() + "/" + _documents[id]->fname


    def query_document_data(self, id: str) -> str:
            string fname
            fname = query_document_file_name(id)
            if (fname) {
            return unguarded( (: read_file($(fname)) :) )


    def is_document(self, id: str) -> int:
            return _documents[id] != 0


    def query_document_readable(self, id: str) -> str:
            string fname
            string text
            fname = query_document_file_name(id)
            if (fname) {
            switch (_documents[id]->type) {
            case DOCUMENT_PLAIN :
            text = unguarded( (: read_file($(fname)) :) )
            break
            case DOCUMENT_HTML :
            text = unguarded( (: NROFF_HAND.cat_file($(fname) + ".nroff", 1) :) )
            if (!text) {
            text = unguarded( (: read_file( $(fname)) :) )
            if (text) {
            text = NEWSPAPER_HANDLER.convert_html(text)
            unguarded( (: write_file($(fname) + ".proc", $(text), 1) :) )
            if (unguarded( (: NROFF_HAND.create_nroff($(fname) + ".proc",
            $(fname) + ".nroff")
            :) )) {
            text = unguarded( (: NROFF_HAND.cat_file($(fname) +
            ".nroff") :) )
            } else {
            text = "Unable to make nroff file.\n"


    def query_document_html(self, id: str) -> str:
            string fname
            string text
            fname = query_document_file_name(id)
            if (fname) {
            switch (_documents[id]->type) {
            case DOCUMENT_PLAIN :
            text = unguarded( (: read_file($(fname)) :) )
            text = replace(fname, ["&", "&amp;", "<", "&lt;", ">", "&gt;",
            " ", "&nbsp;", "\n", "<br>"] )
            break
            case DOCUMENT_HTML :
            text = unguarded( (: read_file($(fname)) :) )
            if (!text) {
            text = unguarded( (: read_file( $(fname)) :) )
            if (text) {
            text = NEWSPAPER_HANDLER.convert_html(text)
            unguarded( (: write_file($(fname) + ".proc", $(text), 1) :) )
            if (unguarded( (: NROFF_HAND.create_nroff($(fname) + ".proc",
            $(fname) + ".nroff")
            :) )) {
            text = unguarded( (: NROFF_HAND.cat_file($(fname) +
            ".nroff") :) )
            } else {
            text = "Unable to make nroff file.\n"


    def update_document_text(self, id: str, text: str) -> None:
            string fname
            fname = query_document_file_name(id)
            if (fname) {
            unguarded( (: write_file($(fname), $(text), 1) :))


    def delete_document(self, id: str) -> None:
            string fname
            fname = query_document_file_name(id)
            if (fname) {
            unguarded( (: rm($(fname) + ".proc") :))
            unguarded( (: rm($(fname) + ".nroff.o") :))
            unguarded( (: rm($(fname)) :))
            map_delete(_documents, id)
            save_me()


    def add_document(self, title: str, text: str, person: str, type: int) -> str:
            class document bing
            string id
            id = _next_doc_id + ""
            bing = new(class document)
            bing->title = title
            bing->added_by = person
            bing->type = type
            bing->time_added = time()
            bing->fname = id + ".txt"
            _next_doc_id++
            _documents[id] = bing
            update_document_text(id, text)
            save_me()
            return id


    def do_list(self, ) -> int:
            string ret
            class document info
            string id
            if (!is_open_for("document_view", this_player()->query_name())) {
            add_failed_mess("You cannot list documents on $I.\n",
            [self])
            return 0


    def do_display(self, id: str) -> int:
            string ret
            class document info
            if (!is_open_for("document_view", this_player()->query_name())) {
            add_failed_mess("You cannot view documents on $I.\n",
            [self])
            return 0


    def do_add_document(self, title: str, type: int) -> int:
            if (!is_open_for("document_add", this_player()->query_name())) {
            add_failed_mess("You cannot add documents to $I.\n",
            [self])
            return 0


    def finish_edit(self, str: str, args: Any) -> None:
            string title
            int type
            title = args[0]
            type = args[1]
            if (!str || str == "") {
            write("Abandoning adding the document.\n")
            return


    def do_delete_document(self, id: str) -> int:
            if (!is_open_for("document_delete", this_player()->query_name())) {
            add_failed_mess("You cannot delete documents from $I.\n",
            [self])
            return 0


    def init_dynamic_arg(self, map: Any) -> None:
            if (file_name(self) != "/std/room/furniture/inherit/document_handler" && map) {
            _documents = query_auto_load_value(map, TAG, "documents")
            if (!_documents) {
            _documents = ([ ])


    def init_object(self, ) -> None:
            add_command("list", "documents [from] <direct:object>", (: do_list() :))
            add_command("view", "document <string'id'> [from] <direct:object>",
            (: do_display($4[0]) :))
            add_command("add", "documents {html|plain} called <string:quoted'title'> to <direct:object>",
            (: do_add_document($4[1], ($4[0] == "html"?DOCUMENT_HTML:DOCUMENT_PLAIN)) :))
            add_command("delete", "document <string'id'> [from] <direct:object>",
            (: do_delete_document($4[0]) :))


    def init_room(self, ) -> None:
            add_command("list", "[documents]", (: do_list() :))
            add_command("view", "[document] <string'id'>",
            (: do_display($4[0]) :))
            add_command("add", "[document] {html|plain} called <string:quoted'title'>",
            (: do_add_document($4[1], ($4[0] == "html"?DOCUMENT_HTML:DOCUMENT_PLAIN)) :))
            add_command("delete", "[document] <string'id'>",
            (: do_delete_document($4[0]) :))


    def __init__(self):
            self._allowed_positions = []


    def __init__(self):
            self._allowed_positions = []
            self.set_max_cond(100000)
            self.set_cond(100000)


    def query_furniture(self, ) -> int:
            return 1


    def set_allowed_positions(self, positions: str) -> None:
            _allowed_positions = positions


    def remove_allowed_positions(self, positions: str) -> None:
            _allowed_positions -= positions


    def set_allowed_room_verbs(self, allowed: Any) -> None:
            _allowed_room_verbs = allowed


    def query_position_string(self, position_type: str) -> str:
            if(_allowed_positions.index(position_type) if position_type in _allowed_positions else -1 != -1) {
            return one_short()


    def set_bonded(self, person: str) -> None:
            _bonded = person


    def query_bonded(self, ) -> str:
            return _bonded


    def query_owner(self, ) -> str:
            return _bonded


    def is_allowed_to_mess(self, player: MudObject) -> int:
            mixed *stuff
            string occupier
            if(environment() && !function_exists("query_owner", environment()))
            return 1
            if(player.query_creator())
            return 1
            if(player.query_caster())
            player = find_player(player.query_caster())
            if(player.query_owner())
            player = player.query_owner()
            if (player && player.query_name() == _bonded)
            return 1
            stuff = self.query_property("dropped")
            if(player && sizeof(stuff) && stuff[0] == player.query_name())
            return 1
            if(player && environment()) {
            if(environment()->test_occupier(player.query_name()))
            return 1
            if(environment()->query_owner() == "For Sale" ||
            environment()->query_owner() == "Under Offer")
            return 1
            occupier = HOUSING.query_owner(base_name(environment()))
            if(pk_check(player, occupier, 1))
            return 0


    def move_check(self, dest: MudObject) -> int:
            if (living(dest)) {
            if (!is_allowed_to_mess(dest)) {
            return 0


    def query_placement_verb(self, ) -> str:
            return query_property(PLACEMENT_CURRENT_ROOM_VERB)


    def query_placement_other(self, ) -> str:
            return query_property(PLACEMENT_CURRENT_ROOM_OTHER)


    def query_placement_position(self, ) -> str:
            return query_property(PLACEMENT_CURRENT_ROOM_POSITION)


    def query_placement_immovable(self, ) -> int:
            return query_property(PLACEMENT_IMMOVABLE)


    def is_placed(self, ) -> int:
            return query_placement_position() &&
            stringp(query_placement_verb()) &&
            stringp(query_placement_other())


    def set_placement_verb(self, verb: str) -> None:
            add_property(PLACEMENT_CURRENT_ROOM_VERB, verb)


    def set_placement_other(self, other: str) -> None:
            add_property(PLACEMENT_CURRENT_ROOM_OTHER, other)


    def set_placement_position(self, position: str) -> None:
            add_property(PLACEMENT_CURRENT_ROOM_POSITION, position)


    def set_placement_immovable(self, ) -> int:
            return query_property(PLACEMENT_IMMOVABLE)


    def init(self, ) -> None:
            this_player()->add_command( "slot", self,
            _coin_short + " into <direct:object>", (: do_slot() :) )
            this_player()->add_command( "pull", self,
            "lever on <direct:object>", (: do_pull_lever() :) )
            this_player()->add_command( "read", self,
            "dial on <direct:object>", (: do_read_dial() :) )


    def set_coin_type(self, coin: str) -> int:
            if( MONEY_HAND.query_valid_types(.index( coin) if  coin in MONEY_HAND.query_valid_types( else -1 ) == -1 )
            return 0
            _coin = coin
            _coin_short = MONEY_HAND.query_aliases_for( coin )[0]
            _coin_pl = MONEY_HAND.query_main_plural_for( coin )
            return 1


    def set_chances(self, c1: int, c2: int, c3: int, c4: int, c5: int) -> int:
            if( !( c1 > 0 && c2 > 0 && c3 > 0 && c4 > 0 && c5 > 0 ) )
            return 0
            _chances = [c1, ( c1 + c2 ), ( c1 + c2 + c3 ), ( c1 + c2 + c3 + c4 ),
            ( c1 + c2 + c3 + c4 + c5 )]
            return 1


    def set_prizes(self, p1: int, p2: int, p3: int, p4: int, p5: int, jackpot: int) -> int:
            if( !( p1 > 1 && p2 > 1 && p3 > 1 && p4 > 1 && p5 > 1 && jackpot > 1 ) ||
            ( jackpot <= p1 || jackpot <= p2 || jackpot <= p3 ||
            jackpot <= p4 || jackpot <= p5 ) )
            return 0
            _prizes = ({p1, p2, p3, p4, p5, jackpot})
            return 1


    def do_slot(self, ) -> int:
            if( this_player(.index( _coin) if  _coin in this_player( else -1->query_money_array() ) == -1 ) {
            this_player()->add_failed_mess( self,
            "You need " + add_a( _coin ) + " to play.\n", [}) )
            return 0


    def do_pull_lever(self, ) -> int:
            if( _busy == 0 ) {
            this_player()->add_failed_mess( self,
            "You must put a coin in the slot before you can play.\n", [}) )
            return 0


    def rollem(self, player: MudObject) -> None:
            int a1, a2, a3, c
            int adj1 = random( 10 ),
            adj2 = random( 10 ),
            adj3 = random( 10 )
            c = random( _chances[4] )
            if( c < _chances[0] )
            a1 = 0
            else if( c < _chances[1] )
            a1 = 1
            else if( c < _chances[2] )
            a1 = 2
            else if( c < _chances[3] )
            a1 = 3
            else
            a1 = 4
            c = random( _chances[4] )
            if( c < _chances[0] )
            a2 = 0
            else if( c < _chances[1] )
            a2 = 1
            else if( c < _chances[2] )
            a2 = 2
            else if( c < _chances[3] )
            a2 = 3
            else
            a2 = 4
            c = random( _chances[4] )
            if( c < _chances[0] )
            a3 = 0
            else if( c < _chances[1] )
            a3 = 1
            else if( c < _chances[2] )
            a3 = 2
            else if( c < _chances[3] )
            a3 = 3
            else
            a3 = 4
            tell_object( player,
            "The windows now show these pictures :\n\n"
            "        " + adject[ adj1 ] + " " + animal[ a1 ] +
            "    " + adject[ adj2 ] + " " + animal[ a2 ] +
            "    " + adject[ adj3 ] + " "+animal[ a3 ] + "\n\n" )
            if( a1 == a2 && a1 == a3 ) {
            if( adj1 == adj2 && adj1 == adj3 ) {
            tell_object( player,
            "WOW!!  A triple " + adject[ adj1 ] + " " + animal[ a1 ] +
            "!!  You really hit the jackpot this time!\n\n"
            "Whistles and bells start sounding like crazy, the whole " +
            self.short() +  " glows with flashing lights.  There "
            "is a loud tingling as " + _prizes[5] + " " +
            MONEY_HAND.query_plural_for( _coin ) + " drop into the tray "
            "of " + my_short() + ".  Slightly stunned you quickly scoop "
            "it up and cackle with delight.\n" )
            tell_room( environment( self ),
            "Whistles and bells start sounding and " + my_short() +
            " starts to flash with coloured lights.  Someone must have "
            "won the jackpot...lucky buggers.  As you watch some coins "
            "drop into the tray at the bottom of " + my_short() + ", " +
            player.one_short() + " snatches it up and cackles with "
            "delight.\n", ({player}) )
            player.adjust_money( _prizes[5] ,_coin )
            self.adjust_money( -(_prizes[ 5 ]) )
            _busy = 0
            return


    def query_chances(self, ) -> List[int]:
            int* tmp = [})
            tmp += [_chances[0]]
            tmp += [_chances[1] - _chances[0]]
            tmp += [_chances[2] - _chances[1]]
            tmp += [_chances[3] - _chances[2]]
            tmp += [_chances[4] - _chances[3]]
            return tmp


    def query_prizes(self, ) -> List[int]:
            return _prizes


    def query_coin_type(self, ) -> str:
            return _coin


    def my_short(self, ) -> str:
            return self.the_short()


    def do_read_dial(self, ) -> int:
            string tmp =
            "Stake        : 1 " + _coin_pl + "\n"
            "3x Albatross : " + _prizes[0] + " " + _coin_pl + "\n"
            "3x Frog      : " + _prizes[1] + " " + _coin_pl + "\n"
            "3x Hippo     : " + _prizes[2] + " " + _coin_pl + "\n"
            "3x Turtle    : " + _prizes[3] + " " + _coin_pl + "\n"
            "3x Cabbage   : " + _prizes[4] + " " + _coin_pl + "\n"
            "JACKPOT      : " + _prizes[5] + " " + _coin_pl + "\n"
            this_player()->add_succeeded_mess( self,
            ({tmp, "$N read$s the dial on $D.\n"}), [}) )
            return 1


    def is_card_red(self, playing_card: Any) -> int:
            class playing_card* make_deck(int number_of_decks,
            int number_of_jokers) {
            class playing_card* deck
            class playing_card card
            int i
            int suit
            int num
            deck = [})
            for (i = 0; i < number_of_decks; i++) {
            for (suit = CARD_SUIT_HEARTS; suit <= CARD_SUIT_SPADES; suit++) {
            for (num = 1; num <= CARD_NUM_MAX; num++) {
            card = new(class playing_card)
            card->suit = suit
            card->number = num
            deck += [card]


    def query_suit_letter(self, suit: int) -> str:
            switch (suit) {
            case CARD_SUIT_SPADES :
            return "S"
            break
            case CARD_SUIT_HEARTS :
            return "H"
            break
            case CARD_SUIT_DIAMONDS :
            return "D"
            break
            case CARD_SUIT_CLUBS :
            return "C"
            break
            case CARD_SUIT_JOKER :
            return "J"


    def query_card_string(self, playing_card: Any) -> str:
            string ret
            string colour
            if (card->suit == CARD_SUIT_JOKER) {
            return "*J*"


    def is_card_red(self, playing_card: Any) -> int:
            return card->suit == CARD_SUIT_HEARTS || card->suit == CARD_SUIT_DIAMONDS


    def is_card_black(self, playing_card: Any) -> int:
            return card->suit == CARD_SUIT_SPADES || card->suit == CARD_SUIT_CLUBS


    def is_card_joker(self, playing_card: Any) -> int:
            return card->suit == CARD_SUIT_JOKER


    def query_hand_string(self, playing_card: Any, flags: int, cols: int) -> str:
            string hand_str
            int i
            int j
            int width
            int start_pos
            string top
            string line
            string start
            string end
            string start_space
            string end_space
            mixed card_str
            if (!sizeof(hand)) {
            return "No cards\n"


    def __init__(self):
            self._players = ([ ])
            self._ids_when_started = []


    def reset_game(self, ) -> None:


    def start_game(self, ) -> int:
            delete_gone_players()
            if (sizeof(query_currently_playing_ids()) < _minimum_needed) {
            return 0


    def finish_game(self, winner: str) -> None:
            _winner = winner
            _game_started = 0


    def query_winner(self, ) -> str:
            return _winner


    def is_game_started(self, ) -> int:
            return _game_started


    def can_join_as_new_player(self, ) -> int:
            return _can_join_as_new


    def set_can_join_as_new_player(self, join: int) -> None:
            _can_join_as_new = join


    def is_person_playing(self, id: str) -> int:
            if (_players[id]->name) {
            if (find_player(_players[id]->name) &&
            is_in_me_or_environment(self,
            find_player(_players[id]->name)) &&
            interactive(find_player(_players[id]->name))) {
            return 1


    def is_playing(self, ob: MudObject) -> int:
            string id
            id = find_player_id_of_person(ob)
            return id != 0


    def is_current_player(self, ob: MudObject) -> int:
            string id
            id = find_player_id_of_person(ob)
            return id == _current_player


    def add_person_to_game(self, id: str, person: MudObject) -> int:
            class player_info info
            if (is_person_playing(id)) {
            return 0


    def remove_person_object_from_game(self, person: MudObject) -> int:
            class player_info info
            string id
            foreach (id, info in _players) {
            if (find_player(info->name) == person) {
            info->name = 0
            info->cap_name = 0
            return 1


    def remove_person_id_from_game(self, id: str) -> int:
            if (_players[id]->name) {
            _players[id]->name = 0
            return 1


    def randomise_player_numbers(self, ) -> None:
            string* ids
            int num
            int pos
            ids = keys(_players)
            num = 0
            while (sizeof(ids)) {
            pos = random(sizeof(ids))
            _players[ids[pos]]->number = num
            ids = ids[0..pos-1] + ids[pos+1..]
            num++


    def add_player_id_type(self, id: str, number: int) -> None:
            _players[id] = new(class player_info)
            _players[id]->number = number


    def remove_player_id_type(self, id: str) -> None:
            map_delete(_players, id)


    def find_player_id_from_number(self, num: int) -> str:
            class player_info info
            string id
            foreach (id, info in _players) {
            if (info->number == num) {
            return id


    def query_player_cap_name(self, id: str) -> str:
            if (_players[id] && _players[id]->name) {
            return _players[id]->cap_name


    def query_player_object(self, id: str) -> MudObject:
            return find_player(_players[id]->name)


    def query_player_the_short(self, id: str) -> str:
            object ob
            if (_players[id]->name) {
            ob = query_player_object(id)
            if (ob) {
            return ob.the_short()


    def query_player_poss_short(self, id: str) -> str:
            object ob
            if (_players[id]->name) {
            ob = query_player_object(id)
            if (ob) {
            return ob.poss_short()


    def delete_gone_players(self, ) -> None:
            string id
            class player_info info
            foreach (id, info in _players) {
            if (info->name) {
            if (!find_player(info->name) ||
            !is_in_me_or_environment(self, find_player(info->name))) {
            info->name = 0


    def set_minimum_needed(self, minimun: int) -> None:
            _minimum_needed = minimun


    def can_start_game(self, ) -> int:
            if (sizeof(query_currently_playing_ids()) > _minimum_needed) {
            return 1


    def find_next_player(self, id: str) -> str:
            class player_info info
            int start
            int cur
            string new_id
            if (!id) {
            id = _current_player


    def find_previous_player(self, id: str) -> str:
            class player_info info
            int start
            string new_id
            int cur
            if (!id) {
            id = _current_player


    def increment_current_player(self, ) -> None:
            _current_player = find_next_player(_current_player)


    def find_player_id_of_person(self, person: MudObject) -> str:
            class player_info info
            string id
            foreach (id, info in _players) {
            if (find_player(info->name) == person) {
            return id


    def query_current_player(self, ) -> str:
            if (!_current_player) {
            _current_player = find_player_id_from_number(0)


    def set_current_player(self, id: str) -> str:
            _current_player = id


    def tell_player(self, id: str, message: str) -> None:
            object player
            player = find_player(_players[id]->name)
            if (player && (environment(player) == environment() ||
            player == environment())) {
            await player.send(message)


    def tell_current_player(self, message: str) -> None:
            tell_player(_current_player, message)


    def query_player_data(self, id: str) -> Any:
            return _players[id]->data


    def set_player_data(self, id: str, data: Any) -> None:
            _players[id]->data = data


    def multiplayer_someone_joins(self, id: str) -> None:


    def multiplayer_someone_resigns(self, id: str, name: str) -> None:


    def do_join(self, id: str) -> int:
            if (is_person_playing(id)) {
            add_failed_mess("Someone is already playing " + id + " on $D.\n")
            return 0


    def do_resign(self, ) -> int:
            string id
            id = find_player_id_of_person(this_player())
            if (remove_person_object_from_game(this_player())) {
            add_succeeded_mess("$N $V from the game on $D.\n")
            multiplayer_someone_resigns(id, this_player()->query_cap_name())
            if (id == query_current_player()) {
            increment_current_player()


    def init(self, ) -> None:
            string ids
            ids = implode(keys(_players), "|")
            add_command("join", "[game] [as] {" + ids + "} on <direct:object>",
            (: do_join($4[0]) :))
            add_command("resign", "[from] [game] on <direct:object>",
            (: do_resign() :))


    def init_dynamic_arg(self, map: Any, player: MudObject) -> None:
            if (!map) {
            return


    def splash_func(self, ob: MudObject) -> int:
            ob.add_extra_look(self)
            ob.add_property("splashed with", previous_object()->query_liquid_name())
            return 1


    def extra_look(self, ) -> str:
            return capitalize((string)previous_object()->query_name())+
            " has been splashed with "+
            previous_object()->query_property("splashed with")


    def setup_shadow(self, person: MudObject, thing: MudObject) -> None:
            shadow( person, 1 )
            peacenpc=thing


    def event_exit(self, ob: MudObject, message: str, to: MudObject) -> None:
            if (ob==peacenpc)
            dest_peace_shadow()


    def event_move_object(self, from: Any, to: Any) -> None:
            dest_peace_shadow()


    def command_shadowed(self, verb: str, args: str) -> int:
            switch(verb) {
            case "attack":
            case "behead":
            case "berserk":
            case "bob":
            case "crush":
            case "disarm":
            case "fire":
            case "guard":
            case "hack":
            case "hurl":
            case "iai":
            case "impale":
            case "kill":
            case "punch":
            case "riposte":
            case "slash":
            case "throw":
            case "warcry":
            await TP.send(GFR)
            return 1
            case "cast":
            case "circle":
            case "educe":
            case "forget":
            case "invoke":
            case "remember":
            case "scribe":
            case "scry":
            case "spellcheck":
            case "twist":
            case "use":
            case "zap":
            await TP.send(GMR)
            return 1
            case "bodyguard":
            case "bury":
            case "drag":
            case "eye":
            case "fuel":
            case "hedgehog":
            case "judge":
            case "leatherwork":
            case "mock":
            case "tempt":
            case "scathe":
            case "vurdere":
            await TP.send(GOR)
            return 1
            case "conflagrate":
            case "consecrate":
            case "decompose":
            case "ensumpf":
            case "envalise":
            case "imbue":
            case "perform":
            case "pray":
            case "pyroscipate":
            case "shroud":
            case "suffuse":
            case "ventisepelate":
            await TP.send(GRR)
            return 1
            case "abscond":
            case "ambush":
            case "case":
            case "conceal":
            case "crack":
            case "disable":
            case "filch":
            case "hide":
            case "inhume":
            case "lpick":
            case "palm":
            case "peek":
            case "plant":
            case "probe":
            case "scope":
            case "shoplift":
            case "slip":
            case "snatch":
            case "sneak":
            case "steal":
            case "unhide":
            await TP.send(GSR)
            return 1
            default:
            return 0


    def run_away(self, ) -> int:
            await TO.send(GER)


    def trap_lock(self, type: str) -> int:
            if(type != "pick")
            return 0
            await this_player().send("Trap triggered.\n")
            return 0


    def reset_keep(self, ) -> None:
            _keep = 0
            if (!_identifier)
            remove_this_effect()


    def query_full_identifier(self, ) -> str:
            string tmp
            tmp = ""
            if ( sizeof( _adjs ) ) {
            tmp += implode( _adjs, " " ) + " "


    def set_identifier(self, word: str) -> None:
            string* bits
            if (word) {
            bits = explode(word, " ")
            _identifier = bits[<1]
            _adjs = bits[0..<2]
            } else {
            _identifier = 0
            _adjs = [})
            if (!_keep)
            remove_this_effect()


    def set_identity_hold_owner(self, ob: MudObject) -> None:
            _owner = ob


    def query_identity_hold_owner(self, ) -> MudObject:
            return _owner


    def query_msgin(self, ) -> str:
            {
            return "$N stagger$s clumsily from $F."


    def query_msgout(self, ) -> str:
            {
            return "$N stagger$s $T clumsily."


    def move(self, dest: Any, inmsg: str, outmsg: str) -> int:
            {
            int ret
            ret = player.move(dest, inmsg, outmsg)
            if (ret == MOVE_OK) {
            tell_object( player, "You wince as spikes seem to drive themselves "
            "into the balls of your feet, but you get there eventually.\n" )


    def test_for_effect(self, thing: MudObject) -> int:
            return member_array( EFFECTS +"newbie_shoes",
            (string *)thing.query_wear_effects() ) != -1


    def taken_off(self, what: MudObject, eff: str) -> None:
            {
            if (eff != EFFECTS + "newbie_shoes")
            player.taken_off(what, eff)
            else {
            remove_this_effect()


    def query_auto_load(self, ) -> Any:
            return 0


    def query_dynamic_auto_load(self, ) -> Any:
            return 0


    def query_static_auto_load(self, ) -> Any:
            return 0


    def set_holder(self, thing: MudObject, pos: int) -> Any:
            self.remove_hide_invis( "concealed" )
            if ( objectp( thing ) )
            if ( !thing.query_corpse() &&
            ( (string)thing.query_name() != arg() ) )
            return 0
            return (mixed)player.set_holder( thing, pos )


    def query_owner(self, ) -> str:
            return (string) arg()


    def query_skill_bonus(self, skill: str, true: int) -> int:
            if ((skill != "other.movement.swimming") || true)
            return player.query_skill_bonus(skill)
            return player.query_skill_bonus(skill)+50


    def init(self, ) -> None:
            mixed args
            object where
            string channel
            where = environment(player)
            #ifdef DEBUG
            tell_creator("taffyd", "%O, %O, %O.\n", player, this_player(), where)
            #endif
            if( !where )
            return
            if (!living(where)) {
            player.init()
            return


    def query_player(self, ) -> MudObject:
            if(player && environment(player) && living(environment(player)))
            return environment(player)
            return 0


    def do_talker_control(self, args: Any, pattern: str) -> int:
            class talker_args t_args
            int position
            string full_name
            #ifdef DEBUG
            tell_creator("taffyd", "Args to talker control is %O. Pattern is %O.\n",
            args, pattern)
            #endif
            t_args = arg()
            switch (pattern) {
            case ON_PATTERN:
            return handle_status_command(args[0], t_args)
            case VERBOSE_PATTERN:
            return handle_verbose_command(args[0], t_args)
            case CHANNEL_PATTERN:
            if ( !t_args->status ) {
            await this_player().send("The eyes are asleep.\n")
            return 1


    def handle_history_command(self, channel: str, talker_args: Any) -> int:
            mixed *history
            string result
            if (!args->status) {
            await this_player().send("The eyes are asleep.\n")
            return 1


    def query_colour_status(self, talker_args: Any) -> str:
            if ( !mapp( args->colour ) ) {
            return "off"


    def set_colour_status(self, talker_args: Any, status: str) -> int:
            if ( !args->colour ) {
            args->colour = DEFAULT_COLOUR_SETTINGS
            } else {
            if ( stringp( args->colour ) ) {
            args->colour = DEFAULT_COLOUR_WITH( args->colour )


    def set_channel_colour(self, talker_args: Any, channel: str, colour: str) -> int:
            if ( !channel || !colour )
            return 0
            if ( !mapp( args->colour ) ) {
            args->colour = DEFAULT_COLOUR_WITH(colour)


    def handle_colour_toggle_command(self, talker_args: Any) -> int:
            if ( query_colour_status( args ) == "on" ) {
            return handle_colour_on_off_command( "off", args )


    def handle_colour_on_off_command(self, str_status: str, talker_args: Any) -> int:
            string status
            status = query_colour_status( args )
            switch( str_status ) {
            case "on":
            if ( status == "on" ) {
            add_failed_mess( "Talker colours for $D are already on!\n" )
            return -1


    def handle_status_command(self, mode: str, talker_args: Any) -> int:
            switch (mode) {
            case "on" :
            if ( args->status ) {
            tell_object(this_player(),  "The eyes are already alert "
            "and listening to your every word.\n")
            } else {
            tell_object(this_player(), "The eyes open and light up "
            "eagerly, then dim to a dull glow.\n")
            args->status = 1


    def handle_verbose_command(self, mode: str, talker_args: Any) -> int:
            if (!args->status) {
            await this_player().send("The eyes are asleep.\n")
            return 1


    def receive(self, channel: str, sender: str, text: str, receivers: MudObject) -> None:
            class talker_args args
            string *ignoring
            object where
            string colour
            string txt
            if(!player || !environment(player) )
            return
            where = environment(player)
            args = arg()
            if (args && !classp(args))
            return
            if (!args || !args->status || !living(where) || !interactive(where))
            return
            if(map(args->channels, (: lower_case($1.index(channel) if channel in map(args->channels, (: lower_case($1 else -1 :)) ) == -1) {
            return


    def do_chat(self, message: str, pattern: str, verb: str) -> int:
            class talker_args args
            object *things, *receivers
            string sender
            #ifdef DEBUG
            tell_creator("taffyd", "Message is %s, pattern is %s, verb is "
            "%s.\n", message, pattern, verb)
            #endif
            #ifdef EMOTE_ENABLED
            if ( verb[ <1 ] == ':' ) {
            verb = verb[0..<2]


    def remove_effect_shadow(self, i: int) -> None:
            if ( i == id ) {
            if ( player && environment( player ) ) {
            environment( player )->remove_object( player, 1 )
            init()


    def handle_colour_list(self, colour_args: Any, talker_args: Any) -> int:
            string channel
            if (!mapp(args->colour) || query_colour_status( args ) == "off" ) {
            add_failed_mess( "You currently have talker colours disabled.  Use "
            "\"talker colour on\" to turn them on.\n" )
            return 0


    def handle_echo_command(self, mode: str, talker_args: Any) -> int:
            int current
            current = args->local_echo
            if ( current ) {
            if ( mode == "on" ) {
            add_failed_mess( "Talker echo is already on for $D!\n" )
            return -1


    def flusoul(self, ) -> str:
            string flu
            soulverb = ({"sneeze",
            "cough"
            })
            souladverb = ({"violently",
            "loudly",
            "suddenly"
            })
            this_player()->force_soul_command(soulverb[random(sizeof(soulverb))]+" "+souladverb[random(sizeof(souladverb))])
            return flu


    def look_me(self, arg: str) -> int:
            if(!arg){
            if (random(100) > 30){
            await player.send("You feel dizzy and bleary eyed.\n")


    def attack_ob(self, obj: MudObject) -> int:
            object *contents
            object target
            if(random(100) > 30){
            await player.send("You feel too ill, and can't be bothered to attack.\n")
            return 1


    def cast(self, str: str) -> int:
            if(random(100) > 50){
            tell_object(player, "You lose your concentration as you feel a "+
            "sneeze coming on.\n")
            this_player()->force_soul_command("sneeze")
            return 1


    def query_special_manoeuvre(self, ) -> int:
            await player.send("Your head hurts too much to try anything.\n")
            return 0


    def command_shadowed(self, verb: str, arg: str) -> int:
            if(verb=="cast"){
            write("Your head hurts too much to muster your might.\n")
            return 1


    def query_blinded(self, ) -> int:
            return 1


    def mangle_chat(self, s: str) -> str:
            return replace(s, replace_matrix)


    def mangle_speech(self, s: str) -> str:
            string s1
            s1 = player.mangle_speech( s )
            return replace( " " + (stringp(s1)?s1:s), replace_matrix)[1..10000]


    def event_whisper(self, ob: MudObject, start: str, mess: str, d: MudObject, lang: str) -> None:
            int i
            i = (int)arg() / 2
            if (random(100) < i) {
            player.event_whisper(ob, start, mess, d, lang)
            } else {
            player->add_message(ob, "$N %hiss% something at you, but you just "+
            "can't make it out.\n", 1)


    def event_person_say(self, ob: MudObject, start: str, mess: str, lang: str) -> None:
            string dum1, dum2
            if (sscanf(start, "%sloud%s", dum1, dum2)) {
            if (random(100) > (100 - (int)arg()) / 2) {
            player.event_person_say(ob, start, mess, lang)
            } else {
            player->add_message(ob, "$N say$s something loudly, but "+
            "you fail to hear it properly.\n", 1)


    def long(self, str: str, dark: int) -> str:
            string s, class_ob
            s = "You see "+ query_short()
            class_ob = player.query_class_ob()
            if (class_ob)
            s += " "+ (string)class_ob.query_title( self ) +".\n"
            else
            s += ".\n"
            s += "It is a small blue humanoid wearing white trousers.\n"
            s += capitalize(query_pronoun())+" "+player.health_string()+".\n"
            s += player.calc_extra_look()
            s += player.weather_extra_look()
            s += player.query_living_contents(0)
            return s


    def smurf(self, str: str) -> str:
            string str1
            if ( sscanf( str, "%s,", str ) ) str1 = ","
            else if ( sscanf( str, "%s.", str ) ) str1 = "."
            else if ( sscanf( str, "%s!", str ) ) str1 = "!"
            else if ( sscanf( str, "%s;", str ) ) str1 = ";"
            else str1 = ""
            if ( sscanf( str, "%sing", str ) ) str = "smurfing"
            else if ( sscanf( str, "%sd", str ) ) str = "smurfed"
            else if ( sscanf( str, "%ss", str ) ) str = "smurfs"
            else str = "smurf"
            return str + str1


    def mangle_speech(self, str: str) -> str:
            string tmp, *bits
            int i
            tmp = player.mangle_speech( str )
            if( !tmp ) tmp = str
            bits = explode(tmp, " ")
            for (i=1;i<sizeof(bits);i+=3) {
            bits[i] = smurf( bits[i] )


    def __init__(self):
            self.replace_matrix = []
            self.trans = ([ ])
            self.trans["stairs"] = "apples and pears"
            self.trans["Downstairs"] = "Down the apples and pears"
            self.trans["downstairs"] = "down the apples and pears"
            self.trans["Upstairs"] = "Up the apples and pears"
            self.trans["upstairs"] = "up the apples and pears"
            self.trans["mouth"] = "North and South"
            self.trans["Mouth"] = "North and South"
            self.trans["Face"] = "Boat Race"
            self.trans["face"] = "Boat Race"
            self.trans["Trouble"] = "Barney Rubble"
            self.trans["trouble"] = "Barney Rubble"
            self.trans["wife"] = ['trouble and strife', 'ole lady']
            self.trans["Road"] = "Frog and Toad"
            self.trans["road"] = "frog and toad"
            self.trans["pub"] = "rub-a-dub "
            self.trans["bar"] = "boozer"
            self.trans["husband"] = "ole man"
            self.trans["Party"] = "Knees-up"
            self.trans["party"] = "knees-up"
            self.trans["Parties"] = "Knees-ups"
            self.trans["parties"] = "knees-ups"
            self.trans["My"] = "Me"
            self.trans["my"] = "me"
            self.trans["Your"] = "Yer"
            self.trans["your"] = "yer"
            self.trans["You"] = "Yer"
            self.trans["you"] = "yer"
            self.trans["Those"] = "Them"
            self.trans["those"] = "them"
            self.trans["those"] = "them"
            self.trans["(those"] = "(them"
            self.trans["The"] = ["The bleedin'", 'The']
            self.trans["Fe"] = ["The bleedin'", 'The']
            self.trans["the"] = ["the bleedin'", 'the']
            self.trans["fe"] = ["the bleedin'", 'the']
            self.trans["Thus"] = "So"
            self.trans["thus"] = "so"
            self.trans["(thus"] = "(so"
            self.trans["thus"] = "so"
            self.trans["old"] = "ole"
            self.trans["to"] = "ter"
            self.trans["Aren't"] = "Ain't"
            self.trans["aren't"] = "ain't"
            self.trans["Isn't"] = "Ain't"
            self.trans["isn't"] = "ain't"
            self.trans["Hallo"] = "Wotcher"
            self.trans["Hello"] = "Wotcher"
            self.trans["Hullo"] = "Wotcher"
            self.trans["Hi"] = "Wotcher"
            self.trans["hallo"] = "wotcher"
            self.trans["hello"] = "wotcher"
            self.trans["hullo"] = "wotcher"
            self.trans["hi"] = "wotcher"
            self.trans["What"] = "Wot"
            self.trans["what"] = "wot"
            self.trans["Were"] = "Was"
            self.trans["were "] = "was"
            self.trans["Bother"] = "Ars"
            self.trans["bother"] = "ars"
            self.trans["Mother"] = "Muvver"
            self.trans["Other"] = "Uvver"
            self.trans["other"] = "uvver"
            self.trans["Father"] = "Favver"
            self.trans["father"] = "favver"
            self.trans["Rather"] = "Ravver"
            self.trans["rather"] = "ravver"
            self.trans["Weather"] = "Wevver"
            self.trans["weather"] = "wevver"
            self.trans["Leather"] = "Levver"
            self.trans["leather"] = "levver"
            self.trans["Wither"] = "Wivver"
            self.trans["wither"] = "wivver"
            self.trans["Either"] = "Eever"
            self.trans["either"] = "eever"
            self.trans["With"] = "Wiv"
            self.trans["with"] = "wiv"
            self.trans["Anything"] = "Anyfink"
            self.trans["anything"] = "anyfink"
            self.trans["Something"] = "Sumfink"
            self.trans["something"] = "sumfink"
            self.trans["Nothing"] = "Nuffink"
            self.trans["nothing"] = "nuffink"
            self.trans["guitars"] = "spoons"
            self.trans["guitar"] = "spoons"
            self.trans["drums"] = "spoons"
            self.trans["drum"] = "spoons"
            self.trans["trumpets"] = "spoons"
            self.trans["trumpet"] = "spoons"
            self.trans["violins"] = "spoons"
            self.trans["violin"] = "spoons"
            self.trans["clarinets"] = "spoons"
            self.trans["clarinet"] = "spoons"
            self.trans["trombones"] = "spoons"
            self.trans["trombone"] = "spoons"
            self.trans["oboes"] = "spoons"
            self.trans["oboe"] = "spoons"
            self.trans["flutes"] = "spoons"
            self.trans["flute"] = "spoons"
            self.trans["tubas"] = "spoons"
            self.trans["tuba"] = "spoons"
            self.trans["Data"] = "Info"
            self.trans["data"] = "info"
            self.trans["Directory"] = "Lockup"
            self.trans["directory"] = "lockup"
            self.trans["Directories"] = "Lockups"
            self.trans["directories"] = "lockups"
            self.trans["Stopped"] = "'Ad the mockers put on"
            self.trans["stopped"] = "'ad the mockers put on"
            self.trans["Stopping"] = "Putting the mockers on"
            self.trans["stopping"] = "putting the mockers on"
            self.trans["stops"] = "puts the mockers on"
            self.trans["stop"] = "put the mockers on"
            self.trans["STOP"] = "Put The Mockers On"
            self.trans["Londoner"] = "Cockney"
            self.trans["londoner"] = "Cockney"
            self.trans["friend"] = ['mucker', 'mate', 'china']
            self.trans["sin'"] = "sing"
            self.trans["rin'"] = "ring"


    def mangle_speech(self, str: str) -> str:
            string tmp, *bits
            mixed erp
            int i
            tmp = player.mangle_speech( str )
            tmp = replace(" "+(stringp(tmp)?tmp:str)+" ", replace_matrix)
            bits = explode(tmp, " ")
            for (i=0;i<sizeof(bits);i++) {
            if (erp = trans[bits[i]])
            if (stringp(erp))
            bits[i] = erp
            else
            bits[i] = erp[random(sizeof(erp))]


    def query_property(self, prop: str) -> Any:
            if ( prop == "player_title" ) {
            return 0


    def bing(self, ) -> None:
            player.submit_ee2( player->sid_to_enum( id ), "spam", 5, EE_CONTINUOUS )


    def query_keep_room_loaded(self, ) -> int:
            return 1


    def dont_free(self, ) -> int:
            return 1


    def clean_up(self, ) -> int:
            return 1


    def tent_collapsed(self, ) -> None:
            remove_this_effect()


    def setup_shad(self, ) -> None:
            i++


    def ditch_room(self, ) -> None:
            if( !--i ) {
            remove_this_effect()


    def query_passed_out_message(self, ) -> str:
            {
            string *msgs = ({
            "The eyes!  They're burning!  Can't think!\n",
            "Your concentration is too fragmented.\n",
            "Why do that when you can just sit here and fall into those eyes?\n",
            "Arrrrgghhhh!  Too much pain!\n"
            })
            return msgs[random(sizeof(msgs))]


    def move_with_look(self, dest: MudObject, messin: str, messout: str) -> int:
            {
            tell_object(player, "Your mind is not here to help you control "+
            "your movement.\n")
            return MOVE_NO_DROP


    def attack_by(self, obj: MudObject) -> int:
            {
            if( !obj || ( !obj.one_short() ) ) {
            tell_room( environment( player ), player.one_short() + " is totally "
            "helpless.\n", player )


    def init(self, ) -> None:
            player.init()
            if( this_player() != my_owner )
            return
            this_player()->add_command( "help", self, "<direct:living:here>" )
            this_player()->add_command( "order", self,
            "<direct:living:here> to {kill|attack} <indirect:living:here>" )
            this_player()->add_command( "order", self,
            "<direct:living:here> to protect <indirect:living:here>" )
            this_player()->add_command( "order", self,
            "<direct:living:here> to leave" )


    def set_enemy(self, enemy: MudObject) -> int:
            object *list
            int i
            my_enemy = enemy
            if( my_enemy == my_owner ) {
            my_owner = 0
            list = self.query_attacker_list()
            for( i = 0; i < sizeof(list); i++ ) {
            self.stop_fight( list[i] )
            (list[ i ])->stop_fight( self )
            if ( !pk_check( list[ i ], my_enemy ) ) {
            (list[ i ])->attack_ob( my_enemy )
            my_enemy.attack_ob( list[ i ] )
            await  list[ i ].send((string)self.the_short()
            +" tells you: I will help you fight "+
            (string)my_enemy.the_short() +".\n")


    def set_owner(self, owner: MudObject, time: int, turn: int) -> int:
            if ( !owner ) return 0
            my_owner = owner
            turn_chance = turn
            if ( summoned )
            asyncio.create_task(self. "do_leave", time )
            asyncio.create_task(self. "move_me", 1 )
            return 1


    def event_dest_me(self, ob: MudObject) -> None:
            if ( ob == my_owner )
            asyncio.create_task(self. "go_away", 0 )
            if ( ob == my_enemy ) {
            if ( !my_owner )
            asyncio.create_task(self. "go_away", 0 )
            if ( my_enemy )
            await  my_owner.send((string)my_enemy.the_short() +" has left FaernWorld\n" )
            my_enemy = 0
            asyncio.create_task(self. "move_me",0)


    def event_death(self, ob: MudObject) -> None:
            if ( ob == my_enemy ) {
            if ( !my_owner ) asyncio.create_task(self. "go_away", 0 )
            asyncio.create_task(self. "do_tell", 0, my_owner, self.query_short() +" tells you: "+
            my_enemy.the_short() +" has been killed!\n")
            my_enemy = 0
            asyncio.create_task(self. "move_me", 0 )


    def do_tell(self, ob: MudObject, str: str) -> None:
            await  ob.send(str )


    def move_me(self, ) -> None:
            if ( my_enemy ) {
            if ( environment() == environment( my_enemy ) ) return
            player.move( environment( my_enemy ), enter_msg, leave_msg )
            await  my_enemy.send(self.the_short() +" says: You cannot escape me!\n" )
            return


    def do_leave(self, ) -> int:
            if ( my_owner ) {
            await  my_owner.send(self.the_short()
            +" tells you:  It is time for me to leave.\n" )
            say( self.the_short() +" smiles happily.\n" )


    def attack_by(self, ob: MudObject) -> int:
            if ( summoned && !my_owner ) {
            say( self.the_short()
            +" says: I will not fight without an owner!\n")
            asyncio.create_task(self."go_away",0)
            return 1


    def event_exit(self, ob: MudObject) -> None:
            if( ob != my_owner && ob != my_enemy ) return
            asyncio.create_task(self. "move_me", 1 )


    def go_away(self, ) -> None:
            write( leave_msg )
            player.move( "/room/rubbish" )


    def second_life(self, ) -> int:
            mixed *bit
            int ret
            bit = arg()
            if (functionp(bit)) {
            ret = evaluate(bit, player)
            } else if (pointerp(bit)) {
            ret = call_other(bit[0], bit[1], player)


    def cannot_walk(self, ) -> int:
            return 1


    def move(self, dest: Any, messin: str, messout: str) -> Any:
            int ret
            ret = player.move( dest, messin, messout )
            if( ret == 0 ) {
            asyncio.create_task(self. "find_corpse", 0 )


    def event_enter(self, ob: MudObject, mess: str, from: MudObject) -> None:
            player.event_enter( ob, mess, from )
            if( sizeof( query_valid_bits(ob) ) ) {
            remove_asyncio.create_task(self. "eat_corpse" )
            asyncio.create_task(self. "eat_corpse", 10, ob )


    def move(self, dest: Any, messin: str, messout: str) -> Any:
            int ret
            ret = player.move(dest, messin, messout)
            if (ret == 0) {
            asyncio.create_task(self.(: do_eat_edible :), 0)


    def event_enter(self, ob: MudObject, mess: str, from: MudObject) -> None:
            player.event_enter(ob, mess, from)
            if (ob.query_edible()) {
            asyncio.create_task(self."real_eat", 2, ob)


    def event_enter(self, ob: MudObject, mess: str) -> None:
            mixed *bit
            int ret
            bit = arg()
            if (functionp(bit)) {
            ret = evaluate(bit, player, ob, mess)
            } else if (pointerp(bit)) {
            ret = call_other(bit[0], bit[1], player, ob, mess)


    def event_exit(self, ob: MudObject, mess: str) -> None:
            mixed *bit
            int ret
            bit = arg()
            if (functionp(bit)) {
            ret = evaluate(bit, player, ob, mess)
            } else if (pointerp(bit)) {
            ret = call_other(bit[0], bit[1], player, ob, mess)


    def event_enter(self, ob: MudObject, mess: str, from: MudObject) -> None:
            mixed *bit = [})
            int ret
            if (environment(ob) == player) {
            if(sizeof(arg()) > 1)
            bit = arg()
            else
            bit = [arg()]
            if (sizeof(bit) < 2)
            ret = evaluate(bit[0], player, ob, mess, from)
            else
            ret = call_other(bit[0], bit[1], player, ob, mess, from)


    def __init__(self):
            self.specials = []
            self.weapons = ([ ])


    def good_fighter_setup(self, ) -> None:
            {
            int adjust
            int lvl
            int *args = arg()
            if (!args || !arrayp(args) || sizeof(args) != 2)
            return
            specials = [})
            bluntorsharp = args[0]
            dodgeorparry = args[1]
            lvl = player.query_level()
            check_skill("other.perception", lvl / 2)
            check_skill("other.health", lvl)
            adjust += (lvl / 3)
            if (bluntorsharp == USE_PIERCE) {
            check_skill("fighting.combat.melee.blunt", lvl - adjust)
            check_skill("fighting.combat.melee.sharp", lvl - adjust)
            check_skill("fighting.combat.melee.pierce", lvl + adjust)
            check_skill("fighting.combat.melee.unarmed", lvl - adjust)
            } else if (bluntorsharp == USE_BLUNT) {
            check_skill("fighting.combat.melee.blunt", lvl + adjust)
            check_skill("fighting.combat.melee.sharp", lvl - adjust)
            check_skill("fighting.combat.melee.pierce", lvl - adjust)
            check_skill("fighting.combat.melee.unarmed", lvl - adjust)
            } else if (bluntorsharp == USE_SHARP) {
            check_skill("fighting.combat.melee.blunt", lvl - adjust)
            check_skill("fighting.combat.melee.sharp", lvl + adjust)
            check_skill("fighting.combat.melee.pierce", lvl - adjust)
            check_skill("fighting.combat.melee.unarmed", lvl - adjust)
            } else if (bluntorsharp == USE_UNARMED) {
            check_skill("fighting.combat.melee.blunt", lvl - adjust)
            check_skill("fighting.combat.melee.sharp", lvl - adjust)
            check_skill("fighting.combat.melee.pierce", lvl - adjust)
            check_skill("fighting.combat.melee.unarmed", lvl + adjust)
            } else {
            check_skill("fighting.combat.melee.blunt", lvl)
            check_skill("fighting.combat.melee.sharp", lvl)
            check_skill("fighting.combat.melee.pierce", lvl)
            check_skill("fighting.combat.melee.unarmed", lvl)


    def event_fight_in_progress(self, attacker: MudObject, opponent: MudObject) -> None:
            {
            object ts, weapon
            int chance
            string cmd
            ts = player
            ts.event_fight_in_progress(attacker, opponent)
            if(ts.query_specific_gp("fighting") < 50)
            return
            if (victim && !objectp(victim))
            victim = 0
            if (victim && !interactive(victim))
            victim = 0
            if (victim && environment(victim) != environment(player))
            victim = 0
            if (victim && victim != attacker)
            return
            if (!victim) {
            if(ts.query_attacker_list(.index(attacker) if attacker in ts.query_attacker_list( else -1) != -1)
            victim = attacker
            if (!victim)
            return


    def event_person_say(self, ob: MudObject, start: str, mess: str, lang: str) -> None:
            int i
            string *bits
            string *filter
            player.event_person_say(ob, start, mess, lang)
            if (!userp(ob)) {
            return


    def do_gossip_say(self, str: str) -> None:
            int i
            string *stuff
            int chance
            if (!str) {
            str = "$name$ said: $mess$"


    def stopped_route(self, ) -> None:
            if (!done) {
            mixed *rabbit
            rabbit = arg()
            if (objectp(rabbit[0])) {
            womble = rabbit[0]


    def move(self, ob: MudObject, in_thing: str, out_thing: str) -> int:
            int ret
            if (!done) {
            mixed *rabbit
            rabbit = arg()
            done = 1
            if (arrayp(rabbit) && objectp(rabbit[0])) {
            womble = rabbit[0]
            done = 2


    def move(self, ob: MudObject, in_thing: str, out_thing: str) -> int:
            int ret
            ret = player.move(ob, in_thing, out_thing)
            if (ret) {
            if (id) {
            remove_asyncio.create_task(self.id)


    def second_life(self, ) -> int:
            mixed *bit
            int ret
            bit = arg()
            if (functionp(bit)) {
            ret = evaluate(bit, player)
            } else if (pointerp(bit)) {
            ret = call_other(bit[0], bit[1], player)


    def event_light_change(self, ob: MudObject, delta: int) -> None:
            asyncio.create_task(self."delayed_event_light_change",0, ob, delta )


    def delayed_event_light_change(self, ob: MudObject, delta: int) -> None:
            mixed *bit
            int ret
            bit = arg()
            if (functionp(bit)) {
            ret = evaluate(bit, player, ob, delta)
            } else if (pointerp(bit)) {
            ret = call_other(bit[0], bit[1], player, ob, delta)


    def query_mock_block(self, mocked: str) -> int:
            if( arg(.index( "all") if  "all" in arg( else -1 ) != -1 ) {
            return 1


    def __init__(self):
            self.specials = []
            self.weapons = ([ ])


    def good_fighter_setup(self, ) -> None:
            {
            int adjust
            int lvl
            int *args = arg()
            if (!args || !arrayp(args) || sizeof(args) != 2)
            return
            specials = [})
            bluntorsharp = args[0]
            dodgeorparry = args[1]
            lvl = player.query_level()
            check_skill("other.perception", lvl / 2)
            check_skill("other.health", lvl)
            adjust = lvl * 3 / 4
            if (bluntorsharp == USE_PIERCE) {
            check_skill("fighting.combat.melee.blunt", lvl - adjust)
            check_skill("fighting.combat.melee.sharp", lvl - adjust)
            check_skill("fighting.combat.melee.pierce", lvl + adjust)
            check_skill("fighting.combat.melee.unarmed", lvl - adjust)
            } else if (bluntorsharp == USE_BLUNT) {
            check_skill("fighting.combat.melee.blunt", lvl + adjust)
            check_skill("fighting.combat.melee.sharp", lvl - adjust)
            check_skill("fighting.combat.melee.pierce", lvl - adjust)
            check_skill("fighting.combat.melee.unarmed", lvl - adjust)
            } else if (bluntorsharp == USE_SHARP) {
            check_skill("fighting.combat.melee.blunt", lvl - adjust)
            check_skill("fighting.combat.melee.sharp", lvl + adjust)
            check_skill("fighting.combat.melee.pierce", lvl - adjust)
            check_skill("fighting.combat.melee.unarmed", lvl - adjust)
            } else if (bluntorsharp == USE_UNARMED) {
            check_skill("fighting.combat.melee.blunt", lvl - adjust)
            check_skill("fighting.combat.melee.sharp", lvl - adjust)
            check_skill("fighting.combat.melee.pierce", lvl - adjust)
            check_skill("fighting.combat.melee.unarmed", lvl + adjust)
            } else {
            check_skill("fighting.combat.melee.blunt", lvl)
            check_skill("fighting.combat.melee.sharp", lvl)
            check_skill("fighting.combat.melee.pierce", lvl)
            check_skill("fighting.combat.melee.unarmed", lvl)


    def event_fight_in_progress(self, attacker: MudObject, opponent: MudObject) -> None:
            {
            object ts, temp, weapon
            int chance
            string cmd, str
            ts = player
            ts.event_fight_in_progress(attacker, opponent)
            if (victim && !objectp(victim))
            victim = 0
            if (victim && !interactive(victim))
            victim = 0
            if (victim && environment(victim) != environment(player))
            victim = 0
            if (victim && victim != attacker)
            return
            if (!victim) {
            victim = attacker
            if (!victim)
            return


    def add_follower(self, ob: MudObject) -> int:
            asyncio.create_task(self."do_command", 0, "lose everyone")
            return player.add_follower(ob)


    def event_pub_brawl(self, ob: MudObject, mess: str) -> None:
            mixed *bit
            int ret
            bit = arg()
            if (functionp(bit)) {
            ret = evaluate(bit, player, ob, mess)
            } else if (pointerp(bit)) {
            ret = call_other(bit[0], bit[1], player, ob, mess)


    def move(self, dest: Any, messin: str, messout: str) -> Any:
            int ret
            ret = player.move(dest, messin, messout)
            if (ret == 0) {
            asyncio.create_task(self."do_savage_corpse", 0)


    def event_enter(self, ob: MudObject, mess: str, from: MudObject) -> None:
            player.event_enter(ob, mess, from)
            if (ob.query_corpse()) {
            remove_asyncio.create_task(self."real_savage")
            asyncio.create_task(self."real_savage", 10, ob)


    def stopped_route(self, ) -> None:
            object *obs
            int i
            mixed room
            room = arg()
            if (pointerp(room)) {
            room = room[0]


    def do_spell_effects(self, ob: MudObject) -> None:
            mixed *bit
            int ret
            bit = arg()
            if (functionp(bit)) {
            ret = evaluate(bit, player, ob)
            } else if (pointerp(bit)) {
            ret = call_other(bit[0], bit[1], player, ob)


    def event_death(self, ob: MudObject, mess: str) -> None:
            mixed *bit
            int ret
            bit = arg()
            if (functionp(bit)) {
            ret = evaluate(bit, player, ob, mess)
            } else if (pointerp(bit)) {
            ret = call_other(bit[0], bit[1], player, ob, mess)


    def attack_by(self, thing: MudObject) -> int:
            info = arg()
            if(!thing.query_property("player")){
            return 1


    def event_enter(self, ob: MudObject, mess: str, from: MudObject) -> None:
            string name = ob.query_name()
            int bing
            if(!ob.query_property("player")){
            return


    def vamp_corpse(self, corpse: MudObject) -> MudObject:
            string player_name
            if( corpse && objectp( corpse )
            && !corpse.query_property( "vampire corpse" )
            && corpse.query_race_name() == "human" ) {
            corpse.add_property( "no burial", 1 )
            corpse.add_property( "vampire corpse", 1 )
            if( stringp( player.query_property( "determinate" ) ) )
            player_name = player.query_property( "determinate" ) +
            player.query_short()
            else
            player_name =
            "/global/events"->convert_message( player.a_short() )
            corpse->add_effect( "/std/effects/npc/vampirecorpse_effect",
            [player_name, copy( player.query_gender() ),
            copy( player.query_level() ), 0] )


    def make_corpse(self, ) -> MudObject:
            object corpse
            corpse = player.make_corpse()
            vamp_corpse( corpse )
            return corpse


    def setup_shadow(self, thing: MudObject) -> None:
            shadow( thing, 1 )
            shadowed = thing
            concealed = [})


    def destruct_shadow(self, thing: MudObject) -> None:
            if ( thing == self )
            destruct( self )
            else
            thing.destruct_shadow( thing )


    def add_concealed(self, thing: MudObject) -> None:
            concealed -= [0]
            if ( concealed .index( thing) if  thing in concealed  else -1 == -1 )
            concealed += [thing]


    def set_worn_by(self, thing: MudObject) -> int:
            int weight
            if ( thing == (object)shadowed.query_donned in Faern_by() )
            return 1
            if ( !shadowed.set_donned in Faern_by( thing ) )
            return 0
            weight = (int)shadowed.query_weight()
            concealed -= [0]
            foreach ( thing in concealed ) {
            if ( (int)thing.query_complete_weight() > random( weight ) )
            thing.remove_hide_invis( "concealed" )


    def setup_shadow(self, thing: MudObject) -> None:
            shadow( thing, 1 )
            player = thing


    def run_away(self, ) -> None:
            await player.send("You feel too peaceful to run away.\n")


    def pk_check(self, thing1: Any, thing2: Any, off_line: int) -> int:
            return 1


    def adjust_hp(self, number: int, attacker: MudObject) -> None:
            if(player.query_attacker_list()) {
            foreach(attacker in player.query_attacker_list()) {
            attacker.stop_fight(player)
            player.stop_fight(attacker)


    def adjust_gp(self, number: int) -> None:
            if ( number < 0 )
            return player.adjust_gp( number )
            return


    def attack_by(self, ob: MudObject) -> int:
            ob.stop_fight(player)
            player.stop_fight(ob)
            return 1


    def test_add(self, ob: MudObject) -> int:
            if (ob.query_property("dead usable"))
            return 1
            return 0


    def attack(self, ) -> None:


    def adjust_hp(self, ) -> None:


    def set_hp(self, ) -> None:


    def do_death(self, ) -> None:


    def setup_shadow(self, ob: MudObject) -> None:
            shadow( ob, 1 )
            my_player = ob
            cost_life = my_player.query_property( "death cost life" )
            my_player.remove_property( "death cost life" )
            resurrect_adds_life = my_player.query_property( "resurrect should add life" )
            my_player.remove_property( "resurrect should add life" )


    def attack_by(self, ob: MudObject) -> int:
            await  ob.send("This person is a ghost... You cannot attack them.\n" )
            ob.stop_fight( my_player )
            return 1


    def attack_ob(self, ob: MudObject) -> int:
            write( "Your hand passes right through it!  You are just a ghost!\n" )
            return 0


    def short(self, ) -> str:
            if ( !my_player )
            return "Death shadow"
            return "the ghost of "+my_player.short()


    def dest_death_shadow(self, ) -> None:
            destruct( self )


    def cast(self, ) -> int:
            write( "Casting spells when you are dead?\n" )
            return 1


    def do_shout(self, ) -> int:
            write( "You are dead, that is not possible.\n" )
            return 1


    def do_echo(self, ) -> int:
            write( "You are dead...\n" )
            return 1


    def do_guild_command(self, ) -> int:
            write( "You are dead!\n" )
            return 1


    def do_race_command(self, ) -> int:
            write( "You are dead!\n" )
            return 1


    def score(self, ) -> int:
            write( "You are just a disembodied spirit.  What use has a wispy thing "
            "like you have for a collection of meaningless numbers?\n" )
            return 1


    def second_life(self, ) -> None:


    def setup_shadow(self, thing: MudObject) -> None:
            shadow( thing, 1 )
            shadowed = thing


    def destruct_shadow(self, thing: MudObject) -> None:
            if ( thing == self ) {
            destruct( self )
            } else {
            thing.destruct_shadow( thing )


    def set_effs(self, args: Any) -> None:
            ::set_effs(args)


    def set_eeq(self, args: Any) -> None:
            ::set_eeq(args)


    def setup_shadow(self, thing: MudObject, word: str) -> None:
            shadow( thing, 1 )
            player = thing
            protector = word
            protecting = 1
            asyncio.create_task(self. "dest_harry_shadow", 60 * 20 )


    def zap_harry_shadow(self, ) -> None:
            protecting = 0
            await  player.send("You lose "+ protector +"'s protection.\n" )
            asyncio.create_task(self. "dest_harry_shadow", 1 )


    def adjust_hp(self, number: int, thing: MudObject, weapon: MudObject, attack: str) -> int:
            if ( ( number > 0 ) || !protecting ||
            !thing || !pk_check(thing, player ) || player == this_player() )
            return (int)player.adjust_hp( number, thing, weapon, attack )
            return (int)player.query_hp()


    def set_hp(self, number: int, thing: MudObject) -> int:
            int current
            current = (int)player.query_hp()
            if ( ( number > current ) || !protecting || !thing || !thing.query_player_killer() )
            return (int)player.set_hp( number, thing )
            return current


    def attack_by(self, thing: MudObject) -> int:
            if ( !protecting || !thing.query_player_killer( ) )
            return (int)player.attack_by( thing )
            await  thing.send((string)player.the_short() +
            " are protected from combat by "+ protector +".\n" )
            tell_object( player, "You are protected from combat by "+
            protector +".\n" )
            thing.stop_fight( player )
            return 0


    def attack_ob(self, thing: MudObject) -> int:
            if ( protecting )
            zap_harry_shadow()
            return (int)player.attack_ob( thing )


    def do_ambushed(self, ) -> None:
            write( protector +" stops you from harming "+
            (string)player.the_short() +".\n" )
            tell_object( player, protector +" stops "+
            (string)this_player()->the_short() +" from harming you.\n" )


    def no_offense(self, ) -> int:
            if ( protecting )
            zap_harry_shadow()
            return (int)player.no_offense()


    def query_player_killer(self, ) -> int:
            return 0


    def command_shadowed(self, verb: str, args: str) -> int:
            if ( ["cast", "scathe", "perform"] .index( verb) if  verb in ["cast", "scathe", "perform"]  else -1 == -1 )
            return (int)player.command_shadowed( verb, args )
            if ( protecting )
            zap_harry_shadow()
            return (int)player.command_shadowed( verb, args )


    def __init__(self):
            self.yes_response = ([ "say":({ "yes", "yep", "sure", "ok",
            self.no_response = ([ "say":({ "no", "nope", ({ "won't", "i" }),
            self.local_prop = ([ MARRYPROP : 1, ])


    def add_marry_shadow(self, p: MudObject, m1: MudObject, m2: MudObject) -> MudObject:
            player = p
            marry1 = m1
            marry2 = m2
            askingwho = (string)marry1.query_name()
            asking = ASKFIRST
            tell_object( player, "Now you should ask " +
            (string) marry1.query_short() + " whether " +
            (string) marry1.query_pronoun() + " will marry " +
            (string) marry2.query_short() + "\n")
            return shadow( p, 1 )


    def remove_read_marks(self, str: str) -> str:
            int index, size
            string result
            string temp
            index = 0
            size = strlen(str)
            result = ""
            while (index < size) {
            temp = str[index..index]
            if (((temp >= "a") && (temp <= "z")) ||
            (temp == " ") || (temp == "'")) result += temp
            else result += " "
            index++


    def check_response(self, resptype: str, mess: str) -> None:
            if ( mess && strlen( mess ) ) {
            mess = lower_case( mess )
            mess = remove_read_marks(mess)
            words = explode( mess, " " )
            yes_array = yes_response[ resptype ]
            no_array = no_response[ resptype ]
            response_index = sizeof( yes_array )
            while ( response_index-- ) {
            if ( !stringp( yes_array[ response_index ] ) ) {
            if ( ( member_array( yes_array[ response_index ][ 0 ],
            words ) != -1 ) &&
            ( member_array( yes_array[ response_index ][ 1 ],
            words ) != -1 ) ) {
            do_accept()
            return


    def event_person_say(self, ob: MudObject, start: str, mess: str, lang: str) -> None:
            if ( ob.query_name() == askingwho ) {
            check_response("say", mess)


    def event_person_tell(self, ob: MudObject, start: str, mess: str, lang: str) -> None:
            if ( ob.query_name() == askingwho ) {
            check_response("say", mess)


    def do_accept(self, ) -> None:
            if ( asking == ASKFIRST ) {
            asking = ASKSECOND
            askingwho = (string) marry2.query_name()
            await  player.send((string) marry1.query_pronoun() +
            " accepted. Now you should ask " +
            (string) marry2.query_short() + " whether " +
            (string) marry2.query_pronoun() + " will marry " +
            (string) marry1.query_short() + "\n" )
            await  marry1.send("You accepted.\n" )
            } else if ( asking == ASKSECOND ) {
            asking = DONEASK
            askingwho = "*NoOne*"
            await  player.send((string) marry2.query_pronoun() +
            " accepted. Now you can ask if there are any objections or" +
            " you can finalize the wedding with 'marry them'.\n" )
            await  marry2.send("You accepted.\n" )
            } else {
            tell_object( player, "Something is wrong here, please tell Olorin " +
            "what you where doing.\n" )
            #ifdef LOG
            unguarded((: write_file, LOG ,
            "marry_error "+
            "in accept:" + asking + ";" + askingwho + "(" +
            (string) marry1.query_short() + " to " +
            (string) marry2.query_short() + ")" :))
            #endif
            asyncio.create_task(self. "remove_propose_shadow", 0 )


    def do_refuse(self, ) -> None:
            if ( asking == ASKFIRST ) {
            await  player.send((string) marry1.query_pronoun() +
            " wimpied out.\n" )
            await  marry1.send("You refused, the marriage is off.\n" )
            } else if ( asking == ASKSECOND ) {
            await  player .send((string) marry2.query_pronoun() +
            " wimpied out.\nYou'd better try to console " +
            (string) marry1.query_short() + "\n" )
            tell_object( marry2, "You refused, how will you explain that to "+
            (string) marry1.query_short() + ".\n" )
            } else {
            tell_object( player, "Something is wrong here, please tell Olorin " +
            "what you where doing.\n" )
            #ifdef LOG
            unguarded((: write_file, LOG ,
            "marry_error"+
            "in refuse:" + asking + ";" + askingwho + "(" +
            (string) marry1.query_short() + " to " +
            (string) marry2.query_short() + ")" :))
            #endif


    def query_property(self, str: str) -> Any:
            if ( str == MARRYPROP ) {
            return 1
            } else {
            return player.query_property( str )


    def do_wedding(self, ) -> int:
            if ( environment( player ) == environment( marry1 ) ) {
            if ( environment( player ) == environment( marry2 ) ) {
            marry1.add_property( "spouse", marry2->query_name() )
            marry2.add_property( "spouse", marry1->query_name() )
            ring1 = clone_object( RING )
            ring1.set_owner( marry1->query_short() )
            ring1.set_giver( marry2->query_short() )
            ring1.move( marry1 )
            ring2 = clone_object( RING )
            ring2.set_owner( marry2->query_short() )
            ring2.set_giver( marry1->query_short() )
            ring2.move( marry2 )
            await  player.send("They are now married, you'd better tell them.\n" )
            asyncio.create_task(self. "remove_marry_shadow", 0 )
            return 1
            } else {
            await  player.send(marry2.query_short() +
            " seems to have wandered off.\n" +
            "Perhaps you should try to console " +
            (string) marry1.query_short() + "\n" )


    def abort_wedding(self, ) -> int:
            asyncio.create_task(self. "remove_marry_shadow", 0 )
            return 0


    def remove_marry_shadow(self, ) -> None:
            destruct( self )
            return


    def setup_shadow(self, thing: MudObject) -> None:
            shadow( thing, 1 )
            player = thing


    def adjust_hp(self, number: int, thing: MudObject, weapon: MudObject, attack: str) -> int:
            if ( number > 0 )
            return (int)player.adjust_hp( number, thing, weapon, attack )
            else
            return (int)player.query_hp()


    def set_hp(self, number: int, thing: MudObject) -> int:
            int current
            current = (int)player.query_hp()
            if ( number > current )
            return (int)player.set_hp( number, thing )
            else
            return current


    def attack_by(self, thing: MudObject) -> int:
            await  thing.send((string)player.the_short() +
            " is prevented from fighting by Offler.\n" )
            thing.stop_fight( self )
            return 0


    def attack_ob(self, thing: MudObject) -> int:
            await  player.send("You are prevented from fighting by Offler.\n" )
            thing.stop_fight( self )
            return 0


    def do_ambushed(self, ) -> None:
            write( "You suddenly see a terrifying image of a huge crocodile!\n" )
            this_player()->run_away()


    def no_offense(self, ) -> int:
            write( "You are prevented from offensive actions by Offler.\n" )
            return 1


    def cast(self, ) -> int:
            write( "You are about to start when Offler stops you.\n" )
            return 1


    def setup_shadow(self, gambler: MudObject) -> None:
            shadow( gambler, 1 )
            this_gambler = gambler
            return


    def net_dead(self, ) -> None:
            this_gambler.net_dead()
            if ( !environment( this_gambler )->query_status()  &&
            !environment( this_gambler )->query_anted( this_gambler ) )  {
            tell_room( environment( this_gambler ), "One of the imps taps " +
            this_gambler.short() + " on the chalky forehead, "
            "pulls out a small hourglass, and begins watching it "
            "intently.\n" )
            asyncio.create_task(self. "do_leave", 30 )


    def inform_reconnect_game(self, ) -> None:
            tell_room( environment( this_gambler ), "The imp puts away its "
            "hourglass, nods happily at " +
            this_gambler.short() + ", and returns to the "
            "corner.\n", this_gambler )
            tell_object( this_gambler, "An imp puts away its hourglass, nods "
            "happily at you, and returns to the corner.\n")
            return


    def do_fold(self, ) -> None:
            tell_room( environment( this_gambler ), "The imp gently takes the cards "
            "from " + this_gambler.short() + " and returns to the "
            "corner.\n" )
            environment( this_gambler )->do_fold( this_gambler )
            return


    def do_leave(self, ) -> None:
            if ( environment( this_gambler )->query_status() )
            tell_room( environment( this_gambler ), "The imp gently takes the "
            "cards from " + this_gambler.short() + ", props " +
            this_gambler.query_objective() +
            " against the wall, and returns to the corner.\n" )
            else
            tell_room( environment( this_gambler ), "The imp props " +
            this_gambler.short() + " against the wall and "
            "returns to the corner.\n" )
            environment( this_gambler )->do_leave( this_gambler )
            return


    def do_check(self, ) -> None:
            await driver.tell_room( environment( this_gambler ), "The imp says, exclude=\"Time's up!\"\n" )
            environment( this_gambler )->do_check()
            return


    def do_idle(self, ) -> None:
            tell_room( environment( this_gambler ), "The imp announces, \"Time's up!  "
            "Continue without " + this_gambler.query_short() +
            ".\"\n" )
            tell_room( environment( this_gambler ), "The imp whispers something to " +
            this_gambler.query_short() + ".\n" )
            tell_object( this_gambler, "The imp whispers to you, \"If you can get "
            "some money before the cards are dealt, you can still "
            "play.\"\n" )
            environment( this_gambler )->sit_out( this_gambler )
            return


    def do_death(self, ) -> None:
            tell_object( this_gambler, "As you breathe your last, one of the imps "
            "leaps on your head screaming, \"Dead people are not allowed "
            "to play!\"\n" )
            tell_room( environment( this_gambler ), "As " +
            this_gambler.short() + " keels over, one of the imps "
            "leaps on " + this_gambler.query_possessive() +
            " head and screeches, \"Dead people are not allowed to "
            "play!\"\n", this_gambler )
            environment( this_gambler )->do_leave( this_gambler )
            this_gambler.do_death()
            return


    def dest_poker_shadow(self, ) -> None:
            asyncio.create_task(self. "zap", 0 )
            return


    def zap(self, ) -> None:
            destruct( self )
            return


    def prepare_to_leave(self, ) -> None:
            asyncio.create_task(self. "do_leave", 30 )
            return


    def prepare_to_fold(self, delay: int) -> None:
            asyncio.create_task(self. "do_fold", delay )
            return


    def prepare_to_check(self, delay: int) -> None:
            asyncio.create_task(self. "do_check", delay )
            return


    def prepare_to_idle(self, delay: int) -> None:
            asyncio.create_task(self."do_idle", delay)
            return


    def cancel_fold(self, ) -> None:
            int i
            i = 0
            while( remove_asyncio.create_task(self. "do_fold" )  != -1  ||
            remove_asyncio.create_task(self. "do_check" ) != -1  ||
            remove_asyncio.create_task(self. "do_idle" )  != -1   )  i = 1
            if ( i )
            tell_room( environment( this_gambler ), "The imp nods, puts away its "
            "hourglass, and returns to the corner.\n" )
            return


    def run_away(self, ) -> None:
            if ( previous_object() == find_object( FEAR ) )
            tell_object( this_player( 1 ), "One of the imps screeches, \"Quit "
            "trying to scare " + this_gambler.short() +
            "away!\"\n" )
            else this_gambler.run_away()
            return


    def add_effect(self, eff: str, duration: int) -> None:
            if ( eff == BLIND )  {
            write( "One of the imps jumps up and pokes you in the eyes screaming, "
            "\"How do YOU like it?\"\n" )
            say( "One of the imps pokes " + this_player()->query_short() + "in the "
            "eyes screaming, \"How do YOU like it?\"\n" )


    def event_quit(self, me: MudObject) -> None:
            environment( this_gambler )->event_exit( this_gambler, 0, 0 )
            return


    def setup_shadow(self, thing1: MudObject, thing2: MudObject) -> None:
            shadow( thing1, 1 )
            shadowed = thing1
            surface = thing2


    def query_shadowed(self, thing: MudObject) -> MudObject:
            if ( thing == self ) return shadowed
            return (object)thing.query_shadowed( thing )


    def destruct_shadow(self, thing: MudObject) -> None:
            if ( thing == self ) destruct( self )
            else thing.destruct_shadow( thing )


    def setup_shadow(self, thing: MudObject, victors: MudObject) -> None:
            {
            string *bits
            protector = 0
            if (environment(thing)) {
            bits = explode(file_name(environment(thing)), "/") - ["", "."]
            if (sizeof(bits) > 1 && bits[0] == "d") {
            object mast
            mast = load_object(implode(bits[0..1] + ["master"], "/"))
            if (mast)
            protector = mast.query_protector_string()


    def can_be_nasty(self, ) -> int:
            {
            object who
            object *inv
            if (!protecting)
            return 1
            if (!environment(player))
            return 1
            inv = all_inventory(environment(player))
            foreach (who in allowed)
            if (inv.index(who) if who in inv else -1 != -1)
            return 0
            return 1


    def zap_surrender_shadow(self, ) -> None:
            protecting = 0
            await  player.send("You lose "+ protector +"'s protection.\n" )
            asyncio.create_task(self. "dest_surrender_shadow", 1 )


    def adjust_hp(self, number: int, thing: MudObject, weapon: MudObject, attack: str) -> int:
            if ( ( number > 0 ) || !protecting ||
            !thing || !pk_check(thing, player ) || player == this_player() )
            return (int)player.adjust_hp( number, thing, weapon, attack )
            return (int)player.query_hp()


    def set_hp(self, number: int, thing: MudObject) -> int:
            int current
            current = (int)player.query_hp()
            if (number > current || !protecting || !thing)
            return (int)player.set_hp( number, thing )
            return current


    def cannot_walk(self, ) -> int:
            {
            if (!can_be_nasty()) {
            notify_fail("You can't leave while your subduer is here.\n")
            return 1


    def attack_by(self, thing: MudObject) -> int:
            if (!protecting)
            return (int)player.attack_by( thing )
            await  thing.send((string)player.the_short() +
            " is protected from combat by "+ protector +".\n" )
            tell_object( player, "You are protected from combat by "+
            protector +".\n" )
            thing.stop_fight( player )
            return 0


    def attack_ob(self, thing: MudObject) -> int:
            if (!can_be_nasty())
            return 0
            zap_surrender_shadow()
            return (int)player.attack_ob( thing )


    def do_ambushed(self, ) -> None:
            write( protector +" stops you from harming "+
            (string)player.the_short() +".\n" )
            tell_object( player, protector +" stops "+
            (string)this_player()->the_short() +" from harming you.\n" )


    def no_offense(self, ) -> int:
            if (!can_be_nasty())
            return 1
            zap_surrender_shadow()
            return (int)player.no_offense()


    def query_property(self, word: str) -> Any:
            if (protecting && word == "no attack")
            return 1
            return (mixed)player.query_property( word )


    def query_player_killer(self, ) -> int:
            return 0


    def command_shadowed(self, verb: str, args: str) -> int:
            if ( ["cast", "scathe"] .index( verb) if  verb in ["cast", "scathe"]  else -1 == -1 )
            return (int)player.command_shadowed( verb, args )
            if (!can_be_nasty())
            return notify_fail("You can't do that while you're subdued\n")
            zap_surrender_shadow()
            return (int)player.command_shadowed( verb, args )


    def test_remove(self, thing: MudObject, flag: int, dest: Any) -> int:
            {
            allowed -= [0]
            if (allowed.index(this_player()) if this_player() in allowed else -1 != -1)
            return 1
            else
            return player.test_remove(thing, flag, dest)


    def allowed_to_loot(self, who: MudObject, obj: MudObject) -> int:
            {
            if (allowed.index(who) if who in allowed else -1 != -1) {
            object wb
            if (!obj)
            return 1
            wb = obj.query_donned in Faern_by()
            if (wb == player && player.remove_armour(obj))
            return 0
            return 1
            } else
            return player.allowed_to_loot(who)


    def dest_surrender_shadow(self, ) -> None:
            {
            if (!player.query_property("player")) {
            player->move("/room/rubbish", "",
            player.one_short() + " runs off to recuperate.")
            } else {
            await player.send("You feel that you can leave now.\n")


    def query_sanctuary(self, ) -> int:
            {
            if (protecting) return 1
            else return player.query_sanctuary()


    def do_quit(self, ) -> int:
            {
            if (!can_be_nasty()) {
            write("You cannot quit while your subduer is here.\n")
            return 1


    def quit_alt(self, ) -> int:
            {
            if (!can_be_nasty()) {
            write("You cannot quit while your subduer is here.\n")
            return 1


    def setup_shadow(self, thing: MudObject) -> None:
            shadow( thing, 1 )
            player = thing


    def extra_score(self, ) -> str:
            string team
            team = (string)TEAM.query_party( player )
            if ( !team ) {
            asyncio.create_task(self. "destruct_team_shadow", 1 )
            return (string)player.extra_score()


    def setup_shadow(self, this_swimmer: MudObject) -> None:
            shadow( this_swimmer, 1 )
            swimmer = this_swimmer
            calc_swim_bonus()


    def event_enter(self, ob: MudObject, message: str, from: MudObject) -> None:
            int old_bonus, old_buoy
            if (swimmer) {
            swimmer.event_enter( ob, message, from )


    def event_exit(self, ob: MudObject, message: str, to: MudObject) -> None:
            int old_bonus, old_buoy
            if (swimmer) {
            swimmer.event_exit(ob, message, to)


    def calc_swim_bonus(self, ) -> None:
            float pct
            object *held
            if ( living( swimmer )  &&
            ( held = (object *)swimmer.query_holding() ) )  {
            swimmer.calc_burden()
            bonus = (int)swimmer.query_skill_bonus( SWIMMING_SKILL ) /
            ( sizeof( held - (object *)[0] ) + 1 )
            buoyancy = bonus - (int)swimmer.query_loc_weight() +
            (int)swimmer.query_property( BUOYANT_PROP )
            if ( (string)swimmer.query_race() == TROLL_RACE )  buoyancy -= 300
            if ( buoyancy < 0  &&  bonus )  {
            pct = -buoyancy / bonus
            if ( pct < 1.0 )  {
            bonus += buoyancy
            buoyancy = 0


    def add_property(self, prop: str, val: Any, time: int) -> None:
            if (swimmer) {
            swimmer.add_property( prop, val, time )


    def remove_property(self, prop: str) -> None:
            if (swimmer) {
            swimmer.remove_property( prop )


    def add_skill_level(self, skill: str, lev: int) -> int:
            int lvl
            if ( living(swimmer) )  {
            lvl = (int)swimmer.add_skill_level( skill, lev )
            if ( skill == SWIMMING_SKILL  &&  lev )  {
            calc_swim_bonus()
            test_sweep()
            test_float()


    def test_sweep(self, ) -> None:
            mapping flows, possible
            int total_flow, r, f, s, flow_rate
            string *dirs, dir, *dest_dir_info
            object room
            s = find_asyncio.create_task(self. "do_sweep" )
            room = environment( swimmer )
            flows = (mapping)room.query_flows()
            dest_dir_info = (string *)room.query_dest_dir()
            f = ( 300 - ( evaluate( flows[ sweep_dir ] ) - swimming * bonus ) ) / 30
            if ( f < 0 )  f = 0
            f += room.query_min_sweep_delay( sweep_dir )
            if ( s > f )  {
            remove_asyncio.create_task(self. "do_sweep" )
            asyncio.create_task(self. "do_sweep", f,
            dest_dir_info[ member_array( sweep_dir,
            dest_dir_info ) + 1 ] )


    def test_float(self, ) -> None:
            object room
            int s, t
            room = environment( swimmer )
            if ( buoyancy < 0 )  {
            remove_asyncio.create_task(self. "do_rise" )
            s = find_asyncio.create_task(self. "do_sink" )
            if ( !( room.query_bottom() ) )  {
            t = (300 + buoyancy) / 30
            if ( s > t )  {
            remove_asyncio.create_task(self. "do_sink" )
            s = -1


    def test_drown(self, ) -> None:
            int delay
            if ( environment( swimmer )->query_surface() )
            remove_asyncio.create_task(self."do_drown")
            else if ( find_asyncio.create_task(self. "do_drown" ) == -1  &&
            !( swimmer.query_property( GILLS_PROP ) ) )  {
            delay = (int)swimmer.query_skill_bonus( STAMINA_SKILL ) / 20
            if ( delay < 15 )  delay = 15
            asyncio.create_task(self. "do_drown", delay )
            drown_stage = 0


    def do_sweep(self, dest: str) -> None:
            mixed *dest_other_info
            object room
            room = environment(swimmer)
            if ( environment( swimmer )->query_terrain() )
            environment( swimmer )->set_destination( sweep_dir )
            dest_other_info = (mixed *)room.query_dest_other()
            if ( !( swimmer.query_property("player") ) )
            swimmer->move( dest,
            replace_string( (string)room.query_sweep_in_mess(),
            "$F",sweep_string( dest_other_info,
            member_array( sweep_dir,
            dest_other_info ) + 1 ) ),
            replace_string( (string)room.query_sweep_out_mess(),
            "$T", sweep_dir ) )
            else  {
            await  swimmer.send("The current pulls you " + sweep_dir + ".\n" )
            swimmer->move_with_look( dest,
            replace_string( (string)room->
            query_sweep_in_mess(), "$F",
            sweep_string( dest_other_info,
            member_array( sweep_dir,
            dest_other_info ) + 1 ) ),
            replace_string( (string)room->
            query_sweep_out_mess(), "$T",
            sweep_dir ) )


    def do_sink(self, ) -> None:
            string dir
            mixed *dest_other_info
            int i
            object room
            room = environment(swimmer)
            dir = (string)room.query_down_dir()
            if ( environment( swimmer )->query_terrain() )
            environment( swimmer )->set_destination( dir )
            dest_other_info = (mixed *)room.query_dest_other()
            if ( ( i = dest_other_info .index( dir) if  dir in dest_other_info  else -1 ) > -1 )  {
            if ( !( swimmer.query_property("player") ) )
            swimmer->move( dest_other_info[ i + 1 ][0],
            replace_string( (string)room.query_sink_in_mess(),
            "$F", sweep_string( dest_other_info,
            i + 1 ) ),
            replace_string( (string)room.query_sink_out_mess(),
            "$T", dir ) )
            else  {
            await  swimmer.send("You sink toward the bottom.\n" )
            swimmer->move_with_look( dest_other_info[ i + 1 ][0],
            replace_string( (string)room->
            query_sink_in_mess(),
            "$F", sweep_string( dest_other_info,
            i + 1 ) ),
            replace_string( (string)room->
            query_sink_out_mess(),
            "$T", dir ) )


    def do_rise(self, ) -> None:
            string dir
            mixed *dest_other_info
            int i
            object room
            room = environment( swimmer )
            dir = (string)room.query_up_dir()
            if ( environment( swimmer )->query_terrain() )
            environment( swimmer )->set_destination( dir )
            dest_other_info = (mixed *)room.query_dest_other()
            if ( ( i = dest_other_info .index( dir) if  dir in dest_other_info  else -1 ) > -1 )  {
            if ( !( swimmer.query_property("player") ) )
            swimmer->move( dest_other_info[ i + 1 ][0],
            replace_string( (string)room.query_float_in_mess(),
            "$F", sweep_string( dest_other_info,
            i + 1 ) ),
            replace_string( (string)room.query_float_out_mess(),
            "$T", dir ) )
            else  {
            await  swimmer.send("You drift toward the surface.\n" )
            swimmer->move_with_look( dest_other_info[ i + 1 ][0],
            replace_string( (string)room->
            query_float_in_mess(),
            "$F", sweep_string( dest_other_info,
            i + 1 ) ),
            replace_string( (string)room->
            query_float_out_mess(),
            "$T", dir ) )


    def do_drown(self, ) -> None:
            string *exits, up
            int delay
            delay = (int)swimmer.query_skill_bonus( STAMINA_SKILL ) / 5
            if ( delay < 15 )  delay = 15
            switch ( drown_stage )  {
            case 0:
            await  swimmer.send("Your lungs start to feel a bit heavy.\n" )
            tell_room( environment( swimmer ), (string)swimmer.query_short() +
            " begins to look a bit uncomfortable.\n", swimmer )
            asyncio.create_task(self. "do_drown", delay )
            break
            case 1:
            await  swimmer.send("Your lungs are starting to burn.\n" )
            tell_room( environment( swimmer ), (string)swimmer.query_short() +
            " starts to look slightly blue.\n", swimmer )
            asyncio.create_task(self. "do_drown", delay )
            break
            case 2:
            await  swimmer.send("Your lungs are fairly bursting.\n" )
            tell_room( environment( swimmer ), (string)swimmer.query_short() +
            " begins to look panicky.\n", swimmer)
            asyncio.create_task(self. "do_drown", delay )
            break
            default:
            swimmer.adjust_hp( ( 2 - drown_stage ) * 5 *
            ( 30 - (int)swimmer.query_con() ) )
            if ( swimmer.query_hp() > 0 )  {
            asyncio.create_task(self. "do_drown", delay )
            exits = (string *)environment( swimmer )->query_dest_dir()
            if ( member_array( up = (string)environment( swimmer )->
            query_up_dir(),
            exits ) > -1 )  {
            tell_object( swimmer, "You panic and try to flee for the "
            "surface.\n" )
            tell_room( environment( swimmer ),
            (string)swimmer.query_short() + " panics and madly "
            "tries to flee for the surface.\n", swimmer )
            swimmer.exit_command( up )


    def do_soak(self, ) -> None:
            swimmer.add_effect("/std/effects/other/wetness", swimmer->query_weight())
            swimmer.do_soak()


    def cancel_sweep(self, ) -> None:
            remove_asyncio.create_task(self. "do_sweep" )
            sweep_dir = ""
            return


    def dest_water_shadow(self, ) -> None:
            remove_asyncio.create_task(self. "do_sweep" )
            remove_asyncio.create_task(self. "do_rise" )
            remove_asyncio.create_task(self. "do_sink" )
            remove_asyncio.create_task(self. "do_drown" )
            remove_asyncio.create_task(self. "do_soak" )
            remove_asyncio.create_task(self. "test_again" )
            if (swimmer) {
            swimmer.remove_property("there")


    def command_shadowed(self, verb: str, args: str) -> int:
            string my_mess, others_mess
            my_mess = 0
            if ( !( environment( swimmer )->query_surface() ) )  {
            if ( verb == "say"  ||  verb == "'" )  {
            my_mess = "You try to talk, but only generate some bubbles."
            others_mess = (string)swimmer.query_short() + " emits a 'glub glub' "
            "noise."
            if ( !( swimmer.query_property( GILLS_PROP ) ) )  {
            my_mess += "  In the process you inhale some water.\n"
            others_mess += "  In the process, " +
            (string)swimmer.query_pronoun() + " inhales "
            "some water.\n"
            ++drown_stage


    def do_death(self, thing: MudObject) -> None:
            if (swimmer) {
            swimmer.do_death( thing )


    def remove_ghost(self, ) -> None:
            swimmer.remove_ghost()
            environment( swimmer )->event_enter( swimmer, "", 0 )
            return


    def move(self, dest: Any, messin: str, messout: str) -> int:
            string where, *dest_dir_info
            int pos
            if ( !swimmer.query_property( "dead" )  &&  living( swimmer ) )  {
            if ( objectp( dest ) )  where = file_name( dest )
            else where = dest
            dest_dir_info = (string *)environment( swimmer )->query_dest_dir()
            pos = dest_dir_info .index( where) if  where in dest_dir_info  else -1 - 1
            if ( pos > -1  &&
            !(int)environment( swimmer )->
            attempt_exit( dest_dir_info[ pos ], swimmer ) )  {
            notify_fail( "" )
            return MOVE_NO_DROP


    def do_float(self, ) -> int:
            if ( !swimming )  {
            await  swimmer.send("You are already drifting with the current.\n" )


    def do_swim(self, ) -> int:
            if ( swimming )  {
            await  swimmer.send("You are already fighting the current.\n" )


    def test_again(self, ) -> None:
            test_float()
            test_sweep()
            asyncio.create_task(self. "test_again", recheck_delay )


    def update_recheck(self, time_out: int) -> None:
            int t
            recheck_delay = time_out
            if ( time_out == -1 )  {
            remove_asyncio.create_task(self. "test_again" )


    def sweep_string(self, dest_other_info: Any, pos: int) -> str:
            if ( pointerp( dest_other_info[pos][5] ) )  {
            return dest_other_info[pos][5][1]


    def set_data(self, words: str) -> None:
            mapping special_attack( object target ) {
            int damage
            int skill
            int difficulty
            object *args
            args = arg()
            if((object)environment(target) != (object)environment(player)) {
            await player.send("Where did "+target.short()+" go?\n")
            remove_this_effect()
            return ([ ])


    def tasking_done(self, ) -> int:
            void event_death(object killed, object * others, object killer, string rmess,
            string kmess) {
            object *args
            player.event_death(killed, others, killer, rmess, kmess)
            args = arg()
            if ( killed == args[ 0 ] ) remove_this_effect()


    def set_data(self, words: str) -> None:
            mapping special_attack( object target ) {
            int i, damage, skill
            object *args
            mixed *attacks
            args = arg()
            if (!args) {
            return 0


    def tasking_done(self, ) -> int:
            ==================================================
            FILE: shadows/attached/single_shoulder.c
            ==================================================
            inherit "/std/effect_shadow"
            private int test_sash( object thing ) {
            return (string)thing.query_type() == "sash" &&
            sizeof(thing.query_pockets())


    def check_handicap(self, ) -> None:
            int new_arg
            mixed old_arg
            object *things
            things = (object *)player.query_wearing() - [0]
            old_arg = arg()
            if (objectp(old_arg)) {
            old_arg = 0


    def now_worn(self, thing: MudObject) -> None:
            player.now_donned in Faern( thing )
            if ( find_asyncio.create_task(self. "check_handicap" ) == -1 ) {
            asyncio.create_task(self. "check_handicap", 0 )


    def now_removed(self, thing: MudObject) -> None:
            player.now_removed( thing )
            if ( find_asyncio.create_task(self. "check_handicap" ) == -1 ) {
            asyncio.create_task(self. "check_handicap", 0 )


    def setup(self, ) -> None:
            set_light(50)
            set_theft_handler( HOSPITAL )
            set_save_file("%savedir%/flat%N%")
            set_orientation(%orientation%)
            set_quit_handler(%out%)
            set_short("front room")
            set_base_desc("a small and cosy front room" )
            add_surface( "floor", "finished pine board" )
            add_surface( "ceiling", "plain plaster" )
            add_surface( "%0% wall", "plain plaster" )
            add_surface( "%2% wall", "plain plaster" )
            add_surface( "%4% wall", "plain plaster" )
            add_surface( "%6% wall", "plain plaster" )
            add_exit("out", %out%, "door")
            modify_exit("out", ["door short", "front door"}))
            add_exit("%2%", PATH+"flat%N%bed", "door")
            modify_exit("%2%", ["door short", "bedroom door"}))
            modify_exit("out", ({"exit mess", "$N leaves the flat.",
            "enter mess",
            [1,
            "$N enters from a flat.",
            "$N enter from a flat."
            }),
            }) )
            modify_exit( "out", ["closed", 1] )


    def setup(self, ) -> None:
            set_light(50)
            set_theft_handler( HOSPITAL )
            set_save_file("%savedir%/flat%N%bed")
            set_orientation(%orientation%)
            set_quit_handler(%out%)
            set_short("bedroom")
            set_base_desc( "a small bedroom" )
            add_surface( "floor", "finished pine board" )
            add_surface( "ceiling", "plain plaster" )
            add_surface( "%0% wall", "plain plaster" )
            add_surface( "%2% wall", "plain plaster" )
            add_surface( "%4% wall", "plain plaster" )
            add_surface( "%6% wall", "plain plaster" )
            add_exit( "%6%", PATH +"flat%N%", "door" )
            modify_exit("%6%", ["door short", "livingroom door"])


    def setup(self, ) -> None:
            set_light(50)
            set_theft_handler( HOSPITAL )
            set_save_file("%savedir%/%N%bed")
            set_orientation(%orientation%)
            set_quit_handler(%out%)
            set_short("bedroom")
            set_base_desc( "a small bedroom" )
            add_surface( "floor", "finished pine board" )
            add_surface( "ceiling", "plain plaster" )
            add_surface( "%0% wall", "plain plaster" )
            add_surface( "%2% wall", "plain plaster" )
            add_surface( "%4% wall", "plain plaster" )
            add_surface( "%6% wall", "plain plaster" )
            add_exit( "down", PATH +"%N%livingroom", "stair" )
            modify_exit("down", ["downgrade", 9])


    def setup(self, ) -> None:
            set_light(50)
            set_theft_handler( HOSPITAL )
            set_save_file("%savedir%/%N%hall")
            set_orientation(%orientation%)
            set_quit_handler(%out%)
            set_short("front room")
            set_base_desc("a small hallway" )
            add_surface( "floor", "finished pine board" )
            add_surface( "ceiling", "plain plaster" )
            add_surface( "%0% wall", "plain plaster" )
            add_surface( "%2% wall", "plain plaster" )
            add_surface( "%4% wall", "plain plaster" )
            add_surface( "%6% wall", "plain plaster" )
            add_exit("out", %out%, "door")
            modify_exit("out", ({"door short", "front door",
            "exit mess", "$N leaves the house.",
            "closed", 1,
            "enter mess",
            [1,
            "$N enters from a house.",
            "$N enter from a house."
            }),
            }) )
            add_exit("%0%", PATH+"%N%livingroom", "door")
            modify_exit("%0%", ["door short", "livingroom door"}))


    def setup(self, ) -> None:
            set_light(50)
            set_theft_handler( HOSPITAL )
            set_save_file("%savedir%/%N%livingroom")
            set_orientation(%orientation%)
            set_quit_handler(%out%)
            set_short("livingroom")
            set_base_desc("a comfortable livingroom")
            add_surface("floor", "finished pine board" )
            add_surface("ceiling", "plain plaster" )
            add_surface("%0% wall", "plain plaster")
            add_surface("%2% wall", "plain plaster")
            add_surface("%4% wall", "plain plaster")
            add_surface("%6% wall", "plain plaster")
            add_exit("%4%", PATH+"%N%hall", "door")
            modify_exit("%4%", ({"door short", "hallway door"}))
            add_exit("up", PATH+"%N%bed", "stair")
            modify_exit("up", ["upgrade", 9])


    def setup(self, ) -> None:
            set_light(50)
            set_theft_handler( HOSPITAL )
            set_save_file("%savedir%/%N%bed")
            set_orientation(%orientation%)
            set_quit_handler(%out%)
            set_short("bedroom")
            set_base_desc( "a small bedroom" )
            add_surface( "floor", "stone paving" )
            add_surface( "ceiling", "roughly finished wood" )
            add_surface( "%0% wall", "roughly finished wood" )
            add_surface( "%2% wall", "roughly finished wood" )
            add_surface( "%4% wall", "roughly finished wood" )
            add_surface( "%6% wall", "roughly finished wood" )
            add_exit( "%4%", PATH +"%N%livingroom", "door" )
            modify_exit("%4%", ["door short", "living room door"])


    def setup(self, ) -> None:
            set_light(50)
            set_theft_handler( HOSPITAL )
            set_save_file("%savedir%/%N%livingroom")
            set_orientation(%orientation%)
            set_quit_handler(%out%)
            set_short("livingroom")
            set_base_desc("a small cramped livingroom")
            add_surface("floor", "stone paving" )
            add_surface("ceiling", "roughly finished wood" )
            add_surface("%0% wall", "roughly finished wood" )
            add_surface("%2% wall", "roughly finished wood" )
            add_surface("%4% wall", "roughly finished wood" )
            add_surface("%6% wall", "roughly finished wood" )
            add_exit("out", %out%, "door")
            modify_exit("out", ({"door short", "front door",
            "exit mess", "$N leaves the hut.",
            "closed", 1,
            "enter mess",
            [1,
            "$N enters from a hut.",
            "$N enter from a hut."
            }),
            }) )
            add_exit("%0%", PATH+"%N%bed", "door")
            modify_exit("%0%", ({"door short", "bedroom door"}))


    def setup(self, ) -> None:
            set_light(50)
            set_theft_handler( HOSPITAL )
            set_save_file("%savedir%/%N%bed2")
            set_orientation(%orientation%)
            set_quit_handler(%out%)
            set_short("bedroom")
            set_base_desc( "a small bedroom" )
            add_surface( "floor", "finished pine board" )
            add_surface( "ceiling", "plain plaster" )
            add_surface( "%0% wall", "plain plaster" )
            add_surface( "%2% wall", "plain plaster" )
            add_surface( "%4% wall", "plain plaster" )
            add_surface( "%6% wall", "plain plaster" )
            add_exit( "%0%", PATH +"%N%landing1", "door" )
            modify_exit("%0%", ["door short", "bedroom door"])
            add_exit("window", PATH + "%N%half-roof", "window")


    def setup(self, ) -> None:
            set_light(50)
            set_theft_handler( HOSPITAL )
            set_save_file("%savedir%/%N%bed3")
            set_orientation(%orientation%)
            set_quit_handler(%out%)
            set_short("bedroom")
            set_base_desc( "a small bedroom" )
            add_surface( "floor", "finished pine board" )
            add_surface( "ceiling", "plain plaster" )
            add_surface( "%0% wall", "plain plaster" )
            add_surface( "%2% wall", "plain plaster" )
            add_surface( "%4% wall", "plain plaster" )
            add_surface( "%6% wall", "plain plaster" )
            add_exit( "%0%", PATH +"%N%landing2", "door" )
            modify_exit("%0%", ["door short", "bedroom door"])
            add_exit("window", PATH + "%N%half-roof", "window")


    def setup(self, ) -> None:
            set_light(50)
            set_theft_handler( HOSPITAL )
            set_save_file("%savedir%/%N%bed4")
            set_orientation(%orientation%)
            set_quit_handler(%out%)
            set_short("bedroom")
            set_base_desc( "a small bedroom" )
            add_surface( "floor", "finished pine board" )
            add_surface( "ceiling", "plain plaster" )
            add_surface( "%0% wall", "plain plaster" )
            add_surface( "%2% wall", "plain plaster" )
            add_surface( "%4% wall", "plain plaster" )
            add_surface( "%6% wall", "plain plaster" )
            add_exit( "%4%", PATH +"%N%landing2", "door" )
            modify_exit("%4%", ["door short", "livingroom door"])


    def setup(self, ) -> None:
            set_light(50)
            set_theft_handler( HOSPITAL )
            set_save_file("%savedir%/%N%diningroom")
            set_orientation(%orientation%)
            set_quit_handler(%out%)
            set_short("spacious dining room")
            set_base_desc("a spacious dining room")
            add_surface( "floor", "finished pine board" )
            add_surface( "ceiling", "plain plaster" )
            add_surface( "%0% wall", "plain plaster" )
            add_surface( "%2% wall", "plain plaster" )
            add_surface( "%4% wall", "plain plaster" )
            add_surface( "%6% wall", "plain plaster" )
            add_exit("%3%", PATH+"%N%livingroom", "corridor")
            add_exit("%2%", PATH+"%N%kitchen", "corridor")
            add_exit("window", PATH+"%N%garden", "window")


    def setup(self, ) -> None:
            set_light(50)
            set_theft_handler( HOSPITAL )
            set_save_file("%savedir%/flat%N%study")
            set_orientation(%orientation%)
            set_quit_handler(%out%)
            set_short("small study")
            set_base_desc("a small study")
            add_surface( "floor", "finished pine board" )
            add_surface( "ceiling", "plain plaster" )
            add_surface( "%0% wall", "plain plaster" )
            add_surface( "%2% wall", "plain plaster" )
            add_surface( "%4% wall", "plain plaster" )
            add_surface( "%6% wall", "plain plaster" )
            add_exit("%6%", PATH+"%N%kitchen", "corridor")
            add_exit("%0%", PATH+"%N%garden", "door")


    def setup(self, ) -> None:
            set_light(50)
            set_theft_handler( HOSPITAL )
            set_save_file("%savedir%/%N%garden")
            set_orientation(%orientation%)
            set_quit_handler(%out%)
            set_short("small garden")
            set_base_desc("a quiet and secluded garden")
            add_surface("floor", "grass")
            add_surface("%0% wall", "red brick" )
            add_surface( "%2% wall", "red brick" )
            add_surface( "%6% wall", "red brick" )
            add_exit("%4%", PATH+"%N%familyroom", "door")
            modify_exit("%4%", ["door short", "garden door"])
            add_exit("window", PATH+"%N%diningroom", "window")


    def setup(self, ) -> None:
            set_light(100)
            set_short("half-roof")
            set_long("This is a half-roof, a piece of sloping roof halfway up the "
            "front of the house.  There is a window to the %2% and another "
            "to the %6%.\n")
            set_slope(30, "half-roof", %out%)
            add_exit("%6% window", PATH+"%N%bed2", "window")
            add_exit("%2% window", PATH+"%N%bed3", "window")
            set_wall( ["bottom", [%out", 250],] )
            set_wall( ["move", ["down", 30, %out%,
            "$N climb$s down from above to join you."]] )


    def setup(self, ) -> None:
            set_light(50)
            set_theft_handler( HOSPITAL )
            set_save_file("%savedir%/%N%kitchen")
            set_orientation(%orientation%)
            set_quit_handler(%out%)
            set_short("large kitchen")
            set_base_desc("a large kitchen")
            add_surface( "floor", "finished pine board" )
            add_surface( "ceiling", "plain plaster" )
            add_surface( "%0% wall", "plain plaster" )
            add_surface( "%2% wall", "plain plaster" )
            add_surface( "%4% wall", "plain plaster" )
            add_surface( "%6% wall", "plain plaster" )
            add_exit("%6%", PATH+"%N%diningroom", "corridor")
            add_exit("%4%", PATH+"%N%livingroom", "corridor")
            add_exit("%2%", PATH+"%N%familyroom", "corridor")


    def setup(self, ) -> None:
            set_light(50)
            set_theft_handler( HOSPITAL )
            set_save_file("%savedir%/%N%landing1")
            set_orientation(%orientation%)
            set_quit_handler(%out%)
            set_short("landing")
            set_base_desc( "a landing at the top of the stairs" )
            add_surface( "floor", "finished pine board" )
            add_surface( "ceiling", "plain plaster" )
            add_surface( "%0% wall", "plain plaster" )
            add_surface( "%4% wall", "plain plaster" )
            add_surface( "%6% wall", "plain plaster" )
            add_exit( "%0%", PATH +"%N%masterbed", "door" )
            modify_exit("%0%", ["door short", "bedroom door"])
            add_exit( "%4%", PATH +"%N%bed2", "door" )
            modify_exit("%4%", ["door short", "bedroom door"])
            add_exit("%2%", PATH+"%N%landing2", "corridor")
            add_exit("down", PATH+"%N%livingroom", "corridor")
            modify_exit("down", ({"downgrade", 9])


    def setup(self, ) -> None:
            set_light(50)
            set_theft_handler( HOSPITAL )
            set_save_file("%savedir%/flat%N%bed")
            set_orientation(%orientation%)
            set_quit_handler(%out%)
            set_short("hallway")
            set_base_desc( "a hallway" )
            add_surface( "floor", "finished pine board" )
            add_surface( "ceiling", "plain plaster" )
            add_surface( "%0% wall", "plain plaster" )
            add_surface( "%2% wall", "plain plaster" )
            add_surface( "%4% wall", "plain plaster" )
            add_exit( "%0%", PATH +"%N%bed4", "door" )
            modify_exit("%0%", ["door short", "bedroom door"])
            add_exit( "%4%", PATH +"%N%bed3", "door" )
            modify_exit("%4%", ["door short", "bedroom door"])
            add_exit( "%6%", PATH +"%N%landing1", "corridor" )


    def setup(self, ) -> None:
            set_light(50)
            set_theft_handler( HOSPITAL )
            set_save_file("%savedir%/%N%livingroom")
            set_orientation(%orientation%)
            set_quit_handler(%out%)
            set_short("livingroom")
            set_base_desc("a large, comfortable, and sunny livingroom")
            add_surface("floor", "finished pine board" )
            add_surface("ceiling", "plain plaster" )
            add_surface("%0% wall", "plain plaster")
            add_surface("%2% wall", "plain plaster")
            add_surface("%4% wall", "plain plaster")
            add_surface("%6% wall", "plain plaster")
            add_exit("out", %out%, "door")
            modify_exit("out", ({"door short", "front door"}))
            add_exit("%7%", PATH+"%N%diningroom", "corridor")
            add_exit("%0%", PATH + "%N%kitchen", "corridor")
            add_exit("up", PATH + "%N%landing1", "corridor")
            modify_exit("up", ({"upgrade", 9}))
            modify_exit("out", ({"message", "$N leaves the house.",
            "enter",
            [1,
            "$N enters from a house.",
            "$N enter from a house."],
            "closed", 1,
            "door long", "This is the front door to a house.  "
            "It has the numerals '%N%' in brass lettering.\n",
            }) )


    def setup(self, ) -> None:
            set_light(50)
            set_theft_handler( HOSPITAL )
            set_save_file("%savedir%/%N%masterbed")
            set_orientation(%orientation%)
            set_quit_handler(%out%)
            set_short("bedroom")
            set_base_desc( "a huge master bedroom" )
            add_surface( "floor", "finished pine board" )
            add_surface( "ceiling", "plain plaster" )
            add_surface( "%0% wall", "plain plaster" )
            add_surface( "%2% wall", "plain plaster" )
            add_surface( "%4% wall", "plain plaster" )
            add_surface( "%6% wall", "plain plaster" )
            add_exit( "%4%", PATH +"%N%landing1", "door" )
            modify_exit("%4%", ["door short", "bedroom door"])


    def set_boundaries(self, min: int, max: int) -> None:
            {
            x1 = min[0]
            x2 = max[0]
            y1 = min[1]
            y2 = max[1]


    def query_pass_through(self, coord: int) -> int:
            {
            return 100


    def install_effect(self, ) -> None:
            {
            (void)POTION_SPACE_HANDLER.remove_effect(file_name(self))
            (void)POTION_SPACE_HANDLER.add_effect(file_name(self), x1, x2, y1, y2)


    def sqrt(self, p: int) -> int:
            {
            int i
            for (i = 1; i < 500; i++) if (i * i > p) return i-1


    def distance_within_region(self, coord: int) -> int:
            {
            int dx, dy
            if (x1 < 0) {
            if (x2 > 0)
            dx = (coord[0] < 0) ? -coord[0] : coord[0]
            else
            dx = (x2 - coord[0])
            } else
            dx = coord[0] - x1
            if (y1 < 0) {
            if (y2 > 0)
            dy = (coord[1] < 0) ? -coord[1] : coord[1]
            else
            dy = (y2 - coord[1])
            } else
            dy = coord[1] - y1
            return sqrt(dx * dx + dy * dy)


    def distance_from_origin(self, coord: int) -> int:
            {
            return sqrt(coord[0] * coord[0] + coord[1] * coord[1])


    def beginning(self, thing: MudObject, amount: int, id: int) -> int:
            tell_object(find_player("ceres"), sprintf("Adding trap to %O\n",
            thing))
            thing.set_lock_trap(thing, "trap_lock")
            return 0


    def beginning(self, player: MudObject, time: int, id: int) -> None:
            if (time == 0) {
            time = 30*60


    def end(self, player: MudObject, time: int, id: int) -> None:


    def create_bug(self, player: MudObject, time: int, id: int) -> None:
            object bug
            object room
            string env_string
            object *ignore
            bug = clone_object("/obj/monster/cockroach")
            room = environment(player)
            env_string = player.the_short()
            ignore = [})
            while (room) {
            if (room == environment(player) && living(player)) {
            await player.send(env_string+" have "+bug.a_short()+
            " suddenly pop out of your "
            "ear.\n")
            ignore += [player]
            tell_room(room, env_string+" has "+bug.a_short()+
            " suddenly pop out of "+
            player.query_possessive()+
            " ear.\n", ignore)
            } else if (living(player)) {
            tell_room(room, env_string+" has "+bug.a_short()+
            " suddenly pop out of "+
            player.query_possessive()+
            " ear.\n", ignore)
            } else {
            tell_room(room, env_string+" has "+bug.a_short()+
            " suddenly pop out of it.\n", ignore)


    def beginning(self, player: MudObject, time: int, id: int) -> None:
            player.submit_ee( "make_stink", [20, 20], EE_CONTINUOUS )
            player.submit_ee( 0, time, EE_REMOVE )


    def merge_effect(self, player: MudObject, time1: int, time2: int, id: int) -> int:
            player.submit_ee( 0, time1 + time2 - (int)player.expected_tt(),
            EE_REMOVE )
            return time1 + time2


    def end(self, player: MudObject, time: int, id: int) -> None:
            await  player.send("Your stomach calms down at last.\n" )


    def make_stink(self, player: MudObject, time: int, id: int) -> None:
            tell_object( player, "A huge trumpeting noise comes from your "
            "rear, closely followed by a stench of boiled cabbage.\n" )
            tell_room( environment( player ), "The smell of sprouts and cabbages from "
            + (string)player.one_short() +
            " wafts over you and you find yourself thinking of school dinners."
            "\n", player )


    def smell_string(self, player: MudObject, time: int) -> str:
            return "the delicious doughnutty smell"


    def query_classification(self, ) -> str:
            return "object.extra_description"


    def beginning(self, thing: MudObject, args: Any) -> None:
            string description
            int duration
            description = args[ 0 ]
            duration = args[ 1 ]
            if( !stringp( description ) || !intp( duration ) ) return
            thing.add_extra_look( self )
            thing.submit_ee( 0 , duration , EE_REMOVE )


    def extra_look(self, thing: MudObject) -> str:
            int *enums
            string message, temp
            enums = thing.effects_matching( query_classification() )
            if( !sizeof( enums ) ) {
            thing.remove_extra_look( self )
            return ""


    def end(self, thing: MudObject, args: Any, id: int) -> None:
            if( sizeof( args ) == 3 && stringp( args[ 2 ] ) ) {
            string end_mess = args[ 2 ]
            if( end_mess[<2 .. ] != "\n" ) end_mess += "\n"
            await  thing .send(end_mess )


    def query_classification(self, ) -> str:
            {
            return "object.heat"


    def query_shadow_ob(self, ) -> str:
            {
            return SHADOWS+"heat_shadow"


    def beginning(self, ob: MudObject, heat: int, id: int) -> int:
            {
            ob.submit_ee("change_temperature", [45, 15], EE_CONTINUOUS)
            ob.add_extra_look(self)
            return heat


    def restart(self, ob: MudObject) -> None:
            {
            ob.add_extra_look(self)


    def merge_effect(self, ob: MudObject, new_heat: int, old_heat: int, id: int) -> int:
            {
            int heat
            heat = new_heat + old_heat
            if(heat < 21)
            {
            ob.submit_ee(0, 0, EE_REMOVE)


    def end(self, ob: MudObject, heat: int, id: int) -> None:
            {
            ob.remove_extra_look(self)


    def change_temperature(self, ob: MudObject, heat: int, id: int) -> None:
            {
            int shift
            int env_temp
            int new_heat
            env_temp = environment(ob)->query_heat()
            if(!env_temp)
            {
            env_temp = 20


    def extra_look(self, ob: MudObject) -> str:
            {
            int heat
            int *enums
            int red_hot
            enums = ob.effects_matching("object.heat")
            if(!sizeof(enums))
            {
            return ""


    def beginning(self, player: MudObject, amount: int) -> None:
            player.submit_ee(0, amount, EE_REMOVE)
            player.add_extra_look(self)


    def merge_effect(self, player: MudObject, old_amount: int, new_amount: int) -> int:
            if (old_amount > new_amount)
            return old_amount
            return new_amount


    def query_shadow_ob(self, ) -> str:
            return SHADOWS+"shadow_horse"


    def survive_death(self, ) -> int:
            return 0


    def extra_look(self, player: MudObject) -> str:
            return capitalize((string)player.the_short()) +
            " is mounted on a large, black horse.\n"


    def end(self, player: MudObject, amount: int, id: int) -> None:
            player.remove_extra_look(self)


    def query_shadow_ob(self, ) -> str:
            class special_stuff beginning( object thing, mapping data, int id ) {
            class special_stuff special_stuff
            special_stuff = new(class special_stuff)
            special_stuff->keep = data["keep"]
            special_stuff->identity = data["identity"]
            thing.set_keep_value(special_stuff->keep)
            thing.set_identifier(special_stuff->identity)
            thing.set_identity_hold_owner(this_player())
            return special_stuff


    def end(self, thing: MudObject, store: Any, id: int) -> None:


    def query_indefinite(self, ) -> int:
            object create_store(mapping map,
            object player) {
            object store
            store = clone_object( "/std/container" )
            if ( objectp( player ) ) {
            store.set_player( player )


    def query_classification(self, ) -> str:
            mixed* beginning( object thing, object label, int id ) {
            object store
            store = clone_object( "/std/container" )
            label.move( store )
            thing.add_extra_look( file_name(self) )
            return [store, store.query_dynamic_auto_load()]


    def end(self, thing: MudObject, store: Any, id: int) -> None:
            int i
            if (arrayp(store)) {
            for(i=0; i<sizeof(store); i++)
            if(objectp(store[i]))
            store[i]->dest_me()
            } else if(objectp(store))
            store.dest_me()
            thing.remove_extra_look( self )


    def extra_look(self, thing: MudObject) -> str:
            int *enums
            object store
            object *labels
            mixed *bing
            enums = (int *)thing.effects_matching( "object.label" )
            if ( !sizeof( enums ) ) {
            return ""


    def chat(self, player: MudObject, arg: Any, id: int) -> None:
            {
            string *mechats = ({
            "Something's crawling inside the shoes.\n",
            "The Cobblers of Sek must've made these things!\n",
            "Did that vice just screw down tighter?\n",
            "*OUCH* that stung!\n",
            "You not-so-idly wonder who came up with these shoes.\n"
            })
            string *youchats = ({
            " winces in pain.\n",
            " mutters something about shoes.\n",
            " stumbles.\n"
            })
            if (!interactive(player)) return
            await player.send(mechats[random(sizeof(mechats))])
            tell_room(environment(player),
            player.query_cap_name() + youchats[random(sizeof(youchats))],
            [player] )


    def notify(self, player: MudObject, arg: Any, id: int) -> None:
            {
            tell_object(player,
            "A fiery pain shoots up your legs from your feet.\n")


    def beginning(self, player: MudObject, amount: int, id: int) -> None:
            {
            player.add_extra_look( self )
            player.adjust_bonus_dex(-1)
            player.submit_ee("chat", [10, 30], EE_CONTINUOUS)
            player.submit_ee("notify", 1, EE_ONCE)


    def restart(self, player: MudObject, amount: int, id: int) -> None:
            {
            beginning(player, amount, id)


    def merge_effect(self, player: MudObject, oldarg: Any, newarg: Any, id: int) -> None:
            {
            return


    def end(self, player: MudObject, amount: int, id: int) -> None:
            {
            player.remove_extra_look( self )
            player.adjust_bonus_dex(1)
            await player.send("Ahhhh!  Free from those evil shoes!\n")


    def extra_look(self, player: MudObject) -> str:
            {
            int *enums
            enums = (int *)player.effects_matching( CLASS )
            if ( !sizeof( enums ) )
            return ""
            return(capitalize(player.query_pronoun()) +
            " looks embarrassed and uncomfortable.\n")


    def beginning(self, thing: MudObject, owner: str, id: int) -> None:
            string merge_effect( object thing, string old_owner, string new_owner,
            int id ) {
            return old_owner


    def query_classification(self, ) -> str:
            string* beginning(object thing, string* desc){
            switch(sizeof(desc)){
            case 5:
            thing.add_property("determinate", desc[4])
            case 4:
            thing.add_alias(desc[3])
            case 3:
            thing.add_adjective(desc[2])
            case 2:
            thing.set_long(desc[1])
            case 1:
            thing.set_short(desc[0])


    def beginning(self, thing: MudObject, owner: str, id: int) -> None:
            string merge_effect( object thing, string old_owner, string new_owner,
            int id ) {
            write( "There is a bug with the ownership of "+
            (string)thing.the_short() +" ("+ file_name( thing ) +
            ")!  Please bug report it and contact a creator!\n" )
            return old_owner


    def beginning(self, player: MudObject, time: int) -> None:
            player.submit_ee( "test_donned in Faern", 1, EE_ONCE )
            player.submit_ee( "test_donned in Faern", 20, EE_CONTINUOUS )


    def restart(self, player: MudObject) -> None:


    def merge_effect(self, player: MudObject, old_state: int, new_state: int) -> int:
            return old_state | new_state


    def test_for_effect(self, thing: MudObject) -> int:
            if ( !thing )
            return 0
            return member_array( file_name( self ),
            (string *)thing.query_wear_effects() ) != -1


    def test_worn(self, player: MudObject) -> None:
            if ( player.still_auto_loading() )
            return
            if ( !sizeof( filter_array( (object *)player.query_armours(),
            "test_for_effect", self ) ) ) {
            player.submit_ee( 0, 0, EE_REMOVE )
            return


    def query_indefinite(self, ) -> int:
            protected class talker_args new_talker_args() {
            return new(class talker_args, status : 1, channels : ["one"],
            verbose : 1, local_echo : 0, colour : 0 )


    def restart(self, thing: MudObject, args: Any, id: int) -> None:
            if (!classp(args)) {
            thing.set_arg_of(thing->sid_to_enum(id), new_talker_args())
            tell_object( environment( thing ), "Your talker quivers "
            "uncontrollably and starts to jump around.  You will have "
            "to re-add your talker channels and reconfigure your talker.\n" )


    def end(self, thing: MudObject, args: Any, id: int) -> None:
            if ( environment( thing ) )
            tell_object( environment( thing ), "The pair of glittering eyes in "+
            (string)thing.the_short() +" close and fade away forever.\n" )
            thing.remove_extra_look( self )
            thing.remove_alias( "talker" )
            thing.remove_plural( "talkers" )


    def extra_look(self, thing: MudObject) -> str:
            int *enums
            mixed args
            enums = (int *)thing.effects_matching( "magic.talker" )
            if ( !sizeof( enums ) ) {
            return ""


    def channels(self, ) -> str:
            return sprintf( "%#-*s\n", (int)this_player()->query_cols(),
            implode( all_channels( this_player() ), "\n" ) )


    def find_actual_talker(self, thing: MudObject) -> MudObject:
            object talker
            while ( thing ) {
            talker = thing
            thing = query_shadowing( thing )


    def list(self, word: str, brief: int) -> str:
            int space
            int *enums
            string sender
            string table
            object thing
            object *ok
            object *things
            object holder
            class talker_args args
            table = ""
            space = (int)this_player()->query_cols() - 20
            things = children( SHADOWS + "talker" ) -
            [find_object( SHADOWS + "talker" )]
            things = filter( map( things, (: find_actual_talker( $1 ) :) ),
            (: $1 && environment($1) && living(environment($1)) &&
            (!userp($1) || interactive($1)) :) )
            things = uniq_array(things)
            things = sort_array( things,
            (: strcmp( environment($1)->query_name(),
            environment($2)->query_name() ) :) )
            ok = [})
            foreach( thing in things ) {
            holder = environment( thing )
            if (userp(holder)) {
            sender = capitalize( holder.query_cap_name() )
            } else {
            sender = capitalize( holder.query_name() )


    def normalise_name(self, channel: str) -> str:
            int position
            mixed *details
            string *lower_names
            string lower_channel
            lower_channel = lower_case( channel )
            lower_names = map( valid_channels, (: lower_case($1) :) )
            position = lower_names .index( lower_channel) if  lower_channel in lower_names  else -1
            if ( position == -1 ) {
            details = HELP_CMD->find_match_in_array( lower_channel,
            lower_names )
            if ( details[ 1 ] > 70 ) {
            return valid_channels[ details[ 0 ] ]


    def reset(self, ) -> None:
            _channel_cache = ([ ])


    def clear_cache(self, person: str) -> None:
            if (_channel_cache) {
            map_delete(_channel_cache, person)


    def beginning(self, thing: MudObject, amount: int, id: int) -> None:
            thing.submit_ee( "dry_off", [30, 90], EE_CONTINUOUS )
            thing.add_extra_look( self )
            thing.add_adjective("wet")


    def merge_effect(self, thing: MudObject, old_amount: int, new_amount: int, id: int) -> int:
            return old_amount + new_amount


    def end(self, thing: MudObject, amount: int, id: int) -> None:
            thing.remove_extra_look( self )
            thing.remove_adjective("wet")


    def restart(self, thing: MudObject, amount: int, id: int) -> None:
            thing.add_extra_look( self )


    def dry_off(self, thing: MudObject, amount: int, id: int) -> None:
            amount -= 100 + amount / 10
            if ( amount > 0 )
            thing.set_arg_of( (int)thing.sid_to_enum( id ), amount )
            else
            thing.submit_ee( 0, 0, EE_REMOVE )


    def wet_string(self, thing: MudObject) -> str:
            int *enums
            string wetness
            enums = (int *)thing.effects_matching( "object.wet" )
            if ( !sizeof( enums ) )
            return ""
            switch ( (int)thing.arg_of( enums[ 0 ] ) / ( 1 +
            (int)thing.query_weight() ) ) {
            case 0 :
            return "just barely damp"
            case 1 .. 5 :
            wetness = "slightly wet"
            break
            case 6 .. 10 :
            wetness = "wet"
            break
            case 11 .. 30 :
            wetness = "very wet"
            break
            case 31 .. 80 :
            wetness = "sopping wet"
            break
            default :
            wetness = "absolutely soaking wet"


    def extra_look(self, thing: MudObject) -> str:
            return "It is " + wet_string(thing) + ".\n"


    def beginning(self, player: MudObject, time: int) -> None:
            if (time > 1800)
            time = 1800
            await  player.send("\n" )
            await driver.tell_room( environment( player ), (string)player.the_short() + " drinks some of his coffee and ends up with a small amount of froth on "+player.query_possessive()+" nose.\n", exclude=player)
            player.submit_ee( 0, time, EE_REMOVE )
            player.add_extra_look( self )


    def merge_effect(self, player: MudObject, time1: int, time2: int) -> int:
            int newtime
            newtime = (time1 > time2 ) ? time1 : time2
            newtime = ( newtime > 1800 ) ? 1800 : newtime
            player.submit_ee( 0, newtime, EE_REMOVE )
            return newtime


    def end(self, player: MudObject, time: int) -> None:
            if ( !player.query_property( "dead" ) )
            await  player.send("A small amount of frothy Coffee drops onto the floor.\n" )
            player.remove_extra_look( self )


    def extra_look(self, player: MudObject) -> str:
            return capitalize( player.query_pronoun()+" looks "
            "like "+player.query_pronoun()+" has a small amount of creamy, frothy coffee on "+player.query_possessive()+" nose.\n" )


    def cleanse(self, thing: MudObject, bonus: int) -> int:
            int i, flag, *effnums
            class effect *effs
            if ( !thing )
            return 0
            if ( !living( thing ) )
            return 0
            effnums = (int *)thing->effects_matching(
            "disease.parasite.external.flea")
            if ( !sizeof( effnums ) )
            return 0
            effs = (class effect *)thing.query_effs()
            for ( i = sizeof( effnums ) - 1; i >= 0; i-- )
            if ( effs[ effnums[ i ] ]->ob_name->test_remove( thing,
            effs[ effnums[ i ] ]->arg, effnums[ i ], bonus ) ) {
            thing.delete_effect( effnums[ i ] )
            flag = 1


    def beginning(self, player: MudObject, time: int) -> None:
            player.submit_ee( "make_smell", [20, 30], EE_CONTINUOUS )
            player.submit_ee( "kill_flea", [30, 40], EE_CONTINUOUS )
            asyncio.create_task(self."cleanse", 0, player, time/10)
            player.submit_ee( 0, time, EE_REMOVE )


    def merge_effect(self, player: MudObject, time1: int, time2: int) -> int:
            player.submit_ee( 0, time1 + time2 - (int)player.expected_tt(),
            EE_REMOVE )
            if (!infested)
            asyncio.create_task(self."cleanse", 0, player, (time1+time2)/10)
            return time1 + time2


    def end(self, player: MudObject, time: int) -> None:
            await  player.send("The odd odour is gone now.\n" )


    def kill_flea(self, player: MudObject) -> None:
            if (infested && random(2)) {
            tell_object( player, "You hear a faint scream and see a small dot " +
            "fall past your eyes.\n" )
            tell_room( environment( player ), "You see a tiny speck leap from " +
            (string)player.short() + "'s head, screaming pitifully.\n",
            player )


    def make_smell(self, player: MudObject) -> None:
            tell_object( player, "You notice a strange odour, like wet Grflx "
            "and rotting cabbage, in the air.\n" )
            tell_room( environment( player ),  "A smell reminiscent of a wet Grflx "+
            "and rotting cabbages seems to emanate from "+
            (string)player.short() + ".\n", player )


    def smell_string(self, player: MudObject, time: int) -> str:
            return "the odd odour of wet Grflx and rotting cabbage"


    def query_classification(self, ) -> str:
            return "herb.insect.repellent"


    def beginning(self, them: MudObject, power: int, id: int) -> int:
            if (power <= 0) {
            them.submit_ee(0, 1, EE_REMOVE)
            return 0


    def merge_effect(self, them: MudObject, power: int, adjust: int) -> int:
            power += adjust
            if (power <= 0) {
            them.submit_ee(0, 1, EE_REMOVE)
            return 0


    def start_mess(self, them: MudObject, power: int, id: int) -> None:
            string start_mess
            switch (power) {
            case 1:
            start_mess = "You smell rather pleasant, much as you might wish to for a "
            "date."
            break
            case 2..3:
            start_mess = "A pungent smell envelops you."
            break
            default:
            start_mess = "A horribly pungent smell envelops you, sufficient to make "
            "anyone with a sense of smell keep their distance."


    def smell(self, them: MudObject, power: int, id: int) -> None:
            string self_mess, other_mess
            object env
            if (--power <= 0) {
            await them.send("The herbal odour around you fades away.\n")
            them.remove_property("insect")
            them.submit_ee(0, 1, EE_REMOVE)
            return 0


    def beginning(self, player: MudObject, amount: int, id: int) -> None:
            player.add_extra_look( self )
            player.submit_ee( "decrease_amount", 15, EE_CONTINUOUS )


    def restart(self, player: MudObject, amount: int, id: int) -> None:
            player.add_extra_look( self )


    def merge_effect(self, player: MudObject, old_amount: int, new_amount: int, id: int) -> int:
            return old_amount + new_amount


    def end(self, player: MudObject, amount: int, id: int) -> None:
            player.remove_extra_look( self )


    def decrease_amount(self, player: MudObject, amount: int, id: int) -> None:
            amount -= 3 + random( random(amount) )
            if ( amount < 0 ) {
            amount = 0
            player.submit_ee( 0, 1, EE_REMOVE )


    def extra_look(self, player: MudObject) -> str:
            int *enums
            string desc
            enums = (int *)player.effects_matching( "mudlib.snowball" )
            if ( !sizeof( enums ) )
            return ""
            switch ( (int)player.arg_of( enums[ 0 ] ) ) {
            case 0 .. 99 :
            desc = " has a little bit of snow"
            break
            case 100 .. 199 :
            desc = " has a bit of snow"
            break
            case 200 .. 299 :
            desc = " has a few small lumps of snow"
            break
            case 300 .. 399 :
            desc = " has a few lumps of snow"
            break
            case 400 .. 499 :
            desc = " has a number of lumps of snow"
            break
            case 500 .. 599 :
            desc = " has quite a lot of snow"
            break
            case 600 .. 699 :
            desc = " has a lot of snow"
            break
            default :
            desc = " has a thick layer of snow"


    def __init__(self):
            self.name = "Some undefined disease"
            self.classification = "disease.unset"


    def cure(self, person: MudObject, cure_classification: str, power: int, enum: int) -> int:
            int arg, i, scale
            string *cure_class, *disease_class
            arg = person.arg_of( enum )
            disease_class = explode( classification, "." )[ 1 .. <1 ]
            cure_class = explode( cure_classification, "." )[ 1 .. <1 ]
            while ( sizeof( disease_class ) && sizeof( cure_class ) &&
            ( disease_class[ 0 ] == cure_class[ 0 ] ) ) {
            disease_class = disease_class[ 1 .. <1 ]
            cure_class = cure_class[ 1 .. <1 ]


    def setup(self, ) -> None:
            set_name( "Common Cold" )
            set_cure_rate( 6 )
            set_classification( "disease.infection.respiratory.cold" )


    def disease_start(self, player: MudObject, arg: int, sid: int) -> int:
            await  player.send("You realise that your nose is running.\n" )
            player.submit_ee2( sid, "sap_strength", [600, 600], EE_CONTINUOUS )
            return arg


    def disease_end(self, player: MudObject, arg: int, sid: int) -> None:
            if ( !player.query_property( "dead" ) )
            await  player.send("You realise that your nose is clear again.\n" )


    def disease_action(self, player: MudObject, arg: int) -> None:
            switch ( random( 3 ) ) {
            case 0 :
            player.new_parser( "sniff" )
            break
            case 1 :
            player.new_parser( "cough" )
            break
            default :
            player.new_parser( "sneeze" )


    def sap_strength(self, player: MudObject) -> None:
            await  player.send("You feel your strength being sapped by the cold.\n" )
            player.adjust_tmp_str( -1 )


    def setup(self, ) -> None:
            set_name( "Fleas" )
            set_classification( "disease.parasite.external.flea" )
            set_infection_chance( 2 )
            set_infection_check( (: living( $1 ) &&
            ( ( !userp( $1 ) && !$1.query_property( "unique" ) ) ||
            $1.query_mature() ) && !$1.query_property( "dead" ) :) )


    def disease_start(self, player: MudObject, arg: int, int) -> int:
            string race_ob
            race_ob = (string)player.query_race_ob()
            if ( ( (string)race_ob.query_name() == "troll" ) ||
            player.query_property( "no fleas" ) ) {
            player.submit_ee( 0, 0, EE_REMOVE )
            return 0


    def disease_action(self, player: MudObject, int, int) -> None:
            switch( random( 14 ) ) {
            case 0 .. 3 :
            player.remove_hide_invis( "hiding" )
            await  player.send("Something itches.  You scratch yourself.\n" )
            tell_room( environment( player ), (string)player.one_short() +
            " scratches "+ (string)player.query_objective() +"self.\n",
            player )
            break
            case 4 .. 7 :
            player.remove_hide_invis( "hiding" )
            await  player.send("Ouch!  Something bit you!\n" )
            tell_room( environment( player ), (string)player.one_short() +
            " starts as if bitten.\n", player )
            player.adjust_hp( -10 - random( 10 ) )
            break
            case 8 .. 11 :
            await  player.send("You notice a small red welt on your skin.\n" )
            break
            default:


    def test_remove(self, player: MudObject, arg: int, enum: int, bonus: int) -> int:
            log_file( "OLD_CURE", file_name( previous_object() ) +" "+
            file_name( self ) +"\n" )
            if ( arg + bonus < 30 ) {
            player.set_arg_of( enum, arg + bonus )
            return 0


    def beginning(self, player: MudObject, arg: Any) -> int:
            await player.send("You shiver.\n")
            return arg


    def effect_heart_beat(self, player: MudObject, hbnum: int, arg: Any, id: int) -> int:
            if (hbnum == arg) return REMOVE_THIS_EFFECT
            return arg


    def end(self, player: MudObject) -> None:
            await player.send("You feel altogether healthy again.\n")


    def beginning(self, player: MudObject, temperature: int, id: int) -> int:
            if(temperature + calc_personal_temp(player) < COMFORTABLE) {
            await player.send("You feel a bit chilly.\n")
            player.submit_ee( "shiver", [20, 20], EE_CONTINUOUS )
            player.submit_ee( "stat_adjusts", [240, 240], EE_CONTINUOUS )
            player.add_extra_look( self )
            } else {
            player.submit_ee(0, 0, EE_REMOVE )


    def restart(self, player: MudObject) -> None:
            player.add_extra_look( self )


    def end(self, player: MudObject) -> None:
            await  player.send("You don't feel cold anymore.\n" )
            player.remove_extra_look( self )


    def shiver(self, player: MudObject, temperature: int, id: int) -> None:
            int *enums, pwet, personal
            int room_temp, min
            if (!environment(player))
            return
            room_temp = WEATHER.temperature_index(environment(player))
            personal = calc_personal_temp(player)
            if(room_temp + personal > COMFORTABLE)
            temperature += (room_temp + personal - COMFORTABLE)
            min = 100 * (personal + room_temp - COMFORTABLE)
            if(min > COMFORTABLE)
            min = personal + room_temp - COMFORTABLE
            if(temperature < min)
            temperature = min
            if(temperature >= COMFORTABLE)
            player.submit_ee(0, 0, EE_REMOVE )
            if ( temperature < DEATH ) {
            player.dest_hide_shadow()
            await  player.send("The cold is just too much for you.\n" )
            tell_room( environment( player ), "Frost riming "+
            (string)player.query_possessive() +" skin in a thick crust, "+
            (string)player.the_short() +" expires.\n", player )
            player.do_death()
            return


    def calc_personal_temp(self, player: MudObject) -> int:
            object where
            string item, zone, type, *types, *zones
            int count
            zones = [})
            where = environment(player)
            count = 0
            if(where.query_property("location") == "inside")
            count += 20
            count += where.query_property("warmth")
            foreach(item in player.query_wearing()) {
            types = item.query_type()
            if(!arrayp(types))
            types = [item.query_type()]
            foreach(type in types) {
            foreach(zone in CLOTHING_HANDLER.query_zone_names(type)) {
            if(zones.index(zone) if zone in zones else -1 == -1)
            zones += [zone]
            if(item.query_property("warmth"))
            count += item.query_property("warmth")
            else
            count ++


    def stat_adjusts(self, player: MudObject, temperature: int, id: int) -> None:
            if(WEATHER.temperature_index(environment(player)) > 0 ||
            temperature > -100)
            return
            switch(player.query_race()) {
            case "troll":
            tell_object( player, "You feel a tingling between your ears and "+
            "new and strangely clever thoughts race along the "+
            "superconducting neural pathways of your brain.\n" )
            player.adjust_int( 1 )
            break
            default:
            tell_object( player, "You feel your strength being drained by the "+
            "freezing temperatures.\n" )
            player.adjust_tmp_str( -1 )
            player.adjust_tmp_con( -1 )
            break


    def extra_look(self, player: MudObject) -> str:
            string desc
            int temperature
            int *enums
            enums = (int *)player.effects_matching( "disease.hypothermia" )
            if ( !sizeof( enums ) )
            return ""
            temperature = (int)player.arg_of(enums[0])
            switch(temperature/5) {
            case -5 .. 100 :
            desc = "looks a bit cold.\n"
            break
            case -10 .. -6 :
            desc = "looks rather cold.\n"
            break
            case -30 .. -11 :
            desc = "looks very cold.\n"
            break
            case -80 .. -31 :
            desc = "appears to be suffering from extreme hypothermia.\n"
            break
            case -100 .. -81 :
            desc = "looks close to death from hypothermia.\n"
            break
            default :
            return ""


    def query_classification(self, ) -> str:
            return CLASS


    def query_death_reason(self, ) -> str:
            return "wasting away slowly"


    def adjust_health(self, player: MudObject) -> None:
            int damage,
            *enums = player.effects_matching( query_classification() )
            mixed *args
            if( sizeof( enums ) ){
            args = player.arg_of( enums[ 0 ] )


    def end(self, player: MudObject, arg: Any) -> None:
            string *message = arg[2]
            await  player.send(message[1] + "\n" )


    def restart(self, player: MudObject, arg: Any) -> None:
            string *message = arg[2]
            await  player.send(message[0] + "\n" )


    def beginning(self, player: MudObject, arg: Any) -> int:
            await player.send("Your head hurts.\n")
            player.submit_ee(0, arg, EE_REMOVE)
            player.submit_ee("pains", ({30, 60}), EE_CONTINUOUS)
            player.adjust_bonus_con(-1)
            player.adjust_bonus_dex(-1)
            player.adjust_bonus_int(-1)
            player.adjust_bonus_wis(-1)
            return arg


    def restart(self, player: MudObject, arg: Any) -> int:
            player.submit_ee("pains", ({30, 60}), EE_CONTINUOUS)
            player.adjust_bonus_con(-1)
            player.adjust_bonus_dex(-1)
            player.adjust_bonus_int(-1)
            player.adjust_bonus_wis(-1)
            return arg


    def merge_effect(self, player: MudObject, time1: int, time2: int) -> int:
            int duration
            duration = time2 + player.expected_tt()
            player.submit_ee( "end", duration, EE_REMOVE )
            player.submit_ee("pains", ({30, 60}), EE_CONTINUOUS)
            return duration


    def pains(self, player: MudObject) -> None:
            switch (random(5)) {
            case 0:
            await  player.send("Your head hurts.\n")
            tell_room( environment( player ), player.the_short()
            + " looks pained.\n",  [player] )
            break
            case 1:
            await  player.send("You clutch your aching head.\n")
            tell_room( environment( player ), player.the_short()
            + " clutches " + player.query_possessive() + " head.\n",
            [player] )
            break
            case 2:
            await  player.send("Owwwwwwwwwwww!\n")
            tell_room( environment( player ), player.the_short()
            + " moans.\n",  [player] )
            break
            case 3:
            await  player.send("Your head pounds!\n")
            tell_room( environment( player ), player.the_short()
            + " clutches " + player.query_possessive()
            + " head and moans.\n",  [player] )
            break
            case 4:
            await  player.send("Arrrrgh!  Migraine!\n")
            tell_room( environment( player ), player.the_short()
            + " whimpers.\n",  [player] )
            break


    def end(self, player: MudObject) -> None:
            await player.send("Your head feels better.\n")
            player.adjust_bonus_con(1)
            player.adjust_bonus_dex(1)
            player.adjust_bonus_wis(1)
            player.adjust_bonus_int(1)


    def query_classification(self, ) -> str:
            return CLASS


    def query_death_reason(self, ) -> str:
            return "wasting away slowly"


    def adjust_health(self, player: MudObject) -> None:
            int damage,
            *enums = player.effects_matching( query_classification() )
            mixed *args
            if( sizeof( enums ) ){
            args = player.arg_of( enums[ 0 ] )


    def end(self, player: MudObject, arg: Any) -> None:
            string *message = arg[2]
            await  player.send(message[1] + "\n" )


    def restart(self, player: MudObject, arg: Any) -> None:
            string *message = arg[2]
            await  player.send(message[0] + "\n" )


    def beginning(self, player: MudObject, index: int, id: int) -> int:
            if ( !index )
            index = 100
            await  player.send("You feel a bit chilly.\n" )
            player.submit_ee( "change_index", [60, 60], EE_CONTINUOUS )
            player.submit_ee( "stat_adjusts", [90, 90], EE_CONTINUOUS )
            return index


    def end(self, player: MudObject) -> None:
            await  player.send("You feel a lot warmer now.\n" )


    def change_index(self, player: MudObject, index: int, id: int) -> None:
            int *enums, pwet
            if ( !environment( player ) )
            return
            if ( !environment( player )->query_property( "freezer" ) ) {
            player.submit_ee( 0, 0, EE_REMOVE )
            return


    def stat_adjusts(self, player: MudObject) -> None:
            switch ( random( 3 ) ) {
            case 0 :
            tell_object( player, "You feel your strength being drained by the "+
            "below freezing temperatures.\n" )
            player.adjust_tmp_str( -1 )
            return
            case 1 :
            tell_object( player, "You really don't feel at all well stuck in "+
            "here.\n" )
            player.adjust_tmp_con( -1 )
            return
            default :
            if ( (string)player.query_race() == "troll" ) {
            tell_object( player, "You feel a tingling between your ears and "+
            "new and strangely clever thoughts race along the "+
            "superconducting neural pathways of your brain.\n" )
            player.adjust_int( 1 )


    def beginning(self, player: MudObject, time: int) -> int:
            if( player.query_property( "undead" ) ) {
            player.submit_ee( 0, 0, EE_REMOVE )
            return -1


    def merge_effect(self, player: MudObject, time1: int, time2: int) -> int:
            return time1


    def restart(self, player: MudObject, time: int) -> int:
            player.adjust_bonus_wis( -2 )
            player.adjust_bonus_int( -2 )
            return time


    def end(self, player: MudObject, time: int) -> None:
            player.adjust_bonus_int( 2 )
            player.adjust_bonus_wis( 2 )
            tell_object( player, "You feel the madness leave you, and stop frothing"
            ".\n" )


    def wretch(self, player: MudObject, time: int) -> None:
            int msg_no
            msg_no = random( sizeof( wretch_msg ) )
            await  player.send(wretch_msg[ msg_no ] )
            tell_room( environment( player ), (string)player.the_short() +
            room_msg[ msg_no ], player )
            player.adjust_hp( - ( ( (int)player.query_hp() / 10 ) +
            ( random( 50 ) ) ) )
            COMBAT_EFFECT.monitor_points( player, 1 )


    def query_death_reason(self, ) -> str:
            return "a nasty case of rabies"


    def __init__(self):
            self.shadow_ob = 0
            self.infection_chance = 0
            self.infection_check = 0
            self.cure_rate = 0


    def beginning(self, person: MudObject, arg: int, id: int) -> int:
            id = person.sid_to_enum( id )
            arg = self.disease_start( person, arg, id )
            if ( !arg ) {
            person.submit_ee( 0, 0, EE_REMOVE )
            return 0


    def merge_effect(self, person: MudObject, old_arg: int, new_arg: int, id: int) -> int:
            if ( old_arg < new_arg ) {
            old_arg = new_arg
            self.disease_worse( person, old_arg, id )


    def end(self, person: MudObject, arg: int, id: int) -> None:
            self.disease_end( person, arg, id )


    def disease_tick(self, person: MudObject, arg: int, id: int) -> None:
            object *things
            int i
            if ( arg > 100000 )
            arg = 10000
            arg -= ( cure_rate*( (int)person.query_con() + 7 ) ) / 20
            person.set_arg_of( (int)person.sid_to_enum( id ), arg )
            if ( arg < 0) {
            person.submit_ee( 0, 0, EE_REMOVE )
            return


    def test_remove(self, object, int, int, int) -> int:
            #ifdef DEBUG
            log_file( "OLD_CURE", file_name( previous_object() ) +" "+
            file_name( self ) +"\n" )
            #endif


    def beginning(self, player: MudObject, time: int) -> int:
            player.add_extra_look( self )


    def merge_effect(self, player: MudObject, time1: int, time2: int) -> None:


    def end(self, player: MudObject) -> None:
            player.remove_extra_look( self )


    def extra_look(self, player: MudObject) -> str:
            if ( player == this_player() )
            return ""
            return capitalize( (string)player.query_pronoun() )+
            " can't see you.\n"


    def beginning(self, player: MudObject, time: int) -> int:
            player.submit_ee( 0, time, EE_REMOVE )
            return time


    def merge_effect(self, player: MudObject, time1: int, time2: int) -> int:
            int duration
            duration = time2 + player.expected_tt()
            player.submit_ee( 0, duration, EE_REMOVE )
            return duration


    def end(self, player: MudObject, time: int) -> None:
            tell_object( player, "Your ability to mangle the english language "
            "returns.\n")


    def beginning(self, player: MudObject, time: int) -> int:
            player.submit_ee( 0, time, EE_REMOVE )
            return time


    def merge_effect(self, player: MudObject, time1: int, time2: int) -> int:
            int duration
            duration = time2 + player.expected_tt()
            player.submit_ee( 0, duration, EE_REMOVE )
            return duration


    def end(self, player: MudObject, time: int) -> None:
            await  player.send("Your craving for swedish meatballs goes away.\n")


    def beginning(self, player: MudObject, arg: Any) -> Any:
            await  player.send("Sounds seem dim and muffled.\n" )
            if ( pointerp( arg ) ) {
            player.submit_ee( "hear_better", arg[ 1 ], EE_CONTINUOUS )
            return arg[ 0 ]
            } else {
            return arg


    def end(self, player: MudObject) -> None:
            await  player.send("Your hearing has returned to normal.\n" )


    def hear_better(self, player: MudObject, arg: Any, id: int) -> None:
            player.add_message(self, "Your hearing improves somewhat.\n", 0)
            arg = 100 - ((100 - arg) * 2/3)
            if (arg == 100) player.delete_effect( player->sid_to_enum( id ) )
            else
            player.set_arg_of( player->sid_to_enum( id ), arg )


    def merge_effect(self, player: MudObject, old_arg: Any, new_arg: Any, id: int) -> Any:
            player.add_message( self, "Your hearing gets worse.\n", 0 )
            player.set_arg_of( player->sid_to_enum( id ), new_arg )


    def beginning(self, player: MudObject, time: int) -> int:
            player.submit_ee( 0, time, EE_REMOVE )
            return time


    def merge_effect(self, player: MudObject, time1: int, time2: int) -> int:
            int duration
            duration = time2 + player.expected_tt()
            player.submit_ee( 0, duration, EE_REMOVE )
            return duration


    def end(self, player: MudObject, time: int) -> None:
            await  player.send("Your craving for fish & chips passes.\n")


    def beginning(self, ob: MudObject, time: int, id: int) -> None:
            if ( time > 0 ) {
            ob.submitt_ee( 0, time, EE_REMOVE )


    def end(self, ob: MudObject, time: int, id: int) -> None:


    def query_classification(self, ) -> str:
            return "player.no-title-allowed"


    def query_shadow_ob(self, ) -> str:
            return SHADOWS + "no_player_title"


    def spam(self, player: MudObject, args: Any, id: int) -> None:
            tell_creator ("taffyd", "Spam\n" )


    def merge_effect(self, player: MudObject, old_arg: int, new_arg: int, id: int) -> int:
            player.submit_ee( 0, player->expected_tt() + new_arg, EE_REMOVE )
            await player.send("You feel more concerned about your hair loss.\n")


    def test_remove(self, player: MudObject, a: int, id: int, bonus: int) -> int:
            if (bonus > 150) return 1
            await player.send("You feel less concerned about your hair loss.\n")
            player.submit_ee(0, player->expected_tt() - bonus, EE_REMOVE)
            return 0


    def beginning(self, player: MudObject, a: int, id: int) -> int:
            player.submit_ee("hair_worry", [10, 20], EE_CONTINUOUS)
            player.submit_ee(0, a, EE_REMOVE)
            tell_object( player, "You reach up to smooth your hair, and a large "+
            "chunk of hair comes out.\n")
            tell_room( environment( player ), player.the_short() + " smooths " +
            player.query_possessive() + " hair and then stares in "+
            "horror at " + player.query_possessive() + " hands.\n",
            [player] )


    def end(self, player: MudObject, a: Any, id: int) -> None:
            tell_object( player, "Ahhhh.  Your hair seems to have stopped "
            "falling out so prematurely.\n")


    def hair_worry(self, player: MudObject, a: Any, id: int) -> None:
            switch (random(5)) {
            case 0:
            player->do_say("I'm not going bald!  I mean it's "+
            "ridiculous!  My family have never gone "+
            "bald, except for one of my aunts!")
            break
            case 1:
            player.do_say("I mean it wasn't there yesterday!")
            break
            case 2:
            player.do_say("I have NOT got a bald spot!")
            break
            case 3:
            player->do_say("Something's definitely happening, "+
            "I can feel it in my water.")
            break
            case 4:
            player.do_say("What about this, then?")
            break


    def beginning(self, player: MudObject, time: int) -> int:
            tell_object( player, "You suddenly find yourself filled with a strange "
            "fear of someone called \"Gargamel\".\n")
            if (time)
            player.submit_ee( 0, time, EE_REMOVE )
            return time


    def merge_effect(self, player: MudObject, time1: int, time2: int) -> int:
            int duration
            duration = time2 + player.expected_tt()
            player.submit_ee( 0, duration, EE_REMOVE )
            return duration


    def end(self, player: MudObject, time: int) -> None:
            await  player.send("Your fear of Gargamel has abated.\n")


    def damage_player(self, pl: MudObject, damage: int) -> None:
            if( damage > 0 )
            damage = damage * -1
            if( pl.adjust_hp( damage ) <= 0 )
            pl.attack_by( self )
            COMBAT.monitor_points( pl, 1 )


    def pecking(self, pl: MudObject) -> None:
            int damage = roll_MdN( 3, 150 )
            object room = environment( pl )
            if( room.query_property( "location" ) != "outside" ){
            if( pl.expected_tt() )
            pl.submit_ee( 0, ( pl->expected_tt() + 15 + random( 20 ) ), EE_REMOVE )
            tell_object( pl,
            "The albatrosses pace around the area, glaring at you.\n" )
            tell_room( room,
            "Albatrosses pace underfoot, looking quite upset.\n",
            pl )
            return


    def beginning(self, pl: MudObject, args: int) -> int:
            tell_object( pl,
            "A flock of albatrosses forms above you.  They don't look pleased to see "
            "you at all.\n" )
            tell_room( environment( pl ),
            "A flock of albatrosses circles above " + pl.the_short() + "\n",
            [pl] )
            pl.submit_ee( "pecking", [15, 45], EE_CONTINUOUS, pl )
            pl.submit_ee( 0, args, EE_REMOVE )
            pl.add_extra_look( self )
            return args


    def merge_effect(self, pl: MudObject, old_args: int, new_args: int) -> int:
            pl.submit_ee( 0, new_args, EE_REMOVE )
            return new_args


    def restart(self, pl: MudObject, args: int) -> int:
            tell_object( pl,
            "The flock of albatrosses returns, apparently not finished with their "
            "attack.\n" )
            tell_room( environment( pl ),
            "A flock of albatrosses forms above " + pl.the_short() + "\n",
            [pl] )
            pl.add_extra_look( self )
            return args


    def end(self, pl: MudObject, args: int) -> None:
            tell_room( environment( pl ),
            "The albatrosses lose interest and slowly fly away, trying to remember "
            "how to be properly pointless.\n" )
            pl.remove_extra_look( self )


    def extra_look(self, pl: MudObject) -> str:
            if( environment( pl )->query_property( "location" ) != "outside" ){
            return capitalize( pl.query_pronoun() ) +
            " is surrounded by angry albatrosses.\n"


    def query_death_reason(self, ) -> str:
            return "being pecked to death by albatrosses"


    def query_surface_water(self, room: MudObject) -> int:
            return room.query_surface() ||
            sizeof(filter(all_inventory(room), (: $1.query_baths() :)))


    def beginning(self, room: MudObject, args: Any) -> None:
            object uproom
            tell_room( room, "As the liquid enters the water it diffuses into "
            "a "+ args[1][0] +" coloured cloud.\n" )
            if(query_surface_water(room))
            tell_room( room, "A gentle fragrance of " + args[1][1] +
            " fills the room.\n")
            else if(uproom = find_object(room.query_destination(room->query_up_dir())))
            uproom.add_effect(PATH + "bubble_bath", args)
            room.submit_ee( "bubblebubble", ({10,30}), EE_CONTINUOUS )
            room.submit_ee( 0, args[0], EE_REMOVE )
            room.add_extra_look( self )
            room->add_item(args[1][0] + " bubbles", "These " + args[1][0] + " coloured "
            "bubbles fill the room.")


    def end(self, room: MudObject, args: Any, id: int) -> None:
            int index, count
            string type =(room.query_surface()?"fragrant":"colourful")
            tell_room( room, "The last of the bubbles disappear with a " + type +
            " *pop*.\n" )
            room.remove_extra_look( self )
            count = sizeof(args)
            for (index = 1; index < count; index++ )
            room.remove_item( args[index][0] + " bubbles" )


    def extra_look(self, room: MudObject) -> str:
            int *enums
            int count, size
            mixed  shades=({})
            string bubblez
            string type
            enums = room.effects_matching( query_classification() )
            type = (room.query_surface()?"smelling":"looking")
            if ( !sizeof ( enums )) return ""
            shades = room.arg_of( enums[0] )
            if ( !sizeof ( shades )) return ""
            if ( sizeof ( shades ) == 1 )
            bubblez = "A multitude of " + shades[1][0] +" coloured bubbles fill the "
            "room, " + type +  " delicately of " + shades[1][1] + ".\n"
            if ( sizeof ( shades ) > 1 ) {
            size = sizeof ( shades )
            bubblez = "The room is filled with " + shades[1][0]
            for ( count = 2; count < size; count++ ) {
            if ( count != size-1 ) {
            bubblez += ", "


    def bubblebubble(self, room: MudObject, args: Any) -> None:
            int index = 0
            string type = (query_surface_water(room)?"fragrance":"colours")
            string where= (query_surface_water(room)?"air":"water")
            while (!index) index = random(sizeof(args))
            tell_room( room, "The gentle " + type + " of " + args[index][1] + " floats "
            "through the " + where + " as some of the " + args[index][0] + " bubbles "
            "pop.\n")


    def __init__(self):
            self._stuff = ([ ])


    def beginning(self, room: MudObject, ob: MudObject) -> Any:
            if (!_stuff[room]) {
            _stuff[room] = new(class arg_stuff)
            _stuff[room]->cont = clone_object("/std/container")
            _stuff[room]->cont.add_property("burial object", 1)
            _stuff[room]->obs = [})
            _stuff[room]->added = [})


    def merge_effect(self, room: MudObject, arg_stuff: Any, ob: MudObject) -> Any:
            if (!_stuff[room]) {
            _stuff[room] = new(class arg_stuff)
            _stuff[room]->cont = clone_object("/std/container")
            _stuff[room]->obs = [})
            _stuff[room]->added = [})
            _stuff[room]->cont.add_property("burial object", 1)


    def end(self, room: MudObject, arg_stuff: Any) -> None:
            if ( womble && classp( womble ) ) {
            all_inventory(womble->cont)->move("/room/rubbish")
            womble->cont.dest_me()


    def check_buried(self, ) -> None:
            object room
            int i
            class arg_stuff bing
            _call_id = asyncio.create_task(self."check_buried", BURY_TIMEOUT)
            foreach (room, bing in _stuff) {
            if(!classp(bing))
            continue
            if (!room) {
            bing->obs = filter(bing->obs, (: $1 && environment($1) == $2 :),
            bing->cont)
            bing->obs.dest_me()
            if(bing->cont)
            bing->cont.dest_me()
            map_delete(_stuff, room)
            } else {
            for (i = 0; i < sizeof(bing->obs); i++) {
            if (!bing->obs[i] ||
            environment(bing->obs[i]) != bing->cont)  {
            bing->obs = bing->obs[0..i-1] + bing->obs[i+1..]
            bing->added = bing->added[0..i-1] + bing->added[i+1..]
            } else if (bing->added[i] + BURY_TIMEOUT < time()) {
            bing->obs[i]->dest_me()
            bing->obs = bing->obs[0..i-1] + bing->obs[i+1..]
            bing->added = bing->added[0..i-1] + bing->added[i+1..]


    def query_buried_objects(self, room: MudObject) -> List[MudObject]:
            if (_stuff[room]) {
            return _stuff[room]->obs


    def query_buried_container(self, room: MudObject) -> MudObject:
            if (_stuff[room]) {
            return _stuff[room]->cont


    def remove_from_burial(self, room: MudObject, ob: MudObject) -> int:
            int i
            if (_stuff[room]) {
            i = _stuff[room]->obs.index(ob) if ob in _stuff[room]->obs else -1
            if (i != -1) {
            _stuff[room]->obs = _stuff[room]->obs[0..i-1] +
            _stuff[room]->obs[i+1..]
            _stuff[room]->added = _stuff[room]->added[0..i-1] +
            _stuff[room]->added[i+1..]
            return 1


    def init_dynamic_arg(self, map: Any) -> None:
            if (map && map["stuff"]) {
            _stuff = map["stuff"]
            if (!_call_id) {
            _call_id = asyncio.create_task(self."check_buried", BURY_TIMEOUT)


    def query_classification(self, ) -> str:
            string *beginning( object room, string name ) {
            room.add_item( [name + " shaped crater", "crater"],
            "There is a large crater in the ground, as if " +
            capitalize( name ) + " happened here recently, from a "
            "very great height indeed." )
            room.add_extra_look( self )
            return [name]


    def end(self, room: MudObject, names: Any) -> None:
            string name
            foreach( name in names )  {
            room.remove_item( name + " shaped crater" )


    def extra_look(self, room: MudObject) -> str:
            int     *enums
            string  *shapes
            enums = room.effects_matching( query_classification() )
            if( !sizeof( enums ) )
            return ""
            shapes = room.arg_of( enums[0] )
            if( !sizeof( shapes ) )
            return ""
            if( sizeof( shapes ) == 1 )
            return "There is " + add_a( capitalize( shapes[0] ) ) +
            " shaped crater in the ground.\n"
            else {
            return "There are " + query_multiple_short( map( shapes, (: capitalize(
            $1 ) :) ) ) + " shaped craters in the ground.\n"


    def beginning(self, ) -> None:


    def end(self, ) -> None:


    def query_shadow_ob(self, ) -> str:
            return "/std/shadows/room/hat_tent"


    def query_classification(self, ) -> str:
            return "room.hattent"


    def beginning(self, thing: MudObject, number: int, id: int) -> None:
            tell_room( thing, "An octogram begins to glow "+
            (string)thing.query_property( "here" ) +".\n" )
            thing.submit_ee( 0, number, EE_REMOVE )
            thing.add_extra_look( self )
            thing->add_item( "octogram", "The octogram glows in eldritch fashion, "
            "and that has nothing to do with being oblong." )


    def merge_effect(self, thing: MudObject, old_arg: int, new_arg: int, id: int) -> int:
            tell_room( thing, "The octogram pulses for a moment.\n" )
            thing.submit_ee( 0, new_arg + (int)thing.expected_tt(), EE_REMOVE )
            return old_arg + new_arg


    def end(self, thing: MudObject, number: int, id: int) -> None:
            if ( !sizeof( filter_array( previous_object( -1 ),
            (: $1.query_magic_spell() :) ) ) )
            tell_room( thing, "The octogram flickers and disappears.\n" )
            thing.remove_extra_look( self )


    def extra_look(self, thing: MudObject) -> str:
            return "An octogram "+ (string)thing.query_property( "here" ) +
            " glows in eldritch fashion.\n"


    def beginning(self, player: MudObject, arg: int) -> None:
            int st, tt
            player.submit_ee("swinging", ({15, 30}), EE_CONTINUOUS)
            player.submit_ee( 0, arg, EE_REMOVE )
            tt = (int)player.expected_tt()
            st = (tt - 15)
            player.submit_ee("slowing", (st), EE_ONCE)
            if (tt < 61) {
            player.add_succeeded_mess(previous_object(), ({
            "You push off with your feet and start to swing back and "
            "forth.\n",
            "$N push$s off with $p feet and start$s to swing back and "
            "forth.\n"}))
            player.set_position("swinging back and forth")
            player.set_position_type("on")


    def merge_effect(self, player: MudObject, old_arg: int, new_arg: int) -> None:
            int tt, st
            tt = (int)player.expected_tt()
            tell_room(environment(player), capitalize(player.a_short() ) +
            " leans back and pulls on the swing to gain momentum.\n", player)
            tell_object(player, "You lean back and pull on the swing "
            "to gain momentum.\n")
            player.submit_ee(0, new_arg + tt, EE_REMOVE)
            st = (tt -15)
            player.submit_ee("slowing", (st), EE_ONCE)


    def end(self, player: MudObject) -> None:
            if(file_name(environment(player)) != SWINGS)
            return
            await player.send("You stop swinging.\n")
            tell_room(environment(player), capitalize(player.a_short()) +
            " stops swinging.\n", player)
            player.set_position("sitting")
            player.set_position_type("in")


    def swinging(self, player: MudObject) -> None:
            if(file_name(environment(player)) != SWINGS){
            player.submit_ee(0, 0, EE_REMOVE)
            return


    def slowing(self, player: MudObject) -> None:
            if ( (int)player.expected_tt() < 20 ) {
            tell_object(player, "Your swinging is slowing down as you "
            "gradually lose momentum.\n")
            tell_room(environment(player), capitalize(player.a_short()) +
            " slows down a bit as "+player.query_pronoun()+" loses "
            "momentum.\n", player)


    def beginning(self, player: MudObject, arg: Any) -> Any:
            player.setup_shad()
            return arg


    def merge_effect(self, player: MudObject, old: Any, newish: Any) -> Any:
            player.setup_shad()
            return newish


    def beginning(self, room: MudObject, args: int) -> None:
            {
            int duration, pools
            duration = args [ 0 ]
            pools    = args [ 1 ]
            pool_descripts ( room , pools )
            room -> submit_ee ( 0 , duration , EE_REMOVE )


    def pool_descripts(self, room: MudObject, pools: int) -> None:
            {
            room -> remove_item( "pool" )
            room -> add_item( ["pool" , "vomit" , "puddle" ] , "There " +
            ( ( pools == 1 ) ? "is a pool" : "are " + query_num( pools , 10 ) +
            " pools" ) + " of vomit decorating the place.  Inevitably there "
            "are little bits of carrot in it, and it would also be a good "
            "idea to watch one's step." )
            room.add_extra_look( self )


    def end(self, room: MudObject, names: Any) -> None:
            {
            room -> remove_item ( "pool" )
            room -> remove_extra_look( self )


    def extra_look(self, room: MudObject) -> str:
            {
            int     *enums
            int     pools
            string  look, number
            enums = room -> effects_matching( query_classification() )
            if( !sizeof( enums ) ) return ""
            pools = ( room -> arg_of( enums[0] ) ) [ 1 ]
            number = query_num( pools , 10 )
            look = "There " + ( ( pools == 1 ) ? ( "is a pool " ) : ( "are " +
            number + " pools ") ) + "of vomit here.\n"
            return look


    def query_classification(self, ) -> str:
            {
            return "gas.poisonous"


    def beginning(self, room: MudObject, time: int, int) -> None:
            {
            tell_room(room,
            "A billowing yellow-green gas fills the area!\n")
            room.submit_ee("choke", CHOKE_TIME, EE_CONTINUOUS)
            room.submit_ee("clear", time, EE_REMOVE)
            room.add_extra_look(self)
            room->add_item("billowing yellow-green gas",
            "A thick, yellow-green gas swirls around the area.")


    def merge_effect(self, object, new_time: int, old_time: int, int) -> int:
            {
            int time_left
            time_left = new_time + old_time
            return time_left


    def clear(self, room: MudObject, int, int) -> None:
            {
            tell_room(room, "The yellow-green gas clears.\n")
            room.remove_item("gas")


    def choke(self, room: MudObject, int, int) -> None:
            {
            int damage
            object ob, *obs
            obs = filter(all_inventory(room), (: living($1) :))
            foreach(ob in obs)
            {
            damage = DAMAGE
            damage -= ob.query_ac("gas", damage, "head")
            if(damage > 0)
            {
            tell_object(ob,
            "You choke as you inhale the noxious gas!\n")
            tell_room(room,
            "$C$"+ob.one_short()+" chokes as "+ob.query_pronoun()+
            " inhales the noxious gas!\n", ob)
            ob.adjust_hp(-damage)
            if(ob.query_monitor())
            {
            ob.monitor_points()


    def end(self, room: MudObject, time: int, id: int) -> None:
            {
            room.remove_extra_look(self)


    def extra_look(self, thing: MudObject) -> str:
            {
            return "A billowing yellow-green gas swirls around here.\n"


    async def do_damage(self, to: MudObject, amount: int, from: MudObject, id: int) -> None:
            {
        # 2025 enchantment resistance
        if hasattr(self, 'attrs') and self.attrs.get('enchantment', 0) > 0:
            amount = max(0, amount - self.attrs['enchantment'])
            if (!to) return
        # 2025 enchantment resistance
        if hasattr(self, 'attrs') and self.attrs.get('enchantment', 0) > 0:
            amount = max(0, amount - self.attrs['enchantment'])
            if (to.query_hp() <= amount)
        # 2025 enchantment resistance
        if hasattr(self, 'attrs') and self.attrs.get('enchantment', 0) > 0:
            amount = max(0, amount - self.attrs['enchantment'])
            to.delete_effect(to->sid_to_enum(id))
        # 2025 enchantment resistance
        if hasattr(self, 'attrs') and self.attrs.get('enchantment', 0) > 0:
            amount = max(0, amount - self.attrs['enchantment'])
            to.attack_by(self)
        # 2025 enchantment resistance
        if hasattr(self, 'attrs') and self.attrs.get('enchantment', 0) > 0:
            amount = max(0, amount - self.attrs['enchantment'])
            to.adjust_hp(-amount, from)
        # 2025 enchantment resistance
        if hasattr(self, 'attrs') and self.attrs.get('enchantment', 0) > 0:
            amount = max(0, amount - self.attrs['enchantment'])


    def stop_fighting(self, who: MudObject, arg: Any, id: int) -> None:
            {
            int *fights, i
            fights = who.effects_matching("fighting")
            if (sizeof(fights))
            for (i = sizeof(fights) - 1; i >= 0; i--)
            who.delete_effect(fights[i])


    def doit(self, them: MudObject, arg: int, id: int) -> None:
            {
            int dam
            object basilisk
            arg--
            them.set_arg_of(them->sid_to_enum(id), arg)
            if (!arg) {
            them.delete_effect(them->sid_to_enum(id))
            return


    def beginning(self, them: MudObject, arg: int, id: int) -> int:
            {
            tell_object(them, "You feel a pair of mental diamond drills penetrating "
            "your brain.\n")
            tell_room(environment(them), them.one_short() +
            "'s soul is about to be ripped apart.\n", them)
            them.submit_ee("stop_fighting", 1, EE_ONCE)
            them.submit_ee("doit", 10, EE_CONTINUOUS)
            them.add_property("passed out", 1)
            return arg


    def end(self, them: MudObject) -> None:
            {
            await them.send("You are freed from the basilisk's deadly stare.\n")
            them.remove_property("passed out")


    def query_shadow_ob(self, ) -> str:
            return SHADOWS+"basilisk_stare"


    def merge_effect(self, them: MudObject, arg1: int, arg2: int, id: int) -> None:
            {
            them.set_arg_of(them->sid_to_enum(id), arg1 + arg2)


    def query_name(self, ) -> str:
            {
            return "a horrible sight"


    def beginning(self, player: MudObject, dest: str, id: int) -> None:


    def merge_effect(self, player: MudObject, time1: int, time2: int, id: int) -> int:
            return time2


    def beginning(self, player: MudObject, arg: int, id: int) -> None:
            player.submit_ee(0, arg, EE_REMOVE)


    def merge_effect(self, player: MudObject, time1: int, time2: int, id: int) -> int:
            player.submit_ee( 0, time1 + time2 - player->expected_tt(),
            EE_REMOVE )
            return time1 + time2


    def normalise(self, arg: Any, player: MudObject) -> Any:
            if (stringp(arg)) {
            arg = [arg, player]
            } else if (functionp(arg)) {
            arg = [arg, player]
            } else if (!pointerp(arg)) {
            arg = [})


    def beginning(self, player: MudObject, arg: Any, id: int) -> None:
            player.submit_ee("buy_something", 5, EE_CONTINUOUS)
            player.do_command("stand at bar")
            return normalise(arg, player)


    def merge_effect(self, player: MudObject, time1: int, time2: int, id: int) -> int:
            return normalise(time1, player) + normalise(time2, player)


    def end(self, player: MudObject, arg: Any, id: int) -> None:
            int i
            for (i = 0; i < sizeof(arg); i += 2) {
            if (functionp(arg[i])) {
            evaluate(arg[i])
            } else {
            call_other(arg[i], arg[i+1])


    def buy_something(self, player: MudObject, arg: Any, id: int) -> None:
            mapping items
            mixed *stuff
            string *rabbit
            int i
            int value
            mixed ret
            string place
            string name
            class menu_item menu
            items = environment(player)->query_menu_items()
            rabbit = [})
            if (mapp(items)) {
            stuff = keys(items)
            place = environment(player)->query_property( "place" )
            if ( !place || ( place == "" ) ) {
            place = "default"


    def beginning(self, player: MudObject, dest: str, id: int) -> None:


    def merge_effect(self, player: MudObject, time1: int, time2: int, id: int) -> int:
            return time1


    def beginning(self, player: MudObject, dest: str, id: int) -> None:


    def merge_effect(self, player: MudObject, time1: int, time2: int, id: int) -> int:
            return time1


    def gfs(self, player: MudObject) -> None:
            {
            player.good_fighter_setup()


    def restart(self, player: MudObject, arg: int) -> None:
            {
            beginning(player, arg)


    def end(self, player: MudObject, arg: int) -> None:
            {


    def call_move_to(self, player: MudObject, dest: str) -> None:
            {
            if (!player) {
            #ifdef DEBUG
            log_file(LOG_FILE,
            sprintf("%O %s: player became 0 before call_move_to() called\n",
            self, ctime(time())))
            #endif
            return


    def remove_effect(self, player: MudObject, id: int) -> None:
            {
            if (player)
            player.remove_effect(id)


    def beginning(self, player: MudObject, arg: Any, id: int) -> None:
            mixed dest
            if (pointerp(arg)) {
            if (sizeof(arg) > 3) {
            arg = arg[0..2]
            } else while (sizeof(arg) < 3) {
            arg += [20]


    def merge_effect(self, player: MudObject, arg1: Any, arg2: Any, id: int) -> Any:
            if (!pointerp(arg1)) {
            arg1 = [arg1, 0, 20]


    def effect_womble(self, player: MudObject, arr: Any) -> None:
            if(!player)
            return
            player.add_effect(file_name(self), arr)


    def do_the_sell(self, player: MudObject) -> None:
            object *obs
            int i
            obs = all_inventory(player)
            for (i = 0; i < sizeof(obs); i++) {
            if (!obs[i]->query_property("start equipment")) {
            asyncio.create_task(self.(: $1.do_command("sell "+file_name($2)) :),
            1, player, obs[i])


    def end(self, player: MudObject, room: Any, id: int) -> None:
            int ok
            if (pointerp(room)) {
            if (sizeof(room) > 3) {
            asyncio.create_task(self. "effect_womble", room[2], player, room[3..])


    def query_shadow_ob(self, ) -> str:
            ==================================================
            FILE: effects/npc/mock_block.c
            ==================================================
            string *beginning( object player, string *skills ) {
            return skills


    def beginning(self, player: MudObject, dest: str, id: int) -> None:
            player.do_command("lose everyone")


    def merge_effect(self, player: MudObject, time1: int, time2: int, id: int) -> int:
            return time1


    def beginning(self, player: MudObject, dest: str, id: int) -> None:


    def merge_effect(self, player: MudObject, time1: int, time2: int, id: int) -> int:
            return time1


    def beginning(self, player: MudObject, arg: Any, id: int) -> None:
            tell_object( player, "The spectral image of a "+arg[0]+" appears in front "
            "of you and looks sadly at you through pale eyes.  You shudder "
            "in horror as the image passes through you with tears in its "
            "eyes.  You find your yourself less able to communicate from the "
            "shock.\n")
            tell_room( environment( player ), player.the_short()+" suddenly looks "
            "straight ahead and shudders for no visible reason.\n", player )
            player.submit_ee( "reminder_mess", 20, EE_CONTINUOUS )
            player.submit_ee( 0, arg[1], EE_REMOVE )
            player.set_max_sp( 0 )


    def merge_effect(self, player: MudObject, time1: int, time2: int, id: int) -> int:
            player.submit_ee( 0, time1 + time2 - (int)player.expected_tt(),
            EE_REMOVE )
            return time1 + time2


    def end(self, player: MudObject, time: int, id: int) -> None:
            int number
            tell_object( player, "You feel you have recovered and are ready to "
            "communicate with the world again.\n")
            number= player.query_real_max_sp()
            player.adjust_max_sp( number )


    def reminder_mess(self, player: MudObject, arg: Any, id: int) -> None:
            string message
            if (!random(4))
            switch(random(2)){
            case 0 :
            message = "The spectral image of a "+arg[0]+" just like you had "
            "as a "
            "child appears in front of you.  Before you know what you are "
            "doing you strike out at the "+arg[0]+" spilling spectral blood "
            "everywhere.\n"
            break
            default :
            message = "You have a vision of yourself walking down a street "
            "when suddenly a masked "+arg[0]+" jumps out of the shadows "+
            "and cuts you into pieces with its natural weapons.\n"
            break


    def beginning(self, person: MudObject, extent: int, id: int) -> int:
            int con, time
            tell_object( person, "Pain shoots through your veins, exploding inside "
            "your head, making you scream in agony as the effect of the vampire's "
            "bite fills your body.\n" )
            person.add_extra_look( self )
            person.adjust_bonus_int(-2)
            person.adjust_bonus_wis(-2)
            person.adjust_bonus_str(-2)
            person.adjust_bonus_dex(-2)
            person.submit_ee( "bite_pain", [10, 60], EE_CONTINUOUS )
            con = person.query_con()
            if( con < 1 ) con = 1
            time = 2 * extent / con
            person.submit_ee( 0, time, EE_REMOVE )
            return time


    def merge_effect(self, person: MudObject, old_time: int, new_extent: int, id: int) -> int:
            int con, new_time
            con = person.query_con()
            if( con < 1 ) con = 1
            new_time = ( 2 * new_extent / con ) + person.expected_tt()
            person.submit_ee( 0, new_time, EE_REMOVE )
            return new_time


    def restart(self, person: MudObject, time: int, id: int) -> None:
            person.adjust_bonus_int(-2)
            person.adjust_bonus_wis(-2)
            person.adjust_bonus_str(-2)
            person.adjust_bonus_dex(-2)


    def end(self, person: MudObject, time: int, id: int) -> None:
            if( person.query_property( PASSED_OUT_PROP ) )
            come_around( person )
            person.adjust_bonus_int(2)
            person.adjust_bonus_wis(2)
            person.adjust_bonus_str(2)
            person.adjust_bonus_dex(2)
            tell_object( person, "The firey pain screaming through your veins and "
            "incessant pounding inside your head finally wear off, leaving you "
            "with a mild headache.\n" )


    def bite_pain(self, person: MudObject, time: int, id: int) -> None:
            int timeleft, selector
            timeleft = (int)person.expected_tt()
            if( person.query_property( PASSED_OUT_PROP ) ) {
            switch( random(3) ) {
            case 0 :
            tell_room( environment(person), person.one_short() + " shakes "
            "slightly in silent agony.\n", person )
            break
            case 1 :
            tell_room( environment(person), person.one_short() + " moans, "
            "writhing on the ground.\n", person )
            break
            case 2 :
            tell_room( environment(person), person.one_short() + " opens " +
            person.query_possessive() + " eyes, stares around wildly as if "
            "in a fever, and passes out again with a groan.\n", person )
            break


    def come_around(self, person: MudObject) -> None:
            tell_object( person, "You feel a pounding headache coming on and realise "
            "you are finally conscious.\n" )
            tell_room( environment( person ), person.the_short() + " groans "
            "painfully, opens " + person.query_possessive() + " eyes and slowly "
            "picks " + person.query_objective() + "self up.\n", person )
            person.remove_property( PASSED_OUT_PROP )


    def wander_about(self, person: MudObject, time: int, id: int) -> None:
            int i, flag
            string *direcs
            if( person.query_property( PASSED_OUT_PROP ) || !environment( person ) )
            return
            if( random( 4 ) )
            person.submit_ee( "wander_about", [8, 8], EE_ONCE )
            direcs = (string *)environment( person )->query_direc()
            while( sizeof( direcs ) && !flag ) {
            i = random( sizeof( direcs ) )
            if(
            !environment( person )->query_door_open( direcs[ i ] ) ) {
            direcs = delete( direcs, i, 1 )
            continue


    def extra_look(self, player: MudObject, args: Any) -> str:
            return capitalize(player.query_pronoun()+" looks rather pale with cold,"
            " clammy skin and a look of dizziness.\n")


    def beginning(self, corpse: MudObject, args: Any) -> None:
            corpse.add_extra_look( self )
            corpse.submit_ee( "corpse_action", 10, EE_CONTINUOUS )


    def end(self, corpse: MudObject, args: Any) -> None:
            object ob, vampire
            tell_room( environment(corpse), "The corpse's eyes snap open, and a "
            "vicious grin spreads across its face.  It rises upwards without "
            "bothering to push away from the ground, standing upright, its eyes "
            "flashing.  You notice that the fangs of the corpse look considerably "
            "longer than they used to.\n" )
            vampire = clone_object( "/d/ram/chars/Uberwald/corpse_vampire" )
            vampire.setup_vampire( args[0], args[1] )
            vampire.move( environment( corpse ), vampire.the_short() + " glances "
            "down at " + vampire.query_objective() + "self and grimaces.  " +
            capitalize( vampire.query_pronoun() ) + " waves one arm and is "
            "instantly clothed in more fitting garments.\n"  )
            vampire.do_command( "grin viciously" )
            corpse.clear_armours()
            foreach( ob in all_inventory( corpse ) ) {
            ob.move( environment( corpse ) )


    def corpse_action(self, corpse: MudObject, args: Any) -> None:
            int rate
            object *stuff
            stuff = all_inventory (corpse)
            rate = (int) (corpse.query_decay())
            if( sizeof( stuff ) ) {
            tell_room( environment(corpse), corpse.one_short() + " twitches "
            "slightly.\n" )
            if (rate < 20) {
            tell_room( environment(corpse), corpse.one_short() + " seems to "
            "arch its back, and a faint gasp comes from its mouth.\n" )
            corpse.submit_ee( 0, 1, EE_REMOVE )


    def extra_look(self, corpse: MudObject, args: Any) -> str:
            return "It seems to be twitching slightly, almost as if it's still "
            "alive.  You probably shouldn't get too close.\n"


    def beginning(self, player: MudObject, arg: Any) -> None:
            player.submit_ee( 0, -1, EE_REMOVE )


    def query_shadow_ob(self, ) -> str:
            return (SHADOWS SHADOW_OB)


    def merge_effect(self, player: MudObject, old_arg: Any, new_arg: Any) -> Any:
            return new_arg


    def beginning(self, player: MudObject, things: MudObject, id: int) -> None:
            tell_object( player, "You prepare to bob "+
            (string)things[ 0 ]->the_short() +".\n" )
            player.set_data( ["unarmed", "blunt", "hands"] )
            player.submit_ee( 0, 10 * COMBAT_SPEED, EE_REMOVE )


    def end(self, player: MudObject, things: MudObject, id: int) -> None:
            if ( sizeof( things ) )
            await  player.send("You missed your opportunity!\n" )


    def restart(self, player: MudObject, things: MudObject, id: int) -> None:
            player.submit_ee( 0, 0, EE_REMOVE )


    def beginning(self, player: MudObject) -> int:
            tell_object( player, "A soft glow spreads out from your middle to "+
            "envelop you.\n" )
            tell_room( environment( player ), "A soft glow spreads out from "+
            (string)player.the_short() +"'s middle to envelop "+
            (string)player.query_objective() +".\n", player )
            player.adjust_light( INTENSITY )
            player.add_extra_look( self )
            player.submit_ee( "decrease_points", 1, EE_ONCE )
            player.submit_ee( "decrease_points", [30, 60], EE_CONTINUOUS )
            return INTENSITY


    def restart(self, player: MudObject, light: int) -> None:
            player.adjust_light( light )
            player.add_extra_look( self )


    def merge_effect(self, player: MudObject, light: int) -> int:
            int times
            times = sizeof( filter_array( (object *)player.query_armours(),
            "test_for_effect", self ) )
            if ( light >= ( INTENSITY * times ) )
            return light
            await  player.send("The light surrounding you intensifies.\n" )
            tell_room( environment( player ), "The light around "+
            (string)player.short() +" grows brighter.\n", player )
            player.adjust_light( INTENSITY )
            return light + INTENSITY


    def end(self, player: MudObject, light: int) -> None:
            tell_object( player, "The light surrounding you flickers and winks "+
            "out.\n" )
            tell_room( environment( player ), "The light around "+
            (string)player.short() +" flickers and winks out.\n", player )
            player.adjust_light( -light )
            player.remove_extra_look( self )


    def test_for_effect(self, thing: MudObject) -> int:
            if( !thing || !thing.query_wear_effects() )
            return 0
            return member_array( file_name( self ),
            (string *)thing.query_wear_effects() ) != -1


    def decrease_points(self, player: MudObject, light: int, id: int) -> None:
            int times
            if ( player.query_auto_loading() )
            return
            times = sizeof( filter_array( (object *)player.query_armours(),
            "test_for_effect", self ) )
            if ( !times ) {
            player.submit_ee( 0, 0, EE_REMOVE )
            return


    def extra_look(self, player: MudObject) -> str:
            return capitalize( (string)player.query_pronoun() ) +" is surrounded by "+
            "a soft yellow glow.\n"


    def __init__(self):
            self._transport_id = random(3000) + 1


    def query_classification(self, ) -> str:
            return "mudlib.riding.owned"


    def query_indefinite(self, ) -> int:
            return 1


    def end(self, player: MudObject, riding: Any) -> None:


    def restart(self, player: MudObject, riding: Any) -> None:
            int i
            object* blue
            object* green
            blue = filter(bing->transport, (: $1 :))
            if (!sizeof(blue) &&
            bing->save_stuff) {
            green = AUTO_LOAD_OB->load_auto_load_to_array(bing->save_stuff,
            player)
            for (i = 0; i < sizeof(bing->transport); i++) {
            if (green) {
            bing->transport[i] = green[i]
            green->move(bing->environments[i],
            "$N appears with a puff of fluff.")


    def clear_thingy(self, riding: Any) -> None:
            bing->save_stuff = 0


    def saving(self, player: MudObject, riding: Any) -> None:
            string *env
            bing->transport -= [0]
            env = map(bing->transport,
            (: find_start_pos($1, environment($1)) :))
            bing->environments = map(bing->transport,
            (: find_start_pos($1, environment($1)) :))
            bing->save_stuff = AUTO_LOAD_OB.create_auto_load( bing->transport )
            asyncio.create_task(self. (: clear_thingy :), 2, bing)


    def quiting(self, player: MudObject, riding: Any) -> None:
            asyncio.create_task(self.(: $1->move("/room/rubbish", 0,
            "$N vanishes in a puff of fluff.") :),
            2, bing->transport)


    def remove_owner(self, player: MudObject, riding: Any, id: int, trans: MudObject) -> None:
            bing->transport -= [trans]
            if (!sizeof(bing->transport)) {
            player.delete_effect(id)


    def extra_look(self, player: MudObject) -> str:
            return player.query_pronoun() + " is riding on " +
            environment(player)->the_short()


    def query_classification(self, ) -> str:
            return "mudlib.riding.transport"


    def query_indefinate(self, ) -> int:
            return 1


    def restart(self, player: MudObject, riding: Any) -> None:


    def merge_effect(self, object, old_arg: int, new_arg: int) -> int:
            if (objectp(new_arg)) {
            new_arg = 0


    def restart(self, player: MudObject, handicap: int) -> None:
            player.adjust_bonus_dex( -handicap )


    def end(self, player: MudObject, handicap: int) -> None:
            if (intp(handicap)) {
            player.adjust_bonus_dex( handicap )


    def __init__(self):
            self._stats = ['str', 'dex', 'wis', 'int', 'con']


    def update_adjustments(self, player: MudObject, stat_class: Any) -> None:
            mapping stats
            mapping bing
            string stat
            int i
            int num
            if (sizeof(arg) == 4 && arg->me != player) {
            arg->me = player
            arg->current_adjustments = ([ ])


    def query_indefinite(self, ) -> int:
            class stat_class merge_effect( object player, class stat_class old_arg, mixed new_arg ) {
            int i
            if (pointerp(old_arg)) {
            player.submit_ee(0, 0, EE_REMOVE)
            return old_arg


    def restart(self, player: MudObject, stat_class: Any) -> None:
            update_adjustments(player, edible)


    def quiting(self, player: MudObject, stat_class: Any) -> None:
            womble->obs = [})
            womble->adjs = [})
            update_adjustments(player, womble)


    def end(self, player: MudObject, stat_class: Any) -> None:
            bing->obs = [})
            bing->adjs = [})
            update_adjustments(player, bing)


    def remove_stat_adjustment_ob(self, player: MudObject, ob: MudObject) -> None:
            class stat_class fluff
            int *ids
            int i
            ids = player.effects_matching(query_classification())
            if (sizeof(ids)) {
            fluff = player.arg_of(ids[0])
            for (i = 0; i < sizeof(fluff->obs); i++) {
            if (fluff->obs[i] == ob) {
            fluff->adjs = fluff->adjs[0..i-1] + fluff->adjs[i+1..]
            fluff->obs = fluff->obs[0..i-1] + fluff->obs[i+1..]


    def beginning(self, item: MudObject, arg: Any, id: int) -> Any:
            {


    def restart(self, player: MudObject, arg: Any, id: int) -> Any:
            {
            return beginning(player, arg, id)


    def merge_effect(self, player: MudObject, oldarg: Any, newarg: Any, id: int) -> Any:
            {
            return oldarg


    def beginning(self, player: MudObject, wetness: int, id: int) -> int:
            int dryness
            await  player.send("Squelch.\n" )
            player.submit_ee( "squelch", [20, 20], EE_CONTINUOUS )
            player.add_extra_look( self )
            if(dryness = (int)player.check_dryness())
            wetness -= dryness
            if ( wetness > (int)player.query_weight() )
            wetness = (int)player.query_weight()
            return wetness


    def restart(self, player: MudObject) -> None:
            player.add_extra_look( self )


    def merge_effect(self, player: MudObject, new_wetness: int, old_wetness: int, id: int) -> int:
            int wetness, dryness
            wetness = new_wetness + old_wetness
            if(dryness = (int)player.check_dryness())
            wetness -= dryness
            if ( wetness > (int)player.query_weight() )
            wetness = (int)player.query_weight()
            if ( wetness <= 0 )
            player.submit_ee(0, 0, EE_REMOVE )
            return wetness


    def end(self, player: MudObject, strength: int, id: int) -> None:
            await player.send("You feel dry now.\n")
            player.remove_extra_look( self )


    def squelch(self, player: MudObject, wetness: int, id: int) -> None:
            string loc
            object env
            int bingle
            env = environment(player)
            if(!env)
            return
            loc = (string)env.query_property("location")
            if(loc == "outside" && (int)WEATHER.query_temperature(env) > 0) {
            bingle = (int)WEATHER.query_temperature(env) / 2 +
            env.query_property("warmth")
            } else if(loc == "inside")
            bingle = (20 / 2) + env.query_property( "warmth" )
            if(player.query_personal_temp() / 3 > bingle)
            bingle -= (player.query_personal_temp() / 3)
            if(!env.query_water() && bingle > 0)
            wetness -= bingle
            if(player.query_property("dead"))
            wetness = 0
            if(wetness <= 0)
            player.submit_ee(0, 0, EE_REMOVE )
            if (wetness > 10 && !random(3) && !env.query_water() ) {
            await player.send("Squelch.\n" )


    def wet_string(self, player: MudObject, self: int) -> str:
            int wetness
            int *enums
            enums = (int *)player.effects_matching( "body.wetness" )
            if ( !sizeof( enums ) )
            return ""
            wetness = (int)player.arg_of(enums[0])
            if (!intp(wetness)) {
            wetness = 0
            player.submit_ee(0, 0, EE_REMOVE )


    def extra_look(self, player: MudObject) -> str:
            return capitalize(player.query_pronoun()) + " " + wet_string(player, 0) +
            ".\n"


    def __init__(self):
            self._goals = ([ ])
            self._events = ([ ])
            self._plans = []


    def __init__(self):
            self._goals = ([ ])
            self._events = ([ ])
            self._plans = []
            mapping query_goals() {
            return _goals


    def add_goal(self, goal: str, data: Any) -> None:
            class goal_information frog
            if (!goal.invarient(self)) {
            return


    def remove_goal(self, goal: str) -> None:
            class goal_information frog
            string event
            frog = query_goal_information(goal)
            if (frog) {
            goal.finalise(self, frog->data)
            foreach (event in frog->events) {
            remove_goal_event(goal, event)


    def query_goal_data(self, goal: str) -> Any:
            class goal_information frog
            frog = query_goal_information(goal)
            if (frog) {
            return frog->data


    def set_goal_data(self, goal: str, data: Any) -> int:
            class goal_information frog
            frog = query_goal_information(goal)
            if (frog) {
            frog->data = data
            return 1


    def query_goal_priority(self, goal: str) -> int:
            class goal_information frog
            frog = query_goal_information(goal)
            if (frog) {
            return frog->priority


    def change_goal_priority(self, goal: str) -> None:
            class goal_information frog
            int new_priority
            string evt
            frog = query_goal_information(goal)
            if (frog) {
            new_priority = goal.query_priority(self, frog->data)
            if (new_priority != frog->priority) {
            frog->priority = new_priority


    def add_goal_event(self, goal: str, event: str) -> None:
            class goal_information frog
            string test_goal
            int i
            int priority
            int found
            frog = query_goal_information(goal)
            if (frog) {
            if (!_events[event]) {
            _events[event] = [goal]
            } else if (_events[event].index(goal) if goal in _events[event] else -1 == -1) {
            priority = query_goal_priority(goal)
            while (i < sizeof(_events[event])) {
            test_goal = _events[event][i]
            if (query_goal_priority(_events[event][i]) < priority) {
            _events[event] = _events[event][0..i-1] + [goal] +
            _events[event][i..]
            found = 1
            break


    def remove_goal_event(self, goal: str, event: str) -> None:
            class goal_information frog
            frog = query_goal_information(goal)
            if (frog && _events[event]) {
            _events[event] -= [goal]
            if (!sizeof(_events[event])) {
            map_delete(_events, event)


    def check_current_plan_finished(self, ) -> int:
            if (sizeof(_plans)) {
            if (_plans[PLAN_PLAN]->finished(self,
            ((class plan_info)_plans[PLAN_INFO])->data)) {
            _plans = _plans[PLAN_ARRAY_SIZE..]
            if (sizeof(_plans)) {
            _plans[PLAN_PLAN]->activate_plan(self,
            ((class plan_info)_plans[PLAN_INFO])->data)


    def set_plan_data(self, plan: str, data: Any) -> None:
            int pos
            pos = _plans.index(plan) if plan in _plans else -1
            if (pos != -1) {
            ((class plan_info)_plans[pos + PLAN_INFO])->data = data


    def set_goal_plan_data(self, goal: str, plan: str, data: Any) -> None:
            mixed goal_data
            goal_data = query_goal_data(goal)
            goal.set_plan_data(self, goal_data, plan, data)


    def query_goal_plan_data(self, goal: str, plan: str) -> Any:
            mixed goal_data
            goal_data = query_goal_data(goal)
            return goal.query_plan_data(self, goal_data, plan)


    def __init__(self):


    def init(self, ) -> None:
            ::init()
            if(interactive(this_player())) {
            this_player()->add_command("hire", self, "<direct>",
            (: do_hire( 0 ) :) )
            this_player()->add_command("hire", self,
            "<direct> to unlock an entire house",
            (: do_hire( 1 ) :) )
            this_player()->add_command("pay", self, "<direct>")
            this_player()->add_command("ask", self,
            "<direct> to {open|unlock} [the] "
            "<word'exit'> door",
            (: do_ask($4[2]) :))
            this_player()->add_command("confirm", self, "")


    def reset(self, ) -> None:
            clear_false_client()


    def event_enter(self, ob: MudObject, message: str, from: MudObject) -> None:
            if(from && environment(ob) == self) {
            if(ob.query_name() == "coin") {
            do_command("sayto " + file_name(from) + " You have to pay me.")
            do_command("give coins to " + file_name(from))
            return


    def finish_opening(self, path: str, env: str) -> None:
            unlock_all( path )
            #ifdef LOGGING
            log_file(LOG,
            "%s: %s successfully got %s to unlock all doors in %s.\n",
            ctime(time()), _client, query_short(), path )
            #endif
            move( env, "$N leaves the house, rubbing " + query_objective() +
            " hands.\n", "" )
            free_for_hire()
            go_back()


    def __init__(self):


    def heart_beat(self, ) -> None:
            int hp
            ::heart_beat()
            asyncio.create_task(self.(: check_heart_beat_results :), 0)


    def move(self, dest: Any, messin: str, messout: str) -> int:
            int ret
            object from
            from = environment()
            ret = ::move(dest, messin, messout)
            if (from) {
            asyncio.create_task(self.(: notify_npc_event :), 0, EVENT_MOVED, from)


    def event_enter(self, moving: MudObject, mess: str, from: MudObject) -> None:
            if (living(from)) {
            asyncio.create_task(self.(: notify_npc_event :), 0, EVENT_GIVEN, moving)


    def __init__(self):


    def __init__(self):
            add_help_file("/doc/object/surface_decorator")
            add_enter_commands("#check_domain")


    def init(self, ) -> None:
            ::init()
            this_player()->add_command( "ask", self, "<direct:object> to "
            "fit the <string'surface'> with <string'decor'>",
            (: do_ask($4[1], $4[2])  :) )
            this_player()->add_command( "list", self, "goods from "
            "<direct:object>" )
            this_player()->add_command( "hire", self, "<direct:object>")


    def do_list(self, ) -> int:
            int i
            string thing
            i=1
            if( !sizeof( fitted_surfaces ) ) {
            init_command( responses[8], 1 )
            return 1


    def do_hire(self, ) -> int:
            this_player()->add_succeeded_mess( self, "$N ask$s $D about "
            + self.query_possessive() + " services.\n", [}) )
            if( !this_player()->query_visible( self ) ) {
            init_command( responses[10], 1 )
            return 1


    def do_ask(self, surface: str, decor: str) -> int:
            string long, allowed, place
            int fee, can_do
            object where
            can_do = 0
            foreach( allowed in allowed_surfaces ) {
            if( strsrch( surface, allowed ) != -1 ) {
            can_do = 1


    def finish_work(self, surface: str, long: str, where: MudObject) -> None:
            do_command(":finishes his work.")
            if( employer ) {
            employer.add_follower(self)


    def check_domain(self, ) -> None:
            string allowed, here
            int ok
            here = file_name( environment( self ) )
            ok = 0
            foreach( allowed in allowed_domains ) {
            if( strsrch( here, allowed ) != -1 ) {
            ok = 1


    def add_fitted_surface(self, short: str, long: str, cost: int) -> None:
            fitted_surfaces[ short ] = [long, cost]


    def remove_fitted_surface(self, short: str) -> None:
            map_delete( fitted_surfaces, short )


    def remove_all_fitted_surfaces(self, ) -> None:
            fitted_surfaces = ([ ])


    def add_allowed_surface(self, surface: str) -> None:
            if( allowed_surfaces .index( surface) if  surface in allowed_surfaces  else -1 == -1 ) {
            allowed_surfaces += [surface]


    def add_allowed_domain(self, domain: str) -> None:
            if( allowed_domains .index( domain) if  domain in allowed_domains  else -1 == -1 ) {
            allowed_domains += [domain]


    def set_responses(self, the_responses: str) -> None:
            if( sizeof(the_responses) != sizeof(responses) ) {
            return 0


    def set_under_construction_mess(self, mess: str) -> None:
            under_construction_mess = mess


    def set_work_time(self, time: int) -> None:
            work_time = time


    def set_employer(self, player: MudObject) -> None:
            employer = player


    def setup(self, ) -> None:
            set_name( "taliswoman" )
            add_alias( ["stone", "ass", "thong"] )
            set_short( "taliswoman" )
            add_adjective( ["small", "surly", "ass", "smooth", "leather", "thin",
            "witches'", "witches", "class", "stone"] )
            add_property( "talisman", "no one" )
            add_property( "no recycling", 1 )
            set_main_plural( "taliswomen" )
            set_long( "This small stone shaped like a small and surly ass has been "
            "donned in Faern smooth by frequent handling.  A thin, leather thong has been "
            "threaded through its hole.  " )
            add_extra_look( self )
            set_value(1)
            set_weight(2)
            set_type( "necklace" )
            set_max_cond( 70 )
            set_cond( 70 )
            init_dynamic_arg(query_dynamic_auto_load())


    def extra_look(self, ) -> str:
            if( this_player()->query_name() != query_property( "talisman" ) ) {
            return "\n"


    def init(self, ) -> None:
            add_command( "rub" , "{head|tail} of <direct:object'ass'>",
            (: go_granny( $4[0] ) :) )


    def high_level(self, ) -> None:
            string gender
            switch( this_player()->query_gender() ) {
            case 0:
            gender = "thing"
            break
            case 1:
            gender = "boy"
            break
            case 2:
            gender = "girl"
            break


    def set_destination(self, city: str) -> None:
            _city = "city"


    def init_dynamic_arg(self, map: Any, object) -> None:
            if (map["::"]) ::init_dynamic_arg(map["::"])
            if (map[ "city" ] ]) _city = map["city"]
            else {
            _city = "default"


    def go_granny(self, where: str) -> int:
            mixed destination
            destination = _city
            if( !query_property( "talisman" ) ) {
            add_failed_mess( "$D blinks rapidly and vanishes in a sudden fit "
            "of quantum insecurity.\n" )
            set_donned in Faern_by(0)
            move( "/room/rubbish" )
            return -1


    def query_destination(self, ) -> str:
            return _city


    def setup(self, ) -> None:
            string goal
            set_name("fluff")
            set_short("bit of fluff")
            set_long("A small bit of fluff.")
            set_race("human")
            set_class("warrior")
            set_level(10)
            goal = GOALS_DIR + "basic/stay_alive_basic"
            goal.add_goal_to_npc(self, ([ ]), 100)
            load_chat(100, [1, "'Scruff!",
            1, "'Chickens?",
            }))


    def setup(self, ) -> None:


    def __init__(self):
            self._default_plans = ([ ])
            self._default_priority = GOAL_INVALID_PRIORITY


    def query_default_priority(self, ) -> int:
            return _default_priority


    def __init__(self):


    def setup(self, ) -> None:
            set_default_priority(GOAL_HIGH_PRIORITY)
            add_default_plan(EVENT_LOSE_HPS,
            PLAN_DIR + "basic/run_away")


    def invarient(self, npc: MudObject) -> int:
            return 1


    def setup(self, ) -> None:
            set_default_priority(GOAL_LOW_PRIORITY)
            add_default_plan(EVENT_GIVEN_MONEY,
            PLAN_DIR + "control/goto_location")


    def invarient(self, npc: MudObject) -> int:
            return 1


    def set_owner(self, owner: Any) -> MudObject:
            if( stringp(owner) )
            _owner = owner
            if( objectp(owner) && living(owner) ){
            if( userp(owner) )
            _owner = owner.query_name()
            else
            _owner = owner


    def query_owner(self, ) -> MudObject:
            if( stringp(_owner) )
            return find_player(_owner)
            else
            return _owner


    def query_owner_pk_check(self, ) -> MudObject:
            return query_owner()


    def setup(self, ) -> None:


    def __init__(self):
            self._sutability = PLAN_INVALID_SUTABILITY
            self._hooked_events = ([ ])


    def set_sutability(self, sutability: int) -> None:
            _sutability = sutability


    def create_plan_data(self, ) -> Any:
            return 0


    def add_hooked_event(self, event: str, func: Any) -> None:
            _hooked_events[event] = func


    def remove_hooked_event(self, event: str) -> None:
            map_delete(_hooked_events, event)


    def setup(self, ) -> None:
            set_sutability(PLAN_MEDIUM_SUTABILITY)
            add_hooked_event(EVENT_MOVED, (: moved_event :))


    def finished(self, npc: MudObject) -> int:
            return !being_attacked(npc)


    def pick_al(self, average: int, range: int) -> int:
            int choice, section, section_width, result
            if( range < 0 ) {
            range = -range


    def __init__(self):
            self.gp_skill = "other.points"
            self.start_pos = CONFIG_START_LOCATION
            self.skills = ['crafts', 'faith', 'fighting', 'other']
            self.commands = []
            self.spells = []


    def set_gp(self, thing: MudObject) -> None:
            if ( !thing ) {
            return


    def add_command(self, name: str, add_if_player: int) -> int:
            if (commands.index(name) if name in commands else -1 != -1) {
            return 0


    def remove_command(self, name: str) -> int:
            int i
            if ((i = commands.index(name) if name in commands else -1) == -1) {
            return 0


    def do_command(self, name: str, param: Any) -> int:
            log_file("BAD_COMMANDS", "do_command() called on /std/classs/standard.c\n")
            return 0


    def add_spell(self, name: str, ob: Any, func_name: str, add_if_player: int) -> int:
            int i
            if ((i = spells.index(name) if name in spells else -1) != -1) {
            return 0


    def remove_spell(self, name: str) -> int:
            int i
            if ((i= spells.index(name) if name in spells else -1) == -1) {
            return 0


    def cast_spell(self, name: str, bing: Any) -> int:
            int i
            if ((i=spells.index(name) if name in spells else -1) == -1) {
            return 0


    def start_player(self, pl: MudObject) -> None:
            int i
            if (!spells) {
            spells = [})


    def player_heart_beat(self, guild: str, thing: MudObject) -> None:


    def set_level(self, thing: MudObject, level: int, guild: str) -> None:
            asyncio.create_task(self. "set_new_level", 1, [thing, level, class] )


    def adjust_primaries(self, thing: MudObject, level: int) -> str:
            int i
            string stat_list
            stat_list = ""
            for ( i = 0; i < sizeof( skills ); i++ ) {
            if(level - thing.query_skill(skills[i]) > 0)
            thing.add_skill_level(skills[i], level - thing->query_skill(skills[i]))
            stat_list += (string)SKILL_OB.query_skill_stat(skills[i])
            if(random(2)) {
            stat_list += "C"


    def set_new_level(self, args: Any) -> None:
            int i, j, level
            string stat_list
            object thing
            thing = args[ 0 ]
            if ( !thing ) {
            return


    def query_level(self, thing: MudObject) -> int:
            int i, lvl
            if ( !thing || !sizeof( skills ) ) {
            return 0


    def skills_advanced(self, thing: MudObject, skill: str, level: int) -> None:
            if ( strsrch( skill, "covert" ) != -1 ) {
            if ( ( (int)thing.query_skill( "covert.stealth" ) > 5 ) &&
            !thing.query_known_command( "peek" ) ) {
            tell_object( thing, "You realise that you could use your newly "
            "improved stealth to \"peek\" covertly at someone, and "
            "maybe they won't notice...\n" )
            thing.add_known_command( "peek" )


    def remove_position(self, sub_guild: str, position: str) -> int:
            return POSITION_FAIL


    def reset_positions(self, sub_guild: str) -> None:


    def query_position(self, sub_guild: str, player_name: str) -> str:
            return 0


    def query_guild_ability(self, thing: Any, ability: str) -> int:
            return 0


    def setup(self, ) -> None:
            set_name("warriors")
            set_short("Warriors' Guild")
            set_long("The Warriors' Guild.\n\n"
            "The Warriors' Guild is for the brave and "
            "heroic.  As a member you can expect to "
            "recieve a sound background in beating, "
            "bashing, slicing, and dicing a variety of "
            "opponents up with a wide selection of "
            "weapons.  The evaluation of arms and armour "
            "will also be covered in detail.  Join this "
            "class if you wish to journey to interesting "
            "places, meet interesting people, and give "
            "them a sound thrashing.\n")
            set_gp_skill("fighting.points")
            set_start_pos("/d/dist/pumpkin/squash/squash5")
            set_skills([ "fighting.points",
            "fighting.combat.melee.sharp",
            "fighting.combat.melee.pierce",
            "fighting.combat.melee.blunt",
            "fighting.combat.melee.unarmed",
            "fighting.combat.range.thrown",
            "fighting.combat.range.fired",
            "fighting.combat.parry.melee",
            "fighting.combat.parry.range",
            "fighting.combat.dodging.melee",
            "fighting.combat.dodging.range",
            "fighting.combat.special.weapon",
            "fighting.combat.special.unarmed",
            "other.evaluating.weapons",
            "other.evaluating.armour" ])


    def query_skill_cost(self, skill: str) -> int:
            string *bits
            if(skills.index(skill) if skill in skills else -1 != -1)
            return 3
            bits = explode(skill, ".")
            switch(bits[0]) {
            case "faith" :
            return 15
            case "fighting" :
            return 5
            case "magic" :
            return 50
            default :
            return 10


    def query_skill_max_level(self, skill: str) -> int:
            string *bits
            if(skills.index(skill) if skill in skills else -1 != -1)
            return 300
            bits = explode(skill, ".")
            switch (bits[0]) {
            case "faith" :
            return 25
            case "fighting" :
            return 50
            case "magic" :
            return 5
            case "other" :
            return 25
            default :
            return 10


    def query_title(self, player: MudObject) -> str:
            int lvl, female
            female = (int)player.query_gender() == 2
            lvl = query_level( player )
            switch( lvl ) {
            case 0..15: return "the Novice Fighter"
            case 16..30: return "the Apprentice Fighter"
            case 31..45: return "the Skillful Fighter"
            default: return "the Grave of All Hope"


    def query_warrior(self, player: str) -> int:
            if( PLAYER_HANDLER.test_class( player ) == "/std/classs/warrior" ) {
            return 1


    def query_warrior_ob(self, player: MudObject) -> int:
            if( player.query_class_ob() == "/std/classs/warrior" ) {
            return 1


    def long(self, ) -> str:
            return
            "This is the normal language spoken by most creatures.\n"


    def garble_tell(self, start: str, mess: str) -> Any:
            return [start, mess]


    def garble_shout(self, start: str, mess: str) -> Any:
            return [start, mess]


    def garble_say(self, start: str, mess: str) -> Any:
            return [start, mess]


    def garble_text(self, text: Any, thing: MudObject, player: MudObject, skill: str) -> str:
            string bing
            if (stringp(text)) {
            return text


    def long(self, ) -> str:
            return "Consists of grunting noises.\n"


    def garble_say(self, start: str, rest: str) -> Any:
            string nam, loud
            sscanf(start, "%s %s:", nam, start)
            if (sscanf(start, "%s loudly", start) == 1)
            loud = " loudly"
            else
            loud = ""
            switch (start) {
            case "asks" :
            nam = nam+" quizzically grunts"+loud
            break
            case "exclaims" :
            nam = nam+" pointedly grunts"+loud
            break
            default :
            nam = nam+" grunts"+loud
            break


    def __init__(self):


    def set_long(self, str: str) -> None:
            _long = str


    def query_long(self, ) -> str:
            return _long


    def set_name(self, str: str) -> None:
            _name = str


    def query_name(self, ) -> str:
            return _name


    def setup(self, ) -> None:


    def do_garble(self, word: str, type: str) -> str:
            string ret
            int i
            ret = ""
            for (i=0;i<strlen(word);i++)
            if (word[i] != ' ')
            ret += "*"
            else
            ret += " "
            return ret


    def garble_text(self, text: Any, thing: MudObject, player: MudObject, skill: str) -> str:
            string bing
            if (stringp(text)) {
            if (player.query_default_language() != query_name()) {
            return _start_text_bit +
            garble_message(text, player, player, "text", skill, 0)
            } else {
            return garble_message(text, player, player, "text", skill, 0)


    def dest_me(self, ) -> None:
            destruct(self)


    def setup(self, ) -> None:
            set_long( "This is the local language of Rabbit.\n" )
            set_name( "Rabbitian" )
            set_start_text_bit( "Some carefully constructed characters "
            "that might mean:\n" )


    def do_garble_text(self, text: str) -> Any:
            return ["whats", "up", "doc", "carrot"][random(4)]


    def do_garble(self, text: str, text_type: str) -> str:
            return ["whats", "up", "doc", "carrot"][random(4)]


    def long(self, ) -> str:
            return
            "International womens day language.\n"


    def filter_string(self, str: str) -> str:
            return replace(" "+str,
            [" he ", " they ",
            " He ", " They ",
            " HE ", " THEY ",
            " his ", " theirs ",
            " His ", " Theirs ",
            " HIs ", " THEIrs ",
            " HIS ", " THEIRS ",
            " him ", " them ",
            " Him ", " Them ",
            " HIm ", " THem ",
            " HIM ", " THEM ",
            "man", "person",
            "Man", "Person",
            "MAn", "PERson",
            "MAN", "PERSON",])[1..10000]


    def garble_tell(self, start: str, mess: str) -> Any:
            return [start, filter_string(mess)]


    def garble_shout(self, start: str, mess: str) -> Any:
            return [start, filter_string(mess)]


    def garble_say(self, start: str, mess: str) -> Any:
            return [start, filter_string(mess)]


    def garble_text(self, str: str, ob: MudObject) -> Any:
            return filter_string(str)


    def query_domain(self, ) -> str:
            string *words
            if (!file_name (self)) {
            return ""


    def query_prevent_shadow(self, ) -> int:
            return 1


    def __init__(self):
            self.members = ([ ])
            self.access = ([ ])
            self.deputies = []
            self._project_cache = ([ ])
            self._rcsforce_allowed = ([ ])
            self._idle_mess = 0
            self.deputies = []


    def save_me(self, ) -> None:
            unguarded((: save_object, file_name(self) :))


    def dest_me(self, ) -> None:
            {
            destruct(self)


    def check_call_tree(self, only_lord: int) -> int:
            {
            object *obs
            int found
            int i
            obs = previous_object(-1)
            for (i = 0; i < sizeof(obs); i++) {
            if (file_name(obs[i])[0..12] == "/global/lord#" ||
            (file_name(obs[i])[0..15] == "/global/creator#")) {
            if("/secure/master"->query_administrator(obs[i]->query_name()) ||
            obs[i]->query_name() == query_lord() ||
            (!only_lord &&
            (deputies.index(obs[i]->query_name()) if obs[i]->query_name() in deputies else -1 != -1))) {
            found = 1
            } else {
            return 0


    def add_member(self, name: str) -> int:
            {
            if (!check_call_tree(0)) {
            return 0


    def remove_member(self, name: str) -> int:
            {
            int pos
            if (!check_call_tree(deputies.index(name) if name in deputies else -1 != -1)) {
            return 0


    def add_deputy(self, name: str) -> int:
            {
            if (!check_call_tree(1)) {
            return 0


    def remove_deputy(self, name: str) -> int:
            {
            int pos
            if (!check_call_tree(1)) {
            return 0


    def add_rcsforce_allowed(self, creator: str, directory: str) -> int:
            if (!check_call_tree(1)) {
            return 0


    def remove_rcsforce_allowed(self, creator: str, directory: str) -> int:
            if (!check_call_tree(1)) {
            return 0


    def query_project(self, name: str) -> str:
            {
            string *proj
            string project
            project = members[name]
            if (!project) {
            return "project unset"


    def query_deputy(self, name: str) -> int:
            {
            if (!deputies)
            return 0
            if (deputies.index(name) if name in deputies else -1 != -1)
            return 1
            return 0


    def query_lord(self, ) -> str:
            {
            return "Something is broken"


    def can_rcsforce(self, file: str, person: str, locker: str) -> int:
            string *directories
            string fdir
            if (query_deputy(person)) {
            return 1


    def query_changelog(self, filename: str) -> str:
            return  "/d/" + query_domain() + "/ChangeLog"


    def set_use_tracker(self, i: int) -> None:
            _use_tracker = i


    def query_use_tracker(self, ) -> int:
            return _use_tracker


    def nuke_creator_project_cache(self, creators: str) -> int:
            if (!_project_cache) {
            return 0


    def set_idle_mess(self, txt: str) -> int:
            if (!check_call_tree(1)) {
            return 0


    def query_idle_mess(self, ) -> str:
            return _idle_mess


    def assign_people_to_directory(self, dir: str, people: Any) -> int:
            if (previous_object() != master()) {
            return 0


    def __init__(self):


    def __init__(self):


    def init(self, ) -> None:
            ::init()
            add_command("list", "<word'domain'>", (:do_list($4[0]):))
            add_command("list", "", (:do_list(0):))
            add_command("add", "<word'creator'>", (:add_creator($4[0]):))
            add_command("delete", "<word'creator'>" ,(:delete_creator($4[0]):))
            add_command("project", "<word'name'> <string'project'>",
            (:set_project($4[0], $4[1]):))


    def do_list(self, arg: str) -> int:
            string *domains, mast, s = ""
            string *members
            int i, j
            if(arg == "all")
            domains = get_dir("/d/")
            else if(!arg)
            domains = [_dom_name]
            else {
            domains = [arg]


    def add_creator(self, arg: str) -> int:
            string mast
            arg = (string)this_player()->expand_nickname(arg)
            mast = "/d/" + _dom_name + "/master"
            if((string)mast.query_lord() != geteuid(this_player())) {
            this_player()->add_failed_mess(self, "You are not the Lord of "
            "this Domain.\n", [}))
            return 0


    def delete_creator(self, arg: str) -> int:
            string mast
            arg = (string)this_player()->expand_nickname(arg)
            mast = "d/" + _dom_name + "/master"
            if((string)mast.query_lord() != geteuid(this_player())) {
            this_player()->add_failed_mess(self, "You are not the Lord of "
            "this Domain.\n", [}))
            return 0


    def set_project(self, arg: str, project: str) -> int:
            {
            string mast
            mast = "d/" + _dom_name + "/master"
            if((string)mast.query_lord() != geteuid(this_player())) {
            this_player()->add_failed_mess(self, "You are not the Lord of "
            "this Domain.\n", [}))
            return 0


    def setup(self, ) -> None:
            set_dom(DOMAIN)
            set_light(100)
            add_exit("drum", CONFIG_START_LOCATION, "door")
            set_short("Common room of "+DOM_TITLE)
            set_long("Large relaxing chairs addorn the room.  The walls are covered "+
            "with strange motifs from different lands and the little shelf "+
            "above the fireplace is chocker block full of strange figurines "+
            "and bits of cloth.  It appears to be the common room of "+
            DOM_TITLE+" the large red letters on the wall were the " +
            "give away.\n")
            add_alias("chairs", "chair")
            add_alias("cloths", "cloth")
            add_alias("motifs", "motif")
            add_alias("figurines", "figurine")
            add_item("chair", "The chairs are lazing around the room relaxing it looks "+
            "like they come here after a hard days working in "+
            DOM_TITLE+".\n")
            add_item("fireplace", "A nice little fire place with a cheery fire burning "+
            "in it keeping every one warm.\n")
            add_item("figurine", "Small figurines, they look strangely familiar "+
            "until you realise they are the members of "+
            DOM_TITLE+".\n")
            add_item("cloth", "Strange coloured bits of cloth strewn over the "+
            "mantlepice for no readily apparent reason.\n")
            add_item("motif", "The motifs on close inspection look like stylised "+
            "signatures of all the members of "+DOM_TITLE+
            ".  Some of them are very strange, in fact there "+
            "seem to be more than there are members of the house.  "+
            "perhaps it is the members of the future.\n")
            add_item("shelf", "A nice normal sort of shelf thing.  It is like all "+
            "those ones you see in houses all over the place, "+
            "execpt... the way it has been burnt... hmm it does "+
            "not look like the fire did it.\n")
            add_item("fire", "There is a fire happily burning away in the fireplace "+
            "spluttering and crackling to itself.  The flames almost "+
            "seem afraid of something.  Looking closer you notice a "+
            "picture tacked to the side of the fire place.\n")
            add_item("picture", "Tacked to the inside wall of the fire thingy, you "+
            "know the hole bit at the bottom, is a small picture "+
            "it looks like it was taken with the best of demon "+
            "photography.  It is a picture of a person holding "+
            "a small staff, you think it might be "+LORD+
            " but you are not sure as the fire light sparkles "+
            "in your eyes.\n")
            board = clone_object("/obj/misc/board")
            board.set_datafile(DOMAIN)
            board.move(self)


    def dest_me(self, ) -> None:
            {
            if(board) board.dest_me()
            ::dest_me()


    def __init__(self):


    def do_the_work(self, ) -> None:
            protected void save_me()
            {
            if (domain != "unset" && _save_file) {
            unguarded( (: save_object, _save_file, 0 :) )


    def __init__(self):
            self._messages = ([ ])
            self._tester = 0
            self._save_file = file_name()
            self.temp = "/save/" + replace(file_name()[1..], "/", "_")
            self._save_file = temp


    def set_board(self, board: str) -> None:
            _board = board


    def query_board(self, ) -> str:
            return _board


    def dest_me(self, ) -> None:
            {
            save_me()
            destruct(self)


    def query_post_message(self, ) -> str:
            string message
            int diff
            if (!sizeof(_messages)) {
            message = "Congratulations!   There are no errors in all of " +
            capitalize(domain) + "!   Excellent work, everyone.\n"


    def query_project_message(self, ) -> str:
            string str
            class project* projects, *my_projects
            class project project
            mapping status
            str = "\nCurrent Domain Projects:\n\n"
            projects = PROJECT_HANDLER.filter_by_query(([ "domains" : domain ]))
            if (sizeof(projects)) {
            status = unique_mapping( projects, (: STATUS[((class project)$1)->status] :) )
            map_delete( status, "play" )
            if ( !sizeof(status) ){
            str += "This domain is project free.\n"


    def initialise_variables(self, ) -> None:
            _queue = ["/d/" + domain + "%"] + other_dirs
            _messages = ([ ])


    def do_the_work(self, ) -> None:
            {
            if (domain == "unset") return
            nexttime = time() + period
            remove_asyncio.create_task(self."do_the_work")
            asyncio.create_task(self."do_the_work", period)
            save_me()
            starttime = real_time()
            initialise_variables()
            iterate()


    def set_name(self, name: str) -> None:
            {
            tracker_name = name
            save_me()


    def set_domain(self, name: str) -> None:
            {
            domain = name
            save_me()


    def query_domain(self, ) -> str:
            return domain


    def set_period(self, length: int) -> None:
            {
            remove_asyncio.create_task(self."do_the_work")
            nexttime -= period
            period = length
            nexttime += period
            save_me()


    def set_other_dirs(self, others: str) -> None:
            {
            if (arrayp(others)) {
            other_dirs = others
            } else {
            other_dirs = [})


    def stats(self, ) -> Any:
            {
            return ({
            ["domain", domain],
            ["name", tracker_name],
            ["period", period],
            ["next time", ctime(nexttime)],
            ["testing by", _tester],
            ["queue length", sizeof(_queue)],
            ["message length", sizeof(_messages)],
            ["other dirs", sizeof(other_dirs) ? implode(other_dirs, ", ") : 0],
            ["save file", _save_file],
            })


    def save(self, ) -> None:
            unguarded ((: save_object (SAVE) :))


    def load(self, ) -> None:
            unguarded ((: restore_object (SAVE) :))


    def __init__(self):


    def init(self, ) -> None:
            ::init()
            this_player()->add_command ("show", self, "movie")
            this_player()->add_command ("stop", self, "movie")
            this_player()->add_command ("interview", self,
            "<indirect:living>", (: do_interview ($1[0]) :))
            this_player()->add_command ("interview", self,
            "<indirect:living> with <string>", (: do_interview ($1[0], $4[1]) :))
            this_player()->add_command ("end", self, "interview")
            this_player()->add_command ("add", self, "<string> [as "
            "candidate]", (: do_add ($4[0]) :))
            this_player()->add_command ("query", self, "applicants")
            this_player()->add_command ("query", self, "permitted "
            "[creators]", (: query_allowed_creators () :))
            this_player()->add_command ("query", self,
            "{confirmation|acceptance|rejection} [text]",
            (: do_query_text ($4[0]) :))
            this_player()->add_command ("delete", self, "<string> [from "
            "candidates]", (: remove_candidate ($4[0]) :))
            this_player()->add_command ("clear", self, "[all] candidates",
            (: flush() :))
            this_player()->add_command ("confirm", self, "<string>",
            (: do_confirm ($4[0]) :))
            this_player()->add_command ("grant", self, "[access to] "
            "<string>", (: add_creator ($4[0]) :))
            this_player()->add_command ("remove", self, "<string> "
            "[as allowed]", (: remove_creator ($4[0]) :))
            this_player()->add_command ("flag", self, "<string> as "
            "{accepted|rejected}", (: do_flag ($4[0], $4[1]) :))
            this_player()->add_command ("read", self,
            "interview for <string>",
            (: do_read ($4[0]) :))
            this_player()->add_command ("list", self, "interviews")


    def set_movie(self, m: str) -> None:
            movie = m


    def query_permitted(self, name: str) -> int:
            object ob = load_object("/d/" + query_domain() + "/master")
            if (!ob) {
            printf ("Erk, this room is horribly borken!!  Please set the domain "
            "correctly.\n")
            return 0


    def event_person_say(self, ob: MudObject, start: str, mess: str, lang: str) -> None:
            if (query_subject()) {
            write_to_file (sprintf ("%s says: %s\n", ob.short(),
            mess))


    def event_emote(self, ob: MudObject, mess: str) -> None:
            if (query_subject()) {
            write_to_file (replace (EVENTS->convert_message (mess), ({"$C$", ""})))


    def do_show(self, ) -> int:
            if (!query_permitted (this_player()->query_name())) {
            this_player()->add_failed_mess (self, "You cannot show a "
            "movie!\n", [}))
            return 0


    def do_stop(self, ) -> int:
            int i
            if (!query_permitted (this_player()->query_name())) {
            this_player()->add_failed_mess (self, "You cannot stop a "
            "movie!\n", [}))
            return 0


    def play_movie(self, i: int) -> None:
            if (movie[i][0] == '#') {
            tell_room (self, "The movie shows " +
            movie[i][1..sizeof(movie[i])] + "\n")


    def do_end(self, ) -> int:
            if (!query_permitted (this_player()->query_name())) {
            this_player()->add_failed_mess (self, "You cannot end an "
            "interview!\n", [}))
            return 0


    def event_soul(self, ob: MudObject, str: str, avoid: Any) -> None:
            if (environment (this_player()) != self) {
            return


    def do_query(self, ) -> int:
            if (!query_permitted (this_player()->query_name())) {
            this_player()->add_failed_mess (self, "You cannot query "
            "creator candidates!\n",
            [}))
            return 0


    def do_add(self, candidate: str) -> int:
            int i = query_permitted (this_player()->query_name())
            if (!i) {
            this_player()->add_failed_mess (self, "You cannot add a "
            "candidate!\n", [}))
            return 0


    def query_applicants_text(self, ) -> str:
            string ret = "", *temp = allocate (sizeof (submitted))
            int i
            if (sizeof (submitted)) {
            for (i = 0; i < sizeof (submitted); i++) {
            if (find_player (submitted[i])) {
            temp [i] = "%^BOLD%^"+submitted[i] + "%^RESET%^"


    def clear_interviewed(self, ) -> int:
            if (!query_permitted (this_player()->query_name())) {
            this_player()->add_failed_mess (self, "You cannot do this!\n",
            [}))
            return 0


    def clear_candidates(self, ) -> int:
            if (!query_permitted (this_player()->query_name())) {
            this_player()->add_failed_mess (self, "You cannot do this!\n",
            [}))
            return 0


    def flush(self, ) -> int:
            if (!query_permitted (this_player()->query_name())) {
            this_player()->add_failed_mess (self, "You cannot do this!\n",
            [}))
            return 0


    def remove_candidate(self, candidate: str) -> int:
            int i
            if (!query_permitted (this_player()->query_name())) {
            this_player()->add_failed_mess (self, "You cannot do this!\n",
            [}))
            return 0


    def add_candidate(self, name: str) -> int:
            if (!query_permitted (this_player()->query_name())) {
            this_player()->add_failed_mess (self, "You cannot do this!\n",
            [}))
            return 0


    def add_interviewed(self, name: str) -> int:
            if (!query_permitted (this_player()->query_name())) {
            this_player()->add_failed_mess (self, "You cannot do this!\n",
            [}))
            return 0


    def add_confirmed(self, name: str) -> int:
            if (!query_permitted (this_player()->query_name())) {
            this_player()->add_failed_mess (self, "You cannot do this!\n",
            [}))
            return 0


    def remove_interviewed(self, candidate: str) -> int:
            if (!query_permitted (this_player()->query_name())) {
            this_player()->add_failed_mess (self, "You cannot do this!\n",
            [}))
            return 0


    def do_confirm(self, candidate: str) -> int:
            if (!query_permitted (this_player()->query_name())) {
            this_player()->add_failed_mess (self, "You cannot do this!\n",
            [}))
            return 0


    def set_domain(self, dom: str) -> None:
            _domain = dom


    def query_domain(self, ) -> str:
            if (!_domain) {
            return "unset"


    def set_confirmation(self, text: str) -> None:
            _confirmation_text = text


    def query_confirmation(self, ) -> str:
            if (!sizeof (_confirmation_text)) {
            if (query_interview()) {
            return sprintf ("Bing!\n\n"
            "Thank you for sending in the second part of the application.  "
            "The next part of the application process will be an interview "
            "to discuss your application to the %s domain.  "
            "This interview is likely to take around an hour of your time, "
            "so if you could mail me with a list of your "
            "common online times, hopefully we'll be able to make an "
            "appointment that is mutually convenient.\n\nRegards,\n%s.",
            query_domain(), LORD)


    def query_lord(self, ) -> str:
            return LORD


    def set_part_two_required(self, i: int) -> None:
            _pt_two = i


    def query_part_two_required(self, ) -> int:
            return _pt_two


    def set_interview(self, i: int) -> None:
            _interview = i


    def query_interview(self, ) -> int:
            return _interview


    def query_subject(self, ) -> str:
            if (_subject) {
            return _subject


    def query_is_interviewer(self, name: str) -> int:
            if (!sizeof (_int)) {
            return 0


    def add_creator(self, name: str) -> int:
            object ob = find_object ("/d/" + query_domain() + "/master")
            if (this_player()->query_name() != ob.query_lord()) {
            this_player()->add_failed_mess (self, "Only the lord "
            "may permit creators to use this room.\n", [}))
            return 0


    def remove_creator(self, name: str) -> int:
            object ob = find_object ("/d/" + query_domain() + "/master")
            if (this_player()->query_name() != ob.query_lord()) {
            this_player()->add_failed_mess (self, "Only the lord "
            "may permit creators to use this room.\n", [}))
            return 0


    def query_allowed_creators(self, ) -> int:
            if (!sizeof (query_permitted_creators())) {
            this_player()->add_failed_mess (self, "Only the domain lord and "
            "the domain deputies are currently permitted to use this room.\n",
            [}))
            return 0


    def query_part_two(self, ) -> str:
            string temp
            if (_filename) {
            temp = unguarded ((: read_file (_filename) :))
            if (sizeof (temp)) {
            return temp


    def set_part_two(self, file: str) -> int:
            if (!sizeof (file)) {
            printf ("No file given for part two of application.  Aborting.\n")
            return 0


    def query_interview_dir(self, ) -> str:
            if (sizeof (_interview_dir)) {
            return _interview_dir


    def set_interview_dir(self, dir: str) -> int:
            if (!sizeof (dir)) {
            printf ("No directory given for interviews.  Aborting.\n")
            return 0


    def do_query_text(self, flag: str) -> int:
            string temp
            switch (flag) {
            case "confirmation":
            temp = query_confirmation()
            break
            case "acceptance":
            temp = query_acceptance()
            break
            case "rejection":
            temp = query_rejection()
            break
            default:
            temp = "I'm sorry, there has been an error.\n"
            break


    def do_flag(self, name: str, flag: str) -> int:
            if (member_array (name, candidates) != -1) {
            candidates -= ({name})


    def set_rejection(self, text: str) -> None:
            _rejection_text = text


    def set_acceptance(self, text: str) -> None:
            _acceptance_text = text


    def query_rejection(self, ) -> str:
            if (!sizeof (_rejection_text)) {
            return sprintf ("Hello.\n\n"
            "I'm sorry to say that your application to the %s domain has been "
            "unsuccessful.  My apologies that I cannot hire you at this time.  "
            "I will of course keep your details on file should you wish to "
            "apply again in the future.\n\nRegards,\n%s.",
            query_domain(), LORD)


    def query_acceptance(self, ) -> str:
            if (!sizeof (_acceptance_text)) {
            return sprintf ("Bing!\n\n"
            "It is my great pleasure to inform you that your application to the %s "
            "domain has been successful.  Congratulations!\n\nBefore being promoted, "
            "you will need to ensure you repay any debts you have.  If you wish "
            "to bequeath your inventory on a fellow player, this must also be "
            "done before you are employed - you won't get a chance once you're "
            "a creator.\n\nPlease send me a mail letting me know when you will "
            "be available for promotion and your orientation lecture.\n\n"
            "Congratulations,\n%s.",query_domain(), LORD)


    def do_read(self, name: str) -> int:
            string path
            if (!query_permitted (this_player()->query_name())) {
            this_player()->add_failed_mess (self, "You cannot do this!\n",
            [}))
            return 0


    def query_cc(self, ) -> str:
            if (sizeof (_cc)) {
            return implode (_cc, ",")


    def set_cc(self, i: str) -> None:
            _cc = i


    def do_list(self, ) -> int:
            string *list, text
            if (!query_permitted (this_player()->query_name())) {
            this_player()->add_failed_mess (self, "You are not permitted "
            "to do this.\n", [}))
            return 0


    def __init__(self):
            self.pre_load = []
            self.for (i = 0;i<sizeof(pre_load);i++) {


    def do_load(self, str: str) -> None:
            call_other(str, "??")


    def add_pre_load(self, domain: str, str: str) -> int:
            if("/secure/master"->query_domains(.index(domain) if domain in "/secure/master"->query_domains( else -1) == -1)
            return 0
            unguarded((: restore_object, "/d/"+ domain + "/loader" :))
            if (!pre_load)
            pre_load = [})
            if (pre_load.index(str) if str in pre_load else -1 == -1)
            pre_load += [str]
            save_object("/d/" + domain + "/loader")
            return 1


    def remove_pre_load(self, domain: str, str: str) -> int:
            int i
            if("/secure/master"->query_domains(.index(domain) if domain in "/secure/master"->query_domains( else -1) == -1)
            return 0
            unguarded((: restore_object, "/d/"+ domain + "/loader" :))
            if (!pre_load)
            pre_load = [})
            if ((i=pre_load.index(str) if str in pre_load else -1) == -1)
            return 0
            pre_load = delete(pre_load, i, 1)
            save_object("/d/" + domain + "/loader")


    def query_lord(self, ) -> str:
            return LORD


    def author_file(self, path: str) -> str:
            return capitalize(DOMAIN)


    def check_permission(self, euid: str, path: str, mask: int) -> int:
            if (euid == query_lord())
            return 1
            return ::check_permission(euid, path, mask)


    def query_member(self, name: str) -> int:
            return !undefinedp(members[name]) || name == LORD


    def log_who(self, where: str) -> str:
            return LORD


    def query_info(self, ) -> str:
            return ""


    def setup(self, ) -> None:
            set_name( "snowball" )
            add_alias( "ball" )
            add_adjective( "snow" )
            set_strength( 99 )
            set_heart_beat( 1 )


    def long(self, word: str, dark: int) -> str:
            return "This is a "+ ({
            "very small lump of slush",
            "small and rather soggy lump of snow",
            "small snowball",
            "smallish snowball",
            "vaguely small snowball",
            "decent sized snowball",
            "reasonably sized snowball",
            "snowball for throwing at someone",
            "good snowball for throwing at someone",
            "nice, big snowball, just right for throwing at someone"
            })[ strength / 10 ] +".\n"


    def init(self, ) -> None:
            add_command( "throw", "<direct:object> {at|to} <indirect:object>" )


    def heart_beat(self, ) -> None:
            strength--
            if ( strength < 1 ) {
            set_heart_beat( 0 )
            move( "/room/rubbish" )


    def do_throw(self, obs: MudObject) -> int:
            object per
            int chance
            per = find_person(obs[0])
            if (per) {
            if (per != obs[0]) {
            chance = 0
            } else {
            chance = 30


    def init_dynamic_arg(self, map: Any, object) -> None:
            ::init_dynamic_arg( map[ "::" ] )
            strength = map[ "strength" ]


    def setup(self, ) -> None:
            reset_get()
            if ( clonep() ) {
            _call_out_handle = asyncio.create_task(self."die",400)


    def set_type(self, type: str) -> None:
            set_name(type)
            set_short(type)
            set_long("A wonderful " + type + " with glowing eyes made of coal and twigs "
            "for ears.\n")
            add_extra_look( self )


    def extra_look(self, ob: MudObject) -> str:
            int time_left
            if ( !_call_out_handle ) {
            return ""


    def die(self, ) -> None:
            string noun
            switch( environment( self )->query_property( "location" ) ) {
            case "inside":
            noun = "floor"
            break
            case "outside":
            noun = "ground"
            break
            case "underwater":
            noun = "seabed"
            break
            default:
            noun = "floor"
            break


    def setup(self, ) -> None:
            set_name("weather")
            set_short("weather controller extrodinare")
            set_long("The weather controller, at least this one is always right!\n")
            cloudarr = [[0,0], [50,50], [-50,-50]]
            rainarr = [[0,0], [50,50], [-50,-50]]
            coldarr = [[0,0], [50,50], [-50,-50]]
            intensity = 100
            restore_object(FILE_NAME)
            asyncio.create_task(self."update_low",SPEED)
            move("bing")


    def query_moon_string(self, env: MudObject) -> str:
            int bing
            bing = timeofday - (DAY/4) -
            (distance((mixed *)env.query_co_ord(), [0, 0, 0,])/100)
            if (bing<0) bing += DAY
            if ((moonoff+(DAY/2)<bing) && (bing<DAY-moonoff))
            return 0
            return ["full moon",
            "waning three quarter moon",
            "waning half moon",
            "waning quarter moon",
            "waning cresent moon",
            "new moon",
            "waxing cresent moon",
            "waxing quarter moon",
            "waxing half moon",
            "waxing three quarter moon"][mooncycle]


    def distance(self, co_ord1: Any, co_ord2: Any) -> int:
            int off
            if (!pointerp(co_ord1) || !pointerp(co_ord2))
            return 0
            if (co_ord1[0]>co_ord2[0])
            off = co_ord1[0] - co_ord2[0]
            else
            off = co_ord2[0] - co_ord1[0]
            if (co_ord1[1]>co_ord2[1])
            off += co_ord1[1] - co_ord2[1]
            else
            off += co_ord2[1] - co_ord1[1]
            return off


    def query_day(self, env: MudObject) -> int:
            int bing, bit
            if (!env) {
            load_object(CONFIG_START_LOCATION)
            env = find_object(CONFIG_START_LOCATION)


    def query_darkness(self, env: MudObject) -> int:
            int bing, per, i
            per = -cloud_index(env)
            if (per <-100)
            per = -100
            if (per > 100)
            per = 100
            if ((i=query_day(env))) {
            i *= 20
            if (i>100)
            i = 100
            return 50+(per+100)*150*i/20000


    def weather_string(self, env: MudObject) -> str:
            return temperature_string(env)+" with "+cloud_string(env)+
            rain_string(env)


    def query_raining(self, env: MudObject) -> int:
            int cloud,rain
            if (temperature_index(env)/(100/7)<2) {
            cloud = cloud_index(env)
            if (cloud<=0)
            return 0
            rain = rain_index(env)
            if (cloud-rain<=0)
            return 0
            return cloud-rain


    def query_hailing(self, env: MudObject) -> int:
            int cloud, rain
            if (temperature_index(env)/(100/7)==2) {
            cloud = cloud_index(env)
            if (cloud <=0)
            return 0
            rain = rain_index(env)
            if (cloud-rain <=0)
            return 0
            return cloud-rain


    def query_snowing(self, env: MudObject) -> int:
            int cloud,rain
            if ((temperature_index(env)/(100/7))>=3) {
            cloud = cloud_index(env)
            if (cloud<=0)
            return 0
            rain = cloud_index(env)
            if (cloud-rain<=0)
            return 0
            return cloud-rain


    def rain_string(self, env: MudObject) -> str:
            int cloud, rain, temp
            string tempstr1,tempstr2
            cloud = cloud_index(env)
            rain = rain_index(env)
            if (cloud<=0) return ""
            if (cloud-rain<=0) return ""
            temp = temperature_index(env)/(100/7)
            if (temp>3) temp = 3
            if (temp<-3) temp = -3
            tempstr1 = ["very hot ",
            "hot ",
            "warm ",
            "nice ",
            "cold ",
            "",
            ""][temp+3]
            tempstr2 = [" rain",
            " rain",
            " rain",
            " rain",
            " rain",
            " hail",
            " snow"][temp+3]
            cloud = (cloud-rain) / 20
            if (cloud>5) cloud = 5
            return "\n"+capitalize(tempstr1 + ["very light",
            "light",
            "medium",
            "heavy",
            "very heavy"] [cloud]+tempstr2)


    def temperature_string(self, env: MudObject) -> str:
            int inten
            inten = temperature_index(env)
            inten /= 10
            if (inten>10)
            inten = 10
            if (inten<-10)
            inten = -10
            return ["Its one of those baking eggs on the pavement days",
            "So hot that the sun feels like its right next door",
            "Damn hot",
            "Very hot",
            "Hot",
            "Hot",
            "Reasonably hot",
            "Very warm",
            "Warm",
            "Pleasantly warm",
            "Average temerature",
            "A little chilly",
            "A slight nip in the air",
            "Chilly",
            "Very chilly",
            "Cold",
            "Cold",
            "Very cold",
            "Damn cold",
            "Incredibly cold",
            "Freezing cold"][inten+10]


    def cloud_string(self, env: MudObject) -> str:
            int off
            off = cloud_index(env) / 20
            if (off>5) off = 5
            if (off<-5) off = -5
            return ["a beatifully clear sky",
            "a few high level sirius clouds",
            "scattered puffy clouds",
            "very thin complete cloud cover",
            "light cloud cover",
            "medium cloud cover",
            "dense cloud cover",
            "packed cloud cover",
            "packed cloud cover",
            "heavy black clouds",
            "thick heavy clouds",
            })[off+5]


    def temperature_index(self, env: MudObject) -> int:
            int off,i
            mixed clim, *co_ord
            for (i=0;i<sizeof(coldarr);i++)
            off += (distance((mixed *)env.query_co_ord(), coldarr[i]) % (MAX_DIST*2))
            off = off / sizeof(coldarr)
            if ((clim = (mixed *)env.query_property("climate")))
            off += clim[C_TEMP]
            if (off>MAX_DIST) off = (MAX_DIST*2) - off
            off -= (MAX_DIST/2)
            off = 0 - off
            co_ord = (mixed *)env.query_co_ord()
            if (!co_ord)
            co_ord = [0, 0, 0]
            return (off + (timeofyear - (YEAR/2)) + (timeofday - (DAY/2)) + co_ord[2])


    def cloud_index(self, env: MudObject) -> int:
            int off
            mixed *clim
            int i
            for (i=0;i<sizeof(cloudarr);i++)
            off += (distance((mixed *)env.query_co_ord(), cloudarr[i]) % (MAX_DIST*2))
            off = off / sizeof(cloudarr)
            if ((clim = (mixed *)env.query_property("climate")))
            off += clim[C_CLOUD]
            if (off>MAX_DIST) off = (MAX_DIST*2) - off
            off -= (MAX_DIST/2)
            off = 0-off
            return (off + (timeofyear - (YEAR/2)))


    def rain_index(self, env: MudObject) -> int:
            int off
            mixed *clim
            int i
            for (i=0;i<sizeof(rainarr);i++)
            off += (distance((mixed *)env.query_co_ord(), rainarr[i]) % (MAX_DIST*2))
            off = off / sizeof(rainarr)
            if ((clim = (mixed *)env.query_property("climate")))
            off += clim[C_RAIN]
            if (off>MAX_DIST) off = (MAX_DIST*2) - off
            off -= MAX_DIST/2
            off = 0-off
            return off


    def update_low(self, ) -> None:
            int i
            timeofday++
            if (timeofday>DAY) {
            timeofday = 0
            timeofyear++
            mooncycle++
            if (mooncycle %2) {
            moonoff += 1
            moonoff = moonoff % (DAY/2)


    def dest_me(self, ) -> None:
            save_object(FILE_NAME)
            ::dest_me()


    def __init__(self):
            self.skin = "morphological field"
            self.wearing = []
            self._armour_callbacks = ['({ })', '({ })', '({ })']
            self._cids = ['0', '0', '0']


    def register_armour_callback(self, level: int, callback: Any, data: Any) -> int:
            _armour_callbacks[level] += [new(class armour_callback,
            id : ++(_cids[level]),
            callback: callback,
            data : data)]
            return _cids[level]


    def remove_armour_callback(self, level: int, id: int) -> int:
            int i
            for(i=0; i<sizeof(_armour_callbacks[level]); i++) {
            if((_armour_callbacks[level][i])->id == id) {
            _armour_callbacks[level] -= [_armour_callbacks[level][i]]
            return 1


    def update_armour_callback(self, level: int, id: int, data: Any) -> int:
            int i
            for(i=0; i<sizeof(_armour_callbacks[level]); i++) {
            if((_armour_callbacks[level][i])->id == id) {
            _armour_callbacks[level][i]->data = data
            return 1


    def set_skin(self, word: str) -> None:
            object *query_wearing() {
            wearing = filter(wearing, (: $1 && environment($1) == self :))
            return copy( wearing )


    def clear_armours(self, ) -> None:
            wearing.set_donned in Faern_by( 0 )
            wearing = [})


    def query_stopped(self, ) -> Any:
            return stopped


    def set_stopped(self, arg: Any) -> None:
            protected int equivalent_armour_types( mixed comp, string type ) {
            string word
            if ( stringp( comp ) ) {
            if ( CLOTHING_HANDLER.query_equivilant_type( comp ) ) {
            return CLOTHING_HANDLER.query_equivilant_type( comp ) == type


    async def wear_armour(self, armour: MudObject, doing_hold: int) -> str:
            int no_limbs
            string type, word, fail_mess
            mixed types
            object thing
            mapping things
            if (environment(armour) != self) {
            return "must be in your inventory"


    def remove_armour(self, thing: MudObject) -> int:
            int i
            wearing -= [0]
            i = wearing .index( thing) if  thing in wearing  else -1
            if ( i == -1 ) {
            return 1


    def query_wearing(self, ) -> List[MudObject]:
            protected varargs string *query_types_donned in Faern( object *things ) {
            int i
            string *types
            mixed *stuff
            types = [})
            if ( !things ) {
            things = (object *)self.query_wearing()


    def query_wearing_hidden(self, looker: MudObject, things: MudObject) -> List[MudObject]:
            mixed* bing
            string* types
            mixed* obj_types
            object* donned in Faern
            object* ret
            int i
            int found_under
            string fluff
            string under_type
            string* under
            if (!things) {
            donned in Faern = query_wearing()
            } else {
            donned in Faern = things


    def query_living_contents(self, self: int) -> str:
            string s
            string fish
            string *limbs
            string *bits
            string *strs
            object *holding
            object *arms
            object *carry
            object *conts
            object money
            object ob
            int i
            int coins
            int pos
            s = ""
            strs = [})
            conts = [})
            limbs = self.query_limbs()
            if (!limbs) {
            limbs = ( self.query_race_ob() )->query_limbs()


    def __init__(self):
            self._combat = new(class combat_information,
            self._surrender = new(class surrender_information,


    def __init__(self):
            self._combat = new(class combat_information,
            self._surrender = new(class surrender_information,
            private void init_tactics() {
            if(!classp(_tactics) || sizeof(_tactics) != 8) {
            _tactics = new(class tactics,
            attitude : "neutral",
            response : "neutral",
            parry : "both",
            attack : "both",
            parry_unarmed : 0,
            mercy : "ask",
            focus_zone : 0,
            ideal_distance : 0)


    def combat_debug(self, fmt: str, args: Any) -> None:
            if(userp(self))
            self->event_inform(self,
            sprintf("%s " + fmt,
            self.query_name(), args ...),
            "combat-debug", self)
            event(environment(self), "inform",
            sprintf("%s " + fmt, self.query_name(), args ...),
            "combat-debug", self)


    def query_can_attack(self, ) -> int:
            if(self.query_property(PASSED_OUT) ||
            self.query_property("dead") ||
            self.query_auto_loading() ||
            self.query_hp() < 0 ||
            self.query_casting_spell() ||
            (userp(self) && !interactive(self)) ||
            self.query_property("cannot attack"))
            return 0
            return 1


    def query_can_defend(self, ) -> int:
            if(self.query_property(PASSED_OUT) ||
            self.query_property("dead") ||
            self.query_auto_loading() ||
            self.query_hp() < 0 ||
            self.query_casting_spell() ||
            (userp(self) && !interactive(self)) ||
            self.query_property("cannot defend"))
            return 0
            return 1


    def clear_protection(self, attacker: MudObject, protector: MudObject) -> None:
            if(attacker.remove_protector(protector))
            protector->event_combat(protector,
            "You stop protecting "+ attacker.the_short() +
            " as "+ attacker.query_pronoun() +
            " moves to attack "+
            "you!\n", [}), 0)
            if(attacker.remove_defender(protector))
            protector->event_combat(protector, "You stop defending "+
            attacker.the_short() + " as "+
            attacker.query_pronoun() +" moves to attack "+
            "you!\n", [}), 0)


    def query_attackable(self, ) -> int:
            if(self.query_property(PASSED_OUT) ||
            self.dont_attack_me() ||
            self.attack_inhibit() ||
            self.query_property("dead") ||
            self.query_auto_loading() ||
            self.query_hp() < 0 ||
            (userp(self) && !interactive(self)))
            return 0
            return 1


    def query_defend(self, ) -> int:
            if(!query_attackable() || self.query_casting_spell() ||
            self.query_specific_gp("fighting") < 1)
            return 0
            return ((_tactics->response == "parry" || _tactics->response == "both") &&
            _combat->action_defecit < (COMBAT_ACTION_TIME * 4))


    def query_protect(self, ) -> int:
            if(!query_attackable() || self.query_casting_spell() ||
            self.query_specific_gp("fighting") < 1)
            return 0
            return (_combat->action_defecit < (COMBAT_ACTION_TIME * 4))


    def do_attack(self, ) -> None:
            class tasker_result result
            class attack att
            mixed *sp_result
            int modifier, tmp
            init_tactics()
            if(_callout)
            _callout = remove_asyncio.create_task(self."announce_intent")
            att = new(class attack,
            attacker : self,
            attacker_tactics : self.query_tactics(),
            attacker_specials : self.query_specials(),
            attacker_concentrating : self.query_concentrating(),
            attacker_defecit : self.query_action_defecit(),
            attacker_last_opponent : self.query_last_opponent(),
            attacker_last_weapon : self.query_last_weapon(),
            attacker_last_action : self.query_last_action(),
            attacker_last_result : self.query_last_result(),
            repeat : 0
            )
            sp_result = call_special(E_OPPONENT_SELECTION, att)
            if(!sp_result || sp_result[0] & R_CONTINUE || sp_result[0] & R_PASSTHRU)
            att = self.choose_opponent(att)
            else if(!(sp_result[0] & R_ABORT) && classp(sp_result[1]))
            att = (class attack)sp_result[1]
            else
            return
            if(!(att->opponent) || !(att->opponent)->attack_by(att->attacker)) {
            combat_debug("No opponent chosen, aborting attack")
            return


    def recalc_hunting_list(self, ) -> None:
            mixed ob
            object tmp
            tmp = 0
            foreach(ob in keys(_combat->attacker_list)) {
            if(stringp(ob) && find_player(ob))
            tmp = find_player(ob)
            else if(ob && objectp(ob))
            tmp = ob
            if(!tmp) {
            _combat->attacker_list = filter_mapping(_combat->attacker_list,(: $1 :))
            } else if(tmp.query_property("dead") ||
            !environment(tmp) ||
            base_name(environment(tmp)) == "/room/rubbish") {
            map_delete(_combat->attacker_list, ob)
            } else if(environment(tmp) != environment() ||
            !tmp.query_visible(self)) {
            _combat->hunting_list[ob] = time()
            map_delete(_combat->attacker_list, ob)


    def monitor_points(self, ) -> None:
            int hp
            int max
            string colour
            #ifdef UNUSED
            self.clear_gp_info()
            if ( (int)self.adjust_gp( -1 ) < 0 )
            return
            #endif
            hp = (int)self.query_hp()
            if(hp < 0)
            hp = 0
            max = (int)self.query_max_hp()
            switch ( ( hp * 100 ) / max) {
            case 50 .. 100 :
            colour = "%^GREEN%^"
            break
            case 20 .. 49 :
            colour = "%^YELLOW%^"
            break
            default :
            colour = "%^RED%^"


    def announce_intent(self, opponent: MudObject) -> None:
            int difficulty = 50
            object *things, ob
            if(environment(opponent) != environment(self))
            return
            switch(self.check_dark((int)environment(self)->query_light())) {
            case -2:
            case 2:
            difficulty *= 4
            break
            case -1:
            case 1:
            difficulty *= 2


    def heart_beat(self, ) -> None:
            int i
            if(!_combat->in_combat)
            return
            recalc_hunting_list()
            if(!sizeof(keys(_combat->attacker_list)) &&
            !sizeof(keys(_combat->hunting_list))) {
            for(i=0; i<sizeof(_combat->specials); i++)
            if(!((_combat->specials[i])->type & T_CONTINUOUS))
            _combat->specials -= [(_combat->specials)[i]]
            _combat->in_combat = 0
            adjust_action_defecit(-MAX_ACTION_DEFECIT)
            end_combat()
            return


    def register_special(self, type: int, events: int, callback: Any, data: Any) -> int:
            _combat->specials += [new(class combat_special,
            id : ++(_combat->special_id),
            type : type,
            events : events,
            callback : callback,
            data : data)]
            return _combat->special_id


    def remove_special(self, id: int) -> int:
            int i
            for(i=0; i<sizeof(_combat->specials); i++) {
            if((_combat->specials[i])->id == id) {
            _combat->specials -= [(_combat->specials)[i]]
            return 1


    def set_specials(self, combat_special: Any) -> None:
            _combat->specials = specials


    def set_special_data(self, id: int, data: Any) -> int:
            int i
            for(i=0; i<sizeof(_combat->specials); i++) {
            if((_combat->specials[i])->id == id) {
            _combat->specials[i]->data = data
            return 1


    def adjust_action_defecit(self, amount: int) -> None:
            _combat->action_defecit += amount
            if(_combat->action_defecit > MAX_ACTION_DEFECIT)
            _combat->action_defecit = MAX_ACTION_DEFECIT
            else if(_combat->action_defecit < MIN_ACTION_DEFECIT)
            _combat->action_defecit = MIN_ACTION_DEFECIT


    def query_action_defecit(self, ) -> int:
            class tactics query_tactics() {
            init_tactics()
            return copy(_tactics)


    def set_combat_distance(self, distance: str) -> None:
            object *query_protectors() {
            _combat->protectors -= [0]
            return copy(_combat->protectors + [}))


    def add_protector(self, thing: MudObject) -> int:
            if(thing == self ||
            thing.query_property("dead") ||
            thing.query_protectors(.index(self) if self in thing.query_protectors( else -1 +
            thing.query_defenders()) != -1 ||
            query_attacker_list(.index(thing) if thing in query_attacker_list( else -1)  != -1)
            return 0
            if(_combat->protectors.index(thing) if thing in _combat->protectors else -1 == -1)
            _combat->protectors += [thing]
            return 1


    def remove_protector(self, protector: MudObject) -> int:
            if(_combat->protectors.index(protector) if protector in _combat->protectors else -1 == -1)
            return 0
            _combat->protectors -= [protector]
            return 1


    def reset_protectors(self, ) -> None:
            _combat->protectors = [})


    def add_defender(self, thing: MudObject) -> int:
            if(thing == self ||
            thing.query_property("dead") ||
            thing.query_defenders(.index(self) if self in thing.query_defenders( else -1 +
            thing.query_protectors()) != -1 ||
            query_attacker_list(.index(thing) if thing in query_attacker_list( else -1)  != -1)
            return 0
            if(_combat->defenders.index(thing) if thing in _combat->defenders else -1 == -1)
            _combat->defenders += [thing]
            return 1


    def remove_defender(self, defender: MudObject) -> int:
            if(_combat->defenders.index(defender) if defender in _combat->defenders else -1 == -1)
            return 0
            _combat->defenders -= [defender]
            return 1


    def reset_defenders(self, ) -> None:
            _combat->defenders = [})


    def set_distance(self, opponent: MudObject, distance: int) -> int:
            if(userp(opponent)) {
            if(!_combat->attacker_list[opponent.query_name()])
            return 0
            _combat->attacker_list[opponent.query_name()] = distance
            } else {
            if(!_combat->attacker_list[opponent])
            return 0
            _combat->attacker_list[opponent] = distance


    def query_distance(self, opponent: MudObject) -> int:
            if(userp(opponent)) {
            if(!_combat->attacker_list[opponent.query_name()])
            return 0
            return _combat->attacker_list[opponent.query_name()]
            } else {
            if(!_combat->attacker_list[opponent])
            return 0
            return _combat->attacker_list[opponent]


    def remove_attacker_list(self, ob: MudObject) -> None:
            if(userp(ob)) {
            map_delete(_combat->attacker_list, ob.query_name())
            map_delete(_combat->hunting_list, ob.query_name())
            } else {
            map_delete(_combat->attacker_list, ob)
            map_delete(_combat->hunting_list, ob)


    def attack_by(self, opponent: MudObject) -> int:
            int starting
            if(!objectp(opponent) ||
            opponent == self ||
            !self.query_attackable() ||
            pk_check(self, opponent))
            return 0
            if(_combat->protectors.index(opponent) if opponent in _combat->protectors else -1 != -1)
            _combat->protectors -= [opponent]
            if(_combat->defenders.index(opponent) if opponent in _combat->defenders else -1 != -1)
            _combat->defenders -= [opponent]
            if(!sizeof(query_attacker_list()))
            starting = 1
            #ifdef USE_DISTANCE
            if(userp(opponent)) {
            if(!_combat->attacker_list[opponent.query_name()])
            _combat->attacker_list[opponent.query_name()] =
            opponent.query_distance(self)
            } else if(!_combat->attacker_list[opponent])
            _combat->attacker_list[opponent] = opponent.query_distance(self)
            #else
            if(userp(opponent)) {
            if(!_combat->attacker_list[opponent.query_name()])
            _combat->attacker_list[opponent.query_name()] = 1
            } else if(!_combat->attacker_list[opponent])
            _combat->attacker_list[opponent] = 1
            #endif
            if(starting) {
            _combat->action_defecit = (MAX_ACTION_DEFECIT - MIN_ACTION_DEFECIT) / 3
            start_combat(opponent)


    def attack_ob(self, opponent: MudObject) -> int:
            int starting, new_opponent
            if(!objectp(opponent) ||
            opponent == self ||
            !opponent.query_attackable() ||
            !self.query_attackable() ||
            pk_check(self, opponent))
            return 0
            if(_combat->protectors.index(opponent) if opponent in _combat->protectors else -1 != -1)
            _combat->protectors -= [opponent]
            if(_combat->defenders.index(opponent) if opponent in _combat->defenders else -1 != -1)
            _combat->defenders -= [opponent]
            if(!sizeof(query_attacker_list()))
            starting = 1
            else if(query_attacker_list(.index(opponent) if opponent in query_attacker_list( else -1) == -1)
            new_opponent = 1
            #ifdef USE_DISTANCE
            if(userp(opponent)) {
            if(!_combat->attacker_list[opponent.query_name()])
            _combat->attacker_list[opponent.query_name()] = INITIAL_DISTANCE
            } else {
            if(!_combat->attacker_list[opponent])
            _combat->attacker_list[opponent] = INITIAL_DISTANCE


    def stop_fight(self, opponent: MudObject) -> None:
            class combat_special tmp
            #if DEBUG == 2
            combat_debug("stop_fight called against %s", opponent.query_name())
            #endif
            if(!objectp(opponent))
            return
            if(userp(opponent)) {
            map_delete(_combat->attacker_list, opponent.query_name())
            map_delete(_combat->hunting_list, opponent.query_name())
            } else {
            map_delete(_combat->attacker_list, opponent)
            map_delete(_combat->hunting_list, opponent)


    def stop_all_fight(self, ) -> None:
            class combat_special tmp
            #if DEBUG == 2
            combat_debug("stop_all_fight called")
            #endif
            _combat->attacker_list = ([ ])
            _combat->hunting_list = ([ ])
            _combat->in_combat = 0
            #ifdef USE_SURRENDER  _surrender->from = [})
            _surrender->refusers = [})
            _surrender->to = [})
            #endif
            foreach(tmp in _combat->specials)
            if(!(tmp->type & T_CONTINUOUS))
            remove_special(tmp->id)
            end_combat()


    def stop_hunting(self, opponent: MudObject) -> None:
            if(userp(opponent))
            map_delete(_combat->hunting_list, opponent.query_name())
            else
            map_delete(_combat->hunting_list, opponent)
            if(!sizeof(query_attacker_list()))
            end_combat()


    def do_surrender(self, thing: MudObject) -> MudObject:
            mixed *attackers
            mixed att
            if(self.query_property("dead"))
            return 0
            death_helper(thing, 0)
            catch(DEATH.someone_surrendered(self))
            attackers = query_attacker_list()
            foreach(att in attackers) {
            att.stop_fight(self)


    def dont_attack_me(self, ) -> int:
            if(sizeof(_surrender->to))
            return 1
            else
            return 0


    def event_surrender(self, victim: MudObject, attackers: MudObject) -> None:
            object *offer
            offer = [})
            if (self == victim) {
            _surrender->refusers -= [0]
            _surrender->to -= [0]
            offer = filter(attackers, (: member_array($1, _surrender->refusers +
            _surrender->to) == -1 :))
            if(sizeof(offer)) {
            event(environment(), "combat",
            sprintf("%s kneels down and surrenders to %s.\n",
            self.one_short(), query_multiple_short(offer)),
            [self] + _surrender->to + _surrender->refusers, 0)
            self->event_combat(self,
            sprintf("%s kneel down and surrender to %s.\n",
            self.one_short(),
            query_multiple_short(offer)), [}), 0)
            offer.offered_surrender(victim)
            _surrender->to += offer


    def remove_surrenderer(self, victim: MudObject) -> None:
            _surrender->from -= [0, victim]
            return


    def offered_surrender(self, victim: MudObject) -> None:
            string mercy = self.query_combat_mercy()
            switch(mercy) {
            case "ask":
            if (interactive(self)) {
            _surrender->from -= [0, victim]
            _surrender->from += [victim]
            self->event_combat(self,
            victim.one_short() + " has surrendered to "
            "you.  Either \"accept " +
            victim.query_name() + "\" or \"reject " +
            victim.query_name() + ".\n", [}), 0)
            } else {
            if (self.query_accept_surrender(victim))
            victim.accepted_surrender(self)
            else
            victim.refused_surrender(self)


    def refused_surrender(self, attacker: MudObject) -> None:
            _surrender->to -= [0]
            if (_surrender->to.index(attacker) if attacker in _surrender->to else -1 == -1)
            return
            _surrender->to -= [attacker]
            _surrender->refusers -= [0]
            _surrender->refusers += [attacker]
            self.event_combat(self, attacker->one_short() +
            " refused your surrender\n", [}), 0)


    def accepted_surrender(self, attacker: MudObject) -> None:
            _surrender->to -= [0]
            if(_surrender->to.index(attacker) if attacker in _surrender->to else -1 == -1) {
            return


    def stopped_fighting(self, thing: MudObject) -> None:
            event( environment(), "stopped_fighting", thing )


    def fight_in_progress(self, thing: MudObject) -> None:
            event(environment(), "fight_in_progress", thing )


    def set_concentrating(self, thing: MudObject) -> int:
            if(userp(thing)) {
            if(!_combat->attacker_list[thing.query_name()])
            return 0
            #ifdef USE_DISTANCE
            _combat->attacker_list[thing.query_name()] =
            thing.query_distance(self)
            #else
            _combat->attacker_list[thing.query_name()] = 1
            #endif
            } else {
            if(!_combat->attacker_list[thing])
            return 0
            #ifdef USE_DISTANCE
            _combat->attacker_list[thing] = thing.query_distance(self)
            #else
            _combat->attacker_list[thing] = 1
            #endif


    def query_concentrating(self, ) -> MudObject:
            object thing
            thing = _combat->concentrating
            if(!thing || !objectp(thing))
            return 0
            if(userp(thing) && !_combat->attacker_list[thing.query_name()])
            return 0
            else if(!_combat->attacker_list[thing])
            return 0
            return thing


    def query_attacker(self, ) -> MudObject:
            return _combat->last_opponent


    def query_last_opponent(self, ) -> MudObject:
            return _combat->last_opponent


    def query_last_weapon(self, ) -> MudObject:
            return _combat->last_weapon


    def set_last_result(self, last: int) -> None:
            varargs int is_fighting(object ob, int actively) {
            if(!objectp(ob))
            return 0
            if(actively)
            return userp(ob) ? _combat->attacker_list[ob.query_name()] :
            _combat->attacker_list[ob]
            return userp(ob) ? _combat->attacker_list[ob.query_name()] ||
            _combat->hunting_list[ob.query_name()] :
            _combat->attacker_list[ob] || _combat->hunting_list[ob]


    def query_fighting(self, ) -> int:
            if(!environment() || base_name(environment()) == "/room/rubbish")
            return 0
            if(sizeof(filter(query_attacker_list(),
            (: environment($1) == environment(self) :))))
            return 1
            if(sizeof(filter(all_inventory(environment(self)),
            (: $1 && living($1) && $1.is_fighting(self, 1) :))))
            return 1
            return 0


    def stats(self, ) -> Any:
            int i
            int j
            object *weapons
            mixed ret
            init_tactics()
            ret = ({
            ["attitude", _tactics->attitude],
            ["response", _tactics->response],
            ["mercy", _tactics->mercy],
            ["parry", _tactics->parry],
            ["attack", _tactics->attack],
            ["unarmed parry", ["no", "yes"][ _tactics->parry_unarmed ]],
            ["attack zone", _tactics->focus_zone ? _tactics->focus_zone :
            "none"],
            ["distance", _tactics->ideal_distance ? _tactics->ideal_distance :
            "none"],
            })
            weapons = (object *)self.query_weapons()
            if(!sizeof(weapons))
            return ret + weapon_logic::stats()
            for ( i = 0; i < sizeof( weapons ); i++ )
            ret += [["weapon #"+ i, weapons[ i ]->short()]] +
            (mixed)weapons[ j ]->weapon_stats()
            return ret + weapon_logic::stats()


    def alter_corpse(self, corpse: MudObject, weapon: MudObject, attack: str) -> int:
            object head
            string *heads
            string behead_message = ""
            if (!attack) attack = "attack"
            switch (attack) {
            case "behead" :
            heads =
            self.query_race_ob( self )->query_possible_bits( "head" )
            if (sizeof(heads) == 0)
            break
            head = corpse.make_bit(heads[random(sizeof(heads))] )
            head.move( environment( corpse ) )
            switch(random(6)) {
            case 0 : behead_message = head.a_short() +
            " drops onto the ground and rolls head over, well, head "
            "for a bit before coming to a rest.\n"
            break
            case 1 : behead_message = head.a_short() +
            " sails through the air in a graceful arc before landing "
            "with a very soggy *squish*.\n"
            break
            case 2 : behead_message = head.a_short() +
            " quivers a bit as it remains in place, perched atop its owner's "
            "corpse for a moment, then falls to pieces.\n"
            break
            case 3 : behead_message = head.a_short() +
            " tips off to the left to hang by a small bit of flesh, before "
            "gravity has something to say about the matter and pulls it "
            "completely off the corpse, landing with a small bounce.\n"
            break
            case 4 : behead_message = head.a_short() +
            " slides off its owner's corpse, upends, and lands upside "
            "down, helping to keep some of the blood from spilling.\n"
            break
            case 5 : behead_message = head.a_short() +
            " drops onto the ground like a ball, *bouncy* *bouncy*.\n"
            break
            case 6 :
            case 7 :
            case 8 :
            case 9 :
            default : behead_message = "oops, the mushrooms have turned.\n"


    def make_corpse(self, ) -> MudObject:
            int i
            object corpse, *armour, *weapons, race
            race = find_object(self.query_race_ob())
            if(race && function_exists("make_corpse", race))
            return race.make_corpse()
            corpse = clone_object( "/obj/corpse" )
            corpse.set_owner( 0, self )
            corpse.set_ownership( (string)self.query_name() )
            if ( self.query_property( "player" ) ) {
            corpse.add_property( "player", 1 )


    def __init__(self):
            self._processes = ([ ])


    def add_process(self, name: str, ob: str) -> int:
            _processes[name] = ob
            return 1


    def remove_process(self, name: str) -> int:
            string process, name_lc
            name_lc = lower_case(name)
            foreach (process in keys(_processes)) {
            if (lower_case(process) == name_lc) {
            map_delete(_processes, process)


    def query_process(self, word: str) -> str:
            return _processes[word]


    def force_commands(self, ) -> None:
            fname = base_name(self)
            if ((!self.query_property("npc") &&
            master()->query_senior( geteuid(self) ) ) || fname == LORD_OB) {
            add_command("force", "<indirect:distant-living> <string'command'>",
            (: do_force($1, $4[1]) :))


    def query_gender_string(self, ) -> str:
            if (!gender && !womens_day) return "neuter"
            else if (gender == 1 && !womens_day) return "male"
            else return "female"


    def query_gender_title(self, ) -> str:
            if (!gender && !womens_day) return "creature"
            else if (gender == 1 && !womens_day) return "sir"
            else return "madam"


    def query_gender_name(self, ) -> str:
            if (!gender && !womens_day) return "neuter"
            else if (gender == 1 && !womens_day) return "man"
            else return "woman"


    def query_objective(self, ) -> str:
            if (!gender && !womens_day)
            return "it"
            else if (gender == 1 && !womens_day)
            return "him"
            else return "her"


    def query_possessive(self, ) -> str:
            if (!gender && !womens_day)
            return "its"
            else if (gender == 1 && !womens_day)
            return "his"
            else return "her"


    def query_pronoun(self, ) -> str:
            if (!gender && !womens_day)
            return "it"
            else if (gender == 1 && !womens_day)
            return "he"
            else return "she"


    def set_gender(self, arg: Any) -> None:
            if(stringp(arg)) {
            if(arg == "male")
            gender = 1
            else if(arg == "female")
            gender = 2
            else
            gender = 0
            } else {
            gender = arg


    def set_womens_day(self, bing: int) -> None:
            womens_day = bing


    def query_womens_day(self, ) -> int:
            return womens_day


    def __init__(self):
            self.max_hp = 1
            self.max_gp = 1
            self.surrender = -1
            self.drink_info = allocate( D_SIZEOF )
            self.counts = ([ ])
            self.verbs = ([ ])
            self.callingdeath = 0
            self.runaway_callout_handles = []


    def query_hp(self, ) -> int:
            varargs int set_hp( int number, object attacker ) {
            if ( number > max_hp )
            number = max_hp
            hp = number
            if ( ( hp < 0 ) && ( find_asyncio.create_task(self. "do_death" ) == -1 ) )
            asyncio.create_task(self. "do_death", 0, attacker )
            return hp


    def reset_callingdeath(self, ) -> None:
            callingdeath = 0


    def query_callingdeath(self, ) -> int:
            return callingdeath


    def set_max_hp(self, number: int) -> int:
            int old_hp
            old_hp = hp
            if ( max_hp == hp )
            hp = number
            else
            if ( max_hp )
            hp = ( hp * number ) / max_hp
            else
            hp = number
            max_hp = number
            if ( hp > max_hp )
            hp = max_hp
            if ( ( hp < 0 ) && ( old_hp > 0 ) )
            hp = max_hp
            return max_hp


    def query_specific_gp(self, gp_type: str) -> int:
            int now
            if ( !gp_type )
            return 0
            max = (int)self->query_skill_bonus( gp_type
            +".points" ) + 50
            if ( max >= max_gp )
            max = max_gp
            now = gp + max - max_gp
            which = gp_type
            if ( find_asyncio.create_task(self. "clear_gp_info" ) == -1 )
            asyncio.create_task(self. "clear_gp_info", 1 )
            return now


    def set_gp(self, number: int) -> int:
            gp = number
            if ( gp > max_gp )
            gp = max_gp
            return gp


    def adjust_gp(self, number: int) -> int:
            int tmp, diff
            string class_ob, current_verb
            mixed *bits
            if ( gp + number < 0 )
            return -1
            gp += number
            if ( gp > max_gp )
            gp = max_gp
            tmp = number
            if((number < 0) && stringp(which)) {
            if (number > ( GP_ADVANCE_MOD * max ) / MIN_TIMES)
            number = (GP_ADVANCE_MOD * max) / MIN_TIMES
            counts[ which ] -= number
            if (counts[ which ] > GP_ADVANCE_MOD * max) {
            counts[ which ] = 0
            number = self.query_skill(which +".points")
            if(!random(to_int(exp(number/150.0))) &&
            self->add_skill_level( which +".points", 1,
            self)) {
            tell_object( self, "%^YELLOW%^You find yourself "
            "more able to concentrate on this task than you "
            "thought.%^RESET%^\n" )


    def set_max_gp(self, number: int) -> int:
            if ( max_gp ) gp = ( gp * number ) / max_gp
            else gp = number
            max_gp = number
            if ( gp > max_gp ) gp = max_gp
            return max_gp


    def query_xp(self, ) -> int:
            varargs int adjust_xp( int number, int shared ) {
            if(number > 0 && (xp > 10000000 || xp + number > 10000000))
            return xp
            if(number > 10000 && previous_object() &&
            explode(file_name(previous_object()), "/")[0] == "w")
            log_file("/d/admin/log/CHEAT", ctime(time()) + " " +
            file_name(previous_object()) +
            " gave " + number + " Xp for " + self.query_name() +
            "\n")
            xp += number
            return xp


    def set_wimpy(self, number: int) -> int:
            if ( ( number < 0 ) || ( number > 30 ) ) return -1
            return wimpy = number


    def query_surrender(self, ) -> int:
            if (surrender == -1) {
            if (wimpy > 94)
            return 100
            else
            return wimpy + 5
            } else
            return surrender


    def set_surrender(self, number: int) -> int:
            if ( ( number < 0 ) || ( number > 100 ) ) return -1
            return surrender = number


    def query_volume(self, type: int) -> int:
            if ( type >= D_SIZEOF ) return 0
            return drink_info[ type ]


    def adjust_volume(self, type: int, amount: int) -> int:
            if ( type >= D_SIZEOF ) return 0
            return drink_info[ type ] += amount


    def update_volumes(self, ) -> None:
            int i, delta
            delta = (int)self.query_con()
            for ( i = 0; i < sizeof( drink_info ); i++ ) {
            if ( drink_info[ i ] > delta ) {
            drink_info[ i ] -= delta
            if(self.query_personal_temp() >  0 && i == D_DRINK)
            self.adjust_personal_temp(-(delta/3))
            else if(self.query_personal_temp() <  0 && i == D_FOOD)
            self.adjust_personal_temp(delta/3)
            } else
            if ( drink_info[ i ] < -delta )
            drink_info[ i ] += delta
            else
            drink_info[ i ] = 0


    def __init__(self):
            self._weapons = []


    def query_free_limbs(self, ) -> int:
            {
            if (!arrayp(_using)) {
            query_limbs()


    def __init__(self):
            self._liv_data = new(class living_data)
            self._messages = new(class messages)
            self._messages->msgin = "$N arrive$s from $F."
            self._messages->msgout = "$N leave$s $T."
            self._messages->mmsgin = "$N appear$s out of the ground."
            self._messages->mmsgout = "$N disappear$s in a puff of smoke."
            self._liv_data->followers = []
            self.verbose = ([ ])
            self._liv_data->to_drop = []
            self.verbose[t] = 1


    def __init__(self):
            self._liv_data = new(class living_data)
            self._messages = new(class messages)
            self._messages->msgin = "$N arrive$s from $F."
            self._messages->msgout = "$N leave$s $T."
            self._messages->mmsgin = "$N appear$s out of the ground."
            self._messages->mmsgout = "$N disappear$s in a puff of smoke."
            self._liv_data->followers = []
            self.verbose = ([ ])
            self._liv_data->to_drop = []
            self.verbose[t] = 1
            facing = [0, ["north", "northeast", "east", "southeast", "south",
            "southwest", "west", "northwest"], ["up", "down"]]
            position = STANDING
            add_adjective("living")


    def heart_beat(self, ) -> None:
            stats::heart_beat()
            combat::heart_beat()


    def query_pronoun(self, ) -> str:
            return gender::query_pronoun()


    def query_possessive(self, ) -> str:
            return gender::query_possessive()


    def query_objective(self, ) -> str:
            return gender::query_objective()


    def query_burden(self, ) -> int:
            return _liv_data->burden


    def calc_burden(self, ) -> None:
            int new_handicap
            int burden
            object thing
            mapping hands
            _liv_data->burden_call = 0
            update_loc_weight()
            burden = query_loc_weight()
            foreach(thing in query_wearing())
            burden -= (int)thing.query_complete_weight() / 2
            hands = ([ ])
            foreach(thing in query_holding())
            if(objectp(thing))
            hands[thing]++
            foreach(thing in keys(hands))
            burden += (int)thing.query_complete_weight() / hands[thing]
            if(!query_max_weight()) {
            self.reset_carry_cap()
            _liv_data->burden = 50
            } else
            _liv_data->burden = (100 * burden) / query_max_weight()
            new_handicap = (_liv_data->burden / 25) - 1
            if(new_handicap < 0)
            new_handicap = 0
            if ( _liv_data->handicap != new_handicap ) {
            adjust_bonus_dex( _liv_data->handicap - new_handicap )
            _liv_data->handicap = new_handicap


    def burden_string(self, ) -> str:
            switch (_liv_data->handicap) {
            case 0 :
            return "unburdened"
            case 1 :
            return "burdened"
            case 2 :
            return "heavily burdened"
            case 3 :
            return "very heavily burdened"
            default :
            return "incredibly heavily burdened"


    def living_commands(self, ) -> None:
            #if efun_defined(add_action)
            add_action( "exit_command", "*", 1 )
            #endif


    def eat_this(self, food: MudObject) -> None:
            self.bypass_queue()
            command( "eat " + file_name( food ) )


    def test_add(self, ob: MudObject, flag: int) -> int:
            if(sizeof(all_inventory(self)) > query_max_items())
            return 0
            return !flag


    def test_remove(self, ob: MudObject, flag: int, dest: Any) -> int:
            object thing
            if ( flag ) {
            return 0


    def adjust_al(self, number: int) -> int:
            alignment += number
            if ( alignment < -MAX_AL ) {
            alignment = -MAX_AL


    def adjust_alignment(self, number: int) -> int:
            int change
            change = - (number + alignment/5)
            change /= 20
            return adjust_al( change )


    def align_string(self, ) -> str:
            switch ( alignment ) {
            case -MAX_AL .. -5001 : return "extremely good"; break
            case -5000 .. -2501 : return "very good"; break
            case -2500 .. -1251 : return "quite good"; break
            case -1250 .. -601 : return "good"; break
            case -600 .. -301 : return "barely good"; break
            case -300 .. 300 : return "neutral"; break
            case 301 .. 600 : return "barely evil"; break
            case 601 .. 1250 : return "evil"; break
            case 1251 .. 2500 : return "quite evil"; break
            case 2501 .. 5000 : return "very evil"; break
            default : return "extremely evil"; break


    def set_msgin(self, str: str) -> int:
            if (strsrch(str, "$N") == -1 || strsrch(str, "$F") == -1) {
            return 0


    def set_msgout(self, str: str) -> int:
            if (strsrch(str, "$N") == -1 || strsrch(str, "$T") == -1) {
            return 0


    def set_mmsgin(self, str: str) -> int:
            if (strsrch(str, "$N") == -1) {
            return 0


    def set_mmsgout(self, str: str) -> int:
            if (strsrch(str, "$N") == -1) {
            return 0


    def find_rel(self, word: str, from: int) -> str:
            int i
            i = facing[ 1 ] .index( word) if  word in facing[ 1 ]  else -1
            if ( i != -1 ) {
            i = ( i + 8 - facing[ 0 ] ) % 8
            return REL_DIRS[ 3 * i + from ]


    def find_abs(self, word: str) -> str:
            int i
            i = REL_DIRS .index( word) if  word in REL_DIRS  else -1
            if ( i != -1 ) {
            i = ( i / 3 + facing[ 0 ]) % 8
            return facing[ 1 ][ i ]


    def reorient_rel(self, word: str) -> str:
            int i
            i = REL_DIRS .index( word) if  word in REL_DIRS  else -1
            if ( i != -1 ) {
            i = ( i / 3 + facing[ 0 ] ) % 8
            facing[ 0 ] = i
            return facing[ 1 ][ i ]


    def reorient_abs(self, verb: str) -> None:
            if ((ABS_FACING)[verb]) {
            facing[0] = (ABS_FACING)[verb] % 8


    def room_look(self, ) -> int:
            if ( query_property( UNKNOWN_MOVE ) || !( interactive( self ) ||
            self.query_slave() ) )
            return 0
            if(!mapp(verbose))
            verbose = ([ ])
            if(verbose && verbose["look"]) {
            self.ignore_from_history( "look" )
            self.bypass_queue()
            command( "look" )
            } else {
            self.ignore_from_history( "glance" )
            self.bypass_queue()
            command( "glance" )


    def query_verbose(self, type: str) -> int:
            if(!verbose || !mapp(verbose)) {
            verbose = ([ ])


    def set_verbose(self, type: str, val: int) -> None:
            if(!verbose || !mapp(verbose)) {
            verbose = ([ ])


    def become_flummoxed(self, ) -> None:
            int will
            will = query_int() * query_wis()
            if ( will < random( WILL_POWER ) )
            self.interrupt_ritual()
            if ( will < random( WILL_POWER ) )
            self.interrupt_spell()
            if ( will < random( WILL_POWER ) )
            self.stop_all_fight()


    def run_away(self, ) -> int:
            int i
            object old_env
            mixed *direcs
            direcs = (mixed *)environment()->query_dest_dir(self)
            old_env = environment()
            while ( sizeof( direcs ) ) {
            i = random( sizeof( direcs ) / 2 ) * 2
            if ( exit_command( direcs[i] ) ) {
            event( old_env, "run_away", direcs[ i ], direcs[ i + 1 ] )
            return 1


    def add_follower(self, ob: MudObject) -> int:
            if (ob == self) {
            return 0


    def remove_follower(self, ob: MudObject) -> int:
            int i
            i = _liv_data->followers.index(ob) if ob in _liv_data->followers else -1
            if (i != -1) {
            _liv_data->followers = delete(_liv_data->followers, i, 1)
            return 1


    def check_doing_follow(self, thing: MudObject, verb: str, special: str) -> int:
            return 1


    def query_current_room(self, {: Any) -> MudObject:
            mixed *query_followers() { return copy(_liv_data->followers - [0]); }
            varargs void adjust_money(mixed amt, string type) {
            return money::adjust_money(amt, type)


    def query_money(self, type: str) -> int:
            return money::query_money(type)


    def do_burden_call(self, ) -> None:
            if(_liv_data->burden_call)
            remove_asyncio.create_task(self._liv_data->burden_call)
            _liv_data->burden_call = asyncio.create_task(self."calc_burden", 1)


    def query_burden_limit(self, ) -> int:
            if (self.query_creator()) {
            return MAX_CREATOR_INVEN
            } else {
            return MAX_INVEN


    def event_enter(self, thing: MudObject, mess: str, from: MudObject) -> None:
            if(environment( thing ) == self) {
            do_burden_call()
            if(sizeof(all_inventory()) > query_burden_limit() ) {
            _liv_data->to_drop += [thing]
            remove_asyncio.create_task(self."test_number_of_items")
            asyncio.create_task(self."test_number_of_items", 5 + random(5))


    def event_exit(self, thing: MudObject, mess: str, to: MudObject) -> None:
            if(environment(thing) == self) {
            do_burden_call()


    def test_number_of_items(self, ) -> None:
            int how_many
            object thing, *things, *dropped
            things = all_inventory() - query_armours() - query_holding()
            how_many = sizeof(things) - query_burden_limit()
            if ( how_many < 1 ) {
            return


    def force_burden_recalculate(self, ) -> None:
            do_burden_call()
            remove_asyncio.create_task(self."test_number_of_items")
            asyncio.create_task(self."test_number_of_items", 5 + random(5))


    def attack_by(self, ob: MudObject) -> int:
            return_to_default_position(0)
            return ::attack_by(ob)


    def attack_ob(self, ob: MudObject) -> int:
            return_to_default_position(0)
            return ::attack_ob(ob)


    def set_always_use_default_position(self, flag: int) -> None:
            always_use_default_position = flag


    def query_always_use_default_position(self, ) -> int:
            return always_use_default_position


    def query_default_position(self, ) -> str:
            mixed pos
            if (stringp(default_position) &&
            default_position.query_position_command()) {
            pos = default_position
            } else if (pointerp(default_position) &&
            (sizeof(default_position) == POSITION_MESS_SIZE ||
            sizeof(default_position) == POSITION_ONLY_TYPE_SIZE)) {
            pos = default_position
            } else if (functionp(default_position)) {
            pos = default_position


    def set_default_position(self, str: Any) -> None:
            if (stringp(str) && str.query_position_command() && str != STANDING_CMD) {
            default_position = str
            } else if (!str || str == STANDING_CMD) {
            default_position = 0
            } else if (pointerp(str) && (sizeof(str) == POSITION_ONLY_TYPE_SIZE ||
            sizeof(str) == POSITION_MESS_SIZE)) {
            default_position = str
            } else if (functionp(str)) {
            default_position = str


    def return_to_default_position(self, leaving: int) -> None:
            mixed pos
            if (query_always_use_default_position()) {
            pos = query_default_position()
            } else {
            pos = 0
            if (environment()) {
            pos = environment()->query_default_position(self)


    def set_position(self, name: str) -> None:
            position = name


    def query_position(self, ) -> str:
            return position


    def set_position_on(self, ob: Any) -> None:
            if (!position_on) {
            position_on = allocate(POSITION_ARRAY_SIZE)


    def set_position_multiple(self, mult: int) -> None:
            if (!position_on) {
            position_on = allocate(POSITION_ARRAY_SIZE)


    def query_position_multiple(self, ) -> int:
            if (!position_on) {
            return 0


    def set_position_type(self, type: str) -> None:
            if (!position_on) {
            position_on = allocate(POSITION_ARRAY_SIZE)


    def query_position_type(self, ) -> str:
            if (!position_on ||
            !position_on[POS_TYPE]) {
            return "on"


    def query_position_on(self, ) -> MudObject:
            if (!position_on) {
            return 0


    def query_position_on_short(self, ) -> str:
            if (!position_on || !position_on[POS_ON_OBJECT]) {
            return ""


    def query_position_long(self, ) -> str:
            if (position != STANDING || position_on) {
            if (position_on) {
            return query_pronoun() + " is " + query_position_type() + " "+
            query_position_on_short()+".\n"


    def query_position_short(self, ) -> str:
            if (!position_on ||
            !position_on[POS_ON_OBJECT]) {
            return position


    def can_find_match_reference_inside_object(self, thing: MudObject, looker: MudObject) -> int:
            if (query_wearing_hidden(looker, 0.index(thing) if thing in query_wearing_hidden(looker, 0 else -1) != -1) {
            return 0


    def query_deity_favour(self, god: str) -> int:
            if ( !mapp( deity_favour ) )
            return 0
            if ( !undefinedp( deity_favour[ god ] ) )
            return 0
            return deity_favour[ god ]


    def adjust_deity_favour(self, god: str, amount: int) -> None:
            if ( !mapp( deity_favour ) )
            deity_favour = ([ ])
            if ( !undefinedp( deity_favour[ god ] ) )
            deity_favour[ god ] = amount
            deity_favour[ god ] += amount
            if ( deity_favour[ god ] > MAX_FAVOUR )
            deity_favour[ god ] = MAX_FAVOUR
            if ( deity_favour[ god ] < -MAX_FAVOUR )
            deity_favour[ god ] = -MAX_FAVOUR
            return


    def __init__(self):
            self._liv_data = new(class living_data)
            self._messages = new(class messages)
            self._messages->msgin = "$N arrive$s from $F."
            self._messages->msgout = "$N leave$s $T."
            self._messages->mmsgin = "$N appear$s out of the ground."
            self._messages->mmsgout = "$N disappear$s in a puff of smoke."
            self._liv_data->followers = []
            self.verbose = ([ ])
            self._liv_data->to_drop = []
            self.verbose[t] = 1


    def __init__(self):
            self._liv_data = new(class living_data)
            self._messages = new(class messages)
            self._messages->msgin = "$N arrive$s from $F."
            self._messages->msgout = "$N leave$s $T."
            self._messages->mmsgin = "$N appear$s out of the ground."
            self._messages->mmsgout = "$N disappear$s in a puff of smoke."
            self._liv_data->followers = []
            self.verbose = ([ ])
            self._liv_data->to_drop = []
            self.verbose[t] = 1
            facing = [0, ["north", "northeast", "east", "southeast", "south",
            "southwest", "west", "northwest"], ["up", "down"]]
            position = STANDING
            add_adjective("living")


    def heart_beat(self, ) -> None:
            stats::heart_beat()
            combat::heart_beat()


    def query_pronoun(self, ) -> str:
            return gender::query_pronoun()


    def query_possessive(self, ) -> str:
            return gender::query_possessive()


    def query_objective(self, ) -> str:
            return gender::query_objective()


    def query_burden(self, ) -> int:
            return _liv_data->burden


    def calc_burden(self, ) -> None:
            int new_handicap
            int burden
            object thing
            mapping hands
            _liv_data->burden_call = 0
            update_loc_weight()
            burden = query_loc_weight()
            foreach(thing in query_wearing())
            burden -= (int)thing.query_complete_weight() / 2
            hands = ([ ])
            foreach(thing in query_holding())
            if(objectp(thing))
            hands[thing]++
            foreach(thing in keys(hands))
            burden += (int)thing.query_complete_weight() / hands[thing]
            if(!query_max_weight()) {
            self.reset_carry_cap()
            _liv_data->burden = 50
            } else
            _liv_data->burden = (100 * burden) / query_max_weight()
            new_handicap = (_liv_data->burden / 25) - 1
            if(new_handicap < 0)
            new_handicap = 0
            if ( _liv_data->handicap != new_handicap ) {
            adjust_bonus_dex( _liv_data->handicap - new_handicap )
            _liv_data->handicap = new_handicap


    def burden_string(self, ) -> str:
            switch (_liv_data->handicap) {
            case 0 :
            return "unburdened"
            case 1 :
            return "burdened"
            case 2 :
            return "heavily burdened"
            case 3 :
            return "very heavily burdened"
            default :
            return "incredibly heavily burdened"


    def living_commands(self, ) -> None:
            #if efun_defined(add_action)
            add_action( "exit_command", "*", 1 )
            #endif


    def eat_this(self, food: MudObject) -> None:
            self.bypass_queue()
            command( "eat " + file_name( food ) )


    def test_add(self, ob: MudObject, flag: int) -> int:
            if(sizeof(all_inventory(self)) > query_max_items())
            return 0
            return !flag


    def test_remove(self, ob: MudObject, flag: int, dest: Any) -> int:
            object thing
            if ( flag ) {
            return 0


    def adjust_al(self, number: int) -> int:
            alignment += number
            if ( alignment < -MAX_AL ) {
            alignment = -MAX_AL


    def adjust_alignment(self, number: int) -> int:
            int change
            change = - (number + alignment/5)
            change /= 20
            return adjust_al( change )


    def align_string(self, ) -> str:
            switch ( alignment ) {
            case -MAX_AL .. -5001 : return "extremely good"; break
            case -5000 .. -2501 : return "very good"; break
            case -2500 .. -1251 : return "quite good"; break
            case -1250 .. -601 : return "good"; break
            case -600 .. -301 : return "barely good"; break
            case -300 .. 300 : return "neutral"; break
            case 301 .. 600 : return "barely evil"; break
            case 601 .. 1250 : return "evil"; break
            case 1251 .. 2500 : return "quite evil"; break
            case 2501 .. 5000 : return "very evil"; break
            default : return "extremely evil"; break


    def set_msgin(self, str: str) -> int:
            if (strsrch(str, "$N") == -1 || strsrch(str, "$F") == -1) {
            return 0


    def set_msgout(self, str: str) -> int:
            if (strsrch(str, "$N") == -1 || strsrch(str, "$T") == -1) {
            return 0


    def set_mmsgin(self, str: str) -> int:
            if (strsrch(str, "$N") == -1) {
            return 0


    def set_mmsgout(self, str: str) -> int:
            if (strsrch(str, "$N") == -1) {
            return 0


    def find_rel(self, word: str, from: int) -> str:
            int i
            i = facing[ 1 ] .index( word) if  word in facing[ 1 ]  else -1
            if ( i != -1 ) {
            i = ( i + 8 - facing[ 0 ] ) % 8
            return REL_DIRS[ 3 * i + from ]


    def find_abs(self, word: str) -> str:
            int i
            i = REL_DIRS .index( word) if  word in REL_DIRS  else -1
            if ( i != -1 ) {
            i = ( i / 3 + facing[ 0 ]) % 8
            return facing[ 1 ][ i ]


    def reorient_rel(self, word: str) -> str:
            int i
            i = REL_DIRS .index( word) if  word in REL_DIRS  else -1
            if ( i != -1 ) {
            i = ( i / 3 + facing[ 0 ] ) % 8
            facing[ 0 ] = i
            return facing[ 1 ][ i ]


    def reorient_abs(self, verb: str) -> None:
            if ((ABS_FACING)[verb]) {
            facing[0] = (ABS_FACING)[verb] % 8


    def room_look(self, ) -> int:
            if ( query_property( UNKNOWN_MOVE ) || !( interactive( self ) ||
            self.query_slave() ) )
            return 0
            if(!mapp(verbose))
            verbose = ([ ])
            if(verbose && verbose["look"]) {
            self.ignore_from_history( "look" )
            self.bypass_queue()
            command( "look" )
            } else {
            self.ignore_from_history( "glance" )
            self.bypass_queue()
            command( "glance" )


    def query_verbose(self, type: str) -> int:
            if(!verbose || !mapp(verbose)) {
            verbose = ([ ])


    def set_verbose(self, type: str, val: int) -> None:
            if(!verbose || !mapp(verbose)) {
            verbose = ([ ])


    def become_flummoxed(self, ) -> None:
            int will
            will = query_int() * query_wis()
            if ( will < random( WILL_POWER ) )
            self.interrupt_ritual()
            if ( will < random( WILL_POWER ) )
            self.interrupt_spell()
            if ( will < random( WILL_POWER ) )
            self.stop_all_fight()


    def run_away(self, ) -> int:
            int i
            object old_env
            mixed *direcs
            direcs = (mixed *)environment()->query_dest_dir(self)
            old_env = environment()
            while ( sizeof( direcs ) ) {
            i = random( sizeof( direcs ) / 2 ) * 2
            if ( exit_command( direcs[i] ) ) {
            event( old_env, "run_away", direcs[ i ], direcs[ i + 1 ] )
            return 1


    def add_follower(self, ob: MudObject) -> int:
            if (ob == self) {
            return 0


    def remove_follower(self, ob: MudObject) -> int:
            int i
            i = _liv_data->followers.index(ob) if ob in _liv_data->followers else -1
            if (i != -1) {
            _liv_data->followers = delete(_liv_data->followers, i, 1)
            return 1


    def check_doing_follow(self, thing: MudObject, verb: str, special: str) -> int:
            return 1


    def query_current_room(self, {: Any) -> MudObject:
            mixed *query_followers() { return copy(_liv_data->followers - [0]); }
            varargs void adjust_money(mixed amt, string type) {
            return money::adjust_money(amt, type)


    def query_money(self, type: str) -> int:
            return money::query_money(type)


    def do_burden_call(self, ) -> None:
            if(_liv_data->burden_call)
            remove_asyncio.create_task(self._liv_data->burden_call)
            _liv_data->burden_call = asyncio.create_task(self."calc_burden", 1)


    def query_burden_limit(self, ) -> int:
            if (self.query_creator()) {
            return MAX_CREATOR_INVEN
            } else {
            return MAX_INVEN


    def event_enter(self, thing: MudObject, mess: str, from: MudObject) -> None:
            if(environment( thing ) == self) {
            do_burden_call()
            if(sizeof(all_inventory()) > query_burden_limit() ) {
            _liv_data->to_drop += [thing]
            remove_asyncio.create_task(self."test_number_of_items")
            asyncio.create_task(self."test_number_of_items", 5 + random(5))


    def event_exit(self, thing: MudObject, mess: str, to: MudObject) -> None:
            if(environment(thing) == self) {
            do_burden_call()


    def test_number_of_items(self, ) -> None:
            int how_many
            object thing, *things, *dropped
            things = all_inventory() - query_armours() - query_holding()
            how_many = sizeof(things) - query_burden_limit()
            if ( how_many < 1 ) {
            return


    def force_burden_recalculate(self, ) -> None:
            do_burden_call()
            remove_asyncio.create_task(self."test_number_of_items")
            asyncio.create_task(self."test_number_of_items", 5 + random(5))


    def attack_by(self, ob: MudObject) -> int:
            return_to_default_position(0)
            return ::attack_by(ob)


    def attack_ob(self, ob: MudObject) -> int:
            return_to_default_position(0)
            return ::attack_ob(ob)


    def set_always_use_default_position(self, flag: int) -> None:
            always_use_default_position = flag


    def query_always_use_default_position(self, ) -> int:
            return always_use_default_position


    def query_default_position(self, ) -> str:
            mixed pos
            if (stringp(default_position) &&
            default_position.query_position_command()) {
            pos = default_position
            } else if (pointerp(default_position) &&
            (sizeof(default_position) == POSITION_MESS_SIZE ||
            sizeof(default_position) == POSITION_ONLY_TYPE_SIZE)) {
            pos = default_position
            } else if (functionp(default_position)) {
            pos = default_position


    def set_default_position(self, str: Any) -> None:
            if (stringp(str) && str.query_position_command() && str != STANDING_CMD) {
            default_position = str
            } else if (!str || str == STANDING_CMD) {
            default_position = 0
            } else if (pointerp(str) && (sizeof(str) == POSITION_ONLY_TYPE_SIZE ||
            sizeof(str) == POSITION_MESS_SIZE)) {
            default_position = str
            } else if (functionp(str)) {
            default_position = str


    def return_to_default_position(self, leaving: int) -> None:
            mixed pos
            if (query_always_use_default_position()) {
            pos = query_default_position()
            } else {
            pos = 0
            if (environment()) {
            pos = environment()->query_default_position(self)


    def set_position(self, name: str) -> None:
            position = name


    def query_position(self, ) -> str:
            return position


    def set_position_on(self, ob: Any) -> None:
            if (!position_on) {
            position_on = allocate(POSITION_ARRAY_SIZE)


    def set_position_multiple(self, mult: int) -> None:
            if (!position_on) {
            position_on = allocate(POSITION_ARRAY_SIZE)


    def query_position_multiple(self, ) -> int:
            if (!position_on) {
            return 0


    def set_position_type(self, type: str) -> None:
            if (!position_on) {
            position_on = allocate(POSITION_ARRAY_SIZE)


    def query_position_type(self, ) -> str:
            if (!position_on ||
            !position_on[POS_TYPE]) {
            return "on"


    def query_position_on(self, ) -> MudObject:
            if (!position_on) {
            return 0


    def query_position_on_short(self, ) -> str:
            if (!position_on || !position_on[POS_ON_OBJECT]) {
            return ""


    def query_position_long(self, ) -> str:
            if (position != STANDING || position_on) {
            if (position_on) {
            return query_pronoun() + " is " + query_position_type() + " "+
            query_position_on_short()+".\n"


    def query_position_short(self, ) -> str:
            if (!position_on ||
            !position_on[POS_ON_OBJECT]) {
            return position


    def can_find_match_reference_inside_object(self, thing: MudObject, looker: MudObject) -> int:
            if (query_wearing_hidden(looker, 0.index(thing) if thing in query_wearing_hidden(looker, 0 else -1) != -1) {
            return 0


    def query_deity_favour(self, god: str) -> int:
            if ( !mapp( deity_favour ) )
            return 0
            if ( !undefinedp( deity_favour[ god ] ) )
            return 0
            return deity_favour[ god ]


    def adjust_deity_favour(self, god: str, amount: int) -> None:
            if ( !mapp( deity_favour ) )
            deity_favour = ([ ])
            if ( !undefinedp( deity_favour[ god ] ) )
            deity_favour[ god ] = amount
            deity_favour[ god ] += amount
            if ( deity_favour[ god ] > MAX_FAVOUR )
            deity_favour[ god ] = MAX_FAVOUR
            if ( deity_favour[ god ] < -MAX_FAVOUR )
            deity_favour[ god ] = -MAX_FAVOUR
            return


    def __init__(self):
            self._liv_data = new(class living_data)
            self._messages = new(class messages)
            self._messages->msgin = "$N arrive$s from $F."
            self._messages->msgout = "$N leave$s $T."
            self._messages->mmsgin = "$N appear$s out of the ground."
            self._messages->mmsgout = "$N disappear$s in a puff of smoke."
            self._liv_data->followers = []
            self.verbose = ([ ])
            self._liv_data->to_drop = []
            self.verbose[t] = 1


    def __init__(self):
            self._liv_data = new(class living_data)
            self._messages = new(class messages)
            self._messages->msgin = "$N arrive$s from $F."
            self._messages->msgout = "$N leave$s $T."
            self._messages->mmsgin = "$N appear$s out of the ground."
            self._messages->mmsgout = "$N disappear$s in a puff of smoke."
            self._liv_data->followers = []
            self.verbose = ([ ])
            self._liv_data->to_drop = []
            self.verbose[t] = 1
            facing = [0, ["north", "northeast", "east", "southeast", "south",
            "southwest", "west", "northwest"], ["up", "down"]]
            position = STANDING
            add_adjective("living")


    def heart_beat(self, ) -> None:
            stats::heart_beat()
            combat::heart_beat()


    def query_pronoun(self, ) -> str:
            return gender::query_pronoun()


    def query_possessive(self, ) -> str:
            return gender::query_possessive()


    def query_objective(self, ) -> str:
            return gender::query_objective()


    def query_burden(self, ) -> int:
            return _liv_data->burden


    def calc_burden(self, ) -> None:
            int new_handicap
            int burden
            object thing
            mapping hands
            _liv_data->burden_call = 0
            update_loc_weight()
            burden = query_loc_weight()
            foreach(thing in query_wearing())
            burden -= (int)thing.query_complete_weight() / 2
            hands = ([ ])
            foreach(thing in query_holding())
            if(objectp(thing))
            hands[thing]++
            foreach(thing in keys(hands))
            burden += (int)thing.query_complete_weight() / hands[thing]
            if(!query_max_weight()) {
            self.reset_carry_cap()
            _liv_data->burden = 50
            } else
            _liv_data->burden = (100 * burden) / query_max_weight()
            new_handicap = (_liv_data->burden / 25) - 1
            if(new_handicap < 0)
            new_handicap = 0
            if ( _liv_data->handicap != new_handicap ) {
            adjust_bonus_dex( _liv_data->handicap - new_handicap )
            _liv_data->handicap = new_handicap


    def burden_string(self, ) -> str:
            switch (_liv_data->handicap) {
            case 0 :
            return "unburdened"
            case 1 :
            return "burdened"
            case 2 :
            return "heavily burdened"
            case 3 :
            return "very heavily burdened"
            default :
            return "incredibly heavily burdened"


    def living_commands(self, ) -> None:
            #if efun_defined(add_action)
            add_action( "exit_command", "*", 1 )
            #endif


    def eat_this(self, food: MudObject) -> None:
            self.bypass_queue()
            command( "eat " + file_name( food ) )


    def test_add(self, ob: MudObject, flag: int) -> int:
            if(sizeof(all_inventory(self)) > query_max_items())
            return 0
            return !flag


    def test_remove(self, ob: MudObject, flag: int, dest: Any) -> int:
            object thing
            if ( flag ) {
            return 0


    def adjust_al(self, number: int) -> int:
            alignment += number
            if ( alignment < -MAX_AL ) {
            alignment = -MAX_AL


    def adjust_alignment(self, number: int) -> int:
            int change
            change = - (number + alignment/5)
            change /= 20
            return adjust_al( change )


    def align_string(self, ) -> str:
            switch ( alignment ) {
            case -MAX_AL .. -5001 : return "extremely good"; break
            case -5000 .. -2501 : return "very good"; break
            case -2500 .. -1251 : return "quite good"; break
            case -1250 .. -601 : return "good"; break
            case -600 .. -301 : return "barely good"; break
            case -300 .. 300 : return "neutral"; break
            case 301 .. 600 : return "barely evil"; break
            case 601 .. 1250 : return "evil"; break
            case 1251 .. 2500 : return "quite evil"; break
            case 2501 .. 5000 : return "very evil"; break
            default : return "extremely evil"; break


    def set_msgin(self, str: str) -> int:
            if (strsrch(str, "$N") == -1 || strsrch(str, "$F") == -1) {
            return 0


    def set_msgout(self, str: str) -> int:
            if (strsrch(str, "$N") == -1 || strsrch(str, "$T") == -1) {
            return 0


    def set_mmsgin(self, str: str) -> int:
            if (strsrch(str, "$N") == -1) {
            return 0


    def set_mmsgout(self, str: str) -> int:
            if (strsrch(str, "$N") == -1) {
            return 0


    def find_rel(self, word: str, from: int) -> str:
            int i
            i = facing[ 1 ] .index( word) if  word in facing[ 1 ]  else -1
            if ( i != -1 ) {
            i = ( i + 8 - facing[ 0 ] ) % 8
            return REL_DIRS[ 3 * i + from ]


    def find_abs(self, word: str) -> str:
            int i
            i = REL_DIRS .index( word) if  word in REL_DIRS  else -1
            if ( i != -1 ) {
            i = ( i / 3 + facing[ 0 ]) % 8
            return facing[ 1 ][ i ]


    def reorient_rel(self, word: str) -> str:
            int i
            i = REL_DIRS .index( word) if  word in REL_DIRS  else -1
            if ( i != -1 ) {
            i = ( i / 3 + facing[ 0 ] ) % 8
            facing[ 0 ] = i
            return facing[ 1 ][ i ]


    def reorient_abs(self, verb: str) -> None:
            if ((ABS_FACING)[verb]) {
            facing[0] = (ABS_FACING)[verb] % 8


    def room_look(self, ) -> int:
            if ( query_property( UNKNOWN_MOVE ) || !( interactive( self ) ||
            self.query_slave() ) )
            return 0
            if(!mapp(verbose))
            verbose = ([ ])
            if(verbose && verbose["look"]) {
            self.ignore_from_history( "look" )
            self.bypass_queue()
            command( "look" )
            } else {
            self.ignore_from_history( "glance" )
            self.bypass_queue()
            command( "glance" )


    def query_verbose(self, type: str) -> int:
            if(!verbose || !mapp(verbose)) {
            verbose = ([ ])


    def set_verbose(self, type: str, val: int) -> None:
            if(!verbose || !mapp(verbose)) {
            verbose = ([ ])


    def become_flummoxed(self, ) -> None:
            int will
            will = query_int() * query_wis()
            if ( will < random( WILL_POWER ) )
            self.interrupt_ritual()
            if ( will < random( WILL_POWER ) )
            self.interrupt_spell()
            if ( will < random( WILL_POWER ) )
            self.stop_all_fight()


    def run_away(self, ) -> int:
            int i
            object old_env
            mixed *direcs
            direcs = (mixed *)environment()->query_dest_dir(self)
            old_env = environment()
            while ( sizeof( direcs ) ) {
            i = random( sizeof( direcs ) / 2 ) * 2
            if ( exit_command( direcs[i] ) ) {
            event( old_env, "run_away", direcs[ i ], direcs[ i + 1 ] )
            return 1


    def add_follower(self, ob: MudObject) -> int:
            if (ob == self) {
            return 0


    def remove_follower(self, ob: MudObject) -> int:
            int i
            i = _liv_data->followers.index(ob) if ob in _liv_data->followers else -1
            if (i != -1) {
            _liv_data->followers = delete(_liv_data->followers, i, 1)
            return 1


    def check_doing_follow(self, thing: MudObject, verb: str, special: str) -> int:
            return 1


    def query_current_room(self, {: Any) -> MudObject:
            mixed *query_followers() { return copy(_liv_data->followers - [0]); }
            varargs void adjust_money(mixed amt, string type) {
            return money::adjust_money(amt, type)


    def query_money(self, type: str) -> int:
            return money::query_money(type)


    def do_burden_call(self, ) -> None:
            if(_liv_data->burden_call)
            remove_asyncio.create_task(self._liv_data->burden_call)
            _liv_data->burden_call = asyncio.create_task(self."calc_burden", 1)


    def query_burden_limit(self, ) -> int:
            if (self.query_creator()) {
            return MAX_CREATOR_INVEN
            } else {
            return MAX_INVEN


    def event_enter(self, thing: MudObject, mess: str, from: MudObject) -> None:
            if(environment( thing ) == self) {
            do_burden_call()
            if(sizeof(all_inventory()) > query_burden_limit() ) {
            _liv_data->to_drop += [thing]
            remove_asyncio.create_task(self."test_number_of_items")
            asyncio.create_task(self."test_number_of_items", 5 + random(5))


    def event_exit(self, thing: MudObject, mess: str, to: MudObject) -> None:
            if(environment(thing) == self) {
            do_burden_call()


    def test_number_of_items(self, ) -> None:
            int how_many
            object thing, *things, *dropped
            things = all_inventory() - query_armours() - query_holding()
            how_many = sizeof(things) - query_burden_limit()
            if ( how_many < 1 ) {
            return


    def force_burden_recalculate(self, ) -> None:
            do_burden_call()
            remove_asyncio.create_task(self."test_number_of_items")
            asyncio.create_task(self."test_number_of_items", 5 + random(5))


    def attack_by(self, ob: MudObject) -> int:
            return_to_default_position(0)
            return ::attack_by(ob)


    def attack_ob(self, ob: MudObject) -> int:
            return_to_default_position(0)
            return ::attack_ob(ob)


    def set_always_use_default_position(self, flag: int) -> None:
            always_use_default_position = flag


    def query_always_use_default_position(self, ) -> int:
            return always_use_default_position


    def query_default_position(self, ) -> str:
            mixed pos
            if (stringp(default_position) &&
            default_position.query_position_command()) {
            pos = default_position
            } else if (pointerp(default_position) &&
            (sizeof(default_position) == POSITION_MESS_SIZE ||
            sizeof(default_position) == POSITION_ONLY_TYPE_SIZE)) {
            pos = default_position
            } else if (functionp(default_position)) {
            pos = default_position


    def set_default_position(self, str: Any) -> None:
            if (stringp(str) && str.query_position_command() && str != STANDING_CMD) {
            default_position = str
            } else if (!str || str == STANDING_CMD) {
            default_position = 0
            } else if (pointerp(str) && (sizeof(str) == POSITION_ONLY_TYPE_SIZE ||
            sizeof(str) == POSITION_MESS_SIZE)) {
            default_position = str
            } else if (functionp(str)) {
            default_position = str


    def return_to_default_position(self, leaving: int) -> None:
            mixed pos
            if (query_always_use_default_position()) {
            pos = query_default_position()
            } else {
            pos = 0
            if (environment()) {
            pos = environment()->query_default_position(self)


    def set_position(self, name: str) -> None:
            position = name


    def query_position(self, ) -> str:
            return position


    def set_position_on(self, ob: Any) -> None:
            if (!position_on) {
            position_on = allocate(POSITION_ARRAY_SIZE)


    def set_position_multiple(self, mult: int) -> None:
            if (!position_on) {
            position_on = allocate(POSITION_ARRAY_SIZE)


    def query_position_multiple(self, ) -> int:
            if (!position_on) {
            return 0


    def set_position_type(self, type: str) -> None:
            if (!position_on) {
            position_on = allocate(POSITION_ARRAY_SIZE)


    def query_position_type(self, ) -> str:
            if (!position_on ||
            !position_on[POS_TYPE]) {
            return "on"


    def query_position_on(self, ) -> MudObject:
            if (!position_on) {
            return 0


    def query_position_on_short(self, ) -> str:
            if (!position_on || !position_on[POS_ON_OBJECT]) {
            return ""


    def query_position_long(self, ) -> str:
            if (position != STANDING || position_on) {
            if (position_on) {
            return query_pronoun() + " is " + query_position_type() + " "+
            query_position_on_short()+".\n"


    def query_position_short(self, ) -> str:
            if (!position_on ||
            !position_on[POS_ON_OBJECT]) {
            return position


    def can_find_match_reference_inside_object(self, thing: MudObject, looker: MudObject) -> int:
            if (query_wearing_hidden(looker, 0.index(thing) if thing in query_wearing_hidden(looker, 0 else -1) != -1) {
            return 0


    def query_deity_favour(self, god: str) -> int:
            if ( !mapp( deity_favour ) )
            return 0
            if ( !undefinedp( deity_favour[ god ] ) )
            return 0
            return deity_favour[ god ]


    def adjust_deity_favour(self, god: str, amount: int) -> None:
            if ( !mapp( deity_favour ) )
            deity_favour = ([ ])
            if ( !undefinedp( deity_favour[ god ] ) )
            deity_favour[ god ] = amount
            deity_favour[ god ] += amount
            if ( deity_favour[ god ] > MAX_FAVOUR )
            deity_favour[ god ] = MAX_FAVOUR
            if ( deity_favour[ god ] < -MAX_FAVOUR )
            deity_favour[ god ] = -MAX_FAVOUR
            return


    def setup_shadow(self, ob: MudObject) -> None:
            shadow(ob,1)
            npc = ob


    def __init__(self):
            self.mon_actions = []


    def do_shadow(self, ) -> None:
            int i
            object ob
            string fname
            self.shadow_death()
            fname = (string)MONSTER_HAND.query_shadow_name()
            rm(fname+".c")
            for (i=0;i<sizeof(mon_actions);i+=2)
            write_file(fname+".c",
            "inherit \"/std/trigger/"+mon_actions[i]+"\";\n")
            write_file(fname+".c", read_file("/std/living/mon-shadow.c"))
            ob = clone_object(fname)
            ob.setup_shadow(self)
            rm(fname+".c")


    def remove_trigger(self, name: str) -> int:
            int i
            if ((i=mon_actions.index(name) if name in mon_actions else -1) == -1)
            return 0
            mon_actions = delete(mon_actions, i, 2)
            if (!sizeof(mon_actions))
            self.shadow_death()
            else
            do_shadow()
            return 1


    def remove_triggered_action(self, trigger: str, name: str) -> int:
            int i, j
            if ((i=mon_actions.index(trigger) if trigger in mon_actions else -1) == -1)
            return 0
            if ((j=mon_actions[i+1].index(name) if name in mon_actions[i+1] else -1) == -1)
            return 0
            mon_actions[i+1] = delete(mon_actions[i+1], i, 2)
            if (!sizeof(mon_actions[i+1]))
            remove_trigger(trigger)
            return 1


    def query_money_object(self, force: int) -> MudObject:
            object money
            money = present( MONEY_ALIAS, self )
            if (!money && force) {
            money = MONEY_VAULT.get_money_ob()
            money.move( self )


    def set_money_array(self, new_array: Any) -> None:
            query_money_object(1)->set_money_array( new_array )


    def query_value(self, ) -> int:
            object money
            money = query_money_object(0)
            if ( ! money ) {
            return 0


    def query_value_in(self, where: str) -> int:
            object money
            money = query_money_object(0)
            if ( ! money ) {
            return 0


    def query_money(self, type: str) -> int:
            object money
            money = query_money_object(0)
            if ( ! money ) {
            return 0


    def query_nationality(self, ) -> str:
            if (_nationality_data && _nationality_data->nationality) {
            return _nationality_data->nationality


    def query_nationality_region(self, ) -> str:
            if (_nationality_data && _nationality_data->region) {
            return _nationality_data->region


    def query_nationality_data(self, ) -> Any:
            if (_nationality_data && _nationality_data->data) {
            return _nationality_data->data


    def set_nationality(self, nationality: str) -> None:
            if (!_nationality_data) {
            _nationality_data = new(class living_nationality)


    def set_nationality_region(self, region: str) -> None:
            if (!_nationality_data) {
            _nationality_data = new(class living_nationality)


    def set_nationality_data(self, data: Any) -> None:
            if (!_nationality_data) {
            _nationality_data = new(class living_nationality)


    def query_nationality_name(self, ) -> str:
            if (_nationality_data && _nationality_data->nationality) {
            return _nationality_data->nationality.query_name()


    def query_nationality_description(self, looker: MudObject) -> str:
            if (_nationality_data && _nationality_data->nationality) {
            return _nationality_data->nationality.query_look_description(self, looker)


    def query_nationality_accent_ob(self, ) -> str:
            if (_nationality_data && _nationality_data->nationality) {
            return _nationality_data->nationality.query_region_accent_ob(_nationality_data->region)


    def query_nationality_start_location(self, ) -> str:
            if (_nationality_data && _nationality_data->nationality) {
            return _nationality_data->nationality.query_start_location(_nationality_data->region)


    def __init__(self):
            self._respond_cmd = ([ ])


    def add_respond_command(self, type: str, ob: MudObject, data: Any) -> None:
            class respond_data frog
            remove_respond_command(type, ob)
            frog = new (class respond_data)
            frog->ob = ob
            frog->data = data
            if (!_respond_cmd[type]) {
            _respond_cmd[type] = [})


    def query_respond_command(self, type: str, ob: MudObject) -> Any:
            class respond_data frog
            if (_respond_cmd[type]) {
            foreach (frog in _respond_cmd[type]) {
            if (frog->ob == ob) {
            return frog->data


    def remove_respond_command(self, type: str, ob: MudObject) -> None:
            class respond_data frog
            int i
            if (_respond_cmd[type]) {
            for (i = 0; i < sizeof(_respond_cmd[type]); i++) {
            frog = _respond_cmd[type][i]
            if (frog->ob == ob) {
            _respond_cmd[type] = _respond_cmd[type][0..i - 1] +
            _respond_cmd[type][i+1..]
            i--


    def clear_respond_commands(self, ) -> None:
            _respond_cmd = ([ ])


    def __init__(self):
            self._respond_to_with = []
            self._response_data = new(class response_data)
            self._response_data->only_respond_to = []


    def set_response_mon_understand_anything(self, flag: int) -> None:
            _response_data->understand_anything = flag


    def query_response_mon_debug_mode(self, ) -> int:
            return self.query_property("respon mon debug")


    def set_response_mon_debug_mode(self, flag: int) -> None:
            self.add_property("respon mon debug", flag)


    def query_stop_responding(self, ) -> int:
            int query_response_allowed(object ob,
            string *response) {
            if (!self.query_visible(ob)) {
            return 0


    def set_respond_to_with(self, map: Any) -> None:
            mixed *old_keys
            int i
            if ( mapp( map ) ) {
            #ifdef DEBUG
            log_file("BAD_RESPONSE", "set_respond_to_with() called by %O (%s)\n",
            previous_object(), previous_object()->query_name())
            #endif
            old_keys = keys(map)
            _respond_to_with = allocate(sizeof(old_keys) * 2)
            for (i = sizeof(old_keys); i--; ) {
            _respond_to_with[2*i] = old_keys[i]
            _respond_to_with[2*i+1] = map[old_keys[i]]


    def add_respond_to_with(self, trigger: Any, response: Any) -> None:
            _respond_to_with += [trigger, response]


    def add_only_respond_to(self, person: MudObject) -> None:
            _response_data->only_respond_to += [person]


    def remove_only_respond_to(self, person: MudObject) -> None:
            _response_data->only_respond_to -= [person]


    def query_only_respond_to(self, ) -> List[MudObject]:
            return _response_data->only_respond_to


    def check_loop(self, per: MudObject, mess: str) -> int:
            if(interactive(per)) {
            return 0


    def event_person_sayto(self, per: MudObject, mess: str, lang: str, targets: Any) -> None:
            string skill
            if(_response_data->stop_responding ||
            !sizeof(_respond_to_with) ||
            environment() == find_object( "/room/rubbish" ) ||
            environment() == find_object( "/room/void" ) ||
            !per || per == self) {
            return


    def event_person_say(self, per: MudObject, start: str, mess: str, lang: str) -> None:
            string skill
            if(_response_data->stop_responding ||
            !sizeof(_respond_to_with) ||
            environment() == find_object( "/room/rubbish" ) ||
            environment() == find_object( "/room/void" ) ||
            !per || per == self) {
            return


    def __init__(self):
            self._bonus_cache = ([ ])
            self._teach_offer = ([ ])
            self._stat_cache = ([ ])
            self.new_skills = ([ ])
            self._last_info = ([ "time" : time() ])


    def not_there(self, skill: str) -> int:
            return undefinedp(new_skills[skill])


    def zap_stat_cache(self, ) -> None:
            int i
            string word, *list, stat
            stat = self.stats_to_zap()
            if ( !stat ) {
            return


    def totaly_zap_bonus_cache(self, ) -> None:
            _bonus_cache = ([ ])


    def query_skill(self, skill: str) -> int:
            string *path
            if (!new_skills) {
            new_skills = ([ ])


    def tm_check_ok(self, skill: str, exp: MudObject) -> int:
            string *history, *bits, *abits
            int i, j, last, delay
            if ( !_last_info ) {
            _last_info = ([ "time" : time() ])


    def query_skill_successful(self, str: str, mod: int) -> int:
            return (query_skill_bonus(str, 0) + mod >= random(200))


    def add_teach_offer(self, ob: MudObject, skill: str, num: int, lvl: int, xp: int) -> None:
            _teach_offer[ob] = [skill, num, lvl, xp]


    def stop_teaching_skills(self, left: int, bing: Any) -> None:
            object ob
            if (left > 0) {
            if (bing[O_OTHER_PER] == self) {
            say(self.short() + " stops teaching themselves some "
            "skills.\n")
            } else if (previous_object() == self) {
            ob = bing[O_OTHER_PER]
            await ob.send(self.short() + " interupts your "
            "training.\n")
            } else {
            ob = self
            await ob.send(bing[O_OTHER_PER]->short() + " interupts your "
            "training.\n")


    def __init__(self):
            self.spells = ([ ])


    def help_spell(self, str: str) -> str:
            if (!mapp(spells)) {
            spells = ([ ])


    def add_spell(self, name: str, ob: Any, func: Any) -> int:
            int i
            mapping tmp
            if (pointerp(spells)) {
            tmp = ([ ])
            for (i=0;i<sizeof(spells);i+=2)
            tmp[spells[i]] = spells[i+1]
            spells = tmp


    def remove_spell(self, name: str) -> int:
            string spell, name_lc
            if ( !name ) {
            map_delete( spells, 0 )
            return 1


    def query_spell(self, word: str) -> Any:
            mapping tmp_spells
            string test_spell
            if ( !mapp( spells ) ) {
            return 0


    def stats_to_zap(self, ) -> str:
            string temp
            temp = to_zap
            to_zap = 0
            return temp


    def zap_stat(self, word: str) -> None:
            string dummy
            if ( !to_zap ) {
            to_zap = word
            if ( find_asyncio.create_task(self. "zap_stat_cache" ) == -1 )
            asyncio.create_task(self. "zap_stat_cache", 1 )


    def hp_base(self, ) -> int:
            int base
            base = 150 + 10 * (int)self.query_con()
            if ( base < 5 ) base = 5
            return base


    def scaled_weight(self, ) -> int:
            int i, actual, scaled
            actual = (int)self.query_weight(1)
            if ( actual < SCALING_DATA[ 0 ] )
            return actual
            scaled += SCALING_DATA[ 0 ]
            actual -= SCALING_DATA[ 0 ]
            i = 1
            while ( actual && ( ( i * SCALING_DATA[ 2 ] ) < 100 ) ) {
            if ( actual >= SCALING_DATA[ 1 ] ) {
            scaled += ( ( 100 - SCALING_DATA[ 2 ] * i ) * SCALING_DATA[ 1 ] )
            / 100
            scaled += ( SCALING_DATA[ 3 ] * SCALING_DATA[ 1 ] ) / 1000
            actual -= SCALING_DATA[ 1 ]
            } else {
            scaled += ( ( 100 - SCALING_DATA[ 2 ] * i ) * actual ) / 100
            scaled += ( SCALING_DATA[ 3 ] * actual ) / 1000
            actual = 0


    def reset_hp(self, ) -> None:
            int new_max, skill_bon
            string report
            if ( no_check )
            return
            skill_bon = (int)self.query_skill_bonus( "other.health" )
            new_max = hp_base() + skill_bon * hp_gradient()
            if ( !base_weight ) {
            if ( (string)self.query_name() == "object" )
            return
            report = file_name( self ) +" ("+
            (string)self.query_name() +"): race object is "+
            (string)self.query_race_ob()
            if ( environment() ) {
            if ( file_name( environment() ) == "/room/void" )
            return
            report += "; in "+ file_name( environment() )
            self->move( "/room/void", "$N gets booted into the void for "+
            "being a bad NPC." )


    def reset_gp(self, ) -> None:
            string class_ob
            if ( no_check )
            return
            class_ob = (string)self.query_class_ob()
            if (!class_ob) {
            class_ob = query_property("backup class")


    def calc_inc_rates(self, ) -> None:
            string class_ob
            hp_inc = sqrt((int)self.stat_modify(100, "other.health")) - 7
            class_ob = (string)self.query_class_ob()
            if ( !class_ob ) {
            class_ob = query_property("backup class")
            if (!class_ob) {
            class_ob = CONFIG_DEFAULT_GUILD


    def heart_beat(self, ) -> None:
            int hp
            int calling_death
            hp = self.query_hp()
            if ( hp < 0 ) {
            calling_death = self.query_callingdeath()
            if ( calling_death ) {
            if ( time() > calling_death + DEATH_WAIT_TIME ) {
            self.do_death()


    def reset_carry_cap(self, ) -> None:
            int i, hst_num, hst_wei, new_cap, old_loc, tot_str
            object *contents, *dropped
            if ( no_check ) return
            old_loc = (int)self.query_loc_weight()
            tot_str = Str + strtmp + strbon
            new_cap = BASE
            new_cap += ( ORD1T * tot_str ) / ORD1B
            new_cap += ( ORD2T * tot_str * tot_str ) / ORD2B
            new_cap = ( new_cap * (int)self.query_weight(1) ) / 100
            if ( !new_cap )
            new_cap = 1
            self.set_max_weight( new_cap )
            if ( new_cap >= old_loc ) return
            self.dest_hide_shadow()
            contents = all_inventory( self ) -
            (object *)self.query_armours()
            dropped = [})
            while ( ( old_loc > new_cap ) && sizeof( contents ) ) {
            hst_num = 0
            hst_wei = 0
            for ( i = 0; i < sizeof( contents ); i++ )
            if ( (int)contents[ i ]->query_complete_weight() > hst_wei ) {
            hst_wei = (int)contents[ i ]->query_complete_weight()
            hst_num = i


    def check_stats_zero(self, ) -> None:
            if ( Int + inttmp + intbon <= 0 ||
            Wis + wistmp + wisbon <= 0 ) {
            self.add_property( PASSED_OUT, 1, 500 )
            await  self.send("You fall asleep.\n" )


    def reset_all2(self, ) -> None:
            no_check = 0
            reset_hp()
            reset_gp()
            reset_carry_cap()
            calc_inc_rates()
            check_stats_zero()
            self.do_burden_call()


    def set_con(self, number: int) -> int:
            if ( !check( number ) ) number = 28
            if ( Con != number )
            zap_stat( "C" )
            Con = number
            return Con


    def set_dex(self, number: int) -> int:
            if ( !check( number ) ) number = 28
            if ( Dex != number )
            zap_stat( "D" )
            Dex = number
            return Dex


    def set_int(self, number: int) -> int:
            if ( !check( number ) ) number = 28
            if ( Int != number )
            zap_stat( "I" )
            Int = number
            return Int


    def set_str(self, number: int) -> int:
            if ( !check( number ) ) number = 28
            if ( Str != number )
            zap_stat( "S" )
            Str = number
            return Str


    def set_wis(self, number: int) -> int:
            if ( !check( number ) ) number = 28
            if ( Wis != number )
            zap_stat( "W" )
            Wis = number
            return Wis


    def adjust_con(self, number: int) -> int:
            if ( check( number + Con ) ) {
            Con += number
            if ( number )
            zap_stat( "C" )


    def adjust_dex(self, number: int) -> int:
            if ( check( number + Dex ) ) {
            Dex += number
            if ( number )
            zap_stat( "D" )


    def adjust_int(self, number: int) -> int:
            if ( check( number + Int ) ) {
            Int += number
            if ( number )
            zap_stat( "I" )


    def adjust_str(self, number: int) -> int:
            if ( check( number + Str ) ) {
            Str += number
            if ( number )
            zap_stat( "S" )


    def adjust_wis(self, number: int) -> int:
            if ( check( number + Wis ) ) {
            Wis += number
            if ( number )
            zap_stat( "W" )


    def adjust_tmp_con(self, number: int) -> int:
            contmp += number
            if ( number )
            zap_stat( "C" )
            if ( contmp && !dextmp && !inttmp && !strtmp && !wistmp )
            asyncio.create_task(self. "update_tmps", 900 )
            return contmp


    def adjust_tmp_dex(self, number: int) -> int:
            dextmp += number
            if ( number )
            zap_stat( "D" )
            if ( !contmp && dextmp && !inttmp && !strtmp && !wistmp )
            asyncio.create_task(self. "update_tmps", 900 )
            return dextmp


    def adjust_tmp_int(self, number: int) -> int:
            inttmp += number
            if ( number )
            zap_stat( "I" )
            if ( !contmp && !dextmp && inttmp && !strtmp && !wistmp )
            asyncio.create_task(self. "update_tmps", 900 )
            return inttmp


    def adjust_tmp_str(self, number: int) -> int:
            strtmp += number
            if ( number )
            zap_stat( "S" )
            if ( !contmp && !dextmp && !inttmp && strtmp && !wistmp )
            asyncio.create_task(self. "update_tmps", 900 )
            return strtmp


    def adjust_tmp_wis(self, number: int) -> int:
            wistmp += number
            if ( number )
            zap_stat( "W" )
            if ( !contmp && !dextmp && !inttmp && !strtmp && wistmp )
            asyncio.create_task(self. "update_tmps", 900 )
            return wistmp


    def adjust_bonus_con(self, number: int) -> int:
            conbon += number
            if ( number )
            zap_stat( "C" )
            return conbon


    def adjust_bonus_dex(self, number: int) -> int:
            dexbon += number
            if ( number )
            zap_stat( "D" )
            return dexbon


    def adjust_bonus_int(self, number: int) -> int:
            intbon += number
            if ( number )
            zap_stat( "I" )
            return intbon


    def adjust_bonus_str(self, number: int) -> int:
            strbon += number
            if ( number )
            zap_stat( "S" )
            return strbon


    def adjust_bonus_wis(self, number: int) -> int:
            wisbon += number
            if ( number )
            zap_stat( "W" )
            return wisbon


    def update_tmps(self, ) -> None:
            if ( contmp ) {
            zap_stat( "C" )
            contmp = contmp / 2


    def set_height(self, number: int) -> None:
            if ( number > 0 ) height = number


    def set_base_weight(self, number: int) -> None:
            if ( number > 0 )
            base_weight = number


    def query_weight(self, int) -> int:
            int adjust_weight
            adjust_weight = ( ( ( Con + 3 * Str ) / 4 ) - 13 ) * ( base_weight / 30 )
            return base_weight + adjust_weight


    def do_get_rock(self, verb: str, dest: MudObject) -> Any:
            int rock_size
            string rock_type
            object rock
            if ( query_property( "rock object" ) )
            return ( rock = clone_object( (string)query_property( "rock object" ) ) )
            if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
            rock_size = 3
            if ( !rock_size ) return 0
            rock = clone_object( "/obj/mineral" )
            if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
            rock_type = ["cinnabar", "coal", "rosy-quartz", "chalk", "flint",
            "slate"][ random( 6 ) ]
            rock.make_mineral( rock_type, 1 + random( rock_size ) )
            if ( !( rock.move( this_player() ) ) ) return 1
            rock.dest_me()
            return 0


    def __init__(self):


    def query_terrain_map_colour(self, ) -> str:
            int do_get_rock(object *indirs, string dir, string indir, mixed *args,
            string pattern)
            {
            int rock_size
            string rock_type
            object rock
            if ( query_property( "rock object" ) )
            rock = clone_object(query_property("rock object"))
            else {
            if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
            rock_size = 3
            if ( !rock_size ) return 0
            rock = clone_object( "/obj/mineral" )
            if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
            rock_type = ["cinnabar", "coal", "rosy-quartz", "chalk", "flint",
            "slate"][ random( 6 ) ]
            rock.make_mineral(rock_type, 1 + random(rock_size))


    def __init__(self):


    def do_get_rock(self, verb: str, dest: MudObject) -> Any:
            int rock_size
            string rock_type
            object rock
            if ( query_property( "rock object" ) )
            return ( rock = clone_object( (string)query_property( "rock object" ) ) )
            if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
            rock_size = 3
            if ( !rock_size ) return 0
            rock = clone_object( "/obj/mineral" )
            if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
            rock_type = ["cinnabar", "coal", "rosy-quartz", "chalk", "flint",
            "slate"][ random( 6 ) ]
            rock.make_mineral(rock_type, 1 + random(rock_size))
            if (!(rock.move(this_player() ) ) ) return 1
            rock.dest_me()
            return 0


    def do_get_flower(self, verb: str, dest: MudObject) -> Any:
            string flower_type
            object flower
            printf("Verb: %s\n", verb)
            if ( query_property( "flower object" ) )
            return (flower = clone_object((string)query_property("flower object")))
            if ((int)query_property("noflowers"))
            return 0
            flower = clone_object("/std/plant")
            if(undefinedp(flower_type = (string)query_property("flower type")))
            flower_type = ({"forgetmenot", "violet"})[ random(2) ]
            flower.set_plant(flower_type)
            flower.set_plant_type(flower_type)
            flower->set_plant_desc("A beautiful "+flower_type+" picked before its "+
            "time.\n")
            flower.add_plural( capitalize( flower_type ) )
            if (!(flower.move(this_player()))) return 1
            flower.dest_me()
            return 0


    def __init__(self):


    def do_get_rock(self, verb: str, dest: MudObject) -> Any:
            int rock_size
            string rock_type
            object rock
            if ( query_property( "rock object" ) )
            return ( rock = clone_object( (string)query_property( "rock object" ) ) )
            if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
            rock_size = 3
            if ( !rock_size ) return 0
            rock = clone_object( "/obj/mineral" )
            if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
            rock_type = ["cinnabar", "coal", "rosy-quartz", "chalk", "flint",
            "slate"][ random( 6 ) ]
            rock.make_mineral( rock_type, 1 + random( rock_size ) )
            if ( !( rock.move( this_player() ) ) ) return 1
            rock.dest_me()
            return 0


    def do_get_flower(self, verb: str, dest: MudObject) -> Any:
            string flower_type
            object flower
            if ( query_property( "flower object" ) )
            return (flower = clone_object((string)query_property("flower object")))
            if ((int)query_property("noflowers"))
            return 0
            flower = clone_object("/std/plant")
            if(undefinedp(flower_type = (string)query_property("flower type")))
            flower_type = ({"forgetmenot", "buttercup", "daisy"})[ random(2) ]
            flower.set_plant(flower_type)
            flower.set_plant_type(flower_type)
            flower->set_plant_desc("A beautiful "+flower_type+" picked before its "
            "time.")
            flower.add_plural( pluralize( flower_type ) )
            if (!(flower.move(this_player()))) return 1
            flower.dest_me()
            return 0


    def __init__(self):


    def __init__(self):


    def __init__(self):
            add_item("rock", ["long", "A nice rock looking thingy.",
            "get",  [self, "do_get_rock"]] )
            add_property("track type", "woodland")
            if(!do_setup) {
            self.setup()
            self.reset()


    def extra_look(self, ) -> str:
            string extra
            extra = ::extra_look()
            switch((string)WEATHER.query_season()) {
            case "spring":
            return extra + "Spring flowers are everywhere you look.\n"
            case "autumn":
            return extra + "The ground is littered with fallen leaves.\n"
            break
            default:
            return extra


    def do_get_rock(self, verb: str, dest: MudObject) -> Any:
            int rock_size
            string rock_type
            object rock
            if ( query_property( "rock object" ) )
            return ( rock = clone_object( (string)query_property( "rock object" ) ) )
            if ( undefinedp( rock_size = (int)query_property( "rock size" ) ) )
            rock_size = 3
            if ( !rock_size ) return 0
            rock = clone_object( "/obj/mineral" )
            if ( undefinedp( rock_type = (string)query_property( "rock type" ) ) )
            rock_type = ["cinnabar", "coal", "rosy-quartz", "chalk", "flint",
            "slate"][ random( 6 ) ]
            rock.make_mineral( rock_type, 1 + random( rock_size ) )
            if ( !( rock.move( this_player() ) ) ) return 1
            rock.dest_me()
            return 0


    def do_get_flower(self, verb: str, dest: MudObject) -> Any:
            string flower_type
            object flower
            if ( query_property( "flower object" ) )
            return (flower = clone_object((string)query_property("flower object")))
            if ((int)query_property("noflowers"))
            return 0
            flower = clone_object("/std/plant")
            if(undefinedp(flower_type = (string)query_property("flower type")))
            flower_type = ({"forgetmenot", "violet"})[ random(2) ]
            flower.set_plant(flower_type)
            flower.set_plant_type(flower_type)
            flower->set_plant_desc("A beautiful "+flower_type+" picked before its "+
            "time.\n")
            flower.set_main_plural(flower_type + "s")
            if (!(flower.move(this_player()))) return 1
            flower.dest_me()
            return 0


    def do_get_berry(self, verb: str, dest: MudObject) -> Any:
            object berry
            string berry_type
            if ((int)query_property("noflowers"))
            return 0
            berry_type = ({"blackberry", "raspberry", "blueberry", "strawberry",
            "blackcurrant"})[random(5)]
            berry = clone_object( "/obj/food" )
            berry.set_name(berry_type)
            berry.set_short(berry_type)
            berry->set_long("This is a lovely, plump "+berry_type+" it looks good "+
            "enough to eat.\n")
            berry.add_alias("berry")
            if (!(berry.move(this_player()))) return 1
            berry.dest_me()
            return 0


    def do_get_leaf(self, verb: str, dest: MudObject) -> Any:
            object leaf
            string leaf_type
            if ((int)query_property("noflowers"))
            return 0
            leaf_type = ({"maple", "oak", "sycamore", "ash", "silver birch"})[random(5)]
            leaf = clone_object("/std/object")
            leaf.set_name("leaf")
            leaf.set_short(leaf_type+" leaf")
            leaf->set_long("This is a dead "+leaf_type+" leaf.  Its natural green "+
            "has turned to shades of gold, red and brown.\n")
            leaf.add_adjective(leaf_type)
            if (!(leaf.move(this_player()))) return 1
            leaf.dest_me()
            return 0


    def setup(self, ) -> None:
            set_short("workroom of "+ CREATOR)
            add_property( "determinate", "the ")
            set_light(100)
            set_long("This is the workroom of "+CREATOR+".  You can see a small "
            "wooden desk sulking in the corner of the room, it has a "
            "beautifully carved wooden rolly chair in front of it.  It "
            "looks like this was just newly created, there is a smell "
            "of paint and leather in the air.\n")
            add_item("chair",
            ["long", "The teak rolly chair has amazing carvings of dragons "
            "and ... other things on it.  They almost seem alive, "
            "you especially don't note the way the dragon "
            "blinks at you.",
            "position",
            "the teak rolly chair"] )
            add_item("desk", "The desk is made of mahogany with a touch of "
            "mountain ash.  The top has two little basket things "
            "on it labelled \"in\" and \"out\".  The in basket "
            "is rather small." )
            add_item( "dragon", "I told you, you don't notice it winking at you." )
            add_item("in basket", "The in basket is full of small yellow forms "
            "with large red letters on them saying "
            "\"Important read me first\" and then not "
            "appearing to actually have any thing else on "
            "them." )
            add_item( "out basket", "The out basket is completely empty." )
            add_item("basket", "There are two baskets sitting on top of the desk.  "
            "They have the words \"in\" and \"out\" written "
            "on them." )
            add_item("paint", "You look around to see the source of the paint "
            "smell and you can't find it.  The walls? of the room "
            "ummm seem to be well shall we just twisting in a "
            "confused mish mash of shapes, you are sure they are "
            "not threatening." )
            add_item("wall", "The walls are made up of a cloudy substance, white "
            "in nature that is roiling around the place where "
            "you are standing.  Great magic must be holding it "
            "back, every now and then you see a demonic head "
            "push its way out of the cloud roll its eyes and fade "
            "back into the cloud." )
            add_item("cloud", "The cloud is white coloured with a few flashes "
            "of light bursting in it." )
            add_item("demon", "The demonic heads that pop out are pretty nasty "
            "looking, they disapear with a snarl of strain." )
            add_exit("common", "/w/common", "door")
            add_exit("drum", CONFIG_START_LOCATION, "path")
            add_exit("learning", "/d/learning/main", "path")
            modify_exit( ["common", "drum", "learning"],
            ["function", "check_player"] )
            add_alias("north", "drum")
            add_alias("south", "common")
            "/w/common"->add_exit(CREATOR, "/w/"+CREATOR+"/workroom", "door")


    def reset(self, ) -> None:
            if (!button) {
            button = clone_object("/obj/misc/button")
            button.move(self)


    def check_player(self, verb: str, player: MudObject, special: str) -> int:
            if ( interactive( player ) ) {
            return 1


    def __init__(self):
            self.bits = []
            self.inedible = ['skull']
            self.unrottable = ['skull']


    def setup(self, ) -> None:
            set_name( "ape" )
            set_long( "The apes are any members of the family Pongidae of large "
            "semi-erect primates, including the chimpanzee, gorilla, orangutan "
            "and gibbon.\n" )
            set_weight( 2500 )
            set_height( 175 )
            set_stats( [4, 4, 0, 4, 0] )


    def query_desc(self, thing: MudObject) -> str:
            if( (int)thing.query_gender() == 1 )
            return "He is your average hairy young male ape.\n"
            return "She is your average hairy young female ape.\n"


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            thing.add_ac( "blunt", "blunt", 15 + level / 10 )
            thing.add_ac( "sharp", "sharp", 10 + level / 15 )
            thing.add_ac( "pierce", "pierce", 12 + level / 12 )
            thing.reset_all()


    def query_dark(self, light: int) -> int:
            if( light < 10 ) return 1
            if( light > 200 ) return 2
            return 0


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 10 + ( 3 * sqrt( number ) ) / 2
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.add_attack( "hands", 75, [2 * number, 8, number],
            "blunt", "unarmed", "unarmed_hands" )
            thing.add_attack( "feet", 25, [3 * number, 10, number],
            "blunt", "unarmed", 0 )


    def __init__(self):
            self.bits = []
            self.inedible = ['left fang', 'right fang', 'mandible']
            self.unrottable = ['left fang', 'right fang', 'mandible']


    def setup(self, ) -> None:
            set_name( "badger" )
            set_long( "A big black white and grey burowing animal.\n" )
            set_height( 30 )
            set_weight( 500 )
            set_desc( "small brown meateater" )
            set_stats( [2, -2, -2, 2, -4] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            level = 3 + ( 2 * level + random( level ) ) / 8
            thing.add_ac( "blunt", "blunt", 20 + level / 3 )
            thing.add_ac( "sharp", "sharp", 50 + level )
            thing.add_ac( "pierce", "pierce", 60 + 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number ) / 2
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "claws" )
            thing.remove_attack( "chew" )
            thing.add_attack( "claws", 50, [( 4 * number ) / 2, 8, 2 * number],
            "sharp", "unarmed", 0 )
            thing.add_attack( "bite", 100, [2 * number, 10, ( 3 * number )/2],
            "chew", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def __init__(self):
            self.sight = ['5', '20', '200', '300']
            self.stats = allocate( 5 )
            self.desc = "a small non-descript thing"
            self.inedible = []
            self.unrottable = []
            self.pluckable = []
            self.acs = []
            self.attacks = []
            self.bits = []


    def query_dark(self, light: int) -> int:
            if ( light < sight[ 0 ] ) {
            return -2


    def query_desc(self, thing: MudObject) -> str:
            return capitalize( (string)thing.query_pronoun() ) +" is "+ desc +".\n"


    def set_desc(self, words: str) -> None:
            string *query_limbs() {
            if ( !limbs ) {
            self.find_limbs()


    def find_limbs(self, ) -> None:
            int i
            string limb
            limbs = [})
            for ( i = 0; i < sizeof( bits ); i += 3 ) {
            if ( sscanf( bits[ i ], "%s hand", limb ) == 1 ) {
            limbs += [bits[ i ]]


    def add_ac(self, ac_name: str, ac_type: str, ac_amount: Any) -> None:
            acs += [ac_name, ac_type, ac_amount]


    def add_attack(self, attack_name: str, attack_chance: int, attack_data: int) -> None:
            attacks += [attack_name, attack_chance, attack_data]


    def add_bit(self, bit_short: str, bit_name: str, bit_array: Any) -> None:
            int i
            i = bits .index( bit_short) if  bit_short in bits  else -1
            if ( !( i % 3 ) ) {
            bits[ i ] = bit_short
            bits[ i + 1 ] = bit_name
            bits[ i + 2 ] = bit_array
            return


    def remove_bit(self, word: str) -> None:
            int i
            i = bits .index( word) if  word in bits  else -1
            if ( ( i == -1 ) || ( i % 3 ) ) {
            return


    def modifier(self, number: int) -> int:
            return ( number * ( roll_MdN( 20, 21 ) - 220 ) ) / 2000


    def start_player(self, thing: MudObject) -> None:
            if ( !thing.query_base_weight() ) {
            thing.set_base_weight( 1 + weight + modifier( weight ) )


    def query_number_worn(self, type: str) -> int:
            switch ( type ) {
            case "armband" :
            return 2
            case "badge" :
            return 15
            case "bracelet" :
            return 4
            case "earring" :
            return 2
            case "garter" :
            return 2
            case "shoulder" :
            return 2
            case "necklace" :
            return 5
            case "ring" :
            return 8
            case "sash" :
            return 2
            case "shirt" :
            return 2
            case "belt scabbard" :
            return 2
            case "small scabbard" :
            return 2
            case "bandaid" :
            return 5
            default :
            return 1


    def set_level(self, thing: MudObject, level: int) -> None:
            int i
            if ( !thing ) {
            return


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int i, number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number )
            for ( i = sizeof( attacks ) - 3; i > -1; i -= 3 ) {
            thing.remove_attack( attacks[ i ] )
            thing->add_attack( attacks[ i ], attacks[ i + 1 ],
            calc_attack( attacks[ i + 2 ], number ), A_TYPES[ attacks[ i ] ],
            "unarmed", "unarmed_"+ attacks[ i ] )


    def query_eat(self, bit: str) -> int:
            if (inedible.index( bit) if  bit in inedible else -1 == -1) {
            return 1


    def query_unrottable(self, bit: str) -> int:
            if (unrottable.index( bit) if  bit in unrottable else -1 == -1) {
            return 0


    def query_pluckable(self, bit: str) -> int:
            if (pluckable.index( bit) if  bit in pluckable else -1 == -1) {
            return 0


    def map_target_zone(self, zone: str) -> str:
            switch(zone) {
            case "abdomen":
            return "stomach"
            case "hands":
            case "arms":
            return (random(2) ? "left " : "right ") + "front leg"
            case "feet":
            case "legs":
            return (random(2) ? "left " : "right ") + "rear leg"
            default:
            return zone


    def map_armour_zone(self, zone: str) -> str:
            switch(zone) {
            case "thorax":
            case "body":
            case "breast":
            case "trunk":
            return "chest"
            case "tail":
            return "back"
            case "stomach":
            return "abdomen"
            case "left arm":
            case "right arm":
            case "left front leg":
            case "right front leg":
            case "left petral fin":
            case "right petral fin":
            case "left wing":
            case "right wing":
            case "branches":
            return "arms"
            case "left hand":
            case "right hand":
            case "left middle leg":
            case "right middle leg":
            case "left front paw":
            case "right front paw":
            return "hands"
            case "left leg":
            case "right leg":
            case "left back leg":
            case "right back leg":
            case "left rear leg":
            case "right rear leg":
            case "dorsal fin":
            return "legs"
            case "left foot":
            case "right foot":
            case "left rear paw":
            case "left rear paw":
            case "left rear foot":
            case "left rear foot":
            case "left claw":
            case "right claw":
            case "root":
            return "feet"
            default:
            return zone


    def setup(self, ) -> None:
            set_name( "bat" )
            set_long( "This is a small flying rodent." )
            set_desc( "a small, flying rodent" )
            set_height( 20 )
            set_weight( 40 )
            remove_bit( "torso" )
            remove_bit( "left front leg" )
            remove_bit( "right front leg" )
            remove_bit( "left rear leg" )
            remove_bit( "right rear leg" )
            add_bit( "torso", "torso", [0, 20, 0,
            "heart", "liver", "left kidney", "right kidney", "spleen",
            "right lung", "left lung", "right wing", "left wing"] )
            add_bit( "right wing", "wing", ["torso", 20, 0] )
            add_bit( "left wing", "wing", ["torso", 20, 0] )
            add_bit( "left leg", "leg", [0, 5, 0] )
            add_bit( "right leg", "leg", [0, 5, 0] )
            set_sight( [-20, 0, 80, 120] )
            set_stats( [0, 14, -4, -4, -6] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            thing.add_ac( "blunt", "blunt", level )
            thing.add_ac( "sharp", "sharp", 2 + level )
            thing.add_ac( "pierce", "pierce", 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number ) / 4
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "bite" )
            thing.remove_attack( "claws" )
            thing.add_attack( "bite", 75, [0, 3, number],
            "pierce", "unarmed", 0 )
            thing.add_attack( "claws", 50, [0, 5, number / 2],
            "sharp", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "bear" )
            set_desc( "a furry bear" )
            set_height( 200 )
            set_weight( 8000 )
            set_stats( [6, 4, -2, 8, -4] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            level = 2 + ( 2 * level + random( level ) ) / 8
            thing.add_ac( "blunt", "blunt", 20 + level / 3 )
            thing.add_ac( "sharp", "sharp", 50 + level )
            thing.add_ac( "pierce", "pierce", 60 + 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number ) / 2
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "claws" )
            thing.remove_attack( "bite" )
            thing.add_attack( "claws", 100, [2 * number, 10, number],
            "sharp", "unarmed", 0 )
            thing.add_attack( "bite", 50, [3 * number, 8, number],
            "pierce", "unarmed", 0 )
            thing.tactics( "response dodge" )
            thing.tactics( "attitude offensive" )


    def setup(self, ) -> None:
            set_name( "beetle" )
            set_desc( "a hard-carapaced insect that scuttles along the ground" )
            set_height( 5 )
            set_weight( 2 )
            add_bit( "left wing cover", "cover", ["thorax", 1, 0] )
            add_bit( "right wing cover", "cover", ["thorax", 1, 0] )
            inedible += ["left wing cover", "right wing cover"]
            set_stats( [-6, 4, -6, -6, -6] )


    def start_player(self, thing: MudObject) -> None:
            ::start_player( thing )
            thing.tactics( "response dodge" )
            thing.tactics( "attitude defensive" )


    def setup(self, ) -> None:
            set_name( "bird" )
            set_long( "A general, unspecified bird.\n" )
            set_height( 15 )
            set_weight( 60 )
            set_stats( [0, 14, -4, -4, -6] )


    def new_set_level(self, args: Any) -> None:
            int weight
            object thing
            thing = args[ 1 ]
            if ( !thing )
            return
            weight = (thing.query_weight() / 20)
            thing.add_ac( "blunt", "blunt", weight / 2 )
            thing.add_ac( "pierce", "pierce", weight )
            thing.add_ac( "sharp", "sharp", weight )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number / 4 ) + ( thing.query_weight() / 20 )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "beak" )
            thing.remove_attack( "claws" )
            thing.add_attack( "beak", 50, [number / 2, 2, number / 2],
            "pierce", "unarmed", 0 )
            thing.add_attack( "claws", 75, [number, 5, number / 2],
            "sharp", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def __init__(self):
            self.bits = []
            self.inedible = ['beak', 'skull', 'body feather', 'left wing feather']
            self.unrottable = ['beak', 'skull', 'body feather', 'left wing feather']
            self.pluckable = ['body feather', 'left wing feather', 'right wing feather']


    def map_target_zone(self, zone: str) -> str:
            switch(zone) {
            case "chest":
            return "breast"
            case "abdomen":
            return "stomach"
            case "hands":
            case "arms":
            return (random(2) ? "left " : "right ") + "wing"
            case "feet":
            return (random(2) ? "left " : "right ") + "claw"
            default:
            return zone


    def setup(self, ) -> None:
            set_name( "bufonid" )
            set_long( "The bufonids are rare species of humanoid toad-like beings.  "
            "It is rumoured that they were created by wizards as part of a "
            "heinous series of experiments of unknown intent and subsequently "
            "escaped from their creators.  Little is known of them, except that "
            "they keep themselves well hidden from humans.\n" )
            set_height( 150 )
            set_weight( 1800 )
            set_desc( "a strange creature, with webbed feet and warty green skin, "
            "that gives you the impression of being a humanoid toad" )
            remove_bit( "left ear" )
            remove_bit( "right ear" )
            remove_bit( "nose" )
            remove_bit( "scalp" )
            remove_bit( "teeth" )
            add_ac( "blunt", "blunt", 15 )
            add_ac( "pierce", "pierce", 12 )
            add_ac( "sharp", "sharp", 10 )
            add_attack( "hands", 75, [40, 5, 10] )
            add_attack( "feet", 25, [30, 5, 20] )
            set_stats( [2, 2, 0, 2, 0] )


    def setup(self, ) -> None:
            set_name( "cabbage" )
            set_long("A green, leafy vegetable.  Probably full of vitamins and "+
            "minerals, and plenty of roughage.\n" )
            set_height( 20 )
            set_weight( 40 )
            set_desc( "a cute little green-fronded cabbage.  Awww" )
            set_skin( "fronds" )
            bits = ({
            "frond", "frond", [0, 100, ({"/std/bit", 10})],
            "stalk", "stalk", [0, 500, 0]
            })
            inedible = [})
            unrottable = [})
            set_stats( [-4, -4, -6, -4, -6] )


    def player_heart_beat(self, word: str, brassica: MudObject) -> None:
            object *caterpillars
            if( !environment( brassica ) ) {
            return


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number ) / 2
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "fronds" )
            thing.add_attack( "fronds", 160, [4 * number, 5, 3 * number],
            "sharp", "unarmed", 0 )
            thing->add_attack_message( "fronds", "sharp", ({
            50, "$N scratch$es $P $z with a frond.\n",
            100, "$N jab$s a sharp frond into $P $z.\n",
            140, "$N chew$s on $P $z.\n",
            180, "$N slash$es $P $z with $p fronds.\n",
            230, "$N climb$s onto %I and cuts $P $z with a sharp frond.\n",
            0, "$N bite$s $P $z off!\n"] )
            thing.tactics( "response dodge" )
            thing.tactics( "attitude offensive" )


    def setup(self, ) -> None:
            set_name( "camel" )
            set_long( "The camel is an animal living in desert regions.  It has two "
            "humps, a mean temper and a good eye for numbers.  They are usually "
            "named things like \"You Bastard\", \"Evil-smelling Bugger\" and so "
            "on, something that might seem strange to anyone who hasn't "
            "actually met one of the beasts.\n" )
            set_height( 170 )
            set_weight( 12000 )
            set_desc( "a camel that looks less interested in you than in sand" )
            add_bit( "tail", "tail", [0, 18, 0] )
            add_bit( "fore hump", "hump", [0, 75, 0] )
            add_bit( "aft hump", "hump", [0, 50, 0] )
            inedible += ["tail"]
            add_ac( "blunt", "blunt", 50 )
            add_ac( "pierce", "pierce", 20 )
            add_ac( "sharp", "sharp", 20 )
            add_attack( "bite", 50, [40, 8, 10] )
            add_attack( "feet", 50, [60, 10, 40] )
            set_stats( [4, 2, 10, 6, 8] )


    def start_player(self, thing: MudObject) -> None:
            ::start_player( thing )
            thing.tactics( "response dodge" )


    def __init__(self):
            self.bits = []
            self.inedible = ['skull', 'claw', 'tail', 'teeth', 'tooth', 'skin']
            self.unrottable = ['skull', 'claw', 'teeth', 'tooth']


    def map_target_zone(self, zone: str) -> str:
            switch(zone) {
            case "chest":
            return random(4) ? "back" : "chest"
            case "abdomen":
            return random(4) ? "stomach" : "lower back"
            case "arms":
            return (random(2) ? "left " : "right ") + "front leg"
            case "hands":
            return (random(2) ? "left " : "right ") + "front paw"
            case "legs":
            return (random(2) ? "left " : "right ") + "rear leg"
            case "feet":
            return (random(2) ? "left " :"right ") + "rear paw"
            default:
            return zone


    def setup(self, ) -> None:
            set_name( "cat" )
            set_long( "A carnivorous mammal (Felis catus) long domesticated and kept "+
            "by man as a pet or for catching rats and mice.\n" )
            set_height( 20 )
            set_weight( 100 )
            set_desc( "a furry cat, on the hunt for a mouse to play with" )
            set_stats( [0, 10, 2, -2, 2] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            level = 1 + ( 2 * level + random( level ) ) / 10
            thing.add_ac( "blunt", "blunt", level )
            thing.add_ac( "sharp", "sharp", 2 + level )
            thing.add_ac( "pierce", "pierce", 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "bite" )
            thing.remove_attack( "claws" )
            thing.add_attack( "bite", 100, [number, 5, number],
            "sharp", "unarmed", 0 )
            thing.add_attack( "claws", 150, [number / 2, 7, number],
            "sharp", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "caterpillar" )
            set_long( "The elongated wormlike larva of a butterfly or moth.\n" )
            set_height( 5 )
            set_weight( 2 )
            set_desc( "a caterpillar, crawling along the ground" )
            set_stats( [-6, -6, -6, -6, -6] )


    def player_heart_beat(self, word: str, eater: MudObject) -> None:
            int i, time
            object flowers, *things
            if( !environment( eater ) ) return
            if( eater.query_property( "eating" ) ) return
            things = all_inventory( environment( eater ) ) - [eater]
            if( !sizeof( things ) ) return
            for( i = 0; i < sizeof( things ); i++ ) {
            if( !(int)things[ i ]->id( "flowers" ) ) {
            things -= [things[ i ]]
            i--
            } else {
            if( things[ i ]->query_property( "being eaten" ) ) {
            things -= [things[ i ]]
            i--


    def done_eating(self, eater: MudObject, flowers: MudObject) -> None:
            if( !eater ) return
            eater.remove_property( "eating" )
            if( !environment( eater ) ) return
            if( !flowers ) return
            if( all_inventory( environment( eater .index( flowers) if  flowers in all_inventory( environment( eater  else -1 ) ) == -1 )
            return
            tell_room( environment( eater ), "The " + (string)eater.query_short() +
            " finishes the " + (string)flowers.query_short() + " and burps " +
            "contentedly.\n" )
            flowers.dest_me()


    def setup(self, ) -> None:
            set_name( "chicken" )
            set_long( "Chickens.  That's all there is to say.  Chickens, chickens, "
            "chickens, chickens, chickens.  Thank you.\n" )
            set_weight( 80 )
            set_height( 30 )
            set_desc( "an ordinary brain-dead chicken" )
            add_ac( "feather_blow", "blunt", 10 )
            add_ac( "feather_slash", "sharp", 2 )
            add_ac( "feather_pierce", "pierce", 2 )
            set_stats( [0, 8, -6, -4, -6] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number / 4 ) + ( thing.query_weight() / 20 )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "beak" )
            thing.remove_attack( "claws" )
            thing.add_attack( "beak", 50, [number / 2, 2, number / 2],
            "pierce", "unarmed", 0 )
            thing.add_attack( "claws", 75, [number, 5, number / 2],
            "sharp", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_desc( "a nasty cockroach, ugh" )
            set_name( "cockroach" )
            set_height( 5 )
            set_weight( 2 )
            add_ac( "blunt", "blunt", 40 )
            add_ac( "sharp", "sharp", 20 )
            add_ac( "pierce", "pierce", 10 )
            set_stats( [-6, 4, -4, -6, -6] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "claws" )
            thing.remove_attack( "bite" )
            thing.add_attack( "claws", 100, [( 3 * number ) / 2, 5, number],
            "sharp", "unarmed", 0 )
            thing.add_attack( "bite", 50, ({3 * number, 2, number],
            "pierce", "unarmed", 0 )
            thing.tactics( "response dodge" )
            thing.tactics( "attitude defensive" )


    def setup(self, ) -> None:
            mixed *new_head
            set_name( "cow" )
            set_long( "A large hoofed mammal.  Surprise.\n" )
            set_height( 175 )
            set_weight( 16000 )
            set_desc( "a large, hairy quadruped reminding you very much of a cow" )
            new_head = query_bit( "head" )
            new_head[ 2 ] += ["left horn", "right horn"]
            remove_bit( "head" )
            add_bit( "head", "head", new_head[ 2 ] )
            add_bit( "left horn", "horn", ["head", 10, 0] )
            add_bit( "right horn", "horn", ["head", 10, 0] )
            add_bit( "udders", "udders", [0, 60, 0] )
            add_bit( "tail", "tail", [0, 15, 0] )
            inedible += ["left horn", "right horn", "tail"]
            unrottable += ["left horn", "right horn"]
            add_ac( "blunt", "blunt", 50 )
            add_ac( "pierce", "pierce", 20 )
            add_ac( "sharp", "sharp", 20 )
            add_attack( "bite", 20, [40, 8, 10] )
            add_attack( "feet", 50, [60, 10, 40] )
            set_stats( [4, -2, -4, 6, -6] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "horns" )
            thing.remove_attack( "hoof" )
            if( number < 10 )
            number = 10
            thing.add_attack( "horns", 40, [60, 10, 40],
            "pierce", "unarmed", 0 )
            thing.add_attack( "hoof", 60, [40, 8, 10],
            "blunt", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "crab" )
            set_long( "A scuttling crab.\n" )
            set_height( 10 )
            set_weight( 18 )
            set_desc( "a scuttling crab" )
            bits = ({
            "head", "head", [0, 200, 0,
            "left antenna", "right antenna", "left antennule", "right "
            "antennule", "brain", "left eye", "right eye", "left eyestalk",
            "right eyestalk", "jaw", "skull"],
            "left antenna", "antenna", ["head", 2, 0],
            "right antenna", "antenna", ["head", 2, 0],
            "left antennule", "antennule", ["head", 1, 0],
            "right antennule", "antennule", ["head", 1, 0],
            "brain", "brain", ["head", 50, 0],
            "skull", "skull", ["head", 50, 0],
            "left eye", "eye", ["head", 5, 0],
            "right eye", "eye", ["head", 5, 0],
            "left eyestalk", "eyestalk", ["head", 2, 0],
            "right eyestalk", "eyestalk", ["head", 2, 0],
            "jaw", "mouth", ["head", 25, 0],
            "carapace", "carapace", [0, 25, 0],
            "thorax", "thorax", [0, 500, 0,
            "left cheliped", "right cheliped", "left second leg",
            "right second leg", "left third leg", "right third leg", "left "
            "fourth leg", "right fourth leg", "left back leg", "right back "
            "leg", "heart", "hepatopancreas", "intestine", "stomach"],
            "left cheliped", "cheliped", ["thorax", 75, 0],
            "right cheliped", "cheliped", ["thorax", 75, 0],
            "left second leg", "leg", ["thorax", 50, 0],
            "right second leg", "leg", ["thorax", 50, 0],
            "left third leg", "leg", ["thorax", 50, 0],
            "right third leg", "leg", ["thorax", 50, 0],
            "left fourth leg", "leg", ["thorax", 50, 0],
            "right fourth leg", "leg", ["thorax", 50, 0],
            "left back leg", "leg", ["thorax", 50, 0],
            "right back leg", "leg", ["thorax", 50, 0],
            "heart", "heart", ["thorax", 50, 0],
            "hepatopancreas", "hepatopancreas", ["thorax", 10, 0],
            "intestine", "intestine", ["thorax", 30, 0],
            "stomach", "stomach", ["thorax", 30, 0],
            "apron", "apron", [0, 100, 0, "left pleopod", "right pleopod"],
            "left pleopod", "pleopod", ["apron", 20, 0],
            "right pleopod", "pleopod", ["apron", 20, 0]
            })
            inedible = ["jaw", "carapace", "skull"]
            unrottable = ["jaw", "carapace", "skull"]
            set_skin( "shell" )
            set_stats( [-6, 4, -6, -4, -6] )


    def query_eat(self, type: str) -> int:
            return ( inedible .index( type) if  type in inedible  else -1 == -1 )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            thing.add_skill_level( "other.health", level * 2 )
            thing.add_ac( "blunt", "blunt", level / 2 )
            thing.add_ac( "pierce", "pierce", level / 4 )
            thing.add_ac( "sharp", "sharp", level / 3 )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "pincers" )
            thing.add_attack( "pincers", 100, [number, 10, number],
            "unarmed", "unarmed", 0 )
            thing->add_attack_message( "pincers", "unarmed", ({
            20, "$N bat$s $I with $p pincer",
            60, "$N nip$s $P $z with $p pincer",
            100, "$N scratch$es $I deeply with $p pincer",
            140, "$N cut$s $P $z deeply with $p pincer",
            180, "$N dig$s $p pincer into $P $z",
            220, "$N gouge$s $I with $p pincer",
            0, "$N slice$s $P $z up with $p pincer"] )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "crocodile" )
            set_long( "Any of several large voracious thick-skinned long-bodied "
            "aquatic reptiles (as of the genus Crocodylus) of tropical and "
            "subtropical waters.\n" )
            set_height( 30 )
            set_weight( 5000 )
            set_desc( "a crocodile, sharp of tooth and vicious of temper." )
            add_ac( "blunt", "blunt", 80 )
            add_ac( "pierce", "pierce", 80 )
            add_ac( "sharp", "sharp", 80 )
            set_stats( [6, 4, -4, 8, -4] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "chew" )
            thing.remove_attack( "tail" )
            thing.add_attack( "chew", 75, [3 * number, number, number],
            "sharp", "unarmed", 0 )
            thing.add_attack( "tail", 75, [number, number, number],
            "blunt", "unarmed", 0 )
            thing.tactics( "response dodge" )
            thing.tactics( "attitude offensive" )


    def setup(self, ) -> None:
            set_name( "deer" )
            set_long( "A medium-sized hoofed mammal.  Surprise.\n" )
            set_height( 250 )
            set_weight( 4000 )
            bits= ({
            "head", "head", [0, 120, 0,
            "left eye", "right eye", "skull", "brain", "left ear",
            "right ear", "tongue"],
            "left antler", "antler", ["head", 30, 0],
            "right antler", "antler", ["head", 30, 0],
            "left eye", "eye", ["head", 2, 0],
            "right eye", "eye", ["head", 2, 0],
            "skull", "cranium", ["head", 45, 0, "teeth"],
            "brain", "brain", ["head", 20, 0],
            "left ear", "ear", ({"head", 4, 0],
            "right ear", "ear", ({"head", 4, 0],
            "teeth", "teeth", ["skull", 5, ({"/std/bit_set", 1})],
            "tooth", "tooth", ["teeth", 1, ({"/std/bit", 18})],
            "tongue", "tongue", ["head", 9, 0],
            "neck", "neck", [0, 120, 0],
            "torso", "body", [0, 400, 0,
            "heart", "liver", "left kidney", "right kidney", "left lung",
            "right lung", "spleen", "intestine", "pancreas"],
            "heart", "heart", ["torso", 35, 0],
            "liver", "liver", ["torso", 35, 0],
            "left kidney", "kidney", ["torso", 20, 0],
            "right kidney", "kidney", ["torso", 20, 0],
            "left lung", "lung", ["torso", 35, 0],
            "right lung", "lung", ["torso", 35, 0],
            "spleen", "spleen", ["torso", 20, 0],
            "intestine", "gut", ["torso", 75, 0],
            "pancreas", "pancreas", ["torso", 20, 0],
            "left front leg", "leg", [0, 140, 0, "left front hoof"],
            "left front hoof", "hoof", ["left front leg", 20, 0],
            "right front leg", "leg", [0, 140, 0, "right front hoof"],
            "right front hoof", "hoof", ["right front leg", 20, 0],
            "left rear leg", "leg", [0, 160, 0, "left rear hoof"],
            "left rear hoof", "hoof", ["left rear leg", 20, 0],
            "right rear leg", "leg", [0, 160, 0, "right rear hoof"],
            "right rear hoof", "hoof", ["right rear leg", 20, 0],
            "tail", "tail", [0, 15, 0],
            "skin", "skin", [0, 175, 0]
            })
            inedible = ["skull", "left front hoof", "right front hoof", "left antler", "right antler",
            "left rear hoof", "right rear hoof", "tail", "teeth", "tooth"]
            unrottable = ["skull", "left front hoof", "right front hoof", "left antler", "right antler",
            "left rear hoof", "right rear hoof", "teeth", "tooth"]
            set_desc( "a medium-sized, hairy quadruped.  It looks like a deer" )
            add_ac( "blunt", "blunt", 50 )
            add_ac( "sharp", "sharp", 20 )
            add_ac( "pierce", "pierce", 20 )
            set_skin( "skin" )
            set_stats( [4, 4, -2, 6, -2] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "antlers" )
            thing.remove_attack( "hoof" )
            thing.add_attack( "antlers", 40, [number, 2, number],
            "pierce", "unarmed", 0 )
            thing.add_attack( "hoof", 60, [number / 2, 5, number],
            "blunt", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_long( "This is one of the denizens of the Underworld.\n" )
            set_name( "demon" )
            set_height( 250 )
            set_weight( 5000 )
            set_desc( "a nasty-looking demon" )
            add_ac( "fire", "fire", 100 )
            set_stats( [10, 0, -2, 10, 4] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            thing.add_skill_level( "other.health", level * 2 )
            thing.add_ac( "blunt", "blunt", level / 2 )
            thing.add_ac( "pierce", "pierce", level / 4 )
            thing.add_ac( "sharp", "sharp", level / 3 )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "claws" )
            thing.remove_attack( "bite" )
            thing.add_attack( "claws", 75, [2 * number, 8, number],
            "sharp", "unarmed", 0 )
            thing.add_attack( "bite", 25, [3 * number, 10, number],
            "pierce", "unarmed", 0 )


    def setup(self, ) -> None:
            set_name( "dog" )
            set_long( "A street dog. I wouldn't stay too near, it could bite.\n" )
            set_desc( "a nasty dog" )
            set_height( 50 )
            set_weight( 700 )
            set_stats( [4, 10, -2, 6, -4] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            thing.add_ac( "blunt", "blunt", 40 )
            thing.add_ac( "sharp", "sharp", 20 )
            thing.add_ac( "pierce", "pierce", 10 )
            thing.add_skill_level( "other.perception", 200 )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "claws" )
            thing.remove_attack( "bite" )
            thing.add_attack( "claws", 100, [( 3 * number ) / 2, 5, number } ),
            "sharp", "unarmed", 0 )
            thing.add_attack( "bite", 50, [3 * number, 2, number],
            "pierce", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "duck" )
            set_long( "Ducks.  That's all there is to say.  Ducks, ducks, ducks, "
            "ducks, ducks.  Thank you.\n" )
            set_weight( 80 )
            set_height( 30 )
            set_desc( "an ordinary brain-dead duck" )
            add_ac( "feather_blow", "blunt", 10 )
            add_ac( "feather_slash", "sharp", 2 )
            add_ac( "feather_pierce", "pierce", 2 )
            set_stats( [0, 14, -6, -4, -6] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number / 4 ) + ( thing.query_weight() / 20 )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "beak" )
            thing.add_attack( "beak", 50, [number / 2, 2, number / 2],
            "pierce", "unarmed", 0 )
            thing.add_attack( "feet", 75, [number, 5, number / 2],
            "blunt", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "duckling" )
            set_long( "Awwwwwwww it's SUCH a cute little duckling!\n" )
            set_weight( 10 )
            set_height( 15 )
            set_desc( "an cute ickle duckling" )
            add_ac( "feather_blow", "blunt", 10 )
            add_ac( "feather_slash", "sharp", 2 )
            add_ac( "feather_pierce", "pierce", 2 )
            set_stats( [0, 14, -6, -4, -6] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number / 4 ) + ( thing.query_weight() / 20 )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "beak" )
            thing.add_attack( "beak", 50, [number / 2, 2, number / 2],
            "pierce", "unarmed", 0 )
            thing.add_attack( "feet", 75, [number, 5, number / 2],
            "blunt", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "elephant" )
            set_long( "This is an elephant.  A large creature with a thick grey "
            "hide.  He seems to weigh a lot so don't let him step on your "
            "toe.\n" )
            set_height( 280 )
            set_weight( 100000 )
            set_desc( "an elephant that looks back at you with small nice eyes" )
            remove_bit( "nose" )
            remove_bit( "head" )
            add_bit( "head", "head", [0, 135, 0,
            "left eye", "right eye", "skull", "tongue", "left ear", "right ear",
            "right tusk" "left tusk", "trunk"] )
            add_bit( "right tusk", "tusk", ["head", 20, ["/std/bit", 2]] )
            add_bit( "left tusk", "tusk", ["head", 20, ["/std/bit", 2]] )
            add_bit( "trunk", "trunk", ["head", 30, 0] )
            remove_bit( "left front leg" )
            remove_bit( "right front leg" )
            remove_bit( "left rear leg" )
            remove_bit( "right rear leg" )
            remove_bit( "left front hoof" )
            remove_bit( "right front hoof" )
            remove_bit( "left rear hoof" )
            remove_bit( "right rear hoof" )
            add_bit( "left front leg", "leg", [0, 150, 0, "left front foot"] )
            add_bit( "right front leg", "leg", [0, 150, 0, "right front foot"] )
            add_bit( "left rear leg", "leg", [0, 150, 0, "left rear leg"] )
            add_bit( "right rear leg", "leg", [0, 150, 0, "right rear leg"] )
            add_bit( "left front foot", "foot", ["left front leg", 30, 0] )
            add_bit( "right front foot", "foot", ["right front leg", 30, 0] )
            add_bit( "left rear foot", "foot", ["left rear leg", 30, 0] )
            add_bit( "right rear foot", "foot", ["right rear leg", 30, 0] )
            add_bit( "tail", "tail", [0, 15, 0] )
            inedible += ["tail", "right tusk", "left tusk"]
            unrottable += ["left tusk", "right tusk"]
            add_ac( "blunt", "blunt", [40, 20}) )
            add_ac( "pierce", "pierce", [30, 20] )
            add_ac( "sharp", "sharp", [50, 20] )
            add_ac( "acid", "acid", 20 )
            add_ac( "fire", "fire", 20 )
            set_stats( [30, -6, -4, 16, -2] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            thing.remove_attack( "hands" )
            thing.remove_attack( "tusks" )
            thing.remove_attack( "crush" )
            thing.remove_attack( "ram" )
            thing.add_attack( "tusks", 25, ({200, 10, 30}), "pierce", "unarmed", 0 )
            thing.add_attack( "crush", 10, ({300, 10, 50}), "blunt", "unarmed", 0 )
            thing->add_attack_message( "crush", "unarmed", ({
            0, "$N stand$s on $p hind legs and attempt$s to crash down on $I",
            200, "$N stand$s on $p hind legs and crash$es down, striking $I "
            "a glancing blow",
            400, "$N stand$s on $p hind legs and crash$es down on $I, crushing "
            "$P $z",
            5000, "$N stand$s on $p hind legs and crash$es down on $I, crushing "
            "$P $z into a bloody mess"] )
            thing.add_attack( "ram", 25, ({200, 10, 20}), "blunt", "unarmed", 0 )
            thing->add_attack_message( "ram", "unarmed", ({
            0, "$N charge$s at $I",
            200, "$N charge$s $I and strike$s $I",
            400, "$N charge$s $I and strike$s $P $z hard, making $I stagger "
            "around",
            5000, "$N charge$s $I and strike$s $I to the ground.  $I "
            "stumbles around a little groggily"] )
            thing.add_attack( "trunk", 50, ({100, 5, 20}), "blunt", "unarmed", 0 )
            thing->add_attack_message( "trunk", "unarmed", ({
            0, "$N swing$s $p trunk at $I",
            200, "$N swing$s $p trunk at $I, hitting $P $z hard",
            400, "$N swing$s $p trunk, which thumps forcefully into $P $z",
            5000, "$N swing$s $p trunk at $I, nearly knocking $I down"] )


    def map_target_zone(self, zone: str) -> str:
            switch(zone) {
            case "chest":
            return random(4) ? "back" : "chest"
            case "abdomen":
            return random(4) ? "stomach" : "lower back"
            case "arms":
            return (random(2) ? "left " : "right ") + "front leg"
            case "hands":
            return (random(2) ? "left " : "right ") + "front foot"
            case "legs":
            return (random(2) ? "left " : "right ") + "rear leg"
            case "feet":
            return (random(2) ? "left " :"right ") + "rear foot"
            default:
            return zone


    def setup(self, ) -> None:
            set_name( "ferret" )
            set_long( "A small black white and grey animal.\n" )
            set_height( 15 )
            set_weight( 30 )
            set_desc( "small brown meateater" )
            set_stats( [-2, 8, -2, -4, -4] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            level = 1 + ( 2 * level + random( level ) ) / 8
            thing.add_ac( "blunt", "blunt", 20 + level / 3 )
            thing.add_ac( "sharp", "sharp", 50 + level )
            thing.add_ac( "pierce", "pierce", 60 + 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number ) / 2
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "claws" )
            thing.remove_attack( "bite" )
            thing.add_attack( "claws", 50, [( 4 * number ) / 2, 8, 2 * number],
            "sharp", "unarmed", 0 )
            thing.add_attack( "bite", 100, [2 * number, 10, ( 3 * number ) / 2],
            "pierce", "unarmed", 0  )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "fish" )
            set_long( "Fish,  yes.  A fish.  Nice generic standard fish thing.\n" )
            set_height( 15 )
            set_weight( 40 )
            set_desc( "a fish, the kind with fins" )
            set_stats( [-2, 14, -4, -4, -6] )


    def check_water(self, player: MudObject) -> None:
            if( !environment( player )->query_water() )
            asyncio.create_task(self. "do_drown", 4, player )


    def do_drown(self, player: MudObject) -> None:
            int i
            if( environment( player )->query_water() )
            return
            tell_room( environment( player ) , player.one_short() + " gasps for "
            "air.\n" )
            i = player.query_max_hp() / 5
            if( i < 20 ) i = 20
            player.adjust_hp( -i )
            asyncio.create_task(self. "do_drown", 4, player )


    def start_player(self, thing: MudObject) -> None:
            ::start_player( thing )
            thing.add_property( "gills", 1 )
            thing.add_property("lives in water", 1)
            thing.add_enter_commands( (: check_water :) )
            thing.set_default_position( ["lying"] )
            thing.return_to_default_position( 0 )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number ) / 2
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "bite" )
            thing.add_attack( "bite", 100, [2 * number, 5, number],
            "pierce", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def __init__(self):
            self.bits = []
            self.inedible = ['left petral fin', 'right petral fin', 'dorsal petral fin']
            self.unrottable = []


    def __init__(self):
            self.bits = []
            self.inedible = ['left petral fin', 'right petral fin', 'dorsal petral fin']
            self.unrottable = []
            string *query_target_zones() {
            return ["head", "head",
            "body","body", "body", "body", "body", "body",
            "left petral fin", "right petral fin",
            "dorsal fin", "body",
            "body", "body",
            "body", "body",
            "body", "body", "body", "body", "body"
            "body", "body",
            "tail", "tail"]


    def map_target_zone(self, zone: str) -> str:
            switch(zone) {
            case "head":
            return zone
            case "arms":
            return (random(2) ? "left " : "right ") + "petral fin"
            case "hands":
            return "dorsal fin"
            case "feet":
            return "tail"
            default:
            return "body"


    def setup(self, ) -> None:
            set_name( "fox" )
            set_long( "A cat-like creature with red fur, hunts small, "
            "animals like mice and rabbits.\n" )
            set_height( 30 )
            set_weight( 400 )
            set_desc( "A small red fox" )
            set_stats( [0, 10, -2, 4, -4] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            level = 1 + ( 2 * level + random( level ) ) / 10
            thing.add_ac( "blunt", "blunt", level )
            thing.add_ac( "sharp", "sharp", 2 + level )
            thing.add_ac( "pierce", "pierce", 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "bite" )
            thing.remove_attack( "claws" )
            thing.add_attack( "bite", 100, [number / 2, 2, number],
            "pierce", "unarmed", 0 )
            thing.add_attack( "claws", 150, [number / 2, 2, number],
            "sharp", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "frog" )
            set_long( "Frogs are amphibians" )
            set_height(10)
            set_weight(10)
            set_desc( "an innocent little froggie" )
            add_ac( "blunt", "blunt", 5 )
            add_ac( "pierce", "pierce", 4 )
            add_ac( "sharp", "sharp", 3 )
            add_attack( "bite", 50, [10, 2, 6] )
            set_sight( [5, 20, 200, 300] )
            set_stats( [-4, 10, -4, -4, -6] )


    def start_player(self, thing: MudObject) -> None:
            ::start_player( thing )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "gnome" )
            set_long( "This is the race for gnomes.\n" )
            set_desc( "a short-looking gnome" )
            set_weight( 25 )
            set_height( 20 )
            set_sight( [0, 5, 150, 200] )
            set_stats( [-2, 8, 0, 6, 0] )


    def setup(self, ) -> None:
            set_name( "goat" )
            set_long( "A cloven-hoofed, horned mammal closely related to the "
            "sheep.\n" )
            set_desc( "a cloven-hoofed, horned mammal" )
            set_weight( 800 )
            set_height( 80 )
            remove_bit( "head" )
            add_bit( "head", "head", [0, 135, 0,
            "left eye", "right eye", "nose", "skull", "tongue", "left ear",
            "right ear", "left horn", "right horn"] )
            add_bit( "left horn", "horn", ["head", 5, 0] )
            add_bit( "right horn", "horn", ["head", 5, 0] )
            inedible += ["left horn", "right horn"]
            set_stats( [4, 8, 0, 2, -4] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "standard" )
            thing.remove_attack( "horns" )
            thing.remove_attack( "hoof" )
            thing.add_attack( "horns", 60, [21, 8, 11],
            "pierce", "unarmed", 0 )
            thing.add_attack( "hoof", 60, [32, 10, 11],
            "blunt", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "golem" )
            set_long( "Golems are artifical shaped of clay to resemble humanoids and "
            "animated using religious rituals.  If they are actually alive is a "
            "question under constant debate.\n" )
            set_height( 200 )
            set_weight( 40000 )
            set_desc( "a tall, human-shaped creature made of clay" )
            add_property( "no scry", 1 )
            add_ac( "blunt", "pierce", ({150}) )
            add_ac( "pierce", "pierce", ({250}) )
            add_ac( "sharp", "sharp", ({250}) )
            add_ac( "fire", "fire", ({10000}) )
            add_ac( "cold", "cold", ({10000}) )
            add_ac( "acid", "acid", ({10000}) )
            add_ac( "magic", "magic", ({10000}) )
            set_sight( [0, 5, 100, 125] )
            set_stats( [30, 10, 0, 40, 0] )


    def make_corpse(self, ) -> MudObject:
            object corpse, owner
            owner = previous_object()
            corpse = ARMOURY.request_item( "golem corpse", 100 )
            all_inventory( owner )->move( corpse )
            return corpse


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            if( !thing )
            return
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.add_attack( "hands", 75, [50, 10, 15],
            "blunt", "unarmed", ["unarmed_hands", self] )


    def knock_out(self, player: MudObject, golem: MudObject) -> None:
            object room, target
            string *all_exits, *no_doors = [})
            string exit
            int i
            if( !player || !golem )
            return
            player.stop_all_fight()
            golem.stop_fight( player )
            if( !( room = environment( golem ) ) )
            return
            all_exits = room.query_dest_dir()
            for( i = 0; i < sizeof( all_exits ); i += 2 )
            if( !room.query_door( all_exits[i], "door" ) )
            no_doors += [all_exits[i + 1] ]
            target = load_object( no_doors[ random( sizeof( no_doors ) ) ] )
            tell_object( player,
            golem.the_short() + "' blow lifts you off your feet and hurls "
            "you through the air.\n"
            "You see the world race past you and then the ground approaching very "
            "fast.\n" )
            if( target ) {
            exit = all_exits[ all_exits .index( file_name( target )) if  file_name( target ) in all_exits  else -1 - 1 ]
            player->move( target,
            "$N come$s flying through the air from $F in a high arc and "
            "thump$s onto the ground.",
            "$N is lifted off " + player.query_possessive() + " feet by " +
            golem.the_short() + "'s blow and sail$s out of the room "
            "to the " + exit + "." )
            } else
            tell_room( room,
            player.the_short() + " is lifted off " +
            player.query_possessive() + " feet by " +
            golem.the_short() + "'s blow and smashes to the "
            "ground.\n", ({player}) )
            player.set_position( "lying on the ground unconscious" )
            player.add_property( "passed out", 1, ( 150 + random( 150 ) ) )


    def stone_skinned(self, ) -> int:
            return 1


    def setup(self, ) -> None:
            set_name( "guppy" )
            set_long( "Fish,  yes.  A fish.  Nice generic standard fish thing.\n" )
            set_height( 15 )
            set_weight( 40 )
            set_desc( "a beautiful looking guppy" )
            set_stats( [-2, 14, -4, -4, -6] )


    def start_player(self, thing: MudObject) -> None:
            ::start_player( thing )
            thing.add_property( "gills", 1 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "hare" )
            set_long( "This is a hare with long ears.\n" )
            set_height( 50 )
            set_weight( 100 )
            set_desc( "a large and meaty hare" )
            set_stats( [-2, 8, -4, -4, -6] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            thing.add_ac( "blunt", "blunt", level )
            thing.add_ac( "sharp", "sharp", 2 + level )
            thing.add_ac( "pierce", "pierce", 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number ) / 6
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "bite" )
            thing.add_attack( "bite", 75, [0, 3, 5],
            "pierce", "unarmed", 0 )
            thing.tactics( "response dodge" )
            thing.tactics( "attitude defensive" )


    def setup(self, ) -> None:
            set_name( "hedgehog" )
            set_long( "A snail and worm eating little bugger.\n" )
            set_height( 30 )
            set_weight( 150 )
            set_desc( "A small spiny hedgehog" )
            set_stats( [2, -2, -4, -2, -6] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            level = 1 + ( 2 * level + random( level ) ) / 10
            thing.add_ac( "blunt", "blunt", level )
            thing.add_ac( "sharp", "sharp", 2 + level )
            thing.add_ac( "pierce", "pierce", 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "bite" )
            thing.remove_attack( "claws" )
            thing.add_attack( "bite", 100, [number / 2, 2, number],
            "pierce", "unarmed", 0 )
            thing.add_attack( "claws", 150, [number / 2, 2, number],
            "sharp", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "elephant" )
            set_long( "This is an elephant.  A large creature with a thick grey "
            "hide.  He seems to weigh a lot so don't let him step on your "
            "toe.\n" )
            set_height( 280 )
            set_weight( 100000 )
            set_desc( "an elephant that looks back at you with small nice eyes" )
            remove_bit( "nose" )
            remove_bit( "head" )
            add_bit( "head", "head", [0, 135, 0,
            "left eye", "right eye", "skull", "tongue", "left ear", "right ear",
            "tusk", "tusks", "trunk"] )
            add_bit( "tail", "tail", [0, 15, 0] )
            add_bit( "tusk", "tusk", ["head", 20, ({"/std/bit_set", 1}),
            "tusks"] )
            add_bit( "tusks", "tusks", ["head", 40, ({"/std/bit", 2})] )
            add_bit( "trunk", "trunk", ["head", 30, 0] )
            inedible += ["tail", "tusk", "tusks"]
            unrottable += ["tusk", "tusks"]
            add_ac( "blunt", "blunt", [40, 20}) )
            add_ac( "pierce", "pierce", [30, 20] )
            add_ac( "sharp", "sharp", [50, 20] )
            add_ac( "acid", "acid", 20 )
            add_ac( "fire", "fire", 20 )
            set_stats( [10, -6, -4, 16, -2] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            thing.remove_attack( "hands" )
            thing.remove_attack( "tusks" )
            thing.remove_attack( "crush" )
            thing.remove_attack( "ram" )
            thing.add_attack( "tusks", 20, ({75, 5, 30}),
            "pierce", "unarmed", 0 )
            thing.add_attack( "crush", 10, ({100, 5, 50}),
            "blunt", "unarmed", 0 )
            thing->add_attack_message( "crush", "unarmed", ({
            0, "$N stand$s on $p hind legs and attempt$s to crash down on $I",
            100, "$N stand$s on $p hind legs and crash$es down stricking $I "
            "a glancing blow ",
            150, "$N stand$s on $p hind legs and crash$es down on $I, crushing "
            "$P $z",
            350, "$N stand$s on $p hind legs and crash$es down on $I, crushing "
            "$P $z into a bloody mess"] )
            thing.add_attack( "ram", 10, ({50, 3, 20}),
            "blunt", "unarmed", 0 )
            thing->add_attack_message( "ram", "unarmed", ({
            0, "$N charge$s at $I",
            100, "$N charge$s $I and strike$s $I",
            150, "$N charge$s $I and strike$s $P $z hard, making $I stagger "
            "around",
            350, "$N charge$s $I and strike$s $I to the ground.  $I "
            "stumbles around a little groggily"] )
            thing.add_attack( "trunk", 20, ({50, 3, 20}),
            "blunt", "unarmed", 0 )
            thing->add_attack_message( "trunk", "unarmed", ({
            0, "$N swing$s $p trunk at $I",
            100, "$N swing$s $p trunk at $I, hitting $P $z hard",
            150, "$N swing$s $p trunk, which thumps forcefully into $P $z",
            350, "$N swing$s $p trunk at $I, knocking $I down.  $I "
            "gets up groggily"] )


    def setup(self, ) -> None:
            set_name( "horse" )
            set_long( "A large hoofed mammal.  Surprise.\n" )
            set_height( 200 )
            set_weight( 7000 )
            bits= ({
            "head", "head", [0, 120, 0,
            "left eye", "right eye", "skull", "brain", "left ear",
            "right ear", "tongue"],
            "left eye", "eye", ["head", 2, 0],
            "right eye", "eye", ["head", 2, 0],
            "skull", "cranium", ["head", 45, 0, "teeth"],
            "brain", "brain", ["head", 20, 0],
            "left ear", "ear", ({"head", 4, 0],
            "right ear", "ear", ({"head", 4, 0],
            "teeth", "teeth", ["skull", 5, ({"/std/bit_set", 1})],
            "tooth", "tooth", ["teeth", 1, ({"/std/bit", 18})],
            "tongue", "tongue", ["head", 9, 0],
            "neck", "neck", [0, 120, 0],
            "torso", "body", [0, 400, 0,
            "heart", "liver", "left kidney", "right kidney", "left lung",
            "right lung", "spleen", "intestine", "pancreas"],
            "heart", "heart", ["torso", 35, 0],
            "liver", "liver", ["torso", 35, 0],
            "left kidney", "kidney", ["torso", 20, 0],
            "right kidney", "kidney", ["torso", 20, 0],
            "left lung", "lung", ["torso", 35, 0],
            "right lung", "lung", ["torso", 35, 0],
            "spleen", "spleen", ["torso", 20, 0],
            "intestine", "gut", ["torso", 75, 0],
            "pancreas", "pancreas", ["torso", 20, 0],
            "left front leg", "leg", [0, 140, 0, "left front hoof"],
            "left front hoof", "hoof", ["left front leg", 20, 0],
            "right front leg", "leg", [0, 140, 0, "right front hoof"],
            "right front hoof", "hoof", ["right front leg", 20, 0],
            "left rear leg", "leg", [0, 160, 0, "left rear hoof"],
            "left rear hoof", "hoof", ["left rear leg", 20, 0],
            "right rear leg", "leg", [0, 160, 0, "right rear hoof"],
            "right rear hoof", "hoof", ["right rear leg", 20, 0],
            "tail", "tail", [0, 15, 0],
            "skin", "skin", [0, 175, 0]
            })
            inedible = ["skull", "left front hoof", "right front hoof",
            "left rear hoof", "right rear hoof", "tail", "teeth", "tooth"]
            unrottable = ["skull", "left front hoof", "right front hoof",
            "left rear hoof", "right rear hoof", "teeth", "tooth"]
            set_desc( "a large, hairy quadruped.  It looks like a horse" )
            add_ac( "blunt", "blunt", 50 )
            add_ac( "sharp", "sharp", 20 )
            add_ac( "pierce", "pierce", 20 )
            set_skin( "skin" )
            set_stats( [4, 4, -2, 6, -2] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "chew" )
            thing.remove_attack( "hoof" )
            thing.add_attack( "chew", 50, [number, 2, number],
            "sharp", "unarmed", 0 )
            thing.add_attack( "hoof", 70, [number / 2, 5, number],
            "blunt", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_long("The human race.  The standard by which all the races are set, "+
            "this is race can be considered the norm.\n")
            set_name("human")
            set_weight(1600)
            set_height(175)
            add_ac( "blunt", "blunt", 3 )
            add_ac( "pierce", "pierce", 2 )
            add_ac( "sharp", "sharp", 2 )
            set_sight( [5, 25, 200, 300] )


    def query_desc(self, thing: MudObject) -> str:
            if ( (int)thing.query_gender() == 1 )
            return "He is a strapping young human lad.\n"
            if ( (int)thing.query_gender() == 2 )
            return "She is a strapping young human lass.\n"
            return "It is a strapping young human.\n"


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.add_attack( "hands", 75, [2 * number, 5, number], "blunt",
            "unarmed", "unarmed_hands" )
            thing.add_attack( "feet", 25, [3 * number, 7, number], "blunt",
            "unarmed", 0 )


    def temperature_effects(self, thing: MudObject, temperature: int) -> str:
            string temperature_str
            switch(temperature/3) {
            case 101 .. 1000:
            thing.dest_hide_shadow()
            await  thing.send("The heat is just too much for you.\n" )
            tell_room( environment( thing ), "Sweating profusely and turning "
            "a nasty red-purple colour "+
            (string)thing.the_short() +" expires.\n", thing )
            thing.do_death()
            temperature_str = ""
            break
            case 81 .. 100:
            temperature_str = "close to death from extreme heatstroke"
            thing.adjust_tmp_wis(-1)
            thing.adjust_tmp_int(-1)
            break
            case 51 .. 80:
            temperature_str = "sick from heatstroke"
            if(!random(2))
            thing.adjust_tmp_wis(-1)
            if(!random(2))
            thing.adjust_tmp_int(-1)
            break
            case 21 .. 50:
            temperature_str = "very hot"
            await thing.send("You feel really hot.\n")
            break
            case 11 .. 20:
            temperature_str = "rather warm"
            await thing.send("You feel quite warm.\n")
            break
            case -10 .. 10:
            temperature_str = ""
            break
            case -20 .. -11 :
            temperature_str = "rather cold"
            await thing.send("You feel quite cold.\n")
            break
            case -50 .. -21 :
            temperature_str = "very cold"
            await thing.send("You feel cold to your bones.\n")
            break
            case -80 .. -51 :
            temperature_str = "sick from hypothermia"
            await thing.send("You're so cold you feel your energy being drained.\n")
            if(!random(2))
            thing.adjust_tmp_str(-1)
            if(!random(2))
            thing.adjust_tmp_con(-1)
            break
            case -100 .. -81 :
            temperature_str = "close to death from extreme hypothermia"
            tell_object(thing, "You're so cold you feel as though you're about to "
            "expire.\n")
            thing.adjust_tmp_str(-1)
            thing.adjust_tmp_con(-1)
            break
            case -1000 .. -101:
            thing.dest_hide_shadow()
            await  thing.send("The cold is just too much for you.\n" )
            tell_room( environment( thing ), "Frost riming "+
            (string)thing.query_possessive() +" skin in a thick crust, "+
            (string)thing.the_short() +" expires.\n", thing )
            thing.do_death()
            temperature_str = ""
            break


    def __init__(self):
            self.bits = []
            self.inedible = ['skull', 'teeth', 'tooth', 'rib', 'left femur', 'right femur']
            self.unrottable = ['skull', 'teeth', 'tooth', 'rib', 'left femur', 'right femur']


    def query_humanoid(self, ) -> int:
            return 1


    def map_target_zone(self, zone: str) -> str:
            switch(zone) {
            case "abdomen":
            return "stomach"
            case "arms":
            return (random(2) ? "left " : "right ") + "arm"
            case "hands":
            return (random(2) ? "left " : "right ") + "hand"
            case "legs":
            return (random(2) ? "left " : "right ") + "leg"
            case "feet":
            return (random(2) ? "left " :"right ") + "foot"
            default:
            return zone


    def setup(self, ) -> None:
            set_long( "This is one of the smaller denizens of the Underworld.\n" )
            set_name( "imp" )
            set_height( 50 )
            set_weight( 400 )
            set_desc( "a crafty-looking imp" )
            set_stats( [2, 8, 2, 2, 2] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            thing.add_skill_level( "other.health", level * 4 )
            thing.add_ac( "blunt", "blunt", level / 4 )
            thing.add_ac( "pierce", "pierce", level / 8 )
            thing.add_ac( "sharp", "sharp", level / 6 )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 6 + sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.add_attack( "hands", 75, [2 * number, 8, number],
            "blunt", "unarmed", 0 )
            thing.add_attack( "feet", 25, [3 * number, 10, number],
            "blunt", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "insect" )
            set_long( "A nondescript insect.\n" )
            set_height( 5 )
            set_weight( 2 )
            set_desc( "a nondescript insect" )
            set_stats( [-6, 4, -6, -6, -6] )


    def query_eat(self, type: str) -> int:
            return ( inedible .index( type) if  type in inedible  else -1 == -1 )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            thing.add_skill_level( "other.health", level * 2 )
            thing.add_ac( "blunt", "blunt", level / 2 )
            thing.add_ac( "pierce", "pierce", level / 4 )
            thing.add_ac( "sharp", "sharp", level / 3 )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "bite" )
            thing.add_attack( "bite", 75, [3 * number, 10, number],
            "pierce", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def __init__(self):
            self.bits = []
            self.inedible = ['mandible']
            self.unrottable = ['mandible']


    def map_target_zone(self, zone: str) -> str:
            switch(zone) {
            case "neck":
            case "chest":
            return "thorax"
            case "arms":
            case "hands":
            return (random(2) ? "left " : "right ") +
            (random(2) ? "front " : "middle ") + "leg"
            case "feet":
            case "legs":
            return (random(2) ? "left " : "right ") + "rear leg"
            default:
            return zone


    def setup(self, ) -> None:
            set_name( "jellyfish" )
            set_long( "A jelly-like blob with tendrils.\n" )
            set_height( 15 )
            set_weight( 20 )
            set_desc( "a jelly-like blob with tendrils." )
            bits = ({
            "tendril", "tendril", [0, 1, ["/std/bit", 10]],
            "bell", "bell", [0, 10, 0]
            })
            inedible = ["bell", "tendril"]
            unrottable = [})
            set_skin( "exocuticule" )
            add_ac( "acid", "acid", 100 )
            add_ac( "poison", "poison", 100 )
            add_ac( "blunt", "blunt", 75 )
            add_ac( "sharp", "sharp", 25 )
            add_ac( "pierce", "pierce", 25 )
            set_stats( [-5, -5, -5, -5, -5] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 2 + (sqrt( number ) / 10)
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "tendrils" )
            thing.add_attack( "tendrils", 100, [number, 10, number],
            "blunt", "blunt", ["sting", self] )
            thing->add_attack_message( "tendrils", "blunt", ({
            20, "$N brush$es $P $z with $p tendrils",
            60, "$N slap$s $P $z with $p tendrils",
            100, "$N knock$s $I with $p tendrils",
            140, "$N thwack$s $I with $p tendrils",
            180, "$N smack$s $p tendrils into $P $z",
            220, "$N wallop$s $I with $p tendrils",
            0, "$N hammer$s $I with $p tendrils"] )


    def start_player(self, thing: MudObject) -> None:
            ::start_player( thing )
            thing.add_property( "gills", 1 )
            thing.add_property("lives in water", 1)


    def sting(self, damage: int, him: MudObject, me: MudObject, atype: str, aname: str) -> None:
            him.add_effect(STINGEFFECT, damage)


    def __init__(self):
            self.bits = []
            self.inedible = ['skull', 'teeth', 'tooth', 'tail', 'skin']
            self.unrottable = ['skull', 'teeth', 'tooth']


    def map_target_zone(self, zone: str) -> str:
            switch(zone) {
            case "chest":
            return random(4) ? "back" : "chest"
            case "abdomen":
            return random(4) ? "stomach" : "lower back"
            case "arms":
            return (random(2) ? "left " : "right ") + "front leg"
            case "hands":
            return (random(2) ? "left " : "right ") + "front paw"
            case "legs":
            return (random(2) ? "left " : "right ") + "rear leg"
            case "feet":
            return (random(2) ? "left " :"right ") + "rear paw"
            default:
            return zone


    def setup(self, ) -> None:
            set_name( "light" )
            set_long( "A small sphere of magical blue light.\n" )
            set_weight( 1 )
            set_height( 1 )
            set_desc( "a small ball of blue light hovering in the air." )
            bits = [})
            inedible = [})
            unrottable = [})
            add_ac( "fire", "fire", 1000 )
            add_ac( "sound", "sound", 1000 )
            add_ac( "acid", "acid", 1000 )
            add_ac( "gas", "gas", 1000 )
            add_ac( "mental", "mental", 100 )
            set_stats( [0, 14, -6, -6, -6] )


    def start_player(self, thing: MudObject) -> None:
            ::start_player( thing )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "lion" )
            set_long( "A carnivorous mammal.  This is the real thing though, not "
            "your domesticated house cat, but the king of its kind.  It leaps "
            "over the ground in huge bounding strides, power that other cats "
            "can only dream about.\n" )
            set_height( 150 )
            set_weight( 3500 )
            set_desc( "a rather large lion, bounding vigorously towards you" )
            add_bit( "bile duct", "duct", ["torso", 1, 0] )
            set_stats( [6, 10, -4, 10, -4] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            thing.add_ac( "blunt", "blunt", level )
            thing.add_ac( "sharp", "sharp", 2 + level )
            thing.add_ac( "pierce", "pierce", 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "claws" )
            thing.remove_attack( "bite" )
            if( number < 10 )
            number = 10
            thing.add_attack( "claws", 100, [number, 10, number],
            "sharp", "unarmed", 0 )
            thing.add_attack( "bite", 75, [3 * number, number / 2, number],
            "pierce", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "lobster" )
            set_long( "A cranky lobster.\n" )
            set_height( 10 )
            set_weight( 18 )
            set_desc( "a cranky lobster" )
            bits = ({
            "head", "head", [0, 200, 0,
            "left antenna", "right antenna", "left antennule", "right "
            "antennule", "brain", "left eye", "right eye", "left eyestalk",
            "right eyestalk", "jaw", "skull"],
            "left antenna", "antenna", ["head", 2, 0],
            "right antenna", "antenna", ["head", 2, 0],
            "left antennule", "antennule", ["head", 1, 0],
            "right antennule", "antennule", ["head", 1, 0],
            "brain", "brain", ["head", 50, 0],
            "skull", "skull", ["head", 50, 0],
            "left eye", "eye", ["head", 5, 0],
            "right eye", "eye", ["head", 5, 0],
            "left eyestalk", "eyestalk", ["head", 2, 0],
            "right eyestalk", "eyestalk", ["head", 2, 0],
            "jaw", "mouth", ["head", 25, 0],
            "carapace", "carapace", [0, 25, 0],
            "thorax", "thorax", [0, 500, 0,
            "left cheliped", "right cheliped", "left second leg",
            "right second leg", "left third leg", "right third leg", "left "
            "fourth leg", "right fourth leg", "left back leg", "right back "
            "leg", "heart", "hepatopancreas", "intestine", "stomach"],
            "left cheliped", "cheliped", ["thorax", 75, 0],
            "right cheliped", "cheliped", ["thorax", 75, 0],
            "left second leg", "leg", ["thorax", 50, 0],
            "right second leg", "leg", ["thorax", 50, 0],
            "left third leg", "leg", ["thorax", 50, 0],
            "right third leg", "leg", ["thorax", 50, 0],
            "left fourth leg", "leg", ["thorax", 50, 0],
            "right fourth leg", "leg", ["thorax", 50, 0],
            "left back leg", "leg", ["thorax", 50, 0],
            "right back leg", "leg", ["thorax", 50, 0],
            "heart", "heart", ["thorax", 50, 0],
            "hepatopancreas", "hepatopancreas", ["thorax", 10, 0],
            "intestine", "intestine", ["thorax", 30, 0],
            "stomach", "stomach", ["thorax", 30, 0],
            "apron", "apron", [0, 100, 0, "left pleopod", "right pleopod"],
            "left pleopod", "pleopod", ["apron", 20, 0],
            "right pleopod", "pleopod", ["apron", 20, 0]
            })
            inedible = ["jaw", "carapace", "skull"]
            unrottable = ["jaw", "carapace", "skull"]
            set_skin( "shell" )
            set_stats( [-6, 4, -6, -4, -6] )


    def query_eat(self, type: str) -> int:
            return ( inedible .index( type) if  type in inedible  else -1 == -1 )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            thing.add_skill_level( "other.health", level * 2 )
            thing.add_ac( "blunt", "blunt", level / 2 )
            thing.add_ac( "pierce", "pierce", level / 4 )
            thing.add_ac( "sharp", "sharp", level / 3 )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "pincers" )
            thing.add_attack( "pincers", 100, [number, 10, number],
            "unarmed", "unarmed", 0 )
            thing->add_attack_message( "pincers", "unarmed", ({
            20, "$N bat$s $I with $p pincer.\n",
            60, "$N nip$s $P $z with $p pincer.\n",
            100, "$N scratch$es $I deeply with $p pincer.\n",
            140, "$N cut$s $P $z deeply with $p pincer.\n",
            180, "$N dig$s $p pincer into $P $z.\n",
            220, "$N gouge$s $I with $p pincer.\n",
            0, "$N slice$s $P $z up with $p pincer.\n"] )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "luggage" )
            set_long( "A sapient pearwood luggage.\n" )
            set_desc( "a nice set of luggage" )
            set_height( 75 )
            set_weight( 5000 )
            bits = ({
            "trunk", "trunk", [0, 400, 0],
            "lid", "lid", [0, 1000, 0],
            "leg", "leg", [0, 5, ({"/std/bit", 50})]
            })
            inedible = ["trunk", "lid"]
            unrottable = ["trunk", "lid"]
            set_skin( "casing" )
            add_ac( "blunt", "blunt", 25 )
            add_ac( "pierce", "pierce", 25 )
            add_ac( "sound", "sound", 1000 )
            add_ac( "gas", "gas", 1000 )
            set_stats( [10, 6, -2, 10, -2] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number ) / 2
            thing.remove_attack( "hands" )
            thing.add_attack( "feet", 75, [5 * number, 10, number], "blunt",
            "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "mole" )
            set_long( "Any insectivore of the family Talpidae, which includes moles, "
            "shrew moles, and desmans.  They have no ears and tiny eyes, and live "
            "in small burrows.\n" )
            set_height( 30 )
            set_weight( 10 )
            set_desc( "This is a blind and deaf mole." )
            set_sight( [-100, -60, 40, 60] )
            set_stats( [-2, 2, -6, -2, -6] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number ) / 6
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "bite" )
            thing.remove_attack( "claws" )
            thing.add_attack( "bite", 75, [0, 3, number],
            "pierce", "unarmed", 0 )
            thing.add_attack( "claws", 50, [10, 5, number / 2],
            "sharp", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            mixed *new_head
            set_name( "moose" )
            set_long( "The moose is a large woodland animal.\n" )
            set_height( 200 )
            set_weight( 7000 )
            set_desc( "a large, hairy quadruped reminding you very much of a moose" )
            new_head = query_bit( "head" )
            new_head[ 2 ] += ["left horn", "right horn"]
            remove_bit( "head" )
            add_bit( "head", "head", new_head[ 2 ] )
            add_bit( "left horn", "horn", ["head", 20, 0] )
            add_bit( "right horn", "horn", ["head", 20, 0] )
            add_bit( "tail", "tail", [0, 15, 0] )
            inedible += ({"left horn", "right horn", "tail"]
            unrottable += ["left horn", "right horn"]
            add_ac( "blunt", "blunt", 50 )
            add_ac( "pierce", "pierce", 20 )
            add_ac( "sharp", "sharp", 20 )
            set_stats( [4, -2, -4, 8, -4] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "standard" )
            thing.remove_attack( "chew" )
            thing.remove_attack( "hoof" )
            thing.add_attack( "chew", 20, [40, 8, 10],
            "sharp", "unarmed", 0 )
            thing.add_attack( "hoof", 50, [60, 10, 40],
            "blunt", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "mouse" )
            set_long( "Any of numerous small rodents (as of the genus Mus) with "
            "pointed snout, rather small ears, elongated body and slender "
            "tail.\n" )
            set_height( 10 )
            set_weight( 5 )
            set_desc( "a little mouse, scurrying about for food." )
            set_stats( [-4, 8, -4, -4, -6] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            thing.add_ac( "blunt", "blunt", level )
            thing.add_ac( "sharp", "sharp", 2 + level )
            thing.add_ac( "pierce", "pierce", 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number ) / 6
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "bite" )
            thing.remove_attack( "claws" )
            thing.add_attack( "bite", 75, [0, 3, number],
            "pierce", "unarmed", 0 )
            thing.add_attack( "claws", 50, [0, 5, number / 2],
            "sharp", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "mustelidae" )
            set_long( "The typical weasel like animal.\n" )
            set_height( 15 )
            set_weight( 30 )
            set_desc( "small brown meateater" )
            set_stats( [-2, 8, -2, -4, -4] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            level = 2 + ( 2 * level + random( level ) ) / 8
            thing.add_ac( "blunt", "blunt", 20 + level / 3 )
            thing.add_ac( "sharp", "sharp", 50 + level )
            thing.add_ac( "pierce", "pierce", 60 + 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number ) / 2
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "claws" )
            thing.remove_attack( "bite" )
            thing.add_attack( "claws", 50, [( 4 * number ) / 2, 8, 2 * number],
            "sharp", "unarmed", 0 )
            thing.add_attack( "bite", 100, [2 * number, 10, ( 3 * number ) / 2],
            "pierce", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def __init__(self):
            self.bits = []
            self.inedible = ['skull', 'teeth', 'tooth', 'tail', 'skin']
            self.unrottable = ['skull', 'teeth', 'tooth']


    def setup(self, ) -> None:
            set_name( "panda" )
            set_desc( "a black and white fluffy panda" )
            set_height( 200 )
            set_weight( 8000 )
            set_stats( [6, 4, -2, 8, -4] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            level = 2 + ( 2 * level + random( level ) ) / 8
            thing.add_ac( "blunt", "blunt", 20 + level / 3 )
            thing.add_ac( "sharp", "sharp", 50 + level )
            thing.add_ac( "pierce", "pierce", 60 + 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number ) / 2
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "claws" )
            thing.remove_attack( "bite" )
            thing.add_attack( "claws", 100, [2 * number, 10, number],
            "sharp", "unarmed", 0 )
            thing.add_attack( "bite", 50, [3 * number, 8, number],
            "pierce", "unarmed", 0 )
            thing.tactics( "response dodge" )
            thing.tactics( "attitude offensive" )


    def setup(self, ) -> None:
            set_name( "parrot" )
            set_long( "This is a vicious, evil-looking parrot with a glint of mischief "
            "in its eye.\n" )
            set_weight( 25 )
            set_height( 20 )
            set_desc( "an ordinary parrot" )
            add_ac( "feather_blow", "blunt", 10 )
            add_ac( "feather_slash", "sharp", 2 )
            add_ac( "feather_pierce", "pierce", 2 )
            set_stats( [0, 8, -6, -4, -6] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number / 4 ) + ( thing.query_weight() / 20 )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "beak" )
            thing.remove_attack( "claws" )
            thing.add_attack( "beak", 50, [number / 2, 2, number / 2],
            "pierce", "unarmed", 0 )
            thing.add_attack( "claws", 75, [number, 5, number / 2],
            "sharp", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "penguin" )
            set_long( "Penguins are always rather formal.\n" )
            set_weight( 600 )
            remove_bit( "gizzard" )
            set_stats( [2, 8, -4, -4, -6] )


    def query_desc(self, ob: MudObject) -> str:
            return "Penguins are always rather formally dressed.\n"


    def setup(self, ) -> None:
            set_name( "pig" )
            set_long( "A domesticated mammal, of the swine family.\n" )
            set_desc( "a domesticated mammal, of the swine family" )
            set_weight( 1200 )
            set_height( 50 )
            remove_bit( "nose" )
            remove_bit( "head" )
            remove_bit( "left front leg" )
            remove_bit( "right front leg" )
            remove_bit( "left rear leg" )
            remove_bit( "right rear leg" )
            add_bit( "head", "head", [0, 135, 0,
            "left eye", "right eye", "snout", "skull", "tongue", "left ear",
            "right ear"] )
            add_bit( "snout", "snout", ["head", 12, 0] )
            add_bit( "left front trotter", "trotter", [0, 180, 0, "left front hoof"] )
            add_bit( "right front trotter", "trotter", [0, 180, 0, "right front hoof"] )
            add_bit( "left rear trotter", "trotter", [0, 180, 0, "left rear hoof"] )
            add_bit( "right rear trotter", "trotter", [0, 180, 0, "right rear hoof"] )
            add_bit( "chop", "chop", [0, 1, 0] )
            add_bit( "tail", "tail", [0, 1, 0] )
            inedible += ["left front trotter", "right front trotter",
            "left rear trotter", "right rear trotter"]
            unrottable += ["left front trotter", "right front trotter",
            "left rear trotter", "right rear trotter"]
            set_stats( [2, 0, -2, 4, -4] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "standard" )
            thing.remove_attack( "hoof" )
            thing.add_attack( "hoof", 60, [32, 10, 11],
            "blunt", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "rabbit" )
            set_long( "A small furry and fluffy rabbit.\n" )
            set_height( 30 )
            set_weight( 25 )
            set_desc( "a cute and fluffy little bunny" )
            set_stats( [-3, 8, -4, -5, -6] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            thing.add_ac( "blunt", "blunt", level )
            thing.add_ac( "sharp", "sharp", 2 + level )
            thing.add_ac( "pierce", "pierce", 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number ) / 7
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "bite" )
            thing.add_attack( "bite", 75, [1, 3, 4],
            "pierce", "unarmed", 0 )
            thing.tactics( "response dodge" )
            thing.tactics( "attitude defensive" )


    def setup(self, ) -> None:
            set_name( "raptor" )
            set_long( "A carnivorous bird (as a hawk or falcon) that feeds wholly on "
            "meat taken by hunting.\n" )
            set_height( 65 )
            set_weight( 200 )
            set_desc( "a sharp-eyed raptor" )
            remove_bit( "gizzard" )
            set_stats( [0, 14, -4, 2, -6] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            level = 2 * level + random( level )
            thing.add_ac( "blunt", "blunt", level )
            thing.add_ac( "pierce", "pierce", level / 4 )
            thing.add_ac( "sharp", "sharp", level / 4 )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number ) / 2
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "beak" )
            thing.remove_attack( "claws" )
            thing.add_attack( "beak", 50, [number / 2, 2, number / 2],
            "pierce", "unarmed", 0 )
            thing.add_attack( "claws", 75, [number, 5, number / 2],
            "sharp", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "rat" )
            set_long( "A rodent of the genus Rattus, distinguished from a mouse "
            "by its larger size and by structural details, as of the teeth.\n" )
            set_height( 15 )
            set_weight( 10 )
            set_desc( "a vicious-looking rat, scurrying about for food." )
            set_stats( [-4, 8, -2, -4, -4] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            thing.add_ac( "blunt", "blunt", level )
            thing.add_ac( "sharp", "sharp", 2 + level )
            thing.add_ac( "pierce", "pierce", 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "bite" )
            thing.remove_attack( "claws" )
            thing.add_attack( "bite", 75, [3*number, 3, number],
            "pierce", "unarmed", 0 )
            thing.add_attack( "claws", 50, [3*number, 5, number / 2],
            "sharp", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "reptile" )
            set_long( "A normal reptile, wiv scales on.\n" )
            set_weight( 1000 )
            set_height( 20 )
            set_desc( "your standard reptile" )
            set_stats( [-2, 2, -4, -2, -6] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "chew" )
            thing.remove_attack( "tail" )
            thing.add_attack( "chew", 75, [3 * number, number / 2, number],
            "sharp", "unarmed", 0 )
            thing.add_attack( "tail", 75, [number, 5, number],
            "blunt", "unarmed", 0 )
            thing.tactics( "response dodge" )
            thing.tactics( "attitude offensive" )


    def __init__(self):
            self.bits = []
            self.inedible = ['skull', 'left front foot', 'right front foot']
            self.unrottable = ['skull', 'teeth', 'tooth']


    def setup(self, ) -> None:
            set_name( "rodent" )
            set_long( "A generic rodent object.\n" )
            set_height( 10 )
            set_weight( 10 )
            set_desc( "a small rodent" )
            set_stats( [-4, 8, -4, -4, -6] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            level = 1 + ( 2 * args[ 0 ] + random( level ) ) / 10
            thing.add_ac( "blunt", "blunt", level )
            thing.add_ac( "sharp", "sharp", 2 + level )
            thing.add_ac( "pierce", "pierce", 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "bite" )
            thing.add_attack( "bite", 100, [number, 5, number],
            "pierce", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def __init__(self):
            self.bits = []
            self.inedible = ['skull', 'teeth', 'tooth', 'tail', 'skin']
            self.unrottable = ['skull', 'teeth', 'tooth']


    def __init__(self):
            self.bits = []
            self.inedible = ['skull', 'neck', 'genitals', 'teeth', 'left front hoof']
            self.unrottable = ['skull', 'teeth', 'tooth']


    def map_target_zone(self, zone: str) -> str:
            switch(zone) {
            case "chest":
            return random(4) ? "back" : "chest"
            case "abdomen":
            return random(4) ? "stomach" : "lower back"
            case "arms":
            return (random(2) ? "left " : "right ") + "front leg"
            case "hands":
            return (random(2) ? "left " : "right ") + "front hoof"
            case "legs":
            return (random(2) ? "left " : "right ") + "rear leg"
            case "feet":
            return (random(2) ? "left " :"right ") + "rear hoof"
            default:
            return zone


    def setup(self, ) -> None:
            set_name( "scorpion" )
            set_long( "A nasty little poisonous creature, of the arachnid family.\n" )
            set_height( 5 )
            set_weight( 2 )
            set_desc( "a nasty little poisonous creature, of the arachnid family" )
            bits = ({
            "head", "head", [0, 200, 0,
            "left eye", "right eye", "mandible", "brain"],
            "left eye", "eye", ["head", 10, 0],
            "right eye", "eye", ["head", 10, 0],
            "mandible", "mouth", ["head", 50, 0],
            "brain", "brain", ["head", 25, 0],
            "thorax", "thorax", [0, 500, 0, "heart", "poison sac"],
            "heart", "heart", ["thorax", 50, 0],
            "poison sac", "sac", ["thorax", 50, 0],
            "tail", "tail", [0, 300, 0, "sting"],
            "sting", "sting", ["tail", 25, 0],
            "left claw", "claw", [0, 100, 0],
            "right claw", "claw", [0, 100, 0],
            "left front leg", "leg", [0, 50, 0],
            "left middle leg", "leg", [0, 50, 0],
            "left back leg", "leg", [0, 50, 0],
            "right front leg", "leg", [0, 50, 0],
            "right middle leg", "leg", [0, 50, 0],
            "right back leg", "leg", [0, 50, 0]
            })
            inedible = ["mandible", "left claw", "right claw"]
            unrottable = ["mandible", "left claw", "right claw"]
            set_stats( [-6, 4, -6, -6, -6] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            thing.add_skill_level( "other.health", level * 3 )
            thing.add_ac( "blunt", "blunt", level / 2 )
            thing.add_ac( "pierce", "pierce", level / 4 )
            thing.add_ac( "sharp", "sharp", level / 3 )
            thing.add_ac( "fire", "fire", level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "poison" )
            thing.remove_attack( "bite" )
            thing.add_attack( "sting", 70, [5 * number, 10, number],
            "pierce", "unarmed", ["poison", self] )
            thing.add_attack( "bite",  20, [3 * number, 10, number],
            "pierce", "unarmed", 0 )
            thing->add_attack_message( "sting", "pierce", ({
            0, "$N sting$s $P $z.\n"] )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "shark" )
            set_long( "A big mean shark.\n" )
            set_height( 15 )
            set_weight( 8000 )
            set_desc( "a fish, the kind with fins" )
            set_stats( [10, 14, 2, 21, -4] )


    def check_water(self, player: MudObject) -> None:
            if( player && !environment( player )->query_water() )
            asyncio.create_task(self. "do_drown", 4, player )


    def do_drown(self, player: MudObject) -> None:
            int i
            if(!player || !environment(player) || environment(player)->query_water() )
            return
            tell_room( environment( player ) , player.one_short() + " gasps for "
            "air.\n" )
            i = player.query_max_hp() / 5
            if( i < 20 ) i = 20
            player.adjust_hp( -i )
            asyncio.create_task(self. "do_drown", 4, player )


    def start_player(self, thing: MudObject) -> None:
            ::start_player( thing )
            thing.add_property( "gills", 1 )
            thing.add_enter_commands( (: check_water :) )
            thing.set_default_position( ["lying"] )
            thing.return_to_default_position( 0 )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number ) * 2
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "bite" )
            thing.add_attack( "bite", 100, [2 * number, 5, number],
            "pierce", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "sheep" )
            set_long( "The sheep is a wooly mammal.  It is possibly the most stupid "
            "animal in the universe, with the possible exception of the duck.\n" )
            set_height( 50 )
            set_weight( 800 )
            set_skin( "fleece" )
            set_desc( "a wooly sheep" )
            add_ac( "blunt", "blunt", 50 )
            add_ac( "pierce", "pierce", 20 )
            add_ac( "sharp", "sharp", 20 )
            set_stats( [0, 0, -6, -2, -6] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "standard" )
            thing.remove_attack( "chew" )
            thing.remove_attack( "hoof" )
            thing.add_attack( "chew", 50, [40, 8, 10],
            "sharp", "unarmed", 0 )
            thing.add_attack( "hoof", 50, [60, 10, 40],
            "blunt", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "skunk" )
            set_long( "A small black and white animal.\n" )
            set_height( 15 )
            set_weight( 30 )
            set_desc( "small brown meateater" )
            set_stats( [-2, 8, -2, -4, -4] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            level = 1 + ( 2 * level + random( level ) ) / 8
            thing.add_ac( "blunt", "blunt", 20 + level / 3 )
            thing.add_ac( "sharp", "sharp", 50 + level )
            thing.add_ac( "pierce", "pierce", 60 + 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number ) / 2
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "claws" )
            thing.remove_attack( "bite" )
            thing.add_attack( "claws", 50, [( 4 * number ) / 2, 8, 2 * number],
            "sharp", "unarmed", 0 )
            thing.add_attack( "bite", 100, [2 * number, 10, ( 3 * number ) / 2],
            "pierce", "unarmed", 0  )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "snake" )
            set_long( "Snake, Serpent, Legless thingy that crawls on its belly all "
            "day long.\n" )
            set_height( 5 )
            set_weight( 60 )
            set_desc( "a serpent, the type with no legs but with scales." )
            bits = ({
            "head", "head", [0, 50, 0,
            "left eye", "right eye", "poison sac", "tongue", "skull"],
            "left eye", "eye", ["head", 5, 0],
            "right eye", "eye", ["head", 5, 0],
            "poison sac", "sac", ["head", 10, 0],
            "skull", "skull", ["head", 40, 0, "tooth", "brain"],
            "tooth", "tooth", ["skull", 5, ({"/std/bit", 2})],
            "brain", "brain", ["skull", 10, 0],
            "torso", "torso", [0, 600, 0,
            "heart", "liver", "left kidney", "right kidney", "spleen",
            "bladder", "intestine"],
            "heart", "heart", ["torso", 20, 0],
            "liver", "liver", ["torso", 20, 0],
            "left lung", "lung", ["torso", 20, 0],
            "right lung", "lung", ["torso", 20, 0],
            "left kidney", "kidney", ["torso", 10, 0],
            "right kidney", "kidney", ["torso", 10, 0],
            "spleen", "spleen", ["torso", 10, 0],
            "bladder", "bladder", ["torso", 10, 0],
            "intestine", "gut", ["torso", 100, 0],
            "genitals", "genitals", [0, 5, 0],
            "tail", "tail", [0, 500, 0],
            "skin", "skin", [0, 175, 0]
            })
            inedible = ["poison sac", "tooth"]
            unrottable = ["tooth"]
            add_ac( "blunt", "blunt", 40 )
            add_ac( "sharp", "sharp", 20 )
            add_ac( "pierce", "pierce", 10 )
            set_stats( [0, 0, -4, 4, -4] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "bite" )
            thing.remove_attack( "crush" )
            thing.add_attack( "bite", 75, [( 3 * number ) / 2, 5, number * 2],
            "pierce", "unarmed", 0 )
            thing.add_attack( "squeeze", 50, [3 * number, 2, number],
            "blunt", "unarmed", 0 )
            thing->add_attack_message( "squeeze", "unarmed", ({
            0, "$N attempt$s to wrap $oself around $P $z",
            40, "$N wrap$s $oself around $P $z and squeeze$s",
            80, "$N wrap$s $oself tightly around $P $z and squeeze$s",
            120, "$N wrap$s $oself tightly around $P $z and squeeze$s firmly",
            160, "$N wrap$s $oself around $P $z and squeeze$s tightly, crushing "
            "$I in $p grip",
            0, "$N wrap$s tightly around $I and crush$es $I to a pulp"] )
            thing.tactics( "response dodge" )


    def map_target_zone(self, zone: str) -> str:
            switch(zone) {
            case "head":
            return "head"
            case "neck":
            case "chest":
            return "body"
            default:
            return "tail"


    def setup(self, ) -> None:
            set_name( "spider" )
            set_long( "A small, poisonous, hairy spider.\n" )
            set_desc( "a hairy arachnid" )
            set_height( 5 )
            set_weight( 2 )
            add_bit( "silk gland", "gland", ["abdomen", 10,
            ({"/std/bit", 1, 400})] )
            add_bit( "poison gland", "gland", ["cephalothorax", 5,
            ({"/std/bit", 1, 400})] )
            inedible += ["poison gland"]
            set_stats( [-6, 4, -6, -6, -6] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            thing.add_skill_level( "other.health", level * 2 )
            thing.add_ac( "blunt", "blunt", level / 2 )
            thing.add_ac( "pierce", "pierce", level / 4 )
            thing.add_ac( "sharp", "sharp", level / 3 )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "standard" )
            thing.remove_attack( "bite" )
            thing.remove_attack( "chew" )
            thing.add_attack( "bite", 80, [10, 2, 5],
            "pierce", "unarmed", ["poison", self] )
            thing.add_attack( "chew", 100, [2, 2, 10],
            "sharp", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "stoat" )
            set_long( "A small black and white animal.\n" )
            set_height( 15 )
            set_weight( 30 )
            set_desc( "small brown meateater" )
            set_stats( [-2, 8, -2, -4, -4] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            level = 1 + ( 2 * level + random( level ) ) / 8
            thing.add_ac( "blunt", "blunt", 20 + level / 3 )
            thing.add_ac( "sharp", "sharp", 50 + level )
            thing.add_ac( "pierce", "pierce", 60 + 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number ) / 2
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "claws" )
            thing.remove_attack( "bite" )
            thing.add_attack( "claws", 50, [( 4 * number ) / 2, 8, 2 * number],
            "sharp", "unarmed", 0 )
            thing.add_attack( "bite", 100, [2 * number, 10, ( 3 * number ) /2],
            "pierce", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "toad" )
            set_long( "Toads are amphibians" )
            set_height(10)
            set_weight(10)
            set_desc( "an warty toad" )
            add_ac( "blunt", "blunt", 5 )
            add_ac( "pierce", "pierce", 4 )
            add_ac( "sharp", "sharp", 3 )
            add_attack( "bite", 50, [10, 2, 6] )
            set_sight( [5, 20, 200, 300] )
            set_stats( [-4, 10, -4, -4, -6] )


    def start_player(self, thing: MudObject) -> None:
            ::start_player( thing )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "tortoise" )
            set_long( "A tortoise.\n" )
            set_height( 40 )
            set_weight( 600 )
            set_desc( "a tortoise, slow and steady" )
            bits = ({
            "head", "head", [0, 100, 0,
            "left eye", "right eye", "skull", "tongue"],
            "left eye", "eye", ["head", 1, 0],
            "right eye", "eye", ["head", 1, 0],
            "skull", "skull", ["head", 50, 0, "brain"],
            "beak", 0, ["skull", 20, 0],
            "brain", "brain", ["skull", 30, 0],
            "torso", "torso", [0, 450, 0,
            "heart", "liver", "left kidney", "right kidney", "spleen",
            "right lung", "left lung", "intestine"],
            "heart", "heart", ["torso", 20, 0],
            "liver", "liver", ["torso", 20, 0],
            "left kidney", "kidney", ["torso", 10, 0],
            "right kidney", "kidney", ["torso", 10, 0],
            "spleen", "spleen", ["torso", 10, 0],
            "right lung", "lung", ["torso", 20, 0],
            "left lung", "lung", ["torso", 20, 0],
            "intestine", "gut", ["torso", 50, 0],
            "genitals", "genitals", [0, 5, 0],
            "left front leg", "leg", [0, 150, 0, "left front claw"],
            "left front claw", "claw", ["left front leg", 25, 0],
            "right front leg", "leg", [0, 150, 0, "right front claw"],
            "right front claw", "claw", ["right front leg", 25, 0],
            "left rear leg", "leg", [0, 150, 0, "left rear claw"],
            "left rear claw", "claw", ["left rear leg", 25, 0],
            "right rear leg", "leg", [0, 150, 0, "right rear claw"],
            "right rear claw", "claw", ["right rear leg", 25, 0],
            "tail", "tail", [0, 25, 0],
            "shell", 0, [0, 275, 0]
            })
            inedible = ["skull", "beak", "shell"]
            unrottable = ["skull", "beak", "shell"]
            set_skin( "skin" )
            set_stats( [2, 4, -2, 6, -4] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number ) / 2
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "chew" )
            thing.remove_attack( "claws" )
            thing.add_attack( "chew", 100, [3 * number, 0, number],
            "sharp", "unarmed", 0 )
            thing.add_attack( "claws", 50, [( 3 * number ) / 2, number, number],
            "sharp", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "tree" )
            set_long( "A tree.\n" )
            set_height( 800 )
            set_weight( 40000 )
            set_desc( "a large tree" )
            add_ac( "blunt", "blunt", 500 )
            add_ac( "sharp", "sharp", 50 )
            add_ac( "pierce", "pierce", 250 )
            add_ac( "fire", "fire", 100 )
            add_ac( "sound", "sound", 1000 )
            add_ac( "gas", "gas", 1000 )
            set_stats( [10, -6, -2, 10, 4] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 2 + sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "branches" )
            thing.add_attack( "branches", 100, [number / 2, 10, number],
            "blunt", "blunt", 0 )
            thing->add_attack_message( "branches", "blunt", ({
            0, "$N swing$s at $I with $p branches",
            20, "$N tap$s $I in the $z with $p branches",
            60, "$N hit$s $I in the $z with $p branches",
            100, "$N bruise$s $P $z with $p branches",
            140, "$N hit$s $I hard in the $z with $p branches",
            180, "$N smash$es $I in the $z with $p branches",
            220, "$N crush$es $P $z with $p branches",
            5000, "$N mash$es $P $z with $p branches"])
            thing.set_unarmed_parry(1)


    def __init__(self):
            self.bits = []
            self.inedible = ['trunk', 'branch', 'root']
            self.unrottable = []


    def map_target_zone(self, zone: str) -> str:
            switch(zone) {
            case "chest":
            case "abdomen":
            case "back":
            return "trunk"
            case "hands":
            case "neck":
            case "head":
            case "arms":
            case "legs":
            return "branches"
            case "feet":
            return "root"


    def setup(self, ) -> None:
            set_name( "snake" )
            set_long( "Snake, Serpent, Legless thingy that crawls on its belly all "
            "day long.\n" )
            set_height( 5 )
            set_weight( 60 )
            set_desc( "a serpent, the type with no legs but with scales." )
            bits = ({
            "head", "head", [0, 50, 0,
            "left eye", "right eye", "poison sac", "tongue", "skull"],
            "left eye", "eye", ["head", 5, 0],
            "right eye", "eye", ["head", 5, 0],
            "poison sac", "sac", ["head", 10, 0],
            "skull", "skull", ["head", 40, 0, "tooth", "brain"],
            "tooth", "tooth", ["skull", 5, ({"/std/bit", 2})],
            "brain", "brain", ["skull", 10, 0],
            "torso", "torso", [0, 600, 0,
            "heart", "liver", "left kidney", "right kidney", "spleen",
            "bladder", "intestine"],
            "heart", "heart", ["torso", 20, 0],
            "liver", "liver", ["torso", 20, 0],
            "left lung", "lung", ["torso", 20, 0],
            "right lung", "lung", ["torso", 20, 0],
            "left kidney", "kidney", ["torso", 10, 0],
            "right kidney", "kidney", ["torso", 10, 0],
            "spleen", "spleen", ["torso", 10, 0],
            "bladder", "bladder", ["torso", 10, 0],
            "intestine", "gut", ["torso", 100, 0],
            "genitals", "genitals", [0, 5, 0],
            "tail", "tail", [0, 500, 0],
            "skin", "skin", [0, 175, 0]
            })
            inedible = ["poison sac", "tooth"]
            unrottable = ["tooth"]
            add_ac( "blunt", "blunt", 40 )
            add_ac( "sharp", "sharp", 20 )
            add_ac( "pierce", "pierce", 10 )
            set_stats( [0, 0, -4, 4, -4] )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number )
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "bite" )
            thing.remove_attack( "crush" )
            thing.add_attack( "bite", 80, [( 3 * number ) / 2, 5, number * 2],
            "pierce", "unarmed", ["poison", self] )
            thing.tactics( "response dodge" )


    def map_target_zone(self, zone: str) -> str:
            switch(zone) {
            case "head":
            return "head"
            case "neck":
            case "chest":
            return "body"
            default:
            return "tail"


    def setup(self, ) -> None:
            set_name( "vulture" )
            set_long( "A largish, rather scruffy-looking bird with an ugly, "
            "featherless head and a big crooked beak.\n" )
            set_desc( "a somewhat evil-looking old vulture\n" )
            set_height( 40 )
            set_weight( 200 )
            set_stats( [0, 14, -4, 2, -6] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            thing.add_ac( "blunt", "blunt", level / 2 )
            thing.add_ac( "pierce", "pierce", level )
            thing.add_ac( "sharp", "sharp", level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = sqrt( number ) / 2
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "beak" )
            thing.remove_attack( "claws" )
            thing.add_attack( "beak", 50, [number / 2, 2, number / 2],
            "pierce", "unarmed", 0 )
            thing.add_attack( "claws", 75, [number, 5, number / 2],
            "sharp", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "weasel" )
            set_long( "A small brown furred animal.\n" )
            set_height( 15 )
            set_weight( 30 )
            set_desc( "small brown meateater" )
            set_stats( [-2, 8, -2, -4, -4] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            level = 2 + ( 2 * level + random( level ) ) / 8
            thing.add_ac( "blunt", "blunt", 20 + level / 3 )
            thing.add_ac( "sharp", "sharp", 50 + level )
            thing.add_ac( "pierce", "pierce", 60 + 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number ) / 2
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "claws" )
            thing.remove_attack( "bite" )
            thing.add_attack( "claws", 50, [( 4 * number ) / 2, 8, 2 * number],
            "sharp", "unarmed", 0 )
            thing.add_attack( "bite", 100, [2 * number, 10, ( 3 * number ) / 2],
            "pierce", "unarmed", 0  )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "wolf" )
            set_desc( "a really nasty, hungry looking canine" )
            set_height( 75 )
            set_weight( 1000 )
            set_stats( [6, 12, -4, 8, -4] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            level = 2 + ( 2 * level + random( level ) ) / 8
            thing.add_ac( "blunt", "blunt", 20 + level / 3 )
            thing.add_ac( "sharp", "sharp", 50 + level )
            thing.add_ac( "pierce", "pierce", 60 + 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number ) / 2
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "claws" )
            thing.remove_attack( "bite" )
            thing.add_attack( "claws", 50, [( 5 * number ) / 2, 8, 2 * number],
            "sharp", "unarmed", 0 )
            thing.add_attack( "bite", 100, [3 * number, 10, ( 3 * number ) / 2],
            "pierce", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def setup(self, ) -> None:
            set_name( "wombat" )
            set_long( "One of several stocky marsupials (family Vombatidae) "
            "resembling small bears.\n" )
            set_height( 40 )
            set_weight( 600 )
            set_desc( "a stocky wombat, looking for something to nibble" )
            bits = ({
            "head", "head", [0, 100, 0,
            "left eye", "right eye", "left ear", "right ear", "skull"],
            "left eye", "eye", ["head", 1, 0],
            "right eye", "eye", ["head", 1, 0],
            "left ear", "ear", ["head", 15, 0],
            "right ear", "ear", ["head", 15, 0],
            "skull", "skull", ["head", 50, 0, "teeth", "brain"],
            "brain", "brain", ["skull", 30, 0],
            "teeth", "teeth", ["skull", 1, ({"/std/bit_set", 1}), "tooth"],
            "tooth", "tooth", ["teeth", 1, ({"/std/bit", 18})],
            "torso", "torso", [0, 450, 0,
            "heart", "liver", "left kidney", "right kidney", "spleen",
            "right lung", "left lung", "intestine"],
            "heart", "heart", ["torso", 20, 0],
            "liver", "liver", ["torso", 20, 0],
            "left kidney", "kidney", ["torso", 10, 0],
            "right kidney", "kidney", ["torso", 10, 0],
            "spleen", "spleen", ["torso", 10, 0],
            "right lung", "lung", ["torso", 20, 0],
            "left lung", "lung", ["torso", 20, 0],
            "intestine", "gut", ["torso", 50, 0],
            "genitals", "genitals", [0, 5, 0],
            "left front leg", "leg", [0, 150, 0, "left front paw"],
            "left front paw", "paw", ["left front leg", 25, 0],
            "right front leg", "leg", [0, 150, 0, "right front paw"],
            "right front paw", "paw", ["right front leg", 25, 0],
            "left rear leg", "leg", [0, 150, 0, "left rear paw"],
            "left rear paw", "paw", ["left rear leg", 25, 0],
            "right rear leg", "leg", [0, 150, 0, "right rear paw"],
            "right rear paw", "paw", ["right rear leg", 25, 0],
            "tail", "tail", [0, 25, 0],
            "skin", "skin", [0, 175, 0]
            })
            inedible = ["skull", "teeth", "tail", "skin"]
            unrottable = ["skull", "teeth"]
            set_skin( "fur" )
            set_stats( [2, 4, -2, 6, -4] )


    def new_set_level(self, args: Any) -> None:
            int level
            object thing
            if( sizeof(args) < 2 || !args[1] )
            return
            level = args[ 0 ]
            thing = args[ 1 ]
            level = 1 + ( 2 * level + random( level ) ) / 10
            thing.add_ac( "blunt", "blunt", level )
            thing.add_ac( "sharp", "sharp", 2 + level )
            thing.add_ac( "pierce", "pierce", 2 * level )


    def set_unarmed_attacks(self, thing: MudObject) -> None:
            int number
            number = (int)thing.query_skill_bonus( "fighting.combat.melee.unarmed" )
            number = 4 + sqrt( number ) / 2
            thing.remove_attack( "hands" )
            thing.remove_attack( "feet" )
            thing.remove_attack( "chew" )
            thing.remove_attack( "claws" )
            thing.add_attack( "chew", 100, [3 * number, 0, number],
            "sharp", "unarmed", 0 )
            thing.add_attack( "claws", 50, [( 3 * number ) / 2, number, number],
            "sharp", "unarmed", 0 )
            thing.tactics( "response dodge" )


    def init_shadow(self, ob: MudObject) -> None:
            my_player = ob
            shadow(ob, 1)


    async def query_ac(self, type: str, dam: int) -> int:
            int i
        # 2025 weather effect
        if hasattr(self, 'worn_by') and weather_handler.query_weather(self.worn_by.location) == 'rain' and 'fire' in damage_type:
            return ac + 5
            i = (int)my_player.query_ac(type)
        # 2025 weather effect
        if hasattr(self, 'worn_by') and weather_handler.query_weather(self.worn_by.location) == 'rain' and 'fire' in damage_type:
            return ac + 5
            if (environment(my_player)->query_underwater())
        # 2025 weather effect
        if hasattr(self, 'worn_by') and weather_handler.query_weather(self.worn_by.location) == 'rain' and 'fire' in damage_type:
            return ac + 5
            return i*100
        # 2025 weather effect
        if hasattr(self, 'worn_by') and weather_handler.query_weather(self.worn_by.location) == 'rain' and 'fire' in damage_type:
            return ac + 5
            return i
        # 2025 weather effect
        if hasattr(self, 'worn_by') and weather_handler.query_weather(self.worn_by.location) == 'rain' and 'fire' in damage_type:
            return ac + 5


    def move(self, ob: MudObject, s1: str, s2: str) -> int:
            int i
            i = (int)my_player.move(ob, s1, s2)
            if (!i && !ob.query_underwater())
            asyncio.create_task(self."do_drown", 2)
            else
            remove_asyncio.create_task(self."do_drown")
            return i


    def do_drown(self, ) -> None:
            tell_room(my_player, my_player.one_short()+" gasps for air.\n")
            my_player.adjust_hp(random(50)+50)
            asyncio.create_task(self."do_drown", 2)



class Merged_obj_std(MudObject):

    ac = '([ ])'

    armour_types = '[]'

    corpse_weight = 'STD_CORPSE_WEIGHT'

    _pages = '[]'

    _default_page_object = '"/obj/misc/paper"'

    _def_p_obj = 'find_object(_default_page_object)'

    registered_containers = '[]'

    _n_tracked_items = 0

    _tracking = 1

    _delivery = '([ ])'

    _save_file = 'temp'

    _delivery_delay = 5

    _delivery_mess = '"\\nA small womble wearing a bright green hat "'

    _burdened_mess = '"\\nA small womble wearing a bright purple "'

    _cont = 'clone_object("/std/container")'

    _group_info = '([ ])'

    pages = "['({ 0', '0', '0 })']"

    _locations = '([ ])'

    _materials = '[]'

    create_me = '"who knows"'

    _races = '(['

    _guilds = '(['

    _race_obs = '([ ])'

    _race_obs[tmp] = 'load_object(tmp)'

    _guild_obs = '([ ])'

    catch(_guild_obs[tmp] = 'load_object(tmp))'

    num_pages = 1

    open_page = 1

    _skills = 'STD_SKILLS'

    _skill_tree = '([ ])'

    _immediate_children = '([ ])'

    _not_allowed_to_teach = '([ ])'

    _only_show_if_non_zero = '([ ])'

    _no_bonus = '([ ])'

    lang_tree = '[]'

    languages = 'LANGUAGE_HAND->query_languages()'

    for (i = '0;i<sizeof(pre_load);i++) {'

    rabbit = '[]'

    rabbit + = "['SPOKEN_SKILL', '0', '0', '({ })']"

    attack_names = '[]'

    attack_types = '[]'

    attack_data = '[]'

    special_messages = '([ ])'

    _difficulty = 5

    _pick_skill = '"covert.lockpick.doors"'

    max_cond = 1

    effs = '[]'

    eeq = '[]'

    _data = 'new(class effect_data)'

    _data->shadows = '[]'

    _data->next_id = 0

    _data->current_enum = '-1'

    _data->next_event_time = 0

    logging_effects = 0

    _variables = '([ ])'

    _functions = '([ ])'

    _user_functions = '([ ])'

    extra_looks = '[]'

    _hide_invis = '([])'

    _no_limbs = 1

    _inform_of_change = '[]'

    weight = 1

    value_info = '([ ])'

    _adjs = '[]'

    version_control[ base_name( this_object() ) ] = 'ctime( time() )'

    version_control[ base_name( temp ) ] = 'temp->query_version()'

    immune_to = "['cold', 'sound', 'gas', 'mental']"

    wear_effects = '[]'

    wear_remove_func = '[]'

    connected = 0

    verbose = '([ ])'

    _regions = '([ ])'

    replace_matrix = '[]'

    trans = '([ ])'

    trans["stairs"] = '"apples and pears"'

    trans["Downstairs"] = '"Down the apples and pears"'

    trans["downstairs"] = '"down the apples and pears"'

    trans["Upstairs"] = '"Up the apples and pears"'

    trans["upstairs"] = '"up the apples and pears"'

    trans["mouth"] = '"North and South"'

    trans["Mouth"] = '"North and South"'

    trans["Face"] = '"Boat Race"'

    trans["face"] = '"Boat Race"'

    trans["Trouble"] = '"Barney Rubble"'

    trans["trouble"] = '"Barney Rubble"'

    trans["wife"] = "['trouble and strife', 'ole lady']"

    trans["Road"] = '"Frog and Toad"'

    trans["road"] = '"frog and toad"'

    trans["pub"] = '"rub-a-dub "'

    trans["bar"] = '"boozer"'

    trans["husband"] = '"ole man"'

    trans["Party"] = '"Knees-up"'

    trans["party"] = '"knees-up"'

    trans["Parties"] = '"Knees-ups"'

    trans["parties"] = '"knees-ups"'

    trans["My"] = '"Me"'

    trans["my"] = '"me"'

    trans["Your"] = '"Yer"'

    trans["your"] = '"yer"'

    trans["You"] = '"Yer"'

    trans["you"] = '"yer"'

    trans["Those"] = '"Them"'

    trans["those"] = '"them"'

    trans["(those"] = '"(them"'

    trans["The"] = '["The bleedin\'", \'The\']'

    trans["Fe"] = '["The bleedin\'", \'The\']'

    trans["the"] = '["the bleedin\'", \'the\']'

    trans["fe"] = '["the bleedin\'", \'the\']'

    trans["Thus"] = '"So"'

    trans["thus"] = '"so"'

    trans["(thus"] = '"(so"'

    trans["old"] = '"ole"'

    trans["to"] = '"ter"'

    trans["Aren't"] = '"Ain\'t"'

    trans["aren't"] = '"ain\'t"'

    trans["Isn't"] = '"Ain\'t"'

    trans["isn't"] = '"ain\'t"'

    trans["Hallo"] = '"Wotcher"'

    trans["Hello"] = '"Wotcher"'

    trans["Hullo"] = '"Wotcher"'

    trans["Hi"] = '"Wotcher"'

    trans["hallo"] = '"wotcher"'

    trans["hello"] = '"wotcher"'

    trans["hullo"] = '"wotcher"'

    trans["hi"] = '"wotcher"'

    trans["What"] = '"Wot"'

    trans["what"] = '"wot"'

    trans["Were"] = '"Was"'

    trans["were "] = '"was"'

    trans["Bother"] = '"Ars"'

    trans["bother"] = '"ars"'

    trans["Mother"] = '"Muvver"'

    trans["Other"] = '"Uvver"'

    trans["other"] = '"uvver"'

    trans["Father"] = '"Favver"'

    trans["father"] = '"favver"'

    trans["Rather"] = '"Ravver"'

    trans["rather"] = '"ravver"'

    trans["Weather"] = '"Wevver"'

    trans["weather"] = '"wevver"'

    trans["Leather"] = '"Levver"'

    trans["leather"] = '"levver"'

    trans["Wither"] = '"Wivver"'

    trans["wither"] = '"wivver"'

    trans["Either"] = '"Eever"'

    trans["either"] = '"eever"'

    trans["With"] = '"Wiv"'

    trans["with"] = '"wiv"'

    trans["Anything"] = '"Anyfink"'

    trans["anything"] = '"anyfink"'

    trans["Something"] = '"Sumfink"'

    trans["something"] = '"sumfink"'

    trans["Nothing"] = '"Nuffink"'

    trans["nothing"] = '"nuffink"'

    trans["guitars"] = '"spoons"'

    trans["guitar"] = '"spoons"'

    trans["drums"] = '"spoons"'

    trans["drum"] = '"spoons"'

    trans["trumpets"] = '"spoons"'

    trans["trumpet"] = '"spoons"'

    trans["violins"] = '"spoons"'

    trans["violin"] = '"spoons"'

    trans["clarinets"] = '"spoons"'

    trans["clarinet"] = '"spoons"'

    trans["trombones"] = '"spoons"'

    trans["trombone"] = '"spoons"'

    trans["oboes"] = '"spoons"'

    trans["oboe"] = '"spoons"'

    trans["flutes"] = '"spoons"'

    trans["flute"] = '"spoons"'

    trans["tubas"] = '"spoons"'

    trans["tuba"] = '"spoons"'

    trans["Data"] = '"Info"'

    trans["data"] = '"info"'

    trans["Directory"] = '"Lockup"'

    trans["directory"] = '"lockup"'

    trans["Directories"] = '"Lockups"'

    trans["directories"] = '"lockups"'

    trans["Stopped"] = '"\'Ad the mockers put on"'

    trans["stopped"] = '"\'ad the mockers put on"'

    trans["Stopping"] = '"Putting the mockers on"'

    trans["stopping"] = '"putting the mockers on"'

    trans["stops"] = '"puts the mockers on"'

    trans["stop"] = '"put the mockers on"'

    trans["STOP"] = '"Put The Mockers On"'

    trans["Londoner"] = '"Cockney"'

    trans["londoner"] = '"Cockney"'

    trans["friend"] = "['mucker', 'mate', 'china']"

    trans["sin'"] = '"sing"'

    trans["rin'"] = '"ring"'

    account_cost = 0

    percentage = 90

    total_account = 0

    total_made = 0

    bank_name = '"Bing\'s First"'

    place = '"default"'

    _total_account = 0

    _total_made = 0

    _cost_per_book = 4000

    _cost_per_page = 400

    standard = 100

    exchanges = '([ ])'

    buy_mess = '[]'

    sell_mess = '[]'

    list_mess = '"$extra$"'

    value_mess = '"$ob$ is valued at $money$.\\n"'

    too_costly_mess = '"$ob$ is worth too much to be sold here.\\n"'

    not_worthy_mess = '"$ob$ is not worth enough to be sold here.\\n"'

    browse_mess = '"$ob$ costs $money$, it looks like:\\n$extra$"'

    other_shops = '[]'

    max_inventory = 'MAX_INVENTORY'

    min_amount = 50

    _strict_currency = 1

    letter_cost = 'DEFAULT_LETTER_COST'

    time_to_collect = 'DEFAULT_TIME_TO_COLLECT'

    time_per_copy = 'DEFAULT_TIME_PER_COPY'

    collectables = '([ ])'

    discount_schedule = "['({ 100', '5 })']"

    default_language = '"common"'

    translation_costs = '([ ])'

    print_shop_name = '"Rabbits happy little printing press"'

    _areas = '[]'

    _city = '"Ankh-Morpork"'

    _language = '"common"'

    _signtypes = '[]'

    _paintcolours = '([ ])'

    _signs = '([ ])'

    room_cont = '([ ])'

    shop_type = '([ ])'

    max_num = 8

    loot = 'random(10)'

    _sell_list = 'clone_object("/std/container")'

    _current_save_num = 1

    _current_ids = '[]'

    _categories = '([ ])'

    _auctions = '[]'

    _finished_auctions = '[]'

    _cut = 10

    _max_auctions = 20

    _auction_obs = '[]'

    _royalties = '([ ])'

    _auction_times = '(['

    _retrieval_time = 'DEFAULT_RETRIEVAL_TIME'

    _max_retries = 5

    _minimum_bid_increase = 10

    _allow_add = 1

    _account_cost = 400

    _total_difference = 0

    _percentage = 10

    _notes = '[]'

    _commercial_things = '[]'

    _use_type_expressions = '([ ])'

    _property_size = 25

    _black_list = '[]'

    _last_stats = 'time()'

    _weekly_status = 'new(class weekly_status)'

    _weekly_status->withdrawls = '[]'

    _use_expression = 'parse_boolean_string("false")'

    _default_category = '"General"'

    _minimum_age_to_vote = '2 * DAY'

    _pawn_mess = '[]'

    _pawn_markup = '20 '

    _pawn_ttl = '7 * 24 * 60 * 60 '

    _shop_language = '"morporkian" '

    _round_value = 1

    _waiting_for_approval = '[]'

    _menu_items = '([ ])'

    _menu_aliases = '([ ])'

    _menu_header = '"The menu reads:"'

    _display_header = 1

    _menu_subheadings = "['Appetisers', 'Main Courses', 'Desserts']"

    _display_subheadings = 1

    _menu_object = 'clone_object( PUB_MENU_FILE )'

    _counter = 'make_counter()'

    _events = '([ ])'

    aliases = '[]'

    _exits = '[]'

    hidden_objects = '[]'

    _use_internal_objects = '[]'

    door_control = '([ ])'

    dest_other = '[]'

    exits = '([ ])'

    _types = '([ ])'

    _waiting_approval = '([ ])'

    _blacklist = '([ ])'

    _denied = '([ ])'

    _approved = '([ ])'

    _last_posted = 'time()'

    _subscribers = '([ ])'

    _weather_handler = 'WEATHER '

    weak_messages = '[]'

    slope_messages = '[]'

    step_messages = '[]'

    jump_tm_messages = '[]'

    jump_success_messages = '[]'

    jump_failure_messages = '[]'

    ghost_fall_messages = '[]'

    item_slope_messages = '[]'

    corpse_slope_messages = '[]'

    damages = '([ ])'

    damage_types = "['weak', 'slope', 'step', 'jump']"

    translations = '([ ])'

    jump_info = '([ ])'

    _start_cost = 400

    _cost_per_week = 400

    _stable_cache = '([ ])'

    _accounts = '([ ])'

    _stable_types = '[]'

    name = '"Some undefined disease"'

    lng = '"It\'s just a door.\\n"'

    shrt = '"door"'

    adjs = '[]'

    plu = '[]'

    _creator_room = 'file_name(previous_object())'

    _lng = "['']"

    _shrt = "['']"

    _gather = '([ ])'

    _plu = '[]'

    _name = '[]'

    _verb = '([ ])'

    _plural = '([ ])'

    _pattern = '([ ])'

    _cur_desc = '[]'

    _count = '([ ])'

    _other_things = '([ "smell" : 0, "taste" : 0, "read" : 0 ])'

    rooms = 'allocate( MAXROOMS )'

    roominfo = '([ ])'

    belows = '[]'

    bottom = 0

    ghost_action = 0

    moves = '[]'

    no_drop = 0

    death_mess = 0

    _wash = '([ ])'

    _finished_funcs = '[]'

    _percentage_cut = 5

    _room_type = 'CLUB_ROOM_CLUB_OR_FAMILY'

    cost_div = 'COST_DIV'

    cost_mult = 100

    spells = '([ ])'

    commands = '[]'

    _honours = '([ ])'

    _titles = '[]'

    _floor = 'create_floor()'

    _reporters = '([ ])'

    _editors = '[]'

    _payees = '([ ])'

    _articles = '[]'

    _category = '([ ])'

    _adverts = '[]'

    _setters = '[]'

    _sponsors = '[]'

    _next_article_num = 2

    _allowed = '[]'

    _catalog_by_author = '([ ])'

    _catalog_by_title = '([ ])'

    _player_contributable = 1

    _library_name = '"The illustrious library of fluff"'

    _catalog = '([ ])'

    _fines = '([ ])'

    _access = '([ ])'

    _loan_length = '3 * 24 * 60 * 60'

    _fine_per_day = 400

    _lost_damaged_fine = 1050

    _max_loans = 5

    exit_shorts = '([ ])'

    decorations = '[]'

    tell_denied = '[]'

    done_setup = 0

    _mail_information = '""'

    details = '([ ])'

    _last_saved = 'time()'

    _x_coord = '-1'

    _y_coord = '-1'

    votes = '([ ])'

    elections = '([ ])'

    _adjacent_items = '([ ])'

    _items = '[]'

    _night_descs = '[]'

    _day_descs = '[]'

    _variable_exits = '[]'

    _default_exits = '([ ])'

    _bell = 'clone_object("/std/object")'

    _file_modified_time = '([ ])'

    _options = '([ ])'

    _ownership = '([ ])'

    _default_ownership = '([ ])'

    std_euid = '"/secure/master"->creator_file(file_name(this_object()))'

    _maximum_total_difference = 4000

    _last_paid = 'time()'

    _commercial_size = 100

    _use_types = '[]'

    _amount = 100

    _drawer_mess = '"a drawer in $ob_short$"'

    _drawers = '[]'

    _on_top = '[]'

    _ante_house = 400

    _ante_amount = 400

    _min_bet = 400

    _max_bet = 1200

    _max_draw_rounds = 1

    _player_stats = '([ ])'

    _documents = '([ ])'

    _allowed_positions = '[]'

    _players = '([ ])'

    _ids_when_started = '[]'

    specials = '[]'

    weapons = '([ ])'

    yes_response = '([ "say":({ "yes", "yep", "sure", "ok",'

    no_response = '([ "say":({ "no", "nope", ({ "won\'t", "i" }),'

    local_prop = '([ MARRYPROP : 1, ])'

    classification = '"disease.unset"'

    shadow_ob = 0

    infection_chance = 0

    infection_check = 0

    cure_rate = 0

    _stuff = '([ ])'

    _transport_id = 'random(3000) + 1'

    _stats = "['str', 'dex', 'wis', 'int', 'con']"

    _goals = '([ ])'

    _plans = '[]'

    _default_plans = '([ ])'

    _default_priority = 'GOAL_INVALID_PRIORITY'

    _sutability = 'PLAN_INVALID_SUTABILITY'

    _hooked_events = '([ ])'

    gp_skill = '"other.points"'

    start_pos = 'CONFIG_START_LOCATION'

    skills = "['crafts', 'faith', 'fighting', 'other']"

    members = '([ ])'

    access = '([ ])'

    deputies = '[]'

    _project_cache = '([ ])'

    _rcsforce_allowed = '([ ])'

    _idle_mess = 0

    _messages = 'new(class messages)'

    _tester = 0

    temp = '"/save/" + replace(file_name()[1..], "/", "_")'

    pre_load = '[]'

    skin = '"morphological field"'

    wearing = '[]'

    _armour_callbacks = "['({ })', '({ })', '({ })']"

    _cids = "['0', '0', '0']"

    _combat = 'new(class combat_information,'

    _surrender = 'new(class surrender_information,'

    _processes = '([ ])'

    max_hp = 1

    max_gp = 1

    surrender = '-1'

    drink_info = 'allocate( D_SIZEOF )'

    counts = '([ ])'

    verbs = '([ ])'

    callingdeath = 0

    runaway_callout_handles = '[]'

    _weapons = '[]'

    _liv_data = 'new(class living_data)'

    _messages->msgin = '"$N arrive$s from $F."'

    _messages->msgout = '"$N leave$s $T."'

    _messages->mmsgin = '"$N appear$s out of the ground."'

    _messages->mmsgout = '"$N disappear$s in a puff of smoke."'

    _liv_data->followers = '[]'

    _liv_data->to_drop = '[]'

    verbose[t] = 1

    mon_actions = '[]'

    _respond_cmd = '([ ])'

    _respond_to_with = '[]'

    _response_data = 'new(class response_data)'

    _response_data->only_respond_to = '[]'

    _bonus_cache = '([ ])'

    _teach_offer = '([ ])'

    _stat_cache = '([ ])'

    new_skills = '([ ])'

    _last_info = '([ "time" : time() ])'

    bits = '[]'

    inedible = "['trunk', 'branch', 'root']"

    unrottable = '[]'

    sight = "['5', '20', '200', '300']"

    stats = 'allocate( 5 )'

    desc = '"a small non-descript thing"'

    pluckable = "['body feather', 'left wing feather', 'right wing feather']"

    acs = '[]'

    attacks = '[]'
