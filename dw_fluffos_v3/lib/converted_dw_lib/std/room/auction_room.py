# Generated from /mnt/home2/test/Test/dw_fluffos_v3/lib/std/room/auction_room.c (2003 FluffOS v3) for Forgotten Realms MUD
# Date: 2025-03-12 12:51:30
from typing import Dict, List, Optional, Any
from ..driver import MudObject, Player, driver
from ..driver import MudObject, Player, driver
import asyncio

    def __init__(self):


    def __init__(self):
            asyncio.create_task(self. "load_file", 1 )
            asyncio.create_task(self. "load_store", 2 )
            asyncio.create_task(self. "lot_check", 5 )


    def init(self, ) -> None:
            this_player()->add_command( "bid", self,
            "<string'amount'> {on|for} <indirect:object:here'case'>",
            (: do_bid( $4[0], $1 ) :) )
            this_player()->add_command( "collect", self,
            ["successful bids", "money", "expired lots",
            "all"],
            (: do_collect( $5 ) :) )
            this_player()->add_command( "deposit", self,
            "<indirect:object:me'items'> for <number> "
            "{minute|hour|day} auction" ,
            (: do_deposit( $1, $4[1], $4[2], "" ) :) )
            this_player()->add_command( "deposit", self,
            "<indirect:object:me'items'> for <number> "
            "{minute|hour|day} "
            "auction with [a] reserve price of <string'amount'>",
            (: do_deposit( $1, $4[1], $4[2], $4[3] ) :) )
            this_player()->add_command( "list", self, "" )
            this_player()->add_command( "browse", self,
            "<string'object'> in <indirect:object'case'>", (: do_browse( $1, $4[0], 0 ) :) )
            this_player()->add_command( "browse", self,
            "<string'object'> <number> in <indirect:object'case'>",
            (: do_browse( $1, $4[0], $4[1] ) :) )
            this_player()->add_command( "withdraw", self,
            "<indirect:object'case'> from auction",
            (: do_withdraw( $1 ) :) )
            this_player()->add_command( "write", self,
            "<string'text'> on <indirect:object'case'>",
            (: do_describe( $1, $4[0] ) :) )
            this_player()->add_command( "exclude", self,
            "<string'name'> from bidding on <indirect:object'case'>",
            (: do_exclude( $1, $4[0] ) :) )
            this_player()->add_command( "exclude", self,
            "list for <indirect:object'case'>",
            (: do_exclude( $1, "list" ) :) )
            this_player()->add_command( "exclude", self,
            "current ignore list from bidding on <indirect:object'case'>",
            (: do_exclude( $1, "ignore list" ) :) )
            this_player()->add_command( "unexclude", self,
            "<string'name'> from bidding on <indirect:object'case'>",
            (: do_unexclude( $1, $4[0] ) :) )


    def generate_auto_load(self, obs: MudObject) -> Any:
            object box = clone_object( "/obj/baggage" )
            string *temp
            box.set_name( "box" )
            box->set_long( "This is a box used in the auction room inheritable. "
            "How did you get hold of one?\n" )
            box.set_weight( 500000 )
            box.set_max_weight( 500000 )
            box.set_volume( 500000 )
            if ( sizeof( filter( obs.move( box ), (: $1 != 0 :) ) ) )
            return ERROBNOMOVE
            temp = create_auto_load( [box], 0 )
            if ( !arrayp( temp ) )
            return ERRGENFAIL
            obs.dest_me()
            obs -= [0]
            if ( sizeof( obs ) ) {
            #ifdef DEBUG
            log_file( "REAS", "%s: WARNUNDEST generated by object %s.\n", ctime( time() ),
            query_multiple_short( map( obs, (: file_name( $1 ) :) ) ) )
            #endif


    def lot_check(self, ) -> None:
            c_lot temp_lot
            c_store current_store
            object new_case
            object *all_new_cases = [})
            object *obs
            object *exp_cases
            int *active_lots
            string name
            int *bids
            cases = filter( cases, (: objectp( $1 ) :) )
            active_lots = map( filter( lots, (: ( (c_lot) $1)->status == OPEN :) ),
            (: ( (c_lot) $1)->case_code :) )
            if ( sizeof( cases ) < sizeof( active_lots ) ) {
            active_lots = active_lots - values( cases )
            foreach( int temp in active_lots ) {
            temp_lot = filter( lots, (: $1->case_code == $(temp) :) )[0]
            current_store = temp_lot->assoc_store
            new_case = clone_object( "/std/object" )
            new_case.set_name( "case" )
            new_case.set_short( current_store->colour + " case" )
            new_case->set_long( "This is a display case used in this auction shop. "
            "It contains " + current_store->inv_string +".\nYou can \"browse\" these"
            " items.\n" )
            new_case.add_adjective( current_store->colour )
            new_case.move( self )
            new_case.reset_get()
            new_case.add_extra_look( self )
            used_colours += [current_store->colour]
            cases += ([ new_case: temp ])
            all_new_cases += [new_case]


    def do_deposit(self, things: MudObject, auction_time: int, time_type: str, res_price: str) -> int:
            mixed *auto_load_string
            c_lot temp
            c_store temp2
            int value
            int finishtime
            if ( auction_time <= 0 || ( time_type == "day" && auction_time > 10 )
            || ( time_type == "minute" && auction_time > 59 ) ||
            ( time_type == "hour" && auction_time > 23 ) ) {
            this_player()->add_failed_mess( self,
            "That's not a valid length.\n" )
            return 0


    def do_list(self, ) -> int:
            c_lot *_lots
            c_lot _lot
            string str
            if ( !sizeof( cases ) ) {
            write( "There is nothing up for auction in this store.\n" )
            return 1


    def remove_lot(self, ob: MudObject) -> None:
            if ( keys( cases .index( ob) if  ob in keys( cases  else -1 ) == -1 )  {
            return


    def do_bid(self, offer: str, boxes: MudObject) -> int:
            c_lot temp
            c_lot *temps
            c_store temp2
            object box
            int value
            if ( sizeof( boxes ) > 1 ) {
            this_player()->add_failed_mess( self,
            "You can only $V on one case at "
            "a time.\n" )
            return 0


    def do_browse(self, boxes: MudObject, target: str, identifier: int) -> int:
            object box
            c_store container
            c_item temp
            mapping contents = ([ ])
            string *names = [})
            mixed *longadj = [})
            string temp2
            mixed *contenders
            string *contender
            string *adjectives
            string name
            string word
            int keep_flag
            if ( sizeof( boxes ) > 1 ) {
            this_player()->add_failed_mess( self,
            "You can only $V one case at a time.\n" )
            return 0


    def adjust_money(self, amount: int, player: MudObject) -> None:
            object money
            if ( amount < 0 ) {
            player.pay_money(MONEY_HAND->create_money_array(-amount, currency ))
            return


    def load_file(self, ) -> None:
            if ( !stringp( location ) ) return
            if ( file_size( location +".o" ) < 0 ) return
            unguarded( (: restore_object, location :) )
            return


    def save_file(self, ) -> None:
            if ( location == "unset" ) return
            unguarded( (: save_object, location :) )
            return


    def dest_me(self, ) -> None:
            save_file()
            if ( sizeof( cases ) ) keys( cases )->dest_me()
            ::dest_me()


    def recover_lot(self, lot_autoload: Any) -> Any:
            object *boxes
            object *stuff
            boxes = load_auto_load_to_array( lot_autoload, this_player() )
            if ( !objectp( boxes[0] ) ) {
            #ifdef DEBUG
            log_file( "REAS", "%s: Could not recover: %O.\n", ctime( time() ),
            lot_autoload )
            #endif
            return ERRNORECV


    def do_withdraw(self, boxes: MudObject) -> int:
            object box
            c_lot *_lots
            object *obs
            if ( sizeof( boxes ) > 1  ) {
            this_player()->add_failed_mess( self,
            "You can only $V on one case at "
            "a time.\n" )
            return 0


    def do_describe(self, boxes: MudObject, int_desc: str) -> int:
            object box
            c_lot *_lots
            c_lot  _lot
            int code
            if ( sizeof( boxes ) > 1 ) {
            this_player()->add_failed_mess( self,
            "You can only $V on one case at "
            "a time.\n" )
            return 0


    def extra_look(self, ob: MudObject) -> str:
            c_lot temp, *temp2
            mixed bid_info
            string ret
            int code
            if ( keys( cases .index( ob) if  ob in keys( cases  else -1 ) == -1 ) return ""
            code = cases[ ob ]
            temp2 = filter( lots, (: $1->case_code == $(code) :) )
            if ( sizeof( temp2 ) != 1 ) return sizeof( temp2 ) +" found in lot array!\n"
            temp = temp2[0]
            bid_info = temp->current_bid
            ret = ""
            if ( !stringp( bid_info[ AUCTION_PLAYER_NAME ] ) ) {
            if ( temp->reserve_price ) {
            ret += "Reserve price is: "
            ret += MONEY_HAND.money_value_string( temp->reserve_price, currency )
            ret += ".\n"


    def do_collect(self, pattern: str) -> int:
            int amount
            c_lot _lot, *_lots = [}), *_exp_lots
            object *items = [})
            _exp_lots = filter( lots, (: ((c_lot)$1)->status != OPEN :) )
            _exp_lots = filter( _exp_lots, (: ((c_lot)$1)->status != CLOSED :) )
            _exp_lots = filter( _exp_lots, (: ((c_lot)$1)->status != WAIT_CRE_INTERVENTION :) )
            if ( pattern == "all" ) {
            do_collect( "money" )
            do_collect( "successful bids" )
            do_collect( "expired lots" )
            return 1


    def do_exclude(self, boxes: MudObject, excluded: str) -> int:
            object box
            c_lot *_lots
            c_lot  _lot
            int code
            string *ignored = this_player()->query_property( "ignoring" )
            if ( sizeof( boxes ) > 1 ) {
            this_player()->add_failed_mess( self,
            "You can only $V people from one case at "
            "a time.\n" )
            return 0


    def do_unexclude(self, boxes: MudObject, excluded: str) -> int:
            object box
            c_lot *_lots
            c_lot  _lot
            int code
            if ( sizeof( boxes ) > 1 ) {
            this_player()->add_failed_mess( self,
            "You can only $V people from one case at "
            "a time.\n" )
            return 0


    def generate_advertising_string(self, lot: Any) -> str:
            string c_string
            if ( intp( lot->current_bid[ 0 ] ) && ( lot->current_bid[ 0 ] ) )
            c_string = MONEY_HAND.money_value_string( lot->current_bid[ 0 ], currency )
            else
            if ( intp( lot->reserve_price ) && lot->reserve_price )
            c_string = MONEY_HAND.money_value_string( lot->reserve_price, currency )
            else
            c_string = "make an offer"
            if ( c_string == "make an offer" )
            return lot->assoc_store->inv_string + ", " + c_string +
            " but hurry, bidding stops at " + amtime( lot->expiration_time )
            return lot->assoc_store->inv_string + ", currently going for " + c_string +
            " but hurry, bidding stops at " + amtime( lot->expiration_time )


    def generate_random_adv_string(self, ) -> str:
            c_lot temp
            if ( sizeof( lots ) ) {
            temp = lots[ random( sizeof( lots ) ) ]
            if ( temp->status != OPEN )
            return WARNNOLOTS
            else return generate_advertising_string( temp )



class Auction_room(Room):
