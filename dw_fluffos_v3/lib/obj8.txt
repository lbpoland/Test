
=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/map.c ===
#include <map_handler.h>
#include <config.h>
inherit "/obj/handlers/inherit/distance_handler";
mapping shorts = ([ ]);
mapping movezoness = ([ ]);
mapping changetimes = ([ ]);
#if !efun_defined(db_exec)
mapping clusters = ([ ]);
mapping map = ([ ]);
#else
int db, loop = 0;
#include <db.h>
#endif
mapping forced_rooms = ([ ]);
#ifdef COORDS
mapping coords = ([ ]);
mapping sizes = ([ ]);
#endif
int load = 0, time, stopped;
string *cache = ({ }), *queue = ({ });
int check_next_call_out;
mapping stats = ([]);
private void do_room1( string room );
private void check_next();
private void check_map2( string );
void create() {
   seteuid( (string)"secure/master"->get_root_uid() );
   "/room/void"->force_load();
   check_next_call_out = call_out( (: check_next :), SKEWTIME );
#if efun_defined(db_exec)
   db = db_connect("localhost","discworld",CONFIG_DB_USER);
#endif
}
protected void update_cache( string directory, int load ) {
   if ( !shorts[ directory ] || load ) {
      cache = ( cache - ({ directory }) ) + ({ directory });
      if ( sizeof( cache ) > CACHESIZE ) {
         map_delete( shorts, cache[ 0 ] );
         map_delete( movezoness, cache[ 0 ] );
         map_delete( changetimes, cache[ 0 ] );
#if !efun_defined(db_exec)
         map_delete( clusters, cache[ 0 ] );
         map_delete( map, cache[ 0 ] );
#endif
#ifdef COORDS
         map_delete( coords, cache[ 0 ] );
         map_delete( sizes, cache[ 0 ] );
#endif
         cache -= ({ cache[ 0 ] });
         LOG( sprintf( "%%^RED%%^uncaching %s%%^RESET%%^\n", cache[ 0 ] ) );
      }
      shorts[ directory ] = MH->query_shorts( directory );
      movezoness[ directory ] = MH->query_movezones( directory );
      changetimes[ directory ] = MH->query_changetimes( directory );
#if !efun_defined(db_exec)
      clusters[ directory ] = MH->query_clusters( directory );
      map[ directory ] = MH->query_map( directory );
#endif
#ifdef COORDS
      coords[ directory ] = MH->query_co_ords( directory );
      sizes[ directory ] = MH->query_sizes( directory );
#endif
   }
}
void clear_cache() {
   shorts = ([ ]);
   movezoness = ([ ]);
   changetimes = ([ ]);
#if !efun_defined(db_exec)
   clusters = ([ ]);
   map = ([ ]);
#endif
#ifdef COORDS
   coords = ([ ]);
   sizes = ([ ]);
#endif
   cache = ({ });
}
#if !efun_defined(db_exec)
mapping query_map( string dir ) {
   if ( !map[ dir ] ) {
     update_cache( dir, 1 );
   }
   stats["map"]++;
   return map[ dir ];
}
void change_map( string dir, string room, string *dd ) {
   MH->change_map( dir, room, dd );
   map[ dir ][ room ] = dd;
}
#endif
mapping query_shorts( string dir ) {
   if ( !shorts[ dir ] ) {
      update_cache( dir, 1 );
   }
   stats["shorts"]++;
   return shorts[ dir ];
}
void change_shorts( string dir, string room, string sh ) {
   MH->change_shorts( dir, room, sh );
   shorts[ dir ][ room ] = sh;
}
mapping query_movezones( string dir ) {
   if ( !movezoness[ dir ] ) {
      update_cache( dir, 1 );
   }
   stats["movezones"]++;
   return movezoness[ dir ];
}
void change_movezones( string dir, string room, string *zones ) {
   MH->change_movezones( dir, room, zones );
   movezoness[ dir ][ room ] = zones;
}
mapping query_changetimes( string dir ) {
   if ( !changetimes[ dir ] ) {
      update_cache( dir, 1 );
   }
   stats["changetimes"]++;
   return changetimes[ dir ];
}
void change_changetimes( string dir, string room, int time ) {
   MH->change_changetimes( dir, room, time );
   changetimes[ dir ][ room ] = time;
}
#if !efun_defined(db_exec)
mapping query_clusters( string dir ) {
  if ( !clusters[ dir ] ) {
    update_cache( dir, 1 );
  }
  return clusters[ dir ];
}
void change_clusters( string dir, string room, int cluster ) {
   MH->change_clusters( dir, room, cluster );
   if(clusters[ dir ])
     clusters[ dir ][ room ] = cluster;
}
#endif
#ifdef COORDS
mapping query_co_ords( string dir ) {
   if ( !coords[ dir ] )
      update_cache( dir, 1 );
   stats["co_ords"]++;
   return coords[ dir ];
}
void change_co_ords( string dir, string room, int *coord ) {
   MH->change_co_ords( dir, room, coord );
   coords[ dir ][ room ] = coord;
}
mapping query_sizes( string dir ) {
   if ( !sizes[ dir ] )
      update_cache( dir, 1 );
   stats["sizes"]++;
   return sizes[ dir ];
}
void change_sizes( string dir, string room, int *size ) {
   MH->change_sizes( dir, room, size );
   sizes[ dir ][ room ] = size;
}
#endif
void del( string dir, string room ) {
   MH->del( dir, room );
   update_cache( dir, 1 );
}
#if !efun_defined(db_exec)
int query_cluster( string room ) {
  string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
  string troom = explode( room, "/" )[ <1 ];
  if ( troom[ <2.. ] == ".c" ) {
    troom = troom[ 0..<3];
  }
  if( !clusters[ directory ] ) {
    update_cache( directory, 1 );
  }
  if( !clusters[ directory ] ) {
    clusters[ directory ] = ([]);
  }
  return query_clusters( directory )[ troom ];
}
void set_cluster( string room, int cluster ) {
  string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
  string troom = explode( room, "/" )[ <1 ];
  if ( troom[ <2.. ] == ".c" ) {
    troom = troom[ 0..<3];
  }
  change_clusters( directory, troom, cluster);
}
#endif
string *query_dest_dir( string room ) {
#if !efun_defined(db_exec)
  string directory, troom;
#else
  mixed rows;
  string *ret;
  int i = 0;
#endif
  stats["dest_dir"]++;
  if(!room || room == "/" || room == "" || strsrch(room, "/") == -1)
    return ({ });
#if !efun_defined(db_exec)
  directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
  troom = explode( room, "/" )[ <1 ];
  if ( troom[ <2.. ] == ".c" ) {
    troom = troom[ 0..<3];
  }
  if( !query_map( directory )[ troom ] ) {
    check_map2( room );
  }
  return query_map( directory )[ troom ];
#else
  if ( room[ <2.. ] == ".c" ) {
    room = room[ 0..<3];
  }
  if(loop == time())
    return ({});
  loop = time();
  rows = db_exec(db, "select exit, dest from roomexit where id = '%s'", db_escape(room));
  if(stringp(rows)||!rows){
    forced_rooms[ room ] = 1;
    check_map2( room );
    rows = db_exec(db, "select exit, dest from roomexit where id = '%s'", db_escape(room));
    if(stringp(rows)){
      loop = 0;
      return ({ });
    }
  }
  ret = allocate(rows * 2);
  for(i=0; i<rows; i++){
    string *row;
    row = db_fetch(db, i + 1);
    ret[i*2] = row[0];
    ret[i*2+1] = row[1];
  }
  loop = 0;
  return ret;
#endif
}
string *qdd( string room ) {
   return query_dest_dir( room );
}
string query_destination( string exit, string room ) {
   int i;
   string *dest_dir;
   stats["destination"]++;
   if( !room || room == "") {
      room = file_name( environment( previous_object() ) );
      if( !room ) return "/room/void";
   }
   dest_dir = query_dest_dir( room );
   i = member_array( exit, dest_dir );
   if( i < 0 ) return "/room/void";
   return dest_dir[ i + 1 ];
}
string qdes( string exit, string room ) {
   return query_destination( exit, room );
}
string *qdir( string room ) {
   int i;
   string *qddir, *dir=({});
   stats["qdir"]++;
   if( !room || room == "") {
      room = file_name( environment( previous_object() ) );
      if( !room ) return ({ "/room/void" });
   }
   qddir = query_dest_dir( room );
   for( i = sizeof( qddir ) - 2;i > -1;i -= 2)
     dir += ({ qddir[ i ]} );
   return dir;
}
string *query_cache() { return cache; }
string *query_queue() { return queue; }
void set_stopped( int s ) { stopped = s; }
int compare_arrays( mixed *ar1, mixed *ar2 ) {
   int i;
   if ( !ar1 && !ar2 ) return 0;
   if ( sizeof( ar1 ) != sizeof( ar2 ) ) return 1;
   i = sizeof( ar1 );
   while ( i-- ) {
      if ( ar1[ i ] != ar2[ i ] ) {
         return 1;
      }
   }
   return 0;
}
varargs void queue_room( string room, int force, string reason ) {
   queue -= ({ room });
   queue += ({ room });
   forced_rooms[ room ] = force;
#ifdef LOGTO
   if ( !reason ) reason = "";
   LOG( sprintf( "%%^RED%%^Queueing %s(%i) %s.%%^RESET%%^\n",
                room, sizeof( queue ), reason ) );
#else
   reason = reason;
#endif
}
void do_room( string room ) {
   call_out( (: do_room1 :), 1, room );
}
private void do_room1( string room ) {
   mixed tmp;
   int changetime;
   string directory = implode( explode( room, "/" )[ 0 .. <2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" )
      troom = troom[ 0 .. <3 ];
   if ( directory[ 0 ] == 'w' ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ in /w/.\n", room ) );
      return;
   }
   if ( directory[ 0 .. 2 ] == "std" ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ in /std/.\n", room ) );
      return;
   }
   tmp = stat( room +".c" );
   if( !pointerp( tmp ) || sizeof( tmp ) < 2 ) {
      tmp = stat( room );
      if( !pointerp( tmp ) || sizeof( tmp ) < 2 )
         return;
   }
   tmp = find_object( room );
   if ( tmp ) {
      if( tmp->query_property( "no map" ) ) {
         LOG( sprintf( "%%^BLUE%%^Skipping %s%%^RESET%%^, it asked me to.\n",
                      tmp->a_short() ) );
         return;
      }
#ifdef COORDS
      tmp->calc_co_ord();
      if ( sizeof( tmp->query_co_ord() ) >
          sizeof( query_co_ords( directory )[ troom ] ) ) {
         queue_room( room, 1, "new co_ordinates");
         return;
      }
#endif
   }
   tmp = stat( room +".c" );
   if ( query_changetimes( directory )[ troom ] ==
       ( changetime = tmp[ TIME ] ) ) {
      return;
   }
   queue -= ({ room });
   queue += ({ room });
   LOG( sprintf( "%%^RED%%^Queueing %s(%i).%%^RESET%%^\n",
                room, sizeof( queue ) ) );
}
private void check_next() {
   string room;
   if ( sizeof( queue ) && !stopped ) {
        check_next_call_out = call_out( (: check_next :), SKEWTIME );
      room = queue[ 0 ];
      queue -= ({ room });
      check_map2( room );
   } else {
      check_next_call_out = call_out( (: check_next :), 60 );
   }
}
private void check_short( object room_obj, string room_short, string room ) {
   string tmp_short, bad_short;
   if(!room_short)
     return;
   tmp_short = lower_case(room_short);
   bad_short = 0;
   if ( tmp_short[ 0 .. 4 ] == "an a " ||
       tmp_short[ 0 .. 5 ] == "an an " ||
       tmp_short[ 0 .. 5 ] == "the the " ||
       tmp_short[ 0 .. 5 ] == "a the " ) {
      bad_short = "strange or missing determinate";
   } else {
      if(!sizeof(tmp_short))
         bad_short = "no short";
      else if ( tmp_short[ <1 ] == '.' ) {
         bad_short = "period in short";
      } else {
         if ( !(tmp_short = (string)room_obj->query_property( "determinate" ) ) ) {
            tmp_short = (string)room_obj->query_short();
            if ( tmp_short )
            if ( tmp_short[ 0 .. 0 ] != lower_case( tmp_short[ 0 .. 0 ] ) )
               bad_short = "suspicious capitalisation";
         } else {
            if ( tmp_short != "" ) {
               if ( tmp_short[ <1 ] != ' ' ) {
                  bad_short = "missing space in determinate";
               } else {
                  if ( tmp_short[ 0 .. 0 ] != lower_case( tmp_short[ 0 .. 0 ] ) ) {
                     bad_short = "suspicious capitalisation in determinate";
                  }
               }
            }
         }
      }
   }
   if ( bad_short ) {
      log_file( "STRANGE_SHORT","%s, %s (%s)\n",
               room_short, bad_short, room );
      LOG( sprintf( "%%^RED%%^%s.%%^RESET%%^\n", bad_short ) );
   }
}
void check_map( string room ) {
   do_room( room );
}
private void check_map2( string room ) {
   mixed tmp;
   int i, changetime, do_update;
   string *dest_dir, *tmpdest_dir, room_short, *movezones;
#ifdef COORDS
   int *coord;
   mixed size;
#endif
   object room_obj;
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   if ( directory[ 0 ] == 'w' ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ in /w/.\n", room ) );
      return;
   }
   if ( directory[ 0 .. 2 ] == "std" ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ in /std/.\n", room ) );
      return;
   }
   do_update = forced_rooms[ room ];
   tmp = stat( room +".c" );
   if( !pointerp( tmp ) || sizeof( tmp ) < 2 )
      return;
#ifdef COORDS
   if ( room_obj = find_object( room ) ) {
      room_obj->calc_co_ord();
      if ( ( sizeof( room_obj->query_co_ord() ) >
            sizeof( query_co_ords( directory )[ troom ] ) ) ||
          compare_arrays( room_obj->query_co_ord(),
                         query_co_ords( directory )[ troom ] ) ) {
         do_update = 1;
      }
   }
#endif
   if ( !do_update &&
       ( query_changetimes( directory )[ troom ] ==
        ( changetime = tmp[ TIME ] ) ) ) {
      return;
   }
   if ( !find_object( room ) )
      catch( room->force_load() );
   room_obj = find_object( room );
   queue -= ({ room });
   map_delete( forced_rooms, room );
   update_cache( directory, 0 );
   if( !room_obj ) {
      if( shorts[ directory ][ troom ] ) {
         dest_dir = query_dest_dir(room);
         for(i = 1; i < sizeof( dest_dir ); i += 2 )
            check_map( dest_dir[ i ] );
#if !efun_defined(db_exec)
         map_delete( map[ directory ], troom );
#endif
         map_delete( shorts[ directory ], troom );
         map_delete( movezoness[ directory ], troom );
         map_delete( changetimes[ directory ], troom );
#ifdef COORDS
         map_delete( coords[ directory ], troom );
         map_delete( sizes[ directory ], troom );
#endif
         del( directory, room );
         LOG( sprintf( "%%^RED%%^Removing %s,%%^RESET%%^.\n", room ) );
      }
      return;
   }
   if ( room_obj->query_property( "no map" ) ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ it asked me to.\n",
                   room ) );
      return;
   }
   room_short = (string)"/global/events"->convert_message(
         (string)room_obj->a_short() );
   if ( shorts[ directory ][ troom ] != room_short )
      do_update = 1;
   LOG( sprintf( "%%^YELLOW%%^Updating %s%%^RESET%%^. (%s)\n",
                room_short, troom ) );
#ifdef LOG_SHORTS
   check_short( room_obj, room_short, room );
#endif
   movezones = room_obj->query_zones();
   if ( !pointerp( movezones ) ) movezones = ({ });
   if ( movezoness[ directory ][ troom ] != movezones )
      do_update = 1;
#ifdef COORDS
   room_obj->calc_co_ord();
   coord = room_obj->query_co_ord();
   if ( !coord ) room_obj->calc_co_ord();
   coord = room_obj->query_co_ord();
   if ( !coords[ directory ] ) coords[ directory ] = ([ ]);
   if ( compare_arrays( coords[ directory ][ troom ], coord ) )
      do_update = 1;
   size = room_obj->query_room_size_array();
   if ( !sizes[ directory ] ) sizes[ directory ] = ([ ]);
   if ( sizes[ directory ][ troom ] != size )
      do_update = 1;
#endif
   if ( changetimes[ directory ][ troom ] != changetime )
      do_update = 1;
   if ( do_update ) {
      change_changetimes( directory, troom, changetime );
      change_movezones( directory, troom, movezones );
      change_shorts( directory, troom, room_short );
#ifdef COORDS
      if ( sizeof( coord ) == 3 )
         change_co_ords( directory, troom, coord );
      change_sizes( directory, troom, size );
#endif
      update_cache( directory, 1 );
   }
   dest_dir = room_obj->query_dest_dir();
   if( !dest_dir ) {
      dest_dir = ({ });
   } else {
      string exit;
      if( room_obj->query_blockage() ) {
        exit = room_obj->query_direction();
        if( !exit )
          for( i = 1; i < sizeof( dest_dir ); i += 2 )
            if( dest_dir[ i ]->query_blockage() ) {
              exit = dest_dir[ i - 1 ];
              break;
            }
      }
      if(!exit)
         exit = "";
      tmpdest_dir = ({ });
      for ( i = 1; i < sizeof( dest_dir ); i += 2 ) {
         mixed tmp2;
         catch(load_object(dest_dir[i]));
         if ( objectp( find_object( dest_dir[ i ] ) ) &&
                          !clonep( find_object( dest_dir[ i ] ) ) &&
              exit != dest_dir[i - 1] &&
              dest_dir[i - 1][0..5] != "enter " &&
              dest_dir[i][1] != 'w' &&
              dest_dir[i][1..3] != "std" &&
              dest_dir[i][1..4] != "room" &&
                     (catch(tmp2 = dest_dir[i]->query_property( "no map" )), !tmp2)) {
            tmpdest_dir += ({ dest_dir[ i - 1 ], dest_dir[ i ] });
         }
      }
      dest_dir = tmpdest_dir;
   }
   if ( compare_arrays( query_dest_dir(room), dest_dir ) ) {
#if !efun_defined(db_exec)
      map[ directory ][ troom ] = dest_dir;
#else
      db_exec(db, "delete from roomexit where id = '%s'", db_escape(room));
      for(i=0; i<sizeof(dest_dir)/2; i++){
        db_exec(db, "insert into roomexit values ('%s', '%s', '%s')",
                db_escape(room), db_escape(dest_dir[i*2]),
                db_escape(dest_dir[i*2+1]));
      }
#endif
      for( i = 1; i < sizeof( dest_dir );i += 2 ) {
         if ( dest_dir[ i ][ <2.. ] == ".c" ) {
#ifdef LOG_EXITS
            log_file("BAD_EXIT","from %s, %s to %s\n",
                     directory +"/"+ troom, dest_dir[ i-1 ], dest_dir[ i ] );
#endif
            dest_dir[ i ] = dest_dir[ i ][ 0..<3 ];
         }
      }
#if !efun_defined(db_exec)
      change_map( directory, troom, dest_dir );
#endif
#ifdef PARANOID
      update_cache( directory, 1 );
#endif
      for( i = 1; i < sizeof( dest_dir ); i += 2 ) {
         do_room( dest_dir[ i ] );
      }
#ifdef PARANOID
      return;
#endif
   }
#ifdef PARANOID
   update_cache( directory, 1 );
#endif
}
string query_short( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   stats["short"]++;
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return (string)"/global/events"->convert_message(
                     (string)room->a_short() );
      } else {
         return "The map_handler was called on a non-existent clone";
      }
   }
   if ( !shorts[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !shorts[ directory ] ) {
      shorts[ directory ] = ([ ]);
   }
   if ( shorts[ directory ][ troom ] ) {
     return shorts[ directory ][ troom ];
   }
   if ( !catch( load_object(room) ) ) {
     return (string)"/global/events"->convert_message(
                            (string)room->a_short() );
   }
   return "Oops!";
}
string static_query_short( string room ) {
   string directory, troom;
   if(!stringp(room))
     return "";
   directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   stats["static short"]++;
   if ( !shorts[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !shorts[ directory ] ) {
      shorts[ directory ] = ([ ]);
   }
   if ( shorts[ directory ][ troom ] ) {
     return shorts[ directory ][ troom ];
   }
   return 0;
}
string *query_zones( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   object roomob;
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   stats["zones"]++;
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return (string *)room->query_movezones();
      } else {
         return ({ });
      }
   }
   if ( !movezoness[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !movezoness[ directory ] ) {
      movezoness[ directory ] = ([ ]);
   }
   if ( movezoness[ directory ][ troom ] ) {
     return movezoness[ directory ][ troom ];
   }
   if ( !catch( roomob = load_object(room) ) ) {
     if(roomob)
       return roomob->query_movezones();
   }
   return ({ "Oops!" });
}
#ifdef COORDS
void set_co_ord( string room, int *coord ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   if ( !coords[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !coords[ directory ] ) {
      coords[ directory ] = ([ ]);
   }
   MH->change_co_ords( directory, troom, coord );
   coords[ directory ][ troom ] = coord;
}
int *query_co_ord( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   stats["co_ord"]++;
   LOG( sprintf( "%%^BLUE%%^query_co_ord(%s)%%^RESET%%^\n", room ) );
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return room->query_co_ord();
      } else {
         return 0;
      }
   }
   if ( !coords[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !coords[ directory ] ) {
      coords[ directory ] = ([ ]);
   }
   if ( coords[ directory ][ troom ] ) {
     return coords[ directory ][ troom ];
   }
   if ( !catch( load_object(room ) ) ) {
     return room->query_co_ord();
   }
   return 0;
}
int *static_query_co_ord( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   stats["static co_ord"]++;
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return room->query_co_ord();
      } else {
         return 0;
      }
   }
   if ( !coords[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !coords[ directory ] ) {
      coords[ directory ] = ([ ]);
   }
   if ( coords[ directory ][ troom ] ) {
     return coords[ directory ][ troom ];
   }
   return 0;
}
int *query_room_size( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   stats["room_size"]++;
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return room->query_room_size_array();
      } else {
         return 0;
      }
   }
   if ( !sizes[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !sizes[ directory ] ) {
      sizes[ directory ] = ([ ]);
   }
   if ( sizes[ directory ][ troom ] ) {
     return sizes[ directory ][ troom ];
   }
   if (!catch(room->force_load())) {
      return room->query_room_size_array();
   }
   return 0;
}
#endif
int test_room( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   if ( strsrch( room, "#" ) != -1 )  {
      return 1;
   }
   if ( !shorts[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !shorts[ directory ] ) {
      shorts[ directory ] = ([ ]);
   }
   if ( shorts[ directory ][ troom ] ) {
     return 1;
   }
   if ( !catch( load_object(room) ) ) {
     return 1;
   }
   return 0;
}
int query_known( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   if ( !shorts[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !shorts[ directory ] ) {
      shorts[ directory ] = ([ ]);
   }
   return !undefinedp(shorts[ directory ][troom]);
}
void check_save_files() {
   string *files, file, room, *tmp;
   files = unguarded((: get_dir, "/save/map/" :));
   files = map( files, (: replace( $1, ({ "_", "/", ".o", ""}) ) :) );
   foreach( file in files ) {
      printf( "%s\n", file );
      tmp = keys( MH->query_map( file ) );
      reset_eval_cost();
      foreach( room in tmp ) {
         if( file_size( file +"/"+ room + ".c" ) < 0 ) {
            printf( "%s no longer exists.\n", file + "/" + room );
            MH->del( file, room );
         }
      }
   }
   cache = ({ });
}
mapping query_dynamic_auto_load() {
   mapping tmp;
   tmp = ([ "shorts" : shorts,
            "movezoness" : movezoness,
            "changetimes" : changetimes,
#if !efun_defined(db_exec)
            "clusters" : clusters,
            "map" : map,
#endif
#ifdef COORDS
            "coords" : coords,
            "sizes" : sizes,
#endif
            "cache" : cache,
            "queue" : queue,
          ]);
   return tmp;
}
void init_dynamic_arg(mapping maps) {
   if (maps["shorts"])
      shorts = maps["shorts"];
   if (maps["movezoness"])
      movezoness = maps["movezoness"];
   if (maps["changetimes"])
      changetimes = maps["changetimes"];
#if !efun_defined(db_exec)
   if (maps["clusters"])
      clusters = maps["clusters"];
   if (maps["map"])
     map = maps["map"];
#endif
#ifdef COORDS
   if (maps["coords"])
      coords = maps["coords"];
   if (maps["sizes"])
      sizes = maps["sizes"];
#endif
   if (maps["cache"])
      cache = maps["cache"];
   if (maps["queue"])
      queue = maps["queue"];
}
mixed *stats() {
   return ({
      ({ "queue size", sizeof( queue ) }),
      ({ "cache size", sizeof( cache ) }),
      ({ "next check", find_call_out( check_next_call_out ) }),
        }) + map(keys(stats), (:({$1, $(stats)[$1]}):));
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/quest_handler.c ===
#include <library.h>
#include <player_handler.h>
#define QUEST_LOG "QUESTS"
#define SAVE_FILE "/save/quests"
#define BACKUP_FILE "/save/quests/quests"
inherit "/std/object";
private int *quest_level;
private int *num_times_done;
private int *quest_status;
private string *quest_name;
private string *quest_title;
private string *quest_story;
private string *last_done_by;
private nosave int total_qp;
void load_quests() { unguarded( (: restore_object, SAVE_FILE :) ); }
void save_quests() { unguarded( (: save_object, SAVE_FILE :) ); }
void create() {
   int i;
   ::create();
   load_quests();
   if ( !quest_name ) {
      quest_name = ({ });
   }
   if ( !quest_level ) {
      quest_level = ({ });
   }
   if ( !quest_title ) {
      quest_title = ({ });
   }
   if ( !quest_story ) {
      quest_story = ({ });
   }
   if ( !last_done_by ) {
      last_done_by = ({ });
   }
   if ( !num_times_done ) {
      num_times_done = ({ });
   }
   if ( !quest_status ) {
     if(sizeof(quest_name)) {
       quest_status = allocate(sizeof(quest_name));
       for(i=0; i<sizeof(quest_name); i++) {
         quest_status[i] = 1;
       }
     } else {
       quest_status = ({ });
     }
   }
   for(i = 0; i<sizeof(quest_level); i++) {
     if(quest_status[i]) {
       total_qp += quest_level[i];
     }
   }
}
int query_total_qp() { return total_qp; }
int add_quest( string name, int level, string title, string story ) {
   string log_name;
   if ( member_array( name, quest_name ) != -1 )
      return 0;
   quest_name += ({ name });
   quest_level += ({ level });
   quest_title += ({ title });
   quest_story += ({ story });
   last_done_by += ({ "nobody" });
   num_times_done += ({ 0 });
   quest_status += ({ 1 });
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file( QUEST_LOG, log_name +
         " added: "+ name +", "+ level +", "+ title +", "+ story +"\n" );
   save_quests();
   unguarded( (: cp, SAVE_FILE +".o", BACKUP_FILE +"."+ time() :) );
   total_qp += level;
   return 1;
}
int change_quest_status(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  quest_status[temp] = !quest_status[temp];
  return quest_status[temp];
}
int query_quest_status(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  return quest_status[temp];
}
int query_quest_level(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  return quest_level[temp];
}
int set_quest_level(string name, int level) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : level set for %s to %d\n\n",
            log_name, name, level);
   quest_level[ temp ] = level;
   save_quests();
   return 1;
}
string query_quest_story(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return "did nothing";
  }
  return quest_story[temp];
}
int set_quest_story(string name, string story) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : story set for %s to %s\n\n",
            log_name, name, story);
   quest_story[ temp ] = story;
   save_quests();
   return 1;
}
string query_quest_title(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1 || quest_title[temp] == "") {
    return "Unknown Quester";
  }
  return quest_title[temp];
}
int set_quest_title(string name, string title) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : title set for %s to %s\n\n",
            log_name, name, title);
   quest_title[ temp ] = title;
   save_quests();
   return 1;
}
int query_quest_times( string name ) {
   int i;
   i = member_array( name, quest_name );
   if ( i == -1 )
      return -1;
   return num_times_done[ i ];
}
mixed query_quest_done( string name ) {
   int i;
   i = member_array( name, quest_name );
   if ( i == -1 )
      return -1;
   return last_done_by[ i ];
}
int delete_quest(string name) {
   int temp;
   string log_name;
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, log_name + " removed : " +
            name + "\n\n");
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   total_qp -= quest_level[temp];
   quest_name = delete(quest_name, temp, 1);
   quest_level = delete(quest_level, temp, 1);
   quest_title = delete(quest_title, temp, 1);
   quest_story = delete(quest_story, temp, 1);
   last_done_by = delete( last_done_by, temp, 1 );
   num_times_done = delete( num_times_done, temp, 1 );
   save_quests();
   return 1;
}
string *query_quest_names() {
  return quest_name + ({ });
}
int *query_quest_levels() {
  return quest_level + ({ });
}
string *query_quest_titles() {
  return quest_title + ({ });
}
string *query_quest_stories() {
  return quest_story + ({ });
}
void quest_completed( string name, string quest, object prev_ob ) {
   int i;
   string word;
   log_file( QUEST_LOG, ctime( time() ) +" "+ name +" completed "+
         quest +"\n" );
   user_event( "inform", name +" completes "+ quest, "quest" );
   if ( file_name( previous_object() ) != LIBRARY ) {
      prev_ob = previous_object();
   }
   word = (string)prev_ob->query_name();
   if ( !word ) {
      word = file_name( prev_ob );
   } else {
      word += " ("+ file_name( prev_ob ) +")";
   }
   log_file( QUEST_LOG, "given by "+ word +"\n" );
   i = member_array( quest, quest_name );
   if ( i == -1 ) {
      log_file( QUEST_LOG, "non existent quest\n" );
      return;
   }
   last_done_by[ i ] = name;
   num_times_done[ i ]++;
   save_quests();
}
int query_player_fame(string name){
   int playerqp, rank;
   if (!name){
      return 0;
   }
   if (this_player()){
      name = (string)this_player()->expand_nickname(name);
   }
   if (!PLAYER_HANDLER->test_user(name)){
      return 0;
   }
   playerqp = (int)LIBRARY->query_quest_points(name);
   rank = ( playerqp * 125 ) / query_total_qp();
   return rank;
}
string query_fame_str( string name ) {
   switch ( query_player_fame( name ) ) {
      case 0 .. 4 :
         return "completely unknown";
      case 5 .. 14 :
         return "unknown";
      case 15 .. 24 :
         return "unknown";
      case 25 .. 34 :
         return "moderately well known";
      case 35 .. 44 :
         return "well known";
      case 45 .. 54 :
         return "very well known";
      case 55 .. 64 :
         return "known throughout the region";
      case 65 .. 74 :
         return "famous";
      case 75 .. 84 :
         return "renowned";
      case 85 .. 94 :
         return "Disc renowned";
      default :
         return "so renowned that no introduction is needed";
   }
}
string *query_player_story(string name){
   string *quests;
   string *story;
   int i;
   story = ({ });
   if (!name){
      return ({ });
   }
   if (this_player()){
      name = (string)this_player()->expand_nickname(name);
   }
   if (!PLAYER_HANDLER->test_user(name)){
      return 0;
   }
   quests = query_quest_names();
   if (sizeof(quests) == 1){
      story = ({"Is an under achiever."});
   }
   else{
      for(i=0;i<sizeof(quests);i++){
         if (LIBRARY->query_quest_done(name, quests[i])){
            story = ({ query_quest_story( quests[ i ] ) }) + story;
         }
      }
   }
   return story;
}
void print_some_stats()  {
   int i;
   for (i = 0; i < sizeof(quest_name); i++)
      printf("%s: %6d, %3d\n", quest_name[i], num_times_done[i], quest_level[i]);
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/mailer.c ===
#include <mime.h>
#include <mail.h>
#include <localtime.h>
#include <player_handler.h>
#define FOLDER_H "/obj/handlers/folder_handler.c"
#define MAIL_PATH "/save/mail/"
#define COLS (int)owner->query_cols()
#define ROWS (int)owner->query_rows()
#undef CONVERTER
nosave class mail_header *folder;
nosave int *deleted, *newish, no_menu, last_read, full_header;
nosave string current, to, subject, cc, mailrc;
nosave mixed *do_this_last;
nosave object owner;
nosave string *ignore = ({
  "email-version",
  "x-lines",
  "expires",
  "transport-options",
  "x-mailer",
  "errors-to",
  "lines",
  "priority",
  "newsgroups",
  "default-options",
  "auto-forward-count",
  "ua-message-id",
  "approved",
  "followup-to",
  "message-version",
  "message-id",
  "message-service",
  "message-type",
  "sender",
  "end-of-header",
  "content-type",
  "path",
  "report-version",
  "submitted-by",
  "message-protocol",
  "posting-number",
  "x-postmark",
  "apparently-to",
  "organization",
  "posted-date",
  "return-receipt-to",
  "keywords",
  "x-sun-charset",
  "summary",
  "in-reply-to",
  "reply-to",
  "distribution",
  "sent-by",
  "company",
  "references",
  "mts-message-id",
  "x-sequence",
  "via",
  "content-charset",
  "status",
  "confirmed-by",
  "ua-content-id",
  "content-length",
  "mime-version",
  "auto-forwarded-from",
  "content-transfer-encoding",
  "received",
  "end-of-protocol",
  "x-uidl",
  "precedence",
  "return-path"
});
string *folder_names;
varargs protected void rm_message(string input);
protected void unrm_message(string input);
private void print_message(int number);
varargs private void reply_message(int input, int flag);
private void save_me();
private int load_me();
void dest_me();
private void read_messages(string fname);
protected void read_loop(string input);
private void prompt();
protected void change_folder(string input);
varargs private void delete_it(string bonk, int last, string newish_folder);
varargs protected void move_message(string input, int flag);
private void save_message(string input);
protected void get_recipient(string input);
varargs protected void get_subject(string input, int number, int flag);
varargs protected void main_menu(string fname, int flag, int *range);
protected void forward_message(string input);
void finish_write_message(string input);
string format_date(int x);
private int *expand_range(string str);
private int valid_name(string str);
void read_mail(string str, string sub);
private void forward_email(int number);
private void write_message();
private void check_external_mail();
private void create() {
    mapping aliases;
    seteuid("Mailer");
    no_menu = full_header = 0;
    last_read = -1;
    newish = ({ });
    folder = ({ });
    folder_names = ({ "inbox" });
    deleted = ({ });
    current = "";
    if (clonep()) {
        owner = this_player();
        if (owner) {
            aliases = owner->query_aliases();
            if (aliases) {
                mailrc = aliases[".mailrc"];
            }
        }
    } else {
        check_external_mail();
    }
}
#define HEADER_NAME 1
#define HEADER_VAL  2
private string folder_filename(string name) {
    return MAIL_PATH+name[0..0] + "/"  + name;
}
private string strip_header(string message) {
    mixed *ra;
    int i;
    string header;
    if ((i = strsrch(message, "\n\n")) == -1) {
        return message;
    }
    header = message[0..i];
    message = message[i+1..];
    ra = reg_assoc(header,
      ({ "^[!-9;-~]+:", "((\n?[ \t])+[^\n]*(\n|$))+" }),
      ({ HEADER_NAME, HEADER_VAL }));
    for (i = 1; i + 2 < sizeof(ra[0]); i += 2) {
        if (ra[1][i] == HEADER_NAME && ra[1][i+2] == HEADER_VAL) {
            if (member_array(replace_string(lower_case(ra[0][i]), ":", ""),
                ignore) != -1) {
                ra[0][i] = ra[0][i+2] = "";
            }
        }
    }
    return implode(ra[0], "") + message;
}
private void check_external_mail() {
    string *dir, fname, mess, t, ccs;
    class mail_message msg = new(class mail_message);
    class mime_header hdr;
    dir = unguarded((: get_dir, EXTERNAL_MAIL_PATH :));
    if (!dir) {
        call_out((: check_external_mail :), 60);
        return;
    }
    foreach (fname in dir) {
        mess = unguarded((: read_file, EXTERNAL_MAIL_PATH + fname :));
        mess = replace(mess, ({ "\r\n", "\n", "\t", "        " }));
        hdr = MIME->parse_headers(mess);
        if (!hdr) {
            unguarded((: rm, EXTERNAL_MAIL_PATH + fname :));
            continue;
        }
        msg->from = hdr->header_m["from"];
        msg->subject = hdr->header_m["subject"];
        t = hdr->header_m["to"];
        if (!t) {
            continue;
        }
        msg->to = explode(t, ",");
        ccs = hdr->header_m["cc"];
        if (!ccs) {
            ccs = "";
        }
        msg->cc = explode(ccs, ",");
        msg->body = mess;
        FOLDER_H->add_it(msg, 1);
        unguarded((: rm, EXTERNAL_MAIL_PATH + fname :));
    }
    call_out((: check_external_mail :), 60);
}
void set_do_this_last(mixed *bing) { do_this_last = bing; }
mixed *query_do_this_last() { return do_this_last; }
varargs int do_mail_message(string t, string from, string sub, string ccs,
  string body, int, string only_to, int flag) {
    string *cc_e, *goto;
    class mail_message msg;
    if(file_name(previous_object())[0..12] != "/secure/login" &&
       file_name(previous_object())[0..13] != "/secure/nlogin" &&
       file_name(previous_object())[0..13] != "/obj/handlers/" &&
       file_name(previous_object())[0..4] != "/www/" &&
       file_name(previous_object())[0..11] != "/net/daemon/" &&
       file_name(previous_object())[0..11] != "/global/lord" &&
       file_name(previous_object())[0..14] != "/global/creator" &&
       file_name(previous_object())[0..18] != "/global/auto_mailer" &&
       file_name(previous_object())[0..12] != "/cmds/creator" &&
       file_name(previous_object())[0..9] != "/cmds/lord" &&
       file_name(previous_object()) != "/d/am/buildings/post/parcel" &&
       file_name(previous_object()) != "/d/am/buildings/apex/admin_office" &&
       file_name(previous_object()) != "/d/am/bookkeepers/weichert_office" &&
       file_name(previous_object()) != "/d/ram/ohulan/market/post_office" &&
       file_name(previous_object()) != "/d/ram/interview" &&
       file_name(previous_object()) != "/d/forn/utils/interview" &&
       file_name(previous_object()) != "/d/am/buildings/flintwick/lawyer_office" &&
       file_name(previous_object()) != "/d/am/buildings/council/court" &&
       file_name(previous_object()) != "/d/klatch/djel/city/palace/council_court" &&
       file_name(previous_object()) != "/d/guilds/error_tracker" &&
       file_name(previous_object())[0..25] != "/d/ram/ohulan/market/post2") {
        printf("MAILER: illegal access (%O).\n", file_name(previous_object()));
        return 0;
    }
    if ((file_name(previous_object())[0..11] == "/global/lord" ||
        file_name(previous_object())[0..14] == "/global/creator") &&
        (lower_case(from) != (string)this_player()->query_name())) {
        printf("MAILER: illegal acces.\n");
        return 0;
    }
    if (!ccs) {
        ccs = "";
    }
    cc_e = explode(ccs, ",")-({""});
    goto = explode(t, ",")-({""});
    if (only_to) {
        goto = explode(only_to, ",")-({""});
    }
    msg = new(class mail_message);
    msg->to = goto;
    msg->cc = cc_e;
    msg->body = "From " + from + " " + ctime(time()) +
    "\nDate: " + format_date(time()) +
    "\nFrom: " + from +
    "\nTo: " + t +
    "\nSubject: " + sub +
    "\n" + (sizeof(cc_e)?"Cc: "+ ccs+ "\n":"")+
    "\n" + body;
    msg->from = lower_case(from);
    msg->subject = sub;
    FOLDER_H->add_it(msg, flag);
    return 1;
}
string finger_mail(string pname) {
    return FOLDER_H->finger_mail(lower_case(pname));
}
string new_mail(string pname) {
    return FOLDER_H->check_mail(lower_case(pname));
}
private void prompt() {
    printf("\nCommand (h for main menu): ");
}
void read_mail(string str, string sub) {
    if (this_player()->query_property("guest")) {
        write("Sorry, mailer access is not allowed for guests.\n");
        if (do_this_last && objectp(do_this_last[0])) {
            call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
        } else {
            dest_me();
        }
        return;
    }
    if (!load_me()) {
        if (do_this_last && objectp(do_this_last[0])) {
            call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
        } else {
            dest_me();
        }
        return;
    }
    if (str) {
        no_menu = 1;
        if (!sub) {
            get_recipient(str);
        } else {
            to = str;
            get_subject(sub);
        }
        return;
    }
    MAIL_TRACK->add_mailer(this_object(), owner->query_name());
    main_menu("inbox");
    return;
}
varargs private void main_menu(string fname, int flag, int *range) {
    int i, size, offs, cols, fromcols, statcols;
    cols = COLS;
    printf("%|=*s", cols, "" + mud_name() + " mailer system version 2.0\n\n");
    if (!strlen(fname)) {
        fname = "inbox";
    }
    current = fname;
    if (!flag) {
        read_messages(current);
        last_read = -1;
        deleted = ({ });
    }
    if (!range) {
        range = ({ });
    }
    newish = ({ });
    size = sizeof(folder);
    for (i = 0; i < size; i++) {
        if (folder[i]->status == "N") {
            newish += ({ i });
        }
    }
    if (sizeof(newish) && newish[0] != 0 && last_read == -1) {
        last_read = newish[0]-1;
    }
    if (size && !sizeof(newish) && last_read == -1) {
        last_read = size-1;
    }
    printf(owner->fix_string(sprintf("%s%|=*s%s","%^CYAN%^",cols,
          "Folder "+current+" with "+
          (size?""+size:"no")+
          " message"+(size == 1?"":"s")+".\n\n",
          "%^RESET%^")));
    if (!sizeof(range)) {
        i = size - ROWS + 11;
        if (i < 0) {
            i = 0;
        }
        range = expand_range(sprintf("%d-%d", i, size));
    }
    size = sizeof(range);
    if (size) {
        offs = range[0]-1;
    } else {
        offs = 0;
    }
    statcols = cols / 3;
    fromcols = 2 * cols / 3 - 8;
    for (i = 0; i<size; i++) {
        printf(owner->
          fix_string(sprintf("%s%-6s %-*.*s %-*.*s%s\n",
              (last_read == i+offs?
                "%^REVERSE%^":""),
              (last_read == i+offs?">":" ")+
              folder[i+offs]->status+
              " " + (i+offs+1), statcols, statcols, "From: " +
              folder[i+offs]->from, fromcols, fromcols,
              "Subject: "+
              replace_string(terminal_colour(folder[i+offs]->subject,
                  ([ ])), "%", "%%"),
              "%^RESET%^")));
    }
    printf("%|=*s", cols, "\n  You can use any of the following commands by "
      "entering the first character;\nd)elete or u)ndelete mail,  m)ail a "
      "message,  r)eply or f)orward mail,  q)uit,\n"
      "> = move messages, c)hange folder, i)ndex of folders, ? = help\n"
      "To read next unread message, press <return>.\n");
    printf("Command: ");
    input_to("read_loop");
}
protected void read_loop(string input) {
    int i, num;
    string s1, s2, comm, *tmp;
    num = 0;
    i = 0;
    if (sscanf(input, "%d%s", num, input) != 2) {
        comm = "";
        if (sscanf(input, "%s %d %s", s1, num, s2) == 3) {
            i = 1;
            input = s1 + " " + s2;
        }
    }
    if (sscanf(input, "%s %s", comm, input) != 2) {
        comm = input;
        input = "";
    }
    if (i)
        input = ""+num+" "+input;
    switch(comm) {
    case "q" :  if (current == "inbox") {
            if (sizeof(folder) &&
              (sizeof(folder) != sizeof(newish)) &&
              (sizeof(deleted) != sizeof(folder))) {
                printf( "\nMove read message(s) to \"received\" folder? "
                  "(y/[n]): ");
                input_to("get_yesno");
                break;
            }
        }
        delete_it(current, 1);
        break;
    case "d" :
        if (input != "") {
            rm_message(input);
            break;
        }
        printf( "\nDelete which messages (number or range): " );
        input_to("rm_message");
        break;
    case "u" :
        if (input != "") {
            unrm_message(input);
            break;
        }
        printf( "\nUndelete which messages (number or range): " );
        input_to("unrm_message");
        break;
    case "c" :
        if (input != "") {
            change_folder(input);
            break;
        }
        printf( "\nChange to which folder (= for inbox): " );
        input_to("change_folder");
        break;
    case "m" :
        if (input != "") {
            get_recipient(input);
            break;
        }
        printf( "\nRecipient: " );
        input_to("get_recipient");
        break;
    case "R" :
        reply_message(num);
        break;
    case "r" :
        reply_message(num, 1);
        break;
    case "$" :
        main_menu(current);
        break;
    case "f" :
        if (input != "") {
            forward_message(input);
            break;
        }
        printf("\nForward a message.  Ranges are not supported.\n"
          "Enter the number of the message and the name(s) of the "
          "recipient(s), separated by a comma: ");
        input_to("forward_message");
        break;
    case "F" :
        forward_email(num);
        break;
    case "i" :
        printf("\nHere's the index of your folders:\n");
        printf("\n%-#*s\n", COLS, implode(folder_names, "\n"));
        prompt();
        input_to("read_loop");
        break;
    case "L" :
        if (full_header) {
            printf("\nOkay, now showing abbreviated header.\n");
            full_header = 0;
        } else {
            printf("\nOkay, now showing full header.\n");
            full_header = 1;
        }
        prompt();
        input_to("read_loop");
        break;
    case "l" :
        if (input != "") {
            if (!MAIL_TRACK->query_list(input)) {
                printf( "\nSorry, list "+input+" does not exist.\n" );
                prompt();
                input_to("read_loop");
                break;
            }
            printf( "\nMembers of list "+ input +":\n" );
            tmp = MAIL_TRACK->query_members(input);
        } else {
            printf( "\nCurrently available mailing lists:\n" );
            tmp = MAIL_TRACK->query_mailing_lists();
        }
        printf("\n%-#*s\n", COLS, implode(tmp,"\n"));
        prompt();
        input_to("read_loop");
        break;
    case ">" :
        if (!PLAYER_HANDLER->test_user(owner->query_name())) {
            printf( "You can't do that as a guest.\n" );
            break;
        }
        if (input != "") {
            move_message(input);
            break;
        }
        printf("\nMove message to folder.\nEnter the number "
          "(or range) of the message and the name of the folder, "
          "separated by a comma: ");
        input_to("move_message");
        break;
    case "h" :
        if (input != "") {
            main_menu(current, 1, expand_range(input));
            break;
        }
        main_menu(current, 1);
        break;
    case "s" :
        save_message(input);
        break;
    case "?" :
        owner->set_finish_func("finish_print");
        comm = read_file("/doc/helpdir/mailer");
        owner->more_string(comm);
        break;
    case "" :
        if (num) {
            print_message(num-1);
            last_read = num-1;
            break;
        }
        if (newish == ({ })) {
            printf("\nNo more new messages in folder.\n");
            prompt();
            input_to("read_loop");
            break;
        }
        last_read = newish[0];
        print_message(newish[0]);
        break;
    default :
        printf("\nUnknown command.  Use \"?\" for help.\n");
        prompt();
        input_to("read_loop");
        break;
    }
}
protected void get_yesno(string input) {
    int bing, i;
    if (!input || (input == "")) {
        printf("No.\n");
        delete_it(current, 1);
        return;
    }
    if (lower_case(input) == "n") {
        delete_it(current, 1);
        return;
    }
    if (lower_case(input) == "y") {
        bing = sizeof(folder);
        for (i = 0; i < bing; i++) {
            if ((member_array(i, newish) == -1) &&
              (member_array(folder[i]->number, deleted) == -1)) {
                move_message(""+(i+1)+" received", 1);
            }
        }
    }
    delete_it(current, 1);
    return;
}
private void forward_email(int number) {
    int i;
    string email, body;
    if (!number) {
        if (!(i = sizeof(folder))) {
            printf("No messages in folder.\n");
            prompt();
            input_to("read_loop");
            return;
        }
        if (newish != ({ })) {
            number = newish[0];
            if (number == 0) {
                printf("All your messages are still unread: aborting.\n");
                prompt();
                input_to("read_loop");
                return;
            }
        }
        else if (last_read > -1)
            number = last_read+1;
        else
            number = i;
    }
    if (sizeof(folder) < number) {
        printf("Oh dear.  No message with that number.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    number--;
    if (!(email = PLAYER_HANDLER->test_email(owner->query_name()))) {
        printf("Sorry, your E-mail address is not set.  Use chfn or email "
          "to set it.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (email[0] == ':') {
        email = email[1..];
    }
    body = FOLDER_H->load_message(owner->query_name(), current,
      folder[number]->number);
    if (body) {
        SMTP->eventSendMail(email, owner->query_name(), body);
        printf("Message #%d forwarded to your E-mail address.\n", number + 1);
    }
    prompt();
    input_to("read_loop");
}
private string rewrite_local(string rcpt) {
    string tmpr;
    if ((tmpr = FOLDER_H->check_local(rcpt))) {
        return tmpr;
    }
    return rcpt;
}
varargs private void reply_message(int number, int flag) {
    int i;
    string body;
    class mime_header hdr;
    if (!number) {
        if (!(i = sizeof(folder))) {
            printf("No messages in folder.\n");
            prompt();
            input_to("read_loop");
            return;
        }
        if (newish != ({ })) {
            number = newish[0];
            if (number == 0) {
                printf("All your messages are still unread: aborting.\n");
                prompt();
                input_to("read_loop");
                return;
            }
        }
        else if (last_read > -1)
            number = last_read+1;
        else
            number = i;
    }
    if (sizeof(folder) < number) {
        printf("Oh dear.  No message with that number.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    number--;
    to = folder[number]->from;
    body = FOLDER_H->load_message(owner->query_name(), current,
      folder[number]->number);
    if (!body) {
        prompt();
        input_to("read_loop");
        return;
    }
    hdr = MIME->parse_headers(body);
    if (!hdr) {
        prompt();
        input_to("read_loop");
        return;
    }
    if (hdr->header_m["reply-to"]) {
        to = hdr->header_m["reply-to"];
    }
    if (!flag) {
        string tmp;
        cc = hdr->header_m["cc"];
        tmp = hdr->header_m["to"];
        if (tmp) {
            if (cc) {
                cc += "," + tmp;
            } else {
                cc = tmp;
            }
        }
        if (cc == "") {
            cc = 0;
        }
        if (cc) {
            cc = implode(map(MIME->get_email_addrs(cc)[0],
                (: rewrite_local($1) :))-({ owner->query_name(), to }),
              ",");
        }
    }
    printf("Include original message? (y/[n]/q) ");
    input_to("finish_reply_message", 0, number);
}
protected void finish_reply_message(string input, int number) {
    int flag, i;
    string s1;
    if (!input || input == "" || lower_case(input)[0] != 'y') {
        if (lower_case(input)[0] == 'q') {
            cc = 0;
            to = "";
            printf("Aborting.\n");
            prompt();
            input_to("read_loop");
            return;
        }
        printf( "No.\n" );
    } else flag = 1;
    subject = folder[number]->subject;
    if (sscanf(subject, "Re:#%d %s", i, s1) != 2)
        subject = "Re:#1 " + subject;
    else
        subject = sprintf("Re:#%d %s", (i+1), s1);
    printf("Press return for a subject of \"%s\"\nSubject: ", subject);
    if (flag)
        input_to("get_subject", 0, ++number, 1);
    else
        input_to("get_subject");
}
protected void change_folder(string input) {
    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    if (input == "=") {
        delete_it(current, 0, "inbox");
        return;
    }
    if (member_array(input, folder_names) == -1) {
        printf("No folder named %s.\n", input);
        prompt();
        input_to("read_loop");
        return;
    }
    delete_it(current, 0, input);
}
protected void get_recipient(string input) {
    string *str, *full, nn;
    int i;
    mixed *addrs;
    if (!input || input == "") {
        printf("No recipient given: aborting.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    addrs = MIME->get_email_addrs(input);
    str = addrs[0];
    full = addrs[1];
    for (i=0;i<sizeof(str);i++){
        nn = (string)owner->expand_nickname(str[i]);
        if (str[i] != nn) {
            str[i] = full[i] = nn;
        }
        if (!valid_name(str[i])) {
            printf("%s is not a valid recipient.\n", str[i]);
            str = delete(str, i, 1);
            full = delete(full, i--, 1);
        }
    }
    if (sizeof(full))
        to = implode(full, ",");
    else {
        if (no_menu) {
            delete_it("inbox", 1);
            return;
        }
        prompt();
        input_to("read_loop");
        return;
    }
    subject = "";
    printf("Subject: ");
    input_to("get_subject");
}
varargs protected void get_subject(string input, int number, int flag) {
    if ((!input || input == "") && (!subject || subject == "")) {
        printf("No subject given: aborting.\n");
        if (no_menu) {
            delete_it("inbox", 1);
            return;
        }
        prompt();
        input_to("read_loop");
        return;
    }
    if (input && input != "")
        subject = input;
    printf("Cc: ");
    input_to("get_cc", 0 , number, flag);
}
private int valid_name(string str) {
    string mud;
    str = lower_case(str);
    if (!sscanf(str, "%s@%s", str, mud) ||
      lower_case(mud) == lower_case(mud_name())) {
        return (int)PLAYER_HANDLER->test_user(str) ||
        (int)MAIL_TRACK->query_list(str);
    }
    return 1;
}
varargs protected void get_cc(string input, int number, int flag) {
    string *str, body, *full, nn;
    int i;
    mixed *addrs;
    if (!input || input == "**" || input == "") {
        if (number) {
            body = FOLDER_H->load_message(owner->query_name(), current,
              folder[number-1]->number);
            if (!body) {
                prompt();
                input_to("read_loop");
                return;
            }
            if (!flag) {
                finish_write_message("> " + replace_string(body, "\n", "\n> ") + "\n");
                return;
            }
            owner->do_edit("> " + replace_string(body, "\n", "\n> ") + "\n",
              "finish_write_message");
            return;
        }
        write_message();
        return;
    }
    addrs = MIME->get_email_addrs(input);
    str = addrs[0];
    full = addrs[1];
    for (i = 0; i < sizeof(str); i++) {
        nn = (string)owner->expand_nickname(str[i]);
        if (str[i] != nn) {
            str[i] = full[i] = nn;
        }
        if (!valid_name(str[i])) {
            printf("%s is not a valid recipient.\n", str[i]);
            str = delete(str, i, 1);
            full = delete(full, i--, 1);
        }
    }
    if (cc)
        cc += "," + implode(full, ",");
    else
        cc = implode(full, ",");
    printf("Cc: ");
    input_to("get_cc", 0, number, flag);
}
private void write_message() {
    owner->do_edit(0, "finish_write_message");
}
void finish_write_message(string input) {
    if (!input || input == "") {
        if (no_menu) {
            delete_it("inbox", 1);
            return;
        }
        prompt();
        input_to("read_loop");
        return;
    }
    printf("Cc: ");
    input_to("get_cc_after", 0, input);
}
protected void get_cc_after(string input, string body) {
    mixed *goto, cc_e, *addrs;
    class mail_message msg;
    string *str, *full, nn;
    int i;
    if (!input || input == "**" || input == "") {
        body += owner->append_signature();
        FOLDER_H->mark_read(owner->query_name(), current, newish);
        goto = explode(to, ",") - ({ "" });
        if (cc && cc != "") {
            cc_e = explode(cc, ",") - ({ "" });
        } else {
            cc_e = ({ });
        }
        msg = new(class mail_message);
        msg->to = goto;
        msg->cc = cc_e;
        msg->body = "From " + owner->query_name() + " " + ctime(time()) +
        "\nDate: " + format_date(time()) +
        "\nFrom: " + owner->query_name() +
        "\nTo: " + to +
        "\nSubject: " + subject +
        "\n" + (sizeof(cc_e)?"Cc: " + cc + "\n":"") +
        "\n" + body;
        msg->from = owner->query_name();
        msg->subject = subject;
        FOLDER_H->add_it(msg, 0);
        to = "";
        cc = 0;
        subject = "";
        printf("Message sent.\n");
        if (no_menu) {
            delete_it("inbox", 1);
            return;
        }
        prompt();
        input_to("read_loop");
        return;
    }
    addrs = MIME->get_email_addrs(input);
    str = addrs[0];
    full = addrs[1];
    for (i = 0; i < sizeof(str); i++) {
        nn = (string)owner->expand_nickname(str[i]);
        if (str[i] != nn) {
            str[i] = full[i] = nn;
        }
        if (!valid_name(str[i])) {
            printf("%s is not a valid recipient.\n", str[i]);
            str = delete(str, i, 1);
            full = delete(full, i--, 1);
        }
    }
    if (cc)
        cc += "," + implode(full, ",");
    else
        cc = implode(full, ",");
    printf("Cc: ");
    input_to("get_cc_after", 0, body);
}
varargs private void delete_it(string fname, int last, string newish_folder) {
    if (!fname)
        fname = current;
    if (deleted != ({ })) {
        printf("Delete message(s)? ([y]/n) ");
        input_to("finish_delete_it", 0, fname, last, newish_folder);
        return;
    }
    if (last) {
        FOLDER_H->mark_read(owner->query_name(), current, newish);
        save_me();
        if (do_this_last && objectp(do_this_last[0]))
            call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
        else
            dest_me();
        return;
    }
    FOLDER_H->mark_read(owner->query_name(), current, newish);
    if (!newish_folder || newish_folder == "")
        main_menu(fname);
    else
        main_menu(newish_folder);
}
protected void finish_delete_it(string input, string fname, int last,
  string newish_folder) {
    if (lower_case(input) == "n" || (input && input != "" &&
        lower_case(input) != "y")) {
        printf("Keeping message(s).\n");
        deleted = ({ });
        if (last) {
            FOLDER_H->mark_read(owner->query_name(), current, newish);
            save_me();
            if (do_this_last && objectp(do_this_last[0]))
                call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
            else
                dest_me();
            return;
        }
        FOLDER_H->mark_read(owner->query_name(), current, newish);
        if (!newish_folder || newish_folder == "")
            main_menu(fname);
        else
            main_menu(newish_folder);
        return;
    }
    printf("Deleting message(s).\n");
    FOLDER_H->mark_read(owner->query_name(), current, newish);
    FOLDER_H->delete_it(owner->query_name(), fname, deleted);
    deleted = ({ });
    save_me();
    if (last) {
        if (do_this_last && objectp(do_this_last[0]))
            call_other(do_this_last[0], do_this_last[1], do_this_last[2]);
        else
            dest_me();
        return;
    }
    if (!newish_folder || newish_folder == "")
        main_menu(fname);
    else
        main_menu(newish_folder);
    return;
}
varargs protected void rm_message(string input, int flag) {
    int i, tmp;
    int *range;
    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    range = expand_range(input);
    tmp = sizeof(range);
    for (i = 0; i < tmp; i++) {
        if (member_array(folder[range[i]-1]->number,
            deleted) == -1) {
            newish -= ({ range[i]-1 });
            deleted += ({ folder[range[i]-1]->number });
            folder[range[i]-1]->status = "D";
            printf("Marked message %d as deleted.\n", range[i]);
        }
    }
    if (!flag) {
        prompt();
        input_to("read_loop");
    }
}
protected void unrm_message(string input) {
    int i, tmp;
    int *range;
    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    range = expand_range(input);
    tmp = sizeof(range);
    for (i = 0; i < tmp; i++) {
        if (member_array(folder[range[i]-1]->number,
            deleted) > -1) {
            deleted -= ({ folder[range[i]-1]->number });
            folder[range[i]-1]->status = "U";
            printf("Undeleted message %d.\n", range[i]);
        }
    }
    prompt();
    input_to("read_loop");
}
protected void forward_message(string input) {
    int number, i;
    string *str, *full, nn;
    mixed *addrs;
    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    if (sscanf(input, "%d %s", number, to) != 2) {
        printf("Wrong syntax (ranges are not supported with forward).\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (number > sizeof(folder) || !number) {
        printf("Oh dear. No message with that number.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    addrs = MIME->get_email_addrs(to);
    str = addrs[0];
    full = addrs[1];
    for (i = 0; i < sizeof(str); i++) {
        nn = (string)owner->expand_nickname(str[i]);
        if (str[i] != nn) {
            str[i] = full[i] = nn;
        }
        if (!valid_name(str[i])) {
            printf("%s is not a valid recipient.\n", str[i]);
            str = delete(str, i, 1);
            full = delete(full, i--, 1);
        }
    }
    if (sizeof(full)) {
        to = implode(full, ",");
    } else {
        prompt();
        input_to("read_loop");
        return;
    }
    cc = 0;
    printf("Edit outgoing message? (y/[n]) ");
    input_to("edit_it", 0, number);
}
protected void edit_it(string input, int number) {
    subject = folder[number-1]->subject + " (fwd)";
    if (!input || input == "")
        printf( "No.\n" );
    printf("Press return for a subject of \"%s\"\nSubject: ", subject);
    if (!strlen(input) || (lower_case(input) == "n"))
        input_to("get_subject", 0, number);
    else if (lower_case(input) == "y")
        input_to("get_subject", 0, number, 1);
    return;
}
varargs protected void move_message(string input, int flag) {
    int *range, i, bing;
    string to_folder, number;
    if (!input || input == "") {
        prompt();
        input_to("read_loop");
        return;
    }
    if (!sscanf(input, "%s %s", number, to_folder)) {
        printf("Wrong syntax.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (to_folder == current) {
        printf("Destination folder is the same as source folder: not moved.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (to_folder == "=")
        to_folder = "inbox";
    range = expand_range(number);
    bing = sizeof(range);
    FOLDER_H->mark_read(owner->query_name(), current, newish);
    for (i = 0; i < bing; i++) {
        int status;
        if (member_array(to_folder, folder_names) == -1) {
            if (FOLDER_H->can_create_folder(owner->query_name(), to_folder)) {
                folder_names += ({ to_folder });
            } else {
                printf("Cannot create a folder called %s, please choose "
                    "another another name.\n", to_folder);
                break;
            }
        }
        deleted += ({ folder[range[i]-1]->number });
        status = FOLDER_H->move_it(owner->query_name(), current, to_folder,
          folder[range[i]-1]->number);
        folder[range[i]-1]->status = "D";
        switch(status) {
        case 2:
          printf("Folder full!\n");
        case 1:
          printf("Marked message %d as deleted.\n", range[i]);
          break;
        case 0:
          if(!flag)
            printf("Saved message %d to folder %s.\n", range[i], to_folder);
        }
    }
    if (!flag) {
        prompt();
        input_to("read_loop");
    }
}
private void save_message(string input) {
    int *range, i, bing, ret;
    string to_file, number, body, err;
    if (!wizardp(owner)) {
        printf("Sorry, only creators can save mail to files.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (!input || input == "") {
        if (last_read != -1)
            input = sprintf("%d ~/mbox",(last_read+1));
        else {
            printf("No messages in folder or all messages still unread.\n");
            prompt();
            input_to("read_loop");
            return;
        }
    }
    if (!sscanf(input, "%s %s", number, to_file)) {
        printf("Wrong syntax.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    seteuid(geteuid(owner));
    to_file = (string)owner->get_path(to_file);
    if (!master()->valid_write(to_file, owner, "write_file")) {
        printf("You cannot write to that file.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if ((i=file_size(to_file)) > 0)
        printf("Appending to existing file.\n");
    else if (i == -2) {
        printf("That is a directory.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    range = expand_range(number);
    bing = sizeof(range);
    i = 0;
    for (i = 0; i < bing; i++) {
        body = FOLDER_H->load_message(owner->query_name(), current,
          folder[range[i]-1]->number);
        if (!body) {
            continue;
        }
        err = catch(ret = write_file(to_file, body + "\n\n"));
        if (err) {
            printf("Writing to file failed: %s\n", err);
        } else if (!ret) {
            printf("Writing to file failed.\n");
        } else {
            printf("Saved message %d to %s.\n", range[i], to_file);
        }
    }
    seteuid("Mailer");
    prompt();
    input_to("read_loop");
}
private void print_message(int number) {
    string body;
    if (number > sizeof(folder)-1 || number < 0) {
        printf("No message with that number.\n");
        prompt();
        input_to("read_loop");
        return;
    }
    if (folder[number]->status == "N") {
        newish -= ({ number });
        folder[number]->status = " ";
    }
    body = FOLDER_H->load_message(owner->query_name(), current,
      folder[number]->number);
    if (!body) {
        rm_message(""+(number+1));
        return;
    }
    owner->set_finish_func("finish_print");
    printf("\n\nMessage %d\n", (number + 1));
    owner->more_string((full_header?body:strip_header(body)),
      "Message "+(number+1));
}
void finish_print() {
    printf("\n");
    prompt();
    input_to("read_loop");
}
private void save_me() {
    if (!PLAYER_HANDLER->test_user(owner->query_name())) {
        return;
    }
    if (current != "inbox") {
        if (FOLDER_H->check_empty(owner->query_name(), current)) {
            folder_names -= ({ current });
        }
    }
    unguarded((: save_object, folder_filename(owner->query_name()) :));
}
private int load_me() {
#ifdef CONVERTER
    if ("/obj/handlers/converter"->query_busy(owner->query_name())) {
        printf( "You cannot use the mailer now, your mail is being converted.\n" );
        return 0;
    }
#endif
    unguarded((: restore_object, folder_filename(owner->query_name()) :));
    if (!folder_names) {
        folder_names = ({ "inbox" });
    }
    return 1;
}
string *query_folders(string pname) {
    unguarded((: restore_object, folder_filename(pname) :));
    if (!folder_names)
        return ({});
    return folder_names;
}
private void read_messages(string fname) {
    folder = FOLDER_H->get_messages(owner->query_name(), fname);
}
void dest_me() {
    MAIL_TRACK->delete_mailer(this_object());
    destruct(this_object());
}
string format_date(int x) {
    string str;
    string mon;
    mixed *tm;
    if (x<0 || !intp(x))
        return "Bad time";
    tm = localtime(x);
    str = DAYS[tm[LT_WDAY]];
    mon = MONTHS[tm[LT_MON]];
    str = sprintf("%s, %d %s %d %02d:%02d %s", str, tm[LT_MDAY], mon,
      tm[LT_YEAR], tm[LT_HOUR], tm[LT_MIN], tm[LT_ZONE]);
    return str;
}
private int *expand_range(string str) {
    int *ms, i, start, end;
    if (!str)
        str = "";
    if (!sizeof(folder))
        return ({ });
    str = replace_string(str, " ", "");
    ms = ({ });
    if (sscanf(str, "%*sall%*s")==2) {
        int size = sizeof(folder) + 1;
        for (i = 1; i < size; i++) {
            ms += ({ i });
        }
        return ms;
    }
    while (sscanf(str, "%d%s", start, str) == 2) {
        if (start < 1)
            start = 1;
        if (start > sizeof(folder))
            start = sizeof(folder);
        if (str && str != "" && (str[0] == '-' || ((strlen(str) > 1) &&
              str[0..1] == ".."))) {
            sscanf(str, "%*(-|(..))%d%s", end, str);
            if (end >= start) {
                if (end > sizeof(folder))
                    end = sizeof(folder);
                for (i = start; i <= end; i++)
                    if (member_array(i, ms) == -1)
                        ms += ({ i });
            }
        } else
        if (member_array(start, ms) == -1)
            ms += ({ start });
        sscanf(str, ",%s", str);
    }
    return ms;
}

=== /mnt/home2/test/Test/dw_fluffos_v3/lib/obj/handlers/parcel.c ===
#define BASE_PATH "/save/parcels/"
#define SAVE_PATH BASE_PATH + location + "/" + name[0..0]
#define SAVE_FILE BASE_PATH + location + "/" + name[0..0] + "/" + name + ".o"
#define POST_LOG "PARCEL_LOG"
inherit "/global/auto_load";
#undef USE_COMPRESSION
#include <player_handler.h>
class parcel {
  string from;
  string *autoloadinfo;
  int exp_time;
}
mapping parcels;
private nosave string _current_name, _current_location;
nosave class parcel *_parcels;
int test_expire( class parcel temp );
void create() {
  string dir;
  seteuid( master()->creator_file( base_name( this_object() ) ) );
  parcels = ([ ]);
  if(parcels) {
    parcels = copy(parcels);
    parcels = ([ ]);
  }
  _parcels = ({ });
}
private void save_file(string name, string location) {
  string str;
  map_delete(parcels, name);
  if(sizeof(keys(parcels)))
    unguarded( (: save_object, SAVE_PATH, 2 :));
  if(file_size(SAVE_PATH) == -1)
    unguarded( (: mkdir, SAVE_PATH :) );
  if(_parcels != ({ })) {
    str = save_variable(_parcels);
#ifdef USE_COMPRESSION
    if(!ungarded( (: write_buffer, SAVE_FILE + ".gz", 0, compress(str) :) ))
#else
    if(!unguarded((: write_file, SAVE_FILE, str, 1 :) ))
#endif
      log_file(POST_LOG, "%s: error writing to %s\n",
               ctime(time()), SAVE_FILE);
  } else {
    if(file_size(SAVE_FILE) > 0)
      unguarded( (: rm, SAVE_FILE :));
    if(file_size(SAVE_FILE+".gz") > 0)
      unguarded( (: rm, SAVE_FILE + ".gz" :));
  }
}
private void load_file( string name, string location ) {
  if(_current_name == name && _current_location == location)
    return;
#ifdef USE_COMPRESSION
  if(file_size(SAVE_FILE + ".gz") > 0) {
    _parcels = restore_variable(uncompress(read_file(SAVE_FILE)));
  } else
#endif
  if(file_size(SAVE_FILE) > 0) {
    debug_printf("%s", SAVE_FILE);
    _parcels = restore_variable(unguarded( (: read_file, SAVE_FILE :) ));
  } else if (file_size(SAVE_PATH+ ".o.gz") > 0) {
    unguarded( (: restore_object, SAVE_PATH+".o.gz" :));
    _parcels = parcels[name];
  } else if(file_size(SAVE_PATH+".o") > 0) {
    unguarded( (: restore_object, SAVE_PATH :) );
    _parcels = parcels[name];
  } else {
    parcels = ([ ]);
    _parcels = ({ });
  }
  _current_name = name;
  _current_location = location;
}
public int deposit(string to, string from, string location, object *obs) {
  class parcel temp;
  object boxy;
  string obsstuff, tmp;
  obsstuff = "/global/events"->convert_message(query_multiple_short (obs));
  if(!PLAYER_HANDLER->test_user(to))
    return 0;
#ifndef __DISTRIBUTION_LIB__
    if("/secure/alist"->query_alt(from, to) == 100) {
      tmp = capitalize(from) + " sent a parcel containing " +
        obsstuff + " to his/her alt " + capitalize(to) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    } else if("/secure/alist"->query_alt(from, to) > 40) {
      tmp = capitalize(from) + " sent a parcel containing " +
        obsstuff + " to his/her POSSIBLE alt "+ capitalize(to) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    }
#endif
  load_file(to, location );
  if(undefinedp(_parcels) || !arrayp(_parcels))
    _parcels = ({ });
  boxy = clone_object("/obj/baggage");
  boxy->set_name("boxy");
  boxy->set_max_weight(100000);
  obs->move( boxy );
  temp = new( class parcel,
              from : from,
              exp_time: time() + ( 14 * 24 * 60 * 60));
  temp->autoloadinfo = create_auto_load( ({ boxy }), 0 );
  _parcels += ({ temp });
  save_file(to, location);
  boxy->dest_me();
  log_file (POST_LOG, "%s: %s deposited %s at %s for %s.\n", ctime(time()),
      from, obsstuff, location, to);
}
public int collect(string name, string location, object target, int copy) {
  class parcel temp;
  object *box_array = ({ });
  object *obs = ({ });
  string tmp;
  load_file(name, location );
  if(!_parcels || _parcels == ({ }))
    return 0;
  foreach(temp in _parcels) {
    box_array += load_auto_load_to_array(temp->autoloadinfo, this_player());
#ifndef __DISTRIBUTION_LIB__
    obs = all_inventory(box_array[<1]);
    if("/secure/alist"->query_alt(name, temp->from) == 100) {
      tmp = capitalize(name) + " received a parcel containing " +
        "/global/events"->convert_message(query_multiple_short(obs)) +
        " from his/her alt " + capitalize(temp->from) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    } else if("/secure/alist"->query_alt(name, temp->from) > 40) {
      tmp = capitalize(name) + " received a parcel containing " +
        "/global/events"->convert_message(query_multiple_short(obs)) +
        " from his/her POSSIBLE alt "+ capitalize(temp->from) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    }
#endif
  }
  foreach( object box in box_array ) {
    obs += all_inventory (box);
    all_inventory( box )->move( target );
    box->dest_me();
  }
  if ( !copy )
    _parcels = ({ });
  log_file (POST_LOG, "%s: %s collected %s at %s.\n", ctime(time()),
            name, "/global/events"->convert_message(query_multiple_short(obs)),
            location);
  save_file(name, location);
  return 1;
}
class parcel *queryparcels_for(string name, string location) {
  load_file(name, location);
  return _parcels;
}
void do_migrate(int letter, string location) {
  string name;
  class parcel temp2;
  tell_creator("ceres", "Processing %c in %s\n", letter, location);
  load_file(sprintf("%c", letter), location);
  foreach(name, temp2 in parcels) {
    _parcels = filter(temp2, (: test_expire :));
    save_file(name, location);
  }
  if(!sizeof(keys(parcels))) {
    name = BASE_PATH + location + "/" + sprintf("%c", letter) + ".o.gz";
    unguarded((: rm, name :));
  }
  if(letter < 'z') {
    letter++;
    call_out("do_migrate", 15 + random(30), letter, location);
  }
}
int test_expire(class parcel temp ) {
  if ( temp->exp_time > time() )
    return 1;
  return 0;
}
void player_refreshed(mixed name, int total ) {
  string location;
  string *dirs = map( filter( get_dir( BASE_PATH, -1 ),
                              (: $1[1] == -2 :) ), (: $1[0] :) );
  if (objectp(name))
    name = name->query_name();
  foreach(location in dirs) {
    load_file(name, location);
    map_delete(parcels, name);
    save_file(name, location);
  }
}
