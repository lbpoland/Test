




==================================================
FILE: /lib/cmds/living/climb.c
==================================================

#include <tasks.h>
#define TP this_player()
#define SKILL "other.movement.climbing.rock"
inherit "/cmds/base";
void fall_off( object place, int number ) {
   if ( place->query_at_bottom() ) {
      write( "You try to climb, but you can't seem to get anywhere.\n" );
      say( (string)TP->one_short() + " tries to climb, but fails.\n" );
      return;
   }
   if ( random( (int)TP->query_dex() ) < number / 20 ) {
      write( "You begin to climb, but your fatigue makes you "+
            "clumsily lose your grip.\n" );
      say( (string)TP->one_short() +
            " begins to climb but clumsily loses "+
            (string)TP->query_possessive() +" grip.\n" );
      place->fall_down( TP );
      return;
   }
   write( "You begin to climb but wobble precariously and decide to "+
         "stay put for the moment.\n" );
   say( (string)TP->one_short() +
            " begins to climb, but wobbles precariously and stops.\n" );
}
mixed cmd( string words ) {
   int difficulty;
   object place;
   mixed ghost_action;
   mixed *move;
   string *move_descs = ({ "", "", "" });
   string skill;
   place = environment( TP );
   if ( !place ) {
      add_failed_mess( "You cannot climb anything: you're in limbo!\n" );
      return 0;
   }
   move = (mixed *)place->query_move( words );
   if ( !move ) {
      if( sizeof( place->query_moves() ) )
         add_failed_mess( "You cannot climb \""+ words +"\" from here.\n" );
      else
         add_failed_mess( "There is nothing to climb here.\n" );
      return 0;
   }
   if( stringp( move[2] ) ) {
      move_descs[0] =
         "You climb "+ words +".\n";
      move_descs[1] =
         "$N slowly climb$s "+ words +" and disappears from view.";
      move_descs[2] =
         copy( move[2] );
   } else if( sizeof( move[2] ) == 3 ) {
      move_descs = copy( move[2] );
      move_descs[0] += "\n";
   } else {
      return 0;
   }
   if ( TP->query_property( "dead" ) ) {
      ghost_action = place->query_ghost_action( place );
      if ( ! ghost_action ) {
          TP->move_with_look( move[ 1 ], move_descs[ 2 ], move_descs[ 1 ] );
          add_succeeded_mess("");
          return 1;
      }
      else if ( intp( ghost_action ) && ghost_action == 1 ) {
          add_failed_mess( "How can you climb anything?  You're dead!\n");
          return 0;
      }
      else if ( stringp( ghost_action ) ) {
          write( "As you move to climb the wall, your inherent wispiness gets "
              "the better of you, and you fall through to the other side.\n" );
          TP->move_with_look( ghost_action,
              "$N wisps through the wall with some undue haste.",
              "$N tries to climb the wall, but falls through it." );
          add_succeeded_mess( "" );
          return 1;
      }
      else if ( arrayp( ghost_action ) ) {
          write( ghost_action[ 1 ][ 0 ] + "\n" );
          TP->move_with_look( ghost_action[ 0 ],
              ghost_action[ 1 ][ 1 ], ghost_action[ 1 ][ 2 ] );
          add_succeeded_mess( "" );
          return 1;
      }
      else {
          TP->move_with_look( move[ 1 ], move_descs[ 2 ], move_descs[ 1 ] );
          add_succeeded_mess("");
          return 1;
      }
   }
   if( intp( move[0] ) ) {
      difficulty = move[0] + (int)TP->query_loc_weight() / 10;
      skill = SKILL;
   } else if( arrayp( move[0] ) && sizeof( move[0] ) > 1 ) {
      difficulty = move[0][0] + (int)TP->query_loc_weight() / 10;
      skill = move[0][1];
      debug_printf( "Base difficulty: %d, total difficulty: %d, skill: %s\n",
                    move[0][0], difficulty, move[0][1] );
   }
   if ( (int)TP->query_specific_gp( "other" ) < difficulty ) {
      fall_off( place, difficulty );
      add_succeeded_mess("");
      return 1;
   }
   TP->adjust_gp( -difficulty / 2 );
   switch ( (int)TASKER->perform_task(TP, skill, difficulty,
                                      TM_COMMAND)) {
      case AWARD :
         call_out( "advance_notice", random( 60 ), TP );
      case SUCCEED :
         write( move_descs[ 0 ] );
         TP->move_with_look( move[ 1 ], move_descs[ 2 ],
               move_descs[ 1 ] );
         return 1;
      default :
         break;
   }
   difficulty = random( difficulty );
   if ( (int)TP->query_specific_gp( "other" ) < difficulty ) {
      fall_off( place, difficulty );
      add_succeeded_mess("");
      return 1;
   }
   TP->adjust_gp( -difficulty );
   switch ( (int)TASKER->perform_task(TP, skill,  difficulty / 2,
                                      TM_COMMAND)) {
      case AWARD :
         write( "%^YELLOW%^You manage not to fall off!%^RESET%^\n" );
      case SUCCEED :
         write( "You begin to climb but wobble precariously and decide to "+
               "stay put for the moment.\n" );
         say( (string)TP->one_short() +
               " begins to climb, but wobbles precariously and stops.\n" );
         break;
      default :
         fall_off( place, difficulty );
         break;
   }
   add_succeeded_mess("");
   return 1;
}
void advance_notice( object thing ) {
   if ( !thing )
      return;
   tell_object( thing, "%^YELLOW%^"+ ({
      "In a flash of inspiration, you realise how to balance better "+
            "when climbing.",
      "Thinking about your climb, you realise something important.",
      "You realise that you've been using better grips to climb.",
      "You realise you've discovered how to find better places to "+
            "support your feet.",
      "You find you've worked out a more sensible way to distribute "+
            "your weight as you climb.",
      "With all your climbing, you discover you've found a better way "+
            "to locate handholds."
   })[ random( 6 ) ] +"%^RESET%^\n" );
}
mixed *query_patterns() {
   return ({ "<string'direction'>", (: cmd($4[0]) :) });
}

==================================================
FILE: /lib/cmds/living/concentrate.c
==================================================

inherit "/cmds/base";
int concentrate_list( ) {
   object conc;
   conc = this_player()->query_concentrating();
   if ( !conc ) {
      write("You are not currently concentrating on "
                  "any particular opponent.\n" );
   } else {
      write("You are currently concentrating on "+
            conc->the_short() + ".\n");
   }
   return 1;
}
int concentrate(object *things ) {
   if ( sizeof( things ) > 1 ) {
      return notify_fail( "You can only concentrate on one thing at once.\n" );
   }
   if (!sizeof(this_player()->query_attacker_list())) {
      add_failed_mess("You are not fighting anyone.\n");
      return 0;
   }
   if ( things[0] == this_player() ) {
      return notify_fail( "It would be silly to concentrate on yourself.\n" );
   }
   if (member_array(things[0], this_player()->query_attacker_list()) == -1) {
     return notify_fail("You can only concentrate on people you are "
                        "fighting.\n");
   }
   if (this_player()->set_concentrating(things[0])) {
        add_succeeded_mess(({"You are now concentrating on $I.\n", "" }),
                           things);
   } else {
      add_succeeded_mess(({"Unable to concentrate on $I.\n", "" }), things);
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "[on] <indirect:living>", (: concentrate($1) :),
             "", (: concentrate_list() :) });
}

==================================================
FILE: /lib/cmds/living/crawl.c
==================================================

#define EFFECTPATH "/std/effects/other/"
#define PT "/obj/handlers/playtesters"
inherit "/cmds/base";
int is_in_water( object room );
varargs int cmd( string str ) {
   if( str == "stop" ) {
      if( !this_player()->query_crawling() ) {
         this_player()->add_failed_mess( this_object(),
                                         "You should be crawling first in order"
                                         " to stop doing it, don't you "
                                         "think?\n",
                                         ({ }) );
         return 0;
      };
      this_player()->stop_crawling();
      return 1;
   };
   if( !str ) {
      if( this_player()->query_property( "dead" ) ) {
         this_player()->add_failed_mess( this_object(),
                                         "You appear to be dead.  There is no "
                                         "necessity to torture your morphogenic"
                                         " arms, you know?\n",
                                         ({ }) );
         return 0;
      } else if( this_player()->query_crawling() ) {
         this_player()->add_failed_mess( this_object(),
                                         "You are already crawling.\n",
                                         ({ }) );
         return 0;
      } else if( is_in_water( environment( this_player() ) ) ) {
         this_player()->add_failed_mess( this_object(),
                                         "You are in water at the moment, so "
                                         "crawling is impossible.\n",
                                         ({ }) );
         return 0;
      } else {
         this_player()->add_effect( EFFECTPATH + "crawling" );
         return 1;
      };
   };
}
mixed* query_patterns() {
   return ({
      "", (: cmd() :),
      "stop", (: cmd( "stop" ) :)
   });
}
int is_in_water( object room ) {
   if( inherits( "/std/water_inside.c", room ) ||
       inherits("/std/water_outside.c", room ) ||
       inherits("/std/uwater.c", room ) ) {
      return 1;
   } else
      return 0;
}

==================================================
FILE: /lib/cmds/living/crouch.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("crouch", "down", CROUCHING);
}

==================================================
FILE: /lib/cmds/living/debate.c
==================================================

#include <tasks.h>
#define EFFECT "/std/effects/religious/theological_debate"
#define HANDLER "/obj/handlers/philosophies"
#define DEBATE_MULT 4
inherit "/cmds/base";
mapping _debaters;
void create() {
   _debaters = ([ ]);
}
mixed cmd(object * indirect_obs,
          string indir_match,
          string dir_match,
          mixed *args,
          string pattern)
{
   int bonus;
   string topic;
   string type;
   string needed;
   object target;
   if (sizeof((int *)this_player()->effects_matching("debating"))) {
      return notify_fail("You are already engaged in a debate.\n");
   }
   if (_debaters[this_player()]) {
      tell_object(_debaters[this_player()][0],
                  this_player()->the_short() + " withdraws their debating "
                  "challenge from you.\n");
      map_delete(_debaters, this_player());
   }
   target = indirect_obs[0];
   if (target == this_player()) {
      return notify_fail("Debating with yourself?  Which one of your "
         "personalities are you trying to outwit?\n");
   }
   if (userp(target) && !interactive(target)) {
      return notify_fail("How can you debate anything with a net-dead "
                         "statue?\n");
   }
   topic = args[0];
   if (_debaters[target] && _debaters[target][0] == this_player()) {
      if ((_debaters[target][0] == this_player()) &&
          (_debaters[target][1] == topic)) {
         write("You accept " + (string) target->the_short() +
               "'s challenge to debate " + topic + ".\n");
         say((string) this_player()->the_short() + " accepts " +
             (string) target->the_short() + "'s challenge to debate " +
             topic + ".\n", target);
         tell_object(target, (string) this_player()->the_short() +
                     " accepts your challenge to debate " + topic + ".\n");
         map_delete(_debaters, target);
         this_player()->add_effect(EFFECT, target);
         target->add_effect(EFFECT, this_player());
         return 1;
      }
   }
   if (!HANDLER->query_philosophy(topic)) {
      return notify_fail("You cannot debate \"" + topic + "\".  You can " +
                         "debate " + query_multiple_short((string *) HANDLER->
                                                          query_philosophy_names
                                                          ()) + ".\n");
   }
   type = (string) HANDLER->query_philosophy_type(topic);
   bonus = (int) HANDLER->query_philosophy_bonus(topic);
   needed = (string) HANDLER->query_philosophy_needed(topic);
   if (this_player()->query_skill_bonus(type + ".points") < bonus) {
      return notify_fail(needed + " is not sufficient to debate " +
                         topic + " at the moment.\n");
   }
   if (this_player()->query_specific_gp(type) < bonus) {
      return notify_fail("You are too tired to debate " + topic +
                         " at the moment.\n");
   }
   this_player()->adjust_gp(-(bonus * DEBATE_MULT));
   write("You challenge " + (string) target->the_short() +
         " to a debate on " + topic + ".\n");
   say((string) this_player()->one_short() + " challenges " +
       (string) target->one_short() + " to a debate on " + topic + ".\n",
       target);
   tell_object(target,
               (string) this_player()->one_short() +
               " challenges you to a debate on " + topic + ".\n");
   _debaters[this_player()] = ({ target, topic });
   call_out("answer_challenge", 5, this_player(), target, topic);
   return 1;
}
void answer_challenge(object challenger,
                      object target,
                      string topic)
{
   int bonus;
   int diff;
   string type;
   if (!challenger) {
      return;
   }
   if (!target) {
      return;
   }
   if (environment(challenger) != environment(target)) {
      return;
   }
   if (!_debaters[challenger]) {
      return;
   }
   if ((_debaters[challenger][0] != target) || (_debaters[challenger][1] != topic)) {
      return;
   }
   if (pk_check(challenger, target)) {
      tell_object(target, "Use \"debate " + topic + " with " +
                  (string) challenger->query_name() +
                  "\" to accept the challenge.\n");
      return;
   }
   type = (string) HANDLER->query_philosophy_type(topic);
   bonus = (int) target->query_skill_bonus(type + ".points");
   diff = (int) target->query_skill_bonus(type + ".points") / 3;
   switch ((int) TASKER->perform_task(challenger, type + ".points", 2 * diff,
                                      TM_COMMAND)) {
   case AWARD:
      tell_object(challenger, "You feel " +
                  (string) HANDLER->query_philosophy_needed(topic) +
                  " surge for a moment.\n");
   case SUCCEED:
      tell_object(target, "You find yourself accepting " +
                  (string) challenger->the_short() +
                  "'s challenge to debate " + topic + ".\n");
      tell_room(environment(target),
                (string) target->the_short() + " accepts " +
                (string) challenger->the_short() + "'s challenge to debate " +
                topic + ".\n", ({ target, challenger }));
      tell_object(challenger,
                  (string) target->the_short() +
                  " accepts your challenge to debate " + topic + ".\n");
      map_delete(_debaters, target);
      this_player()->add_effect(EFFECT, target);
      target->add_effect(EFFECT, this_player());
      return;
   default:
      if (userp(target)) {
         tell_object(target, "Use \"debate " + topic + " with " +
                     (string) challenger->query_name() +
                     "\" to accept the challenge.\n");
      }
   }
}
mapping query_debaters()
{
   return _debaters;
}
mixed *query_patterns()
{
   return ({ "<word'topic'> with <indirect:living'person'>",
             (: cmd($1, $2, $3, $4, $5) :) });
}

==================================================
FILE: /lib/cmds/living/defend.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *things) {
  int i;
  object *defendees;
  things -= ({ TP });
  if ( TP->query_property( "dead" ) ) {
    add_failed_mess("You cannot provide much defense as a ghost.\n" );
    return 0;
  }
  if ( !sizeof( things ) ) {
     add_failed_mess("You cannot defend yourself!\n");
     return 0;
  }
  if(TP->query_combat_response() != "parry") {
    add_failed_mess("Dodging out of the way will not help " +
                    query_multiple_short(things) + ".\n");
    return 0;
  }
  defendees = ({ });
  for ( i = 0; i < sizeof( things ); i++ ) {
    if ( things[ i ]->add_defender( TP ) ) {
      defendees += ({ things[ i ] });
      things = delete( things, i, 1 );
      i--;
    }
  }
  if ( !sizeof( defendees ) ) {
    add_failed_mess("You cannot defend $I.\n", things);
    return 0;
  }
  if ( sizeof( things ) ) {
    write( "You cannot defend "+ query_multiple_short( things ) +".\n" );
  }
  add_succeeded_mess(({ "You will defend $I.\n",
                        "$N moves to defend $I.\n" }),
                  defendees);
  return 1;
}
int show_defenders() {
   object *defend;
   object womble;
   defend = this_player()->query_defenders();
   if (sizeof(defend)) {
      write("You are being defended by " + query_multiple_short(defend) +
            ".\n");
   } else {
      write("You are not being defended by anyone.\n");
   }
   defend = ({ });
   foreach (womble in all_inventory(environment(this_player()))) {
      if (living(womble) && womble != this_player()) {
         if (member_array(this_player(), womble->query_defenders()) != -1) {
            defend += ({ womble });
         }
      }
   }
   if (sizeof(defend)) {
      write("Of the people in this room, you are defending " +
            query_multiple_short(defend) + ".\n");
   } else {
      write("You are not defending anyone in this room.\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:living>",
             (: cmd($1) :),
             "",
             (: show_defenders() :) });
}

==================================================
FILE: /lib/cmds/living/double_quote.c
==================================================

#include "/cmds/living/lsay.c"

==================================================
FILE: /lib/cmds/living/drag.c
==================================================

#include <player.h>
#include <room.h>
#include <player_handler.h>
inherit "/cmds/base";
mixed cmd( object *indirect_obs, string direction) {
  string owner;
  object owner_ob;
  string *words, word;
  if( this_player()->query_property( "dead" ) )
    return add_failed_mess( "You're dead.  You can't drag anything.\n" );
  if( objectp( (object)this_player()->query_dragging() ) )
    return add_failed_mess( "You're already dragging something.\n" );
  if( sizeof( indirect_obs ) > 1 )
    return add_failed_mess( "You can only drag one thing at a time.\n" );
  if( indirect_obs[0] == this_player() )
    return add_failed_mess( "You try and drag yourself away from the keyboard, "
      "but you cannot.  Oh no!\n");
  if( living( indirect_obs[ 0 ] ) ) {
    if( !indirect_obs[ 0 ]->query_property( PASSED_OUT_PROP )
        || pk_check( indirect_obs[ 0 ], this_player() ) )
      return add_failed_mess( (string)indirect_obs[ 0 ]->the_short() +
        " doesn't want to be dragged away, thank you very much.\n" );
  } else
    if( base_name(indirect_obs[0]) == "/obj/corpse" ) {
      owner = indirect_obs[ 0 ]->query_owner();
      words = explode( lower_case( owner ),  " " );
      words = filter( words, (: PLAYER_HANDLER->test_user($1) :) );
      foreach( word in words ) {
          owner_ob = find_player( lower_case( word ) );
          if( owner_ob && userp( owner_ob ) &&
            pk_check( owner_ob, this_player() ) &&
            member_array ( this_player()->query_name(), indirect_obs[0]->
            query_permitted() ) == -1 )
            return add_failed_mess( "For some reason, you can't get hold of "+
              (string)indirect_obs[ 0 ]->the_short() +".\n" );
      }
  }
  if( ( environment( indirect_obs[ 0 ] ) != environment( this_player() ) ) ||
    indirect_obs[ 0 ]->get() )
      return add_failed_mess( "For some reason, you can't get hold of " +
        (string)indirect_obs[ 0 ]->the_short() +".\n" );
  write( "You get hold of " + (string)indirect_obs[ 0 ]->the_short() + ".\n" );
  say( (string)this_player()->one_short() + " gets hold of " +
    (string)indirect_obs[ 0 ]->a_short() + ".\n" );
  if( (int)indirect_obs[ 0 ]->query_complete_weight() +
    (int)this_player()->query_loc_weight() > 2 *
    (int)this_player()->query_max_weight() ) {
      write( "You struggle and strain, but you can't budge " +
        (string)indirect_obs[ 0 ]->query_objective() + ".\n" );
      say( (string)this_player()->one_short() + " struggles and strains, but " +
        (string)this_player()->query_pronoun() + " can't budge " +
        (string)indirect_obs[ 0 ]->query_objective() + ".\n" );
  } else {
    this_player()->set_dragging( indirect_obs[ 0 ] );
    if( !this_player()->exit_command( direction ) )
      write( "You can't drag " + (string)indirect_obs[ 0 ]->the_short() +
        " that way.\n" );
    else
      if( interactive( this_player() ) )
        indirect_obs[0]->add_property( "dropped",
          ({this_player()->query_name(), query_ip_number( this_player() ),
          time()}), 1800 );
    this_player()->reset_dragging();
  }
  write( "You let go of " + (string)indirect_obs[ 0 ]->the_short() + ".\n" );
  say( (string)this_player()->the_short() + " releases " +
    (string)this_player()->query_possessive() + " hold of " +
    (string)indirect_obs[ 0 ]->the_short() + ".\n" );
  return 1;
}
mixed *query_patterns() {
  return
    ({ "<indirect:object:here> [to] <word'direction'>",
         (: cmd( $1, implode($4[1..], " ") ) :),
       "<indirect:object:here> [to] <string'direction'>",
         (: cmd( $1, implode($4[1..], " ") ) :) });
}

==================================================
FILE: /lib/cmds/living/draw.c
==================================================

#include <move_failures.h>
#include <obj_parser.h>
#define DEFAULT -1
#define LEFT 0
#define RIGHT 1
inherit "/cmds/base";
int cmd( string weapon_str, object * scabbards, string hand_str ) {
   object scabbard, * weapons, weapon;
   class obj_match match;
   string *limbs;
   string *hands;
   int *what_in;
   int targeted, result;
   int hand;
   match = new( class obj_match );
   targeted = scabbards ? 1 : 0;
   debug_printf( "targeted = %d\nscabbards = %O\n", targeted, scabbards );
   if( !scabbards ) {
      scabbards = filter( all_inventory( this_player() ),
        (: $1->query_scabbard() :) );
      if( !sizeof(scabbards) ) {
         add_failed_mess( "Can't find any scabbards in your inventory.\n" );
         return 0;
      }
      foreach( scabbard in scabbards ) {
         match = (class obj_match)match_objects_in_environments( weapon_str, scabbard,
           0, this_player() );
         result = match->result;
         if( result == OBJ_PARSER_SUCCESS ) {
            weapons = match->objects;
            break;
         } else if( result == OBJ_PARSER_AMBIGUOUS ) {
            add_failed_mess( "Ambiguous reference to \"" + weapon_str
              + "\" in at least one scabbard.\n" );
         }
      }
      if( !sizeof(weapons) ) {
         add_failed_mess( "Cannot find " + weapon_str + " in any "
           "scabbard in your inventory.\n" );
         return 0;
      }
   } else {
      if( sizeof(scabbards) > 1 ) {
         add_failed_mess( "You can only draw from one scabbard at a "
           "time.\n" );
         return -1;
      }
      scabbard = scabbards[0];
      if( !scabbard->query_scabbard() ) {
         add_failed_mess( scabbard->the_short() + " is not a scabbard.\n" );
         return 0;
      }
      if ( environment(scabbard) != this_player() ) {
         add_failed_mess( "You can only draw from a scabbard in your "
           "inventory.\n" );
         return -1;
      }
      match = (class obj_match)match_objects_in_environments( weapon_str, scabbard,
        0, this_player() );
      if( match->result == OBJ_PARSER_SUCCESS ) {
         weapons = match->objects;
      } else {
         add_failed_mess( "Cannot find " + weapon_str + " in " +
           scabbard->the_short() + ".\n" );
         return -1;
      }
   }
   weapon = weapons[0];
   if ( scabbard->query_closed() ) {
      add_failed_mess( "You cannot draw " + weapon->the_short()
        + " from " + scabbard->the_short() + "; it is closed.\n" );
      return targeted ? -1 : 0;
   }
   if( !scabbard->test_type_ok( weapon ) ) {
      add_failed_mess( "You cannot draw " + weapon->the_short()
        + " from " + scabbard->the_short() + ".\n" );
      return targeted ? -1 : 0;
   }
   if ( weapon->move( this_player() ) != MOVE_OK ) {
      add_failed_mess( "You cannot draw " + weapon->the_short()
        + " from " + scabbard->the_short() + ".\n" );
      return targeted ? -1 : 0;
   }
   if (!hand_str)  hand = -1;
   else hand = member_array(hand_str, this_player()->query_limbs());
   if ( !sizeof( weapon->hold_item( this_player(), hand ) ) ) {
      weapon->move( scabbard );
      add_failed_mess( "You cannot hold " + weapon->the_short() + ".\n" );
      return targeted ? -1 : 0;
   }
   if (!hand_str)  {
      limbs = this_player()->query_limbs();
      what_in = find_member(weapon, this_player()->query_holding());
      hands = allocate(sizeof(what_in));
      for (hand = 0; hand < sizeof(what_in); hand++)
         hands[hand] = limbs[what_in[hand]];
      hand_str = query_multiple_short(hands);
   }
   this_player()->add_succeeded_mess(scabbard, "$N $V $I from $D into $p " +
                                     hand_str + ".\n",
     ({ weapon }) );
   return 1;
}
mixed * query_patterns() {
   string limbs;
   limbs = "{" + implode(this_player()->query_limbs(), "|") + "}";
   return ({
      "<string'weapon'>",
        (: cmd( $4[0], 0, 0 ) :),
      "<string'weapon'> from <indirect:object:me'scabbard'>",
        (: cmd( $4[0], $1, 0 ) :),
      "<string'weapon'> into [my] " + limbs,
        (: cmd($4[0], 0, $4[1]) :),
      "<string'weapon'> from <indirect:object:me'scabbard'> into [my] " + limbs,
        (: cmd( $4[0], $1, $4[2]) :),
   });
}

==================================================
FILE: /lib/cmds/living/drop.c
==================================================

#include <move_failures.h>
#include <player.h>
#define MAX_DROP_NUMBER 20
inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *obs, string str) {
   int num, max;
   object bing;
   string env_sh;
   object ob;
   object *fail;
   object *too_many;
   object *keep;
   mapping ret;
   object env;
   string drop_mess;
   ret = ([ ]);
   fail = ({ });
   too_many = ({ });
   keep = ({ });
   if (sizeof(obs) > MAX_DROP_NUMBER) {
      too_many = obs[MAX_DROP_NUMBER..];
      obs = obs[0..MAX_DROP_NUMBER-1];
   }
   foreach(ob in obs) {
      if (!ob->short()) {
         continue;
      }
      if (ob->query_keep()) {
         keep += ({ ob });
         continue;
      }
      env = environment(ob);
      if (function_exists("do_drop", ob) ||
            function_exists("command_control", ob)) {
         if (function_exists("do_drop", ob)) {
            max = (int)call_other(ob, "do_drop", ({ }), str, 0, ({ str }),
                                             "<direct:object:me>");
         } else {
            max = ob->command_control("drop", ({ }), str, 0, ({ str }),
                                                   "<direct:object:me>");
         }
         if (max == 0)  {
            fail += ({ ob });
            continue;
         }
      }
      if (ob->move(environment(TP)) == MOVE_OK) {
         if (ret[env]) {
            ret[env] += ({ ob });
         } else {
            ret[env] = ({ ob });
         }
#ifndef __DISTRUBUTION_LIB__
         if(interactive(TP))
           PLAYER_MULTIPLAYER_HANDLER->record_object("dropped", TP, ob);
#endif
      } else {
        fail += ({ ob });
      }
   }
   if (sizeof(ret)) {
      foreach (env, bing in ret) {
         if (env != this_player()) {
            env_sh = " from inside " + inside_the_short(env);
         } else {
            env_sh = "";
         }
         if ( drop_mess = this_player()->query_drop_mess() ) {
            add_succeeded_mess( drop_mess, bing );
         }
         else {
            add_succeeded_mess("$N $V $I" + env_sh + ".\n", bing);
         }
      }
      if (sizeof(too_many)) {
         add_succeeded_mess(({ "You can only drop " +
                         query_num(MAX_DROP_NUMBER) + " objects at one time; "
                         "discarding.\n", "" }));
      }
   } else {
      if (sizeof(keep)) {
         add_failed_mess("You are keeping $I.\n", keep);
      }
      if (sizeof(fail)) {
         add_failed_mess("You cannot drop $I.\n", fail);
         return 0;
      }
      if (sizeof(too_many)) {
         add_failed_mess("You can only drop " +
                         query_num(MAX_DROP_NUMBER) + " objects at one time; "
                         "discarding $I.\n", too_many);
         return 0;
      }
   }
   num = sizeof(fail)+sizeof(ret);
   if (!num) {
        return 0;
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd($1, $3) :) });
}

==================================================
FILE: /lib/cmds/living/dry.c
==================================================

inherit "/cmds/base";
mixed cmd(mixed *things)
{
   int pwet;
   int twet;
   int max;
   int *enums;
   object thing;
   object with;
   thing = things[0][0];
   with = things[1][0];
   if (!with->id("towel") && !with->query_property("dryer")) {
      return notify_fail("You can't dry anyone with " +
                         (string) with->the_short() + ".\n");
   }
   if (environment(with) != this_player())  {
      return notify_fail(with->a_short() + " isn't going to do much good "
         "inside " + environment(with)->a_short() + ".\n");
   }
   if (thing->query_property("dead")) {
      return notify_fail((string) thing->the_short() + " is dead; " +
                         (string) thing->query_pronoun() +
                         " has more immediate problems than being wet.\n");
   }
   max = 200 * (int) with->query_weight();
   enums = (int *) with->effects_matching("object.wet");
   if (sizeof(enums)) {
      twet = (int) with->arg_of(enums[0]);
   }
   if (twet > max / 2) {
      return notify_fail((string) with->the_short() +
                         " is already dripping wet.  You can't dry anybody "
                         "with it.\n");
   }
   enums = (int *) thing->effects_matching("body.wetness");
   if (sizeof(enums)) {
      pwet = (int) thing->arg_of(enums[0]);
   }
   if (pwet < 10) {
      if (thing == this_player()) {
         return notify_fail("You don't need drying.\n");
      } else {
         return notify_fail((string) thing->the_short() +
                            " doesn't need drying.\n");
      }
   }
   if (pwet + twet > max) {
      pwet = max - twet;
   }
   pwet -= random(10);
   if (pwet > 0) {
      thing->add_effect("/std/effects/other/wetness", -pwet);
      with->add_effect("/std/effects/object/wet", pwet);
   }
   if (thing == this_player()) {
      write("You dry yourself with " + with->the_short() + ".\n");
      say((string) this_player()->one_short() + " dries " +
          (string) this_player()->query_objective() + "self with " +
          (string) with->poss_short() + ".\n");
   } else {
      write("You dry " + (string) thing->the_short() + " with " +
            (string) with->the_short() + ".\n");
      tell_object(thing, (string) this_player()->one_short() +
                  " dries you with " + (string) with->poss_short() + ".\n");
      say((string) this_player()->one_short() + " dries " +
          (string) thing->the_short() + " with " +
          (string) with->poss_short() + ".\n", thing);
   }
   return 1;
}
mixed *query_patterns()
{
   return ({ "<indirect:living'person'> with <indirect:object:me>",
             (: cmd($1) :),
             "myself with <indirect:object:me>",
             (: cmd(({ ({ this_player() }), $1 })) :) });
}

==================================================
FILE: /lib/cmds/living/echo.c
==================================================

#include <player.h>
#include <drinks.h>
inherit "/cmds/base";
#define TP this_player()
void my_mess(string fish, string erk);
mixed cmd(string str) {
  if(!TP->query_creator() && !TP->query_property("echo"))
    return notify_fail(NOT_ALLOWED);
  if (!str || str == "")
    return notify_fail("Syntax : echo <text>\n");
  if (!TP->query_creator() && TP->adjust_sp(-ECHO_COST) < 0)
    return notify_fail(NO_POWER);
  if (TP->query_volume(D_ALCOHOL))
    str = TP->drunk_speech(str);
  log_file("ECHOS", ctime(time())+" "+this_player()->query_name()+" echos: "+
     str+"\n");
  str += "%^RESET%^";
  my_mess("You echo: ", str);
  TP->comm_event(environment(TP), "player_echo", str + "\n");
  return 1;
}
void my_mess(string fish, string erk) {
  if(!interactive(TP)) return;
  printf("%s%-=*s\n", fish, (int)TP->query_cols()-strlen(fish),
          TP->fix_string(erk));
}

==================================================
FILE: /lib/cmds/living/echoto.c
==================================================

#include <player.h>
#include <drinks.h>
inherit "/cmds/base";
#define TP this_player()
void my_mess(string fish, string erk);
mixed cmd(string str) {
  string who, what;
  object ob;
  if(!TP->query_creator() && !TP->query_property("echoto"))
    return notify_fail(NOT_ALLOWED);
  if(!str || str == "")
    return notify_fail("Syntax : echoto <player> <text>\n");
  if(sscanf(str, "%s %s", who, what) != 2)
    return notify_fail("Syntax : echoto <player> <text>\n");
  who = lower_case(who);
  who = (string)TP->expand_nickname(who);
  if(!TP->query_creator() && TP->adjust_sp(-ECHOTO_COST) < 0)
    return notify_fail(NO_POWER);
  ob = find_player(who);
  if(!ob)
    return notify_fail("Can't find "+who+".\n");
  if (TP->query_volume(D_ALCOHOL))
    what = TP->drunk_speech(what);
  log_file("ECHOS", ctime(time())+" "+this_player()->query_name()+" echos "+
     "to "+who+": "+what+"\n" );
  what += "%^RESET%^";
  my_mess("You echo to " + who + ": ", what);
  event(ob, "player_echo_to", what + "\n", TP);
  return 1;
}
void my_mess(string fish, string erk) {
  if(!interactive(TP)) return;
  printf("%s%-=*s\n", fish, (int)TP->query_cols()-strlen(fish),
          TP->fix_string(erk));
}

==================================================
FILE: /lib/cmds/living/em_ote.c
==================================================

#include <library.h>
#include <player.h>
inherit "/cmds/base";
mixed cmd( string words ) {
  string pad = " ";
  if(!environment(this_player())) {
    return notify_fail("You are in limbo, you cannot emote.\n");
  }
  if ( userp( this_player() ) && !this_player()->query_creator() ) {
    if ( this_player()->query_property( "emote" ) ) {
      LIBRARY->set_quest( (string)this_player()->query_name(), "emote" );
      this_player()->remove_property( "emote" );
    }
    if ( !LIBRARY->query_quest_done( (string)this_player()->query_name(),
                                     "emote" ) ) {
      return notify_fail( NOT_ALLOWED );
    }
    if(this_player()->query_property("no emote")) {
      return notify_fail(NOT_ALLOWED);
    }
    if ( (int)this_player()->adjust_sp( -EMOTE_COST ) < 0 ) {
      return notify_fail( NO_POWER );
    }
  }
  if ( !words || ( words == "" ) ) {
    return notify_fail( "Syntax: emote <text>\n" );
  }
  words = strip_colours(words);
  words = replace(words, ({"        ", " ",
                           "       ", " ",
                           "      ", " ",
                           "     ", " ",
                           "    ", " ",
                           "   ", " ",
                            }) );
  this_player()->adjust_time_left( -5 );
  if (words[0..0] == "'") pad = "";
  environment( this_player() )->event_emote( this_player(),
                                             "$C$" + this_player()->one_short() + pad +
                                             words +"\n" );
  all_inventory( environment( this_player() ) )->
    event_emote( this_player(), "$C$" + this_player()->one_short() +
                                pad + words + "%^RESET%^\n" );
  write( "You emote: $C$"+
         (string)this_player()->pretty_short( this_player() ) + pad + words +
         "%^RESET%^\n" );
  return 1;
}

==================================================
FILE: /lib/cmds/living/emoteall.c
==================================================

#include <player.h>
#include <drinks.h>
inherit "/cmds/base";
#define TP this_player()
#define BEEP sprintf("%c",7)
void my_mess(string fish, string erk);
mixed cmd(string str) {
  if(!TP->query_creator() && !TP->query_property("emoteall")) {
    return notify_fail(NOT_ALLOWED);
  }
  if(!str || str == "") {
    return notify_fail("Syntax : emoteall <string>\n");
  }
  if(!TP->query_creator() &&
     TP->adjust_sp(-EMOTEALL_COST*((strlen(str)/10)+1)+100) < 0) {
    return notify_fail(NO_POWER);
  }
  str = replace(str, BEEP, "");
  if (TP->query_volume(D_ALCOHOL)) {
    str = TP->drunk_speech(str);
  }
  log_file("ECHOS", ctime(time())+" "+TP->query_name()+" emotes "+
           "to all: "+str+"\n");
  str += "%^RESET%^";
  my_mess("You emoteall : ", TP->query_cap_name()+" " + str);
  TP->comm_event(users(), "player_emote_all", "%^BOLD%^%^RED%^" + TP->query_cap_name() + " " + str + "\n");
  return 1;
}
void my_mess(string fish, string erk) {
  if(!interactive(TP)) return;
  printf("%s%-=*s\n", fish, (int)TP->query_cols()-strlen(fish),
          TP->fix_string(erk));
}

==================================================
FILE: /lib/cmds/living/eq_uip.c
==================================================

#define TP this_player()
inherit "/cmds/base";
int cmd() {
   int no_limbs;
   string stuff;
   object thing;
   object *equipped;
   object *things;
   equipped = ({ });
   things = all_inventory( TP ) - TP->query_wearing() -
            TP->query_holding();
   foreach ( thing in things ) {
      no_limbs = thing->query_no_limbs();
      if ( no_limbs > TP->query_free_limbs() ) {
         continue;
      }
      if ( thing->query_wearable() ) {
         if ( !TP->wear_armour( thing, 0 ) ) {
            equipped += ({ thing });
         }
         continue;
      }
      if (thing->query_weapon() && no_limbs) {
         if ( sizeof( TP->set_hold( thing,
               member_array( 0, TP->query_holding() ) ) ) ) {
            equipped += ({ thing });
         }
      }
   }
   if ( !sizeof( equipped ) ) {
      return notify_fail( "You have no equippable items.\n" );
   }
   stuff = query_multiple_short( equipped );
   say( (string)TP->one_short() +" equips "+ stuff +".\n" );
   write( "You equip "+ stuff +".\n" );
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: /lib/cmds/living/facing.c
==================================================

#include <dirs.h>
inherit "/cmds/base";
string find_direction( object who );
int check_reference_point( object where );
int cmd( object *indirect_obs ) {
    mapping details;
    object *oblist;
    string *show, dir;
    if ( !check_reference_point( environment( this_player() ) ) ) {
        add_failed_mess( "You can't make out a point of reference "
            "to use to determine which way you're facing!\n" );
        return 0;
    }
    if ( !indirect_obs || sizeof( indirect_obs ) == 1 &&
        indirect_obs[ 0 ] == this_player()) {
        tell_object( this_player(), "You are facing " +
            find_direction( this_player() ) + ".\n" );
        return 1;
    }
    indirect_obs -= ({ this_player() });
    details = unique_mapping( indirect_obs,
        (: find_direction( $1 ) :) );
    show = ({ });
    foreach(dir, oblist in details)  {
      if (sizeof(oblist) > 1)  {
        show += ({ query_multiple_short(oblist) + " are facing " + dir });
      }
      else  {
        show += ({ oblist[0]->one_short() + " is facing " + dir });
      }
    }
    write(query_multiple_short(show) + ".\n");
    return 1;
}
string find_direction( object who ) {
    int facing;
    mapping directions;
    facing = who->query_facing()[ 0 ];
    directions = filter( ABS_FACING, (: $2 == $(facing) :) );
    if ( !sizeof( directions ) )
        return "north";
    return keys( directions )[ 0 ];
}
int check_reference_point( object where ) {
    string *relatives;
    relatives = map( where->query_direc(),
        (: $(where)->query_relative( $1 ) :) );
    return member_array( 0, relatives ) > -1;
}
mixed *query_patterns() {
    return ({ "", (: cmd( 0 ) :),
        "<indirect:living:here>", (: cmd($1) :) });
}

==================================================
FILE: /lib/cmds/living/flip.c
==================================================

#include <money.h>
#define EFFECTS "/obj/handlers/mag_eff_handler"
inherit "/cmds/base";
mixed cmd( object *things ) {
   int *effect;
   object place;
   mixed *stuff, *details;
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can only flip one thing at once.\n");
      return 0;
   }
   stuff = (mixed *)things[ 0 ]->query_money_array();
   if ( !sizeof( stuff ) ) {
      add_failed_mess( "You must have a coin to flip.\n" );
      return 0;
   }
   if ( ( sizeof( stuff ) > 2 ) || ( stuff[ 1 ] != 1 ) ) {
      add_failed_mess( "You can only flip one coin at a time.\n" );
      return 0;
   }
   details = (mixed *)MONEY_HAND->query_details_for( stuff[ 0 ] );
   if ( details[ MONEY_DETAILS_COMPOSITION ] == "paper" ) {
       add_failed_mess( "You cannot flip $I as you would a coin, because "
        "it is made of paper.\n", things );
       return -1;
   }
   write( "You flip "+ (string)things[ 0 ]->the_short() +".\n" );
   say( (string)this_player()->one_short() +" flips "+
         (string)things[ 0 ]->a_short() +".\n" );
   effect = (int *)EFFECTS->choose_effect(
         (int)EFFECTS->ambient_enchantment( things[ 0 ] ) );
   place = environment( this_player() );
   if ( random( 1000 ) < effect[ 0 ] ) {
      switch( effect[ 1 ] ) {
         case 0 :
            things[ 0 ]->move( place );
            tell_room( place, (string)things[ 0 ]->the_short() +
                  " lands on its edge.\n" );
            break;
         default :
            things[ 0 ]->move( "/room/rubbish" );
      }
      EFFECTS->do_effect( effect[ 1 ], (string)things[ 0 ]->the_short(),
            place );
      return 1;
   }
   things[ 0 ]->move( place );
   tell_room( place, (string)things[ 0 ]->the_short() +" falls "+
         (string)place->query_property( "here" ) +", "+
         details[ random( 2 ) ] +" up.\n" );
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd( $1 ) :) });
}

==================================================
FILE: /lib/cmds/living/fo_llow.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(object *obs) {
   object *ok, ob;
   object *already;
   string s;
   mapping hide_invis;
   int hiding, sneaking;
   ok = ({ });
   already = ({ });
   foreach (ob in obs) {
      if (member_array(TP, ob->query_followers()) == -1) {
         if (ob->add_follower(TP)) {
            ok += ({ ob });
         }
      } else {
         already += ({ ob });
      }
   }
   if (!sizeof(ok)) {
      if (sizeof(already)) {
         add_failed_mess("You are already following $I.\n", already);
      }
      obs -= already;
      if (sizeof(obs)) {
         if(member_array(TP, obs) == -1) {
            add_failed_mess("You cannot follow " + query_multiple_short(obs) +
                                          ".\n");
         } else {
            add_failed_mess("You can't follow " +
                          query_multiple_short(obs - ({TP}) + ({"yourself"})) +
                          ".\n");
         }
      }
      return 0;
   }
  hide_invis = ( mapping )this_player()->query_hide_invis();
  hiding = hide_invis[ "hiding" ] ? 1 : 0;
  sneaking = this_player()->query_sneak_level() ? 1 : 0;
  if( hiding || sneaking )
    write("You follow " + ( s = query_multiple_short( ok ) ) + " unseen.\n" );
  else {
   write("You follow "+(s=query_multiple_short(ok))+".\n");
   say(TP->one_short(1)+" follows "+s+".\n", ok);
   foreach (ob in ok)
      tell_object(ob, TP->one_short(1)+
                      " follows "+query_multiple_short((ok + ({"you"})) -
                      ({ ob }))+".\n");
  }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:living>", (: cmd($1) :) });
}

==================================================
FILE: /lib/cmds/living/g_lance.c
==================================================

#include <obj_parser.h>
#include <dirs.h>
#include <player.h>
inherit "/cmds/base";
int check_exists(string file);
string room_glance(object person, object room, int dark);
mixed cmd_direction(string dir);
int check_pre_stuff() {
   int dark;
   object room;
   room = environment(previous_object());
   if (!room) {
      return notify_fail("You are in limbo... sorry you can't look at "+
             "anything.\n");
   }
   if (!previous_object()->query_property("dead")) {
      dark = (int)previous_object()->check_dark((int)room->query_light());
   }
   if( dark < 0 ) {
      write("It's too dark to look at anything.\n");
      return 1;
   } else if( dark > 0 ) {
      write("It's too bright to look at anything.\n");
      return 1;
   }
   return 2;
}
mixed cmd_ob(object* obs) {
   object thing;
   int retval;
   int dark;
   object room;
   retval = check_pre_stuff();
   if (retval != 2) {
      return retval;
   }
   room = environment(previous_object());
   dark = (int)previous_object()->check_dark((int)room->query_light());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   foreach (thing in obs) {
      string tmp;
      if(thing == this_player()) {
        write("That's you that is.\n");
      } else {
        tmp = (string)thing->a_short( dark );
        if (tmp) {
          write(capitalize(tmp) + ".\n");
        }
      }
   }
   return 1;
}
mixed cmd_direction(string dir, int from_string) {
   object room;
   int dark;
   int retval;
   string ret;
   string dest;
   mixed *func;
   retval = check_pre_stuff();
   if (retval != 2) {
      return retval;
   }
   retval = 0;
   room = environment(previous_object());
   dark = (int)previous_object()->check_dark((int)room->query_light());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   dir = EXPAND_EXIT(dir);
   if ( room->query_relative( dir ) ) {
      add_failed_mess( "You do not think that the "+ dir +" is here.\n" );
      return 0;
   }
   dir = (string)this_player()->find_abs(dir);
   if(room->query_exit(dir)) {
      room->set_destination( dir );
      if ( check_exists( (string)room->query_destination( dir ) ) ) {
         write("You glance " + dir + " and see:\n");
         ret = room->query_look(dir);
         if (ret) {
            write(ret+"\n");
            return 1;
         }
         func = room->query_look_func(dir);
         if(sizeof(func)) {
            call_other(func[0], func[1], 1);
            return 1;
         }
         dest = room->query_destination(dir);
         if(room->query_door_open(dir) != 0) {
            if (!dark && !previous_object()->query_property("dead") &&
                !previous_object()->query_creator()) {
               dark = previous_object()->check_dark(dest->query_light());
            }
            load_object(dest);
            this_player()->set_looked( find_object( dest ) );
            if (dark) {
               write("It's too dark to see that far.\n");
            } else  {
               write( (string)dest->a_short( dark ) +" "+
                     (string)dest->query_short_exit_string()+".\n"+
                     (string)dest->query_contents(""));
            }
            return 1;
         } else if(room->query_door_open(dir) == 0) {
            write("The "+dir+" door is closed.\n");
         }
      }
   }
   if (!retval) {
      add_failed_mess("You do not think that the "+dir+" is here.\n");
   }
   return retval;
}
string room_glance(object person, object room, int dark) {
   string ret;
   string sees;
   object mirror;
   ret = "";
   if (person->query_creator()) {
      ret += " %^CYAN%^" + file_name(room) + "%^RESET%^";
      sees=(string)room->query_property("creator sees");
      if (sees) {
         ret += sees +"\n"+ (string)room->query_contents();
      }
   }
   mirror = room->query_mirror_room();
   if (mirror) {
      room = mirror;
   }
   if(!dark || previous_object()->query_creator()) {
      if (mirror) {
         ret += ".\n" + (string)mirror->query_contents();
      } else {
         ret += (string)room->query_short_exit_string()+".\n"+
           (string)room->query_contents();
      }
   } else if((dark == 2) || (dark == -2)) {
      if (!mirror) {
         ret += (string)room->query_short_exit_string()+"\n";
      } else {
         ret += "\n";
      }
      if((string)room->query_contents("") != "") {
         ret += person->colour_event("inventory", "%^GREEN%^") +
           "Some objects you can't make out are here.%^RESET%^\n";
      }
   } else {
      ret += "\n";
   }
   if (dark == 1 || dark == -1) {
      ret += "You can't see your hand in front of your face.\n";
   } else  {
      ret = "$a_short:"+ file_name(room) + "$"+ ret;
   }
   if (mirror) {
      ret += "Around " + room->the_short() + " is:\n";
      ret += room_glance(person, mirror, dark);
   }
   return ret;
}
int cmd_here() {
   object room;
   int dark;
   int retval;
   string str;
   retval = check_pre_stuff();
   if (retval != 2) {
      return retval;
   }
   room = environment(previous_object());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   dark = previous_object()->check_dark((int)room->query_light());
   str = room_glance(previous_object(), room, dark);
   write(str);
   return 1;
}
int check_exists(string file) {
  if ( objectp( find_object( file ) ) )
    return 1;
  if (file_size(file+".c") > 0) {
    return 1;
  }
  return 0;
}
mixed* query_patterns() {
   return ({
             "", (: cmd_here() :),
             "exit <string'exit'>", (: cmd_direction($4[0], 1) :),
             "[at] <indirect:object>", (: cmd_ob($1) :),
             "<string'exit'>", (: cmd_direction($4[0], 0) :),
            });
}

==================================================
FILE: /lib/cmds/living/get.c
==================================================

#include <obj_parser.h>
#include <move_failures.h>
#include <player.h>
#define DROP_H 40
#define PINCH_H 120
#define MAX_GET_NUMBER 20
inherit "/cmds/base";
#define TP this_player()
object* find_matching_obs(string match_str, object dob) {
   class obj_match result;
   result = (class obj_match)match_objects_in_environments(match_str, dob);
   if (result->result != OBJ_PARSER_SUCCESS) {
      add_failed_mess(match_objects_failed_mess(result));
      return 0;
   }
   return result->objects;
}
mixed cmd(object * obs, string dir, string indir, mixed *args) {
   object *dest;
   object ob;
   object dob;
   object *fail_dest;
   object *too_many;
   mixed *fail;
   mixed *ret;
   mixed amt;
   string sh;
   string hand_unit;
   string match_str;
   int i;
   int num;
   int cap;
   int perc;
   int handful;
   int total_num;
   mixed we;
   object env;
   object *bing;
   fail_dest = ({ });
   cap = (int) TP->query_max_weight();
   if (indir && sizeof(obs) > 10) {
      add_failed_mess("Please be more specific as to what you want "
                      "to get from.\n");
      return 0;
   }
   if (indir) {
      match_str = args[0];
      dest = obs;
   } else {
      if (environment(TP)->query_mirror_room()) {
         dest = ({ environment(TP), environment(TP)->query_mirror_room() });
      } else {
         dest = ({ environment(TP) });
      }
   }
   too_many = ({ });
   foreach(dob in dest) {
     if (!is_in_me_or_environment(dob, this_player())) {
         fail_dest += ({ dob });
         continue;
      }
      if (dob->cannot_get_stuff() || dob->query_closed()) {
         fail_dest += ({ dob });
         continue;
      }
      if (living(dob) && !dob->allowed_to_loot(this_player())) {
        fail_dest += ({ dob });
        continue;
      } else if (indir) {
         obs = find_matching_obs(match_str, dob);
      }
      if (!obs) {
         continue;
      }
      if (total_num + sizeof(obs) > MAX_GET_NUMBER) {
         if (total_num > MAX_GET_NUMBER) {
            too_many += obs;
            obs = ({ });
         } else {
            too_many += obs[MAX_GET_NUMBER - total_num..];
            obs = obs[0..MAX_GET_NUMBER - total_num - 1];
         }
      }
      total_num += sizeof(obs);
      ret = ({ ([ ]), ([ ]), ([ ]), ([ ]), ([ ]), });
      fail = ({ });
      foreach(ob in obs) {
        env = environment(ob);
        if(env != dob) {
          if(ob->query_collective())
            ob->move(dob);
          else
            dob = env;
        }
        if ((living(dob) && !dob->allowed_to_loot(this_player(), ob)) ||
            (ob->query_liquid() && ob->query_food_object())) {
          fail += ({ ob });
          num++;
          continue;
        }
         if (ob->query_continuous()) {
            amt = ob->query_amount_types();
            if (amt["handful"]) {
               hand_unit = "handful";
               handful = amt["handful"][0];
            } else if ((amt["drop"]) && (ob->query_liquid())) {
               hand_unit = "drops";
               handful = amt["drop"][0] * DROP_H;
            } else if (amt["pinch"]) {
               hand_unit = "pinches";
               handful = amt["pinch"][0] * PINCH_H;
            } else {
               handful = ob->query_amount();
            }
            if (ob->query_amount() > handful) {
               if (!match_str) {
                  match_str = ob->query_name();
               }
               if (i = strsrch(match_str, "of") >= 0) {
                  i += 3;
               }
               if (hand_unit == "handful") {
                  handful = 1;
               }
               match_str = handful + " " + hand_unit + " of " +
                  match_str[i..];
               fail += ({ "all of the " + ob->short() });
               ob = ob->query_parse_id(({ handful, match_str }));
               if (!ob) {
                  continue;
               }
               num++;
            }
         }
         if (function_exists("do_get", ob) ||
             function_exists("command_control", ob)) {
            if (function_exists("do_get", ob)) {
               we = (int) call_other(ob, "do_get", dob, 0, match_str,
                                     ({ 0, match_str }),
                                     "<direct:object> from <indirect:object>");
            } else {
               we = ob->command_control("get", dob, 0, match_str,
                                        ({ 0, match_str }),
                                        "<direct:object> from <indirect:object>");
            }
            if (!objectp(we)) {
               if (we) {
                  we = (int) ob->query_weight();
                  perc = (we * 100) / cap;
                  if (perc >= 95) {
                     i = 4;
                  } else {
                     i = perc / 25;
                  }
                  if (!ret[i][env]) {
                     ret[i][env] = ({ ob });
                  } else {
                     ret[i][env] += ({ ob });
                  }
               } else {
                  if (member_array(ob, this_player()->query_succ_mess_indir())
                      == -1 && !query_notify_fail() && !living(ob)) {
                     fail += ({ ob });
                  }
                  num++;
               }
               continue;
            } else {
               ob = we;
            }
         }
#ifndef __DISTRIBUTION_LIB__
         if(interactive(TP) &&
            PLAYER_MULTIPLAYER_HANDLER->check_multiplayers("get", TP, ob)) {
           fail += ({ ob });
           num++;
         } else
#endif
         if ((int) ob->move(TP) == MOVE_OK) {
            we = (int) ob->query_weight();
            perc = (we * 100) / cap;
            if (perc >= 95) {
               i = 4;
            } else {
               i = perc / 25;
            }
            if (!ret[i][env]) {
               ret[i][env] = ({ ob });
            } else {
               ret[i][env] += ({ ob });
            }
         } else {
            fail += ({ ob });
            num++;
         }
      }
      for (i = 0; i < sizeof(ret); i++) {
         if (sizeof(ret[i])) {
            foreach(env, bing in ret[i]) {
               if (this_player()->query_succ_mess_dir()) {
                  bing -= this_player()->query_succ_mess_dir();
               }
               if (sizeof(bing)) {
                  sh = query_multiple_short(bing);
                  write("You " + ({ "get", "get with a bit of difficulty",
                                    "struggle somewhat to get",
                                    "find it very difficult to get",
                                    "use all your strength and just barely manage to get" })
                        [i] + " " + sh + " from " + inside_the_short(dob) +
                        ".\n");
                  say(capitalize((string) TP->one_short()) + " " +
                      ({ "gets", "gets with a bit of difficulty",
                         "struggles somewhat to get",
                         "finds it very difficult to get",
                         "uses all " + TP->query_possessive() +
                         " strength and just barely manages to get" })[i] +
                      " " + sh + " from " + inside_a_short(dob) + ".\n");
               }
            }
         }
      }
      if (sizeof(fail)) {
         add_failed_mess("You cannot get $I.\n", fail);
      }
   }
   if (num == total_num) {
      if (query_notify_fail()) {
         return 0;
      }
      if (indir) {
         if (sizeof(fail_dest)) {
            add_failed_mess("You cannot get anything from $I.\n", fail_dest);
         }
      } else {
         add_failed_mess("You cannot get $I.\n", obs);
      }
      return -1;
   } else {
      if (sizeof(too_many)) {
         add_succeeded_mess(({ "You cannot pick up more than " +
                               query_num(MAX_GET_NUMBER) +
                               " objects at a time; " "discarding $I.\n",
                               "" }), too_many);
      }
   }
   return 1;
}
mixed *
query_patterns()
{
   return ({ "<indirect:object:here>", (: cmd($1, 0, 0, 0) :),
             "<string> from <indirect:object>", (: cmd($1, $2, $3, $4) :) });
}

==================================================
FILE: /lib/cmds/living/give.c
==================================================

#include <move_failures.h>
#include <player.h>
inherit "cmds/base";
#define TP this_player()
#define SUPPRESS_MESS "suppress give messages"
mixed cmd(mixed *indir, string *indir_match) {
  string sh;
  string s1;
  string failmess;
  int tot;
  int max;
  int ok;
  object *per;
  object *ret;
  object *fail;
  object pobj;
  object ob;
  object *obs;
  object *succ;
  object *keep;
  per = indir[1];
  succ = ({ });
  keep = ({ });
  failmess = "";
  foreach(pobj in per) {
    obs = indir[0];
    obs -= per;
    if (pobj->query_property("player") && !interactive(pobj)) {
      failmess = pobj->the_short()+" seems too chalky to accept your "
        "gift.\n";
      continue;
    }
    if (pobj == TP) {
     failmess = "You nag yourself for a while, but can't convince "
                 "yourself to accept things from yourself.\n";
     continue;
    }
    if (!sizeof(obs)) {
      failmess = "Nothing to give to "+ pobj->short() +".\n";
      continue;
    }
    ret = ({ });
    fail = ({ });
    foreach(ob in obs) {
      if ( member_array( ob, succ ) > -1 ) {
        continue;
      }
      if (ob->query_keep()) {
         keep += ({ ob });
         continue;
      }
      if (function_exists("do_give", ob) ||
          function_exists("command_control", ob)) {
        if (function_exists("do_give", ob)) {
          max = call_other(ob, "do_give", pobj, indir_match[0],
                                indir_match[1],
                                ({ indir_match[0], indir_match[1] }),
                                "<direct:object:me> to <indirect:living>");
        } else {
          max = ob->command_control("give", pobj, indir_match[0],
                                    indir_match[1],
                                    ({ indir_match[0], indir_match[1] }),
                                    "<direct:object:me> to <indirect:living>");
        }
        if (max == 0)  {
          fail += ({ ob });
          continue;
        }
      }
#ifndef __DISTRIBUTION_LIB__
      PLAYER_MULTIPLAYER_HANDLER->record_object("give", TP, ob);
      if(pobj->query_property("player") && interactive(TP) &&
         "/obj/handlers/multiplayer"->check_multiplayers("give", pobj, ob)) {
        fail += ({ ob });
      } else
#endif
      if (pobj->query_closed()  ||  ob->move(pobj) != MOVE_OK) {
        fail += ({ ob });
      } else  {
        ret += ({ ob });
        tot += ob->query_weight();
      }
    }
    if (sizeof(ret)) {
      ok = 1;
      succ += ret;
      if (pobj->query_clothing()) {
        s1 = pobj->query_pocket_mess();
      } else {
        s1 = "$ob_short$";
      }
      sh = query_multiple_short(ret);
      if ( interactive( pobj ) || !pobj->query_property( SUPPRESS_MESS ) ) {
        tell_object(TP, "You give "+ sh +" to "+
                  replace_string(s1, "$ob_short$", pobj->one_short())+
                  ".\n");
        tell_room(environment(TP), TP->one_short() + " gives " + sh +
               " to " + replace_string(s1, "$ob_short$",
                                      pobj->one_short()) +
               ".\n", ({ TP, pobj }));
        tell_object(pobj, capitalize(TP->one_short() ) + " gives "+
                    sh + " to you.\n" );
      }
      if (living(pobj) && (max = pobj->query_max_weight()))
        if ((max = tot*100/max) > 25)
          if (max >= 95) {
            tell_room(environment(TP),
                      pobj->the_short()+" staggers under a weight "+
                      pobj->query_pronoun()+" can only just carry.\n",
                      ({ pobj }) );
            pobj->event_say(TP, "You stagger under a weight you can only "
                            "just carry.\n");
          } else {
            tell_room(environment(TP), pobj->the_short()+ ({
              " is only mildly discomforted by the additional weight.\n",
              " braces "+pobj->query_objective()+"self to take the load.\n",
              " stumbles as "+pobj->query_pronoun()+" takes the load.\n"
              })[(max/25)-1], ({ pobj }) );
            pobj->event_say(TP, "You"+ ({
              " are only mildly discomforted by the additional weight.\n",
              " brace yourself under the load.\n",
              " stumble as you take the load.\n"
              })[(max/25)-1]);
          }
    }
    if (sizeof(fail)) {
      failmess += "You cannot give "+query_multiple_short(fail)+ " to "+
                  pobj->one_short() +".\n";
    }
  }
  if (!ok) {
    add_failed_mess(failmess);
    if (sizeof(keep)) {
       add_failed_mess("You have $I set to be kept.\n", keep);
    }
  }
  return ok;
}
mixed *query_patterns() {
  return ({ "<indirect:object:me> to <indirect:living>",
            (: cmd($1, $3) :) });
}

==================================================
FILE: /lib/cmds/living/ho_ld.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(object * obs,
        string str)
{
   int num_limbs;
   int avail;
   int old_avail;
   int reqd;
   int i;
   int pos;
   int success;
   int *used;
   int *already_used;
   int *limbs_used;
   object ob;
   object weapon;
   object *using;
   object *fails;
   object *unfails;
   object *holds;
   object *unholds;
   object *already;
   object *no_change;
   string *limbs;
   string *hhands;
   string *uhands;
   limbs = TP->query_limbs();
   num_limbs = sizeof(limbs);
   avail = TP->query_free_limbs();
   no_change = ({ });
   already = filter(obs, (: $1->query_holder() :));
   if (sizeof(already) > 0) {
      using = this_player()->query_holding();
      foreach (ob in already)  {
         limbs_used = find_member(ob, using);
         if (str)  {
            if (sizeof(limbs_used) == 1  &&
                member_array(str, limbs) == limbs_used[0])
            {
               no_change += ({ ob });
            }
            else already -= ({ ob });
         }
         else if (sizeof(limbs_used) != ob->query_no_limbs())
            already -= ({ ob });
      }
      if (sizeof(obs) == sizeof(no_change))  {
         add_failed_mess("You are already holding " +
                         query_multiple_short(obs) +
                         " in your " + str + ".\n");
         return -1;
      }
      else if (sizeof(obs) == sizeof(already)) {
         return notify_fail("You are already holding " +
                            query_multiple_short(obs) + ".\n");
      } else {
         obs -= already;
         if (sizeof(already) > 0)
            write(sprintf("You are already holding %s, you instead try to "
                          "hold %s.\n", query_multiple_short(already),
                          query_multiple_short(obs)));
         already_used = map(already, (: $1->query_my_limb() :));
      }
   } else {
      already_used = ({ });
   }
   fails = holds = unholds = hhands = uhands = unfails = ({ });
   if (str && obs[0]) {
      pos = member_array(str, limbs);
      if (pos == -1) {
         if (!sizeof(limbs)) {
            return
               notify_fail("You seem to have a singular lack of limbs.\n");
         }
         return notify_fail("Incorrect limb type, must be one of " +
                            query_multiple_short(limbs) + ".\n");
      }
      using = TP->query_holding();
      if (sizeof(unfails) == 0  &&  using[pos]) {
         used = TP->set_unhold(using[pos]);
         if (sizeof(used) == 0) {
            unfails += ({ using[pos] });
            uhands += ({ limbs[pos] });
         } else {
            for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
               uhands += ({ limbs[used[i]] });
            }
            unholds += ({ using[pos] });
         }
      }
      if ((i = member_array(obs[0], using - unholds)) != -1)  {
         used = TP->set_unhold(obs[0]);
         if (sizeof(used) == 0) {
            unfails += ({ obs[0] });
            uhands += ({ limbs[i] });
         } else {
            for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
               uhands += ({ limbs[used[i]] });
            }
            unholds += ({ obs[0] });
         }
      }
      if (sizeof(unfails) == 0) {
         used = TP->set_hold(obs[0], pos, 1);
         if (sizeof(used) == 0) {
            fails += ({ obs[0] });
         } else {
            for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
               hhands += ({ limbs[used[i]] });
            }
            holds += ({ obs[0] });
            success = 1;
         }
      }
   } else {
      foreach(ob in obs) {
         reqd += ob->query_no_limbs();
      }
      if (reqd > num_limbs) {
         add_failed_mess("You do not have enough limbs to hold $I.\n", obs);
         return 0;
      }
      old_avail = -1;
      while ((avail < reqd) && (avail < num_limbs)) {
         if ((reqd > num_limbs - sizeof(unfails)) || (old_avail == avail)) {
            if (sizeof(unfails)) {
               add_failed_mess
                  ("You do not have enough limbs to hold $I, since " +
                   query_multiple_short(unfails) + " failed " "to unhold.\n",
                   obs);
            } else {
               add_failed_mess
                  ("Not able to free up enough limbs to hold $I.\n", obs);
            }
            return 0;
         }
         old_avail = avail;
         using = TP->query_holding();
         for (i = 0; i < sizeof(using); i++) {
            weapon = using[i];
            if (weapon && member_array(i, already_used) == -1) {
               used = TP->set_unhold(weapon);
               if (sizeof(used)) {
                  for (i = 0; i < sizeof(used) && used[i] < sizeof(limbs);
                       i++) {
                     uhands += ({ limbs[used[i]] });
                  }
                  unholds += ({ weapon });
                  avail = TP->query_free_limbs();
                  break;
               } else {
                  if (member_array(weapon, unfails) == -1) {
                     unfails += ({ weapon });
                  }
                  uhands += ({ limbs[i] });
               }
            }
         }
      }
      if (!sizeof(unfails)) {
         foreach(ob in obs) {
            using = TP->query_holding();
            pos = 0;
            if (!ob->query_no_limbs() || avail < ob->query_no_limbs()) {
               fails += ({ ob });
               break;
            }
            while ((using[pos]) && (pos < num_limbs)) {
               pos++;
            }
            used = TP->set_hold(ob, pos, ob->query_no_limbs());
            if (used == ({ })) {
               fails += ({ ob });
            } else {
               for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
                  hhands += ({ limbs[used[i]] });
               }
               holds += ({ ob });
               success = 1;
               avail = TP->query_free_limbs();
            }
         }
      }
   }
   if (sizeof(unfails)) {
      tell_object(TP,
                  "You fail to put down " + query_multiple_short(unfails) +
                  " from your " + query_multiple_short(uhands) + ".\n");
      say(TP->one_short() + " fails to put down " +
          query_multiple_short(unholds) + " from " + TP->query_possessive() +
          " " + query_multiple_short(uhands) + ".\n");
   }
   if (sizeof(unholds)) {
      tell_object(TP, "You put down " + query_multiple_short(unholds) +
                  " from your " + query_multiple_short(uhands) + ".\n");
      say(TP->one_short() + " puts down " + query_multiple_short(unholds) +
          " from " + TP->query_possessive() + " " +
          query_multiple_short(uhands) + ".\n");
   }
   if (sizeof(holds)) {
      tell_object(TP,
                  "You hold " + query_multiple_short(holds) + " in your " +
                  query_multiple_short(hhands) + ".\n");
      say(TP->one_short() + " holds " + query_multiple_short(holds) + " in " +
          TP->query_possessive() + " " + query_multiple_short(hhands) +
          ".\n");
   }
   if (!success && sizeof(fails)) {
      tell_object(TP,
                  "You fail to hold " + query_multiple_short(fails) + ".\n");
      say(TP->one_short() + " fails to hold " + query_multiple_short(fails) +
          ".\n");
   }
   return 1;
}
mixed *query_patterns()
{
   return ({ "<indirect:object:me>", (: cmd($1, 0) :),
             "<indirect:object:me> in [my] {" +
             implode(this_player()->query_limbs(), "|") + "}",
             (: cmd($1, implode($4[1..], " ")) :) });
}

==================================================
FILE: /lib/cmds/living/kill.c
==================================================

#include <player.h>
inherit "/cmds/base";
int cmd( object* things ) {
   object thing;
   object *fighting;
   if ( !environment( this_player() ) ) {
      add_failed_mess( "You are in limbo...\n" );
      return 0;
   }
   if ( this_player()->no_offense() ) {
      add_failed_mess( "You cannot attack anyone at the moment.\n" );
      return 0;
   }
   things -= ({ this_player() });
   if ( !sizeof( things ) ) {
      add_failed_mess( "You shouldn't beat yourself up so much.\n");
      return 0;
   }
   foreach ( thing in things ) {
      if ( !userp( thing ) ) {
         if ( userp( this_player() ) ||
               !thing->query_property( "no attack" ) ) {
            this_player()->attack_ob( thing );
            thing->attack_by(this_player());
         }
         continue;
      }
      if ( !interactive( thing ) ) {
         write( (string)thing->the_short() +" is net-dead.\n" );
         things -= ({ thing });
         continue;
      }
      if ( thing->query_property( "guest" ) ) {
         write( "You cannot attack "+ (string)thing->the_short() +
               " since "+ (string)thing->query_pronoun() +" is a guest.\n" );
         things -= ({ thing });
         continue;
      }
      if ( thing->query_property( "dead" ) ) {
         write( "You cannot attack "+ (string)thing->the_short() +
               " since "+ (string)thing->query_pronoun() +
                " is already dead.\n" );
         things -= ({ thing });
         continue;
      }
      if ( thing->query_auto_loading() ) {
         write( "Be sporting; "+ (string)thing->the_short() +
               " doesn't have "+ (string)thing->query_possessive() +
               " equipment yet.\n" );
         things -= ({ thing });
         continue;
      }
      if ( userp( this_player() ) &&
           !this_player()->query_player_killer() ) {
         write( "You cannot summon the courage to attack "+
               (string)thing->the_short() +".\n" );
         things -= ({ thing });
         continue;
      }
      if ( userp( this_player() ) &&
            !thing->query_player_killer() ) {
         write( "Something tells you that it would be wrong "
               "to attack "+ (string)thing->the_short() +".\n" );
         things -= ({ thing });
         continue;
      }
      call_out( (: this_player()->attack_ob( $(thing) ) :), 0);
      call_out( (: $(thing)->attack_by(this_player()) :), 0);
   }
    if ( sizeof( things ) ) {
      fighting = ({ });
      foreach(thing in things) {
        object *list;
        list = thing->query_attacker_list();
        if (arrayp(list)) {
           fighting += list;
        }
      }
      if(sizeof(fighting))
        fighting = filter(uniq_array(fighting),
                          (: $1 && environment($1) != environment(this_player()) :));
      if(!sizeof(fighting))
        this_player()->add_succeeded_mess(this_object(),
                                          ({ "You prepare to attack " + query_multiple_short(things) + ".\n", "" }), ({ }) );
      else
        this_player()->add_succeeded_mess(this_object(),
					  ({ "You prepare to attack " + query_multiple_short(things) + " who " + (sizeof(things) > 1 ? "are" : "is") + " already hunting " + query_multiple_short(fighting) + ".\n", "" }), ({ }) );
        return 1;
    } else {
        add_failed_mess("");
        return 0;
    }
}
mixed *query_patterns() {
   return ({ "<indirect:living:here>", (: cmd($1) :) });
}

==================================================
FILE: /lib/cmds/living/kneel.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("kneel", "down", KNEELING);
}
# Total Tokens: 21983
# Total Files Merged: 25
# Total Characters: 73345

