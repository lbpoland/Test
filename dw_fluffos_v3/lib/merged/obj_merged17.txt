# Total Tokens: 22110
# Total Files Merged: 11
# Total Characters: 73739

dlers/report_handler.c
==================================================

#include <report_handler.h>
inherit "/std/object";
void move_to_recent_cases(mixed *thing);
mixed *new_cases, *recent_cases;
void setup() {
  set_short("report handler");
  add_property("determinate", "the ");
  set_long("This is a rather tacky statue of a woman holding "
    "a sword and some wonky scales.\n");
  if(file_size(NEWCASES) > -1) {
    new_cases = restore_variable(read_file(NEWCASES));
  }
  if(file_size(RECENT) > -1) {
    recent_cases = restore_variable(read_file(RECENT));
  }
}
void save_new_cases() {
  unguarded((: rm, NEWCASES :));
  unguarded((: write_file, NEWCASES, save_variable(new_cases)+"\n" :));
}
mixed query_new() {
  return new_cases;
}
int sizeof_new_cases() {
  if(!new_cases) {
    new_cases = restore_variable(read_file(NEWCASES));
  }
  return sizeof(new_cases);
}
string query_new_cases() {
  int i, j;
  string reports = "";
  for(i = 0; i < sizeof(new_cases); i++) {
    if(i < 10) {
      reports += "   "+(i + 1)+": ";
    } else {
      reports += "  "+(i + 1)+": ";
    }
    reports += "%^CYAN%^Player%^RESET%^: "+capitalize(new_cases[i][NAME]);
    for(j = 0; j < (12 - sizeof(new_cases[i][NAME])); j++) {
      reports += " ";
    }
    reports += "%^CYAN%^Category%^RESET%^: "+new_cases[i][CATEGORY]+"\n";
  }
  return reports;
}
string query_new_case(int i) {
  string report = "";
  mixed *stuff;
  if(!new_cases) {
    new_cases = restore_variable(read_file(NEWCASES));
  }
  if(i < 1 || i > sizeof(new_cases)) {
    return 0;
  }
  stuff = new_cases[i - 1];
  report += "  %^CYAN%^Suspect%^RESET%^: "+capitalize(stuff[NAME])+"\n";
  if(!sizeof(stuff[CHARS])) {
    report += "  %^CYAN%^Other Characters%^RESET%^: Unknown.\n";
  } else {
    report += "  %^CYAN%^Other Characters%^RESET%^: "
      "$I$5="+query_multiple_short(stuff[CHARS])+"$I$0=\n";
  }
  report += "  %^CYAN%^Creator%^RESET%^: "+stuff[CREATOR]+"\n"
    "  %^CYAN%^Time%^RESET%^: "+stuff[TIME]+"\n"
    "  %^CYAN%^Category%^RESET%^: "+stuff[CATEGORY]+"\n"
    "  %^CYAN%^Report%^RESET%^: $I$5="+stuff[REPORT]+"$I$0=";
  return report;
}
void add_report(string *stuff) {
  if(!new_cases) {
    new_cases = restore_variable(read_file(NEWCASES));
  }
  new_cases += ({ stuff });
  save_new_cases();
}
void deal_with_it(int num, string name, string decision) {
  mixed *thing;
  num--;
  thing = new_cases[num];
  thing += ({ name });
  thing += ({ decision });
  new_cases -= ({new_cases[num]});
  move_to_recent_cases(thing);
}
void save_recent_cases() {
  unguarded((: rm, RECENT :));
  unguarded((: write_file, RECENT, save_variable(recent_cases)+"\n" :));
}
void move_to_recent_cases(mixed *thing) {
  int i, j;
  mixed *c_record, *chars;
  for(i = sizeof(recent_cases) - NO_RECENT; i > -1; i--) {
    chars = ({recent_cases[i][NAME]});
    if(arrayp(recent_cases[i][CHARS])) {
      chars += recent_cases[i][CHARS];
    }
    uniq_array(chars);
    for(j = 0; j < sizeof(chars); j++) {
      if(file_size((SAVEPATH+chars[j]+".o")) > -1) {
        c_record = restore_variable(read_file((SAVEPATH+chars[j]+".o")));
        c_record += ({recent_cases[j]});
      } else {
        c_record = ({recent_cases[j]});
      }
      unguarded((: rm, (SAVEPATH+chars[j]+".o") :));
      unguarded((: write_file, (SAVEPATH+chars[j]+".o"),
        save_variable(c_record)+"\n" :));
    }
    recent_cases -= ({recent_cases[i]});
  }
  recent_cases += ({ thing });
  save_new_cases();
  save_recent_cases();
}
mixed query_recent() {
  if(!recent_cases) {
    recent_cases = restore_variable(read_file(RECENT));
  }
  return recent_cases;
}
string query_recent_cases() {
  int i, j;
  string reports = "";
  for(i = 0; i < sizeof(recent_cases); i++) {
    if(i < 10) {
      reports += "   "+(i + 1)+": ";
    } else {
      reports += "  "+(i + 1)+": ";
    }
    reports += "%^CYAN%^Suspect%^RESET%^: "+capitalize(recent_cases[i][NAME]);
    for(j = 0; j < (12 - sizeof(recent_cases[i][NAME])); j++) {
      reports += " ";
    }
    reports += "%^CYAN%^Category%^RESET%^: "+recent_cases[i][CATEGORY]+"\n";
  }
  return reports;
}
string query_recent_case(int i) {
  string report = "";
  mixed *stuff;
  if(!recent_cases) {
    recent_cases = restore_variable(read_file(RECENT));
  }
  if(i < 1 || i > sizeof(recent_cases)) {
    return 0;
  }
  stuff = recent_cases[i - 1];
  report += "  %^CYAN%^Suspect%^RESET%^: "+capitalize(stuff[NAME])+"\n";
  if(!sizeof(stuff[CHARS])) {
    report += "  %^CYAN%^Other Characters%^RESET%^: Unknown.\n";
  } else {
    report += "  %^CYAN%^Other Characters%^RESET%^: "
      "$I$5="+query_multiple_short(stuff[CHARS])+"$I$0=\n";
  }
  report += "  %^CYAN%^Creator%^RESET%^: "+capitalize(stuff[CREATOR])+"\n"
    "  %^CYAN%^Time%^RESET%^: "+stuff[TIME]+"\n"
    "  %^CYAN%^Offence%^RESET%^: "+stuff[CATEGORY]+"\n"
    "  %^CYAN%^Report%^RESET%^: $I$5="+stuff[REPORT]+"$I$0="
    "  %^YELLOW%^High Lord%^RESET%^: "+stuff[HIGHLORD]+"\n"
    "  %^YELLOW%^High Lord Decision%^RESET%^: "+stuff[DECISION];
  for(i = 8; i < sizeof(stuff); i += 2) {
    report += "  %^YELLOW%^Comment from "+stuff[i]+"%^RESET%^: "
      +stuff[i + 1];
  }
  return report;
}
string case_history(string name) {
  int i, j;
  mixed *history, *cases, *stuff, *all_cases, *check_case;
  string report, *other_chars = ({ });
  history = get_dir(SAVEPATH+lower_case(name)+".o");
  all_cases = get_dir(SAVEPATH);
  all_cases -= ({"recent.o", "new.o"});
  for(i = 0; i < sizeof(all_cases); i++) {
    check_case = restore_variable(read_file((SAVEPATH+all_cases[i])));
    for(j = 0; j < sizeof(check_case); j++) {
      if(arrayp(check_case[j][CHARS])) {
        if(member_array(capitalize(name), check_case[j][CHARS]) != -1) {
          other_chars += check_case[j][CHARS];
          other_chars += ({check_case[j][NAME]});
        }
      }
    }
  }
  if(sizeof(other_chars)) {
    uniq_array(other_chars);
    for(i = 0; i < sizeof(other_chars); i++) {
      other_chars[i] = capitalize(other_chars[i]);
    }
    other_chars -= ({capitalize(name)});
    other_chars = uniq_array(other_chars);
    write(capitalize(name)+" is also "
      +query_multiple_short(other_chars)+".\n");
  }
  if(!sizeof(history)) {
    return 0;
  }
  write("%^CYAN%^Case History for "+capitalize(name)+"%^RESET%^:\n");
  report = "";
  cases = restore_variable(read_file(SAVEPATH+lower_case(name)+".o"));
  for(i = 0; i < sizeof(cases); i++) {
    stuff = cases[i];
    report += "  %^CYAN%^Suspect%^RESET%^: "+capitalize(stuff[NAME])+"\n";
    if(!sizeof(stuff[CHARS])) {
      report += "  %^CYAN%^Other Characters%^RESET%^: Unknown.\n";
    } else {
      report += "  %^CYAN%^Other Characters%^RESET%^: "
        "$I$5="+query_multiple_short(stuff[CHARS])+"$I$0=\n";
    }
    report +=  "  %^CYAN%^Creator%^RESET%^: "+capitalize(stuff[CREATOR])+"\n"
      "  %^CYAN%^Time%^RESET%^: "+stuff[TIME]+"\n"
      "  %^CYAN%^Offence%^RESET%^: "+stuff[CATEGORY]+"\n"
      "  %^CYAN%^Report%^RESET%^: $I$5="+stuff[REPORT]+"$I$0="
      "  %^YELLOW%^High Lord%^RESET%^: "+stuff[HIGHLORD]+"\n"
      "  %^YELLOW%^High Lord Decision%^RESET%^: "+stuff[DECISION];
    for(j = 8; j < sizeof(stuff); j += 2) {
      report += "  %^YELLOW%^Comment from "+stuff[j]+"%^RESET%^: "
        +stuff[j + 1];
    }
  }
  return report;
}
void add_comment(int i, string name, string comment) {
  i--;
  recent_cases[i] += ({ capitalize(name), comment });
  save_recent_cases();
}

==================================================
FILE: /lib/obj/handlers/room_handler.c
==================================================

#include <climate.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>
#include <room.h>
#include <weather.h>
#include <position.h>
#define CHATSIZE 80
#define DOORSIZE 60
mapping exit_types;
mapping door_types;
mapping opposite;
mixed *chatters, *doors;
void add_door( object thing );
void create() {
   seteuid( (string)"/secure/master"->
           creator_file( file_name( this_object() ) ) );
   exit_types = ([
"standard" :({ 0, 1,   400, 0 }),
"corridor" :({ 0, 1,   250, 0 }),
"plain"    :({ 0, 1, 10000, 0 }),
"door"     :({ 0, 1,   300, 0 }),
"stair"    :({ 0, 1,   300, 0 }),
"hidden"   :({ 0, 0,   300, 0 }),
"secret"   :({ 0, 0,   300, 0 }),
"gate"     :({ 0, 1,   450, 0 }),
"road"     :({ 0, 1,  1300, 0 }),
"path"     :({ 0, 1,   800, 0 }),
"window"   :({ "$N climb$s through a window.\n", 0, 75, 0 }),
]);
   door_types = ([
"door"      : ({ 0, 0, "generic_key", 2, 0, 0, "door" }),
"secret"    : ({ 0, 0, "generic_key", 3, 1, 0, "door" }),
"gate"      : ({ 1, 0, "generic_key", 1, 0, 1, "door" }),
"window"    : ({ 1, 0, "generic_key", 1, 0, 1, "window" }),
]);
   opposite = ([
"north" : ({ 0, "$R$[the ]+south$R$" }),
"south" : ({ 0, "$R$[the ]+north$R$" }),
"east" : ({ 0, "$R$[the ]+west$R$" }),
"west" : ({ 0, "$R$[the ]+east$R$" }),
"northeast" : ({ 0, "$R$[the ]+southwest$R$" }),
"southwest" : ({ 0, "$R$[the ]+northeast$R$" }),
"southeast" : ({ 0, "$R$[the ]+northwest$R$" }),
"northwest" : ({ 0, "$R$[the ]+southeast$R$" }),
"up":({0,"below"}), "down":({0,"above"}),
"out":({0,"inside"}), "in":({0,"outside"}),
"exit":({0,"inside"}), "enter":({0,"outside"}),
"hubward":({0,"rimward"}), "rimward":({0,"hubward"}),
"turnwise":({0,"widdershins"}),
"widdershins":({0,"turnwise"}) ]);
   chatters = allocate( CHATSIZE );
   doors = allocate( DOORSIZE );
   call_out( "housekeeping", 4 );
}
string query_opposite_direction(string dir) {
   if (opposite[dir]) {
      return opposite[dir][1];
   }
   return 0;
}
mixed *query_chatters() { return chatters; }
mixed *query_doors() { return doors; }
int add_exit_type(string type, mixed message, mixed obvious,
                            int size, mixed func) {
  if (exit_types[type]) {
    return 0;
  }
  exit_types[type] = ({ message, obvious, size, func });
  return 1;
}
int remove_exit_type(string type) {
   map_delete(exit_types, type);
   return 1;
}
mixed *query_door_type(string type, string direc, string dest) {
   if (!door_types[type]) {
      return 0;
   }
   call_out( "check_door", 1, ({ previous_object(), direc }) );
   return door_types[type];
}
void check_door( mixed args ) {
   string direc, dest;
   string door_name;
   if ( !args[ 0 ] ) {
      return;
   }
   args[ 0 ]->set_destination( args[ 1 ] );
   dest = (string)args[ 0 ]->query_destination( args[ 1 ] );
   if ( !dest ) {
      tell_room( args[ 0 ], "Error: "+ args[ 1 ] +
            " is no longer an exit.\n" );
      return;
   }
   if ( !find_object( dest ) ) {
      return;
   }
   door_name = args[0]->call_door(args[1], "query_door_name");
   direc = (string)dest->query_door( args[ 0 ], door_name );
   if ( !direc &&
       !args[ 0 ]->call_door( args[ 1 ], "query_one_way" ) ) {
      tell_room( args[ 0 ], "Error: "+ dest +
                "does not have a door coming back here.\n" );
      return;
   }
   args[ 0 ]->modify_exit( args[ 1 ], ({ "other", direc }) );
   args[ 0 ]->modify_exit( args[ 1 ], ({
      "closed", (int)dest->call_door( direc, "query_closed" ),
      "locked", (int)dest->call_door( direc, "query_locked" ) }) );
   if ( !args[ 0 ]->call_door( args[ 1 ], "query_closed" ) &&
       ( (string)args[ 0 ]->query_property( "location" ) == "outside" ) ) {
      add_door( (object)args[ 0 ]->query_door_control( args[ 1 ], door_name ) );
   }
}
mixed *query_exit_type(string type, string dir) {
  mixed s;
   if (!(s = opposite[dir])) {
      s = ({ 0, "elsewhere" });
   }
   if (!exit_types[type]) {
      return exit_types["standard"] + ({ s, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
   }
   return exit_types[ type ] + ({ s, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
}
int move_thing( object thing, string dir, string dest, mixed exit,
                mixed enter, string move ) {
  int ret;
  string arrive, leave;
  object dragging;
  dragging = (object)thing->query_dragging();
  if (dragging && environment(dragging) != environment(thing)) {
    thing->reset_dragging();
    dragging = 0;
  }
  if ( ( exit != "none" ) || objectp( dragging ) ) {
    if ( stringp( enter ) )
      enter = ({ 1, enter });
    else if ( functionp(enter) )
      enter = ({ 1, evaluate(enter, thing) });
    else if ( !pointerp( enter ) )
      enter = ({ 0, "somewhere" });
    switch ( enter[ 0 ] ) {
    case 0 :
      arrive = replace( (string)thing->query_msgin(),
                        ({"$F", enter[ 1 ],
                          "$r", thing->query_pronoun() }) );
      break;
    default :
      arrive = enter[ 1 ];
    }
    if ( stringp( exit) )
      leave = exit;
    else if ( functionp( exit ) )
      leave = evaluate(exit, thing);
    else if ( pointerp( exit ) )
      leave = exit[ 0 ];
    else
      leave = (string)thing->query_msgout();
    leave = replace( leave, ({"$T", "$R$-"+ dir +"$R$",
                              "$r", thing->query_pronoun() }) );
  }
  thing->return_to_default_position(1);
  if ( arrive || objectp( dragging ) ) {
    thing->remove_hide_invis( "hiding" );
    if ( stringp( arrive ) && objectp( dragging ) ) {
      arrive += "\n$C$"+ (string)thing->query_pronoun() +" drags "+
        (string)dragging->a_short() +" in behind "+
        (string)thing->query_objective() +".";
    }
    if ( stringp( leave ) && objectp( dragging ) ) {
      leave += "\n$C$"+ (string)thing->query_pronoun() +" drags "+
        (string)dragging->the_short() +" away behind "+
        (string)thing->query_objective() +".";
    }
    if ( stringp( move ) ) {
      tell_object( thing, move );
    }
    ret = (int)thing->move( dest, arrive, leave );
    if ( ( ret == MOVE_OK ) && objectp( dragging ) ) {
      if(dragging->move(environment(thing)) == MOVE_OK) {
        tell_object( thing, "You drag "+
                     (string)dragging->the_short() +" behind you.\n" );
        thing->adjust_time_left( -DEFAULT_TIME );
      } else {
        tell_object( thing, "You fail to drag "+
                     (string)dragging->the_short() +" behind you.\n" );
      }
    }
  } else {
    if ( stringp( move ) ) {
      tell_object( thing, move );
    }
    ret = (int)thing->move( dest );
  }
  if ( ret == MOVE_OK ) {
    thing->adjust_time_left( -DEFAULT_TIME );
    return 1;
  }
  return 0;
}
int exit_move_door_checks(object thing, mixed closed) {
  closed->force_other();
  if(closed->query_open())
    return 1;
  if(thing->query_property( "demon" ) || thing->query_property("dead")) {
    tell_object(thing, "You ghost through "+(string)closed->the_short()+
                ".\n");
    return 1;
  }
  if(thing->query_weight() < 300)
    return 0;
  if(closed->query_locked() && !closed->moving_unlock(thing)) {
    if(!closed->query_visible(thing)) {
      return 0;
    }
    tell_object(thing, (string)closed->the_short() +
                ({ " is ", " are " })[(int)closed->query_how_many()] +
                "locked.\n");
    return notify_fail("");
  }
  if(!closed->moving_open(thing)) {
    return 0;
  }
  return 1;
}
int exit_move_func_checks(string verb, string special, object thing,
                          mixed func, object place) {
  if(stringp(func))
    return call_other(place, func, verb, thing, special);
  if(functionp(func))
    return evaluate(func, verb, thing, special);
  if(pointerp(func) && sizeof(func) > 1 && func[0] && func[1])
    return call_other(func[0], func[1], verb, thing, special);
  return 1;
}
int exit_move( string verb, string extra, mixed special, object thing ) {
   string leave;
   object place;
   object follower;
   object *okay;
   mixed closed;
   int locked;
   mixed func;
   mixed *dest_other;
   object *all_followers;
   object *tmp_followers;
   object *more_followers;
   place = environment( thing );
   verb = (string)place->expand_alias( verb );
   place->set_destination( verb );
   dest_other = (mixed *)place->query_dest_other( verb );
   if (!pointerp(dest_other))
      return 0;
   if(thing->cannot_walk( verb, dest_other ))
      return notify_fail( "" );
   closed = (object)place->query_door_control( verb );
   if(objectp(closed)) {
     closed->force_other();
     if(!closed)
       closed = (object)place->query_door_control( verb );
   }
   if (!interactive(thing) && living(thing)
         && sizeof(dest_other) > ROOM_NPC_STOP && dest_other[ROOM_NPC_STOP])
      return 0;
   if (objectp(closed)) {
      locked = closed->query_locked();
   }
   if(objectp(closed) && closed->query_open()) {
     closed = 0;
   }
   if(objectp(closed) && !exit_move_door_checks(thing, closed)) {
     return 0;
   }
   if ( place->block_exit_move( verb, thing ) ) {
     return notify_fail( "" );
   }
   func = dest_other[ROOM_FUNC];
   if(func && !thing->query_property( "demon" ) &&
      !exit_move_func_checks(verb, special, thing, func, place))
     return 0;
   if ( place->query_relative( verb ) )
     leave = (string)thing->find_rel( verb, 0 );
   else
     leave = verb;
   if((int)thing->query_height() > dest_other[ ROOM_SIZE ] &&
      !(thing->query_crawling() &&
        (int)thing->query_height()/3 <= dest_other[ ROOM_SIZE ])) {
     tell_object( thing, "You are too tall to go that way.\n" );
     return notify_fail( "" );
   }
   if ( !stringp( special ) ) {
      special = dest_other[ ROOM_EXIT ];
   }
   if ( !move_thing( thing, verb, dest_other[ ROOM_DEST ], special,
                     dest_other[ ROOM_ENTER ], dest_other[ ROOM_MESS ] ) ) {
     return 0;
   }
   thing->return_to_default_position(1);
   okay = ({ });
   if (place) {
     all_followers = thing->query_followers();
     more_followers = all_followers;
     do {
       tmp_followers = ({ });
       foreach (follower in more_followers) {
         if (follower &&
             environment( follower ) == place ) {
           tmp_followers |= follower->query_followers();
         }
       }
       more_followers = tmp_followers - all_followers;
       all_followers |= tmp_followers;
     } while (sizeof(more_followers));
     foreach ( follower in all_followers) {
       if ( !objectp( follower ) ) {
         thing->remove_follower( follower );
         continue;
       }
       if(environment(follower) != place ||
          (userp(follower) && !interactive(follower)) ||
          (!thing->query_visible(follower) || (special == "none")) ||
          follower->query_property( PASSED_OUT) ||
          follower->cannot_walk( verb, dest_other ))
         continue;
       if(objectp(closed) && !exit_move_door_checks(follower, closed))
         continue;
       if ( func && !follower->query_property( "demon" ) &&
            !exit_move_func_checks(verb, special, follower, func, place))
         continue;
       if (!interactive(follower) && living(follower)
           && sizeof(dest_other) > ROOM_NPC_STOP && dest_other[ROOM_NPC_STOP])
         continue;
       if ( place->query_relative( verb ) ) {
         leave = (string)follower->find_rel( verb, 0 );
         follower->reorient_rel( leave );
       } else {
         leave = verb;
         follower->reorient_abs( leave );
       }
       if ( (int)follower->query_height() > dest_other[ ROOM_SIZE ] ) {
         tell_object( follower, "You are too tall to follow "+
                      (string)thing->the_short() +" "+ leave +".\n" );
         continue;
       }
       if (function_exists("check_doing_follow", follower) &&
           !follower->check_doing_follow(thing, verb, special)) {
         continue;
       }
       if(move_thing( follower, verb, dest_other[ROOM_DEST], special,
                      dest_other[ROOM_ENTER], dest_other[ROOM_MESS]) &&
          living(follower)) {
         tell_object(follower, "You follow "+ (string)thing->the_short() +
                     " "+ leave +".\n");
         if(follower->query_visible(thing))
           okay += ({ follower });
         follower->return_to_default_position(1);
       } else {
         tell_object( follower, "You fail to follow "+
                      (string)thing->the_short() +" "+ leave +".\n" );
       }
     }
   }
   thing->room_look();
   if(sizeof(okay)) {
     okay->room_look();
     tell_object(thing, query_multiple_short(okay) +
                 " $V$0=follows,follow$V$ you.\n" );
   }
   if(objectp(closed)) {
      closed->moving_close(thing);
      if (locked)
        closed->moving_lock(thing);
   }
   return 1;
}
void housekeeping() {
   call_out( "check_chatters", 1 );
   call_out( "check_doors", 2 );
   call_out( "housekeeping", 4 );
}
void add_chatter(object thing, int number) {
   number /= 4;
   if ( number > CHATSIZE - 1 )
      number = CHATSIZE - 1;
   if ( !pointerp( chatters[ number ] ) )
      chatters[ number ] = ({ thing });
   else
      chatters[ number ] += ({ thing });
}
void check_chatters() {
   object thing, *things;
   things = chatters[ 0 ];
   chatters[ 0 .. <2 ] = chatters[ 1 .. <1 ];
   chatters[ <1 ] = 0;
   if ( !pointerp( things ) )
      return;
   foreach ( thing in things ) {
      if ( objectp( thing ) )
         thing->make_chat();
   }
}
void add_door( object thing ) {
   int number;
   number = random( DOORSIZE );
   if ( !pointerp( doors[ number ] ) )
      doors[ number ] = ({ thing });
   else
      doors[ number ] += ({ thing });
}
void check_doors() {
   int wind;
   string dest, other, mess;
   object mine, thing, *things;
   things = doors[ 0 ];
   doors[ 0 .. <2 ] = doors[ 1 .. <1 ];
   doors[ <1 ] = 0;
   if ( !pointerp( things ) )
      return;
   foreach ( thing in things ) {
      if ( !objectp( thing ) )
         continue;
      if ( thing->query_closed() )
         continue;
      if(thing->query_stuck())
         continue;
      dest = (string)thing->query_dest();
      other = (string)thing->query_other_id();
      mine = (object)thing->query_my_room();
      wind = (int)WEATHER->calc_actual( mine, WINDSP );
      if ( random( 25 ) > wind ) {
         add_door( thing );
         return;
      }
      switch ( wind ) {
       case -1000 .. 20 :
         mess = "blow$s shut in the breeze.\n";
         break;
       case 21 .. 40 :
         mess = "blow$s shut in the wind.\n";
         break;
       default :
         mess = "slam$s shut in the wind.\n";
      }
      if ( find_object( dest ) ) {
         dest->modify_exit( other, ({ "closed", 1 }) );
         if(thing->query_autolock())
           dest->modify_exit(other, ({ "locked", 1 }));
         dest->tell_door( other, "The $D "+ mess, 0 );
      }
      thing->set_closed( 1 );
      if(thing->query_autolock())
        thing->set_locked();
      thing->tell_door( "The $D "+ mess, 0 );
   }
}
mapping query_dynamic_auto_load() {
   mapping tmp;
   tmp = ([ "exit_types" : exit_types,
            "door_types" : door_types,
            "opposite" : opposite,
            "chatters" : chatters,
            "doors" : doors,
          ]);
   return tmp;
}
void init_dynamic_arg(mapping maps) {
   if (maps["exit_types"])
      exit_types = maps["exit_types"];
   if (maps["door_types"])
      door_types = maps["door_types"];
   if (maps["opposite"])
      opposite = maps["opposite"];
   if (maps["chatters"])
      chatters = maps["chatters"];
   if (maps["doors"])
      doors = maps["doors"];
}
mixed *stats() {
   int door_count, chatter_count;
   mixed temp;
   foreach (temp in chatters)
      chatter_count += sizeof( temp );
   foreach (temp in doors)
      door_count += sizeof( temp );
   return ({
      ({ "exit types", sizeof( exit_types ) }),
      ({ "door types", sizeof( door_types ) }),
      ({ "opposites",  sizeof( opposite ) }),
      ({ "chatters",  chatter_count }),
      ({ "doors", door_count }),
   });
}

==================================================
FILE: /lib/obj/handlers/room_rental.c
==================================================

#include <money.h>
#include <room/room_rental.h>
protected void do_load();
protected void do_save();
protected void evict_tenant( object room_ob );
private nosave int loaded = 0;
private mapping rented_rooms = ([]);
private mapping rental = ([]);
private mapping eviction_times = ([]);
private mapping locations = ([]);
private mapping paths = ([]);
void create() {
  do_load();
}
void reset() {
   string room;
   int now = time();
   foreach( room in keys( rented_rooms ) ) {
      if ( stringp( rented_rooms[ room ] ) ) {
         if ( ( eviction_times[ room ] < now ) &&
              ( eviction_times[ room ] > -1 ) ) {
            evict_tenant( find_object( room ) );
            tell_creator( "goldenthread", "RENTAL: %s no longer rents %s\n",
                          rented_rooms[ room ], room );
            rented_rooms[ room ] = 0;
            eviction_times[ room ] = -1;
         }
      }
   }
   do_save();
}
protected void do_load() {
   if ( !loaded )
      unguarded( (: restore_object( ROOM_RENTAL_SAVE_FILE, 1 ) :) );
   loaded = 1;
}
protected void do_save() {
   unguarded( (: save_object( ROOM_RENTAL_SAVE_FILE , 0 ) :) );
}
void evict_tenant( object room_ob ) {
   object *occupants;
   occupants = filter( all_inventory( room_ob ), (: living :) );
   room_ob->evict_tenant( occupants );
}
int add_room( string room, int cost, object office ) {
   object room_ob;
   if( !room_ob = load_object( room ) )
      return 0;
   rented_rooms[ room ] = 0;
   rental[ room ] = cost;
   eviction_times[ room ] = -1;
   locations[ room ] = office->query_location();
   paths[ room_ob->short() ] = room;
   do_save();
   return 1;
}
string query_who_rents( string room, object office ) {
   if ( locations[room] == office->query_location() ) {
      if ( stringp( rented_rooms[room] ) )
         return rented_rooms[room];
      else
         return "nobody";
   } else
      return "no such room in this location";
}
int check_tenant( object player_ob, object room_ob, object office ) {
   string player = player_ob->short();
   string room = room_ob->short();
   if ( player == query_who_rents( room, office ) )
      return RENTAL_SUCCESS;
   else if ( player == "nobody" )
      return RENTAL_AVAILABLE;
   else if ( player == "no such room!" )
      return RENTAL_NO_SUCH_ROOM;
   else
      return RENTAL_ALREADY_RENTED;
}
int delete_room( string room, object office ) {
  string room_short = load_object( room )->short();
  if ( locations[room] == office->query_location() ) {
    map_delete( rented_rooms, room );
    map_delete( rental, room );
    map_delete( eviction_times, room );
    map_delete( locations, room );
    map_delete( paths, room_short );
    do_save();
    return 1;
  } else
    return 0;
}
int clear_rooms( object office ) {
   object room_ob;
   foreach( string room in keys( filter( locations,
            (: $2 == $( office->query_location() ) :) ) ) ) {
      room_ob = load_object( room );
    map_delete( rented_rooms, room );
    map_delete( rental, room );
    map_delete( eviction_times, room );
    map_delete( locations, room );
    map_delete( paths, room_ob->query_short() );
  }
  do_save();
  return 1;
}
string *query_rooms_to_rent( object office ) {
  return keys( filter( locations,
               (: $2 == $( office->query_location() ) :) ) );
}
int do_rental( object player_ob, string room_short, object office ) {
   int result;
   string domain = office->query_domain();
   string room = paths[ room_short ];
   if ( locations[room] == office->query_location() ) {
      if ( !rented_rooms[room] ||
           ( rented_rooms[room] == player_ob->short()) ) {
         if ( (int)player_ob->query_value_in( domain ) < rental[room] )
            return RENTAL_NO_MONEY;
         rented_rooms[room] = player_ob->short();
         eviction_times[room] = time() + ONE_DAY;
         result = RENTAL_SUCCESS;
      } else
         result = RENTAL_ALREADY_RENTED;
   } else
      result = RENTAL_NO_SUCH_ROOM;
   do_save();
   return result;
}
int query_rental_value( string room ) {
   return rental[ room ];
}
int remove_rental( object room_ob ) {
   int result;
   string room_short = room_ob->short();
   string room = paths[ room_short ];
   if ( !undefinedp( rented_rooms[room] ) ) {
      rented_rooms[room] = 0;
      result = RENTAL_SUCCESS;
   } else
      result = RENTAL_NO_SUCH_ROOM;
   do_save();
   return result;
}

==================================================
FILE: /lib/obj/handlers/route_handler.c
==================================================

int use_count;
varargs void get_route(string end, string start, function call_back, int count) {
  string *result;
  if(start == "/room/virtual"){
    call_out((: evaluate($(call_back), ({ })) :), 1);
    return;
  }
  if(!(stringp(start) && stringp(end)))
    error("illegal argument 1 or 2 to get_route");
  if(!function_owner(call_back))
    return;
  if ((end == start) || (count > 3)){
    call_out((: evaluate($(call_back), ({ })) :), 1);
    if(end != start)
      log_file("ROUTEHANDLER","route for %s from %s to %s failed\n",
               file_name(function_owner(call_back)), start, end);
    return;
  }
  result = "/obj/handlers/clusters"->get_route(start, end);
  if(!result){
    call_out((:get_route($(end), $(start), $(call_back), $(count + 1)):), 10);
    return;
  }
  use_count++;
  call_out((: evaluate($(call_back), $(result)) :), 1);
  return;
}
void dest_me() {
  destruct(this_object());
}
mixed *stats() {
  return  ({
    ({ "routes done", use_count }),
  });
}

==================================================
FILE: /lib/obj/handlers/script_processor.c
==================================================

#define RATIO 20
inherit "/std/object";
string stage;
mapping actors;
void setup() {
   actors = ([ ]);
}
string query_stage() { return stage; }
void set_stage( string word ) { stage = word; }
mapping query_actors() { return actors; }
string query_actor( string word ) { return actors[ word ]; }
void set_actor( string name, string path ) { actors[ name ] = path; }
int perform_line( string script, int line ) {
   int length;
   string action, name, text;
   object actor;
   length = file_length( script );
   if ( length < 1 ) {
      write( "Length of file \""+ script +"\" is "+ length +".\n" );
      return -1;
   }
   if ( length < line )
      return -1;
   if ( !stage || ( stage == "" ) )
      return -2;
   text = read_file( script, line, 1 );
   if ( sscanf( text, "%s=%s\n", name, action ) == 2 ) {
      if ( !actors[ name ] )
         return -3;
      actor = find_object( actors[ name ] );
      if ( !actor )
         return -4;
      actor->do_command( action );
   } else {
      actor = find_object( stage );
      if ( !actor )
         return -4;
      tell_room( actor, text );
   }
   if ( length == line )
      return -5;
   return strlen( text ) / RATIO;
}
void perform_script( string script, int line ) {
   int next;
   next = perform_line( script, line );
   if ( next < 0 ) {
      if ( find_object( stage ) )
         stage->script_ended( next );
      return;
   }
   call_out( "perform_script", 2 + next, script, line + 1 );
}
int start_script( string script ) {
   if ( find_call_out( "perform_script" ) != -1 )
      return 0;
   call_out( "perform_script", 3, script, 1 );
   return 1;
}

==================================================
FILE: /lib/obj/handlers/snmp_handler.c
==================================================

#include "snmp.h"
void create()
{
}
buffer BufferiseInt(int p)
{
  buffer buf1;
  buf1=allocate_buffer(4);
  if(p<0)
  {
    buf1[0]=(4294967296+p)/16777216;
  } else {
    buf1[0]=p/16777216;
  }
  buf1[1]=p/65536;
  buf1[2]=p/256;
  buf1[3]=p%256;
  return buf1;
}
buffer GetData(buffer MIB)
{
  int i,j,k;
  object *tmp;
  buffer mibreply,mibdata,tmpbuf;
  mibreply=allocate_buffer(4);
  tmpbuf=allocate_buffer(1);
  mibreply[0]=48;
  mibreply[1]=0;
  mibreply[2]=OBJECT_IDENT;
  mibreply[3]=0;
  mibreply+=MIB;
  i=sizeof(mibreply);
  switch(MIB[6])
  {
    case 101 :
      j=sizeof(users());
      tmpbuf[0]=2;
      mibreply+=tmpbuf;
      tmpbuf[0]=0;
      mibreply+=tmpbuf;
      tmpbuf=BufferiseInt(j);
      mibreply+=tmpbuf;
      mibreply[i+1]=sizeof(tmpbuf);
      break;
    case 102 :
      j=0;
      tmp=users();
      for(k=0;k<sizeof(tmp);k++)
        if(tmp[k] && (tmp[k])->query_creator())
          j++;
      tmpbuf[0]=2;
      mibreply+=tmpbuf;
      tmpbuf[0]=0;
      mibreply+=tmpbuf;
      tmpbuf=BufferiseInt(j);
      mibreply+=tmpbuf;
      mibreply[i+1]=sizeof(tmpbuf);
      break;
    case 100 :
      tmpbuf[0]=2;
      mibreply+=tmpbuf;
      tmpbuf[0]=1;
      mibreply+=tmpbuf;
      tmpbuf[0]=0;
      mibreply+=tmpbuf;
      break;
    default :
      mibreply[0]=255;
      break;
  }
  mibreply[1]=sizeof(mibreply)-2;
  mibreply[3]=sizeof(MIB);
  return mibreply;
}

==================================================
FILE: /lib/obj/handlers/soul_compiler.c
==================================================

#include "soul.h"
#include "user_parser.h"
private nosave string _current_file;
private nosave int _current_line;
private nosave int _file_len;
private nosave int _depth;
private nosave int _look_for;
private nosave int _last_chunk_compile;
private nosave mixed *_to_compile;
private nosave mixed *_arguments;
private nosave object _current_player;
void start_compile();
void parse_chunk(string chunk);
void make_into_soul_commands(mapping commands);
#define CHUNK_SIZE 20
#define OPEN_BRACKET 1
#define START_ARGUMENT 2
#define END_BRACKET 3
#define END_STRING 4
#define ARGUMENT_VALUE 5
#define ARGUMENT_NAME 6
#define REST_OF_ARGUMENT 7
void create() {
   _to_compile = ({ });
   seteuid("Root");
}
int test_security(string fname) {
   return 1;
}
void notify(string mess) {
   if (_current_player)
      tell_object(_current_player, mess);
}
void compile_file(string fname) {
   if (file_size(SOUL_DIR+fname) == -1) {
      tell_object(this_player(), "The file "+
                         SOUL_DIR+fname+" does not exist.\n");
      return ;
   }
   if (file_size(SOUL_DIR+fname) == -2) {
      tell_object(this_player(), "The file "+
                         SOUL_DIR+fname+" is a directory exist.\n");
      return ;
   }
   _to_compile += ({ SOUL_DIR+fname, this_player() });
   start_compile();
}
void compile_directory(string fname) {
   string *bits, start;
   int i;
   if (file_size(SOUL_DIR+fname) != -2) {
      tell_object(this_player(), "The file "+
                         fname+" is not a directory exist.\n");
      return ;
   }
   bits = explode(fname, "/");
   start = implode(bits[0..<1], "/");
   if (start != "") {
      start += "/";
   }
   fname = SOUL_DIR+fname;
   if (fname[<1] == '/') {
      fname += "*.s";
   } else {
      fname += "
void start_compile() {
   if ((_current_file || !sizeof(_to_compile)) &&
       (time() - _last_chunk_compile) > 10) {
      return ;
   }
   write("Starting to compile " + _to_compile[0] + "\n");
   _current_file = _to_compile[0];
   _current_player = _to_compile[1];
   _to_compile = _to_compile[2..];
   _current_line = 1;
   _depth = 0;
   _look_for = OPEN_BRACKET;
   _file_len = file_length(_current_file);
   _arguments = ({ 0, ([ ]) });
   call_out("compile_chunk", 2);
}
void compile_chunk() {
   string chunk;
   int end;
   _last_chunk_compile = time();
   if (_current_line+CHUNK_SIZE > _file_len) {
      end = _file_len+1;
   } else {
      end = _current_line+CHUNK_SIZE;
   }
   chunk = unguarded((: read_file, _current_file, _current_line,
                               end-_current_line :));
   _current_line = end;
   parse_chunk(chunk);
   if (end > _file_len) {
      call_out("start_compile", 2);
      _current_file = 0;
      make_into_soul_commands(_arguments[1]);
   } else {
      call_out("compile_chunk", 2);
   }
}
void parse_chunk(string chunk) {
   string *bits, s1, s2;
   int pos, chunk_size, start;
   chunk_size = strlen(chunk);
   pos = 0;
   bits = explode(chunk, "(");
   while (pos < chunk_size) {
      switch (_look_for) {
         case OPEN_BRACKET :
            if (sscanf(chunk[pos..], "%s(%s", s1, s2)) {
               chunk = s2;
               chunk_size = strlen(chunk);
               pos = 0;
               _depth++;
               _arguments += ({ 0, 0 });
               _look_for = ARGUMENT_NAME;
            } else {
               pos = chunk_size;
            }
            break;
         case ARGUMENT_NAME :
            while (pos < chunk_size && (chunk[pos] == ' ' ||
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos == chunk_size) {
               break;
            }
            start = pos;
            while (pos < chunk_size && chunk[pos] != ' ' &&
                      chunk[pos] != '\t' && chunk[pos] != '\n') {
               pos++;
            }
            _arguments[_depth*2] = chunk[start..pos-1];
            _look_for = ARGUMENT_VALUE;
            break;
         case ARGUMENT_VALUE :
            while (pos < chunk_size && (chunk[pos] == ' ' ||
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos >= chunk_size) {
               break;
            }
            switch (chunk[pos]) {
               case '(' :
                  _arguments[_depth*2+1] = ([ ]);
                  _depth++;
                  _arguments += ({ 0, 0 });
                  _look_for = ARGUMENT_NAME;
                  pos++;
                  break;
               case '"' :
                  _arguments[_depth*2+1] = "";
                  _look_for = END_STRING;
                  pos++;
                  break;
               default :
                  start = pos;
                  if (sscanf(chunk[pos..], "%s)%s", s1, s2) == 2) {
                     _arguments[_depth*2+1] = replace(implode(explode(replace(s1,
                            ({ "\n", " ", "\r", "" })), " ")-({ "" }), " "), ", ", ",");
                     pos = 0;
                     chunk = ")"+s2;
                     _look_for = END_BRACKET;
                  } else {
                     _arguments[_depth*2+1] = chunk[pos..];
                     _look_for = REST_OF_ARGUMENT;
                     pos = 0;
                     chunk = "";
                  }
                  chunk_size = strlen(chunk);
                  break;
            }
            break;
         case REST_OF_ARGUMENT :
            if (sscanf(chunk[pos..], "%s)%s", s1, s2) == 2) {
               _arguments[_depth*2+1] = replace(implode(explode(
                                                    replace(_arguments[_depth*2+1]+s1, "\n", " "),
                                                                         " ") - ({ "" }),
                                                             " "), ", ", ",");
               pos = 0;
               chunk = ")"+s2;
               _look_for = END_BRACKET;
            } else {
               _arguments[_depth*2+1] += chunk[pos..];
               pos = 0;
               chunk = "";
            }
            chunk_size = strlen(chunk);
            break;
         case END_BRACKET :
            if (sscanf(chunk[pos..], "%s)%s", s1, s2)) {
               switch (_depth) {
                  case 2 :
                  case 3 :
                     if (pointerp(_arguments[_depth*2-1][_arguments[_depth*2]]))
                        _arguments[_depth*2-1][_arguments[_depth*2]] += ({ _arguments[_depth*2+1] });
                     else
                        _arguments[_depth*2-1][_arguments[_depth*2]] = ({ _arguments[_depth*2+1] });
                     break;
                  case 1 :
                  case 4 :
                  case 5 :
                  case 6 :
                  case 7 :
                     _arguments[_depth*2-1][_arguments[_depth*2]] = _arguments[_depth*2+1];
                     break;
               }
               chunk = s2;
               chunk_size = strlen(s2);
               _depth--;
               pos = 0;
               _arguments = _arguments[0.._depth*2+1];
               if (_depth) {
                  _look_for = START_ARGUMENT;
               } else {
                  _look_for = OPEN_BRACKET;
               }
            }
            break;
         case START_ARGUMENT :
            while (pos < chunk_size && (chunk[pos] == ' '
                   || chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos >= chunk_size) {
               break;
            }
            switch (chunk[pos]) {
               case ')' :
                  _look_for = END_BRACKET;
                  break;
               case '(' :
                  _look_for = OPEN_BRACKET;
                  break;
               default :
                  if (!sscanf(chunk[pos..], "%s\n%s", s1, s2)) {
                     s1 = chunk;
                  }
                  printf("Syntax error in file %s, near %s\n", _current_file, s1);
                  _look_for = END_BRACKET;
                  break;
            }
            break;
         case END_STRING :
            if (sscanf(chunk[pos..], "%s\"%s", s1, s2)) {
               if (strlen(s1) > 0 && s1[strlen(s1)-1] == '\\') {
                  _arguments[_depth*2+1] += replace(s1[0..strlen(s1)-2], "\n", "")+"\"";
                  chunk = s2;
                  pos = 0;
                  chunk_size = strlen(s2);
               } else {
                  _arguments[_depth*2+1] += replace(s1, "\n", "");
                  _look_for = END_BRACKET;
                  chunk = s2;
                  pos = 0;
                  chunk_size = strlen(s2);
               }
            } else {
               _arguments[_depth*2+1] += replace(chunk, "\n", "");
               pos = chunk_size;
            }
            break;
         default :
            notify("Horrible error "+_look_for+"\n");
            pos = chunk_size;
            break;
      }
   }
}
int check_sort(string pat1, string pat2) {
   int lvl1, lvl2;
   lvl1 = ((mixed *)PATTERN_OB->compile_pattern(pat1))[0];
   lvl2 = ((mixed *)PATTERN_OB->compile_pattern(pat2))[0];
   return lvl2-lvl1;
}
string *sort_patterns(string *inp) {
   if (!pointerp(inp)) {
      printf("%O\n", inp);
      return ({ });
   }
   return sort_array(inp, "check_sort", this_object());
}
void make_into_soul_commands(mapping comms) {
   string *fluff;
   int i, failed, j;
   mapping ret, tmp;
   fluff = keys(comms);
   ret = ([ ]);
   for (i=0;i<sizeof(fluff);i++) {
      ret[fluff[i]] = ({ comms[fluff[i]]["pattern"], 0, 0 });
      if (comms[fluff[i]]["single"]) {
         if (comms[fluff[i]]["single"][0]["no-arguments"]) {
            tmp = comms[fluff[i]]["single"][0]["no-arguments"][0];
            if (!tmp["self"]) {
               notify("The 'self' type is missing in the no-argument, single for the soul command "+fluff[i]+"\n");
               failed = 1;
            } else if (!tmp["rest"]) {
               notify("The 'rest' type is missing in the no-argument, single for the soul command "+fluff[i]+"\n");
               failed = 1;
            } else {
               ret[fluff[i]][SINGLE] = ({ ({ tmp["self"], tmp["rest"],
                                                            tmp["position"] }),
                                                         0 });
            }
         }
         if (comms[fluff[i]]["single"][0]["arguments"]) {
            j = sizeof(comms[fluff[i]]["single"][0]["arguments"]);
            if (!ret[fluff[i]][SINGLE]) {
               ret[fluff[i]][SINGLE] = ({ 0, allocate(j*SMALL_ARG_SIZE) });
            } else {
               ret[fluff[i]][SINGLE][ARGUMENTS] = allocate(j*SMALL_ARG_SIZE);
            }
            for (j=0;j<sizeof(comms[fluff[i]]["single"][0]["arguments"]);j++) {
               tmp = comms[fluff[i]]["single"][0]["arguments"][j];
               if (!mapp(tmp)) {
                  notify("The soul command "+fluff[i]+" is totaly stuffed.\n");
                  failed = 1;
               } else if (!tmp["self"]) {
                  notify("The 'self' type is missing in the argument, single for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else if (!tmp["rest"]) {
                  notify("The 'rest' type is missing in the argument, single for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else if (!tmp["arguments"]) {
                  notify("The 'arguments' type is missing in the argument, single for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else {
                  ret[fluff[i]][SINGLE][ARGUMENTS][j*SMALL_ARG_SIZE+SELF] = tmp["self"];
                  ret[fluff[i]][SINGLE][ARGUMENTS][j*SMALL_ARG_SIZE+REST] = tmp["rest"];
                  ret[fluff[i]][SINGLE][ARGUMENTS][j*SMALL_ARG_SIZE+ARGS] = explode(tmp["arguments"], ",");
                  ret[fluff[i]][SINGLE][ARGUMENTS][j*SMALL_ARG_SIZE+POSITION_SINGLE] = tmp["position"];
               }
            }
         }
      }
      if (comms[fluff[i]]["targeted"]) {
         if (comms[fluff[i]]["targeted"][0]["no-arguments"]) {
            tmp = comms[fluff[i]]["targeted"][0]["no-arguments"][0];
            if (!tmp["self"]) {
               notify("The 'self' type is missing in the no-argument, target for the soul command "+fluff[i]+"\n");
               failed = 1;
            } else if (!tmp["rest"]) {
               notify("The 'rest' type is missing in the no-argument, target for the soul command "+fluff[i]+"\n");
               failed = 1;
            } else {
               ret[fluff[i]][TARGET] = ({ ({ tmp["self"], tmp["rest"],
                                     tmp["target"], 0, tmp["force"], tmp["position"] }),
                                                         0 });
            }
         }
         if (comms[fluff[i]]["targeted"][0]["arguments"]) {
            j = sizeof(comms[fluff[i]]["targeted"][0]["arguments"]);
            if (!ret[fluff[i]][TARGET])
               ret[fluff[i]][TARGET] = ({ 0, allocate(j*ARG_SIZE) });
            else
               ret[fluff[i]][TARGET][ARGUMENTS] = allocate(j*ARG_SIZE);
            for (j=0;j<sizeof(comms[fluff[i]]["targeted"][0]["arguments"]);j++) {
               tmp = comms[fluff[i]]["targeted"][0]["arguments"][j];
               if (!tmp["self"]) {
                  notify("The 'self' type is missing in the argument, target for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else if (!tmp["rest"]) {
                  notify("The 'rest' type is missing in the argument, target for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else if (!tmp["arguments"]) {
                  notify("The 'arguments' type is missing in the argument, target for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else {
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+SELF] = tmp["self"];
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+REST] = tmp["rest"];
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+TARG] = tmp["target"];
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+ARGS] = explode(tmp["arguments"], ",");
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+FORCE] = tmp["force"];
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+POSITION] = tmp["position"];
               }
            }
         }
      }
   }
   fluff = keys(ret);
   for (i=0;i<sizeof(fluff);i++) {
      ret[fluff[i]][PATTERNS] = sort_patterns(ret[fluff[i]][PATTERNS]);
      SOUL_OBJECT->add_soul_command(fluff[i], ret[fluff[i]]);
      notify("Added soul command "+fluff[i]+".\n");
   }
}
void blue() {
   printf("%O\n", sort_patterns(({ "[at] <indirect:object>", "<string>" })));
}

==================================================
FILE: /lib/obj/handlers/start_positions.c
==================================================

#include <login_handler.h>
#define SAVE_FILE "/save/start_position_handler"
#define CHECKED_PROP "checked start positions"
private int _last_added;
private string * _buggy_starts;
void load_file() {
   if ( file_size( SAVE_FILE + ".o" ) > 0 ||
        file_size( SAVE_FILE + ".o.gz" ) > 0 )
   {
      unguarded( (: restore_object, SAVE_FILE :) );
   }
}
void save_file() {
   unguarded( (: save_object, SAVE_FILE :) );
}
void create() {
   _last_added = 0;
   _buggy_starts = ({ });
   load_file();
   if ( !_buggy_starts ) {
      _buggy_starts = ({ });
   }
}
int add_buggy_start( string fname ) {
   if ( !fname ) {
      return 0;
   }
   fname = lower_case( fname );
   if ( fname[ <2 .. ] == ".c" ) {
      fname = fname[ 0 .. <3 ];
   }
   if ( member_array( fname, _buggy_starts ) != -1 ) {
      return -1;
   }
   _buggy_starts += ({ fname });
   _last_added = time();
   save_file();
   return 1;
}
int delete_buggy_start( string fname ) {
   if ( !fname ) {
      return 0;
   }
   fname = lower_case( fname );
   if ( fname[ <2 .. ] == ".c" ) {
      fname = fname[ 0 .. <3 ];
   }
   if ( member_array( fname, _buggy_starts ) == -1 ) {
      return -1;
   }
   _buggy_starts -= ({ fname });
   save_file();
   return 1;
}
string * list_buggy_starts() {
   return copy( _buggy_starts );
}
void remove_buggy_starts( object player ) {
   string * starts;
   if ( !player ) {
      return;
   }
   starts = copy( player->query_starts() );
   for( int i = 0; i < sizeof( starts ); i += 2 ) {
      if ( member_array( starts[i], _buggy_starts ) != -1 ) {
         player->remove_start( starts[i] );
      }
   }
   player->add_property( CHECKED_PROP, time() );
}
void login_callback( string player, string type ) {
   object playerob;
   if ( !player ||
        !type ||
        type != LOGIN )
   {
      return;
   }
   player = lower_case( player );
   if ( !( playerob =  find_player( player ) ) ||
        ( playerob->query_property( CHECKED_PROP ) >= _last_added ) )
   {
      return;
   }
   remove_buggy_starts( playerob );
}
void dest_me() {
   destruct( this_object() );
}

==================================================
FILE: /lib/obj/handlers/state_change.c
==================================================

#include <state_change.h>
#define PROP "state name"
#define DATA_DIR "/obj/state_change/"
mapping table = ([ ]);
void set_amount_of_ob( object ob, int amount );
mixed query_table() { return table; }
void create() {
    string *files;
    int i;
    seteuid("/secure/master"->creator_file(file_name(this_object())));
    files = ({ "base.hdr" });
    files += get_dir(DATA_DIR + "*.dat");
    for (i = 0; i < sizeof(files); i++) {
        files[i] = DATA_DIR + files[i];
    }
    table += "/obj/handlers/data"->compile_data(files);
}
varargs object transform( object ob, string transformation, object player ) {
    string index, name;
    object ret;
    class state_change c;
    function f;
    int *weight_unit;
    if (!stringp(name = ob->query_property(PROP)))
      if (!stringp(name = ob->query_medium_alias()))
        name = ob->short();
    if ( !player )
      player = this_player();
    index = transformation + ":" + name;
    if (undefinedp(table[index]))
      return 0;
    c = table[index];
    ret = clone_object(c->result);
    foreach (f in c->func)
      evaluate(f, ob, ret, player);
    if (ret->query_continuous()) {
        if ( ob->query_continuous() || ob->query_collective() ) {
            ret->set_amount(to_int(ob->query_amount() * c->factor));
        } else {
            weight_unit = ret->query_weight_unit();
            set_amount_of_ob( ret, to_int( ob->query_weight() * c->factor *
              weight_unit[1] / weight_unit[0] ) );
        }
    } else {
        if ( ob->query_continuous() || ob->query_collective() ) {
            weight_unit = ob->query_weight_unit();
            ret->set_weight(to_int(ob->query_amount() * c->factor *
                                   weight_unit[0] / weight_unit[1]));
        } else {
            ret->set_weight(to_int(ob->query_weight() * c->factor));
        }
    }
    log_file( "STATE_CHANGE", "Changed %d amount of %s to %d amount of %s via %s.\n",
      ob->query_amount(), ob->query_medium_alias(), ret->query_amount(),
      ret->query_medium_alias(), transformation );
    return ret;
}
void set_amount_of_ob( object ob, int amount ) {
  if ( !ob )
      return;
  if ( !amount )
      ob->dest_me();
  ob->set_amount( amount );
  return;
}

==================================================
FILE: /lib/obj/handlers/taskmaster.c
==================================================

#include <tasks.h>
#define TIME_PER_USER 1800
#define SAVE_FILES "/save/tasks/"
#define LOG_STATS 2
#undef LOGGING
mapping stats;
nosave int last_save;
nosave int last;
nosave string skill;
nosave mixed *control;
nosave int * critical_chances;
varargs mixed perform_task( object person, string skill, int difficulty,
                         int tm_type, int degree );
varargs mixed attempt_task( int difficulty, int bonus, int upper,
                            mixed extra, int degree );
varargs mixed attempt_task_e( int difficulty, int bonus, int upper,
                              int half, int degree );
int is_critical( int margin );
void create() {
   float a, b;
   seteuid( "Root" );
   critical_chances = allocate(100);
   a = 0.93260;
   b = 0.06978;
   for( int i = 0; i < 100; i++ ) {
      critical_chances[i] = a * exp( b * ( i + 1 ) );
   }
}
mapping query_stats( string s_name ) {
  if ( skill != s_name ) {
    skill = s_name;
    if ( file_size( SAVE_FILES + skill +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILES + skill :) );
    else
      stats = 0;
  }
  if ( !stats )
    stats = ([ ]);
  return copy( stats );
}
int query_last() { return last; }
mixed *query_control() { return control; }
void set_control( mixed *args ) { control = args; }
void reset_control() { control = 0; }
void award_made( string p_name, string o_name, string s_name, int level ) {
  user_event( "inform", p_name +" gains a level in "+ s_name +" from "+
              o_name + " at level " + level, "skill" );
#ifdef LOG_STATS
#if LOG_STATS == 1
  query_stats( s_name );
  if ( !stats[ level ] )
    stats[ level ] = ([ ]);
  stats[ level ][ explode( o_name, "#" )[ 0 ] ]++;
#else
  query_stats("summary");
  if(s_name[<7..] == ".points" || s_name[0..13] == "other.language")
    return;
  s_name = explode(s_name, ".")[0];
  if(!stats[s_name])
    stats[s_name] = ({ ({ 0 , 0 }),  ({ 0, 0 }),  ({ 0, 0 }) , ({0,0})});
  switch(level) {
  case 0..149:
    stats[s_name][0] = ({ stats[s_name][0][0], stats[s_name][0][1]+1 });
    break;
  case 150..299:
    stats[s_name][1] = ({ stats[s_name][1][0], stats[s_name][1][1]+1 });
    break;
  case 300..599:
    stats[s_name][2] = ({ stats[s_name][2][0], stats[s_name][2][1]+1 });
    break;
  default:
    stats[s_name][3] = ({ stats[s_name][3][0], stats[s_name][3][1]+1 });
    break;
  }
  if(last_save < time() - 300) {
    unguarded( (: save_object, SAVE_FILES + "summary" :) );
    last_save = time();
  }
#endif
#endif
}
#if LOG_STATS == 2
void skill_checked(string s_name, int level) {
  query_stats("summary");
  if(s_name[<7..] == ".points" || s_name[0..13] == "other.language")
    return;
  s_name = explode(s_name, ".")[0];
  if(!stats[s_name])
    stats[s_name] = ({ ({0,0}), ({0,0}), ({0,0}), ({0,0}), ({0,0}) });
  switch(level) {
  case 0..49:
    stats[s_name][0] = ({ stats[s_name][0][0]+1, stats[s_name][0][1] });
    break;
  case 50..149:
    stats[s_name][1] = ({ stats[s_name][1][0]+1, stats[s_name][1][1] });
    break;
  case 150..299:
    stats[s_name][2] = ({ stats[s_name][2][0]+1, stats[s_name][2][1] });
    break;
  case 300..599:
    stats[s_name][3] = ({ stats[s_name][3][0]+1, stats[s_name][3][1] });
    break;
  default:
    stats[s_name][4] = ({ stats[s_name][4][0]+1, stats[s_name][4][1] });
    break;
  }
  if(last_save < time() - 300) {
    unguarded( (: save_object, SAVE_FILES + "summary" :) );
    last_save = time();
  }
}
#endif
string *query_skill_files() {
  return unguarded( (: get_dir, SAVE_FILES +"*.o" :) );
}
void clear_skill_files() {
  string word;
  foreach ( word in unguarded( (: get_dir, SAVE_FILES +"*.o" :) ) )
    unguarded( (: rm, SAVE_FILES + word :) );
  skill = 0;
}
varargs mixed compare_skills( object offob, string offskill,
                              object defob, string defskill,
                              int modifier, int off_tm_type,
                              int def_tm_type, int degree )
{
  int offbonus, defbonus;
  int perc, chance;
  int success_margin, res, deg;
  if( !offob || !defob || !offskill || !defskill )
    return BARF;
  offbonus = offob->query_skill_bonus(offskill);
  defbonus = defob->query_skill_bonus(defskill);
  if( !defbonus ) {
    defbonus = 1;
  }
  if( !offbonus ) {
    offbonus = 1;
  }
  (offbonus > defbonus) ?
    perc = (50 * offbonus * offbonus) / (offbonus * defbonus) :
    perc = 100 - (50 * defbonus * defbonus) / (offbonus * defbonus);
  perc += modifier;
  if(perc > 99)
    perc = 99;
  if(perc < 1)
    perc = 1;
  chance = random(100);
  success_margin = perc - chance;
  if( success_margin > 0 ) {
    switch( perform_task( offob, offskill, defbonus-modifier,
                          off_tm_type, 0 ) )
    {
    case AWARD:
      res = OFFAWARD;
      break;
    default:
      res = OFFWIN;
    }
    if( degree ) {
      if( is_critical(success_margin) ) {
        deg = TASKER_CRITICAL;
      } else {
         if( success_margin < TASKER_MARGINAL_UPPER ) {
           deg = TASKER_MARGINAL;
         } else if( success_margin < TASKER_NORMAL_UPPER ) {
           deg = TASKER_NORMAL;
         } else {
           deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
    } else {
      return res;
    }
  } else {
    switch( perform_task( defob, defskill, offbonus-modifier,
                          def_tm_type, 0 ) ) {
    case AWARD:
      res = DEFAWARD;
      break;
    default:
      res = DEFWIN;
    }
    if( degree ) {
      if( is_critical(success_margin) ) {
        deg = TASKER_CRITICAL;
      } else {
         if( -success_margin < TASKER_MARGINAL_UPPER ) {
           deg = TASKER_MARGINAL;
         } else if( -success_margin < TASKER_NORMAL_UPPER ) {
           deg = TASKER_NORMAL;
         } else {
           deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
    } else {
      return res;
    }
  }
}
varargs mixed perform_task( object person, string skill, int difficulty,
                            int tm_type, int degree ) {
  mixed result;
  int bonus, upper;
  if( !person || !skill )
    return BARF;
  bonus = person->query_skill_bonus( skill );
  switch(tm_type) {
  case TM_FIXED:
    result = attempt_task( difficulty, bonus, 100, 0, degree );
    break;
  case TM_FREE:
    result = attempt_task( difficulty, bonus, 25, 0, degree );
    break;
  case TM_CONTINUOUS:
    result = attempt_task( difficulty, bonus, 50, 0, degree );
    break;
  case TM_COMMAND:
    if( explode( skill, "." )[0] == "covert" )
      result = attempt_task_e
  ( difficulty, bonus, 60, 40, degree );
    else
      result = attempt_task( difficulty, bonus, 100, 0, degree );
    break;
  case TM_RITUAL:
    result = attempt_task_e( difficulty, bonus, 50, 25, degree );
    break;
  case TM_SPELL:
    result = attempt_task_e( difficulty, bonus, 60, 40, degree );
    break;
  case TM_NONE:
    result = attempt_task_e(difficulty, bonus, 1, 0, degree);
    if(classp(result) && ( (class tasker_result)result )->result == AWARD) {
      result->result = SUCCEED;
    } else if( result == AWARD ) {
      result = SUCCEED;
    }
    break;
  default:
#ifdef LOGGING
    if(file_name(previous_object())[0..2] != "/w/")
      log_file("ATTEMPT_TASK",
               "%s Object %s using old perform_task [%d, %d]\n",
               ctime(time()), base_name(previous_object()), tm_type, degree );
#endif
    upper = tm_type;
    if ( !upper )
      upper = 100;
    result = attempt_task( difficulty, bonus, upper, 0, degree );
  }
  if(classp(result) && ( (class tasker_result)result )->result == AWARD ||
     result == AWARD) {
    if(person->advancement_restriction() ||
       !person->add_skill_level(skill, 1, previous_object())) {
      if(classp(result))
        result->result = SUCCEED;
      else
        result = SUCCEED;
    }
  }
  return result;
}
varargs mixed attempt_task( int difficulty, int bonus, int upper,
                            mixed extra, int degree )
{
   int margin, success_margin, deg, res;
   float tmp;
#ifdef LOGGING
   if( call_stack(2)[1] != "perform_task" &&
       base_name( previous_object() ) != "/std/effects/fighting/combat" &&
       file_name( previous_object() )[0..2] != "/w/" )
   {
     log_file("ATTEMPT_TASK", "%s Object %s is using old attempt_task "
              "[%O]\n",
              ctime( time() ), base_name( previous_object() ), call_stack(2) );
   }
#endif
#if LOG_STATS == 2
   if(pointerp(control) && control[1]) {
      skill_checked(control[1], control[0]->query_skill(control[1]));
   }
#endif
   if ( bonus < difficulty ) {
#ifdef DEBUG
      if(pointerp(control) && control[0]->query_name() == WATCH_PLAYER &&
         find_player(DEBUG))
      {
         tell_creator( DEBUG, "%^RED%^"
           + sprintf( "TM: %s Skill: %s [%d] [%d] Failed\n",
                      control[0]->query_name(), control[1], bonus, difficulty )
           + "%^RESET%^" );
      }
#endif
      if( degree ) {
         return new( class tasker_result,
                     result : FAIL,
                     degree : ( is_critical( -100 ) ?
                                TASKER_CRITICAL :
                                TASKER_EXCEPTIONAL ),
                     raw    : -100 );
      } else {
         return FAIL;
      }
   }
   if ( !extra )
      margin = 3 * sqrt( difficulty );
   else {
      if ( intp( extra ) )
         margin = extra;
      if ( pointerp( extra ) )
         margin = extra[ 0 ] + extra[ 1 ] * sqrt( difficulty );
   }
   if ( !margin )
      return BARF;
   if ( bonus > difficulty + margin ) {
#ifdef DEBUG
     if(pointerp(control) &&
        WATCH_PLAYER || control[0]->query_name() == WATCH_PLAYER &&
        find_player(DEBUG))
       tell_object(find_player(DEBUG), "%^RED%^" + sprintf("TM: %s Skill: %s [%d] [%d] [%d] Succeeded\n", control[0]->query_name(), control[1], bonus, difficulty, margin) + "%^RESET%^");
#endif
      if( degree ) {
         return new( class tasker_result,
                     result : SUCCEED,
                     degree : ( is_critical(100) ?
                                TASKER_CRITICAL :
                                TASKER_EXCEPTIONAL ),
                     raw    : 100 );
      } else {
         return SUCCEED;
      }
   }
   if(!margin)
     margin = 1;
   success_margin = ( ( 100 * ( bonus - difficulty ) ) / margin ) - random(100);
   if ( success_margin <= 0 ) {
#ifdef DEBUG
     if(pointerp(control) &&
        control[0]->query_name() == WATCH_PLAYER &&
        find_player(DEBUG))
       tell_object(find_player(DEBUG), "%^RED%^" + sprintf("TM: %s Skill: %s [%d] [%d] Failed (2)\n", control[0]->query_name(), control[1], bonus, difficulty) + "%^RESET%^");
#endif
      if( degree ) {
         if( is_critical(success_margin) ) {
            deg = TASKER_CRITICAL;
         } else {
            if( -success_margin < TASKER_MARGINAL_UPPER ) {
               deg = TASKER_MARGINAL;
            } else if( -success_margin < TASKER_NORMAL_UPPER ) {
               deg = TASKER_NORMAL;
            } else {
               deg = TASKER_EXCEPTIONAL;
            }
         }
         return new( class tasker_result,
                     result : FAIL,
                     degree : deg,
                     raw    : success_margin );
      } else {
         return FAIL;
      }
   }
   if ( pointerp( control ) ) {
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), "%^RED%^" +
                   sprintf("TM: %s Skill: %s [%d,%d] OU: %d ",
                           control[0]->query_name(),
                           control[1], bonus,
                           control[0]->query_skill(control[1]),
                           upper));
#endif
     upper = (int)control[ 0 ]->stat_modify(upper, control[ 1 ] );
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG),
                   sprintf("SU: %d ", upper));
#endif
     tmp = exp((control[0]->query_skill(control[1])-BASE) / DECAY);
     upper = to_int(upper / tmp) - MODIFIER;
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("LU: %d ", upper));
#endif
     if(upper < 0)
       upper = 0;
#ifdef DEBUG
      if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("FU: %d\n",
                                                 upper) + "%^RESET%^");
#endif
   }
#ifdef DEBUG
   else
     if(find_player(DEBUG))
       tell_object(find_player(DEBUG), sprintf("No control: %O\n",
                                                 previous_object(-1)));
#endif
     if(!margin)
        margin = 1;
   if( random(100) < ( upper * ( difficulty + margin - bonus ) ) / margin )
      res = AWARD;
   else
      res = SUCCEED;
   if( degree ) {
      if( is_critical(success_margin) ) {
         deg = TASKER_CRITICAL;
      } else {
         if( success_margin < TASKER_MARGINAL_UPPER ) {
            deg = TASKER_MARGINAL;
         } else if( success_margin < TASKER_NORMAL_UPPER ) {
            deg = TASKER_NORMAL;
         } else {
            deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
   } else {
      return res;
   }
}
varargs mixed attempt_task_e( int difficulty, int bonus, int upper,
                              int half, int degree )
{
   float fail_chance;
   float tmp;
   int success_margin, deg, res;
#ifdef LOGGING
   if(call_stack(2)[1] != "perform_task" &&
      base_name(previous_object()) != "/std/effects/fighting/combat" &&
      file_name(previous_object())[0..2] != "/w/") {
     log_file("ATTEMPT_TASK", "%s Object %s is using old attempt_task "
              "[%O]\n",
              ctime(time()), base_name(previous_object()), call_stack(2));
   }
#endif
#if LOG_STATS == 2
   if(pointerp(control) && control[1]) {
     skill_checked(control[1], control[0]->query_skill(control[1]));
   }
#endif
   if ( bonus < difficulty ) {
      if( degree ) {
         return new( class tasker_result,
                     result : FAIL,
                     degree : ( is_critical( -100 ) ?
                                TASKER_CRITICAL :
                                TASKER_EXCEPTIONAL ),
                     raw    : -100 );
      } else {
         return FAIL;
      }
   }
   if( !half )
      half = 6 * sqrt( difficulty );
   if( !half )
      half = 1;
   fail_chance = exp( ( -0.693 * ( bonus - difficulty ) ) / half );
   success_margin = ( random( 1000 ) - ( 1000 * fail_chance ) ) / 10;
   if ( success_margin < 0 ) {
      if( degree ) {
         if( is_critical(success_margin) ) {
            deg = TASKER_CRITICAL;
         } else {
            if( -success_margin < TASKER_MARGINAL_UPPER ) {
               deg = TASKER_MARGINAL;
            } else if( -success_margin < TASKER_NORMAL_UPPER ) {
               deg = TASKER_NORMAL;
            } else {
               deg = TASKER_EXCEPTIONAL;
            }
         }
         return new( class tasker_result,
                     result : FAIL,
                     degree : deg,
                     raw    : success_margin );
      } else {
         return FAIL;
      }
   }
   if ( pointerp( control ) ) {
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), "%^RED%^" +
                   sprintf("TM: %s Skill: %s [%d,%d] OU: %d ",
                           control[0]->query_name(),
                           control[1], bonus,
                           control[0]->query_skill(control[1]),
                           upper));
#endif
     upper = (int)control[ 0 ]->stat_modify( upper, control[ 1 ] );
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG),
                   sprintf("SU: %d ", upper));
#endif
     tmp = exp((control[0]->query_skill(control[1])-BASE) / DECAY);
     upper = to_int(upper / tmp) - E_MODIFIER;
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("LU: %d ", upper));
#endif
     if(upper < 0)
       upper = 0;
#ifdef DEBUG
      if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("FU: %d\n",
                                                 upper) + "%^RESET%^");
#endif
   }
   if ( random(1000) < ( upper * fail_chance * 10 )
    &&  bonus < difficulty + ( half * 5 ) ) {
      res = AWARD;
   } else {
      res = SUCCEED;
   }
   if( degree ) {
      if( is_critical(success_margin) ) {
         deg = TASKER_CRITICAL;
      } else {
         if( success_margin < TASKER_MARGINAL_UPPER ) {
            deg = TASKER_MARGINAL;
         } else if( success_margin < TASKER_NORMAL_UPPER ) {
            deg = TASKER_NORMAL;
         } else {
            deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
   } else {
      return res;
   }
}
int is_critical( int margin ) {
   if ( margin < 0 ) {
      margin *= -1;
   }
   if ( margin > 100 ) {
      margin = 100;
   }
   if ( margin == 0 ) {
      return 0;
   }
   return random(10000) < critical_chances[ margin - 1 ];
}

==================================================
FILE: /lib/obj/handlers/team.c
==================================================

#define CREATOR "Ceres"
#include <login_handler.h>
#define SHADOW "/std/shadows/misc/team"
#define MAX_GROUP_SIZE 5
class group {
  object leader;
  int policy;
  object *members;
  int locked;
}
mapping groups,
        members;
private void check_group(string g_name);
private void disband_group(string g_name, string p_name);
private void tidy_members(string g_name);
void create() {
  members = ([ ]);
  groups = ([ ]);
}
void dest_me() {
  destruct(this_object());
}
void leaving(string p_name, string type) {
  class group record;
  string g_name;
  if((type != "logout") || (!members[p_name]))
    return;
  g_name = members[p_name];
  record = (class group)groups[g_name];
  map_delete(members, p_name);
  if(!record)
    return;
  if((record->leader == 0) || ((record->leader)->query_name() == p_name)) {
     disband_group(g_name, p_name);
#ifdef LOG_FILE
    log_file(LOG_FILE, sprintf("%s %s has left the game, the %s has been "
                             "disbanded.\n", ctime(time()), p_name, g_name));
#endif
  } else {
#ifdef LOG_FILE
    log_file(LOG_FILE, sprintf("%s %s left the game while a member of the %s\n",
                             ctime(time()), p_name, g_name));
#endif
    record->members = delete(record->members,
                             member_array(0, record->members), 1);
  }
  return;
}
int new_group(string g_name, object leader, int policy) {
  class group record;
  if(!undefinedp(groups[g_name]))
    return 0;
  record = new(class group);
  record->leader = leader;
  record->policy = policy;
  record->members = ({ leader });
  groups[g_name] = record;
  members[leader->query_name()] = g_name;
  leader->set_title( "TEAM", "Team Leader of "+ g_name );
   clone_object( SHADOW )->setup_shadow( leader );
#ifdef LOG_FILE
  log_file(LOG_FILE, sprintf("%s %s created by %s\n", ctime(time()),
                           g_name, leader->query_name()));
#endif
  return 1;
}
int end_group(string g_name) {
  class group record;
  object player;
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
   foreach( player in record->members )
      if ( player ) {
         map_delete( members, player->query_name() );
         player->remove_title( "TEAM" );
         player->destruct_team_shadow();
      }
  map_delete(groups, g_name);
#ifdef LOG_FILE
  log_file(LOG_FILE, sprintf("%s %s disbanded\n", ctime(time()), g_name));
#endif
  return 1;
}
int join_group(string g_name, object player) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
  record->members += ({ player });
  members[player->query_name()] = g_name;
   player->set_title( "TEAM", "Team Member of "+ g_name );
   clone_object( SHADOW )->setup_shadow( player );
#ifdef LOG_FILE
  log_file(LOG_FILE, sprintf("%s %s joined by %s\n", ctime(time()),
                           g_name, player->query_name()));
#endif
  return 1;
}
int leave_group(string g_name, object player) {
  class group record;
  if(player) {
    map_delete(members, player->query_name());
      player->remove_title( "TEAM" );
      player->destruct_team_shadow();
#ifdef LOG_FILE
    log_file(LOG_FILE, sprintf("%s %s left by %s\n", ctime(time()), g_name,
                             player->query_name()));
#endif
  }
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
  if(member_array(player, record->members) == -1)
    return -1;
  record->members = delete(record->members,
                           member_array(player, record->members), 1);
  return 1;
}
object query_owner(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = (class group)groups[g_name];
  return record->leader;
}
object *query_members(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  tidy_members(g_name);
  record = groups[g_name];
  return (object *)record->members;
}
int query_policy(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
  return (int)record->policy;
}
string query_group(object player) {
  if(undefinedp(members[player->query_name()]))
    return 0;
  return members[player->query_name()];
}
int test_group(string g_name) {
  if(undefinedp(groups[g_name]))
    return 0;
  return 1;
}
int query_full(string g_name) {
  class group record;
  object member;
  if(undefinedp(groups[g_name]))
    return 0;
  tidy_members(g_name);
  record = (class group)groups[g_name];
  if(sizeof(record->members) >= MAX_GROUP_SIZE)
    return 1;
  return 0;
}
int query_locked(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = (class group)groups[g_name];
  return (record->locked);
}
int set_locked(string g_name, int lock) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = (class group)groups[g_name];
  record->locked = lock;
  return 1;
}
string *list_groups() {
  string frog;
  foreach (frog in keys(groups)) {
    check_group(frog);
  }
  return keys(groups);
}
private void disband_group(string g_name, string p_name) {
  class group record;
  object person;
  object member;
  record = (class group)groups[g_name];
  foreach(member in record->members) {
    if(!member)
      break;
    map_delete(members, member->query_name());
    foreach(person in member->query_protectors())
      member->remove_protector(person);
    foreach(person in member->query_followers())
      member->remove_follower(person);
    tell_object(member, p_name+" has left the game and so the "+g_name+
                " has been disbanded.\n");
  }
  map_delete(groups, g_name);
}
private void check_group(string g_name) {
  class group record;
  record = (class group)groups[g_name];
  if (record->leader == 0) {
    disband_group(g_name, "Your leader");
  } else {
    record->members -= ({ 0 });
  }
}
private void tidy_members(string g_name) {
  class group record;
  object member;
  record = (class group)groups[g_name];
  foreach(member in record->members)
    if(!member)
      record->members -= ({ 0 });
}
