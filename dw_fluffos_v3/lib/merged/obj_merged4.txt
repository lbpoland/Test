# Total Tokens: 118764
# Total Files Merged: 43

=====
FILE: handlers/terrain_handler.c
==================================================

#include <dirs.h>
#include <terrain.h>
#include <map.h>
#undef DEBUG_ROOM_SIZE
#undef DEBUG_CALC_EXITS
#define TP(x) tell_object(find_player("taffyd"), x);
#define BACKUP_TIME_OUT 1000000
inherit "/std/object";
string terrain_name;
mapping fixed_locations;
mixed *floating_locations;
private nosave int in_map;
private nosave mapping size_cache, cloned_locations, float_cache;
private nosave mapping std_types = ([ "north" : "path", "south" : "path",
  "east" : "path", "west" : "path", "northeast" : "hidden",
  "southwest" : "hidden", "southeast" : "hidden",
  "northwest" : "hidden", "up" : "stair", "down" : "stair" ]);
void setup() {
  size_cache = ([ ]);
  cloned_locations = ([ ]);
  float_cache = ([ ]);
  set_name("map");
  set_short("terrain map");
  add_adjective("terrain");
  set_long("This is a large map showing a large expanse of forest, desert, "
           "mountain or ocean.  A few locations of interest are marked on "
           "it, with most of the gaps between them blank or marked "
           "\"Here bee Draggons\" and the like, suggesting that the map-"
           "maker didn't know what was there either.\n" );
  add_adjective("terrain");
}
string member_cloned_locations(int *co_ords) {
  mapping tmp;
  if ((tmp = cloned_locations[terrain_name]) && (tmp = tmp[co_ords[0]]) &&
      (tmp = tmp[co_ords[1]])) {
      return tmp[co_ords[2]];
  }
  return 0;
}
string member_fixed_locations(int *co_ords) {
  int *loc_co_ords;
  string location;
  foreach (location, loc_co_ords in fixed_locations) {
    if ((co_ords[0] == loc_co_ords[0]) && (co_ords[1] == loc_co_ords[1]) &&
        (co_ords[2] == loc_co_ords[2])) {
      return location;
    }
  }
  return 0;
}
private int between(int limit1, int val, int limit2)
{
  if (limit1 < limit2) {
    return ((limit1 <= val) && (val <= limit2));
  } else {
    return ((limit2 <= val) && (val <= limit1));
  }
}
mixed *member_floating_locations(int *co_ords) {
  int *data;
  mixed *right_locations, *location;
  right_locations = ({ });
  foreach (location in floating_locations) {
    data = location[1];
    if (sizeof(data) == 6) {
      if (between(data[0], co_ords[0], data[3]) &&
          between(data[1], co_ords[1], data[4]) &&
          between(data[2], co_ords[2], data[5])) {
        right_locations += ({ location[0], location[2] });
      }
    } else {
      if ((co_ords[0] == data[0]) && (co_ords[1] == data[1]) &&
          (co_ords[2] == data[2])) {
        right_locations += ({ location[0], location[2] });
      }
    }
  }
  return right_locations;
}
string top_floating_location(int *co_ords) {
  int i, highest_level;
  string highest_location;
  mixed *right_locations;
  right_locations = member_floating_locations(co_ords);
  if (!sizeof(right_locations))
    return 0;
  highest_level = right_locations[1];
  highest_location = right_locations[0];
  for (i = 0; i < sizeof(right_locations); i += 2) {
    if (right_locations[i + 1] > highest_level) {
      highest_level = right_locations[i + 1];
      highest_location = right_locations[i];
    }
  }
  if (highest_location == "nothing")
    return 0;
  return highest_location;
}
private void init_data(string word) {
  terrain_name = word;
  fixed_locations = ([ ]);
  floating_locations = ({ });
}
int get_data_file(string word) {
  if (terrain_name != word) {
    if (file_size(RESTORE_PATH + word + ".o") > 0) {
      unguarded((: restore_object, RESTORE_PATH + word :));
    } else {
      init_data(word);
      return 0;
    }
  }
  return 1;
}
private void save_data_file(string word) {
  int number, last;
  string line, *lines;
  if (file_size(RESTORE_PATH + word +".o") > 0) {
    unguarded((: rename, RESTORE_PATH + word +".o",
               RESTORE_PATH +"backups/"+ word +"."+ time() :));
    lines = unguarded((: get_dir, RESTORE_PATH +"backups/"+ word +".*" :));
    if (sizeof(lines) > 3) {
      last = time() - BACKUP_TIME_OUT;
      foreach(line in lines) {
        sscanf(line, word +".%d", number);
        if (number < last)
          unguarded((: rm, RESTORE_PATH +"backups/"+ line :));
      }
    }
  }
  unguarded((: save_object, RESTORE_PATH + word :));
}
mapping query_cloned_locations(string terrain) {
  return cloned_locations[terrain];
}
mapping query_fixed_locations(string word) {
  get_data_file(word);
  return fixed_locations;
}
mixed *query_floating_locations(string word) {
  get_data_file(word);
  return floating_locations;
}
int *query_co_ord(string terrain, string file) {
  get_data_file(terrain);
  return fixed_locations[file];
}
string query_connection(string terrain, int *co_ords, string direc) {
  mapping connection_info, tmp;
  string connections;
  if (!float_cache[terrain] ||
      !(connection_info = float_cache[terrain][co_ords[0]])) {
    if (file_size(RESTORE_PATH + terrain) != -2) {
      return 0;
    }
    if (file_size(RESTORE_PATH + terrain +"/"+ co_ords[0]) == -1) {
      return 0;
    }
    connections = unguarded((: read_file,
                              RESTORE_PATH + terrain +"/"+ co_ords[0] :));
    connection_info = restore_variable(connections);
    if (!mapp(float_cache[terrain])) {
      float_cache[terrain] = ([ co_ords[0] : connection_info ]);
    } else {
      float_cache[terrain][co_ords[0]] = connection_info;
    }
  }
  if ((tmp = connection_info[co_ords[1]]) && (tmp = tmp[co_ords[2]])) {
    return tmp[direc];
  }
  return 0;
}
int query_connected(string terrain, int *co_ords) {
  mapping connection_info, tmp;
  string connections;
  if (!float_cache[terrain] ||
      !(connection_info = float_cache[terrain][co_ords[0]])) {
    if (file_size(RESTORE_PATH + terrain) != -2) {
      return 0;
    }
    if (file_size(RESTORE_PATH + terrain +"/"+ co_ords[0]) == -1) {
      return 0;
    }
    connections = unguarded((: read_file,
                              RESTORE_PATH + terrain +"/"+ co_ords[0] :));
    connection_info = restore_variable(connections);
    if (!mapp(float_cache[terrain])) {
      float_cache[terrain] = ([ co_ords[0] : connection_info ]);
    } else {
      float_cache[terrain][co_ords[0]] = connection_info;
    }
  }
  if ((tmp = connection_info[co_ords[1]]) && tmp[co_ords[2]]) {
    return 1;
  }
  return 0;
}
int add_fixed_location(string terrain, string file, int *co_ords) {
  get_data_file(terrain);
  if (fixed_locations[file]) {
    return 0;
  }
  if (sizeof(co_ords) != 3) {
    return 0;
  }
  fixed_locations[file] = co_ords;
  save_data_file(terrain_name);
  return 1;
}
private int add_connection(string terrain, int *co_ords, string direc,
                           string file) {
  mapping connection_info, tmp;
  string connections;
  if (!query_connection(terrain, co_ords, direc)) {
    if (file_size(RESTORE_PATH + terrain) != -2) {
      unguarded((: mkdir, RESTORE_PATH + terrain :));
    }
    if (file_size(RESTORE_PATH + terrain +"/"+ co_ords[0]) == -1) {
      connection_info = ([ co_ords[1] : ([ co_ords[2] : ([ direc : file ]) ])
                        ]);
      unguarded((: write_file, RESTORE_PATH + terrain + "/" + co_ords[0],
                   save_variable(connection_info), 1 :));
    } else {
      connections = unguarded((: read_file,
                                 RESTORE_PATH + terrain +"/"+ co_ords[0] :));
      connection_info = restore_variable(connections);
      if ((tmp = connection_info[co_ords[1]])) {
        if ((tmp = tmp[co_ords[2]])) {
          tmp[direc] = file;
        } else {
          connection_info[co_ords[1]][co_ords[2]] = ([ direc : file ]);
        }
      } else {
        connection_info[co_ords[1]] = ([ co_ords[2] : ([ direc : file ]) ]);
      }
      unguarded((: write_file, RESTORE_PATH + terrain + "/" + co_ords[0],
                   save_variable(connection_info), 1 :));
    }
    if (!mapp(float_cache[terrain])) {
      float_cache[terrain] = ([ co_ords[0] : connection_info ]);
    } else {
      float_cache[terrain][co_ords[0]] = connection_info;
    }
  }
}
int add_floating_location(string terrain, string file, int *co_ords,
                          int level) {
  get_data_file(terrain);
  if ((sizeof(co_ords) != 6) && (sizeof(co_ords) != 3)) {
    return 0;
  }
  if (member_array(({ file, co_ords, level }), floating_locations) != -1) {
    return 0;
  }
  floating_locations += ({ ({ file, co_ords, level }) });
  save_data_file(terrain_name);
  return 1;
}
private void add_cloned_location(string terrain, string file, int *co_ords) {
  mapping tmp, location_m;
  if (!(location_m = cloned_locations[terrain])) {
    cloned_locations[terrain] = ([ file : co_ords,
                                   co_ords[0] : ([ co_ords[1] :
                                                   ([ co_ords[2] : file ]) ])
                                ]);
  } else {
    location_m[file] = co_ords;
    if ((tmp = location_m[co_ords[0]])) {
      if ((tmp = tmp[co_ords[1]])) {
        tmp[co_ords[2]] = file;
      } else {
        location_m[co_ords[0]][co_ords[1]] = ([ co_ords[2] : file ]);
      }
    } else {
      location_m[co_ords[0]] = ([ co_ords[1] : ([ co_ords[2] : file ]) ]);
    }
  }
}
int modify_fixed_location(string terrain, string file, int *co_ords) {
  get_data_file(terrain);
  if (!fixed_locations[file]) {
    return 0;
  }
  if (sizeof(co_ords) != 3) {
    return 0;
  }
  fixed_locations[file] = co_ords;
  save_data_file(terrain_name);
  return 1;
}
int delete_cloned_location(string terrain, string file) {
  int *co_ords;
  mapping tmp, location_m;
  if (!((location_m = cloned_locations[terrain]) &&
        (co_ords = location_m[file]))) {
    return 0;
  }
  map_delete(location_m, file);
  tmp = location_m[co_ords[0]][co_ords[1]];
  map_delete(tmp, co_ords[2]);
  if (!sizeof(tmp)) {
    tmp = location_m[co_ords[0]];
    map_delete(tmp, co_ords[1]);
    if (!sizeof(tmp)) {
      map_delete(location_m, co_ords[0]);
      if (!sizeof(location_m)) {
        map_delete(cloned_locations, terrain);
      }
    }
  }
  return 1;
}
int delete_fixed_location(string terrain, string file) {
  get_data_file(terrain);
  if (!fixed_locations[file]) {
    return 0;
  }
  map_delete(fixed_locations, file);
  save_data_file(terrain_name);
  return 1;
}
int delete_floating_location(string terrain, string file, int *co_ords) {
  int i, j, flag_d, flag_m, *data;
  get_data_file(terrain);
  for (i = 0; i < sizeof(floating_locations); i++) {
    if (floating_locations[i][0] == file) {
      data = floating_locations[i][1];
      if (sizeof(data) != sizeof(co_ords)) {
        continue;
      }
      flag_m = 0;
      for (j = 0; j < sizeof(data); j++) {
        if (data[j] != co_ords[j]) {
          flag_m = 1;
          break;
        }
        if (!flag_m) {
          floating_locations = delete(floating_locations, i, 1);
          flag_d = 1;
        }
      }
    }
  }
  save_data_file(terrain_name);
  return flag_d;
}
void clear_cloned_locations(string terrain) {
  map_delete(cloned_locations, terrain);
}
void clear_connections(string terrain) {
  string line, *lines;
  if (file_size(RESTORE_PATH + terrain) != -2) {
    return;
  }
  lines = unguarded((: get_dir, RESTORE_PATH + terrain +"
private int right_co_ords(int *new_co_ords, int *co_ords, int delta,
                          int *vector) {
  int i;
  for (i = 0; i < 3; i++) {
    if (new_co_ords[i] + delta * vector[i] != co_ords[i]) {
      return 0;
    }
  }
  return 1;
}
int get_room_size(string file, int level) {
  int i, number, roomsize, *mapsize;
  string bname, parent, *lines;
  bname = base_name(file);
  if (size_cache[bname]) {
#ifdef DEBUG_ROOM_SIZE
    TP(sprintf("GRS says (cached) %s is %d\n", file, size_cache[bname]));
#endif
    return size_cache[bname];
  }
  if (find_object(file)) {
    size_cache += ([ bname : file->query_room_size() ]);
#ifdef DEBUG_ROOM_SIZE
    TP(sprintf("GRS says (loaded) %s is %d\n", file, size_cache[bname]));
#endif
    return size_cache[bname];
  }
  if (!in_map) {
    in_map = 1;
    mapsize = MAP_HANDLER->query_room_size(bname);
    in_map = 0;
  } else {
#ifdef DEBUG_ROOM_SIZE
    TP("GRS says recursion!\n");
#endif
    mapsize = 0;
  }
  if (mapsize) {
    size_cache += ([ bname : mapsize[0] ]);
#ifdef DEBUG_ROOM_SIZE
    TP(sprintf("GRS says (map) %s is %d\n", file, size_cache[bname]));
#endif
    return mapsize[0];
  }
  file = bname + ".c";
  if (file_size(file) < 0) {
    return 10;
  }
  lines = explode(read_file(file), "\n");
  roomsize = 10;
  for (i = 0; i < sizeof(lines); i++) {
    if (level < 4 &&
        sscanf(lines[i], "%*sinherit%*s\"%s\"%*s;", parent) == 4) {
      if (parent[<2..] != ".c") {
        parent += ".c";
      }
      roomsize = get_room_size(parent, level + 1);
    } else if (sscanf(lines[i], "%*sset_room_size(%*s%d%*s", number) == 4) {
      roomsize = number;
      break;
    }
  }
  size_cache += ([ bname : roomsize ]);
#ifdef DEBUG_ROOM_SIZE
  TP(sprintf("GRS says (parsed) %s is %d\n", file, size_cache[bname]));
#endif
  return roomsize;
}
private void add_exit(object place, string direc, string dest) {
  string type;
  type = (string)place->query_exit_type(direc, dest);
  if (!type) {
    type = std_types[direc];
  } else {
    if (type == "none") {
      return;
    }
  }
  place->add_exit(direc, dest, type);
}
private void calculate_exits(object place, int *co_ords) {
  int i, j, k, connected, delta, *new_co_ords;
  string actual, *exit_dirs;
  connected = query_connected(terrain_name, co_ords);
  exit_dirs = (string *)place->query_direc();
  for (i = 0; i < 20; i += 2) {
    if (member_array(STD_ORDERS[i], exit_dirs) != -1) {
      continue;
    }
    actual = query_connection(terrain_name, co_ords, STD_ORDERS[i]);
    if (actual) {
#ifdef DEBUG_CALC_EXITS
      TP(sprintf("actual room %s found\n", actual));
#endif
      add_exit(place, STD_ORDERS[i], actual);
      continue;
    }
    if (connected) {
#ifdef DEBUG_CALC_EXITS
      TP("connected, but no actual room\n");
#endif
      continue;
    }
    new_co_ords = copy(co_ords);
    for (k = 0; k < 3; k++) {
      new_co_ords[k] -= place->query_room_size() * STD_ORDERS[i+1][k];
    }
    reset_eval_cost();
    for (j = 0; j < 100; j++) {
      for (k = 0; k < 3; k++) {
        new_co_ords[k] -= 5 * STD_ORDERS[i+1][k];
      }
      if ((actual = member_fixed_locations(new_co_ords)) ||
          (actual = member_cloned_locations(new_co_ords)) ||
          (actual = top_floating_location(new_co_ords))) {
        delta = (int)place->query_room_size() + get_room_size(actual, 0);
        if (!right_co_ords(new_co_ords, co_ords, delta, STD_ORDERS[i+1])) {
          continue;
        }
#ifdef DEBUG_CALC_EXITS
        TP(sprintf("adding connection for %s\n", actual));
#endif
        add_connection(terrain_name, co_ords, STD_ORDERS[i],
                       base_name(actual));
        add_exit(place, STD_ORDERS[i], actual);
        break;
      }
    }
  }
}
object find_location(string terrain, int *co_ords) {
  string dest_name;
  object destination;
  if (!(get_data_file(terrain)) || (sizeof(co_ords) != 3)) {
    return 0;
  }
  reset_eval_cost();
  if ((dest_name = member_fixed_locations(co_ords))) {
    if (!(destination = find_object(dest_name))) {
      destination = load_object(dest_name);
    }
    return destination;
  }
  if (dest_name = member_cloned_locations(co_ords)) {
    if ((destination = find_object(dest_name))) {
      return destination;
    } else {
      delete_cloned_location(terrain, dest_name);
    }
  }
  if (dest_name = top_floating_location(co_ords)) {
    destination = clone_object(dest_name);
    destination->set_co_ord(co_ords);
    destination->set_terrain(terrain_name);
    calculate_exits(destination, co_ords);
    add_cloned_location(terrain, file_name(destination), co_ords);
    return destination;
  }
  return 0;
}
void setup_location(object place, string terrain) {
  int *co_ords;
  get_data_file(terrain);
  if (!fixed_locations[base_name(place)]) {
    return;
  }
  co_ords = fixed_locations[base_name(place)];
  place->set_co_ord(co_ords);
  calculate_exits(place, co_ords);
}
mixed *stats() {
  return ::stats() + ({
    ({ "roomsize cache size", sizeof(size_cache) }),
      ({ "cloned_locations", sizeof(cloned_locations) }),
        ({ "float_cache", sizeof(float_cache) }),
          ({ "terrain name", terrain_name }),
            ({ "fixed locations", sizeof(fixed_locations) }),
              ({ "floating locations", sizeof(floating_locations) }),
  });
}

==================================================
FILE: handlers/title_handler.c
==================================================

#include <login.h>
private mapping _pending;
private mapping _titles;
private nosave string* _allowed_multiple;
#define SAVE_FILE "/save/titles"
void load_me();
void save_me();
class blob {
   string ob;
   string func;
}
void create() {
   _pending = ([ ]);
   _titles = ([ ]);
   load_me();
   _allowed_multiple = ({ "very reverend", "mostly reverend",
                          "reverend mother", "mad granny",
                          "mad nanny", "mad mr", "mad ms", "mad miss",
                          "mad mrs" });
}
int is_allowed_multiple_title(string title) {
   return member_array(lower_case(title), _allowed_multiple) != -1;
}
string* query_allowed_multiple_titles() {
   return _allowed_multiple;
}
void add_title_to_player(string person, string title) {
   object ob;
   ob = find_player(person);
   if (ob) {
      ob->add_player_title(title);
      return ;
   }
   if (!_pending[person]) {
      _pending[person] = ({ });
   }
   _pending[person] += ({ title });
   save_me();
}
string* query_pending_titles(string person) {
   if (_pending[person]) {
      return _pending[person];
   }
   return ({ });
}
void add_controlled_title(string title, string ob, string func) {
   class blob fluff;
   fluff = new(class blob);
   fluff->ob = ob;
   fluff->func = func;
   _titles[title] = fluff;
   save_me();
}
protected class blob query_controlled_title(string title) {
   return _titles[title];
}
void check_player(object player) {
   string* titles;
   string title;
   if (!player) {
      return ;
   }
   if (_pending[player->query_name()]) {
      foreach (title in _pending[player->query_name()]) {
         player->add_player_title(title);
      }
      map_delete(_pending, player->query_name());
      save_me();
   }
   titles = player->query_all_player_titles();
   foreach (title in titles) {
      if (_titles[title]) {
         if(!find_object(_titles[title]->ob) ||
            !call_other(_titles[title]->ob, _titles[title]->func,
                        player->query_name())) {
           player->remove_player_title(title);
         }
      }
   }
}
void login_handler_call(string person, string type) {
   if (type == LOGIN) {
      call_out((: check_player(find_player($1)) :), 2, person);
   }
}
void save_me() {
   unguarded((: save_object(SAVE_FILE) :));
}
void load_me() {
   unguarded((: restore_object(SAVE_FILE, 1) :));
}

==================================================
FILE: handlers/tokeniser.c
==================================================

#include "tokenise.h"
mapping token;
void create() {
  token = ([
           '+' : TOK_PLUS,
           '-' : TOK_MINUS,
           '*' : TOK_MULT,
           '/' : TOK_DIV,
           '(' : TOK_OBRAC,
           ')' : TOK_CBRAC,
           '{' : TOK_SARRAY,
           '}' : TOK_EARRAY,
           '[' : TOK_SMAPPING,
           ']' : TOK_EMAPPING,
           ':' : TOK_COLON,
           ',' : TOK_COMMA,
           '.' : TOK_DOT,
           '\t' : TOK_TAB,
           '=' : TOK_ASSIGN,
#ifdef BOOLEAN
           '>' : TOK_GREATOR,
           '<' : TOK_LESS,
           "==" : TOK_EQUAL,
           ">=" : TOK_GREATOREQ,
           "<=" : TOK_LESSEQUAL,
#endif
           "->" : TOK_CALL,
           ".." : TOK_DOTDOT,
           ]);
}
mixed tokenise(string inp) {
  string *bits, *cur;
  int pos, num;
  int start_pos;
  cur = ({ });
  while (pos < strlen(inp))
    switch (inp[pos++]) {
      case ' ' :
      case '\t' :
        break;
      case '\'' :
      case '"' :
      case '`' :
        bits = explode("#"+inp[pos-1..]+"#", inp[pos-1..pos-1]);
        if (!bits || sizeof(bits) < 2) {
          write("Error processing the string.\n");
          return 0;
        }
        pos += strlen(bits[1])+1;
        cur += ({ ({ bits[1] }) });
        break;
      case '.' :
      case '0' :
      case '1' :
      case '2' :
      case '3' :
      case '4' :
      case '5' :
      case '6' :
      case '7' :
      case '8' :
      case '9' :
        start_pos = pos;
        while ((inp[pos] >= '0' && inp[pos] <= '9') || (inp[pos] == '.')) {
          pos++;
        }
        if (strsrch(inp[start_pos..pos], ".") != -1) {
          sscanf(inp[start_pos-1..pos], "%f", num);
        } else {
          sscanf(inp[start_pos-1..pos], "%d", num);
        }
        cur += ({ ({ num }) });
        break;
      case '+' :
      case '*' :
      case ':' :
      case ',' :
      case '{' :
      case '}' :
      case '(' :
      case ')' :
      case '[' :
      case ']' :
        cur += ({ token[inp[pos-1]] });
        break;
      case '>' :
      case '<' :
      case '=' :
      case '-' :
      case '/' :
      case '.' :
        if (inp[pos-1] != '/') {
          if ((num = token[inp[pos-1..pos]])) {
            cur += ({ num });
            pos++;
            break;
          }
          num = token[inp[pos-1]];
          if (num) {
            cur += ({ num });
            break;
          }
        } else {
          if (sizeof(cur) && !stringp(cur[sizeof(cur)-1])) {
            cur += ({ token[inp[pos-1]] });
            break;
          }
        }
      default :
        num = pos-1;
        while (pos < strlen(inp) && (!token[inp[pos++]] || inp[pos-1] == '/'));
        if (pos == num+1)
          break;
        if (token[inp[pos-1]])
          pos--;
        cur += ({ inp[num..pos-1] });
        break;
    }
  return cur;
}

==================================================
FILE: handlers/top_ten_handler.c
==================================================

#include <library.h>
#include <skills.h>
#include <top_ten_tables.h>
#include <clubs.h>
#include <player.h>
#include <player_handler.h>
#define SAVE_FILE "/save/top_ten_tables"
#define TOP_TEN_SIZE 15
#define GUILD_TOP_TEN_SIZE 10
#define ARCHIVE_TIME 50 * 24 * 60 * 60
#define ARCHIVE_RATING 30000
#define APEX_LIMIT 10000
#define AGE_DIVIDER 100
#define AGE calculate_age_modifier( thing, 0 )
mapping guild_top_tens;
mixed *archive, *top_ten;
nosave int average;
nosave mixed *skills;
string _family_largest;
int _family_largest_num;
string _family_qp;
int _family_qp_num;
string _family_age;
int _family_age_num;
mapping _family_guilds;
mapping _family_guilds_num;
string _family_pk;
int _family_pk_num;
string _family_single_gender;
int _family_single_gender_num;
string _family_start_time;
int _family_start_time_num;
string _family_relationships;
int _family_relationships_num;
string _club_largest;
int _club_largest_num;
string _club_qp;
int _club_qp_num;
string _club_age;
int _club_age_num;
mapping _club_guilds;
mapping _club_guilds_num;
string _club_pk;
int _club_pk_num;
string _club_single_gender;
int _club_single_gender_num;
string _club_start_time;
int _club_start_time_num;
void calculate_family_and_club_info();
void create() {
    seteuid( (string)"/secure/master"->
      creator_file( file_name( this_object() ) ) );
    guild_top_tens = ([ ]);
    _family_guilds = ([ ]);
    _club_guilds = ([ ]);
    _family_guilds_num = ([ ]);
    _club_guilds_num = ([ ]);
    archive = ({ });
    top_ten = ({ });
    call_out( "check_tables", 5 );
    call_out( "check_family_and_club_info", 10 );
    if ( file_size( SAVE_FILE +".o" ) > 0 ) {
        unguarded( (: restore_object, SAVE_FILE :) );
        if (!_family_guilds_num) {
            _family_guilds_num = ([ ]);
        }
        if (!_club_guilds_num) {
            _club_guilds_num = ([ ]);
        }
    }
}
private void save_me() {
    unguarded( (: save_object, SAVE_FILE :) );
}
int query_average() { return average; }
mixed *query_skills() { return skills; }
mapping query_guild_top_tens() { return guild_top_tens; }
void set_guild_top_tens( mapping map ) {
    guild_top_tens = map;
    save_me();
}
void add_guild_top_ten( string word ) {
    if ( guild_top_tens[ word ] ) {
        return;
    }
    guild_top_tens[ word ] = ({ });
    save_me();
}
mixed *query_archive() { return archive; }
void set_archive( mixed *args ) {
    archive = args;
    save_me();
}
mixed *query_top_ten() { return top_ten; }
void set_top_ten( mixed *args ) {
    top_ten = args;
    save_me();
}
int check_person( mixed *args, string guild ) {
    int i;
    string word;
    if ( !guild ) {
        sscanf( args[ 0 ], "%s (%s)", word, guild );
    } else {
        word = args[ 0 ];
    }
    if ( !PLAYER_HANDLER->test_user( word ) ||
      !PLAYER_HANDLER->test_active( word ) ||
      PLAYER_HANDLER->test_creator( word ) ||
      PLAYER_HANDLER->test_property( word, "no_score" ) ||
      PLAYER_HANDLER->test_property( word, "no score" ) ) {
        return 0;
    }
    if ( "/obj/handlers/player_handler"->test_guild( word, guild ) != "/std/guilds/"+ guild )
        return 0;
    if ( ( (int)PLAYER_HANDLER->test_last( word ) < time() - ARCHIVE_TIME ) ) {
        if ( args[ 1 ] > ARCHIVE_RATING ) {
            args[ 0 ] = word +" ("+ guild +")";
            for ( i = sizeof( archive ) - 1; i > -1; i-- ) {
                if ( archive[ i ][ 0 ] == args[ 0 ] ) {
                    if ( archive[ i ][ 1 ] > args[ 1 ] )
                        archive[ i ] = args + ({ time() });
                    break;
                }
            }
            if ( i == -1 ) {
                archive += ({ args + ({ time() }) });
            }
        }
        return 0;
    }
    return 1;
}
void check_tables() {
    int i;
    string word;
    for ( i = sizeof( top_ten ) - 1; i > -1; i-- ) {
        if ( !check_person( copy( top_ten[ i ] ), 0 ) ) {
            top_ten = delete( top_ten, i, 1 );
        }
    }
    foreach ( word in keys( guild_top_tens ) ) {
        for ( i = sizeof( guild_top_tens[ word ] ) - 1; i > -1; i-- ) {
            if ( !check_person( copy( guild_top_tens[ word ][ i ] ), word ) ) {
                guild_top_tens[ word ] = delete( guild_top_tens[ word ], i, 1 );
            }
        }
    }
    save_me();
}
mixed *query_ordered_table( string table_name ) {
    int i, highest_loc, highest_num;
    mixed *ret, *args;
    if ( !table_name || table_name == "main") {
        args = top_ten;
    } else {
        if ( table_name == "archive" ) {
            args = archive;
        } else {
            if ( !guild_top_tens[ table_name ] ) {
                return ({ });
            }
            args = guild_top_tens[ table_name ];
        }
    }
    ret = ({ });
    while ( sizeof( args ) ) {
        highest_loc = highest_num = 0;
        for ( i = 0; i < sizeof( args ); i++ ) {
            if ( args[ i ][ TOP_TEN_RATING ] > highest_num ) {
                highest_num = args[ i ][ TOP_TEN_RATING ];
                highest_loc = i;
            }
        }
        ret += ({ args[ highest_loc] });
        args = args[ 0 .. highest_loc - 1 ] + args[ highest_loc + 1 .. ];
    }
    return ret;
}
mixed *remove_name( string word, mixed *args ) {
    int i;
    if ( !sizeof( args ) ) {
        return ({ });
    }
    for ( i = sizeof( args ) - 1; i > -1; i-- ) {
        if ( word == explode( args[ i ][ TOP_TEN_NAME ], " " )[ 0 ] ) {
            args = delete( args, i, 1 );
        }
    }
    return args;
}
int *find_lowest( mixed *args ) {
    int i, lowest_loc, lowest_num;
    if ( !sizeof( args ) ) {
        return ({ 0, 0 });
    }
    lowest_loc = 0;
    lowest_num = args[ 0 ][ TOP_TEN_RATING ];
    for ( i = 1; i < sizeof( args ); i++ ) {
        if ( lowest_num > args[ i ][ TOP_TEN_RATING ] ) {
            lowest_loc = i;
            lowest_num = args[ i ][ TOP_TEN_RATING ];
        }
    }
    return ({ lowest_loc, lowest_num });
}
int query_skill_weight( string skill ) {
    int total;
    string *next;
    next = (string *)SKILL_OB->query_immediate_children( skill );
    if ( !sizeof( next ) ) {
        return 1;
    }
    foreach ( skill in next ) {
        total += query_skill_weight( skill );
    }
    return total;
}
int calculate_age_modifier( object thing, int algorithm ) {
    if ( algorithm ) {
        return ( -( thing->query_time_on() - ( thing->query_refresh_time() ? ( time() - thing->query_refresh_time() ) + thing->query_time_on() : 0 ) ) / 86400 );
    }
    return ( -thing->query_time_on() / 86400 );
}
int calculate_rating( object thing ) {
    int i, j, rating, *bonuses;
    rating = (int)thing->query_level();
    if ( !skills ) {
        skills = ({ });
        for ( i = 0; i < sizeof( STD_SKILLS ); i += SKILL_ARR_SIZE ) {
            skills += ({
              (string *)SKILL_OB->query_immediate_children( STD_SKILLS[ i ] )
            });
            skills += ({
              sizeof( skills[ <1 ] ),
              query_skill_weight( STD_SKILLS[ i ] )
            });
            average += skills[ <1 ];
        }
        average /= sizeof( skills ) / 3;
    }
    bonuses = allocate( sizeof( skills ) / 3 );
    for ( i = sizeof( bonuses ) - 1; i > -1; i-- ) {
        for ( j = skills[ 3 * i + 1 ] - 3; j > -1; j-- ) {
            bonuses[ i ] +=
            (int)thing->query_skill_bonus( skills[ 3 * i ][ j ], 1 );
        }
        bonuses[ i ] = ( ( bonuses[ i ] / skills[ 3 * i + 1 ] ) *
          skills[ 3 * i + 2 ] ) / average;
    }
    bonuses = sort_array( bonuses, -1 );
    j = sizeof( bonuses );
    for ( i = 0; i < j; i++ ) {
        rating = 2 * rating + bonuses[ i ];
        if ( !i && userp( thing ) ) {
            rating += (int)LIBRARY->
            query_quest_points( (string)thing->query_name() );
        }
    }
    if( rating > APEX_LIMIT && userp( thing ) ) {
        rating = AGE * (rating - APEX_LIMIT) / AGE_DIVIDER + APEX_LIMIT;
    }
    return rating;
}
void player_skill_advance( string word, object thing ) {
    int rating, *lowest;
    string name;
    mixed *guild_top_ten;
    if ( thing->query_creator() ) {
        return;
    }
    if ( thing->query_property( "guest" ) ) {
        return;
    }
    if ( thing->query_property( "no_score" ) ) {
        return;
    }
    if ( thing->query_property( "no score" ) ) {
        return;
    }
    guild_top_ten = guild_top_tens[ word ];
    if ( !guild_top_ten ) {
        return;
    }
    name = (string)thing->query_name();
    rating = calculate_rating( thing );
    guild_top_ten = remove_name( name, guild_top_ten );
    lowest = find_lowest( guild_top_ten );
    if ( sizeof( guild_top_ten ) < GUILD_TOP_TEN_SIZE ) {
        guild_top_ten += ({
          ({ name, rating, (int)thing->query_level(),
            -(int)thing->query_time_on() }) });
    } else {
        if ( rating > lowest[ 1 ] ) {
            guild_top_ten[ lowest[ 0 ] ] =
            ({ name, rating, (int)thing->query_level(),
              -(int)thing->query_time_on() });
        }
    }
    guild_top_tens[ word ] = guild_top_ten;
    top_ten = remove_name( name, top_ten );
    lowest = find_lowest( top_ten );
    if ( sizeof( top_ten ) < TOP_TEN_SIZE ) {
        top_ten += ({
          ({ name +" ("+ word +")", rating,
            (int)thing->query_level(), -(int)thing->query_time_on() }) });
    } else {
        if ( rating > lowest[ 1 ] ) {
            top_ten[ lowest[ 0 ] ] =
            ({ name +" ("+ word +")", rating,
              (int)thing->query_level(), -(int)thing->query_time_on() });
        }
    }
}
varargs void excise_name( string word1, string word2 ) {
    if ( !word2 ) {
        top_ten = remove_name( word1, top_ten );
    } else {
        if ( guild_top_tens[ word2 ] ) {
            guild_top_tens[ word2 ] = remove_name( word1,
              guild_top_tens[ word2 ] );
        }
    }
    save_me();
}
void check_family_and_club_info() {
    int offset;
    string bing;
    string guild;
    _family_qp_num = 0;
    _family_age_num = 0;
    _family_largest_num = 0;
    if (!mapp(_family_guilds)) {
        _family_guilds = ([ ]);
    }
    if (!mapp(_club_guilds)) {
        _club_guilds = ([ ]);
    }
    if (_family_qp && !CLUB_HANDLER->is_family(_family_qp)) {
        _family_qp = 0;
        _family_qp_num = 0;
    }
    if (_family_age && !CLUB_HANDLER->is_family(_family_age)) {
        _family_age = 0;
        _family_age_num = 0;
    }
    if (_family_largest && !CLUB_HANDLER->is_family(_family_largest)) {
        _family_largest = 0;
        _family_largest_num = 0;
    }
    if (_family_single_gender && !CLUB_HANDLER->is_family(_family_single_gender)) {
        _family_single_gender = 0;
        _family_single_gender_num = 0;
    }
    if (_family_pk && !CLUB_HANDLER->is_family(_family_pk)) {
        _family_pk = 0;
        _family_pk_num = 0;
    }
    if (_club_qp && !CLUB_HANDLER->is_club(_club_qp)) {
        _club_qp = 0;
        _club_qp_num = 0;
    }
    if (_club_age && !CLUB_HANDLER->is_club(_club_age)) {
        _club_age = 0;
        _club_age_num = 0;
    }
    if (_club_largest && !CLUB_HANDLER->is_club(_club_largest)) {
        _club_largest = 0;
        _club_largest_num = 0;
    }
    if (_club_single_gender && !CLUB_HANDLER->is_club(_club_single_gender)) {
        _club_single_gender = 0;
        _club_single_gender_num = 0;
    }
    if (_club_pk && !CLUB_HANDLER->is_club(_club_pk)) {
        _club_pk = 0;
        _club_pk_num = 0;
    }
    offset = 3;
    foreach (guild, bing in _family_guilds) {
        if (stringp(bing)) {
            if (!CLUB_HANDLER->is_family(bing)) {
                map_delete(_family_guilds, guild);
                map_delete(_family_guilds_num, guild);
            }
        } else {
            map_delete(_family_guilds, guild);
            map_delete(_family_guilds_num, guild);
        }
    }
    foreach (guild, bing in _club_guilds) {
        if (stringp(bing)) {
            if (!CLUB_HANDLER->is_club(bing)) {
                map_delete(_club_guilds, guild);
                map_delete(_club_guilds_num, guild);
            }
        } else {
            map_delete(_club_guilds, guild);
            map_delete(_club_guilds_num, guild);
        }
    }
    save_me();
}
void inform_of_club(string club,
  int family,
  int type,
  mixed num) {
    string str;
    int bing;
    if (family) {
        switch (type) {
        case TOP_TEN_LARGEST_FAMILY:
            if (_family_largest_num < num ||
              _family_largest == club) {
                _family_largest_num = num;
                _family_largest = club;
                save_me();
            }
            break;
        case TOP_TEN_OLDEST_FAMILY:
            if (_family_age_num < num ||
              _family_age == club) {
                _family_age_num = num;
                _family_age = club;
                save_me();
            }
            break;
        case TOP_TEN_MOST_QUEST_POINTS:
            if (_family_qp_num < num ||
              _family_qp == club) {
                _family_qp_num = num;
                _family_qp = club;
                save_me();
            }
            break;
        case TOP_TEN_MOST_GUILD:
            foreach (str, bing in num) {
                if (_family_guilds_num[str] < bing ||
                  _family_guilds[str] == club) {
                    _family_guilds_num[str] = bing;
                    _family_guilds[str] = club;
                    save_me();
                }
            }
            break;
        case TOP_TEN_MOST_PKS:
            if (_family_pk_num < num ||
              _family_pk == club) {
                _family_pk_num = num;
                _family_pk = club;
                save_me();
            }
            break;
        case TOP_TEN_SINGLE_GENDER:
            if (_family_single_gender_num < num ||
              _family_single_gender == club) {
                _family_single_gender_num = num;
                _family_single_gender = club;
                save_me();
            }
            break;
        case TOP_TEN_OLDEST_LOGONS:
            if (_family_start_time_num < num ||
              _family_start_time == club) {
                _family_start_time_num = num;
                _family_start_time = club;
                save_me();
            }
            break;
        case TOP_TEN_MOST_RELATIONSHIPS:
            if (_family_relationships_num < num ||
              _family_relationships == club) {
                _family_relationships_num = num;
                _family_relationships = club;
                save_me();
            }
            break;
        }
    } else {
        switch (type) {
        case TOP_TEN_LARGEST_FAMILY:
            if (_club_largest_num < num ||
              _club_largest == club) {
                _club_largest_num = num;
                _club_largest = club;
                save_me();
            }
            break;
        case TOP_TEN_OLDEST_FAMILY:
            if (_club_age_num < num ||
              _club_age == club) {
                _club_age_num = num;
                _club_age = club;
                save_me();
            }
            break;
        case TOP_TEN_MOST_QUEST_POINTS:
            if (_club_qp_num < num ||
              _club_qp == club) {
                _club_qp_num = num;
                _club_qp = club;
                save_me();
            }
            break;
        case TOP_TEN_MOST_GUILD:
            foreach (str, bing in num) {
                if (_club_guilds_num[str] < bing ||
                  _club_guilds[str] == club ||
                  !_club_guilds[str]) {
                    _club_guilds_num[str] = bing;
                    _club_guilds[str] = club;
                    save_me();
                }
            }
            break;
        case TOP_TEN_MOST_PKS:
            if (_club_pk_num < num ||
              _club_pk == club) {
                _club_pk_num = num;
                _club_pk = club;
                save_me();
            }
            break;
        case TOP_TEN_SINGLE_GENDER:
            if (_club_single_gender_num < num ||
              _club_single_gender == club) {
                _club_single_gender_num = num;
                _club_single_gender = club;
                save_me();
            }
            break;
        case TOP_TEN_OLDEST_LOGONS:
            if (_club_start_time_num < num ||
              _club_start_time == club) {
                _club_start_time_num = num;
                _club_start_time = club;
                save_me();
            }
            break;
        }
    }
}
mixed *query_family_info() {
    return ({ _family_largest,
      _family_age,
      _family_qp,
      _family_guilds,
      _family_pk,
      _family_single_gender,
      _family_start_time,
      _family_relationships });
}
mixed *query_club_info() {
    return ({ _club_largest,
      _club_age,
      _club_qp,
      _club_guilds,
      _club_pk,
      _club_single_gender,
      _club_start_time });
}
void dest_me() {
    save_me();
    destruct(this_object());
}
void reset() {
    save_me();
}

==================================================
FILE: handlers/trig.c
==================================================

int *sintab, *pow;
create()
{
   pow = ({ 296296, 308556, 321324, 334621, 348467, 362887, 377903,
            393541, 409825, 426784, 444444, 462835, 481987, 501931,
            522701, 544331, 566855, 590311, 614738, 640176, 666666,
            694253, 722981, 752897, 784052, 816496, 850283, 885467,
            922107, 960264, 1000000,
            1041379, 1084471, 1129346, 1176079, 1224744, 1275424,
            1328201, 1383161, 1440396, 1500000, 1562069, 1626707,
            1694020, 1764118, 1837117, 1913136, 1992301, 2074742,
            2160595, 2250000, 2343104, 2440061, 2541030, 2646177,
            2755675, 2869705, 2988452, 3112114, 3240892, 3375000
   });
   sintab = ({
      0, 17452, 34899, 52335, 69756, 87155, 104528, 121869, 139173, 156434,
      173648, 190808, 207911, 224951, 241921, 258819, 275637, 292371,
      309016, 325568, 342020, 358367, 374606, 390731, 406736, 422618,
      438371, 453990, 469471, 484809, 500000, 515038, 529919, 544639,
      559192, 573576, 587785, 601815, 615661, 629320, 642787, 656059,
      669130, 681998, 694658, 707106, 719339, 731353, 743144, 754709,
      766044, 777145, 788010, 798635, 809016, 819152, 829037, 838670,
      848048, 857167, 866025, 874619, 882947, 891006, 898794, 906307,
      913545, 920504, 927183, 933580, 939692, 945518, 951056, 956304,
      961261, 965925, 970295, 974370, 978147, 981627, 984807, 987688,
      990268, 992546, 994521, 996194, 997564, 998629, 999390, 999847, 1000000
   });
}
int sin(int angle)
{
   while (angle < 0) angle += 360;
   while (angle >= 360) angle -= 360;
   if (angle >= 270) return -sintab[360 - angle];
   if (angle >= 180) return -sintab[angle - 180];
   if (angle >= 90) return sintab[180 - angle];
   return sintab[angle];
}
int cos(int angle)
{
   return sin(90 - angle);
}
int tan(int angle)
{
   return 1000 * sin(angle) / (sin(90 - angle) / 1000);
}
int pow1_5(int n)
{
   if (n > 30) n = 30;
   else if (n < -30) n = -30;
   return pow[30-n];
}

==================================================
FILE: handlers/twiki.c
==================================================

#include <board.h>
void do_check_changes();
#define SAVE_FILE "/save/twiki"
#define CHECK_TIME (7 * 24 * 60 * 60)
#define TWIKI_CHANGE_FILE "/.changes"
#define TWIKI_DATA_DIRECTORY "/twiki/data/"
private nosave string* _databases;
private int _last_check;
private mapping _last_change;
void create() {
   _databases = ({ "Main", "Am", "Ram", "Cwc", "Sur", "Klatch",
                   "Forn", "Underworld", "Other", "Playtesters" });
   seteuid(getuid());
   restore_object(SAVE_FILE);
   if (_last_check + CHECK_TIME < time()) {
      do_check_changes();
   }
   call_out("do_check_changes", _last_check + CHECK_TIME - time());
   if (!_last_change) {
      _last_change = ([ ]);
   }
   call_out("do_change_inform", 60 * 5);
}
mapping find_changed_pages(int limit, string database) {
   string* lines;
   int i;
   int tim;
   string page;
   string author;
   mixed* bits;
   mapping changes_pages;
   lines = explode(read_file(TWIKI_DATA_DIRECTORY + database + TWIKI_CHANGE_FILE), "\n");
   changes_pages = ([ ]);
   for (i = 1; i < sizeof(lines); i++) {
      bits = reg_assoc(lines[<i], ({ "([a-zA-Z][a-zA-Z0-9]+)", "[0-9]+" }), ({ 1, 2 }) );
      if (sizeof(bits[0]) == 9 || sizeof(bits[0]) == 7) {
         page = bits[0][1];
         author = bits[0][3];
         sscanf(bits[0][5], "%d", tim);
         if (tim > limit) {
            if (page[0..4] != "TWiki" &&
                page[0..9] != "Underworld" &&
                author != "PeterThoeny" &&
                page != author &&
                page != "WebPreferences") {
               if (file_size("/twiki/data/" + database + "/" + page + ".txt") > 0 &&
                   strsrch(read_file("/twiki/data/" + database + "/" + page + ".txt"),
                           "\t* Login Name:") == -1) {
                  if (!changes_pages[page]) {
                     changes_pages[page] = ({ });
                  }
                  if (member_array(author, changes_pages[page]) == -1) {
                     changes_pages[page] += ({ author });
                  }
               }
            }
         } else {
            break;
         }
      } else {
         break;
      }
   }
   return changes_pages;
}
string find_changes(int limit) {
   mapping changes_pages;
   string ret;
   string page;
   string database;
   ret = "Changes since " + ctime(limit) + " in\n"
         "http:
   foreach (database in _databases) {
      changes_pages = find_changed_pages(limit, database);
      foreach (page in sort_array(keys(changes_pages), 1)) {
         ret += sprintf("%-30s changed by %s\n", database + "." + page,
                         query_multiple_short(changes_pages[page]));
      }
   }
   return ret;
}
string find_changes_in_database(string database, int limit) {
   mapping changes_pages;
   string ret;
   string page;
   if (database == "Playtesters") {
      ret = "Changes since " + ctime(limit) + " in\n"
         "http:
   } else {
      ret = "Changes since " + ctime(limit) + " in\n"
         "http:
   }
   changes_pages = find_changed_pages(limit, database);
   foreach (page in sort_array(keys(changes_pages), 1)) {
      ret += sprintf("%-30s changed by %s\n", database + "." + page,
                      query_multiple_short(changes_pages[page]));
   }
   return ret;
}
string query_file(string fname) {
   if (strsrch(fname, ".") > 0) {
      fname = "/twiki/data/" + replace_string(fname, ".", "/") + ".txt";
   } else {
      fname = "/twiki/data/Main/" + fname + ".txt";
   }
   if (sizeof(stat(fname))) {
      return read_file(fname);
   }
   return 0;
}
void do_check_changes() {
   string changes;
   changes = find_changes(_last_check);
   BOARD_HAND->add_message("commonroom", "Twiki Database",
                           "Changes in the Twiki database",
                           changes);
   _last_check = time();
   save_object(SAVE_FILE);
   call_out("do_check_changes", _last_check + CHECK_TIME - time());
}
void do_change_inform() {
   int changed;
   mapping changed_pages;
   string page;
   string* changers;
   int dosave;
   string database;
   if (!mapp(_last_change)) {
      _last_change = ([ ]);
   }
   foreach (database in _databases) {
      if (!_last_change[database]) {
         _last_change[database] = time();
         dosave = 1;
      } else {
         changed = stat(TWIKI_DATA_DIRECTORY + database + TWIKI_CHANGE_FILE)[1];
         if (changed != _last_change[database]) {
            changed_pages = find_changed_pages(_last_change[database], database);
            _last_change[database] = changed;
            dosave = 1;
            foreach (page, changers in changed_pages) {
               user_event( "inform",
                           sprintf( "%s changes the twiki page %s.%s",
                                    query_multiple_short(changers), database,
                                    page),
                           "message",
                           this_player() );
            }
         }
      }
   }
   if (dosave) {
      save_object(SAVE_FILE);
   }
   call_out("do_change_inform", 60 * 5);
}

==================================================
FILE: handlers/vhandler.c
==================================================

mapping stored_variables;
void create()
{
  seteuid(geteuid(this_object()));
  stored_variables=([ ]);
  restore_object(file_name(this_object()));
}
mixed query_variable_status(string vname)
{
  return stored_variables[vname];
}
int set_variable_status(string vname, mixed vvalue)
{
  stored_variables[vname]=vvalue;
  save_object(file_name(this_object()));
}

==================================================
FILE: handlers/virtuals.c
==================================================

#define SAVE_FILE "/save/virtuals"
#define MAX_NUMBERS 50
mapping load_data;
string *paths;
string *missing_paths;
string *forbidden_paths;
void create() {
   seteuid( "/secure/master"->creator_file( file_name( this_object() ) ) );
   load_data = ([ ]);
   paths = ({ });
   missing_paths = ({ });
   forbidden_paths = ({ });
   if ( file_size( SAVE_FILE +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE :) );
}
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }
void add_data( string path ) {
  object junk_item;
  string tmp_str;
  int tmp_int;
  junk_item = clone_object( path );
  load_data[ path ] = ({ stat( path )[1], junk_item->query_static_auto_load() });
  destruct( junk_item );
  paths -= ({ path });
  paths += ({ path });
  if( sizeof( paths ) > MAX_NUMBERS ) {
    tmp_int = sizeof( paths ) - (MAX_NUMBERS + 1);
    paths = paths[tmp_int+1..tmp_int+MAX_NUMBERS];
  }
  foreach( tmp_str in keys( load_data ) ) {
    if( member_array( tmp_str, paths ) == -1 ) {
      map_delete( load_data, tmp_str );
    }
  }
  save_me();
}
mapping new_data( string path ) {
  if( ( !load_data[path] ) || ( !sizeof( stat( path ) ) ) || ( load_data[path][0] < stat( path )[1] ) ) {
    if( !sizeof( stat( path ) ) ) {
      return 0;
    }
    add_data( path );
  }
  return load_data[path][1];
}
string *query_missing_paths() { return missing_paths; }
int add_missing( string path ) {
  if( !missing_paths )
    missing_paths = ({ });
  if( member_array( path, missing_paths ) != -1 )
    return 0;
  if( path[0..2] == "/w/" )
    return 0;
  missing_paths += ({ path });
  save_me();
  return 1;
}
void remove_missing( string path ) {
  missing_paths -= ({ path });
  save_me();
}
int query_forbidden( string path ) {
  return ( member_array( path, forbidden_paths ) != -1 );
}
string *query_forbidden_paths( ) { return forbidden_paths; }
int add_forbidden( string path ) {
  if( !forbidden_paths )
    forbidden_paths = ({ });
  if( member_array( path, forbidden_paths ) != -1 )
    return 0;
  forbidden_paths += ({ path });
  save_me();
  return 1;
}
void remove_forbidden( string path ) {
  forbidden_paths -= ({ path });
  save_me();
}

==================================================
FILE: handlers/wander_handler.c
==================================================

#include <player.h>
#define MH "/obj/handlers/map"
#define LAST_LOC_PROPERTY "last locations"
void do_move_after();
class route_traveller {
  object monster;
  int movetime;
  int delay;
  string dest;
}
class wander_group {
  object *monsters;
  int movetime;
}
private class wander_group *wanderers = ({});
private mapping wanderpos = ([]);
private class route_traveller *travellers = ({});
private mapping travelpos = ([]);
private int move_call_out_id;
private int after_call_out_id;
private void do_move_after();
private void move_monsters();
void delete_move_after( object monster );
private void do_wander(int running_away, object monster);
mixed query_next_mover() {
  return wanderers[0];
}
mixed query_anything(string thing){
  return copy(fetch_variable(thing));
}
int query_moving_monster(object ob) {
  return member_array(ob, travellers) != -1;
}
mixed query_route_monster() {
  return travellers[0];
}
int find_pos(mixed *arr, function func, int val, int ref found){
  int mid, high, low;
  high = sizeof(arr) - 1;
  low = 0;
  while(high >= low){
    mid = (high + low) / 2;
    if(val < (*func)(arr[mid]))
      high = mid - 1;
    else if(val > (*func)(arr[mid]))
      low = mid + 1;
    else break;
  }
  found = !(high < low);
  return mid;
}
private void add_traveller(class route_traveller new_traveller){
  if(sizeof(travellers)){
    int found, mid;
    mid = find_pos(travellers, (: $1->movetime :), new_traveller->movetime,
                   ref found);
    if(!found){
      if(new_traveller->movetime > travellers[mid]->movetime)
        mid++;
      if(mid == sizeof(travellers)){
        travellers += ({new_traveller});
        if(find_call_out(move_call_out_id) == -1 && sizeof(travellers) ) {
          move_call_out_id = call_out((: move_monsters :),
                                      travellers[0]->movetime - time() );
        }
        return;
      }
    }
    if(mid == 0){
      travellers = ({new_traveller}) + travellers;
      remove_call_out(move_call_out_id);
      move_call_out_id = call_out((: move_monsters :),
                                      new_traveller->movetime - time());
    } else {
        travellers = insert(travellers, new_traveller, mid);
    }
  } else {
    travellers = ({ new_traveller });
    move_call_out_id = call_out((: move_monsters :),
                                      new_traveller->movetime - time());
  }
}
int move_me_please(int delay, string dest) {
  class route_traveller new_traveller;
  object monster;
  monster = previous_object();
  if(!intp(delay))
    return 0;
  if(travelpos[monster])
    travelpos[monster]->monster = 0;
  if(delay < 5)
    delay = 5;
  new_traveller = new (class route_traveller, monster:monster, delay:delay,
             movetime:time() + delay, dest:dest);
  travelpos[monster] = new_traveller;
  add_traveller(new_traveller);
}
private void move_monsters(){
  class route_traveller tmp;
  int virtual_move, right, refuse;
  object monster;
  string true_location, destination, direc;
  tmp = travellers[0];
  monster = tmp->monster;
  if(sizeof(travellers) > 1)
    travellers = travellers[1..];
  else
    travellers = ({});
  if (monster) {
    virtual_move = monster->query_virtual_move();
    true_location = monster->query_true_location();
    direc = monster->get_next_route_direction();
    if (direc) {
      if ( !virtual_move ){
        if(catch(monster->do_command(direc)))
          catch(monster->do_command(direc));
      } else {
        if ( "/room/virtual" != file_name( environment( monster ) ) )
          right = 1;
        if ( right ) {
          environment( monster )->set_destination( direc );
          destination = environment( monster )->query_destination( direc, monster );
        } else
          destination = (string)MH->qdes( direc, true_location );
        if ( right ) {
          if ( monster->check_anyone_here() || find_object( destination ) ){
            if(catch(monster->do_command( direc )))
              catch(monster->do_command( direc ));
          } else {
            "/room/virtual"->force_load();
            monster->move( find_object( "/room/virtual" ) );
            true_location = destination;
            monster->set_true_location( true_location );
          }
        } else {
          if ( !find_object( destination ) ) {
            true_location = destination;
            monster->set_true_location( true_location );
          } else {
            object ob = environment(monster);
            ob->remove_exit(direc);
            ob->add_exit(direc, destination,
               "plain" );
            monster->do_command(direc);
            ob->remove_exit(direc);
          }
        }
      }
    }
    tmp->movetime = time() + tmp->delay;
    if ( direc && (!(refuse = monster->query_stop_moving()))) {
      add_traveller( tmp );
    } else {
      if(!refuse)
        refuse = (file_name(environment(tmp->monster)) != tmp->dest);
      tmp->monster->stopped_route(!refuse);
      map_delete( travelpos, tmp->monster );
    }
  } else
    travelpos = filter(travelpos, (: $1 :));
  if(find_call_out(move_call_out_id) == -1 && sizeof(travellers) ) {
    move_call_out_id = call_out((: move_monsters :),
                                      travellers[0]->movetime - time() );
  }
}
private void add_move_after(object monster, int movetime) {
  if(sizeof(wanderers)){
    int found, mid;
    reset_eval_cost();
    if(sizeof(wanderers) > 5000){
      wanderers=filter(wanderers, function(class wander_group thing){
        return sizeof(filter(thing->monsters, (:$1:)));
      });
      reset_eval_cost();
    }
    if (find_call_out(after_call_out_id) == -1)
      after_call_out_id = call_out((: do_move_after :), 0);
    mid = find_pos(wanderers, (: $1->movetime :), movetime, ref found);
    if(!found){
      if(movetime > wanderers[mid]->movetime)
        mid++;
      if(mid == sizeof(wanderers)){
        wanderers += ({ new(class wander_group, monsters:({monster}),
                            movetime:movetime) });
        wanderpos[monster] = wanderers[<1];
        return;
      }
      if(mid == 0){
        wanderers = ({ new(class wander_group, monsters:({monster}),
                           movetime:movetime) }) + wanderers;
        wanderpos[monster] = wanderers[0];
        remove_call_out(after_call_out_id);
        after_call_out_id = call_out((: do_move_after :), movetime - time());
        return;
        }
      wanderers = insert(wanderers, new(class wander_group,
                                        monsters:({monster}),
                                        movetime:movetime), mid);
      wanderpos[monster] = wanderers[mid];
      return;
    } else {
      wanderers[mid]->monsters += ({ monster });
      wanderpos[monster] = wanderers[mid];
      return;
    }
  } else {
    wanderers = ({ new(class wander_group, monsters:({monster}),
                       movetime:movetime) });
    wanderpos[monster] = wanderers[0];
    after_call_out_id = call_out((: do_move_after :), movetime - time());
  }
}
void move_after( int runaway ) {
  mixed move_after;
  if(runaway)
    return do_wander(runaway, previous_object());
  move_after = previous_object()->query_move_after();
  delete_move_after(previous_object());
  if (!arrayp(move_after) || (!move_after[0] && !move_after[1])) {
    return;
  }
  add_move_after(previous_object(), time() + move_after[ 0 ] +
                 random( move_after[ 1 ] ));
}
void delete_move_after(object monster) {
  if(wanderpos[monster]) {
    ((class wander_group)wanderpos[monster])->monsters -= ({monster});
  }
  map_delete(wanderpos, monster);
}
private void do_wander(int running_away, object monster) {
  int right, virtual_move;
  string destination, *direcs, *room_zones, true_location, *move_zones,
         *last_locs;
  if ( !monster )
    return ;
  if ( !environment( monster ) || monster->query_property( PASSED_OUT_PROP ) )
    return ;
  if ( !running_away &&
       sizeof( (object *)monster->query_attacker_list() ) )
    return ;
  if ( (int)monster->query_hp() <= 0 )
    return ;
  virtual_move = monster->query_virtual_move();
  true_location = monster->query_true_location();
  if (1 || !virtual_move ||
       (virtual_move && "/room/virtual" != file_name(environment(monster))))
    right = 1;
  if ( right )
   direcs = (string *)environment( monster )->query_direc( monster );
  else
    direcs = (string *)MH->qdir( true_location );
  last_locs = monster->query_propery( LAST_LOC_PROPERTY );
  if (!pointerp(last_locs))
    last_locs = ({ });
   if (!direcs) direcs = ({ });
  direcs = shuffle( direcs );
  while ( sizeof( direcs ) ) {
    if ( right ) {
      direcs[ 0 ] = (string)environment( monster )->expand_alias( direcs[ 0 ] );
      destination = environment( monster )->query_destination( direcs[0], monster );
    } else
      destination = (string)MH->qdes( direcs[ 0 ], true_location );
    if ( (!destination && !virtual_move) || (sizeof(direcs) > 1 &&
                          member_array(destination, last_locs) != -1 ) ||
         (0 && stringp(destination) && !find_object(destination) && !virtual_move) ) {
      direcs = direcs[1..];
      continue;
    }
    move_zones = (string *)monster->query_move_zones();
    if ( sizeof( move_zones ) ) {
      if ( find_object( destination ) )
        room_zones = (string *)destination->query_zones();
      else
        room_zones = (string *)MH->query_zones( destination );
      if (!room_zones ||
          (sizeof(room_zones) == sizeof(room_zones - move_zones))) {
        direcs = direcs[1..];
        continue;
      }
    }
    break;
  }
  last_locs += ({ destination });
  if (sizeof(last_locs) > 4)
    last_locs = last_locs[sizeof(last_locs)-4..];
  monster->add_property( LAST_LOC_PROPERTY, last_locs);
  if (sizeof(direcs)) {
    if (1 || !virtual_move ||
        (right && monster->check_anyone_here()) ||
        (find_object( destination ) ) ) {
      object ob;
      if (!right) {
        ob = environment(monster);
        ob->remove_exit(direcs[0]);
        ob->add_exit(direcs[0], destination, "plain");
        reset_eval_cost();
      }
      monster->do_move(direcs[0]);
      if(!right)
        ob->remove_exit(direcs[0]);
    } else {
      if (virtual_move) {
        "/room/virtual"->force_load();
        monster->move( find_object("/room/virtual"));
        monster->set_true_location(destination);
      }
    }
  }
}
private void do_move_after() {
  object monster;
  int movetime, *move_after, zero;
  class wander_group tmp;
  reset_eval_cost();
  if(sizeof(wanderers) > 5000){
    wanderers=filter(wanderers, function(class wander_group thing){
      return sizeof(filter(thing->monsters, (:$1:)));
    });
    reset_eval_cost();
  }
  while (sizeof(wanderers) && wanderers[0]->movetime <= time()) {
    reset_eval_cost();
    tmp = wanderers[0];
    wanderers = wanderers[1..];
    foreach(monster in tmp->monsters){
      map_delete(wanderpos, monster);
      if (objectp(monster) && environment(monster)) {
        move_after = monster->query_move_after();
        if (move_after[0] || move_after[1]) {
          movetime = time() + move_after[ 0 ] + random( move_after[ 1 ] );
          if( movetime < (time() + 2) ) {
            movetime = time() + 2;
          }
          add_move_after( monster, movetime );
          reset_eval_cost();
          if (!travelpos[monster]) {
            do_wander(0, monster);
          }
        }
      } else {
        zero = 1;
      }
    }
  }
  if (find_call_out(after_call_out_id) == -1 && sizeof(wanderers)) {
    after_call_out_id = call_out((: do_move_after :),
                                        wanderers[0]->movetime - time());
  }
  if(zero) {
    wanderpos = filter(wanderpos, (: $1 :));
  }
}
mapping query_dynamic_auto_load() {
   return ([
    "wanderers" : wanderers,
    "wanderpos" : wanderpos,
    "travellers" : travellers,
    "travelpos" : travelpos
     ]);
}
void init_dynamic_arg(mapping map) {
  if (map) {
     wanderers = map["wanderers"];
     wanderpos = map["wanderpos"];
     travellers = map["travellers"];
     travelpos = map["travelpos"];
     do_move_after();
  }
}

==================================================
FILE: handlers/weather.c
==================================================

#include <climate.h>
#include <am_time.h>
#include <weather.h>
#define FILE_NAME "/save/nweather"
#define UPDATE_SPEED 300
#define CYCLE_SPEED  3600
#define DIY 400
#define DIF(x, y) (x > y) ? (x-y) : (y-x)
private mapping _pattern;
private mapping _current;
private int *_variance;
private nosave mapping _rooms;
private nosave int _lastupdate;
private nosave int _day;
private nosave int _sunrise;
private nosave int _sunset;
private nosave int _toy;
private int mooncycle;
private int moonupdate;
void set_day();
void update_pattern();
int calc_actual(object env, int type);
int cloud_index(object env);
int query_day(object env);
int query_rain_type(int temp, int rain);
string sun_direction(int which);
int temperature_index(object env);
int rain_index(object env);
void create() {
  string str;
  _rooms = ([ ]);
  unguarded((: restore_object, FILE_NAME :));
  if(!_pattern)
    _pattern = ([ ]);
  if(!_current)
    _current = ([ ]);
  if(!_variance)
    _variance = ({ 10, 75, 20 });
  foreach(str in CLIMATES) {
    if(!_pattern[str])
      _pattern[str] =  ({ 0, 0, 0 });
    if(!_current[str])
      _current[str] =  ({ 0, 0, 0 });
  }
  call_out("update_weather", UPDATE_SPEED);
  set_day();
  update_pattern();
}
int weather_notify( object which_room, int notifications ) {
  if(notifications < 0 || notifications >
     (NOTIFY_TEMPERATURE | NOTIFY_CLOUD | NOTIFY_RAIN | NOTIFY_DAY)) {
    return 0;
  }
  _rooms[which_room] = notifications;
  return 1;
}
void test_notifications() {
  object room;
  string w;
  foreach( room in keys(_rooms)) {
    w = sprintf("%O notified of %s%s%s%s\n", room,
    ((_rooms[room] & NOTIFY_TEMPERATURE) ? "Temperature " : ""),
                ((_rooms[room] & NOTIFY_CLOUD) ? "Clouds " : ""),
                ((_rooms[room] & NOTIFY_RAIN) ? "Rain " : ""),
                ((_rooms[room] & NOTIFY_DAY) ? "Day" : ""));
    write( w );
  }
  write("test_notifications() done\n");
}
int day_number() {
  return ( time() % AM_SECONDS_PER_HALF_YEAR ) / AM_SECONDS_PER_DAY;
}
int minute_number() {
  return (( time() % AM_SECONDS_PER_DAY ) / AM_SECONDS_PER_MINUTE);
}
string query_moon_string(object env) {
  string str;
  if(mooncycle > 10)
    return "It is night and there is no moon.\n";
  if(calc_actual(env, CLOUD) > 70)
    str = "It is night and the %s is hidden by the clouds.\n";
  else if(env && env->query_water())
    str = "The water is lit up by the eerie light of the %s.\n";
  else
    str = "The land is lit up by the eerie light of the %s.\n";
  return sprintf(str, ({"waxing crescent moon",
                        "waxing quarter moon",
                        "waxing half moon",
                        "waxing three quarter moon",
                        "waxing gibbous moon",
                        "full moon",
                        "waning gibbous moon",
                        "waning three quarter moon",
                        "waning half moon",
                        "waning quarter moon",
                        "waning crescent moon",
                        "no moon",
                        "no moon",
                        "no moon",
                      })[mooncycle]);
}
int query_moon_state() {
  if(mooncycle < 6)
    return mooncycle+1;
  if(mooncycle < 11)
    return (11 - mooncycle);
  return 0;
}
string query_moon_phase() {
  return ({"crescent",
           "quarter",
           "half",
           "three quarter",
           "gibbous",
           "full",
           "gibbous",
           "three quarter",
           "half",
           "quarter",
           "crescent",
           "",
           "",
           "",
         })[mooncycle];
}
int query_stars( object env ) {
    int clouds, stars ;
    clouds = cloud_index(env) ;
    if ( query_day(env) || clouds > 70 ) {
        return 0 ;
    }
    switch( clouds ) {
        case 0:
            stars = 100 ;
            break ;
        case 1..39:
            stars = 80 ;
            break ;
        case 40..59:
            stars = 40 ;
            break ;
        case 60..69:
            stars = 20 ;
            break ;
        default:
            stars = 10 ;
            break ;
    }
    return stars ;
}
string query_star_string( object env ) {
    string str ;
    if ( query_day(env) ) {
        return "There are no stars visible during the day.\n" ;
    }
    switch( query_stars(env) ) {
        case 1..20:
            str = "one or two bright stars" ;
            break ;
        case 21..40:
            str = "a few stars" ;
            break ;
        case 41..60:
            str = "quite a few stars" ;
            break ;
        case 61..80:
            str = "lots of stars" ;
            break ;
        case 81..100:
            str = "countless stars" ;
            break ;
        default:
            str = "no stars" ;
            break ;
    }
    return "Tonight, there are " + str + " visible.\n" ;
}
string query_season() {
  switch(day_number()) {
  case 0..50: return "winter";
  case 51..150: return "spring";
  case 151..250: return "summer";
  case 251..350: return "autumn";
  case 351..400: return "winter";
  }
}
string query_tod() {
  if((minute_number() < _sunrise) || (minute_number() > _sunset))
    return "night";
  switch(minute_number()) {
  case 0..700:
    return "morning";
  case 701..740:
    return "midday";
    break;
  case 741..1080:
    return "afternoon";
    break;
  default:
    return "evening";
  }
}
int query_day(object env) {
  return _day;
}
int query_darkness(object env) {
  int result, cloud, day;
  result = 10;
  day = query_day(env);
  if(day == 10)
    return 100;
  if(mooncycle <= 10) {
    if(mooncycle < 6)
      result += mooncycle * 10;
    else
      result += (5 - (mooncycle % 6)) * 10;
    }
  if((cloud = cloud_index(env)) > 0)
    result -= (cloud_index(env) / 15);
  if(result < 0)
    result = 0;
  if(day > 0)
    result += (100 - result) / (10 - day);
  return result;
}
int query_visibility(object env) {
  int result;
  int temp;
  int rain;
  int rt;
  result = 100;
  temp = temperature_index(env);
  rain = rain_index(env);
  rt = query_rain_type(temp, rain);
  if (rt ==  WEATHER_SNOW_TYPE) {
     rain += 50;
  } else if (rt == WEATHER_SLEET_TYPE) {
     rain += 20;
  }
  if (rain > 0) {
     if (rain > 100) {
        result = 0;
     } else {
        result = (result * (100 - rain)) / 100;
     }
  }
  return result;
}
int calc_actual(object env, int type) {
  int *clim;
  string climate;
  if(env) {
    climate = env->query_climate();
    clim = (int *)env->query_property("climate");
  }
  if(!climate)
    climate = DEFAULT_CLIMATE;
  if(!clim)
    return _current[climate][type];
  return _current[climate][type] + clim[type];
}
int temperature_index(object env) {
  int temp, tod, j, diurnal;
  string climate;
  temp = calc_actual(env, TEMP);
  if(env)
    climate = env->query_climate();
  if(!climate)
    climate = DEFAULT_CLIMATE;
  tod = 10 - query_day(env);
  if(tod) {
    switch(climate) {
    case "Af":
    case "Am":
    case "Aw":
      diurnal = 10;
      break;
    case "Bw":
    case "Bs":
      diurnal = 15 + (_pattern[climate][0] / 2);
      break;
    case "Cfa":
    case "Cs":
    case "Cfb":
    case "Dw":
    case "Ds":
    case "Df":
      diurnal = 15;
      break;
    case "Et":
    case "Ef":
    case "H":
      diurnal = 20;
      break;
    }
    temp -= (diurnal * tod) / 10;
  }
  j = sqrt(_current[climate][CLOUD]);
  if(j < 0)
    j = 0;
  if(temp < 10 && tod == 10)
    temp += j;
  else if(temp > 30 && !tod)
    temp -= j;
  temp -= sqrt(_current[climate][WINDSP]);
  return temp;
}
int cloud_index(object env) {
  int cloud;
  cloud = calc_actual(env, CLOUD);
  if(cloud < 0)
    cloud = 0;
  return cloud;
}
int rain_index(object env) {
  int rain;
  rain = calc_actual(env, CLOUD) - (calc_actual(env, TEMP) / 2) - 100;
  return (rain > 0)? rain : 0;
}
string temp_string(int temp) {
  switch(temp) {
    case 51..1000: return "incredibly, unbelievably hot"; break;
    case 46..50: return "amazingly hot"; break;
    case 41..45: return "damn hot"; break;
    case 36..40: return "very hot"; break;
    case 31..35: return "hot"; break;
    case 26..30: return "reasonably hot"; break;
    case 23..25: return "very warm"; break;
    case 20..22: return "warm"; break;
    case 16..19: return "pleasantly warm"; break;
    case 13..15: return "cool"; break;
    case 10..12: return "slightly chilly"; break;
    case 7..9: return "chilly"; break;
    case 4..6: return "very chilly"; break;
    case 1..3: return "cold"; break;
    case -3..0: return "very cold"; break;
    case -10..-4: return "freezing cold"; break;
    case -20..-11: return "damn cold"; break;
    case -30..-21: return "dangerously cold"; break;
    case -50..-31: return "incredibly, unbelievably cold"; break;
  }
}
private string precipitation_string(int rain, int rt, int wind) {
  switch(rain) {
  case -1000..20:
    return "lightly";
    break;
  case 21..40:
    if(wind < 20) {
      return "steadily";
    } else {
      return "hard";
    }
    break;
  case 41..60:
    return "heavily";
    break;
  case 61..500:
    if(rt == WEATHER_RAIN_TYPE) {
      return "torrentially";
    } else {
      return "very heavily";
    }
    break;
  }
}
string rain_string(object env) {
  int rt, rain, wind, temp;
  temp = temperature_index(env);
  rain = rain_index(env);
  rt = query_rain_type(temp, rain);
  if (rt != WEATHER_RAIN_TYPE) {
    return "There is no rain";
  }
  return "It is raining " + precipitation_string(rain, rt, wind);
}
string snow_string(object env) {
  int rt, rain, wind, temp;
  temp = temperature_index(env);
  rain = rain_index(env);
  rt = query_rain_type(temp, rain);
  if (rt != WEATHER_SNOW_TYPE) {
    return "There is no snow";
  }
  return "It is snowing " + precipitation_string(rain, rt, wind);
}
string sleet_string(object env) {
  int rt, rain, wind, temp;
  temp = temperature_index(env);
  rain = rain_index(env);
  rt = query_rain_type(temp, rain);
  if (rt != WEATHER_SLEET_TYPE) {
    return "There is no sleet";
  }
  return "It is sleeting " + precipitation_string(rain, rt, wind);
}
string cloud_string(object env) {
  int cloud;
  string str;
  cloud = cloud_index(env);
  switch(cloud) {
    case -1000..5:
       str = "a beautifully clear sky";
       break;
    case 6..10:
       str = "a few high level cirrus clouds";
       break;
    case 11..25:
       str = "scattered puffy clouds";
       break;
    case 26..40:
       str = "some puffy clouds";
       break;
    case 41..60:
       str = "many puffy clouds";
       break;
    case 61..80:
       str = "medium cloud cover";
       break;
    case 81..110:
       str = "dense cloud cover";
       break;
    case 111..130:
       str = "packed cloud cover";
       break;
    case 131..160:
       str = "thick black clouds";
       break;
    case 161..1000:
       str = "thick heavy storm clouds";
       break;
  }
  return str;
}
varargs string weather_string(object env, string obscured) {
  int temp, cloud, wind, rain, rt;
  int *warray;
  string str, tstr;
   if ( !env )
     return 0;
  temp = temperature_index(env);
  cloud = cloud_index(env);
  wind = calc_actual(env, WINDSP);
  rain = rain_index(env);
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temp, cloud, wind, rain))) {
    temp = warray[0];
    cloud = warray[1];
    wind = warray[2];
    rain = warray[3];
  }
  rt = query_rain_type(temp, rain);
  str = "It is ";
  tstr = temp_string(temp);
  switch(tstr[0]) {
  case 'a':
  case 'e':
  case 'i':
  case 'o':
  case 'u':
    str += "an ";
    break;
  default:
    str += "a ";
  }
  str += tstr + " ";
  switch((time() % (AM_SECONDS_PER_HALF_YEAR*2)) / AM_SECONDS_PER_DAY) {
  case 51..150:
    str += "spring prime";
    break;
  case 151..250:
    str += "summer prime";
    break;
  case 251..350:
    str += "autumn prime";
    break;
  case 351..450:
    str += "spindlewinter";
    break;
  case 451..550:
    str += "secundus spring";
    break;
  case 551..650:
    str += "secundus summer";
    break;
  case 651..750:
    str += "secundus autumn";
    break;
  default:
    str += "backspindlewinter";
  }
  str += "'s "+ query_tod() +" with ";
  switch(wind) {
    case -1000..5: str += "almost no wind"; break;
    case 6..10: str += "a gentle breeze"; break;
    case 11..15: str += "a steady breeze"; break;
    case 16..20: str += "a strong breeze"; break;
    case 21..30: str += "a steady wind"; break;
    case 31..40: str += "gusty winds"; break;
    case 41..50: str += "strong winds"; break;
    case 51..60: str += "gale-force winds"; break;
    case 61..1000: str += "storm-force winds"; break;
    default: str += "no wind at all"; break;
  }
  if (!obscured) {
    if(rain)
      str += ", ";
    else
      str += " and ";
    switch(cloud) {
      case -1000..5: str += "a beautifully clear sky"; break;
      case 6..10: str += "a few high level cirrus clouds"; break;
      case 11..25: str += "scattered puffy clouds"; break;
      case 26..40: str += "some puffy clouds"; break;
      case 41..60: str += "many puffy clouds"; break;
      case 61..80: str += "medium cloud cover"; break;
      case 81..110: str += "dense cloud cover"; break;
      case 111..130: str += "packed cloud cover"; break;
      case 131..160: str += "thick black clouds"; break;
      case 161..1000: str += "thick heavy storm clouds"; break;
    }
  }
  if(rain) {
    str += " and ";
    switch(rain) {
      case -1000..20: str += "light"; break;
      case 21..40:
        if(wind < 20)
          str += "steady";
        else
          str += "driving";
      break;
      case 41..60: str += "heavy"; break;
      case 61..500:
        if(rt == WEATHER_RAIN_TYPE)
          str += "torrential";
        else
          str += "very heavy";
      break;
    }
    str += " ";
    str += ({"", "snow", "sleet", "rain"})[rt];
  }
  if (obscured) {
    str += ".  " + obscured;
  }
  if((rain > 20) && (wind > 30)) {
    if (obscured)
      str += ".\nPeals of thunder echo overhead";
    else
      str += ".\nPeals of thunder and streaks of lightning rend the sky";
  }
  return str;
}
int next_update() {
  return _lastupdate + UPDATE_SPEED;
}
void dest_me() {
  unguarded((: save_object, FILE_NAME :));
}
int query_rain_type(int temp, int rain) {
  int type;
  if (rain > 0)
    switch(temp) {
    case -1000..-2:
      type = WEATHER_SNOW_TYPE;
      break;
    case -1..3:
      type = WEATHER_SLEET_TYPE;
      break;
    case 4..1000:
      type = WEATHER_RAIN_TYPE;
      break;
    }
  else
    type = WEATHER_NO_RAIN_TYPE;
  return type;
}
int query_snowing(object env) {
  int *warray;
  if(!env)
    return 0;
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
    return (query_rain_type(warray[0], warray[3]) == WEATHER_SNOW_TYPE)? 1 : 0;
  return (query_rain_type(temperature_index(env),
                          rain_index(env)) == WEATHER_SNOW_TYPE) ? 1 : 0;
}
int query_raining(object env) {
  int *warray;
  if(!env)
    return 0;
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
  {
    return (query_rain_type(warray[0], warray[3]) > WEATHER_SNOW_TYPE) ? 1 : 0;
  }
  return (query_rain_type(temperature_index(env),
                          rain_index(env)) > WEATHER_SNOW_TYPE) ? 1 : 0;
}
int query_temperature(object env) {
  int *warray;
  if(!env)
    return 0;
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
    return warray[0];
  return temperature_index(env);
}
int query_cloud(object env) {
  int *warray;
  if(!env)
    return 0;
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
    return warray[1];
  return cloud_index(env);
}
int query_windsp(object env) {
  int *warray;
  if(!env)
    return 0;
  if(function_exists("room_weather", env) &&
     !catch(warray = (int *)env->room_weather(temperature_index(env),
                                              cloud_index(env),
                                              calc_actual(env, WINDSP),
                                              rain_index(env))))
    return warray[2];
  return calc_actual(env, WINDSP);
}
int calc_variance(string climate, int type, int seasonal) {
  int diff, ret;
  diff = seasonal - _pattern[climate][type];
  if(diff < 0)
    ret = - random(diff * 2);
  else
    ret = random(diff * 2);
  if(random(2))
    ret += random(_variance[type]);
  else
    ret -= random(_variance[type]);
  return ret;
}
void set_day() {
  int min;
  _toy = (day_number() < (DIY / 2)) ? day_number() :
  (DIY / 2) - (day_number() % (DIY / 2));
  min = minute_number();
  _sunrise = 6 * AM_MINUTES_PER_HOUR;
  _sunset = 20 * AM_MINUTES_PER_HOUR;
  _sunrise += (100 - _toy);
  _sunset -= (100 - _toy);
  if((min <= _sunrise) || (min >= _sunset))
    _day = 0;
  else {
    if((min > _sunrise) && (min < _sunrise + 30))
      _day = (min-_sunrise) / 3;
    else if((min < _sunset) && (min > _sunset - 30))
      _day = (_sunset-min) / 3;
    else
      _day = 10;
  }
}
void migrate(string climate, int type) {
  int diff;
  diff = _pattern[climate][type] - _current[climate][type];
  if(diff > (_variance[type] / 2))
    diff = _variance[type] / 2;
  if(diff < 0)
    _current[climate][type] -= random(random(-diff));
  else
    _current[climate][type] += random(random(diff));
}
int check_umbrella(object ob) {
  if ( ob )
    return (int)ob->query_property( "umbrella" );
  return 0;
}
void do_inform(object who, int old_temp, int old_cloud, int old_rain,
               int old_day) {
  string str, where;
  int new_temp, new_cloud, new_wind, new_rain;
  int old_rain_type, new_rain_type;
  int *warray;
  new_temp = temperature_index(environment(who));
  new_rain = rain_index(environment(who));
  new_wind = calc_actual(environment(who), WINDSP);
  new_cloud = cloud_index(environment(who));
  if(function_exists("room_weather", environment(who)) &&
     !catch(warray = (int *)environment(who)->room_weather(new_temp, new_cloud,
                                                   new_wind, new_rain))) {
    new_temp = warray[0];
    new_cloud = warray[1];
    new_wind = warray[2];
    new_rain = warray[3];
  }
  if(who->query_name() == "ceres")
    tell_object(who, sprintf("%s: ot %d, or: %d, oc: %d, "
                             "nt %d, nr: %d, nc: %d, nw: %d",
                             who->query_name(),
                             old_temp, old_rain, old_cloud, new_temp,
                             new_rain, new_cloud, new_wind));
  old_rain_type = query_rain_type(old_temp, old_rain);
  new_rain_type = query_rain_type(new_temp, new_rain);
  str = "";
  if(_day != old_day) {
    where = sun_direction( 1 );
    if((old_day == 10)  && (_day < 10))
      str += "The sun starts to set slowly on the "+where+" horizon.\n";
    else if((old_day > 0) && (_day == 0))
      str += "The sun disappears from view below the "+where+" horizon.\n";
    else if((old_day > _day) && (_day < 9) && (_day > 0))
      str += "The sun sinks further below the "+where+" horizon.\n";
    where = sun_direction( 0 );
    if((_day > 0) && (old_day == 0))
      str += "The "+where+" sky starts to lighten as the sun peeks over the "+
        "horizon.\n";
    else if((_day == 10) && (old_day < 10))
      str += "The sun rises above the "+where+" horizon and greets you "+
        "for a new day.\n";
    else if((_day > old_day) && (_day < 9) && (_day > 0))
      str += "The sun rises further above the "+where+" horizon lightening "+
        "the sky as morning arrives.\n";
  }
  if(_day && (old_cloud != new_cloud)) {
    if((old_cloud < 60) && (new_cloud > 20) && (!(new_cloud % 2)))
      str += "The " + query_tod()+ " sun disappears behind a cloud.\n";
    else if((old_cloud > 20) && (new_cloud < 60) && (new_cloud % 2))
      str += "The " + query_tod() + " sun peeks out from behind a cloud.\n";
  }
  if(old_rain_type != new_rain_type) {
    str += ({"", "It has stopped snowing", "It has stopped sleeting",
             "It has stopped raining"})[old_rain_type];
    if(old_rain_type && new_rain_type)
      str += " and started ";
    else if(new_rain_type)
      str += "It has started ";
    str += ({"", "snowing", "sleeting", "raining"})[new_rain_type];
    str += ".\n";
  } else if(new_rain_type > 0)
    str += "The "+({"", "snow", "sleet", "rain"})[new_rain_type]+
      " continues to fall.\n";
  if(new_rain_type)
    if((!sizeof(filter_array(who->query_holding(), "check_umbrella",
                            this_object())) &&
       !sizeof(filter_array(who->query_wearing(), "check_umbrella",
                          this_object()))) || !random(50))
    {
      who->add_effect("/std/effects/other/wetness",
                      ((new_rain * new_rain_type) / 2) * (UPDATE_SPEED/60));
    }
  if(str != "")
    tell_object(who, who->colour_event("weather", "%^ORANGE%^")+str+
                "%^RESET%^");
}
string sun_direction(int which) {
  switch(((time()+(AM_SECONDS_PER_HALF_YEAR * which)) %
          (AM_SECONDS_PER_HALF_YEAR*2)) / AM_SECONDS_PER_DAY) {
  case 0..174:
    return "widdershins";
  case 175..225:
    return "hubwards";
  case 226..574:
    return "turnwise";
  case 575..625:
    return "rimward";
  default:
    return "widdershins";
  }
}
void do_room_inform(object what, int old_temp, int old_cloud, int old_rain,
        int old_day, int notifications) {
  int new_cloud, new_rain, new_wind, new_temp;
  int *warray;
  int has_changed = 0;
  new_temp = temperature_index(what);
  new_cloud = cloud_index(what);
  new_wind = calc_actual(what, WINDSP);
  new_rain = rain_index(what);
  if(function_exists("room_weather", what) &&
     !catch(warray = (int *)what->room_weather(new_temp, new_cloud,
                                       new_wind, new_rain))) {
    new_temp = warray[0];
    new_cloud = warray[1];
    new_wind = warray[2];
    new_rain = warray[3];
  }
  if(_day != old_day && (notifications & NOTIFY_DAY))
    has_changed += NOTIFY_DAY;
  if(old_temp != new_temp && (notifications & NOTIFY_TEMPERATURE))
    has_changed += NOTIFY_TEMPERATURE;
  if(old_cloud != new_cloud && (notifications & NOTIFY_CLOUD))
    has_changed += NOTIFY_CLOUD;
  if(old_rain != new_rain && (notifications & NOTIFY_RAIN))
    has_changed += NOTIFY_RAIN;
  if(has_changed) {
    call_out( "notify_room", 1, what, has_changed,
      _day, new_temp, new_cloud, new_rain );
  }
}
void notify_room( object what, int has_changed,
  int day, int temp, int cloud, int rain)
{
  if(what)
    what->event_weather( has_changed, day, temp, cloud, rain);
}
int query_sunrise(int doy) {
  int toy;
  toy = (doy < (DIY / 2)) ? doy : (DIY / 2) - (doy % (DIY / 2));
  return (6 * AM_MINUTES_PER_HOUR) + (100 - toy);
}
int query_sunset(int doy) {
  int toy;
  toy = (doy < (DIY / 2)) ? doy : (DIY / 2) - (doy % (DIY / 2));
  return (20 * AM_MINUTES_PER_HOUR) - (100 - toy);
}
void update_pattern() {
  int toy, temp, wind, cloud, tvar, wvar, cvar;
  string climate;
  call_out("update_pattern", CYCLE_SPEED);
  toy = (day_number() < (DIY / 2)) ? day_number() :
    (DIY / 2) - (day_number() % (DIY / 2));
  foreach(climate in CLIMATES) {
    switch(climate) {
    case "Af":
      temp = 30 + (toy / 40);
      cloud = 50 + random(100);
      wind = random(10);
      break;
    case "Am":
      temp = 30 + (toy / 20);
      cloud = -25 + sqrt(toy) * 10;
      wind = random(10);
      break;
    case "Aw":
      temp = 20 + (toy / 10);
      cloud = toy - 50;
      wind = random(10);
      break;
    case "Bw":
      temp = 30 + (toy / 20);
      cloud = (100 - toy/2) - 50;
      wind = random(10);
      break;
    case "Bs":
      temp = 25 + (toy / 20);
      cloud = ((200 - toy) / 2) - 12;
      wind = random(10);
      break;
    case "Cfa":
      temp = (toy / 8) + 15;
      cloud = ((225 - toy) / 2) - 25;
      wind = 10 - (toy / 8);
      break;
    case "Cs":
      temp = (toy / 12) + 10;
      cloud = ((225 - toy) / 2) - 50;
      wind = 10 - (toy / 8);
      break;
    case "Cfb":
      temp = (toy / 6) - 5;
      cloud = ((225 - toy) / 2) - 25;
      wind = 10 - (toy / 8);
      break;
    case "Dw":
      temp = (toy / 5) - 10;
      cloud = toy / 2;
      wind = 15 - (toy / 8);
      break;
    case "Ds":
      temp = (toy / 5) - 10;
      cloud = (200 - toy) / 2;
      wind = 15 - (toy / 8);
      break;
    case "Df":
      temp = (toy / 5) - 10;
      cloud = ((200 - toy) / 4) + 50;
      wind = 15 - (toy / 8);
      break;
    case "Et":
      temp = (toy / 20) - 10;
      cloud = ((225 - toy) / 2) - 25;
      wind = 25 - (toy / 8);
      break;
    case "Ef":
      temp = (toy / 10) - 30;
      cloud = ((225 - toy) / 2) - 25;
      wind = 25 - (toy / 8);
      break;
    case "H":
      temp = (toy / 10) - 10;
      cloud = ((225 - toy) / 2);
      wind = 35 - (toy / 8);
      break;
    }
    tvar = calc_variance(climate, TEMP, temp);
    cvar = calc_variance(climate, CLOUD, cloud);
    wvar = calc_variance(climate, WINDSP, wind);
    _pattern[climate] =  ({ temp + tvar, cloud + cvar, wind + wvar });
  }
  unguarded((: save_object, FILE_NAME :));
}
void update_weather() {
  int *warray, notifications;
  mapping list, roomlist, newrooms;
  object user, room;
  string climate;
  _lastupdate = time();
  call_out("update_weather", UPDATE_SPEED);
  list = ([ ]);
  roomlist = ([ ]);
  foreach(user in filter(users(),
                         (: $1 && environment($1) &&
                          environment($1)->query_property("location") ==
                          "outside" :))) {
    if(function_exists("room_weather", environment(user)) &&
       !catch(warray = (int *)environment(user)->room_weather(
                                 (int)temperature_index(environment(user)),
                                 (int)cloud_index(environment(user)),
                                 (int)calc_actual(environment(user), WINDSP),
                                 (int)rain_index(environment(user))))) {
      list[user] = ({ warray[0], warray[1], warray[3], _day});
    } else {
      list[user] = ({ (int)temperature_index(environment(user)),
                        (int)cloud_index(environment(user)),
                        (int)rain_index(environment(user)),
                        _day});
    }
  }
  newrooms = ([ ]);
  foreach (room, notifications in _rooms)  {
    if (room)
      newrooms[room] = notifications;
  }
  _rooms = copy(newrooms);
  foreach(room, notifications in _rooms) {
    if(function_exists("room_weather", room) &&
       !catch(warray = (int *)room->room_weather((int)temperature_index(room),
                                                 (int)cloud_index(room),
                                               (int)calc_actual(room, WINDSP),
                                                 (int)rain_index(room) ))) {
      roomlist[room] = ({ warray[0], warray[1], warray[3], _day});
    } else {
      roomlist[room] = ({ (int)temperature_index(room),
                            (int)cloud_index(room),
                            (int)rain_index(room),
                            _day });
    }
  }
  if((moonupdate + (AM_SECONDS_PER_DAY * 2)) < time()) {
    mooncycle++;
    mooncycle %= 14;
    moonupdate = time();
  }
  foreach(climate in CLIMATES) {
    migrate(climate, TEMP);
    migrate(climate, CLOUD);
    migrate(climate, WINDSP);
  }
  set_day();
  unguarded((: save_object, FILE_NAME :));
  foreach(user, warray in list) {
    do_inform(user, warray[0], warray[1], warray[2], warray[3]);
  }
  foreach(room, notifications in _rooms) {
      do_room_inform(room, roomlist[room][0], roomlist[room][1],
                     roomlist[room][2], roomlist[room][3], notifications);
      map_delete(_rooms, room);
  }
}
void print_stats(object here) {
  string climate, *weather;
  if(here)
    climate = here->query_climate();
  weather = ({ temperature_index(here), cloud_index(here),
                 calc_actual(here, WINDSP) });
  printf("Climate: %s toy: %d tod: %s [%d]\n"
         "here: %O\ncurrent: %O\npattern: %O\nvariance: %O\n",
         climate, _toy, query_tod(), 10 - query_day(here), weather,
         _current[climate], _pattern[climate], _variance);
  printf("Sunrise at: %d:%02d, sunset at: %d:%02d\n",
         _sunrise/60, _sunrise%60, _sunset/60, _sunset%60);
}
int *query_mooncycle() {
  return ({ mooncycle, 0});
}
void set_variance(int temp, int cloud, int wind) {
  _variance = ({temp, cloud, wind});
  unguarded((: save_object, FILE_NAME :));
}
void reset_weather() {
  int toy, temp, wind, cloud;
  string climate;
  toy = (day_number() < (DIY / 2)) ? day_number() :
    (DIY / 2) - (day_number() % (DIY / 2));
  foreach(climate in CLIMATES) {
    switch(climate) {
    case "Af":
      temp = 25 + (toy / 40);
      cloud = 50 + random(100);
      wind = random(10);
      break;
    case "Am":
      temp = 20 + (toy / 20);
      cloud = -25 + sqrt(toy) * 10;
      wind = random(10);
      break;
    case "Aw":
      temp = 20 + (toy / 20);
      cloud = toy - 50;
      wind = random(10);
      break;
    case "Bw":
      temp = 30 + (toy / 20);
      cloud = (100 - toy/2) - 50;
      wind = random(10);
      break;
    case "Bs":
      temp = 25 + (toy / 20);
      cloud = ((200 - toy) / 2) - 12;
      wind = random(10);
      break;
    case "Cfa":
      temp = (toy / 8) + 15;
      cloud = ((225 - toy) / 2) - 25;
      wind = 10 - (toy / 8);
      break;
    case "Cs":
      temp = (toy / 12) + 10;
      cloud = ((225 - toy) / 2) - 50;
      wind = 10 - (toy / 8);
      break;
    case "Cfb":
      temp = (toy / 6) - 5;
      cloud = ((225 - toy) / 2) - 25;
      wind = 10 - (toy / 8);
      break;
    case "Dw":
      temp = (toy / 5) - 10;
      cloud = toy / 2;
      wind = 15 - (toy / 8);
      break;
    case "Ds":
      temp = (toy / 5) - 10;
      cloud = (200 - toy) / 2;
      wind = 15 - (toy / 8);
      break;
    case "Df":
      temp = (toy / 5) - 10;
      cloud = ((200 - toy) / 4) + 50;
      wind = 15 - (toy / 8);
      break;
    case "Et":
      temp = (toy / 20) - 10;
      cloud = ((225 - toy) / 2) - 25;
      wind = 25 - (toy / 8);
      break;
    case "Ef":
      temp = (toy / 10) - 30;
      cloud = ((225 - toy) / 2) - 25;
      wind = 25 - (toy / 8);
      break;
    case "H":
      temp = (toy / 10) - 10;
      cloud = ((225 - toy) / 2);
      wind = 35 - (toy / 8);
      break;
    }
    _pattern[climate] =  ({ temp, cloud, wind });
    _current[climate] = ({ temp, cloud, wind });
  }
  unguarded((: save_object, FILE_NAME :));
}
mapping query_dynamic_auto_load() {
   return ([ "rooms" : _rooms ]);
}
void init_dynamic_arg(mapping map, object) {
   _rooms = map["rooms"];
   if (!_rooms) {
      _rooms = ([ ]);
   }
}

==================================================
FILE: handlers/world_map.c
==================================================

#include <terrain_map.h>
class region {
   mixed* terrains;
   string* features;
   int last_touched;
}
#define SAVE_DIR "/save/world_map/"
#define BOUNDARY TERRAIN_MAP_WORLD_BOUNDARY
#define REGION_SIZE TERRAIN_MAP_WORLD_REGION_SIZE
#define REGION_BOUNDARY TERRAIN_MAP_WORLD_REGION_BOUNDARY
#define OFFSET TERRAIN_MAP_WORLD_OFFSET
#define REGION_WIDTH TERRAIN_MAP_WORLD_REGION_WIDTH
void load_me();
private void generate_main_templates();
private void generate_blocking_templates();
private nosave mixed* _regions;
private nosave mixed* _templates;
private nosave mixed* _blocking_templates;
void create() {
   _regions = allocate(REGION_WIDTH, (: allocate(REGION_WIDTH) :));
   seteuid(getuid());
   generate_main_templates();
   generate_blocking_templates();
}
private void generate_main_templates() {
   int size;
   mixed* last;
   int x;
   int y;
   int u;
   int v;
   int e;
   int i;
   _templates = allocate(12);
   last = ({ ({ 1 }) });
   for (size = 0; size < sizeof(_templates); size++) {
      for (i = 0; i < sizeof(last); i++) {
         last[i] = ({ 0 }) + last[i] + ({ 0 });
      }
      _templates[size] = ({ allocate((size + 1) * 2 + 1) }) + last +
                         ({ allocate((size + 1) * 2 + 1) });
      x = 0;
      y = size + 1;
      u = 1;
      v = 2 * (size + 1) - 1;
      e = 0;
      while (x <= y) {
         _templates[size][size + 1 + x][size + 1 + y] = 1;
         _templates[size][size + 1 + x][size + 1 - y] = 1;
         _templates[size][size + 1 - x][size + 1 + y] = 1;
         _templates[size][size + 1 - x][size + 1 - y] = 1;
         _templates[size][size + 1 + y][size + 1 + x] = 1;
         _templates[size][size + 1 + y][size + 1 - x] = 1;
         _templates[size][size + 1 - y][size + 1 + x] = 1;
         _templates[size][size + 1 - y][size + 1 - x] = 1;
         if (size > 0) {
            _templates[size][size + 1 + x - 1][size + 1 + y] = 1;
            _templates[size][size + 1 + x - 1][size + 1 - y] = 1;
            _templates[size][size + 1 - x + 1][size + 1 + y] = 1;
            _templates[size][size + 1 - x + 1][size + 1 - y] = 1;
            _templates[size][size + 1 + y - 1][size + 1 + x] = 1;
            _templates[size][size + 1 + y - 1][size + 1 - x] = 1;
            _templates[size][size + 1 - y + 1][size + 1 + x] = 1;
            _templates[size][size + 1 - y + 1][size + 1 - x] = 1;
         }
         x++;
         e += u;
         u += 2;
         if (v < 2 * e) {
            y--;
            e -= v;
            v -= 2;
         }
         if (x > y) {
            break;
         }
      }
      last = copy(_templates[size]);
   }
}
mixed* generate_blocking(int x, int y, string* start,
                          string* straight, string* diagonal) {
   int i;
   int dx;
   int ex;
   int dy;
   int balance;
   int sx;
   int sy;
   int blocked;
   int blocked_straight;
   int blocked_diagonal;
   int first_block;
   first_block = -1;
   for (i = 0; i <= sizeof(start); i++) {
      sx = 0;
      sy = 0;
      ex = sizeof(start);
      dx = sizeof(start);
      dy = i;
      dy <<= 1;
      balance = dy - dx;
      dx <<= 1;
      blocked_straight = blocked_diagonal = blocked = 0;
      while (sx != ex) {
         if (blocked) {
            if (first_block == -1) {
               first_block = i;
            }
            start[sy] = start[sy][0..sx-1] + "*" + start[sy][sx+1..];
         } else {
            start[sy] = start[sy][0..sx-1] + " " + start[sy][sx+1..];
         }
         if (blocked_straight) {
            straight[sy] = straight[sy][0..sx-1] + "*" + straight[sy][sx+1..];
         } else {
            straight[sy] = straight[sy][0..sx-1] + " " + straight[sy][sx+1..];
         }
         if (blocked_diagonal) {
            diagonal[sy] = diagonal[sy][0..sx-1] + "*" + diagonal[sy][sx+1..];
         } else {
            diagonal[sy] = diagonal[sy][0..sx-1] + " " + diagonal[sy][sx+1..];
         }
         if (sx == x && sy == y) {
            blocked_diagonal = blocked_straight = blocked = 1;
            diagonal[sy] = diagonal[sy][0..sx-1] + "@" + diagonal[sy][sx+1..];
            start[sy] = start[sy][0..sx-1] + "@" + start[sy][sx+1..];
            straight[sy] = straight[sy][0..sx-1] + "@" + straight[sy][sx+1..];
         }
         if (sx == x && sy == y + 1) {
            blocked_straight = 1;
            straight[sy] = straight[sy][0..sx-1] + "|" + straight[sy][sx+1..];
         }
         if (sx == x + 1 && sy == y + 1) {
            blocked_diagonal = 1;
            diagonal[sy] = diagonal[sy][0..sx-1] + "\\" + diagonal[sy][sx+1..];
         }
         if (balance >= 0) {
            sy++;
            balance -= dx;
         }
         balance += dy;
         sx++;
      }
   }
   if (first_block >= (sizeof(start) / 2)) {
      for (i = sizeof(start); i >= 6; i--) {
         sx = 0;
         sy = 0;
         ex = sizeof(start);
         dx = sizeof(start);
         dy = i;
         dy <<= 1;
         balance = dy - dx;
         dx <<= 1;
         blocked = 0;
         while (sx != ex) {
            start[sy] = start[sy][0..sx-1] + " " + start[sy][sx+1..];
            if (sx == x && sy == y) {
               break;
            }
            if (balance >= 0) {
               sy++;
               balance -= dx;
            }
            balance += dy;
            sx++;
         }
      }
   }
   return ({ start, straight, diagonal });
}
private void generate_blocking_templates() {
   int x;
   int y;
   int size;
   mixed* basic;
   string* start;
   string line;
   basic = _templates[<1];
   size = sizeof(_templates);
   line = "";
   for (x = 0; x < size + 1; x++) {
      line += " ";
   }
   start = allocate(size + 1, line);
   _blocking_templates = allocate(size + 1, ({ }));
   for (x = 0; x < size + 1; x++) {
      _blocking_templates[x] = allocate(size + 1);
   }
   for (x = 0; x < size + 1; x++) {
      for (y = x; y < size + 1; y++) {
         if (basic[x + size][y + size] && (x != 0 || y != 0)) {
            _blocking_templates[x][y] = generate_blocking(y, x, copy(start), copy(start), copy(start));
         }
      }
   }
}
string *query_blocking_template(int x, int y, int type) {
   if (arrayp(_blocking_templates[x][y])) {
      return copy(_blocking_templates[x][y][type]);
   }
   return 0;
}
mixed* query_map_template(int size) {
   return copy(_templates[size - 1]);
}
void load_region(int x, int y) {
   class region region;
   string fname;
   if (_regions[x][y]) {
      _regions[x][y]->last_touched = time();
      return ;
   }
   fname = SAVE_DIR + "region_" + x + "_" + y;
   if (unguarded((: file_size($(fname)) :)) > 0) {
      region = unguarded( (: restore_variable(read_file($(fname), 1)) :));
   } else {
      region = new(class region,
                   terrains : allocate(REGION_SIZE, (: allocate(REGION_SIZE) :)),
                   features : ({ }));
   }
   _regions[x][y] = region;
   _regions[x][y]->last_touched = time();
}
void save_region(int x, int y) {
   string fname;
   class region region;
   if (_regions[x][y]) {
      region = _regions[x][y];
      fname = SAVE_DIR + "region_" + x + "_" + y;
      unguarded( (: write_file($(fname), save_variable($(region)), 1) :));
   }
}
int add_terrain(string path, int x1, int y1, int x2, int y2) {
   int tmp;
   int region_x;
   int region_y;
   if (x1 > x2) {
      tmp = x1;
      x1 = x2;
      x2 = tmp;
   }
   if (y1 > y2) {
      tmp = y1;
      y1 = y2;
      y2 = tmp;
   }
   if (x2 - x1 != BOUNDARY ||
       y2 - y1 != BOUNDARY) {
      debug_printf("Incorrect terrain size (%d x %d): %s\n",
                  x2 - x1, y2 - y1, path);
      return 0;
   }
   if (x1 % BOUNDARY ||
       y1 % BOUNDARY) {
      debug_printf("Incorrect boundary (%d - %d): %s\n",
                  x1 % BOUNDARY, y1 % BOUNDARY, path);
      return 0;
   }
   x1 = ((x1 + OFFSET) / BOUNDARY);
   y1 = ((y1 + OFFSET) / BOUNDARY);
   region_x = x1 / REGION_SIZE;
   region_y = y1 / REGION_SIZE;
   load_region(region_x, region_y);
   x2 = x1 % REGION_SIZE;
   y2 = y1 % REGION_SIZE;
   _regions[region_x][region_y]->terrains[x2][y2] = path;
   save_region(region_x, region_y);
   debug_printf("Added terrain (%d {%d}, %d {%d}) [%d,  %d]: %s\n",
                 x1, x2, y1, y2, region_x, region_y, path);
   return 1;
}
string find_terrain_at(int x, int y) {
   int region_x;
   int region_y;
   x = ((x + OFFSET) / BOUNDARY);
   y = ((y + OFFSET) / BOUNDARY);
   region_x = x / REGION_SIZE;
   region_y = y / REGION_SIZE;
   load_region(region_x, region_y);
   return _regions[region_x][region_y]->terrains[x % REGION_SIZE][y % REGION_SIZE];
}
string find_room_at(int x, int y) {
   string path;
   path = find_terrain_at(x, y);
   if (path) {
      return path->find_room_at_real_coord(x, y);
   }
   return 0;
}
void add_feature(string feature) {
   int x;
   int y;
   for (x = 0; x < REGION_WIDTH; x++) {
      for (y = 0; y < REGION_WIDTH; y++) {
         if (feature->is_inside_region(
                                (x * REGION_WIDTH) * BOUNDARY - OFFSET,
                                (y * REGION_WIDTH) * BOUNDARY - OFFSET,
                                ((x + 1) * REGION_WIDTH) * BOUNDARY - OFFSET,
                                ((y + 1) * REGION_WIDTH) * BOUNDARY - OFFSET)) {
            load_region(x, y);
            _regions[x][y]->features |= ({ feature });
            save_region(x, y);
            debug_printf("Added feature to region %d, %d\n", x, y);
         }
      }
   }
}
void remove_feature(string feature) {
   int x;
   int y;
   for (x = 0; x < REGION_WIDTH; x++) {
      for (y = 0; y < REGION_WIDTH; y++) {
         load_region(x, y);
         if (member_array(feature, _regions[x][y]->features) != -1) {
            _regions[x][y]->features -= ({ feature });
            save_region(x, y);
         }
      }
   }
}
string* query_features_at(int x, int y) {
   int region_x;
   int region_y;
   x = ((x + OFFSET) / BOUNDARY);
   y = ((y + OFFSET) / BOUNDARY);
   region_x = x / REGION_WIDTH;
   region_y = y / REGION_WIDTH;
   load_region(region_x, region_y);
   return _regions[region_x][region_y]->features;
}
string* query_features_in_region(int x1_orig, int y1_orig, int x2_orig, int y2_orig) {
   int region_x;
   int region_y;
   int x1;
   int y1;
   int x2;
   int y2;
   int tmp;
   string* features;
   string feat;
   x1 = ((x1_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   y1 = ((y1_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   x2 = ((x2_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   y2 = ((y2_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   if (x1 > x2) {
      tmp = x1;
      x1 = x2;
      x2 = tmp;
   }
   if (y1 > y2) {
      tmp = y1;
      y1 = y2;
      y2 = tmp;
   }
   features = ({ });
   if (x1 < 0) {
      x1 = 0;
   }
   if (y1 < 0) {
      y1 = 0;
   }
   if (x2 >= REGION_WIDTH) {
      x2 = REGION_WIDTH - 1;
   }
   if (y2 >= REGION_WIDTH) {
      y2 = REGION_WIDTH - 1;
   }
   for (region_x = x1; region_x <= x2; region_x++) {
      for (region_y = y1; region_y <= y2; region_y++) {
         load_region(region_x, region_y);
         foreach (feat in _regions[region_x][region_y]->features) {
            if (feat->is_inside_region(x1_orig, y1_orig, x2_orig, y2_orig)) {
               features |= ({ feat });
            }
         }
      }
   }
   return features;
}

==================================================
FILE: handlers/inherit/case_control.c
==================================================

#define NOMIC_SYSTEM_NO_CLASSES
#define NOMIC_SYSTEM_CASE_CLASSES
#include <nomic_system.h>
private mapping _open_cases;
private mapping _recently_closed_cases;
private mapping _closed_cases;
private int _next_case_id;
private int _next_note_id;
void save_me();
void send_council_inform(string area, int only_magistrates,
                         string mess);
void create() {
   _open_cases = ([ ]);
   _closed_cases = ([ ]);
   _recently_closed_cases = ([ ]);
   _next_case_id = 1;
   _next_note_id = 1;
}
void create_area(string area) {
   if (_open_cases[area]) {
      return ;
   }
   _open_cases[area] = ({ });
   _closed_cases[area] = ({ });
   _recently_closed_cases[area] = ({ });
}
int* query_open_cases(string area) {
   return _open_cases[area];
}
int* query_closed_cases(string area) {
   return _closed_cases[area];
}
int* query_recently_closed_cases(string area) {
   return _recently_closed_cases[area];
}
string query_case_file_name(int id) {
   return NOMIC_CASE_SAVE + sprintf("cases/%02d/%d_case", id % 20, id);
}
int query_next_case_id() {
   int next;
   do {
      next = _next_case_id++;
   } while (sizeof(stat(query_case_file_name(next))));
   return next;
}
private void save_case(class nomic_case stuff) {
   string fname;
   string tmp;
   fname = query_case_file_name(stuff->id);
   tmp = save_variable(stuff);
   unguarded((: write_file($(fname), $(tmp), 1) :));
}
string query_note_file_name(int id) {
   return NOMIC_CASE_SAVE + sprintf("notes/%02d/%d_note", id % 20, id);
}
int query_next_note_id() {
   int next;
   do {
      next = _next_note_id++;
   } while (sizeof(stat(query_note_file_name(next))));
   return next;
}
private void save_note(class nomic_case_note stuff) {
   string fname;
   string tmp;
   fname = query_note_file_name(stuff->id);
   tmp = save_variable(stuff);
   unguarded((: write_file($(fname), $(tmp) ) :));
}
private int create_case(string opener, string short, string* people) {
   class nomic_case new_case;
   new_case = new(class nomic_case);
   new_case->id = query_next_case_id();
   new_case->opener = opener;
   new_case->short = short;
   new_case->people = people;
   new_case->notes = ({ });
   new_case->events = ({ });
   new_case->time_opened = time();
   save_case(new_case);
   return new_case->id;
}
private int create_note(string person, string text) {
   class nomic_case_note new_note;
   new_note = new(class nomic_case_note);
   new_note->id = query_next_note_id();
   new_note->person = person;
   new_note->text = text;
   new_note->time_created = time();
   save_note(new_note);
   return new_note->id;
}
private class nomic_case_event create_event(int type, string person,
                                            string mess, mixed data) {
   class nomic_case_event event;
   event = new(class nomic_case_event);
   event->type = type;
   event->mess = mess;
   event->person = person;
   event->event_time = time();
   event->data = data;
   return event;
}
string query_event_name(int type) {
   switch (type) {
   case NOMIC_CASE_EVENT_CLOSE :
      return "closed case";
   case NOMIC_CASE_EVENT_APPEAL :
      return "appealed case";
   case NOMIC_CASE_EVENT_ADD_PERSON :
      return "add person";
   case NOMIC_CASE_EVENT_REMOVE_PERSON :
      return "remove person";
   default :
      return "unknown";
   }
}
class nomic_case query_open_case(string area, int id) {
   string fname;
   string tmp;
   if (!_open_cases[area]) {
      return 0;
   }
   if (member_array(id, _open_cases[area]) == -1) {
      return 0;
   }
   fname = query_case_file_name(id);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
class nomic_case query_recently_closed_case(string area, int id) {
   string fname;
   string tmp;
   if (!_recently_closed_cases[area]) {
      return 0;
   }
   if (member_array(id, _recently_closed_cases[area]) == -1) {
      return 0;
   }
   fname = query_case_file_name(id);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
class nomic_case query_closed_case(string area, int id) {
   string fname;
   string tmp;
   if (!_closed_cases[area]) {
      return 0;
   }
   if (member_array(id, _closed_cases[area]) == -1) {
      return 0;
   }
   fname = query_case_file_name(id);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
class nomic_case_note query_note(int note_num) {
   string fname;
   string tmp;
   fname = query_note_file_name(note_num);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
int add_new_case(string area, string opener, string short, string* people) {
   int case_id;
   if (!_open_cases[area]) {
      return 0;
   }
   case_id = create_case(opener, short, people);
   _open_cases[area] += ({ case_id });
   save_me();
   send_council_inform(area, 1, opener + " opened a case with " +
                      query_multiple_short(people));
   return case_id;
}
int close_case(string area, int id, string closer, string result,
               mixed data) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_open_case(area, id);
   if (!the_case || !stringp(result)) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_CLOSE, closer, result, data);
   the_case->events += ({ event });
   save_case(the_case);
   _open_cases[area] -= ({ the_case->id });
   _recently_closed_cases[area] += ({ the_case->id });
   save_me();
   send_council_inform(area, 1, closer + " closed a case with " +
                      query_multiple_short(the_case->people));
   return 1;
}
int appeal_case(string area, int id, string appealer, string reason) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_recently_closed_case(area, id);
   if (!the_case || !stringp(reason)) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_APPEAL, appealer, reason, 0);
   the_case->events += ({ event });
   save_case(the_case);
   _recently_closed_cases[area] -= ({ the_case->id });
   _open_cases[area] += ({ the_case->id });
   save_me();
   send_council_inform(area, 1, appealer + " appeals a case with " +
                      query_multiple_short(the_case->people));
   return 1;
}
int add_note_to_case(string area, int id, string person, string text) {
   class nomic_case the_case;
   int note_id;
   the_case = query_open_case(area, id);
   if (!the_case) {
      return 0;
   }
   note_id = create_note(person, text);
   the_case->notes += ({ note_id });
   save_case(the_case);
   save_me();
   return 1;
}
int add_person_to_case(string area, int id, string adder,
                       string person, string text) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_open_case(area, id);
   if (!the_case || !stringp(text) ||
       member_array(person, the_case->people) != -1) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_ADD_PERSON, adder, text, 0);
   the_case->events += ({ event });
   the_case->people += ({ person });
   save_case(the_case);
   return 1;
}
int remove_person_from_case(string area, int id, string remover,
                       string person, string text) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_open_case(area, id);
   if (!the_case || !stringp(text) ||
       member_array(person, the_case->people) == -1) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_REMOVE_PERSON, remover, text, 0);
   the_case->events += ({ event });
   the_case->people -= ({ person });
   save_case(the_case);
   return 1;
}
void update_recently_closed_cases() {
   string area;
   int* stuff;
   int id;
   class nomic_case the_case;
   class nomic_case_event event;
   int last_close;
   foreach (area, stuff in _recently_closed_cases) {
      foreach (id in stuff) {
         the_case = query_recently_closed_case(area, id);
         last_close = 0;
         foreach (event in the_case->events) {
            if (event->type == NOMIC_CASE_EVENT_CLOSE) {
               last_close = event->event_time;
            }
         }
         if (last_close < time() - NOMIC_CASE_APPEAL_TIME) {
            _closed_cases[area] += ({ id });
            _recently_closed_cases[area] -= ({ id });
         }
      }
   }
}

==================================================
FILE: handlers/inherit/citizen_elections.c
==================================================

inherit "/obj/handlers/inherit/citizens";
#include <player_handler.h>
#include <player.h>
#include <board.h>
#define NOMIC_SYSTEM_NO_CLASSES
#include <nomic_system.h>
#define CITIZEN_ELECTION_PHASE_NONE       0
#define CITIZEN_ELECTION_PHASE_NOMINATION 1
#define CITIZEN_ELECTION_PHASE_ELECTION   2
#define CITIZEN_ELECTION_PHASE_GRACE      3
#define CITIZEN_ELECTION_PHASE_DISABLED 4
#define CITIZEN_ELECTION_TIME   (20 * (7 * 24 * 60 * 60))
#define CITIZEN_ELECTION_PHASE_TIME      (10 * 24 * 60 * 60)
#define CITIZEN_PHASE_TIME      (14 * 24 * 60 * 60)
#define CITIZEN_GRACE_TIME      (14 * 24 * 60 * 60)
#define CITIZEN_ELECTION_DISABLED_TIME (14 * 24 * 60 * 60)
class election_data {
   int last_election;
   int phase;
   int phase_start;
   mapping nominations;
   mapping votes;
   string* voted;
}
protected void finish_election_phase(string area);
int post_citizen_message(string area, string subject, string message);
private mapping _elections;
private mapping _boards;
void create() {
   _elections = ([ ]);
   _boards = ([ ]);
   citizens::create();
   call_out("do_next_event", 10);
}
void create_area(string area) {
   _elections[area] = new(class election_data);
   _elections[area]->phase = CITIZEN_ELECTION_PHASE_GRACE;
   _elections[area]->phase_start = time();
   _elections[area]->nominations = ([ ]);
   _elections[area]->votes = ([ ]);
   _elections[area]->voted = ({ });
   ::create_area(area);
}
int query_next_election_time(string area) {
   if (!_elections[area]) {
      return 0;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_GRACE) {
      return _elections[area]->phase_start + CITIZEN_GRACE_TIME;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NONE) {
      return _elections[area]->last_election + CITIZEN_ELECTION_TIME;
   }
   return 0;
}
int query_end_of_phase_time(string area) {
   if (!_elections[area]) {
      return 0;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NONE) {
      return 0;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      return _elections[area]->phase_start + CITIZEN_ELECTION_PHASE_TIME;
   }
   return _elections[area]->phase_start + CITIZEN_PHASE_TIME;
}
protected int query_election_phase(string area) {
   if (!_elections[area]) {
      return CITIZEN_ELECTION_PHASE_NONE;
   }
   return _elections[area]->phase;
}
int is_nomination_phase(string area) {
   return query_election_phase(area) == CITIZEN_ELECTION_PHASE_NOMINATION;
}
int is_election_phase(string area) {
   return query_election_phase(area) == CITIZEN_ELECTION_PHASE_ELECTION;
}
int is_grace_phase(string area) {
   return query_election_phase(area) == CITIZEN_ELECTION_PHASE_GRACE;
}
int nominate_magistrate(string area, string person, string nominator) {
   if (!_elections[area] ||
       !is_citizen_of(area, person) ||
       !is_citizen_of(area, nominator)) {
      return 0;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NOMINATION) {
      if (!_elections[area]->nominations[person]) {
         _elections[area]->nominations[person] = ({ });
      } else if (member_array(nominator,
                              _elections[area]->nominations[person]) != -1) {
         return 0;
      }
      _elections[area]->nominations[person] += ({ nominator });
      save_me();
      return 1;
   }
   return 0;
}
string* query_nominated_by(string area, string person) {
   if (!_elections[area]) {
      return ({ });
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NOMINATION) {
      if (_elections[area]->nominations[person]) {
         return copy(_elections[area]->nominations[person]);
      }
   }
   return ({ });
}
string* query_people_nominated(string area) {
   if (!_elections[area]) {
      return ({ });
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NOMINATION) {
      return keys(_elections[area]->nominations);
   }
   return ({ });
}
int is_nomination_accepted(string area, string person) {
   string* nominations;
   nominations = query_nominated_by(area, person);
   if (sizeof(nominations) >= 2 &&
       member_array(person, nominations) != -1) {
      return 1;
   }
   return 0;
}
int has_voted(string area, string person) {
   if (!_elections[area]) {
      return 0;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      return member_array(person, _elections[area]->voted) != -1;
   }
   return 0;
}
int is_eligible_to_vote_for(string area, string person) {
   if (!_elections[area]) {
      return 0;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      return member_array(person, keys(_elections[area]->votes)) != -1;
   }
   return 0;
}
int vote_for_people(string area, string* people, string voter) {
   string person;
   if (!_elections[area] ||
       !is_citizen_of(area, voter)) {
      return 0;
   }
   foreach (person in people) {
      if (!is_citizen_of(area, person)) {
         return 0;
      }
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      if (has_voted(area, voter)) {
         return 0;
      }
      foreach (person in people) {
         if (is_eligible_to_vote_for(area, person)) {
            _elections[area]->votes[person]++;
         }
      }
      _elections[area]->voted += ({ voter });
      save_me();
      return 1;
   }
   return 0;
}
string* query_can_vote_for(string area) {
   if (!_elections[area]) {
      return ({ });
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      return keys(_elections[area]->votes);
   }
   return ({ });
}
protected void start_election(string area) {
   if (!_elections[area]) {
      return ;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NONE ||
       _elections[area]->phase == CITIZEN_ELECTION_PHASE_GRACE) {
      _elections[area]->votes = ([ ]);
      _elections[area]->voted = ({ });
      _elections[area]->nominations = ([ ]);
      _elections[area]->phase_start = time();
      _elections[area]->phase = CITIZEN_ELECTION_PHASE_NOMINATION;
      save_me();
      post_citizen_message(area, "Nomination phase has started.",
                           "Please go to your council offices and "
                           "nominate\nthe magistrates for office.\n");
   }
}
protected void finish_nomination_phase(string area) {
   string person;
   string* nominators;
   if (!_elections[area]) {
      return ;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NOMINATION) {
      _elections[area]->votes = ([ ]);
      _elections[area]->voted = ({ });
      foreach (person, nominators in _elections[area]->nominations) {
         if (is_citizen_of(area, person) &&
             is_nomination_accepted(area, person) &&
             !PLAYER_HANDLER->test_creator(person)) {
            _elections[area]->votes[person] = 0;
         }
      }
      _elections[area]->phase = CITIZEN_ELECTION_PHASE_ELECTION;
      _elections[area]->phase_start = time();
      _elections[area]->nominations = ([ ]);
      save_me();
      post_citizen_message(area, "Nomination phase finished.",
                           "The people nominated for election are:\n" +
                           implode(map(keys(_elections[area]->votes),
                                       (: "   " + $1 :)), "\n"));
      if (sizeof(keys(_elections[area]->votes)) <=
          query_number_of_magistrates(area)) {
          finish_election_phase(area);
      }
   }
}
protected void finish_election_phase(string area) {
   string* voted;
   string* sorted_voted;
   string high_pk;
   string high_non_pk;
   string person;
   string results;
   int needed;
   int num;
   if (!_elections[area]) {
      return ;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      if (sizeof(keys(_elections[area]->votes)) <=
          query_number_of_magistrates(area)) {
         voted = sort_array(keys(_elections[area]->votes),
                            (: $3[$2] - $3[$1] :), _elections[area]->votes);
         sorted_voted = voted;
      } else {
         voted = sort_array(keys(_elections[area]->votes),
                            (: $3[$2] - $3[$1] :), _elections[area]->votes);
         sorted_voted = voted;
         needed = query_number_of_magistrates(area);
         foreach (person in voted) {
            if (PLAYER_HANDLER->test_player_killer(person)) {
               if (!high_pk) {
                  needed--;
                  high_pk = person;
               }
            } else {
               if (!high_non_pk) {
                  needed--;
                  high_non_pk = person;
               }
            }
            if (high_pk && high_non_pk) {
               break;
            }
         }
         voted -= ({ high_pk, high_non_pk });
         voted = voted[0..needed - 1];
         voted += ({ high_pk, high_non_pk });
         voted -= ({ 0 });
      }
      results = "Votes:\n";
      foreach (person in sorted_voted) {
         results += sprintf("%20s %d\n", capitalize(person),
                            _elections[area]->votes[person]);
      }
      results += "\nElected officals are " + query_multiple_short(voted) + "\n";
      results += "\nNumber of people who voted " +
                 sizeof(_elections[area]->voted);
      num = query_number_of_citizens(area);
      if (num == 0) {
         results += " (100% of the citizens)\n";
      } else {
         results += " (" + (sizeof(_elections[area]->voted) * 100 / num) +
                    "% of the citizens)\n";
      }
      _elections[area]->votes = ([ ]);
      _elections[area]->voted = ({ });
      _elections[area]->phase = CITIZEN_ELECTION_PHASE_NONE;
      _elections[area]->phase_start = time();
      _elections[area]->last_election = time();
      _elections[area]->nominations = ([ ]);
      post_citizen_message(area, "Election results", results);
      setup_magistrates(area, voted);
      save_me();
   }
}
protected void do_next_event() {
   int next_event;
   int time_to_next_event;
   string area;
   class election_data data;
   foreach (area, data in _elections) {
      switch (data->phase) {
      case CITIZEN_ELECTION_PHASE_NONE :
         next_event = (data->last_election - time()) + CITIZEN_ELECTION_TIME;
         if (next_event <= 0) {
            start_election(area);
         }
         break;
      case CITIZEN_ELECTION_PHASE_NOMINATION :
         next_event = (data->phase_start - time()) + CITIZEN_PHASE_TIME;
         if (next_event <= 0) {
            finish_nomination_phase(area);
         }
         break;
      case CITIZEN_ELECTION_PHASE_ELECTION :
         next_event = (data->phase_start - time()) + CITIZEN_ELECTION_PHASE_TIME;
         if (next_event <= 0) {
            finish_election_phase(area);
         }
         break;
      case CITIZEN_ELECTION_PHASE_GRACE :
         next_event = (data->phase_start - time()) + CITIZEN_GRACE_TIME;
         if (next_event <= 0) {
            start_election(area);
         }
         break;
      case CITIZEN_ELECTION_PHASE_DISABLED :
         next_event = (data->phase_start - time()) +
            CITIZEN_ELECTION_DISABLED_TIME;
         if (next_event <= 0) {
             next_event = next_event;
         }
         break;
      }
      if (next_event > 0 &&
          (next_event < time_to_next_event || !time_to_next_event)) {
         time_to_next_event = next_event;
      }
   }
   if(time_to_next_event) {
     call_out("do_next_event", time_to_next_event);
   }
}
void set_citizen_board(string area, string name) {
   if (!pointerp(_boards[area])) {
      _boards[area] = ({ 0, 0 });
   }
   _boards[area][0] = name;
   save_me();
}
string query_magistrate_board(string area) {
   if (pointerp(_boards[area])) {
      return _boards[area][1];
   }
   return 0;
}
void set_magistrate_board(string area, string name) {
   if (!pointerp(_boards[area])) {
      _boards[area] = ({ 0, 0 });
   }
   _boards[area][1] = name;
   save_me();
}
string query_citizen_board(string area) {
   if (pointerp(_boards[area])) {
      return _boards[area][0];
   }
   return 0;
}
int post_citizen_message(string area, string subject, string message) {
   string board;
   board = query_citizen_board(area);
   if (board) {
      return BOARD_HAND->add_message(board,
                           NOMIC_SYSTEM_ADMINISTRATOR_NAME,
                           subject,
                           message);
   }
   return 0;
}
int post_magistrate_message(string area, string subject, string message) {
   string board;
   board = query_magistrate_board(area);
   if (board) {
      return BOARD_HAND->add_message(board,
                           NOMIC_SYSTEM_ADMINISTRATOR_NAME,
                           subject,
                           message);
   }
   return 0;
}
int disable_citizen_election(string area) {
    if (!_elections[area]) {
      return 0;
    }
   _elections[area]->phase = CITIZEN_ELECTION_PHASE_DISABLED;
   _elections[area]->phase_start = time();
   _elections[area]->nominations = ([ ]);
   _elections[area]->votes = ([ ]);
   _elections[area]->voted = ({ });
   save_me();
   return 1;
}

==================================================
FILE: handlers/inherit/citizens.c
==================================================

#include <player_handler.h>
#include <playtesters.h>
#include <player.h>
private mapping _magistrates;
private mapping _citizens;
int is_citizen_of(string area, string citizen);
void save_me();
void create() {
   _citizens = ([ ]);
   _magistrates = ([ ]);
}
int create_area(string area, int num_magistrates) {
   _citizens[area] = ({ });
   _magistrates[area] = allocate(num_magistrates);
   save_me();
}
string* query_citizenship_areas() {
   return keys(_citizens);
}
int remove_citizen(string area, string citizen) {
   int pos;
   if (!_citizens[area]) {
      return 0;
   }
   if (member_array(citizen, _citizens[area]) != -1) {
      _citizens[area] -= ({ citizen });
      if (citizen) {
         pos = member_array(citizen, _magistrates[area]);
         if (pos != -1) {
            _magistrates[area][pos] = 0;
         }
      }
      save_me();
      return 1;
   }
   return 0;
}
int add_magistrate(string area, string magistrate) {
   int pos;
   if (!is_citizen_of(area, magistrate)) {
      return 0;
   }
   pos = member_array(0, _magistrates[area]);
   if (pos == -1) {
      return 0;
   }
   _magistrates[area][pos] = magistrate;
   save_me();
   PLAYER_TITLE_HANDLER->add_title_to_player(magistrate, "magistrate");
   return 1;
}
protected void setup_magistrates(string area, string* magistrates) {
   int i;
   int num;
   string magistrate;
   if (!_magistrates[area]) {
      return ;
   }
   for (i = 0; i < sizeof(_magistrates[area]); i++) {
      _magistrates[area][i] = 0;
   }
   num = sizeof(_magistrates[area]);
   if (num <= sizeof(magistrates)) {
      magistrates = magistrates[0..num];
   } else {
      magistrates += allocate(num - sizeof(magistrates));
   }
   _magistrates[area] = magistrates;
   save_me();
   foreach (magistrate in magistrates) {
      PLAYER_TITLE_HANDLER->add_title_to_player(magistrate, "magistrate");
   }
}
int query_number_of_magistrates(string area) {
   if (!_magistrates[area]) {
      return 0;
   }
   return sizeof(_magistrates[area]);
}
string* query_magistrates(string area) {
   if (!_magistrates[area]) {
      return ({ });
   }
   return _magistrates[area] - ({ 0 });
}
int add_citizen(string area, string citizen) {
   if (!PLAYER_HANDLER->test_user(citizen)) {
      return 0;
   }
   if (!_citizens[area]) {
      return 0;
   }
   _citizens[area] += ({ citizen });
   save_me();
   return 1;
}
int is_citizen_of(string area, string citizen) {
   if (!_citizens[area]) {
      return 0;
   }
   if (master()->query_lord(citizen)) {
      return 1;
   }
   return member_array(citizen, _citizens[area]) != -1;
}
int is_magistrate_of(string area, string magistrate) {
   if (!_magistrates[area]) {
      return 0;
   }
   if (master()->query_lord(magistrate)) {
      return 1;
   }
   return member_array(magistrate, _magistrates[area]) != -1;
}
string query_citizen(string citizen) {
   string bing;
   foreach (bing in query_citizenship_areas()) {
      if (is_citizen_of(bing, citizen)) {
         return bing;
      }
   }
   return 0;
}
int is_magistrate_anywhere(string person) {
   string bing;
   foreach (bing in query_citizenship_areas()) {
      if (is_magistrate_of(bing, person)) {
         return 1;
      }
   }
   return 0;
}
int query_number_of_citizens(string area) {
   return sizeof(_citizens[area]);
}

==================================================
FILE: handlers/inherit/club_basic.c
==================================================

#include <clubs.h>
#include <broadcaster.h>
#include <player_handler.h>
class club_info {
   string actual_name;
   string founder;
   string *recruiters;
   string *members;
   int type;
   mapping accounts;
   int last_paid;
   int last_touched;
   mixed extra_data;
   string description;
   string region;
}
#define CLUB_CACHE_SIZE 20
private mapping _club_names;
private string *_observers;
private nosave int _no_cache_hits;
private nosave int _no_cache_requests;
private nosave int _no_cache_miss;
private nosave int _cache_call_out;
private nosave mapping _cache;
private nosave string *_cache_order;
#define SAVE_FILE_NAME "/save/clubs"
#define SAVE_FILE_DIR "/save/clubs/"
protected void save_club(string name);
protected void load_main();
protected void save_main();
int is_club(string club_name);
int remove_recruiter(string name, string recruiter);
int is_recruiter_of(string name, string recruiter);
int query_club_type(string name);
void check_extra_information(string club_name, string member, int login);
int is_family(string name);
int disband_club(string name);
protected void set_club_changed(string name);
protected void send_broadcast_message(string club,
                                      string message);
protected void send_observer_event(string event_name,
                                   string *args ...);
void create() {
    seteuid(master()->creator_file(file_name()));
   _club_names = ([ ]);
   _cache = ([ ]);
   _cache_order = ({ });
   _observers = ({ });
   load_main();
}
string query_cap_name() {
   return "Club controller";
}
protected void load_main() {
   unguarded( (: restore_object(SAVE_FILE_NAME, 1) :) );
}
protected void save_main() {
   unguarded( (: save_object(SAVE_FILE_NAME, 1) :) );
}
string normalise_name(string name) {
   return replace_string(lower_case(name), " ", "_");
}
private void fixup_cache() {
   int i;
   if (sizeof(_cache_order) > CLUB_CACHE_SIZE) {
      for (i = sizeof(_cache_order) - CLUB_CACHE_SIZE; i >= 0; i--) {
         if (_club_names[_cache_order[i]]) {
            save_club(_cache_order[i]);
         }
         map_delete(_cache, _cache_order[i]);
      }
      _cache_order = _cache_order[sizeof(_cache_order) - CLUB_CACHE_SIZE + 1..];
   }
}
protected class club_info query_club_info(string name) {
   class club_info bing;
   name = normalise_name(name);
   _no_cache_requests++;
   if (_cache[name]) {
      _no_cache_hits++;
      return _cache[name];
   }
   if (unguarded( (: file_size(SAVE_FILE_DIR + $(name)) :)) > 0) {
      _cache[name] = unguarded( (: restore_variable(read_file(SAVE_FILE_DIR +
                                                              $(name))) :) );
      _cache_order += ({ name });
      if (intp(_cache[name]->accounts)) {
         _cache[name]->accounts = ([ CLUB_DEFAULT_ACCOUNT_NAME : _cache[name]->accounts ]);
      }
      if (sizeof(_cache[name]) == 10) {
         bing = new(class club_info);
         bing->actual_name = _cache[name]->actual_name;
         bing->founder = _cache[name]->founder;
         bing->recruiters = _cache[name]->recruiters;
         bing->members = _cache[name]->members;
         bing->type = _cache[name]->type;
         bing->accounts = _cache[name]->accounts;
         bing->last_paid = _cache[name]->last_paid;
         bing->last_touched = _cache[name]->last_touched;
         bing->extra_data = _cache[name]->extra_data;
         bing->description = _cache[name]->description;
         bing->region = "Ankh-Morpork";
         _cache[name] = bing;
         set_club_changed(name);
      }
      fixup_cache();
      return _cache[name];
   }
   _no_cache_miss++;
   return 0;
}
protected void save_club(string name) {
   name = normalise_name(name);
   if (_cache[name]) {
      _club_names[name] = 0;
      unguarded( (: write_file(SAVE_FILE_DIR + $(name),
                               save_variable(_cache[$(name)]),
                               1) :) );
   }
}
protected void save_cache() {
   string name;
   class club_info data;
   foreach (name, data in _cache) {
      if (_club_names[name]) {
         save_club(name);
      }
   }
}
protected void set_club_changed(string name) {
   name = normalise_name(name);
   if (!undefinedp(_club_names[name])) {
      if (find_call_out(_cache_call_out) == -1) {
         _cache_call_out = call_out((: save_cache :), 0);
      }
      _club_names[name] = 1;
   }
}
private void add_club(string name,
                      class club_info data) {
   name = normalise_name(name);
   _cache[name] = data;
   _club_names[name] = 0;
   set_club_changed(name);
}
string the_short() {
   return "Club Control";
}
protected void create_extra_data(string name) {
   class club_info data;
   data = query_club_info(name);
   data->extra_data = 0;
   set_club_changed(name);
}
int create_club(string name, string founder, int type, string region) {
   class club_info info;
   if (!stringp(name) || !stringp(founder)) {
      return 0;
   }
   info = new(class club_info);
   info->actual_name = name;
   if (type != CLUB_FAMILY) {
      info->recruiters = ({ founder });
      info->members = ({ founder });
   } else {
      info->recruiters = ({ });
      info->members = ({ });
   }
   info->founder = founder;
   info->last_touched = time();
   info->type = type;
   info->last_paid = time();
   info->description = 0;
   info->accounts = ([ CLUB_DEFAULT_ACCOUNT_NAME : 0 ]);
   info->region = region;
   add_club(name, info);
   create_extra_data(name);
   set_club_changed(name);
   add_club(name, info);
   save_main();
   return 1;
}
int change_club_type(string name,
                     int type) {
   int club_type;
   class club_info info;
   if (is_club(name)) {
      club_type = query_club_type(name);
      info = query_club_info(name);
      if (club_type != type) {
         info->type = (club_type & CLUB_FLAGS_MASK) | type;
         set_club_changed(name);
         create_extra_data(name);
         return 1;
      }
   }
   return 0;
}
int query_club_type(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      if (!data) {
         disband_club(name);
      } else {
         return data->type & CLUB_TYPE_MASK;
      }
   }
}
int set_club_secret(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      data->type |= CLUB_SECRET_FLAG;
      set_club_changed(name);
      return 1;
   }
   return 0;
}
int reset_club_secret(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      data->type &= ~CLUB_SECRET_FLAG;
      set_club_changed(name);
      return 1;
   }
   return 0;
}
int query_club_secret(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      return (data->type & CLUB_SECRET_FLAG) != 0;
   }
}
string query_club_region(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      return data->region;
   }
   return 0;
}
int disband_club(string name) {
   class club_info data;
   name = normalise_name(name);
   if (is_club(name)) {
      data = query_club_info(name);
      if (data) {
         log_file("CLUB", ctime(time()) + ": disbanded '" +
                       this_object()->query_club_name(name) + "'; balance = " +
                       this_object()->query_balance(name, CLUB_DEFAULT_ACCOUNT_NAME) + "; fees due = " +
                       ctime(this_object()->query_time_fees_due(name)) +
                       "\n");
      } else {
         log_file("CLUB", ctime(time()) + " disbanded '" + name + "' "
                          "which has a bad data file.\n");
      }
      map_delete(_club_names, name);
      map_delete(_cache, name);
      unguarded( (: rm(SAVE_FILE_DIR + $(name)) :) );
      save_main();
      send_observer_event("club_event_disband_club", name);
      return 1;
   }
   return 0;
}
string *query_clubs() {
   return keys(_club_names);
}
string query_insignia_path(string name) {
   return "/obj/misc/club_badge";
}
void touch_club(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      data->last_touched = time();
      set_club_changed(name);
   }
}
string *query_recruiters(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      return data->recruiters;
   }
   return ({ });
}
string query_founder(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      return data->founder;
   }
   return 0;
}
string *query_members(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      return data->members;
   }
   return ({ });
}
int add_recruiter(string name, string recruiter) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      if (member_array(recruiter, data->members) != -1 &&
          member_array(recruiter, data->recruiters) == -1) {
         data->recruiters += ({ recruiter });
         set_club_changed(name);
         touch_club(name);
         if (!is_family(name)) {
            send_broadcast_message(name,
                                   capitalize(recruiter) +
                                   " becomes a recruiter for the club.");
         }
         return 1;
      }
   }
   return 0;
}
int add_member(string name, string member) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      if (member_array(member, data->members) == -1) {
         data->members += ({ member });
         set_club_changed(name);
         touch_club(name);
         if (!is_family(name)) {
            send_broadcast_message(name,
                                   capitalize(member) + " joins the club.");
         }
         return 1;
      }
   }
   return 0;
}
int remove_member(string name, string member) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      if (member_array(member, data->members) != -1) {
         if (is_recruiter_of(name, member)) {
            remove_recruiter(name, member);
         }
         data->members -= ({ member });
         set_club_changed(name);
         check_extra_information(name, member, 0);
         if (!is_family(name)) {
            send_broadcast_message(name,
                                   capitalize(member) + " leaves the club.");
         }
         send_observer_event("club_event_remove_member", name, member);
         return 1;
      }
   }
   return 0;
}
int remove_recruiter(string name, string recruiter) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      if (member_array(recruiter, data->recruiters) != -1) {
         data->recruiters -= ({ recruiter });
         set_club_changed(name);
         if (!is_family(name)) {
            send_broadcast_message(name,
                                   capitalize(recruiter) +
                                   " stops being a recruiter for the club.");
         }
         return 1;
      }
   }
   return 0;
}
string query_club_name(string club_name) {
   class club_info data;
   if (is_club(club_name)) {
      data = query_club_info(club_name);
      if (!data) {
         return club_name;
      }
      return data->actual_name;
   }
   return 0;
}
string query_club_description(string club_name) {
   class club_info data;
   if (is_club(club_name)) {
      data = query_club_info(club_name);
      return data->description;
   }
   return 0;
}
int set_club_description(string club_name, string description) {
   class club_info data;
   if (is_club(club_name)) {
      data = query_club_info(club_name);
      data->description = description;
      set_club_changed(club_name);
      return 1;
   }
   return 0;
}
int query_time_fees_due(string club_name) {
   class club_info data;
   if (is_club(club_name)) {
      data = query_club_info(club_name);
      return data->last_paid + CLUB_PAY_PERIOD;
   }
   return 0;
}
int query_club_cost_per_period(string club_name) {
   if (is_club(club_name)) {
      return CLUB_COST_PER_YEAR +
           sizeof(query_members(club_name)) * CLUB_COST_PER_MEMBER_PER_YEAR;
   }
   return 0;
}
int is_club(string name) {
   name = normalise_name(name);
   if (!undefinedp(_club_names[name])) {
      return 1;
   }
   return 0;
}
int is_elected_club(string name) {
   name = normalise_name(name);
   if (is_club(name)) {
      return query_club_type(name) == CLUB_ELECTED;
   }
   return 0;
}
int is_personal_club(string name) {
   if (is_club(name)) {
      return query_club_type(name) == CLUB_PERSONAL;
   }
   return 0;
}
int is_family(string name) {
   if (is_club(name)) {
      return query_club_type(name) == CLUB_FAMILY;
   }
   return 0;
}
int is_member_of(string name, string member) {
   if (is_club(name)) {
      return member_array(member, query_members(name)) != -1;
   }
   return 0;
}
int is_recruiter_of(string name, string recruiter) {
   if (is_club(name)) {
      return member_array(recruiter, query_recruiters(name)) != -1;
   }
   return 0;
}
int is_founder_of(string name, string founder) {
   name = normalise_name(name);
   if (is_club(name)) {
      return query_founder(name) == founder;
   }
   return 0;
}
int create_account(string name,
                   string account) {
   class club_info data;
   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (is_club(name)) {
      data = query_club_info(name);
      if (undefinedp(data->accounts[account])) {
         data->accounts[account] = 0;
         touch_club(name);
         set_club_changed(name);
         return 1;
      }
   }
   return 0;
}
int add_money(string name,
              int amount,
              int type,
              string person,
              string account) {
   class club_info data;
   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (is_club(name) && amount > 0) {
      data = query_club_info(name);
      if (!undefinedp(data->accounts[account])) {
         data->accounts[account] += amount;
         touch_club(name);
         set_club_changed(name);
         return 1;
      }
   }
   return 0;
}
int remove_money(string name,
                 int amount,
                 int type,
                 string person,
                 string account) {
   class club_info data;
   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (is_club(name) && amount > 0) {
      data = query_club_info(name);
      if (!undefinedp(data->accounts[account])) {
         data->accounts[account] -= amount;
         touch_club(name);
         set_club_changed(name);
         return 1;
      }
   }
   return 0;
}
int query_balance(string name,
                  string account) {
   class club_info data;
   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (is_club(name)) {
      data = query_club_info(name);
      return data->accounts[account];
   }
   return 0;
}
string* query_account_names(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      if (data) {
         return keys(data->accounts);
      }
   }
   return ({ });
}
int is_account_of(string club_name, string account) {
   return member_array(account, query_account_names(club_name)) != -1;
}
int is_creator_club(string club_name) {
   if (is_club(club_name)) {
      if (PLAYER_HANDLER->test_creator(query_founder(club_name))) {
         return 1;
      }
   }
   return 0;
}
int is_observer(string obs) {
   if (member_array(obs, _observers) != -1) {
      return 1;
   }
   return 0;
}
int add_observer(string obs) {
   if (!is_observer(obs) &&
       file_size(obs) > 0) {
      _observers += ({ obs });
      save_main();
      return 1;
   }
   return 0;
}
int remove_observer(string obs) {
   if (is_observer(obs)) {
      _observers -= ({ obs });
      save_main();
      return 1;
   }
   return 0;
}
string *query_observers() {
   return _observers;
}
protected void send_observer_event(string event_name,
                                   string *args ...) {
   string bing;
   foreach (bing in _observers) {
      if (file_size(bing) > 0) {
         call_out((: call_other($1, $2, $3 ...) :),
                  0,
                  event_name,
                  bing,
                  args ...);
      } else {
         remove_observer(bing);
      }
   }
}
protected void send_broadcast_message(string club,
                                      string message) {
   BROADCASTER->broadcast_to_channel(this_object(),
                                     lower_case(query_club_name(club)),
                                     ({ message, 0 }));
}
mixed *stats() {
   return ({
              ({ "cache hits", _no_cache_hits }),
              ({ "cache requests", _no_cache_requests }),
              ({ "cache miss", _no_cache_miss }),
              ({ "percentage", _no_cache_hits * 100 / _no_cache_requests }),
           });
}

==================================================
FILE: handlers/inherit/club_discuss.c
==================================================

inherit "/obj/handlers/inherit/club_elected";
#define __CLUBS_H_NO_CLASSES
#include <clubs.h>
#include <broadcaster.h>
#include <player_handler.h>
#include <player_handler.h>
private nosave mapping _discussion_items;
#define CLUB_DISCUSS_FUNCTION_OBJECT     0
#define CLUB_DISCUSS_FUNCTION_FUNCTION   1
#define CLUB_DISCUSS_QUORUM_COMMITTEE   75
#define CLUB_DISCUSS_QUORUM_OPEN        25
private void add_club_discussion(int type,
                                 function func);
protected int remove_discussion_item(string club_name,
                                     class discussion_idea item);
private mixed club_discuss_new_position(int message,
                                        string club_name,
                                        class discussion_idea frog);
private mixed club_discuss_position_name(int message,
                                         string club_name,
                                         class discussion_idea frog,
                                         string arg1,
                                         string arg2);
private mixed club_discuss_position_remove(int message,
                                           string club_name,
                                           class discussion_idea frog,
                                           string arg1,
                                           string arg2);
private mixed club_discuss_description(int message,
                                       string club_name,
                                       class discussion_idea frog);
private mixed club_discuss_memo(int message,
                                string club_name,
                                class discussion_idea frog);
private mixed club_discuss_secret(int message,
                                  string club_name,
                                  class discussion_idea frog);
private mixed club_discuss_remove_member(int message,
                                         string club_name,
                                         class discussion_idea frog,
                                         string member);
private mixed club_discuss_no_confidence(int message,
                                         string club_name,
                                         class discussion_idea frog,
                                         string arg1,
                                         string arg2);
private mixed club_discuss_election(int message,
                                    string club_name,
                                    class discussion_idea frog,
                                    string arg1,
                                    string arg2);
private mixed club_discuss_nomination(int message,
                                      string club_name,
                                      class discussion_idea frog,
                                      string arg1,
                                      string arg2);
private mixed club_discuss_function(int message,
                                    string club_name,
                                    class discussion_idea frog,
                                    string arg1,
                                    string arg2);
private mixed club_discuss_create_account(int message,
                                    string club_name,
                                    class discussion_idea frog,
                                    string arg1,
                                    string arg2);
class discussion_idea query_discussion_item_by_type(string club_name,
                                                    int type,
                                                    class discussion_idea idea);
protected mixed send_discuss_message(string club_name,
                                    int message,
                                    class discussion_idea item,
                                    string arg1,
                                    string arg2);
protected void broadcast_discuss_message(string club_name,
                                         int message,
                                         string arg1,
                                         string arg2);
int add_discussion_item(string club,
                        int type,
                        string added_by,
                        string name,
                        string info,
                        string *choices,
                        int time_to_finish,
                        mixed extra_data);
int setup_by_election(string club,
                      string position,
                      string info);
int is_discuss_nominateable(string club_name,
                            int id);
void create() {
   _discussion_items = ([ ]);
   ::create();
   add_club_discussion(CLUB_DISCUSS_NEW_POSITION,
                       (: club_discuss_new_position :));
   add_club_discussion(CLUB_DISCUSS_POSITION_NAME,
                       (: club_discuss_position_name :));
   add_club_discussion(CLUB_DISCUSS_POSITION_REMOVE,
                       (: club_discuss_position_remove :));
   add_club_discussion(CLUB_DISCUSS_DESCRIPTION,
                       (: club_discuss_description :));
   add_club_discussion(CLUB_DISCUSS_MEMO,
                       (: club_discuss_memo :));
   add_club_discussion(CLUB_DISCUSS_MEMBER_REMOVE,
                       (: club_discuss_remove_member :));
   add_club_discussion(CLUB_DISCUSS_SECRET_TYPE,
                       (: club_discuss_secret :));
   add_club_discussion(CLUB_DISCUSS_NO_CONFIDENCE,
                       (: club_discuss_no_confidence :));
   add_club_discussion(CLUB_DISCUSS_ELECTION,
                       (: club_discuss_election :));
   add_club_discussion(CLUB_DISCUSS_NOMINATION,
                       (: club_discuss_nomination :));
   add_club_discussion(CLUB_DISCUSS_FUNCTION,
                       (: club_discuss_function :));
   add_club_discussion(CLUB_DISCUSS_CREATE_ACCOUNT,
                       (: club_discuss_create_account :));
}
private void add_club_discussion(int type,
                                 function func) {
   _discussion_items[type] = func;
}
protected int archive_discussion_item(string club_name,
                                      string subject,
                                      string item) {
   if (is_elected_club(club_name)) {
      add_archive(club_name,
                  subject,
                  item);
   }
}
int is_discussion_position_valid(string club_name,
                                 string position) {
   class discussion_idea bing;
   position = lower_case(position);
   if (is_valid_position(club_name, position)) {
      return 0;
   }
   do {
      bing = query_discussion_item_by_type(club_name,
                                           CLUB_DISCUSS_POSITION_NAME,
                                           bing);
      if (bing) {
         if (!undefinedp(bing->choices[position])) {
            return 0;
         }
      }
   } while (bing);
   do {
      bing = query_discussion_item_by_type(club_name,
                                           CLUB_DISCUSS_NEW_POSITION,
                                           bing);
      if (bing) {
         if (bing->information == position) {
            return 0;
         }
      }
   } while (bing);
   return 1;
}
private mixed club_discuss_position_name(int message,
                                         string club_name,
                                         class discussion_idea frog,
                                         string arg1,
                                         string arg2) {
   string body;
   string position;
   int num;
   string old_pos;
   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         if (!is_discussion_position_valid(club_name, frog->optional_data)) {
            return 0;
         }
         frog->choices = ([ CLUB_DISCUSS_YES_CHOICE : 0,
                            CLUB_DISCUSS_NO_CHOICE : 0,
                            CLUB_DISCUSS_ABSTAIN_CHOICE : 0 ]);
         if (!is_valid_position(club_name, frog->name)) {
            return 0;
         }
         return 1;
      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item "
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "  The final votes for the discussion item to change the "
                "position " +frog->name + " to " + frog->optional_data +
                " is:\n";
         foreach (position, num in frog->choices) {
            body += position + ":   " + num + "\n";
         }
         body += "\n";
         if (frog->information) {
            body += frog->information + "\n";
         }
         old_pos = frog->name;
         if (frog->choices[CLUB_DISCUSS_YES_CHOICE] >
             frog->choices[CLUB_DISCUSS_NO_CHOICE]) {
            change_position_name_in_club(club_name,
                                        frog->name,
                                        frog->optional_data);
            body += "Which means the position " + old_pos +
                     " has been changed to " + frog->optional_data + ".\n";
         } else {
            body += "Which means the position " + old_pos +
                    " has not been changed to " + frog->optional_data + ".\n";
         }
         do_mail_committee(club_name,
                           "Results of changing the position " +
                              frog->name,
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;
      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Voting on changing the position '" + frog->name +
                "' to '" + frog->optional_data + "'.\n";
         if (frog->information) {
            body += frog->information;
         }
         return body;
      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "Changing the position '" + frog->name + "'";
      case CLUB_DISCUSS_MESSAGE_CHANGE_POSITION :
         if (frog->name == arg1) {
            frog->name = arg2;
            return 1;
         }
         return 0;
      case CLUB_DISCUSS_MESSAGE_REMOVE_POSITION :
         if (frog->name == arg1) {
            remove_discussion_item(club_name, frog);
            return 1;
         }
         return 0;
   }
   return 0;
}
private mixed club_discuss_position_remove(int message,
                                           string club_name,
                                           class discussion_idea frog,
                                           string arg1,
                                           string arg2) {
   string body;
   string position;
   int num;
   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         if (!is_valid_position(club_name, frog->name)) {
            return 0;
         }
         if (is_basic_position(club_name, frog->name)) {
            return 0;
         }
         frog->choices = ([ CLUB_DISCUSS_YES_CHOICE : 0,
                            CLUB_DISCUSS_NO_CHOICE : 0,
                            CLUB_DISCUSS_ABSTAIN_CHOICE : 0 ]);
         return 1;
      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item "
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "  The final votes for the discussion item "
                "to remove the position " + frog->name + " are:\n";
         foreach (position, num in frog->choices) {
            body += position + ":   " + num + "\n";
         }
         body += "\n";
         if (frog->information) {
            body += frog->information + "\n";
         }
         if (frog->choices[CLUB_DISCUSS_YES_CHOICE] >
             frog->choices[CLUB_DISCUSS_NO_CHOICE]) {
            if (is_basic_position(club_name, frog->name)) {
               body += "Unable to remove the basic position " + frog->name +
                        ".\n";
            } else if (remove_position_in_club(club_name, frog->name)) {
               body += "Which means the position " + frog->name +
                        " has been removed.\n";
            } else {
               body += "Unable to remove the position " + frog->name +
                        " for some reason, basic position or something?\n";
            }
         } else {
            body += "Which means the position " + frog->name +
                    " has not been removed.\n";
         }
         do_mail_committee(club_name,
                           "Results of removing the position " +
                              frog->name,
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;
      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Voting on removing the position '" + frog->name +
                "'.\n";
         if (frog->information) {
            body += frog->information;
         }
         return body;
      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "Removing the position '" + frog->name + "'";
      case CLUB_DISCUSS_MESSAGE_CHANGE_POSITION :
         if (frog->name == arg1) {
            frog->name = arg2;
            return 1;
         }
         return 0;
      case CLUB_DISCUSS_MESSAGE_REMOVE_POSITION :
         if (frog->name == arg1) {
            remove_discussion_item(club_name, frog);
            return 1;
         }
         return 0;
   }
   return 0;
}
private mixed club_discuss_new_position(int message,
                                        string club_name,
                                        class discussion_idea frog) {
   string body;
   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         frog->choices = ([ CLUB_DISCUSS_YES_CHOICE : 0,
                            CLUB_DISCUSS_NO_CHOICE : 0,
                            CLUB_DISCUSS_ABSTAIN_CHOICE : 0 ]);
         if (!is_discussion_position_valid(club_name, frog->name)) {
            return 0;
         }
         return 1;
      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item "
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "  The vote for adding the position " +
            frog->name + " to the club " + query_club_name(club_name) +
            " has been completed and the results are " +
            frog->choices[CLUB_DISCUSS_YES_CHOICE] + " in favour, " +
            frog->choices[CLUB_DISCUSS_NO_CHOICE] + " against and " +
            frog->choices[CLUB_DISCUSS_ABSTAIN_CHOICE] + " abstaining.\n";
         if (frog->information) {
            body += frog->information;
         }
         if (is_valid_position(club_name, frog->name)) {
            body += "\nUnfortunately " + frog->name +
               " is not a valid position.  Vote forfited.\n";
            do_mail_committee(club_name,
                              "Results of adding " + frog->name,
                              body);
            return 0;
         }
         if (frog->choices[CLUB_DISCUSS_YES_CHOICE] >
             frog->choices[CLUB_DISCUSS_NO_CHOICE]) {
            if (create_position_in_club(club_name, frog->name)) {
               body += "\nWhich means that the position " + frog->name +
                  " has been created.\n";
               setup_by_election(club_name,
                                 frog->name,
                                 frog->information);
            } else if (is_voting_in_progress(club_name)) {
               body += "\nWhich means we attempted to create the position " +
                  frog->name + " but were prevented because "
                  "voting is in progress?\n";
            } else {
               body += "\nWhich means we attempted to create the position " +
                  frog->name + " but were prevented for some reason.\n";
            }
         } else {
            body += "\nWhich means that the position " + frog->name +
               " was not created.\n";
         }
         do_mail_committee(club_name,
                           "Results of adding " + frog->name,
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;
      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Voting on adding the position '" + frog->name +
            "' to the club.\n";
         if (frog->information) {
            body += frog->information;
         }
         return body;
      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "Adding the position '" + frog->name + "'";
   }
   return 0;
}
private mixed club_discuss_description(int message,
                                       string club_name,
                                       class discussion_idea frog) {
   string body;
   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         if (query_discussion_item_by_type(club_name,
                                           CLUB_DISCUSS_DESCRIPTION,
                                           0)) {
            return 0;
         }
         frog->choices = ([ CLUB_DISCUSS_YES_CHOICE : 0,
                            CLUB_DISCUSS_NO_CHOICE : 0,
                            CLUB_DISCUSS_ABSTAIN_CHOICE : 0 ]);
         return 1;
      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item "
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "  The vote for changing the description of the " +
            "club " + query_club_name(club_name) +
            " to:\n" + frog->information + "\nThe vote has been completed "
            "and the results are " +
            frog->choices[CLUB_DISCUSS_YES_CHOICE] + " in favour, " +
            frog->choices[CLUB_DISCUSS_NO_CHOICE] + " against and " +
            frog->choices[CLUB_DISCUSS_ABSTAIN_CHOICE] + " abstaining.\n";
         if (frog->choices[CLUB_DISCUSS_YES_CHOICE] >
             frog->choices[CLUB_DISCUSS_NO_CHOICE]) {
            set_club_description(club_name, frog->information);
            body += "Which means the description has been changed.\n";
         } else {
            body += "Which means the description has not been changed.\n";
         }
         do_mail_committee(club_name,
                           "Results of changing the description",
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;
      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Voting on changing the description of the club to:\n" +
                frog->information + "\n";
         return body;
      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "Changing the description";
   }
   return 0;
}
private mixed club_discuss_secret(int message,
                                  string club_name,
                                  class discussion_idea frog) {
   string body;
   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         if (query_discussion_item_by_type(club_name,
                                           CLUB_DISCUSS_SECRET_TYPE,
                                           0)) {
            return 0;
         }
         frog->choices = ([ CLUB_DISCUSS_YES_CHOICE : 0,
                            CLUB_DISCUSS_NO_CHOICE : 0,
                            CLUB_DISCUSS_ABSTAIN_CHOICE : 0 ]);
         return 1;
      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item "
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "  The vote for changing the club " +
                query_club_name(club_name) + " to ";
         if (query_club_secret(club_name)) {
            body += "an open club";
         } else {
            body += "a secret club";
         }
         body += " has been completed and the "
            "results are " +
            frog->choices[CLUB_DISCUSS_YES_CHOICE] + " in favour and " +
            frog->choices[CLUB_DISCUSS_NO_CHOICE] + " against with " +
            frog->choices[CLUB_DISCUSS_ABSTAIN_CHOICE] + " abstaining.\n\n";
         if (frog->choices[CLUB_DISCUSS_YES_CHOICE] >
             frog->choices[CLUB_DISCUSS_NO_CHOICE]) {
            if (query_club_secret(club_name)) {
               reset_club_secret(club_name);
               body += "Which means the club is now open.\n";
            } else {
               set_club_secret(club_name);
               body += "Which means the club is now secret.\n";
            }
         } else {
            body += "Which means the club's secret flag has not been "
                    "changed.\n";
         }
         if (frog->information) {
            body += "\n" + frog->information;
         }
         do_mail_committee(club_name,
                           "Results of changing the secret flag",
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;
      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         if (query_club_secret(club_name)) {
            body = "Voting on changing the club to be open.\n";
         } else {
            body = "Voting on changing the club to be secret.\n";
         }
         if (frog->information) {
            body += frog->information;
         }
         return body;
      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         if (query_club_secret(club_name)) {
            return "Changing the club to be open";
         } else {
            return "Changing the club to be secret";
         }
   }
   return 0;
}
private mixed club_discuss_memo(int message,
                                string club_name,
                                class discussion_idea frog) {
   string body;
   string choice;
   int num;
   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         return 1;
      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item "
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "   The final votes for discussion memo '" +
                frog->name + "' were:\n";
         foreach (choice, num in frog->choices) {
            body += choice + ":   " + num + "\n";
         }
         body += "\n" + frog->information;
         do_mail_committee(club_name,
                           "Results of memo '" +
                           frog->name + "'\n",
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;
      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Voting on the memo '" + frog->name +
                "'.\n";
         if (stringp(frog->information)) {
            body += "\n" + frog->information;
         }
         return body;
      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "Memo: " + frog->name;
   }
   return 0;
}
private mixed club_discuss_remove_member(int message,
                                         string club_name,
                                         class discussion_idea frog,
                                         string member) {
   string body;
   class discussion_idea womble;
   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         frog->name = lower_case(frog->name);
         do {
            womble = query_discussion_item_by_type(club_name,
                                                   CLUB_DISCUSS_MEMBER_REMOVE,
                                                   womble);
            if (womble &&
                womble->name == frog->name) {
               return 0;
            }
         } while (womble);
         if (!is_member_of(club_name, frog->name)) {
            return 0;
         }
         frog->choices = ([ CLUB_DISCUSS_YES_CHOICE : 0,
                            CLUB_DISCUSS_NO_CHOICE : 0,
                            CLUB_DISCUSS_ABSTAIN_CHOICE : 0 ]);
         return 1;
      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item "
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "  The vote for changing removing the member " +
                frog->name + " from the club " +
                query_club_name(club_name) +
                " has been completed and the "
            "results are " +
            frog->choices[CLUB_DISCUSS_YES_CHOICE] + " in favour and " +
            frog->choices[CLUB_DISCUSS_NO_CHOICE] + " against with " +
            frog->choices[CLUB_DISCUSS_ABSTAIN_CHOICE] + " abstaining.\n\n";
         if (frog->information) {
            body += frog->information;
         }
         if (frog->choices[CLUB_DISCUSS_YES_CHOICE] >
             frog->choices[CLUB_DISCUSS_NO_CHOICE]) {
            if (!is_member_of(club_name, frog->name)) {
               body += "Looks like someone beat us to removing them.\n";
            } else {
               body += "Which means they have now been removed.\n";
               remove_member(club_name, frog->name);
            }
         } else {
            body += "Which means no one has been removed.\n";
         }
         do_mail_committee(club_name,
                           "Results of removing the member",
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;
      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Voting on removing the member " + frog->name + ".\n";
         if (frog->information) {
            body += frog->information;
         }
         return body;
      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "Removing the member " + frog->name;
      case CLUB_DISCUSS_MESSAGE_REMOVE_MEMBER :
         if (frog->name == member) {
            return remove_discussion_item(club_name, frog);
         }
         return 0;
   }
   return 0;
}
private mixed club_discuss_no_confidence(int message,
                                         string club_name,
                                         class discussion_idea frog,
                                         string arg1,
                                         string arg2) {
   string body;
   class discussion_idea womble;
   string real;
   string pos;
   if (!frog->name) {
      real = "all postions";
   } else {
      real = frog->name;
   }
   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         frog->name = lower_case(frog->name);
         do {
            womble = query_discussion_item_by_type(club_name,
                                                   CLUB_DISCUSS_NO_CONFIDENCE,
                                                   womble);
            if (womble &&
                womble->name == frog->name) {
               return 0;
            }
         } while (womble);
         if (!is_valid_position(club_name, frog->name) &&
             frog->name) {
            return 0;
         }
         frog->choices = ([ CLUB_DISCUSS_YES_CHOICE : 0,
                            CLUB_DISCUSS_NO_CHOICE : 0,
                            CLUB_DISCUSS_ABSTAIN_CHOICE : 0 ]);
         return 1;
      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item "
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "   The vote for no confidence in " +
                real + " in the club " +
                query_club_name(club_name) +
                " has been completed and the "
            "results are " +
            frog->choices[CLUB_DISCUSS_YES_CHOICE] + " in favour and " +
            frog->choices[CLUB_DISCUSS_NO_CHOICE] + " against with " +
            frog->choices[CLUB_DISCUSS_ABSTAIN_CHOICE] + " abstaining.\n\n";
         if (frog->choices[CLUB_DISCUSS_YES_CHOICE] >
             frog->choices[CLUB_DISCUSS_NO_CHOICE]) {
            if (!frog->name) {
               body += "Therefor we have removed everyone from the committee "
                  "and started a new election.\n";
               foreach (pos in query_valid_positions(club_name)) {
                  catch(set_position_holder(club_name, pos, CLUB_UNKNOWN_MEMBER));
               }
               start_election(club_name);
            } else if (is_valid_position(club_name,
                                  frog->name)) {
               set_position_holder(club_name, frog->name, CLUB_UNKNOWN_MEMBER);
               body += "Therefor we had set the position as vacant.\n";
            } else {
               body += "The position in the club appears to have vanished!\n";
            }
         } else {
            body += "Which means nothing has happened.\n";
         }
         if (frog->information) {
            body += frog->information;
         }
         do_mail_committee(club_name,
                           "Results of no confidence vote",
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;
      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Voting on confidence in the position " +
                real + ", a yes vote indicates that you are in favour of the "
                "no confidence vote.\n";
         if (frog->information) {
            body += frog->information;
         }
         return body;
      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "No confidence in " + real;
      case CLUB_DISCUSS_MESSAGE_REMOVE_MEMBER :
         if (holds_position_of(club_name,
                               frog->name,
                               arg1) ||
             holds_position_of(club_name,
                               frog->name,
                               CLUB_UNKNOWN_MEMBER)) {
            return remove_discussion_item(club_name, frog);
         }
         return 0;
      case CLUB_DISCUSS_MESSAGE_CHANGE_POSITION :
         if (frog->name == arg1) {
            frog->name = arg2;
            return 1;
         }
         return 0;
      case CLUB_DISCUSS_MESSAGE_REMOVE_POSITION :
         if (frog->name == arg1) {
            remove_discussion_item(club_name, frog);
            return 1;
         }
         return 0;
   }
   return 0;
}
private int is_nomination_or_election_being_discussed(
   string club_name,
   string pos_name
   )
{
   class discussion_idea womble;
   womble = 0;
   do {
      womble = query_discussion_item_by_type(club_name,
                                             CLUB_DISCUSS_ELECTION,
                                             womble);
      if (womble &&
          lower_case(womble->name) == lower_case(pos_name)) {
         return 1;
      }
   } while (womble);
   womble = 0;
   do {
      womble = query_discussion_item_by_type(club_name,
                                             CLUB_DISCUSS_NOMINATION,
                                             womble);
      if (womble &&
          lower_case(womble->name) == lower_case(pos_name)) {
         return 1;
      }
   } while (womble);
   return 0;
}
private mixed club_discuss_nomination(int message,
                                      string club_name,
                                      class discussion_idea frog,
                                      string arg1,
                                      string arg2) {
   string body;
   string name;
   string *nom;
   string *nominated;
   int ret;
   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         frog->name = query_position_name(club_name, frog->name);
         if (is_nomination_or_election_being_discussed(club_name, frog->name)) {
            return 0;
         }
         if (!is_valid_position(club_name, frog->name)) {
            return 0;
         }
         if (is_election_in_progress(club_name) ||
             is_nomination_in_progress(club_name)) {
            return 0;
         }
         frog->choices = ([ ]);
         return 1;
      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item "
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "  The vote for nominations for the position of " +
                frog->name + " in the club " +
                query_club_name(club_name) +
                " has been completed and the "
            "results are:\n";
         nominated = ({ });
         foreach (name, nom in frog->choices) {
            body += name + ": " + query_multiple_short(nom);
            if (member_array(name, nom) != -1 &&
                sizeof(nom) >= 2) {
               body += " (accepted)\n";
               nominated += ({ name });
            } else {
               body += "\n";
            }
         }
         if (frog->information) {
            body += frog->information;
         }
         if (sizeof(nominated)) {
            if (is_valid_position(club_name,
                                  frog->name)) {
               if (sizeof(nominated) != 1) {
                  body += "Therefor we had added an election for " +
                     query_multiple_short(nominated) +
                     " .\n";
                  call_out((: add_discussion_item :), 0,
                                      club_name,
                                      CLUB_DISCUSS_ELECTION |
                                         CLUB_DISCUSS_OPEN |
                                         CLUB_DISCUSS_NO_QUORUM,
                                      CLUB_CONTROLLER_MEMBER,
                                      frog->name,
                                      frog->information,
                                      nominated,
                                      7 * (24 * 60 * 60),
                                      0);
               } else {
                  body += "Only " + nominated[0] +
                     " was nominated, so they are elected immediately.\n";
                  set_position_holder(club_name, frog->name, nominated[0]);
               }
            } else {
               body += "The position in the club appears to have vanished!\n";
            }
         } else {
            if (is_valid_position(club_name, frog->name)) {
               body += "No one accepted their nomination, so nothing "
                       "happened.\n";
               call_out((: add_discussion_item :), 0,
                                   club_name,
                                   CLUB_DISCUSS_NOMINATION |
                                      CLUB_DISCUSS_OPEN |
                                      CLUB_DISCUSS_NO_QUORUM,
                                   frog->added_by,
                                   frog->name,
                                   frog->information,
                                   ({ }),
                                   7 * (24 * 60 * 60),
                                   frog->optional_data);
            } else {
               body += "The position in the club appears to have vanished!\n";
            }
         }
         do_mail_committee(club_name,
                           "Results of nomination",
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;
      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Nominations for the position " + frog->name + ":\n";
         foreach (name, nom in frog->choices) {
            body += name + ": " + query_multiple_short(nom);
            if (member_array(name, nom) != -1 &&
                sizeof(nom) >= 2) {
               body += " (accepted)\n";
            } else {
               body += "\n";
            }
         }
         if (frog->information) {
            body += frog->information;
         }
         return body;
      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "Nominations for " + frog->name;
      case CLUB_DISCUSS_MESSAGE_NOMINATION :
         if (is_member_of(club_name, arg1) &&
             is_member_of(club_name, arg2)) {
            if (!frog->choices[arg2]) {
               frog->choices[arg2] = ({ arg1 });
               return 1;
            } else if (member_array(arg1,
                                    frog->choices[arg2]) == -1) {
               frog->choices[arg2] += ({ arg1 });
               return 1;
            }
         }
         return 0;
      case CLUB_DISCUSS_MESSAGE_WITHDRAW :
         if (frog->choices[arg1]) {
            map_delete(frog->choices, arg1);
            return 1;
         }
         return 0;
      case CLUB_DISCUSS_MESSAGE_REMOVE_MEMBER :
         if (frog->choices[arg1]) {
            map_delete(frog->choices, arg1);
            ret = 1;
         }
         foreach (name, nom in frog->choices) {
            if (member_array(arg1, nom) != -1) {
               frog->choices[name] = nom - ({ arg1 });
               if (!sizeof(frog->choices[name])) {
                  map_delete(frog->choices, name);
               }
               ret = 1;
            }
         }
         return ret;
      case CLUB_DISCUSS_MESSAGE_CHANGE_POSITION :
         if (frog->name == arg1) {
            frog->name = arg2;
            return 1;
         }
         return 0;
      case CLUB_DISCUSS_MESSAGE_TYPE :
         return CLUB_DISCUSS_MESSAGE_TYPE_NOMINATE;
      case CLUB_DISCUSS_MESSAGE_NOMINATION_QUERY :
         return frog->choices;
      case CLUB_DISCUSS_MESSAGE_REMOVE_POSITION :
         if (frog->name == arg1) {
            remove_discussion_item(club_name, frog);
            return 1;
         }
         return 0;
   }
   return 0;
}
private mixed club_discuss_election(int message,
                                    string club_name,
                                    class discussion_idea frog,
                                    string arg1,
                                    string arg2) {
   string body;
   string name;
   int num;
   int highest;
   string *voted;
   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         frog->name = query_position_name(club_name, frog->name);
         if (is_nomination_or_election_being_discussed(club_name, frog->name)) {
            return 0;
         }
         if (!is_valid_position(club_name, frog->name)) {
            return 0;
         }
         if (is_election_in_progress(club_name) ||
             is_nomination_in_progress(club_name)) {
            return 0;
         }
         foreach (name, num in frog->choices) {
            frog->choices[name] = 0;
            if (!is_member_of(club_name, name)) {
               map_delete(frog->choices, name);
            }
         }
         if (!sizeof(frog->choices)) {
            return 0;
         }
         return 1;
      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item "
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "  The vote the position of " +
                frog->name + " in the club " +
                query_club_name(club_name) +
                " has been completed and the "
            "results are:\n";
         highest = 0;
         voted = ({ });
         foreach (name, num in frog->choices) {
            body += name + ": " + num + "\n";
            if (num > highest) {
               highest = num;
               voted = ({ name });
            } else if (highest == num) {
               voted += ({ name });
            }
         }
         if (frog->information) {
            body += frog->information;
         }
         if (sizeof(voted)) {
            if (is_valid_position(club_name,
                                  frog->name)) {
               if (sizeof(voted) == 1) {
                  body += "Therefor " + voted[0] +
                     " was elected to the position of " + frog->name +
                     ".\n";
                  set_position_holder(club_name, frog->name, voted[0]);
               } else {
                  body += "More than one person tied for the position, so "
                     "the election has been added again.\n";
               }
            } else {
               body += "The position in the club appears to have vanished!\n";
            }
         } else {
            body += "No one voted for anyone, so nothing happened.\n";
         }
         do_mail_committee(club_name,
                           "Results of election",
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;
      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Election for the position of " + frog->name + ".\n";
         if (frog->information) {
            body += frog->information;
         }
         return body;
      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "Election for " + frog->name;
      case CLUB_DISCUSS_MESSAGE_REMOVE_MEMBER :
         if (!undefinedp(frog->choices[arg1])) {
            map_delete(frog->choices, arg1);
            return 1;
         }
         return 0;
      case CLUB_DISCUSS_MESSAGE_CHANGE_POSITION :
         if (frog->name == arg1) {
            frog->name = arg2;
            return 1;
         }
         return 0;
      case CLUB_DISCUSS_MESSAGE_REMOVE_POSITION :
         if (frog->name == arg1) {
            remove_discussion_item(club_name, frog);
            return 1;
         }
         return 0;
   }
   return 0;
}
private mixed club_discuss_function(int message,
                                    string club_name,
                                    class discussion_idea frog,
                                    string arg1,
                                    string arg2) {
   mixed ret;
   ret = call_other(frog->name[CLUB_DISCUSS_FUNCTION_OBJECT],
                    frog->name[CLUB_DISCUSS_FUNCTION_FUNCTION],
                    message,
                    club_name,
                    frog,
                    arg1,
                    arg2);
   if (message == CLUB_DISCUSS_MESSAGE_COMPLETE &&
       stringp(ret)) {
      do_mail_committee(club_name,
                      send_discuss_message(club_name,
                                           CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                           frog,
                                           arg1,
                                           arg2),
                      ret);
      archive_discussion_item(club_name,
                              send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                              ret);
      return 1;
   }
   return ret;
}
private mixed club_discuss_create_account(int message,
                                    string club_name,
                                    class discussion_idea frog,
                                    string arg1,
                                    string arg2) {
   string body;
   class discussion_idea womble;
   switch (message) {
      case CLUB_DISCUSS_MESSAGE_VERIFY :
         do {
            womble = query_discussion_item_by_type(club_name,
                                                   CLUB_DISCUSS_CREATE_ACCOUNT,
                                                   womble);
            if (womble &&
                womble->name == frog->name) {
               return 0;
            }
         } while (womble);
         frog->choices = ([ CLUB_DISCUSS_YES_CHOICE : 0,
                            CLUB_DISCUSS_NO_CHOICE : 0,
                            CLUB_DISCUSS_ABSTAIN_CHOICE : 0 ]);
         if (is_account_of(club_name, frog->name)) {
            return 0;
         }
         return 1;
      case CLUB_DISCUSS_MESSAGE_COMPLETE :
         body = "Hello!\n\nThe discussion item "
                "added at " + ctime(frog->time_added) + ", finished at " +
                ctime(time()) + " and added by " + frog->added_by +
                " has finished.";
         body += "  The vote for adding the special account " +
                frog->name + " in the club " +
                query_club_name(club_name) +
                " has been completed and the "
                "results are " +
                frog->choices[CLUB_DISCUSS_YES_CHOICE] + " in favour, " +
                frog->choices[CLUB_DISCUSS_NO_CHOICE] + " against and " +
                frog->choices[CLUB_DISCUSS_ABSTAIN_CHOICE] + " abstaining.\n";
         if (frog->choices[CLUB_DISCUSS_YES_CHOICE] >
             frog->choices[CLUB_DISCUSS_NO_CHOICE]) {
            if (create_account(club_name, frog->name)) {
                body += "Which means the special account " + frog->name +
                     " has been created.\n";
            } else {
                body += "Which means the special account " + frog->name +
                     " was attempted to be created but had some problems.\n";
            }
         } else {
            body += "Which means the special account " + frog->name +
                  " has not been created.\n";
         }
         if (frog->information) {
            body += frog->information;
         }
         do_mail_committee(club_name,
                           "Results of creating account",
                           body);
         archive_discussion_item(club_name,
                                 send_discuss_message(club_name,
                                                 CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                 frog,
                                                 0,
                                                 0),
                                 body);
         return 1;
      case CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION :
         body = "Creating the special account " + frog->name + ".\n";
         if (frog->information) {
            body += frog->information;
         }
         return body;
      case CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION :
         return "Create special account " + frog->name;
   }
   return 0;
}
class discussion_idea query_discussion_item(string club_name,
                                            int id) {
   class election_info frog;
   class discussion_idea bing;
   frog = (class election_info)query_elected_info(club_name);
   if (frog) {
      foreach (bing in frog->discussion) {
         if (bing->id == id) {
            return bing;
         }
      }
   }
   return 0;
}
class discussion_idea* query_all_discussion_items(string club_name) {
   class election_info frog;
   frog = (class election_info)query_elected_info(club_name);
   if (frog) {
      return copy(frog->discussion);
   }
   return 0;
}
string query_discussion_item_short_description(string club_name,
                                               int id) {
   class discussion_idea bing;
   bing = query_discussion_item(club_name, id);
   if (bing) {
      if (_discussion_items[bing->discuss_type & CLUB_DISCUSS_TYPE_MASK]) {
         return send_discuss_message(club_name,
                                     CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                     bing,
                                     0,
                                     0);
      }
   }
   return 0;
}
string query_discussion_item_long_description(string club_name,
                                            int id) {
   class discussion_idea bing;
   bing = query_discussion_item(club_name, id);
   if (bing) {
      if (_discussion_items[bing->discuss_type & CLUB_DISCUSS_TYPE_MASK]) {
         return send_discuss_message(club_name,
                                     CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION,
                                     bing,
                                     0,
                                     0);
      }
   }
   return 0;
}
int is_valid_discussion_item_type(int type) {
   if (_discussion_items[type & CLUB_DISCUSS_TYPE_MASK]) {
      return 1;
   }
   return 0;
}
int add_discussion_item(string club,
                        int type,
                        string added_by,
                        string name,
                        string info,
                        string *choices,
                        int time_to_finish,
                        mixed extra_data) {
   class discussion_idea bing;
   class election_info frog;
   int max_id;
   string choice;
   int i;
   if (is_elected_club(club) &&
       is_valid_discussion_item_type(type) &&
       time_to_finish > 0 &&
       (is_member_of(club, lower_case(added_by)) ||
        added_by == CLUB_CONTROLLER_MEMBER ||
        normalise_name(added_by) == normalise_name(club))) {
      frog = (class election_info)query_elected_info(club);
      if (!pointerp(frog->discussion)) {
         frog->discussion = ({ });
      }
      bing = new(class discussion_idea);
      max_id = 0;
      for (i = 0; i < sizeof(frog->discussion); i++) {
         if (frog->discussion[i]->id > max_id) {
            max_id = frog->discussion[i]->id;
         }
      }
      bing->id = max_id + 1;
      bing->time_added = time();
      bing->time_finish = time() + time_to_finish;
      bing->discuss_type = type;
      bing->added_by = added_by;
      bing->name = name;
      bing->information = info;
      bing->choices = ([ ]);
      foreach (choice in choices) {
         bing->choices[lower_case(choice)] = 0;
      }
      bing->voted = ({ });
      bing->optional_data = extra_data;
      if (send_discuss_message(club,
                               CLUB_DISCUSS_MESSAGE_VERIFY,
                               bing,
                               0,
                               0)) {
         frog->discussion += ({ bing });
         set_club_changed(club);
         return 1;
      }
      return 0;
   }
   return 0;
}
class discussion_idea query_discussion_item_by_type(string club_name,
                                                    int type,
                                                    class discussion_idea idea) {
   class election_info frog;
   class discussion_idea bing;
   int found;
   frog = (class election_info)query_elected_info(club_name);
   if (frog) {
      if (!idea) {
         found = 1;
      }
      foreach (bing in frog->discussion) {
         if (found) {
            if ((bing->discuss_type & CLUB_DISCUSS_TYPE_MASK) == type) {
               return bing;
            }
         } else if (bing == idea) {
            found = 1;
         }
      }
   }
   return 0;
}
string *query_discussion_choices(string club_name,
                             int id) {
   class discussion_idea frog;
   frog = query_discussion_item(club_name, id);
   if (frog) {
      return keys(frog->choices);
   }
   return ({ });
}
string query_discussion_added_by(string club_name,
                                 int id) {
   class discussion_idea frog;
   frog = query_discussion_item(club_name, id);
   if (frog &&
       frog->added_by) {
      return frog->added_by;
   }
   return CLUB_UNKNOWN_MEMBER;
}
int query_discussion_time_finish(string club_name,
                                 int id) {
   class discussion_idea frog;
   frog = query_discussion_item(club_name, id);
   if (frog) {
      return frog->time_finish;
   }
   return 0;
}
int query_discussion_time_added(string club_name,
                                 int id) {
   class discussion_idea frog;
   frog = query_discussion_item(club_name, id);
   if (frog) {
      return frog->time_finish;
   }
   return 0;
}
mixed query_discussion_optional_data(string club_name,
                                     int id) {
   class discussion_idea frog;
   frog = query_discussion_item(club_name, id);
   if (frog) {
      return frog->optional_data;
   }
   return 0;
}
mapping query_discussion_nomination(string club_name,
                                    int id) {
   class discussion_idea frog;
   mapping stuff;
   frog = query_discussion_item(club_name, id);
   if (frog) {
      stuff = send_discuss_message(club_name,
                                   CLUB_DISCUSS_MESSAGE_NOMINATION_QUERY,
                                   frog,
                                   0,
                                   0);
      if (stuff) {
         return stuff;
      }
      return ([ ]);
   }
   return ([ ]);
}
int is_discuss_person_nominated(string club_name,
                               int id,
                               string nominator,
                               string nominated) {
   mapping bing;
   bing = query_discussion_nomination(club_name, id);
   if (bing[nominated]) {
      if (member_array(nominator, bing[nominated]) != -1) {
         return 1;
      }
   }
   return 0;
}
int is_committee_discussion_item(string club_name,
                                 int id) {
   class discussion_idea frog;
   frog = query_discussion_item(club_name, id);
   if (frog) {
       if (frog->discuss_type & CLUB_DISCUSS_OPEN) {
          return 0;
       }
       return 1;
   }
   return 0;
}
int is_no_quorum_discussion_item(string club_name,
                                 int id) {
   class discussion_idea frog;
   frog = query_discussion_item(club_name, id);
   if (frog) {
       if (frog->discuss_type & CLUB_DISCUSS_NO_QUORUM) {
          return 1;
       }
       return 0;
   }
   return 0;
}
int is_discussion_item_finished(string club_name,
                                int id) {
   class discussion_idea frog;
   string *committee;
   frog = query_discussion_item(club_name, id);
   if (frog) {
      if (is_committee_discussion_item(club_name, id)) {
         committee = query_committee(club_name);
         if (committee &&
             !sizeof(committee - frog->voted)) {
            return 1;
         }
      }
      if (frog->time_finish < time()) {
         return 1;
      }
   }
   return 0;
}
int query_discussion_item_quorum_number(string club_name,
                                        int id) {
   class discussion_idea bing;
   int num;
   bing = query_discussion_item(club_name, id);
   if (is_no_quorum_discussion_item(club_name, id)) {
      return 0;
   } else if (is_committee_discussion_item(club_name, id)) {
      num = sizeof(filter(query_committee(club_name),
                          (: $1 != CLUB_UNKNOWN_MEMBER &&
                             PLAYER_HANDLER->test_active($1) :)));
      return (num * CLUB_DISCUSS_QUORUM_COMMITTEE / 100);
   } else {
      num = sizeof(filter(query_members(club_name),
                          (: $1 != CLUB_UNKNOWN_MEMBER &&
                             PLAYER_HANDLER->test_active($1, 1) :)));
      return (num * CLUB_DISCUSS_QUORUM_OPEN / 100);
   }
   return 0;
}
int query_discussion_item_number_voted(string club_name,
                                       int id) {
   class discussion_idea bing;
   bing = query_discussion_item(club_name, id);
   if (bing) {
      return sizeof(bing->voted);
   }
   return 0;
}
int is_discussion_item_quorum(string club_name,
                              int id) {
   class discussion_idea bing;
   int num;
   bing = query_discussion_item(club_name, id);
   if (bing) {
      num = query_discussion_item_quorum_number(club_name, id);
      if (sizeof(bing->voted) >= num) {
         return 1;
      }
   }
   return 0;
}
int is_valid_discussion_choice(string club_name,
                               int id,
                               string choice) {
   class discussion_idea frog;
   frog = query_discussion_item(club_name, id);
   choice = lower_case(choice);
   if (frog &&
       !undefinedp(frog->choices[choice])) {
      return 1;
   }
   return 0;
}
int is_discuss_votable(string club_name,
                       int id) {
   class discussion_idea frog;
   frog = query_discussion_item(club_name, id);
   if (frog) {
      if (send_discuss_message(club_name,
                               CLUB_DISCUSS_MESSAGE_TYPE,
                               frog,
                               0,
                               0) == CLUB_DISCUSS_MESSAGE_TYPE_VOTE) {
         return 1;
      }
   }
   return 0;
}
int is_discuss_nominateable(string club_name,
                            int id) {
   class discussion_idea frog;
   frog = query_discussion_item(club_name, id);
   if (frog) {
      if (send_discuss_message(club_name,
                               CLUB_DISCUSS_MESSAGE_TYPE,
                               frog,
                               0,
                               0) == CLUB_DISCUSS_MESSAGE_TYPE_NOMINATE) {
         return 1;
      }
   }
   return 0;
}
int can_reference_discussion_item(string club_name,
                                  int id,
                                  string person) {
   class discussion_idea frog;
   frog = query_discussion_item(club_name, id);
   if (frog &&
       (!is_committee_discussion_item(club_name, id) ||
        holds_any_position_of(club_name, person))) {
      return 1;
   }
   return 0;
}
int has_voted_for_discussion_item(string club_name,
                                  int id,
                                  string person) {
   class discussion_idea frog;
   frog = query_discussion_item(club_name, id);
   if (frog &&
       member_array(person, frog->voted) != -1) {
      return 1;
   }
   return 0;
}
int vote_for_discussion_item(string club_name,
                             int id,
                             string person,
                             string choice) {
   class discussion_idea frog;
   frog = query_discussion_item(club_name, id);
   choice = lower_case(choice);
   if (frog &&
       can_reference_discussion_item(club_name, id, person) &&
       !has_voted_for_discussion_item(club_name, id, person) &&
       is_valid_discussion_choice(club_name, id, choice) &&
       is_discuss_votable(club_name, id)) {
      frog->choices[choice]++;
      frog->voted += ({ person });
      set_club_changed(club_name);
      return 1;
   }
   return 0;
}
int nominate_discussion_item(string club_name,
                             int id,
                             string nominator,
                             string nominated) {
   class discussion_idea frog;
   frog = query_discussion_item(club_name, id);
   if (frog &&
       is_member_of(club_name, nominator) &&
       is_member_of(club_name, nominated) &&
       is_discuss_nominateable(club_name, id)) {
      if (!is_creator_club(club_name) &&
          PLAYER_HANDLER->test_creator(nominated)) {
         return 0;
      }
      if (send_discuss_message(club_name,
                               CLUB_DISCUSS_MESSAGE_NOMINATION,
                               frog,
                               nominator,
                               nominated)) {
         set_club_changed(club_name);
         return 1;
      }
   }
   return 0;
}
int withdraw_discussion_item(string club_name,
                             int id,
                             string withdraw) {
   class discussion_idea frog;
   frog = query_discussion_item(club_name, id);
   if (frog &&
       is_member_of(club_name, withdraw) &&
       is_discuss_nominateable(club_name, id)) {
      if (send_discuss_message(club_name,
                               CLUB_DISCUSS_MESSAGE_WITHDRAW,
                               frog,
                               withdraw,
                               withdraw)) {
         set_club_changed(club_name);
         return 1;
      }
   }
   return 0;
}
protected int remove_discussion_item(string club_name,
                                     class discussion_idea item) {
   class election_info bing;
   int i;
   bing = (class election_info)query_elected_info(club_name);
   if (bing) {
      for (i = 0; i < sizeof(bing->discussion); i++) {
         if (bing->discussion[i] == item) {
            bing->discussion = bing->discussion[0..i - 1] +
               bing->discussion[i + 1..];
            set_club_changed(club_name);
            return 1;
         }
      }
   }
   return 0;
}
int complete_discussion_item(string club_name,
                             int id) {
   class discussion_idea frog;
   class election_info bing;
   int ret;
   frog = query_discussion_item(club_name, id);
   bing = (class election_info)query_elected_info(club_name);
   if (frog &&
       is_discussion_item_finished(club_name, id)) {
      if (is_discussion_item_quorum(club_name, id)) {
         if (_discussion_items[frog->discuss_type & CLUB_DISCUSS_TYPE_MASK]) {
            send_broadcast_message(club_name,
                                   "Finished discussion item: " +
                                   send_discuss_message(club_name,
                                                        CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION,
                                                        frog,
                                                        0,
                                                        0) +
                                   " see archives for results.");
            send_discuss_message(club_name,
                                 CLUB_DISCUSS_MESSAGE_COMPLETE,
                                 frog,
                                 0,
                                 0);
         } else {
            ret = -1;
            do_mail_committee(club_name,
                              "Completed vote",
                              "The completed vote on:\n" +
                              "Discussion type " +
                               (frog->discuss_type & CLUB_DISCUSS_TYPE_MASK) +
                              " failed due to major internal messes.\n");
         }
      } else {
         if (_discussion_items[frog->discuss_type & CLUB_DISCUSS_TYPE_MASK]) {
            do_mail_committee(club_name,
                              "Completed vote",
                              "The completed vote on:\n" +
                              query_discussion_item_long_description(club_name,
                                                                     id) +
                              "\n\nDid not have quorum, only " +
                              sizeof(frog->voted) + " people voted.\n");
         } else {
            do_mail_committee(club_name,
                              "Completed vote",
                              "The completed vote on:\n" +
                              "Discussion type " + (frog->discuss_type & CLUB_DISCUSS_TYPE_MASK) +
                              " failed due to major internal messes.\n");
         }
         ret = -1;
      }
      remove_discussion_item(club_name, frog);
   }
   return ret;
}
protected mixed send_discuss_message(string club_name,
                                     int message,
                                     class discussion_idea item,
                                     string arg1,
                                     string arg2) {
   return evaluate(_discussion_items[item->discuss_type &
                                           CLUB_DISCUSS_TYPE_MASK],
                   message,
                   club_name,
                   item,
                   arg1,
                   arg2);
}
protected void broadcast_discuss_message(string club_name,
                                         int message,
                                         string arg1,
                                         string arg2) {
   class discussion_idea frog;
   class election_info bing;
   bing = (class election_info)query_elected_info(club_name);
   foreach (frog in bing->discussion) {
      if (send_discuss_message(club_name,
                               message,
                               frog,
                               arg1,
                               arg2)) {
         set_club_changed(club_name);
      }
   }
}
int remove_member(string name,
                  string member) {
   if (::remove_member(name, member)) {
      if (is_elected_club(name)) {
         broadcast_discuss_message(name,
                                   CLUB_DISCUSS_MESSAGE_REMOVE_MEMBER,
                                   member,
                                   0);
      }
      return 1;
   }
   return 0;
}
int change_position_name_in_club(string name,
                                 string position,
                                 string new_position) {
   if (::change_position_name_in_club(name, position, new_position)) {
      if (is_elected_club(name)) {
         broadcast_discuss_message(name,
                                   CLUB_DISCUSS_MESSAGE_CHANGE_POSITION,
                                   position,
                                   new_position);
      }
      return 1;
   }
   return 0;
}
int remove_position_in_club(string name,
                            string position) {
   if (::remove_position_in_club(name, position)) {
      if (is_elected_club(name)) {
         broadcast_discuss_message(name,
                                   CLUB_DISCUSS_MESSAGE_REMOVE_POSITION,
                                   position,
                                   0);
      }
      return 1;
   }
   return 0;
}
int set_position_holder(string club_name,
                                  string position,
                                  string person) {
   if (::set_position_holder(club_name, position, person)) {
      if (person == CLUB_UNKNOWN_MEMBER) {
         add_discussion_item(club_name,
                             CLUB_DISCUSS_NOMINATION |
                                CLUB_DISCUSS_NO_QUORUM |
                                CLUB_DISCUSS_OPEN,
                             CLUB_CONTROLLER_MEMBER,
                             position,
                             "Position became vacant.\n",
                             ({ }),
                             7 * (24 * 60 * 60),
                             0);
      }
      return 1;
   }
   return 0;
}
int start_election(string name) {
   class discussion_idea womble;
   class election_info data;
   int type;
   if (::start_election(name)) {
      data = (class election_info)query_elected_info(name);
      foreach (womble in data->discussion) {
         type = womble->discuss_type & CLUB_DISCUSS_TYPE_MASK;
         if (type == CLUB_DISCUSS_NOMINATION ||
             type == CLUB_DISCUSS_ELECTION) {
            remove_discussion_item(name, womble);
            set_club_changed(name);
         }
      }
      return 1;
   }
   return 0;
}
protected void check_elected_information(string name,
                                        string member,
                                        int startup) {
   class election_info data;
   class discussion_idea frog;
   string pos;
   ::check_elected_information(name, member, startup);
   data = (class election_info)query_elected_info(name);
   if (data) {
      foreach (frog in data->discussion) {
         if (is_discussion_item_finished(name, frog->id)) {
            complete_discussion_item(name, frog->id);
            set_club_changed(name);
         } else if (frog->discuss_type == CLUB_DISCUSS_NOMINATION ||
                    frog->discuss_type == CLUB_DISCUSS_ELECTION) {
           if (!is_election_in_progress(name) &&
               !is_nomination_in_progress(name)) {
               frog->discuss_type |= CLUB_DISCUSS_OPEN |
                                     CLUB_DISCUSS_NO_QUORUM;
               set_club_changed(name);
            } else {
               remove_discussion_item(name, frog);
            }
         }
      }
      foreach (pos, member in data->positions) {
         if (member == CLUB_UNKNOWN_MEMBER &&
             !is_election_in_progress(name) &&
             !is_nomination_in_progress(name) &&
             !is_nomination_or_election_being_discussed(name, pos)) {
            setup_by_election(name,
                              pos,
                              "Automatic after the position is declared "
                              "vacant.\n");
            set_club_changed(name);
         }
      }
   }
}
int setup_by_election(string club,
                      string position,
                      string info) {
   return add_discussion_item(club,
                              CLUB_DISCUSS_NOMINATION |
                                 CLUB_DISCUSS_OPEN |
                                 CLUB_DISCUSS_NO_QUORUM,
                              CLUB_CONTROLLER_MEMBER,
                              position,
                              info,
                              ({ }),
                              7 * 24 * 60 * 60,
                              0);
}

==================================================
FILE: handlers/inherit/club_elected.c
==================================================

inherit "/obj/handlers/inherit/club_family";
#define __CLUBS_H_NO_CLASSES
#include <clubs.h>
#include <mail.h>
#include <board.h>
#include <player_handler.h>
private mapping _elections;
private string *_boards;
private nosave mapping _discussion_items;
#define CLUB_PRESIDENT_INDEX          "president"
#define CLUB_VICE_PRESIDENT_INDEX     "vice-president"
#define CLUB_TREASURER_INDEX          "treasurer"
#define CLUB_SECRETARY_INDEX          "secretary"
#define CLUB_ORDINARY_COMMITTEE_INDEX "committee"
#define CLUB_BOARD_PREFIX "club "
#define CLUB_DISCUSS_MESSAGE_VERIFY            1
#define CLUB_DISCUSS_MESSAGE_COMPLETE          2
#define CLUB_DISCUSS_MESSAGE_SHORT_DESCRIPTION 3
#define CLUB_DISCUSS_MESSAGE_LONG_DESCRIPTION  4
#define CLUB_DISCUSS_MESSAGE_NOMINATION        5
#define CLUB_MAX_ARCHIVE_SIZE 50
int is_nomination_accepted(string club_name,
                           string position,
                           string person);
int complete_election(string club_name);
int start_election(string club_name);
int holds_position_of(string name, string position, string person);
string query_position_name(string club_name,
                           string position);
int set_position_holder(string club_name,
                                  string position,
                                  string person);
protected int add_archive(string club_name,
                          string subject,
                          string thingy);
string query_club_board_name(string club_name);
class election_info {
   string treasurer;
   string president;
   string vice_president;
   string secretary;
   mapping account_info;
   mapping positions;
   int last_election;
   int election_period;
   mapping options;
   class discussion_idea *discussion;
   class club_archive *archives;
   string announcement;
   int announce_time;
}
#define CLUB_NOMINATION        1
#define CLUB_NOMINATION_SECOND 3
#define CLUB_ELECTION          2
class election_data {
   int time_of_event;
   int state;
   mapping people;
   mapping nominated;
   mapping voted_for;
   string election_status;
}
class account_info {
   class club_transaction* transactions;
   string* allowed_people;
   string* allowed_positions;
}
private class election_info query_elected_info(string name);
void create() {
   _elections = ([ ]);
   _boards = ({ });
   ::create();
   if (!_boards) {
      _boards = ({ });
   }
}
protected void create_extra_data(string name) {
   class election_info e_info;
   class club_info data;
   class club_transaction bing;
   class account_info frog;
   if (query_club_type(name)== CLUB_ELECTED) {
      data = (class club_info)query_club_info(name);
      e_info = new(class election_info);
      e_info->treasurer = CLUB_TREASURER_INDEX;
      e_info->president = CLUB_PRESIDENT_INDEX;
      e_info->vice_president = CLUB_VICE_PRESIDENT_INDEX;
      e_info->secretary = CLUB_SECRETARY_INDEX;
      e_info->discussion = ({ });
      e_info->positions = ([
                             CLUB_TREASURER_INDEX : CLUB_UNKNOWN_MEMBER,
                             CLUB_PRESIDENT_INDEX : data->founder,
                             CLUB_VICE_PRESIDENT_INDEX : CLUB_UNKNOWN_MEMBER,
                             CLUB_SECRETARY_INDEX : CLUB_UNKNOWN_MEMBER,
                           ]);
      e_info->account_info = ([ ]);
      e_info->last_election = time();
      e_info->options = ([ ]);
      e_info->election_period = CLUB_INVALID_TIME;
      e_info->announcement = "";
      e_info->archives = ({ });
      e_info->announce_time = 0;
      data->extra_data = e_info;
      set_club_changed(name);
      bing = new(class club_transaction);
      bing->date = time();
      bing->amount = query_balance(name, CLUB_DEFAULT_ACCOUNT_NAME);
      bing->transaction_type = CLUB_TRANSACTION_START_BALANCE;
      bing->who = CLUB_CONTROLLER_MEMBER;
      frog = new(class account_info);
      frog->transactions = ({ bing });
      frog->allowed_people = ({ });
      frog->allowed_positions = ({ CLUB_TREASURER_INDEX,
                                   CLUB_PRESIDENT_INDEX });
      e_info->account_info[CLUB_DEFAULT_ACCOUNT_NAME] = frog;
      set_club_changed(name);
   } else {
      ::create_extra_data(name);
   }
}
int change_club_type(string name,
                     int type) {
   if (::change_club_type(name, type)) {
      start_election(name);
      return 1;
   }
   return 0;
}
int disband_club(string name) {
   if (::disband_club(name)) {
      map_delete(_elections, name);
      _boards -= ({ query_club_board_name(name) });
      save_main();
      return 1;
   }
   return 0;
}
protected class election_info query_elected_info(string name) {
   class club_info data;
   class account_info fluff;
   if (is_elected_club(name)) {
      data = (class club_info)query_club_info(name);
      if (pointerp(data->extra_data->account_info)) {
         fluff = new(class account_info);
         fluff->transactions = data->extra_data->account_info;
         fluff->allowed_people = ({ });
         fluff->allowed_positions = ({ data->extra_data->president,
                                       data->extra_data->treasurer });
         data->extra_data->account_info = ([ CLUB_DEFAULT_ACCOUNT_NAME : fluff ]);
      }
      return data->extra_data;
   }
   return 0;
}
protected class account_info query_account_info(string name, string account) {
   class election_info bing;
   bing = query_elected_info(name);
   if (bing) {
      if (!account) {
         account = CLUB_DEFAULT_ACCOUNT_NAME;
      }
      return bing->account_info[account];
   }
   return 0;
}
int remove_member(string club, string member) {
   class election_info bing;
   class account_info fluff;
   string account;
   string person;
   string position;
   string name;
   mapping nominations;
   string *people;
   if (::remove_member(club, member)) {
      bing = query_elected_info(club);
      if (bing) {
         foreach (account, fluff in bing->account_info) {
            fluff->allowed_people -= ({ member });
         }
         foreach (position, person in bing->positions) {
            if (person == member) {
               set_position_holder(club, position, CLUB_UNKNOWN_MEMBER);
            }
         }
      }
      name = normalise_name(club);
      if (_elections[name]) {
         foreach (position, nominations in _elections[name]->nominated) {
            map_delete(nominations, member);
            foreach (person, people in nominations) {
               nominations[person] = people - ({ member });
            }
         }
         foreach (position, nominations in _elections[name]->people) {
            map_delete(nominations, member);
         }
      }
      return 1;
   }
   return 0;
}
int query_last_election(string name) {
   class election_info info;
   info = query_elected_info(name);
   if (info) {
      return info->last_election;
   }
   return 0;
}
int query_next_election(string name) {
   int bing;
   bing = query_last_election(name);
   if (bing) {
      return bing + CLUB_ELECTION_PERIOD;
   }
   return 0;
}
int query_minimum_next_election(string name) {
   int bing;
   bing = query_last_election(name);
   if (bing) {
      return bing + CLUB_MINIMUM_ELECTION_PERIOD;
   }
   return 0;
}
int is_president_of(string name, string president) {
   class election_info info;
   info = query_elected_info(name);
   if (info) {
      return holds_position_of(name, info->president, president);
   }
   return 0;
}
int is_vice_president_of(string name, string vice_president) {
   class election_info info;
   info = query_elected_info(name);
   if (info) {
      return holds_position_of(name, info->vice_president, vice_president);
   }
   return 0;
}
int is_secretary_of(string name, string secretary) {
   class election_info info;
   info = query_elected_info(name);
   if (info) {
      return holds_position_of(name, info->secretary, secretary);
   }
   return 0;
}
int is_treasurer_of(string name, string treasurer) {
   class election_info info;
   info = query_elected_info(name);
   if (info) {
      return holds_position_of(name, info->treasurer, treasurer);
   }
   return 0;
}
int holds_any_position_of(string name, string person) {
   class election_info info;
   string pos_name;
   string per_name;
   info = query_elected_info(name);
   if (info) {
      foreach (pos_name, per_name in info->positions) {
         if (per_name == person) {
            return 1;
         }
      }
   }
   return 0;
}
int holds_position_of(string name, string position, string person) {
   class election_info info;
   info = query_elected_info(name);
   if (info) {
      position = query_position_name(name, position);
      return info->positions[position] == person;
   }
}
int create_account(string name, string account) {
   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (::create_account(name, account)) {
      class election_info info;
      class account_info frog;
      info = query_elected_info(name);
      if (info) {
         frog = new(class account_info);
         frog->transactions = ({ });
         frog->allowed_people = ({ });
         frog->allowed_positions = ({ info->president, info->treasurer });
         info->account_info[account] = frog;
         set_club_changed(name);
      }
      return 1;
   }
   return 0;
}
int add_money(string name,
              int amount,
              int type,
              string person,
              string account,
              string information) {
   class account_info frog;
   class club_transaction bing;
   if (::add_money(name, amount, type, person, account)) {
      frog = query_account_info(name, account);
      if (frog) {
         bing = new(class club_transaction);
         bing->date = time();
         bing->amount = amount;
         bing->transaction_type = type;
         bing->who = person;
         bing->information = information;
         frog->transactions += ({ bing });
         set_club_changed(name);
      }
      return 1;
   }
   return 0;
}
int remove_money(string name,
                 int amount,
                 int type,
                 string person,
                 string account,
                 string information) {
   class account_info frog;
   class club_transaction bing;
   if (::remove_money(name, amount, type, person, account)) {
      frog = query_account_info(name, account);
      if (frog) {
         bing = new(class club_transaction);
         bing->date = time();
         bing->amount = -amount;
         bing->transaction_type = type;
         bing->who = person;
         bing->information = information;
         frog->transactions += ({ bing });
         set_club_changed(name);
      }
      return 1;
   }
   return 0;
}
class club_transaction* query_transactions(string name, string account) {
   class account_info frog;
   class club_transaction bing;
   class club_transaction old;
   int i;
   if (is_elected_club(name)) {
      frog = query_account_info(name, account);
      if (sizeof(frog->transactions) &&
          sizeof(frog->transactions[0]) == 4) {
         for (i = 0; i < sizeof(frog->transactions); i++) {
            old = frog->transactions[i];
            bing = new(class club_transaction);
            bing->who = old->who;
            bing->transaction_type = old->transaction_type;
            bing->amount = old->amount;
            bing->date = old->date;
            bing->information = 0;
            frog->transactions[i] = bing;
            set_club_changed(name);
         }
      }
      return frog->transactions;
   }
   return ({ });
}
string query_transaction_type_name(int type) {
   switch (type) {
      case CLUB_TRANSACTION_UPKEEP :
         return "upkeep";
      case CLUB_TRANSACTION_DEPOSIT :
         return "player deposit";
      case CLUB_TRANSACTION_INSIGNIA :
         return "insignia";
      case CLUB_TRANSACTION_START_BALANCE :
         return "start balance";
      case CLUB_TRANSACTION_WITHDRAWL :
         return "player withdrawl";
      case CLUB_TRANSACTION_TRANSFER :
         return "player transfer";
      default :
         return "unknown";
   }
}
string* query_account_allowed_people(string club_name, string account) {
   class account_info frog;
   frog = query_account_info(club_name, account);
   if (frog) {
      return frog->allowed_people;
   }
   return ({ });
}
int is_allowed_to_modify_account(string club_name,
                               string account,
                               string person) {
   class account_info frog;
   string pos;
   frog = query_account_info(club_name, account);
   if (frog) {
      if (member_array(person, frog->allowed_people) != -1) {
         return 1;
      }
      foreach (pos in frog->allowed_positions) {
         if (holds_position_of(club_name, pos, person)) {
            return 1;
         }
      }
   }
   return 0;
}
int add_account_allowed_person(string club_name, string account, string person) {
   class account_info frog;
   frog = query_account_info(club_name, account);
   if (frog &&
       member_array(person, frog->allowed_people) == -1) {
      frog->allowed_people += ({ person });
      set_club_changed(club_name);
      return 1;
   }
   return 0;
}
int remove_account_allowed_person(string club_name, string account, string person) {
   class account_info frog;
   frog = query_account_info(club_name, account);
   if (frog &&
       member_array(person, frog->allowed_people) != -1) {
      frog->allowed_people -= ({ person });
      set_club_changed(club_name);
      return 1;
   }
   return 0;
}
string* query_account_allowed_positions(string club_name, string account) {
   class account_info frog;
   frog = query_account_info(club_name, account);
   if (frog) {
      return frog->allowed_positions;
   }
   return ({ });
}
int add_account_allowed_position(string club_name, string account, string position) {
   class account_info frog;
   frog = query_account_info(club_name, account);
   if (frog &&
       member_array(position, frog->allowed_positions) == -1) {
      frog->allowed_positions += ({ position });
      set_club_changed(club_name);
      return 1;
   }
   return 0;
}
int remove_account_allowed_position(string club_name, string account, string position) {
   class account_info frog;
   frog = query_account_info(club_name, account);
   if (frog &&
       member_array(position, frog->allowed_positions) != -1) {
      frog->allowed_positions -= ({ position });
      set_club_changed(club_name);
      return 1;
   }
   return 0;
}
int set_elected_option(string club_name,
                       string option,
                       mixed value) {
   class election_info data;
   data = query_elected_info(club_name);
   if (data) {
      data->options[option] = value;
      set_club_changed(club_name);
      return 1;
   }
   return 0;
}
int remove_elected_option(string club_name,
                          string option) {
   class election_info data;
   data = query_elected_info(club_name);
   if (data) {
      map_delete(data->options, option);
      set_club_changed(club_name);
      return 1;
   }
   return 0;
}
mixed query_elected_option(string club_name,
                           string option) {
   class election_info data;
   data = query_elected_info(club_name);
   if (data) {
      return data->options[option];
   }
   return 0;
}
int is_elected_option(string club_name,
                      string option) {
   class election_info data;
   data = query_elected_info(club_name);
   if (data) {
      return !undefinedp(data->options[option]);
   }
   return 0;
}
int start_election(string club_name) {
   string name;
   string pos;
   class election_info bing;
   string *stuff;
   name = normalise_name(club_name);
   if (is_elected_club(name)) {
      if (!_elections[name]) {
         bing = query_elected_info(name);
         _elections[name] = new(class election_data);
         _elections[name]->people = ([ ]);
         _elections[name]->nominated = ([ ]);
         _elections[name]->voted_for = ([ ]);
         _elections[name]->time_of_event = time() + CLUB_NOMINATION_TIME;
         _elections[name]->state = CLUB_NOMINATION;
         foreach (pos, stuff in bing->positions) {
            _elections[name]->people[pos] = ([ ]);
            _elections[name]->nominated[pos] = ([ ]);
            _elections[name]->voted_for[pos] = ({ });
         }
         save_main();
         send_broadcast_message(name,
                         "An election has just started!  Nominate your "
                         "favourite person now at the club control centre.");
         return 1;
      }
   }
   return 0;
}
int nominate_person(string club_name, string position, string person,
                    string nominating) {
   string name;
   name = normalise_name(club_name);
   if (is_elected_club(name)) {
      if (_elections[name] &&
          (_elections[name]->state == CLUB_NOMINATION ||
           _elections[name]->state == CLUB_NOMINATION_SECOND)) {
         position = query_position_name(club_name, position);
         if (_elections[name]->nominated[position]) {
            if (!_elections[name]->nominated[position][person]) {
                _elections[name]->nominated[position][person] = ({ });
            }
            if (member_array(nominating,
                        _elections[name]->nominated[position][person]) == -1) {
               _elections[name]->nominated[position][person] += ({ nominating });
               save_main();
               return 1;
            }
         }
      }
   }
   return 0;
}
mixed finish_nomination(string club_name) {
   string name;
   string position_name;
   mapping position_data;
   string *data;
   string person;
   string *bad_positions;
   class election_info frog;
   name = normalise_name(club_name);
   bad_positions = ({ });
   if (is_elected_club(name)) {
      frog = query_elected_info(name);
      if (_elections[name] &&
          (_elections[name]->state == CLUB_NOMINATION ||
           _elections[name]->state == CLUB_NOMINATION_SECOND)) {
         foreach (position_name,
                  position_data in _elections[name]->nominated) {
            _elections[name]->people[position_name] = ([ ]);
            foreach (person, data in position_data) {
               if (is_nomination_accepted(club_name, position_name, person)) {
                  _elections[name]->people[position_name][person] = 0;
               }
            }
            if (sizeof(_elections[name]->people[position_name]) == 0) {
               bad_positions += ({ position_name });
            }
         }
         if (!sizeof(bad_positions) ||
             _elections[name]->state == CLUB_NOMINATION_SECOND) {
            foreach (position_name, position_data in _elections[name]->people) {
               if (sizeof(position_data) == 1) {
                  set_position_holder(club_name,
                                      position_name,
                                      keys(position_data)[0]);
                  map_delete(_elections[name]->people, position_name);
               }
            }
            foreach (position_name in bad_positions) {
               set_position_holder(club_name,
                                   position_name,
                                   CLUB_UNKNOWN_MEMBER);
               map_delete(_elections[name]->people, position_name);
            }
            bad_positions = ({ });
            _elections[name]->state = CLUB_ELECTION;
            if (!sizeof(_elections[name]->people)) {
               save_main();
               complete_election(name);
            } else {
               _elections[name]->election_status = 0;
               _elections[name]->time_of_event = time() +
                                                CLUB_ELECTION_TIME;
               set_club_changed(name);
               save_main();
               send_broadcast_message(name,
                            "The nomination period has finished.  Vote "
                            "for your favourite person for each position now "
                            "at the club control centre.");
            }
         } else {
            _elections[name]->election_status = "No one has accepted "
                           "nominations for " +
                           query_multiple_short(bad_positions);
            save_main();
         }
         return bad_positions;
      }
   }
   return 0;
}
int vote_for_person(string club_name,
                    string position,
                    string person,
                    string voter) {
   string name;
   name = normalise_name(club_name);
   if (is_club(name)) {
      if (_elections[name] &&
          _elections[name]->state == CLUB_ELECTION) {
         position = query_position_name(club_name, position);
         if (_elections[name]->voted_for[position] &&
             member_array(voter,
                          _elections[name]->voted_for[position]) == -1) {
            if (!undefinedp(_elections[name]->people[position][person])) {
               _elections[name]->people[position][person]++;
               _elections[name]->voted_for[position] += ({ voter });
               save_main();
               return 1;
            }
         }
      }
   }
}
int complete_election(string club_name) {
   string name;
   string position;
   mapping people;
   string person_name;
   int count;
   int max_count;
   string *max_people;
   mapping elected_positions;
   int pos;
   class election_info frog;
   name = normalise_name(club_name);
   if (is_elected_club(name) &&
       _elections[name] &&
       _elections[name]->state = CLUB_ELECTION) {
      elected_positions = ([ ]);
      foreach (position, people in _elections[name]->people) {
         max_count = 0;
         max_people = ({ });
         if (sizeof(people) > 1) {
            foreach (person_name, count in people) {
               if (count > max_count) {
                  max_count = count;
                  max_people = ({ person_name });
               } else if (count == max_count) {
                  max_people += ({ person_name });
               }
            }
         } else {
            max_people = keys(people);
         }
         if (sizeof(max_people) == 0) {
           _elections[name]->election_status = "No one has voted for "
             "the position of " + position;
           return 0;
         }
         pos = random(sizeof(max_people));
         person_name = max_people[pos];
         elected_positions[position] = person_name;
      }
      frog = query_elected_info(name);
      foreach (position, person_name in elected_positions) {
         set_position_holder(club_name, position, person_name);
      }
      frog->last_election = time();
      set_club_changed(name);
      touch_club(name);
      map_delete(_elections, name);
      save_main();
      send_broadcast_message(name, "The election has finished!");
      return 1;
   }
   return 0;
}
int is_election_in_progress(string club) {
   string name;
   name = normalise_name(club);
   if (is_elected_club(name) &&
       _elections[name]) {
      return 1;
   }
}
int is_nomination_in_progress(string club) {
   string name;
   name = normalise_name(club);
   if (is_elected_club(name) &&
       _elections[name] &&
       (_elections[name]->state == CLUB_NOMINATION ||
        _elections[name]->state == CLUB_NOMINATION_SECOND)) {
      return 1;
   }
}
int is_voting_in_progress(string club) {
   string name;
   name = normalise_name(club);
   if (is_elected_club(name) &&
       _elections[name] &&
       _elections[name]->state == CLUB_ELECTION) {
      return 1;
   }
}
string *query_valid_positions(string club_name) {
   string name;
   class election_info frog;
   name = normalise_name(club_name);
   if (is_elected_club(name)) {
      frog = query_elected_info(club_name);
      return keys(frog->positions);
   }
   return ({ });
}
string *query_committee(string club_name) {
   string name;
   class election_info frog;
   name = normalise_name(club_name);
   if (is_elected_club(name)) {
      frog = query_elected_info(club_name);
      return values(frog->positions);
   }
   return ({ });
}
int is_valid_position(string club_name,
                      string position) {
   string *pos;
   pos = map(query_valid_positions(club_name), (: lower_case :));
   return (member_array(lower_case(position), pos) != -1);
}
int is_basic_position(string club_name,
                      string position) {
   class election_info frog;
   if (is_club(club_name) &&
       is_valid_position(club_name, position)) {
      frog = query_elected_info(club_name);
      position = query_position_name(club_name, position);
      return (position == frog->president) ||
             (position == frog->vice_president) ||
             (position == frog->secretary) ||
             (position == frog->treasurer);
   }
   return 0;
}
string query_position_name(string club_name,
                           string position) {
   string *pos;
   string *real_pos;
   int i;
   real_pos = query_valid_positions(club_name);
   pos = map(real_pos, (: lower_case :));
   i = member_array(lower_case(position), pos);
   if (i == -1) {
      return 0;
   }
   return real_pos[i];
}
string query_position_members(string club_name, string position) {
   class election_info frog;
   if (is_elected_club(club_name) &&
       is_valid_position(club_name, position)) {
      position = query_position_name(club_name, position);
      frog = query_elected_info(club_name);
      if (frog->positions[position]) {
         return frog->positions[position];
      }
   }
   return "not found";
}
int create_position_in_club(string name,
                            string position) {
   class election_info frog;
   if (is_elected_club(name) &&
       !is_voting_in_progress(name) &&
       !is_valid_position(name, position)) {
      frog = query_elected_info(name);
      frog->positions[position] = CLUB_UNKNOWN_MEMBER;
      set_club_changed(name);
      if (is_nomination_in_progress(name)) {
         name = normalise_name(name);
         _elections[name]->nominated[position] = ([ ]);
         _elections[name]->voted_for[position] = ({ });
         _elections[name]->people[position] = ([ ]);
         save_main();
      }
      return 1;
   }
   return 0;
}
int remove_position_in_club(string name,
                            string position) {
   class election_info frog;
   class account_info green;
   string account;
   if (is_elected_club(name) &&
       is_valid_position(name, position) &&
       !is_voting_in_progress(name) &&
       !is_basic_position(name, position)) {
      position = query_position_name(name, position);
      frog = query_elected_info(name);
      map_delete(frog->positions, position);
      set_club_changed(name);
      if (is_nomination_in_progress(name)) {
         name = normalise_name(name);
         map_delete(_elections[name]->nominated, position);
         map_delete(_elections[name]->voted_for, position);
         map_delete(_elections[name]->people, position);
         save_main();
      }
      foreach (account, green in frog->account_info) {
         green->allowed_positions -= ({ position });
      }
      send_observer_event("club_event_remove_position",
                          name,
                          position);
      return 1;
   }
   return 0;
}
int change_position_name_in_club(string name,
                                 string position,
                                 string new_position) {
   class election_info frog;
   class account_info green;
   string account;
   int pos;
   if (is_elected_club(name) &&
       !is_valid_position(name, new_position) &&
       !is_voting_in_progress(name) &&
       is_valid_position(name, position)) {
      position = query_position_name(name, position);
      frog = query_elected_info(name);
      frog->positions[new_position] = frog->positions[position];
      map_delete(frog->positions, position);
      if (frog->president == position) {
         frog->president = new_position;
      } else if (frog->vice_president == position) {
         frog->vice_president = new_position;
      } else if (frog->secretary == position) {
         frog->secretary = new_position;
      } else if (frog->treasurer == position) {
         frog->treasurer = new_position;
      }
      set_club_changed(name);
      name = normalise_name(name);
      if (is_nomination_in_progress(name)) {
         _elections[name]->nominated[new_position] =
                                         _elections[name]->nominated[position];
         map_delete(_elections[name]->nominated, position);
         _elections[name]->voted_for[new_position] =
                                         _elections[name]->voted_for[position];
         map_delete(_elections[name]->voted_for, position);
         _elections[name]->people[new_position] =
                                         _elections[name]->people[position];
         map_delete(_elections[name]->people, position);
         save_main();
      }
      foreach (account, green in frog->account_info) {
         pos = member_array(position, green->allowed_positions);
         if (pos != -1) {
            green->allowed_positions[pos] = new_position;
         }
      }
      send_observer_event("club_event_change_position_name",
                          name,
                          position,
                          new_position);
      return 1;
   }
   return 0;
}
int set_position_holder(string club_name,
                                  string position,
                                  string person) {
   class election_info info;
   info = query_elected_info(club_name);
   if (info) {
      if (is_valid_position(club_name, position)) {
         if (is_member_of(club_name, person) ||
             person == CLUB_UNKNOWN_MEMBER) {
            position = query_position_name(club_name, position);
            info->positions[position] = person;
            set_club_changed(club_name);
            send_observer_event("club_event_position_holder",
                                club_name,
                                position,
                                person);
            return 1;
         }
      }
   }
   return 0;
}
int has_person_voted(string club_name,
                    string position,
                    string person) {
   string name;
   name = normalise_name(club_name);
   if (is_valid_position(club_name, position)) {
      if (_elections[name]) {
         position = query_position_name(club_name, position);
         if (_elections[name]->voted_for[position]) {
            return (member_array(person,
                              _elections[name]->voted_for[position]) != -1);
         } else {
            return 1;
         }
      }
   }
   return 0;
}
int has_nominated_person(string club_name,
                         string position,
                         string nominated,
                         string by) {
   string name;
   name = normalise_name(club_name);
   if (is_valid_position(club_name, position)) {
      position = query_position_name(club_name, position);
      if (_elections[name] &&
          _elections[name]->nominated[position][nominated]) {
         return (member_array(by,
                      _elections[name]->nominated[position][nominated]) != -1);
      }
   }
}
string *query_nominated_for(string club_name,
                            string position) {
   string name;
   name = normalise_name(club_name);
   if (is_valid_position(club_name, position)) {
      if (_elections[name]) {
         position = query_position_name(club_name, position);
         if (is_voting_in_progress(club_name)) {
            if (_elections[name]->people[position]) {
               return keys(_elections[name]->people[position]);
            }
            return ({ });
         } else if (is_nomination_in_progress(club_name)) {
            return keys(_elections[name]->nominated[position]);
         }
      }
   }
   return ({ });
}
string *query_nominators_for(string club_name,
                             string position,
                             string nominated) {
   string name;
   name = normalise_name(club_name);
   if (is_valid_position(club_name, position)) {
      if (_elections[name]) {
         position = query_position_name(club_name, position);
         if (is_nomination_in_progress(club_name) &&
            _elections[name]->nominated[position][nominated]) {
            return _elections[name]->nominated[position][nominated];
         }
      }
   }
   return ({ });
}
int is_nominated_for(string club_name,
                     string position,
                     string person) {
   if (is_valid_position(club_name, position)) {
      return member_array(person,
                          query_nominated_for(club_name, position)) != -1;
   }
}
int is_nomination_accepted(string club_name,
                           string position,
                           string person) {
   string *nom;
   if (is_nominated_for(club_name, position, person)) {
      nom = query_nominators_for(club_name, position, person);
      if (sizeof(nom) > 1 &&
          member_array(person, nom) != -1) {
         return 1;
      }
   }
   return 0;
}
int query_next_event_time(string club_name) {
   if (is_club(club_name)) {
      club_name = normalise_name(club_name);
      if (_elections[club_name]) {
         return _elections[club_name]->time_of_event;
      }
   }
}
string query_election_status(string club_name) {
   if (is_elected_club(club_name)) {
      if (is_election_in_progress(club_name)) {
         club_name = normalise_name(club_name);
         return _elections[club_name]->election_status;
      }
   }
}
string query_announcement(string club_name) {
   class election_info bing;
   bing = query_elected_info(club_name);
   if (bing) {
      return bing->announcement;
   }
   return "";
}
int query_announcement_time(string club_name) {
   class election_info bing;
   bing = query_elected_info(club_name);
   if (bing) {
      return bing->announce_time;
   }
   return 0;
}
int set_announcement(string club_name,
                     string announce) {
   class election_info bing;
   bing = query_elected_info(club_name);
   if (bing) {
      if (bing->announce_time &&
          strlen(bing->announcement)) {
         add_archive(club_name,
                     "Announcement",
                     "Announcement on " + ctime(time()) + ":\n\n" +
                     bing->announcement);
      }
      bing->announce_time = time();
      bing->announcement = announce;
      set_club_changed(club_name);
      send_broadcast_message(club_name, "A new announcement has been added.");
      return 1;
   }
   return 0;
}
private class club_archive* convert_archives(mixed *archives) {
   string archive;
   class club_archive bing;
   int i;
   for (i = 0; i < sizeof(archives); i++) {
      archive = archives[i];
      if (stringp(archive)) {
         bing = new(class club_archive);
         bing->archive_date = time();
         bing->subject = "unknown";
         bing->matter = archive;
         archives[i] = bing;
      }
   }
   return archives;
}
protected int add_archive(string club_name,
                          string subject,
                          string thingy) {
   class election_info data;
   class club_archive fluff;
   data = query_elected_info(club_name);
   if (data) {
      fluff = new(class club_archive);
      fluff->subject = subject;
      fluff->matter = thingy;
      fluff->archive_date = time();
      data->archives += ({ fluff });
      if (sizeof(data->archives) > CLUB_MAX_ARCHIVE_SIZE) {
         data->archives = data->archives[<CLUB_MAX_ARCHIVE_SIZE..];
      }
      if (stringp(data->archives[0])) {
         data->archives = convert_archives(data->archives);
      }
      set_club_changed(club_name);
      return 1;
   }
   return 0;
}
class club_archive *query_archives(string club_name) {
   class election_info data;
   data = query_elected_info(club_name);
   if (data) {
      if (sizeof(data->archives) &&
          stringp(data->archives[0])) {
         data->archives = convert_archives(data->archives);
         set_club_changed(club_name);
      }
      return data->archives;
   }
   return ({ });
}
string *query_boards() {
   return _boards;
}
int query_club_board(string club_name) {
   string name;
   name = query_club_board_name(club_name);
   return member_array(name, _boards) != -1;
}
string query_club_board_name(string club_name) {
   return CLUB_BOARD_PREFIX + normalise_name(club_name);
}
int create_club_board(string club_name) {
   string name;
   name = query_club_board_name(club_name);
   if(is_elected_club(club_name) || this_player()->query_director()) {
      if (BOARD_HAND->is_board(name)) {
         return 0;
      }
      BOARD_HAND->create_board(name,
                               B_PRIV_ACCESS_RESTRICTED_METHOD |
                               B_PRIV_NO_INFORM,
                               "frog");
      BOARD_HAND->set_method_access_call(name,
                                         "check_board_post",
                                         CLUB_HANDLER);
      BOARD_HAND->set_timeout(10);
      BOARD_HAND->set_maximum(60);
      BOARD_HAND->set_minimum(10);
      _boards += ({ name });
      save_main();
      return 1;
   }
   return 0;
}
int remove_club_board(string club_name) {
   string name;
   if (query_club_board(club_name)) {
      name = query_club_board_name(club_name);
      BOARD_HAND->delete_board(name);
      _boards -= ({ name });
      save_main();
      return 1;
   }
}
int check_board_post(int type,
                     string board,
                     string previous,
                     string name,
                     int num) {
   string club;
   club = board[strlen(CLUB_BOARD_PREFIX)..];
   switch (type) {
   case B_ACCESS_READ :
      return is_member_of(club, name);
   case B_ACCESS_WRITE :
      return is_member_of(club, name);
   case B_ACCESS_DELETE :
      return holds_any_position_of(club, name);
   case B_ACCESS_INFORM :
      if (!num) {
         send_broadcast_message(club,
                                name + " posts a message to the board.");
      } else {
         send_broadcast_message(club,
                                name + " posts a message to the board and " +
                                num + " message" +
                                (num > 1?"s":"") + " explode in sympathy.");
      }
      return 1;
   }
}
protected void do_mail_committee(string club_name,
                            string subject,
                            string body) {
   string *committee;
   body += "\n\nYours,\nFindlewoodlwinks\n(Club Handler)\n";
   committee = query_committee(club_name) - ({ CLUB_UNKNOWN_MEMBER });
   if (!sizeof(committee)) {
      if (PLAYER_HANDLER->test_user(query_founder(club_name))) {
         committee = ({ query_founder(club_name) });
      } else {
         return ;
      }
   }
   MAILER->do_mail_message(implode(committee, ","),
                           "Patricians office",
                           subject,
                           "",
                           body);
}
protected void check_elected_information(string name,
                                         string member,
                                         int startup) {
   class election_info data;
   string position_name;
   string person;
   mapping gruff;
   string *nom;
   int cre_club;
   int votes;
   name = normalise_name(name);
   data = query_elected_info(name);
   if (data) {
      if (!mapp(data->options)) {
         data->options = ([ ]);
         set_club_changed(name);
      }
      foreach (position_name, person in data->positions) {
         if (person != CLUB_UNKNOWN_MEMBER &&
             (!is_member_of(name, person) ||
              !PLAYER_HANDLER->test_active(person) ||
              member == person)) {
            set_position_holder(name, position_name, CLUB_UNKNOWN_MEMBER);
         }
      }
      if (query_next_election(name) < time() ||
          _elections[name]) {
         if (!_elections[name]) {
            start_election(name);
         } else {
            switch (_elections[name]->state) {
               case CLUB_NOMINATION_SECOND :
               case CLUB_NOMINATION :
                  if (_elections[name]->time_of_event < time()) {
                     if (sizeof(finish_nomination(name))) {
                        _elections[name]->time_of_event = time() +
                                                          CLUB_ELECTION_TIME;
                        _elections[name]->state = CLUB_NOMINATION_SECOND;
                        save_main();
                     }
                  }
                  break;
               case CLUB_ELECTION :
                  if (_elections[name]->time_of_event < time()) {
                     complete_election(name);
                  }
                  break;
            }
         }
      }
      if (_elections[name] &&
          startup) {
         cre_club = is_creator_club(name);
         foreach (position_name, gruff in _elections[name]->people) {
            foreach (person, votes in gruff) {
               if ((!cre_club &&
                    PLAYER_HANDLER->test_creator(person)) ||
                   !is_member_of(name, person) ||
                   !PLAYER_HANDLER->test_user(person)) {
                  map_delete(gruff, person);
               }
            }
         }
         foreach (position_name,
                  gruff in _elections[name]->nominated) {
            foreach (person, nom in gruff) {
               if ((!cre_club &&
                    PLAYER_HANDLER->test_creator(person)) ||
                   !is_member_of(name, person) ||
                   !PLAYER_HANDLER->test_user(person)) {
                  map_delete(gruff, person);
               }
            }
         }
      }
   }
}

==================================================
FILE: handlers/inherit/club_family.c
==================================================

inherit "/obj/handlers/inherit/club_personal";
#define __CLUBS_H_NO_CLASSES
#include <clubs.h>
#include <player_handler.h>
private nosave mapping _valid_relationships;
private nosave mapping _gender_relationship;
private void add_valid_relationship(string relation,
                                    string relation2,
                                    int flags);
private void add_gender_relationship(string region,
                                     string relationship,
                                     string male,
                                     string female);
string* query_gender_relationships(string relationship);
class family_info {
   mapping relationships;
   string *never_join;
   string tmp;
   int tmp2;
}
#define CLUB_INTERFAMILY_FLAG 1
#define CLUB_JOIN_FAMILY_FLAG 2
class relationship_type_data {
   string opposite;
   int flags;
}
void create() {
   _valid_relationships = ([ ]);
   _gender_relationship = ([ ]);
   ::create();
   add_valid_relationship("spouse",
                          "spouse",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "spouse",
                           "husband",
                           "wife");
   add_valid_relationship("lover",
                          "lover",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "lover",
                           "lover",
                           "lover");
   add_valid_relationship("sibling",
                          "sibling",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "sibling",
                           "brother",
                           "sister");
   add_valid_relationship("sibling-in-law",
                          "sibling-in-law",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "sibling-in-law",
                           "brother-in-law",
                           "sister-in-law");
   add_valid_relationship("parent-in-law",
                          "child-in-law",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "parent-in-law",
                           "father-in-law",
                           "mother-in-law");
   add_gender_relationship("Ankh-Morpork",
                           "child-in-law",
                           "son-in-law",
                           "daughter-in-law");
   add_valid_relationship("child",
                          "parent",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "child",
                          "son",
                          "daughter");
   add_gender_relationship("Ankh-Morpork",
                           "parent",
                           "father",
                           "mother");
   add_valid_relationship("grandparent",
                          "grandchild",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "grandparent",
                           "grandfather",
                           "grandmother");
   add_gender_relationship("Ankh-Morpork",
                           "grandchild",
                           "grandson",
                           "granddaughter");
   add_valid_relationship("godchild",
                          "godparent",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "godchild",
                           "godson",
                           "goddaughter");
   add_gender_relationship("Ankh-Morpork",
                           "godparent",
                           "godfather",
                           "godmother");
   add_valid_relationship("uncle",
                          "niece",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "uncle",
                           "uncle",
                           "aunt");
   add_gender_relationship("Ankh-Morpork",
                           "niece",
                           "nephew",
                           "niece");
   add_valid_relationship("cousin",
                          "cousin",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "cousin",
                           "cousin",
                           "cousin");
   add_valid_relationship("master",
                          "maid",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "maid",
                           "butler",
                           "maid");
   add_gender_relationship("Ankh-Morpork",
                           "master",
                           "master",
                           "mistress");
   add_valid_relationship("apprentice",
                          "tutor",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "apprentice",
                           "apprentice",
                           "apprentice");
   add_gender_relationship("Ankh-Morpork",
                           "tutor",
                           "tutor",
                           "tutor");
   add_valid_relationship("guardian",
                          "ward",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "guardian",
                           "guardian",
                           "guardian");
   add_gender_relationship("Ankh-Morpork",
                           "ward",
                           "ward",
                           "ward");
   add_valid_relationship("ex-spouse",
                          "ex-spouse",
                          CLUB_INTERFAMILY_FLAG | CLUB_JOIN_FAMILY_FLAG);
   add_gender_relationship("Ankh-Morpork",
                           "ex-spouse",
                           "ex-husband",
                           "ex-wife");
}
protected void create_extra_data(string name) {
   class family_info f_info;
   class club_info data;
   data = (class club_info)query_club_info(name);
   if (query_club_type(name) == CLUB_FAMILY) {
      f_info = new(class family_info);
      f_info->relationships = ([ ]);
      f_info->never_join = ({ });
      data->extra_data = f_info;
   } else {
      ::create_extra_data(name);
   }
   set_club_changed(name);
}
int query_club_cost_per_period(string club_name) {
   if (is_club(club_name)) {
      if (is_family(club_name)) {
         return FAMILY_COST_PER_YEAR +
              sizeof(query_members(club_name)) * FAMILY_COST_PER_MEMBER_PER_YEAR;
      } else {
         return ::query_club_cost_per_period(club_name);
      }
   }
   return 0;
}
private class family_info query_family_info(string name) {
   class club_info data;
   if (is_family(name)) {
      data = (class club_info)query_club_info(name);
      return data->extra_data;
   }
}
void add_valid_relationship(string relation1,
                            string relation2,
                            int flags) {
   class relationship_type_data frog;
   frog = new(class relationship_type_data);
   frog->opposite = relation2;
   frog->flags = flags;
   _valid_relationships[relation1] = frog;
   frog = new(class relationship_type_data);
   frog->opposite = relation1;
   frog->flags = flags;
   _valid_relationships[relation2] = frog;
}
string query_opposite_relationship(string relation) {
   if (_valid_relationships[relation]) {
      return _valid_relationships[relation]->opposite;
   }
   return 0;
}
int is_valid_relationship(string str) {
   return _valid_relationships[str] != 0;
}
int is_valid_interfamily_relationship(string str) {
   class relationship_type_data frog;
   frog = _valid_relationships[str];
   if (frog) {
      if (frog->flags & CLUB_INTERFAMILY_FLAG) {
         return 1;
      }
   }
   return 0;
}
int is_valid_join_family_relationship(string str) {
   class relationship_type_data frog;
   frog = _valid_relationships[str];
   if (frog) {
      if (frog->flags & CLUB_JOIN_FAMILY_FLAG) {
         return 1;
      }
   }
   return 0;
}
string *query_all_valid_relationships() {
   return keys(_valid_relationships);
}
private void add_gender_relationship(string region,
                                     string relationship,
                                     string male,
                                     string female) {
   _gender_relationship[male] = relationship;
   _gender_relationship[female] = relationship;
   if (!mapp(_gender_relationship[relationship])) {
      _gender_relationship[relationship] = ([ ]);
   }
   _gender_relationship[relationship][region] = ({ male,
                                                   female });
}
string query_ungendered_relationship(string relationship) {
   if (stringp(_gender_relationship[relationship])) {
      return _gender_relationship[relationship];
   }
   if (mapp(_gender_relationship[relationship])) {
      return relationship;
   }
   return 0;
}
string *query_all_relationships() {
   return keys(_gender_relationship);
}
string query_relationship_gender(string relationship,
                                 int female,
                                 string region) {
   string rel;
   rel = query_ungendered_relationship(relationship);
   if (!rel ||
       female < 0 ||
       female > 1) {
      return 0;
   }
   if (!region || !_gender_relationship[rel][region]) {
      region = "Ankh-Morpork";
   }
   return _gender_relationship[rel][region][female];
}
private void real_add_relationship(string name,
                                   string person,
                                   string dest,
                                   string relationship) {
   class family_info womble;
   class relationship_data plum;
   womble = query_family_info(name);
   if (!womble->relationships[person]) {
      womble->relationships[person] = ({ });
   }
   plum = new(class relationship_data);
   plum->related_to = dest;
   plum->relationship = relationship;
   womble->relationships[person] += ({ plum });
   set_club_changed(name);
}
private void real_remove_relationship(string name,
                                      string person,
                                      string dest,
                                      string relationship) {
   class family_info womble;
   int i;
   womble = query_family_info(name);
   for (i = 0; i < sizeof(womble->relationships[person]); i++) {
      if (womble->relationships[person][i]->related_to == dest &&
          womble->relationships[person][i]->relationship == relationship) {
         womble->relationships[person] = womble->relationships[person][0..i-1] +
                                         womble->relationships[person][i+1..];
         set_club_changed(name);
      }
   }
}
int add_relationship(string name,
                     string person,
                     string dest_name,
                     string dest,
                     string relationship) {
   if (is_family(name) &&
       is_family(dest_name) &&
       is_member_of(name, person) &&
       is_member_of(dest_name, dest) &&
       is_valid_relationship(relationship)) {
      real_add_relationship(name,
                            person,
                            dest,
                            relationship);
      real_add_relationship(dest_name,
                            dest,
                            person,
                            query_opposite_relationship(relationship));
      save_club(name);
      return 1;
   }
   return 0;
}
class relationship_data *query_relationships(string name,
                                             string person) {
   class family_info womble;
   if (is_family(name)) {
      womble = query_family_info(name);
      if (womble->relationships[person]) {
         return womble->relationships[person];
      }
   }
   return ({ });
}
int move_family_member(string curr_family,
                       string person,
                       string dest_family) {
  class relationship_data *stuff;
  class family_info womble;
  if (is_family(curr_family) &&
      is_family(dest_family) &&
      is_member_of(curr_family, person)) {
    stuff = query_relationships(curr_family,
                                person);
    womble = query_family_info(curr_family);
    map_delete(womble->relationships, person);
    set_club_changed(curr_family);
    remove_member(curr_family, person);
    add_member(dest_family, person);
    womble = query_family_info(dest_family);
    womble->relationships[person] = stuff;
    set_club_changed(dest_family);
    return 1;
  }
  return 0;
}
string *query_relationships_to(string name,
                               string person,
                               string related) {
   class relationship_data frog;
   string *relationships;
   relationships = ({ });
   foreach (frog in query_relationships(name, person)) {
      if (frog->related_to == related) {
         relationships += ({ frog->relationship });
      }
   }
   return relationships;
}
int is_relationship(string name,
                    string person,
                    string related,
                    string relationship) {
   class relationship_data frog;
   foreach (frog in query_relationships(name, person)) {
      if (frog->related_to == related &&
          frog->relationship == relationship) {
         return 1;
      }
   }
   return 0;
}
int remove_relationship(string name,
            string person,
                        string dest_name,
      string dest,
      string relationship) {
   if (is_relationship(name, person, dest, relationship)) {
      real_remove_relationship(name,
                   person,
             dest,
             relationship);
      if (dest_name) {
         real_remove_relationship(dest_name,
                      dest,
                person,
                      query_opposite_relationship(relationship));
      }
      return 1;
   }
   return 0;
}
protected void check_family_information(string name,
                                        string member,
                                        int startup) {
   class family_info fam_data;
   string family;
   fam_data = query_family_info(name);
   if (fam_data) {
      if (member &&
         fam_data->relationships[member]) {
         family = PLAYER_HANDLER->test_family(member);
         if (!family ||
              normalise_name(family) != name) {
            if (find_player(member)) {
               find_player(member)->set_family_name(family);
            } else {
               log_file("CLUB", ctime(time()) +
                                ": removed " +
                                member + " from " + family +
                                " family deficent.\n");
               remove_member(name, member);
            }
         }
         if (!undefinedp(fam_data->relationships)) {
            map_delete(fam_data->relationships, member);
            set_club_changed(name);
         }
      }
   }
}

==================================================
FILE: handlers/inherit/club_inherit.c
==================================================

inherit "/obj/handlers/inherit/club_discuss";
#define __CLUBS_H_NO_CLASSES
#define __MAIL_H_NO_CLASSES
#include <mail.h>
#include <clubs.h>
#include <player_handler.h>
#include <broadcaster.h>
#include <player.h>
#include <top_ten_tables.h>
#include <library.h>
#include <player_handler.h>
private nosave int _callout_id;
private nosave int _test_callout_id;
private string _current_test_club;
private int _last_test_time;
protected void check_extra_information(string name, string person, int startup);
void check_clubs(int startup);
class top_ten_tables {
   int num;
   int qp;
   int age;
   int start_time;
   int gender;
   int single_gender;
   int rels;
   int no_pks;
   mapping guild;
}
protected void setup_call_check_clubs(int time, int startup) {
   remove_call_out(_callout_id);
   _callout_id = call_out("check_clubs", time, startup);
}
private void send_low_balance_mail(string club) {
   string *to;
   string bit;
   switch (query_club_type(club)) {
      case CLUB_FAMILY :
         to = query_members(club);
         bit = "family";
         break;
      case CLUB_PERSONAL :
         to = ({ query_founder(club) });
         bit = "club";
         to -= ({ "unknown" });
         if (!sizeof(to)) {
            to = query_members(club);
         }
         break;
      case CLUB_ELECTED :
         to = query_committee(club) - ({ CLUB_UNKNOWN_MEMBER });
         if (!sizeof(to)) {
            to = ({ query_members(club) });
         }
         bit = "club";
         break;
   }
   to = filter(to, (: PLAYER_HANDLER->test_user($1) :));
   if (sizeof(to)) {
      MAILER->do_mail_message(implode(to, ","),
                           "Patricians office",
                           "The " + bit + " has fees due.",
                           "",
                           sprintf("%-=80s\n", "Morning,\n\n"
                           "This is a reminder from the Patrician's Office "
                           "the " + bit + " '" + query_club_name(club) +
                           "' is currently in remission and "
                           "its balance will need to be updated before "
                           "the next "
                           "pay period or your " + bit + " will be "
                           "disbanded.\n\nYours happily,\nThe Patrician."));
   }
}
private void send_disband_mail(string club) {
   string *to;
   string bit;
   switch (query_club_type(club)) {
      case CLUB_FAMILY :
         to = query_members(club);
         bit = "family";
         break;
      case CLUB_PERSONAL :
         to = ({ query_founder(club) });
         bit = "club";
         break;
      case CLUB_ELECTED :
         to = query_committee(club) - ({ CLUB_UNKNOWN_MEMBER });
         if (!sizeof(to)) {
            to = ({ query_members(club) });
         }
         bit = "club";
         break;
   }
   MAILER->do_mail_message(implode(to, ","),
                           "Patricians office",
                           "The " + bit + " has been disbanded.",
                           "",
                           sprintf("%-=80s\n", "Morning,\n\n"
                           "This is a message from the patricians "
                           "office to you that your " + bit +
                           " '" + query_club_name(club) +
                           "' has been disbanded for having its fees "
                           "in remission."
                           "\n\nYours happily,\nThe Patrician."));
}
protected void check_extra_information(string name,
                                       string member,
                                       int startup) {
   if (is_elected_club(name)) {
      check_elected_information(name, member, startup);
   } else if (is_family(name)) {
      check_family_information(name, member, startup);
   }
}
protected void check_club_members(string club_name,
                                string* members,
                                class top_ten_tables top_info) {
   int i;
   int tmp;
   string member;
   string str;
   string flip;
   class relationship_data *rels;
   class relationship_data frog;
   for (i = 0; i < 1 && i < sizeof(members); i++) {
      member = members[i];
      if (!PLAYER_HANDLER->test_user(member)) {
         log_file("CLUB", ctime(time()) + ": removed " + member +
                          " from " + club_name + " for not existing.\n");
         remove_member(club_name, member);
      } else if (!PLAYER_HANDLER->test_creator(member) &&
                 !PLAYER_HANDLER->test_property(member, "no score")) {
         top_info->num++;
         top_info->qp += LIBRARY->query_quest_points(member);
         tmp = -PLAYER_HANDLER->test_age(member) / (60 * 60);
         top_info->rels += sizeof(CLUB_HANDLER->query_relationships(club_name, member));
         top_info->age += tmp;
         top_info->start_time += PLAYER_HANDLER->test_start_time(member) / (60 * 60);
         str = PLAYER_HANDLER->test_guild(member);
         if (str &&
             str != "") {
            if (top_info->guild[str]) {
               top_info->guild[str]++;
            } else {
               if (file_size(str + ".c") > 0) {
                  flip = str->query_real_guild_object();
                  if (flip) {
                     str = flip;
                  }
                  top_info->guild[str]++;
               }
            }
         }
         if (PLAYER_HANDLER->test_player_killer(member)) {
            top_info->no_pks++;
         }
         if (!top_info->gender) {
            top_info->gender = PLAYER_HANDLER->test_gender(member);
         }
         if (top_info->single_gender != -1 &&
             PLAYER_HANDLER->test_gender(member) != top_info->gender) {
            top_info->single_gender = -1;
         }
      }
      if (is_family(club_name)) {
         check_family_information(club_name, member, 0);
         rels = CLUB_HANDLER->query_relationships(club_name, member);
         foreach (frog in rels) {
            if (!PLAYER_HANDLER->test_family(frog->related_to)) {
               log_file("CLUB", ctime(time()) + ": removed relationship " +
                          member +
                          " <-> " + frog->related_to + " (" +
                          frog->relationship + ") for loosing their "
                          "family.\n");
            }
         }
      }
   }
   members = members[1..];
   if (!sizeof(members)) {
      if (!sizeof(query_members(club_name))) {
         disband_club(club_name);
      } else if (top_info->num > 3) {
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_LARGEST_FAMILY,
                                         top_info->num);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_OLDEST_FAMILY,
                                         top_info->age / top_info->num);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_MOST_QUEST_POINTS,
                                         top_info->qp / top_info->num);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_MOST_GUILD,
                                         top_info->guild);
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_MOST_PKS,
                                         top_info->no_pks);
         if (top_info->single_gender != -1) {
            TOP_TEN_HANDLER->inform_of_club(club_name,
                                            is_family(club_name),
                                            TOP_TEN_SINGLE_GENDER,
                                            top_info->num);
         } else {
            TOP_TEN_HANDLER->inform_of_club(club_name,
                                            is_family(club_name),
                                            TOP_TEN_SINGLE_GENDER,
                                            0);
         }
         TOP_TEN_HANDLER->inform_of_club(club_name,
                                         is_family(club_name),
                                         TOP_TEN_OLDEST_LOGONS,
                                         top_info->start_time / top_info->num);
      }
      top_info = new(class top_ten_tables);
      top_info->guild = ([ ]);
      i = member_array(_current_test_club, query_clubs());
      if (i < sizeof(query_clubs())) {
         _current_test_club = query_clubs()[i+1];
         _test_callout_id = call_out("check_club_members", 60, _current_test_club, query_members(_current_test_club), top_info);
      } else {
         _current_test_club = 0;
         _test_callout_id = 0;
      }
      save_main();
   } else {
      _test_callout_id = call_out("check_club_members", 60, club_name, members, top_info);
   }
}
private nosave int _specific_callout_id = 0;
private nosave string *_clubs_to_check = ({ });
protected void check_specific_club(string club_name, int startup) {
    class club_info bing;
    bing = (class club_info)query_club_info(club_name);
    if (bing->last_touched < time() - CLUB_TIMEOUT) {
        disband_club(club_name);
        return;
    }
    if (!pointerp(query_members(club_name))) {
        disband_club(club_name);
        return;
    }
    if (query_time_fees_due(club_name) < time()) {
        if (query_balance(club_name, CLUB_DEFAULT_ACCOUNT_NAME) < 0) {
            send_disband_mail(club_name);
            disband_club(club_name);
            return;
        }
        if (remove_money(club_name, query_club_cost_per_period(club_name),
            CLUB_TRANSACTION_UPKEEP, "Club Dues",
            CLUB_DEFAULT_ACCOUNT_NAME, 0)) {
            int tmp;
            bing = (class club_info)query_club_info(club_name);
            tmp = bing->last_paid;
            bing->last_paid = query_time_fees_due(club_name);
            set_club_changed(club_name);
            if (query_balance(club_name, CLUB_DEFAULT_ACCOUNT_NAME) < 0) {
               reset_eval_cost();
               send_low_balance_mail(club_name);
            }
        }
    }
    call_out( (: check_extra_information :),  1,  club_name, 0,  startup);
}
protected void check_specific_clubs( int startup, int pos ) {
    string club_name;
    if ( pos >= sizeof( _clubs_to_check ) ) {
        _clubs_to_check = ({ });
        _specific_callout_id = 0;
        pos = 0;
        return;
    }
    club_name = _clubs_to_check[ pos ];
    tell_creator( "taffyd", "Checking club %s (%d)\n", club_name, pos );
    check_specific_club(club_name, startup);
    _specific_callout_id = call_out( (: check_specific_clubs :), 10, startup, ++pos );
}
void check_clubs(int startup) {
   class top_ten_tables blue;
   setup_call_check_clubs(24 * 60 * 60, 0);
   if ( !_specific_callout_id ) {
       _clubs_to_check = query_clubs();
        _specific_callout_id = call_out( (: check_specific_clubs :), 0,
            startup, 0 );
   }
   remove_call_out(_test_callout_id);
   if (!_current_test_club &&
       _last_test_time + 7 * 24 * 60 * 60 < time()) {
      if (sizeof(query_clubs()) > 0) {
         _current_test_club = query_clubs()[0];
      }
      _last_test_time = 0;
      save_main();
   }
   if (_current_test_club) {
      blue = new(class top_ten_tables);
      blue->guild = ([ ]);
      _test_callout_id = call_out("check_club_members",
                                 60,
                                 _current_test_club,
                                 query_members(_current_test_club),
                                 blue);
   }
}
#ifdef OLD_CHECK_CODE
protected void check_specific_club(string club_name, int extra_space,
                                   int startup) {
}
#endif

==================================================
FILE: handlers/inherit/club_personal.c
==================================================

inherit "/obj/handlers/inherit/club_basic";
#define __CLUBS_H_NO_CLASSES
#include <clubs.h>
class personal_info {
}
protected void create_extra_data(string name) {
   class personal_info p_info;
   class club_info data;
   data = (class club_info)query_club_info(name);
   if (query_club_type(name) == CLUB_PERSONAL) {
         p_info = new(class personal_info);
      data->extra_data = p_info;
      set_club_changed(name);
   } else {
      ::create_extra_data(name);
   }
}
private class personal_info query_personal_info(string name) {
   class club_info data;
   if (is_personal_club(name)) {
      data = (class club_info)query_club_info(name);
      return data->extra_data;
   }
   return 0;
}

==================================================
FILE: handlers/inherit/craft_skills.c
==================================================

#include <skills.h>
private string *_craft_skill_tree;
void add_craft_skill(string name);
void create() {
   _craft_skill_tree = ({ });
   add_craft_skill("crafts.smithing.gold");
   add_craft_skill("crafts.smithing.silver");
   add_craft_skill("crafts.smithing.black.tool");
   add_craft_skill("crafts.smithing.black.weapon");
   add_craft_skill("crafts.smithing.black.armour");
   add_craft_skill("crafts.smithing.gem.cutting");
   add_craft_skill("crafts.smithing.gem.polishing");
   add_craft_skill("crafts.smithing.gem.setting");
   add_craft_skill("crafts.mining.gem");
   add_craft_skill("crafts.mining.ore.panning");
   add_craft_skill("crafts.mining.mineral");
   add_craft_skill("crafts.hunting.tracking");
   add_craft_skill("crafts.hunting.fishing");
   add_craft_skill("crafts.hunting.trapping");
   add_craft_skill("crafts.carpentry.furniture");
   add_craft_skill("crafts.carpentry.coopering");
   add_craft_skill("crafts.carpentry.turning");
   add_craft_skill("crafts.carpentry.whittling");
   add_craft_skill("crafts.pottery.forming.throwing");
   add_craft_skill("crafts.pottery.forming.shaping");
   add_craft_skill("crafts.pottery.glazing");
   add_craft_skill("crafts.pottery.staining");
   add_craft_skill("crafts.pottery.firing");
   add_craft_skill("crafts.materials.leatherwork");
   add_craft_skill("crafts.materials.weaving");
   add_craft_skill("crafts.materials.spinning");
   add_craft_skill("crafts.materials.needlework");
   add_craft_skill("crafts.materials.dyeing");
   add_craft_skill("crafts.husbandry.plant.edible");
   add_craft_skill("crafts.husbandry.plant.herbal");
   add_craft_skill("crafts.husbandry.plant.milling");
   add_craft_skill("crafts.husbandry.plant.tree");
   add_craft_skill("crafts.husbandry.animal.grooming");
   add_craft_skill("crafts.husbandry.animal.breeding");
   add_craft_skill("crafts.culinary.cooking");
   add_craft_skill("crafts.culinary.baking");
   add_craft_skill("crafts.culinary.butchering");
   add_craft_skill("crafts.culinary.preserving");
   add_craft_skill("crafts.culinary.brewing");
   add_craft_skill("crafts.culinary.distilling");
   add_craft_skill("crafts.arts.design");
   add_craft_skill("crafts.arts.calligraphy");
   add_craft_skill("crafts.arts.drawing");
   add_craft_skill("crafts.arts.painting");
   add_craft_skill("crafts.arts.printing");
   add_craft_skill("crafts.arts.sculpture");
   add_craft_skill("crafts.points");
}
private mixed *add_craft_skill_int(string *bits,
                                   mixed *arr) {
   int pos;
   pos = member_array(bits[0], arr);
   if (pos == -1) {
      pos = sizeof(arr);
      arr += ({ bits[0], 0, 0, ({ }) });
   }
   if (sizeof(bits) > 1) {
      arr[pos + SKILL_BIT] = add_craft_skill_int(bits[1..],
                                                 arr[pos + SKILL_BIT]);
   }
   return arr;
}
private void add_craft_skill(string name) {
   string *bits;
   bits = explode(name, ".");
   _craft_skill_tree = add_craft_skill_int(bits, _craft_skill_tree);
}
mixed *query_crafts_skill_tree() {
   return _craft_skill_tree;
}

==================================================
FILE: handlers/inherit/distance_handler.c
==================================================

#define BAD_ROOM -1
#define TRAVEL_NOT_ALLOWED -2
#define BAD_DOMAIN -3
int* query_co_ord(string room);
private int difference(int bing, int womble){
   if (womble > bing) {
      return womble - bing;
   }
   return bing - womble;
}
private int filename_check(string one, string two){
   string dom_one;
   string dom_two;
   string alpha;
   log_file("/log/PORTAL", "Unable to get co-ords for %O %O, doing filename based check.\n", one, two);
   dom_one = explode(one, "/")[1];
   dom_two = explode(two, "/")[1];
   alpha = dom_one<dom_two?dom_one+":"+dom_two:dom_two+":"+dom_one;
   switch(alpha){
      case "am:am":
         return 3000;
      case "am:cwc":
         return TRAVEL_NOT_ALLOWED;
      case "am:ram":
         return 3000000;
      case "am:klatch":
         return 1000000;
      case "am:sur":
         return 500000;
      case "am:forn":
         return TRAVEL_NOT_ALLOWED;
      case "am:guilds":
         return 1000;
      case "cwc:ram":
      case "cwc:klatch":
      case "cwc:forn":
      case "cwc:guilds":
      case "cwc:sur":
         return TRAVEL_NOT_ALLOWED;
      case "cwc:cwc":
         return 500000;
      case "forn:forn":
         return TRAVEL_NOT_ALLOWED;
      case "forn:ram":
         return TRAVEL_NOT_ALLOWED;
      case "forn:guilds":
         return TRAVEL_NOT_ALLOWED;
      case "forn:klatch":
         return TRAVEL_NOT_ALLOWED;
      case "forn:sur":
         return TRAVEL_NOT_ALLOWED;
      case "guilds:guilds":
         return 1000;
      case "guilds:klatch":
         return 500000;
      case "guilds:sur":
         return 500000;
      case "guilds:ram":
         return 1500000;
      case "klatch:klatch":
         return 1000;
      case "klatch:sur":
         return 3300000;
      case "klatch:ram":
         return 4000000;
      case "ram:ram":
         return 500000;
      case "ram:sur":
         return 900000;
      case "sur:sur":
         return 500000;
   }
   return BAD_DOMAIN;
}
int query_distance_from_coords(int* co_ord_one, int* co_ord_two){
   float x;
   float y;
   float z;
   float distanceplane;
   float distance;
   x = difference(co_ord_one[0], co_ord_two[0]);
   y = difference(co_ord_one[1], co_ord_two[1]);
   z = difference(co_ord_one[2], co_ord_two[2]);
   distanceplane = sqrt(pow(x, 2) + pow(y, 2));
   distance = sqrt(pow(distanceplane, 2) + pow(z, 2));
   return to_int(distance);
}
int query_distance_from_rooms(mixed one, mixed two){
   mixed co_ord_one;
   mixed co_ord_two;
   if (objectp(one)) {
      one = file_name(one);
   }
   if (objectp(two)) {
      two = file_name(two);
   }
   if (one->query_co_ord()) {
      co_ord_one = one->query_co_ord();
   } else {
      co_ord_one = query_co_ord(one);
   }
   if (two->query_co_ord()) {
      co_ord_two = two->query_co_ord();
   } else {
      co_ord_two = query_co_ord(two);
   }
   if(co_ord_one == 0 || co_ord_two == 0) {
      return filename_check(one, two);
   }
   return query_distance_from_coords(co_ord_one, co_ord_two);
}

==================================================
FILE: handlers/inherit/error_handler.c
==================================================

#include <db.h>
#include <error_handler.h>
#define SAVE_FILE "/save/handlers/error_handler"
#define ERROR_SUMMARY_FIELDS "id, entrydate, filename, type, category, name, reporter, status, directory"
#define ERROR_DETAILS_FIELDS ERROR_SUMMARY_FIELDS \
                      ", report, runtime"
#define ERROR_REPLY_TIMEOUT (60 * 60 * 24 * 7 * 4)
void finish_update(int type, mixed data, function finished, string query);
private string _db;
private string _user;
private string _password;
void create() {
   unguarded( (: restore_object(SAVE_FILE) :) );
   DB_HANDLER->make_sql_request(_db, _user, _password,
                 "delete from error_replies where senddate < " +
                 (time() - ERROR_REPLY_TIMEOUT), (: 1 :));
}
protected void setup_error_handler(string user, string db, string password) {
   _user = user;
   _db = db;
   _password = password;
   save_object(SAVE_FILE);
}
protected string build_sql_query(string select_rows, class error_query query) {
   string* restrict;
   string name;
   string tmp;
   restrict = ({ });
   if (query->id != 0) {
      restrict += ({ "id = " + query->id });
   }
   if (query->dir) {
      if (query->dir[<1] == '/') {
         query->dir = query->dir[0..<2];
      }
      if (query->recursive) {
         restrict += ({ "directory like '" + query->dir + "%'" });
      } else {
         restrict += ({ "directory = '" + query->dir + "'" });
      }
   }
   if (query->assigned_to) {
      restrict += ({ "AssignedTo = '" + query->assigned_to + "'" });
   }
   if (query->reporter) {
      restrict += ({ "Reporter = '" + query->reporter + "'" });
   }
   if (query->file_name) {
      restrict += ({ "FileName = '" + query->file_name + "'" });
   }
   if (sizeof(query->type)) {
      tmp = "Type in (";
      foreach (name in query->type) {
         tmp += "'" + name + "',";
      }
      tmp = tmp[0..<2] + ")";
      restrict += ({ tmp });
   }
   if (sizeof(query->status)) {
      tmp = "Status in (";
      foreach (name in query->status) {
         tmp += "'" + name + "',";
      }
      tmp = tmp[0..<2] + ")";
      restrict += ({ tmp });
   }
   if (sizeof(query->category)) {
      tmp = "Category in (";
      foreach (name in query->category) {
         tmp += "'" + name + "',";
      }
      tmp = tmp[0..<2] + ")";
      restrict += ({ tmp });
   }
   if (sizeof(restrict)) {
      tmp = "select " + lower_case(select_rows) + " from errors where " +
             implode(restrict, " and ");
      switch (query->order_by) {
      case ERROR_ORDER_BY_FILENAME :
         tmp += " order by filename, entrydate";
         break;
      case ERROR_ORDER_BY_DATE :
         tmp += " order by entrydate";
         break;
      case ERROR_ORDER_BY_REPORTER :
         tmp += " order by reporter, entrydate";
         break;
      case ERROR_ORDER_BY_DIRECTORY :
      default :
         tmp += " order by directory, filename, entrydate";
         break;
      }
      return tmp + " limit 150";
   }
   return 0;
}
string build_sql_update(int id, string field, mixed value) {
   string ret;
   ret = "update errors set " + field + " = ";
   if (stringp(value)) {
      ret += "'" + value + "'";
   } else {
      ret += "" + value;
   }
   ret += " where id = " + id;
   return ret;
}
class error_forward create_error_forward(mapping map) {
   class error_forward newy;
   newy = new(class error_forward);
   newy->date = map["forwarddate"];
   newy->forwarder = map["forwarder"];
   newy->old_directory = map["olddirectory"];
   return newy;
}
class error_comment create_error_comment(mapping map) {
   class error_comment newy;
   newy = new(class error_comment);
   newy->date = map["commentdate"];
   newy->commenter = map["commenter"];
   newy->comment = map["comment"];
   return newy;
}
class error_summary create_error_summary(mapping map) {
   class error_summary newy;
   newy = new(class error_summary);
   newy->id = map["id"];
   newy->entry_date = map["entrydate"];
   newy->filename = map["filename"];
   newy->category = map["category"];
   newy->assigned_to = map["assignedto"];
   newy->reporter = map["reporter"];
   newy->status = map["status"];
   newy->type = map["type"];
   newy->directory = map["directory"];
   return newy;
}
class error_details create_error_details(mapping map) {
   class error_details newy;
   newy = new(class error_details);
   newy->summary = create_error_summary(map);
   newy->fix_date = map["fixdate"];
   newy->fixer = map["fixer"];
   newy->report = map["report"];
   newy->runtime = map["runtime"];
   return newy;
}
class error_complete create_error_complete(class error_details details) {
   class error_complete newy;
   newy = new(class error_complete);
   newy->details = details;
   newy->comments = ({ });
   newy->forwards = ({ });
   newy->replies = ({ });
   return newy;
}
class error_replies create_error_replies(mapping map) {
   class error_replies reply;
   reply = new(class error_replies);
   reply->id = map["id"];
   reply->bug_id = map["bug_id"];
   reply->sender = map["sender"];
   reply->status = map["status"];
   reply->recipient = map["recipient"];
   reply->senddate = map["senddate"];
   reply->subject = map["subject"];
   reply->message = map["message"];
   return reply;
}
void finish_summary(int type, mixed data, function finished, string query) {
   class error_summary* errors;
   mapping map;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data, query);
   } else {
      errors = ({ });
      foreach (map in data) {
         errors += ({ create_error_summary(map) });
      }
      evaluate(finished, type, errors, query);
   }
}
void finish_forwards(int type, mixed data, function finished,
                     class error_complete* errors, string query) {
   mapping map;
   class error_complete detail;
   if (type != DB_SUCCESS) {
      evaluate(finished, DB_SUCCESS, errors, query);
   } else {
      foreach (map in data) {
         foreach (detail in errors) {
            if (detail->details->summary->id == map["id"]) {
                 detail->forwards += ({ create_error_forward(map) });
            }
         }
      }
      evaluate(finished, type, errors, query);
   }
}
void finish_details_error_replies(int type, mixed data, function finished,
                     class error_complete* errors, string ids, string query) {
   mapping map;
   class error_complete detail;
   if (type != DB_SUCCESS) {
      evaluate(finished, DB_SUCCESS, errors, query);
   } else {
      foreach (map in data) {
         foreach (detail in errors) {
            if (detail->details->summary->id == map["bug_id"]) {
               detail->replies += ({ create_error_replies(map) });
            }
         }
      }
      DB_HANDLER->make_sql_request(_db, _user, _password,
                     "select id,forwarddate,forwarder,olddirectory from "
                     "forwards where id in " + ids +
                     " order by forwarddate",
                     (: finish_forwards($1, $2, $(finished), $(errors), $(query)) :));
   }
}
void finish_comments(int type, mixed data, function finished,
                     class error_complete* errors, string ids, string query) {
   mapping map;
   class error_complete detail;
   if (type != DB_SUCCESS) {
      evaluate(finished, DB_SUCCESS, errors, query);
   } else {
      foreach (map in data) {
         foreach (detail in errors) {
            if (detail->details->summary->id == map["id"]) {
                 detail->comments += ({ create_error_comment(map) });
            }
         }
      }
      DB_HANDLER->make_sql_request(_db, _user, _password,
                     "select * from "
                     "error_replies where bug_id in " + ids +
                     " order by senddate",
                     (: finish_details_error_replies($1, $2, $(finished), $(errors), $(ids), $(query)) :));
   }
}
void finish_details(int type, mixed data, function finished, string query) {
   class error_complete* errors;
   mapping map;
   string str;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data, query);
   } else {
      errors = ({ });
      str = "(";
      foreach (map in data) {
         errors += ({ create_error_complete(create_error_details(map)) });
         str += map["id"] + ",";
      }
      str = str[0..<2] + ")";
      DB_HANDLER->make_sql_request(_db, _user, _password,
                     "select commentdate,commenter,comment,id "
                     "from comments where id in " + str +
                     " order by commentdate desc",
                     (: finish_comments($1, $2, $(finished), $(errors), $(str), $(query)) :));
   }
}
void finish_forward_query(int type, mixed data, function finished,
                          string user, string newdir) {
   class error_complete error;
   mapping map;
   string str;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data);
   } else {
      map = data[0];
      error = create_error_complete(create_error_details(map));
      if (error->details->summary->directory != newdir) {
         str = "insert into forwards (id,forwarddate,forwarder,olddirectory) " +
               "values (" + error->details->summary->id + ", " + time() + ", '" +
               db_escape(user) + "', '" +
               db_escape(error->details->summary->directory) +
               "')";
         DB_HANDLER->make_sql_request(_db, _user, _password,
                     str, (: 1 :));
         str = build_sql_update(error->details->summary->id, "directory", newdir);
         DB_HANDLER->make_sql_request(_db, _user, _password, str,
                                 (: finish_update($1, $2, $(finished), $(str)) :));
      } else {
         evaluate(finished, type, data);
      }
   }
}
void finish_status_query(int type, mixed data, function finished,
                         string status,
                         int nomail, string user, string subject,
                         string message) {
   class error_complete error;
   mapping map;
   string str;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data);
   } else {
      map = data[0];
      error = create_error_complete(create_error_details(map));
      if (!nomail) {
         str = "insert into error_replies (bug_id,status,sender,recipient,senddate,message,subject) "
               "values (" +
               error->details->summary->id + ", 'NEW', '" + user + "', '" +
               error->details->summary->reporter + "', " +
               time() + ", '" +
               "Change status from " + error->details->summary->status +
               " to " + status +
               "\n" + db_escape(message) + "', '" + db_escape(subject) + "')";
         DB_HANDLER->make_sql_request(_db, _user, _password, str,
                 (: 1 :) );
      }
      str = build_sql_update(error->details->summary->id, "status", status);
      if (!str) {
         return 0;
      }
      DB_HANDLER->make_sql_request(_db, _user, _password, str,
                            (: finish_update($1, $2, $(finished), $(str)) :));
   }
}
void finish_update(int type, mixed data, function finished, string query) {
   evaluate(finished, type, data, query);
}
void finish_error_replies(int type, mixed data, function finished, string query) {
   class error_replies* replies;
   mapping map;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data);
   } else {
      replies = ({ });
      foreach (map in data) {
         replies += ({ create_error_replies(map) });
      }
      evaluate(finished, type, replies);
   }
}
int do_query_bug_summary(class error_query query, function finished) {
   string str;
   str = build_sql_query(ERROR_SUMMARY_FIELDS,
                         query);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                                   (: finish_summary($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_query_bug_details(int bug_id, function finished) {
   string str;
   class error_query query;
   query = new(class error_query);
   query->id = bug_id;
   str = build_sql_query(ERROR_DETAILS_FIELDS, query);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_details($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_query_open_bugs_in_dir(string dir, function finished) {
   class error_query query;
   query = new(class error_query);
   query->dir = dir;
   query->status = ({ "OPEN", "FIXING", "CONSIDERING" });
   return do_query_bug_summary(query, finished);
}
int do_query_open_bugs_for_fname(string fname, function finished) {
   class error_query query;
   query = new(class error_query);
   query->file_name = fname;
   query->status = ({ "OPEN", "FIXING", "CONSIDERING" });
   return do_query_bug_summary(query, finished);
}
int do_query_open_bugs_by_reporter(string reporter, function finished) {
   class error_query query;
   query = new(class error_query);
   query->reporter = reporter;
   query->status = ({ "OPEN", "FIXING", "CONSIDERING" });
   return do_query_bug_summary(query, finished);
}
int do_change_type(int id, string type, function finished) {
   string str;
   str = build_sql_update(id, "type", type);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_change_category(int id, string category, function finished) {
   string str;
   str = build_sql_update(id, "category", category);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_assign_bug_to(int id, string assigned_to, function finished) {
   string str;
   str = build_sql_update(id, "assignedto", assigned_to);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_change_status(int id, string status, int nomail, string subject,
                     string user, string message, function finished) {
   string str;
   class error_query query;
   query = new(class error_query, id : id);
   str = build_sql_query(ERROR_DETAILS_FIELDS, query);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
             (: finish_status_query($1, $2, $(finished), $(status),
                                    $(nomail), $(user), $(subject),
                                     $(message)) :));
   return 1;
}
int do_forward(int id, string user, string dir, function finished) {
   string str;
   class error_query query;
   if (!strlen(dir)) {
      return 0;
   }
   if (dir[0] != '/') {
      dir = "/" + dir;
   }
   if (dir[<1] == '/') {
      dir = dir[0..<2];
   }
   if (file_size(dir) != -2 || dir == "/") {
      return 0;
   }
   query = new(class error_query, id : id);
   str = build_sql_query(ERROR_DETAILS_FIELDS, query);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
             (: finish_forward_query($1, $2, $(finished), $(user), $(dir)) :));
   return 1;
}
int do_comment(int id, string user, string comment, function finished) {
   string str;
   str = "insert into comments (id,commentdate,commenter,comment) values (" +
         id + ", " + time() + ", '" + user + "', '" + db_escape(comment) +
         "')";
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                             (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_error_replies(string recipient, int only_new, function finished) {
   string str;
   str = "select * from error_replies where recipient = '" + recipient +
         "'";
   if (only_new) {
      str += " and status = 'NEW'";
   } else {
      str += " and status != 'DELETED'";
   }
   str += " order by senddate";
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                      (: finish_error_replies($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_status_error_reply(int id, string status, function finished) {
   string str;
   str = "update error_replies set status = '" + status + "' where id = " +
         id;
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                      (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_add_error_reply(int bug_id, string from, string to, string subject, string message) {
   string str;
   str = "insert into error_replies (bug_id,status,sender,recipient,senddate,message,subject) "
         "values (" + bug_id + ", 'NEW', '" + from + "', '" + to + "', " +
         time() + ", '" +
         db_escape(message) + "', '" + db_escape(subject) + "')";
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
           (: 1 :) );
   return 1;
}

==================================================
FILE: handlers/inherit/nomic_rules.c
==================================================

#include <nomic_system.h>
private mapping _rules;
void save_me();
int query_can_change_rule(string area, class nomic_rule rule);
class nomic_rule find_nomic_rule(string area, string creator, string text);
void create() {
   _rules = ([ ]);
}
int add_nomic_rule(string area, int type, string creator, string text) {
   int bing;
   class nomic_rule nomic_rule;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   if (type < 0 || type >= sizeof(_rules[area]->new_type_num)) {
      return NOMIC_ERROR;
   }
   if (find_nomic_rule(area, creator, text)) {
      return NOMIC_ERROR;
   }
   nomic_rule = new(class nomic_rule);
   bing = _rules[area]->new_type_num[type];
   nomic_rule->id = bing;
   nomic_rule->creator = creator;
   nomic_rule->type = type;
   nomic_rule->text = text;
   nomic_rule->date_created = time();
   nomic_rule->amendments = ({ });
   _rules[area]->rules += ({ nomic_rule });
   _rules[area]->new_type_num[type] = bing + 1;
   save_me();
   return bing;
}
protected int add_nomic_rule_class(string area,
                                   class nomic_rule new_rule,
                                   int type) {
   int bing;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   if (type < 0 || type >= sizeof(_rules[area]->new_type_num)) {
      return NOMIC_ERROR;
   }
   if (find_nomic_rule(area, new_rule->creator, new_rule->text)) {
      return NOMIC_ERROR;
   }
   bing = _rules[area]->new_type_num[type];
   new_rule->id = bing;
   new_rule->type = type;
   _rules[area]->rules += ({ new_rule });
   _rules[area]->new_type_num[type] = bing + 1;
   save_me();
   return bing;
}
protected int move_nomic_rule(string area, class nomic_rule rule,
                              int type) {
   int bing;
   int i;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   if (type < 0 || type >= sizeof(_rules[area]->new_type_num)) {
      return NOMIC_ERROR;
   }
   bing = _rules[area]->new_type_num[type];
   for (i = 0; i < sizeof(_rules[area]->rules); i++) {
      if (_rules[area]->rules[i]->id == rule->id) {
         if (!query_can_change_rule(area, _rules[area]->rules[i])) {
            return NOMIC_ERROR;
         }
         _rules[area]->rules[i]->id = bing;
         ((class nomic_rule)_rules[area]->rules[i])->type = type;
         _rules[area]->new_type_num[type] = bing + 1;
         save_me();
         return bing;
      }
   }
   return NOMIC_ERROR;
}
int change_nomic_rule(string area, class nomic_rule rule) {
   int i;
   if (!_rules[area]) {
      return 0;
   }
   for (i = 0; i < sizeof(_rules[area]->rules); i++) {
      if (_rules[area]->rules[i]->id == rule->id) {
         if (!query_can_change_rule(area, _rules[area]->rules[i])) {
            return NOMIC_ERROR;
         }
         rule->type = ((class nomic_rule)_rules[area]->rules[i])->type;
         rule->id = ((class nomic_rule)_rules[area]->rules[i])->id;
         _rules[area]->rules[i] = rule;
         save_me();
         return 1;
      }
   }
   return 0;
}
int remove_nomic_rule(string area, int id) {
   class nomic_rule nomic_rule;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   foreach (nomic_rule in _rules[area]->rules) {
      if (nomic_rule->id == id) {
         if (!query_can_change_rule(area, nomic_rule)) {
            return NOMIC_ERROR;
         }
         _rules[area]->rules -= ({ nomic_rule });
         save_me();
         return 1;
      }
   }
   return 0;
}
int int_remove_nomic_rule(string area, int id) {
   class nomic_rule nomic_rule;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   foreach (nomic_rule in _rules[area]->rules) {
      if (nomic_rule->id == id) {
         _rules[area]->rules -= ({ nomic_rule });
         save_me();
         return 1;
      }
   }
   return 0;
}
class nomic_rule query_nomic_rule(string area, int id) {
   class nomic_rule nomic_rule;
   if (!_rules[area]) {
      return 0;
   }
   foreach (nomic_rule in _rules[area]->rules) {
      if (nomic_rule->id == id) {
         return copy(nomic_rule);
      }
   }
   return 0;
}
class nomic_rule* query_all_nomic_rules(string area) {
   if (!_rules[area]) {
      return ({ });
   }
   return copy(_rules[area]->rules);
}
class nomic_rule find_nomic_rule(string area, string creator, string text) {
   class nomic_rule rule;
   if (!_rules[area]) {
      return 0;
   }
   foreach (rule in _rules[area]->rules) {
      if (rule->creator == creator && rule->text == text) {
         return rule;
      }
   }
   return 0;
}
int create_area(string area) {
   class nomic_area new_area;
   if (_rules[area]) {
       return 0;
   }
   new_area = new(class nomic_area);
   new_area->new_type_num = NOMIC_DEFAULT_TYPE_NUMS;
   new_area->rules = ({ });
   _rules[area] = new_area;
   return 1;
}
int query_type_number(string name) {
   switch (lower_case(name)) {
   case "immutable" :
      return NOMIC_TYPE_IMMUTABLE;
   case "general" :
      return NOMIC_TYPE_GENERAL;
   case "citizen" :
      return NOMIC_TYPE_CITIZEN;
   default :
      return NOMIC_ERROR;
   }
}
string query_type_name(int type_no) {
   switch (type_no) {
   case NOMIC_TYPE_IMMUTABLE :
      return "immutable";
   case NOMIC_TYPE_GENERAL :
      return "general";
   case NOMIC_TYPE_CITIZEN :
      return "citizen";
   default :
      return "error";
   }
}
int query_can_change_rule(string area, class nomic_rule rule) {
   return rule->type != NOMIC_TYPE_IMMUTABLE;
}
string rule_as_string(int indent, class nomic_rule rule) {
   string ret;
   class nomic_amendment amend;
   ret = "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
          (rule->id?rule->id+"":"(" +
          NOMIC_HANDLER->query_type_name(rule->type) + ")") + " by " +
          capitalize(rule->creator) + " (" +
          ctime(rule->date_created) + "):\n" + rule->text +
          "\n";
   foreach (amend in rule->amendments) {
      ret += "$I$" + (indent + 10) + "=" + sprintf("%*s", indent + 3, "") +
             capitalize(amend->amender) + " (" +
             ctime(amend->date_amended) + "):\n" +
             amend->text + "\n";
   }
   return ret;
}

==================================================
FILE: handlers/inherit/player_council.c
==================================================

inherit "/obj/handlers/inherit/nomic_rules";
inherit "/obj/handlers/inherit/case_control";
inherit "/obj/handlers/inherit/citizen_elections";
#define NOMIC_SYSTEM_NO_CLASSES
#include <nomic_system.h>
#include <player.h>
private mapping _motions;
private mapping _new_citizens;
private int _completion_id;
void save_me();
class nomic_motion find_motion(string area, int rule_no, int type);
void update_immutables(string area);
void send_council_inform(string area, int only_magistrates,
                         string mess);
string motion_as_string(int indent, string area, class nomic_motion motion, int brief);
void create() {
   _motions = ([ ]);
   _new_citizens = ([ ]);
   citizen_elections::create();
   nomic_rules::create();
   case_control::create();
   _completion_id = call_out("check_for_completions",
       (time() - time() % (24 * 60 * 60) + (24 * 60 * 60) + (2 * 60)) - time());
}
void create_area(string area) {
   citizen_elections::create_area(area);
   nomic_rules::create_area(area);
   case_control::create_area(area);
   _motions[area] = ({ });
   _new_citizens[area] = ({ });
   update_immutables(area);
}
void update_immutables(string area) {
   string tmp;
   string type;
   string file;
   int int_type;
   class nomic_rule rule;
   foreach (rule in query_all_nomic_rules(area)) {
      if (rule->type == NOMIC_TYPE_IMMUTABLE) {
         remove_nomic_rule(area, rule->id);
      }
   }
   foreach (file in get_dir(NOMIC_RULE_DEFAULT_DIR)) {
      if (file_size(NOMIC_RULE_DEFAULT_DIR + "/" + file) > 0) {
         tmp = read_file(NOMIC_RULE_DEFAULT_DIR + "/" + file);
         type = explode(tmp, "\n")[0];
         tmp = implode(explode(tmp, "\n")[1..], "\n");
         switch (type) {
         case "immutable" :
            int_type = NOMIC_TYPE_IMMUTABLE;
            break;
         case "citizen" :
            int_type = NOMIC_TYPE_CITIZEN;
            break;
         case "general" :
            int_type = NOMIC_TYPE_GENERAL;
            break;
         default :
            int_type = -1;
            printf("Ignoring file " + file + "\n");
            break;
         }
         if (int_type != -1) {
            add_nomic_rule(area, int_type, area + " administrator", tmp);
         }
      }
   }
   save_me();
}
private int query_next_motion_id(string area) {
   int num;
   class nomic_motion fluff;
   num = 1;
   foreach (fluff in _motions[area]) {
      if (num <= fluff->identifier) {
         num = fluff->identifier + 1;
      }
   }
   return num;
}
int add_create_rule_motion(string area, int type, string text,
                          string creator) {
   class nomic_motion fluff;
   if (!is_magistrate_of(area, creator)) {
      return 0;
   }
   fluff = new(class nomic_motion);
   fluff->motion_type = NOMIC_MOTION_TYPE_RULE_ADD;
   fluff->rule = new(class nomic_rule);
   fluff->rule->creator = creator;
   fluff->rule->text = text;
   fluff->rule->type = type;
   fluff->rule->amendments = ({ });
   fluff->rule->date_created = time();
   fluff->comments = ({ });
   fluff->voted = ({ });
   fluff->state = NOMIC_STATE_COUNCIL_REVIEW;
   fluff->date_added = time();
   fluff->date_event = time();
   fluff->yes_votes = 0;
   fluff->no_votes = 0;
   fluff->added_by = creator;
   fluff->identifier = query_next_motion_id(area);
   _motions[area] += ({ fluff });
   save_me();
   send_council_inform(area, 1, creator + " added a new rule motion");
   post_magistrate_message(area, "New: Create rule motion",
              PLAYER_OB->convert_message(motion_as_string(0, area, fluff, 0)));
   return 1;
}
int add_move_rule_type_motion(string area, int rule_no, int type,
                              string creator) {
   class nomic_motion fluff;
   class nomic_rule bing;
   bing = query_nomic_rule(area, rule_no);
   if (!bing) {
      return 0;
   }
   if (bing->type == type) {
      return 0;
   }
   fluff = find_motion(area, rule_no, NOMIC_MOTION_TYPE_RULE_MOVE);
   if (fluff) {
      return 0;
   }
   fluff = new(class nomic_motion);
   fluff->motion_type = NOMIC_MOTION_TYPE_RULE_MOVE;
   fluff->rule = bing;
   fluff->new_rule_type = type;
   fluff->comments = ({ });
   fluff->voted = ({ });
   fluff->state = NOMIC_STATE_COUNCIL_REVIEW;
   fluff->date_added = time();
   fluff->date_event = time();
   fluff->yes_votes = 0;
   fluff->no_votes = 0;
   fluff->added_by = creator;
   fluff->identifier = query_next_motion_id(area);
   _motions[area] += ({ fluff });
   save_me();
   send_council_inform(area, 1, creator + " added a move rule motion");
   post_magistrate_message(area, "New: Move rule motion",
              PLAYER_OB->convert_message(motion_as_string(0, area, fluff, 0)));
   return 1;
}
int add_amend_rule_motion(string area, int rule_no, string amendment,
                           string creator) {
   class nomic_motion fluff;
   class nomic_rule bing;
   class nomic_amendment amend;
   bing = query_nomic_rule(area, rule_no);
   if (!bing) {
      return 0;
   }
   fluff = find_motion(area, rule_no, NOMIC_MOTION_TYPE_RULE_AMEND);
   if (fluff) {
      return 0;
   }
   fluff = new(class nomic_motion);
   fluff->motion_type = NOMIC_MOTION_TYPE_RULE_AMEND;
   amend = new (class nomic_amendment);
   amend->amender = creator;
   amend->text = amendment;
   amend->date_amended = time();
   bing->amendments += ({ amend });
   fluff->rule = bing;
   fluff->comments = ({ });
   fluff->voted = ({ });
   fluff->state = NOMIC_STATE_COUNCIL_REVIEW;
   fluff->date_added = time();
   fluff->date_event = time();
   fluff->yes_votes = 0;
   fluff->no_votes = 0;
   fluff->added_by = creator;
   fluff->identifier = query_next_motion_id(area);
   _motions[area] += ({ fluff });
   save_me();
   send_council_inform(area, 1, creator + " added an add rule motion");
   post_magistrate_message(area, "New: Ammend rule motion",
              PLAYER_OB->convert_message(motion_as_string(0, area, fluff, 0)));
   return 1;
}
int remove_rule_motion(string area, int rule_no, string creator) {
   class nomic_motion fluff;
   class nomic_rule bing;
   bing = query_nomic_rule(area, rule_no);
   if (!bing) {
      return 0;
   }
   fluff = find_motion(area, rule_no, NOMIC_MOTION_TYPE_RULE_REMOVE);
   if (fluff) {
      return 0;
   }
   fluff = new(class nomic_motion);
   fluff->motion_type = NOMIC_MOTION_TYPE_RULE_REMOVE;
   fluff->rule = bing;
   fluff->comments = ({ });
   fluff->voted = ({ });
   fluff->state = NOMIC_STATE_COUNCIL_REVIEW;
   fluff->date_added = time();
   fluff->date_event = time();
   fluff->yes_votes = 0;
   fluff->no_votes = 0;
   fluff->added_by = creator;
   fluff->identifier = query_next_motion_id(area);
   _motions[area] += ({ fluff });
   save_me();
   send_council_inform(area, 1, creator + " added a remove rule motion");
   post_magistrate_message(area, "New: Remove rule motion",
              PLAYER_OB->convert_message(motion_as_string(0, area, fluff, 0)));
   return 1;
}
class nomic_motion query_motion(string area, int id) {
   class nomic_motion fluff;
   if (!_motions[area]) {
      return 0;
   }
   foreach (fluff in _motions[area]) {
      if (fluff->identifier == id) {
         return fluff;
      }
   }
   return 0;
}
class nomic_motion* query_all_motions(string area) {
   if (!_motions[area]) {
      return ({ });
   }
   return copy(_motions[area]);
}
class nomic_motion find_motion(string area, int rule_no, int type) {
   class nomic_motion motion;
   foreach (motion in _motions[area]) {
      if (motion->rule->id == rule_no &&
          motion->motion_type == type) {
         return motion;
      }
   }
   return 0;
}
int comment_on_motion(string area, int id, string comment_text,
                            string commenter) {
   class nomic_comment comment;
   class nomic_motion bing;
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }
   if (bing->state != NOMIC_STATE_COUNCIL_REVIEW &&
       bing->state != NOMIC_STATE_COUNCIL_VOTE) {
      return 0;
   }
   comment = new(class nomic_comment);
   comment->text = comment_text;
   comment->commenter = commenter;
   comment->date_commented = time();
   bing->comments += ({ comment });
   save_me();
   return 1;
}
int amend_motion(string area, int id, string amend_text,
                    string amender) {
   class nomic_motion bing;
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }
   if (bing->state != NOMIC_STATE_COUNCIL_REVIEW) {
      return 0;
   }
   switch (bing->motion_type) {
   case NOMIC_MOTION_TYPE_RULE_ADD :
      bing->rule->text = amend_text;
      break;
   case NOMIC_MOTION_TYPE_RULE_REMOVE :
   case NOMIC_MOTION_TYPE_RULE_MOVE :
      return 0;
   case NOMIC_MOTION_TYPE_RULE_AMEND :
      bing->rule->amendments[<1]->text = amend_text;
   }
   save_me();
   return 1;
}
int vote_for_motion(string area, int id, int vote_type, string voter) {
   class nomic_motion bing;
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }
   if (member_array(voter, bing->voted) != -1) {
      return 0;
   }
   if (bing->state != NOMIC_STATE_COUNCIL_VOTE &&
       bing->state != NOMIC_STATE_CITIZEN_VOTE) {
      return 0;
   }
   switch (vote_type) {
   case NOMIC_VOTE_YES :
      bing->yes_votes++;
      break;
   case NOMIC_VOTE_NO :
      bing->no_votes++;
      break;
   case NOMIC_VOTE_ABSTAIN :
      bing->abstain_votes++;
      break;
   default :
      return 0;
   }
   bing->voted += ({ voter });
   save_me();
   return 1;
}
int has_voted_for_motion(string area, int id, string voter) {
   class nomic_motion bing;
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }
   return member_array(voter, bing->voted) != -1;
}
int* query_votes_for_motion(string area, int id) {
   class nomic_motion bing;
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }
   return ({ bing->yes_votes, bing->no_votes, bing->abstain_votes });
}
private void remove_motion(string area, class nomic_motion motion) {
   int i;
   for (i = 0; i < sizeof(_motions[area]); i++) {
      if (_motions[area][i] == motion) {
         _motions[area] = _motions[area][0..i-1] + _motions[area][i+1..];
      }
   }
}
void send_council_inform(string area, int only_magistrates,
                         string mess) {
   object *obs;
   if (only_magistrates) {
      obs = filter(users(), (: is_magistrate_of($2, $1->query_name()) :), area);
   } else {
      obs = filter(users(), (: is_citizen_of($2, $1->query_name()) :), area);
   }
   call_other(obs, "event_inform", this_object(), mess, "council");
}
int query_completion_time(string area, class nomic_motion motion) {
   return (motion->date_event - motion->date_event % (24 * 60 * 60) +
           7 * (24 * 60 * 60));
}
int complete_motion(string area, int id) {
   class nomic_motion bing;
   class nomic_motion motion;
   int passed;
   int new_num;
   string mess;
   int only_magistrates;
   string voting_result;
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }
   passed = bing->yes_votes > bing->no_votes;
   voting_result = "Voting Results:\n"
                   "    Yes: " + bing->yes_votes + "\n"
                   "     No: " + bing->no_votes + "\n"
                   "Abstain: " + bing->abstain_votes + "\n";
   mess = "Motion added by " + bing->added_by + " to ";
   switch (bing->motion_type) {
   case NOMIC_MOTION_TYPE_RULE_ADD :
      mess += "add a new rule";
      break;
   case NOMIC_MOTION_TYPE_RULE_REMOVE :
      mess += "remove rule " + bing->rule->id;
      break;
   case NOMIC_MOTION_TYPE_RULE_MOVE :
      mess += "move rule " + bing->rule->id;
      break;
   case NOMIC_MOTION_TYPE_RULE_AMEND :
      mess += "amend rule " + bing->rule->id;
      break;
   }
   if (passed || bing->state == NOMIC_STATE_COUNCIL_REVIEW) {
      switch (bing->state) {
      case NOMIC_STATE_COUNCIL_REVIEW :
         bing->yes_votes = 0;
         bing->no_votes = 0;
         bing->abstain_votes = 0;
         bing->voted = ({ });
         bing->state = NOMIC_STATE_COUNCIL_VOTE;
         mess += " is open for magistrates to vote";
         only_magistrates = 1;
         post_magistrate_message(area, "Motion now in voting phase",
              PLAYER_OB->convert_message(motion_as_string(0, area, bing, 0)));
         break;
      case NOMIC_STATE_COUNCIL_VOTE :
         bing->yes_votes = 0;
         bing->no_votes = 0;
         bing->abstain_votes = 0;
         bing->voted = ({ });
         bing->state = NOMIC_STATE_CITIZEN_VOTE;
         bing->comments = ({ });
         mess += " is open for citizens to vote";
         post_magistrate_message(area, "Law passed onto citizens",
                    PLAYER_OB->convert_message(rule_as_string(0, bing->rule)) +
                              "\n\n" + voting_result);
         post_citizen_message(area, "New motion for voting on",
              PLAYER_OB->convert_message(motion_as_string(0, area, bing, 0)));
         break;
      case NOMIC_STATE_CITIZEN_VOTE :
         switch (bing->motion_type) {
         case NOMIC_MOTION_TYPE_RULE_ADD :
            add_nomic_rule_class(area, bing->rule, bing->motion_type);
            break;
         case NOMIC_MOTION_TYPE_RULE_AMEND :
            change_nomic_rule(area, bing->rule);
            break;
         case NOMIC_MOTION_TYPE_RULE_MOVE :
            new_num = move_nomic_rule(area, bing->rule, bing->new_rule_type);
            foreach (motion in _motions[area]) {
               if (motion->rule->id == bing->rule->id) {
                  motion->rule->id = new_num;
               }
            }
            break;
         case NOMIC_MOTION_TYPE_RULE_REMOVE :
            remove_nomic_rule(area, bing->rule->id);
            break;
         }
         remove_motion(area, bing);
         mess += " is now law";
         post_citizen_message(area, "New Law!",
                    PLAYER_OB->convert_message(rule_as_string(0, bing->rule)));
         post_magistrate_message(area, "New Law!",
                    PLAYER_OB->convert_message(rule_as_string(0, bing->rule)) +
                    "\n\n" + voting_result);
         break;
      }
      bing->date_event = time();
   } else {
      if (bing->state == NOMIC_STATE_COUNCIL_VOTE) {
         mess += " not passed by the magistrates";
         only_magistrates = 1;
         post_magistrate_message(area, "Law not passed onto citizens",
                              rule_as_string(0, bing->rule) + "\n\n" +
                              voting_result);
      } else {
         mess += " not ratified by the citizens";
         only_magistrates = 0;
         post_citizen_message(area, "Law not passed",
                              rule_as_string(0, bing->rule));
         post_magistrate_message(area, "Law not passed",
                              rule_as_string(0, bing->rule) + "\n\n" +
                              voting_result);
      }
      remove_motion(area, bing);
   }
   save_me();
   send_council_inform(area, only_magistrates, mess);
   return 1;
}
void check_for_completions() {
   string area;
   class nomic_motion* bits;
   class nomic_motion motion;
   foreach (area, bits in _motions) {
      foreach (motion in bits) {
         if (query_completion_time(area, motion) < time()) {
            complete_motion(area, motion->identifier);
         }
      }
   }
   remove_call_out(_completion_id);
   _completion_id = call_out("check_for_completions",
            (time() - time() % (24 * 60 * 60) + (24 * 60 * 60)) - time());
   update_recently_closed_cases();
}
string motion_as_string(int indent, string area, class nomic_motion motion,
                        int brief) {
   string ret;
   class nomic_comment comment;
   ret = "";
   switch (motion->motion_type) {
   case NOMIC_MOTION_TYPE_RULE_ADD :
      ret += "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
             motion->identifier + ") Add new rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_REMOVE :
      ret += "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
             motion->identifier + ") Remove rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_MOVE :
      ret += "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
             motion->identifier + ") Transmogrify rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_AMEND :
      ret += "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
             motion->identifier + ") Amend rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "\n";
      break;
   }
   ret += rule_as_string(5 + indent, motion->rule);
   if (sizeof(motion->comments)) {
      if (!brief) {
         ret += "$I$" + (indent + 5) + "=     Comments:\n";
         foreach (comment in motion->comments) {
            ret += "$I$" + (indent + 11) + "=" + sprintf("%*s", indent + 3, "") +                capitalize(comment->commenter) + " (" +
                   ctime(comment->date_commented) + "):\n" +
                   comment->text + "\n";
         }
      } else {
         ret += "$I$0=" + sprintf("%*s", indent, "") + "     " +
                 sizeof(motion->comments) + " Comments.\n";
      }
   } else {
      ret += "$I$0=" + sprintf("%*s", indent, "") + "     No Comments.\n";
   }
   switch (motion->state) {
   case NOMIC_STATE_COUNCIL_REVIEW :
      ret += "$I$0=" + sprintf("%*s", indent, "") +
             "The item is currently being reviewed by the magistrates.\n";
      break;
   case NOMIC_STATE_COUNCIL_VOTE :
      ret += "$I$0=" + sprintf("%*s", indent, "") +
             "The item is currently being voted on by the magistrates.\n";
      break;
   case NOMIC_STATE_CITIZEN_VOTE :
      ret += "$I$0=" + sprintf("%*s", indent, "") +
             "The item is currently being ratified by the citizens.\n";
      break;
   }
   ret += "$I$0=" + sprintf("%*s", indent, "") +
          "The item will go onto the next stage at " +
          ctime(query_completion_time(area, motion)) +
          ".\n";
   return ret;
}
string rule_as_html(class nomic_rule rule) {
   string ret;
   class nomic_amendment amend;
   ret = "<i><b>" + (rule->id?rule->id+"":"(" +
          NOMIC_HANDLER->query_type_name(rule->type) + ")") + "</b> by " +
          capitalize(rule->creator) + " (" +
          ctime(rule->date_created) + "):</i>\n"
          "<p style=\"margin-left: 30pt;margin-top: 5pt\">\n" +
          replace_string(rule->text, "\n", "<br>") +
          "<br>\n";
   foreach (amend in rule->amendments) {
      ret += "<i><b>Ammendment</b> by " + capitalize(amend->amender) + " (" +
             ctime(amend->date_amended) + "):</i>\n"
             "<p style=\"margin-left: 60pt;margin-top: 5pt\">\n" +
             replace_string(amend->text, "\n", "<br>") +
             "\n</p>\n";
   }
   ret += "</p>\n";
   return ret;
}
string motion_as_html(string area, class nomic_motion motion) {
   string ret;
   class nomic_comment comment;
   ret = "";
   switch (motion->motion_type) {
   case NOMIC_MOTION_TYPE_RULE_ADD :
      ret += "<b>" + motion->identifier + ") Add new rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "</b>\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_REMOVE :
      ret += "<b>" + motion->identifier + ") Remove rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "</b>\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_MOVE :
      ret += "<b>" + motion->identifier + ") Transmogrify rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "</b>\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_AMEND :
      ret += "<b>" + motion->identifier + ") Amend rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "</b>\n";
      break;
   }
   ret += "<ul>" + rule_as_html(motion->rule) + "</ul>";
   if (sizeof(motion->comments)) {
      ret += "<b>Comments:</b><br>\n";
      foreach (comment in motion->comments) {
         ret += ctime(comment->date_commented) + "):<br>\n" +
                comment->text + "<p>\n";
      }
   }
   switch (motion->state) {
   case NOMIC_STATE_COUNCIL_REVIEW :
      ret += "The item is currently being reviewed by the magistrates.\n";
      break;
   case NOMIC_STATE_COUNCIL_VOTE :
      ret += "The item is currently being voted on by the magistrates.\n";
      break;
   case NOMIC_STATE_CITIZEN_VOTE :
      ret += "The item is currently being ratified by the citizens.\n";
      break;
   }
   ret += "<br>The item will go onto the next stage at " +
          ctime(query_completion_time(area, motion)) +
          ".\n";
   return ret;
}

==================================================
FILE: handlers/terrain_things/dungeon_maker.c
==================================================

#include <dirs.h>
#include <terrain.h>
#define END 0
#define TWO 1
#define FOUR 2
#define ROOM 3
#define HALF 0
#define FULL 1
#define DIRS ({ "north", "northeast", "east", "southeast", \
      "south", "southwest", "west", "northwest" })
inherit "/std/object";
int max, size, *clear, *c_probs, *p_probs, *r_probs, *start;
string terrain_name, *passage_files, *room_files;
object easel;
mixed *passages, *room_entries;
void setup() {
   set_name( "box" );
   set_short( "green box" );
   add_adjective( "green" );
   set_long( "This is a green box.  It's quite featureless but, strangely "+
         "enough, something tells you it's a dungeon generator.\n" );
   reset_get();
   start = allocate( 3 );
   passages = ({ });
   room_entries = ({ });
}
void dest_me() {
   if ( easel )
      easel->dest_me();
   ::dest_me();
}
int query_max_locations() { return max; }
void set_max_locations( mixed arg ) { max = to_int( arg ); }
int *query_junction_clearance() { return clear; }
void set_junction_clearance( mixed *args ) {
   int i;
   clear = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      clear[ i ] = to_int( args[ i ] );
}
int *query_continue_probabilities() { return c_probs; }
void set_continue_probabilities( mixed *args ) {
   int i;
   c_probs = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      c_probs[ i ] = to_int( args[ i ] );
}
int *query_passage_probabilities() { return p_probs; }
void set_passage_probabilities( mixed *args ) {
   int i;
   p_probs = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      p_probs[ i ] = to_int( args[ i ] );
}
int *query_room_probabilities() { return r_probs; }
void set_room_probabilities( mixed *args ) {
   int i;
   r_probs = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      r_probs[ i ] = to_int( args[ i ] );
}
int *query_start_co_ord() { return start; }
void set_start_co_ord( mixed *args ) {
   int i;
   if ( sizeof( args ) != 3 )
      return;
   for ( i = 0; i < sizeof( args ); i++ )
      start[ i ] = to_int( args[ i ] );
}
string query_terrain_name() { return terrain_name; }
void set_terrain_name( string word ) { terrain_name = word; }
string *query_passage_files() { return passage_files; }
void set_passage_files( string *words ) { passage_files = words; }
string *query_room_files() { return room_files; }
void set_room_files( string *words ) { room_files = words; }
object query_easel() { return easel; }
mixed *query_passages() { return passages; }
mixed *query_room_entries() { return room_entries; }
int do_generate(string);
void init() {
   add_command( "generate", "<word'terrainname'>", (:do_generate($4[0]):));
}
void mark_passage( int *co_ord ) {
   easel->add_shape( ({ ( co_ord[ 1 ] - start[ 1 ] ) / size,
         ( start[ 0 ] - co_ord[ 0 ] ) / size }), ({ "#" }) );
}
void mark_room( int *co_ord, string room ) {
   int width;
   width = (int)room->query_room_size();
   easel->add_shape( ({ ( co_ord[ 1 ] - start[ 1 ] - width - size / 2 ) / size,
         ( start[ 0 ] - co_ord[ 0 ] - width - size / 2 ) / size }),
         (string *)easel->make_block( ( 2 * width ) / size + 2 ) );
}
int do_generate( string word ) {
   int i;
   string data, direc, *lines;
   mixed *parameters;
   if ( easel )
      return notify_fail( "The generator is working on "+
            terrain_name +".\n" );
   if ( file_size( word ) < 0 )
      return notify_fail( "File "+ word +" does not exist.\n" );
   lines = explode( read_file( word ), "\n" );
   for ( i = 0; i < sizeof( lines ); i++ ) {
      if ( lines[ i ] == "" )
         continue;
       if ( lines[ i ][ 0 .. 0 ] == "#" )
         continue;
      parameters = explode( lines[ i ], " " );
      if ( !stringp( parameters[ 0 ] ) ) {
         printf( "%s line %d: %O is not a string.\n", word, i,
               parameters[ 0 ] );
         continue;
      }
      if ( sizeof( parameters ) == 2 )
         call_other( this_object(), "set_"+ parameters[ 0 ],
               parameters[ 1 ] );
      else
         call_other( this_object(), "set_"+ parameters[ 0 ],
               parameters[ 1 .. sizeof( parameters ) - 1 ] );
      printf( "Set %s to %O.\n", parameters[ 0 ], call_other( this_object(),
            "query_"+ parameters[ 0 ] ) );
   }
   if ( file_size( RESTORE_PATH + terrain_name +".o" ) > 0 )
      return notify_fail( "Terrain "+ terrain_name +" already exists.\n" );
   easel = clone_object( "/obj/misc/easel" );
   set_long( "This is a green box.  It's quite featureless but, strangely "+
         "enough, something tells you it's a dungeon generator.\nIt seems "+
         "to be humming quietly but in a very powerful way.\n" );
   write( "Working on "+ terrain_name +".\n" );
   direc = DIRS[ random( 8 ) ];
   for ( i = 0; i < 4; i++ )
      passages += ({ ({ DIRS[ ( member_array( direc, DIRS ) + 2 * i ) % 8 ],
            passage_files[ random( sizeof( passage_files ) ) ],
            start, 0, 0, 1 + clear[ 0 ] + random( clear[ 1 ] ) }) });
   size = 2 * (int)passage_files[ 0 ]->query_room_size();
   TERRAIN_MAP->add_floating_location( terrain_name, passage_files[ 0 ],
         start, 0 );
   call_out( "process_passages", 2 );
   return 1;
}
void stop_working() {
   tell_room( environment(), "The box stops humming as it extrudes an "+
         "easel from a slot in one side.\n" );
   easel->add_shape( ({ 0, 0 }), ({ "@" }) );
   write_file( "/open/"+ terrain_name +".map",
         implode( (string *)easel->query_lines(), "\n" ) );
   easel->move( environment() );
   easel = 0;
   passages = ({ });
   room_entries = ({ });
   set_long( "This is a green box.  It's quite featureless but, strangely "+
         "enough, something tells you it's a dungeon generator.\n" );
}
int *shift_in( int *co_ord, string direc, string from, string to ) {
   int i, delta, *new_co_ord, *vector;
   delta = (int)from->query_room_size() + (int)to->query_room_size();
   new_co_ord = allocate( 3 );
   vector = STD_ORDERS[ member_array( direc, STD_ORDERS ) + 1 ];
   for ( i = 0; i < 3; i++ )
      new_co_ord[ i ] = co_ord[ i ] - delta * vector[ i ];
   return new_co_ord;
}
void process_passages() {
   int i, j, k, prob, straight, *co_ord, *new_co_ord;
   string direc, new_direc, type, new_type;
   mixed *last;
   if ( !sizeof( passages ) ) {
      tell_room( environment(), "No passages to process.\n" );
      return stop_working();
   }
   if ( max < 1 ) {
      tell_room( environment(), "Reached maximum.\n" );
      return stop_working();
   }
   max--;
   direc = passages[ 0 ][ 0 ];
   type = passages[ 0 ][ 1 ];
   co_ord = passages[ 0 ][ 2 ];
   last = passages[ 0 ][ 3 .. 4 ];
   straight = passages[ 0 ][ 5 ];
   passages = delete( passages, 0, 1 );
   call_out( "process_passages", 2 );
   for ( i = 0; i < 3; i++ ) {
      new_direc = DIRS[ ( member_array( direc, DIRS ) + 7 + i ) % 8 ];
      new_co_ord = shift_in( co_ord, new_direc, type, type );
      if ( sizeof( (mixed *)TERRAIN_MAP->
            member_floating_locations( new_co_ord ) ) ) {
         tell_room( environment(), "Passage already at "+ new_co_ord[ 0 ] +
               ", "+ new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +"; ending "+
               "passage at "+ co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+
               co_ord[ 2 ] +".\n" );
         return;
      }
      for ( j = 0; j < sizeof( room_entries ); j++ ) {
         for ( k = 0; k < 3; k++ )
            if ( new_co_ord[ k ] != room_entries[ j ][ k ] )
               break;
         if ( k < 3 )
            continue;
         tell_room( environment(), "Room entry at "+ new_co_ord[ 0 ] +
               ", "+ new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +"; "+
               "joining passage at "+ co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+
               co_ord[ 2 ] +".\n" );
         TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord,
               0 );
         mark_passage( new_co_ord );
         room_entries = delete( room_entries, j, 1 );
         return;
      }
      if ( (int)easel->query_at( ({ ( new_co_ord[ 1 ] - start[ 1 ] ) / size,
            ( start[ 0 ] - new_co_ord[ 0 ] ) / size }) ) != 32 ) {
         tell_room( environment(), "Something at "+ new_co_ord[ 0 ] +
               ", "+ new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +"; ending "+
               "passage at "+ co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+
               co_ord[ 2 ] +".\n" );
         return;
      }
   }
   prob = random( 100 );
   if ( prob < p_probs[ END ] ) {
      tell_room( environment(), "Passage going "+ direc +" ends at "+
            co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
      return;
   }
   prob -= p_probs[ END ];
   if ( ( prob < p_probs[ TWO ] ) && !straight ) {
      if ( random( 100 ) >= c_probs[ HALF ] + c_probs[ FULL ] ) {
         tell_room( environment(), "Passage branching "+ direc +" and " );
         new_co_ord = shift_in( co_ord, direc, type, type );
         TERRAIN_MAP->add_floating_location( terrain_name, type,
               new_co_ord, 0 );
         passages += ({ ({ direc, type, new_co_ord, co_ord, last[ 0 ],
               clear[ 0 ] + random( clear[ 1 ] ) }) });
         mark_passage( new_co_ord );
         if ( random( c_probs[ HALF ] + c_probs[ FULL ] ) < c_probs[ HALF ] )
            direc = DIRS[ ( member_array( direc, DIRS ) + 1 +
                  6 * random( 2 ) ) % 8 ];
         else
            direc = DIRS[ ( member_array( direc, DIRS ) + 2 +
                  4 * random( 2 ) ) % 8 ];
         type = passage_files[ random( sizeof( passage_files ) ) ];
         new_co_ord = shift_in( co_ord, direc, type, type );
         TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord,
               0 );
         passages += ({ ({ direc, type, new_co_ord, co_ord, last[ 0 ],
               clear[ 0 ] + random( clear[ 1 ] ) }) });
         mark_passage( new_co_ord );
         tell_room( environment(), direc +" from "+
               co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
         return;
      }
      if ( random( c_probs[ HALF ] + c_probs[ FULL ] ) < c_probs[ HALF ] )
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 1 ) % 8 ];
      else
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 2 ) % 8 ];
      type = passage_files[ random( sizeof( passage_files ) ) ];
      new_co_ord = shift_in( co_ord, new_direc, type, type );
      TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord, 0 );
      passages += ({ ({ new_direc, type, new_co_ord, co_ord, last[ 0 ],
            clear[ 0 ] + random( clear[ 1 ] ) }) });
      mark_passage( new_co_ord );
      tell_room( environment(), "Passage branching "+ new_direc +" and " );
      if ( random( c_probs[ HALF ] + c_probs[ FULL ] ) < c_probs[ HALF ] )
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 7 ) % 8 ];
      else
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 6 ) % 8 ];
      type = passage_files[ random( sizeof( passage_files ) ) ];
      new_co_ord = shift_in( co_ord, new_direc, type, type );
      TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord, 0 );
      passages += ({ ({ new_direc, type, new_co_ord, co_ord, last[ 0 ],
            clear[ 0 ] + random( clear[ 1 ] ) }) });
      mark_passage( new_co_ord );
      tell_room( environment(), new_direc +" from "+
            co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
      return;
   }
   prob -= p_probs[ TWO ];
   if ( ( prob < p_probs[ FOUR ] ) && !straight ) {
      tell_room( environment(), "Crossroads from "+ direc +" at "+
            co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
      for ( i = 0; i < 3; i++ ) {
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 6 + 2 * i ) % 8 ];
         type = passage_files[ random( sizeof( passage_files ) ) ];
         new_co_ord = shift_in( co_ord, new_direc, type, type );
         TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord,
               0 );
         passages += ({ ({ new_direc, type, new_co_ord, co_ord, last[ 0 ],
               clear[ 0 ] + random( clear[ 1 ] ) }) });
         mark_passage( new_co_ord );
      }
      return;
   }
   prob -= p_probs[ FOUR ];
   if ( ( prob < p_probs[ ROOM ] ) && !straight ) {
      prob = random( 100 );
      new_type = room_files[ 0 ];
      for ( i = 1; i < sizeof( room_files ); i++ )
         if ( prob < r_probs[ FULL + i ] ) {
            new_type = room_files[ i ];
            break;
         } else
            prob -= r_probs[ FULL + i ];
      new_co_ord = shift_in( co_ord, direc, type, new_type );
      tell_room( environment(), "Room at "+ new_co_ord[ 0 ] +", "+
            new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +".\n" );
      TERRAIN_MAP->add_floating_location( terrain_name, new_type,
            new_co_ord, 0 );
      mark_room( new_co_ord, new_type );
      mark_passage( co_ord );
      for ( i = 1; i < 8; i++ ) {
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 4 + i ) % 8 ];
         type = passage_files[ random( sizeof( passage_files ) ) ];
         co_ord = shift_in( new_co_ord, new_direc, new_type, type );
         if ( i % 2 ) {
            if ( random( 100 ) < r_probs[ HALF ] ) {
               tell_room( environment(), "Passage leaving room to "+
                     new_direc +".\n" );
               TERRAIN_MAP->add_floating_location( terrain_name, type, co_ord,
                     0 );
               passages += ({ ({ new_direc, type, co_ord, new_co_ord,
                     last[ 0 ], clear[ 0 ] + random( clear[ 1 ] ) }) });
               mark_passage( co_ord );
            } else
               room_entries += ({ co_ord });
         } else {
            if ( random( 100 ) < r_probs[ FULL ] ) {
               tell_room( environment(), "Passage leaving room to "+
                     new_direc +".\n" );
               TERRAIN_MAP->add_floating_location( terrain_name, type, co_ord,
                     0 );
               passages += ({ ({ new_direc, type, co_ord, new_co_ord,
                     last[ 0 ], clear[ 0 ] + random( clear[ 1 ] ) }) });
               mark_passage( co_ord );
            } else
               room_entries += ({ co_ord });
         }
      }
      return;
   }
   prob = random( 100 );
   if ( ( prob < c_probs[ HALF ] ) && !straight ) {
      direc = DIRS[ ( member_array( direc, DIRS ) + 1 +
             6 * random( 2 ) ) % 8 ];
      straight = clear[ 0 ] + random( clear[ 1 ] );
   } else {
      prob -=  c_probs[ HALF ];
      if ( ( prob < c_probs[ FULL ] ) && !straight ) {
         direc = DIRS[ ( member_array( direc, DIRS ) + 2 +
               4 * random( 2 ) ) % 8 ];
         straight = clear[ 0 ] + random( clear[ 1 ] );
      }
   }
   if ( straight > 0 )
      straight--;
   new_co_ord = shift_in( co_ord, direc, type, type );
   tell_room( environment(), "Passage goes "+ direc +" from "+
         co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
   TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord, 0 );
   passages += ({ ({ direc, type, new_co_ord, co_ord, last[ 0 ],
         straight }) });
   mark_passage( new_co_ord );
}

==================================================
FILE: handlers/terrain_things/logroom.c
==================================================

#include <terrain.h>
#define SAVE_FILE RESTORE_PATH +"logroom"
inherit "/std/room";
mapping locations;
void setup() {
   set_short( "limbo" );
   set_light( 50 );
   set_long( "You are between worlds, surrounded by raw potentiality and "+
         "not a lot else.\n" );
   add_item( "potentiality", "Well, it's sort of potentially something and "+
         "potentially nothing, and it can't quite decide at the moment.  "+
         "With any luck, though, you won't be here long enough to find "+
         "out...\n" );
   add_exit( "drum", "/d/am/am/mendeddrum", "path" );
   locations = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) )
      unguarded((: restore_object, SAVE_FILE :));
}
void save_this() {
  unguarded((: save_object, SAVE_FILE :));
}
void player_quitting( object player, object place ) {
   if ( player->query_property( "guest" ) )
      return;
   locations[ (string)player->query_name() ] =
         ({ (string)place->query_property( "terrain name" ),
         (int *)place->query_co_ord() });
   save_this();
   call_out( "check_quitted", 5, (string)player->query_name() );
}
void check_quitted( string word ) {
   if ( !find_player( word ) )
      return;
   if ( locations[ word ] )
      locations = m_delete( locations, word );
   save_this();
}
void event_enter( object player, string words, object thing ) {
   object location;
   mixed *data;
   data = locations[ (string)player->query_name() ];
   if ( !data ) {
      player->move( (string)player->query_start_pos(),
            "$N enter$s the game." );
      return;
   }
   location = (object)TERRAIN_MAP->find_location( data[ 0 ],
         data[ 1 ] );
   player->move( location );
   locations = m_delete( locations, (string)player->query_name() );
   save_this();
}

==================================================
FILE: handlers/terrain_things/sample_passage.c
==================================================

inherit "/std/room";
void setup() {
   set_short( "dusty corridor" );
   set_light( 20 );
   set_room_size( 5 );
   set_long( "You are in a dry, dusty corridor.  It looks as though it has "+
         "been deserted for a long time.\n" );
   add_item( "dust", "There's quite a bit of dust in here, collecting along "+
         "the bottom of the walls." );
}
string query_exit_type( string word ) { return "corridor"; }

==================================================
FILE: handlers/terrain_things/sample_passage_1.c
==================================================

inherit "/std/room";
void setup() {
   set_short( "dusty corridor" );
   set_light( 20 );
   set_room_size( 5 );
   set_long( "You are in a dry, dusty corridor.  It looks as though it has "+
         "been deserted for a long time.\n" );
   add_item( "dust", "There's quite a bit of dust in here, collecting along "+
         "the bottom of the walls." );
}
string query_exit_type( string word ) { return "corridor"; }

==================================================
FILE: handlers/terrain_things/sample_passage_2.c
==================================================

inherit "/std/room";
void setup() {
   set_short( "rock-walled tunnel" );
   set_light( 20 );
   set_room_size( 5 );
   set_long( "You are tunnel with rough-hewn rock walls.  It looks as though "+
         "it has been deserted for a long time.\n" );
   add_item( ({ "rough-hewn rock wall", "rock" }), "The walls are rough, "+
         "where the tunnel was hewn out of the rock." );
}
string query_exit_type( string word ) { return "corridor"; }

==================================================
FILE: handlers/terrain_things/sample_room_1.c
==================================================

inherit "/std/room";
void setup() {
   set_short( "small room" );
   set_light( 20 );
   set_room_size( 15 );
   set_long( "You are in a small room.  The walls, floor and ceiling are "+
         "comprised of large stone blocks.  The room is quite bare.\n" );
   add_item( ({ "wall", "floor", "ceiling" }), "The walls, floor and "+
         "ceiling of the room are formed from large stone blocks." );
   add_item( "large stone block", "The blocks of stone that make up the "+
         "surfaces of this room are not too rough, but they were never "+
         "polished smooth either." );
}
string query_exit_type( string word ) { return "corridor"; }

==================================================
FILE: handlers/terrain_things/sample_room_2.c
==================================================

inherit "/std/room";
void setup() {
   set_short( "largish room" );
   set_light( 20 );
   set_room_size( 25 );
   set_long( "You are in a largish room.  The walls, floor and ceiling are "+
         "comprised of large stone blocks.  The room is quite bare.\n" );
   add_item( ({ "wall", "floor", "ceiling" }), "The walls, floor and "+
         "ceiling of the room are formed from large stone blocks." );
   add_item( "large stone block", "The blocks of stone that make up the "+
         "surfaces of this room are not too rough, but they were never "+
         "polished smooth either." );
}
string query_exit_type( string word ) { return "corridor"; }

==================================================
FILE: handlers/terrain_things/sample_room_3.c
==================================================

inherit "/std/room";
void setup() {
   set_short( "large room" );
   set_light( 20 );
   set_room_size( 35 );
   set_long( "You are in a large room.  The walls, floor and ceiling are "+
         "comprised of large stone blocks.  The room is quite bare.\n" );
   add_item( ({ "wall", "floor", "ceiling" }), "The walls, floor and "+
         "ceiling of the room are formed from large stone blocks." );
   add_item( "large stone block", "The blocks of stone that make up the "+
         "surfaces of this room are not too rough, but they were never "+
         "polished smooth either." );
}
string query_exit_type( string word ) { return "corridor"; }

==================================================
FILE: handlers/autodoc/autodoc_file.c
==================================================

#define MASTER_OB "/secure/master.c"
#define EOF -1
#define SAVE_DIR "/save/autodoc/"
nosave mapping private_functions;
mapping public_functions;
mapping protected_functions;
mapping inherits;
mapping main_docs;
mapping define_docs;
mapping includes;
mapping class_docs;
string file_name;
int last_changed;
int num_failed_tries;
nosave string current_comment;
nosave string current_file;
nosave int current_position;
nosave int changed;
nosave mapping defines;
nosave mixed *exclude_methods;
private void setup();
private mapping parse_comment(string stuff);
private void do_parse_file(function func);
private int query_file_position();
private void handle_inherit(mixed *bits);
void create() {
   seteuid(getuid());
   setup();
}
private void setup() {
   changed = 0;
   main_docs = 0;
   file_name = "";
   private_functions = ([ ]);
   public_functions = ([ ]);
   protected_functions = ([ ]);
   inherits = ([ ]);
   defines = ([ ]);
   define_docs = ([ ]);
   includes = ([ ]);
   class_docs = ([ ]);
   current_comment = 0;
   current_file = "";
   current_position = 0;
   last_changed = 0;
   exclude_methods = ({ "setup", "create", "init", "dest_me", "reset" });
}
private int query_file_position() {
   return current_position;
}
private int lookahead_character(int num) {
   if (current_position + num - 1 < strlen(current_file)) {
      return current_file[current_position + num - 1];
   }
   return EOF;
}
private int next_character() {
   if (current_position < strlen(current_file)) {
      return current_file[current_position++];
   }
   return EOF;
}
private int pop_character(int num) {
   current_position += num;
}
private void skip_to_end_of_line() {
   int ch;
   do {
      ch = next_character();
   } while (ch != '\r' && ch != '\n' && ch != EOF);
}
private string skip_to_end_of_comment() {
   string data;
   int ch;
   int ok;
   data = "";
   do {
      ok = 1;
      ch = next_character();
      if (ch == '*' && lookahead_character(1) == '/') {
         ok = 0;
         pop_character(1);
      } else if (ch == '\r' || ch == '\n') {
         data += "\n";
         if (lookahead_character(1) == ' ') {
            pop_character(1);
         }
         if (lookahead_character(1) == '*' && lookahead_character(2) != '/') {
            pop_character(1);
            if (lookahead_character(1) == ' ') {
               pop_character(1);
            }
         }
      } else if (ch == EOF) {
         ok = 0;
      } else if (ch == '\\' && (lookahead_character(1) == '/' ||
                               lookahead_character(1) == '*' ||
                               lookahead_character(1) == '\\')) {
      } else {
         data += sprintf("%c", ch);
      }
   } while (ok);
   return data;
}
private void skip_spaces_and_comments() {
   int ok;
   do {
     switch (lookahead_character(1)) {
        case ' ' :
        case '\t' :
        case '\n' :
        case '\r' :
           ok = 1;
           pop_character(1);
           break;
        case '/' :
           if (lookahead_character(2) == '/') {
              ok = 1;
              skip_to_end_of_line();
           } else if (lookahead_character(2) == '*') {
              ok = 1;
              if (lookahead_character(3) != '*' ||
                  lookahead_character(4) == '*') {
                 pop_character(2);
                 skip_to_end_of_comment();
                 current_comment = 0;
              } else {
                 pop_character(3);
                 if (lookahead_character(1) == ' ') {
                    pop_character(1);
                 }
                 if (!main_docs) {
                    main_docs = parse_comment(skip_to_end_of_comment());
                 } else {
                    current_comment = skip_to_end_of_comment();
                 }
              }
           } else {
              ok = 0;
           }
           break;
        default :
           ok = 0;
           break;
     }
   } while (ok);
}
private string expand_token(string token) {
   if (defines[token]) {
      return defines[token];
   }
   return 0;
}
private string get_word() {
   string data;
   int ok;
   int ch;
   skip_spaces_and_comments();
   ok = 1;
   data = "";
   ch = lookahead_character(1);
   if ((ch >= 'a' && ch <= 'z') ||
       (ch >= 'A' && ch <= 'Z') ||
       (ch == '_')) {
      do {
         ch = lookahead_character(1);
         if ((ch >= 'a' && ch <= 'z') ||
             (ch >= 'A' && ch <= 'Z') ||
             (ch >= '0' && ch <= '9') ||
             (ch == '_')) {
            ch = next_character();
            data += sprintf("%c", ch);
         } else {
            ok = 0;
         }
      } while (ok);
      if (expand_token(data)) {
         current_file = expand_token(data) + current_file[current_position..];
         current_position = 0;
         return get_word();
      }
   } else if ((ch >= '0' && ch <= '9') ||
              (ch == '-')) {
      if (ch == '-') {
         data += sprintf("%c", next_character());
      }
      do {
         ch = lookahead_character(1);
         if ((ch >= '0' && ch <= '9') ||
             (ch >= '.')) {
            ch = next_character();
            data += sprintf("%c", ch);
         } else {
            ok = 0;
         }
      } while (ok);
   } else if (ch == '\"' || ch == '\'') {
      int end_ch;
      end_ch = ch;
      ch = next_character();
      data += sprintf("%c", ch);
      do {
         ch = next_character();
         if (ch == end_ch) {
            ok = 0;
            data += sprintf("%c", ch);
         } else if (ch == '\\') {
            ch = next_character();
            data += sprintf("\\%c", ch);
         } else if (ch == EOF) {
            ok = 0;
         } else {
            data += sprintf("%c", ch);
         }
      } while (ok);
   } else if (ch == '(') {
      if (lookahead_character(2) == '{' ||
          lookahead_character(2) == '[') {
         return sprintf("%c%c", next_character(), next_character());
      }
      return sprintf("%c", next_character());
   } else if (ch == '}' || ch == ']') {
      if (lookahead_character(2) == ')') {
         return sprintf("%c%c", next_character(), next_character());
      }
      return sprintf("%c", next_character());
   } else if (ch == ';' ||
              ch == ')' ||
              ch == '=' ||
              ch == '{' ||
              ch == '}') {
      return sprintf("%c", next_character());
   } else if (ch == EOF) {
      return "";
   } else {
      do {
         ch = lookahead_character(1);
         if ((ch >= 'a' && ch <= 'z') ||
             (ch >= 'A' && ch <= 'Z') ||
             (ch >= '0' && ch <= '9') ||
             (ch == '_') ||
             (ch == ' ') ||
             (ch == '\t') ||
             (ch == '\n') ||
             (ch == '(') ||
             (ch == ')') ||
             (ch == EOF) ||
             (ch == ';') ||
             (ch == '=') ||
             (ch == '{') ||
             (ch == '}') ||
             (ch == '\'') ||
             (ch == '\"') ||
             (ch == '\r')) {
            ok = 0;
         } else {
            ch = next_character();
            data += sprintf("%c", ch);
         }
      } while (ok);
   }
   return data;
}
private mixed *get_statement(string start) {
   mixed *bits;
   string curr;
   int depth;
   string temp_comment;
   int last_pos;
   int in_class;
   bits = ({ start });
   do {
      last_pos = query_file_position();
      curr = get_word();
      bits += ({ curr });
      if (last_pos != query_file_position()) {
         reset_eval_cost();
      }
   } while (curr != ";" && curr != "{" && curr != "");
   if (curr == "{") {
      if (member_array("class", bits) != -1 &&
          member_array("(", bits) == -1) {
         in_class = 1;
      }
      temp_comment = current_comment;
      depth = 1;
      do {
        last_pos = query_file_position();
        curr = get_word();
        if (curr == "{") {
           depth++;
        } else if (curr == "}") {
           depth--;
        } else if (curr == "") {
           depth = 0;
        }
        if (last_pos != query_file_position()) {
           reset_eval_cost();
        }
        if (in_class) {
           bits += ({ curr });
        }
      } while (depth > 0);
      current_comment = temp_comment;
   }
   return bits;
}
private mapping parse_comment(string stuff) {
   string *bits;
   int i;
   mapping frog;
   string name;
   int j;
   int rabbit;
   if (!stuff) {
      return ([ ]);
   }
   if (stuff[0] == '@') {
      stuff = "\n" + stuff;
   } else {
      stuff = "\n@main " + stuff;
   }
   bits = explode(stuff, "\n@");
   frog = ([ ]);
   for (i = 0; i< sizeof(bits); i++) {
      j = strsrch(bits[i], " ");
      rabbit = strsrch(bits[i], "\n");
      if (j == -1 || (rabbit != -1 && rabbit < j)) {
         j = rabbit;
      }
      if (j > 0) {
         name = bits[i][0..j - 1];
         stuff = bits[i][j+1..];
         if (!frog[name]) {
            frog[name] = ({ stuff });
         } else {
            frog[name] += ({ stuff });
         }
      }
   }
   return frog;
}
private void handle_class(mixed *bits) {
   string name;
   int i;
   string *types;
   mapping comm;
   name = bits[1];
   types = ({ });
   i = member_array("{", bits);
   if (i != -1) {
      bits = bits[i + 1..];
      while (sizeof(bits)) {
         i = member_array(";", bits);
         if (i != -1) {
            types += ({ ({ bits[i - 1], bits[0..i - 2] }) });
            bits = bits[i + 1..];
         } else {
            bits = ({ });
         }
      }
      comm = parse_comment(current_comment);
      if (!comm["ignore"]) {
         class_docs[name] = ({ 0, types,
                               parse_comment(current_comment) });
      }
   }
}
private void handle_inherit(mixed *bits) {
   int pos;
   string name;
   pos = member_array("inherit", bits);
   if (pos >= 0) {
      name = implode(map(bits[pos+1.. sizeof(bits)-2],
                         function(string str) {
                            if (str[0] == '\"') {
                               sscanf(str, "\"%s\"", str);
                               return str;
                            }
                            return "";
                         } ), "");
      inherits[name] = bits[0..pos-1];
   }
}
private void handle_function_definition(mixed *bits) {
   int pos;
   int end_pos;
   int new_pos;
   string name;
   string *type;
   mixed *args;
   mapping comm;
   pos = member_array("(", bits);
   if (pos > 0) {
      name = bits[pos-1];
      if (member_array(name, exclude_methods) == -1) {
         type = bits[0..pos-2];
         if (sizeof(type) == 0) {
            type = ({ "int" });
         }
         end_pos = member_array(")", bits, pos);
         args = ({ });
         if (end_pos > pos + 1) {
            pos++;
            while (member_array(",", bits, pos) != -1) {
               new_pos = member_array(",", bits, pos);
               args += ({ bits[pos..new_pos-2], bits[new_pos-1] });
               pos = new_pos + 1;
            }
            args += ({ bits[pos..end_pos -2], bits[end_pos-1] });
         }
         comm = parse_comment(current_comment);
         if (!comm["ignore"]) {
            if (member_array("private", type) != -1) {
               type -= ({ "private" });
               private_functions[name] = ({ type, args,
                                          comm });
            } else if (member_array("protected", type) != -1) {
               type -= ({ "protected" });
               protected_functions[name] = ({ type, args,
                                           comm });
            } else {
               type -= ({ "public" });
               public_functions[name] = ({ type, args,
                                           comm });
            }
         }
      }
      current_comment = 0;
   }
}
private string get_rest_of_line() {
   string value;
   int ch;
   int last_pos;
   value = "";
   ch = lookahead_character(1);
   while (ch == ' ' || ch == '\t') {
      pop_character(1);
      ch = lookahead_character(1);
   }
   do {
      last_pos = query_file_position();
      ch = next_character();
      if (ch == '\\') {
         ch = next_character();
         if (ch == '\r' && lookahead_character(1) == '\n') {
            ch = next_character();
         }
         ch = ' ';
      }
      if (last_pos != query_file_position()) {
         reset_eval_cost();
      }
      value += sprintf("%c", ch);
   } while (ch != '\n' && ch != '\r' && ch != EOF);
   return value;
}
private void handle_hash() {
   int i;
   string token;
   string name;
   string value;
   string *bits;
   string stuff;
   string inc_name;
   string curr_comm;
   mapping comm;
   token = get_word();
   switch (token) {
      case "define" :
      case "defin" :
         curr_comm = current_comment;
         value = get_rest_of_line();
         if (sscanf(value, "%s %s", name, value) == 2) {
            defines[name] = value;
            if (token == "define") {
               comm = parse_comment(curr_comm);
               if (!comm["ignore"]) {
                  define_docs[name] = comm;
               }
               current_comment = 0;
            }
         }
         break;
      case "include" :
         value = get_rest_of_line();
         if (value[0] == '\"') {
            bits = explode(file_name, "/");
            sscanf(value, "\"%s\"", name);
            stuff = read_file(implode(bits[0..<2], "/") +
                              "/" + name);
            if (stuff) {
               inc_name = "/" + implode(bits[0..<2], "/") +
                              "/" + name;
            }
         } else if (value[0] == '<') {
            sscanf(value, "<%s>", name);
         }
         if (name[0] == '/') {
            stuff = read_file(name);
            if (stuff) {
               inc_name = name;
            }
         }
         bits = MASTER_OB->define_include_dirs();
         while (!stuff && i < sizeof(bits)) {
            stuff = read_file(sprintf(bits[i], name));
            if (stuff) {
               stuff = replace_string(stuff, "
               stuff = replace_string(stuff, "class ", "clas ");
               stuff = replace_string(stuff, "#define ", "#defin ");
               inc_name = sprintf(bits[i], name);
            }
            i++;
         }
         if (inc_name) {
            inc_name = replace(inc_name, "
            if (inc_name[0] != '/') {
               inc_name = "/" + inc_name;
            }
         }
         if (stuff && !includes[inc_name]) {
            current_file = stuff + current_file[current_position..];
            current_position = 0;
            includes[inc_name] = unguarded( (: stat($(inc_name)) :) )[1];
         }
         break;
      default :
         skip_to_end_of_line();
         break;
   }
}
private void next_statement() {
   string token;
   string *bits;
   token = get_word();
   if (token[0] == '#') {
      return handle_hash();
   } else if (token == ";") {
      return ;
   } else if (token != "") {
      bits = get_statement(token);
      if (member_array("inherit", bits) != -1) {
         return handle_inherit(bits);
      } else if (bits[0] == "class" &&
                 member_array("(", bits) == -1) {
         return handle_class(bits);
      } else if (bits[sizeof(bits) - 1] == "{" &&
                 member_array("=", bits) == -1) {
         return handle_function_definition(bits);
      } else {
         return ;
      }
   }
}
void load_file() {
   unguarded((: restore_object(SAVE_DIR + replace_string(file_name, "/", ".")) :));
   if (!includes) {
      includes = ([ ]);
   }
   if (!class_docs) {
      class_docs = ([ ]);
   }
}
void save_file() {
   unguarded((: save_object(SAVE_DIR + replace_string(file_name, "/", ".")) :));
}
void parse_file(string name, function func, int only_load) {
   int curr_change;
   int my_change;
   string my_name;
   int reload;
   setup();
   file_name = name;
   load_file();
   if (!only_load) {
      if (sizeof(unguarded( (: stat($(name)) :) )) > 1) {
         curr_change = unguarded( (: stat($(name)) :) )[1];
         my_name = file_name(this_object());
         sscanf(my_name, "%s#%*s", my_name);
         my_name += ".c";
         my_change = unguarded( (: stat($(my_name)) :) )[1];
         reload = curr_change > last_changed;
         if (my_change > last_changed &&
             my_change > curr_change) {
            curr_change = my_change;
            reload = 1;
         }
         if (!reload) {
            foreach (my_name, my_change in includes) {
               if ( unguarded( (: stat($(my_name)) :) )[1] != my_change) {
                  reload = 1;
                  break;
               }
            }
         }
         if (reload) {
            setup();
            num_failed_tries = 0;
            file_name = name;
            changed = 1;
            last_changed = curr_change;
            current_file = read_file(name);
            current_position = 0;
            if (catch(do_parse_file(func))) {
               evaluate(func);
            }
         } else {
            if (num_failed_tries) {
               num_failed_tries = 0;
               save_file();
            }
            call_out( (: evaluate($1) :), 2, func);
         }
      } else {
         num_failed_tries++;
         save_file();
         call_out( (: evaluate($1) :), 2, func);
      }
   } else {
      call_out( (: evaluate($1) :), 2, func);
   }
}
private void do_parse_file(function func) {
   int num;
   if (unguarded( (: stat(file_name) :))[1] > last_changed) {
      return parse_file(file_name, func, 0);
   }
   num = 0;
   while (lookahead_character(1) != EOF && num < 2) {
      next_statement();
      num++;
   }
   if (lookahead_character(1) == EOF) {
      save_file();
      call_out((: evaluate($1) :), 2, func);
   } else {
      call_out((: do_parse_file($1) :), 2, func);
   }
}
mapping query_inherits() { return inherits; }
mapping query_private_functions() { return private_functions; }
mapping query_public_functions() { return public_functions; }
mapping query_protected_functions() { return protected_functions; }
mapping query_main_docs() {
   if (main_docs) {
      return main_docs;
   }
   return ([ ]);
}
string query_file_name() { return file_name; }
mapping query_defines() { return defines; }
int query_changed() { return changed; }
int query_num_failed_tries() { return num_failed_tries; }
string *query_includes() { return keys(includes); }
mapping query_define_docs() { return define_docs; }
mapping query_class_docs() { return class_docs; }
void dest_me() {
   destruct(this_object());
}

==================================================
FILE: handlers/autodoc/autodoc_handler.c
==================================================

#include <autodoc.h>
#define MAIN_FILE 0
#define INDEX_FILE 1
#define SAVE_FILE (SAVE_DIR "main_rubbish")
string *files;
int file_pos;
int something_changed;
int last_created_index;
nosave function *filters;
nosave int call_id;
nosave mapping summary_map;
nosave mixed *extra_indexes;
mapping help_map;
private void create_nroff_file(object ob, int type);
private void create_html_file(object ob, int type);
private void after_thingy(int no_index);
private void start_processing();
private void do_parse_next_file();
private void create_index();
private void add_to_index(object ob);
private void load();
private void save();
string *query_files();
int remove_file(string fname);
void create() {
   seteuid(getuid());
   filters = ({ (: create_nroff_file($1, $2) :),
                (: create_html_file($1, $2) :) });
   file_pos = 0;
   something_changed = 0;
   files = ({ });
   load();
   do_parse_next_file();
}
private void create_nroff_file(mixed ob, int type) {
   string fname;
   mixed *stuff;
   mixed *index_stuff;
   int i;
   if (type == MAIN_FILE) {
      fname = replace(ob->query_file_name(), "/", ".");
      if (fname[0] == '.') {
         fname = fname[1..];
      }
      rm(NROFF_DOC_DIR + fname);
      AUTODOC_NROFF->create_nroff_file(ob, NROFF_DOC_DIR + fname);
   } else if (type == INDEX_FILE) {
      index_stuff = ob;
      stuff = map(query_files(), function (string name) {
           string *bits;
           bits = explode(name, "/");
           return ({ bits[sizeof(bits)-1], name });
        } );
      stuff = unique_array(index_stuff + stuff, (: lower_case($1[0])[0] :));
      for (i = 0; i < sizeof(stuff); i++) {
         fname = NROFF_DOC_DIR + "index_" + lower_case(stuff[i][0][0][0..0]);
         AUTODOC_NROFF->create_nroff_index_file(stuff[i], fname);
      }
   }
}
private void create_html_file(mixed ob, int type) {
   string fname;
   mixed *stuff;
   mixed *index_stuff;
   int i;
   mapping chars;
   if (type == MAIN_FILE) {
      fname = replace(ob->query_file_name(), "/", ".");
      if (fname[0] == '.') {
         fname = fname[1..];
      }
      fname += ".html";
      rm(HTML_DOC_DIR + fname);
      AUTODOC_HTML->create_html_file(ob, HTML_DOC_DIR + fname);
   } else if (type == INDEX_FILE) {
      index_stuff = ob;
      stuff = map(query_files(), function (string name) {
           string *bits;
           bits = explode(name, "/");
           return ({ bits[sizeof(bits)-1], name, "", summary_map[name] });
        } );
      stuff = unique_array(index_stuff + stuff, (: lower_case($1[0])[0] :));
      chars = ([ ]);
      for (i = 0; i < sizeof(stuff); i++) {
         fname = "index_" + lower_case(stuff[i][0][0][0..0]) + ".html";
         rm(HTML_DOC_DIR + fname);
         AUTODOC_HTML->create_html_index_file(stuff[i], stuff[i][0][0][0..0],
                                       HTML_DOC_DIR + fname);
         reset_eval_cost();
         chars[capitalize(stuff[i][0][0][0..0])] =  fname;
      }
      fname = HTML_DOC_DIR;
      AUTODOC_HTML->create_main_index(chars, fname);
   }
}
private void after_thingy(int no_index) {
   int i;
   if (no_index) {
      printf("Finished recreating the documentation for %O\n",
              previous_object()->query_file_name(),
             previous_object());
   }
   if (previous_object()->query_changed()) {
      something_changed = 1;
   }
   if (previous_object()->query_num_failed_tries() > 1) {
      remove_file(files[file_pos - 1]);
   } else if (previous_object()->query_changed() || no_index) {
      for (i = 0; i < sizeof(filters); i++) {
         call_out((: evaluate($1, $2, $3) :), 0, filters[i],
                  previous_object(), MAIN_FILE);
      }
   }
   call_out((: $1->dest_me() :), 20, previous_object());
   save();
}
private void do_parse_next_file() {
   call_id = call_out((: start_processing() :), 60);
   if (file_pos >= sizeof(files)) {
      file_pos = 0;
   }
   new(AUTODOC_FILE)->parse_file(files[file_pos++], (: after_thingy(0) :));
}
private void start_processing() {
   if (sizeof(files) == 0) {
      return ;
   }
   if (last_created_index + SAVE_INDEX_DELAY < time()) {
      if (something_changed) {
         call_out( (: create_index() :), 2);
      }
      something_changed = 0;
      save();
   }
   call_id = call_out((: do_parse_next_file() :), 360);
}
private string query_short_args_def(mixed *args) {
   string ret;
   int i;
   ret = "";
   for (i = 0; i < sizeof(args); i += 2) {
      if (i != 0) {
         ret += ", ";
      }
      ret += implode(args[AUTO_ARGS_TYPE], " ");
   }
   return "(" + ret + ")";
}
private string *process_stuff(string name,
                              string fname,
                              string fn,
                              mapping docs) {
   string blue;
   int i;
   int end;
   mixed *ret;
   mapping fluff;
   if (name != "create" && name != "setup" && name != "init") {
      if (help_map[name]) {
         help_map[name] += ({ fn });
      } else {
         help_map[name] = ({ fn });
      }
   }
   if (docs[name]) {
      if (arrayp(docs[name])) {
         fluff = docs[name][AUTO_DOCS];
         ret =  ({ name, fname, query_short_args_def(docs[name][AUTO_ARGS]) });
      } else {
         ret = ({ name, fname, "" });
         fluff = docs[name];
      }
   } else {
      ret = ({ name, fname, "" });
      if (mapp(docs)) {
         fluff = docs;
      } else {
         fluff = ([ ]);
      }
   }
   if (fluff["main"]) {
      blue = implode(fluff["main"], "\n");
      end = strlen(blue);
      i = strsrch(blue, ".");
      if (i > 0) {
         end = i;
      }
      i = strsrch(blue, "!");
      if (i > 0 && i < end) {
         end = i;
      }
      i = strsrch(blue, "?");
      if (i > 0 && i < end) {
         end = i;
      }
      blue = blue[0..end];
   }
   ret += ({ blue });
   if (fluff["index"]) {
      foreach (blue in fluff["index"]) {
         blue = replace(blue, ({ " ", "", "\n", "" }));
         if (help_map[blue]) {
            help_map[blue] += ({ fn });
         } else {
            help_map[blue] = ({ fn });
         }
         extra_indexes += ({ ({ blue, fname, "", ret[AUTO_INDEX_SUMMARY] }) });
      }
   }
   return ret;
}
private void create_index() {
   int i;
   mixed *index_stuff;
   mixed *rabbit;
   string fname;
   string fn;
   string *bits;
   object parse;
   index_stuff = ({ });
   help_map = ([ ]);
   extra_indexes = ({ });
   summary_map = ([ ]);
   parse = clone_object(AUTODOC_FILE);
   for (i = 0; i < sizeof(files); i++) {
      parse->parse_file(files[i], 0, 1);
      fname = parse->query_file_name();
      if (fname) {
         fn = replace(fname, "/", ".");
         if (fn[0] == '.') {
            fn = fn[1..];
         }
         fn = NROFF_DOC_DIR + fn;
         bits = explode(fname[0..strlen(fname)-3], "/");
         rabbit = process_stuff(bits[sizeof(bits) - 1], "", fn,
                                parse->query_main_docs());
         if (rabbit[AUTO_INDEX_SUMMARY]) {
            summary_map[fname] = rabbit[AUTO_INDEX_SUMMARY];
         } else {
            map_delete(summary_map, fname);
         }
         index_stuff += map(keys(parse->query_public_functions()),
                            (: process_stuff($1, $(fname), $(fn),
                               $(parse)->query_public_functions()) :) );
         index_stuff += map(keys(parse->query_protected_functions()),
                            (: process_stuff($1, $(fname), $(fn),
                               $(parse)->query_protected_functions()) :) );
         index_stuff += map(keys(parse->query_class_docs()),
                            (: process_stuff($1, $(fname), $(fn),
                               $(parse)->query_class_docs()) :) );
         if (sscanf(fname, "%*s.h") == 1) {
            index_stuff += map(keys(parse->query_define_docs()),
                               (: process_stuff($1, $(fname), $(fn),
                               $(parse)->query_define_docs()) :) );
         }
      }
      reset_eval_cost();
   }
   index_stuff += extra_indexes;
   extra_indexes = ({ });
   for (i = 0; i < sizeof(filters); i++) {
      reset_eval_cost();
      catch(evaluate(filters[i], index_stuff, INDEX_FILE));
   }
   summary_map = ([ ]);
   last_created_index = time();
   save();
}
int recreate_documentation(string fname) {
   object ob;
   if (member_array(fname, files) != -1) {
      ob = clone_object(AUTODOC_FILE);
      ob->parse_file(fname, (: after_thingy(1) :));
      return 1;
   }
   return 0;
}
void recreate_indexes() {
   unguarded( (: create_index() :));
}
int add_file(string fname) {
   fname = "/" + implode(explode(fname, "/") - ({ "" }), "/");
   if (member_array(fname, files) == -1) {
      if (sizeof(unguarded( (: stat($(fname)) :) ))) {
         files += ({ fname });
         save();
         if (sizeof(files) == 1) {
            start_processing();
         } else {
            call_out((: recreate_documentation($1) :), random(60), fname);
         }
         return 1;
      }
   }
   return 0;
}
int remove_file(string fname) {
   string fn;
   string dfn;
   string *our_files;
   if (member_array(fname, files) != -1) {
      files -= ({ fname });
      file_pos = 0;
      fn = HTML_DOC_DIR + replace(fname, "/", ".");
      unguarded((: rm($(fn)) :));
      fn = NROFF_DOC_DIR + replace(fname, "/", ".");
      unguarded((: rm($(fn)) :));
      fn = NROFF_DOC_SINGLE + fname[0..<3] + "/";
      our_files = get_dir(fn);
      if (sizeof(our_files)) {
         foreach (dfn in our_files) {
            dfn =  fn + dfn;
            unguarded( (: rm($(dfn)) :) );
         }
      }
      if (file_size(fn[0..<2]) != -1) {
         unguarded((: rm($(fn[0..<2])) :));
      }
      save();
      if (!sizeof(files)) {
         remove_call_out(call_id);
      }
      return 1;
   }
   return 0;
}
private void load() {
   unguarded( (: restore_object( SAVE_FILE ) :) );
}
private void save() {
   unguarded( (: save_object( SAVE_FILE ) :) );
}
string *query_files() { return files; }
mapping query_help_map() { return help_map; }
string query_help_on(string file, string func) {
   if (file[0] == '/') {
      file = file[1..];
   }
   if (sscanf(file, "%*s.c") == 1) {
      file = file[0..<3];
   }
   file = NROFF_DOC_SINGLE + file + "/" + func;
   if (file_size(file) > 0) {
      return file;
   }
   return 0;
}
mapping query_summary_map() { return summary_map; }
int is_autodoc_file(string name) {
   return member_array(name, files) != -1;
}

==================================================
FILE: handlers/autodoc/autodoc_html.c
==================================================

#include <autodoc.h>
#include <config.h>
private string query_func_def(mixed *stuff, string func);
private string query_methods(string *funcs, function data,
                           int prot);
private string query_method_description(mapping docs);
private string create_href(string str);
private string query_method_summary(string *funcs, object file);
private string query_defines(string *defs, mapping docs);
private string query_class_summary(mapping classes);
private string query_classes(mapping classes);
private string query_class_def(mixed *stuff, string name);
private string query_class_description(mapping docs);
void create() {
   seteuid(getuid());
}
void create_html_file(object file, string output) {
   int i;
   mapping stuff;
   string *pub_funcs;
   string *pro_funcs;
   string *defs;
   string *bits;
   string name;
   string bing;
   bits = explode(file->query_file_name(), "/");
   name = bits[sizeof(bits)-1];
   bing = "<html><head><title>";
   bing += "File " + name +
           "\n</title></head><body bgcolor=\"#ffffff\" TEXT=\"#000030\" LINK=\"#4a529c\" VLINK=\"#b57339\">";
   bing += "[ <a href=\"index.html\">Package Index</a></code> | ";
   bing += "<a href=\"index_std.html\">Mudlib Index</a></code> | ";
   bing += "<a href=\"index_eff.html\">Effect Index</a></code> ]<br>";
   stuff = file->query_main_docs();
   if (stuff["main"]) {
      bing += "<h2>File " + file->query_file_name() +
                         "</h2>";
      bing += implode(stuff["main"], " ");
      if (stuff["see"]) {
         bing += "<p><b>See also:</b><br>" +
                            query_multiple_short(
                            map(stuff["see"], (: create_href($1) :)));
      }
      if (stuff["author"]) {
         bing += "<p>Written by " +
                    query_multiple_short(stuff["author"]);
      }
      if (stuff["started"]) {
         bing += "<p>Started " +
                    query_multiple_short(stuff["started"]);
      }
      if (stuff["example"]) {
         if (sizeof(stuff["example"]) > 1) {
            for (i = 0; i < sizeof(stuff["example"]); i++) {
               bing += "<h3>Example " + (i + 1) + "</h3>\n";
               bing += "<pre>"+stuff["example"][i]+"</pre>\n";
            }
         } else {
            bing +=  "<h3>Example</h3>\n<pre>" + stuff["example"][0] +
                             "</pre>\n";
         }
      }
      if (stuff["changed"]) {
         bing += "<h3>Change history</h3>\n<dl>" +
                            implode(map(stuff["changed"], function (string str) {
                   string start;
                   string rest;
                   if (sscanf(str, "%s\n%s", start, rest) == 2) {
                      return "<dt>" + start + "<dd>" + rest;
                   }
                   return "<dd>" + str;
             } ), "\n") + "</dl>\n";
      }
   }
   if (sizeof(file->query_inherits())) {
      bing += "<hr><h2>Inherits</h2>\n";
      bing += "This class inherits the following classes " +
                         query_multiple_short(
               map(keys(file->query_inherits()), (: create_href :)));
   }
   if (sizeof(file->query_includes())) {
      bing += "<hr><h2>Includes</h2>\n";
      bing += "This class includes the following files " +
                         query_multiple_short(
               map(file->query_includes(), (: create_href :)));
   }
   if (sizeof(file->query_class_docs())) {
       bing += query_class_summary(file->query_class_docs());
   }
   pub_funcs = keys(file->query_public_functions());
   pro_funcs = keys(file->query_protected_functions());
   bing += query_method_summary(pub_funcs + pro_funcs, file);
   if (sizeof(pub_funcs)) {
      bing += "<hr><h2>Public Functions</h2>\n";
      bing += "These are functions that everyone can "
                         "access.<p><dl>\n.";
      bing += query_methods(pub_funcs, (: $(file)->query_public_functions()[$1] :),
                    0);
      bing += "</dl>\n";
   }
   if (sizeof(pro_funcs)) {
      bing += "<hr><h2>Protected Functions</h2>\n";
      bing += "These are functions that only "
                         "objects inheriting the class can access.<p>\n";
      bing += query_methods(pro_funcs, (: $(file)->query_protected_functions()[$1] :),
                    1);
      bing +=  "\n";
   }
   if (sscanf(name, "%*s.h") == 1 &&
       sizeof(file->query_define_docs())) {
      defs = sort_array(keys(file->query_define_docs()),
                        (: strcasecmp($1, $2) :));
      bing +=  "<hr><h2>Defines</h2>\n";
      query_defines(defs, file->query_define_docs());
      bing = "";
   }
   if (sizeof(file->query_class_docs())) {
      bing += "<hr><h2>Classes</h2>\n";
      bing += "These are nice data types for dealing with...  Data!"
                         "<p>\n";
      bing += query_classes(file->query_class_docs());
   }
   write_file(output, bing, 1);
   bing = "/www/footer"->www_function(output);
   write_file(output, bing + "</body></html>");
}
void create_html_index_file(string *index, string letter, string output) {
   int i;
   string name;
   string bing;
   bing = "<html><head><title>\nIndex of " + letter +
                      "\n</title></head><body bgcolor=\"#ffffff\" TEXT=\"#000030\" LINK=\"#4a529c\" VLINK=\"#b57339\">\n";
   bing += "<img align=left src=\"" + CONFIG_EXTERNAL_WEB_ADDRESS +
                       "pics/dw4.gif\">\n"
                      "<p align=right><code><a href=\"index.html\">"
                      "Main Index</a></code></p>\n"
                      "<h2>Index of " + letter + "</h2>\n"
                      "<h3><i>Letters can change the world, remove the l "
                      "from world and you have word</i></h3>\n"
                      "<br clear=both>\n"
                      "<hr><dl>\n";
   index = sort_array(index, (: strcasecmp($1[0], $2[0]) ? strcasecmp($1[0], $2[0]) :
                                        strcasecmp($1[1], $2[1]) :) );
   for (i = 0; i < sizeof(index); i++) {
      name = replace(index[i][AUTO_INDEX_FILE_NAME], "/", ".");
      if (name[0] == '.') {
         name = name[1..];
      }
      if (sscanf(index[i][AUTO_INDEX_NAME], "%*s.%*s") == 2) {
         bing += "<dt><img src=\"images/magenta-ball-small.gif\" "
                            "height=6 width=6 alt=\" . \"><b><a href=\"" +
                            name + ".html\">" + index[i][AUTO_INDEX_NAME] +
                            "</a></b>.\n";
      } else {
         bing += "<dt><img src=\"images/magenta-ball-small.gif\" "
                            "height=6 width=6 alt=\" . \"><b><a href=\"" +
                            name + ".html#" + index[i][AUTO_INDEX_NAME] +
                            "\">" + index[i][AUTO_INDEX_NAME] + "</a></b>" +
                            index[i][AUTO_INDEX_ARGS] +
                            "; <a href=\"" + name + ".html\">" +
                            index[i][AUTO_INDEX_FILE_NAME] + "</a>\n";
      }
      if (index[i][AUTO_INDEX_SUMMARY]) {
         bing += "<dd>"+index[i][AUTO_INDEX_SUMMARY]+"\n";
      }
      reset_eval_cost();
   }
   write_file(output, bing + "</dl>", 1);
   write_file(output, "/www/footer"->www_function(output) + "</body></html>");
}
private string bing_cre;
private string bing_eff;
private string bing_index;
void create_main_index(mapping chars, string output_dir) {
   int i;
   string output_index;
   string output_eff;
   string output_cre;
   string *files;
   mixed *stuff;
   string str;
   string fname;
   string *index;
   mapping summaries;
   function write_all;
   string bing_file;
   string fluff;
   summaries = AUTODOC_HANDLER->query_summary_map();
   output_index = output_dir + "index_std.html";
   output_eff = output_dir + "index_eff.html";
   output_cre = output_dir + "index_cre.html";
   bing_cre = "";
   bing_eff = "";
   bing_file = "";
   bing_index = "";
   rm (output_eff);
   rm (output_index);
   rm (output_cre);
   write_all = (: bing_eff += $1,
                  bing_cre += $1,
                  bing_index += $1 :);
   evaluate(write_all, "<html><head><title>\n");
   evaluate(write_all, "" + mud_name() + " autodoc index\n</title></head>\n"
                            "<body bgcolor=\"#ffffff\" TEXT=\"#000030\" "
                             "LINK=\"#4a529c\" VLINK=\"#b57339\">\n");
   bing_index += "<img align=left src=\"" + CONFIG_EXTERNAL_WEB_ADDRESS +
                      "/pics/dw4.gif\">\n"
                      "<h2>" + mud_name() + " Documentation</h2>\n"
                      "<h3><i>Where cabbages evaporate in the sun</i></h3>\n"
                      "<br clear=both>\n";
   bing_eff += "<img align=left src=\"" + CONFIG_EXTERNAL_WEB_ADDRESS +
                      "/pics/dw4.gif\">\n"
                      "<h2>" + mud_name() + " Effect Documentation</h2>\n"
                      "<h3><i>Where your consequences are vanquished</i></h3>\n"
                      "<br clear=both>\n";
   bing_cre += "<img align=left src=\"" + CONFIG_EXTERNAL_WEB_ADDRESS +
                      "pics/dw4.gif\">\n"
                      "<h2>" + mud_name() + " Creator Documentation</h2>\n"
                      "<h3><i>Blue fluff?  No red and scruffy!</i></h3>\n"
                      "<br clear=both>\n";
   evaluate(write_all, "<h2>Function index</h2>\n");
   files = AUTODOC_HANDLER->query_files();
   files = sort_array(files, (: strcasecmp :) );
   index = sort_array(keys(chars), (: strcasecmp :) );
   for (i = 0; i < sizeof(index); i++) {
      if (i > 0) {
         evaluate(write_all, ", ");
      }
      evaluate(write_all, "<a href=\"" + chars[index[i]] + "\">" + index[i] +
                         "</a>\n");
   }
   bing_index += ", <a href=\"index_eff.html\">Effects</a>";
   bing_index += ", <a href=\"index_cre.html\">Creator</a>";
   bing_eff += ", <a href=\"index.html\">Main</a>";
   bing_eff += ", <a href=\"index_cre.html\">Creator</a>";
   bing_cre += ", <a href=\"index.html\">Main</a>";
   bing_cre += ", <a href=\"index_eff.html\">Effects</a>";
   evaluate(write_all, "<hr><h2>Class index</h2>\n");
   evaluate(write_all, "<dl>\n");
   stuff = unique_array(files, (: $1[0..strsrch($1, "/", -1)] :));
   for (i = 0; i < sizeof(stuff); i++) {
      str = stuff[i][0][0..strsrch(stuff[i][0], "/", -1)];
      if (str[0..12] == "/std/effects/") {
         bing_eff += "<dt><img src=\"images/cyan-ball.gif\" height=12 "
                            "width=12><b><a href=\"#" + str + "\">"+
                            str + "</a></b>\n";
      } else if (str[0..2] == "/w/") {
         bing_cre += "<dt><img src=\"images/cyan-ball.gif\" "
                            "height=12 "
                            "width=12><b><a href=\"#" + str + "\">"+
                            str + "</a></b>\n";
      } else {
         bing_index += "<dt><img src=\"images/cyan-ball.gif\" height=12 "
                            "width=12><b><a href=\"#" + str + "\">"+
                            str + "</a></b>\n";
      }
   }
   evaluate(write_all, "</dl>\n");
   for (i = 0; i < sizeof(stuff); i++) {
      fluff = "";
      str = stuff[i][0][0..strsrch(stuff[i][0], "/", -1)];
      fluff += "<h2><a name=\"" + str + "\">" + str + "</a></h2>\n<dl>\n";
      reset_eval_cost();
      foreach (str in stuff[i]) {
         fname = replace(str, "/", ".")[1..];
         fluff += "<dt><img src=\"images/cyan-ball-small.gif\" "
                            "height=6 width=6><a href=\"" + fname + ".html\">" +
                            str[strsrch(str, "/", -1) + 1..] + "</a>\n";
         if (summaries[str]) {
            fluff += "<dd>" + summaries[str] + "\n";
         }
      }
      fluff += "</dl>\n";
      if (stuff[i][0][0..12] == "/std/effects/") {
         bing_eff += fluff;
      } else if (stuff[i][0][0..2] == "/w/") {
         bing_cre += fluff;
      } else {
         bing_index += fluff;
      }
   }
   write_file(output_eff, bing_eff, 1);
   write_file(output_eff,
              "/www/footer"->www_function(output_eff) + "</body></html");
   write_file(output_index, bing_index, 1);
   write_file(output_index,
              "/www/footer"->www_function(output_index) + "</body></html");
   write_file(output_cre, bing_cre, 1);
   write_file(output_cre,
              "/www/footer"->www_function(output_cre) + "</body></html");
}
private string query_classes(mapping classes) {
   string name;
   string *names;
   string bing;
   names = sort_array(keys(classes), (: strcasecmp :) );
   bing = "<dl>\n";
   foreach (name in names) {
      reset_eval_cost();
      bing += "<dt><a name=\"class_" + name + "\">\n";
      bing += "<img src=\"images/cyan-ball.gif\" width=12 "
                         "height=12 alt=\" * \">";
      bing += "<b>" + name +
              "</b></a><pre>\n" +
              query_class_def(classes[name], name) + "\n</pre>";
      if (classes[name][AUTO_CLASS_DOCS]["main"]) {
         bing += query_class_description(classes[name][AUTO_CLASS_DOCS]);
      }
      bing += "\n";
   }
   return bing + "</dl>\n";
}
private string query_methods(string *funcs, function data,
                           int prot) {
   int i;
   mixed *stuff;
   string bing;
   funcs = sort_array(funcs, (: strcasecmp($1, $2) :));
   bing = "";
   for (i = 0; i < sizeof(funcs); i++) {
      reset_eval_cost();
      stuff = evaluate(data, funcs[i]);
      bing += "<dt><a name=\"" + funcs[i] + "\">\n";
      if (prot) {
        bing += "<img src=\"images/magenta-ball.gif\" width=12 "
                           "height=12 alt=\" * \">";
      } else {
        bing += "<img src=\"images/cyan-ball.gif\" width=12 "
                           "height=12 alt=\" * \">";
      }
      bing += "<b>" + funcs[i] +
                         "</b></a><pre>\n" +
                         query_func_def(stuff, funcs[i]) +
                         "\n</pre>";
      if (stuff[AUTO_DOCS]["main"]) {
         bing += query_method_description(stuff[AUTO_DOCS]);
      }
      bing += "\n";
   }
   return bing;
}
private string query_func_def(mixed *stuff, string func) {
   string ret;
   int i;
   int pad;
   ret = implode(stuff[AUTO_TYPE], " ") + " " + func+"(";
   pad = strlen(ret);
   for (i = 0; i < sizeof(stuff[AUTO_ARGS]); i += 2) {
      if (i) {
         ret += sprintf(",\n%-"+pad+"s", "");
      }
      ret += implode(stuff[AUTO_ARGS][i + AUTO_ARGS_TYPE], " ") + " " +
             stuff[AUTO_ARGS][i + AUTO_ARGS_NAME];
   }
   ret += ")";
   return ret;
}
private string query_class_def(mixed *stuff, string name) {
   string ret;
   int pad;
   int i;
   ret = "class " + name + " {\n";
   pad = strlen(ret);
   for (i = 0; i < sizeof(stuff[AUTO_CLASS_MEMBERS]); i++) {
      ret += sprintf("%-" + pad + "s", "");
      ret += implode(stuff[AUTO_CLASS_MEMBERS][i][AUTO_CLASS_TYPE], " ") +
             " " + stuff[AUTO_CLASS_MEMBERS][i][AUTO_CLASS_NAME] + ";\n";
   }
   ret += "}\n";
   return ret;
}
private string query_method_description(mapping docs) {
   int i;
   string name;
   string desc;
   string bing;
   bing = "";
   if (docs["main"]) {
      bing += "<dd>" + implode(docs["main"], " ")
                         +"<p>\n";
   }
   if (docs["param"] || docs["return"] || docs["see"] || docs["example"]) {
      bing += "<dd><dl>\n";
   }
   if (docs["param"]) {
      bing += "<dt><b>Parameters:</b>\n";
      for (i = 0; i < sizeof(docs["param"]); i++) {
         if (sscanf(docs["param"][i], "%s %s", name, desc) == 2) {
            bing += "<dd>" + name + " - " + (desc) + "\n";
         }
      }
   }
   if (docs["return"]) {
      bing += "<dt><b>Returns:</b>\n<dd>" + implode(docs["return"], " ") +
                         "\n";
   }
   if (docs["see"]) {
      bing += "<dt><b>See also:</b>\n<dd>" +
                         query_multiple_short(
                         map(docs["see"], (: create_href($1) :)));
   }
   if (docs["example"]) {
      bing += "<dt><b>Example:</b>\n<dd><pre>" +
                 implode(docs["example"], "</pre><dd><pre>\n") +
                        "</pre>";
   }
   if (docs["param"] || docs["return"] || docs["see"] || docs["example"]) {
      bing += "</dl>\n";
   }
   return bing;
}
private string query_class_description(mapping docs) {
   int i;
   string name;
   string desc;
   string bing;
   bing = "";
   if (docs["main"]) {
      bing += "<dd>" + implode(docs["main"], " ")
                         +"<p>\n";
   }
   if (docs["member"] || docs["see"]) {
      bing += "<dl>\n";
   }
   if (docs["member"]) {
      bing += "<dt><b>Members:</b>\n";
      for (i = 0; i < sizeof(docs["member"]); i++) {
         if (sscanf(docs["member"][i], "%s %s", name, desc) == 2) {
            bing += "<dd>" + name + " - " +
                               (desc) + "\n";
         }
      }
   }
   if (docs["see"]) {
      bing += "<dt><b>See also:</b>\n<dd>" +
                         query_multiple_short(
                         map(docs["see"], (: create_href($1) :)));
   }
   if (docs["member"] || docs["see"]) {
      bing += "</dl>\n";
   }
   return bing;
}
private string create_href(string str) {
   string name;
   string ref_name;
   string func;
   if (sscanf(str, "%s#%s", name, func) == 2) {
      ref_name = replace(name, "/", ".");
      if (ref_name[0] == '.') {
         ref_name = ref_name[1..];
      }
      return "<a href=\"" + ref_name + ".c.html#" + func + "\">" +
             name + "->" + func + "()</a>";
   } else if (sscanf(str, "%s->%s", name, func) == 2) {
      sscanf(func, "%s(%*s)", func);
      ref_name = replace(name, "/", ".");
      if (ref_name[0] == '.') {
         ref_name = ref_name[1..];
      }
      return "<a href=\"" + ref_name + ".c.html#" + func + "\">" + str + "</a>";
   } else if (sscanf(str, "%s()", func) == 1) {
      return "<a href=\"#" + func + "\">" + str + "</a>";
   } else if (str[0..4] == "http:") {
      return "<a href=\"" + str + "\">" + str + "</a>";
   } else {
      ref_name = replace(str, "/", ".");
      if (ref_name[0] == '.') {
         ref_name = ref_name[1..];
      }
      if (sscanf(str, "%*s.%*s") != 2) {
         ref_name += ".c";
         str += ".c";
      }
      if (member_array(str, AUTODOC_HANDLER->query_files()) != -1) {
         return "<a href=\"" + ref_name + ".html\">" + str + "</a>";
      }
      return str;
   }
}
private string query_short_args_def(mixed *args) {
   string ret;
   int i;
   ret = "";
   for (i = 0; i < sizeof(args); i += 2) {
      if (i != 0) {
         ret += ", ";
      }
      ret += implode(args[i + AUTO_ARGS_TYPE], " ");
   }
   return "(" + ret + ")";
}
private string query_short_desc(mapping docs) {
   mixed main;
   int pos;
   int tmp_pos;
   main = docs["main"];
   if (!main) {
      return 0;
   }
   main = implode(main, " ");
   pos = strlen(main);
   tmp_pos = strsrch(main, ".");
   if (tmp_pos < pos && tmp_pos != -1) {
      pos = tmp_pos;
   }
   tmp_pos = strsrch(main, "?");
   if (tmp_pos < pos && tmp_pos != -1) {
      pos = tmp_pos;
   }
   tmp_pos = strsrch(main, "!");
   if (tmp_pos < pos && tmp_pos != -1) {
      pos = tmp_pos;
   }
   return main[0..pos];
}
private string query_class_summary(mapping classes) {
   string *names;
   string name;
   string short_desc;
   string bing;
   names = sort_array(keys(classes), (: strcasecmp :));
   bing = "<hr><h2>Class Index</h2>\n";
   bing += "<dl>";
   foreach (name in names) {
      bing += "<dt><img src=\"images/cyan-ball-small.gif\" "
                         "height=6 width=6 alt=\" o \">\n";
      bing += "<a href=\"#class_" + name + "\"><b>" + name +
                         "</b></a>\n";
      short_desc = query_short_desc(classes[name][AUTO_CLASS_DOCS]);
      if (short_desc) {
         bing += "<dd>" + short_desc + "\n";
      }
   }
   bing += "</dl>";
   return bing;
}
private string query_method_summary(string *funcs,
                                  object file) {
   int i;
   mixed *stuff;
   string short_desc;
   int prot;
   string bing;
   bing = "";
   if (sizeof(funcs)) {
      bing += "<hr><h2>Method index</h2>\n<dl>";
      funcs = sort_array(funcs, (: strcasecmp :) );
      for (i = 0; i < sizeof(funcs); i++) {
         if (file->query_public_functions()[funcs[i]]) {
            stuff = file->query_public_functions()[funcs[i]];
            prot = 0;
         } else if (file->query_protected_functions()[funcs[i]]) {
            stuff = file->query_protected_functions()[funcs[i]];
            prot = 1;
         }
         if (prot) {
           bing += "<dt><img src=\"images/magenta-ball-small.gif\" "
                              "height=6 width=6 alt=\" o \">\n";
         } else {
           bing += "<dt><img src=\"images/cyan-ball-small.gif\" "
                              "height=6 width=6 alt=\" o \">\n";
         }
         bing += "<a href=\"#" + funcs[i] + "\"><b>" + funcs[i] +
                            "</b></a>" + query_short_args_def(stuff[AUTO_ARGS])
;
         short_desc = query_short_desc(stuff[AUTO_DOCS]);
         if (short_desc) {
            bing += "<dd>" + short_desc + "\n";
         }
      }
      bing += "</dl>";
   }
   return bing;
}
private string query_defines(string *defs, mapping docs) {
   int i;
   string bing;
   bing = "";
   for (i = 0; i < sizeof(defs); i++) {
      bing +=  "<dt><a name=\"" + defs[i] + "\">\n";
      bing += "<img src=\"images/red-ball.gif\" width=12 "
                         "height=12 alt=\" * \"><b>" + defs[i] + "</b></a>\n";
      if (docs[defs[i]]["main"]) {
         bing += query_method_description(docs[defs[i]]);
      }
   }
   return bing;
}

==================================================
FILE: handlers/autodoc/autodoc_nroff.c
==================================================

#include <autodoc.h>
private void write_single_description(string func, mixed *stuff,
                                      string output, string fn);
private string query_methods(string *funcs, function data,
                           string base_single, string fn);
private string query_func_def(mixed *stuff, string func);
private string query_method_description(mapping docs);
private string parse_string(string inp);
string convert_html(string text, int depth, int preformat, int edge_width);
private string query_defines(mapping defines);
private string query_class_def(mixed *stuff, string name);
private string query_class_description(mapping docs);
private void write_single_class_description(string func, mixed *stuff,
                                            string output, string fn);
private string query_classes(string base_single,
                           mapping classes,
                           string fn);
void create() {
   seteuid(getuid());
}
void create_nroff_file(object file, string output) {
   mapping stuff;
   string *funcs;
   string *bits;
   string name;
   string base_single;
   string *files;
   string ret;
   int pos;
   bits = explode(file->query_file_name(), "/");
   name = bits[sizeof(bits)-1];
   ret = "";
   ret += ".DT\n";
   ret += name + "\n" + mud_name() + " autodoc help\n" + name + "\n\n";
   stuff = file->query_main_docs();
   if (stuff["main"]) {
      ret += ".SH Description\n";
      ret += convert_html(implode(stuff["main"], " "), 5, 0, 5);
      ret += ".SP 10 5\n";
      if (stuff["author"]) {
         ret += "\n\nWritten by " +
                    parse_string(query_multiple_short(stuff["author"]));
      }
      if (stuff["started"]) {
         ret += "\n\nStarted " +
                    parse_string(query_multiple_short(stuff["started"]));
      }
      ret += "\n.EP\n\n";
      if (stuff["see"]) {
         ret += "\n\n.SH See also\n.SP 5 5\n" +
                            query_multiple_short(stuff["see"]) + "\n.EP\n";
      }
      if (stuff["changed"]) {
         ret += ".SH Change history\n.SP 5 5\n" +
                            parse_string(implode(stuff["changed"], "\n\n")) +
                            "\n.EP\n\n";
      }
      if (stuff["example"]) {
        ret += ".SH Example\n.SI 5\n" +
               parse_string(implode(stuff["example"], "\n")) + "\n.EI\n";
      }
   }
   if (sizeof(file->query_inherits())) {
      ret += ".SH Inherits\n.SP 5 5\n";
      ret += "This class inherits the following classes " +
                         query_multiple_short(keys(file->query_inherits())) +
                         ".\n.EP\n\n";
   }
   if (sizeof(file->query_includes())) {
      ret += ".SH Includes\n.SP 5 5\n";
      ret += "This class includes the following files " +
                         query_multiple_short(file->query_includes()) +
                         ".\n.EP\n\n";
   }
   funcs = filter(keys(file->query_public_functions()),
                  (: $1 != "create" && $1 != "setup" &&
                   !$(file)->query_public_functions()[$1][AUTO_DOCS]["ignore"] :));
   base_single = file->query_file_name();
   pos = strsrch(base_single, ".", -1);
   if (pos > 0) {
      base_single = base_single[0..pos-1];
   }
   base_single = NROFF_DOC_SINGLE + base_single + "/";
   files = get_dir(base_single + "*");
   if (pointerp(files)) {
      foreach (name in files) {
         if (file_size(base_single + name) >= 0) {
            rm(base_single + name);
         }
      }
   }
   if (sizeof(file->query_class_docs())) {
      ret += ".SH Classes\n\n";
      ret += query_classes(base_single,
                    file->query_class_docs(),
                    file->query_file_name());
      ret += "\n";
   }
   if (sizeof(funcs)) {
      ret += ".SH Public Functions\n" +
                         ".SP 5 5\nThese are functions that everyone can "
                         "access.\n.EP\n\n";
      ret += query_methods(funcs,
                    (: $(file)->query_public_functions()[$1] :),
                    base_single,
                    file->query_file_name());
      ret += "\n";
   }
   funcs = filter(keys(file->query_protected_functions()),
                  (: !$(file)->query_protected_functions()[$1][AUTO_DOCS]["ignore"] :));
   if (sizeof(funcs)) {
      ret += ".SH Protected Functions\n"
                         ".SP 5 5\nThese are functions that only "
                         "objects inheriting the class can access.\n.EP\n\n";
      ret += query_methods(funcs, (: $(file)->query_protected_functions()[$1] :),
                    base_single, file->query_file_name());
      ret += "\n";
   }
   bits = explode(file->query_file_name(), "/");
   name = bits[sizeof(bits)-1];
   if (sscanf(name, "%*s.h") == 1 &&
       sizeof(file->query_define_docs())) {
      ret += ".SH Defines\n";
      ret += query_defines(file->query_define_docs());
      ret += "";
   }
   write_file(output, ret);
}
private string query_defines(mapping docs) {
   string name;
   string *names;
   string ret;
   names = sort_array(keys(docs), (: strcasecmp :));
   ret = "";
   foreach (name in names) {
      ret += ".SI 3\n* %^BOLD%^" + name + "%^RESET%^\n" +
                         ".EI\n";
      if (docs[name]["main"]) {
         ret += query_method_description(docs[name]);
      }
      ret += "\n";
   }
   return ret;
}
private string query_classes(string base_single,
                           mapping classes,
                           string fn) {
   string name;
   string *names;
   string ret;
   names = sort_array(keys(classes), (: strcasecmp :) );
   ret = "";
   foreach (name in names) {
      reset_eval_cost();
      ret += ".SI 3\n* %^BOLD%^" + name + "%^RESET%^\n";
      ret += query_class_def(classes[name], name) + "\n.EI\n";
      if (classes[name][AUTO_CLASS_DOCS]["main"]) {
         ret += query_class_description(classes[name][AUTO_CLASS_DOCS]);
         write_single_class_description(name,
                                        classes[name],
                                        base_single + name,
                                        fn);
      }
      ret += "\n";
   }
   return ret;
}
private string query_methods(string *funcs,
                           function data,
                           string base_single,
                           string fn) {
   int i;
   mixed *stuff;
   string ret;
   funcs = sort_array(funcs, (: strcmp($1, $2) :));
   ret = "";
   for (i = 0; i < sizeof(funcs); i++) {
      stuff = evaluate(data, funcs[i]);
      ret += ".SI 3\n* %^BOLD%^" + funcs[i] + "%^RESET%^\n" +
                         ".EI\n.SI 5\n" + query_func_def(stuff, funcs[i]) +
                         "\n.EI\n";
      if (stuff[AUTO_DOCS]["main"]) {
         ret += query_method_description(stuff[AUTO_DOCS]);
         write_single_description(funcs[i], stuff, base_single + funcs[i], fn);
      }
      ret += "\n";
   }
   return ret;
}
private string query_class_def(mixed *stuff, string name) {
   string ret;
   int pad;
   int i;
   ret = "class " + name + " {\n";
   pad = strlen(ret);
   for (i = 0; i < sizeof(stuff[AUTO_CLASS_MEMBERS]); i++) {
      ret += sprintf("%-" + pad + "s", "");
      ret += implode(stuff[AUTO_CLASS_MEMBERS][i][AUTO_CLASS_TYPE], " ") +
             " " + stuff[AUTO_CLASS_MEMBERS][i][AUTO_CLASS_NAME] + ";\n";
   }
   ret += "}\n";
   return ret;
}
private string query_func_def(mixed *stuff, string func) {
   string ret;
   int i;
   ret = implode(stuff[AUTO_TYPE], " ") + " " + func+"(";
   for (i = 0; i < sizeof(stuff[AUTO_ARGS]); i += 2) {
      if (i) {
         ret += ", ";
      }
      ret += implode(stuff[AUTO_ARGS][i + AUTO_ARGS_TYPE], " ") + " " +
             stuff[AUTO_ARGS][i + AUTO_ARGS_NAME];
   }
   ret += ")";
   return ret;
}
private string query_long_func_def(mixed *stuff, string func) {
   string ret;
   int i;
   int pad;
   ret = implode(stuff[AUTO_TYPE], " ") + " " + func+"(";
   pad = strlen(ret);
   for (i = 0; i < sizeof(stuff[AUTO_ARGS]); i += 2) {
      if (i) {
         ret += sprintf(",\n%-"+pad+"s", "");
      }
      ret += implode(stuff[AUTO_ARGS][i + AUTO_ARGS_TYPE], " ") + " " +
             stuff[AUTO_ARGS][i + AUTO_ARGS_NAME];
   }
   ret += ")";
   return ret;
}
private string query_class_description(mapping docs) {
   int i;
   string name;
   string desc;
   string ret;
   ret = "";
   if (docs["main"]) {
      ret += convert_html(implode(docs["main"], " "), 7, 0, 5);
   }
   if (docs["member"]) {
      ret += ".SI 7\n%^BOLD%^Members:%^RESET%^\n.EI\n";
      for (i = 0; i < sizeof(docs["member"]); i++) {
         if (sscanf(docs["member"][i], "%s %s", name, desc) == 2) {
            ret +=  ".SP 9 5\n" + name + " - " +
                               parse_string(desc) + "\n.EP\n";
         }
      }
   }
   return ret;
}
private string query_method_description(mapping docs) {
   int i;
   string name;
   string desc;
   string ret;
   ret = "";
   if (docs["main"]) {
      ret += convert_html(implode(docs["main"], " "), 7, 0, 5);
   }
   if (docs["param"]) {
      ret += ".SI 7\n%^BOLD%^Parameters:%^RESET%^\n.EI\n";
      for (i = 0; i < sizeof(docs["param"]); i++) {
         if (sscanf(docs["param"][i], "%s %s", name, desc) == 2) {
            ret += ".SP 9 5\n" + name + " - " +
                               parse_string(desc) + "\n.EP\n";
         }
      }
   }
   if (docs["return"]) {
      ret +=".SI 7\n%^BOLD%^Returns:%^RESET%^\n.EI\n.SP 9 5\n" +
                         parse_string(implode(docs["return"], " ")) +
                         "\n.EP\n";
   }
   return ret;
}
private void write_single_description(string func, mixed *stuff,
                                      string output, string fn) {
   mapping fluff;
   string blue;
   int i;
   int end;
   string *bits;
   string name;
   string desc;
   string ret;
   reset_eval_cost();
   bits = explode(output, "/");
   blue = "/";
   for (i = 0; i < sizeof(bits) - 1; i++) {
      blue += bits[i] + "/";
      if (file_size(blue) != -2) {
         mkdir(blue);
      }
   }
   fluff = stuff[AUTO_DOCS];
   ret = "";
   ret += ".DT\n" + func + "\n" + mud_name() + " creator help\n" +
                      func + "\n\n";
   ret += ".SH Name\n.SP 5 5\n";
   blue = implode(fluff["main"], "\n");
   end = strlen(blue);
   i = strsrch(blue, ".");
   if (i > 0) {
      end = i;
   }
   i = strsrch(blue, "!");
   if (i > 0 && i < end) {
      end = i;
   }
   i = strsrch(blue, "?");
   if (i > 0 && i < end) {
      end = i;
   }
   ret += "" + func + " - " + replace(blue[0..end], "\n", " ") +
                      "\n.EP\n\n";
   ret += ".SH Syntax\n.SI 5\n" + query_long_func_def(stuff, func) +
                      "\n.EI\n\n";
   if (fluff["param"]) {
      ret += ".SH Parameters\n.SI 5\n";
      for (i = 0; i < sizeof(fluff["param"]); i++) {
         if (sscanf(fluff["param"][i], "%s %s", name, desc) == 2) {
            ret += "%^BOLD%^" + name + "%^RESET%^ - " +
                               (desc) + "\n";
         }
      }
      ret += ".EI\n\n";
   }
   if (fluff["return"]) {
      ret += ".SH Returns\n.SI 5\n";
      ret += implode(fluff["return"], " ");
      ret += ".EI\n\n";
   }
   ret += ".SH Defined in\n.SI 5\n" + fn + "\n.EI\n\n";
   ret += ".SH Description\n" + convert_html(blue, 5, 0, 5) + "\n";
   if (fluff["example"]) {
      i = 1;
      foreach (blue in fluff["example"]) {
         ret += ".SH Example " + i + "\n.SI 5\n" +
                            parse_string(blue) + "\n.EI\n\n";
         i++;
      }
   }
   if (fluff["see"]) {
      ret += ".SH See also\n.SP 5 5\n" +
                         implode(fluff["see"], ", ") + "\n.EP\n\n";
   }
   write_file(output, ret);
}
private void write_single_class_description(string func, mixed *stuff,
                                            string output, string fn) {
   mapping fluff;
   string blue;
   int i;
   int end;
   string *bits;
   string name;
   string desc;
   string ret;
   reset_eval_cost();
   bits = explode(output, "/");
   blue = "/";
   for (i = 0; i < sizeof(bits) - 1; i++) {
      blue += bits[i] + "/";
      if (file_size(blue) != -2) {
         mkdir(blue);
      }
   }
   fluff = stuff[AUTO_DOCS];
   ret = "";
   ret += ".DT\n" + func + "\n" + mud_name() + " creator help\n" +
                      func + "\n\n";
   ret +=  ".SH Name\n.SP 5 5\n";
   blue = implode(fluff["main"], "\n");
   end = strlen(blue);
   i = strsrch(blue, ".");
   if (i > 0) {
      end = i;
   }
   i = strsrch(blue, "!");
   if (i > 0 && i < end) {
      end = i;
   }
   i = strsrch(blue, "?");
   if (i > 0 && i < end) {
      end = i;
   }
   ret += "" + func + " - " + replace(blue[0..end], "\n", " ") +
                      "\n.EP\n\n";
   ret += ".SH Definition\n.SI 5\n" +
              query_class_def(stuff, func) +
                      "\n.EI\n\n";
   if (fluff["member"]) {
      ret += ".SH Members\n.SI 5\n";
      for (i = 0; i < sizeof(fluff["member"]); i++) {
         if (sscanf(fluff["member"][i], "%s %s", name, desc) == 2) {
            ret += "%^BOLD%^" + name + "%^RESET%^ - " +
                               (desc) + "\n";
         }
      }
      ret += ".EI\n\n";
   }
   ret += ".SH Defined in\n.SI 5\n" + fn + "\n.EI\n\n";
   ret += ".SH Description\n" + convert_html(blue, 5, 0, 5) + "\n";
   if (fluff["example"]) {
      i = 1;
      foreach (blue in fluff["example"]) {
         ret += ".SH Example " + i + "\n.SI 5\n" +
                            parse_string(blue) + "\n.EI\n\n";
         i++;
      }
   }
   if (fluff["see"]) {
      ret += ".SH See also\n.SP 5 5\n" +
                         implode(fluff["see"], ", ") + "\n.EP\n\n";
   }
   write_file(output, ret);
}
private string parse_string(string str) {
   return replace(str, ({ "<p>", "\n\n", "<br>", "\n\n",
                          "<b>", "%^BOLD%^", "</b>", "%^RESET%^",
                          "<i>", "%^CYAN%^", "</i>", "%^RESET%^",
                          "<pre>", "\n\n", "</pre>", "\n\n" }));
}
#define LIST_NONE 0
#define LIST_DYNAMIC 1
#define LIST_ORDERED 2
#define LIST_UNORDERED 3
#define LIST_TYPE 0
#define LIST_DEPTH 1
#define LIST_START 2
#define LIST_ADDITIONAL 3
#define LIST_NUM 4
string convert_html(string text, int depth, int preformat, int edge_width) {
   string ret;
   string *bits;
   mixed *lists;
   string* before_centers;
   string start;
   string new_start;
   string additional;
   string add;
   int i;
   string tag;
   string rest;
   ret = "";
   if (text[0] == '.') {
      text = " " + text;
   }
   bits = explode("#" + text, "<");
   bits[0] = bits[0][1..];
   start = ".SP " + depth + " " + edge_width;
   ret = start + "\n" + bits[0];
   additional = "";
   lists = ({ ({ LIST_NONE, depth, start, additional }) });
   before_centers = ({ });
   for (i = 1; i < sizeof(bits); i++) {
         if (sscanf(bits[i], "%s>%s", tag, rest) == 2) {
            new_start = start;
            add = 0;
            switch (lower_case(tag)) {
               case "p" :
                  ret += "\n\n" + additional;
                  break;
               case "br" :
                  ret += "\n.E" + start[2..2] + "\n" + start + "\n" + additional;
                  break;
               case "dl" :
                  lists += ({ ({ LIST_DYNAMIC, depth, start, additional }) });
                  break;
               case "/dl" :
                  if (lists[<1][LIST_TYPE] == LIST_DYNAMIC) {
                     lists = lists[0..<2];
                     new_start = lists[<1][LIST_START];
                     additional = lists[<1][LIST_ADDITIONAL];
                  }
                  break;
               case "u" :
                  ret += "_";
                  break;
               case "/u" :
                  ret += "_";
                  break;
               case "center" :
                  before_centers += ({ start });
                  new_start = ".SC";
                  break;
               case "/center" :
                  new_start = before_centers[<1];
                  before_centers = before_centers[0..<2];
                  break;
               case "ol" :
                  lists += ({ ({ LIST_ORDERED, depth, start, additional, 1 }) });
                  break;
               case "/ol" :
                  if (lists[<1][LIST_TYPE] == LIST_ORDERED) {
                     lists = lists[0..<2];
                     new_start = lists[<1][LIST_START];
                     additional = lists[<1][LIST_ADDITIONAL];
                  }
                  break;
               case "ul" :
                  lists += ({ ({ LIST_UNORDERED, depth, start, additional }) });
                  break;
               case "/ul" :
                  if (lists[<1][LIST_TYPE] == LIST_UNORDERED) {
                     lists = lists[0..<2];
                     new_start = lists[<1][LIST_START];
                     additional = lists[<1][LIST_ADDITIONAL];
                  }
                  break;
               case "dd" :
                  if (lists[<1][LIST_TYPE] == LIST_DYNAMIC) {
                     new_start = ".SP " + (lists[<1][LIST_DEPTH] + 3) + " " +
                                 edge_width;
                     depth = lists[<1][LIST_DEPTH] + 3;
                     start = start[0..3];
                     additional = "";
                  }
                  break;
               case "dt" :
                  if (lists[<1][LIST_TYPE] == LIST_DYNAMIC) {
                     new_start = ".SP " + (lists[<1][LIST_DEPTH] + 0) + " " +
                                 edge_width;
                     depth = lists[<1][LIST_DEPTH] + 0;
                     start = start[0..3];
                     additional = "";
                  }
                  break;
               case "li" :
                  if (lists[<1][LIST_TYPE] != LIST_DYNAMIC) {
                     switch (lists[<1][LIST_TYPE]) {
                        case LIST_ORDERED :
                           new_start = ".SO " + (lists[<1][LIST_DEPTH] + 1) +
                                 " 3 -" + (6 + lists[<1][LIST_DEPTH]);
                           add = "\n\t" + (lists[<1][LIST_NUM]++) + ". \t";
                           additional = "\t\t";
                           depth = (lists[<1][LIST_DEPTH] + 3);
                           break;
                        case LIST_UNORDERED :
                           new_start = ".SO " + (lists[<1][LIST_DEPTH] + 1) +
                                 " 2 -" + (5 + lists[<1][LIST_DEPTH]);
                           add = "\n\t*\t";
                           additional = "\t\t";
                           depth = (lists[<1][LIST_DEPTH] + 3);
                           break;
                     }
                  }
                  break;
               case "pre" :
                  preformat++;
                  break;
               case "b" :
                  ret += "%^BOLD%^";
                  break;
               case "i" :
                  ret += "%^CYAN%^";
                  break;
               case "/b" :
               case "/i" :
                  ret += "%^RESET%^";
                  break;
               case "/pre" :
                  preformat--;
                  break;
               case "code" :
               case "/code" :
                  break;
               default :
                  rest = "<" + tag + ">" + rest;
                  break;
            }
            if (new_start != start) {
               ret += "\n.E" + start[2..2] + "\n" + new_start + "\n";
               start = new_start;
            }
            if (add) {
               ret += add;
            }
            if (preformat) {
               ret += replace(rest, "\n", "\n.E" + start[2..2] + "\n" +
                                    start + "\n" + additional);
            } else {
               rest = replace(rest, "\n", " ");
               while (strlen(rest) && rest[0] == ' ') {
                  rest = rest[1..];
               }
               while (strsrch(rest, "  ") != -1) {
                  rest = replace_string(rest, "  ", " ");
               }
               ret += rest;
            }
         } else {
            ret += ">" + bits[i];
         }
   }
   ret += "\n.E" + start[2..2] + "\n";
   return ret;
}

==================================================
FILE: rings/high_gp_ring.c
==================================================

#define GP_AWARD 250
inherit "/obj/ring";
void setup() {
    set_name( "ring" );
    set_short( "pink crystal ring" );
    add_adjective( ({ "pink", "crystal" }) );
    set_main_plural( "pink crystal rings" );
    set_long( "The ring is a single piece of $material$, cut and polished "+
      "until its facets sparkle in the light.\n" );
    set_material( "rosy-quartz" );
    set_value( 750 );
    set_value_info( "artifact", 15000 );
    set_weight( 1 );
    set_enchant( 5 );
    add_property( "artifact form", ([
        "ring of power" : 6
      ]) );
    adjust_charges( 1 + random( 11 ) );
    set_level( 75 );
    set_zapper( file_name( this_object() ) );
}
string query_ring_name() { return "ring of power"; }
void zap( object dummy, object person, object ring ) {
    tell_object( person, "You feel slightly more powerful.\n" );
    if ( ( (string)person->query_gp() + GP_AWARD ) >
      (string)person->query_max_gp() ) {
        person->set_gp( person->query_max_gp() );
        return;
    }
    person->adjust_gp( GP_AWARD );
}
int failed_zap( object dummy, object person, object ring ) {
    tell_object( person, "You feel slightly less powerful.\n" );
    person->add_succeeded_mess( ring, "$N $V $D.\n", ({ }) );
    if ( person->query_gp() < ( GP_AWARD / 3 ) ) {
        person->set_gp( 0 );
        return 1;
    }
    person->adjust_gp( 0 - ( GP_AWARD / 3 ) );
    return 1;
}

==================================================
FILE: rings/invisibility.c
==================================================

inherit "/obj/ring";
void setup() {
   set_name( "ring" );
   set_short( "clear crystal ring" );
   add_adjective( ({ "clear", "crystal" }) );
   set_main_plural( "clear crystal rings" );
   set_long( "The ring is made from a colourless stone that seems to refract "+
         "light in a strange way.  The outer edge has eight sides.\n" );
   set_material( "calcite" );
   set_value( 200 );
   set_value_info( "artifact", 5000 );
   set_weight( 1 );
   set_enchant( 2 );
   add_property( "no recycling", 1 );
   add_property( "fluff'n'stuff", 1 );
   add_property( "artifact form", ([
      "ring of invisibility" : 2
   ]) );
   adjust_charges( 1 + random( 7 ) );
   set_level( 60 );
   set_zapper( file_name( this_object() ) );
}
string query_ring_name() { return "ring of invisibility"; }
void zap( object dummy, object person, object ring ) {
   person->add_effect( "/std/effects/magic/invisibility",
         roll_MdN( 7, (int)ring->query_level() ) );
}

==================================================
FILE: rings/low_gp_ring.c
==================================================

#define GP_AWARD 50
inherit "/obj/ring";
void setup() {
    set_name( "ring" );
    set_short( "pink crystal ring" );
    add_adjective( ({ "pink", "crystal" }) );
    set_main_plural( "pink crystal rings" );
    set_long( "The ring is a single piece of $material$, cut and polished "+
      "until its facets sparkle in the light.\n" );
    set_material( "rosy-quartz" );
    set_value( 250 );
    set_value_info( "artifact", 5000 );
    set_weight( 1 );
    set_enchant( 3 );
    add_property( "artifact form", ([
        "ring of energy" : 4
      ]) );
    adjust_charges( 1 + random( 11 ) );
    set_level( 25 );
    set_zapper( file_name( this_object() ) );
}
string query_ring_name() { return "ring of energy"; }
void zap( object dummy, object person, object ring ) {
    tell_object( person, "You feel slightly more powerful.\n" );
    if ( ( (string)person->query_gp() + GP_AWARD ) >
      (string)person->query_max_gp() ) {
        person->set_gp( person->query_max_gp() );
        return;
    }
    person->adjust_gp( GP_AWARD );
}
int failed_zap( object dummy, object person, object ring ) {
    tell_object( person, "You feel slightly less powerful.\n" );
    person->add_succeeded_mess( ring, "$N $V $D.\n", ({ }) );
    if ( person->query_gp() < ( GP_AWARD / 3 ) ) {
        person->set_gp( 0 );
        return 1;
    }
    person->adjust_gp( 0 - ( GP_AWARD / 3 ) );
    return 1;
}

==================================================
FILE: rings/med_gp_ring.c
==================================================

#define GP_AWARD 150
inherit "/obj/ring";
void setup() {
    set_name( "ring" );
    set_short( "pink crystal ring" );
    add_adjective( ({ "pink", "crystal" }) );
    set_main_plural( "pink crystal rings" );
    set_long( "The ring is a single piece of $material$, cut and polished "+
      "until its facets sparkle in the light.\n" );
    set_material( "rosy-quartz" );
    set_value( 500 );
    set_value_info( "artifact", 10000 );
    set_weight( 1 );
    set_enchant( 4 );
    add_property( "artifact form", ([
        "ring of vigour" : 5
      ]) );
    adjust_charges( 1 + random( 11 ) );
    set_level( 50 );
    set_zapper( file_name( this_object() ) );
}
string query_ring_name() { return "ring of vigour"; }
void zap( object dummy, object person, object ring ) {
    tell_object( person, "You feel slightly more powerful.\n" );
    if ( ( (string)person->query_gp() + GP_AWARD ) >
      (string)person->query_max_gp() ) {
        person->set_gp( person->query_max_gp() );
        return;
    }
    person->adjust_gp( GP_AWARD );
}
int failed_zap( object dummy, object person, object ring ) {
    tell_object( person, "You feel slightly less powerful.\n" );
    person->add_succeeded_mess( ring, "$N $V $D.\n", ({ }) );
    if ( person->query_gp() < ( GP_AWARD / 3 ) ) {
        person->set_gp( 0 );
        return 1;
    }
    person->adjust_gp( 0 - ( GP_AWARD / 3 ) );
    return 1;
}

==================================================
FILE: rings/recall.c
==================================================

#include <drinks.h>
#include <cwc.h>
#include <config.h>
inherit "/obj/ring";
void setup() {
  set_name( "ring" );
  set_short( "blue crystal ring" );
  add_adjective( ({ "blue", "crystal" }) );
  set_main_plural( "blue crystal rings" );
  set_long( "The ring is a single piece of $material$, cut and polished "+
      "until its facets sparkle in the light.\n" );
  set_material( "sapphire" );
  set_value( 500 );
  set_value_info( "artifact", 10000 );
  set_weight( 1 );
  set_enchant( 3 );
  add_property( "artifact form", ([
    "ring of recall" : 3
  ]) );
  adjust_charges( 1 + random( 11 ) );
  set_level( 30 );
  set_zapper( file_name( this_object() ) );
}
string query_ring_name() { return "ring of recall"; }
string find_start_location( object person ) {
    string pos;
    if ( file_name( environment( person ) )[0..19] == "/d/cwc/Bes_Pelargic/" ) {
        return CWC_START_LOCATION;
    }
    pos = person->query_start_pos();
    if ( pos[ 0..19 ] == "/d/cwc/Bes_Pelargic/" && file_name( environment( person ) )[ 0..19 ] != "/d/cwc/Bes_Pelargic/" ) {
        return CONFIG_START_LOCATION;
    }
    return pos;
}
void zap( object dummy, object person, object ring ) {
   string place;
   place = query_property( "destination" );
   if ( !place ) {
      call_out( "move_person", 0, person, find_start_location( person ) );
   }
   else {
      call_out( "move_person", 0, person, place );
   }
}
int failed_zap( object dummy, object person, object ring ) {
  person->add_succeeded_mess( ring, "$N $V $D, but nothing happens.\n", ({ }) );
  return 1;
}
void move_person( object person, string place ) {
  tell_creator( "taffyd", "%O, %s\n", person, place );
  if ( !find_object( place ) )
    place->force_load();
  if ( !find_object( place ) ) {
    tell_object( person, "Please contact a creator and ask that \""+ place +
        "\" be checked.  You are also owed a charge on this ring.\n" );
    return;
  }
  if ( environment( person ) == find_object( place ) ) {
    tell_object( person, "You momentarily feel dislocated from reality; "+
        "the feeling passes, but something has changed...\n" );
    person->adjust_volume( D_ALCOHOL, ( 500 + random( 500 ) ) * ( 1 -
        2 * random( 2 ) ) );
    return;
  }
  tell_object( person, "You suddenly feel as if something yanks you "+
      "across the dimensions.\n" );
  person->move_with_look( place, "A spot of blue appears, enlarges and "+
      "turns into $N.", "$N shrinks and becomes red, then disappears "+
      "altogether." );
}

==================================================
FILE: plants/inherit/grain.c
==================================================

#include <move_failures.h>
#include <state_change.h>
#define TO this_object()
#define TP this_player()
#define THRESHOLD 5
inherit "/obj/food";
int _max_strip;
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_name( "grain" );
  set_short( "broken grain" );
  set_long( "This is some funky, but broken, grain.\n" );
  _max_strip = THRESHOLD;
  remove_help_file( "food" );
  add_help_file( "grain" );
  add_alias( "plant" );
  add_plural( "plants" );
  set_collective();
  set_amount( 1 );
  set_weight_unit( ({ 1, 10 }) );
  set_eat_mess( ({
    "$N choke down $D. It absorbs all the moisture from your mouth and sticks "
      "in your throat.  Looks like you just aren't designed to eat unmilled "
      "grain.\n",
    "$N chokes down $D, coughing and rubbing $p throat unhappily.\n"
  }) );
  if ( ! do_setup ) {
    TO->setup();
    TO->reset();
  }
}
void init() {
  ::init();
  TP->add_command( "chew", TO );
  TP->add_command( "strip", TO );
}
void set_max_strippable( int num ) {
  _max_strip = num;
}
int query_max_strippable() {
  return _max_strip;
}
int do_chew() {
  int size;
  size = query_amount();
  if ( ! size ) {
    add_failed_mess( "You can't chew thin air.\n" );
    return 0;
  }
  if ( size > 1 ) {
    add_failed_mess( "You can't chew more than one " + short(0)
      + " at a time.\n" );
    return 0;
  }
  TP->set_position( "idly chewing " + TO->a_short() );
  add_succeeded_mess(
    "$N place$s $D between $p teeth, and chew$s it idly.\n" );
  return 1;
}
int do_strip() {
  int i;
  object stripped;
  if ( query_amount() > query_max_strippable() ) {
    add_failed_mess( "That's far too much $D for you to strip by hand.  "
      "Perhaps you should look for a tool of some kind.\n" );
    return 0;
  }
  stripped = STATE_CHANGE->transform( TO, "thresh" );
  if ( ! objectp( stripped ) ) {
    add_failed_mess( "For some reason, you can't strip $D.\n" );
    return 0;
  }
  i = stripped->move( TP );
  if ( i != MOVE_OK ) {
    stripped->move( environment( TP ) );
    add_succeeded_mess( "$N strip$s the grain from $D with $p fingers, "
      "spilling some onto the "
      + ( environment( TP )->query_property( "location" ) == "inside" ? "floor"
      : "ground" ) + ".\n" );
  } else {
    add_succeeded_mess( "$N strip$s the grain from $D with $p fingers.\n" );
  }
  move( "/room/rubbish" );
  return 1;
}
mapping query_static_auto_load() {
  return int_query_static_auto_load();
}
