# Total Tokens: 99480
# Total Files Merged: 32
# Total Characters: 331681

f.c
==================================================

#include <nroff.h>
mixed *nroffed_file;
string nroffed_file_name;
int modified_time;
nosave int new_string;
nosave int force_string;
void create() {
  nroffed_file = ({ });
  seteuid("Root");
}
#define do_bounds(bing) (bing<0?bing+cols:bing)
string cat_file(string fname, int update) {
   int i;
   int k;
   int cols;
   string ret;
   string pat;
   mixed* tmp;
   if (!master()->valid_read(fname, geteuid(previous_object()),
                             "restore_object")) {
      return 0;
   }
   nroffed_file_name = 0;
   modified_time = 0;
   if (!restore_object(fname))
      return 0;
   if (!nroffed_file_name && update)
      return 0;
   if (update) {
      mixed *something;
      if (!master()->valid_read(nroffed_file_name,
                                geteuid(previous_object()),
                                "restore_object"))
         return 0;
      if (file_size(nroffed_file_name) <= 0)
         return 0;
      something = stat(nroffed_file_name);
      if (something[1] > modified_time)
         return 0;
   }
   ret = "";
   if (this_player()) {
      cols = (int)this_player()->query_cols();
   } else {
      cols = 79;
   }
   for (i=0;i<sizeof(nroffed_file);i++) {
      if (stringp(nroffed_file[i])) {
         ret += nroffed_file[i];
      } else {
         switch (nroffed_file[i]) {
          case V_HEADER :
            ret += sprintf("%%^BOLD%%^%s%%^RESET%%^\n", nroffed_file[i+1]);
            i++;
            break;
          case V_CENTER :
            ret += sprintf("%|=*s", cols, nroffed_file[i+1]);
            i++;
            break;
          case V_ALL :
            ret += "%^BOLD%^\n" + sprintf("%-s%*|s%*s\n",
                           nroffed_file[i+2],
                           cols - nroffed_file[i+1]*2,
                           nroffed_file[i+3],
                           nroffed_file[i+1],
                           nroffed_file[i+4]) + "%^RESET%^\n";
            i += 4;
            break;
          case V_INDENT :
            ret += sprintf( "%*=s%-=*s", nroffed_file[ i + 1 ], "",
                           cols - nroffed_file[ i + 1 ], nroffed_file[ i + 2 ] );
            i += 2;
            break;
          case V_PARA :
            if (nroffed_file[i+1])
            ret += sprintf("%*=s%-=*s%=*s\n", nroffed_file[i+1], "",
                           cols-nroffed_file[i+1]-
                           nroffed_file[i+2], nroffed_file[i+3],
                           nroffed_file[i+2], "");
            else if (nroffed_file[i+2])
            ret += sprintf("%-=*s%=*s\n", cols-nroffed_file[i+2],
                           nroffed_file[i+3],
                           nroffed_file[i+2], "");
            else
            ret += sprintf("%-=*s\n", cols, nroffed_file[i+3]);
            i += 3;
            break;
          case V_LEFT :
            ret += sprintf("%-=*s", cols, nroffed_file[i+1]);
            i++;
            break;
          case V_TABLE :
            ret += sprintf("%-#*s", cols, nroffed_file[i+1]);
            i++;
            break;
          case V_COLUMN : {
             int j;
             switch (sizeof(nroffed_file[i+1])) {
              case 2 :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                   ret += sprintf("%*-=s%*-=s\n", do_bounds(nroffed_file[i+1][0]),
                                  nroffed_file[i+2][j],
                                  do_bounds(nroffed_file[i+1][1]),
                                  nroffed_file[i+3][j]);
                }
                i += 3;
                break;
              case 3 :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                   ret += sprintf("%*-=s%*-=s%*-=s\n",
                               do_bounds(nroffed_file[i+1][0]),
                               nroffed_file[i+2][j],
                               do_bounds(nroffed_file[i+1][1]),
                               nroffed_file[i+3][j],
                               do_bounds(nroffed_file[i+1][2]),
                               nroffed_file[i+4][j]);
                }
                i += 4;
                break;
             default :
                pat = implode(allocate(sizeof(nroffed_file[i+1]), "%*-=s"), "");
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                   tmp = ({ });
                   for (k = 0; k < sizeof(nroffed_file[i+1]); k++) {
                      tmp += ({ do_bounds(nroffed_file[i+1][k]),
                                nroffed_file[i+2+k][j] });
                   }
                   ret += sprintf(pat + "\n", tmp ... );
                }
                i += sizeof(nroffed_file[i+1]) + 1;
                break;
             }
             break;
          }
         }
      }
   }
   return " \n"+ret;
}
private string htmlify(string  str) {
  return replace(str, ({ "&", "&amp;", "<", "&lt;", ">", "&gt;"}));
}
string html_file(string file, string title) {
   int i, j, cols, in_bold, in_italic;
   int k;
   string ret, *bits;
   if (!master()->valid_read(file, geteuid(previous_object()),
                             "restore_object"))
      return 0;
   nroffed_file_name = 0;
   modified_time = 0;
   if (!restore_object(file))
      return 0;
   ret = "";
   cols = 78;
   for (i=0;i<sizeof(nroffed_file);i++)
     if (stringp(nroffed_file[i]))
       nroffed_file[i] = htmlify(nroffed_file[i]);
     else if(arrayp(nroffed_file[i])) {
       for (j=0;j<sizeof(nroffed_file[i]);j++)
         if(stringp(nroffed_file[i][j]))
           nroffed_file[i][j] = htmlify(nroffed_file[i][j]);
     }
   for (i=0;i<sizeof(nroffed_file);i++) {
      if (stringp(nroffed_file[i])) {
         ret += "<h3>"+nroffed_file[i]+"</h3>";
#ifdef UNUSED
         if(strsrch(nroffed_file[i], "See also") > -1) {
           for(j=i+1; j < sizeof(nroffed_file); j++) {
             if(stringp(nroffed_file[j])) {
               nroffed_file[j] = make_links(nroffed_file[j]);
             }
           }
         }
#endif
      } else {
         switch (nroffed_file[i]) {
          case V_HEADER :
            ret += "<h3>"+replace_string(nroffed_file[i+1], "\n", "<br>")+
              "</h3>";
            i++;
            break;
          case V_CENTER :
            ret += "<center>"+replace(nroffed_file[i+1], "\n", "<br>")+
            "</center>";
            i++;
            break;
          case V_ALL :
            ret += "\n<table width=100%><tr>\n" +
                   "<td nowrap width=* align=left><h2>" +
                   nroffed_file[i+2] + "</h2></td>\n" +
                   "<td nowrap align=center><h2>" +
                   nroffed_file[i+3] + "</h2></td>\n" +
                   "<td nowrap width=* align=right><h2>" +
                   nroffed_file[i+4] + "</h2></td>\n" +
                   "</tr></table>\n";
            i += 4;
            break;
          case V_INDENT :
            ret += replace(nroffed_file[i+2], ({"<", "&lt;", ">",
               "&gt;", "\n", "<br>"}));
            i += 2;
            break;
          case V_PARA :
            ret += replace(nroffed_file[i+3], "\n", "<p>");
            i += 3;
            break;
          case V_LEFT :
            ret += "<left>"+nroffed_file[i+1]+"</left>";
            i++;
            break;
          case V_TABLE :
            ret += "<ul><li>"+replace(nroffed_file[i+1], "\n", "<li>")+"</ul>";
            i++;
            break;
          case V_COLUMN : {
             ret += "<table cellpadding=10>";
             switch (sizeof(nroffed_file[i+1])) {
              case 2 :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                  ret += "<tr>\n";
                  ret += "<td nowrap>"+nroffed_file[i+2][j] + "</td>";
                  ret += "<td>"+nroffed_file[i+3][j] + "</td>";
                  ret += "</tr>";
                }
                i += 3;
                break;
              case 3 :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                  ret += "<tr>\n";
                  ret += "<td nowrap>"+nroffed_file[i+2][j] + "</td>";
                  ret += "<td nowrap>"+nroffed_file[i+3][j] + "</td>";
                  ret += "<td>"+nroffed_file[i+4][j] + "</td>";
                  ret += "</tr>";
                }
                i += 4;
                break;
             default :
                for (j=0;j<sizeof(nroffed_file[i+2]);j++) {
                   ret += "<tr>\n";
                   for (k = 0; k < sizeof(nroffed_file[i+1]); k++) {
                      ret += "<td nowrap>" + nroffed_file[i+2+k][j] + "</td>\n";
                   }
                   ret += "</tr>\n";
                }
                i += sizeof(nroffed_file[i+1]) + 1;
                break;
             }
             ret += "</table>";
             break;
          }
         }
      }
   }
   bits = explode(ret, "%^");
   ret = "";
   for (i=0;i<sizeof(bits);i+=2) {
      ret += bits[i];
    if (i+1 < sizeof(bits)) {
       switch (bits[i+1]) {
        case "BOLD" :
          if (!in_bold)
             ret += "<strong>";
          else
             ret += "</strong>";
          in_bold = !in_bold;
          break;
        case "RESET" :
          if (in_bold)
             ret += "</strong>";
          if (in_italic)
             ret += "</i>";
          in_bold = 0;
          in_italic = 0;
          break;
        default :
          if (!in_italic)
             ret += "<i>";
          else
             ret += "</i>";
          in_italic = !in_italic;
          break;
       }
    }
   }
   return ret;
}
private void add_array(mixed *i) {
  if (!sizeof(nroffed_file)) {
    nroffed_file += ({ i });
  } else if (force_string) {
    nroffed_file += ({ "", i });
  } else {
    nroffed_file += ({ i });
  }
  force_string = 0;
  new_string = 0;
}
private void add_int(int i) {
  if (!sizeof(nroffed_file)) {
    nroffed_file += ({ i });
  } else if (force_string) {
    nroffed_file += ({ "", i });
  } else {
    nroffed_file += ({ i });
  }
  force_string = 0;
  new_string = 0;
}
private void add_string(string s) {
  if (!sizeof(nroffed_file) || new_string) {
    nroffed_file += ({ s });
  } else if (stringp(nroffed_file[<1])) {
    nroffed_file[<1] += s;
  } else {
    nroffed_file += ({ s });
  }
  new_string = 0;
  force_string = 0;
}
int create_nroff(string in_file, string out_file) {
  string text,
         tmp,
         *bits;
  string *bing;
  mixed  *cols;
  int strip_crs,
      col_mode,
      conv_tabs,
      i, j, k, fluff,
      num_cols;
  if (!master()->valid_read(in_file, geteuid(previous_object()),
                            "read_file"))
    return 0;
  nroffed_file_name = in_file;
  modified_time = time();
  text = read_file(in_file);
  if (!text) {
    return 0;
  }
  bits = explode("#\n"+text, "\n.");
  bits[0] = bits[0][1..];
  nroffed_file = ({ 0 });
  if (strlen(bits[0])) {
    add_string(bits[0]);
  }
  for (i=1;i<sizeof(bits);i++) {
     if (sscanf(bits[i], "%s\n%s", tmp, bits[i]) != 2) {
        tmp = bits[i];
        bits[i] = "";
        fluff = 1;
     } else {
        fluff = 0;
     }
     switch (tmp[0..1]) {
      case "SH" :
        add_int(V_HEADER);
        add_string(tmp[3..]);
        new_string = 1;
        break;
      case "SI" :
        add_int(V_INDENT);
        j = 0;
        sscanf(tmp[2..], "%d%s", j, tmp);
        add_int(j);
        force_string = 1;
        break;
      case "EI" :
        add_string("");
        new_string = 1;
        break;
      case "SP" :
        add_int(V_PARA);
        j = 0;
        sscanf(tmp[2..], "%d%s", j, tmp);
        add_int(j);
        j = 0;
        sscanf(tmp, " %d%s", j, tmp);
        add_int(j);
        force_string = 1;
        strip_crs = 1;
        break;
      case "EP" :
        add_string("");
        new_string = 1;
        strip_crs = 0;
        break;
      case "SC" :
        add_int(V_CENTER);
        force_string = 1;
        break;
      case "EC" :
        new_string = 1;
        break;
      case "SL" :
        add_int(V_LEFT);
        force_string = 1;
        break;
      case "EL " :
        new_string = 1;
        break;
      case "ST" :
        add_int(V_TABLE);
        force_string = 1;
        conv_tabs = 1;
        break;
      case "ET" :
        new_string = 1;
        conv_tabs = 0;
        break;
      case "DT" :
        bing = explode(bits[i], "\n");
        if (sizeof(bing) < 3) {
           if (this_player()->query_creator()) {
              tell_object(this_player(), "Text file "+in_file+
                          " did not have enough lines after the .DT directive.\n");
              tell_object(this_player(), sprintf("%O\n", bing));
           }
           return 0;
        }
        add_int(V_ALL);
        if (strlen(bing[0]) > strlen(bing[2]))
           add_int(strlen(bing[0]));
        else
           add_int(strlen(bing[2]));
        new_string = 1;
        add_string(bing[0]);
        new_string = 1;
        add_string(bing[1]);
        new_string = 1;
        add_string(bing[2]);
        new_string = 1;
        bits[i] = implode(bing[3..], "\n");
        break;
      case "SO" :
        num_cols = 0;
        tmp = tmp[2..];
        cols = ({ });
        while (sscanf(tmp, "%d%s", j, tmp) == 2) {
           cols += ({ j });
           num_cols++;
           while (strlen(tmp) && tmp[0] == ' ')
           tmp = tmp[1..];
        }
        add_int(V_COLUMN);
        if (sscanf(tmp, "%d", j) == 1) {
           cols += ({ j });
           num_cols++;
        }
        add_array(cols);
        cols = allocate(num_cols);
        for (j=0;j<num_cols;j++) {
           cols[j] = ({ });
        }
        col_mode = 1;
        break;
      case "EO" :
        for (j=0;j<num_cols;j++) {
           add_array(cols[j]);
        }
        col_mode = 0;
        break;
      case "NF" :
        bing = explode(bits[i], "\n");
        if (sizeof(bing) < 1) {
           if (this_player()->query_creator()) {
              tell_object(this_player(), "Text file "+in_file+
                          " did not have enough lines after the .NF directive.\n");
              tell_object(this_player(), sprintf("%O\n", bing));
           }
           return 0;
        }
        text = read_file(bing[ 0 ]);
        if (!text) {
          return 0;
        }
        bits = explode("#\n"+text, "\n.");
        bits[0] = bits[0][1..];
        nroffed_file = ({ 0 });
        if (strlen(bits[0])) {
           add_string(bits[0]);
        }
        strip_crs = col_mode = conv_tabs = fluff = num_cols = i = 0;
        break;
     }
     if (fluff) {
        continue;
     }
     if (conv_tabs) {
        bits[i] = replace(bits[i], "\t", "\n");
     }
     if (col_mode) {
        string *frog;
        frog = explode(bits[i], "\n");
        for (k = 0; k < sizeof(frog); k++) {
           bing = explode("#"+frog[k], "\t");
           bing[0] = bing[0][1..];
           for (j = 0; j < num_cols && j < sizeof(bing); j++) {
              cols[j] += ({ bing[j] });
           }
           for (j = sizeof(bing);j < num_cols; j++) {
              cols[j] += ({ "\n" });
           }
        }
     } else if (strip_crs) {
        bits[i] = replace_string(bits[i], "\n\n", "$%^NeW_LiNe^%$");
        bits[i] = replace_string(bits[i], ".\n", ".  ");
        bits[i] = replace_string(bits[i], "\n", " ");
        bits[i] = replace_string(bits[i], "$%^NeW_LiNe^%$", "\n\n");
        add_string(bits[i]+" ");
     } else {
        add_string(bits[i]+"\n");
     }
  }
  new_string = 0;
  force_string = 0;
  unguarded((: save_object, out_file :));
  return 1;
}
string query_file_name( string fname ) {
   if (!master()->valid_read(fname, geteuid(previous_object()),
                             "restore_object")) {
      return 0;
   }
   nroffed_file_name = 0;
   modified_time = 0;
   if (!restore_object(fname)) {
      return 0;
   }
   return nroffed_file_name;
}

==================================================
FILE: handlers/options_handler.c
==================================================

#include <cmds/options.h>
#include <cmds/teach.h>
#include <colour.h>
#include <clubs.h>
#include <ls.h>
#include <obj_parser.h>
#include <player.h>
#include <creator.h>
#include <terrain_map.h>
#include <error_handler.h>
class option {
   mixed type;
   int restriction;
   function set;
   function query;
   mapping suboptions;
   string help;
}
private mapping _options;
private string* _colours;
private mapping _cache_input;
protected int add_option(string path, mixed type, int cre_only,
                         function set_function, function query_function,
                         string help);
private int set_player_brief(object player, string variable, int value);
private int query_player_brief(object player, string variable);
private mapping get_inform_colours(object player);
private mapping get_club_colours(object player);
private int change_bool_property(string prop, object player, int new_value);
private int change_earmuffs(object player, string ear, int new_value);
private int setup_earmuffs(object player, string value);
private int valid_birthday(string str);
private string convert_birthday(string birthday);
private int change_error_reports(object player, string ear, int new_value);
void create() {
   string womble;
   _options = ([ ]);
   _cache_input = ([ ]);
   _colours = ({
    "BOLD",
    "FLASH",
    "BLACK",
    "RED",
    "BLUE",
    "CYAN",
    "MAGENTA",
    "ORANGE",
    "YELLOW",
    "GREEN",
    "WHITE",
    "B_RED",
    "B_ORANGE",
    "B_YELLOW",
    "B_BLACK",
    "B_CYAN",
    "B_WHITE",
    "B_GREEN",
    "B_MAGENTA" });
   add_option("output look", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display room descriptions briefly or in full");
   add_option("output combat", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display all combat messages or only those involving damage");
   add_option("output errors", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display errors in the error handler briefly");
   add_option("output score", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Amount of detail to be displayed by the 'score' command");
   add_option("output accent", ({ "mangle", "unadulterated" }),
              OPTIONS_TYPE_ALL,
              (: $1->set_mangle_accent($3 == "mangle"), 1 :),
              (: $1->query_mangle_accent() ? "mangle" : "unadulterated" :),
              "Show others speech with or without regional accents");
   add_option("output names", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Display player names with or without title and surname");
   add_option("output htell", OPTIONS_TYPE_BRIEF, OPTIONS_TYPE_ALL,
              (: $1->set_verbose($2[<1], $3), 1 :),
              (: $1->query_verbose($2[<1]) :),
              "Cause the 'htell' command to display times for tells or not");
   add_option("output msgout", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_msgout($3) :),
              (: $1->query_msgout() :),
              "The message that is displayed when you walk out of a room");
   add_option("output msgin", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_msgin($3) :),
              (: $1->query_msgin() :),
              "The message that is displayed when you walk into a room");
   add_option("output mmsgout", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_mmsgout($3) :),
              (: $1->query_mmsgout() :),
              "The message that is displayed when you trans out of a room");
   add_option("output mmsgin", OPTIONS_TYPE_STRING, OPTIONS_TYPE_CRE_ONLY,
              (: $1->set_mmsgin($3) :),
              (: $1->query_mmsgin() :),
              "The message that is displayed when you trans into of a room");
   add_option("output usercolour",
              OPTIONS_TYPE_BOOLEAN, 0,
              (: $3?$1->add_property(PLAYER_ALLOW_COLOURED_SOULS, 1):
                    $1->remove_property(PLAYER_ALLOW_COLOURED_SOULS), 1 :),
              (: $1->query_property(PLAYER_ALLOW_COLOURED_SOULS) :),
              "Display user chosen colours in souls");
   add_option("output plainmaps",
              OPTIONS_TYPE_BOOLEAN, 0,
              (: $3?$1->add_property(PLAYER_PLAIN_MAPS, 1):
                    $1->remove_property(PLAYER_PLAIN_MAPS), 1 :),
              (: $1->query_property(PLAYER_PLAIN_MAPS) :),
              "Display terrain maps without colour");
   add_option("output lookmap", OPTIONS_TYPE_BOOLEAN,
              OPTIONS_TYPE_PLAYTESTER_ONLY,
              (: $3?$1->add_property(TERRAIN_MAP_IN_LOOK_PROP, 1):
                    $1->remove_property(TERRAIN_MAP_IN_LOOK_PROP), 1 :),
              (: $1->query_property(TERRAIN_MAP_IN_LOOK_PROP) :),
              "Display room a map in the terrain long or not");
   add_option( "output tabstops", OPTIONS_TYPE_INTEGER, OPTIONS_TYPE_CRE_ONLY,
              (: $1->add_property( TABSTOP_PROP, $3 ) :),
              (: $1->query_property( TABSTOP_PROP ) :),
               "Show tabstops as <TAB> or as spaces");
   add_option( "output shorthand", OPTIONS_TYPE_BOOLEAN, 0,
               (: $1->add_property( SHORTHAND_OUTPUT_PROP, $3 ) :),
               (: $1->query_property( SHORTHAND_OUTPUT_PROP ) :),
               "Convert others shorthand text into long form");
   foreach (womble in USER_COLOUR_LIST) {
      add_option("colour " + womble, OPTIONS_TYPE_COLOUR, 0,
                 (: $1->set_my_colours($2[<1], $3), 1 :),
                 (: $1->colour_event($2[<1], "default") :),
                 "The colour for " + womble + " messages");
   }
   foreach (womble in ADDITIONAL_CHANNELS) {
     add_option("colour " + womble, OPTIONS_TYPE_COLOUR, OPTIONS_TYPE_CRE_ONLY,
                (: $1->set_my_colours($2[<1], $3), 1 :),
                (: $1->colour_event($2[<1], "default") :),
                "The colour for " + womble + " messages");
   }
   foreach (womble in "/secure/master"->query_domains() - NO_CHANNELS) {
     add_option("colour " + womble, OPTIONS_TYPE_COLOUR, OPTIONS_TYPE_CRE_ONLY,
                (: $1->set_my_colours($2[<1], $3), 1 :),
                 (: $1->colour_event($2[<1], "default") :),
                "The colour for " + womble + " messages");
   }
   add_option("colour inform", OPTIONS_TYPE_DYNAMIC_GROUP, 0,
              0, (: get_inform_colours :),
              "The colours of various informational messages");
   add_option("colour club", OPTIONS_TYPE_DYNAMIC_GROUP, 0,
              0, (: get_club_colours :),
              "The colour for club messages");
   add_option("terminal type", OPTIONS_TYPE_TERMINAL, 0,
              (: $1->set_term_type($3), 1 :),
              (: $1->query_term_name() :),
              "The type of terminal you are using");
   add_option("terminal rows", OPTIONS_TYPE_INTEGER, 0,
              (: $1->set_rows($3), 1 :),
              (: $1->query_rows() :),
              "The number of rows in your terminal");
   add_option("terminal cols", OPTIONS_TYPE_INTEGER, 0,
              (: $1->set_cols($3), 1 :),
              (: $1->query_cols() :),
              "The number of coloumns in your terminal");
    add_option("combat wimpy", OPTIONS_TYPE_INTEGER, 0,
              (: $1->set_wimpy($3) :),
              (: $1->query_wimpy() :),
               "The percentage of your hitpoints at which you will run away");
   add_option("combat monitor", MONITOR_OPTIONS, 0,
              (: $1->set_monitor(member_array($3, MONITOR_OPTIONS)), 1 :),
              (: MONITOR_OPTIONS[$1->query_monitor()] :),
              "The frequency of display of your combat monitor");
   add_option("combat tactics attitude",
              ({ "insane", "offensive", "neutral", "defensive", "wimp" }), 0,
              (: $1->set_combat_attitude($3), 1 :),
              (: $1->query_combat_attitude() :),
              "Your combat attitude (see help tactics)");
   add_option("combat tactics response",
              ({ "dodge", "neutral", "parry" }), 0,
              (: $1->set_combat_response($3), 1 :),
              (: $1->query_combat_response() :),
              "Your combat response (see help tactics)");
   add_option("combat tactics parry",
              ({ "left", "right", "both" }), 0,
              (: $1->set_combat_parry($3), 1 :),
              (: $1->query_combat_parry() :),
              "Which hand you will parry with (see help tactics)");
   add_option("combat tactics unarmed_parry",
              OPTIONS_TYPE_BOOLEAN, 0,
              (: $1->set_unarmed_parry($3), 1 :),
              (: $1->query_unarmed_parry() :),
              "Which hand you will parry with (see help tactics)");
   add_option("combat tactics attack",
              ({ "left", "right", "both" }), 0,
              (: $1->set_combat_attack($3), 1 :),
              (: $1->query_combat_attack() :),
              "Which hand you will attack with (see help tactics)");
#ifdef USE_SURRENDER
   add_option("combat tactics mercy",
              ({ "always", "ask", "never" }), 0,
              (: $1->set_combat_mercy($3), 1 :),
              (: $1->query_combat_mercy() :),
              "Whether or not you will show mercy to opponents");
#endif
   add_option("combat tactics focus",
              ({"upper body", "lower body", "head", "neck", "chest",
                  "abdomen", "arms", "hands", "legs", "feet", "none"}), 0,
              (: $1->set_combat_focus($3), 1 :),
              (: $1->query_combat_focus() :),
              "Which body part you will focus on in combat (see help tactics)");
#ifdef USE_DISTANCE
   add_option("combat tactics distance",
              ({"long", "medium", "close", "hand-to-hand", "none" }), 0,
              (: $1->set_combat_distance($3), 1 :),
              (: $1->query_combat_distance() :),
              "Your ideal combat distance (see help tactics)");
#endif
   add_option("combat killer",
              OPTIONS_TYPE_BOOLEAN, 1,
              (: $1->set_player_killer($3) :),
              (: $1->query_player_killer() :),
              "Whether or not you are a registered player killer");
   add_option("input ambiguous", OPTIONS_TYPE_BOOLEAN, 0,
              (: change_bool_property(OBJ_PARSER_AMBIGUOUS_PROP, $1, !$3) :),
              (: !$1->query_property(OBJ_PARSER_AMBIGUOUS_PROP) :),
              "Should the parser notify you of ambiguities");
   add_option("input andascomma", OPTIONS_TYPE_BOOLEAN, 0,
              (: change_bool_property(OBJ_PARSER_USE_AND_AS_BREAK_PROP, $1, !$3) :),
          (: !$1->query_property(OBJ_PARSER_USE_AND_AS_BREAK_PROP) :),
              "Should 'and' be treated as a comma (an inclusive list)");
   add_option("input editor", ({ "menu", "magic", "command", "ed" }), 0,
              (: $1->set_editor($3) :),
              (: $1->query_editor() :),
              "Your preferred editor");
   add_option( "input shorthand", OPTIONS_TYPE_BOOLEAN, 0,
               (: $1->add_property( SHORTHAND_PROP, $3 ) :),
               (: $1->query_property( SHORTHAND_PROP ) :),
               "Convert your shorthand typing into long form");
   foreach (womble in ({ "shout", "newbie", "cryer", "remote-soul",
                           "multiple-soul", "multiple-tell",  "teach",
                           "tell", "remote", "multiple-remote" })) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, 0,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   foreach(womble in ADDITIONAL_CHANNELS) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   foreach(womble in "/secure/master"->query_domains() - NO_CHANNELS) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   foreach(womble in ({ "lord", "intermud-all", "intercre",
                          "intergossip", "dwcre", "dwchat", "remote-spam" })) {
     add_option("earmuff events "  + womble, OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
                (: change_earmuffs($1, $2[<1], $3) :),
                (: member_array($2[<1], ($1->query_property("earmuffs")?$1->query_property("earmuffs"):({}))) != -1 :),
                "Should you be informed of " + womble + " messages");
   }
   add_option("earmuff state",
              ({ "on", "off", "allowfriends" }), 0,
              (: setup_earmuffs($1, $3) :),
              (: $1->query_earmuffs()? ($1->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF ? "allowfriends" : "on") : "off" :),
              "Enable or disable earmuffs always or just for friends");
   add_option("earmuff cut-through", ({ "off", "ask", "auto"}), 1,
              (: $1->add_property("cut earmuffed tells",
                    member_array($3, ({ "off", "ask", "auto"}))) :),
              (: ({ "off", "ask", "auto" })[$1->query_property(
                                             "cut earmuffed tells")] :),
              "Cut through a players tell earmuffs");
   add_option("command ls use_nickname", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_CRE_ONLY,
              (: $3 ? change_bool_property( LS_COMMAND_NICKNAME_PROPERTY, $1, 1 ) : change_bool_property( LS_COMMAND_NICKNAME_PROPERTY, $1, 0 ) :),
              (: $1->query_property( LS_COMMAND_NICKNAME_PROPERTY ) :),
              "Should 'ls' check for nicknames");
   foreach(womble in ERROR_TYPE) {
      womble = lower_case(womble);
      add_option("command look error " + womble, OPTIONS_TYPE_BOOLEAN,
              OPTIONS_TYPE_CRE_ONLY,
              (: change_error_reports($1, $2[<1], $3) :),
              (: member_array(upper_case($2[<1]), ($1->query_property(PLAYER_SHOW_ERRORS_PROP)?$1->query_property(PLAYER_SHOW_ERRORS_PROP):({}))) != -1 :),
              "Show the errors of type " + lower_case(womble) +
              " when doing a look.");
   }
   add_option("personal description", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_desc($3 == "none"?0:$3), 1) :),
              (: (($1->query_desc())?($1->query_desc()):"none") :),
              "Ain't you perdy");
   add_option("personal real_name", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_real_name($3 == "none"?0:$3), 1) :),
              (: (($1->query_real_name())?($1->query_real_name()):"none") :),
              "The real name displayed in your finger information");
   add_option("personal location", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_where($3 == "none"?0:$3), 1) :),
              (: (($1->query_where())?($1->query_where()):"none") :),
              "The location displayed in your finger information");
   add_option("personal home_page", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_homepage($3 == "none"?0:$3), 1) :),
              (: (($1->query_homepage())?($1->query_homepage()):"none") :),
              "The url displayed in your finger information");
   add_option("personal email", OPTIONS_TYPE_STRING, 0,
              (: strlen($3) > 30?0:($1->set_email($3 == "none"?0:$3), 1) :),
              (: (($1->query_email())?($1->query_email()):"none") :),
              "The email address displayed in your finger information");
   add_option("personal birthday", OPTIONS_TYPE_STRING, 0,
              (: (!valid_birthday($3) || $1->query_birthday())? 0:($1->set_birthday($3 == "none"?0:convert_birthday($3)), 1) :),
              (: (($1->query_birthday())?($1->query_birthday()):"none") :),
              "Your birthday");
   add_option("personal execinclude", OPTIONS_TYPE_STRING, 0,
              (: ($3=="none"?$1->remove_property(OPTION_EXEC_INCLUDE):$1->add_property(OPTION_EXEC_INCLUDE, $3)), 1 :),
              (: ($1->query_property(OPTION_EXEC_INCLUDE)?$1->query_property(OPTION_EXEC_INCLUDE):"none") :),
              "The path of files to be included in exec commands?");
   add_option("personal auto teach", OPTIONS_TYPE_BOOLEAN, 0,
              (: $3?$1->add_property(TEACH_COMMAND_AUTO_PROPERTY,$3):$1->remove_property(TEACH_COMMAND_AUTO_PROPERTY) :),
              (: $1->query_property(TEACH_COMMAND_AUTO_PROPERTY) :),
              "Are you available to auto-teach");
   add_option("personal travel",
              ({ "walk", "journey" }), 0,
              (: $3 == "walk" ?$1->remove_property(TERRAIN_MAP_LONG_JUMP_PROPERTY):$1->add_property(TERRAIN_MAP_LONG_JUMP_PROPERTY,1), 1 :),
              (: $1->query_property(TERRAIN_MAP_LONG_JUMP_PROPERTY)?"journey":"walk" :),
              "By default should you walk or journey across terrains");
   add_option("playtester protection", OPTIONS_TYPE_BOOLEAN,
              OPTIONS_TYPE_PLAYTESTER_ONLY,
              (: $3 ? $1->enable_personal_pt_protection() : $1->disable_personal_pt_protection() :),
              (: $1->query_pt_protection() :),
              "Enable or disable playtester protection");
   add_option("personal roleplaying", OPTIONS_TYPE_BOOLEAN, OPTIONS_TYPE_PLAYTESTER_ONLY,
              (: $1->set_role_playing($3), 1 :),
              (: $1->query_role_playing() :),
              "Enable or disable roleplaying mode");
}
protected void add_option_to_mapping(mapping array, string name, mixed type,
                                     int cre_only, function set_function,
                                     function query_function, string help) {
   class option fluff;
   fluff = new(class option);
   fluff->type = type;
   fluff->set = set_function;
   fluff->query = query_function;
   fluff->restriction = cre_only;
   fluff->suboptions = ([ ]);
   fluff->help = help;
   array[name] = fluff;
}
protected int add_option(string name, mixed type, int cre_only,
                         function set_function, function query_function,
                         string help) {
   string option;
   mapping stuff;
   string *path;
   path = explode(name, " ");
   stuff = _options;
   foreach (option in path[0..<2]) {
      if (!stuff[option]) {
         add_option_to_mapping(stuff, option, OPTIONS_TYPE_GROUP, cre_only,
                               0, 0, help);
      } else if (((class option)stuff[option])->type != OPTIONS_TYPE_GROUP) {
         return 0;
      }
      stuff = stuff[option]->suboptions;
   }
   add_option_to_mapping(stuff, path[<1], type, cre_only, set_function,
                         query_function, help);
   return 1;
}
private mixed query_sub_option(object player, string name, mapping tree) {
   mixed tmp;
   if (mapp(tree[name])) {
      return tree[name];
   }
   if (classp(tree[name])) {
      switch (tree[name]->restriction) {
      case OPTIONS_TYPE_CRE_ONLY:
         if (!player->query_creator()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_LORD_ONLY:
         if (!player->query_lord()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_PLAYTESTER_ONLY:
         if (!player->query_playtester()) {
            return 0;
         }
         break;
      }
      if (((class option)tree[name])->type == OPTIONS_TYPE_DYNAMIC_GROUP) {
         tmp = evaluate(tree[name]->query, player, name);
         return tmp;
      }
      if (((class option)tree[name])->type == OPTIONS_TYPE_GROUP) {
         return tree[name]->suboptions;
      }
      return tree[name];
   }
   return 0;
}
private mixed query_bottom_sub_option(object player, string* path) {
   string option;
   mixed stuff;
   if (!sizeof(path)) {
      return _options;
   }
   stuff = _options;
   foreach (option in path[0..<2]) {
      stuff = query_sub_option(player, option, stuff);
      if (!mapp(stuff)) {
         return 0;
      }
   }
   stuff = query_sub_option(player, path[<1], stuff);
   if (classp(stuff)) {
      switch (stuff->restriction) {
      case OPTIONS_TYPE_CRE_ONLY:
         if (!player->query_creator()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_LORD_ONLY:
         if (!player->query_lord()) {
            return 0;
         }
         break;
      case OPTIONS_TYPE_PLAYTESTER_ONLY:
         if (!player->query_playtester()) {
            return 0;
         }
         break;
      }
   }
   return stuff;
}
int is_option(object player, string name) {
   mixed stuff;
   string *path;
   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (!classp(stuff)) {
      return 0;
   }
   return 1;
}
int is_option_group(object player, string name) {
   mixed stuff;
   string *path;
   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (!mapp(stuff)) {
      return 0;
   }
   return 1;
}
string *query_sub_options(object player, string name) {
   mapping stuff;
   string *path;
   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (mapp(stuff)) {
      return filter(keys(stuff),
                    (: query_bottom_sub_option($2, $3 + ({ $1 })) :),
                    player, path);
   }
   return ({ });
}
string* query_option_values(object player, string name) {
   mixed stuff;
   class option opt;
   string *path;
   path = explode(name, " ");
   stuff = query_bottom_sub_option(player, path);
   if (classp(stuff)) {
      opt = stuff;
      if (intp(opt->type)) {
         switch (opt->type) {
         case OPTIONS_TYPE_BOOLEAN :
            return ({ "on", "off" });
         case OPTIONS_TYPE_BRIEF :
            return ({ "brief", "verbose" });
         case OPTIONS_TYPE_INTEGER :
            return ({ "integer" });
         case OPTIONS_TYPE_STRING :
            return ({ "string" });
         case OPTIONS_TYPE_PERCENTAGE :
            return ({ "0..100" });
         case OPTIONS_TYPE_COLOUR :
            return ({ "none", "default", "colour" });
         }
      } else {
         return opt->type;
      }
   }
   return ({ });
}
string query_option_value(object player, string path) {
   string* bits;
   mixed value;
   class option stuff;
   bits = explode(path, " ");
   stuff = query_bottom_sub_option(player, bits);
   if (classp(stuff)) {
      value = evaluate(stuff->query, player, bits);
      if (intp(stuff->type)) {
         switch (stuff->type) {
         case OPTIONS_TYPE_BRIEF:
            if (value) {
               value = "verbose";
            } else {
               value = "brief";
            }
            break;
         case OPTIONS_TYPE_BOOLEAN :
            if (value) {
               value = "on";
            } else {
               value = "off";
            }
            break;
         case OPTIONS_TYPE_COLOUR :
            if (value == "") {
               value = "[none]";
            } else if (value == "default") {
               value = "[default]";
            } else {
               value = "[" + value + "" +
                       lower_case(replace(value, ({ "%^%^", " ", "%^", "" }))) +
                       "%^RESET%^]";
            }
            break;
         default :
         }
      }
      return value + "";
   }
}
string query_option_help(object player, string path) {
  string *bits;
  mixed stuff;
  bits = explode(path, " ");
  stuff = query_bottom_sub_option(player, bits);
  if (classp(stuff)) {
    return copy(stuff->help);
  }
  return "";
}
int set_option_value(object player, string path, string value) {
   string* bits;
   string* bad;
   mixed set_value;
   class option stuff;
   bits = explode(path, " ");
   stuff = query_bottom_sub_option(player, bits);
   if (classp(stuff)) {
      if (pointerp(stuff->type)) {
         if (member_array(value, stuff->type) == -1) {
            add_failed_mess("You must set your type to one of " +
                            query_multiple_short(stuff->type) + ".\n");
            return 0;
         }
         set_value = value;
      } else switch (stuff->type) {
      case OPTIONS_TYPE_BRIEF:
         if (value == "verbose") {
            set_value = 1;
         } else if (value == "brief") {
            set_value = 0;
         } else {
            return 0;
         }
         break;
      case OPTIONS_TYPE_BOOLEAN :
         if (value == "on" || value == "true") {
            set_value = 1;
         } else if (value == "off" || value == "false") {
            set_value = 0;
         } else {
            return 0;
         }
         break;
      case OPTIONS_TYPE_PERCENTAGE :
      case OPTIONS_TYPE_INTEGER :
         if (sscanf(value, "%d", set_value) != 1) {
            return 0;
         }
         if (stuff->type == OPTIONS_TYPE_PERCENTAGE &&
             (set_value < 0 || set_value > 100)) {
            add_failed_mess("Value must be between 0 and 100.\n");
            return 0;
         }
         break;
      case OPTIONS_TYPE_COLOUR :
         if (value == "none" || value == "default") {
            set_value = value;
         } else {
            set_value = map(explode(value, " "),
                         (: upper_case($1) :));
            bad = filter(set_value, (: member_array($1, _colours) == -1 :));
            if (sizeof(bad)) {
               add_failed_mess("Bad colours " + implode(bad, " ") + ".\n");
               return 0;
            }
            set_value = "%^" + implode(set_value, (: $1 + "%^ %^" + $2 :)) + "%^";
         }
         break;
      default :
         set_value = value;
         break;
      }
      return evaluate(stuff->set, player, bits, set_value);
   }
   return 0;
}
private mapping get_inform_colours(object player) {
   string* colours;
   string womble;
   mapping ret;
   string index;
   if (player->query_creator()) {
      index = "colour 1";
   } else if (player->query_lord()) {
      index = "colour 2";
   } else {
      index = "colour 0";
   }
   if (_cache_input[index]) {
      return _cache_input[index];
   }
   colours = player->query_inform_types();
   ret = ([ ]);
   foreach (womble in colours) {
      add_option_to_mapping(ret, womble, OPTIONS_TYPE_COLOUR, 0,
                            (: $1->set_my_colours($2[<1], $3), 1 :),
                            (: $1->colour_event($2[<1], "default") :),
                            "The colour of " + womble + " informs");
   }
   _cache_input[index] = ret;
   return ret;
}
private mapping get_club_colours(object player) {
   string* colours;
   string womble;
   mapping ret;
   string index;
   index = "colour " + player->query_name();
   if (_cache_input[index]) {
      return _cache_input[index];
   }
   colours = map(this_player()->query_player_clubs(),
                 (: CLUB_HANDLER->normalise_name($1) :) );
   ret = ([ ]);
   foreach (womble in colours) {
      add_option_to_mapping(ret, womble, OPTIONS_TYPE_COLOUR, 0,
                            (: $1->set_my_colours("club_" + $2[<1], $3), 1 :),
                            (: $1->colour_event("club_" + $2[<1], "default") :),
                            "The colour for " + womble + " club messages");
   }
   _cache_input[index] = ret;
   call_out((: map_delete(_cache_input, $1) :), 5 * 60, index);
   return ret;
}
private int change_bool_property(string prop, object player, int new_value) {
   if (new_value) {
      player->add_property(prop, 1);
   } else {
      player->remove_property(prop);
   }
   return 1;
}
private int setup_earmuffs(object player, string ear) {
   switch (ear) {
   case "on" :
      if (!player->query_earmuffs()) {
         player->toggle_earmuffs();
      } else if (player->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF) {
         player->toggle_earmuffs();
         player->toggle_earmuffs();
      }
      break;
   case "off" :
      if (player->query_earmuffs()) {
         player->toggle_earmuffs();
      }
      break;
   case "allowfriends" :
      player->set_allow_friends_earmuffs();
      break;
   }
   return 1;
}
private int change_error_reports(object player, string error, int new_value) {
   string *on;
   on = player->query_property(PLAYER_SHOW_ERRORS_PROP);
   if (!on) {
      on = ({ });
   }
   error = upper_case(error);
   if (new_value) {
      if (member_array(error, on) == -1) {
         on += ({ error });
         player->add_property(PLAYER_SHOW_ERRORS_PROP, on);
      }
   } else {
      on -= ({ error });
      player->add_property(PLAYER_SHOW_ERRORS_PROP, on);
   }
   return 1;
}
private int change_earmuffs(object player, string ear, int new_value) {
   string *on;
   on = player->query_property("earmuffs");
   if (!on) {
      on = ({ });
   }
   if (new_value) {
      if (member_array(ear, on) == -1) {
         on += ({ ear });
         player->add_property("earmuffs", on);
      }
   } else {
      on -= ({ ear });
      player->add_property("earmuffs", on);
   }
   return 1;
}
private int valid_birthday(string str) {
#define LENGTHS ({ 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 })
  int tot, month, day;
  if(strlen(str) != 4) {
    return 0;
  }
  if(!sscanf(str, "%d", tot)) {
    return 0;
  }
  month = tot % 100;
  day = tot / 100;
  if(month > 12 || month < 1) {
    return 0;
  }
  if(day < 1) {
    return 0;
  }
  return day <= LENGTHS[month];
}
string convert_birthday(string str) {
#undef MONTHS
#define MONTHS ({ "January", "February", "March", "April", "May", "June", \
      "July", "August", "September", "October", "November", "December" })
  int day, month, tot;
  string retval;
  sscanf(str, "%d", tot);
  day = tot / 100;
  month = tot % 100;
  switch(day) {
    case 11:
      retval = "11th"; break;
    case 12:
      retval = "12th"; break;
    case 13:
      retval = "13th"; break;
    default:
      switch(day%10) {
        case 1:
          retval = day+"st"; break;
        case 2:
          retval = day+"nd"; break;
        case 3:
          retval = day+"rd"; break;
        default:
          retval = day+"th";
      }
  }
  return retval + " of " + MONTHS[month-1];
}

==================================================
FILE: handlers/parcel.c
==================================================

#define BASE_PATH "/save/parcels/"
#define SAVE_PATH BASE_PATH + location + "/" + name[0..0]
#define SAVE_FILE BASE_PATH + location + "/" + name[0..0] + "/" + name + ".o"
#define POST_LOG "PARCEL_LOG"
inherit "/global/auto_load";
#undef USE_COMPRESSION
#include <player_handler.h>
class parcel {
  string from;
  string *autoloadinfo;
  int exp_time;
}
mapping parcels;
private nosave string _current_name, _current_location;
nosave class parcel *_parcels;
int test_expire( class parcel temp );
void create() {
  string dir;
  seteuid( master()->creator_file( base_name( this_object() ) ) );
  parcels = ([ ]);
  if(parcels) {
    parcels = copy(parcels);
    parcels = ([ ]);
  }
  _parcels = ({ });
}
private void save_file(string name, string location) {
  string str;
  map_delete(parcels, name);
  if(sizeof(keys(parcels)))
    unguarded( (: save_object, SAVE_PATH, 2 :));
  if(file_size(SAVE_PATH) == -1)
    unguarded( (: mkdir, SAVE_PATH :) );
  if(_parcels != ({ })) {
    str = save_variable(_parcels);
#ifdef USE_COMPRESSION
    if(!ungarded( (: write_buffer, SAVE_FILE + ".gz", 0, compress(str) :) ))
#else
    if(!unguarded((: write_file, SAVE_FILE, str, 1 :) ))
#endif
      log_file(POST_LOG, "%s: error writing to %s\n",
               ctime(time()), SAVE_FILE);
  } else {
    if(file_size(SAVE_FILE) > 0)
      unguarded( (: rm, SAVE_FILE :));
    if(file_size(SAVE_FILE+".gz") > 0)
      unguarded( (: rm, SAVE_FILE + ".gz" :));
  }
}
private void load_file( string name, string location ) {
  if(_current_name == name && _current_location == location)
    return;
#ifdef USE_COMPRESSION
  if(file_size(SAVE_FILE + ".gz") > 0) {
    _parcels = restore_variable(uncompress(read_file(SAVE_FILE)));
  } else
#endif
  if(file_size(SAVE_FILE) > 0) {
    debug_printf("%s", SAVE_FILE);
    _parcels = restore_variable(unguarded( (: read_file, SAVE_FILE :) ));
  } else if (file_size(SAVE_PATH+ ".o.gz") > 0) {
    unguarded( (: restore_object, SAVE_PATH+".o.gz" :));
    _parcels = parcels[name];
  } else if(file_size(SAVE_PATH+".o") > 0) {
    unguarded( (: restore_object, SAVE_PATH :) );
    _parcels = parcels[name];
  } else {
    parcels = ([ ]);
    _parcels = ({ });
  }
  _current_name = name;
  _current_location = location;
}
public int deposit(string to, string from, string location, object *obs) {
  class parcel temp;
  object boxy;
  string obsstuff, tmp;
  obsstuff = "/global/events"->convert_message(query_multiple_short (obs));
  if(!PLAYER_HANDLER->test_user(to))
    return 0;
#ifndef __DISTRIBUTION_LIB__
    if("/secure/alist"->query_alt(from, to) == 100) {
      tmp = capitalize(from) + " sent a parcel containing " +
        obsstuff + " to his/her alt " + capitalize(to) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    } else if("/secure/alist"->query_alt(from, to) > 40) {
      tmp = capitalize(from) + " sent a parcel containing " +
        obsstuff + " to his/her POSSIBLE alt "+ capitalize(to) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    }
#endif
  load_file(to, location );
  if(undefinedp(_parcels) || !arrayp(_parcels))
    _parcels = ({ });
  boxy = clone_object("/obj/baggage");
  boxy->set_name("boxy");
  boxy->set_max_weight(100000);
  obs->move( boxy );
  temp = new( class parcel,
              from : from,
              exp_time: time() + ( 14 * 24 * 60 * 60));
  temp->autoloadinfo = create_auto_load( ({ boxy }), 0 );
  _parcels += ({ temp });
  save_file(to, location);
  boxy->dest_me();
  log_file (POST_LOG, "%s: %s deposited %s at %s for %s.\n", ctime(time()),
      from, obsstuff, location, to);
}
public int collect(string name, string location, object target, int copy) {
  class parcel temp;
  object *box_array = ({ });
  object *obs = ({ });
  string tmp;
  load_file(name, location );
  if(!_parcels || _parcels == ({ }))
    return 0;
  foreach(temp in _parcels) {
    box_array += load_auto_load_to_array(temp->autoloadinfo, this_player());
#ifndef __DISTRIBUTION_LIB__
    obs = all_inventory(box_array[<1]);
    if("/secure/alist"->query_alt(name, temp->from) == 100) {
      tmp = capitalize(name) + " received a parcel containing " +
        "/global/events"->convert_message(query_multiple_short(obs)) +
        " from his/her alt " + capitalize(temp->from) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    } else if("/secure/alist"->query_alt(name, temp->from) > 40) {
      tmp = capitalize(name) + " received a parcel containing " +
        "/global/events"->convert_message(query_multiple_short(obs)) +
        " from his/her POSSIBLE alt "+ capitalize(temp->from) + ".";
      user_event("inform", tmp, "multiplayer");
      log_file("MULTIPLAYERS", ctime(time()) + ": " +
               this_player()->convert_message(tmp) + "\n");
    }
#endif
  }
  foreach( object box in box_array ) {
    obs += all_inventory (box);
    all_inventory( box )->move( target );
    box->dest_me();
  }
  if ( !copy )
    _parcels = ({ });
  log_file (POST_LOG, "%s: %s collected %s at %s.\n", ctime(time()),
            name, "/global/events"->convert_message(query_multiple_short(obs)),
            location);
  save_file(name, location);
  return 1;
}
class parcel *queryparcels_for(string name, string location) {
  load_file(name, location);
  return _parcels;
}
void do_migrate(int letter, string location) {
  string name;
  class parcel temp2;
  tell_creator("ceres", "Processing %c in %s\n", letter, location);
  load_file(sprintf("%c", letter), location);
  foreach(name, temp2 in parcels) {
    _parcels = filter(temp2, (: test_expire :));
    save_file(name, location);
  }
  if(!sizeof(keys(parcels))) {
    name = BASE_PATH + location + "/" + sprintf("%c", letter) + ".o.gz";
    unguarded((: rm, name :));
  }
  if(letter < 'z') {
    letter++;
    call_out("do_migrate", 15 + random(30), letter, location);
  }
}
int test_expire(class parcel temp ) {
  if ( temp->exp_time > time() )
    return 1;
  return 0;
}
void player_refreshed(mixed name, int total ) {
  string location;
  string *dirs = map( filter( get_dir( BASE_PATH, -1 ),
                              (: $1[1] == -2 :) ), (: $1[0] :) );
  if (objectp(name))
    name = name->query_name();
  foreach(location in dirs) {
    load_file(name, location);
    map_delete(parcels, name);
    save_file(name, location);
  }
}

==================================================
FILE: handlers/pattern_compiler.c
==================================================

#include <user_parser.h>
#define PATTERN_CACHE_SIZE 200
nosave mapping patterns;
nosave mapping pattern_short;
nosave string *pattern_order;
nosave int hits, reqs, cache_callout;
nomask mixed *compile_pattern(string str);
void create() {
   patterns = ([ "" : ({ 100 }) ]);
   pattern_short = ([ "" : "" ]);
}
void clean_cache() {
  int i;
  for(i=0; i<(sizeof(pattern_order)-PATTERN_CACHE_SIZE); i++) {
    map_delete(patterns, pattern_order[i]);
    map_delete(pattern_short, pattern_order[i]);
  }
  pattern_order = pattern_order[i..];
  cache_callout = 0;
}
nomask mixed *query_pattern(string pattern) {
  if (!patterns[pattern]) {
    patterns[pattern] = compile_pattern(pattern);
  }
  return patterns[pattern];
}
nomask mixed *compile_pattern(string str) {
   mixed *pattern;
   mixed *bits;
   int i;
   int failed;
   int type;
   int weight;
   mixed env;
   string short;
   string short_bit;
   int pos;
   int pos2;
   int j;
   int k;
   bits = explode(str, " ") - ({ 0, "" });
   pattern = ({ });
   short = "";
   for (i = 0; i < sizeof(bits) && !failed; i++) {
      switch (bits[i][0]) {
      case '<' :
         pos = strsrch(bits[i], "'");
         if (pos != -1) {
             pos2 = strsrch(bits[i][pos + 1..], "'", pos + 1);
             if (pos2 == -1) {
                for (j = i + 1; j < sizeof(bits); j++) {
                   pos2 = strsrch(bits[j], "'");
                   if (pos2 != -1) {
                      break;
                   }
                }
                if (j < sizeof(bits)) {
                   for (k = i + 1; k <= j; k++) {
                      bits[i] += " " + bits[k];
                   }
                   bits[j] = bits[i];
                   i = j;
                   pos2 = strsrch(bits[i], "'", -1);
                }
             } else {
                pos2 += pos + 1;
             }
             if (pos2 != -1) {
                short_bit = bits[i][pos+1..pos2-1];
                bits[i] = bits[i][0..pos-1] + bits[i][pos2+1..];
             } else {
                short_bit = 0;
             }
         } else {
             short_bit = 0;
         }
         bits[i] = bits[i][1..<2];
         bits[i] = explode(bits[i], ":");
         if (!bits[i]) {
            bits[i] = ({ "" });
         }
         switch (bits[i][0]) {
         case "direct" :
            weight += 7;
            if (sizeof(bits[i]) > 1) {
               switch (bits[i][1]) {
               case "living" :
                  type = LIVING;
                  break;
               case "distant-living" :
                  type = DISTANT_LIVING;
                  break;
               case "any-living" :
                  type = ANY_LIVING;
                  break;
               case "object" :
                  type = ANY_OBJECT;
                  break;
               case "player" :
                  type = TARGET_PLAYER;
                  break;
               default :
                  failed = 1;
                  printf("Unknown type of direct (%s).\n", bits[i][1]);
                  break;
               }
               if (!short_bit) {
                   short += "<"+bits[i][1]+"> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            } else {
               type = ANY_OBJECT;
               bits[i] += ({ "object" });
               if (!short_bit) {
                  short += "<object> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            }
            env = ENV_ME_HERE;
            if (sizeof(bits[i]) > 2)
               switch (bits[i][2]) {
               case "here" :
                  env = ENV_HERE;
                  break;
               case "me" :
                  env = ENV_ME;
                  break;
               case "direct-obs" :
                  env = ENV_DIRECT_OBS;
                  break;
               case "me-here" :
                  env = ENV_ME_HERE;
                  break;
               case "here-me" :
                  env = ENV_HERE_ME;
                  break;
               default :
                  env = bits[i][2];
                  break;
               }
            pattern += ({ DIRECT_OBJECT, type, env });
            break;
         case "indirect" :
            weight += 7;
            if (sizeof(bits[i]) > 1) {
               switch (bits[i][1]) {
               case "living" :
                  type = LIVING;
                  break;
               case "distant-living" :
                  type = DISTANT_LIVING;
                  break;
               case "any-living" :
                  type = ANY_LIVING;
                  break;
               case "object" :
                  type = ANY_OBJECT;
                  break;
               case "player" :
                  type = TARGET_PLAYER;
                  break;
               case "wiz-present" :
                  type = WIZ_PRESENT_TARGET;
                  break;
               default :
                  failed = 1;
                  printf("Unknown type of indirect (%s).\n", bits[i][1]);
                  break;
               }
               if (!short_bit) {
                  short += "<"+bits[i][1]+"> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            } else {
               type = ANY_OBJECT;
               bits[i] += ({ "object" });
               if (!short_bit) {
                  short += "<object> ";
               } else {
                   short += "<" + short_bit + "> ";
               }
            }
            env = ENV_ME_HERE;
            if (sizeof(bits[i]) > 2)
               switch (bits[i][2]) {
               case "here" :
                  env = ENV_HERE;
                  break;
               case "me" :
                  env = ENV_ME;
                  break;
               case "direct-obs" :
                  env = ENV_DIRECT_OBS;
                  break;
               case "me-here" :
                  env = ENV_ME_HERE;
                  break;
               case "here-me" :
                  env = ENV_HERE_ME;
                  break;
               default :
                  env = bits[i][2];
                  break;
               }
            pattern += ({ INDIRECT_OBJECT, type, env });
            break;
         case "string" :
            if (sizeof(bits[i]) > 1) {
               switch (bits[i][1]) {
               case "small" :
                  if (!short_bit) {
                     short += "<string> ";
                  } else {
                     short += "<" + short_bit + "> ";
                  }
                  weight += 6;
                  pattern += ({ SHORT_STRING });
                  break;
               case "long" :
                  if (!short_bit) {
                     short += "<string> ";
                  } else {
                     short += "<" + short_bit + "> ";
                  }
                  weight += 5;
                  pattern += ({ STRING });
                  break;
               case "quoted" :
                  if (!short_bit) {
                     short += "\"<string>\" ";
                  } else {
                     short += "\"<" + short_bit + ">\" ";
                  }
                  weight += 8;
                  pattern += ({ QUOTED_STRING });
                  break;
               default :
                  printf("Invalid type of string (%s).\n", bits[i][1]);
                  failed = 1;
                  break;
               }
            } else {
               if (!short_bit) {
                  short += "<string> ";
               } else {
                  short += "<" + short_bit + "> ";
               }
               weight += 5;
               pattern += ({ STRING });
            }
            break;
         case   "number" :
            if (!short_bit) {
               short += "<number> ";
            } else {
               short += "<" + short_bit + "> ";
            }
            weight += 10;
            pattern += ({ NUMBER });
            break;
         case "word" :
            if (!short_bit) {
               short += "<word> ";
            } else {
               short += "<" + short_bit + "> ";
            }
            weight += 7;
            pattern += ({ SINGLE_WORD });
            break;
         case "fraction" :
            if (!short_bit) {
               short += "<fraction> ";
            } else {
               short += "<" + short_bit + "> ";
            }
            weight += 10;
            pattern += ({ FRACTION });
            break;
         default :
            weight += 10;
            bits[i] = implode(bits[i], ":");
            if (master()->query_word_list(bits[i])
                  || this_player()->query_word_list(bits[i])) {
               if (!short_bit) {
                  short += "<"+bits[i]+"> ";
               } else {
                  short += "<" + short_bit + "> ";
               }
               pattern += ({ WORD_LIST, bits[i] });
            } else {
               printf("Unknown word list name (%s)\n", bits[i]);
               failed = 1;
            }
            break;
         }
         break;
      case '{' :
         weight += 10;
         if (bits[i][<1] == '}') {
            pattern += ({ WORD_LIST, explode(bits[i][1..<2], "|") });
            short += bits[i]+" ";
         } else {
            int old = i;
            string elm, *res;
            for (++i; bits[i][<1] != '}'; i++);
            res = ({});
            foreach (elm in explode(implode(bits[old..i], " ")[1..<2], "|"))
               res += ({ explode(elm, " ") });
            pattern += ({ WORD_LIST_SPACES, res });
            short += implode(bits[old..i], " ")+" ";
         }
         break;
      case '[' :
         weight += 4;
         if (bits[i][1] == '<') {
            if (MASTER->query_word_list(bits[i][2..<3])
                  || this_player()->query_word_list(bits[i][2..<3]))
               pattern += ({ OPTIONAL, bits[i][2..<3] });
            else {
               printf("Unknown word list name (%s)\n", bits[i]);
               failed = 1;
               pattern += ({ OPTIONAL, bits[i][2..<3] });
            }
            short += bits[i]+" ";
         } else if (bits[i][1] == '{') {
            if (bits[i][<1] == ']') {
               pattern += ({ OPTIONAL, explode(bits[i][2..<3], "|") });
               short += bits[i]+" ";
            } else {
               int old = i;
               string elm, *res;
               for (++i; bits[i][<1] != ']'; i++);
               res = ({});
               foreach (elm in explode(implode(bits[old..i], " ")[2..<3], "|"))
                  res += ({ explode(elm, " ") });
               pattern += ({ OPTIONAL_SPACES, res });
               short += implode(bits[old..i], " ")+" ";
            }
         } else if (bits[i][<1] == ']') {
            pattern += ({ OPTIONAL, explode(bits[i][1..<2], "|") });
            short += bits[i]+" ";
         } else {
            int old = i;
            string elm, *res;
            for (++i; bits[i][<1] != ']'; i++);
            res = ({});
            foreach (elm in explode(implode(bits[old..i], " ")[1..<2], "|"))
               res += ({ explode(elm, " ") });
            pattern += ({ OPTIONAL_SPACES, res });
            short += implode(bits[old..i], " ")+" ";
         }
         break;
      default :
         weight += 10;
         short += bits[i]+" ";
         pattern += ({ WORD_LIST, ({ bits[i] }) });
         break;
      }
   }
   if (failed) {
      return 0;
   }
   pattern_short[str] = short;
   return ({ weight }) + pattern;
}
string query_short_pattern(string str) {
  reqs++;
  if(!pattern_short[str])
    compile_pattern(str);
  else
    hits++;
  return pattern_short[str];
}
mixed *stats() {
  return  ({
    ({ "patterns", sizeof(keys(pattern_short)), }),
        ({ "requests", reqs, }),
          ({ "cache hit percent", (hits * 100) / reqs, }),
            });
}

==================================================
FILE: handlers/peopler.c
==================================================

#include <peopler.h>
#define MULTIPLAYER "/obj/handlers/multiplayer"
string *de_names,
       *abbrev,
       *var_names;
void create() {
  de_names = DE_NAMES;
  abbrev = ABBREV;
  var_names = ({
      "dirs",
      "netstat",
      "people",
      "qpeople",
      "terms",
      "netdups",
    });
}
object *get_people(string str) {
  object *ob;
  int i;
  string s1;
  ob = users();
  for(i = 0; i<sizeof(ob); i++) {
    if (str && (sscanf(ob[i]->query_name(),str+"%s", s1) != 1)) {
      ob = ob[0..i - 1] + ob[i+1..];
      i--;
    }
  }
  return ob;
}
private string create_title(mixed *bits) {
  int i, pos;
  string str;
  str = "";
  for (i=0;i<sizeof(bits);i+=2) {
    if ((pos = (bits[i]&~MASK)) == STRING)
      str += bits[i+1];
    else
      if (strlen(de_names[pos]) > bits[i+1])
        str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"s", "");
      else
        switch (bits[i]&MASK) {
          case CENTER :
            str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"|s", de_names[pos]);
            break;
          case RIGHT :
            str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"s", de_names[pos]);
            break;
          default :
            str += sprintf("%"+bits[i+1]+"."+bits[i+1]+"-s", de_names[pos]);
            break;
        }
  }
  return str;
}
private string review_thingy(mixed *bing) {
  int i;
  string str;
  str = "";
  for (i = 0; i < sizeof(bing); i += 2) {
    if (bing[i] == STRING) {
      str += bing[i+1];
    } else {
      switch (bing[i]&MASK) {
        case CENTER :
          str += "%|"+bing[i+1]+abbrev[bing[i]&~MASK];
          break;
        case RIGHT :
          str += "%"+bing[i+1]+abbrev[bing[i]&~MASK];
          break;
        default :
          str += "%-"+bing[i+1]+abbrev[bing[i]&~MASK];
          break;
      }
    }
  }
  return str;
}
private void print_entrys(object *obs, mixed *format, int with_dups,
                          string constraint) {
  int age, j;
  mixed g;
  string form, str, mess, *not_allowed;
  object ob, env, *dups;
  mapping per_ip;
  reset_eval_cost();
  if (with_dups) {
    per_ip = unique_mapping(obs, (: query_ip_number($1) :));
  }
  mess = sprintf("%s\n", create_title(format));
  foreach(ob in obs) {
    str = "";
    for (j=0;j<sizeof(format);j+=2) {
      switch (format[j]&MASK) {
        case RIGHT :
          form = "%"+format[j+1]+"."+format[j+1];
          break;
        case CENTER :
          form = "%|"+format[j+1]+"."+format[j+1];
          break;
        default :
          form = "%-"+format[j+1]+"."+format[j+1];
          break;
      }
      switch (format[j]&~MASK) {
        case STRING :
          str += format[j+1];
          break;
        case C_NAME :
          str += sprintf(form+"s", capitalize( (string)ob->query_name() ) );
          break;
        case GENDER :
          str += sprintf(form+"s", ob->query_gender_string());
          break;
        case NAME :
          str += sprintf(form+"s", (ob->query_in_editor()?"*":"")+
              ( ob->query_invis() ? "("+ (string)ob->query_name() +")" :
              (string)ob->query_name() ) );
          break;
        case GUILD :
          if(ob)
            str += sprintf(form+"s",
                           ((g=(object)ob->query_guild_ob())?
                            g->query_name():"No guild"));
          else
            str += sprintf(form+"s", "Broken guild");
          break;
        case LEVEL :
          str += sprintf(form+"s", ""+ ob->query_level());
          break;
        case ROWS :
          str += sprintf(form+"s", ""+ ob->query_rows());
          break;
        case COLS :
          str += sprintf(form+"s", ""+ ob->query_cols());
          break;
        case TERMINAL :
          str += sprintf(form+"s",
                         ((g = ob->query_term_name()) ?
                          g + (g == "network" ? " (" +
                               ob->query_cur_term() + ")" : "") : ""));
          break;
        case IP_NUMBER :
          str += sprintf(form+"s", query_ip_number(ob));
          break;
        case IP_NAME :
          str += sprintf(form+"s",
                           (query_ident(ob)?query_ident(ob)+"@":"")+
                           query_ip_name(ob));
          break;
        case TYPE :
          str += sprintf(form+"s", ob->query_object_type()+"");
          break;
        case AGE :
          age = (int)ob->query_time_on();
          if (age < -86400)
            str += sprintf(form+"s", (age/-86400)+"D");
          else if (age < -3600)
            str += sprintf(form+"s", (age/-3600)+"h");
          else if (age < -60)
            str += sprintf(form+"s", (age/-60)+"m");
          else
            str += sprintf(form+"s", (age/-1)+"s");
          break;
        case ROOM :
          env = environment(ob);
          str += sprintf(form+"s",env?file_name(env):"No environment");
          break;
        case EUID :
          env = environment(ob);
          str += sprintf(form+"s",env?geteuid(env):"No environment");
          break;
        case UID :
          env = environment(ob);
          str += sprintf(form+"s",env?getuid(env):"No environment");
          break;
        case CFILE :
          env = environment(ob);
          str += sprintf(form+"s",env?"/secure/master"->creator_file(env)
                         :"No environment");
          break;
        case CUR_DIR :
          str += sprintf(form+"s", (ob->query_current_path()?
                                    ob->query_current_path():"No dir"));
          break;
        case ND_ALLOWED :
          dups = per_ip[query_ip_number(ob)] - ({ ob });
          not_allowed = MULTIPLAYER->check_allowed(ob, dups);
          str += sprintf(form+"s", (sizeof(not_allowed) ?
                                    query_multiple_short(not_allowed) :
                                    ""));
          break;
      }
    }
    if(!constraint || strsrch(str, constraint) != -1)
      mess += sprintf("%s\n", str);
  }
  this_player()->more_string( mess );
}
int do_command(mixed *pattern, string constraint, function sort_func,
               int only_duplicates) {
   object *obs;
   object *tmpobs;
   int i;
   obs = get_people("");
   if (!sizeof(obs)) {
      notify_fail("Nobody seems to start with '" + constraint + "'.\n");
      return 0;
   }
   if (!sort_func) {
      sort_func = (: strcmp($1->query_name(), $2->query_name()) :);
   }
   obs = sort_array(obs, sort_func);
   if (only_duplicates) {
      tmpobs = ({ });
      for (i = 1; i <sizeof(obs); i++) {
         if (!evaluate(sort_func, obs[i - 1], obs[i])) {
            if (member_array(obs[i - 1], tmpobs) == -1) {
               tmpobs += obs[i - 1..i];
            } else {
               tmpobs += ({ obs[i] });
            }
         }
      }
      if (!sizeof(tmpobs)) {
         notify_fail("Unable to find any duplicates.\n");
         return 0;
      }
      obs = tmpobs;
   }
   print_entrys(obs, pattern, only_duplicates, constraint);
   return 1;
}
int review() {
  mixed *bing;
  bing = (mixed *)this_player()->query_property("people list");
  if (!bing)
    bing = P_DEFAULT;
  write("People : "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("qpeople list");
  if (!bing)
    bing = QP_DEFAULT;
  write("Qpeople: "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("netstat list");
  if (!bing)
    bing = N_DEFAULT;
  write("Netstat: "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("term list");
  if (!bing)
    bing = T_DEFAULT;
  write("Terms  : "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("dir list");
  if (!bing)
    bing = D_DEFAULT;
  write("Dirs   : "+review_thingy(bing)+"\n");
  bing = (mixed *)this_player()->query_property("netdup list");
  if (!bing)
    bing = ND_DEFAULT;
  write("Netdups: "+review_thingy(bing)+"\n");
}
private mixed *create_review(string str) {
  string *bits, rest;
  int i, bing, width, tmp;
  mixed *ret;
  bits = explode("$"+str, "%");
  bits[0] = bits[0][1..];
  if (!strlen(bits[0]))
    ret = ({ });
  else
    ret = ({ STRING, bits[0] });
  for (i=1;i<sizeof(bits);i++) {
    bing = RIGHT;
    rest = bits[i];
    if (rest[0] == '|') {
      bing = CENTER;
      rest = rest[1..];
    } else if (rest[0] == '-') {
      bing = 0;
      rest = rest[1..];
    }
    if (sscanf(rest, "%d%s", width, rest) == 2) {
      tmp = member_array(rest[0..0], abbrev);
      if (tmp == -1) {
        write("Unknown thingy '"+rest[0..0]+"'\n");
        return 0;
      }
      ret += ({ tmp+bing, width });
      rest = rest[1..];
      if (strlen(rest))
        ret += ({ STRING, rest });
    } else {
      ret += ({ STRING, bits[i] });
    }
  }
  return ret;
}
private void list_matches() {
  int i;
  for (i=0;i<sizeof(de_names);i++) {
    if (i == STRING) continue;
    printf("%s: %s\n", abbrev[i], de_names[i]);
  }
}
int set_var(string str) {
  string name, type;
  mixed *bing;
  if (str == "help") {
    write("The non helpful help.\nThis is the list of things that go after "+
          "the %'s in the value.\n");
    list_matches();
    return 1;
  }
  if (!str || sscanf(str, "%s %s", name, type) != 2) {
    notify_fail("Syntax: "+query_verb()+" <var_name> <value>\n"+
                "        "+query_verb()+" help\n");
    return 0;
  }
  if (member_array(name, var_names) == -1) {
    notify_fail("You cannot set the var "+name+", it has to be one of "+
                implode(var_names[0..<2], ", ")+" or " + var_names[<1] +
                ".\n");
    return 0;
  }
  bing = create_review(type);
  if (!bing)
    return 1;
  this_player( 1 )->add_property( name +" list", bing );
  write("Ok, set var "+name+" to "+type+".\n");
  return 1;
}

==================================================
FILE: handlers/philosophies.c
==================================================

#define SAVE_FILE "/save/philosophies"
#define SAVE_DIR "/save/philosophies/"
#define PHILOSOPHY_TYPE 0
#define PHILOSOPHY_BONUS 1
#define PHILOSOPHY_NEEDED 2
#define PHILOSOPHY_EFFECT 3
#define PHILOSOPHY_ARGUMENTS 4
nosave string current_person, current_philosophies;
mapping philosophies;
void create() {
  seteuid( (string)"/secure/master"->
           creator_file( file_name( this_object() ) ) );
   philosophies = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE :) );
}
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }
mapping query_philosophies() { return philosophies; }
string *query_philosophy_names() { return keys( philosophies ); }
int query_philosophy( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return 1;
}
void add_philosophy( string name, string type, int bonus, string needed,
      string effect ) {
   philosophies[ name ] = ({ type, bonus, needed, effect, ([ ]) });
   save_me();
}
void remove_philosophy( string name ) {
   if ( !philosophies[ name ] ) {
      return;
   }
   map_delete( philosophies, name );
   save_me();
}
string query_philosophy_type( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_TYPE ];
}
int query_philosophy_bonus( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_BONUS ];
}
string query_philosophy_needed( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_NEEDED ];
}
string query_philosophy_effect( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_EFFECT ];
}
mapping query_philosophy_all_arguments( string name ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return copy( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ] );
}
mixed query_philosophy_argument( string name, string argument ) {
   if ( !philosophies[ name ] ) {
      return 0;
   }
   return philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ];
}
void add_philosophy_argument( string name, string argument, mixed args ) {
   if ( !philosophies[ name ] ) {
      return;
   }
   if ( !undefinedp( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ] ) ) {
      return;
   }
   philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ] = args;
   save_me();
}
void remove_philosophy_argument( string name, string argument ) {
   if ( !philosophies[ name ] ) {
      return;
   }
   if ( undefinedp( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ][ argument ] ) ) {
      return;
   }
   map_delete( philosophies[ name ][ PHILOSOPHY_ARGUMENTS ], argument );
   save_me();
}
string *query_all_known( string person ) {
   string *oldstuff, *newstuff = ({}), key;
  if ( person != current_person ) {
     if(unguarded((: file_length, SAVE_DIR + person[0..0]+"/"+person :)) < 1) {
       current_philosophies = "";
     } else {
       current_philosophies = unguarded((:read_file,
         SAVE_DIR+person[0..0]+"/"+person:));
     }
  }
  oldstuff = explode(current_philosophies, "\n");
  foreach ( key in oldstuff ) {
     if ( member_array( key, newstuff ) == -1 ) {
          newstuff += ({ key });
      }
  }
  current_person = person;
  return newstuff;
}
int query_known( string person, string argument ) {
  if(person != current_person) {
    current_philosophies = "";
    if( unguarded( (: file_length,
		    SAVE_DIR + person[0..0]+"/"+person :) ) < 1 ) {
      current_person = person;
      return 0;
    }
    current_person = person;
    current_philosophies =
      unguarded( (: read_file, SAVE_DIR +  person[0..0]+"/"+person :) );
  }
  return (member_array(argument,explode(current_philosophies ,"\n")) != -1);
}
void add_known( string person, string argument ) {
   string *oldstuff, *newstuff = ({}), key;
   if ( !query_known( person, argument ) ) {
      if( !current_philosophies ) {
         current_philosophies = "";
      }
      current_philosophies += argument +"\n";
   }
   current_person = person;
   oldstuff = explode(current_philosophies, "\n");
   foreach ( key in oldstuff ) {
     if ( member_array( key, newstuff ) == -1 ) {
       newstuff += ({ key });
     }
   }
   unguarded( (: write_file, SAVE_DIR +  person[0..0]+"/"+person,
      current_philosophies, 1 :));
}
int remove_known( string person, string argument ) {
   string *oldstuff, *newstuff = ({}), key;
   if ( !this_player()->query_lord() &&
      this_player()->query_name() != "ringo" ) {
      tell_object(this_player(), "Lords only...\n");
      return 1;
   }
   oldstuff = query_all_known( person );
   current_person = person;
   current_philosophies = "";
   foreach ( key in oldstuff ) {
      if ( member_array( key, newstuff ) == -1 &&
        key != argument ) {
          newstuff += ({ key });
          current_philosophies += sprintf( "%s\n", key );
       }
   }
   unguarded( (: write_file, SAVE_DIR +  person[0..0]+"/"+person,
      current_philosophies, 1 :));
}
int reset_known( string person ) {
   if ( !this_player()->query_lord() &&
      this_player()->query_name() != "ringo" ) {
      tell_object(this_player(), "Lords only...\n");
      return 1;
   }
   current_person = person;
   current_philosophies = "";
   unguarded( (: write_file, SAVE_DIR +  person[0..0]+"/"+person,
      current_philosophies, 1 :));
}

==================================================
FILE: handlers/player_council.c
==================================================

inherit "/obj/handlers/inherit/player_council";
#define NOMIC_SYSTEM_NO_CLASSES
#include <nomic_system.h>
void load_me();
void save_me();
void create() {
   player_council::create();
   load_me();
}
void save_me() {
   unguarded( (: save_object(NOMIC_SYSTEM_SAVE_FILE) :) );
}
void load_me() {
   unguarded( (: restore_object(NOMIC_SYSTEM_SAVE_FILE, 1) :) );
}
void dest_me() {
   destruct(this_object());
}

==================================================
FILE: handlers/player_handler.c
==================================================

inherit "/global/family";
inherit "/std/living/nationality";
#include <alias.h>
#include <player.h>
#include <login_handler.h>
#include <access.h>
#define MAX_CACHE_SIZE MAX_PLAYERS
#define CACHE_TIMEOUT 900
#define INACTIVE_LIMIT 1209600
#define ILLEGAL ({ "black", "blood", "cyber", "dark", "penis", "cock", "pussy",\
  "fuck", "shit", "death", "deth", "dragon", "fish", "hell", "mage", "pink", "lord",\
  "shadow", "evil", "killer", "slayer" })
private int gender;
private int creator;
private int time_on;
private int last_log_on;
private string last_on_from;
private int activity_counter;
private int start_time;
private string password;
private string deity;
private string guild_ob;
private string cap_name;
private mapping aliases;
private mapping map_prop;
private mapping new_skills;
private mapping player_info;
private mixed *guild_data;
private int _flags;
private string home_dir;
string player_ob;
class player_record {
  int cached;
  int touched;
  int deleting;
  int appealing;
  int gender;
  int creator;
  int active;
  int level;
  string cap_name;
  mapping map_prop;
  mapping player_info;
  string deity;
  string guild;
  mixed *guild_data;
  int age;
  int last;
  int flags;
  string last_on_from;
  int start_time;
  string family_name;
  string player_title;
  string password;
  mixed *project;
  mixed *plan;
  mixed *reference;
  mixed *signature;
  string home_dir;
  string nationality;
  string nationality_region;
  mixed nationality_data;
}
nosave mapping player_cache;
nosave string prev, prev_find, prev_name;
nosave int prev_count, prev_finds, delay;
int requests,
  cache_hits;
void create() {
  seteuid("Root");
  player_ob = "/global/player";
  player_cache = ([ ]);
}
object my_find_player(string player) {
  string *funs, stack = "";
  object *obs;
  int i;
  if(prev_name == player)
    return find_player(player);
  prev_name = player;
  if (base_name(previous_object()) == prev_find && delay > time() - 60 &&
      prev_name == player) {
    prev_finds++;
  } else {
    prev_finds = 1;
    delay = time();
    prev_find = base_name(previous_object());
  }
  if(!(prev_finds % 25)) {
    obs = call_stack(1);
    funs = call_stack(2);
    for(i=0; i<sizeof(obs); i++) {
      if(clonep(obs[i]))
        stack += base_name(obs[i]) + "#" + obs[i]->query_name();
      else
        stack += base_name(obs[i]);
      stack += "->" + funs[i] + "()\n";
    }
    log_file("GARBAGE", "%s %s checked %d players in %d seconds.\n%s",
             ctime(time())[4..18], prev_find, prev_finds, time() - delay,
             stack);
  }
  return find_player(player);
}
void clean_cache() {
  string name;
  foreach(name in keys(player_cache)) {
    if (player_cache[name]->cached < time() - CACHE_TIMEOUT) {
      map_delete(player_cache, name);
    }
  }
}
void remove_cache_entry(string name) {
  map_delete(player_cache, name);
}
private int validate_name(string name) {
  if (!stringp(name) || !name || name == "logon" || name[0] == '.' ||
      (sscanf(name, "%*s %*s") == 2) || strlen(name) < 2) {
    return 0;
  }
  if (sizeof(explode(name, "..")) > 1) {
    return 0;
  }
  return 1;
}
string query_player_file_name(string name) {
#ifdef USE_RAMDISK
  if(PLAYER_RAM_DIR) {
    if(file_size(PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o.gz") == -1) {
      if(file_size(PLAYER_SAVE_DIR + name[0..0] + "/" + name + ".o.gz") > -1) {
        unguarded((: cp,
                   PLAYER_SAVE_DIR + name[0..0] + "/" + name + ".o.gz",
                   PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o.gz" :));
      } else if((file_size(PLAYER_SAVE_DIR+name[0..0]+"/"+name+".o") >-1)) {
        unguarded((: cp,
                   PLAYER_SAVE_DIR + name[0..0] + "/" + name + ".o",
                   PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o" :));
        unguarded((: compress_file,
                   PLAYER_RAM_DIR + name[0..0] + "/" + name + ".o" :));
      }
    }
    return PLAYER_RAM_DIR + name[0..0] + "/" + name;
  }
#endif
  return PLAYER_SAVE_DIR + name[0..0] + "/" + name;
}
string query_player_ram_file_name(string name) {
  return PLAYER_RAM_DIR + name[0..0] + "/" + name;
}
string query_player_disk_file_name(string name) {
  return PLAYER_SAVE_DIR + name[0..0] + "/" + name;
}
string query_delete_player_file_name(string name) {
   return PLAYER_SAVE_DIR + DELETE_DIR + "/" + name;
}
string query_appeal_player_file_name(string name) {
   return PLAYER_SAVE_DIR + APPEAL_DIR + "/" + name;
}
int load_player(string name) {
  class player_record tmp;
  mixed *file;
  int diff, deleting, appealing;
  string tstr, fname;
  object loaded_guild_ob;
  if (!validate_name(name)) {
    return 0;
  }
  requests++;
  if (player_cache[name]) {
    if (10 * (time() - player_cache[name]->cached) <
        (time() - player_cache[name]->touched)) {
      cache_hits++;
      return 1;
    }
  }
  if(file = unguarded((: get_dir, query_player_ram_file_name(name) + ".o.gz",
                       -1 :)))
    fname = query_player_ram_file_name(name);
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_player_disk_file_name(name) +
                      ".o.gz", -1 :));
    fname = query_player_disk_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_player_disk_file_name(name) +
                      ".o", -1 :));
    fname = query_player_disk_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_delete_player_file_name(name) + ".o.gz",
                      -1 :));
    fname = query_delete_player_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_delete_player_file_name(name) + ".o",
                      -1 :));
    fname = query_delete_player_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_appeal_player_file_name(name) + ".o.gz",
                      -1 :));
    fname = query_appeal_player_file_name(name);
  }
  if (!file || !sizeof(file) || file[0][1] < 0) {
    file = unguarded((: get_dir, query_appeal_player_file_name(name) + ".o",
                      -1 :));
    fname = query_appeal_player_file_name(name);
  }
  if(!file || !sizeof(file) || file[0][1] < 0)
    return 0;
  if(player_cache[name] && player_cache[name]->touched == file[0][2]) {
    player_cache[name]->cached = time();
    cache_hits++;
    return 1;
  }
  gender = 0;
  creator = 0;
  time_on = 0;
  last_log_on = 0;
  last_on_from = 0;
  activity_counter = 0;
  start_time = 0;
  password = 0;
  deity = 0;
  guild_ob = 0;
  cap_name = 0;
  player_info = ([ ]);
  aliases = ([ ]);
  new_skills = ([ ]);
  map_prop = ([ ]);
  guild_data = 0;
  if (base_name(previous_object()) == prev && delay > time() - 60) {
    prev_count++;
  } else {
    prev_count = 1;
    delay = time();
    prev = base_name(previous_object());
  }
  if (!(prev_count % 25)) {
    tstr = prev;
    if (tstr == "/secure/login" && sizeof(previous_object(-1)) > 1) {
      tstr = base_name(previous_object(-1)[1]);
    }
    log_file("GARBAGE", "%s %s loaded %d player files in %d seconds.\n",
             ctime(time())[4..18], tstr, prev_count, time() - delay);
  }
#ifdef DEBUG
  string ob;
  if (base_name(previous_object()) != "/secure/login") {
    ob = base_name(previous_object());
  } else {
    ob = base_name(previous_object(-1)[1]);
  }
  log_file("CDEBUG", "%s: %O:%O\n", ob, call_stack(1), call_stack(2));
#endif
  if(!unguarded((: restore_object, fname, 1 :)))
    return 0;
  if(fname == query_appeal_player_file_name(name)) {
    appealing = file[0][2];
  } else if(fname == query_delete_player_file_name(name)) {
    deleting = file[0][2];
  }
  tmp = new (class player_record,
             cached: time(),
             touched: file[0][2],
             deleting: deleting,
             appealing: appealing,
             gender: gender,
             creator: creator,
             active: 0,
             level: 0,
             cap_name: cap_name,
             player_info: player_info,
             map_prop: map_prop,
             deity: deity,
             guild: guild_ob,
             guild_data: guild_data,
             flags: _flags,
             age: time_on,
             last: last_log_on,
             last_on_from: last_on_from,
             start_time: start_time,
             family_name: query_family_name(),
             player_title: query_player_title(),
             nationality: query_nationality(),
             nationality_region: query_nationality_region(),
             nationality_data: query_nationality_data(),
             password: password);
  if(aliases) {
    if (aliases[".project"])
      tmp->project = aliases[".project"][0..1023];
    if (aliases[".plan"])
      tmp->plan = aliases[".plan"][0..1023];
    if (aliases[".reference"])
      tmp->reference = aliases[".reference"][0..1023];
    if (aliases[".signature"])
      tmp->signature = aliases[".signature"][0..240];
  }
  diff = (time() - last_log_on) / (3600 * 24 * 7);
  diff *= 10;
  tmp->active = (activity_counter - diff) > -50 ? 1 : 0;
  if (guild_ob) {
    loaded_guild_ob = load_object( guild_ob );
    if ( loaded_guild_ob ) {
        tmp->level = (int) guild_ob->query_level(this_object());
    }
    else {
        tmp->level = 0;
    }
  }
  player_cache[name] = tmp;
  if ((sizeof(player_cache) > MAX_CACHE_SIZE) &&
      (find_call_out("clean_cache") == -1))
    call_out("clean_cache", 60);
  return 1;
}
string make_string(mixed *al, int max) {
  string str;
  int i;
  int lines;
  str = ALIAS_CMD->alias_string(al);
  sscanf(str, "%s $*$", str);
  str = replace(str, sprintf("%c", 7), "^G");
  str = replace(str, ({ "@@", "@ @ ", "\\;", "$escaped$", ";", "\n",
                          "$escaped$", ";" }));
  for (i = lines = 0; i < sizeof(str) && i < max*80 && lines < max; i++) {
    if (str[i] == '\n' || str[i] == ';') {
      lines++;
    }
  }
  return str[0..i - 1];
}
int test_user(string str) {
  if (player_cache[str])
    return 1;
  if (!validate_name(str))
    return 0;
  return file_size(query_player_disk_file_name(str) + ".o.gz") > 0 ||
    file_size(query_player_disk_file_name(str) + ".o") > 0 ||
    file_size(PLAYER_RAM_DIR + str[0..0] + "/" + str + ".o.gz") > 0 ||
    file_size(PLAYER_RAM_DIR + str[0..0] + "/" + str + ".o") > 0 ||
    file_size(query_delete_player_file_name(str) + ".o.gz") > 0 ||
    file_size(query_delete_player_file_name(str) + ".o") > 0 ||
    file_size(query_appeal_player_file_name(str) + ".o.gz") > 0 ||
    file_size(query_appeal_player_file_name(str) + ".o") > 0;
}
int test_deleting(string str) {
  if (player_cache[str])
    return player_cache[str]->deleting;
  if (!validate_name(str))
    return 0;
  if (file_size(query_delete_player_file_name(str) + ".o") > 0)
    return stat(query_delete_player_file_name(str) + ".o")[1];
  if(file_size(query_delete_player_file_name(str) + ".o.gz") > 0)
    return stat(query_delete_player_file_name(str) + ".o.gz")[1];
  return 0;
}
int test_appealing(string str) {
  if (player_cache[str])
    return player_cache[str]->appealing;
  if (!validate_name(str))
    return 0;
  if (file_size(query_appeal_player_file_name(str) + ".o") > 0)
    return stat(query_appeal_player_file_name(str) + ".o")[1];
  if(file_size(query_appeal_player_file_name(str) + ".o.gz") > 0)
    return stat(query_appeal_player_file_name(str) + ".o.gz")[1];
  return 0;
}
int test_gender(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_gender();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->gender;
}
varargs int test_active(string player, int noload) {
  mixed *file;
  if (find_player(player)) {
    map_delete(player_cache, player);
    return 1;
  }
  if (noload) {
    if (player_cache[player])
      return player_cache[player]->active;
    file =
      unguarded((: stat,
                 query_player_disk_file_name(player) + ".o" :));
    if (!file || !sizeof(file)) {
      file =
        unguarded((: stat,
                   query_player_disk_file_name(player) + ".o.gz" :));
    }
    return (sizeof(file) && file[1] > time() - INACTIVE_LIMIT);
  }
  if (!load_player(player))
    return 0;
  return player_cache[player]->active;
}
string query_cap_name(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_cap_name();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->cap_name;
}
int test_level(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_level();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->level;
}
mixed query_guild_data() {
    return guild_data;
}
int query_skill(string skill) {
  if (mapp(new_skills)) {
    return new_skills[skill];
  }
  return 0;
}
int test_banished(string name) {
  return file_size(BANISH_DIR + name[0..0] + "/" + name + ".o") != -1;
}
varargs int test_valid(string name) {
  string *bits, bit, tname;
  name = lower_case(name);
  tname = replace(name, ({ "'", "", "_", " " }));
  bits = explode(tname, " ");
  name = replace(name, ({ "'", " ", "_", " " }));
  bits += explode(name, " ");
  foreach(bit in bits) {
    if (bit == "the" || bit == "von" || bit == "sto" || bit == "here" ||
    bit == "there" || bit == "time") {
      continue;
    }
    if (test_banished(bit))
      return 0;
  }
  name = replace(name, ({ " ", "" }));
  if (test_banished(name))
    return 0;
  foreach(bit in ILLEGAL) {
    if (strsrch(name, bit) != -1)
      return 0;
  }
  return 1;
}
string test_real_name(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_real_name();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["real_name"];
}
string test_email(string str) {
  if(file_name(previous_object())[0..13] != "/secure/finger" &&
     file_name(previous_object())[0..12] != "/secure/login" &&
     file_name(previous_object())[0..13] != "/secure/nlogin")
    return "";
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_email();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["email"];
}
string test_birthday(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_birthday();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["birthday"];
}
string test_location(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_where();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["location"];
}
string test_homepage(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_homepage();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["homepage"];
}
string test_desc(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_desc();
  }
  if (!load_player(str))
    return "";
  return player_cache[str]->player_info["desc"];
}
mixed test_player_killer(string word, string str) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_player_killer();
  }
  if (!load_player(word)) {
    return 0;
  }
  return player_cache[word]->flags & PLAYER_KILLER_FLAG;
}
mixed test_property(string word, string str) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_property(str);
  }
  if (!load_player(word))
    return 0;
  return player_cache[word]->map_prop[str];
}
void special_add_property(string pname, string prop, mixed val) {
  if(player_cache[pname])
    player_cache[pname]->map_prop[prop] = val;
}
string test_deity(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_deity();
  }
  if (!load_player(word))
    return 0;
  return player_cache[word]->deity;
}
string test_guild(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_guild_ob();
  }
  if (!load_player(word))
    return "";
  return player_cache[word]->guild;
}
mixed *test_guild_data(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_guild_data();
  }
  if (!load_player(word))
    return ({ });
  return player_cache[word]->guild_data;
}
int test_age(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_time_on();
  }
  if (!load_player(word))
    return 0;
  return player_cache[word]->age;
}
int test_last(string word, int noload) {
  mixed *file;
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_last_log_on();
  }
  if (noload) {
    if (player_cache[word]) {
      return player_cache[word]->last;
    }
    word = replace(word, ({ "/", "", "\\", "" }) );
    file =
      unguarded((: stat, query_player_ram_file_name(word) + ".o" :));
    if (!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_player_disk_file_name(word)+".o.gz" :));
    }
    if(!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_delete_player_file_name(word)+
                        ".o" :));
    }
    if (!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_delete_player_file_name(word)+
                        ".o.gz" :));
    }
    if(!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_appeal_player_file_name(word)+
                        ".o" :));
    }
    if (!file || !sizeof(file)) {
      file = unguarded((: stat,
                        query_appeal_player_file_name(word)+
                        ".o.gz" :));
    }
    if (!sizeof(file))
      return 0;
    return file[1];
  }
  if (!load_player(word)) {
    return 0;
  }
  return player_cache[word]->last;
}
string test_last_on_from(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return query_ip_name(find_player(word)) + " (" +
      query_ip_number(find_player(word)) + ") ";
  }
  if (!load_player(word)) {
    return 0;
  }
  return player_cache[word]->last_on_from;
}
int test_start_time(string word) {
  if (find_player(word)) {
    map_delete(player_cache, word);
    return find_player(word)->query_start_time();
  }
  if (!load_player(word))
    return 0;
  return player_cache[word]->start_time;
}
int test_creator(string str) {
  str = lower_case (str);
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_creator();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->creator;
}
string test_home_dir(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_home_dir();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->home_dir;
}
string test_family(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_family_name();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->family_name;
}
string test_player_title(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_player_title();
  }
  if (!load_player(str))
    return 0;
  return player_cache[str]->player_title;
}
int test_password(string name, string pass) {
  if (!load_player(name)) {
    return 0;
  }
  if (find_player(name) && player_cache[name]->password == "") {
    if(file_size(query_player_ram_file_name(name) + ".o.gz") > 0)
      unguarded((: restore_object, query_player_ram_file_name(name), 1 :));
    else
      unguarded((: restore_object, query_player_disk_file_name(name), 1 :));
    player_cache[name]->password = password;
  }
  return crypt(pass, player_cache[name]->password) ==
    player_cache[name]->password;
}
string get_password(string name) {
  if(file_name(previous_object()) != "/secure/ftp_auth")
    return "x";
  if(!load_player(name))
    return "x";
  if(find_player(name) && player_cache[name]->password == "") {
    unguarded((: restore_object,
               query_player_disk_file_name(name), 1 :));
  }
  return player_cache[name]->password;
}
string query_signature(string name) {
  string sig;
  if (find_player(name)) {
    map_delete(player_cache, name);
    sig =
      make_string(find_player(name)->query_player_alias(".signature"),
                  3);
  } else {
    if (!load_player(name))
      return "";
    sig = make_string(player_cache[name]->signature, 3);
  }
  if (sig && sig != "")
    sig = "\n--\n" + strip_colours(sig);
  return sig;
}
string query_project(string name, int unused) {
  if (find_player(name)) {
    map_delete(player_cache, name);
    if (find_player(name)->query_player_alias(".project"))
      return make_string(find_player(name)->query_player_alias(".project"), 5);
    else
      return "";
  }
  if (!load_player(name))
    return "";
  return make_string(player_cache[name]->project, 5);
}
string query_plan(string name, int unused) {
  if (find_player(name)) {
    map_delete(player_cache, name);
    if (find_player(name)->query_player_alias(".plan"))
      return make_string(find_player(name)->query_player_alias(".plan"),
                         5);
    else
      return "";
  }
  if (!load_player(name))
    return "";
  return make_string(player_cache[name]->plan, 5);
}
string query_reference(string name) {
  if (find_player(name)) {
    map_delete(player_cache, name);
    if (find_player(name)->query_player_alias(".reference"))
      return make_string(find_player(name)->
                         query_player_alias(".reference"), 20);
    else
      return "";
  }
  if (!load_player(name))
    return "";
  return make_string(player_cache[name]->reference, 20);
}
string test_nationality(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_nationality();
  }
  if (!load_player(str)) {
    return 0;
  }
  return ((class player_record)player_cache[str])->nationality;
}
string test_nationality_region(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_nationality_region();
  }
  if (!load_player(str)) {
    return 0;
  }
  return player_cache[str]->nationality_region;
}
string test_nationality_data(string str) {
  if (find_player(str)) {
    map_delete(player_cache, str);
    return find_player(str)->query_nationality_data();
  }
  if (!load_player(str)) {
    return 0;
  }
  return player_cache[str]->nationality_data;
}
int test_ip_allowed(string name, string ip) {
  string *ips;
  if(ip == "127.0.0.1")
    return 1;
  if(find_player(name)) {
    map_delete(player_cache, name);
    ips = find_player(name)->query_rhosts();
  } else if (load_player(name))
    ips = player_cache[name]->player_info["allowed_ips"];
  if(!ips || !sizeof(ips))
    return 1;
  while(strlen(ip)) {
    if(member_array(ip, ips) != -1)
      return 1;
    ip = implode((string *)explode(ip, ".")[0..<2], ".");
  }
  return 0;
}
mixed *stats() {
  int percentage;
  if (requests)
    percentage = (cache_hits * 100) / requests;
  return ({ ({ "cache size", sizeof(player_cache) }),
              ({ "requests", requests }),
              ({ "cache hits", cache_hits }),
              ({ "cache misses", requests - cache_hits }),
              ({ "percentage hits", percentage }), });
}
nomask int query_prevent_shadow(object ob) { return 1; }

==================================================
FILE: handlers/player_shop.c
==================================================

#include <player_shop.h>
#include <mail.h>
#define REFRESH_HANDLER "/obj/handlers/refresh"
#define save_me() unguarded((:write_file, "/save/player_shops", \
                  save_variable(_shops), 1:));
private nosave mapping _shops = 0;
void create()
{
    seteuid("Root");
    if (file_size("/save/player_shops") > 0)
    {
        _shops = restore_variable(unguarded((:read_file,
              "/save/player_shops":)));
    }
}
int add_shop(string short_name, string office_path)
{
    string savedir;
    object ob;
    if (!(ob = find_object(office_path)))
    {
        tell_object(this_player(), "No such object "+ office_path+ ".\n");
        return 0;
    }
    if (_shops)
    {
        if (_shops[short_name])
        {
            tell_object(this_player(), "Shop already exists.\n");
            return 0;
        }
        _shops += ([short_name:""]);
    }
    else
    {
        _shops = ([short_name:""]);
    }
    _shops[short_name] = office_path;
    REFRESH_HANDLER->register_refresh(office_path);
    REFRESH_HANDLER->register_delete(office_path);
    savedir = sprintf("/save/player_housing/%s/",
      lower_case(geteuid(ob)));
    if (!sizeof(get_dir(savedir)))
        unguarded((: mkdir, savedir :));
    savedir += sprintf("/player_shops");
    if (!sizeof(get_dir(savedir)))
        unguarded((: mkdir, savedir :));
    savedir += sprintf("/%s", short_name);
    if (!sizeof(get_dir(savedir)))
        unguarded((: mkdir, savedir :));
    save_me();
    return 1;
}
int remove_shop(string short_name)
{
    if (!_shops || !_shops[short_name])
    {
        tell_object(this_player(), "Shop doesn't exist.\n");
        return 0;
    }
    if (!this_player()->query_lord() &&
      this_player()->query_name() != CREATOR)
    {
        tell_object(this_player(), "Permission denied.\n");
        return 0;
    }
    map_delete(_shops, short_name);
    save_me();
    return 1;
}
int update_shop(string short_name, string office_path)
{
    if (!_shops || !_shops[short_name])
    {
        tell_object(this_player(), "Shop doesn't exist.\n");
        return 0;
    }
    if (!this_player()->query_lord() &&
      this_player()->query_name() != CREATOR)
    {
        tell_object(this_player(), "Permission denied.\n");
        return 0;
    }
    if (!find_object(office_path))
    {
        tell_object(this_player(), "No such object "+ office_path+ ".\n");
        return 0;
    }
    REFRESH_HANDLER->register_refresh(office_path);
    REFRESH_HANDLER->register_delete(office_path);
    _shops[short_name] = office_path;
    save_me();
    return 1;
}
string query_shop(string short_name)
{
    if (!_shops || !_shops[short_name])
        return "";
    if (!find_object(_shops[short_name]))
        return "No such file "+ _shops[short_name]+ ".";
    return _shops[short_name];
}
mapping query_shops() { return copy(_shops); }
void auto_mail(string to, string from, string sub, string cc, string body)
{
    if (_shops)
    {
        foreach (string shop in keys(_shops))
        {
            if (_shops[shop] == file_name(previous_object()))
            {
                return MAILER->do_mail_message(to, from, sub, cc, body, 0, 0, 1);
            }
        }
    }
    unguarded((: write_file, "/log/CHEAT",
        "Illegal access to AUTO_MAILER.\n" "Backtrace: " +
        back_trace() :));
}

==================================================
FILE: handlers/playerinfo.c
==================================================

#include <playerinfo.h>
#include <player_handler.h>
#include <refresh.h>
#include <applications.h>
#include <newbiehelpers.h>
#define SAVE_DIR         "/save/playerinfo"
#define SAVE_FILE        ( SAVE_DIR + "/handler_data" )
#define NO_ACCESS_LOG    6
#define LIAISON_WAND       "/d/liaison/items/wand"
#define LIAISON_SCEPTRE    "/d/liaison/items/mort_sceptre"
#define LIAISON_PEN        "/d/liaison/items/quota_pen"
#define LIAISON_INTERVIEW  "/d/liaison/utils/interview"
#define MULTIPLAY          "/obj/handlers/multiplayer"
#define GAG                "/cmds/creator/gag"
#define UNGAG              "/cmds/creator/ungag"
#define METEOR             "/cmds/creator/meteor"
#define FRY                "/cmds/creator/fry"
#define REPORT_COMMAND     "/cmds/creator/playerinfo"
#define ADD_COMMAND        "/cmds/creator/addevent"
#define DELETE_COMMAND     "/cmds/creator/delevent"
#define ADDALT_COMMAND     "/cmds/creator/addalt"
#define DELALT_COMMAND     "/cmds/creator/delalt"
#define FAMILY_COMMAND     "/cmds/creator/family"
#define SUSPENDER          "/secure/bastards"
#define SHOWHELP_COMMAND   "/cmds/creator/show_help"
#define PATRICIAN_PALACE   "/d/am/patrician/patrician"
#define REFRESH_HANDLER    "/obj/handlers/refresh"
#define PRISON             "/d/sur/beta/prison/dungeon"
#define FETCH_COMMAND      "/cmds/creator/fetch"
#define REARRANGE_COMMAND  "/cmds/guild-race/rearrange"
#define PATRICIAN_PT       "/d/playtesters/handlers/applications"
#define PATRICIAN_COMPLAIN "/d/am/patrician/pat_complaints"
#define RUN_HANDLER        "/obj/handlers/guild_things/run"
#define BANISH_COMMAND     "/secure/cmds/creator/banish"
#define FAIRY_GODMOTHER    "/obj/handlers/fairy_godmothers"
#define CACHE_SIZE 150
#define CL_CREATOR      "%^CYAN%^"
#define CL_EVENT        "%^RED%^"
#define CL_RESET        "%^RESET%^"
#define CL_HEADER       "%^RED%^"
#define DEBOUNCE_PERIOD (60*30)
#define TIMEOUT_PERIOD  (60*60*24)
#define ONE_WEEK           ( 60 * 60 * 24 * 7 )
nosave inherit "/std/object";
mapping          query_timeouts();
protected string filename(string name);
string *         query_events();
protected int    query_debounced(string event);
protected int    query_lord_only(string event);
int              query_source_ok(string event, string source);
protected int    query_deleter_ok(string event, object deleter);
protected int    query_can_add(string e, object p);
protected int    query_can_delete(string e, object p);
protected int    query_can_handle_alts(object p);
protected void   do_debouncing(string player, class dbentry entry);
protected void   do_timeout();
protected void   load_player(string player);
protected void   save_player(string player);
void             player_remove(string player);
int              add_entry(object creator, string player, string event,
                   string comment, mixed *extra);
int              delete_entry(object creator, string player, string event,
                   int n);
protected string query_header(string player);
protected string query_entry(int idx, class dbentry e,
                   string display_name);
string           query_access_log(object source, string player, int lastn);
string           query_event(object source, string player, string event);
string           add_alt(object creator, string player, string alt);
string           delete_alt(object creator, string player, string alt);
mapping          query_alerts();
int              query_alerts_for( string player );
int              is_alert( string player, int idx );
int              acknowledge_alert( object creator, string player,
                   string event, int idx, string update, mixed * extra );
void             clear_alerts_for( string player );
int              increment_alerts_for( string player );
int              decrement_alerts_for( string player );
void             correct_alts_for( string player );
void player_deleted(mixed player, int deleted);
void fix_alts(mixed player);
class source {
   string *add;
   string *delete;
}
private class playerinfo    dossier;
private nosave mapping      timeouts    = ([ "replace" : (60*60*24*30) ]);
private int local_time;
private nosave mapping _sources;
nosave mapping _alerts;
nosave string * _lordonly;
private nosave int correcting_alts;
private nosave int no_recurse;
private nosave mapping _dossier_cache;
private nosave int _dossier_cache_hits;
private nosave int _dossier_total;
void save_handler_data() {
   mapping vars = ([ ]);
   string tmp;
   vars["alerts"] = _alerts;
   tmp = save_variable( vars );
   unguarded( (: write_file, SAVE_FILE, tmp, 1 :) );
}
void load_handler_data() {
   mapping vars;
   string tmp;
   if( file_size( SAVE_FILE ) <= 0 )
      return;
   tmp = unguarded( (: read_file, SAVE_FILE :) );
   vars = restore_variable( tmp );
   _alerts = vars["alerts"];
}
void create() {
    ::create();
    _sources = ([
        "cheat":        new(class source,
                            add : ({ }),
                            delete : ({ DELETE_COMMAND })),
        "discipline":   new(class source,
                            add : ({ ADD_COMMAND, PRISON, REPORT_COMMAND,
                                     BANISH_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "email":        new(class source,
                            add : ({ }),
                            delete : ({ DELETE_COMMAND })),
        "family":       new(class source,
                            add : ({ FAMILY_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "gag":          new(class source,
                            add : ({ GAG, UNGAG,
                                     ADD_COMMAND, REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "harassment":   new(class source,
                            add : ({ ADD_COMMAND, REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "meteor":       new(class source,
                            add : ({ METEOR, FRY }),
                            delete : ({ DELETE_COMMAND })),
        "misc":         new(class source,
                            add : ({ ADD_COMMAND, APPLICATIONS_HANDLER,
                                     REARRANGE_COMMAND, PATRICIAN_PT,
                                     PATRICIAN_COMPLAIN, RUN_HANDLER,
                                     REPORT_COMMAND, NEWBIEHELPERS_HANDLER,
                                     LIAISON_SCEPTRE,
                                     LIAISON_PEN, FAIRY_GODMOTHER,
                                     LIAISON_INTERVIEW }),
                            delete : ({ DELETE_COMMAND })),
        "multiplay":    new(class source,
                            add : ({ MULTIPLAY, ADD_COMMAND,
                                     REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "replace":      new(class source,
                            add : ({ LIAISON_WAND,
                                     ADD_COMMAND, FETCH_COMMAND,
                                     REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "showhelp":     new(class source,
                            add : ({ SHOWHELP_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "suspend":      new(class source,
                            add : ({ SUSPENDER }),
                            delete : ({ })),
        "alert":        new(class source,
                            add : ({ ADD_COMMAND, REPORT_COMMAND }),
                            delete : ({ DELETE_COMMAND })),
        "refresh":      new(class source,
                            add : ({ REFRESH_HANDLER }),
                            delete : ({ DELETE_COMMAND })),
        "delete":      new(class source,
                           add : ({ REFRESH_HANDLER }),
                           delete : ({ DELETE_COMMAND }))
    ]);
    _alerts = ([ ]);
    _lordonly = ({ });
    _dossier_cache = ([ ]);
    _dossier_cache_hits = 0;
    _dossier_total = 0;
    seteuid("Room");
    load_handler_data();
}
mapping query_timeouts() {
    return timeouts;
}
string query_name() {
    return "playerinfo handler";
}
protected string filename(string name) {
    string p = lower_case(name);
    return sprintf("%s/%c/%s.o",SAVE_DIR,p[0],p);
}
string *query_events() {
    return keys(_sources);
}
protected int query_debounced(string event) {
    return (event == "replace" || event == "multiplay" ||
            event == "gag" || event == "misc" ||
            event == "discipline" || event == "showhelp" ||
            event == "suspend");
}
protected int query_lord_only(string event) {
    return ( member_array( event, _lordonly ) >= 0 ) ? 1 : 0;
}
int query_source_ok(string event, string source) {
    string *reqd;
    reqd = _sources[event]->add;
    if(reqd == 0) {
        return 1;
    }
    if(sizeof(reqd) == 0) {
        return 0;
    }
    return member_array(source,reqd) >= 0;
}
protected int query_deleter_ok(string event, object deleter) {
    string *reqd;
    reqd = _sources[event]->delete;
    if (reqd == 0) {
        return 1;
    }
    if (sizeof(reqd) == 0) {
        return 0;
    }
    return member_array(base_name(deleter),reqd) >= 0;
}
protected int query_can_add(string e, object p) {
    if(member_array(e,query_events()) < 0)
        return 0;
    if(!interactive(p))
        return 1;
    return !(query_lord_only(e) && !p->query_lord());
}
protected int query_can_delete(string e, object p) {
    if( !interactive(p) ) {
        return 1;
    }
    if( e == "misc" || e == "replace" ) {
        return master()->query_senior( p->query_name() ) ||
               "/d/liaison/master"->query_deputy( p->query_name() );
    }
    return p->query_lord();
}
protected int query_can_handle_alts(object p) {
    if( !interactive(p) ) {
        return 1;
    }
    return master()->query_senior( p->query_name() ) ||
           "/d/liaison/master"->query_deputy( p->query_name() );
}
protected void do_debouncing(string player, class dbentry entry) {
    int             n;
    class dbentry   last;
    if (query_debounced(entry->event)) {
        n = sizeof(dossier->data);
        if ( n ) {
            last = dossier->data[ n - 1 ];
            if( entry->event == last->event &&
                entry->creator == last->creator &&
                entry->time - last->time <= DEBOUNCE_PERIOD)
            {
                last->comment += entry->comment;
                last->time = entry->time;
                if(last->extra != 0) {
                    if(entry->extra == 0) {
                        entry->extra = ({ });
                    }
                    last->extra += entry->extra;
                }
                return;
            }
        }
    }
    dossier->data += ({ entry });
    return;
}
protected void do_timeout() {
    function not_timed_out = function(class dbentry p)
    {
        int life = timeouts[p->event];
        if(life == 0)
            return 1;
        return local_time <= (p->time + life);
    };
    local_time = time();
    dossier->data = filter(dossier->data, not_timed_out);
    dossier->last_check = time();
}
protected void load_player(string player) {
    string  p = lower_case(player);
    string  fn = filename(p);
    class playerinfo tmp;
    mixed result;
    _dossier_total++;
    if ( !undefinedp(_dossier_cache[ player ] ) ) {
        dossier = _dossier_cache[ player ];
        _dossier_cache_hits++;
        return;
    }
    if( dossier != 0 && dossier->name == p ) {
        return;
    }
    if(file_size(fn) > 0) {
        result = unguarded( (: restore_object, fn, 0 :) );
    } else {
        dossier = new(class playerinfo,
            name:       p,
            last_check: time(),
            alts:       ({ }),
            data:       ({ }));
    }
    if (!classp(dossier)) {
        dossier = new(class playerinfo,
            name:       p,
            last_check: time(),
            alts:       ({ }),
            data:       ({ }));
    }
    if(sizeof(dossier) == 5) {
      tmp = new(class playerinfo,
                name: dossier->name,
                last_check: dossier->last_check,
                alts: copy(dossier->alts),
                data: copy(dossier->data),
                main_alt: dossier->main_alt,
                old_alts: ({ }));
      dossier = tmp;
    }
    if(!dossier->old_alts)
      dossier->old_alts = ({ });
    if(!correcting_alts) {
        correct_alts_for( dossier->name );
    }
    _dossier_cache[ player ] = dossier;
}
protected void save_player(string player) {
    if( time() - dossier->last_check >= TIMEOUT_PERIOD ) {
        do_timeout();
    }
    unguarded( (: save_object, filename(player) :) );
}
void player_remove(string player) {
    string alt, new_main;
    string * alts;
    if ( !player ) {
        return;
    }
    player = lower_case( player );
    correcting_alts = 1;
    load_player( player );
    if ( sizeof( dossier->alts ) ) {
        alts = copy( dossier->alts );
        new_main = alts[0];
        alts -= ({ new_main });
        load_player( new_main );
        dossier->main_alt = 0;
        dossier->alts = uniq_array( alts + ({ player }) );
        save_player( new_main );
        foreach( alt in alts ) {
            load_player( alt );
            dossier->main_alt = new_main;
            save_player( alt );
        }
    }
    correcting_alts = 0;
    unguarded( (: rm, filename(player) :) );
    clear_alerts_for(player);
}
int add_entry(object creator, string player, string event, string comment,
  mixed *extra) {
    class dbentry   new_entry;
    if(!query_can_add(event,creator))
        return 0;
    if(!query_source_ok(event,base_name(previous_object())))
        return 0;
    if(!PLAYER_HANDLER->test_user(lower_case(player)))
        return 0;
    if(comment[<1..<1] != "\n") {
        comment += "\n";
    }
    load_player(player);
    new_entry = new(class dbentry,
            time:       time(),
            creator:    capitalize(creator->query_name()),
            event:      event,
            comment:    (comment == 0 ? "" : comment),
            extra:      extra);
    do_debouncing(player, new_entry);
    save_player(player);
    if( event == "alert" )
        increment_alerts_for(player);
    return 1;
}
int delete_entry(object creator, string player, string event, int n) {
   int idx = n - 1;
   class dbentry * data;
   class dbentry fluff;
   if( !query_can_delete( event, creator ) )
      return 0;
   if( !query_deleter_ok( event, previous_object() ) )
      return 0;
   load_player(player);
   if( ( idx < 0 ) || ( idx >= sizeof( dossier->data ) ) )
      return 0;
   fluff =  dossier->data[idx];
   if( fluff->event != event )
      return 0;
   data = copy( dossier->data );
   data = data[0 .. (idx - 1)] + data[(idx + 1) .. <1];
   dossier->data = data;
   save_player(player);
   log_file("DELETE", ctime(time()) + ": " + event + " added by " +
            fluff->creator + "\n");
   if( event == "alert" )
      decrement_alerts_for(player);
   return 1;
}
protected string query_header( string player ) {
  string aka, alts, str;
  string *tmp, *tmp2;
  aka = alts = str = "";
  if( sizeof( dossier->alts ) > 0 )
    alts = " aka " +
      query_multiple_short(map(dossier->alts,
                               (: CL_HEADER+capitalize($1)+CL_RESET :)));
  if(sizeof(dossier->old_alts) > 0)
    alts += " (and was " +
      query_multiple_short(map(dossier->old_alts,
                               (: CL_HEADER+capitalize($1)+CL_RESET :))) + ")";
  if( dossier->main_alt ) {
    if(!PLAYER_HANDLER->test_user(dossier->main_alt)) {
      fix_alts(player);
      load_player(player);
    }
    aka = " (alt of " + CL_HEADER + capitalize(dossier->main_alt) + CL_RESET;
    load_player(dossier->main_alt);
    tmp = copy(dossier->alts);
    tmp2 = copy(dossier->old_alts);
    if(!tmp) {
      tmp = ({ });
      dossier->alts = ({ });
      save_player( dossier->name );
    }
    load_player(player);
    tmp -= ({ player });
    if(sizeof(tmp))
      aka += ", aka " +
        query_multiple_short(map(tmp, (: CL_HEADER+capitalize($1)+CL_RESET :)));
    if( arrayp( tmp2 ) ) {
      tmp2 -= ({ player });
      if(sizeof(tmp2)) {
        aka += " and was " +
          query_multiple_short(map(tmp2, (: CL_HEADER+capitalize($1)+CL_RESET:)));
      }
    }
    aka += ")";
  }
  return sprintf( "Report for: %s%s%s\n\n",
                  CL_HEADER + capitalize(player) + CL_RESET, alts, aka );
}
protected string query_entry( int idx, class dbentry e,
                              string display_name ) {
   string  date      = ctime( e->time );
   string  creator   = e->creator;
   string  event     = e->event;
   string  *comments = explode( e->comment, "\n" );
   string  line, str;
   int     lines = 0;
   if( display_name )
      display_name = sprintf( "%-31s ",
        "(" + CL_CREATOR + display_name + CL_RESET + ")" );
   else
      display_name = "";
   str = sprintf( "%2d. %s%s %s%|14s%s (by %s%s%s)\n",
     idx + 1, display_name, date, CL_EVENT, event, CL_RESET,
     CL_CREATOR, creator, CL_RESET );
   foreach( line in comments ) {
      if( sizeof(line) != 0 ) {
         str += sprintf( "    %s\n", line );
         lines++;
      }
   }
   if( !lines ) {
      str += sprintf( "    (no comments)\n" );
   }
   return str;
}
varargs string query_dossier( object source, string player, int lastn ) {
   int             i;
   class dbentry   * list;
   string          msg, str;
   mapping         log;
   load_player(player);
   str = query_header(player);
   list = dossier->data;
   if ( sizeof( dossier ) == NO_ACCESS_LOG ) {
    dossier = new ( class playerinfo,
        name: dossier->name,
        last_check: dossier->last_check,
        alts: dossier->alts,
        data: dossier->data,
        main_alt: dossier->main_alt,
        old_alts: dossier->old_alts,
        access_log: ([ ]) );
   }
   if ( mapp( dossier->access_log ) )
     log = dossier->access_log;
   else
     log = ([ ]);
   if( !lastn ||
       sizeof(list) <= lastn ||
       source->query_property(VERBOSE_PI) )
   {
      i = 0;
   } else {
      i = sizeof(list) - lastn;
      msg = "%^RED%^NOTE:%^RESET%^ Only displaying this player's most "
        "recent " + lastn + " entries.  Use 'playerinfo "
        + player + " verbose' to see their entire dossier.\n";
      str += msg + "\n";
   }
   for( ; i < sizeof( list ); i++ ) {
      str += query_entry( i, list[i], 0 );
   }
   if( msg ) {
      str += "\n" + msg;
   }
   log = filter( log, (: $2 > time() - ONE_WEEK :) );
   if ( interactive( source ) )
     log[ source->query_name() ] = time();
  dossier->access_log = log;
  save_player( player );
  return str;
}
string query_event( object source, string player, string event ) {
   int             i;
   class dbentry   *list;
   string          str;
   load_player(player);
   str = query_header(player);
   list = dossier->data;
   for( i = 0; i < sizeof(list); i++ ) {
      if( list[i]->event == event )
         str += query_entry( i, list[i], 0 );
   }
   return str;
}
string query_interleaved( object source, string player, string event ) {
   class playerinfo * dossiers;
   class dbentry * stuff;
   string str;
   string * alts;
   int i, size, done, earliest, earliestt, count;
   int * earliests;
   load_player(player);
   if( dossier->main_alt ) {
      player = dossier->main_alt;
      load_player(player);
   }
   str = query_header(player);
   alts = ({ player }) + copy( dossier->alts );
   size = sizeof(alts);
   if( size == 1 ) {
      if(event) {
        str = query_event( source, player, event );
      } else {
        str = query_dossier( source, player );
      }
      return str;
   }
   dossiers = allocate(size);
   earliests = allocate(size);
   for( i = 0; i < size; i++ ) {
     load_player( alts[i] );
     if( sizeof( dossier->data ) ) {
       dossiers[i] = copy(dossier);
     } else {
       dossiers[i] = 0;
     }
     earliests[i] = 0;
   }
   count = 0;
   while( !done ) {
      done = 1;
      earliestt = 0;
      for( i = 0; i < size; i++ ) {
         if( !dossiers[i] ) {
            continue;
         }
         done = 0;
         stuff = dossiers[i]->data;
         if( !earliestt || stuff[ earliests[i] ]->time < earliestt ) {
            earliest = i;
            earliestt = stuff[ earliests[i] ]->time;
         }
      }
      if(done) {
         continue;
      }
      stuff = dossiers[earliest]->data;
      if( !event ||
          stuff[ earliests[earliest] ]->event == event )
      {
         str += query_entry( count, stuff[ earliests[earliest] ],
                             alts[earliest] );
         count++;
      }
      earliests[earliest]++;
      if( earliests[earliest] >= sizeof(stuff) ) {
         dossiers[earliest] = 0;
      }
   }
   return str;
}
string query_alt_of(string player) {
  if(!PLAYER_HANDLER->test_user(player))
    return 0;
  load_player(player);
  return dossier->main_alt;
}
string *query_alts(string player) {
  if(!PLAYER_HANDLER->test_user(player))
    return ({ });
  load_player(player);
  return dossier->alts;
}
string add_alt(object creator, string player, string alt) {
  class dbentry new_entry;
  int is_deleted;
  string *alts, tmp;
  if((base_name(previous_object()) != "/cmds/player/register") &&
     !query_can_handle_alts(this_player()))
    return "You are not allowed to add players' alts.\n";
  alt = lower_case(alt);
  if(!find_player(alt) && !PLAYER_HANDLER->test_user(alt)) {
    if(!creator)
      return "No such player: " + capitalize(alt) + ".\n";
    if(file_size(filename(alt)) == -1)
      return "No such player and no record for: " + capitalize(alt) + ".\n";
    is_deleted = 1;
  }
  load_player(alt);
  if(dossier->main_alt && PLAYER_HANDLER->test_user(dossier->main_alt) &&
     !is_deleted)
    return capitalize(alt) + " is already an alt of " +
      capitalize(dossier->main_alt) + ".\n";
  if(sizeof(dossier->alts)) {
    if(is_deleted)
      return capitalize(alt) + " already has alts.\n";
    else {
      alts = dossier->alts + dossier->old_alts;
    }
  }
  player = lower_case(player);
  if(!find_player(player) && !PLAYER_HANDLER->test_user(player))
    return "No such player: "+ capitalize(player) +".\n";
  correcting_alts = 1;
  load_player(player);
  if(dossier->main_alt == alt) {
    correcting_alts = 0;
    return capitalize(player) + " is already an alt of " +
      capitalize(dossier->main_alt) + ".\n";
  }
  if(dossier->alts && member_array(alt, dossier->alts) != -1) {
    correcting_alts = 0;
    return capitalize(alt) + " is already an alt of " +
      capitalize(player) + ".\n";
  }
  if(!dossier->alts)
    dossier->alts = ({ });
  dossier->alts += ({ alt });
  if(alts) {
    foreach(tmp in alts) {
      if(PLAYER_HANDLER->test_user(tmp))
        dossier->alts += ({ tmp });
      else
        dossier->old_alts += ({ tmp });
    }
  }
  new_entry = new(class dbentry,
                  time:       time(),
                  creator:    creator ? capitalize(creator->query_name()) :
                              player,
                  event:      "register",
                  comment:    "Registered " + capitalize(alt) +
                              " as an alt.\n",
                  extra:      0);
  do_debouncing(player, new_entry);
  save_player(player);
  load_player(alt);
  dossier->main_alt = player;
  dossier->alts = ({ });
  dossier->old_alts = ({ });
  new_entry = new(class dbentry,
                  time:       time(),
                  creator:    creator ? capitalize(creator->query_name()) :
                              player,
                  event:      "register",
                  comment:    "Registered as an alt of " + player + ".\n",
                  extra:      0);
  do_debouncing(alt, new_entry);
  save_player(alt);
  correcting_alts = 0;
  return "Added " + capitalize(alt) + " as an alt of " + capitalize(player) +
    ".\n";
}
string delete_alt(object creator, string player, string alt) {
  string ret;
  class dbentry new_entry;
  if(!query_can_handle_alts(this_player()))
    return "You are not allowed to delete players' alts.\n";
  player = lower_case(player);
  alt = lower_case(alt);
  load_player(player);
  if(!dossier->alts || member_array(alt, dossier->alts) == -1)
    ret = capitalize(alt) + " was not an alt of " + capitalize(player);
  else {
    dossier->alts -= ({ alt });
    new_entry = new(class dbentry,
                    time:       time(),
                    creator:    capitalize(creator->query_name()),
                    event:      "register",
                    comment:    "Removed " + capitalize(alt) + " as an alt.\n",
                    extra:      0);
    do_debouncing(alt, new_entry);
    save_player(player);
  }
  load_player(alt);
  if(dossier->main_alt != player) {
    if(ret)
      return capitalize(alt) + " is not an alt of " + capitalize(player) +
        ".\n";
    else
      ret = capitalize(player) + " was not the main player for " +
        capitalize(alt);
  } else {
    dossier->main_alt = 0;
    dossier->alts = ({ });
    dossier->old_alts = ({ });
    new_entry = new(class dbentry,
                    time:       time(),
                    creator:    capitalize(creator->query_name()),
                    event:      "register",
                    comment:    "Removed as an alt of " + capitalize(player) +
                    ".\n",
                    extra:      0);
    do_debouncing(alt, new_entry);
    save_player(alt);
  }
  if(ret)
    return "Deleted " + capitalize(alt) + " from " + capitalize(player) +
      "'s list of alts (" + ret + ").\n";
  else
    return "Deleted " + capitalize(alt) + " from " + capitalize(player) +
      "'s list of alts.\n";
}
mapping query_alerts() {
   if( !_alerts ) {
      _alerts = ([ ]);
   }
   return _alerts;
}
int query_alerts_for( string player ) {
   player = lower_case(player);
   if( !_alerts ) {
      _alerts = ([ ]);
   }
   return _alerts[player];
}
int is_alert( string player, int idx ) {
   load_player( player );
   if( sizeof(dossier->data) < idx ) {
      return 0;
   }
   return ( dossier->data[ idx - 1 ] )->event == "alert";
}
int acknowledge_alert( object creator, string player, string event,
   int idx, string update, mixed * extra ) {
   class dbentry entry;
   string previnfo;
   player = lower_case(player);
   if( !query_can_add( event, creator ) )
      return 0;
   if( !query_source_ok( "alert", base_name( previous_object() ) ) )
      return 0;
   if( !query_source_ok( event,  base_name( previous_object() ) ) )
      return 0;
   if( !PLAYER_HANDLER->test_user(player) )
      return 0;
   if( member_array( event, keys(_sources) ) < 0 )
      return 0;
   idx--;
   load_player( player );
   entry = dossier->data[idx];
   previnfo = sprintf( "Originally added by %s%s%s at %s:\n%s\n---\n",
     CL_CREATOR, entry->creator, CL_RESET, ctime( entry->time ),
     entry->comment );
   entry->time    = time();
   entry->creator = capitalize( creator->query_name() );
   entry->event   = lower_case( event );
   entry->comment = previnfo + update;
   dossier->data[idx] = entry;
   if( event != "alert" ) {
      decrement_alerts_for(player);
   }
   save_player( player );
   return 1;
}
void clear_alerts_for( string player ) {
   player = lower_case(player);
   if( !_alerts ) {
      _alerts = ([ ]);
   }
   map_delete( _alerts, player );
   save_handler_data();
}
int increment_alerts_for( string player ) {
   player = lower_case(player);
   if( !_alerts ) {
      _alerts = ([ ]);
   }
   if( !PLAYER_HANDLER->test_user(player) ) {
      return 0;
   }
   if( undefinedp( _alerts[player] ) ) {
      _alerts[player] = 1;
   } else {
      _alerts[player] = _alerts[player] + 1;
   }
   save_handler_data();
   return _alerts[player];
}
int decrement_alerts_for( string player ) {
   player = lower_case(player);
   if( !_alerts ) {
      _alerts = ([ ]);
   }
   if( undefinedp( _alerts[player] ) ) {
      return 0;
   }
   _alerts[player] = _alerts[player] - 1;
   if(_alerts[player] <= 0 ) {
      map_delete( _alerts, player );
   }
   save_handler_data();
   return _alerts[player];
}
string * query_online_alerts() {
   if ( !_alerts ) {
      _alerts = ([ ]);
      return ({ });
   }
   return filter( keys(_alerts), (: find_player($1) :) );
}
private void correct_alts_for(string player) {
  string main;
  string *alts, *tmp, alt;
  if(!player)
    return;
  player = lower_case(player);
  correcting_alts = 1;
  load_player(player);
  main = dossier->main_alt;
  alts = copy(dossier->alts);
  if(main && !no_recurse) {
    if(sizeof(alts)) {
      dossier->alts = ({ });
      save_player(player);
    }
    if((!PLAYER_HANDLER->test_user(player) ||
        !PLAYER_HANDLER->test_user(main))) {
      correcting_alts = 0;
      no_recurse = 1;
      correct_alts_for(main);
      load_player(player);
    }
    return;
  }
  if(!PLAYER_HANDLER->test_user(player)) {
    if(!sizeof(alts)) {
      if(this_player()->query_name("ceres"))
        write("No alts for : " + player + "\n");
      correcting_alts = 0;
      return;
    }
    tmp = filter(alts, (: PLAYER_HANDLER->test_user($1) :));
    if(sizeof(tmp)) {
      main = tmp[0];
    }
  }
  if(main) {
    dossier->main_alt = main;
    dossier->alts = ({ });
    save_player(player);
  }
  if(main)
    load_player(main);
  if(sizeof(alts)) {
    tmp = filter(alts, (: !find_player($1) &&
                        !PLAYER_HANDLER->test_user($1) :));
    tmp = uniq_array(dossier->old_alts + tmp);
  } else
    alts = ({ });
  alts = uniq_array(alts + dossier->alts) - ({ main });
  alts = filter(alts, (: find_player($1) || PLAYER_HANDLER->test_user($1) :));
  if(main && (alts != dossier->alts || tmp != dossier->old_alts)) {
    dossier->alts = copy(alts);
    dossier->old_alts = copy(tmp);
    save_player(main);
    foreach(alt in alts) {
      if(dossier->main_alt != main) {
        load_player(alt);
        dossier->main_alt = main;
        save_player(alt);
      }
    }
    foreach(alt in tmp) {
      if(dossier->main_alt != main) {
        load_player(alt);
        dossier->main_alt = main;
        save_player(alt);
      }
    }
  }
  load_player(player);
  correcting_alts = 0;
}
void reregister_parent( string player ) {
   string main;
   string * alts;
   if ( !player ) {
      return;
   }
   player = lower_case(player);
   correcting_alts = 1;
   load_player( player );
   main = dossier->main_alt;
   if ( main ) {
      load_player(main);
      alts = dossier->alts;
      if ( !alts || !sizeof( alts ) ) {
         dossier->alts = ({ player });
      } else if ( member_array( player, alts ) == -1 ) {
         dossier->alts = alts + ({ player });
      } else {
         return;
      }
      save_player( main );
   }
}
void player_refreshed(mixed player, int totally) {
  class dbentry new_entry;
  string comment;
  if(objectp(player))
    player = player->query_name();
  switch (totally) {
  case PARTIAL_REFRESH:
    comment = "They did a partial refresh.";
    break;
  case TOTAL_REFRESH:
    comment = "They did a total and complete refresh.  (Even refreshed their "
      "breath)";
    break;
  default:
    comment = "They did some weird sort of unknown refresh.";
    break;
  }
  load_player(player);
  new_entry = new(class dbentry,
                  time:       time(),
                  creator:    "Refresh Handler",
                  event:      "refresh",
                  comment:    comment,
                  extra:      0);
  do_debouncing(player, new_entry);
  save_player(player);
}
void player_deleted(mixed player, int deleted) {
  class dbentry new_entry;
  string *tmp, *tmp2, alt, main;
  if(objectp(player))
    player = player->query_name();
  if(file_size(filename(player)) == -1)
    return;
  clear_alerts_for(player);
  load_player(player);
  new_entry = new(class dbentry,
                  time:       time(),
                  creator:    "Refresh Handler",
                  event:      "delete",
                  comment:    "Player deleted",
                  extra:      0);
  do_debouncing(player, new_entry);
  save_player(player);
  if(dossier->main_alt) {
    main = dossier->main_alt;
    dossier->main_alt = 0;
    save_player(player);
    load_player(main);
    dossier->alts -= ({ player });
    dossier->old_alts += ({ player });
    save_player(main);
    return;
  }
  if(dossier->alts && sizeof(dossier->alts)) {
    tmp = filter(dossier->alts, (: PLAYER_HANDLER->test_user($1) :));
    if(sizeof(tmp))
      main = tmp[0];
    tmp2 = dossier->old_alts;
    load_player(main);
    dossier->main_alt = 0;
    if(sizeof(tmp) > 1)
      dossier->alts = copy(tmp[1..]);
    dossier->old_alts = copy(tmp2 + ({ player }));
    save_player(main);
    foreach(alt in dossier->alts) {
      load_player(alt);
      dossier->main_alt = main;
      save_player(alt);
    }
    return;
  }
}
void player_created(string player) {
  if(file_size(filename(player)) == -1)
    return;
  load_player(player);
  if(dossier->main_alt) {
    dossier->main_alt = 0;
    dossier->alts = ({ });
    save_player(player);
  }
  return;
}
void fix_alts(mixed player) {
  string *alts, alt, main;
  if(objectp(player))
    player = player->query_name();
  if(file_size(filename(player)) == -1)
    return;
  load_player(player);
  if(dossier->main_alt) {
    main = dossier->main_alt;
    load_player(dossier->main_alt);
    if(!PLAYER_HANDLER->test_user(dossier->main_alt)) {
      if(sizeof(alts))
        main = alts[0];
    }
  } else {
    main = player;
  }
  alts = ({});
  if( dossier->alts ) {
     alts = alts + dossier->alts;
  }
  if( dossier->old_alts ) {
     alts = alts + dossier->old_alts;
  }
  alts = uniq_array( alts + ({ player }));
  alts -= ({ main });
  dossier->main_alt = 0;
  dossier->alts = filter(alts, (: PLAYER_HANDLER->test_user($1) :));
  dossier->old_alts = filter(alts, (: !PLAYER_HANDLER->test_user($1) :));
  foreach(alt in alts) {
    load_player(alt);
    dossier->main_alt = main;
    dossier->alts = 0;
    dossier->old_alts = 0;
    save_player(alt);
  }
}
void reset() {
    if ( sizeof( _dossier_cache ) > CACHE_SIZE ) {
        _dossier_cache = ([ ]);
    }
}
string query_access_history( string player ) {
  mapping history;
  string ret = "";
  load_player(player);
  history = dossier->access_log;
  ret += sprintf( "Access log for player %s:\n", capitalize( player ) );
  foreach( string name in sort_array( keys( history ),
                                      (: $(history)[$2] - $(history)[$1] :) ))
    ret += sprintf( "%12s:\t%s.\n", capitalize(name),
                    query_time_string( time() - history[name], 2 ) + " ago");
  return ret;
}
mixed *stats() {
    return ({
        ({ "cache hits", _dossier_cache_hits }),
        ({ "total requests", _dossier_total }),
        ({ "cache hit %", to_int(_dossier_cache_hits * 100.0 /
                                 _dossier_total) }),
        ({ "current cache size", sizeof( _dossier_cache ) })
    });
}

==================================================
FILE: handlers/playtesters.c
==================================================

#include <board.h>
#include <project_management.h>
#include <player_handler.h>
#include <playtesters.h>
#include <login.h>
#define SAVE_FILE "/save/playtesters"
#define LEVEL 150
#define NORMAL_PLAYTESTER 1
#define SENIOR_PLAYTESTER 2
#define BUG_SKIP 10
private int count = 0;
private nosave int updating = 0;
private string* months = ({});
private mapping pts = ([]);
private mapping playtesters = ([]);
private mapping ages = ([]);
private mapping guilds = ([]);
private mapping bugs = ([]);
private mapping leave = ([]);
private mapping tmp_pts = ([ ]);
private mapping _jump_points;
private string *executives = ({ });
int query_leave (string);
void save_file() {
    unguarded( (: save_object, SAVE_FILE :) );
}
void create() {
   seteuid( master()->creator_file( file_name( this_object() ) ) );
   months = ({ });
   pts = ([ ]);
   ages = ([ ]);
   guilds = ([ ]);
   bugs = ([ ]);
   playtesters = ([ ]);
   leave = ([ ]);
   tmp_pts = ([ ]);
   _jump_points = ([ ]);
   executives = ({ });
   if ( file_size( SAVE_FILE + ".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILE, 1 :) );
   call_out( "reset", 2 );
}
string* query_playtesters() {
    return copy( keys( pts ) );
}
int query_playtester( string name ) {
  return !undefinedp( pts[ name ] );
}
int check_playtester( string ) {
    log_file( "PLAYTESTERS", file_name( previous_object() ) + " using "
              "deprecated check_playtester() call\n" );
    return 0;
}
int query_tester( mixed person ) {
    object ob;
    string str;
    if ( stringp( person ) ) {
        ob = find_player( person );
        if ( !ob ) {
            return 0;
        }
        str = person;
    } else if ( objectp( person ) ) {
        ob = person;
        str = person->query_name();
    } else {
        return 0;
    }
    return ( ob->query_creator() ||
             ob->query_property( "test character" ) ||
             query_playtester( str ) );
}
protected int get_age_raw( string name ) {
    int fu = PLAYER_HANDLER->test_age( name );
    if ( fu < 0 )
        fu = -fu;
    return fu;
}
int get_age_cached( string name ) {
    if ( ages[ name ] < 0 )
        ages[ name ] = -ages[ name ];
    return ages[ name ];
}
int get_age_uncached( string name ) {
    if ( find_player( name ) )
        ages[ name ] = find_player( name )->query_time_on();
    return get_age_cached( name );
}
int get_age_uncached_offline( string name ) {
    ages[ name ] = get_age_raw( name );
    return get_age_cached( name );
}
int query_senior_playtester( string name ) {
    return ( pts[ name ] == SENIOR_PLAYTESTER );
}
int add_playtester( string name ) {
    if ( pts[ name ] )
        return 0;
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " added as a playtester by %s\n", this_player()->query_name() );
    pts[ name ] = NORMAL_PLAYTESTER;
    ages[ name ] = get_age_uncached_offline( name );
    guilds[ name ] = PLAYER_HANDLER->test_guild( name );
    bugs[ name ] = ([ ]);
    if (tmp_pts[name]) {
      if (tmp_pts[name] == SENIOR_PLAYTESTER) {
        pts[name] = SENIOR_PLAYTESTER;
      }
      map_delete (tmp_pts, name);
    }
    PT_APPLICATION_HANDLER->delete_applicant (name);
    save_file();
    return 1;
}
int add_senior_playtester( string name ) {
    if ( pts[ name ] != NORMAL_PLAYTESTER )
        return 0;
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " promoted to senior playtester by %s\n",
              this_player()->query_name() );
    pts[ name ] = SENIOR_PLAYTESTER;
    save_file();
    return 1;
}
int remove_senior_playtester( string name, string reason ) {
    if ( pts[ name ] != SENIOR_PLAYTESTER )
        return 0;
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " demoted from senior playtester; Reason: " + reason +
              " by "+ this_player()->query_name() + "\n" );
    pts[ name ] = NORMAL_PLAYTESTER;
    save_file();
    return 1;
}
int remove_playtester( string name, string reason ) {
    string str;
    if ( !query_playtester( name ) )
        return 0;
    str = ctime( time() ) +": "+ name + " removed as a playtester";
    if ( reason ) {
        str += "; Reason: " + reason;
    }
    str += " by "+ this_player()->query_name() + "\n" ;
    log_file( "PLAYTESTERS", str + "\n" );
    map_delete( pts, name );
    map_delete( ages, name );
    map_delete( guilds, name );
    map_delete( bugs, name );
    PROJECT_HANDLER->clear_playtesting_projects (({name }));
    save_file();
    return 1;
}
string reason_invalid_playtester(string name) {
    if ( !PLAYER_HANDLER->test_user( name ) ) {
        return "not a user";
    }
    if ( PLAYER_HANDLER->test_creator( name ) ) {
        return "currently a creator";
    }
    if ( PLAYER_HANDLER->test_level( name ) < LEVEL ) {
        return "level is too low";
    }
    return 0;
}
int valid_playtester( string name ) {
    return ( !stringp( reason_invalid_playtester( name ) ) );
}
int hire_playtester( object thing ) {
    string name;
    if ( !objectp( thing ) )
        return 0;
    name = thing->query_name();
    if ( !stringp( name ) )
        return 0;
    if ( !valid_playtester( name ) )
        return 0;
    return add_playtester( name );
}
void adjust_quota( string name, int amount ) {
    string* bits;
    string right_now;
    int* bing;
    int age;
    bits = explode( ctime( time() ), " " ) - ({ "" });
    right_now = bits[ 1 ] + " " + bits[ 4 ];
    if (!bugs[name][right_now]) {
      bugs[name][right_now] = 0;
    }
    bing = bugs[ name ][ right_now ];
    age = get_age_uncached( name );
    if ( arrayp( bing ) && ( sizeof( bing ) == 3 ) ) {
        bing[ 0 ] += amount;
        bing[ 1 ] += age - bing[ 2 ];
        bing[ 2 ] = age;
    } else {
        bing = ({ amount, 0, age });
    }
    bugs[ name ][ right_now ] = bing;
    save_file();
}
protected void check_playtesters_one( string name ) {
    if ( !valid_playtester( name ) ) {
        remove_playtester( name, reason_invalid_playtester( name ) +
                           " [automatic]" );
    } else {
        adjust_quota( name, 0 );
    }
}
void check_playtesters( string* who ) {
    string* bits;
    string right_now;
    if ( sizeof( who ) ) {
        check_playtesters_one( who[ 0 ] );
        if ( sizeof( who ) > 1 ) {
            call_out( "check_playtesters", random( 10 ) + 5, who[ 1.. ] );
        } else {
            bits = explode( ctime( time() ), " " ) - ({ "" });
            right_now = bits[ 1 ] + " " + bits[ 4 ];
            if ( member_array( right_now, months ) < 0 ) {
                months += ({ right_now });
                save_file();
            }
        }
    }
}
void reset() {
    if ( !updating )
        call_out( "check_playtesters", 30, copy( keys( pts ) ) );
    updating++;
    updating %= 12;
}
void report_made( string name, string type, string file, string text ) {
    int post = 0;
    if ( !query_playtester( name ) )
        return;
    if ( regexp( type, "IDEA" ) ) {
        post = 1;
    } else if ( regexp( type, "BUG" ) ) {
        count = ( count + 1 ) % BUG_SKIP;
        post = ( count == 0 );
    }
    if ( post ) {
        BOARD_HAND->add_message( "playtester_bugs", capitalize( name ),
                                 type + " for " + file,
                                 sprintf( "%75-=s", text ) );
    }
    adjust_quota( name, 1 );
}
string query_show_list() {
    string result;
    result = "              ";
    foreach ( string month in months[ <5.. ] ) {
        result += "    " + month;
    }
    result += "\n";
    foreach ( string name in sort_array( query_playtesters(), 1 ) ) {
        if ( query_senior_playtester( name ) ) {
            result += "S ";
        } else {
            result += "  ";
        }
        if ( stringp( leave[ name ] ) )
            result += sprintf( "%-14s", "[" + name + "]" );
        else
            result += sprintf( " %-12s ", name );
        foreach ( string month in months[ <5.. ] ) {
            if ( sizeof( bugs[ name ][ month ] ) >= 2 )
                result += sprintf( "   %4d %4d", bugs[ name ][ month ][ 0 ],
                                   ( bugs[ name ][ month ][ 1 ] / 3600 ) );
            else
                result += "   ---- ----";
        }
        result += "\n";
    }
    return result;
}
string query_show_list_colour() {
    string result;
    string colour;
    int online, reports;
    string temp;
    result = "              ";
    foreach ( string month in months[ <5.. ] ) {
        result += "    " + month;
    }
    result += "\n";
    foreach ( string name in sort_array( query_playtesters(), 1 ) ) {
        reports = 0;
        online = 0;
        if ( query_senior_playtester( name ) ) {
            temp = "S ";
        } else {
            temp = "  ";
        }
        temp += sprintf( "%%s%-12s%%%%^RESET%%%%^", name );
        foreach ( string month in months[ <5.. ] ) {
	          if (query_leave (name)) {
                    colour = "%%^WHITE%%^";
	          }
            else if ( sizeof( bugs[ name ][ month ] ) >= 2 ) {
                reports += bugs[ name ][ month ][ 0 ];
                online += bugs[ name ][ month ][ 1 ];
                if ( bugs[ name ][ month ][ 1 ] == 0 )
                    colour = ( stringp( leave[ name ] ) ?
                               "%%^MAGENTA%%^" :
                               "%%^BOLD%%^%%^MAGENTA%%^" );
                else if ( bugs[ name ][ month ][ 0 ] >=
                     ( bugs[ name ][ month ][ 1 ] / 7200 ) )
                    colour = ( stringp( leave[ name ] ) ?
                               "%%^GREEN%%^" :
                               "%%^BOLD%%^%%^GREEN%%^" );
                else if ( bugs[ name ][ month ][ 0 ] <
                          ( bugs[ name ][ month ][ 1 ] / 24000 ) )
                    colour = ( stringp( leave[ name ] ) ?
                               "%%^RED%%^" :
                               "%%^BOLD%%^%%^RED%%^" );
                else
                    colour = ( stringp( leave[ name ] ) ?
                               "%%^ORANGE%%^" :
                               "%%^YELLOW%%^" );
                temp += sprintf( "   %s%4d %4d%%%%^RESET%%%%^",
                                 colour,
                                 bugs[ name ][ month ][ 0 ],
                                 ( bugs[ name ][ month ][ 1 ] / 3600 ) );
            } else
                temp += "   ---- ----";
        }
        temp += "\n";
        if ( online == 0 )
            colour = ( stringp( leave[ name ] ) ?
                       "%^BOLD%^%^WHITE%^" :
                       "%^BOLD%^%^MAGENTA%^" );
        else if ( reports >= ( online / 7200 ) )
            colour = ( stringp( leave[ name ] ) ?
                       "%^GREEN%^" :
                       "%^BOLD%^%^GREEN%^" );
        else if ( reports < ( online / 24000 ) )
            colour = ( stringp( leave[ name ] ) ?
                       "%^RED%^" :
                       "%^BOLD%^%^RED%^" );
        else
            colour = ( stringp( leave[ name ] ) ?
                       "%^ORANGE%^" :
                       "%^YELLOW%^" );
        result += sprintf( temp, colour );
    }
    return result;
}
mapping query_playtester_guilds() {
    mapping r = ([]);
    foreach ( string pt, string guild in guilds ) {
        if ( arrayp( r[ guild ] ) )
            r[ guild ] += ({ pt });
        else
            r[ guild ] = ({ pt });
    }
    return r;
}
mapping query_guilds() {
    return copy( guilds );
}
void update_guilds() {
  string guild;
    foreach( string player, mapping data in playtesters ) {
        if ( !sizeof (data[ "guild" ]) ) {
            guild = PLAYER_HANDLER->test_guild( player );
            if (!sizeof (guild)) {
              guild = "/std/guilds/standard";
            }
            data[ "guild" ] = guild;
        }
    }
    save_file();
}
mixed query_pt_data( string name ) {
    if ( !undefinedp( playtesters[ name ] ) )
        return copy( playtesters[ name ] );
    return 0;
}
mapping query_bugs( string name ) {
    return copy( bugs[ name ] );
}
string* query_months() {
    return copy( months );
}
int set_leave( string name, string reason ) {
    if ( pts[ name ] ) {
        leave[ name ] = reason;
        log_file( "PLAYTESTERS", ctime( time() ) + ": " + name + " marked as "
                  "on leave: " + reason + "\n" );
        save_file();
        return 1;
    } else {
        return 0;
    }
}
int reset_leave( string name ) {
    if ( leave[ name ] ) {
        map_delete( leave, name );
        log_file( "PLAYTESTERS", ctime( time() ) + ": " + name + " no longer "
                  "marked as on leave\n" );
        save_file();
        return 1;
    } else {
        return 0;
    }
}
int query_leave( string name ) {
    return stringp( leave[ name ] );
}
#ifdef PLAYTESTERS_HANDLER_OLD_STYLE_CONVERSION
void transfer_data_callout( string* pts ) {
    string pt;
    mixed bing;
    int lastage;
    int nowage;
    if ( sizeof( pts ) ) {
        pt = pts[ 0 ];
        nowage = get_age_uncached_offline( pt );
        lastage = nowage - playtesters[ pt ][ "age" ];
        guilds[ pt ] = PLAYER_HANDLER->test_guild( pt );
        ages[ pt ] = nowage;
        bugs[ pt ] = ([ ]);
        foreach ( string s in keys( playtesters[ pt ] ) -
                  ({ "senior", "age", "current age", "guild" }) ) {
            bing = playtesters[ pt ][ s ];
            if ( arrayp( bing ) ) {
                bugs[ pt ][ s ] = ({ bing[ 0 ], bing[ 1 ], nowage });
            } else if ( intp( bing ) ) {
                bugs[ pt ][ s ] = ({ bing, lastage, nowage });
            }
        }
        tell_creator( "arienne", "Done " + pt + "!\n" );
        if ( sizeof( pts ) > 1 ) {
            call_out( "transfer_data_callout", 5, pts[ 1.. ] );
        } else {
            save_file();
            tell_creator( "arienne", "Done the transfer!\n" );
        }
    }
}
void transfer_data_to_new_system() {
    foreach ( string pt in keys( playtesters ) ) {
        if ( playtesters[ pt ][ "senior" ] )
            pts[ pt ] = SENIOR_PLAYTESTER;
        else
            pts[ pt ] = NORMAL_PLAYTESTER;
    }
    call_out( "transfer_data_callout", 5, copy( keys( playtesters ) ) );
}
#endif
mapping query_jump_points() {
   if (!_jump_points) {
      _jump_points = ([ ]);
   }
   return copy(_jump_points);
}
void add_jump_point(string from, string to) {
   if (!_jump_points[from]) {
      _jump_points[from] = ({ });
   }
   _jump_points[from] += ({ to });
   save_file();
}
void remove_jump_point_from(string from) {
   map_delete(_jump_points, from);
   save_file();
}
void remove_jump_point(string from, string to) {
   if (_jump_points[from]) {
      _jump_points[from] -= ({ to });
      if (!sizeof(_jump_points[from])) {
         map_delete(_jump_points, from);
      }
      save_file();
   }
}
string* query_jump_destination(string from) {
   return _jump_points[from];
}
int add_pt_exec( string name ) {
    if ( undefinedp (pts[ name ]))
        return 0;
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " promoted to playtester executive by %s\n",
              this_player()->query_name() );
    executives += ({ name });
    save_file();
    return 1;
}
int remove_pt_exec( string name ) {
    if ( !undefinedp (pts[ name ]))
        return 0;
    if (member_array (name, executives) == -1) {
      return 0;
    }
    log_file( "PLAYTESTERS", ctime( time() ) + ": " + name +
              " removed from playtester executive by %s\n",
              this_player()->query_name() );
    executives -= ({ name });
    save_file();
    return 1;
}
int query_pt_exec(string name) {
  if (member_array (name, executives) == -1) {
    return 0;
  }
  return 1;
}
int query_exec_access (string name) {
  if (master()->query_senior(name)) {
    return 1;
  }
  if (query_pt_exec (name)) {
    return 1;
  }
  if (query_senior_playtester (name)) {
    return 1;
  }
  if (load_object ("/d/playtesters/master")->query_deputy (name)) {
    return 1;
  }
  return 0;
}

==================================================
FILE: handlers/potion.c
==================================================

inherit "/std/object";
mapping paths = allocate_mapping(10);
mapping potions = allocate_mapping(10);
#define POTION_DIR "/obj/potions/"
string *directories = ({
    POTION_DIR,
});
void create() {
    string dir, s, dummy, title, path, index;
    int d, i;
    seteuid("Room");
    for (d = 0; d < sizeof(directories); d++) {
        dir = directories[d];
        index = dir + "index";
        i = 1;
        if (file_size(index) > 0) {
            while (s = read_file(index, i++, 1)) {
                if ((s == "") || (sscanf(s, "#%s", dummy))) {
                    continue;
                }
                if (sscanf(s, "\"%s\"%*s\"%s\"", title, path) != 3) {
                    continue;
                }
                paths[title] = path;
                potions[title] = 0;
            }
        }
    }
    ::create();
}
int query_min_level(string s) {
    s = this_player()->expand_nickname(s);
    if (undefinedp(paths[s])) {
        return -1;
    }
    if (!potions[s]) {
        potions[s] = clone_object(paths[s]);
    }
    return potions[s]->query_min_level();
}
string query_chant(string s) {
    s = this_player()->expand_nickname(s);
    if (undefinedp(paths[s])) {
        return 0;
    }
    if (!potions[s]) {
        potions[s] = clone_object(paths[s]);
    }
    return potions[s]->query_chant();
}
object query_potion(string s) {
    s = this_player()->expand_nickname(s);
    if (undefinedp(paths[s])) {
       return 0;
    }
    if (!potions[s]) {
       potions[s] = clone_object(paths[s]);
    }
    return potions[s];
}
mixed clone_reagent(string s) {
    object pot;
    string potion;
    potion = this_player()->expand_nickname(s);
    if (undefinedp(paths[potion])) {
      return -1;
    }
    pot = query_potion(s);
    printf("Verb = %O\n", query_verb());
    return pot->clone_reagent(query_verb());
}
mapping query_paths() {
    return paths;
}
mapping query_potions() {
    return potions;
}

==================================================
FILE: handlers/potion_space.c
==================================================

#define SAVE_FILE "/save/potion_space"
mixed *effect_vols;
void create() {
  seteuid("Room");
  unguarded((: restore_object, SAVE_FILE :));
}
int add_effect(string ob, int x1, int x2, int y1, int y2) {
   if (!stringp(ob)) {
      tell_object(this_player(), "Effect object must be a string.\n");
      return 0;
   }
   effect_vols = ({ ob, x1, x2, y1, y2 }) + effect_vols;
   unguarded((: save_object, SAVE_FILE :));
   return 1;
}
int remove_effect(object ob) {
   int i;
   for (i = 0; i < sizeof(effect_vols); i+=5)
      if (effect_vols[i] == ob) {
         effect_vols = effect_vols[0..i-1] + effect_vols[i+5..sizeof(effect_vols)];
         break;
      }
   unguarded((: save_object, SAVE_FILE :));
   return 1;
}
string *query_effect_at(int *coord) {
   int i;
   string *obs;
   obs = ({ });
   for (i = 0; i < sizeof(effect_vols); i+=5) {
      if (coord[0] >= effect_vols[i+1] && coord[0] <= effect_vols[i+2] &&
          coord[1] >= effect_vols[i+3] && coord[1] <= effect_vols[i+4])
         obs += ({ effect_vols[i] });
   }
   return obs;
}
mixed *query_attrs_at(int *coord){
   string *effects;
   int sum, i, pass_through;
   mixed *attrs, *temp_attrs;
   effects = query_effect_at(coord);
   if (!sizeof(effects)) return ({ 0, 100, ({ }), ({ }), ({ }), ({ }) });
   attrs = effects[0]->query_attrs(coord);
   sum = 100;
   pass_through = effects[0]->query_pass_through(coord);
   i = 1;
   while (pass_through && i < sizeof(effects)) {
      if (effects[i]->backdrop()) break;
      temp_attrs = effects[i]->query_attrs(coord);
      attrs = "/obj/container"->merge_potions(attrs, temp_attrs,
                                   sum, pass_through, sum + pass_through);
      sum += pass_through;
      pass_through = effects[i]->query_pass_through(coord);
      i++;
   }
   return attrs;
}
void potion_drunk(mixed ob, int *coord, int quantity) {
   string *effects;
   int i, pass_through;
   effects = query_effect_at(coord);
   pass_through = 100;
   for (i = 0; i < sizeof(effects) && pass_through; i++) {
      if (i > 0 && effects[i]->backdrop()) break;
      effects[i]->action_drunk(ob, coord, quantity * pass_through / 100);
      pass_through = pass_through * effects[i]->query_pass_through(coord) / 100;
   }
   return;
}
void potion_touch(mixed ob, int *coord, int quantity) {
   string *effects;
   int i, pass_through;
   effects = query_effect_at(coord);
   pass_through = 100;
   for (i = 0; i < sizeof(effects) && pass_through; i++) {
      if (i > 0 && effects[i]->backdrop()) break;
      effects[i]->action_touch(ob, coord, quantity * pass_through / 100);
      pass_through = pass_through * effects[i]->query_pass_through(coord) / 100;
   }
   return;
}
void potion_smell(mixed ob, int *coord, int quantity) {
   string *effects;
   int i, pass_through;
   effects = query_effect_at(coord);
   pass_through = 100;
   for (i = 0; i < sizeof(effects) && pass_through; i++) {
      if (i > 0 && effects[i]->backdrop()) break;
      effects[i]->action_smell(ob, coord, quantity * pass_through / 100);
      pass_through = pass_through * effects[i]->query_pass_through(coord) / 100;
   }
   return;
}
void potion_create(mixed ob, int *coord, int quantity) {
   string *effects;
   int i, pass_through;
   effects = query_effect_at(coord);
   pass_through = 100;
   for (i = 0; i < sizeof(effects) && pass_through; i++) {
      if (i > 0 && effects[i]->backdrop()) break;
      effects[i]->action_create(ob, coord, quantity * pass_through / 100);
      pass_through = pass_through * effects[i]->query_pass_through(coord) / 100;
   }
   return;
}
mixed *query_effect_vols() {
   return effect_vols + ({ });
}
int *neutral_coordinate() {
   return ({ 0, 0 });
}

==================================================
FILE: handlers/project_management.c
==================================================

#include "project_management.h"
#include <playtesters.h>
#include <permissions.h>
#include <board.h>
#include <mail.h>
#include <cmds/twiki.h>
int query_project_completeness(string);
string* query_project_tasks(string);
int valid_operation (string name, string action, string project);
int find_project (string);
void do_save();
int nuke_creator_project_cache(string*);
string* query_projects_for_creator (string);
int clear_file_cache (string nfile);
void do_mail (string*, string);
int clear_playtesting_projects (string*);
class project* filter_by_query (mapping);
void catch_status_change (string, int);
class file_access_cache {
  string id;
  mapping accesses;
}
string *pt_post_cache = ({ });
class project *projects = ({ });
class project_tmp *tmp_projects = ({ });
int touched;
int last_summary;
mapping summary;
mapping num_assignments;
nosave mapping inform = ([ ]);
nosave mapping creator_project_cache = ([ ]);
nosave mapping pt_assignment_cache = ([ ]);
nosave class file_access_cache *cache = ({ });
nosave string *excluded = ({
  "bfg",
  "dionysus",
  "melian",
});
mapping project_locks = ([ ]);
void save_file() {
  if (find_call_out ("do_save") == -1) {
    call_out ("do_save", 10);
  }
}
void do_log (string text) {
  log_file (PROJECT_LOG, text);
}
void do_save() {
  seteuid ("Root");
  touched = 1;
  unguarded ((: save_object, PROJECT_SAVE :));
  touched = 0;
}
void do_load() {
  unguarded ((: restore_object, PROJECT_SAVE :));
}
void create() {
  string *creators = ({ });
  do_load();
  if (!last_summary) {
    last_summary = time();
  }
  if (!summary) {
    summary = ([ ]);
  }
  if (!tmp_projects) {
    tmp_projects = ({ });
  }
  if (!creator_project_cache) {
    creator_project_cache = ([ ]);
  }
  if (!cache) {
    cache = ({ });
  }
  if (!pt_post_cache) {
    pt_post_cache = ({ });
  }
  if (!num_assignments) {
    num_assignments = ([ ]);
  }
  foreach (class project p in projects) {
    creators += p->creators;
  }
  creators = uniq_array (creators);
  foreach (string c in creators) {
    query_projects_for_creator (c);
  }
}
void touch_project (string id, string reason, string name) {
  int i = find_project (id);
  object ob;
  if (i == -1) {
    return;
  }
  projects[i]->last_touched = time();
  projects[i]->what_touched = reason;
  projects[i]->touched_by = name;
  save_file();
  if (find_call_out ("do_inform") == -1) {
    call_out ("do_inform", 120);
  }
  if (undefinedp (summary[id])) {
    summary[id] = ({ name });
  }
  else {
    summary[id] += ({ name });
  }
  if (undefinedp (inform[id])) {
    inform[id] = ({ name });
  }
  else {
    inform[id] += ({ name });
  }
  foreach (string d in projects[i]->domains) {
    ob = load_object ("/d/" + d + "/master");
    if (ob) {
      ob->nuke_creator_project_cache (projects[i]->creators);
    }
    nuke_creator_project_cache (projects[i]->creators);
  }
  do_log (sprintf ("%s:  Project %s touched by %s:  %s\n",
    ctime (time()), id, name, reason));
}
void do_inform() {
  int i;
  foreach (string id, string *names in inform) {
    i = find_project (id);
    user_event ("inform", sprintf ("%s: Project %s touched by %s",
      query_multiple_short(map (projects[i]->domains, (: capitalize ($1) :))),
      id, query_multiple_short (map (uniq_array (names),
      (: capitalize ($1) :)))), "message", this_player());
  }
  inform = ([ ]);
}
string* query_projects_for_creator (string c) {
  if (!creator_project_cache[c]) {
    creator_project_cache[c] = map (filter_by_query ((["creators": c])),
      (: $1->id :));
  }
  return creator_project_cache[c];
}
string* query_projects_for_creator_in_domain (string creator, string domain) {
  return sort_array (map (filter_by_query ((["creators": creator, "domains" : domain])),
      (: $1->name :)), 1);
}
string query_touched (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  if (!projects[i]->last_touched) {
    return "This project has not been touched since it was added.";
  }
  return sprintf ("%s last touched project %s on %s:  %s.",
    (projects[i]->touched_by ? capitalize (projects[i]->touched_by) :
    "Someone"), id,
    ctime (projects[i]->last_touched), projects[i]->what_touched);
}
mapping query_summary_mapping() {
  return summary;
}
int query_last_summary() {
  return last_summary;
}
string query_summary_page() {
  string ret = "Project changes since " + ctime (last_summary) + "\n\n";
  foreach (string proj, string *names in summary) {
    ret += sprintf ("%-30s touched by %s\n",
      proj, query_multiple_short (uniq_array (names)));
  }
  return ret;
}
int insert_into_projects (mixed temp) {
  int index = 0;
  if (!sizeof (projects)) {
    projects = ({ temp });
    return 0;
  }
  while (index < sizeof (projects) && temp->id > projects[index]->id) {
    index++;
  }
  if (index == sizeof (projects)) {
    projects = projects + ({ temp });
  }
  else if (index == 0) {
    projects = ({ temp }) + projects;
  }
  else {
    projects = projects[0..index-1] + ({ temp }) +
      projects[index..sizeof(projects)];
  }
  return index;
}
int insert_into_cache (mixed temp) {
  int index = 0;
  if (!sizeof (cache)) {
    cache = ({ temp });
    return 0;
  }
  while (index < sizeof (cache) && temp->id > cache[index]->id) {
    index++;
  }
  if (index == sizeof (cache)) {
    cache = cache + ({ temp });
  }
  else if (index == 0) {
    cache = ({ temp }) + cache ;
  }
  else {
    cache = cache[0..index-1] + ({ temp }) +
      cache[index..sizeof(cache)];
  }
  return index;
}
int insert_into_tasks (int i, mixed temp) {
  int index = 0;
  if (!sizeof (projects[i]->tasks)) {
    projects[i]->tasks = ({ temp });
    return 0;
  }
  while (index < sizeof (projects[i]->tasks) &&
    temp->id > projects[i]->tasks[index]->id) {
      index++;
  }
  if (index == sizeof (projects[i]->tasks)) {
    projects[i]->tasks = projects[i]->tasks + ({ temp });
  }
  else if (index == 0) {
    projects[i]->tasks = ({ temp }) + projects[i]->tasks;
  }
  else {
    projects[i]->tasks = projects[i]->tasks[0..index-1] + ({ temp })
      + projects[i]->tasks[index..sizeof(projects[i]->tasks)];
  }
  return index;
}
int insert_into_notes (int i, mixed temp) {
  int index = 0;
  if (!sizeof (projects[i]->notes)) {
    projects[i]->notes = ({ temp });
    return 0;
  }
  while (index < sizeof (projects[i]->notes) &&
    temp->id > projects[i]->notes[index]->id) {
      index++;
  }
  if (index == sizeof (projects[i]->notes)) {
    projects[i]->notes = projects[i]->notes + ({ temp });
  }
  else if (index == 0) {
    projects[i]->notes = ({ temp }) + projects[i]->notes;
  }
  else {
    projects[i]->notes = projects[i]->notes[0..index-1] + ({ temp })
      + projects[i]->notes[index..sizeof(projects[i]->notes)];
  }
  return index;
}
protected int find_index (string id, mixed array) {
  int mid, right, left;
  if (!sizeof (array)) {
    return -1;
  }
  right = sizeof (array);
  mid = (left + right) / 2;
  left = 0;
  do {
    if (array[mid]->id == id) {
      return mid;
    }
    if (id > array[mid]->id) {
      left = mid + 1;
      mid = (left + right) / 2;
    }
    else if (id < array[mid]->id) {
      right = mid;
      mid = (left + right) / 2;
    }
  } while (left < right);
  return -1;
}
string parse_details(class project p) {
  string ret = sprintf ("$I$5=The %s (%s) project belongs to the %s %s and is "
    "in %s, with assigned creators of: %s.\n",
    p->id, p->name, query_multiple_short (p->domains),
    (sizeof (p->domains) == 1 ? "domain" : "domains"), STATUS[p->status],
    query_multiple_short (p->creators));
    ret = replace (ret, ({"$I$5=", "<p>"}));
  return ret;
}
int find_project (string id) {
  int i = find_index (id, projects);
  return i;
}
int find_note(mixed i, string id) {
  int j;
  if (!intp(i)) {
    i = find_project (i);
  }
  j = find_index (id, projects[i]->notes);
  return j;
}
int find_task(mixed i, string id) {
  int j;
  if (!intp(i)) {
    i = find_project (i);
  }
  j = find_index (id, projects[i]->tasks);
  return j;
}
class file* find_file(mixed i, string nfile, string task) {
  int j;
  class file *tmp = ({ });
  if (!intp(i)) {
    i = find_project (i);
  }
  if (!sizeof (projects[i]->files)) {
    return tmp;
  }
  for (j=0; j < sizeof (projects[i]->files); j++) {
    if (projects[i]->files[j]->file == nfile) {
      if (sizeof (task)) {
        if (task == "leader" || projects[i]->files[j]->task == task) {
          tmp += ({ projects[i]->files[j] });
        }
      }
      else if (!sizeof (projects[i]->files[j]->task)) {
          tmp += ({ projects[i]->files[j] });
      }
    }
  }
  return tmp;
}
int find_cache_file (string file) {
  int i = find_index (file, cache);
  return i;
}
int delete_project (string id, string name) {
  int i = find_index (id, projects);
  if (i == -1) {
    return 0;
  }
  projects -= ({ projects[i] });
  do_log (sprintf ("%s:  %s deleted project %s.\n",
    ctime(time()), name, id));
  save_file();
  return 1;
}
int delete_task (string id, string task_id, string name) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  projects[i]->tasks -= ({ projects[i]->tasks[j] });
  touch_project (id, "Deleted task " + task_id, name);
  return 1;
}
int delete_note (string id, string note_id, string name) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_note (i, note_id);
  if (j == -1) {
    return 0;
  }
  projects[i]->notes -= ({ projects[i]->notes[j] });
  touch_project (id, "Deleted note " + note_id, name);
  return 1;
}
int add_project (string id, string nname, string lead, string desc,
  string *dom, string *cre, string add_name, int size, int complexity,
  string *guilds) {
  int i;
  class project tmp;
  if (find_project (id) != -1) {
    return -1;
  }
  tmp = new (class project, id: id, name: nname, leader: lead,
    date_added: time(), added_by: add_name,
    date_completed: 0, status: 0, estimated_completion: 0,
    description: desc, domains: dom, creators: (sizeof (cre) ? cre :
    ({})), playtesters: ({ }), tasks: ({ }),
    files: ({ }), twiki: ({ }), percent_complete: 0, sub_projects: ({ }),
    notes: ({ }), size: size, complexity: complexity, guild_specific :
    guilds);
  i = insert_into_projects (tmp);
  touch_project (id, "Project added", add_name);
  return i;
}
int add_cache_file (string id) {
  int i;
  class file_access_cache tmp;
  if (find_cache_file (id) != -1) {
    return -1;
  }
  tmp = new (class file_access_cache, id: id, accesses: ([ ]));
  i = insert_into_cache (tmp);
  return i;
}
int set_completion_date (string id, int date) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  projects[i]->estimated_completion = date;
}
int add_creator (string id, string creator) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  if (!sizeof (projects[i]->creators)) {
    projects[i]->creators = ({ creator });
  }
  else if (member_array (creator, projects[i]->creators) == -1) {
    projects[i]->creators += ({ creator });
  }
  return 1;
}
int add_twiki (string id, string twiki) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  if (!sizeof (projects[i]->twiki)) {
    projects[i]->twiki = ({ twiki });
  }
  else {
    projects[i]->twiki += ({ twiki });
  }
  return 1;
}
string* query_twiki (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return copy (projects[i]->twiki);
}
class file* query_files (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return copy (projects[i]->files);
}
int add_file (string id, string file, int access, string name, string task) {
  int i = find_project (id);
  int k;
  mixed ob;
  class file tmp;
  class file *files = ({ });
  if (i == -1) {
    return 0;
  }
  if (access == GRANT_MASK || access == LOCK_MASK) {
    ob = find_player (name);
    if (!ob) {
      return 0;
    }
  }
  if (!ob) {
    ob = name;
  }
  k = master()->valid_grant (ob, file, access);
  if (!k) {
    log_file ("CHEAT", ctime(time()) + ": " + name + " tried to add "
      "level " + access + " access to file " + file + "\n");
    return 0;
  }
  tmp = new (class file, file: file, access: access, task: task);
  if (!sizeof (projects[i]->files)) {
    projects[i]->files = ({ tmp });
  }
  else {
    files = find_file (i, file, task);
    foreach (class file f in files) {
      if (f->access == access && f->task == task) {
        return 0;
      }
    }
    projects[i]->files += ({ tmp });
  }
  clear_file_cache (file);
  touch_project (id, "Added a file permission", name);
  return 1;
}
int remove_file (string id, string file, string task, string name) {
  int i = find_project (id);
  class file *tmp = ({ });
  if (i == -1) {
    return 0;
  }
  tmp = find_file (i, file, task);
  if (!sizeof (tmp)) {
    return 0;
  }
  foreach (class file f in tmp) {
    if (f->task == task) {
      projects[i]->files -= ({ f });
      break;
    }
  }
  clear_file_cache (file);
  touch_project (id, "Removed a file permission", name);
  return 1;
}
int reset_files (string id) {
  int i = find_project (id);
  projects[i]->files = ({ });
}
int add_domain (string id, string domain) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  if (!sizeof (projects[i]->domains)) {
    projects[i]->domains = ({ domain });
  }
  else {
    projects[i]->domains += ({ domain });
  }
  return 1;
}
int set_project_leader (string id, string leader) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  projects[i]->leader= leader;
}
string query_project_leader (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return projects[i]->leader;
}
string* query_project_subprojects (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return projects[i]->sub_projects;
}
string* query_projects() {
  return map (projects, (: $1->id :));
}
int set_status (string id, int stat) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  if (stat >= sizeof (STATUS)) {
    return 0;
  }
  projects[i]->status = stat;
  catch_status_change (id, stat);
}
int query_status (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return projects[i]->status;
}
string query_all_projects_info() {
  string ret = "";
  foreach (class project p in projects) {
    ret += parse_details (p);
  }
  return ret;
}
string* query_project_tasks (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return map (projects[i]->tasks, (: $1->id :));
}
string* query_project_notes (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  if (!sizeof (projects[i]->notes)) {
    return 0;
  }
  return map (projects[i]->notes, (: $1->id :));
}
string* query_project_domains (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return projects[i]->domains;
}
int set_description (string id, string desc) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  projects[i]->description = desc;
  return 1;
}
string query_description (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return projects[i]->description;
}
int set_status_change(string id, int time) {
  int i = find_project (id);
  if (time) {
    projects[i]->last_status_change = time;
  }
}
string project_info (string id) {
  int i = find_project (id);
  string ret = "";
  if (i == -1) {
    return "There is no project with that ID.\n";
  }
  ret += sprintf ("\n$I$5=Project %s (%s) belongs to the %s %s.\n",
    id, projects[i]->name, query_multiple_short
      (projects[i]->domains), (sizeof(projects[i]->domains) == 1 ?
      "domain" : "domains"));
  if (sizeof (projects[i]->description)) {
    ret += sprintf ("$I$5=Project %s has the following description: \n",
      id, projects[i]->description);
  }
  ret += sprintf ("$I$5=Project %s is %s percent complete.\n",
    id, query_num (query_project_completeness (id)));
  ret += sprintf ("$I$5=Project %s has a project leader of: %s.\n",
    id, projects[i]->leader);
  ret += sprintf ("$I$5=Project %s has the following assigned creators:  %s.\n",
    id, query_multiple_short (projects[i]->creators));
  ret += sprintf ("$I$5=Project %s is currently: in %s.\n",
    id, STATUS[projects[i]->status]);
  ret += sprintf ("$I$5=Project %s was added at: %s by %s.\n",
    id, ctime (projects[i]->date_added), projects[i]->added_by);
  if (sizeof (projects[i]->twiki)) {
    ret += sprintf ("$I$5=Project %s has the following twiki pages: %s.\n",
      id, query_multiple_short (projects[i]->twiki));
  }
  if (sizeof (projects[i]->tasks)) {
    ret += sprintf ("$I$5=Project %s has the following tasks: %s.\n",
      id, query_multiple_short (query_project_tasks (id)));
  }
  if (projects[i]->estimated_completion) {
    ret += sprintf ("$I$5=Project %s will be completed by the estimated date "
      "of: %s.\n", id, ctime (projects[i]->estimated_completion));
  }
    ret = replace (ret, ({"$I$5=", "<p>"}));
  return ret;
}
string task_info (string id, string task_id) {
  int i = find_project (id);
  int j;
  string ret = "";
  if (i == -1) {
    return "There is no project with that ID.\n";
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return "There is no task with that ID for project " + id + ".\n";
  }
  ret += sprintf ("Project %s:  task %s.\n", id, task_id);
  ret += sprintf ("task %s is %s percent complete.\n",
    task_id, query_num (projects[i]->tasks[j]->percent_complete));
  ret += sprintf ("task %s has the following assigned creators:  %s.\n",
    query_multiple_short (projects[i]->tasks[j]->assigned_to));
  return ret;
}
int set_project_completeness (string id, int percent) {
  int i = find_project (id);
  if (i == -1) {
    return -1;
  }
  projects[i]->percent_complete = percent;
}
int set_project_name (string id, string name) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  projects[i]->name = name;
}
string query_project_name (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return projects[i]->name;
}
int query_project_completeness (string id) {
  int i = find_project(id);
  int percent = 0;
  int counter = 0;
  string p;
  if (i == -1) {
    return 0;
  }
  if (projects[i]->percent_complete) {
    return projects[i]->percent_complete;
  }
  if (!sizeof (projects[i]->tasks)) {
    return 0;
  }
  if (sizeof (projects[i]->sub_projects)) {
    foreach (p in projects[i]->sub_projects) {
      if (p == id) {
        continue;
      }
      percent += query_project_completeness (p);
      counter++;
    }
  }
  foreach (class task bing in projects[i]->tasks) {
      if (!intp (bing->percent_complete)) {
        bing->percent_complete = to_int (bing->percent_complete);
      }
      percent += bing->percent_complete;
      counter++;
  }
  return percent / counter;
}
int update_project_task_completeness (string id, string task, int percent) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return -1;
  }
  j = find_task (i, task);
  if (j == -1) {
    return -1;
  }
  projects[i]->tasks[j]->percent_complete = percent;
}
int assign_project_task_creator (string id, string task, string creator) {
  int i = find_project (id);
  int j;
  string *cres;
  if (i == -1) {
    return -1;
  }
  j = find_task (i, task);
  if (j == -1) {
    return -1;
  }
  cres = projects[i]->tasks[j]->assigned_to;
  if (!sizeof (cres)) {
    cres = ({ creator });
  }
  else {
    cres += ({ creator });
  }
  projects[i]->tasks[j]->assigned_to = cres;
  if (member_array (creator, projects[i]->creators) == -1) {
    add_creator (id, creator);
  }
  return 1;
}
int add_task_to_project (string id, string task_id, string name, string aim) {
  int i = find_project (id);
  int j;
  class task tmp;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j != -1) {
    return 0;
  }
  tmp = new (class task, id: task_id, added_by: name,
    date_added: time(), aims: aim);
  touch_project (id, "Added task " + task_id, name);
  return insert_into_tasks (i, tmp);
}
int add_note_to_project (string id, string note_id, string note, string name) {
  int i = find_project (id);
  int j;
  class note tmp;
  if (i == -1) {
    return 0;
  }
  j = find_note (i, note_id);
  if (j != -1) {
    return 0;
  }
  tmp = new (class note, id: note_id, note: note, added_by: name,
    date_added: time());
  touch_project (id, "Added note " + note_id, name);
  return insert_into_notes (i, tmp);
}
int set_task_name (string id, string task_id, string name) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  projects[i]->tasks[j]->task_name = name;
  return 1;
}
int set_task_aims (string id, string task_id, string aims) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  projects[i]->tasks[j]->aims = aims;
  return 1;
}
string query_task_aims (string id, string task_id) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  return projects[i]->tasks[j]->aims;
  }
string query_task_name (string id, string task_id) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  return projects[i]->tasks[j]->task_name;
}
class task* project_task_data (string id) {
  int i = find_project (id);
  if (i == -1) {
    return ({ });
  }
  return projects[i]->tasks;
}
class note* project_note_data (string id) {
  int i = find_project (id);
  if (i == -1) {
    return ({ });
  }
  return projects[i]->notes;
}
int set_task_comments (string id, string task_id, string comments) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  projects[i]->tasks[j]->comments = comments;
  return 1;
}
string query_task_comments (string id, string task_id) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  return projects[i]->tasks[j]->comments;
}
int add_task_creator (string id, string task_id, string creator) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  if (!sizeof (projects[i]->tasks[j]->assigned_to)) {
    projects[i]->tasks[j]->assigned_to= ({ creator });
  }
  else {
    projects[i]->tasks[j]->assigned_to+= ({ creator });
  }
  return 1;
}
string* query_task_creators (string id, string task_id) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  return projects[i]->tasks[j]->assigned_to;
}
int set_task_completion (string id, string task_id, int percent) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  projects[i]->tasks[j]->percent_complete = percent;
  return 1;
}
int query_task_competion (string id, string task_id) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  return projects[i]->tasks[j]->percent_complete;
}
int set_task_completion_date(string id, string task_id, int date) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  projects[i]->tasks[j]->completion_date = date;
  return 1;
}
int query_task_completion_date (string id, string task_id) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, task_id);
  if (j == -1) {
    return 0;
  }
  return projects[i]->tasks[j]->completion_date;
}
class project* filter_by_query (mapping query) {
  string tmp_str, *tmp_arr;
  int match, unassigned = 0;
  class project *tmp = ({ });
  string *un = ({"unassigned", "none", "no-one", "noone", "nobody"});
  if (member_array (query["creators"], un) != -1) {
    unassigned = 1;
  }
  foreach (class project p in projects) {
    match = 0;
    tmp_str = query ["projid"];
    if (sizeof (tmp_str)) {
      if (p->id == query["projid"]) {
        match = 1;
      }
      else {
        continue;
      }
    }
    tmp_str = query ["domains"];
    if (sizeof (tmp_str)) {
      tmp_arr = explode (replace (tmp_str, ({" ", ""})), ",");
      if (sizeof (map (tmp_arr, (: lower_case ($1) :))
        & map (p->domains, (: lower_case ($1) :))) == sizeof (tmp_arr)) {
        match = 1;
      }
      else {
        continue;
      }
    }
    tmp_str = query["creators"];
    if (sizeof (tmp_str)) {
      tmp_arr = explode (replace (tmp_str, ({" ", ""})), ",");
      if (sizeof (map (tmp_arr, (: lower_case ($1) :))
        & map (p->creators, (: lower_case ($1) :))) == sizeof (tmp_arr)) {
        match = 1;
      }
      else if (unassigned && !sizeof (p->creators)) {
        match = 1;
      }
      else {
        continue;
      }
    }
    if (sizeof (query["status"])) {
      if (query["status"] == "all") {
        match = 1;
      }
      else if (p->status == member_array (query["status"], STATUS)) {
        match = 1;
      }
      else {
        continue;
      }
    }
    if (sizeof (query["leader"])) {
      if (lower_case (p->leader) == lower_case (query["leader"])) {
        match = 1;
      }
      else {
        continue;
      }
    }
    if (query["touched"]) {
      if (p->last_touched > time() - query["touched"] ) {
        match = 1;
      }
      else {
        continue;
      }
    }
    if (query["completeness"]) {
      if (query_project_completeness (p->id)
        >= to_int (query["completeness"])) {
        match = 1;
      }
      else {
        continue;
      }
    }
    tmp_str = query["playtesters"];
    if (sizeof (tmp_str)) {
      tmp_arr = explode (replace (tmp_str, ({" ", ""})), ",");
      if (sizeof (tmp_arr & p->playtesters) == sizeof (tmp_arr)) {
        match = 1;
      }
      else {
        continue;
      }
    }
    if (match) {
      tmp += ({ p });
    }
  }
  return tmp;
}
class task* filter_tasks_by_query (string id, mapping query) {
  string tmp_str, *tmp_arr;
  int match, i, j;
  class task *tmp = ({ });
  i = find_project (id);
  if (i == -1) {
    return 0;
  }
  foreach (class task p in projects[i]->tasks) {
    match = 0;
    tmp_str = query["creators"];
    if (sizeof (tmp_str)) {
      tmp_arr = explode (replace (tmp_str, ({" ", ""})), ",");
      if (sizeof (tmp_arr & p->assigned_to) == sizeof (tmp_arr)) {
        match = 1;
      }
      else {
        continue;
      }
    }
    if (sizeof (query["completed"])) {
      j = to_int (query["completed"]);
      if (p->percent_complete > j) {
        match = 1;
      }
      else {
        continue;
      }
    }
    if (match) {
      tmp += ({ p });
    }
  }
  return tmp;
}
class project get_project_file (string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  return projects[i];
}
void set_project_file (string id, class project tmp, string name) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  projects[i] = tmp;
  touch_project (id, "Updated project file", name);
  catch_status_change (id, tmp->status);
}
class project* data_dump() {
  mapping dom_proj = ([ ]);
  string d;
  class project *tmp = ({ });
  string *dom;
  foreach (class project p in projects) {
    foreach (d in p->domains) {
      if (undefinedp (dom_proj [d])) {
        dom_proj [d] = ({ p });
      }
      else {
        dom_proj [d] += ({ p });
      }
    }
  }
  dom = sort_array (keys (dom_proj), 1);
  foreach (d in dom) {
    tmp += dom_proj[d];
  }
  return uniq_array (tmp);
}
class task get_task_file (string id, string t) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, t);
  if (j == -1) {
    return 0;
  }
  return projects[i]->tasks[j];
}
void set_task_file (string id, string t, class task tmp, string name) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_task (i, t);
  if (j == -1) {
    return 0;
  }
  projects[i]->tasks[j] = tmp;
  touch_project (id, "Updated task " + t, name);
}
class note get_note_file (string id, string t) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_note (i, t);
  if (j == -1) {
    return 0;
  }
  return projects[i]->notes[j];
}
void set_note_file (string id, string t, class note tmp, string name) {
  int i = find_project (id);
  int j;
  if (i == -1) {
    return 0;
  }
  j = find_note(i, t);
  if (j == -1) {
    return 0;
  }
  projects[i]->notes[j] = tmp;
  touch_project (id, "Updated note " + t, name);
}
int is_creator_on_project (string name, string id) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  if (member_array ("all", projects[i]->creators) != -1) {
    return 1;
  }
  if (member_array (name, projects[i]->creators) != -1) {
    return 1;
  }
  return 0;
}
varargs int valid_operation (string name, string action, string project,
  string* dom) {
  object ob;
  string *domains;
  int i = find_project (project);
  int j;
  if (master()->high_programmer (name)) {
    return 1;
  }
  if (name == "drakkos") {
    return 1;
  }
  if (i != -1) {
    domains = query_project_domains (project);
  }
  else if (dom) {
    domains = dom;
  }
  if (is_creator_on_project (name, project)) {
    return 1;
  }
  if (action == PLAYTESTING) {
    ob = find_object ("/d/playtesting/master");
    if (ob->query_lord() == name) {
      return 1;
    }
    if (ob->query_deputy (name)) {
      return 1;
    }
  }
  if (!sizeof (domains)) {
    return 0;
  }
  foreach (string d in domains) {
    ob = find_object ("/d/" + d + "/master");
    if (function_exists (CALLBACK, ob)) {
      j = call_other (ob, CALLBACK, name, action, project);
      if (j != -1) {
        return j;
      }
    }
    if (ob->query_lord() == name) {
      return 1;
    }
    if (ob->query_deputy (name) && action != PLAYTESTING) {
      return 1;
    }
  }
  if (action == PROJECT) {
    return 1;
    return sizeof (filter (domains, (:
      find_object ("/d/" + $1 + "/master")->query_member ($(name)) :)));
  }
  if (action == TASK || action == NOTE) {
    return is_creator_on_project (name, project);
  }
  return 0;
}
void catch_status_change (string id, int status) {
  object ob;
  int i = find_project (id);
  foreach (string d in projects[i]->domains) {
    ob = load_object ("/d/" + d + "/master");
    if (!ob) {
      continue;
    }
    if (function_exists ("project_status_change", ob)) {
      ob->project_status_change (id, status);
    }
  }
  if (status == member_array ("play", STATUS)) {
    WHATWHAT->add_project (projects[i]->name, projects[i]->domains,
      projects[i]->creators, projects[i]->description, "play");
  }
  if (status != member_array ("playtesting", STATUS)) {
    clear_playtesting_projects (projects[i]->playtesters);
    projects[i]->playtesters = ({ });
    save_file();
  }
  projects[i]->last_status_change = time();
}
int assign_playtesters (string id, string *pt, string name) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  pt = map(pt, (: lower_case ($1) :));
  pt = filter (pt, (: PLAYTESTER_HAND->query_playtester ($1) :));
  projects[i]->playtesters = pt;
  save_file();
  foreach (string p in pt) {
    if (pt_assignment_cache [p]) {
      map_delete (pt_assignment_cache, p);
    }
  }
  return 1;
}
string* add_playtester (string id, string *pt) {
  int i = find_project (id);
  string *names;
  if (i == -1) {
    return 0;
  }
  pt = map(pt, (: lower_case ($1) :));
  pt = filter (pt, (: PLAYTESTER_HAND->query_playtester ($1) :));
  names = projects[i]->playtesters;
  projects[i]->playtesters = uniq_array (names += pt);
  clear_playtesting_projects (pt);
  save_file();
  do_mail (pt, projects[i]->id);
  return pt;
}
int remove_playtester (string id, string *pt) {
  int i = find_project (id);
  if (i == -1) {
    return 0;
  }
  pt = map(pt, (: lower_case ($1) :));
  projects[i]->playtesters -= pt;
  clear_playtesting_projects (pt);
  save_file();
  return 1;
}
void do_load_tmp() {
  unguarded ((: restore_object, TMP_SAVE :));
}
void do_setup() {
  projects = ({ });
  foreach (class project p in tmp_projects) {
    projects += ({ p });
  }
  tmp_projects = ({ });
  do_save();
}
int clear_file_cache (string nfile) {
  int i = find_cache_file (nfile);
  if (i == -1) {
    return 0;
  }
  cache -= ({ cache[i] });
  return 1;
}
int query_permission (string project, string name, string nfile, int access) {
  int i = find_project (project);
  int j;
  string *tasks = ({ });
  class file *tmp = ({ });
  if (i == -1) {
    return 0;
  }
  if (projects[i]->leader != name &&
    member_array (name, projects[i]->creators) == -1) {
    return 0;
  }
  if (projects[i]->leader == name) {
    tasks = map (projects[i]->tasks, (: $1->id :));
    tasks += ({"leader"});
  }
  else {
    tasks = map (filter (projects[i]->tasks, (: member_array ($(name),
      $1->assigned_to) != -1 :)), (: $1->id :));
  }
  tasks += ({""});
  foreach (string t in tasks) {
    tmp += find_file (i, nfile, t);
  }
  if (!sizeof (tmp)) {
    return 0;
  }
  tmp = uniq_array (tmp);
  foreach (class file f in tmp) {
    j = find_cache_file (f->file);
    if (j == -1) {
      j = add_cache_file (f->file);
    }
    if (!sizeof (f->task)) {
      if (f->access == access) {
        if (cache[j]->accesses[name] < access) {
          cache[j]->accesses[name] = access;
        }
        return 1;
      }
    }
    else if (member_array (f->task, tasks) != -1) {
        if (f->access == access) {
          if (cache[j]->accesses[name] < access) {
            cache[j]->accesses[name] = access;
          }
          return 1;
        }
    }
  }
  return 0;
}
int nuke_creator_project_cache(string *creators) {
  if (!creator_project_cache) {
    return 0;
  }
  foreach (string c in creators) {
    map_delete (creator_project_cache, c);
    return 1;
  }
}
int query_file_permission (string name, string nfile, int access) {
  string *a_projects = query_projects_for_creator (name);
  int i, j, k, l = 0;
  if (!sizeof (a_projects)) {
    return 0;
  }
  j = find_cache_file (nfile);
  if (j != -1 ) {
    k = cache[j]->accesses[name];
    if (k == -1) {
      return 0;
    }
    if (k >= access) {
      return 1;
    }
  }
  foreach (string p in a_projects) {
    i = query_permission (p, name, nfile, access);
    if (!l && i) {
      l = 1;
    }
  }
  return l;
}
void set_project_lock (string project) {
  project_locks[project] = time();
}
int query_project_lock (string project) {
  if (project_locks[project] + PROJECT_LOCK > time()) {
    return 1;
  }
  map_delete (project_locks, project);
  return 0;
}
string generate_pt_report() {
  string *new_cache = ({ });
  string missing_projects = "";
  string ret = "";
  string *det = ({ });
  string project_list = "";
  string tmp;
  string post = "";
  int i;
  class project *in_pt = ({ });
  class project *out_pt = ({ });
  class project *new_pt = ({ });
  string *del = ({ });
  class project *playtesting = filter_by_query ((["status": "playtesting"]));
  foreach (class project p in playtesting) {
      new_cache += ({ p->id });
      if (member_array (p->id, pt_post_cache) == -1) {
        new_pt += ({ p });
      }
      else {
        in_pt += ({ p });
      }
    }
  if (sizeof (pt_post_cache)) {
    foreach (string id in pt_post_cache) {
      if (member_array (id, new_cache) == -1) {
        i = find_project (id);
        if (i == -1) {
          del += ({ id });
        }
        else {
          out_pt += ({ projects[i] });
        }
      }
    }
  }
  if (sizeof (new_pt)) {
    ret += "The following projects have entered playtesting:\n\n";
    foreach (class project p in new_pt) {
      det = ({ });
      det += ({sprintf ("*  %s (%s): %s.\n   Description: %s\n   "
        "Project leader: %s.\n   "
        "Creators: %s.\n   Notes: %s.\n", p->id, p->name,
          query_multiple_short (p->domains), (p->description ? replace
            (p->description, ({"\n", ""})) :
          "None"), (p->leader ? p->leader :
          "No-one"), (p->creators ? query_multiple_short (p->creators) :
          "None"), (sizeof (p->pt_notes) ? replace (p->pt_notes,
          ({"\n", ""})) : "None")) });
      ret += implode (det, "\n\n");
    }
    ret += "\n\n";
  }
  if (sizeof (in_pt)) {
    ret += "The following projects are still in playtesting:\n\n";
    det = ({ });
    foreach (class project p in in_pt) {
      det += ({sprintf ("*  %s (%s): %s.", p->id, p->name,
        query_multiple_short (p->domains)) });
    }
    ret += implode (det, "\n");
    ret += "\n\n";
  }
  if (sizeof (out_pt)) {
    det = ({ });
    ret += "The following projects have been removed from playtesting:\n\n";
    foreach (class project p in out_pt) {
      det += ({sprintf ("*  %s (%s): %s.", p->id, p->name,
        STATUS[p->status]) });
    }
    ret += implode (det, "\n\n");
    ret += "\n\n";
  }
  if (sizeof (del)) {
    ret += "The following projects have been deleted from the handler:\n\n";
    foreach (string d in del) {
      det += ({sprintf ("*  %s.", d) });
    }
    ret += implode (det, "\n\n");
    ret += "\n\n";
  }
  pt_post_cache = new_cache;
  if (!sizeof (ret)) {
    ret= "Wow, absolutely nothing is officially in playtesting at the "
      "moment.  You can all have the week off.\n\n";
  }
  else {
    ret += "Remember that you can use the 'playtesting' command for more "
      "information on projects that are currently in playtesting.\n\n";
  }
  return ret;
}
int make_post() {
  int ret;
  ret = BOARD_HAND->add_message("ptforum",
         "The Project Tracker", "What's in Playtesting?",
         generate_pt_report() +
         TWIKI_HANDLER->find_changes_in_database("Playtesters", last_summary));
  last_summary = time();
  save_file();
}
string* query_pt_cache() {
  return pt_post_cache;
}
string* query_pt_projects (string name) {
  class project *tmp;
  if (!undefinedp (pt_assignment_cache [name])) {
    return pt_assignment_cache [name];
  }
  tmp = filter_by_query ((["playtesters" : name ]));
  if (!tmp) {
    pt_assignment_cache[name] = ({ });
  }
  else {
    pt_assignment_cache[name] = map (tmp, (: $1->id :));
  }
  return pt_assignment_cache[name];
}
int query_number_of_pts (mixed proj) {
  int i;
  int t;
  if (!intp (proj)) {
    i = find_project (proj);
  }
  else {
    i = proj;
  }
  if (i == -1) {
    return -1;
  }
  switch (projects[i]->size) {
    case 0:
      t = 2;
    break;
    case 1:
      t = 3;
    break;
    case 2:
      t = 4;
    break;
    case 3:
      t = 5;
    break;
    case 4:
      t = 6;
    break;
    case 5:
      t = 8;
    break;
    case 6:
      t = 0;
    break;
    default:
      t = 2;
    break;
  }
  return t;
}
int next_rotation_time(mixed proj) {
  int i, t;
  if (!intp (proj)) {
    i = find_project (proj);
  }
  else {
    i = proj;
  }
  if (i == -1) {
    return -1;
  }
  if (projects[i]->complexity == member_array ("special", COMPLEXITY)) {
    return 0;
  }
  switch (projects[i]->size) {
    case 0:
      t = WEEK;
    break;
    case 1:
      t = WEEK * 2;
    break;
    case 2:
      t = WEEK * 2;
    break;
    case 3:
      t = WEEK * 4;
    break;
    case 4:
      t = WEEK * 4;
    break;
    case 5:
      t = WEEK * 6;
    break;
    case 6:
      t = WEEK * 6;
    default:
      t = WEEK;
  }
  if (!projects[i]->current_rotation) {
    projects[i]->last_rotation = time();
    projects[i]->current_rotation = 1;
    save_file();
  }
  return projects[i]->last_rotation + t;
}
int query_time_to_rotate (mixed proj) {
  int i;
  i = next_rotation_time(proj);
  if (i < time()) {
    return 1;
  }
  else {
    return 0;
  }
}
int query_number_rotations(mixed proj) {
  int i ;
  if (!intp (proj)) {
    i = find_project (proj);
  }
  else {
    i = proj;
  }
  if (i == -1) {
    return -1;
  }
  if (projects[i]->complexity == member_array ("special", COMPLEXITY)) {
    return projects[i]->current_rotation + 1;
  }
  return projects[i]->complexity + 2;
}
int query_rotation (mixed proj) {
  int i = (!intp (proj) ? find_project (proj) : proj);
  if (i == -1) {
    return 0;
  }
  return projects[i]->current_rotation;
}
string* query_playtesters (mixed proj) {
  int i = (!intp (proj) ? find_project (proj) : proj);
  if (i == -1) {
    return 0;
  }
  return projects[i]->playtesters;
}
int set_complexity (mixed proj, int com) {
  int i = (!intp (proj) ? find_project (proj) : proj);
  if (i == -1) {
    return 0;
  }
  projects[i]->complexity = com;
  return 1;
}
int set_size(mixed proj, int siz) {
  int i = (!intp (proj) ? find_project (proj) : proj);
  if (i == -1) {
    return 0;
  }
  projects[i]->size = siz;
  return 1;
}
int query_size(mixed proj) {
  int i = (!intp (proj) ? find_project (proj) : proj);
  if (i == -1) {
    return 0;
  }
  return projects[i]->size;
}
int set_guild_specific (mixed proj, string *guilds) {
  int i = (!intp (proj) ? find_project (proj) : proj);
  if (i == -1) {
    return 0;
  }
  projects[i]->guild_specific = guilds;
  return 1;
}
string *query_guild_specific(mixed proj) {
  int i = (!intp (proj) ? find_project (proj) : proj);
  if (i == -1) {
    return 0;
  }
  return projects[i]->guild_specific;
}
int clear_playtesting_projects (string *names) {
  foreach (string v in names) {
    if (pt_assignment_cache[v]) {
      map_delete (pt_assignment_cache, v);
    }
    if (!num_assignments[v]) {
      num_assignments[v] = 1;
    }
    else {
      num_assignments[v] += 1;
    }
  }
  save_file();
}
class project* get_playtesting_projects () {
  class project *tmp;
  tmp = filter_by_query ((["status": "playtesting"]));
  return tmp;
}
void set_rotations (string proj, int rot) {
  int i = find_project (proj);
  if (i == -1) {
    return;
  }
  projects[i]->current_rotation = rot;
}
string* assign_pts_to_project (mixed proj) {
  int i = (!intp (proj) ? find_project (proj) : proj);
  int needed, tmp;
  int min = sizeof (projects) + 1, max = -1;
  mapping guilds;
  mapping tmp_assign_cache = ([ ]);
  string tpt;
  string *valid = ({ });
  string *selected = ({ });
  string *virgins = ({ });
  string *ordered = ({ });
  string *last = ({ });
  string *nvalid = ({ });
  string *unassigned = ({ });
  string *assigned = ({ });
  if (i == -1) {
    return 0;
  }
  if (projects[i]->size != member_array ("special", SIZE)) {
    needed = query_number_of_pts (proj);
  }
  else {
    return ({ });
  }
  if (sizeof (projects[i]->guild_specific)) {
    guilds = PLAYTESTER_HAND->query_guilds();
    foreach (string g in projects[i]->guild_specific) {
      foreach (string name, string gu in guilds) {
        if (load_object (gu)->query_name() == g) {
          valid += ({ name });
        }
      }
    }
  }
  else {
    valid = PLAYTESTER_HAND->query_playtesters();
  }
  foreach (string v in valid) {
    if (!sizeof (query_pt_projects (v))) {
      unassigned += ({ v });
    }
    else {
      assigned += ({ v });
    }
  }
  if (sizeof (unassigned) >= needed) {
    valid = unassigned;
  }
  else {
    valid = unassigned;
    while (sizeof (valid) < needed) {
      tmp = random (sizeof (assigned));
      valid += ({ assigned[tmp] });
      assigned -= ({ assigned[tmp] });
    }
  }
  foreach (string va in valid) {
    if (member_array (lower_case (va), excluded) != -1) {
      nvalid += ({ va });
    }
    if (PLAYTESTER_HAND->query_leave (va)) {
      nvalid += ({ va });
    }
  }
  valid -= nvalid;
  virgins = valid - (projects[i]->last_pt_cohort ? projects[i]->last_pt_cohort : ({ }));
  if (sizeof (projects[i]->last_pt_cohort)) {
    clear_playtesting_projects (projects[i]->last_pt_cohort);
  }
  last = projects[i]->last_pt_cohort;
  projects[i]->last_pt_cohort = ({ });
  projects[i]->last_rotation = time();
  foreach (string v in valid) {
    tmp_assign_cache[v] = sizeof (query_pt_projects (v)) + num_assignments[v];
  }
  foreach (string pt, int val in tmp_assign_cache) {
    if (val < min) {
      min = val;
    }
    if (val > max) {
      max = val;
    }
  }
  for (int v = min; v <= max; v++) {
    ordered = ({ });
    foreach (string pt, int val in tmp_assign_cache) {
      if (val == v) {
        ordered += ({ pt });
      }
    }
    if ((sizeof (selected) + sizeof (ordered))  >= needed) {
      do {
        tpt = ordered[random(sizeof(ordered))];
        selected += ({ tpt });
        ordered-= ({ tpt });
      } while (sizeof (selected) < needed);
      projects[i]->playtesters = selected;
      save_file();
      if (!last) {
        last = ({ });
      }
      clear_playtesting_projects ((selected ? selected : ({ })) + (last? last : ({ })));
      do_mail (selected, projects[i]->id);
      return selected;
    }
    else {
      selected += ordered;
    }
  }
  valid = uniq_array (valid);
  projects[i]->last_pt_cohort = projects[i]->playtesters;
  if (sizeof (projects[i]->playtesters)) {
    if (sizeof (projects[i]->all_pts)) {
      projects[i]->all_pts += ({ projects[i]->playtesters });
    }
    else {
      projects[i]->all_pts = ({ projects[i]->playtesters });
    }
  }
  projects[i]->playtesters = selected;
  clear_playtesting_projects ((selected ? selected : ({ })) + (last? last : ({ })));
  do_mail (selected, projects[i]->id);
  save_file();
  return selected;
}
void rotate_project (mixed tmp) {
  int i;
  if (intp (tmp)) {
    i = tmp;
  }
  else {
    i = find_project (tmp);
  }
  if (projects[i]->current_rotation == query_number_rotations (i)) {
    AUTO_MAILER->auto_mail( "drakkos", "The Playtester Wheel Of Fate",
      "Your project in playtesting", projects[i]->leader,
      "Bing!\n\nThe project " + projects[i]->id + " has reached the end of "
      "its automatic playtesting lifetime and has been put back into a state "
      "of limbo.  If you wish for the project to continue in playtesting, then "
      "please set the project back into playtesting and give Drakkos a nudge!\n\n"
      "Thx bye,\nThe Playtester Wheel Of Fate.\n", 0, 0, 1 );
    AUTO_MAILER->auto_mail( "drakkos", "The Playtester Wheel Of Fate",
      "Your project in playtesting", implode (projects[i]->playtesters, ","),
      "Bing!\n\nThe project " + projects[i]->id + " has reached the end of "
      "its automatic playtesting lifetime and has been put back into a state "
      "of limbo.  Thank you for your work on the last stage of its current "
      "playtesting phase.\n\n"
      "Thx bye,\nThe Playtester Wheel Of Fate.\n", 0, 0, 1 );
    set_status(projects[i]->id, 4);
    projects[i]->current_rotation = 0;
    return;
  }
  projects[i]->current_rotation = projects[i]->current_rotation+1;
  projects[i]->last_rotation = time();
  assign_pts_to_project(i);
}
void reset() {
  if (!last_summary) {
    last_summary = time();
  }
  if ((last_summary + TIME_BETWEEN_POSTINGS) < time()) {
    make_post();
  }
  for (int i = 0; i < sizeof (projects); i++) {
    if (projects[i]->status != member_array ("playtesting", STATUS)) {
      continue;
    }
    if (query_time_to_rotate (i)) {
      rotate_project (i);
    }
  }
}
void do_mail (string *playtesters, mixed proj) {
  string text = "Hello!\n\nYou have been assigned to project " +
    proj + " on its latest rotation.  You can use "
    "'playtesting details " + proj + " to find out more about "
    "the project if neccessary.\n\nRegards,\nThe Playtester Wheel "
    "Of Fate.\n";
  AUTO_MAILER->auto_mail( "drakkos", "The Playtester Wheel Of Fate",
    "Your new playtester assignment", implode (playtesters, ","),
    text, 0, 0, 1 );
}
void clear() {
  string *names;
  for (int i = 0; i < sizeof (projects); i++) {
    projects[i]->all_pts = ({ });
    projects[i]->last_pt_cohort = ({ });
    projects[i]->playtesters = ({ });
  }
  names = PLAYTESTER_HAND->query_playtesters();
  clear_playtesting_projects (names);
  save_file();
}
void test_num() {
  printf ("%O\n", pt_assignment_cache);
}

==================================================
FILE: handlers/property_tracker.c
==================================================

#include <login.h>
#define CACHE_PROPERTY "property_tracker"
nosave inherit "/std/object";
void save_file();
private string *_invalid_properties;
private mapping _property_funcs;
void create() {
    ::create();
    seteuid( "Root" );
    set_name( "tracker" );
    set_short( "property tracker" );
    unguarded( (: restore_object, "/save/property_tracker.o" :) );
    if ( !_invalid_properties ) {
        _invalid_properties = ({ "team", "ctf_deaths", "ctf_shared",
            "ctf_solo",
            "completed feather quest", "ChapelGapp",
            "scythe sharpness", "DJ to ephebe",
            "emote", "quiting frog", "woeshipper",
            "arresting", "Junior's friend", "donetd",
            "Sek_gem", "looky thingy", "riddle_master",
            "help shopkeeper" });
        _property_funcs = ([ ]);
        save_file();
    }
}
public void check_properties(mixed person, string type) {
    string property;
    mixed data;
    int result;
    int diff;
    if (type != LOGIN)
        return;
    if ( !objectp(person) && !( person = find_player( person ) ) ) {
        return;
    }
#ifdef CACHE_TIME
    diff = CACHE_TIME;
#else
    diff = 1;
#endif
    if ( time() > person->query_property( CACHE_PROPERTY ) + diff ) {
#ifdef DEBUG
        tell_creator( "taffyd", "Scanning %s (%O) for properties.\n",
            person->query_name(), person );
#endif
        foreach( property, data in person->query_properties() ) {
            if ( member_array( property, _invalid_properties ) > -1 ) {
#ifdef DEBUG
                tell_creator( "taffyd", "Checking to property %s.\n",
                    property );
#endif
                if ( _property_funcs[ property ] ) {
                    result = call_other( _property_funcs[ property ][ 1 ],
                        _property_funcs[ property ][ 0 ], property, person,
                        data );
                    if ( result ) {
                        continue;
                    }
                }
#ifdef DEBUG
                tell_creator( "taffyd", "Removing property %s.\n",
                    property );
#endif
                person->remove_property( property );
            }
        }
#ifdef CACHE_TIME
        person->add_property( CACHE_PROPERTY, time() );
#else
        person->remove_property( CACHE_PROPERTY );
#endif
    }
    person->add_skill_level( "other.language.common.spoken", -person->query_skill( "other.language.common.spoken" ) );
    person->add_skill_level( "other.language.common.written", -person->query_skill( "other.language.common.written" ) );
}
public string query_invalid_properties() {
    return copy( _invalid_properties );
}
varargs public int add_invalid_property( string property, mixed func, mixed obj ) {
#ifdef LORD_ONLY
    if ( !master()->query_lord( previous_object( -1 ) ) ) {
        tell_creator( this_player(1), "Get a Lord to add your property for "
            "you.\n" );
        return 0;
    }
#endif
    if ( member_array( property, _invalid_properties ) == -1 ) {
        if ( objectp( func ) ) {
            func = file_name( func );
        }
        if ( objectp( obj ) ) {
            obj = file_name( obj );
        }
        if ( func && obj ) {
            _property_funcs[ property ] = ({ func, obj });
        }
        _invalid_properties += ({ property });
        save_file();
        return 1;
    }
    return 0;
}
int remove_invalid_property( string property ) {
#ifdef LORD_ONLY
    if ( !master()->query_lord( previous_object( -1 ) ) ) {
        tell_creator( this_player(1), "Get a Lord to add your property for "
            "you.\n" );
        return 0;
    }
#endif
    if ( _property_funcs[ property ] ) {
        map_delete( _property_funcs, property );
    }
    _invalid_properties -= ({ property });
    save_file();
    return 1;
}
void save_file() {
    unguarded( (: save_object, "/save/property_tracker" :) );
}
void reset_data() {
    unguarded( (: rm, "/save/property_tracker.o" :) );
}
void convert_no_score( string property, object who, mixed data ) {
    if ( property != "no_score" )
        return;
    if ( data ) {
        who->remove_property( property );
        who->add_property( "no score", 1 );
    }
}
int remove_warmth( string property, object who, mixed data ) {
    if ( property != "warmth" ) {
        return 1;
    }
    if ( !who->query_property_time_left( property ) ) {
        who->remove_property( property );
        return 1;
    }
    return 1;
}

==================================================
FILE: handlers/quest_handler.c
==================================================

#include <library.h>
#include <player_handler.h>
#define QUEST_LOG "QUESTS"
#define SAVE_FILE "/save/quests"
#define BACKUP_FILE "/save/quests/quests"
inherit "/std/object";
private int *quest_level;
private int *num_times_done;
private int *quest_status;
private string *quest_name;
private string *quest_title;
private string *quest_story;
private string *last_done_by;
private nosave int total_qp;
void load_quests() { unguarded( (: restore_object, SAVE_FILE :) ); }
void save_quests() { unguarded( (: save_object, SAVE_FILE :) ); }
void create() {
   int i;
   ::create();
   load_quests();
   if ( !quest_name ) {
      quest_name = ({ });
   }
   if ( !quest_level ) {
      quest_level = ({ });
   }
   if ( !quest_title ) {
      quest_title = ({ });
   }
   if ( !quest_story ) {
      quest_story = ({ });
   }
   if ( !last_done_by ) {
      last_done_by = ({ });
   }
   if ( !num_times_done ) {
      num_times_done = ({ });
   }
   if ( !quest_status ) {
     if(sizeof(quest_name)) {
       quest_status = allocate(sizeof(quest_name));
       for(i=0; i<sizeof(quest_name); i++) {
         quest_status[i] = 1;
       }
     } else {
       quest_status = ({ });
     }
   }
   for(i = 0; i<sizeof(quest_level); i++) {
     if(quest_status[i]) {
       total_qp += quest_level[i];
     }
   }
}
int query_total_qp() { return total_qp; }
int add_quest( string name, int level, string title, string story ) {
   string log_name;
   if ( member_array( name, quest_name ) != -1 )
      return 0;
   quest_name += ({ name });
   quest_level += ({ level });
   quest_title += ({ title });
   quest_story += ({ story });
   last_done_by += ({ "nobody" });
   num_times_done += ({ 0 });
   quest_status += ({ 1 });
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file( QUEST_LOG, log_name +
         " added: "+ name +", "+ level +", "+ title +", "+ story +"\n" );
   save_quests();
   unguarded( (: cp, SAVE_FILE +".o", BACKUP_FILE +"."+ time() :) );
   total_qp += level;
   return 1;
}
int change_quest_status(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  quest_status[temp] = !quest_status[temp];
  return quest_status[temp];
}
int query_quest_status(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  return quest_status[temp];
}
int query_quest_level(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return -1;
  }
  return quest_level[temp];
}
int set_quest_level(string name, int level) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : level set for %s to %d\n\n",
            log_name, name, level);
   quest_level[ temp ] = level;
   save_quests();
   return 1;
}
string query_quest_story(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1) {
    return "did nothing";
  }
  return quest_story[temp];
}
int set_quest_story(string name, string story) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : story set for %s to %s\n\n",
            log_name, name, story);
   quest_story[ temp ] = story;
   save_quests();
   return 1;
}
string query_quest_title(string name) {
  int temp;
  temp = member_array(name, quest_name);
  if(temp == -1 || quest_title[temp] == "") {
    return "Unknown Quester";
  }
  return quest_title[temp];
}
int set_quest_title(string name, string title) {
   int temp;
   string log_name;
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, "%s : title set for %s to %s\n\n",
            log_name, name, title);
   quest_title[ temp ] = title;
   save_quests();
   return 1;
}
int query_quest_times( string name ) {
   int i;
   i = member_array( name, quest_name );
   if ( i == -1 )
      return -1;
   return num_times_done[ i ];
}
mixed query_quest_done( string name ) {
   int i;
   i = member_array( name, quest_name );
   if ( i == -1 )
      return -1;
   return last_done_by[ i ];
}
int delete_quest(string name) {
   int temp;
   string log_name;
   if ( this_player() ) {
      log_name = this_player()->query_name();
   }
   else {
      log_name = file_name( previous_object() );
   }
   log_file(QUEST_LOG, log_name + " removed : " +
            name + "\n\n");
   temp = member_array(name, quest_name);
   if(temp == -1) {
      return 0;
   }
   total_qp -= quest_level[temp];
   quest_name = delete(quest_name, temp, 1);
   quest_level = delete(quest_level, temp, 1);
   quest_title = delete(quest_title, temp, 1);
   quest_story = delete(quest_story, temp, 1);
   last_done_by = delete( last_done_by, temp, 1 );
   num_times_done = delete( num_times_done, temp, 1 );
   save_quests();
   return 1;
}
string *query_quest_names() {
  return quest_name + ({ });
}
int *query_quest_levels() {
  return quest_level + ({ });
}
string *query_quest_titles() {
  return quest_title + ({ });
}
string *query_quest_stories() {
  return quest_story + ({ });
}
void quest_completed( string name, string quest, object prev_ob ) {
   int i;
   string word;
   log_file( QUEST_LOG, ctime( time() ) +" "+ name +" completed "+
         quest +"\n" );
   user_event( "inform", name +" completes "+ quest, "quest" );
   if ( file_name( previous_object() ) != LIBRARY ) {
      prev_ob = previous_object();
   }
   word = (string)prev_ob->query_name();
   if ( !word ) {
      word = file_name( prev_ob );
   } else {
      word += " ("+ file_name( prev_ob ) +")";
   }
   log_file( QUEST_LOG, "given by "+ word +"\n" );
   i = member_array( quest, quest_name );
   if ( i == -1 ) {
      log_file( QUEST_LOG, "non existent quest\n" );
      return;
   }
   last_done_by[ i ] = name;
   num_times_done[ i ]++;
   save_quests();
}
int query_player_fame(string name){
   int playerqp, rank;
   if (!name){
      return 0;
   }
   if (this_player()){
      name = (string)this_player()->expand_nickname(name);
   }
   if (!PLAYER_HANDLER->test_user(name)){
      return 0;
   }
   playerqp = (int)LIBRARY->query_quest_points(name);
   rank = ( playerqp * 125 ) / query_total_qp();
   return rank;
}
string query_fame_str( string name ) {
   switch ( query_player_fame( name ) ) {
      case 0 .. 4 :
         return "completely unknown";
      case 5 .. 14 :
         return "unknown";
      case 15 .. 24 :
         return "unknown";
      case 25 .. 34 :
         return "moderately well known";
      case 35 .. 44 :
         return "well known";
      case 45 .. 54 :
         return "very well known";
      case 55 .. 64 :
         return "known throughout the region";
      case 65 .. 74 :
         return "famous";
      case 75 .. 84 :
         return "renowned";
      case 85 .. 94 :
         return "Disc renowned";
      default :
         return "so renowned that no introduction is needed";
   }
}
string *query_player_story(string name){
   string *quests;
   string *story;
   int i;
   story = ({ });
   if (!name){
      return ({ });
   }
   if (this_player()){
      name = (string)this_player()->expand_nickname(name);
   }
   if (!PLAYER_HANDLER->test_user(name)){
      return 0;
   }
   quests = query_quest_names();
   if (sizeof(quests) == 1){
      story = ({"Is an under achiever."});
   }
   else{
      for(i=0;i<sizeof(quests);i++){
         if (LIBRARY->query_quest_done(name, quests[i])){
            story = ({ query_quest_story( quests[ i ] ) }) + story;
         }
      }
   }
   return story;
}
void print_some_stats()  {
   int i;
   for (i = 0; i < sizeof(quest_name); i++)
      printf("%s: %6d, %3d\n", quest_name[i], num_times_done[i], quest_level[i]);
}

==================================================
FILE: handlers/random_names.c
==================================================

#include <random_names.h>
#include <player_handler.h>
private mapping rules;
private string* _test_rules;
void create() {
   seteuid("Room");
   rules = ([ ]);
   _test_rules = ({ });
   unguarded((: restore_object, RANDOM_NAME_SAVE_FILE :));
   if (!_test_rules) {
      _test_rules = ({ });
   }
}
private void save_me() {
   unguarded((: save_object, RANDOM_NAME_SAVE_FILE :));
}
void open_file(string f) {
   string str, *bits, *stuff, lang;
   int i;
   bits = explode(f, ".");
   if (sizeof(bits) > 1) {
      lang = implode(bits[0..sizeof(bits)-2], ".");
   } else {
      lang = f;
   }
   lang = replace(lang, "_", " ");
   str = unguarded((: read_file, RANDOM_NAME_DATA_DIR+f :));
   bits = explode(str, "\n");
   rules[lang] = ([ ]);
   for (i=0;i<sizeof(bits);i++) {
      sscanf(bits[i], "%s#%*s", bits[i]);
      if (strlen(bits[i])) {
         stuff = explode("G"+bits[i], ":");
         if (sizeof(stuff) >= 3) {
            rules[lang][stuff[1]] = stuff[2];
         } else {
            write("Incorrect file format at line "+i+", less than 3 "
                  ": seporated bits.\n");
         }
      }
   }
   save_me();
}
string random_name(string lang) {
   string word = "W", *bing;
   int some_caps = 1, i;
   do {
      some_caps = 0;
      for (i = 0; i < strlen(word); i++)
         if (word[i] >= 'A' && word[i] <= 'Z') {
            bing = explode(rules[lang][word[i..i]], " ") - ({ "" });
            word = word[0..i-1] + bing[random(sizeof(bing))] + word[i+1..];
            some_caps = 1;
         }
   } while (some_caps);
   return word;
}
string *query_languages() { return keys(rules) - _test_rules; }
string *query_test_languages() {
   return _test_rules;
}
void add_test_language(string lang) {
   _test_rules += ({ lang });
   save_me();
}
void remove_test_language(string lang) {
   _test_rules -= ({ lang });
   save_me();
}
string unique_name(string lang) {
   string str;
   int ok;
   do {
      ok = 1;
      str = random_name(lang);
      if (strlen(str) < 2 || strlen(str) > 11)
         ok = 0;
      if (ok && PLAYER_HANDLER->test_user(str))
         ok = 0;
      if (ok && !PLAYER_HANDLER->test_valid(str))
         ok = 0;
      if (ok && find_living(str))
         ok = 0;
   } while (!ok);
   return str;
}
void dest_me() {
   destruct(this_object());
}

==================================================
FILE: handlers/random_num.c
==================================================

int seed = 100;
varargs int random(int max, mixed lseed);
#define Q           51924
#define R           10855
#define MULT        41358
#define MOD   21474836647
#define MAX_VALUE (MOD-1)
#define STARTUP_RANDS  16
void set_seed(int new_seed) {
  int i;
  if (seed <= 0)
    seed = efun::random(200);
  else
    seed = new_seed;
  for (i=0;i<STARTUP_RANDS;i++)
    random(200);
}
varargs int random(int max, mixed lseed) {
  int k, residue, curseed, mode;
  if (undefinedp(lseed)) {
    curseed = seed;
  } else if (intp(lseed)) {
    curseed = lseed;
    mode = 1;
  } else if (arrayp(lseed) && (sizeof(lseed) == 1) && (intp(lseed[0]))) {
    curseed = lseed[0];
    mode = 2;
  } else {
    curseed = seed;
  }
  k = curseed / Q;
  residue = MULT * (curseed - Q*R) - R*k;
  if (residue < 0)
    residue += MOD;
  if (mode == 0) {
    seed = residue;
  } else if (mode == 2) {
    lseed[0] = residue;
  }
  return residue % max;
}
int query_seed() {
  return seed;
}

==================================================
FILE: handlers/reaction.c
==================================================

#include <move_failures.h>
#include <reaction.h>
#define REACTIONS "/obj/reactions/"
#define SUBSTANCES 10
mapping substance = allocate_mapping(SUBSTANCES);
int debug_rh = 0;
void restore_from_files();
void write_dbg(string str) { if (debug_rh) write(str); }
void create() {
    seteuid("/secure/master"->creator_file(file_name(this_object())));
    restore_from_files();
}
mapping merge_effects(mapping effects_a, mapping effects_m, int q_a, int q_m) {
    int q_t, strength;
    string key;
    mapping ret = ([ ]);
    if(!mapp(effects_a) || !mapp(effects_m))
      return 0;
    q_t = q_a + q_m;
    if ( !q_t ) {
        return 0;
    }
    foreach (key in keys(effects_a)) {
        if (!intp(effects_a[key]) || !intp(effects_m[key])) {
            continue;
        }
        if (undefinedp(effects_m[key])) {
            strength = (effects_a[key]*q_a)/q_t;
        } else {
            strength = (effects_a[key]*q_a + effects_m[key]*q_m)/q_t
                - effects_m[key];
            map_delete(effects_m, key);
        }
        ret += ([key: strength]);
    }
    foreach (key in keys(effects_m)) {
        if (!intp(effects_m[key])) {
            continue;
        }
        strength = (effects_a[key]*q_a + effects_m[key]*q_m)/q_t
            - effects_m[key];
        ret += ([key: strength]);
    }
    return ret;
}
object merge_cont_medium(object a, string medium_alias) {
    object medium;
    int no_join, q_a, q_m;
    mapping effects_a, effects_m, eff;
    string key;
    a->remove_alias(medium_alias);
    no_join = a->query_no_join();
    if ((medium = present(medium_alias, environment(a))) && !no_join) {
        a->set_no_join();
        a->move("/room/void");
        q_a = a->query_amount();
        q_m = medium->query_amount();
        medium->adjust_amount(q_a);
        effects_a = copy(a->query_eat_effects());
        effects_m = copy(medium->query_eat_effects());
        eff = merge_effects(effects_a, effects_m, q_a, q_m);
        if (mapp(eff)) {
           foreach (key in keys(eff)) {
               medium->add_eat_effect(key, eff[key]);
           }
        }
        effects_a = copy(a->query_external_effects());
        effects_m = copy(medium->query_external_effects());
        eff = merge_effects(effects_a, effects_m, q_a, q_m);
        if(eff) {
          foreach (key in keys(eff)) {
            medium->add_external_effect(key, eff[key]);
          }
        }
        call_out("dest_substance", 0, a);
        return medium;
    } else {
        a->add_alias(medium_alias);
        return a;
    }
}
void check_reaction(object a) {
    int amt_a, need_amt_a, amt_b, need_amt_b;
    string name_a, name_b, i_a, i_b, msg, fcn;
    mixed *fcns;
    int i, j, amt_result;
    object x, *bs, ob_a, ob_b;
    float ratio;
    class reaction rcn;
    if (objectp(this_player()))
      debug_rh = this_player()->query_property("debug_rh");
    else
      debug_rh = 0;
    write_dbg("Entering reaction_handler.\n");
    name_a = a->query_medium_alias();
    if (!name_a || !a->query_continuous()) {
        write_dbg("Leaving reaction_handler because there is no A or it is not "
        "continous.\n");
        return;
    }
    if ( a->query_medium_alias() == a->query_name() ) {
        debug_printf( "WARNING: Your cont_medium alias must "
          "not be the same as your name.\n" );
        return;
    }
    a = merge_cont_medium(a, name_a);
    bs = all_inventory(environment(a));
    debug_printf( "A is %O at %O. Bs are: %O.\n", a, environment( a ), bs );
    if ((sizeof(bs) < 2) || (!a->query_amount())) {
        write_dbg("Leaving reaction_handler because there is no B, or there is "
        "0 amounts of A.\n");
        return;
    }
    write_dbg("Checking the following: ");
    for (i = 0; i < sizeof(bs); i++) {
        write_dbg(bs[i]->query_medium_alias() + ", ");
    }
    write_dbg("\n");
    for (i = 0; i < sizeof(bs); i++) {
        if (!a->query_amount()) {
            write_dbg("Leaving reaction_handler.\n");
            return;
        }
        name_b = bs[i]->query_medium_alias();
        if (!name_b || !bs[i]->query_continuous() || !bs[i]->query_amount()) {
            continue;
        }
        if (name_a < name_b) {
            i_a = name_a;
            i_b = name_b;
            ob_a = a;
            ob_b = bs[i];
        } else {
            i_a = name_b;
            i_b = name_a;
            ob_a = bs[i];
            ob_b = a;
        }
        write_dbg("Checking " + i_a + " against " + i_b + ".\n");
        if (!substance[i_a] || !substance[i_a][i_b]) {
            continue;
        }
        write_dbg("...they react.\n");
        rcn = substance[i_a][i_b];
        amt_a = ob_a->query_amount();
        amt_b = ob_b->query_amount();
        ratio = to_float(amt_a) / amt_b;
        if (intp(rcn->ratio)) {
            rcn->ratio = to_float(rcn->ratio);
        }
        if (floatp(rcn->ratio)) {
            write_dbg("Single ratio...\n");
            if (ratio > rcn->ratio) {
                need_amt_b = amt_b;
                need_amt_a = to_int(ceil(amt_b*rcn->ratio));
                write_dbg("Setting amt_a to "+ to_int(ceil(amt_b*rcn->ratio)) +".\n" );
            } else {
                need_amt_a = amt_a;
                need_amt_b = to_int(ceil(amt_a/rcn->ratio));
                write_dbg("Setting amt_b to "+ to_int(ceil(amt_a/rcn->ratio)) +".\n" );
            }
        } else if (arrayp(rcn->ratio) && (sizeof(rcn->ratio) == 2)) {
            write_dbg("Range of ratios...");
            if (intp(rcn->ratio[0])) {
                rcn->ratio[0] = to_float(rcn->ratio[0]);
            }
            if (intp(rcn->ratio[1])) {
                rcn->ratio[1] = to_float(rcn->ratio[1]);
            }
            if (ratio > rcn->ratio[1]) {
                write_dbg("above range...(" + ratio + ")\n");
                need_amt_b = amt_b;
                need_amt_a = to_int(ceil(amt_b*rcn->ratio[1]));
                write_dbg("Setting amt_a to "+ to_int(ceil(amt_b*rcn->ratio[1])) +".\n" );
                write_dbg("This is because amta is: "+ amt_b +" and ratio is "+ rcn->ratio[1] + ".\n" );
            } else if (ratio < rcn->ratio[0]) {
                write_dbg("below range...(" + ratio + ")\n");
                need_amt_a = amt_a;
                need_amt_b = to_int(ceil(amt_a/rcn->ratio[0]));
                write_dbg("Setting amt_b to "+ to_int(ceil(amt_a/rcn->ratio[0])) +".\n" );
                write_dbg("This is because amta is: "+ amt_a +" and ratio is "+ rcn->ratio[0] + ".\n" );
            } else {
                write_dbg("within range...(" + ratio + ")\n");
                need_amt_a = amt_a;
                need_amt_b = amt_b;
            }
        } else {
            error("Illegal reaction ratio; expecting float, int, or "
                  "array of two floats or ints.");
        }
        amt_result = to_int((need_amt_a + need_amt_b)*rcn->result_amt);
        write_dbg("...got ("+amt_a+","+amt_b+"), taking ("+need_amt_a+","+
                  need_amt_b+"), creating " + amt_result + ".\n");
        write_dbg("...creating "+rcn->result+".\n");
        x = clone_object(rcn->result);
        if (rcn->result_amt) {
            if (function_exists("set_amount", x)) {
                x->set_amount(amt_result);
            } else {
                x->set_weight(amt_result);
            }
        }
        msg = rcn->message;
        if (msg) {
            msg = replace(rcn->message, ({
                "#env#", file_name(environment(a)),
                "#env2#", file_name(environment(environment(a))),
                "#obj_a#", file_name(ob_a),
                "#obj_b#", file_name(ob_b),
                "#obj_x#", file_name(x)
              }));
            tell_room(environment(environment(a)), msg);
        }
        fcns = rcn->func;
        if (fcns) {
            for (j = 0; j < sizeof(fcns); j++) {
                if (stringp(fcns[j])) {
                    fcn = replace(fcns[j], ({
                        "#env#", file_name(environment(a)),
                        "#env2#", file_name(environment(environment(a))),
                        "#obj_a#", file_name(ob_a),
                        "#obj_b#", file_name(ob_b),
                        "#obj_x#", file_name(x)
                      }));
                } else if (functionp(fcns[j])) {
                    evaluate(fcns[j], ob_a, ob_b, x, environment(a),
                             environment(environment(a)), need_amt_a,
                             need_amt_b);
                }
            }
        }
        call_out("move_substance", 0, ({x, environment(a)}));
        ob_a->adjust_amount( -need_amt_a );
        ob_b->adjust_amount( -need_amt_b );
    }
    write_dbg("Leaving reaction_handler.\n");
}
void move_substance(object *ob) {
    int vol, vol_left, cont, closed, i, mv_stat;
    object *contents;
    if (!ob[0] || !ob[1]) return;
    vol_left = (int)ob[1]->query_max_volume() - (int)ob[1]->query_volume();
    if (cont = ob[0]->query_continuous()) {
        vol = ob[0]->query_amount();
    } else {
        vol = (int)ob[0]->query_weight()*200;
    }
    closed = ob[1]->query_closed();
    ob[1]->set_open();
    if ((mv_stat = ob[0]->move(ob[1])) != MOVE_OK) {
        write_dbg(sprintf("Move error (%d)...", vol));
        if ((vol > vol_left) && cont && !closed) {
            write_dbg("too much...\n");
            ob[0]->set_amount(vol_left);
            tell_room(environment(ob[1]), ob[0]->short(0) +
                      " leaks out of the " + ob[1]->short(0) + ".\n");
            mv_stat = ob[0]->move(ob[1]);
        }
        if (mv_stat == MOVE_OK) {
            if (closed) ob[1]->set_closed();
        } else {
            contents = all_inventory(ob[1]);
            write_dbg(sprintf("contents = %O\n", contents));
            for (i = 0; i < sizeof(contents); i++) {
                contents[i]->dest_me();
            }
            if (!living(ob[1]) && !function_exists("query_co_ord", ob[1])) {
                tell_room(environment(ob[1]), ob[1]->the_short(0) +
                          " explodes, splattering the contents all over.\n");
                ob[1]->move("/room/rubbish");
            }
            ob[0]->move("/room/rubbish");
        }
    } else {
        if (closed) ob[1]->set_closed();
    }
}
void dest_substance(object ob) {
    if (ob) {
        ob->dest_me();
    }
}
mixed *query_reaction(string name_a, string name_b) {
    if (!substance[name_a] || !substance[name_a][name_b]) {
        return 0;
    }
    return substance[name_a][name_b];
}
mapping query_reactions() { return substance; }
void restore_from_files() {
    string *files;
    int i;
    files = ({ "base.hdr" });
    files += get_dir(REACTIONS + "*.rcn");
    for (i = 0; i < sizeof(files); i++) {
        files[i] = REACTIONS + files[i];
    }
    substance = "/obj/handlers/data"->compile_data(files);
}
void update_from_files(string fn) {
    mapping new_substance;
    string a, b;
    new_substance = "/obj/handlers/data"->compile_data( ({ fn }) );
    foreach (a in keys(new_substance)) {
      if (undefinedp(substance[a])) {
        substance[a] = ([ ]);
      }
      foreach (b in keys(new_substance[a])) {
        substance[a][b] = new_substance[a][b];
      }
    }
}

==================================================
FILE: handlers/refresh.c
==================================================

#include <refresh.h>
#include <playerinfo.h>
#define SAVE_FILE "/save/refresh"
mapping refresh_callbacks;
mapping delete_callbacks;
nosave string loaded_by;
nosave string loaded_time;
protected void load_me()
{
  refresh_callbacks = 0;
  delete_callbacks = 0;
  unguarded( (: restore_object, SAVE_FILE, 0 :) );
  if (!refresh_callbacks) {
    refresh_callbacks = ([ ]);
  }
  if (!delete_callbacks) {
    delete_callbacks = ([ ]);
  }
}
protected void save_me()
{
  unguarded( (: save_object, SAVE_FILE, 0 :) );
}
string query_name() {
   return "Refresh Handler";
}
void create()
{
  seteuid("/secure/master"->creator_file(file_name(this_object())));
  load_me();
  if (!previous_object()) {
    loaded_by = "The Masked Man";
  } else {
    if (previous_object()->query_creator()) {
      loaded_by = "Creator: " + previous_object()->query_name();
    } else if (previous_object()->query_interactive()) {
      loaded_by = "Player: " + previous_object()->query_name();
    } else {
      loaded_by = file_name(previous_object());
      if (this_player())
        loaded_by += sprintf(" (%s)", this_player()->query_name());
    }
  }
  loaded_time = ctime(time());
}
void dest_me()
{
  save_me();
  destruct(this_object());
}
nomask mixed dwep()
{
  efun::destruct(this_object());
  return "Destructed With Extreme Prejudice";
}
string register_refresh(mixed ob, string func)
{
  object real;
  if (objectp(ob)) {
    ob = base_name(ob);
  }
  if (!ob) {
    return "Please supply an object";
  }
  real = load_object(ob);
  if (!real) {
    return "Couldn't find object";
  }
  if (func && !function_exists(func, real)) {
    return "Couldn't find function";
  }
  if (!func) {
    if (refresh_callbacks[ob]) {
      map_delete(refresh_callbacks, ob);
    }
  } else {
    if (refresh_callbacks[ob]) {
      refresh_callbacks[ob] = func;
    } else {
      refresh_callbacks += ([ ob : func ]);
    }
  }
  save_me();
}
string register_delete(mixed ob, string func)
{
  object real;
  if (objectp(ob)) {
    ob = base_name(ob);
  }
  if (!ob) {
    return "Please supply an object";
  }
  real = load_object(ob);
  if (!real) {
    return "Couldn't find object";
  }
  if (func && !function_exists(func, real)) {
    return "Couldn't find function";
  }
  if (!func) {
    if (delete_callbacks[ob]) {
      map_delete(delete_callbacks, ob);
    }
  } else {
    if (delete_callbacks[ob]) {
      delete_callbacks[ob] = func;
    } else {
      delete_callbacks += ([ ob : func ]);
    }
  }
  save_me();
}
varargs void player_refreshed(object player, int totally) {
  string ob;
  if (base_name(file_name(previous_object())) != "/global/player") {
    return;
  }
  foreach (ob in keys(refresh_callbacks)) {
    object obj;
    obj = load_object(ob);
    if (obj) {
      mixed *vals;
      vals = ({ refresh_callbacks[ob], player, totally });
      call_out( (: call_other, obj, vals :), 1);
    }
  }
}
varargs void player_deleted(string player)
{
  string ob;
  if (file_name(previous_object()) != "/secure/delete_clear" &&
      file_name(previous_object()) != "/cmds/lord/rmp_layer" &&
      !master()->high_programmer(previous_object(-1))) {
    unguarded( (: write_file, "/log/CHEAT", ctime( time() ) +
                ": illegal attempt to delete player files using "+
                "refresh_handler\nTrace: "+ back_trace() :) );
    return;
  }
  foreach (ob in keys(delete_callbacks)) {
    object obj;
    obj = load_object(ob);
    if (obj) {
      mixed *vals;
      vals = ({ delete_callbacks[ob], player, PLAYER_DELETED });
      call_out( (: call_other, obj, vals :), 1);
    }
  }
  "/secure/related_files"->delete_related_files(player, 1, 0);
}
mapping query_funcs()
{
  return ([
    "refresh callbacks" : refresh_callbacks,
    "delete callbacks" : delete_callbacks,
    ]);
}
mixed *stats()
{
  return ({
    ({ "refreshes", sizeof(refresh_callbacks) }),
    ({ "deletes", sizeof(delete_callbacks) }),
    ({ "loaded by", loaded_by }),
    ({ "loaded time", loaded_time }),
    });
}

==================================================
FILE: handlers/report_handler.c
==================================================

#include <report_handler.h>
inherit "/std/object";
void move_to_recent_cases(mixed *thing);
mixed *new_cases, *recent_cases;
void setup() {
  set_short("report handler");
  add_property("determinate", "the ");
  set_long("This is a rather tacky statue of a woman holding "
    "a sword and some wonky scales.\n");
  if(file_size(NEWCASES) > -1) {
    new_cases = restore_variable(read_file(NEWCASES));
  }
  if(file_size(RECENT) > -1) {
    recent_cases = restore_variable(read_file(RECENT));
  }
}
void save_new_cases() {
  unguarded((: rm, NEWCASES :));
  unguarded((: write_file, NEWCASES, save_variable(new_cases)+"\n" :));
}
mixed query_new() {
  return new_cases;
}
int sizeof_new_cases() {
  if(!new_cases) {
    new_cases = restore_variable(read_file(NEWCASES));
  }
  return sizeof(new_cases);
}
string query_new_cases() {
  int i, j;
  string reports = "";
  for(i = 0; i < sizeof(new_cases); i++) {
    if(i < 10) {
      reports += "   "+(i + 1)+": ";
    } else {
      reports += "  "+(i + 1)+": ";
    }
    reports += "%^CYAN%^Player%^RESET%^: "+capitalize(new_cases[i][NAME]);
    for(j = 0; j < (12 - sizeof(new_cases[i][NAME])); j++) {
      reports += " ";
    }
    reports += "%^CYAN%^Category%^RESET%^: "+new_cases[i][CATEGORY]+"\n";
  }
  return reports;
}
string query_new_case(int i) {
  string report = "";
  mixed *stuff;
  if(!new_cases) {
    new_cases = restore_variable(read_file(NEWCASES));
  }
  if(i < 1 || i > sizeof(new_cases)) {
    return 0;
  }
  stuff = new_cases[i - 1];
  report += "  %^CYAN%^Suspect%^RESET%^: "+capitalize(stuff[NAME])+"\n";
  if(!sizeof(stuff[CHARS])) {
    report += "  %^CYAN%^Other Characters%^RESET%^: Unknown.\n";
  } else {
    report += "  %^CYAN%^Other Characters%^RESET%^: "
      "$I$5="+query_multiple_short(stuff[CHARS])+"$I$0=\n";
  }
  report += "  %^CYAN%^Creator%^RESET%^: "+stuff[CREATOR]+"\n"
    "  %^CYAN%^Time%^RESET%^: "+stuff[TIME]+"\n"
    "  %^CYAN%^Category%^RESET%^: "+stuff[CATEGORY]+"\n"
    "  %^CYAN%^Report%^RESET%^: $I$5="+stuff[REPORT]+"$I$0=";
  return report;
}
void add_report(string *stuff) {
  if(!new_cases) {
    new_cases = restore_variable(read_file(NEWCASES));
  }
  new_cases += ({ stuff });
  save_new_cases();
}
void deal_with_it(int num, string name, string decision) {
  mixed *thing;
  num--;
  thing = new_cases[num];
  thing += ({ name });
  thing += ({ decision });
  new_cases -= ({new_cases[num]});
  move_to_recent_cases(thing);
}
void save_recent_cases() {
  unguarded((: rm, RECENT :));
  unguarded((: write_file, RECENT, save_variable(recent_cases)+"\n" :));
}
void move_to_recent_cases(mixed *thing) {
  int i, j;
  mixed *c_record, *chars;
  for(i = sizeof(recent_cases) - NO_RECENT; i > -1; i--) {
    chars = ({recent_cases[i][NAME]});
    if(arrayp(recent_cases[i][CHARS])) {
      chars += recent_cases[i][CHARS];
    }
    uniq_array(chars);
    for(j = 0; j < sizeof(chars); j++) {
      if(file_size((SAVEPATH+chars[j]+".o")) > -1) {
        c_record = restore_variable(read_file((SAVEPATH+chars[j]+".o")));
        c_record += ({recent_cases[j]});
      } else {
        c_record = ({recent_cases[j]});
      }
      unguarded((: rm, (SAVEPATH+chars[j]+".o") :));
      unguarded((: write_file, (SAVEPATH+chars[j]+".o"),
        save_variable(c_record)+"\n" :));
    }
    recent_cases -= ({recent_cases[i]});
  }
  recent_cases += ({ thing });
  save_new_cases();
  save_recent_cases();
}
mixed query_recent() {
  if(!recent_cases) {
    recent_cases = restore_variable(read_file(RECENT));
  }
  return recent_cases;
}
string query_recent_cases() {
  int i, j;
  string reports = "";
  for(i = 0; i < sizeof(recent_cases); i++) {
    if(i < 10) {
      reports += "   "+(i + 1)+": ";
    } else {
      reports += "  "+(i + 1)+": ";
    }
    reports += "%^CYAN%^Suspect%^RESET%^: "+capitalize(recent_cases[i][NAME]);
    for(j = 0; j < (12 - sizeof(recent_cases[i][NAME])); j++) {
      reports += " ";
    }
    reports += "%^CYAN%^Category%^RESET%^: "+recent_cases[i][CATEGORY]+"\n";
  }
  return reports;
}
string query_recent_case(int i) {
  string report = "";
  mixed *stuff;
  if(!recent_cases) {
    recent_cases = restore_variable(read_file(RECENT));
  }
  if(i < 1 || i > sizeof(recent_cases)) {
    return 0;
  }
  stuff = recent_cases[i - 1];
  report += "  %^CYAN%^Suspect%^RESET%^: "+capitalize(stuff[NAME])+"\n";
  if(!sizeof(stuff[CHARS])) {
    report += "  %^CYAN%^Other Characters%^RESET%^: Unknown.\n";
  } else {
    report += "  %^CYAN%^Other Characters%^RESET%^: "
      "$I$5="+query_multiple_short(stuff[CHARS])+"$I$0=\n";
  }
  report += "  %^CYAN%^Creator%^RESET%^: "+capitalize(stuff[CREATOR])+"\n"
    "  %^CYAN%^Time%^RESET%^: "+stuff[TIME]+"\n"
    "  %^CYAN%^Offence%^RESET%^: "+stuff[CATEGORY]+"\n"
    "  %^CYAN%^Report%^RESET%^: $I$5="+stuff[REPORT]+"$I$0="
    "  %^YELLOW%^High Lord%^RESET%^: "+stuff[HIGHLORD]+"\n"
    "  %^YELLOW%^High Lord Decision%^RESET%^: "+stuff[DECISION];
  for(i = 8; i < sizeof(stuff); i += 2) {
    report += "  %^YELLOW%^Comment from "+stuff[i]+"%^RESET%^: "
      +stuff[i + 1];
  }
  return report;
}
string case_history(string name) {
  int i, j;
  mixed *history, *cases, *stuff, *all_cases, *check_case;
  string report, *other_chars = ({ });
  history = get_dir(SAVEPATH+lower_case(name)+".o");
  all_cases = get_dir(SAVEPATH);
  all_cases -= ({"recent.o", "new.o"});
  for(i = 0; i < sizeof(all_cases); i++) {
    check_case = restore_variable(read_file((SAVEPATH+all_cases[i])));
    for(j = 0; j < sizeof(check_case); j++) {
      if(arrayp(check_case[j][CHARS])) {
        if(member_array(capitalize(name), check_case[j][CHARS]) != -1) {
          other_chars += check_case[j][CHARS];
          other_chars += ({check_case[j][NAME]});
        }
      }
    }
  }
  if(sizeof(other_chars)) {
    uniq_array(other_chars);
    for(i = 0; i < sizeof(other_chars); i++) {
      other_chars[i] = capitalize(other_chars[i]);
    }
    other_chars -= ({capitalize(name)});
    other_chars = uniq_array(other_chars);
    write(capitalize(name)+" is also "
      +query_multiple_short(other_chars)+".\n");
  }
  if(!sizeof(history)) {
    return 0;
  }
  write("%^CYAN%^Case History for "+capitalize(name)+"%^RESET%^:\n");
  report = "";
  cases = restore_variable(read_file(SAVEPATH+lower_case(name)+".o"));
  for(i = 0; i < sizeof(cases); i++) {
    stuff = cases[i];
    report += "  %^CYAN%^Suspect%^RESET%^: "+capitalize(stuff[NAME])+"\n";
    if(!sizeof(stuff[CHARS])) {
      report += "  %^CYAN%^Other Characters%^RESET%^: Unknown.\n";
    } else {
      report += "  %^CYAN%^Other Characters%^RESET%^: "
        "$I$5="+query_multiple_short(stuff[CHARS])+"$I$0=\n";
    }
    report +=  "  %^CYAN%^Creator%^RESET%^: "+capitalize(stuff[CREATOR])+"\n"
      "  %^CYAN%^Time%^RESET%^: "+stuff[TIME]+"\n"
      "  %^CYAN%^Offence%^RESET%^: "+stuff[CATEGORY]+"\n"
      "  %^CYAN%^Report%^RESET%^: $I$5="+stuff[REPORT]+"$I$0="
      "  %^YELLOW%^High Lord%^RESET%^: "+stuff[HIGHLORD]+"\n"
      "  %^YELLOW%^High Lord Decision%^RESET%^: "+stuff[DECISION];
    for(j = 8; j < sizeof(stuff); j += 2) {
      report += "  %^YELLOW%^Comment from "+stuff[j]+"%^RESET%^: "
        +stuff[j + 1];
    }
  }
  return report;
}
void add_comment(int i, string name, string comment) {
  i--;
  recent_cases[i] += ({ capitalize(name), comment });
  save_recent_cases();
}

==================================================
FILE: handlers/room_handler.c
==================================================

#include <climate.h>
#include <living.h>
#include <move_failures.h>
#include <player.h>
#include <room.h>
#include <weather.h>
#include <position.h>
#define CHATSIZE 80
#define DOORSIZE 60
mapping exit_types;
mapping door_types;
mapping opposite;
mixed *chatters, *doors;
void add_door( object thing );
void create() {
   seteuid( (string)"/secure/master"->
           creator_file( file_name( this_object() ) ) );
   exit_types = ([
"standard" :({ 0, 1,   400, 0 }),
"corridor" :({ 0, 1,   250, 0 }),
"plain"    :({ 0, 1, 10000, 0 }),
"door"     :({ 0, 1,   300, 0 }),
"stair"    :({ 0, 1,   300, 0 }),
"hidden"   :({ 0, 0,   300, 0 }),
"secret"   :({ 0, 0,   300, 0 }),
"gate"     :({ 0, 1,   450, 0 }),
"road"     :({ 0, 1,  1300, 0 }),
"path"     :({ 0, 1,   800, 0 }),
"window"   :({ "$N climb$s through a window.\n", 0, 75, 0 }),
]);
   door_types = ([
"door"      : ({ 0, 0, "generic_key", 2, 0, 0, "door" }),
"secret"    : ({ 0, 0, "generic_key", 3, 1, 0, "door" }),
"gate"      : ({ 1, 0, "generic_key", 1, 0, 1, "door" }),
"window"    : ({ 1, 0, "generic_key", 1, 0, 1, "window" }),
]);
   opposite = ([
"north" : ({ 0, "$R$[the ]+south$R$" }),
"south" : ({ 0, "$R$[the ]+north$R$" }),
"east" : ({ 0, "$R$[the ]+west$R$" }),
"west" : ({ 0, "$R$[the ]+east$R$" }),
"northeast" : ({ 0, "$R$[the ]+southwest$R$" }),
"southwest" : ({ 0, "$R$[the ]+northeast$R$" }),
"southeast" : ({ 0, "$R$[the ]+northwest$R$" }),
"northwest" : ({ 0, "$R$[the ]+southeast$R$" }),
"up":({0,"below"}), "down":({0,"above"}),
"out":({0,"inside"}), "in":({0,"outside"}),
"exit":({0,"inside"}), "enter":({0,"outside"}),
"hubward":({0,"rimward"}), "rimward":({0,"hubward"}),
"turnwise":({0,"widdershins"}),
"widdershins":({0,"turnwise"}) ]);
   chatters = allocate( CHATSIZE );
   doors = allocate( DOORSIZE );
   call_out( "housekeeping", 4 );
}
string query_opposite_direction(string dir) {
   if (opposite[dir]) {
      return opposite[dir][1];
   }
   return 0;
}
mixed *query_chatters() { return chatters; }
mixed *query_doors() { return doors; }
int add_exit_type(string type, mixed message, mixed obvious,
                            int size, mixed func) {
  if (exit_types[type]) {
    return 0;
  }
  exit_types[type] = ({ message, obvious, size, func });
  return 1;
}
int remove_exit_type(string type) {
   map_delete(exit_types, type);
   return 1;
}
mixed *query_door_type(string type, string direc, string dest) {
   if (!door_types[type]) {
      return 0;
   }
   call_out( "check_door", 1, ({ previous_object(), direc }) );
   return door_types[type];
}
void check_door( mixed args ) {
   string direc, dest;
   string door_name;
   if ( !args[ 0 ] ) {
      return;
   }
   args[ 0 ]->set_destination( args[ 1 ] );
   dest = (string)args[ 0 ]->query_destination( args[ 1 ] );
   if ( !dest ) {
      tell_room( args[ 0 ], "Error: "+ args[ 1 ] +
            " is no longer an exit.\n" );
      return;
   }
   if ( !find_object( dest ) ) {
      return;
   }
   door_name = args[0]->call_door(args[1], "query_door_name");
   direc = (string)dest->query_door( args[ 0 ], door_name );
   if ( !direc &&
       !args[ 0 ]->call_door( args[ 1 ], "query_one_way" ) ) {
      tell_room( args[ 0 ], "Error: "+ dest +
                "does not have a door coming back here.\n" );
      return;
   }
   args[ 0 ]->modify_exit( args[ 1 ], ({ "other", direc }) );
   args[ 0 ]->modify_exit( args[ 1 ], ({
      "closed", (int)dest->call_door( direc, "query_closed" ),
      "locked", (int)dest->call_door( direc, "query_locked" ) }) );
   if ( !args[ 0 ]->call_door( args[ 1 ], "query_closed" ) &&
       ( (string)args[ 0 ]->query_property( "location" ) == "outside" ) ) {
      add_door( (object)args[ 0 ]->query_door_control( args[ 1 ], door_name ) );
   }
}
mixed *query_exit_type(string type, string dir) {
  mixed s;
   if (!(s = opposite[dir])) {
      s = ({ 0, "elsewhere" });
   }
   if (!exit_types[type]) {
      return exit_types["standard"] + ({ s, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
   }
   return exit_types[ type ] + ({ s, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
}
int move_thing( object thing, string dir, string dest, mixed exit,
                mixed enter, string move ) {
  int ret;
  string arrive, leave;
  object dragging;
  dragging = (object)thing->query_dragging();
  if (dragging && environment(dragging) != environment(thing)) {
    thing->reset_dragging();
    dragging = 0;
  }
  if ( ( exit != "none" ) || objectp( dragging ) ) {
    if ( stringp( enter ) )
      enter = ({ 1, enter });
    else if ( functionp(enter) )
      enter = ({ 1, evaluate(enter, thing) });
    else if ( !pointerp( enter ) )
      enter = ({ 0, "somewhere" });
    switch ( enter[ 0 ] ) {
    case 0 :
      arrive = replace( (string)thing->query_msgin(),
                        ({"$F", enter[ 1 ],
                          "$r", thing->query_pronoun() }) );
      break;
    default :
      arrive = enter[ 1 ];
    }
    if ( stringp( exit) )
      leave = exit;
    else if ( functionp( exit ) )
      leave = evaluate(exit, thing);
    else if ( pointerp( exit ) )
      leave = exit[ 0 ];
    else
      leave = (string)thing->query_msgout();
    leave = replace( leave, ({"$T", "$R$-"+ dir +"$R$",
                              "$r", thing->query_pronoun() }) );
  }
  thing->return_to_default_position(1);
  if ( arrive || objectp( dragging ) ) {
    thing->remove_hide_invis( "hiding" );
    if ( stringp( arrive ) && objectp( dragging ) ) {
      arrive += "\n$C$"+ (string)thing->query_pronoun() +" drags "+
        (string)dragging->a_short() +" in behind "+
        (string)thing->query_objective() +".";
    }
    if ( stringp( leave ) && objectp( dragging ) ) {
      leave += "\n$C$"+ (string)thing->query_pronoun() +" drags "+
        (string)dragging->the_short() +" away behind "+
        (string)thing->query_objective() +".";
    }
    if ( stringp( move ) ) {
      tell_object( thing, move );
    }
    ret = (int)thing->move( dest, arrive, leave );
    if ( ( ret == MOVE_OK ) && objectp( dragging ) ) {
      if(dragging->move(environment(thing)) == MOVE_OK) {
        tell_object( thing, "You drag "+
                     (string)dragging->the_short() +" behind you.\n" );
        thing->adjust_time_left( -DEFAULT_TIME );
      } else {
        tell_object( thing, "You fail to drag "+
                     (string)dragging->the_short() +" behind you.\n" );
      }
    }
  } else {
    if ( stringp( move ) ) {
      tell_object( thing, move );
    }
    ret = (int)thing->move( dest );
  }
  if ( ret == MOVE_OK ) {
    thing->adjust_time_left( -DEFAULT_TIME );
    return 1;
  }
  return 0;
}
int exit_move_door_checks(object thing, mixed closed) {
  closed->force_other();
  if(closed->query_open())
    return 1;
  if(thing->query_property( "demon" ) || thing->query_property("dead")) {
    tell_object(thing, "You ghost through "+(string)closed->the_short()+
                ".\n");
    return 1;
  }
  if(thing->query_weight() < 300)
    return 0;
  if(closed->query_locked() && !closed->moving_unlock(thing)) {
    if(!closed->query_visible(thing)) {
      return 0;
    }
    tell_object(thing, (string)closed->the_short() +
                ({ " is ", " are " })[(int)closed->query_how_many()] +
                "locked.\n");
    return notify_fail("");
  }
  if(!closed->moving_open(thing)) {
    return 0;
  }
  return 1;
}
int exit_move_func_checks(string verb, string special, object thing,
                          mixed func, object place) {
  if(stringp(func))
    return call_other(place, func, verb, thing, special);
  if(functionp(func))
    return evaluate(func, verb, thing, special);
  if(pointerp(func) && sizeof(func) > 1 && func[0] && func[1])
    return call_other(func[0], func[1], verb, thing, special);
  return 1;
}
int exit_move( string verb, string extra, mixed special, object thing ) {
   string leave;
   object place;
   object follower;
   object *okay;
   mixed closed;
   int locked;
   mixed func;
   mixed *dest_other;
   object *all_followers;
   object *tmp_followers;
   object *more_followers;
   place = environment( thing );
   verb = (string)place->expand_alias( verb );
   place->set_destination( verb );
   dest_other = (mixed *)place->query_dest_other( verb );
   if (!pointerp(dest_other))
      return 0;
   if(thing->cannot_walk( verb, dest_other ))
      return notify_fail( "" );
   closed = (object)place->query_door_control( verb );
   if(objectp(closed)) {
     closed->force_other();
     if(!closed)
       closed = (object)place->query_door_control( verb );
   }
   if (!interactive(thing) && living(thing)
         && sizeof(dest_other) > ROOM_NPC_STOP && dest_other[ROOM_NPC_STOP])
      return 0;
   if (objectp(closed)) {
      locked = closed->query_locked();
   }
   if(objectp(closed) && closed->query_open()) {
     closed = 0;
   }
   if(objectp(closed) && !exit_move_door_checks(thing, closed)) {
     return 0;
   }
   if ( place->block_exit_move( verb, thing ) ) {
     return notify_fail( "" );
   }
   func = dest_other[ROOM_FUNC];
   if(func && !thing->query_property( "demon" ) &&
      !exit_move_func_checks(verb, special, thing, func, place))
     return 0;
   if ( place->query_relative( verb ) )
     leave = (string)thing->find_rel( verb, 0 );
   else
     leave = verb;
   if((int)thing->query_height() > dest_other[ ROOM_SIZE ] &&
      !(thing->query_crawling() &&
        (int)thing->query_height()/3 <= dest_other[ ROOM_SIZE ])) {
     tell_object( thing, "You are too tall to go that way.\n" );
     return notify_fail( "" );
   }
   if ( !stringp( special ) ) {
      special = dest_other[ ROOM_EXIT ];
   }
   if ( !move_thing( thing, verb, dest_other[ ROOM_DEST ], special,
                     dest_other[ ROOM_ENTER ], dest_other[ ROOM_MESS ] ) ) {
     return 0;
   }
   thing->return_to_default_position(1);
   okay = ({ });
   if (place) {
     all_followers = thing->query_followers();
     more_followers = all_followers;
     do {
       tmp_followers = ({ });
       foreach (follower in more_followers) {
         if (follower &&
             environment( follower ) == place ) {
           tmp_followers |= follower->query_followers();
         }
       }
       more_followers = tmp_followers - all_followers;
       all_followers |= tmp_followers;
     } while (sizeof(more_followers));
     foreach ( follower in all_followers) {
       if ( !objectp( follower ) ) {
         thing->remove_follower( follower );
         continue;
       }
       if(environment(follower) != place ||
          (userp(follower) && !interactive(follower)) ||
          (!thing->query_visible(follower) || (special == "none")) ||
          follower->query_property( PASSED_OUT) ||
          follower->cannot_walk( verb, dest_other ))
         continue;
       if(objectp(closed) && !exit_move_door_checks(follower, closed))
         continue;
       if ( func && !follower->query_property( "demon" ) &&
            !exit_move_func_checks(verb, special, follower, func, place))
         continue;
       if (!interactive(follower) && living(follower)
           && sizeof(dest_other) > ROOM_NPC_STOP && dest_other[ROOM_NPC_STOP])
         continue;
       if ( place->query_relative( verb ) ) {
         leave = (string)follower->find_rel( verb, 0 );
         follower->reorient_rel( leave );
       } else {
         leave = verb;
         follower->reorient_abs( leave );
       }
       if ( (int)follower->query_height() > dest_other[ ROOM_SIZE ] ) {
         tell_object( follower, "You are too tall to follow "+
                      (string)thing->the_short() +" "+ leave +".\n" );
         continue;
       }
       if (function_exists("check_doing_follow", follower) &&
           !follower->check_doing_follow(thing, verb, special)) {
         continue;
       }
       if(move_thing( follower, verb, dest_other[ROOM_DEST], special,
                      dest_other[ROOM_ENTER], dest_other[ROOM_MESS]) &&
          living(follower)) {
         tell_object(follower, "You follow "+ (string)thing->the_short() +
                     " "+ leave +".\n");
         if(follower->query_visible(thing))
           okay += ({ follower });
         follower->return_to_default_position(1);
       } else {
         tell_object( follower, "You fail to follow "+
                      (string)thing->the_short() +" "+ leave +".\n" );
       }
     }
   }
   thing->room_look();
   if(sizeof(okay)) {
     okay->room_look();
     tell_object(thing, query_multiple_short(okay) +
                 " $V$0=follows,follow$V$ you.\n" );
   }
   if(objectp(closed)) {
      closed->moving_close(thing);
      if (locked)
        closed->moving_lock(thing);
   }
   return 1;
}
void housekeeping() {
   call_out( "check_chatters", 1 );
   call_out( "check_doors", 2 );
   call_out( "housekeeping", 4 );
}
void add_chatter(object thing, int number) {
   number /= 4;
   if ( number > CHATSIZE - 1 )
      number = CHATSIZE - 1;
   if ( !pointerp( chatters[ number ] ) )
      chatters[ number ] = ({ thing });
   else
      chatters[ number ] += ({ thing });
}
void check_chatters() {
   object thing, *things;
   things = chatters[ 0 ];
   chatters[ 0 .. <2 ] = chatters[ 1 .. <1 ];
   chatters[ <1 ] = 0;
   if ( !pointerp( things ) )
      return;
   foreach ( thing in things ) {
      if ( objectp( thing ) )
         thing->make_chat();
   }
}
void add_door( object thing ) {
   int number;
   number = random( DOORSIZE );
   if ( !pointerp( doors[ number ] ) )
      doors[ number ] = ({ thing });
   else
      doors[ number ] += ({ thing });
}
void check_doors() {
   int wind;
   string dest, other, mess;
   object mine, thing, *things;
   things = doors[ 0 ];
   doors[ 0 .. <2 ] = doors[ 1 .. <1 ];
   doors[ <1 ] = 0;
   if ( !pointerp( things ) )
      return;
   foreach ( thing in things ) {
      if ( !objectp( thing ) )
         continue;
      if ( thing->query_closed() )
         continue;
      if(thing->query_stuck())
         continue;
      dest = (string)thing->query_dest();
      other = (string)thing->query_other_id();
      mine = (object)thing->query_my_room();
      wind = (int)WEATHER->calc_actual( mine, WINDSP );
      if ( random( 25 ) > wind ) {
         add_door( thing );
         return;
      }
      switch ( wind ) {
       case -1000 .. 20 :
         mess = "blow$s shut in the breeze.\n";
         break;
       case 21 .. 40 :
         mess = "blow$s shut in the wind.\n";
         break;
       default :
         mess = "slam$s shut in the wind.\n";
      }
      if ( find_object( dest ) ) {
         dest->modify_exit( other, ({ "closed", 1 }) );
         if(thing->query_autolock())
           dest->modify_exit(other, ({ "locked", 1 }));
         dest->tell_door( other, "The $D "+ mess, 0 );
      }
      thing->set_closed( 1 );
      if(thing->query_autolock())
        thing->set_locked();
      thing->tell_door( "The $D "+ mess, 0 );
   }
}
mapping query_dynamic_auto_load() {
   mapping tmp;
   tmp = ([ "exit_types" : exit_types,
            "door_types" : door_types,
            "opposite" : opposite,
            "chatters" : chatters,
            "doors" : doors,
          ]);
   return tmp;
}
void init_dynamic_arg(mapping maps) {
   if (maps["exit_types"])
      exit_types = maps["exit_types"];
   if (maps["door_types"])
      door_types = maps["door_types"];
   if (maps["opposite"])
      opposite = maps["opposite"];
   if (maps["chatters"])
      chatters = maps["chatters"];
   if (maps["doors"])
      doors = maps["doors"];
}
mixed *stats() {
   int door_count, chatter_count;
   mixed temp;
   foreach (temp in chatters)
      chatter_count += sizeof( temp );
   foreach (temp in doors)
      door_count += sizeof( temp );
   return ({
      ({ "exit types", sizeof( exit_types ) }),
      ({ "door types", sizeof( door_types ) }),
      ({ "opposites",  sizeof( opposite ) }),
      ({ "chatters",  chatter_count }),
      ({ "doors", door_count }),
   });
}

==================================================
FILE: handlers/room_rental.c
==================================================

#include <money.h>
#include <room/room_rental.h>
protected void do_load();
protected void do_save();
protected void evict_tenant( object room_ob );
private nosave int loaded = 0;
private mapping rented_rooms = ([]);
private mapping rental = ([]);
private mapping eviction_times = ([]);
private mapping locations = ([]);
private mapping paths = ([]);
void create() {
  do_load();
}
void reset() {
   string room;
   int now = time();
   foreach( room in keys( rented_rooms ) ) {
      if ( stringp( rented_rooms[ room ] ) ) {
         if ( ( eviction_times[ room ] < now ) &&
              ( eviction_times[ room ] > -1 ) ) {
            evict_tenant( find_object( room ) );
            tell_creator( "goldenthread", "RENTAL: %s no longer rents %s\n",
                          rented_rooms[ room ], room );
            rented_rooms[ room ] = 0;
            eviction_times[ room ] = -1;
         }
      }
   }
   do_save();
}
protected void do_load() {
   if ( !loaded )
      unguarded( (: restore_object( ROOM_RENTAL_SAVE_FILE, 1 ) :) );
   loaded = 1;
}
protected void do_save() {
   unguarded( (: save_object( ROOM_RENTAL_SAVE_FILE , 0 ) :) );
}
void evict_tenant( object room_ob ) {
   object *occupants;
   occupants = filter( all_inventory( room_ob ), (: living :) );
   room_ob->evict_tenant( occupants );
}
int add_room( string room, int cost, object office ) {
   object room_ob;
   if( !room_ob = load_object( room ) )
      return 0;
   rented_rooms[ room ] = 0;
   rental[ room ] = cost;
   eviction_times[ room ] = -1;
   locations[ room ] = office->query_location();
   paths[ room_ob->short() ] = room;
   do_save();
   return 1;
}
string query_who_rents( string room, object office ) {
   if ( locations[room] == office->query_location() ) {
      if ( stringp( rented_rooms[room] ) )
         return rented_rooms[room];
      else
         return "nobody";
   } else
      return "no such room in this location";
}
int check_tenant( object player_ob, object room_ob, object office ) {
   string player = player_ob->short();
   string room = room_ob->short();
   if ( player == query_who_rents( room, office ) )
      return RENTAL_SUCCESS;
   else if ( player == "nobody" )
      return RENTAL_AVAILABLE;
   else if ( player == "no such room!" )
      return RENTAL_NO_SUCH_ROOM;
   else
      return RENTAL_ALREADY_RENTED;
}
int delete_room( string room, object office ) {
  string room_short = load_object( room )->short();
  if ( locations[room] == office->query_location() ) {
    map_delete( rented_rooms, room );
    map_delete( rental, room );
    map_delete( eviction_times, room );
    map_delete( locations, room );
    map_delete( paths, room_short );
    do_save();
    return 1;
  } else
    return 0;
}
int clear_rooms( object office ) {
   object room_ob;
   foreach( string room in keys( filter( locations,
            (: $2 == $( office->query_location() ) :) ) ) ) {
      room_ob = load_object( room );
    map_delete( rented_rooms, room );
    map_delete( rental, room );
    map_delete( eviction_times, room );
    map_delete( locations, room );
    map_delete( paths, room_ob->query_short() );
  }
  do_save();
  return 1;
}
string *query_rooms_to_rent( object office ) {
  return keys( filter( locations,
               (: $2 == $( office->query_location() ) :) ) );
}
int do_rental( object player_ob, string room_short, object office ) {
   int result;
   string domain = office->query_domain();
   string room = paths[ room_short ];
   if ( locations[room] == office->query_location() ) {
      if ( !rented_rooms[room] ||
           ( rented_rooms[room] == player_ob->short()) ) {
         if ( (int)player_ob->query_value_in( domain ) < rental[room] )
            return RENTAL_NO_MONEY;
         rented_rooms[room] = player_ob->short();
         eviction_times[room] = time() + ONE_DAY;
         result = RENTAL_SUCCESS;
      } else
         result = RENTAL_ALREADY_RENTED;
   } else
      result = RENTAL_NO_SUCH_ROOM;
   do_save();
   return result;
}
int query_rental_value( string room ) {
   return rental[ room ];
}
int remove_rental( object room_ob ) {
   int result;
   string room_short = room_ob->short();
   string room = paths[ room_short ];
   if ( !undefinedp( rented_rooms[room] ) ) {
      rented_rooms[room] = 0;
      result = RENTAL_SUCCESS;
   } else
      result = RENTAL_NO_SUCH_ROOM;
   do_save();
   return result;
}

==================================================
FILE: handlers/route_handler.c
==================================================

int use_count;
varargs void get_route(string end, string start, function call_back, int count) {
  string *result;
  if(start == "/room/virtual"){
    call_out((: evaluate($(call_back), ({ })) :), 1);
    return;
  }
  if(!(stringp(start) && stringp(end)))
    error("illegal argument 1 or 2 to get_route");
  if(!function_owner(call_back))
    return;
  if ((end == start) || (count > 3)){
    call_out((: evaluate($(call_back), ({ })) :), 1);
    if(end != start)
      log_file("ROUTEHANDLER","route for %s from %s to %s failed\n",
               file_name(function_owner(call_back)), start, end);
    return;
  }
  result = "/obj/handlers/clusters"->get_route(start, end);
  if(!result){
    call_out((:get_route($(end), $(start), $(call_back), $(count + 1)):), 10);
    return;
  }
  use_count++;
  call_out((: evaluate($(call_back), $(result)) :), 1);
  return;
}
void dest_me() {
  destruct(this_object());
}
mixed *stats() {
  return  ({
    ({ "routes done", use_count }),
  });
}

==================================================
FILE: handlers/script_processor.c
==================================================

#define RATIO 20
inherit "/std/object";
string stage;
mapping actors;
void setup() {
   actors = ([ ]);
}
string query_stage() { return stage; }
void set_stage( string word ) { stage = word; }
mapping query_actors() { return actors; }
string query_actor( string word ) { return actors[ word ]; }
void set_actor( string name, string path ) { actors[ name ] = path; }
int perform_line( string script, int line ) {
   int length;
   string action, name, text;
   object actor;
   length = file_length( script );
   if ( length < 1 ) {
      write( "Length of file \""+ script +"\" is "+ length +".\n" );
      return -1;
   }
   if ( length < line )
      return -1;
   if ( !stage || ( stage == "" ) )
      return -2;
   text = read_file( script, line, 1 );
   if ( sscanf( text, "%s=%s\n", name, action ) == 2 ) {
      if ( !actors[ name ] )
         return -3;
      actor = find_object( actors[ name ] );
      if ( !actor )
         return -4;
      actor->do_command( action );
   } else {
      actor = find_object( stage );
      if ( !actor )
         return -4;
      tell_room( actor, text );
   }
   if ( length == line )
      return -5;
   return strlen( text ) / RATIO;
}
void perform_script( string script, int line ) {
   int next;
   next = perform_line( script, line );
   if ( next < 0 ) {
      if ( find_object( stage ) )
         stage->script_ended( next );
      return;
   }
   call_out( "perform_script", 2 + next, script, line + 1 );
}
int start_script( string script ) {
   if ( find_call_out( "perform_script" ) != -1 )
      return 0;
   call_out( "perform_script", 3, script, 1 );
   return 1;
}

==================================================
FILE: handlers/snmp_handler.c
==================================================

#include "snmp.h"
void create()
{
}
buffer BufferiseInt(int p)
{
  buffer buf1;
  buf1=allocate_buffer(4);
  if(p<0)
  {
    buf1[0]=(4294967296+p)/16777216;
  } else {
    buf1[0]=p/16777216;
  }
  buf1[1]=p/65536;
  buf1[2]=p/256;
  buf1[3]=p%256;
  return buf1;
}
buffer GetData(buffer MIB)
{
  int i,j,k;
  object *tmp;
  buffer mibreply,mibdata,tmpbuf;
  mibreply=allocate_buffer(4);
  tmpbuf=allocate_buffer(1);
  mibreply[0]=48;
  mibreply[1]=0;
  mibreply[2]=OBJECT_IDENT;
  mibreply[3]=0;
  mibreply+=MIB;
  i=sizeof(mibreply);
  switch(MIB[6])
  {
    case 101 :
      j=sizeof(users());
      tmpbuf[0]=2;
      mibreply+=tmpbuf;
      tmpbuf[0]=0;
      mibreply+=tmpbuf;
      tmpbuf=BufferiseInt(j);
      mibreply+=tmpbuf;
      mibreply[i+1]=sizeof(tmpbuf);
      break;
    case 102 :
      j=0;
      tmp=users();
      for(k=0;k<sizeof(tmp);k++)
        if(tmp[k] && (tmp[k])->query_creator())
          j++;
      tmpbuf[0]=2;
      mibreply+=tmpbuf;
      tmpbuf[0]=0;
      mibreply+=tmpbuf;
      tmpbuf=BufferiseInt(j);
      mibreply+=tmpbuf;
      mibreply[i+1]=sizeof(tmpbuf);
      break;
    case 100 :
      tmpbuf[0]=2;
      mibreply+=tmpbuf;
      tmpbuf[0]=1;
      mibreply+=tmpbuf;
      tmpbuf[0]=0;
      mibreply+=tmpbuf;
      break;
    default :
      mibreply[0]=255;
      break;
  }
  mibreply[1]=sizeof(mibreply)-2;
  mibreply[3]=sizeof(MIB);
  return mibreply;
}

==================================================
FILE: handlers/soul_compiler.c
==================================================

#include "soul.h"
#include "user_parser.h"
private nosave string _current_file;
private nosave int _current_line;
private nosave int _file_len;
private nosave int _depth;
private nosave int _look_for;
private nosave int _last_chunk_compile;
private nosave mixed *_to_compile;
private nosave mixed *_arguments;
private nosave object _current_player;
void start_compile();
void parse_chunk(string chunk);
void make_into_soul_commands(mapping commands);
#define CHUNK_SIZE 20
#define OPEN_BRACKET 1
#define START_ARGUMENT 2
#define END_BRACKET 3
#define END_STRING 4
#define ARGUMENT_VALUE 5
#define ARGUMENT_NAME 6
#define REST_OF_ARGUMENT 7
void create() {
   _to_compile = ({ });
   seteuid("Root");
}
int test_security(string fname) {
   return 1;
}
void notify(string mess) {
   if (_current_player)
      tell_object(_current_player, mess);
}
void compile_file(string fname) {
   if (file_size(SOUL_DIR+fname) == -1) {
      tell_object(this_player(), "The file "+
                         SOUL_DIR+fname+" does not exist.\n");
      return ;
   }
   if (file_size(SOUL_DIR+fname) == -2) {
      tell_object(this_player(), "The file "+
                         SOUL_DIR+fname+" is a directory exist.\n");
      return ;
   }
   _to_compile += ({ SOUL_DIR+fname, this_player() });
   start_compile();
}
void compile_directory(string fname) {
   string *bits, start;
   int i;
   if (file_size(SOUL_DIR+fname) != -2) {
      tell_object(this_player(), "The file "+
                         fname+" is not a directory exist.\n");
      return ;
   }
   bits = explode(fname, "/");
   start = implode(bits[0..<1], "/");
   if (start != "") {
      start += "/";
   }
   fname = SOUL_DIR+fname;
   if (fname[<1] == '/') {
      fname += "*.s";
   } else {
      fname += "
void start_compile() {
   if ((_current_file || !sizeof(_to_compile)) &&
       (time() - _last_chunk_compile) > 10) {
      return ;
   }
   write("Starting to compile " + _to_compile[0] + "\n");
   _current_file = _to_compile[0];
   _current_player = _to_compile[1];
   _to_compile = _to_compile[2..];
   _current_line = 1;
   _depth = 0;
   _look_for = OPEN_BRACKET;
   _file_len = file_length(_current_file);
   _arguments = ({ 0, ([ ]) });
   call_out("compile_chunk", 2);
}
void compile_chunk() {
   string chunk;
   int end;
   _last_chunk_compile = time();
   if (_current_line+CHUNK_SIZE > _file_len) {
      end = _file_len+1;
   } else {
      end = _current_line+CHUNK_SIZE;
   }
   chunk = unguarded((: read_file, _current_file, _current_line,
                               end-_current_line :));
   _current_line = end;
   parse_chunk(chunk);
   if (end > _file_len) {
      call_out("start_compile", 2);
      _current_file = 0;
      make_into_soul_commands(_arguments[1]);
   } else {
      call_out("compile_chunk", 2);
   }
}
void parse_chunk(string chunk) {
   string *bits, s1, s2;
   int pos, chunk_size, start;
   chunk_size = strlen(chunk);
   pos = 0;
   bits = explode(chunk, "(");
   while (pos < chunk_size) {
      switch (_look_for) {
         case OPEN_BRACKET :
            if (sscanf(chunk[pos..], "%s(%s", s1, s2)) {
               chunk = s2;
               chunk_size = strlen(chunk);
               pos = 0;
               _depth++;
               _arguments += ({ 0, 0 });
               _look_for = ARGUMENT_NAME;
            } else {
               pos = chunk_size;
            }
            break;
         case ARGUMENT_NAME :
            while (pos < chunk_size && (chunk[pos] == ' ' ||
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos == chunk_size) {
               break;
            }
            start = pos;
            while (pos < chunk_size && chunk[pos] != ' ' &&
                      chunk[pos] != '\t' && chunk[pos] != '\n') {
               pos++;
            }
            _arguments[_depth*2] = chunk[start..pos-1];
            _look_for = ARGUMENT_VALUE;
            break;
         case ARGUMENT_VALUE :
            while (pos < chunk_size && (chunk[pos] == ' ' ||
                      chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos >= chunk_size) {
               break;
            }
            switch (chunk[pos]) {
               case '(' :
                  _arguments[_depth*2+1] = ([ ]);
                  _depth++;
                  _arguments += ({ 0, 0 });
                  _look_for = ARGUMENT_NAME;
                  pos++;
                  break;
               case '"' :
                  _arguments[_depth*2+1] = "";
                  _look_for = END_STRING;
                  pos++;
                  break;
               default :
                  start = pos;
                  if (sscanf(chunk[pos..], "%s)%s", s1, s2) == 2) {
                     _arguments[_depth*2+1] = replace(implode(explode(replace(s1,
                            ({ "\n", " ", "\r", "" })), " ")-({ "" }), " "), ", ", ",");
                     pos = 0;
                     chunk = ")"+s2;
                     _look_for = END_BRACKET;
                  } else {
                     _arguments[_depth*2+1] = chunk[pos..];
                     _look_for = REST_OF_ARGUMENT;
                     pos = 0;
                     chunk = "";
                  }
                  chunk_size = strlen(chunk);
                  break;
            }
            break;
         case REST_OF_ARGUMENT :
            if (sscanf(chunk[pos..], "%s)%s", s1, s2) == 2) {
               _arguments[_depth*2+1] = replace(implode(explode(
                                                    replace(_arguments[_depth*2+1]+s1, "\n", " "),
                                                                         " ") - ({ "" }),
                                                             " "), ", ", ",");
               pos = 0;
               chunk = ")"+s2;
               _look_for = END_BRACKET;
            } else {
               _arguments[_depth*2+1] += chunk[pos..];
               pos = 0;
               chunk = "";
            }
            chunk_size = strlen(chunk);
            break;
         case END_BRACKET :
            if (sscanf(chunk[pos..], "%s)%s", s1, s2)) {
               switch (_depth) {
                  case 2 :
                  case 3 :
                     if (pointerp(_arguments[_depth*2-1][_arguments[_depth*2]]))
                        _arguments[_depth*2-1][_arguments[_depth*2]] += ({ _arguments[_depth*2+1] });
                     else
                        _arguments[_depth*2-1][_arguments[_depth*2]] = ({ _arguments[_depth*2+1] });
                     break;
                  case 1 :
                  case 4 :
                  case 5 :
                  case 6 :
                  case 7 :
                     _arguments[_depth*2-1][_arguments[_depth*2]] = _arguments[_depth*2+1];
                     break;
               }
               chunk = s2;
               chunk_size = strlen(s2);
               _depth--;
               pos = 0;
               _arguments = _arguments[0.._depth*2+1];
               if (_depth) {
                  _look_for = START_ARGUMENT;
               } else {
                  _look_for = OPEN_BRACKET;
               }
            }
            break;
         case START_ARGUMENT :
            while (pos < chunk_size && (chunk[pos] == ' '
                   || chunk[pos] == '\t' || chunk[pos] == '\n')) {
               pos++;
            }
            if (pos >= chunk_size) {
               break;
            }
            switch (chunk[pos]) {
               case ')' :
                  _look_for = END_BRACKET;
                  break;
               case '(' :
                  _look_for = OPEN_BRACKET;
                  break;
               default :
                  if (!sscanf(chunk[pos..], "%s\n%s", s1, s2)) {
                     s1 = chunk;
                  }
                  printf("Syntax error in file %s, near %s\n", _current_file, s1);
                  _look_for = END_BRACKET;
                  break;
            }
            break;
         case END_STRING :
            if (sscanf(chunk[pos..], "%s\"%s", s1, s2)) {
               if (strlen(s1) > 0 && s1[strlen(s1)-1] == '\\') {
                  _arguments[_depth*2+1] += replace(s1[0..strlen(s1)-2], "\n", "")+"\"";
                  chunk = s2;
                  pos = 0;
                  chunk_size = strlen(s2);
               } else {
                  _arguments[_depth*2+1] += replace(s1, "\n", "");
                  _look_for = END_BRACKET;
                  chunk = s2;
                  pos = 0;
                  chunk_size = strlen(s2);
               }
            } else {
               _arguments[_depth*2+1] += replace(chunk, "\n", "");
               pos = chunk_size;
            }
            break;
         default :
            notify("Horrible error "+_look_for+"\n");
            pos = chunk_size;
            break;
      }
   }
}
int check_sort(string pat1, string pat2) {
   int lvl1, lvl2;
   lvl1 = ((mixed *)PATTERN_OB->compile_pattern(pat1))[0];
   lvl2 = ((mixed *)PATTERN_OB->compile_pattern(pat2))[0];
   return lvl2-lvl1;
}
string *sort_patterns(string *inp) {
   if (!pointerp(inp)) {
      printf("%O\n", inp);
      return ({ });
   }
   return sort_array(inp, "check_sort", this_object());
}
void make_into_soul_commands(mapping comms) {
   string *fluff;
   int i, failed, j;
   mapping ret, tmp;
   fluff = keys(comms);
   ret = ([ ]);
   for (i=0;i<sizeof(fluff);i++) {
      ret[fluff[i]] = ({ comms[fluff[i]]["pattern"], 0, 0 });
      if (comms[fluff[i]]["single"]) {
         if (comms[fluff[i]]["single"][0]["no-arguments"]) {
            tmp = comms[fluff[i]]["single"][0]["no-arguments"][0];
            if (!tmp["self"]) {
               notify("The 'self' type is missing in the no-argument, single for the soul command "+fluff[i]+"\n");
               failed = 1;
            } else if (!tmp["rest"]) {
               notify("The 'rest' type is missing in the no-argument, single for the soul command "+fluff[i]+"\n");
               failed = 1;
            } else {
               ret[fluff[i]][SINGLE] = ({ ({ tmp["self"], tmp["rest"],
                                                            tmp["position"] }),
                                                         0 });
            }
         }
         if (comms[fluff[i]]["single"][0]["arguments"]) {
            j = sizeof(comms[fluff[i]]["single"][0]["arguments"]);
            if (!ret[fluff[i]][SINGLE]) {
               ret[fluff[i]][SINGLE] = ({ 0, allocate(j*SMALL_ARG_SIZE) });
            } else {
               ret[fluff[i]][SINGLE][ARGUMENTS] = allocate(j*SMALL_ARG_SIZE);
            }
            for (j=0;j<sizeof(comms[fluff[i]]["single"][0]["arguments"]);j++) {
               tmp = comms[fluff[i]]["single"][0]["arguments"][j];
               if (!mapp(tmp)) {
                  notify("The soul command "+fluff[i]+" is totaly stuffed.\n");
                  failed = 1;
               } else if (!tmp["self"]) {
                  notify("The 'self' type is missing in the argument, single for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else if (!tmp["rest"]) {
                  notify("The 'rest' type is missing in the argument, single for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else if (!tmp["arguments"]) {
                  notify("The 'arguments' type is missing in the argument, single for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else {
                  ret[fluff[i]][SINGLE][ARGUMENTS][j*SMALL_ARG_SIZE+SELF] = tmp["self"];
                  ret[fluff[i]][SINGLE][ARGUMENTS][j*SMALL_ARG_SIZE+REST] = tmp["rest"];
                  ret[fluff[i]][SINGLE][ARGUMENTS][j*SMALL_ARG_SIZE+ARGS] = explode(tmp["arguments"], ",");
                  ret[fluff[i]][SINGLE][ARGUMENTS][j*SMALL_ARG_SIZE+POSITION_SINGLE] = tmp["position"];
               }
            }
         }
      }
      if (comms[fluff[i]]["targeted"]) {
         if (comms[fluff[i]]["targeted"][0]["no-arguments"]) {
            tmp = comms[fluff[i]]["targeted"][0]["no-arguments"][0];
            if (!tmp["self"]) {
               notify("The 'self' type is missing in the no-argument, target for the soul command "+fluff[i]+"\n");
               failed = 1;
            } else if (!tmp["rest"]) {
               notify("The 'rest' type is missing in the no-argument, target for the soul command "+fluff[i]+"\n");
               failed = 1;
            } else {
               ret[fluff[i]][TARGET] = ({ ({ tmp["self"], tmp["rest"],
                                     tmp["target"], 0, tmp["force"], tmp["position"] }),
                                                         0 });
            }
         }
         if (comms[fluff[i]]["targeted"][0]["arguments"]) {
            j = sizeof(comms[fluff[i]]["targeted"][0]["arguments"]);
            if (!ret[fluff[i]][TARGET])
               ret[fluff[i]][TARGET] = ({ 0, allocate(j*ARG_SIZE) });
            else
               ret[fluff[i]][TARGET][ARGUMENTS] = allocate(j*ARG_SIZE);
            for (j=0;j<sizeof(comms[fluff[i]]["targeted"][0]["arguments"]);j++) {
               tmp = comms[fluff[i]]["targeted"][0]["arguments"][j];
               if (!tmp["self"]) {
                  notify("The 'self' type is missing in the argument, target for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else if (!tmp["rest"]) {
                  notify("The 'rest' type is missing in the argument, target for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else if (!tmp["arguments"]) {
                  notify("The 'arguments' type is missing in the argument, target for the soul command "+fluff[i]+"\n");
                  failed = 1;
               } else {
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+SELF] = tmp["self"];
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+REST] = tmp["rest"];
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+TARG] = tmp["target"];
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+ARGS] = explode(tmp["arguments"], ",");
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+FORCE] = tmp["force"];
                  ret[fluff[i]][TARGET][ARGUMENTS][j*ARG_SIZE+POSITION] = tmp["position"];
               }
            }
         }
      }
   }
   fluff = keys(ret);
   for (i=0;i<sizeof(fluff);i++) {
      ret[fluff[i]][PATTERNS] = sort_patterns(ret[fluff[i]][PATTERNS]);
      SOUL_OBJECT->add_soul_command(fluff[i], ret[fluff[i]]);
      notify("Added soul command "+fluff[i]+".\n");
   }
}
void blue() {
   printf("%O\n", sort_patterns(({ "[at] <indirect:object>", "<string>" })));
}

==================================================
FILE: handlers/start_positions.c
==================================================

#include <login_handler.h>
#define SAVE_FILE "/save/start_position_handler"
#define CHECKED_PROP "checked start positions"
private int _last_added;
private string * _buggy_starts;
void load_file() {
   if ( file_size( SAVE_FILE + ".o" ) > 0 ||
        file_size( SAVE_FILE + ".o.gz" ) > 0 )
   {
      unguarded( (: restore_object, SAVE_FILE :) );
   }
}
void save_file() {
   unguarded( (: save_object, SAVE_FILE :) );
}
void create() {
   _last_added = 0;
   _buggy_starts = ({ });
   load_file();
   if ( !_buggy_starts ) {
      _buggy_starts = ({ });
   }
}
int add_buggy_start( string fname ) {
   if ( !fname ) {
      return 0;
   }
   fname = lower_case( fname );
   if ( fname[ <2 .. ] == ".c" ) {
      fname = fname[ 0 .. <3 ];
   }
   if ( member_array( fname, _buggy_starts ) != -1 ) {
      return -1;
   }
   _buggy_starts += ({ fname });
   _last_added = time();
   save_file();
   return 1;
}
int delete_buggy_start( string fname ) {
   if ( !fname ) {
      return 0;
   }
   fname = lower_case( fname );
   if ( fname[ <2 .. ] == ".c" ) {
      fname = fname[ 0 .. <3 ];
   }
   if ( member_array( fname, _buggy_starts ) == -1 ) {
      return -1;
   }
   _buggy_starts -= ({ fname });
   save_file();
   return 1;
}
string * list_buggy_starts() {
   return copy( _buggy_starts );
}
void remove_buggy_starts( object player ) {
   string * starts;
   if ( !player ) {
      return;
   }
   starts = copy( player->query_starts() );
   for( int i = 0; i < sizeof( starts ); i += 2 ) {
      if ( member_array( starts[i], _buggy_starts ) != -1 ) {
         player->remove_start( starts[i] );
      }
   }
   player->add_property( CHECKED_PROP, time() );
}
void login_callback( string player, string type ) {
   object playerob;
   if ( !player ||
        !type ||
        type != LOGIN )
   {
      return;
   }
   player = lower_case( player );
   if ( !( playerob =  find_player( player ) ) ||
        ( playerob->query_property( CHECKED_PROP ) >= _last_added ) )
   {
      return;
   }
   remove_buggy_starts( playerob );
}
void dest_me() {
   destruct( this_object() );
}

==================================================
FILE: handlers/state_change.c
==================================================

#include <state_change.h>
#define PROP "state name"
#define DATA_DIR "/obj/state_change/"
mapping table = ([ ]);
void set_amount_of_ob( object ob, int amount );
mixed query_table() { return table; }
void create() {
    string *files;
    int i;
    seteuid("/secure/master"->creator_file(file_name(this_object())));
    files = ({ "base.hdr" });
    files += get_dir(DATA_DIR + "*.dat");
    for (i = 0; i < sizeof(files); i++) {
        files[i] = DATA_DIR + files[i];
    }
    table += "/obj/handlers/data"->compile_data(files);
}
varargs object transform( object ob, string transformation, object player ) {
    string index, name;
    object ret;
    class state_change c;
    function f;
    int *weight_unit;
    if (!stringp(name = ob->query_property(PROP)))
      if (!stringp(name = ob->query_medium_alias()))
        name = ob->short();
    if ( !player )
      player = this_player();
    index = transformation + ":" + name;
    if (undefinedp(table[index]))
      return 0;
    c = table[index];
    ret = clone_object(c->result);
    foreach (f in c->func)
      evaluate(f, ob, ret, player);
    if (ret->query_continuous()) {
        if ( ob->query_continuous() || ob->query_collective() ) {
            ret->set_amount(to_int(ob->query_amount() * c->factor));
        } else {
            weight_unit = ret->query_weight_unit();
            set_amount_of_ob( ret, to_int( ob->query_weight() * c->factor *
              weight_unit[1] / weight_unit[0] ) );
        }
    } else {
        if ( ob->query_continuous() || ob->query_collective() ) {
            weight_unit = ob->query_weight_unit();
            ret->set_weight(to_int(ob->query_amount() * c->factor *
                                   weight_unit[0] / weight_unit[1]));
        } else {
            ret->set_weight(to_int(ob->query_weight() * c->factor));
        }
    }
    log_file( "STATE_CHANGE", "Changed %d amount of %s to %d amount of %s via %s.\n",
      ob->query_amount(), ob->query_medium_alias(), ret->query_amount(),
      ret->query_medium_alias(), transformation );
    return ret;
}
void set_amount_of_ob( object ob, int amount ) {
  if ( !ob )
      return;
  if ( !amount )
      ob->dest_me();
  ob->set_amount( amount );
  return;
}

==================================================
FILE: handlers/taskmaster.c
==================================================

#include <tasks.h>
#define TIME_PER_USER 1800
#define SAVE_FILES "/save/tasks/"
#define LOG_STATS 2
#undef LOGGING
mapping stats;
nosave int last_save;
nosave int last;
nosave string skill;
nosave mixed *control;
nosave int * critical_chances;
varargs mixed perform_task( object person, string skill, int difficulty,
                         int tm_type, int degree );
varargs mixed attempt_task( int difficulty, int bonus, int upper,
                            mixed extra, int degree );
varargs mixed attempt_task_e( int difficulty, int bonus, int upper,
                              int half, int degree );
int is_critical( int margin );
void create() {
   float a, b;
   seteuid( "Root" );
   critical_chances = allocate(100);
   a = 0.93260;
   b = 0.06978;
   for( int i = 0; i < 100; i++ ) {
      critical_chances[i] = a * exp( b * ( i + 1 ) );
   }
}
mapping query_stats( string s_name ) {
  if ( skill != s_name ) {
    skill = s_name;
    if ( file_size( SAVE_FILES + skill +".o" ) > 0 )
      unguarded( (: restore_object, SAVE_FILES + skill :) );
    else
      stats = 0;
  }
  if ( !stats )
    stats = ([ ]);
  return copy( stats );
}
int query_last() { return last; }
mixed *query_control() { return control; }
void set_control( mixed *args ) { control = args; }
void reset_control() { control = 0; }
void award_made( string p_name, string o_name, string s_name, int level ) {
  user_event( "inform", p_name +" gains a level in "+ s_name +" from "+
              o_name + " at level " + level, "skill" );
#ifdef LOG_STATS
#if LOG_STATS == 1
  query_stats( s_name );
  if ( !stats[ level ] )
    stats[ level ] = ([ ]);
  stats[ level ][ explode( o_name, "#" )[ 0 ] ]++;
#else
  query_stats("summary");
  if(s_name[<7..] == ".points" || s_name[0..13] == "other.language")
    return;
  s_name = explode(s_name, ".")[0];
  if(!stats[s_name])
    stats[s_name] = ({ ({ 0 , 0 }),  ({ 0, 0 }),  ({ 0, 0 }) , ({0,0})});
  switch(level) {
  case 0..149:
    stats[s_name][0] = ({ stats[s_name][0][0], stats[s_name][0][1]+1 });
    break;
  case 150..299:
    stats[s_name][1] = ({ stats[s_name][1][0], stats[s_name][1][1]+1 });
    break;
  case 300..599:
    stats[s_name][2] = ({ stats[s_name][2][0], stats[s_name][2][1]+1 });
    break;
  default:
    stats[s_name][3] = ({ stats[s_name][3][0], stats[s_name][3][1]+1 });
    break;
  }
  if(last_save < time() - 300) {
    unguarded( (: save_object, SAVE_FILES + "summary" :) );
    last_save = time();
  }
#endif
#endif
}
#if LOG_STATS == 2
void skill_checked(string s_name, int level) {
  query_stats("summary");
  if(s_name[<7..] == ".points" || s_name[0..13] == "other.language")
    return;
  s_name = explode(s_name, ".")[0];
  if(!stats[s_name])
    stats[s_name] = ({ ({0,0}), ({0,0}), ({0,0}), ({0,0}), ({0,0}) });
  switch(level) {
  case 0..49:
    stats[s_name][0] = ({ stats[s_name][0][0]+1, stats[s_name][0][1] });
    break;
  case 50..149:
    stats[s_name][1] = ({ stats[s_name][1][0]+1, stats[s_name][1][1] });
    break;
  case 150..299:
    stats[s_name][2] = ({ stats[s_name][2][0]+1, stats[s_name][2][1] });
    break;
  case 300..599:
    stats[s_name][3] = ({ stats[s_name][3][0]+1, stats[s_name][3][1] });
    break;
  default:
    stats[s_name][4] = ({ stats[s_name][4][0]+1, stats[s_name][4][1] });
    break;
  }
  if(last_save < time() - 300) {
    unguarded( (: save_object, SAVE_FILES + "summary" :) );
    last_save = time();
  }
}
#endif
string *query_skill_files() {
  return unguarded( (: get_dir, SAVE_FILES +"*.o" :) );
}
void clear_skill_files() {
  string word;
  foreach ( word in unguarded( (: get_dir, SAVE_FILES +"*.o" :) ) )
    unguarded( (: rm, SAVE_FILES + word :) );
  skill = 0;
}
varargs mixed compare_skills( object offob, string offskill,
                              object defob, string defskill,
                              int modifier, int off_tm_type,
                              int def_tm_type, int degree )
{
  int offbonus, defbonus;
  int perc, chance;
  int success_margin, res, deg;
  if( !offob || !defob || !offskill || !defskill )
    return BARF;
  offbonus = offob->query_skill_bonus(offskill);
  defbonus = defob->query_skill_bonus(defskill);
  if( !defbonus ) {
    defbonus = 1;
  }
  if( !offbonus ) {
    offbonus = 1;
  }
  (offbonus > defbonus) ?
    perc = (50 * offbonus * offbonus) / (offbonus * defbonus) :
    perc = 100 - (50 * defbonus * defbonus) / (offbonus * defbonus);
  perc += modifier;
  if(perc > 99)
    perc = 99;
  if(perc < 1)
    perc = 1;
  chance = random(100);
  success_margin = perc - chance;
  if( success_margin > 0 ) {
    switch( perform_task( offob, offskill, defbonus-modifier,
                          off_tm_type, 0 ) )
    {
    case AWARD:
      res = OFFAWARD;
      break;
    default:
      res = OFFWIN;
    }
    if( degree ) {
      if( is_critical(success_margin) ) {
        deg = TASKER_CRITICAL;
      } else {
         if( success_margin < TASKER_MARGINAL_UPPER ) {
           deg = TASKER_MARGINAL;
         } else if( success_margin < TASKER_NORMAL_UPPER ) {
           deg = TASKER_NORMAL;
         } else {
           deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
    } else {
      return res;
    }
  } else {
    switch( perform_task( defob, defskill, offbonus-modifier,
                          def_tm_type, 0 ) ) {
    case AWARD:
      res = DEFAWARD;
      break;
    default:
      res = DEFWIN;
    }
    if( degree ) {
      if( is_critical(success_margin) ) {
        deg = TASKER_CRITICAL;
      } else {
         if( -success_margin < TASKER_MARGINAL_UPPER ) {
           deg = TASKER_MARGINAL;
         } else if( -success_margin < TASKER_NORMAL_UPPER ) {
           deg = TASKER_NORMAL;
         } else {
           deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
    } else {
      return res;
    }
  }
}
varargs mixed perform_task( object person, string skill, int difficulty,
                            int tm_type, int degree ) {
  mixed result;
  int bonus, upper;
  if( !person || !skill )
    return BARF;
  bonus = person->query_skill_bonus( skill );
  switch(tm_type) {
  case TM_FIXED:
    result = attempt_task( difficulty, bonus, 100, 0, degree );
    break;
  case TM_FREE:
    result = attempt_task( difficulty, bonus, 25, 0, degree );
    break;
  case TM_CONTINUOUS:
    result = attempt_task( difficulty, bonus, 50, 0, degree );
    break;
  case TM_COMMAND:
    if( explode( skill, "." )[0] == "covert" )
      result = attempt_task_e
  ( difficulty, bonus, 60, 40, degree );
    else
      result = attempt_task( difficulty, bonus, 100, 0, degree );
    break;
  case TM_RITUAL:
    result = attempt_task_e( difficulty, bonus, 50, 25, degree );
    break;
  case TM_SPELL:
    result = attempt_task_e( difficulty, bonus, 60, 40, degree );
    break;
  case TM_NONE:
    result = attempt_task_e(difficulty, bonus, 1, 0, degree);
    if(classp(result) && ( (class tasker_result)result )->result == AWARD) {
      result->result = SUCCEED;
    } else if( result == AWARD ) {
      result = SUCCEED;
    }
    break;
  default:
#ifdef LOGGING
    if(file_name(previous_object())[0..2] != "/w/")
      log_file("ATTEMPT_TASK",
               "%s Object %s using old perform_task [%d, %d]\n",
               ctime(time()), base_name(previous_object()), tm_type, degree );
#endif
    upper = tm_type;
    if ( !upper )
      upper = 100;
    result = attempt_task( difficulty, bonus, upper, 0, degree );
  }
  if(classp(result) && ( (class tasker_result)result )->result == AWARD ||
     result == AWARD) {
    if(person->advancement_restriction() ||
       !person->add_skill_level(skill, 1, previous_object())) {
      if(classp(result))
        result->result = SUCCEED;
      else
        result = SUCCEED;
    }
  }
  return result;
}
varargs mixed attempt_task( int difficulty, int bonus, int upper,
                            mixed extra, int degree )
{
   int margin, success_margin, deg, res;
   float tmp;
#ifdef LOGGING
   if( call_stack(2)[1] != "perform_task" &&
       base_name( previous_object() ) != "/std/effects/fighting/combat" &&
       file_name( previous_object() )[0..2] != "/w/" )
   {
     log_file("ATTEMPT_TASK", "%s Object %s is using old attempt_task "
              "[%O]\n",
              ctime( time() ), base_name( previous_object() ), call_stack(2) );
   }
#endif
#if LOG_STATS == 2
   if(pointerp(control) && control[1]) {
      skill_checked(control[1], control[0]->query_skill(control[1]));
   }
#endif
   if ( bonus < difficulty ) {
#ifdef DEBUG
      if(pointerp(control) && control[0]->query_name() == WATCH_PLAYER &&
         find_player(DEBUG))
      {
         tell_creator( DEBUG, "%^RED%^"
           + sprintf( "TM: %s Skill: %s [%d] [%d] Failed\n",
                      control[0]->query_name(), control[1], bonus, difficulty )
           + "%^RESET%^" );
      }
#endif
      if( degree ) {
         return new( class tasker_result,
                     result : FAIL,
                     degree : ( is_critical( -100 ) ?
                                TASKER_CRITICAL :
                                TASKER_EXCEPTIONAL ),
                     raw    : -100 );
      } else {
         return FAIL;
      }
   }
   if ( !extra )
      margin = 3 * sqrt( difficulty );
   else {
      if ( intp( extra ) )
         margin = extra;
      if ( pointerp( extra ) )
         margin = extra[ 0 ] + extra[ 1 ] * sqrt( difficulty );
   }
   if ( !margin )
      return BARF;
   if ( bonus > difficulty + margin ) {
#ifdef DEBUG
     if(pointerp(control) &&
        WATCH_PLAYER || control[0]->query_name() == WATCH_PLAYER &&
        find_player(DEBUG))
       tell_object(find_player(DEBUG), "%^RED%^" + sprintf("TM: %s Skill: %s [%d] [%d] [%d] Succeeded\n", control[0]->query_name(), control[1], bonus, difficulty, margin) + "%^RESET%^");
#endif
      if( degree ) {
         return new( class tasker_result,
                     result : SUCCEED,
                     degree : ( is_critical(100) ?
                                TASKER_CRITICAL :
                                TASKER_EXCEPTIONAL ),
                     raw    : 100 );
      } else {
         return SUCCEED;
      }
   }
   if(!margin)
     margin = 1;
   success_margin = ( ( 100 * ( bonus - difficulty ) ) / margin ) - random(100);
   if ( success_margin <= 0 ) {
#ifdef DEBUG
     if(pointerp(control) &&
        control[0]->query_name() == WATCH_PLAYER &&
        find_player(DEBUG))
       tell_object(find_player(DEBUG), "%^RED%^" + sprintf("TM: %s Skill: %s [%d] [%d] Failed (2)\n", control[0]->query_name(), control[1], bonus, difficulty) + "%^RESET%^");
#endif
      if( degree ) {
         if( is_critical(success_margin) ) {
            deg = TASKER_CRITICAL;
         } else {
            if( -success_margin < TASKER_MARGINAL_UPPER ) {
               deg = TASKER_MARGINAL;
            } else if( -success_margin < TASKER_NORMAL_UPPER ) {
               deg = TASKER_NORMAL;
            } else {
               deg = TASKER_EXCEPTIONAL;
            }
         }
         return new( class tasker_result,
                     result : FAIL,
                     degree : deg,
                     raw    : success_margin );
      } else {
         return FAIL;
      }
   }
   if ( pointerp( control ) ) {
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), "%^RED%^" +
                   sprintf("TM: %s Skill: %s [%d,%d] OU: %d ",
                           control[0]->query_name(),
                           control[1], bonus,
                           control[0]->query_skill(control[1]),
                           upper));
#endif
     upper = (int)control[ 0 ]->stat_modify(upper, control[ 1 ] );
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG),
                   sprintf("SU: %d ", upper));
#endif
     tmp = exp((control[0]->query_skill(control[1])-BASE) / DECAY);
     upper = to_int(upper / tmp) - MODIFIER;
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("LU: %d ", upper));
#endif
     if(upper < 0)
       upper = 0;
#ifdef DEBUG
      if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("FU: %d\n",
                                                 upper) + "%^RESET%^");
#endif
   }
#ifdef DEBUG
   else
     if(find_player(DEBUG))
       tell_object(find_player(DEBUG), sprintf("No control: %O\n",
                                                 previous_object(-1)));
#endif
     if(!margin)
        margin = 1;
   if( random(100) < ( upper * ( difficulty + margin - bonus ) ) / margin )
      res = AWARD;
   else
      res = SUCCEED;
   if( degree ) {
      if( is_critical(success_margin) ) {
         deg = TASKER_CRITICAL;
      } else {
         if( success_margin < TASKER_MARGINAL_UPPER ) {
            deg = TASKER_MARGINAL;
         } else if( success_margin < TASKER_NORMAL_UPPER ) {
            deg = TASKER_NORMAL;
         } else {
            deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
   } else {
      return res;
   }
}
varargs mixed attempt_task_e( int difficulty, int bonus, int upper,
                              int half, int degree )
{
   float fail_chance;
   float tmp;
   int success_margin, deg, res;
#ifdef LOGGING
   if(call_stack(2)[1] != "perform_task" &&
      base_name(previous_object()) != "/std/effects/fighting/combat" &&
      file_name(previous_object())[0..2] != "/w/") {
     log_file("ATTEMPT_TASK", "%s Object %s is using old attempt_task "
              "[%O]\n",
              ctime(time()), base_name(previous_object()), call_stack(2));
   }
#endif
#if LOG_STATS == 2
   if(pointerp(control) && control[1]) {
     skill_checked(control[1], control[0]->query_skill(control[1]));
   }
#endif
   if ( bonus < difficulty ) {
      if( degree ) {
         return new( class tasker_result,
                     result : FAIL,
                     degree : ( is_critical( -100 ) ?
                                TASKER_CRITICAL :
                                TASKER_EXCEPTIONAL ),
                     raw    : -100 );
      } else {
         return FAIL;
      }
   }
   if( !half )
      half = 6 * sqrt( difficulty );
   if( !half )
      half = 1;
   fail_chance = exp( ( -0.693 * ( bonus - difficulty ) ) / half );
   success_margin = ( random( 1000 ) - ( 1000 * fail_chance ) ) / 10;
   if ( success_margin < 0 ) {
      if( degree ) {
         if( is_critical(success_margin) ) {
            deg = TASKER_CRITICAL;
         } else {
            if( -success_margin < TASKER_MARGINAL_UPPER ) {
               deg = TASKER_MARGINAL;
            } else if( -success_margin < TASKER_NORMAL_UPPER ) {
               deg = TASKER_NORMAL;
            } else {
               deg = TASKER_EXCEPTIONAL;
            }
         }
         return new( class tasker_result,
                     result : FAIL,
                     degree : deg,
                     raw    : success_margin );
      } else {
         return FAIL;
      }
   }
   if ( pointerp( control ) ) {
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), "%^RED%^" +
                   sprintf("TM: %s Skill: %s [%d,%d] OU: %d ",
                           control[0]->query_name(),
                           control[1], bonus,
                           control[0]->query_skill(control[1]),
                           upper));
#endif
     upper = (int)control[ 0 ]->stat_modify( upper, control[ 1 ] );
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG),
                   sprintf("SU: %d ", upper));
#endif
     tmp = exp((control[0]->query_skill(control[1])-BASE) / DECAY);
     upper = to_int(upper / tmp) - E_MODIFIER;
#ifdef DEBUG
     if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("LU: %d ", upper));
#endif
     if(upper < 0)
       upper = 0;
#ifdef DEBUG
      if(find_player(DEBUG) && bonus >= MIN_LEVEL)
       tell_object(find_player(DEBUG), sprintf("FU: %d\n",
                                                 upper) + "%^RESET%^");
#endif
   }
   if ( random(1000) < ( upper * fail_chance * 10 )
    &&  bonus < difficulty + ( half * 5 ) ) {
      res = AWARD;
   } else {
      res = SUCCEED;
   }
   if( degree ) {
      if( is_critical(success_margin) ) {
         deg = TASKER_CRITICAL;
      } else {
         if( success_margin < TASKER_MARGINAL_UPPER ) {
            deg = TASKER_MARGINAL;
         } else if( success_margin < TASKER_NORMAL_UPPER ) {
            deg = TASKER_NORMAL;
         } else {
            deg = TASKER_EXCEPTIONAL;
         }
      }
      return new( class tasker_result,
                  result : res,
                  degree : deg,
                  raw    : success_margin );
   } else {
      return res;
   }
}
int is_critical( int margin ) {
   if ( margin < 0 ) {
      margin *= -1;
   }
   if ( margin > 100 ) {
      margin = 100;
   }
   if ( margin == 0 ) {
      return 0;
   }
   return random(10000) < critical_chances[ margin - 1 ];
}

==================================================
FILE: handlers/team.c
==================================================

#define CREATOR "Ceres"
#include <login_handler.h>
#define SHADOW "/std/shadows/misc/team"
#define MAX_GROUP_SIZE 5
class group {
  object leader;
  int policy;
  object *members;
  int locked;
}
mapping groups,
        members;
private void check_group(string g_name);
private void disband_group(string g_name, string p_name);
private void tidy_members(string g_name);
void create() {
  members = ([ ]);
  groups = ([ ]);
}
void dest_me() {
  destruct(this_object());
}
void leaving(string p_name, string type) {
  class group record;
  string g_name;
  if((type != "logout") || (!members[p_name]))
    return;
  g_name = members[p_name];
  record = (class group)groups[g_name];
  map_delete(members, p_name);
  if(!record)
    return;
  if((record->leader == 0) || ((record->leader)->query_name() == p_name)) {
     disband_group(g_name, p_name);
#ifdef LOG_FILE
    log_file(LOG_FILE, sprintf("%s %s has left the game, the %s has been "
                             "disbanded.\n", ctime(time()), p_name, g_name));
#endif
  } else {
#ifdef LOG_FILE
    log_file(LOG_FILE, sprintf("%s %s left the game while a member of the %s\n",
                             ctime(time()), p_name, g_name));
#endif
    record->members = delete(record->members,
                             member_array(0, record->members), 1);
  }
  return;
}
int new_group(string g_name, object leader, int policy) {
  class group record;
  if(!undefinedp(groups[g_name]))
    return 0;
  record = new(class group);
  record->leader = leader;
  record->policy = policy;
  record->members = ({ leader });
  groups[g_name] = record;
  members[leader->query_name()] = g_name;
  leader->set_title( "TEAM", "Team Leader of "+ g_name );
   clone_object( SHADOW )->setup_shadow( leader );
#ifdef LOG_FILE
  log_file(LOG_FILE, sprintf("%s %s created by %s\n", ctime(time()),
                           g_name, leader->query_name()));
#endif
  return 1;
}
int end_group(string g_name) {
  class group record;
  object player;
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
   foreach( player in record->members )
      if ( player ) {
         map_delete( members, player->query_name() );
         player->remove_title( "TEAM" );
         player->destruct_team_shadow();
      }
  map_delete(groups, g_name);
#ifdef LOG_FILE
  log_file(LOG_FILE, sprintf("%s %s disbanded\n", ctime(time()), g_name));
#endif
  return 1;
}
int join_group(string g_name, object player) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
  record->members += ({ player });
  members[player->query_name()] = g_name;
   player->set_title( "TEAM", "Team Member of "+ g_name );
   clone_object( SHADOW )->setup_shadow( player );
#ifdef LOG_FILE
  log_file(LOG_FILE, sprintf("%s %s joined by %s\n", ctime(time()),
                           g_name, player->query_name()));
#endif
  return 1;
}
int leave_group(string g_name, object player) {
  class group record;
  if(player) {
    map_delete(members, player->query_name());
      player->remove_title( "TEAM" );
      player->destruct_team_shadow();
#ifdef LOG_FILE
    log_file(LOG_FILE, sprintf("%s %s left by %s\n", ctime(time()), g_name,
                             player->query_name()));
#endif
  }
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
  if(member_array(player, record->members) == -1)
    return -1;
  record->members = delete(record->members,
                           member_array(player, record->members), 1);
  return 1;
}
object query_owner(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = (class group)groups[g_name];
  return record->leader;
}
object *query_members(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  tidy_members(g_name);
  record = groups[g_name];
  return (object *)record->members;
}
int query_policy(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = groups[g_name];
  return (int)record->policy;
}
string query_group(object player) {
  if(undefinedp(members[player->query_name()]))
    return 0;
  return members[player->query_name()];
}
int test_group(string g_name) {
  if(undefinedp(groups[g_name]))
    return 0;
  return 1;
}
int query_full(string g_name) {
  class group record;
  object member;
  if(undefinedp(groups[g_name]))
    return 0;
  tidy_members(g_name);
  record = (class group)groups[g_name];
  if(sizeof(record->members) >= MAX_GROUP_SIZE)
    return 1;
  return 0;
}
int query_locked(string g_name) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = (class group)groups[g_name];
  return (record->locked);
}
int set_locked(string g_name, int lock) {
  class group record;
  if(undefinedp(groups[g_name]))
    return 0;
  record = (class group)groups[g_name];
  record->locked = lock;
  return 1;
}
string *list_groups() {
  string frog;
  foreach (frog in keys(groups)) {
    check_group(frog);
  }
  return keys(groups);
}
private void disband_group(string g_name, string p_name) {
  class group record;
  object person;
  object member;
  record = (class group)groups[g_name];
  foreach(member in record->members) {
    if(!member)
      break;
    map_delete(members, member->query_name());
    foreach(person in member->query_protectors())
      member->remove_protector(person);
    foreach(person in member->query_followers())
      member->remove_follower(person);
    tell_object(member, p_name+" has left the game and so the "+g_name+
                " has been disbanded.\n");
  }
  map_delete(groups, g_name);
}
private void check_group(string g_name) {
  class group record;
  record = (class group)groups[g_name];
  if (record->leader == 0) {
    disband_group(g_name, "Your leader");
  } else {
    record->members -= ({ 0 });
  }
}
private void tidy_members(string g_name) {
  class group record;
  object member;
  record = (class group)groups[g_name];
  foreach(member in record->members)
    if(!member)
      record->members -= ({ 0 });
}

==================================================
FILE: handlers/term.c
==================================================

#define ANSI(p) sprintf("%c["+(p)+"m", 27)
#define ESC(p) sprintf("%c"+(p), 27)
#define CHAR(p) sprintf("%c", (p))
#define TERMINAL_DUMB "dumb"
private nosave mapping aliases, terms;
void create() {
  aliases = ([ "xterm-debian" : "xterm",
               "zmud" : "vt220",
               "amiga" : "vt220",
               "linux" : "vt220",
               "xterm-color" : "xterm",
               "vt102" : "vt100",
               "dec-vt100" : "vt100",
               "vt300" : "vt220",
               "vt100a" : "vt100",
               "vt100-ansi" : "vt100",
               "dec-vt220" : "vt220",
               "vt400" : "vt220",
               "vs100" : "xterm",
               "sun-cmd" : "vt220-nc",
               "unknown" : TERMINAL_DUMB,
               "ibm" : TERMINAL_DUMB,
               "iris-ansi-net" : "vt220",
               "network" : TERMINAL_DUMB,
               "vt320" : "vt220",
               "dtterm" : "vt220",
               "screen" : "vt220",
               "dec-vt320" : "vt220",
               "dec-vt100i" : "vt100",
               "ansii" : "ansi",
               "vt100i" : "vt100",
               "vt200-80" : "vt220",
               "ibm-3279-2-e" : TERMINAL_DUMB,
               "ibm-3279-2" : TERMINAL_DUMB,
               "vt200" : "vt220",
               "dec-vt200" : "vt220",
               "hft" : "vt220",
               "mac" : "vt220-nc",
               "vt340" : "vt220",
               "vt340-am" : "vt220",
               "ibm-3278-2" : TERMINAL_DUMB,
               "ibm-3278-2-e" : TERMINAL_DUMB,
               "kterm" : "xterm",
               "sun" : "vt220-nc",
               "sun1" : "vt220-nc",
               "xterms" : "xterm",
               "vs100s" : "xterm",
               "vt52" : TERMINAL_DUMB,
               "vt420" : "vt220",
               "dec-vt420" : "vt220",
               "aixterm-m" : "aixterm",
               "ibm-3151" : "ibm3151",
               "ibm-3278-5" : TERMINAL_DUMB,
               "du" : TERMINAL_DUMB,
               "dialup" : TERMINAL_DUMB,
               "dec-vt52" : TERMINAL_DUMB,
               "vt100-pro" : "vt100",
            ]);
  terms = ([ TERMINAL_DUMB : ([ "RESET" : "",
                         "BOLD" : "",
                         "FLASH" : "",
                         "BLACK" : "",
                         "RED" : "",
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "ORANGE" : "",
                         "YELLOW" : "",
                         "GREEN" : "",
                         "WHITE" : "",
                         "BLACK" : "",
                         "B_RED" : "",
                         "B_ORANGE" : "",
                         "B_YELLOW" : "",
                         "B_BLACK" : "",
                         "B_CYAN" : "",
                         "B_WHITE" : "",
                         "B_GREEN" : "",
                         "B_MAGENTA" : "",
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE": "",
                         "UNDERLINE": "",
                         "%" : "%^",
                         ]),
             "ansi" : ([ "RESET" : ANSI("39;49")+ANSI("0;10"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "ansi-no-flash" : ([ "RESET" : ANSI("39;49")+ANSI("0;10"),
                         "BOLD" : ANSI(1),
                         "FLASH" : "",
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "freedom" : ([ "RESET" : ESC("G0"),
                         "BOLD" : ESC("G@"),
                         "FLASH" : ESC("G2"),
                         "BLACK" : "",
                         "RED" : "",
                         "GREEN" : "",
                         "ORANGE" : "",
                         "YELLOW" : "",
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "BLACK" : "",
                         "WHITE" : "",
                         "B_RED" : ESC("GD"),
                         "B_GREEN" : ESC("GD"),
                         "B_ORANGE" : ESC("G4"),
                         "B_YELLOW" : ESC("G4"),
                         "B_BLUE" : ESC("G4"),
                         "B_CYAN" : ESC("GD"),
                         "B_BLACK" : ESC("GD"),
                         "B_WHITE" : ESC("G4"),
                         "B_MAGENTA" : ESC("G4"),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ESC("G4"),
                         "UNDERLINE" : ESC("G8"),
                         "%" : "%^",
                         ]),
             "ansi-status": ([
                         "RESET" : ANSI("39;49")+ANSI("0;10"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS" : ESC("[23;24r") + ESC(8),
                         "WINDOW" : ESC(7)+ESC("[0;22r")+ESC("[22H\n"),
                         "INITTERM" : ESC("[H")+ESC("[J")+
                                      ESC("[23;24r")+ESC("23H\n"),
                         "ENDTERM" : ESC("[0r")+ESC("[H")+ESC("[J"),
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "xterm": ([ "RESET" : ANSI("39;49")+ESC("[m"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "WINDOW" : "",
                         "INITTERM" : "",
                         "ENDTERM" : "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "vt100" : (["RESET" : ANSI("39;49")+ESC("[m")+CHAR(15),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "hpterm" : (["RESET" : ESC("&v0S")+ESC("&d@"),
                         "BOLD" : ESC("&dB"),
                         "FLASH" : "",
                         "BLACK" : "",
                         "RED" : ESC("&dB"),
                         "GREEN" : ESC("&dD"),
                         "ORANGE" : "",
                         "YELLOW" : ESC("&dB"),
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "WHITE" : "",
                         "B_RED" : "",
                         "B_GREEN" : "",
                         "B_ORANGE" : "",
                         "B_YELLOW" : "",
                         "B_BLUE" : "",
                         "B_CYAN" : "",
                         "B_BLACK" : "",
                         "B_WHITE" : "",
                         "B_MAGENTA" : "",
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ESC("&dB"),
                         "UNDERLINE" : ESC("&dD"),
                         "%" : "%^",
                         ]),
           "aixterm" : ([ "RESET" : ANSI("0;10")+ESC("(B"),
                         "BOLD" : ANSI(1),
                         "FLASH" : "",
                         "BLACK" : "",
                         "RED" : ANSI(1),
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "ORANGE" : "",
                         "YELLOW" : ESC('p'),
                         "GREEN" : ESC('W'),
                         "WHITE" : "",
                         "BLACK" : "",
                         "B_RED" : "",
                         "B_ORANGE" : "",
                         "B_YELLOW" : "",
                         "B_BLACK" : "",
                         "B_CYAN" : "",
                         "B_WHITE" : "",
                         "B_GREEN" : "",
                         "B_MAGENTA" : "",
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE": ESC('p'),
                         "UNDERLINE": ESC('W'),
                         "%" : "%^",
                         ]),
           "ibm3151" : ([ "RESET" : ESC("4@"),
                         "BOLD" : ESC("4H"),
                         "FLASH" : ESC("4D"),
                         "BLACK" : "",
                         "RED" : ESC("4H"),
                         "BLUE" : "",
                         "CYAN" : "",
                         "MAGENTA" : "",
                         "ORANGE" : "",
                         "YELLOW" : ESC("4A"),
                         "GREEN" : ESC("4B"),
                         "WHITE" : "",
                         "BLACK" : "",
                         "B_RED" : "",
                         "B_ORANGE" : "",
                         "B_YELLOW" : "",
                         "B_BLACK" : "",
                         "B_CYAN" : "",
                         "B_WHITE" : "",
                         "B_GREEN" : "",
                         "B_MAGENTA" : "",
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE": ESC("4A"),
                         "UNDERLINE": ESC("4B"),
                         "%" : "%^",
                         ]),
             "vt220": ([ "RESET" : ANSI("39;49")+ESC("[m"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI(31),
                         "GREEN" : ANSI(32),
                         "ORANGE" : ANSI(33),
                         "YELLOW" : ANSI("1;33"),
                         "BLUE" : ANSI(34),
                         "CYAN" : ANSI(36),
                         "MAGENTA" : ANSI(35),
                         "BLACK" : ANSI(30),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "WINDOW" : "",
                         "INITTERM" : "",
                         "ENDTERM" : "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "vt100-nc" : ([ "RESET" : ESC("[m")+CHAR(15),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI("37;7"),
                         "GREEN" : ANSI(1),
                         "ORANGE" : ANSI(37),
                         "YELLOW" : ANSI("1;4"),
                         "BLUE" : ANSI(37),
                         "CYAN" : ANSI(4),
                         "MAGENTA" : ANSI(37),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
             "vt220-nc" : ([ "RESET" : ESC("[m"),
                         "BOLD" : ANSI(1),
                         "FLASH" : ANSI(5),
                         "BLACK" : ANSI(30),
                         "RED" : ANSI("37;7"),
                         "GREEN" : ANSI(1),
                         "ORANGE" : ANSI(37),
                         "YELLOW" : ANSI("1;4"),
                         "BLUE" : ANSI(37),
                         "CYAN" : ANSI(4),
                         "MAGENTA" : ANSI("7;4"),
                         "WHITE" : ANSI(37),
                         "B_RED" : ANSI(41),
                         "B_GREEN" : ANSI(42),
                         "B_ORANGE" : ANSI(43),
                         "B_YELLOW" : ANSI("1;43"),
                         "B_BLUE" : ANSI(44),
                         "B_CYAN" : ANSI(46),
                         "B_BLACK" : ANSI(40),
                         "B_WHITE" : ANSI(47),
                         "B_MAGENTA" : ANSI(45),
                         "STATUS": "",
                         "WINDOW": "",
                         "INITTERM": "",
                         "ENDTERM": "",
                         "REVERSE" : ANSI(7),
                         "UNDERLINE" : ANSI(4),
                         "%" : "%^",
                         ]),
          ]);
}
mixed set_network_term_type(string str) {
  string type;
  str = lower_case(str);
  if (!terms[str] && !(type = aliases[str])) {
#ifdef DEBUG
    log_file("TERMTYPES", "No entry for \"%s\" (%s).\n", str,
             this_player()->query_name());
#endif
    return 0;
  }
  if (type) {
     return terms[type];
  }
  return terms[str];
}
mapping set_term_type(string str) {
  if (!terms[str] && !(str = aliases[str])) {
    efun::tell_object(this_player(), "No entry for "+str+", using dumb.\n");
    str = TERMINAL_DUMB;
  }
  return terms[str];
}
string *query_term_types() {
  return m_indices(terms);
}
string *query_colour_codes() {
   return keys(terms[TERMINAL_DUMB]);
}
