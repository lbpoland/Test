# Total Tokens: 13198
# Total Files Merged: 7
# Total Characters: 44014

=================================================

#include <bits_controller.h>
#include <weather.h>
inherit "/obj/food";
#define WARM 10
#define WARM_TIME 60
#define COOL_RATE_DEFAULT 10
private int _cool_level;
private int _cool_rate;
private int _purchase_time;
private mixed _hot_eat_message;
private mixed _cold_eat_message;
private mixed _hot_eat_piece_message;
private mixed _hot_eat_amt_message;
private mixed _hot_eat_last_message;
private mixed _cold_eat_piece_message;
private mixed _cold_eat_amt_message;
private mixed _cold_eat_last_message;
void create();
void set_cool_rate( int rate );
void set_cool_level(int level);
int query_cool_rate();
int query_cool_level();
protected void do_cool();
void set_hot_eat_mess(mixed messages);
void set_cold_eat_mess(mixed messages);
mixed query_hot_eat_mess();
mixed query_cold_eat_mess();
void setup_cold_eat_piece_messages(mixed piece, mixed amt, mixed last);
void setup_hot_eat_piece_messages(mixed piece, mixed amt, mixed last);
mixed query_hot_eat_amt_message;
mixed query_hot_eat_piece_message;
mixed query_hot_last_message;
mixed query_cold_eat_amt_message;
mixed query_cold_eat_piece_message;
mixed query_cold_last_message;
void create() {
   do_setup++;
   ::create();
   do_setup--;
   _cool_rate = COOL_RATE_DEFAULT;
   set_decay_speed( 1 );
   if ( !do_setup ) this_object()->setup();
   _cool_level = ( this_object()->query_weight() ) * 20;
   _purchase_time = time();
}
void set_cool_rate( int rate ) {
   _cool_rate = rate;
}
int query_cool_rate() {
   return _cool_rate;
}
int query_cool_level() {
   return _cool_level;
}
string query_short_rotten_adjective() {
   string ret;
   if (this_object()->query_cool_level() == 7){
       return ("cold " + ::query_short_rotten_adjective());
   }
   _cool_level = (time() - _purchase_time)/_cool_rate;
   ret = "";
   switch ( _cool_level ) {
     case 0..1:
        ret="piping hot " + ret;
        break;
     case 2:
        ret = "slightly cooled " + ret;
        break;
     case 3:
        ret = "partially cooled " + ret;
        break;
     case 4:
        ret = "half cooled " + ret;
        break;
     case 5:
        ret = "mostly cooled " + ret;
        break;
     case 6:
        ret = "almost completely cooled " + ret;
        break;
     default:
        ret ="stone cold " + ret;
        break;
        }
   return ret;
}
string query_long_decay_level() {
   string ret;
   int flag;
   if(query_collective() && query_amount() > 1 ) flag = 1;
   if (this_object()->query_cool_level() == 7){
       return ("It is stone cold. " + ::query_long_decay_level());
   }
   ret = "";
  _cool_level = (time() - _purchase_time)/_cool_rate;
   switch ( _cool_level) {
     case 0..1:
          ret += (flag?
          "They have not yet begun to cool.\n":
          "It has not yet begun to cool.\n");
        break;
     case 2:
           ret += (flag?
           "They have cooled slightly.\n":
           "It has cooled slightly.\n");
        break;
     case 3:
           ret += (flag?
           "They have partially cooled.\n":
           "It has partially cooled.\n");
        break;
     case 4:
           ret += (flag?
           "They are half cooled.\n":
           "It is half cooled.\n");
        break;
     case 5:
           ret += (flag?
           "They have mostly cooled.\n":
           "It has mostly cooled.\n");
        break;
     case 6:
           ret += (flag?
           "They are almost completely cold.\n":
           "It is almost completely cold.\n");
        break;
     default:
           ret += (flag?
           "They are stone cold.\n":
           "It is stone cold.\n");
        break;
        }
    return ret;
}
varargs int do_eat( int no_mess ) {
  int current_warmth;
  int remaining_time;
  int new_warmth;
  int new_time;
  if(this_object()->query_cool_level() >= 7 ){
    if (this_object()->query_weight_per_bite()){
      setup_eat_piece_messages(this_object()->query_cold_eat_piece_message(),
                               this_object()->query_cold_eat_amt_message(),
                               this_object()->query_cold_eat_last_message());
      }
    else {
      set_eat_mess( this_object()->query_cold_eat_message() );
      }
     return( ::do_eat( no_mess ));
  }
  if(this_player()->query_property("warmth")){
    current_warmth = this_player() -> query_property("warmth");
    remaining_time = this_player() -> query_property_time_left("warmth");
    new_warmth = current_warmth+WARM;
    new_time = (remaining_time + WARM_TIME)*0.75;
    this_player()->add_property( "warmth",new_warmth,new_time);
    }
  else{
     this_player()->add_property("warmth",WARM,WARM_TIME);
     }
  if(this_object()->query_weight_per_bite()){
    setup_eat_piece_messages(this_object()->query_hot_eat_piece_message(),
                                 this_object()->query_hot_eat_amt_message(),
                                 this_object()->query_hot_eat_last_message());
      }
  else{
    set_eat_mess( this_object()->query_hot_eat_message() );
    }
  return( ::do_eat( no_mess ) );
}
void set_hot_eat_message(mixed messages){
   _hot_eat_message = messages;
}
void set_cold_eat_message(mixed messages){
   _cold_eat_message = messages;
}
mixed query_hot_eat_message(){
  return _hot_eat_message;
}
mixed query_cold_eat_message(){
  return _cold_eat_message;
}
void setup_hot_eat_piece_messages(mixed piece, mixed amt, mixed last) {
   _hot_eat_piece_message = piece;
   _hot_eat_amt_message = amt;
   _hot_eat_last_message = last;
}
void setup_cold_eat_piece_messages(mixed piece, mixed amt, mixed last) {
   _cold_eat_piece_message = piece;
   _cold_eat_amt_message = amt;
   _cold_eat_last_message = last;
}
mixed query_cold_eat_piece_message(){
  return _cold_eat_piece_message;
}
mixed query_cold_eat_amt_message(){
  return _cold_eat_amt_message;
}
mixed query_cold_eat_last_message(){
  return _cold_eat_last_message;
}
mixed query_hot_eat_piece_message(){
  return _hot_eat_piece_message;
}
mixed query_hot_eat_amt_message(){
  return _hot_eat_amt_message;
}
mixed query_hot_eat_last_message(){
  return _hot_eat_last_message;
}
mixed *stats(){
   mixed *args;
   args =::stats() + ({ ({ "cool level", _cool_level }),
                        ({ "cool rate", _cool_rate }),
                        ({ "purchase time", _purchase_time }) });
   return args;
}
mapping int_query_static_auto_load(){
   return ([ "::" : ::int_query_static_auto_load(),
             "cool_level" : _cool_level,
             "cool rate" : _cool_rate,
             "purchase time" : _purchase_time ]);
}
mapping query_static_auto_load(){
   if ( ( base_name( this_object() ) != "/obj/food" )
       && !query_continuous() ) {
      return 0;
   }
   return int_query_static_auto_load();
}
void init_static_arg( mapping map ){
   if ( !mapp( map ) ) return;
   if ( map[ "::" ] ) ::init_static_arg( map[ "::" ] );
   _cool_level = map[ "cool_level" ];
   _cool_rate = map[ "cool rate" ];
   _purchase_time = map [ "purchase time" ];
}
mapping query_dynamic_auto_load(){
   return ([ "::" : ::query_dynamic_auto_load(),
             "cool_level" : _cool_level,
             "cool rate" : _cool_rate,
             "purchase time" : _purchase_time ]);
}
void init_dynamic_arg( mapping map, object ){
   if ( !mapp( map ) ) return;
   if ( map[ "::" ] ) ::init_dynamic_arg( map[ "::" ] );
   _cool_level = map[ "cool_level" ];
   _cool_rate = map[ "cool rate" ];
   _purchase_time = map [ "purchase time" ];
}
void do_decay() {
   if (this_object()->query_cool_level()>1) return;
   ::do_decay();
}
int query_decays() {
   if (this_object()->query_cool_level()>1) return 0;
   return 1;
}
int query_decay_speed() {
   if (this_object()->query_cool_level()>1) return 0;
   return (::query_decay_speed());
}
int query_decay_level() {
   if (this_object()->query_cool_level()>1) return 0;
   return (::query_decay_level());
}
void set_decay_speed( int decay ) {
  if (this_object()->query_cool_level()>1) return( ::set_decay_speed( 0 ) );
  return( ::set_decay_speed( 7200 ) );
}
void set_main_plural(mixed str) {
   return;
}

==================================================
FILE: implement.c
==================================================

inherit "/std/object";
inherit "/std/basic/holdable";
#include "money.h"
#include <move_failures.h>
#include <virtual.h>
string *un_modifyable;
mixed *wield_func;
void create() {
   holdable::create();
   object::create();
   add_alias("implement");
   add_alias("utensil");
   add_plural("implements");
   if (!query_property("shop type")) {
      add_property("shop type", "general");
   }
}
varargs int move( mixed dest, string messin, string messout ) {
   int ret;
   int limb;
   object holder;
   limb = query_my_limb();
   holder = query_holder();
   ret = holdable::move(dest);
   if (ret != MOVE_OK) {
      return ret;
   }
   ret = object::move( dest, messin, messout );
   if (ret != MOVE_OK && holder) {
      holder->set_hold(this_object(), limb);
   }
   return ret;
}
void dest_me() {
  holdable::dest_me();
  object::dest_me();
}
void player_wield(int pos) {
  if (!environment()) {
    return;
  }
  this_object()->hold_item( environment(), pos );
}
mapping query_static_auto_load() {
   if ( base_name( this_object() ) == "/obj/implement" )
     return int_query_static_auto_load();
   return 0;
}
mapping int_query_static_auto_load() {
  mapping tmp;
  tmp = object::int_query_static_auto_load();
  return ([ "::" : tmp,
            "hold" : holdable::query_static_auto_load()
            ]);
}
mapping query_dynamic_auto_load() {
  mapping map;
  map = ([
          "::" : object::query_dynamic_auto_load(),
          "hold" : holdable::query_dynamic_auto_load(),
          ]);
  return map;
}
void init_static_arg( mapping map ) {
  if ( !mapp( map ) ) return ;
  if ( map[ "::" ] ) {
    object::init_static_arg( map[ "::" ] );
  }
  holdable::init_static_arg(map);
}
void init_dynamic_arg( mapping map, object ) {
   mapping stat_temp;
   string virt_name, new_name;
   if ( map[ "::" ] )
      object::init_dynamic_arg( map[ "::" ] );
   holdable::init_dynamic_arg(map["hold"], 1);
   if( virt_name = query_property( VIRTUAL_NAME_PROP) ) {
     if( file_size( virt_name ) == -1 ) {
       new_name = ( CLONER )->other_file( virt_name );
       if( stringp( new_name ) && ( new_name != virt_name ) ) {
         add_property( VIRTUAL_NAME_PROP, new_name );
         virt_name = new_name;
       } else {
         if( VIRTUAL_HANDLER->query_forbidden( virt_name ) ) {
           call_out( "replace_me", 1 );
         } else {
           VIRTUAL_HANDLER->add_missing( virt_name );
         }
       }
     }
     if( file_size( virt_name ) != -1 &&
         query_property( "virtual time" ) < stat( virt_name )[1] ) {
       stat_temp = ( VIRTUAL_HANDLER )->new_data( virt_name );
       if( mapp( stat_temp ) ) {
         init_static_arg( stat_temp );
         add_property( "virtual time", time() );
       }
     }
   }
}

==================================================
FILE: key.c
==================================================

inherit "std/object";
string type;
void set_type(string str) {
  remove_adjective(type);
  type = str;
  add_adjective(type);
  set_main_plural(type + " keys");
  set_short(type + " key");
}
string query_type() {
  return type;
}
void create() {
  ::create();
  set_name("key");
  set_main_plural("normal keys");
  add_plural("keys");
  type = "normal";
  set_short(query_type() + " key");
  set_long("A key.  Wonder where it fits?\n");
  set_weight(1);
  adjust_money(1, "brass");
}

==================================================
FILE: lantern.c
==================================================

#include <fuel_handler.h>
inherit "/std/object";
#define BRIGHTNESS      60
#define FUEL_PER_TICK  FUEL_TIME
#define MAX_FUEL 3600
int  fuel_left;
int  is_lit;
void create(){
  ::create();
}
string short( int i ) {
  if ( is_lit )
    return ::short( 0 ) + " (lit)";
  return ::short( 0 );
}
int do_extinguish() {
   if ( !is_lit ) {
      this_player()->add_failed_mess(this_object(), "$D is not lit.\n", ({ }));
      return 0;
   }
   FUEL_HANDLER->remove_burner( this_object() );
   is_lit = 0;
   set_light( 0 );
   return 1;
}
int do_dowse() {
   return do_extinguish();
}
int do_light() {
   if ( is_lit ) {
      this_player()->add_failed_mess( this_object(), "$D is already lit.\n",
                                     ({ }) );
      return 0;
   }
   if ( fuel_left <= 0 ) {
      this_player()->add_failed_mess( this_object(), "$D is out of fuel.\n",
                                     ({ }) );
      return 0;
   }
   FUEL_HANDLER->add_burner( this_object() );
   is_lit = 1;
   set_light( BRIGHTNESS );
   return 1;
}
void init() {
   this_player()->add_command("light", this_object());
   this_player()->add_command("extinguish", this_object());
   this_player()->add_command("dowse", this_object());
}
void out_of_fuel() {
   object env;
   is_lit    = 0;
   fuel_left = 0;
   env = environment( this_object() );
   FUEL_HANDLER->remove_burner( this_object() );
   set_light( 0 );
   if ( interactive( env ) ) {
      write( poss_short() +" burns out.\n" );
      tell_room( environment(env), poss_short() +" burns out.\n", env );
   } else
      say( poss_short() +" burns out.\n" );
}
void consume_fuel() {
   fuel_left -= FUEL_PER_TICK;
   switch ( fuel_left ) {
    case -10000 .. 0:
      out_of_fuel();
      break;
    default:
   }
}
string pretty_plural( object thing) {
  if ( is_lit )
    return ::pretty_plural(thing) + " (lit)";
  return ::pretty_plural(thing);
}
void dest_me() {
   set_light( 0 );
   FUEL_HANDLER->remove_burner( this_object() );
   ::dest_me();
}
mixed *stats() {
  return ::stats() + ({
    ({ "fuel" , fuel_left, }),
    ({ "is lit", is_lit, }),
   });
}
mapping query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "fuel left" : fuel_left,
             "is lit" : is_lit,
          ]);
}
void init_dynamic_arg( mapping arg ) {
   fuel_left = arg["fuel left"];
   if ( arg[ "is lit" ] ) {
      FUEL_HANDLER->add_burner( this_object() );
      is_lit = 1;
      set_light(BRIGHTNESS);
   }
   ::init_dynamic_arg( arg["::"] );
}
int query_fuel_left() {
    return fuel_left;
}
void set_fuel_left( int i ) {
    if ( i > MAX_FUEL ) {
        i = MAX_FUEL;
    }
    fuel_left = i;
}
int query_max_fuel() {
    return MAX_FUEL;
}

==================================================
FILE: meltable.c
==================================================

#include <bits_controller.h>
#include <weather.h>
inherit "/obj/food";
#define CHILL -5
#define CHILL_TIME 10
#define MELT_RATE_DEFAULT 6
#define WATER "/obj/food/beverages/water.food"
#define _LOOKUP_RATE ({ 60, 57, 54, 51, 48, 42, 36, 30, 27, 24, \
                        20, 18, 16, 14, 12, 10,  9,  8,  7,  6, \
                         6,  6,  6,  5,  5,  5,  4,  4,  4,  3, \
                         3,  3,  3,  3,  3,  3,  3,  3,  3,  2, \
                         2,  2,  2,  2,  2,  2,  2,  2,  2,  1  })
private int _melt_level;
private int _original_melt_level;
private int _melt_rate;
private int _melt_counter;
private int _callout_id;
private string _melt_result;
void create();
void set_melt_result( string result );
string query_melt_result();
void set_melt_rate( int rate );
int query_melt_rate();
int query_melt_level();
private void setup_callout();
protected void do_melt();
void create() {
   do_setup++;
   ::create();
   do_setup--;
   _melt_rate = MELT_RATE_DEFAULT;
   _melt_counter = 0;
   set_melt_result( WATER );
   set_decay_speed( 1 );
   setup_callout();
   if ( !do_setup ) {
      this_object()->setup();
   }
   _melt_level = ( this_object()->query_weight() ) * 10;
   _original_melt_level = _melt_level;
}
void set_melt_result( string result ) {
   _melt_result = result;
}
string query_melt_result() {
   return _melt_result;
}
void set_melt_rate( int rate ) {
   _melt_rate = rate;
}
int query_melt_rate() {
   return _melt_rate;
}
int query_melt_level() {
   return _melt_level;
}
private void setup_callout() {
   if( _callout_id ) {
      remove_call_out( _callout_id );
   }
   _callout_id = call_out( "do_melt", _melt_rate );
}
protected void do_melt() {
   object liquid;
   object room, ob;
   int environment_temp, current_weight;
   ob = environment( this_object() );
   if( !ob ) {
      return;
   }
   room = ob;
   while( ob = environment( ob ) ) {
      room = ob;
   }
   if( room->query_property( "location" ) == "outside" ) {
      environment_temp = WEATHER->query_temperature( room );
   }
   else if( room->query_name() == "clone_on_demand-store" ) {
      environment_temp = 0;
   }
   else {
      environment_temp = 20 + room->query_property( "warmth" );
   }
   if( environment_temp > 1 ) {
      if( environment_temp > 50 ) {
         _melt_rate = 1;
      }
      else {
         _melt_rate = _LOOKUP_RATE[ environment_temp ];
      }
      _melt_level = _melt_level - 1;
      _melt_counter = _melt_counter + 1;
      if ( _melt_counter >= 10 ) {
         liquid = clone_object( _melt_result );
         liquid->set_amount( 20 );
         liquid->move( environment( this_object() ) );
         current_weight = this_object()->query_weight();
         if( current_weight <= 1 ) {
            this_object()->move( "/room/rubbish" );
         }
         else {
            this_object()->set_weight( current_weight - 1 );
         }
         _melt_counter = 0;
      }
   }
   _callout_id = call_out( "do_melt", _melt_rate );
}
string query_short_rotten_adjective() {
   string ret;
   int bing;
   bing = 100 - ( ( 100 * _melt_level ) / _original_melt_level );
   ret = "";
   switch ( bing ) {
   case 0..1:
      break;
   case 2..20:
      ret = "slightly melted " + ret;
      break;
   case 21..45:
      ret = "partially melted " + ret;
      break;
   case 46..55:
      ret = "half melted " + ret;
      break;
   case 56..80:
      ret = "mostly melted " + ret;
      break;
   case 81..100:
      ret = "almost completely melted " + ret;
      break;
   }
   return ret;
}
string query_long_decay_level() {
   string ret;
   int bing;
   bing = 100 - ( ( 100 * _melt_level ) / _original_melt_level );
   ret = "";
   switch ( bing ) {
   case 0..1:
     if( query_collective() && query_amount() > 1 )
        ret += "They have not yet begun to melt.\n";
     else
        ret += "It has not yet begun to melt.\n";
     break;
   case 2..20:
      if( query_collective() && query_amount() > 1 )
         ret += "They have melted slightly.\n";
      else
         ret += "It has melted slightly.\n";
      break;
   case 21..45:
      if( query_collective() && query_amount() > 1 )
         ret += "They have partially melted away.\n";
      else
         ret += "It has partially melted away.\n";
      break;
   case 46..55:
      if( query_collective() && query_amount() > 1 )
         ret += "They are half melted away.\n";
      else
         ret += "It is half melted away.\n";
      break;
   case 56..80:
      if( query_collective() && query_amount() > 1 )
         ret += "They have mostly melted away.\n";
      else
         ret += "It has mostly melted away.\n";
      break;
   case 81..100:
      if( query_collective() && query_amount() > 1 )
         ret += "They have almost complete melted away.\n";
      else
         ret += "It has almost completely melted away.\n";
      break;
   }
    return ret;
}
varargs int do_eat( int no_mess ) {
   this_player()->add_property( "warmth", CHILL, CHILL_TIME );
   return( ::do_eat( no_mess ) );
}
int do_apply( object * things ) {
   int i;
   if( i = ::do_apply( things ) ) {
      things[ 0 ]->add_property( "warmth", CHILL, CHILL_TIME );
   }
   return i;
}
int do_rub( object * things ) {
   int i;
   if( i = ::do_rub( things ) ) {
      things[ 0 ]->add_property( "warmth", CHILL, CHILL_TIME );
   }
   return i;
}
mixed *stats()
{
   mixed *args;
   args =::stats() + ({ ({ "melt level", _melt_level }),
                        ({ "melt result", _melt_result }),
                        ({ "original melt level", _original_melt_level }),
                        ({ "melt rate", _melt_rate }),
                        ({ "melt counter", _melt_counter }),
                        ({ "callout id", _callout_id }) });
   return args;
}
mapping int_query_static_auto_load() {
   return ([ "::" : ::int_query_static_auto_load(),
             "melt_level" : _melt_level,
             "melt_result" : _melt_result,
             "original melt level" : _original_melt_level,
             "melt rate" : _melt_rate,
             "melt counter" : _melt_counter,
             "callout id" : _callout_id ]);
}
mapping query_static_auto_load()
{
   if ( ( base_name( this_object() ) != "/obj/food" )
       && !query_continuous() ) {
      return 0;
   }
   return int_query_static_auto_load();
}
void init_static_arg( mapping map )
{
   if ( !mapp( map ) ) {
      return;
   }
   if ( map[ "::" ] ) {
      ::init_static_arg( map[ "::" ] );
   }
   _melt_level = map[ "melt_level" ];
   _melt_result = map[ "melt_result" ];
   _original_melt_level = map[ "original melt level" ];
   _melt_rate = map[ "melt rate" ];
   _melt_counter = map[ "melt counter" ];
   _callout_id = map[ "callout id" ];
}
mapping query_dynamic_auto_load()
{
   return ([ "::" : ::query_dynamic_auto_load(),
             "melt_level" : _melt_level,
             "melt_result" : _melt_result,
             "original melt level" : _original_melt_level,
             "melt rate" : _melt_rate,
             "melt counter" : _melt_counter,
             "callout id" : _callout_id ]);
}
void init_dynamic_arg( mapping map, object )
{
   if ( !mapp( map ) ) {
      return;
   }
   if ( map[ "::" ] ) {
      ::init_dynamic_arg( map[ "::" ] );
   }
   _melt_level = map[ "melt_level" ];
   _melt_result = map[ "melt_result" ];
   _original_melt_level = map[ "original melt level" ];
   _melt_rate = map[ "melt rate" ];
   _melt_counter = map[ "melt counter" ];
   _callout_id = map[ "callout id" ];
}
int query_liquid() {
   return 0;
}
void set_liquid() {
}
void do_decay() {
   return;
}
int query_decays() {
   return 0;
}
int query_decay_speed() {
   return 0;
}
int query_decay_level() {
   return 0;
}
void set_decay_speed( int decay ) {
  return( ::set_decay_speed( 1 ) );
}
int do_cure() {
   return 0;
}
int query_cured() {
   return 0;
}
int do_dry() {
   return 0;
}
int query_dried() {
   return 0;
}
int query_rotten() {
   return 0;
}
void set_splashable() {
   return;
}

==================================================
FILE: mineral.c
==================================================

#include <mineral.h>
#define HANDLER "/obj/handlers/cmr_handler"
#define PRICE_INDEX "/obj/handlers/cpi_handler"
#define DEFAULT_MARKET "Ankh-Morpork"
inherit "/obj/food";
nosave string mineral;
void create() {
   ::create();
   set_decay_speed(0);
   remove_help_file("food");
   add_help_file("mineral");
}
varargs void make_mineral( string word, int number, string *inputs ) {
   string adjective, material_adjective, noun, *args;
   mineral = word;
   set_value_info( "material", 1 );
   material_adjective = (string)HANDLER->query_material_adjective( mineral );
   set_weight( number );
   switch( number ) {
      case 0 .. PEBBLE :
         adjective = "small";
         noun = "pebble";
         break;
      case PEBBLE + 1 .. STONE :
         adjective = "medium sized";
         noun = "stone";
         break;
      case STONE + 1 .. ROCK :
         adjective = "large";
         noun = "rock";
         break;
      default:
         adjective = "huge";
         noun = "boulder";
   }
   if ( !pointerp( inputs ) )
      args = allocate( 10 );
   else
      args = inputs + ({ 0, 0, 0, 0, 0 });
   if ( !args[ 0 ] ) {
      set_name( noun );
      add_plural( noun +"s" );
   } else {
      set_name( args[ 0 ] );
      if ( !args[ 3 ] )
         add_plural( pluralize( args[ 0 ] ) );
      else
         add_plural( args[ 3 ] );
   }
   if ( !args[ 1 ] ) {
      set_short(material_adjective +" "+ noun);
      set_main_plural(material_adjective +" "+ pluralize( noun ));
   } else {
      set_short( args[ 1 ] );
      if ( !args[ 4 ] )
         set_main_plural( pluralize( args[ 1 ] ) );
      else
         set_main_plural( args[ 4 ] );
   }
   if ( !args[ 2 ] )
      set_long( "This is "+ add_a( adjective ) +" lump of $mineral$.\n" );
   else
      set_long( args[ 2 ] );
   add_adjective( ({ adjective }) + explode( material_adjective, " " ) );
}
string long( string words, int dark ) {
   return replace( ::long( words, dark ), "$mineral$",
         (string)HANDLER->identify_material( mineral, this_player(), 1 ) );
}
string *parse_command_adjectiv_id_list() {
   return explode( (string)HANDLER->identify_material( mineral,
         this_player(), 0 ), " " ) + ::parse_command_adjectiv_id_list();
}
string query_mineral() { return mineral; }
string query_material() { return mineral; }
void init() {
   ::init();
   this_player()->add_command( "pulverise", this_object(),
         "<direct:object> {with|using} <indirect:object>" );
   this_player()->add_command( "chip", this_object(),
         "<direct:object> {with|using} <indirect:object>" );
   this_player()->add_command( "smash", this_object(),
         "<direct:object> {with|using} <indirect:object>" );
   this_player()->add_command( "sprinkle", this_object(),
         "<direct:object:me> [on] <indirect:object>" );
   this_player()->add_command( "sprinkle", this_object(),
         "<direct:object:me>" );
}
int do_eat() {
   if ( (string)this_player()->query_race_ob() != "/std/races/troll" ) {
      this_player()->add_failed_mess( this_object(),
            "What do you think you are, a troll?\n", ({ }) );
      return 0;
   }
   return ::do_eat();
}
int check_tool( object *tools, string *needed ) {
   string word;
   if ( sizeof( tools ) > 1 ) {
      write( "You only need to use one tool at a time.\n" );
      return 0;
   }
   if ( !sizeof( tools ) ) {
      write( "You need to use a tool of some sort.\n" );
      return 0;
   }
   if ( member_array( tools[ 0 ],
         (object *)this_player()->query_holding() ) == -1 ) {
      write( "You need to use a tool that you are holding.\n" );
      return 0;
   }
   foreach ( word in needed ) {
      if ( tools[ 0 ]->id( word ) )
         return 1;
   }
   write( "You need to use a tool appropriate to the job.\n" );
   return 0;
}
int do_pulverise( object *tools ) {
   string material_adjective;
   if ( !check_tool( tools, ({ "hammer" }) ) )
      return 0;
   if ( query_continuous() ) {
      write( "The "+ (string)HANDLER->identify_material( mineral,
            this_player(), 0 ) +" has already been pulverised.\n" );
      return 0;
   }
   if ( query_weight() > PEBBLE ) {
      write( "This piece of "+ (string)HANDLER->identify_material( mineral,
            this_player(), 0 ) +" is too large to pulverise.\n" );
      return 0;
   }
   material_adjective = (string)HANDLER->query_material_adjective( mineral );
   set_name("powder");
   set_short(material_adjective +" powder");
   set_main_plural(material_adjective +" powder" );
   add_plural( "powder" );
   add_property( "determinate", "some " );
   add_adjective( ({ "some", "pinch", "pinches", "handful",
         "handfuls", "of" }) );
   set_long( "This is $pile_size$ of "+ material_adjective +
         " powder, $amount_size$.\n" );
   set_weight_unit( ({ 1, 50 }) );
   set_medium_alias( "Powdered" + capitalize(mineral) );
   set_amount_types( ([ "pinch": ({ 1, "pinches" }),
         "handful": ({ 50, "handfuls" }) ]) );
   set_pile_types( ({ 50, "small", 100, "medium", "large" }) );
   set_continuous();
   set_amount( roll_MdN( 5, 10 ) * query_weight() );
   remove_property("encoded destination");
   move( environment() );
   this_player()->add_succeeded( tools[ 0 ] );
   return 1;
}
int do_chip( object *tools ) {
   object chip;
   if ( query_continuous() )
      return 0;
   if ( !check_tool( tools, ({ "pick", "pickaxe", "hammer" }) ) )
      return 0;
   if ( query_weight() == 1 ) {
      write( "This piece of "+ (string)HANDLER->identify_material( mineral,
            this_player(), 0 ) +" is already a chip.\n" );
      return 0;
   }
   set_weight( query_weight() - 1 );
   chip = clone_object( MINERAL );
   chip->make_mineral( mineral, 1 );
   chip->move( environment() );
   this_player()->add_succeeded( tools[ 0 ] );
   return 1;
}
int do_smash( object *tools ) {
   int i, j, largest, number, size;
   object debris, remains;
   if ( query_continuous() )
      return 0;
   if ( !check_tool( tools, ({ "pick", "pickaxe" }) ) )
      return 0;
   if ( query_weight() < ROCK / 2 ) {
      write( "This piece of "+ (string)HANDLER->identify_material( mineral,
            this_player(), 0 ) +" is too small to smash.\n" );
      return 0;
   }
   largest = this_player()->query_max_weight();
   if ( largest >= query_weight() )
      largest = query_weight();
   else {
      remains = clone_object( MINERAL );
      remains->make_mineral( mineral, query_weight() - largest );
      remains->move( environment() );
   }
   tools[ 0 ]->hit_weapon( largest, "blunt" );
   number = 2 + random( 4 );
   for ( i = 0; i < 8; i++ ) {
      largest /= number;
      for ( j = 1; j < number; j++ ) {
         size = ( 3 * largest + random( largest ) ) / 4;
         if ( size ) {
            debris = clone_object( MINERAL );
            debris->make_mineral( mineral, size );
            debris->move( environment() );
          }
       }
   }
   this_player()->add_succeeded( tools[0] );
   move( "/room/rubbish" );
   return 1;
}
int do_sprinkle(object *obs) {
    if (!query_continuous())
      return notify_fail(
        "You should pulverise the stuff before you sprinkle it.\n");
   if (!sizeof(obs)) {
     obs=({ environment(this_player()) });
     this_player()->add_succeeded_mess(this_object(),
       "$N $V $D everywhere.\n",({ }));
   } else {
     this_player()->add_succeeded_mess(this_object(),
       "$N $V $D on $I.\n",({ obs[0] }));
   }
   obs[0]->add_effect("/std/effects/other/powdered",
                      (string)HANDLER->query_material_adjective( mineral ) +
                      " powder" );
   call_out("move",0,"/room/rubbish");
   return 1;
}
mixed *stats() {
   return ::stats() + ({
      ({ "mineral", mineral, }),
   });
}
mapping int_query_static_auto_load() {
   return ([
      "::" : ::int_query_static_auto_load(),
      "mineral" : mineral,
   ]);
}
void init_static_arg( mapping map ) {
   if ( map[ "::" ] )
      ::init_static_arg( map[ "::" ] );
   if ( !undefinedp( map[ "mineral" ] ) )
      mineral = map[ "mineral" ];
   set_decay_speed(0);
}
mapping query_static_auto_load() {
   if ( ( explode( file_name( this_object() ), "#" )[ 0 ] == "/obj/mineral" )
         || query_continuous() )
      return int_query_static_auto_load();
   return ([ ]);
}
void set_decay_level( int level ) {
   ::set_decay_level( 0 );
   return;
}

==================================================
FILE: money.c
==================================================

#include <money.h>
#include <move_failures.h>
#include <obj_parser.h>
#define COIN_WEIGHT 10
#define DEF_VALUE 1
#define USE_VAULT DEF_VALUE
inherit "/std/object";
private nosave int no_join;
private nosave int _already_joined;
private mixed *money_array;
private nosave string _long;
int query_value_in(string where);
void create() {
   ::create();
   set_name( "coin" );
   add_alias( MONEY_ALIAS );
   add_plural( "coins" );
   set_main_plural( "coins" );
   add_property( "determinate", "" );
   add_property( "no one", 1 );
   add_property( "money", 1 );
   money_array = ({ });
}
int query_collective() { return 1; }
mapping query_dynamic_auto_load() {
   if (!_already_joined) {
      return ([
         "::" : ::query_dynamic_auto_load(),
         "money array" : money_array,
      ]);
   }
   add_alias(MONEY_ALIAS);
}
void init_dynamic_arg( mapping map, object ) {
   ::init_dynamic_arg( map[ "::" ] );
   money_array = map[ "money array" ];
   if (sizeof(money_array) < 2)  call_out("dest_me", 0);
   short_d = _long = 0;
   if ( find_call_out( "check_adjectives" ) == -1 ) {
      call_out( "check_adjectives", 0 );
   }
}
int query_merger() { return 1; }
int query_no_join() { return no_join; }
int query_already_joined() { return _already_joined; }
void reset_already_joined() { _already_joined = 0; }
void set_already_joined() { _already_joined = 1; }
void set_no_join() {
#ifdef DEBUGGER
   if (find_player(DEBUGGER) == this_player())
      tell_creator(DEBUGGER, "Called set_no_join\n");
#endif
   no_join = 1;
   call_out( "merge_coins", 0 );
}
void force_no_join()  { no_join = 1; }
void reset_no_join() { no_join = 0; }
int query_number_coins() {
   int i;
   int tot;
   if (_already_joined) {
      return 0;
   }
   for ( i = 1; i < sizeof( money_array ); i += 2 ) {
      tot += money_array[ i ];
   }
   return tot;
}
void fixup_money_weight() {
   set_weight( 1 + query_number_coins() / COIN_WEIGHT );
}
int group_object() { return ( query_number_coins() > 1 ); }
void check_adjectives() {
   int i;
   string* bits;
   set_adjectives( ({ }) );
   set_aliases( ({ }) );
   set_plurals( ({ }) );
   if ( !sizeof( money_array )) {
     if(file_name(environment()) != MONEY_VAULT) {
       _already_joined = 0;
#ifdef DEBUGGER
      if (find_player(DEBUGGER) == this_player())
          tell_creator(DEBUGGER, "MOVING %O to rubbish room\n", this_object());
#endif
#ifdef USE_VAULT
       MONEY_VAULT->add_to_list(this_object());
#else
       move("/room/rubbish");
#endif
     }
     return;
   }
   add_alias( MONEY_ALIAS );
   add_plural( "coins" );
   add_plural("money");
   for ( i = 0; i < sizeof( money_array ); i += 2 ) {
      bits = explode(lower_case(money_array[ i ]), " ");
      if (sizeof(bits) > 1) {
         add_adjective(bits[0..<2] );
      } else {
         add_adjective(bits);
      }
      if (MONEY_HAND->query_origin_of(money_array[i]) == "default")
         add_adjective(({ "provincial", "default" }));
      add_alias(MONEY_HAND->query_aliases_for(money_array[i]));
      add_adjective(MONEY_HAND->query_adjectives_for(money_array[i]));
      add_plural( (string)MONEY_HAND->query_plural_for( money_array[ i ] ) );
   }
   fixup_money_weight();
}
mixed *query_money_array() {
   if (!_already_joined) {
      return money_array;
   }
   return ({ });
}
varargs int adjust_money( mixed amount, string type ) {
   int i;
   int ret;
   if ( pointerp( amount ) ) {
      for ( i = 0; i < sizeof( amount ); i += 2 ) {
         adjust_money( amount[ i + 1 ], amount[ i ] );
      }
      fixup_money_weight();
      return 1;
   }
   if ( !stringp( type ) || !intp( amount ) || _already_joined) {
      return 0;
   }
   short_d = _long = 0;
   if ( ( i = member_array( type, money_array ) ) == -1 ) {
      money_array += ({ type, amount });
      ret = 1;
   } else {
      money_array[ i + 1 ] += amount;
      if ( money_array[ i + 1 ] <= 0 ) {
         money_array = delete( money_array, i, 2 );
         ret = 0;
      } else {
         ret = 1;
      }
   }
   if ( find_call_out( "check_adjectives" ) == -1 ) {
      call_out( "check_adjectives", 0 );
   }
   fixup_money_weight();
   if (ret) {
      return money_array[ i + 1 ];
   }
   return 0;
}
void set_money_array( mixed *new_array ) {
   short_d = _long = 0;
   money_array = new_array;
   if ( find_call_out( "check_adjectives" ) == -1 ) {
      call_out( "check_adjectives", 0 );
   }
   fixup_money_weight();
}
string *half_symbol_short()  {
   int i;
   int value;
   string *retval;
   string *zones = ({ });
   for (i = 0; i < sizeof(money_array); i += 2)
      zones |= ({ MONEY_HAND->query_origin_of(money_array[i]) });
   retval = allocate(sizeof(zones));
   for (i = 0; i < sizeof(zones); i++)  {
      value = query_value_in(zones[i]);
      retval[i] = MONEY_HAND->money_value_string(value, zones[i]);
   }
   return retval;
}
string *half_short( int full ) {
   int i;
   string *retval;
   retval = ({ });
   for ( i = 0; i < sizeof( money_array ); i += 2 ) {
      if ( money_array[ i + 1 ] < 1 ) {
         continue;
      }
      if ( !full && ( money_array[ i + 1 ] > 12 ) ) {
         retval += ({ "some "+ (string)MONEY_HAND->query_main_plural_for(
               money_array[ i ] ) });
         continue;
      }
      if ( money_array[ i + 1 ] == 1 ) {
         retval += ({ "one "+
               (string)MONEY_HAND->query_short_for( money_array[ i ] ) });
         continue;
      }
      retval += ({ money_array[ i + 1 ] +" "+
            (string)MONEY_HAND->query_main_plural_for( money_array[ i ] ) });
   }
   return retval;
}
string short( int dark ) {
   string *retval;
   if ( short_d ) {
      return short_d;
   }
   retval = half_short( 0 );
   if ( !sizeof( retval ) ) {
      return 0;
   }
   if ( sizeof( retval ) == 1 ) {
      short_d = retval[ 0 ];
   } else {
      short_d = query_multiple_short( retval );
   }
   return short_d;
}
string long( string word, int dark ) {
   int i;
   mixed *details;
   if (dark < -1 || dark > 1) {
      return "It is too dark to see anything about the coins.\n";
   }
   if ( _long ) {
      return _long;
   }
   if ( !sizeof( money_array ) ) {
      return "This is some money that isn't money.\n";
   }
   _long = "";
   for ( i = 0; i < sizeof( money_array ); i += 2 ) {
      details = (mixed *)MONEY_HAND->query_details_for( money_array[ i ] );
      if ( money_array[ i + 1 ] == 1 ) {
         _long += "The "+ (string)MONEY_HAND->query_short_for(
               money_array[ i ] ) +" shows ";
      } else {
         _long += "The "+ (string)MONEY_HAND->query_main_plural_for(
               money_array[ i ] ) +" show ";
      }
      _long += details[ 2 ] +" on the reverse, and "+ details[ 3 ] +
            " on the obverse.\n";
   }
   return _long;
}
string query_long_details( string word, int dark, object looker) {
   if (dark < -1 || dark > 1) {
      return "It is too dark to see anything about the coins.\n";
   }
   return long(word, dark);
}
object new_money_object(mixed number, string type) {
   int i;
   object money;
   object env;
   object per;
#ifdef DEBUGGER
   if (find_player(DEBUGGER) == this_player())
      tell_creator(DEBUGGER, "Creating new money object from %O\n", this_object());
#endif
   if (!sizeof(money_array) || _already_joined) {
      return 0;
   }
   if (pointerp(number))  {
#ifdef USE_VAULT
      money = MONEY_VAULT->get_money_ob();
#else
      money = clone_object(MONEY_OBJECT);
#endif
      money->set_no_join();
      money->adjust_money(number);
      for (i = 1; i < sizeof(number); i += 2)
         number[i] = -number[i];
      adjust_money(number);
   }
   else  {
      if (!type || type == "") {
         return 0;
      }
      if ((i = member_array(type, money_array)) == -1) {
         return 0;
      }
      if (number > money_array[i + 1]) {
         return 0;
      }
#ifdef USE_VAULT
      money = MONEY_VAULT->get_money_ob();
#else
      money = clone_object(MONEY_OBJECT);
#endif
      money->set_no_join();
      money->adjust_money(number, type);
      adjust_money(-number, type);
   }
   if (money->move(environment()) != MOVE_OK) {
      env = environment();
      do {
        env = environment(env);
      } while (env && money->move(env) != MOVE_OK);
      per = environment();
      while (per && !living(per)) {
         per = environment(per);
      }
      if (money && env)
        tell_object(per, "Oops, the money " + money->the_short() +
                    " has found life in your inventory too heavy and "
                    "has gone to " + env->the_short() + ".\n");
   }
   return money;
}
object merge_coins() {
   object money;
   if (_already_joined)   return this_object();
   remove_alias( MONEY_ALIAS );
   if(environment()) {
     money = present( MONEY_ALIAS, environment() );
   }
   add_alias( MONEY_ALIAS );
   if ( objectp( money ) &&
        money != this_object())
   {
#ifdef USE_VAULT
      MONEY_VAULT->add_to_list(this_object());
#else
      move("/room/rubbish");
#endif
      money->adjust_money( money_array );
      money->fixup_money_weight();
      _already_joined = 1;
#ifdef DEBUGGER
      if (find_player(DEBUGGER) == this_player())
         tell_creator(DEBUGGER, "Merging %O and %O\n", this_object(), money);
#endif
      return money;
   }
#ifdef DEBUGGER
   if (find_player(DEBUGGER) == this_player())
      tell_creator(DEBUGGER, "Merge coins returning %O\n", this_object());
#endif
   return this_object();
}
varargs int move( mixed dest, string messin, string messout ) {
   int i;
   if (_already_joined)
     return MOVE_INVALID_DEST;
   if(objectp(dest) && environment(dest) && !living(dest) &&
      !dest->query_corpse() && !dest->query_accept_money())
     return MOVE_INVALID_DEST;
   i = ::move( dest, messin, messout );
   if ( i != MOVE_OK ) {
      return i;
   }
   if((file_name(environment()) == MONEY_VAULT))
     return MOVE_OK;
   if ( ( file_name( environment() ) == "/room/rubbish" ) || no_join ) {
      reset_no_join();
      return MOVE_OK;
   }
   merge_coins();
   return MOVE_OK;
}
public int find_best_fit( mixed word ) {
   int i;
   int best;
   int best_rating;
   int rating;
   string against;
   string *words;
   if ( !word || ( word == "" ) ) {
      return 0;
   }
   if (stringp(word)) {
      words = explode( lower_case( word ), " " ) - ({ "coin", "coins" });
   } else {
      words = word;
   }
   best = -1;
   for ( i = 0; i < sizeof( money_array ); i += 2 ) {
      rating = 0;
      against = "X "+ replace( money_array[ i ] +" "+
            (string)MONEY_HAND->query_plural_for( money_array[ i ] ),
            " coins", "" ) +" X";
      foreach( word in words ) {
         if ( sscanf( against, "%*s "+ word +" %*s" ) == 2 ) {
            rating++;
         }
      }
      if ( rating > best_rating ) {
         best_rating = rating;
         best = i;
      }
   }
   return best;
}
object query_parse_id( mixed *arr ) {
   int i;
   string *bits;
   object money;
#ifdef DEBUG
   debug_printf("%O", arr );
#endif
   if ( ( arr[ 0 ] < 0 ) || !sizeof( money_array ) ) {
      return 0;
   }
   if ( arr[ 0 ] == 0 ) {
      bits = explode( arr[ 1 ], " " );
      if ( sizeof( bits ) == 1 ) {
         if ( bits[ 0 ] == "coins" ) {
            return this_object();
         }
      }
      if ( member_array( bits[ sizeof( bits ) - 1 ], query_plurals() ) == -1 ) {
         return this_object();
      }
      i = find_best_fit( arr[ 1 ] );
      if ( i == -1 ) {
         return 0;
      }
      money = new_money_object( money_array[ i + 1 ], money_array[ i ] );
      return money;
   }
   i = find_best_fit( arr[ 1 ] );
   if ( i == -1 ) {
      i = 0;
   }
   if ( arr[ 0 ] > money_array[ i + 1 ] ) {
      return 0;
   }
   money = new_money_object( arr[ 0 ], money_array[ i ] );
   return money;
}
mixed* parse_match_object(string* input, object viewer,
                          class obj_match_context context) {
   int ret;
   int found;
   int num;
   int i;
   int j;
   int success;
   object money;
   mixed *matched;
   string where;
   string *bits;
   string name;
   if (!sizeof(money_array)) {
      return 0;
   }
   ret = ::is_matching_object(input, viewer, context);
   if (!ret) {
      return 0;
   }
   if (sizeof(input) == 1 &&
       !context->number_included &&
       !context->ordinal &&
       (input[<1] == "coins" || input[<1] == "money" ||
        input[<1] == "all" || input[<1] == "thing" ||
        input[<1] == "one")) {
      return ({ OBJ_PARSER_MATCH_PLURAL, ({ this_object() }) });
   }
   else if (sizeof(input) >= 2  &&
            member_array(input[0], query_adjectives()) > -1  &&
            (input[<1] == "coins"  ||  input[<1] == "money"))
   {
      success = 0;
      name = lower_case(input[0]);
      if (name == "provincial"  ||  name == "default")  {
         success = 1;
         where = "default";
      }
      else for (i = 0; i < sizeof(money_array); i += 2)  {
         bits = explode(lower_case(money_array[i]), " ");
         if (member_array(name, bits) > -1)  {
            where = MONEY_HAND->query_origin_of(money_array[i]);
            if (!where)
               return 0;
            if (where != "default")
               success = 1;
            break;
         }
      }
      if (success)  {
         matched = MONEY_HAND->filter_legal_money_to_array(money_array,
                                                           where);
         if (sizeof(matched[0]) == 0)
            return 0;
         for (j = 1; j < sizeof(matched[0]); j+= 2)
           num += matched[0][j];
         if (!update_parse_match_context(context, num, ret))
            return 0;
         money = new_money_object(matched[0], "");
         if (!money)
            return 0;
         return ({ ret, ({ money }) });
      }
   }
   found = find_best_fit(input);
   if (found == -1) {
      return 0;
   }
   num = money_array[found + 1];
   num = update_parse_match_context(context, num, ret);
   if (!num) {
      return 0;
   }
   money = new_money_object( num, money_array[found]);
   if (!money) {
      return 0;
   }
   return ({ ret, ({ money }) });
}
int do_not_sell() { return 1; }
int query_value() { return 0; }
int query_value_in( string where ) {
   return (int)MONEY_HAND->query_total_value( money_array, where );
}
int query_money( string type ){
   int i;
   i = member_array( type, money_array );
   if (i == -1 ) {
      return 0;
   }
   return money_array[i + 1];
}
mixed *stats() {
  return ::stats() +
    ({ ({ "value" , query_multiple_short(half_short(1)) }) });
}
