# Total Tokens: 58028
# Total Files Merged: 102

=====
FILE: creator/findc_orpse.c
==================================================

inherit "/cmds/base";
int cmd( string arg ) {
   object *cs, c;
   string r;
   r = "player corpse objects\n";
   cs = filter( children( "/obj/corpse" ), (: $1 && $1->query_property(
      "player" ) :) );
   if( !arg ) {
      foreach( c in cs ) r += file_name( c ) + " - " + c->query_owner() +
         " - " + ( environment( c ) ? file_name( environment( c ) ) :
         "In void" ) + "\n";
      tell_object( this_player(), r );
      tell_object( this_player(), sizeof( cs ) + " player corpses.\n" );
   } else {
      cs = filter( cs, (: $1 && $1->query_ownership() == $( arg ) :) );
      if( sizeof( cs ) ) {
         r = "Corpse objects of " + arg + ": \n";
         foreach( c in cs ) r += file_name( c ) + " in " + (
         environment( c ) ? file_name( environment( c ) ) : "void" ) + "\n";
         tell_object( this_player(), r );
      } else {
         tell_object( this_player(), arg + " has no corpses loaded.\n" );
      }
   }
   return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/findr_edef.c
==================================================

string *find_stuff(object ob, string varname){
  string *variables = variables(ob);
  string *ret = ({});
  if(member_array(varname, variables) > -1){
    object *inhobs = map(inherit_list(ob), (:find_object:));
    object obj;
    foreach(obj in inhobs){
      ret += find_stuff(obj, varname);
    }
    if(ret == ({})){
      ret = ({file_name(ob)});
    }
  }
  return ret;
}
int cmd(object ob, string var){
  string *files = find_stuff(ob, var);
  if(sizeof(files) > 1)
    printf("%s is defined in %s and %s.\n", var, implode(files[0..<2], ", "),
           files[<1]);
  else
    write("No redefinition found.\n");
  return 1;
}
string *query_patterns(){
  return ({"<indirect:wiz-present> <word'global'>", (:cmd($1[0], $4[1]):)});
}

==================================================
FILE: creator/fixed.c
==================================================

#include <config.h>
#include <db.h>
inherit "/cmds/base";
int db;
void finish_request(int type, mixed* data, object person) {
   string ret;
   mapping row;
   if (type == DB_SUCCESS) {
      ret = "";
      foreach (row in data) {
         ret += sprintf("%-15s %s\n", row["Fixer"], "" + row["bing"]);
      }
   } else {
      ret = "Some sort of horrible error!\n";
   }
   person->more_string(ret, "details");
}
int cmd(string who){
   string request;
   if(who == "all") {
      request = "select Fixer, count(*) as bing from errors "
                            "where Fixer is not NULL and Status = 'FIXED' and "
                            "Type = 'BUG' "
                            "group by Fixer order by bing desc";
   } else {
      request = "select Fixer, count(*) as bing from errors "
                            "where Fixer = '" + who +
                            "' and Status = 'FIXED' and "
                            "Type = 'BUG' "
                            "group by Fixer order by bing desc";
   }
   DB_HANDLER->make_sql_request("errors", CONFIG_DB_USER, "", request,
                                (: finish_request($1, $2, $(this_player())) :));
   add_succeeded_mess("");
   return 1;
}
mixed *query_patterns() {
   return ({ "<string'person|all'>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/forwards.c
==================================================

#include <config.h>
#include <db.h>
inherit "/cmds/base";
int db;
void finish_request(int type, mixed* data, object person) {
   string ret;
   mapping row;
   if (type == DB_SUCCESS) {
      ret = "";
      foreach (row in data) {
         ret += sprintf("%-15s %s\n", row["Forwarder"], "" + row["bing"]);
      }
   } else {
      ret = "Some sort of horrible error!\n";
   }
   person->more_string(ret, "details");
}
int cmd(string who){
   string request;
   if(who == "all") {
      request = "select Forwarder, count(*) as bing from forwards "
                   "where Forwarder is not NULL "
                   "group by Forwarder order by bing desc";
   } else {
      request = "select Forwarder, count(*) as bing from forwards "
                   "where Forwarder = '" + who + "' "
                   "group by Forwarder order by bing desc";
   }
   DB_HANDLER->make_sql_request("errors", CONFIG_DB_USER, "", request,
                                (: finish_request($1, $2, $(this_player())) :));
   add_succeeded_mess("");
   return 1;
}
mixed *query_patterns() {
   return ({ "<string'person|all'>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/fry.c
==================================================

#include <playerinfo.h>
#define LIGHTNING "%^WHITE%^BOLD%^lightning%^RESET%^"
#define THUNDER "%^RED%^BOLD%^thunder%^RESET%^"
inherit "/cmds/base";
mapping banned = ([
    "macchirton"    :   "it's tradition.",
    "que"           :   "you're an arse.",
    ]);
mixed cmd(string words) {
  string player, reason;
  object ob;
    add_failed_mess("At Pinkfish's request this command has been disabled.\n" );
    return 0;
  if(member_array (this_player()->query_name(), keys(banned)) != -1)
  {
    return notify_fail("You cannot use 'fry', because " +
        banned[this_player()->query_name()] + "\n");
  }
  if(!words || sscanf(words, "%s %s", player, reason ) != 2) {
    return notify_fail("Usage: fry <player> <reason>\n");
  }
  if (!"/secure/master"->query_senior(this_player()->query_name()))
  {
    return notify_fail ("Only Senior Creators and above may smite players "
        "with Righteous Vengeance!\n");
  }
  ob = find_player(this_player()->expand_nickname(player));
  if(!ob) {
    return notify_fail(player+" not found!\n");
  }
  write("Warning: This is not to be used for pranks.  If you "
    "do not have a valid reason to use this, do not use it!  "
    "Are you quite sure you wish to proceed? (y/n): ");
  input_to("are_sure", ob, reason);
  return 1;
}
void are_sure(string str, object ob, string reason) {
  string gender = "boy";
  if(this_player()->query_gender() == 2) {
    gender = "girl";
  }
  str = lower_case(str);
  if(str[0] != 'y') {
    write("There's a good "+gender+"!  Now you go play nice with little "
        + ob->one_short() + "!\n");
    return;
  }
  write("Would you like the whole Disc to be aware of the reason "
    "for your ire? (y/n): ");
  input_to("positive", ob, reason);
}
void positive (string str, object ob, string reason) {
  str = lower_case(str);
  if(str[0] != 'y') {
    write ("Okay, we'll keep it between you and me.\n");
    call_out("fry2", 5+random (3), ob);
  }
  else
  {
    write ("Bwah-ha-ha-ha!\n");
    call_out("fry2", 5+random (3), ob, reason);
  }
  PLAYERINFO_HANDLER->add_entry(this_player(),
                                ob->query_name(),
                                "meteor",
                                reason);
  log_file("SMITE", "%s: %s smote %s: %s\n", ctime(time()),
    this_player()->query_short(), ob->query_short(), reason);
  shout("The sky grows dark.  Thick black clouds roll in.\n");
  shout("A loud peal of " + THUNDER + " rumbles, shaking the ground, "
    "and bolts of " + LIGHTNING + " flash through the sky!\n");
  write("Smiting "+capitalize (ob->query_name()) +" with Righteous Vengeance!\n");
}
varargs void fry2(object ob, string reason) {
    string *shout_mess = ({
        "A bolt of ferocious " + LIGHTNING + " rips the sky in two!  ",
        "A peal of deafening " + THUNDER + " rumbles o'er the land!  ",
        "The clouds gather, spitting forth bolts of vicious " + LIGHTNING +
            " from their folds!  ",
        "The clouds gather into great dark masses, spitting " + LIGHTNING +
            " at the cowering Disc below!  "
        });
    string *player_mess = ({
        "A bolt of shimmering " + LIGHTNING + " spears the ground in front "
            "of you!\n",
        "A bolt of " + LIGHTNING + " pierces the air above you, melting "
            "your eyebrows.\n",
        "A bolt of " + LIGHTNING + " flares before your face, causing "
            "little blobs of light to dance over your retinas.\n"
            });
    shout (shout_mess[random(sizeof(shout_mess))] + "It appears one "
        "of the " + mud_name() + "'s creators is unhappy...\n");
    tell_object(ob, player_mess[random(sizeof(player_mess))]);
    call_out("fry3", 8 + random (10), ob, reason);
}
varargs void fry3(object ob, string reason)
{
    string name;
    string *TMs = ({
        "You feel more able to spear players with bolts of lightning!\n",
        "You feel more confident about your aim when trying to hit small "
            "scurrying figures from Cori Celesti!\n",
        "You manage to grasp one of the principles of creator justice "
            "more firmly!\n",
        });
    string *shout_mess = ({
        "Another spear of " + LIGHTNING + " lances through the clouds, "
            "followed closely by a deafening peal of " + THUNDER + "!\n",
        "A deafening roll of " + THUNDER + " followed by a bolt of brilliant "
        + LIGHTNING + " rolls over the " + mud_list() + ".\n",
        "The clouds spit out another violent bolt of " + LIGHTNING + " as "
        + THUNDER + " shatters the relative peace of the " + mud_list() + ".\n"
        });
    string *player_mess = ({
        "A bolt of " + LIGHTNING + " strikes you and sends you into the "
            "%^RED%^oblivion%^RESET%^ of the real world!\n",
        "A bolt of " + LIGHTNING + " pierces the skies and strikes you!  "
        "%^RED%^Zzzzzot!%^RESET%^\n",
        "A bolt of " + LIGHTNING + " spears down from the sky and %^RED%^"
            "smites%^RESET%^ you!\n",
        });
  if (random (100) > 80)
  {
        tell_object (this_player(), "The " + LIGHTNING + " blasts " + ob->short() +
            " into oblivion!\n");
        tell_object (this_player(), "%^YELLOW%^%^BOLD%^" + TMs[random(sizeof(TMs))]
            + "%^RESET%^");
        this_player()->add_skill_level ("fighting.combat.range.thrown", 1);
  }
  shout(shout_mess[random(sizeof(shout_mess))]);
  if (this_player()->query_invis())
  {
        name = "Someone";
  }
  else
  {
        name = this_player()->short();
  }
  if (reason)
  {
      shout(name + " shouts from the clouds:  This is " + reason +
      ", " + ob->short() +"!\n");
  }
  else
  {
      shout(name + " cackles in the distance.\n");
  }
  tell_object(ob, player_mess[random(sizeof(player_mess))]);
  ob->save();
  ob->quit();
  shout(ob->query_cap_name()+" was smote by " + name + "'s "
    "lightning.\n"+ capitalize(ob->query_pronoun())+" is no more.\n");
  shout ("The clouds roll back across the sky.");
}

==================================================
FILE: creator/ftpwho.c
==================================================

inherit "/cmds/base";
#define FTPD "/secure/ftpd"
#define UNIX_FTPD "/secure/ftp_auth"
mixed cmd(string) {
  mixed *who_unix, *who;
  int i;
  if(!find_object(FTPD)) {
    write("MUD FTP is currently disabled.\n");
  } else {
    who = FTPD->query_connections();
    if ((i = sizeof(who))) {
      write("People currently using MUD FTP :\n");
      while (i--)
        write(" - "+who[i]+"\n");
    } else {
      write("No one is using MUD FTP at the moment.\n");
    }
  }
  who_unix = UNIX_FTPD->query_connections();
  if ((i = sizeof(who_unix))) {
    write("People currently using UNIX FTP :\n");
    while (i--)
      write(" - "+who_unix[i]+"\n");
  } else {
    write("No one is using UNIX FTP at the moment.\n");
  }
  return 1;
}

==================================================
FILE: creator/gag.c
==================================================

#include <playerinfo.h>
inherit "/cmds/base";
int cmd( object victim, string reason, int number ) {
   victim->add_property( "gagged", reason, 60 * number );
   log_file( "GAG", ctime(time()) +": "+ this_player()->query_short()
             + " gagged " + victim->query_short() + " for " + number
             + " minutes.  Reason: " + reason +".\n");
   PLAYERINFO_HANDLER->add_entry( this_player(), victim->query_name(),
             "gag", "Gagged for " + number + " minutes.  Reason: '" + reason +
             "'.\n");
   tell_object( victim,
         "%^RED%^%^BOLD%^You have been gagged by " +
         this_player()->query_short() + " for the reason: '" + reason +
         "'.\nYou will not be able to shout, chat or use the newbie "
         "channel until the gag is removed.%^RESET%^\n" );
   write( "Okay, gagged " + victim->query_short() + " for " + number +
          " minutes.  Now please discuss your reason for gagging with "
          "them.  IMPORTANT! You should only be gagging for deliberately "
          "offensive language.\n" );
   event( users(), "inform", this_player()->query_short()
          + " gagged " + victim->query_short() + " for: " + reason, "gag");
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:player'player'> <string'reason'>",
                (: cmd( $1[0], $4[1], 15 ) :),
             "<indirect:player'player'> <string'reason'> <number'minutes'>",
                (: cmd( $1[0], $4[1], $4[2] ) :) });
}

==================================================
FILE: creator/gna_.c
==================================================

inherit "/cmds/base";
protected int cmd( string pattern, object *obs ) {
    string gn;
    object ob;
    string verb = query_verb();
    if ( sizeof( explode( verb, "" ) - ({ "g", "n", "a", "h" }) ) ) {
        return 0;
    }
    gn = "gn" + implode( allocate( sizeof( pattern ) - 2, "a" ), "" ) + "h!";
    if ( arrayp( obs ) ) {
        obs = filter( obs, (: !$1->check_earmuffs( "remote-soul" ) :) );
        obs -= ({ this_player() });
         if ( sizeof( obs ) ) {
            tell_object( this_player(), "You go '$C$" + gn + "' at " +
                query_multiple_short( obs ) + ".\n" );
            foreach (ob in obs) {
                tell_object(ob, this_player()->the_short() + " goes '$C$" +
                    gn + "' at you.\n" );
            }
            return 1;
        }
    }
    write( capitalize( gn ) + "\n" );
    return 1;
}
mixed *query_patterns() {
    mixed *pat = ({ "", (: cmd($6, 0) :) });
    if ( previous_object(1)->query_lord() ) {
        pat += ({ " <indirect:wiz-present>", (: cmd($6, $1) :) });
    }
    else {
        pat += ({ " <indirect:any-living>", (: cmd($6, $1) :),
                  " <indirect:object>", (: cmd($6, $1) :) });
    }
    return pat;
}

==================================================
FILE: creator/go_to.c
==================================================

mixed cmd(string str) {
  object dest;
  string *names, nick;
  string tname;
  if (!str)
    return notify_fail("Teleport where?\n");
  nick = (string)this_player()->expand_nickname(str);
  dest = find_living(nick);
  if (!dest && objectp(this_player()->get_obvar(str))) {
    dest = this_player()->get_obvar(str);
    if (dest == environment(this_player()))
      return notify_fail("You look around and realise you are already there.\n");
    this_player()->set_last_location(base_name(environment(this_player())));
    this_player()->move_with_look( dest,
                                   (string)this_player()->query_mmsgin(),
                                   (string)this_player()->query_mmsgout() );
    return 1;
  }
  if (dest) {
    if(dest = environment(dest)) {
      if (dest == environment(this_player()))
        return notify_fail("You look around and realise you are already "
                           "there.\n");
      this_player()->set_last_location(base_name(environment(this_player())));
      this_player()->move_with_look( dest,
            (string)this_player()->query_mmsgin(),
            (string)this_player()->query_mmsgout() );
      return 1;
    } else
      return notify_fail(capitalize(nick) + " is not standing in a location.\n");
  } else {
    names = (string *)this_player()->get_cfiles(str);
    if(sizeof(names)) {
      str = names[0];
    } else {
      if (strsrch(str, ":") == -1) {
         return notify_fail("No such room.\n");
      }
      if (str[0] != '/') {
         str = this_player()->query_current_path() + "/" + str;
      }
    }
    dest = load_object(str);
    if (!dest) {
      return notify_fail("Failed to load " + str + "\n");
    } else if(!dest->query_property("location")) {
      return notify_fail("Not a room: " + str + "\n");
    } else {
      if (dest == environment(this_player())) {
        notify_fail("You look around and realise you are already there.\n");
        return 0;
      }
      if (environment(this_player())) {
         tname = environment(this_player())->query_property("terrain name");
         if (tname) {
           this_player()->set_last_location(
             ({ tname, environment(this_player())->query_co_ord() })
             );
         } else {
           this_player()->set_last_location(
             base_name(environment(this_player()))
             );
         }
      }
      this_player()->move_with_look( dest,
                                     (string)this_player()->query_mmsgin(),
                                     (string)this_player()->query_mmsgout() );
      return 1;
    }
  }
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/gob_ack.c
==================================================

#include <terrain.h>
mixed cmd(string str) {
  mixed dest;
  string tname;
  dest = this_player()->query_last_location();
  if(!dest)
    return notify_fail("No stored location.\n");
  if (stringp(dest)) {
    dest = load_object(dest);
  } else if (arrayp(dest) && stringp(dest[0]) && arrayp(dest[1])) {
    dest = TERRAIN_MAP->find_location(dest[0], dest[1]);
  } else {
    return notify_fail("I don't understand your stored location.\n");
  }
  tname = environment(this_player())->query_property("terrain name");
  if (tname) {
    this_player()->set_last_location(
      ({ tname, environment(this_player())->query_co_ord() })
      );
  } else {
    this_player()->set_last_location(
      base_name(environment(this_player()))
      );
  }
  this_player()->move_with_look( dest,
                                 this_player()->query_mmsgin(),
                                 this_player()->query_mmsgout() );
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/guildl_ist.c
==================================================

inherit "/cmds/base";
int cmd(string arg) {
  object ob;
  mapping guilds;
  string guild, *fields;
  guilds = ([ ]);
  foreach(ob in users()) {
    if(ob->query_creator())
      continue;
    if(!ob->query_guild_ob()) {
      guilds["none"]++;
    } else {
      fields = explode((string)ob->query_guild_ob(), "/");
      guilds[fields[2]]++;
    }
  }
  write("Guild memberships:\n");
  foreach(guild in keys(guilds))
    printf("  %s: %d\n", guild, guilds[guild]);
  return 1;
}

==================================================
FILE: creator/hcode.c
==================================================

inherit "/cmds/base";
#include <broadcaster.h>
mixed cmd(string) {
   int i;
   mixed *hist;
   if (!wizardp(this_player())) {
      return 0;
   }
   hist = HIST_HANDLER->query_chat_history("code");
   if (!pointerp(hist) || !sizeof(hist)) {
      return notify_fail("Nobody said anything on the code channel.\n");
   }
   write("The code channel history is:\n");
   for (i=0;i<sizeof(hist);i++) {
      if (sizeof(hist[i]) > 2) {
         efun::tell_object(this_player(),
                (string)this_player()->fix_string(sprintf("*%s* %s%-=*s\n",
                ctime(hist[i][2])[11..18], hist[i][0],
                (int)this_player()->query_cols()-strlen(hist[i][0])-11,
                hist[i][1])));
      } else {
         efun::tell_object(this_object(),
                (string)this_player()->fix_string(sprintf("%s%-=*s\n",
                hist[i][0], (int)this_player()->query_cols()-strlen(hist[i][0]),
                hist[i][1])));
      }
   }
   return 1;
}

==================================================
FILE: creator/hcre.c
==================================================

inherit "/cmds/base";
#include <broadcaster.h>
mixed cmd(string) {
   int i;
   mixed *hist;
   if (!wizardp(this_player())) {
      return 0;
   }
   hist = HIST_HANDLER->query_chat_history("cre");
   if (!pointerp(hist) || !sizeof(hist)) {
      return notify_fail("Nobody said anything on the cre channel.\n");
   }
   write("The creator channel history is:\n");
   for (i=0;i<sizeof(hist);i++) {
      if (sizeof(hist[i]) > 2) {
         efun::tell_object(this_player(),
                (string)this_player()->fix_string(sprintf("*%s* %s%-=*s\n",
                ctime(hist[i][2])[11..18], hist[i][0],
                (int)this_player()->query_cols()-strlen(hist[i][0])-11,
                hist[i][1])));
      } else {
         efun::tell_object(this_object(),
                (string)this_player()->fix_string(sprintf("%s%-=*s\n",
                hist[i][0], (int)this_player()->query_cols()-strlen(hist[i][0]),
                hist[i][1])));
      }
   }
   return 1;
}

==================================================
FILE: creator/he_ad.c
==================================================

mixed cmd(string str) {
  int i;
  string *files;
  seteuid(geteuid(this_player()));
  if (!str)
    return notify_fail("Usage: head <file>\n");
  files = this_player()->get_files(str);
  if (!sizeof(files))
    return notify_fail("File does not exist.\n");
  str = files[0];
  i = file_length(str);
  if (i < 0) {
    printf("File not found.\n");
    return 1;
  }
  if (i > 20) i=20;
  write(read_file(str,1,i));
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/hliaison.c
==================================================

inherit "/cmds/base";
#include <broadcaster.h>
mixed cmd(string) {
   int i;
   mixed *hist;
   if (!wizardp(this_player())) {
      return 0;
   }
   hist = HIST_HANDLER->query_chat_history("liaison");
   if (!pointerp(hist) || !sizeof(hist)) {
      return notify_fail("Nobody said anything on the liaison channel.\n");
   }
   write("The liaison channel history is:\n");
   for (i=0;i<sizeof(hist);i++) {
      if (sizeof(hist[i]) > 2) {
         efun::tell_object(this_player(),
                (string)this_player()->fix_string(sprintf("*%s* %s%-=*s\n",
                ctime(hist[i][2])[11..18], hist[i][0],
                (int)this_player()->query_cols()-strlen(hist[i][0])-11,
                hist[i][1])));
      } else {
         efun::tell_object(this_object(),
                (string)this_player()->fix_string(sprintf("%s%-=*s\n",
                hist[i][0], (int)this_player()->query_cols()-strlen(hist[i][0]),
                hist[i][1])));
      }
   }
   return 1;
}

==================================================
FILE: creator/ho_me.c
==================================================

mixed cmd(string str) {
  write("Usage : alias home goto <wherever> :)\n");
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/host.c
==================================================

inherit "/cmds/base";
mapping lookups = ([]);
int cmd( string w ) {
    string ip = lower_case( this_player()->expand_nickname( w ) );
    string ip2;
    if ( find_player( ip ) ) {
        ip2 = query_ip_number( find_player( ip ) );
        lookups[ resolve( ip2, "lookup_callback" ) ] = this_player();
        tell_object( this_player(), "Starting lookup for " + ip +
                     " (" + ip2 + ").\n" );
    } else {
        lookups[ resolve( ip, "lookup_callback" ) ] = this_player();
        tell_object( this_player(), "Starting lookup for " + ip + ".\n" );
    }
    return 1;
}
void lookup_callback( string address, string resolved, int key ) {
    if ( lookups[ key ] ) {
        tell_object( lookups[ key ], "Resolved " +
                     ( address ? address : "?unknown" ) +
                     " to " +
                     ( resolved ? resolved : "?unknown" ) + ".\n" );
    }
    map_delete( lookups, key );
}
mixed *query_patterns() {
   return ({ "<string'ip-address, host or player'>",
                 (: cmd( $4[0] ) :) });
}

==================================================
FILE: creator/hours.c
==================================================

inherit "/cmds/base";
int cmd( int time, string all) {
    mapping people;
    int seconds, num;
    string mess;
    if ( !time ) {
      if(all == "")
        people = unique_mapping( filter( users(),
            (: interactive( $1 ) && !$1->query_login_ob() &&
             !$1->query_creator() :) ),
            (: ( (time() - $1->query_last_log_on() ) / 3600 ) :) );
      else
        people = unique_mapping( filter( users(),
            (: interactive( $1 ) && !$1->query_login_ob() :) ),
            (: ( (time() - $1->query_last_log_on() ) / 3600 ) :) );
        people = map( people, (: sort_array( $2, (: strcmp( $1->query_name(),
            $2->query_name() ) :) ) :) );
        mess = "";
        foreach( num in sort_array( keys( people ), -1 ) ) {
            if ( num > 0 ) {
                mess += "Online for " + query_num( num ) +
                    ( num == 1 ? " hour: \n" : " hours: \n" ) +
                    query_multiple_short( people[ num ] ) + ".\n\n";
            }
        }
        tell_object( this_player(), "$P$Online time$P$" +
            mess );
    }
    else {
        seconds = time * 60 * 60;
        people = allocate_mapping( users(), (: $(time()) -  $1->query_last_log_on() :) );
        people = filter( people, (: interactive($1) && !$1->query_login_ob()
            && $2 > $(seconds) :) );
        if ( sizeof( people ) ) {
            tell_object( this_player(), "The following people have been "
                "connected for more than " + query_num( time ) +
                ( time % 3600 < 2 ? " hour: " : " hours: " ) +
                query_multiple_short( keys( people ) ) + ".\n" );
        }
        else {
            tell_object( this_player(), "No one has been connected for that "
                "long.\n" );
        }
    }
    return 1;
}
mixed *query_patterns() {
  return ({ "<number>", (: cmd($4[0], "") :),
            "<number> all", (: cmd($4[0], "all") :),
            "all", (: cmd(0, "all") :),
            "", (: cmd(0, "") :) });
}

==================================================
FILE: creator/hous_ing.c
==================================================

#include <housing.h>
#include <login_handler.h>
#include <money.h>
inherit "/cmds/base";
private string get_file(string fname) {
  string *tmp;
  tmp = this_player()->get_files(fname);
  if(sizeof(tmp) != 1) {
    tmp = this_player()->get_files(fname + ".c");
    if(sizeof(tmp) != 1)
      return "";
  }
  return tmp[0][0..<3];
}
int do_remove(string house) {
  house = get_file(house);
  if(!HOUSING->query_house(house))
    return notify_fail("No such house.\n");
  HOUSING->remove_house(house);
  write("House removed.\n");
  return 1;
}
int do_add(string house, string region, int rented, string address) {
  object ob;
  house = get_file(house);
  if(house == "")
    return notify_fail("House does not exist.\n");
  load_object(house);
  ob = find_object(house);
  if(!ob || !function_exists("query_owner", ob)) {
     add_failed_mess("The file " + house + " is not a player house.\n");
     return 0;
  }
  HOUSING->add_house(house, ({ }), address, region, rented);
  write("House added.\n");
  return 1;
}
int do_modify(string house, string region, int rented, string address) {
  string *rooms;
  house = get_file(house);
  if(house == "")
    return notify_fail("House does not exist.\n");
  if(!HOUSING->query_house(house))
    return notify_fail("That house is not registered.\n");
  rooms = HOUSING->query_rooms(house) - ({ house });
  HOUSING->modify_house(house, rooms, address, region, rented);
  write("House modified.\n");
  return 1;
}
int add_room(string house, string room) {
  string *files, file;
  object ob;
  int added;
  house = get_file(house);
  if(!HOUSING->query_house(house)) {
    return notify_fail("No such house.\n");
  }
  files = this_player()->get_files(room);
  if(!sizeof(files)) {
    return notify_fail("That room doesn't exist.\n");
  }
  house->force_load();
  ob = find_object(house);
  if(!ob || !function_exists("query_owner", ob)) {
     add_failed_mess("The start point is not a player house!\n");
     return 0;
  }
  added = 0;
  foreach(file in files) {
    room = file[0..<3];
    if(room == house) {
      continue;
    }
    if(!HOUSING->add_rooms(house, ({ room }))) {
      write("Error adding room " + room + ".\n");
    } else {
      write("Room added [" + room + "]\n");
    }
  }
  return 1;
}
int remove_room(string house, string room) {
  house = get_file(house);
  if(!HOUSING->query_house(house))
    return notify_fail("No such house.\n");
  if(!HOUSING->remove_rooms(house, ({ room })))
    return notify_fail("Error removing room.\n");
  write("Room removed.\n");
  return 1;
}
int do_owner(string house, string owner) {
  if(owner == "none")
    owner = "For Sale";
  if(owner != "For Sale" && owner != "Under Offer" &&
     !PLAYER_HANDLER->test_user(owner))
    return notify_fail("No such user " + owner + ".\n");
  house = get_file(house);
  if(!HOUSING->set_owner(house, owner))
     return notify_fail("Error changing owner.\n");
  write("Owner set to " + owner + ".\n");
  return 1;
}
int do_list(string search) {
  string house;
  string str;
  string tmp;
  int num, negative;
  debug_printf("search: %s", search);
  if(search) {
    house = get_file(search);
    if(HOUSING->query_house(house)) {
      printf("House: %s\n  Owner: %s\n  Address: %s\n  Region: %s\n  "
             "Type: %s\n  Value: %d\n  Rooms: %s\n",
             house,
             HOUSING->query_owner(house),
             HOUSING->query_address(house),
             HOUSING->query_region(house),
             (HOUSING->query_type(house) ? "Rented" : "Owned"),
             HOUSING->query_value(house),
             implode(HOUSING->query_rooms(house), ", "));
      return 1;
    }
  }
  str = "";
  if(search && strlen(search) > 4 && search[0..3] == "not ") {
    search = search[4..];
    negative = 1;
  }
  foreach(house in keys(HOUSING->query_houses())) {
    tmp = sprintf("%s - %s: %s. %d rooms (%s).\n",
                  house,
                  (HOUSING->query_type(house) ? "Renter" +
                   (HOUSING->query_value(house) ? " (" +
                    MONEY_HAND->money_value_string(HOUSING->query_value(house), "Ankh-Morpork") + ")" : "")
                   : "Owner"),
                  HOUSING->query_owner(house),
                  sizeof(HOUSING->query_rooms(house)),
                  (stringp(HOUSING->query_region(house))?HOUSING->query_region(house):"Bad region"));
    if(!search ||
       (!negative && strsrch(lower_case(tmp), lower_case(search)) != -1) ||
       (negative && strsrch(lower_case(tmp), lower_case(search)) == -1)) {
      str += tmp;
      num++;
    }
  }
  if (!num) {
     str += "No houses found.\n";
  } else {
     str += num + " houses found.\n";
  }
  write("$P$Housing$P$" + str);
  return 1;
}
int do_sell(string house) {
   house = get_file(house);
   if (!HOUSING->set_for_sale(house)) {
      add_failed_mess("Unable to set the house " + house + " up for sale.\n");
      return 0;
   }
   write("Set the house up for sale.\n");
   return 1;
}
int do_list_address(string search) {
  string house;
  string str;
  string tmp;
  int num;
  int negative;
  str = "";
  if(search && strlen(search) > 4 && search[0..3] == "not ") {
    search = search[4..];
    negative = 1;
  }
  foreach(house in keys(HOUSING->query_houses())) {
    tmp = sprintf("%s - %s (%s).\n",
                  house,
                  HOUSING->query_address(house),
                  HOUSING->query_region(house));
    if(!search ||
       (!negative && strsrch(lower_case(tmp), lower_case(search)) != -1) ||
       (negative && strsrch(lower_case(tmp), lower_case(search)) == -1)) {
      str += tmp;
      num++;
    }
  }
  if (!num) {
     str += "No houses found.\n";
  } else {
     str += num + " houses found.\n";
  }
  write("$P$Housing$P$" + str);
  return 1;
}
mixed *query_patterns() {
  return ({ "list", (: do_list(0) :),
              "list <string'search'>", (: do_list($4[0]) :),
              "list address", (: do_list_address(0) :),
              "list address <string'search'>", (: do_list_address($4[0]) :),
              "sell <word'house'>", (: do_sell($4[0]) :),
              "add <word'house'> <word'region'> <number'rented'> "
              "<string'address'>", (: do_add($4[0], $4[1], $4[2], $4[3]) :),
              "modify <word'house'> <word'region'> <number'rented'> "
              "<string'address'>", (: do_modify($4[0], $4[1], $4[2], $4[3]) :),
              "add room <word'house'> <string'room'>",
              (: add_room($4[0], $4[1]) :),
              "remove room <word'house'> <string'room'>",
              (: remove_room($4[0], $4[1]) :),
              "owner <word'house'> <string'owner'>",
              (: do_owner($4[0], $4[1]) :),
              "remove <word'house'>", (: do_remove($4[0]) :),
              });
}

==================================================
FILE: creator/iemote.c
==================================================

#include <network.h>
inherit "/cmds/base";
int cmd(string person, string text) {
    string target, mud;
    if (sscanf(person, "%s@%s", target, mud) != 2) {
        return 0;
    }
    if ( !strlen( target ) || !strlen( mud ) ) {
        return 0;
    }
    SERVICES_D->eventSendEmote(target, mud, text);
    add_succeeded_mess( ({ sprintf("You emote to %s@%s: %s@%s %s\n",
        capitalize(target), mud, this_player()->query_cap_name(),
        mud_name(), text), "" }) );
    return 1;
}
mixed *query_patterns() {
    return ({ "<string'person'> <string'message'>",
              (: cmd($4[0], $4[1]) :) });
}

==================================================
FILE: creator/iloc_ate.c
==================================================

#include <network.h>
mixed cmd(string who) {
  if (!who) {
    notify_fail("Syntax: locate <name>\n");
    return 0;
  }
  SERVICES_D->eventSendLocateRequest(who);
  printf("Locating %s. Don't explode !\n", who);
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/inh_eritance.c
==================================================

#include <creator.h>
inherit "/cmds/base";
private string inherith(string ob, string ind, string leaf);
private int cmd(string fn, string fn2) {
    object ob, ob2;
    fn = this_player()->get_path( fn );
    if (!( ob = find_object( fn ))) {
        add_failed_mess( "No such object: " + fn + "\n" );
        return 0;
    }
    if ( fn2 ) {
        fn2 = this_player()->get_path( fn2 );
        if (!( ob2 = find_object( fn2 ))) {
            add_failed_mess( "No such object: " + fn2 + "\n" );
            return 0;
        }
    }
    fn = file_name(ob);
    write(fn + "\n" + inherith(fn, "  ", fn2 ));
    return 1;
}
private string inherith(string ob, string ind, string leaf) {
    string *fn, rtn = "", s;
    int i;
    if(!load_object(ob))
      return ind + "unable to find " + ob + "\n";
    fn = inherit_list(find_object(ob));
    for (i = 0; i < sizeof(fn); i++) {
        if (leaf && (find_object(fn[i]) == find_object(leaf))) {
            rtn += ind + fn[i] + "\n";
        } else {
            s = inherith(fn[i], ind + "  ", leaf);
            if (!leaf || (s != "")) {
                rtn += ind + fn[i] + "\n" + s;
            }
        }
    }
    return rtn;
}
int wiz_present_cmd( mixed indirect_obs ) {
    object fo, fo2;
    string fn, fn2;
    if ( !arrayp( indirect_obs ) ) {
        return 0;
    }
    if ( sizeof( indirect_obs ) < 1 ) {
        return 0;
    }
    if ( arrayp( indirect_obs[0] ) ) {
        fo = indirect_obs[0][0];
        if ( sizeof( indirect_obs ) == 2 ) {
            fo2 = indirect_obs[ 1 ][ 0 ];
        }
    }
    else {
        fo = indirect_obs[ 0 ];
        if ( sizeof( indirect_obs ) == 2 ) {
            fo2 = indirect_obs[ 1 ];
        }
    }
    if ( fo ) {
        fn = file_name( fo );
    }
    if ( fo2 ) {
        fn2 = file_name( fo2 );
    }
    debug_printf( "%O, %O\n", fn, fn2 );
    return cmd( fn, fn2 );
}
public mixed *query_patterns() {
    return ({
              "<word> [with] <word>", (: cmd( $4[0], $4[1] ) :),
              "<word>", (: cmd( $4[0], 0 ) :),
              "<indirect:wiz-present> with <indirect:wiz-present>", (: wiz_present_cmd( $1 ) :),
              "<indirect:wiz-present>", (: wiz_present_cmd( $1 ) :),
    });
}

==================================================
FILE: creator/inv.c
==================================================

#include <creator.h>
inherit "/cmds/base";
protected int cmd( object *obs ) {
    object ob;
    object *inventory;
    foreach( ob in obs ) {
        inventory = filter( all_inventory( ob ),
          (: reference_allowed( $1, $( this_player() ) ) :) );
        tell_object( this_player(), "Inv of " + WIZ_PRESENT->desc_object( ob ) +
          " in " + WIZ_PRESENT->desc_object(
            environment( ob ) ) + ":\n" );
        tell_object( this_player(), implode( map( inventory,
              (: "  " + WIZ_PRESENT->desc_f_object( $1 ) :) ), "\n" ) + "\n" );
        if ( !sizeof( inventory ) ) {
            continue;
        }
    }
    return 1;
}
mixed *query_patterns() {
    return ({ "[of] <indirect:wiz-present>", (: cmd($1) :) });
}

==================================================
FILE: creator/jumps.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
object find_location(string str) {
   if (find_object(str)) {
      return find_object(str);
   }
   return load_object(str);
}
int do_add_jump(string from, string to) {
   object from_ob;
   object to_ob;
   from_ob = find_location(from);
   to_ob = find_location(to);
   if (!from_ob) {
      add_failed_mess("The from location does not exist.\n");
      return 0;
   }
   if (!to_ob) {
      add_failed_mess("The to location does not exist.\n");
      return 0;
   }
   PLAYTESTER_HAND->add_jump_point(from, to);
   write("You added the jump point from " + from + " to " + to + ".\n");
   return 1;
}
int do_path_list() {
   string str;
   string from;
   string* dest;
   str = "";
   foreach (from, dest in PLAYTESTER_HAND->query_jump_points()) {
      str += from + ": " + query_multiple_short(dest) + ".\n";
   }
   write(str);
   return 1;
}
int do_remove_jump(string from, string to) {
   string* dests;
   dests = PLAYTESTER_HAND->query_jump_destination(from);
   if (!sizeof(dests)) {
      add_failed_mess("There are no destiations from " + from + ".\n");
      return 0;
   }
   if (member_array(to, dests) == -1) {
      add_failed_mess("Unable to remove a jump from " + from + " to " +
                      to + ".\nValid to's are: " +
                      query_multiple_short(dests) + ".\n");
      return 0;
   }
   PLAYTESTER_HAND->remove_jump_point(from, to);
   write("Removed the jump from " + from + " to " + to + ".\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "add <string'from'> <string'to'>", (: do_add_jump($4[0], $4[1]) :),
        "remove <string'from'> <string'to'>", (: do_remove_jump($4[0], $4[1]) :),
        "creator list", (: do_path_list :) });
}

==================================================
FILE: creator/loc_alcmd.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  int flags, i, j, pos;
  mixed flag_types;
  object *obs;
  string *coms, flag;
  mixed *junk;
  if (!str) str = "";
  flag_types = ({ "priority", "star", "function", "object" });
  while (strlen(str) && str[0] == '-') {
    if (sscanf(str, "-%s %s", flag, str) != 2) {
      flag = str[1..100];
      str = "";
    }
    i = member_array(flag, flag_types, 1);
    if (i != -1) {
      flags |= 1 << i;
    }
  }
  if (!flags) {
    if (!strlen(str))
      coms = actions_defined(this_player());
    else {
      obs = WIZ_PRESENT->wiz_present(str, this_player());
      if (!sizeof(obs)) {
        notify_fail("Could not find "+str+" to get the commands off.\n");
        return 0;
      }
      coms = map(obs, (: actions_defined($1) :));
    }
  } else {
    if (!strlen(str))
      junk = actions_defined(0, 0, flags);
    else {
      obs = WIZ_PRESENT->wiz_present(str, this_object());
      if (!sizeof(obs)) {
        notify_fail("Could not find "+str+" to get the commands off.\n");
        return 0;
      }
      junk = map(obs, (: actions_defined($1, 0, $(flags)) :));
    }
    coms = ({ });
    for (i=1;i<sizeof(junk);i+=2) {
      pos = 0;
      str = junk[i-1];
      if ((flags&0xc) == 0xc) {
        str = WIZ_PRESENT->desc_f_object(junk[i][0])+"->"+junk[i][1]+":"+str;
        pos += 2;
      } else if (flags&0x8) {
        str = WIZ_PRESENT->desc_object(junk[i][0])+":"+str;
        pos++;
      } else if (flags&0x4) {
        str = junk[i][0]+"%"+str;
        pos++;
      }
      if (flags&0x2) {
        if (j = junk[i][pos]) {
          if (strlen(junk[i-1]) == j)
            str += "*";
          else {
            j = strlen(str)-junk[i][pos];
            str = str[0..j]+"*"+str[j+1..10000];
          }
        }
        pos++;
      }
      if (flags&1) {
        str += "|"+junk[i][pos];
      }
      coms += ({ str });
    }
  }
  this_player()->more_string( sprintf( "%-#*s\n",
      (int)this_player()->query_cols(),
      implode( coms, "\n" ) ), "Commands" );
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/lpc_info.c
==================================================

mixed cmd(string str) {
  printf("%s", lpc_info());
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/mail.c
==================================================

#include <mail.h>
mixed cmd(string str) {
  return (int)MAIL_TRACK->mail(str);
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/malloc.c
==================================================

mixed cmd(string str) {
  printf("%s", malloc_status());
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/mem_stat.c
==================================================

#include <creator.h>
#define OBJ_LIMIT 50
#define TP this_player()
inherit "/cmds/base";
string help();
mixed cmd(string str) {
  int memtotal, limit, i = TP->query_cols() -7 -1, j;
  string ret, str2, str3;
   object *objlist;
  if (!str || str == "")
    return notify_fail(help());
  while (strlen(str) && str[0] == ' ')
    str = str[1..];
  if (sscanf(str, "-%s%d %s", str3, limit, str2) == 3) {
    if (str3[0..0] != "l")
      return notify_fail("Error: Only valid character following '-' is 'l' at "
                         "this time.\n");
    str = str2;
  }
  seteuid(geteuid(TP));
  objlist = WIZ_PRESENT->wiz_present(str, TP);
  if (!arrayp(objlist) || sizeof(objlist) < 1) {
    mixed *filelist;
    str = TP->get_path(str);
    notify_fail("Unable to find any objects or files corresponding"
                " to the given name.\n");
    if (sizeof(filelist = TP->get_files(str)) > 0) {
      filelist = filter(filelist, (: (sizeof($1) > 2) &&
                                   ($1[sizeof($1) - 2..] == ".c") :));
      if (sizeof(filelist) < 1)
        return 0;
      filelist = filter(filelist, (: find_object($1) :));
      objlist = map(filelist, (: find_object($1) :));
    } else
      return 0;
  }
  ret = sprintf("%-"+ i +"s %-7s\n", "Object name", "Memory");
  ret += sprintf("%-"+ i +"s %-7s\n", "------------", "-------");
  if (!limit)
    limit = OBJ_LIMIT;
  if (limit > sizeof(objlist))
    limit = sizeof(objlist);
  if (limit == 1)
    ret += sprintf("%-"+ i +"."+ i +"s %7.7d\n",
                   WIZ_PRESENT->desc_f_object(objlist[sizeof(objlist) - 1]),
                   memory_info(objlist[sizeof(objlist) - 1]));
  else
    for (j = 0; j < limit; j++)
      ret += sprintf("%-"+ i +"."+ i +"s %7.7d\n",
                     WIZ_PRESENT->desc_f_object(objlist[j]),
                     memory_info(objlist[j]));
  if (sizeof(objlist) > 1) {
    for (j = 0; j < sizeof(objlist); j++)
      memtotal += memory_info(objlist[j]);
    ret += sprintf("%-"+ i +"."+ i +"s %7.7s\n",
                   "", "=======");
    ret += sprintf("%-"+ i +"."+ i +"s %7.7d\n",
                   "Total memory used for all "+ sizeof(objlist) +
                   " object(s):", memtotal);
  }
  TP->more_string(ret);
  return 1;
}
string help() {
  return "Usage: memstat [-l<number>] [<filename(s)>|<wiz_present syntax>]\n\n"
"Memstat lists the guestimated amount of memory the specified object(s) use. "
"Using the -l option, a maximum amount of objects to be listed may be "
"specified otherwise a default limit of "+ OBJ_LIMIT +" objects are listed. "
"Paths including wildcards are taken as a way of specifying more than one "
"file.\n";
}
mixed *query_patterns() {
    return ({ "<string>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: creator/meteor.c
==================================================

#include <playerinfo.h>
inherit "/cmds/base";
mixed cmd(string words) {
  string player, reason;
  object ob;
  if(this_player()->query_name() == "macchirton") {
    return notify_fail("You cannot use meteor.\n");
  }
  if(!words || sscanf(words, "%s %s", player, reason ) != 2) {
    return notify_fail("Usage: meteor <player> <reason>\n");
  }
  ob = find_player(this_player()->expand_nickname(player));
  if(!ob) {
    return notify_fail(player+" not found!\n");
  }
  write("Warning: This is not to be used for pranks.  If you "
    "do not have a valid reason to use this, do not use it!  "
    "Are you quite sure you wish to proceed? (y|n): ");
  input_to("are_sure", ob, reason);
  return 1;
}
void are_sure(string str, object ob, string reason) {
  string gender = "boy";
  if(this_player()->query_gender() == 2) {
    gender = "girl";
  }
  str = lower_case(str);
  if(str[0] != 'y') {
    write("Good little "+gender+"!  Now go play nice with "
      +ob->one_short()+".\n");
    return;
  }
  PLAYERINFO_HANDLER->add_entry(this_player(),
                                ob->query_name(),
                                "meteor",
                                reason);
  log_file("NUKE", "%s: %s nuked %s: %s\n", ctime(time()),
    this_player()->query_short(), ob->query_short(), reason);
  shout("You see a very large %^YELLOW%^meteor%^RESET%^ up in the sky.\n");
  write("Nuking player "+ob->query_name()+".\n");
  call_out("nuke2", 2, ob);
}
void nuke2(object ob) {
  shout("The %^YELLOW%^meteor%^RESET%^ rushes towards the ground.\n");
  tell_object(ob, "It looks like it's heading for you.\n");
  call_out("nuke3", 5, ob);
}
void nuke3(object ob) {
  tell_object(ob, "The %^YELLOW%^meteor%^RESET%^ hits you ......"+
    "%^RED%^WALLOP.%^RESET%^\n");
  shout(ob->query_cap_name()+" has been struck by a meteor.\n"+
        capitalize(ob->query_pronoun())+" is no more.\n");
  ob->save();
  ob->quit();
}

==================================================
FILE: creator/mk_dir.c
==================================================

mixed cmd(string str) {
   seteuid(geteuid(this_player()));
   if (!str || str == "") {
      notify_fail("Make what directory?\n");
      return 0;
      }
   str = this_player()->get_path(str);
   str = replace(str, " ", "_");
   if (!str)
      return 1;
   if (file_size(str) != -1) {
      notify_fail(str + " already exists.\n");
      return 0;
      }
   if (!mkdir(str)) {
      notify_fail("Couldn't make dir.\n");
      return 0;
   }
   write("Ok.\n");
   return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/mo_re.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  object *things;
  seteuid(geteuid(this_player()));
  if(!str) {
    notify_fail("More which file(s)/object?\n");
    return 0;
  }
  if(sizeof(things = WIZ_PRESENT->wiz_present(str, this_player()))) {
    str = file_name(things[0]);
    sscanf(str, "%s#%*d", str);
    if (file_size(str) <= 0)
      str += ".c";
  }
  return this_player()->more_file(str);
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/mobs.c
==================================================

#include <creator.h>
#define COUNT 10
int cmd(string arg){
  mapping m = ([]);
  string *obs, ob, ret = "";
  if(!master()->query_senior(this_player()->query_name()))
    return 0;
  switch(arg){
  case "all":
    objects((:$(m)[base_name($1)]++,reset_eval_cost():));
    break;
  case "inside":
    objects((:environment($1) && $(m)[base_name($1)]++:));
    break;
  default:
    objects((:environment($1) && living($1) &&
       $(m)[base_name($1)]++:));
  }
  obs = keys(filter(m, (:$2 > COUNT:)));
  foreach(ob in obs){
    object *things, thing;
    m = ([]);
    reset_eval_cost();
    if(arg != "all")
      things = filter(children(ob), (:environment($1):));
    else
      things = children(ob);
    foreach(thing in things)
      m[environment(thing)]++;
    m = filter(m, (:$2 > COUNT:));
    if(sizeof(m)){
      object *rooms = keys(m);
      foreach(thing in rooms){
        ret += sprintf("%3d %s in %s\n", m[thing],
                       WIZ_PRESENT->desc_f_object(find_object(ob)),
                       WIZ_PRESENT->desc_f_object(thing));
      }
    }
  }
  ob = sprintf("/w/%s/mobs", this_player()->query_name());
  printf("Saving to %s.\n", ob);
  seteuid(geteuid(this_player()));
  unguarded((:rm($(ob)),write_file($(ob), $(ret)):));
  return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
      "{all|inside}", (: cmd($4[0]) :) });
}
string help() {
  return "Shows groups of NPCs of one kind that are in the same room.";
}

==================================================
FILE: creator/mudinfo.c
==================================================

inherit "/cmds/base";
#ifndef __COMPILER__
#define __COMPILER__     "probably gcc"
#define __OPTIMIZATION__ "bugged driver?"
#endif
#define WIDTH 15
#define PAD(x,y)      sprintf("%-*s: %s\n", WIDTH, x,"" + y)
varargs string pretty_time(int tim, int len);
private nosave int num_obs;
mixed cmd(string str) {
   mapping r;
   float cpu;
   string name, cc, tmp;
   int *ltype;
   name = capitalize(mud_name()) + "   (" + query_host_name() + " " +
          __PORT__ + ")";
   cc = __COMPILER__ + "   (" + __OPTIMIZATION__ + ")";
   r = rusage();
   cpu = ((r["utime"] + r["stime"]) / uptime() / 10.0);
   num_obs = 0;
   objects((: num_obs++ :));
   ltype = implode(users(), (:$1[compressedp($2)]++, $1:), ({0,0}));
   tmp = PAD("Mud name", name) +
         PAD("Driver", __VERSION__) +
         PAD("Architecture", __ARCH__) +
         PAD("Compiler", cc) +
         PAD("Driver uptime", pretty_time(uptime(), 4)) +
         PAD("Avg Cpu usage", sprintf("%4.2f%%",cpu)) +
         PAD("Load Average", query_load_average()) +
         PAD("No of users", sizeof(users())) +
         PAD("Using MCCP", ltype[1]) +
         PAD("Plain telnet", ltype[0]) +
         PAD("Named Livings", sizeof(named_livings())) +
         PAD("Objects", num_obs) +
         PAD("Call Outs", sizeof(call_out_info()) + " pending.") +
         PAD("Memory usage", memory_info());
   tell_object(this_player(), tmp);
   return 1;
}
varargs string pretty_time(int tim, int len) {
   int num;
   string *bits, tmp;
   if(!len)
     len = 99999;
   bits = ({ });
   if(tim >= 60*60*24 && sizeof(bits) < len)
      bits += ({ (num=tim/(60*60*24))+" day"+(num==1?"":"s") });
   if(tim >= 60*60 && tim%(60*60*24) && sizeof(bits) < len)
      bits += ({ (num=(tim/(60*60))%24)+" hour"+(num==1?"":"s") });
   if(tim >= 60 && tim%(60*60) && sizeof(bits) <len)
      bits += ({ (num=(tim/60)%60)+" minute"+(num==1?"":"s") });
   if(tim%60 && sizeof(bits) <len)
      bits += ({ (num=tim%60)+" second"+(num==1?"":"s") });
   for(len =0; len<sizeof(bits); len++)
      if(sscanf(bits[len],"%d %s", num, tmp) == 2 && num == 0)
         bits[len] = 0;
   return implode(bits, ", ");
}

==================================================
FILE: creator/multipl_ayer.c
==================================================

#include <creator.h>
#include <player.h>
inherit "/cmds/base";
varargs int cmd(string command, string name, string what, string extra) {
  switch (command) {
  case "add":
    if (!call_other(PLAYER_MULTIPLAYER_HANDLER, "add_" + what, name, extra)) {
      printf("\"%s\"%s isn't known here.\n", name, (extra ? " and/or \"" +
                extra + "\"" : ""));
    } else {
      if (what == "allowed") {
        printf("\"%s\" and \"%s\" added as allowed together.\n", name, extra);
      } else {
        printf("\"%s\" added.\n", name);
      }
    }
    break;
  case "del":
    if(!call_other(PLAYER_MULTIPLAYER_HANDLER, "delete_" + what, name)) {
      printf("\"%s\" isn't on the list.\n", name);
    } else {
      printf("\"%s\" deleted.\n", name);
    }
    break;
  case "log":
    PLAYER_MULTIPLAYER_HANDLER->mark_log(name, extra);
    if (extra) {
      printf("Added \"multiplay\" playerinfo event for \"%s\": \"%s\".\n",
           name, extra);
    } else {
      printf("Marked \"multiplay\" playerinfo events for \"%s\" as handled.\n",
           name);
    }
    break;
  case "list":
    write("The list currently consists of: $I$5=\n" +
          query_multiple_short(sort_array(call_other(PLAYER_MULTIPLAYER_HANDLER,
                                                     "query_" + what),
                                          (: strcmp($1, $2) :)))
          + "$I$0=\n");
    break;
  case "site":
    if(find_player(name)) {
      name = query_ip_number(find_player(name));
    }
    if("/secure/bastards"->change_multi(name, 1, time() + 3600)) {
      write("Site " + name + " has been permitted for multiplayers "
            "for the next hour.\n");
    } else {
      write("Error permitting site " + name + " for multiplayers.\n");
    }
    break;
  default:
    write("Unknown option.\n");
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "[list]",  (: cmd("list", 0, "gits") :),
              "{list allow}", (: cmd("list", 0, "allowed") :),
            "add git <word'name'>", (: cmd("add", $4[0], "git") :),
            "add allowed <word'first name'> <word'second name'>",
            (: cmd("add", $4[0], "allowed", $4[1]) :),
            "allow site <word'address|name'>", (: cmd("site", $4[0], "allowed") :),
            "del allowed <word'name'>", (: cmd("del", $4[0], "allowed") :),
            "log <word'name'>", (: cmd("log", $4[0], "git") :),
            "log <word'name'> <string'log text'>", (: cmd("log", $4[0], "git",
                                                       implode($4[1..], " ")) :)
         });
}

==================================================
FILE: creator/mv.c
==================================================

mixed cmd(string str) {
  int loop, fs, pos, multi;
  string *filenames, dest, *fnames, trash1, trash2, trash3, trash4;
  string path, *temp, start, end;
  seteuid(geteuid(this_player()));
  if ((!str) || (sscanf(str, "%s %s", trash1, trash2) != 2))
    return notify_fail("Usage : mv file [file|dir...]\n");
  fnames = explode(str, " ");
  filenames = this_player()->get_files(implode(fnames[0..sizeof(fnames) -2], " "));
  if(!sizeof(filenames))
    return notify_fail("Usage : mv file [file|dir...]\n");
  dest = fnames[sizeof(fnames) - 1];
  dest = this_player()->get_path(dest);
  if (!dest) {
    write("No destination\n");
    return 1;
  }
  if (sscanf(str, "%s*%s %s*%s", trash1, trash2, trash3, trash4) == 4) {
    multi = 1;
    temp = explode(dest, "/");
    path = implode(temp[0..sizeof(temp) - 2], "/") + "/";
    sscanf(temp[sizeof(temp)-1], "%s*%s", start, end);
    temp = explode(implode(fnames[0..sizeof(fnames) -2], " "), "/");
    sscanf(temp[sizeof(temp)-1], "%s*%s", trash1, trash2);
    pos = strlen(trash1);
  }
  for (loop = 0; loop < sizeof(filenames); loop++) {
    str = filenames[loop];
    if(file_size(str) == -1) {
      write("No such file : " + str + "\n");
      continue;
    }
    if(multi) {
      temp = explode(str, "/");
      trash1 = temp[sizeof(temp)-1];
      fs  = strlen(trash1) - strlen(trash2) - 1;
      dest = path + start + trash1[pos..fs] + end;
      fs = file_size(dest);
    }
    else {
      fs = file_size(dest);
      if(fs == -2) {
        string *names;
        names = explode(str, "/");
        fs = file_size(dest + "/" + names[sizeof(names) - 1]);
      }
    }
    if(fs != -1) {
      write("File exists : " + dest + "\n");
      continue;
    }
    rename(str, dest);
  }
  write("Ok.\n");
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/net_stat.c
==================================================

#include <creator.h>
inherit "/cmds/base";
#include <peopler.h>
#include <creator.h>
mixed cmd(string str) {
   mixed *stuff;
   stuff = this_player()->query_property("netstat list");
   if (!stuff) {
      stuff = N_DEFAULT;
   }
   return PEOPLER->do_command(stuff, str);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/netdups.c
==================================================

#include <creator.h>
#include <peopler.h>
int cmd(string str) {
   mixed *bing;
   bing = this_player()->query_property("netdups list");
   if (!bing) {
      bing = ND_DEFAULT;
   }
   return PEOPLER->do_command(bing, str,
      (: query_ip_number($1) == 0 || query_ip_number($2) == 0 ||
         strcmp(query_ip_number($1), query_ip_number($2)) :),
      1);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/nslookup.c
==================================================

inherit "/cmds/creator/host";

==================================================
FILE: creator/ob_ject.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  int i, j, cols;
  string obvarname, start, end;
  mixed *names, *objects;
  if (str) {
    if (sscanf(str, "%s=%s", obvarname, str) != 2)
      return notify_fail("USAGE: object ObVarName=ObjectSpec\n");
    notify_fail("Can't find object.\n");
    objects = WIZ_PRESENT->wiz_present(str, this_player());
    if (!sizeof(objects))
      return 0;
    if (sizeof(objects) > 1)
      write("Only using first object of several matched.\n");
    this_player()->set_obvar(obvarname, objects[0]);
    write("Var "+obvarname+" now attached to "+
        WIZ_PRESENT->desc_object(objects[0])+".\n");
    return 1;
  }
  objects = m_values((mapping)this_player()->get_obvars());
  names = m_indices((mapping)this_player()->get_obvars());
  j = sizeof(objects);
  cols = this_player()->query_cols();
  for (i=0; i<sizeof(objects); i++) {
    if (!objects[i]) {
      j--;
      this_player()->del_obvar(names[i]);
      break;
    }
    if (objectp(names[i]))
      start = WIZ_PRESENT->desc_object(names[i]);
    else
      start = sprintf("%O", names[i]);
    if (objectp(objects[i]))
      end = WIZ_PRESENT->desc_object(objects[i]);
    else {
      end = sprintf("%O", objects[i]);
      end = replace(end, "\n", "");
    }
    printf("%s; %*-=s\n", start, cols-strlen(start)-2, end);
  }
  if (!j) write("No obvars set.\n");
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/on_line.c
==================================================

inherit "/cmds/base";
string idle_time(object person) {
  int hours, mins, secs;
  string s, m, h;
  secs = query_idle(person);
  mins = secs / 60;
  secs %= 60;
  hours = mins / 60;
  mins %= 60;
  s = ("0"+secs)[<2..<1];
  m = ("0"+mins)[<2..<1];
  if ( !hours )  {
    return " (idle: "+m+":"+s+")";
  }
  h = ("0"+hours)[<2..<1];
  return " (idle: "+h+":"+m+":"+s+")";
}
int cmd( int show_idle ) {
  object *people, person;
  string *cre, *invis, *director, *trustee, bing, obtyp;
  cre = ({ });
  invis = ({ });
  director = ({ });
  trustee = ({ });
  people = filter_array( users(), (: $1->query_creator() :) );
  people = people - this_player()->query_ignoring( people );
  people = sort_array( people,
    (: strcmp( $1->query_name(), $2->query_name() ) :) );
  foreach( person in people )  {
    bing = person->query_cap_name();
    if ( show_idle && query_idle( person ) > 120 )  {
      bing += idle_time( person );
    }
    if (!this_player()->query_property("nod")) {
      obtyp = person->query_object_type();
        switch(obtyp) {
        case "X":
           break;
        case " ":
           break;
        case "C":
           bing += "(%^CYAN%^C%^RESET%^)";
           if ( "/d/liaison/master"->query_member((string)person->query_name()))
              bing += "(%^YELLOW%^l%^RESET%^)";
           break;
        case "S":
           bing += "(%^BOLD%^%^CYAN%^S%^RESET%^)";
           if ( "/d/liaison/master"->query_member((string)person->query_name()))
             bing += "(%^YELLOW%^l%^RESET%^)";
           break;
        case "T":
           bing += "(%^BOLD%^%^RED%^T%^RESET%^)";
           if ( "/d/liaison/master"->query_member((string)person->query_name()))
             bing += "(%^YELLOW%^l%^RESET%^)";
           break;
        case "D":
           bing += "(%^RED%^D%^RESET%^)";
           if ( "/d/liaison/master"->query_member((string)person->query_name()))
             bing += "(%^YELLOW%^l%^RESET%^)";
           break;
        default:
           break;
      }
    }
    switch( person->query_invis()  )  {
      case 0:
        cre += ({ bing });
        break;
      case 1:
        invis += ({ bing });
        break;
      case 2:
        director += ({ bing });
        break;
      default:
        trustee += ({ bing });
        break;
    }
  }
  if(sizeof(cre)) {
    tell_object(this_player(),
      "/global/events"->convert_message("$I$2=%^GREEN%^"
      "Visible%^RESET%^: "+query_multiple_short(cre)+".\n"));
  }
  if(sizeof(invis)) {
    tell_object(this_player(),
      "/global/events"->convert_message("$I$2=%^CYAN%^"
      "Invisible%^RESET%^: "+query_multiple_short(invis)+".\n"));
  }
  if(sizeof(director)) {
    tell_object(this_player(),
      "/global/events"->convert_message("$I$2=%^YELLOW%^Director "
      "Invisible%^RESET%^: "+query_multiple_short(director)+".\n"));
  }
  if(sizeof(trustee)) {
    tell_object(this_player(),
      "/global/events"->convert_message("$I$2=%^RED%^Trustee "
      "Invisible%^RESET%^: "+query_multiple_short(trustee)+".\n"));
  }
  return 1;
}
mixed *query_patterns() {
    return ({ "", (: cmd(1) :),
              "noidle", (: cmd(0) :) });
}

==================================================
FILE: creator/panic.c
==================================================

#include <panic.h>
inherit "/cmds/base";
int cmd( ) {
    return 0;
  PANIC_HANDLER->do_startup(previous_object());
  this_player()->add_succeeded_mess(this_object(),
                  "$N panic$s hopefully.", ({ }) );
  return 1;
}
mixed *query_pattern() {
  return ({ "", (: cmd() :) });
}

==================================================
FILE: creator/path_of.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  object *ov, ob;
  if(strsrch(str, "in everyone") != -1)
    return notify_fail("Please don't do that.  You've been asked not to "
      "and it causes lag.\n");
  notify_fail("Pathof what?\n");
  ov = WIZ_PRESENT->wiz_present(str, this_player());
  if (!sizeof(ov)) return 0;
  foreach (ob in ov) {
    if (!objectp(ob)) continue;
    write("Path of " + WIZ_PRESENT->desc_object(ob) + " in " +
        WIZ_PRESENT->desc_object(environment(ob)) + ":\n");
    write(file_name(ob)+ "\n");
  }
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/pe_ople.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#include <peopler.h>
int num_sort(object first, object second) {
  int one, two;
  one = first->query_level();
  two = second->query_level();
  if(one < two)
    return 1;
  if(one > two)
    return -1;
  return 0;
}
int guild_sort(object first, object second) {
  object g1, g2;
  g1 = first->query_guild_ob();
  g2 = second->query_guild_ob();
  return strcmp(g1 ? g1->query_name() : "",
                g2 ? g2->query_name() : "");
}
int domain_sort(object first, object second) {
  object d1, d2;
  d1 = environment(first);
  d2 = environment(second);
  return strcmp(d1 ? file_name(d1) : "", d2 ? file_name(d2) : "");
}
int age_sort(object first, object second) {
  int one, two;
  one = first->query_time_on();
  two = second->query_time_on();
  if(one < two)
    return -1;
  if(one > two)
    return 1;
  return 0;
}
mixed cmd(string str) {
  mixed *stuff;
  string bit, *bits;
  function sort_func;
  stuff = this_player()->query_property("people list");
  if (!stuff)
    stuff = P_DEFAULT;
  if(str) {
    bits = explode(str, " ");
    str = 0;
    foreach(bit in bits) {
      switch(bit) {
      case "-l":
        sort_func = (: num_sort :);
        break;
      case "-g":
        sort_func = (: guild_sort :);
        break;
      case "-a":
        sort_func = (: age_sort :);
        break;
      case "-d":
        sort_func = (: domain_sort :);
        break;
      default:
        if(str)
          str += " " + bit;
        else
          str = bit;
      }
    }
  }
  return (int)PEOPLER->do_command(stuff, str, sort_func);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/perm_it.c
==================================================

#include <parser.h>
#include <access.h>
#include <player_handler.h>
#include <error_handler.h>
inherit "/cmds/base";
#define READ_MASK 1
#define WRITE_MASK 2
#define GRANT_MASK 4
#define LOCK_MASK 8
int help();
mixed cmd(string command, string euid, string path) {
  string* euids;
  string* bing;
  if (this_player() != this_player(1)) {
    return 0;
  }
  seteuid("Root");
  notify_fail("Something went wrong.\n");
  path = (string)this_player()->get_path(path);
  switch(command) {
  case "assign" :
    if (file_size(path) != -2) {
       notify_fail("The path " + path + " does not exist.\n");
       return 0;
    }
    euids = explode(replace_string(euid, " ", ""), ",") - ({ "none" });
    bing = filter(euids, (: !PLAYER_HANDLER->test_creator($1) &&
                            $1 != ERROR_ASSIGNED_NO_ONE:));
    if (sizeof(bing)) {
       notify_fail("The people " + query_multiple_short(bing) +
                   " are not creators.\n");
       return 0;
    }
    if ((int)master()->assign_people_to_directory(path, euids)) {
       add_succeeded_mess("Assigned the directory " + path +
                         " to " + query_multiple_short(euids) + ".\n");
       return 1;
    }
    notify_fail("Unable to assign the directory, not creator names?\n");
    return 0;
  case "read":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, READ_MASK))
      return notify_fail("You do not have permission to add read access.\n");
    return (int)master()->add_read_permission(euid, path);
    break;
  case "write":
      if (!master()->high_programmer(previous_object(-1)) &&
          !master()->valid_grant(this_player(), path, WRITE_MASK))
        return notify_fail("You do not have permission to add write "
                           "access.\n");
      return (int)master()->add_write_permission(euid, path);
      break;
  case "grant":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, GRANT_MASK))
      return notify_fail("You do not have permission to add grant access.\n");
    return (int)master()->add_grant_permission(euid, path);
    break;
  case "lock":
    if (!master()->query_lord(previous_object(-1)))
      return notify_fail("You don't have permission to lock paths.\n");
    if ((path[0..2] != "/d/") &&
        !master()->high_programmer(previous_object(-1)))
      return notify_fail("You don't have permission to lock paths there.\n");
    return (int)master()->lock_path(path);
  case "noread":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, READ_MASK))
      return notify_fail("You do not have permission to remove read "
                         "access.\n");
    return (int)master()->remove_read_permission(euid, path);
  break;
  case "nowrite":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, WRITE_MASK))
      return notify_fail("You do not have permission to remove write "
                         "access.\n");
    return (int)master()->remove_write_permission(euid, path);
    break;
  case "nogrant":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, GRANT_MASK))
      return notify_fail("You do not have permission to remove grant "
                         "access.\n");
    return (int)master()->remove_grant_permission(euid, path);
    break;
  case "unlock":
    if (!master()->query_lord(previous_object(-1)))
      return notify_fail("You don't have permission to lock paths.\n");
    if ((path[0..2] != "/d/") &&
        !master()->high_programmer(previous_object(-1)))
      return notify_fail("You don't have permission to lock paths there.\n");
    return (int)master()->unlock_path(path);
    break;
  default:
    return help();
  }
}
int do_directory_summary(string dir) {
   mapping assignments;
   mapping new_assignments;
   string* paths;
   string path;
   string ret;
   string domain;
   assignments = master()->query_directory_assignments();
   foreach (domain in master()->query_domains()) {
      ret = catch(new_assignments = ("/d/" + domain + "/master")->query_directory_assignments());
      if (sizeof(new_assignments)) {
         assignments += new_assignments;
      }
   }
   if (sizeof (dir)) {
     assignments = filter (assignments, (: strsrch ($1, $(dir)) != -1 :));
  }
   paths = sort_array( keys( assignments ), 1 );
   ret = sprintf("%40-s Assigned To\n", "Path");
   foreach (path in paths) {
      ret += sprintf("%-40s %s\n", path, query_multiple_short(assignments[path]));
   }
   write("$P$Directory Assignments$P$" + ret);
   return 1;
}
int do_directory_update(string dir) {
   mapping assignments;
   mapping new_assignments;
   string* paths;
   string path;
   string ret;
   string domain;
   string* bits;
   assignments = master()->query_directory_assignments();
   foreach (domain in master()->query_domains()) {
      ret = catch(new_assignments = ("/d/" + domain + "/master")->query_directory_assignments());
      if (sizeof(new_assignments)) {
         assignments += new_assignments;
      }
   }
   if (sizeof (dir)) {
     assignments = filter (assignments, (: strsrch ($1, $(dir)) != -1 :));
  }
   paths = sort_array( keys( assignments ), 0 );
   foreach (path in paths) {
      if (sizeof(assignments[path])) {
         bits = explode(path, "/");
         if (bits[0] == "d") {
           ERROR_HANDLER->do_update_directory_assignment(("/d/" + bits[1] + "/master")->query_lord(), assignments[path][0], path, (: 1 :));
         } else {
           ERROR_HANDLER->do_update_directory_assignment("nobody", assignments[path][0], path, (: 1 :));
         }
         write("Updated " + path + " to " + assignments[path][0] + "\n");
      }
   }
   write("$P$Directory Assignments$P$" + ret);
   return 1;
}
int do_summary(string str) {
  mapping perms;
  string *paths, *euids, ret, creator;
  int i, j, k;
  perms = (mapping)master()->query_permissions();
  if (str) {
    if (!perms[str]) {
      if (!PLAYER_HANDLER->test_user(str) && !master()->valid_euid(str)) {
        write("There are no permissions for "+str+".\n");
        return 1;
      } else {
        creator = str;
      }
    } else {
      perms = ([ str : perms[str] ]);
    }
  }
  paths = sort_array( keys( perms ), 1 );
  if (!sizeof(paths)) {
    ret = "No permissions set.\n";
  } else {
    ret = sprintf("%11-s    Path\n", "Euid");
  }
  for (i=0;i<sizeof(paths);i++) {
    euids = keys(perms[paths[i]]);
    for (j=0;j<sizeof(euids);j++) {
      if (!creator || (euids[j] == creator ) ) {
        k = perms[paths[i]][euids[j]];
        if (k & LOCK_MASK)
          ret += sprintf("%11-s LCK %s\n", euids[j], paths[i]);
        else
          ret += sprintf("%11-s %c%c%c %s\n", euids[j],(k & READ_MASK?'R':' '),
                         (k & WRITE_MASK?'W':' '), (k & GRANT_MASK?'G':' '),
                         paths[i]);
      }
    }
  }
  this_player()->more_string( ret, "Permissions", 1 );
  return 1;
}
int do_tidy() {
   int i, j, perm, same;
   string path, creator, *bits;
   mapping perms, euids, others;
   if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
      event( users(), "inform", "illegal attempt to call do_tidy() by "+
            (string)this_player()->query_name(), "cheat" );
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +": illegal "
                   "attempt to call do_tidy() by "+
                   (string)this_player()->query_name() +"\n" :));
      return notify_fail( "Failed.\n" );
   }
   perms = (mapping)master()->query_permissions();
   foreach( path in keys( perms ) ) {
      euids = perms[ path ];
      foreach( creator in keys( euids ) ) {
         perm = euids[ creator ];
         if ( !PLAYER_HANDLER->test_creator( creator ) &&
              !master()->valid_euid( creator ) ) {
            write( "No creator: "+ creator +".\n" );
            if ( perm & READ_MASK )
               master()->remove_read_permission( creator, path );
            if ( perm & WRITE_MASK )
               master()->remove_write_permission( creator, path );
            if ( perm & GRANT_MASK )
               master()->remove_grant_permission( creator, path );
            continue;
         }
         if ( path == "/" )
            continue;
         same = perms[ "/" ][ creator ] & perm;
         if ( same ) {
            write( "Access to / supercedes "+ path +" for "+ creator +".\n" );
            if ( same & READ_MASK )
               master()->remove_read_permission( creator, path );
            if ( same & WRITE_MASK )
               master()->remove_write_permission( creator, path );
            if ( same & GRANT_MASK )
               master()->remove_grant_permission( creator, path );
            continue;
         }
         bits = explode( path, "/" );
         j = sizeof( bits ) - 1;
         for ( i = 0; i < j; i++ ) {
            others = perms[ "/"+ implode( bits[ 0 .. i ], "/" ) ];
            if ( !others )
               continue;
            same = others[ creator ] & perm;
            if ( same ) {
               write( "Access to /"+ implode( bits[ 0 .. i ], "/" ) +
                     " supercedes "+ path +" for "+ creator +".\n" );
               if ( same & READ_MASK )
                  master()->remove_read_permission( creator, path );
               if ( same & WRITE_MASK )
                  master()->remove_write_permission( creator, path );
               if ( same & GRANT_MASK )
                  master()->remove_grant_permission( creator, path );
               break;
            }
         }
      }
   }
   return 1;
}
int help() {
  write("Available commands:\n"
"  read    <euid> <path>     : add read permison to the path.\n"
"  write   <euid> <path>     : add write permission to the path.\n"
"  grant   <euid> <path>     : add granting privileges to the path.\n"
"  lock           <path>     : restrict access to the path.\n"
"  noread  <euid> <path>     : remove read permission from the path.\n"
"  nowrite <euid> <path>     : remove write permission from the path.\n"
"  nogrant <euid> <path>     : remove granting privileges to the path.\n"
"  unlock         <path>     : remove restrictions to path.\n"
"  summary [path|euid]       : give a list of all the read/write perms.\n"
"  tidy                      : tidy away unnecessary perms.\n"
"  assign <euid> <path>      : assigns someone to look after a directory.\n"
"  assignment summary        : summary of directory assignments.\n" );
   return 1;
}
mixed *query_patterns() {
  return ({ "summary", (: do_summary(0) :),
              "summary <string>", (: do_summary($4[0]) :),
              "assignment summary", (: do_directory_summary(0) :),
              "assignment summary <string'filter'>", (: do_directory_summary($4[0]) :),
              "tidy", (: do_tidy() :),
              "help", (: help() :),
              "<word'permission'> <string'euid'> <word'path'>",
              (: cmd($4[0], $4[1], $4[2] ) :)
#ifdef 0
              ,
              "write <string'euid'> <string>", (: cmd("write", $4[0], $4[1]) :),
              "grant <string'euid'> <string>", (: cmd("grant", $4[0], $4[1]) :),
              "lock <string'euid'> <string>", (: cmd("lock", $4[0], $4[1]) :),
              "noread <string'euid'> <string>", (: cmd("noread", $4[0], $4[1]) :),
              "nowrite <string'euid'> <string>", (: cmd("nowrite", $4[0], $4[1]) :),
              "nogrant <string'euid'> <string>", (: cmd("nogrant", $4[0], $4[1]) :),
              "unlock <string'euid'> <string>", (: cmd("unlock", $4[0], $4[1])
                                                 :),
#endif
              });
}

==================================================
FILE: creator/playerinfo.c
==================================================

#include <creator.h>
#include <playerinfo.h>
#include <player_handler.h>
#define LOGGING
inherit "/cmds/base";
int do_report( string player, string event, int lastn, int interleaved ) {
   string who = this_player()->expand_nickname( lower_case(player) );
   string ret;
   if( !PLAYER_HANDLER->test_user(who) ) {
      tell_object( this_player(), "%^RED%^%^BOLD%^NOTE: %^RESET%^"
        "This is a player that either "
        "never existed or no longer exists.  Some deleted players' "
        "dossiers remain, while others do not.\n" );
   }
#ifdef LOGGING
   log_file( "/d/admin/log/PLAYERINFO.log", "%s: %s read dossier of %s.\n",
     ctime( time() ), this_player()->query_name(), who );
#endif
   if( interleaved ) {
     ret = PLAYERINFO_HANDLER->query_interleaved(this_player(), who,
                                                 event);
   } else if( !event ) {
     ret = PLAYERINFO_HANDLER->query_dossier( this_player(), who, lastn );
   } else {
     ret = PLAYERINFO_HANDLER->query_event( this_player(), who,
                                            lower_case(event) );
   }
   ret = this_player()->fix_string(ret, this_player()->query_cols());
   return this_player()->more_string(ret, "Playerinfo", 1);
}
int list_events() {
   string * list;
   string event, myself, result;
   list = sort_array( PLAYERINFO_HANDLER->query_events(), 1 );
   myself = base_name(this_object());
   result = "";
   foreach( event in list )
     result += ( event == list[0] ) ? event : ( ", " + event );
   write( "The following events exist: " + result + ". \n" );
   list = filter( list,
     (: PLAYERINFO_HANDLER->query_source_ok( $1, $(myself) ) :) );
   write( "You can manually add the following events: "
     + query_multiple_short(list) + ". \n" );
   return 1;
}
void update_database( string comment, string * data ) {
   if( !comment )
      return;
   if( PLAYERINFO_HANDLER->add_entry( this_player(), data[0], data[1],
                                      comment + "\n" ) ) {
      write( capitalize( data[0] ) + "'s dossier updated.\n" );
   } else {
      write( "Cannot update " + capitalize( data[0] ) + "'s dossier.\n" );
   }
}
int do_acknowledge( string player, string event, int idx, string update ) {
   if( !(PLAYERINFO_HANDLER->is_alert( player, idx ) ) ) {
      add_failed_mess( "That event is not an alert, so cannot be "
        "acknowledged.\n" );
      return -1;
   }
   if( !PLAYERINFO_HANDLER->acknowledge_alert( this_player(), player,
     event, idx, update, 0 ) ) {
      add_failed_mess( "You do not have the permission to acknowledge that alert, "
        "or the event type is invalid.\n" );
      return -1;
   }
   add_succeeded_mess( ({ "Event acknowledged.\n", "" }) );
   return 1;
}
int list_alerts( int foo ) {
   string * names;
   if( foo )
      names = PLAYERINFO_HANDLER->query_online_alerts();
   else
      names = keys( PLAYERINFO_HANDLER->query_alerts() );
   if( !sizeof( names ) )
      write( "There are no players with unacknowledged alerts.\n" );
   else
      write( "The following players have unacknowledged alerts: "
        + query_multiple_short( names ) + ". (" + sizeof( names ) +
        ")\n" );
   return 1;
}
int add_event( string player, string event, string comment ) {
   string *events;
   string myself;
   player = this_player()->expand_nickname( lower_case(player) );
   event = lower_case(event);
   if( !PLAYER_HANDLER->test_user(player) ) {
      add_failed_mess( "No such player: " + player + ".\n" );
      return 0;
   }
   myself = base_name( this_object() );
   events = filter( PLAYERINFO_HANDLER->query_events(),
     (: PLAYERINFO_HANDLER->query_source_ok( $1, $(myself) ) :) );
   if( member_array( event, events ) == -1 ) {
      add_failed_mess( "Incorrect event type '" + event
        + "': it must be one of " + query_multiple_short(events) + ".\n" );
      return 0;
   }
   if( comment ) {
      update_database( comment, ({ player, event }) );
      return 1;
   }
   write( "Please enter your comments:\n" );
   this_player()->do_edit( 0, "update_database", this_object(), 0,
     ({ player, event }) );
   return 1;
}
int add_alts( string s1, string s2, int deleting ) {
   string who, result;
   string * alts;
   who = this_player()->expand_nickname( lower_case(s1) );
   alts = explode( lower_case(s2), " " );
   alts = explode( implode( alts, "," ), "," ) - ({ "" }) - ({ 0 });
   if( deleting ) {
      result = PLAYERINFO_HANDLER->delete_alts( this_player(), who, alts );
   } else {
      result = PLAYERINFO_HANDLER->add_alts( this_player(), who, alts );
   }
   add_succeeded_mess( ({ result, "" }) );
   return 1;
}
mixed *query_patterns() {
   return ({
     "list",
       (: list_events() :),
     "list alerts",
       (: list_alerts(0) :),
     "list alerts online",
       (: list_alerts(1) :),
     "<word'playername'>",
       (: do_report( $4[0], 0, 10, 0 ) :),
     "<word'playername'> verbose",
       (: do_report( $4[0], 0, 0, 0 ) :),
     "<word'playername'> interleaved",
       (: do_report( $4[0], 0, 0, 1 ) :),
     "<word'playername'> <word'event type'> interleaved",
       (: do_report( $4[0], $4[1], 0, 1 ) :),
     "<word'playername'> <word'event type'>",
       (: do_report( $4[0], $4[1], 0, 0 ) :),
     "<word'playername'> acknowledge <number'event number'> "
       "<string'comment'>",
       (: do_acknowledge( $4[0], "misc", $4[1], $4[2] ) :),
     "<word'playername'> acknowledge <number'event number'> "
       "as <word'event type'> <string'comment'>",
       (: do_acknowledge( $4[0], $4[2], $4[1], $4[3] ) :),
     "<word'playername'> add [event] <word'event type'>",
       (: add_event( $4[0], $4[1], 0 ) :),
     "<word'playername'> add [event] <word'event type'> <string'comment'>",
       (: add_event( $4[0], $4[1], $4[2] ) :),
     "<word'playername'> addalt <string'alt-name alt-name ...'>",
       (: add_alts( $4[0], $4[1], 0 ) :),
     "<word'playername'> delalt <string'alt-name alt-name ...'>",
       (: add_alts( $4[0], $4[1], 1 ) :),
   });
}

==================================================
FILE: creator/playerskills.c
==================================================

#include <skills.h>
private string rec_list( mixed *args, string path, int all, int lvl,
                 int only_leaf, object pl ) {
   int i, sk, o_l;
   string str, tp, tmp;
   str = "";
   for ( i = 0 ; i < sizeof( args ) ; i += SKILL_ARR_SIZE ) {
      o_l = 0;
      tp = path +"."+ args[ i ];
      sk = (int)pl->query_skill( tp );
      reset_eval_cost();
      if (lvl == 1 && SKILL_OB->query_only_leaf(tp))
        o_l = 1;
      if (!(only_leaf || o_l) || (!sizeof(args[i+SKILL_BIT]) &&
                                  (sk > 0 || all)))
        str += sprintf( "%*'| 's%*'.'-s %4d %4d\n", ( lvl-1 ) * 2, "",
              20 - ( ( lvl - 1 ) * 2 ), args[ i ], sk,
              (int)pl->query_skill_bonus( tp ) );
      if ( sizeof( args[ i + SKILL_BIT ] ) && ( only_leaf || o_l || all
                                                || ( sk > 5 * lvl ) ) ) {
         tmp = rec_list( args[ i + SKILL_BIT ], path +"."+ args[i],
                         all, lvl + 1, only_leaf || o_l, pl );
         if ((only_leaf || o_l) && (tmp != "" || (!all && lvl == 1)))
           str += sprintf( "%*'| 's%*'.'-s    -    -\n", ( lvl-1 ) * 2, "",
                           20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
         else
           str += tmp;
      }
   }
   return str;
}
private int real_cmd( object *players, string word ) {
   int i;
   string result, *bits;
   object pl;
   mixed *args;
   pl = players[0];
   result = "";
   bits = ({ });
   if ( word ) {
      args = (mixed *)SKILL_OB->query_skills();
      if ( ( i = member_array( word, args ) ) == -1 ) {
         notify_fail( "Usage: "+ query_verb() +" <skill>\n" );
         return 0;
      }
      args = args[ i + SKILL_BIT ];
      result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
            "=======SKILLS=======Level/Bonus" );
      result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
            rec_list( args, word, 1, 1, 0, pl ) );
      this_player()->more_string( result, "Skills" );
    tell_object( pl, this_player()->query_cap_name() + " is checking "
        "your skills.\n" );
      return 1;
   }
   args = (mixed *)SKILL_OB->query_skills();
   result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
         "=======SKILLS=======Level/Bonus");
   result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
         rec_list( args, "", ( member_array( "all", bits ) != -1 ), 1, 0, pl ) );
   this_player()->more_string( result, "Skills" );
   tell_object( pl, this_player()->query_cap_name() + " is checking your "
       "skills.\n" );
   return 1;
}
private void check_response( string txt, object *indirect_obs, string skill ) {
    int result;
    if ( upper_case( txt ) == "Y" ) {
        result = real_cmd( indirect_obs, skill );
        return;
    }
    tell_object( this_player(), "Not viewing skills.\n" );
}
private int cmd( object *indirect_obs, string skill ) {
   if ( !sizeof( filter( indirect_obs, (: userp :) ) ) ) {
      check_response( "Y", indirect_obs, skill );
      return 1;
   }
   tell_object( this_player(), "Are you sure you wish to view " +
      query_multiple_short( indirect_obs ) + "'s skills?  You should ask "
      "$V$0=" + indirect_obs[0]->query_possessive() + ",their$V$ "
   "permission first.\n" );
   tell_object( this_player(), "Enter 'Y' to view " +
      query_multiple_short( indirect_obs ) + "'s skill tree.\n" );
   input_to( (: check_response :), 0, indirect_obs, skill );
   return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:wiz-present> <string>",
            (: cmd($1, $4[1]) :),
            "<indirect:wiz-present>",
            (: cmd($1, 0) :) });
}

==================================================
FILE: creator/pquests.c
==================================================

#include <quest_handler.h>
#include <library.h>
inherit "/cmds/base";
string quest_text(string quest);
int cmd( string player, int sorted ) {
    string *quests, text;
    int i, size;
    if ( !player ) {
        quests = QUEST_HANDLER->query_quest_names();
        text = "$P$Quest list$P$\nTotal quests on " + mud_name() + " :-\n\n";
    }
    else {
        quests = LIBRARY->query_quests(player);
        if (!quests) {
            add_failed_mess( "That player has not done any "
                "quests.\n" );
            return 0;
        }
    if ( sorted )
        quests = sort_array( quests, 1 );
        text = "$P$Quest list$P$\nQuests done for player " + player + " :-\n\n";
    }
    size = sizeof(quests);
    for ( i = 0; i < size; i++ ) {
        text += sprintf("%d. %s (%s) %s\n", i + 1, quests[i],
            QUEST_HANDLER->query_quest_title (quests[i]),
            quest_text( quests[i] ) );
    }
    tell_object( this_player(), text );
    return 1;
}
string quest_text(string quest) {
    switch ( QUEST_HANDLER->query_quest_status(quest) ) {
        case 0:
            return "(inactive)";
        case 1:
            return "";
        default:
            return "(broken)";
    }
}
mixed *query_patterns() {
    return ({ "", (: cmd(0, 0) :),
        "<string'player'>", (: cmd($4[0], 0) :),
        "<string'player'> sorted", (: cmd($4[0], 1) :)
    });
}

==================================================
FILE: creator/prof.c
==================================================

#include <housing.h>
inherit "/cmds/base";
#define MAX 500
int last_got;
mixed *data, *tot;
int total(mapping *info) {
  int ret;
  mapping item;
  foreach(item in info)
    ret += item["self"];
  return ret;
}
int cmd(string thing) {
  int i, j;
  mapping stuff;
  object ob;
  mixed foo;
  string ret;
  if(last_got < time() - 900) {
    data = map(objects((: !clonep($1) :)),
               (: ({ $1, function_profile($1) }) :));
    tot = allocate(sizeof(data));
    for(i=0; i<sizeof(data); i++) {
      tot[i] = ({ data[i][0], total(data[i][1]) });
    }
    for(i=0; i<24; i++) {
      reset_eval_cost();
      for (j = i; j < sizeof(tot); j++)
        if (tot[i][1] < tot[j][1]) {
          foo = tot[i];
          tot[i] = tot[j];
          tot[j] = foo;
        }
    }
    last_got = time();
  }
  ret = "";
  if(!thing) {
    for (i = 0; i < 50 && i<sizeof(tot); i++) {
      if(tot[i][1])
        ret += sprintf("%60-O %i\n", tot[i][0], tot[i][1]);
    }
  } else {
    ob = find_object(thing);
    if(!ob)
      return notify_fail("No such object.\n");
    ret += sprintf("%30-s %10s %10s %10s\n", "function", "calls", "self", "children");
    i = 0;
    for(j=0; j<sizeof(data); j++)
      if(data[j][0] == ob) {
        i = 1;
        break;
      }
    if(!i)
      return notify_fail("No such object in data.\n");
    foreach(stuff in data[j][1]) {
      ret += sprintf("%30-s %10d %10d %10d\n", stuff["name"], stuff["calls"],
             stuff["self"], stuff["children"]);
    }
  }
  write("$P$Profile$P$" + ret);
  return 1;
}

==================================================
FILE: creator/pstat.c
==================================================

inherit "/cmds/base";
int cmd( object *indirect_obs ) {
    object ob;
    mapping prop;
    string *sorted, property;
    string txt;
    txt = "$P$Properties$P$";
    foreach( ob in indirect_obs ) {
        prop = filter( ob->query_properties(), (: $2 :) );
        sorted = sort_array( keys( prop ), 1 );
        foreach( property in sorted ) {
            txt += sprintf( "$I$0,5=(%s): %O$I$0,-5=\n", property, prop[ property ] );
        }
    }
    tell_object( this_player(), txt );
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:wiz-present>", (: cmd( $1 ) :) });
}

==================================================
FILE: creator/ptest_ers.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
#include <project_management.h>
string query_applicant_text();
varargs int cmd(string check, string name, string reason) {
  int i;
  string *names, *projects;
  string ret = "";
  class project *tmp, *tmp2;
  switch (check) {
    case "ptinfo":
      ret = PLAYTESTER_HAND->query_show_list_colour();
      tell_object (this_player(), ret);
      return 1;
    break;
    case "assign":
      i = PROJECT_HANDLER->find_project (name);
      if (i == -1) {
        this_player()->add_failed_mess (this_object(), "There is no project "
          "of that ID.\n", ({ }));
        return 0;
      }
      else {
        names = PROJECT_HANDLER->assign_pts_to_project (i);
        if (!sizeof (names)) {
          this_player()->add_failed_mess (this_object(), "Something went "
            "wrong!\n", ({ }));
            return 0;
        }
        else {
          tell_object (this_player(), sprintf ("$I$5=You assign %s to project %s.\n",
          query_multiple_short (map (names, (: capitalize ($1) :))), name));
        return 1;
      }
    }
    break;
    case "allassign":
      tmp = PROJECT_HANDLER->get_playtesting_projects();
      tmp2 = filter (tmp, (: sizeof ($1->guild_specific) :));
      tmp -= tmp2;
      if (!sizeof (tmp) && !sizeof (tmp2)) {
          this_player()->add_failed_mess (this_object(), "There are no "
            "projects currently in playtesting.\n", ({ }));
          return 0;
      }
      else {
        for (int c = 0; c < 2; c++) {
          if (c == 0) {
            projects = map (tmp2, (: $1->id :));
          }
          else {
            projects = map (tmp, (: $1->id :));
          }
          foreach (string p in projects) {
            names = PROJECT_HANDLER->assign_pts_to_project (p);
            if (!sizeof (names)) {
              continue;
            }
            ret += sprintf ("$I$5=You assign %s to project %s.\n",
              query_multiple_short (map (names, (: capitalize ($1) :))), p);
          }
        }
        tell_object (this_player(), ret);
        return 1;
    }
    break;
    case "add":
      i = PLAYTESTER_HAND->add_playtester (name);
      if (i) {
        this_player()->add_succeeded_mess (this_object(), "$N add$s someone "
          "as a playtester.\n", ({ }));
        return 1;
      }
      else {
        this_player()->add_failed_mess (this_object(), "You cannot add this "
          "player as a playtester.\n", ({ }));
        return 0;
      }
    break;
    case "remove":
      i = PLAYTESTER_HAND->remove_playtester (name, reason);
      if (i) {
        this_player()->add_succeeded_mess (this_object(), "$N remove$s someone "
          "as a playtester.\n", ({ }));
        return 1;
      }
      else {
        this_player()->add_failed_mess (this_object(), "You cannot remove this "
          "player as a playtester.\n", ({ }));
        return 0;
      }
    break;
    case "shortlist":
      PT_APPLICATION_HANDLER->set_shortlist (name);
        this_player()->add_succeeded_mess (this_object(), "$N toggle$s "
          "something.\n", ({ }));
      return 1;
    break;
    case "investigate":
        PT_APPLICATION_HANDLER->set_considering (name);
        this_player()->add_succeeded_mess (this_object(), "$N toggle$s "
          "something.\n", ({ }));
        return 1;
    break;
    case "delete":
      i =  PT_APPLICATION_HANDLER->delete_applicant (name);
      if (i) {
        this_player()->add_succeeded_mess (this_object(), "$N delete$s someone "
          "as from the application process.\n", ({ }));
        return 1;
      }
      else {
        this_player()->add_failed_mess (this_object(), "You cannot remove this "
          "player from the application process.\n", ({ }));
        return 0;
      }
    break;
    case "holiday":
      i =  PLAYTESTER_HAND->query_leave(name);
      if (i) {
        PLAYTESTER_HAND->reset_leave(name);
        this_player()->add_succeeded_mess (this_object(), "$N reset$s someones "
          "playtester leave.\n", ({ }));
        return 1;
      }
      else {
        PLAYTESTER_HAND->set_leave(name, reason);
        this_player()->add_succeeded_mess (this_object(), "$N set$s someone "
          "as on leave.\n", ({ }));
        return 1;
      }
    break;
  }
}
mixed *query_patterns() {
   mixed *patterns =
    ({
      "add <word>", (: cmd ("add", $4[0]) :),
      "remove <word'name'> <string'reason'>", (: cmd ("remove", $4[0], $4[1]) :),
      "holiday <word> <string>", (: cmd ("holiday", $4[0], $4[1]) :),
      "shortlist <word>", (: cmd ("shortlist", $4[0]) :),
      "investigate <word>", (: cmd ("investigate", $4[0]) :),
      "delete <word>", (: cmd ("delete", $4[0]) :),
      "assign all", (: cmd ("allassign", "all") :),
      "assign <word>", (: cmd ("assign", $4[0]) :),
      "info", (: cmd ("ptinfo") :)
      });
  return patterns;
}

==================================================
FILE: creator/ptguilds.c
==================================================

#include <player.h>
string format_guild_list( string guild_path, string *members ) {
    return "Members of the " + (guild_path->query_short()
      ? guild_path->query_short() : "Misc.") + ": " +
        query_multiple_short( sort_array( map( members,
           (: capitalize( $1 ) :) ), 1 ) ) + ".";
}
int cmd( string guild ) {
    mapping data;
    string txt;
    string *members;
    data = PLAYTESTER_HAND->query_playtester_guilds();
    txt = "Playtester listing by Guild\n\n";
    if ( guild && ( members = data[ guild ] ) ) {
        txt = format_guild_list( guild, members );
    }
    else {
        txt += implode( values( map( data,
            (: format_guild_list( $1, $2 ) :) ) ), "\n\n" );
    }
    tell_object( this_player(), txt + "\n" );
    return 1;
}
mixed *query_patterns() {
    return ({ "", (: cmd(0) :),
              "<string'guild'>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/ptobj_ect.c
==================================================

inherit "/cmds/base";
#define PT_ARMOURY "/d/playtesters/palace_rooms/armoury"
mixed *query_patterns() {
    return ({ "info",
                  (: PT_ARMOURY->do_info() :),
              "help",
                  (: PT_ARMOURY->do_info() :),
              "list",
                  (: PT_ARMOURY->do_list_all() :),
              "list commands",
                  (: PT_ARMOURY->do_list_commands() :),
              "list objects",
                  (: PT_ARMOURY->do_list_commands() :),
              "control",
                  (: PT_ARMOURY->do_list_control_all() :),
              "control commands",
                  (: PT_ARMOURY->do_list_control_commands() :),
              "control objects",
                  (: PT_ARMOURY->do_list_control_commands() :),
              "request <string:'item'>",
                  (: PT_ARMOURY->do_request_object( lower_case( $4[ 0 ] ) ) :),
              "add object <word:'path of object'> as <string:'item name'>",
                  (: PT_ARMOURY->do_add_object( $4[ 0 ],
                                                lower_case( $4[ 1 ] ) ) :),
              "remove object <string:'item name'>",
                  (: PT_ARMOURY->do_remove_object( $4[ 0 ] ) :),
              "allow <word:'guilds'> to use object <string:'item name'>",
                  (: PT_ARMOURY->do_allow_object( $4[ 0 ],
                                                  lower_case( $4[ 1 ] ) ) :),
              "add command <string:'command name'>",
                  (: PT_ARMOURY->do_add_command( $4[ 0 ] ) :),
              "remove command <string:'command name'>",
                  (: PT_ARMOURY->do_remove_command( $4[ 0 ] ) :),
              "allow <word:'guilds'> to use command <string:'command name'>",
                  (: PT_ARMOURY->do_allow_command( $4[ 0 ], $4[ 1 ] ) :)
              });
}

==================================================
FILE: creator/pw_d.c
==================================================

inherit "/cmds/base";
int cmd() {
   write(this_player()->query_path() + "\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd :) });
}

==================================================
FILE: creator/qp_eople.c
==================================================

inherit "/cmds/base";
#include <peopler.h>
#include <creator.h>
mixed cmd(string str) {
   mixed *stuff;
   stuff = this_player()->query_property("qpeople list");
   if (!stuff) {
      stuff = D_DEFAULT;
   }
   return PEOPLER->do_command(stuff, str);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/qwho.c
==================================================

#include <top_ten_tables.h>
int cmd(string filter, string arg);
string* determine_location( object person ) {
    mixed *areas, *place;
    areas = ({
        ({ "/d/liaison/NEWBIE", ({ "Misc", "The newbie area" }) }),
        ({ "/room/air", ({ "Misc", "The air" }) }),
        ({ "/room/void", ({ "Misc", "The void" }) }),
        ({ "/room/rubbish", ({ "Misc", "The rubbish room" }) }),
        ({ "/room/departures", ({ "Misc", "The departures lounge" }) }),
        ({ "/room/jail", ({ "Misc", "Jail" }) }),
        ({ "/w/", ({ "Misc", "/w dirs" }) }),
        ({ "/d/cwc/utils/interview", ({ "CWC", "Interview room" }) }),
        ({ "/d/cwc/common", ({ "CWC", "Commonroom" }) }),
        ({ "/d/cwc/Brown_Islands", ({ "CWC", "Brown Islands" }) }),
        ({ "/d/cwc/Bes_Pelargic/Bad_Poo-Ning/roads/medina",
            ({ "CWC", "Medina" }) }),
        ({ "/d/cwc/Bes_Pelargic/Sum_Bing/roads/snail",
            ({ "CWC", "The Snail" }) }),
        ({ "/d/cwc/Bes_Pelargic", ({ "CWC", "Bes Pelargic" }) }),
        ({ "/d/cwc/Hunghung", ({ "CWC", "HungHung" }) }),
        ({ "/d/cwc/Isle_of_Tonahamen", ({ "CWC", "Isle of Tonahamen" }) }),
        ({ "/d/cwc/families/mcsweeny", ({ "CWC", "McSweeney Estate" }) }),
        ({ "/d/cwc/Maps", ({ "CWC", "Terrains" }) }),
        ({ "/d/cwc", ({ "CWC", "?" }) }),
        ({ "/d/guilds/assassins/Bes-Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/thieves/Bes-Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/warriors/BesPelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/warriors/Hunghung", ({ "CWC", "HH guilds" }) }),
        ({ "/d/guilds/priests/Bes_Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/wizards/Bes_Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/witches/bespelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/underworld/moving_shop/rooms/cwc", ({ "CWC", "F-shop" }) }),
        ({ "/d/am/utils/interview", ({ "AM", "Interview room" }) }),
        ({ "/d/am/shades", ({ "AM", "The Shades" }) }),
        ({ "/d/am/common", ({ "AM", "Commonroom" }) }),
        ({ "/d/am", ({ "AM", "Ankh-Morpork" }) }),
        ({ "/d/special/player_shops", ({ "AM", "Tarnach's" }) }),
        ({ "/d/guilds/merchants", ({ "AM", "Ankh-Morpork" }) }),
        ({ "/d/guilds/assassins/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/thieves/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/warriors/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/priests/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/wizards/Ankh-Morpork",
            ({ "AM", "Unseen University" }) }),
        ({ "/d/guilds/witches/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/witches/am", ({ "AM", "AM guilds" }) }),
        ({ "/d/klatch/utils/interview", ({ "Klatch", "Interview room" }) }),
        ({ "/d/klatch/common", ({ "Klatch", "Commonroom" }) }),
        ({ "/d/klatch/djel/city", ({ "Klatch", "KLK" }) }),
        ({ "/d/klatch/djel/necropolis", ({ "Klatch", "Necropolis" }) }),
        ({ "/d/klatch/djel/netherworld", ({ "Klatch", "Netherworld" }) }),
        ({ "/d/klatch/tsort/desert/roads",
            ({ "Klatch", "Tsort desert road" }) }),
        ({ "/d/klatch/tsort/desert", ({ "Klatch", "Tsort desert" }) }),
        ({ "/d/klatch/tsort", ({ "Klatch", "Tsort" }) }),
        ({ "/d/klatch/Maps", ({ "Klatch", "Terrains" }) }),
        ({ "/d/klatch", ({ "Klatch", "?" }) }),
        ({ "/d/guilds/assassins/Khot-lip-khin",
            ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/thieves/Khot-lip-khin", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/warriors/Khot-lip-khin",
            ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/priests/Djelibeybi", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/priests/Khot-lip-khin", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/wizards/Khot-lip-khin", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/wizards/Ephebe", ({ "Klatch", "Ephebe guilds" }) }),
        ({ "/d/guilds/wizards/Tsort", ({ "Klatch", "Tsort guilds" }) }),
        ({ "/d/guilds/witches/klk", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/ram/utils/interview", ({ "Ram", "Interview room" }) }),
        ({ "/d/ram/common", ({ "Ram", "Commonroom" }) }),
        ({ "/d/ram/Gloomy_Forest", ({ "Ram", "Gloomy forest" }) }),
        ({ "/d/ram/Lancre_Kingdom", ({ "Ram", "Lancre Kingdom" }) }),
        ({ "/d/ram/Listening_Monks", ({ "Ram", "Listening Monks" }) }),
        ({ "/d/ram/Razorback", ({ "Ram", "Razorback" }) }),
        ({ "/d/ram/Slice", ({ "Ram", "Slice" }) }),
        ({ "/d/ram/Sprite_Caverns", ({ "Ram", "Sprite caverns" }) }),
        ({ "/d/ram/Temple_of_Soyin", ({ "Ram", "Temple of Soyin" }) }),
        ({ "/d/ram/Uberwald", ({ "Ram", "Uberwald" }) }),
        ({ "/d/ram/badass", ({ "Ram", "Bad Ass" }) }),
        ({ "/d/ram/madstoat", ({ "Ram", "Mad Stoat" }) }),
        ({ "/d/ram/ohulan", ({ "Ram", "Ohulan-Cutash" }) }),
        ({ "/d/ram/foothills", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/bridge", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/moorland", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/gorge_road", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/Lower_Valleys", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/lancre_town", ({ "Ram", "Lancre Town" }) }),
        ({ "/d/ram/bandit_camp", ({ "Ram", "Bandit camp" }) }),
        ({ "/d/ram/druid_circle", ({ "Ram", "Druid circle" }) }),
        ({ "/d/ram/mountains", ({ "Ram", "Ramtops" }) }),
        ({ "/d/ram", ({ "Ram", "?" }) }),
        ({ "/d/guilds/assassins/Ohulan-Cutash", ({ "Ram", "OC guilds" }) }),
        ({ "/d/guilds/thieves/Madstoat", ({ "Ram", "Mad Stoat guilds" }) }),
        ({ "/d/guilds/warriors/Lancre", ({ "Ram", "Lancre guilds" }) }),
        ({ "/d/guilds/priests/Monks-of-Cool", ({ "Ram", "Monks of Cool" }) }),
        ({ "/d/guilds/priests/Ohulan-Cutash", ({ "Ram", "OC guilds" }) }),
        ({ "/d/guilds/wizards/Creel-Springs",
            ({ "Ram", "Creel Springs guilds" }) }),
        ({ "/d/guilds/witches/badass", ({ "Ram", "Bad Ass guilds" }) }),
        ({ "/d/guilds/witches/lancre", ({ "Ram", "Lancre guilds" }) }),
        ({ "/d/guilds/witches/madstoat", ({ "Ram", "Mad Stoat guilds" }) }),
        ({ "/d/guilds/witches/razorback", ({ "Ram", "Razorback guilds" }) }),
        ({ "/d/sur/utils/interview", ({ "Sur", "Interview room" }) }),
        ({ "/d/sur/common", ({ "Sur", "Commonroom" }) }),
        ({ "/d/sur/Maps", ({ "Sur", "Terrains" }) }),
        ({ "/d/sur/Dinky", ({ "Sur", "Dinky" }) }),
        ({ "/d/sur/Sto_Helit", ({ "Sur", "Sto Helit" }) }),
        ({ "/d/sur/StoLat", ({ "Sur", "Sto Lat" }) }),
        ({ "/d/sur/Hillshire", ({ "Sur", "Hillshire" }) }),
        ({ "/d/sur/Holywood", ({ "Sur", "Holywood" }) }),
        ({ "/d/sur/Nowhere", ({ "Sur", "Nowhere" }) }),
        ({ "/d/sur/PekanFord", ({ "Sur", "Pekan Ford" }) }),
        ({ "/d/sur/Sheepridge", ({ "Sur", "Sheepridge" }) }),
        ({ "/d/sur/Scrogden", ({ "Sur", "Scrogden" }) }),
        ({ "/d/sur/items/carriage", ({ "Sur", "Carriage" }) }),
        ({ "/d/sur", ({ "Sur", "?" }) }),
        ({ "/d/guilds/assassins/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/assassins/Sto-Helit", ({ "Sur", "SH guilds" }) }),
        ({ "/d/guilds/assassins/Sheepridge",
            ({ "Sur", "Sheepridge guilds" }) }),
        ({ "/d/guilds/thieves/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/thieves/Sto-Helit", ({ "Sur", "SH guilds" }) }),
        ({ "/d/guilds/thieves/Pekan_Ford", ({ "Sur", "PF guilds" }) }),
        ({ "/d/guilds/warriors/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/priests/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/wizards/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/witches/skund", ({ "Sur", "Skund guilds" }) }),
        ({ "/d/guilds/witches/stolat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/forn/utils/interview", ({ "Forn", "Interview room" }) }),
        ({ "/d/forn/common", ({ "Forn", "Commonroom" }) }),
        ({ "/d/forn/genua", ({ "Forn", "Genua" }) }),
        ({ "/d/forn", ({ "Forn", "?" }) }),
        ({ "/d/guilds/assassins/Genua", ({ "Forn", "Genua guilds" }) }),
        ({ "/d/special/utils/interview", ({ "Special", "Interview room" }) }),
        ({ "/d/special/common", ({ "Special", "Commonroom" }) }),
        ({ "/d/special/ctf", ({ "Special", "CTF" }) }),
        ({ "/d/special", ({ "Special", "?" }) }),
        ({ "/d/playtesters/utils/interview", ({ "Playtesters",
            "Interview room" }) }),
        ({ "/d/playtesters/common", ({ "Playtesters", "Commonroom" }) }),
        ({ "/d/playtesters/palace_rooms", ({ "Playtesters", "Palace" }) }),
        ({ "/d/playtesters", ({ "Playtesters", "?" }) }),
        ({ "/d/liaison/utils/interview", ({ "Liaison", "Interview room" }) }),
        ({ "/d/liaison/common", ({ "Liaison", "Commonroom" }) }),
        ({ "/d/liaison", ({ "Liaison", "?" }) }),
        ({ "/d/underworld/common", ({ "Underworld", "Commonroom" }) }),
        ({ "/d/underworld/death", ({ "Underworld", "Death's domain" }) }),
        ({ "/d/underworld/lspace", ({ "Underworld", "L-space" }) }),
        ({ "/d/underworld/moving_shop", ({ "Underworld", "T-shop" }) }),
        ({ "/d/underworld", ({ "Underworld", "?" }) }),
        ({ "/d/guilds/common", ({ "Guilds", "Commonroom" }) }),
        ({ "/d/guilds/assassins", ({ "Guilds", "Assassins" }) }),
        ({ "/d/guilds/thieves", ({ "Guilds", "Thieves" }) }),
        ({ "/d/guilds/warriors", ({ "Guilds", "Warriors" }) }),
        ({ "/d/guilds/priests/rooms", ({ "Guilds", "Passage rooms" }) }),
        ({ "/d/guilds/priests", ({ "Guilds", "Priests" }) }),
        ({ "/d/guilds/wizards", ({ "Guilds", "Wizards" }) }),
        ({ "/room/magic_circle", ({ "Guilds", "Witches' circle" }) }),
        ({ "/d/guilds/witches", ({ "Guilds", "Witches" }) }),
        ({ "/d/guilds", ({ "Guilds", "?" }) }),
        ({ "/d/admin/room/domain_control", ({ "Admin", "Domain control" }) }),
        ({ "/d/admin", ({ "Admin", "?" }) }),
        ({ "/d", ({ "Other", "Unknown /d room" }) }),
    });
    if( !environment(person) ) {
        return ({ "Other", "No environment" });
    }
    foreach( place in areas ) {
        if( strsrch( file_name(environment(person)), place[0] ) == 0 ) {
            return place[1];
        }
    }
    return ({ "Other", "Unknown environment" });
}
int get_guild_id(object person) {
    switch(person->query_guild_ob()) {
        case "/std/guilds/warrior":
            return 0;
        case "/std/guilds/assassin":
            return 1;
        case "/std/guilds/thief":
            return 2;
        case "/std/guilds/wizard":
            return 3;
        case "/std/guilds/priest":
            return 4;
        case "/std/guilds/witch":
            return 5;
        default:
            return 6;
    }
}
mapping get_dist( string filter, string arg ) {
    mapping ps;
    object *people, person;
    string *loc;
    int to_add;
    people = filter( users(), (: !$1->query_creator() &&
        $1->query_name() != "logon" :) );
    ps = ([ ]);
    foreach( person in people ) {
        loc = determine_location(person);
        if( !ps[loc[0]] ) {
            if( filter == "average" ) {
                ps[loc[0]] = ({ ([ ]), 0, ({ -1, 0, 0 }) });
            }
            else {
                ps[loc[0]] = ({ ([ ]), 0, 0 });
            }
        }
        ps[loc[0]][1]++;
        if( !ps[loc[0]][0][loc[1]] ) {
            if( filter == "average" ) {
                ps[loc[0]][0][loc[1]] = ({ 0, ({ -1, 0, 0 }) });
            }
            else {
                ps[loc[0]][0][loc[1]] = ({ 0, 0 });
            }
        }
        ps[loc[0]][0][loc[1]][0]++;
        switch(filter) {
            case "verbosity":
                if( person->query_verbose(arg) ) {
                    ps[loc[0]][2]++;
                    ps[loc[0]][0][loc[1]][1]++;
                }
                break;
            case "average":
                to_add = 0;
                if( arg == "guild level" ) {
                    to_add = person->query_level();
                }
                if( arg == "rating" ) {
                    to_add = (int)TOP_TEN_HANDLER->calculate_rating(person);
                }
                if( arg == "age" ) {
                    to_add = -person->query_time_on();
                }
                if( to_add < ps[loc[0]][2][0] || ps[loc[0]][2][0] == -1 ) {
                    ps[loc[0]][2][0] = to_add;
                }
                ps[loc[0]][2][1] += to_add;
                if( to_add > ps[loc[0]][2][2] ) {
                    ps[loc[0]][2][2] = to_add;
                }
                if( to_add < ps[loc[0]][0][loc[1]][1][0] ||
                    ps[loc[0]][0][loc[1]][1][0] == -1 ) {
                    ps[loc[0]][0][loc[1]][1][0] = to_add;
                }
                ps[loc[0]][0][loc[1]][1][1] += to_add;
                if( to_add > ps[loc[0]][0][loc[1]][1][2] ) {
                    ps[loc[0]][0][loc[1]][1][2] = to_add;
                }
                break;
            case "category":
                if( arg == "guild" ) {
                    if( !ps[loc[0]][2] ) {
                        ps[loc[0]][2] = ({0,0,0,0,0,0,0});
                    }
                    if( !ps[loc[0]][0][loc[1]][1] ) {
                        ps[loc[0]][0][loc[1]][1] = ({0,0,0,0,0,0,0});
                    }
                    to_add = get_guild_id(person);
                    ps[loc[0]][2][to_add]++;
                    ps[loc[0]][0][loc[1]][1][to_add]++;
                }
                break;
            default:
        }
    }
    return ps;
}
int cmd( string filter, string arg, int verbose ) {
    string place, zone, *guilds;
    mapping players, zones;
    int total, i, j;
    string tmp;
    string ret;
    ret = "";
    players = get_dist(filter,arg);
    total = sizeof(filter( users(), (: !$1->query_creator() &&
        $1->query_name() != "logon" :) ));
    guilds = ({ "Warriors", "Assassins", "Thieves", "Wizards", "Priests",
        "Witches", "Adventurers" });
    tmp = "\n";
    tmp+= sprintf( "%-27s", "Distribution of players:" );
    if( filter == "category" && arg == "guild" ) {
        j = (this_player()->query_cols() - 27) / (sizeof(guilds));
        for( i=0; i<sizeof(guilds); i++ ) {
            tmp += sprintf( "%" + j + ".3s", guilds[i] );
        }
    }
    if( filter == "average" ) {
        if( arg == "age" ) {
            j = (this_player()->query_cols() - 27);
            tmp += sprintf( "%-" + j + "s", "   Average age" );
        }
        else {
            j = (this_player()->query_cols() - 27) / 3;
            tmp += sprintf( "%" + j + "s", "Lowest" );
            tmp += sprintf( "%" + j + "s", "Average" );
            tmp += sprintf( "%" + j + "s", "Highest" );
        }
    }
    tmp += "\n\n";
    ret += tmp;
    foreach( place in keys(players) ) {
        tmp = "%^YELLOW%^";
        tmp+= sprintf( "%-24.24s", place );
        tmp+= sprintf( "%3.1i", players[place][1] );
        switch( filter ) {
            case "verbosity":
                tmp += players[place][2] + "/" +
                    players[place][1] + " verbose " + arg;
                break;
            case "average":
                if( arg == "age" ) {
                    tmp += sprintf( "%-"+ j +"s", "   " + query_time_string(
                        players[place][2][1] / players[place][1] ) );
                }
                else {
                    tmp += sprintf( "%"+ j +".1i", players[place][2][0] );
                    tmp += sprintf( "%"+ j +".1i", players[place][2][1] /
                        players[place][1] );
                    tmp += sprintf( "%"+ j +".1i", players[place][2][2] );
                }
                break;
            case "category":
                if( arg == "guild" ) {
                    for( i=0; i<sizeof(guilds); i++ ) {
                        tmp += sprintf( "%" + j + ".1i",
                            players[place][2][i] );
                    }
                }
                break;
            default:
                tmp += "   (";
                tmp += sprintf( "%3s",
                    ((100 * players[place][1]) / total + "%") );
                tmp += ")";
                break;
        }
        tmp += "%^RESET%^";
        tmp += "\n";
        ret += tmp;
        if (verbose) {
           zones = players[place][0];
           foreach( zone in keys( zones ) ) {
               tmp = sprintf( "%-24.24s", ("  - " + zone) );
               tmp+= sprintf( "%3.1i", zones[zone][0] );
               switch( filter ) {
                   case "verbosity":
                       tmp += " (" + zones[zone][1] + "/" + zones[zone][0] +
                           " verbose " + arg + ")";
                       break;
                   case "average":
                       if( arg == "age" ) {
                           tmp += sprintf( "%-"+ j +"s", "   " +
                               query_time_string( zones[zone][1][1] /
                               zones[zone][0] ) );
                       }
                       else {
                           tmp += sprintf( "%"+ j +".1i", zones[zone][1][0] );
                           tmp += sprintf( "%"+ j +".1i", zones[zone][1][1] /
                               zones[zone][0] );
                           tmp += sprintf( "%"+ j +".1i", zones[zone][1][2] );
                       }
                       break;
                   case "category":
                       if( arg == "guild" ) {
                           for( i=0; i<sizeof(guilds); i++ ) {
                               if( !zones[zone][1][i] ) {
                                   tmp += "%^BLACK%^";
                                   tmp += sprintf( "%" + j + ".1i",
                                        zones[zone][1][i] );
                                   tmp += "%^RESET%^";
                               }
                               else {
                                   tmp += sprintf( "%" + j + ".1i",
                                       zones[zone][1][i] );
                               }
                           }
                       }
                       break;
                   default:
                       tmp += "   (";
                       tmp += sprintf( "%3s",
                           ((100 * zones[zone][0]) / total + "%") );
                       tmp += ")";
                       break;
               }
               tmp += "\n";
               ret += tmp;
           }
        }
        if (verbose) {
           ret += "\n";
        }
    }
    ret += "Total = " + total + "\n";
    write("$P$Distribution$P$" + ret);
    return 1;
}
mixed *query_patterns() {
    return ({
        "by domain", (: cmd(0, 0, 0) :),
        "by guild level",  (: cmd("average", "guild level", 0) :),
        "by rating",  (: cmd("average", "rating", 0) :),
        "by age",  (: cmd("average", "age", 0) :),
        "by guild",  (: cmd("category", "guild", 0) :),
        "verbose by domain", (: cmd(0, 0, 1) :),
        "verbose by guild level",  (: cmd("average", "guild level", 1) :),
        "verbose by rating",  (: cmd("average", "rating", 1) :),
        "verbose by age",  (: cmd("average", "age", 1) :),
        "verbose by guild",  (: cmd("category", "guild", 1) :),
    });
}

==================================================
FILE: creator/random_name.c
==================================================

#include <random_names.h>
inherit "/cmds/base";
string lang_list;
void create() {
  lang_list = implode(RANDOM_NAME_GENERATOR->query_languages() +
                      RANDOM_NAME_GENERATOR->query_test_languages(), "|");
}
mixed cmd(string pattern, string my_lang) {
  string *langs;
  int i;
  if (pattern == "") {
    write("Generating one word from each language.  To generate more "
          "words in a particular language, specify the language on the "
          "command line.\n");
    langs = (string *)RANDOM_NAME_GENERATOR->query_languages() +
            RANDOM_NAME_GENERATOR->query_test_languages();
    for (i=0;i<sizeof(langs);i++) {
      write(capitalize(langs[i])+": "+
            (string)RANDOM_NAME_GENERATOR->random_name(langs[i])+"\n");
    }
    return 1;
  }
  write("Generateing 10 names in "+my_lang+"\n\n");
  for (i=0;i<10;i++) {
    write( (string)RANDOM_NAME_GENERATOR->random_name(my_lang)+"\n");
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd($5, "") :),
            "{"+lang_list+"}", (: cmd($5, $4[0]) :) });
}

==================================================
FILE: creator/rehash.c
==================================================

#include <armoury.h>
#define CMD_D "/secure/command"
mixed cmd(string str) {
  if (!str)
    return notify_fail("Syntax: rehash <path>\n");
  if (file_size(str) != -2)
    return notify_fail(str+": Path not found.\n");
  if (str[0..4] == "/doc/") {
     "/cmds/player/help"->rehash_specific_dir(str);
     write("Rehashed help dir: " + str + "\n");
     return 1;
  }
  if (str[0..4] == "/obj/" || str[0..2] == "/d/") {
     if (ARMOURY->rehash_specific_dir(str)) {
        write("Rehashed armoury dir: " + str + "\n");
        return 1;
     }
  }
  CMD_D->eventRehash(str);
  write(str+": Rehashed.\n");
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/req_uest.c
==================================================

#include <housing.h>
inherit "/cmds/base";
#include <armoury.h>
int request(string item, int condition, string area) {
  object ob;
  ob = ARMOURY->request_item(item, condition, area);
  if(!ob)
    return notify_fail(item + " not found.\n");
  ob->move(this_player());
  this_player()->add_succeeded_mess(ob, "$N $V $D\n", ({ }));
  log_file ("REQUEST", "%s: %s requested %s.\n",
    ctime (time()), this_player()->query_name(), item);
  return 1;
}
int list(string type, string filter) {
  mapping stuff;
  stuff = ARMOURY->query_items(type, filter);
  if(!sizeof(stuff))
     return this_player()->add_failed_mess(this_object(),
                                           "No such list.\n", ({ }));
  printf("Available " + type +" objects are:\n%-*#s\n",
         (int)this_player()->query_cols(),
         implode(keys(stuff), "\n"));
  this_player()->add_succeeded_mess(this_object(), "", ({ }));
  return 1;
}
int path(string item, int condition, string area) {
  object ob;
  string res;
  ob = ARMOURY->request_item(item, condition, area);
  if(!ob)
    return notify_fail("");
  if (ob->query_property("virtual name")) {
    res = "Virtual file for " + ob->the_short() +
      ":\n   " + ob->query_property("virtual name") + "\n";
  } else {
    res = "Path of " + ob->the_short() + ":\n   " + base_name(ob) + "\n";
  }
  ob->move("/room/rubbish");
  this_player()->add_succeeded_mess(ob, res, ({ }));
  return 1;
}
mixed *query_patterns() {
  return ({ "list <word'" + implode(ARMOURY->query_types(), "|") + "'>",
              (: list($4[0], "") :),
"list <word'" + implode(ARMOURY->query_types(), "|") + "'> <string'filter'>",
              (: list($4[0], $4[1]) :),
              "<word'area'> <string'item'>", (: request($4[1], 100, $4[0]) :),
              "<word'area'> <string'item'> <number'condition'>", (: request($4
[1], $4[2], $4[0]) :),
              "<string'item'>", (: request($4[0], 100, "") :),
              "<string'item'> <number'condition'>", (: request($4[0], $4
[1], "") :),
              "path <string'item'>", (: path($4[0], 100, "") :),
              "path <word'area'> <string'item'>", (: path($4[1], 100, $4
[0]) :),
        });
}

==================================================
FILE: creator/rm.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  int fsize, loop;
  string *filenames;
  seteuid(geteuid(this_player()));
  if (!str) {
    notify_fail("Usage: rm file [file ...]\n");
    return 0;
  }
  filenames = this_player()->get_files(str);
  if (!sizeof(filenames)) {
    notify_fail("No such file : "+ str+"\n");
    return 0;
  }
  for (loop = 0; loop < sizeof(filenames); loop++) {
    str = filenames[loop];
    fsize = file_size(str);
    if (str[<2..] == "/." || str[<3..] == "/..")
      continue;
    if (fsize == -1) {
      notify_fail("No such file or directory.\n");
      return 0;
    }
    if (fsize == -2) {
      if (!rmdir(str)) {
        notify_fail("Couldn't rm directory: " + str + "\n");
        return 0;
      }
    } else if (!rm(str)) {
      notify_fail("Can't remove file.\n");
      return 0;
    }
  }
  write("Ok.\n");
  return 1;
}

==================================================
FILE: creator/rmd_ir.c
==================================================

mixed cmd(string str) {
   string *filenames;
   int fsize, loop;
   seteuid(geteuid(this_player()));
   if (!str || str == "") {
      notify_fail("Remove what dir?\n");
      return 0;
   }
   filenames = this_player()->get_files(str);
   if (!sizeof(filenames)) {
      notify_fail("No such directory : " + str + "\n");
      return 0;
   }
   for(loop = 0; loop < sizeof(filenames); loop++) {
      str = filenames[loop];
      fsize = file_size(str);
      if (fsize == -1) {
         notify_fail(str + " doesn't exist.\n");
         return 0;
      }
      if (fsize != -2) {
         notify_fail(str + " is not a directory.\n");
         return 0;
      }
      if (!rmdir(str)) {
         notify_fail("Couldn't remove dir : " + str + "\n");
         return 0;
      }
   }
   write("Ok.\n");
   return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/sar.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  int i;
  string *files;
  string s1, s2, s3, s4;
  mixed *things;
  seteuid(geteuid(this_player()));
  if ( !str ) {
    notify_fail( "Usage: sar <search_string> <replace_string> <files>\n" );
    return 0;
  }
  s4 = str[ 0 .. 0 ];
  if ( sscanf( str, s4 +"%s"+ s4 +" "+ s4 +"%s"+ s4 +" %s", s1, s2, s3 ) != 3 )
    if ( sscanf( str, "%s %s %s", s1, s2, s3 ) != 3 ) {
      notify_fail( "Usage: sar <search_string> <replace_string> <files>\n" );
      return 0;
    }
  if(strsrch(s3, "*") == -1) {
    if(sizeof(things = WIZ_PRESENT->wiz_present(s3, this_player()))) {
      s3 = file_name(things[0]);
      sscanf(s3, "%s#%*d", s3);
      if (file_size(s3) <= 0)
        s3 += ".c";
    }
  }
  files = (string *)this_player()->get_files(s3);
  if(!sizeof(files))
  {
    notify_fail("File(s) " + s3 + " not found.\n");
    return 0;
  }
  s1 = replace( s1, "^M", "\n" );
  s2 = replace( s2, "^M", "\n" );
  for (i=0;i<sizeof(files);i++)
  {
    if (file_size(files[i]) <= 0) continue;
    printf("Looking at %s.\n", files[i]);
    s4 = read_file(files[i]);
    if (s4)
    {
      s4 = replace(s4, s1, s2);
      rm(files[i]);
      write_file(files[i], s4);
    }
    else
      printf("...failed...no file\n");
  }
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/scorepl_ayer.c
==================================================

inherit "/cmds/base";
#define SCORE_CMD "/cmds/player/score"
int score_quests(object *obs) {
   object play;
   foreach(play in obs) {
      write("Quests score for " + play->the_short() + ":\n");
      SCORE_CMD->score_quests(play);
   }
   return 1;
}
int score_stats(object *obs) {
   object play;
   foreach(play in obs) {
      write("Stats score for " + play->the_short() + ":\n");
      SCORE_CMD->score_stats(play, "verbose");
   }
   return 1;
}
int score_normal(object *obs) {
   object play;
   foreach(play in obs) {
      write("Score for " + play->the_short() + ":\n");
      SCORE_CMD->score_normal(play, "verbose");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "quests <indirect:player>", (: score_quests($1) :),
             "stats <indirect:player>", (: score_stats($1) :),
             "<indirect:any-living>", (: score_normal($1) :) });
}

==================================================
FILE: creator/screen.c
==================================================

inherit "/cmds/base";
object target;
int cmd(object player)
{
   target = player;
   if (target == this_player())
      return notify_fail("You start to send text to yourself, "
                         "but think better of it.\n");
   if (target->check_earmuffs("remote-spam")) {
      tell_object(target, sprintf("%s tried to screen some text to you.\n",
                                  this_player()->query_short()));
      return notify_fail(target->query_short() +
                         " currently has " + target->query_possessive() +
                         " screen earmuffs on, ask " +
                         target->query_possessive() + " to turn "
                         "them off.\n");
   }
   tell_object(target, sprintf("Receiving text from %s.\n",
                               this_player()->query_short()));
   tell_object(this_player(),
               sprintf("Sending text to %s. Use ** to stop.\n]",
                       target->query_short()));
   input_to("do_screen");
   return 1;
}
void do_screen(string spam)
{
   if (spam == "**") {
      tell_object(target,
                  sprintf("Stopped receiving text from %s.\n",
                          this_player()->query_short()));
      tell_object(this_player(),
                  sprintf("Stopped sending text to %s.\n",
                          target->query_short()));
      return;
   }
   if (spam) {
      tell_object(target, "] " + spam + "\n");
      write("] ");
   }
   input_to("do_screen");
}
int screen_toggle(string toggle)
{
   if (toggle == "on") {
      if (member_array("remote-spam",
                       this_player()->query_property("earmuffs")) == -1)
         return notify_fail("You aren't earmuffing remote-spam events!\n");
      this_player()->add_property("earmuffs",
                                  (this_player()->query_property("earmuffs") -
                                   ({ "remote-spam" })));
      write("Remote-spam earmuffs off.\n");
      return 1;
   }
   if (toggle == "off") {
      if (member_array("remote-spam",
                       this_player()->query_property("earmuffs")) != -1)
         return
            notify_fail("You are already earmuffing remote-spam events!\n");
      this_player()->add_property("earmuffs",
                                  (this_player()->query_property("earmuffs") +
                                   ({ "remote-spam" })));
      write("Remote-spam earmuffed.\n");
      if (!this_player()->query_earmuffs())
         write("Remeber to \"earmuff on\" to enable them.\n");
      return 1;
   }
}
mixed *query_patterns()
{
   return ({ "<indirect:player>", (: cmd($1[0]) :),
             "{on|off}", (: screen_toggle($4[0]) :) });
}

==================================================
FILE: creator/set.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  return (int)PEOPLER->set_var(str);
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/setmin.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(string str) {
  if(TP->query_creator() || TP->query_property("setm")) {
    str = str + " ";
    if(sizeof(explode("^"+str, "$N")) < 2 ||
       sizeof(explode("^"+str, "$F")) < 2)
      return notify_fail("Must have a $N and a $F in your entry message.\n");
    TP->set_msgin(str);
    write("Ok.\n");
    return 1;
  }
  return notify_fail("You are not allowed that power yet.\n");
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/setmmin.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(string str) {
  if(TP->query_creator() || TP->query_property("setm")) {
    str = str + " ";
    if (sizeof(explode("^"+str, "$N")) < 2)
      return notify_fail("Must have a $N in your teleport entry message.\n");
    TP->set_mmsgin(str);
    write("Ok.\n");
    return 1;
  }
  return notify_fail("You are not allowed that power yet.\n");
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/setmmout.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(string str) {
  if(TP->query_creator() || TP->query_property("setm")) {
    str = str + " ";
    if (sizeof(explode("^"+str, "$N")) < 2)
      return notify_fail("Must have a $N in your teleport exit message.\n");
    TP->set_mmsgout(str);
    write("Ok.\n");
    return 1;
  }
  return notify_fail("You are not allowed that power yet.\n");
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/setmout.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(string str) {
  if(TP->query_creator() || TP->query_property("setm")) {
    str = str + " ";
    if(sizeof(explode("^"+str, "$N")) < 2 ||
       sizeof(explode("^"+str, "$T")) < 2)
      return notify_fail("Must have a $N and a $T in your exit message.\n");
    TP->set_msgout(str);
    write("Ok.\n");
    return 1;
  }
  return notify_fail("You are not allowed that power yet.\n");
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/sh_adows.c
==================================================

#include <creator.h>
inherit "/cmds/base";
int cmd(object *indirect_obs) {
  object *objs, *shadows, ob, shad, nobj;
   objs = indirect_obs;
  foreach (ob in objs) {
    shadows = ({ });
     nobj = ob;
     while(nobj = shadow(nobj, 0))
       shadows += ({ nobj });
     if(!sizeof(shadows)) {
       write(WIZ_PRESENT->desc_f_object(ob) + " is not being shadowed.\n");
     } else {
       write(WIZ_PRESENT->desc_f_object(ob) + " is being shadowed by:\n");
       foreach (shad in shadows)
         write("    " + file_name(shad) + "\n");
    }
  }
  return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:wiz-present>", (: cmd( $1 ) :) });
}

==================================================
FILE: creator/show_help.c
==================================================

#include <playerinfo.h>
inherit "/cmds/base";
#define WHO(n) globals[n]
private nosave mapping globals = ([]);
mixed show_help(object *player, string helpname) {
   player[0]->set_finish_func("who_did_it", this_object());
   WHO(player[0]) = capitalize(this_player()->query_name());
   if (!player[0]->eventForce("help "+ helpname)) {
      map_delete(globals, player[0]);
      return notify_fail("The help command failed ... Did you specify the "
              "correct help subject ?\n");
   }
   event(users(), "inform", capitalize(this_player()->query_name())+
         " showed help on \"" + helpname + "\" to " + player[0]->the_short(),
         "help");
   write("Okay, showed help on \"" + helpname + "\" to " +
         player[0]->query_cap_name() + ".\n");
   PLAYERINFO_HANDLER->add_entry(this_player(),
                                 player[0]->query_name(),
                                 "showhelp",
                                 "Showed help on " + helpname,
                                 0);
   return 1;
}
int who_did_it() {
   tell_object(previous_object(), WHO(previous_object()) +
         " wanted you to read this help file.\n");
   map_delete(globals, previous_object());
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:player> <string'help file'>",
             (: show_help($1, $4[1]) :) });
}

==================================================
FILE: creator/shutdown.c
==================================================

inherit "/cmds/base";
mixed cmd(int tim, string reason, int force) {
  string str;
  seteuid(geteuid(this_player()));
  str = (string)this_player()->query_name()+" at "+ctime(time());
#ifdef GAME_LOG
  log_file("GAME_LOG", "Game shutdown by ");
  log_file("GAME_LOG", str);
  log_file("GAME_LOG", " for\n");
  log_file("GAME_LOG", num + " " + reason);
  log_file("GAME_LOG", "\n\n");
#endif
  write("Ok... shutting down game... \n");
  if (tim < 10 && (!master()->query_lord(geteuid(this_object())) && !force)) {
    tim = 10;
  }
  if (!tim) {
    "/obj/shut"->end_it_all(reason);
  } else {
    "/obj/shut"->shut(tim, reason);
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<number'number of minutes'> <string'reason'>",
              (: cmd($4[0], $4[1], 0) :),
              "now <string'reason'>", (: cmd(0, $4[0], 1) :),
              });
}

==================================================
FILE: creator/sne_tstat.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#include <peopler.h>
mixed cmd(string str) {
   mixed *bing;
   bing = (mixed *)this_player()->query_property("netstat list");
   if (!bing) {
     bing = SN_DEFAULT;
   }
   (int)PEOPLER->do_command( bing, str,
                         (: strcmp(query_ip_number($1), query_ip_number($2)) :) );
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/snoop.c
==================================================

inherit "/cmds/base";
int do_snoop_cancel() {
  seteuid(geteuid(this_player()));
  if (!query_snooping(this_player()))
    write("You aren't snooping anyone.\n");
  else  {
    snoop(this_player(), 0);
    write("Ok, snoop cancelled.\n");
  }
  return 1;
}
int do_snoop(object *obs) {
  object targ;
  targ = obs[0];
  if(!snoop(this_player(), targ)) {
    notify_fail("You fail to snoop " + targ->the_short() + ".\n");
    return 0;
  }
  write("Ok, snooping "+targ->the_short()+".\n");
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:player>", (: do_snoop($1) :),
            "", (: do_snoop_cancel() :) });
}

==================================================
FILE: creator/snoope_rs.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  object *obs;
  int i;
  obs = (object *)PEOPLER->get_people(str);
  obs = filter_array(obs, "check_snoop", this_object());
  if (!sizeof(obs)) {
    notify_fail("No one is being snooped by anyone.\n");
    return 0;
  }
  for (i=0;i<sizeof(obs);i++)
    write(obs[i]->query_cap_name()+" is snooping "+
          obs[i]->query_snoopee()->query_cap_name()+".\n");
  return 1;
}
int check_snoop(object ob) {
  if((object)ob->query_snoopee())
    return 1;
  else
    return 0;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/sockets.c
==================================================

inherit "/cmds/base";
mixed cmd(string ) {
  this_player()->more_string(dump_socket_status());
  return 1;
}

==================================================
FILE: creator/spell.c
==================================================

inherit "/cmds/base";
#include <network.h>
void finish_lookup(object player, string word, int result, mixed* results) {
   if (result == NETWORK_SUCCESS) {
      if (!sizeof(results)) {
         tell_object(player, "Matches for " + word + ": None.\n");
      } else {
         tell_object(player, "Matches for " + word + ": " +
                             query_multiple_short(map(results, (: $1[1] :))) +
                             "\n");
      }
   } else {
      tell_object(player, "Error matching " + word + ": " + result);
   }
}
int cmd(string word) {
   NETWORK_DICTIONARY_HANDLER->spell_word(word, 0,
                        (: finish_lookup($(this_player()), $1, $2, $3) :));
   add_succeeded_mess("$N look$s up a word.\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/sql.c
==================================================

#include <config.h>
#include <db.h>
inherit "/cmds/base";
private mapping fd = ([]), com = ([]);
#define FD fd[this_player()]
#define COM com[this_player()]
void prompt(string db, string user, string pass, object player){
   if(!strlen(COM)) {
      tell_object(player, "sql> ");
   } else {
      tell_object(player, "  -> ");
   }
   input_to("main", 0, db, user, pass);
}
int cmd(string arg, string user, string passwd){
   string err;
   if(!passwd){
      passwd = "";
   }
   if(!user){
      user = CONFIG_DB_USER;
   }
   if (stringp(err)){
      return notify_fail(err);
   }
   write("Welcome to the " + mud_name() + " SQL monitor.  Commands end with ; .\n\nType 'help' for help."
        "\n\n");
   COM = "";
   prompt(arg, user, passwd, this_player());
   return 1;
}
void finish_query(int result, mixed params, string db, string user,
                  string passwd, object player) {
   mapping row;
   string *keys;
   string key;
   if (result != DB_SUCCESS) {
      tell_object(player, "Failed: " + params + ".\n");
      return ;
   }
   foreach (row in params) {
      if (!keys) {
         keys = keys(row);
         foreach (key in keys) {
            tell_object(player, key + "   ");
         }
      }
      foreach (key in keys) {
         tell_object(player, row[key] + "   ");
      }
      tell_object(player, "\n");
   }
   prompt(db, user, passwd, player);
}
void main(string input, string db, string user, string passwd){
   if(strlen(input)) {
      while(input[<1] == ' ') {
         input = input[0..<2];
      }
      while(input[0] == ' ') {
         input = input[1..];
      }
   }
  switch(input){
  case "clear":
    COM = "";
    return prompt(db, user, passwd, this_player());
  case "edit":
    this_player()->do_edit(COM, "edfin", this_object(), 0, ({ db, user, passwd }));
    return;
  case "quit":
    printf("Use 'exit' to quit.\n");
    return prompt(db, user, passwd, this_player());
  case "exit":
    map_delete(fd, this_player());
    map_delete(com, this_player());
    return;
  case "help":
    printf(@END
'help' prints this help.
'clear' clears the command you are working on.
'edit' enters the editor so you can edit your query.
'exit' quits sql.
END);
    return prompt(db, user, passwd, this_player());
  default:
    if(strlen(input) && input[<1] == ';'){
      COM += input[0..<2] + "\n";
      DB_HANDLER->make_sql_request(db, user, passwd, input,
                                  (: finish_query($1, $2, $(db), $(user), $(passwd), $(this_player())) :));
      input_to("main", db, user, passwd);
      COM="";
     tell_creator ("drakkos", "Bing %s.\n", input);
      return ;
    } else {
      COM += input + "\n";
    }
    prompt(db, user, passwd, this_player());
  }
}
void edfin(string input, string* args){
  COM=input;
  prompt(args[0], args[1], args[2], this_player());
}
mixed *query_patterns() {
   return ({ "<word'database'>", (:cmd($4[0], CONFIG_DB_USER, 0) :),
            "<word'database'> -u <word'user'>", (:cmd($4[0], $4[1], 0):),
            "<word'database'> -u <word'user'> -p <word'password'>",
                                    (:cmd($4[0], $4[1], $4[2]):)});
}

==================================================
FILE: creator/sqlcmd.c
==================================================

#include <db.h>
#include <config.h>
mapping *results;
void set_results( int flag, mapping *res, object who);
int cmd( string db, string query ) {
  DB_HANDLER->make_sql_request( db, CONFIG_DB_USER, "", query,
  (: set_results( $1, $2, $(this_player()) ) :) );
  return 1;
}
void set_results( int flag, mapping *res, object who ) {
  tell_creator( who, "flag: %O\n%O\n", flag, res );
  results = res;
}
mapping *query_results() { return results; }
mixed query_patterns() {
  return ({
    "<word'db'> <string:quoted'query'>",
    (: cmd( $4[0], $4[1] ) :) });
}

==================================================
FILE: creator/st_at.c
==================================================

#include <creator.h>
inherit "/cmds/base";
mixed cmd(string str) {
  object *ob, thing;
  mixed *ob1, *thing1;
  string s, bing;
  string long_fields, temp;
  int long_length;
  bing = "";
  str = (string)this_player()->expand_nickname(str);
  ob = WIZ_PRESENT->wiz_present(str, this_player());
  if (!sizeof(ob)) {
    write("No such object.\n");
    return 1;
  }
  foreach (thing in ob) {
    ob1 = (mixed *)thing->stats();
    if (!pointerp(ob1))
      continue;
    s = "";
    long_fields = "";
    long_length = ( (int)this_player()->query_cols() / 3 ) - 1;
    foreach (thing1 in (pointerp(ob1[0][0])?ob1[0]:ob1)) {
      if (thing1[1]) {
        temp = thing1[0] +": "+ sprintf("%O", thing1[1]) +"\n";
        if (strlen(temp) > long_length) {
          long_fields += temp;
        } else {
          s += temp;
        }
      }
    }
    bing += sprintf("%-*#s\n", this_player()->query_cols(), long_fields) +
      sprintf( "%-*#s\n", this_player()->query_cols(), s );
  }
  this_player()->more_string(bing, "Stat");
  return 1;
}

==================================================
FILE: creator/stats.c
==================================================

inherit "/cmds/base";
#define TP this_player()
#define STATS ({"con", "dex", "int", "str", "wis"})
#define GUILDS ({"assassin", "priest", "thief", "warrior", "witch", "wizard"})
#define TREES ({"covert", "crafts", "faith", "fighting", "magic", "other" })
string get_stat(string s) {
  switch(s) {
  case "S": return "str";
  case "I": return "int";
  case "W": return "wis";
  case "D": return "dex";
  case "C": return "con";
  }
}
int cmd() {
  object user;
  string guild_ob, stat, str;
  mapping stats;
  int val, m, i;
  mapping tmp;
  mapping mode;
  stats = ([ ]);
  foreach(user in users()) {
    if(user->query_creator() || user->query_known_command("rearrange"))
      continue;
    tmp = ([]);
    guild_ob = user->query_guild_ob();
    if(guild_ob)
      guild_ob = guild_ob->query_name();
    if(stats[guild_ob])
      tmp = stats[guild_ob];
    else {
      foreach(stat in STATS) {
        tmp[stat] = ({ 0, 0, 0, 0 });
      }
    }
    if(!mode)
      mode = ([ ]);
    if(!mode[guild_ob])
      mode[guild_ob] = ([ ]);
    foreach(stat in STATS) {
      val = call_other(user, "query_real_" + stat);
      tmp[stat][0] += 1;
      tmp[stat][1] += val;
      if(tmp[stat][2] > val || !tmp[stat][2]) {
        tmp[stat][2] = val;
      }
      if(tmp[stat][3] < val) {
        tmp[stat][3] = val;
      }
      if(!mode[guild_ob][stat])
        mode[guild_ob][stat] = ([ val : 1 ]);
      else if(!mode[guild_ob][stat][val])
        mode[guild_ob][stat][val] = 1;
      else
        mode[guild_ob][stat][val] += 1;
    }
    stats[guild_ob] = tmp;
  }
  write("stat: min max mode ave\n");
  foreach(guild_ob in keys(stats)) {
    if(!guild_ob)
      continue;
    printf("\n%s:\n", guild_ob);
    str = "";
    foreach(stat in STATS) {
      m = 0;
      foreach(i in keys(mode[guild_ob][stat]))
        if(mode[guild_ob][stat][i] > m) {
          val = i;
          m = mode[guild_ob][stat][i];
        }
      str += sprintf("  %s: %2d %2d %2d %2d\n",
                     stat,
                     stats[guild_ob][stat][2], stats[guild_ob][stat][3],
                     val, stats[guild_ob][stat][1] / stats[guild_ob][stat][0]);
    }
    printf("%-#*s", this_player()->query_cols(), str);
  }
  printf("\n");
  return 1;
}
int guild(string gstr) {
  string user, stat, gob, tstr, guild;
  mapping count, total;
  int val, i;
  foreach(guild in GUILDS) {
    if(gstr && gstr != guild && gstr != guild+"s" &&
       gstr != guild+"es")
      continue;
    gob = "/std/guilds/" + guild;
    count = ([ ]);
    total = ([ ]);
    foreach(user in users()) {
      if(user->query_guild_ob() != gob || user->query_creator() ||
         user->query_known_command("rearrange"))
        continue;
      foreach(stat in STATS) {
        total[stat] += 1;
        val = call_other(user, "query_real_" + stat);
        if(!count[stat])
          count[stat] = ([ val : 1 ]);
        if(!count[stat][val])
          count[stat][val] = 1;
        else
          count[stat][val] += 1;
      }
    }
    if(!sizeof(count))
      return notify_fail("No players in that guild.\n");
    write("\nStats for " + guild + "\n");
    foreach(stat in STATS)
      printf("%-13s", "   " + capitalize(stat));
    write("\n");
    for(val = 8; val <= 23; val++) {
      foreach(stat in STATS) {
        tstr = "";
        for(i=0; i<((count[stat][val] * 10) / total[stat]); i++)
          tstr += "#";
        printf("%2d %-10s", val, tstr);
      }
      write("\n");
    }
  }
  return 1;
}
int stats(string sstr) {
  string user, guild, tstr, st;
  mapping count, total;
  int val, i;
  foreach(st in STATS) {
    if(sstr && st[0] != sstr[0])
      continue;
    count = ([ ]);
    total = ([ ]);
    foreach(user in users()) {
      if(user->query_creator() || user->query_known_command("rearrange"))
        continue;
      guild = replace(user->query_guild_ob(), "/std/guilds/", "");
      if(!guild)
        continue;
      val = call_other(user, "query_real_" + st);
      if(!count[guild])
        count[guild] = ([ val : 1 ]);
      else
        count[guild][val] += 1;
      total[guild] += 1;
    }
    if(!sizeof(count))
      return notify_fail("No players in that guild.\n");
    write("\nValues for " + capitalize(st) + "\n");
    foreach(guild in GUILDS)
      printf("%-13s", "   " + capitalize(guild));
    write("\n");
    for(val = 8; val <= 23; val++) {
      foreach(guild in GUILDS) {
        tstr = "";
        for(i=0; i<((count[guild][val] * 10) / total[guild]); i++) {
          tstr += "#";
        }
        printf("%2d %-10s", val, tstr);
      }
      write("\n");
    }
  }
  return 1;
}
int primaries() {
  string guild, skill, st, stats;
  mapping count;
  int i, total;
  string str;
  write("Guild Primaries\n");
  foreach(guild in GUILDS) {
    write(guild + "\n");
    count = ([ ]);
    total = 0;
    str = "";
    foreach(skill in ("/std/guilds/" + guild)->query_skills()) {
      stats = "/std/skills"->query_skill_stat(skill);
      total += sizeof(stats);
      for(i=0; i<sizeof(stats); i++) {
        st = get_stat(stats[i..i]);
        count[st] += 1;
      }
    }
    foreach(st in STATS) {
      str += sprintf("  %s: %2d%%\n",
                     capitalize(st), (count[st] * 100) / total);
    }
    printf("%-#*s", this_player()->query_cols(), str);
    write("\n");
  }
  return 1;
}
int skills() {
  string tree, skill, st, stats;
  mapping count;
  int i, total;
  string str;
  write("Guild Primaries\n");
  foreach(tree in TREES) {
    write(tree + "\n");
    count = ([ ]);
    total = 0;
    str = "";
    foreach(skill in ("/std/skills")->query_all_children(tree)) {
      stats = "/std/skills"->query_skill_stat(skill);
      total += sizeof(stats);
      for(i=0; i<sizeof(stats); i++) {
        st = get_stat(stats[i..i]);
        count[st] = 1;
      }
    }
    foreach(st in STATS) {
      str += sprintf("  %s: %2d%%\n",
                     capitalize(st), (count[st] * 100) / total);
    }
    printf("%-#*s", this_player()->query_cols(), str);
    write("\n");
  }
  return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :),
             "guild", (: guild(0) :),
             "guild <word'guild'>", (: guild($4[0]) :),
             "stat", (: stats(0) :),
             "stat <word'guild'>", (: stats($4[0]) :),
             "primaries", (: primaries() :),
             "skills", (: skills() :) });
}

==================================================
FILE: creator/statthief.c
==================================================

#include <player_handler.h>
inherit "/cmds/base";
#define QUOTA "/obj/handlers/guild_things/quota"
#define MONEY "/obj/handlers/money_handler"
string cost_str(int amt);
string time_str(int time);
int cmd(string str) {
  if(!str || !PLAYER_HANDLER->test_user(str))
    return notify_fail("Get thief stats for who?\n");
  if( !QUOTA->query_quota_data( str ) )
    return notify_fail("Sorry, "+str+" does not have a quota.\n");
  printf("Thief statistics for: %s\n", str);
  printf("  Quota: \n");
  printf("    Min %s\n", cost_str((int)QUOTA->query_thief_minquota(str)));
  printf("    Max %s\n", cost_str((int)QUOTA->query_thief_maxquota(str)));
  printf("  Debts:\n");
  printf("    Debts %s\n", cost_str(QUOTA->query_thief_debts(str)));
  printf("    Fines %s\n", cost_str(QUOTA->query_thief_fines(str)));
  printf("  This period:\n");
  printf("    Stolen %s\n", cost_str(QUOTA->query_total_stolen(str)));
  printf("    Time left %s\n", time_str(QUOTA->query_time_to_reset(str)));
  return 1;
}
string cost_str(int amt) {
  return MONEY->money_string(MONEY->create_money_array(amt, "Ankh-Morpork"));
}
string time_str(int time) {
  string str;
  str = "";
  if (time > 86400)
    str += sprintf("%d days, ", time/86400);
  if (time > 3600)
    str += sprintf("%d hours, ", (time/3600)%24);
  str += sprintf("%d minutes and %d seconds",
                     (time/60)%60, time%60);
  return str;
}

==================================================
FILE: creator/status.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  if (str)
    this_player()->more_string(mud_status(1), "Status info");
  else
    printf("%s", mud_status());
  return 1;
}
mixed* query_patterns() {
   return ({ "", (: cmd(0) :),
             "detailed", (: cmd("detailed") :) });
}

==================================================
FILE: creator/suspend.c
==================================================

#include <parser.h>
#include <access.h>
inherit "/cmds/base";
#define MULTI_SUSPEND 28*24
#define LIAISON "/d/liaison/master"
private int do_suspend(string, int, string);
private int cmd(string name, int tim, string type, string reason) {
  if (this_player() != this_player(1)) {
    return 0;
  }
  if (!master()->query_lord(geteuid(previous_object())) &&
      !LIAISON->query_deputy(geteuid(previous_object()))) {
    return notify_fail("You must be a lord or liaison deputy to suspend "
                       "someone.");
  }
  if ( type[<1] != 's' ) {
      type += "s";
  }
  switch (type) {
    case "days":
        tim *= 24;
    break;
    case "weeks":
        tim *= 24 * 7;
    break;
    case "months":
        tim  *= 24 * 7 * 4;
    break;
    case "years":
        tim *= 24 * 365;
    break;
    case "hours":
    break;
    default:
  }
  if (!master()->query_lord (geteuid(previous_object()))
      && LIAISON->query_deputy(geteuid(previous_object()))
      && tim > MULTI_SUSPEND) {
    return notify_fail ("You can only suspend for a maximum of " +
      query_num (MULTI_SUSPEND) + " hours.");
  }
  return do_suspend(name, tim, reason);
}
private int suspend(string who, string reason) {
  if(this_player() != this_player(1))
    return 0;
  if (!master()->query_lord(geteuid(previous_object())) &&
      !master()->query_senior(geteuid(previous_object())) &&
      !LIAISON->query_member(geteuid(previous_object()))) {
    return notify_fail("Only liaisons or seniors can do that.\n");
  }
  return do_suspend(who, 2, reason);
}
#ifdef SUSPEND_MULTI
private int suspend_multi(string who) {
  if(this_player() != this_player(1))
    return 0;
  if (!"/secure/master"->query_lord(geteuid(previous_object())) &&
      !LIAISON->query_deputy(geteuid(previous_object()))) {
    return notify_fail("You must be a lord or liaison deputy to suspend "
                       "someone for multiplaying.");
  }
  return do_suspend(who, MULTI_SUSPEND, "Multiplaying");
}
#endif
private int do_suspend(string name, int tim, string reason) {
  notify_fail("We failed!\n");
  if (!"/secure/bastards"->suspend_person(name, tim*60*60, reason)) {
    return 0;
  }
  write(name+" suspended until "+ctime(time()+tim*60*60)+"\n");
  return 1;
}
int help() {
  if(!"/secure/master"->query_lord(geteuid(previous_object())) &&
     !LIAISON->query_member(this_player()->query_name()))
    return notify_fail("You cannot use suspend.\n");
  if(this_player()->query_lord() ||
     master()->query_senior(geteuid(previous_object())) ||
     LIAISON->query_member(geteuid(previous_object())))
    write("suspend <name> <reason> -- will suspend a player for 2 hours.\n");
#ifdef SUSPEND_MULTI
  if(this_player()->query_lord() ||
     LIAISON->query_deputy(geteuid(this_player())))
    write("suspend <name> multiplaying -- will suspend a multiplayer for "
          "2 weeks.\n");
#endif
  if (LIAISON->query_deputy(geteuid(this_player()))) {
    write("suspend <name> <time> <reason> where time is in hours.\n");
    write ("You may suspend people for a maximum of "
      + query_num (MULTI_SUSPEND) + " hours as a liaison deputy.\n");
  }
  if ("/secure/master"->query_lord(geteuid(this_player()))) {
    write("suspend <name> <time> <reason> where time is in hours.\n");
    write("suspend <name> <time> <hours|days|weeks|months|years> <reason> "
        "where time is in the units specified in the command.\n");
  }
  return 1;
}
public mixed *query_patterns() {
  mixed retval;
  retval = ({ "help", (: help() :) });
  if( master()->query_lord(geteuid(this_player())) ||
     master()->query_senior(geteuid(previous_object())) ||
     LIAISON->query_member(geteuid(previous_object())))
    retval += ({ "<word'player'> <string'reason'>",
                   (: suspend($4[0], implode($4[1..], " ")) :) });
#ifdef SUSPEND_MULTI
  if(this_player()->query_lord() ||
     LIAISON->query_deputy(geteuid(this_player())))
    retval += ({ "<word'player'> multiplaying",
                   (: suspend_multi($4[0]) :) });
#endif
  if( master()->query_lord(geteuid(this_player())) ||
        LIAISON->query_deputy(geteuid(this_player()))) {
        retval += ({ "<word'player'> <number'time'> <string'reason'>",
                   (: cmd($4[0], $4[1], "hours", implode($4[2..], " ") ) :) });
        retval += ({ "<word'player'> <number'time'> "
            "<word'hours|days|weeks|months|years'> <string'reason'>",
                   (: cmd($4[0], $4[1], $4[2], implode($4[3..], " ") ) :) });
  }
  return retval;
}

==================================================
FILE: creator/tasks.c
==================================================

#include <skills.h>
#define SAVE_FILES "/save/tasks/"
inherit "/cmds/base";
mapping awards;
void create() { seteuid( "Root" ); }
void main_menu( string word ) {
   int i, j, *numbers;
   string text, *words;
   if ( !word || ( word == "" ) )
      word = " ";
   switch ( word[ 0 ] ) {
      case 'Q' :
      case 'q' :
         return;
      case 'L' :
      case 'l' :
         words = get_dir( SAVE_FILES +"*.o" );
         if ( !sizeof( words ) ) {
            printf( "No tasks have been logged.\n" );
            return;
         }
         for ( i = sizeof( words ) - 1; i > -1; i-- ) {
            words[ i ] = words[ i ][ 0 .. strlen( words[ i ] ) - 3 ];
            if ( sizeof( (string *)SKILL_OB->
                  query_immediate_children( words[ i ] ) ) )
               words[ i ] += sprintf( "%*s", 60 - strlen( words[ i ] ),
                     "[non-primary]" );
         }
         this_player()->set_finish_func( "main_menu", this_object() );
         this_player()->more_string( "Skills with logged tasks are:\n   "+
               implode( words, "\n   " ) +"\n", "Tasks", 1 );
         return;
      case 'C' :
      case 'c' :
         if ( strlen( word ) < 4 ) {
            printf( "Syntax: C <skill>\n" );
            break;
         }
         word = word[ 2 .. ];
         if ( file_size( SAVE_FILES + word +".o" ) < 1 ) {
            printf( "There are no tasks logged for "+ word +".\n" );
            break;
         }
         unguarded( (: restore_object, SAVE_FILES + word :) );
         numbers = allocate( 5 );
         text = "Skill awards made for "+ word +":\n";
         foreach ( i in sort_array( keys( awards ), 1 ) ) {
            j = 0;
            foreach ( word in keys( awards[ i ] ) )
               j += awards[ i ][ word ];
            text += sprintf( "   level%5d awarded by%5d tasks\n", i, j );
            if ( i < 301 )
               switch ( j ) {
                  case 1 .. 4 :
                     numbers[ 0 ]++;
                     break;
                  case 5 .. 9 :
                     numbers[ 1 ]++;
                     break;
                  case 10 .. 19 :
                     numbers[ 2 ]++;
                     break;
                  case 20 .. 49 :
                     numbers[ 3 ]++;
                     break;
                  default :
                     numbers[ 4 ]++;
               }
         }
         text += sprintf( "Coverage at the  1 task level is%4d%%.\n",
               ( numbers[ 0 ] + numbers[ 1 ] + numbers[ 2 ] +
               numbers[ 3 ] + numbers[ 4 ] ) / 3 );
         text += sprintf( "Coverage at the  5 task level is%4d%%.\n",
               ( numbers[ 1 ] + numbers[ 2 ] + numbers[ 3 ] +
               numbers[ 4 ] ) / 3 );
         text += sprintf( "Coverage at the 10 task level is%4d%%.\n",
               ( numbers[ 2 ] + numbers[ 3 ] + numbers[ 4 ] ) / 3 );
         text += sprintf( "Coverage at the 20 task level is%4d%%.\n",
               ( numbers[ 3 ] + numbers[ 4 ] ) / 3 );
         text += sprintf( "Coverage at the 50 task level is%4d%%.\n",
               numbers[ 4 ] / 3 );
         this_player()->set_finish_func( "main_menu", this_object() );
         this_player()->more_string( text, "Tasks", 1 );
         return;
      case 'H' :
      case 'h' :
         printf( "\nTasks editor commands:\n\n"+
               "Q         : quit the quest editor\n"+
               "L         : list tasked skills\n"+
               "C <skill> : examine coverage for <skill>\n"+
               "H         : get this list of commands\n\n" );
         break;
      default :
   }
   printf( "Choose one of Q, L, C or H (for help) : " );
   input_to( "main_menu" );
}
int cmd() {
   main_menu( "L" );
   return 1;
}

==================================================
FILE: creator/tcheck.c
==================================================

int cmd( string str ) {
   mixed  err, ret;
   object ob;
   string file, wiz_dir;
   if (!this_player()) return 0;
   seteuid(geteuid(this_player()));
   if (!str) {
      notify_fail("Usage: tcheck <file name>\n");
      return 0;
   }
   wiz_dir = "/w/" + (string)this_player()->query_name();
   if (file_size(wiz_dir)!=-2) {
      notify_fail("Directory: " + wiz_dir + " does not exist.\n");
      return 0;
   }
   if ( str[0..0] != "/" )
     str = (string)this_player()->query_path() + "/" + str;
   if (str[<1..<1]=="0") {
      str=str[0..<2];
   }
   if (file_size(str)<0) {
      notify_fail("File: " + str + " does not exist or is a directory.\n");
      return 0;
   }
   file = wiz_dir + "/exec_tmp";
   if (find_object(file)) file->dest_me();
   if (file_size(file+".c")>0) rm(file+".c");
   write_file(file+".c",
              "#pragma strict_types\n" +
              "#pragma save_types\n" +
              "#include \""+ str +"\"\n" +
              "void dest_me_in_exec_temp() { destruct(this_object()); }\n" +
              "\n");
   err = catch(ret = (mixed) file->force_load());
   if (err==0) printf("%s loaded ok.\n", str);
   if (find_object(file)) file->dest_me_in_exec_temp();
   rm(file+".c");
   return 1;
}
void dest_me() {
   destruct(this_object());
}
void clean_up() {
   dest_me();
}
void reset() {
   dest_me();
}

==================================================
FILE: creator/tell!.c
==================================================

#include <drinks.h>
#include <language.h>
#include <player.h>
#define TP this_player()
inherit "/cmds/base";
inherit "/cmds/speech";
#ifdef USE_SMILEYS
string *two_smileys = ({":)", ":(", ":P", ":p", ":b", ";)",
  ";(", ";P", ";p", ";b", "=)", "=("});
string *three_smileys = ({":-)", ":-(", ":-P", ":-p", ":-b",
  ";-)", ";-(", ";-P", ";-p", ";-b", ":o)", ":o(", ":oP",
  ":op", ":ob", ";o)", ";o(", ";oP", ";op", ";ob", "=-)",
  "=-(", "=o)", "=o("});
#endif
int cmd( string arg, mixed thing, int silent ) {
   string word, lang, words, emotion;
#ifdef USE_SMILEYS
   string smiley, smiley_words;
#endif
   string them_mess, temp;
   string me_mess;
   object *obs;
   object *net_dead;
   object *fail;
   mixed busy;
   emotion = "";
   if (pointerp(thing)) {
      words = arg;
   } else if ( !objectp( thing ) ) {
      if ( !arg || sscanf( arg, "%s %s", word, words ) != 2 )
         return 0;
      word = lower_case( word );
      word = (string)TP->expand_nickname( word );
      thing = find_player( word );
      if ( !thing ) {
         if ( sscanf( word, "%*s@%*s" ) == 2 ) {
            "/net/daemon/out_tell"->do_tell( word+" "+words );
            return 1;
         }
         add_failed_mess( capitalize( word ) +" is not logged in.\n" );
         return 0;
      }
   } else {
      words = arg;
   }
   if (!pointerp(thing)) {
      obs = ({ thing });
   } else {
      obs = thing;
   }
   obs -= ({ this_player() });
   if ( !sizeof(obs) ) {
      add_failed_mess( "Talking to yourself again.  I don't know.\n" );
      return 0;
   }
   if (sizeof(obs) > 20) {
      add_failed_mess("You can only tell up to 20 people a message.\n");
      return 0;
   }
   fail = this_player()->query_ignoring(obs);
   if ( sizeof( fail ) )  {
      write( "You are currently ignoring " +
             query_multiple_short( fail ) + ", so " +
             (sizeof(fail) > 1 ? " they" : fail[0]->query_pronoun()) +
             " couldn't reply anyway.\n" );
      obs -= fail;
      if ( !sizeof( obs ) )  {
         return 1;
      }
   }
   lang = (string)TP->query_current_language();
   if ( !LANGUAGE_HAND->query_language_spoken( lang ) ) {
      return notify_fail( capitalize( lang ) +
            " is not a spoken language.\n" );
   }
   if ( !LANGUAGE_HAND->query_language_distance( lang ) ) {
      return notify_fail( capitalize( lang ) +
            " is not able to be spoken at a distance.\n" );
   }
#ifdef USE_SMILEYS
  if(sizeof(words) >= 3) {
    if(member_array(words[<3..], three_smileys) != -1) {
      smiley = words[<3..];
    } else if(member_array(words[<2..], two_smileys) != -1) {
      smiley = words[<2..];
    }
  } else if(member_array(words, three_smileys) != -1) {
    smiley = words;
  } else if(member_array(words, two_smileys) != -1) {
    smiley = words;
  }
#endif
  word = query_word_type(words, "");
  if(word != "") {
    word = " "+word+"ing";
  }
#ifdef USE_SMILEYS
  if(smiley) {
    if(sizeof(words) > 3) {
      smiley_words = words[0..<sizeof(smiley) + 1];
    } else {
      smiley_words = words;
    }
    word = query_word_type(smiley_words, "");
    if(word != "") {
      word = " "+word+"ing";
    }
  }
  switch(smiley) {
    case ":)" :
    case ":-)" :
    case ":o)" :
      emotion = " happily";
      break;
    case ":(" :
    case ":-(" :
    case ":o(" :
      emotion = " sadly";
      break;
    case "=)" :
    case "=-)" :
    case "=o)" :
      emotion = " innocently";
      break;
    case "=(" :
    case "=-(" :
    case "=o(" :
      emotion = " tearfully";
      break;
    case ";(" :
    case ";-(" :
    case ";o(" :
      emotion = " angrilly";
      break;
    case ";)" :
    case ";-)" :
    case ";o)" :
      emotion = " mischieviously";
      break;
    case ":P" :
    case ":-P" :
    case ":oP" :
    case ":p" :
    case ":-p" :
    case ":op" :
    case ":b" :
    case ":-b" :
    case ":ob" :
      emotion = " insanely";
      break;
    case "=P" :
    case "=-P" :
    case "=oP" :
    case "=p" :
    case "=-p" :
    case "=op" :
    case "=b" :
    case "=-b" :
    case "=ob" :
      emotion = " cheekily";
      break;
    case ";P" :
    case ";-P" :
    case ";oP" :
    case ";b" :
    case ";-b" :
    case ";ob" :
    case ";p" :
    case ";-p" :
    case ";op" :
      emotion = " evilly";
      break;
    default :
      emotion = "";
  }
#endif
   if ( word != " asking" ) {
      me_mess = "tell";
   } else {
      me_mess = "ask";
      word = "";
   }
   net_dead = ({ });
   foreach (thing in obs) {
      temp = emotion;
      if(thing->query_earmuffs("emoticon")) {
         emotion = "";
      }
      thing->event_person_tell( TP,
            capitalize( (string)TP->query_name() ) +
            " (creator) "+ me_mess + "s "+
            query_multiple_short(obs - ({ thing }) + ({ "you" })) + emotion +
            word + ": ", words, lang );
      if (!interactive(thing) && userp(thing)) {
         net_dead += ({ thing });
      }
   }
   if ( !silent ) {
      if ( lang != "common" ) {
         word += " in "+ lang;
      }
      if (sizeof(obs)) {
         them_mess =
               TP->convert_message(capitalize( query_multiple_short(obs)));
         emotion = temp;
         if(this_player()->query_earmuffs("emoticon")) {
           emotion = "";
         }
         TP->add_tell_history( "(creator) You " + me_mess + " "+ them_mess +
               word + emotion+ ": ", words );
      }
      if ( sizeof(net_dead)) {
          write("Warning: "+query_multiple_short(
                               map(net_dead, (: $1->query_cap_name() :)))+
                " "+ (sizeof(net_dead)>1?"are":"is")+" net dead.\n" );
      }
      emotion = temp;
      if(this_player()->query_earmuffs("emoticon")) {
        emotion = "";
      }
      busy = this_player()->query_busy();
      if (busy == 1) {
         write("Warning! You have your busy flag on.\n");
      } else if (pointerp(busy) && sizeof(obs - busy)) {
         write("Warning! You are currently set as busy with " +
                  query_multiple_short(busy) + ".\n");
      }
      my_mess("(creator) You "+me_mess+" "+them_mess+
            emotion + word+": ", words);
   }
   TP->adjust_time_left( -5 );
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:player> <string'message'>", (: cmd($4[1], $1, 0) :),
             "<string>", (: cmd($4[0], 0, 0) :) });
}

==================================================
FILE: creator/template.c
==================================================

#include <terrain_map.h>
inherit "/cmds/base";
int cmd(int size) {
   mixed* data;
   int x;
   int y;
   string line;
   data = TERRAIN_MAP_WORLD_MAP->query_map_template(size);
   line = "";
   for (y = 0; y < sizeof(data); y++) {
      for (x = 0; x < sizeof(data[y]); x++) {
         if (data[x][y]) {
            line += "*";
         } else {
            line += " ";
         }
      }
      line += "\n";
   }
   write(line);
   return 1;
}
mixed* query_patterns() {
   return ({ "<number>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/terms.c
==================================================

inherit "/cmds/base";
#include <peopler.h>
#include <creator.h>
mixed cmd(string str) {
   mixed *stuff;
   stuff = this_player()->query_property("term list");
   if (!stuff) {
      stuff = T_DEFAULT;
   }
   return PEOPLER->do_command(stuff, str);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/terrain_s.c
==================================================

inherit "/cmds/base";
#include <terrain_map.h>
int do_map() {
   string map;
   object hand;
   int* coords;
   int x;
   int y;
   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }
   coords = environment(this_player())->query_terrain_coords();
   x = coords[0];
   y = coords[1];
   map = hand->query_debug_map(x, y, 13, x, y);
   write(map);
   add_succeeded_mess("");
   return 1;
}
int do_map_terrain() {
   string map;
   object hand;
   string* map_data;
   int i;
   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }
   map_data = hand->query_area_map();
   map = "";
   for (i = sizeof(map_data) - 1; i >= 0; i--) {
      map += map_data[i] + "\n";
   }
   write("$P$Map$P$" + map);
   add_succeeded_mess("");
   return 1;
}
int do_features_distant() {
   object hand;
   string title;
   mixed tmp;
   string fluff;
   string ret;
   int* coords;
   int x;
   int y;
   int z;
   string* features;
   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }
   coords = environment(this_player())->query_co_ord();
   x = coords[0];
   y = coords[1];
   z = coords[2];
   features = TERRAIN_MAP_WORLD_MAP->query_features_at(x, y);
   if (!sizeof(features)) {
      add_failed_mess("No distant features to list.\n");
      return 0;
   }
   ret = "List of distant features:\n";
   foreach (title in features) {
      tmp = title->query_feature_desc_from(x, y, z);
      if (tmp && tmp != "") {
         if (stringp(tmp)) {
            ret += "$I$3=%^BOLD%^" + title + "%^RESET%^: " + tmp + "\n";
         } else if (pointerp(tmp)) {
            foreach (fluff in tmp) {
               ret += "$I$3=%^BOLD%^" + title + "%^RESET%^: " + fluff + "\n";
            }
         }
      }
   }
   write("$P$Distant Features$P$" + ret);
   return 1;
}
int do_features_local() {
   mapping features;
   string ret;
   object hand;
   mapping hand_features;
   string name;
   mixed stuff;
   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }
   hand_features = hand->query_features();
   features = environment(this_player())->query_features();
   if (!features) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }
   if (!sizeof(features)) {
      add_failed_mess("No local features.\n");
      return 0;
   }
   ret = "List of features:\n";
   foreach (name, stuff in hand_features) {
      ret += "$I$3=%^BOLD%^" + name + "%^RESET%^ (" +
             file_name(hand->query_feature_region(name)) + ")";
      if (features[name]) {
         ret += " " + features[hand] + "\n";
      } else {
         ret += " Not visible here.\n";
      }
   }
   write("$P$Features$P$" + ret);
   return 1;
}
int do_feature_local_map(string feature) {
   object hand;
   mapping hand_features;
   string ret;
   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }
   hand_features = hand->query_features();
   if (!hand_features[feature]) {
      add_failed_mess("There is no feature called " + feature + ".\n");
      return 0;
   }
   ret = hand->query_debug_map_feature(feature);
   write("$P$" + feature + "$P$" + ret);
   return 1;
}
int do_feature_distant_map(string feature) {
   object hand;
   string* dist_features;
   string ret;
   int* coords;
   int x;
   int y;
   int z;
   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }
   coords = environment(this_player())->query_co_ord();
   x = coords[0];
   y = coords[1];
   z = coords[2];
   dist_features = TERRAIN_MAP_WORLD_MAP->query_features_at(x, y);
   if (member_array(feature, dist_features) == -1) {
      add_failed_mess("There is no distant feature " + feature + ".\n");
      return 0;
   }
   ret = hand->query_debug_map_feature_distant(feature);
   write("$P$" + feature + "$P$" + ret);
   return 1;
}
int do_terrain_status() {
   string ret;
   object hand;
   mixed* coords;
   mapping features;
   string name;
   int x;
   int y;
   int z;
   string* dist_features;
   mapping terrs;
   hand = environment(this_player())->query_map_handler();
   if (!hand) {
      add_failed_mess("You must be in a terrain to use this command.\n");
      return 0;
   }
   ret = "%^BOLD%^" + file_name(hand) + ":%^RESET%^\n";
   ret += "Size: " + hand->query_dimensions()[0] + ", " + hand->query_dimensions()[1] + "\n";
   coords = hand->query_real_coords();
   if (coords) {
      ret += "Real: " + coords[0][0] + ", " + coords[0][1] + " -- " +
             coords[1][0] + ", " + coords[1][1] + "\n";
   }
   features = hand->query_features();
   foreach (name in keys(features)) {
      ret += name + ": " + file_name(hand->query_feature_ob(name)) + "\n";
   }
   coords = environment(this_player())->query_co_ord();
   x = coords[0];
   y = coords[1];
   z = coords[2];
   dist_features = TERRAIN_MAP_WORLD_MAP->query_features_at(x, y);
   foreach (name in dist_features) {
      ret += name + " (distant feature)\n";
   }
   hand->find_all_adjacent_terrains();
   terrs = hand->query_adjacent_terrains();
   if (terrs["-1:-1"]) {
      ret += "Southwest: " + terrs["-1:-1"] + "\n";
   }
   if (terrs["0:-1"]) {
      ret += "South: " + terrs["0:-1"] + "\n";
   }
   if (terrs["40:-1"]) {
      ret += "Southeast: " + terrs["40:-1"] + "\n";
   }
   if (terrs["40:0"]) {
      ret += "East: " + terrs["40:0"] + "\n";
   }
   if (terrs["40:40"]) {
      ret += "NorthEast: " + terrs["40:40"] + "\n";
   }
   if (terrs["0:40"]) {
      ret += "North: " + terrs["0:40"] + "\n";
   }
   if (terrs["-1:40"]) {
      ret += "Northwest: " + terrs["-1:40"] + "\n";
   }
   if (terrs["-1:0"]) {
      ret += "West: " + terrs["-1:0"] + "\n";
   }
   write("$P$Status$P$" + ret);
   return 1;
}
mixed* query_patterns() {
   return ({ "map", (: do_map() :),
             "map terrain", (: do_map_terrain :),
             "features local", (: do_features_local :),
             "features distant", (: do_features_distant :),
             "status", (: do_terrain_status :),
             "features local <string'feature to map'>",
                  (: do_feature_local_map($4[0]) :),
             "features distant <string'feature to map'>",
                  (: do_feature_distant_map($4[0]) :) });
}

==================================================
FILE: creator/testchar.c
==================================================

inherit "/cmds/base";
private mapping properties = ([ "no score" : 1,
    "no delete" : 1,
    "test character" : (: $1->query_name() :),
    "authorised player" : 1 ]);
int cmd( object player, string status ) {
    foreach( string property, mixed value in properties ) {
        if ( status == "on" ) {
            if ( functionp( value ) ) {
                player->add_property( property, evaluate( value,
                    this_player() ) );
            }
            else {
                player->add_property( property, value );
            }
        }
        else {
            player->remove_property( property );
        }
    }
    if ( status == "on" ) {
        player->save_me();
        add_succeeded_mess( ({ "$I is now a test character.\n", "" }),
            ({ player }) );
    }
    else {
        add_succeeded_mess( ({ "$I is no longer a test character.\n", "" }),
            ({ player }) );
    }
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:player> {on|off}", (: cmd($1[0], $4[1]) :) });
}

==================================================
FILE: creator/todo.c
==================================================

inherit "/cmds/base";
class todo_item {
   string type;
   int id;
   int priority;
   string description;
   int time_added;
   int time_to_finish;
}
#define TODO_PRIVATE 0x8000
#define TODO_PRIORITY_MASK (~TODO_PRIVATE)
private mapping todo_lists;
private mapping changed;
private int save_callout_id;
void create() {
   ::create();
   todo_lists = ([ ]);
   changed = ([ ]);
   seteuid("Root");
}
private class todo_item *query_todo_list(string player) {
   string data;
   class todo_item *stuff;
   class todo_item *new_stuff;
   class todo_item item;
   class todo_item new_item;
   if (todo_lists[player]) {
      return todo_lists[player];
   }
   data = read_file("/w/" + player + "/save/todo_list.o");
   if (!data) {
      return ({ });
   }
   stuff = restore_variable(data);
   if (!stuff) {
      return ({ });
   }
   if (sizeof(stuff) &&
       sizeof(stuff[0]) != 6) {
      new_stuff = ({ });
      foreach (item in stuff) {
         new_item = new(class todo_item);
         new_item->priority = item->priority;
         new_item->type = item->type;
         new_item->description = item->description;
         new_item->id = item->id;
         new_item->time_added = time();
         new_item->time_to_finish = time();
         new_stuff += ({ new_item });
      }
      stuff = new_stuff;
   }
   return stuff;
}
private void save_todo_lists() {
   int times;
   string player;
   string data;
   save_callout_id = 0;
   foreach (player, times in changed) {
      data = save_variable(todo_lists[player]);
      write_file("/w/" + player + "/save/todo_list.o", data, 1);
   }
   changed = ([ ]);
   todo_lists = ([ ]);
}
private void set_todo_list(string player, class todo_item *data) {
   todo_lists[player] = data;
   changed[player] = time();
   if (!save_callout_id) {
      save_callout_id = call_out((: save_todo_lists :), 120);
   }
}
private int query_next_id(string player) {
   class todo_item *data;
   class todo_item item;
   int id;
   data = query_todo_list(player);
   id = 1;
   foreach (item in data) {
      if (item->id >= id) {
         id = item->id + 1;
      }
   }
   return id;
}
string query_priority_name(int priority) {
   string extra;
   extra = " ";
   if (priority & TODO_PRIVATE) {
      extra = "P";
   }
   switch (priority & TODO_PRIORITY_MASK) {
      case 0 :
         return "VL" + extra;
      case 1 :
         return " L" + extra;
      case 2 :
         return " H" + extra;
      case 3 :
         return "VH" + extra;
      case 4 :
         return " U" + extra;
      default :
         return " F" + extra;
   }
}
int query_priority_number(string priority) {
   int mask;
   priority = lower_case(priority);
   mask = 0;
   if (priority[<1] == 'p') {
      mask = TODO_PRIVATE;
      priority = priority[0..<2];
   }
   switch (priority) {
      case "vl" :
         return 0 | mask;
      case "l" :
         return 1 | mask;
      case "h" :
         return 2 | mask;
      case "vh" :
         return 3 | mask;
      case "u" :
         return 4 | mask;
   }
   return -1;
}
string query_todo_line(class todo_item item, int brief, int cols) {
  if(brief) {
  return sprintf("%s%-=*s\n",
                  query_priority_name(item->priority),
                  cols - 3,
                  item->description);
  }
  return sprintf("#%3d %s (%s) Added at %s\n    %-=*s\n",
                  item->id,
                  query_priority_name(item->priority),
                  item->type,
                  ctime(item->time_added),
                  cols - 4,
                  item->description);
}
int sort_function(class todo_item bing,
                  class todo_item bing2) {
   if ((bing->priority & TODO_PRIORITY_MASK) == (bing2->priority & TODO_PRIORITY_MASK)) {
      if (bing->type == bing2->type) {
         return bing->id - bing2->id;
      }
      return strcmp(bing->type, bing2->type);
   }
   return (bing2->priority & TODO_PRIORITY_MASK) - (bing->priority & TODO_PRIORITY_MASK);
}
class todo_item *sort_todo_list(class todo_item *data) {
   return sort_array(data, (: sort_function :));
}
string query_todo_list_string(class todo_item *items, int brief) {
   class todo_item bing;
   string data;
   data = "";
   if (sizeof(items)) {
      foreach (bing in items) {
         data += query_todo_line(bing, brief, this_player()->query_cols());
      }
   }
   return data;
}
private int list_todo(int brief) {
   class todo_item* items;
   string data;
   items = query_todo_list(this_player()->query_name());
   if (sizeof(items)) {
     data = query_todo_list_string(items, brief);
   } else {
      data = "No items in your todo list.\n";
   }
   write("$P$Todo list$P$" + data);
   add_succeeded_mess("");
   return 1;
}
private int list_todo_creator(string player) {
   class todo_item* items;
   string data;
   items = query_todo_list(player);
   if (sizeof(items)) {
      items = filter(items, (: !($1->priority & TODO_PRIVATE) :));
      data = query_todo_list_string(items, 0);
   } else {
      data = "No items in " + capitalize(player) + "'s todo list.\n";
   }
   write("$P$Todo list$P$" + data);
   add_succeeded_mess("");
   return 1;
}
private int list_todo_priority(int priority) {
   class todo_item *items;
   string data;
   items = query_todo_list(this_player()->query_name());
   items = filter(items, (: ($1->priority & TODO_PRIORITY_MASK) == $(priority) :) );
   if (sizeof(items)) {
      data = query_todo_list_string(items, 0);
   } else {
      data = "No items in your todo list with the specified priority.\n";
   }
   write("$P$Todo list$P$" + data);
   add_succeeded_mess("");
   return 1;
}
private int list_todo_type(string type) {
   class todo_item *items;
   string data;
   type = lower_case(type);
   items = query_todo_list(this_player()->query_name());
   items = filter(items, (: $1->type == $(type) :) );
   if (sizeof(items)) {
      data = query_todo_list_string(items, 0);
   } else {
      data = "No items in your todo list with a type of " + type + ".\n";
   }
   write("$P$Todo list$P$" + data);
   add_succeeded_mess("");
   return 1;
}
private int add_item(string priority, string type, string description) {
   int priority_num;
   class todo_item frog;
   class todo_item *data;
   priority_num = query_priority_number(priority);
   if (priority_num == -1) {
      add_failed_mess("Unknown priority '" + priority +
                      "', only VL, L, H, VH and U allowed.\n");
      return 0;
   }
   if (strlen(type) > 10) {
      add_failed_mess("The type cannot be more than 10 characters long.\n");
      return 0;
   }
   if (file_size("/w/" + this_player()->query_name() + "/save") != -2) {
      add_failed_mess("There is no save directory in your home directory.  "
                      "This is needed for operation of this command.\n");
      return 0;
   }
   frog = new(class todo_item);
   frog->priority = priority_num;
   frog->description = description;
   frog->type = lower_case(type);
   frog->id = query_next_id(this_player()->query_name());
   frog->time_added = time();
   frog->time_to_finish = time() + (60 * 60 * 24) * 7;
   data = query_todo_list(this_player()->query_name());
   data += ({ frog });
   data = sort_todo_list(data);
   set_todo_list(this_player()->query_name(), data);
   add_succeeded_mess(({ "You added a new item #" + frog->id +
                         " to your todo list.\n", "" }));
   return 1;
}
private void confirm_complete_item(string response, int id) {
   class todo_item *data;
   class todo_item item;
   response = lower_case(response);
   if (!strlen(response) || response[0] != 'y') {
      write("Ok, canceling the completion of the item.\n");
      return ;
   }
   data = query_todo_list(this_player()->query_name());
   foreach (item in data) {
      if (item->id == id) {
         data -= ({ item });
         set_todo_list(this_player()->query_name(), data);
         write("Ok, completed list id #" + id + ".\n");
         return ;
      }
   }
   write("Unable to find the item.  Someone must have run off with it!\n");
   return ;
}
class todo_item find_todo_id(class todo_item *data, int id) {
   class todo_item item;
   foreach (item in data) {
      if (item->id == id) {
         return item;
      }
   }
   return 0;
}
private int complete_item(int id) {
   class todo_item *data;
   class todo_item item;
   data = query_todo_list(this_player()->query_name());
   item = find_todo_id(data, id);
   if (item) {
      write(query_todo_line(item, 0, this_player()->query_cols()) +
            "Are you sure you wish to complete this todo list item? ");
      input_to((: confirm_complete_item :), 0, id);
      return 1;
   }
   add_failed_mess("Unable to find an item of id #" + id + " to complete.\n");
   return 0;
}
private int change_priority(int id, string new_priority) {
   class todo_item *data;
   class todo_item item;
   int priority_num;
   priority_num = query_priority_number(new_priority);
   if (priority_num == -1) {
      add_failed_mess("Unknown priority '" + new_priority +
                      "', only VL, L, H, VH and U allowed.\n");
      return 0;
   }
   data = query_todo_list(this_player()->query_name());
   item = find_todo_id(data, id);
   if (item) {
      item->priority = priority_num;
      add_succeeded_mess(({ "Change the priority of #" + id +
                            " to " + new_priority + ".\n", "" }));
      set_todo_list(this_player()->query_name(), data);
      return 1;
   }
   add_failed_mess("Unable to find an item of id #" + id +
                   " to change the priority of.\n");
   return 0;
}
private int change_description(int id, string new_description) {
   class todo_item *data;
   class todo_item item;
   data = query_todo_list(this_player()->query_name());
   item = find_todo_id(data, id);
   if (item) {
      item->description = new_description;
      set_todo_list(this_player()->query_name(), data);
      return 1;
   }
   add_failed_mess("Unable to find an item of id #" + id +
                   " to change the description of.\n");
   return 0;
}
mixed *query_patterns() {
   return ({
             "", (: list_todo(1) :),
             "list", (: list_todo(0) :),
             "list type <string'type'>", (: list_todo_type($4[0]) :),
             "list urgent", (: list_todo_priority(4) :),
             "list very high", (: list_todo_priority(3) :),
             "list high", (: list_todo_priority(2) :),
             "list low", (: list_todo_priority(1) :),
             "list very low", (: list_todo_priority(0) :),
               "list brief", (: list_todo(1) :),
             "creator <string'name'>", (: list_todo_creator($4[0]) :),
             "add <word'priority'> <word'type'> <string'description'>",
                   (: add_item($4[0], $4[1], $4[2]) :),
             "complete <number'todo id'>", (: complete_item($4[0]) :),
             "change priority <number'todo it'> <word'priority'>",
                   (: change_priority($4[0], $4[1]) :),
             "change description <number'todo id'> <string'description'>",
                   (: change_description($4[0], $4[1]) :),
           });
}
void dest_me() {
   save_todo_lists();
   ::dest_me();
}

==================================================
FILE: creator/tra_ns.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  object *obs, ob;
  if (!str || !(sizeof(obs = WIZ_PRESENT->wiz_present(str, this_player())))) {
    write("Transport who ?\n");
    return 1;
  }
  foreach (ob in obs) {
    if (environment(ob) == environment(this_player())) {
      write(WIZ_PRESENT->desc_object(ob)+" is already here.\n");
      continue;
    }
    tell_object( ob, "You are magically transferred somewhere.\n" );
      ob->move_with_look( environment( this_player() ),
            (string)ob->query_mmsgin(), (string)ob->query_mmsgout() );
    log_file("/d/admin/log/trans", "%s transed %s to %s\n",
             this_player()->query_name(), str,
             base_name(environment(this_player())));
  }
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/trace.c
==================================================

#include <creator.h>
#include <parser.h>
inherit "/cmds/base";
#define OPTIONS ({ "off", "call", "call_other", "return", "args", "exec", "heart_beat", })
mixed cmd(string arg) {
  string *args;
  int     i, j, trace_arg;
  notify_fail( "Usage: trace <" + implode(OPTIONS, "|") + ">\n" );
  if( !arg ) return 0;
  args = explode( arg, " " );
  if( !sizeof( args ) )
    return 0;
  for( i = 0; i < sizeof( args ); i++ )
    if( (j = member_array( args[ i ], OPTIONS )) != -1 )
    {
      if( !j )
      {
        trace( 0 );
        write( "Trace off.\n" );
        return 1;
      }
      else
        trace_arg |= ({ 0, 1, 2, 4, 8, 16, 32, 64, 128 })[ j ];
    }
    else if( sscanf( args[ i ], "%d", j ) && j != 64)
      trace_arg |= j;
  trace( trace_arg | 128 );
  write( "Trace level: " + trace_arg + "\n" );
  return 1;
}

==================================================
FILE: creator/twiki.c
==================================================

inherit "/cmds/base";
#include <cmds/twiki.h>
#define DAY (24 * 60 * 60)
int cmd(int days) {
   string str;
   if (days <= 0) {
      add_failed_mess("The number of days must be higher than 0.\n");
      return 0;
   }
   if (days > 10) {
      add_failed_mess("You are limited to a maximum of ten days of "
        "twiki changes.  Consult the automated commonroom twiki post "
        "for further historical information.\n");
      return 0;
   }
   str = TWIKI_HANDLER->find_changes(time() - days * DAY);
   write(str);
   return 1;
}
int cmd_file(string fname) {
   string str;
   str = TWIKI_HANDLER->query_file(fname);
   if (!str) {
      add_failed_mess("The twiki file " + fname + " does not exist.\n");
      return 0;
   }
   write("$P$" + fname + "$P$" + str);
   return 1;
}
mixed *query_patterns() {
   return ({ "changes [since] <number'days'>", (: cmd($4[0]) :),
             "view <string'file'>", (: cmd_file($4[0]) :) });
}

==================================================
FILE: creator/ungag.c
==================================================

#include <playerinfo.h>
inherit "/cmds/base";
int cmd( object victim ) {
   if( !victim->query_property( "gagged" ) )
      return notify_fail( victim->query_short() +" is not gagged.\n" );
   victim->remove_property("gagged");
   log_file("GAG", ctime(time()) + ": " + this_player()->
         query_short() + " ungagged " + victim->query_short() + ".\n");
   tell_object( victim, this_player()->query_short() + " ungags you.\n"
                        "%^YELLOW%^Be more careful with what you say "
                        "in future.%^RESET%^\n" );
   write( "Okay, ungagged " + victim->query_short() + ".\n" );
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:player'player'>",
                (: cmd( $1[0] ) :) });
}

==================================================
FILE: creator/unsuspend.c
==================================================

#include <parser.h>
#include <access.h>
inherit "/cmds/base";
mixed cmd(string str) {
  if (this_player() != this_player(1))
    return 0;
  if (!"/secure/master"->query_lord(geteuid(previous_object())) &&
      !"/d/liaison/master"->query_deputy(geteuid(previous_object())))
    return notify_fail("You must be a lord or liaison deputy to unsuspend "
		       "someone.");
  notify_fail("We failed!\n");
  if (!"/secure/bastards"->unsuspend_person(str))
    return 0;
  write(str+" unsuspended.\n");
  return 1;
}
int help() {
  return notify_fail("Syntax: unsuspend <name>.\n");
}
mixed *query_patterns() {
  return ({ "<string>", (: cmd($4[0]) :), });
}

==================================================
FILE: creator/upg_rade.c
==================================================

mixed cmd(string str) {
  seteuid(geteuid(this_player()));
  (clone_object("/secure/login"))->do_upgrade(this_player());
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/usage.c
==================================================

mixed cmd(string arg) {
	mapping info;
  info = rusage();
  printf("Current statistics are:\n"+
				 "Memory: %d\nMajorfaults: %d\nUser time: %d\nSystem time: %d\n",
				 info["maxrss"], info["majflt"], info["minflt"],
				 info["utime"] / 1000, info["stime"] / 1000);
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/weapons.c
==================================================

#include <weapon.h>
inherit "/cmds/base";
mapping _weapons;
mapping _items;
mapping _matched;
mapping _conditions = ([ "cloth" : 800, "rubber" : 100, "hide" : 700, "leather" : 600, "wood" : 500, "bone" : 200, "silver" : 300, "copper" : 400, "stone" : 400, "bronze" : 500, "iron" : 700, "steel" : 900, "klatchian steel" : 1100, "octiron" : 1300 ]);
mapping _chances = ([ "cloth" : 20, "rubber" : 19, "hide" : 17, "leather" : 15, "wood" : 12, "bone" : 8, "silver" : 15, "copper" : 10, "stone" : 3, "bronze" : 8, "iron" : 6, "steel" : 4, "klatchian steel" : 2, "octiron" : 0 ]);
mapping _weights = ([ "cloth" : 1, "rubber" : 3, "hide" : 2, "leather" : 2, "wood" : 3, "bone" : 3, "silver" : 6, "copper" : 6, "stone" : 5, "bronze" : 5, "iron" : 5, "steel" : 5, "klatchian steel" : 5, "octiron" : 5 ]);
mapping _equivalents = ([ "chocolate" : "rubber",
                          "earthworm" : "octiron" ]);
mapping _specials = ([ "bash" : "smash",
                       "hack" : "chop",
                       "stab" : "pierce",
                       "slash" : "slice" ]);
mapping _types = ([ "strike" : "blunt",
                    "bash" : "blunt",
                    "smash" : "blunt",
                    "hack" : "sharp",
                    "chop" : "sharp",
                    "poke" : "pierce",
                    "stab" : "pierce",
                    "pierce" : "pierce",
                    "cut" : "sharp",
                    "slash" : "sharp",
                    "slice" : "sharp",
                    "spike" : "pierce",
                    "fire" : "any" ]);
nosave string *_attack_types = ({ "blunt", "sharp", "pierce", "fire" });
void create() {
  ::create();
  _weapons = "/obj/handlers/armoury"->make_list("/obj/nweapons/",
                                                ({".c", ".wep"}));
}
string warn(int i) {
  switch(i) {
  case 2:
    return "  %^BOLD%^%^RED%^!%^RESET%^ ";
  case 1:
    return "  %^ORANGE%^o%^RESET%^ ";
  default:
    return "  %^GREEN%^-%^RESET%^ ";
  }
}
int *calc_rating(object weapon) {
    int i, size;
    int ave = 0;
    int max = 0;
    int *damage;
    mixed *data;
    data = (mixed *)weapon->query_attack_data();
    if ( !( size = sizeof( data ) ) )
      return ({ 0, 0 });
    for ( i = 0; i < size; i += W_ARRAY_SIZE ) {
      if ( member_array( data[ i + W_SKILL ], _attack_types ) == -1 )
        continue;
      damage = data[ i + W_DAMAGE ];
      ave += ( data[ i + W_CHANCE ] * ( damage[ F_FIXED ] +
            ( damage[ F_NUM ] * ( 1 + damage[ F_DIE ] ) ) / 2 ) ) / 100;
      if(damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ] > max)
        max = damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ];
    }
    return ({ ave, max });
}
int calc_ave(mixed damage) {
  if(arrayp(damage))
    return damage[F_FIXED] + (damage[F_NUM] * (1 + damage[F_DIE])) / 2;
  return damage;
}
int calc_max(mixed damage) {
  if(arrayp(damage))
    return damage[F_FIXED] + (damage[F_NUM] * damage[F_DIE]);
  return damage;
}
object *filter(object who) {
  object *tmp;
  if(who->query_creator())
    return ({});
  tmp = who->query_weapons();
  switch(sizeof(tmp)) {
  case 2:
    if(tmp[0]->query_property("virtual name")) {
      if(tmp[0]->query_property("virtual name") ==
         tmp[1]->query_property("virtual name"))
        return ({ tmp[0] });
    } else {
      if(base_name(tmp[0]) == base_name(tmp[1]))
        return ({ tmp[0] });
    }
    break;
  default:
  }
  return tmp;
}
int list(string type) {
  mapping weapons;
  object wep;
  mixed *data;
  string *names, *types, str;
  int i;
  weapons = "/obj/handlers/armoury"->query_items("weapons");
  foreach(str in keys(weapons)) {
    if(str == "twoedge" || str == "kring" ||
       strsrch(weapons[str], "ranged") != -1 ||
       strsrch(weapons[str], "misc") != -1)
      continue;
    wep = "/obj/handlers/armoury"->request_item(str);
    if(!wep)
      continue;
    types = wep->query_attack_types();
    if(type && types && member_array(type, types) == -1)
      continue;
    data = wep->query_attack_data();
    names = wep->query_attack_names();
    for(i=0; i<sizeof(data); i += W_ARRAY_SIZE) {
      printf("%-30s %8s %3d %3d %3d %6s\n",
             wep->query_short(),
             names[i / W_ARRAY_SIZE],
             data[i + W_CHANCE],
             calc_ave(data[i+W_DAMAGE]),
             calc_max(data[i+W_DAMAGE]),
             data[i+W_SKILL]);
      write_file("/w/ceres/WEAPONS.csv",
                 sprintf("%s,%s,%d,%d,%d,%s\n",
                         wep->query_short(),
                         names[i / W_ARRAY_SIZE],
                         data[i + W_CHANCE],
                         calc_ave(data[i+W_DAMAGE]),
                         calc_max(data[i+W_DAMAGE]),
                         data[i+W_SKILL]));
    }
    wep->dest_me();
  }
  return 1;
}
int sort_weapons(int wep1, int wep2) {
  if(wep1 > wep2)
    return -1;
  if(wep1 < wep2)
    return 1;
  return 0;
}
int players() {
  mapping weapons;
  object wep, *weps;
  mixed *data;
  string str;
  data = map(users(), "filter");
  weapons = ([ ]);
  foreach(weps in data) {
    if(weps) {
      foreach(wep in weps) {
        if(wep->query_property("virtual name"))
          str = (clone_object(wep->query_property("virtual name"))->query_short());
        else
          str = base_name(wep)->query_short();
        if(!weapons[str])
          weapons[str] = 1;
        else
          weapons[str] += 1;
      }
    }
  }
  foreach(str in sort_array(keys(weapons),
                            (: sort_weapons($(weapons)[$1],
                                            $(weapons)[$2]) :)))
    if(str && weapons[str])
      printf("%d %s\n", weapons[str], str);
  return 1;
}
private string *map_materials(string *materials) {
  string str;
  foreach(str in materials) {
    if(_equivalents[str]) {
      materials -= ({ str });
      materials += ({ _equivalents[str] });
    }
  }
  return materials;
}
void total(object pl) {
  write("Total of " + _matched[pl] + " weapons found.\n");
}
void check(int bad_only, string type, string search, string *weapons,
           object pl) {
  string str, *materials, att, ret;
  string *tstr, *anames;
  object wep;
  int cond, dc, ave, max, weight, tmp, bad, count;
  mixed *data;
  float wf;
  count = 0;
  foreach(str in weapons) {
    bad = 0;
    if(wep)
      wep->dest_me();
    if(str == "twoedge" || str == "kring")
      continue;
    if(bad_only && (strsrch(str, "bow") != -1 ||
                    str == "satin knife boots" || str == "knife boots" ||
                    strsrch(_items[pl][str], "ranged") != -1 ||
                    strsrch(_items[pl][str], "misc") != -1))
      continue;
    if(search != "" && strsrch(str, search) == -1 &&
       strsrch(_items[pl][str], search) == -1)
      continue;
    wep = clone_object(_items[pl][str]);
    if(!wep || !wep->query_short())
      continue;
    materials = map_materials(wep->query_materials());
    cond = wep->query_max_cond();
    dc = wep->query_damage_chance();
    ret = "";
    if(search)
      ret = sprintf("\n");
    ret += sprintf("%s (%s)\n", capitalize(wep->query_short()),
                   _items[pl][str]);
    tstr = ({ });
    if(!sizeof(materials) || sizeof(materials - keys(_conditions)))
      tstr += ({ "materials" });
    else
      ret += warn(0) + sprintf("is made of %s\n",
                               query_multiple_short(materials));
    if(wep->query_length() == 1)
      tstr += ({ "length" });
    if(wep->query_width() == 1)
      tstr += ({ "width" });
    if(!wep->query_weight())
      tstr += ({ "weight" });
    if(sizeof(tstr)) {
      if(sizeof(tstr) == 1 && tstr[0] == "width") {
        ret += warn(1);
      } else {
        ret += warn(2);
        bad = 2;
      }
      ret += sprintf("has no %s\n", replace(query_multiple_short(tstr),
                                            "and", "or"));
      if(member_array("materials", tstr) != -1) {
        tell_object(pl, ret);
        continue;
      }
    }
    if(wep->query_length() != 1 && wep->query_width() != 1)
      ret += warn(0) + sprintf("is %s%d\" (%dcm) by %s%d\" (%dcm) "
                               "and weighs %.1f%s (%.1fkg)\n",
                               (wep->query_length() / 12) > 0 ?
                               (wep->query_length() / 12) + "'" : "",
                               wep->query_length() % 12,
                               to_int(wep->query_length() * 2.54),
                               (wep->query_width() / 12) > 0 ?
                               (wep->query_width() / 12) + "'" : "",
                               wep->query_width() % 12,
                               to_int(wep->query_width() * 2.54),
                               wep->query_weight() / 9.0,
                               (wep->query_weight() / 9.0) == 1.0 ? "lb" :
                               "lbs",
                               wep->query_weight() / 20.0);
    wf = 0;
    foreach(tstr in materials)
      wf += _weights[tstr];
    wf /= sizeof(materials);
    wf = (wep->query_weight() * (wep->query_weight() / 2)) /
      (wep->query_length() * wep->query_width() * wf);
    if(wf < 0.5 || wf > 3.0) {
      ret += warn(1);
      if(bad < 2)
        bad = 1;
    } else
      ret += warn(0);
    ret += sprintf("has weight factor of %.1f [0.5/1.0/3.0] "
                   "(%%^ORANGE%%^Experimental%%^RESET%%^)\n", wf);
    switch(type) {
    case "weapons":
      weight = 10 + 2 * sqrt(wep->query_weight());
      break;
    case "armours":
      weight = 5 + 2 * sqrt(wep->query_weight());
      break;
    case "clothes":
      weight = 2 * sqrt(wep->query_weight());
      break;
    }
    tmp = 0;
    foreach(tstr in materials)
      tmp += _conditions[tstr];
    tmp /= sizeof(materials);
    tmp *= weight;
    if((cond < tmp - tmp/10) || (cond > tmp + tmp/10)) {
      ret += warn(2) + sprintf("has max cond of %d should be [%d/%d/%d]\n",
                               cond, tmp - tmp/10, tmp, tmp + tmp/10);
      tell_object(pl, ret);
      continue;
    } else if(search)
      ret += warn(0) + sprintf("has max cond of %d [%d/%d/%d]\n",
                               cond, tmp - tmp/10, tmp, tmp + tmp/10);
    tmp = 0;
    foreach(tstr in materials)
      tmp += _chances[tstr];
    tmp /= sizeof(materials);
    if(dc < tmp -1 || dc > tmp+1) {
      ret += warn(2) + sprintf("has damage chance of %d should be "
                               "[%d/%d/%d]\n",
                               dc, tmp-1, tmp, tmp+1);
      bad = 2;
    } else if(search)
      ret += warn(0) + sprintf("has damage chance of %d [%d/%d/%d]\n",
                               dc, tmp-1, tmp, tmp+1);
    anames = wep->query_attack_names();
    if(!sizeof(anames)) {
      ret += warn(2) + sprintf("has no attacks.\n");
      tell_object(pl, ret);
      continue;
    }
    foreach(att in anames) {
      if(!_specials[att] && member_array(att, keys(_types)) == -1) {
        ret += warn(1) + sprintf("has non-standard %s attack\n", att);
        if(bad < 2)
          bad = 1;
      } else if(wep->query_weight() < 30 &&
         member_array(att, values(_specials)) != -1) {
        ret += warn(2) + sprintf("has %s but is too light\n", att);
        bad = 2;
      } else if(wep->query_weight() > 50 && _specials[att] &&
                member_array(_specials[att], anames) == -1) {
        ret += warn(1) + sprintf("has %s but not %s\n", att, _specials[att]);
        if(bad < 2)
          bad = 1;
      }
    }
    data = wep->query_attack_data();
    for(tmp=0; tmp < sizeof(data); tmp += W_ARRAY_SIZE) {
      if(member_array(data[tmp+W_TYPE], _attack_types) == -1) {
        ret += warn(2) + sprintf("has unknown attack type %s\n",
                                 data[tmp+W_TYPE]);
        bad = 2;
      }
      if(member_array(data[tmp+W_SKILL], values(_types)) == -1) {
        ret += warn(2) + sprintf("has unknown attack skill %s\n",
                                 data[tmp+W_SKILL]);
        bad = 2;
      }
      if(_types[anames[tmp/W_ARRAY_SIZE]] &&
         _types[anames[tmp/W_ARRAY_SIZE]] != "any" &&
         _types[anames[tmp/W_ARRAY_SIZE]] != data[tmp+W_SKILL]) {
        ret += warn(2) + sprintf("has attack %s with skill of %s\n",
                                 anames[tmp/W_ARRAY_SIZE], data[tmp+W_SKILL]);
        bad = 2;
      }
      if(data[tmp+W_FUNCTION]) {
        ret += warn(1) + sprintf("has attack function %s on %s attack\n",
                                 data[tmp+W_FUNCTION],
                                 anames[tmp/W_ARRAY_SIZE]);
        bad = 1;
      }
    }
    if(strsrch(_items[pl][str], "axe") == -1 &&
       strsrch(wep->query_long(), "axe") == -1) {
      if(member_array("chop", wep->query_attack_names()) != -1) {
        ret += warn(1) + sprintf("has chop attack but is not an axe.\n");
        if(bad < 2)
          bad = 1;
      }
      if(member_array("hack", wep->query_attack_names()) != -1) {
        ret += warn(1) + sprintf("has chop attack but is not an axe.\n");
        if(bad < 2)
          bad = 1;
      }
    } else {
      if(member_array("slash", wep->query_attack_names()) != -1) {
        ret += warn(1) + sprintf("has slash attack but is an axe.\n");
        if(bad < 2)
          bad = 1;
      }
      if(member_array("slice", wep->query_attack_names()) != -1) {
        ret += warn(1) + sprintf("has slice attack but is an axe.\n");
        if(bad < 2)
          bad = 1;
      }
    }
    if(cond) {
      data = calc_rating(wep);
      ave = data[0];
      max = data[1];
      if(ave > 140 || max > 300) {
        ret += warn(2);
        bad = 2;
      } else
        ret += warn(0);
      ret += sprintf("has damage of %d/%d max permitted is [140/300]\n",
                     ave, max);
      tmp = (100 * ave * max) / cond;
      if(tmp < 75 || tmp > 150) {
        ret += warn(1);
        if(bad < 2)
          bad = 1;
      } else
        ret += warn(0);
      ret += sprintf("has damage factor of %d [75/150] "
                     "(%%^ORANGE%%^Experimental%%^RESET%%^)\n",
                     tmp);
    }
    if(bad >= bad_only) {
      tell_object(pl, ret);
      count++;
    }
  }
  _matched[pl] += count;
  return;
}
int do_check(int bad_only, string type) {
  string *tmp, search;
  int i;
  if(!_items)
    _items = ([ ]);
  if(!_matched)
    _matched = ([ ]);
  if(type == "armours" || type == "clothes") {
    _items[this_player()] = "/obj/handlers/armoury"->query_items(type);
    search = "";
  } else if(type == "weapons") {
    _items[this_player()] = _weapons;
    search = "";
  } else {
    search = type;
    type = "weapons";
    _items[this_player()] = _weapons;
  }
  _matched[this_player()] = 0;
  tmp = keys(_items[this_player()]);
  if(!sizeof(tmp))
    return notify_fail("No items matched.\n");
  for(i=0; i<sizeof(tmp); i+= 50) {
    if(i+50 < sizeof(tmp)) {
      call_out("check", 0, bad_only, type, search, tmp[i..i+49],
               this_player());
    } else
      call_out("check", 0, bad_only, type, search, tmp[i..], this_player());
  }
  call_out("total", 1, this_player());
  return 1;
}
mixed *query_patterns() {
  return ({
              "players", (: players() :),
              "check", (: do_check(0, "") :),
              "check <string'type'>", (: do_check(0, $4[0]) :),
              "check bad", (: do_check(2, "") :),
                "check bad <string'type'>", (: do_check(2, $4[0]) :),
              "check warn", (: do_check(1, "") :),
              "check warn <string'type'>", (: do_check(1, $4[0]) :)
                });
}

==================================================
FILE: creator/whe_reis.c
==================================================

#include <creator.h>
inherit "/cmds/base";
int cmd( object *indirect_obs ) {
    object ob, e;
    int described;
    string txt;
    if ( !sizeof( indirect_obs ) ) {
        add_failed_mess( "Where is what?\n" );
        return 0;
    }
    txt = "$P$Whereis$P$";
    foreach ( ob in indirect_obs ) {
        if ( ob->query_hidden() )
            continue;
        described = 0;
        e = ob;
        while ( e = environment( e ) ) {
            if ( interactive( e ) && !reference_allowed( e, this_player() ) )
                break;
            if ( !described ) {
                txt += WIZ_PRESENT->desc_object(ob) + " is : \n";
                described = 1;
            }
            txt += "  in " + WIZ_PRESENT->desc_f_object(e) + "\n";
        }
        if ( !described )
            txt += WIZ_PRESENT->desc_object(ob) + " is in Null-space.\n";
    }
    tell_object( this_player(), txt + "\n" );
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:wiz-present>", (: cmd($1) :) });
}

==================================================
FILE: creator/which.c
==================================================

#include <command.h>
#include <soul.h>
#include <user_parser.h>
inherit "/cmds/base";
int cmd(string str) {
  int i;
  mixed *junk, *coms;
  class command cmd;
  string file, *files;
  files = ({ });
  junk = actions_defined(this_player(), 0, 12);
  for (i = 0; i < sizeof(junk); i += 2) {
    if (junk[i] == str) {
      file = function_exists((string)junk[i+1][1], (object)junk[i+1][0]);
      if (!file) {
        file = base_name((object)junk[i+1][0]);
      }
      files += ({ file });
    }
  }
  cmd = new(class command, verb : str);
  if (CMD_D->HandleStars(cmd) &&
      sizeof((coms = (mixed *)CMD_D->GetPaths(cmd->verb) &
              (mixed *)this_player()->GetSearchPath()))) {
    files += map(coms, (: $1 + "/" + $(cmd->verb) :));
  }
  coms = this_player()->query_parse_command_objects(str);
  if (sizeof(coms)) {
    files += map(coms, (: base_name($1) :));
  }
  if ((coms = SOUL_OBJECT->query_soul_command(str))) {
    files += ({ SOUL_OBJECT });
  }
  if (!sizeof(files)) {
    return notify_fail("Command " + str + " not found.\n");
  }
  printf("List of files defining '%s', in search order:\n%s", str,
         implode(files, (: $1 + "    " + $2 + "\n" :), ""));
  return 1;
}
int command_list() {
    mapping objects;
    mapping data = ([ ]);
    string *dkeys;
    string command;
    int maxlen = 8;
    int width = 0;
    string txt;
    objects = this_player()->query_p_objects();
    foreach( object ob, string *commands in objects ) {
        foreach( command in commands ) {
            if ( data[ command ] ) {
                data[ command ] += ({ ob });
            }
            else {
                data[ command ] = ({ ob });
            }
            if ( strlen( command ) > maxlen ) {
                maxlen = strlen( command );
            }
        }
    }
    width = this_player()->query_cols() - maxlen;
    dkeys = sort_array( keys( data ), 1 );
    txt = sprintf( "$P$Command list$P$%*-s %*-=s\n", maxlen, "Command",
        width, "Defined On" );
    foreach( command in dkeys ) {
        txt += sprintf( "%*-s %*-=s\n", maxlen,
            command, width,
            implode( map( data[ command ], (: file_name :) ), ", " ) );
    }
    tell_object( this_player(), txt );
    return 1;
}
mixed *query_patterns() {
  return ({
      "", (: command_list :),
      "<word'command'>", (: cmd($4[0]) :) });
}
