# Total Tokens: 25449
# Total Files Merged: 35
# Total Characters: 84916

ibe.c
==================================================

#include <player.h>
#include <clothing.h>
inherit "/cmds/base";
#define TP this_player()
int use_count = 0;
private string _zone_str;
void create() {
   string zone;
   _zone_str = "face|hair";
   foreach (zone in keys(CLOTHING_HANDLER->query_all_clothing_zones())) {
      _zone_str += "|" + zone;
   }
}
int cmd(string str) {
   string desc;
   string zone;
   desc = TP->query_desc();
   if (!str) {
      if (desc) {
         write("Description reads:\n" + TP->query_cap_name() + " " +
               desc + "\n");
      } else {
         write("No description set.\n");
      }
      if (sizeof(TP->query_zone_desc_names())) {
         foreach (zone in TP->query_zone_desc_names()) {
            write("$I$5=$C$" + zone + ": " + TP->query_zone_desc(zone) + "\n");
         }
         if (!desc) {
            write("%^YELLOW%^Warning! Your zone descriptions will not be "
                  "displayed unless you also have a main description.%^RESET%^\n");
         } else {
            write("Each zone description is a sentence, or multiple "
                  "sentences.  If you do not do this then the descriptions "
                  "will look wrong.\n");
         }
      } else {
         write("No zone descriptions setup.\n");
      }
      return 1;
   }
   else if (str == "clear") {
      write("Description cleared.\n");
      TP->set_desc(0);
      return 1;
   }
   else if (str == "edit") {
     if (desc) {
         this_player()->do_edit(sprintf("%-=*s", this_player()->query_cols(),
                                        this_player()->query_cap_name() + " " +
                                        replace(strip_colours(desc), "\n",
                                                "\n\n") + "\n"),
                                "finish_desc_edit");
     } else
       this_player()->do_edit("", "finish_desc_edit");
     ++use_count;
     return 1;
   }
   else if (strlen(str) > MAX_DESC) {
      notify_fail("Description unchanged.  Given description was too long.  "
                  "Maximum allowed length is " + MAX_DESC+ ".\n");
      return 0;
   }
   TP->set_desc(strip_colours(str));
   write("Description set.\n");
   return 1;
}
void finish_desc_edit(string str) {
   string cname;
   --use_count;
   if (!str) {
      write("Description unchanged.\n");
     return;
   }
   cname = this_player()->query_cap_name();
   if (str[0 .. strlen(cname)] == cname + " ")
      str = str[strlen(cname) + 1 .. 10000];
   str = strip_colours(str);
   str = replace(str, ({ "\n\n", "$NEW_LINE$", "\n", " " }));
   str = replace(str, "$NEW_LINE$", "\n");
   if (strlen(str) > MAX_DESC) {
      write("Description unchanged.  Given description was too long.  "
            "Maximum allowed length is " + MAX_DESC+ ".\n");
      return;
   }
   TP->set_desc(str);
   write("Description set.\n");
   return;
}
int cmd_zone(string zone, string desc) {
   this_player()->set_zone_desc(zone, desc);
   write("Set the description for the zone " + zone + " as \"" + desc + "\".\n");
   return 1;
}
int cmd_zone_clear(string zone) {
   this_player()->set_zone_desc(zone, 0);
   write("Cleared the description for the zone " + zone + ".\n");
   return 1;
}
mixed *query_patterns()  {
   return ({ "", (: cmd(0) :),
             "main <string'description'>", (: cmd($4[0]) :),
             "edit", (: cmd("edit") :),
             "clear", (: cmd("clear") :),
             "zone {" + _zone_str + "} <string'description'>",
                  (: cmd_zone($4[0], $4[1]) :),
             "zone {" + _zone_str + "} clear",
                  (: cmd_zone_clear($4[0]) :),
               });
}

==================================================
FILE: player/dnickname.c
==================================================

inherit "cmds/base";
mixed cmd(string str) {
  mapping map_nicknames;
  map_nicknames = this_player()->query_nicknames();
  if (!map_nicknames)
    map_nicknames = ([ ]);
  if (!map_nicknames[str]) {
    notify_fail("That nickname does not exist.\n");
    return 0;
  }
  map_nicknames = m_delete(map_nicknames, str);
  this_player()->set_nicknames(map_nicknames);
  write("Deleted nickname \"" + str + "\".\n");
  return 1;
}
mixed *query_patterns()  {
  return ({ "<string'nickname'>", (: cmd($4[0]) :) });
}

==================================================
FILE: player/ea_lias.c
==================================================

#include <alias.h>
inherit "/cmds/base";
mapping editing_alias;
void create() {
   editing_alias = ([ ]);
}
protected int edit_alias(string str, int new_flag) {
   string al;
   if (editing_alias[this_player()]) {
      add_failed_mess("You are already editing the '" +
                  editing_alias[this_player()] + "' alias.\n");
      return 0;
   }
   if (!this_player()->is_alias(str))  {
      if (!new_flag)  {
         add_failed_mess("No alias '"+str+"' defined.\n");
         return 0;
      }
   } else if (new_flag)  {
      add_failed_mess("You already have an alias called \"" + str + "\".");
      return 0;
   }
   editing_alias[this_player()] = str;
   if (new_flag)  al = "";
   else al = replace(ALIAS_CMD->alias_string(this_player()->
      query_player_alias(str)), ";", "\n");
   this_player()->do_edit(al, "finish_alias_edit", 0);
   return 1;
}
protected int edit_alias_copy(string alias, string new_alias) {
   string al;
   if (!this_player()->is_alias(alias)) {
      add_failed_mess("No alias '"+alias+"' defined.\n");
      return 0;
   }
   if (this_player()->is_alias(new_alias)) {
      add_failed_mess("The alias '"+new_alias+"' already exists.\n");
      return 0;
   }
   new_alias = replace_string(new_alias, "END_ALIAS", "NO YOU DONT");
   editing_alias[this_player()] = new_alias;
   al = replace(ALIAS_CMD->alias_string(this_player()->query_player_alias(alias)), ";", "\n");
   this_player()->do_edit(al, "finish_alias_edit", 0);
   return 1;
}
void finish_alias_edit(string str) {
   string alias;
   if (!editing_alias[this_player()]) {
      write("Oh dear.  We got terribly confused and forgot "
            "what you were trying to do.  Terribly sorry.\n");
      return ;
   }
   if (!str  ||  str == "") {
      write("Can't save an empty alias, sorry.\n");
      editing_alias[this_player()] = 0;
      return ;
   }
   str = replace(str, "\n", ";");
   alias = editing_alias[this_player()];
   if (!this_player()->is_alias(alias))
      printf("Added alias '%s'.\n", alias);
   else
      printf("Changed alias '%s'\n", alias);
   this_player()->add_player_alias(alias, ALIAS_CMD->compile_alias(str));
   map_delete(editing_alias, this_player());
   return ;
}
mixed *query_patterns() {
  return ({
    "<word'alias'>", (: edit_alias($4[0], 0) :),
    "new <word'alias'>", (: edit_alias($4[0], 1) :),
    "copy <word'alias'> to <word'new alias'>", (: edit_alias_copy($4[0], $4[1]) :),
      });
}
int clean_up()  {
   if (sizeof(editing_alias) == 0)
      ::clean_up();
   return 1;
}
void reset()  {
   if (sizeof(editing_alias) == 0)
      ::reset();
   return;
}

==================================================
FILE: player/ear_muffs.c
==================================================

#define TP this_player()
#include <player.h>
#include <newbiehelpers.h>
inherit "/cmds/base";
private string *_normal_types;
private string *_cre_types;
private string _player_format;
void create() {
   ::create();
   _normal_types = ({ "shout", "newbie", "cryer", "remote-soul",
         "multiple-soul", "multiple-tell",  "teach",
         "tell", "remote", "multiple-remote" });
   _cre_types = ({ "cre", "lord", "code", "liaison",
         "intermud-all", "intercre", "intergossip",
         "dwcre", "dwchat", "remote-spam", "newbiehelpers",
                     "verbose-logon"});
   _player_format = "{" + implode(_normal_types, "|") + "}";
}
int check_earmuffs() {
  string *on;
  string *types;
  on = TP->query_property(PLAYER_EARMUFF_PROP);
  if (!on) {
    on = ({ });
  }
  types = _normal_types;
  if (TP->query_creator()) {
    types += _cre_types + TP->channel_list();
  } else if (NEWBIEHELPERS_HANDLER->query_can_chat(TP)) {
    types += ({"newbiehelpers"});
  }
  if (TP->query_earmuffs()) {
    if (TP->query_earmuffs() == PLAYER_ALLOW_FRIENDS_EARMUFF) {
      printf("Your earmuffs are set to allow friends through.\n");
    } else {
      printf("Your earmuffs are on.\n");
    }
  } else {
    printf("Your earmuffs are off.\n");
  }
  if (!sizeof(on)) {
    printf("You have nothing set to be earmuffed.\n");
    write("$I$5=Earmuffable events are "+ query_multiple_short(types)+
          ".\n");
  } else {
    write("$I$5=You have "+ query_multiple_short(on)+ " earmuffed.\n");
    types -= on;
    if (sizeof(types)) {
      write("$I$5=You are not currently earmuffing "+
            query_multiple_short(types)+ " events.\n");
    }
  }
  return 1;
}
int do_earmuff_control(string str) {
  string *types;
  string *on;
  types = _normal_types;
  if (TP->query_creator()) {
    types += _cre_types + TP->channel_list();
  } else if (NEWBIEHELPERS_HANDLER->query_can_chat(TP)) {
    types += ({"newbiehelpers"});
  }
  on = TP->query_property(PLAYER_EARMUFF_PROP);
  if (!on) {
    on = ({ });
  }
  switch (str) {
    case "on" :
      if (!TP->query_earmuffs()) {
        TP->toggle_earmuffs();
      } else if (TP->query_allow_friends_earmuffs()) {
        TP->toggle_earmuffs();
        TP->toggle_earmuffs();
      }
      write("Earmuffs turned on.\n");
      break;
    case "off" :
      if (TP->query_earmuffs()) {
        TP->toggle_earmuffs();
      }
      write("Earmuffs turned off.\n");
      break;
    case "allowfriends" :
      TP->set_allow_friends_earmuffs();
      write("Earmuffs set to allow friends through.\n");
      break;
    case "all" :
      on = types;
      if (sizeof(on)) {
        write("$I$5=Your "+ query_multiple_short(on)+
              " events will now be earmuffed.\n");
      }
      break;
    case "none" :
      write("Nothing will be earmuffed any more.  (No news is good news?)\n");
      on = ({ });
      break;
  }
  TP->add_property(PLAYER_EARMUFF_PROP, on);
  return 1;
}
int do_earmuff(string str, string onOff) {
  string *types, *on, *off;
  types = _normal_types;
  if (TP->query_creator()) {
    types += _cre_types;
  }
  on = (string *)TP->query_property(PLAYER_EARMUFF_PROP);
  if (!on) {
    on = ({ });
  }
  off = ({ });
  switch (onOff) {
    case "on" :
      if (member_array(str, on) == -1) {
        on += ({ str });
      }
      write("You are now earmuffing " + str + " events.\n");
      break;
    case "off" :
      off += ({ str });
      write("You are not earmuffing " + str + " events anymore.\n");
      break;
    default :
      if (member_array(str, on) == -1) {
        on += ({ str });
        write("You are now earmuffing " + str + " events.\n");
      } else {
        off += ({ str });
        write("You are not earmuffing " + str + " events anymore.\n");
      }
      break;
  }
  on -= off;
  TP->add_property(PLAYER_EARMUFF_PROP, on);
  return 1;
}
mixed *query_patterns() {
  string cre_format;
  if (this_player()->query_creator()) {
    cre_format = "{" + implode(_normal_types +
                     _cre_types + this_player()->channel_list(), "|") + "}";
    return ({ "", (: check_earmuffs() :),
                "{on|off|all|none|allowfriends}",
                (: do_earmuff_control($4[0]) :),
                cre_format, (: do_earmuff($4[0], "") :),
                cre_format + " {on|off}", (: do_earmuff($4[0], $4[1]) :) });
  } else {
    if( NEWBIEHELPERS_HANDLER->query_can_chat(this_player()) ) {
      _player_format = "{" +
                       implode(_normal_types + ({"newbiehelpers"}), "|") + "}";
    }
    return ({ "", (: check_earmuffs() :),
                "{on|off|all|none|allowfriends}",
                (: do_earmuff_control($4[0]) :),
                _player_format, (: do_earmuff($4[0], "") :) ,
                _player_format + " {on|off}",
                (: do_earmuff($4[0], $4[1]) :) });
  }
}

==================================================
FILE: player/email.c
==================================================

#include <player.h>
inherit "/cmds/base";
#define TP this_player()
int cmd(string str) {
   string email;
  email = TP->query_email();
   if (!str) {
      write("Your current email address is "+email+"\n");
      write("To clear use \"email CLEAR\"\n");
      write("For the email address to be only visible by lords prepend a :\n");
      write("eg email :frog@frogcentral.froguni.swamp\n");
      return 1;
   }
   if (str == "CLEAR")
      email = "";
   else
      email = str;
   if (email != "")
      write("Email address set to "+str+".\n");
   else
      write("Email address is null.\n");
   TP->set_email(email);
   return 1;
}

==================================================
FILE: player/ex_amine.c
==================================================

inherit "/cmds/living/l_ook";
mixed *query_patterns() {
    return ({ "<string'direction'>", (: cmd_string($4[0]) :),
              "<indirect:object>", (: cmd_object($1, $4[0]) :) });
}

==================================================
FILE: player/finger.c
==================================================

inherit "/cmds/base";
#include <clubs.h>
mixed cmd() {
  string ret;
  object ob, *obs;
  string type;
  string str;
    obs = users();
    obs = sort_array(obs, (: strcmp($1->query_cap_name(),
    $2->query_cap_name()) :));
    str = sprintf("%-12.12s    %-20.20s %-20.20s %-20.20s\n",
                  "Name", "Real name", "Where", "Birthday");
    foreach (ob in obs) {
      string euid;
      type = (ob->query_earmuffs() ? "e" : " ");
      euid = geteuid(ob);
      type += ob->query_object_type();
      str += sprintf("%-12.12s %2.2s %-20.20s %-20.20s %-20.20s\n",
      (ob->query_invis()?"("+ob->query_cap_name()+")":(string)ob->query_cap_name()),
                    type,
                    ((ret = (string)ob->query_real_name())?ret:"-"),
                    ((ret = (string)ob->query_where())?ret:"-"),
                    ((ret = (string)ob->query_birthday())?ret:"-"));
    }
    write("$P$Finger$P$" + str);
    return 1;
}
int finger_player(string str) {
  string ret;
  string mud;
  if (str) {
    str = lower_case(str);
    str = (string)this_player()->expand_nickname(str);
  }
  ret = (string)"/secure/finger"->finger_info(str);
  if (ret) {
    write("$P$finger: " + str + "$P$" + ret);
    return 1;
  } else if (this_player()->query_creator() &&
             sscanf(str, "%s@%s", mud, mud) == 2) {
    "/net/daemon/out_finger"->do_finger(str);
    return 1;
  } else {
    add_failed_mess("No one going by the name of " + str + " has ever visited "
      "" + mud_name() + ".\n");
    return 0;
  }
}
mixed *query_patterns() {
   return ({ "", (: cmd() :),
             "<string'name|domain|club'>", (: finger_player($4[0]) :) });
}

==================================================
FILE: player/friend_s.c
==================================================

inherit "/cmds/base";
#include <player.h>
#include <player_handler.h>
int cmd_display(string person, string pattern) {
   string* friends;
   string ret;
   if (person == "online") {
      friends = filter(this_player()->query_friends(), (: find_player($1) :));
   } else if (person != "") {
      person = this_player()->expand_nickname(person);
      if (!this_player()->is_friend(person)) {
         add_failed_mess(person + " is not your friend.\n");
         return 0;
      }
      friends = ({ person });
   } else {
      friends = this_player()->query_friends();
   }
   if (pattern) {
      if (regexp(pattern,
           "[\\[\\]\\(\\)\\*\\?\\+][\\[\\]\\(\\)\\*\\?\\+]+") ) {
         add_failed_mess("Bad pattern to alias.\n");
         return 0;
      }
      if (pattern[0] == '*' || pattern[0] == '+') {
         add_failed_mess("Cannot start a regular expression with a '*' or '+', "
                         "try: '.*' or '.+'.\n");
         return 0;
      }
      if (catch(regexp("test str", pattern))) {
         add_failed_mess("Pattern has an error in it, mismatched brackets?\n");
         return 0;
      }
      foreach (person in friends) {
         if (!regexp(this_player()->query_friend_tag(person), pattern)) {
            friends -= ({ person });
         }
      }
      if (!sizeof(friends)) {
         add_failed_mess("The tag '" + pattern + "' did not exist "
                         "in your friends list.\n");
         return 0;
      }
   }
   if (!sizeof(friends)) {
     if(person == "online") {
       add_failed_mess("You do not have any friends online.\n");
     } else {
       add_failed_mess("You do not have any friends.\n");
     }
     return 0;
   }
   ret = "";
   foreach (person in sort_array(friends, 0)) {
      ret += "$I$5=" + capitalize(person) + ": " +
             this_player()->query_friend_tag(person) + "%^RESET%^\n";
   }
   write("$P$Friends$P$" + ret);
   return 1;
}
int cmd_add(string person, string tag) {
   person = lower_case(person);
   person = this_player()->expand_nickname(person);
   if(person == this_player()->query_name()) {
     add_failed_mess("Are you really that lonely?\n");
     return 0;
   }
   if (!PLAYER_HANDLER->test_user(person)) {
      add_failed_mess(person + " does not exist.\n");
      return 0;
   }
   if (strlen(tag) > PLAYER_MAX_FRIEND_TAG_LEN) {
      add_failed_mess("Your tag for " + person + " is too long, the "
                      "maximum is " + PLAYER_MAX_FRIEND_TAG_LEN + ".\n");
      return 0;
   }
   if (!this_player()->is_friend(person)) {
      this_player()->add_friend(person, tag);
      add_succeeded_mess(({ "You add " + person + " with a tag of: " +
                            tag + "%^RESET%^.\n",
                            "" }));
   } else {
      this_player()->add_friend(person, tag);
      add_succeeded_mess(({ "You change " + person + "'s tag to: " +
                            tag + "%^RESET%^.\n",
                            "" }));
   }
   return 1;
}
int cmd_remove(string person) {
   person = lower_case(person);
   person = this_player()->expand_nickname(person);
   if (!this_player()->is_friend(person)) {
      add_failed_mess("Sorry, " + person + " is not your friend to remove.\n");
      return 0;
   }
   this_player()->remove_friend(person);
   add_succeeded_mess(({ "You remove " + person + " from your friends list.\n",
                         "" }));
   return 1;
}
int cmd_clear() {
   write("This will clear all of your friends.  Are you sure you want to do "
         "this? ");
   input_to("clear_check");
   add_succeeded_mess("");
   return 1;
}
void clear_check(string str) {
   string friend;
   if (!strlen(str) || str[0] != 'y') {
      write("Ok, aborting.\n");
      return ;
   }
   foreach (friend in this_player()->query_friends()) {
      this_player()->remove_friend(friend);
   }
   write("Friend list cleared.\n");
}
mixed *query_patterns() {
   return ({ "<word'friend'>",
                (: cmd_display($4[0], 0) :),
             "",
                (: cmd_display("", 0) :),
             "list <string>",
                (: cmd_display("", $4[0]) :),
             "online",
                (: cmd_display("online", 0) :),
             "add <word'friend'>",
                (: cmd_add($4[0], "needs no introduction") :),
             "add <word'friend'> <string'tag'>",
                (: cmd_add($4[0], $4[1]) :),
             "remove <word'friend'>",
                (: cmd_remove($4[0]) :),
             "clear",
                (: cmd_clear() :),
             });
}

==================================================
FILE: player/gather.c
==================================================

#include <move_failures.h>
inherit "/cmds/base";
#define TP this_player()
int cmd( string str ) {
  object *items, *moved = ({ }), *left = ({ });
  int i;
  if( !stringp(str) || (str == "" )) {
    add_failed_mess("Syntax: gather <plant>\n");
    return 0;
  }
  items = "/obj/handlers/gathering"->gather_item(str, TP);
  if (!sizeof(items)) {
    if (str[<1] != 's') {
       str = pluralize(str);
    }
    add_failed_mess( "You couldn't find any " + str + ".\n");
    return 0;
  }
  for (i = 0; i < sizeof(items); i++) {
    if (items[i]->move(TP) == MOVE_OK) {
    moved += ({ items[i] });
  }  else
    if(items[i]->move(environment(TP)) == MOVE_OK) {
      left += ({ items[i] });
    } else {
      items[i]->move("/room/rubbish");
    }
  }
  if (sizeof(moved)) {
#ifdef NO_DECAY
    moved->set_decay_speed(0);
#endif
    add_succeeded_mess( "$N gather$s $I.\n", moved );
    event( environment( this_player() ), "gather", this_player(), str,
        moved );
  }
  left -= ({ this_player() });
  if (sizeof(left))
    write("You found but couldn't get " + query_multiple_short(left) + ".\n");
  return 1;
}
mixed query_patterns() {
  return ({ "<string>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: player/gchat.c
==================================================

#include <language.h>
#include <player.h>
#include <drinks.h>
inherit "cmds/base";
inherit "cmds/speech";
#define TEAM_HANDLER "/obj/handlers/team"
#define TP this_player()
mixed cmd(string arg) {
  string word, cur_lang, group;
  object ob, *members, *earmuffed;
  return notify_fail( "This command is no longer used.  Please "
   "use \"group say\" instead.\n" );
  if( TP->check_earmuffs( "gchat" ) )
     return notify_fail( "You have gchat ear muffed.\n" );
  group = TEAM_HANDLER->query_group(this_player());
  if(!group)
    return notify_fail("You are not a member of any group.\n");
  if(!arg)
    return notify_fail("Syntax: gchat <message>\n");
  cur_lang = TP->query_current_language();
  if (!LANGUAGE_HAND->query_language_spoken(cur_lang))
    return notify_fail(capitalize(cur_lang)+" is not a spoken language.\n");
  if (!LANGUAGE_HAND->query_language_distance(cur_lang))
    return notify_fail(capitalize(cur_lang)+" is not able to spoken at a "
                       "distance.\n");
  word = query_word_type(arg, "");
  if (word != "")
    word = word + "ing";
  if (TP->query_volume(D_ALCOHOL))
    arg = drunk_speech(arg);
  if(function_exists("mangle_tell", environment(TP)))
    arg = environment(TP)->mangle_tell(arg, ob, 0);
  members = TEAM_HANDLER->query_members(group);
  members -= ({ this_player() });
  if ( !members ) {
    TEAM_HANDLER->leave_group( group, this_player() );
    TEAM_HANDLER->end_group( group );
    write( "Somehow your group has no members.  "
        "Your group has been ended.  "
        "I hope this is okay.\n" );
    return 1;
  }
  earmuffed = ({ });
  foreach( ob in members ) {
    if( ob->check_earmuffs( "gchat" ) ) {
      earmuffed += ({ ob });
      members -= ({ ob });
    }
  }
  if( sizeof( earmuffed ) ) {
    write( capitalize( query_multiple_short( earmuffed ) ) +
        ( sizeof( earmuffed ) > 1 ? " have":" has" )+
        " gchat ear muffed.\n");
  }
  if( !sizeof( members ) ) {
    return notify_fail( "It seems you are the only one listening to "
          "this channel.\n" );
  } else if(word != "asking") {
    if( word != "" )
      word = " "+ word;
    foreach(ob in members) {
      if ( ob && interactive( ob ) )
        ob->event_person_tell(TP, capitalize((string)TP->query_name())+
                              " tells "+ group + word +": ", arg,
                              cur_lang );
    }
    if(cur_lang != "common")
      word += " in "+cur_lang;
    my_mess("You tell "+ group + word +": ", arg);
    TP->add_tell_history( "You tell "+ group + word + ": ", arg );
  } else {
    foreach(ob in members) {
      if ( ob && interactive( ob ) )
        ob->event_person_tell(TP, capitalize((string)TP->query_name())+
                              " asks "+group+": ", arg, cur_lang );
    }
    if(cur_lang != "common")
      word = " in "+ cur_lang;
    else word = "";
    my_mess( "You ask "+ group + word +": ", arg);
    TP->add_tell_history( "You ask "+ group + word + ": ", arg );
  }
  TP->adjust_time_left(-5);
  return 1;
}

==================================================
FILE: player/godmother.c
==================================================

#include <panic.h>
#include <move_failures.h>
inherit "/cmds/base";
void create() {
  seteuid(getuid());
}
int cmd( ) {
  mixed why_not;
  string destination;
  int ret;
  string str;
  if (!environment(this_player())) {
      destination = this_player()->query_last_pos();
      str = catch(ret = this_player()->move_with_look(destination,
                             "$N appears out of nowhere.",
                             "$N disappears with a pop."));
      if (str || ret != MOVE_OK) {
         destination = this_player()->query_start_pos();
         str = catch(ret = this_player()->move_with_look(destination,
                                "$N appears out of nowhere.",
                                "$N disappears with a pop."));
      }
      if (str || ret != MOVE_OK) {
         destination = this_player()->query_nationality()->query_default_start_location();
         str = catch(ret = this_player()->move_with_look(destination,
                                "$N appears out of nowhere.",
                                "$N disappears with a pop."));
      }
      if (str || ret != MOVE_OK) {
         add_failed_mess("Unable to move you out of limbo.  Try again "
                         "soon.\n");
         return 0;
      }
     add_succeeded_mess("You escape from limbo.\n");
     return 1;
  }
  if (environment() ||
      (why_not = environment(this_player())->query_property("no godmother"))) {
          if ( why_not && stringp( why_not ) ) {
              add_failed_mess( why_not );
          } else {
              add_failed_mess("You cannot summon the godmother here.\n");
          }
          return 0;
   }
   why_not = this_player()->query_property( "no godmother" );
   if( why_not )
   {
      if( stringp( why_not ) && sizeof( why_not ) ) {
         add_failed_mess( why_not );
      } else {
         add_failed_mess( "You cannot summon a godmother at this moment.\n" );
      }
      return 0;
   }
   if (PANIC_HANDLER->do_startup(previous_object())) {
      this_player()->add_succeeded_mess(this_object(),
                      ({ "",
                         "$N stares into space and looks pensive.\n" }),
                      ({ }) );
   } else {
      return 0;
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "help", (: cmd() :) });
}

==================================================
FILE: player/group.c
==================================================

#include <group_handler.h>
#include <function.h>
#include <player.h>
#undef IN_TESTING
#undef IN_STRICT_TESTING
mixed *_patterns;
mapping _sub_commands;
class sub_command {
   string file_name;
   mixed *data;
}
#if defined( IN_TESTING ) || defined( IN_STRICT_TESTING )
int allowed_to_use( object user );
#endif
void rehash_group_sub_commands();
void make_patterns_array();
mixed *query_patterns();
int group_command_control( string verb, mixed *indirect_obs,
   string dir_match, string indir_match, mixed *args, string pattern );
int do_help( string on_what );
void create() {
   rehash_group_sub_commands();
   make_patterns_array();
}
void rehash_group_sub_commands() {
   mixed *files;
   object cmd_object;
   string dir, verb, file, pattern;
   _sub_commands = ([ ]);
   dir = GROUP_SUB_CMDS_DIR;
   dir += GROUP_SUB_CMDS_FILE_WILDCARD;
   files = get_dir( dir );
   if( !sizeof( files ) ) {
      return;
   }
   foreach( file in files ) {
      sscanf( file, "%s.%*s", file );
      cmd_object = load_object( ( GROUP_SUB_CMDS_DIR + file ) );
      if( !cmd_object ) {
         continue;
      }
      if( !cmd_object->query_group_sub_command_amount() ) {
         continue;
      }
      foreach( verb in cmd_object->query_group_sub_command_verbs() ) {
         if( !_sub_commands[ verb ] ) {
            _sub_commands += ([ verb : new( class sub_command ) ]);
         }
         _sub_commands[ verb ]->data = ( mixed * )({ });
         _sub_commands[ verb ]->file_name = ( string )file_name( cmd_object );
         foreach( pattern in
            cmd_object->query_group_sub_command_patterns( verb ) ) {
            _sub_commands[ verb ]->data +=
               ({
               pattern,
               cmd_object->query_group_sub_command_function( verb, pattern )
               });
         }
      }
   }
}
int group_command_control( string verb, mixed *indirect_obs,
   string dir_match, string indir_match, mixed *args, string pattern ) {
   int count, size;
   string cmd_pattern, mangled_pattern, group;
   function cmd_fun;
   object cmd_object;
   class sub_command info;
#if defined( IN_TESTING ) || defined( IN_STRICT_TESTING )
   if( !allowed_to_use( this_player() ) ) {
      return 0;
   }
#endif
   info = _sub_commands[ verb ];
   if( !info ) {
      printf( "ERROR: Command information for \"" + verb + "\""
         " not found.\n" );
      return 0;
   }
   if( pattern != verb ) {
      sscanf( pattern, verb + " %s", mangled_pattern );
   }
   else {
      mangled_pattern = "";
   }
   size = sizeof( info->data );
   for( count = 0; count < size; count += 2 ) {
      if( mangled_pattern == info->data[ count ] ) {
         cmd_pattern = info->data[ count ];
         cmd_fun     = info->data[ count + 1 ];
         break;
      }
   }
   if( !cmd_pattern || !cmd_fun ) {
      printf( "ERROR: Correct version of \"" + verb + "\" not found.\n" );
      tell_creator( this_player(), "DEBUG: Verb: %s, pattern: %s\n",
         verb, pattern );
      return 0;
   }
   if( !cmd_object = load_object( info->file_name ) ) {
      printf( "ERROR: Cannot load command \"" + verb + "\"!\n" );
      tell_creator( this_player(), "DEBUG: File name: %s\n", info->file_name );
      return 0;
   }
   if( functionp( cmd_fun ) & FP_OWNER_DESTED ) {
      info->data[ count + 1 ] = cmd_fun =
         cmd_object->query_group_sub_command_function( verb, cmd_pattern );
   }
   if( !cmd_fun || !functionp( cmd_fun ) ) {
      printf( "ERROR: Could not find command function for verb " +
         "\"" + verb + "\".\n" );
      return 0;
   }
   group = this_player()->query_group();
   if( cmd_object->query_membership_required( verb, cmd_pattern ) > 0 ) {
      if( !group ) {
         return notify_fail( "You must be a member of a group in order "
            "to use this command.\n" );
      }
   }
   if( cmd_object->query_leadership_required( verb, cmd_pattern ) > 0 ) {
      if( GROUP->leader_of( group ) != this_player() ) {
         return notify_fail( "Only the leader of a group can use this "
            "command.\n" );
      }
   }
   return evaluate( cmd_fun, indirect_obs, dir_match, indir_match,
      args, pattern, group );
}
int do_help( string on_what ) {
   int top_left;
   string help, message;
   object command;
   on_what = lower_case( on_what );
#if defined( IN_TESTING ) || defined( IN_STRICT_TESTING )
   if( !allowed_to_use( this_player() ) ) {
      return 0;
   }
#endif
   if( on_what == "help" ) {
      return notify_fail( "To get help on a command, use \"group help <sub-"
         "command>\".  That is, if you wanted to get help on the command "
         "\"group create <name>\", you would type \"group help create\".\n" );
   }
   if( !_sub_commands[ on_what ] ) {
      return notify_fail( "There is no sub-command called \"" + on_what +
         "\".\n" );
   }
   command = load_object( _sub_commands[ on_what ]->file_name );
   if( !command ) {
      tell_creator( this_player(), "Alleged file name: %s\n",
         _sub_commands[ on_what ]->file_name );
      return notify_fail( "ERROR: Cannot find or load sub-command "
         "\"" + on_what + "\".\n" );
   }
   help = command->query_help_string_for( on_what );
   if( !help ) {
      return notify_fail( "No help found for sub-command \"" + on_what +
         "\".\n" );
   }
   top_left = this_player()->query_cols();
   message = sprintf(
      "\n%' '|*s\n"
      "%' '-=*s\n",
      top_left, "Help on sub-command \"" + on_what + "\":\n",
      top_left, help );
   this_player()->more_string( message );
   return 1;
}
void make_patterns_array() {
   int count, size;
   string verb, pattern;
   class sub_command command;
   _patterns = ({ });
   _patterns += ({
      "help <word'sub-command'>", (: do_help( $4[ 0 ] ) :) });
   foreach( verb, command in _sub_commands ) {
      size = sizeof( command->data );
      for( count = 0; count < size; count += 2 ) {
         if( sizeof( command->data[ count ] ) ) {
            pattern = verb + " " + command->data[ count  ];
         }
         else {
            pattern = verb;
         }
         _patterns += ({
            pattern, (: group_command_control( $( verb ), $1, $2, $3, $4,
               $5 ) :) });
      }
   }
}
mixed *query_patterns() {
   return _patterns;
}
#if defined( IN_TESTING ) || defined( IN_STRICT_TESTING )
int allowed_to_use( object user ) {
#endif
#ifdef IN_STICT_TESTING
   if( !user->query_creator() ) {
      tell_object( user, "You are not allowed to use this feature at this "
         "time.\n" );
      return 0;
   }
#endif
#ifdef IN_TESTING
   if( !PLAYTESTER_HAND->query_tester( user ) ) {
      tell_object( user, "You are not allowed to use this feature at this "
         "time.\n" );
      return 0;
   }
#endif
#if defined( IN_TESTING ) || defined( IN_STRICT_TESTING )
   return 1;
}
#endif
mapping dump_info() { return _sub_commands; }
mixed *dump_patterns() { return _patterns; }

==================================================
FILE: player/groups.c
==================================================

#include <group_handler.h>
inherit "/cmds/base";
mixed cmd(string str, string pattern) {
   return GROUP_CMD->group_command_control( "list", "", "", "",
                                            ({ str }), pattern );
}
mixed *query_patterns() {
   return ({ "", (: cmd("", "list") :),
             "[with] <string'player'>",
             (: cmd($4[0], "list [with] <string'player'>") :) });
}

==================================================
FILE: player/gstat_us.c
==================================================

inherit "cmds/base";
#define TEAM_HANDLER "/obj/handlers/team"
mixed cmd(string str) {
  string group;
  string locked;
  object member;
  return notify_fail( "This command is no longer used.  Please use the "
   "\"group\" command from now on.  Also have a read of \"help "
   "grouping\".\n" );
  group = TEAM_HANDLER->query_group(this_player());
  if(!group || !TEAM_HANDLER->query_members(group))
    return notify_fail("You are not a member of any group.\n");
  if(TEAM_HANDLER->query_locked(group))
    locked = "(locked) ";
  else
    locked = "";
  printf("Members of %s%s:\n", locked, group);
  printf("%-12s %|20s   Idle\n", "Name", "Health");
  foreach(member in TEAM_HANDLER->query_members(group)) {
    if(member && interactive(member))
      printf("%-12s %-20s %3d:%02d\n", member->short(),
       member->health_string(), (query_idle(member)/60),
       (query_idle(member)%60));
    else if(member)
      printf("%s\n", member->short());
  }
  return 1;
}

==================================================
FILE: player/haunt.c
==================================================

#define HAUNT_EARMUFF "remote-soul"
inherit "/cmds/base";
string ooo() {
    return implode( allocate( 3 + random( 15 ),
        (: ({ "O", "o" })[ random( 2 ) ] :) ), "" );
}
int haunt_player( object *victims ) {
    victims = filter( victims, (: !sizeof( $1->query_ignoring( ({ this_player() }) ) ) :) );
    victims = filter( victims, (: !$1->check_earmuffs( HAUNT_EARMUFF,
        $(this_player()) ) :) );
    victims = filter( victims,
        (: interactive( $1 ) || ( $1->query_property( "npc" ) &&
        environment( $1 ) == environment( this_player() ) ) :) );
    if ( !this_player()->query_property("dead") ) {
        add_failed_mess( "You are nowhere near wispy enough to "
          "haunt people.  You could probably scare a table or "
          "chair, though.\n" );
        return -1;
    }
    if ( !sizeof( victims ) ) {
        return 0;
    }
    add_succeeded_mess( "$N wave$s $p arms about anxiously and say$s: \""
   + ooo() + "\" at $I.\n", victims );
    return 1;
}
int cmd() {
    if ( !this_player()->query_property("dead") ) {
        add_failed_mess( "You are nowhere near wispy enough to "
          "haunt people.  You could probably scare a table or "
          "chair, though.\n" );
        return -1;
    }
    add_succeeded_mess( "$N wave$s $p arms about anxiously and intone$s: \"" +
        ooo() + "\".\n" );
    return 1;
}
mixed *query_patterns() {
    return ({ "", (: cmd() :),
      "<indirect:any-living>", (: haunt_player($1) :)  });
}

==================================================
FILE: player/health.c
==================================================

inherit "cmds/base";
string *level_colors = ({ "", "%^BOLD%^%^RED%^", "%^RED%^", "%^YELLOW%^",
                          "%^CYAN%^", "" });
mixed cmd(object *who, int wounded) {
   object person;
   string health;
   int level;
   int found;
   if(this_player()->check_dark((int)environment(this_player())->
                                 query_light())) {
      add_failed_mess("You cannot see well enough to examine someone's "
                      "health.\n");
      return 0;
   }
   foreach(person in who) {
      health = person->health_string(1, ref level);
      if (this_player() == person) {
         health = replace(health, ({ "is ", "are ", "appears ", "appear " }));
      }
      if (health) {
         if (!wounded || level != 5) {
            write(level_colors[level] + "$C$" + person->one_short(1) + " " +
                  level_colors[level] + health + ".\n%^RESET%^");
            found++;
         }
      } else {
         write(person->one_short(1) + " is so unhealthy they have forgotten "
               "how healthy they are.\n");
      }
      if (person != this_player())
         tell_object(person, this_player()->the_short(1) + " appears to be "
                  "checking out all your wounds.\n");
   }
   if (wounded && !found) {
      add_failed_mess("Unable to find any wounded people.\n");
      return 0;
   }
   say(this_player()->one_short(1) + " studies " +
       query_multiple_short(who) + ".\n");
   return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:living>", (: cmd($1, 0) :),
            "wounded <indirect:living>", (: cmd($1, 1) :) });
}

==================================================
FILE: player/help.c
==================================================

inherit "/cmds/base";
#include <nroff.h>
#include <soul.h>
#include <log.h>
#include <autodoc.h>
#include <login_handler.h>
#include <player_handler.h>
#include <command.h>
#define SYNONYMS "/doc/SYNONYMS"
#define MATCH_THRESHOLD 55
void do_help(mixed *stuff);
private void list_help(string title, string dir);
private mixed *help_list(string name);
int command_cmd(string name);
int here_cmd();
int object_cmd(object ob);
int spell_cmd(string name, int spell);
int file_help(string name);
void rehash_dirs();
mixed *query_help_on(string name, int creator, int, int);
mixed *create_help_files(string *names, string nroff_dir);
private mapping read_directories(string *directories, int recurse);
private mapping read_synonyms();
private string letter_name(int letter, mixed *things);
private string start_letter( mixed *things );
private string end_letter( mixed *things );
private int query_number_from_string(string name, mixed *things );
private nosave mapping _help_files_player;
private nosave mapping _help_files_creator;
private nosave mapping _help_files_playtester;
private nosave mapping _help_files_lord;
private nosave mapping _synonyms;
private nosave string *_player_dirs;
private nosave string *_creator_dirs;
private nosave string *_lord_dirs;
private nosave string *_playtester_dirs;
void create() {
   ::create();
   _player_dirs = ({ "/doc/helpdir/",
                    "/doc/concepts/",
                    "/doc/known_command/",
                    "/doc/room/",
                    "/doc/spells/",
                    "/doc/object/" });
   _creator_dirs = ({"/doc/creator/",
                    "/doc/driver/",
                    "/doc/policy/",
                    "/doc/new/" });
   _playtester_dirs = ({ "/doc/playtesters/" });
   _lord_dirs = ({"/doc/lord/"});
   unguarded((: rehash_dirs() :));
}
int *find_match_in_array( string entry, string *items )  {
   int i;
   int j;
   int elength;
   int ilength;
   int this_match;
   int best_match;
   int best_try;
   elength = strlen( entry );
   best_match = this_match = -1;
   for ( i = sizeof( items ) - 1; i >= 0; i--, this_match = 0 )  {
      ilength = strlen( items[ i ] );
      for ( j = 0; j < elength  &&  j < ilength; j++ )
        if ( entry[ j ] == items[ i ][ j ] ||
             entry[ j ] == items[ i ][ j - 1 + ( j == 0 ) ]  ||
             entry[ j ] == items[ i ][ j + 1 - ( j + 1 == ilength ) ] )
          ++this_match;
      this_match = 100 * this_match / ( j == elength ? ilength : elength );
      if ( this_match > best_match )  {
        best_match = this_match;
        best_try = i;
      }
   }
   return ({ best_try, best_match });
}
int cmd(string name) {
  class command cmd;
   mixed *list;
   string str;
   string suggestion;
   int i;
   int *matches;
   list = help_list(name);
   if (sizeof(list) == 0 &&
       mapp(_synonyms) &&
       _synonyms[name]) {
      list = help_list(_synonyms[name]);
   }
   if (sizeof(list) == 0) {
      if (PLAYER_HANDLER->test_user(name)) {
         add_failed_mess("That is a player, silly.\n");
         return 0;
      }
      list = keys(_help_files_player) + ({ "command_list", "concepts"});
      matches = find_match_in_array(name, list);
      if (matches[1] > MATCH_THRESHOLD) {
         suggestion = list[matches[0]];
      } else {
         list = keys(_synonyms);
         matches = find_match_in_array(name, list);
         if(matches[1] > MATCH_THRESHOLD) {
            suggestion = _synonyms[list[matches[0]]];
         }
      }
      if (!this_player()->query_creator()) {
         log_file("MISSING_HELP", "%s %s looked for help on %s, "
                  "recommended %s\n",
                  ctime(time()), this_player()->query_name(),
                  name, suggestion);
      }
      str = "Could not find any help on '" + name + "'.  ";
      if (!suggestion && this_player()->query_known_command("newbie"))
        str += "Many useful commands are explained in 'help essentials'.  ";
      else if(suggestion)
        str += "Perhaps you are looking for 'help " +suggestion + "'?  ";
      cmd = new(class command, verb : name);
      if((CMD_D->IsGRCommand(name) &&
          this_player()->query_known_command(name)) ||
         (CMD_D->HandleStars(cmd) &&
          sizeof(((mixed *)CMD_D->GetPaths(cmd->verb) &
                  (mixed *)this_player()->GetSearchPath()))) ||
         sizeof(this_player()->query_parse_command_objects(name)))
        str += "The syntax for the command '" + name + "' can be found by "
          "entering 'syntax " + name + "'.  ";
      if (environment(this_player()) &&
          environment(this_player())->help_function())
         str += "Type 'help here' for help on how to use this room.";
      return notify_fail(str + "\n");
   }
   if (sizeof(list) == 1) {
      do_help(list[0]);
      return 1;
   }
   str = "";
   for (i = 0; i < sizeof(list); i++) {
      str += sprintf("%s) %s\n", letter_name(i, list), list[i][0]);
   }
   printf("Discworld help found multiple matches, please choose one of:\n"
          "%-*#s\nChoice: ", this_player()->query_cols(), str);
   input_to("help_input", 0, list);
   return 1;
}
void help_input(string str, mixed *list) {
   int num;
   str = lower_case(str);
   if (str == "quit" || str == "**" || str == "." || str == "") {
      write("OK, exiting help.\n");
      return ;
   }
   if ( ( num = query_number_from_string( str, list ) ) == -1 ) {
       printf("Incorrect choice, must be between %s and %s.\nChoice: ",
        start_letter( list ), end_letter( list ) );
      input_to("help_input", 0, list);
      return ;
   }
   do_help(list[num]);
}
void do_help(mixed *stuff) {
   string str;
   str = evaluate(stuff[1]);
   if (!str || !strlen(str)) {
      write("Broken help file!\n");
   } else {
      write("$P$" + stuff[0] + "$P$" + str);
   }
}
int here_cmd() {
  mixed str;
  mixed *list;
  int i;
  str = environment(this_player())->help_function();
  if(pointerp(str))
    list = str;
  else if(str)
    list += ({ ({ environment(this_player())->short(), str }) });
  else {
    write("There is no help available for this room.\n");
    return 1;
  }
  if (sizeof(list) == 1) {
    do_help(list[0]);
    return 1;
  }
  str = "";
  for (i = 0; i < sizeof(list); i++) {
    str += sprintf("%s) %s\n", letter_name(i, list), list[i][0]);
  }
  printf("Discworld help found multiple matches, please choose one of:\n"
         "%-*#s\nChoice: ", this_player()->query_cols(), str);
  input_to("help_input", 0, list);
  return 1;
}
int object_cmd(object ob) {
  mixed str;
  mixed *list;
  int i;
  str = ob->help_function();
  if(pointerp(str))
    list = str;
  else if(str)
    list += ({ ({ environment(this_player())->short(), str }) });
  else {
    add_failed_mess("There is no help available for $I.\n", ({ob}));
    return -1;
  }
  if (sizeof(list) == 1) {
    do_help(list[0]);
    return 1;
  }
  str = "";
  for (i = 0; i < sizeof(list); i++) {
    str += sprintf("%s) %s\n", letter_name(i, list), list[i][0]);
  }
  printf("Discworld help found multiple matches, please choose one of:\n"
         "%-*#s\nChoice: ", this_player()->query_cols(), str);
  input_to("help_input", 0, list);
  return 1;
}
int command_cmd(string name) {
   mixed help;
   help = this_player()->help_command(name);
   if (!help) {
      notify_fail("No such command as '" + name + "'.\n");
      return 0;
   } else {
      if (functionp(help)) {
         help = evaluate(help);
      }
      write("$P$" + name + "$P$P" + help);
      return 1;
   }
}
int soul_cmd(string name) {
   string help;
   help = SOUL_OBJECT->help_string(name);
   if (!help) {
      notify_fail("No such soul as '" + name + "'.\n");
      return 0;
   } else {
      write("$P$" + name + "$P$P" + help);
      return 1;
   }
}
int spell_cmd(string name, int spell) {
   mixed help;
   help = this_player()->help_spell(name);
   if (!help) {
      notify_fail("No such spell as '" + name + "'.\n");
      return 0;
   } else {
      if (functionp(help)) {
         this_player()->move_string(evaluate(help), name);
      } else {
         write("$P$" + name + "$P$P" + help);
      }
      return 1;
   }
}
int command_list_cmd() {
   list_help("Command list, try 'help concepts' for a list of concepts.",
       "/doc/helpdir/");
   return 1;
}
int concepts_list_cmd() {
   list_help("Concepts list, try 'help command_list' for a list of commands.",
       "/doc/concepts/");
   return 1;
}
int error_log_cmd() {
   notify_fail("Unable to get help on '" + ERROR_LOG + "'.\n");
   return 0;
}
private void list_help(string title, string dir) {
   string *files;
   files = get_dir(dir + "*") - ({ ".", "..", "ERROR_REPORTS", "RCS", "old" });
   write("$P$Help$P$" + sprintf("%s\n%-#*s\n", title,
                                     (int)this_player()->query_cols(),
                                     implode(files, "\n")));
}
 mixed *help_list(string name) {
   string* stuff;
   mixed str;
   object* fluff;
   object blue;
   stuff = query_help_on(name, this_player()->query_creator(),
                         this_player()->query_lord(),
                         this_player()->query_playtester());
   if (name == "room" || name == "here") {
      str = environment(this_player())->help_function();
      if (pointerp(str)) {
         stuff += str;
      } else if (str) {
         stuff += ({ ({ environment(this_player())->short(),
                        str }) });
      } else {
         add_failed_mess("There is no help available for this room.\n");
         return 0;
      }
   }
   str = this_player()->help_spell(name);
   if (stringp(str)) {
      stuff += ({ ({ name + " (Spell)",
                    (: $(str) :) }) });
   }
   if (functionp(str)) {
      stuff += ({ ({ name + " (Spell)", str }) });
   }
   str = SOUL_OBJECT->help_string(name);
   if (str) {
      stuff += ({ ({ name + " (Soul)",
                    (: $(SOUL_OBJECT)->help_string($(name)) :) }) });
   }
   fluff = filter(match_objects_for_existence(name, ({ this_player(),
                                      environment(this_player()) })),
                    (: $1 && $1->help_function() :));
   if (sizeof(fluff)) {
      foreach (blue in fluff) {
         stuff += blue->help_function();
      }
   }
   return stuff;
}
private string letter_name(int letter, mixed *things) {
   string bing;
   if (sizeof(things) > 26) {
      bing = "aa";
      bing[0] = 'a' + (letter / 26);
      bing[1] = 'a' + (letter % 26);
      return bing;
   }
   bing = "a";
   bing[0] = 'a' + letter;
   return bing;
}
private string start_letter( mixed *things ) {
   return letter_name(0, things);
}
private string end_letter( mixed *things ) {
   return letter_name(sizeof(things) - 1, things);
}
private int query_number_from_string(string name, mixed *things ) {
   int pos;
   if (sizeof(things) > 26) {
      if (strlen(name) != 2) {
         return -1;
      }
      name = lower_case(name);
      if (name[0] < 'a' || name[0] > 'z') {
         return -1;
      }
      if (name[1] < 'a' || name[1] > 'z') {
         return -1;
      }
      pos = (name[0] - 'a') * 26 + name[1] - 'a';
      if (pos >= sizeof(things)) {
         return -1;
      }
      return pos;
   }
   if (strlen(name) != 1) {
      return -1;
   }
   name = lower_case(name);
   if (name[0] < 'a' || name[0] > 'z') {
      return -1;
   }
   pos = name[0] - 'a';
   if (pos >= sizeof(things)) {
      return -1;
   }
   return pos;
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :),
               "here", (: here_cmd() :),
               "object <indirect:object:me-here'item'>", (: object_cmd($1[0]) :),
               "command <string>", (: command_cmd($4[0]) :),
               "spell <string>", (: spell_cmd($4[0], 0) :),
               "ritual <string>", (: spell_cmd($4[0], 1) :),
               "soul <string>", (: soul_cmd($4[0]) :),
               "command_list", (: command_list_cmd() :),
               "concepts", (: concepts_list_cmd() :),
               "", (: concepts_list_cmd() :) });
}
void rehash_dirs() {
   _help_files_player = read_directories(_player_dirs, 1);
   _help_files_creator = read_directories(_creator_dirs, 1);
   _help_files_lord = read_directories(_lord_dirs, 1);
   _help_files_playtester = read_directories(_playtester_dirs, 1);
   _synonyms = read_synonyms();
}
void rehash_specific_dir(string dir) {
   string start;
   mapping ret;
   string name;
   string* files;
   if (dir[<1] != '/') {
      dir += "/";
   }
   start = "/" + implode(explode(dir, "/")[0..1], "/") + "/";
   if (member_array(start, _player_dirs) != -1) {
      ret = read_directories(({ dir }), 0);
      foreach (name, files in ret) {
         if (_help_files_player[name]) {
            _help_files_player[name] &= files;
         } else {
            _help_files_player[name] = files;
         }
      }
   }
   if (member_array(start, _creator_dirs) != -1) {
      ret = read_directories(({ dir }), 0);
      foreach (name, files in ret) {
         if (_help_files_creator[name]) {
            _help_files_creator[name] &= files;
         } else {
            _help_files_creator[name] = files;
         }
      }
   }
   if (member_array(start, _lord_dirs) != -1) {
      ret = read_directories(({ dir }), 0);
      foreach (name, files in ret) {
         if (_help_files_lord[name]) {
            _help_files_lord[name] &= files;
         } else {
            _help_files_lord[name] = files;
         }
      }
   }
   if (member_array(start, _playtester_dirs) != -1) {
      ret = read_directories(({ dir }), 0);
      foreach (name, files in ret) {
         if (_help_files_playtester[name]) {
            _help_files_playtester[name] &= files;
         } else {
            _help_files_playtester[name] = files;
         }
      }
   }
}
private mapping read_synonyms() {
  string *bits, *bits2;
  int i;
  mapping tmp;
  tmp = ([ ]);
  bits = explode(read_file(SYNONYMS), "\n");
  for(i=0; i<sizeof(bits); i++) {
    bits2 = explode(bits[i], " ");
    tmp[bits2[0]] = bits2[1];
  }
  return tmp;
}
private mapping read_directories(string *directories, int recurse) {
   string *files;
   string fname;
   int i;
   string dir;
   mapping ret;
   ret = ([ ]);
   for (i = 0; i < sizeof(directories); i++) {
     dir = directories[i];
     files = get_dir(dir + "*") - ({ "ERROR_REPORTS" });
     foreach (fname in files) {
       if (file_size( dir + fname) == -2) {
         if (fname != "." &&
             fname != ".." &&
             fname != "old" &&
             fname != "RCS") {
           directories += ({ dir + fname + "/" });
         }
       } else if (fname != "." &&
                  fname != ".." &&
                  fname != "old") {
         if (!ret[fname]) {
           ret[fname] = ({ dir + fname });
         } else {
           ret[fname] += ({ dir + fname });
         }
         if (strsrch(fname, "_") > 0) {
           fname = replace(fname, "_", " ");
           if (!ret[fname]) {
             ret[fname] = ({ dir + fname });
           } else {
             ret[fname] += ({ dir + fname });
           }
         }
       }
     }
   }
   return ret;
}
mixed *query_help_on(string name, int creator, int lord, int pt) {
   string *files;
   mapping map;
   files = ({ });
   name = replace_string(name, " ", "_");
   if (_help_files_player[name]) {
      files += create_help_files(_help_files_player[name], NROFF_DIR);
   }
   if (lord || creator || pt) {
     if(_help_files_playtester && _help_files_playtester[name]) {
         files += create_help_files(_help_files_playtester[name], NROFF_DIR);
      }
   }
   if (lord || creator) {
     if(_help_files_creator && _help_files_creator[name]) {
         files += create_help_files(_help_files_creator[name], NROFF_DIR);
      }
      map = AUTODOC_HANDLER->query_help_map();
      if (map && map[name]) {
         files += create_help_files(map[name], NROFF_DIR);
      }
   }
   if (lord) {
     if(_help_files_lord && _help_files_lord[name]) {
         files += create_help_files(_help_files_lord[name], NROFF_DIR);
      }
      map = AUTODOC_HANDLER->query_help_map();
      if (map && map[name]) {
         files += create_help_files(map[name], NROFF_DIR);
      }
  }
   return files;
}
string query_synonym(string name) {
  if(mapp(_synonyms) && _synonyms[name])
    return _synonyms[name];
  return "";
}
private string nroff_file(string name, string nroff_dir) {
   string nroff_fn;
   string str;
   nroff_fn = nroff_dir + replace(name, "/", ".");
   str = NROFF_HAND->cat_file(nroff_fn, 1);
   if (!str) {
      NROFF_HAND->create_nroff(name, nroff_fn);
      str = NROFF_HAND->cat_file(nroff_fn, 0);
   }
   return str;
}
mixed *create_help_files(string *names, string nroff_dir) {
   int i;
   mixed *ret;
   string *bits;
   ret = ({ });
   for (i = 0; i < sizeof(names); i++) {
      bits = explode(names[i], "/");
      ret += ({ ({ bits[<1] + " (" +
                   names[i] + ")",
                   (: nroff_file($(names[i]), $(nroff_dir)) :) }) });
   }
   return ret;
}
mapping query_help_files_player() { return _help_files_player; }
mapping query_help_files_creator() { return _help_files_creator; }
mixed *stats() {
  mapping map;
  map = AUTODOC_HANDLER->query_help_map();
  return ({
      ({ "player help files", sizeof( keys(_help_files_player) ) }),
      ({ "creator help files", sizeof( keys(_help_files_creator) ) }),
        ({ "autodoc help map", sizeof(keys(map)) }) ,
          });
}
int clean_up() {
  return 0;
}
void dest_me() {
}

==================================================
FILE: player/helper_s.c
==================================================

#include <player_handler.h>
inherit "/cmds/base";
int cmd() {
    object *helpers;
    string mess;
    helpers = filter( users(), (: !$1->query_creator() &&
        $1->query_property( "newbie helper" ) &&
        !$1->query_login_ob() :) );
    switch( sizeof( helpers ) ) {
        case 0:
            add_failed_mess("There are no newbie helpers logged on at the "
                "moment.\n");
            return 0;
        case 1:
            if ( helpers[ 0 ] == this_player() ) {
                mess = "You are the only newbie helper logged on at the "
                    "moment.\n";
            }
            else {
                mess = helpers[ 0 ]->query_short() + " is the only newbie "
                    "helper logged on at the moment.\n";
            }
        break;
        default:
            mess = query_multiple_short( helpers->query_short() ) + " are "
                "newbie helpers.\n";
    }
    this_player()->add_succeeded_mess(this_object(), ({mess, ""}),
      ({ }));
    return 1;
}
int test_helper( string player_name ) {
    player_name = lower_case( player_name );
    if ( PLAYER_HANDLER->test_property( player_name, "newbie helper" ) ) {
        this_player()->add_succeeded_mess(this_object(), ({
          capitalize( player_name ) + " is a newbie helper.\n",
          ""}), ({ }));
        return 1;
    }
    add_failed_mess(capitalize( player_name ) +
        " is not a newbie helper.\n" );
    return 0;
}
mixed *query_patterns() {
    return ({ "", (: cmd :),
              "<string'name'>", (: test_helper( $4[ 0 ] ) :) });
}

==================================================
FILE: player/hi_story.c
==================================================

int cmd(string arg){
   return this_player()->print_history(arg);
}
mixed query_patterns() {
   return ({ "", (: cmd("") :),
               "<string'number|number,number'>", (: cmd($4[0]) :) });
}

==================================================
FILE: player/hnew_bie.c
==================================================

#include <player.h>
inherit "/cmds/guild_base";
#define HIST "/obj/handlers/hist_handler"
int cmd() {
  mixed *history;
  string result;
  history = HIST->query_chat_history("newbie");
  if ( !arrayp( history ) || !sizeof( history ) ) {
    tell_object(this_player(), "Nothing has been said on the newbie "
                "channel.\n");
  }
  else {
    result = "$P$Newbie Channel$P$";
    result += implode(map(history, (: "$I$5=*" + ctime($1[2])[11..18] +
                                      "* $C$" + $1[0] + $1[1] +
                                    "%^RESET%^" :)), "\n");
    tell_object(this_player(), result);
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd() :) });
}

==================================================
FILE: player/ht_ell.c
==================================================

int cmd(string arg, int brief){
  function bing;
  bing = this_player()->get_htell_func();
  arg = this_player()->expand_nickname(arg);
  return evaluate(bing, arg, brief);
}
mixed *query_patterns()  {
    return ({ "brief search <string'name'>", (: cmd(lower_case($4[0]), 1) :),
              "search <string'name'>", (: cmd(lower_case($4[0]),
                                     !this_player()->query_verbose("htell")) :),
              "brief", (: cmd("", 1) :),
              "verbose", (: cmd("", 0) :),
              "", (: cmd("", !this_player()->query_verbose("htell")) :)
           });
}

==================================================
FILE: player/i.c
==================================================

inherit "/cmds/player/inv_entory";

==================================================
FILE: player/idea.c
==================================================

inherit "/cmds/report_base";
void create() {
   ::create();
   set_error_type("IDEA");
   set_use_last_error(0);
}

==================================================
FILE: player/identify.c
==================================================

#define EFFECT "/std/effects/object/identity_hold"
inherit "/cmds/base";
mixed cmd(object *indirect_obs, string new_name)
{
   string  word;
   object  thing;
   object *things;
   int *ees;
   int keep;
   if (!new_name)  {
      things = filter(indirect_obs, (: $1->query_identifier() :));
      if (!sizeof(things))  {
         if (sizeof(indirect_obs) > 1) {
            write("You do not have any of those objects identified.\n");
         } else {
            write("You do not have " + indirect_obs[0]->the_short() +
                  " identified.\n");
         }
      } else foreach (thing in things)  {
         write("You have " + thing->the_short() + " identified as \"" +
               thing->query_full_identifier() + "\".\n");
      }
   } else if (sizeof(indirect_obs) == 1)  {
      word = lower_case(new_name);
      if (word == "none") {
         ees = indirect_obs[0]->effects_matching(EFFECT->query_classification());
         if (!sizeof(ees)) {
            add_failed_mess("No identities to remove.");
            return 0;
         }
         keep = indirect_obs[0]->query_keep();
         indirect_obs[0]->delete_effect(ees[0]);
         if (keep) {
            thing->add_effect( EFFECT, ([ "keep" : 1 ]) );
         }
         write("You remove the description from " +
               indirect_obs[0]->the_short() + ".\n");
      } else {
         indirect_obs[0]->add_effect(EFFECT, ([ "identity" : word ]));
         write(indirect_obs[0]->the_short() + " may now be identified as \"" +
               word + "\".\n");
      }
   } else {
      write("You may only identify one thing at a time.\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me'object'> as <string'some new name'>",
             (: cmd($1, $4[1]) :),
             "<indirect:object:me'object(s)'>",
             (: cmd($1, 0) :) });
}

==================================================
FILE: player/idle.c
==================================================

inherit "/cmds/base";
int cmd(object who) {
  if (!interactive(who))
    write(who->query_cap_name() + " is net-dead.\n");
  else
    write(who->query_cap_name() + " has been idle for " +
          "/secure/finger"->time_elapsed_string(query_idle(who)) + ".\n");
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:player>", (: cmd($1[0]) :) });
}

==================================================
FILE: player/ignore.c
==================================================

#include <drinks.h>
#include <language.h>
#include <player.h>
#include <player_handler.h>
#define TP this_player()
inherit "/cmds/base";
int cmd_list() {
   string *ignoring;
   ignoring = TP->query_property("ignoring");
   if(!ignoring) {
      ignoring = ({ });
   }
   if ( !sizeof(ignoring) )  {
      write( "You are not ignoring anyone.\n" );
   } else  {
      ignoring = sort_array(ignoring, 1);
      write( "You are currently ignoring " +
              query_multiple_short( map(ignoring, (: capitalize($1) :)),
                                    0, 0, 1, 0 ) + ".\n" );
   }
   return 1;
}
int cmd( string str) {
   string *ignoring;
   ignoring = TP->query_property("ignoring");
   if(!ignoring) {
      ignoring = ({ });
   }
   str = lower_case( TP->expand_nickname(str) );
   if ( !(PLAYER_HANDLER->test_user(str))  &&  !find_player(str)) {
      if (find_living(str)) {
         add_failed_mess("You cannot ignore an npc.\n");
         return 0;
      } else {
         add_failed_mess( "Ignoring someone that doesn't exist?  Is this some "
                           "kind of zen?\n" );
         return 0;
      }
   }
   if (TP->query_name() == str) {
      add_failed_mess("Ignoring yourself.  Novel.\n");
      return 0;
   }
   if ( member_array( str, ignoring ) == -1 )  {
      ignoring += ({ str });
      TP->add_property("ignoring", ignoring, 604800);
   } else  {
      write( "You are already ignoring " + capitalize(str) + ".\n" );
   }
   write("You are now ignoring "+capitalize(str)+".\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "<string'person'>", (: cmd($4[0]) :),
             "", (: cmd_list() :) });
}

==================================================
FILE: player/inv_entory.c
==================================================

inherit "/cmds/base";
mixed cmd()
{
   if (this_player()->query_property("dead")) {
      object *obs;
      write("You are just a disembodied spirit.  "
            "You have mist; what else do you want?\n");
      obs = all_inventory(this_player());
      obs = filter_array(obs, (: $1->query_property("dead usable") :));
      if (sizeof(obs)) {
         write("Hang on!  You appear to have " +
               query_multiple_short(obs) + ".  Amazing.\n");
      }
      return 1;
   }
   write(sprintf("You are %s by:\n", this_player()->burden_string()) +
	 this_player()->query_living_contents(1));
   if (this_player()->query_auto_loading()) {
      write("\n%^YELLOW%^Please note that your inventory is still being "
            "generated.%^RESET%^\n");
   }
   return 1;
}
mixed *query_patterns()
{
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/joing_roup.c
==================================================

inherit "cmds/base";
#define TEAM_HANDLER "/obj/handlers/team"
mixed cmd(string str) {
  object owner, person;
  int policy;
  if(!str)
    return notify_fail("Syntax: joingroup <group name>\n");
  if(TEAM_HANDLER->query_group(this_player()))
    return notify_fail("You are already a member of a group.\n");
  if(!TEAM_HANDLER->test_group(str))
    return notify_fail("Sorry, there is no group by that name.\n");
  owner = TEAM_HANDLER->query_owner(str);
  if(!owner || environment(owner) != environment(this_player()))
    return notify_fail("Sorry, the owner of "+str+" is not here.\n");
  if(TEAM_HANDLER->query_full(str))
    return notify_fail("Sorry, that group is full, you cannot join.\n");
  if(TEAM_HANDLER->query_locked(str))
    return notify_fail("Sorry, that group is locked, you cannot join.\n");
  policy = TEAM_HANDLER->query_policy(str);
  if(!TEAM_HANDLER->join_group(str, this_player()))
    return notify_fail("Ack, something went wrong.\n");
  foreach(person in TEAM_HANDLER->query_members(str)) {
    if(person && present(person, environment(this_player())) &&
       person != this_player()) {
      this_player()->add_protector(person);
      person->add_protector(this_player());
      if(policy == 1)
  this_player()->add_follower(person);
      if((policy == 1) || (person == owner))
  person->add_follower(this_player());
    }
  }
  write("You join "+str+" and will now protect and be protected by "
  "them.\n");
  say(this_player()->short()+" joins "+str+" and will protect and be "
      "protected by its members.\n");
  write("You are now a member of "+str+"\n");
  return 1;
}

==================================================
FILE: player/keep.c
==================================================

#define EFFECT "/std/effects/object/identity_hold"
inherit "/cmds/base";
int cmd( object *obs )  {
   object thing;
   foreach(thing in obs) {
      thing->add_effect( EFFECT, ([ "keep" : 1 ]) );
   }
   write( "You will now attempt to keep "+
         (string)query_multiple_short(obs)+".\n" );
   return 1;
}
int cmd_list() {
   object* obs;
   obs = all_inventory(this_player());
   obs = filter(obs, (: $1->query_keep() :) );
   if (!sizeof(obs)) {
      add_failed_mess("You are not keeping anything.\n");
      return 0;
   }
   write("You are keeping " + query_multiple_short(obs) + ".\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd( $1 ) :),
             "", (: cmd_list :) });
}

==================================================
FILE: player/killers.c
==================================================

#include <player_handler.h>
#include <clubs.h>
inherit "/cmds/base";
string second_name( string str );
mixed cmd( string mode ) {
   object *killers;
   object player = this_player();
   string *names, *tmp, name;
   int i, brief, number, guild;
   mixed *unique_names;
   if ( mode == "verbose" ) brief = 0;
   else brief = 1;
   killers = filter_array( users(),
                         (: !($1->query_creator())  &&
                            !($1->query_login_ob())  &&
                            !($1->query_property("test character")) &&
                            $1->query_player_killer() :) );
   if (mode) mode = lower_case(mode);
   if (mode &&
       mode != "verbose" &&
       mode != "brief") {
      guild = 1;
      mode = replace(mode, ({  "assassins",   "assassin",
                               "priests",     "priest",
                               "thieves",     "thief",
                               "warriors",    "warrior",
                               "witches",     "witch",
                               "wizards",     "wizard",
                               "adventurers", "adventurer",
                               "fighters",    "warrior",
                               "fighter",     "warrior",
                               "monks",       "monk",
                              }));
      killers = filter_array( killers,
                      (: $1->query_guild_ob() == "/std/guilds/" + $(mode) :) );
   }
   if (brief) {
      names = killers->query_cap_name();
   } else {
      names = killers->short();
   }
   for (i = 0; i < sizeof(killers); i++) {
      if (names[i] && this_player()->is_friend(killers[i]->query_name())) {
         names[i] += "(%^GREEN%^F%^RESET%^)";
      }
   }
   names -= ({ 0 });
   if (!sizeof(names)) {
      write("There are no " + (guild?mode + " ":"") + "player killers logged"
            " in.\n");
   } else {
      if(sizeof(names) == 1)  {
         if ( names[0] == (brief? player->query_cap_name(): player->short()) ) {
            write( "You are the only player killer on " + mud_name() + ".\n" );
         } else {
            write("The only " + (guild?mode:"") + " player killer currently "
                  "logged in is "+ names[0]+".\n");
         }
      } else {
         i = 0;
         if ( member_array(
              (brief? player->query_cap_name(): player->short()),
              names ) > -1 )  {
            names -= ({ (brief? player->query_cap_name(): player->short()) });
            i = 1;
         }
         names = sort_array( names,
                             (: strcmp( lower_case( $1 ),
                                        lower_case( $2 ) ) :) );
         if ( i ) {
             name = this_player()->query_cap_name();
             if (this_player()->query_family_name() &&
                 !brief) {
                name += " " + this_player()->query_family_name();
             }
             names += ({ name });
         }
         if (!brief) {
           unique_names = unique_array( names, (: second_name($1) :) );
           names = ({ });
           foreach ( tmp in unique_names ) {
                names += tmp;
           }
         }
         number = sizeof(names);
         write("There are " + sizeof(names) + (guild?" " + mode:"") +
               " player killers logged in:\n" +
               query_multiple_short(names) + "\n");
      }
   }
   return 1;
}
int cmd_here() {
   string *killers;
   killers = filter_array( all_inventory(environment(this_player())),
                         (: !($1->query_creator())  &&
                            !($1->query_property("test character")) &&
                            $1->query_player_killer() &&
                            $1->query_visible( this_player() ) &&
                            $1 != this_player() :) );
   if (!sizeof(killers)) {
      add_failed_mess("There are no killers here.\n");
      return 0;
   }
   if (sizeof(killers) > 1) {
      write("The killers here are " +
            query_multiple_short(killers) + ".\n");
   } else {
      write("The killer here is " +
            query_multiple_short(killers) + ".\n");
   }
   return 1;
}
string second_name( string str ) {
  int pos;
  pos = strsrch( str, " " );
  if (pos == -1) {
     return "";
  }
  return str[pos+1..];
}
int cmd_club( string club ) {
    int number;
    string *names;
    if( CLUB_HANDLER->query_club_secret( club ) &&
        !CLUB_HANDLER->is_member_of( club, this_player()->query_name() ) ) {
        add_failed_mess( "That is a secret club! Killers information about "
            "secret clubs is only shown to club members.\n" );
        return -1;
    }
    names = map( filter( CLUB_HANDLER->query_members( club ),
       (: find_player( $1 ) && !PLAYER_HANDLER->test_creator( $1 ) &&
        pk_check( $1, this_player(), 1 ) != 1 :) ),
        (: capitalize( $1 ) :) );
    if ( number = sizeof( names ) ) {
        if ( number > 1 ) {
            write("There are " + number + " player killers logged on "
                "who are members of " + capitalize( club ) + ":\n" +
                sprintf("%-#*s", this_player()->query_cols(), implode( names,
                "\n" ) ) + "\n");
        }
        else {
            write("There is " + number + " player killer logged on "
                "who is a member of " + capitalize( club ) + ":\n" +
                sprintf("%-#*s", this_player()->query_cols(), implode( names,
                "\n" ) ) + "\n");
        }
    }
    else {
        add_failed_mess( "There are no player killers in that club.\n" );
        return -1;
    }
     return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
            "{verbose|brief}", (: cmd( $4[0] ) :),
            "here", (: cmd_here() :),
            "club <string'club name'>", (: cmd_club( $4[0] ) :),
            "guild <string'guild name'>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: player/lang_uages.c
==================================================

#include <move_failures.h>
#include <language.h>
inherit "cmds/base";
#define TP this_player()
mixed cmd(object *obs, string indir, string str) {
   int i;
   string *langs;
   langs = LANGUAGE_HAND->query_languages();
   for (i = 0; i < sizeof(langs); i++) {
      if (TP->query_skill(
               LANGUAGE_HAND->query_language_spoken_skill(langs[i])) > 1 ||
          TP->query_skill(
               LANGUAGE_HAND->query_language_written_skill(langs[i])) > 1) {
      } else {
         langs = langs[0..i-1] + langs[i+1..];
         i--;
      }
   }
   write("You can currently speak " +( TP->query_womens_day()?"wommon":
                 implode(langs, ", ") ) +" and grunt.\n");
   return 1;
}

==================================================
FILE: player/last.c
==================================================

#include <player_handler.h>
inherit "/cmds/base";
#define BASENAME "/d/admin/log/ENTER"
string process_file(string fname, string str);
string get_details(string str, string file);
string mtime(string t);
string stime(string t);
nosave int logged_on;
nosave string time;
mixed cmd(string str) {
  string retval;
  int i;
  write("This command is no longer available.\n");
  return 1;
  if (!str || str == "") {
    notify_fail("Usage: last <name>\n");
    return 0;
  }
  if(!this_player()->query_creator() &&
     PLAYER_HANDLER->test_creator(str)) {
    return notify_fail("Sorry, you can't do that, "+ str + " is a "
           "creator.\n");
  }
  if("/secure/master"->query_lord(str) &&
     !"/secure/master"->query_lord(this_player()->query_name())) {
    return notify_fail("Sorry, you can't do that, "+ str +" is a "
           "lord\n");
  }
  logged_on = 0;
  retval = "";
  time = "";
  str = (string)this_player()->expand_nickname(str);
  retval = process_file(BASENAME + ".log", str);
  if(logged_on == 1) {
    if (!find_player(str)) {
      retval += sprintf("%15-s %s - Destd (??:??)\n", str, mtime(time));
    } else {
      retval += sprintf("%15-s %s - Not logged off\n", str, mtime(time));
    }
  }
  if(retval == "") {
    if(PLAYER_HANDLER->test_user(str)) {
      i = (int)PLAYER_HANDLER->test_last(str);
      if(i) {
        write(sprintf("%15-s %s\n", str, ctime(i)));
        return 1;
      }
    }
    write("No such user " + str + "\n");
  } else {
    write(retval);
  }
  return 1;
}
string process_file(string fname, string str) {
  int size, bits, length, i;
  string retval, file;
  retval = "";
  seteuid("Root");
  size = file_size(fname);
  if(size > 50000) {
    length = file_length(fname);
    bits = size / 50000;
  } else {
    bits = 1;
  }
  if(bits > 10) {
    i = bits - 10;
  } else {
    i = 0;
  }
  for(; i< bits; i++) {
    file = unguarded((: read_file, fname,
          i * (length/bits), length / bits :) );
    if (!file) {
      write("Log file non existant, or bad things are happening.  "
      "(Bad vibes man!)\n");
      return "";
    }
    retval += get_details(str, file);
  }
  seteuid("Room");
  return retval;
}
string get_details(string str, string file) {
  string *sarr;
  string retval;
  string t2;
  string type;
  string time_str;
  int i;
  retval = "";
  sarr = explode(file, "\n");
  for (i = 0; i < sizeof(sarr); i++) {
    if (sscanf(sarr[i], "%s [%s] " + str + " ", time_str, type) == 2 ||
        sscanf(sarr[i], "%s [%s]  " + str + " ", time_str, type) == 2)  {
      switch(type)  {
        case "Enter":
          time = time_str;
          logged_on = 1;
          break;
        case "Recon":
          time = time_str;
          logged_on = 1;
          break;
        case "Su":
          t2 = time_str;
          logged_on = 0;
          retval += sprintf("%15-s %s - %s [Quit]\n", str, mtime(time),
                            stime(t2));
          break;
        case "NDead":
          t2 = time_str;
          logged_on = 1;
          retval += sprintf("%15-s %s - %s [NetDead]\n", str, mtime(time),
                    stime(t2));
          time = "";
          break;
        case "Exit":
          t2 = time_str;
          logged_on = 0;
          retval += sprintf("%15-s %s - %s [Quit]\n", str, mtime(time),
                            stime(t2));
          break;
        default:
          write("Someone has stuffed up... please file a bug report\n");
          break;
      }
    }
  }
  return retval;
}
string mtime(string t) {
  if(t == "")
    return "??? ?? ??:??";
  return t[0..<4];
}
string stime(string t) {
  if(t == "")
    return "??:??";
  return t[7..11];
}

==================================================
FILE: player/leaveg_roup.c
==================================================

inherit "cmds/base";
#define TEAM_HANDLER "/obj/handlers/team"
int do_leave(string group, object member);
mixed cmd(string str) {
   object member, *members;
   string group;
   int disband;
   group = TEAM_HANDLER->query_group(this_player());
   if(!group)
      return notify_fail("You are not a member of any group.\n");
   members = TEAM_HANDLER->query_members( group );
   if ( !members) {
     TEAM_HANDLER->leave_group(group, this_player());
     TEAM_HANDLER->end_group( group );
     write( "Somehow your group has no members.  "
           "Your group has been ended.  "
           "I hope this is okay.\n" );
     return 1;
   } else if(!(TEAM_HANDLER->query_owner(group))) {
     TEAM_HANDLER->leave_group( group, member );
     TEAM_HANDLER->end_group( group );
     write( "Somehow your group has no leader.  "
      "Your group has been ended.  "
      "I hope this is okay.\n" );
     return 1;
   }
   if((object)TEAM_HANDLER->query_owner(group) == this_player())
      disband = 1;
   foreach( member in members ) {
      if ( !member || ( member == this_player() ) )
         continue;
      if ( disband ) {
         tell_object(member, this_player()->short()+" leaves the group and "
                     "it disbands, everyone going their separate ways.\n");
         do_leave(group, member);
      } else
         tell_object(member, this_player()->short()+" leaves the group.\n");
   }
   if(disband) {
      TEAM_HANDLER->end_group(group);
      write("You disband "+group+" and everyone goes their separate "
            "ways.\n");
   } else {
      do_leave(group, this_player());
      write("You leave "+group+".\n");
   }
   return 1;
}
int do_leave(string group, object member) {
   object person;
   if(!TEAM_HANDLER->leave_group(group, member))
      return notify_fail("Ack, something went wrong.\n");
   if ( !sizeof( (object *)TEAM_HANDLER->query_members( group ) ) )
      return 0;
   foreach(person in TEAM_HANDLER->query_members(group)) {
      if(person) {
         member->remove_protector(person);
         person->remove_protector(member);
         member->remove_follower(person);
         person->remove_follower(member);
      }
   }
   return 1;
}

==================================================
FILE: player/liaison_s.c
==================================================

inherit "/cmds/base";
private string idle_time(object person) {
  int hours, mins, secs;
  string s, m, h;
  secs = query_idle(person);
  mins = secs / 60;
  secs %= 60;
  hours = mins / 60;
  mins %= 60;
  s = ("0"+secs)[<2..<1];
  m = ("0"+mins)[<2..<1];
  if ( !hours )  {
    return " (idle: "+m+":"+s+")";
  }
  h = ("0"+hours)[<2..<1];
  return " (idle: "+h+":"+m+":"+s+")";
}
mixed cmd( ) {
   int i, j;
   string *members, *member_alias, *aliases;
   object person;
   members = (string *)"/d/liaison/master"->query_members();
   aliases = ({ });
   i = sizeof( members );
   while ( i-- ) {
      person = find_player( members[ i ] );
      if ( ! person ) {
         member_alias = "/d/liaison/master"->member_alias( members[ i ] );
         j = sizeof( member_alias );
         while ( j-- ) {
            if ( find_player( member_alias[ j ] ) ) {
               aliases += ({ capitalize( member_alias[ j ] ) +"("+
                     capitalize( members[ i ] ) +")" });
            }
         }
         members = delete( members, i, 1 );
      } else if (!person) {
          members = delete(members, i, 1);
      } else {
         if ( !interactive( person ) ) {
            members = delete( members, i, 1 );
         } else {
            members[ i ] = capitalize( members[ i ] );
            switch( person->query_invis()  )  {
            case 0:
               break;
            case 1:
               members[ i ] = sprintf( "(%s)", members[ i ] );
               break;
            case 2:
               members[ i ] = sprintf( "({%s})", members[ i ] );
               break;
            default:
               members[ i ] = sprintf( "([%s])", members[ i ] );
               break;
            }
            members[ i ] = capitalize( members[ i ] );
            if (person->query_busy()) {
               members[ i ] += " (busy)";
            }
            if ( query_idle( person ) > 120 )  {
               members[ i ] += idle_time( person );
            }
         }
      }
   }
   if ( this_player()->query_creator() || !sizeof( members )) {
      members += aliases;
   }
   if ( !sizeof( members ) ) {
      add_failed_mess( "There are no Liaison creators currently logged on.\n" );
      return 0;
   }
   if ( sizeof( members ) > 1 ) {
      write( "Liaison creators logged on are "+
            query_multiple_short( members ) +".\n" );
   } else {
      write( "The only Liaison creator logged on is "+ members[ 0 ] +".\n" );
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/locate.c
==================================================

inherit "/cmds/base";
#define TP this_player()
object *look_in_container(object fluff,
                          string word) {
   object frog;
   object *obs;
   object *things;
   things = match_objects_for_existence(word, ({ fluff }));
   obs = all_inventory(fluff);
   foreach (frog in obs) {
      if (sizeof(all_inventory(frog))) {
         things += look_in_container(frog, word);
      }
   }
   return things;
}
mixed cmd( string word ) {
   int i;
   int base_num;
   string list;
   object thing;
   object *things;
   object *extra_things;
   debug_printf("%s", word);
   if (environment(TP)) {
      switch(TP->check_dark(environment(TP)->query_light())) {
      case -2:
      case -1:
        if (this_player()->query_creator()) {
          write("It is too dark to locate anything, but since you are a cre...\n");
        } else {
          return notify_fail("It's too dark to locate anything.\n");
        }
        break;
      case 1:
      case 2:
        if (this_player()->query_creator()) {
          write("It is too bright to locate anything, but since you are a cre...\n");
        } else {
           return notify_fail("It's too bright to locate anything.\n");
        }
        break;
      }
   }
   things = match_objects_for_existence( word, ({ environment( TP ) }) );
   things = filter(things, (: environment($1) == environment(TP) ||
                             environment($1) == TP :));
   extra_things = look_in_container(this_player(), word) - things;
   base_num = sizeof(things);
   things += extra_things;
   if ( !sizeof( things ) ) {
      return notify_fail( "There is nothing here matching \""+ word +"\".\n" );
   }
   if ( sizeof( things ) == 1 ) {
     if ( things[0] == TP ) {
       write("You are here! :)\n");
       return 1;
     }
     list = "$C$"+ (string)things[ 0 ]->the_short();
     if ( (object)things[ 0 ]->query_wielded() == TP ) {
       list += " (held in " + query_multiple_short(TP->query_holding_limbs(things[0])) + ")";
     }
     if ( (object)things[ 0 ]->query_worn_by() == TP ) {
       list += " (worn)";
     }
     if ( things[ 0 ]->query_keep() ) {
       list += " (keeping)";
     }
     word = (string)things[ 0 ]->query_full_identifier();
     if ( stringp( word ) ) {
       list += " (\""+ word +"\")";
     }
     if (environment(things[0]) == this_player()) {
       list += (things[0]->group_object() ? " are" : " is") +
         " in your inventory.\n";
     } else {
       list += (things[0]->group_object() ? " are in " : " is in ");
       list += inside_the_short(environment( things[ 0 ] )) + ".\n";
     }
     write( list );
     return 1;
   }
   list = "";
   foreach ( thing in things ) {
      i++;
      if ( thing == TP ) {
         list += "You (" + i + ") are here :)\n";
         continue;
      }
      if (i > 30) {
         list += "Truncated list!  Cannot list more than 30 items.\n";
         break;
      }
      list += "$C$" + (string)thing->the_short();
      if (i <= base_num) {
         list += " (" + i + ")";
      }
      if ( (object)thing->query_wielded() == TP ) {
         list += " (held in " + query_multiple_short(TP->query_holding_limbs(thing)) + ")";
      }
      if ( (object)thing->query_worn_by() == TP ) {
         list += " (worn)";
      }
      if ( thing->query_keep() ) {
         list += " (keeping)";
      }
      word = (string)thing->query_full_identifier();
      if ( stringp( word ) ) {
         list += " (\""+ word +"\")";
      }
      if (environment(thing) == this_player()) {
         list += (thing->group_object() ? " are " : " is ") +
           "in your inventory.\n";
      } else {
        list += (thing->group_object() ? " are in " : " is in ");
         list += inside_the_short(environment( thing )) + ".\n";
      }
   }
   write( "$P$Locate$P$"+ list );
   return 1;
}
mixed *query_patterns() {
   return ({ "<string'object name'>", (: cmd($4[0]) :) });
}
