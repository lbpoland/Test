# Total Tokens: 17585
# Total Files Merged: 12
# Total Characters: 58651

c
==================================================

#include <quest_handler.h>
#define TEXTS_DIR "/save/quests/"
inherit "/cmds/base";
private string *names;
private mapping makers;
protected void create() {
   makers = ([ ]);
}
private void print_info( int i ) {
   string text;
   text = read_file( TEXTS_DIR + replace( names[ i ], " ", "_" ) +".txt" );
   if ( !text )
      text = "There is no text file for this quest.\n";
   printf( "\nQuest %d of %d  \"%s\", level %d\n"
           "   title: %s\n   story: %s\n"
           "   Active: %s\n"
           "   completed %d times, last by %s\n\n"
           "%s\n",
           i + 1, sizeof( names ), names[ i ],
           (int)QUEST_HANDLER->query_quest_level( names[ i ] ),
           (string)QUEST_HANDLER->query_quest_title( names[ i ] ),
           (string)QUEST_HANDLER->query_quest_story( names[ i ] ),
           (int)QUEST_HANDLER->query_quest_status(names[i]) ? "Yes" : "No",
           (int)QUEST_HANDLER->query_quest_times( names[ i ] ),
           capitalize( (string)QUEST_HANDLER->query_quest_done( names[ i ] ) ),
           text );
}
private void change_status( int i ) {
  switch(QUEST_HANDLER->change_quest_status(names[i])) {
  case 1:
    printf("Quest %s set to active.\n", names[i]);
    break;
  case 0:
    printf("Quest %s set to inactive.\n", names[i]);
    break;
  case -1:
    printf("No such quest: %s.\n", names[i]);
    break;
  }
}
void main_menu( string word ) {
   int number, which;
   string name;
   mixed *args;
   which = makers[ this_player() ][ 0 ];
   args = makers[ this_player() ][ 1 ];
   if ( !word || ( word == "" ) )
      word = " ";
   switch ( word[ 0 ] ) {
      case 'Q' :
      case 'q' :
         return;
      case 'N' :
      case 'n' :
         if ( which > sizeof( names ) - 2 ) {
            printf( "No more quests.\n" );
            which = sizeof( names ) - 1;
            break;
         }
         which++;
         print_info( which );
         break;
      case 'A':
      case 'a':
         change_status(which);
         break;
      case 'P' :
      case 'p' :
         if ( which < 1 ) {
            printf( "No previous quests.\n" );
            which = 0;
            break;
         }
         which--;
         print_info( which );
         break;
      case 'G' :
      case 'g' :
         if ( strlen( word ) < 3 ) {
            printf( "Syntax: G <number>\n" );
            break;
         }
         if ( sscanf( word[ 2 .. ], "%d", number ) != 1 ) {
            printf( "Syntax: G <number>\n" );
            break;
         }
         if ( ( number < 1 ) || ( number > sizeof( names ) ) ) {
            printf( "Number must be between 1 and %d.\n", sizeof( names ) );
            break;
         }
         which = number - 1;
         print_info( which );
         break;
      case 'C' :
      case 'c' :
         if ( strlen( word ) < 3 ) {
            printf( "Syntax: C <quest>\n" );
            break;
         }
         if ( args[ 0 ] < 1 ) {
            printf( "No quest level set.\n" );
            break;
         }
         if ( !stringp( args[ 1 ] ) ) {
            printf( "No quest title set.\n" );
            break;
         }
         if ( !stringp( args[ 2 ] ) ) {
            printf( "No quest story set.\n" );
            break;
         }
         word = word[ 2 .. ];
         if ( member_array( word, names ) != -1 ) {
            printf( "There is already a quest \""+ word +"\".\n" );
            break;
         }
         QUEST_HANDLER->add_quest( word, args[ 0 ], args[ 1 ], args[ 2 ] );
         names += ({ word });
         args = allocate( 3 );
         printf( "Quest \""+ word +"\" added.\n" );
         which = sizeof( names ) - 1;
         print_info( which );
         break;
      case 'L' :
      case 'l' :
         if ( strlen( word ) < 3 ) {
            printf( "Syntax: L <level>\n" );
            break;
         }
         if ( sscanf( word[ 2 .. ], "%d", number ) != 1 ) {
            printf( "Syntax: L <level>\n" );
            break;
         }
         if ( number < 1 ) {
            printf( "Level must be at least 1.\n" );
            break;
         }
         args[ 0 ] = number;
         printf( "Quest level set to "+ number +".\n" );
         break;
      case 'T' :
      case 't' :
         if ( strlen( word ) < 3 ) {
            printf( "Syntax: T <title>\n" );
            break;
         }
         word = word[ 2 .. ];
         if ( member_array( word, (string)QUEST_HANDLER->query_quest_titles() )
               != -1 ) {
            printf( "There is already a quest that gives the title \""+
                  word +"\".\n" );
            break;
         }
         args[ 1 ] = word;
         printf( "Quest title set to \""+ word +"\".\n" );
         break;
      case 'S' :
      case 's' :
         if ( strlen( word ) < 3 ) {
            printf( "Syntax: S <story>\n" );
            break;
         }
         word = word[ 2 .. ];
         if ( member_array( word, (string)QUEST_HANDLER->query_quest_stories() )
               != -1 ) {
            printf( "There is already a quest that has the story \""+
                  word +"\".\n" );
            break;
         }
         args[ 2 ] = word;
         printf( "Quest story set to \""+ word +"\".\n" );
         break;
      case 'R' :
      case 'r' :
         printf( "\nQuest data so far:\n" );
         if ( args[ 0 ] < 1 )
            word = "not set";
         else
            word = sprintf( "%d", args[ 0 ] );
         printf( "   level: %s\n", word );
         if ( !stringp( args[ 1 ] ) )
            word = "not set";
         else
            word = args[ 1 ];
         printf( "   title: %s\n", word );
         if ( !stringp( args[ 2 ] ) )
            word = "not set";
         else
            word = args[ 2 ];
         printf( "   story: %s\n\n", word );
         break;
      case 'E' :
      case 'e' :
         printf( "Editing the text file...\n"
               "The log will show that you edited this file; if you "
               "ruin it,\nyou will be hunted down and eviscerated.\n" );
         this_player()->do_edit( read_file( TEXTS_DIR +
               replace( names[ which ], " ", "_" ) +".txt" ),
               "end_edit" );
         return;
      case 'F' :
      case 'f' :
         if ( strlen( word ) < 3 ) {
            printf( "Syntax: F <word>\n" );
            break;
         }
         word = word[ 2 .. ];
         number = 0;
         foreach ( name in ( names[ which + 1 .. ] + names[ 0 .. which ] ) ) {
            which = ( which + 1 ) % sizeof( names );
            if ( strsrch( name, word ) != -1 ) {
               print_info( which );
               number = 1;
               break;
            }
            if ( strsrch( lower_case( (string)QUEST_HANDLER->
                  query_quest_title( name ) ), word ) != -1 ) {
               print_info( which );
               number = 1;
               break;
            }
            if ( strsrch( lower_case( (string)QUEST_HANDLER->
                  query_quest_story( name ) ), word ) != -1 ) {
               print_info( which );
               number = 1;
               break;
            }
         }
         if ( !number )
            printf( "\""+ word +"\" not found.\n" );
         break;
      case 'H' :
      case 'h' :
         printf( "\nQuest editor commands:\n\n"
               "Q          : quit the quest editor\n"
               "N          : go to the next quest\n"
               "P          : go to the previous quest\n"
               "G <number> : go to a particular quest by number\n"
               "A          : toggle a quests active/inactive flag\n"
               "C <quest>  : create a new quest\n"
               "L <level>  : set a new quest's level\n"
               "T <title>  : set a new quest's title\n"
               "S <story>  : set a new quest's story\n"
               "R          : review the new quest's data\n"
               "E          : edit the quest's text file\n"
               "F <word>   : find the next quest using that word\n"
               "H          : get this list of commands\n\n"
               "To create a new quest, set the level, title and \n"
               "story first, then use C to create the quest with \n"
               "the title that creators will see.\n\n"
               "No command will reprint the current quest.\n\n" );
         break;
      default :
         print_info( which );
   }
   makers[ this_player() ] = ({ which, args });
   printf( "Choose one of Q, N, P, G, C, L, T, S, R, E, F or H (for help) : " );
   input_to( "main_menu" );
}
void end_edit( string text ) {
   string name;
   if ( !text || ( text == "" ) ) {
      printf( "Aborted.\n" );
      main_menu( "Z" );
      return;
   }
   if ( text[ <1 ] != '\n' )
      text += "\n";
   name = names[ makers[ this_player() ][ 0 ] ];
   log_file( "QUESTS", ctime( time() ) +" "+
         (string)this_player()->query_name() +
         " changed text file for "+ name +"\n" );
   printf( "Writing file...\n" );
   unguarded( (: write_file, TEXTS_DIR + replace( name, " ", "_" ) +
         ".txt", text, 1 :) );
   main_menu( "Z" );
}
private int cmd() {
   names = (string *)QUEST_HANDLER->query_quest_names();
   makers[ this_player() ] = ({ 0, allocate( 3 ) });
   main_menu( "G 1" );
   return 1;
}
public mixed *query_patterns() {
    return ({ "", (: cmd() :) });
}

==================================================
FILE: lord/resetpw.c
==================================================

#include <parser.h>
#include <liaison.h>
#include <player_handler.h>
inherit "/cmds/base";
string basename;
string file;
int do_reset(string player, string newpw) {
  string password;
  string *bits, t1, t2;
  int i;
  if(base_name(previous_object())[0..12] != "/secure/login" &&
     base_name(previous_object())[0..13] != "/secure/nlogin") {
    if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
                 ": illegal attempt to reset password.\nTrace: " + back_trace()
                 :));
      return 0;
    }
    if (!master()->high_programmer(previous_object(-1)) &&
        !(master()->query_director(previous_object(-1)) &&
          this_player(1)->query_name() == "/d/liaison/master"->query_lord())) {
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
                 ": illegal attempt to reset password.\nTrace: " + back_trace()
                 :));
      return 0;
    }
  }
  seteuid("Root");
  if (PLAYER_HANDLER->test_user(player)) {
    basename = "/save/ramdisk/players/" + player[0..0] + "/" + player;
    if(file_size(basename+".o.gz")>0 ||
       file_size(basename+".o")>0) {
      unguarded((: uncompress_file(basename+".o.gz") :));
    } else {
      basename = "/save/players/" + player[0..0] + "/" + player;
      if(file_size(basename+".o.gz")>0 ||
         file_size(basename + ".o") > 0) {
        unguarded((: uncompress_file(basename+".o.gz") :));
      } else {
        basename = "/save/players/delete/" + player;
        if(file_size(basename+".o.gz")>0) {
          unguarded((: uncompress_file(basename+".o.gz") :));
        }
      }
    }
    file = unguarded( (: read_file(basename + ".o") :));
    if(!file) {
      write("Error reading file " + basename + ".\n");
      return notify_fail("Error reading file " + basename +".o\n");
    }
    bits = explode(file, "\n");
    for (i = 0; i < sizeof(bits); i++) {
      if (bits[i][0..strlen("password")-1] == "password") {
        t1 = bits[i];
        password = restore_variable(bits[i][strlen("password") + 1..]);
        break;
      }
    }
    password = crypt(newpw, newpw[0..1]);
    t2 = "password " + save_variable(password);
    file = replace(file, t1, t2);
    unguarded( (: rm(basename + ".old") :) );
    unguarded( (: rename(basename+".o", basename+".old") :) );
    unguarded( (: write_file(basename + ".o", file) :));
    unguarded( (: compress_file(basename+".o") :));
    PLAYER_HANDLER->remove_cache_entry(player);
    return 1;
  }
  return 0;
}
mixed cmd(string player, string newpw) {
  if(!newpw || newpw == "")
    return notify_fail("Syntax: resetpw <player> <new password>\n");
  if(do_reset(player, newpw)) {
    write(sprintf("Reset password for %s to %s\n", player, newpw));
  } else {
    write("Unable to find player "+player+".\n");
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<word> <string>", (: cmd($4[0], $4[1]) :),
            });
}

==================================================
FILE: lord/rmdirector.c
==================================================

#include <parser.h>
#include <player_handler.h>
inherit "/cmds/base";
mixed cmd(string creator) {
  seteuid("Root");
  if ( !PLAYER_HANDLER->test_user( creator ) ||
       !"/secure/master"->query_trustee( previous_object( -1 ) ) )
    return notify_fail("You must be a trustee to remove a director.\n");
  if("/secure/master"->remove_director(creator)) {
    write(creator + " removed from directorship.\n");
    return 1;
  } else
    return notify_fail("Call to remove_director failed.\n");
}
mixed *query_patterns() {
  return ({ "<string>", (: cmd($4[0]) :), });
}

==================================================
FILE: lord/rms_enior.c
==================================================

#include <parser.h>
#include <player_handler.h>
inherit "/cmds/base";
mixed cmd(string creator) {
  seteuid("Root");
  if ( !PLAYER_HANDLER->test_user( creator ) ||
       !"/secure/master"->query_lord( previous_object( -1 ) ) )
    return notify_fail("You must be a lord to remove a senior creator.\n");
  if("/secure/master"->remove_senior(creator)) {
    write(creator + " removed from senior.\n");
    return 1;
  } else
    return notify_fail("Call to remove_senior failed.\n");
}
mixed *query_patterns() {
  return ({ "<string>", (: cmd($4[0]) :), });
}

==================================================
FILE: lord/rstats.c
==================================================

inherit "/cmds/base";
int cmd(string str) {
  mapping stats;
  string obj, file;
  int total, num;
  stats = "/secure/master"->query_read_stats();
  if(str) {
    if(!stats[str])
      return notify_fail("No such file\n");
    foreach(file in keys(stats[str])) {
      if(stats[str][file] > 1)
        printf("%-60s %5d\n", file, stats[str][file]);
    }
    return 1;
  }
  printf("%-60s %5s %5s\n", "Object", "Total", "Files");
  foreach(obj in keys(stats)) {
    total = 0;
    num = 0;
    foreach(file in keys(stats[obj])) {
      num++;
      total += stats[obj][file];
    }
    if(total > 200)
      printf("%-60s %5d %5d\n", obj, total, num);
  }
  return 1;
}

==================================================
FILE: lord/site.c
==================================================

#include <parser.h>
#include <access.h>
inherit "/cmds/base";
mixed cmd(string address, string level, string reason) {
   seteuid("Root");
   if (this_player() != this_player(1))
      return 0;
   switch(level) {
   case "nonew":
      level = "2";
      break;
   case "noacccess":
      level = "3";
      break;
   case "authnew":
     level = "4";
     break;
   case "normal":
      level = "1";
      break;
   }
   address = replace(address, ".*", "");
   if (!"/secure/bastards"->change_access(address, to_int(level), reason)) {
     write("Error changing permissions.\n");
     return 0;
   }
   write("Access permisions changed.\n");
   printf("Site %s set to %s for %s\n", address, PERM_NAMES[to_int(level)],
          reason);
   return 1;
}
int access(string filter) {
  string addr, ret;
  mapping list;
  int found;
  seteuid("Root");
  if (this_player() != this_player(1))
    return 0;
  list = "/secure/bastards"->query_all_access();
  ret = "";
  foreach(addr in keys(list)) {
    if(!filter || filter == "" || strsrch(addr, filter) != -1) {
      found = 1;
      ret += sprintf("%-20s %-18s %-=39s\n", addr,
                     PERM_NAMES[list[addr][ACCESS_LEVEL]],
                     list[addr][ACCESS_REASON]);
    }
  }
  if (!found)
    return notify_fail("No access control defined.\n");
  write("Current access list:\n");
  this_player()->more_string(ret, "site access");
  return 1;
}
int multi(int allow, string address) {
  if("/secure/bastards"->change_multi(address, allow, 0)) {
    if(allow)
      write("Site " + address + " has been permitted for multiplayers.\n");
    else
      write("Site " + address + " has been blocked for multiplayers.\n");
  } else
    write("Error multiplayer settings for site " + address + ".\n");
  return 1;
}
int list_multi(string filter) {
  string addr, ret;
  mapping list;
  int found;
  list = "/secure/bastards"->query_all_multi();
  ret = "";
  foreach(addr in keys(list)) {
    if(!filter || filter == "" || strsrch(addr, filter) != -1) {
      found = 1;
      ret += sprintf("%-30s\n", addr);
    }
  }
  if (!found)
    return notify_fail("No access control defined.\n");
  write("Current multuser site list:\n");
  this_player()->more_string(ret, "site access");
  return 1;
}
int help() {
   return notify_fail(
      "Syntax: site access\n"+
      "            site ban <ip number|site name> <level> <reason>\n"+
      "                     <level> := normal normal access,\n"+
      "                                nonew no new players, \n"+
      "                                authnew authorised new players\n"+
      "                                noaccess no access.\n");
}
mixed *query_patterns() {
   return ({ "ban <word'address'> <word'level'> <string'reason'>",
               (: cmd($4[0], $4[1], implode($4[2..], "")) :),
               "allow multi <word'address'>",
               (: multi(1, $4[0]) :),
               "disallow multi <word'address'>",
               (: multi(0, $4[0]) :),
               "list multi", (: list_multi("") :),
               "list multi <word'address'>", (: list_multi($4[0]) :),
               "access <word'address'>", (: access($4[0]) :),
               "access", (: access("") :),
               "", (: help() :),
               "help", (: help() :)
               });
}

==================================================
FILE: lord/tmstats.c
==================================================

inherit "/cmds/base";
#include <tasks.h>
#define STATS_DIR "/save/tasks/"
#define DIVISOR 100
int do_summary();
int cmd(string str) {
  string file, cmd, tmp;
  mapping awards, summary, obs;
  int lvl, i, total, files;
  return do_summary();
  if(!str)
    str="";
  tmp = "";
  obs = ([ ]);
  summary = ([ ]);
  foreach(file in get_dir(STATS_DIR+str+"*")) {
    file = file[0..sizeof(file)-3];
    files++;
    awards = TASKER->query_stats(file);
    foreach(lvl in keys(awards)) {
      foreach(cmd in keys(awards[lvl])) {
        total += awards[lvl][cmd];
        obs[cmd] += 1;
      }
    }
  }
  foreach(cmd in keys(obs)) {
    if(obs[cmd] > 100)
      i += 1;
  }
  printf("%s: Skills: %d, Total: %d: Ratio: %d, Objects: %d, "
         "Obs over 100: %d\n",
         str, files, total, total/files, sizeof(keys(obs)), i);
  return 1;
}
int do_summary() {
  string skill;
  mapping sum, stats;
  int i;
  int tries, awards;
  stats = TASKER->query_stats("summary");
  sum = stats;
  foreach(skill in keys(sum)) {
    if("/std/skills"->query_skill(({ skill })) != skill)
      continue;
    printf("Skill: %s \n", skill);
    printf("  Level 0..49:       Tries: %d, Awards: %d, ",
           sum[skill][0][0], sum[skill][0][1]);
    if(sum[skill][0][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][0][0]/(sum[skill][0][1]));
    printf("  Level 50..149:     Tries: %d, Awards: %d, ",
           sum[skill][1][0], sum[skill][1][1]);
    if(sum[skill][1][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][1][0]/(sum[skill][1][1]));
    printf("  Level 150..299:    Tries: %d, Awards: %d, ",
           sum[skill][2][0], sum[skill][2][1]);
    if(sum[skill][2][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][2][0]/(sum[skill][2][1]));
    printf("  Level 300..599:    Tries: %d, Awards: %d, ",
           sum[skill][3][0], sum[skill][3][1]);
    if(sum[skill][3][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][3][0]/(sum[skill][3][1]));
    printf("  Level >= 600:      Tries: %d, Awards: %d, ",
           sum[skill][4][0], sum[skill][4][1]);
    if(sum[skill][4][1] == 0)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", sum[skill][4][0]/(sum[skill][4][1]));
    tries = 0;
    awards = 0;
    for(i=0; i<3; i++) {
      tries += sum[skill][i][0];
      awards += sum[skill][i][1];
    }
    printf("  Total:              Tries: %d, Awards: %d, ", tries, awards);
    if(!awards)
      printf("Ratio: ?\n");
    else
      printf("Ratio: 1/%d\n", tries/awards);
  }
  return 1;
}

==================================================
FILE: lord/wstats.c
==================================================

inherit "/cmds/base";
int cmd(string str) {
  mapping stats;
  string obj, file;
  int total, num;
  stats = "/secure/master"->query_write_stats();
  if(str) {
    if(!stats[str])
      return notify_fail("No such file\n");
    foreach(file in keys(stats[str])) {
      if(stats[str][file] > 1)
        printf("%-60s %5d\n", file, stats[str][file]);
    }
    return 1;
  }
  printf("%-60s %5s %5s\n", "Object", "Total", "Files");
  foreach(obj in keys(stats)) {
    total = 0;
    num = 0;
    foreach(file in keys(stats[obj])) {
      num++;
      total += stats[obj][file];
    }
        if(total > 50)
      printf("%-60s %5d %5d\n", obj, total, num);
  }
  return 1;
}

==================================================
FILE: player/accept.c
==================================================

#include <clubs.h>
#include <broadcaster.h>
inherit "/cmds/base";
mixed do_surrender(object player) {
  object *victims;
  victims = this_player()->query_surrenderers();
  if (!victims  ||  member_array(player, victims) == -1) {
    add_failed_mess("Sorry, but $I has not offered to surrender to you.\n",
                    ({ player }) );
    return 0;
  }
  this_player()->remove_surrenderer(player);
  player->accepted_surrender(this_player());
  write("Good show!\n");
  return 1;
}
mixed do_club(string club_name, object *players) {
   object ob;
   string club;
   int ok;
   foreach (ob in players) {
      club = this_player()->query_respond_command(CLUB_RESPOND_TYPE, ob);
      if (club) {
         if (lower_case(club) == lower_case(club_name)) {
            if (CLUB_HANDLER->is_member_of(club_name,
                                           this_player()->query_name())) {
               add_failed_mess("You are already a member of '" +
                               CLUB_HANDLER->query_club_name(club_name) +
                               "'.\n");
            } else {
               CLUB_HANDLER->add_member(club_name,
                                        this_player()->query_name());
               add_succeeded_mess("$N join$s '" +
                               CLUB_HANDLER->query_club_name(club_name) +
                               "' with an invite from $I.\n",
                               ({ ob }) );
	       ob->remove_respond_command(CLUB_RESPOND_TYPE, ob);
               ok++;
               all_inventory(this_player())->event_joined_club(this_player(),
                                                               club_name);
            }
         } else {
            add_failed_mess("$I is inviting you to join '" +
                            CLUB_HANDLER->query_club_name(club) +
                            "' not '" + club_name + "'.\n", ({ ob }));
         }
      } else {
         add_failed_mess("$I is not inviting you to join any clubs.\n",
                         ({ ob }));
      }
   }
   return ok;
}
int do_family(string family,
              string relationship,
              object *players) {
   object ob;
   int ok;
   string curr_family;
   class family_response_data frog;
   curr_family = this_player()->query_family_name();
   if (curr_family) {
      curr_family = CLUB_HANDLER->query_club_name(curr_family);
   }
   relationship = CLUB_HANDLER->query_ungendered_relationship(relationship);
   if (!relationship) {
      add_failed_mess("Could not figure out the relationship.\n");
      return 0;
   }
   foreach (ob in players) {
      frog = this_player()->query_respond_command(CLUB_FAMILY_RESPOND_TYPE,
                                                  ob);
      if (!family) {
         family = frog->family;
      }
      if (frog && frog->family) {
         if (lower_case(frog->family) == lower_case(family)) {
  	    if (lower_case(frog->relationship) != lower_case(relationship)) {
               add_failed_mess("You were asked to have the relationship of '" +
                     CLUB_HANDLER->query_relationship_gender(frog->relationship,
                                     this_player()->query_female()) +
                               "', not '" +
                     CLUB_HANDLER->query_relationship_gender(relationship,
                                     this_player()->query_female()) +
                               "' in the family '" +
                               CLUB_HANDLER->query_club_name(frog->family) +
                               "'.\n");
	    } else if (CLUB_HANDLER->is_relationship(frog->family,
                                                     this_player()->query_name(),
                                                     ob->query_name(),
                                                     relationship) &&
                       frog->family == curr_family) {
               add_failed_mess("You have already setup a relationship of '" +
                     CLUB_HANDLER->query_relationship_gender(relationship,
                                     this_player()->query_female()) +
                               "' with $I.\n", ({ ob }) );
            } else {
               if (!CLUB_HANDLER->is_member_of(frog->family,
                                               this_player()->query_name())) {
                  if (frog->family != curr_family &&
                      curr_family) {
                     if (!CLUB_HANDLER->move_family_member(curr_family,
                                                           this_player()->query_name(),
                                                           frog->family)) {
                       add_failed_mess("Unable to move you into the family " +
                                       frog->family + " for some reason.\n");
                       continue;
                     }
                  } else {
                     if (!CLUB_HANDLER->add_member(frog->family,
                                                  this_player()->query_name())){
                       add_failed_mess("Unable to add you into the family " +
                                       frog->family + " for some reason.\n");
                       continue;
                     }
                  }
                  this_player()->set_family_name(frog->family);
               }
	       if (!CLUB_HANDLER->is_relationship(frog->family,
                                                  this_player()->query_name(),
                                                  ob->query_name(),
                                                  relationship)) {
                  if (!CLUB_HANDLER->add_relationship(ob->query_family_name(),
                                                     ob->query_name(),
                                                     frog->family,
                                                     this_player()->query_name(),
                                                     relationship)) {
                     add_failed_mess("Unable to add the relationship to $I for "
                                     "some reason.\n");
                  } else {
                     add_succeeded_mess("$N set$s up a relationship with $I " +
                                        "in '" +
                                        CLUB_HANDLER->query_club_name(frog->family) +
                                        "'.\n",
                                        ({ ob }) );
                     ok++;
                  }
               } else {
                  add_succeeded_mess("$N set$s up a relationship with $I " +
                                     "in '" +
                                     CLUB_HANDLER->query_club_name(frog->family) +
                                     "'.\n",
                                     ({ ob }) );
                  ok++;
               }
               ob->remove_respond_command(CLUB_FAMILY_RESPOND_TYPE, ob);
            }
         } else {
            add_failed_mess("$I is inviting you to a relationship in '" +
                            CLUB_HANDLER->query_club_name(frog->family) +
                            "' not '" + family + "'.\n", ({ ob }));
         }
      } else {
         add_failed_mess("$I is not inviting you to setup any relationships.\n",
                         ({ ob }));
      }
   }
   return ok;
}
mixed *query_patterns() {
  return ({ "<indirect:living:here>", (: do_surrender($1[0]) :),
            "invite from <indirect:living:here> to <string'club name'>",
                (: do_club($4[1], $1) :),
            "relationship from <indirect:living:here> to <string'family'> as <string'relationship'>",
                (: do_family($4[1], $4[2], $1) :),
            "relationship from <indirect:living:here> as <string'relationship'>",
	       (: do_family(this_player()->query_family_name(), $4[1], $1) :) });
}

==================================================
FILE: player/access.c
==================================================

#include <drinks.h>
#include <language.h>
#include <player.h>
#include <player_handler.h>
#define TP this_player()
inherit "/cmds/base";
int cmd_list() {
   string *ips;
   ips = TP->query_rhosts();
   if(!ips) {
      ips = ({ });
   }
   if ( !sizeof(ips) )  {
     write( "You are allowed to login from anywhere.\n" );
   } else  {
     ips = sort_array(ips, 1);
     write( "You are currently allowed to login from: " +
            query_multiple_short(ips) + ".\n" );
   }
   return 1;
}
int enable( string str) {
   string *ips;
   if(TP->query_property("access_restricted"))
     return notify_fail("Sorry, you are not allowed to change your "
                        "access list.\n");
   ips = TP->query_rhosts();
   if(!ips) {
      ips = ({ });
   }
   if(member_array(str, ips) == -1 )  {
     ips += ({ str });
     TP->set_rhosts(ips);
   } else  {
     write( "You are already allowed to login from  " + str + ".\n" );
   }
   write("You are now allowed to login from "+str+".\n");
   return 1;
}
int disable( string str) {
   string *ips;
   if(TP->query_property("access_restricted"))
     return notify_fail("Sorry, you are not allowed to change your "
                        "access list.\n");
   ips = TP->query_rhosts();
   if(!ips) {
      ips = ({ });
   }
   if ( member_array( str, ips ) != -1 )  {
     ips -= ({ str });
     if(!sizeof(ips))
       TP->set_rhosts(0);
     else
       TP->set_rhosts(ips);
   } else  {
     write( "You are already not allowed to login from  " + str + ".\n" );
   }
   if(!sizeof(ips))
     write("You are now allowed to login from anywhere.\n");
   else
     write("You are not now allowed to login from "+str+".\n");
   return 1;
}
int authorise_for (string name, string address) {
  string fname;
  string file,  *bits;
  string var_name = "player_info ";
  mapping info = ([ ]);
  int i, found = 0;
  if (!this_player()->query_lord()) {
    return notify_fail ("You may not do this.\n");
  }
  if (find_player (name)) {
    return notify_fail ("This player is online.\n");
  }
  if (!PLAYER_HANDLER->test_user(name)) {
    return notify_fail ("No such player.\n");
  }
  seteuid("Root");
  fname = "/save/players/" + name[0..0] + "/" + name;
  uncompress_file (fname+ ".o.gz");
  file = unguarded( (: read_file($(fname)+".o") :));
  if (!file) {
    return notify_fail ("Error reading file.\n");
  }
   bits = explode(file, "\n");
   for (i = 0; i < sizeof(bits); i++) {
     if (bits[i][0..strlen(var_name)-1] == var_name) {
       info = restore_variable(bits[i][strlen(var_name)..]);
       found = 1;
       break;
     }
   }
  if(!found) {
    return notify_fail ("Cannot find mapping.\n");
  }
  if (address == "reset") {
    info["allowed_ips"] = ({ });
  }
  else if (sizeof (info ["allowed_ips"])) {
    if (member_array (address, info["allowed_ips"]) == -1) {
      info["allowed_ips"] += ({ address });
    }
  }
  else {
    info["allowed_ips"] = ({ address });
  }
  if (i < sizeof(bits)) {
     bits[i] = var_name + save_variable(info);
   } else {
     bits += ({ var_name + save_variable(info) });
  }
  unguarded( (: rm($(fname) + ".old") :) );
  unguarded( (: rename($(fname)+".o", $(fname)+".old") :) );
  unguarded( (: write_file($(fname) + ".o",
    implode($(bits), "\n") + "\n") :));
  compress_file (fname + ".o");
  unguarded( (: rm($(fname) + ".o") :) );
  PLAYER_HANDLER->remove_cache_entry(name);
  tell_object (this_player(), "Access for " + name + " changed.\n");
  return 1;
}
mixed *query_patterns() {
  return ({ "enable <string'address'>", (: enable($4[0]) :),
              "disable <string'address'>", (: disable($4[0]) :),
              "for <string'name'> <string'address'>",
                (: authorise_for ($4[0], $4[1]) :),
              "reset for <string'name'>", (: authorise_for ($4[0],
              "reset") :),
              "", (: cmd_list() :) });
}

==================================================
FILE: player/al_ias.c
==================================================

#include <alias.h>
inherit "/cmds/base";
private nosave string gfilter;
string alias_string(mixed *al) {
   int i;
   int num;
   int *add_thing;
   string str;
   str = "";
   add_thing = ({ });
   for (i=0;i<sizeof(al);i++) {
      if (stringp(al[i])) {
         str += replace(al[i], ({";", "\\;"}));
      } else {
         num = al[i] & ALIAS_MASK;
         switch (al[i] - num) {
         case NEW_LINE  :
            str += ";";
            break;
         case ALL_ARGS  :
            str += "$*$";
            break;
         case ONE_ARG   :
            str += "$"+num+"$";
            break;
         case TO_ARG    :
            str += "$*"+num+"$";
            break;
         case FROM_ARG  :
            str += "$"+num+"*$";
            break;
         case ALL_ARG   :
            str += "$arg:"+al[++i]+"$";
            break;
         case ARG_THING :
            str += "$arg"+num+":"+al[++i]+"$";
            break;
         case ELSE_THING :
           str += "$else$";
           break;
         case ALL_IFARG :
            str += "$ifarg:";
            break;
         case IFARG_THING :
            str += "$ifarg"+num+":";
            break;
         case CURR_LOC :
            str += "$!$";
            break;
         case END_IF      :
            str += "$endif$";
            break;
         }
      }
   }
   return str;
}
int print_aliases(string filter, int sorted) {
   int i;
   int len;
   string str;
   string str1;
   string str2;
   string *tmp;
   string bing;
   mapping aliases;
   string ret;
   aliases = this_player()->query_aliases();
   if (!m_sizeof(aliases)) {
      notify_fail("None defined.\n");
      return 0;
   }
   str1 = "";
   str2 = "";
   tmp = m_indices(aliases);
   if (filter) {
      if (regexp(filter,
           "[\\[\\]\\(\\)\\*\\?\\+][\\[\\]\\(\\)\\*\\?\\+]+") ) {
         add_failed_mess("Bad pattern to alias.\n");
         return 0;
      }
      if (filter[0] == '*' || filter[0] == '+') {
         add_failed_mess("Cannot start a regular expression with a '*' or '+', "
                         "try: '.*' or '.+'.\n");
         return 0;
      }
      gfilter = "^" + filter;
      if (catch(tmp = filter_array(tmp, (: $1 && regexp($1, gfilter) :)))) {
         add_failed_mess("Bad pattern to alias (mismatched brackets?).\n");
         return 0;
      }
   }
   tmp = sort_array(tmp, 1);
   ret = "You currently have the following aliases:\n";
   for (i = 0; i < sizeof(tmp); i++) {
      if (!tmp[i]) {
         map_delete(aliases, 0);
         continue;
      }
      bing = alias_string(aliases[tmp[i]]);
      if (!bing) {
         bing = "Error in the alias!";
      }
      if (!tmp[i]) {
         tmp[i] = "icky";
      }
      if (strsrch(bing, "%^") != -1) {
         bing = replace_string(bing, "%^", "% ^");
         tmp[i] += " (colour replace)";
      }
      str = tmp[i] + ": " + bing;
      if (strlen(str) > 39 || sorted) {
         len = this_player()->query_cols() - strlen(tmp[i]) - 2;
         if (len < 0) {
            len = 10;
         }
         ret += sprintf("%s: %-=*s\n", tmp[i], len, bing);
      } else if (strlen(str) > 19) {
         str1 += str+"\n";
      } else {
         str2 += str+"\n";
      }
   }
   if (strlen(str1)) {
      ret += sprintf("%-#*s\n", this_player()->query_cols(), str1);
   }
   if (strlen(str2)) {
      ret += sprintf("%-#*s\n", this_player()->query_cols(), str2);
   }
   ret += sprintf("A total of %d aliases.\n", sizeof(tmp));
   this_player()->more_string(ret);
   return 1;
}
mixed *compile_alias(string str) {
   mixed *ret;
   int i;
   int space;
   string *frog;
   string s1;
   int tmp;
   int gumby;
   int nodollar;
   int ending_dollar;
   mixed *ifargs;
   str = replace(str, ({ "\\;", "$escaped$", ";", "$new_line$", " ", " " }));
   str = replace(str, "$escaped$", ";");
   if(str[sizeof(str)-1] == '$')
     ending_dollar = 1;
   frog = explode("&" + str + "&", "$");
   if (frog[0] == "&") {
      frog[0] = "";
   } else {
      frog[ 0 ] = frog[ 0 ][ 1 .. ];
   }
   s1 = frog[<1];
   if (s1 == "&") {
      frog = frog[0..<2];
   } else {
      frog[<1] = s1[0..<2];
   }
   ret = ({ frog[0] });
   ifargs = ({ });
   nodollar = 1;
   for (i = 1; i < sizeof(frog); i++) {
      switch (frog[i]) {
      case "new_line" :
         ret += ({ NEW_LINE });
         nodollar = 1;
         break;
      case "*" :
         ret += ({ ALL_ARGS });
         gumby = 1;
         nodollar = 1;
         break;
      case "!" :
         if (this_object()->query_creator()) {
            ret += ({ CURR_LOC });
            nodollar = 1;
         }
         break;
      case "else" :
         if (sizeof(ifargs)) {
            ret[ifargs[sizeof(ifargs)-1]] = sizeof(ret) -
               ifargs[sizeof(ifargs)-1]+1;
            ret += ({ ELSE_THING, 0, "" });
            ifargs[sizeof(ifargs)-1] = sizeof(ret)-2;
            nodollar = 1;
         }
         break;
      case "~" :
      case "endif" :
         if (sizeof(ifargs)) {
            ret += ({ END_IF });
            ret[ifargs[sizeof(ifargs)-1]] = sizeof(ret)-
               ifargs[sizeof(ifargs)-1];
            ifargs = delete(ifargs, sizeof(ifargs)-1, 1);
            nodollar = 1;
            space = 1;
         }
         break;
      default :
         if (frog[i][0..4] == "ifarg") {
            if (sscanf(frog[i], "ifarg%d:%s", tmp, s1) == 2) {
               if (tmp < 0) {
                  tmp = 0;
               }
               if (tmp > ALIAS_MASK) {
                  tmp = ALIAS_MASK;
               }
               ret += ({ IFARG_THING+ tmp, 0, "" });
               frog[i--] = s1;
               nodollar = 1;
               ifargs += ({ sizeof(ret)-2 });
               space = 0;
               gumby = 1;
            } else if (frog[i][5] == ':') {
               ret += ({ ALL_IFARG, 0, "" });
               frog[i] = frog[i][6..];
               nodollar = 1;
               ifargs += ({ sizeof(ret)-2 });
               space = 0;
               gumby = 1;
               i--;
            } else {
               if (sizeof(ret) && stringp(ret[sizeof(ret)-1]) && !space) {
                  ret[sizeof(ret)-1] += "$"+frog[i];
               } else if (nodollar) {
                  ret += ({ frog[i] });
                  nodollar = 0;
               } else {
                  ret += ({ "$"+frog[i] });
               }
            }
         } else if (frog[i][0..2] == "arg") {
            if (sscanf(frog[i], "arg%d:%s", tmp, s1) == 2) {
               if (tmp < 0) {
                  tmp = 0;
               }
               if (tmp > ALIAS_MASK) {
                  tmp = ALIAS_MASK;
               }
               ret += ({ ARG_THING+ tmp, s1, "" });
               nodollar = 1;
               gumby = 1;
            } else if (frog[i][3] == ':') {
               ret += ({ ALL_ARG, frog[i][4..100], "" });
               nodollar = 1;
               gumby = 1;
            } else {
               if (sizeof(ret) && stringp(ret[sizeof(ret)-1]) && !space) {
                  ret[sizeof(ret)-1] += "$"+frog[i];
               } else if (nodollar) {
                  ret += ({ frog[i] });
                  nodollar = 0;
               } else {
                  ret += ({ "$"+frog[i] });
               }
               gumby = 1;
               space = 0;
            }
         } else if (strlen(frog[i]) && frog[i][<1] == '*' &&
                    sscanf(frog[i], "%d%s*", tmp, s1) == 2 && s1 == "") {
            if (tmp < 0) {
               tmp = 0;
            }
            if (tmp > ALIAS_MASK) {
               tmp = ALIAS_MASK;
            }
            ret += ({ FROM_ARG + tmp });
            gumby = 1;
            nodollar = 1;
         } else if (strlen(frog[i]) && frog[i][0] == '*' &&
                    sscanf(frog[i][1..], "%d%s", tmp,s1) == 2 && s1 == "") {
           if (tmp < 0) {
             tmp = 0;
           }
           if (tmp > ALIAS_MASK) {
             tmp = ALIAS_MASK;
           }
           ret += ({ TO_ARG + tmp });
           gumby = 1;
           nodollar = 1;
         } else if (sscanf(frog[i], "%d%s", tmp, s1) == 2 && s1 == "" &&
                    (i < sizeof(frog)-1 || ending_dollar)) {
           if (tmp < 0) {
             tmp = 0;
           }
           if (tmp > ALIAS_MASK) {
             tmp = ALIAS_MASK;
           }
           ret += ({ ONE_ARG + tmp });
           gumby = 1;
           nodollar = 1;
         } else {
            if (!nodollar) {
               frog[i] = "$"+frog[i];
            }
            nodollar = 0;
            space = 0;
            if (strlen(frog[i]) && frog[i][<1] == '~') {
               if (sizeof(ifargs)) {
                  if (strlen(frog[i]) == 1) {
                     frog[i] = "";
                  } else {
                     frog[i] = frog[i][0..<2];
                  }
                  ret += ({ END_IF });
                  ret[ifargs[<1]] = sizeof(ret) - ifargs[<1];
                  ifargs = ifargs[0..<2];
                  nodollar = 1;
                  space = 1;
               }
            }
            if (sizeof(ret) && stringp(ret[<1]) && space != 2) {
               ret[<1] += frog[i];
            } else {
               ret += ({ frog[i] });
            }
            if (space) {
               space = 2;
            }
         }
      }
   }
   while (sizeof(ifargs)) {
      ret += ({ END_IF });
      ret[ifargs[sizeof(ifargs)-1]] = sizeof(ret)-
         ifargs[sizeof(ifargs)-1];
      ifargs = delete(ifargs, sizeof(ifargs)-1, 1);
   }
   if (!gumby) {
      if (sizeof(ret) && !stringp(ret[sizeof(ret)-1]) || space) {
         ret += ({ " ", ALL_ARGS });
      } else if(sizeof(ret)) {
         ret[sizeof(ret)-1] += " ";
         ret += ({ ALL_ARGS });
      }
   }
   return ret;
}
int print_some_aliases(string str, int every) {
   if (this_player()->is_alias(str) && !every) {
      printf("%s: %-=*s\n", str,
                (int)this_player()->query_cols() - strlen(str) -2,
                alias_string(this_player()->query_player_alias(str)));
      return 1;
   }
   return print_aliases(str, 0);
}
protected int alias(string name, string value) {
#ifdef DISALLOW_COLOUR
   if (strsrch(name, "%^") >= 0 || strsrch(value, "%^") >= 0) {
      notify_fail("Cannot add an alias with a colour escape "
                  "sequence (% ^).\n");
      return 0;
   }
#endif
   if (strsrch(value, "END_ALIAS") != -1) {
      add_failed_mess("You cannot use 'END_ALIAS' in an alias.\n");
      return 0;
   }
   name = implode(explode(name, " "), "");
   if (name == "unalias" || name == "alias" || name == "ealias")  {
      add_failed_mess("You can't alias the '" + name + "' command, because "
                      "otherwise, there would be Problems.\n");
      return 0;
   }
   if (!this_player()->is_alias(name)) {
      this_player()->add_player_alias(name, compile_alias(value));
      write("Added alias '" + name + "'.\n");
   } else {
      this_player()->add_player_alias(name, compile_alias(value));
      write("Changed alias '" + name + "'.\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({
         "", (: print_aliases("", 0) :),
         "sorted", (: print_aliases("", 1) :),
         "every <word'alias'>", (: print_some_aliases($4[0], 1) :),
         "<word'alias'>", (: print_some_aliases($4[0], 0) :),
         "<word'alias'> <string>", (: alias($4[0], $4[1]) :)
         });
}

==================================================
FILE: player/apply.c
==================================================

#include <applications.h>
#include <board.h>
#include <playerinfo.h>
#include <mail.h>
#include <player.h>
inherit "/cmds/base";
varargs void begin_application (object, string, string);
class applying_player {
   int step;
   object player;
   string domain;
   string next_method;
   string type;
   string *questions;
   string *answers;
}
class vouch_info {
  string applicant;
  string voucher;
  string position;
}
void create() {
  seteuid (geteuid());
}
int do_creator_apply(string domain, string type) {
  int temp;
  if (!domain) {
    domain = type;
  }
  if( this_player()->query_property( "guest" ) ) {
    write( "Only people with permanent characters are allowed to "
      "become Creators.\n" );
    return 1;
  }
  temp = APPLICATIONS_HANDLER->query_applications_accepted( domain );
  if( temp == -1 ) {
    this_player()->add_failed_mess( this_object(), "The domain " +
       domain + " is not a valid domain.\n" );
    return 0;
  }
  if( temp == 0 ) {
    this_player()->add_failed_mess (this_object(), "The domain " +
    domain + " is not currently open for applications.\n");
    return 0;
  }
  if( !APPLICATIONS_HANDLER->valid_application (this_player()->query_name(),
    type ) && !this_player()->query_lord() ) {
      write( "Sorry, you have not fulfilled the requirements yet.\n" );
      return 1;
  }
  if (domain == "liaison") {
    type = "liaison";
  }
  if (strsrch (domain, "playtester") != -1) {
    type = "playtester";
  }
  begin_application (this_player(), type, domain);
  return 1;
}
void confirm (string message,  class applying_player tmp) {
  if (!message || !sizeof (message) || strsrch (message, "no") != -1
    || strsrch (message, "n") != -1) {
    return;
  }
  else {
    call_other (this_object(), tmp->next_method, tmp->player, tmp);
  }
}
string query_application_info (string domain) {
  string ret;
  if( file_size( "/d/" + domain + "/application.txt" ) != -1 ) {
    ret = read_file( "/d/" + domain + "/application.txt" );
  }
  return ret;
}
varargs void begin_application (object player, string type, string domain) {
  class applying_player tmp;
  string ret = APPLICATIONS_HANDLER->query_intro_text (type);
  if( file_size( "/d/" + domain + "/application.txt" ) != -1 ) {
      ret += "\nPlease read the following information about applying to "
             "$C$" + domain + ": \n\n" ;
      ret += query_application_info (domain);
   }
  tell_object (this_player(), ret + "\n");
  tmp = new (class applying_player);
  tmp->type = type;
  tmp->domain = domain;
  tmp->answers = ({ });
  tmp->step = 1;
  tmp->next_method = "do_questions";
  tmp->player = player;
  tell_object (player, "Do you wish to continue your application?\n");
  this_player()->do_edit( "", "confirm", this_object(), 0,
    tmp);
}
varargs void do_questions (object player, class applying_player tmp) {
  if (tmp->step == 1) {
    tmp->questions = APPLICATIONS_HANDLER->query_questions (tmp->type);
  }
  tell_object (player, "%^BOLD%^" + tmp->questions[0]
    + "%^RESET%^\n");
  this_player()->do_edit( "", "start_asking", this_object(), 0,
    tmp);
}
void start_asking(string message, class applying_player tmp) {
  object player = tmp->player;
  if (!message || sizeof (message) == 0) {
    tell_object (player, "Your application has been aborted.\n");
    return;
  }
  tmp->answers += ({ message });
  if (tmp->step == sizeof (tmp->questions)) {
    tell_object (player, "Do you wish to submit your application?\n");
    tmp->next_method = "submit_application";
    this_player()->do_edit( "", "confirm", this_object(), 0,
      tmp);
    return;
  }
  tell_object (player, "%^BOLD%^" + tmp->questions[tmp->step]
    + "%^RESET%^\n");
  tmp->step += 1;
  this_player()->do_edit( "", "start_asking", this_object(), 0,
    tmp);
}
void submit_application (object player, class applying_player tmp) {
  int i;
  string *text = ({ });
  for (int j = 0; j < sizeof (tmp->questions); j++) {
    text += ({ "%^CYAN%^" +sprintf( "%2d) %-=*s", ( j + 1), 70,
      tmp->questions[j] ) + "%^RESET%^\n" });
    text += ({ sprintf( "      %-=*s\n\n", 72, tmp->answers[j] )});
  }
  i = APPLICATIONS_HANDLER->add_application (tmp->type, player->query_name(),
    implode (text, "\n"), tmp->domain);
  if (!i) {
    tell_object (player, "Something has gone wrong!\n");
    return;
  }
  else {
    tell_object (player, "Thank you for your application... it has been "
      "placed in the handler ready for people to vouch.\n");
  }
}
int do_list_types() {
  string ret = "";
  string *types;
  types = APPLICATIONS_HANDLER->query_types();
  ret += "You can apply for the following positions with this command:\n\n";
  foreach (string t in types) {
    ret += t + "\n";
  }
  this_player()->more_string (ret);
  return 1;
}
int do_list_requirements(string type) {
  string ret = APPLICATIONS_HANDLER->application_requirements (type);
  this_player()->more_string (ret);
  return 1;
}
int domain_status() {
  mapping map = APPLICATIONS_HANDLER->query_domain_status();
  string ret = "";
  foreach (string s, int o in map) {
    ret += (o ? "%^BOLD%^%^CYAN%^" : "") + capitalize (s) + " is " +
           (o ? "open" : "closed") + "%^RESET%^ to "
      "applications and is managed by " +
      capitalize (APPLICATIONS_HANDLER->query_responsibility (s)) + ".\n";
  }
  write("$P$Domain Status$P$" + ret);
  return 1;
}
int do_list_questions (string type) {
  string *quest = APPLICATIONS_HANDLER->query_questions (type);
  tell_object (this_player(), "\n\nPlease take time to write your application.  "
     "Preferably, prepare an answer to each of these questions off-line "
     "and copy your response into the editor on the MUD if possible.  "
     "You will be asked these questions one-by-one during the application "
     "process, so you should answer each question thoroughly.  Remember, "
     "this is a formal application to a position of responsibility, so "
     "treat each question seriously.\n\n");
  this_player()->more_string (implode (quest, "\n\n"));
  return 1;
}
int do_vouch (string name, string position) {
  int i = APPLICATIONS_HANDLER->find_application (name, position);
  class vouch_info tmp;
  tmp = new (class vouch_info);
  if (i == -1) {
    write (capitalize (name) + " has not applied for a "
      + position + " position.\n");
    return 1;
  }
  tell_object (this_player(), "%^BOLD%^Why do you think " + capitalize (name)
    + " would be a suitable " + position + "? %^RESET%^");
  tmp->applicant = name;
  tmp->voucher = this_player()->query_name();
  tmp->position = position;
  this_player()->do_edit( "", "vouch_edit", this_object(), 0,
    tmp);
  return 1;
}
void vouch_edit(string message, class vouch_info tmp) {
  object ob;
  int i;
  string name = tmp->applicant;
  string position = tmp->position;
  ob = find_player (tmp->voucher);
  if (!sizeof (message) || message == "") {
    if (ob) {
      tell_object (ob, "Your vouch has been aborted.\n");
    }
  }
  else {
    i = APPLICATIONS_HANDLER->make_vouch (position, name, tmp->voucher, message);
    switch (i) {
      case 2:
        tell_object (ob, "You submit your vouch for " + capitalize (name)
          + " as a " + position + ".\n");
      break;
      case 1:
        tell_object (ob, "You resubmit your vouch for " + capitalize (name)
          + " as a " + position + ".\n");
      break;
      case 0:
        tell_object (ob, "You cannot submit a vouch for yourself.\n");
      break;
      case -1:
        tell_object (ob, "There is no application for " + capitalize (name) +
          " as a " + position + ".\n");
      break;
    }
  }
}
int do_delete_vouch (string name, string position) {
  int i = APPLICATIONS_HANDLER->delete_vouch (this_player()->query_name(),
    name, position);
  if (i) {
    tell_object (this_player(), "You delete your vouch for " +
      capitalize (name) + " as a " + position + ".\n");
  }
  else {
    tell_object (this_player(), "You have not vouched for " +
      capitalize (name) + " as a " + position + ".\n");
  }
  return 1;
}
int query_my_vouch (string name, string position) {
  string v = APPLICATIONS_HANDLER->query_vouch (position, name,
    this_player()->query_name());
  if (!v) {
    tell_object (this_player(), "There is no application for "
      + capitalize (name) + " as a " + position + ".\n");
  }
  else {
    tell_object (this_player(), v + "\n");
  }
  return 1;
}
int delete_application (string pos) {
  int i = APPLICATIONS_HANDLER->delete_application (pos,
    this_player()->query_name());
  if (!i) {
    tell_object (this_player(), "You have no pending applications for "
      "that position.\n");
  }
  else {
    tell_object (this_player(), "Your application has been deleted.\n");
  }
  return 1;
}
int do_register() {
   if ( this_player()->query_property( "guest" )==1 ) {
      write ( "You are a guest. Registering as a player killer is not an "
        "option for you.\n");
      log_file( "CHEAT", ctime(time()) +": "+
        this_player()->query_short()+
        " (" +query_ip_number(this_player()) + ") (a guest) tried to "
        "register as a player killer.\n");
      return 1;
   }
   if (this_player()->query_player_killer()) {
      add_failed_mess( "You already are a player killer, silly!\n" );
      return 0;
   }
   if (-this_player()->query_time_on() < PKER_MINIMUM_AGE) {
      add_failed_mess( "You are not old enough to be a player killer.  You "
        "must be " + (PKER_MINIMUM_AGE / (60 * 60 * 24)) + " days old to "
        "register as a player killer.\n");
      return 0;
   }
   if (this_player()->query_property(PKER_NOT_ALLOWED)) {
      write( "Due to previous abuses of the playerkiller system, you are "
         "not allowed to become a playerkiller.\n");
      log_file( "CHEAT", ctime(time()) +": "+
        this_player()->query_short()+ " (" +query_ip_number(this_player()) +
        ") (not allowed to be a pk) tried to register as a player "
        "killer.\n");
      return 1;
   }
   write( "%^BOLD%^%^YELLOW%^You are hereby registering yourself as "
          "a player killer.\n\n"
          "This means that you can attack and be attacked by other "
          "player killers.  Once you are a registered player killer, "
          "there is NO going back.  Please note, this is NOT a quest "
          "and you will NOT get any experience points from doing "
          "it.%^RESET%^\n");
   write( "Are you sure about this, (Y/N)?\n");
   input_to("register2");
   return 1;
}
void register2(string str)
{
   str = lower_case(str);
   if (!strlen(str) ||
       (str[0] != 'y' && str[0] != 'n' && str[0] != 'q')) {
      write("You need to type 'y' or 'n'.\n");
      write("Are you sure about this, (Y/N)? ");
      input_to("register2");
      return ;
   }
   if (str[0] == 'n' ||
       str[0] == 'q') {
      write("You have chosen not to register as a playerkiller at this "
         "time.  You may choose to register later if you wish.\n");
   } else {
      write("%^BOLD%^%^YELLOW%^You are now a playerkiller, ready to kill and be killed.%^RESET%^\n");
      this_player()->set_player_killer(1);
      PLAYERINFO_HANDLER->add_entry( this_player(),
        this_player()->query_name(), "misc",
        "Registered as a Player Killer." );
   }
}
int do_query_all_vouches() {
  mapping tmp = APPLICATIONS_HANDLER->query_vouches_for_all
    (this_player()->query_name());
  string *ret = ({ });
  string tmp2;
  if (!sizeof (tmp)) {
    this_player()->add_failed_mess (this_object(), "You have made no "
      "vouches for anyone.\n", ({ }));
    return 0;
  }
  foreach (string n, string v in tmp) {
    tmp2 = "$I$5=%^CYAN%^" + capitalize (n) + "%^RESET%^: " + v;
    ret += ({ tmp2 });
  }
  this_player()->more_string (implode (ret, "\n\n"));
  return 1;
}
private int do_list_applicants() {
  string ret;
  if (!this_player()->query_lord()) {
    return 0;
  }
  ret = APPLICATIONS_HANDLER->list_applications();
  this_player()->more_string (ret);
  return 1;
}
private int do_browse_app (string type, string name) {
  int i = APPLICATIONS_HANDLER->find_application (name, type);
  string ret;
  if (i == -1) {
    this_player()->add_failed_mess (this_object(), "There is no "
      +type + " application for " + name + ".\n", ({ }));
    return 0;
  }
  ret = APPLICATIONS_HANDLER->format_application (i);
  this_player()->more_string (ret);
  return 1;
}
int query_my_vouches (string position) {
  mapping i = APPLICATIONS_HANDLER->query_application_vouches
    (this_player()->query_name(), position);
  if (!i) {
    this_player()->add_failed_mess (this_object(), "You currently have no vouches "
      "for a " + position + " application.\n", ({ }));
    return 0;
  }
  else {
    tell_object (this_player(), "The following people have vouched for your " +
      position + " application:  " + query_multiple_short (map (keys (i),
        (: capitalize ($1) :))) + ".\n");
    return 1;
  }
}
mixed* query_patterns() {
   string t = "{" + implode (APPLICATIONS_HANDLER->query_types(), "|")
    + "}";
   mixed *tmp;
   tmp = ({
             "as creator in <word> domain", (: do_creator_apply($4[0], "creator") :),
             "as player killer", (: do_register() :),
             "as playtester", (: do_creator_apply("playtesters", "playtester") :),
             "as liaison", (: do_creator_apply(0, "liaison") :),
             "delete my application as <word'position'>",
              (: delete_application ($4[0]) :),
             "list available positions", (: do_list_types() :),
             "list requirements for " + t + " applications",
              (: do_list_requirements($4[0]) :),
             "list position status", (: domain_status() :),
             "list questions for " + t + " applications",
              (: do_list_questions ($4[0]) :),
             "vouch for <word'name'> as <word'position'>",
              (: do_vouch ($4[0], $4[1]) :),
             "delete vouch for <word'name'> as <word'position'>",
              (: do_delete_vouch ($4[0], $4[1]) :),
             "query vouch for <word'name'> as <word'position'>",
              (: query_my_vouch ($4[0], $4[1]) :),
             "query all my vouches", (: do_query_all_vouches() :),
             "query vouches for my <word> application", (: query_my_vouches($4[0]) :),
  });
  if (this_player()->query_lord()) {
    tmp += ({"browse <word'type'> application for <word'name'>", (: do_browse_app($4[0], $4[1]) :) });
    tmp += ({"list applicants", (: do_list_applicants() :) });
  }
  return tmp;
}
void clean_up() {
  return 0;
}
int application_board_access_check( int type, string board,
                                    object previous, string name ) {
   switch(type) {
      case B_ACCESS_READ :
         return 1;
      case B_ACCESS_WRITE :
         if( file_name(previous) == file_name( this_object() ) )
            return 1;
          if (base_name (previous) == APPLICATIONS_HANDLER) {
            return 1;
          }
         return master()->query_lord(name);
      case B_ACCESS_DELETE :
         return 0;
   }
}
void reset() {
}
