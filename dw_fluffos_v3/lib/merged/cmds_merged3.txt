# Total Tokens: 99864
# Total Files Merged: 133
# Total Characters: 333238

=================================================

#include <obj_parser.h>
#include <move_failures.h>
#include <player.h>
#define DROP_H 40
#define PINCH_H 120
#define MAX_GET_NUMBER 20
inherit "/cmds/base";
#define TP this_player()
object* find_matching_obs(string match_str, object dob) {
   class obj_match result;
   result = (class obj_match)match_objects_in_environments(match_str, dob);
   if (result->result != OBJ_PARSER_SUCCESS) {
      add_failed_mess(match_objects_failed_mess(result));
      return 0;
   }
   return result->objects;
}
mixed cmd(object * obs, string dir, string indir, mixed *args) {
   object *dest;
   object ob;
   object dob;
   object *fail_dest;
   object *too_many;
   mixed *fail;
   mixed *ret;
   mixed amt;
   string sh;
   string hand_unit;
   string match_str;
   int i;
   int num;
   int cap;
   int perc;
   int handful;
   int total_num;
   mixed we;
   object env;
   object *bing;
   fail_dest = ({ });
   cap = (int) TP->query_max_weight();
   if (indir && sizeof(obs) > 10) {
      add_failed_mess("Please be more specific as to what you want "
                      "to get from.\n");
      return 0;
   }
   if (indir) {
      match_str = args[0];
      dest = obs;
   } else {
      if (environment(TP)->query_mirror_room()) {
         dest = ({ environment(TP), environment(TP)->query_mirror_room() });
      } else {
         dest = ({ environment(TP) });
      }
   }
   too_many = ({ });
   foreach(dob in dest) {
     if (!is_in_me_or_environment(dob, this_player())) {
         fail_dest += ({ dob });
         continue;
      }
      if (dob->cannot_get_stuff() || dob->query_closed()) {
         fail_dest += ({ dob });
         continue;
      }
      if (living(dob) && !dob->allowed_to_loot(this_player())) {
        fail_dest += ({ dob });
        continue;
      } else if (indir) {
         obs = find_matching_obs(match_str, dob);
      }
      if (!obs) {
         continue;
      }
      if (total_num + sizeof(obs) > MAX_GET_NUMBER) {
         if (total_num > MAX_GET_NUMBER) {
            too_many += obs;
            obs = ({ });
         } else {
            too_many += obs[MAX_GET_NUMBER - total_num..];
            obs = obs[0..MAX_GET_NUMBER - total_num - 1];
         }
      }
      total_num += sizeof(obs);
      ret = ({ ([ ]), ([ ]), ([ ]), ([ ]), ([ ]), });
      fail = ({ });
      foreach(ob in obs) {
        env = environment(ob);
        if(env != dob) {
          if(ob->query_collective())
            ob->move(dob);
          else
            dob = env;
        }
        if ((living(dob) && !dob->allowed_to_loot(this_player(), ob)) ||
            (ob->query_liquid() && ob->query_food_object())) {
          fail += ({ ob });
          num++;
          continue;
        }
         if (ob->query_continuous()) {
            amt = ob->query_amount_types();
            if (amt["handful"]) {
               hand_unit = "handful";
               handful = amt["handful"][0];
            } else if ((amt["drop"]) && (ob->query_liquid())) {
               hand_unit = "drops";
               handful = amt["drop"][0] * DROP_H;
            } else if (amt["pinch"]) {
               hand_unit = "pinches";
               handful = amt["pinch"][0] * PINCH_H;
            } else {
               handful = ob->query_amount();
            }
            if (ob->query_amount() > handful) {
               if (!match_str) {
                  match_str = ob->query_name();
               }
               if (i = strsrch(match_str, "of") >= 0) {
                  i += 3;
               }
               if (hand_unit == "handful") {
                  handful = 1;
               }
               match_str = handful + " " + hand_unit + " of " +
                  match_str[i..];
               fail += ({ "all of the " + ob->short() });
               ob = ob->query_parse_id(({ handful, match_str }));
               if (!ob) {
                  continue;
               }
               num++;
            }
         }
         if (function_exists("do_get", ob) ||
             function_exists("command_control", ob)) {
            if (function_exists("do_get", ob)) {
               we = (int) call_other(ob, "do_get", dob, 0, match_str,
                                     ({ 0, match_str }),
                                     "<direct:object> from <indirect:object>");
            } else {
               we = ob->command_control("get", dob, 0, match_str,
                                        ({ 0, match_str }),
                                        "<direct:object> from <indirect:object>");
            }
            if (!objectp(we)) {
               if (we) {
                  we = (int) ob->query_weight();
                  perc = (we * 100) / cap;
                  if (perc >= 95) {
                     i = 4;
                  } else {
                     i = perc / 25;
                  }
                  if (!ret[i][env]) {
                     ret[i][env] = ({ ob });
                  } else {
                     ret[i][env] += ({ ob });
                  }
               } else {
                  if (member_array(ob, this_player()->query_succ_mess_indir())
                      == -1 && !query_notify_fail() && !living(ob)) {
                     fail += ({ ob });
                  }
                  num++;
               }
               continue;
            } else {
               ob = we;
            }
         }
#ifndef __DISTRIBUTION_LIB__
         if(interactive(TP) &&
            PLAYER_MULTIPLAYER_HANDLER->check_multiplayers("get", TP, ob)) {
           fail += ({ ob });
           num++;
         } else
#endif
         if ((int) ob->move(TP) == MOVE_OK) {
            we = (int) ob->query_weight();
            perc = (we * 100) / cap;
            if (perc >= 95) {
               i = 4;
            } else {
               i = perc / 25;
            }
            if (!ret[i][env]) {
               ret[i][env] = ({ ob });
            } else {
               ret[i][env] += ({ ob });
            }
         } else {
            fail += ({ ob });
            num++;
         }
      }
      for (i = 0; i < sizeof(ret); i++) {
         if (sizeof(ret[i])) {
            foreach(env, bing in ret[i]) {
               if (this_player()->query_succ_mess_dir()) {
                  bing -= this_player()->query_succ_mess_dir();
               }
               if (sizeof(bing)) {
                  sh = query_multiple_short(bing);
                  write("You " + ({ "get", "get with a bit of difficulty",
                                    "struggle somewhat to get",
                                    "find it very difficult to get",
                                    "use all your strength and just barely manage to get" })
                        [i] + " " + sh + " from " + inside_the_short(dob) +
                        ".\n");
                  say(capitalize((string) TP->one_short()) + " " +
                      ({ "gets", "gets with a bit of difficulty",
                         "struggles somewhat to get",
                         "finds it very difficult to get",
                         "uses all " + TP->query_possessive() +
                         " strength and just barely manages to get" })[i] +
                      " " + sh + " from " + inside_a_short(dob) + ".\n");
               }
            }
         }
      }
      if (sizeof(fail)) {
         add_failed_mess("You cannot get $I.\n", fail);
      }
   }
   if (num == total_num) {
      if (query_notify_fail()) {
         return 0;
      }
      if (indir) {
         if (sizeof(fail_dest)) {
            add_failed_mess("You cannot get anything from $I.\n", fail_dest);
         }
      } else {
         add_failed_mess("You cannot get $I.\n", obs);
      }
      return -1;
   } else {
      if (sizeof(too_many)) {
         add_succeeded_mess(({ "You cannot pick up more than " +
                               query_num(MAX_GET_NUMBER) +
                               " objects at a time; " "discarding $I.\n",
                               "" }), too_many);
      }
   }
   return 1;
}
mixed *
query_patterns()
{
   return ({ "<indirect:object:here>", (: cmd($1, 0, 0, 0) :),
             "<string> from <indirect:object>", (: cmd($1, $2, $3, $4) :) });
}

==================================================
FILE: living/give.c
==================================================

#include <move_failures.h>
#include <player.h>
inherit "cmds/base";
#define TP this_player()
#define SUPPRESS_MESS "suppress give messages"
mixed cmd(mixed *indir, string *indir_match) {
  string sh;
  string s1;
  string failmess;
  int tot;
  int max;
  int ok;
  object *per;
  object *ret;
  object *fail;
  object pobj;
  object ob;
  object *obs;
  object *succ;
  object *keep;
  per = indir[1];
  succ = ({ });
  keep = ({ });
  failmess = "";
  foreach(pobj in per) {
    obs = indir[0];
    obs -= per;
    if (pobj->query_property("player") && !interactive(pobj)) {
      failmess = pobj->the_short()+" seems too chalky to accept your "
        "gift.\n";
      continue;
    }
    if (pobj == TP) {
     failmess = "You nag yourself for a while, but can't convince "
                 "yourself to accept things from yourself.\n";
     continue;
    }
    if (!sizeof(obs)) {
      failmess = "Nothing to give to "+ pobj->short() +".\n";
      continue;
    }
    ret = ({ });
    fail = ({ });
    foreach(ob in obs) {
      if ( member_array( ob, succ ) > -1 ) {
        continue;
      }
      if (ob->query_keep()) {
         keep += ({ ob });
         continue;
      }
      if (function_exists("do_give", ob) ||
          function_exists("command_control", ob)) {
        if (function_exists("do_give", ob)) {
          max = call_other(ob, "do_give", pobj, indir_match[0],
                                indir_match[1],
                                ({ indir_match[0], indir_match[1] }),
                                "<direct:object:me> to <indirect:living>");
        } else {
          max = ob->command_control("give", pobj, indir_match[0],
                                    indir_match[1],
                                    ({ indir_match[0], indir_match[1] }),
                                    "<direct:object:me> to <indirect:living>");
        }
        if (max == 0)  {
          fail += ({ ob });
          continue;
        }
      }
#ifndef __DISTRIBUTION_LIB__
      PLAYER_MULTIPLAYER_HANDLER->record_object("give", TP, ob);
      if(pobj->query_property("player") && interactive(TP) &&
         "/obj/handlers/multiplayer"->check_multiplayers("give", pobj, ob)) {
        fail += ({ ob });
      } else
#endif
      if (pobj->query_closed()  ||  ob->move(pobj) != MOVE_OK) {
        fail += ({ ob });
      } else  {
        ret += ({ ob });
        tot += ob->query_weight();
      }
    }
    if (sizeof(ret)) {
      ok = 1;
      succ += ret;
      if (pobj->query_clothing()) {
        s1 = pobj->query_pocket_mess();
      } else {
        s1 = "$ob_short$";
      }
      sh = query_multiple_short(ret);
      if ( interactive( pobj ) || !pobj->query_property( SUPPRESS_MESS ) ) {
        tell_object(TP, "You give "+ sh +" to "+
                  replace_string(s1, "$ob_short$", pobj->one_short())+
                  ".\n");
        tell_room(environment(TP), TP->one_short() + " gives " + sh +
               " to " + replace_string(s1, "$ob_short$",
                                      pobj->one_short()) +
               ".\n", ({ TP, pobj }));
        tell_object(pobj, capitalize(TP->one_short() ) + " gives "+
                    sh + " to you.\n" );
      }
      if (living(pobj) && (max = pobj->query_max_weight()))
        if ((max = tot*100/max) > 25)
          if (max >= 95) {
            tell_room(environment(TP),
                      pobj->the_short()+" staggers under a weight "+
                      pobj->query_pronoun()+" can only just carry.\n",
                      ({ pobj }) );
            pobj->event_say(TP, "You stagger under a weight you can only "
                            "just carry.\n");
          } else {
            tell_room(environment(TP), pobj->the_short()+ ({
              " is only mildly discomforted by the additional weight.\n",
              " braces "+pobj->query_objective()+"self to take the load.\n",
              " stumbles as "+pobj->query_pronoun()+" takes the load.\n"
              })[(max/25)-1], ({ pobj }) );
            pobj->event_say(TP, "You"+ ({
              " are only mildly discomforted by the additional weight.\n",
              " brace yourself under the load.\n",
              " stumble as you take the load.\n"
              })[(max/25)-1]);
          }
    }
    if (sizeof(fail)) {
      failmess += "You cannot give "+query_multiple_short(fail)+ " to "+
                  pobj->one_short() +".\n";
    }
  }
  if (!ok) {
    add_failed_mess(failmess);
    if (sizeof(keep)) {
       add_failed_mess("You have $I set to be kept.\n", keep);
    }
  }
  return ok;
}
mixed *query_patterns() {
  return ({ "<indirect:object:me> to <indirect:living>",
            (: cmd($1, $3) :) });
}

==================================================
FILE: living/ho_ld.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(object * obs,
        string str)
{
   int num_limbs;
   int avail;
   int old_avail;
   int reqd;
   int i;
   int pos;
   int success;
   int *used;
   int *already_used;
   int *limbs_used;
   object ob;
   object weapon;
   object *using;
   object *fails;
   object *unfails;
   object *holds;
   object *unholds;
   object *already;
   object *no_change;
   string *limbs;
   string *hhands;
   string *uhands;
   limbs = TP->query_limbs();
   num_limbs = sizeof(limbs);
   avail = TP->query_free_limbs();
   no_change = ({ });
   already = filter(obs, (: $1->query_holder() :));
   if (sizeof(already) > 0) {
      using = this_player()->query_holding();
      foreach (ob in already)  {
         limbs_used = find_member(ob, using);
         if (str)  {
            if (sizeof(limbs_used) == 1  &&
                member_array(str, limbs) == limbs_used[0])
            {
               no_change += ({ ob });
            }
            else already -= ({ ob });
         }
         else if (sizeof(limbs_used) != ob->query_no_limbs())
            already -= ({ ob });
      }
      if (sizeof(obs) == sizeof(no_change))  {
         add_failed_mess("You are already holding " +
                         query_multiple_short(obs) +
                         " in your " + str + ".\n");
         return -1;
      }
      else if (sizeof(obs) == sizeof(already)) {
         return notify_fail("You are already holding " +
                            query_multiple_short(obs) + ".\n");
      } else {
         obs -= already;
         if (sizeof(already) > 0)
            write(sprintf("You are already holding %s, you instead try to "
                          "hold %s.\n", query_multiple_short(already),
                          query_multiple_short(obs)));
         already_used = map(already, (: $1->query_my_limb() :));
      }
   } else {
      already_used = ({ });
   }
   fails = holds = unholds = hhands = uhands = unfails = ({ });
   if (str && obs[0]) {
      pos = member_array(str, limbs);
      if (pos == -1) {
         if (!sizeof(limbs)) {
            return
               notify_fail("You seem to have a singular lack of limbs.\n");
         }
         return notify_fail("Incorrect limb type, must be one of " +
                            query_multiple_short(limbs) + ".\n");
      }
      using = TP->query_holding();
      if (sizeof(unfails) == 0  &&  using[pos]) {
         used = TP->set_unhold(using[pos]);
         if (sizeof(used) == 0) {
            unfails += ({ using[pos] });
            uhands += ({ limbs[pos] });
         } else {
            for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
               uhands += ({ limbs[used[i]] });
            }
            unholds += ({ using[pos] });
         }
      }
      if ((i = member_array(obs[0], using - unholds)) != -1)  {
         used = TP->set_unhold(obs[0]);
         if (sizeof(used) == 0) {
            unfails += ({ obs[0] });
            uhands += ({ limbs[i] });
         } else {
            for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
               uhands += ({ limbs[used[i]] });
            }
            unholds += ({ obs[0] });
         }
      }
      if (sizeof(unfails) == 0) {
         used = TP->set_hold(obs[0], pos, 1);
         if (sizeof(used) == 0) {
            fails += ({ obs[0] });
         } else {
            for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
               hhands += ({ limbs[used[i]] });
            }
            holds += ({ obs[0] });
            success = 1;
         }
      }
   } else {
      foreach(ob in obs) {
         reqd += ob->query_no_limbs();
      }
      if (reqd > num_limbs) {
         add_failed_mess("You do not have enough limbs to hold $I.\n", obs);
         return 0;
      }
      old_avail = -1;
      while ((avail < reqd) && (avail < num_limbs)) {
         if ((reqd > num_limbs - sizeof(unfails)) || (old_avail == avail)) {
            if (sizeof(unfails)) {
               add_failed_mess
                  ("You do not have enough limbs to hold $I, since " +
                   query_multiple_short(unfails) + " failed " "to unhold.\n",
                   obs);
            } else {
               add_failed_mess
                  ("Not able to free up enough limbs to hold $I.\n", obs);
            }
            return 0;
         }
         old_avail = avail;
         using = TP->query_holding();
         for (i = 0; i < sizeof(using); i++) {
            weapon = using[i];
            if (weapon && member_array(i, already_used) == -1) {
               used = TP->set_unhold(weapon);
               if (sizeof(used)) {
                  for (i = 0; i < sizeof(used) && used[i] < sizeof(limbs);
                       i++) {
                     uhands += ({ limbs[used[i]] });
                  }
                  unholds += ({ weapon });
                  avail = TP->query_free_limbs();
                  break;
               } else {
                  if (member_array(weapon, unfails) == -1) {
                     unfails += ({ weapon });
                  }
                  uhands += ({ limbs[i] });
               }
            }
         }
      }
      if (!sizeof(unfails)) {
         foreach(ob in obs) {
            using = TP->query_holding();
            pos = 0;
            if (!ob->query_no_limbs() || avail < ob->query_no_limbs()) {
               fails += ({ ob });
               break;
            }
            while ((using[pos]) && (pos < num_limbs)) {
               pos++;
            }
            used = TP->set_hold(ob, pos, ob->query_no_limbs());
            if (used == ({ })) {
               fails += ({ ob });
            } else {
               for (i = 0; i < sizeof(used) && i < sizeof(limbs); i++) {
                  hhands += ({ limbs[used[i]] });
               }
               holds += ({ ob });
               success = 1;
               avail = TP->query_free_limbs();
            }
         }
      }
   }
   if (sizeof(unfails)) {
      tell_object(TP,
                  "You fail to put down " + query_multiple_short(unfails) +
                  " from your " + query_multiple_short(uhands) + ".\n");
      say(TP->one_short() + " fails to put down " +
          query_multiple_short(unholds) + " from " + TP->query_possessive() +
          " " + query_multiple_short(uhands) + ".\n");
   }
   if (sizeof(unholds)) {
      tell_object(TP, "You put down " + query_multiple_short(unholds) +
                  " from your " + query_multiple_short(uhands) + ".\n");
      say(TP->one_short() + " puts down " + query_multiple_short(unholds) +
          " from " + TP->query_possessive() + " " +
          query_multiple_short(uhands) + ".\n");
   }
   if (sizeof(holds)) {
      tell_object(TP,
                  "You hold " + query_multiple_short(holds) + " in your " +
                  query_multiple_short(hhands) + ".\n");
      say(TP->one_short() + " holds " + query_multiple_short(holds) + " in " +
          TP->query_possessive() + " " + query_multiple_short(hhands) +
          ".\n");
   }
   if (!success && sizeof(fails)) {
      tell_object(TP,
                  "You fail to hold " + query_multiple_short(fails) + ".\n");
      say(TP->one_short() + " fails to hold " + query_multiple_short(fails) +
          ".\n");
   }
   return 1;
}
mixed *query_patterns()
{
   return ({ "<indirect:object:me>", (: cmd($1, 0) :),
             "<indirect:object:me> in [my] {" +
             implode(this_player()->query_limbs(), "|") + "}",
             (: cmd($1, implode($4[1..], " ")) :) });
}

==================================================
FILE: living/kill.c
==================================================

#include <player.h>
inherit "/cmds/base";
int cmd( object* things ) {
   object thing;
   object *fighting;
   if ( !environment( this_player() ) ) {
      add_failed_mess( "You are in limbo...\n" );
      return 0;
   }
   if ( this_player()->no_offense() ) {
      add_failed_mess( "You cannot attack anyone at the moment.\n" );
      return 0;
   }
   things -= ({ this_player() });
   if ( !sizeof( things ) ) {
      add_failed_mess( "You shouldn't beat yourself up so much.\n");
      return 0;
   }
   foreach ( thing in things ) {
      if ( !userp( thing ) ) {
         if ( userp( this_player() ) ||
               !thing->query_property( "no attack" ) ) {
            this_player()->attack_ob( thing );
            thing->attack_by(this_player());
         }
         continue;
      }
      if ( !interactive( thing ) ) {
         write( (string)thing->the_short() +" is net-dead.\n" );
         things -= ({ thing });
         continue;
      }
      if ( thing->query_property( "guest" ) ) {
         write( "You cannot attack "+ (string)thing->the_short() +
               " since "+ (string)thing->query_pronoun() +" is a guest.\n" );
         things -= ({ thing });
         continue;
      }
      if ( thing->query_property( "dead" ) ) {
         write( "You cannot attack "+ (string)thing->the_short() +
               " since "+ (string)thing->query_pronoun() +
                " is already dead.\n" );
         things -= ({ thing });
         continue;
      }
      if ( thing->query_auto_loading() ) {
         write( "Be sporting; "+ (string)thing->the_short() +
               " doesn't have "+ (string)thing->query_possessive() +
               " equipment yet.\n" );
         things -= ({ thing });
         continue;
      }
      if ( userp( this_player() ) &&
           !this_player()->query_player_killer() ) {
         write( "You cannot summon the courage to attack "+
               (string)thing->the_short() +".\n" );
         things -= ({ thing });
         continue;
      }
      if ( userp( this_player() ) &&
            !thing->query_player_killer() ) {
         write( "Something tells you that it would be wrong "
               "to attack "+ (string)thing->the_short() +".\n" );
         things -= ({ thing });
         continue;
      }
      call_out( (: this_player()->attack_ob( $(thing) ) :), 0);
      call_out( (: $(thing)->attack_by(this_player()) :), 0);
   }
    if ( sizeof( things ) ) {
      fighting = ({ });
      foreach(thing in things) {
        object *list;
        list = thing->query_attacker_list();
        if (arrayp(list)) {
           fighting += list;
        }
      }
      if(sizeof(fighting))
        fighting = filter(uniq_array(fighting),
                          (: $1 && environment($1) != environment(this_player()) :));
      if(!sizeof(fighting))
        this_player()->add_succeeded_mess(this_object(),
                                          ({ "You prepare to attack " + query_multiple_short(things) + ".\n", "" }), ({ }) );
      else
        this_player()->add_succeeded_mess(this_object(),
					  ({ "You prepare to attack " + query_multiple_short(things) + " who " + (sizeof(things) > 1 ? "are" : "is") + " already hunting " + query_multiple_short(fighting) + ".\n", "" }), ({ }) );
        return 1;
    } else {
        add_failed_mess("");
        return 0;
    }
}
mixed *query_patterns() {
   return ({ "<indirect:living:here>", (: cmd($1) :) });
}

==================================================
FILE: living/kneel.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("kneel", "down", KNEELING);
}

==================================================
FILE: living/l_ook.c
==================================================

#include <player.h>
#include <weather.h>
#include <dirs.h>
#include <error_handler.h>
#include <db.h>
#include <terrain_map.h>
inherit "/cmds/base";
#define TP this_player()
string weather_long(string str);
int check_exists(string file);
string look_around();
mixed cmd_string(string arg);
void finish_bug_summary(object player, int type, mixed data) {
   class error_complete summ;
   class error_complete* errors;
   string str;
   int pos;
   if (type != DB_SUCCESS) {
      return ;
   }
   errors = data;
   if (!sizeof(errors)) {
      tell_object(player, "No errors for this room.\n");
      return ;
   }
   str = "";
   str = sprintf("#<bug id>  ( <date> ) %5-s %4-s %-4s by %11-s %11-s\n",
                 "Status", "Type", "Cat", "Reporter", "Assigned");
   foreach (summ in errors) {
      pos = strsrch(summ->details->report, "\n");
      if (pos < 0 || pos > player->query_cols() - 5) {
         pos = player->query_cols() - 5;
      } else {
         pos --;
      }
      str += sprintf("$I$3=#%d (%s) %5-s %4-s %-4s by %11-s %11-s\n%s\n",
                     summ->details->summary->id,
                     ctime(summ->details->summary->entry_date)[4..15],
                     summ->details->summary->status[0..4],
                     summ->details->summary->type,
                     summ->details->summary->category[0..3],
                     summ->details->summary->reporter,
                     summ->details->summary->assigned_to,
                     summ->details->report[0..pos]);
   }
   tell_object(player, str);
}
void show_error_summary(object player, string* types) {
   class error_query query;
   if (!arrayp(types) || !sizeof(types)) {
      return ;
   }
   query = new(class error_query);
   query->file_name = file_name(environment(player));
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   query->type = types;
   query->no_extra_details = 1;
   ERROR_HANDLER->do_query_multiple_bug_details(query, (: finish_bug_summary, player :));
}
int cmd_look_room()
{
   object room;
   int dark;
   string ret;
   int *coords;
   room = environment(TP);
   if (!room) {
      add_failed_mess("You are in limbo... sorry you can't look at " +
                      "anything.\n");
      return 0;
   }
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   if (!TP->query_property("dead")) {
      dark = (int) TP->check_dark((int) room->query_light());
   }
   if (TP->query_creator()) {
      coords = room->query_co_ord();
      if (sizeof(coords)) {
         ret = "  (" + coords[0] + "," + coords[1] + "," + coords[2] + ")";
      } else {
         ret = "  (unset)";
      }
      if (virtualp(room)) {
         write("%^CYAN%^" + file_name(room) + " [" +
                room->query_property("base path")  + "]" + ret + "%^RESET%^\n");
      } else {
         write("%^CYAN%^" + file_name(room) + ret + "%^RESET%^\n");
      }
   }
   if ((TP->query_creator() || TP->query_playtester()) &&
       TP->query_property(TERRAIN_MAP_IN_LOOK_PROP)) {
      ret = room->long_test(0, dark);
      if (ret) {
         write("$P$Look$P$" + ret);
      } else {
         write("$P$Look$P$" + (string) room->long(0, dark));
      }
   } else {
      write("$P$Look$P$" + (string) room->long(0, dark));
   }
   if (dark && TP->query_creator()) {
      write("%^YELLOW%^As a creator, you can see:%^RESET%^\n" +
            (string) room->long(0, 0));
   }
   if (TP->query_creator() && TP->query_property(PLAYER_SHOW_ERRORS_PROP)) {
      show_error_summary(this_player(), TP->query_property(PLAYER_SHOW_ERRORS_PROP));
   }
   return 1;
}
string query_look_thing(object thing,
                        object player,
                        int dark,
                        string verb,
                        string arg)
{
   string ret;
   object env;
   string other;
   string replaced;
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   ret = "";
   if (living(thing)) {
      if (thing == player) {
         ret += "Looking at yourself again?  What a narcissist!\n";
      } else {
         tell_object(thing, "$one_short:" + file_name(player) +
                     "$ $V$0=looks,look$V$ at you.\n");
      }
   } else {
      env = environment(thing);
      while (env && !living(env)) {
         env = environment(env);
      }
   }
   if (env && env != player) {
      tell_object(env, player->the_short() + " " + verb + " "
                  "at your " + thing->pretty_short() + ".\n");
      other = thing->query_long(arg, dark);
      if (other) {
         replaced = thing->replace_long_dollars(player, other);
         if (replaced) {
            ret += replaced;
         }
         else {
            ret += other;
         }
      }
      other = thing->query_long_details(arg, dark, player);
      if (other) {
         ret += other;
      }
   } else {
      ret += thing->long(arg, dark);
   }
   return ret;
}
mixed cmd_object(object * obs,
                 string arg)
{
   object thing;
   object room;
   int dark;
   int retval;
   string ret;
   room = environment(TP);
   if (LENGTHEN[arg]) {
     arg = LENGTHEN[arg];
   }
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   if (!room) {
      add_failed_mess("You are in limbo... sorry you can't look at " +
                      "anything.\n");
      return 0;
   }
   if (!TP->query_property("dead")) {
      dark = (int) TP->check_dark((int) room->query_light());
   }
   if (dark == 2) {
      add_failed_mess("It is way too bright to see anything at all.\n");
      return 0;
   }
   if (dark == -2) {
      add_failed_mess("It is way too dark to see anything at all.\n");
      return 0;
   }
   ret = "";
   foreach(thing in obs) {
      ret += query_look_thing(thing, this_player(), dark, "looks", arg);
   }
   if (ret != "") {
      write("$P$Look$P$" + ret);
      retval = 1;
   }
   if (room->query_exit(arg))
      cmd_string(arg);
   else {
      arg = (string) this_player()->find_abs(arg);
      if (room->query_exit(arg))
         cmd_string(arg);
   }
   return 1;
}
mixed cmd_string(string arg)
{
   object room;
   int dark;
   int retval;
   string ret;
   string other;
   string orig_arg;
   mixed *func;
   room = environment(TP);
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   if (!room) {
      add_failed_mess("You are in limbo... sorry you can't look at " +
                      "anything.\n");
      return 0;
   }
   switch (arg) {
   case "soul":
      write((string) "/obj/handlers/new_soul"->help_list());
      return 1;
   case "sun":
   case "moon":
   case "stars":
   case "weather":
   case "sky":
      write(weather_long(arg));
      return 1;
   case "around":
      write(look_around());
      return 1;
   }
   orig_arg = arg;
   if (!TP->query_property("dead")) {
      dark = (int) TP->check_dark((int) room->query_light());
   }
   if (dark == 2) {
      add_failed_mess("It is way too bright to see anything at all.\n");
      return 0;
   }
   if (dark == -2) {
      add_failed_mess("It is way too dark to see anything at all.\n");
      return 0;
   }
   if (LENGTHEN[arg]) {
      arg = LENGTHEN[arg];
   }
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   if (!room->query_exit(arg)) {
      arg = (string) this_player()->find_abs(arg);
   }
   if (room->query_exit(arg)) {
      int tmp_ret_val;
      room->set_destination(arg);
      other = (string) room->query_destination(arg);
      ret = room->query_look(arg);
      if (ret && ret != "") {
         write(ret + "\n");
         retval = 1;
         tmp_ret_val = 1;
      }
      func = room->query_look_func(arg);
      if (pointerp(func) && sizeof(func) >= 1 && func[0] && func[1]) {
         if (call_other(func[0], func[1], 1)) {
            retval = 1;
            tmp_ret_val = 1;
         }
      } else if (functionp(func)) {
         if (evaluate(func, 1)) {
            retval = 1;
            tmp_ret_val = 1;
         }
      }
      if (check_exists(other) && !tmp_ret_val) {
         object door;
         door = room->query_door_control(arg);
         if (room->query_door_open(arg) || door->query_transparent()) {
            other->force_load();
            dark = (int) TP->check_dark((int) other->query_light());
            ret = other->long(0, dark);
            this_player()->set_looked(find_object(other));
            write(ret);
            retval = 1;
         } else {
            add_failed_mess(door->the_short() +
                            " is closed and not transparent.\n");
            retval = 0;
         }
      }
   }
   return retval;
}
int check_exists(string file)
{
   int retval;
   if (objectp(find_object(file))) {
      return 1;
   }
   if (strsrch(file, ":")) {
      return 1;
   }
   if (file_size(file + ".c") > 0) {
      retval = 1;
   } else {
      retval = 0;
   }
   return retval;
}
string weather_long(string str)
{
   object env;
   string temp;
   string whandler;
   env = environment(TP);
   temp = (string) env->query_property("location");
   switch (temp) {
   case ("inside"):
      return "You are not outside.\n";
   }
   whandler = env->query_weather_handler() ;
   if ( ! whandler ) {
       whandler = WEATHER ;
   }
   if (str == "sun") {
      if (whandler->query_day(env)) {
         return "Ouch that hurts.\n";
      } else {
         return "The sun is not up, sorry.\n";
      }
   }
   if (str == "moon") {
      if (whandler->query_day(env)) {
         return "The moon is not up, try at night.\n";
      } else if ( (temp = whandler->query_moon_string(env)) ) {
         return temp;
      } else {
         return "The moon is not up at the moment, try again later.\n";
      }
   }
   if (str == "stars") {
       if (whandler->query_day(env)) {
           return "The stars are not out at the moment - try at night.\n" ;
       } else {
           if ( (temp = whandler->query_star_string(env)) ) {
               return temp ;
           } else {
               return "There aren't any visible stars right now.\n" ;
           }
       }
   }
   return "You look up at the sky.  " + whandler->weather_string(env) + ".\n";
}
string look_around()
{
   int i;
   int j;
   string prep;
   string room;
   string *parts;
   string *rooms;
   object place;
   object thing;
   object *contents;
   mixed *locations;
   if (TP->query_blinded()) {
      add_failed_mess("You are blind and cannot see.\n");
      return 0;
   }
   place = environment(this_player());
   if (place->query_linked()) {
      rooms = (string *) place->query_rooms();
   } else {
      rooms = ({ });
   }
   locations = ({ });
   say((string) this_player()->one_short() + " $V$0=looks,look$V$ around.\n");
   foreach(room in rooms) {
      if (!find_object(room)) {
         continue;
      }
      if (this_player()->check_dark((int) room->query_light())) {
         continue;
      }
      contents = ({ });
      foreach(thing in all_inventory(find_object(room))) {
         if (living(thing) && thing->query_visible(this_player()))
            contents += ({ thing });
      }
      if (!sizeof(contents)) {
         continue;
      }
      prep = (string) room->query_static_preposition();
      if (prep != "") {
         if (!stringp(prep)) {
            prep = sprintf("%O", prep);
         }
         prep += " ";
      }
      locations += ({ ({ contents, prep +
                         (string) this_player()->
                         convert_message((string) room->the_short())
                      }) });
   }
   if (!sizeof(locations)) {
      contents = ({ });
      if (this_player()->check_dark((int) place->query_light())) {
         return "You can't see well enough to look around here.\n";
      }
      foreach(thing in all_inventory(place)) {
         if (living(thing) && thing->query_visible(this_player()) &&
             (thing != this_player()))
            contents += ({ thing });
      }
      if (!sizeof(contents)) {
         return "You do not see anyone else about.\n";
      }
      return "$C$" + query_multiple_short(contents) +
         " $V$0=is,are$V$ here.\n";
   }
   for (i = 0; i < sizeof(locations) - 1; i++) {
      for (j = i + 1; j < sizeof(locations); j++) {
         if (locations[i][1] == locations[j][1]) {
            locations[i][0] += locations[j][0];
            locations = delete(locations, j, 1);
            j--;
         }
      }
   }
   parts = ({ });
   for (i = 0; i < sizeof(locations); i++) {
      parts += ({ query_multiple_short(locations[i][0]) + " " +
                  locations[i][1] });
   }
   if (sizeof(parts) == 1) {
      return "You can see " + parts[0] + ".\n";
   }
   return "You can see " + query_multiple_short(parts) + ".\n";
}
mixed *query_patterns()
{
   return ({ "", (: cmd_look_room() :),
             "<string'direction'>", (: cmd_string($4[0]) :),
             "<indirect:object>", (: cmd_object($1, $4[0]) :),
             "at <indirect:object>", (: cmd_object($1, $4[0]) :),
             "in <indirect:object>", (: cmd_object($1, $4[0]) :),
             "inside <indirect:object>", (: cmd_object($1, $4[0]) :),
             "around", (: cmd_string("around") :) });
}

==================================================
FILE: living/learn.c
==================================================

#include <skills.h>
#include <tune.h>
#include <cmds/teach.h>
#include <command.h>
inherit "/cmds/base";
#define TP this_player()
mixed cmd(string str, object *obs);
mixed cmd(string str, object *obs) {
  object *diff_lvl;
  object *no_xp;
  object *not_offer;
  object *ok;
  object *moved;
  object ob;
  int time;
  string skill;
  string cmd;
  string cmd_ob;
  string *bits;
  string levelstr;
  class teaching_skill womble;
  if (TP->query_property("dead")) {
    notify_fail("Your dead.  Your mind slips off the task and goes for "
                "a wander down memory lane.\n");
    return 0;
  }
  skill = str;
  bits = explode(implode(explode(skill, " "), "."), ".");
  skill = SKILL_OB->query_skill(bits);
  if (!skill) {
    ok = ({ });
    cmd = str;
    if (sizeof(CMD_D->GetPaths(cmd)) &&
        CMD_D->GetPaths(cmd)[0]) {
       cmd_ob = CMD_D->GetPaths(cmd)[0] + "/" + cmd;
       foreach (ob in obs) {
          bits = TP->query_respond_command(TEACH_COMMAND_TYPE, ob);
          if (pointerp(bits) && member_array(cmd, bits) != -1) {
             cmd_ob->teach_command(ob, this_player());
             ok += ({ ob });
             bits -= ({ cmd });
             if (sizeof(bits)) {
                TP->add_respond_command(TEACH_COMMAND_TYPE, ob, bits);
             } else {
                TP->remove_respond_command(TEACH_COMMAND_TYPE, ob);
             }
             event(environment(this_player()), "teach", "command", ob, this_player());
             break;
          }
       }
       if (sizeof(ok)) {
          add_succeeded_mess("$N learn$s " + cmd + " from $I.\n", ok);
          return 1;
       }
       add_failed_mess("The skill \"" + cmd + "\" is invalid, or $I "
                       "is not trying to teach you the \"" + cmd + "\" "
                       "command.\n");
    } else {
       add_failed_mess("The skill '" + cmd + "' is invalid.\n");
    }
    return 0;
  }
  moved = ok = not_offer = no_xp = diff_lvl = ({ });
  foreach (ob in obs) {
    womble = TP->query_respond_command(TEACH_SKILL_TYPE, ob);
    if (!womble) {
      not_offer += ({ ob });
      continue;
    }
    if (skill != womble->skill) {
      not_offer += ({ ob });
      continue;
    }
    if ((int)TP->query_xp() < womble->xp ||
        !womble->xp) {
      no_xp += ({ ob });
      continue;
    }
    if (TP->query_skill(womble->skill) != womble->lvl) {
      diff_lvl += ({ ob });
      TP->remove_respond_command(TEACH_SKILL_TYPE, womble->teacher);
      continue;
    }
    if (sizeof(ok)) {
      continue;
    }
    if(womble->num == 1)
      levelstr = "level";
    else
      levelstr = "levels";
    if (environment(this_player()) != womble->room) {
       moved += ({ ob });
       TP->remove_respond_command(TEACH_SKILL_TYPE, womble->teacher);
       continue;
    }
    if (ob != TP) {
      write(ob->short()+" starts to teach you " + womble->num + " " +
            levelstr + " of " + womble->skill + " for " + womble->xp +
            " xp.\n");
      tell_object(ob, "You start to teach " + TP->short() +
                  " " + womble->num + " " + levelstr +
                  " of " + womble->skill +
                  " for " + womble->xp + " xp.\n");
      say(ob->short()+" starts to teach "+TP->short()+" some skills.\n",
          ({ TP, ob }));
      ok += ({ ob });
    } else {
      write("You start to teach yourself " + womble->num + " " +
            levelstr + " in "+
            womble->skill + " for " + womble->xp + " xp.\n");
      say(TP->short()+" starts to teach " + TP->query_objective() +
          "self some skills.\n", ({ TP }));
    }
    time = womble->xp / TIME_DIV;
    if(time > 1000) {
      time = 1000;
    }
    TP->adjust_time_left(-time);
    womble->teacher = ob;
    womble->taught = TP;
    TP->set_interupt_command("stop_teaching_skills", file_name(this_object()),
                             womble);
    if (TP != ob) {
      ob->adjust_time_left(-time);
      ob->set_interupt_command("stop_teaching_skills", TP, womble);
    }
  }
  if (sizeof(not_offer)) {
    if(sizeof(not_offer) == 1) {
      if(not_offer[0] != this_player())
        write(capitalize(query_multiple_short(not_offer)) +
              " is not offering to teach you "+ skill+".\n");
      else
        write(capitalize(query_multiple_short(not_offer)) +
              " are not offering to teach yourself "+ skill+".\n");
    } else
        write(capitalize(query_multiple_short(not_offer)) +
              " are not offering to teach you "+ skill+".\n");
  }
  if (sizeof(moved)) {
    write("You appear to have moved away from the excellent teaching "
          "environment selected by "+
          query_multiple_short(moved)+".\n");
  }
  if (sizeof(no_xp)) {
    write("You do not have enough xp to learn "+skill+" from "+
          query_multiple_short(no_xp)+".\n");
  }
  if (sizeof(diff_lvl)) {
    write("You were a different level in "+skill+" when "+
          query_multiple_short(diff_lvl)+" offered to teach you.\n");
  }
  if (sizeof(ok)) {
    say(TP->short()+" learns some skills from "+query_multiple_short(ok)+
        ".\n", ok);
  }
  return 1;
}
void stop_teaching_skills(int time_left, class teaching_skill womble,
                          object us, object interupter, string cmd) {
   object ob;
   mixed *stuff;
   string levelstr;
   if (time_left > 0) {
      if (womble->teacher == us) {
         if (womble->teacher == womble->taught) {
            say(womble->taught->short() + " stops teaching " +
                womble->taught->query_objective() + "self some "
                "skills.\n");
         } else if (us == interupter) {
            ob = womble->teacher;
            tell_object(ob, womble->taught->short() + " interupts your "
                            "training.\n");
         } else {
            tell_object(us, interupter->short() + " interupts your "
                            "training.\n");
         }
         say(interupter->short() + " stops teaching some skills to " +
             womble->taught->short() + ".\n",
             ({ us, interupter }));
      }
      if (us == womble->teacher) {
         ob = womble->taught;
      } else {
         ob = womble->teacher;
      }
      if (ob) {
         stuff = ob->query_interupt_command();
         if (stuff) {
            if (stuff[0] == "stop_teaching_skills") {
               ob->interupt_command(us);
            }
         }
      }
      us->adjust_time_left(-((int)womble->taught->query_time_left()));
      us->set_interupt_command(0);
      return ;
   }
   if (interupter != us) {
      return ;
   }
   if (environment(womble->taught) != environment(womble->teacher) ||
       environment(womble->taught) != womble->room) {
      tell_object(us, "You appear to have left your excellent "
                      "teaching environment, so the skill teaching failed.\n");
      tell_object(womble->teacher, "You appear to have left your excellent "
                      "teaching environment, so the skill teaching failed.\n");
      return;
   }
   if(womble->taught->query_xp() < womble->xp) {
      write("Something has gone wrong. :(\n");
      return;
   }
   if (womble->taught != womble->teacher) {
      womble->teacher->adjust_xp(womble->xp / 10);
   }
   womble->taught->adjust_xp(-womble->xp);
   if(womble->num == 1)
     levelstr = "level";
   else
     levelstr = "levels";
   if(womble->taught->add_skill_level(womble->skill, womble->num, womble->xp))
     {
       if (us != womble->teacher) {
         tell_object(us, "You finish learning " + womble->num +
                     " " + levelstr + " of "
                     + womble->skill + " from " + womble->teacher->short() +
                     ".\n");
         tell_object(womble->teacher, womble->taught->short() + " finishes " +
                     "learning " + womble->num + " " + levelstr + " of "
                     + womble->skill + " from you.\n");
         say(us->short() + " finishes learning some skills "+
             "from "+ womble->teacher->short()+".\n",
             ({ us, womble->teacher }));
       } else {
         tell_object(us, "You finish teaching yourself " + womble->num +
                     " " + levelstr + " of " +
                     womble->skill + ".\n");
         say(us->short() + " finishes learning some skills "
             "from " + us->query_objective() + "self.\n",
             ({ us, womble->teacher }));
       }
     } else {
       tell_object(womble->taught, "Something went wrong learning " +
                   womble->skill + " from " + womble->teacher->query_short() +
                   ".\n");
     }
   womble->taught->remove_respond_command(TEACH_SKILL_TYPE, womble->teacher);
}
mixed *query_patterns() {
   return ({ "<string'skill/command'> from <indirect:living>",
             (: cmd($4[0], $1) :) });
}

==================================================
FILE: living/lie.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("lie", "down", LYING);
}

==================================================
FILE: living/lo_se.c
==================================================

inherit "/cmds/base";
mixed cmd(object *obs, string str) {
  object *ok, ob;
  string s;
  if (str == "everyone")
    obs = this_player()->query_followers();
  if (!sizeof(obs)) {
    write("You are not being followed by anyone.\n");
    return 1;
  }
  ok = ({ });
  foreach (ob in obs)
    if (this_player()->remove_follower(ob))
      ok += ({ ob });
  if (!sizeof(ok)) {
    if (member_array(this_player(), obs) == -1)
      return notify_fail("You are not being followed by "+
                         query_multiple_short(obs)+".\n");
    else
      return notify_fail("You are not being followed by " +
                         query_multiple_short(obs - ({this_player()}) +
                                              ({"yourself"})) + ".\n");
  }
  write("You lose "+(s=query_multiple_short(ok))+".\n");
  say(this_player()->the_short()+" loses "+s+".\n", ok);
  foreach (ob in ok)
    tell_object(ob, this_player()->the_short() + " loses " +
                query_multiple_short((ok + ({ "you" })) - ({ ob }))+".\n");
  return 1;
}
mixed *query_patterns() {
  return ({ "everyone", (: cmd(0, "everyone") :),
            "<indirect:living>", (: cmd($1, 0) :) });
}

==================================================
FILE: living/lsay.c
==================================================

#include <language.h>
#include <player.h>
#include <drinks.h>
#include <broadcaster.h>
inherit "/cmds/speech";
#define TP this_player()
mixed cmd(string arg) {
  int *co_ords;
  int status;
  class message mess;
  if (!arg)  arg = "";
  mess = build_message("@loudly " + arg, 0, "say");
  status = say_it(mess);
  if(status && TP && environment(TP))  {
    co_ords = environment(TP)->query_co_ord();
    BROADCASTER->npc_shout_event(TP, mess->notify_mess, mess->text,
                                 mess->language, co_ords, 20);
  }
  return status;
}
mixed *query_pattern() {
   return ({ "<string'message'>", (: cmd($4[0]) :) });
}

==================================================
FILE: living/meditate.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("meditate", "", MEDITATING);
}

==================================================
FILE: living/offer.c
==================================================

#include <money.h>
#include <cmds/offer.h>
inherit "/cmds/base";
int offer_sale(object *to_sell, object *sell_to, string amt, int each) {
   int value;
   int num;
   string *fluff;
   string place;
   string *gumboot;
   object *fail;
   class offer_sale wombat;
   fluff = MONEY_HAND->query_all_places();
   gumboot = ({ });
   foreach (place in fluff) {
      value = MONEY_HAND->value_from_string(amt, place);
      if (value) {
        gumboot += ({ place });
      }
   }
   if (!sizeof(gumboot)) {
      add_failed_mess("Unable to understand the value of " + amt + ".\n",
                      to_sell);
      return 0;
   }
   if (member_array("Ankh-Morpork", gumboot) != -1) {
      gumboot = ({ "Ankh-Morpork" });
   }
   if (sizeof(gumboot) > 1) {
      add_failed_mess("Too many types of currency matched, matched currency "
                      "from " + query_multiple_short(gumboot) + ", try and "
                      "be more specific.  ie:  Ankh-Morpork dollars, not just "
                      "dollars.\n",
                      to_sell);
      return 0;
   }
   fail = this_player()->query_ignoring(sell_to);
   if (sizeof(fail)) {
      sell_to -= fail;
      if (!sizeof(sell_to)) {
         add_failed_mess("You cannot offer anything to $I since you are "
                         "ignoring them.\n", fail);
         return 0;
      }
   }
   fail = this_player()->query_ignored_by(sell_to);
   if (sizeof(fail)) {
      sell_to -= fail;
      if (!sizeof(sell_to)) {
         add_failed_mess("You cannot offer anything to $I since they are "
                         "ignoring you.\n", fail);
         return 0;
      }
   }
   place = gumboot[0];
   value = MONEY_HAND->value_from_string(amt, place);
   if (value < 0) {
      add_failed_mess("The value of the item was set too high.\n");
      return 0;
   }
   if (sizeof(sell_to) > 1) {
      add_failed_mess("Attempted to sell to $I, cannot sell to more than "
                      "one person.\n", sell_to);
      return 0;
   }
   if (sell_to[0] == this_player()) {
      add_failed_mess("You cannot sell $I to yourself.\n", to_sell);
      return 0;
   }
   if (each) {
      num = 0;
      foreach(object item in to_sell) {
          if ( item->query_collective() || item->query_continuous() ) {
             num += item->query_amount();
          }
          else {
             num++;
          }
      }
      value = value * num;
   }
#ifdef CHECK_MONEY
   if (sell_to[0]->query_value_in(gumboot[0]) < value) {
      add_failed_mess(sell_to[0]->the_short() + " does not have enough money "
                      "to buy $I.\n", to_sell);
      return 0;
   }
   if (!MONEY_HAND->query_person_payments(value, gumboot[0], sell_to[0], this_player())) {
      add_failed_mess(sell_to[0]->the_short() + " does not have the correct "
                      "change to pay " +
                      MONEY_HAND->money_value_string(value, gumboot[0]) +
                      " (and you do not have change to give back).\n");
      return 0;
   }
#endif
   wombat = new(class offer_sale);
   wombat->sell_obs = to_sell;
   wombat->seller = this_player();
   wombat->buyer = sell_to[0];
   wombat->value = value;
   wombat->place = gumboot[0];
   sell_to->add_respond_command("sell", this_player(), wombat);
   tell_object(sell_to[0],
               "You can accept the offer by typing:\n"
               "accept offer from " + this_player()->query_name() + "\n");
   add_succeeded_mess("$N offer$s to sell $I to " + sell_to[0]->the_short() +
                      " for " + MONEY_HAND->money_value_string(value,
                                            gumboot[0]) + ".\n", to_sell);
   return 1;
}
mixed *query_patterns() {
   return ({
 "<indirect:object:me'sell object'> to <indirect:living> for <string>",
             (: offer_sale($1[0], $1[1], $4[2], 0) :),
 "<indirect:object:me'sell object'> to <indirect:living> for <string> each",
             (: offer_sale($1[0], $1[1], $4[2], 1) :) });
}

==================================================
FILE: living/protect.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *things) {
  int i;
  object *protectees;
  things -= ({ TP });
  if ( !sizeof( things ) ) {
     add_failed_mess("You cannot protect yourself!\n");
     return 0;
  }
  if ( TP->query_property( "dead" ) ) {
    add_failed_mess("You cannot provide much protection as a ghost.\n" );
    return 0;
  }
  protectees = ({ });
  for ( i = 0; i < sizeof( things ); i++ ) {
    if ( things[ i ]->add_protector( TP ) ) {
      protectees += ({ things[ i ] });
      things = delete( things, i, 1 );
      i--;
    }
  }
  if ( !sizeof( protectees ) ) {
    add_failed_mess("You cannot protect $I.\n", things);
    return 0;
  }
  if ( sizeof( things ) ) {
    write( "You cannot protect "+ query_multiple_short( things ) +".\n" );
  }
  add_succeeded_mess(({ "You will protect $I.\n",
                        "$N moves to protect $I.\n" }),
	                protectees);
  return 1;
}
int show_protectors() {
   object *protect;
   object womble;
   protect = this_player()->query_protectors();
   if (sizeof(protect)) {
      write("You are being protected by " + query_multiple_short(protect) +
            ".\n");
   } else {
      write("You are not being protected by anyone.\n");
   }
   protect = ({ });
   foreach (womble in all_inventory(environment(this_player()))) {
      if (living(womble) && womble != this_player()) {
         if (member_array(this_player(), womble->query_protectors()) != -1) {
            protect += ({ womble });
         }
      }
   }
   if (sizeof(protect)) {
      write("Of the people in this room, you are protecting " +
            query_multiple_short(protect) + ".\n");
   } else {
      write("You are not protecting anyone in this room.\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:living>",
             (: cmd($1) :),
             "",
             (: show_protectors() :) });
}

==================================================
FILE: living/put.c
==================================================

#include <move_failures.h>
#include <player.h>
#define MAX_PUT_NUMBER 20
inherit "cmds/base";
#define TP this_player()
string con;
mixed cmd(mixed *indir,
          string *indir_match,
          string *args)
{
   string person;
   string thing;
   string sh;
   int tot;
   int max;
   object *per;
   object *ret;
   object *fail;
   object pobj;
   object ob;
   object *obs;
   object *succ;
   object *too_many;
   int num;
   con = args[1];
   per = indir[1];
   thing = indir_match[0];
   person = indir_match[1];
   succ = ({ });
   too_many = ({ });
   foreach(pobj in per) {
      if (living(pobj) && !pobj->query_living_container()) {
         tell_object(TP,
                     "You cannot put things " + con + " living things.\n");
         continue;
      }
      obs = indir[0];
      obs -= per;
      if (!sizeof(obs)) {
         tell_object(TP, "Nothing to " + query_verb() + " " + con + " " +
                     inside_the_short(pobj) + ".\n");
         continue;
      }
      if (!is_in_me_or_environment(pobj, this_player())) {
         add_failed_mess("Cannot $V $I " + con + " " + pobj->the_short() +
                         ".\n", obs);
         continue;
      }
      ret = ({ });
      fail = ({ });
      foreach(ob in obs) {
         if (member_array(ob, succ) > -1) {
            continue;
         }
         if (num > MAX_PUT_NUMBER) {
            too_many += ({ ob });
            continue;
         }
         if (function_exists("do_put", ob) ||
             function_exists("command_control", ob)) {
            if (function_exists("do_put", ob)) {
               max = (int) call_other(ob, "do_put", pobj, thing, person,
                                      ({ thing, person }),
                                      "<direct:object> " + con +
                                      " <indirect:object>");
            } else {
               max = ob->command_control("put", pobj, thing, person,
                                         ({ thing, person }),
                                         "<indirect:object> " +
                                         con + " <indirect:object>");
            }
            if (max == 0) {
               fail += ({ ob });
               continue;
            }
         }
         if (pobj->query_closed() || ob->move(pobj) != MOVE_OK) {
            fail += ({ ob });
         } else {
            ret += ({ ob });
            tot += (int) ob->query_weight();
#ifndef __DISTRUBUTION_LIB__
            if(interactive(TP))
              PLAYER_MULTIPLAYER_HANDLER->record_object("dropped", TP, ob);
#endif
            num++;
         }
      }
      if (sizeof(ret)) {
         succ += ret;
         sh = query_multiple_short(ret);
         add_succeeded_mess("$N $V $I " + con + " " +
                            inside_the_short(pobj) + ".\n", ret);
      }
      if (sizeof(fail)) {
         add_failed_mess("You cannot $V $I " + con + " " +
                         inside_the_short(pobj) + ".\n", fail);
      }
   }
   if (sizeof(too_many)) {
      if (sizeof(succ) > 0) {
         add_succeeded_mess(({ "You cannot handle more than " +
                               query_num(MAX_PUT_NUMBER) +
                               " objects with $V; discarding $I.\n", "" }),
                            too_many);
      } else {
         add_failed_mess("You cannot handle more than " +
                         query_num(MAX_PUT_NUMBER) +
                         " objects with $V; discarding $I.\n", too_many);
      }
   }
   return sizeof(succ) > 0;
}
string query_con() {
  return con;
}
mixed *query_patterns()
{
   return ({ "<indirect:object:me> {in|on|into} <indirect:object>",
             (: cmd($1, $3, $4) :) });
}

==================================================
FILE: living/r_ead.c
==================================================

#include <language.h>
inherit "/cmds/base";
varargs string create_text( object thing, int label );
mixed cmd( object *things ) {
   string gendstr;
   string text;
   string read;
   string reader;
   string *others;
   string r_short;
   object thing;
   mapping hide_invis;
   int dark;
   dark = this_player()->check_dark(environment(this_player())->query_light());
   if (dark < 0) {
      add_failed_mess("It is too dark to read $I.\n", things);
      return 0;
   }
   if (dark > 0) {
      add_failed_mess("It is too bright to read $I.\n", things);
      return 0;
   }
   reader = "";
   others = ({ });
   foreach( thing in things ) {
      if (!is_in_me_or_environment(thing, this_player())) {
          add_failed_mess("You cannot read $I.\n", ({ thing }));
          continue;
      }
      text = thing->query_readable_message(this_player());
      read = thing->query_read_short();
      if (!read) {
         read = "$name$";
      }
      if ( !text) {
        if (living(thing)) {
            gendstr = thing->query_objective();
        } else {
           gendstr = "it";
        }
        r_short = thing->query_read_short();
        if (!r_short) {
           r_short = "$name$";
        }
        if (!thing->command_control("read")) {
            if (thing != this_player()) {
               reader += "$C$"+ replace_string(r_short,
                                        "$name$",
                                        thing->a_short()) +
                     " does not have anything written on " +
                     gendstr + ".\n";
            } else {
               reader += "You cannot read yourself.\n";
            }
         } else {
            others += ({ replace( read, "$name$", (string)thing->a_short() ) });
            reader += "";
         }
         continue;
      }
      reader += "You read "+ replace_string( read, "$name$",
            (string)thing->the_short() ) +":\n"+ text + "\n";
      if ( read == "$name$" ) {
          others += ({ thing });
      }
      else {
          others += ({ replace( read, "$name$", (string)thing->a_short() ) });
      }
   }
   if ( !sizeof( others ) ) {
      add_failed_mess(reader);
      return 0;
   }
   write( "$P$Read$P$"+ reader );
   hide_invis = this_player()->query_hide_invis();
   if(!hide_invis["hiding"]) {
      add_succeeded_mess(({ "", "$N read$s $I.\n" }), others);
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object>", (: cmd($1) :) });
}

==================================================
FILE: living/remove.c
==================================================

#include <clothing.h>
#include <tasks.h>
#define SKILL "covert.manipulation.sleight-of-hand"
#ifdef DEBUG
#define TELL_ME "presto"
#endif
inherit "cmds/base";
int cmd(object *things)  {
   object  *removed = ({ });
   object  *blocking = ({ });
   object  *blocked;
   object  *total_blocking = ({ });
   object  *succeeded;
   object  *failed;
   object  *failed_rewear;
   object   ob;
   object   blocker;
   mapping  is_blocking = ([ ]);
   mapping  hide_invis;
   string   tmp1;
   string   tmp2;
   int      last_blocking;
   int      limit;
   int      i;
   int      hiding;
   int      sneaking;
   int      difficulty;
   int      light;
   int      my_light;
   succeeded = this_player()->query_wearing();
   failed = filter(things, (: member_array($1, $(succeeded)) == -1 :));
   things -= failed;
   if (sizeof(things) == 0)  {
      write("You are not wearing " + query_multiple_short(failed, "the") +
            ".\n");
      return 1;
   }
   succeeded = things;
   for (i = 0; i < sizeof(succeeded); i++)  {
      ob = succeeded[i];
      blocking = CLOTHING_HANDLER->query_items_blocking(ob, this_player()) -
                 ({ ob });
      if (sizeof(blocking))  {
         foreach (blocker in blocking)  {
            if (undefinedp(is_blocking[blocker]))
               is_blocking[blocker] = ({ ob });
            else
               is_blocking[blocker] |= ({ ob });
         }
         total_blocking |= blocking;
         succeeded = ({ things..., total_blocking... });
      }
   }
   total_blocking = ({ });
   foreach (ob, blocked in is_blocking)  {
#ifdef DEBUG
      if (this_player() == find_player(TELL_ME))
      tell_creator(TELL_ME, "ob == %s, blocked == %O\n",
                   ob->short(), blocked->short());
#endif
      last_blocking = -1;
      for (i = sizeof(total_blocking) - 1; i >= 0; i--)  {
         if (member_array(ob, is_blocking[total_blocking[i]]) > -1)  {
            last_blocking = i;
            break;
         }
      }
      if (last_blocking == -1)  {
         total_blocking = ({ ob, total_blocking... });
#ifdef DEBUG
         if (this_player() == find_player(TELL_ME))
            tell_creator(TELL_ME, "Nothing is blocking ob, adding it to "
                         "the beginning\n%O\n", total_blocking->short());
#endif
         continue;
      }
      total_blocking = ({ total_blocking[0 .. last_blocking]...,
                          ob,
                          total_blocking[(last_blocking + 1) .. ]... });
#ifdef DEBUG
      if (this_player() == find_player(TELL_ME))
         tell_creator(TELL_ME, "Adding ob after last_blocking position "
                      "(%d)\n%O\n",
                      last_blocking, total_blocking->short());
#endif
      limit = last_blocking;
      blocking = copy(blocked);
      for (i = 0; i < limit; i++)  {
         if (member_array(total_blocking[i], blocking) > -1)  {
            blocking += is_blocking[total_blocking[i]];
            if (i == 0)
               total_blocking =
                  ({ total_blocking[1 .. (last_blocking + 1)]...,
                     total_blocking[0],
                     total_blocking[(last_blocking + 2) .. ]... });
            else
               total_blocking =
                  ({ total_blocking[0 .. (i - 1)]...,
                     total_blocking[(i + 1) .. (last_blocking + 1)]...,
                     total_blocking[i],
                     total_blocking[(last_blocking + 2) .. ]... });
            --limit;
            --i;
#ifdef DEBUG
            if (this_player() == find_player(TELL_ME))
               tell_creator(TELL_ME, "Reordered list:\n%O\n",
                            total_blocking->short());
#endif
         }
      }
   }
   foreach (blocker in total_blocking)  {
      tmp1 = CLOTHING_HANDLER->can_wear_or_remove(blocker, this_player());
      if (tmp1)  {
         write("You cannot remove " +
               query_multiple_short(is_blocking[blocker], "the") +
               " " + tmp1 + ".\n");
         things -= is_blocking[blocker];
         break;
      }
      else if (this_player()->remove_armour(blocker))  {
         write("You cannot remove " +
               query_multiple_short(is_blocking[blocker], "the") +
               " because you cannot remove " + blocker->one_short() + ".\n");
         things -= is_blocking[blocker];
         break;
      }
      else removed += ({ blocker });
   }
   succeeded = things & removed;
   failed = ({ });
   foreach (ob in things - removed)  {
      if (this_player()->remove_armour(ob))
         failed += ({ ob });
      else
         succeeded += ({ ob });
   }
   if (sizeof(succeeded) > 0)  {
      removed -= things;
      tmp2 = query_multiple_short(succeeded, "the") ;
      if (sizeof(removed) > 0)  {
         tmp1 = query_multiple_short(removed, "the");
         write("You remove " + tmp1 + " so you can remove " + tmp2 + ".\n");
         say(this_player()->the_short() + " removes " + tmp1 + " so " +
             this_player()->query_pronoun() + " can remove " + tmp2 + ".\n");
      }
      else  {
        hide_invis = ( mapping )this_player()->query_hide_invis();
        hiding = hide_invis[ "hiding" ] ? 1 : 0;
        sneaking = this_player()->query_sneak_level() ? 1 : 0;
        if( hiding || sneaking ) {
          my_light = this_player()->query_light();
          light = environment( this_player() )->query_light();
          difficulty = light + ( 4 * my_light ) / ( light + 1 );
          difficulty += succeeded[0]->query_complete_weight();
          debug_printf( "Difficulty = %d.\n Skill = %s\n Bonus = %d\n",
                        difficulty, SKILL, this_player()->
                        query_skill_bonus( SKILL ) );
          switch( TASKER->perform_task( this_player(), SKILL, difficulty,
            TM_FREE ) ) {
            case AWARD :
              write( "%^YELLOW%^" + ({
                "You discover something that lets your fingers move more "
                  "nimbly.",
                "You find yourself capable of deceiving the eye with greater "
                  "ease than before.",
                "You realise how to deceive the eye more effectively."
              })[ random(3) ] + "%^RESET%^\n" );
            case SUCCEED :
              add_succeeded_mess( ({ "$N $V " + tmp2 + ", managing to stay "
                "unnoticed.\n",
                "" }) );
              break;
            default :
              this_player()->add_succeeded_mess( this_object(), "$N "
                "unsuccessfully tr$y to " + query_verb() + " " + tmp2 +
                " while staying unnoticed.\n", ({ }) );
              break;
          }
        } else {
          this_player()->add_succeeded_mess( this_object(), "$N $V " + tmp2 +
            ".\n", ({ }) );
        }
      }
   }
   succeeded = ({ });
   failed_rewear = ({ });
   foreach (ob in removed)  {
      if (this_player()->wear_armour(ob))
         failed_rewear += ({ ob });
      else
         succeeded += ({ ob });
   }
   if (sizeof(succeeded) > 0)  {
      this_player()->force_burden_recalculate();
      tmp1 = query_multiple_short(succeeded, "the");
      write("You wear " + tmp1 + ".\n");
      say(this_player()->the_short() + " wears " + tmp1 + ".\n");
   }
   if (sizeof(failed_rewear) > 0)  {
      write("You cannot put " +
            query_multiple_short(failed_rewear, "the") + " back on.\n");
   }
   if (sizeof(failed) > 0)  {
      write("You cannot remove " + query_multiple_short(failed, "the") +
            ".\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:me>", (: cmd($1) :) });
}

==================================================
FILE: living/sa_y.c
==================================================

#include <language.h>
#include <player.h>
#include <drinks.h>
inherit "cmds/base";
inherit "cmds/speech";
mixed cmd(string arg) {
  class message mess;
  mess = build_message(arg, 0, "say");
  return say_it(mess);
}

==================================================
FILE: living/sayto.c
==================================================

#include <language.h>
#include <player.h>
#include <drinks.h>
inherit "cmds/base";
inherit "/cmds/speech";
#define TP this_player()
mixed cmd(object *obs, string str) {
  class message mess;
  obs = filter(obs, (: $1 && $1 != this_player() :));
  if(!sizeof(obs)) {
    return notify_fail("Be serious.\n");
  }
  mess = build_message(str, obs, "say");
  return say_it_to(mess, obs, 0, "person_say");
}
mixed *query_patterns() {
   return ({ "<indirect:living> <string>", (: cmd($1, $4[1]) :) });
}

==================================================
FILE: living/sh_out.c
==================================================

#include <player.h>
#include <drinks.h>
#include <language.h>
#include <cmds/options.h>
#include "/d/am/path.h"
inherit "/cmds/base";
inherit "/cmds/speech";
#define TP this_player()
#define BEEP sprintf("%c",7)
#define NO_QUIT_INVENTORY 1
#define NO_QUIT_COMBAT    2
#define BROADCASTER "/obj/handlers/broadcaster"
int query_no_quit();
string query_shout_word_type(string str);
void my_mess(string fish, string erk);
mixed cmd(string str) {
  string s1, s2, s;
  object g;
  string cur_lang;
  object lag;
  int tim, cost;
  if(!str || str == "")
    return notify_fail("Syntax : shout <text>\n");
  if (!environment(this_player()))
    return notify_fail( "You appear to be in limbo...\n" );
  if(TP->query_property("dead") == 1)
    return notify_fail("You don't have any lungs, how can you shout?\n");
  if (TP->check_earmuffs("shout"))
    return notify_fail("Why shout when you can't hear people "
                       "shout back?\n");
  cur_lang = TP->query_current_language();
  if (!LANGUAGE_HAND->query_language_spoken(cur_lang))
    return notify_fail(capitalize(cur_lang)+" is not a spoken language.\n");
  if (!LANGUAGE_HAND->query_language_distance(cur_lang))
    return notify_fail(capitalize(cur_lang)+" is not able to spoken "
                       "at a distance.\n");
  if (TP->query_invis())
    return notify_fail("Invisible people cannot shout, they cannot "
                       "see their arm in front of their face.  Shouting is "
                       "out of the question.\n");
  if (TP->query_property("gagged"))
    return notify_fail("You have been gagged!  You will not be able "
                       "to shout again until the gag is removed.  Perhaps "
                       "you should talk to a creator about this.\n");
  if (TP->query_property("recently shouted")) {
    return notify_fail("You have shouted very recently, perhaps you "
                       "should give your lungs a small break and try again "
                       "in a couple seconds.\n");
  }
  if(TP->query_property("player") == 1 && !TP->query_creator()) {
    cost = SHOUT_COST * ((strlen(str) / 5) + 1);
    cost += sizeof(filter(explode(str, ""), (: $1 <= "Z" :))) / 2;
    if(TP->adjust_sp(-cost) < 0)
      return notify_fail(NO_POWER);
    TP->adjust_max_sp(- (cost / 5));
  }
  if (!interactive(TP)) {
    str = TP->convert_message( str );
    str = TP->fit_message( str );
  }
  s1 = query_shout_word_type(str);
  if (s1 != "yell")
    s = "shouts" + s1;
  else
    s = s1 + "s";
  if(TP->query_property(SHORTHAND_PROP))
    str = fix_shorthand(str);
  if(TP->query_volume( D_ALCOHOL))
    str = drunk_speech( str );
  TP->remove_hide_invis("hiding");
  if (s1 != "yell") {
    if (cur_lang != "common") s1 += " in " + capitalize(cur_lang);
    my_mess("You shout" + s1 + ": ", str);
  } else {
    if (cur_lang != "common") s1 += " in " + capitalize(cur_lang);
    my_mess("You " + s1 + ": ", str);
  }
  s2 =  " " + lower_case(str);
  if (sscanf(" "+s2, "%s eight%s", s1, s1)==2 ||
      sscanf(s2, "%s8%s", s1, s1)==2) {
    s1 = replace(str, ({ "8", "", " eight", "", " ", "" }));
    switch (query_no_quit()) {
    case NO_QUIT_INVENTORY:
      return notify_fail("You only just arrived.  You are far too "
                         "busy strapping on equipment to shout like that.\n");
    case NO_QUIT_COMBAT:
      return notify_fail("You are too busy fighting to shout "
                         "like that.\n");
    default:
      if (s1 == "") {
        write("Oops...\n");
        call_out( "summon_bel_shamharoth", 10, TP );
      }
      else {
        g = (object)TP->query_guild_ob();
        if (random(100) < 40 ||
            (g && (string)g->query_name() == "wizards"))
          write("Oops...\n");
        call_out( "summon_bel_shamharoth", 10, TP );
      }
    }
  }
  lag = load_object(SHORT + "short20")->lag_for_shout();
  if(lag && sscanf(" "+lower_case(s2), "%*s lag%*s") == 2) {
    tim = TP->query_property("lag shout time");
    TP->add_property("lag shout time", time(), 300);
    if((tim + 300 > time()) && lag != TP) {
      switch (query_no_quit()) {
      case NO_QUIT_INVENTORY:
        lag->init_command("hug "+ TP->query_name() +
                          " Welcome to " + mud_name() + "", 0);
        return notify_fail("The air is suddenly squeezed out "
                           "of you.\n");
      case NO_QUIT_COMBAT:
        lag->init_command("wedgie " + TP->query_name(), 0);
        return notify_fail("You are rudely interrupted "
                           "mid-shout.  Fortunately you are not distracted "
                           "from the fight.\n");
      default:
        call_out( "summon_bel_shamharoth", 10, TP, 1);
      }
    }
  }
  if(environment(this_player()) &&
     environment(this_player())->query_property("location") == "inside")
    tim = 10;
  else
    tim = 3;
  user_event( this_player(), "person_shout",
              (string)this_player()->a_short() +" "+ s,
              str, cur_lang,
              (int *)environment( this_player() )->query_co_ord(),
              ( 100 * ( (int)this_player()->query_con() +
                        (int)this_player()->query_str() ) ) / tim );
  environment(TP)->event_person_shout( 0, (string)TP->a_short() +" "+ s,
                                       str + "%^RESET%^", cur_lang );
  BROADCASTER->npc_shout_event(TP, (string)TP->a_short() +" "+ s,
                               str + "%^RESET%^", cur_lang,
                               (int *)environment(TP)->query_co_ord(),
                               (100 * ((int)TP->query_con() +
                                       (int)TP->query_str() ) ) / 3);
  if (TP->query_property("player") == 1 && !TP->query_creator()) {
    TP->add_property("recently shouted", 1, 2);
  }
  return 1;
}
string query_shout_word_type(string str) {
  switch (str[<1]) {
  case '!':
    return "yell";
  case '?':
    return " asking";
  default:
    return "";
  }
}
void my_mess(string fish, string erk) {
  if(!interactive(TP))
    return;
  printf("%s%-=*s\n", fish, TP->query_cols() - strlen(fish),
         TP->fix_string(erk));
}
void summon_bel_shamharoth(object who, int lag_shout) {
  object env;
  if (!who || !objectp(who))
    return;
  if (!random(3))
    who->adjust_tmp_con(-2);
  if (!random(3))
    who->adjust_tmp_int(-2);
  if (!random(3))
    who->adjust_tmp_wis(-2);
  if (!random(3))
    who->adjust_tmp_dex(-2);
  env = environment(who);
  if ("/secure/master"->query_lord(geteuid(who))) {
    BROADCASTER->broadcast_event(users(),
                                 (int *)env->query_co_ord(),
                 "The heavens shake with a hideous roar and just as suddenly "
                 "all is quiet.\n$C$"+ who->query_name() + " chuckles in the "
                 "distance.\n",
                                 ( 100 * ( (int)who->query_con() +
                                           (int)who->query_str() ) ) / 3,
                                 1, 0);
    tell_object(who, "Your lordliness saves you from a grizzly "
                "encounter with the Sender of Eight.\n");
  } else {
    BROADCASTER->broadcast_event(users(),
                                 (int *)env->query_co_ord(),
                             "a sudden chill passes through the land as $C$" +
                           who->query_name() + " is carried off screaming "
                           "to the land of shades.\n",
                                 ( 100 * ( (int)who->query_con() +
                                           (int)who->query_str() ) ) / 3,
                                 1, 0);
    tell_object( who, "You think you'd best be careful what you "
                 "shout in the future as shadowy tentacles drag you "
                 "into the ground...\n" );
    if(lag_shout)
      BROADCASTER->broadcast_event(users(),
                                   (int *)env->query_co_ord(),
                                   ( 100 * ( (int)who->query_con() +
                  "The heavens shake with a hideous chuckle and in the "
                  "distance a booming yet apologetic voice says: Oops.\n",
                                             (int)who->query_str() ) ) / 3,
                                   1, 0);
    if(base_name(env) != "/room/departures")
      who->quit();
  }
}
int query_no_quit() {
  if (TP->query_save_inhibit() || TP->query_auto_loading()) {
    return NO_QUIT_INVENTORY;
  }
  if (sizeof(filter_array(TP->query_attacker_list(), (: living($1) :)))) {
    return NO_QUIT_COMBAT;
  }
  return 0;
}

==================================================
FILE: living/sheathe.c
==================================================

#include <move_failures.h>
inherit "/cmds/base";
int cmd( object * weapons, object * scabbards ) {
   object weapon;
   object scabbard;
   if( sizeof(weapons) > 1 ) {
      add_failed_mess( "You can only sheathe one thing at a time.\n" );
      return 0;
   }
   weapon = weapons[0];
   if ( ( scabbard = environment( weapon ) )->query_scabbard() &&
        scabbard->test_type_ok( weapon ) ) {
      add_failed_mess( weapon->the_short() + " is already sheathed.\n" );
      return 0;
   }
   if ( environment( weapon ) != this_player() ) {
      add_failed_mess( weapon->the_short() + " is not in your inventory.\n" );
      return 0;
   }
   if ( scabbards ) {
      if ( sizeof(scabbards) > 1 ) {
         add_failed_mess( "For shame! Trying to sheathe your weapon "
           "in more than one object at a time?\n" );
         return -1;
      }
      scabbard = scabbards[0];
      if ( !scabbard->query_scabbard() ) {
         add_failed_mess( scabbard->the_short() + " is not even a "
           "scabbard!\n" );
         return -1;
      }
      if( !scabbard->test_type_ok( weapon ) ) {
        return add_failed_mess( "$C$"+scabbard->the_short() + " is not a "
                                "suitable scabbard for " + weapon->a_short()
                                + ".\n" );
      }
   } else {
      scabbards = filter( all_inventory( this_player() ),
                          (: $1->query_scabbard() &&
                             $1->test_type_ok( $(weapon) ) :) );
      if ( !sizeof( scabbards ) ) {
         return add_failed_mess( "Can't find any suitable scabbards in "
           "your inventory.\n" );
      }
      scabbards = filter( scabbards, (: $1->test_add( $(weapon), 0, 1 ) :) );
      if ( !sizeof(scabbards) ) {
         return add_failed_mess( "Can't find any empty scabbards in your "
           "inventory.\n" );
      }
      scabbard = scabbards[0];
   }
   if ( weapon->query_wielded() &&
       !sizeof( this_player()->set_unhold(weapon) ) )
   {
      return add_failed_mess( "You cannot let go of " + weapon->the_short()
        + ".\n" );
   }
   if ( weapon->move(scabbard) != MOVE_OK ) {
      this_player()->add_failed_mess( scabbard, "You cannot $V $I in $D.\n",
        ({ weapon }) );
      return 0;
   }
   this_player()->add_succeeded_mess( scabbard, "$N $V $I in $D.\n",
     ({ weapon }) );
   return 1;
}
mixed * query_patterns() {
   return ({
      "<indirect:object:me'weapon'>",
        (: cmd( $1, 0 ) :),
      "<indirect:object:me'weapon'> in <indirect:object:me'scabbard'>",
        (: cmd( $1[0], $1[1]) :)
   });
}

==================================================
FILE: living/show.c
==================================================

#include <command.h>
#define READ ( DIR_LIVING_CMDS "/r_ead" )
inherit "/cmds/base";
int do_show_object( object shower, object item, object owner, object target, int no_mess );
#ifdef DEBUG
int notify_fail(string str) {
  tell_object(find_player("tape"), "%^YELLOW%^"+
              this_player()->query_short()+" "+str+"%^RESET%^\n");
  return efun::notify_fail(str);
}
#endif
int cmd( object item, object target )
{
   return do_show_object( this_player(), item, this_player(), target, 0 );
}
int do_show_object( object shower, object item, object owner, object target, int nomess )
{
   tell_creator( shower, "%O\n%O\n", item, target );
   if( target == shower ) {
      add_failed_mess( "Why not just look at it?\n");
      return 0;
   }
   if( !shower->query_visible( target ) ) {
      add_failed_mess( "It appears that " + target->the_short() +
         " can't see you or your item.\n" );
      return 0;
   }
   if( target->query_property( "ignoring" ) ) {
      if( member_array( shower->query_name(),
         target->query_property( "ignoring" ) ) != -1 ) {
         add_failed_mess( target->the_short() + " ignores you.\n" );
         return 0;
      }
   }
   if( item->query_worn_by() ) {
      add_failed_mess( item->the_short() + " must be removed before it can be "
         "shown.\n" );
      return 0;
   }
   target->add_respond_command( "show offer", this_object(),
      ({ item, owner, shower }) );
   if( !nomess )
   {
      tell_room( environment( shower ), shower->the_short() +
         " offers to show " + item->a_short() + " to " +
         target->a_short() + ".\n",
         ({ target, shower }) );
      tell_object( shower, "You offer " + item->the_short() +
         " to " + target->the_short() + " for inspection.\n" );
      tell_object( target, shower->the_short() + " offers you " +
         item->a_short() + " for inspection.  Use \"show accept offer "
         "from " + shower->query_name() + "\" to view it.\n" );
   }
   return 1;
}
int accept_show( object target, int read ) {
   mixed *stuff;
   object from;
   object owner;
   object item;
   string message;
   if( target == this_player() ) {
      add_failed_mess( "You cannot show stuff to yourself.\n");
      return 0;
   }
   stuff = this_player()->query_respond_command(
      "show offer", this_object() );
   if( !sizeof( stuff ) ) {
      add_failed_mess( "No one has offered to show you anything.\n");
      return 0;
   }
   item     = stuff[ 0 ];
   owner    = stuff[ 1 ];
   from     = stuff[ 2 ];
   if( !from || target != from ) {
      add_failed_mess( target->the_short() + " hasn't offered "
         "to show you anything.\n" );
      return 0;
   }
   if( !item || ( owner && environment( item ) != owner ) )
   {
      add_failed_mess( "It appears that " + target->the_short() +
         " has misplaced " + target->query_possessive() + " item.\n");
      return 0;
   }
   this_player()->remove_respond_command( "show offer", this_object() );
   tell_room( environment( this_player() ), this_player()->the_short() +
      " accepts the offer from " +
      target->the_short() +
      " to see " + item->the_short() + ".\n", ({ this_player(), target }) );
   message = "You accept " + target->the_short() + "'s offer.\n";
   tell_object( target, "You show " + item->the_short() + " to " +
      this_player()->the_short() + ".\n" );
   message += "\n";
   if( this_player()->query_creator() ) {
      message += "%^CYAN%^" + file_name( item ) + ":%^RESET%^\n";
   }
   message += item->long();
   if( sizeof( item->query_read_mess() ) ) {
      message += item->the_short() + " also contains some writing.\n";
      message += item->query_readable_message(this_player());
   }
   write("$P$Show$P$" + message);
   return 1;
}
mixed *query_patterns() {
   return ({
      "<indirect:object:me'item'> to <indirect:living'living'>",
         (: cmd( $1[ 0 ][ 0 ], $1[ 1 ][ 0 ] ) :),
      "accept [offer] [from] <indirect:living'living'>",
         (: accept_show( $1[ 0 ], 0 ) :) });
}

==================================================
FILE: living/sit.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   if(this_player()->query_position() == "lying")
     setup_position("sit", "up", SITTING);
   else
     setup_position("sit", "down", SITTING);
}

==================================================
FILE: living/sp_eak.c
==================================================

inherit "/cmds/base";
#include <language.h>
#define TP this_player()
int cmd(string which)
{
   string *langs;
   string skill;
   int i;
   mapping skills;
   skills = TP->query_skills();
   if (!which) {
      langs = LANGUAGE_HAND->query_languages();
      for (i = 0; i < sizeof(langs); i++) {
         if (TP->
             query_skill(LANGUAGE_HAND->
                         query_language_spoken_skill(langs[i])) > 1
             || TP->query_skill(LANGUAGE_HAND->
                                query_language_written_skill(langs[i])) > 1) {
         } else {
            langs = langs[0..i - 1] + langs[i + 1..];
            i--;
         }
      }
      write("You are currently speaking " +
            cap_words(TP->query_current_language()) + " and your default "
            "language is " + cap_words(TP->query_default_language()) + ".\n");
      write("You can speak " +
            query_multiple_short(map(langs, (: cap_words :)) +
                                 ({ "Grunt" })) + ".\n");
      write("Please note that the language you are speaking is used for "
            "writing as well, so some of the languages may be just written.\n");
      return 1;
   }
   which = lower_case(which);
   skill = LANGUAGE_HAND->query_language_spoken_skill(which);
   if (!skill) {
      return notify_fail("You cannot speak that language.\n");
   }
   if((!TP->query_skill(skill) && which != "grunt" && which != "general") ||
      (which == "general" && !TP->query_creator() && interactive(TP)))
      return notify_fail("You don't know that language.\n");
   if (which == this_player()->query_current_language()) {
      add_failed_mess("You are already speaking " + cap_words(which) + ".\n");
      return 0;
   }
   if (!TP->set_language(which)) {
      return notify_fail("Argh... something weird happened.\n");
   }
   write("Now using " + cap_words(which) + " for speaking and writing.\n");
   return 1;
}
mixed *query_patterns()
{
   string *languages;
   string tmp;
   languages = LANGUAGE_HAND->query_languages();
   if ( TP->query_womens_day() ) {
       languages += ({ "wommon" });
   }
   tmp = implode(languages + map(languages, (: cap_words :)), "|");
   return ({ "{" + tmp + "}", (: cmd(implode($4, " ")) :),
             "", (: cmd(0) :) });
}

==================================================
FILE: living/stand.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("stand", "up", STANDING);
}

==================================================
FILE: living/surr_ender.c
==================================================

inherit "/cmds/base";
mixed cmd(int mode, int val) {
  if (!mode) {
    int surr = this_player()->query_surrender();
    if (surr)
      write(sprintf("You will surrender at %d%% of your max hps.\n", surr));
    else
      write("You will not surrender.\n");
    return 1;
  } else {
    if (val < 0 || val > 100)
      return notify_fail("Your surrender must be between 0 and 100.\n");
    this_player()->set_surrender(val);
    write(sprintf("Surrender set to %d%%\n", this_player()->query_surrender()));
    return 1;
  }
}
mixed *query_patterns()
{
  return ({ "", (: cmd(0, 0) :),
            "<number>", (: cmd(1, $4[0]) :) });
}

==================================================
FILE: living/swim.c
==================================================

inherit "/cmds/position_base";
#include <position.h>
void create() {
   ::create();
   setup_position("swim", "around", SWIMMING);
}

==================================================
FILE: living/tactics.c
==================================================

inherit "/cmds/base";
#include <combat.h>
int cmd() {
  class tactics tactics;
  tactics = (class tactics) this_player()->query_tactics();
  write("Your combat options are:\n\n" );
  write("   Attitude - "+ tactics->attitude +".\n" );
  write("   Response - "+ tactics->response +".\n" );
#ifdef USE_SURRENDER
  write("   Mercy - "+ (tactics->mercy?tactics->mercy:"none") + ".\n");
#endif
  write("   Focus - "+ (tactics->focus_zone?tactics->focus_zone:"none") + ".\n" );
#ifdef USE_DISTANCE
  write("   Target distance - "+ (tactics->ideal_distance?tactics->ideal_distance:"none") + ".\n" );
#endif
  write("You will use "+
        (tactics->attack == "both" ? "both hands" :
         "your "+ (tactics->attack?tactics->attack:"either") +" hand" ) +
        " to attack.\n" );
  write("You will use "+
        (tactics->parry == "both" ? "both hands" :
         "your "+ (tactics->parry?tactics->parry:"either") +" hand" ) +
        " to parry.\n" );
  write("\nYou will"+ ( tactics->parry_unarmed ? " " : " not " ) +
        "attempt to parry unarmed.\n" );
  return 1;
}
int attitude(string word) {
  class tactics my_tactics;
  my_tactics = new(class tactics);
  my_tactics = (class tactics) this_player()->query_tactics();
  switch(word) {
  case "insane":
  case "offensive":
  case "neutral":
  case "defensive":
  case "wimp":
    if((my_tactics->attitude) == word) {
      write("Your attitude is already " + word + ".\n");
    } else {
      my_tactics->attitude = word;
      write("Your attitude is now " + word + ".\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail("Syntax: tactics attitude "
                       "insane|offensive|neutral|defensive|wimp.\n");
  }
}
int response(string word) {
  class tactics my_tactics;
  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "dodge":
  case "neutral":
  case "parry":
    if(my_tactics->response == word) {
      write("Your response is already " + word + ".\n");
    } else {
      my_tactics->response = word;
      write("Your response is now " + word + ".\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics response dodge|neutral|parry\n");
  }
}
int parry(string word) {
  class tactics my_tactics;
  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "unarmed":
    my_tactics->parry_unarmed = 1 - my_tactics->parry_unarmed;
    write("You will"+ ( my_tactics->parry_unarmed ? " " : " not " ) +
          "now attempt to parry unarmed.\n" );
    this_player()->set_tactics(my_tactics);
    return 1;
  case "left":
  case "right":
  case "both":
    if(my_tactics->parry == word) {
      write("You are already using "+
            ( word == "both" ? "both hands" :
              "your "+ word +" hand" ) +" to parry.\n" );
    } else {
      my_tactics->parry = word;
      write("You will now use "+
            ( word == "both" ? "both hands" :
              "your "+ word +" hand" ) +" to parry.\n" );
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics parry "+
                        "left|right|both [hand(s)]\n        "
                        "tactics parry unarmed\n" );
  }
}
int attack(string word) {
  class tactics my_tactics;
  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "left":
  case "right":
  case "both":
    if(my_tactics->attack == word) {
      write("You are already using "+
            ( word == "both" ? "both hands" :
              "your "+ word +" hand" ) +" to attack.\n" );
    } else {
      my_tactics->attack = word;
      write("You will now use "+
            ( word == "both" ? "both hands" :
              "your "+ word +" hand" ) +" to attack.\n" );
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics attack "+
                        "left|right|both [hand(s)]\n" );
  }
}
int focus(string word) {
  class tactics my_tactics;
  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "head":
  case "neck":
  case "chest":
  case "abdomen":
  case "arms":
  case "hands":
  case "legs":
  case "feet":
  case "upper body":
  case "lower body":
    if(my_tactics->focus_zone == word) {
      write("You are already focussing on your opponent's "+ word + ".\n");
    } else {
      my_tactics->focus_zone = word;
      write("You will now focus on your opponent's "+ word + ".\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  case "none":
    if(!my_tactics->focus_zone) {
      write("You are not currently focussing on any particular target "
            "area.\n");
    } else {
      my_tactics->focus_zone = 0;
      write("You will no longer focus on a specific target area.\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics focus " +
                        "upper body|lower body|head|neck|chest|abdomen|arms|hands|legs|feet|none\n");
  }
}
int distance(string word) {
  class tactics my_tactics;
  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "long":
  case "medium":
  case "close":
  case "hand-to-hand":
    if(my_tactics->ideal_distance == word) {
      write("You are already set for " + word + " range.\n");
      return 1;
    }
    my_tactics->ideal_distance = word;
    write("You will now aim for "+ word + " range combat.\n");
    this_player()->set_tactics(my_tactics);
    return 1;
  case "none":
    if(!my_tactics->ideal_distance) {
      write("You are not currently aiming for any specific combat distance.\n");
    } else {
      my_tactics->ideal_distance = 0;
      write("You will no longer aim for a specific combat distance.\n");
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail( "Syntax: tactics distance " +
                        "{long|medium|close|hand-to-hand\n");
  }
}
#ifdef USE_SURRENDER
int mercy(string word) {
  class tactics my_tactics;
  my_tactics = this_player()->query_tactics();
  switch(word) {
  case "always":
  case "ask":
  case "never":
    if(my_tactics->mercy == word) {
      write("Your mercy is already " + word + ".\n");
    } else {
      my_tactics->mercy = word;
      write("Your mercy is now "+ word +".\n" );
      this_player()->set_tactics(my_tactics);
    }
    return 1;
  default:
    return notify_fail("Syntax: tactics mercy always|ask|never\n");
  }
}
#endif
mixed *query_patterns() {
  return ({ "", (: cmd() :),
              "attitude <word'insane|offensive|neutral|defensive|wimp'>",
              (: attitude($4[0]) :),
              "response <word'dodge|neutral|parry'>", (: response($4[0]) :),
#ifdef USE_SURRENDER
              "mercy <word'always|ask|never'>", (: mercy($4[0]) :),
#endif
              "parry <word'left|right|both|unarmed'>", (: parry($4[0]) :),
              "attack <word'left|right|both'>", (: attack($4[0]) :),
              "focus <string'upper body|lower body|head|neck|chest|abdomen|"
              "arms|hands|legs|feet|none'>", (: focus($4[0]) :),
#ifdef USE_DISTANCE
              "distance <word'long|medium|close|hand-to-hand|none'>",
              (: distance($4[0]) :),
#endif
              });
}

==================================================
FILE: living/take.c
==================================================

inherit "/cmds/living/get";

==================================================
FILE: living/teach.c
==================================================

#include <skills.h>
#include <tune.h>
#include <command.h>
#include <cmds/teach.h>
#include <playtesters.h>
#include <player.h>
inherit "/cmds/base";
#define DEBUGGER "ceres"
#undef ENFORCE_MAX_TEACH_LEVEL
int command_teach( object *obs, string comm, object teacher );
int spell_teach(object *obs, string spell, object teacher);
int teach_skill(object *obs, string str, object teacher);
int cmd_int(string str, object *obs, object teacher);
int check_ignoring(object ignorer, object ignoree);
int query_auto_teaching(object teacher, object learner) {
   return teacher->query_property(TEACH_COMMAND_AUTO_PROPERTY);
}
int cmd(string str, object *obs, object player) {
  int ret;
  object ob;
  object* ear;
  if (this_player()->query_property(PASSED_OUT_PROP)) {
     add_failed_mess("You cannot teach while passed out.\n");
     return 0;
  }
  if (this_player()->query_fighting()) {
    add_failed_mess("You cannot teach or learn anything while you are "
                    "fighting!\n");
    return 0;
  }
  if (this_player()->check_earmuffs("teach")) {
    add_failed_mess("You have teaching earmuffed.\n");
    return 0;
  }
  if (player) {
    ear = filter(obs, (: userp($1) && !interactive($1) :));
    if (sizeof(ear)) {
      obs -= ear;
      add_failed_mess("$C$$I does not have enough responsiveness to teach "
                      "you.\n", ear);
      if (!obs) {
        return 0;
      }
    }
    ear = filter(obs, (: $1->check_earmuffs("teach") :));
    if (sizeof(ear)) {
      obs -= ear;
      if (sizeof(ear) == 1) {
        add_failed_mess("$I has " + ear[0]->query_possessive() + " earmuffs "
                        "on.\n", ear);
      } else {
        add_failed_mess("$I have their earmuffs on.\n", ear);
      }
      if (!obs) {
        return 0;
      }
    }
    ear = filter(obs, (: check_ignoring($1, this_player()) :));
    if (sizeof(ear)) {
      obs -= ear;
      add_failed_mess("$I is ignoring you, or you are ignoring them.\n",
                      ear);
      if (!obs) {
        return 0;
      }
    }
    ear = filter(obs, (: $1->query_property(PASSED_OUT_PROP) :));
    if (sizeof(ear)) {
      obs -= ear;
      add_failed_mess("$I is passed out and looks rather worse for wear.\n",
                      ear);
      if (!obs) {
        return 0;
      }
    }
    ear = filter(obs, (: $1->query_fighting() :));
    if (sizeof(ear)) {
      obs -= ear;
      add_failed_mess("$I is currently beating stuff up, please wait "
                      "for them to finish.\n", ear);
      if (!obs) {
        return 0;
      }
    }
    obs = filter(obs, (: !$1->query_creator() :) );
    if (!sizeof(obs)) {
      add_failed_mess("None of those people are allowed to teach you.\n");
      return 0;
    }
    obs = filter(obs, (: query_auto_teaching($1, this_player()) :));
    if (!sizeof(obs)) {
      add_failed_mess("None of those people have auto teaching turned "
                      "on.\n");
      return 0;
    }
    obs = filter(obs, (: $1->query_time_left() > 0 :));
    if (!sizeof(obs)) {
      add_failed_mess("All the people you are trying to learn from appear "
                      "to be busy.\n");
      return 0;
    }
    foreach (ob in obs) {
      ret |= cmd_int(str, ({ this_player() }), ob);
    }
    return ret;
  }
  return cmd_int(str, obs, this_player());
}
int cmd_int(string str, object *obs, object teacher) {
  if (teacher->query_property("dead")) {
    add_failed_mess("You wave your arms around, and your lips move but "
                       "they can't hear what you are saying.\n");
    return 0;
  }
  obs = filter(obs,  (: !$1->query_property("dead") :));
  if (!sizeof(obs)) {
    add_failed_mess("You must teach someone, preferably living.\n");
    return 0;
  }
  if (sizeof(obs) > 1) {
    add_failed_mess("You can only teach one person at a time.\n");
    return 0;
  }
  if (!command_teach(obs, str, teacher) &&
      !spell_teach(obs, str, teacher) &&
      !teach_skill(obs, str, teacher))
  {
    return 0;
  }
  return 1;
}
int check_ignoring(object ignorer, object ignoree) {
  return (ignorer->query_property("ignoring") &&
          member_array(ignoree->query_name(),
                       ignorer->query_property("ignoring")) != -1);
}
int command_teach(object *obs, string comm, object teacher) {
  string cmd_ob;
  object *succ;
  object *no_go;
  object *me_low;
  mixed *him_low;
  object *know_already;
  object *ear_muffed;
  object *ignored;
  object *ignoring;
  object ob;
  string *tmp_stuff;
  int i;
  class command cmd = new(class command, verb : comm);
  mixed tmp;
  if (member_array(comm, teacher->query_known_commands()) == -1 ||
      !CMD_D->HandleStars(cmd))
  {
    if (CMD_D->HandleStars(cmd)) {
      if (teacher == this_player()) {
        add_failed_mess("You do not know the command " + comm + ".\n");
      } else {
        add_failed_mess(teacher->the_short(1) +
                        " does not know the command " + comm + ".\n");
      }
    }
    return 0;
  }
  obs -= ({ teacher });
  if (!sizeof(obs)) {
    add_failed_mess("You cannot teach yourself a command.\n");
    return 0;
  }
  if (teacher->check_earmuffs("teach")) {
    if (teacher == this_player()) {
      add_failed_mess("You have teaching earmuffed.\n");
    } else {
      add_failed_mess(teacher->the_short(1) + " has teaching earmuffed.\n");
    }
    return 0;
  }
  cmd_ob = CMD_D->GetPaths(cmd->verb)[0] + "/" + cmd->verb;
  succ = ({ });
  ear_muffed = ({ });
  know_already = ({ });
  no_go = ({ });
  me_low = ({ });
  him_low = ({ });
  ignored = ({ });
  if (teacher->query_property("ignoring")) {
    ignoring = filter(obs, (: check_ignoring($(teacher), $1) :));
    obs -= ignoring;
  }
  foreach(ob in obs) {
    if (!living(ob)) {
      continue;
    }
    if (teacher == this_player()) {
      tmp = ob;
    } else {
      tmp = "you";
    }
    if (member_array(comm, ob->query_known_commands()) != -1) {
      know_already += ({ tmp });
    } else if (ob->check_earmuffs("teach")) {
      ear_muffed += ({ tmp });
    } else if (check_ignoring(ob, teacher)) {
      ignored += ({ tmp });
    } else {
      switch (cmd_ob->can_teach_command(teacher, ob)) {
        case 1:
          succ += ({ ob });
          break;
        case 0 :
          no_go += ({ tmp });
          break;
        case -1 :
          me_low += ({ tmp });
          break;
        case -2 :
          him_low += ({ tmp });
          break;
      }
    }
  }
  if (!succ || !sizeof(succ)) {
    if (teacher != this_player()) {
      tell_object(teacher, this_player()->the_short() + " tried to "
                  "learn " + comm + " from you automatically, "
                  "but failed.\n");
    }
    if (sizeof(no_go) > 0) {
      add_failed_mess(teacher->the_short() + " cannot teach " + comm +
                      " to $I.\n", no_go);
    }
    if (sizeof(me_low)) {
      if (teacher == this_player()) {
        add_failed_mess(teacher->the_short() +
                        " are too low a level to teach " + comm +
                        " to $I.\n", me_low);
      } else {
        add_failed_mess(teacher->the_short() +
                        " is too low a level to teach " + comm +
                        " to $I.\n", me_low);
      }
    }
    if (sizeof(ear_muffed) > 0) {
      add_failed_mess("$I has teaching events earmuffed, you are unable "
                      "to teach them.\n", ear_muffed);
    }
    if (sizeof(him_low) > 0) {
      add_failed_mess("$I " +
                      ((sizeof(him_low) == 1  &&
                        him_low[0] != this_player()) ? "is" : "are") +
                      " too low a level to learn " + comm + ".\n", him_low);
    }
    if (sizeof(know_already)) {
      add_failed_mess("$I already know" +
                      (sizeof(know_already) > 1  ||
                       teacher != this_player()? "" : "s") +
                      " the command " + comm + ".\n", know_already);
    }
    if (sizeof(ignoring)) {
      if (this_player() == teacher) {
        add_failed_mess("You are ignoring $I.\n", ignoring);
      } else {
        add_failed_mess(teacher->the_short(1) + " is ignoring $I.\n",
                        ignoring);
      }
    }
    if (sizeof(ignored)) {
      add_failed_mess("You are being ignored by $I.\n", ignored);
    }
    return 0;
  }
  write(teacher->the_short() + " offer" +
        (this_player() == teacher ? "" : "s") + " to teach " + comm +
        " to " + query_multiple_short(succ) + ".\n");
  if (teacher == this_player()) {
    if (sizeof(no_go)) {
      write("You cannot teach " + comm + " to " +
            query_multiple_short(no_go, "the", 0, 1 ) + ".\n");
    }
    if (sizeof(ear_muffed) > 0) {
      write(capitalize(query_multiple_short(ear_muffed, "the", 0, 1)) +
            " has teaching events earmuffed, you are unable "
            "to teach them.\n");
    }
    if (sizeof(me_low) > 0) {
      write("You are too low a level to teach " + comm + " to " +
            query_multiple_short(me_low, "the", 0, 1) + ".\n");
    }
    if (sizeof(him_low) > 0) {
      write(capitalize(query_multiple_short(him_low, "the", 0, 1)) +
            ((sizeof(him_low) == 1) ? " is" : " are") +" too low a "
            "level to learn " + comm + ".\n");
    }
  } else {
    tell_object(teacher,
                "You automatically offer to teach " + comm + " to " +
                query_multiple_short(succ) + ".\n");
  }
  say(capitalize((string)teacher->short()) + " teaches something to " +
      query_multiple_short(succ) + ".\n", succ + ({ teacher }));
  for (i = 0; i < sizeof(succ); i++) {
    tell_object(succ[i], capitalize(teacher->the_short()) +
                " offers to teach " +
                query_multiple_short(delete(succ, i, 1) +
                ({ "you" }) ) + " the command \"" + comm + "\".\n"
                "Type \"learn " + comm + " from " +
                teacher->query_name() + "\" to learn the command.\n");
    tmp_stuff = succ[i]->query_respond_command(TEACH_COMMAND_TYPE, teacher);
    if (!tmp_stuff) {
      tmp_stuff = ({ comm });
    } else if (member_array(comm, tmp_stuff) == -1) {
      tmp_stuff += ({ comm });
    }
    succ[i]->add_respond_command(TEACH_COMMAND_TYPE, teacher, tmp_stuff);
  }
  add_succeeded_mess("");
  return 1;
}
int spell_teach(object *obs, string spell, object teacher) {
  object *succ, *no_go, *me_low, *him_low, ob;
  object *ignoring;
  object *ignored;
  object *ear_muffed;
  string ret;
  string is_are;
  mapping spells;
  mixed tmp;
  spells = teacher->query_spells();
  if (!spells[spell]) {
    return 0;
  }
  if (teacher == this_player()) {
    is_are = "are";
  } else {
    is_are = "is";
  }
  if (teacher->check_earmuffs("teach")) {
    add_failed_mess("You have teaching earmuffed.\n");
    return 0;
  }
  ear_muffed = succ = no_go = me_low = him_low = ({ });
  ignored = ({ });
  if (teacher->query_property("ignoring")) {
    ignoring = filter(obs, (: check_ignoring($(teacher), $1) :));
    obs -= ignoring;
  }
  foreach(ob in obs) {
    if (living(ob)) {
      if (ob->check_earmuffs("teach")) {
        ear_muffed += ({ ob });
        continue;
      } else if (check_ignoring(ob, teacher)) {
        ignored += ({ ob });
      } else {
        if (teacher == this_player()) {
          tmp = ob;
        } else {
          tmp = "you";
        }
        switch (spells[spell][0]->teach(ob, spell)) {
          case 1:
            succ += ({ ob });
            break;
          case 0:
            no_go += ({ ob });
            break;
          case -1:
            me_low += ({ ob });
            break;
          case -2:
            him_low += ({ ob });
            break;
        }
      }
    }
  }
  if (sizeof(succ) == 0) {
    if (teacher != this_player()) {
      tell_object(teacher, this_player()->the_short() + " tried to "
                  "learn " + spell +
                  " from you automatically, but failed.\n");
    }
    ret = "";
    if (sizeof(no_go) > 0) {
      add_failed_mess(teacher->the_short() +
                      " cannot teach " + spell + " to $I.\n", no_go);
    }
    if (sizeof(me_low) > 0) {
      add_failed_mess(teacher->the_short() +
                      " " + is_are +
                      " too low a level to teach $I " + spell + ".\n",
                      me_low);
    }
    if (sizeof(him_low) > 0) {
      add_failed_mess("$I " + is_are + " too low a level to learn " +
                       spell + ".\n", him_low);
    }
    if (sizeof(ignoring)) {
       add_failed_mess("You are ignoring $I.\n", ignoring);
    }
    if (sizeof(ignored) > 0) {
       add_failed_mess("You are being ignored by $I.\n", ignored);
    }
    if (sizeof(ignored) > 0) {
       add_failed_mess("$I has teaching earmuffed.\n", ignored);
    }
    return 0;
   }
   if (teacher == this_player()) {
     write(teacher->the_short() +
           " successfuly teach " + query_multiple_short(succ) + " " +
           spell + ".\n");
     if (sizeof(no_go) > 0) {
       write("You cannot teach " + spell + " to " +
             query_multiple_short(no_go, "the", 0, 1) + ".\n");
     }
     if (sizeof(me_low) > 0) {
       write("You are too low a level to teach " +
             query_multiple_short(me_low, "the", 0, 1) + " " + spell +
             ".\n");
     }
     if (sizeof(him_low) > 0) {
       write(capitalize(query_multiple_short(him_low, 0, 1)) +
             (sizeof(him_low) == 1 ? " is " : " are ") +
             "too low a level to learn " + spell + ".\n");
     }
     if (sizeof(ignoring) > 0) {
       add_failed_mess("You are ignoring " +
                       query_multiple_short(ignoring, "the", 0, 1) +
                       ".\n");
     }
     if (sizeof(ignored) > 0) {
       add_failed_mess("You are being ignored by " +
                       query_multiple_short(ignored, "the", 0, 1) + ".\n");
     }
   } else {
     write(teacher->the_short() +
           " successfuly teaches " + query_multiple_short(succ) + " " +
           spell + ".\n");
   }
   return 1;
}
#define CANNOT 0
#define TOO_LOW 1
#define ONLY_LEAF 2
#define TOO_HIGH 3
#define CANNOT_TEACH 4
int teach_skill(object *obs, string str, object teacher) {
  int num;
  int lvl;
  int my_lvl;
  int lvl_up;
  int j;
  int cost;
  int total;
  int total2;
  int sk;
  int depth;
  object *ok;
  object *too_little;
  mixed  *too_low;
  object *cannot_teach;
  object *only_leaf;
  object *ignored;
  object *ignoring;
  object *ear_muffed;
  object *too_high;
  object ob;
  string skill;
  string skill_start;
  mixed *bits;
  class teaching_skill frog;
  float k;
  mixed tmp;
  num = 1;
  if (sscanf(str, "%d levels of %s", num, skill) != 2) {
    if (sscanf(str, "%d level of %s", num, skill) != 2) {
      if (sscanf(str, "%d %s", num, skill) != 2) {
        num = 1;
        skill = str;
      }
    }
  }
  if (num < 1) {
    add_failed_mess("You cannot teach a negative or zero number of "
                    "levels.\n");
    return 0;
  }
  if (num > 50) {
    add_failed_mess("You cannot teach more than 50 levels at a time.\n");
    return 0;
  }
  if (teacher->check_earmuffs("teach")) {
    add_failed_mess("You have teaching earmuffed.\n");
    return 0;
  }
  skill_start = skill;
  bits = explode(implode(explode(skill, " "), "."), ".") - ({ "" });
  if (!bits || !(skill = (string)SKILL_OB->query_skill(bits))) {
    if (member_array(skill_start, teacher->query_known_commands()) != -1) {
      return 0;
    }
    add_failed_mess("The skill " + implode(bits, ".") + " is invalid.\n");
    return 0;
  }
  bits = explode(skill, ".");
  my_lvl = teacher->query_skill_bonus(skill, 1);
  ear_muffed = ({ });
  too_high = ({ });
  only_leaf = ({ });
  too_low = ({ });
  ok = ({ });
  too_little = ({ });
  cannot_teach = ({ });
  ignored = ({ });
  if (teacher->query_property("ignoring")) {
    ignoring = filter(obs, (: check_ignoring($(teacher), $1) :));
    obs -= ignoring;
  }
  foreach (ob in obs) {
    if (teacher == this_player()) {
      tmp = ob;
    } else {
      tmp = "you";
    }
    if (!interactive(ob)) {
      cannot_teach += ({ tmp });
      continue;
    }
    if (!SKILL_OB->query_allowed_to_teach(skill)) {
      cannot_teach += ({ tmp });
      continue;
    }
    if (ob->check_earmuffs("teach")) {
      ear_muffed += ({ tmp });
      continue;
    }
    if (check_ignoring(ob, teacher)) {
      ignored += ({ tmp });
      continue;
    }
    if (SKILL_OB->query_only_leaf(skill) &&
        sizeof((mixed *)SKILL_OB->query_immediate_children(skill)))
    {
      only_leaf += ({ tmp });
      continue;
    }
    lvl = (int)ob->query_skill(skill);
    if (ob != teacher) {
      if ((int)ob->calc_bonus(lvl + num, skill, 1) > my_lvl) {
        add_failed_mess(teacher->the_short() +
                        " cannot teach $I, since their bonus is " +
                        (teacher == this_player() ? "higher" : "lower") +
                        " than yours.\n", ({ tmp }));
        continue;
      }
#ifdef ENFORCE_MAX_TEACH_LEVEL
      if (lvl + num > SKILL_MAX_TEACH) {
        too_high += ({ tmp });
        continue;
      }
#endif
    }
    if (sizeof(bits) > 1) {
      lvl_up = ob->query_skill(implode(bits[0 .. sizeof(bits) - 2], "."));
    } else {
      lvl_up = lvl;
    }
    depth = SKILL_OB->query_skill_depth(bits);
    if (!SKILL_OB->query_only_leaf(skill) && depth * 5 > lvl_up) {
      too_low += ({ tmp });
      continue;
    }
    total = 0;
    total2 = 0;
    foreach (sk in SKILL_OB->query_all_children(skill)) {
      if (SKILL_OB->query_immediate_children(sk) != ({ })) {
        continue;
      }
      my_lvl = teacher->query_skill_bonus(sk, 1);
      lvl = (int)ob->query_skill(sk);
      cost = DEFAULT_COST;
      cost *= STD_COST / 5;
      if (!my_lvl) {
        my_lvl = 1;
      }
      for (j = 0; j < num; j++) {
        k = 0.5 * (int)ob->calc_bonus(lvl + j, sk, 1 ) / my_lvl + 1.0;
        total2 += 500 + to_int(cost * (lvl+j) * exp((lvl + j) / 500.0) * k);
        if (total > total2) {
          num = j;
          break;
        } else {
          total = total2;
        }
      }
#ifdef DEBUG
      tell_object(find_player(DEBUGGER),
                  sprintf("%s:%s j:%d, lvl: %d, mylvl: %d, newbonus: %d, "
                          "total: %d\n",
                          this_player()->query_name(),
                          ob->query_name(),
                          j, lvl,
                          my_lvl,
                          (int)ob->calc_bonus(lvl + j, sk, 1),
                          lvl,
                          total2));
#endif
      if (!total) {
        total = cost;
      }
    }
    if (total > (int)ob->query_xp()) {
      if (teacher == this_player()) {
        add_failed_mess("It would have cost " + total + " xp to teach " +
                        num + " level" + (num > 1 ? "s" : "") + " of " +
                        skill + " to $I.\n", ({ ob }));
      } else {
        add_failed_mess("It would have cost " + total + " xp to teach " +
                        num + " level" + (num > 1 ? "s" : "") + " of " +
                        skill + " to you from " + teacher->the_short() +
                        ".\n");
      }
      too_little += ({ tmp });
      continue;
    }
    if (ob != teacher) {
      if (teacher == this_player()) {
        tell_object(ob, teacher->the_short() + " offers to teach "
                    "you " + num + " level" + (num > 1 ? "s" : "") +
                    " of " + skill + " for " + total + " xp.\nUse "
                    "\"learn\" to learn the skill.\n");
        write("You offer to teach $M$$the_short:" + file_name(ob) +
              "$$M$ " + num + " level" + (num > 1 ? "s" : "") + " of " +
              skill + " for " + total + " xp.\n");
      } else {
        tell_object(ob, teacher->the_short() + " offers to teach "
                    "you " + num + " level" + (num > 1 ? "s" : "") +
                    " of " + skill + " for "+total+" xp.\nUse \"learn\" "
                    "to learn the skill.\n");
        tell_object(teacher,
                    "You offer to teach $M$$the_short:" + file_name(ob) +
                    "$$M$ " + num + " level" + (num > 1 ? "s" : "") +
                    " of " + skill + " for " + total + " xp.\n");
      }
    } else {
      write("You can teach yourself " + num + " level" +
            (num > 1 ? "s" : "") + " of " + skill + " for " + total +
            " xp.\nUse \"learn\" to learn the skill.\n");
      write("You offer to teach $M$$the_short:" + file_name(ob) +
            "$$M$ " + num + " level" + (num > 1 ? "s" : "") + " of " +
            skill + " for " + total + " xp.\n");
    }
    ok += ({ tmp });
    frog = new(class teaching_skill);
    frog->num = num;
    frog->lvl = ob->query_skill(skill);
    frog->skill = skill;
    frog->xp = total;
    frog->room = environment(this_player());
    ob->add_respond_command(TEACH_SKILL_TYPE, teacher, frog);
  }
  if (sizeof(ok) == 0) {
    if (teacher != this_player()) {
      tell_object(teacher,
                  this_player()->the_short() + " tried to learn " + skill +
                  " from you automatically but failed.\n");
    }
    if (sizeof(only_leaf) > 0) {
      add_failed_mess("You cannot teach the skill " + skill +
                      ", as it is only possible to teach leaf skills in "
                      "this skill tree.\n");
    }
    if (sizeof(ear_muffed) > 0) {
      add_failed_mess("You cannot teach any levels of " + skill +
                      " to $I, they have teaching earmuffed and cannot "
                      "hear you.\n", ear_muffed);
    }
    if (sizeof(cannot_teach) > 0) {
      add_failed_mess("You cannot teach any levels of " + skill +
                      "; you need to look for alternative methods of "
                      "advancement.\n");
    }
    if (sizeof(too_low) > 0) {
      add_failed_mess(query_multiple_short(too_low, "the", 0, 1) +
                      ((sizeof(too_low) > 1    ||
                        too_low[0] == teacher  ||
                        teacher != this_player()) ? " are " : " is ") +
                      "not at a high enough level in the outer skills to "
                      "learn " + num + " levels of " + skill + ".   See "
                      "'help skills' for more details.\n");
    }
    if (sizeof(too_high) > 0) {
      add_failed_mess(query_multiple_short(too_low, "the", 0, 1) +
                      ((sizeof(too_high) > 1     ||
                        teacher != this_player() ||
                        too_low[0] == teacher) ? " are " : " is ") +
                      "too high a level to learn " + num + " levels of " +
                      skill + ", they must be less than " +
                      SKILL_MAX_TEACH + " to learn from someone else.\n");
    }
    if (sizeof(ignoring) > 0) {
      add_failed_mess("You are ignoring $I.\n", ignoring);
    }
    if (sizeof(ignored) > 0) {
      add_failed_mess("You are being ignored by $I.\n", ignored);
    }
  }
  return sizeof(ok);
}
mixed *query_patterns() {
   return ({
      "<string:'skill|n levels of skill|command'> to <indirect:living>",
                   (: cmd($4[0], $1, 0) :),
      "me <string:'skill|n levels of skill|command'> from <indirect:living>",
                   (: cmd($4[0], $1, this_player()) :)});
}

==================================================
FILE: living/th_row.c
==================================================

#define CREATOR "Ceres"
#include <player.h>
#include <move_failures.h>
#include <tasks.h>
#define ASKILL "fighting.combat.range.thrown"
#define DSKILL "fighting.combat.dodging.range"
#define PSKILL "fighting.combat.parry.range"
#define COMMAND_GP_COST 5
inherit "/cmds/base";
int valid_target( object target, object thrower, object item );
int cmd( mixed *indirect_obs ) {
    object target, item;
    int dchance, damage;
    if ( sizeof( indirect_obs[ 0 ] ) > 1 ) {
        add_failed_mess( "You can only throw one item at a time!\n" );
        return 0;
    }
    item = indirect_obs[ 0 ][ 0 ];
    if ( sizeof( indirect_obs[ 1 ] ) > 1 ) {
        add_failed_mess( "You can only throw $I at one target at a time!\n",
            ({ item }) );
        return 0;
    }
    target = indirect_obs[ 1 ][ 0 ];
    if ( item->query_wielded() != this_player() ) {
        add_failed_mess( "You must be holding $I to throw it.\n",
            ({ item }) );
        return 0;
    }
    if ( this_player() == target ) {
        add_failed_mess( "You cannot throw $I at yourself!\n", ({ item }) );
        return 0;
    }
    if ( !living( target ) && !target->query_property( "targetable" ) ) {
        add_failed_mess( "Why do you want to throw $I at " +
            target->the_short() + "?\n", ({ item }) );
        return 0;
    }
    if (this_player()->query_gp() < COMMAND_GP_COST) {
        add_failed_mess( "You need " + COMMAND_GP_COST + " points to "
            "throw " + item->the_short() + " at " + target->the_short() +
            ".\n");
        return 0;
    }
    if ( !valid_target( target, this_player(), item ) ) {
        add_failed_mess( "You decide against throwing $I at " +
            target->the_short() + ".\n", ({ item }) );
        return 0;
    }
    if ( living( target ) ) {
        switch ( (string)target->query_combat_response() ) {
            case "dodge" :
                dchance = target->query_skill_bonus( DSKILL );
            break;
            default:
                dchance = target->query_skill_bonus( PSKILL );
        }
    }
    else {
        dchance = target->query_property( "targetable" );
    }
    dchance += item->query_weight() / ( this_player()->query_str() / 2 );
    if( !this_player()->query_visible( target ) ) {
        dchance /= 2;
    }
    this_player()->adjust_gp(-COMMAND_GP_COST);
    switch( TASKER->perform_task(this_player(), ASKILL, dchance, TM_FREE) ) {
        case AWARD:
            tell_object(this_player(), "%^YELLOW%^You feel that your "
                "skill in throwing weapons has increased.%^RESET%^\n");
        case SUCCEED:
            tell_object( this_player(), "You throw " + item->the_short() +
                " at " + target->the_short() + " and hit!\n" );
            tell_room( environment( this_player() ),
                this_player()->the_short() + " throws " + item->a_short() +
                    " at " + target->the_short() + " and hits!\n",
                    this_player() );
            if ( living( target ) ) {
                damage = ( item->query_weight() / 4 ) +
                    ( this_player()->query_str() * 2) +
                    ( this_player()->query_skill_bonus( ASKILL ) / 3 );
                damage -= target->query_ac( "blunt", damage );
                target->attack_by( this_player() );
                target->adjust_hp( -damage, this_player() );
                this_player()->attack_ob( target );
                event( item, "thrown", this_player(), target );
                    this_player()->adjust_time_left(-(ROUND_TIME*2));
            }
            target->thrown_at( this_player(), 1, item );
            if ( item->move( target ) != MOVE_OK ) {
                item->move( environment( target ) );
            }
        break;
        default:
            tell_object( this_player(), "You throw " + item->the_short() +
                " at " + target->the_short() + " but miss.\n" );
            tell_room( environment( this_player() ),
                this_player()->the_short() + " throws " + item->a_short() +
                " at " + target->the_short() + " but misses.\n", this_player() );
            item->move( environment( target ) );
            if( !interactive( target ) && living( target ) ) {
                this_player()->attack_ob( target );
                target->attack_by( this_player() );
            }
            target->thrown_at( this_player(), 0 );
        break;
    }
    return 1;
}
int valid_target( object target, object thrower, object item ) {
    mixed owner;
    if ( target->query_property( "dead" ) || target->query_auto_loading() ) {
        return 0;
    }
    if ( userp( target ) && !interactive( target ) ) {
        return 0;
    }
    if ( pk_check( thrower, target ) )
        return 0;
    if ( ( owner = target->query_owner() ) && pk_check( thrower, owner ) ) {
        return 0;
    }
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:object:me'weapon'> at <indirect:object'target'>",
        (: cmd($1) :) });
}

==================================================
FILE: living/und_efend.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *things) {
  object *defendees;
  object ob;
  object *fail;
  if(!things) {
    things = ({ });
  }
  things -= ({ TP });
  if ( !sizeof( things ) ) {
    add_failed_mess("You cannot undefend yourself!\n");
    return 0;
  }
  defendees = ({ });
  fail = ({ });
  foreach ( ob in things) {
    if ( ob->remove_defender( TP ) ) {
      defendees += ({ ob });
    } else  {
       fail += ({ ob });
    }
  }
  if ( sizeof( fail ) ) {
    add_failed_mess( "You are not defending " + query_multiple_short( fail ) +
                     ".\n" );
  }
  if (sizeof(defendees)) {
     add_succeeded_mess("$N stop$s defending $I.\n", defendees);
     return 1;
  } else {
     return 0;
  }
}
mixed *query_patterns() {
   return ({ "<indirect:living>", (: cmd($1) :) });
}

==================================================
FILE: living/unf_ollow.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(object *obs) {
   mapping hide_invis;
   int hiding, sneaking;
  object *ok, ob;
  string s;
  ok = ({ });
  foreach (ob in obs) {
    if (ob->remove_follower(TP)) {
      ok += ({ ob });
    }
  }
  if (!sizeof(ok)) {
    if (member_array(TP, obs) == -1) {
      return notify_fail("You are not following "+query_multiple_short(obs)+
                         ".\n");
    } else {
      return notify_fail("You are not following " +
        query_multiple_short(obs - ({ TP }) + ({ "yourself" })) + ".\n");
    }
  }
  hide_invis = ( mapping )this_player()->query_hide_invis();
  hiding = hide_invis[ "hiding" ] ? 1 : 0;
  sneaking = this_player()->query_sneak_level() ? 1 : 0;
  if( hiding || sneaking )
   write("You stop following "+(s=query_multiple_short(ok))+" unseen.\n");
  else {
    write("You stop following "+(s=query_multiple_short(ok))+".\n");
    say(TP->the_short()+" stops following "+s+".\n", ok);
    foreach (ob in ok) {
      tell_object(ob, TP->the_short() +
                  " stops following "+query_multiple_short((ok + ({"you"})) -
                                                           ({ ob }))+".\n");
    }
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:living>", (: cmd($1) :) });
}

==================================================
FILE: living/unh_old.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(object obs) {
  object *ok, *zip, *failed, ob, *using;
  string s;
  mixed ret;
  using = TP->query_holding();
  failed = ok = zip = ({ });
  foreach (ob in obs) {
    if (member_array(ob, using) != -1) {
      if (!sizeof(ret = TP->set_unhold(ob)) || !ret)
        failed += ({ ob });
      else
        ok += ({ ob });
    }
    else
      zip += ({ ob });
  }
  if (!sizeof(ok)) {
    s = "";
    if (sizeof(failed))
      s += "Could not unhold "+query_multiple_short(failed)+".\n";
    if (sizeof(zip))
      s += capitalize("You are not holding " +
                      query_multiple_short(zip, "the") + ".\n");
    return notify_fail(s);
  }
  tell_object(TP, "You put down "+(s = query_multiple_short(ok))+".\n");
  tell_room(environment(TP), TP->one_short()+" puts down "+s+".\n", TP);
  TP->force_burden_recalculate();
  return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:object:me>", (: cmd($1) :) });
}

==================================================
FILE: living/unp_rotect.c
==================================================

inherit "/cmds/base";
#define TP this_player()
mixed cmd(object *things) {
  object *protectees;
  object ob;
  object *fail;
  if(!things) {
    things = ({ });
  }
  things -= ({ TP });
  if ( !sizeof( things ) ) {
    add_failed_mess("You cannot unprotect yourself!\n");
    return 0;
  }
  protectees = ({ });
  fail = ({ });
  foreach ( ob in things) {
    if ( ob->remove_protector( TP ) ) {
      protectees += ({ ob });
    } else  {
       fail += ({ ob });
    }
  }
  if ( sizeof( fail ) ) {
    add_failed_mess( "You are not protecting " + query_multiple_short( fail ) +
                     ".\n" );
  }
  if (sizeof(protectees)) {
     add_succeeded_mess("$N stop$s protecting $I.\n", protectees);
     return 1;
  } else {
     return 0;
  }
}
mixed *query_patterns() {
   return ({ "<indirect:living>", (: cmd($1) :) });
}

==================================================
FILE: living/watch.c
==================================================

#define COST 50
inherit "/cmds/base";
mixed cmd() {
   if ( this_player()->query_blinded() ) {
      add_failed_mess( "How can you watch anything?  You're blind.\n" );
      return 0;
   }
   if (this_player()->query_property("dead")) {
      add_failed_mess( "Dead people don't watch. It is rude!\n");
      return 0;
   }
   if ( sizeof( (int *)this_player()->effects_matching( "mind.alertness" ) ) ) {
      add_failed_mess( "You are already alert and watching "
        "your surroundings.\n" );
      return 0;
   }
   if ( this_player()->query_specific_gp( "other" ) < COST ) {
      add_failed_mess( "You can't concentrate enough to watch "
        "your surroundings.\n" );
      return 0;
   }
   this_player()->adjust_gp( -COST );
   this_player()->add_effect( "/std/effects/other/alertness", 60 +
     (int)this_player()->query_skill_bonus( "other.perception" ) / 2 );
   return 1;
}
int stop_watching() {
   int *enums, id;
   enums = this_player()->effects_matching( "mind.alertness" );
   if ( sizeof( enums ) ) {
      foreach( id in enums ) {
         this_player()->delete_effect( id );
      }
   }
   else {
      add_succeeded_mess( ({ "You are not currently watching!\n", "" }) );
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "stop", (: stop_watching() :),
     "", (: cmd() :) });
}

==================================================
FILE: living/wea_r.c
==================================================

#include <clothing.h>
#include <tasks.h>
inherit "/cmds/base";
#define TP this_player()
#define SKILL "covert.manipulation.sleight-of-hand"
mapping add_to_failed(mapping failed, string word, object thing);
int cmd(object *things) {
  int i;
  string result;
  string stuff;
  string *reasons;
  object *okay;
  object *blocking;
  object *total_blocking;
  object ob;
  object tmp;
  mapping failed;
  mapping hide_invis;
  int hiding, sneaking, difficulty, light, my_light;
  okay = ({ });
  failed = ([ ]);
  things = sort_array(things, (: CLOTHING_HANDLER->query_clothing_depth($2->query_type()) -
                                 CLOTHING_HANDLER->query_clothing_depth($1->query_type()) :) );
  total_blocking = ({ });
  foreach (ob in things) {
    if (environment(ob) != this_player())  {
      failed = add_to_failed(failed, "not carrying", ob);
      continue;
    }
    if ( !ob->query_wearable() ) {
      failed = add_to_failed( failed, "cannot wear", ob);
      continue;
    }
    if (member_array(ob, TP->query_wearing()) != -1) {
      failed = add_to_failed(failed, "already wearing", ob);
      continue;
    }
    if (ob->cannot_be_worn()) {
      failed = add_to_failed(failed, "cannot wear", ob);
      continue;
    }
    blocking = CLOTHING_HANDLER->query_items_blocking(ob, this_player());
if (this_player() == find_player("presto"))
printf("blocking == %O\n", blocking);
    if (sizeof(blocking)) {
       total_blocking += blocking;
       foreach (tmp in blocking) {
          TP->remove_armour(tmp);
       }
    }
    result = CLOTHING_HANDLER->can_wear_or_remove(ob, this_player());
if (this_player() == find_player("presto"))
printf("ob == %s, result == %s\n", ob->short(), result);
    if (result) {
      failed = add_to_failed(failed, result, ob);
      continue;
    }
    result = TP->wear_armour(ob, 0);
    if (result) {
      failed = add_to_failed(failed, result, ob);
      continue;
    }
    okay += ({ ob });
  }
  if (total_blocking) {
    foreach (tmp in total_blocking) {
      TP->wear_armour(tmp);
    }
  }
  result = "";
  if (sizeof(failed)) {
    reasons = keys(failed);
    for (i = 0; i < sizeof(reasons); i++) {
      stuff = query_multiple_short(failed[reasons[i]], "the");
      switch (reasons[i]) {
      case "cannot wear" :
        if (!sizeof(okay)) {
           result += capitalize(stuff) +" cannot be worn.\n";
        }
        break;
      case "already wearing" :
        result += "You are already wearing "+ stuff +".\n";
        break;
      case "already holding" :
        result += "You cannot wear "+ stuff +" as you do not "
          "have enough free limbs.\n";
        break;
      case "oh dear" :
        result += "I'm not sure why you can't wear "+ stuff +
          "; something has probably gone wrong, so please "
          "contact a creator.\n";
        break;
      case "not carrying":
        result += "You aren't carrying " + stuff + ".\n";
        break;
      default :
        result += "You cannot put on "+ stuff +" "+ reasons[i] +".\n";
      }
    }
  }
  if (!sizeof(okay)) {
    return notify_fail(result);
  }
  stuff = query_multiple_short(okay);
  if (sizeof(total_blocking)) {
     tell_room(environment(TP), TP->one_short() + " removes " +
               query_multiple_short(total_blocking) + " so " +
               TP->query_pronoun() + " can wear "+
               stuff +".\n" + TP->one_short() + " wears " +
               query_multiple_short(total_blocking) + ".\n",
               TP);
     write("You remove " +
               query_multiple_short(total_blocking) + " so you can wear "+
               stuff +".\nYou wear " +
               query_multiple_short(total_blocking) + ".\n",
               TP);
  } else {
    hide_invis = ( mapping )this_player()->query_hide_invis();
    hiding = hide_invis[ "hiding" ] ? 1 : 0;
    sneaking = this_player()->query_sneak_level() ? 1 : 0;
    if( hiding || sneaking ) {
      my_light = this_player()->query_light();
      light = environment( this_player() )->query_light();
      difficulty = light + ( 4 * my_light ) / ( light + 1 );
      if( sizeof( total_blocking ) ) {
        difficulty += 50 * sizeof( total_blocking );
      }
      difficulty += okay[0]->query_complete_weight();
      debug_printf( "Difficulty = %d.\n Skill = %s\n Bonus = %d\n",
                    difficulty, SKILL, this_player()->
                    query_skill_bonus( SKILL ) );
      switch( TASKER->perform_task( this_player(), SKILL, difficulty,
        TM_FREE ) ) {
        case AWARD :
          write( "%^YELLOW%^" + ({
            "You discover something that lets your fingers move more "
              "nimbly.",
            "You find yourself capable of deceiving the eye with greater "
              "ease than before.",
            "You realise how to deceive the eye more effectively."
          })[ random(3) ] + "%^RESET%^\n" );
        case SUCCEED :
          add_succeeded_mess( ({ "$N $V " + stuff + ", managing to stay "
            "unnoticed.\n",
            "" }) );
          break;
        default :
          this_player()->add_succeeded_mess( this_object(), "$N "
            "unsuccessfully tr$y to " + query_verb() + " " + stuff +
            " while staying unnoticed.\n", ({ }) );
          break;
      }
    } else {
      this_player()->add_succeeded_mess( this_object(), "$N $V " + stuff +
        ".\n", ({ }) );
    }
  }
  return 1;
}
mapping add_to_failed(mapping failed, string word, object thing) {
  if (!failed[word]) {
    failed += ([ word : ({ thing }) ]);
  } else {
    failed[word] += ({ thing });
  }
  return failed;
}
mixed *query_patterns() {
  return ({ "<indirect:object:me>", (: cmd($1) :) });
}

==================================================
FILE: living/whi_sper.c
==================================================

inherit "/cmds/base";
inherit "/cmds/speech";
mixed cmd( object *others, string last ) {
  class message mess;
  if (sizeof(others) == 1 && others[0] == this_player()) {
     add_failed_mess("Whispering to yourself?  Neat trick.\n");
     return 0;
  }
  mess = build_message(last, others, "whisper");
  mess->type = "whisper";
  return say_it_to(mess, others, 1, "whisper");
}
mixed *query_patterns() {
   return ({ "<string'message'> to <indirect:living>", (: cmd($1, $4[0]) :),
             "<indirect:living> <string'message'>", (: cmd($1, $4[1]) :) });
}

==================================================
FILE: living/wi_eld.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  if (!interactive(this_player()))
    return "/cmds/living/ho_ld"->cmd(str);
  return notify_fail("Use hold; see help hold for more details.\n");
}

==================================================
FILE: living/withdraw.c
==================================================

#include <money.h>
#include <cmds/offer.h>
inherit "/cmds/base";
int withdraw_offer(object *sell_to) {
   object *removed;
   object ob;
   removed = ({ });
   foreach (ob in sell_to) {
      if (ob->query_respond_command("sell", this_player())) {
         ob->remove_respond_command("sell", this_player());
         removed += ({ ob });
      }
   }
   if (sizeof(removed)) {
      add_succeeded_mess("$N withdraw$s $p offer of sale to $I.\n", removed);
      return 1;
   }
   add_failed_mess("You cannot withdraw your offer of sale to $I since "
                   "you have not offered to sell them anything in the "
                   "first place.\n", sell_to);
   return 0;
}
mixed *query_patterns() {
   return ({ "offer {from|to} <indirect:living>",
             (: withdraw_offer($1) :) });
}

==================================================
FILE: living/wring.c
==================================================

inherit "/cmds/base";
int cmd(object *things)  {
   object *towels;
   int    *enums;
   int     wetness;
   int     success;
   string  str;
   towels = filter(things,
                   (: $1->id("towel")  ||  $1->query_property("dryer") :));
   things -= towels;
   str = "";
   if (sizeof(towels) == 1)  {
      enums = towels[0]->effects_matching("object.wet");
      if (sizeof(enums)) {
         wetness = towels[0]->arg_of(enums[0]);
      }
      if (wetness < 36 - this_player()->query_str())  {
         str = "You can't wring any more moisture out of " +
               towels[0]->one_short();
         success = 0;
      } else  {
         towels[0]->add_effect("/std/effects/object/wet",
            -wetness / ((36 - this_player()->query_str()) / 4));
         str = "You wring some moisture out of " +
               towels[0]->one_short();
         success = 1;
      }
   } else if (sizeof(towels))  {
      str = "You can only wring out one thing at a time";
      success = 0;
   }
   if (sizeof(things))  {
      if (success) {
         str += ", but you can't wring out " +
                query_multiple_short(things) + " at all.\n";
      } else {
         str += ", and you can't wring out " +
                query_multiple_short(things) + " at all.\n";
      }
   } else {
      str += ".\n";
   }
   write(str);
   return 1;
}
mixed *query_patterns()  {
   return ({ "[out] <indirect:object:me'towel'>", (: cmd($1) :) });
}

==================================================
FILE: creator/addalt.c
==================================================

#include <creator.h>
#include <playerinfo.h>
inherit "/cmds/base";
int add_alt(string s1, string s2) {
  string *alts, alt;
  s1 = this_player()->expand_nickname(lower_case(s1));
  alts = explode(lower_case(s2)," ") - ({ "" }) - ({ 0 });
  foreach(alt in alts)
    write(PLAYERINFO_HANDLER->add_alt(this_player(), s1, alt));
  return 1;
}
mixed *query_patterns()
{
    return ({
        "<word'player-name'> <string'alt-name alt-name ...'>",
        (: add_alt($4[0],$4[1]) :)
    });
}

==================================================
FILE: creator/addevent.c
==================================================

#include <creator.h>
#include <playerinfo.h>
#include <player_handler.h>
inherit "/cmds/base";
void update_database(string comment, string *data) {
    if (comment == 0) {
       return;
    }
    if (PLAYERINFO_HANDLER->add_entry(this_player(),
                                      data[0],
                                      data[1],
                                      comment+"\n")) {
        write(capitalize(data[0])+"'s dossier updated.  \n");
    } else {
        write("Cannot update "+capitalize(data[0])+"'s dossier.  \n");
    }
}
int add_event(string player, string event, string comment) {
    string *events;
    string myself;
    player = this_player()->expand_nickname(lower_case(player));
    event = lower_case(event);
    if (!PLAYER_HANDLER->test_user(player)) {
        add_failed_mess("No such player: " + player + ".\n");
        return 0;
    }
    myself = base_name(this_object());
    events = filter(PLAYERINFO_HANDLER->query_events(),
                (: PLAYERINFO_HANDLER->query_source_ok($1, $(myself)) :));
    if (member_array(event, events) == -1) {
       add_failed_mess("Incorrect event type '" + event +
                       "' it must be one of " +
                       query_multiple_short(events) + ".\n");
       return 0;
    }
    if (comment != 0) {
        update_database(comment, ({ player, event }));
        return 1;
    }
    write("Please enter your comments:\n");
    this_player()->do_edit(0, "update_database", this_object(), 0,
                           ({ player, event }));
    return 1;
}
int list_events() {
    string result;
    string myself;
    string *list;
    result = "";
    myself = base_name(this_object());
    list = sort_array(
            filter(PLAYERINFO_HANDLER->query_events(),
                (: PLAYERINFO_HANDLER->query_source_ok($1, $(myself)) :)), 1);
    write("The following events can be added using addevent: " +
          query_multiple_short(list) + ". \n");
    return 1;
}
mixed *query_patterns()
{
    return ({
        "list",
        (: list_events() :),
        "<word'player-name'> <word'event'>",
        (: add_event($4[0],$4[1],0) :),
        "<word'player-name'> <word'event'> <string'comment'>",
        (: add_event($4[0],$4[1],$4[2]) :)
    });
}

==================================================
FILE: creator/auto_doc.c
==================================================

inherit "/cmds/base";
#include <autodoc.h>
int cmd(string str) {
   string *files;
   string file;
   files = this_player()->get_files(str);
   if (!sizeof(files)) {
      notify_fail("Unable to find the files " + str + ".\n");
      return 0;
   }
   foreach (file in files) {
      if (AUTODOC_HANDLER->recreate_documentation(file)) {
         write("Recreating documentation for " + file + ".\n");
      } else {
         write("Unable to recreate documentation for " + file + ".\n");
      }
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
 }

==================================================
FILE: creator/autodocadd.c
==================================================

inherit "/cmds/base";
#include <autodoc.h>
int cmd(string str) {
   string *files;
   string file;
   files = this_player()->get_files(str);
   if (!sizeof(files)) {
      notify_fail("Unable to find the files " + str + ".\n");
      return 0;
   }
   foreach (file in files) {
      if (AUTODOC_HANDLER->add_file(file)) {
         write("Added file " + file + ".\n");
      } else {
         write("Unable to add file " + file + ".\n");
      }
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
 }

==================================================
FILE: creator/autodocrm.c
==================================================

inherit "/cmds/base";
#include <autodoc.h>
int cmd(string str) {
   string *files;
   string file;
   files = this_player()->get_files(str);
   if (!sizeof(files)) {
      notify_fail("Unable to find the files " + str + ".\n");
      return 0;
   }
   foreach (file in files) {
      if (AUTODOC_HANDLER->remove_file(file)) {
         write("Removed file " + file + ".\n");
      } else {
         write("Unable to remove file " + file + ".\n");
      }
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<string>", (: cmd($4[0]) :) });
 }

==================================================
FILE: creator/ban.c
==================================================

#include <parser.h>
#include <access.h>
inherit "/cmds/base";
mixed cmd(string ip, string reason) {
  seteuid("Root");
  if (this_player() != this_player(1))
    return 0;
  if(!"/secure/master"->query_lord(geteuid(previous_object())) &&
     !"/d/liaison/master"->query_deputy(geteuid(previous_object())))
    return notify_fail("Only lords or liaison deputies can do that.\n");
  if(strsrch(ip, "*") != -1)
    return notify_fail("This command does not take wildcards.\n");
  if (!"/secure/bastards"->change_access(ip, 2, reason,
                                         time() + (60*60*2))) {
    write("Error changing permissions.\n");
    return 0;
  }
  write("Site banned.\n");
  return 1;
}
int help() {
  return notify_fail(
    "Syntax: ban <ip number> <reason>\n");
}
mixed *query_patterns() {
  return ({ "<word'address'> <string'reason'>",
              (: cmd($4[0], implode($4[1..], "")) :),
              "help", (: help() :)
              });
}

==================================================
FILE: creator/bugreps.c
==================================================

#include <config.h>
#include <db.h>
inherit "/cmds/base";
int db;
void finish_request(int type, mixed* data, object person) {
   string ret;
   mapping row;
   if (type == DB_SUCCESS) {
      ret = "";
      foreach (row in data) {
         ret += sprintf("%-15s %s\n", row["Reporter"], "" + row["bing"]);
      }
   } else {
      ret = "Some sort of horrible error!\n";
   }
   person->more_string(ret, "details");
}
int cmd(string who){
   string request;
   if(who == "all") {
      request = "select Reporter, count(*) as bing from errors "
                   "group by Reporter order by bing desc";
   } else {
      request = "select Reporter, count(*) as bing from errors "
		   "where Reporter = '" + who + "'"
                   "group by Reporter order by bing desc";
   }
   DB_HANDLER->make_sql_request("errors", CONFIG_DB_USER, "", request,
                                (: finish_request($1, $2, $(this_player())) :));
   add_succeeded_mess("");
   return 1;
}
mixed *query_patterns() {
   return ({ "<string'person|all'>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/callouts.c
==================================================

#define CALL_OUT_SORT_THRESHOLD 1000
#define CALL_OUT_FILE_NAME 0
#define CALL_OUT_FUNCTION 1
#define CALL_OUT_TIME 2
inherit "/cmds/base";
private mixed *get_call_outs() {
    mixed *junk;
    junk = call_out_info();
    if (sizeof(junk) < CALL_OUT_SORT_THRESHOLD) {
        junk = sort_array( junk, (: ( $1[ 2 ] > $2[ 2 ] ) -
            ( $1[ 2 ] < $2[ 2 ] ) :) );
    }
    return junk;
}
int count_callouts() {
    mixed *call_outs = get_call_outs();
    mapping count = ([ ]);
    string ret = "";
    foreach( mixed *func in call_outs) {
        count[ file_name( func[ CALL_OUT_FILE_NAME ] ) + ":" +
            func[ CALL_OUT_FUNCTION ] ] += 1;
    }
    foreach( string key, int value in count ) {
        ret += sprintf( "%-30s %d\n", key, value );
    }
    this_player()->more_string( ret, "Callouts" );
    return 1;
}
int count_clean() {
    mixed *call_outs = get_call_outs();
    string ret = "";
    foreach( mixed *func in call_outs) {
        if ( base_name( func[CALL_OUT_FUNCTION] ) != "effect_timer" &&
          base_name( func[CALL_OUT_FUNCTION] ) != "print_messages" ) {
            ret += sprintf( "%O: %O in %O\n",
                        file_name( func[ CALL_OUT_FILE_NAME ] ),
                        func[ CALL_OUT_FUNCTION ], func[ CALL_OUT_TIME ] );
        }
    }
    this_player()->more_string( ret, "Callouts" );
    return 1;
}
int count_for_file( string str ) {
    mixed *call_outs = get_call_outs();
    string ret = "";
    foreach( mixed *func in call_outs) {
        if ( sscanf( file_name( func[ 0 ] ), "%*s"+ str +"%*s" ) == 2 ) {
            ret += sprintf( "%O: %O in %O\n",
                file_name( func[ CALL_OUT_FILE_NAME ] ),
                func[ CALL_OUT_FUNCTION ], func[ CALL_OUT_TIME ] );
        }
    }
    this_player()->more_string( ret, "Callouts" );
    return 1;
}
int count_time(string choice, int mtime ) {
    mixed *call_outs = get_call_outs();
    string ret = "";
    foreach( mixed *func in call_outs) {
        if ( choice == "before" && func[ CALL_OUT_TIME ] >= mtime ) {
            continue;
        } else if ( choice == "after" && func[ CALL_OUT_TIME ] <= mtime ) {
            continue;
        } else if ( choice == "at" && func[ CALL_OUT_TIME ] != mtime ) {
            continue;
        }
        ret += sprintf( "%O: %O in %O\n", func[ CALL_OUT_FILE_NAME ],
            func[ CALL_OUT_FUNCTION ], func[ CALL_OUT_TIME ] );
    }
    if ( ret == "" ) {
        add_failed_mess( "No callouts matching that criteria found.\n" );
        return -1;
    }
    this_player()->more_string( ret, "Callouts" );
    return 1;
}
int cmd() {
    mixed *call_outs = get_call_outs();
    string ret = "";
    foreach( mixed *func in call_outs) {
        ret += sprintf( "%O: %O in %O\n", func[ CALL_OUT_FILE_NAME ],
            func[ CALL_OUT_FUNCTION ], func[ CALL_OUT_TIME ] );
    }
    this_player()->more_string( ret, "Callouts" );
    return 1;
}
mixed *query_patterns() {
    return ({ "{-c|count}", (: count_callouts :),
              "{-b|no effects}", (: count_clean :),
              "<string'file'>", (: count_for_file( $4[0] ) :),
              "{before|at|after} <number'time'>",
                (: count_time($4[0], $4[1]) :),
              "", (: cmd :),
    });
}

==================================================
FILE: creator/cloner.c
==================================================

inherit "/cmds/base";
#define CLONER "/global/cloner"
#define LIFE_TIME 7257600
int do_list(string file) {
  string *files, change;
  mapping changes;
  string ret;
  if(file && file != "") {
    files = this_player()->get_files(file);
  }
  changes = CLONER->query_changes();
  ret = "";
  foreach(change in keys(changes)) {
    if(files && member_array(change, files) == -1 &&
       strsrch(change, file) == -1) {
      continue;
    }
    ret += sprintf("%s:\n  %s until %s\n", change, changes[change][0],
           ctime(changes[change][1] + LIFE_TIME));
  }
  this_player()->more_string( ret, "Cloner list", 1 );
  return 1;
}
int do_move(string source, string dest) {
  string *sources, *tmp, destp, rcs;
  seteuid(geteuid(this_player()));
  sources = this_player()->get_files(source);
  if(!sizeof(sources))
    return notify_fail("No source files found.\n");
  destp = this_player()->get_path(dest);
  if(file_size(destp) != -2 && !mkdir(dest))
    return notify_fail("Destination must be a directory.\n");
  foreach(source in sources) {
    if(file_size(source) == -2 || file_size(source) == -1) {
      if(source[<4..] == "/RCS") {
        if(rename(source, source+".tmp"))
          return notify_fail("Error moving RCS directory to temp location.\n");
        else
          rcs = source+".tmp";
      } else
        write("Not moving directory: " + source + "\n");
    } else {
      tmp = explode(source, "/");
      dest = destp + "/" + tmp[sizeof(tmp)-1];
      if(rename(source, dest))
        return notify_fail("Error renaming [" + source + "] to [" + dest +
                           "]\n");
      CLONER->add_mapping(source, dest);
    }
  }
  if(rcs && rename(rcs, destp + "/RCS"))
    return notify_fail("Error moving RCS directory.\n");
  return 1;
}
int do_add(string source, string dest) {
  CLONER->add_mapping(source, dest);
  return 1;
}
int do_remove(string source) {
  CLONER->remove_mapping(source);
  return 1;
}
mixed *query_patterns() {
  return ({ "list", (: do_list(0) :),
            "list <word'file'>", (: do_list($4[0]) :),
            "move <word'source'> <word'dest'>", (: do_move($4[0], $4[1]) :),
            "add <word'source'> <word'dest'>", (: do_add($4[0], $4[1]) :),
            "remove <word'source'>", (: do_remove($4[0]) :),
              });
}

==================================================
FILE: creator/clubs.c
==================================================

#include <runtime_config.h>
#include <clubs.h>
#include <mail.h>
#include <money.h>
inherit "/cmds/base";
#define CONTROL_ROOM "/std/room/club_control_room"
#define ELEN 20
private void do_list(string extra, int width);
private void do_invalid(string extra, int width);
mixed cmd(string command, string extra, string rest) {
  if (this_player() != this_player(1))
    return 0;
  switch(command) {
  case "list":
    do_list(extra, this_player()->query_cols());
    break;
  case "invalid":
    do_invalid(extra, this_player()->query_cols());
    break;
  }
  return 1;
}
private string club_line(string club, int width, int verbose) {
  string tmp, tmp2, member;
  int clubtype, i;
  clubtype = CLUB_HANDLER->query_club_type(club);
  tmp = sprintf("%%^BOLD%%^%%^RED%%^%-9s%%^RESET%%^ %-15s\n",
                CLUB_ARRAY[clubtype]+":", club);
  if(verbose) {
        tmp+= sprintf(" %%^BOLD%%^Club Name:%%^RESET%%^ %s\n",
                  CLUB_HANDLER->query_club_name(club));
    tmp += sprintf(" %%^BOLD%%^Founder:%%^RESET%%^ %s\n"
                   " %%^BOLD%%^Members:%%^RESET%%^\n",
                   CLUB_HANDLER->query_founder(club));
    i = 0;
    tmp2 = "";
    foreach(member in CLUB_HANDLER->query_members(club)) {
      tmp2 += sprintf("%-15s ", member);
      if((i-1 * ELEN) % (width/ELEN) == 0  && tmp2 != "") {
        tmp += this_player()->fix_string("   " + tmp2 + "\n", width, 10);
        tmp2 = "";
      }
      i++;
    }
  }
  return tmp;
}
private void do_list(string extra, int width) {
  string club, tmp, t2, *clubs;
  tmp = "";
  clubs = sort_array(CLUB_HANDLER->query_clubs(),
                     (: strcmp($1, $2 ) :) );
  foreach(club in clubs) {
    if(extra == "" || extra == "brief" || extra == "verbose" ||
       strsrch(club, extra) != -1) {
      t2 = club_line(club, width, (extra != "brief"));
      if(strlen(tmp) + strlen(t2) < 200000)
        tmp += t2;
      else
        break;
    }
}
  if(tmp == "")
    write("No clubs matching " + extra + ".\n");
  else
    this_player()->more_string(tmp, "Clubs", 1);
}
private int do_balance(string club_name) {
   int balance;
   string place;
   if (!CLUB_HANDLER->is_club(club_name)) {
      add_failed_mess("There is no club called '" +
                      CLUB_HANDLER->query_club_name(club_name) + "'.\n");
   }
   place = environment(this_player())->query_property("place");
   if (!place) {
      place = "default";
   }
   balance = CLUB_HANDLER->query_balance(club_name);
   write("The balance of the club '" +
         CLUB_HANDLER->query_club_name(club_name) + "' is " +
         MONEY_HAND->money_value_string(balance, place) + ".\n");
   return 1;
}
mixed *query_patterns() {
  return ({ "list", (: cmd("list", "", "") :),
            "list <string'club name'>", (: cmd("list", $4[0], "") :),
            "balance <string'club name'>", (: do_balance($4[0]) :)
        });
}

==================================================
FILE: creator/comment.c
==================================================

inherit "/cmds/report_base";
void create() {
   ::create();
   set_error_type("COMMENT");
   set_use_last_error(1);
}

==================================================
FILE: creator/compare.c
==================================================

#include <creator.h>
inherit "/cmds/base";
int cmd( string words ) {
  string *name = allocate(2);
  string *mess = allocate(2);
  object *person = allocate(2);
  object *tmp;
  object thing;
  mixed *inv = allocate(2);
  mixed *matching = allocate(2);
  int i;
  sscanf( words, "%s with %s", name[0], name[1] );
  for( i=0; i<2; i++)
    name[i] = this_player()->expand_nickname( name[i] );
  for( i=0; i<2; i++) {
    if( !(person[i] = find_player( name[i] )) )
         return notify_fail("No such player - " + name[i] + ".\n");
    inv[i] = all_inventory( person[i] );
    tmp = ({ });
    foreach( thing in inv[i] )
      if( thing->query_cloned_by() == name[!i] ) tmp += ({ thing });
    if(tmp) {
      switch( arrayp(tmp) ) {
        case 1:  matching[i] = tmp; break;
        default: matching[1] = ({ tmp });
      }
    }
    switch( sizeof(matching[i]) ) {
      case 0:
        mess[i] = "No items in " + name[i] + " were cloned by " + name[!i] + ".\n";
        break;
      case 1:
        mess[i] = "One item in " + name[i] + " was cloned by " + name[!i] + ".\n";
        mess[i] += "  " + WIZ_PRESENT->desc_f_object(matching[i][0]) + "\n";
        break;
      default:
        mess[i] = sizeof(matching[i]) + " items in " + name[i] +
                                       " were cloned by " + name[!i] + ".\n";
        foreach( thing in matching[i] )
          mess[i] += "  " + WIZ_PRESENT->desc_f_object(thing) + "\n";
    }
  }
  write(mess[1] + "\n" + mess[0]);
  return 1;
}

==================================================
FILE: creator/compare2.c
==================================================

#include <creator.h>
inherit "/cmds/base";
string format_data( object *items, object victim, object target ) {
    int size;
    string vname, tname;
    vname = victim->the_short();
    tname = target->the_short();
    switch( size = sizeof( items ) ) {
    case 0:
        return "No objects in " + vname + " were cloned by " +
        tname;
    case 1:
        return "One object, " + query_multiple_short( items ) +
        " in " + vname + "'s inventory was cloned by " +
        tname;
    default:
        return query_num( size, 100 ) + " objects in " +
        vname + "'s inventory were cloned by " + tname;
    }
}
void describe_objects( object player1, object player2 ) {
    string mess;
    mapping data;
    data = filter( unique_mapping( all_inventory( player1 ),
        (: $1->query_cloned_by() :) ),
      (: $1 == $(player2)->query_name() :) );
    if ( !sizeof( data ) ) {
        data[ player1->query_name() ] = ({ });
    }
    mess = implode( values( map( data,
          (: format_data( $2, $(player1), $(player2) ) :) ) ), "\n" );
    tell_object( this_player(), "$P$compare$P$" + mess + "." );
}
int cmd( object player1, object player2 ) {
    describe_objects( player1, player2 );
    describe_objects( player2, player1 );
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:wiz-present> {against|with|and} "
      "<indirect:wiz-present>",
      (: cmd( $1[0][0], $1[1][0] ) :) });
}

==================================================
FILE: creator/crea_tor.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  object *ov, ob;
  notify_fail("Creator of what?\n");
  ov = WIZ_PRESENT->wiz_present(str,this_player());
  if (!sizeof(ov)) return 0;
  foreach (ob in ov) {
    write("Creator of " + WIZ_PRESENT->desc_object(ob) + ": " +
        master()->creator_file (file_name(ob)) + ", uid: " +
        getuid(ob) + ", euid: "+geteuid(ob)+"\n");
  }
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/cst_at.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  object *ob, thing;
  mixed *ob1, *thing1;
  string s, bing;
  string long_fields, temp;
  int long_length;
  bing = "";
  str = (string)this_player()->expand_nickname(str);
  ob = WIZ_PRESENT->wiz_present(str, this_player());
  if (!sizeof(ob)) {
    write("No such object.\n");
    return 1;
  }
  foreach (thing in ob) {
    ob1 = (mixed *)thing->stats();
    if (!pointerp(ob1))
      continue;
    s = "";
    long_fields = "";
    long_length = ( (int)this_player()->query_cols() / 3 ) - 1;
    foreach (thing1 in (pointerp(ob1[0][0])?ob1[0]:ob1))
      if ( thing1[ 1 ] && !sscanf(thing1[0],"(%s)",temp)) {
        temp = thing1[0] +": "+ thing1[ 1 ] +"\n";
        if (strlen(temp) > long_length) long_fields += temp;
        else s += temp;
      }
    bing += sprintf("%-*#s\n", this_player()->query_cols(), long_fields) +
        sprintf( "%-*#s\n", this_player()->query_cols(), s );
  }
  this_player()->more_string(bing);
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/data.c
==================================================

#include <creator.h>
inherit "/cmds/base";
int cmd(object *obs, string var) {
    object ob;
    foreach (ob in obs) {
        if ( userp(ob) && !master()->query_lord( this_player()->query_name() ) ) {
            write("You cannot dump a player object.\n");
            continue;
        }
        else {
            this_player()->more_string( WIZ_PRESENT->desc_object( ob ) + ":\n" +
              debug_info( 2, ob ) + "\n", "Data" );
        }
    }
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:wiz-present>", (: cmd($1, 0) :) });
}

==================================================
FILE: creator/dbxwhere.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  mapping error;
  object ob;
  if (str) {
    str = this_player()->expand_nickname(str);
    ob = find_player(str);
    if (!ob) {
      write("No such player.\n");
      return 1;
    }
  } else
    ob = this_player();
  if (error = (mapping)ob->get_last_error()) {
    printf("%s\n", master()->standard_trace(error, 1));
  } else write("No error.\n");
  return 1;
}

==================================================
FILE: creator/debug.c
==================================================

inherit "/cmds/base";
#include <creator.h>
int cmd(object *obs, int detail) {
   object ob;
   foreach (ob in obs) {
      write(WIZ_PRESENT->desc_object(ob) + ":\n" + debug_info(detail, ob) + "\n");
   }
   return 1;
}
mixed *query_patterns() {
  return ({ "-v <indirect:wiz-present>", (: cmd($1, 2) :),
              "<indirect:wiz-present>", (: cmd($1, 1) :) });
}

==================================================
FILE: creator/define.c
==================================================

inherit "/cmds/base";
#include <network.h>
void finish_lookup(object player, string word, int result, mixed* results) {
   string ret;
   string* bing;
   if (result == NETWORK_SUCCESS) {
      if (!sizeof(results)) {
         tell_object(player, "No definitions for " + word + ".\n");
      } else {
         ret = "";
         foreach (bing in results) {
            ret += bing[1] + "\n" + bing[2] + "\n\n";
         }
         tell_object(player, "Definitions for " + word + ":\n" + ret);
      }
   } else {
      tell_object(player, "Error matching " + word + ": " + result);
   }
}
int cmd(string word) {
   NETWORK_DICTIONARY_HANDLER->define_word(word, 0,
                        (: finish_lookup($(this_player()), $1, $2, $3) :));
   add_succeeded_mess("$N look$s up a word.\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/delalt.c
==================================================

#include <creator.h>
#include <playerinfo.h>
inherit "/cmds/base";
int delete_alt(string s1, string s2) {
  string *alts, alt;
  s1 = this_player()->expand_nickname(lower_case(s1));
  alts =  explode(lower_case(s2)," ") - ({ "" }) - ({ 0 });
  foreach(alt in alts)
    write(PLAYERINFO_HANDLER->delete_alt(this_player(), s1, alt));
  return 1;
}
mixed *query_patterns()
{
    return ({
        "<word'player-name'> <string'alt-name alt-name ...'>",
        (: delete_alt($4[0],$4[1]) :)
    });
}

==================================================
FILE: creator/delevent.c
==================================================

#include <creator.h>
#include <playerinfo.h>
#include <player_handler.h>
inherit "/cmds/base";
int delete_event(string s1, string s2, int n)
{
    string  who = lower_case(s1);
    string  event = lower_case(s2);
    if(!PLAYER_HANDLER->test_user(who)) {
        write("No such player: "+who+".  \n");
        return 1;
    }
    if(PLAYERINFO_HANDLER->delete_entry(this_player(),who,event,n))
        write("Entry #" + n + " of " + capitalize(who) +
            "'s dossier deleted.  \n");
    else
        write("Cannot remove entry #" + n + " from " +
            capitalize(who) + "'s dossier.  \n");
    return 1;
}
mixed *query_patterns()
{
    return ({
        "<word'player-name'> <word'event'> <number'entry-number'>",
        (: delete_event($4[0],$4[1],$4[2]) :)
    });
}

==================================================
FILE: creator/denied.c
==================================================

int db;
int cmd(string who){
  mixed rows;
  string ret;
  db = db_connect("localhost", "errors");
  if(who == "all")
    rows = db_exec(db, "select Reporter, count(*) as bing from errors "
		   "where Status = 'DENIED' "
                   "group by Reporter order by bing desc");
  else
    rows = db_exec(db, sprintf("select Reporter, count(*) from errors "
                               "where Reporter = '%s' and Status = 'DENIED' "
			       "group by Reporter",
                               who));
  if(intp(rows)){
    ret = sprintf("%-15s %s\n", "player", "reports");
    ret += implode(allocate(rows, function(int i){
      mixed *tmp = db_fetch(db, i+1);
      return sprintf("%-15s %s", tmp[0], ""+tmp[1]);
    }), "\n");
    ret += "\n";
    db_close(db);
    this_player()->more_string(ret);
  } else printf(rows);
  return 1;
}

==================================================
FILE: creator/dest_ruct.c
==================================================

#include <creator.h>
inherit "/cmds/base";
void main_dest_bit(object *ob);
void ask_dest(object *obs) {
  if (!pointerp(obs) || !sizeof(obs)) {
    write("No more things to dest.\n");
    return;
  }
  write("Dest object " + WIZ_PRESENT->desc_object(obs[0]) + " ? ");
  input_to("dest_answer", 0, 0, obs);
  return;
}
void dest_answer(string s, int majd, object *obs) {
  string err, shrt;
  if (this_player()->affirmative(s)) {
    if (majd) {
      shrt = (string)obs[0]->short();
      err = catch(obs[0]->dwep());
      this_player()->handle_error(err, "DWEP");
      if (obs[0]) {
        write("It REALLY doesn't want to be dested.\n");
        err = catch(destruct(obs[0]));
        this_player()->handle_error(err, "destruct()");
      }
      majd = 0;
      if (obs[0]) write("It didn't dest.\n");
      else {
        say((string)this_player()->query_cap_name()+" disintegrates "+
            (shrt ? shrt : "something") +".\n");
        write("Ok.\n");
      }
      ask_dest(obs[1..]);
      return;
    } else {
      obs[0]->move("/room/rubbish");
      err = catch(obs[0]->dest_me());
      this_player()->handle_error(err, "dest_me");
      if (obs[0]) {
        write("This object does NOT want to be dested.  Are you sure? ");
        input_to("dest_answer", 0, 1, obs);
        return;
      }
      write("Ok.\n");
      ask_dest(obs[1..]);
      return;
    }
  } else if (s == "q" || s == "quit") {
    write("Ok.  No more objects will be destd.\n");
    return;
  }
  write("Ok.  Not destd.\n");
  ask_dest(obs[1..]);
  return;
}
mixed cmd(string str) {
  object *ob, *dest_obj;
  string qstr;
  dest_obj = ({ });
  notify_fail("Can't find " + str + " to dest.\n");
  if ( !str || ( str == "" ) )
    return notify_fail( "Destruct what?\n" );
  if (this_player()->query_name() == "simidh") {
     write("Bye bye...\n");
     this_player()->dest_me();
     return 1;
  }
  if (sscanf(str, "query %s", qstr) == 1) {
    dest_obj = WIZ_PRESENT->wiz_present(qstr, this_player());
    if (!sizeof(dest_obj)) return 0;
    ask_dest(dest_obj);
    return 1;
  }
  ob = WIZ_PRESENT->wiz_present(str,this_player());
  if (!sizeof(ob)) return 0;
  main_dest_bit(ob);
  return 1;
}
void main_dest_bit(object *ob) {
  object thing, *rest, *dest_obj;
  string err, shrt, dobj;
  rest = ({ });
  dest_obj = ({ });
  foreach (thing in ob) {
    if (interactive(thing) && sizeof(ob) != 1) {
      write("You DON'T destruct " + thing->query_name() + ".\n");
      continue;
    }
    catch(shrt = (string)thing->short());
    dobj = WIZ_PRESENT->desc_object(thing);
    thing->move("/room/rubbish");
    err = catch(thing->dest_me());
    this_player()->handle_error(err, "dest_me");
    if (thing)
      dest_obj += ({ thing });
    else {
      write("You destruct " + dobj + ".\n");
      say((string)this_player()->query_cap_name()+" disintegrates "+
          (shrt ? shrt : "something") + ".\n");
    }
  }
  if (sizeof(dest_obj) > 0) {
    ask_dest(dest_obj);
    return;
  }
  return;
}

==================================================
FILE: creator/dir_s.c
==================================================

inherit "/cmds/base";
#include <peopler.h>
#include <creator.h>
mixed cmd(string str) {
   mixed *stuff;
   stuff = this_player()->query_property("dir list");
   if (!stuff) {
      stuff = D_DEFAULT;
   }
   return PEOPLER->do_command(stuff, str);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/dist_ribution.c
==================================================

inherit "/cmds/base";
varargs int cmd(string num) {
  object player, *players;
  int division, i, max, slot;
  mapping stuff;
  division = to_int(num);
  if(!division) {
    division = 50;
  }
  stuff = ([ ]);
  players = users();
  max = 0;
  foreach( player in players )  {
    if ( !player->query_creator() )  {
      slot = player->query_level() / division;
      ++stuff[slot];
      if ( slot > max )  max = slot;
    }
    else players -= ({ player });
  }
  write("%^ORANGE%^Player level distribution:%^RESET%^\n");
  for ( i = 0; i < max; i++ )  {
    if ( stuff[i] )  {
      printf( "%5d ..%4d:\t%3d\t%3d%%\n", division * i, division * (i + 1) - 1,
              stuff[i], stuff[i] * 100  / sizeof( players ) );
    }
  }
  return 1;
}

==================================================
FILE: creator/dump.c
==================================================

inherit "/cmds/base";
#include <creator.h>
int cmd(object *obs) {
   object ob;
   foreach (ob in obs) {
      write(WIZ_PRESENT->desc_object(ob) + ":\n" + debug_info(0, ob) + "\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:wiz-present>", (: cmd($1) :) });
}

==================================================
FILE: creator/dupd_ate.c
==================================================

inherit "/cmds/base";
#include <creator.h>
string other;
int do_it(string str){
  object ob, *obs;
  string *all, *dil, file, fnob ;
  obs = WIZ_PRESENT->wiz_present(str, this_player());
  if(!sizeof(obs))
    return 0;
  foreach(ob in obs){
    fnob = file_name(ob);
    all = inherit_list(ob);
    foreach(file in all){
      if (other){
        dil = deep_inherit_list(find_object(file));
        if (!((member_array(other, dil) != -1) || other == file))
          continue;
      }
      do_it(file);
    }
    ob->dest_me();
    if (ob)
      ob->dwep();
    if (ob)
      destruct(ob);
    ob = load_object(fnob);
    printf("Updated %s.\n", WIZ_PRESENT->desc_f_object(ob));
  }
  return 1;
}
int cmd(string str){
  object *tmp;
  other = 0;
  notify_fail("usage: dupdate <object> [<object>]\n");
  if (!str)
    return 0;
  sscanf(str, "%s %s", str, other);
  if (other){
    tmp = WIZ_PRESENT->wiz_present(other, this_player());
    if (sizeof(tmp)){
      other = file_name(tmp[0]);
      other += ".c";
    }
    else
      return 0;
  }
  return do_it(str);
}

==================================================
FILE: creator/eff_ects.c
==================================================

inherit "/cmds/base";
int cmd( object * obs, int brief ) {
   object who;
   int num, * enums;
   mixed arg;
   if( !obs )
      obs = ({ this_player() });
   foreach( who in obs ) {
      write( "%^BOLD%^Effects on " + who->query_short() + ":%^RESET%^\n" );
      enums = who->effects_matching( "" );
      if( !sizeof( enums ) ) {
         write( "No effects.\n" );
         printf( "%s\n",
           "-----------------------------------------------------------" );
         continue;
      }
      foreach( num in enums ) {
         arg = who->arg_of(num);
         if ( brief && ( arrayp(arg) || classp(arg) || mapp(arg) ) ) {
            arg = "COMPLEX";
         }
         if ( !brief ) {
            printf( "%s\n",
              "-----------------------------------------------------------" );
         }
         printf( "[%d]   %s (%O)\n", num,
           find_object( who->eff_of(num) )->query_classification(),
           arg );
      }
      printf( "%s\n",
        "-----------------------------------------------------------" );
   }
   return 1;
}
mixed * query_patterns() {
   return ({
     "<indirect:wiz-present> verbose", (: cmd( $1, 0 ) :),
     "<indirect:wiz-present> [brief]", (: cmd( $1, 1 ) :),
     "[me] verbose", (: cmd( 0, 0 ) :),
     "[me] [brief]", (: cmd( 0, 1 ) :),
   });
}

==================================================
FILE: creator/errors.c
==================================================

inherit "/cmds/base";
#include <error_handler.h>
#include <db.h>
#include <nroff.h>
#include <player_handler.h>
class user_data {
   class error_query query;
   class error_summary* errors;
   int pos;
   int last_touched;
   string direction;
   string report;
}
private mapping _user_query;
void create() {
   _user_query = ([ ]);
}
int find_index(object person, int id) {
   int i;
   class error_summary* errors;
   if (!_user_query[person->query_name()]) {
      return 0;
   }
   _user_query[person->query_name()]->last_touched = time();
   errors = _user_query[person->query_name()]->errors;
   for (i = 0; i < sizeof(errors); i++) {
      if (id == errors[i]->id) {
         return i;
      }
   }
   return 0;
}
int max_index(object person) {
   if (!_user_query[person->query_name()]) {
      return 0;
   }
   _user_query[person->query_name()]->last_touched = time();
   return sizeof(_user_query[person->query_name()]->errors);
}
int id_at(object person, int index) {
   if (!_user_query[person->query_name()] || index < 0 ||
       index >= sizeof(_user_query[person->query_name()]->errors)) {
      return 0;
   }
   _user_query[person->query_name()]->last_touched = time();
   return _user_query[person->query_name()]->errors[index]->id;
}
string menu_line(object person) {
   string ret;
   ret = "[" + (_user_query[person->query_name()]->pos + 1) + " of " +
          sizeof(_user_query[person->query_name()]->errors) + "] "
         "STFCOLHA-+PNGQ : ";
   return ret;
}
void finish_details(object person, int verbose,
                    int type, mixed data) {
   string ret;
   class error_details details;
   class error_complete complete;
   class error_comment comment;
   class error_forward forward;
   class error_replies reply;
   class user_data user_data;
   if (type != DB_SUCCESS) {
      tell_object(person, "%^BOLD%^%^RED%^Error: " + data + "%^RESET%^\n");
      return ;
   }
   user_data = _user_query[person->query_name()];
   complete = data[0];
   details = complete->details;
   ret = "%^BOLD%^%^CYAN%^Bug #" + details->summary->id + "%^RESET%^ " +
         details->summary->status + " " + details->summary->type + " " +
         details->summary->category + "\n";
   ret += "%^BOLD%^Date Reported%^RESET%^     : " +
             ctime(details->summary->entry_date) + "\n";
   ret += "%^BOLD%^Assigned To%^RESET%^       : " +
          details->summary->assigned_to + "\n";
   ret += "%^BOLD%^Reporter%^RESET%^          : " + details->summary->reporter + "\n";
   ret += "%^BOLD%^File name%^RESET%^         : " + details->summary->filename + "\n";
   if (verbose) {
      ret += "%^BOLD%^Directory%^RESET%^         : " + details->summary->directory + "\n";
   }
   if (details->summary->status == "FIXED" ||
       details->summary->status == "DENIED") {
      ret += "%^BOLD%^Fixed By%^RESET%^          : " + details->fixer +
             " (" + ctime(details->fix_date) + ")\n";
   }
   if (verbose) {
      if (sizeof(complete->forwards)) {
         ret += "%^BOLD%^Forwards%^RESET%^          :\n";
         foreach (forward in complete->forwards) {
            ret += "$I$5=     " + forward->forwarder + " from " +
                   forward->old_directory + " at " +
                   ctime(forward->date)[4..15] + "\n";
         }
      }
   }
   ret += "$I$0=" + details->report;
   if (verbose) {
      ret += details->runtime;
   } else if (details->runtime && details->runtime != "") {
      ret += "[Runtime Available]\n";
   }
   user_data->report = details->report;
   if (verbose) {
      ret += "$I$3=   ";
      foreach (reply in complete->replies) {
         ret += "%^BOLD%^Date Sent%^RESET%^   : " + ctime(reply->senddate)[4..15] +
                "\n%^BOLD%^From%^RESET%^        : " + reply->sender +
                "\n%^BOLD%^To%^RESET%^          : " + reply->recipient +
                "\n%^BOLD%^Subject%^RESET%^     : " + reply->subject + "<br>" +
                reply->message + "\n";
      }
      if (sizeof(complete->replies) && sizeof(complete->comments)) {
         ret += "$I$0=-------------------------------------------------------------\n$I$3=   ";
      }
      foreach (comment in complete->comments) {
         ret += "%^BOLD%^Comment by " + comment->commenter + " at " +
                ctime(comment->date)[4..15] + "%^RESET%^\n" +
                comment->comment + "\n";
      }
   } else {
      if (sizeof(complete->replies) > 0) {
         ret += sizeof(complete->replies) + " error replies.\n";
      }
      if (sizeof(complete->comments) > 0) {
         ret += sizeof(complete->comments) + " comments.\n";
      }
   }
   person->set_finish_func("finish_more_details", this_object());
   tell_object(person, "$P$Bug #" + details->summary->id + "$P$" + ret);
}
int finish_more_details() {
   object ob;
   ob = this_player();
   write(menu_line(ob));
   input_to("menu_response");
}
int finish_forward(object person, int pos, string new_dir, int type, mixed mess) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Unable to forward bug #" +
                          data->errors[data->pos]->id +
                          " to " + new_dir + " (" + mess + ")");
   } else {
      tell_object(person, "Forwarded bug #" +
                          data->errors[data->pos]->id +
                          " from " + data->errors[data->pos]->directory +
                          " to " + new_dir);
      data->errors[data->pos]->directory = new_dir;
   }
}
void finish_change_status(object person, string status, int command,
                          string subject, int no_reply, int type, mixed mess) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Database error: " + mess);
      if (!command) {
         tell_object(person, menu_line(person));
      }
      return ;
   }
   tell_object(person, "Updated status of bug #" + data->errors[data->pos]->id +
               " to " + status + (no_reply ?  " (no reply) " : "") +"\n");
   if (!command) {
      data = _user_query[person->query_name()];
      tell_object(person, menu_line(person));
      data->errors[data->pos]->status = status;
   }
}
void finish_status_message(object person, string status, int command,
                           string subject, string mess) {
   class user_data data;
   int pos;
   data = _user_query[person->query_name()];
   if (!mess) {
      tell_object(person, "Message aborted.\n");
      if (!command) {
         tell_object(person, menu_line(person));
      }
      return ;
   }
   if (status == "THANKS" || status == "TEMPORARY") {
      status = "FIXED";
   }
   if (status == "NOTREPRODUCIBLE" || status == "NOINFO" ||
       status == "NOTPOSSIBLE") {
      status = "DENIED";
   }
   pos = strsrch("$report$", mess);
   if (pos == -1) {
      mess += "\n\n" + data->report;
   } else {
      mess = replace_string(mess, "$report$", data->report);
   }
   if (!command) {
      input_to("menu_response");
   }
   if (!ERROR_HANDLER->do_change_status(data->errors[data->pos]->id,
                        status, subject == 0, subject, person->query_name(),
                        mess,
                        (: finish_change_status, person, status, command,
                                          subject, subject == 0 :))) {
      tell_object(person, "Unhappily an error occured.\n");
      if (!command) {
         tell_object(person, menu_line(person));
      }
   }
}
string query_subject_from_type(string type, class error_summary error) {
   switch (type) {
   case "THANKS" :
      return "Thanks for " + error->category + " " + error->type;
   case "NOTPOSSIBLE" :
      return "Not possible to fix " + error->category + " " + error->type;
   case "NOTREPRODUCIBLE" :
      return "Not able to reproduce " + error->category + " " + error->type;
   case "FIXED" :
      return "Fixed bug #" + error->id;
   case "DENIED" :
      return "Denied bug #" + error->id;
   default :
      return "Change status of bug #" + error->id + " to " +
             type;
   }
}
string query_message_from_type(object person, string type,
                               class error_summary error) {
   switch (upper_case(type)) {
   case "THANKS" :
      return "Thanks for the " + lower_case(error->type) + ".\n\nGood luck!\n" +
             person->query_cap_name();
   case "TEMPORARY" :
      return "Your " + lower_case(error->type) +
             " report was a temporary problem in the system and has "
             "since been resolved.  Thanks for reporting it."
             "\n\nGood luck!\n" +
             person->query_cap_name();
   case "NOTENOUGHINFORMATION" :
      return "Your " + lower_case(error->type) +
             " report did not contain enough information for this " +
             lower_case(error->type) + " to be resolved.  Please report "
             "again with more detailed information."
             "\n\nGood luck!\n" +
             person->query_cap_name();
   case "NOTREPRODUCIBLE" :
      return "Unable to reproduce your " + lower_case(error->type) +
             " report.  If you can track down exactly the circumstances "
             "which generate this error, please report it again."
             "\n\nGood luck!\n" +
             person->query_cap_name();
   case "NOTPOSSIBLE" :
      return "Thank you for your " + lower_case(error->type) +
             " report, this " + lower_case(error->type) +
             " is not possible to fix, because of code restrictions."
             "\n\nGood luck!\n" +
             person->query_cap_name();
   case "FIXED" :
   case "DENIED" :
      return "Thank you for your " + lower_case(error->type) +
             " report, this " + lower_case(error->type) +
             " has now been " + lower_case(type) + ".\n\nGood luck!\n" +
             person->query_cap_name();
   case "FIXING" :
      return "Thank you for your " + lower_case(error->type) +
             " report, this " + lower_case(error->type) +
             " is currently being fixed.\n\n"
             "Good luck!\n" +
             person->query_cap_name();
   case "CONSIDERING" :
      return "Thank you for your " + lower_case(error->type) +
             " report, this " + lower_case(error->type) +
             " is currently being considered for future fixing.\n\n"
             "Good luck!\n" +
             person->query_cap_name();
   case "CUSTOM" :
      return "custom";
   case "NONE" :
      return "none";
   case "OPEN" :
      return "Thanks for the " + lower_case(error->type) + ".\n\nGood luck!\n" +
             person->query_cap_name();
   }
}
void finish_change_type(object person, string new_type, int type, mixed mess) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Sql Error: " + mess);
      tell_object(person, menu_line(person));
      return ;
   }
   tell_object(person, "Bug #" + data->errors[data->pos]->id +
                       " has a new type of " + new_type + "\n");
   tell_object(person, menu_line(person));
   data->errors[data->pos]->type = new_type;
}
void finish_change_category(object person, string new_category, int type, mixed mess) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Sql Error: " + mess);
      tell_object(person, menu_line(person));
      return ;
   }
   tell_object(person, "Bug #" + data->errors[data->pos]->id +
                       " has a new category of " + new_category + "\n");
   tell_object(person, menu_line(person));
   data->errors[data->pos]->type = new_category;
}
void finish_assign_bug(object person, string assigner, int type, mixed mess) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (type != DB_SUCCESS) {
      tell_object(person, "Sql Error: " + mess);
      tell_object(person, menu_line(person));
      return ;
   }
   tell_object(person, "Bug #" + data->errors[data->pos]->id +
                       " is assigned to " + assigner + "\n");
   tell_object(person, menu_line(person));
   data->errors[data->pos]->assigned_to = assigner;
}
void finish_adding_comment(object person, int type, mixed mess) {
   if (type != DB_SUCCESS) {
      tell_object(person, "SQL Error: " + mess);
      tell_object(person, menu_line(person));
   }
   tell_object(person, "Added a comment to the bug.\n");
   tell_object(person, menu_line(person));
}
void finish_comment(object person, int id, string comment) {
   if (!comment) {
      write("Aborted adding the comment.\n");
      write(menu_line(person));
      input_to("menu_response");
      return ;
   }
   input_to("menu_response");
   if (!ERROR_HANDLER->do_comment(id, person->query_name(), comment,
                             (: finish_adding_comment, person :))) {
      write("Big bad error.\n");
      write(menu_line(person));
   }
}
int do_bug_details(object person, int id, int verbose) {
   if (!ERROR_HANDLER->do_query_bug_details(id, (: finish_details, person,
                                                   verbose :))) {
      tell_object(person, "Error doing stuff.");
   }
   return 1;
}
int do_forward(object person, string new_dir) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (!ERROR_HANDLER->do_forward(data->errors[data->pos]->id,
                person->query_name(), new_dir,
                    (: finish_forward, person, data->pos, new_dir :))) {
      write("A horrible error occured.\n");
      return 0;
   }
   return 1;
}
int do_change_status(object person, string status, int command, string subject,
                     string mess) {
   if (mess == "custom") {
      tell_object(person, "User $report$ to place the error report in the "
                  "mail.  If $report$ is not included, the report will be "
                  "added onto the end.\n");
      person->do_edit("", (: finish_status_message, person, status, command,
                                                    subject :));
   } else if (mess == "none") {
      finish_status_message(person, status, command, 0, "");
   } else {
      finish_status_message(person, status, command, subject, mess);
   }
}
int do_change_type(object person, string type) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (!ERROR_HANDLER->do_change_type(data->errors[data->pos]->id, type,
       (: finish_change_type, person, type :))) {
      tell_object(person, "Error doing stuff.\n");
   }
   return 1;
}
int do_change_category(object person, string category) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (!ERROR_HANDLER->do_change_category(data->errors[data->pos]->id, category,
       (: finish_change_category, person, category :))) {
      tell_object(person, "Error doing stuff.\n");
   }
   return 1;
}
int do_assign_bug(object person, string assigner) {
   class user_data data;
   data = _user_query[person->query_name()];
   if (!ERROR_HANDLER->do_assign_bug_to(data->errors[data->pos]->id, assigner,
       (: finish_assign_bug, person, assigner :))) {
      tell_object(person, "Error doing stuff.\n");
   }
   return 1;
}
int do_comment(object person) {
   class user_data data;
   data = _user_query[person->query_name()];
   this_player()->do_edit("", (: finish_comment, person,
                                   data->errors[data->pos]->id :));
}
int do_help(object player) {
   string str;
   str = NROFF_HAND->cat_file("/doc/creatornr/errors", 1);
   if (!str) {
      NROFF_HAND->create_nroff("/doc/creator/commands/errors", "/doc/creatornr/errors");
      str = NROFF_HAND->cat_file("/doc/creatornr/errors", 1);
   }
   player->set_finish_func("finish_more_details", this_object());
   tell_object(player, "$P$Error help$P$" + str);
}
int do_list_errors() {
   class user_data data;
   class error_summary error;
   string str;
   int i;
   data = _user_query[this_player()->query_name()];
   str = "";
   i = 1;
   str += sprintf("ndx: #<num> %5-s %4-s %4-s by %11-s %15-s [%s]\n",
                  "Status", "Cat", "Type", "Reporter", "Filename", "Directory");
   foreach (error in data->errors) {
      str += sprintf("$I$3=%3d: #%d %5-s %4-s %4-s by %11-s %15-s [%s]\n",
                     i++, error->id, error->status[0..4], error->category[0..3],
                     error->type, error->reporter, error->filename[<15..],
                     error->directory[<15..]);
   }
   this_player()->set_finish_func("finish_more_details", this_object());
   write("$P$Error list$P$" + str);
}
int show_current_bug(object player, int verbose) {
   class user_data data;
   data = _user_query[player->query_name()];
   if (verbose == -1) {
      verbose = player->query_verbose("errors");
   }
   return do_bug_details(player, data->errors[data->pos]->id, verbose);
}
string expand_short_type(string name) {
   string str;
   str = upper_case(name);
   switch (str) {
   case "F" :
      return ERROR_STATUS_FIXED;
   case "D" :
      return ERROR_STATUS_DENIED;
   case "I" :
      return ERROR_STATUS_FIXING;
   case "C" :
      return ERROR_STATUS_CONSIDERING;
   case "O" :
      return ERROR_STATUS_OPEN;
   case "U" :
      return "CUSTOM";
   case "R" :
      return "NOTREPRODUCIBLE";
   case "R" :
      return "NOTPOSSIBLE";
   case "N" :
      return "NONE";
   case "T" :
      return "THANKS";
   case "M" :
      return "NOTENOUGHINFORMATION";
   case "E" :
      return "TEMPORARY";
   default :
      return str;
   }
}
void finish_change_status_command(object player, int id, string status,
                        string messtype, int type, mixed data) {
   string mess;
   string subject;
   class error_summary error;
   if (type != DB_SUCCESS) {
      tell_object(player, "SQL error: " + data + "\n");
      return ;
   }
   if (!sizeof(data)) {
      tell_object(player, "No bug found with an id of #" + id + "\n");
      return ;
   }
   error = data[0];
   _user_query[player->query_name()] = new(class user_data);
   _user_query[player->query_name()]->errors = data;
   _user_query[player->query_name()]->pos = 0;
   status = expand_short_type(status);
   if (messtype) {
      messtype = expand_short_type(messtype);
      mess = query_message_from_type(player, messtype, error);
      subject = query_subject_from_type(messtype, error);
      if (!mess) {
         tell_object(player, "The reply type " + messtype + " was not valid.\n");
      } else {
         if (member_array(status, ERROR_TYPE) != -1) {
            tell_object(player, "The error type must be one of " +
                  query_multiple_short(ERROR_TYPE) + ".\n");
         } else {
            do_change_status(player, status, 1, subject, mess);
            return ;
         }
      }
   } else {
      mess = query_message_from_type(player, status, error);
      subject = query_subject_from_type(status, error);
      if (mess) {
         do_change_status(player, status, 1, subject, mess);
         return ;
      }
   }
   tell_object(player, "Syntax: s {OPEN|FIXED|CONSIDERING|DENIED|THANKS|NOTPOSSIBLE|NOTREPRODUCIBLE|NOTENOUGHINFORMATION} [{none|custom|fixed|denied|notpossible|notreproducible|notenoughinformation}]\n");
   tell_object(player, "The default message is based on the type it is changed to.\n");
   tell_object(player, "The type has some short forms: o -> open, f -> fixed, d ->denied\n");
   tell_object(player, "   c ->considering, t -> thanks, n -> none, u -> custom, i -> fixing.\n");
   tell_object(player, "   r ->notreproducible, p -> notpossible, m -> notenoughinformation.\n");
   tell_object(player, "   t ->temporary.\n");
}
void menu_response(string str) {
   string* bits;
   class user_data data;
   int print_menu_line;
   class error_summary error;
   string mess;
   string subject;
   int id;
   bits = explode(str, " ");
   if (!sizeof(bits)) {
      bits = ({ "n" });
   }
   data = _user_query[this_player()->query_name()];
   switch(lower_case(bits[0])) {
   case "v" :
      if (sizeof(bits) > 1) {
         show_current_bug(this_player(), bits[1] == "verbose");
      } else {
         show_current_bug(this_player(), -1);
      }
      break;
   case "+" :
   case "n" :
      if (data->pos < sizeof(data->errors) - 1) {
         data->pos++;
         print_menu_line = !show_current_bug(this_player(), -1);
      } else {
         write("No next bug to go to.\n");
         print_menu_line = 1;
      }
      break;
   case "-" :
   case "p" :
      if (data->pos > 0) {
         data->pos--;
         print_menu_line = !show_current_bug(this_player(), -1);
      } else {
         write("No previous bug to go to.\n");
         print_menu_line = 1;
      }
      break;
   case "f" :
      if (sizeof(bits) == 2) {
         if (do_forward(this_player(), bits[1])) {
            input_to("menu_response");
         } else {
            print_menu_line = 1;
         }
      } else {
         write("Need to specify the destination directory (and nothing else)\n");
         print_menu_line = 1;
      }
      break;
   case "s" :
      if (sizeof(bits) > 1) {
         bits[1] = expand_short_type(bits[1]);
         error = data->errors[data->pos];
         if (sizeof(bits) > 2) {
            bits[2] = expand_short_type(bits[2]);
            mess = query_message_from_type(this_player(), bits[2], error);
            subject = query_subject_from_type(bits[1], error);
            if (!mess) {
               write("The reply type " + bits[2] + " was not valid.\n");
               print_menu_line = 1;
            } else {
               if (member_array(bits[1], ERROR_TYPE) != -1) {
                  write("The error type must be one of " +
                        query_multiple_short(ERROR_TYPE) + ".\n");
                  print_menu_line = 1;
               } else {
                  do_change_status(this_player(), bits[1], 0, subject, mess);
                  input_to("menu_response");
               }
            }
         } else {
            mess = query_message_from_type(this_player(), bits[1], error);
            subject = query_subject_from_type(bits[1], error);
            if (mess) {
               do_change_status(this_player(), bits[1], 0, subject, mess);
               input_to("menu_response");
            }
         }
         if (!mess) {
            write("Syntax: s {OPEN|FIXED|CONSIDERING|DENIED|THANKS|NOTPOSSIBLE|NOTREPRODUCIBLE|NOTENOUGHINFORMATION} [{none|custom|fixed|denied|notpossible|notreproducible|notenoughinformation}]\n");
            write("The default message is based on the type it is changed to.\n");
            write("The type has some short forms: o -> open, f -> fixed, d ->denied\n");
            write("   c ->considering, t -> thanks, n -> none, u -> custom, i -> fixing.\n");
            write("   r ->notreproducible, p -> notpossible, m -> notenoughinformation.\n");
            write("   t ->temporary.\n");
            print_menu_line = 1;
         }
      } else {
         write("Syntax: s {OPEN|FIXED|CONSIDERING|DENIED|THANKS|NOTPOSSIBLE|NOTREPRODUCIBLE|NOTENOUGHINFORMATION} [{none|custom|fixed|denied|notpossible|notreproducible|notenoughinformation}]\n");
         write("The default message is based on the type it is changed to.\n");
         write("The type has some short forms: o -> open, f -> fixed, d ->denied\n");
         write("   c ->considering, t -> thanks, n -> none, u -> custom, i -> fixing.\n");
         write("   r ->notreproducible, p -> notpossible, m -> notenoughinformation.\n");
         write("   t ->temporary.\n");
         print_menu_line = 1;
      }
      break;
   case "t" :
      if (sizeof(bits) > 1) {
         bits[1] = upper_case(bits[1]);
         if (member_array(bits[1], ERROR_TYPE) != -1) {
            do_change_type(this_player(), bits[1]);
            input_to("menu_response");
         } else {
            write("The type must be one of " +
                  query_multiple_short(ERROR_TYPE) + ".\n");
            print_menu_line = 1;
         }
      } else {
         write("Syntax: t {TYPO|BUG|IDEA}\n");
         print_menu_line = 1;
      }
      break;
   case "o" :
      if (sizeof(bits) > 1) {
         bits[1] = upper_case(bits[1]);
         if (member_array(bits[1], ERROR_CATEGORIES) != -1) {
            do_change_category(this_player(), bits[1]);
            input_to("menu_response");
         } else {
            write("The type must be one of " +
                  query_multiple_short(ERROR_CATEGORIES) + ".\n");
            print_menu_line = 1;
         }
      } else {
         write("Syntax: t {ROOM|OBJECT|COMMAND|HELP|RITUAL|SPELL|GENERAL}\n");
         print_menu_line = 1;
      }
      break;
   case "g" :
      if (sizeof(bits) > 0) {
         id = to_int(bits[1]);
         if (id <= sizeof(data->errors)) {
            data->pos = id - 1;
            show_current_bug(this_player(), -1);
         } else {
            id = find_index(this_player(), id);
            if (id == -1) {
               write("Unable to find the bug #" + id + "\n");
               print_menu_line = 1;
            }
         }
      } else {
         write("Syntax: g <num>\nNum can either be the index number or the "
               "bug id.\n");
         print_menu_line = 1;
      }
      break;
   case "c" :
      do_comment(this_player());
      break;
   case "i" :
   case "l" :
      do_list_errors();
      break;
   case "q" :
      write("Bye bye.\n");
      return ;
   case "a" :
      if (sizeof(bits) > 1) {
         if (!PLAYER_HANDLER->test_creator(bits[1])) {
            write("You can only assign a bug to a creator.\n");
            print_menu_line = 1;
         } else {
            do_assign_bug(this_player(), bits[1]);
            input_to("menu_response");
         }
      } else {
         write("You need to specify someone to assign the error to.\n");
         print_menu_line = 1;
      }
      break;
   case "h" :
      do_help(this_player());
      break;
   default :
      write("Bad command.\n");
      print_menu_line = 1;
      break;
   }
   if (print_menu_line) {
      write(menu_line(this_player()));
      input_to("menu_response");
   }
}
void finish_query(object player, int type, mixed data) {
   if (type != DB_SUCCESS) {
      tell_object(player, "Error: " + data + "\n");
      return ;
   }
   _user_query[player->query_name()] = new(class user_data);
   _user_query[player->query_name()]->errors = data;
   _user_query[player->query_name()]->pos = 0;
   if (!sizeof(data)) {
      tell_object(player, "No bugs with that query.\n");
      return ;
   }
   show_current_bug(player, -1);
}
int setup_query(object player, class error_query query) {
   if (!ERROR_HANDLER->do_query_bug_summary(query, (: finish_query, player :))) {
      add_failed_mess("Unable to setup the query.\n");
      return 0;
   }
   return 1;
}
int errors_change_status(int id, string status, string messtype) {
   class error_query query;
   query = new (class error_query);
   query->id = id;
   if (!ERROR_HANDLER->do_query_bug_summary(query,
                     (: finish_change_status_command, this_player(), id, status,
                        messtype :))) {
      add_failed_mess("Unable to setup the query.\n");
      return 0;
   }
   write("Looking up bug #" + id + " to fix.\n");
   return 1;
}
int errors_this_dir(int recursive) {
   class error_query query;
   query = new (class error_query);
   query->dir = this_player()->query_path();
   query->recursive = recursive;
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
int errors_by_person(string person) {
   class error_query query;
   query = new (class error_query);
   query->reporter = lower_case(person);
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
int errors_assigned_to_person(string person) {
   class error_query query;
   query = new (class error_query);
   query->assigned_to = lower_case(person);
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
int errors_assigned_to_me() {
   return errors_assigned_to_person(this_player()->query_name());
}
int errors_in_dir(string str, int recursive) {
   class error_query query;
   string path;
   path = this_player()->get_path(str);
   query = new (class error_query);
   query->dir = path;
   query->recursive = recursive;
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
int errors_with_id(int id) {
   class error_query query;
   query = new (class error_query);
   query->id = id;
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
int errors_for_file(string file) {
   class error_query query;
   query = new (class error_query);
   query->file_name = file;
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
int errors_in_this_room() {
   class error_query query;
   query = new (class error_query);
   query->file_name = file_name(environment(this_player()));
   query->status = ({ ERROR_STATUS_OPEN, ERROR_STATUS_CONSIDERING,
                      ERROR_STATUS_FIXING });
   return setup_query(this_player(), query);
}
mixed* query_patterns() {
   return ({ "", (: errors_this_dir(0) :),
             "status <number'bug id'> <word'status'>",
                   (: errors_change_status($4[0], $4[1], 0) :),
             "status <number'bug id'> <word'status'> <word'reply'>",
                   (: errors_change_status($4[0], $4[1], $4[2]) :),
             "recursive", (: errors_this_dir(1) :),
             "mine", (: errors_assigned_to_me :),
             "here", (: errors_in_this_room :),
             "assigned <string'person'>", (: errors_assigned_to_person($4[0]) :),
             "by <string'person'>", (: errors_by_person($4[0]) :),
             "id <number'bug id'>", (: errors_with_id($4[0]) :),
             "file <string'file'>", (: errors_for_file($4[0]) :),
             "dir <string'dir'>", (: errors_in_dir($4[0], 0) :),
             "dir recursive <string'dir'>", (: errors_in_dir($4[0], 1) :) });
}

==================================================
FILE: creator/family.c
==================================================

#include <clubs.h>
#include <money.h>
inherit "/cmds/base";
inherit "/std/basic/club_listing";
#include <player_handler.h>
#include <playerinfo.h>
mixed family_reverse(string from, string to) {
  string family_from;
  string family_to;
  string *relations_to;
  string *relations_from;
  string opp;
  string relation;
  family_from = PLAYER_HANDLER->test_family(from);
  family_to = PLAYER_HANDLER->test_family(to);
  if (!family_from) {
    add_failed_mess("Sorry, " + from + " is not in a family.\n");
  }
  if (!family_to) {
    add_failed_mess("Sorry, " + to + " is not in a family.\n");
  }
  if (!family_to ||
      !family_from) {
    return 0;
  }
  relations_to = CLUB_HANDLER->query_relationships_to(family_to,
                                                     to,
                                                     from);
  relations_from = CLUB_HANDLER->query_relationships_to(family_from,
                                                       from,
                                                       to);
  if (!sizeof(relations_to) ||
      !sizeof(relations_from)) {
    add_failed_mess(from + " and " + to + " are not related.\n");
    return 0;
  }
  foreach (relation in relations_from) {
    opp = CLUB_HANDLER->query_opposite_relationship(relation);
    if (!opp) {
      write("Unable to swap " + relation + ".\n");
    } else {
      if (!CLUB_HANDLER->remove_relationship(family_from,
                                             from,
                                             family_to,
                                             to,
                                             relation)) {
        write("Could not remove relationship " + relation + " between " +
              from + " and " + to + ".\n");
      } else {
        CLUB_HANDLER->add_relationship(family_from,
                                       from,
                                       family_to,
                                       to,
                                       opp);
        PLAYERINFO_HANDLER->add_entry(this_player(),
                                      from,
                                      "family",
                                      "Changed relationship with " + to + " to " +
                                      opp);
        PLAYERINFO_HANDLER->add_entry(this_player(),
                                      to,
                                      "family",
                                      "Changed relationship with " + from + " to " +
                                      relation);
        write("Swapped relationship " + relation + " between " +
              from + " and " + to + ".\n");
      }
    }
  }
  return 1;
}
int family_remove(string from, string to) {
  string family_from;
  string family_to;
  string *relations_to;
  string *relations_from;
  string relation;
  family_from = PLAYER_HANDLER->test_family(from);
  family_to = PLAYER_HANDLER->test_family(to);
  if (!family_from) {
    add_failed_mess("Sorry, " + from + " is not in a family.\n");
  }
  if (!family_to) {
    add_failed_mess("Sorry, " + to + " is not in a family.\n");
  }
  if (!family_to ||
      !family_from) {
    return 0;
  }
  relations_to = CLUB_HANDLER->query_relationships_to(family_to,
                                                     to,
                                                     from);
  relations_from = CLUB_HANDLER->query_relationships_to(family_from,
                                                       from,
                                                       to);
  if (!sizeof(relations_to) ||
      !sizeof(relations_from)) {
    add_failed_mess(from + " and " + to + " are not related.\n");
    return 0;
  }
  foreach (relation in relations_from) {
    if (!CLUB_HANDLER->remove_relationship(family_from,
                                           from,
                                           family_to,
                                           to,
                                           relation)) {
      write("Could not remove relationship " + relation + " between " +
            from + " and " + to + ".\n");
    } else {
      write("Removed relationship " + relation + " between " +
            from + " and " + to + ".\n");
      PLAYERINFO_HANDLER->add_entry(this_player(),
                                    from,
                                    "family",
                                    "Removed relationship with " + to);
      PLAYERINFO_HANDLER->add_entry(this_player(),
                                    to,
                                    "family",
                                    "Removed relationship with " + from);
    }
  }
  return 1;
}
private int do_balance(string club_name) {
   int balance;
   string place;
   if (!CLUB_HANDLER->is_club(club_name)) {
      add_failed_mess("There is no family called '" +
                      CLUB_HANDLER->query_club_name(club_name) + "'.\n");
   }
   place = environment(this_player())->query_property("place");
   if (!place) {
      place = "default";
   }
   balance = CLUB_HANDLER->query_balance(club_name);
   write("The balance of the family '" +
         CLUB_HANDLER->query_club_name(club_name) + "' is " +
         MONEY_HAND->money_value_string(balance, place) + ".\n");
   return 1;
}
private int do_all_balance() {
   string *clubs;
   string club;
   string place;
   mapping bing;
   string ret;
   clubs = CLUB_HANDLER->query_clubs();
   place = environment(this_player())->query_property("place");
   if (!place) {
      place = "default";
   }
   bing = ([ ]);
   foreach (club in clubs) {
      if (!CLUB_HANDLER->is_family(club)) {
         continue;
      }
      bing[club] = CLUB_HANDLER->query_balance(club);
   }
   clubs = keys(bing);
   clubs = sort_array(clubs, (: $3[$1] - $3[$2] :), bing);
   ret = "";
   foreach (club in clubs) {
      ret += sprintf("Family '%-20s': %s\n",
            CLUB_HANDLER->query_club_name(club),
            MONEY_HAND->money_value_string(bing[club], place));
   }
   write("$P$Club Balances$P$" + ret);
   return 1;
}
mixed *query_patterns() {
  return ({ "info <word'family name'>",
              (: family_info($4[0], this_player()->query_name()) :),
            "reverse relationship <word'player name'> <word'player name'>",
              (: family_reverse($4[0], $4[1]) :),
            "remove relationship <word'player name'> <word'player name'>",
              (: family_remove($4[0], $4[1]) :),
            "balance <string'family name'>", (: do_balance($4[0]) :),
            "balance all", (: do_all_balance() :) });
}

==================================================
FILE: creator/fds.c
==================================================

inherit "/cmds/base";
mixed cmd(string) {
  this_player()->more_string(dump_file_descriptors());
  return 1;
}

==================================================
FILE: creator/fetch.c
==================================================

#include <move_failures.h>
#include <playerinfo.h>
#define BROKEN_ROOM "/room/broken"
inherit "/cmds/base";
int cmd( mixed *indirect_obs ) {
    object *broken_items, *failed, *success;
    object player;
    if ( sizeof( indirect_obs ) != 2 ) {
        return 0;
    }
    if ( sizeof( indirect_obs[ 1 ] ) > 1 ) {
        add_failed_mess( "You cannot $V an object for more than one "
            "player at once.\n" );
        return 0;
    }
    player = indirect_obs[ 1 ][ 0 ];
    broken_items = indirect_obs[ 0 ];
    failed = filter( broken_items,
        (: $1->move( $(player), "$N appear$s in your inventory." ) != MOVE_OK :) );
    success = broken_items - failed;
    if ( sizeof( failed ) ) {
        tell_object( this_player(), "Warning-- could not move " +
            query_multiple_short( failed ) + " to " +
            player->the_short() + ".\n" );
    }
    if ( sizeof( success ) ) {
        PLAYERINFO_HANDLER->add_entry(
            this_player(), player->query_name(), "replace",
            "Fetched " + implode( success->short(), "," ) + " from /room/broken.");
        add_succeeded_mess( "$N $V $I for " + player->the_short() + " from "
            "the broken room.\n", success );
        return 1;
    }
    add_failed_mess( "No objects could be retrieved for $I.\n",
        ({ player }) );
    return -1;
}
mixed *query_patterns() {
    return ({ "<indirect:object:" + BROKEN_ROOM + "> [for] <indirect:player>",
        (: cmd($1) :) });
}

==================================================
FILE: creator/findc_orpse.c
==================================================

inherit "/cmds/base";
int cmd( string arg ) {
   object *cs, c;
   string r;
   r = "player corpse objects\n";
   cs = filter( children( "/obj/corpse" ), (: $1 && $1->query_property(
      "player" ) :) );
   if( !arg ) {
      foreach( c in cs ) r += file_name( c ) + " - " + c->query_owner() +
         " - " + ( environment( c ) ? file_name( environment( c ) ) :
         "In void" ) + "\n";
      tell_object( this_player(), r );
      tell_object( this_player(), sizeof( cs ) + " player corpses.\n" );
   } else {
      cs = filter( cs, (: $1 && $1->query_ownership() == $( arg ) :) );
      if( sizeof( cs ) ) {
         r = "Corpse objects of " + arg + ": \n";
         foreach( c in cs ) r += file_name( c ) + " in " + (
         environment( c ) ? file_name( environment( c ) ) : "void" ) + "\n";
         tell_object( this_player(), r );
      } else {
         tell_object( this_player(), arg + " has no corpses loaded.\n" );
      }
   }
   return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/findr_edef.c
==================================================

string *find_stuff(object ob, string varname){
  string *variables = variables(ob);
  string *ret = ({});
  if(member_array(varname, variables) > -1){
    object *inhobs = map(inherit_list(ob), (:find_object:));
    object obj;
    foreach(obj in inhobs){
      ret += find_stuff(obj, varname);
    }
    if(ret == ({})){
      ret = ({file_name(ob)});
    }
  }
  return ret;
}
int cmd(object ob, string var){
  string *files = find_stuff(ob, var);
  if(sizeof(files) > 1)
    printf("%s is defined in %s and %s.\n", var, implode(files[0..<2], ", "),
           files[<1]);
  else
    write("No redefinition found.\n");
  return 1;
}
string *query_patterns(){
  return ({"<indirect:wiz-present> <word'global'>", (:cmd($1[0], $4[1]):)});
}

==================================================
FILE: creator/fixed.c
==================================================

#include <config.h>
#include <db.h>
inherit "/cmds/base";
int db;
void finish_request(int type, mixed* data, object person) {
   string ret;
   mapping row;
   if (type == DB_SUCCESS) {
      ret = "";
      foreach (row in data) {
         ret += sprintf("%-15s %s\n", row["Fixer"], "" + row["bing"]);
      }
   } else {
      ret = "Some sort of horrible error!\n";
   }
   person->more_string(ret, "details");
}
int cmd(string who){
   string request;
   if(who == "all") {
      request = "select Fixer, count(*) as bing from errors "
                            "where Fixer is not NULL and Status = 'FIXED' and "
                            "Type = 'BUG' "
                            "group by Fixer order by bing desc";
   } else {
      request = "select Fixer, count(*) as bing from errors "
                            "where Fixer = '" + who +
                            "' and Status = 'FIXED' and "
                            "Type = 'BUG' "
                            "group by Fixer order by bing desc";
   }
   DB_HANDLER->make_sql_request("errors", CONFIG_DB_USER, "", request,
                                (: finish_request($1, $2, $(this_player())) :));
   add_succeeded_mess("");
   return 1;
}
mixed *query_patterns() {
   return ({ "<string'person|all'>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/forwards.c
==================================================

#include <config.h>
#include <db.h>
inherit "/cmds/base";
int db;
void finish_request(int type, mixed* data, object person) {
   string ret;
   mapping row;
   if (type == DB_SUCCESS) {
      ret = "";
      foreach (row in data) {
         ret += sprintf("%-15s %s\n", row["Forwarder"], "" + row["bing"]);
      }
   } else {
      ret = "Some sort of horrible error!\n";
   }
   person->more_string(ret, "details");
}
int cmd(string who){
   string request;
   if(who == "all") {
      request = "select Forwarder, count(*) as bing from forwards "
                   "where Forwarder is not NULL "
                   "group by Forwarder order by bing desc";
   } else {
      request = "select Forwarder, count(*) as bing from forwards "
                   "where Forwarder = '" + who + "' "
                   "group by Forwarder order by bing desc";
   }
   DB_HANDLER->make_sql_request("errors", CONFIG_DB_USER, "", request,
                                (: finish_request($1, $2, $(this_player())) :));
   add_succeeded_mess("");
   return 1;
}
mixed *query_patterns() {
   return ({ "<string'person|all'>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/fry.c
==================================================

#include <playerinfo.h>
#define LIGHTNING "%^WHITE%^BOLD%^lightning%^RESET%^"
#define THUNDER "%^RED%^BOLD%^thunder%^RESET%^"
inherit "/cmds/base";
mapping banned = ([
    "macchirton"    :   "it's tradition.",
    "que"           :   "you're an arse.",
    ]);
mixed cmd(string words) {
  string player, reason;
  object ob;
    add_failed_mess("At Pinkfish's request this command has been disabled.\n" );
    return 0;
  if(member_array (this_player()->query_name(), keys(banned)) != -1)
  {
    return notify_fail("You cannot use 'fry', because " +
        banned[this_player()->query_name()] + "\n");
  }
  if(!words || sscanf(words, "%s %s", player, reason ) != 2) {
    return notify_fail("Usage: fry <player> <reason>\n");
  }
  if (!"/secure/master"->query_senior(this_player()->query_name()))
  {
    return notify_fail ("Only Senior Creators and above may smite players "
        "with Righteous Vengeance!\n");
  }
  ob = find_player(this_player()->expand_nickname(player));
  if(!ob) {
    return notify_fail(player+" not found!\n");
  }
  write("Warning: This is not to be used for pranks.  If you "
    "do not have a valid reason to use this, do not use it!  "
    "Are you quite sure you wish to proceed? (y/n): ");
  input_to("are_sure", ob, reason);
  return 1;
}
void are_sure(string str, object ob, string reason) {
  string gender = "boy";
  if(this_player()->query_gender() == 2) {
    gender = "girl";
  }
  str = lower_case(str);
  if(str[0] != 'y') {
    write("There's a good "+gender+"!  Now you go play nice with little "
        + ob->one_short() + "!\n");
    return;
  }
  write("Would you like the whole Disc to be aware of the reason "
    "for your ire? (y/n): ");
  input_to("positive", ob, reason);
}
void positive (string str, object ob, string reason) {
  str = lower_case(str);
  if(str[0] != 'y') {
    write ("Okay, we'll keep it between you and me.\n");
    call_out("fry2", 5+random (3), ob);
  }
  else
  {
    write ("Bwah-ha-ha-ha!\n");
    call_out("fry2", 5+random (3), ob, reason);
  }
  PLAYERINFO_HANDLER->add_entry(this_player(),
                                ob->query_name(),
                                "meteor",
                                reason);
  log_file("SMITE", "%s: %s smote %s: %s\n", ctime(time()),
    this_player()->query_short(), ob->query_short(), reason);
  shout("The sky grows dark.  Thick black clouds roll in.\n");
  shout("A loud peal of " + THUNDER + " rumbles, shaking the ground, "
    "and bolts of " + LIGHTNING + " flash through the sky!\n");
  write("Smiting "+capitalize (ob->query_name()) +" with Righteous Vengeance!\n");
}
varargs void fry2(object ob, string reason) {
    string *shout_mess = ({
        "A bolt of ferocious " + LIGHTNING + " rips the sky in two!  ",
        "A peal of deafening " + THUNDER + " rumbles o'er the land!  ",
        "The clouds gather, spitting forth bolts of vicious " + LIGHTNING +
            " from their folds!  ",
        "The clouds gather into great dark masses, spitting " + LIGHTNING +
            " at the cowering Disc below!  "
        });
    string *player_mess = ({
        "A bolt of shimmering " + LIGHTNING + " spears the ground in front "
            "of you!\n",
        "A bolt of " + LIGHTNING + " pierces the air above you, melting "
            "your eyebrows.\n",
        "A bolt of " + LIGHTNING + " flares before your face, causing "
            "little blobs of light to dance over your retinas.\n"
            });
    shout (shout_mess[random(sizeof(shout_mess))] + "It appears one "
        "of the " + mud_name() + "'s creators is unhappy...\n");
    tell_object(ob, player_mess[random(sizeof(player_mess))]);
    call_out("fry3", 8 + random (10), ob, reason);
}
varargs void fry3(object ob, string reason)
{
    string name;
    string *TMs = ({
        "You feel more able to spear players with bolts of lightning!\n",
        "You feel more confident about your aim when trying to hit small "
            "scurrying figures from Cori Celesti!\n",
        "You manage to grasp one of the principles of creator justice "
            "more firmly!\n",
        });
    string *shout_mess = ({
        "Another spear of " + LIGHTNING + " lances through the clouds, "
            "followed closely by a deafening peal of " + THUNDER + "!\n",
        "A deafening roll of " + THUNDER + " followed by a bolt of brilliant "
        + LIGHTNING + " rolls over the " + mud_list() + ".\n",
        "The clouds spit out another violent bolt of " + LIGHTNING + " as "
        + THUNDER + " shatters the relative peace of the " + mud_list() + ".\n"
        });
    string *player_mess = ({
        "A bolt of " + LIGHTNING + " strikes you and sends you into the "
            "%^RED%^oblivion%^RESET%^ of the real world!\n",
        "A bolt of " + LIGHTNING + " pierces the skies and strikes you!  "
        "%^RED%^Zzzzzot!%^RESET%^\n",
        "A bolt of " + LIGHTNING + " spears down from the sky and %^RED%^"
            "smites%^RESET%^ you!\n",
        });
  if (random (100) > 80)
  {
        tell_object (this_player(), "The " + LIGHTNING + " blasts " + ob->short() +
            " into oblivion!\n");
        tell_object (this_player(), "%^YELLOW%^%^BOLD%^" + TMs[random(sizeof(TMs))]
            + "%^RESET%^");
        this_player()->add_skill_level ("fighting.combat.range.thrown", 1);
  }
  shout(shout_mess[random(sizeof(shout_mess))]);
  if (this_player()->query_invis())
  {
        name = "Someone";
  }
  else
  {
        name = this_player()->short();
  }
  if (reason)
  {
      shout(name + " shouts from the clouds:  This is " + reason +
      ", " + ob->short() +"!\n");
  }
  else
  {
      shout(name + " cackles in the distance.\n");
  }
  tell_object(ob, player_mess[random(sizeof(player_mess))]);
  ob->save();
  ob->quit();
  shout(ob->query_cap_name()+" was smote by " + name + "'s "
    "lightning.\n"+ capitalize(ob->query_pronoun())+" is no more.\n");
  shout ("The clouds roll back across the sky.");
}

==================================================
FILE: creator/ftpwho.c
==================================================

inherit "/cmds/base";
#define FTPD "/secure/ftpd"
#define UNIX_FTPD "/secure/ftp_auth"
mixed cmd(string) {
  mixed *who_unix, *who;
  int i;
  if(!find_object(FTPD)) {
    write("MUD FTP is currently disabled.\n");
  } else {
    who = FTPD->query_connections();
    if ((i = sizeof(who))) {
      write("People currently using MUD FTP :\n");
      while (i--)
        write(" - "+who[i]+"\n");
    } else {
      write("No one is using MUD FTP at the moment.\n");
    }
  }
  who_unix = UNIX_FTPD->query_connections();
  if ((i = sizeof(who_unix))) {
    write("People currently using UNIX FTP :\n");
    while (i--)
      write(" - "+who_unix[i]+"\n");
  } else {
    write("No one is using UNIX FTP at the moment.\n");
  }
  return 1;
}

==================================================
FILE: creator/gag.c
==================================================

#include <playerinfo.h>
inherit "/cmds/base";
int cmd( object victim, string reason, int number ) {
   victim->add_property( "gagged", reason, 60 * number );
   log_file( "GAG", ctime(time()) +": "+ this_player()->query_short()
             + " gagged " + victim->query_short() + " for " + number
             + " minutes.  Reason: " + reason +".\n");
   PLAYERINFO_HANDLER->add_entry( this_player(), victim->query_name(),
             "gag", "Gagged for " + number + " minutes.  Reason: '" + reason +
             "'.\n");
   tell_object( victim,
         "%^RED%^%^BOLD%^You have been gagged by " +
         this_player()->query_short() + " for the reason: '" + reason +
         "'.\nYou will not be able to shout, chat or use the newbie "
         "channel until the gag is removed.%^RESET%^\n" );
   write( "Okay, gagged " + victim->query_short() + " for " + number +
          " minutes.  Now please discuss your reason for gagging with "
          "them.  IMPORTANT! You should only be gagging for deliberately "
          "offensive language.\n" );
   event( users(), "inform", this_player()->query_short()
          + " gagged " + victim->query_short() + " for: " + reason, "gag");
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:player'player'> <string'reason'>",
                (: cmd( $1[0], $4[1], 15 ) :),
             "<indirect:player'player'> <string'reason'> <number'minutes'>",
                (: cmd( $1[0], $4[1], $4[2] ) :) });
}

==================================================
FILE: creator/gna_.c
==================================================

inherit "/cmds/base";
protected int cmd( string pattern, object *obs ) {
    string gn;
    object ob;
    string verb = query_verb();
    if ( sizeof( explode( verb, "" ) - ({ "g", "n", "a", "h" }) ) ) {
        return 0;
    }
    gn = "gn" + implode( allocate( sizeof( pattern ) - 2, "a" ), "" ) + "h!";
    if ( arrayp( obs ) ) {
        obs = filter( obs, (: !$1->check_earmuffs( "remote-soul" ) :) );
        obs -= ({ this_player() });
         if ( sizeof( obs ) ) {
            tell_object( this_player(), "You go '$C$" + gn + "' at " +
                query_multiple_short( obs ) + ".\n" );
            foreach (ob in obs) {
                tell_object(ob, this_player()->the_short() + " goes '$C$" +
                    gn + "' at you.\n" );
            }
            return 1;
        }
    }
    write( capitalize( gn ) + "\n" );
    return 1;
}
mixed *query_patterns() {
    mixed *pat = ({ "", (: cmd($6, 0) :) });
    if ( previous_object(1)->query_lord() ) {
        pat += ({ " <indirect:wiz-present>", (: cmd($6, $1) :) });
    }
    else {
        pat += ({ " <indirect:any-living>", (: cmd($6, $1) :),
                  " <indirect:object>", (: cmd($6, $1) :) });
    }
    return pat;
}

==================================================
FILE: creator/go_to.c
==================================================

mixed cmd(string str) {
  object dest;
  string *names, nick;
  string tname;
  if (!str)
    return notify_fail("Teleport where?\n");
  nick = (string)this_player()->expand_nickname(str);
  dest = find_living(nick);
  if (!dest && objectp(this_player()->get_obvar(str))) {
    dest = this_player()->get_obvar(str);
    if (dest == environment(this_player()))
      return notify_fail("You look around and realise you are already there.\n");
    this_player()->set_last_location(base_name(environment(this_player())));
    this_player()->move_with_look( dest,
                                   (string)this_player()->query_mmsgin(),
                                   (string)this_player()->query_mmsgout() );
    return 1;
  }
  if (dest) {
    if(dest = environment(dest)) {
      if (dest == environment(this_player()))
        return notify_fail("You look around and realise you are already "
                           "there.\n");
      this_player()->set_last_location(base_name(environment(this_player())));
      this_player()->move_with_look( dest,
            (string)this_player()->query_mmsgin(),
            (string)this_player()->query_mmsgout() );
      return 1;
    } else
      return notify_fail(capitalize(nick) + " is not standing in a location.\n");
  } else {
    names = (string *)this_player()->get_cfiles(str);
    if(sizeof(names)) {
      str = names[0];
    } else {
      if (strsrch(str, ":") == -1) {
         return notify_fail("No such room.\n");
      }
      if (str[0] != '/') {
         str = this_player()->query_current_path() + "/" + str;
      }
    }
    dest = load_object(str);
    if (!dest) {
      return notify_fail("Failed to load " + str + "\n");
    } else if(!dest->query_property("location")) {
      return notify_fail("Not a room: " + str + "\n");
    } else {
      if (dest == environment(this_player())) {
        notify_fail("You look around and realise you are already there.\n");
        return 0;
      }
      if (environment(this_player())) {
         tname = environment(this_player())->query_property("terrain name");
         if (tname) {
           this_player()->set_last_location(
             ({ tname, environment(this_player())->query_co_ord() })
             );
         } else {
           this_player()->set_last_location(
             base_name(environment(this_player()))
             );
         }
      }
      this_player()->move_with_look( dest,
                                     (string)this_player()->query_mmsgin(),
                                     (string)this_player()->query_mmsgout() );
      return 1;
    }
  }
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/gob_ack.c
==================================================

#include <terrain.h>
mixed cmd(string str) {
  mixed dest;
  string tname;
  dest = this_player()->query_last_location();
  if(!dest)
    return notify_fail("No stored location.\n");
  if (stringp(dest)) {
    dest = load_object(dest);
  } else if (arrayp(dest) && stringp(dest[0]) && arrayp(dest[1])) {
    dest = TERRAIN_MAP->find_location(dest[0], dest[1]);
  } else {
    return notify_fail("I don't understand your stored location.\n");
  }
  tname = environment(this_player())->query_property("terrain name");
  if (tname) {
    this_player()->set_last_location(
      ({ tname, environment(this_player())->query_co_ord() })
      );
  } else {
    this_player()->set_last_location(
      base_name(environment(this_player()))
      );
  }
  this_player()->move_with_look( dest,
                                 this_player()->query_mmsgin(),
                                 this_player()->query_mmsgout() );
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/guildl_ist.c
==================================================

inherit "/cmds/base";
int cmd(string arg) {
  object ob;
  mapping guilds;
  string guild, *fields;
  guilds = ([ ]);
  foreach(ob in users()) {
    if(ob->query_creator())
      continue;
    if(!ob->query_guild_ob()) {
      guilds["none"]++;
    } else {
      fields = explode((string)ob->query_guild_ob(), "/");
      guilds[fields[2]]++;
    }
  }
  write("Guild memberships:\n");
  foreach(guild in keys(guilds))
    printf("  %s: %d\n", guild, guilds[guild]);
  return 1;
}

==================================================
FILE: creator/hcode.c
==================================================

inherit "/cmds/base";
#include <broadcaster.h>
mixed cmd(string) {
   int i;
   mixed *hist;
   if (!wizardp(this_player())) {
      return 0;
   }
   hist = HIST_HANDLER->query_chat_history("code");
   if (!pointerp(hist) || !sizeof(hist)) {
      return notify_fail("Nobody said anything on the code channel.\n");
   }
   write("The code channel history is:\n");
   for (i=0;i<sizeof(hist);i++) {
      if (sizeof(hist[i]) > 2) {
         efun::tell_object(this_player(),
                (string)this_player()->fix_string(sprintf("*%s* %s%-=*s\n",
                ctime(hist[i][2])[11..18], hist[i][0],
                (int)this_player()->query_cols()-strlen(hist[i][0])-11,
                hist[i][1])));
      } else {
         efun::tell_object(this_object(),
                (string)this_player()->fix_string(sprintf("%s%-=*s\n",
                hist[i][0], (int)this_player()->query_cols()-strlen(hist[i][0]),
                hist[i][1])));
      }
   }
   return 1;
}

==================================================
FILE: creator/hcre.c
==================================================

inherit "/cmds/base";
#include <broadcaster.h>
mixed cmd(string) {
   int i;
   mixed *hist;
   if (!wizardp(this_player())) {
      return 0;
   }
   hist = HIST_HANDLER->query_chat_history("cre");
   if (!pointerp(hist) || !sizeof(hist)) {
      return notify_fail("Nobody said anything on the cre channel.\n");
   }
   write("The creator channel history is:\n");
   for (i=0;i<sizeof(hist);i++) {
      if (sizeof(hist[i]) > 2) {
         efun::tell_object(this_player(),
                (string)this_player()->fix_string(sprintf("*%s* %s%-=*s\n",
                ctime(hist[i][2])[11..18], hist[i][0],
                (int)this_player()->query_cols()-strlen(hist[i][0])-11,
                hist[i][1])));
      } else {
         efun::tell_object(this_object(),
                (string)this_player()->fix_string(sprintf("%s%-=*s\n",
                hist[i][0], (int)this_player()->query_cols()-strlen(hist[i][0]),
                hist[i][1])));
      }
   }
   return 1;
}

==================================================
FILE: creator/he_ad.c
==================================================

mixed cmd(string str) {
  int i;
  string *files;
  seteuid(geteuid(this_player()));
  if (!str)
    return notify_fail("Usage: head <file>\n");
  files = this_player()->get_files(str);
  if (!sizeof(files))
    return notify_fail("File does not exist.\n");
  str = files[0];
  i = file_length(str);
  if (i < 0) {
    printf("File not found.\n");
    return 1;
  }
  if (i > 20) i=20;
  write(read_file(str,1,i));
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/hliaison.c
==================================================

inherit "/cmds/base";
#include <broadcaster.h>
mixed cmd(string) {
   int i;
   mixed *hist;
   if (!wizardp(this_player())) {
      return 0;
   }
   hist = HIST_HANDLER->query_chat_history("liaison");
   if (!pointerp(hist) || !sizeof(hist)) {
      return notify_fail("Nobody said anything on the liaison channel.\n");
   }
   write("The liaison channel history is:\n");
   for (i=0;i<sizeof(hist);i++) {
      if (sizeof(hist[i]) > 2) {
         efun::tell_object(this_player(),
                (string)this_player()->fix_string(sprintf("*%s* %s%-=*s\n",
                ctime(hist[i][2])[11..18], hist[i][0],
                (int)this_player()->query_cols()-strlen(hist[i][0])-11,
                hist[i][1])));
      } else {
         efun::tell_object(this_object(),
                (string)this_player()->fix_string(sprintf("%s%-=*s\n",
                hist[i][0], (int)this_player()->query_cols()-strlen(hist[i][0]),
                hist[i][1])));
      }
   }
   return 1;
}

==================================================
FILE: creator/ho_me.c
==================================================

mixed cmd(string str) {
  write("Usage : alias home goto <wherever> :)\n");
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/host.c
==================================================

inherit "/cmds/base";
mapping lookups = ([]);
int cmd( string w ) {
    string ip = lower_case( this_player()->expand_nickname( w ) );
    string ip2;
    if ( find_player( ip ) ) {
        ip2 = query_ip_number( find_player( ip ) );
        lookups[ resolve( ip2, "lookup_callback" ) ] = this_player();
        tell_object( this_player(), "Starting lookup for " + ip +
                     " (" + ip2 + ").\n" );
    } else {
        lookups[ resolve( ip, "lookup_callback" ) ] = this_player();
        tell_object( this_player(), "Starting lookup for " + ip + ".\n" );
    }
    return 1;
}
void lookup_callback( string address, string resolved, int key ) {
    if ( lookups[ key ] ) {
        tell_object( lookups[ key ], "Resolved " +
                     ( address ? address : "?unknown" ) +
                     " to " +
                     ( resolved ? resolved : "?unknown" ) + ".\n" );
    }
    map_delete( lookups, key );
}
mixed *query_patterns() {
   return ({ "<string'ip-address, host or player'>",
                 (: cmd( $4[0] ) :) });
}

==================================================
FILE: creator/hours.c
==================================================

inherit "/cmds/base";
int cmd( int time, string all) {
    mapping people;
    int seconds, num;
    string mess;
    if ( !time ) {
      if(all == "")
        people = unique_mapping( filter( users(),
            (: interactive( $1 ) && !$1->query_login_ob() &&
             !$1->query_creator() :) ),
            (: ( (time() - $1->query_last_log_on() ) / 3600 ) :) );
      else
        people = unique_mapping( filter( users(),
            (: interactive( $1 ) && !$1->query_login_ob() :) ),
            (: ( (time() - $1->query_last_log_on() ) / 3600 ) :) );
        people = map( people, (: sort_array( $2, (: strcmp( $1->query_name(),
            $2->query_name() ) :) ) :) );
        mess = "";
        foreach( num in sort_array( keys( people ), -1 ) ) {
            if ( num > 0 ) {
                mess += "Online for " + query_num( num ) +
                    ( num == 1 ? " hour: \n" : " hours: \n" ) +
                    query_multiple_short( people[ num ] ) + ".\n\n";
            }
        }
        tell_object( this_player(), "$P$Online time$P$" +
            mess );
    }
    else {
        seconds = time * 60 * 60;
        people = allocate_mapping( users(), (: $(time()) -  $1->query_last_log_on() :) );
        people = filter( people, (: interactive($1) && !$1->query_login_ob()
            && $2 > $(seconds) :) );
        if ( sizeof( people ) ) {
            tell_object( this_player(), "The following people have been "
                "connected for more than " + query_num( time ) +
                ( time % 3600 < 2 ? " hour: " : " hours: " ) +
                query_multiple_short( keys( people ) ) + ".\n" );
        }
        else {
            tell_object( this_player(), "No one has been connected for that "
                "long.\n" );
        }
    }
    return 1;
}
mixed *query_patterns() {
  return ({ "<number>", (: cmd($4[0], "") :),
            "<number> all", (: cmd($4[0], "all") :),
            "all", (: cmd(0, "all") :),
            "", (: cmd(0, "") :) });
}

==================================================
FILE: creator/hous_ing.c
==================================================

#include <housing.h>
#include <login_handler.h>
#include <money.h>
inherit "/cmds/base";
private string get_file(string fname) {
  string *tmp;
  tmp = this_player()->get_files(fname);
  if(sizeof(tmp) != 1) {
    tmp = this_player()->get_files(fname + ".c");
    if(sizeof(tmp) != 1)
      return "";
  }
  return tmp[0][0..<3];
}
int do_remove(string house) {
  house = get_file(house);
  if(!HOUSING->query_house(house))
    return notify_fail("No such house.\n");
  HOUSING->remove_house(house);
  write("House removed.\n");
  return 1;
}
int do_add(string house, string region, int rented, string address) {
  object ob;
  house = get_file(house);
  if(house == "")
    return notify_fail("House does not exist.\n");
  load_object(house);
  ob = find_object(house);
  if(!ob || !function_exists("query_owner", ob)) {
     add_failed_mess("The file " + house + " is not a player house.\n");
     return 0;
  }
  HOUSING->add_house(house, ({ }), address, region, rented);
  write("House added.\n");
  return 1;
}
int do_modify(string house, string region, int rented, string address) {
  string *rooms;
  house = get_file(house);
  if(house == "")
    return notify_fail("House does not exist.\n");
  if(!HOUSING->query_house(house))
    return notify_fail("That house is not registered.\n");
  rooms = HOUSING->query_rooms(house) - ({ house });
  HOUSING->modify_house(house, rooms, address, region, rented);
  write("House modified.\n");
  return 1;
}
int add_room(string house, string room) {
  string *files, file;
  object ob;
  int added;
  house = get_file(house);
  if(!HOUSING->query_house(house)) {
    return notify_fail("No such house.\n");
  }
  files = this_player()->get_files(room);
  if(!sizeof(files)) {
    return notify_fail("That room doesn't exist.\n");
  }
  house->force_load();
  ob = find_object(house);
  if(!ob || !function_exists("query_owner", ob)) {
     add_failed_mess("The start point is not a player house!\n");
     return 0;
  }
  added = 0;
  foreach(file in files) {
    room = file[0..<3];
    if(room == house) {
      continue;
    }
    if(!HOUSING->add_rooms(house, ({ room }))) {
      write("Error adding room " + room + ".\n");
    } else {
      write("Room added [" + room + "]\n");
    }
  }
  return 1;
}
int remove_room(string house, string room) {
  house = get_file(house);
  if(!HOUSING->query_house(house))
    return notify_fail("No such house.\n");
  if(!HOUSING->remove_rooms(house, ({ room })))
    return notify_fail("Error removing room.\n");
  write("Room removed.\n");
  return 1;
}
int do_owner(string house, string owner) {
  if(owner == "none")
    owner = "For Sale";
  if(owner != "For Sale" && owner != "Under Offer" &&
     !PLAYER_HANDLER->test_user(owner))
    return notify_fail("No such user " + owner + ".\n");
  house = get_file(house);
  if(!HOUSING->set_owner(house, owner))
     return notify_fail("Error changing owner.\n");
  write("Owner set to " + owner + ".\n");
  return 1;
}
int do_list(string search) {
  string house;
  string str;
  string tmp;
  int num, negative;
  debug_printf("search: %s", search);
  if(search) {
    house = get_file(search);
    if(HOUSING->query_house(house)) {
      printf("House: %s\n  Owner: %s\n  Address: %s\n  Region: %s\n  "
             "Type: %s\n  Value: %d\n  Rooms: %s\n",
             house,
             HOUSING->query_owner(house),
             HOUSING->query_address(house),
             HOUSING->query_region(house),
             (HOUSING->query_type(house) ? "Rented" : "Owned"),
             HOUSING->query_value(house),
             implode(HOUSING->query_rooms(house), ", "));
      return 1;
    }
  }
  str = "";
  if(search && strlen(search) > 4 && search[0..3] == "not ") {
    search = search[4..];
    negative = 1;
  }
  foreach(house in keys(HOUSING->query_houses())) {
    tmp = sprintf("%s - %s: %s. %d rooms (%s).\n",
                  house,
                  (HOUSING->query_type(house) ? "Renter" +
                   (HOUSING->query_value(house) ? " (" +
                    MONEY_HAND->money_value_string(HOUSING->query_value(house), "Ankh-Morpork") + ")" : "")
                   : "Owner"),
                  HOUSING->query_owner(house),
                  sizeof(HOUSING->query_rooms(house)),
                  (stringp(HOUSING->query_region(house))?HOUSING->query_region(house):"Bad region"));
    if(!search ||
       (!negative && strsrch(lower_case(tmp), lower_case(search)) != -1) ||
       (negative && strsrch(lower_case(tmp), lower_case(search)) == -1)) {
      str += tmp;
      num++;
    }
  }
  if (!num) {
     str += "No houses found.\n";
  } else {
     str += num + " houses found.\n";
  }
  write("$P$Housing$P$" + str);
  return 1;
}
int do_sell(string house) {
   house = get_file(house);
   if (!HOUSING->set_for_sale(house)) {
      add_failed_mess("Unable to set the house " + house + " up for sale.\n");
      return 0;
   }
   write("Set the house up for sale.\n");
   return 1;
}
int do_list_address(string search) {
  string house;
  string str;
  string tmp;
  int num;
  int negative;
  str = "";
  if(search && strlen(search) > 4 && search[0..3] == "not ") {
    search = search[4..];
    negative = 1;
  }
  foreach(house in keys(HOUSING->query_houses())) {
    tmp = sprintf("%s - %s (%s).\n",
                  house,
                  HOUSING->query_address(house),
                  HOUSING->query_region(house));
    if(!search ||
       (!negative && strsrch(lower_case(tmp), lower_case(search)) != -1) ||
       (negative && strsrch(lower_case(tmp), lower_case(search)) == -1)) {
      str += tmp;
      num++;
    }
  }
  if (!num) {
     str += "No houses found.\n";
  } else {
     str += num + " houses found.\n";
  }
  write("$P$Housing$P$" + str);
  return 1;
}
mixed *query_patterns() {
  return ({ "list", (: do_list(0) :),
              "list <string'search'>", (: do_list($4[0]) :),
              "list address", (: do_list_address(0) :),
              "list address <string'search'>", (: do_list_address($4[0]) :),
              "sell <word'house'>", (: do_sell($4[0]) :),
              "add <word'house'> <word'region'> <number'rented'> "
              "<string'address'>", (: do_add($4[0], $4[1], $4[2], $4[3]) :),
              "modify <word'house'> <word'region'> <number'rented'> "
              "<string'address'>", (: do_modify($4[0], $4[1], $4[2], $4[3]) :),
              "add room <word'house'> <string'room'>",
              (: add_room($4[0], $4[1]) :),
              "remove room <word'house'> <string'room'>",
              (: remove_room($4[0], $4[1]) :),
              "owner <word'house'> <string'owner'>",
              (: do_owner($4[0], $4[1]) :),
              "remove <word'house'>", (: do_remove($4[0]) :),
              });
}

==================================================
FILE: creator/iemote.c
==================================================

#include <network.h>
inherit "/cmds/base";
int cmd(string person, string text) {
    string target, mud;
    if (sscanf(person, "%s@%s", target, mud) != 2) {
        return 0;
    }
    if ( !strlen( target ) || !strlen( mud ) ) {
        return 0;
    }
    SERVICES_D->eventSendEmote(target, mud, text);
    add_succeeded_mess( ({ sprintf("You emote to %s@%s: %s@%s %s\n",
        capitalize(target), mud, this_player()->query_cap_name(),
        mud_name(), text), "" }) );
    return 1;
}
mixed *query_patterns() {
    return ({ "<string'person'> <string'message'>",
              (: cmd($4[0], $4[1]) :) });
}

==================================================
FILE: creator/iloc_ate.c
==================================================

#include <network.h>
mixed cmd(string who) {
  if (!who) {
    notify_fail("Syntax: locate <name>\n");
    return 0;
  }
  SERVICES_D->eventSendLocateRequest(who);
  printf("Locating %s. Don't explode !\n", who);
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/inh_eritance.c
==================================================

#include <creator.h>
inherit "/cmds/base";
private string inherith(string ob, string ind, string leaf);
private int cmd(string fn, string fn2) {
    object ob, ob2;
    fn = this_player()->get_path( fn );
    if (!( ob = find_object( fn ))) {
        add_failed_mess( "No such object: " + fn + "\n" );
        return 0;
    }
    if ( fn2 ) {
        fn2 = this_player()->get_path( fn2 );
        if (!( ob2 = find_object( fn2 ))) {
            add_failed_mess( "No such object: " + fn2 + "\n" );
            return 0;
        }
    }
    fn = file_name(ob);
    write(fn + "\n" + inherith(fn, "  ", fn2 ));
    return 1;
}
private string inherith(string ob, string ind, string leaf) {
    string *fn, rtn = "", s;
    int i;
    if(!load_object(ob))
      return ind + "unable to find " + ob + "\n";
    fn = inherit_list(find_object(ob));
    for (i = 0; i < sizeof(fn); i++) {
        if (leaf && (find_object(fn[i]) == find_object(leaf))) {
            rtn += ind + fn[i] + "\n";
        } else {
            s = inherith(fn[i], ind + "  ", leaf);
            if (!leaf || (s != "")) {
                rtn += ind + fn[i] + "\n" + s;
            }
        }
    }
    return rtn;
}
int wiz_present_cmd( mixed indirect_obs ) {
    object fo, fo2;
    string fn, fn2;
    if ( !arrayp( indirect_obs ) ) {
        return 0;
    }
    if ( sizeof( indirect_obs ) < 1 ) {
        return 0;
    }
    if ( arrayp( indirect_obs[0] ) ) {
        fo = indirect_obs[0][0];
        if ( sizeof( indirect_obs ) == 2 ) {
            fo2 = indirect_obs[ 1 ][ 0 ];
        }
    }
    else {
        fo = indirect_obs[ 0 ];
        if ( sizeof( indirect_obs ) == 2 ) {
            fo2 = indirect_obs[ 1 ];
        }
    }
    if ( fo ) {
        fn = file_name( fo );
    }
    if ( fo2 ) {
        fn2 = file_name( fo2 );
    }
    debug_printf( "%O, %O\n", fn, fn2 );
    return cmd( fn, fn2 );
}
public mixed *query_patterns() {
    return ({
              "<word> [with] <word>", (: cmd( $4[0], $4[1] ) :),
              "<word>", (: cmd( $4[0], 0 ) :),
              "<indirect:wiz-present> with <indirect:wiz-present>", (: wiz_present_cmd( $1 ) :),
              "<indirect:wiz-present>", (: wiz_present_cmd( $1 ) :),
    });
}

==================================================
FILE: creator/inv.c
==================================================

#include <creator.h>
inherit "/cmds/base";
protected int cmd( object *obs ) {
    object ob;
    object *inventory;
    foreach( ob in obs ) {
        inventory = filter( all_inventory( ob ),
          (: reference_allowed( $1, $( this_player() ) ) :) );
        tell_object( this_player(), "Inv of " + WIZ_PRESENT->desc_object( ob ) +
          " in " + WIZ_PRESENT->desc_object(
            environment( ob ) ) + ":\n" );
        tell_object( this_player(), implode( map( inventory,
              (: "  " + WIZ_PRESENT->desc_f_object( $1 ) :) ), "\n" ) + "\n" );
        if ( !sizeof( inventory ) ) {
            continue;
        }
    }
    return 1;
}
mixed *query_patterns() {
    return ({ "[of] <indirect:wiz-present>", (: cmd($1) :) });
}

==================================================
FILE: creator/jumps.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
object find_location(string str) {
   if (find_object(str)) {
      return find_object(str);
   }
   return load_object(str);
}
int do_add_jump(string from, string to) {
   object from_ob;
   object to_ob;
   from_ob = find_location(from);
   to_ob = find_location(to);
   if (!from_ob) {
      add_failed_mess("The from location does not exist.\n");
      return 0;
   }
   if (!to_ob) {
      add_failed_mess("The to location does not exist.\n");
      return 0;
   }
   PLAYTESTER_HAND->add_jump_point(from, to);
   write("You added the jump point from " + from + " to " + to + ".\n");
   return 1;
}
int do_path_list() {
   string str;
   string from;
   string* dest;
   str = "";
   foreach (from, dest in PLAYTESTER_HAND->query_jump_points()) {
      str += from + ": " + query_multiple_short(dest) + ".\n";
   }
   write(str);
   return 1;
}
int do_remove_jump(string from, string to) {
   string* dests;
   dests = PLAYTESTER_HAND->query_jump_destination(from);
   if (!sizeof(dests)) {
      add_failed_mess("There are no destiations from " + from + ".\n");
      return 0;
   }
   if (member_array(to, dests) == -1) {
      add_failed_mess("Unable to remove a jump from " + from + " to " +
                      to + ".\nValid to's are: " +
                      query_multiple_short(dests) + ".\n");
      return 0;
   }
   PLAYTESTER_HAND->remove_jump_point(from, to);
   write("Removed the jump from " + from + " to " + to + ".\n");
   return 1;
}
mixed* query_patterns() {
   return ({ "add <string'from'> <string'to'>", (: do_add_jump($4[0], $4[1]) :),
        "remove <string'from'> <string'to'>", (: do_remove_jump($4[0], $4[1]) :),
        "creator list", (: do_path_list :) });
}

==================================================
FILE: creator/loc_alcmd.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  int flags, i, j, pos;
  mixed flag_types;
  object *obs;
  string *coms, flag;
  mixed *junk;
  if (!str) str = "";
  flag_types = ({ "priority", "star", "function", "object" });
  while (strlen(str) && str[0] == '-') {
    if (sscanf(str, "-%s %s", flag, str) != 2) {
      flag = str[1..100];
      str = "";
    }
    i = member_array(flag, flag_types, 1);
    if (i != -1) {
      flags |= 1 << i;
    }
  }
  if (!flags) {
    if (!strlen(str))
      coms = actions_defined(this_player());
    else {
      obs = WIZ_PRESENT->wiz_present(str, this_player());
      if (!sizeof(obs)) {
        notify_fail("Could not find "+str+" to get the commands off.\n");
        return 0;
      }
      coms = map(obs, (: actions_defined($1) :));
    }
  } else {
    if (!strlen(str))
      junk = actions_defined(0, 0, flags);
    else {
      obs = WIZ_PRESENT->wiz_present(str, this_object());
      if (!sizeof(obs)) {
        notify_fail("Could not find "+str+" to get the commands off.\n");
        return 0;
      }
      junk = map(obs, (: actions_defined($1, 0, $(flags)) :));
    }
    coms = ({ });
    for (i=1;i<sizeof(junk);i+=2) {
      pos = 0;
      str = junk[i-1];
      if ((flags&0xc) == 0xc) {
        str = WIZ_PRESENT->desc_f_object(junk[i][0])+"->"+junk[i][1]+":"+str;
        pos += 2;
      } else if (flags&0x8) {
        str = WIZ_PRESENT->desc_object(junk[i][0])+":"+str;
        pos++;
      } else if (flags&0x4) {
        str = junk[i][0]+"%"+str;
        pos++;
      }
      if (flags&0x2) {
        if (j = junk[i][pos]) {
          if (strlen(junk[i-1]) == j)
            str += "*";
          else {
            j = strlen(str)-junk[i][pos];
            str = str[0..j]+"*"+str[j+1..10000];
          }
        }
        pos++;
      }
      if (flags&1) {
        str += "|"+junk[i][pos];
      }
      coms += ({ str });
    }
  }
  this_player()->more_string( sprintf( "%-#*s\n",
      (int)this_player()->query_cols(),
      implode( coms, "\n" ) ), "Commands" );
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/lpc_info.c
==================================================

mixed cmd(string str) {
  printf("%s", lpc_info());
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/mail.c
==================================================

#include <mail.h>
mixed cmd(string str) {
  return (int)MAIL_TRACK->mail(str);
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/malloc.c
==================================================

mixed cmd(string str) {
  printf("%s", malloc_status());
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/mem_stat.c
==================================================

#include <creator.h>
#define OBJ_LIMIT 50
#define TP this_player()
inherit "/cmds/base";
string help();
mixed cmd(string str) {
  int memtotal, limit, i = TP->query_cols() -7 -1, j;
  string ret, str2, str3;
   object *objlist;
  if (!str || str == "")
    return notify_fail(help());
  while (strlen(str) && str[0] == ' ')
    str = str[1..];
  if (sscanf(str, "-%s%d %s", str3, limit, str2) == 3) {
    if (str3[0..0] != "l")
      return notify_fail("Error: Only valid character following '-' is 'l' at "
                         "this time.\n");
    str = str2;
  }
  seteuid(geteuid(TP));
  objlist = WIZ_PRESENT->wiz_present(str, TP);
  if (!arrayp(objlist) || sizeof(objlist) < 1) {
    mixed *filelist;
    str = TP->get_path(str);
    notify_fail("Unable to find any objects or files corresponding"
                " to the given name.\n");
    if (sizeof(filelist = TP->get_files(str)) > 0) {
      filelist = filter(filelist, (: (sizeof($1) > 2) &&
                                   ($1[sizeof($1) - 2..] == ".c") :));
      if (sizeof(filelist) < 1)
        return 0;
      filelist = filter(filelist, (: find_object($1) :));
      objlist = map(filelist, (: find_object($1) :));
    } else
      return 0;
  }
  ret = sprintf("%-"+ i +"s %-7s\n", "Object name", "Memory");
  ret += sprintf("%-"+ i +"s %-7s\n", "------------", "-------");
  if (!limit)
    limit = OBJ_LIMIT;
  if (limit > sizeof(objlist))
    limit = sizeof(objlist);
  if (limit == 1)
    ret += sprintf("%-"+ i +"."+ i +"s %7.7d\n",
                   WIZ_PRESENT->desc_f_object(objlist[sizeof(objlist) - 1]),
                   memory_info(objlist[sizeof(objlist) - 1]));
  else
    for (j = 0; j < limit; j++)
      ret += sprintf("%-"+ i +"."+ i +"s %7.7d\n",
                     WIZ_PRESENT->desc_f_object(objlist[j]),
                     memory_info(objlist[j]));
  if (sizeof(objlist) > 1) {
    for (j = 0; j < sizeof(objlist); j++)
      memtotal += memory_info(objlist[j]);
    ret += sprintf("%-"+ i +"."+ i +"s %7.7s\n",
                   "", "=======");
    ret += sprintf("%-"+ i +"."+ i +"s %7.7d\n",
                   "Total memory used for all "+ sizeof(objlist) +
                   " object(s):", memtotal);
  }
  TP->more_string(ret);
  return 1;
}
string help() {
  return "Usage: memstat [-l<number>] [<filename(s)>|<wiz_present syntax>]\n\n"
"Memstat lists the guestimated amount of memory the specified object(s) use. "
"Using the -l option, a maximum amount of objects to be listed may be "
"specified otherwise a default limit of "+ OBJ_LIMIT +" objects are listed. "
"Paths including wildcards are taken as a way of specifying more than one "
"file.\n";
}
mixed *query_patterns() {
    return ({ "<string>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: creator/meteor.c
==================================================

#include <playerinfo.h>
inherit "/cmds/base";
mixed cmd(string words) {
  string player, reason;
  object ob;
  if(this_player()->query_name() == "macchirton") {
    return notify_fail("You cannot use meteor.\n");
  }
  if(!words || sscanf(words, "%s %s", player, reason ) != 2) {
    return notify_fail("Usage: meteor <player> <reason>\n");
  }
  ob = find_player(this_player()->expand_nickname(player));
  if(!ob) {
    return notify_fail(player+" not found!\n");
  }
  write("Warning: This is not to be used for pranks.  If you "
    "do not have a valid reason to use this, do not use it!  "
    "Are you quite sure you wish to proceed? (y|n): ");
  input_to("are_sure", ob, reason);
  return 1;
}
void are_sure(string str, object ob, string reason) {
  string gender = "boy";
  if(this_player()->query_gender() == 2) {
    gender = "girl";
  }
  str = lower_case(str);
  if(str[0] != 'y') {
    write("Good little "+gender+"!  Now go play nice with "
      +ob->one_short()+".\n");
    return;
  }
  PLAYERINFO_HANDLER->add_entry(this_player(),
                                ob->query_name(),
                                "meteor",
                                reason);
  log_file("NUKE", "%s: %s nuked %s: %s\n", ctime(time()),
    this_player()->query_short(), ob->query_short(), reason);
  shout("You see a very large %^YELLOW%^meteor%^RESET%^ up in the sky.\n");
  write("Nuking player "+ob->query_name()+".\n");
  call_out("nuke2", 2, ob);
}
void nuke2(object ob) {
  shout("The %^YELLOW%^meteor%^RESET%^ rushes towards the ground.\n");
  tell_object(ob, "It looks like it's heading for you.\n");
  call_out("nuke3", 5, ob);
}
void nuke3(object ob) {
  tell_object(ob, "The %^YELLOW%^meteor%^RESET%^ hits you ......"+
    "%^RED%^WALLOP.%^RESET%^\n");
  shout(ob->query_cap_name()+" has been struck by a meteor.\n"+
        capitalize(ob->query_pronoun())+" is no more.\n");
  ob->save();
  ob->quit();
}

==================================================
FILE: creator/mk_dir.c
==================================================

mixed cmd(string str) {
   seteuid(geteuid(this_player()));
   if (!str || str == "") {
      notify_fail("Make what directory?\n");
      return 0;
      }
   str = this_player()->get_path(str);
   str = replace(str, " ", "_");
   if (!str)
      return 1;
   if (file_size(str) != -1) {
      notify_fail(str + " already exists.\n");
      return 0;
      }
   if (!mkdir(str)) {
      notify_fail("Couldn't make dir.\n");
      return 0;
   }
   write("Ok.\n");
   return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/mo_re.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  object *things;
  seteuid(geteuid(this_player()));
  if(!str) {
    notify_fail("More which file(s)/object?\n");
    return 0;
  }
  if(sizeof(things = WIZ_PRESENT->wiz_present(str, this_player()))) {
    str = file_name(things[0]);
    sscanf(str, "%s#%*d", str);
    if (file_size(str) <= 0)
      str += ".c";
  }
  return this_player()->more_file(str);
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/mobs.c
==================================================

#include <creator.h>
#define COUNT 10
int cmd(string arg){
  mapping m = ([]);
  string *obs, ob, ret = "";
  if(!master()->query_senior(this_player()->query_name()))
    return 0;
  switch(arg){
  case "all":
    objects((:$(m)[base_name($1)]++,reset_eval_cost():));
    break;
  case "inside":
    objects((:environment($1) && $(m)[base_name($1)]++:));
    break;
  default:
    objects((:environment($1) && living($1) &&
       $(m)[base_name($1)]++:));
  }
  obs = keys(filter(m, (:$2 > COUNT:)));
  foreach(ob in obs){
    object *things, thing;
    m = ([]);
    reset_eval_cost();
    if(arg != "all")
      things = filter(children(ob), (:environment($1):));
    else
      things = children(ob);
    foreach(thing in things)
      m[environment(thing)]++;
    m = filter(m, (:$2 > COUNT:));
    if(sizeof(m)){
      object *rooms = keys(m);
      foreach(thing in rooms){
        ret += sprintf("%3d %s in %s\n", m[thing],
                       WIZ_PRESENT->desc_f_object(find_object(ob)),
                       WIZ_PRESENT->desc_f_object(thing));
      }
    }
  }
  ob = sprintf("/w/%s/mobs", this_player()->query_name());
  printf("Saving to %s.\n", ob);
  seteuid(geteuid(this_player()));
  unguarded((:rm($(ob)),write_file($(ob), $(ret)):));
  return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd(0) :),
      "{all|inside}", (: cmd($4[0]) :) });
}
string help() {
  return "Shows groups of NPCs of one kind that are in the same room.";
}

==================================================
FILE: creator/mudinfo.c
==================================================

inherit "/cmds/base";
#ifndef __COMPILER__
#define __COMPILER__     "probably gcc"
#define __OPTIMIZATION__ "bugged driver?"
#endif
#define WIDTH 15
#define PAD(x,y)      sprintf("%-*s: %s\n", WIDTH, x,"" + y)
varargs string pretty_time(int tim, int len);
private nosave int num_obs;
mixed cmd(string str) {
   mapping r;
   float cpu;
   string name, cc, tmp;
   int *ltype;
   name = capitalize(mud_name()) + "   (" + query_host_name() + " " +
          __PORT__ + ")";
   cc = __COMPILER__ + "   (" + __OPTIMIZATION__ + ")";
   r = rusage();
   cpu = ((r["utime"] + r["stime"]) / uptime() / 10.0);
   num_obs = 0;
   objects((: num_obs++ :));
   ltype = implode(users(), (:$1[compressedp($2)]++, $1:), ({0,0}));
   tmp = PAD("Mud name", name) +
         PAD("Driver", __VERSION__) +
         PAD("Architecture", __ARCH__) +
         PAD("Compiler", cc) +
         PAD("Driver uptime", pretty_time(uptime(), 4)) +
         PAD("Avg Cpu usage", sprintf("%4.2f%%",cpu)) +
         PAD("Load Average", query_load_average()) +
         PAD("No of users", sizeof(users())) +
         PAD("Using MCCP", ltype[1]) +
         PAD("Plain telnet", ltype[0]) +
         PAD("Named Livings", sizeof(named_livings())) +
         PAD("Objects", num_obs) +
         PAD("Call Outs", sizeof(call_out_info()) + " pending.") +
         PAD("Memory usage", memory_info());
   tell_object(this_player(), tmp);
   return 1;
}
varargs string pretty_time(int tim, int len) {
   int num;
   string *bits, tmp;
   if(!len)
     len = 99999;
   bits = ({ });
   if(tim >= 60*60*24 && sizeof(bits) < len)
      bits += ({ (num=tim/(60*60*24))+" day"+(num==1?"":"s") });
   if(tim >= 60*60 && tim%(60*60*24) && sizeof(bits) < len)
      bits += ({ (num=(tim/(60*60))%24)+" hour"+(num==1?"":"s") });
   if(tim >= 60 && tim%(60*60) && sizeof(bits) <len)
      bits += ({ (num=(tim/60)%60)+" minute"+(num==1?"":"s") });
   if(tim%60 && sizeof(bits) <len)
      bits += ({ (num=tim%60)+" second"+(num==1?"":"s") });
   for(len =0; len<sizeof(bits); len++)
      if(sscanf(bits[len],"%d %s", num, tmp) == 2 && num == 0)
         bits[len] = 0;
   return implode(bits, ", ");
}

==================================================
FILE: creator/multipl_ayer.c
==================================================

#include <creator.h>
#include <player.h>
inherit "/cmds/base";
varargs int cmd(string command, string name, string what, string extra) {
  switch (command) {
  case "add":
    if (!call_other(PLAYER_MULTIPLAYER_HANDLER, "add_" + what, name, extra)) {
      printf("\"%s\"%s isn't known here.\n", name, (extra ? " and/or \"" +
                extra + "\"" : ""));
    } else {
      if (what == "allowed") {
        printf("\"%s\" and \"%s\" added as allowed together.\n", name, extra);
      } else {
        printf("\"%s\" added.\n", name);
      }
    }
    break;
  case "del":
    if(!call_other(PLAYER_MULTIPLAYER_HANDLER, "delete_" + what, name)) {
      printf("\"%s\" isn't on the list.\n", name);
    } else {
      printf("\"%s\" deleted.\n", name);
    }
    break;
  case "log":
    PLAYER_MULTIPLAYER_HANDLER->mark_log(name, extra);
    if (extra) {
      printf("Added \"multiplay\" playerinfo event for \"%s\": \"%s\".\n",
           name, extra);
    } else {
      printf("Marked \"multiplay\" playerinfo events for \"%s\" as handled.\n",
           name);
    }
    break;
  case "list":
    write("The list currently consists of: $I$5=\n" +
          query_multiple_short(sort_array(call_other(PLAYER_MULTIPLAYER_HANDLER,
                                                     "query_" + what),
                                          (: strcmp($1, $2) :)))
          + "$I$0=\n");
    break;
  case "site":
    if(find_player(name)) {
      name = query_ip_number(find_player(name));
    }
    if("/secure/bastards"->change_multi(name, 1, time() + 3600)) {
      write("Site " + name + " has been permitted for multiplayers "
            "for the next hour.\n");
    } else {
      write("Error permitting site " + name + " for multiplayers.\n");
    }
    break;
  default:
    write("Unknown option.\n");
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "[list]",  (: cmd("list", 0, "gits") :),
              "{list allow}", (: cmd("list", 0, "allowed") :),
            "add git <word'name'>", (: cmd("add", $4[0], "git") :),
            "add allowed <word'first name'> <word'second name'>",
            (: cmd("add", $4[0], "allowed", $4[1]) :),
            "allow site <word'address|name'>", (: cmd("site", $4[0], "allowed") :),
            "del allowed <word'name'>", (: cmd("del", $4[0], "allowed") :),
            "log <word'name'>", (: cmd("log", $4[0], "git") :),
            "log <word'name'> <string'log text'>", (: cmd("log", $4[0], "git",
                                                       implode($4[1..], " ")) :)
         });
}

==================================================
FILE: creator/mv.c
==================================================

mixed cmd(string str) {
  int loop, fs, pos, multi;
  string *filenames, dest, *fnames, trash1, trash2, trash3, trash4;
  string path, *temp, start, end;
  seteuid(geteuid(this_player()));
  if ((!str) || (sscanf(str, "%s %s", trash1, trash2) != 2))
    return notify_fail("Usage : mv file [file|dir...]\n");
  fnames = explode(str, " ");
  filenames = this_player()->get_files(implode(fnames[0..sizeof(fnames) -2], " "));
  if(!sizeof(filenames))
    return notify_fail("Usage : mv file [file|dir...]\n");
  dest = fnames[sizeof(fnames) - 1];
  dest = this_player()->get_path(dest);
  if (!dest) {
    write("No destination\n");
    return 1;
  }
  if (sscanf(str, "%s*%s %s*%s", trash1, trash2, trash3, trash4) == 4) {
    multi = 1;
    temp = explode(dest, "/");
    path = implode(temp[0..sizeof(temp) - 2], "/") + "/";
    sscanf(temp[sizeof(temp)-1], "%s*%s", start, end);
    temp = explode(implode(fnames[0..sizeof(fnames) -2], " "), "/");
    sscanf(temp[sizeof(temp)-1], "%s*%s", trash1, trash2);
    pos = strlen(trash1);
  }
  for (loop = 0; loop < sizeof(filenames); loop++) {
    str = filenames[loop];
    if(file_size(str) == -1) {
      write("No such file : " + str + "\n");
      continue;
    }
    if(multi) {
      temp = explode(str, "/");
      trash1 = temp[sizeof(temp)-1];
      fs  = strlen(trash1) - strlen(trash2) - 1;
      dest = path + start + trash1[pos..fs] + end;
      fs = file_size(dest);
    }
    else {
      fs = file_size(dest);
      if(fs == -2) {
        string *names;
        names = explode(str, "/");
        fs = file_size(dest + "/" + names[sizeof(names) - 1]);
      }
    }
    if(fs != -1) {
      write("File exists : " + dest + "\n");
      continue;
    }
    rename(str, dest);
  }
  write("Ok.\n");
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/net_stat.c
==================================================

#include <creator.h>
inherit "/cmds/base";
#include <peopler.h>
#include <creator.h>
mixed cmd(string str) {
   mixed *stuff;
   stuff = this_player()->query_property("netstat list");
   if (!stuff) {
      stuff = N_DEFAULT;
   }
   return PEOPLER->do_command(stuff, str);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/netdups.c
==================================================

#include <creator.h>
#include <peopler.h>
int cmd(string str) {
   mixed *bing;
   bing = this_player()->query_property("netdups list");
   if (!bing) {
      bing = ND_DEFAULT;
   }
   return PEOPLER->do_command(bing, str,
      (: query_ip_number($1) == 0 || query_ip_number($2) == 0 ||
         strcmp(query_ip_number($1), query_ip_number($2)) :),
      1);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/nslookup.c
==================================================

inherit "/cmds/creator/host";

==================================================
FILE: creator/ob_ject.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  int i, j, cols;
  string obvarname, start, end;
  mixed *names, *objects;
  if (str) {
    if (sscanf(str, "%s=%s", obvarname, str) != 2)
      return notify_fail("USAGE: object ObVarName=ObjectSpec\n");
    notify_fail("Can't find object.\n");
    objects = WIZ_PRESENT->wiz_present(str, this_player());
    if (!sizeof(objects))
      return 0;
    if (sizeof(objects) > 1)
      write("Only using first object of several matched.\n");
    this_player()->set_obvar(obvarname, objects[0]);
    write("Var "+obvarname+" now attached to "+
        WIZ_PRESENT->desc_object(objects[0])+".\n");
    return 1;
  }
  objects = m_values((mapping)this_player()->get_obvars());
  names = m_indices((mapping)this_player()->get_obvars());
  j = sizeof(objects);
  cols = this_player()->query_cols();
  for (i=0; i<sizeof(objects); i++) {
    if (!objects[i]) {
      j--;
      this_player()->del_obvar(names[i]);
      break;
    }
    if (objectp(names[i]))
      start = WIZ_PRESENT->desc_object(names[i]);
    else
      start = sprintf("%O", names[i]);
    if (objectp(objects[i]))
      end = WIZ_PRESENT->desc_object(objects[i]);
    else {
      end = sprintf("%O", objects[i]);
      end = replace(end, "\n", "");
    }
    printf("%s; %*-=s\n", start, cols-strlen(start)-2, end);
  }
  if (!j) write("No obvars set.\n");
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/on_line.c
==================================================

inherit "/cmds/base";
string idle_time(object person) {
  int hours, mins, secs;
  string s, m, h;
  secs = query_idle(person);
  mins = secs / 60;
  secs %= 60;
  hours = mins / 60;
  mins %= 60;
  s = ("0"+secs)[<2..<1];
  m = ("0"+mins)[<2..<1];
  if ( !hours )  {
    return " (idle: "+m+":"+s+")";
  }
  h = ("0"+hours)[<2..<1];
  return " (idle: "+h+":"+m+":"+s+")";
}
int cmd( int show_idle ) {
  object *people, person;
  string *cre, *invis, *director, *trustee, bing, obtyp;
  cre = ({ });
  invis = ({ });
  director = ({ });
  trustee = ({ });
  people = filter_array( users(), (: $1->query_creator() :) );
  people = people - this_player()->query_ignoring( people );
  people = sort_array( people,
    (: strcmp( $1->query_name(), $2->query_name() ) :) );
  foreach( person in people )  {
    bing = person->query_cap_name();
    if ( show_idle && query_idle( person ) > 120 )  {
      bing += idle_time( person );
    }
    if (!this_player()->query_property("nod")) {
      obtyp = person->query_object_type();
        switch(obtyp) {
        case "X":
           break;
        case " ":
           break;
        case "C":
           bing += "(%^CYAN%^C%^RESET%^)";
           if ( "/d/liaison/master"->query_member((string)person->query_name()))
              bing += "(%^YELLOW%^l%^RESET%^)";
           break;
        case "S":
           bing += "(%^BOLD%^%^CYAN%^S%^RESET%^)";
           if ( "/d/liaison/master"->query_member((string)person->query_name()))
             bing += "(%^YELLOW%^l%^RESET%^)";
           break;
        case "T":
           bing += "(%^BOLD%^%^RED%^T%^RESET%^)";
           if ( "/d/liaison/master"->query_member((string)person->query_name()))
             bing += "(%^YELLOW%^l%^RESET%^)";
           break;
        case "D":
           bing += "(%^RED%^D%^RESET%^)";
           if ( "/d/liaison/master"->query_member((string)person->query_name()))
             bing += "(%^YELLOW%^l%^RESET%^)";
           break;
        default:
           break;
      }
    }
    switch( person->query_invis()  )  {
      case 0:
        cre += ({ bing });
        break;
      case 1:
        invis += ({ bing });
        break;
      case 2:
        director += ({ bing });
        break;
      default:
        trustee += ({ bing });
        break;
    }
  }
  if(sizeof(cre)) {
    tell_object(this_player(),
      "/global/events"->convert_message("$I$2=%^GREEN%^"
      "Visible%^RESET%^: "+query_multiple_short(cre)+".\n"));
  }
  if(sizeof(invis)) {
    tell_object(this_player(),
      "/global/events"->convert_message("$I$2=%^CYAN%^"
      "Invisible%^RESET%^: "+query_multiple_short(invis)+".\n"));
  }
  if(sizeof(director)) {
    tell_object(this_player(),
      "/global/events"->convert_message("$I$2=%^YELLOW%^Director "
      "Invisible%^RESET%^: "+query_multiple_short(director)+".\n"));
  }
  if(sizeof(trustee)) {
    tell_object(this_player(),
      "/global/events"->convert_message("$I$2=%^RED%^Trustee "
      "Invisible%^RESET%^: "+query_multiple_short(trustee)+".\n"));
  }
  return 1;
}
mixed *query_patterns() {
    return ({ "", (: cmd(1) :),
              "noidle", (: cmd(0) :) });
}

==================================================
FILE: creator/panic.c
==================================================

#include <panic.h>
inherit "/cmds/base";
int cmd( ) {
    return 0;
  PANIC_HANDLER->do_startup(previous_object());
  this_player()->add_succeeded_mess(this_object(),
                  "$N panic$s hopefully.", ({ }) );
  return 1;
}
mixed *query_pattern() {
  return ({ "", (: cmd() :) });
}

==================================================
FILE: creator/path_of.c
==================================================

#include <creator.h>
mixed cmd(string str) {
  object *ov, ob;
  if(strsrch(str, "in everyone") != -1)
    return notify_fail("Please don't do that.  You've been asked not to "
      "and it causes lag.\n");
  notify_fail("Pathof what?\n");
  ov = WIZ_PRESENT->wiz_present(str, this_player());
  if (!sizeof(ov)) return 0;
  foreach (ob in ov) {
    if (!objectp(ob)) continue;
    write("Path of " + WIZ_PRESENT->desc_object(ob) + " in " +
        WIZ_PRESENT->desc_object(environment(ob)) + ":\n");
    write(file_name(ob)+ "\n");
  }
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/pe_ople.c
==================================================

inherit "/cmds/base";
#include <creator.h>
#include <peopler.h>
int num_sort(object first, object second) {
  int one, two;
  one = first->query_level();
  two = second->query_level();
  if(one < two)
    return 1;
  if(one > two)
    return -1;
  return 0;
}
int guild_sort(object first, object second) {
  object g1, g2;
  g1 = first->query_guild_ob();
  g2 = second->query_guild_ob();
  return strcmp(g1 ? g1->query_name() : "",
                g2 ? g2->query_name() : "");
}
int domain_sort(object first, object second) {
  object d1, d2;
  d1 = environment(first);
  d2 = environment(second);
  return strcmp(d1 ? file_name(d1) : "", d2 ? file_name(d2) : "");
}
int age_sort(object first, object second) {
  int one, two;
  one = first->query_time_on();
  two = second->query_time_on();
  if(one < two)
    return -1;
  if(one > two)
    return 1;
  return 0;
}
mixed cmd(string str) {
  mixed *stuff;
  string bit, *bits;
  function sort_func;
  stuff = this_player()->query_property("people list");
  if (!stuff)
    stuff = P_DEFAULT;
  if(str) {
    bits = explode(str, " ");
    str = 0;
    foreach(bit in bits) {
      switch(bit) {
      case "-l":
        sort_func = (: num_sort :);
        break;
      case "-g":
        sort_func = (: guild_sort :);
        break;
      case "-a":
        sort_func = (: age_sort :);
        break;
      case "-d":
        sort_func = (: domain_sort :);
        break;
      default:
        if(str)
          str += " " + bit;
        else
          str = bit;
      }
    }
  }
  return (int)PEOPLER->do_command(stuff, str, sort_func);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<string>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/perm_it.c
==================================================

#include <parser.h>
#include <access.h>
#include <player_handler.h>
#include <error_handler.h>
inherit "/cmds/base";
#define READ_MASK 1
#define WRITE_MASK 2
#define GRANT_MASK 4
#define LOCK_MASK 8
int help();
mixed cmd(string command, string euid, string path) {
  string* euids;
  string* bing;
  if (this_player() != this_player(1)) {
    return 0;
  }
  seteuid("Root");
  notify_fail("Something went wrong.\n");
  path = (string)this_player()->get_path(path);
  switch(command) {
  case "assign" :
    if (file_size(path) != -2) {
       notify_fail("The path " + path + " does not exist.\n");
       return 0;
    }
    euids = explode(replace_string(euid, " ", ""), ",") - ({ "none" });
    bing = filter(euids, (: !PLAYER_HANDLER->test_creator($1) &&
                            $1 != ERROR_ASSIGNED_NO_ONE:));
    if (sizeof(bing)) {
       notify_fail("The people " + query_multiple_short(bing) +
                   " are not creators.\n");
       return 0;
    }
    if ((int)master()->assign_people_to_directory(path, euids)) {
       add_succeeded_mess("Assigned the directory " + path +
                         " to " + query_multiple_short(euids) + ".\n");
       return 1;
    }
    notify_fail("Unable to assign the directory, not creator names?\n");
    return 0;
  case "read":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, READ_MASK))
      return notify_fail("You do not have permission to add read access.\n");
    return (int)master()->add_read_permission(euid, path);
    break;
  case "write":
      if (!master()->high_programmer(previous_object(-1)) &&
          !master()->valid_grant(this_player(), path, WRITE_MASK))
        return notify_fail("You do not have permission to add write "
                           "access.\n");
      return (int)master()->add_write_permission(euid, path);
      break;
  case "grant":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, GRANT_MASK))
      return notify_fail("You do not have permission to add grant access.\n");
    return (int)master()->add_grant_permission(euid, path);
    break;
  case "lock":
    if (!master()->query_lord(previous_object(-1)))
      return notify_fail("You don't have permission to lock paths.\n");
    if ((path[0..2] != "/d/") &&
        !master()->high_programmer(previous_object(-1)))
      return notify_fail("You don't have permission to lock paths there.\n");
    return (int)master()->lock_path(path);
  case "noread":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, READ_MASK))
      return notify_fail("You do not have permission to remove read "
                         "access.\n");
    return (int)master()->remove_read_permission(euid, path);
  break;
  case "nowrite":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, WRITE_MASK))
      return notify_fail("You do not have permission to remove write "
                         "access.\n");
    return (int)master()->remove_write_permission(euid, path);
    break;
  case "nogrant":
    if (!master()->high_programmer(previous_object(-1)) &&
        !master()->valid_grant(this_player(), path, GRANT_MASK))
      return notify_fail("You do not have permission to remove grant "
                         "access.\n");
    return (int)master()->remove_grant_permission(euid, path);
    break;
  case "unlock":
    if (!master()->query_lord(previous_object(-1)))
      return notify_fail("You don't have permission to lock paths.\n");
    if ((path[0..2] != "/d/") &&
        !master()->high_programmer(previous_object(-1)))
      return notify_fail("You don't have permission to lock paths there.\n");
    return (int)master()->unlock_path(path);
    break;
  default:
    return help();
  }
}
int do_directory_summary(string dir) {
   mapping assignments;
   mapping new_assignments;
   string* paths;
   string path;
   string ret;
   string domain;
   assignments = master()->query_directory_assignments();
   foreach (domain in master()->query_domains()) {
      ret = catch(new_assignments = ("/d/" + domain + "/master")->query_directory_assignments());
      if (sizeof(new_assignments)) {
         assignments += new_assignments;
      }
   }
   if (sizeof (dir)) {
     assignments = filter (assignments, (: strsrch ($1, $(dir)) != -1 :));
  }
   paths = sort_array( keys( assignments ), 1 );
   ret = sprintf("%40-s Assigned To\n", "Path");
   foreach (path in paths) {
      ret += sprintf("%-40s %s\n", path, query_multiple_short(assignments[path]));
   }
   write("$P$Directory Assignments$P$" + ret);
   return 1;
}
int do_directory_update(string dir) {
   mapping assignments;
   mapping new_assignments;
   string* paths;
   string path;
   string ret;
   string domain;
   string* bits;
   assignments = master()->query_directory_assignments();
   foreach (domain in master()->query_domains()) {
      ret = catch(new_assignments = ("/d/" + domain + "/master")->query_directory_assignments());
      if (sizeof(new_assignments)) {
         assignments += new_assignments;
      }
   }
   if (sizeof (dir)) {
     assignments = filter (assignments, (: strsrch ($1, $(dir)) != -1 :));
  }
   paths = sort_array( keys( assignments ), 0 );
   foreach (path in paths) {
      if (sizeof(assignments[path])) {
         bits = explode(path, "/");
         if (bits[0] == "d") {
           ERROR_HANDLER->do_update_directory_assignment(("/d/" + bits[1] + "/master")->query_lord(), assignments[path][0], path, (: 1 :));
         } else {
           ERROR_HANDLER->do_update_directory_assignment("nobody", assignments[path][0], path, (: 1 :));
         }
         write("Updated " + path + " to " + assignments[path][0] + "\n");
      }
   }
   write("$P$Directory Assignments$P$" + ret);
   return 1;
}
int do_summary(string str) {
  mapping perms;
  string *paths, *euids, ret, creator;
  int i, j, k;
  perms = (mapping)master()->query_permissions();
  if (str) {
    if (!perms[str]) {
      if (!PLAYER_HANDLER->test_user(str) && !master()->valid_euid(str)) {
        write("There are no permissions for "+str+".\n");
        return 1;
      } else {
        creator = str;
      }
    } else {
      perms = ([ str : perms[str] ]);
    }
  }
  paths = sort_array( keys( perms ), 1 );
  if (!sizeof(paths)) {
    ret = "No permissions set.\n";
  } else {
    ret = sprintf("%11-s    Path\n", "Euid");
  }
  for (i=0;i<sizeof(paths);i++) {
    euids = keys(perms[paths[i]]);
    for (j=0;j<sizeof(euids);j++) {
      if (!creator || (euids[j] == creator ) ) {
        k = perms[paths[i]][euids[j]];
        if (k & LOCK_MASK)
          ret += sprintf("%11-s LCK %s\n", euids[j], paths[i]);
        else
          ret += sprintf("%11-s %c%c%c %s\n", euids[j],(k & READ_MASK?'R':' '),
                         (k & WRITE_MASK?'W':' '), (k & GRANT_MASK?'G':' '),
                         paths[i]);
      }
    }
  }
  this_player()->more_string( ret, "Permissions", 1 );
  return 1;
}
int do_tidy() {
   int i, j, perm, same;
   string path, creator, *bits;
   mapping perms, euids, others;
   if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
      event( users(), "inform", "illegal attempt to call do_tidy() by "+
            (string)this_player()->query_name(), "cheat" );
      unguarded((: write_file, "/log/CHEAT", ctime( time() ) +": illegal "
                   "attempt to call do_tidy() by "+
                   (string)this_player()->query_name() +"\n" :));
      return notify_fail( "Failed.\n" );
   }
   perms = (mapping)master()->query_permissions();
   foreach( path in keys( perms ) ) {
      euids = perms[ path ];
      foreach( creator in keys( euids ) ) {
         perm = euids[ creator ];
         if ( !PLAYER_HANDLER->test_creator( creator ) &&
              !master()->valid_euid( creator ) ) {
            write( "No creator: "+ creator +".\n" );
            if ( perm & READ_MASK )
               master()->remove_read_permission( creator, path );
            if ( perm & WRITE_MASK )
               master()->remove_write_permission( creator, path );
            if ( perm & GRANT_MASK )
               master()->remove_grant_permission( creator, path );
            continue;
         }
         if ( path == "/" )
            continue;
         same = perms[ "/" ][ creator ] & perm;
         if ( same ) {
            write( "Access to / supercedes "+ path +" for "+ creator +".\n" );
            if ( same & READ_MASK )
               master()->remove_read_permission( creator, path );
            if ( same & WRITE_MASK )
               master()->remove_write_permission( creator, path );
            if ( same & GRANT_MASK )
               master()->remove_grant_permission( creator, path );
            continue;
         }
         bits = explode( path, "/" );
         j = sizeof( bits ) - 1;
         for ( i = 0; i < j; i++ ) {
            others = perms[ "/"+ implode( bits[ 0 .. i ], "/" ) ];
            if ( !others )
               continue;
            same = others[ creator ] & perm;
            if ( same ) {
               write( "Access to /"+ implode( bits[ 0 .. i ], "/" ) +
                     " supercedes "+ path +" for "+ creator +".\n" );
               if ( same & READ_MASK )
                  master()->remove_read_permission( creator, path );
               if ( same & WRITE_MASK )
                  master()->remove_write_permission( creator, path );
               if ( same & GRANT_MASK )
                  master()->remove_grant_permission( creator, path );
               break;
            }
         }
      }
   }
   return 1;
}
int help() {
  write("Available commands:\n"
"  read    <euid> <path>     : add read permison to the path.\n"
"  write   <euid> <path>     : add write permission to the path.\n"
"  grant   <euid> <path>     : add granting privileges to the path.\n"
"  lock           <path>     : restrict access to the path.\n"
"  noread  <euid> <path>     : remove read permission from the path.\n"
"  nowrite <euid> <path>     : remove write permission from the path.\n"
"  nogrant <euid> <path>     : remove granting privileges to the path.\n"
"  unlock         <path>     : remove restrictions to path.\n"
"  summary [path|euid]       : give a list of all the read/write perms.\n"
"  tidy                      : tidy away unnecessary perms.\n"
"  assign <euid> <path>      : assigns someone to look after a directory.\n"
"  assignment summary        : summary of directory assignments.\n" );
   return 1;
}
mixed *query_patterns() {
  return ({ "summary", (: do_summary(0) :),
              "summary <string>", (: do_summary($4[0]) :),
              "assignment summary", (: do_directory_summary(0) :),
              "assignment summary <string'filter'>", (: do_directory_summary($4[0]) :),
              "tidy", (: do_tidy() :),
              "help", (: help() :),
              "<word'permission'> <string'euid'> <word'path'>",
              (: cmd($4[0], $4[1], $4[2] ) :)
#ifdef 0
              ,
              "write <string'euid'> <string>", (: cmd("write", $4[0], $4[1]) :),
              "grant <string'euid'> <string>", (: cmd("grant", $4[0], $4[1]) :),
              "lock <string'euid'> <string>", (: cmd("lock", $4[0], $4[1]) :),
              "noread <string'euid'> <string>", (: cmd("noread", $4[0], $4[1]) :),
              "nowrite <string'euid'> <string>", (: cmd("nowrite", $4[0], $4[1]) :),
              "nogrant <string'euid'> <string>", (: cmd("nogrant", $4[0], $4[1]) :),
              "unlock <string'euid'> <string>", (: cmd("unlock", $4[0], $4[1])
                                                 :),
#endif
              });
}

==================================================
FILE: creator/playerinfo.c
==================================================

#include <creator.h>
#include <playerinfo.h>
#include <player_handler.h>
#define LOGGING
inherit "/cmds/base";
int do_report( string player, string event, int lastn, int interleaved ) {
   string who = this_player()->expand_nickname( lower_case(player) );
   string ret;
   if( !PLAYER_HANDLER->test_user(who) ) {
      tell_object( this_player(), "%^RED%^%^BOLD%^NOTE: %^RESET%^"
        "This is a player that either "
        "never existed or no longer exists.  Some deleted players' "
        "dossiers remain, while others do not.\n" );
   }
#ifdef LOGGING
   log_file( "/d/admin/log/PLAYERINFO.log", "%s: %s read dossier of %s.\n",
     ctime( time() ), this_player()->query_name(), who );
#endif
   if( interleaved ) {
     ret = PLAYERINFO_HANDLER->query_interleaved(this_player(), who,
                                                 event);
   } else if( !event ) {
     ret = PLAYERINFO_HANDLER->query_dossier( this_player(), who, lastn );
   } else {
     ret = PLAYERINFO_HANDLER->query_event( this_player(), who,
                                            lower_case(event) );
   }
   ret = this_player()->fix_string(ret, this_player()->query_cols());
   return this_player()->more_string(ret, "Playerinfo", 1);
}
int list_events() {
   string * list;
   string event, myself, result;
   list = sort_array( PLAYERINFO_HANDLER->query_events(), 1 );
   myself = base_name(this_object());
   result = "";
   foreach( event in list )
     result += ( event == list[0] ) ? event : ( ", " + event );
   write( "The following events exist: " + result + ". \n" );
   list = filter( list,
     (: PLAYERINFO_HANDLER->query_source_ok( $1, $(myself) ) :) );
   write( "You can manually add the following events: "
     + query_multiple_short(list) + ". \n" );
   return 1;
}
void update_database( string comment, string * data ) {
   if( !comment )
      return;
   if( PLAYERINFO_HANDLER->add_entry( this_player(), data[0], data[1],
                                      comment + "\n" ) ) {
      write( capitalize( data[0] ) + "'s dossier updated.\n" );
   } else {
      write( "Cannot update " + capitalize( data[0] ) + "'s dossier.\n" );
   }
}
int do_acknowledge( string player, string event, int idx, string update ) {
   if( !(PLAYERINFO_HANDLER->is_alert( player, idx ) ) ) {
      add_failed_mess( "That event is not an alert, so cannot be "
        "acknowledged.\n" );
      return -1;
   }
   if( !PLAYERINFO_HANDLER->acknowledge_alert( this_player(), player,
     event, idx, update, 0 ) ) {
      add_failed_mess( "You do not have the permission to acknowledge that alert, "
        "or the event type is invalid.\n" );
      return -1;
   }
   add_succeeded_mess( ({ "Event acknowledged.\n", "" }) );
   return 1;
}
int list_alerts( int foo ) {
   string * names;
   if( foo )
      names = PLAYERINFO_HANDLER->query_online_alerts();
   else
      names = keys( PLAYERINFO_HANDLER->query_alerts() );
   if( !sizeof( names ) )
      write( "There are no players with unacknowledged alerts.\n" );
   else
      write( "The following players have unacknowledged alerts: "
        + query_multiple_short( names ) + ". (" + sizeof( names ) +
        ")\n" );
   return 1;
}
int add_event( string player, string event, string comment ) {
   string *events;
   string myself;
   player = this_player()->expand_nickname( lower_case(player) );
   event = lower_case(event);
   if( !PLAYER_HANDLER->test_user(player) ) {
      add_failed_mess( "No such player: " + player + ".\n" );
      return 0;
   }
   myself = base_name( this_object() );
   events = filter( PLAYERINFO_HANDLER->query_events(),
     (: PLAYERINFO_HANDLER->query_source_ok( $1, $(myself) ) :) );
   if( member_array( event, events ) == -1 ) {
      add_failed_mess( "Incorrect event type '" + event
        + "': it must be one of " + query_multiple_short(events) + ".\n" );
      return 0;
   }
   if( comment ) {
      update_database( comment, ({ player, event }) );
      return 1;
   }
   write( "Please enter your comments:\n" );
   this_player()->do_edit( 0, "update_database", this_object(), 0,
     ({ player, event }) );
   return 1;
}
int add_alts( string s1, string s2, int deleting ) {
   string who, result;
   string * alts;
   who = this_player()->expand_nickname( lower_case(s1) );
   alts = explode( lower_case(s2), " " );
   alts = explode( implode( alts, "," ), "," ) - ({ "" }) - ({ 0 });
   if( deleting ) {
      result = PLAYERINFO_HANDLER->delete_alts( this_player(), who, alts );
   } else {
      result = PLAYERINFO_HANDLER->add_alts( this_player(), who, alts );
   }
   add_succeeded_mess( ({ result, "" }) );
   return 1;
}
mixed *query_patterns() {
   return ({
     "list",
       (: list_events() :),
     "list alerts",
       (: list_alerts(0) :),
     "list alerts online",
       (: list_alerts(1) :),
     "<word'playername'>",
       (: do_report( $4[0], 0, 10, 0 ) :),
     "<word'playername'> verbose",
       (: do_report( $4[0], 0, 0, 0 ) :),
     "<word'playername'> interleaved",
       (: do_report( $4[0], 0, 0, 1 ) :),
     "<word'playername'> <word'event type'> interleaved",
       (: do_report( $4[0], $4[1], 0, 1 ) :),
     "<word'playername'> <word'event type'>",
       (: do_report( $4[0], $4[1], 0, 0 ) :),
     "<word'playername'> acknowledge <number'event number'> "
       "<string'comment'>",
       (: do_acknowledge( $4[0], "misc", $4[1], $4[2] ) :),
     "<word'playername'> acknowledge <number'event number'> "
       "as <word'event type'> <string'comment'>",
       (: do_acknowledge( $4[0], $4[2], $4[1], $4[3] ) :),
     "<word'playername'> add [event] <word'event type'>",
       (: add_event( $4[0], $4[1], 0 ) :),
     "<word'playername'> add [event] <word'event type'> <string'comment'>",
       (: add_event( $4[0], $4[1], $4[2] ) :),
     "<word'playername'> addalt <string'alt-name alt-name ...'>",
       (: add_alts( $4[0], $4[1], 0 ) :),
     "<word'playername'> delalt <string'alt-name alt-name ...'>",
       (: add_alts( $4[0], $4[1], 1 ) :),
   });
}

==================================================
FILE: creator/playerskills.c
==================================================

#include <skills.h>
private string rec_list( mixed *args, string path, int all, int lvl,
                 int only_leaf, object pl ) {
   int i, sk, o_l;
   string str, tp, tmp;
   str = "";
   for ( i = 0 ; i < sizeof( args ) ; i += SKILL_ARR_SIZE ) {
      o_l = 0;
      tp = path +"."+ args[ i ];
      sk = (int)pl->query_skill( tp );
      reset_eval_cost();
      if (lvl == 1 && SKILL_OB->query_only_leaf(tp))
        o_l = 1;
      if (!(only_leaf || o_l) || (!sizeof(args[i+SKILL_BIT]) &&
                                  (sk > 0 || all)))
        str += sprintf( "%*'| 's%*'.'-s %4d %4d\n", ( lvl-1 ) * 2, "",
              20 - ( ( lvl - 1 ) * 2 ), args[ i ], sk,
              (int)pl->query_skill_bonus( tp ) );
      if ( sizeof( args[ i + SKILL_BIT ] ) && ( only_leaf || o_l || all
                                                || ( sk > 5 * lvl ) ) ) {
         tmp = rec_list( args[ i + SKILL_BIT ], path +"."+ args[i],
                         all, lvl + 1, only_leaf || o_l, pl );
         if ((only_leaf || o_l) && (tmp != "" || (!all && lvl == 1)))
           str += sprintf( "%*'| 's%*'.'-s    -    -\n", ( lvl-1 ) * 2, "",
                           20 - ( ( lvl - 1 ) * 2 ), args[ i ]) + tmp;
         else
           str += tmp;
      }
   }
   return str;
}
private int real_cmd( object *players, string word ) {
   int i;
   string result, *bits;
   object pl;
   mixed *args;
   pl = players[0];
   result = "";
   bits = ({ });
   if ( word ) {
      args = (mixed *)SKILL_OB->query_skills();
      if ( ( i = member_array( word, args ) ) == -1 ) {
         notify_fail( "Usage: "+ query_verb() +" <skill>\n" );
         return 0;
      }
      args = args[ i + SKILL_BIT ];
      result = sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
            "=======SKILLS=======Level/Bonus" );
      result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
            rec_list( args, word, 1, 1, 0, pl ) );
      this_player()->more_string( result, "Skills" );
    tell_object( pl, this_player()->query_cap_name() + " is checking "
        "your skills.\n" );
      return 1;
   }
   args = (mixed *)SKILL_OB->query_skills();
   result += sprintf( "%'='*-s\n", (int)this_player()->query_cols(),
         "=======SKILLS=======Level/Bonus");
   result += sprintf( "%#*-s\n", (int)this_player()->query_cols(),
         rec_list( args, "", ( member_array( "all", bits ) != -1 ), 1, 0, pl ) );
   this_player()->more_string( result, "Skills" );
   tell_object( pl, this_player()->query_cap_name() + " is checking your "
       "skills.\n" );
   return 1;
}
private void check_response( string txt, object *indirect_obs, string skill ) {
    int result;
    if ( upper_case( txt ) == "Y" ) {
        result = real_cmd( indirect_obs, skill );
        return;
    }
    tell_object( this_player(), "Not viewing skills.\n" );
}
private int cmd( object *indirect_obs, string skill ) {
   if ( !sizeof( filter( indirect_obs, (: userp :) ) ) ) {
      check_response( "Y", indirect_obs, skill );
      return 1;
   }
   tell_object( this_player(), "Are you sure you wish to view " +
      query_multiple_short( indirect_obs ) + "'s skills?  You should ask "
      "$V$0=" + indirect_obs[0]->query_possessive() + ",their$V$ "
   "permission first.\n" );
   tell_object( this_player(), "Enter 'Y' to view " +
      query_multiple_short( indirect_obs ) + "'s skill tree.\n" );
   input_to( (: check_response :), 0, indirect_obs, skill );
   return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:wiz-present> <string>",
            (: cmd($1, $4[1]) :),
            "<indirect:wiz-present>",
            (: cmd($1, 0) :) });
}

==================================================
FILE: creator/pquests.c
==================================================

#include <quest_handler.h>
#include <library.h>
inherit "/cmds/base";
string quest_text(string quest);
int cmd( string player, int sorted ) {
    string *quests, text;
    int i, size;
    if ( !player ) {
        quests = QUEST_HANDLER->query_quest_names();
        text = "$P$Quest list$P$\nTotal quests on " + mud_name() + " :-\n\n";
    }
    else {
        quests = LIBRARY->query_quests(player);
        if (!quests) {
            add_failed_mess( "That player has not done any "
                "quests.\n" );
            return 0;
        }
    if ( sorted )
        quests = sort_array( quests, 1 );
        text = "$P$Quest list$P$\nQuests done for player " + player + " :-\n\n";
    }
    size = sizeof(quests);
    for ( i = 0; i < size; i++ ) {
        text += sprintf("%d. %s (%s) %s\n", i + 1, quests[i],
            QUEST_HANDLER->query_quest_title (quests[i]),
            quest_text( quests[i] ) );
    }
    tell_object( this_player(), text );
    return 1;
}
string quest_text(string quest) {
    switch ( QUEST_HANDLER->query_quest_status(quest) ) {
        case 0:
            return "(inactive)";
        case 1:
            return "";
        default:
            return "(broken)";
    }
}
mixed *query_patterns() {
    return ({ "", (: cmd(0, 0) :),
        "<string'player'>", (: cmd($4[0], 0) :),
        "<string'player'> sorted", (: cmd($4[0], 1) :)
    });
}

==================================================
FILE: creator/prof.c
==================================================

#include <housing.h>
inherit "/cmds/base";
#define MAX 500
int last_got;
mixed *data, *tot;
int total(mapping *info) {
  int ret;
  mapping item;
  foreach(item in info)
    ret += item["self"];
  return ret;
}
int cmd(string thing) {
  int i, j;
  mapping stuff;
  object ob;
  mixed foo;
  string ret;
  if(last_got < time() - 900) {
    data = map(objects((: !clonep($1) :)),
               (: ({ $1, function_profile($1) }) :));
    tot = allocate(sizeof(data));
    for(i=0; i<sizeof(data); i++) {
      tot[i] = ({ data[i][0], total(data[i][1]) });
    }
    for(i=0; i<24; i++) {
      reset_eval_cost();
      for (j = i; j < sizeof(tot); j++)
        if (tot[i][1] < tot[j][1]) {
          foo = tot[i];
          tot[i] = tot[j];
          tot[j] = foo;
        }
    }
    last_got = time();
  }
  ret = "";
  if(!thing) {
    for (i = 0; i < 50 && i<sizeof(tot); i++) {
      if(tot[i][1])
        ret += sprintf("%60-O %i\n", tot[i][0], tot[i][1]);
    }
  } else {
    ob = find_object(thing);
    if(!ob)
      return notify_fail("No such object.\n");
    ret += sprintf("%30-s %10s %10s %10s\n", "function", "calls", "self", "children");
    i = 0;
    for(j=0; j<sizeof(data); j++)
      if(data[j][0] == ob) {
        i = 1;
        break;
      }
    if(!i)
      return notify_fail("No such object in data.\n");
    foreach(stuff in data[j][1]) {
      ret += sprintf("%30-s %10d %10d %10d\n", stuff["name"], stuff["calls"],
             stuff["self"], stuff["children"]);
    }
  }
  write("$P$Profile$P$" + ret);
  return 1;
}

==================================================
FILE: creator/pstat.c
==================================================

inherit "/cmds/base";
int cmd( object *indirect_obs ) {
    object ob;
    mapping prop;
    string *sorted, property;
    string txt;
    txt = "$P$Properties$P$";
    foreach( ob in indirect_obs ) {
        prop = filter( ob->query_properties(), (: $2 :) );
        sorted = sort_array( keys( prop ), 1 );
        foreach( property in sorted ) {
            txt += sprintf( "$I$0,5=(%s): %O$I$0,-5=\n", property, prop[ property ] );
        }
    }
    tell_object( this_player(), txt );
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:wiz-present>", (: cmd( $1 ) :) });
}

==================================================
FILE: creator/ptest_ers.c
==================================================

inherit "/cmds/base";
#include <playtesters.h>
#include <project_management.h>
string query_applicant_text();
varargs int cmd(string check, string name, string reason) {
  int i;
  string *names, *projects;
  string ret = "";
  class project *tmp, *tmp2;
  switch (check) {
    case "ptinfo":
      ret = PLAYTESTER_HAND->query_show_list_colour();
      tell_object (this_player(), ret);
      return 1;
    break;
    case "assign":
      i = PROJECT_HANDLER->find_project (name);
      if (i == -1) {
        this_player()->add_failed_mess (this_object(), "There is no project "
          "of that ID.\n", ({ }));
        return 0;
      }
      else {
        names = PROJECT_HANDLER->assign_pts_to_project (i);
        if (!sizeof (names)) {
          this_player()->add_failed_mess (this_object(), "Something went "
            "wrong!\n", ({ }));
            return 0;
        }
        else {
          tell_object (this_player(), sprintf ("$I$5=You assign %s to project %s.\n",
          query_multiple_short (map (names, (: capitalize ($1) :))), name));
        return 1;
      }
    }
    break;
    case "allassign":
      tmp = PROJECT_HANDLER->get_playtesting_projects();
      tmp2 = filter (tmp, (: sizeof ($1->guild_specific) :));
      tmp -= tmp2;
      if (!sizeof (tmp) && !sizeof (tmp2)) {
          this_player()->add_failed_mess (this_object(), "There are no "
            "projects currently in playtesting.\n", ({ }));
          return 0;
      }
      else {
        for (int c = 0; c < 2; c++) {
          if (c == 0) {
            projects = map (tmp2, (: $1->id :));
          }
          else {
            projects = map (tmp, (: $1->id :));
          }
          foreach (string p in projects) {
            names = PROJECT_HANDLER->assign_pts_to_project (p);
            if (!sizeof (names)) {
              continue;
            }
            ret += sprintf ("$I$5=You assign %s to project %s.\n",
              query_multiple_short (map (names, (: capitalize ($1) :))), p);
          }
        }
        tell_object (this_player(), ret);
        return 1;
    }
    break;
    case "add":
      i = PLAYTESTER_HAND->add_playtester (name);
      if (i) {
        this_player()->add_succeeded_mess (this_object(), "$N add$s someone "
          "as a playtester.\n", ({ }));
        return 1;
      }
      else {
        this_player()->add_failed_mess (this_object(), "You cannot add this "
          "player as a playtester.\n", ({ }));
        return 0;
      }
    break;
    case "remove":
      i = PLAYTESTER_HAND->remove_playtester (name, reason);
      if (i) {
        this_player()->add_succeeded_mess (this_object(), "$N remove$s someone "
          "as a playtester.\n", ({ }));
        return 1;
      }
      else {
        this_player()->add_failed_mess (this_object(), "You cannot remove this "
          "player as a playtester.\n", ({ }));
        return 0;
      }
    break;
    case "shortlist":
      PT_APPLICATION_HANDLER->set_shortlist (name);
        this_player()->add_succeeded_mess (this_object(), "$N toggle$s "
          "something.\n", ({ }));
      return 1;
    break;
    case "investigate":
        PT_APPLICATION_HANDLER->set_considering (name);
        this_player()->add_succeeded_mess (this_object(), "$N toggle$s "
          "something.\n", ({ }));
        return 1;
    break;
    case "delete":
      i =  PT_APPLICATION_HANDLER->delete_applicant (name);
      if (i) {
        this_player()->add_succeeded_mess (this_object(), "$N delete$s someone "
          "as from the application process.\n", ({ }));
        return 1;
      }
      else {
        this_player()->add_failed_mess (this_object(), "You cannot remove this "
          "player from the application process.\n", ({ }));
        return 0;
      }
    break;
    case "holiday":
      i =  PLAYTESTER_HAND->query_leave(name);
      if (i) {
        PLAYTESTER_HAND->reset_leave(name);
        this_player()->add_succeeded_mess (this_object(), "$N reset$s someones "
          "playtester leave.\n", ({ }));
        return 1;
      }
      else {
        PLAYTESTER_HAND->set_leave(name, reason);
        this_player()->add_succeeded_mess (this_object(), "$N set$s someone "
          "as on leave.\n", ({ }));
        return 1;
      }
    break;
  }
}
mixed *query_patterns() {
   mixed *patterns =
    ({
      "add <word>", (: cmd ("add", $4[0]) :),
      "remove <word'name'> <string'reason'>", (: cmd ("remove", $4[0], $4[1]) :),
      "holiday <word> <string>", (: cmd ("holiday", $4[0], $4[1]) :),
      "shortlist <word>", (: cmd ("shortlist", $4[0]) :),
      "investigate <word>", (: cmd ("investigate", $4[0]) :),
      "delete <word>", (: cmd ("delete", $4[0]) :),
      "assign all", (: cmd ("allassign", "all") :),
      "assign <word>", (: cmd ("assign", $4[0]) :),
      "info", (: cmd ("ptinfo") :)
      });
  return patterns;
}

==================================================
FILE: creator/ptguilds.c
==================================================

#include <player.h>
string format_guild_list( string guild_path, string *members ) {
    return "Members of the " + (guild_path->query_short()
      ? guild_path->query_short() : "Misc.") + ": " +
        query_multiple_short( sort_array( map( members,
           (: capitalize( $1 ) :) ), 1 ) ) + ".";
}
int cmd( string guild ) {
    mapping data;
    string txt;
    string *members;
    data = PLAYTESTER_HAND->query_playtester_guilds();
    txt = "Playtester listing by Guild\n\n";
    if ( guild && ( members = data[ guild ] ) ) {
        txt = format_guild_list( guild, members );
    }
    else {
        txt += implode( values( map( data,
            (: format_guild_list( $1, $2 ) :) ) ), "\n\n" );
    }
    tell_object( this_player(), txt + "\n" );
    return 1;
}
mixed *query_patterns() {
    return ({ "", (: cmd(0) :),
              "<string'guild'>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/ptobj_ect.c
==================================================

inherit "/cmds/base";
#define PT_ARMOURY "/d/playtesters/palace_rooms/armoury"
mixed *query_patterns() {
    return ({ "info",
                  (: PT_ARMOURY->do_info() :),
              "help",
                  (: PT_ARMOURY->do_info() :),
              "list",
                  (: PT_ARMOURY->do_list_all() :),
              "list commands",
                  (: PT_ARMOURY->do_list_commands() :),
              "list objects",
                  (: PT_ARMOURY->do_list_commands() :),
              "control",
                  (: PT_ARMOURY->do_list_control_all() :),
              "control commands",
                  (: PT_ARMOURY->do_list_control_commands() :),
              "control objects",
                  (: PT_ARMOURY->do_list_control_commands() :),
              "request <string:'item'>",
                  (: PT_ARMOURY->do_request_object( lower_case( $4[ 0 ] ) ) :),
              "add object <word:'path of object'> as <string:'item name'>",
                  (: PT_ARMOURY->do_add_object( $4[ 0 ],
                                                lower_case( $4[ 1 ] ) ) :),
              "remove object <string:'item name'>",
                  (: PT_ARMOURY->do_remove_object( $4[ 0 ] ) :),
              "allow <word:'guilds'> to use object <string:'item name'>",
                  (: PT_ARMOURY->do_allow_object( $4[ 0 ],
                                                  lower_case( $4[ 1 ] ) ) :),
              "add command <string:'command name'>",
                  (: PT_ARMOURY->do_add_command( $4[ 0 ] ) :),
              "remove command <string:'command name'>",
                  (: PT_ARMOURY->do_remove_command( $4[ 0 ] ) :),
              "allow <word:'guilds'> to use command <string:'command name'>",
                  (: PT_ARMOURY->do_allow_command( $4[ 0 ], $4[ 1 ] ) :)
              });
}

==================================================
FILE: creator/pw_d.c
==================================================

inherit "/cmds/base";
int cmd() {
   write(this_player()->query_path() + "\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd :) });
}

==================================================
FILE: creator/qp_eople.c
==================================================

inherit "/cmds/base";
#include <peopler.h>
#include <creator.h>
mixed cmd(string str) {
   mixed *stuff;
   stuff = this_player()->query_property("qpeople list");
   if (!stuff) {
      stuff = D_DEFAULT;
   }
   return PEOPLER->do_command(stuff, str);
}
mixed *query_patterns() {
   return ({ "", (: cmd(0) :),
             "<word>", (: cmd($4[0]) :) });
}

==================================================
FILE: creator/qwho.c
==================================================

#include <top_ten_tables.h>
int cmd(string filter, string arg);
string* determine_location( object person ) {
    mixed *areas, *place;
    areas = ({
        ({ "/d/liaison/NEWBIE", ({ "Misc", "The newbie area" }) }),
        ({ "/room/air", ({ "Misc", "The air" }) }),
        ({ "/room/void", ({ "Misc", "The void" }) }),
        ({ "/room/rubbish", ({ "Misc", "The rubbish room" }) }),
        ({ "/room/departures", ({ "Misc", "The departures lounge" }) }),
        ({ "/room/jail", ({ "Misc", "Jail" }) }),
        ({ "/w/", ({ "Misc", "/w dirs" }) }),
        ({ "/d/cwc/utils/interview", ({ "CWC", "Interview room" }) }),
        ({ "/d/cwc/common", ({ "CWC", "Commonroom" }) }),
        ({ "/d/cwc/Brown_Islands", ({ "CWC", "Brown Islands" }) }),
        ({ "/d/cwc/Bes_Pelargic/Bad_Poo-Ning/roads/medina",
            ({ "CWC", "Medina" }) }),
        ({ "/d/cwc/Bes_Pelargic/Sum_Bing/roads/snail",
            ({ "CWC", "The Snail" }) }),
        ({ "/d/cwc/Bes_Pelargic", ({ "CWC", "Bes Pelargic" }) }),
        ({ "/d/cwc/Hunghung", ({ "CWC", "HungHung" }) }),
        ({ "/d/cwc/Isle_of_Tonahamen", ({ "CWC", "Isle of Tonahamen" }) }),
        ({ "/d/cwc/families/mcsweeny", ({ "CWC", "McSweeney Estate" }) }),
        ({ "/d/cwc/Maps", ({ "CWC", "Terrains" }) }),
        ({ "/d/cwc", ({ "CWC", "?" }) }),
        ({ "/d/guilds/assassins/Bes-Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/thieves/Bes-Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/warriors/BesPelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/warriors/Hunghung", ({ "CWC", "HH guilds" }) }),
        ({ "/d/guilds/priests/Bes_Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/wizards/Bes_Pelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/guilds/witches/bespelargic", ({ "CWC", "BP guilds" }) }),
        ({ "/d/underworld/moving_shop/rooms/cwc", ({ "CWC", "F-shop" }) }),
        ({ "/d/am/utils/interview", ({ "AM", "Interview room" }) }),
        ({ "/d/am/shades", ({ "AM", "The Shades" }) }),
        ({ "/d/am/common", ({ "AM", "Commonroom" }) }),
        ({ "/d/am", ({ "AM", "Ankh-Morpork" }) }),
        ({ "/d/special/player_shops", ({ "AM", "Tarnach's" }) }),
        ({ "/d/guilds/merchants", ({ "AM", "Ankh-Morpork" }) }),
        ({ "/d/guilds/assassins/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/thieves/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/warriors/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/priests/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/wizards/Ankh-Morpork",
            ({ "AM", "Unseen University" }) }),
        ({ "/d/guilds/witches/Ankh-Morpork", ({ "AM", "AM guilds" }) }),
        ({ "/d/guilds/witches/am", ({ "AM", "AM guilds" }) }),
        ({ "/d/klatch/utils/interview", ({ "Klatch", "Interview room" }) }),
        ({ "/d/klatch/common", ({ "Klatch", "Commonroom" }) }),
        ({ "/d/klatch/djel/city", ({ "Klatch", "KLK" }) }),
        ({ "/d/klatch/djel/necropolis", ({ "Klatch", "Necropolis" }) }),
        ({ "/d/klatch/djel/netherworld", ({ "Klatch", "Netherworld" }) }),
        ({ "/d/klatch/tsort/desert/roads",
            ({ "Klatch", "Tsort desert road" }) }),
        ({ "/d/klatch/tsort/desert", ({ "Klatch", "Tsort desert" }) }),
        ({ "/d/klatch/tsort", ({ "Klatch", "Tsort" }) }),
        ({ "/d/klatch/Maps", ({ "Klatch", "Terrains" }) }),
        ({ "/d/klatch", ({ "Klatch", "?" }) }),
        ({ "/d/guilds/assassins/Khot-lip-khin",
            ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/thieves/Khot-lip-khin", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/warriors/Khot-lip-khin",
            ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/priests/Djelibeybi", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/priests/Khot-lip-khin", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/wizards/Khot-lip-khin", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/guilds/wizards/Ephebe", ({ "Klatch", "Ephebe guilds" }) }),
        ({ "/d/guilds/wizards/Tsort", ({ "Klatch", "Tsort guilds" }) }),
        ({ "/d/guilds/witches/klk", ({ "Klatch", "KLK guilds" }) }),
        ({ "/d/ram/utils/interview", ({ "Ram", "Interview room" }) }),
        ({ "/d/ram/common", ({ "Ram", "Commonroom" }) }),
        ({ "/d/ram/Gloomy_Forest", ({ "Ram", "Gloomy forest" }) }),
        ({ "/d/ram/Lancre_Kingdom", ({ "Ram", "Lancre Kingdom" }) }),
        ({ "/d/ram/Listening_Monks", ({ "Ram", "Listening Monks" }) }),
        ({ "/d/ram/Razorback", ({ "Ram", "Razorback" }) }),
        ({ "/d/ram/Slice", ({ "Ram", "Slice" }) }),
        ({ "/d/ram/Sprite_Caverns", ({ "Ram", "Sprite caverns" }) }),
        ({ "/d/ram/Temple_of_Soyin", ({ "Ram", "Temple of Soyin" }) }),
        ({ "/d/ram/Uberwald", ({ "Ram", "Uberwald" }) }),
        ({ "/d/ram/badass", ({ "Ram", "Bad Ass" }) }),
        ({ "/d/ram/madstoat", ({ "Ram", "Mad Stoat" }) }),
        ({ "/d/ram/ohulan", ({ "Ram", "Ohulan-Cutash" }) }),
        ({ "/d/ram/foothills", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/bridge", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/moorland", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/gorge_road", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/Lower_Valleys", ({ "Ram", "Connecting paths" }) }),
        ({ "/d/ram/lancre_town", ({ "Ram", "Lancre Town" }) }),
        ({ "/d/ram/bandit_camp", ({ "Ram", "Bandit camp" }) }),
        ({ "/d/ram/druid_circle", ({ "Ram", "Druid circle" }) }),
        ({ "/d/ram/mountains", ({ "Ram", "Ramtops" }) }),
        ({ "/d/ram", ({ "Ram", "?" }) }),
        ({ "/d/guilds/assassins/Ohulan-Cutash", ({ "Ram", "OC guilds" }) }),
        ({ "/d/guilds/thieves/Madstoat", ({ "Ram", "Mad Stoat guilds" }) }),
        ({ "/d/guilds/warriors/Lancre", ({ "Ram", "Lancre guilds" }) }),
        ({ "/d/guilds/priests/Monks-of-Cool", ({ "Ram", "Monks of Cool" }) }),
        ({ "/d/guilds/priests/Ohulan-Cutash", ({ "Ram", "OC guilds" }) }),
        ({ "/d/guilds/wizards/Creel-Springs",
            ({ "Ram", "Creel Springs guilds" }) }),
        ({ "/d/guilds/witches/badass", ({ "Ram", "Bad Ass guilds" }) }),
        ({ "/d/guilds/witches/lancre", ({ "Ram", "Lancre guilds" }) }),
        ({ "/d/guilds/witches/madstoat", ({ "Ram", "Mad Stoat guilds" }) }),
        ({ "/d/guilds/witches/razorback", ({ "Ram", "Razorback guilds" }) }),
        ({ "/d/sur/utils/interview", ({ "Sur", "Interview room" }) }),
        ({ "/d/sur/common", ({ "Sur", "Commonroom" }) }),
        ({ "/d/sur/Maps", ({ "Sur", "Terrains" }) }),
        ({ "/d/sur/Dinky", ({ "Sur", "Dinky" }) }),
        ({ "/d/sur/Sto_Helit", ({ "Sur", "Sto Helit" }) }),
        ({ "/d/sur/StoLat", ({ "Sur", "Sto Lat" }) }),
        ({ "/d/sur/Hillshire", ({ "Sur", "Hillshire" }) }),
        ({ "/d/sur/Holywood", ({ "Sur", "Holywood" }) }),
        ({ "/d/sur/Nowhere", ({ "Sur", "Nowhere" }) }),
        ({ "/d/sur/PekanFord", ({ "Sur", "Pekan Ford" }) }),
        ({ "/d/sur/Sheepridge", ({ "Sur", "Sheepridge" }) }),
        ({ "/d/sur/Scrogden", ({ "Sur", "Scrogden" }) }),
        ({ "/d/sur/items/carriage", ({ "Sur", "Carriage" }) }),
        ({ "/d/sur", ({ "Sur", "?" }) }),
        ({ "/d/guilds/assassins/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/assassins/Sto-Helit", ({ "Sur", "SH guilds" }) }),
        ({ "/d/guilds/assassins/Sheepridge",
            ({ "Sur", "Sheepridge guilds" }) }),
        ({ "/d/guilds/thieves/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/thieves/Sto-Helit", ({ "Sur", "SH guilds" }) }),
        ({ "/d/guilds/thieves/Pekan_Ford", ({ "Sur", "PF guilds" }) }),
        ({ "/d/guilds/warriors/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/priests/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/wizards/Sto-Lat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/guilds/witches/skund", ({ "Sur", "Skund guilds" }) }),
        ({ "/d/guilds/witches/stolat", ({ "Sur", "SL guilds" }) }),
        ({ "/d/forn/utils/interview", ({ "Forn", "Interview room" }) }),
        ({ "/d/forn/common", ({ "Forn", "Commonroom" }) }),
        ({ "/d/forn/genua", ({ "Forn", "Genua" }) }),
        ({ "/d/forn", ({ "Forn", "?" }) }),
        ({ "/d/guilds/assassins/Genua", ({ "Forn", "Genua guilds" }) }),
        ({ "/d/special/utils/interview", ({ "Special", "Interview room" }) }),
        ({ "/d/special/common", ({ "Special", "Commonroom" }) }),
        ({ "/d/special/ctf", ({ "Special", "CTF" }) }),
        ({ "/d/special", ({ "Special", "?" }) }),
        ({ "/d/playtesters/utils/interview", ({ "Playtesters",
            "Interview room" }) }),
        ({ "/d/playtesters/common", ({ "Playtesters", "Commonroom" }) }),
        ({ "/d/playtesters/palace_rooms", ({ "Playtesters", "Palace" }) }),
        ({ "/d/playtesters", ({ "Playtesters", "?" }) }),
        ({ "/d/liaison/utils/interview", ({ "Liaison", "Interview room" }) }),
        ({ "/d/liaison/common", ({ "Liaison", "Commonroom" }) }),
        ({ "/d/liaison", ({ "Liaison", "?" }) }),
        ({ "/d/underworld/common", ({ "Underworld", "Commonroom" }) }),
        ({ "/d/underworld/death", ({ "Underworld", "Death's domain" }) }),
        ({ "/d/underworld/lspace", ({ "Underworld", "L-space" }) }),
        ({ "/d/underworld/moving_shop", ({ "Underworld", "T-shop" }) }),
        ({ "/d/underworld", ({ "Underworld", "?" }) }),
        ({ "/d/guilds/common", ({ "Guilds", "Commonroom" }) }),
        ({ "/d/guilds/assassins", ({ "Guilds", "Assassins" }) }),
        ({ "/d/guilds/thieves", ({ "Guilds", "Thieves" }) }),
        ({ "/d/guilds/warriors", ({ "Guilds", "Warriors" }) }),
        ({ "/d/guilds/priests/rooms", ({ "Guilds", "Passage rooms" }) }),
        ({ "/d/guilds/priests", ({ "Guilds", "Priests" }) }),
        ({ "/d/guilds/wizards", ({ "Guilds", "Wizards" }) }),
        ({ "/room/magic_circle", ({ "Guilds", "Witches' circle" }) }),
        ({ "/d/guilds/witches", ({ "Guilds", "Witches" }) }),
        ({ "/d/guilds", ({ "Guilds", "?" }) }),
        ({ "/d/admin/room/domain_control", ({ "Admin", "Domain control" }) }),
        ({ "/d/admin", ({ "Admin", "?" }) }),
        ({ "/d", ({ "Other", "Unknown /d room" }) }),
    });
    if( !environment(person) ) {
        return ({ "Other", "No environment" });
    }
    foreach( place in areas ) {
        if( strsrch( file_name(environment(person)), place[0] ) == 0 ) {
            return place[1];
        }
    }
    return ({ "Other", "Unknown environment" });
}
int get_guild_id(object person) {
    switch(person->query_guild_ob()) {
        case "/std/guilds/warrior":
            return 0;
        case "/std/guilds/assassin":
            return 1;
        case "/std/guilds/thief":
            return 2;
        case "/std/guilds/wizard":
            return 3;
        case "/std/guilds/priest":
            return 4;
        case "/std/guilds/witch":
            return 5;
        default:
            return 6;
    }
}
mapping get_dist( string filter, string arg ) {
    mapping ps;
    object *people, person;
    string *loc;
    int to_add;
    people = filter( users(), (: !$1->query_creator() &&
        $1->query_name() != "logon" :) );
    ps = ([ ]);
    foreach( person in people ) {
        loc = determine_location(person);
        if( !ps[loc[0]] ) {
            if( filter == "average" ) {
                ps[loc[0]] = ({ ([ ]), 0, ({ -1, 0, 0 }) });
            }
            else {
                ps[loc[0]] = ({ ([ ]), 0, 0 });
            }
        }
        ps[loc[0]][1]++;
        if( !ps[loc[0]][0][loc[1]] ) {
            if( filter == "average" ) {
                ps[loc[0]][0][loc[1]] = ({ 0, ({ -1, 0, 0 }) });
            }
            else {
                ps[loc[0]][0][loc[1]] = ({ 0, 0 });
            }
        }
        ps[loc[0]][0][loc[1]][0]++;
        switch(filter) {
            case "verbosity":
                if( person->query_verbose(arg) ) {
                    ps[loc[0]][2]++;
                    ps[loc[0]][0][loc[1]][1]++;
                }
                break;
            case "average":
                to_add = 0;
                if( arg == "guild level" ) {
                    to_add = person->query_level();
                }
                if( arg == "rating" ) {
                    to_add = (int)TOP_TEN_HANDLER->calculate_rating(person);
                }
                if( arg == "age" ) {
                    to_add = -person->query_time_on();
                }
                if( to_add < ps[loc[0]][2][0] || ps[loc[0]][2][0] == -1 ) {
                    ps[loc[0]][2][0] = to_add;
                }
                ps[loc[0]][2][1] += to_add;
                if( to_add > ps[loc[0]][2][2] ) {
                    ps[loc[0]][2][2] = to_add;
                }
                if( to_add < ps[loc[0]][0][loc[1]][1][0] ||
                    ps[loc[0]][0][loc[1]][1][0] == -1 ) {
                    ps[loc[0]][0][loc[1]][1][0] = to_add;
                }
                ps[loc[0]][0][loc[1]][1][1] += to_add;
                if( to_add > ps[loc[0]][0][loc[1]][1][2] ) {
                    ps[loc[0]][0][loc[1]][1][2] = to_add;
                }
                break;
            case "category":
                if( arg == "guild" ) {
                    if( !ps[loc[0]][2] ) {
                        ps[loc[0]][2] = ({0,0,0,0,0,0,0});
                    }
                    if( !ps[loc[0]][0][loc[1]][1] ) {
                        ps[loc[0]][0][loc[1]][1] = ({0,0,0,0,0,0,0});
                    }
                    to_add = get_guild_id(person);
                    ps[loc[0]][2][to_add]++;
                    ps[loc[0]][0][loc[1]][1][to_add]++;
                }
                break;
            default:
        }
    }
    return ps;
}
int cmd( string filter, string arg, int verbose ) {
    string place, zone, *guilds;
    mapping players, zones;
    int total, i, j;
    string tmp;
    string ret;
    ret = "";
    players = get_dist(filter,arg);
    total = sizeof(filter( users(), (: !$1->query_creator() &&
        $1->query_name() != "logon" :) ));
    guilds = ({ "Warriors", "Assassins", "Thieves", "Wizards", "Priests",
        "Witches", "Adventurers" });
    tmp = "\n";
    tmp+= sprintf( "%-27s", "Distribution of players:" );
    if( filter == "category" && arg == "guild" ) {
        j = (this_player()->query_cols() - 27) / (sizeof(guilds));
        for( i=0; i<sizeof(guilds); i++ ) {
            tmp += sprintf( "%" + j + ".3s", guilds[i] );
        }
    }
    if( filter == "average" ) {
        if( arg == "age" ) {
            j = (this_player()->query_cols() - 27);
            tmp += sprintf( "%-" + j + "s", "   Average age" );
        }
        else {
            j = (this_player()->query_cols() - 27) / 3;
            tmp += sprintf( "%" + j + "s", "Lowest" );
            tmp += sprintf( "%" + j + "s", "Average" );
            tmp += sprintf( "%" + j + "s", "Highest" );
        }
    }
    tmp += "\n\n";
    ret += tmp;
    foreach( place in keys(players) ) {
        tmp = "%^YELLOW%^";
        tmp+= sprintf( "%-24.24s", place );
        tmp+= sprintf( "%3.1i", players[place][1] );
        switch( filter ) {
            case "verbosity":
                tmp += players[place][2] + "/" +
                    players[place][1] + " verbose " + arg;
                break;
            case "average":
                if( arg == "age" ) {
                    tmp += sprintf( "%-"+ j +"s", "   " + query_time_string(
                        players[place][2][1] / players[place][1] ) );
                }
                else {
                    tmp += sprintf( "%"+ j +".1i", players[place][2][0] );
                    tmp += sprintf( "%"+ j +".1i", players[place][2][1] /
                        players[place][1] );
                    tmp += sprintf( "%"+ j +".1i", players[place][2][2] );
                }
                break;
            case "category":
                if( arg == "guild" ) {
                    for( i=0; i<sizeof(guilds); i++ ) {
                        tmp += sprintf( "%" + j + ".1i",
                            players[place][2][i] );
                    }
                }
                break;
            default:
                tmp += "   (";
                tmp += sprintf( "%3s",
                    ((100 * players[place][1]) / total + "%") );
                tmp += ")";
                break;
        }
        tmp += "%^RESET%^";
        tmp += "\n";
        ret += tmp;
        if (verbose) {
           zones = players[place][0];
           foreach( zone in keys( zones ) ) {
               tmp = sprintf( "%-24.24s", ("  - " + zone) );
               tmp+= sprintf( "%3.1i", zones[zone][0] );
               switch( filter ) {
                   case "verbosity":
                       tmp += " (" + zones[zone][1] + "/" + zones[zone][0] +
                           " verbose " + arg + ")";
                       break;
                   case "average":
                       if( arg == "age" ) {
                           tmp += sprintf( "%-"+ j +"s", "   " +
                               query_time_string( zones[zone][1][1] /
                               zones[zone][0] ) );
                       }
                       else {
                           tmp += sprintf( "%"+ j +".1i", zones[zone][1][0] );
                           tmp += sprintf( "%"+ j +".1i", zones[zone][1][1] /
                               zones[zone][0] );
                           tmp += sprintf( "%"+ j +".1i", zones[zone][1][2] );
                       }
                       break;
                   case "category":
                       if( arg == "guild" ) {
                           for( i=0; i<sizeof(guilds); i++ ) {
                               if( !zones[zone][1][i] ) {
                                   tmp += "%^BLACK%^";
                                   tmp += sprintf( "%" + j + ".1i",
                                        zones[zone][1][i] );
                                   tmp += "%^RESET%^";
                               }
                               else {
                                   tmp += sprintf( "%" + j + ".1i",
                                       zones[zone][1][i] );
                               }
                           }
                       }
                       break;
                   default:
                       tmp += "   (";
                       tmp += sprintf( "%3s",
                           ((100 * zones[zone][0]) / total + "%") );
                       tmp += ")";
                       break;
               }
               tmp += "\n";
               ret += tmp;
           }
        }
        if (verbose) {
           ret += "\n";
        }
    }
    ret += "Total = " + total + "\n";
    write("$P$Distribution$P$" + ret);
    return 1;
}
mixed *query_patterns() {
    return ({
        "by domain", (: cmd(0, 0, 0) :),
        "by guild level",  (: cmd("average", "guild level", 0) :),
        "by rating",  (: cmd("average", "rating", 0) :),
        "by age",  (: cmd("average", "age", 0) :),
        "by guild",  (: cmd("category", "guild", 0) :),
        "verbose by domain", (: cmd(0, 0, 1) :),
        "verbose by guild level",  (: cmd("average", "guild level", 1) :),
        "verbose by rating",  (: cmd("average", "rating", 1) :),
        "verbose by age",  (: cmd("average", "age", 1) :),
        "verbose by guild",  (: cmd("category", "guild", 1) :),
    });
}

==================================================
FILE: creator/random_name.c
==================================================

#include <random_names.h>
inherit "/cmds/base";
string lang_list;
void create() {
  lang_list = implode(RANDOM_NAME_GENERATOR->query_languages() +
                      RANDOM_NAME_GENERATOR->query_test_languages(), "|");
}
mixed cmd(string pattern, string my_lang) {
  string *langs;
  int i;
  if (pattern == "") {
    write("Generating one word from each language.  To generate more "
          "words in a particular language, specify the language on the "
          "command line.\n");
    langs = (string *)RANDOM_NAME_GENERATOR->query_languages() +
            RANDOM_NAME_GENERATOR->query_test_languages();
    for (i=0;i<sizeof(langs);i++) {
      write(capitalize(langs[i])+": "+
            (string)RANDOM_NAME_GENERATOR->random_name(langs[i])+"\n");
    }
    return 1;
  }
  write("Generateing 10 names in "+my_lang+"\n\n");
  for (i=0;i<10;i++) {
    write( (string)RANDOM_NAME_GENERATOR->random_name(my_lang)+"\n");
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "", (: cmd($5, "") :),
            "{"+lang_list+"}", (: cmd($5, $4[0]) :) });
}

==================================================
FILE: creator/rehash.c
==================================================

#include <armoury.h>
#define CMD_D "/secure/command"
mixed cmd(string str) {
  if (!str)
    return notify_fail("Syntax: rehash <path>\n");
  if (file_size(str) != -2)
    return notify_fail(str+": Path not found.\n");
  if (str[0..4] == "/doc/") {
     "/cmds/player/help"->rehash_specific_dir(str);
     write("Rehashed help dir: " + str + "\n");
     return 1;
  }
  if (str[0..4] == "/obj/" || str[0..2] == "/d/") {
     if (ARMOURY->rehash_specific_dir(str)) {
        write("Rehashed armoury dir: " + str + "\n");
        return 1;
     }
  }
  CMD_D->eventRehash(str);
  write(str+": Rehashed.\n");
  return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}

==================================================
FILE: creator/req_uest.c
==================================================

#include <housing.h>
inherit "/cmds/base";
#include <armoury.h>
int request(string item, int condition, string area) {
  object ob;
  ob = ARMOURY->request_item(item, condition, area);
  if(!ob)
    return notify_fail(item + " not found.\n");
  ob->move(this_player());
  this_player()->add_succeeded_mess(ob, "$N $V $D\n", ({ }));
  log_file ("REQUEST", "%s: %s requested %s.\n",
    ctime (time()), this_player()->query_name(), item);
  return 1;
}
int list(string type, string filter) {
  mapping stuff;
  stuff = ARMOURY->query_items(type, filter);
  if(!sizeof(stuff))
     return this_player()->add_failed_mess(this_object(),
                                           "No such list.\n", ({ }));
  printf("Available " + type +" objects are:\n%-*#s\n",
         (int)this_player()->query_cols(),
         implode(keys(stuff), "\n"));
  this_player()->add_succeeded_mess(this_object(), "", ({ }));
  return 1;
}
int path(string item, int condition, string area) {
  object ob;
  string res;
  ob = ARMOURY->request_item(item, condition, area);
  if(!ob)
    return notify_fail("");
  if (ob->query_property("virtual name")) {
    res = "Virtual file for " + ob->the_short() +
      ":\n   " + ob->query_property("virtual name") + "\n";
  } else {
    res = "Path of " + ob->the_short() + ":\n   " + base_name(ob) + "\n";
  }
  ob->move("/room/rubbish");
  this_player()->add_succeeded_mess(ob, res, ({ }));
  return 1;
}
mixed *query_patterns() {
  return ({ "list <word'" + implode(ARMOURY->query_types(), "|") + "'>",
              (: list($4[0], "") :),
"list <word'" + implode(ARMOURY->query_types(), "|") + "'> <string'filter'>",
              (: list($4[0], $4[1]) :),
              "<word'area'> <string'item'>", (: request($4[1], 100, $4[0]) :),
              "<word'area'> <string'item'> <number'condition'>", (: request($4
[1], $4[2], $4[0]) :),
              "<string'item'>", (: request($4[0], 100, "") :),
              "<string'item'> <number'condition'>", (: request($4[0], $4
[1], "") :),
              "path <string'item'>", (: path($4[0], 100, "") :),
              "path <word'area'> <string'item'>", (: path($4[1], 100, $4
[0]) :),
        });
}

==================================================
FILE: creator/rm.c
==================================================

inherit "/cmds/base";
mixed cmd(string str) {
  int fsize, loop;
  string *filenames;
  seteuid(geteuid(this_player()));
  if (!str) {
    notify_fail("Usage: rm file [file ...]\n");
    return 0;
  }
  filenames = this_player()->get_files(str);
  if (!sizeof(filenames)) {
    notify_fail("No such file : "+ str+"\n");
    return 0;
  }
  for (loop = 0; loop < sizeof(filenames); loop++) {
    str = filenames[loop];
    fsize = file_size(str);
    if (str[<2..] == "/." || str[<3..] == "/..")
      continue;
    if (fsize == -1) {
      notify_fail("No such file or directory.\n");
      return 0;
    }
    if (fsize == -2) {
      if (!rmdir(str)) {
        notify_fail("Couldn't rm directory: " + str + "\n");
        return 0;
      }
    } else if (!rm(str)) {
      notify_fail("Can't remove file.\n");
      return 0;
    }
  }
  write("Ok.\n");
  return 1;
}

==================================================
FILE: creator/rmd_ir.c
==================================================

mixed cmd(string str) {
   string *filenames;
   int fsize, loop;
   seteuid(geteuid(this_player()));
   if (!str || str == "") {
      notify_fail("Remove what dir?\n");
      return 0;
   }
   filenames = this_player()->get_files(str);
   if (!sizeof(filenames)) {
      notify_fail("No such directory : " + str + "\n");
      return 0;
   }
   for(loop = 0; loop < sizeof(filenames); loop++) {
      str = filenames[loop];
      fsize = file_size(str);
      if (fsize == -1) {
         notify_fail(str + " doesn't exist.\n");
         return 0;
      }
      if (fsize != -2) {
         notify_fail(str + " is not a directory.\n");
         return 0;
      }
      if (!rmdir(str)) {
         notify_fail("Couldn't remove dir : " + str + "\n");
         return 0;
      }
   }
   write("Ok.\n");
   return 1;
}
void dest_me() {
  destruct(this_object());
}
void clean_up() {
  dest_me();
}
void reset() {
  dest_me();
}
