# Total Tokens: 15513
# Total Files Merged: 15
# Total Characters: 51752

ise.c
==================================================

#include <volumes.h>
int cmd(object *things);
string query_length_mess(int number) {
    int half_feet;
    switch(number) {
        case 0:
            return "not very";
        case 1:
            return "an inch";
        case 2:
            return "a couple of inches";
        case 3:
            return "three inches";
        case 4:
            return "four inches";
        case 5..7:
            return "about six inches";
        case 8..10:
            return "about nine inches";
        case 11..14:
            return "about a foot";
        case 15..21:
            return "about a foot and a half";
        case 22..27:
            return "about two feet";
        case 28..33:
            return "about two and a half feet";
        default:
            half_feet = (number + 3)/6;
            if( half_feet%2 ) {
                return "about " + query_num(half_feet/2) + " and a half feet";
            }
            else {
                return "about " + query_num(half_feet/2) + " feet";
            }
    }
}
string query_dimensions_mess(object thing) {
    return "is " + query_length_mess(thing->query_length()) + " long and " +
        query_length_mess(thing->query_width()) + " wide.";
}
string query_appearance_mess(object thing) {
    string material_mess;
    if( !sizeof(thing->query_materials()) ) {
        material_mess = "some unidentifiable material";
    }
    else {
        material_mess = query_multiple_short(thing->query_materials());
    }
    if(thing->query_colour()) {
        return "is " + thing->query_colour() + " and is made of " +
            material_mess;
    }
    else {
        return "is made of " + material_mess;
    }
}
string query_type_mess(object thing) {
    if( thing->query_plant() ) {
        return "appears to be some sort of plant";
    }
    if( thing->query_food_object() ) {
        if( thing->query_liquid() ) {
            return "looks drinkable";
        }
        else {
            return "looks edible";
        }
    }
    if( thing->query_furniture() ) {
        return "could be placed as furniture";
    }
    if( thing->query_property("shop type") == "jewellers" ) {
        return "appears to be a piece of jewellery";
    }
    if( thing->query_weapon() ) {
        return "could be used as a weapon";
    }
    if( thing->query_armour() && thing->query_wearable()) {
        return "could be worn as armour";
    }
    if( thing->query_wearable() ) {
        return "looks like you could wear it";
    }
    if (thing->query_no_limbs() > 0) {
        return "looks like you could hold it";
    }
    return 0;
}
string query_container_mess(object thing) {
   int volume;
   int size;
   string str;
   volume = thing->query_max_volume();
   if (thing->query_container()) {
      size = thing->query_max_size();
   }
   if (size || volume) {
      str = "";
      if (size) {
         str += "can hold about " + (size / 9) + " pounds";
      }
      if (volume) {
         if (size) {
            str += " and ";
         }
         str += "can hold about ";
         if (volume > VOLUME_GALLON) {
            str += ((volume + VOLUME_GALLON / 2) / VOLUME_GALLON) + " gallons";
         } else if (volume >= VOLUME_QUART) {
            str += ((volume + VOLUME_QUART / 2) / VOLUME_QUART) + " quarts";
         } else if (volume >= VOLUME_PINT) {
            str += ((volume + VOLUME_PINT / 2) / VOLUME_PINT) + " pints";
         } else if (volume >= VOLUME_GILL) {
            str += ((volume + VOLUME_GILL / 2) / VOLUME_GILL) + " gills";
         } else if (volume >= VOLUME_SHOT) {
            str += ((volume + VOLUME_SHOT / 2) / VOLUME_SHOT) + " shots";
         } else {
            str += "nothing";
         }
      }
      return str;
   }
   return 0;
}
int cmd(object *things) {
    object thing;
    string mess;
    string tmp;
    if(!sizeof(things)) {
        add_failed_mess("For some reason, you "
            "have nothing to appraise.  Please bugrep this.\n", ({ }) );
        return 0;
    }
    if(sizeof(things) > 1) {
        add_failed_mess("You cannot appraise "
            "more than one object at once.\n", ({ }) );
        return 0;
    }
    if (thing == this_player()) {
        if (this_player()->query_name() == "penguin") {
           write("Is that a tuxuedo you are wearing?  No, probably not.\n");
        } else {
           write("You appraise yourself.  " + (random(10) + 1) + " out of 10.\n");
        }
        return 0;
    }
    thing = things[0];
    if(environment(thing) != this_player()) {
        add_failed_mess("You cannot appraise "
            "objects you are not carrying.\n", ({ }) );
        return 0;
    }
    if(living(thing)) {
        write("You appraise " + thing->the_short() + " and mmmm, very "
            "sexy.\n");
        return 1;
    }
    if(thing->query_worn_by()) {
        add_failed_mess("You cannot appraise "
            "$I while you are wearing it.\n", ({ thing }) );
        return 0;
    }
    if( !thing->query_clothing() ) {
        mess = thing->the_short() + " " + query_dimensions_mess(thing);
        mess += "  ";
    }
    else {
        mess = "";
    }
    tmp = query_type_mess(thing);
    if(tmp) {
        mess += "It " + query_appearance_mess(thing);
        mess += " and " + tmp + ".";
    }
    else {
        mess += "It " + query_appearance_mess(thing) + ".";
    }
    tmp = query_container_mess(thing);
    if (tmp) {
       mess += "  It " + tmp + ".";
    }
    if(thing->cond_string() && thing->cond_string() != "") {
        mess += "  " + thing->cond_string();
    }
    else {
        mess += "\n";
    }
    write("$P$Appraise$P$" + mess );
    add_succeeded_mess("");
    return 1;
}
mixed *query_patterns() {
    return ({ "<indirect:object:me-here'item'>", (: cmd($1) :) });
}

==================================================
FILE: player/arguments.c
==================================================

#include <philosophies.h>
inherit "/cmds/base";
int cmd() {
   string *args;
   args = PHILOSOPHY_HANDLER->query_all_known(this_player()->query_name());
   if (!sizeof(args)) {
      write("You do not know any theological arguments.\n");
   } else {
      write("You know the following theological arguments:\n" +
            query_multiple_short(args) + ".\n");
   }
   return 1;
}
mixed *query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/birthdays.c
==================================================

inherit "/cmds/base";
int cmd()  {
   object *peeps;
   peeps = filter(users(), (: $1->query_visible(this_player())  &&
                              $1->query_is_birthday_today() :));
   if (sizeof(peeps) == 0)
      return notify_fail("No one has a birthday today.\n");
   if (sizeof(peeps) == 1)
      printf("%s has a birthday today.\n", peeps[0]->short());
   else
      write(query_multiple_short(peeps) + " have a birthday today.\n");
   return 1;
}
mixed *query_patterns()  {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/brief.c
==================================================

inherit "/cmds/base";
#define TP this_player()
int cmd(string which, string type) {
  string t, disp;
  if(!type) {
    disp = "Your settings are: ";
    foreach(t in TP->query_verbose_types())
      disp += t + (TP->query_verbose(t) ? " (verbose) " : " (brief) ");
    write(disp + "\n");
  }
  else if(type == "all") {
    foreach(t in TP->query_verbose_types())
      TP->set_verbose(t, which == "verbose");
    write("Ok\n");
  } else if(member_array(type, TP->query_verbose_types()) != -1) {
    TP->set_verbose(type, which == "verbose");
    write("Ok\n");
  } else {
    write("No such option.\n");
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<word'type'>", (: cmd("brief", $4[0]) :),
            "", (: cmd("brief", 0) :),
         });
}

==================================================
FILE: player/bright.c
==================================================

inherit "/cmds/base";
#include <dirs.h>
#define THRESHOLDS ({ 10, 30, 200, 300 })
string illumination( int number ) {
   if ( number < 0 ) {
      return "in the darkness that lies beyond darkness";
   }
   if ( number < THRESHOLDS[ 0 ] ) {
      return "in pitch darkness";
   }
   if ( number < THRESHOLDS[ 1 ] ) {
      return "in near darkness";
   }
   if ( number > THRESHOLDS[ 3 ] ) {
      return "too brightly lit to see";
   }
   if ( number > THRESHOLDS[ 2 ] ) {
      return "too brightly lit to see clearly";
   }
   number = ( 100 * ( number - THRESHOLDS[ 1 ] ) ) /
      ( THRESHOLDS[ 2 ] - THRESHOLDS[ 1 ] );
   switch ( number ) {
   case 0 .. 5 :
      return "very poorly lit";
   case 6 .. 10 :
      return "poorly lit";
   case 11 .. 20 :
      return "dimly lit";
   case 21 .. 30 :
      return "quite well lit";
   case 31 .. 40 :
      return "well lit";
   case 41 .. 50 :
      return "brightly lit";
   default :
      return "very brightly lit";
   }
}
string intensity(int number, object thing) {
   int flag = (thing == this_player());
   if (number < 0) {
      return (flag?"are":"is") + " dark beyond darkness";
   }
   if (number < THRESHOLDS[0]) {
      return "produce" + (flag?"":"s") + " a faint light";
   }
   if ( number < THRESHOLDS[ 1 ] ) {
      return "produce" + (flag?"":"s") + " a bit of light";
   }
   if ( number > THRESHOLDS[ 3 ] ) {
      return (flag?"are":"is") + " so bright you can't bear to look";
   }
   if ( number > THRESHOLDS[ 2 ] ) {
      return (flag?"are":"is") + " so bright it hurts to look";
   }
   number = ( 100 * ( number - THRESHOLDS[ 1 ] ) ) /
      ( THRESHOLDS[ 2 ] - THRESHOLDS[ 1 ] );
   switch ( number ) {
   case 0 .. 24 :
      return "produce" + (flag?"":"s") + " quite a bit of light";
   case 25 .. 49 :
      return (flag?"are":"is") + " very bright";
   default :
      return (flag?"are":"is") + " extremely bright";
   }
}
int check_exists(string file) {
  int retval;
  if ( objectp( find_object( file ) ) )
    return 1;
  if (file_size(file+".c") > 0) {
    retval = 1;
  } else {
    retval = 0;
  }
  return retval;
}
mixed cmd(object *things) {
   int its_light;
   string results;
   string no_light_results;
   object thing;
   object* no_light;
   int result_light;
   results = "";
   if (environment(this_player())->query_light() < THRESHOLDS[0]) {
      results += "Wherever you are, it's ";
   } else {
      results += "$C$"+ environment(this_player())->the_short(1) + " is ";
   }
   results += illumination(environment(this_player())->query_light()) + ".\n";
   if (!things) {
      write(results);
      return 1;
   }
   no_light_results = "";
   no_light = ({ });
   foreach(thing in things) {
      its_light = (int)thing->query_light();
      if (its_light) {
        results += "$C$" + thing->the_short(1) + " " +
          intensity(its_light, thing) + ".\n";
        result_light = 1;
      } else {
         no_light += ({ thing });
      }
   }
   if (sizeof(no_light) && !result_light) {
      write("$C$" + query_multiple_short(no_light, "one", 0, 1) +
            ((sizeof(no_light) == 1  &&  no_light[0] != this_player()) ?
               " produces" : " produce") + " no light at all.\n");
   }
   write(results);
   return 1;
}
int cmd_exit(string arg) {
   object room;
   string other;
   room = environment(this_player());
   if (room->query_mirror_room()) {
      room = room->query_mirror_room();
   }
   if (LENGTHEN[arg]) {
      arg = LENGTHEN[arg];
   }
   if(!room->query_exit(arg)) {
     arg = (string)this_player()->find_abs(arg);
   }
   if ( room->query_exit( arg ) ) {
      other = room->query_destination(arg);
      if ( check_exists( other )) {
         object door;
         door = room->query_door_control(arg);
         if(room->query_door_open(arg) ||
            door->query_transparent()) {
            write(other->the_short(1) + " is " +
                       illumination(other->query_light()) + ".\n");
            return 1;
         } else {
            add_failed_mess("The exit " + arg + " is not open.\n");
            return 0;
         }
      } else {
         add_failed_mess("The exit " + arg + " does not exist.\n");
         return 0;
      }
   }
   add_failed_mess("Unable to find the exit " + arg + ".\n");
   return 0;
}
mixed *query_patterns() {
   return ({ "<indirect:object>", (: cmd($1) :),
             "exit <string'exit name'>", (: cmd_exit($4[0]) :),
             "", (: cmd(0) :) });
}

==================================================
FILE: player/bug.c
==================================================

inherit "/cmds/report_base";
void create() {
   ::create();
   set_error_type("BUG");
   set_use_last_error(1);
}

==================================================
FILE: player/bugcheck.c
==================================================

#define WEIRD_OBJECT_LOG "/log/secure/playtesters/bugcheck-weird-objects"
inherit "/cmds/base";
varargs int cmd(object *obs) {
    string* s;
    string txt;
    foreach ( object ob in obs ) {
        if ( stringp( ob->query_property( "virtual name" ) ) )
            s = explode( ob->query_property( "virtual name" ), "/" );
        else
            s = explode( base_name( ob ), "/" );
        switch ( s[ 0 ] ) {
        case "d":
            write(capitalize( ob->the_short() ) +
                         " is a domain thing.  It's probably safe to "
                         "bugrep it directly.\n" );
            break;
        case "w":
            write(capitalize( ob->the_short() ) +
                         "... why do you have a creator item?\n" );
            log_file ("ILLEGAL_OBJECT", "%s: %s tried to bugcheck %s.\n\n",
              ctime(time()), this_player()->query_name(), base_name (ob));
            break;
        case "std":
            write(capitalize( ob->the_short() ) +
                         " is a weird MUD library thing.  If you bugrep "
                         "it, the response might be slow.  It may be a "
                         "better idea to bugrep the room that the object "
                         "was found in.\n" );
            break;
        case "obj":
          switch (s[1]) {
            case "weapons":
            case "armours":
            case "clothes":
            case "food":
            case "jewellery":
              write(capitalize( ob->the_short() ) +
                         " is a Disc-wide item, but belongs to a directory "
                         "that is checked regularly.  Best to make the "
                         "bugrep directly on the item.\n" );
            break;
            default:
              write(capitalize( ob->the_short() ) +
                         " is a fairly general Disc-wide object.  If you "
                         "bugrep it, the response might be slow.  It would "
                         "most likely be a better idea to bugrep the room "
                         "in which the object was found.\n" );
            break;
          }
        break;
        case "global":
          switch (s[1]) {
            case "player":
            case "lord":
            case "playtester":
              if ( ob == this_player() ) {
                  txt = "are";
              }
              else {
                  txt = "is";
              }
              write(capitalize( ob->the_short() ) +
                         " " + txt + " the general " + s[1] + " object... if your "
                         "bugrep is on this, then bugrep this object.  If "
                         "your bugrep is along the frivolous lines of '"
                         + ob->the_short() +" " + txt + " overpowered!', "
                         "then don't "
                         "bugreport it... be sure and raise the issue on the "
                         "nearest bulletin board.\n" );
            break;
          }
        break;
        default:
            write("I've got no idea about " +
                         ob->the_short() + ".  Sorry it didn't work out.\n" );
            log_file( WEIRD_OBJECT_LOG, implode( s, "/" ) + "\n" );
            break;
        }
    }
    return 1;
}
int cmd_room() {
   write("Bug report the room for anything that seems to be odd in the room, "
         "descriptions being wrong, items you look at being wrong.  Anything "
         "odd you see that does not seem to fit anywhere else should also be "
         "reported to the room.\n");
   return 1;
}
mixed *query_patterns() {
   return ({ "<indirect:object:'thing'>", (: cmd($1) :),
             "here", (: cmd_room :)
    });
}

==================================================
FILE: player/bury.c
==================================================

#include <move_failures.h>
#include <cmds/bury.h>
#include <playtesters.h>
inherit "/cmds/base";
#define TP this_player()
#define GP_INCREMENT 10
#define MAX_BURY_NUMBER 20
mixed cmd(object *obs) {
   string person;
   mixed effs, *xp;
   string* messages;
   object ob, tmp;
   object *sobs;
   object *fobs;
   object *too_many;
   int gp;
#ifdef PT
   if (!PLAYTESTER_HAND->query_playtester(this_player()->query_name()) &&
       !this_player()->query_creator()) {
      add_failed_mess("This command is in play testing at the moment.\n");
      return 0;
   }
#endif
   sobs = ({ });
   fobs = ({ });
   too_many = ({ });
   if (TP->query_property("dead")) {
      add_failed_mess("You are a disembodied spirit, how do you expect to bury "
                      "anything at all?\n");
      return 0;
   }
   if(sizeof(filter_array(TP->query_attacker_list(),
                          (: environment($1) == environment(this_player()) :)))) {
      add_failed_mess("You cannot bury items while in combat.\n");
      return 0;
   }
   if(environment(TP)->query_property("no burial")) {
      add_failed_mess("You cannot bury things here.\n");
      return 0;
   }
   fobs = filter(obs, (: !is_in_me_or_environment($1, this_player()) :));
   obs -= fobs;
   foreach (ob in obs) {
      if (sizeof(sobs) >= MAX_BURY_NUMBER) {
         too_many += ({ ob });
      } else if ((ob->query_owner() == this_player()->query_cap_name()) ||
                 ((ob->get() == MOVE_OK) ||
                  (ob->get() == MOVE_TOO_HEAVY)) &&
                 (ob->query_property("no burial") != 1) &&
                 !ob->ok_to_bury(this_player())) {
        if (ob->query_property("player") != 1 ||
            ob->query_owner() == this_player()->query_name()) {
            effs = ob->effects_matching("mudlib.owned.weapon");
            if(sizeof(effs)) {
               person = ob->arg_of(effs[0]);
               log_file("BURIAL", "%s: %s's %s buried by %s\n", ctime(time()),
                        person, ob->query_short(), TP->query_name());
            }
            environment(this_player())->add_effect(BURY_EFFECT, ob);
            sobs += ({ ob });
            if (ob->query_property("corpse bit") ||
                ob->query_property("money")) {
               gp--;
            } else if(base_name(ob) == "/obj/corpse" &&
                      !ob->query_property("already buried")) {
               gp += GP_INCREMENT;
               ob->add_property("already buried", 1);
               xp = ob->query_property("XP");
               if(xp && sizeof(xp) == 2) {
                 foreach(tmp in xp[0]) {
                   if(tmp)
                     tmp->adjust_xp(xp[1], 1);
                 }
               }
               ob->remove_property("XP");
            }
         } else {
            fobs += ({ ob });
         }
      } else {
         fobs += ({ ob });
      }
   }
   if (!sizeof(sobs)) {
      if (sizeof(fobs)) {
         if (member_array(TP, fobs) == -1) {
            add_failed_mess("You cannot bury " +
                            query_multiple_short(fobs)+".\n");
            return 0;
         } else {
            add_failed_mess("You cannot bury " +
                            query_multiple_short(fobs - ({TP}) +
                                                 ({"yourself"}))+
                            ".\n");
            return 0;
         }
      } else {
         add_failed_mess("You cannot find anything here to bury!\n");
         return 0;
      }
   }
   if (sizeof(too_many)) {
      write("You can only bury up to " + MAX_BURY_NUMBER +
            " items at a time, not burying " +
            query_multiple_short(too_many) + ".\n");
   }
   messages = environment(TP)->query_burial_message();
   if (messages) {
      write(replace_string(messages[0], "$objs$", query_multiple_short(sobs)));
      say(replace(messages[1], ({ "$N", TP->the_short(), "$objs$", query_multiple_short(sobs) })));
   } else if (environment(TP)->query_property("location") != "outside") {
      write("You tidy up the place, clearing away "+
            query_multiple_short(sobs)+".\n");
      say( (string)this_player()->one_short() +
           " tidies up the place, clearing away "+
           query_multiple_short( sobs ) +".\n" );
   } else {
      write("You bury "+query_multiple_short(sobs)+" deep within the earth.\n");
      say( (string)this_player()->one_short() +
           " buries "+ query_multiple_short( sobs ) +
           " deep within the ground.\n" );
   }
   TP->adjust_gp(gp);
   return 1;
}
mixed *query_patterns() {
  return ({ "<indirect:object:here>", (: cmd($1) :),
            "",
            (: cmd(match_objects_for_existence("corpse", environment(TP))) :) });
}

==================================================
FILE: player/chfn.c
==================================================

inherit "/cmds/base";
#define TP this_player()
#define MAX_EMAIL_LEN 50
int cmd(string str) {
  write("Change finger information.\n");
  write("Pressing return at the prompts will take the default.  The default "
        "is the option in []'s.\n");
  write("What real name do you wish to use ["+TP->query_real_name()+"] ? ");
  input_to("real_name");
  return 1;
}
int real_name(string str) {
  string real_name;
  str = strip_colours(str);
  real_name = TP->query_real_name();
  if (str && str != "") {
    if (str == "none") {
      real_name = 0;
    } else {
      real_name = str;
    }
  }
  if (real_name && strlen(real_name) > MAX_EMAIL_LEN) {
    write("Real name is too long, a maximum of " + MAX_EMAIL_LEN + " characters is allowed.\n");
    write("What real name do you wish to use ["+TP->query_real_name()+"] ? ");
    input_to("real_name");
    return 1;
  }
  if (real_name && real_name != "") {
    write("Ok real name set to "+real_name+".\n");
  } else {
    write("Real name cleared.\n");
  }
  TP->set_real_name(real_name);
  write("Enter your location (ie Perth, oz, whatever) ["+
        TP->query_where()+"]\n(none for none) : ");
  input_to("get_where");
  return 1;
}
int get_where(string str) {
  string where;
  str = strip_colours(str);
  where = TP->query_where();
  if (str && str != "") {
    if (str == "none") {
      where = 0;
    } else {
      where = str;
    }
  }
  if (where && where != "") {
    write("Ok location set to "+where+".\n");
  } else {
    write("Location cleared.\n");
  }
  if (where && strlen(where) > MAX_EMAIL_LEN) {
     write("Your location is too long, maximum of " + MAX_EMAIL_LEN + " characters allowed.\n");
     write("Enter your location (ie Perth, oz, whatever) ["+
           TP->query_where()+"]\n(none for none) : ");
     input_to("get_where");
     return 1;
  }
  TP->set_where(where);
  if(TP->query_birthday() == "Unknown") {
    write("Enter your birthday (ddmm) ["+TP->query_birthday()+
          "] (none for none) : ");
    input_to("birthday");
  } else {
    write("What email address do you wish to use.  Set to none to clear.\n");
    write("Putting a : in front of it means that only the creators "
          "can read it.\n");
    write("["+TP->query_email()+"] : ");
    input_to("get_email");
  }
  return 1;
}
string convert_birthday(string str) {
#undef MONTHS
#define MONTHS ({ "January", "February", "March", "April", "May", "June", \
      "July", "August", "September", "October", "November", "December" })
  int day, month, tot;
  string retval;
  sscanf(str, "%d", tot);
  day = tot / 100;
  month = tot % 100;
  switch(day) {
    case 11:
      retval = "11th"; break;
    case 12:
      retval = "12th"; break;
    case 13:
      retval = "13th"; break;
    default:
      switch(day%10) {
        case 1:
          retval = day+"st"; break;
        case 2:
          retval = day+"nd"; break;
        case 3:
          retval = day+"rd"; break;
        default:
          retval = day+"th";
      }
  }
  return retval + " of " + MONTHS[month-1];
}
int valid_birthday(string str) {
#define LENGTHS ({ 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 })
  int tot, month, day;
  if(strlen(str) != 4) {
    return 0;
  }
  if(!sscanf(str, "%d", tot)) {
    return 0;
  }
  month = tot % 100;
  day = tot / 100;
  if(month > 12 || month < 1) {
    return 0;
  }
  if(day < 1) {
    return 0;
  }
  return day <= LENGTHS[month];
}
void birthday(string str) {
  string birth_day;
  birth_day = TP->query_birthday();
  if (str == "") {
    if (birth_day)
      write("Birthday unchanged from "+birth_day+".\n");
    else
      write("Birthday left as blank.\n");
  } else {
    if(birth_day != "Unknown") {
      write("You can't change when you were born! Please ask a Creator or "
        "a Lord to change it if you made an error.\n");
    } else if(!valid_birthday(str)) {
        write("Invalid Birthday.  Birthday cleared.\n");
        birth_day = 0;
    } else {
      birth_day = convert_birthday(str);
      write("Birthday set to " + birth_day + ".\n");
      TP->birthday_gifts();
    }
  }
  TP->set_birthday(birth_day);
  write("What email address do you wish to use.  Set to none to clear.\n");
  write("Putting a : in front of it means that only the creators and lords "
        "can read it.\n");
  write("["+TP->query_email()+"] : ");
  input_to("get_email");
}
void get_email(string str) {
  string email;
  email = TP->query_email();
  str = strip_colours(str);
  if (str == "") {
    if (!email || email == "") {
      write("Email address left blank.\n");
    } else {
      write("Email address left as "+email+".\n");
    }
  } else if (str == "none") {
    email = 0;
    write("Email address cleared.\n");
  } else {
    email = str;
    write("Email address set to "+email+".\n");
  }
  if (email && strlen(email) > MAX_EMAIL_LEN) {
    write("Your email address is too long, maximum of " + MAX_EMAIL_LEN + " characters allowed.\n");
    write("What email address do you wish to use.  Set to none to clear.\n");
    write("Putting a : in front of it means that only the creators and lords "
          "can read it.\n");
    write("["+TP->query_email()+"] : ");
    input_to("get_email");
    return ;
  }
  TP->set_email(email);
  write("Please enter your home page (World Wide Web page address), "
        "type 'none' to clear it.\n");
  if (!TP->query_homepage()) {
    write("[none] : ");
  } else {
    write("["+TP->query_homepage()+"] : ");
  }
  input_to("get_home_page");
}
void get_home_page(string str) {
  str = strip_colours(str);
  if (str == "") {
    if (!TP->query_homepage()) {
      write("Home page left as blank.\n");
    } else {
      write("Home page left as "+TP->query_homepage()+"\n");
    }
  } else if (str == "none") {
    TP->set_homepage("");
    write("Home page cleared.\n");
  } else if (strlen(str) <= MAX_EMAIL_LEN) {
    TP->set_homepage(str);
    write("Home page set to "+str+"\n");
  } else {
    write("Your home page address is too long, maximum of " + MAX_EMAIL_LEN + " characters allowed.\n");
    write("Please enter your home page (World Wide Web page address), "
          "type 'none' to clear it.\n");
    if (!TP->query_homepage()) {
      write("[none] : ");
    } else {
      write("["+TP->query_homepage()+"] : ");
    }
    input_to("get_home_page");
    return ;
  }
  TP->save_me();
}

==================================================
FILE: player/co_mmands.c
==================================================

inherit "/cmds/base";
int cmd( ) {
  string *cmds;
  write( "Your current commands are:\n"+ sprintf( "%-#*s\n",
         (int)this_player()->query_cols(), implode( sort_array(
         (string *)this_player()->query_known_commands(), 1 ),
         "\n" ) ) );
  if (this_player()->query_playtester()) {
    cmds = get_dir ("/cmds/playtester/");
    cmds = filter (cmds, (: strsrch ($1, ".c") == (sizeof ($1) - 2) :));
    write( "\n\nYour playtester commands are:\n"+ replace (sprintf( "%-#*s\n",
         (int)this_player()->query_cols(), implode( sort_array(
         (string *)cmds, 1 ),
         "\n" ) ), ({".c", ""})) );
  }
   return 1;
}
mixed* query_patterns() {
   return ({ "", (: cmd() :) });
}

==================================================
FILE: player/colo_urs.c
==================================================

#include <colour.h>
#include <clubs.h>
#include <creator.h>
#include <newbiehelpers.h>
inherit "cmds/base";
private string* _colours;
void create() {
  ::create();
  _colours = ({
   "BOLD",
   "FLASH",
   "BLACK",
   "RED",
   "BLUE",
   "CYAN",
   "MAGENTA",
   "ORANGE",
   "YELLOW",
   "GREEN",
   "WHITE",
   "B_RED",
   "B_ORANGE",
   "B_YELLOW",
   "B_BLACK",
   "B_CYAN",
   "B_WHITE",
   "B_GREEN",
   "B_MAGENTA" });
}
int is_valid_colour(string name) {
   if (member_array(name, _colours) != -1) {
      return 1;
   }
   return 0;
}
int show_allowed_colours() {
   write("The allowed colour codes are " +
         query_multiple_short(map(_colours, (: lower_case($1) :)), 0, 0, 1) +
         ".\n");
   return 1;
}
string* query_colour_list(int inform) {
  string* colour_list;
  string* clubs;
  string bing;
  switch (inform) {
  case 0:
    colour_list = USER_COLOUR_LIST;
    if( NEWBIEHELPERS_HANDLER->query_can_chat(this_player()) ) {
      colour_list += ({"newbiehelpers"});
    }
    if(this_player()->query_creator()) {
      colour_list += this_player()->channel_list();
    }
    break;
  case 1 :
    colour_list = this_player()->query_inform_types();
    break;
  case 2 :
    clubs = this_player()->query_player_clubs();
    clubs = filter(clubs, (: !CLUB_HANDLER->is_club($1) :));
    foreach (bing in clubs) {
       this_player()->remove_player_club(bing);
    }
    colour_list = map(this_player()->query_player_clubs(), (: "club_" + $1 :));
    break;
  }
  return colour_list;
}
mixed set_colours(int inform, string event_type, string colour, int force) {
  mapping my_colours;
  string *colour_list;
  string *bad;
  string tmp;
  string name;
  colour_list = query_colour_list(inform);
  if (inform == 2) {
    name = CLUB_HANDLER->query_club_name(event_type);
    event_type = "club_" + event_type;
  } else {
    name = lower_case(event_type);
  }
  if(member_array(event_type, colour_list) == -1) {
    return notify_fail("No such type.\n");
  }
  my_colours = this_player()->query_my_colours();
  if(colour == "default") {
    this_player()->set_my_colours(event_type, colour);
    write(name + " colour set to default.\n");
  } else if(colour == "none") {
    this_player()->set_my_colours(event_type, colour);
    write(name + " colour set to none.\n");
  } else {
    colour_list = map(explode(colour, " "),
                      (: upper_case($1) :));
    bad = filter(colour_list, (: !is_valid_colour($1) :));
    if (sizeof(bad) && !force) {
       if (sizeof(bad) > 1) {
          add_failed_mess("The colours " + query_multiple_short(bad) +
                          " are not valid, valid colours are: " +
                          query_multiple_short(_colours) + ".\n");
       } else {
          add_failed_mess("The colour " + query_multiple_short(bad) +
                          " is not valid, valid colours are: " +
                          query_multiple_short(_colours) + ".\n");
       }
       return 0;
    }
    tmp = "%^" + implode(colour_list, (: $1 + "%^ %^" + $2 :)) + "%^";
    this_player()->set_my_colours(event_type, tmp);
    write(name + " colour set to " + tmp + "[" + colour +
          "]%^RESET%^.\n");
  }
  return 1;
}
private int show_colours(int inform) {
  string *colour_list, event;
  mapping my_colours;
  string name;
  colour_list = query_colour_list(inform);
  my_colours = this_player()->query_my_colours();
  if (!inform) {
    write(sprintf("%-20s %s\n", "Clubs", "<list>"));
    write(sprintf("%-20s %s\n", "Inform", "<list>"));
  }
  foreach(event in colour_list) {
    if (inform == 2) {
       name = CLUB_HANDLER->query_club_name(event[5..]);
    } else {
       name = event;
    }
    if(my_colours[event]) {
      if(my_colours[event] != "") {
        write(sprintf("%-20s %s\n", name, my_colours[event] +
                      "[" + replace(my_colours[event], "%^", "") +
                      "]%^RESET%^"));
      } else {
        write(sprintf("%-20s %s\n", name, "[none]"));
      }
    } else {
      write(sprintf("%-20s %s\n", name, "[default]"));
    }
  }
  return 1;
}
mixed *query_patterns() {
  return ({ "<word'event type'> <string'colour'>",
              (: set_colours(0, $4[0], $4[1], 0) :),
            "force <word'event type'> <string'colour'>",
              (: set_colours(0, $4[0], $4[1], 1) :),
            "", (: show_colours(0) :),
            "inform <word'inform type'> <string'colour'>",
              (: set_colours(1, $4[0], $4[1], 0) :),
            "inform force <word'inform type'> <string'colour'>",
              (: set_colours(1, $4[0], $4[1], 1) :),
            "club <string:quoted'club name'> <string'colour'>",
              (: set_colours(2, $4[0], $4[1], 0) :),
            "club force <string:quoted'club name'> <string'colour'>",
              (: set_colours(2, $4[0], $4[1], 1) :),
            "inform", (: show_colours(1) :),
            "allowed", (: show_allowed_colours() :),
            "clubs", (: show_colours(2) :) });
}

==================================================
FILE: player/components.c
==================================================

#define OBJ 0
inherit "/cmds/base";
int cmd( string spell_name ) {
  mapping spells = this_player()->query_spells_nocase();
  string spell_ob;
  string *consumed, *needed;
  string mess;
  if( !sizeof( spells ) ) {
    add_failed_mess( "You don't know any magic spells.\n" );
    return 0;
  }
  spell_name = this_player()->expand_nickname( spell_name );
  spell_name = capitalize( spell_name );
  if( !spells[ lower_case(spell_name) ] ) {
    add_failed_mess( "You don't know a spell named " + spell_name +
        ".\n" );
    return 0;
  }
  spell_ob = spells[ lower_case(spell_name) ][ OBJ ];
  consumed = spell_ob->query_consumables();
  needed   = spell_ob->query_needed();
  if( !sizeof( consumed ) && !sizeof( needed ) ) {
    mess = "You don't need anything to cast " + spell_name;
  } else if( sizeof( consumed ) ) {
    mess = spell_name + " will consume " + query_multiple_short(
           consumed );
    if( sizeof( needed ) ) {
      mess += ".  It also requires " + query_multiple_short(
                 needed ) + " but will not consume " +
                 ( sizeof( needed ) > 1 ? "them" : "it" );
    }
  } else {
    mess = spell_name + " requires " + query_multiple_short( needed ) +
           " but will not consume " + ( sizeof ( needed ) > 1 ?
           "them" : "it" );
  }
  add_succeeded_mess( ({ mess + ".\n", "" }) );
  return 1;
}
mixed *query_patterns() {
  return ({ "[for] <string'spell'>", (: cmd( $4[0] ) :) });
}

==================================================
FILE: player/con_sider.c
==================================================

#define CREATOR "Ceres"
#include <weapon.h>
#include <cmr.h>
#include <player.h>
inherit "/cmds/base";
int calc_danger(object ob);
string do_compare(int dif);
mixed cmd(object *obs) {
  object ob;
  int level, ok, dif, total, them;
  string out;
  if(previous_object()->check_dark((int)environment(previous_object())->
    query_light()) < 0) {
     add_failed_mess("It's too dark to consider anyone.\n");
     return 0;
  }
  if(previous_object()->check_dark((int)environment(previous_object())->
    query_light()) > 0) {
     add_failed_mess("It's too bright to consider anyone.\n");
     return 0;
  }
  if (sizeof(obs) > 1) {
     obs -= ({ this_player() });
  }
  if (sizeof(obs) > 5) {
     add_failed_mess("You can only consider five things at once.\n");
     return 0;
  }
  if (this_player()->query_property("dead"))  {
    add_failed_mess( "You're dead.  You could just about kill a "
                        "conversation.\n" );
    return 0;
  }
  level = calc_danger(previous_object());
  foreach (ob in obs) {
    if (!living(ob)) {
       continue;
    }
    if (ob == previous_object()) {
       if (sizeof(obs) == 1) {
          write("You are exactly equal to yourself, you had better go and "
                "arm yourself with more spiky things and try to not arm "
                "your reflection at the same time.  No problems?\n");
          ok++;
       }
       continue;
    }
    ok++;
    them = calc_danger(ob);
    total += them;
    dif = ((level - them) * 100) / level;
    if ( userp( ob ) && this_player()->query_player_killer() &&
          !ob->query_player_killer() ) {
       out = replace( do_compare( dif ), "$who$", (string)ob->the_short() +
             " [not a killer]" );
    } else {
       out = replace( do_compare( dif ), "$who$", (string)ob->the_short() );
    }
    if (userp(ob)) {
       tell_object(ob, this_player()->the_short(1) + " looks you up and down "
                       "carefully checking out your weapons and armour.\n");
    } else {
       ob->event_npc_consider(this_player());
    }
    write( out +"\n" );
  }
  if(!ok) {
    add_failed_mess("You need to consider someone.\n");
    return 0;
  }
  return 1;
}
string do_compare(int dif) {
   string ret;
   int level;
   ret = "$C$$who$";
   level = PLAYER_DRUNK_EFFECT->query_drunk_level(this_player());
   if (level > 4) {
      if (level > 7) {
         return "%^BOLD%^%^GREEN%^Mate!  They looked at you wrong, you "
                "better sort them out before they get more cocky.%^RESET%^";
      }
      return "%^BOLD%^%^GREEN%^You reckon they would be an easy "
             "target.  Why bother with weapons?%^RESET%^";
   }
  if(dif > 320) {
    ret = "%^BOLD%^GREEN%^"+ret+" is too weak to bother attacking";
  } else {
    switch(dif) {
    case 161..320:
      ret = "%^BOLD%^%^GREEN%^"+ret+" is someone you look down on";
      break;
    case 81..160:
      ret = "%^GREEN%^"+ret+" would be an easy target";
      break;
    case 41..80:
      ret = "%^GREEN%^"+ret+" is a lot weaker than you";
      break;
    case 21..40:
      ret = "%^GREEN%^"+ret+" is weaker than you";
      break;
    case 11..20:
      ret = "%^CYAN%^"+ret+" is slightly weaker than you";
      break;
    case -10..10:
      ret = "%^CYAN%^"+ret+" is about equal with you";
      break;
    case -20..-11:
      ret = "%^CYAN%^"+ret+" is slightly tougher than you";
      break;
    case -40..-21:
      ret = "%^RED%^"+ret+" is tougher than you";
      break;
    case -80..-41:
      ret = "%^RED%^"+ret+" is a lot tougher than you";
      break;
    case -160..-81:
      ret = "%^RED%^"+ret+" looks pretty nasty";
      break;
    case -320..-161:
      ret = "%^BOLD%^%^RED%^"+ret+" is into the don't-even-think-about-it "
        "region";
      break;
    default:
      ret = "%^BOLD%^%^RED%^You would have to be utterly insane to attack "
        "$who$";
      break;
    }
   }
   return ret + ".%^RESET%^";
}
int calc_weapon_damage(object weapon) {
  mixed *data;
  int wdam, *damage, i;
  data = (mixed *)weapon->query_attack_data();
  if(sizeof(data)) {
    wdam = 0;
    for ( i = 0; i < sizeof( data ); i += W_ARRAY_SIZE ) {
      if (member_array( data[ i + W_TYPE ], ({ "blunt", "unarmed",
                                               "sharp", "pierce" }) ) == -1 )
        continue;
      damage = data[ i + W_DAMAGE ];
      wdam += ( data[ i + W_CHANCE ] * ( damage[ F_FIXED ] +
                        ( damage[ F_NUM ] * damage[ F_DIE ] ) / 2 ) ) / 100;
      wdam += damage[ F_FIXED ] + damage[ F_NUM ] * damage[ F_DIE ];
    }
  }
  return wdam;
}
int calc_value(mixed arr) {
  if (intp(arr))
    return arr;
  if (!pointerp(arr))
    return 0;
  if (sizeof(arr) == 1)
    return arr[F_FIXED];
  if (sizeof(arr) == 2)
    return arr[F_FIXED]+arr[F_NUM];
  return arr[F_FIXED]+(arr[F_NUM] * arr[F_DIE]);
}
int calc_armour_protection(object armour) {
  int ac, i;
  mapping data;
  mixed *stuff;
  if(!armour->query_armour())
    return 0;
  data = armour->query_armour_class();
  if(!sizeof(data))
     return 0;
  stuff = keys(data);
  for(i=0; i<sizeof(stuff); i++)
    ac += calc_value(data[stuff[i]][0]);
  return ac;
}
int calc_danger(object ob) {
   object weapon;
   object *weapons;
   object armour;
   object rider;
   int wdam;
   int wskill;
   int dskill;
   int ac;
   int hp;
   int trans;
   if (ob->query_transport()) {
      foreach (rider in ob->query_riders()) {
         trans += calc_danger(rider);
      }
   }
  weapons = ob->query_holding();
  if(weapons && sizeof(weapons) > 0 && (weapons[0] != 0) && (weapons[0]->
    query_weapon())) {
    weapon = weapons[0];
    dskill = ob->query_skill_bonus("fighting.combat.parry.melee");
  } else if(weapons && sizeof(weapons) > 1 && (weapons[1] != 0) &&
      (weapons[1]->query_weapon())) {
    weapon = weapons[1];
    dskill = ob->query_skill_bonus("fighting.combat.parry.melee");
  } else {
    weapon = ob;
    dskill = ob->query_skill_bonus("fighting.combat.parry.melee");
  }
  dskill += ob->query_skill_bonus("fighting.combat.dodging.melee");
  wdam = calc_weapon_damage(weapon);
  if(!sizeof(weapon->query_attack_data())) {
    wskill += ob->query_skill_bonus("fighting.combat.melee.unarmed");
    wskill += ob->query_skill_bonus("fighting.combat.special.unarmed") / 2;
  } else {
    wskill += ob->query_skill_bonus("fighting.combat.melee."+
              (string)weapon->query_attack_data()[W_SKILL]);
    wskill += ob->query_skill_bonus("fighting.combat.special.weapon") / 2;
  }
  wskill += ob->query_skill_bonus("fighting.combat.special.tactics");
  wskill += ob->query_specific_gp("fighting");
  hp = ob->query_hp();
  if(ob->query_wearing())
    foreach(armour in ob->query_wearing())
      if(armour)
        ac += calc_armour_protection(armour);
  wdam /= 3;
  hp /= 3;
  dskill /= 2;
  ac /= 6;
  return trans + wdam + wskill + dskill + ac + hp;
}
mixed* query_patterns() {
  return ({ "<indirect:living:here>", (: cmd($1) :) });
}

==================================================
FILE: player/cond_ition.c
==================================================

inherit "/cmds/base";
class cond_info {
   object cond_item;
   string cond_string;
   int cond_percent;
}
int compare(float, float);
string cond_colour(int percent)
{
   switch (100 - percent) {
   case 0..50:
      return "";
   case 51..60:
      return "%^CYAN%^";
   case 61..70:
      return "%^GREEN%^";
   case 71..80:
      return "%^YELLOW%^";
   case 81..90:
      return "%^RED%^";
   case 91..100:
      return "%^BOLD%^%^RED%^";
   }
}
int is_valid_environment(object ob) {
   object env;
   env = environment(ob);
   if (env == environment(this_player())) {
      return 1;
   }
   while (env) {
      if (env == this_player()) {
         return 1;
      }
      env = environment(env);
   }
   return 0;
}
int cmd(object *things, int dir, int no_excellent)
{
   int i;
   string list;
   object thing;
   class cond_info *info = ({ });
   class cond_info new_info;
   int dark;
   if (!this_player()->query_property("dead")) {
      dark =
         this_player()->check_dark(environment(this_player())->query_light());
   }
   if (dark == 2) {
      add_failed_mess("It is way too bright to see anything at all.\n");
      return 0;
   }
   if (dark == -2) {
      add_failed_mess("It is way too dark to see anything at all.\n");
      return 0;
   }
   things = filter(things, (: is_valid_environment :));
   if (!sizeof(things)) {
      add_failed_mess("Can only check the condition of things you "
                      "have in your inventory or on the ground.\n");
      return 0;
   }
   if (sizeof(things) == 1) {
      list = things[0]->cond_string();
      if (!list || list == "") {
         list = " has no condition.\n";
      } else {
         if (things[0]->query_is_pair())  list = list[4 .. ];
         else list = list[2..];
      }
      write("$C$" + things[0]->the_short() + list);
      return 1;
   }
   foreach(thing in things) {
      list = thing->cond_string();
      if (list && list != "") {
       if (thing->query_is_pair())  list = list[4 .. ];
       else list = list[2 .. ];
       info += ({ new (class cond_info,
                       cond_item: thing,
                       cond_string: list,
                       cond_percent:(thing->query_cond() * 100) /
                         thing-> query_max_cond()
                    )
            });
      }
   }
   if (!sizeof(info)) {
      add_failed_mess("None of those things has a condition.\n");
      return 0;
   } else if (sizeof(info) == 1) {
      write("$C$" + info[0]->cond_item->the_short() + info[0]->cond_string);
   } else {
      if (dir) {
         info = sort_array
            (info, (: $(dir) * compare($1->cond_percent, $2->cond_percent) :));
      }
      i = 0;
      foreach(new_info in info) {
         if (!no_excellent || new_info->cond_percent <= 90) {
            write(cond_colour(new_info->cond_percent) + "$C$" +
                  new_info->cond_item->the_short() + " (" + (i + 1) + ")" +
                  new_info->cond_string + "%^RESET%^");
            ++i;
         }
      }
      if (!i && no_excellent) {
         write("Everything is in excellent condition.\n");
      }
   }
   return 1;
}
mixed *query_patterns()
{
   return ({ "<indirect:object'item(s)'> sorting {up|down}",
             (: cmd($1, $4[1] == "up" ? 1 : -1, 0) :),
             "<indirect:object'item(s)'>",
             (: cmd($1, 0, 0) :),
             "<indirect:object'item(s)'> damaged",
             (: cmd($1, 0, 1) :),
             "<indirect:object'item(s)'> damaged sorting {up|down}",
             (: cmd($1, $4[1] == "up" ? 1 : -1, 1) :), });
}
int compare(float first, float second)
{
   if (first > second)
      return 1;
   if (first < second)
      return -1;
   return 0;
}

==================================================
FILE: player/count.c
==================================================

#include <money.h>
inherit "/cmds/base";
#define MAX_COUNT_SIZE 50
int is_not_in_other_player(object thing);
int cmd(object *things, int brief)  {
   string  list;
   string *aliases;
   string  message;
   mixed  *stuff;
   object  thing;
   object  money;
   object  sack;
   object *continuous, *collective;
   object *room_items;
   object *tmp;
   object tmp_ob;
   int     i;
   int     total;
   if (this_player()->
       check_dark(environment(this_player())->query_light()) < 0) {
      add_failed_mess("It's too dark to count anything.\n");
      return 0;
   }
   if(sizeof(things) > MAX_COUNT_SIZE)
     return add_failed_mess("You cannot count that many things!\n");
   things = filter(things, (: !is_not_in_other_player($1) :));
   if (!sizeof(things))  {
      write("You can't count things carried by other people.\n");
      return 1;
   }
   money = 0;
   total = 0;
   list = "";
   foreach (thing in things)  {
      aliases = thing->query_alias();
      if (aliases  &&  member_array(MONEY_ALIAS, aliases) > -1)  {
         if (!money) {
            money = clone_object(MONEY_OBJECT);
         }
         money->adjust_money(thing->query_money_array());
         things -= ({ thing });
      }
   }
   if (money)  {
      total += money->query_number_coins();
      if (sizeof(things))  {
         list = implode(money->half_short(1), ", ");
         if (sizeof(things) == 1) {
            list += " and ";
         } else {
            list += ", ";
         }
      } else {
         list = query_multiple_short(money->half_short(1));
      }
      money->dest_me();
   }
   continuous = filter(things, (: $1->query_continuous() :));
   if (sizeof(continuous))  {
      sack = clone_object("/std/container");
      foreach (thing in continuous) {
         thing->make_medium_clone(thing->query_amount())->move(sack);
      }
      things -= continuous;
      continuous = all_inventory(sack);
      foreach (thing in continuous)  {
         total += thing->query_how_many();
      }
      if (sizeof(things))  {
         list += implode(map(continuous,
                 (: $1->amount_size(1) + " of " + $1->short() :)), ", ");
         if (sizeof(things) == 1) {
            list += " and ";
         } else {
            list += ", ";
         }
      } else {
         list += query_multiple_short(map(continuous,
                 (: $1->amount_size(1) + " of " + $1->short() :)));
      }
      sack->dest_me();
   }
   collective = filter(things, (: $1->query_collective() :));
   if (sizeof(collective))  {
     sack = clone_object("/std/container");
     foreach (thing in collective) {
       if (thing) {
          tmp_ob = thing->make_medium_clone(thing->query_amount());
          if (tmp_ob) {
             tmp_ob->move(sack);
          }
       }
     }
     things -= collective;
     collective = all_inventory(sack);
     foreach (thing in collective) {
       total += thing->query_amount();
     }
     if(sizeof(things)) {
       list += implode(map(collective,
                           (: $1->query_amount() + " " +
                            ($1->query_amount() == 1 ? $1->short() :
                             $1->query_plural()) :)),
                       ", ");
       if (sizeof(things) == 1) {
         list += " and ";
       } else {
         list += ", ";
       }
     } else {
       list += query_multiple_short(map(collective,
                                        (: $1->query_amount() + " " +
                                         ($1->query_amount() == 1 ?
                                          $1->short() :
                                          $1->query_plural()) :)));
     }
     sack->dest_me();
   }
   room_items = filter(things, (: strsrch(file_name($1),
                                          "/std/room/basic/item") > -1 :));
   if (sizeof(room_items))  {
      things -= room_items;
      tmp = filter(room_items, (: $1->query_count() :));
      room_items -= tmp;
      if (sizeof(things))  {
         if (sizeof(tmp)) {
            list += implode(map(tmp, (: query_num($1->query_count()) +
                    " " + ($1->query_count() > 1 ? $1->pretty_plural()
                                                 : $1->pretty_short()) :)),
                    ", ");
            foreach (thing in tmp)  {
               total += thing->query_count();
            }
         }
         if (sizeof(room_items)) {
            list += implode(map(room_items, (: "at least one " +
                                               $1->pretty_short() :)), ", ");
            total += sizeof(room_items);
         }
         if (sizeof(things) == 1) {
            list += " and ";
         } else {
            list += ", ";
         }
      } else  {
         if (sizeof(tmp)) {
            list += query_multiple_short(map(tmp,
                    (: query_num($1->query_count()) + " " +
                    ($1->query_count() > 1 ? $1->pretty_plural()
                                           : $1->pretty_short()) :)), ", ");
            total += sizeof(tmp);
         }
         if (sizeof(room_items)) {
            list += query_multiple_short(map(room_items,
                    (: "at least one " + $1->pretty_short() :)));
            total += sizeof(room_items);
         }
      }
   }
   if (sizeof(things))  {
      list += query_multiple_short(things, "one");
if (this_player() == find_player("presto"))
tell_creator("presto", "list == %s\n", list);
      stuff = this_player()->reform_message(list, ({}));
if (this_player() == find_player("presto"))
printf("test message: %O\n", this_player()->evaluate_message(stuff));
      message = stuff[0];
      for (i = 0; i < sizeof(stuff[1]); i++)  {
         message = replace_string(message, "$" + i + "$",
            this_player()->calc_shorts(stuff[1][i], 1));
      }
      total += sizeof(things);
   } else {
      message = list;
   }
   if (brief) {
      write("You count " + total + " items.\n");
   } else {
      write("You count " + message + " with a total of " +
            query_num(total) + (total > 1 ? " items.\n" : " item.\n"));
   }
   return 1;
}
int is_not_in_other_player(object env)  {
   while ((env = environment(env))  &&  !living(env))
      ;
   if (env  &&  env != this_player())
      return 1;
   else
      return 0;
}
mixed *query_patterns()  {
   return ({ "<indirect:object:me-here'things [in <container>]'>",
             (: cmd($1, 0) :),
             "<indirect:object:me'things'> in inventory", (: cmd($1, 0) :),
             "<indirect:object:here'things'> in room", (: cmd($1, 0) :),
             "brief <indirect:object:me-here'things [in <container>]'>",
             (: cmd($1, 1) :),
             "brief <indirect:object:me'things'> in inventory", (: cmd($1, 1) :),
             "brief <indirect:object:here'things'> in room", (: cmd($1, 1) :) });
}
