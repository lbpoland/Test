# Total Tokens: 24606
# Total Files Merged: 12
# Total Characters: 82054

erit/error_handler.c
==================================================

#include <db.h>
#include <error_handler.h>
#define SAVE_FILE "/save/handlers/error_handler"
#define ERROR_SUMMARY_FIELDS "id, entrydate, filename, type, category, name, reporter, status, directory"
#define ERROR_DETAILS_FIELDS ERROR_SUMMARY_FIELDS \
                      ", report, runtime"
#define ERROR_REPLY_TIMEOUT (60 * 60 * 24 * 7 * 4)
void finish_update(int type, mixed data, function finished, string query);
private string _db;
private string _user;
private string _password;
void create() {
   unguarded( (: restore_object(SAVE_FILE) :) );
   DB_HANDLER->make_sql_request(_db, _user, _password,
                 "delete from error_replies where senddate < " +
                 (time() - ERROR_REPLY_TIMEOUT), (: 1 :));
}
protected void setup_error_handler(string user, string db, string password) {
   _user = user;
   _db = db;
   _password = password;
   save_object(SAVE_FILE);
}
protected string build_sql_query(string select_rows, class error_query query) {
   string* restrict;
   string name;
   string tmp;
   restrict = ({ });
   if (query->id != 0) {
      restrict += ({ "id = " + query->id });
   }
   if (query->dir) {
      if (query->dir[<1] == '/') {
         query->dir = query->dir[0..<2];
      }
      if (query->recursive) {
         restrict += ({ "directory like '" + query->dir + "%'" });
      } else {
         restrict += ({ "directory = '" + query->dir + "'" });
      }
   }
   if (query->assigned_to) {
      restrict += ({ "AssignedTo = '" + query->assigned_to + "'" });
   }
   if (query->reporter) {
      restrict += ({ "Reporter = '" + query->reporter + "'" });
   }
   if (query->file_name) {
      restrict += ({ "FileName = '" + query->file_name + "'" });
   }
   if (sizeof(query->type)) {
      tmp = "Type in (";
      foreach (name in query->type) {
         tmp += "'" + name + "',";
      }
      tmp = tmp[0..<2] + ")";
      restrict += ({ tmp });
   }
   if (sizeof(query->status)) {
      tmp = "Status in (";
      foreach (name in query->status) {
         tmp += "'" + name + "',";
      }
      tmp = tmp[0..<2] + ")";
      restrict += ({ tmp });
   }
   if (sizeof(query->category)) {
      tmp = "Category in (";
      foreach (name in query->category) {
         tmp += "'" + name + "',";
      }
      tmp = tmp[0..<2] + ")";
      restrict += ({ tmp });
   }
   if (sizeof(restrict)) {
      tmp = "select " + lower_case(select_rows) + " from errors where " +
             implode(restrict, " and ");
      switch (query->order_by) {
      case ERROR_ORDER_BY_FILENAME :
         tmp += " order by filename, entrydate";
         break;
      case ERROR_ORDER_BY_DATE :
         tmp += " order by entrydate";
         break;
      case ERROR_ORDER_BY_REPORTER :
         tmp += " order by reporter, entrydate";
         break;
      case ERROR_ORDER_BY_DIRECTORY :
      default :
         tmp += " order by directory, filename, entrydate";
         break;
      }
      return tmp + " limit 150";
   }
   return 0;
}
string build_sql_update(int id, string field, mixed value) {
   string ret;
   ret = "update errors set " + field + " = ";
   if (stringp(value)) {
      ret += "'" + value + "'";
   } else {
      ret += "" + value;
   }
   ret += " where id = " + id;
   return ret;
}
class error_forward create_error_forward(mapping map) {
   class error_forward newy;
   newy = new(class error_forward);
   newy->date = map["forwarddate"];
   newy->forwarder = map["forwarder"];
   newy->old_directory = map["olddirectory"];
   return newy;
}
class error_comment create_error_comment(mapping map) {
   class error_comment newy;
   newy = new(class error_comment);
   newy->date = map["commentdate"];
   newy->commenter = map["commenter"];
   newy->comment = map["comment"];
   return newy;
}
class error_summary create_error_summary(mapping map) {
   class error_summary newy;
   newy = new(class error_summary);
   newy->id = map["id"];
   newy->entry_date = map["entrydate"];
   newy->filename = map["filename"];
   newy->category = map["category"];
   newy->assigned_to = map["assignedto"];
   newy->reporter = map["reporter"];
   newy->status = map["status"];
   newy->type = map["type"];
   newy->directory = map["directory"];
   return newy;
}
class error_details create_error_details(mapping map) {
   class error_details newy;
   newy = new(class error_details);
   newy->summary = create_error_summary(map);
   newy->fix_date = map["fixdate"];
   newy->fixer = map["fixer"];
   newy->report = map["report"];
   newy->runtime = map["runtime"];
   return newy;
}
class error_complete create_error_complete(class error_details details) {
   class error_complete newy;
   newy = new(class error_complete);
   newy->details = details;
   newy->comments = ({ });
   newy->forwards = ({ });
   newy->replies = ({ });
   return newy;
}
class error_replies create_error_replies(mapping map) {
   class error_replies reply;
   reply = new(class error_replies);
   reply->id = map["id"];
   reply->bug_id = map["bug_id"];
   reply->sender = map["sender"];
   reply->status = map["status"];
   reply->recipient = map["recipient"];
   reply->senddate = map["senddate"];
   reply->subject = map["subject"];
   reply->message = map["message"];
   return reply;
}
void finish_summary(int type, mixed data, function finished, string query) {
   class error_summary* errors;
   mapping map;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data, query);
   } else {
      errors = ({ });
      foreach (map in data) {
         errors += ({ create_error_summary(map) });
      }
      evaluate(finished, type, errors, query);
   }
}
void finish_forwards(int type, mixed data, function finished,
                     class error_complete* errors, string query) {
   mapping map;
   class error_complete detail;
   if (type != DB_SUCCESS) {
      evaluate(finished, DB_SUCCESS, errors, query);
   } else {
      foreach (map in data) {
         foreach (detail in errors) {
            if (detail->details->summary->id == map["id"]) {
                 detail->forwards += ({ create_error_forward(map) });
            }
         }
      }
      evaluate(finished, type, errors, query);
   }
}
void finish_details_error_replies(int type, mixed data, function finished,
                     class error_complete* errors, string ids, string query) {
   mapping map;
   class error_complete detail;
   if (type != DB_SUCCESS) {
      evaluate(finished, DB_SUCCESS, errors, query);
   } else {
      foreach (map in data) {
         foreach (detail in errors) {
            if (detail->details->summary->id == map["bug_id"]) {
               detail->replies += ({ create_error_replies(map) });
            }
         }
      }
      DB_HANDLER->make_sql_request(_db, _user, _password,
                     "select id,forwarddate,forwarder,olddirectory from "
                     "forwards where id in " + ids +
                     " order by forwarddate",
                     (: finish_forwards($1, $2, $(finished), $(errors), $(query)) :));
   }
}
void finish_comments(int type, mixed data, function finished,
                     class error_complete* errors, string ids, string query) {
   mapping map;
   class error_complete detail;
   if (type != DB_SUCCESS) {
      evaluate(finished, DB_SUCCESS, errors, query);
   } else {
      foreach (map in data) {
         foreach (detail in errors) {
            if (detail->details->summary->id == map["id"]) {
                 detail->comments += ({ create_error_comment(map) });
            }
         }
      }
      DB_HANDLER->make_sql_request(_db, _user, _password,
                     "select * from "
                     "error_replies where bug_id in " + ids +
                     " order by senddate",
                     (: finish_details_error_replies($1, $2, $(finished), $(errors), $(ids), $(query)) :));
   }
}
void finish_details(int type, mixed data, function finished, string query) {
   class error_complete* errors;
   mapping map;
   string str;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data, query);
   } else {
      errors = ({ });
      str = "(";
      foreach (map in data) {
         errors += ({ create_error_complete(create_error_details(map)) });
         str += map["id"] + ",";
      }
      str = str[0..<2] + ")";
      DB_HANDLER->make_sql_request(_db, _user, _password,
                     "select commentdate,commenter,comment,id "
                     "from comments where id in " + str +
                     " order by commentdate desc",
                     (: finish_comments($1, $2, $(finished), $(errors), $(str), $(query)) :));
   }
}
void finish_forward_query(int type, mixed data, function finished,
                          string user, string newdir) {
   class error_complete error;
   mapping map;
   string str;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data);
   } else {
      map = data[0];
      error = create_error_complete(create_error_details(map));
      if (error->details->summary->directory != newdir) {
         str = "insert into forwards (id,forwarddate,forwarder,olddirectory) " +
               "values (" + error->details->summary->id + ", " + time() + ", '" +
               db_escape(user) + "', '" +
               db_escape(error->details->summary->directory) +
               "')";
         DB_HANDLER->make_sql_request(_db, _user, _password,
                     str, (: 1 :));
         str = build_sql_update(error->details->summary->id, "directory", newdir);
         DB_HANDLER->make_sql_request(_db, _user, _password, str,
                                 (: finish_update($1, $2, $(finished), $(str)) :));
      } else {
         evaluate(finished, type, data);
      }
   }
}
void finish_status_query(int type, mixed data, function finished,
                         string status,
                         int nomail, string user, string subject,
                         string message) {
   class error_complete error;
   mapping map;
   string str;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data);
   } else {
      map = data[0];
      error = create_error_complete(create_error_details(map));
      if (!nomail) {
         str = "insert into error_replies (bug_id,status,sender,recipient,senddate,message,subject) "
               "values (" +
               error->details->summary->id + ", 'NEW', '" + user + "', '" +
               error->details->summary->reporter + "', " +
               time() + ", '" +
               "Change status from " + error->details->summary->status +
               " to " + status +
               "\n" + db_escape(message) + "', '" + db_escape(subject) + "')";
         DB_HANDLER->make_sql_request(_db, _user, _password, str,
                 (: 1 :) );
      }
      str = build_sql_update(error->details->summary->id, "status", status);
      if (!str) {
         return 0;
      }
      DB_HANDLER->make_sql_request(_db, _user, _password, str,
                            (: finish_update($1, $2, $(finished), $(str)) :));
   }
}
void finish_update(int type, mixed data, function finished, string query) {
   evaluate(finished, type, data, query);
}
void finish_error_replies(int type, mixed data, function finished, string query) {
   class error_replies* replies;
   mapping map;
   if (type != DB_SUCCESS) {
      evaluate(finished, type, data);
   } else {
      replies = ({ });
      foreach (map in data) {
         replies += ({ create_error_replies(map) });
      }
      evaluate(finished, type, replies);
   }
}
int do_query_bug_summary(class error_query query, function finished) {
   string str;
   str = build_sql_query(ERROR_SUMMARY_FIELDS,
                         query);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                                   (: finish_summary($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_query_bug_details(int bug_id, function finished) {
   string str;
   class error_query query;
   query = new(class error_query);
   query->id = bug_id;
   str = build_sql_query(ERROR_DETAILS_FIELDS, query);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_details($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_query_open_bugs_in_dir(string dir, function finished) {
   class error_query query;
   query = new(class error_query);
   query->dir = dir;
   query->status = ({ "OPEN", "FIXING", "CONSIDERING" });
   return do_query_bug_summary(query, finished);
}
int do_query_open_bugs_for_fname(string fname, function finished) {
   class error_query query;
   query = new(class error_query);
   query->file_name = fname;
   query->status = ({ "OPEN", "FIXING", "CONSIDERING" });
   return do_query_bug_summary(query, finished);
}
int do_query_open_bugs_by_reporter(string reporter, function finished) {
   class error_query query;
   query = new(class error_query);
   query->reporter = reporter;
   query->status = ({ "OPEN", "FIXING", "CONSIDERING" });
   return do_query_bug_summary(query, finished);
}
int do_change_type(int id, string type, function finished) {
   string str;
   str = build_sql_update(id, "type", type);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_change_category(int id, string category, function finished) {
   string str;
   str = build_sql_update(id, "category", category);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_assign_bug_to(int id, string assigned_to, function finished) {
   string str;
   str = build_sql_update(id, "assignedto", assigned_to);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                               (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_change_status(int id, string status, int nomail, string subject,
                     string user, string message, function finished) {
   string str;
   class error_query query;
   query = new(class error_query, id : id);
   str = build_sql_query(ERROR_DETAILS_FIELDS, query);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
             (: finish_status_query($1, $2, $(finished), $(status),
                                    $(nomail), $(user), $(subject),
                                     $(message)) :));
   return 1;
}
int do_forward(int id, string user, string dir, function finished) {
   string str;
   class error_query query;
   if (!strlen(dir)) {
      return 0;
   }
   if (dir[0] != '/') {
      dir = "/" + dir;
   }
   if (dir[<1] == '/') {
      dir = dir[0..<2];
   }
   if (file_size(dir) != -2 || dir == "/") {
      return 0;
   }
   query = new(class error_query, id : id);
   str = build_sql_query(ERROR_DETAILS_FIELDS, query);
   if (!str) {
      return 0;
   }
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
             (: finish_forward_query($1, $2, $(finished), $(user), $(dir)) :));
   return 1;
}
int do_comment(int id, string user, string comment, function finished) {
   string str;
   str = "insert into comments (id,commentdate,commenter,comment) values (" +
         id + ", " + time() + ", '" + user + "', '" + db_escape(comment) +
         "')";
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                             (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_error_replies(string recipient, int only_new, function finished) {
   string str;
   str = "select * from error_replies where recipient = '" + recipient +
         "'";
   if (only_new) {
      str += " and status = 'NEW'";
   } else {
      str += " and status != 'DELETED'";
   }
   str += " order by senddate";
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                      (: finish_error_replies($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_status_error_reply(int id, string status, function finished) {
   string str;
   str = "update error_replies set status = '" + status + "' where id = " +
         id;
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
                      (: finish_update($1, $2, $(finished), $(str)) :));
   return 1;
}
int do_add_error_reply(int bug_id, string from, string to, string subject, string message) {
   string str;
   str = "insert into error_replies (bug_id,status,sender,recipient,senddate,message,subject) "
         "values (" + bug_id + ", 'NEW', '" + from + "', '" + to + "', " +
         time() + ", '" +
         db_escape(message) + "', '" + db_escape(subject) + "')";
   DB_HANDLER->make_sql_request(_db, _user, _password, str,
           (: 1 :) );
   return 1;
}

==================================================
FILE: handlers/inherit/nomic_rules.c
==================================================

#include <nomic_system.h>
private mapping _rules;
void save_me();
int query_can_change_rule(string area, class nomic_rule rule);
class nomic_rule find_nomic_rule(string area, string creator, string text);
void create() {
   _rules = ([ ]);
}
int add_nomic_rule(string area, int type, string creator, string text) {
   int bing;
   class nomic_rule nomic_rule;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   if (type < 0 || type >= sizeof(_rules[area]->new_type_num)) {
      return NOMIC_ERROR;
   }
   if (find_nomic_rule(area, creator, text)) {
      return NOMIC_ERROR;
   }
   nomic_rule = new(class nomic_rule);
   bing = _rules[area]->new_type_num[type];
   nomic_rule->id = bing;
   nomic_rule->creator = creator;
   nomic_rule->type = type;
   nomic_rule->text = text;
   nomic_rule->date_created = time();
   nomic_rule->amendments = ({ });
   _rules[area]->rules += ({ nomic_rule });
   _rules[area]->new_type_num[type] = bing + 1;
   save_me();
   return bing;
}
protected int add_nomic_rule_class(string area,
                                   class nomic_rule new_rule,
                                   int type) {
   int bing;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   if (type < 0 || type >= sizeof(_rules[area]->new_type_num)) {
      return NOMIC_ERROR;
   }
   if (find_nomic_rule(area, new_rule->creator, new_rule->text)) {
      return NOMIC_ERROR;
   }
   bing = _rules[area]->new_type_num[type];
   new_rule->id = bing;
   new_rule->type = type;
   _rules[area]->rules += ({ new_rule });
   _rules[area]->new_type_num[type] = bing + 1;
   save_me();
   return bing;
}
protected int move_nomic_rule(string area, class nomic_rule rule,
                              int type) {
   int bing;
   int i;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   if (type < 0 || type >= sizeof(_rules[area]->new_type_num)) {
      return NOMIC_ERROR;
   }
   bing = _rules[area]->new_type_num[type];
   for (i = 0; i < sizeof(_rules[area]->rules); i++) {
      if (_rules[area]->rules[i]->id == rule->id) {
         if (!query_can_change_rule(area, _rules[area]->rules[i])) {
            return NOMIC_ERROR;
         }
         _rules[area]->rules[i]->id = bing;
         ((class nomic_rule)_rules[area]->rules[i])->type = type;
         _rules[area]->new_type_num[type] = bing + 1;
         save_me();
         return bing;
      }
   }
   return NOMIC_ERROR;
}
int change_nomic_rule(string area, class nomic_rule rule) {
   int i;
   if (!_rules[area]) {
      return 0;
   }
   for (i = 0; i < sizeof(_rules[area]->rules); i++) {
      if (_rules[area]->rules[i]->id == rule->id) {
         if (!query_can_change_rule(area, _rules[area]->rules[i])) {
            return NOMIC_ERROR;
         }
         rule->type = ((class nomic_rule)_rules[area]->rules[i])->type;
         rule->id = ((class nomic_rule)_rules[area]->rules[i])->id;
         _rules[area]->rules[i] = rule;
         save_me();
         return 1;
      }
   }
   return 0;
}
int remove_nomic_rule(string area, int id) {
   class nomic_rule nomic_rule;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   foreach (nomic_rule in _rules[area]->rules) {
      if (nomic_rule->id == id) {
         if (!query_can_change_rule(area, nomic_rule)) {
            return NOMIC_ERROR;
         }
         _rules[area]->rules -= ({ nomic_rule });
         save_me();
         return 1;
      }
   }
   return 0;
}
int int_remove_nomic_rule(string area, int id) {
   class nomic_rule nomic_rule;
   if (!_rules[area]) {
      return NOMIC_ERROR;
   }
   foreach (nomic_rule in _rules[area]->rules) {
      if (nomic_rule->id == id) {
         _rules[area]->rules -= ({ nomic_rule });
         save_me();
         return 1;
      }
   }
   return 0;
}
class nomic_rule query_nomic_rule(string area, int id) {
   class nomic_rule nomic_rule;
   if (!_rules[area]) {
      return 0;
   }
   foreach (nomic_rule in _rules[area]->rules) {
      if (nomic_rule->id == id) {
         return copy(nomic_rule);
      }
   }
   return 0;
}
class nomic_rule* query_all_nomic_rules(string area) {
   if (!_rules[area]) {
      return ({ });
   }
   return copy(_rules[area]->rules);
}
class nomic_rule find_nomic_rule(string area, string creator, string text) {
   class nomic_rule rule;
   if (!_rules[area]) {
      return 0;
   }
   foreach (rule in _rules[area]->rules) {
      if (rule->creator == creator && rule->text == text) {
         return rule;
      }
   }
   return 0;
}
int create_area(string area) {
   class nomic_area new_area;
   if (_rules[area]) {
       return 0;
   }
   new_area = new(class nomic_area);
   new_area->new_type_num = NOMIC_DEFAULT_TYPE_NUMS;
   new_area->rules = ({ });
   _rules[area] = new_area;
   return 1;
}
int query_type_number(string name) {
   switch (lower_case(name)) {
   case "immutable" :
      return NOMIC_TYPE_IMMUTABLE;
   case "general" :
      return NOMIC_TYPE_GENERAL;
   case "citizen" :
      return NOMIC_TYPE_CITIZEN;
   default :
      return NOMIC_ERROR;
   }
}
string query_type_name(int type_no) {
   switch (type_no) {
   case NOMIC_TYPE_IMMUTABLE :
      return "immutable";
   case NOMIC_TYPE_GENERAL :
      return "general";
   case NOMIC_TYPE_CITIZEN :
      return "citizen";
   default :
      return "error";
   }
}
int query_can_change_rule(string area, class nomic_rule rule) {
   return rule->type != NOMIC_TYPE_IMMUTABLE;
}
string rule_as_string(int indent, class nomic_rule rule) {
   string ret;
   class nomic_amendment amend;
   ret = "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
          (rule->id?rule->id+"":"(" +
          NOMIC_HANDLER->query_type_name(rule->type) + ")") + " by " +
          capitalize(rule->creator) + " (" +
          ctime(rule->date_created) + "):\n" + rule->text +
          "\n";
   foreach (amend in rule->amendments) {
      ret += "$I$" + (indent + 10) + "=" + sprintf("%*s", indent + 3, "") +
             capitalize(amend->amender) + " (" +
             ctime(amend->date_amended) + "):\n" +
             amend->text + "\n";
   }
   return ret;
}

==================================================
FILE: handlers/inherit/player_council.c
==================================================

inherit "/obj/handlers/inherit/nomic_rules";
inherit "/obj/handlers/inherit/case_control";
inherit "/obj/handlers/inherit/citizen_elections";
#define NOMIC_SYSTEM_NO_CLASSES
#include <nomic_system.h>
#include <player.h>
private mapping _motions;
private mapping _new_citizens;
private int _completion_id;
void save_me();
class nomic_motion find_motion(string area, int rule_no, int type);
void update_immutables(string area);
void send_council_inform(string area, int only_magistrates,
                         string mess);
string motion_as_string(int indent, string area, class nomic_motion motion, int brief);
void create() {
   _motions = ([ ]);
   _new_citizens = ([ ]);
   citizen_elections::create();
   nomic_rules::create();
   case_control::create();
   _completion_id = call_out("check_for_completions",
       (time() - time() % (24 * 60 * 60) + (24 * 60 * 60) + (2 * 60)) - time());
}
void create_area(string area) {
   citizen_elections::create_area(area);
   nomic_rules::create_area(area);
   case_control::create_area(area);
   _motions[area] = ({ });
   _new_citizens[area] = ({ });
   update_immutables(area);
}
void update_immutables(string area) {
   string tmp;
   string type;
   string file;
   int int_type;
   class nomic_rule rule;
   foreach (rule in query_all_nomic_rules(area)) {
      if (rule->type == NOMIC_TYPE_IMMUTABLE) {
         remove_nomic_rule(area, rule->id);
      }
   }
   foreach (file in get_dir(NOMIC_RULE_DEFAULT_DIR)) {
      if (file_size(NOMIC_RULE_DEFAULT_DIR + "/" + file) > 0) {
         tmp = read_file(NOMIC_RULE_DEFAULT_DIR + "/" + file);
         type = explode(tmp, "\n")[0];
         tmp = implode(explode(tmp, "\n")[1..], "\n");
         switch (type) {
         case "immutable" :
            int_type = NOMIC_TYPE_IMMUTABLE;
            break;
         case "citizen" :
            int_type = NOMIC_TYPE_CITIZEN;
            break;
         case "general" :
            int_type = NOMIC_TYPE_GENERAL;
            break;
         default :
            int_type = -1;
            printf("Ignoring file " + file + "\n");
            break;
         }
         if (int_type != -1) {
            add_nomic_rule(area, int_type, area + " administrator", tmp);
         }
      }
   }
   save_me();
}
private int query_next_motion_id(string area) {
   int num;
   class nomic_motion fluff;
   num = 1;
   foreach (fluff in _motions[area]) {
      if (num <= fluff->identifier) {
         num = fluff->identifier + 1;
      }
   }
   return num;
}
int add_create_rule_motion(string area, int type, string text,
                          string creator) {
   class nomic_motion fluff;
   if (!is_magistrate_of(area, creator)) {
      return 0;
   }
   fluff = new(class nomic_motion);
   fluff->motion_type = NOMIC_MOTION_TYPE_RULE_ADD;
   fluff->rule = new(class nomic_rule);
   fluff->rule->creator = creator;
   fluff->rule->text = text;
   fluff->rule->type = type;
   fluff->rule->amendments = ({ });
   fluff->rule->date_created = time();
   fluff->comments = ({ });
   fluff->voted = ({ });
   fluff->state = NOMIC_STATE_COUNCIL_REVIEW;
   fluff->date_added = time();
   fluff->date_event = time();
   fluff->yes_votes = 0;
   fluff->no_votes = 0;
   fluff->added_by = creator;
   fluff->identifier = query_next_motion_id(area);
   _motions[area] += ({ fluff });
   save_me();
   send_council_inform(area, 1, creator + " added a new rule motion");
   post_magistrate_message(area, "New: Create rule motion",
              PLAYER_OB->convert_message(motion_as_string(0, area, fluff, 0)));
   return 1;
}
int add_move_rule_type_motion(string area, int rule_no, int type,
                              string creator) {
   class nomic_motion fluff;
   class nomic_rule bing;
   bing = query_nomic_rule(area, rule_no);
   if (!bing) {
      return 0;
   }
   if (bing->type == type) {
      return 0;
   }
   fluff = find_motion(area, rule_no, NOMIC_MOTION_TYPE_RULE_MOVE);
   if (fluff) {
      return 0;
   }
   fluff = new(class nomic_motion);
   fluff->motion_type = NOMIC_MOTION_TYPE_RULE_MOVE;
   fluff->rule = bing;
   fluff->new_rule_type = type;
   fluff->comments = ({ });
   fluff->voted = ({ });
   fluff->state = NOMIC_STATE_COUNCIL_REVIEW;
   fluff->date_added = time();
   fluff->date_event = time();
   fluff->yes_votes = 0;
   fluff->no_votes = 0;
   fluff->added_by = creator;
   fluff->identifier = query_next_motion_id(area);
   _motions[area] += ({ fluff });
   save_me();
   send_council_inform(area, 1, creator + " added a move rule motion");
   post_magistrate_message(area, "New: Move rule motion",
              PLAYER_OB->convert_message(motion_as_string(0, area, fluff, 0)));
   return 1;
}
int add_amend_rule_motion(string area, int rule_no, string amendment,
                           string creator) {
   class nomic_motion fluff;
   class nomic_rule bing;
   class nomic_amendment amend;
   bing = query_nomic_rule(area, rule_no);
   if (!bing) {
      return 0;
   }
   fluff = find_motion(area, rule_no, NOMIC_MOTION_TYPE_RULE_AMEND);
   if (fluff) {
      return 0;
   }
   fluff = new(class nomic_motion);
   fluff->motion_type = NOMIC_MOTION_TYPE_RULE_AMEND;
   amend = new (class nomic_amendment);
   amend->amender = creator;
   amend->text = amendment;
   amend->date_amended = time();
   bing->amendments += ({ amend });
   fluff->rule = bing;
   fluff->comments = ({ });
   fluff->voted = ({ });
   fluff->state = NOMIC_STATE_COUNCIL_REVIEW;
   fluff->date_added = time();
   fluff->date_event = time();
   fluff->yes_votes = 0;
   fluff->no_votes = 0;
   fluff->added_by = creator;
   fluff->identifier = query_next_motion_id(area);
   _motions[area] += ({ fluff });
   save_me();
   send_council_inform(area, 1, creator + " added an add rule motion");
   post_magistrate_message(area, "New: Ammend rule motion",
              PLAYER_OB->convert_message(motion_as_string(0, area, fluff, 0)));
   return 1;
}
int remove_rule_motion(string area, int rule_no, string creator) {
   class nomic_motion fluff;
   class nomic_rule bing;
   bing = query_nomic_rule(area, rule_no);
   if (!bing) {
      return 0;
   }
   fluff = find_motion(area, rule_no, NOMIC_MOTION_TYPE_RULE_REMOVE);
   if (fluff) {
      return 0;
   }
   fluff = new(class nomic_motion);
   fluff->motion_type = NOMIC_MOTION_TYPE_RULE_REMOVE;
   fluff->rule = bing;
   fluff->comments = ({ });
   fluff->voted = ({ });
   fluff->state = NOMIC_STATE_COUNCIL_REVIEW;
   fluff->date_added = time();
   fluff->date_event = time();
   fluff->yes_votes = 0;
   fluff->no_votes = 0;
   fluff->added_by = creator;
   fluff->identifier = query_next_motion_id(area);
   _motions[area] += ({ fluff });
   save_me();
   send_council_inform(area, 1, creator + " added a remove rule motion");
   post_magistrate_message(area, "New: Remove rule motion",
              PLAYER_OB->convert_message(motion_as_string(0, area, fluff, 0)));
   return 1;
}
class nomic_motion query_motion(string area, int id) {
   class nomic_motion fluff;
   if (!_motions[area]) {
      return 0;
   }
   foreach (fluff in _motions[area]) {
      if (fluff->identifier == id) {
         return fluff;
      }
   }
   return 0;
}
class nomic_motion* query_all_motions(string area) {
   if (!_motions[area]) {
      return ({ });
   }
   return copy(_motions[area]);
}
class nomic_motion find_motion(string area, int rule_no, int type) {
   class nomic_motion motion;
   foreach (motion in _motions[area]) {
      if (motion->rule->id == rule_no &&
          motion->motion_type == type) {
         return motion;
      }
   }
   return 0;
}
int comment_on_motion(string area, int id, string comment_text,
                            string commenter) {
   class nomic_comment comment;
   class nomic_motion bing;
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }
   if (bing->state != NOMIC_STATE_COUNCIL_REVIEW &&
       bing->state != NOMIC_STATE_COUNCIL_VOTE) {
      return 0;
   }
   comment = new(class nomic_comment);
   comment->text = comment_text;
   comment->commenter = commenter;
   comment->date_commented = time();
   bing->comments += ({ comment });
   save_me();
   return 1;
}
int amend_motion(string area, int id, string amend_text,
                    string amender) {
   class nomic_motion bing;
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }
   if (bing->state != NOMIC_STATE_COUNCIL_REVIEW) {
      return 0;
   }
   switch (bing->motion_type) {
   case NOMIC_MOTION_TYPE_RULE_ADD :
      bing->rule->text = amend_text;
      break;
   case NOMIC_MOTION_TYPE_RULE_REMOVE :
   case NOMIC_MOTION_TYPE_RULE_MOVE :
      return 0;
   case NOMIC_MOTION_TYPE_RULE_AMEND :
      bing->rule->amendments[<1]->text = amend_text;
   }
   save_me();
   return 1;
}
int vote_for_motion(string area, int id, int vote_type, string voter) {
   class nomic_motion bing;
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }
   if (member_array(voter, bing->voted) != -1) {
      return 0;
   }
   if (bing->state != NOMIC_STATE_COUNCIL_VOTE &&
       bing->state != NOMIC_STATE_CITIZEN_VOTE) {
      return 0;
   }
   switch (vote_type) {
   case NOMIC_VOTE_YES :
      bing->yes_votes++;
      break;
   case NOMIC_VOTE_NO :
      bing->no_votes++;
      break;
   case NOMIC_VOTE_ABSTAIN :
      bing->abstain_votes++;
      break;
   default :
      return 0;
   }
   bing->voted += ({ voter });
   save_me();
   return 1;
}
int has_voted_for_motion(string area, int id, string voter) {
   class nomic_motion bing;
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }
   return member_array(voter, bing->voted) != -1;
}
int* query_votes_for_motion(string area, int id) {
   class nomic_motion bing;
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }
   return ({ bing->yes_votes, bing->no_votes, bing->abstain_votes });
}
private void remove_motion(string area, class nomic_motion motion) {
   int i;
   for (i = 0; i < sizeof(_motions[area]); i++) {
      if (_motions[area][i] == motion) {
         _motions[area] = _motions[area][0..i-1] + _motions[area][i+1..];
      }
   }
}
void send_council_inform(string area, int only_magistrates,
                         string mess) {
   object *obs;
   if (only_magistrates) {
      obs = filter(users(), (: is_magistrate_of($2, $1->query_name()) :), area);
   } else {
      obs = filter(users(), (: is_citizen_of($2, $1->query_name()) :), area);
   }
   call_other(obs, "event_inform", this_object(), mess, "council");
}
int query_completion_time(string area, class nomic_motion motion) {
   return (motion->date_event - motion->date_event % (24 * 60 * 60) +
           7 * (24 * 60 * 60));
}
int complete_motion(string area, int id) {
   class nomic_motion bing;
   class nomic_motion motion;
   int passed;
   int new_num;
   string mess;
   int only_magistrates;
   string voting_result;
   bing = query_motion(area, id);
   if (!bing) {
      return 0;
   }
   passed = bing->yes_votes > bing->no_votes;
   voting_result = "Voting Results:\n"
                   "    Yes: " + bing->yes_votes + "\n"
                   "     No: " + bing->no_votes + "\n"
                   "Abstain: " + bing->abstain_votes + "\n";
   mess = "Motion added by " + bing->added_by + " to ";
   switch (bing->motion_type) {
   case NOMIC_MOTION_TYPE_RULE_ADD :
      mess += "add a new rule";
      break;
   case NOMIC_MOTION_TYPE_RULE_REMOVE :
      mess += "remove rule " + bing->rule->id;
      break;
   case NOMIC_MOTION_TYPE_RULE_MOVE :
      mess += "move rule " + bing->rule->id;
      break;
   case NOMIC_MOTION_TYPE_RULE_AMEND :
      mess += "amend rule " + bing->rule->id;
      break;
   }
   if (passed || bing->state == NOMIC_STATE_COUNCIL_REVIEW) {
      switch (bing->state) {
      case NOMIC_STATE_COUNCIL_REVIEW :
         bing->yes_votes = 0;
         bing->no_votes = 0;
         bing->abstain_votes = 0;
         bing->voted = ({ });
         bing->state = NOMIC_STATE_COUNCIL_VOTE;
         mess += " is open for magistrates to vote";
         only_magistrates = 1;
         post_magistrate_message(area, "Motion now in voting phase",
              PLAYER_OB->convert_message(motion_as_string(0, area, bing, 0)));
         break;
      case NOMIC_STATE_COUNCIL_VOTE :
         bing->yes_votes = 0;
         bing->no_votes = 0;
         bing->abstain_votes = 0;
         bing->voted = ({ });
         bing->state = NOMIC_STATE_CITIZEN_VOTE;
         bing->comments = ({ });
         mess += " is open for citizens to vote";
         post_magistrate_message(area, "Law passed onto citizens",
                    PLAYER_OB->convert_message(rule_as_string(0, bing->rule)) +
                              "\n\n" + voting_result);
         post_citizen_message(area, "New motion for voting on",
              PLAYER_OB->convert_message(motion_as_string(0, area, bing, 0)));
         break;
      case NOMIC_STATE_CITIZEN_VOTE :
         switch (bing->motion_type) {
         case NOMIC_MOTION_TYPE_RULE_ADD :
            add_nomic_rule_class(area, bing->rule, bing->motion_type);
            break;
         case NOMIC_MOTION_TYPE_RULE_AMEND :
            change_nomic_rule(area, bing->rule);
            break;
         case NOMIC_MOTION_TYPE_RULE_MOVE :
            new_num = move_nomic_rule(area, bing->rule, bing->new_rule_type);
            foreach (motion in _motions[area]) {
               if (motion->rule->id == bing->rule->id) {
                  motion->rule->id = new_num;
               }
            }
            break;
         case NOMIC_MOTION_TYPE_RULE_REMOVE :
            remove_nomic_rule(area, bing->rule->id);
            break;
         }
         remove_motion(area, bing);
         mess += " is now law";
         post_citizen_message(area, "New Law!",
                    PLAYER_OB->convert_message(rule_as_string(0, bing->rule)));
         post_magistrate_message(area, "New Law!",
                    PLAYER_OB->convert_message(rule_as_string(0, bing->rule)) +
                    "\n\n" + voting_result);
         break;
      }
      bing->date_event = time();
   } else {
      if (bing->state == NOMIC_STATE_COUNCIL_VOTE) {
         mess += " not passed by the magistrates";
         only_magistrates = 1;
         post_magistrate_message(area, "Law not passed onto citizens",
                              rule_as_string(0, bing->rule) + "\n\n" +
                              voting_result);
      } else {
         mess += " not ratified by the citizens";
         only_magistrates = 0;
         post_citizen_message(area, "Law not passed",
                              rule_as_string(0, bing->rule));
         post_magistrate_message(area, "Law not passed",
                              rule_as_string(0, bing->rule) + "\n\n" +
                              voting_result);
      }
      remove_motion(area, bing);
   }
   save_me();
   send_council_inform(area, only_magistrates, mess);
   return 1;
}
void check_for_completions() {
   string area;
   class nomic_motion* bits;
   class nomic_motion motion;
   foreach (area, bits in _motions) {
      foreach (motion in bits) {
         if (query_completion_time(area, motion) < time()) {
            complete_motion(area, motion->identifier);
         }
      }
   }
   remove_call_out(_completion_id);
   _completion_id = call_out("check_for_completions",
            (time() - time() % (24 * 60 * 60) + (24 * 60 * 60)) - time());
   update_recently_closed_cases();
}
string motion_as_string(int indent, string area, class nomic_motion motion,
                        int brief) {
   string ret;
   class nomic_comment comment;
   ret = "";
   switch (motion->motion_type) {
   case NOMIC_MOTION_TYPE_RULE_ADD :
      ret += "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
             motion->identifier + ") Add new rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_REMOVE :
      ret += "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
             motion->identifier + ") Remove rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_MOVE :
      ret += "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
             motion->identifier + ") Transmogrify rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_AMEND :
      ret += "$I$" + (indent + 5) + "=" + sprintf("%*s", indent, "") +
             motion->identifier + ") Amend rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "\n";
      break;
   }
   ret += rule_as_string(5 + indent, motion->rule);
   if (sizeof(motion->comments)) {
      if (!brief) {
         ret += "$I$" + (indent + 5) + "=     Comments:\n";
         foreach (comment in motion->comments) {
            ret += "$I$" + (indent + 11) + "=" + sprintf("%*s", indent + 3, "") +                capitalize(comment->commenter) + " (" +
                   ctime(comment->date_commented) + "):\n" +
                   comment->text + "\n";
         }
      } else {
         ret += "$I$0=" + sprintf("%*s", indent, "") + "     " +
                 sizeof(motion->comments) + " Comments.\n";
      }
   } else {
      ret += "$I$0=" + sprintf("%*s", indent, "") + "     No Comments.\n";
   }
   switch (motion->state) {
   case NOMIC_STATE_COUNCIL_REVIEW :
      ret += "$I$0=" + sprintf("%*s", indent, "") +
             "The item is currently being reviewed by the magistrates.\n";
      break;
   case NOMIC_STATE_COUNCIL_VOTE :
      ret += "$I$0=" + sprintf("%*s", indent, "") +
             "The item is currently being voted on by the magistrates.\n";
      break;
   case NOMIC_STATE_CITIZEN_VOTE :
      ret += "$I$0=" + sprintf("%*s", indent, "") +
             "The item is currently being ratified by the citizens.\n";
      break;
   }
   ret += "$I$0=" + sprintf("%*s", indent, "") +
          "The item will go onto the next stage at " +
          ctime(query_completion_time(area, motion)) +
          ".\n";
   return ret;
}
string rule_as_html(class nomic_rule rule) {
   string ret;
   class nomic_amendment amend;
   ret = "<i><b>" + (rule->id?rule->id+"":"(" +
          NOMIC_HANDLER->query_type_name(rule->type) + ")") + "</b> by " +
          capitalize(rule->creator) + " (" +
          ctime(rule->date_created) + "):</i>\n"
          "<p style=\"margin-left: 30pt;margin-top: 5pt\">\n" +
          replace_string(rule->text, "\n", "<br>") +
          "<br>\n";
   foreach (amend in rule->amendments) {
      ret += "<i><b>Ammendment</b> by " + capitalize(amend->amender) + " (" +
             ctime(amend->date_amended) + "):</i>\n"
             "<p style=\"margin-left: 60pt;margin-top: 5pt\">\n" +
             replace_string(amend->text, "\n", "<br>") +
             "\n</p>\n";
   }
   ret += "</p>\n";
   return ret;
}
string motion_as_html(string area, class nomic_motion motion) {
   string ret;
   class nomic_comment comment;
   ret = "";
   switch (motion->motion_type) {
   case NOMIC_MOTION_TYPE_RULE_ADD :
      ret += "<b>" + motion->identifier + ") Add new rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "</b>\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_REMOVE :
      ret += "<b>" + motion->identifier + ") Remove rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "</b>\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_MOVE :
      ret += "<b>" + motion->identifier + ") Transmogrify rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "</b>\n";
      break;
   case NOMIC_MOTION_TYPE_RULE_AMEND :
      ret += "<b>" + motion->identifier + ") Amend rule; added by " +
             capitalize(motion->added_by) + " at " +
             ctime(motion->date_added) + "</b>\n";
      break;
   }
   ret += "<ul>" + rule_as_html(motion->rule) + "</ul>";
   if (sizeof(motion->comments)) {
      ret += "<b>Comments:</b><br>\n";
      foreach (comment in motion->comments) {
         ret += ctime(comment->date_commented) + "):<br>\n" +
                comment->text + "<p>\n";
      }
   }
   switch (motion->state) {
   case NOMIC_STATE_COUNCIL_REVIEW :
      ret += "The item is currently being reviewed by the magistrates.\n";
      break;
   case NOMIC_STATE_COUNCIL_VOTE :
      ret += "The item is currently being voted on by the magistrates.\n";
      break;
   case NOMIC_STATE_CITIZEN_VOTE :
      ret += "The item is currently being ratified by the citizens.\n";
      break;
   }
   ret += "<br>The item will go onto the next stage at " +
          ctime(query_completion_time(area, motion)) +
          ".\n";
   return ret;
}

==================================================
FILE: handlers/terrain_things/dungeon_maker.c
==================================================

#include <dirs.h>
#include <terrain.h>
#define END 0
#define TWO 1
#define FOUR 2
#define ROOM 3
#define HALF 0
#define FULL 1
#define DIRS ({ "north", "northeast", "east", "southeast", \
      "south", "southwest", "west", "northwest" })
inherit "/std/object";
int max, size, *clear, *c_probs, *p_probs, *r_probs, *start;
string terrain_name, *passage_files, *room_files;
object easel;
mixed *passages, *room_entries;
void setup() {
   set_name( "box" );
   set_short( "green box" );
   add_adjective( "green" );
   set_long( "This is a green box.  It's quite featureless but, strangely "+
         "enough, something tells you it's a dungeon generator.\n" );
   reset_get();
   start = allocate( 3 );
   passages = ({ });
   room_entries = ({ });
}
void dest_me() {
   if ( easel )
      easel->dest_me();
   ::dest_me();
}
int query_max_locations() { return max; }
void set_max_locations( mixed arg ) { max = to_int( arg ); }
int *query_junction_clearance() { return clear; }
void set_junction_clearance( mixed *args ) {
   int i;
   clear = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      clear[ i ] = to_int( args[ i ] );
}
int *query_continue_probabilities() { return c_probs; }
void set_continue_probabilities( mixed *args ) {
   int i;
   c_probs = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      c_probs[ i ] = to_int( args[ i ] );
}
int *query_passage_probabilities() { return p_probs; }
void set_passage_probabilities( mixed *args ) {
   int i;
   p_probs = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      p_probs[ i ] = to_int( args[ i ] );
}
int *query_room_probabilities() { return r_probs; }
void set_room_probabilities( mixed *args ) {
   int i;
   r_probs = allocate( sizeof( args ) );
   for ( i = 0; i < sizeof( args ); i++ )
      r_probs[ i ] = to_int( args[ i ] );
}
int *query_start_co_ord() { return start; }
void set_start_co_ord( mixed *args ) {
   int i;
   if ( sizeof( args ) != 3 )
      return;
   for ( i = 0; i < sizeof( args ); i++ )
      start[ i ] = to_int( args[ i ] );
}
string query_terrain_name() { return terrain_name; }
void set_terrain_name( string word ) { terrain_name = word; }
string *query_passage_files() { return passage_files; }
void set_passage_files( string *words ) { passage_files = words; }
string *query_room_files() { return room_files; }
void set_room_files( string *words ) { room_files = words; }
object query_easel() { return easel; }
mixed *query_passages() { return passages; }
mixed *query_room_entries() { return room_entries; }
int do_generate(string);
void init() {
   add_command( "generate", "<word'terrainname'>", (:do_generate($4[0]):));
}
void mark_passage( int *co_ord ) {
   easel->add_shape( ({ ( co_ord[ 1 ] - start[ 1 ] ) / size,
         ( start[ 0 ] - co_ord[ 0 ] ) / size }), ({ "#" }) );
}
void mark_room( int *co_ord, string room ) {
   int width;
   width = (int)room->query_room_size();
   easel->add_shape( ({ ( co_ord[ 1 ] - start[ 1 ] - width - size / 2 ) / size,
         ( start[ 0 ] - co_ord[ 0 ] - width - size / 2 ) / size }),
         (string *)easel->make_block( ( 2 * width ) / size + 2 ) );
}
int do_generate( string word ) {
   int i;
   string data, direc, *lines;
   mixed *parameters;
   if ( easel )
      return notify_fail( "The generator is working on "+
            terrain_name +".\n" );
   if ( file_size( word ) < 0 )
      return notify_fail( "File "+ word +" does not exist.\n" );
   lines = explode( read_file( word ), "\n" );
   for ( i = 0; i < sizeof( lines ); i++ ) {
      if ( lines[ i ] == "" )
         continue;
       if ( lines[ i ][ 0 .. 0 ] == "#" )
         continue;
      parameters = explode( lines[ i ], " " );
      if ( !stringp( parameters[ 0 ] ) ) {
         printf( "%s line %d: %O is not a string.\n", word, i,
               parameters[ 0 ] );
         continue;
      }
      if ( sizeof( parameters ) == 2 )
         call_other( this_object(), "set_"+ parameters[ 0 ],
               parameters[ 1 ] );
      else
         call_other( this_object(), "set_"+ parameters[ 0 ],
               parameters[ 1 .. sizeof( parameters ) - 1 ] );
      printf( "Set %s to %O.\n", parameters[ 0 ], call_other( this_object(),
            "query_"+ parameters[ 0 ] ) );
   }
   if ( file_size( RESTORE_PATH + terrain_name +".o" ) > 0 )
      return notify_fail( "Terrain "+ terrain_name +" already exists.\n" );
   easel = clone_object( "/obj/misc/easel" );
   set_long( "This is a green box.  It's quite featureless but, strangely "+
         "enough, something tells you it's a dungeon generator.\nIt seems "+
         "to be humming quietly but in a very powerful way.\n" );
   write( "Working on "+ terrain_name +".\n" );
   direc = DIRS[ random( 8 ) ];
   for ( i = 0; i < 4; i++ )
      passages += ({ ({ DIRS[ ( member_array( direc, DIRS ) + 2 * i ) % 8 ],
            passage_files[ random( sizeof( passage_files ) ) ],
            start, 0, 0, 1 + clear[ 0 ] + random( clear[ 1 ] ) }) });
   size = 2 * (int)passage_files[ 0 ]->query_room_size();
   TERRAIN_MAP->add_floating_location( terrain_name, passage_files[ 0 ],
         start, 0 );
   call_out( "process_passages", 2 );
   return 1;
}
void stop_working() {
   tell_room( environment(), "The box stops humming as it extrudes an "+
         "easel from a slot in one side.\n" );
   easel->add_shape( ({ 0, 0 }), ({ "@" }) );
   write_file( "/open/"+ terrain_name +".map",
         implode( (string *)easel->query_lines(), "\n" ) );
   easel->move( environment() );
   easel = 0;
   passages = ({ });
   room_entries = ({ });
   set_long( "This is a green box.  It's quite featureless but, strangely "+
         "enough, something tells you it's a dungeon generator.\n" );
}
int *shift_in( int *co_ord, string direc, string from, string to ) {
   int i, delta, *new_co_ord, *vector;
   delta = (int)from->query_room_size() + (int)to->query_room_size();
   new_co_ord = allocate( 3 );
   vector = STD_ORDERS[ member_array( direc, STD_ORDERS ) + 1 ];
   for ( i = 0; i < 3; i++ )
      new_co_ord[ i ] = co_ord[ i ] - delta * vector[ i ];
   return new_co_ord;
}
void process_passages() {
   int i, j, k, prob, straight, *co_ord, *new_co_ord;
   string direc, new_direc, type, new_type;
   mixed *last;
   if ( !sizeof( passages ) ) {
      tell_room( environment(), "No passages to process.\n" );
      return stop_working();
   }
   if ( max < 1 ) {
      tell_room( environment(), "Reached maximum.\n" );
      return stop_working();
   }
   max--;
   direc = passages[ 0 ][ 0 ];
   type = passages[ 0 ][ 1 ];
   co_ord = passages[ 0 ][ 2 ];
   last = passages[ 0 ][ 3 .. 4 ];
   straight = passages[ 0 ][ 5 ];
   passages = delete( passages, 0, 1 );
   call_out( "process_passages", 2 );
   for ( i = 0; i < 3; i++ ) {
      new_direc = DIRS[ ( member_array( direc, DIRS ) + 7 + i ) % 8 ];
      new_co_ord = shift_in( co_ord, new_direc, type, type );
      if ( sizeof( (mixed *)TERRAIN_MAP->
            member_floating_locations( new_co_ord ) ) ) {
         tell_room( environment(), "Passage already at "+ new_co_ord[ 0 ] +
               ", "+ new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +"; ending "+
               "passage at "+ co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+
               co_ord[ 2 ] +".\n" );
         return;
      }
      for ( j = 0; j < sizeof( room_entries ); j++ ) {
         for ( k = 0; k < 3; k++ )
            if ( new_co_ord[ k ] != room_entries[ j ][ k ] )
               break;
         if ( k < 3 )
            continue;
         tell_room( environment(), "Room entry at "+ new_co_ord[ 0 ] +
               ", "+ new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +"; "+
               "joining passage at "+ co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+
               co_ord[ 2 ] +".\n" );
         TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord,
               0 );
         mark_passage( new_co_ord );
         room_entries = delete( room_entries, j, 1 );
         return;
      }
      if ( (int)easel->query_at( ({ ( new_co_ord[ 1 ] - start[ 1 ] ) / size,
            ( start[ 0 ] - new_co_ord[ 0 ] ) / size }) ) != 32 ) {
         tell_room( environment(), "Something at "+ new_co_ord[ 0 ] +
               ", "+ new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +"; ending "+
               "passage at "+ co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+
               co_ord[ 2 ] +".\n" );
         return;
      }
   }
   prob = random( 100 );
   if ( prob < p_probs[ END ] ) {
      tell_room( environment(), "Passage going "+ direc +" ends at "+
            co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
      return;
   }
   prob -= p_probs[ END ];
   if ( ( prob < p_probs[ TWO ] ) && !straight ) {
      if ( random( 100 ) >= c_probs[ HALF ] + c_probs[ FULL ] ) {
         tell_room( environment(), "Passage branching "+ direc +" and " );
         new_co_ord = shift_in( co_ord, direc, type, type );
         TERRAIN_MAP->add_floating_location( terrain_name, type,
               new_co_ord, 0 );
         passages += ({ ({ direc, type, new_co_ord, co_ord, last[ 0 ],
               clear[ 0 ] + random( clear[ 1 ] ) }) });
         mark_passage( new_co_ord );
         if ( random( c_probs[ HALF ] + c_probs[ FULL ] ) < c_probs[ HALF ] )
            direc = DIRS[ ( member_array( direc, DIRS ) + 1 +
                  6 * random( 2 ) ) % 8 ];
         else
            direc = DIRS[ ( member_array( direc, DIRS ) + 2 +
                  4 * random( 2 ) ) % 8 ];
         type = passage_files[ random( sizeof( passage_files ) ) ];
         new_co_ord = shift_in( co_ord, direc, type, type );
         TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord,
               0 );
         passages += ({ ({ direc, type, new_co_ord, co_ord, last[ 0 ],
               clear[ 0 ] + random( clear[ 1 ] ) }) });
         mark_passage( new_co_ord );
         tell_room( environment(), direc +" from "+
               co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
         return;
      }
      if ( random( c_probs[ HALF ] + c_probs[ FULL ] ) < c_probs[ HALF ] )
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 1 ) % 8 ];
      else
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 2 ) % 8 ];
      type = passage_files[ random( sizeof( passage_files ) ) ];
      new_co_ord = shift_in( co_ord, new_direc, type, type );
      TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord, 0 );
      passages += ({ ({ new_direc, type, new_co_ord, co_ord, last[ 0 ],
            clear[ 0 ] + random( clear[ 1 ] ) }) });
      mark_passage( new_co_ord );
      tell_room( environment(), "Passage branching "+ new_direc +" and " );
      if ( random( c_probs[ HALF ] + c_probs[ FULL ] ) < c_probs[ HALF ] )
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 7 ) % 8 ];
      else
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 6 ) % 8 ];
      type = passage_files[ random( sizeof( passage_files ) ) ];
      new_co_ord = shift_in( co_ord, new_direc, type, type );
      TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord, 0 );
      passages += ({ ({ new_direc, type, new_co_ord, co_ord, last[ 0 ],
            clear[ 0 ] + random( clear[ 1 ] ) }) });
      mark_passage( new_co_ord );
      tell_room( environment(), new_direc +" from "+
            co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
      return;
   }
   prob -= p_probs[ TWO ];
   if ( ( prob < p_probs[ FOUR ] ) && !straight ) {
      tell_room( environment(), "Crossroads from "+ direc +" at "+
            co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
      for ( i = 0; i < 3; i++ ) {
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 6 + 2 * i ) % 8 ];
         type = passage_files[ random( sizeof( passage_files ) ) ];
         new_co_ord = shift_in( co_ord, new_direc, type, type );
         TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord,
               0 );
         passages += ({ ({ new_direc, type, new_co_ord, co_ord, last[ 0 ],
               clear[ 0 ] + random( clear[ 1 ] ) }) });
         mark_passage( new_co_ord );
      }
      return;
   }
   prob -= p_probs[ FOUR ];
   if ( ( prob < p_probs[ ROOM ] ) && !straight ) {
      prob = random( 100 );
      new_type = room_files[ 0 ];
      for ( i = 1; i < sizeof( room_files ); i++ )
         if ( prob < r_probs[ FULL + i ] ) {
            new_type = room_files[ i ];
            break;
         } else
            prob -= r_probs[ FULL + i ];
      new_co_ord = shift_in( co_ord, direc, type, new_type );
      tell_room( environment(), "Room at "+ new_co_ord[ 0 ] +", "+
            new_co_ord[ 1 ] +", "+ new_co_ord[ 2 ] +".\n" );
      TERRAIN_MAP->add_floating_location( terrain_name, new_type,
            new_co_ord, 0 );
      mark_room( new_co_ord, new_type );
      mark_passage( co_ord );
      for ( i = 1; i < 8; i++ ) {
         new_direc = DIRS[ ( member_array( direc, DIRS ) + 4 + i ) % 8 ];
         type = passage_files[ random( sizeof( passage_files ) ) ];
         co_ord = shift_in( new_co_ord, new_direc, new_type, type );
         if ( i % 2 ) {
            if ( random( 100 ) < r_probs[ HALF ] ) {
               tell_room( environment(), "Passage leaving room to "+
                     new_direc +".\n" );
               TERRAIN_MAP->add_floating_location( terrain_name, type, co_ord,
                     0 );
               passages += ({ ({ new_direc, type, co_ord, new_co_ord,
                     last[ 0 ], clear[ 0 ] + random( clear[ 1 ] ) }) });
               mark_passage( co_ord );
            } else
               room_entries += ({ co_ord });
         } else {
            if ( random( 100 ) < r_probs[ FULL ] ) {
               tell_room( environment(), "Passage leaving room to "+
                     new_direc +".\n" );
               TERRAIN_MAP->add_floating_location( terrain_name, type, co_ord,
                     0 );
               passages += ({ ({ new_direc, type, co_ord, new_co_ord,
                     last[ 0 ], clear[ 0 ] + random( clear[ 1 ] ) }) });
               mark_passage( co_ord );
            } else
               room_entries += ({ co_ord });
         }
      }
      return;
   }
   prob = random( 100 );
   if ( ( prob < c_probs[ HALF ] ) && !straight ) {
      direc = DIRS[ ( member_array( direc, DIRS ) + 1 +
             6 * random( 2 ) ) % 8 ];
      straight = clear[ 0 ] + random( clear[ 1 ] );
   } else {
      prob -=  c_probs[ HALF ];
      if ( ( prob < c_probs[ FULL ] ) && !straight ) {
         direc = DIRS[ ( member_array( direc, DIRS ) + 2 +
               4 * random( 2 ) ) % 8 ];
         straight = clear[ 0 ] + random( clear[ 1 ] );
      }
   }
   if ( straight > 0 )
      straight--;
   new_co_ord = shift_in( co_ord, direc, type, type );
   tell_room( environment(), "Passage goes "+ direc +" from "+
         co_ord[ 0 ] +", "+ co_ord[ 1 ] +", "+ co_ord[ 2 ] +".\n" );
   TERRAIN_MAP->add_floating_location( terrain_name, type, new_co_ord, 0 );
   passages += ({ ({ direc, type, new_co_ord, co_ord, last[ 0 ],
         straight }) });
   mark_passage( new_co_ord );
}

==================================================
FILE: handlers/terrain_things/logroom.c
==================================================

#include <terrain.h>
#define SAVE_FILE RESTORE_PATH +"logroom"
inherit "/std/room";
mapping locations;
void setup() {
   set_short( "limbo" );
   set_light( 50 );
   set_long( "You are between worlds, surrounded by raw potentiality and "+
         "not a lot else.\n" );
   add_item( "potentiality", "Well, it's sort of potentially something and "+
         "potentially nothing, and it can't quite decide at the moment.  "+
         "With any luck, though, you won't be here long enough to find "+
         "out...\n" );
   add_exit( "drum", "/d/am/am/mendeddrum", "path" );
   locations = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) )
      unguarded((: restore_object, SAVE_FILE :));
}
void save_this() {
  unguarded((: save_object, SAVE_FILE :));
}
void player_quitting( object player, object place ) {
   if ( player->query_property( "guest" ) )
      return;
   locations[ (string)player->query_name() ] =
         ({ (string)place->query_property( "terrain name" ),
         (int *)place->query_co_ord() });
   save_this();
   call_out( "check_quitted", 5, (string)player->query_name() );
}
void check_quitted( string word ) {
   if ( !find_player( word ) )
      return;
   if ( locations[ word ] )
      locations = m_delete( locations, word );
   save_this();
}
void event_enter( object player, string words, object thing ) {
   object location;
   mixed *data;
   data = locations[ (string)player->query_name() ];
   if ( !data ) {
      player->move( (string)player->query_start_pos(),
            "$N enter$s the game." );
      return;
   }
   location = (object)TERRAIN_MAP->find_location( data[ 0 ],
         data[ 1 ] );
   player->move( location );
   locations = m_delete( locations, (string)player->query_name() );
   save_this();
}

==================================================
FILE: handlers/terrain_things/sample_passage.c
==================================================

inherit "/std/room";
void setup() {
   set_short( "dusty corridor" );
   set_light( 20 );
   set_room_size( 5 );
   set_long( "You are in a dry, dusty corridor.  It looks as though it has "+
         "been deserted for a long time.\n" );
   add_item( "dust", "There's quite a bit of dust in here, collecting along "+
         "the bottom of the walls." );
}
string query_exit_type( string word ) { return "corridor"; }

==================================================
FILE: handlers/terrain_things/sample_passage_1.c
==================================================

inherit "/std/room";
void setup() {
   set_short( "dusty corridor" );
   set_light( 20 );
   set_room_size( 5 );
   set_long( "You are in a dry, dusty corridor.  It looks as though it has "+
         "been deserted for a long time.\n" );
   add_item( "dust", "There's quite a bit of dust in here, collecting along "+
         "the bottom of the walls." );
}
string query_exit_type( string word ) { return "corridor"; }

==================================================
FILE: handlers/terrain_things/sample_passage_2.c
==================================================

inherit "/std/room";
void setup() {
   set_short( "rock-walled tunnel" );
   set_light( 20 );
   set_room_size( 5 );
   set_long( "You are tunnel with rough-hewn rock walls.  It looks as though "+
         "it has been deserted for a long time.\n" );
   add_item( ({ "rough-hewn rock wall", "rock" }), "The walls are rough, "+
         "where the tunnel was hewn out of the rock." );
}
string query_exit_type( string word ) { return "corridor"; }

==================================================
FILE: handlers/terrain_things/sample_room_1.c
==================================================

inherit "/std/room";
void setup() {
   set_short( "small room" );
   set_light( 20 );
   set_room_size( 15 );
   set_long( "You are in a small room.  The walls, floor and ceiling are "+
         "comprised of large stone blocks.  The room is quite bare.\n" );
   add_item( ({ "wall", "floor", "ceiling" }), "The walls, floor and "+
         "ceiling of the room are formed from large stone blocks." );
   add_item( "large stone block", "The blocks of stone that make up the "+
         "surfaces of this room are not too rough, but they were never "+
         "polished smooth either." );
}
string query_exit_type( string word ) { return "corridor"; }

==================================================
FILE: handlers/terrain_things/sample_room_2.c
==================================================

inherit "/std/room";
void setup() {
   set_short( "largish room" );
   set_light( 20 );
   set_room_size( 25 );
   set_long( "You are in a largish room.  The walls, floor and ceiling are "+
         "comprised of large stone blocks.  The room is quite bare.\n" );
   add_item( ({ "wall", "floor", "ceiling" }), "The walls, floor and "+
         "ceiling of the room are formed from large stone blocks." );
   add_item( "large stone block", "The blocks of stone that make up the "+
         "surfaces of this room are not too rough, but they were never "+
         "polished smooth either." );
}
string query_exit_type( string word ) { return "corridor"; }

==================================================
FILE: handlers/terrain_things/sample_room_3.c
==================================================

inherit "/std/room";
void setup() {
   set_short( "large room" );
   set_light( 20 );
   set_room_size( 35 );
   set_long( "You are in a large room.  The walls, floor and ceiling are "+
         "comprised of large stone blocks.  The room is quite bare.\n" );
   add_item( ({ "wall", "floor", "ceiling" }), "The walls, floor and "+
         "ceiling of the room are formed from large stone blocks." );
   add_item( "large stone block", "The blocks of stone that make up the "+
         "surfaces of this room are not too rough, but they were never "+
         "polished smooth either." );
}
string query_exit_type( string word ) { return "corridor"; }

==================================================
FILE: handlers/autodoc/autodoc_file.c
==================================================

#define MASTER_OB "/secure/master.c"
#define EOF -1
#define SAVE_DIR "/save/autodoc/"
nosave mapping private_functions;
mapping public_functions;
mapping protected_functions;
mapping inherits;
mapping main_docs;
mapping define_docs;
mapping includes;
mapping class_docs;
string file_name;
int last_changed;
int num_failed_tries;
nosave string current_comment;
nosave string current_file;
nosave int current_position;
nosave int changed;
nosave mapping defines;
nosave mixed *exclude_methods;
private void setup();
private mapping parse_comment(string stuff);
private void do_parse_file(function func);
private int query_file_position();
private void handle_inherit(mixed *bits);
void create() {
   seteuid(getuid());
   setup();
}
private void setup() {
   changed = 0;
   main_docs = 0;
   file_name = "";
   private_functions = ([ ]);
   public_functions = ([ ]);
   protected_functions = ([ ]);
   inherits = ([ ]);
   defines = ([ ]);
   define_docs = ([ ]);
   includes = ([ ]);
   class_docs = ([ ]);
   current_comment = 0;
   current_file = "";
   current_position = 0;
   last_changed = 0;
   exclude_methods = ({ "setup", "create", "init", "dest_me", "reset" });
}
private int query_file_position() {
   return current_position;
}
private int lookahead_character(int num) {
   if (current_position + num - 1 < strlen(current_file)) {
      return current_file[current_position + num - 1];
   }
   return EOF;
}
private int next_character() {
   if (current_position < strlen(current_file)) {
      return current_file[current_position++];
   }
   return EOF;
}
private int pop_character(int num) {
   current_position += num;
}
private void skip_to_end_of_line() {
   int ch;
   do {
      ch = next_character();
   } while (ch != '\r' && ch != '\n' && ch != EOF);
}
private string skip_to_end_of_comment() {
   string data;
   int ch;
   int ok;
   data = "";
   do {
      ok = 1;
      ch = next_character();
      if (ch == '*' && lookahead_character(1) == '/') {
         ok = 0;
         pop_character(1);
      } else if (ch == '\r' || ch == '\n') {
         data += "\n";
         if (lookahead_character(1) == ' ') {
            pop_character(1);
         }
         if (lookahead_character(1) == '*' && lookahead_character(2) != '/') {
            pop_character(1);
            if (lookahead_character(1) == ' ') {
               pop_character(1);
            }
         }
      } else if (ch == EOF) {
         ok = 0;
      } else if (ch == '\\' && (lookahead_character(1) == '/' ||
                               lookahead_character(1) == '*' ||
                               lookahead_character(1) == '\\')) {
      } else {
         data += sprintf("%c", ch);
      }
   } while (ok);
   return data;
}
private void skip_spaces_and_comments() {
   int ok;
   do {
     switch (lookahead_character(1)) {
        case ' ' :
        case '\t' :
        case '\n' :
        case '\r' :
           ok = 1;
           pop_character(1);
           break;
        case '/' :
           if (lookahead_character(2) == '/') {
              ok = 1;
              skip_to_end_of_line();
           } else if (lookahead_character(2) == '*') {
              ok = 1;
              if (lookahead_character(3) != '*' ||
                  lookahead_character(4) == '*') {
                 pop_character(2);
                 skip_to_end_of_comment();
                 current_comment = 0;
              } else {
                 pop_character(3);
                 if (lookahead_character(1) == ' ') {
                    pop_character(1);
                 }
                 if (!main_docs) {
                    main_docs = parse_comment(skip_to_end_of_comment());
                 } else {
                    current_comment = skip_to_end_of_comment();
                 }
              }
           } else {
              ok = 0;
           }
           break;
        default :
           ok = 0;
           break;
     }
   } while (ok);
}
private string expand_token(string token) {
   if (defines[token]) {
      return defines[token];
   }
   return 0;
}
private string get_word() {
   string data;
   int ok;
   int ch;
   skip_spaces_and_comments();
   ok = 1;
   data = "";
   ch = lookahead_character(1);
   if ((ch >= 'a' && ch <= 'z') ||
       (ch >= 'A' && ch <= 'Z') ||
       (ch == '_')) {
      do {
         ch = lookahead_character(1);
         if ((ch >= 'a' && ch <= 'z') ||
             (ch >= 'A' && ch <= 'Z') ||
             (ch >= '0' && ch <= '9') ||
             (ch == '_')) {
            ch = next_character();
            data += sprintf("%c", ch);
         } else {
            ok = 0;
         }
      } while (ok);
      if (expand_token(data)) {
         current_file = expand_token(data) + current_file[current_position..];
         current_position = 0;
         return get_word();
      }
   } else if ((ch >= '0' && ch <= '9') ||
              (ch == '-')) {
      if (ch == '-') {
         data += sprintf("%c", next_character());
      }
      do {
         ch = lookahead_character(1);
         if ((ch >= '0' && ch <= '9') ||
             (ch >= '.')) {
            ch = next_character();
            data += sprintf("%c", ch);
         } else {
            ok = 0;
         }
      } while (ok);
   } else if (ch == '\"' || ch == '\'') {
      int end_ch;
      end_ch = ch;
      ch = next_character();
      data += sprintf("%c", ch);
      do {
         ch = next_character();
         if (ch == end_ch) {
            ok = 0;
            data += sprintf("%c", ch);
         } else if (ch == '\\') {
            ch = next_character();
            data += sprintf("\\%c", ch);
         } else if (ch == EOF) {
            ok = 0;
         } else {
            data += sprintf("%c", ch);
         }
      } while (ok);
   } else if (ch == '(') {
      if (lookahead_character(2) == '{' ||
          lookahead_character(2) == '[') {
         return sprintf("%c%c", next_character(), next_character());
      }
      return sprintf("%c", next_character());
   } else if (ch == '}' || ch == ']') {
      if (lookahead_character(2) == ')') {
         return sprintf("%c%c", next_character(), next_character());
      }
      return sprintf("%c", next_character());
   } else if (ch == ';' ||
              ch == ')' ||
              ch == '=' ||
              ch == '{' ||
              ch == '}') {
      return sprintf("%c", next_character());
   } else if (ch == EOF) {
      return "";
   } else {
      do {
         ch = lookahead_character(1);
         if ((ch >= 'a' && ch <= 'z') ||
             (ch >= 'A' && ch <= 'Z') ||
             (ch >= '0' && ch <= '9') ||
             (ch == '_') ||
             (ch == ' ') ||
             (ch == '\t') ||
             (ch == '\n') ||
             (ch == '(') ||
             (ch == ')') ||
             (ch == EOF) ||
             (ch == ';') ||
             (ch == '=') ||
             (ch == '{') ||
             (ch == '}') ||
             (ch == '\'') ||
             (ch == '\"') ||
             (ch == '\r')) {
            ok = 0;
         } else {
            ch = next_character();
            data += sprintf("%c", ch);
         }
      } while (ok);
   }
   return data;
}
private mixed *get_statement(string start) {
   mixed *bits;
   string curr;
   int depth;
   string temp_comment;
   int last_pos;
   int in_class;
   bits = ({ start });
   do {
      last_pos = query_file_position();
      curr = get_word();
      bits += ({ curr });
      if (last_pos != query_file_position()) {
         reset_eval_cost();
      }
   } while (curr != ";" && curr != "{" && curr != "");
   if (curr == "{") {
      if (member_array("class", bits) != -1 &&
          member_array("(", bits) == -1) {
         in_class = 1;
      }
      temp_comment = current_comment;
      depth = 1;
      do {
        last_pos = query_file_position();
        curr = get_word();
        if (curr == "{") {
           depth++;
        } else if (curr == "}") {
           depth--;
        } else if (curr == "") {
           depth = 0;
        }
        if (last_pos != query_file_position()) {
           reset_eval_cost();
        }
        if (in_class) {
           bits += ({ curr });
        }
      } while (depth > 0);
      current_comment = temp_comment;
   }
   return bits;
}
private mapping parse_comment(string stuff) {
   string *bits;
   int i;
   mapping frog;
   string name;
   int j;
   int rabbit;
   if (!stuff) {
      return ([ ]);
   }
   if (stuff[0] == '@') {
      stuff = "\n" + stuff;
   } else {
      stuff = "\n@main " + stuff;
   }
   bits = explode(stuff, "\n@");
   frog = ([ ]);
   for (i = 0; i< sizeof(bits); i++) {
      j = strsrch(bits[i], " ");
      rabbit = strsrch(bits[i], "\n");
      if (j == -1 || (rabbit != -1 && rabbit < j)) {
         j = rabbit;
      }
      if (j > 0) {
         name = bits[i][0..j - 1];
         stuff = bits[i][j+1..];
         if (!frog[name]) {
            frog[name] = ({ stuff });
         } else {
            frog[name] += ({ stuff });
         }
      }
   }
   return frog;
}
private void handle_class(mixed *bits) {
   string name;
   int i;
   string *types;
   mapping comm;
   name = bits[1];
   types = ({ });
   i = member_array("{", bits);
   if (i != -1) {
      bits = bits[i + 1..];
      while (sizeof(bits)) {
         i = member_array(";", bits);
         if (i != -1) {
            types += ({ ({ bits[i - 1], bits[0..i - 2] }) });
            bits = bits[i + 1..];
         } else {
            bits = ({ });
         }
      }
      comm = parse_comment(current_comment);
      if (!comm["ignore"]) {
         class_docs[name] = ({ 0, types,
                               parse_comment(current_comment) });
      }
   }
}
private void handle_inherit(mixed *bits) {
   int pos;
   string name;
   pos = member_array("inherit", bits);
   if (pos >= 0) {
      name = implode(map(bits[pos+1.. sizeof(bits)-2],
                         function(string str) {
                            if (str[0] == '\"') {
                               sscanf(str, "\"%s\"", str);
                               return str;
                            }
                            return "";
                         } ), "");
      inherits[name] = bits[0..pos-1];
   }
}
private void handle_function_definition(mixed *bits) {
   int pos;
   int end_pos;
   int new_pos;
   string name;
   string *type;
   mixed *args;
   mapping comm;
   pos = member_array("(", bits);
   if (pos > 0) {
      name = bits[pos-1];
      if (member_array(name, exclude_methods) == -1) {
         type = bits[0..pos-2];
         if (sizeof(type) == 0) {
            type = ({ "int" });
         }
         end_pos = member_array(")", bits, pos);
         args = ({ });
         if (end_pos > pos + 1) {
            pos++;
            while (member_array(",", bits, pos) != -1) {
               new_pos = member_array(",", bits, pos);
               args += ({ bits[pos..new_pos-2], bits[new_pos-1] });
               pos = new_pos + 1;
            }
            args += ({ bits[pos..end_pos -2], bits[end_pos-1] });
         }
         comm = parse_comment(current_comment);
         if (!comm["ignore"]) {
            if (member_array("private", type) != -1) {
               type -= ({ "private" });
               private_functions[name] = ({ type, args,
                                          comm });
            } else if (member_array("protected", type) != -1) {
               type -= ({ "protected" });
               protected_functions[name] = ({ type, args,
                                           comm });
            } else {
               type -= ({ "public" });
               public_functions[name] = ({ type, args,
                                           comm });
            }
         }
      }
      current_comment = 0;
   }
}
private string get_rest_of_line() {
   string value;
   int ch;
   int last_pos;
   value = "";
   ch = lookahead_character(1);
   while (ch == ' ' || ch == '\t') {
      pop_character(1);
      ch = lookahead_character(1);
   }
   do {
      last_pos = query_file_position();
      ch = next_character();
      if (ch == '\\') {
         ch = next_character();
         if (ch == '\r' && lookahead_character(1) == '\n') {
            ch = next_character();
         }
         ch = ' ';
      }
      if (last_pos != query_file_position()) {
         reset_eval_cost();
      }
      value += sprintf("%c", ch);
   } while (ch != '\n' && ch != '\r' && ch != EOF);
   return value;
}
private void handle_hash() {
   int i;
   string token;
   string name;
   string value;
   string *bits;
   string stuff;
   string inc_name;
   string curr_comm;
   mapping comm;
   token = get_word();
   switch (token) {
      case "define" :
      case "defin" :
         curr_comm = current_comment;
         value = get_rest_of_line();
         if (sscanf(value, "%s %s", name, value) == 2) {
            defines[name] = value;
            if (token == "define") {
               comm = parse_comment(curr_comm);
               if (!comm["ignore"]) {
                  define_docs[name] = comm;
               }
               current_comment = 0;
            }
         }
         break;
      case "include" :
         value = get_rest_of_line();
         if (value[0] == '\"') {
            bits = explode(file_name, "/");
            sscanf(value, "\"%s\"", name);
            stuff = read_file(implode(bits[0..<2], "/") +
                              "/" + name);
            if (stuff) {
               inc_name = "/" + implode(bits[0..<2], "/") +
                              "/" + name;
            }
         } else if (value[0] == '<') {
            sscanf(value, "<%s>", name);
         }
         if (name[0] == '/') {
            stuff = read_file(name);
            if (stuff) {
               inc_name = name;
            }
         }
         bits = MASTER_OB->define_include_dirs();
         while (!stuff && i < sizeof(bits)) {
            stuff = read_file(sprintf(bits[i], name));
            if (stuff) {
               stuff = replace_string(stuff, "
               stuff = replace_string(stuff, "class ", "clas ");
               stuff = replace_string(stuff, "#define ", "#defin ");
               inc_name = sprintf(bits[i], name);
            }
            i++;
         }
         if (inc_name) {
            inc_name = replace(inc_name, "
            if (inc_name[0] != '/') {
               inc_name = "/" + inc_name;
            }
         }
         if (stuff && !includes[inc_name]) {
            current_file = stuff + current_file[current_position..];
            current_position = 0;
            includes[inc_name] = unguarded( (: stat($(inc_name)) :) )[1];
         }
         break;
      default :
         skip_to_end_of_line();
         break;
   }
}
private void next_statement() {
   string token;
   string *bits;
   token = get_word();
   if (token[0] == '#') {
      return handle_hash();
   } else if (token == ";") {
      return ;
   } else if (token != "") {
      bits = get_statement(token);
      if (member_array("inherit", bits) != -1) {
         return handle_inherit(bits);
      } else if (bits[0] == "class" &&
                 member_array("(", bits) == -1) {
         return handle_class(bits);
      } else if (bits[sizeof(bits) - 1] == "{" &&
                 member_array("=", bits) == -1) {
         return handle_function_definition(bits);
      } else {
         return ;
      }
   }
}
void load_file() {
   unguarded((: restore_object(SAVE_DIR + replace_string(file_name, "/", ".")) :));
   if (!includes) {
      includes = ([ ]);
   }
   if (!class_docs) {
      class_docs = ([ ]);
   }
}
void save_file() {
   unguarded((: save_object(SAVE_DIR + replace_string(file_name, "/", ".")) :));
}
void parse_file(string name, function func, int only_load) {
   int curr_change;
   int my_change;
   string my_name;
   int reload;
   setup();
   file_name = name;
   load_file();
   if (!only_load) {
      if (sizeof(unguarded( (: stat($(name)) :) )) > 1) {
         curr_change = unguarded( (: stat($(name)) :) )[1];
         my_name = file_name(this_object());
         sscanf(my_name, "%s#%*s", my_name);
         my_name += ".c";
         my_change = unguarded( (: stat($(my_name)) :) )[1];
         reload = curr_change > last_changed;
         if (my_change > last_changed &&
             my_change > curr_change) {
            curr_change = my_change;
            reload = 1;
         }
         if (!reload) {
            foreach (my_name, my_change in includes) {
               if ( unguarded( (: stat($(my_name)) :) )[1] != my_change) {
                  reload = 1;
                  break;
               }
            }
         }
         if (reload) {
            setup();
            num_failed_tries = 0;
            file_name = name;
            changed = 1;
            last_changed = curr_change;
            current_file = read_file(name);
            current_position = 0;
            if (catch(do_parse_file(func))) {
               evaluate(func);
            }
         } else {
            if (num_failed_tries) {
               num_failed_tries = 0;
               save_file();
            }
            call_out( (: evaluate($1) :), 2, func);
         }
      } else {
         num_failed_tries++;
         save_file();
         call_out( (: evaluate($1) :), 2, func);
      }
   } else {
      call_out( (: evaluate($1) :), 2, func);
   }
}
private void do_parse_file(function func) {
   int num;
   if (unguarded( (: stat(file_name) :))[1] > last_changed) {
      return parse_file(file_name, func, 0);
   }
   num = 0;
   while (lookahead_character(1) != EOF && num < 2) {
      next_statement();
      num++;
   }
   if (lookahead_character(1) == EOF) {
      save_file();
      call_out((: evaluate($1) :), 2, func);
   } else {
      call_out((: do_parse_file($1) :), 2, func);
   }
}
mapping query_inherits() { return inherits; }
mapping query_private_functions() { return private_functions; }
mapping query_public_functions() { return public_functions; }
mapping query_protected_functions() { return protected_functions; }
mapping query_main_docs() {
   if (main_docs) {
      return main_docs;
   }
   return ([ ]);
}
string query_file_name() { return file_name; }
mapping query_defines() { return defines; }
int query_changed() { return changed; }
int query_num_failed_tries() { return num_failed_tries; }
string *query_includes() { return keys(includes); }
mapping query_define_docs() { return define_docs; }
mapping query_class_docs() { return class_docs; }
void dest_me() {
   destruct(this_object());
}
