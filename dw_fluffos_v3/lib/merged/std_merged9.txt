




==================================================
FILE: /lib/std/shops/inherit/bank_master.c
==================================================

inherit "/std/shops/inherit/bank_base";
#include <money.h>
int query_float();
int do_process(object *obs) {
   object ob;
   int amount;
   int found;
   object* not_credit;
   object* not_valid;
   string place;
   place = query_money_place();
   not_valid = ({ });
   not_credit = ({ });
   foreach (ob in obs) {
      if (ob->query_credit_note() ||
          ob->query_bank_name() != query_bank_name()) {
         not_credit += ({ ob });
         obs -= ({ ob });
      } else if (ob->is_valid_note()) {
         amount += ob->query_credit_balance();
      } else {
         not_valid += ({ ob });
         obs -= ({ ob });
      }
   }
   if (!sizeof(obs)) {
      if (sizeof(not_credit)) {
         add_failed_mess("None of $I are credit notes.\n", not_credit);
      }
      if (sizeof(not_valid)) {
         add_failed_mess("None of $I are valid credit notes.\n", not_valid);
      }
      return 0;
   }
   foreach (ob in obs) {
      amount = ob->query_amount();
      if (amount > 0) {
         if (this_player()->query_value_in(query_money_place()) < amount) {
            add_failed_mess("You do not have the needed " +
                            MONEY_HAND->money_value_string(amount, place) +
                            " to deposit.\n");
            continue;
         }
         else if (ob->do_process()) {
            this_player()->pay_money(MONEY_HAND->create_money_array(amount,
                   place), place);
            add_succeeded_mess("$N $V depositing " +
                               MONEY_HAND->money_value_string(amount, place) +
                               " from $I.\n", ({ ob }));
            found++;
         } else {
            add_failed_mess("You cannot process $I for some reason.\n",
                            ({ ob }));
            continue;
         }
      } else if (amount < 0) {
         if (ob->do_process()) {
            this_player()->adjust_money(MONEY_HAND->create_money_array(-amount, place));
            add_succeeded_mess("$N $V withdrawing " +
                               MONEY_HAND->money_value_string(-amount, place) +
                               " from $I.\n", ({ ob }));
            found++;
         } else {
            add_failed_mess("You cannot process $I for some reason.\n",
                            ({ ob }));
            continue;
         }
      }
      ob->move("/room/rubbish");
   }
   return found;
}
void init() {
   ::init();
   add_command("process", "<indirect:object>");
}

==================================================
FILE: /lib/std/shops/inherit/clone_on_demand.c
==================================================

#include <armoury.h>
#define INFINITE_LEFT 10000
#define MAX_PROP "max per reset"
#define NUM_REMOVED "number removed this reset"
#define REFERENCE "name we are reference by"
#define DISPLAY "display in shop"
nosave object _cont;
nosave string _domain;
void create(){
}
object query_cont(){  return _cont;  }
void check_cont() {
  if (!_cont) {
     _cont = clone_object("/std/container");
     _cont->set_name( "clone_on_demand-store" );
  }
}
void reset() {
  object ob;
  check_cont();
  foreach( ob in all_inventory(_cont) ){
    ob->remove_property(NUM_REMOVED);
  }
}
void set_object_domain(string domain) {
   _domain = domain;
}
string query_object_domain() {
   return _domain;
}
varargs int add_object( string name, int max_per_reset, string display_as ) {
  object ob;
  if(!_cont) {
     _cont = clone_object("/std/container");
     _cont->set_name( "clone_on_demand-store" );
  }
  if (!(ob = this_object()->create_object(name))) {
    if(!ob = clone_object(name)) {
      ob = ARMOURY->request_item(name, 100, _domain);
    }
  }
  if(ob) {
    if (ob->query_decays()) {
      ob->set_decay_speed(0);
    }
    ob->move(_cont);
    if (display_as) {
         ob->add_property( DISPLAY, display_as);
    }
    ob->add_property( REFERENCE, name);
    ob->add_property( MAX_PROP, max_per_reset );
    return 1;
  }
  return 0;
}
int query_num_items_left(object ob) {
   int max;
   int num;
   max = ob->query_property( MAX_PROP );
   num = ob->query_property( NUM_REMOVED );
   if( max ){
     return max - num;
   }
   return INFINITE_LEFT;
}
int query_number_left(string name) {
   object * things;
   things = filter( all_inventory(_cont),
     (: $1->query_short() == $(name) :) );
   if( !sizeof(things) ) {
      return -1;
   }
   return query_num_items_left( things[0] );
}
int * query_items_left( string *names ) {
   if( !names )
      return ({ });
   return map( names, (: query_number_left($1) :) );
}
private void switch_properties(object newone, object original) {
  mixed *extra, *props, prop;
  props = ({ MAX_PROP, NUM_REMOVED, REFERENCE });
  extra = this_object()->switch_extra_properties();
  if( sizeof(extra) )
    props += extra;
  foreach( prop in props ){
    newone->add_property( prop, original->query_property( prop ) );
    original->remove_property( prop );
  }
  if (newone->query_decay_speed()) {
     original->set_decay_speed( newone->query_decay_speed() );
     newone->set_decay_speed(0);
  }
}
protected object create_real_object(object thing) {
   string name;
   object new_thing, *continv, temp_cont;
   int j, max, num;
   name = thing->query_property( REFERENCE );
   if(!name)
     return 0;
   new_thing = this_object()->create_object( name );
   if ( !new_thing )  {
      new_thing = clone_object(name);
   }
   if ( !new_thing )  {
      new_thing = ARMOURY->request_item( name, 80 + random( 20 ), _domain );
   }
  if( new_thing ){
    switch_properties( new_thing, thing );
    continv = all_inventory(_cont);
    j = member_array( thing, continv );
    temp_cont = clone_object("/std/container");
    thing->move("/room/void");
    continv[j] = new_thing;
    new_thing->move(_cont);
      for (j=sizeof(continv)-1;j>=0;j--) {
      continv[j]->move(temp_cont);
      continv[j]->move(_cont);
    }
    temp_cont->dest_me();
    max = new_thing->query_property( MAX_PROP );
    num = new_thing->query_property( NUM_REMOVED );
    if ( max ) {
      new_thing->add_property( NUM_REMOVED, num + 1 );
    }
  }
  return thing;
}
void dest_me(){
  if( _cont )
    _cont->dest_me();
}
varargs int add_armour( string name, int max_per_reset, string display_as ) {
  return add_object(name, max_per_reset, display_as);
}
varargs int add_weapon( string name, int max_per_reset, string display_as ) {
  return add_object(name, max_per_reset, display_as);
}

==================================================
FILE: /lib/std/shops/inherit/commercial.c
==================================================

#include <player.h>
#include <move_failures.h>
#include <expressions.h>
#include <money.h>
#include <player_handler.h>
#include <mail.h>
inherit "/std/room/player_housing";
inherit "/std/shops/inherit/expression_util";
inherit "/std/shops/inherit/person_expressions";
#define COMMERCIAL_WEEKLY_STATS_TIME (7 * 24 * 60 * 60)
#define COMMERCIAL_ROYALTY_TIMEOUT_PERIOD (7 * 24 * 60 * 60)
class float_withdrawls {
   string person;
   int amount;
   int withdrawl_time;
}
class weekly_status {
   int total_incoming;
   int total_outgoing;
   class float_withdrawls* withdrawls;
}
class royalty_data {
   int value;
   int last_withdrawl;
}
private string* _auto_load_sign_str;
private int _broken_sign;
private string _property_name;
private mapping _royalties;
private class parse_node* _use_expression;
private class parse_node* _entry_cost;
private int _entry_time_limit;
private mapping _use_type_expressions;
private string* _black_list;
private int _last_stats;
private class weekly_status _weekly_status;
private int _commercial_id;
private nosave object _sign_ob;
private nosave string _parcel_post;
private nosave object* _commercial_things;
private nosave string _use_type;
private nosave string _commercial_type;
private nosave string _save_dir;
private nosave int _property_size;
private nosave string _language;
#define COMMERCIAL_SALESPERSON "/obj/monster/commercial"
private string variable_use_type(string seller);
void create() {
    _commercial_things = ({ });
    _royalties = ([ ]);
    _use_type_expressions = ([ ]);
    _property_size = 25;
    _black_list = ({ });
    _last_stats = time();
    _weekly_status = new(class weekly_status);
    _weekly_status->withdrawls = ({ });
    _language = "common";
    expression_util::create();
    player_housing::create();
    person_expressions::create();
    add_allowed_variable("type", EXPRESSION_TYPE_STRING,
                        (: variable_use_type :));
    set_expression_type("room");
    add_help_file("commercial");
    if (!_use_expression) {
        _use_expression = parse_boolean_string("false");
    }
    if (!_black_list) {
        _black_list = ({ });
    }
    if (!_last_stats) {
        _last_stats = time();
    }
    if (_last_stats + COMMERCIAL_WEEKLY_STATS_TIME - time() < 0) {
        call_out("mail_weekly_status", 0);
    }
    else {
        call_out("mail_weekly_status", _last_stats +
            COMMERCIAL_WEEKLY_STATS_TIME - time());
    }
}
string short() {
    if (_property_name) {
        set_short(_property_name);
        add_property("determinate", "");
    }
    return ::short();
}
string long(string word, int dark) {
    if (_property_name) {
        set_short(_property_name);
        add_property("determinate", "");
    }
    return ::long(word, dark);
}
int is_open_for(string type, string person) {
   class parse_node ret;
   if (is_allowed(person)) {
      return 1;
   }
   if (member_array(person, _black_list) != -1) {
      return 0;
   }
   _use_type = type;
   ret = evaluate_expression(_use_expression, this_player()->query_name());
   if (ret->value) {
      if (_use_type_expressions[type]) {
         ret = evaluate_expression(_use_type_expressions[type],
                                   this_player()->query_name());
      }
   }
   return ret->value;
}
object query_main_room() {
   return this_object();
}
void add_commercial_thing(object ob) {
   _commercial_things += ({ ob });
   ob->load_me();
}
void remove_commercial_thing(object thing) {
   thing->save_me();
   _commercial_things -= ({ thing });
}
object* query_commercial_things() {
   return _commercial_things;
}
int query_owners_money() {
   if (classp(_royalties[query_owner()])) {
      return ((class royalty_data)_royalties[query_owner()])->value;
   }
   return 0;
}
void adjust_royalty(string person, int amount) {
   if (is_allowed(person)) {
      if (!_weekly_status) {
         _weekly_status = new(class weekly_status);
         _weekly_status->withdrawls = ({ });
      }
      if (amount > 0) {
         _weekly_status->total_incoming += amount;
      } else {
         _weekly_status->total_outgoing += -amount;
      }
      if (!classp(_royalties[query_owner()])) {
         _royalties[query_owner()] = new(class royalty_data,
                      value : amount + _royalties[query_owner()],
                      last_withdrawl : time());
      } else {
         if (((class royalty_data)_royalties[query_owner()])->value == 0) {
            ((class royalty_data)_royalties[query_owner()])->last_withdrawl = time();
         }
         ((class royalty_data)_royalties[query_owner()])->value += amount;
      }
   } else {
      if (!classp(_royalties[person])) {
         _royalties[person] = new(class royalty_data,
                      value : amount + _royalties[person],
                      last_withdrawl : time());
      } else {
         if (((class royalty_data)_royalties[person])->value == 0) {
            ((class royalty_data)_royalties[person])->last_withdrawl = time();
         }
         ((class royalty_data)_royalties[person])->value += amount;
      }
   }
   event_save(this_object());
}
int query_royalty(string person) {
   if (classp(_royalties[person])) {
      return ((class royalty_data)_royalties[person])->value;
   }
   return 0;
}
int query_float() {
   return query_owners_money();
}
int query_commercial_property() {
   return 1;
}
void set_parcel_post(string parcel) {
   _parcel_post = parcel;
}
string query_parcel_post() {
   return _parcel_post;
}
void set_language(string language) {
   _language = language;
}
string query_language() {
   return _language;
}
void set_commercial_type(string name) {
   _commercial_type = name;
}
string query_commercial_type() {
   return _commercial_type;
}
void set_property_name(string name) {
  if(strsrch(name, "%^") != -1)
    return 0;
   _property_name = name;
   add_property("determinate", "");
   set_short(_property_name);
}
string query_property_name() {
   return _property_name;
}
void event_dest_me(object ob) {
   if (_sign_ob) {
      _sign_ob->dest_me();
   }
}
object query_sign_object() {
   object* obs;
   if (!_sign_ob && _auto_load_sign_str && !_broken_sign) {
      if (catch(obs = (PLAYER_OB)->load_auto_load_to_array(_auto_load_sign_str))) {
         _broken_sign = 1;
      } else {
         if (sizeof(obs)) {
            _sign_ob = obs[0];
            _sign_ob->reset_get();
         } else {
            _broken_sign = 1;
         }
      }
   }
   return _sign_ob;
}
void set_sign_object(object ob) {
   if (ob) {
      _auto_load_sign_str = (PLAYER_OB)->create_auto_load(({ ob }));
      ob->reset_get();
   } else {
      _auto_load_sign_str = 0;
   }
   _sign_ob = ob;
   event_save(this_object());
}
void set_save_file(string str) {
   printf("ERROR!  Do not use set_save_file.\n");
}
void set_save_dir(string dir) {
   if (dir[<1] != '/') {
      dir += "/";
   }
   _save_dir = dir;
   ::set_save_file(dir + "_main");
}
string query_save_dir() {
   return _save_dir;
}
int find_next_commercial_id() {
   object *obs;
   obs = all_inventory();
   while (file_size(query_save_dir() + _commercial_id) >= 0 ||
          file_size(query_save_dir() + _commercial_id + ".o") >= 0 ||
          file_size(query_save_dir() + _commercial_id + ".o.gz") >= 0 ||
          sizeof(filter(obs,
                        (: $1->query_commercial_id() == _commercial_id :)))) {
      _commercial_id++;
   }
   event_save(this_object());
   return _commercial_id;
}
void set_property_size(int size) {
   _property_size = size;
}
int query_property_size() {
   return _property_size;
}
void reset_weekly_status() {
   object ob;
   _weekly_status = new(class weekly_status);
   _weekly_status->withdrawls = ({ });
   foreach (ob in _commercial_things) {
      if (ob) {
         ob->reset_weekly_status();
      }
   }
}
string query_weekly_status_string() {
   string place;
   string ret;
   string str;
   object ob;
   class float_withdrawls withdrawl;
   place = query_property("place");
   if (!_weekly_status) {
      _weekly_status = new(class weekly_status);
      _weekly_status->withdrawls = ({ });
   }
   ret = "";
   ret += "\n$I$0=---=== " + the_short() + " ===---\n";
   ret += "Total outgoing   : " +
          MONEY_HAND->money_value_string(_weekly_status->total_outgoing, place) + "\n";
   ret += "Total incoming   : " +
          MONEY_HAND->money_value_string(_weekly_status->total_incoming, place) + "\n";
   if (sizeof(_weekly_status->withdrawls)) {
      ret += "Float withdrawls:\n";
      foreach (withdrawl in _weekly_status->withdrawls) {
         ret += "$I$6=   " + ctime(withdrawl->withdrawl_time)[0..11] + " " +
                withdrawl->person + " for " +
                MONEY_HAND->money_value_string(withdrawl->amount, place) + "\n";
      }
   } else {
      ret += "No withdrawls from the float.\n";
   }
   foreach (ob in _commercial_things) {
      if (ob) {
         str = ob->query_weekly_status_string();
         if (str) {
            ret += "\n$I$0=---=== " + ob->the_short() + " ===---\n";
            ret += str;
         }
      }
   }
   return ret;
}
protected void mail_weekly_status() {
   string str;
   string ret;
   class royalty_data data;
   string person;
   if(!query_owner()) {
      return;
   }
   foreach (person, data in _royalties) {
      if (classp(data)) {
         if (person != query_owner() &&
             data->value > 0 &&
             data->last_withdrawl +
                  COMMERCIAL_ROYALTY_TIMEOUT_PERIOD - time() < 0) {
            AUTO_MAILER->auto_mail(person,
                                   the_short(),
                                   "Lost royalties.",
                                   0,
                                   "You took too long to collect your "
                                   "royalties and they vanished.\n\n"
                                   "Good luck!\n"
                                   "Administrator.");
            map_delete(_royalties, person);
         }
      }
   }
   ret = catch(str = query_weekly_status_string());
   if (ret) {
      AUTO_MAILER->auto_mail(query_owner(),
                        the_short(),
                        "Weekly Statistics " + ctime(time()),
                        implode(query_allowed(), ","),
                        "The weekly stats generated an error: " + ret + "\n");
      AUTO_MAILER->auto_mail("pinkfish",
                        the_short(),
                        "Weekly Statistics " + ctime(time()),
                        0,
                        "The weekly stats generated an error: " +
                        ret + "\nin room: " + file_name(this_object()) + "\n");
   } else {
      str = PLAYER_OB->convert_message(str);
      AUTO_MAILER->auto_mail(query_owner(),
                        the_short(),
                        "Weekly Statistics " + ctime(time()),
                        implode(query_allowed(), ","),
                        str);
   }
   _last_stats = time();
   foreach (object ob in _commercial_things) {
      adjust_royalty(query_owner(), -ob->query_weekly_upkeep_cost());
   }
   event_save(this_object());
   reset_weekly_status();
   event_save(this_object());
}
object* find_commercial_items(string type) {
   object* obs;
   obs = filter(all_inventory(this_object()),
                (: $1->query_commercial_name() == $2 :), type);
   return obs;
}
void register_use_types(string* types) {
   string bing;
   if (!_use_type_expressions) {
      _use_type_expressions = ([ ]);
   }
   foreach (bing in types) {
      if (!_use_type_expressions[bing]) {
         _use_type_expressions[bing] = parse_boolean_string("true");
      }
   }
}
int do_name_property(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot set the name of " + the_short() + ".\n");
      return 0;
   }
   set_property_name(name);
   add_succeeded_mess("$N set$s the property name to '" + name + "'.\n");
   return 1;
}
int do_set_sign(object* obs) {
   object ob;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot set the sign for the property.\n");
      return 0;
   }
   if (sizeof(obs) > 1) {
      add_failed_mess("You must only specifiy one sign.\n");
      return 0;
   }
   if (living(obs[0])) {
      add_failed_mess("You have to wait till " + obs[0]->the_short() +
                      " dies first.\n");
      return 0;
   }
   if (obs[0]->get()) {
      add_failed_mess("Cannot set something as a sign that you cannot get.\n");
      return 0;
   }
   ob = query_sign_object();
   if (obs[0]->move("/room/rubbish") == MOVE_OK) {
      set_sign_object(obs[0]);
   } else {
      add_failed_mess("Unable to move $I off you.\n", obs[0..0]);
      return 0;
   }
   if (query_sign_object() != ob) {
      if (ob) {
         ob->set_get();
         if (ob->move(this_player()) != MOVE_OK) {
            ob->move(this_object());
         }
         add_succeeded_mess(({ "You remove the sign " +ob->the_short() +
                               " and set " + obs[0]->the_short() +
                               " as your property sign.\n",
                               "$N sets the sign for outside " + the_short() +
                               ".\n" }));
      } else {
         add_succeeded_mess(({ "You set " + obs[0]->the_short() +
                               " as your property sign.\n",
                               "$N sets the sign for outside " + the_short() +
                               ".\n" }));
      }
      return 1;
   } else {
      obs[0]->move(this_player());
      add_failed_mess("You cannot set the sign for some reason.\n");
      return 0;
   }
}
int do_remove_sign() {
   object ob;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot set the sign for the property.\n");
      return 0;
   }
   if (!query_sign_object()) {
      add_failed_mess("You cannot remove the sign since there is no sign.\n");
      return 0;
   }
   ob = query_sign_object();
   ob->set_get();
   if (ob->move(this_player()) == MOVE_OK) {
      add_succeeded_mess("$N $V $I from " + the_short() +
                         ".\n", ({ ob }));
      set_sign_object(0);
      return 1;
   } else {
      ob->reset_get();
      add_failed_mess("You cannot remove the sign, unable to hold it?\n");
      return 0;
   }
}
int do_status(int hint) {
   string ret;
   object ob;
   string str;
   string place;
   string fluff;
   class parse_node* expr;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }
   place = query_property("place");
   ret = "";
   ret += "$I$5=The owner of the property is " + query_owner() + ".\n";
   ret += "$I$5=The name of the property is " + _property_name + ".\n";
   if (hint) {
      ret += "$I$0=       Hint: name property <name>\n";
   }
   if (sizeof(_black_list)) {
      ret += "$I$5=The black list is " +
             query_multiple_short(_black_list) + ".\n";
   } else {
      ret += "$I$5=The black list is empty.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: blacklist add <name>\n";
      ret += "$I$0=       Hint: blacklist add ignore\n";
      ret += "$I$0=       Hint: blacklist remove <name>\n";
   }
   if (query_sign_object()) {
      ret += "$I$5=The property currently has a sign set.\n";
   } else {
      ret += "$I$5=The property does not currently have a sign set.\n";
   }
   if (hint) {
      ret += "$I$0=       Hint: set sign <object>\n";
      ret += "$I$0=       Hint: remove sign\n";
   }
   if (sizeof(query_allowed())) {
      ret += "$I$5=People allowed to change the property are " +
             query_multiple_short(sort_array(query_allowed(), 0)) + ".\n";
   } else if (hint) {
      ret += "$I$5=Only the owner can change the property.\n";
   }
   ret += "$I$5=Current float is " +
          MONEY_HAND->money_value_string(query_float(), place) + ".\n";
   if (sizeof(_use_expression)) {
      ret += "$I$5=Use condition: " + query_expression_string(_use_expression, 0) +
             ".\n";
   } else {
      ret += "$I$5=Anyone can use the shop.\n";
   }
   foreach (fluff, expr in _use_type_expressions) {
      ret += "$I$5=  Use " + fluff + " condition: " +
             query_expression_string(expr, 0) + ".\n";
   }
   ret += "$I$0=\n";
   foreach (ob in _commercial_things) {
      if (ob) {
         str = ob->query_main_status(hint);
         if (str) {
            ret += str;
         }
      }
   }
   write("$P$Status$P$" + ret);
   return 1;
}
int do_weekly_status() {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to see the status of this store.\n");
      return 0;
   }
   write("$P$Weekly Status$P$" + query_weekly_status_string());
   return 1;
}
int do_use_expression(string str) {
   class parse_node* expr;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add restrictions to the property.\n");
      return 0;
   }
   if (str == "disable")  {
      _use_expression = ({ });
      add_succeeded_mess(({ "You disable checking to see if "
         "someone can use the property.\n",
         "$N fiddle$s about with " + the_short() + " a bit.\n" }));
      return 1;
   }
   expr = parse_boolean_string(str);
   if (!sizeof(expr)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   } else {
      _use_expression = expr;
      add_succeeded_mess(({ "You set the expression to use when checking "
                            "to see if someone can use the property to " +
                            query_expression_string(expr, 1) +
                            ".\n",
                            "$N fiddle$s about with " + the_short() +
                                " a bit.\n" }));
      event_save(this_object());
   }
   return 1;
}
int do_use_expression_type(string type, string str) {
   class parse_node* expr;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add restrictions to the property.\n");
      return 0;
   }
   if (!_use_type_expressions[type]) {
      add_failed_mess("The type '" + type + "' is invalid, must be one "
                      "of " +
                      query_multiple_short(keys(_use_type_expressions)) +
                      ".\n");
      return 0;
   }
   if (str == "disable")  {
      _use_type_expressions[type] = ({ });
      add_succeeded_mess(({ "You disable checking to see if "
         "someone can use the property for " + type + ".\n",
         "$N fiddle$s about with " + the_short() + " a bit.\n" }));
      return 1;
   }
   expr = parse_boolean_string(str);
   if (!sizeof(expr)) {
      add_failed_mess(query_last_expression_error() + ".\n");
      return 0;
   } else {
      _use_type_expressions[type] = expr;
      add_succeeded_mess(({ "You set the expression to use when checking "
                            "to see if someone can use the property for " +
                            type + " to " +
                            query_expression_string(expr, 1) +
                            ".\n",
                            "$N fiddle$s about with " + the_short() +
                                " a bit.\n" }));
      event_save(this_object());
   }
   return 1;
}
int do_royalties() {
   string place;
   class royalty_data data;
   if (!is_open_for("royalty", this_player()->query_name())) {
      add_failed_mess(the_short() + " is not currently open for "
                      "customers.\n");
      return 0;
   }
   if (!classp(_royalties[this_player()->query_name()]) &&
       _royalties[this_player()->query_name()] != 0) {
      data = new(class royalty_data,
                 value : _royalties[this_player()->query_name()],
                 last_withdrawl : time());
     _royalties[this_player()->query_name()] = data;
   }
   data = _royalties[this_player()->query_name()];
   if (!data) {
      add_failed_mess("You have no money owed to you here.\n");
      return 0;
   }
   if (this_player()->query_name() != query_owner() && data->value > 0) {
      if (data->last_withdrawl + COMMERCIAL_ROYALTY_TIMEOUT_PERIOD - time() < 0) {
         write("Your royalties timed out before you could claim them.\n");
         map_delete(_royalties, this_player()->query_name());
      }
   }
   if (data->value < 0) {
      add_failed_mess("You owe money to " + the_short() + ".\n");
      return 0;
   }
   if (data->value == 0) {
      map_delete(_royalties, this_player()->query_name());
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   add_succeeded_mess(({ "You have " +
                      MONEY_HAND->money_value_string(data->value, place) +
                      " in royalties currently which will timeout in " +
                      query_time_string(data->last_withdrawl + COMMERCIAL_ROYALTY_TIMEOUT_PERIOD - time(), 2) + ".\n",
                      "$N checks $p royalties.\n" }));
   return 1;
}
int do_royalty_list() {
   string place;
   mixed value;
   class royalty_data data;
   string person;
   string ret;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("Only the property owners can do this.\n");
      return 0;
   }
   if (!sizeof(_royalties)) {
      add_failed_mess("No one has royalties here currently.\n");
      return 0;
   }
   place = query_property("place");
   ret = "";
   foreach (person in sort_array(keys(_royalties), 0)) {
      value = _royalties[person];
      if (!classp(value)) {
         data = new(class royalty_data, value : value, last_withdrawl : time());
      } else {
         data = value;
      }
      if (PLAYER_HANDLER->test_user(person)) {
         ret += capitalize(person) + " " +
                MONEY_HAND->money_value_string(data->value, place);
         if (person != query_owner()) {
            ret += " (Timeout: " + query_time_string(data->last_withdrawl +
                     COMMERCIAL_ROYALTY_TIMEOUT_PERIOD - time(), 2) + ")\n";
         } else {
            ret += "\n";
         }
      } else {
         map_delete(_royalties, person);
      }
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   write("$P$Royalties$P$" + ret);
   return 1;
}
int do_collect() {
   string place;
   string name;
   class royalty_data data;
   if (!is_open_for("royalty", this_player()->query_name())) {
      add_failed_mess(the_short() + " is not currently open for "
                      "customers.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   name = this_player()->query_name();
   if (!classp(_royalties[this_player()->query_name()]) &&
       _royalties[this_player()->query_name()] != 0) {
      data = new(class royalty_data,
                 value : _royalties[this_player()->query_name()],
                 last_withdrawl : time());
     _royalties[this_player()->query_name()] = data;
   }
   data = _royalties[name];
   if (!data) {
      add_failed_mess("You have no royalties to collect.\n");
      return 0;
   }
   if (name != query_owner() && data->value > 0) {
      if (data->last_withdrawl + COMMERCIAL_ROYALTY_TIMEOUT_PERIOD - time() < 0) {
         write("Your royalties timed out before you could claim them.\n");
         map_delete(_royalties, name);
         return 1;
      }
   }
   if (data->value == 0) {
      map_delete(_royalties, this_player()->query_name());
   }
   if (this_player()->query_refresh_time() &&
       this_player()->query_refresh_time() > data->last_withdrawl) {
      add_failed_mess("You have refreshed since your last collection.\n");
      map_delete(_royalties, name);
      return 0;
   }
   if ((!data || !data->value) && is_allowed(this_player()->query_name())) {
      name = query_owner();
      data = _royalties[name];
   }
   if (data->value > 0) {
      this_player()->adjust_money(MONEY_HAND->create_money_array(data->value, place));
      if (name == query_owner()) {
         _weekly_status->withdrawls += ({ new(class float_withdrawls, amount : data->value,
                               person : name,
                               withdrawl_time : time() ) });
      }
      event_save(this_object());
      add_succeeded_mess(({ "You collect " +
                            MONEY_HAND->money_value_string(data->value, place) +
                            " in royalties.\n",
                            "$N collects some royalties.\n" }));
      data->value = 0;
      if (!data->value && name != query_owner()) {
         map_delete(_royalties, name);
      }
      return 1;
   } else if (!data->value) {
      add_failed_mess("You have no royalties to collect.\n");
   } else {
      if (this_player()->query_value_in(place) < -data->value) {
         add_failed_mess("You do not have enough money to pay off "
                         "your debts.\n");
         return 0;
      }
      this_player()->pay_money(MONEY_HAND->create_money_array(-data->value, place),
                               place);
      add_succeeded_mess(({ "You pay off " +
                            MONEY_HAND->money_value_string(data->value, place) +
                            " in debt.\n",
                            "$N pays off some debt.\n" }));
      if (name != query_owner()) {
         map_delete(_royalties, name);
      } else {
         data->value = 0;
      }
      return 1;
   }
}
int do_collect_partial_royalties(string amount) {
   int amt;
   string place;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("Only the owners can do this.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   amt = MONEY_HAND->value_from_string(amount, place);
   if (!amt) {
      add_failed_mess("The value " + amount + " is not a valid money "
                      "amount.\n");
      return 0;
   }
   if (amt > query_owners_money()) {
      add_failed_mess("You cannot collect more money than you have.\n");
      return 0;
   }
   this_player()->adjust_money(MONEY_HAND->create_money_array(amt, place));
   ((class royalty_data)_royalties[query_owner()])->value -= amt;
   if (!((class royalty_data)_royalties[query_owner()])->value) {
      map_delete(_royalties, query_owner());
   }
   if (!_weekly_status) {
      _weekly_status = new(class weekly_status);
      _weekly_status->withdrawls = ({ });
   }
   _weekly_status->withdrawls += ({ new(class float_withdrawls, amount : amt,
                                        person : this_player()->query_name(),
                                        withdrawl_time : time() ) });
   event_save(this_object());
   add_succeeded_mess(({ "You collect " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " in royalties.\n",
                      "$N collects some money in royalties.\n" }));
   return 1;
}
int do_pay_entry() {
   string place;
   class parse_node ret;
   if (!_entry_cost) {
      add_failed_mess("Entry into " + the_short() + " is free.\n");
      return 0;
   }
   if (!is_open_for("entry", this_player()->query_name())) {
      add_failed_mess(the_short() + " is not currently open for "
                      "customers.\n");
      return 0;
   }
   ret = evaluate_expression(_entry_cost, this_player()->query_name());
   if (this_player()->query_value_in(place) < ret->value) {
      add_failed_mess("You do not have the " +
                      MONEY_HAND->money_value_string(ret->value, place) +
                      " needed to enter.\n");
      return 0;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(ret->value, place),
                            place);
   this_player()->add_property(file_name(this_object()),
                               _entry_time_limit * 60 * 60);
   add_succeeded_mess("$N pay$s " +
                      MONEY_HAND->money_value_string(ret->value, place) +
                      " for entry into " + the_short() + ".\n");
   return 1;
}
int do_add_royalties(string amount) {
   int amt;
   string place;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You cannot add to the float.\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   amt = MONEY_HAND->value_from_string(amount, place);
   if (!amt) {
      add_failed_mess("The value " + amount + " is not a valid money "
                      "amount.\n");
      return 0;
   }
   if (this_player()->query_value_in(place) < amt) {
      add_failed_mess("You do not have " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to add to the float.\n");
      return 0;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(amt, place),
                            place);
   if (!classp(_royalties[query_owner()])) {
       int value;
       value = _royalties[query_owner()];
       _royalties[query_owner()] = new(class royalty_data,
            value : value,
            last_withdrawl : time());
   }
   ((class royalty_data)_royalties[query_owner()])->value += amt;
   add_succeeded_mess(({ "You add " +
                      MONEY_HAND->money_value_string(amt, place) +
                      " to " + poss_short() + " float.\n",
                      "$N fiddles about in " + the_short() + ".\n" }));
   return 1;
}
int do_purchase() {
   object ob;
   ob = clone_object(COMMERCIAL_SALESPERSON);
   ob->move(this_object(), "$N arrives in a flash.\n");
   ob->set_commercial_type(query_commercial_type());
   ob->do_start_speil(this_player());
   return 1;
}
int do_deposit(object* obs) {
   object* monies;
   object money;
   string place;
   monies = filter(obs, (: $1->id(MONEY_ALIAS) :));
   if (!sizeof(monies)) {
      add_failed_mess("YOu cannot deposit any of $I.\n", obs);
      return 0;
   }
   money = monies[0];
   place = query_property("place");
   monies = MONEY_HAND->filter_legal_tender(money, place);
   if (monies[1]) {
      monies[1]->move(this_player());
   }
   if (!monies[0]) {
      add_failed_mess("You must use legal tender.\n");
      return 0;
   }
   adjust_royalty(query_owner(), monies[0]->query_value_in(place));
   monies[0]->move("/room/rubbish");
   add_succeeded_mess(({ "$N $V $I into " + the_short() + ".\n",
                         "$N $V some money into " + the_short() + ".\n" }),
                      monies[0..0]);
   event_save(this_object());
   return 1;
}
int do_black_list_add(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add people to the black list.\n");
      return 0;
   }
   name = lower_case(name);
   if (!PLAYER_HANDLER->test_user(name)) {
      add_failed_mess("Sorry, " + name + " does not play here.\n");
      return 0;
   }
   if (is_allowed(name)) {
      add_failed_mess("This person is in the list of people allowed to use "
                      "the shop.  They cannot be put on a black list.\n");
      return 0;
   }
   if (member_array(name, _black_list) != -1) {
      add_failed_mess("The person " + name + " is already in the "
                      "black list.\n");
      return 0;
   }
   _black_list += ({ name });
   event_save(this_object());
   add_succeeded_mess(({ "You add " + name + " to the black list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_black_list_add_ignore() {
   string *people;
   string *bad;
   string *ok;
   string name;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to add people to the black list.\n");
      return 0;
   }
   people = this_player()->query_property("ignoring");
   if (!people) {
      add_failed_mess("You are not ignoring anyone.\n");
      return 0;
   }
   bad = ({ });
   ok = ({ });
   foreach (name in people) {
      name = lower_case(name);
      if (!PLAYER_HANDLER->test_user(name)) {
         bad += ({ name });
      } else if (member_array(name, _black_list) != -1) {
         bad += ({ name });
      } else {
         _black_list += ({ name });
         ok += ({ name });
      }
   }
   event_save(this_object());
   if (!sizeof(ok)) {
      add_failed_mess("Your ignore list is already added to the black list.\n");
      return 0;
   }
   add_succeeded_mess(({ "You add " + query_multiple_short(ok) + " to the "
                         "black list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
int do_black_list_remove(string name) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to remove people from "
                      "the black list.\n");
      return 0;
   }
   name = lower_case(name);
   if (member_array(name, _black_list) == -1) {
      add_failed_mess("The person " + name + " is not in the black list.\n");
      return 0;
   }
   _black_list -= ({ name });
   event_save(this_object());
   add_succeeded_mess(({ "You remove " + name + " from the black list.\n",
                         "$N fiddle$s with something in the shop.\n" }) );
   return 1;
}
private string variable_use_type(string seller) {
   return _use_type;
}
int do_measure() {
    this_player()->add_succeeded_mess( this_object(),
        ({
            "$N $V up the size of the property and calculate that it is "
            "about " + query_num(query_property_size()) + " square yards.\n",
            "$N $V up the size of the property.\n"
        }), ({ }) );
    return 1;
}
void init() {
   if (!_royalties) {
      _royalties = ([ ]);
   }
   player_housing::init();
   expression_util::init();
   add_command("collect", "royalties", (: do_collect() :));
   add_command("royalties", "", (: do_royalties() :));
   add_command("royalty", "", (: do_royalties() :));
   add_command("measure", "property", (: do_measure() :) );
   if (!is_allowed(this_player()->query_name())) {
      return ;
   }
   add_command("royalty", "list", (: do_royalty_list() :));
   add_command("royalties", "list", (: do_royalty_list() :));
   add_command("collect", "royalties of <string'amount'>",
               (: do_collect_partial_royalties($4[0]) :));
   add_command("royalty", "add <string'amount'> to float",
               (: do_add_royalties($4[0]) :));
   add_command("deposit", "[to] float <indirect:object>",
               (: do_deposit :));
   add_command("status", "room",
               (: do_status(0) :));
   add_command("status", "room {hint|hints}",
               (: do_status(1) :));
   add_command("status", "room weekly",
               (: do_weekly_status() :));
   add_command("name", "property <string'property name'>",
               (: do_name_property($4[0]) :));
   add_command("set", "use expression <string'expression'>",
               (: do_use_expression($4[0]) :));
   add_command("set",
               "use expression for <string'type'> as <string'expression'>",
               (: do_use_expression_type($4[0], $4[1]) :));
   add_command("set", "sign <indirect:object'sign'>",
               (: do_set_sign($1) :) );
   add_command("remove", "sign",
               (: do_remove_sign() :) );
   add_command("blacklist", "add <string'person'>",
               (: do_black_list_add($4[0]) :));
   add_command("blacklist", "add ignore",
               (: do_black_list_add_ignore() :));
   add_command("blacklist", "remove <string'person'>",
               (: do_black_list_remove($4[0]) :));
   add_command("purchase", "stuff", (: do_purchase() :));
}

==================================================
FILE: /lib/std/shops/inherit/craft_shop.c
==================================================

#include <money.h>
#include <shops/craft_shop.h>
inherit "/std/shops/inherit/open_shop";
private nosave object _controller;
private nosave string _save_dir_name;
private nosave function _allowed_to_sell;
private nosave function _when_sold_func;
private nosave int _max_sell_per_person;
private nosave int _cut;
private nosave int _minimum_cost;
private nosave function _extra_sell_check;
private nosave int _always_ask_price;
private nosave int _use_name;
private nosave int _no_royalty_commands;
int do_sell(object *obs);
void set_controller(string name);
int do_buy(object *obs, int force);
int do_delete(string id);
int do_browse(object *obs);
int do_change(object *obs, string str);
int do_change_name(object *obs, string str);
void set_allowed_to_sell(function f);
void set_minimum_cost(int i);
protected void sell_name(string name, object *sellable);
protected void sell_choice(string choice, object *sellable, string *names);
protected void determine_cost(string cost, string name, object *sellable);
protected void confirm_sale(string answer, int value, string name,
                            object *sellable, string category);
protected void confirm_sell_name_choice(string answer, string name,
                                        object *sellable);
protected void complete_sale(int value, string name, object *sellable, string category);
protected void do_confirm_sale(int value, string name, object *sellable);
void set_cut(int value);
int query_cut();
int check_open(object player, string command);
mixed query_property(string name);
string the_short();
string query_craft_shop_save_dir();
void create() {
   if (!_allowed_to_sell) {
      set_allowed_to_sell((: 1 :));
   }
   if (!_cut) {
      set_cut(10);
   }
   if (!_minimum_cost) {
      set_minimum_cost(12 * 4);
   }
   if (!_controller && _save_dir_name) {
      set_controller("/std/shops/controllers/craft_shop_controller");
      _controller->load_it();
   }
}
int value_from_string(string str, string place) {
   return MONEY_HAND->value_from_string(str, place);
}
protected void do_save_file(int type, mixed value, string fname) {
   string tmp, file;
   string dir;
   switch (type) {
   case CRAFT_SHOP_MAIN_SAVE_FILE :
     debug_printf("attempting to write main");
#ifdef USE_RAMDISK
     tmp = replace_string(query_craft_shop_save_dir(), "/save/",
                          "/save/ramdisk/");
     file = tmp + ".o";
#endif
     if(!file) {
       file = query_craft_shop_save_dir() + ".o";
     }
     debug_printf("writing main %s", file);
     tmp = save_variable(value);
     if (file_size(query_craft_shop_save_dir() + ".o") != -1) {
       unguarded( (: rename(query_craft_shop_save_dir() + ".o",
                            query_craft_shop_save_dir() + ".o.bak") :));
     }
     if(unguarded( (: write_file($(file), $(tmp), 1) :) )) {
       unguarded( (: rm($(file) + ".bak") :));
     } else {
       unguarded( (: rename($(file) + ".bak", $(file)) :));
     }
     break;
   case CRAFT_SHOP_DATA_SAVE_FILE :
#ifdef USE_RAMDISK
     dir = replace_string(query_craft_shop_save_dir(), "/save/", "/save/ramdisk/");
     if (file_size(dir) == -2) {
        file = dir + "/" + fname;
     }
#endif
     if(!file) {
       file = query_craft_shop_save_dir() + "/" + fname;
     }
     debug_printf("writing data %s", file);
     tmp = save_variable(value);
     if (!unguarded( (: write_file($(file), $(tmp), 1) :))) {
        debug_printf("failed to write data to %s", file);
     }
     break;
   case CRAFT_SHOP_REMOVE_DATA_SAVE_FILE :
#ifdef USE_RAMDISK
     file = replace_string(query_craft_shop_save_dir() + "/" + fname, "/save/",
                          "/save/ramdisk/");
     unguarded( (: rm($(file)) :) );
#endif
     unguarded((: rm(query_craft_shop_save_dir() + "/" + $(fname)) :));
     break;
   default :
     printf("Unknown file type to write in %O, of %O\n", __FILE__, type);
     break;
   }
}
protected string do_read_file(int type, string fname) {
   string tmp, file;
   switch (type) {
   case CRAFT_SHOP_MAIN_SAVE_FILE :
#ifdef USE_RAMDISK
     tmp = replace_string(query_craft_shop_save_dir(), "/save/",
                          "/save/ramdisk/");
     if(unguarded((: file_size($(tmp) + ".o") :)) > 0) {
       file = tmp + ".o";
     }
#endif
     if(!file) {
       tmp = query_craft_shop_save_dir();
       if(unguarded((: file_size($(tmp) + ".o") :)) > 0) {
         file = tmp + ".o";
       }
       if(unguarded((: file_size($(tmp) + ".o.bak") :)) > 0) {
         file = tmp + ".o.bak";
       }
     }
     if (!file) {
        debug_printf("No file found at %s or %s\n", tmp + ".o", tmp + ".o.bak");
        return 0;
     }
     tmp = unguarded( (: read_file($(file)) :) );
     if(tmp)
       return restore_variable(tmp);
     return 0;
   case CRAFT_SHOP_DATA_SAVE_FILE :
#ifdef USE_RAMDISK
     tmp = replace_string(query_craft_shop_save_dir() + "/" + fname,
                           "/save/", "/save/ramdisk/");
     if(unguarded((: file_size($(tmp)) :)) > 0)
       file = tmp;
#endif
     if(!file)
       file = query_craft_shop_save_dir() + "/" + fname;
     debug_printf("reading %s", file);
     tmp = unguarded( (: read_file($(file)) :) );
     if (tmp) {
       return restore_variable(tmp);
     }
     return 0;
   default :
     printf("Unknown file type to read in %O, of %O\n", __FILE__, type);
     break;
   }
}
void reload_shop() {
   set_controller("/std/shops/controllers/craft_shop_controller");
   _controller->load_it();
}
void set_controller(string name) {
   if (_controller) {
      _controller->dest_me();
   }
   _controller = clone_object(name);
   _controller->set_save_function((: do_save_file($1, $2, $3) :));
   _controller->set_load_function((: do_read_file($1, $2) :) );
}
object query_controller() {
   return _controller;
}
void set_save_dir(string fname) {
   _save_dir_name = fname;
}
string query_craft_shop_save_dir() {
   return _save_dir_name;
}
void set_allowed_to_sell(function func) {
   _allowed_to_sell = func;
}
function query_allowed_to_sell() {
   return _allowed_to_sell;
}
void set_max_sell_per_person(int num) {
   _max_sell_per_person = num;
}
int query_max_sell_per_person() {
   return _max_sell_per_person;
}
void set_always_ask_price(int ask_price) {
   _always_ask_price = ask_price;
}
int query_always_ask_price() {
   return _always_ask_price;
}
void set_use_name(int flag) {
   _use_name = flag;
}
int query_use_name() {
   return _use_name;
}
int query_maximum_sale_value(string person, object *obs) {
   return 0;
}
string query_extra_price_information(string person, object *obs) {
   return "";
}
int query_shop() {
   return 1;
}
object *query_shop_lift_items(string str, object player) {
   object *stuff;
   object *pk_ok;
   object ob;
   stuff = match_objects_for_existence(str, ({ _controller->query_sell_list() }));
   pk_ok = ({ });
   foreach (ob in stuff) {
      if (!pk_check(_controller->query_owner_of_shop_object(ob),
                      player, 1)) {
         pk_ok += ({ ob });
      }
   }
   if (sizeof(pk_ok) != sizeof(stuff)) {
      player->add_failed_mess(previous_object(),
                      "You cannot shoplift $I since you cannot "
                      "shoplift from non-player killers.\n", stuff);
   }
   return pk_ok;
}
void inform_of_buy(int value, object *obs, object player, string *sellers,
                   string *names, string *cats, int *values) {
}
int query_no_steal() {
   return 1;
}
int is_able_to_change(object ob) {
   return _controller->query_owner_of_shop_object(ob) ==
       this_player()->query_name();
}
int is_allowed_to_sell(object* obs, string name, string *sellable_names) {
   if ((sizeof(sellable_names)+sizeof(obs)) > query_max_sell_per_person() &&
       query_max_sell_per_person()) {
      add_failed_mess("Cannot sell $I, since you already have " +
                      number_as_string(sizeof(sellable_names)) +
                      " items listed with a maximum of " +
                      number_as_string(query_max_sell_per_person()) +
                      ".\n", obs);
      return 0;
   }
   return 1;
}
void init() {
   string storeroom;
   add_command("sell", "<indirect:object:me>");
   add_command("list", "");
   if (query_controller()) {
      storeroom = file_name(_controller->query_sell_list());
      add_command("buy", "<indirect:object:" + storeroom + ">",
                  (: do_buy($1, 0) :));
      add_command("browse", "<indirect:object:" + storeroom + ">",
                  (: do_browse($1) :));
      add_command("change", "price of <indirect:object:" + storeroom +
                            "> to <string>", (: do_change($1, $4[1]) :));
      add_command("change", "name of <indirect:object:" + storeroom +
                            "> to <string>", (: do_change_name($1, $4[1]) :));
   }
   if (!_no_royalty_commands) {
      add_command("collect", "royalties");
      add_command("royalties", "");
   }
   add_command("delete", "<string'sell id'>",
               (: do_delete($4[0]) :));
}
int do_sell_id(object* obs, string id, int force) {
   object *sellable;
   object *cannot;
   object *worn;
   string name;
   string *sellable_names;
   if (!check_open(this_player(), "sell")) {
      return 0;
   }
   sellable = filter(obs, query_allowed_to_sell());
   if (!sizeof(sellable)) {
      add_failed_mess("This shop does not deal in $I.\n", obs);
      return 0;
   }
   worn = this_player()->query_holding() + this_player()->query_armours();
   cannot = filter(sellable, (: member_array($1, $2) != -1 :), worn);
   if (sizeof(cannot)) {
       sellable -= cannot;
       tell_object(this_player(), "You decide not to sell " +
         query_multiple_short(cannot, "the") + ", because "
         "you are wearing or holding $V$0=it,them$V$.\n");
      if (!sizeof(sellable))  return 0;
   }
   name = this_player()->query_name();
   if (!is_allowed_to_sell(sellable, name, sellable_names)) {
      return 0;
   }
   if (query_cut() != 100) {
      write("Selling an item to this shop does not automatically give you the "
            "money.  You will get a cut of " + (100 - query_cut()) +
            "% of the sale price once the item has been sold by the shop.\n");   }
}
int do_sell(object *obs) {
   object *sellable;
   object *cannot;
   object *worn;
   string name;
   string *sellable_names;
   int i;
   int cost;
   string place;
   if (!check_open(this_player(), "sell")) {
      return 0;
   }
   sellable = filter(obs, query_allowed_to_sell());
   if (!sizeof(sellable)) {
      add_failed_mess("This shop does not deal in $I.\n", obs);
      return 0;
   }
   worn = this_player()->query_holding() + this_player()->query_armours();
   cannot = filter(sellable, (: member_array($1, $2) != -1 :), worn);
   if (sizeof(cannot)) {
       sellable -= cannot;
       tell_object(this_player(), "You decide not to sell " +
         query_multiple_short(cannot, "the") + ", because "
         "you are wearing or holding $V$0=it,them$V$.\n");
      if (!sizeof(sellable))  return 0;
   }
   name = this_player()->query_name();
   if (!is_allowed_to_sell(sellable, name, sellable_names)) {
      return 0;
   }
   if (query_cut() != 100) {
      write("Selling an item to this shop does not automatically give you the "
            "money.  You will get a cut of " + (100 - query_cut()) +
            "% of the sale price once the item has been sold by the shop.\n");
   }
   if (_use_name) {
      sell_name(query_multiple_short(sellable, 0, 1), sellable);
      add_succeeded_mess(({ "", "$N starts to sell $I to the shop.\n" }),
                         sellable);
      return 1;
   }
   obs->set_no_join();
   sellable_names = _controller->query_owner_sellables(name);
   sellable_names = uniq_array(sellable_names);
   if (!sizeof(sellable_names)) {
      write("You are not currently selling any items.  What item name "
            "would you like to list " + query_multiple_short(sellable) +
            " under?  (Blank line to quit)\nList name: ");
      input_to((: sell_name :), 0, sellable);
   } else {
      place = query_property("place");
      if (!place) {
         place = "default";
      }
      write("You currently have the following listed for sale:\n");
      for (i = 0; i < sizeof(sellable_names); i++) {
         cost = _controller->query_list_object_cost(sellable_names[i],
                                   this_player()->query_name());
         write(sprintf("  %c) %s (%s)\n", 'a' + i, sellable_names[i],
                       MONEY_HAND->money_value_string(cost, place)));
      }
      write("Select the letter of the choice to add to the item, or type "
            "'create' to create a new listing name.\n"
            "Your choice ([a-" + sprintf("%c", 'a' + sizeof(sellable_names) -1) +
            "],create) ? ");
      input_to((: sell_choice :), 0, sellable, sellable_names);
   }
   add_succeeded_mess(({ "", "$N starts to sell $I to the shop.\n" }),
                      sellable);
   return 1;
}
protected int check_sell_name( string name ) {
   if (strlen(name) > CRAFT_SHOP_MAX_NAME_LENGTH) {
      write("Sorry, that name is too long.  It can be a maximum of " +
            CRAFT_SHOP_MAX_NAME_LENGTH + " characters.\n");
      return 0;
   }
   if (strsrch(name, "%^") != -1) {
      write("Sorry, you cannot use colour sequences in names.\n");
      return 0;
   }
   return 1;
}
protected void sell_name(string name, object *sellable) {
   if (name == "" || name == 0) {
      write("Ok, cancelling the sale of " + query_multiple_short(sellable) +
            ".\n");
      return ;
   }
   if ( !check_sell_name( name ) ) {
      input_to((: sell_name :), 0, sellable);
      write("What name would you like to list " +
            query_multiple_short(sellable) + " under? ");
      return;
   }
   write("You wish to sell " + query_multiple_short(sellable) +
         " as '" + name + "' (y/n)? ");
   input_to((: confirm_sell_name_choice :), 0, name, sellable);
}
protected void confirm_sell_name_choice(string answer, string name,
                                        object *sellable) {
   answer = lower_case(answer);
   if (strlen(answer) > 0 && ( answer[0] == 'n' || answer[0] == 'q' ) ) {
      write("Ok, cancelling the sale of " + query_multiple_short(sellable) +
            ".\n");
      return ;
   }
   if (!strlen(answer) || answer[0] != 'y') {
      write("Unknown selection.\n");
      write("You wish to sell " + query_multiple_short(sellable) +
            " as '" + name + "' (y/n)? ");
      input_to( (: confirm_sell_name_choice :), 0, name, sellable);
      return ;
   }
   write(query_extra_price_information(this_player()->query_name(), sellable));
   write("How much money do you wish to sell the item '" + name + "' for? ");
   input_to((: determine_cost :), 0, name, sellable);
}
protected void sell_choice(string answer, object *sellables, string *names) {
   int cost;
   string place;
   int pos;
   if (sizeof(names) >= 17) {
      if (answer == "" || answer[0..1] == "qu") {
         write("Ok, cancelling the sale of " + query_multiple_short(sellables) +
             ".\n");
         return 0;
      }
   } else if (answer == "" || answer[0] == 'q') {
      write("Ok, cancelling the sale of " + query_multiple_short(sellables) +
            ".\n");
      return ;
   }
   answer = lower_case(answer);
   if (answer == "create") {
      write("Please enter the name you wish to list " +
            query_multiple_short(sellables) + " as.\nList name: ");
      input_to((: sell_name :), 0, sellables);
      return ;
   }
   if (strlen(answer) > 1 ||
       (answer[0] < 'a' || answer[0] >= 'a' + sizeof(names))) {
      write(sprintf("Your response must be between 'a' and '%c' or "
                    "'create'.\nChoice? ", 'a' + sizeof(names) - 1));
      input_to((: sell_choice :), 0, sellables, names);
      return ;
   }
   pos = answer[0] - 'a';
   cost = _controller->query_list_object_cost(names[pos],
                                              this_player()->query_name());
   if (!cost || _always_ask_price) {
      write("How much money do you wish to list the item '" + names[pos] +
            "' for? ");
      write(query_extra_price_information(this_player()->query_name(),
                                          sellables));
      input_to((: determine_cost :), 0, names[pos], sellables);
   } else {
      place = query_property("place");
      if (!place) {
         place = "default";
      }
      do_confirm_sale(cost, names[pos], sellables);
   }
}
protected void determine_cost(string cost, string name, object *sellable) {
   int max;
   int value;
   string place;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   value = value_from_string(cost, place);
   if (value < _minimum_cost) {
      if (!strlen(cost) ||
          lower_case(cost)[0] == 'q') {
         write("Aborting.\n");
         return ;
      }
      write("You must list your item as costing more than " +
            MONEY_HAND->money_value_string(_minimum_cost, place) + ".\n");
      write(query_extra_price_information(this_player()->query_name(),
                                          sellable));
      write("What do you wish to list " + name + " for? ");
      input_to("determine_cost", 0, name, sellable);
      return ;
   }
   max = query_maximum_sale_value(this_player()->query_name(), sellable);
   if (value > max && max) {
      write("You must list your item as costing less than " +
            MONEY_HAND->money_value_string(max, place) + ".\n");
      write(query_extra_price_information(this_player()->query_name(),
                                          sellable));
      write("What do you wish to list " + name + " for? ");
      input_to("determine_cost", 0, name, sellable);
      return ;
   }
   do_confirm_sale(value, name, sellable);
}
private void confirm_sale_question(int value,
                                   string name,
                                   object *sellables,
                                   string category) {
   string place;
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   write("Confirming your sale of " + query_multiple_short(sellables) +
         " as '" + name +
         "' " + (category?"in category " + category + " ":"") +
         "for " + MONEY_HAND->money_value_string(value, place) + " (y/n)? ");
   input_to((: confirm_sale :), 0, value, name, sellables, category);
}
protected void do_confirm_sale(int value, string name, object *sellables) {
   if (_extra_sell_check) {
      evaluate(_extra_sell_check,
               (: confirm_sale_question :),
               value, name, sellables);
   } else {
      confirm_sale_question(value, name, sellables, 0);
   }
}
protected void confirm_sale(string answer, int value, string name,
                            object *sellable,
                            string category) {
   if (answer == "" || answer[0] == 'q' || answer[0] == 'Q' ||
       answer[0] == 'n' || answer[0] == 'N') {
      write("Ok, aborting sale of " + query_multiple_short(sellable) + ".\n");
      return 0;
   }
   if (answer[0] != 'y' && answer[0] != 'Y') {
      write("Please answer yes or no.\n");
      confirm_sale_question(value, name, sellable, category);
      return 0;
   }
   complete_sale(value, name, sellable, category);
}
protected void complete_sale(int value, string name, object *sellable,
                             string category) {
   object *bought;
   string place;
   object ob;
   if (_when_sold_func) {
      foreach (ob in sellable) {
         evaluate(_when_sold_func, ob);
      }
   }
   bought = _controller->buy_objects(sellable, name, value,
                                   this_player()->query_cap_name(), category);
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   if (sizeof(bought)) {
      write("Sold " + query_multiple_short(bought) + ", listed as '" +
            name + "' " + (category?"in category " + category + " ":"") +
            "for " + MONEY_HAND->money_value_string(value, place) +
            ".\nYou will need to come back later to pick up your royalties "
            "for the sale.\n");
      say(this_player()->query_cap_name() + " sold " +
          query_multiple_short(bought) + " to " + the_short() + ".\n");
   } else {
      write("Unable to sell " + query_multiple_short(sellable) + ".\n");
   }
}
int do_list() {
   string place;
   object *obs;
   object ob;
   mixed *stuff;
   string ret;
   if (!check_open(this_player(), "list")) {
      return 0;
   }
   obs = _controller->query_sell_list_obs();
   if (!sizeof(obs)) {
      add_failed_mess("The shop is empty.\n", ({ }));
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   stuff = unique_array(obs, (: _controller->query_id_of_shop_object($1) :) );
   stuff = sort_array(stuff, (:
                strcmp(_controller->query_id_of_shop_object($1[0]),
                       _controller->query_id_of_shop_object($2[0])) :) );
   ret = "";
   foreach (obs in stuff) {
      ob = obs[0];
      ret += "$I$9=$C$" + _controller->query_id_of_shop_object(ob) +
            ") $C$" + ob->short() + " for " +
            MONEY_HAND->money_value_string(ob->query_value(), place) + "; " +
            query_num(sizeof(obs)) + " left.\n";
   }
   write("$P$Shop list$P$" + ret);
   add_succeeded_mess( ({ "", "$N browses through the inventory.\n" }) );
   return 1;
}
int do_buy(object *obs, int force) {
   int value;
   string place;
   int player_money;
   object *bought;
   string *sellers;
   string *names;
   string *cats;
   int *values;
   if (!check_open(this_player(), "buy")) {
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   player_money = this_player()->query_value_in(place);
   value = _controller->value_of_objects(obs);
   if (value > player_money) {
      add_failed_mess("You cannot buy $I as "+
                      ( sizeof( obs ) > 1 ? "they cost ":"it costs " )+
                      MONEY_HAND->money_value_string(value, place) +
                      " and you do not have that much money.\n", obs );
      return 0;
   }
   sellers = map(obs, (: _controller->query_owner_of_shop_object($1) :));
   names = map(obs, (: _controller->query_name_of_shop_object($1) :));
   cats = map(obs, (: _controller->query_category_of_shop_object($1) :));
   values = map(obs, (: $1->query_value() :));
   bought = _controller->sell_objects(obs, place, this_player(),
                                     query_cut(), force, ref value);
   if (!sizeof(bought)) {
      if (sizeof(bought) > 1) {
         add_failed_mess("Cannot move any of $I into your inventory, nothing "
                         "bought.\n", obs);
      } else {
         add_failed_mess("Unable to find any objects to buy, the shop "
                         "seems to have some stock problems.\n");
      }
      return 0;
   }
   inform_of_buy(value, bought, this_player(), sellers, names, cats, values);
   add_succeeded_mess(({ "You buy $I for " +
                       MONEY_HAND->money_value_string(value, place) + ".\n",
                         "$N buys $I.\n" }), bought);
   return 1;
}
int do_delete(string id ) {
   if( !this_player()->query_director() ) {
      add_failed_mess( "This command is reserved for directors.\n", ({ }) );
      return 0;
   }
   if( !id || id == "" ) {
      add_failed_mess( "You have to choose a valid sell id.\n", ({ }) );
      return 0;
   }
   _controller->delete_objects(id);
   add_succeeded_mess( "$N $V some things.\n", ({ }) );
   return 1;
}
int do_browse(object *obs) {
   object *real_obs;
   object ob;
   string mess;
   string read;
   if (!check_open(this_player(), "browse")) {
      return 0;
   }
   if (sizeof(obs) > 10) {
      add_failed_mess("You cannot browse more than 10 things at once.\n");
      return 0;
   }
   real_obs = _controller->create_all_real_objects(this_player(), obs);
   mess = "$P$Browse$P$";
   foreach (ob in real_obs) {
      mess += ob->the_short() + ":\n" + ob->long();
      read = ob->query_readable_message();
      if (read) {
         mess += "You read " +
                 replace(ob->query_read_short(this_player()), "$name$",
                         ob->a_short()) + ":\n" +
                 ob->query_readable_message();
      }
   }
   real_obs->move("/room/rubbish");
   add_succeeded_mess(({ mess, "$N $V $I.\n" }), obs);
   return 1;
}
int do_change(object *obs, string change) {
   object *frog;
   int value;
   string place;
   if (!check_open(this_player(), "change")) {
      return 0;
   }
   frog = filter(obs, (: $1->short() == $2->short() :), obs[0]);
   if (sizeof(frog) != sizeof(obs)) {
      add_failed_mess("You cannot change the value of more than one "
                      "type of object at once.\n", obs);
      return 0;
   }
   if (!is_able_to_change(obs[0])) {
      add_failed_mess("You do not own $I.\n", obs);
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   value = value_from_string(change, place);
   if (value < _minimum_cost) {
      add_failed_mess("You cannot set $I to a value less than " +
                 MONEY_HAND->money_value_string(_minimum_cost, place) + ".\n",
                 obs);
      return 0;
   }
   _controller->change_value_of_shop_object(obs[0], value);
   add_succeeded_mess( ({ "You change the value of $I to " +
         MONEY_HAND->money_value_string(value, place) + ".\n",
         "$N changes the value of $I.\n" }), obs[0..0]);
   return 1;
}
int do_change_name(object *obs, string new_name) {
   object *frog;
   if (!check_open(this_player(), "change")) {
      return 0;
   }
   frog = filter(obs, (: $1->short() == $2->short() :), obs[0]);
   if (sizeof(frog) != sizeof(obs)) {
      add_failed_mess("You cannot change the value of more than one "
                      "type of object at once.\n", obs);
      return 0;
   }
   if (!is_able_to_change(obs[0])) {
      add_failed_mess("You do not own $I.\n", obs);
      return 0;
   }
   if( !check_sell_name( new_name ) ) {
      add_failed_mess( "Try another name.\n", ({ }) );
      return 0;
   }
   if (_controller->change_name_of_shop_object(obs[0], new_name,
                               _controller->query_dont_use_name())) {
      add_succeeded_mess(({ "You change the name of $I to " +
                               new_name + ".\n",
                               "$N changes the name of $I.\n" }),
                         ({ obs[0] }) );
   } else {
      add_failed_mess("The name " + new_name + " is already in use.\n", obs);
   }
   return 1;
}
int do_collect() {
   string name;
   string place;
   int value;
   if (!check_open(this_player(), "collect")) {
      return 0;
   }
   name = this_player()->query_name();
   value = _controller->query_royalty(name);
   if (!value) {
      add_failed_mess("You have no money owed to you here.\n");
      return 0;
   }
   if (value < 0) {
      add_failed_mess("You owe money to " + the_short() + ".\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   _controller->pay_out_royalty(name, place);
   log_file(__FILE__ + ".log",
            name + " collects " +
                      MONEY_HAND->money_value_string(value, place) +
                      " in royalties.\n");
   add_succeeded_mess(({ "You collect " +
                      MONEY_HAND->money_value_string(value, place) +
                      " in royalties.\n",
                      "$N collects some money in royalties.\n" }));
   return 1;
}
int do_royalties() {
   string name;
   string place;
   int value;
   if (!check_open(this_player(), "royalties")) {
      return 0;
   }
   name = this_player()->query_name();
   value = _controller->query_royalty(name);
   if (!value) {
      add_failed_mess("You have no money owed to you here.\n");
      return 0;
   }
   if (value < 0) {
      add_failed_mess("You owe money to " + the_short() + ".\n");
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   add_succeeded_mess(({ "You have " +
                      MONEY_HAND->money_value_string(value, place) +
                      " in royalties currently.\n",
                      "$N checks $p royalties.\n" }));
   return 1;
}
void set_cut(int new_cut) {
   _cut = new_cut;
}
int query_cut() {
   return _cut;
}
void set_minimum_cost(int cost) {
   _minimum_cost = cost;
}
int query_minimum_cost() {
   return _minimum_cost;
}
void set_when_sold_function(function func) {
   _when_sold_func = func;
}
function query_when_sold_function() {
   return _when_sold_func;
}
int check_open(object player, string type) {
   if (!is_open(player, 0)) {
      add_failed_mess("The shop is not open.\n");
      return 0;
   }
   return 1;
}
void set_extra_sell_check(function func) {
   _extra_sell_check = func;
}
function query_extra_sell_check() {
   return _extra_sell_check;
}
void set_no_royalty_commands(int flag) {
   _no_royalty_commands = flag;
}
int query_no_royalty_commands() {
   return _no_royalty_commands;
}
void dest_me() {
  if(_controller) {
     _controller->dest_me();
  }
}

==================================================
FILE: /lib/std/shops/inherit/craft_shop_category.c
==================================================

#include <money.h>
#include <shops/craft_shop.h>
inherit "/std/shops/inherit/craft_shop";
private nosave function _cat_extra_sell_check;
private string _default_category;
#define DAY (24 * 60 * 60)
protected void setup_category(function func,
                              int value,
                              string name,
                              object* sellables);
protected void choose_category(string category,
                              function func,
                              int value,
                              string name,
                              object* sellables,
                              string* categories);
int do_list_category(string category);
int do_change_category(object* obs, string category);
void create() {
   ::set_extra_sell_check( (: setup_category :) );
   if (!_default_category) {
      _default_category = "General";
   }
   ::create();
}
void init() {
   string storeroom;
   ::init();
   if (query_controller()) {
      storeroom = file_name(query_controller()->query_sell_list());
      add_command("change", "category of <indirect:object:" + storeroom +
                            "> to <string'category'>",
                  (: do_change_category($1, $4[1]) :));
   }
   add_command("list", "<string'category'>", (: do_list_category($4[0]) :));
}
void add_shop_category(string category) {
   query_controller()->add_category_accepted(category);
}
void set_category_description(string category, string description) {
   query_controller()->set_category_description(category, description);
}
void set_category_information(string category, string information) {
   query_controller()->set_category_information(category, information);
}
void remove_shop_category(string category) {
   query_controller()->remove_category_accepted(category);
}
private void setup_default_category() {
   if (!query_controller()->is_valid_category(_default_category) &&
       _default_category) {
      add_shop_category(_default_category);
   }
}
string query_default_category() {
   return _default_category;
}
void set_controller(string name) {
   ::set_controller(name);
   setup_default_category();
}
void update_categories() {
   object *obs;
   object ob;
   obs = query_controller()->query_sell_list_obs();
   foreach (ob in obs) {
      if (!query_controller()->query_category_of_shop_object(ob)) {
         query_controller()->change_category_of_shop_object(ob, _default_category);
      }
   }
}
string query_real_category_name(string in_cat) {
   string* categories;
   string cat;
   categories = query_controller()->query_categories();
   foreach (cat in categories) {
      if (lower_case(cat)[0..strlen(in_cat)-1] == lower_case(in_cat)) {
          return cat;
      }
   }
   return 0;
}
protected void setup_category(function func,
                              int value,
                              string name,
                              object* sellables) {
   string* categories;
   string cat;
   int i;
   cat = query_controller()->query_category_of(name,
                                               this_player()->query_name());
   if (cat) {
      evaluate(func, value, name, sellables, cat);
   } else {
      categories = query_controller()->query_categories();
      if (sizeof(categories) == 1) {
         write("There is only category, putting it into the default " +
               categories[0] + ".\n");
         evaluate(func, value, name, sellables, categories[0]);
      } else {
         write("Categories:\n");
         for (i = 0; i < sizeof(categories); i++) {
            write(sprintf("%c) %s\n", i + 'A', categories[i]));
         }
         write("Which category do you wish to put '" + name + "' into? ");
         input_to((: choose_category :),
                  0,
                  func,
                  value,
                  name,
                  sellables,
                  categories);
      }
   }
}
private void complete_cat_sale(int value,
                               string name,
                               object* sellables,
                               string category,
                               function func) {
   evaluate(func, value, name, sellables, category);
}
protected void choose_category(string category,
                              function func,
                              int value,
                              string name,
                              object* sellables,
                              string* categories) {
   string real_category;
   if (!strlen(category)) {
      write("Ok, stopping the sell.\n");
      return ;
   }
   if (strlen(category) == 1) {
      category = lower_case(category);
      if (category[0] < 'a' ||
          category[0] >= 'a' + sizeof(categories)) {
         write("Sorry, " + category + " is out of range.  Try again.\n");
         write("Which category do you wish to put '" + name + "' into? ");
         input_to((: choose_category :),
                  0,
                  func,
                  value,
                  name,
                  sellables,
                  categories);
         return ;
      } else {
         real_category = categories[category[0] - 'a'];
      }
   } else {
      real_category = query_real_category_name(category);
      if (!real_category) {
         write("Sorry, " + category + " is not a category.\n");
         write("Which category do you wish to put '" + name + "' into? ");
         input_to((: choose_category :),
                  0,
                  func,
                  value,
                  name,
                  sellables,
                  categories);
         return ;
      }
   }
   if (!real_category) {
      setup_category(func, value, name, sellables);
   } else {
      if (_cat_extra_sell_check) {
         evaluate(_cat_extra_sell_check,
                  (: complete_cat_sale :),
                  value, name, sellables, real_category, func);
      } else {
         complete_cat_sale(value, name, sellables, real_category, func);
      }
   }
}
int do_list_category(string category) {
   string place;
   string info;
   object *obs;
   object ob;
   mixed *morestuff;
   string ret;
   string list;
   if (!check_open(this_player(), "list")) {
      return 0;
   }
   list = query_real_category_name(category);
   if (!list ||
       !query_controller()->is_valid_category(list)) {
      add_failed_mess("The category " + category + " does not exist.\n");
      return 0;
   }
   info = query_controller()->query_category_information(list);
   obs = query_controller()->query_sell_list_obs();
   if (!sizeof(obs)) {
      add_failed_mess("The shop is empty.\n", ({ }));
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   obs = filter(obs, (: query_controller()->query_category_of_shop_object($1)  == $2:), list );
   ret = "";
   ret += list + ":\n";
   if (info) {
      ret += "$I$3=" + info + "\n";
   }
   morestuff = unique_array(obs, (: query_controller()->query_id_of_shop_object($1) :));
   morestuff = sort_array(morestuff, (:
                strcmp(query_controller()->query_id_of_shop_object($1[0]),
                       query_controller()->query_id_of_shop_object($2[0])) :) );
   foreach (obs in morestuff) {
      ob = obs[0];
      ret += "$I$9=$C$   " + query_controller()->query_id_of_shop_object(ob) +
            ") $C$" + ob->short() + " for " +
            MONEY_HAND->money_value_string(ob->query_value(), place) + "; " +
            query_num(sizeof(obs)) + " left.\n";
   }
   write("$P$Shop list" + list + "$P$" + ret);
   add_succeeded_mess( ({ "", "$N browses through the inventory.\n" }) );
   return 1;
}
int do_list() {
   string place;
   object *obs;
   mixed *stuff;
   mixed *morestuff;
   string ret;
   string* categories;
   string cat;
   string desc;
   object ob;
   if (!check_open(this_player(), "list")) {
      return 0;
   }
   obs = query_controller()->query_sell_list_obs();
   if (!sizeof(obs)) {
      add_failed_mess("The shop is empty.\n", ({ }));
      return 0;
   }
   place = query_property("place");
   if (!place) {
      place = "default";
   }
   categories = query_controller()->query_categories();
   stuff = unique_array(obs, (: query_controller()->query_category_of_shop_object($1) :), 12 );
   ret = "";
   foreach (obs in stuff) {
      if (!query_controller()->query_category_of_shop_object(obs[0])) {
         cat = "No category";
         foreach (ob in obs) {
            query_controller()->change_category_of_shop_object(ob,
                              query_default_category());
         }
         cat = query_default_category();
      } else {
         cat = query_controller()->query_category_of_shop_object(obs[0]);
         categories -= ({ query_controller()->query_category_of_shop_object(obs[0]) });
         desc = query_controller()->query_category_description(cat);
      }
      morestuff = unique_array(obs, (: query_controller()->query_id_of_shop_object($1) :));
      ret += "$I$3=" + cat + ": " + sizeof(morestuff) +
             " different item" + (sizeof(morestuff)>1?"s":"") + " for sale.\n";
      if (desc) {
         ret += "$I$6=   " + desc + "\n";
      }
   }
   if (sizeof(categories) > 1) {
      ret += "$I$0=The categories " + query_multiple_short(categories) +
             " do not have anything for sale.\n";
   } else if (sizeof(categories)) {
      ret += "$I$0=The category " + query_multiple_short(categories) +
             " does not have anything for sale.\n";
   }
   ret += "\n$I$0=Please list each category for the items in the category.\n";
   write("$P$Shop list$P$" + ret);
   add_succeeded_mess( ({ "", "$N browses through the inventory.\n" }) );
   return 1;
}
int do_change_category(object *obs, string new_category) {
   object *frog;
   if (!check_open(this_player(), "change")) {
      return 0;
   }
   frog = filter(obs, (: $1->short() == $2->short() :), obs[0]);
   if (sizeof(frog) != sizeof(obs)) {
      add_failed_mess("You cannot change the category of more than one "
                      "type of object at once.\n", obs);
      return 0;
   }
   if (!is_able_to_change(obs[0])) {
      add_failed_mess("You do not own $I.\n", obs);
      return 0;
   }
   new_category = query_real_category_name(new_category);
   if (!new_category ||
       !query_controller()->is_valid_category(new_category)) {
      add_failed_mess("You must choose a category that exists.\n");
      return 0;
   }
   if (query_controller()->change_category_of_shop_object(obs[0], new_category)) {
      add_succeeded_mess(({ "You change the category of $I to " +
                               new_category + ".\n",
                               "$N changes the category of $I.\n" }),
                         ({ obs[0] }) );
   } else {
      add_failed_mess("Unable to change to category " + new_category + ".\n", obs);
   }
   return 1;
}
void set_extra_sell_check(function func) {
   _cat_extra_sell_check = func;
}
function query_extra_sell_check() {
   return _cat_extra_sell_check;
}
void set_default_category(string category) {
  _default_category = category;
}

==================================================
FILE: /lib/std/shops/inherit/craft_shop_category_modify.c
==================================================

#include <money.h>
#include <shops/craft_shop.h>
inherit "/std/shops/inherit/craft_shop_category";
private nosave int _minimum_age_to_vote;
private nosave int _minimum_age_to_nominate;
private nosave int _minimum_number_nominated;
private nosave int _minimum_number_voted;
private nosave int _percentage_needed_creation;
private nosave int _percentage_needed_deletion;
private nosave int _nomination_time;
private nosave int _election_time;
private nosave int _deletion_time;
#define DAY (24 * 60 * 60)
protected void setup_category(function func,
                              int value,
                              string name,
                              object* sellables);
protected void choose_category(string category,
                              function func,
                              int value,
                              string name,
                              object* sellables,
                              string* categories);
void create() {
   if (!_minimum_age_to_vote) {
      _minimum_age_to_vote = 2 * DAY;
   }
   if (!_minimum_age_to_nominate) {
      _minimum_age_to_nominate = 10 * DAY;
   }
   if (!_minimum_number_nominated) {
      _minimum_number_nominated = 4;
   }
   if (!_nomination_time) {
      _nomination_time = 7 * DAY;
   }
   if (!_election_time) {
      _election_time = 7 * DAY;
   }
   if (!_deletion_time) {
      _deletion_time = 7 * DAY;
   }
   if (!_minimum_number_voted) {
      _minimum_number_voted = 20;
   }
   if (!_percentage_needed_creation) {
      _percentage_needed_creation = 75;
   }
   if (!_percentage_needed_deletion) {
      _percentage_needed_deletion = 75;
   }
   ::create();
}
protected int category_function(string name,
                      int state,
                      string* voted,
                      int yes,
                      int no,
                      int abstain) {
   switch (state) {
   case CRAFT_CATEGORY_STATE_NOMINATING :
      if (sizeof(voted) > _minimum_number_nominated) {
         return _election_time;
      }
      break;
   case CRAFT_CATEGORY_STATE_VOTING :
      if (sizeof(voted) > _minimum_number_voted) {
         if (yes * 100 / (no + yes) >= _percentage_needed_creation) {
            return 1;
         }
      }
      break;
   case CRAFT_CATEGORY_STATE_DELETEING :
      if (sizeof(voted) > _minimum_number_voted) {
         if (yes * 100 / (no + yes) >= _percentage_needed_deletion) {
            return 1;
         }
      }
   }
   return 0;
}
void set_minimum_age_to_vote(int age) {
   _minimum_age_to_vote = age;
}
void set_minimum_age_to_nominate(int age) {
   _minimum_age_to_nominate = age;
}
void set_minimum_nomination_number(int num) {
   _minimum_number_nominated = num;
}
void set_nomination_time(int tim) {
   _nomination_time = tim;
}
void set_election_time(int tim) {
   _election_time = tim;
}
void set_deletion_time(int tim) {
   _deletion_time = tim;
}
# Total Tokens: 25052
# Total Files Merged: 6
# Total Characters: 83525

