# Total Tokens: 15099
# Total Files Merged: 7
# Total Characters: 50351

==================================================

#include <access.h>
#include <mail.h>
#include <player_handler.h>
#include <login.h>
#include <playerinfo.h>
#include <playtesters.h>
#define TIMEOUT_TIME 2419200
nosave string *names;
mapping site_access;
mapping suspended;
mapping lockedout;
mapping multiuser;
mapping temp_passwords;
int query_access(object ob);
protected void timeout_access();
private void save_me();
void create() {
  seteuid("Root");
  site_access = ([ ]);
  suspended = ([ ]);
  lockedout = ([ ]);
  multiuser = ([ ]);
  temp_passwords = ([ ]);
  if(!unguarded((: restore_object, base_name(this_object()) :)))
    write("Failed to restore bastards.\n");
  if (!site_access) {
    write("mmm, no site access\n");
    site_access = ([ ]);
  }
  if(!lockedout)
    lockedout = ([ ]);
  if(!multiuser)
    multiuser = ([ ]);
  if(!temp_passwords) {
    temp_passwords = ([ ]);
  }
  timeout_access();
  if (find_object("/room/void"))
    move_object(find_object("/room/void"));
}
string query_player_ob(string name) {
  if("/secure/master"->query_administrator(name) ||
     "/secure/master"->query_lord(name))
    return "/global/lord";
  if (PLAYER_HANDLER->test_creator(name))
    return "/global/creator";
  if (PLAYTESTER_HAND->query_playtester(name))
    return "/global/playtester";
  return "/global/player";
}
int query_prevent_shadow() { return 1; }
mapping query_all_access() { return copy(site_access); }
int query_access(object ob) {
  string tmp;
  tmp = query_ip_number(ob);
  while(strlen(tmp)) {
    if(site_access[tmp])
      return site_access[tmp][ACCESS_LEVEL];
    tmp = implode((string *)explode(tmp, ".")[0..<2], ".");
  }
  tmp = query_ip_name(ob);
  while(strlen(tmp)) {
    if(site_access[tmp])
      return site_access[tmp][ACCESS_LEVEL];
    tmp = implode(explode(tmp, ".")[1..], ".");
  }
  return DEFAULT;
}
int query_multi(object ob) {
  string tmp;
  tmp = query_ip_number(ob);
  while(strlen(tmp)) {
    if(multiuser[tmp])
      return 1;
    tmp = implode((string *)explode(tmp, ".")[0..<2], ".");
  }
  tmp = query_ip_name(ob);
  while(strlen(tmp)) {
    if(multiuser[tmp])
      return 1;
    tmp = implode(explode(tmp, ".")[1..], ".");
  }
  return 0;
}
mapping query_all_multi() { return copy(multiuser); }
string query_reason(string address) {
  if(site_access[address])
    return site_access[address][ACCESS_REASON];
  return 0;
}
protected void add_multi(string address, int multi, int timeout) {
  if(!multi)
    map_delete(multiuser, address);
  else
    multiuser[address] = timeout;
}
protected void add_access(string address, int level, string reason,
                          int timeout) {
  site_access[address] = ({ level, reason, timeout });
}
protected void timeout_access() {
  string bit;
  foreach(bit in keys(site_access))
    if(site_access[bit][ACCESS_TIMEOUT] < time() ||
       site_access[bit][ACCESS_LEVEL] == ACCESS)
      map_delete(site_access, bit);
  foreach(bit in keys(multiuser))
    if(multiuser[bit] < time())
      map_delete(multiuser, bit);
}
private void save_me() {
  unguarded((: save_object, base_name(this_object()), 2 :));
}
int change_access(string address, int level, string reason, int timeout) {
  if(!master()->query_lord(previous_object(-1)) &&
     base_name(previous_object()) != "/cmds/creator/ban")
    return 0;
  if(!stringp(address) || !reason)
    return notify_fail("Invalid parameters.\n");
  if (!timeout)
    timeout = time() + 100 * 24 * 60 * 60;
  add_access(address, level, reason, timeout);
  save_me();
  unguarded((: write_file, "/log/ACCESS", ctime(time())[4..16] + " " +
             address+" set to " + PERM_NAMES[level] + " for " + reason +
             " until " + ctime(timeout) + " by "+
             this_player()->query_name()+".\n" :));
  return 1;
}
int change_multi(string address, int multi, int timeout) {
  if(!master()->query_lord(previous_object(-1)) &&
     base_name(previous_object()) != "/cmds/creator/multipl_ayer")
    return 0;
  if(!stringp(address))
    return notify_fail("Invalid parameters.\n");
  if (!timeout)
    timeout = time() + 100 * 24 * 60 * 60;
  add_multi(address, multi, timeout);
  save_me();
  unguarded((: write_file, "/log/ACCESS", ctime(time())[4..16] + " " +
             address+" set to " + (multi?"allow":"disallow") +
             " multiple users until " + ctime(timeout) + " by "+
             this_player()->query_name()+".\n" :));
  return 1;
}
int suspend_person(string str, int tim, string reason) {
  if (!master()->query_lord(previous_object(-1)) &&
      base_name(previous_object()) != "/cmds/creator/suspend") {
    return 0;
  }
  if (!PLAYER_HANDLER->test_user(str)) {
    return 0;
  }
  if (!reason) {
    reason = "you have been bad";
  }
  suspended[str] = ({ time() + tim, reason });
  save_me();
  unguarded((: write_file, "/log/SUSPEND", ctime(time())[4..16] + " " +
             str+" suspended until "+ ctime(time()+tim)+" by "+
             this_player()->query_name()+" because "+ reason + ".\n" :));
  PLAYERINFO_HANDLER->add_entry(this_player(), str, "suspend",
                                "Suspended until " + ctime(time() + tim) +
                                " for " + reason);
  return 1;
}
int unsuspend_person(string str) {
  if (!"/secure/master"->query_lord(previous_object(-1)) &&
      base_name(previous_object()) !="/cmds/creator/unsuspend") {
    return 0;
  }
  map_delete(suspended, str);
  unguarded((: save_object, base_name(this_object()), 2 :));
  unguarded((: write_file, "/log/SUSPEND",
             ctime(time())[4..16] + " " + str+" unsuspended.\n" :));
  PLAYERINFO_HANDLER->add_entry(this_player(), str, "suspend", "Unsuspended.");
  return 1;
}
mixed *query_suspended(string name) {
  if (suspended[name]) {
    if (suspended[name][SUSPEND_TIME] > time()) {
      return copy(suspended[name]);
    }
    map_delete(suspended, name);
    save_me();
  }
  return suspended[name];
}
int lockout_person(string str, int tim, string reason) {
  if (!master()->query_lord(previous_object(-1)) &&
      base_name(previous_object()) != "/cmds/player/lockout") {
    return 0;
  }
  if (!PLAYER_HANDLER->test_user(str)) {
    return 0;
  }
  if (!reason) {
    reason = "you have been bad";
  }
  lockedout[str] = ({ time() + tim, reason });
  save_me();
  unguarded((: write_file, "/log/LOCKOUT",
             ctime(time())[4..16] + " " + str+" lockedout until "+
             ctime(time()+tim)+" by "+this_player()->query_name()+" because "+
             reason + ".\n" :));
  PLAYERINFO_HANDLER->add_entry(this_player(), str, "lockedout",
                                "Locked out until " + ctime(time() + tim) +
                                " for " + reason);
  return 1;
}
mixed *query_lockedout(string name) {
  if (lockedout[name]) {
    if (lockedout[name][SUSPEND_TIME] > time()) {
      return copy(lockedout[name]);
    }
    map_delete(lockedout, name);
    save_me();
  }
  return lockedout[name];
}
int set_temp_password(string name, string pass) {
  temp_passwords[name] = ({ time(), pass });
  save_me();
  return 1;
}
mixed *query_temp_password(string name) {
  int found;
  string tmp;
  foreach(tmp in keys(temp_passwords)) {
    if(temp_passwords[tmp][0] < (time() - TIMEOUT_TIME)) {
      map_delete(temp_passwords, tmp);
      found = 1;
    }
  }
  if(found)
    save_me();
  return copy(temp_passwords[name]);
}
void clear_temp_password(string name) {
  if(temp_passwords[name]) {
    map_delete(temp_passwords, name);
    save_me();
  }
}

==================================================
FILE: bulk_delete.c
==================================================

#include <player_handler.h>
#include <mail.h>
#define ERASE_RATE 30
#define MIN_DELAY 604800
#define MAIL_UNREAD_TIME 15552000
#define MAIL_INACTIVE_TIME 31536000
#define ALPHABET ({ "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", \
                    "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", \
                    "w", "x", "y","z" })
#define SAVEFILE "/secure/bulk_delete.os"
#define FOLDER_H "/obj/handlers/folder_handler.c"
nosave string *dirs, current, fname;
nosave class mail_header *folder;
private void delete_name(string name);
private void check_name(string name);
protected void create() {
  string var;
  if (mud_name() != "Discworld") {
    return;
  }
  seteuid("Root");
  dirs = ({ });
  if (file_size(SAVEFILE) >= 0) {
    var = unguarded((: read_file, SAVEFILE :));
    dirs = restore_variable(var);
  }
  call_out("continuous_erase", 1);
}
protected void reset() {
  string var;
  var = save_variable(dirs);
  unguarded((: write_file, SAVEFILE, var, 1 :));
  if (find_call_out("continuous_erase") == -1) {
    call_out("continuous_erase", 1);
  }
}
protected void continuous_erase(string *all_files) {
  if (!sizeof(all_files)) {
    if(!sizeof(dirs)) {
      dirs = ALPHABET;
    }
    current = dirs[random(sizeof(dirs))];
    log_file("EXPIRED", "%s Starting letter %s\n", ctime(time()), current);
    dirs -= ({ current });
    all_files = get_dir(PLAYER_SAVE_DIR + current + "
  time_on = - PLAYER_HANDLER->test_age(name);
  last_log_on = PLAYER_HANDLER->test_last(name);
  if((time() - last_log_on) > MAIL_INACTIVE_TIME) {
    tmp = FOLDER_H->mail_count(name);
    if(tmp[0]) {
#ifdef DEBUG
      log_file("EXPIRED_DEBUG", "%s would have erased mail for %s\n",
               ctime(time()), name);
#else
      log_file("EXPIRED", "%s erased mail for %s\n", ctime(time()), name);
      FOLDER_H->delete_account(name);
    }
    return;
#endif
  }
  if(PLAYER_HANDLER->test_creator(name))
    return;
  if(PLAYER_HANDLER->test_property(name, "no delete"))
    return;
#ifdef DEBUG
  log_file("EXPIRED_DEBUG", "%s %s last logged in %s [%d] age x 60 [%d]\n",
           ctime(time()), name, ctime_elapsed(time() - last_log_on),
           time() - last_log_on, time_on * 60);
#endif
  if((time() - last_log_on) < MIN_DELAY)
    return;
  if((time() - last_log_on) > (time_on * 60)) {
#ifdef DEBUG
    log_file("EXPIRED_DEBUG", "%s would have erased: %s\n",
             ctime(time()), name);
#else
    delete_name(name);
    return;
#endif
  }
  if((time() - last_log_on) > MAIL_UNREAD_TIME) {
    tmp = FOLDER_H->mail_count(name);
    if(!tmp[1])
      return;
    folder = FOLDER_H->get_messages(name, "inbox");
    tmp = ({ });
    for(i=0; i<sizeof(folder); i++) {
      if(folder[i]->status == "N");
      tmp += ({ i });
      reset_eval_cost();
    }
    if(sizeof(tmp)) {
      FOLDER_H->delete_it(name, "inbox", tmp);
    }
  }
}
private void delete_name( string name ) {
  log_file("EXPIRED", "%s Timed out player deletion: %s\n", ctime(time()),
           name);
  fname = PLAYER_HANDLER->query_player_file_name(name);
  unguarded((: rm,  fname + ".o" :));
  unguarded((: rm, fname + ".o.gz" :));
#ifdef USE_RAMDISK
  fname = PLAYER_HANDLER->query_player_ram_file_name(name);
  unguarded((: rm,  fname + ".o" :));
  unguarded((: rm, fname + ".o.gz" :));
  fname = PLAYER_HANDLER->query_player_disk_file_name(name);
  unguarded((: rm,  fname + ".o" :));
  unguarded((: rm, fname + ".o.gz" :));
#endif
  "/secure/related_files"->delete_related_files(name, 1);
  PLAYER_HANDLER->remove_cache_entry(name);
}
int delete_files(string letter) {
  string *all_files;
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
               ": illegal attempt to delete timed out player files using "
               "/secure/bulk_delete.\nTrace: " + back_trace() :));
    return 0;
  }
  if (!master()->high_programmer(previous_object(-1))) {
    unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
               ": illegal attempt to delete timed out player files using "
               "/secure/bulk_delete.\nTrace: " + back_trace() :));
    return 0;
  }
  log_file("EXPIRED", "Manually Requested Processing of %s.\n", letter);
  current = letter;
  all_files = get_dir(PLAYER_SAVE_DIR+ letter +"
int clean_up_files(string dir) {
  int i;
  string *all_files = ({ });
  if (!sizeof(filter(previous_object(-1), (: interactive($1) :)))) {
    unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
               ": illegal attempt to delete unused files using "
               "/secure/bulk_delete.\nTrace: " + back_trace() :));
    return 0;
  }
  if (!master()->high_programmer(previous_object(-1))) {
    unguarded((: write_file, "/log/CHEAT", ctime( time() ) +
               ": illegal attempt to delete unused files using "
               "/secure/bulk_delete.\nTrace: " + back_trace() :));
    return 0;
  }
  switch (dir) {
  case "artifacts" :
    all_files = get_dir("/save/"+ dir +"*.o");
    break;
  case ".dead_ed_files" :
    all_files = get_dir("/w/.dead_ed_files/");
    break;
  default :
    return notify_fail("Invalid directory.\n");
  }
  all_files -= ({ ".", ".." });
  if (!sizeof(all_files)) {
    return notify_fail("Directory empty.\n");
  }
  for (i = sizeof(all_files) - 1; i > -1; i--) {
    switch (dir) {
    case "artifacts" :
      call_out((: check_name :), 5 * (i + 1), all_files[i]);
      break;
    case "mail" :
      call_out((: check_name :), 5 * (i + 1),
               explode(all_files[i], "inbox")[0]);
      break;
    case ".dead_ed_files" :
      call_out((: check_name :), 5 * (i + 1),
               explode(all_files[i], "-")[0]);
      break;
    default :
      call_out((: check_name :), 5 * (i + 1), all_files[i][0..<3]);
      break;
    }
  }
  return 1;
}
mixed *stats() {
  return ({
    ({ "current letter", current }),
    ({ "remaining dirs", sizeof(dirs) ? implode(dirs, ", ") : 0 })
  });
}

==================================================
FILE: command.c
==================================================

#include <command.h>
#include <user_parser.h>
private nosave mapping Commands, Cache;
private nosave string *Paths, *GRCommands;
private nosave string last_verb, last_args, found_cmd, found_args;
void eventRehash(string *paths);
void create() {
   seteuid(getuid());
   Commands = ([]);
   Cache = ([ ]);
   GRCommands = ({});
   Paths = ({});
   eventRehash( ({ DIR_PLAYER_CMDS, DIR_CREATOR_CMDS, DIR_SECURE_CREATOR_CMDS,
                   DIR_LORD_CMDS, DIR_LIVING_CMDS, DIR_GUILD_CMDS,
                   DIR_PLAYTESTER_CMDS }) );
}
void eventGuildRaceRehash() {
   string *paths, path;
   paths = ({ DIR_GUILD_CMDS });
   paths += map(filter(unguarded((: get_dir, DIR_GUILD_CMDS + "/", -1 :)),
                                 (: $1[1] == -2 :)),
                      (: DIR_GUILD_CMDS + "/" + $1[0] :));
   GRCommands = ({ });
   foreach (path in paths) {
      string *files, cmd;
      files = map(unguarded((: get_dir, path + "
void eventRehash(mixed paths) {
   string path;
   Cache = ([ ]);
   if (stringp(paths)) {
      paths = ({ paths });
   } else if (!pointerp(paths)) {
      return;
   }
   foreach(path in paths) {
      string file;
      if  ( path[<1..<1] == "/" ) continue;
      if (file_size(path) != -2)
         continue;
      if (path == DIR_GUILD_CMDS) {
         eventGuildRaceRehash();
         continue;
      }
      foreach (file in unguarded((: get_dir, path + "
void HandleCommandLine(class command cmd) {
   string args = cmd->args;
   int i;
   string* bits;
   if ((i = strsrch(args, " ")) != -1) {
      cmd->verb = args[0..i-1];
      cmd->args = args[i+1..];
   } else {
      cmd->verb = args;
      cmd->args = (string)0;
   }
}
int strncmp(string s1, string s2, int len) {
   return strcmp(s1[0..len-1], s2[0..len-1]);
}
int HandleStars(class command cmd) {
   int i;
   int no_cache;
   string file, *files;
   if(cmd->verb == "END_ALIAS")
     return 0;
   if(last_verb == cmd->verb && last_args == cmd->args) {
     cmd->verb = found_cmd;
     if(stringp(found_args)) {
       cmd->args = found_args;
     }
     return 1;
   }
   if(Cache[cmd->verb]) {
     if(stringp(Cache[cmd->verb][1]))
       cmd->args = Cache[cmd->verb][1];
     cmd->verb = Cache[cmd->verb][0];
     return 1;
   }
   if (Commands[cmd->verb]) {
     return 1;
   }
   files = keys(Commands);
   files = filter(files, (: (int)$1[0] == $(cmd)->verb[0] :));
   foreach (file in files) {
     string tmpverb, tmpargs = 0, tmpfile = 0;
     int len, length;
     if ((i = strsrch(file, "_")) == -1)
       continue;
     tmpfile = (string)delete(file, i, 1);
     len = strlen(tmpfile);
     if (i == len) {
       tmpargs = cmd->verb[i..]+(cmd->args?(strlen(cmd->verb) == i?"":" ") +
                                 cmd->args:"");
       tmpverb = cmd->verb[0..i-1];
       if (strncmp(tmpfile, tmpverb, len) != 0) {
         continue;
       }
       no_cache = 1;
     } else {
       length = strlen(cmd->verb);
       if ((length > len) || (length < i))
         continue;
       if (strncmp(cmd->verb, tmpfile, length) != 0)
         continue;
     }
     if (!no_cache) {
        Cache[cmd->verb] = ({ file, tmpargs });
     }
     last_verb = cmd->verb;
     last_args = cmd->args;
     cmd->verb = file;
     if (stringp(tmpargs))
       cmd->args = tmpargs;
     found_cmd = cmd->verb;
     found_args = tmpargs;
     return 1;
   }
   return 0;
}
int GetCommand(class command cmd, string *path) {
   string *tmp;
   int i;
   if (!stringp(cmd->args)) {
      return 0;
   }
   tmp = (path & Paths);
   if (sizeof(tmp = path - tmp)) {
      eventRehash(tmp);
   }
   HandleCommandLine(cmd);
   if (HandleStars(cmd) && Commands[cmd->verb] &&
       sizeof(tmp = (path & (string *)Commands[cmd->verb]))) {
      cmd->file = sprintf("%s/%s", tmp[0], cmd->verb);
      cmd->filepart = cmd->verb;
      if ((i = strsrch(cmd->verb, "_")) != -1) {
         cmd->verb = (string)delete(cmd->verb, i, 1);
      }
      if (cmd->args && cmd->args == "") {
         cmd->args = (string)0;
      }
      if ((cmd->file)->query_patterns()) {
         return 0;
      }
      return 1;
   }
   return 0;
}
mixed ReturnPatterns(class command cmd, string *path) {
   mixed *q_patterns;
   mixed *r_patterns;
   mixed *stuff;
   mixed *tmp;
   mixed *ret_patterns;
   int i, j;
   string fname;
   tmp = (path & Paths);
   tmp = path - tmp;
   if (sizeof(tmp)) {
      eventRehash(tmp);
   }
   if (HandleStars(cmd) && Commands[cmd->verb]) {
      tmp = (path & (string *)Commands[cmd->verb]);
      if (tmp) {
         ret_patterns = ({ });
         foreach (fname in tmp) {
            cmd->file = sprintf("%s/%s", fname, cmd->verb);
            q_patterns = (cmd->file)->query_patterns();
            if (!q_patterns) {
               return 0;
            }
            r_patterns = ({ });
            for (i = 0; i < sizeof(q_patterns); i += 2) {
               if (q_patterns[i+1] && !functionp(q_patterns[i+1])) {
                  continue;
               }
               stuff = (mixed *)PATTERN_OB->query_pattern(q_patterns[i]);
               j = 0;
               while (j < sizeof(r_patterns) &&
                         r_patterns[j][PATTERN_WEIGHT] >= stuff[0]) {
                  j++;
               }
               r_patterns = r_patterns[0..j-1] +
                  ({ ({ stuff[0], q_patterns[i], 0, find_object(cmd->file),
                           q_patterns[i+1] }) }) + r_patterns[j..];
            }
            ret_patterns += r_patterns;
         }
         return ret_patterns;
      }
   }
   return 0;
}
mixed *GetCommandPatterns(string cmd_name, string *path) {
   class command cmd;
   mixed *stuff;
   cmd = new(class command);
   cmd->verb = cmd_name;
   cmd->args = 0;
   stuff = ReturnPatterns(cmd, path);
   return stuff;
}
varargs string *GetCommands(string path) {
   string *paths, *tmp;
   string cmd;
   if (!path) {
      return keys(Commands);
   }
   tmp = ({ });
   foreach (cmd, paths in Commands) {
      if (member_array(path, paths) != -1) {
         tmp += ({ cmd });
      }
   }
   return tmp;
}
varargs string *GetPaths(string cmd) {
   if (cmd) {
      string *paths;
      class command tmp;
      if (sizeof(paths = Commands[cmd])) {
         return paths;
      }
      tmp = new(class command, verb : cmd);
      if (HandleStars(tmp)) {
         return Commands[tmp->verb];
      } else {
         return 0;
      }
   }
   return Paths;
}
int IsGRCommand(string cmd) {
   if (member_array(cmd, GRCommands) != -1) {
      return 1;
   } else {
      class command tmp = new(class command, verb : cmd);
      if (HandleStars(tmp)) {
         return (member_array(tmp->verb, GRCommands) != -1);
      }
   }
}

==================================================
FILE: delete_clear.c
==================================================

#include <player_handler.h>
#include <refresh.h>
#define ONE_DAY (60*60*24)
#define SAVE_FILE "/save/del_pl_check"
protected void do_checks();
protected void do_delete_check();
protected void do_appeal_check();
void create() {
  seteuid("Root");
  unguarded((: restore_object(SAVE_FILE) :));
  do_checks();
}
protected void do_checks() {
  unguarded((: do_delete_check() :));
  unguarded((: do_appeal_check() :));
  save_object(SAVE_FILE);
  call_out("do_checks", ONE_DAY);
}
protected  void do_delete_check() {
  string *bits, name;
  int i;
  mixed *rubbish;
  bits = get_dir(PLAYER_SAVE_DIR+DELETE_DIR+"/*.o");
  bits += get_dir(PLAYER_SAVE_DIR+DELETE_DIR+"/*.o.gz");
  for (i=0;i<sizeof(bits);i++) {
    rubbish = stat(PLAYER_SAVE_DIR+DELETE_DIR+"/"+bits[i]);
    if (rubbish[1]+(ONE_DAY*10) < time()) {
      log_file( "EXPIRED", "Requested player deletion: "+bits[ i ] +".\n" );
    name = explode( bits[i], "." )[ 0 ];
      user_event( "inform", "Auto deleting user "+name, "delete");
      "/secure/related_files"->delete_related_files(name, 1);
      unguarded((: rm( PLAYER_SAVE_DIR+DELETE_DIR+"/"+$(bits[i])) :));
      REFRESH_HANDLER->player_deleted(name);
    }
  }
}
protected  void do_appeal_check() {
  string *bits, name;
  int i;
  mixed *rubbish;
  bits = get_dir(PLAYER_SAVE_DIR+APPEAL_DIR+"/*.o");
  bits += get_dir(PLAYER_SAVE_DIR+APPEAL_DIR+"/*.o.gz");
  for (i=0;i<sizeof(bits);i++) {
    rubbish = stat(PLAYER_SAVE_DIR+APPEAL_DIR+"/"+bits[i]);
    if (rubbish[1]+(ONE_DAY*28) < time()) {
      log_file( "EXPIRED", ctime(time()) + " appeal player deletion: "+
                bits[i]+".\n");
      name = explode( bits[i], "." )[ 0 ];
      user_event( "inform", "Auto deleting user "+name, "delete");
      "/secure/related_files"->delete_related_files(name, 1);
      unguarded((: rm( PLAYER_SAVE_DIR+APPEAL_DIR+"/"+$(bits[i])) :));
      REFRESH_HANDLER->player_deleted(name);
    }
  }
}

==================================================
FILE: finger.c
==================================================

#include <config.h>
#include <mail.h>
#include <finger.h>
#include <player_handler.h>
#include <player.h>
#include <access.h>
#include <login.h>
#include <clubs.h>
#include <alias.h>
#include <library.h>
#include <nomic_system.h>
inherit "/std/basic/club_listing";
inherit "/global/family";
#define NO_EMAIL_TIME 7776000
#define WWW_REPLACEMENTS (["%^BOLD%^" : "<b>", \
                           "%^EBOLD%^" : "</b>", \
                           "%^RESET%^" : "", \
                           "\n" : "<br>\n" ])
#define REPLACEMENTS (["%^EBOLD%^" : "%^RESET%^", \
                       "<br>" : ""])
void create() {
   seteuid("Root");
}
string htmlise(string str) {
   return replace_string(str, "<", "&lt;");
}
string banish_finger(string name, int caller) {
  string retval;
  string *file;
  file = explode(read_file("/banish/" + name[0..0] + "/" + name + ".o"), "\n");
  retval = sprintf("%35-s%35-s\n", "Login name : " + name,
                   "Real name : Banished");
  retval += "Not really many seconds old.\n";
  retval += "No mail ever.\n";
  retval += "No plan.\nNo future.\n";
  if (caller) {
    if (sizeof(file) == 3) {
      retval += implode(file, "\n") + "\n";
    } else {
      retval += "Banish info not in the correct format.\n";
    }
  }
  if (CLUB_HANDLER->is_club(name)) {
    retval += "\nThere is also a club of this name, try: 'refer club " +
      name + "' for information on the club.\n";
  }
  return replace(retval, "@@", "@ @ ");
}
string time_elapsed_string(int time_elapsed) {
   return query_time_string(time_elapsed, -1);
}
private string get_additional_info(string name, int no_colour,
                                   int user_colour, int width, int caller) {
  string retval, tmp, tmp_leader;
   string *bing;
   int i, used_colour, need_new, domain_leader, domain_deputy,
     domain_developer;
   object ob;
   retval = "%^BOLD%^";
   if (PLAYER_HANDLER->test_creator(name)) {
      if (master()->query_trustee(name))
         retval += capitalize(name) + " is a Trustee.\n";
      else if (master()->query_director(name))
         retval += capitalize(name) + " is a Director.\n";
      else if (master()->query_senior(name))
         retval += capitalize(name) + " is a Senior Creator.\n";
      else
         retval += capitalize(name) + " is a Creator.\n";
      bing = "/secure/master"->query_domains();
      tmp = "";
      tmp_leader = "";
      for (i = 0; i < sizeof(bing); i++) {
         if ((string) ("/d/" + bing[i] + "/master")->query_lord() == name) {
            bing[i] = capitalize(bing[i]);
            tmp_leader += "Leader of the " + bing[i] + " domain.\n";
            domain_leader = 1;
            continue;
         } else if (("/d/" + bing[i] + "/master")->query_deputy(name)) {
            tmp += "Deputy of the " + capitalize(bing[i]) + " domain.\n";
            domain_deputy = 1;
         } else if (!("/d/" + bing[i] + "/master")->query_member(name)) {
           if(bing[i] != "fluffy" && bing[i] != "liaison")
             domain_developer = 1;
           continue;
         }
         tmp += "Project in the " + capitalize(bing[i]) + " domain: " +
           ("/d/" + bing[i] + "/master")->query_project(name) + "\n";
         bing[i] = capitalize(bing[i]);
      }
      tmp = tmp_leader + tmp;
      if (!sizeof(bing) && !domain_leader && !domain_deputy &&
          !domain_developer)
          tmp += "Not a member of any domain.\n";
      bing = ({ });
      if("/d/admin/master"->query_member(name))
        bing += ({ "Administrator" });
      if(domain_leader)
        bing += ({ "Domain Leader" });
      if(domain_deputy)
        bing += ({ "Domain Deputy" });
      if("/d/liaison/master"->query_member(name))
        bing += ({ "Liaison" });
      else if(domain_developer)
        bing += ({ "Developer" });
      if(sizeof(bing))
        retval += "Roles : " + query_multiple_short(bing) + ".\n";
      if(tmp)
        retval += sprintf("Domains : %-=*s", width - 10, tmp);
   } else if (PLAYTESTER_HAND->query_playtester(name)) {
      bing = ({"Playtester"});
      if (PLAYTESTER_HAND->query_pt_exec (name)) {
        bing += ({"Playtesting Executive"});
      }
      if (PLAYTESTER_HAND->query_senior_playtester(name)) {
         retval += capitalize(name) + " is a Senior Playtester.\n";
      } else {
         retval += capitalize(name) + " is a Playtester.\n";
      }
        retval += "Roles : " + query_multiple_short(bing) + ".\n";
   }
   retval += "%^EBOLD%^";
   i = PLAYER_HANDLER->test_start_time(name);
   if (i)
      retval += "First logged on " + ctime(i) + ".\n";
   retval += capitalize(time_elapsed_string(-PLAYER_HANDLER->test_age(name))) + " old.\n";
   if (find_player(name) &&
       (caller >= find_player(name)->query_invis() ||
        (this_player() &&
         reference_allowed(find_player(name), this_player())))) {
      retval += "On since " + ctime(PLAYER_HANDLER->test_last(name)) + " (" +
         capitalize(time_elapsed_string(time() - PLAYER_HANDLER->test_last(name))) +
         ").\n";
   } else {
      i = time() - PLAYER_HANDLER->test_last(name);
      retval += "Last logged off " + time_elapsed_string(i) + " ago.\n";
   }
   if (caller > 1) {
      if (!find_player(name)) {
         retval += PLAYER_HANDLER->test_last_on_from(name) + "  ";
         need_new = 1;
      } else {
         retval += query_ip_name(find_player(name)) + " (" +
            query_ip_number(find_player(name)) + ")\n";
      }
   }
   ob = find_player(name);
   if (ob && (caller >= ob->query_invis() ||
                      (this_player() &&
                       reference_allowed (ob, this_player())))) {
      if (interactive(ob)) {
         retval += "Idle for " + time_elapsed_string(query_idle(ob)) + ".\n";
         need_new = 0;
      } else {
         retval += "Net dead.\n";
         need_new = 0;
      }
   }
   if (need_new)
      retval += "\n";
   retval += (string) MAILER->finger_mail(name);
   tmp = PLAYER_HANDLER->query_project(name);
   if(no_colour || !user_colour) {
     tmp = strip_colours(tmp);
     tmp = replace(tmp, "%^", " ");
   }
   if (tmp && tmp != "") {
      if (strsrch(tmp, "%^") != -1)
         used_colour = 1;
      retval += "%^BOLD%^Project:%^EBOLD%^\n" + tmp + "\n%^RESET%^";
   } else
      retval += "No project.\n";
   tmp = PLAYER_HANDLER->query_plan(name);
   if(no_colour || !user_colour) {
     tmp = strip_colours(tmp);
     tmp = replace(tmp, "%^", " ");
   }
   if (tmp && tmp != "") {
      if (strsrch(tmp, "%^") != -1)
         used_colour = 1;
      retval += "%^BOLD%^Plan:%^EBOLD%^\n" + tmp + "\n%^RESET%^";
   } else
      retval += "No plan.\n";
   if (used_colour)
      retval += "%^RESET%^%^BOLD%^---  End of finger ---%^EBOLD%^\n";
   return retval;
}
public mixed *remote_finger(string name) {
   mixed *retval;
   object ob;
   string cname;
   if (!strlen(name) || !PLAYER_HANDLER->test_user(name))
      return 0;
   ob = find_player(name);
   cname = PLAYER_HANDLER->query_cap_name(name);
   if (!cname) {
      cname = capitalize(name);
   }
   retval = allocate(9);
   retval[0] = cname;
   retval[1] = cname;
   retval[0] = cname;
   retval[1] = cname;
   retval[2] = (PLAYER_HANDLER->test_real_name(name) ?
                PLAYER_HANDLER->test_real_name(name) : "???");
   retval[3] = "0";
   retval[4] = (ob && !ob->query_invis() ? ctime(ob->query_last_log_on()) :
                capitalize(time_elapsed_string(time() -
                                    PLAYER_HANDLER->test_last(name))));
   retval[5] = (ob && !ob->query_invis() ? query_idle(ob) : -1);
   retval[6] = 0;
   retval[7] = 0;
   retval[8] = get_additional_info(name, 1, 0, 80, 0);
   return retval;
}
private string link_name(string name) {
   return "<a href=\"finger.c?player="+ name +"\">"+ capitalize(name) + "</a>";
}
string domain_finger(string name,
                     int width,
                     int www)
{
   string ret;
   string master;
   string *members;
   string *deputies;
   string idle_str;
   int i;
   string projects;
   master = "/d/" + name + "/master";
   if (!stringp(ret = master->generate_string())) {
      ret = "%^BOLD%^The domain of " + capitalize(name) + ".\n";
      ret += "The leader for this domain is " +
         (www?
          link_name((string) master->query_lord()) + ".\n":
          capitalize((string) master->query_lord()) + ".\n");
      members = master->query_members();
      deputies = master->query_deputies();
      if (deputies && sizeof(deputies)) {
         if (sizeof(deputies) > 1) {
            ret += "The deputies for the domain are ";
         } else {
            ret += "The deputy for the domain is ";
         }
         if(www) {
            ret +=
               query_multiple_short(map(deputies, (: link_name($1) :)));
         } else {
            ret +=
               query_multiple_short(map(deputies, (: capitalize($1) :)));
         }
         ret += ".\n";
      }
      ret += "%^EBOLD%^";
      ret += "The current members of this domain are :\n";
      projects = "";
      if(www) {
         ret +=
            "<table cols=\"2\" rules=\"none\""
            "border=\"0\" width=\"100%\">";
      }
      for (i = 0; i < sizeof(members); i++) {
         if (master->query_deputy(members[i])) {
            projects = "[deputy] " + master->query_project(members[i]) + "\n";
         } else {
            projects = master->query_project(members[i]) + "\n";
         }
         if(www) {
            ret += "<tr> <td>"+ link_name(members[i]) +
               "</td> <td>"+ projects +"</td> <tr>";
         } else {
            ret += sprintf("%-=12s %-=*s",
                           capitalize(members[i]), width - 14, projects);
         }
      }
      if(www) {
         ret += "</table>";
      }
   }
   if (master->query_info()) {
      ret += sprintf("%-=*s", width, (string) master->query_info());
   }
   if ( ( idle_str = master->query_idle_mess() ) ) {
       ret += idle_str;
   }
   else {
       ret += "It hasn't been idle, it just hasn't had a lunch break in "
        "years.\n";
   }
   return ret;
}
string club_finger(string name)
{
   return club_info_string(name, 0, "gumball lord");
}
string family_finger(string name)
{
   return family_info_string(name, "gumball lord");
}
string deity_finger(string name)
{
   return 0;
}
private string other_finger(string name,
                            int no_colour,
                            int user_colour,
                            int width,
                            int caller,
                            int www)
{
   if (member_array(name, "/secure/master"->query_domains()) != -1) {
      return domain_finger(name, width, www);
   }
   if (file_size("/save/deities/" + name + ".o") > 0 ||
       file_size("/save/deities/" + name + ".o.gz") > 0) {
      return deity_finger(name);
   }
   if (name[0..4] == "club ") {
      if (CLUB_HANDLER->is_club(name[5..]) &&
          !CLUB_HANDLER->is_family(name[5..])) {
         return club_finger(name[5..]);
      }
   } else if (name[0..6] == "domain ") {
      if (member_array(name[7..], "/secure/master"->query_domains()) != -1) {
         return domain_finger(name[7..], width, www);
      }
   } else if (name[0..6] == "family ") {
      if (CLUB_HANDLER->is_family(name[7..])) {
         return family_finger(name[7..]);
      }
   } else if (CLUB_HANDLER->is_club(name)) {
      if (CLUB_HANDLER->is_family(name)) {
         return family_finger(name);
      } else {
         return club_finger(name);
      }
   }
   if (file_size("/banish/" + name[0..0] + "/" + name + ".o") > 0) {
      return banish_finger(name, caller);
   }
   return 0;
}
private string internal_finger_info(string name,
                                    int no_colour,
                                    int user_colour,
                                    int width,
                                    int caller,
                                    int www)
{
   string retval,
     tmp,
     tmp2;
   int i;
   int days_left;
   mixed *suspended, *lockedout;
   if (!find_player(name) && !PLAYER_HANDLER->test_user(name)) {
      return other_finger(name, no_colour, user_colour, width, caller, www);
   }
   retval = (no_colour ? "" : "%^BOLD%^") +
      sprintf("%*-sReal name : %*-=s\n", (width - 2) / 2,
              "Login name : " +
              strip_colours(PLAYER_HANDLER->query_cap_name(name) + "<br>"),
              (width - 2) / 2 - 12,
              (PLAYER_HANDLER->test_real_name(name) ?
               htmlise(strip_colours(PLAYER_HANDLER->test_real_name(name)[0..30])) :
               "???"));
   tmp = PLAYER_HANDLER->test_email(name);
   tmp2 = PLAYER_HANDLER->test_birthday(name);
   if ( strlen( tmp ) ) {
     if(tmp[0] == ':' || www ||
        PLAYER_HANDLER->test_last( name ) + NO_EMAIL_TIME < time()) {
       if(caller == 0) {
         tmp = "";
       }
     }
   }
   if (tmp) {
      tmp = htmlise(tmp);
      if (tmp2 && tmp2 != UNKNOWN_BIRTHDAY) {
         tmp2 = htmlise(tmp2);
         retval += sprintf("%*-sEmail : %*-=s\n", (width - 2) / 2,
                           "Birthday : " + tmp2 + "<br>", (width - 2) / 2,
                           tmp);
      } else {
         retval += sprintf("Email : %-*s\n", (width - 2) / 2 - 8, tmp[0..30]);
      }
   } else if (tmp2 && tmp2 != UNKNOWN_BIRTHDAY) {
      tmp2 = htmlise(tmp2);
      retval += sprintf("Birthday : %-*s\n", (width - 2) / 2 - 11, tmp2 +
                        "<br>");
   }
   i = PLAYER_HANDLER->test_deleting(name);
   if (i) {
      retval += (no_colour ? "" : "%^RED%^") +
         "This character is marked to be deleted in ";
      if (time() - i > (10 * 60 * 60 * 24)) {
         retval += "1 day.\n";
      } else {
         days_left = (10 - ((time() - i) / (60 * 60 * 24)));
         if (days_left > 1) {
            retval += days_left + " days.\n";
         } else {
           retval += days_left + " day.\n";
         }
      }
      if (!no_colour)
         retval += "%^RESET%^";
   }
   i = PLAYER_HANDLER->test_appealing(name);
   if (i) {
      retval += (no_colour ? "" : "%^RED%^") +
         "This character is marked to be deleted in ";
      if (time() - i > (28 * 60 * 60 * 24)) {
         retval += "1 day";
      } else {
         days_left = (28 - ((time() - i) / (60 * 60 * 24)));
         if (days_left > 1) {
            retval += days_left + " days";
         } else {
           retval += days_left + " day";
         }
      }
      retval += " pending appeal.\n";
      if (!no_colour)
        retval += "%^RESET%^";
   }
   tmp = PLAYER_HANDLER->test_home_dir(name);
   if (tmp)
      retval +=
         sprintf("%*-s", (width - 2) / 2, "Home directory : " + tmp + "<br>");
   tmp = PLAYER_HANDLER->test_guild(name);
   if (tmp) {
      if (catch(retval += "Member of the " + tmp->query_short() + ".\n"))
         retval += "Member of a very broken guild.\n";
   } else
      retval += "Member of the Adventurers' guild.\n";
   if(!no_colour)
     retval += "%^EBOLD%^";
   tmp = PLAYER_HANDLER->test_location(name);
   if (strlen(tmp)) {
      tmp = htmlise(tmp);
      retval += "Location : " + tmp[0..30] + "\n";
   }
   tmp = PLAYER_HANDLER->test_homepage(name);
   if (stringp(tmp)) {
      tmp = htmlise(tmp);
      retval += "Home Page: " + tmp + "\n";
   }
   suspended = "/secure/bastards"->query_suspended(name);
   if (suspended) {
      tmp = capitalize(name) + " has been suspended until " +
         ctime(suspended[SUSPEND_TIME]);
      if (caller) {
         tmp += " for " + suspended[SUSPEND_REASON] + ".\n";
      } else {
         tmp += ".\n";
      }
      retval += "%^YELLOW%^" + sprintf("%s%-=*s", tmp[0..10], width - 11,
                                       tmp[11..]) + "%^RESET%^";
   }
   lockedout = "/secure/bastards"->query_lockedout(name);
   if (lockedout) {
     tmp = capitalize(name) + " is locked out until " +
       ctime(lockedout[SUSPEND_TIME]);
     if (caller) {
       tmp += " because " + lockedout[SUSPEND_REASON] + ".\n";
     } else {
       tmp += ".\n";
     }
      retval += "%^YELLOW%^" + sprintf("%s%-=*s", tmp[0..10], width - 11,
                                       tmp[11..]) + "%^RESET%^";
   }
   retval += htmlise(get_additional_info(name, no_colour, user_colour, width, caller));
   return retval;
}
private string make_html(string str)
{
   int pos;
   pos = strsrch(str, "http:");
   if (pos == -1) {
      str = "http:
   } else {
      str = str[pos..];
   }
   pos = strsrch(str, " ");
   if (pos != -1) {
      str = str[0..pos - 1];
   }
   return str;
}
string finger_info(string name,
                   int no_colour)
{
   int caller,
     width,
     user_colour;
   string retval,
     str;
   string user,
     nick;
   user = this_player()->query_name();
   user_colour = this_player()->query_property(PLAYER_ALLOW_COLOURED_SOULS);
   if (this_player()) {
      nick = (string) this_player()->expand_nickname(name);
      if (nick)
         name = nick;
      width = this_player()->query_cols();
   }
   if (!width) {
      width = 80;
   }
   if (master()->query_director(user)) {
      caller = 3;
   } else if (master()->is_liaison_deputy(user)) {
      caller = 2;
   } else if (PLAYER_HANDLER->test_creator(user)) {
      caller = 1;
   } else {
      caller = 0;
   }
   retval = internal_finger_info(name, no_colour, user_colour,
                                 width, caller, 0);
   if (!retval) {
      return 0;
   }
   foreach(str in keys(REPLACEMENTS)) {
      retval = replace_string(retval, str, REPLACEMENTS[str]);
   }
   return retval;
}
string www_finger_info(string name,
                       string user)
{
   int caller;
   string retval,
     str;
   if (!user || user == "")
      caller = 0;
   else if (master()->query_director(user))
      caller = 3;
   else if (master()->is_liaison_deputy(user))
      caller = 2;
   else if (PLAYER_HANDLER->test_creator(user))
      caller = 1;
   else
      caller = 0;
   retval = internal_finger_info(name, 0, 1, 80, caller, 1);
   if (!retval)
      return 0;
   foreach(str in keys(WWW_REPLACEMENTS))
      retval = replace_string(retval, str, WWW_REPLACEMENTS[str]);
   retval = strip_colours(retval);
   return retval;
}
string refer_info(string name) {
   string retval, nick, tmp, family, rels, area, str;
   object ob;
   int width, sex;
   retval = "";
   width = 80;
   if (this_player()) {
      nick = (string) this_player()->expand_nickname(name);
      width = this_player()->query_cols();
   }
   if (nick) {
      name = nick;
   }
   if (!PLAYER_HANDLER->test_user(name)) {
     retval = other_finger(name, 0, 0, width, 0, 0);
     if(retval)
       foreach(str in keys(REPLACEMENTS))
         retval = replace_string(retval, str, REPLACEMENTS[str]);
     return retval;
   }
   family = "";
   tmp = PLAYER_HANDLER->test_player_title(name);
   if (tmp) {
      tmp += " ";
   } else {
      tmp = "";
   }
   retval = PLAYER_HANDLER->query_cap_name(name);
   if (!retval) {
      return 0;
   }
   tmp = PLAYER_HANDLER->test_family_name(name);
   if (tmp) {
      retval += " " + tmp;
   }
   if ("/d/liaison/master"->query_member(name)) {
      retval += " (%^YELLOW%^Liaison%^RESET%^)";
   } else if (PLAYER_HANDLER->test_creator(name)) {
      if ("/secure/master"->query_trustee(name)) {
         retval += " (%^RED%^Trustee%^RESET%^)";
      } else if ("/secure/master"->query_director(name)) {
         retval += " (%^RED%^Director%^RESET%^)";
      } else if ("/secure/master"->query_senior(name)) {
         retval += " (%^RED%^Senior%^RESET%^)";
      } else {
         retval += " (%^RED%^Creator%^RESET%^)";
      }
   }
   ob = find_player(name);
   if (ob) {
      if (tmp = (string) ob->query_gtitle()) {
         retval += " " + tmp;
      } else {
         retval += " the Adventurer";
      }
      if (tmp = (string)ob->query_property("player_title")) {
         retval += ", " + tmp;
      }
      tmp = (string) ob->query_title();
      if (tmp && tmp != "") {
         retval += ", " + tmp;
      }
   }
   if (PLAYTESTER_HAND->query_playtester(name)) {
     if (PLAYTESTER_HAND->query_senior_playtester(name)) {
       retval += ", (%^BOLD%^%^CYAN%^Senior Playtester%^RESET%^)";
     } else {
       retval += ", (%^CYAN%^Playtester%^RESET%^)";
     }
   }
   if(ob) {
     retval += ".";
      if(ob->query_nationality_name()) {
        retval += "\n" + capitalize(ob->query_possessive()) +
          " nationality is " + capitalize(ob->query_nationality_name());
        if(ob->query_nationality_region())
          retval += " and " + ob->query_pronoun() + " is from "+
            capitalize(ob->query_nationality_region());
        retval +=  ".\n";
      }
   } else {
      retval += " (not currently logged in)\n";
   }
   tmp = PLAYER_HANDLER->test_desc(name);
   if (tmp && tmp != "") {
     if(!this_player()->query_property(PLAYER_ALLOW_COLOURED_SOULS))
       tmp = strip_colours(tmp);
      sex = PLAYER_HANDLER->test_gender(name);
      if (sex == 1) {
         retval += "He " + tmp + "\n";
      } else if (sex == 2) {
         retval += "She " + tmp + "\n";
      } else {
         retval += "It " + tmp + "\n";
      }
   } else {
      retval += "No description.\n";
   }
   foreach(area in NOMIC_HANDLER->query_citizenship_areas()) {
      if (NOMIC_HANDLER->is_magistrate_of(area, name)) {
         retval += "Magistrate in " + area + ".\n";
      } else if (NOMIC_HANDLER->is_citizen_of(area, name)) {
         retval += "Citizen in " + area + ".\n";
      }
   }
   rels = "/std/basic/club_listing"->player_relationships_string(name);
   if (rels != "") {
      retval += PLAYER_HANDLER->query_cap_name(name) + " " +
         PLAYER_HANDLER->test_family(name) + " is the " + rels + "\n";
   }
   if(PLAYER_HANDLER->test_player_killer(name)) {
     retval += PLAYER_HANDLER->query_cap_name(name) + " is a player killer.\n";
   }
   tmp = PLAYER_HANDLER->query_reference(name);
   if(!this_player()->query_property(PLAYER_ALLOW_COLOURED_SOULS))
     tmp = strip_colours(tmp);
   if (tmp && tmp != "") {
      retval += "\n" + tmp + "\n%^RESET%^";
      if (strsrch(tmp, "%^") != -1) {
         retval += "--- End of Reference --\n";
      }
   } else {
      retval += "No reference.\n";
   }
   return retval;
}

==================================================
FILE: force.c
==================================================

#include <obj_parser.h>
#define FORCE_COST 1
#define ILLEGAL_FORCE ({ "alias", "unalias", "mv", "mkdir", "call", "rm", \
                         "force", "kill", "gauge", "exec", "promote", \
                         "new_domain", "rmdir", "cd", "history", "echoall", "shout" })
nosave string fname;
nosave int no_force_me;
void force_commands() {
  sscanf(file_name(this_object()), "%s#", fname);
  if(!this_object()->query_property("npc") &&
     this_object()->query_property("force") || fname == "/global/lord")
    add_action("do_force", "force");
  if(fname == "/global/lord")
    add_action("no_force", "noforce");
}
protected int no_force(string str) {
  if(fname!="/global/lord")
    return 0;
  if(str == "on") {
    no_force_me = 1;
    write("Ok.\n");
    return 1;
  }
  if(str == "off") {
    no_force_me = 0;
    write("Ok.\n");
    return 1;
  }
  write("Forcing you is currently ");
  if(no_force_me) {
    write("disabled.\n");
  }
  else {
    write("enabled.\n");
  }
  return 1;
}
int do_force(string str) {
  string who, what;
  object *obs, ob;
  int i;
  class obj_match omatch;
  if(fname == "/global/player" && !this_player()->query_property("force")) {
    notify_fail("You do not have the ability to do that yet.\n");
    return 0;
  }
  if(!str || sscanf(str, "%s %s", who, what) != 2) {
    notify_fail("Usage : force <person> <command>\n");
    return 0;
  }
  if(this_player()->adjust_social_points(-FORCE_COST) < 0) {
    notify_fail("Insufficient social points.\n");
    return 0;
  }
  who = (string)this_player()->expand_nickname(who);
  who = lower_case(who);
  omatch = match_objects_in_environments(who, environment(this_object()));
  if (omatch->result != OBJ_PARSER_SUCCESS) {
    notify_fail(match_objects_failed_mess(omatch));
    return 0;
  }
  obs = omatch->objects;
  if (!sizeof(obs))
    if (!(ob = find_living(who))) {
      notify_fail("No such living thing.\n");
      return 0;
    } else
      obs += ({ ob });
  for (i=0;i<sizeof(obs);i++)
    if(!obs[i]->do_force_on_me(what))
      write(capitalize(who) + " didn't want to do that.\n");
  write("Ok.\n");
  return 1;
}
int do_force_on_me  (string str) {
  string temp1, temp2;
  object forcer;
  forcer = this_player(1);
  if(!forcer) {
    forcer = previous_object();
  }
  if(!this_object()->query_property("npc")) {
    log_file("FORCE", ctime(time()) + " " + forcer->query_name() + " " +
                      this_object()->query_name() + " : " + str);
  }
  tell_object(this_object(), forcer->query_cap_name() +
        " tries to force you to " + str + "\n");
  if (no_force_me || (string)this_object()->query_name() == "pinkfish") {
    log_file("FORCE", " (failed)\n");
    return 0;
  }
  if(!sscanf(str, "%s %s", temp1, temp2)) {
    temp1 = str;
  }
  if (member_array(temp1, ILLEGAL_FORCE) != -1 &&
      !"secure/master"->high_programmer(geteuid(forcer))) {
    log_file("FORCE", " (failed)\n");
    return 0;
  }
  command(str);
  log_file("FORCE", " (succeeded)\n");
  return 1;
}

==================================================
FILE: ftp_auth.c
==================================================

#include <network.h>
#include <login_handler.h>
#include <playtesters.h>
#define BASTARDS "/secure/bastards"
#define MAX_LIFE 36000
inherit SERVER;
class ftp_session {
  int fd;
  string token;
  int timestamp;
  string user;
}
private mapping Sockets;
protected void create() {
  server::create();
  SetSocketType(STREAM);
  SetDestructOnClose(1);
  Sockets = ([]);
  call_out("setup", 2);
  call_out("clean_sockets", 3600);
}
protected void setup() {
  if (eventCreateSocket(PORT_FTPAUTH) < 0) {
    if (this_object()) {
      destruct(this_object());
    }
  }
}
protected void eventNewConnection(int fd) {
  class ftp_session sess;
  string address, host;
  server::eventNewConnection(fd);
  address = socket_address(fd);
  if ((sscanf(address, "%s %*d", host) != 2) || (host != "127.0.0.1")) {
    eventWrite(fd, "", 1);
    return;
  }
  sess = new(class ftp_session, fd : fd);
  Sockets[fd] = sess;
}
protected string get_path(string str) {
  string *array, *array1;
  int i;
  if (str == "/")
    return "/";
  array = explode(str, "/") - ({ "" });
  array1 = ({ });
  for (i = 0; i < sizeof(array); i++) {
    if (array[i] == "..") {
      if (sizeof(array1)) {
        array1 = array1[0..<2];
      }
    } else if (array[i] != ".") {
      array1 += ({ array[i] });
    }
  }
  if (sizeof(array1))
    str = implode(array1, "/");
  else
    str = "";
  return "/" + str;
}
protected void eventRead(int fd, string str) {
  class ftp_session sess = Sockets[fd];
  string name, rest, ret, token, type, path;
  int timestamp;
  if (!sess) {
    eventWrite(fd, "DENIED\n", 1);
    return;
  }
  if (str == "mudname") {
    eventWrite(fd, sprintf("OKAY: %s\n", mud_name()));
    return;
  }
  if (sscanf(str, "%s %s", name, rest) != 2) {
    eventWrite(fd, "Syntax error\n", 1);
    return;
  }
  name = lower_case(name);
  if (rest == "request login" ||
      rest == "request login playtester") {
    int anon = 0;
    if (name == "ftp") {
        anon = 1;
    }
    if (rest == "request login") {
       if (!(anon || PLAYER_HANDLER->test_creator(name))) {
         eventWrite(fd, "DENIED\n");
         return;
       }
    } else {
       if (!anon &&
           !PLAYTESTER_HAND->query_playtester(name) &&
           !PLAYER_HANDLER->test_creator(name)) {
         eventWrite(fd, "DENIED invalid\n");
         return;
       }
    }
    if ( BASTARDS->query_suspended( name ) ) {
      eventWrite(fd, "DENIED suspended\n");
      return;
    }
    timestamp = time();
    token = crypt("" + timestamp, "" + random(12000));
    sess->token = token;
    sess->timestamp = timestamp;
    sess->user = name;
    if (anon) {
      ret = sprintf("OKAY: %s * /pub\n", token);
    } else {
      ret = sprintf("OKAY: %s %s /w/%s\n", token,
                    PLAYER_HANDLER->get_password(name), name);
    }
    eventWrite(fd, ret);
    return;
  }
  if (sscanf(rest, "%s %s %s", token, type, path) != 3) {
    eventWrite(fd, "Syntax error\n", 1);
    return;
  }
  if ((token != sess->token) || ((time() - sess->timestamp) > MAX_LIFE)) {
    eventWrite(fd, "DENIED\n");
    return;
  }
  path = get_path(path);
  switch (type) {
  case "read":
    if (file_size(path) == -2) {
      path += "
protected void eventSocketClosed(int fd) {
  class ftp_session sess = Sockets[fd];
  if (!sess) {
    return;
  }
  map_delete(Sockets, fd);
}
protected void clean_sockets() {
  class ftp_session sess;
  foreach (sess in values(Sockets)) {
    if (!sess->timestamp) {
      sess->timestamp = time();
      continue;
    }
    if (time() - sess->timestamp > MAX_LIFE) {
      eventWrite(sess->fd, "Timeout\n", 1);
    }
  }
  call_out("clean_sockets", 3600);
}
string *query_connections() {
  class ftp_session val;
  string *list;
  list = ({ });
  foreach (val in values(Sockets)) {
    if (val->user) {
      list += ({ capitalize(val->user) });
    } else {
      list += ({ "login" });
    }
  }
  return list;
}
