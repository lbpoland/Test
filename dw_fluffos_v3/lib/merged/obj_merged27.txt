# Total Tokens: 23318
# Total Files Merged: 35
# Total Characters: 76649

c
==================================================

inherit "std/object";
void setup() {
   set_name( "button" );
   set_short( "red button" );
   add_adjective( "red" );
   set_long( "This red button destructs all non-user objects in "
         "the room.  USE WITH EXTREME CAUTION.\n");
   reset_get();
   add_property( "there", "embedded into the wall" );
}
void init() {
   this_player()->add_command( "press" , this_object() );
}
int do_press() {
   object thing, *things;
   things = (object *)environment()->query_non_destable();
   if ( !things )
      things = ({ this_object() });
   else
      things += ({ this_object() });
   foreach ( thing in all_inventory( environment() ) - things )
      if ( !userp( thing ) )
         thing->dest_me();
   write( "You clean up.\n" );
   say( (string)this_player()->one_short() +" cleans up.\n" );
   return 1;
}

==================================================
FILE: misc/camera.c
==================================================

#include <weather.h>
inherit "/std/object";
int  colour;
int  black_white;
int  scene;
void setup() {
  colour = 2;
  black_white = 4;
  scene = 1;
  set_name( "box" );
  add_adjective( ({ "heavy" , "black" }) );
  set_short( "heavy black cube" );
  set_main_plural( "heavy black cubes" );
  set_long( "You see a heavy black box with a window on one side.  "
            "Looking through the window, you notice a tiny demon sitting "
            "patiently next to a miniscule painter's easel.\n" );
  set_weight( 10 );
  add_alias( ({ "cube" , "camera" }) );
  add_plurals(({ "cubes", "cameras"}));
  adjust_money( 1 , "gold" );
  add_help_file("camera");
}
void init() {
    add_command("use", "<direct:object> on <indirect:object>");
    add_command("use", "<direct:object>");
}
int query_colour()      { return colour;  }
int query_black_white() { return black_white;  }
int do_use(object *obs) {
  int i;
  string view;
  string photo_of;
  string chars_sorted;
  string things_sorted;
  object *players;
  object *chars;
  object *things;
  object  photo;
  object  env;
  object *yes;
  players = ({ });
  chars = ({ });
  things = ({ });
  yes = ({ });
  view = "";
  photo_of = "";
  chars_sorted = "";
  things_sorted = "";
  env = environment(this_player()) ;
  photo_of = "This is a beautiful ";
  if (env->query_light() < 60) {
    this_player()->add_failed_mess(this_object(),
                                   "The little imp whispers: Hey! "
                                   "Not everyone like you can see "
                                   "in the dark you know.\n",({ }));
    return 0;
  }
  if (env->query_light() >180) {
    this_player()->add_failed_mess(this_object(),
                                   "The little demon said quietly: "
                                   "Could I have a pair of sunspecs "
                                   "please! Not too much to ask, is it?\n",
                                   ({ }));
    return 0;
  }
  if (black_white <= 0) {
    call_out("out_of_paint", 0, env);
    this_player()->add_failed_mess(this_object(),
                                   "The little imp gives up painting "
                                   "for you.\n",({ }));
    return 0;
  }
  if (colour > 1) {
    photo_of += "colour ";
    colour --;
  } else if (colour == 1) {
    photo_of += "colour ";
    call_out("out_of_colour", 2, env);
    colour --;
  } else {
    photo_of += "black and white ";
    black_white --;
  }
  if (sizeof(obs)) {
    for (i=0;i<sizeof(obs);i++) {
      if (obs[i]->query_property("player")) {
        players += ({ obs[i] });
        this_player()->add_succeeded(obs[i]);
        yes  += ({ obs[i] });
      } else if (obs[i]->query_property("npc")) {
        chars   += ({ obs[i] });
        this_player()->add_succeeded(obs[i]);
        yes  += ({ obs[i] });
      } else {
        if (environment(obs[i]) != this_player()) {
          things  += ({ obs[i] });
          this_player()->add_succeeded(obs[i]);
          yes  += ({ obs[i] });
        }
      }
    }
    chars_sorted = query_multiple_short(chars);
    things_sorted = query_multiple_short(things);
    if (chars_sorted || things_sorted || sizeof(players)) {
      scene = 0;
    }
  }
  view = env->query_long();
  if(view[sizeof(view)-1] != 10)
    view += "\n";
  if(env->query_property("location") == "outside" &&
     !env->query_weather_obscured(WEATHER->query_day())) {
    view = WEATHER->weather_string(env) + ".  " + view;
  }
  photo_of += "picture of " + env->a_short() + ".";
  if (scene == 0) {
    if ((sizeof(chars)+sizeof(players)) == 1) {
      if (sizeof(chars) == 1) {
        view += capitalize( (string)chars[0]->query_short() ) +
          " is here smiling.\n";
      } else if (sizeof(players) == 1) {
        view += players[0]->one_short() +" is here smiling.\n";
      }
    } else if ((sizeof(players)+sizeof(chars)) > 1) {
      for(i=0;i<sizeof(players);i++) {
        view += players[i]->one_short() ;
        if (i < (sizeof(players)-1)) {
          view += ", ";
        }
      }
      if (chars_sorted != "" && sizeof(players) > 0) {
        view += ", " + chars_sorted ;
      } else if (chars_sorted != "") {
        view += capitalize(chars_sorted) ;
      }
      view += " are smiling here.\n";
    }
    if (sizeof(things) == 1) {
      view += "There is a "+ things_sorted +" in the photo.\n";
    } else if ( sizeof( things ) ) {
      view += "There are " + things_sorted+" lying here in the photo.\n" ;
    }
  }
  photo = clone_object("/std/object");
  photo->set_name("glass");
  photo->add_adjective( ({"tiny", "square"}) );
  photo->set_short("tiny square of glass");
  photo->set_main_plural("tiny squares of glass");
  photo->set_long("/global/events"->convert_message(view));
  photo->set_read_mess(photo_of);
  photo->add_property("photographer", (string)this_player()->query_name()) ;
  photo->move(this_player());
  if (scene == 0) {
    this_player()->add_succeeded_mess(this_object(),
                                      "$N $V $D on $I. After some frantic "
                                      "sounds of pens scratching and "
                                      "brushes brushing, a tiny "
                                      "demon inside hands a piece of painted "
                                      "glass to $N.\n", yes);
  } else {
    this_player()->add_succeeded_mess(this_object(),
                                      "$N $V $D on the scenery. After some "
                                      "frantic sounds of pens scratching "
                                      "and brushes brushing, a "
                                      "tiny demon inside hands a piece "
                                      "of painted glass to $N.\n");
  }
  return 1;
}
mapping query_static_auto_load() {
  return ([ "colour" : colour,
          "black_white" : black_white ]);
}
void init_static_arg(mapping map) {
  colour = map["colour"];
  black_white = map["black_white"];
}
void out_of_paint(object room) {
  tell_object(this_player(), "The tiny demon whispers sarcastically: "
              "Without any more paints, I can still paint "
              "you invisible picture if you like!\n");
  tell_room(room, "The tiny demon in the cube whispers something about "
            "paints to "+ this_player()->one_short() +".\n",
            this_player());
}
void out_of_colour(object room) {
  tell_object(this_player(), "The tiny demon whispers: There are no more "
              "colour paints. This picture is the "
              "last colour one. I can only do you "
              "black and white pictures from now!\n");
  tell_room(room, "The tiny demon in the cube whispers something about "
            "colour to "+ this_player()->one_short() +".\n",
            this_player());
}

==================================================
FILE: misc/case.c
==================================================

#define READ "/cmds/living/r_ead"
inherit "/obj/baggage";
void setup() {
  set_name("case");
  set_long("This is a nice glass display case that looks out of place "
           "here, you could \"peruse\" things in it perhaps.\n");
  add_alias("container");
  add_adjective("display");
  set_transparent();
  set_weight(1000);
  set_main_plural("cases");
  set_max_weight(500000);
  reset_get();
  reset_drop();
}
void init() {
  this_player()->add_command( "peruse", this_object(),
                              "<indirect:object:direct-obs> in <direct:object>");
}
int do_peruse( object *obs ) {
  obs = filter( obs, (: environment( $1 ) == this_object() :) );
  if ( !sizeof( obs ) ) {
    add_failed_mess( "You have to browse something in the display case.\n" );
    return 0;
  }
  if ( sizeof( obs ) > 1 ) {
    add_failed_mess( "You can only browse 1 thing at a time.\n" );
    return 0;
  }
  write( "You peruse the "+ obs[0]->query_short() +".\n" );
  write( obs[0]->long() );
  READ->cmd( ({ obs[0] }) );
  this_player()->add_succeeded_mess( this_object(), "" );
  return 1;
}
int test_add( object item, int flag ) {
  if ( base_name( previous_object( 1 ) )[0..4] == "/cmds" ) {
    if ( this_player()->query_creator() )
      return 1;
    else return 0;
  }
  return 1;
}
int test_remove( object item, int flag ) {
  if ( base_name( previous_object( 1 ) )[0..4] == "/cmds" ) {
    if ( this_player()->query_creator() )
      return 1;
    else return 0;
  }
  return 1;
}
void setup_case( string name, string long ) {
  add_alias( name );
  set_long( long + "You feel you could \"peruse\" things in it.\n" );
}

==================================================
FILE: misc/cash_register.c
==================================================

#include <money.h>
inherit "/std/container";
object shop;
object query_shop() { return shop; }
void set_shop( object thing ) { shop = thing; }
string long( string word, int dark ) {
   int i;
   string ret, *coins;
   object cash;
   ret = query_long();
   cash = present( MONEY_ALIAS, this_object() );
   if ( !cash )
      return ret +"There is no money in the register.\n";
   coins = (string *)cash->half_short( 1 );
   if ( !sizeof( coins ) )
      return ret +"There is no money in the register.\n";
   ret += "The register contains:\n";
   for ( i = 0; i < sizeof( coins ); i++ )
      ret += "      "+ coins[ i ] +"\n";
   return ret;
}
int test_add( object thing, int flag ) {
   if ( !thing->id( MONEY_ALIAS ) )
      return 0;
   if ( shop )
      shop->save_register();
   return 1;
}
int test_remove( object thing, int flag ) {
   if ( shop )
      shop->save_register();
   return 1;
}

==================================================
FILE: misc/chicken_feather.c
==================================================

inherit "/std/object";
void setup() {
 set_name("feather");
 set_short("chicken feather");
 set_main_plural("chicken feathers");
 add_adjective("chicken");
 add_plural("feathers");
 add_adjective("chicken");
 set_weight(1);
 set_long("This is a feather that was plucked from a chicken.\n");
}

==================================================
FILE: misc/club_badge.c
==================================================

#include <clubs.h>
#include <broadcaster.h>
inherit "/obj/clothing";
inherit "/std/basic/club_insignia";
protected int club_members(int online);
protected int do_recruit(object *players, string club);
protected int club_chat(string str, int emote);
protected int club_members(int online);
protected int club_info();
protected int do_history();
private string *extra_adjs;
void setup() {
   extra_adjs = ({ });
   set_name("badge");
   add_adjective("club");
   set_type("badge");
   set_short("club badge");
   setup_clothing(1000);
   set_damage_chance(5);
   set_long("The badge is a nice blue colour with a fringe "
            "like a bunny rabbit.\n");
   add_extra_look(this_object());
}
string extra_look() {
   string tmp_name;
   if (query_club() &&
       CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      tmp_name = replace(lower_case(query_club()), " ", "_");
      return "  You feel like the command '" + tmp_name + "' does something.\n";
   }
   return "\n";
}
void init() {
   club_insignia::init();
}
mapping query_dynamic_auto_load(mapping map) {
   map = clothing::query_dynamic_auto_load();
   map = club_insignia::query_dynamic_auto_load(map);
   map["verSion"] = 1;
   return map;
}
void init_dynamic_arg(mapping map) {
   if (map["verSion"] != 1) {
      clothing::init_dynamic_arg(map["::"]);
   } else {
      clothing::init_dynamic_arg(map);
   }
   club_insignia::init_dynamic_arg(map);
}
void set_club(string name) {
   if (!name) {
      extra_adjs = ({ });
      set_short("club badge");
   } else {
      if (CLUB_HANDLER->is_club(name)) {
         name = CLUB_HANDLER->query_club_name(name);
         extra_adjs = explode(lower_case(name), " ");
            set_short("club badge");
      }
   }
   ::set_club(name);
}
string *parse_command_adjectiv_id_list() {
   return ::parse_command_adjectiv_id_list() +
           extra_adjs;
}
mixed *stats()
{
  return clothing::stats() +
    club_insignia::stats();
}

==================================================
FILE: misc/crystal_phial.c
==================================================

inherit "/obj/vessel";
void setup() {
   set_name( "phial" );
   set_short( "crystal phial" );
   add_adjective( "crystal" );
   set_main_plural( "crystal phials" );
   set_long( "This is a small tube-like bottle made of some sort of "+
         "crystal.  A stopper is attached at one end on a bit of wire.\n" );
   set_weight( 1 );
   set_value( 1000 );
   set_max_weight( 1 );
   set_max_volume( 10 );
   set_transparent();
}
int test_add( object thing, int flag ) {
   string word;
   object *things;
   if ( !this_player() )
      return ::test_add( thing, flag );
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return ::test_add( thing, flag );
   word = (string)things[ 0 ]->query_medium_alias();
   if ( word == (string)thing->query_medium_alias() )
      return ::test_add( thing, flag );
   write( "You don't want to contaminate "+ ( stringp( word ) ?
         (string)things[ 0 ]->the_short() :
         (string)thing->the_short() ) +", do you?\n" );
   return 0;
}
object query_substance() {
   object *things;
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return 0;
   if ( !stringp( (string)things[ 0 ]->query_medium_alias() ) )
      return 0;
   return things[ 0 ];
}
string short( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::short( dark );
   return ::short( dark ) +" of "+ (string)thing->short( dark );
}
string query_plural( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::query_plural( dark );
   return ::query_plural( dark ) +" of "+ (string)thing->short( dark );
}
string *parse_command_adjectiv_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_adjectiv_id_list();
   return ::parse_command_adjectiv_id_list() + ({ "of" }) +
      (string *)thing->query_adjectives();
}

==================================================
FILE: misc/dart_board.c
==================================================

#include <player_handler.h>
inherit "/std/object";
string  *creators, name1, name2, target;
object  player1, player2;
int     score1, score2, in_use, thrown, bet;
void setup();
void init();
int abandon( string str );
string find_target();
int play( string str );
int throw_dart();
int score_it( int i );
void heart_beat();
void end_game();
void setup() {
  set_name("dartboard");
    add_property( "there", "mounted on the wall" );
  add_adjective("party");
  set_main_plural("dartboards");
  set_short("party dartboard");
  set_long("This is a party dartboard.  It's round, with concentric "
    "circles in black and yellow painted on it.\n");
  set_weight(10000);
  set_value(0);
  reset_get();
  set_read_mess(
    "This is a game of darts for two players. Before beginning "
    "their throws, the players must both type 'play'. Each player "
    "in turn can then throw three darts at the board (by typing "
    "'throw' three times). Note that your accuracy is affected "
    "by your DEX stat. The winner of the game is the player with the "
    "highest score after all darts have been thrown.\n" );
}
void init() {
  add_command("abandon", "", (:this_object()->abandon(""):));
  add_command("play", "", (:this_object()->play(0):));
  add_command("throw", "", (:this_object()->throw_dart():));
}
int abandon( string str ) {
  if (this_player() == player1 || this_player() == player2) {
    write("You call off the game of darts.\n");
    say("The game of darts is called off by "
      + this_player()->query_short()+".\n");
    end_game();
    return 1;
  }
}
string find_target() {
  string *creators, victim;
  creators = get_dir("/w/");
  victim = (creators[(random(sizeof(creators)))]);
  while (!PLAYER_HANDLER->test_user(victim) ) {
    victim = (creators[(random(sizeof(creators)))]);
}
  return capitalize(victim);
}
int play( string str ) {
  int val;
  if (in_use) {
    write("The dartboard is in use right now.\n");
    return 1;
  }
  if (!str) str = "0";
  if (!sscanf(str, "%d", val) || val < 0) {
    write("Bets must be for zero or greater coins.\n");
    return 1;
  }
  if (this_player()->query_money() < val) {
    write("Betting is not yet supported... I'm working on it! "
   "Just type \"play\".\n");
    return 1;
  }
  if (player1) {
    if (this_player() == player1) {
      write("You can't play against yourself!\n");
      return 1;
    }
    if (val != bet) {
      write("Bet amounts must match. " + name1 + " bet " + bet + ".\n");
      return 1;
    }
    player2 = this_player();
    name2 = player2->query_short();
    target = find_target();
    tell_room( environment(), name1 + " and " + name2 +
      " have started a game of darts, throwing at " + target
      + ".\n", ({ player1, player2 }) );
    tell_object( player2, "You accept " + name1 + "'s challenge, "
      "and you both prepare to throw darts at " + target + ".\n" );
    tell_object( player1, name2 + " accepts your challenge, and you "
      "both prepare to throw darts at " + target + ".\nThrow your darts.\n");
    in_use = 1;
    return 1;
  }
  bet = val;
  player1 = this_player();
  name1 = player1->query_short();
  write("You can 'abandon' the game if no one takes up your challenge.\n");
  say( name1 + " is looking for someone else to play darts with.\n");
  set_heart_beat(1);
  return 1;
}
int throw_dart() {
  int hit;
  string start;
  if (!in_use)  {
     return notify_fail( "You are not currently playing.\n ");
  }
  if (this_player() != player1 && this_player() != player2)  {
     return notify_fail( "You are not currently playing.\n" );
  }
  if (in_use == 1 && this_player() == player1) {
    thrown += 1;
    write("You throw a dart.\n");
    say( name1 + " throws a dart.\n" );
    hit = score_it(random(21) + ((player1->query_dex() -13 ) / 2 ));
    if (hit == 500 && bet >= 50) {
      write("You feel a bit more experienced.\n");
      player1->ajdust_xp(10);
    }
    score1 += hit;
    if (thrown == 3) {
      write("That was your third dart. Your score is " + score1 + ".\n");
      say(name1 + " has a score of " + score1 + " after three darts.\n");
      if (player2) tell_object(player2, "Your turn to throw.\n");
      in_use = 2;
    }
    return 1;
  }
  if (in_use == 2 && this_player() == player2) {
    thrown += 1;
    write("You throw a dart.\n");
    say(name2+ " throws a dart.\n" );
    hit = score_it(random(21) + ((player2->query_dex() - 13 ) / 2 ));
    if (hit == 500 && bet >= 50) {
      write("You feel a bit more experienced.\n");
      player2->adjust_xp(10);
    }
    score2 += hit;
    if (thrown == 6) {
      write("That was your third dart.\n");
      if (score1 > score2) {
        start = " with a score of " + score1 + " to " +
          score2 + ".\n";
        write(name1 + " beats you" + start);
        tell_room( environment(), name1 + " beats " + name2 + start,
                ({ player1, player2 }));
        tell_object(player1, "You beat " + name2 + start);
      } else if (score2 > score1) {
        start = " with a score of " + score2 + " to " +
          score1 + ".\n";
        write("You beat " + name1 + start);
        tell_room( environment(), name2 + " beats " + name1 + start,
                    ({ player1, player2 }));
        tell_object(player1, name2 + " beats you" + start);
      } else {
        tell_room(environment(this_object()),
          "It's a tie with a score of " + score1 + "!\n");
      }
      end_game();
    }
    return 1;
  }
  write("It's not your turn to throw a dart!\n");
  return 1;
}
int score_it( int i ) {
  string rest_mess;
  int ret;
  if (i < 2) {
    rest_mess = "the wall. No score.\n";
    ret = 0;
  } else if (i < 19) {
    rest_mess = "number "+i+", scoring "+(i*5)+".\n" ;
    ret = i * 5;
  } else if (i == 19) {
    rest_mess =  target+"'s face! Score of 250!\n";
    ret = 250;
  } else {
    rest_mess = target+"'s nose! Score of 500!\n";
    ret = 500;
  }
  write("You hit " + rest_mess);
  say( this_player()->query_short() + " hit " + rest_mess);
  return ret;
}
void heart_beat() {
  if (!player1) player1 = find_player(lower_case(name1));
  if (name2 && !player2) player2 = find_player(lower_case(name2));
  if (!player1 || environment() != environment(player1))
    say(name1 + " is no longer here. The game of darts is called off.\n");
  else if (name2 && (!player2 || environment() != environment(player2)))
    say(name2 + " is no longer here. The game of darts is called off.\n");
  else
    return;
  end_game();
}
void end_game() {
  set_heart_beat(0);
  in_use  = 0; bet    = 0; thrown  = 0;
  player1 = 0; player2 = 0;
  name1  = 0; name2  = 0;
  score1  = 0; score2  = 0;
}

==================================================
FILE: misc/dead_book.c
==================================================

inherit "/std/book_dir";
#define DEAD_PAGES "/save/books/dead/dead_page"
void setup() {
  int i, max;
  seteuid(getuid());
  add_property("dead usable", 1);
  set_short("dark brown book");
  set_name("book");
  add_adjective( ({ "dark", "brown", "dead", "death", "dieing" }) );
  set_long("The book has some writing "
           "burnt into the dark brown leather cover.\n");
  add_read_mess("Introduction to death, or what to "
                "do when your blood runs out", 0, "general", 0 );
  set_book_language("general");
  set_book_dir(DEAD_PAGES);
  set_open_page(0);
}
void recovery_from_death() {
  call_out((: tell_object($1, the_short()+" crumbles and vanishes "
                              "mysteriously.\n") :), 1, previous_object());
  call_out("dest_me", 2);
}
mixed query_static_auto_load() { return 0; }
mixed query_dynamic_auto_load() { return 0; }
mixed query_auto_load() { return 0; }
void check_location() {
  if (environment() &&
      !environment()->query_property("dead") &&
      !environment()->query_creator()) {
    say(the_short()+" vanishes suddenly and randomly.\n");
    call_out("dest_me", 1);
  }
}
varargs int move(object dest, string mess1, string mess2) {
  ::move(dest, mess1, mess2);
  call_out("check_location", 1);
}

==================================================
FILE: misc/dead_chicken.c
==================================================

#include <move_failures.h>
#define CHICKEN_FEATHER "/obj/misc/chicken_feather"
#define MIN_FEATHERS 3
#define MAX_FEATHERS 5
inherit "/obj/food";
void    setup();
void    init();
int     do_pluck( object *indirect_obs, string indir_match, string dir_match,
                 mixed *args, string pattern );
mixed   query_dynamic_auto_load();
void    init_dynamic_arg(mapping arg, object);
int plucked;
void setup()
{
  set_name( "chicken" );
  set_short( "dead chicken" );
  add_alias( ({ "corpse", "chicken corpse" }) );
  add_adjective( "dead" );
  set_main_plural( "dead chickens" );
  set_long( function()
            {
              if( plucked )
                return
                  "This is the dead body of a bedraggled chicken.  "
                  "Judging from the total lack of feathers it is "
                  "ready to be cooked.\n";
              return
                  "This is the dead body of a bedraggled chicken.  "
                  "Most people would pluck the few feathers on it "
                  "and then cook it.\n";
            } );
  set_weight( 8 );
  set_value( 300 );
  set_weight_per_bite( 2 );
}
void init()
{
  ::init();
  this_player()->add_command( "pluck", this_object(),
        "<direct:object:me-here>" );
}
int do_pluck( object *indirect_obs, string indir_match, string dir_match,
   mixed *args, string pattern )
{
  object pluck;
  int feathers = random( MAX_FEATHERS - MIN_FEATHERS ) + MIN_FEATHERS;
  if ( plucked ) return notify_fail( "The chicken is already plucked and "
    "bare of any feathers.\n" );
  plucked = 1;
  for ( int i = 0; i < feathers; i++ ) {
    pluck = clone_object( CHICKEN_FEATHER );
    if( MOVE_OK != pluck->move( this_player() ) )
        pluck->move( environment() );
  }
  tell_room( environment( this_player() ),
        this_player()->one_short() + " plucks a dead chicken with reckless "
          "abandon.\n",
        this_player() );
  return notify_fail( "You pluck the bedraggled, dead chicken cheerfully.\n" );
}
mixed query_dynamic_auto_load() {
  return ([ "::" : ::query_dynamic_auto_load(),
            "plucked" : plucked ]);
}
void init_dynamic_arg(mapping arg, object) {
  ::init_dynamic_arg(arg["::"]);
  plucked = arg["plucked"];
}

==================================================
FILE: misc/dead_duck.c
==================================================

#include <move_failures.h>
#define DUCK_FEATHER "/obj/misc/duck_feather.ob"
#define MIN_FEATHERS 3
#define MAX_FEATHERS 5
inherit "/obj/food";
void    setup();
void    init();
int     do_pluck( object *indirect_obs, string indir_match, string dir_match,
                 mixed *args, string pattern );
mixed   query_dynamic_auto_load();
void    init_dynamic_arg(mapping arg, object);
int plucked;
void setup()
{
  set_name( "duck" );
  set_short( "dead duck" );
  add_alias( ({ "corpse", "duck corpse" }) );
  add_adjective( "dead" );
  set_main_plural( "dead ducks" );
  set_long( function()
            {
              if( plucked )
                return
                  "This is the dead body of a bedraggled duck.  Judging "
                  "from the lack of feathers it is ready to be "
                  "cooked.\n";
              return
                  "This is the dead body of a bedraggled duck.  "
                  "Most people would pluck it and then cook it.\n";
            } );
  set_weight( 10 );
  set_value( 400 );
  set_weight_per_bite( 2 );
}
void init()
{
  ::init();
  this_player()->add_command( "pluck", this_object(),
        "<direct:object:me-here>" );
}
int do_pluck( object *indirect_obs, string indir_match, string dir_match,
   mixed *args, string pattern )
{
  object pluck;
  int feathers = random( MAX_FEATHERS - MIN_FEATHERS ) + MIN_FEATHERS;
  if ( plucked ) return notify_fail( "The duck is already plucked and "
    "bare of any feathers.\n" );
  plucked = 1;
  for ( int i = 0; i < feathers; i++ ) {
    pluck = clone_object( DUCK_FEATHER );
    if( MOVE_OK != pluck->move( this_player() ) )
        pluck->move( environment() );
  }
  tell_room( environment( this_player() ),
        this_player()->one_short() + " plucks a dead duck with reckless "
          "abandon.\n",
        this_player() );
  return notify_fail( "You pluck the bedraggled, dead duck cheerfully.\n" );
}
mixed query_dynamic_auto_load() {
  return ([ "::" : ::query_dynamic_auto_load(),
            "plucked" : plucked ]);
}
void init_dynamic_arg(mapping arg, object) {
  ::init_dynamic_arg(arg["::"]);
  plucked = arg["plucked"];
}

==================================================
FILE: misc/dead_eel.c
==================================================

#include <move_failures.h>
#define EEL_SKIN "/obj/misc/eel_skin"
inherit "/obj/food";
void    setup();
void    init();
int     do_skin( object *indirect_obs, string indir_match, string dir_match,
                 mixed *args, string pattern );
int     test_sharp( object weapon );
mixed   query_dynamic_auto_load();
void    init_dynamic_arg(mapping arg, object);
int skinned;
void setup()
{
  set_name( "eel" );
  set_short( "dead eel" );
  add_alias( ({ "corpse", "eel corpse" }) );
  add_adjective( "dead" );
  set_main_plural( "dead eels" );
  set_long( function()
	    {
	      if( skinned )
		return
		  "This is the dead body of an unfortunate eel.  "
		  "As if being dead wasn't bad enough, it has also "
		  "been skinned.\n";
	      return
		  "This is the dead body of an unfortunate eel.  "
		  "Most people skin such a fish before eating it.\n";
	    } );
  set_weight( 60 );
  set_value( 200 );
  set_weight_per_bite( 2 );
}
void init()
{
  ::init();
  this_player()->add_command( "skin", this_object(),
        "<direct:object:me-here> with <indirect:object:me>" );
}
int do_skin( object *indirect_obs, string indir_match, string dir_match,
   mixed *args, string pattern )
{
  object skin;
  if ( skinned ) return notify_fail( "The eel is already skinned.\n" );
  if( !test_sharp( indirect_obs[0] ) )
    {
      tell_room( environment( this_player() ),
	     this_player()->one_short() + " unsuccessfully tries to "
             "skin an eel with " + indirect_obs[0]->one_short() + ".\n",
             this_player() );
      return notify_fail( indirect_obs[0]->the_short() +
            " only makes a shallow mark in the eel skin.  "
            "It would probably be easier to skin the eel "
            "with some kind of sharp implement.\n" );
    }
  skinned = 1;
  skin = clone_object( EEL_SKIN );
  if( MOVE_OK != skin->move( this_player() ) )
        skin->move( environment() );
  tell_room( environment( this_player() ),
        this_player()->one_short() + " skins an eel with "
        + indirect_obs[0]->one_short() + ".\n",
        this_player() );
  return notify_fail( "You skin the dead eel with " +
        indirect_obs[0]->the_short() + ".\n" );
}
int test_sharp( object weapon )
{
  int i;
  mixed *pongo;
  pongo = weapon->weapon_attacks();
  for( i = 1; i < sizeof( pongo ); i++ )
    {
      if( pongo[i] == "sharp" ) return 1;
    }
  return 0;
}
mixed query_dynamic_auto_load() {
  return ([ "::" : ::query_dynamic_auto_load(),
            "skinned" : skinned ]);
}
void init_dynamic_arg(mapping arg, object) {
  ::init_dynamic_arg(arg["::"]);
  skinned = arg["skinned"];
}

==================================================
FILE: misc/delete_thyself.c
==================================================

inherit "/std/object";
void create() {
   ::create();
   if (clonep(this_object())) {
      call_out((: move("/room/rubbish") :), 3);
   }
}
void init_dynamic_arg(mapping map) {
}
void init_static_arg() {
}

==================================================
FILE: misc/deplusser.c
==================================================

inherit "/std/object.c";
void setup()  {
   set_short("deplusser");
   set_name("deplusser");
   set_long("It's shaped like a plus sign set in a circle, with a diagonal "
             "slash across it.  Type 'deplus <path>' to use.");
   set_weight(9);
}
void init()  {
   add_command("deplus", "<string'file'>", (:this_object()->deplus($4[0]):));
}
int deplus( string fname )  {
   string *files, *lines, last_line, this_line, next_line, old;
   int i, j, sz;
   seteuid(geteuid(this_player()));
   files = get_dir( this_player()->get_path( fname ) );
   if ( !sizeof(files) )
      return notify_fail( "No files found\n" );
   for (i = 0; i < sizeof(files); i++ )  {
      if ( file_size( this_player()->get_path( files[i] ) ) == -2 )  continue;
      old = read_file( this_player()->get_path( files[i] ) );
      lines = explode( replace_string( old, "\t", "   " ), "\n" );
      if ( ( sz = sizeof( lines ) ) < 2 )  continue;
      last_line = implode( explode( lines[0], " " ), "" );
      this_line = implode( explode( lines[1], " " ), "" );
      if ( sz > 2 )
         next_line = implode( explode( lines[2], " " ), "" );
      else next_line = "";
      for (j = 1, sz = sizeof(lines); j < sz - 1; j++ )  {
         if ( last_line[<2 .. <1] == "\"+"  &&
             strlen( this_line )  &&  this_line[0] == '\"' )
            lines[j-1] = lines[j-1][0 .. strsrch(lines[j-1], "+", -1) - 1];
         else if ( this_line[0 .. 1] == "+\""  &&
                   strlen(last_line)  && last_line[<1] == '\"' )
            lines[j] = " " + delete( lines[j], strsrch(lines[j], "+"), 1 );
         last_line = this_line;
         this_line = next_line;
         if ( j < sz - 2 )
            next_line = implode( explode( lines[j+2], " " ), "" );
      }
      if ( !rm( this_player()->get_path(files[i]) ) )
         write("Couldn't remove old file: " + files[i] + "\n" );
      else if ( !write_file(this_player()->get_path(files[i]),
                            implode(lines, "\n" ) + "\n" ) )  {
         write("Could not write new file: " + files[i] + "\n" );
         if ( !write_file(this_player()->get_path(files[i]), old ) )
            return notify_fail("Uh-oh, could not replace old file either.\n");
      }
      else write("File deplussed: " + files[i] + "\n");
   }
   return 1;
}

==================================================
FILE: misc/detabber.c
==================================================

inherit "/std/object";
void setup()
{   set_name("detabber");
    set_long("A long stick with absoulutely no tabs in it.\n"
             "Usage:  detab <filename>.\n");
}
void init()
{   this_player()->add_command("detab",this_object(),"<string>");
}
int do_detab(object *indirect_obs, string *dir_match, string indir_match, mixed *args, string pattern)
{
    string file;
    string tb;
    tb = sprintf("\t");
    file = read_file(args[0]);
    if(file)
        {file = replace_string(file,"\t","    ");
         write_file(args[0],file,1);
         return 1;
         }
    return 0;
}

==================================================
FILE: misc/easel.c
==================================================

#define DIRS ([ \
      "north" : ({ ({ 0, -1 }), ({ "|" }) }), \
      "northeast" : ({ ({ 1, -1 }), ({ "/" }) }), \
      "east" : ({ ({ 1, 0 }), ({ "-" }) }), \
      "southeast" : ({ ({ 1, 1 }), ({ "\\" }) }), \
      "south" : ({ ({ 0, 1 }), ({ "|" }) }), \
      "southwest" : ({ ({ -1, 1 }), ({ "/" }) }), \
      "west" : ({ ({ -1, 0 }), ({ "-" }) }), \
      "northwest" : ({ ({ -1, -1 }), ({ "\\" }) }), \
   ])
#define PRIMES ({ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 })
inherit "/std/object";
int *origin;
string *lines;
void setup() {
   set_name( "easel" );
   set_short( "small easel" );
   add_adjective( "small" );
   set_main_plural( "small easels" );
   set_value( 800 );
   origin = ({ 0, 0 });
   lines = ({ });
}
int *query_origin() { return origin; }
string *query_lines() { return lines; }
string long( string word, int dark ) {
   int i, max, min, width;
   string part;
   if ( !sizeof( lines ) )
      return "The easel is blank.\n";
   width = ( (int)this_player()->query_cols() - 2 ) / 2;
   min = origin[ 0 ] - width;
   max = origin[ 0 ] + width;
   if ( min < 0 ) {
      max -= min;
      min = 0;
   }
   if ( max >= strlen( lines[ 0 ] ) )
      max = strlen( lines[ 0 ] ) - 1;
   part = "";
   for ( i = 0; i < sizeof( lines ); i++ )
      part += " "+ lines[ i ][ min .. max ] +"\n";
   return part;
}
int query_at( int *place ) {
   if ( !sizeof( lines ) )
      return 32;
   if ( ( origin[ 0 ] + place[ 0 ] ) < 0 )
      return 32;
   if ( ( origin[ 0 ] + place[ 0 ] ) >= strlen( lines[ 0 ] ) )
      return 32;
   if ( ( origin[ 1 ] + place[ 1 ] ) < 0 )
      return 32;
   if ( ( origin[ 1 ] + place[ 1 ] ) >= sizeof( lines ) )
      return 32;
   return lines[ origin[ 1 ] + place[ 1 ] ][ origin[ 0 ] + place[ 0 ] ];
}
void add_shape( int *start, string *pieces ) {
   int i, number, max, width;
   string gap, front, back;
   for ( i = 0; i < sizeof( pieces ); i++ )
      if ( strlen( pieces[ i ] ) > max )
         max = strlen( pieces[ i ] );
   if ( sizeof( lines ) )
       width = strlen( lines[ 0 ] );
   else
      lines = ({ "" });
   if ( ( origin[ 0 ] + start[ 0 ] ) < 0 ) {
      gap = "";
      for ( i = origin[ 0 ] + start[ 0 ]; i < 0; i++ )
         gap += " ";
      for ( i = 0; i < sizeof( lines ); i++ )
         lines[ i ] = gap + lines[ i ];
      origin[ 0 ] = -start[ 0 ];
   }
   if ( ( origin[ 0 ] + start[ 0 ] + max ) > width ) {
      gap = "";
      for ( i = width; i < ( origin[ 0 ] + start[ 0 ] + max ); i++ )
         gap += " ";
      for ( i = 0; i < sizeof( lines ); i++ )
         lines[ i ] += gap;
   }
   max = sizeof( pieces );
   width = sizeof( lines );
   if ( ( origin[ 1 ] + start[ 1 ] ) < 0 ) {
      gap = "";
      for ( i = 0; i < strlen( lines[ 0 ] ); i++ )
         gap += " ";
      for ( i = origin[ 1 ] + start[ 1 ]; i < 0; i++ )
         lines = ({ gap }) + lines;
      origin[ 1 ] = -start[ 1 ];
   }
   if ( ( origin[ 1 ] + start[ 1 ] + max ) > width ) {
      gap = "";
      for ( i = 0; i < strlen( lines[ 0 ] ); i++ )
         gap += " ";
      for ( i = width; i < ( origin[ 1 ] + start[ 1 ] + max ); i++ )
         lines += ({ gap });
   }
   for ( i = origin[ 1 ] + start[ 1 ]; i < ( origin[ 1 ] + start[ 1 ] + max );
         i++ ) {
      number = origin[ 0 ] + start[ 0 ];
      if ( number > 0 )
         front = lines[ i ][ 0 .. number - 1 ];
      else
         front = "";
      number = origin[ 0 ] + start[ 0 ] +
            strlen( pieces[ i - origin[ 1 ] - start[ 1 ] ] );
      if ( number < strlen( lines[ i ] ) )
         back = lines[ i ][ number .. strlen( lines[ i ] ) - 1 ];
      else
         back = "";
      lines[ i ] = front + pieces[ i - origin[ 1 ] - start[ 1 ] ] + back;
   }
}
string *make_block( int size, int home ) {
   int i, j;
   string start, end, *blocks;
   if ( size == 1 )
      if ( home )
         return ({ "@" });
      else
         return ({ "#" });
   blocks = allocate( size );
   if ( home )
      blocks[ 0 ] = "@";
   else
      blocks[ 0 ] = "+";
   for ( i = 2; i < size; i++ )
      blocks[ 0 ] += "-";
   if ( home )
      blocks[ 0 ] += "@";
   else
      blocks[ 0 ] += "+";
   for ( i = 2; i < size; i++ ) {
      blocks[ i - 1 ] = "|";
      for ( j = 2; j < size; j++ )
         blocks[ i - 1 ] += ".";
      blocks[ i - 1 ] += "|";
   }
   if ( home )
      blocks[ size - 1 ] = "@";
   else
      blocks[ size - 1 ] = "+";
      for ( i = 2; i < size; i++ )
      blocks[ size - 1 ] += "-";
   if ( home )
      blocks[ size - 1 ] += "@";
   else
      blocks[ size - 1 ] += "+";
   return blocks;
}
void make_map( mixed *locations, mapping connections ) {
   int i, j, k, x, y, *sizes;
   string *places;
   mapping centres;
   sizes = ({ });
   places = ({ });
   centres = ([ ]);
   for ( i = 0; i < sizeof( locations ); i+= 2 ) {
      sizes += ({ locations[ i + 1 ] });
      places += ({ locations[ i ] });
      reset_eval_cost();
   }
   for ( i = 0; i < sizeof( PRIMES ); i++ ) {
      x = 0;
      y = 0;
      for ( j = 0; j < sizeof( sizes ); j++ ) {
         if ( PRIMES[ i ] > sizes[ j ] ) {
            x = 1;
            break;
         }
         if ( sizes[ j ] % PRIMES[ i ] )
            y = 1;
      }
      if ( x )
         break;
      if ( !y ) {
         for ( j = 0; j < sizeof( sizes ); j++ )
            sizes[ j ] /= PRIMES[ i ];
         i--;
      }
   }
   reset_eval_cost();
   centres[ places[ 0 ] ] = ({ 0, 0 });
   for ( i = 0; i < sizeof( places ); i++ ) {
      tell_object( find_player( "deutha" ), "On "+ i +", "+ places[ i ] +
            ", at "+ centres[ places[ i ] ][ 0 ] +", "+
            centres[ places[ i ] ][ 1 ] +" for "+ sizes[ i ] +"\n" );
      add_shape( ({ centres[ places[ i ] ][ 0 ] - sizes[ i ],
            centres[ places[ i ] ][ 1 ] - sizes[ i ] }),
            make_block( 2 * sizes[ i ] - 1, !i ) );
      if ( undefinedp( connections[ places[ i ] ] ) )
            continue;
      for ( j = 0; j < sizeof( connections[ places[ i ] ] ); j += 2 ) {
         reset_eval_cost();
         add_shape( ({ centres[ places[ i ] ][ 0 ] -1 + sizes[ i ] *
               DIRS[ connections[ places[ i ] ][ j ] ][ 0 ][ 0 ],
               centres[ places[ i ] ][ 1 ] -1 + sizes[ i ] *
               DIRS[ connections[ places[ i ] ][ j ] ][ 0 ][ 1 ] }),
               DIRS[ connections[ places[ i ] ][ j ] ][ 1 ] );
         k = member_array( connections[ places[ i ] ][ j + 1 ], places );
         if ( k < 0 )
            continue;
         x = centres[ places[ i ] ][ 0 ] +
               DIRS[ connections[ places[ i ] ][ j ] ][ 0 ][ 0 ] *
               ( sizes[ i ] + sizes[ k ] );
         y = centres[ places[ i ] ][ 1 ] +
               DIRS[ connections[ places[ i ] ][ j ] ][ 0 ][ 1 ] *
               ( sizes[ i ] + sizes[ k ] );
         centres[ places[ k ] ] = ({ x, y });
         tell_object( find_player( "deutha" ), "Put "+
               connections[ places[ i ] ][ j + 1 ] +" at "+
               x +", "+ y +"\n" );
         reset_eval_cost();
      }
   }
}

==================================================
FILE: misc/eel_skin.c
==================================================

inherit "/std/object";
void setup()
{
  set_name( "skin" );
  set_short( "eel skin" );
  add_adjective( "eel" );
  set_main_plural( "eel skins" );
  set_long( "This is the skin of an eel.  It is very greasy and "
        "glistens prettily when you tilt it towards the light.\n" );
  set_weight( 3 );
  set_value( 100 );
}

==================================================
FILE: misc/envelope.c
==================================================

#define SMALL   3
#define MEDIUM  5
#define LARGE   8
#define UNSEALED  1
#define SEALED    2
#define OPENED    3
inherit "/obj/baggage";
nosave int status;
void make_envelope( string description, int size ) {
   string adjective, noun;
   if( size < 2 )
      size = 2;
   switch( size ) {
      case 0..SMALL:
         adjective = "small";
         noun = "envelope";
         break;
      case SMALL + 1..MEDIUM:
         adjective = "medium sized";
         noun = "envelope";
         break;
      case MEDIUM + 1..LARGE:
         adjective = "large";
         noun = "envelope";
         break;
      default:
         adjective = "large";
         noun = "packet";
         add_alias("packet");
   }
   set_name( "envelope" );
   set_short( adjective + " " + description + " " + noun );
   add_adjective( adjective );
   add_adjective( explode( description, " " ) );
   set_long( "This is a " + adjective + " " + description + " envelope.  " );
   set_weight( 1 );
   set_value( 300 + size * 20 );
   set_max_weight( size );
   set_material( "paper" );
   add_property( "writeable", 1 );
   add_extra_look( this_object() );
   status = UNSEALED;
}
void init() {
   ::init();
   this_player()->add_command( "seal", this_object(),
      "<direct:object:me>" );
   this_player()->add_command( "unseal", this_object(),
      "<direct:object:me>" );
}
string long( string str, int dark ) {
   string desc;
   switch( status ) {
   case UNSEALED :
      desc = "It has a sticky flap at one end with which you could "
         "probably seal it if you wanted to, though it might be wise to put "
         "something into it first or you're going to feel rather silly.\n";
      break;
   case SEALED :
      desc = "The sticky flap seems to have been sealed down.\n";
      break;
   case OPENED :
      desc = "It looks like it has been sealed and then opened up.\n";
      break;
   default :
      desc = "It is completely broken - you'd better tell a liaison.\n";
   }
   return ::long( str, dark ) + desc;
}
int do_seal() {
   if( status != UNSEALED ) {
      return notify_fail( this_object()->the_short() + " has already been "
         "sealed.\n" );
   }
   do_close();
   set_stuck( 1 );
   status = SEALED;
   this_player()->add_succeeded_mess( this_object(), "$N lick$s the flap on "
      "$D and seal$s it down.\n", ({ }) );
   return 1;
}
int do_unseal() {
   if( status != SEALED ) {
      return notify_fail( this_object()->the_short() + " has not been "
         "sealed.\n" );
   }
   set_stuck( 0 );
   do_open();
   status = OPENED;
   this_player()->add_succeeded_mess( this_object(), "$N tear$s back the "
      "flap on $D and open$s it.\n", ({ }) );
   return 1;
}
int query_envelope_status() {
   return status;
}
mixed *stats() {
   return ::stats() + ({
      ({ "status", status, }),
   });
}
mapping int_query_static_auto_load() {
   return ([
      "::" : ::int_query_static_auto_load(),
      "status" : status,
   ]);
}
void init_static_arg( mapping map ) {
   if( map["::"] )
      ::init_static_arg( map["::"] );
   if( !undefinedp( map["status"] ) )
      status = map["status"];
}
mixed query_static_auto_load() {
   if( base_name( this_object() ) + ".c" == __FILE__ )
      return int_query_static_auto_load();
   return ([ ]);
}

==================================================
FILE: misc/fire_cracker.c
==================================================

inherit "/std/object";
#define EFFECT "/w/dogbolter/cracker_eff"
#define DURATION 180
void setup() {
    set_name( "firecracker" );
    add_alias( "cracker" );
    add_adjective( "fire" );
    add_plural( "crackers" );
    set_short( "fire cracker" );
    set_long( "This is a large red fire cracker of Auriental manufacture"
      ".  It's the sort of thing that is thrown at weddings.  You may "
      "'light' it, and 'throw' it.\n" );
    set_weight( 2 );
    set_value( 500 );
    set_read_mess("ACME Firecracker", "agatean");
}
void explosion() {
    object victim;
    if( !environment() )
        return;
    if( living( environment() ) ) {
        victim = environment();
        tell_object( environment(), "%^BOLD%^%^RED%^$C$"+ the_short()
          +" explodes in your face!\nMeep meep!%^RESET%^\n" );
        environment()->add_effect (EFFECT, DURATION);
        if( environment( environment() ) ) {
            tell_room( environment( environment() ), "%^BOLD%^%^RED%^$C$"+
              the_short() +" explodes in "+
              environment()->the_short() +"'s face!\nMeep meep!%^RESET%^\n",
              environment() );
        }
    } else {
        tell_room( environment(), "%^BOLD%^%^RED%^$C$"+ the_short()
          +" explodes!%^RESET%^\n" );
    }
    move( "/room/rubbish" );
}
int do_light() {
    call_out( (: explosion :), 10 );
    add_succeeded_mess( "$N $V $D and smoke begins to pour out.\n",
      ({ }) );
    return 1;
}
int do_throw() {
    if( environment() && environment( environment() ) ) {
        add_succeeded_mess( "$N $V $D on the ground.\n", ({ }) );
        move( environment( environment() ) );
        return 1;
    } else {
        add_failed_mess( "There is no ground to $V $D on.  How very odd\n",
          ({ }) );
        return 0;
    }
}
void init() {
    add_command( "light", "<direct:object:me>", (: do_light :) );
    add_command( "throw", "<direct:object:me>", (: do_throw :) );
}
string query_death_reason() {
    return "being blown up by a fire cracker, in true Road Runner Style.\n"
    "%^BOLD%^Meep meep!%^RED%^";
}

==================================================
FILE: misc/football.c
==================================================

inherit "/std/object";
string me, him;
void setup() {
     set_name("football");
     set_short("leather football");
     add_adjective("leather");
     add_alias("ball");
     set_long("This is a leather football, pumped up hard.  Looks like you could"
             " kick it to people.\n");
     set_weight(10);
     set_value(1);
     add_plural("footballs");
     add_plural("balls");
}
void init() {
  this_player()->add_command("kick", this_object(),
        "<direct:object:me> to <indirect:player>");
  add_command( "kickup", "<direct:object>" );
}
int do_kickup()  {
   write( "You kick the football into the air a few times, stopping it from "
   "hitting the floor by bouncing it off your knee, your chest and your feet."
   "  A rare display of skill!\n" );
tell_room( environment( this_player() ),
     this_player()->query_cap_name() + " expertly kicks the ball into the "
     "air, heads it back up, bounces it a few times on their chest and displays "
     "an uncanny level of skill.\n", this_player());
   return 1;
}
int do_kick(object *in_dir) {
  if (!sizeof(in_dir))
    return 0;
  if (move(in_dir[0])) {
    tell_object(in_dir[0], this_player()->query_cap_name()+" kicks "+
        this_object()->query_short()+" at you, but it falls on the floor.\n");
    tell_room(environment(in_dir[0]), "A leather football flies "
        "through the air, "+ in_dir[0]->query_name()+" tries to trap it "
        "but fails and it lands next to them.", ({ in_dir[0], this_player() }) );
    move(environment(in_dir[0]));
  } else {
    tell_object(in_dir[0], this_player()->query_cap_name()+" kicks a "
           "leather football at you.  It curls towards you at speed but you "
           "manage to " +
           ({ "trap it with your foot.",
           "bounce it off your chest and trap it underfoot.",
           "head it to the ground, juggle it a few times and eventually stand"
           " on it",
           "catch it. HANDBALL!",
           "look like the famous footballer Fele and trap it.",
           "trap it easily.  You should sign up for Ankh Morpork Wanderers."})
           [random (6) ]+"\n");
    tell_room(environment(in_dir[0]), "A leather football curls "
           "gracefully towards "+ in_dir[0]->query_cap_name()+", who "+
                "manages to "+
                ({ "trap it with their foot.",
           "bounce it off their chest and trap it underfoot.",
           "head it to the ground, juggle it a few times and eventually stands"
           " on it",
           "catches it. HANDBALL!",
           "look like the famous footballer Fele and trap it.",
           "trap it easily.  They should sign up for Ankh Morpork Wanderers."})
           [random (6) ]+
                "\n",
          ({ in_dir[0], this_player() }));
  }
  this_player()->add_succeeded(in_dir[0..0]);
  return 1;
}

==================================================
FILE: misc/fountain.c
==================================================

#include <volumes.h>
#define FOUNTAIN_SIZE 150000
#define DEFAULT_CYCLE_TIME 60 * ( 2 + random( 2 ) )
inherit "/obj/vessel";
string _liquid_path;
int _liquid_volume;
int _time;
void setup() {
  set_name( "fountain" );
  set_short( "fountain" );
  set_long( "This is a fountain.\n" );
  set_max_volume( FOUNTAIN_SIZE );
  set_weight( 100000 );
  set_stuck( 1 );
}
varargs void initialise( string path, int amount, int time) {
  if ( !stringp( path ) )
    error( "Path not set in initialise.\n" );
  if ( !intp( amount ) )
    amount = VOLUME_LITRE;
  if ( !time )
    time = DEFAULT_CYCLE_TIME;
  _liquid_path = path;
  _liquid_volume = amount;
  _time = time;
  call_out( "make_water", 5 );
  return;
}
varargs void reinitialise( string path, int amount, int time) {
  if ( !stringp( path ) )
    error( "Path not set in initialise.\n" );
  if ( !intp( amount ) )
    amount = VOLUME_LITRE;
  if ( !time )
    time = DEFAULT_CYCLE_TIME;
  _liquid_path = path;
  _liquid_volume = amount;
  _time = time;
  return;
}
void make_water() {
object water;
  if ( !( query_max_volume() - query_volume() ) ) {
    tell_room( environment(), sprintf( "Some of the %s in %s sloshes over the sides.\n",
      query_multiple_short( all_inventory() ), this_object()->the_short() ) );
    remove_volume( -VOLUME_QUART * random( 4 ) * 2 );
  }
  water = clone_object( _liquid_path );
  water->set_amount( _liquid_volume );
  call_out( (: $(water)->move( this_object() ) :), 1 );
  switch( water->query_amount() ) {
	case 0 .. VOLUME_SHOT:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
  	  water->a_short(), ({ "trickles", "seeps", "dribbles" })[random(3)],
	  this_object()->the_short() ) );
      break;
    case VOLUME_SHOT + 1 .. VOLUME_PINT:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
		water->a_short(),  ({ "flows", "splashes", "pours" })[random(3)],
		this_object()->the_short() ) );
      break;
    case VOLUME_PINT + 1 .. VOLUME_LITRE:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
		water->a_short(), ({ "streams", "cascades", "sloshes" })[random(3)],
		this_object()->the_short() ) );
      break;
    case VOLUME_LITRE + 1 .. VOLUME_QUART:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
	    water->a_short(), ({ "gushes", "courses", "swirls" })[random(3)],
        this_object()->the_short() ) );
      break;
    default:
      tell_room( environment(), sprintf( "$C$%s %s into %s.\n",
        water->a_short(), ({ "floods", "surges", "washes" })[random(3)],
  	    this_object()->the_short() ) );
      break;
  }
  call_out( "make_water", _time );
}

==================================================
FILE: misc/frisbee.c
==================================================

inherit "/std/object";
string me, him;
void setup() {
  set_name("frisbee");
  set_short("black frisbee");
  add_adjective("black");
  set_long("This is a small black frisbee.  It looks like you could "
           "throw it to "
           "people.\n");
  add_property("feeding_frenzy", "frisbee");
  set_weight(10);
  set_value(200);
  set_main_plural("black frisbees");
  add_plural("frisbees");
}
void init() {
  this_player()->add_command("throw", this_object(),
                             "<direct:object:me> to <indirect:player>");
}
int do_throw(object *in_dir) {
  if (!sizeof(in_dir))
    return 0;
  if (move(in_dir[0])) {
    tell_object(in_dir[0], this_player()->one_short()+" throws "+
                this_object()->short()+" at you, but it falls on the floor.\n");
    tell_room(environment(in_dir[0]), "A frisbee arcs through the air, "+
              in_dir[0]->query_name()+" tries to catch it but fails and it "+
              "falls on the floor.\n", ({ in_dir[0], this_player() }) );
    move(environment(in_dir[0]));
  } else {
    tell_object(in_dir[0], this_player()->one_short()+" throws a frisbee "+
                "at you, you catch it... just.\n");
    tell_room(environment(in_dir[0]), in_dir[0]->one_short()+
          " fumbles the catch of the "+
          short(0)+" but manages to keep hold of it.\n",
          ({ in_dir[0], this_player() }));
  }
  this_player()->add_succeeded(in_dir[0..0]);
  return 1;
}

==================================================
FILE: misc/glass.c
==================================================

inherit "/obj/vessel";
nosave string description, actual_drink, actual_glass_size;
void create() {
    do_setup++;
    ::create();
    do_setup--;
    set_name("glass");
    set_weight(1);
    set_value(400);
    set_stuck(1);
    set_leak_rate(0);
    set_material("glass");
    add_property("fragile", 200);
    if (!do_setup) {
        this_object()->setup();
    }
}
void make_glass(string drink, string glass_description, string glass_size,
   int amount, int has_contents)
{
    string *glass_adjectives;
    object contents;
    description = glass_description;
    actual_drink = drink;
    actual_glass_size = glass_size;
    glass_adjectives = explode( glass_size, " " )[0..<2];
    set_short( glass_size );
    set_long( (: this_object()->query_volume() ? description : "This is "
        "a dirty " + actual_glass_size + ", one that used to hold some "
        " " + actual_drink + ".\n" :) );
    glass_adjectives = explode( glass_size, " " );
    if (sizeof(glass_adjectives) > 1)
        add_alias(glass_adjectives[<1..]);
    else
        add_alias(glass_size);
    add_adjective(glass_adjectives);
    set_max_volume(amount);
    if (has_contents) {
        contents = clone_object("/obj/reagents/generic_liquid.ob");
        contents->set_name("drink");
        contents->set_short(drink);
        contents->set_long("This is some delicious looking " + drink + ".\n" );
        contents->add_adjectives(explode(drink, " ")[0..<2]);
        contents->add_alias( explode( drink, " " )[ sizeof(
           explode( drink, " " ) ) - 1 ] );
        contents->set_amount(amount);
        contents->move(this_object());
    }
}
mapping int_query_static_auto_load() {
    return ([
        "::": ::int_query_static_auto_load(),
        "description": description,
        "actual_drink" : actual_drink,
        "actual_glass_size" : actual_glass_size,
    ]);
}
void init_static_arg(mapping map) {
    if (map["::"])
        ::init_static_arg(map["::"]);
    if (!undefinedp(map["description"]))
        description = map["description"];
    if (!undefinedp(map["actual_drink"]))
        actual_drink = map["actual_drink"];
    if (!undefinedp(map["actual_glass_size"]))
        actual_glass_size = map["actual_glass_size"];
    set_long((: this_object()->query_volume() ? description : "This is "
        "a dirty " + actual_glass_size + ", one that used to hold some "
        "sort of " + actual_drink + ".\n" :));
}
mixed query_static_auto_load() {
    if (base_name(this_object()) == "/obj/misc/glass" )
        return int_query_static_auto_load();
    return ([ ]);
}

==================================================
FILE: misc/golem_corpse.c
==================================================

#include <armoury.h>
inherit "/obj/container";
void make_fragments();
void setup() {
    set_name( "rubble" );
    set_short( "heap of clay rubble" );
    add_alias( ({"heap", "clay"}) );
    add_adjective( ({"heap of", "clay"}) );
    set_main_plural( "heaps of clay rubble" );
    add_plural( "heaps" );
    set_weight( 40000 );
    set_max_weight( 50000 );
    set_value( 0 );
    set_stuck( 1 );
    make_fragments();
    add_property( "no recycling", 1 );
}
void make_fragments() {
    int amount = random( 8 );
    int i;
    for( i = 1; i <= amount; i++ )
        switch( random( 11 ) ) {
           case 0..5:
               ARMOURY->request_item( "golem shard", 100 )->
                   move( this_object() );
               break;
           case 6..7:
               ARMOURY->request_item( "golem finger", 100 )->
                   move( this_object() );
               break;
           case 8..9:
               ARMOURY->request_item( "golem toe", 100 )->
                   move( this_object() );
               break;
           case 10:
               ARMOURY->request_item( "golem eye", 100 )->
                   move( this_object() );
               break;
        }
}
string long( string word, int dark ) {
    string inv = query_multiple_short( all_inventory( this_object() ) );
    string tmp = "";
    switch( sizeof( all_inventory( this_object() ) ) ) {
        case 0:
           break;
        case 1:
            tmp = "Something that looks like " + inv + " protrudes from it.  ";
            break;
        default:
            tmp = "It looks like " + inv + " are buried in it.  ";
    }
    return "This is a large heap of shattered clay.  " + tmp + "Whatever this "
        "was before, it is destroyed thouroughly and beyond any means of "
        "repair.\n";
}

==================================================
FILE: misc/golem_eye.c
==================================================

inherit "/std/object";
void setup() {
    set_name( "triangle" );
    set_short( "clay triangle" );
    add_adjective( ({"clay"}) );
    set_long( "This is a cracked piece of clay.  A hole in the shape of a "
       "triangle is in its middle.\n" );
    set_main_plural( "clay triangles" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
}

==================================================
FILE: misc/golem_finger.c
==================================================

inherit "/std/object";
void setup() {
    set_name( "fingertip" );
    set_short( "broken clay fingertip" );
    add_adjective( ({"broken", "clay"}) );
    set_long( "This looks like a crude fingertip made of clay.  It is broken "
       "in the middle.\n" );
    set_main_plural( "broken clay fingertips" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
}

==================================================
FILE: misc/golem_shard.c
==================================================

inherit "/std/object";
void setup() {
    set_name( "shard" );
    set_short( "cracked clay shard" );
    add_adjective( ({"clay"}) );
    set_long( "This is a heavily cracked clay shard." );
    set_main_plural( "cracked clay shards" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
}

==================================================
FILE: misc/golem_toe.c
==================================================

inherit "/std/object";
void setup() {
    set_name( "toe" );
    set_short( "remains of a clay toe" );
    add_adjective( ({"remains", "of", "a", "clay"}) );
    set_long( "This looks part of a toe made of clay.\n" );
    set_main_plural( "remains of clay toes" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
    add_property( "determinate", "the " );
}

==================================================
FILE: misc/grinder.c
==================================================

#include <move_failures.h>
#define STATE_CHANGE "/obj/handlers/state_change"
inherit "/obj/container";
int test_add(object ob, int flag);
int do_grind( string what );
int do_empty(object *dest, string me, string him, string prep);
void set_max_grindable( int i );
int query_max_grindable();
string long_status();
private int _max_grind = 0;
void setup() {
  set_name( "grinder" );
  set_short( "food grinder" );
  add_adjective( "food" );
  set_main_plural( "food grinders" );
  set_long( "This is a mechanical contraption to grind food into small "
      "pieces.  There is a funnel-type piece at the top, a crank on one "
      "side and on the other a pipe where the ground food comes out and "
      "is caught in a small tray.\n" );
  set_value( 4000 );
  set_weight( 100 );
  set_max_weight( 100 );
}
void init() {
  this_player()->add_command( "grind", this_object(),
      "<string'object'> in <direct:object'" + query_short() + "'>",
      (: do_grind( $4[0] ) :) );
  add_command( "empty", "<direct:object>" );
}
int test_add(object ob, int flag) {
  object stuff = first_inventory();
  if (stuff) {
    add_failed_mess( "There is already some " + stuff->query_short()
      + " in the grinder.  You'll have to empty it first.\n");
    return 0;
  } else return 1;
}
int do_grind( string what ) {
  object *things, thing;
  object ground;
  object contents;
  things = match_objects_for_existence( what, ({ this_object(),
                                                 this_player() }) );
  if( !sizeof( things ) ) {
    add_failed_mess( "You must be holding something or put it in $D in "
                     "order to $V it.\n" );
    return -1;
  }
  thing = things[0];
  if( ( contents = first_inventory() ) && contents != thing ) {
    add_failed_mess( "$D isn't empty.\n" );
    return -1;
  }
  if( query_max_grindable() &&
      ( thing->query_amount() > query_max_grindable() ||
        thing->query_weight() > query_max_grindable() ) ) {
    add_failed_mess( "You cannot grind that much with $D at once.\n" );
    return -1;
  }
  ground = STATE_CHANGE->transform( thing, "grind" );
  if ( !objectp( ground ) ) {
    add_failed_mess( "You cannot $V $I in $D.\n", ({ thing }) );
    return -1;
  }
  thing->move( "/room/rubbish" );
  if( ground->move( this_object() ) != MOVE_OK ) {
    ground->move( environment( this_player() ) );
    add_succeeded_mess( "$N grind$s $I with $D, spilling it onto the " +
        ( environment( this_player() )->query_property( "location" ) ==
        "inside" ? "floor" : "ground" ) + ".\n" );
    return 1;
  }
  this_player()->add_succeeded_mess( this_object(), "$N grind$s $I "
    "in $D.\n", ({ thing }) );
  return 1;
}
int do_empty(object *dest, string me, string him, string prep) {
  object ground = first_inventory( this_object() );
  if( !ground ) {
    add_failed_mess( "There is nothing in $D.\n" );
    return 0;
  }
  if( ground->move( this_player() ) != MOVE_OK ) {
    ground->move( environment( this_player() ) );
    add_succeeded_mess( "$N $V $D onto the " +
        ( environment( this_player() )->query_property( "location" ) ==
        "inside" ? "floor" : "ground" ) + ".\n" );
    return 1;
  }
  return 1;
}
void set_max_grindable( int i ) { _max_grind = i; }
int query_max_grindable() { return _max_grind; }
string long_status() { return ""; }

==================================================
FILE: misc/housing_creator.c
==================================================

inherit "/std/object";
#include <housing.h>
#define ORIENTATION ({ "north", "northeast", "east", "southeast", "south", "southwest", "west", "northwest", "up" })
#define OPP_ORIENTATION ({ "south", "southwest", "west", "northwest", "north", "northeast", "east", "southeast", "down" })
#define PATH "/std/houses/"
int do_create(string type, string orientation, string location, string out,
              string region, string address, int overwrite,
              int test);
string list_plans();
void setup() {
  set_name("ball");
  set_short("small jade ball");
  add_adjective(({"small", "jade"}));
  set_long("This non-descript jade ball can be used to make player houses.\n");
  set_read_mess((: list_plans() :));
  set_weight(1);
  set_value(0);
  seteuid("Room");
}
void init() {
  this_player()->add_command("make", this_object(),
           "<word'floor plan'> <word'orientation'> "
           "<word'location'> <word'outside'> <word'region'> <string:quoted'address'>",
           (: do_create($4[0], $4[1], $4[2], $4[3], $4[4], $4[5], 0, 1) :) );
  this_player()->add_command("makereal", this_object(),
           "<word'floor plan'> <word'orientation'> "
           "<word'location'> <word'outside'> <word'region'> <string:quoted'address'>",
           (: do_create($4[0], $4[1], $4[2], $4[3], $4[4], $4[5], 0, 0) :) );
  this_player()->add_command("maketest", this_object(),
           "<word'floor plan'> <word'orientation'> "
           "<word'location'> <word'outside'> <word'region'> <string:quoted'address'>",
           (: do_create($4[0], $4[1], $4[2], $4[3], $4[4], $4[5], 1, 1) :) );
}
string list_plans() {
  string ret, str;
  string plan;
  ret = "To create a house use:\n"
    "  'make <floor plan> <orientation> <location> <outside> <region>\n"
    "        <address>' where:\n"
    "  'makereal <floor plan> <orientation> <location> <outside> <region>\n"
    "        <address>' where:\n"
    "  'makeforce <floor plan> <orientation> <location> <outside> <region>\n"
    "        <address>' where:\n"
    "  floor plan is one of the standard floor plans\n"
    "  orientation is its orientation (ie. the direction you enter it to)\n"
    "  location is the directory to write the houses files into\n"
    "  address is a the unique address for the house\n"
    "  region is the region of the house\n"
    "The 'makereal' command will add the house into the housing handler, "
    "the 'make' command will do a normal test make and the 'makeforce' "
    "will overwrite any existing housing files.\n\n"
    "Example:\n"
    "$I$5=   makereal twobedhouse south /d/am/fluff/housing OUT+room1 am \"12 Fluff Street\"\n\n$I$0="
    "The following floorplans are available:\n";
  str = "";
  foreach(plan in get_dir(PATH + "*")) {
    if(plan != "." && plan != ".." && file_size(PATH + plan) == -2 )
      str += plan + "\n";
  }
  ret += sprintf("%-#*s", this_player()->query_cols(), str);
  return ret;
}
int do_create(string type, string orientation, string location, string out,
              string region, string address, int overwrite,
              int test) {
  string room;
  string tmp;
  string fname;
  mapping files;
  mapping main_file;
  string number;
  int orient;
  int i;
  if(file_size(PATH+type) != -2) {
    return notify_fail("No such floor plan\n");
  }
  orient = member_array(orientation, ORIENTATION);
  if(orient == -1) {
    return notify_fail("No such orientation.\n");
  }
  if(file_size(location) != -2) {
    return notify_fail("No such location.\n");
  }
  if (address[0] < '0' || address[0] > '9') {
     add_failed_mess("Address must start with a number.\n");
     return 0;
  }
  i = 0;
  do {
     i++;
  } while (address[i] != ' ');
  number = address[0..i-1];
  address = address[i..];
  if (out[0] == '/') {
     if (out[<2..] == ".c") {
        out = out[0..<3];
     }
     out = "\"" + out + "\"";
  } else {
     if (member_array('+', out) == -1) {
        out = "PATH+\"" + out + "\"";
     }
  }
  files = ([ ]);
  main_file = ([ ]);
  if (type[<1] != 'M') {
     main_file[""] = 0;
  }
  foreach(room in get_dir(PATH+type+"

==================================================
FILE: misc/ink_well.c
==================================================

inherit "/obj/container";
void create() {
  ::create();
  set_name("well");
  add_adjective("ink");
  set_short("ink well");
  set_long("A nice, small ink well.\n");
  set_value( 500 );
  set_leak_rate(0);
  set_max_volume(250);
  set_volume(200);
  set_water_volume(200);
  set_ps_coord_quantity((int *)"/std/effects/other/ink"->query_coordinate(), 200);
}

==================================================
FILE: misc/juicer.c
==================================================

#include  <bit.h>
inherit "/obj/vessel";
int juice_bit( object ob, string fn );
mapping juice_funs = ([
  "/std/bit" : (: juice_bit :),
]);
void setup() {
  set_name( "juicer" );
  set_short( "juicer" );
  set_main_plural( "juicers" );
  set_long( "This is a device for extracting the juice or liquid from " +
            "objects.  It has a hole at the top for inserting things, " +
            "and a small bowl at the bottom to catch the juice.  You " +
            "could probably \"juice\" something and then \"pour\" " +
            "the juicer into another container.\n" );
  set_value( 4000 );
  set_weight( 100 );
  set_max_volume( 19200 );
}
void init() {
  ::init();
  this_player()->add_command( "juice", this_object(), "%I 'in' %D" );
}
int do_juice( object *things ) {
  int i, amount, *weight_unit, percent;
  string medium_short, *types, fn;
  mapping amount_types;
  if ( living( environment() ) ) {
    this_player()->add_failed_mess( this_object(), "You have to put down "+
        "$D to use it.\n", ({ }) );
    return 0;
  }
  for ( i = 0; i < sizeof( things ); i++ )
    if ( environment( things[ i ] ) != this_player() ) {
      things = delete( things, i, 1 );
      i--;
    }
  if ( !sizeof( things ) ) {
    this_player()->add_failed_mess( this_object(), "You should be carrying "+
        "whatever you want to $V in $D", ({ }) );
    return 0;
  }
  if ( sizeof( things ) > 1 ) {
    this_player()->add_failed_mess( this_object(), "You should only $V "+
        "one thing at a time in $D in case they get mixed up.\n", ({ }) );
    return 0;
  }
  if ( !function_exists( "query_continuous", things[ 0 ] ) ) {
    if ( fn = things[ 0 ]->query_property("juice")
        && functionp( juice_funs[ fn ] )) {
      return evaluate( juice_funs[ fn ], things[ 0 ], fn );
    }
    fn = explode(file_name(things[ 0 ]), "#")[ 0 ];
    if (functionp( juice_funs[ fn ] )) {
      return evaluate( juice_funs[ fn ], things[ 0 ], fn );
    }
    this_player()->add_failed_mess( this_object(), "You cannot $V $I "+
        "in $D.  Trust me on this.\n", ({ things[ 0 ] }) );
    return 0;
  }
  if ( !(percent = things[ 0 ]->query_property("%liquid")) ) {
    this_player()->add_failed_mess( this_object(), "$I apparently doesn't " +
        "contain much juice.\n", ({ things[ 0 ] }) );
    things[ 0 ]->move("/room/rubbish");
    return 0;
  }
  things[ 0 ]->add_plural( (string)things[ 0 ]->query_name() );
  if ((amount = (int)things[ 0 ]->query_amount()) == 0) {
    weight_unit = (int *)things[ 0 ]->query_weight_unit();
    amount = ( weight_unit[ 1 ] * (int)things[ 0 ]->query_weight() ) /
      weight_unit[ 0 ];
    amount = ( ( 50 + random( 21 ) ) * amount ) / 80;
  }
  things[ 0 ]->set_amount( amount*percent/100 );
  things[ 0 ]->set_weight_per_bite( 0 );
  things[ 0 ]->set_bites_gone( 0 );
  medium_short = (string)things[ 0 ]->query_medium_short();
  if ( !medium_short )
    medium_short = (string)things[ 0 ]->query_short();
  if ( !things[ 0 ]->query_medium_alias() )
    things[ 0 ]->set_medium_alias( "Ground"+ capitalize( medium_short ) );
  amount_types = ([ "drop" : ({ 1, "drops" }), "ounce" :
        ({ 120, "ounces" }), "pint" : ({ 2400, "pints" }) ]);
  things[ 0 ]->set_amount_types( amount_types );
  types = m_indices( amount_types );
  for ( i = 0; i < sizeof( types ); i++ )
    things[ 0 ]->add_adjective( ({ types[ i ],
        amount_types[ types[ i ] ][ 1 ] }) );
  things[ 0 ]->add_adjective( "of" );
  if ( !sizeof( (mixed *)things[ 0 ]->query_pile_types() ) )
    things[ 0 ]->set_pile_types( ({ 50, "small", 2400, "medium", 19200,
        "large", "huge" }) );
  things[ 0 ]->add_property( "determinate", "some " );
  things[ 0 ]->grind();
  things[ 0 ]->move( this_object() );
  this_player()->add_succeeded_mess( this_object(), "$N $V $D to make $I.\n",
      ({ things[ 0 ] }) );
  return 1;
}
int juice_bit( object ob, string fn ) {
    object juice_ob;
    mixed *bit_data;
    string *m, s;
    int i;
    juice_ob = clone_object("/obj/reagents/generic_liquid.ob");
    juice_ob->set_name("juice");
    if (s = ob->query_race_name())
      s = capitalize(s);
    bit_data = ob->query_bit_data();
    m = explode(bit_data[ BIT_NAME ], " ");
    for ( i = 0; i < sizeof(m); i++ )
      s += capitalize(m[i]?m[i]:"");
    juice_ob->set_medium_alias(s+"Juice");
    switch ( bit_data[ BIT_ALIAS ] ) {
      case "eye":
        juice_ob->add_adjective("eye");
        juice_ob->add_alias("ichor");
        juice_ob->set_short("clear liquid");
        juice_ob->set_long("This is a clear liquid, slightly tinged" +
                           "with blood.\n");
        juice_ob->set_amount(10*(int)ob->query_weight() + 10);
        break;
      default:
        juice_ob->set_short("liquid");
        juice_ob->set_long("This is a non-descript liquid.  It's probably " +
                           "useless.\n");
        break;
    }
    juice_ob->move(this_object());
    ob->move("/room/rubbish");
    this_player()->add_succeeded_mess( this_object(), "$N $V $D to make $I.\n",
                                      ({ juice_ob }) );
    return 1;
}

==================================================
FILE: misc/keyring.c
==================================================

inherit "/std/container";
void create() {
   do_setup++;
   container::create();
   set_name( "keyring" );
   set_short( "keyring" );
   add_property( "determinate", "a " );
   set_main_plural( "keyrings" );
   add_property("shop type", "jewellers");
   set_long( "This is a ring of metal that overlaps itself at one point, "
         "allowing keys to be strung onto it and be kept together.  It's "
         "amazing how useful a ring of metal can be.\n" );
   set_weight( 2 );
   set_value( 20 );
   set_max_weight( 1 );
   do_setup--;
   if (!do_setup)
      this_object()->setup();
}
string long( string word, int dark ) {
   return ::long( word, dark ) +
         query_contents( "$C$"+ the_short() +" holds: " );
}
mapping query_properties() {
   object thing;
   mixed arg, *args;
   mapping props, map;
   props = ::query_properties();
   args = copy( keys( props ) );
   foreach ( thing in find_inv_match( "", this_player() ) ) {
      map = (mapping)thing->query_properties();
      foreach ( arg in keys( map ) ) {
         if ( !stringp( arg ) ) {
            continue;
         }
         if ( member_array( arg, args ) != -1 ) {
            continue;
         }
         props[ arg ] = map[ arg ];
         args += ({ arg });
      }
   }
   return props;
}
mixed query_property( string word ) {
   object thing;
   mixed arg;
   arg = ::query_property( word );
   if ( arg ) {
      return arg;
   }
   foreach ( thing in find_inv_match( "", this_player() ) ) {
      arg = (mixed)thing->query_property( word );
      if ( arg ) {
         return arg;
      }
   }
   return 0;
}
int test_add( object thing, int flag ) {
   if ( !thing->id( "key" ) && environment( thing ) ) {
      return 0;
   }
   return 1;
}
int add_weight(int n) {
  int tmp, ret;
  if(sizeof(all_inventory(this_object())) >= 15)
    return 0;
  return ::add_weight(n);
}
mapping query_static_auto_load() {
   if ( explode( file_name(), "#" )[ 0 ] == "/obj/misc/keyring" ) {
      return int_query_static_auto_load();
   }
   return ([ ]);
}

==================================================
FILE: misc/label.c
==================================================

inherit "/std/object";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_name( "label" );
   set_short( "small label" );
   add_adjective( "small" );
   set_main_plural( "small labels" );
   set_long( "This is a small label made from paper with some sort of "+
         "dried glue smeared on one side.  You could probably \"stick\" "+
         "it onto something.\n" );
   set_value( 100 );
   add_property( "writeable", 1 );
   add_property( "label", 1 );
   set_max_size( 200 );
   if ( !do_setup )
      this_object()->setup();
}
void init() {
   this_player()->add_command( "stick", this_object(),
         "<direct:object:me> to <indirect:object>" );
}
int do_stick( mixed *things ) {
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can't stick $D to more than one thing at a time.\n");
      return 0;
   }
   if ( things[ 0 ] == this_object() ) {
      add_failed_mess("You cannott stick $D to itself!\n");
      return 0;
   }
   things[ 0 ]->add_effect( "/std/effects/object/label", this_object() );
   add_succeeded_mess("$N lick$s $D and stick$s it to $I.\n", things[0..0]);
   return 1;
}
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/misc/label" ) {
      return ([ ]);
   }
   return int_query_static_auto_load();
}

==================================================
FILE: misc/lantern.c
==================================================

inherit "/obj/lantern";
void setup() {
   fuel_left = 3600;
   is_lit    = 0;
   set_name( "lantern" );
   set_main_plural( "lanterns");
   set_short( "lantern" );
   add_help_file("torch");
   set_long(function() {
     string str;
     str = "This is a camping lantern, which smells of lamp oil.\n";
     if ( is_lit ) {
       return str + "The wick flickers inside spreading a dull "
         "glow.\n";
     }
     str += "The lantern is not lit, and ";
     if ( !fuel_left )
       return str + "is out of oil.\n";
     return str + "has some oil left in it.\n";
   } );
   set_weight( 60 );
   set_value( 150 );
}
