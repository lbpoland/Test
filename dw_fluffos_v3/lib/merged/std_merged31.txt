




==================================================
FILE: /lib/std/room/furniture/bank_master.c
==================================================

#include <money.h>
#include <move_failures.h>
nosave inherit "/std/room/furniture/commercial";
nosave inherit "/std/shops/inherit/bank_master";
#define OBJECT_TAG "bank master"
private nosave string _place;
void create() {
  add_help_file("bank_master");
  commercial::create();
  bank_master::create();
  set_commercial_name("bank");
}
void event_save(object ob) {
   environment()->event_save(ob);
}
mixed *stats() {
  return commercial::stats() +
         bank_master::stats();
}
object find_bank_object(string franchise) {
   object* obs;
   object room;
   room = load_object(franchise);
   if (room->query_bank()) {
      return room;
   }
   obs = filter(room->find_commercial_items(query_commercial_name()),
                (: $1->query_bank_name() == query_bank_name() :));
   if (sizeof(obs)) {
      return obs[0];
   }
   return 0;
}
int do_list_franchises() {
   string franchise;
   int pos;
   object bank_ob;
   string ret;
   string place;
   if (!sizeof(BANK_HANDLER->query_franchises(query_bank_name()))) {
      add_failed_mess("This bank has no franchises.\n");
      return 0;
   }
   place = query_money_place();
   ret = "Franchises:\n";
   foreach (franchise in BANK_HANDLER->query_franchises(query_bank_name())) {
      bank_ob = find_bank_object(franchise);
      ret += sprintf("$I$6=   %c %s Balance %s (cost per month %s)\n",
                      pos + 'A', franchise->the_short(),
                      MONEY_HAND->money_value_string(bank_ob->query_total_difference(), place),
                      MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_franchise_cost_per_month(query_bank_name(), franchise), place));
      pos++;
   }
   write("$P$Franchises$P$" + ret);
   return 1;
}
int do_set_franchise_cost(string cost) {
   int amount;
   string place;
   place = query_money_place();
   amount = MONEY_HAND->value_from_string(cost, place);
   if (amount <= 0) {
      add_failed_mess("Unknown amount " + cost + ".\n");
      return 0;
   }
   BANK_HANDLER->set_bank_default_cost_to_open(query_bank_name(), amount);
   add_succeeded_mess("$N set$s the cost to open a franchise to " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_default_cost_to_start(query_bank_name()), place) + "\n");
   return 1;
}
int do_set_default_monthly_cost(string cost) {
   int amount;
   string place;
   place = query_money_place();
   amount = MONEY_HAND->value_from_string(cost, place);
   if (amount <= 0) {
      add_failed_mess("Unknown amount " + cost + ".\n");
      return 0;
   }
   BANK_HANDLER->set_bank_default_cost_per_month(query_bank_name(), amount);
   add_succeeded_mess("$N set$s the cost to open a franchise to " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_default_cost_to_start(query_bank_name()), place) + "\n");
   return 1;
}
int do_set_main_bank_name(string new_name) {
   string* names;
   string name;
   if (query_bank_name()) {
      add_failed_mess("This bank already has a name.\n");
      return 0;
   }
   names = BANK_HANDLER->query_banks();
   foreach (name in names) {
      if (lower_case(name) == lower_case(new_name)) {
         add_failed_mess("There is already a bank called " +
                         name + ".\n");
         return 0;
      }
   }
   write("Do you really want to set the bank name to " + new_name +
         " (Make sure you have correct capitalisation)? ");
   input_to("check_bank_name", 0, new_name);
   add_succeeded_mess("");
   return 1;
}
void check_bank_name(string response, string new_name) {
   if (!strlen(response) || lower_case(response)[0] != 'y') {
      write("Ok, aborting.\n");
      return ;
   }
   write("You set the bank name to " + new_name + ".\n");
   BANK_HANDLER->create_new_bank(new_name, file_name(environment()));
   ::set_bank_name(new_name);
}
int do_set_cut(int percent) {
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   if (percent < 0) {
      add_failed_mess("You cannot set the cut less than 0.\n");
      return 0;
   }
   if (percent > 100) {
      add_failed_mess("You cannot set the cut to greator than 100%.\n");
      return 0;
   }
   set_percentage(percent);
   add_succeeded_mess("$N set$s the cut to " + percent + "% on $D.\n");
   return 1;
}
int do_set_open_cost(string str) {
   string place;
   int value;
   if (!is_allowed(this_player()->query_name())) {
      add_failed_mess("You are not allowed to change the paramaters of "
                   "$D.\n");
      return 0;
   }
   place = query_money_place();
   value = MONEY_HAND->value_from_string(str, place);
   if (!value) {
      add_failed_mess("Unable to parse the string " + str + ".\n");
      return 0;
   }
   set_account_cost(value);
   add_succeeded_mess("$N set$s the account open cost to " +
          MONEY_HAND->money_value_string(value, place) + " on $D.\n");
   return 1;
}
int do_set_franchise_cost_per_month(string id, string amount) {
   string *franchises;
   int id_num;
   int amt;
   id = lower_case(id);
   if (strlen(id) != 1) {
      add_failed_mess("Must be one letter.\n");
      return 0;
   }
   franchises = BANK_HANDLER->query_franchises(query_bank_name());
   id_num = id[0] - 'a';
   if (id_num < 0 || id_num >= sizeof(franchises)) {
      add_failed_mess("The id of the franchises must be between 'A' and '" +
                      sprintf("%c", 'A' + sizeof(franchises) - 1) + ".\n");
      return 0;
   }
   amt = MONEY_HAND->value_from_string(amount, query_money_place());
   if (amt <= 0) {
      add_failed_mess("The amount " + amount + " is invalid.\n");
      return 0;
   }
   BANK_HANDLER->set_bank_franchise_cost_per_month(query_bank_name(),
               franchises[id_num], amt);
   add_succeeded_mess(({ "You set the cost per month for the franchise " +
                         franchises[id_num]->query_address() + " to " +
                         MONEY_HAND->money_value_string(amt, query_money_place()) + ".\n",
                         "" }));
   return 1;
}
string query_main_status(int hints) {
   string ret;
   string place;
   place = query_money_place();
   ret = "$I$0=" + the_short() + ":\n";
   ret += "$I$6=   Bank Name             : " +
          query_bank_name() + "\n";
   ret += "$I$6=   Revenue               : " +
          MONEY_HAND->money_value_string(query_revenue(), place) + "\n";
   ret += "$I$6=   Cost to buy franchise : " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_default_cost_to_open(query_bank_name()), place) + "\n";
   if (hints) {
      ret += "$I$9=      Hint: set buy franchise cost <amount> on <object>\n";
   }
   ret += "$I$6=   Franchise cost per month : " +
          MONEY_HAND->money_value_string(BANK_HANDLER->query_bank_default_cost_per_month(query_bank_name()), place) + "\n";
   if (hints) {
      ret += "$I$9=      Hint: set default franchise monthly cost <amount> on <object>\n";
   }
   ret += "$I$6=   Percentage            : " +
             query_percentage() + "%\n";
   if (hints) {
      ret += "$I$9=      Hint: set percentage <number> on <counter>\n";
   }
   ret += "$I$6=   Cost to open account  : " +
          MONEY_HAND->money_value_string(query_account_cost(), place) + "\n";
   if (hints) {
      ret += "$I$9=      Hint: set account cost <amount> on <object>\n";
   }
   ret += "$I$6=   Number of Franchises  : " +
          sizeof(BANK_HANDLER->query_franchises(query_bank_name())) + "\n";
   return ret;
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, OBJECT_TAG, "bank", query_bank_name());
   add_auto_load_value(map, OBJECT_TAG, "open", query_account_cost());
   add_auto_load_value(map, OBJECT_TAG, "percentage", query_percentage());
   add_auto_load_value(map, OBJECT_TAG, "difference", query_total_difference());
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   commercial::init_dynamic_arg(map, player);
   set_bank_name(query_auto_load_value(map, OBJECT_TAG, "bank"));
   set_account_cost(query_auto_load_value(map, OBJECT_TAG, "open"));
   set_percentage(query_auto_load_value(map, OBJECT_TAG, "percentage"));
   set_total_difference(query_auto_load_value(map, OBJECT_TAG, "difference"));
}
void init() {
   commercial::init();
   bank_master::init();
   if (is_allowed(this_player()->query_name())) {
      add_command("set", "bank name <string'name'> on <direct:object>",
                  (: do_set_main_bank_name($4[0]) :));
      add_command("set", "buy franchise cost <string'cost'> on <direct:object>",
                  (: do_set_franchise_cost($4[0]) :));
      add_command("set", "franchise monthly cost <string'cost'> on <direct:object>",
                  (: do_set_default_monthly_cost($4[0]) :));
      add_command("set", "percentage <number> on <direct:object>",
                  (: do_set_cut($4[0]) :));
      add_command("set", "account cost <string'open cost'> on <direct:object>",
                  (: do_set_open_cost($4[0]) :));
      add_command("set", "franchise monthly cost <string'cost'> for <string'franchise id'> on <direct:object>",
                  (: do_set_franchise_cost_per_month($4[1], $4[0]) :));
      add_command("list", "franchises on <direct:object>",
                  (: do_list_franchises :));
   }
}

==================================================
FILE: /lib/std/room/furniture/basic.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <room/placement.h>
inherit "/std/object";
inherit "/std/basic/item_chat";
inherit "/std/room/furniture/inherit/furniture_base";
void create() {
  do_setup++;
  object::create();
  furniture_base::create();
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
  }
  set_no_all(1);
}
varargs int move( mixed dest, string messin, string messout ) {
  int i, t, f;
  object from;
  if(stringp(dest)) {
    dest = find_object(dest);
  }
  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if(living(dest)) {
    t = (int)this_object()->query_complete_weight() * 2;
    if(!(dest->add_weight(t))) {
      return MOVE_TOO_HEAVY;
    }
  }
  i = ::move(dest, messin, messout);
  if(i != MOVE_OK) {
    dest->add_weight(-t);
    return i;
  }
  from = environment();
  if(from && living(from)) {
    f = (int)this_object()->query_complete_weight() * 2;
    from->add_weight(-f);
  }
  return i;
}
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}
mixed query_dynamic_auto_load() {
   mapping junk;
   junk = object::query_dynamic_auto_load();
   if (!junk) {
      junk = ([ ]);
   }
   junk["bonded"] = query_bonded();
   return junk;
}
void init_dynamic_arg(mapping map) {
   object::init_dynamic_arg(map);
   set_bonded(map["bonded"]);
}
string query_help_file_directory() {
   return "/doc/furniture/";
}
mixed *stats() {
   return ::stats() +
          ({ ({ "bonded", query_bonded() }) });
}

==================================================
FILE: /lib/std/room/furniture/bath.c
==================================================

#include <effect.h>
inherit "/std/room/furniture/surface";
#define WET_EFFECT "/std/effects/other/wetness"
#define SOAP_EFFECT "/std/effects/healing/antiseptic_soap"
int water = 0;
int dirt = 0;
string* dirt_messages = ({
    "clear",
    "almost clear",
    "soapy",
    "foamy",
    "slightly dirty",
    "fairly dirty",
    "dirty",
    "very dirty",
    "muddy"
});
void zap_bad_effects( object who );
int do_wash(object *indirect_obs );
void create(){
    ::create();
    add_property( "no recycling", 1 );
    this_object()->add_extra_look( this_object() );
    add_help_file("bath");
}
string extra_look() {
    object *stuff;
    string answer = "";
    stuff = all_inventory( this_object() );
    if (water) {
        if (dirt >= sizeof(dirt_messages)) {
            dirt = sizeof(dirt_messages) - 1;
        }
        answer = answer + "It's about three quarters full of " +
            dirt_messages[dirt] + " water.\n";
    }
    if( sizeof( stuff ) ) {
        answer = answer + "It has "+ query_multiple_short( stuff ) +" in it.\n";
    }
   return answer;
}
string long_status() {
    return "";
}
void init(){
    ::init();
    add_command( "lie", "in <direct:object>");
    add_command( "sit", "in <direct:object>");
    add_command( "kneel", "in <direct:object>");
    add_command( "stand", "in <direct:object>");
    add_command( "leave", "<direct:object>");
    add_command( "fill", "<direct:object>");
    add_command( "empty", "<direct:object>");
    add_command( "splash", "<indirect:living:here>");
    add_command( "wash", "<indirect:living:here>");
}
int can_player_get_in_it() {
    if (environment(this_object())!=environment(this_player())) {
      this_player()->add_failed_mess(this_object(), "The " + this_object()->short() + " needs to "
      "be on the floor for you to get in it.\n");
      return 0;
    }
    if( environment( this_object() ) == this_player() ){
        this_object()->move(environment(this_player() ));
        tell_object(this_player(), "You drop the "+
            this_object()->short()+".\n");
        tell_room(environment(this_player()), this_player()->short()+" drops "
        "a "+this_object()->short()+".\n", this_player() );
    }
    return 1;
}
void wet_everyone_in() {
    object *victims;
    if (!water) {
        return;
    }
    victims = filter(all_inventory(environment(this_object())),
        (: living($1) :) );
    foreach( object victim in victims ) {
        if (victim -> query_position_type() == "in" &&
            victim -> query_position_on() == "the "+this_object()->short()) {
            victim->add_effect( WET_EFFECT, 500 );
        }
    }
}
void reset() {
    wet_everyone_in();
}
int do_fill() {
    object player;
    player=this_player();
    if (water) {
        player->add_failed_mess(this_object(), "The " + this_object()->short() + " is "
            "already full of water.\n");
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    tell_object(player, "You fill the " + this_object()->short() + " with clean water.\n" );
    tell_room(environment(player), player->short()+" fills "
        "the " + this_object()->short() + " with clean water.\n", player );
    water=1;
    dirt=0;
    wet_everyone_in();
    return 1;
}
int do_empty() {
    object player;
    player=this_player();
    if (!water) {
        player->add_failed_mess(this_object(), "The " + this_object()->short() + " is "
            "already as empty as it gets.\n");
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    tell_object(player, "You reach into the " + this_object()->short() + " and "
                "pull the plug, allowing the water to drain away.\n" );
    tell_room(environment(player), player->short()+" reaches into "
        "the " + this_object()->short() + " and pulls the plug, allowing "
        "the water to flow away.\n", player );
    water=0;
    dirt=0;
    return 1;
}
int do_lie() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    player=this_player();
    add_succeeded_mess( "", ({ }) );
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "lying") {
            tell_object(player, "You are already lying in the pool.\n" );
            return 1;
        }
        tell_object(player, "You lie in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" lies "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + " and lie down.\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + " and lies down.\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "lying" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
int do_sit() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    player=this_player();
    add_succeeded_mess( "", ({ }) );
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "sitting") {
            tell_object(player, "You are already sitting in the " + this_object()->short() + ".\n" );
            return 1;
        }
        tell_object(player, "You sit in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" sits "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + " and sit down.\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + " and sits down.\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "sitting" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
int do_kneel() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    player=this_player();
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "kneeling") {
            tell_object(player, "You are already kneeling in the " + this_object()->short() + ".\n" );
            return 1;
        }
        tell_object(player, "You kneel in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" kneels "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + " and kneel down.\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + " and kneel down.\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "kneeling" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
int do_stand() {
    object player;
    if (!can_player_get_in_it()) {
        return 0;
    }
    add_succeeded_mess( "", ({ }) );
    player = this_player();
    if (player->query_position_on() == "the "+this_object()->short()) {
        if (player->query_position() == "standing") {
            tell_object(player, "You are already standing in the " + this_object()->short() + ".\n" );
            return 1;
        }
        tell_object(player, "You stand in the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" stands "
            "in the " + this_object()->short() + ".\n", player );
    }
    else {
        tell_object(player, "You step into the " + this_object()->short() + ".\n" );
        tell_room(environment(player), player->short()+" steps "
            "into the " + this_object()->short() + ".\n", player );
        if (water) {
            player->add_effect( WET_EFFECT, 500 );
        }
    }
    player->set_position( "lying" );
    player->set_position_type( "in" );
    player->set_position_on( "the "+this_object()->short() );
    return 1;
}
void event_exit(object ob, string message, object to) {
  if (ob==this_player() && this_player()->query_position_on() == this_object()) {
    this_player()->return_to_default_position(1);
  }
}
int do_leave(){
    if (this_player()->query_position_on() == "the "+this_object()->short()) {
        this_player()->return_to_default_position(1);
        tell_object(this_player(), "You clamber out of the " + this_object()->short() + ".\n" );
        tell_room(environment(this_object()), this_player()->short()+" clambers "
            "out of the " + this_object()->short() + ".\n", this_player() );
    }
    else {
        tell_object(this_player(), "Umm... You're not in the " + this_object()->short() + " in the "
            "first place.\n" );
    }
    add_succeeded_mess( "", ({ }) );
    return 1;
}
int do_splash( object *indirect_obs ) {
    if (environment(this_object())!=environment(this_player())) {
      this_player()->add_failed_mess(this_object(), "The " + this_object()->short() + " needs to "
      "be on the floor for you to splash with it.\n");
      return 0;
    }
    if (!water) {
        this_player()->add_failed_mess(this_object(), "It's not a bad idea,  "
            " but maybe you'd need some water in the " + this_object()->short() +
            " before you can splash.\n");
        return 0;
    }
    if ( sizeof( indirect_obs ) ) {
        add_succeeded_mess( "$N splash$es $I.\n", indirect_obs );
        return 1;
    }
    this_player()->add_succeeded_mess( this_object(),
        "$N splash$es $oself.\n", ({ }) );
    return 1;
}
int do_wash( object *indirect_obs ) {
    if (!can_player_get_in_it()) {
        return 0;
    }
    if (this_player() -> query_position_type() != "in" &&
        this_player()->query_position_on() != "the "+this_object()->short()) {
      this_player()->add_failed_mess(this_object(), "You need to get "
                                     "into the " + this_object()->short() +
                                     " first.\n");
      return 0;
    }
    if (!water) {
        this_player()->add_failed_mess(this_object(), "It's not a bad idea,  "
            " but maybe you'd need some water in the " + this_object()->short() +
            " before you can wash.\n");
        return 0;
    }
    if (dirt >= sizeof(dirt_messages) - 1) {
        this_player()->add_failed_mess(this_object(), "The water in the " +
            this_object()->short() +
            " looks so muddy, it probably would just soil anyone.  Maybe " +
            " it would be a better idea to empty it and fill it again " +
            " with fresh water.\n");
        return 0;
    }
    if ( sizeof( indirect_obs ) ) {
        foreach( object victim in indirect_obs ) {
            call_out( (: zap_bad_effects( $1 ) :), 0, victim );
        }
        add_succeeded_mess( "$N wash$es $I using a bar of pleasant smelling soap.\n", indirect_obs );
        return 1;
    }
    call_out( (: zap_bad_effects( $1 ) :), 0, this_player() );
    this_player()->add_succeeded_mess( this_object(),
        "$N wash$es $oself using a bar of pleasant smelling soap.\n", ({ }) );
    return 1;
}
int query_baths() {
    return 1;
}
void zap_bad_effects( object who ) {
    int i, flag, *enums;
    class effect *effs;
    dirt++;
    effs = (class effect *)who->query_effs();
    enums = (int *)who->effects_matching( "body.smell" );
    i = sizeof( enums );
    if ( !random(dirt) && i ) {
        i = random( i );
        flag = 1;
        write( "The antiseptic power of the soap defeats "+
          (string)effs[ enums[ i ] ]->ob_name->smell_string( who,
            effs[ enums[ i ] ]->arg ) +".\n" );
        who->delete_effect( enums[ i ] );
        dirt ++;
    }
    enums = who->effects_matching("pie.cream");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The cream washes right off your body.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = (int *)who->effects_matching( "misc.ketchup" );
    i = sizeof( enums );
    if ( !random(dirt) && i ) {
        i = random( i );
        flag = 1;
        write( "The soap rinses the ketchup off your face.\n" );
        who->delete_effect( enums[ i ] );
        dirt ++;
    }
    enums = who->effects_matching("exploded.apples");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The apples wash right off your body.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = (int *)who->effects_matching("object.label");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The labels stuck on you peel off in "
          "the water.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = who->effects_matching("body.frog-adhesive");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The frog adhesive washes off in the water.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    enums = who->effects_matching("body.writing.soap");
    if (!random(dirt) && sizeof(enums)) {
        tell_object(who, "The rest of the words wash off without a single "
            "bubble in sight.\n");
        who->delete_effect(enums[0]);
        dirt ++;
    }
    if (!random(dirt)) {
        who->add_effect( SOAP_EFFECT, 10000 );
    }
    who->add_effect( WET_EFFECT, 250 );
}

==================================================
FILE: /lib/std/room/furniture/chime_inherit.c
==================================================

inherit "/std/object";
inherit "/std/room/furniture/inherit/furniture_base";
#include <weather.h>
#define TIME 120
string chimes_short();
string chimes_long();
void set_chime_type( string type );
string chime_type();
void jingle();
string chime_verb();
void add_chime_verb( string verb );
void remove_chime_verb( string verb );
string *query_chime_verbs();
void set_hung_up( int up );
int hung_up();
void set_hook( object hook );
object hook();
int do_hang( object hook );
int do_unhang();
private string _chime_type = "metal";
private string *_chime_verbs = ({ "jingles", "tinkles" });
private int _hung_up = 0;
private object _hook;
void create() {
   furniture_base::create();
   object::create();
}
void setup() {
  set_name( "chime" );
  set_short( (: chimes_short() :) );
  set_long( (: chimes_long() :) );
  add_adjective( ({ "wind", chime_type() }) );
  set_value( 420 );
}
void init() {
  add_command( "hang", "<direct:object'chime'> {on|from} "
      "<indirect:object'hook'>", (: do_hang( $1[0] ) :) );
  add_command( "unhang", "<direct:object'chime'>" );
}
string chimes_short() {
  return chime_type() + " wind chime";
}
string chimes_long() {
  return "This little wind chime is nothing more than bits of "
             + chime_type() + " dangling from strings tied to a "
             "ring.\n";
}
void set_chime_type( string type ) {
  remove_adjective( _chime_type );
  add_adjective( type );
  _chime_type = type;
}
string chime_type() { return _chime_type; }
void jingle() {
  object env = environment();
  int wind;
  if( !env )
    return;
  if( !hung_up() )
    return;
  if( !inherits( "/std/room", env ) )
    return;
  wind = env->query_wind_speed();
  if( undefinedp( wind ) ) {
    if( env->query_property( "location" ) == "outside" ||
        env->query_property( "windy" ) )
      wind = WEATHER->query_windsp( this_object() );
    else
      return;
  }
  if( random( wind ) )
    tell_room( env, the_short() + chime_verb() + " in the "
        "wind.\n" );
  call_out( "jingle", TIME );
}
string chime_verb() {
  return " " + _chime_verbs[ random( sizeof( _chime_verbs ) ) ];
}
void add_chime_verb( string verb ) {
  _chime_verbs += ({ verb });
}
void remove_chime_verb( string verb ) {
  _chime_verbs -= ({ verb });
}
void set_chime_verbs( string *verbs ) { _chime_verbs = verbs; }
string *query_chime_verbs() { return _chime_verbs; }
void set_hung_up( int up ) {
  remove_call_out( "jingle" );
  if( up )
    call_out( "jingle", 30 );
  _hung_up = up;
}
int hung_up() { return _hung_up; }
void set_hook( object hook ) { _hook = hook; }
object hook() { return _hook; }
int jingling() { return find_call_out( "jingle" ); }
void init_dynamic_arg( mapping arg ) {
  set_chime_type( arg[ "type" ] );
  set_chime_verbs( arg[ "chime verbs" ] );
  set_hook( arg[ "hook" ] );
  set_hung_up( arg[ "hung up" ] );
  if( undefinedp( hook() ) || !hung_up() ||
      !sizeof( match_objects_for_existence( hook(), ({ environment() }) ) ) ) {
    remove_property( "there" );
    set_hung_up( 0 );
  }
}
mixed query_dynamic_auto_load() {
  return ([ "::" : ::query_dynamic_auto_load(),
            "type" : chime_type(),
            "chime verbs" : query_chime_verbs(),
            "hung up" : hung_up(),
            "hook" : hook() ]);
}
int do_hang( object hook ) {
  string where = hook->a_short();
  if( hung_up() ) {
    add_failed_mess( "The chime is already hanging up.\n" );
    return 0;
  }
  if( !hook->query_hook() && !hook->query_property( "hook" ) )
    return 0;
  if( move( environment( this_player() ) ) )
    return 0;
  if( where )
    where = "on " + where;
  else
    where = "up";
  add_property( "there", "hanging "+ where );
  reset_get();
  set_hung_up( 1 );
  set_hook( hook );
  this_player()->add_succeeded_mess( this_object(), "$N $V $D on "
      "$I.\n", ({ hook }) );
  return 1;
}
int do_unhang() {
  if( !hung_up() ) {
    add_failed_mess( "The chime isn't hanging from anything.\n" );
    return 0;
  }
  remove_property( "there" );
  set_get();
  set_hung_up( 0 );
  move( this_player() );
  return 1;
}

==================================================
FILE: /lib/std/room/furniture/clock.c
==================================================

#include <move_failures.h>
#include <position.h>
inherit "/obj/clock";
inherit "/std/room/furniture/inherit/furniture_base";
void chime(string mess) {
  int *co_ords;
  if(environment(this_object())) {
    co_ords = (int *)environment(this_object())->query_co_ord();
    "/obj/handlers/broadcaster"->broadcast_event(users(), co_ords,
                                                 mess, 20, 1, 0 );
    tell_room(environment(this_object()), mess);
  }
}
void create() {
   do_setup++;
   clock::create();
   add_alias( "furniture" );
   add_plural( "furniture" );
   set_opaque();
   furniture_base::create();
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
   }
}
private int do_real_move(mixed dest, string messin, string messout) {
   return clock::move(dest, messin, messout);
}
varargs int move( mixed dest, string messin, string messout ) {
  int i, t, f;
  object from;
  if(stringp(dest)) {
    dest = find_object(dest);
  }
  if (!move_check(dest)) {
     write(the_short() + " resists being picked up and shocks you slightly.\n");
     return MOVE_INVALID_DEST;
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if(living(dest)) {
    t = (int)this_object()->query_complete_weight() * 2;
    if(!(dest->add_weight(t))) {
      return MOVE_TOO_HEAVY;
    }
    debug_printf("Added %d", t);
  }
  i = ::move(dest, messin, messout);
  if(i != MOVE_OK) {
    dest->add_weight(-t);
    return i;
  }
  from = environment();
  if(from && living(from)) {
    f = (int)this_object()->query_complete_weight() * 2;
    from->add_weight(-f);
  }
  return i;
}
int get(mixed dest) {
  if(!move_check(dest)) {
    write("You feel it would be wrong to take " + the_short() + ".\n");
    return 2;
  }
  return ::get(dest);
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}

==================================================
FILE: /lib/std/room/furniture/commercial.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <money.h>
inherit "/std/object";
inherit "/std/basic/item_chat";
inherit "/std/room/furniture/inherit/furniture_base";
string query_main_status(int hints);
private nosave int _commercial_size;
private nosave string _commercial_type;
private nosave string _commercial_name;
private nosave string* _use_types;
private nosave string _info;
private int _revenue;
private int _weekly_revenue;
private int _commercial_id;
private int _weekly_upkeep_cost;
#define OBJECT_TAG "commercial inh"
void create() {
   _commercial_size = 100;
   if (!_use_types) {
      _use_types = ({ });
   }
   do_setup++;
   object::create();
   furniture_base::create();
   add_alias( "furniture" );
   add_plural( "furniture" );
   add_property("talisman", "no one");
   set_opaque();
   if ( !query_property( "shop type" ) ) {
      add_property( "shop type", "furniture" );
   }
   do_setup--;
   if ( !do_setup ) {
     this_object()->setup();
   }
   set_no_all(1);
   reset_get();
}
void set_weekly_upkeep_cost(int cost) {
   _weekly_upkeep_cost = cost;
}
int query_weekly_upkeep_cost() {
   return _weekly_upkeep_cost;
}
int query_revenue() {
   return _revenue;
}
void set_revenue(int revenue) {
   _revenue = revenue;
}
string query_save_dir() {
   return environment()->query_save_dir();
}
string query_owner() {
  return environment()->query_owner();
}
string query_language() {
  return environment()->query_language();
}
string query_money_place() {
   if (!environment()) {
      return "default";
   }
   return environment()->query_property("place");
}
int is_allowed(string person) {
   return environment()->is_allowed(person);
}
string query_allowed() {
   return environment()->query_allowed();
}
int query_float() {
   return environment()->query_royalty(query_owner());
}
int query_royalty(string person) {
   return environment()->query_royalty(person);
}
int adjust_royalty(string person, int amount) {
   if (person == query_owner()) {
      _revenue += amount;
      _weekly_revenue += amount;
   }
   environment()->adjust_royalty(person, amount);
}
int adjust_float(int amt) {
   adjust_royalty(query_owner(), amt);
}
int is_open_for(string type, string person) {
   if (!environment()->query_commercial_property()) {
      return 0;
   }
   return environment()->is_open_for(type, person);
}
void set_commercial_size(int size) {
   _commercial_size = size;
}
string query_commercial_type() {
   return _commercial_type;
}
void set_commercial_type(string type) {
   _commercial_type = type;
}
void set_commercial_information(string info) {
   _info = info;
}
string query_commercial_information() {
   return _info;
}
void set_commercial_name(string name) {
   _commercial_name = name;
}
string query_commercial_name() {
   return _commercial_name;
}
int query_commercial_size() {
   return _commercial_size;
}
int query_commercial_id() {
   return _commercial_id;
}
void setup_new_commercial_id() {
   _commercial_id = environment()->find_next_commercial_id();
}
void set_commercial_id(int id) {
   _commercial_id = id;
}
string query_parcel_post() {
   return environment()->query_parcel_post();
}
void set_shop_use_types(string* types) {
   _use_types = types;
}
string* query_shop_use_types() {
   return _use_types;
}
void reset_weekly_status() {
   _weekly_revenue = 0;
}
string query_weekly_status_string() {
   string ret;
   string place;
   place = query_money_place();
   if (query_weekly_upkeep_cost()) {
      ret = "Weekly Upkeep : " +
            MONEY_HAND->money_value_string(_weekly_upkeep_cost, place) + "\n" +
            "Weekly Revenue: " +
            MONEY_HAND->money_value_string(_weekly_revenue, place) + "\n" +
            "Profit        : " +
            MONEY_HAND->money_value_string(_weekly_revenue - _weekly_upkeep_cost, place) + "\n";
   } else {
      ret = "Weekly Revenue: " +
            MONEY_HAND->money_value_string(_weekly_revenue, place) + "\n";
   }
   return ret;
}
int can_trash_furniture() {
   return 1;
}
int query_commercial_furniture() {
   return 1;
}
varargs int move( mixed dest, string messin, string messout ) {
   int i;
   int t;
   int f;
   object from;
   if(stringp(dest)) {
      dest = find_object(dest);
   }
   if (!move_check(dest)) {
      write(the_short() + " resists being picked up and shocks you slightly.\n");
      return MOVE_INVALID_DEST;
   }
   if(!dest) {
      return MOVE_INVALID_DEST;
   }
   if(living(dest)) {
      t = (int)this_object()->query_complete_weight() * 5;
      if(!(dest->add_weight(t))) {
         return MOVE_TOO_HEAVY;
      }
      debug_printf("Added %d", t);
   }
   from = environment();
   i = ::move(dest, messin, messout);
   if(i != MOVE_OK) {
      dest->add_weight(-t);
      return i;
   }
   if(from && living(from)) {
      f = (int)this_object()->query_complete_weight() * 5;
      from->add_weight(-f);
   }
   if (from) {
      from->remove_commercial_thing(this_object());
   }
   dest->add_commercial_thing(this_object());
   dest->register_use_types(_use_types);
   return i;
}
int get(mixed dest) {
   if(!move_check(dest)) {
      write("You feel it would be wrong to take " + the_short() + ".\n");
      return 2;
   }
   return ::get(dest);
}
int do_status(int hint) {
   string ret;
   ret = query_main_status(hint);
   write("$P$Status$P$" + ret);
   add_succeeded_mess("$N get$s the status of $D.\n");
   return 1;
}
int do_reset() {
   string place;
   int old_revenue;
   place = query_money_place();
   old_revenue = _revenue;
   _revenue = 0;
   add_succeeded_mess("$N clear$s the revenue of " +
                      MONEY_HAND->money_value_string(old_revenue, place) +
                      " on $D.\n");
   return 1;
}
void init() {
   ::init();
   if (is_allowed(this_player()->query_name())) {
      add_command("status", "<direct:object>", (: do_status, 0 :));
      add_command("status", "hints <direct:object>", (: do_status, 1 :));
      add_command("status", "hint <direct:object>", (: do_status, 1 :));
      add_command("reset", "revenue on <direct:object>", (: do_reset :));
   }
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ ) {
    return int_query_static_auto_load();
  }
  return ([ ]);
}
mixed query_dynamic_auto_load() {
   mapping junk;
   junk = object::query_dynamic_auto_load();
   if (!junk) {
      junk = ([ ]);
   }
   junk["bonded"] = query_bonded();
   add_auto_load_value(junk, OBJECT_TAG, "revenue", query_revenue());
   add_auto_load_value(junk, OBJECT_TAG, "commercial id", query_commercial_id());
   return junk;
}
void init_dynamic_arg(mapping map) {
   object::init_dynamic_arg(map);
   if (map) {
      set_bonded(map["bonded"]);
      set_revenue(query_auto_load_value(map, OBJECT_TAG, "revenue"));
      if (query_auto_load_value(map, OBJECT_TAG, "commercial id")) {
         set_commercial_id(query_auto_load_value(map, OBJECT_TAG, "commercial id"));
      }
   }
}
string query_help_file_directory() {
   return "/doc/furniture/";
}
mixed *stats() {
   return ::stats() +
          ({ ({ "revenue", query_revenue() }),
             ({ "bonded", query_bonded() }),
             ({ "commercial id", query_commercial_id() }) });
}

==================================================
FILE: /lib/std/room/furniture/curtains.c
==================================================

#include <move_failures.h>
#include <position.h>
inherit "/std/room/furniture/basic";
private nosave object _window;
private string _window_id;
private string _window_old_long;
void create() {
  do_setup++;
  ::create();
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  if ( !query_property( "shop type" ) ) {
    add_property( "shop type", "furniture" );
  }
  set_allowed_room_verbs((["hanging" : "hangs" ]));
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
  }
}
void init() {
  if(!_window_id) {
    this_player()->add_command("hang", this_object(),
        "<direct:object> [on|at] <indirect:object:here>");
  }
  this_player()->add_command("open", this_object(), "<direct:object>");
  this_player()->add_command("close", this_object(), "<direct:object>");
}
int do_open() {
  if(!_window)
    _window = environment(this_object())->query_door_control(_window_id);
  if(!_window_id || !_window) {
    this_player()->add_failed_mess(this_object(),
        "$D aren't hanging at a window.\n");
    return 0;
  }
  if(_window->query_transparent()) {
    this_player()->add_failed_mess(this_object(),
        "$D are already open.\n");
    return 0;
  }
  _window->set_transparent();
  this_player()->add_succeeded_mess(this_object(), "$N $V $D.\n", ({}));
  return 1;
}
int do_close() {
  if(!_window)
    _window = environment(this_object())->query_door_control(_window_id);
  if(!_window_id || !_window) {
    this_player()->add_failed_mess(this_object(),
        "$D aren't hanging at a window.\n");
    return 0;
  }
  if(!_window->query_transparent()) {
    this_player()->add_failed_mess(this_object(),
        "$D are already closed.\n");
    return 0;
  }
  _window->reset_transparent();
  this_player()->add_succeeded_mess(this_object(), "$N $V $D.\n", ({}));
  return 1;
}
int do_hang(mixed *in_dir, string direct, string indirect, mixed *args) {
  if(member_array("window", in_dir[0]->parse_command_id_list()) == -1) {
    this_player()->add_failed_mess(this_object(),
        "You can only $V $D at windows.\n",
        ({ }));
    return 0;
  }
  if(this_object()->move(environment(this_player())) != MOVE_OK) {
    this_player()->add_failed_mess(this_object(),
        "You seem to be unable to $V $D "
        "at $I.\n", ({ in_dir[0] }));
    return 0;
  }
  this_object()->add_property("current room hidden", 1);
  _window_id = in_dir[0]->query_my_id();
  _window_old_long = in_dir[0]->query_long();
  in_dir[0]->set_long(in_dir[0]->query_long()+"It has " +
                      this_object()->query_short() +
                      " hanging round it.\n");
  event(environment(), "save", this_object());
  this_player()->add_succeeded_mess(this_object(),
                                   "$N $V $D at $I.\n", ({ in_dir[0] }));
  return 1;
}
void removed() {
  this_object()->remove_property("current room hidden");
  if(!_window)
    _window = environment(this_object())->query_door_control(_window_id);
  _window->set_long(_window_old_long);
  _window->set_transparent();
  _window_id = 0;
}
int query_furniture() { return 1; }
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load() +
      ([ "window" : _window_id,
       "window_old_long" : _window_old_long ]);
  return ([ "window" : _window_id,
          "window_old_long" : _window_old_long ]);
}
void init_static_arg( mapping map ) {
  if ( !mapp( map ) ) {
    return;
  }
  ::init_static_arg(map);
  if ( !undefinedp( map[ "window" ] ) )
    _window_id = map["window"];
  if(!undefinedp(map["window_old_long"]))
    _window_old_long = map["window_old_long"];
}

==================================================
FILE: /lib/std/room/furniture/dividor.c
==================================================

inherit "/std/room/furniture/commercial";
#include <room.h>
#define SIZE_OF_FURNITURE 5
#define TAG "dividor"
#define TEMPLATE_DIVIDOR_ROOM "/mudlib/data/dividor_template.c"
private int _size;
private string _exit_direction;
private string _our_room;
int query_furniture_size() {
   return _size + SIZE_OF_FURNITURE;
}
int query_commercial_id() {
   if (!::query_commercial_id()) {
      setup_new_commercial_id();
   }
   return ::query_commercial_id();
}
string query_exit_direction() {
   return _exit_direction;
}
string query_exit_destination() {
   return _our_room;
}
int create_room() {
   string path;
   string *bits;
   string room_path;
   string stuff;
   path = environment()->query_save_dir();
   path += "/division" + query_commercial_id();
   if (file_size(path) == -2) {
      mkdir(path);
   }
   bits = explode(base_name(environment()), "/");
   room_path = implode(bits[0..<2], "/");
   room_path += "/" + bits[<1] + "_dividor";
   if (file_size(room_path) == -2) {
      mkdir(room_path);
   }
   room_path += "/" + query_commercial_id();
   if (file_size(room_path + ".c") > 0) {
      return 0;
   }
   _our_room = room_path;
   stuff = "inherit \"/std/room/furniture/dividor_room\";\n\n"
           "void setup() {\n"
           "   set_base_desc(\"" + environment()->query_base_desc() + "\");\n"
           "   set_main_room(\"" + base_name(environment()) + "\");\n"
           "   set_save_dir(\"" + path + "\");\n"
           "   set_theft_handler(\"" + environment()->query_theft_handler() + "\");\n"
           "   add_exit(\"" + ROOM_HANDLER->query_opposite_direction(query_exit_direction()) + "\", \"" + base_name(environment() + "\", \"door\");\n"
           "   set_property_size(" + _size + ");\n"
           "   add_property(\"place\", \"" + environment()->query_property("place") + "\");\n"
           "}";
   write_file(room_path + ".c", stuff, 1);
   return 1;
}
void add_exit_to_room() {
   environment()->add_exit(query_exit_direction(), query_exit_destination(), "door");
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, TAG, "exit", _exit_direction);
   add_auto_load_value(map, TAG, "room", _our_room);
   add_auto_load_value(map, TAG, "size", _size);
   return map;
}
void init_dynamic_arg(mapping map) {
   _exit_direction = query_auto_load_value(map, TAG, "exit");
   _our_room = query_auto_load_value(map, TAG, "room");
   _size = query_auto_load_value(map, TAG, "size");
   ::init_dynamic_arg(map);
}

==================================================
FILE: /lib/std/room/furniture/dividor_room.c
==================================================

inherit "/std/shops/commercial";
private string _main_room;
void set_main_room(string room) {
   _main_room = room;
}
string query_main_room() {
   return _main_room;
}
string query_parcel_post() {
   return _main_room->query_parcel_post();
}

==================================================
FILE: /lib/std/room/furniture/document_handler.c
==================================================

inherit "/std/room/furniture/commercial";
inherit "/std/room/furniture/inherit/document_handler";
#include <room/document_handler.h>
void create() {
   document_handler::create();
   commercial::create();
   add_help_file("document_handler");
   set_shop_use_types( ({ "document_view",
                          "document_add",
                          "document_delete" }) );
}
string query_save_dir() {
   return commercial::query_save_dir() + "/" + query_commercial_id();
}
void load_me() {
   if (!query_commercial_id()) {
      setup_new_commercial_id();
   }
   if (unguarded( (: file_size(query_save_dir()) :) ) != -2) {
      unguarded( (: mkdir(query_save_dir()) :));
   }
}
void save_me() {
   environment()->event_save(this_object());
}
void init() {
   add_command("list", "documents [from] <direct:object>", (: do_list() :));
   add_command("view", "document <string'id'> [from] <direct:object>",
                (: do_display($4[0]) :));
   add_command("add", "documents {html|plain} called <string:quoted'title'> to <direct:object>",
               (: do_add_document($4[1], ($4[0] == "html"?DOCUMENT_HTML:DOCUMENT_PLAIN)) :));
   add_command("delete", "document <string'id'> [from] <direct:object>",
                (: do_delete_document($4[0]) :));
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = commercial::query_dynamic_auto_load();
   document_handler::query_dynamic_auto_load(map);
   return map;
}
void init_dynamic_arg(mapping map) {
   document_handler::init_dynamic_arg(map);
   commercial::init_dynamic_arg(map);
}

==================================================
FILE: /lib/std/room/furniture/fireplace.c
==================================================

#include <fuel_handler.h>
#include <move_failures.h>
#define WIZARD "/std/guilds/wizard"
#define CMD "/cmds/"
#define BURN_PER_TICK   1
#define BRIGHT 30
#define K      1
inherit "/std/room/furniture/surface";
private nosave int _light_produced;
private nosave int _is_lit;
private nosave int _frequency;
private nosave string _lit_mess;
private nosave string _unlit_mess;
private nosave string *_lit_chats;
private nosave string *_dying_chats;
private nosave string _turn_on_mess;
private nosave string _turn_off_mess;
private nosave string _out_of_fuel_mess;
void set_light_produced(int b);
void set_lit_mess(string str);
void set_unlit_mess(string str);
void set_frequency(int i);
void set_lit_chats(string *str);
void add_lit_chat(string str);
string request_lit_chat();
void set_dying_chats(string *str);
void add_dying_chat(string str);
string request_dying_chat();
void set_turn_on_mess(string mess);
void set_turn_off_mess(string mess);
void set_out_of_fuel_mess(string mess);
int do_light(object *obs);
int do_zap();
int turn_on();
int do_dowse(object *obs);
int turn_off();
int calc_fuel();
void create() {
  do_setup++;
  surface::create();
  do_setup--;
  set_name("fireplace");
  add_alias( ({ "fireplace", "furniture", "hearth", "fire" }) );
  add_plural( "fireplaces" );
  add_property( "shop type", "furniture" );
  add_property( "degrees", 0 );
  set_light_produced( BRIGHT );
  set_lit_mess("A fire blazes happily in the hearth, providing "
      "a soft red glow and pleasant warmth. It crackles and spits "
      "occasionally, giving the room that homely feel.\n");
  set_unlit_mess("The hearth is blackened with ashes and old embers.\n");
  set_frequency(5);
  set_lit_chats( ({
      "The fire crackles and spits cheerfully.",
      "The warm fire soothes your weariness.",
      "An enchanting orange glow radiates from the hearth.",
      "Small glowing embers dance over the fire.",
      "The fire blazes in the grate." }) );
  set_dying_chats( ({
      "The fire splutters.",
      "The warm red glow flickers.",
      "A whisp of smoke from the fire trails around the room." }) );
  set_turn_on_mess("Soon a roaring fire is blazing in the grate.\n");
  set_turn_off_mess("The embers smoke slightly and their glow dims.\n");
  set_out_of_fuel_mess("The fire flickers and dies away.\n");
  if ( !do_setup ) {
      this_object()->setup();
  }
  this_object()->add_extra_look( this_object() );
  add_help_file("fireplace");
}
void init() {
  this_player()->add_command("light", this_object(), "<direct:object> with <indirect:object>");
  this_player()->add_command("extinguish", this_object(), "<direct:object>", (: do_dowse :) );
  this_player()->add_command("dowse", this_object(), "<direct:object>");
  if( this_player()->query_guild_ob() == WIZARD ){
    this_player()->add_command("zap", this_object(), "<direct:object>");
    this_player()->add_command("point", this_object(), "[finger] at <direct:object>", (: do_zap :) );
  }
}
int query_fuel_left(){  return calc_fuel();  }
void set_light_produced(int b){  _light_produced = b;  }
int query_light_produced(){  return _light_produced;  }
void set_frequency(int i){  _frequency = i + 1;  }
int query_frequency(){  return _frequency;  }
int do_light(object *obs){
  string q_n;
  q_n = obs[0]->query_name();
  if( _is_lit ){
    this_player()->add_failed_mess( this_object(),
         "$D is already ablaze.\n", ({ }) );
    return 0;
  }
  if( q_n != "flint" && q_n != "match" && q_n != "lighter" ){
    this_player()->add_failed_mess(this_object(),
         "You can't light $D with $I.\n", ({ obs[0] }) );
    return 0;
  }
  if( this_player()->query_dex() < random(18) ){
    this_player()->add_failed_mess(this_object(),
      "You strike $I, but can't quite get the spark to catch.\n", ({ obs[0] }) );
    return 0;
  }
  if ( calc_fuel() <= 0 ) {
    this_player()->add_failed_mess( this_object(),
        "There is nothing in the fireplace to burn.\n", ({ }) );
    return 0;
  }
  this_player()->add_succeeded_mess(this_object(),
    "$N $V $D with $I.\n", ({ obs[0] }) );
  return turn_on();
}
int do_zap(){
  object tp;
  tp = this_player();
  if(tp->query_gp() < 10){
    tell_object(tp, "You don't even have the energy for such a small task!\n");
    return 1;
  }
  if(_is_lit){
    tell_object(tp, "There is already a merry fire burning in the fireplace.\n");
    return 1;
  } else {
    tp->add_succeeded_mess(this_object(),
      "$N extend$s an arm towards $D.\nA small fireball leaps from $p "
      "index finger and throws itself onto the hearth.\n", ({ }) );
    tp->adjust_gp( -10 );
    return turn_on();
  }
}
void set_turn_on_mess(string mess){  _turn_on_mess = mess;  }
string query_turn_on_mess(){  return _turn_on_mess;  }
void set_turn_off_mess(string mess){  _turn_off_mess = mess;  }
string query_turn_off_mess(){  return _turn_off_mess;  }
void msg_on(){
  if(_is_lit){
    tell_room(environment( this_object() ), query_turn_on_mess() );
  }
}
int turn_on(){
  int x;
  FUEL_HANDLER->add_burner( this_object() );
  _is_lit = 1;
  adjust_light( query_light_produced() );
    x = query_light_produced() / 4;
    add_property("degrees", query_light_produced() * 4);
    environment( this_object() )->add_property("warmth", x );
  call_out( "msg_on", 7 );
  return 1;
}
int do_dowse(object *obs){
  if( !_is_lit ){
    this_player()->add_failed_mess( this_object(),
         "There is no fire to put out.\n", ({ }) );
    return 0;
  } else {
    this_player()->add_succeeded_mess(this_object(),
      "$N $V $D and the room loses its warm glow.\n", ({ }) );
    return turn_off();
  }
}
void msg_off() {
  if(!_is_lit){
    tell_room(environment( this_object() ), query_turn_off_mess() );
  }
}
int turn_off(){
  FUEL_HANDLER->remove_burner( this_object() );
  _is_lit = 0;
  adjust_light( -query_light_produced() );
  add_property( "degrees", 0 );
  environment( this_object() )->remove_property("warmth");
  call_out( "msg_off", 10 );
  return 1;
}
void set_out_of_fuel_mess(string mess){  _out_of_fuel_mess = mess;  }
string query_out_of_fuel_mess(){  return _out_of_fuel_mess;  }
void out_of_fuel() {
  turn_off();
  tell_room(environment( this_object() ), query_out_of_fuel_mess() );
}
void set_lit_chats(string *str){  _lit_chats = str;  }
void add_lit_chat(string str){
  if( !_lit_chats ){
    _lit_chats = ({ });
  }
  _lit_chats += ({ str });
}
string request_lit_chat(){
  return _lit_chats[random( sizeof(_lit_chats) - 1 )];
}
void set_dying_chats(string *str){  _dying_chats = str;  }
void add_dying_chat(string str){
  if( !_dying_chats ){
    _dying_chats = ({ });
  }
  _dying_chats += ({ str });
}
string request_dying_chat(){
  return _dying_chats[random( sizeof(_dying_chats) - 1 )];
}
void set_lit_mess(string str){  _lit_mess = str;  }
string query_lit_mess(){  return _lit_mess;  }
void set_unlit_mess(string str){  _unlit_mess = str;  }
string query_unlit_mess(){  return _unlit_mess;  }
void consume_fuel() {
  int x;
  int q;
  int z;
  int w;
  int amount;
  string r;
  object *inv;
  object ashes;
  object thing;
  object env;
  inv = filter(all_inventory( this_object() ),
              (:$1->query_property("fuel") :));
  if( !inv || inv == ({ }) || calc_fuel() < 1){
    out_of_fuel();
    return;
  }
  x = sizeof(inv);
  foreach(thing in inv){
      q = thing->query_amount_left();
      w = thing->query_weight();
      z = q - ( ( BURN_PER_TICK * 100 / x ) / w );
      if ( z < 1 ){
          thing->move("/room/rubbish");
          amount = roll_MdN(4, 20);
          ashes = clone_object("/obj/cont_medium");
          ashes->set_name("ash");
          ashes->set_short("fine grey ash");
          ashes->add_property("determinate", "some ");
          ashes->add_adjective(({"some", "fine", "grey", "pinch", "pinches",
           "handful", "handfuls", "bucketful", "bucketfuls", "of"}));
          ashes->add_plural("ash");
          ashes->set_long("This is $pile_size$ of fine grey ash, "
            "$amount_size$. It looks like it was the leftovers "
            "from someone's camp fire.\n");
          ashes->set_weight_unit(({ 1, 50 }));
          ashes->set_medium_alias("FiNeGrEyAsH");
          ashes->set_amount_types((["pinch" : ({1, "pinches"}),
           "handful" : ({50, "handfuls"}),
           "bucketful" : ({1000, "bucketfuls"})]));
          ashes->set_pile_types(({50, "small", 100, "medium",
            200, "large", "huge"}));
          ashes->set_continuous();
          ashes->set_amount(amount);
          ashes->move(this_object());
      } else {
        thing->set_amount_left( z );
      }
  }
  calc_fuel();
  env = environment( this_object() );
  if( random( query_frequency() ) == 1 ){
    if( calc_fuel() > 10 ){
      r = request_lit_chat();
      tell_room( env, r + "\n");
    } else {
      r = request_dying_chat();
      tell_room( env, r + "\n");
    }
  }
}
int calc_fuel(){
  object *inv;
  object thing;
  int tot_fuel = 0;
  int w;
  int amt;
  inv = all_inventory( this_object() );
  if( !inv || inv == ({ }) ) { return 0; }
  foreach(thing in inv){
    if( thing->query_property("fuel") ){
      w =  thing->query_weight();
      amt = thing->query_amount_left();
      tot_fuel += w * amt * K / 100 ;
    }
  }
  return tot_fuel;
}
int test_remove( object thing, int flat, mixed dest){
  object tp;
  object *prev;
  tp = this_player();
  prev = previous_object(-1);
  if(_is_lit && tp && strsrch( file_name(prev[1]), CMD ) != -1 ){
    tell_object(tp, "You reach out towards the fire but "
       "you can't brave the flames and quickly pull away.\n");
    tell_room( environment(tp), tp->query_short() + " tries to take something "
      "from the fire but pulls back sucking " + tp->query_possessive() +
      " fingers.\n", tp);
    tp->adjust_hp( -random(120) );
    return 0;
  }
  return ::test_remove(thing, flat, dest);
}
int test_add( object thing, int flag ) {
  if( !thing->query_property("fuel") && environment(thing) ){
    tell_object(this_player(), "You don't think " + thing->the_short() +
      " would be a suitable fuel.\n");
    return 0;
  }
  if( _is_lit ){
    tell_room(environment( this_object() ),
      ({ "The fire crackles.\n",
         "A shower of glowing embers tumble around the hearth.\n" })[random(2)] );
  }
  call_out("calc_fuel",1);
  return 1;
}
string extra_look( object ob ){
  if( _is_lit ) {
      return query_lit_mess();
  }
  else {
      return query_unlit_mess();
  }
}
void pre_dest_me() {
  int tmp;
  if(_is_lit && environment()) {
    FUEL_HANDLER->remove_burner( this_object() );
    _is_lit = 0;
    adjust_light( -query_light_produced() );
    tmp = environment()->query_property("warmth");
    if(tmp > query_light_produced() / 4)
      environment()->add_property("warmth", tmp -
                            (query_light_produced() / 4));
    else
      environment()->remove_property("warmth");
  }
  return;
}
void dest_me() {
  FUEL_HANDLER->remove_burner( this_object() );
  _is_lit = 0;
   ::dest_me();
}

==================================================
FILE: /lib/std/room/furniture/fireplace_inherit.c
==================================================

inherit "/std/room/furniture/fireplace";

==================================================
FILE: /lib/std/room/furniture/fuel_inherit.c
==================================================

inherit "/std/object";
private nosave int _amount;
private nosave string *_shorts;
private nosave string *_longs;
string fuel_short();
string fuel_long();
void create(){
   ::create();
   if(!_amount){
     _amount = 100;
   }
   set_short( (: fuel_short :) );
   set_long( (: fuel_long :) );
   add_property("no recycling", 1);
   add_property("fuel", 1);
}
void set_amount_left(int i){  _amount = i;  }
void adjust_amount_left(int i){  _amount += i;  }
int query_amount_left(){  return _amount;  }
void set_shorts(string *desc){  _shorts = desc;  }
void set_longs(string *desc){  _longs = desc;  }
string fuel_short(){
   int i;
   int x;
   x = sizeof(_shorts);
   for(i = 1; i <= x; i++){
      if( (_amount + 1) > 100 - ( i * 100 / x ) ){
         return _shorts[(i-1)];
      }
   }
   return "fuel";
}
string fuel_long(){
   int i;
   int x;
   x = sizeof(_longs);
   for(i = 1; i <= x; i++){
      if( ( _amount + 1 ) > ( 100 - ( i * 100 / x )) ){
         return _longs[(i-1)];
      }
   }
   return "fuel";
}
mixed query_dynamic_auto_load() {
   return ([ "::" : ::query_dynamic_auto_load(),
             "amount" : _amount
          ]);
}
void init_dynamic_arg(mapping arg) {
   _amount = arg[ "amount" ];
   ::init_dynamic_arg(arg["::"]);
}

==================================================
FILE: /lib/std/room/furniture/furniture.c
==================================================

#include <move_failures.h>
#include <position.h>
#include <tasks.h>
inherit "/obj/cont_save";
inherit "/std/basic/trap";
inherit "/std/room/furniture/inherit/furniture_base";
private nosave string _drawer_mess;
private nosave mixed *_drawers;
private nosave int _biggest;
private nosave int _drawers_inside;
private nosave object *_on_top;
private nosave int _has_surface;
#define DEBUG
void create() {
  do_setup++;
  ::create();
  _drawer_mess = "a drawer in $ob_short$";
  _drawers = ({ });
  _on_top = ({ });
  add_alias( "furniture" );
  add_plural( "furniture" );
  set_opaque();
  if (!query_property("shop type"))
    add_property( "shop type", "furniture" );
   do_setup--;
   if(!do_setup)
     this_object()->setup();
}
string query_drawer_mess() { return _drawer_mess; }
void set_drawer_mess( string words ) { _drawer_mess = words; }
mixed *query_drawers() { return _drawers; }
void add_drawer( string type, int amount ) {
   if ( !type || ( type == "" ) || ( amount < 1 ) ) {
      return;
   }
   _drawers += ({ type, amount });
   set_max_weight(query_max_weight() + amount);
   if ( amount > _biggest ) {
      _biggest = amount;
   }
}
int query_has_surface() { return _has_surface; }
void set_has_surface(int i) { _has_surface = i; }
void set_drawers_inside(int i) { _drawers_inside = i; }
int query_drawers_inside() { return _drawers_inside; }
varargs int move( mixed dest, string messin, string messout ) {
  int i, w;
  object from;
  w = (int)this_object()->query_complete_weight() * 5;
  if ( from = environment() ) {
    from->add_weight( -w );
  }
  if(!dest) {
    return MOVE_INVALID_DEST;
  }
  if (!( dest->add_weight( w ) ) ) {
    if ( from ) {
      from->add_weight( w );
    }
    return MOVE_TOO_HEAVY;
  }
  if ( stringp( dest ) ) {
    dest = find_object( dest );
  }
  i = ::move( dest, messin, messout );
  if ( i != MOVE_OK ) {
    if ( from ) {
      from->add_weight( w );
    }
    dest->add_weight( -w );
  } else if (query_light_needs_inform()) {
    if ( from ) {
      inform_of_light_level_change(from);
    }
    inform_of_light_level_change(dest);
  }
  return i;
}
string long( string word, int dark ) {
   int i;
   string ret, *sizes;
   mapping types;
  ret = ::long( word, dark );
   if ( sizeof( _drawers ) && !dark &&
        (!query_closed() || !_drawers_inside)) {
     types = ([ ]);
     for ( i = 0; i < sizeof( _drawers ); i += 2 ) {
       types[ _drawers[ i ] ]++;
     }
     sizes = m_indices( types );
     for ( i = 0; i < sizeof( sizes ); i++ ) {
       sizes[ i ] = query_num( types[ sizes[ i ] ] ) +" "+ sizes[ i ] +
         " drawer"+ ( types[ sizes[ i ] ] > 1 ? "s" : "" );
     }
     ret += "It has "+ query_multiple_short( sizes ) +".\n";
   }
   if(sizeof(_on_top))
     ret += query_contents( "On " + the_short() + " " +
                            (sizeof(_on_top) == 1 ? "is " : "are " ), _on_top);
   return ret;
}
varargs string query_contents( string start, object *things,
  int ignore_living) {
  if(!arrayp(things)) {
    things = this_object()->find_inv_match( "", this_player() );
    things -= ({ this_player() });
    things = filter_array( things, (: environment( $1 ) == this_object() :) );
    things -= _on_top;
  }
  return ::query_contents(start, things, ignore_living);
}
int test_remove(object thing, int flag, mixed dest) {
  int result;
  mixed *stuff;
  result = ::test_remove(thing, flag, dest);
  if(result) {
    stuff = thing->query_property("dropped");
    if(environment() &&
       dest == this_player() &&
       function_exists("test_occupier", environment()) &&
       !environment()->test_occupier(this_player()->query_name()) &&
       (!sizeof(stuff) || stuff[0] != this_player()->query_name())) {
      event(environment(this_player()), "theft", this_player(), this_object(),
            ({ thing }));
    }
    if(dest) {
      _on_top -= ({ thing });
      thing->remove_property("_on_top");
    }
    event(environment(), "save");
  }
  return result;
}
int test_add( object thing, int flag ) {
  int i;
  int result;
  if ( flag )
    return 0;
  if(!environment(thing))
    return 1;
  result = ::test_add(thing, flag);
  if(!result)
    return 0;
  if("/cmds/living/put"->query_con() == "on" && _has_surface) {
    _on_top += ({ thing });
    thing->add_property("_on_top", 1);
  } else if(sizeof(_drawers)) {
    if ( !_biggest )
      for ( i = 0; i < sizeof( _drawers ); i+= 2 )
        if ( _drawers[ i + 1 ] > _biggest )
          _biggest = _drawers[ i + 1 ];
    if ( (int)thing->query_complete_weight() > _biggest )
      return write( (string)thing->the_short() +" is too big "+
                    "to fit in any of "+ the_short() +"'s drawers.\n" );
  }
  event(environment(), "save", this_object());
  return result;
}
int pick_unlock(object player) {
  mixed owner;
  if(!environment())
    return ::pick_unlock(player);
  if(!environment() || !function_exists("query_owner", environment()))
    return ::pick_unlock(player);
  owner = environment()->query_owner();
  if(stringp(owner) && pk_check(player, owner, 1)) {
    write("You feel it would be wrong to try to break into "+
          this_object()->query_short() + ".\n");
    return 0;
  }
  return ::pick_unlock(player);
}
mapping int_query_static_auto_load() {
  return ([
           "::" : ::int_query_static_auto_load(),
           "drawer mess" : _drawer_mess,
           "drawers" : _drawers,
           "allowed_positions" : query_allowed_positions(),
           "trap" : query_trap_data(),
           "trap armed": query_trap_armed(),
           ]);
}
mapping query_static_auto_load() {
  return int_query_static_auto_load();
}
void init_static_arg( mapping map ) {
  if ( !mapp( map ) )
    return;
  if ( map[ "::" ] )
    ::init_static_arg( map[ "::" ] );
  if ( !undefinedp( map[ "drawer mess" ] ) )
    _drawer_mess = map[ "drawer mess" ];
  if ( !undefinedp( map[ "drawers" ] ) )
    _drawers = map[ "drawers" ];
  if(!undefinedp(map["allowed_positions"]))
    set_allowed_positions( map["allowed_positions"]);
  if(!undefinedp(map["trap"]))
    setup_trap(map["trap"][0],
                   map["trap"][1],
                   map["trap"][2],
                   map["trap"][3],
                   map["trap"][4]);
  if(!undefinedp(map["trap armed"]))
    set_trap_armed(map["trap armed"]);
}
void init_dynamic_arg(mapping bing) {
  object item;
  ::init_dynamic_arg(bing);
  foreach(item in all_inventory(this_object())) {
    if(item->query_property("_on_top"))
      _on_top += ({ item });
  }
}
string query_help_file_directory() {
  return "/doc/furniture/";
}
mixed *stats() {
  int i;
  mixed *ret;
  ret = ::stats();
  ret += ({ ({ "surface", _has_surface }) });
  for ( i = 0; i < sizeof( _drawers ); i += 2 )
    ret += ({ ({ _drawers[ i ] +" drawer", _drawers[ i + 1 ] }) });
  return ret;
}

==================================================
FILE: /lib/std/room/furniture/mirror.c
==================================================

#include <effect.h>
inherit "/std/room/furniture/basic";
int _in_extra;
void create(){
	::create();
	add_extra_look(this_object());
}
string extra_look(object ob) {
	int dark;
	object env;
	env = environment(ob);
	if(living(env))
		return "You can see yourself in the mirror.";
	dark = (int) this_player()->check_dark((int)env->query_light());
	if(dark)
		return "It is too dark to see much in the room.";
	return "Reflected in the mirror is " +
		query_multiple_short(all_inventory(env) - ({ ob }), "a", 0, 1, dark) +
		".";
}
# Total Tokens: 19723
# Total Files Merged: 15
# Total Characters: 65782

