# Total Tokens: 18572
# Total Files Merged: 8
# Total Characters: 61931

it/pub.c
==================================================

#include <shops/pub_shop.h>
#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <map.h>
inherit "/std/shops/inherit/open_shop";
inherit "/std/shops/inherit/shop_event";
void add_hidden_object(object ob);
private mapping _menu_items;
private mapping _menu_aliases;
private string _menu_header;
private string _language;
private int _display_header;
private string *_menu_subheadings;
private int _display_subheadings;
private int no_standard_alias;
private object _menu_object;
private object _counter;
void add_menu_alias( mixed alias, string actual );
string *calc_standard_aliases( string *aliases );
int do_buy( object *obs, string dir, string indir, mixed *args );
float query_discount( object ob );
object make_counter();
void create() {
   shop_event::create();
   _menu_items = ([ ]);
   _menu_aliases = ([ ]);
   _menu_header = "The menu reads:";
   _display_header = 1;
   _menu_subheadings = ({ "Appetisers", "Main Courses", "Desserts",
                         "Alcoholic Beverages", "Soft Drinks",
                         "Hot Drinks" });
   _display_subheadings = 1;
   if( base_name( this_object() ) + ".c" != __FILE__ ) {
      _menu_object = clone_object( PUB_MENU_FILE );
      _menu_object->set_pub( this_object() );
      add_hidden_object( _menu_object );
      _counter = make_counter();
   }
}
void init() {
   this_player()->add_command( "buy", this_object(), "<string>" );
   this_player()->add_command( "buy", this_object(),
                     "<string> for <indirect:living:here>" );
   this_player()->add_command( "order", this_object(), "<string>",
                     (: do_buy( $1, $2, $3, $4 ) :) );
   this_player()->add_command( "order", this_object(),
                     "<string> for <indirect:living:here>",
                     (: do_buy( $1, $2, $3, $4 ) :) );
}
varargs void add_menu_item(
   string name,
   int type,
   int cost,
   string item,
   string container,
   int volume,
   int intox
) {
   class menu_item new_item;
   string noun, alias;
   string *adjectives, *aliases;
   if( intox < 0 )
      intox = 0;
   if( intox > 10 )
      intox = 10;
   new_item = new( class menu_item );
   new_item->type = type;
   new_item->cost = cost;
   new_item->item = item;
   new_item->container = container;
   new_item->volume = volume;
   new_item->intox = intox;
   _menu_items[name] = new_item;
   if( no_standard_alias ) {
      if( lower_case( name ) != name )
         add_menu_alias( lower_case( name ), name );
      return;
   }
   adjectives = explode( lower_case( name ), " " );
   noun = adjectives[sizeof(adjectives) - 1];
   adjectives = adjectives[0..sizeof(adjectives) - 2];
   aliases = calc_standard_aliases( adjectives );
   foreach( alias in aliases ) {
      add_menu_alias( implode( ({ alias, noun }), " " ), name );
   }
}
string *calc_standard_aliases( string *array ) {
   int i, num_aliases;
   string *new_alias, *aliases;
   if( !sizeof( array ) )
      return ({ 0 });
   if( sizeof( array ) == 1 )
      return ({ array[0], 0 });
   aliases = calc_standard_aliases( array[0..sizeof( array ) - 2] );
   num_aliases = sizeof( aliases );
   for( i = 0; i < num_aliases; i++ ) {
      new_alias = ({ aliases[i], array[ sizeof( array ) - 1] });
      aliases += ({ implode( new_alias, " " ) });
   }
   return aliases;
}
mapping query_menu_items() {
   return _menu_items;
}
int query_pub() {
   return 1;
}
void set_language(string language) {
   _language = language;
}
string query_language() {
   return _language;
}
int remove_menu_item( string name ) {
   if( !_menu_items[name] ) {
      return 0;
   }
   map_delete( _menu_items, name );
   return 1;
}
string string_menu( string *items ) {
   int loop;
   string str, place;
   str = "";
   place = this_object()->query_property( "place" );
   if( !place || ( place == "" ) ) {
      place = "default";
   }
   for( loop = 0; loop < sizeof(items); loop++ ) {
      str += sprintf( "    %-30s %s\n", items[loop],
             MONEY_HAND->money_value_string(
             _menu_items[items[loop]]->cost, place ) );
   }
   return str;
}
string *query_items_of_type( int type ) {
   int i;
   string *selected;
   string *items;
   selected = ({ });
   items = keys( _menu_items );
   for( i = 0; i < sizeof(items); i++ ) {
      if( _menu_items[items[i]]->type == type ) {
         selected += ({ items[i] });
      }
   }
   selected = sort_array( selected, (: _menu_items[$1]->cost -
                                       _menu_items[$2]->cost :) );
   return selected;
}
string string_menu_of_type( int type ) {
   string str;
   string *items;
   items = query_items_of_type( type );
   if( !sizeof(items) ) {
      return "";
   }
   if( _display_subheadings ) {
      str = _menu_subheadings[ type ] + "\n";
   }
   str += string_menu( items );
   return sprintf( "%-=*s\n", (int)this_player()->query_cols(), str );
}
string read() {
   string ret;
   ret = "\n";
   if( _display_header ) {
      ret += _menu_header + "\n";
   }
   ret += string_menu_of_type( PUB_APPETISER );
   ret += string_menu_of_type( PUB_MAINCOURSE );
   ret += string_menu_of_type( PUB_DESSERT );
   ret += string_menu_of_type( PUB_ALCOHOL );
   ret += string_menu_of_type( PUB_SOFTDRINK );
   ret += string_menu_of_type( PUB_HOTDRINK );
   return ret;
}
void set_display_header( int value ) {
   _display_header = value;
}
int query_display_header() {
   return _display_header;
}
void set_menu_header( string header ) {
   _menu_header = header;
}
string query_menu_header() {
   return _menu_header;
}
void set_display_subheadings( int value ) {
   _display_subheadings = value;
}
int query_display_subheadings() {
   return _display_subheadings;
}
void set_menu_subheadings( int subheading, string text ) {
   _menu_subheadings[ subheading ] = text;
}
string *query_menu_subheadings() {
   return _menu_subheadings;
}
void add_menu_alias( mixed alias, string actual ) {
   string bing;
   if (arrayp(alias)) {
      foreach (bing in alias) {
         add_menu_alias(bing, actual);
      }
   }
   _menu_aliases[alias] = actual;
}
void add_menu_aliases( string *aliases, string actual ) {
   string alias;
   foreach( alias in aliases ) {
      add_menu_alias( alias, actual );
   }
}
mapping query_menu_aliases() {
   return _menu_aliases;
}
int remove_menu_alias( string alias ) {
   if( !_menu_aliases[alias] ) {
      return 0;
   }
   map_delete( _menu_aliases, alias );
   return 1;
}
void set_no_standard_alias( int flag ) {
   no_standard_alias = flag;
}
int query_no_standard_alias() {
   return no_standard_alias;
}
object create_real_object( string name ) {
   object item, container;
   if( _menu_items[name]->container ) {
      container = this_object()->create_container(
                                    _menu_items[name]->container );
      if( !container ) {
         container = clone_object( _menu_items[name]->container );
      }
      if( !container ) {
         container = ARMOURY->request_item(
                                 _menu_items[name]->container, 100 );
      }
   }
   if( _menu_items[name]->item ) {
      item = this_object()->create_item( _menu_items[name]->item );
      if( !item ) {
         item = clone_object( _menu_items[name]->item );
      }
      if( !item ) {
         item = ARMOURY->request_item( _menu_items[name]->item, 100 );
      }
   }
   if( item && _menu_items[name]->volume ) {
      item->set_amount( _menu_items[name]->volume );
   } else if ( item && !_menu_items[name]->volume &&
              ( _menu_items[name]->type == PUB_ALCOHOL ||
                _menu_items[name]->type == PUB_HOTDRINK ||
                _menu_items[name]->type == PUB_SOFTDRINK ) ) {
      item->set_amount( container->query_max_volume() -
                        container->query_volume() );
   }
   if( item && container ) {
      if( (int)item->move( container ) != MOVE_OK ) {
         write( "The " + container->short() + " is too small to hold " +
            item->the_short() + ".  Please file a bug report.\n" );
         item->move( "/room/rubbish" );
      }
   }
   if( container ) {
      return container;
   }
   if( item ) {
      return item;
   }
   return 0;
}
int do_buy( object *obs, string dir, string indir, mixed *args ) {
   int value, cost;
   string str, place;
   object person, thing;
   object *succeededpeople, *deadpeople, *failedpeople, *poorpeople;
   succeededpeople = ({ });
   deadpeople = ({ });
   failedpeople = ({ });
   poorpeople = ({ });
   str = args[0];
   if( this_player()->query_property( "dead" ) ) {
      add_failed_mess( "How can you expect to buy " + str + " when you're "
         "dead?\n" );
      return 0;
   }
   if( _menu_aliases[str] ) {
      str = _menu_aliases[str];
   }
   if( !_menu_items[str] ) {
      if (!broadcast_shop_event(PUB_EVENT_NOT_AVAILABLE, this_player(), str)) {
         add_failed_mess( "Sorry, " + str + " is not on the menu.\n" );
      }
      return 0;
   }
   if ( !is_open( this_player(), _menu_items[str]->type ) ) {
      broadcast_shop_event(PUB_EVENT_NOT_OPEN, this_player());
      return 0;
   }
   if( !sizeof( obs ) ) {
      obs = ({ this_player() });
   }
   foreach( person in obs ) {
      if( person->query_property( "dead" ) ) {
         deadpeople += ({ person });
         continue;
      }
      if( !living( person ) ||
          !interactive( person ) && !person->query_property( "npc" ) ) {
         failedpeople += ({ person });
         continue;
      }
      cost = ( _menu_items[str]->cost ) * query_discount( this_player() );
      place = this_object()->query_property( "place" );
      if( !place || ( place == "" ) ) {
         place = "default";
      }
      value = (int)this_player()->query_value_in( place );
      if( place != "default" ) {
         value += (int)this_player()->query_value_in( "default" );
      }
      if( cost > value ) {
         poorpeople += ({ person });
         continue;
      }
      thing = create_real_object( str );
      if( !thing ) {
         add_failed_mess( "Something is buggered.  Please file a bug report.  "
            "Thank you.\n" );
         return 0;
      }
      this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array(
                        cost, place ), place );
      succeededpeople += ({ person });
      if( (int)thing->move( person ) != MOVE_OK ) {
         if( (int)thing->move( _counter ) != MOVE_OK ) {
            thing->move( this_object() );
            write("You cannot pick " + thing->a_short() +
               " up.  It's left on the floor for you.\n" );
         } else {
           write("You cannot pick " + thing->a_short() +
              " up.  It's left on the counter for you.\n" );
         }
      }
   }
   if( sizeof( succeededpeople ) ) {
      if (!broadcast_shop_event(PUB_EVENT_BOUGHT_STUFF, this_player(),
                           succeededpeople, str)) {
         if( !MAP_HANDLER->compare_arrays( succeededpeople,
                                           ({ this_player() }) ) ) {
            this_player()->add_succeeded_mess( this_object(),
               "$N $V $I.\n", ({ add_a(str) }) );
         } else {
            add_succeeded_mess("$N $V "
               + query_multiple_short( ({ thing }), "a" ) + " for $I.\n",
               succeededpeople);
         }
      }
   } else {
      if( sizeof( deadpeople ) ) {
         if (!broadcast_shop_event(PUB_EVENT_DEAD_PEOPLE, this_player(),
                              deadpeople, str)) {
            add_failed_mess("What use " +
               ( sizeof( deadpeople ) > 1?"have ":"has " ) +
               query_multiple_short( deadpeople, "one" ) + " got for " + str +
               "?\n" );
         }
      }
      if( sizeof( failedpeople ) ) {
         if (!broadcast_shop_event(PUB_EVENT_FAILED_PEOPLE, this_player(),
                              failedpeople, str)) {
            add_failed_mess("You can't buy anything for " +
               query_multiple_short( failedpeople, "one" ) + ".\n" );
         }
      }
      if( sizeof( poorpeople ) ) {
         if (!broadcast_shop_event(PUB_EVENT_POOR_PERSON, this_player(),
                              poorpeople, str)) {
            add_failed_mess("You cannot afford to order " + str +
               " for " + query_multiple_short( poorpeople, "one" ) + ".\n" );
         }
      }
      return 0;
   }
   return 1;
}
void dest_me() {
   if( _menu_object ) {
      _menu_object->dest_me();
   }
}
float query_discount( object ob ) {
   return 1.0;
}
object make_counter() {
   object ob;
   ob = clone_object( PUB_COUNTER_FILE );
   add_hidden_object( ob );
   return ob;
}
object query_counter() {
   return _counter;
}
object query_menu() {
   return _menu_object;
}

==================================================
FILE: shops/inherit/shop_event.c
==================================================

private nosave object* _events;
void create() {
   _events = ({ });
}
void add_shop_observer(object observer) {
   if (!_events) {
      _events = ({ });
   }
   if (member_array(observer, _events) == -1) {
      _events += ({ observer });
   }
}
void remove_shop_observer(object observer) {
   _events -= ({ observer });
}
int broadcast_shop_event(string type, object player, mixed args ...) {
   debug_printf("Calling %O on %O\n", "event_shop_" + type, _events);
   if (sizeof(filter(call_other(_events, "event_shop_" + type, this_object(),
                                player, args ...),
                    (: $1 :)))) {
      return 1;
   }
   return 0;
}

==================================================
FILE: shops/inherit/store_close.c
==================================================

#include <weather.h>
#include <climate.h>
#include <am_time.h>
void open_up();
void close_up();
private string _keeper;
private string *_outside_rooms;
private string *_exits;
private string _burglar;
private string _file;
private int _flag;
private int _open;
private int _closed;
private nosave object _keeper_ob;
void event_weather(int whats_changed){
   if(whats_changed >= 8){
      if (_flag) {
         call_out("night_time_check", 1);
      } else {
         call_out("day_time_check", 1);
      }
   }
}
protected void night_time_check(){
   int bing;
   bing = AM_TIME_HANDLER->query_am_hour(time() );
   if (bing > 12 && bing < 23 && !_closed) {
      _open = 0;
      _closed = 1;
      close_up();
   }
   if (bing > 0 && bing < 12 && !_open) {
      _closed = 0;
      _open = 1;
      open_up();
   }
}
protected void day_time_check(){
   int bing;
   bing = AM_TIME_HANDLER->query_am_hour(time() );
   if (bing > 0 && bing < 12 && !_closed) {
      _open = 0;
      _closed = 1;
      close_up();
   }
   if (bing > 12 && bing < 23 && !_open) {
      _closed = 0;
      _open = 1;
      open_up();
   }
}
void set_night_close(int night, string shopkeeper, string *outside,
    string burglar_func){
   int i;
   _flag = night;
   WEATHER->weather_notify( this_object(), NOTIFY_DAY );
   _keeper = _file = shopkeeper;
   if (sizeof(outside) && !(sizeof(outside)%2)) {
      _exits = allocate(sizeof(outside)/2);
      _outside_rooms = allocate(sizeof(outside)/2);
      for(i=0; i<sizeof(outside); i++) {
         if(!i%2)
            _outside_rooms[i] = outside[i];
         else
            _exits[i-1] = outside[i];
      }
   }
   _burglar = burglar_func;
}
void close_up(){
   object *obs;
   object *people;
   object bing;
   object *keeper_ob;
   int i;
   if (_keeper == "none") {
     event (this_object(), "person_say", "The shopkeeper says: ",
       "I'm sorry, it's time to close!", "common");
     tell_room (this_object(), "The shopkeeper ushers you out of "
          "the store.\n");
   }
   else {
      keeper_ob = children(_keeper);
      if (!sizeof(keeper_ob)) {
         return;
      }
      if (keeper_ob[0]->query_fighting()) {
         call_out("close_up", 60);
         return;
      }
      keeper_ob[0]->do_command("'I'm sorry, it's time to close!");
      keeper_ob[0]->do_command(":ushers you out of the store.");
      keeper_ob[0]->move("/room/rubbish");
   }
   obs = all_inventory( this_object() );
   people = filter(obs, (: $1->query_property("player") :));
   foreach(bing in people){
      bing->move_with_look(_outside_rooms[0]);
   }
   for(i=0; i<sizeof(_outside_rooms); i++){
      _outside_rooms[i]->modify_exit(_exits[i], ({"open", 0, "locked", 1,
          "difficulty", 4}));
   }
}
void open_up(){
   int i;
   for(i=0; i<sizeof(_outside_rooms); i++){
     _outside_rooms[i]->modify_exit(_exits[i], ({"open", 1, "locked", 0,
        "difficulty", 4}));
   }
   if (_keeper == "none") {
      return;
   }
   _keeper_ob = clone_object(_file);
   _keeper_ob->move(this_object());
}
void event_enter(object ob, string message, object from){
   if (!_burglar) {
      return;
   }
   if (!_closed) {
      return;
   }
   if (ob->query_creator()) {
      return;
   }
   if (!ob->query_property("player")) {
      return;
   }
   call_out(_burglar, 1, ob);
}
mapping query_dynamic_auto_load() {
   return ([ "keeper ob" : _keeper_ob ]);
}
void init_dynamic_arg(mapping map) {
   _keeper_ob = map["keeper ob"];
}

==================================================
FILE: shops/inherit/vault_entry.c
==================================================

#include <money.h>
#include <vault.h>
#define PTS proprietor->the_short()
#define TIME_LIMIT 500
#define SPAM_GUARD (60 * 3)
void add_exit(string name, string dest, string type);
void modify_exit(string name, mixed* stuff);
mixed query_property(string name);
void add_property(string name, mixed value);
void remove_property(string name);
string location, vault_name, vault_room;
int visit_cost, open_cost;
object proprietor;
void set_location(string str) { location = str; }
void set_open_cost(int i) { open_cost = i; }
void set_visit_cost(int i) { visit_cost = i; }
void set_proprietor(object ob) { proprietor = ob; }
void set_vault_name(string str) { vault_name = str; }
void set_vault_exit(string direc, mixed dest, string type) {
  vault_room = dest;
  add_exit(direc, dest, type);
  modify_exit( direc, ({ "function", "check_customer" }) );
  modify_exit( direc, ({ "closed", 1}));
}
int apply_for_account() {
  string owner;
  object container;
  if(!proprietor || environment(proprietor) != this_object())
    return notify_fail("The vault is closed since the proprietor is "
                       "missing.\n");
  this_player()->add_succeeded_mess( this_object(), "", ({ }) );
  write("You ask for an account.\n");
  say((string)this_player()->one_short() +" asks for an account.\n");
  owner = (string)this_player()->query_name();
  if ( master()->file_exists( VAULT_SAVE +vault_name+ "/"+ owner +".o" ) ||
       query_property( owner ) )
  {
    if ( this_player()->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ this_player()->query_name() );
      proprietor->do_command( "say I just said, you already have an "
         "account." );
      return notify_fail("");
    }
    proprietor->do_command( "say You already have an account!" );
    this_player()->add_property( "vault warned", 1, SPAM_GUARD );
    return 1;
  }
  if ( this_player()->query_value_in( location) < open_cost ) {
    if ( this_player()->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ this_player()->query_name() );
      proprietor->do_command( "say I just said, you don't have enough money!" );
      return notify_fail("");
    }
    proprietor->do_command("say You do not have the "+
                           (string)MONEY_HAND->money_value_string(open_cost,
                                                                  location) +
                           " that it costs to open an account." );
    this_player()->add_property( "vault warned", 1, SPAM_GUARD );
    return 1;
  }
  proprietor->do_command("say Very well, that'll be "+
                         (string)MONEY_HAND->money_value_string( open_cost,
                                                                 location) +
                         ", please." );
  this_player()->pay_money( (mixed *)MONEY_HAND->create_money_array( open_cost,
                                                                     location),
                            location);
  write( "You pay "+PTS+".\n" );
  say( (string)this_player()->the_short() +" pays "+proprietor->the_short()+
       ".\n" );
  proprietor->do_command("say As a new account holder, "
                         "your first use of the facility will be free.  "
                         "Thereafter, it will cost "+
                         (string)MONEY_HAND->money_value_string( visit_cost,
                                                                 location) +
                         " each time.");
  add_property( owner, 1 );
  container = vault_room->init_container(this_player());
  container->dest_me();
  return 1;
}
void init() {
  add_command( "apply", "for [an] account", (: apply_for_account :) );
}
int check_customer( string verb, object thing, string special ) {
  string owner;
  object vroom;
  if(!proprietor || environment(proprietor) != this_object())
    return notify_fail("The vault is closed since the proprietor is "
                       "missing.\n");
  if( !interactive(thing) )
    return 0;
  owner = (string)thing->query_name();
  if ( !master()->file_exists( VAULT_SAVE +vault_name+ "/" + owner +".o" ) &&
       !query_property( owner ) )
  {
    tell_object( thing, PTS+
                 " intercepts you.\n" );
    tell_room( this_object(), PTS+" intercepts "+
               (string)thing->the_short() +".\n",
               thing );
    if ( thing->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ thing->query_name() );
      proprietor->do_command( "say I just said, you don't have an account "
         "so I won't let you in!" );
      return notify_fail("");
    }
    proprietor->do_command("say You do not have an account!");
    if( interactive(thing) )
      proprietor->do_command("say For "+
                             (string)MONEY_HAND->money_value_string(open_cost,
                                                                    location)+
                             ", you could apply for an account.\n" );
    thing->add_property( "vault warned", 1, SPAM_GUARD );
    return notify_fail( "" );
  }
  if ( !( vroom = find_object( vault_room ) ) ) {
    vault_room->load_me();
    vroom = find_object( vault_room );
  }
  if( sizeof( filter_array( all_inventory( vroom ), (: userp( $1 ) :) ) ) ) {
    tell_object( thing, PTS+" intercepts you.\n" );
    tell_room( this_object(), PTS+" intercepts "+ (string)thing->the_short()
       +".\n", thing );
    if( thing->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ thing->query_name() );
      proprietor->do_command( "say I just told you, someone is using the "
         "facility at the moment!" );
      return notify_fail("");
    }
    proprietor->do_command("say Someone is using the facility at the moment!");
    thing->add_property( "vault warned", 1, SPAM_GUARD );
    return notify_fail( "" );
  }
  if( query_property( owner ) ) {
    remove_property(owner);
    tell_object(thing, PTS+" waves you through.\n" );
    tell_room( this_object(), PTS+" waves "+(string)thing->the_short() +
      " through.\n", thing );
    call_out( "check_idler", TIME_LIMIT, thing );
    return 1;
  }
  if ( (int)thing->query_value_in( location ) < visit_cost ) {
    tell_object( thing, PTS+" intercepts you.\n" );
    tell_room( this_object(), PTS+" intercepts "+ (string)thing->the_short()
      +".\n", thing );
    if ( thing->query_property( "vault warned" ) ) {
      proprietor->do_command( "glare "+ thing->query_name() );
      proprietor->do_command( "say I just said, you don't have enough "
         "money to use the facility!" );
      return notify_fail("");
    }
    proprietor->do_command("say It costs "+
                           (string)MONEY_HAND->money_value_string( visit_cost,
                                                                   location ) +
                           " to use the facility!" );
    thing->add_property( "vault warned", 1, SPAM_GUARD );
    return notify_fail( "" );
  }
  thing->pay_money((mixed *)MONEY_HAND->create_money_array(visit_cost,
                                                           location),
                   location);
  tell_object( thing, "You pay "+PTS+" who waves you through.\n" );
  tell_room( this_object(), (string)thing->the_short() +
             " pays "+PTS+" who waves "+ (string)thing->query_objective() +
             " through.\n", thing );
  remove_call_out("check_idler");
  call_out("check_idler", TIME_LIMIT, thing);
  return 1;
}
void check_idler(object who) {
  if(who && base_name(environment(who)) == vault_room) {
    tell_object(who, "You've been in here too long so " + PTS + " comes and "
              "drags you out.\n");
    who->move_with_look(this_object(),
                      "$N is dragged out of the vault by the hair.",
                      "$N is dragged out of the vault by the hair.");
  }
}
void player_quitting(object who, object env) {
}

==================================================
FILE: shops/objs/counter.c
==================================================

#include <position.h>
inherit "/std/surface";
void create() {
   ::create();
   set_name( "counter" );
   set_short( "counter" );
   set_long( "The counter seems to be where you should leave glasses and "
      "plates to be cleared away.\n" );
   reset_get();
   add_property(CAN_POSITION_PROPERTY, 1);
}
void clear_item( object item ) {
   if( environment( item ) == this_object()
       && !sizeof( all_inventory( item ) ) )
      item->move( "/room/rubbish" );
}
void event_enter( object ob, string mess, object from ) {
   if( ob->query_property( "pub item" )
       && !sizeof( all_inventory( ob ) ) )
      call_out( "clear_item", 3, ob );
}

==================================================
FILE: shops/player_shop/counter.c
==================================================

inherit "/std/room/basic_room";
#include <player_shop.h>
#include <money.h>
private nosave mixed *_money;
private nosave object _register = 0;
private nosave string _save_file = "",
                      _place = UNSET_STR,
                      _office = "",
                      _storeroom = "",
                      _mgr_office = "",
                      _shop_front = "",
                      _store_dir = "",
                      _office_dir = "",
                      _shop_dir = "";
private nosave int _call_save = 0;
int action(string);
void add_money_ob(object);
int adjust_register(string, int);
string directions_to(string);
private int do_calc(int,string,int);
private int do_correction(mixed);
private int do_log(mixed *);
int query_register();
private void save_me(string);
void save_register(int);
protected void set_office(string);
protected void set_directions(string, string, string);
void create()
{
   do_setup++;
   ::create();
   do_setup--;
   add_property("no burial", 1);
   add_property("determinate", "");
   if (!do_setup)
   {
      this_object()->setup();
      this_object()->reset();
   }
   add_item("calculator", "A standard shop's calculator used to total "
     "up all those difficult prices.  To use, see \"syntax calc\".");
   add_help_file("player_shop_counter");
}
void init()
{
   ::init();
   if (!_office || _office == "") return;
   this_player()->command_override((: action :));
   add_command("calc", "<number> {+|-|*|/} <number>",
     (: do_calc($4[0],$4[1],$4[2]) :));
   if (_office->query_employee(this_player()->query_name()) ||
     this_player()->query_creator())
   {
      add_command("log",
        "shop {bought|sold} <number> <string'item(s)'> for <word'amount'>",
        (: do_log($4) :));
      add_command("correction",
        "shop {bought|sold} <number> <string'item(s)'> for <word'amount'>",
        (: do_correction($4) :));
   }
}
int action(string str)
{
   string st1;
   if (_office->query_employee(this_player()->query_name()) ||
     this_player()->query_creator())
     return 0;
   sscanf(str,"%s %s",str,st1);
   if(str == "get" || str == "take")
      if (strsrch(st1, "register") != -1)
      {
         tell_object(this_player(), "You are not an active employee here!\n");
         return 1;
      }
   return 0;
}
void add_money_ob(object money)
{
   if (previous_object() && previous_object() != find_object(_office))
   {
      LOG_ERROR("counter.c", "add_money_ob()");
      return;
   }
   if (!money) return;
   money->move( _register );
   save_register(TRUE);
}
int adjust_register(string player, int amount)
{
   int value;
   object cash, change;
   if (previous_object() && previous_object() != find_object(_office))
   {
      LOG_ERROR("counter.c", "adjust_register(" + player+","+amount+")");
      return 0;
   }
   if (amount < 0) return 0;
   cash = present(MONEY_ALIAS, _register);
   if ( !cash ) return 0;
   _money = cash->query_money_array() + ({});
   value = MONEY_HAND->query_total_value(_money, _place);
   if (value < amount) amount = value;
   change = MONEY_HAND->pay_amount_from( amount, cash, _place );
   if (change) change->move( _register );
   _office->shop_log(ACCOUNTS, player, "adjusted the register by "+
     MONEY_HAND->money_value_string(amount, _place), UNPAID);
   save_register(TRUE);
   return amount;
}
string directions_to(string place)
{
   if (place == _storeroom) return _store_dir;
   if (place == _office) return _office_dir;
   if (place == _shop_front) return _shop_dir;
   return "here";
}
private int do_calc(int a, string sign, int b)
{
   int c = 0;
   string result = a+ " "+ sign+ " "+ b+ " = ",
          temp;
   switch (sign)
   {
     case "+" :
        result += sprintf("%d\n", a+b);
        break;
     case "-" :
        result += sprintf("%d\n", a-b);
        break;
     case "*" :
        result += sprintf("%d\n", a*b);
        break;
     case "/" :
        if (!b)
        {
           tell_object( this_player(),
             "Trying to divide by zero?  Whatever next?\n");
           return 1;
        }
        if (a % b) c = ((a%b) * 100)/b;
        temp = sprintf("%02d",c);
        result += sprintf("%d.%s\n", a/b, temp[0..1]);
        break;
   }
   tell_object(this_player(), result);
   add_succeeded_mess("$N use$s the calculator.\n");
   return 1;
}
private int do_correction(mixed *args)
{
   _office->shop_log(LOG_ENTRY, this_player()->query_name(),
     "ERROR IN LOG - correct entry follows:", UNPAID);
   _office->shop_log(LOG_ENTRY, this_player()->query_name(),
     args[0]+ " "+ args[1]+ " "+ args[2]+ " for "+ args[3], UNPAID);
   add_succeeded_mess("$N make$s a correction in the transaction log book.\n");
   return 1;
}
private int do_log(mixed *args)
{
   _office->shop_log(LOG_ENTRY, this_player()->query_name(),
     args[0]+ " "+ args[1]+ " "+ args[2]+ " for "+ args[3], PAID);
   add_succeeded_mess("$N make$s an entry in the transaction log book.\n");
   return 1;
}
void event_death(object k, object *o, object k2, string r, string k3)
{
   _office->event_death(k, o, k2, r, k3);
}
void event_enter(object ob, string message, object from)
{
   _office->event_enter(ob, message, from);
}
int query_register()
{
   object cash = present(MONEY_ALIAS, _register);
   if (!cash) return 0;
   _money = cash->query_money_array() + ({});
   return MONEY_HAND->query_total_value(_money, _place);
}
private void save_me(string name)
{
   int difference;
   object cash;
   mixed *old = _money + ({});
   if (!_register) return;
   cash = present(MONEY_ALIAS, _register);
   if (!cash) _money = ({});
   else _money = (mixed *)cash->query_money_array() + ({});
#ifdef DEBUG
   tell_creator(CREATOR, "Register contains: %O.\n", _money);
#endif
   _office->save_register(_money);
   difference = MONEY_HAND->query_total_value(_money, _place) -
     MONEY_HAND->query_total_value(old, _place);
   if (!difference) return;
   _office->adjust_takings(difference);
   if (!name || name == "") return;
   if (difference < 0)
      _office->shop_log(PURCHASE, name, "removed "+
        MONEY_HAND->money_value_string(-difference, _place)+
        " from register", UNPAID);
   else
      _office->shop_log(SALE, name, "added "+
        MONEY_HAND->money_value_string(difference, _place)+
        " to register", UNPAID);
}
void save_register(int no_player)
{
   remove_call_out(_call_save);
   _call_save = call_out((: save_me($((!no_player)?
      this_player()->query_name():"shop")) :), 1);
}
protected void set_directions(string office, string storeroom, string shop)
{
   _office_dir = office;
   _store_dir = storeroom;
   _shop_dir = shop;
}
protected void set_long(string long_desc)
{
   long_desc += "Employees of the shop can \"log\" transactions or "
     "\"correction\"s here.  The shop's cash register is under the "
     "counter and there is a calculator next to that.\n";
   ::set_long(long_desc);
}
protected void set_office(string path)
{
   object cash;
   _office = path;
   _storeroom = _office->query_storeroom();
   _mgr_office = _office->query_mgr_office();
   _shop_front = _office->query_shop_front();
   _place = _office->query_place();
   if (_register) return;
   _register = clone_object("/obj/misc/cash_register");
   _register->set_name("register");
   _register->set_short("cash register");
   _register->add_adjective("cash");
   _register->set_long("The cash register is really just an iron drawer "
     "mounted underneath the counter.  In a certain light, it almost "
     "seems tongue-shaped.\n");
   _register->set_shop(this_object());
   add_hidden_object(_register);
   _register->reset_get();
   _money = _office->restore_register();
   if (!_money || !sizeof(_money)) return;
   cash = clone_object(MONEY_OBJECT);
   cash->set_money_array(_money);
   cash->move(_register);
}

==================================================
FILE: shops/player_shop/mgr_office.c
==================================================

inherit "/std/room/basic_room";
#include <player_shop.h>
#include <mail.h>
#include <move_failures.h>
#include <money.h>
#include "patterns.h"
private nosave string _office = "",
_place = "",
_shop_front = "",
_counter = "",
_storeroom = "";
private nosave object _notice = 0;
private string cap_name(string);
private int do_accounts();
private int do_ban(mixed *);
private int do_check();
private int do_claim();
private int do_commend(string);
private int do_demote(string);
private int do_fire(mixed *);
private int do_leave(mixed *);
private int do_list(mixed *);
private int do_logs(mixed *, string);
private int do_mail(string);
private int do_memo();
private int do_office();
private int do_policies();
private int do_policy(mixed *,string);
private int do_project(string);
private int do_query(string);
private int do_remove();
private int do_rent();
private int do_retire();
private int do_set(mixed *, string);
private int do_suspend(mixed *);
private int do_transfer(mixed *);
private int do_unban(string);
private int do_view(string,string);
private int do_vote(mixed *, string);
private int do_warn(mixed *);
private void end_memo(string,string);
private void end_policy_suggest(string,string,int);
private void send_memo(string, string, string);
protected void set_office(string);
private void write_memo(string);
void create()
{
    do_setup++;
    ::create();
    do_setup--;
    add_property("determinate", "");
    if (!do_setup)
    {
        this_object()->setup();
        this_object()->reset();
    }
    add_help_file("player_shop_mgr_office");
}
void init()
{
    ::init();
    if (!_office || _office == "") return;
    if ( !_office->query_manager(this_player()->query_name()) &&
      !_office->query_retired(this_player()->query_name()) &&
      !this_player()->query_creator()) return;
    add_command("list", ({LIST_BLANK, LIST_CHOICE}),
      (: do_list($4) :));
    add_command("memo", "", (: do_memo() :));
    add_command("office", "", (: do_office() :));
    add_command("claim", "", (: do_claim() :));
    add_command("accounts", "", (: do_accounts() :));
    add_command("logs", ({LOG_BLANK, LOG_NUMBER, LOG_MGR}),
      (: do_logs($4,$5) :));
    add_command("mail", ({"", "<string>"}), (: do_mail($4) :));
    add_command("query", "{pay|employees}", (: do_query($4[0]) :));
    add_command("view", ({VIEW_EMP, VIEW_APP}), (: do_view($4[0],$5) :));
    add_command("project", "{pay|bonus}", (: do_project($4[0]) :));
    add_command("vote", VOTE_POLICY, (: do_vote($4,$5) :));
    add_command("policy", ({POLICY_SUGGEST, POLICY_REMOVE}),
      (: do_policy($4,$5) :));
    add_command("policies", "", (: do_policies() :));
    if (_office->query_retired(this_player()->query_name())) return;
    add_command("rent", "cabinet", (: do_rent() :));
    add_command("remove", "cabinet", (: do_remove() :));
    add_command("retire", "", (: do_retire() :));
    add_command("vote", VOTE_APPLICANT, (: do_vote($4,$5) :));
    add_command("check", "votes", (: do_check() :));
    add_command("commend", "<word'employee'>", (: do_commend($4[0]) :));
    add_command("fire", "<word'employee'> [for] <string'reason'>",
      (: do_fire($4) :));
    add_command("warn", "<word'employee'> [for] <string'reason'>",
      (: do_warn($4) :));
    add_command("demote", "<word'employee'>", (: do_demote($4[0]) :));
    add_command("suspend", "<word'employee'> [for] <number> [months]",
      (: do_suspend($4) :));
    add_command("leave", "<word'employee'> [for] <number> [days]",
      (: do_leave($4) :));
    add_command("ban", "<word'person'> [for] <string'reason'>",
      (: do_ban($4) :));
    add_command("unban", "<word'person'>", (: do_unban($4[0]) :));
    add_command("set", ({SET_EMPS, SET_PAY}), (: do_set($4,$5) :));
    add_command("transfer", "<number'amount'> <string'type'> [from] "
      "{register|bonus|profit} [to] {register|bonus|profit}",
      (: do_transfer($4) :));
}
private string cap_name(string name)
{
    if (test_player(name))
        return PLAYER_HANDLER->query_cap_name(name);
    else return capitalize(name);
}
void dest_me()
{
    if (_notice) _notice->dest_me();
    ::dest_me();
}
private int do_accounts()
{
    tell_object(this_player(), "The shop's accounts are as follows:\n"+
      sprintf("   Cash   : %s\n   Bonus  : %s\n   Profit : %s\n",
        MONEY_HAND->money_value_string(_counter->query_register(), _place),
        MONEY_HAND->money_value_string(_office->query_bonus(), _place),
        MONEY_HAND->money_value_string(_office->query_profit(), _place)));
    return 1;
}
private int do_ban(mixed *args) { return _office->do_ban(args); }
private int do_check()
{
    string results,
    name = this_player()->query_name();
    mapping applicants;
    add_succeeded_mess("");
    applicants = _office->get_applicants();
    applicants = filter(applicants, (: $(applicants)[$1][APP_TYPE] == 1 :));
    if (this_player()->query_creator())
    {
        results = "The following votes have been cast:\n\n";
        foreach (string word in sort_array(keys(applicants), 1))
        {
            results += cap_name(word)+ " - applied " +
            ctime(applicants[word][APP_TIME] )+ "\n   Votes for:     ";
            foreach (string vote in applicants[word][APP_FOR])
            results += cap_name(vote) + "  ";
            results += "\n   Votes against: ";
            foreach (string vote in applicants[word][APP_AGAINST])
            results += cap_name(vote) + "  ";
            results += "\n   Abstentions:   ";
            foreach (string vote in applicants[word][APP_ABSTAIN])
            results += cap_name(vote) + "  ";
            results += "\n\n";
        }
        tell_object(this_player(), "$P$Votes cast$P$"+ results);
        return 1;
    }
    results = "You have cast the following votes:\n\nFor: ";
    foreach (string vote in sort_array(keys(applicants), 1))
    if (member_array(name, applicants[vote][APP_FOR]) != -1)
        results += cap_name(vote)+ "  ";
    results += "\nAgainst: ";
    foreach (string vote in sort_array(keys(applicants), 1))
    if (member_array(name, applicants[vote][APP_AGAINST]) != -1)
        results += cap_name(vote)+ "  ";
    results += "\nAbstentions: ";
    foreach (string vote in sort_array(keys(applicants), 1))
    if (member_array(name, applicants[vote][APP_ABSTAIN]) != -1)
        results += cap_name(vote)+ "  ";
    tell_object(this_player(), results + "\n");
    return 1;
}
private int do_claim()
{
    object thing;
    if (!_office || _office == "") return 0;
    thing = clone_object(MGR_BOOK);
    thing->set_read_mess("\n   "+ _office->query_shop_name()+ "\n\n"
      "   Manager's Handbook\n\n   This handbook belongs to: "+
      this_player()->query_short()+ "\n\n", "common", 100);
    thing->set_office(_office);
    if (thing->move(this_player()) != MOVE_OK)
    {
        thing->move(this_object());
        tell_object(this_player(),
          "You drop your handbook as you're carrying too much.\n");
    }
    add_succeeded_mess("$N $V a new handbook.\n");
    return 1;
}
private int do_commend(string emp) { return _office->do_commend(emp); }
private int do_demote(string emp) { return _office->do_demote(emp); }
private int do_fire(mixed *args) { return _office->do_fire(args); }
private int do_leave(mixed *args) { return _office->do_leave(args); }
private int do_list(mixed *args)
{
    string results, word;
    mapping baddies, applicants;
    string *applied, *hired, *awaiting;
    if (!sizeof(args)) args = ({"employees"});
    add_succeeded_mess("");
    switch (args[0])
    {
    case "applicants" :
        results = "      Applications for employment as at " +
        ctime(time()) + "\n\n";
        applicants = _office->get_applicants();
        if (!applicants || applicants == ([]))
        {
            tell_object(this_player(), results+
              "No applications outstanding.\n");
            return 1;
        }
        applied = sort_array(keys(filter(applicants,
              (: $(applicants)[$1][APP_TYPE] == APPLIED :))),
          (: $(applicants)[$1][APP_TIME] - $(applicants)[$2][APP_TIME] :));
        hired = sort_array(keys(filter(applicants,
              (: $(applicants)[$1][APP_TYPE] == HIRED :))),
          (: $(applicants)[$1][APP_TIME] - $(applicants)[$2][APP_TIME] :));
        awaiting = sort_array(keys(filter(applicants,
              (: $(applicants)[$1][APP_TYPE] == AWAITING :))),
          (: $(applicants)[$1][APP_TIME] - $(applicants)[$2][APP_TIME] :));
        if ( sizeof(awaiting))
        {
            results += "Applicants awaiting vacancies:\n";
            foreach (word in awaiting)
            results += "     "+ cap_name(word)+
            " - confirmed employment " +
            ctime(applicants[word][1])+ "\n";
            results += "\n";
        }
        if (sizeof(hired))
        {
            results += "Applicants yet to confirm their employment:\n";
            foreach (word in hired)
            results += "     "+ cap_name(word)+ " - voted in " +
            ctime(applicants[word][1])+ "\n";
            results += "\n";
        }
        if (sizeof(applied))
        {
            results += "Applicants yet to be hired or rejected.  Vote now!\n";
            foreach (word in applied)
            {
                results += "     "+ cap_name(word)+ " - applied " +
                ctime(applicants[word][1])+ "\n";
                results += sprintf("     %-12s%-5d%-16s%-5d%-13s%-5d\n",
                  "Votes for:", sizeof(applicants[word][APP_FOR]),
                  "Votes against:", sizeof(applicants[word][APP_AGAINST]),
                  "Abstentions:", sizeof(applicants[word][APP_ABSTAIN]));
            }
        }
        tell_object(this_player(), "$P$Applications list$P$"+ results);
        break;
    case "baddies" :
        if (!m_sizeof(baddies = _office->get_baddies()))
        {
            tell_object(this_player(),
              "There are no people on the list at the moment.\n");
            return 1;
        }
        results = "This is a list of people banned from the shop:\n\n";
        foreach (word in sort_array(keys(baddies), 1))
        {
            results += cap_name(word)+ " banned by "+
            baddies[word][BAD_BANNER]+ " on "+
            ctime(baddies[word][BAD_TIME] )+ ".\n   Banned for "+
            baddies[word][BAD_REASON]+ ".\n\n";
        }
        tell_object(this_player(), "$P$Baddies$P$\n"+ results);
        break;
    default :
        return _office->do_list();
    }
    return 1;
}
private int do_logs(mixed *args, string pattern)
{
    return _office->do_logs(args, pattern);
}
private int do_mail(string words) { return MAIL_TRACK->mail(words); }
private int do_memo()
{
    tell_object(this_player(), "Subject: (hit enter for general memo)\n");
    input_to((: write_memo($1) :), 0);
    add_succeeded_mess("");
    return 1;
}
private int do_office()
{
    int retired = _office->query_retired(this_player()->query_name());
    string result = (retired)?
    "As a retired manager, you can use the following commands:\n":
    "As a manager, you can use the following commands:\n";
    result +=
    "   accounts  - view register, bonus & profit accounts\n"
    "   claim     - claim a manager's handbook\n"
    "   list      - list employees, applicants or banned people\n"
    "   logs      - review the shop's logs\n"
    "   mail      - read / send mail\n"
    "   memo      - send a message to the other managers\n"
    "   policy    - suggest a new (or remove an old) policy for the shop\n"
    "   policies  - check on the proposed policies\n"
    "   project   - view anticipated paypacket & bonus values\n"
    "   query     - query pay amount or number of employees\n"
    "   view      - view a person's history with this shop\n"
    "               or an applicant's application form\n"
    "   vote      - vote for a policy to be implemented into the shop\n";
    if (!retired)
        result +=
        "               or for an applicant to work for the shop\n"
        "   (un)ban   - (un)ban a person from the shop for "+
        BAN_LENGTH+ " days\n"
        "   rent      - rent storeroom cabinets\n"
        "   remove    - remove storeroom cabinets\n"
        "   check     - check votes you have made on applications\n"
        "   commend   - reward an outstanding employee\n"
        "   demote    - demote an employee\n"
        "   fire      - end someone's employment\n"
        "   leave     - place an employee on leave for up to "+
        MAX_LEAVE+ " days\n"
        "   retire    - end your active employment at the shop\n"
        "   set       - set number of employees, and pay amount\n"
        "   suspend   - suspend an employee's bonus entitlement\n"
        "   transfer  - transfer money between register, bonus & profit\n"
        "   warn      - issue a formal warning to an employee\n";
    tell_object(this_player(), result+ "\n");
    add_succeeded_mess("");
    return 1;
}
private int do_policies()
{
    mapping policies = _office->get_new_policies();
    if (!m_sizeof(policies))
        tell_object(this_player(), "There are no policies awaiting sanction.\n");
    else
    {
        int i = 1;
        tell_object(this_player(), "The following policies have been suggested."
          "  Policies in existence are proposed to be overturned.\n");
        foreach(string policy in m_indices(policies))
        tell_object(this_player(), sprintf("%d. %s - %s [%s]. %s\n", i++,
            (policies[policy][POLICY_TYPE])?"MGR":"EMP", policy,
            policies[policy][POLICY_MGR], policies[policy][POLICY_TEXT]));
    }
    return 1;
}
private int do_policy(mixed *args, string pattern)
{
    string *managers, mgr;
    if (pattern == POLICY_SUGGEST)
    {
        if (_office->query_policy(args[1]))
        {
            tell_object(this_player(), "This name is already in use.\n");
            return 1;
        }
        this_player()->do_edit(0, (: end_policy_suggest($1,
              $(lower_case(args[1])),$((args[0] == "manager")?1:0)) :));
        add_succeeded_mess("");
        return 1;
    }
    if (_office->query_policy(args[0]) < 2)
    {
        tell_object(this_player(), "This policy does not exist.\n");
        return 1;
    }
    args[0] = lower_case(args[0]);
    tell_object(this_player(), "You suggest that the "+ args[0]+
      " policy should be removed.\n");
    mgr = this_player()->query_name();
    managers = _office->get_managers();
    managers += _office->get_retired();
    managers += ({_office->query_creator()});
    managers -= ({mgr});
    AUTO_MAILER->auto_mail(implode(managers, ","),
      mgr, "TFQC policy suggestion",
      "", "Please note that I would like you to vote on removing the "+
      args[0]+ " policy.\n", 0, 0);
    _office->add_policy_suggest(args[0], "", mgr);
    return 1;
}
private int do_project(string projection)
{
    add_succeeded_mess("");
    switch (projection)
    {
    case "bonus" :
        _office->calc_bonus();
        break;
    case "pay" :
        tell_object(this_player(),
          "For the month to date, the staff wages total "+
          MONEY_HAND->money_value_string( _office->calc_pay(),
            _place)+ ".\n");
        break;
    }
    return 1;
}
private int do_query(string query)
{
    add_succeeded_mess("");
    switch(query)
    {
    case "pay" :
        tell_object(this_player(), "The pay is currently set at "+
          MONEY_HAND->money_value_string(_office->query_pay(),
            _place)+ ".\n");
        break;
    case "employees" :
        tell_object(this_player(),
          "The maximum number of employees is currently "+
          _office->query_maxemp()+ ".\n");
        break;
    default :
    }
    return 1;
}
private int do_remove() { return _office->do_remove(); }
private int do_rent() { return _office->do_rent(); }
private int do_retire() { return _office->do_retire(); }
private int do_set(mixed *args, string pattern)
{
    return _office->do_set(args, pattern);
}
private int do_suspend(mixed *args) { return _office->do_suspend(args); }
private int do_transfer(mixed *args) { return _office->do_transfer(args); }
private int do_unban( string person ) { return _office->do_unban(person); }
private int do_view(string person, string pattern)
{
    _office->view_record(person, pattern);
    return 1;
}
private int do_vote(mixed *args, string pattern)
{
    return _office->do_vote(args, pattern);
}
private int do_warn(mixed *args) { return _office->do_warn(args); }
private void end_memo(string text, string subject)
{
    if (!text)
    {
        tell_object(this_player(), "Aborted.\n");
        return;
    }
    tell_object(this_player(),
      "Do you want to keep a copy of the memo? ");
    input_to((: send_memo($1,$(subject),$(text)) :), 0);
}
private void end_policy_suggest(string text, string name, int type)
{
    string mgr, *managers;
    if (!text)
    {
        tell_object(this_player(), "Aborted.\n");
        return;
    }
    text = replace_string(text, "\n", " ");
    text = replace_string(text, "  ", " ");
    mgr = this_player()->query_name();
    managers = _office->get_managers();
    managers += _office->get_retired();
    managers += ({_office->query_creator()});
    managers -= ({lower_case(mgr)});
    AUTO_MAILER->auto_mail(implode(managers, ","),
      mgr, _office->shop_very_short()+ " policy suggestion",
      "", "Please note that there is a new policy, "+ name+
      ", on which I would like you to vote.\n", 0, 0);
    _office->add_policy_suggest(name, text, mgr, type);
}
void event_death(object k, object *o, object k2, string r, string k3)
{
    _office->event_death(k, o, k2, r, k3);
}
void event_enter(object ob, string message, object from)
{
    _office->event_enter(ob, message, from);
}
private void send_memo(string ans, string subject, string text)
{
    string *managers;
    ans = lower_case(ans);
    if (strlen(ans) < 1 || (ans[0] != 'y' && ans[0] != 'n'))
    {
        tell_object(this_player(),
          "Do you want to keep a copy of the memo? (Yes or No)? ");
        input_to((: send_memo($1,$(subject),$(text)) :), 0);
        return;
    }
    managers = _office->get_managers();
    managers += _office->get_retired();
    if ( this_player()->query_creator() &&
      this_player()->query_name() != _office->query_creator())
        managers += ({lower_case(this_player()->query_name())});
    managers += ({_office->query_creator()});
    if ( ans[0] == 'n' )
        managers -= ({lower_case(this_player()->query_name())});
    if (!sizeof(managers))
    {
        tell_object(this_player(), "\nNo recipients!\n");
        return;
    }
    tell_object(this_player(), "\nSending your memo.\n");
    subject = (subject && subject != "")?" - "+ subject:"";
    AUTO_MAILER->auto_mail(implode(managers, ","),
      this_player()->query_name(), _office->shop_very_short()+
      " manager memo" + subject, "", text, 0, 0);
}
protected void set_long(string long_desc)
{
    long_desc += "Managers can use their own \"office\" commands "
    "from in here.  There is a management policy notice on the wall.\n";
    ::set_long( long_desc );
}
protected void set_office(string path)
{
    _office = path;
    _place = _office->query_place();
    _shop_front = _office->query_shop_front();
    _counter = _office->query_counter();
    _storeroom = _office->query_storeroom();
    _notice = clone_object(SHOP_NOTICE);
    _notice->set_office(_office);
    _notice->set_type(1);
    add_hidden_object(_notice);
}
private void write_memo(string text)
{
    this_player()->do_edit(0, (: end_memo($1,$(text)) :));
}

==================================================
FILE: shops/player_shop/office.c
==================================================

inherit "/std/room/basic_room";
#include <player_shop.h>
#include <mail.h>
#include <board.h>
#include <money.h>
#include <move_failures.h>
#include <refresh.h>
#include "office.h"
private nosave string _proprietor = UNSET_STR,
                      _shop_name = UNSET_STR,
                      _very_short = UNSET_STR,
                      _place = UNSET_STR,
                      _channel = UNSET_STR,
                      _storeroom = "",
                      _shop_front = "",
                      _counter = "",
                      _mgr_office = "",
                      _store_dir = "",
                      _counter_dir = "",
                      _shop_dir = "",
                      _shopkeeper = "",
                      _stock_policy = "",
                      _cab_name = "",
                      _review_month = "",
                      _savedir = "",
                      _creator = CREATOR;
private nosave object _chart = 0,
                      _board = 0,
                      _notice = 0;
private nosave mapping _history = 0,
                       _applicants = 0,
                       _policies = 0,
                       _new_policies = 0,
                       _list = ([]),
                       _times = ([]),
                       _employees = ([]);
private nosave int _call_save = 0,
                   _call_hist = 0,
                   _call_hist_clear = 0,
                   _call_times = 0,
                   _call_hire_list = 0,
                   _call_mail_hirees = 0,
                   _call_summon = 0,
                   _call_emps = 0,
                   _call_review = 0,
                   _call_apps = 0,
                   _call_apps_clear = 0,
                   _call_pols = 0,
                   _call_pols_clear = 0,
                   _call_newpols = 0,
                   _call_newpols_clear = 0;
private string *_retired = ({}),
               *_got_bonus = ({}),
               _last_month = "last month",
               _eom = CREATOR;
private mapping _baddies = ([]),
                _declined = ([]),
                _accounts = (["profit":0,"bonus":0]);
private int _max_emp = MAX_EMP,
            _bonus_val = 0,
            _bonus = 0,
            _pay_val = 4,
            _num_cabinets = MIN_CABINETS,
            _net_takings = 0;
private mixed *_register = ({});
void create()
{
   do_setup++;
   ::create();
   do_setup--;
   if (!do_setup)
   {
      this_object()->setup();
      this_object()->reset();
   }
   seteuid("Room");
   add_property("determinate", "");
   add_help_file("player_shop_office");
}
#include "office_code/admin.c"
#include "office_code/applications.c"
#include "office_code/baddies.c"
#include "office_code/cabinets.c"
#include "office_code/emp_cmd.c"
#include "office_code/lists.c"
#include "office_code/logging.c"
#include "office_code/masked.c"
#include "office_code/memo.c"
#include "office_code/personnel.c"
#include "office_code/policies.c"
#include "office_code/review.c"
#include "office_code/save.c"
#include "office_code/stock.c"
protected void add_manager_exit(string dir, string path)
{
   add_exit(dir, path, "door");
   modify_exit(dir, ({"function", ({this_object(),
     "check_manager"}), "door short", "office door", "door long",
     "There is a sign on the door which reads: \""+ _proprietor+
     "- Private\".\n"}));
   _mgr_office = path;
}
mapping get_applicants()
{
   load_applicants();
   clear_applicants();
   return copy(_applicants + ([]));
}
mapping get_baddies() { return copy(_baddies + ([])); }
string *get_employees()
{
   string *employees = m_indices(_employees);
   foreach (string word in employees)
      if (_employees[word][EMP_POINTS] & SUPERVISOR)
         employees -= ({word});
   return copy(sort_array(employees, 1));
}
string *get_managers()
{
   return copy(sort_array(keys(filter(_employees,
        (: _employees[$1][EMP_POINTS] & MANAGER :))), 1));
}
mapping get_new_policies()
{
   load_new_policies();
   clear_new_policies();
   return copy(_new_policies);
}
mapping get_policies(int type)
{
   load_policies();
   clear_policies();
   if (type)
      return copy(filter(_policies, (: _policies[$1][1] :)));
   else
      return copy(filter(_policies, (: !_policies[$1][1] :)));
}
string *get_retired() { return copy(sort_array(_retired, 1)); }
string *get_supervisors()
{
   string *supervisors = keys(filter(_employees,
        (: _employees[$1][EMP_POINTS] & SUPERVISOR :)));
   foreach (string word in supervisors)
      if (_employees[word][EMP_POINTS] & MANAGER)
         supervisors -= ({word});
   return copy(sort_array(supervisors, 1));
}
int num_employees_in()
{
   int any = 0;
   foreach (string word in m_indices(_employees))
      if (_employees[word][EMP_POINTS] & CLOCKED_IN)
      {
         if (_employees[word][EMP_POINTS] & NPC) continue;
         if (!find_player(word) || !interactive(find_player(word)))
         {
            reset_employee(word, CLOCKED_IN);
            shop_log(GENERAL, word, "was clocked out", UNPAID);
         }
         else any++;
      }
   return any;
}
int query_applicant(string player)
{
   load_applicants();
   clear_applicants();
   if (!sizeof(_applicants)) return FALSE;
   if (_applicants[player]) return copy(_applicants[player][APP_TYPE]);
   return FALSE;
}
int query_baddie(string player)
{
   if (!m_sizeof(_baddies)) return FALSE;
   if (_baddies[player]) return copy(_baddies[player][BAD_TIME]);
   return FALSE;
}
int query_bonus() { return copy(_accounts["bonus"]); }
string query_channel() { return copy(_channel); }
string query_counter() { return copy(_counter); }
void query_creator(string creator) { return copy(_creator); }
int query_declined(string player)
{
   if (!sizeof(_declined)) return FALSE;
   if (_declined[player]) return copy(_declined[player]);
   return FALSE;
}
int query_employee(string player)
{
   if (_employees[player]) return copy(_employees[player][EMP_POINTS]);
   return FALSE;
}
mapping query_employees() { return copy(_employees + ([])); }
string *query_list_array() { return copy(m_indices(_list) + ({})); }
mapping query_list_mapping() { return copy(_list) + ([]); }
string query_list_string()
{
   if (!m_sizeof(_list)) return "absolutely nothing at the moment";
   return query_multiple_short(m_indices(_list));
}
int query_manager(string player)
{
   if (_employees[player]) return (_employees[player][EMP_POINTS] & MANAGER);
   return FALSE;
}
int query_maxemp() { return copy(_max_emp); }
string query_mgr_office() { return copy(_mgr_office); }
int query_num_cabinets() { return copy(_num_cabinets); }
int query_pay() { return copy(_pay_val); }
string query_place() { return copy(_place); }
int query_policy(string policy)
{
   load_policies();
   clear_policies();
   if (m_sizeof(_policies) && _policies[policy]) return 2;
   load_new_policies();
   clear_new_policies();
   if (m_sizeof(_new_policies) && _new_policies[policy]) return 1;
   return 0;
}
int query_profit() { return copy(_accounts["profit"]); }
string query_proprietor() { return copy(_proprietor); }
int query_retired(string player)
{
   return (member_array(player, _retired) == -1)?FALSE:TRUE;
}
string query_savedir() { return copy(_savedir); }
string query_shop_front() { return copy(_shop_front); }
string query_shop_name() { return copy(_shop_name); }
string query_shopkeeper() { return copy(_shopkeeper); }
int query_stock(string items) { return _storeroom->query_num_items(items, 0); }
string query_storeroom() { return copy(_storeroom); }
int query_supervisor(string player)
{
   if (_employees[player])
      return (_employees[player][EMP_POINTS] & SUPERVISOR);
   return FALSE;
}
protected void save_emps()
{
   if (_very_short == UNSET_STR) return;
   remove_call_out(_call_emps);
   _call_emps = call_out((: do_save_emps() :), SAVE_DELAY);
}
protected void save_me()
{
   if (_very_short == UNSET_STR) return;
   remove_call_out(_call_save);
   _call_save = call_out((: do_save() :), SAVE_DELAY);
}
protected void set_channel(string name, int board)
{
   _channel = lower_case(name);
   if (board)
   {
      _board = clone_object("/obj/misc/board");
      _board->set_datafile(name);
      _board->move(this_object());
   }
}
protected void set_counter(string path) { _counter = path; }
protected void set_creator(string creator) { _creator = creator; }
protected void set_directions(string store, string counter, string shop)
{
   _store_dir = store;
   _counter_dir = counter;
   _shop_dir = shop;
}
protected void set_place(string place) { _place = place; }
protected void set_proprietor(string name) { _proprietor = name; }
protected void set_shop_front(string path) { _shop_front = path; }
protected void set_shop_name(string name) { _shop_name = name; }
protected void set_shopkeeper(string path)
{
   _shopkeeper = path;
   path=_shopkeeper->query_name();
   if (!_employees || !_employees[path])
   {
      _employees += ([path:EMP_MAP]);
      _employees[path][EMP_POINTS] = EMPLOYEE + NPC;
   }
}
protected void set_storeroom(string path) { _storeroom = path; }
protected void set_stock_policy(string desc) { _stock_policy = desc; }
protected void set_very_short(string name)
{
   if (PLAYER_SHOP->query_shop(name) != file_name(this_object()))
      return;
   _very_short = name;
   _savedir = sprintf("/save/player_housing/%s/player_shops/%s/",
      lower_case(geteuid(this_object())), name);
   if (file_size(_savedir+ "shop_data.o") > 0)
      unguarded((: restore_object, _savedir+ "shop_data" :));
   if (file_size(_savedir+ "employees") > 0)
      _employees = restore_variable(unguarded((: read_file,
        _savedir+ "employees" :)));
   if (file_size(_savedir+ "times") > 0)
      _times = restore_variable(unguarded((: read_file,
      _savedir+ "times" :)));
   if (file_size(_savedir+ "list") > 0)
      _list = restore_variable(unguarded((: read_file, _savedir+ "list" :)));
}
string shop_very_short() { return copy(_very_short); }
