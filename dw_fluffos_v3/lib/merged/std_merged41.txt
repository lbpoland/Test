# Total Tokens: 19085
# Total Files Merged: 9
# Total Characters: 63646

ew_inherit.c
==================================================

#include <player_handler.h>
#include <mail.h>
#define LORD capitalize (load_object ("/d/" + query_domain() + "/master")->query_lord())
#define SECURE "/d/" + query_domain() + "/secure/"
#define SAVE query_interview_dir() + "candidate_list"
#define LOG query_interview_dir() + "candidate_log.txt"
#define EVENTS "/global/events"
#define DEBUG 1
inherit "/std/room";
int add_creator (string);
int do_add (string);
int do_confirm (string);
int do_flag (string, string);
varargs int do_interview (object, string);
int do_query_text(string);
int do_list();
int do_read (string);
int flush();
int query_allowed_creators();
int query_interview();
int remove_candidate (string);
int remove_creator (string);
int remove_interviewed (string);
int set_interview_dir (string);
int set_part_two (string);
int query_part_two_required();
void set_acceptance(string);
void set_confirmation(string);
void set_rejection(string);
void set_interview (int);
void set_subject (string);
void set_interviewer(mixed);
void set_cc (string*);
string query_acceptance();
string query_applicants_text();
string query_cc();
string query_confirmation();
string query_domain();
string query_interview_dir();
string query_part_two();
string query_rejection();
string query_subject();
private nosave int _interview;
private nosave int _pt_two = 1;
private nosave string _acceptance_text;
private nosave string _confirmation_text;
private nosave string _domain;
private nosave string _filename;
private nosave string _interview_dir;
private nosave string _rejection_text;
private nosave string _subject;
private nosave string *_int;
private string *_allowed_creators = ({ });
private string *candidates = ({ });
private string *_cc = ({ });
private string *interviewed = ({ });
private string *submitted = ({ });
private string *accepted = ({ });
private string *rejected = ({ });
nosave string *movie = ({
  "First of all, I'd like to congratulate you for getting this far with the "
  "application process.  The second part of the application, in addition to "
  "testing descriptive and coding skills, is also designed to help weed out "
  "those who aren't really serious about becoming creators.  :-)",
  "I should make it clear at this point that getting this far doesn't mean "
  "that you're guaranteed a promotion.  We just want to get a fuller "
  "appreciation of applicants before we reach a decision on whether you are "
  "to be promoted or not.  :-)",
  "Being a creator, regardless of the rumours or jokes to the contrary, is "
  "not an easy option.  Unlike many MUDs, being a creator on " + mud_name() + " is "
  "not the same as early retirement.  You'll be expected to spend time "
  "coming to terms with the mudlib (the body of code that is used to "
  "create the MUD) and your domain (the areas you actually adventure "
  "in).  As a creator, you have considerable power over large segments of "
  "the MUD.  The important thing is learning how to use that power "
  "responsibly.",
  "We have a number of strict rules on " + mud_name() + " .. rules you should be "
  "aware of before you make any decisions as to whether the role is for "
  "you.  Creators aren't allowed to affect the game in any measurable "
  "way.  Chatting is fine... killing NPCs at random or indiscriminately "
  "cloning cash for players is not.",
  "Being a creator is also not about policing the " + mud_name() + "   That falls "
  "under the jurisdiction of Admin and the Liaison domain.  As a coding "
  "creator your responsibilities lie in dealing with the code that "
  "makes up the MUD.  It is quite common that you will be approached by "
  "players with questions, particularly when they are no liaisons "
  "online.  In cases such as this, you are expected to refer them to "
  "a liaison or a Director.  If none are online, you are expected to ask "
  "them to wait until one is.",
  "In rare cases, it will be necessary for immediate action to be "
  "taken... in such cases, it may be acceptable for you to deal with a "
  "player problem yourself.  Always keep in mind however that you are "
  "here to code.  If it is liaising and player interaction that you think "
  "you would enjoy most, it would be best to consider an application "
  "instead to the Liaison domain.",
  "There is also a stern security policy on " + mud_name() + "   As a creator, you "
  "are expected not to violate this policy.  This means:  No passing "
  "creator information on to players, and no revealing what is posted on "
  "creator boards.   As a creator you have access to a lot of information "
  "players do not... this information should be treated as confidential "
  "unless you have Express Permission from your Leader that you may reveal "
  "it.  In short, we have to be able to trust you with sensitive "
  "information.",
  "The most important thing to remember is that you are expected to "
  "create.  If all you're really interested in is coding toys, then this "
  "role is not for you.  " + mud_name() + " is not strict in the sense of 'You have "
  "to code X rooms per day!', but you are expected to make a measurable "
  "and consistent contribution to your domain.  Your Leader and the "
  "deputy immediately supervising you will check up on this on a "
  "regular basis.",
  "It may sound like an awful lot of work to be a creator... and it is.  "
  "But at the same time, it's an awful lot of fun, and provides you with "
  "the means of giving something back to a MUD that has hopefully provided "
  "you with many hours of entertainment.  :-)",
  "Now that the movie is over, are you still willing to continue your "
  "application to be a creator?  If not, then the exit 'drum' will "
  "return you to the " + mud_name() + "   If you are, hang around a while.  :-)"
  });
void save() {
  unguarded ((: save_object (SAVE) :));
}
void load() {
  unguarded ((: restore_object (SAVE) :));
}
void create() {
  do_setup++;
  ::create();
  do_setup--;
  add_property ("no scry", 1);
  add_property ("no teleport", 1);
  add_help_file ("/doc/creator/room/interview_help");
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void init() {
  ::init();
  this_player()->add_command ("show", this_object(), "movie");
  this_player()->add_command ("stop", this_object(), "movie");
  this_player()->add_command ("interview", this_object(),
      "<indirect:living>", (: do_interview ($1[0]) :));
  this_player()->add_command ("interview", this_object(),
      "<indirect:living> with <string>", (: do_interview ($1[0], $4[1]) :));
  this_player()->add_command ("end", this_object(), "interview");
  this_player()->add_command ("add", this_object(), "<string> [as "
      "candidate]", (: do_add ($4[0]) :));
  this_player()->add_command ("query", this_object(), "applicants");
  this_player()->add_command ("query", this_object(), "permitted "
    "[creators]", (: query_allowed_creators () :));
  this_player()->add_command ("query", this_object(),
    "{confirmation|acceptance|rejection} [text]",
    (: do_query_text ($4[0]) :));
  this_player()->add_command ("delete", this_object(), "<string> [from "
      "candidates]", (: remove_candidate ($4[0]) :));
  this_player()->add_command ("clear", this_object(), "[all] candidates",
      (: flush() :));
  this_player()->add_command ("confirm", this_object(), "<string>",
      (: do_confirm ($4[0]) :));
  this_player()->add_command ("grant", this_object(), "[access to] "
    "<string>", (: add_creator ($4[0]) :));
  this_player()->add_command ("remove", this_object(), "<string> "
    "[as allowed]", (: remove_creator ($4[0]) :));
  this_player()->add_command ("flag", this_object(), "<string> as "
    "{accepted|rejected}", (: do_flag ($4[0], $4[1]) :));
  this_player()->add_command ("read", this_object(),
    "interview for <string>",
    (: do_read ($4[0]) :));
  this_player()->add_command ("list", this_object(), "interviews");
}
void set_movie (string *m) {
  movie = m;
}
int query_permitted(string name) {
  object ob = load_object("/d/" + query_domain() + "/master");
  if (!ob) {
    printf ("Erk, this room is horribly borken!!  Please set the domain "
      "correctly.\n");
    return 0;
  }
  if (member_array (ob, previous_object (-1)) != -1) {
    return 2;
  }
  if (master()->high_programmer (name)) {
    return 1;
  }
#ifdef DEBUG
  if (name == "drakkos") {
    return 1;
  }
#endif
  if ((ob->query_lord() != name) &&
    !(ob->query_deputy (name)) && (member_array (name, _allowed_creators)
    == -1)) {
        return 0;
    }
  return 1;
}
private void write_to_file (string text) {
  unguarded ((: write_file (query_interview_dir()
        +query_subject() +".txt",
        sprintf ("%-=*s", 79, $(text) + "\n")) :));
}
void event_person_say(object ob, string start, string mess, string lang) {
  if (query_subject()) {
      write_to_file (sprintf ("%s says: %s\n", ob->short(),
          mess));
  }
}
void event_emote(object ob, string mess) {
  if (query_subject()) {
      write_to_file (replace (EVENTS->convert_message (mess), ({"$C$", ""})));
  }
}
int do_show() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot show a "
        "movie!\n", ({ }));
      return 0;
  }
  else {
    call_out ("play_movie", 5, 0);
  }
  this_player()->add_succeeded_mess (this_object(), "$N dim$s the light "
          "before pulling out a grubby looking movie projector and pointing "
          "it at an empty wall.  After flicking a switch, a thin ray of "
          "light shoots at the wall.\n", ({ }));
  return 1;
}
int do_stop() {
  int i;
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot stop a "
        "movie!\n", ({ }));
      return 0;
  }
  do {
    i = remove_call_out ("play_movie");
  } while (i != -1);
  this_player()->add_succeeded_mess (this_object(), "$N stop$s the movie.\n",
    ({ }));
  return 1;
}
void play_movie (int i) {
  if (movie[i][0] == '#') {
    tell_room (this_object(), "The movie shows " +
      movie[i][1..sizeof(movie[i])] + "\n");
  }
  else {
    event (this_object(), "person_say", "The voice from the movie says: ",
      movie[i], "general");
  }
  if (i < sizeof (movie)) {
    call_out ("play_movie", 15, ++i);
  }
}
varargs int do_interview (object ob, string names) {
  string *inter = ({ });
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot start an "
        "interview!\n", ({ }));
      return 0;
  }
  if (query_subject()) {
      this_player()->add_failed_mess (this_object(), "You'll have to end "
          "the interview with " + query_subject() + " first.\n", ({ }));
      return 0;
  }
  else {
      if (sizeof (names)) {
        names = replace (names, ({" ", ""}));
        inter = explode (names, ",");
        tell_creator ("drakkos", "%O.\n", inter);
        inter = filter (inter, (: find_player ($1)
          && find_player ($1)->query_playtester() :));
        tell_creator ("drakkos", "%O.\n", inter);
      }
      inter += ({ this_player()->query_name() });
      set_subject (ob->query_name());
      set_interviewer (inter);
      write_to_file (sprintf ("Interview with %s, started %s.  Interview "
        "conducted by %s.\n\n", ob->short(), ctime (time()),
        query_multiple_short (inter)));
  }
  this_player()->add_succeeded_mess (this_object(), "$N press$es a button "
      "on $p tape recorder, indicating the interview is now being "
      "recorded.\n", ({ }));
  return 1;
}
int do_end() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot end an "
        "interview!\n", ({ }));
      return 0;
  }
  if (!query_subject()) {
      this_player()->add_failed_mess (this_object(), "You are not currently "
          "interviewing anyone!\n", ({ }));
      return 0;
  }
  else {
      if (member_array (query_subject(), candidates) != -1) {
          candidates -= ({query_subject()});
      }
      if (member_array (query_subject(), submitted) != -1) {
          submitted -= ({query_subject()});
      }
      interviewed += ({query_subject()});
      interviewed = uniq_array (interviewed);
      save();
      write_to_file (sprintf ("Interview with %s, ended %s.\n", query_subject(),
        ctime (time())));
      set_subject (0);
      set_interviewer (0);
      this_player()->add_succeeded_mess (this_object(), "$N switch$es off "
          "$p tape recorder, indicating the interview is at an end.\n", ({ }));
      return 1;
  }
}
void event_soul(object ob, string str, mixed avoid) {
  if (environment (this_player()) != this_object()) {
    return;
  }
  if (query_subject()) {
    write_to_file (EVENTS->convert_message (str));
  }
}
int *query_co_ord() {
  return 0;
}
int do_query() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot query "
        "creator candidates!\n",
          ({ }));
      return 0;
  }
  if (!sizeof (query_applicants_text())) {
    this_player()->add_failed_mess (this_object(), "No information.\n");
  }
  else {
    tell_object (this_player(), this_object()->query_applicants_text());
  }
  return 1;
}
int do_add (string candidate) {
  int i = query_permitted (this_player()->query_name());
  if (!i) {
      this_player()->add_failed_mess (this_object(), "You cannot add a "
        "candidate!\n", ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(candidate)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (query_part_two_required()) {
    if (member_array (candidate, candidates) == -1) {
        unguarded ((: write_file (LOG, sprintf ("%s added %s as a "
            "candidate on %s.\n", ($(i) == 2? "The " + query_domain()
            + " master object" : this_player()->query_name()),
            $(candidate), ctime(time()))) :));
        candidates += ({candidate});
    }
    else {
      this_player()->add_failed_mess (this_object(), "This player has "
          "already been mailed about creatorship.\n", ({ }));
      return 0;
    }
  }
  else if (member_array (candidate, submitted) == -1) {
        unguarded ((: write_file (LOG, sprintf ("%s added %s as a "
            "candidate on %s.\n", ($(i) == 2? "The " + query_domain()
            + " master object" : this_player()->query_name()),
            $(candidate), ctime(time()))) :));
        submitted += ({candidate});
  }
  else {
      this_player()->add_failed_mess (this_object(), "This player has "
          "already been mailed about creatorship.\n", ({ }));
      return 0;
  }
    AUTO_MAILER->auto_mail( candidate, capitalize
      (this_player()->query_name()), "Your application to "
        + capitalize (query_domain()) + ".", query_cc(),
        query_part_two(), 0, 0);
    save();
    this_player()->add_succeeded_mess (this_object(), "$N add$s a "
      "name to the candidate list.\n", ({ }));
    return 1;
}
string* query_submitted() {
  return submitted;
}
string query_applicants_text() {
  string ret = "", *temp = allocate (sizeof (submitted));
  int i;
  if (sizeof (submitted)) {
      for (i = 0; i < sizeof (submitted); i++) {
          if (find_player (submitted[i])) {
              temp [i] = "%^BOLD%^"+submitted[i] + "%^RESET%^";
          }
          else {
              temp [i] = submitted [i];
          }
      }
    }
  if (query_part_two_required()) {
    if (sizeof (candidates)) {
      ret += sprintf ("The candidates for %s still to submit answers to "
          "part two of the application process are: %s.\n",
            capitalize (query_domain()), query_multiple_short (candidates));
    }
  }
  else {
    if (query_interview()) {
      if (sizeof (temp)) {
        ret += sprintf ("The following candidates for %s " +
        (query_part_two_required()? "have submitted "
          "answers to part two of the test and " :  "")
          + "are awaiting an interview.  "
          "Names in bold are currently online: %s.\n",
          capitalize (query_domain()), query_multiple_short (temp));
      }
    }
    else {
      ret += sprintf ("The following candidates for %s have submitted "
        "answers to part two of the test and are awaiting a response.  "
        "Names in bold are currently online: %s.\n",
        capitalize (query_domain()), query_multiple_short (temp));
    }
  }
  if (query_interview()) {
    if (sizeof (interviewed)) {
        ret += sprintf ("The following candidates have been interviewed "
            "for %s, and are awaiting a response: %s.\n",
            capitalize (query_domain()), query_multiple_short (interviewed));
    }
  }
  if (sizeof (accepted)) {
    ret += sprintf ("The following candidates have been accepted "
            "for %s: %s.\n",
            capitalize (query_domain()), query_multiple_short (accepted));
  }
  if (sizeof (rejected)) {
    ret += sprintf ("The following candidates have been rejected from "
            "%s: %s.\n",
            capitalize (query_domain()), query_multiple_short (rejected));
  }
  if (!sizeof (ret)) {
      ret += "There are no outstanding candidates, and no-one has been "
          "interviewed recently.\n";
  }
  return ret;
}
int clear_interviewed() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  interviewed = ({ });
  return 1;
}
int clear_candidates() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  candidates = ({ });
  return 1;
}
int flush() {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  candidates = ({ });
  interviewed = ({ });
  submitted = ({ });
  accepted = ({ });
  rejected = ({ });
  return 1;
}
int remove_candidate(string candidate) {
  int i;
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (member_array (candidate, candidates) != -1) {
      candidates -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, submitted) != -1) {
      submitted -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, interviewed) != -1) {
      interviewed -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, accepted) != -1) {
      accepted -= ({candidate});
      i = 1;
  }
  if (member_array (candidate, rejected) != -1) {
      rejected -= ({candidate});
      i = 1;
  }
  if (i == 1) {
    this_player()->add_succeeded_mess (this_object(), "$N delete$s a "
      "name from the candidate list.\n", ({ }));
    save();
    return 1;
  }
  this_player()->add_failed_mess (this_object(), "No candidate by that "
    "name is on the list.\n", ({ }));
  return 0;
}
int add_candidate(string name) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(name)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (member_array (name, candidates) == -1) {
      candidates += ({name});
      return 1;
  }
  return 0;
}
int add_interviewed(string name) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(name)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (member_array (name, interviewed) == -1) {
      interviewed += ({name});
      return 1;
  }
  return 0;
}
int add_confirmed(string name) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(name)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (member_array (name, submitted) == -1) {
      submitted += ({name});
      return 1;
  }
  return 0;
}
int remove_interviewed(string candidate) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (member_array (candidate, interviewed) != -1) {
      interviewed -= ({candidate});
      return 1;
  }
  return 0;
}
int do_confirm (string candidate) {
  if (!query_permitted (this_player()->query_name())) {
      this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
          ({ }));
      return 0;
  }
  if (!PLAYER_HANDLER->test_user(candidate)) {
      this_player()->add_failed_mess (this_object(), "This player "
          "exists nowhere on " + mud_name() + " \n", ({ }));
      return 0;
  }
  if (member_array (candidate, submitted) != -1) {
    this_player()->add_failed_mess (this_object(), "You have already "
      "confirmed receipt of this candidate's submission.\n", ({ }));
    return 0;
  }
  if (member_array (candidate, interviewed) != -1) {
    this_player()->add_failed_mess (this_object(), "This candidate "
      "has already been interviewed.\n", ({ }));
    return 0;
  }
  if (member_array (candidate, candidates) != -1) {
    candidates -= ({candidate});
  }
    submitted += ({candidate});
    AUTO_MAILER->auto_mail( candidate, capitalize
        (this_player()->query_name()), "Thank you for your submission.",
        query_cc(), query_confirmation(), 0, 0);
    save();
  this_player()->add_succeeded_mess (this_object(), "$N confirm$s "
    "receipt of a candidate's application.\n", ({ }));
  return 1;
}
void set_domain(string dom) {
  _domain = dom;
}
string query_domain () {
  if (!_domain) {
    return "unset";
  }
  else {
    return _domain;
  }
}
void set_confirmation(string text) {
  _confirmation_text = text;
}
string query_confirmation() {
  if (!sizeof (_confirmation_text)) {
    if (query_interview()) {
      return sprintf ("Bing!\n\n"
        "Thank you for sending in the second part of the application.  "
        "The next part of the application process will be an interview "
        "to discuss your application to the %s domain.  "
        "This interview is likely to take around an hour of your time, "
        "so if you could mail me with a list of your "
        "common online times, hopefully we'll be able to make an "
        "appointment that is mutually convenient.\n\nRegards,\n%s.",
        query_domain(), LORD);
    }
    else {
      return sprintf ("Bing!\n\n"
        "Thank you for sending in the second part of the application.  "
        "Your application to the %s domain is now being considered, and "
        "you should expect to hear back within a week or two with an "
        "answer.\n\nRegards,\n%s.",
        query_domain(), LORD);
    }
  }
  else {
    return _confirmation_text;
  }
}
string query_lord() {
  return LORD;
}
void set_part_two_required (int i) {
  _pt_two = i;
}
int query_part_two_required () {
  return _pt_two;
}
void set_interview(int i) {
  _interview = i;
}
int query_interview() {
  return _interview;
}
string query_subject(){
  if (_subject) {
    return _subject;
  }
  return 0;
}
private void set_subject (string name) {
    _subject  = name;
}
private void set_interviewer (mixed name) {
  if (arrayp (name)) {
    _int  = name;
  }
  else {
    _int = ({ name });
  }
}
string *query_interviewer() {
  return _int;
}
int query_is_interviewer (string name) {
  if (!sizeof (_int)) {
    return 0;
  }
  if (member_array (name, _int) != -1) {
    return 1;
  }
  return 0;
}
string* query_permitted_creators() {
  return copy (_allowed_creators);
}
private void add_permitted_creator(string name) {
  if (member_array (name, _allowed_creators) == -1) {
    _allowed_creators += ({ name });
  }
}
private void remove_permitted_creator(string name) {
  if (member_array (name, _allowed_creators) != -1) {
    _allowed_creators -= ({ name });
  }
}
int add_creator (string name) {
  object ob = find_object ("/d/" + query_domain() + "/master");
  if (this_player()->query_name() != ob->query_lord()) {
    this_player()->add_failed_mess (this_object(), "Only the lord "
      "may permit creators to use this room.\n", ({ }));
    return 0;
  }
  if (!PLAYER_HANDLER->test_creator (name)) {
      this_player()->add_failed_mess (this_object(), "Only creators "
        "may be permitted to use the interview room.\n", ({ }));
      return 0;
  }
  add_permitted_creator (name);
  save();
  this_player()->add_succeeded_mess (this_object(), "$N add$s a creator "
    "as allowed.\n", ({ }));
  return 1;
}
int remove_creator (string name) {
  object ob = find_object ("/d/" + query_domain() + "/master");
  if (this_player()->query_name() != ob->query_lord()) {
    this_player()->add_failed_mess (this_object(), "Only the lord "
      "may permit creators to use this room.\n", ({ }));
    return 0;
  }
  remove_permitted_creator (name);
  save();
  this_player()->add_succeeded_mess (this_object(), "$N remove$s a creator "
    "as allowed.\n", ({ }));
  return 1;
}
int query_allowed_creators() {
  if (!sizeof (query_permitted_creators())) {
    this_player()->add_failed_mess (this_object(), "Only the domain lord and "
      "the domain deputies are currently permitted to use this room.\n",
      ({ }));
    return 0;
  }
  tell_object (this_player(), sprintf ("In addition to the domain Lord and "
    "the domain deputies, the following creators are permitted "
    "to make use of this room: %s.\n", query_multiple_short
    (query_permitted_creators())));
  return 1;
}
string query_part_two(){
  string temp;
  if (_filename) {
    temp = unguarded ((: read_file (_filename) :));
    if (sizeof (temp)) {
      return temp;
    }
  }
  return sprintf ("Bing!\n\nThank you for your application to the %s domain. "
    "\n\nYour application has been received and is awaiting processing.\n\n"
    "Regards,\n%s.", query_domain(), LORD);
}
int set_part_two(string file) {
  if (!sizeof (file)) {
    printf ("No file given for part two of application.  Aborting.\n");
    return 0;
  }
  if (file_size(file) == -1) {
    printf ("File given for set_part_two() does not exist.  No file set.\n");
    return 0;
  }
  _filename = file;
  return 1;
}
string query_interview_dir(){
  if (sizeof (_interview_dir)) {
    return _interview_dir;
  }
  else {
    return SECURE;
  }
}
int set_interview_dir(string dir) {
  if (!sizeof (dir)) {
    printf ("No directory given for interviews.  Aborting.\n");
    return 0;
  }
  if (file_size(dir) != -2) {
    printf ("Directory given for set_interview_dir does not exist.  "
      "Aborting.\n");
    return 0;
  }
  _interview_dir = dir;
  return 1;
}
int do_query_text(string flag) {
  string temp;
  switch (flag) {
    case "confirmation":
      temp = query_confirmation();
    break;
    case "acceptance":
      temp = query_acceptance();
    break;
    case "rejection":
      temp = query_rejection();
    break;
    default:
      temp = "I'm sorry, there has been an error.\n";
    break;
  }
  tell_object (this_player(), temp);
  return 1;
}
int do_flag(string name, string flag) {
  if (member_array (name, candidates) != -1) {
        candidates -= ({name});
  }
  if (member_array (name, submitted) != -1) {
      submitted -= ({name});
  }
  if (member_array (name, interviewed) != -1) {
      interviewed -= ({name});
  }
  if (flag == "accepted") {
    AUTO_MAILER->auto_mail( name, capitalize
      (this_player()->query_name()), "Congratulations!",
          query_cc(), query_acceptance(), 0, 0);
    if (member_array (name, accepted) == -1) {
      accepted += ({name});
    }
  }
  else {
    AUTO_MAILER->auto_mail( name, capitalize
      (this_player()->query_name()), sprintf ("Your application to the %s "
        "domain.", query_domain()), query_cc(), query_rejection(), 0, 0);
    if (member_array (name, rejected) == -1) {
      rejected += ({name});
    }
  }
  this_player()->add_succeeded_mess (this_object(), sprintf ("$N flag$s a "
    "player as %s.\n", flag), ({ }));
  save();
  unguarded ((: write_file (LOG, sprintf ("%s flagged %s as %s "
          "on %s.\n", this_player()->query_name(),
          $(name), $(flag), ctime(time()))) :));
  return 1;
}
void set_rejection(string text) {
  _rejection_text = text;
}
void set_acceptance(string text) {
  _acceptance_text = text;
}
string query_rejection() {
  if (!sizeof (_rejection_text)) {
    return sprintf ("Hello.\n\n"
      "I'm sorry to say that your application to the %s domain has been "
      "unsuccessful.  My apologies that I cannot hire you at this time.  "
      "I will of course keep your details on file should you wish to "
      "apply again in the future.\n\nRegards,\n%s.",
          query_domain(), LORD);
  }
  else {
    return _rejection_text;
  }
}
string query_acceptance() {
  if (!sizeof (_acceptance_text)) {
    return sprintf ("Bing!\n\n"
      "It is my great pleasure to inform you that your application to the %s "
        "domain has been successful.  Congratulations!\n\nBefore being promoted, "
        "you will need to ensure you repay any debts you have.  If you wish "
        "to bequeath your inventory on a fellow player, this must also be "
        "done before you are employed - you won't get a chance once you're "
        "a creator.\n\nPlease send me a mail letting me know when you will "
        "be available for promotion and your orientation lecture.\n\n"
        "Congratulations,\n%s.",query_domain(), LORD);
  }
  else {
    return _acceptance_text;
  }
}
int do_read (string name) {
  string path;
  if (!query_permitted (this_player()->query_name())) {
    this_player()->add_failed_mess (this_object(), "You cannot do this!\n",
        ({ }));
    return 0;
  }
  path = query_interview_dir() + name + ".txt";
  if (!file_size (path)) {
    this_player()->add_failed_mess (this_object(), "This document does "
      "not exist.\n", ({ }));
    return 0;
  }
  this_player()->more_string (unguarded ((: read_file ($(path)) :)));
  return 1;
}
string query_cc() {
  if (sizeof (_cc)) {
    return implode (_cc, ",");
  }
  return 0;
}
void set_cc (string *i) {
  _cc = i;
}
int do_list() {
  string *list, text;
  if (!query_permitted (this_player()->query_name())) {
    this_player()->add_failed_mess (this_object(), "You are not permitted "
      "to do this.\n", ({ }));
    return 0;
  }
  else {
    list = get_dir (query_interview_dir());
    list -= ({"candidate_list.o", "candidate_log.txt"});
  }
  list = map (list, (: capitalize ($1) :));
  text = replace (query_multiple_short (list), ({".txt", ""}));
  tell_object (this_player(), sprintf ("The following interviews have been "
    "conducted for the %s domain: %s.\n", query_domain(),
      text));
  this_player()->add_succeeded_mess (this_object(), "$N list$s the completed "
    "interviews.\n", ({ }));
  return 1;
}
string* query_all_applicants() {
  return uniq_array (candidates + interviewed + submitted + accepted + rejected);
}
string* query_interviewed() {
  return interviewed;
}

==================================================
FILE: dom/loader.c
==================================================

string *pre_load;
void create() {
  int i;
  string domain;
  foreach(domain in "/secure/master"->query_domains()) {
    unguarded((: restore_object, "/d/"+ domain + "/loader" :));
    if (!pre_load)
      pre_load = ({ });
    for (i=0;i<sizeof(pre_load);i++) {
      if(pre_load && explode(pre_load[i], "/")[1] != domain)
        printf("invalid " + domain + " preload: " + pre_load[i] +
               "\n");
      else {
        printf(domain +" pre_loading "+pre_load[i]+".\n");
        if (catch(call_other(pre_load[i], "??")))
          call_out("do_load", 0, pre_load[i]);
      }
    }
  }
}
void do_load(string str) {
  call_other(str, "??");
}
int add_pre_load(string domain, string str) {
  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return 0;
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  if (member_array(str, pre_load) == -1)
    pre_load += ({ str });
  save_object("/d/" + domain + "/loader");
  return 1;
}
int remove_pre_load(string domain, string str) {
  int i;
  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return 0;
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  if ((i=member_array(str, pre_load)) == -1)
    return 0;
  pre_load = delete(pre_load, i, 1);
  save_object("/d/" + domain + "/loader");
}
string *query_pre_load(string domain) {
  if(member_array(domain, "/secure/master"->query_domains()) == -1)
    return ({ });
  unguarded((: restore_object, "/d/"+ domain + "/loader" :));
  if (!pre_load)
    pre_load = ({ });
  return pre_load;
}

==================================================
FILE: dom/master.c
==================================================

inherit "/std/dom/base_master";
string query_lord() {
  return LORD;
}
string author_file(string *path) {
  return capitalize(DOMAIN);
}
int check_permission(string euid, string *path, int mask) {
  if (euid == query_lord())
    return 1;
  return ::check_permission(euid, path, mask);
}
int valid_read(string *path, string euid, string funct);
int valid_write(string *path, string euid, string funct);
int query_member(string name) {
  return !undefinedp(members[name]) || name == LORD;
}
string log_who(string where) {
  return LORD;
}
string query_info() {
  return "";
}

==================================================
FILE: environ/snowball.c
==================================================

#include <tasks.h>
inherit "std/object";
int strength;
void set_strength( int number );
void setup() {
   set_name( "snowball" );
   add_alias( "ball" );
   add_adjective( "snow" );
   set_strength( 99 );
   set_heart_beat( 1 );
}
int query_strength() { return strength; }
void set_strength( int number ) { strength = number; }
string long( string word, int dark ) {
   return "This is a "+ ({
      "very small lump of slush",
      "small and rather soggy lump of snow",
      "small snowball",
      "smallish snowball",
      "vaguely small snowball",
      "decent sized snowball",
      "reasonably sized snowball",
      "snowball for throwing at someone",
      "good snowball for throwing at someone",
      "nice, big snowball, just right for throwing at someone"
   })[ strength / 10 ] +".\n";
}
void init() {
    add_command( "throw", "<direct:object> {at|to} <indirect:object>" );
}
void heart_beat() {
   strength--;
   if ( strength < 1 ) {
      set_heart_beat( 0 );
      move( "/room/rubbish" );
   }
}
private object find_person(object ob) {
   if (living(ob)) {
      return ob;
   } else {
      while (ob && !living(ob)) {
         ob = environment(ob);
      }
      if (ob) {
         return ob;
      }
   }
   return 0;
}
int do_throw( object *obs ) {
   object per;
   int chance;
   per = find_person(obs[0]);
   if (per) {
      if (per != obs[0]) {
         chance = 0;
      } else {
         chance = 30;
      }
      if (per == this_player()) {
         per->add_effect( "/std/effects/external/snowball", strength );
      } else {
         switch (TASKER->compare_skills(this_player(),
                                        "fighting.combat.range.thrown",
                                        per,
                                        "fighting.combat.dodging.range",
                                        chance,
                                        TM_FREE,
                                        TM_FREE)) {
         case OFFAWARD :
            tell_object(this_player(), "%^YELLOW%^You feel more able to throw "
                                       "snowballs at people.\n%^YELLOW%^");
         case OFFWIN :
            per->add_effect( "/std/effects/external/snowball", strength );
            add_succeeded_mess( ({ "$N throw$s $D at $I and hit$s!\n",
                "$N throw$s $D at $I and hits!\n" }),  ({ obs[0] }) );
            break;
         case DEFAWARD :
            tell_object(this_player(), "%^YELLOW%^You feel more able to dodge "
                                       "snowball thrown by people.\n%^YELLOW%^");
         case DEFWIN :
            add_succeeded_mess( "$N throw$s $D at $I and miss$es!\n",
                                   ({ obs[0] }) );
            break;
         }
      }
   } else {
      add_succeeded_mess( "$N throw$s $D at $I.\n", ({ obs[ 0 ] }) );
   }
   move( "/room/rubbish" );
   return 1;
}
mapping query_dynamic_auto_load() {
   return ([
      "::" : ::query_dynamic_auto_load(),
      "strength" : strength
   ]);
}
void init_dynamic_arg( mapping map, object ) {
   ::init_dynamic_arg( map[ "::" ] );
   strength = map[ "strength" ];
}

==================================================
FILE: environ/snowman.c
==================================================

#include <move_failures.h>
inherit "/std/object";
private int _call_out_handle;
void setup() {
    reset_get();
    if ( clonep() ) {
        _call_out_handle = call_out("die",400);
    }
}
void set_type(string type) {
    set_name(type);
    set_short(type);
    set_long("A wonderful " + type + " with glowing eyes made of coal and twigs "
      "for ears.\n");
    add_extra_look( this_object() );
}
string extra_look( object ob ) {
    int time_left;
    if ( !_call_out_handle ) {
        return "";
    }
    time_left = find_call_out( _call_out_handle );
    debug_printf( "time left is %d\n", time_left );
    if ( time_left > 300 || time_left < 0 ) {
        return "";
    }
    return "It is " + ({ "mostly", "half", "slightly" })[time_left/100] +
        " melted.\n";
}
void die() {
    string noun;
    switch( environment( this_object() )->query_property( "location" ) ) {
    case "inside":
        noun = "floor";
        break;
    case "outside":
        noun = "ground";
        break;
    case "underwater":
        noun = "seabed";
        break;
    default:
        noun = "floor";
        break;
    }
    tell_room( environment( this_object() ),
      the_short() + " $V$0=melts,melt$V$ into the " + noun + ".\n");
    if ( this_object()->move( "/room/rubbish" ) != MOVE_OK ) {
        dest_me();
    }
}

==================================================
FILE: environ/weather.c
==================================================

#include <config.h>
inherit "std/object";
#include "climate.h"
#define FILE_NAME "/save/environ/weather"
#define HOME "/obj/handlers/weather_room"
#define MAX_DIST 100
#define YEAR 60
#define DAY 60
#define SPEED 40
mixed *coldarr,
      *cloudarr,
      *rainarr;
int timeofyear,
    mooncycle,
    moonoff,
    timeofday,
    intensity;
int distance(mixed *co_ord1,mixed *co_ord);
int cloud_index(object env);
int rain_index(object env);
int temperature_index(object env);
string cloud_string(object env);
string rain_string(object env);
string temperature_string(object env);
void setup() {
  set_name("weather");
  set_short("weather controller extrodinare");
  set_long("The weather controller, at least this one is always right!\n");
  cloudarr = ({ ({ 0,0 }), ({ 50,50 }), ({ -50,-50 }) });
  rainarr = ({ ({ 0,0 }), ({ 50,50 }), ({ -50,-50 }) });
  coldarr = ({ ({ 0,0 }), ({ 50,50 }), ({ -50,-50 }) });
  intensity = 100;
  restore_object(FILE_NAME);
  call_out("update_low",SPEED);
  move("bing");
}
move(arg) {
  ::move(HOME);
}
mixed *query_cold() { return coldarr; }
mixed *query_rain() { return rainarr; }
mixed *query_cloud() { return cloudarr; }
int query_moon() { return mooncycle; }
string query_moon_string(object env) {
  int bing;
  bing = timeofday - (DAY/4) -
         (distance((mixed *)env->query_co_ord(), ({ 0, 0, 0, }))/100);
  if (bing<0) bing += DAY;
  if ((moonoff+(DAY/2)<bing) && (bing<DAY-moonoff))
    return 0;
  return ({ "full moon",
            "waning three quarter moon",
            "waning half moon",
            "waning quarter moon",
            "waning cresent moon",
            "new moon",
            "waxing cresent moon",
            "waxing quarter moon",
            "waxing half moon",
            "waxing three quarter moon" })[mooncycle];
}
int distance(mixed *co_ord1, mixed *co_ord2) {
  int off;
  if (!pointerp(co_ord1) || !pointerp(co_ord2))
    return 0;
  if (co_ord1[0]>co_ord2[0])
    off = co_ord1[0] - co_ord2[0];
  else
    off = co_ord2[0] - co_ord1[0];
  if (co_ord1[1]>co_ord2[1])
    off += co_ord1[1] - co_ord2[1];
  else
    off += co_ord2[1] - co_ord1[1];
  return off;
}
int query_season() { return timeofyear/15; }
int query_time_of_year() { return timeofyear; }
int query_time_of_day() { return timeofday; }
int query_day(object env) {
  int bing, bit;
  if (!env) {
    load_object(CONFIG_START_LOCATION);
    env = find_object(CONFIG_START_LOCATION);
  }
  bing = timeofday - (DAY/4) -
         (distance((mixed *)env->query_co_ord(), ({ 0, 0, 0, }))/100);
  if (bing<0) bing += DAY;
  bit = (DAY/2)-(timeofyear-(YEAR/2))/(YEAR/10);
  if (bing>bit)
    return 0;
  if (bit < 10)
    return bit;
  return -(bing - bit);
}
int query_darkness(object env) {
  int bing, per, i;
  per = -cloud_index(env);
  if (per <-100)
    per = -100;
  if (per > 100)
    per = 100;
  if ((i=query_day(env))) {
    i *= 20;
    if (i>100)
      i = 100;
    return 50+(per+100)*150*i/20000;
  }
  bing = timeofday - (DAY/4) -
         (distance((mixed *)env->query_co_ord(), ({ 0, 0, 0, }))/100);
  if (bing<0) bing += DAY;
  if ((moonoff+(DAY/2)<bing) && (bing<DAY-moonoff))
    return 15+(per+100)*30/200;
  if (timeofday<0) timeofday += DAY;
  i = mooncycle -5;
  if (i<0)
    i = -i;
  return 30+(per+100)*14*i/200;
}
string weather_string(object env) {
  return temperature_string(env)+" with "+cloud_string(env)+
         rain_string(env);
}
int query_raining(object env) {
  int cloud,rain;
  if (temperature_index(env)/(100/7)<2) {
    cloud = cloud_index(env);
    if (cloud<=0)
      return 0;
    rain = rain_index(env);
    if (cloud-rain<=0)
      return 0;
    return cloud-rain;
  }
  return 0;
}
int query_hailing(object env) {
  int cloud, rain;
  if (temperature_index(env)/(100/7)==2) {
    cloud = cloud_index(env);
    if (cloud <=0)
      return 0;
    rain = rain_index(env);
    if (cloud-rain <=0)
      return 0;
    return cloud-rain;
  }
  return 0;
}
int query_snowing(object env) {
  int cloud,rain;
  if ((temperature_index(env)/(100/7))>=3) {
    cloud = cloud_index(env);
    if (cloud<=0)
      return 0;
    rain = cloud_index(env);
    if (cloud-rain<=0)
      return 0;
    return cloud-rain;
  }
  return 0;
}
string rain_string(object env) {
  int cloud, rain, temp;
  string tempstr1,tempstr2;
  cloud = cloud_index(env);
  rain = rain_index(env);
  if (cloud<=0) return "";
  if (cloud-rain<=0) return "";
  temp = temperature_index(env)/(100/7);
  if (temp>3) temp = 3;
  if (temp<-3) temp = -3;
  tempstr1 = ({ "very hot ",
                "hot ",
                "warm ",
                "nice ",
                "cold ",
                "",
                "" })[temp+3];
  tempstr2 = ({ " rain",
                " rain",
                " rain",
                " rain",
                " rain",
                " hail",
                " snow" })[temp+3];
  cloud = (cloud-rain) / 20;
  if (cloud>5) cloud = 5;
  return "\n"+capitalize(tempstr1 + ({ "very light",
                      "light",
                      "medium",
                      "heavy",
                      "very heavy" }) [cloud]+tempstr2);
}
string temperature_string(object env) {
  int inten;
  inten = temperature_index(env);
  inten /= 10;
  if (inten>10)
    inten = 10;
  if (inten<-10)
    inten = -10;
  return ({ "Its one of those baking eggs on the pavement days",
            "So hot that the sun feels like its right next door",
            "Damn hot",
            "Very hot",
            "Hot",
            "Hot",
            "Reasonably hot",
            "Very warm",
            "Warm",
            "Pleasantly warm",
            "Average temerature",
            "A little chilly",
            "A slight nip in the air",
            "Chilly",
            "Very chilly",
            "Cold",
            "Cold",
            "Very cold",
            "Damn cold",
            "Incredibly cold",
            "Freezing cold" })[inten+10];
}
string cloud_string(object env) {
  int off;
  off = cloud_index(env) / 20;
  if (off>5) off = 5;
  if (off<-5) off = -5;
  return ({ "a beatifully clear sky",
            "a few high level sirius clouds",
            "scattered puffy clouds",
            "very thin complete cloud cover",
            "light cloud cover",
            "medium cloud cover",
            "dense cloud cover",
            "packed cloud cover",
            "packed cloud cover",
            "heavy black clouds",
            "thick heavy clouds",
         })[off+5];
}
int temperature_index(object env) {
  int off,i;
  mixed clim, *co_ord;
  for (i=0;i<sizeof(coldarr);i++)
    off += (distance((mixed *)env->query_co_ord(), coldarr[i]) % (MAX_DIST*2));
  off = off / sizeof(coldarr);
  if ((clim = (mixed *)env->query_property("climate")))
    off += clim[C_TEMP];
  if (off>MAX_DIST) off = (MAX_DIST*2) - off;
  off -= (MAX_DIST/2);
  off = 0 - off;
  co_ord = (mixed *)env->query_co_ord();
  if (!co_ord)
    co_ord = ({ 0, 0, 0 });
  return (off + (timeofyear - (YEAR/2)) + (timeofday - (DAY/2)) + co_ord[2]);
}
int cloud_index(object env) {
  int off;
  mixed *clim;
  int i;
  for (i=0;i<sizeof(cloudarr);i++)
    off += (distance((mixed *)env->query_co_ord(), cloudarr[i]) % (MAX_DIST*2));
  off = off / sizeof(cloudarr);
  if ((clim = (mixed *)env->query_property("climate")))
    off += clim[C_CLOUD];
  if (off>MAX_DIST) off = (MAX_DIST*2) - off;
  off -= (MAX_DIST/2);
  off = 0-off;
  return (off + (timeofyear - (YEAR/2)));
}
int rain_index(object env) {
  int off;
  mixed *clim;
  int i;
  for (i=0;i<sizeof(rainarr);i++)
    off += (distance((mixed *)env->query_co_ord(), rainarr[i]) % (MAX_DIST*2));
  off = off / sizeof(rainarr);
  if ((clim = (mixed *)env->query_property("climate")))
    off += clim[C_RAIN];
  if (off>MAX_DIST) off = (MAX_DIST*2) - off;
  off -= MAX_DIST/2;
  off = 0-off;
  return off;
}
void update_low() {
  int i;
  timeofday++;
  if (timeofday>DAY) {
    timeofday = 0;
    timeofyear++;
    mooncycle++;
    if (mooncycle %2) {
      moonoff += 1;
      moonoff = moonoff % (DAY/2);
    }
    timeofyear = timeofyear % YEAR;
    mooncycle = mooncycle % 10;
    save_object(FILE_NAME);
  }
  for (i=0;i<sizeof(rainarr);i++) {
    rainarr[i][0] += random(3)-1;
    rainarr[i][0] = rainarr[i][0] % (MAX_DIST*2);
    rainarr[i][1] += random(3)-1;
    rainarr[i][1] = rainarr[i][1] % (MAX_DIST*2);
  }
  for (i=0;i<sizeof(cloudarr);i++) {
    cloudarr[i][0] += random(3)-1;
    cloudarr[i][0] = cloudarr[i][0] % (MAX_DIST*2);
    cloudarr[i][1] += random(3)-1;
    cloudarr[i][1] = cloudarr[i][1] % (MAX_DIST*2);
  }
  for (i=0;i<sizeof(coldarr);i++) {
    coldarr[i][0] += random(3)-1;
    coldarr[i][0] = coldarr[i][0] % (MAX_DIST*2);
    coldarr[i][1] += random(3)-1;
    coldarr[i][1] = coldarr[i][1] % (MAX_DIST*2);
  }
  intensity += random(3)-1;
  if (intensity<50)
    intensity=50;
  if (intensity>300)
    intensity=300;
  call_out("update_low",SPEED);
}
void dest_me() {
  save_object(FILE_NAME);
  ::dest_me();
}

==================================================
FILE: environ/weather_room.c
==================================================

inherit "std/room";
mixed leverarr;
reset (arg) {
  if (arg) return;
  set_short("The weather room");
  set_long("The weather control center for the entire mud. On the floor should\n"+
           "be the controller itself, scattered around the room are hundred of impresive\n"+
           "flashing lights, dials and levers. You get the feeling however that they dont\n"+
           "actually do anything.\n");
  set_light(1);
  seteuid("pinkfish");
  add_property("inside");
  add_exit("pinkfish","d/Fish/pinkfish/workroom");
  add_item("lights","What did I say? there are lots of them and they are insesantly\n"+
           "flashing.\n");
  add_item("dials","Large dials with all sort of things on them. One you can see says\n"+
           "'Colour of spring', it is currently pointing at purple.\n");
  add_item("levers",
           "The levers are large multicolour protuberances which are scattered around the\n"+
           "room in random profusion.\n");
  leverarr = ({ ({ "blue",
       "The rooms spins and a small bit of printed paper falls from the\n"+
       "Weather controller saying:\n#query_rain" }),
                ({ "white",
       "The ground heaves in a major convulsion and a mound of paper falls onto\n"+
       "You from the ceiling saying:\n#query_cloud" }) });
}
init() {
  ::init();
  add_action("pull","pull");
  add_action("push","push");
}
pull(str) {
  int i;
  string type,rand;
  object lever, weather;
  if (str == "lever" || str == "levers")
    lever = leverarr[random(sizeof(leverarr))];
  else {
    if (!sscanf(str,"%s lever%s",type,rand)) {
      notify_fail("You have to pull a lever.\n");
      return 0;
    }
    for (i=0;i<sizeof(leverarr);i++) {
      if (leverarr[i][0] == type) {
        lever = leverarr[i];
        break;
      }
    }
  }
  if (!lever) {
    notify_fail("You need to choose and existing lever");
    return ;
  }
  weather = present("weather",this_object());
  if (!weather) {
    notify_fail("Opps the weather controller does not exist.\n");
    return 0;
  }
  sscanf(lever[1],"%s#%s",type,rand);
  write(type);
  this_player()->print_object(call_other(weather,rand));
  return 1;
}
push(str) {
  object lever;
  int i;
  string type,bing;
  if (str == "levers" && str == "lever")
    lever = leverarr[random(sizeof(leverarr))];
  else {
    if (!sscanf(str,"%s lever%s",type,bing)) {
      notify_fail("You must push an existing lever.\n");
      return 0;
    }
    for (i=0;i<sizeof(leverarr);i++)
      if (type == leverarr[i][0]) {
        lever = leverarr[i];
        break;
      }
  }
  if (!lever) {
    notify_fail("An existing lever could be usefull...\n");
    return 0;
  }
  write("You huff and you puff, but you just cant push that lever.\n");
}

==================================================
FILE: living/armour.c
==================================================

#include <clothing.h>
#include <function.h>
#include <race.h>
#include <armour.h>
inherit "/std/armour_logic";
#undef INFORM 1
nosave string skin;
nosave object *wearing;
nosave mixed stopped;
nosave mixed *_armour_callbacks;
nosave int *_cids;
void create() {
   skin = "morphological field";
   wearing = ({ });
   if(!_armour_callbacks)
     _armour_callbacks = ({ ({ }), ({ }), ({ }) });
   if(!_cids)
     _cids = ({ 0, 0, 0 });
   ::create();
}
int register_armour_callback(int level, mixed callback, mixed data) {
  _armour_callbacks[level] += ({ new(class armour_callback,
                                     id : ++(_cids[level]),
                                     callback: callback,
                                     data : data) });
  return _cids[level];
}
int remove_armour_callback(int level, int id) {
  int i;
  for(i=0; i<sizeof(_armour_callbacks[level]); i++) {
    if((_armour_callbacks[level][i])->id == id) {
      _armour_callbacks[level] -= ({ _armour_callbacks[level][i] });
      return 1;
    }
  }
  return 0;
}
int update_armour_callback(int level, int id, mixed data) {
  int i;
  for(i=0; i<sizeof(_armour_callbacks[level]); i++) {
    if((_armour_callbacks[level][i])->id == id) {
      _armour_callbacks[level][i]->data = data;
      return 1;
    }
  }
  return 0;
}
mixed *query_armour_callbacks() { return copy(_armour_callbacks); }
string query_skin() { return skin; }
void set_skin( string word ) { skin = word; }
object *query_wearing() {
   wearing = filter(wearing, (: $1 && environment($1) == this_object() :));
   return copy( wearing );
}
object *query_armours() {
   return query_wearing();
}
void clear_armours() {
   wearing->set_worn_by( 0 );
   wearing = ({ });
}
mixed query_stopped() {
   return stopped;
}
void set_stopped( mixed arg ) { stopped = arg; }
protected int equivalent_armour_types( mixed comp, string type ) {
   string word;
   if ( stringp( comp ) ) {
      if ( CLOTHING_HANDLER->query_equivilant_type( comp ) ) {
         return CLOTHING_HANDLER->query_equivilant_type( comp ) == type;
      }
      return comp == type;
   }
   foreach ( word in comp ) {
      if ( equivalent_armour_types( word, type ) )
         return 1;
   }
   return 0;
}
string wear_armour( object armour, int doing_hold ) {
   int no_limbs;
   string type, word, fail_mess;
   mixed types;
   object thing;
   mapping things;
   if (environment(armour) != this_object()) {
      return "must be in your inventory";
   }
   wearing -= ({ 0 });
   if (member_array(armour, wearing) > -1)
     return "since you already have " + armour->query_objective() + " on";
   types = armour->query_type();
   word = this_object()->not_allowed_to_wear( types );
   if ( word ) {
      return word;
   }
   things = ([ ]);
   if ( stringp( types ) ) {
      types = ({ types });
   }
   if ( !pointerp( types ) ) {
      return "oh dear";
   }
   foreach ( type in types ) {
      if ( CLOTHING_HANDLER->query_equivilant_type( type ) ) {
         type = CLOTHING_HANDLER->query_equivilant_type( type );
      }
      things[ type ] = ({ });
      foreach ( thing in wearing ) {
         if ( equivalent_armour_types( (mixed)thing->query_type(), type ) )  {
            things[ type ] += ({ thing });
         }
      }
   }
   word = (string)this_object()->query_race_ob();
   if ( !word )
     return "no race object";
   foreach ( type in keys( things ) ) {
      if ( (int)word->query_number_worn( type ) <= sizeof( things[ type ] ) ) {
         return "since you are already wearing "+
               query_multiple_short( things[ type ] );
      }
   }
   no_limbs = (int)armour->query_no_limbs();
   if ( no_limbs && !doing_hold ) {
      if ( member_array( armour,
            (object *)this_object()->query_holding() ) != -1 ) {
         return "already wearing";
      }
      if( sizeof( (int *)armour->hold_item( this_object(), -1 ) ) ) {
         return 0;
      } else {
         return "already holding";
      }
   }
   if ( !armour->set_worn_by( this_object() ) ) {
      if( fail_mess = armour->query_wear_failure_mess() )
         return fail_mess;
      else
         return "oh dear";
   }
   wearing += ({ armour });
   this_object()->do_burden_call();
   return 0;
}
int remove_armour( object thing ) {
   int i;
   wearing -= ({ 0 });
   i = member_array( thing, wearing );
   if ( i == -1 ) {
      return 1;
   }
   if ( !thing->set_worn_by( 0 ) ) {
      return 1;
   }
   if ( member_array( thing, (object *)this_object()->query_holding() ) != -1 ) {
      if ( !sizeof( (int *)this_object()->set_unhold( thing ) ) ) {
         return 1;
      }
   }
   wearing = delete( wearing, i, 1 );
   this_object()->do_burden_call();
   return 0;
}
varargs int query_ac( string type, int amount, string zone ) {
  int part, total, i, max;
  string word, *types;
  mixed most;
  object thing;
  object *defenses;
  stopped = 0;
#ifdef INFORM
  event( environment(), "inform", "zone "+ zone, "combat" );
#endif
  if ( !zone ) {
    switch(random(21)) {
    case 0..1: zone = "head"; break;
    case 2: zone = "neck"; break;
    case 3..6: zone="chest"; break;
    case 7..9: zone="abdomen"; break;
    case 10..12: zone = "arms"; break;
    case 13..14:
      zone = "hands"; break;
    case 15..18: zone = "legs"; break;
    case 19: zone = "feet"; break;
    case 20: zone = "back"; break;
    }
#ifdef INFORM
    event( environment(), "inform", "picked zone "+ zone,
           "combat" );
#endif
  }
  if(sizeof(_armour_callbacks[ARM_OUTER]) && amount) {
    for(i=0; i<sizeof(_armour_callbacks[ARM_OUTER]); i++) {
      if(!_armour_callbacks[ARM_OUTER][i]->callback[0])
        remove_armour_callback(ARM_OUTER,
                               _armour_callbacks[ARM_OUTER][i]->id);
      else {
        part = call_other(_armour_callbacks[ARM_OUTER][i]->callback[0],
                          _armour_callbacks[ARM_OUTER][i]->callback[1],
                          this_object(),
                          type, amount, zone,
                          _armour_callbacks[ARM_OUTER][i]->data);
        if(part > max) {
          max = part;
          most = stopped;
        }
        total += part;
        amount -= part;
        if(amount < 1)
          break;
      }
    }
  }
  if(zone != "self" && amount > 0) {
    types = CLOTHING_HANDLER->query_clothing_zone( zone );
    if(!types) {
      log_file("ARMOUR_DEBUG", "No types for zone: %s", zone);
      return 0;
    }
    foreach ( word in  types) {
      wearing -= ({ 0 });
      defenses = wearing + filter_array(this_object()->query_holding(),
                                        (: $1 && $1->query_armour() :));
      foreach ( thing in defenses )
        if ( equivalent_armour_types( (mixed)thing->query_type(), word ) ) {
#ifdef INFORM
          event( environment(), "inform", "testing object "+
                 thing->short(), "combat" );
#endif
          part = (int)thing->query_ac( type, amount, zone );
          if (!stopped && part)
            stopped = thing;
          if(part > max) {
            max = part;
            most = stopped;
          }
          total += part;
          amount -= part;
        }
      if (amount < 1)
        break;
    }
  }
  if(sizeof(_armour_callbacks[ARM_INNER]) && amount > 0) {
    for(i=0; i<sizeof(_armour_callbacks[ARM_INNER]); i++) {
      if(!_armour_callbacks[ARM_INNER][i]->callback[0])
        remove_armour_callback(ARM_INNER,
                               _armour_callbacks[ARM_INNER][i]->id);
      else {
        part = call_other(_armour_callbacks[ARM_INNER][i]->callback[0],
                          _armour_callbacks[ARM_INNER][i]->callback[1],
                          this_object(),
                          type, amount, zone,
                          _armour_callbacks[ARM_INNER][i]->data);
        if(part > max) {
          max = part;
          most = stopped;
        }
        total += part;
        amount -= part;
        if(amount < 1)
          break;
      }
    }
  }
  if(amount > 0 && this_object()->query_race_ob() &&
     function_exists("query_ac", load_object(this_object()->query_race_ob()))){
    part = (this_object()->query_race_ob())->query_ac(type, amount, zone);
    if(part > max) {
      max = part;
      most = stopped;
    }
    total += part;
    amount -= part;
  }
  if(amount > 0) {
    if(!stopped && type != "skin")
      stopped = skin;
    if(type == "fire") {
      if(this_object()->effects_matching("body.wetness") &&
         sizeof((int *)this_object()->effects_matching("body.wetness"))) {
        this_object()->add_effect("/std/effects/other/wetness", -amount );
      }
    }
    part = ::query_ac(type, amount, zone);
    if(part > max) {
      max = part;
      most = stopped;
    }
    total += part;
    amount -= part;
  }
  if(amount > 0 && most) {
    stopped = most;
  }
  return total;
}
mixed *stats() {
   return ::stats() + ({
      ({ "skin", skin }),
   });
}

==================================================
FILE: living/carrying.c
==================================================

#include <clothing.h>
#include <money.h>
object* query_wearing();
protected varargs string *query_types_worn( object *things ) {
   int i;
   string *types;
   mixed *stuff;
   types = ({ });
   if ( !things ) {
      things = (object *)this_object()->query_wearing();
   }
   stuff = (mixed *)things->query_type();
   for ( i = sizeof( stuff ) - 1; i > -1; i-- ) {
      if ( stringp( stuff[ i ] ) ) {
         stuff[ i ] = ({ stuff[ i ] });
      }
      if ( !pointerp( stuff[ i ] ) ) {
         printf( "%O (%s) has an invalid type.  Please bug report it.\n",
                 things[ i ], (string)things[ i ]->query_short() );
         stuff[ i ] = ({ "broken" });
      }
      types += stuff[ i ];
   }
   return ({ types, stuff });
}
object* query_wearing_hidden(object looker, object *things) {
   mixed* bing;
   string* types;
   mixed* obj_types;
   object* worn;
   object* ret;
   int i;
   int found_under;
   string fluff;
   string under_type;
   string* under;
   if (!things) {
      worn = query_wearing();
   } else {
      worn = things;
   }
   bing = query_types_worn( worn );
   types = bing[0];
   obj_types = bing[1];
   ret = ({ });
   for (i = 0; i < sizeof(worn); i++) {
      if (worn[i]->query_visible(looker)) {
         found_under = 0;
         foreach (fluff in obj_types[i]) {
            under = CLOTHING_HANDLER->query_clothing_hiding( fluff );
            if ( under && sizeof(under)) {
               foreach (under_type in under) {
                  if (member_array(under_type, types) != -1) {
                     ret += ({ worn[i] });
                     found_under = 1;
                     break;
                  }
               }
            }
            if (found_under) {
               break;
            }
         }
      } else {
         ret += ({ worn[i] });
      }
   }
   return ret;
}
protected string armour_list( object *things, int hidden_only, int self) {
   string word;
   object* hidden;
   hidden = query_wearing_hidden( this_player(), things);
   if (hidden_only) {
      things = filter(hidden, (: $1->query_visible( this_player() ) :));
   } else {
      things = things - hidden;
   }
   if ( !sizeof( things ) ) {
      return 0;
   }
   if (!self) {
      things = sort_array(things,
               (: CLOTHING_HANDLER->query_clothing_depth($2->query_type())  -
                  CLOTHING_HANDLER->query_clothing_depth($1->query_type()) :));
   }
   word = query_multiple_short( things );
   return word;
}
string query_living_contents( int self ) {
   string s;
   string fish;
   string *limbs;
   string *bits;
   string *strs;
   object *holding;
   object *arms;
   object *carry;
   object *conts;
   object money;
   object ob;
   int i;
   int coins;
   int pos;
   s = "";
   strs = ({ });
   conts = ({ });
   limbs = this_object()->query_limbs();
   if (!limbs) {
      limbs = ( this_object()->query_race_ob() )->query_limbs();
   }
   conts = filter(all_inventory(), (: $1->short(0) :) );
   if(!limbs || !sizeof(limbs))
     holding = ({ });
   else
     holding = (object *)this_object()->query_holding() + ({ });
   arms = (object *)this_object()->query_armours() - holding;
   money = present(MONEY_ALIAS, this_object());
   if(!arms) {
      arms = ({ });
   }
   carry = conts - arms - holding - ({ money });
   for (i = 0; i < sizeof(holding); i++) {
     if (holding[i] && environment(holding[i]) == this_object()) {
       bits = ({ limbs[i] });
       ob = holding[i];
       holding[i] = 0;
       while ((pos = member_array(ob, holding)) != -1) {
         bits += ({ limbs[pos] });
         holding[pos] = 0;
       }
       strs += ({  ob->a_short() + " (" +
                     query_multiple_short(bits, "a", 1)+")" });
     }
   }
   if (sizeof(strs)) {
      s += "$I$+10,+0=%^RED%^Holding%^RESET%^ : " +
         query_multiple_short( strs ) +
         ".\n$I$-10,-0=";
   }
   if ( sizeof( arms ) ) {
      if ( fish = armour_list( arms, 0, self) ) {
         s += "$I$+10,+0=%^YELLOW%^Wearing%^RESET%^ : " + fish +
            ".\n$I$-10,-0=";
      }
      if ( self && (fish = armour_list(arms, 1, self) ) ) {
         s += "$I$+10,+0=%^YELLOW%^(under)%^RESET%^ : " + fish +
            ".\n$I$-10,-0=";
      }
   }
   if ( sizeof( carry ) ) {
      fish = this_object()->query_contents(0, carry, 1);
      if ( fish ) {
         if (pointerp(fish)) {
            s += "$I$+10,+0=%^GREEN%^" + fish[1] + "%^RESET%^: " + fish[0] +
               "$I$-10,-0=";
         } else {
            s += "$I$+10,+0=%^GREEN%^Carrying%^RESET%^: " + fish +
               "$I$-10,-0=";
         }
      }
   }
   if ( self && environment() &&
        this_object()->check_dark(environment()->query_light()) > -1) {
      if ( money ) {
         fish = query_multiple_short( (string *)money->half_short( 1 ) );
      } else {
         fish = 0;
      }
      if ( s == "" ) {
         s = "You are empty handed.\n";
      }
      s += "Your purse contains " + (fish?fish:"only moths") + ".\n";
   } else if(money) {
      coins = (int)money->query_number_coins();
      if (self) {
         s += "Your purse is ";
      } else {
         s += capitalize( (string)this_object()->query_possessive() ) +
              " purse is ";
      }
      switch(coins) {
      case 0..10:
         s += "home to only moths!\n";
         break;
      case 11..100:
         s += "tinkling with coins.\n";
         break;
      case 101..300:
         s += "bulging with coins.\n";
         break;
      default:
         s += "fit to burst!\n";
         break;
      }
   }
   return s;
}
