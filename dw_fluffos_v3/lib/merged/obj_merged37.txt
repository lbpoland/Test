# Total Tokens: 15966
# Total Files Merged: 18
# Total Characters: 53267

ab.c
==================================================

#include <mail.h>
#include <board.h>
inherit "/obj/misc/board";
int do_transfer(int num, string str);
int do_store(int num, string str);
int do_storeall(string str);
int do_minimum(int num);
int do_maximum(int num);
int do_timeout(int num);
int do_add(string str);
int do_remove(string str);
int do_board(string str);
int do_archive(string str);
int do_killfile(string str);
int do_unkillfile(string str);
void setup() {
  ::setup();
  add_alias("board master");
  action_pri = 3;
  reset_drop();
  set_get();
}
string long(string str, int dark) {
  int i, irp;
  mixed *stuff;
  string ret;
  mapping news_rc;
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  ret = "A bulletin board ("+board_name+").\n";
  irp = (int)BOARD_HAND->query_minimum(board_name);
  if (irp)
    ret += "Minimum number of messages left by automagic deletion is "+ irp +
           ".\n";
  irp = (int)BOARD_HAND->query_maximum(board_name);
  if (irp)
    ret += "Maximum number of messages on this board is "+irp+".\n";
  irp = (int)BOARD_HAND->query_timeout(board_name);
  if (irp)
    ret += "Messages will automagically time out in "+ irp +" days.\n";
  irp = (int)BOARD_HAND->query_archive(board_name);
  if (irp)
    ret += "Deleted messages are archived in "+irp+".\n";
  ret += sprintf("%#-*s\n\n", this_player()->query_cols(),
                            "read <note number>\npost <subject>\n"+
                            "boards\n"+
                            "store <note number> <file>\n"+
          "storeall <file> (optional)\n"+
          "eat <note number>\n"+
                            "reply <note number>\nfollowup <note number>\n"+
                            "summary [all]\nnext\nprev\nnew\n"+
                            "board <board name>\n"+
                            "timeout <time>\nminimum <num>\nmaximum <num>\n"+
                            "archive <name|none>\n"+
                            "security\nsadd <name>\nsremove <name>\n"+
                            "killfile <board name>\nunkillfile <board name>\nlistkillfile\ntransfer <note> <board>");
  if (!sizeof(stuff))
    return ret+"The board is completely empty.\n";
  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  if (!news_rc)
    news_rc = ([ ]);
  for (i=0;i<sizeof(stuff);i++)
    if (news_rc[board_name] < stuff[i][B_TIME])
      ret += sprintf("N %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
             stuff[i][B_SUBJECT]+" ("+
             stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
    else
      ret += sprintf("  %2d: %-=*s\n", i+1, (int)this_player()->query_cols()-6,
             stuff[i][B_SUBJECT]+" ("+
             stuff[i][B_NAME]+" "+the_date(stuff[i][B_TIME])+")");
  return ret;
}
void init() {
   if (environment() == this_player() &&
       this_player()->query_creator()) {
      add_commands();
      add_command("store", "<number> <word>", (: do_store($4[0], $4[1]) :));
      add_command("storeall", "<word>", (: do_storeall($4[0]) :));
      add_command("next", "");
      add_command("prev", "");
      add_command("new", "");
      add_command("board", "<string>", (: do_board($4[0]) :));
      add_command("boards", "");
      add_command("killfile", "<string>", (: do_killfile($4[0]) :));
      add_command("unkillfile", "<string>",(: do_unkillfile($4[0]) :));
      add_command("listkillfile", "");
      add_command("security", "");
      add_command("sadd", "<word>", (: do_add($4[0]) :));
      add_command("sremove", "<word>", (: do_remove($4[0]) :));
      add_command("timeout", "<number>", (: do_timeout($4[0]) :));
      add_command("minimum", "<number>", (: do_minimum($4[0]) :));
      add_command("maximum", "<number>", (: do_maximum($4[0]) :));
      add_command("archive", "<word>", (: do_archive($4[0]) :));
      add_command("summary", "");
      add_command("skip", "");
      add_command("arts", "");
      add_command("transfer", "<number> <string>",
                     (: do_transfer($4[0], $4[1]) :));
   }
}
int do_storeall(string file) {
  int which;
  mixed *stuff;
  int i, j, no, amt, cnt=0;
  string *boards, their_name;
  mapping news_rc;
  seteuid( geteuid( this_player() ) );
  their_name = this_player()->query_name();
  boards = (string *)BOARD_HAND->list_of_boards();
  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  if (!write_file(file, "File created on "+ctime(time())+
                        " - Seattle time\n", 1)) {
    add_failed_mess("Unable to save the file "+file+"\n");
    return 0;
  }
  for (i=0;i<sizeof(boards);i++) {
    if (!this_player()->query_property("news_kill_"+lower_case(boards[i]))) {
      stuff = (mixed *)BOARD_HAND->get_subjects(boards[i]);
      if (!sizeof(stuff))
        continue;
      for (amt=sizeof(stuff)-1;amt >= 0 &&
                               (stuff[amt][B_TIME] > news_rc[boards[i]] &&
                               lower_case(stuff[amt][B_NAME]) != their_name);
                 amt--);
      if (amt != sizeof(stuff)-1) {
        write_file(file,"\n----> Bulletin Board Name: "+boards[i]+"\n\n\n");
        news_rc[boards[i]] = stuff[sizeof(stuff)-1][B_TIME];
        for(j = amt+1;j<sizeof(stuff);j++) {
          write_file(file,"***** Note #" +(j+1)+ " by " +stuff[j][B_NAME]+
       " posted at " +ctime(stuff[j][B_TIME])+ "\nTitle: "+
       stuff[j][B_SUBJECT][0..(int)this_player()->
                                                 query_cols() - 10]+"\n\n"+
                         BOARD_HAND->get_message(boards[i], j)+"\n\n\n");
          if (cnt == 0)
             printf("Storing ");
          cnt++;
          printf(".");
        }
      }
    }
  }
  add_succeeded_mess(this_object(), ({
                   "\n"+cnt+" new messages are now saved in "+file+"\n",
                   "$N appears to scribble something a lot.\n" }), ({ }));
  if (cnt == 0) {
    this_player()->add_property(NEWS_RC, news_rc);
  }
  return 1;
}
int do_store(int which, string file) {
  mixed *stuff;
  stuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (which < 1 || which > sizeof(stuff)) {
    add_failed_mess("Invalid note number.\n");
    return 0;
  }
  which--;
  file += ".note";
  if (!write_file(file,stuff[which][B_SUBJECT]+"\n\n"+
                  BOARD_HAND->get_message(board_name, which))) {
    add_failed_mess("The master object appears and prevents you.\n");
    return 0;
  }
  add_succeeded_mess(this_object(), ({ "Ok.\n", "$N copies some stuff off "
                                       "the board.\n" }), ({ }) );
  return 1;
}
void set_board_name(string str) { board_name = str; }
void set_datafile(string str) { board_name = str; }
int do_next() {
  int i;
  string *boards;
  boards = (string *)BOARD_HAND->list_of_boards();
  if ((i = member_array(board_name, boards)) == -1)
    i = 0;
  else
    i = (i+1)%sizeof(boards);
  board_name = boards[i];
  add_succeeded_mess(this_object(), ({ "Gone to board:"+board_name+".\n",
                      "$N turns their board over.\n" }), ({ }) );
  return 1;
}
int prev() {
  int i;
  string *boards;
  boards = (string *)BOARD_HAND->list_of_boards();
  if ((i = member_array(board_name, boards)) == -1)
    i = 0;
  else
    i = (i-1+sizeof(boards))%sizeof(boards);
  board_name = boards[i];
  add_succeeded_mess(this_object(), ({ "Gone to board:"+board_name+".\n",
                      "$N turns their board over.\n" }), ({ }) );
  return 1;
}
int do_killfile(string arg) {
  this_player()->add_property( "news_kill_" +lower_case( arg ), 1 );
  add_succeeded_mess(this_object(), ({ "Board "+arg+" killed.\n", "" }), ({}));
  return 1;
}
int do_unkillfile(string arg) {
  if (!this_player()->query_property( "news_kill_" +lower_case( arg ) )) {
     add_failed_mess("Board "+arg+" is not kill file anyway.\n");
     return 0;
  } else {
     this_player()->remove_property( "news_kill_" +lower_case( arg ) );
     add_succeeded_mess(this_object(), ({ "Board "+arg+" unkilled.\n", "" }),
                       ({ }));
  }
  return 1;
}
int do_listkillfile(string arg) {
   string property, s1, *boards=({ });
   mixed value;
   foreach ( property, value in this_player()->query_properties() )
      if ( sscanf(property,"news_kill_%s",s1) == 1 &&
           value )
         boards += ({ s1 });
   if ( sizeof( s1 ) )
      tell_object( this_player(), "You have the following boards killfiled: "+
                  query_multiple_short( boards ) +".\n" );
   add_succeeded_mess(this_object(), "", ({ }));
   return 1;
}
int do_new() {
  int i, amt;
  string *boards, their_name;
  mixed *stuff;
  mixed otherstuff;
  mapping news_rc;
  boards = (string *)BOARD_HAND->list_of_boards();
  their_name = this_player()->query_name();
  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  for (i=0;i<sizeof(boards);i++) {
    if (!this_player()->query_property("news_kill_"+lower_case(boards[i]))) {
      stuff = (mixed *)BOARD_HAND->get_subjects(boards[i]);
      if (!sizeof(stuff))
        continue;
      for (amt=sizeof(stuff)-1;amt >= 0 &&
                               (stuff[amt][B_TIME] > news_rc[boards[i]] &&
                                lower_case(stuff[amt][B_NAME]) != their_name);
                 amt--);
      if (amt != sizeof(stuff)-1) {
        board_name = boards[i];
        add_succeeded_mess(this_object(), ({
          "The "+ boards[ i ] +" board has "+ ( sizeof( stuff ) - amt -
          1 ) +" new message"+ ( ( ( sizeof( stuff ) - amt ) > 2 ) ? "s" : "" )
          +".\n", "$N turns over their board.\n" }), ({ }));
        return 1;
      }
    }
  }
  add_failed_mess("No boards with new messages.\n");
  return 0;
}
int do_board(string str) {
  int i;
  string *boards;
  boards = (string *)BOARD_HAND->list_of_boards();
  i = member_array(str, boards);
  if (i == -1) {
    add_failed_mess("The board "+str+" does not exist sorry.\n");
    return 0;
  }
  add_succeeded_mess(this_object(), ({ "Okay, changed to board "+ str +".\n",
                                   "$N turns over their board.\n" }), ({ }));
  board_name = str;
  return 1;
}
int do_boards() {
   write( "The current boards are:\n\""+
         implode( (string *)BOARD_HAND->list_of_boards(), "\", \"" ) +
         "\".\n" );
  return 1;
}
int do_security() {
   write( "The current people in this boards security array are:\n"+
        implode((string *)BOARD_HAND->query_security(board_name), ", ")+"\n");
  return 1;
}
int do_add(string name) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->add_allowed(board_name, name);
}
int do_remove(string name) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->remove_allowed(board_name, name);
}
int do_timeout(int i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_timeout(board_name, i);
}
int do_minimum(string i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_minimum(board_name, i);
}
int do_maximum(int i) {
  if (this_player() != this_player(1) ||
      !interactive(previous_object()))
    return 0;
  return (int)BOARD_HAND->set_maximum(board_name, i);
}
int do_archive(string name) {
  if (!name)
    return 0;
  if (name != "none")
    return (int)BOARD_HAND->set_archive(board_name, name);
  return (int)BOARD_HAND->set_archive(board_name);
}
varargs int move(object dest, string s1, string s2) {
  int ret;
  if (!objectp(dest))
    return ::move(dest, s1, s2);
  if (interactive(dest)) {
    ret = ::move(dest, s1, s2);
    if (ret)
      return ret;
    seteuid(geteuid(dest));
    return 0;
  }
  return ::move(dest, s1, s2);
}
mixed query_static_auto_load() {
  return board_name;
}
void init_static_arg(mixed board) {
  if (stringp(board))
    board_name = board;
}
int do_summary(string str) {
  int i, no, amt;
  string *boards, their_name;
  mapping news_rc;
  mixed *stuff;
  boards = (string *)BOARD_HAND->list_of_boards();
  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  their_name = this_player()->query_name();
  for (i=0;i<sizeof(boards);i++) {
    if (!this_player()->query_property("news_kill_"+lower_case(boards[i]))) {
      stuff = (mixed *)BOARD_HAND->get_subjects(boards[i]);
      if (!sizeof(stuff))
        continue;
      for (amt=sizeof(stuff)-1;amt >= 0 &&
                               (stuff[amt][B_TIME] > news_rc[boards[i]] &&
                               lower_case(stuff[amt][B_NAME]) != their_name);
                 amt--);
      if (amt != sizeof(stuff)-1) {
        printf( "The "+ boards[ i ] +" board has "+ ( sizeof( stuff ) - amt -
          1 ) +" new message"+ ( ( ( sizeof( stuff ) - amt ) > 2 ) ? "s" : "" )
          +".\n" );
        no++;
      } else if (str == "all") {
        printf("The "+boards[i]+" board has no new messages.\n");
        no++;
      }
    }
  }
  if (no) {
    add_succeeded_mess(this_object(), ({ "", "$N runs their finger over "
                                             "thier board.\n" }), ({ }));
  } else {
    add_failed_mess("No boards with new messages.\n");
  }
  return no;
}
int do_skip() {
  mapping news_rc;
  mixed *otherstuff;
  news_rc = (mapping)this_player()->query_property(NEWS_RC);
  otherstuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (sizeof(otherstuff)) {
    news_rc[board_name] = otherstuff[sizeof(otherstuff)-1][B_TIME];
    this_player()->add_property(NEWS_RC, news_rc);
  }
  printf("Marked all of "+board_name+" as read.\n");
  if (!do_new()) {
    printf("No new messages.\n");
  }
  add_succeeded_mess(this_object(), "", ({ }));
  return 1;
}
int do_arts() {
  int i;
  mixed *otherstuff;
  otherstuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  for (i=0;i<sizeof(otherstuff);i++)
    printf("%2d# %-20s %d\n", i, otherstuff[i][B_NAME], otherstuff[i][B_NUM]);
  add_succeeded_mess(this_object(), "", ({ }));
  return 1;
}
int do_transfer(int num, string str) {
  string mess;
  string *boards;
  mixed *otherstuff;
  int i;
  boards = (string *)BOARD_HAND->query_boards();
  otherstuff = (mixed *)BOARD_HAND->get_subjects(board_name);
  if (member_array(str, boards) == -1) {
    add_failed_mess("Cannot find the board '"+str+"'.\n");
    return 0;
  }
  if (num < 1 || num > sizeof(otherstuff)) {
    add_failed_mess("There is no note '"+num+"' on the board '"+
                        board_name+".\n");
    return 0;
  }
  mess = BOARD_HAND->get_message(board_name, num-1);
  if (mess && BOARD_HAND->add_message(str, otherstuff[num-1][B_NAME],
                              otherstuff[num-1][B_SUBJECT],
                              mess)) {
    write("Transfered note "+num+" to board '"+str+
                   "', local copy retained.\n");
    return 1;
  }
  add_failed_mess("Unable to transfer note "+num+" to the board '"+
                      board_name+", no security privilages?\n");
  return 0;
}

==================================================
FILE: misc/boring_stick.c
==================================================

inherit "/std/held";
#include <move_failures.h>
int state;
void set_state(int state);
void setup() {
  set_name("stick");
  set_state(0);
  set_weight(2);
  set_value(10);
}
void init() {
  this_player()->add_command("turn", this_object(),
                                "<direct:object> {on|off}");
  this_player()->add_command("flick", this_object(),
                                "switch on <direct:object>");
  this_player()->add_command("press", this_object(),
                                "switch on <direct:object>");
  this_player()->add_command("push", this_object(),
                                "switch on <direct:object>");
  this_player()->add_command("flick", this_object(),
                                "<direct:object>");
  this_player()->add_command("turn", this_object(),
                                "switch {on|off} on <direct:object>");
  this_player()->add_command("switch", this_object(),
                                "<direct:object> {on|off}");
}
void set_state(int new_state) {
  state = new_state;
  if (state) {
    set_long(
"The long straight black stick vibrates slightly in your hands, you "
"get a nice massage from it.  There is something which looks a bit "
"like a switch down near the base of the stick.  Flashing lights "
"rush up and down the side of the stick in a mad progression.\n");
  } else {
    set_long(
"The long straight black stick vibrates slightly in your hands, you "
"get a nice massage from it.  There is something which looks a bit "
"like a switch down near the base of the stick.\n");
  }
  if (environment())
    if (state) {
      if (living(environment()))
        environment()->add_extra_look(this_object());
    } else
      environment()->remove_extra_look(this_object());
}
string extra_look() {
  return capitalize(previous_object()->query_pronoun())+
         " is surrounded by an aura of bees.\n";
}
int do_turn(mixed *indirect_obs, string indir_match,
            string dir_match, mixed *args, string pattern) {
  int new_state;
  new_state = 0;
  if ("<direct:object> {on|off}" == pattern) {
    if (args[1] == "on")
      new_state = 1;
  } else {
    if (args[0] == "on")
      new_state = 1;
  }
  if (state == new_state) {
    this_player()->add_failed_mess(this_object(),
                   "$D is already turned "+(state?"on":"off")+".\n", ({ }));
    return 0;
  }
  set_state(new_state);
  this_player()->add_succeeded_mess(this_object(),
    "$N $V $D "+(state?"on":"off")+".\n", ({ }));
  return 1;
}
int do_flick() {
  set_state(!state);
  this_player()->add_succeeded_mess(this_object(),
    "$N $V the switch on $D to the "+(state?"on":"off")+" position.\n", ({ }));
  return 1;
}
int do_press() {
  return do_flick();
}
int do_push() {
  return do_flick();
}
int do_switch(mixed *indirect_obs, string indir_match,
              string dir_match, mixed *args, string pattern) {
  int new_state;
  if (args[1] == "on")
    new_state = 1;
  if (state == new_state) {
    this_player()->add_failed_mess(this_object(),
                   "$D is already turned "+(state?"on":"off")+".\n", ({ }));
    return 0;
  }
  set_state(new_state);
  this_player()->add_succeeded_mess(this_object(),
    "$N $V $D "+(state?"on":"off")+".\n", ({ }));
  return 1;
}
mapping query_dynamic_auto_load() {
   return ([ "state" : state,
             "::" : held::query_dynamic_auto_load()
          ]);
}
void init_dynamic_arg(mapping map) {
   set_state(map["state"]);
   if ( map[ "::" ] )
      held::init_dynamic_arg( map[ "::" ] );
}
varargs int move(mixed dest, string str1, string str2) {
  int ret;
  object old;
  old = environment();
  ret = ::move(dest, str1, str2);
  if (ret == MOVE_OK) {
    if (state) {
      if (old)
        old->remove_extra_look(this_object());
      if (living(environment())) {
        environment()->add_extra_look(this_object());
      }
    }
  }
  return ret;
}

==================================================
FILE: misc/bug.c
==================================================

inherit "/std/object";
int no_shots;
void setup() {
   no_shots = 10;
   set_name( "bug");
   set_long( "It sits there, happier than a clam, its long black silvery "
             "legs sticking out the side.  The legs look fixed in place and "
             "there are some silvery words carved onto the top.  When you "
             "shake it, it sounds like it has something rattling around "
             "inside.  There appears to be a spray nozzle at one end.\n");
   add_read_mess("68000\n", "silver writing", "general", 0);
}
void init() {
  add_command("shake", "<direct:object>");
  add_command("spray", "<indirect:object> with <direct:object>");
}
int do_shake() {
   this_player()->add_succeeded_mess(this_object(),
      "$N $V $D and you can hear something rattling around inside.\n", ({ }));
   return 1;
}
int do_spray(object *obs) {
   int i;
   int done;
   if (no_shots <= 0) {
      return 0;
   }
   done = 0;
   for (i = 0; i < sizeof(obs); i++) {
      if (no_shots > 0 && obs[i] != this_object()) {
         obs[i]->add_effect("/std/effects/object/bug_effect", 0);
         no_shots--;
         this_player()->add_succeeded(obs[i]);
         done = 1;
      }
   }
   return done;
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ([ "::" : ::query_dynamic_auto_load(),
            "shots" : no_shots ]);
   return map;
}
void init_dynamic_arg(mapping map, object foo) {
   ::init_dynamic_arg(map["::"]);
   no_shots = map["shots"];
}

==================================================
FILE: misc/button.c
==================================================

inherit "std/object";
void setup() {
   set_name( "button" );
   set_short( "red button" );
   add_adjective( "red" );
   set_long( "This red button destructs all non-user objects in "
         "the room.  USE WITH EXTREME CAUTION.\n");
   reset_get();
   add_property( "there", "embedded into the wall" );
}
void init() {
   this_player()->add_command( "press" , this_object() );
}
int do_press() {
   object thing, *things;
   things = (object *)environment()->query_non_destable();
   if ( !things )
      things = ({ this_object() });
   else
      things += ({ this_object() });
   foreach ( thing in all_inventory( environment() ) - things )
      if ( !userp( thing ) )
         thing->dest_me();
   write( "You clean up.\n" );
   say( (string)this_player()->one_short() +" cleans up.\n" );
   return 1;
}

==================================================
FILE: misc/camera.c
==================================================

#include <weather.h>
inherit "/std/object";
int  colour;
int  black_white;
int  scene;
void setup() {
  colour = 2;
  black_white = 4;
  scene = 1;
  set_name( "box" );
  add_adjective( ({ "heavy" , "black" }) );
  set_short( "heavy black cube" );
  set_main_plural( "heavy black cubes" );
  set_long( "You see a heavy black box with a window on one side.  "
            "Looking through the window, you notice a tiny demon sitting "
            "patiently next to a miniscule painter's easel.\n" );
  set_weight( 10 );
  add_alias( ({ "cube" , "camera" }) );
  add_plurals(({ "cubes", "cameras"}));
  adjust_money( 1 , "gold" );
  add_help_file("camera");
}
void init() {
    add_command("use", "<direct:object> on <indirect:object>");
    add_command("use", "<direct:object>");
}
int query_colour()      { return colour;  }
int query_black_white() { return black_white;  }
int do_use(object *obs) {
  int i;
  string view;
  string photo_of;
  string chars_sorted;
  string things_sorted;
  object *players;
  object *chars;
  object *things;
  object  photo;
  object  env;
  object *yes;
  players = ({ });
  chars = ({ });
  things = ({ });
  yes = ({ });
  view = "";
  photo_of = "";
  chars_sorted = "";
  things_sorted = "";
  env = environment(this_player()) ;
  photo_of = "This is a beautiful ";
  if (env->query_light() < 60) {
    this_player()->add_failed_mess(this_object(),
                                   "The little imp whispers: Hey! "
                                   "Not everyone like you can see "
                                   "in the dark you know.\n",({ }));
    return 0;
  }
  if (env->query_light() >180) {
    this_player()->add_failed_mess(this_object(),
                                   "The little demon said quietly: "
                                   "Could I have a pair of sunspecs "
                                   "please! Not too much to ask, is it?\n",
                                   ({ }));
    return 0;
  }
  if (black_white <= 0) {
    call_out("out_of_paint", 0, env);
    this_player()->add_failed_mess(this_object(),
                                   "The little imp gives up painting "
                                   "for you.\n",({ }));
    return 0;
  }
  if (colour > 1) {
    photo_of += "colour ";
    colour --;
  } else if (colour == 1) {
    photo_of += "colour ";
    call_out("out_of_colour", 2, env);
    colour --;
  } else {
    photo_of += "black and white ";
    black_white --;
  }
  if (sizeof(obs)) {
    for (i=0;i<sizeof(obs);i++) {
      if (obs[i]->query_property("player")) {
        players += ({ obs[i] });
        this_player()->add_succeeded(obs[i]);
        yes  += ({ obs[i] });
      } else if (obs[i]->query_property("npc")) {
        chars   += ({ obs[i] });
        this_player()->add_succeeded(obs[i]);
        yes  += ({ obs[i] });
      } else {
        if (environment(obs[i]) != this_player()) {
          things  += ({ obs[i] });
          this_player()->add_succeeded(obs[i]);
          yes  += ({ obs[i] });
        }
      }
    }
    chars_sorted = query_multiple_short(chars);
    things_sorted = query_multiple_short(things);
    if (chars_sorted || things_sorted || sizeof(players)) {
      scene = 0;
    }
  }
  view = env->query_long();
  if(view[sizeof(view)-1] != 10)
    view += "\n";
  if(env->query_property("location") == "outside" &&
     !env->query_weather_obscured(WEATHER->query_day())) {
    view = WEATHER->weather_string(env) + ".  " + view;
  }
  photo_of += "picture of " + env->a_short() + ".";
  if (scene == 0) {
    if ((sizeof(chars)+sizeof(players)) == 1) {
      if (sizeof(chars) == 1) {
        view += capitalize( (string)chars[0]->query_short() ) +
          " is here smiling.\n";
      } else if (sizeof(players) == 1) {
        view += players[0]->one_short() +" is here smiling.\n";
      }
    } else if ((sizeof(players)+sizeof(chars)) > 1) {
      for(i=0;i<sizeof(players);i++) {
        view += players[i]->one_short() ;
        if (i < (sizeof(players)-1)) {
          view += ", ";
        }
      }
      if (chars_sorted != "" && sizeof(players) > 0) {
        view += ", " + chars_sorted ;
      } else if (chars_sorted != "") {
        view += capitalize(chars_sorted) ;
      }
      view += " are smiling here.\n";
    }
    if (sizeof(things) == 1) {
      view += "There is a "+ things_sorted +" in the photo.\n";
    } else if ( sizeof( things ) ) {
      view += "There are " + things_sorted+" lying here in the photo.\n" ;
    }
  }
  photo = clone_object("/std/object");
  photo->set_name("glass");
  photo->add_adjective( ({"tiny", "square"}) );
  photo->set_short("tiny square of glass");
  photo->set_main_plural("tiny squares of glass");
  photo->set_long("/global/events"->convert_message(view));
  photo->set_read_mess(photo_of);
  photo->add_property("photographer", (string)this_player()->query_name()) ;
  photo->move(this_player());
  if (scene == 0) {
    this_player()->add_succeeded_mess(this_object(),
                                      "$N $V $D on $I. After some frantic "
                                      "sounds of pens scratching and "
                                      "brushes brushing, a tiny "
                                      "demon inside hands a piece of painted "
                                      "glass to $N.\n", yes);
  } else {
    this_player()->add_succeeded_mess(this_object(),
                                      "$N $V $D on the scenery. After some "
                                      "frantic sounds of pens scratching "
                                      "and brushes brushing, a "
                                      "tiny demon inside hands a piece "
                                      "of painted glass to $N.\n");
  }
  return 1;
}
mapping query_static_auto_load() {
  return ([ "colour" : colour,
          "black_white" : black_white ]);
}
void init_static_arg(mapping map) {
  colour = map["colour"];
  black_white = map["black_white"];
}
void out_of_paint(object room) {
  tell_object(this_player(), "The tiny demon whispers sarcastically: "
              "Without any more paints, I can still paint "
              "you invisible picture if you like!\n");
  tell_room(room, "The tiny demon in the cube whispers something about "
            "paints to "+ this_player()->one_short() +".\n",
            this_player());
}
void out_of_colour(object room) {
  tell_object(this_player(), "The tiny demon whispers: There are no more "
              "colour paints. This picture is the "
              "last colour one. I can only do you "
              "black and white pictures from now!\n");
  tell_room(room, "The tiny demon in the cube whispers something about "
            "colour to "+ this_player()->one_short() +".\n",
            this_player());
}

==================================================
FILE: misc/case.c
==================================================

#define READ "/cmds/living/r_ead"
inherit "/obj/baggage";
void setup() {
  set_name("case");
  set_long("This is a nice glass display case that looks out of place "
           "here, you could \"peruse\" things in it perhaps.\n");
  add_alias("container");
  add_adjective("display");
  set_transparent();
  set_weight(1000);
  set_main_plural("cases");
  set_max_weight(500000);
  reset_get();
  reset_drop();
}
void init() {
  this_player()->add_command( "peruse", this_object(),
                              "<indirect:object:direct-obs> in <direct:object>");
}
int do_peruse( object *obs ) {
  obs = filter( obs, (: environment( $1 ) == this_object() :) );
  if ( !sizeof( obs ) ) {
    add_failed_mess( "You have to browse something in the display case.\n" );
    return 0;
  }
  if ( sizeof( obs ) > 1 ) {
    add_failed_mess( "You can only browse 1 thing at a time.\n" );
    return 0;
  }
  write( "You peruse the "+ obs[0]->query_short() +".\n" );
  write( obs[0]->long() );
  READ->cmd( ({ obs[0] }) );
  this_player()->add_succeeded_mess( this_object(), "" );
  return 1;
}
int test_add( object item, int flag ) {
  if ( base_name( previous_object( 1 ) )[0..4] == "/cmds" ) {
    if ( this_player()->query_creator() )
      return 1;
    else return 0;
  }
  return 1;
}
int test_remove( object item, int flag ) {
  if ( base_name( previous_object( 1 ) )[0..4] == "/cmds" ) {
    if ( this_player()->query_creator() )
      return 1;
    else return 0;
  }
  return 1;
}
void setup_case( string name, string long ) {
  add_alias( name );
  set_long( long + "You feel you could \"peruse\" things in it.\n" );
}

==================================================
FILE: misc/cash_register.c
==================================================

#include <money.h>
inherit "/std/container";
object shop;
object query_shop() { return shop; }
void set_shop( object thing ) { shop = thing; }
string long( string word, int dark ) {
   int i;
   string ret, *coins;
   object cash;
   ret = query_long();
   cash = present( MONEY_ALIAS, this_object() );
   if ( !cash )
      return ret +"There is no money in the register.\n";
   coins = (string *)cash->half_short( 1 );
   if ( !sizeof( coins ) )
      return ret +"There is no money in the register.\n";
   ret += "The register contains:\n";
   for ( i = 0; i < sizeof( coins ); i++ )
      ret += "      "+ coins[ i ] +"\n";
   return ret;
}
int test_add( object thing, int flag ) {
   if ( !thing->id( MONEY_ALIAS ) )
      return 0;
   if ( shop )
      shop->save_register();
   return 1;
}
int test_remove( object thing, int flag ) {
   if ( shop )
      shop->save_register();
   return 1;
}

==================================================
FILE: misc/chicken_feather.c
==================================================

inherit "/std/object";
void setup() {
 set_name("feather");
 set_short("chicken feather");
 set_main_plural("chicken feathers");
 add_adjective("chicken");
 add_plural("feathers");
 add_adjective("chicken");
 set_weight(1);
 set_long("This is a feather that was plucked from a chicken.\n");
}

==================================================
FILE: misc/club_badge.c
==================================================

#include <clubs.h>
#include <broadcaster.h>
inherit "/obj/clothing";
inherit "/std/basic/club_insignia";
protected int club_members(int online);
protected int do_recruit(object *players, string club);
protected int club_chat(string str, int emote);
protected int club_members(int online);
protected int club_info();
protected int do_history();
private string *extra_adjs;
void setup() {
   extra_adjs = ({ });
   set_name("badge");
   add_adjective("club");
   set_type("badge");
   set_short("club badge");
   setup_clothing(1000);
   set_damage_chance(5);
   set_long("The badge is a nice blue colour with a fringe "
            "like a bunny rabbit.\n");
   add_extra_look(this_object());
}
string extra_look() {
   string tmp_name;
   if (query_club() &&
       CLUB_HANDLER->is_member_of(query_club(), this_player()->query_name())) {
      tmp_name = replace(lower_case(query_club()), " ", "_");
      return "  You feel like the command '" + tmp_name + "' does something.\n";
   }
   return "\n";
}
void init() {
   club_insignia::init();
}
mapping query_dynamic_auto_load(mapping map) {
   map = clothing::query_dynamic_auto_load();
   map = club_insignia::query_dynamic_auto_load(map);
   map["verSion"] = 1;
   return map;
}
void init_dynamic_arg(mapping map) {
   if (map["verSion"] != 1) {
      clothing::init_dynamic_arg(map["::"]);
   } else {
      clothing::init_dynamic_arg(map);
   }
   club_insignia::init_dynamic_arg(map);
}
void set_club(string name) {
   if (!name) {
      extra_adjs = ({ });
      set_short("club badge");
   } else {
      if (CLUB_HANDLER->is_club(name)) {
         name = CLUB_HANDLER->query_club_name(name);
         extra_adjs = explode(lower_case(name), " ");
            set_short("club badge");
      }
   }
   ::set_club(name);
}
string *parse_command_adjectiv_id_list() {
   return ::parse_command_adjectiv_id_list() +
           extra_adjs;
}
mixed *stats()
{
  return clothing::stats() +
    club_insignia::stats();
}

==================================================
FILE: misc/crystal_phial.c
==================================================

inherit "/obj/vessel";
void setup() {
   set_name( "phial" );
   set_short( "crystal phial" );
   add_adjective( "crystal" );
   set_main_plural( "crystal phials" );
   set_long( "This is a small tube-like bottle made of some sort of "+
         "crystal.  A stopper is attached at one end on a bit of wire.\n" );
   set_weight( 1 );
   set_value( 1000 );
   set_max_weight( 1 );
   set_max_volume( 10 );
   set_transparent();
}
int test_add( object thing, int flag ) {
   string word;
   object *things;
   if ( !this_player() )
      return ::test_add( thing, flag );
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return ::test_add( thing, flag );
   word = (string)things[ 0 ]->query_medium_alias();
   if ( word == (string)thing->query_medium_alias() )
      return ::test_add( thing, flag );
   write( "You don't want to contaminate "+ ( stringp( word ) ?
         (string)things[ 0 ]->the_short() :
         (string)thing->the_short() ) +", do you?\n" );
   return 0;
}
object query_substance() {
   object *things;
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return 0;
   if ( !stringp( (string)things[ 0 ]->query_medium_alias() ) )
      return 0;
   return things[ 0 ];
}
string short( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::short( dark );
   return ::short( dark ) +" of "+ (string)thing->short( dark );
}
string query_plural( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::query_plural( dark );
   return ::query_plural( dark ) +" of "+ (string)thing->short( dark );
}
string *parse_command_adjectiv_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_adjectiv_id_list();
   return ::parse_command_adjectiv_id_list() + ({ "of" }) +
      (string *)thing->query_adjectives();
}

==================================================
FILE: misc/dart_board.c
==================================================

#include <player_handler.h>
inherit "/std/object";
string  *creators, name1, name2, target;
object  player1, player2;
int     score1, score2, in_use, thrown, bet;
void setup();
void init();
int abandon( string str );
string find_target();
int play( string str );
int throw_dart();
int score_it( int i );
void heart_beat();
void end_game();
void setup() {
  set_name("dartboard");
    add_property( "there", "mounted on the wall" );
  add_adjective("party");
  set_main_plural("dartboards");
  set_short("party dartboard");
  set_long("This is a party dartboard.  It's round, with concentric "
    "circles in black and yellow painted on it.\n");
  set_weight(10000);
  set_value(0);
  reset_get();
  set_read_mess(
    "This is a game of darts for two players. Before beginning "
    "their throws, the players must both type 'play'. Each player "
    "in turn can then throw three darts at the board (by typing "
    "'throw' three times). Note that your accuracy is affected "
    "by your DEX stat. The winner of the game is the player with the "
    "highest score after all darts have been thrown.\n" );
}
void init() {
  add_command("abandon", "", (:this_object()->abandon(""):));
  add_command("play", "", (:this_object()->play(0):));
  add_command("throw", "", (:this_object()->throw_dart():));
}
int abandon( string str ) {
  if (this_player() == player1 || this_player() == player2) {
    write("You call off the game of darts.\n");
    say("The game of darts is called off by "
      + this_player()->query_short()+".\n");
    end_game();
    return 1;
  }
}
string find_target() {
  string *creators, victim;
  creators = get_dir("/w/");
  victim = (creators[(random(sizeof(creators)))]);
  while (!PLAYER_HANDLER->test_user(victim) ) {
    victim = (creators[(random(sizeof(creators)))]);
}
  return capitalize(victim);
}
int play( string str ) {
  int val;
  if (in_use) {
    write("The dartboard is in use right now.\n");
    return 1;
  }
  if (!str) str = "0";
  if (!sscanf(str, "%d", val) || val < 0) {
    write("Bets must be for zero or greater coins.\n");
    return 1;
  }
  if (this_player()->query_money() < val) {
    write("Betting is not yet supported... I'm working on it! "
   "Just type \"play\".\n");
    return 1;
  }
  if (player1) {
    if (this_player() == player1) {
      write("You can't play against yourself!\n");
      return 1;
    }
    if (val != bet) {
      write("Bet amounts must match. " + name1 + " bet " + bet + ".\n");
      return 1;
    }
    player2 = this_player();
    name2 = player2->query_short();
    target = find_target();
    tell_room( environment(), name1 + " and " + name2 +
      " have started a game of darts, throwing at " + target
      + ".\n", ({ player1, player2 }) );
    tell_object( player2, "You accept " + name1 + "'s challenge, "
      "and you both prepare to throw darts at " + target + ".\n" );
    tell_object( player1, name2 + " accepts your challenge, and you "
      "both prepare to throw darts at " + target + ".\nThrow your darts.\n");
    in_use = 1;
    return 1;
  }
  bet = val;
  player1 = this_player();
  name1 = player1->query_short();
  write("You can 'abandon' the game if no one takes up your challenge.\n");
  say( name1 + " is looking for someone else to play darts with.\n");
  set_heart_beat(1);
  return 1;
}
int throw_dart() {
  int hit;
  string start;
  if (!in_use)  {
     return notify_fail( "You are not currently playing.\n ");
  }
  if (this_player() != player1 && this_player() != player2)  {
     return notify_fail( "You are not currently playing.\n" );
  }
  if (in_use == 1 && this_player() == player1) {
    thrown += 1;
    write("You throw a dart.\n");
    say( name1 + " throws a dart.\n" );
    hit = score_it(random(21) + ((player1->query_dex() -13 ) / 2 ));
    if (hit == 500 && bet >= 50) {
      write("You feel a bit more experienced.\n");
      player1->ajdust_xp(10);
    }
    score1 += hit;
    if (thrown == 3) {
      write("That was your third dart. Your score is " + score1 + ".\n");
      say(name1 + " has a score of " + score1 + " after three darts.\n");
      if (player2) tell_object(player2, "Your turn to throw.\n");
      in_use = 2;
    }
    return 1;
  }
  if (in_use == 2 && this_player() == player2) {
    thrown += 1;
    write("You throw a dart.\n");
    say(name2+ " throws a dart.\n" );
    hit = score_it(random(21) + ((player2->query_dex() - 13 ) / 2 ));
    if (hit == 500 && bet >= 50) {
      write("You feel a bit more experienced.\n");
      player2->adjust_xp(10);
    }
    score2 += hit;
    if (thrown == 6) {
      write("That was your third dart.\n");
      if (score1 > score2) {
        start = " with a score of " + score1 + " to " +
          score2 + ".\n";
        write(name1 + " beats you" + start);
        tell_room( environment(), name1 + " beats " + name2 + start,
                ({ player1, player2 }));
        tell_object(player1, "You beat " + name2 + start);
      } else if (score2 > score1) {
        start = " with a score of " + score2 + " to " +
          score1 + ".\n";
        write("You beat " + name1 + start);
        tell_room( environment(), name2 + " beats " + name1 + start,
                    ({ player1, player2 }));
        tell_object(player1, name2 + " beats you" + start);
      } else {
        tell_room(environment(this_object()),
          "It's a tie with a score of " + score1 + "!\n");
      }
      end_game();
    }
    return 1;
  }
  write("It's not your turn to throw a dart!\n");
  return 1;
}
int score_it( int i ) {
  string rest_mess;
  int ret;
  if (i < 2) {
    rest_mess = "the wall. No score.\n";
    ret = 0;
  } else if (i < 19) {
    rest_mess = "number "+i+", scoring "+(i*5)+".\n" ;
    ret = i * 5;
  } else if (i == 19) {
    rest_mess =  target+"'s face! Score of 250!\n";
    ret = 250;
  } else {
    rest_mess = target+"'s nose! Score of 500!\n";
    ret = 500;
  }
  write("You hit " + rest_mess);
  say( this_player()->query_short() + " hit " + rest_mess);
  return ret;
}
void heart_beat() {
  if (!player1) player1 = find_player(lower_case(name1));
  if (name2 && !player2) player2 = find_player(lower_case(name2));
  if (!player1 || environment() != environment(player1))
    say(name1 + " is no longer here. The game of darts is called off.\n");
  else if (name2 && (!player2 || environment() != environment(player2)))
    say(name2 + " is no longer here. The game of darts is called off.\n");
  else
    return;
  end_game();
}
void end_game() {
  set_heart_beat(0);
  in_use  = 0; bet    = 0; thrown  = 0;
  player1 = 0; player2 = 0;
  name1  = 0; name2  = 0;
  score1  = 0; score2  = 0;
}

==================================================
FILE: misc/dead_book.c
==================================================

inherit "/std/book_dir";
#define DEAD_PAGES "/save/books/dead/dead_page"
void setup() {
  int i, max;
  seteuid(getuid());
  add_property("dead usable", 1);
  set_short("dark brown book");
  set_name("book");
  add_adjective( ({ "dark", "brown", "dead", "death", "dieing" }) );
  set_long("The book has some writing "
           "burnt into the dark brown leather cover.\n");
  add_read_mess("Introduction to death, or what to "
                "do when your blood runs out", 0, "general", 0 );
  set_book_language("general");
  set_book_dir(DEAD_PAGES);
  set_open_page(0);
}
void recovery_from_death() {
  call_out((: tell_object($1, the_short()+" crumbles and vanishes "
                              "mysteriously.\n") :), 1, previous_object());
  call_out("dest_me", 2);
}
mixed query_static_auto_load() { return 0; }
mixed query_dynamic_auto_load() { return 0; }
mixed query_auto_load() { return 0; }
void check_location() {
  if (environment() &&
      !environment()->query_property("dead") &&
      !environment()->query_creator()) {
    say(the_short()+" vanishes suddenly and randomly.\n");
    call_out("dest_me", 1);
  }
}
varargs int move(object dest, string mess1, string mess2) {
  ::move(dest, mess1, mess2);
  call_out("check_location", 1);
}

==================================================
FILE: misc/dead_chicken.c
==================================================

#include <move_failures.h>
#define CHICKEN_FEATHER "/obj/misc/chicken_feather"
#define MIN_FEATHERS 3
#define MAX_FEATHERS 5
inherit "/obj/food";
void    setup();
void    init();
int     do_pluck( object *indirect_obs, string indir_match, string dir_match,
                 mixed *args, string pattern );
mixed   query_dynamic_auto_load();
void    init_dynamic_arg(mapping arg, object);
int plucked;
void setup()
{
  set_name( "chicken" );
  set_short( "dead chicken" );
  add_alias( ({ "corpse", "chicken corpse" }) );
  add_adjective( "dead" );
  set_main_plural( "dead chickens" );
  set_long( function()
            {
              if( plucked )
                return
                  "This is the dead body of a bedraggled chicken.  "
                  "Judging from the total lack of feathers it is "
                  "ready to be cooked.\n";
              return
                  "This is the dead body of a bedraggled chicken.  "
                  "Most people would pluck the few feathers on it "
                  "and then cook it.\n";
            } );
  set_weight( 8 );
  set_value( 300 );
  set_weight_per_bite( 2 );
}
void init()
{
  ::init();
  this_player()->add_command( "pluck", this_object(),
        "<direct:object:me-here>" );
}
int do_pluck( object *indirect_obs, string indir_match, string dir_match,
   mixed *args, string pattern )
{
  object pluck;
  int feathers = random( MAX_FEATHERS - MIN_FEATHERS ) + MIN_FEATHERS;
  if ( plucked ) return notify_fail( "The chicken is already plucked and "
    "bare of any feathers.\n" );
  plucked = 1;
  for ( int i = 0; i < feathers; i++ ) {
    pluck = clone_object( CHICKEN_FEATHER );
    if( MOVE_OK != pluck->move( this_player() ) )
        pluck->move( environment() );
  }
  tell_room( environment( this_player() ),
        this_player()->one_short() + " plucks a dead chicken with reckless "
          "abandon.\n",
        this_player() );
  return notify_fail( "You pluck the bedraggled, dead chicken cheerfully.\n" );
}
mixed query_dynamic_auto_load() {
  return ([ "::" : ::query_dynamic_auto_load(),
            "plucked" : plucked ]);
}
void init_dynamic_arg(mapping arg, object) {
  ::init_dynamic_arg(arg["::"]);
  plucked = arg["plucked"];
}

==================================================
FILE: misc/dead_duck.c
==================================================

#include <move_failures.h>
#define DUCK_FEATHER "/obj/misc/duck_feather.ob"
#define MIN_FEATHERS 3
#define MAX_FEATHERS 5
inherit "/obj/food";
void    setup();
void    init();
int     do_pluck( object *indirect_obs, string indir_match, string dir_match,
                 mixed *args, string pattern );
mixed   query_dynamic_auto_load();
void    init_dynamic_arg(mapping arg, object);
int plucked;
void setup()
{
  set_name( "duck" );
  set_short( "dead duck" );
  add_alias( ({ "corpse", "duck corpse" }) );
  add_adjective( "dead" );
  set_main_plural( "dead ducks" );
  set_long( function()
            {
              if( plucked )
                return
                  "This is the dead body of a bedraggled duck.  Judging "
                  "from the lack of feathers it is ready to be "
                  "cooked.\n";
              return
                  "This is the dead body of a bedraggled duck.  "
                  "Most people would pluck it and then cook it.\n";
            } );
  set_weight( 10 );
  set_value( 400 );
  set_weight_per_bite( 2 );
}
void init()
{
  ::init();
  this_player()->add_command( "pluck", this_object(),
        "<direct:object:me-here>" );
}
int do_pluck( object *indirect_obs, string indir_match, string dir_match,
   mixed *args, string pattern )
{
  object pluck;
  int feathers = random( MAX_FEATHERS - MIN_FEATHERS ) + MIN_FEATHERS;
  if ( plucked ) return notify_fail( "The duck is already plucked and "
    "bare of any feathers.\n" );
  plucked = 1;
  for ( int i = 0; i < feathers; i++ ) {
    pluck = clone_object( DUCK_FEATHER );
    if( MOVE_OK != pluck->move( this_player() ) )
        pluck->move( environment() );
  }
  tell_room( environment( this_player() ),
        this_player()->one_short() + " plucks a dead duck with reckless "
          "abandon.\n",
        this_player() );
  return notify_fail( "You pluck the bedraggled, dead duck cheerfully.\n" );
}
mixed query_dynamic_auto_load() {
  return ([ "::" : ::query_dynamic_auto_load(),
            "plucked" : plucked ]);
}
void init_dynamic_arg(mapping arg, object) {
  ::init_dynamic_arg(arg["::"]);
  plucked = arg["plucked"];
}

==================================================
FILE: misc/dead_eel.c
==================================================

#include <move_failures.h>
#define EEL_SKIN "/obj/misc/eel_skin"
inherit "/obj/food";
void    setup();
void    init();
int     do_skin( object *indirect_obs, string indir_match, string dir_match,
                 mixed *args, string pattern );
int     test_sharp( object weapon );
mixed   query_dynamic_auto_load();
void    init_dynamic_arg(mapping arg, object);
int skinned;
void setup()
{
  set_name( "eel" );
  set_short( "dead eel" );
  add_alias( ({ "corpse", "eel corpse" }) );
  add_adjective( "dead" );
  set_main_plural( "dead eels" );
  set_long( function()
	    {
	      if( skinned )
		return
		  "This is the dead body of an unfortunate eel.  "
		  "As if being dead wasn't bad enough, it has also "
		  "been skinned.\n";
	      return
		  "This is the dead body of an unfortunate eel.  "
		  "Most people skin such a fish before eating it.\n";
	    } );
  set_weight( 60 );
  set_value( 200 );
  set_weight_per_bite( 2 );
}
void init()
{
  ::init();
  this_player()->add_command( "skin", this_object(),
        "<direct:object:me-here> with <indirect:object:me>" );
}
int do_skin( object *indirect_obs, string indir_match, string dir_match,
   mixed *args, string pattern )
{
  object skin;
  if ( skinned ) return notify_fail( "The eel is already skinned.\n" );
  if( !test_sharp( indirect_obs[0] ) )
    {
      tell_room( environment( this_player() ),
	     this_player()->one_short() + " unsuccessfully tries to "
             "skin an eel with " + indirect_obs[0]->one_short() + ".\n",
             this_player() );
      return notify_fail( indirect_obs[0]->the_short() +
            " only makes a shallow mark in the eel skin.  "
            "It would probably be easier to skin the eel "
            "with some kind of sharp implement.\n" );
    }
  skinned = 1;
  skin = clone_object( EEL_SKIN );
  if( MOVE_OK != skin->move( this_player() ) )
        skin->move( environment() );
  tell_room( environment( this_player() ),
        this_player()->one_short() + " skins an eel with "
        + indirect_obs[0]->one_short() + ".\n",
        this_player() );
  return notify_fail( "You skin the dead eel with " +
        indirect_obs[0]->the_short() + ".\n" );
}
int test_sharp( object weapon )
{
  int i;
  mixed *pongo;
  pongo = weapon->weapon_attacks();
  for( i = 1; i < sizeof( pongo ); i++ )
    {
      if( pongo[i] == "sharp" ) return 1;
    }
  return 0;
}
mixed query_dynamic_auto_load() {
  return ([ "::" : ::query_dynamic_auto_load(),
            "skinned" : skinned ]);
}
void init_dynamic_arg(mapping arg, object) {
  ::init_dynamic_arg(arg["::"]);
  skinned = arg["skinned"];
}

==================================================
FILE: misc/delete_thyself.c
==================================================

inherit "/std/object";
void create() {
   ::create();
   if (clonep(this_object())) {
      call_out((: move("/room/rubbish") :), 3);
   }
}
void init_dynamic_arg(mapping map) {
}
void init_static_arg() {
}

==================================================
FILE: misc/deplusser.c
==================================================

inherit "/std/object.c";
void setup()  {
   set_short("deplusser");
   set_name("deplusser");
   set_long("It's shaped like a plus sign set in a circle, with a diagonal "
             "slash across it.  Type 'deplus <path>' to use.");
   set_weight(9);
}
void init()  {
   add_command("deplus", "<string'file'>", (:this_object()->deplus($4[0]):));
}
int deplus( string fname )  {
   string *files, *lines, last_line, this_line, next_line, old;
   int i, j, sz;
   seteuid(geteuid(this_player()));
   files = get_dir( this_player()->get_path( fname ) );
   if ( !sizeof(files) )
      return notify_fail( "No files found\n" );
   for (i = 0; i < sizeof(files); i++ )  {
      if ( file_size( this_player()->get_path( files[i] ) ) == -2 )  continue;
      old = read_file( this_player()->get_path( files[i] ) );
      lines = explode( replace_string( old, "\t", "   " ), "\n" );
      if ( ( sz = sizeof( lines ) ) < 2 )  continue;
      last_line = implode( explode( lines[0], " " ), "" );
      this_line = implode( explode( lines[1], " " ), "" );
      if ( sz > 2 )
         next_line = implode( explode( lines[2], " " ), "" );
      else next_line = "";
      for (j = 1, sz = sizeof(lines); j < sz - 1; j++ )  {
         if ( last_line[<2 .. <1] == "\"+"  &&
             strlen( this_line )  &&  this_line[0] == '\"' )
            lines[j-1] = lines[j-1][0 .. strsrch(lines[j-1], "+", -1) - 1];
         else if ( this_line[0 .. 1] == "+\""  &&
                   strlen(last_line)  && last_line[<1] == '\"' )
            lines[j] = " " + delete( lines[j], strsrch(lines[j], "+"), 1 );
         last_line = this_line;
         this_line = next_line;
         if ( j < sz - 2 )
            next_line = implode( explode( lines[j+2], " " ), "" );
      }
      if ( !rm( this_player()->get_path(files[i]) ) )
         write("Couldn't remove old file: " + files[i] + "\n" );
      else if ( !write_file(this_player()->get_path(files[i]),
                            implode(lines, "\n" ) + "\n" ) )  {
         write("Could not write new file: " + files[i] + "\n" );
         if ( !write_file(this_player()->get_path(files[i]), old ) )
            return notify_fail("Uh-oh, could not replace old file either.\n");
      }
      else write("File deplussed: " + files[i] + "\n");
   }
   return 1;
}

==================================================
FILE: misc/detabber.c
==================================================

inherit "/std/object";
void setup()
{   set_name("detabber");
    set_long("A long stick with absoulutely no tabs in it.\n"
             "Usage:  detab <filename>.\n");
}
void init()
{   this_player()->add_command("detab",this_object(),"<string>");
}
int do_detab(object *indirect_obs, string *dir_match, string indir_match, mixed *args, string pattern)
{
    string file;
    string tb;
    tb = sprintf("\t");
    file = read_file(args[0]);
    if(file)
        {file = replace_string(file,"\t","    ");
         write_file(args[0],file,1);
         return 1;
         }
    return 0;
}
