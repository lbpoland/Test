# Total Tokens: 20933
# Total Files Merged: 6
# Total Characters: 69798

ndlers/map.c
==================================================

#include <map_handler.h>
#include <config.h>
inherit "/obj/handlers/inherit/distance_handler";
mapping shorts = ([ ]);
mapping movezoness = ([ ]);
mapping changetimes = ([ ]);
#if !efun_defined(db_exec)
mapping clusters = ([ ]);
mapping map = ([ ]);
#else
int db, loop = 0;
#include <db.h>
#endif
mapping forced_rooms = ([ ]);
#ifdef COORDS
mapping coords = ([ ]);
mapping sizes = ([ ]);
#endif
int load = 0, time, stopped;
string *cache = ({ }), *queue = ({ });
int check_next_call_out;
mapping stats = ([]);
private void do_room1( string room );
private void check_next();
private void check_map2( string );
void create() {
   seteuid( (string)"secure/master"->get_root_uid() );
   "/room/void"->force_load();
   check_next_call_out = call_out( (: check_next :), SKEWTIME );
#if efun_defined(db_exec)
   db = db_connect("localhost","discworld",CONFIG_DB_USER);
#endif
}
protected void update_cache( string directory, int load ) {
   if ( !shorts[ directory ] || load ) {
      cache = ( cache - ({ directory }) ) + ({ directory });
      if ( sizeof( cache ) > CACHESIZE ) {
         map_delete( shorts, cache[ 0 ] );
         map_delete( movezoness, cache[ 0 ] );
         map_delete( changetimes, cache[ 0 ] );
#if !efun_defined(db_exec)
         map_delete( clusters, cache[ 0 ] );
         map_delete( map, cache[ 0 ] );
#endif
#ifdef COORDS
         map_delete( coords, cache[ 0 ] );
         map_delete( sizes, cache[ 0 ] );
#endif
         cache -= ({ cache[ 0 ] });
         LOG( sprintf( "%%^RED%%^uncaching %s%%^RESET%%^\n", cache[ 0 ] ) );
      }
      shorts[ directory ] = MH->query_shorts( directory );
      movezoness[ directory ] = MH->query_movezones( directory );
      changetimes[ directory ] = MH->query_changetimes( directory );
#if !efun_defined(db_exec)
      clusters[ directory ] = MH->query_clusters( directory );
      map[ directory ] = MH->query_map( directory );
#endif
#ifdef COORDS
      coords[ directory ] = MH->query_co_ords( directory );
      sizes[ directory ] = MH->query_sizes( directory );
#endif
   }
}
void clear_cache() {
   shorts = ([ ]);
   movezoness = ([ ]);
   changetimes = ([ ]);
#if !efun_defined(db_exec)
   clusters = ([ ]);
   map = ([ ]);
#endif
#ifdef COORDS
   coords = ([ ]);
   sizes = ([ ]);
#endif
   cache = ({ });
}
#if !efun_defined(db_exec)
mapping query_map( string dir ) {
   if ( !map[ dir ] ) {
     update_cache( dir, 1 );
   }
   stats["map"]++;
   return map[ dir ];
}
void change_map( string dir, string room, string *dd ) {
   MH->change_map( dir, room, dd );
   map[ dir ][ room ] = dd;
}
#endif
mapping query_shorts( string dir ) {
   if ( !shorts[ dir ] ) {
      update_cache( dir, 1 );
   }
   stats["shorts"]++;
   return shorts[ dir ];
}
void change_shorts( string dir, string room, string sh ) {
   MH->change_shorts( dir, room, sh );
   shorts[ dir ][ room ] = sh;
}
mapping query_movezones( string dir ) {
   if ( !movezoness[ dir ] ) {
      update_cache( dir, 1 );
   }
   stats["movezones"]++;
   return movezoness[ dir ];
}
void change_movezones( string dir, string room, string *zones ) {
   MH->change_movezones( dir, room, zones );
   movezoness[ dir ][ room ] = zones;
}
mapping query_changetimes( string dir ) {
   if ( !changetimes[ dir ] ) {
      update_cache( dir, 1 );
   }
   stats["changetimes"]++;
   return changetimes[ dir ];
}
void change_changetimes( string dir, string room, int time ) {
   MH->change_changetimes( dir, room, time );
   changetimes[ dir ][ room ] = time;
}
#if !efun_defined(db_exec)
mapping query_clusters( string dir ) {
  if ( !clusters[ dir ] ) {
    update_cache( dir, 1 );
  }
  return clusters[ dir ];
}
void change_clusters( string dir, string room, int cluster ) {
   MH->change_clusters( dir, room, cluster );
   if(clusters[ dir ])
     clusters[ dir ][ room ] = cluster;
}
#endif
#ifdef COORDS
mapping query_co_ords( string dir ) {
   if ( !coords[ dir ] )
      update_cache( dir, 1 );
   stats["co_ords"]++;
   return coords[ dir ];
}
void change_co_ords( string dir, string room, int *coord ) {
   MH->change_co_ords( dir, room, coord );
   coords[ dir ][ room ] = coord;
}
mapping query_sizes( string dir ) {
   if ( !sizes[ dir ] )
      update_cache( dir, 1 );
   stats["sizes"]++;
   return sizes[ dir ];
}
void change_sizes( string dir, string room, int *size ) {
   MH->change_sizes( dir, room, size );
   sizes[ dir ][ room ] = size;
}
#endif
void del( string dir, string room ) {
   MH->del( dir, room );
   update_cache( dir, 1 );
}
#if !efun_defined(db_exec)
int query_cluster( string room ) {
  string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
  string troom = explode( room, "/" )[ <1 ];
  if ( troom[ <2.. ] == ".c" ) {
    troom = troom[ 0..<3];
  }
  if( !clusters[ directory ] ) {
    update_cache( directory, 1 );
  }
  if( !clusters[ directory ] ) {
    clusters[ directory ] = ([]);
  }
  return query_clusters( directory )[ troom ];
}
void set_cluster( string room, int cluster ) {
  string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
  string troom = explode( room, "/" )[ <1 ];
  if ( troom[ <2.. ] == ".c" ) {
    troom = troom[ 0..<3];
  }
  change_clusters( directory, troom, cluster);
}
#endif
string *query_dest_dir( string room ) {
#if !efun_defined(db_exec)
  string directory, troom;
#else
  mixed rows;
  string *ret;
  int i = 0;
#endif
  stats["dest_dir"]++;
  if(!room || room == "/" || room == "" || strsrch(room, "/") == -1)
    return ({ });
#if !efun_defined(db_exec)
  directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
  troom = explode( room, "/" )[ <1 ];
  if ( troom[ <2.. ] == ".c" ) {
    troom = troom[ 0..<3];
  }
  if( !query_map( directory )[ troom ] ) {
    check_map2( room );
  }
  return query_map( directory )[ troom ];
#else
  if ( room[ <2.. ] == ".c" ) {
    room = room[ 0..<3];
  }
  if(loop == time())
    return ({});
  loop = time();
  rows = db_exec(db, "select exit, dest from roomexit where id = '%s'", db_escape(room));
  if(stringp(rows)||!rows){
    forced_rooms[ room ] = 1;
    check_map2( room );
    rows = db_exec(db, "select exit, dest from roomexit where id = '%s'", db_escape(room));
    if(stringp(rows)){
      loop = 0;
      return ({ });
    }
  }
  ret = allocate(rows * 2);
  for(i=0; i<rows; i++){
    string *row;
    row = db_fetch(db, i + 1);
    ret[i*2] = row[0];
    ret[i*2+1] = row[1];
  }
  loop = 0;
  return ret;
#endif
}
string *qdd( string room ) {
   return query_dest_dir( room );
}
string query_destination( string exit, string room ) {
   int i;
   string *dest_dir;
   stats["destination"]++;
   if( !room || room == "") {
      room = file_name( environment( previous_object() ) );
      if( !room ) return "/room/void";
   }
   dest_dir = query_dest_dir( room );
   i = member_array( exit, dest_dir );
   if( i < 0 ) return "/room/void";
   return dest_dir[ i + 1 ];
}
string qdes( string exit, string room ) {
   return query_destination( exit, room );
}
string *qdir( string room ) {
   int i;
   string *qddir, *dir=({});
   stats["qdir"]++;
   if( !room || room == "") {
      room = file_name( environment( previous_object() ) );
      if( !room ) return ({ "/room/void" });
   }
   qddir = query_dest_dir( room );
   for( i = sizeof( qddir ) - 2;i > -1;i -= 2)
     dir += ({ qddir[ i ]} );
   return dir;
}
string *query_cache() { return cache; }
string *query_queue() { return queue; }
void set_stopped( int s ) { stopped = s; }
int compare_arrays( mixed *ar1, mixed *ar2 ) {
   int i;
   if ( !ar1 && !ar2 ) return 0;
   if ( sizeof( ar1 ) != sizeof( ar2 ) ) return 1;
   i = sizeof( ar1 );
   while ( i-- ) {
      if ( ar1[ i ] != ar2[ i ] ) {
         return 1;
      }
   }
   return 0;
}
varargs void queue_room( string room, int force, string reason ) {
   queue -= ({ room });
   queue += ({ room });
   forced_rooms[ room ] = force;
#ifdef LOGTO
   if ( !reason ) reason = "";
   LOG( sprintf( "%%^RED%%^Queueing %s(%i) %s.%%^RESET%%^\n",
                room, sizeof( queue ), reason ) );
#else
   reason = reason;
#endif
}
void do_room( string room ) {
   call_out( (: do_room1 :), 1, room );
}
private void do_room1( string room ) {
   mixed tmp;
   int changetime;
   string directory = implode( explode( room, "/" )[ 0 .. <2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" )
      troom = troom[ 0 .. <3 ];
   if ( directory[ 0 ] == 'w' ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ in /w/.\n", room ) );
      return;
   }
   if ( directory[ 0 .. 2 ] == "std" ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ in /std/.\n", room ) );
      return;
   }
   tmp = stat( room +".c" );
   if( !pointerp( tmp ) || sizeof( tmp ) < 2 ) {
      tmp = stat( room );
      if( !pointerp( tmp ) || sizeof( tmp ) < 2 )
         return;
   }
   tmp = find_object( room );
   if ( tmp ) {
      if( tmp->query_property( "no map" ) ) {
         LOG( sprintf( "%%^BLUE%%^Skipping %s%%^RESET%%^, it asked me to.\n",
                      tmp->a_short() ) );
         return;
      }
#ifdef COORDS
      tmp->calc_co_ord();
      if ( sizeof( tmp->query_co_ord() ) >
          sizeof( query_co_ords( directory )[ troom ] ) ) {
         queue_room( room, 1, "new co_ordinates");
         return;
      }
#endif
   }
   tmp = stat( room +".c" );
   if ( query_changetimes( directory )[ troom ] ==
       ( changetime = tmp[ TIME ] ) ) {
      return;
   }
   queue -= ({ room });
   queue += ({ room });
   LOG( sprintf( "%%^RED%%^Queueing %s(%i).%%^RESET%%^\n",
                room, sizeof( queue ) ) );
}
private void check_next() {
   string room;
   if ( sizeof( queue ) && !stopped ) {
        check_next_call_out = call_out( (: check_next :), SKEWTIME );
      room = queue[ 0 ];
      queue -= ({ room });
      check_map2( room );
   } else {
      check_next_call_out = call_out( (: check_next :), 60 );
   }
}
private void check_short( object room_obj, string room_short, string room ) {
   string tmp_short, bad_short;
   if(!room_short)
     return;
   tmp_short = lower_case(room_short);
   bad_short = 0;
   if ( tmp_short[ 0 .. 4 ] == "an a " ||
       tmp_short[ 0 .. 5 ] == "an an " ||
       tmp_short[ 0 .. 5 ] == "the the " ||
       tmp_short[ 0 .. 5 ] == "a the " ) {
      bad_short = "strange or missing determinate";
   } else {
      if(!sizeof(tmp_short))
         bad_short = "no short";
      else if ( tmp_short[ <1 ] == '.' ) {
         bad_short = "period in short";
      } else {
         if ( !(tmp_short = (string)room_obj->query_property( "determinate" ) ) ) {
            tmp_short = (string)room_obj->query_short();
            if ( tmp_short )
            if ( tmp_short[ 0 .. 0 ] != lower_case( tmp_short[ 0 .. 0 ] ) )
               bad_short = "suspicious capitalisation";
         } else {
            if ( tmp_short != "" ) {
               if ( tmp_short[ <1 ] != ' ' ) {
                  bad_short = "missing space in determinate";
               } else {
                  if ( tmp_short[ 0 .. 0 ] != lower_case( tmp_short[ 0 .. 0 ] ) ) {
                     bad_short = "suspicious capitalisation in determinate";
                  }
               }
            }
         }
      }
   }
   if ( bad_short ) {
      log_file( "STRANGE_SHORT","%s, %s (%s)\n",
               room_short, bad_short, room );
      LOG( sprintf( "%%^RED%%^%s.%%^RESET%%^\n", bad_short ) );
   }
}
void check_map( string room ) {
   do_room( room );
}
private void check_map2( string room ) {
   mixed tmp;
   int i, changetime, do_update;
   string *dest_dir, *tmpdest_dir, room_short, *movezones;
#ifdef COORDS
   int *coord;
   mixed size;
#endif
   object room_obj;
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   if ( directory[ 0 ] == 'w' ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ in /w/.\n", room ) );
      return;
   }
   if ( directory[ 0 .. 2 ] == "std" ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ in /std/.\n", room ) );
      return;
   }
   do_update = forced_rooms[ room ];
   tmp = stat( room +".c" );
   if( !pointerp( tmp ) || sizeof( tmp ) < 2 )
      return;
#ifdef COORDS
   if ( room_obj = find_object( room ) ) {
      room_obj->calc_co_ord();
      if ( ( sizeof( room_obj->query_co_ord() ) >
            sizeof( query_co_ords( directory )[ troom ] ) ) ||
          compare_arrays( room_obj->query_co_ord(),
                         query_co_ords( directory )[ troom ] ) ) {
         do_update = 1;
      }
   }
#endif
   if ( !do_update &&
       ( query_changetimes( directory )[ troom ] ==
        ( changetime = tmp[ TIME ] ) ) ) {
      return;
   }
   if ( !find_object( room ) )
      catch( room->force_load() );
   room_obj = find_object( room );
   queue -= ({ room });
   map_delete( forced_rooms, room );
   update_cache( directory, 0 );
   if( !room_obj ) {
      if( shorts[ directory ][ troom ] ) {
         dest_dir = query_dest_dir(room);
         for(i = 1; i < sizeof( dest_dir ); i += 2 )
            check_map( dest_dir[ i ] );
#if !efun_defined(db_exec)
         map_delete( map[ directory ], troom );
#endif
         map_delete( shorts[ directory ], troom );
         map_delete( movezoness[ directory ], troom );
         map_delete( changetimes[ directory ], troom );
#ifdef COORDS
         map_delete( coords[ directory ], troom );
         map_delete( sizes[ directory ], troom );
#endif
         del( directory, room );
         LOG( sprintf( "%%^RED%%^Removing %s,%%^RESET%%^.\n", room ) );
      }
      return;
   }
   if ( room_obj->query_property( "no map" ) ) {
      LOG( sprintf( "%%^BLUE%%^Skipping %s,%%^RESET%%^ it asked me to.\n",
                   room ) );
      return;
   }
   room_short = (string)"/global/events"->convert_message(
         (string)room_obj->a_short() );
   if ( shorts[ directory ][ troom ] != room_short )
      do_update = 1;
   LOG( sprintf( "%%^YELLOW%%^Updating %s%%^RESET%%^. (%s)\n",
                room_short, troom ) );
#ifdef LOG_SHORTS
   check_short( room_obj, room_short, room );
#endif
   movezones = room_obj->query_zones();
   if ( !pointerp( movezones ) ) movezones = ({ });
   if ( movezoness[ directory ][ troom ] != movezones )
      do_update = 1;
#ifdef COORDS
   room_obj->calc_co_ord();
   coord = room_obj->query_co_ord();
   if ( !coord ) room_obj->calc_co_ord();
   coord = room_obj->query_co_ord();
   if ( !coords[ directory ] ) coords[ directory ] = ([ ]);
   if ( compare_arrays( coords[ directory ][ troom ], coord ) )
      do_update = 1;
   size = room_obj->query_room_size_array();
   if ( !sizes[ directory ] ) sizes[ directory ] = ([ ]);
   if ( sizes[ directory ][ troom ] != size )
      do_update = 1;
#endif
   if ( changetimes[ directory ][ troom ] != changetime )
      do_update = 1;
   if ( do_update ) {
      change_changetimes( directory, troom, changetime );
      change_movezones( directory, troom, movezones );
      change_shorts( directory, troom, room_short );
#ifdef COORDS
      if ( sizeof( coord ) == 3 )
         change_co_ords( directory, troom, coord );
      change_sizes( directory, troom, size );
#endif
      update_cache( directory, 1 );
   }
   dest_dir = room_obj->query_dest_dir();
   if( !dest_dir ) {
      dest_dir = ({ });
   } else {
      string exit;
      if( room_obj->query_blockage() ) {
        exit = room_obj->query_direction();
        if( !exit )
          for( i = 1; i < sizeof( dest_dir ); i += 2 )
            if( dest_dir[ i ]->query_blockage() ) {
              exit = dest_dir[ i - 1 ];
              break;
            }
      }
      if(!exit)
         exit = "";
      tmpdest_dir = ({ });
      for ( i = 1; i < sizeof( dest_dir ); i += 2 ) {
         mixed tmp2;
         catch(load_object(dest_dir[i]));
         if ( objectp( find_object( dest_dir[ i ] ) ) &&
                          !clonep( find_object( dest_dir[ i ] ) ) &&
              exit != dest_dir[i - 1] &&
              dest_dir[i - 1][0..5] != "enter " &&
              dest_dir[i][1] != 'w' &&
              dest_dir[i][1..3] != "std" &&
              dest_dir[i][1..4] != "room" &&
                     (catch(tmp2 = dest_dir[i]->query_property( "no map" )), !tmp2)) {
            tmpdest_dir += ({ dest_dir[ i - 1 ], dest_dir[ i ] });
         }
      }
      dest_dir = tmpdest_dir;
   }
   if ( compare_arrays( query_dest_dir(room), dest_dir ) ) {
#if !efun_defined(db_exec)
      map[ directory ][ troom ] = dest_dir;
#else
      db_exec(db, "delete from roomexit where id = '%s'", db_escape(room));
      for(i=0; i<sizeof(dest_dir)/2; i++){
        db_exec(db, "insert into roomexit values ('%s', '%s', '%s')",
                db_escape(room), db_escape(dest_dir[i*2]),
                db_escape(dest_dir[i*2+1]));
      }
#endif
      for( i = 1; i < sizeof( dest_dir );i += 2 ) {
         if ( dest_dir[ i ][ <2.. ] == ".c" ) {
#ifdef LOG_EXITS
            log_file("BAD_EXIT","from %s, %s to %s\n",
                     directory +"/"+ troom, dest_dir[ i-1 ], dest_dir[ i ] );
#endif
            dest_dir[ i ] = dest_dir[ i ][ 0..<3 ];
         }
      }
#if !efun_defined(db_exec)
      change_map( directory, troom, dest_dir );
#endif
#ifdef PARANOID
      update_cache( directory, 1 );
#endif
      for( i = 1; i < sizeof( dest_dir ); i += 2 ) {
         do_room( dest_dir[ i ] );
      }
#ifdef PARANOID
      return;
#endif
   }
#ifdef PARANOID
   update_cache( directory, 1 );
#endif
}
string query_short( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   stats["short"]++;
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return (string)"/global/events"->convert_message(
                     (string)room->a_short() );
      } else {
         return "The map_handler was called on a non-existent clone";
      }
   }
   if ( !shorts[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !shorts[ directory ] ) {
      shorts[ directory ] = ([ ]);
   }
   if ( shorts[ directory ][ troom ] ) {
     return shorts[ directory ][ troom ];
   }
   if ( !catch( load_object(room) ) ) {
     return (string)"/global/events"->convert_message(
                            (string)room->a_short() );
   }
   return "Oops!";
}
string static_query_short( string room ) {
   string directory, troom;
   if(!stringp(room))
     return "";
   directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   stats["static short"]++;
   if ( !shorts[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !shorts[ directory ] ) {
      shorts[ directory ] = ([ ]);
   }
   if ( shorts[ directory ][ troom ] ) {
     return shorts[ directory ][ troom ];
   }
   return 0;
}
string *query_zones( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   object roomob;
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   stats["zones"]++;
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return (string *)room->query_movezones();
      } else {
         return ({ });
      }
   }
   if ( !movezoness[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !movezoness[ directory ] ) {
      movezoness[ directory ] = ([ ]);
   }
   if ( movezoness[ directory ][ troom ] ) {
     return movezoness[ directory ][ troom ];
   }
   if ( !catch( roomob = load_object(room) ) ) {
     if(roomob)
       return roomob->query_movezones();
   }
   return ({ "Oops!" });
}
#ifdef COORDS
void set_co_ord( string room, int *coord ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   if ( !coords[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !coords[ directory ] ) {
      coords[ directory ] = ([ ]);
   }
   MH->change_co_ords( directory, troom, coord );
   coords[ directory ][ troom ] = coord;
}
int *query_co_ord( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   stats["co_ord"]++;
   LOG( sprintf( "%%^BLUE%%^query_co_ord(%s)%%^RESET%%^\n", room ) );
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return room->query_co_ord();
      } else {
         return 0;
      }
   }
   if ( !coords[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !coords[ directory ] ) {
      coords[ directory ] = ([ ]);
   }
   if ( coords[ directory ][ troom ] ) {
     return coords[ directory ][ troom ];
   }
   if ( !catch( load_object(room ) ) ) {
     return room->query_co_ord();
   }
   return 0;
}
int *static_query_co_ord( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   stats["static co_ord"]++;
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return room->query_co_ord();
      } else {
         return 0;
      }
   }
   if ( !coords[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !coords[ directory ] ) {
      coords[ directory ] = ([ ]);
   }
   if ( coords[ directory ][ troom ] ) {
     return coords[ directory ][ troom ];
   }
   return 0;
}
int *query_room_size( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   stats["room_size"]++;
   if ( strsrch( room, "#" ) != -1 ) {
      if ( find_object( room ) ) {
         return room->query_room_size_array();
      } else {
         return 0;
      }
   }
   if ( !sizes[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !sizes[ directory ] ) {
      sizes[ directory ] = ([ ]);
   }
   if ( sizes[ directory ][ troom ] ) {
     return sizes[ directory ][ troom ];
   }
   if (!catch(room->force_load())) {
      return room->query_room_size_array();
   }
   return 0;
}
#endif
int test_room( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   if ( strsrch( room, "#" ) != -1 )  {
      return 1;
   }
   if ( !shorts[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !shorts[ directory ] ) {
      shorts[ directory ] = ([ ]);
   }
   if ( shorts[ directory ][ troom ] ) {
     return 1;
   }
   if ( !catch( load_object(room) ) ) {
     return 1;
   }
   return 0;
}
int query_known( string room ) {
   string directory = implode( explode( room, "/" )[ 0..<2 ], "/" );
   string troom = explode( room, "/" )[ <1 ];
   if ( troom[ <2.. ] == ".c" ) {
     troom = troom[ 0..<3];
   }
   if ( !shorts[ directory ] ) {
      update_cache( directory, 1 );
   }
   if ( !shorts[ directory ] ) {
      shorts[ directory ] = ([ ]);
   }
   return !undefinedp(shorts[ directory ][troom]);
}
void check_save_files() {
   string *files, file, room, *tmp;
   files = unguarded((: get_dir, "/save/map/" :));
   files = map( files, (: replace( $1, ({ "_", "/", ".o", ""}) ) :) );
   foreach( file in files ) {
      printf( "%s\n", file );
      tmp = keys( MH->query_map( file ) );
      reset_eval_cost();
      foreach( room in tmp ) {
         if( file_size( file +"/"+ room + ".c" ) < 0 ) {
            printf( "%s no longer exists.\n", file + "/" + room );
            MH->del( file, room );
         }
      }
   }
   cache = ({ });
}
mapping query_dynamic_auto_load() {
   mapping tmp;
   tmp = ([ "shorts" : shorts,
            "movezoness" : movezoness,
            "changetimes" : changetimes,
#if !efun_defined(db_exec)
            "clusters" : clusters,
            "map" : map,
#endif
#ifdef COORDS
            "coords" : coords,
            "sizes" : sizes,
#endif
            "cache" : cache,
            "queue" : queue,
          ]);
   return tmp;
}
void init_dynamic_arg(mapping maps) {
   if (maps["shorts"])
      shorts = maps["shorts"];
   if (maps["movezoness"])
      movezoness = maps["movezoness"];
   if (maps["changetimes"])
      changetimes = maps["changetimes"];
#if !efun_defined(db_exec)
   if (maps["clusters"])
      clusters = maps["clusters"];
   if (maps["map"])
     map = maps["map"];
#endif
#ifdef COORDS
   if (maps["coords"])
      coords = maps["coords"];
   if (maps["sizes"])
      sizes = maps["sizes"];
#endif
   if (maps["cache"])
      cache = maps["cache"];
   if (maps["queue"])
      queue = maps["queue"];
}
mixed *stats() {
   return ({
      ({ "queue size", sizeof( queue ) }),
      ({ "cache size", sizeof( cache ) }),
      ({ "next check", find_call_out( check_next_call_out ) }),
        }) + map(keys(stats), (:({$1, $(stats)[$1]}):));
}

==================================================
FILE: /lib/obj/handlers/map_helper.c
==================================================

#include <map_handler.h>
mapping shorts = ([ ]), movezones = ([ ]), changetimes = ([ ])
#if !efun_defined(db_exec)
, clusters = ([ ]), map = ([ ])
#endif
;
#ifdef COORDS
mapping coords = ([ ]), sizes = ([ ]);
#endif
string directory;
nosave string loaded;
nosave int save;
void create() {
   seteuid( (string)master()->get_bb_uid() );
}
void save_dir() {
#ifdef HELPLOGTO
   tell_object( find_living( LOGTO ), "%^RED%^saving%^RESET%^ "+ loaded +"\n");
#endif
   if (sizeof(shorts) ||
       sizeof(movezones) ||
       sizeof(changetimes) ||
#ifdef COORDS
       sizeof(coords) ||
       sizeof(sizes) ||
#endif
#if !efun_defined(db_exec)
       sizeof(clusters) ||
       sizeof(map) ||
#endif
        0) {
      unguarded((: save_object, "/save/map/" + loaded :));
   } else {
      unguarded((: rm("/save/map/" + loaded) :));
   }
   save = 0;
}
void check_dir( string dir ) {
   string tmp_file;
   if ( dir == directory ) {
      return;
   }
   if ( save )  {
      save_dir();
   }
   tmp_file = replace_string( dir, "/", "_" );
   shorts = ([ ]);
   movezones = ([ ]);
   changetimes = ([ ]);
#if !efun_defined(db_exec)
   clusters = ([ ]);
   map = ([ ]);
#endif
#ifdef COORDS
   coords = ([ ]);
   sizes = ([ ]);
#endif
   if ( file_size( "/save/map/" + tmp_file + ".o" ) > 0 ) {
#ifdef HELPLOGTO
      tell_object( find_living( LOGTO ), "%^GREEN%^loading%^RESET%^ "+ tmp_file
                   +"\n");
#endif
      unguarded((: restore_object, "/save/map/" + tmp_file :));
   } else {
#ifdef HELPLOGTO
      tell_object( find_living( LOGTO ), "%^BLUE%^newmap%^RESET%^ "+ tmp_file +"\n");
#endif
      shorts = ([ ]);
      movezones = ([ ]);
      changetimes = ([ ]);
#if !efun_defined(db_exec)
      clusters = ([ ]);
      map = ([ ]);
#endif
#ifdef COORDS
      coords = ([ ]);
      sizes = ([ ]);
#endif
   }
   loaded = tmp_file;
   directory = dir;
}
#if !efun_defined(db_exec)
void change_map( string dir, string room, string *dd ) {
   check_dir( dir );
   map[ room ] = dd;
   save = 1;
}
mapping query_map( string dir ) {
   check_dir( dir );
   if ( !map )
     return ([ ]);
   return map;
}
#endif
void change_shorts( string dir, string room, string sh ) {
   check_dir( dir );
   shorts[ room ] = sh;
   save = 1;
}
mapping query_shorts( string dir ) {
   check_dir( dir );
   if ( !shorts ) {
     return ([ ]);
   }
   return shorts;
}
void change_movezones( string dir, string room, string *zones ) {
   check_dir( dir );
   movezones[ room ] = zones;
   save = 1;
}
mapping query_movezones( string dir ) {
   check_dir( dir );
   if ( !movezones )
     return ([ ]);
   return movezones;
}
#if !efun_defined(db_exec)
void change_clusters( string dir, string room, int cluster ){
  check_dir( dir );
  if(!clusters)
    clusters = ([]);
  clusters[ room ] = cluster;
  save = 1;
}
mapping query_clusters( string dir ){
  check_dir( dir );
  if( !clusters )
    return ([ ]);
  return clusters;
}
#endif
void change_changetimes( string dir, string room, int time ) {
   check_dir( dir );
   if ( !changetimes )
      changetimes = ([ ]);
   changetimes[ room ] = time;
   save = 1;
}
mapping query_changetimes( string dir ) {
   check_dir( dir );
   if ( !changetimes )
     return ([ ]);
   return changetimes;
}
#ifdef COORDS
void change_co_ords( string dir, string room, int *coord ) {
   check_dir( dir );
   if ( !coords )
      coords = ([ ]);
   coords[ room ] = coord;
   save = 1;
}
mapping query_co_ords( string dir ) {
   check_dir( dir );
   if ( !coords )
     return ([ ]);
   return coords;
}
void change_sizes( string dir, string room, int size ) {
   check_dir( dir );
   if ( !sizes )
      sizes = ([ ]);
   sizes[ room ] = size;
   save = 1;
}
mapping query_sizes( string dir ) {
   check_dir( dir );
   if ( !sizes )
     return ([ ]);
   return sizes;
}
#endif
void del( string dir, string room ) {
   check_dir( dir );
#if !efun_defined(db_exec)
   if (mapp(map)) {
     map_delete( map, room );
   } else {
     map = ([ ]);
   }
#endif
   if (mapp(shorts)) {
     map_delete( shorts, room );
   } else {
     shorts = ([ ]);
   }
   if (mapp(movezones)) {
     map_delete( movezones, room );
   } else {
     movezones = ([ ]);
   }
   if (mapp(changetimes)) {
     map_delete( changetimes, room );
   } else {
     changetimes = ([ ]);
   }
#if !efun_defined(db_exec)
   if (mapp(clusters)) {
     map_delete( clusters, room );
   } else {
     clusters = ([ ]);
   }
#endif
#ifdef COORDS
   if (mapp(coords)) {
     map_delete( coords, room );
   } else {
     coords = ([ ]);
   }
   if (mapp(sizes)) {
     map_delete( sizes, room );
   } else {
     sizes = ([ ]);
   }
#endif
   save = 1;
}

==================================================
FILE: /lib/obj/handlers/mime.c
==================================================

#include <mime.h>
#define HEADER_NAME 1
#define HEADER_VAL  2
#define MUDMAIL     3
#define TOK_QP      4
#define TOK_QUOTE   5
#define TOK_OP      6
#define TOK_CP      7
#define TOK_LT      8
#define TOK_GT      9
#define TOK_SEP     10
#define TOK_AMP     11
#define SPECIAL     12
#define LWS         13
#define ATOM        14
#define COMMENT     15
#define EMAIL       16
#define QUOTE       17
private mixed *tokenize(string header_field) {
  int i, quoted, paren_count, angle_count;
  int *tokens, state;
  mixed *bits;
  bits = reg_assoc(header_field,
                   ({ "\\\\.", "\"", "\\(", "\\)", "<", ">",
                      ",", "@",
                      "[]()<>@,;:\\\\\".[]",
                      "(\n?[ \t])+",
                      "[!#-'*+/-9=?A-Z^-~-]+" }),
                   ({ TOK_QP, TOK_QUOTE, TOK_OP, TOK_CP, TOK_LT, TOK_GT,
                      TOK_SEP, TOK_AMP, SPECIAL, LWS, ATOM }));
  tokens = ({ 0 });
  for (i = 1; i < sizeof(bits[0]); i += 2) {
    switch(bits[1][i]) {
    case LWS:
      if (quoted) {
        tokens += ({ state, 0 });
      } else {
        tokens += ({ 0, 0 });
      }
      break;
    case TOK_QUOTE:
      quoted = !quoted;
      if (!state && quoted) {
        state = QUOTE;
      }
      tokens += ({ state, 0 });
      if (state == QUOTE && !quoted) {
        state = 0;
      }
      break;
    case TOK_OP:
      if (!quoted) {
        paren_count++;
        state = COMMENT;
      }
      tokens += ({ state, 0 });
      break;
    case TOK_CP:
      if (!quoted) {
        paren_count--;
        if (paren_count < 0) {
          printf("Unbalanced ')'\n");
          return ({ });
        }
      }
      tokens += ({ state, 0 });
      if (!paren_count) {
        state = 0;
      }
      break;
    case TOK_LT:
      tokens += ({ state, 0 });
      if (!(quoted || paren_count)) {
        angle_count++;
        state = EMAIL;
      }
      break;
    case TOK_GT:
      if (!(quoted || paren_count)) {
        angle_count--;
        if (angle_count != 0) {
          printf("Unbalanced '%c'\n", (angle_count < 0?'>':'<'));
          return ({ });
        }
        state = 0;
      }
      tokens += ({ state, 0 });
      break;
    default:
      if (!state) {
        tokens += ({ bits[1][i], 0 });
      } else {
        tokens += ({ state, 0 });
      }
      break;
    }
    if (paren_count < 0) {
      printf("Unbalanced ')'\n");
      return ({ });
    }
  }
  if (paren_count != 0) {
    printf("Unbalanced '%c'\n", (paren_count < 0?')':'('));
    return ({ });
  }
  bits += ({ tokens });
  return bits;
}
mixed *get_email_addrs(string arg) {
  string *addrs, *full_addrs;
  int i, idx, state;
  mixed *bits;
  if (!arg) {
    return ({ ({ }), ({ }) });
  }
  bits = tokenize(arg);
  if (!sizeof(bits)) {
    return ({ ({ }), ({ }) });
  }
  addrs = allocate(1);
  addrs[0] = "";
  full_addrs = allocate(1);
  full_addrs[0] = "";
  idx = 0;
  for (i = 1; i < sizeof(bits[2]); i += 2) {
    switch (bits[2][i]) {
    case TOK_SEP:
      idx++;
      addrs += ({ "" });
      full_addrs += ({ "" });
      break;
    case EMAIL:
      if (state != EMAIL) {
        addrs[idx] = bits[0][i];
        state = EMAIL;
      } else {
        addrs[idx] += bits[0][i];
      }
      full_addrs[idx] += bits[0][i];
      break;
    case COMMENT:
    case LWS:
    case 0:
      full_addrs[idx] += bits[0][i];
      break;
    default:
      addrs[idx] += bits[0][i];
      full_addrs[idx] += bits[0][i];
      break;
    }
  }
  return ({ addrs, full_addrs });
}
string rewrite_field(string header_field) {
  int i, idx, state;
  mixed *bits, *addrs, *indices;
  if (!header_field) {
    return "";
  }
  bits = tokenize(header_field);
  if (!sizeof(bits)) {
    return "";
  }
  addrs = allocate(1);
  addrs[0] = ({ });
  indices = allocate(1);
  indices[0] = ({ });
  idx = 0;
  for (i = 1; i < sizeof(bits[2]); i += 2) {
    switch (bits[2][i]) {
    case TOK_SEP:
      if (sizeof(addrs[idx]) && member_array(TOK_AMP, addrs[idx]) == -1) {
        if (bits[0][indices[idx][<1]] == "discworld") {
          bits[0][indices[idx][<1]] += "@discworld.imaginary.com";
        } else {
          bits[0][indices[idx][<1]] += ".discworld@discworld.imaginary.com";
        }
      }
      idx++;
      addrs += ({ ({ }) });
      indices += ({ ({ }) });
      break;
    case EMAIL:
      if (state != EMAIL) {
        addrs[idx] = ({ bits[1][i] });
        indices[idx] = ({ i });
        state = EMAIL;
      } else {
        addrs[idx] += ({ bits[1][i] });
        indices[idx] += ({ i });
      }
      break;
    case COMMENT:
    case LWS:
    case 0:
      break;
    default:
      addrs[idx] += ({ bits[1][i] });
      indices[idx] += ({ i });
      break;
    }
  }
  if (sizeof(addrs[<1]) && member_array(TOK_AMP, addrs[<1]) == -1) {
    if (bits[0][indices[<1][<1]] == "discworld") {
      bits[0][indices[<1][<1]] += "@discworld.imaginary.com";
    } else {
      bits[0][indices[<1][<1]] += ".discworld@discworld.imaginary.com";
    }
  }
  return implode(bits[0], "");
}
class mime_header parse_headers(string message) {
  string *bits, bit, cont, headers;
  int idx, len;
  class mime_header hdr;
  if ((idx = strsrch(message, "\n\n")) == -1) {
    return hdr;
  }
  headers = message[0..idx];
  hdr = new(class mime_header, header_m : ([]), header_k : ({}));
  bits = explode(headers, "\n") - ({ "", 0 });
  foreach (bit in bits[1..]) {
    if (cont && ((bit[0] == ' ') || (bit[0] == '\t'))) {
      hdr->header_m[cont] += "\n" + bit[1..];
      continue;
    }
    len = strlen(bit);
    if ((idx = strsrch(bit, ':')) == -1) {
      continue;
    }
    cont = bit[0..idx-1];
    if (undefinedp(hdr->header_m[lower_case(cont)])) {
      hdr->header_k += ({ cont });
    }
    cont = lower_case(cont);
    ++idx;
    while ((idx < len) && isspace(bit[idx])) {
      ++idx;
    }
    if (undefinedp(hdr->header_m[cont])) {
      hdr->header_m[cont] = bit[idx..];
    } else {
      hdr->header_m[cont] += sprintf(", %s", bit[idx..]);
    }
  }
  return hdr;
}
string rewrite_header(string message) {
  mixed *ra;
  int i;
  string header, field;
  if ((i = strsrch(message, "\n")) == -1) {
    return message;
  }
  message = message[i+1..];
  if ((i = strsrch(message, "\n\n")) == -1) {
    return message;
  }
  header = message[0..i];
  message = message[i+1..];
  ra = reg_assoc(header,
                 ({ "^[!-9;-~]+:", "((\n?[ \t])+[^\n]*(\n|$))+" }),
                 ({ HEADER_NAME, HEADER_VAL }));
  for (i = 1; i + 2 < sizeof(ra[0]); i += 2) {
    if (ra[1][i] == HEADER_NAME && ra[1][i+2] == HEADER_VAL) {
      switch(lower_case(ra[0][i])) {
      case "to:":
      case "from:":
      case "cc:":
      case "bcc:":
      case "reply-to:":
        field = rewrite_field(ra[0][i+2]);
        if (field != "") {
          ra[0][i+2] = field;
        }
        break;
      default:
        break;
      }
    }
  }
  return implode(ra[0], "") + message;
}
void dest_me() {
  destruct(this_object());
}
int cleanup(int inherited) {
  if (!inherited) {
    dest_me();
  }
  return 1;
}

==================================================
FILE: /lib/obj/handlers/money_handler.c
==================================================

#include <money.h>
#define DEF_VALUE 1
#define SAVE_FILE "/save/money_handler"
#define USE_VAULT DEF_VALUE
mapping values;
mapping symbols;
mapping details;
mapping aliases;
mapping adjectives;
mixed *merge_money_arrays(mixed *m_array1, mixed *m_array2);
varargs object *filter_legal_money_array(mixed *m_array, string where);
varargs mixed *filter_legal_money_to_array(mixed *m_array, string where);
void create() {
   seteuid( (string)"/secure/master"->
      creator_file( file_name( this_object() ) ) );
   values = ([ "default": ({ "brass", 1, "copper", 10, "silver", 100,
                                          "gold", 2000, "platinum", 6000 }) ]);
   symbols = ([ ]);
   details = ([
      "brass": ({ "heads", "tails", "a head", "a tail", "brass", 0 }),
      "copper": ({ "heads", "tails", "a head", "a tail", "copper", 0 }),
      "silver": ({ "heads", "tails", "a head", "a tail", "silver", 0 }),
      "gold": ({ "heads", "tails", "a head", "a tail", "gold", 0 }),
      "platinum": ({ "heads", "tails", "a head", "a tail", "platinum", 0 }) ]);
   aliases = ([ ]);
   adjectives = ([ ]);
   if ( file_size( SAVE_FILE +".o" ) > 0 ) {
      unguarded((: restore_object, SAVE_FILE :));
   }
   if ( !symbols ) {
      symbols = ([ ]);
   }
   if ( !aliases ) {
      aliases = ([ ]);
   }
   if ( !adjectives ) {
      adjectives = ([ ]);
   }
}
void save_me() { unguarded( (: save_object, SAVE_FILE :) ); }
mapping query_all_values() { return copy( values ); }
string *query_all_places() {
   return keys(values);
}
mixed *query_values() { return copy( values[ "default" ] ); }
mixed *query_values_in( string where ) {
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   return copy( values[ where ] );
}
mixed *query_weighted_values_in( string where, int backwards ) {
    mixed *bits;
    int i, j;
    int max_size;
    int len;
    mixed *arr, *reversed;
    if ( !where || ( where == "" ) ) {
        return 0;
    }
    bits = copy( values[ where ] );
    arr = ({ });
    max_size = 0;
    for ( i = 0; i < sizeof( bits ); i += 2 ) {
        len = sizeof( bits[ i ] );
        if ( len > max_size ) {
            arr += ({ bits[ i ], bits[ i + 1 ] });
            max_size = len;
            continue;
        }
        for ( j = 0; j < sizeof( arr ); j += 2 ) {
            if ( len <= sizeof( arr[ j ] ) ) {
                arr = arr[ 0..j-1] + ({ bits[ i ], bits[ i + 1 ] }) + arr[j..];
                break;
            }
        }
    }
    if ( backwards ) {
        reversed = ({ });
        for ( i = sizeof( arr ) - 1; i > 0; i -= 2) {
            reversed += ({ arr[ i - 1 ], arr[ i ] });
        }
        return reversed;
    }
    else {
       return arr;
    }
}
int query_smallest_value_in(string where) {
   mixed* values;
   int value;
   int i;
   if (! where) {
      where = "default";
   }
   values = query_values_in(where);
   value = values[1];
   for (i = 2; i < sizeof(values); i += 2) {
      if (values[i + 1] < value) {
         value = values[i + 1];
      }
   }
   return value;
}
void add_type( string where, string type, int value ) {
   int i;
   if ( !values[ where ] ) {
      values[ where ] = ({ type, value });
      save_me();
      return;
   }
   if ( member_array( type, values[ where ] ) != -1 ) {
      return;
   }
   for ( i = 0; i < sizeof( values[ where ] ); i += 2 ) {
      if ( value < values[ where ][ i + 1 ] ) {
         values[ where ] = values[ where ][ 0 .. i - 1 ] + ({ type, value })
                           + values[ where ][ i .. sizeof( values ) ];
         save_me();
         return;
      }
   }
   values[ where ] += ({ type, value });
   save_me();
}
void remove_type( string where, string type ) {
   int i;
   if ( !values[ where ] ) {
      return;
   }
   i = member_array( type, values[ where ] );
   if ( i == -1 ) {
      return;
   }
   values[ where ] = delete( values[ where ], i, 2 );
   if ( !sizeof( values[ where ] ) ) {
      map_delete( values, where );
   }
   save_me();
}
mapping query_details() { return copy( details ); }
mixed *query_details_for( string word ) {
   if ( !details[ word ] ) {
      return ({ "heads", "tails", "a head", "a tail", "unknown", 0 });
   }
   return copy( details[ word ] );
}
void add_details( string word, string hd_sht, string tl_sht, string hd_lng,
                  string tl_lng, mixed composition, string plural ) {
   if ( details[ word ] ) {
      return;
   }
   details[ word ] = ({ hd_sht, tl_sht, hd_lng, tl_lng, composition, plural });
   save_me();
}
void remove_details( string word ) {
   if ( !details[ word ] ) {
      return;
   }
   map_delete( details, word );
   save_me();
}
mapping query_symbols() { return copy( symbols ); }
string query_symbol_for( string word ) {
   if ( !symbols[ word ] ) {
      return 0;
   }
   return copy( symbols[ word ] );
}
void add_symbol( string word, string symboliser ) {
   if ( symbols[ word ] ) {
      return;
   }
   symbols[ word ] = symboliser;
   save_me();
}
void remove_symbol( string word ) {
   if ( !symbols[ word ] ) {
      return;
   }
   map_delete( symbols, word );
   save_me();
}
string query_alias_for( string type ) {
   log_file("OBSOLETE_CALLS",
      sprintf("%O %s: %O called query_alias_for\n",
         this_object(),
         ctime(time()),
         previous_object()
         ));
   if ( !details[ type ] ) return "coin";
   if ( !details[ type ][ 5 ] ) return "coin";
   return explode( type, " " )[ sizeof( explode( type, " " ) ) - 1 ];
}
void set_aliases_for(string type, string *words) {
   if (!words || !sizeof(words)) {
      if (aliases[type]) {
         map_delete(aliases, type);
      }
   } else {
      aliases[type] = words;
   }
   save_me();
   return;
}
string *query_aliases_for( string type ) {
   string *ret;
   if ( !details[ type ] || !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      ret = ({ "coin" });
   } else {
      ret = ({ explode(type, " ")[<1] });
   }
   if ( aliases[ type ] ) {
      ret += aliases[ type ];
   }
   return ret;
}
void set_adjectives_for(string type, string *words) {
   if (!words || !sizeof(words)) {
      if (adjectives[type]) {
         map_delete(adjectives, type);
      }
   } else {
      adjectives[type] = words;
   }
   save_me();
   return;
}
string *query_adjectives_for( string type ) {
   string *ret;
   if ( adjectives[ type ] ) {
      ret = adjectives[ type ];
   }
   else {
      ret = ({ });
   }
   return ret;
}
string query_short_for( string type ) {
   if ( !details[ type ] ) {
      return type +" coin";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return type +" coin";
   }
   return type;
}
string query_plural_for( string type ) {
   if ( !details[ type ] ) {
      return "coins";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return "coins";
   }
   return details[ type ][ MONEY_DETAILS_PLURAL ];
}
void set_plural_for( string type, string plural ) {
   if ( !details[ type ] ) {
      return;
   }
   details[ type ][ MONEY_DETAILS_PLURAL ] = plural;
   save_me();
}
string query_main_plural_for( string type ) {
   string *type_exp;
   if ( !details[ type ] ) {
      return type +" coins";
   }
   if ( !details[ type ][ MONEY_DETAILS_PLURAL ] ) {
      return type +" coins";
   }
   type_exp = explode(type, " ");
   return implode(type_exp[0 .. <2] +
      ({ details[ type ][ MONEY_DETAILS_PLURAL ] }), " " );
}
varargs int query_value( string type, string where ) {
   int i, j, count, total;
   string *places;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( where == "mean" ) {
      places = m_indices( values );
      for ( i = 0; i < sizeof( places ); i++ ) {
         if ( ( j = member_array( type, values[ places[ i ] ] ) ) != -1 ) {
            count++;
            total += values[ places[ i ] ][ j + 1 ];
         }
      }
      if ( !count ) {
         return 0;
      }
      if ( !( total / count ) ) {
         return 0;
      }
      return total / count;
   }
   if ( !values[ where ] ) {
      return 0;
   }
   i = member_array( type, values[ where ] );
   if ( i == -1 ) {
      return 0;
   }
   return values[ where ][ i + 1 ];
}
varargs int query_total_value( mixed mon_array, string where ) {
   int i, amt;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   for ( i = 0; i < sizeof( mon_array ); i += 2 ) {
      amt += mon_array[ i + 1 ] * query_value( mon_array[ i ], where );
   }
   return amt;
}
string money_string( mixed mon_array ) {
   int i;
   string ret;
   if ( !sizeof( mon_array ) ) {
      return "nothing";
   }
   ret = "";
   while( i < sizeof( mon_array ) ) {
      if ( !mon_array[ i + 1 ] ) {
         mon_array = delete( mon_array, i, 2 );
      } else {
         i += 2;
      }
   }
   for ( i = 0; i < sizeof( mon_array ); i += 2 ) {
      ret += mon_array[ i + 1 ] +" ";
      if ( mon_array[ i + 1 ] == 1 ) {
         ret += query_short_for( mon_array[ i ] );
      } else {
         ret += query_main_plural_for( mon_array[ i ] );
      }
      if ( i == sizeof( mon_array ) - 4 ) {
         ret += " and ";
      } else if ( i != sizeof( mon_array ) - 2 ) {
         ret += ", ";
      }
   }
   return ret;
}
varargs mixed *create_money_array( int value, string where ) {
   int i, amt;
   mixed *mon_array;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( !value ) {
      return ({ });
   }
   mon_array = ({ });
   for ( i = sizeof( values[ where ] ) - 2; i >= 0; i -= 2 ) {
      if ( value >= values[ where ][ i + 1 ] ) {
         mon_array += ({ values[ where ][ i ], amt = value /
                         values[ where ][ i + 1 ] });
         value -= amt * values[ where ][ i + 1];
      }
   }
   return mon_array;
}
varargs string money_value_string( int value, string where ) {
   string symboliser;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if ( !symbols[ where ] ) {
      if (value < 0) {
         return "negative " + money_string( create_money_array( -value,
                                                                where ) );
      } else {
         return money_string( create_money_array( value, where ) );
      }
   }
   symboliser = symbols[ where ];
   return (string)symboliser->symbolise_value( value );
}
mixed* money_array_from_string(string str, string where) {
   int value;
   int number;
   int i;
   int pos;
   int frog;
   int match;
   int max_match;
   string plural;
   string *bits;
   string type;
   string match_name;
   mixed *stuff;
   mixed* ret_arr;
   if (!where) {
      where = "default";
   }
   if (symbols[ where ]) {
      value = symbols[ where ]->unsymbolise_string( str );
      if (value) {
         return create_money_array(value, where);
      }
   }
   ret_arr = ({ });
   stuff = query_weighted_values_in( where, 1 );
   if (!value && stuff) {
      bits = explode(str, " ") - ({ "and", ",", "" });
      for (i = 0; i < sizeof(bits); i++) {
         if (sscanf(bits[i], "%d", number) == 1 &&
             i + 1 < sizeof(bits)) {
            i++;
            type = bits[i];
            max_match = 0;
            do {
               match = 0;
               if (type[<1] == ',') {
                  type = type[0..<2];
               }
               type = lower_case(type);
               for (pos = 0; pos < sizeof(stuff); pos += 2) {
                  plural = query_plural_for(stuff[pos]);
                  frog = strsrch(stuff[pos], " ", -1);
                  if (frog) {
                     plural = stuff[pos][0..frog] + plural;
                  }
                  if (lower_case(stuff[pos]) == type ||
                      strsrch(lower_case(stuff[pos]), type) != -1 ||
                      lower_case(plural) == type ||
                      strsrch(lower_case(plural), type) != -1) {
                     match = stuff[pos + 1];
                     match_name = stuff[pos];
                  }
               }
               if (match) {
                  i++;
                  max_match = match;
                  if (i < sizeof(bits)) {
                     type += " " + bits[i];
                  }
               }
            } while (match && i < sizeof(bits));
            if (max_match) {
               ret_arr += ({ match_name, number });
            }
            i--;
         } else {
            i++;
         }
      }
   }
   return ret_arr;
}
int value_from_string(string str, string where) {
   return query_total_value(money_array_from_string(str, where), where);
}
mixed *calc_change( int value, mixed *mon_array ) {
   int i, num;
   mixed *ret;
   ret = ({ });
   for ( i = sizeof( mon_array ) - 2; i >= 0; i -= 2 ) {
      if ( value >= mon_array[ i + 1 ] ) {
         num = value / mon_array[ i + 1 ];
         value = value % mon_array[ i + 1 ];
         ret += ({ mon_array[ i ], num });
         if ( !value ) {
            return ret;
         }
      }
   }
   return ret;
}
mixed *make_money_array_payment( string type,
                                 int value,
                                 mixed *mon_array,
                                 string where,
                                 int use_default) {
   int i;
   int j;
   int num;
   int total;
   int cur_match;
   string mon_name;
   mixed *poss_values;
   mixed *ret;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
   if (type) {
      i = member_array( type, mon_array );
      if ( i != -1 ) {
         if ( value <= mon_array[ i + 1 ] ) {
            mon_array[ i + 1] -= value;
            return ({ ({ type, value }), 0, mon_array });
         }
      }
      value *= query_value( type, where );
   }
   if (!value) {
      return 0;
   }
   total = query_total_value( mon_array, where );
   if (use_default  &&  where != "default") {
      total += query_total_value( mon_array, "default" );
   }
   if ( value > total ) {
      return 0;
   }
   poss_values = ({ });
   if ( where != "default" && use_default ) {
      poss_values += values[ "default" ];
   }
   poss_values += values[ where ];
   ret = ({ });
   for ( i = ( sizeof( poss_values ) - 2 ); i >= 0; i -= 2 ) {
      j = member_array( poss_values[ i ], mon_array );
      if ( j != - 1 ) {
         if ( poss_values[ i + 1 ] <= value ) {
            num = value / poss_values[ i + 1 ];
            if ( num > mon_array[ j + 1 ] ) {
               num = mon_array[ j + 1 ];
            }
            mon_array[ j + 1] -= num;
            value -= num * poss_values[ i + 1 ];
            ret += ({ poss_values[ i ], num });
            if ( !value ) {
               return ({ ret, value, mon_array });
            }
         }
      }
   }
   cur_match = value + 10000000;
   for (i = 0; i < sizeof(poss_values); i +=2 ) {
      j = member_array( poss_values[ i ], mon_array);
      if (j != -1 &&
          mon_array[j + 1] > 0 &&
          poss_values[i + 1] >= value &&
          poss_values[i + 1] - value <= cur_match - value) {
         cur_match = poss_values[i + 1];
         mon_name = poss_values[i];
      }
   }
   if (mon_name) {
      j = member_array(mon_name, mon_array);
      i = member_array(mon_name, poss_values);
      mon_array[j + 1] -= 1;
      value = poss_values[i + 1] - value;
      ret += ({ poss_values[ i ], 1 });
   } else {
      return 0;
   }
   return ({ ret, value, mon_array });
}
varargs mixed *make_payment( string type, int value, object thing,
                             string where ) {
   mixed *mon_array;
   mixed *stuff;
   if (!type) {
     return 0;
   }
   mon_array = copy(thing->query_money_array());
   stuff = make_money_array_payment( type, value, mon_array, where, 1);
   if (!stuff) {
      return stuff;
   }
   if (stuff[MONEY_PAY_CHANGE]) {
      return ({ stuff[MONEY_PAY_RETURN], calc_change(stuff[MONEY_PAY_CHANGE],
                                                     values[where]) });
   }
   return ({ stuff[MONEY_PAY_RETURN], stuff[MONEY_PAY_CHANGE] });
}
varargs object pay_amount_from(int value, object money, string where) {
   int i;
   object change;
   mixed *m_array, *p_array;
   mixed *change_array;
   mixed *pay_array;
   if (!where || where == "") {
      where = "default";
   }
   change_array = ({ });
   pay_array = ({ });
   m_array = create_money_array(value, where);
   for (i = 0; i < sizeof(m_array); i += 2) {
      p_array = make_payment(m_array[i], m_array[i + 1], money, where);
      if (!pointerp(p_array)) {
         continue;
      }
      if (sizeof(p_array[0]) > 0)
         pay_array = merge_money_arrays(pay_array, p_array[0]);
      if (sizeof(p_array[1]) > 0) {
         change_array = merge_money_arrays(change_array, p_array[1]);
      }
   }
   if (sizeof(pay_array) > 0)  {
      for (i = 0; i < sizeof(pay_array); i += 2) {
         pay_array[i + 1] = -pay_array[i + 1];
      }
      money->adjust_money(pay_array);
   }
   if (sizeof(change_array) == 0) {
      return 0;
   }
#ifdef USE_VAULT
   change = MONEY_VAULT->get_money_ob();
   change->set_money_array(change_array);
#else
   change = clone_object(MONEY_OBJECT);
#endif
   return change;
}
varargs object make_new_amount( int value, string where ) {
   object money;
   if ( !where || ( where == "" ) ) {
      where = "default";
   }
#ifdef USE_VAULT
   money = MONEY_VAULT->get_money_ob();
#else
   money = clone_object( MONEY_OBJECT );
#endif
   money->set_money_array( create_money_array( value, where ) );
   if ( !(int)money->query_value_in( where ) ) {
      money->dest_me();
      return 0;
   }
   return money;
}
varargs object *filter_legal_tender(object money, string where) {
   mixed *m_array;
   object *monies;
   m_array = money->query_money_array();
   monies = filter_legal_money_array(m_array, where);
#ifdef USE_VAULT
   MONEY_VAULT->add_to_list(money);
#else
   money->move("/room/rubbish");
#endif
   return monies;
}
varargs object *filter_legal_money_array(mixed *m_array, string where) {
   object good, no_good;
   mixed *money_arrays;
   money_arrays = filter_legal_money_to_array(m_array, where);
   if (sizeof(money_arrays[0]) == 0) {
      good = 0;
   } else  {
#ifdef USE_VAULT
      good = MONEY_VAULT->get_money_ob();
#else
      good = clone_object(MONEY_OBJECT);
#endif
      good->set_money_array(money_arrays[0]);
   }
   if (sizeof(money_arrays[1]) == 0) {
      no_good = 0;
   } else  {
#ifdef USE_VAULT
     no_good = MONEY_VAULT->get_money_ob();
#else
     no_good = clone_object(MONEY_OBJECT);
#endif
     no_good->set_money_array(money_arrays[1]);
   }
   return ({ good, no_good });
}
varargs mixed *filter_legal_money_to_array(mixed *m_array, string where) {
   int i;
   mixed *poss_values;
   mixed *good_array = ({ });
   mixed *no_good_array = ({ });
   if (sizeof(m_array) == 0) {
      return ({ ({ }), ({ }) });
   }
   if (!where || where == "") {
     where = "default";
   }
   if (!(poss_values = values[where])) {
      return ({ ({ }), copy(m_array) });
   }
   for (i = 0; i < sizeof(m_array); i += 2) {
      if (member_array(m_array[i], poss_values) != -1) {
         good_array += ({ m_array[i], m_array[i + 1] });
      } else {
         no_good_array += ({ m_array[i], m_array[i + 1] });
      }
   }
   return ({ good_array, no_good_array });
}
mixed *merge_money_arrays(mixed *m_array1, mixed *m_array2)  {
   int i;
   int idx;
   mixed *new_m_array;
   if (!m_array1)
      m_array1 = ({ });
   if (!m_array2)
      m_array2 = ({ });
   if (sizeof(m_array1) < sizeof(m_array2))  {
      new_m_array = copy(m_array2);
      for (i = 0; i < sizeof(m_array1); i += 2)  {
         idx = member_array(m_array1[i], new_m_array);
         if (idx > -1)  {
            new_m_array[idx + 1] += m_array1[i + 1];
            if (new_m_array[idx + 1] <= 0)
               new_m_array = delete(new_m_array, idx, 2);
         }
         else
            new_m_array += ({ m_array1[i], m_array1[i + 1] });
      }
   }
   else  {
      new_m_array = copy(m_array1);
      for (i = 0; i < sizeof(m_array2); i += 2)  {
         idx = member_array(m_array2[i], new_m_array);
         if (idx > -1)  {
            new_m_array[idx + 1] += m_array2[i + 1];
            if (new_m_array[idx + 1] <= 0)
               new_m_array = delete(new_m_array, idx, 2);
         }
         else
            new_m_array += ({ m_array2[i], m_array2[i + 1] });
      }
   }
   return new_m_array;
}
varargs mixed parse_money(string words, object player, string place) {
   object  thing;
   object *monies;
   object *things;
   mixed  *m_array;
   mixed  *m_array2;
   int     i;
   int     adjust_flag;
   things = match_objects_for_existence(words, ({ player }));
   if (sizeof(things) == 0) {
      m_array = money_array_from_string(words, place);
       if (sizeof(m_array) == 0) {
         return NO_MATCH;
      }
      thing = present(MONEY_ALIAS, player);
      if (!thing) {
         return NO_MATCH;
      }
      for (i = 0; i < sizeof(m_array); i += 2) {
         if (thing->query_money(m_array[i]) < m_array[i + 1]) {
            return NO_MATCH;
         }
      }
      adjust_flag = 1;
   }
   else {
      things = filter(things, (: $1->query_property("money") :));
      if (sizeof(things) == 0)
         return NO_MONEY;
      adjust_flag = 0;
      m_array = ({ });
      foreach (thing in things) {
         m_array = merge_money_arrays(m_array, thing->query_money_array());
#ifdef USE_VAULT
         MONEY_VAULT->add_to_list(thing);
#else
         thing->move("/room/rubbish");
#endif
      }
   }
   monies = filter_legal_money_array(m_array, place);
   if(monies[1])  {
      tell_object(player, monies[1]->the_short() +
            (monies[1]->query_number_coins() == 1 ? " is" : " are") +
            " not legal tender here.\n");
      m_array = monies[1]->query_money_array();
      if (!adjust_flag)
         this_player()->adjust_money(m_array);
#ifdef USE_VAULT
      MONEY_VAULT->add_to_list(monies[1]);
#else
      monies[1]->dest_me();
#endif
   }
   if (monies[0])  {
      if (adjust_flag)  {
         m_array2 = copy(monies[0]->query_money_array());
         for (i = 0; i < sizeof(m_array2); i += 2)
            m_array2[i + 1] = -m_array2[i + 1];
         this_player()->adjust_money(m_array2);
      }
      return monies[0];
   }
   else  {
      return NO_LEGAL;
   }
}
mixed *query_person_payments(int value, string place,
                             object payer, object payee) {
   mixed *stuff;
   mixed *mon_array;
   mixed *rabbit;
   mon_array = copy(payer->query_money_array());
   stuff = make_money_array_payment( 0, value, mon_array, place, 0);
   if (!stuff) {
      return 0;
   }
   if (stuff[MONEY_PAY_CHANGE]) {
      mon_array = copy(payee->query_money_array());
      rabbit = make_money_array_payment( 0, stuff[MONEY_PAY_CHANGE],
                                         mon_array, place, 0);
      if (!rabbit || rabbit[MONEY_PAY_CHANGE]) {
         return 0;
      }
      return ({ stuff[MONEY_PAY_RETURN], rabbit[MONEY_PAY_RETURN] });
   }
   return ({ stuff[MONEY_PAY_RETURN], ({ }) });
}
string * query_valid_types(){
  mixed *tmp;
  string *elem, *valid_types = ({ });
  int i;
  tmp = values(query_all_values());
  foreach( elem in tmp ){
    for( i = 0; i < sizeof( elem ); i += 2 ){
      if ( stringp( elem[i] ) )
        valid_types += ({ elem[i] });
    }
  } return valid_types;
}
string query_origin_of( string type ){
  string elem, *places;
  if( member_array( type, query_valid_types() ) == -1 )
    return 0;
  places = query_all_places();
  foreach( elem in places ){
    if( member_array( type,query_values_in( elem ) ) != -1 )
      return elem;
  }
}
string * query_aliases_of( string word ){
  string *types, elem, *aliases = ({ });
  types = query_valid_types();
  foreach( elem in types ){
    if( member_array( word,query_aliases_for( elem ) ) != -1 )
      aliases += ({ elem });
  } return aliases;
}
int query_value_of( string type ){
  if( member_array( type, query_valid_types() ) == -1 )
    return 0;
   return query_value( type, query_origin_of( type ) );
}
string smallest_in( string place ) {
   int i, smallest, r;
   mixed *values;
   values = query_values_in( place );
   smallest = values[1];
   r = 1;
   for ( i = 3; i < sizeof( values ); i += 2 ) {
      if ( values[i] < smallest ) {
         smallest = values[i];
         r = i;
      }
   }
   return values[r-1];
}
int smallest_value_in( string place ) {
   int i, smallest;
   mixed *values;
   values = query_values_in( place );
   smallest = values[1];
   for ( i = 3; i < sizeof( values ); i += 2 ) {
      if ( values[i] < smallest ) {
         smallest = values[i];
      }
   }
   return smallest;
}
mapping query_mapped_values_in( string where ) {
   mapping values = ([]);
  mixed * array;
  int i;
   if ( !where || ( where == "" ) )
      where = "default";
  array = query_values_in(where);
   for ( i = 1; i < sizeof(array); i += 2 )
  {
      values += ([array[i-1]:array[i]]);
   }
   return values;
}

==================================================
FILE: /lib/obj/handlers/monster_handler.c
==================================================

int num;
void create() {
  seteuid("Room");
  unguarded((: restore_object, "/save/monster-handler" :));
}
string query_shadow_name() {
  num++;
  return "/tmp/mon-shad/frog-"+num;
}
void reset() {
  unguarded((: save_object, "/save/monster-handler" :));
}
void dest_me() {
  unguarded((: save_object, "/save/monster-handler" :));
}

==================================================
FILE: /lib/obj/handlers/multiplayer.c
==================================================

#include <login_handler.h>
#include <playerinfo.h>
#define SAVE_FILE   "/save/multiplayer"
#define ALIST "/secure/alist"
#define ALLOWED_ITEMS ({ "/obj/misc/club_badge", "/obj/misc/al_receipt" })
string *denied_parcels;
mapping allowed;
protected void create() {
  string denied_parcel;
  int changed = 0;
  denied_parcels = ({ });
  allowed = ([ ]);
  seteuid(master()->creator_file(file_name()));
  if (file_size(SAVE_FILE + ".o") > 0) {
    unguarded((: restore_object, SAVE_FILE, 1 :));
  }
  foreach (denied_parcel in denied_parcels) {
    if (!PLAYER_HANDLER->test_user(denied_parcel)) {
      denied_parcels -= ({ denied_parcel });
      changed = 1;
    }
  }
  if (changed) {
    unguarded((: save_object, SAVE_FILE :));
  }
}
private void save_me() {
  unguarded((: save_object, SAVE_FILE :));
}
string *check_allowed(mixed user, mixed *others) {
  string *not_allowed;
  mixed tmp, alt;
  if(objectp(user))
    user = user->query_name();
  if(!allowed[user] && PLAYERINFO_HANDLER->query_alt_of(user) != "")
    user = PLAYERINFO_HANDLER->query_alt_of(user);
  not_allowed = ({ });
  foreach(tmp in others) {
    if(objectp(tmp))
      tmp = tmp->query_name();
    alt = PLAYERINFO_HANDLER->query_alt_of(tmp);
    if(!alt)
      alt = tmp;
    if(!allowed[user] || member_array(alt, allowed[user]) == -1)
      not_allowed += ({ tmp });
  }
  return not_allowed;
}
int add_git(string git) {
  PLAYERINFO_HANDLER->add_entry(this_player(), git, "multiplay",
                                "Caught multiplaying.\n");
  return 1;
}
int add_allowed(string user, string other) {
  int oldsize, changed;
  if (!(PLAYER_HANDLER->test_user(user) && PLAYER_HANDLER->test_user(other))) {
    return 0;
  }
  if(PLAYERINFO_HANDLER->query_alt_of(user))
    user = PLAYERINFO_HANDLER->query_alt_of(user);
  if(PLAYERINFO_HANDLER->query_alt_of(other))
    other = PLAYERINFO_HANDLER->query_alt_of(other);
  if (undefinedp(allowed[user])) {
    allowed[user] = ({ other });
  } else {
    oldsize = sizeof(allowed[user]);
    allowed[user] |= ({ other });
  }
  if (!oldsize || (oldsize != sizeof(allowed[user]))) {
    changed = 1;
    PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                                  "Added to multiplayer handler as allowed "
                                  "together with " + other + ".\n");
  }
  if (undefinedp(allowed[other])) {
    allowed[other] = ({ user });
  } else {
    oldsize = sizeof(allowed[other]);
    allowed[other] |= ({ user });
  }
  if (!oldsize || (oldsize != sizeof(allowed[other]))) {
    changed = 1;
    PLAYERINFO_HANDLER->add_entry(this_player(), other, "multiplay",
                                  "Added to multiplayer handler as allowed "
                                  "together with " + user + ".\n");
  }
  if (changed) {
    call_out((: save_me :), 1);
  }
  return 1;
}
int delete_allowed(string user) {
  if(PLAYERINFO_HANDLER->query_alt_of(user))
    user = PLAYERINFO_HANDLER->query_alt_of(user);
  if (undefinedp(allowed[user]))
    return 0;
  map_delete(allowed, user);
  call_out((: save_me :), 1);
  PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                                "Deleted from multiplayer handler "
                                "(allowed).\n");
  return 1;
}
mapping query_allowed() {
  return copy(keys(allowed));
}
int add_denied_parcel(string user) {
  if (!"/secure/master"->query_lord(geteuid(previous_object())) &&
      !"/d/liaison/master"->query_deputy(geteuid(previous_object()))) {
    write("You do not have permission to add a user to this list.\n");
    return 0;
  }
  if (member_array( user, denied_parcels) != -1) {
    denied_parcels -= ({ user });
  }
  if (!PLAYER_HANDLER->test_user(user)) {
    return 0;
  }
  denied_parcels += ({ lower_case(user) });
  call_out((: save_me :), 1);
  PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                            "Denied the use of the parcel system.\n");
  return 1;
}
int remove_denied_parcel(string user) {
  if (!"/secure/master"->query_lord(geteuid(previous_object())) &&
      !"/d/liaison/master"->query_deputy(geteuid(previous_object()))) {
    write("You do not have permission to remove a user to this list.\n");
    return 0;
  }
  if (member_array(user, denied_parcels) == -1)
    return 0;
  denied_parcels -= ({ user });
  call_out((: save_me :), 1);
  PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                           "Allowed the use of the parcel system.\n");
  return 1;
}
int member_denied_parcel( string user ) {
  if (member_array(user, denied_parcels) == -1)
    return 0;
  return 1;
}
string *query_denied_parcels() {
  return copy(denied_parcels);
}
varargs void mark_log(string user, string comment) {
  if (!comment) {
    log_file("MULTIPLAYERS", ctime(time())
             + " " + user
             + " Previous log entries handled.\n");
    PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                                  "Previous log entries handled.\n");
  } else {
    log_file("MULTIPLAYERS", ctime(time())
             + " " + user
             + ": " + comment + "\n" );
    PLAYERINFO_HANDLER->add_entry(this_player(), user, "multiplay",
                                  comment + "\n");
  }
}
string query_name() {
  return "Multiplayer handler";
}
void record_object(string action, object player, object item) {
  mixed stuff;
  stuff = item->query_property("dropped");
  if(sizeof(stuff) && player->query_name() != stuff[0])
    stuff = ({ player->query_name(), query_ip_number(player), time(),
                 stuff[0] });
  else
    stuff = ({ player->query_name(), query_ip_number(player), time() });
  item->add_property("dropped", stuff, 1800);
}
int check_multiplayers(string action, object player, object item) {
  mixed stuff;
  string direction, verb, res, is;
  if(objectp(player) && !interactive(player))
    return 0;
  stuff = item->query_property("dropped");
  if(!stuff)
    return 0;
  is = "";
  switch(action) {
  case "get":
    verb = " got ";
    direction = " from ";
    break;
  case "give":
    verb = " was given ";
    direction = " by ";
    is = "is ";
    break;
  case "slip":
    verb = " was slipped ";
    direction = " by ";
    is = "is ";
    break;
  case "palm":
    verb = " palmed ";
    direction = " from ";
    break;
  case "plant":
    verb = " planted ";
    direction = " on ";
    is = "is ";
    break;
  case "recover":
    verb = " recovered ";
    direction = " from ";
    break;
  }
  if(stuff[0] != player->query_name() &&
     query_ip_number(player) == stuff[1] &&
     sizeof(check_allowed(player, ({ stuff[0]}) ))) {
    res = capitalize(player->query_name()) + verb + item->a_short() +
      direction + stuff[0] + " who " + is +"logged in from the same "
      "address.";
  } else if(direction != " by " &&
            player->query_name() == stuff[0] &&
            player->query_refresh_time() > stuff[2]) {
    res = capitalize(player->query_name()) + verb + item->a_short() +
      " after a refresh.";
  } else if(ALIST->query_alt(player->query_name(), stuff[0]) == 100) {
    res = capitalize(player->query_name()) + verb + item->a_short() +
      direction + stuff[0] + " who is " + player->query_possessive() +
      " alt.";
  } else if(ALIST->query_alt(player->query_name(), stuff[0]) >= 60) {
    res = capitalize(player->query_name()) + verb +  item->a_short() +
      direction + stuff[0] + " who is POSSIBLY " +
      player->query_possessive() + " alt.";
  } else if(sizeof(stuff) == 4) {
    if(player->query_name() == stuff[3]) {
      if(player->query_refresh_time() > stuff[2]) {
        res = capitalize(player->query_name()) + verb + item->a_short() +
          " after a refresh" + direction + stuff[0] + ".";
      }
    } else if(ALIST->query_alt(player->query_name(), stuff[3]) == 100) {
      res = capitalize(player->query_name()) + verb + item->a_short();
      if(stuff[0] != player->query_name())
        res += " via " + stuff[0];
      res += direction + stuff[3] + " who is " + player->query_possessive() +
        " alt.";
    } else if(ALIST->query_alt(player->query_name(), stuff[3]) >= 60) {
      res = capitalize(player->query_name()) + verb + item->a_short();
      if(stuff[0] != player->query_name())
        res += " via " + stuff[0];
      res += direction + stuff[3] + " who is _POSSIBLY_ " +
        player->query_possessive() + " alt.";
    }
  } else if((PLAYER_HANDLER->test_creator(stuff[0]) ||
             PLAYER_HANDLER->test_property(stuff[0], "test character")) &&
            !player->query_creator() &&
            !player->query_property("test character") &&
            member_array(base_name(item), ALLOWED_ITEMS) == -1 &&
            base_name(item)[0..14] != "/d/liaison/TOYS") {
    res = capitalize(player->query_name()) + verb + item->a_short() +
      direction + stuff[0];
    user_event("inform", res, "cheat");
    log_file("/d/admin/log/CHEAT", ctime(time()) + ": " +
             player->convert_message(res) + "\n");
    return 0;
  }
  if(res) {
    user_event("inform", res, "multiplayer");
    log_file("MULTIPLAYERS", ctime(time()) + ": " +
             player->convert_message(res) + "\n");
  }
  return 0;
}
