# Total Tokens: 15790
# Total Files Merged: 11
# Total Characters: 52664

lish_handler.c
==================================================

float *freq=({ 0.070012, 15.782218, 0.011949, 43.328090, 0.021800, 31.780955,
                 0.041222, 22.534301, 0.081093, 11.110506, 0.016799, 34.952377,
                 0.019235, 35.094824, 0.031751, 21.939816, 0.055348, 15.959625,
                 0.001028, 116.456628, 0.007624, 57.669862, 0.029144,
                 22.558570, 0.028764, 31.148966, 0.047194, 18.490345, 0.054178,
                 15.319177, 0.014415, 36.228697, 0.001335, 116.456628,
                 0.047561, 18.817823, 0.050139, 17.975454, 0.058789, 13.617099,
                 0.020638, 32.978418, 0.005222, 63.346619, 0.011713, 42.180909,
                 0.001264, 116.456628, 0.014661, 40.185678, 0.000530,
                 116.456628, 0.171614, 40.0, 0.000666, 116.456628,
                 0.084311, 10.304674
});
int FreqTest( string line ) {
  int len,i,ch;
  float badness,term;
  int *let;
  let=allocate(29);
  i = len = strlen(line);
  while (i--) {
    ch = line[i];
    if ((ch>=65 && ch<65+26) || (ch>=97 && ch<97+26)) let[(ch&31)-1]++;
    else if (ch==' ') let[26]++;
    else if (ch>='0' && ch<='9') let[27]++;
    else let[28]++;
  }
  badness = 0.0;
  for (i=0;i<29;i++) {
    term = to_float((to_float(let[i]) - freq[i<<1] * len) * freq[(i<<1)+1]);
    badness += (term>0 ? term : -term);
  }
  badness /= (29.0*len);
  i = 100 - 50*badness*badness;
  if (i<1) i=1;
  return i;
}
int ProfaneTest( string strin ) {
  int i,profane=0;
  string str,s;
  if (sizeof(strin)<1) return 0;
  strin=lower_case(strin)+" ";
  str="";
  for (i=0;i<sizeof(strin);i++) {
    if (strin[i]>='a' && strin[i]<='z') str+=strin[i..i];
  }
  if (sizeof(str)<2) return 0;
  s=str[0..0];
  for (i=1;i<sizeof(str);i++) {
    if (s[<1]!=str[i]) s+=str[i..i];
  }
  if (regexp(s,"bastard|tit|shaft|viag")
     || regexp(str,"poo|ass|butt")) profane+=25;
  if (regexp(s,"arse|sex|sux|crap|testic|fart|orgasm|orgy|turd|porn|niple|nazi|jesus|christ|satan|sperm|smeg|toilet|genital")
     || regexp(str,"piss|root|buttw|assho")
     || regexp(strin,"butt |ass ")) profane+=50;
  if (regexp(s,"netsex|arse|shit|screw|urine|rectum|tampon|vibrator|rectal|scatol|semen|suck|lick|dyke|dike|wank|mutha|prost|fag|feck|gay|homo|fuq|horny|blowjob|cuni")
     || regexp(str,"phall|hooter|poof")) profane+=100;
  if (regexp(s,"anal|rape|rapist|fuck|fuk|fuch|kuck|cunt|kunt|whor|slut|clit|masturb|masterb|penis|cock|dick|pusy|bitch|vagina")) profane+=200;
  return profane;
}

==================================================
FILE: handlers/error_handler.c
==================================================

inherit "/obj/handlers/inherit/error_handler";
void create() {
  seteuid("Root");
   ::create();
}
void setup_error_handler(string user, string db, string password) {
   ::setup_error_handler(user, db, password);
}

==================================================
FILE: handlers/error_tracker.c
==================================================

inherit "/std/dom/error_tracker_master";
void create() {
    set_domain( "mudlib" );
    set_name( "The Mudlib's Lord of the Whinge" );
    set_other_dirs( ({
        "/std%",
        "/obj%",
        "/global%",
        "/cmds%",
        "/mudlib%",
        "/include%",
        "/net%",
        "/soul%",
        "/room%",
        "/www%",
      }) );
    set_period( 604800 );
    ::create();
}

==================================================
FILE: handlers/fairy_godmothers.c
==================================================

#include <panic.h>
#include <config.h>
#include <playerinfo.h>
#include <cwc.h>
#define HARRY_SHADOW "/std/shadows/misc/harry_shadow"
object* _panicers;
object* _godmothers;
object* _queue;
#define FREE_NAME "free trip"
#define THRESHOLD 50
#define DAY (60*60*24)
public  void   continue_panicing(string str, object panicer);
private object startup_godmother(object ob);
private void   finish_with_person(object ob, int ok);
void create() {
  _panicers = ({ });
  _godmothers = allocate(NUM_GODMOTHERS);
  _queue = ({ });
}
object *query_godmothers() { return copy(_godmothers); }
int free_godmothers() {
  int i;
  for (i=0;i<sizeof(_godmothers);i++) {
    if (!_godmothers[i]) {
      return 1;
    }
  }
  return 0;
}
int do_startup(object panicer) {
  if (environment(panicer) &&
      environment(panicer)->query_property("no godmother")) {
    notify_fail(environment(panicer)->query_property("no godmother"));
    return 0;
  }
  if (panicer->query_property("attacked godmother") &&
      (panicer->query_property("attacked godmother") + DAY * 10) > time())
  {
    notify_fail("You attacked a godmother!  No help for you!\n");
    return 0;
  }
  if (sizeof(panicer->query_attacker_list())) {
    notify_fail("You cannot use a godmother whilst you are in a fight.\n");
    return 0;
  }
  panicer->remove_property("attacked godmother");
  _panicers -= ({ 0 });
  if (member_array(panicer, _panicers) != -1  ||
      member_array(panicer, _queue) != -1)
  {
    notify_fail("You are already requesting assistance.  Be patient.\n");
    return 0;
  }
  if (!panicer) {
    panicer = this_player();
  }
  if (panicer->query_level() < 10 ||
      !arrayp(environment(panicer)->query_exits()) ||
      !sizeof(environment(panicer)->query_exits()) ||
      !environment(panicer))
  {
    write("You feel help is on its way.\n");
    panicer->add_property("godmother", FREE_NAME);
    continue_panicing("y", panicer);
  }
  else {
    panicer->remove_property("godmother");
    if (panicer->query_level() < 50) {
      int max_gp;
      max_gp = panicer->query_max_gp();
      if (panicer->query_gp() < max_gp / 3) {
        notify_fail("You do not have enough guild points to summon "
                    "a godmother.  You need at least " +
                    (max_gp / 3) + ".\n");
        return 0;
      }
      write("This will cost you all of your current guild points and "
            "social points, and leave you feeling a little weak.  "
            "Do you wish to continue? ");
      input_to("continue_panicing", 0, panicer);
    }
    else {
      if (panicer->query_max_deaths() <= panicer->query_deaths()) {
        notify_fail("You do not have a life to spend on a godmother.\n");
        return 0;
      }
      write("This will cost you a life, do you wish to continue? ");
      input_to("continue_panicing", 0, panicer);
    }
  }
  return 1;
}
private void do_check_queue() {
   _queue -= ({ 0 });
   if (sizeof(_queue)) {
      if (startup_godmother(_queue[0])) {
         _queue = _queue[1..];
      }
   }
}
private void setup_harrass_callout() {
  int i;
  int check_queue;
  int waiting;
  int max_wait;
  for (i = 0; i < sizeof(_godmothers); i++) {
    if (_godmothers[i]) {
      waiting = _godmothers[i]->query_waiting();
      if (waiting > FIRST_WAIT_TIME && environment(_godmothers[i])) {
        _godmothers[i]->hurry_up();
      }
      if (!environment(_godmothers[i])) {
         _godmothers[i]->dest_me();
         check_queue = 1;
      }
      if (waiting > max_wait) {
        max_wait = waiting;
      }
    }
  }
  if (max_wait < FIRST_WAIT_TIME) {
    call_out("do_hurry_up", FIRST_WAIT_TIME-max_wait+2);
  }
  if (check_queue) {
    do_check_queue();
  }
}
void continue_panicing(string str, object panicer) {
  str = lower_case(str);
  if (!str || str == "" || (str[0] != 'y' && str[0] != 'n')) {
    if (panicer->query_level() < 100) {
      write("This will cost you all of your current guild points and "
            "social points and leave you feeling a little weak.  "
            "Do you wish to continue? ");
      input_to("continue_panicing", 0, panicer);
      return ;
    }
    else {
      write("This will cost you a life, do you wish to continue? ");
      input_to("continue_panicing", 0, panicer);
      return ;
    }
  }
  if (str[0] == 'n') {
    write("Ok.  They do not show up to help you.  Good luck.\n");
    return ;
  }
  if (!startup_godmother(panicer)) {
    write("You hope a godmother will turn up sometime soon.\n");
    _queue += ({ panicer });
    setup_harrass_callout();
  }
}
void do_panic_callout(object godmother, object ob) {
  godmother->do_panic(ob);
}
private object startup_godmother(object ob) {
  object godmother;
  int    i, num;
  i = random(NUM_GODMOTHERS);
  if (_godmothers[i]) {
    for (num = 1; num < NUM_GODMOTHERS; num++)  {
      i = (i + 1) % NUM_GODMOTHERS;
      if (!_godmothers[i])  break;
    }
  }
  if (num == NUM_GODMOTHERS)
     return 0;
  switch (i) {
    case 0:
      godmother = clone_object(GODMOTHER_DIR + "granny");
      break;
    case 1:
      godmother = clone_object(GODMOTHER_DIR + "magrat");
      break;
    default:
      write("Something is hosed.  Please file a bug report.\n");
      break;
  }
  _godmothers[i] = godmother;
  godmother->move(environment(ob), "As if by magic $N appears.", "");
  call_out("do_panic_callout", 1, godmother, ob);
  _panicers += ({ ob });
  return godmother;
}
void finish_panic(object person, int ok) {
  int i;
  if (person)  {
     finish_with_person(person, ok);
  }
  _panicers -= ({ person });
  for (i = 0; i < sizeof(_godmothers); i++)  {
    if (_godmothers[i] == previous_object()) {
      call_out("do_move", 10, _godmothers[i] );
      break;
    }
  }
  do_check_queue();
  if (!sizeof(_queue)) {
     remove_call_out("do_hurry_up");
  }
}
void do_move (object fairy) {
      fairy->move("/room/rubbish", "",
          "With a quick flick of her wand, the fairy godmother is gone.");
      fairy = 0;
}
private void finish_with_person(object person, int ok)  {
  if (member_array(person, _panicers) == -1) {
    log_file("GODMOTHER_ERROR", "person == %O, godmother == %s\n", person, previous_object()->query_short());
    write("Consistancy error, they never paniced.\n");
    return ;
  }
  if (ok) {
    if (person->query_property("godmother") == FREE_NAME) {
    }
    else if (person->query_level() < THRESHOLD) {
      person->adjust_tmp_con(-2);
      person->set_gp(0);
      person->set_sp(0);
    }
    else if (person->query_level() >= THRESHOLD &&
             person->query_max_deaths() > person->query_deaths()) {
      PLAYERINFO_HANDLER->add_entry(person,
        person->query_name(), "misc", "Lost a life to the Godmother");
      log_file("GODMOTHER_DEATH", "%s: %s lost a life to the Godmother\n",
        ctime(time()), person->query_name());
      person->adjust_deaths(1);
    }
    call_out(function(object person) {
      string destination;
      destination = person->query_nationality()->query_default_start_location();
      person->move_with_look(destination,
                             "$N appears out of nowhere.",
                             "$N disappears with a pop.");
      if (person->query_ghost()) {
        person->remove_ghost();
        clone_object(HARRY_SHADOW)->setup_shadow(person,
                                                 "a fairy godmother" );
      }
    }, 2, person);
  }
  person->remove_property("godmother");
}
void do_hurry_up() {
  int i;
  int waiting;
  int max_wait;
  if (!sizeof(_queue)) {
    return ;
  }
  for (i = 0; i < sizeof(_godmothers); i++) {
    if (_godmothers[i]) {
      if (!environment(_godmothers[i])) {
        _godmothers[i]->dest_me();
        _godmothers[i] = 0;
      }
      else {
        waiting = _godmothers[i]->query_waiting();
        if (waiting > FIRST_WAIT_TIME) {
          if (waiting > FINISH_WAIT_TIME) {
            _godmothers[i]->finish_up();
          } else {
            _godmothers[i]->hurry_up();
          }
        }
        if (waiting > max_wait) {
          max_wait = waiting;
        }
      }
    }
  }
  if (max_wait > 0) {
    if (FINISH_WAIT_TIME - max_wait < 10) {
      call_out("do_hurry_up", 10);
    } else {
      call_out("do_hurry_up", FINISH_WAIT_TIME-max_wait);
    }
  }
}
void dest_me() {
  int i;
  for (i = 0; i < sizeof(_godmothers); i++) {
    if (_godmothers[i]) {
      _godmothers[i]->dest_me();
    }
  }
  destruct(this_object());
}

==================================================
FILE: handlers/finderror_helper.c
==================================================

#include <log.h>
#include <config.h>
#include <db.h>
nosave inherit "/std/object";
private void recursive_add_directory( string word, string dir );
class error_data {
    string name;
    string *dirs;
    int no_calls;
}
nosave mapping _error_cache;
string name, *dirs;
void create() {
    ::create();
    set_name( "finderror_helper" );
    set_short( "finderror helper" );
    _error_cache = ([ ]);
}
private string strip_extension( string file ) {
    if ( file[<1] == '/' ) {
        return file[0..<2];
    }
    return file;
}
private class error_data get_data_file( string word ) {
    string file;
    if ( _error_cache[ word ] ) {
        return _error_cache[ word ];
    }
    seteuid( word );
    file = "/w/" + word + "/finderror.o";
    if ( file_size( file ) > 0 ) {
        unguarded( (: restore_object, file :) );
        _error_cache[ word ] = new( class error_data,
            name : name,
            dirs : map( dirs, (: strip_extension :) ),
            no_calls : 0 );
    }
    else {
        _error_cache[ word ] = new( class error_data,
            name : word,
            dirs : ({ }),
            no_calls : 0 );
    }
    return _error_cache[ word ];
}
private int save_data_file( string word ) {
    seteuid( word );
    if ( _error_cache[ word ] ) {
        name = _error_cache[ word ]->name;
        dirs = _error_cache[ word ]->dirs;
        unguarded( (: save_object, "/w/" + word + "/finderror" :) );
        return 1;
    }
    return 0;
}
string escape( string txt ) {
    return replace( txt, ({ "'", "\\'" }) );
}
private string assemble_dirs_sql( string *dirs ) {
    dirs = map( dirs, (: escape :) );
    return "(" + implode( map( dirs,
            (: "Directory" + ( strsrch( $1, "%" ) > -1 ? " LIKE " : " = " )
            +  "'" + $1 + "'" :) ), " OR " ) + ")";
}
void finished_query( int status, mixed data, function func, object player ) {
    evaluate( func, player, status, data );
}
public int query_dirs_count(mixed player, function finish_func ) {
  class error_data info;
  string query;
  string txt;
  string word;
    if ( objectp( player ) ) {
  word = player->query_name();
    }
    else {
        word = player;
        player = this_object();
    }
  info = get_data_file( word );
  if ( sizeof( info->dirs ) ) {
        txt = assemble_dirs_sql( info->dirs );
        query = "SELECT Directory, Type, COUNT(Id) FROM errors WHERE " + txt + " AND "
            "Status = 'OPEN' GROUP BY Directory, Type;";
        DB_HANDLER->make_sql_request("errors", CONFIG_DB_ERRORS_USER, "",
            query, (: finished_query( $1, $2, $(finish_func), $(player) ) :) );
        return 1;
  }
  return 0;
}
public int query_errors_in_dirs(string *directories, function finish_func ) {
    string query;
    string txt;
    if ( directories ) {
        directories = map( directories , (: escape :) );
        txt = "(" + implode( map( directories,
            (: "Directory" + ( strsrch( $1, "%" ) > -1 ? " LIKE " : " = " )
            +  "'" + $1 + "'" :) ), " OR " ) + ")";
        query = "SELECT Directory, Type, COUNT(Id) AS C FROM errors WHERE " + txt + " AND "
            "Status = 'OPEN' GROUP BY Directory, Type";
        DB_HANDLER->make_sql_request("errors", CONFIG_DB_ERRORS_USER, "",
            query, (: finished_query( $1, $2, $(finish_func), $(this_player()) ) :) );
        return 1;
    }
    return 0;
}
public void query_next_dir( object player, function finish_func ) {
    string query;
    string txt;
    string word;
    class error_data info;
    word = player->query_name();
    info = get_data_file( word );
    if ( sizeof( info->dirs ) ) {
        txt = assemble_dirs_sql( info->dirs );
        query = "SELECT Directory, COUNT(Id) AS C FROM errors WHERE " + txt +
            " AND Status = 'OPEN' GROUP BY Directory HAVING C > 0 LIMIT 1;";
        DB_HANDLER->make_sql_request( "errors", CONFIG_DB_ERRORS_USER, "",
            query, (: finished_query( $1, $2, $(finish_func), $(player) ) :) );
    }
    else {
        tell_object( player, "You have no finderrors directories defined.  Add "
            "them with 'finderrors add'\n" );
    }
}
public string *query_directories( string player ) {
    class error_data data;
    data = get_data_file( player );
    return copy( data->dirs );
}
public int add_directory( object player, string dir, int recursive ) {
    int res;
    class error_data info;
    string word;
    word = player->query_name();
    info = get_data_file( word );
    res = member_array( dir, info->dirs );
    if ( recursive )  {
        dir += "%";
    }
    if ( res == -1 ) {
        if ( dir[ <1 ] == '/') {
            dir = dir[ 0 .. <2 ];
        }
        info->dirs = ({ dir }) + info->dirs;
        tell_object( player, "Added " + dir +
            (recursive ? " (recursive)" : "") + "\n" );
        save_data_file( word );
    }
    return 1;
}
private void recursive_add_directory( object player, string dir ) {
    mixed *directories, *file;
    class error_data info;
    string word;
    word = player->query_name();
    info = get_data_file( word );
    info->no_calls--;
    directories = get_dir( dir, -1 );
    if ( directories ) {
        foreach ( file in directories ) {
            if ( file[ 1 ] == -2 && file[ 0 ] != "Maps") {
                add_directory( player, dir + file[ 0 ] +"/", 1 );
            }
        }
    }
    if ( info->no_calls == 0 ) {
        tell_object( player,
            "All subdirectories have been added to the list.\n" );
        save_data_file( word );
    }
}
public int remove_directory( object player, string directory, int recursive ) {
    class error_data info;
    string word;
    int pos;
    word = player->query_name();
    info = get_data_file( word );
    if ( recursive ) {
        pos = sizeof( directory ) - 1;
        info->dirs = filter( info->dirs,
            (: $1[ 0..$(pos) ] != $(directory) :));
    }
    else {
        pos = member_array( directory, info->dirs );
        if ( pos == -1 ) {
            return 0;
        }
       info->dirs = info->dirs[ 0..pos - 1 ] + info->dirs[ pos+1.. ];
    }
    save_data_file( word );
    return 1;
}

==================================================
FILE: handlers/firework.c
==================================================

#define BROADCASTER "/obj/handlers/broadcaster"
#define MAX_RANGE 1600
#define SHIFT 30
#define TIME 15
class firework_running {
   string *messages;
   int index;
   string caster;
   string text;
   int *co_ord;
}
mixed *_effects;
class firework_running *_fireworks;
protected void do_effects();
void create() {
  _effects = ({
    ({
      "A small dot flashes up high into the sky.",
      "The dot suddenly bursts open revealing bright multicoloured streams "
          "of flame that pour down towards the ground.",
      "Just as you thought the streams had faded to nothing, they shoot back "
          "up into the air giving a final brilliant yellow colour before "
          "vanishing entirely.",
      "As it fades you think you see the letters \"$arg$\" in the gradually "
          "disappearing smoke.",
    }),
    ({
      "A brilliant trail of yellow sparks follows a small dot up into the "
          "sky.",
      "The dot slowly slows down until it has stopped moving, and hovers for "
          "a few seconds.",
      "Suddenly the dot explodes, sending out bright red streamers of light "
          "in all directions and lighting up the sky for a few seconds.",
      "The red light fades to nothingness, and the last colour left in the "
          "sky shows the letters \"$arg$\" which slowly disappear.",
    }),
    ({
      "A light flashes up high into the sky trailing grey smoke behind it.",
      "The light wizzes around in circles making a high pitched whizzing "
          "noise.",
      "The dot bursts open sending brilliant green streamers of light to "
          "all the corners of the sky.",
      "With a sudden resounding bang, the streamers rush back together to form "
          "\"$arg$\" which hangs in the sky before slowly vanishing."
    }),
  });
  _fireworks = ({ });
}
varargs void random_firework( object caster, string text ) {
  mixed *co_ord;
  class firework_running new_firework;
  co_ord = (mixed *)environment( caster )->query_co_ord();
  if ( sizeof( co_ord ) < 3 ) {
    co_ord = ({ 0, 0, 0 });
  }
  if ( !text || ( text == "" ) ) {
    text = (string)caster->query_name();
  }
  new_firework = new(class firework_running);
  new_firework->messages = _effects[random(sizeof(_effects))];
  new_firework->index = 0;
  new_firework->text = capitalize(text);
  new_firework->co_ord = ({ co_ord[ 0 ], co_ord[ 1 ], co_ord[ 2 ] + SHIFT });
  if ( !sizeof(_fireworks)) {
    call_out( (: do_effects :), TIME );
  }
  _fireworks += ({ new_firework });
}
protected void do_effects() {
  class firework_running firework;
  foreach (firework in _fireworks) {
    BROADCASTER->broadcast_event( users(), firework->co_ord, "you see:\n"+
        replace( firework->messages[firework->index] , "$arg$",
        firework->text ), MAX_RANGE, 0, 0 );
    firework->index++;
    if ( firework->index >= sizeof( firework->messages ) ) {
      _fireworks -= ({ firework });
    }
  }
  if ( sizeof( _fireworks ) ) {
    call_out( (: do_effects :), TIME );
  }
}
mixed *query_effects() {
   return _effects;
}

==================================================
FILE: handlers/folder_handler.c
==================================================

#pragma strict_types
#include <board.h>
#include <comms.h>
#include <mail.h>
#include <network.h>
#include <mime.h>
#include <player_handler.h>
#define MAIL_PATH "/save/mail/"
int *mesg_numbers;
class mail_header *info;
int new_thingy;
nosave int link;
class mail_header *get_messages(string pname, string fname);
string load_message(string pname, string fname, int number);
void delete_it(string pname, string fname, int *deleted);
string check_local(string arg);
private int load_counter();
private void save_counter(int counter);
void dest_me();
void delete_account(string player);
void create() {
  seteuid("Mailer");
}
private string folder_filename(string name) {
  if(file_size(MAIL_PATH + name) != -1) {
    unguarded((: rename, MAIL_PATH + name,
         MAIL_PATH + name[0..0] + "/" + name :));
  } else if(file_size(MAIL_PATH + name + ".o") != -1) {
    unguarded((: rename, MAIL_PATH + name + ".o",
         MAIL_PATH + name[0..0] + "/" + name + ".o" :));
  }
  return MAIL_PATH+name[0..0] + "/"  + name;
}
private string message_filename(int num, string prefix) {
  if(file_size(MAIL_PATH+"new_mesg/" + (num % 50)) == -1) {
    unguarded((: mkdir, MAIL_PATH+"new_mesg/" + (num % 50) :));
  }
  if(file_size(MAIL_PATH+"new_mesg/"+(num % 50)+"/"+((num / 50) % 50)) == -1) {
    unguarded((: mkdir, MAIL_PATH+"new_mesg/" + (num %50) + "/" +
         ((num / 50) % 50) :));
  }
#ifdef 0
  if(file_size(MAIL_PATH + "mesg/" + prefix + num) != -1) {
    unguarded((: rename, MAIL_PATH + "mesg/" + prefix + num,
     MAIL_PATH+"new_mesg/"+ (num % 50) + "/" + ((num / 50) % 50) +
     "/" + prefix + num :));
  }
#endif
  return MAIL_PATH+"new_mesg/"+  (num % 50) + "/" + ((num / 50) % 50) +
    "/" + prefix + num;
}
nomask int can_create_folder(string player, string folder) {
    return file_size(folder_filename(player) + folder + ".o") == -1;
}
private void convert_links(int number) {
  string message;
  int tmplink;
  message = unguarded((: read_file, message_filename(number, "l"), 1, 1 :));
  if (!message || sscanf(message, "%d", tmplink) != 1) {
    return;
  }
  sscanf(message, "%d", tmplink);
  message = unguarded((: read_file, message_filename(number, "") :));
  unguarded((: rm, message_filename(number, "") :));
  unguarded((: rm, message_filename(number, "l") :));
  unguarded((: write_file, message_filename(number, ""),
               "" + tmplink + "\n" + message :));
}
private string query_message_data(int number) {
   string data;
   convert_links(number);
   data = unguarded((: read_file, message_filename(number, "") :));
   if(!data)
     return data;
   sscanf(data, "%*d\n%s", data);
   return data;
}
private void create_new_message(int number, string data, int links) {
   unguarded((: rm, message_filename(number, "") :));
   unguarded((: write_file, message_filename(number, ""),
                            "" +links + "\n" + data :));
}
private void increment_links(int number) {
  string message;
  int num_links;
  convert_links(number);
  message = unguarded((: read_file, message_filename(number, "") :));
  if (!message) {
     return ;
  }
  sscanf(message, "%d\n%s", num_links, message);
  num_links++;
  unguarded((: rm, message_filename(number, "") :));
  unguarded((: write_file, message_filename(number, ""),
               "" + num_links + "\n" + message :));
}
private void decrement_links(int number) {
  string message;
  int num_links;
  convert_links(number);
  message = unguarded((: read_file, message_filename(number, "") :));
  if (!message) {
     return ;
  }
  sscanf(message, "%d\n%s", num_links, message);
  num_links--;
  unguarded((: rm, message_filename(number, "") :));
  if (num_links > 0) {
     unguarded((: write_file, message_filename(number, ""),
                  "" + num_links + "\n" + message :));
  }
}
private int check() {
  string base;
  base = base_name(previous_object());
  if (base != "/obj/handlers/mailer" &&
      base != "/obj/handlers/folder_handler" &&
      base != "/obj/handlers/converter" &&
      base != "/net/daemon/pop3" &&
      base != "/net/daemon/imap4" &&
      base != "/secure/bulk_delete") {
    printf("Folder handler: Illegal access ! (%O)\n", base);
    return 1;
  } else
    return 0;
}
private void convert_class(string pname, string fname) {
  class mail_header hdr;
  int i;
  i = sizeof(info);
  while (i--) {
    hdr = new(class mail_header);
    hdr->number = ((mapping)info[i])["number"];
    hdr->status = ((mapping)info[i])["status"];
    hdr->subject = ((mapping)info[i])["subject"];
    hdr->from = ((mapping)info[i])["from"];
    info[i] = hdr;
  }
  unguarded((: save_object, folder_filename(lower_case(pname)+fname) :));
}
class mail_header *get_messages(string pname, string fname) {
  if (check())
    return ({ });
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+fname) :));
  if (sizeof(info) && mapp(info[0])) {
    convert_class(pname, fname);
  }
  return info;
}
string load_message(string pname, string fname, int number) {
  string message;
  if (check()) {
    return " ";
  }
  if (file_size(message_filename(number, "l")) > 0)  {
    convert_links(number);
  }
  message = query_message_data(number);
  if (!message) {
    printf("* Failed to load message.\n", number);
  }
  return message;
}
void delete_it(string pname, string fname, int *deleted) {
  int i, idx;
  if (check()) {
    return;
  }
  if (!PLAYER_HANDLER->test_user(pname)) {
    return;
  }
  if (sizeof(deleted) > 1) {
    deleted = uniq_array(deleted);
    deleted = sort_array(deleted, 1);
  }
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+fname) :));
  if (sizeof(info) && mapp(info[0])) {
    convert_class(pname, fname);
  }
  i = sizeof(deleted);
  while (i--) {
    reset_eval_cost();
    if ((idx = member_array(deleted[i], mesg_numbers)) > -1) {
      if (file_size(message_filename(mesg_numbers[idx], "l")) > 0) {
        convert_links(mesg_numbers[idx]);
      }
      decrement_links(mesg_numbers[idx]);
      mesg_numbers = delete(mesg_numbers, idx, 1);
      if (idx < sizeof(info) && info[idx] &&
          ((class mail_header)info[idx])->status == "N") {
        new_thingy--;
      }
      info = delete(info, idx, 1);
    }
  }
  unguarded((: save_object, folder_filename(lower_case(pname)+fname) :));
}
private void send_frog(object player, string to, string from) {
   object ob;
   if (!player || !environment(player)->send_message(to)) {
      catch(ob = clone_object(POST_FROG));
      write("A small frog with a post office hat wanders up and takes "
            "your mail.\n");
      say("A small frog with a post office hat wanders up to "+
          player->query_cap_name()+" and takes "+
          player->query_possessive()+" mail.\n");
      if (find_player(to) && sscanf(from, "%*s@%*s") == 2) {
        catch(ob->move(COMM_ROOM, ob->query_mmsgin(), ob->query_mmsgout()));
      } else {
        catch(ob->move(environment(player)));
      }
      catch(ob->send_mail(to, from));
   }
}
private void send_notification(string to,
                               string from) {
    if (find_player(from) ||
        sscanf(from, "%*s@%*s") == 2) {
       call_out((: send_frog :), 0, find_player(from), to, from);
    }
}
void add_it(class mail_message mesg, int flag) {
  int i, counter, bong, ptpost;
  string *local_to, *remote_to, *fail_to, str;
  class mail_header hdr;
  if (check()) {
    return;
  }
  if (sizeof(mesg->cc)) {
    mesg->to += mesg->cc;
  }
  mesg->to = MIME->get_email_addrs(implode(mesg->to, ","))[0];
  local_to = ({ });
  remote_to = ({ });
  fail_to = ({ });
  str = "";
  bong = sizeof(mesg->to);
  for (i = 0; i < bong; i++) {
    if ((str = check_local(mesg->to[i]))) {
      if (MAIL_TRACK->query_list(str)) {
        local_to += MAIL_TRACK->query_members(str) - ({ mesg->from });
        if ( str == "playtesters" ) {
          ptpost = 1;
        }
      } else {
        local_to += ({ str });
      }
    } else {
      remote_to += ({ mesg->to[i] });
    }
  }
  local_to = uniq_array(local_to);
  remote_to = uniq_array(remote_to);
  if ((i = sizeof(local_to))) {
    if (!(counter = load_counter())) {
      if (!flag) {
        printf("Aborting send of message...\n");
      }
      return;
    }
    if (file_size(message_filename(counter, "")) > 0) {
      if (!flag) {
        printf("Fatal error when sending message: File %d exists.\n"
               "Please contact Turrican.\n", counter);
      }
      return;
    }
    for (i = 0; i < sizeof(local_to); i++) {
      if (!flag) {
        printf("Sending to: %s.\n", capitalize(local_to[i]));
      }
      if(MAIL_TRACK->find_mailer(local_to[i]) ||
         PLAYER_HANDLER->test_user(local_to[i])) {
        mesg_numbers = ({ });
        info = ({ });
        new_thingy = 0;
        unguarded((: restore_object, folder_filename(local_to[i]+"inbox") :));
        if (sizeof(info) && mapp(info[0]))
          convert_class(local_to[i], "inbox");
        if(sizeof(mesg_numbers) > MAX_FOLDER_SIZE) {
          write("Sorry, mailbox is full for " + local_to[i] + ".\n");
          mesg->to -= ({ local_to[i] });
          mesg->cc -= ({ local_to[i] });
          local_to = delete(local_to, i--, 1);
          continue;
        }
        if(!PLAYER_HANDLER->test_active(local_to[i])) {
          write("Sorry, " + local_to[i] + " is inactive and so unable to "
                "receive mail.\n");
          mesg->to -= ({ local_to[i] });
          mesg->cc -= ({ local_to[i] });
          local_to = delete(local_to, i--, 1);
          continue;
        }
        mesg_numbers += ({ counter });
        new_thingy++;
        hdr = new(class mail_header);
        hdr->number = counter;
        hdr->status = "N";
        hdr->subject = mesg->subject;
        hdr->from = mesg->from;
        info += ({ hdr });
        if (!unguarded((: save_object, folder_filename(local_to[i]+"inbox") :))) {
          if (!flag) {
            printf("Couldn't save mailbox for %s...\n",
                   capitalize(local_to[i]));
          }
          mesg->to -= ({ local_to[i] });
          mesg->cc -= ({ local_to[i] });
          local_to = delete(local_to, i--, 1);
          continue;
        }
        if(this_player() && environment(this_player()))
          send_notification(local_to[i], mesg->from);
      } else {
        fail_to += ({ local_to[i] });
        mesg->to -= ({ local_to[i] });
        mesg->cc -= ({ local_to[i] });
        local_to = delete(local_to, i--, 1);
      }
    }
    if (i) {
      ++counter;
      save_counter(counter);
      create_new_message(counter - 1, mesg->body, i);
    }
  }
  if ((i = sizeof(fail_to))) {
    while (i--) {
      MAILER->do_mail_message(mesg->from, "postmaster", "Error! User "+
                              fail_to[i]+" unknown", 0,
                              "Original message included:\n\n> "+
                              replace_string(mesg->body, "\n", "\n> "), 1, 0);
    }
  }
  if (sizeof(remote_to) && !flag) {
    for (i = 0; i < sizeof(remote_to); i++) {
      sscanf(remote_to[i], "%*s@%s", str);
      if (str && INTERMUD_D->GetMudName(str)) {
        printf("Sorry, Intermud mail is not currently supported.  "
               "Didn't send mail to %s.\n", remote_to[i]);
        remote_to = delete(remote_to, i--, 1);
        continue;
      }
    }
    SMTP->eventSendMail(remote_to, mesg->from, mesg->body);
  }
  if (ptpost) {
    BOARD_HAND->add_message("playtesters", capitalize(mesg->from),
                            mesg->subject, sprintf( "%-=78s\n",
                            mesg->body ));
  }
}
void mark_read(string pname, string fname, int *unread) {
  int i;
  if (check()) {
    return;
  }
  if (!PLAYER_HANDLER->test_user(pname)) {
    return;
  }
  unread = uniq_array(unread);
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+fname) :));
  if (sizeof(info) && mapp(info[0])) {
    convert_class(pname, fname);
  }
  if (new_thingy == sizeof(unread)) {
    return;
  }
  new_thingy = 0;
  i = sizeof(mesg_numbers);
  while (i--) {
    if (member_array(i, unread) > -1) {
      ((class mail_header)info[i])->status = "N";
      new_thingy++;
    }
    else if(i < sizeof(info))
      ((class mail_header)info[i])->status = " ";
    else
      write("\nErk, problems. The arrays don't quite match.\n");
    reset_eval_cost();
  }
  unguarded((: save_object, folder_filename(lower_case(pname)+fname) :));
  new_thingy = 0;
}
int move_it(string pname, string from, string to, int number) {
  class mail_header tmphdr;
  if (check())
    return 1;
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+to) :));
  if (sizeof(info) && mapp(info[0])) {
    convert_class(pname, to);
  }
  if (member_array(number, mesg_numbers) > -1) {
    return 1;
  }
  if(sizeof(mesg_numbers) > MAX_FOLDER_SIZE) {
    return 2;
  }
  if (file_size(message_filename(number, "l")) > 0) {
    convert_links(number);
  }
  increment_links(number);
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+from) :));
  if (sizeof(info) && mapp(info[0])) {
    convert_class(pname, from);
  }
  tmphdr = info[member_array(number, mesg_numbers)];
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+to) :));
  mesg_numbers += ({ number });
  info += ({ tmphdr });
  if (tmphdr->status == "N") {
    new_thingy++;
  }
  unguarded((: save_object, folder_filename(lower_case(pname)+to) :));
  return 0;
}
int check_empty(string pname, string fname) {
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(lower_case(pname)+fname) :));
  if (!sizeof(mesg_numbers)) {
    unguarded((: rm, folder_filename(lower_case(pname)+fname)+".o" :));
    return 1;
  }
  return 0;
}
string check_local(string str) {
  string name;
  if (sscanf(lower_case(str),
             "%*([\n \t]*([ \t!-;=?-~]+<)?)%([A-Za-z]+)"
             "%*((.discworld(@|$))|$)",
             name) == 3) {
    return name;
  }
  return 0;
}
int *mail_count(string pname) {
  int num;
  mesg_numbers = ({ });
  info = ({ });
  new_thingy = 0;
  unguarded((: restore_object, folder_filename(pname+"inbox") :));
  if(sizeof(info) && mapp(info[0]))
    convert_class(pname, "inbox");
  num = sizeof(mesg_numbers);
  if (!mesg_numbers || !num)
    return ({ 0, 0 });
  return ({ num, new_thingy});
}
string finger_mail(string pname) {
  string ret;
  int *tmp;
  tmp = mail_count(pname);
  if(!tmp[0])
    return "No mail.\n";
  if (tmp[0] == 1) {
    ret = "1 mail message";
  } else {
    ret = tmp[0] + " mail messages";
  }
  if(tmp[1] <= 0)
    ret += ".\n";
  else
    ret += ", " + tmp[1] + " of them unread.\n";
  return ret;
}
string check_mail(string pname) {
  int *tmp;
  string ret;
  tmp = mail_count(pname);
  switch(tmp[1]) {
  case 0:
    ret = "";
    break;
  case 1:
    ret = "\nYou have %^YELLOW%^1 NEW%^RESET%^ mail message.  Go to a "
      "post office to read it.\n\n";
    break;
  default:
    ret = "\nYou have %^YELLOW%^" + tmp[1] + " NEW%^RESET%^ mail messages.  "
      "Go to a post office to read them.\n\n";
  }
  if(tmp[0] > MAX_FOLDER_SIZE) {
    ret = "\n%^BOLD%^%^RED%^You have " + tmp[0] + " messages in your inbox.  "
      "You will receive no more mail until this number is reduced below "
      "acceptable limits.%^RESET%^" + ret;
  } else if(tmp[0] > WARN_FOLDER_SIZE) {
    ret = "\n%^BOLD%^%^RED%^You have " + tmp[0] + " messages in your inbox.  "
      "This is far too many.\n  Please delete some immediately!%^RESET%^" +
      ret;
  }
  return ret;
}
private void save_counter(int counter) {
  if (check())
    return;
  unguarded((: rm, MAIL_PATH+"counter.save" :));
  unguarded((: rename, MAIL_PATH+"counter", MAIL_PATH+"counter.save" :));
  unguarded((: write_file, MAIL_PATH+"counter", ""+counter :));
}
private int load_counter() {
  string bing;
  int ret;
  if (check()) {
    return 0;
  }
  if (bing = unguarded((: read_file, MAIL_PATH+"counter" :))) {
    sscanf(bing, "%d", ret);
  } else {
    printf("The mail counter was lost. Please contact Turrican.\n");
    return 0;
  }
  return ret;
}
void set_counter(int x) {
  if(file_size(message_filename(x, "")) > 0) {
    printf("Invalid counter value: File exists.\n");
    return;
  }
  save_counter(x);
}
void dest_me() {
  destruct(this_object());
}
void delete_account(string pname) {
  string folder;
  string *folders;
  int message;
  object mailer;
  if(previous_object() != find_object( "/secure/related_files") &&
     previous_object() != find_object( "/secure/bulk_delete"))
    return;
  mailer = clone_object(MAILER);
  folders = (string *)mailer->query_folders(pname);
  destruct(mailer);
  if (!folders && file_size(folder_filename(pname+"inbox.o")) == -1)
    return;
  if (!folders)
    folders = ({"inbox"});
  foreach (folder in folders) {
    mesg_numbers = ({ });
    unguarded( (: restore_object, folder_filename(pname+folder) :) );
    if (pointerp(mesg_numbers)) {
      foreach (message in mesg_numbers) {
        reset_eval_cost();
        if (file_size(message_filename(message, "l")) > 0) {
          convert_links(message);
        }
        decrement_links(message);
      }
    }
    unguarded( (: rm, folder_filename(pname + folder + ".o") :) );
  }
  unguarded( (: rm, folder_filename(pname +".o") :) );
}

==================================================
FILE: handlers/fuel_handler.c
==================================================

#include <fuel_handler.h>
object *burners;
void create() {
   seteuid( (string)"/secure/master"->
           creator_file( file_name( this_object() ) ) );
   burners = ({ });
   call_out( "consume_fuel", FUEL_TIME );
}
void add_burner( object thing ) {
   burners += ({ thing });
}
void consume_fuel() {
   burners -= ({ 0 });
   catch( burners->consume_fuel() );
   call_out( "consume_fuel", FUEL_TIME );
}
void remove_burner( object thing ) {
   burners -= ({ thing });
}
object *query_burners() {
   return burners - ({ 0 });
}
mixed *stats() {
  return ({
    ({ "burners" , sizeof( burners ) }),
    ({ "next event", find_call_out( "consume_fuel" ) }),
   });
}

==================================================
FILE: handlers/garbage.c
==================================================

nosave string *trouble = ({});
nosave mapping cloned_by = ([]);
nosave object *_rooms;
nosave int lag, lastlag, maxlag, minlag, burstlag, users;
#define DEBUG
#define MIN_TIME 219599
#define MAX_TIME 219600
#define FAULT_RATE 4500
#define ROOM_IDLE_DELAY 7200
#define ROOM_STABLE_DELAY 10800
#define NO_AUTO_REBOOT 1
#define REBOOTS_PER_CRASH 6
#define CHANGE_SPEED 6
#define SAVE_FILE "/save/garbage"
int max_time;
int crash;
int limit;
nosave int faults_prev;
nosave int stime_prev;
nosave int utime_prev;
nosave int uptime_prev;
nosave int rate_exceeded;
nosave int times_run;
#if efun_defined(get_garbage)
int get_junk(object ob){
  return ob->query_dest_other() == 0;
}
#else
int get_junk(object ob){
  if(!clonep(ob) || refs(ob) != 2 || query_shadowing(ob) ||
     environment(ob) || ob->query_dest_other())
    return 0;
  return 1;
}
#endif
nosave int id;
void create(){
  function tmp;
  mapping map;
  unguarded(function(){
    restore_object(SAVE_FILE);
    if(!max_time) {
      max_time = MAX_TIME;
      crash = 1;
      limit = 1000;
      save_object(SAVE_FILE);
    } else {
      if(crash)
        max_time -= max_time/CHANGE_SPEED;
      else
        max_time += max_time/(CHANGE_SPEED*REBOOTS_PER_CRASH);
      if(max_time > MAX_TIME)
        max_time = MAX_TIME;
      crash = 1;
      save_object(SAVE_FILE);
    }
  });
  map = rusage();
  faults_prev = map["majflt"];
  stime_prev = map["stime"];
  utime_prev = map["utime"];
  uptime_prev = uptime();
  id = call_out("housekeeping", 300);
  tmp = function(function func) {
    int diff;
    diff = real_time() - time();
    if(diff > 2){
      diff -= 2;
      lag += diff;
      if(diff > maxlag) {
        maxlag = diff;
        if(maxlag > 600) {
          master()->crash("Too much lag to recover");
          shutdown(0);
        }
      }
    }
    if(diff < minlag) {
      minlag = diff;
    }
    if(diff > 2 && (diff - lastlag > burstlag))
      burstlag = diff - lastlag;
    lastlag = diff;
    diff = sizeof(users());
    if(diff > users) {
      users = diff;
    }
    efun::call_out(func, 1, func);
  };
  call_out(tmp, 1, tmp);
}
void check_reboot() {
  int faults_now;
  int stime_now;
  int utime_now;
  mapping map;
  int reboot;
  map = rusage();
  stime_now = map["stime"];
  utime_now = map["utime"];
  faults_now = map["majflt"];
  event(users(), "inform",
        "Cpu usage for period = "+
        ((((utime_now-utime_prev) + (stime_now-stime_prev) ) / 10.0 )/
         (uptime() - uptime_prev))+"% Fault rate is "+
       (faults_now - faults_prev), "cpu");
  event(users(), "inform", "Machine lag is "+
        (lag/900) + " seconds (average) "+minlag+" seconds (min) "+
        maxlag+" seconds (max) "+burstlag+" seconds (burst)", "cpu");
  log_file("GARBAGE", "%s lag %d (%d/%d) burst %d users %d faults %d "
           "cpu %.1f%%\n",
           ctime(time())[4..18], (lag/900), minlag, maxlag, burstlag,
           users, (faults_now - faults_prev),
           ((((utime_now-utime_prev) + (stime_now-stime_prev) ) /
             15.0 )/ (uptime() - uptime_prev)));
  if(find_object("/obj/shut") && "/obj/shut"->query_time_to_crash() != 9999)
    return;
#ifndef NO_TIMED_REBOOT
  if(uptime() > max_time)
    reboot = 1;
#endif
#ifndef NO_AUTO_REBOOT
  if((uptime() > MIN_TIME) &&
     (faults_now > (faults_prev + FAULT_RATE))) {
    if(rate_exceeded) {
      reboot = 1;
    }
  } else {
    rate_exceeded = 1;
  } else {
    rate_exceeded = 0;
  }
#endif
  if(reboot) {
    shout("A'Tuin cries out: Too heavy, I need to put the Disc down for a "+
          "moment.\n");
    "/obj/shut"->shut(10);
    log_file("GARBAGE", ctime(time())[4..18]+" Auto; Faults: "+
             faults_now+", "+ faults_prev+"; uptime: "+uptime()+"; Cpu: "+
             ((((utime_now-utime_prev) + (stime_now-stime_prev) ) / 15.0 ) /
              (uptime() - uptime_prev))+
             "\n");
    call_out(function(){
      crash = 0;
      unguarded((:save_object(SAVE_FILE):));
    }, 9*60);
    return;
  }
#if efun_defined(set_check_limit)
  if(lag > 900)
    limit += 5;
  if(lag < 300)
    limit--;
  limit = set_check_limit(limit);
#endif
  faults_prev = faults_now;
  uptime_prev = uptime();
  stime_prev = stime_now;
  utime_prev = utime_now;
  users = 0;
  lag = 0;
  maxlag = 0;
  burstlag = 0;
  minlag = 900;
}
void start_cleanup() {
  int i;
  int t = real_time();
  _rooms = filter(objects((: function_exists("query_last_visited", $1) :)),
                  (: $1->query_keep_room_loaded() == 0 &&
                   $1->query_last_visited() < (time() - ROOM_IDLE_DELAY) &&
                   $1->query_last_visited() > (time() - ROOM_STABLE_DELAY):));
  for(i=(times_run % 2); i<sizeof(_rooms); i += 2)
    catch(_rooms[i]->clean_up());
  log_file("GARBAGE", "%s cleaning %d rooms. Current memory %.2fM\n",
           ctime(time())[4..18], i/2, (memory_info() / 1024000.0));
  event(users(), "inform",
        sprintf("Cleaning %d idle rooms", i/2), "cpu");
  if(real_time() - t > 1)
    log_file("GARBAGE", "%s room cleanup took %d seconds.\n",
             ctime(time())[4..18], real_time() - t);
}
void tidy_up() {
  int rmem, ocount;
  rmem = memory_info();
  ocount = reclaim_objects();
  rmem -= memory_info();
  event(users(), "inform",
        sprintf("Reclaimed %d object%s (%d byte%s)",
                ocount, (ocount == 1 ? "" : "s"),
                rmem, (rmem == 1 ? "" : "s") ), "cpu");
}
void housekeeping() {
  string *tmpkeys;
  int i;
  object *junk;
  int t = real_time();
  i = set_eval_limit(0);
  set_eval_limit(5000000);
#if efun_defined(get_garbage)
  junk = filter(get_garbage(), (:get_junk:));
#else
  junk = objects((:get_junk:));
#endif
  set_eval_limit(i);
  times_run++;
  call_out("check_reboot", 10);
  if(!(times_run % 3))
    call_out("tidy_up", 30);
  if(times_run > 4 && (times_run % 2 == 1))
    call_out("start_cleanup", 60);
  foreach(object ob in junk)
    trouble |= ({base_name(ob)});
  id = call_out((:housekeeping:), 15 * 60);
  foreach(object ob in junk) {
#ifdef DEBUG
    if(cloned_by[file_name(ob)])
      log_file("GARBAGE_DEBUG", "%O cloned by %O\n", ob,
               cloned_by[file_name(ob)]);
#endif
    reset_eval_cost();
    ob->dest_me();
  }
  tmpkeys = keys(cloned_by);
  if(sizeof(tmpkeys)>10000){
    cloned_by = ([]);
  }
#if !efun_defined(add_action)
  "/obj/handlers/livings"->remove_garbage();
#endif
  if(real_time() - t > 1)
    log_file("GARBAGE", "%s garbage cleanup took %d seconds.\n",
             ctime(time())[4..18], real_time() - t);
}
nosave private object armoury, cloner;
void cloned(object ob){
  object obcloner;
  if(!armoury)
    armoury = find_object("/obj/handlers/armoury");
  if(!cloner)
    cloner = find_object("/global/cloner");
  if(previous_object(1) != armoury && previous_object() != cloner){
    obcloner = previous_object(1);
  } else catch {
    int i = 2;
    obcloner = armoury;
    while(obcloner == armoury || obcloner == cloner)
      obcloner = previous_object(i++);
  };
  if(member_array(base_name(ob), trouble) != -1){
    string tmp = "";
#if 0
    int i, j;
    for(i = 2; i < sizeof(call_stack()); i++){
      if(!call_stack(1)[i])
        break;
      for(j = 0; j < 4; j++)
        tmp = sprintf("%s %O", tmp, call_stack(j)[i]);
      tmp += "\n";
    }
#endif
    cloned_by[file_name(ob)] = sprintf("%O\n%s", obcloner, tmp);
  }
  if((find_call_out(id) < 0) && ((uptime() - uptime_prev) > (30 * 60)))
    id = call_out((:housekeeping:), 0);
}
int query_next_reboot() {
#ifndef NO_TIMED_REBOOT
  return max_time - uptime();
#else
  return -1;
#endif
}
int query_faults_prev() {
   return faults_prev;
}
void set_max_time(int i) { max_time = i; save_object(SAVE_FILE); }
void dest_me(){
  crash = 0;
  unguarded((:save_object(SAVE_FILE):));
  destruct(this_object());
}

==================================================
FILE: handlers/gathering.c
==================================================

#include <weather.h>
#include <tasks.h>
#define INIT_FILE "/obj/gatherables/handler.dat"
class item_data {
    string skill;
    int    difficulty;
    string *season;
    mixed  quant;
    string ob;
}
mapping items = ([ ]);
void create() {
    seteuid("/secure/master"->creator_file(file_name(this_object())));
    items = "/obj/handlers/data"->compile_data(({ INIT_FILE }));
}
mixed query_item( string name ) {
    class item_data h;
    if (!(items[name])) {
        return 0;
    }
    h = (class item_data)items[name];
    return ({ h->skill, h->difficulty, h->season, h->quant, h->ob });
}
void add_item( string name, string skill, int diff,
               string *season, mixed quant, string ob ) {
    class item_data h;
    h = new( class item_data );
    h->skill = skill;
    h->difficulty = diff;
    h->season = season;
    h->quant = quant;
    h->ob = ob;
    items[name] = h;
}
mapping query_items() {
    return items;
}
object *gather_item( string word, object player ) {
object *basket = ({ });
object *matched = ({ });
object item;
mixed  *current_item;
class item_data info;
string temp_name;
int temp_scarcity;
int result;
int quantity;
   if ( !objectp( player ) || !environment( player ) )
      return ({ });
   matched = match_objects_for_existence( word, ({ environment( player ) }) );
   if ( !sizeof( matched ) )
      return ({ });
   foreach( object temp in matched ) {
      if ( environment( temp ) == environment( player ) )
         basket += ({ temp });
      current_item = temp->query_gather();
      temp_name = "";
      temp_scarcity = 0;
      if ( !sizeof( current_item ) )
         continue;
      if ( sizeof( current_item ) != 1 ) {
         error( "When Terano recoded this, he assumed that this array would "
            "only contain one array inside it. This turned out to be "
            "wrong.\n" );
      }
      for ( int x = 0; x < sizeof( current_item[0] ); x = x + 2 ) {
         switch ( current_item[ 0 ][ x ] ) {
           case "item name":
           case "item_name":
                  temp_name = evaluate( current_item[ 0 ][ x+1 ],
               environment( player ), player );
              if ( !stringp( temp_name ) )
                    temp_name = 0;
                  break;
           case "scarcity":
                    temp_scarcity = evaluate(current_item[0][ x+1 ],
                  environment( player ), player, temp_name);
                    if ( !intp( temp_scarcity ) )
                        temp_scarcity = 0;
                    break;
         }
      }
      tell_creator( player, "Started to check for %s.\n", temp_name );
       if ( random( 100 ) >= temp_scarcity) {
         tell_creator( player, "Not found %s due to scarcity (%d).\n",
            temp_name, temp_scarcity );
         continue;
      }
      if (!items[temp_name]) {
         tell_creator( player, "Not found %s due to no info!\n",
            temp_name );
         continue;
        }
      info = items[ temp_name ];
      if ( sizeof( info->season ) ) {
          if (member_array( WEATHER->query_season(), info->season ) == -1) {
         tell_creator( player, "Not found %s: Out of season!\n",
            temp_name );
         continue;
        }
      }
      if ( stringp( info->skill ) && strlen( info->skill ) ) {
         result = TASKER->perform_task( player, info->skill ,info->difficulty, TM_FREE );
      switch( result ) {
         case FAIL:
         case BARF:
            tell_creator( player, "Not found %s: Skillcheck failed!\n",
               temp_name );
            continue;
         case AWARD:
            tell_object(player,
                  "%^YELLOW%^You have learned something new about gathering!%^RESET%^\n" );
         case SUCCEED:
         }
      }
      quantity = evaluate( info->quant, environment( player ), player,
         temp_name );
      if ( !quantity || !intp( quantity ) )
         continue;
      item = clone_object( info->ob );
        if (item->query_continuous()) {
         item->set_amount( quantity );
            basket += ({ item });
        }
        else {
         item->dest_me();
         basket += allocate( quantity, (: clone_object( $(info->ob) ) :) );
      }
      continue;
   }
   return basket;
}

==================================================
FILE: handlers/gossip_handler.c
==================================================

#include <gossip.h>
mixed *gossip;
mixed *rumours;
nosave mixed *filter_these;
private void save_stuff();
void create() {
   seteuid(getuid());
   filter_these = ({ "fuck", "fucking", "fucker", "cunt", "bitch", "shit" });
   gossip = ({ });
   rumours = ({ });
   unguarded( (: restore_object(GOSSIP_SAVE_FILE) :) );
   call_out((: save_stuff :), 10*60);
}
private void save_stuff() {
   call_out((: save_stuff :), 10*60);
   if (sizeof(gossip) > GOSSIP_KEEP_LEVEL) {
      gossip = gossip[sizeof(gossip)-GOSSIP_KEEP_LEVEL..];
   }
   if (sizeof(rumours) > RUMOUR_KEEP_LEVEL) {
      rumours = rumours[sizeof(rumours)-RUMOUR_KEEP_LEVEL..];
   }
   unguarded( (: save_object(GOSSIP_SAVE_FILE) :) );
}
void add_gossip(string name, string mess) {
   string *bits;
   int i;
   bits = explode(mess, " ");
   for (i = 0; i < sizeof(bits); i++) {
      if (member_array(bits[i], filter_these) != -1) {
         return ;
      }
   }
   gossip += ({ ({ name, mess }) });
}
varargs string remove_gossip(string match, int force)
{
  int pos, index;
  if (!match || match == "") return "Must provide a match string";;
  pos = -1;
  for (index = sizeof(gossip); index; index--) {
    if (strsrch(gossip[index - 1][1], match) != -1) {
      if (pos == -1)
        pos = index - 1;
      else if (!force) {
        return "too many matches";
      }
    }
  }
  if (pos != -1) {
    string found = "found " + gossip[pos][1] + " by " + gossip[pos][0];
    gossip = delete(gossip, pos, 1);
    return found;
  } else
    return "No match";
}
void add_rumour(string name, string mess) {
   rumours += ({ ({ name, mess }) });
   save_stuff();
}
string *query_random_gossip() {
   if (sizeof(rumours) && random(2)) {
      return rumours[random(sizeof(rumours))];
   } else {
      if (sizeof(gossip))
	 return gossip[random(sizeof(gossip))];
      else
	 return 0;
   }
}
mixed *query_gossip() {
   return gossip;
}
string *query_filter() {
   return filter_these;
}
mixed *query_rumours() {
   return rumours;
}
