# Total Tokens: 17347
# Total Files Merged: 8
# Total Characters: 57850

em_tracker.c
==================================================

#include <library.h>
#include <quest_handler.h>
inherit "/std/object";
#define QUEST_INFO_IDENT  "items"
#define MAX_COPIES    10
mapping item_cache;
mapping player_items;
void create()
{
   ::create();
   item_cache = ([ ]);
}
mixed query_item_state( mixed pl_name, mixed item )
{
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }
  if (objectp(item)) {
    if (item->query_tracked_item_owner() != pl_name) return 0;
    item = item->query_full_tracked_item_identifier();
  }
  if (!item) return 0;
  player_items = item_cache[ pl_name ];
  if (!player_items) {
    player_items = copy(LIBRARY->query_player_quest_info( pl_name, QUEST_INFO_IDENT ));
    if (!player_items) player_items = ([ ]);
    item_cache[ pl_name ] = player_items;
  }
  return player_items[ item ];
}
int delete_item( mixed pl_name, mixed item )
{
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }
  if (objectp(item)) {
    if (item->query_tracked_item_owner() != pl_name) return 0;
    item = item->query_full_tracked_item_identifier();
  }
  if (!item) return 0;
  player_items = item_cache[ pl_name ];
  if (!player_items) {
    player_items = copy(LIBRARY->query_player_quest_info( pl_name, QUEST_INFO_IDENT ));
    if (!player_items) player_items = ([ ]);
    item_cache[ pl_name ] = player_items;
  }
  map_delete( player_items, item );
  return 1;
}
int query_item_copies( mixed pl_name, mixed item )
{
  int copy_number,n_copies;
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }
  if (objectp(item)) {
    item = item->query_tracked_item_identifier();
  }
  if (!item) return 0;
  player_items = item_cache[ pl_name ];
  if (!player_items) {
    player_items = copy(LIBRARY->query_player_quest_info( pl_name, QUEST_INFO_IDENT ));
    if (!player_items) player_items = ([ ]);
    item_cache[ pl_name ] = player_items;
  }
  n_copies = 0;
  for (copy_number = 1; copy_number < MAX_COPIES; copy_number++) {
    if (player_items[ item+"/"+copy_number ]) n_copies++;
  }
  return n_copies;
}
int set_item_state( mixed pl_name, mixed item, mixed state )
{
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }
  if (objectp(item)) {
    if (item->query_tracked_item_owner() != pl_name) return 0;
    item = item->query_full_tracked_item_identifier();
  }
  if (!item) return 0;
  player_items = item_cache[ pl_name ];
  if (!player_items) {
    player_items = copy(LIBRARY->query_player_quest_info( pl_name, QUEST_INFO_IDENT ));
    if (!player_items) player_items = ([ ]);
    item_cache[ pl_name ] = player_items;
  }
  player_items[ item ] = state;
  return 1;
}
mixed query_all_item_states( mixed pl_name )
{
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }
  player_items = item_cache[ pl_name ];
  if (!player_items) {
    player_items = copy(LIBRARY->query_player_quest_info( pl_name, QUEST_INFO_IDENT ));
    if (!player_items) player_items = ([ ]);
    item_cache[ pl_name ] = player_items;
  }
  return player_items;
}
int save_all_item_states( mixed pl_name )
{
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }
  player_items = item_cache[ pl_name ];
  if (!player_items) {
    return 0;
  }
  LIBRARY->set_player_quest_info( pl_name, QUEST_INFO_IDENT, player_items );
  return 1;
}
int save_all_item_states_delete_cache( mixed pl_name )
{
  if (objectp(pl_name)) {
    if (!interactive(pl_name)) return 0;
    pl_name = pl_name->query_name();
  }
  player_items = item_cache[ pl_name ];
  if (!player_items) {
    return 0;
  }
  LIBRARY->set_player_quest_info( pl_name, QUEST_INFO_IDENT, player_items );
  map_delete( item_cache, pl_name );
  return 1;
}

==================================================
FILE: handlers/key_handler.c
==================================================

#define RESTORE_PATH "/save/keys/"
inherit "/std/object";
mapping keys;
mapping key_names;
nosave string _current_group;
private void init_data( string group ) {
   keys = ([ ]);
   key_names = ([ ]);
}
private int get_data_file( string group ) {
   if (_current_group == group) {
      return 1;
   }
   _current_group = group;
   if ( file_size( RESTORE_PATH + group +".o" ) > 0 ) {
      unguarded((: restore_object, RESTORE_PATH + group :));
   } else {
      init_data( group );
      return 0;
   }
   return 1;
}
private void save_data_file( ) {
   unguarded((: save_object, RESTORE_PATH + _current_group :));
}
mapping query_all_keys( string group ) {
   get_data_file( group );
   return keys;
}
private void set_keys( string group, mapping list ) {
   get_data_file( group );
   keys = list;
   save_data_file( );
}
string *query_all_key_permissions( string group, string key ) {
   get_data_file( group );
   if ( !keys[ key ] ) {
      return ({ });
   }
   return keys[ key ];
}
void set_key_permissions( string group, string key, string *types ) {
   get_data_file( group );
   if (sizeof(types)) {
      keys[ key ] = types;
   } else {
      map_delete(keys, key);
   }
   save_data_file( );
}
int query_key_permission( string group, string key, string type ) {
   get_data_file( group );
   if ( !keys[ key ] ) {
      return 0;
   }
   if ( member_array( type, keys[ key ] ) == -1 ) {
      return 0;
   }
   return 1;
}
int add_key_permission( string group, string key, string type ) {
   get_data_file( group );
   if ( !keys[ key ] ) {
       keys[ key ] = ({ });
   }
   if ( member_array( type, keys[ key ] ) != -1 ) {
      return 0;
   }
   keys[ key ] += ({ type });
   save_data_file( );
   return 1;
}
int remove_key_permission( string group, string key, string type ) {
   int i;
   get_data_file( group );
   if ( !keys[ key ] ) {
      return 0;
   }
   if ( ( i = member_array( type, keys[ key ] ) ) == -1 ) {
      return 0;
   }
   keys[ key ] = delete( keys[ key ], i, 1 );
   if (!sizeof(keys[key])) {
      map_delete(keys, key);
   }
   save_data_file( );
   return 1;
}
mapping query_all_key_names( string group ) {
   get_data_file( group );
   return key_names;
}
private void set_key_names( string group, mapping list ) {
   get_data_file( group );
   key_names = list;
   save_data_file( );
}
string query_key_name( string group, string key ) {
   get_data_file( group );
   return key_names[ key ];
}
void set_key_name( string group, string key, string name ) {
   get_data_file( group );
   key_names[ key ] = name;
   save_data_file( );
}
void delete_key_name( string group, string key ) {
   get_data_file( group );
   if ( !key_names[ key ] ) {
      return;
   }
   map_delete( key_names, key );
   save_data_file( );
}

==================================================
FILE: handlers/languages.c
==================================================

#include <language.h>
#define L_NEW 512
#define REPLACEMENTS (["no1":"noone",\
                       "ne1":"anyone",\
                       "any1":"anyone",\
                       "u":"you",\
                       "r":"are", \
                       "NE1":"anyone",\
                       "U":"you",\
                       "R":"are", \
                       "ur":"you are",\
                       "teh":"the", \
                       "some1":"someone", \
                       "c":"see", \
                       "cing":"seeing",\
                       "sum1":"someone",\
                       "urs":"yours",\
                       "thier":"their", \
                       "pls":"please",\
                       "PLZ":"please",\
                       "plz":"please",\
                       "b4":"before", \
                       "tnx":"thanks"])
mapping languages;
string search;
void create() {
  languages = ([
  "rabbit" : ({ L_SPOKEN|L_WRITTEN|L_DISTANCE|L_ALWAYS_SPEAK|L_NEW,
                "/std/languages/rabbit", 10 }),
  "general" : ({ L_SPOKEN|L_WRITTEN|L_DISTANCE|L_ALWAYS_SPEAK,
                "/std/languages/general", 10 }),
  "grunt" : ({ L_SPOKEN | L_ALWAYS_SPEAK, "/std/languages/grunt", 100 }),
  "wommon" : ({ L_WRITTEN|L_SPOKEN|L_DISTANCE|L_MAGIC,
                "/std/languages/wommon", 10 }),
              ]);
  search = "(" + implode(keys(REPLACEMENTS), "|") + ")";
}
int query_language_spoken(string str) {
  if (!languages[str])
    return 0;
  return languages[str][0]&L_SPOKEN;
}
int query_language_written(string str) {
  if (!languages[str])
    return 0;
  return languages[str][0]&L_WRITTEN;
}
int query_language_distance(string str) {
  if (!languages[str])
    return 0;
  return languages[str][0]&L_DISTANCE;
}
int query_language_new(string str) {
  if (!languages[str])
     return 0;
  return languages[str][0]&L_NEW;
}
int query_language_magic(string str) {
  if (!languages[str])
    return 0;
  return languages[str][0]&L_MAGIC;
}
int query_language_size(string str) {
  if (!languages[str])
    return 0;
  return languages[str][2];
}
int query_language_always_spoken(string str) {
  if (!languages[str])
    return 0;
  return languages[str][0]&L_ALWAYS_SPEAK;
}
mixed squidge_text(string lang, mixed str, int size) {
  if (!languages[lang])
    return 0;
  if (!(languages[lang][0]&L_MAGIC))
    return str[0..(size/languages[lang][2])];
  return (mixed)languages[lang][1]->squidge_text(str, size);
}
int query_flags(string name) {
  if (!languages[name])
    return 0;
  return languages[name][0];
}
string query_garble_object(string name) {
  if (!languages[name])
    return 0;
  return languages[name][1];
}
string *query_languages() {
  return m_indices(languages);
}
int test_language(string str) {
  return pointerp(languages[str]);
}
string query_language_spoken_skill(string lang) {
  return LANGUAGE_SKILL_START + replace(lang, " ", "_") + "." + SPOKEN_SKILL;
}
string query_language_written_skill(string lang) {
  return LANGUAGE_SKILL_START + replace(lang, " ", "_") + "." + WRITTEN_SKILL;
}
mixed garble_say(string lang, string start, string mess,
                 object player, object from, string type) {
   string garble_ob;
   if (query_language_new(lang)) {
      garble_ob = query_garble_object(lang);
      if (living (from) && garble_ob) {
         return garble_ob->garble_say(start, mess, player, from, type,
                                      query_language_spoken_skill(lang),
                                      type == SHOUT_TYPE);
      }
   } else {
      if (player->query_skill(query_language_spoken_skill(lang)) < 99) {
         garble_ob = query_garble_object(lang);
         if(garble_ob)
           return garble_ob->garble_say(start, mess, player, type);
         else
           debug_printf("Error, %s has no garble object.", lang);
      }
   }
   return ({ start, mess });
}
string garble_text(string lang, mixed text, object thing, object player ) {
   string garble_ob;
   if (functionp(text)) {
      text = evaluate(text);
   }
   if (query_language_new(lang)) {
      garble_ob = query_garble_object(lang);
      if (garble_ob) {
         return garble_ob->garble_text(text, thing, player,
                                       query_language_written_skill(lang));
      }
   } else {
      if (player->query_skill(query_language_written_skill(lang)) < 99) {
         garble_ob = query_garble_object(lang);
         if( !garble_ob )
            return "You do not recognise the language.\n";
         else
            return garble_ob->garble_text(text, thing, player);
      }
      if (query_language_magic(lang)) {
         garble_ob = query_garble_object(lang);
         return garble_ob->magical_text(text, thing, player);
      }
      return text;
   }
   if (query_language_magic(lang))
      return 0;
   return "Text written in " + lang + " could not have been written.  "
          "There are "
          "broken bits of letters scattered over the page, looks like "
          "someone had a bad game of scrabble.\n";
}
string do_replacements(string mess) {
  string *bits, name, value;
  mixed *tmp;
  int index, i, add_space;
  mess = replace(mess, ({"ne1 no ", "anyone know "}));
  if(!regexp(mess, search))
    return mess;
  if(mess[<1] == ' ')
    add_space = 1;
  bits = explode(mess, " ");
  foreach(name, value in REPLACEMENTS) {
    tmp = regexp(bits, "(^|[^A-Za-z0-9\\\\./_&-]+)"+name+"($|[^A-Za-z0-9\\./&_-]+)", 1);
    if(sizeof(tmp)) {
      for(i=0; i<sizeof(tmp); i+=2) {
        index = tmp[i+1]-1;
        bits[index] = replace(bits[index], name, value);
      }
    }
  }
  return implode(bits, " ") + (add_space ? " " : "");
}
string fix_shorthand(string mess) {
  string pre, mid, post, res;
  if (!stringp(mess)) {
     return "";
  }
  res = "";
  while(sscanf(mess, "%s'%s'%s", pre, mid, post) == 3) {
    res += do_replacements(pre) + "'" + mid;
    mess = "'" + post;
  }
  res += do_replacements(mess);
  return res;
}

==================================================
FILE: handlers/library.c
==================================================

#include <quest_handler.h>
#include <player_handler.h>
#define XP 10000
#define XP_QUESTS ({"womble's brooch", "balance quest", "easy post quest", \
                    "hard post quest", "apprentice baker" })
#define RESTORE_PATH  "save/library/"
#define MAX_CACHE_SIZE 100
#define CACHE_TIMEOUT 900
inherit "/std/object";
int *times;
string player_name, *quests, text_file;
mapping player_quest_info;
nosave mapping qps;
nosave int requests, cache_hits;
class qinfo {
  int cached;
  string player_name;
  string *quests;
  int *times;
  string text_file;
  mapping player_quest_info;
}
nosave mapping player_cache = ([ ]);
int new_top_quest();
int query_quest_time(string, string);
private void init_data(string pl_name) {
  player_name = pl_name;
  quests = ({ });
  times = ({ });
  text_file = "";
  player_quest_info = ([ ]);
}
void clean_cache() {
  string name;
  foreach(name in keys(player_cache))
    if(player_cache[name]->cached < time() - CACHE_TIMEOUT)
      map_delete(player_cache, name);
}
private int get_data_file(string name) {
  int success;
  class qinfo tmp;
  requests++;
  if(player_cache[name]) {
    player_cache[name]->cached = time();
    cache_hits++;
    return 1;
  }
  success = unguarded((: restore_object, RESTORE_PATH+name[0..0]+"/"+name :));
  if(!success)
    init_data(name);
  tmp = new(class qinfo,
            cached : time(),
            player_name : player_name,
            quests : quests,
            times : times,
            text_file : text_file,
            player_quest_info : player_quest_info);
  player_cache[name] = tmp;
  if((sizeof(player_cache) > MAX_CACHE_SIZE) &&
     (find_call_out("clean_cache") == -1))
    call_out("clean_cache", 60);
  return success;
}
private void save_data_file(string name) {
  if(!player_cache[name])
    return;
  player_name = player_cache[name]->player_name;
  quests = player_cache[name]->quests;
  times = player_cache[name]->times;
  text_file = player_cache[name]->text_file;
  player_quest_info = player_cache[name]->player_quest_info;
  unguarded((: save_object, RESTORE_PATH+name[0..0]+"/"+name :));
  return ;
}
string query_title( string name ) {
  string quest;
  get_data_file( name );
  if(!player_cache[name]->quests || !sizeof(player_cache[name]->quests)) {
    return 0;
  }
  quest = player_cache[name]->
    quests[random(sizeof(player_cache[name]->quests))];
  return (string)QUEST_HANDLER->query_quest_title(quest);
}
string *query_quests(string name) {
  get_data_file(name);
  if(!player_cache[name]->quests ) {
    return ({ });
  }
  return player_cache[name]->quests + ({ });
}
string get_most_recent_quest(string name) {
  int loop, highest;
  string quest_name;
  string *quests;
  int *times;
  if(!get_data_file(name))
    return "Sorry";
  quests = player_cache[name]->quests;
  times = player_cache[name]->times;
  if(sizeof(quests) == 0)
    return "None";
  for(highest = loop = 0; loop < sizeof(quests); loop++) {
    if(times[loop] > highest) {
      highest = times[loop];
      quest_name = quests[loop];
    }
  }
  return quest_name;
}
int get_most_recent_time(string name) {
  int loop, hightime;
  string *quests;
  int *times;
  if(!get_data_file(name)) {
    return -1;
  }
  quests = player_cache[name]->quests;
  times = player_cache[name]->times;
  if(sizeof(quests) == 0) {
    return 0;
  }
  for(hightime = loop = 0; loop < sizeof(quests); loop++) {
    if(times[loop] > hightime) {
      hightime = times[loop];
    }
  }
  return hightime;
}
int set_quest(string pl_name, string qu_name, int no_xp) {
  int qu_level;
  object ob;
  object card;
  int i;
  if(!find_player(pl_name) || find_player(pl_name)->query_property("guest"))
    return 0;
  i = QUEST_HANDLER->query_quest_status(qu_name);
  ob = find_player (pl_name);
  if (i == 0 && ob->query_playtester()) {
    tell_object (ob, "%^BOLD%^If this quest weren't inactive, you'd be "
      "showered in riches right about now!\n%^RESET%^");
  }
  if(i < 1) {
   user_event( "inform", pl_name +" completes "+ qu_name + " (inactive)", "quest");
    return 0;
  }
  if (ob && ob->advancement_restriction()) {
    log_file ("/log/secure/playtesters/protection_log", "%s: %s "
      "completed quest %s while advancement restricted active.\n", ctime(time()),
      pl_name, qu_name);
    return 0;
  }
  if(qps && qps[pl_name])
    map_delete(qps, pl_name);
  get_data_file(pl_name);
  if ( member_array( qu_name, player_cache[pl_name]->quests ) != -1 )
    return 0;
  player_cache[pl_name]->quests += ({ qu_name });
  player_cache[pl_name]->times += ({ time() });
  qu_level = (int)QUEST_HANDLER->query_quest_level(qu_name);
  if ( qu_level < 1 )
    return 0;
  QUEST_HANDLER->quest_completed( pl_name, qu_name, previous_object() );
  save_data_file( pl_name );
  if ( !ob ) {
    return 0;
  }
  if(member_array(qu_name, XP_QUESTS) != -1) {
    ob->adjust_xp(XP*qu_level, 0);
    call_out("save_them", 1, ob);
  }
  ob->set_title( "quest",
                 (string)QUEST_HANDLER->query_quest_title( qu_name ) );
  card = clone_object ("/d/underworld/creator_cards/creator_card");
  card->move (ob, "$N appear$s in your inventory with a flash.");
  return 1;
}
int unset_quest(string pl_name, string qu_name) {
  int qu_level;
  get_data_file(pl_name);
  if ( member_array( qu_name, player_cache[pl_name]->quests ) == -1 )
    return 0;
  qu_level = (int)QUEST_HANDLER->query_quest_level(qu_name);
  if ( qu_level < 1 )
    return 0;
  player_cache[pl_name]->quests -= ({ qu_name });
  player_cache[pl_name]->times -= ({ time() });
  save_data_file( pl_name );
  return 1;
}
void save_them( object thing ) {
  if ( thing )
    thing->save_me();
}
void set_player_quest_info( string pl_name, string qu_info, mixed *details ) {
  get_data_file( pl_name );
  if(!player_cache[pl_name]->player_quest_info )
    player_cache[pl_name]->player_quest_info = ([ ]);
  player_cache[pl_name]->player_quest_info[qu_info] = details;
  save_data_file(pl_name);
}
mapping query_all_player_quest_info( string pl_name ) {
  if(!get_data_file( pl_name ))
    return 0;
  if ( !player_cache[pl_name]->player_quest_info )
    return 0;
  return copy(player_cache[pl_name]->player_quest_info);
}
mixed *query_player_quest_info( string pl_name, string qu_info ) {
  if(!get_data_file( pl_name))
    return 0;
  if(!player_cache[pl_name]->player_quest_info)
    return 0;
  player_cache[pl_name]->player_quest_info =
    player_cache[pl_name]->player_quest_info + ([ ]);
  return player_cache[pl_name]->player_quest_info[qu_info];
}
int query_quest_time(string name, string qu_name) {
  int time;
  if(!get_data_file(name)) {
    return 0;
  }
  time = member_array(qu_name, player_cache[name]->quests);
  if(time < 0) {
    return 0;
  }
  return player_cache[name]->times[time];
}
string query_story(string name) {
  string story, *quests;
  int loop;
  if(!get_data_file(name)) {
    return "You can find nothing in the library on " + name + "\n";
  }
  story = "";
  if(player_cache[name]->text_file != "") {
    return unguarded((: read_file, text_file :));
  }
  quests = player_cache[name]->quests;
  if(!sizeof(quests)) {
    return "That person has lead a most unadventureous life";
  }
  for(loop = 0; loop < sizeof(quests); loop++) {
    story += capitalize(QUEST_HANDLER->query_quest_story(quests[loop])) +".\n";
  }
  return story;
}
int query_quest_done(string player, string quest) {
  if(!get_data_file(player))
    return 0;
  return (member_array(quest, player_cache[player]->quests) != -1);
}
int flush_cache (string name) {
  qps[name] = 0;
}
int query_quest_points( string name ) {
   int points;
   string word;
   string *quests;
   if(!qps)
     qps = ([ ]);
   if(qps[name])
     return qps[name]-1;
   get_data_file( name );
   quests = player_cache[name]->quests;
   if ( !quests || !sizeof( quests ) )
      points = 0;
   else {
     foreach( word in quests ) {
       points += (int)QUEST_HANDLER->query_quest_level( word );
     }
   }
   qps[name] = points+1;
   return points;
}
int restart(mixed name) {
  class qinfo tmp;
  if(objectp(name))
    name = name->query_name();
  if(!PLAYER_HANDLER->test_user(name))
    return 0;
  init_data(name);
  tmp = new(class qinfo,
            cached : time(),
            player_name : player_name,
            quests : quests,
            times : times,
            text_file : text_file,
            player_quest_info : player_quest_info);
  player_cache[name] = tmp;
  save_data_file(name);
  return 1;
}
mixed *stats() {
  int percentage;
  if(requests)
    percentage = (cache_hits * 100) / requests;
  return ({
    ({ "cache size", sizeof(player_cache) }),
      ({ "requests", requests }),
      ({ "cache hits", cache_hits }),
      ({ "cache misses", requests - cache_hits }),
      ({ "percentage hits", percentage }),
      });
}

==================================================
FILE: handlers/livings.c
==================================================

private nosave mapping _lnames = ([]);
private nosave mapping _players = ([]);
#ifdef 0
void create() {
  object player, *players;
  players = filter(efun::users(), (: $1 && inherits("/std/container", $1) :));
  foreach(player in players) {
    _players[player->query_name()] = player;
  }
}
#endif
private void check_lnames(string* names) {
   string key;
   foreach (key in names) {
      mixed bing = _lnames[key];
      if (arrayp(bing)) {
         bing -= ({ 0 });
         if (sizeof(bing)) {
            _lnames[key] = bing;
         }
         else {
            map_delete(_lnames, key);
         }
      }
      else {
         map_delete(_lnames, key);
      }
   }
}
private void check_players(string* names) {
   string key;
   foreach (key in names) {
      mixed bing = _players[key];
      if (arrayp(bing)) {
         bing -= ({ 0 });
         if (sizeof(bing)) {
            _players[key] = bing;
         }
         else {
            map_delete(_players, key);
         }
      }
      else {
         map_delete(_players, key);
      }
   }
}
void remove_garbage(){
  string* names;
  int i;
  names = keys(_lnames);
  for (i = 0; i < sizeof(names); i += 50) {
     call_out((: check_lnames :), i / 25, names[i..i+50]);
  }
  names = keys(_players);
  for (i = 0; i < sizeof(names); i += 50) {
     call_out((: check_players :), i / 25, names[i..i+50]);
  }
}
void enable_commands(object ob){
}
void set_living_name(string name, object ob){
  if (!stringp(name) || !objectp(ob)) {
    return ;
  }
  if(!_lnames[name]) {
    _lnames[name] = ({ob});
  } else {
    _lnames[name] += ({ob});
  }
  if ( ob == master() ) {
     log_file( "LIVINGS", "%O (%s) became a living. %O\n", ob,
         name, call_stack(0) );
  }
}
object *named_livings(){
  object *ret;
  ret = keys(_lnames);
  ret = map(ret, (:$1?(_lnames)[$1]:0:));
  reset_eval_cost();
  ret = filter(ret, (:$1:));
  reset_eval_cost();
  ret = implode(ret, (:$1 + $2:));
  reset_eval_cost();
  ret = filter(ret, (:$1:));
  return ret;
}
object find_living(string it) {
  if(_lnames[it]) {
    _lnames[it] = filter(_lnames[it], (: $1 :));
    if(sizeof(_lnames[it]))
      return _lnames[it][<1];
  }
  return 0;
}
object find_player(string it) {
  object *people;
  int t = real_time();
  object *tmp;
  if(_players[it]) {
      return _players[it];
    return 0;
  }
  people = filter(efun::users(), (: $1 && $1->query_name() == $(it) &&
                                  inherits("/std/container", $1):));
  if(sizeof(people)) {
    _players[it] = people[0];
    if(real_time() - t > 1)
      log_file("GARBAGE", "find_player took %d seconds to find %s (1)\n",
               real_time() - t, it);
      return _players[it];
  }
  if(!_lnames[it]) {
    if(real_time() - t > 1)
      log_file("GARBAGE", "find_player took %d seconds to find %s (2)\n",
               real_time() - t, it);
    return 0;
  }
  tmp = filter(_lnames[it], (: $1 && userp($1) :));
  if(real_time() - t > 1)
    log_file("GARBAGE", "find_player took %d seconds to find %s (3)\n",
             real_time() - t, it);
  if(sizeof(tmp))
    return tmp[0];
  return 0;
}
mapping query_dynamic_auto_load() {
   mapping tmp;
   tmp = ([ "lnames" : _lnames,
            "players" : _players,
          ]);
   return tmp;
}
void init_dynamic_arg(mapping maps) {
   object ob;
   string name;
   if (maps["lnames"])
      _lnames = maps["lnames"];
   if (maps["players"])
      _players = maps["players"];
   foreach(ob in efun::users()){
      if ( !ob ) {
        continue;
      }
      name = ob->query_name();
      _players[name] = ob;
      if(!_lnames[name]){
        _lnames[name] = ({ob});
      } else {
        _lnames[name] |= ({ob});
      }
   }
}
mixed *stats() {
  return ({ ({ "lnames", sizeof(keys(_lnames)) }),
              ({ "players", sizeof(keys(_players)) })});
}

==================================================
FILE: handlers/login_handler.c
==================================================

#include <login.h>
#ifdef LOGIN_DEBUG
#undef MAX_COMPRESSED_PLAYERS
#undef MAX_UNCOMPRESSED_PLAYERS
#undef MAX_PLAYERS
#define LOGIN_MAX_COMPRESSED_PLAYERS 2
#define MAX_UNCOMPRESSED_PLAYERS 1
#define MAX_PLAYERS (MAX_COMPRESSED_PLAYERS + MAX_UNCOMPRESSED_PLAYERS)
#endif
#ifdef LOGIN_DEBUG
#define is_compressed_login(x) (strsrch((x)->query_name(), "test") > -1)
#else
#define is_compressed_login(x) (compressedp(x))
#endif
#define COMPRESSED_INTAKE_COUNT 5
#ifdef USE_RAMDISK
#define SAVE_TIME 300
#else
#define SAVE_TIME 900
#endif
#define NEW_SAVE_TIME 15
#define SAVE_NAME "/save/login_handler"
#define BUFFER_TIME 30
#define LOCKDOWN_TIME 900
#define MAX_FAILURES 3
class login_information {
    mixed ob;
    string funct;
}
mapping _static_login_calls;
nosave mapping _dynamic_login_calls;
nosave string _best;
nosave string _worst;
nosave string *_players_on;
nosave mapping _compressed_players_on;
nosave mapping _telnet_players_on;
nosave object *_compressed_login_queue;
nosave object *_telnet_login_queue;
nosave int _compressed_login_count;
nosave string enter_log;
nosave int last_entry;
nosave mapping messages;
nosave mapping lockdowns;
nosave int _creators;
nosave int _players;
nosave int _login_q;
nosave int _next_user_log;
nosave int _title_call;
nosave int _save_call;
nosave int _out_q;
nosave int _q_time;
nosave int _last_queue_time;
nosave int _last_queue_result;
int is_discworld_full(int test_login_queue);
void write_log(string event, string name, int guest, string other);
void save_users();
private void store_user_count();
private void log_user_count();
protected void check_all_titles( string player );
private void do_all_calls(string player, string event);
private void do_call(class login_information login_inf,
  string player, int event);
int is_uncompressed_full( int );
void create() {
    object pl;
    string name;
    _static_login_calls = ([ ]);
    _dynamic_login_calls = ([ ]);
    seteuid( "Root" );
    unguarded((: restore_object, SAVE_NAME :));
    foreach(name in keys(_static_login_calls)) {
      if(!sizeof(_static_login_calls[name])) {
        map_delete(_static_login_calls, name);
      }
      catch(unguarded((: save_object, SAVE_NAME :)));
    }
    _compressed_players_on = ([ ]);
    _telnet_players_on = ([ ]);
    _players_on = ({ });
    foreach(pl in users()) {
        if (is_compressed_login(pl)) {
            _compressed_players_on[ pl->query_name() ] = 1;
        }
        else {
            _telnet_players_on[ pl->query_name() ] = 1;
        }
        _players_on += ({ pl->query_name() });
    }
    _compressed_login_queue = ({ });
    _telnet_login_queue = ({ });
    _compressed_login_count = 1;
    _save_call = call_out( "save_users", NEW_SAVE_TIME );
    _next_user_log = time() + 3601 - (time() % 3600);
    enter_log = "";
    last_entry = time();
    call_out("clean_lockdowns", 3600);
    write_log("Periodic", "", 0, "");
}
mapping query_static_login_calls() {
    return copy(_static_login_calls);
}
mapping query_dynamic_login_calls() {
    return copy(_dynamic_login_calls);
}
string query_best() { return _best; }
string query_worst() { return _worst; }
string *query_players_on() {
    return keys( _compressed_players_on ) + keys( _telnet_players_on );
}
object *query_login_queue() {
    return _compressed_login_queue + _telnet_login_queue;
}
void add_to_login_queue(object login_ob) {
    if ( is_compressed_login( login_ob ) ) {
        _compressed_login_queue += ({ login_ob });
    }
    else {
        _telnet_login_queue += ({ login_ob });
    }
}
void remove_from_login_queue(object ob) {
    _compressed_login_queue -= ({ ob });
    _telnet_login_queue -= ({ ob });
}
int can_jump_queue( object ob ) {
    return ob->query_creator() || ob->query_net_dead() ||
        ob->query_property( "test character" );
}
object pop_from_login_queue() {
    object ob;
    object *login_queue;
    login_queue = query_login_queue();
    if ( !sizeof( login_queue ) ) {
        return 0;
    }
    if(time() != _q_time){
      _q_time = time();
      _out_q = 0;
    }
    _out_q++;
    foreach( ob in _compressed_login_queue ) {
        if ( can_jump_queue( ob ) ) {
            remove_from_login_queue( ob );
            return ob;
        }
    }
    reset_eval_cost();
    if(sizeof(_telnet_login_queue) &&
       !is_uncompressed_full(WITHOUT_LOGIN_QUEUE)) {
      foreach( ob in _telnet_login_queue ) {
        if ( can_jump_queue( ob ) ) {
          remove_from_login_queue( ob );
          return ob;
        }
      }
    }
    if ( sizeof( _compressed_login_queue) &&
         _compressed_login_count < COMPRESSED_INTAKE_COUNT ) {
        _compressed_login_count++;
        ob = _compressed_login_queue[ 0 ];
        _compressed_login_queue = _compressed_login_queue[ 1.. ];
    } else {
        _compressed_login_count = 0;
        ob = _telnet_login_queue[ 0 ];
        _telnet_login_queue = _telnet_login_queue[ 1.. ];
    }
    return ob;
}
int add_static_login_call(string player, mixed funct, mixed obj) {
  class login_information login_inf;
  if (!stringp(funct) || !stringp(obj) || !stringp(player)) {
    return 0;
  }
  if(obj[0..3] == "/w/")
    return 0;
  if(_static_login_calls[player]) {
    foreach (login_inf in _static_login_calls[player]) {
      if (login_inf->ob == obj &&
    login_inf->funct == funct) {
  return 1;
      }
    }
  }
  if (!_static_login_calls[player]) {
    _static_login_calls[player] = ({ });
  }
  login_inf = new (class login_information, funct : funct, ob : obj);
  _static_login_calls[player] += ({ login_inf });
  catch(unguarded((: save_object, SAVE_NAME :)));
  return 1;
}
int remove_static_login_call(string player, mixed funct, mixed obj) {
  class login_information login_inf;
  if (!stringp(funct) || !stringp(obj) || !stringp(player)) {
    return 0;
  }
  if (_static_login_calls[player]) {
    foreach (login_inf in _static_login_calls[player]) {
      if (login_inf->ob == obj &&
          login_inf->funct == funct) {
        _static_login_calls[player] -= ({ login_inf });
        if(!sizeof(_static_login_calls[player]))
          map_delete(_static_login_calls, player);
        catch(unguarded((: save_object, SAVE_NAME :)));
        return 1;
      }
    }
  }
  return 0;
}
int add_dynamic_login_call(string player, mixed funct, mixed obj) {
    class login_information login_inf;
    if (stringp(obj) || objectp(obj)) {
        if (!stringp(funct)) {
            return 0;
        }
    } else if (!functionp(funct)) {
        return 0;
    }
    if (!_dynamic_login_calls[player]) {
        _dynamic_login_calls[player] = ({ });
    }
    login_inf = new (class login_information, funct : funct, ob : obj);
    _dynamic_login_calls[player] += ({ login_inf });
    return 1;
}
int remove_dynamic_login_call(string player, mixed funct, mixed obj) {
    class login_information login_inf;
    if (stringp(obj) || objectp(obj)) {
        if (!stringp(funct)) {
            return 0;
        }
    } else if (!functionp(funct)) {
        return 0;
    }
    if (_dynamic_login_calls[player]) {
        foreach (login_inf in _dynamic_login_calls[player]) {
            if (login_inf->ob == obj &&
              login_inf->funct == funct) {
                _dynamic_login_calls[player] -= ({ login_inf });
                return 1;
            }
        }
    }
    return 0;
}
void update_players_on( string player ) {
    object ob = find_player( player );
    if ( !ob ) {
        return;
    }
    if ( is_compressed_login( ob ) ) {
        if ( undefinedp( _compressed_players_on[ player ] ) ) {
            _compressed_players_on[ player ] = 1;
        }
    }
    else {
        if ( undefinedp( _telnet_players_on[ player ] ) ) {
            _telnet_players_on[ player ] = 1;
        }
    }
    if ( member_array( player, _players_on ) == -1 ) {
        _players_on += ({ player });
    }
}
int tidy_players_on( string player ) {
    int pos;
    int ret;
    ret = 0;
    if ( _compressed_players_on[ player ] ) {
        map_delete( _compressed_players_on, player );
        ret = 1;
    }
    if ( _telnet_players_on[ player ] ) {
        map_delete( _telnet_players_on, player );
        ret = 1;
    }
    pos = member_array( player, _players_on );
    if ( pos != -1 ) {
        _players_on = _players_on[0..pos-1] + _players_on[pos+1..];
        ret = 1;
    }
    return ret;
}
int player_logon(string player, int guest, string ip) {
    if(lower_case(player) != (string)previous_object()->query_name()) {
        return 0;
    }
    update_players_on( player );
    do_all_calls(player, LOGIN);
    if (find_call_out(_title_call) == -1) {
        _title_call = call_out("check_all_titles", 5, player );
    }
    write_log("Enter", player, guest, ip);
}
private void do_all_calls(string player, string event_t) {
  class login_information login_inf;
  if (_static_login_calls[player]) {
    foreach (login_inf in _static_login_calls[player]) {
      call_out((: do_call :), 1, login_inf,
               player, event_t );
    }
  }
  if (_static_login_calls["all"]) {
    foreach (login_inf in _static_login_calls["all"]) {
      call_out((: do_call :), 1, login_inf,
               player, event_t );
    }
  }
  if (_dynamic_login_calls[player]) {
    foreach (login_inf in _dynamic_login_calls[player]) {
      call_out((: do_call :), 1, login_inf,
               player, event_t );
    }
  }
  if (_dynamic_login_calls["all"]) {
    foreach (login_inf in _dynamic_login_calls["all"]) {
      call_out((: do_call :), 1, login_inf,
               player, event_t );
    }
  }
}
private void do_call(class login_information login_inf,
                     string player, int event_t) {
  object ob;
  if (!find_player(player) || find_player(player)->query_invis() < 2) {
    if (!functionp(login_inf->funct)) {
      if(login_inf->ob && login_inf->funct)
        catch(ob = load_object(login_inf->ob));
      if ( ob ) {
        catch(call_other(ob, login_inf->funct, player,
                         event_t));
      } else {
        tell_creator("ceres", "failed to load %s", login_inf->ob);
      }
    } else {
      catch(evaluate(login_inf->funct, player, event_t));
    }
  }
}
int player_logout(string player) {
    object ob;
    do_all_calls(player, LOGOUT);
    if ( tidy_players_on( player ) ) {
        if (find_call_out(_title_call) == -1) {
            _title_call = call_out("check_all_titles", 5, player );
        }
    }
    if(find_call_out(_save_call) == -1) {
        _save_call = call_out("save_users", NEW_SAVE_TIME );
    }
    while (sizeof(query_login_queue()) &&
        !is_discworld_full(WITHOUT_LOGIN_QUEUE) ) {
        ob = pop_from_login_queue();
        if (ob) {
            ob->remove_from_login_queue();
        }
    }
    write_log("Exit", player, 0, "");
    return 1;
}
int player_net_dead(string player) {
    object ob;
    if ( tidy_players_on( player ) ) {
        do_all_calls(player, NETDEATH);
        if (find_call_out(_title_call) == -1) {
            _title_call = call_out("check_all_titles", 5, player );
        }
    }
    while ( sizeof(query_login_queue()) && !is_discworld_full(WITHOUT_ANY_LOGINS) ) {
        ob = pop_from_login_queue();
        if (ob) {
            ob->remove_from_login_queue();
        }
    }
    write_log("NDead", player, 0, "");
    return 1;
}
int player_reconnected(string player) {
    update_players_on(player);
    do_all_calls(player, RECONNECT);
    if (find_call_out(_title_call) == -1) {
        _title_call = call_out("check_all_titles", 5, player);
    }
    write_log("Recon", player, 0, query_ip_name(find_player(player)));
}
protected void check_all_titles( string player ) {
    int al, good, bad;
    object good_thing, bad_thing, thing, *things;
    good = -250;
    bad = 250;
    things = users();
    foreach( thing in things ) {
      if (!thing || thing->query_creator() ) {
        continue;
      }
      al = (int)thing->query_al();
      if ( al > bad ) {
        bad = al;
        bad_thing = thing;
      }
      if ( al < good ) {
        good = al;
        good_thing = thing;
      }
    }
    if ( bad_thing ) {
      if ( stringp( _worst ) && ( _worst != player ) ) {
        thing = find_player( _worst );
      } else {
        thing = 0;
      }
      if ( bad_thing != thing ) {
        if ( thing ) {
          thing->remove_title( "align" );
        }
        switch ( (int)bad_thing->query_gender() ) {
        case 1 :
          bad_thing->set_title( "align", "Lord of Darkness" );
          break;
        case 2 :
          bad_thing->set_title( "align", "Lady of Darkness" );
          break;
        default :
          bad_thing->set_title( "align", "Monster of Darkness" );
        }
        _worst = (string)bad_thing->query_name();
      }
    }
    if ( good_thing ) {
      if ( stringp( _best ) && ( _best != player ) ) {
        thing = find_player( _best );
      } else {
        thing = 0;
      }
      if ( good_thing != thing ) {
        if ( thing ) {
          thing->remove_title( "align" );
        }
        switch ( (int)good_thing->query_gender() ) {
        case 1 :
          good_thing->set_title( "align", "Lord of Light" );
          break;
        case 2 :
          good_thing->set_title( "align", "Lady of Light" );
          break;
        default :
          good_thing->set_title( "align", "Creature of Light" );
        }
        _best = (string)good_thing->query_name();
      }
    }
}
void save_users() {
    int number;
    int next_time;
    string word;
    object thing;
    number = sizeof( _players_on );
    if ( !number ) {
        _players_on = query_players_on();
        _save_call = call_out("save_users", NEW_SAVE_TIME );
        return;
    }
    store_user_count();
    if(_next_user_log < time()) {
        log_user_count();
    }
    word = _players_on[ 0 ];
    thing = find_player( word );
    if ( objectp( thing ) && ( number > 1 ) ) {
        if ( environment( thing ) ) {
            thing->save_me();
        }
        _players_on = _players_on[1..] + ({ word });
    } else {
        _players_on = _players_on[1..] + ({ word });
    }
    next_time = SAVE_TIME / number;
    if ( next_time > 10 ) {
        next_time = 10;
    }
    _save_call = call_out( (: save_users :), next_time );
}
int int_is_discworld_full(int logins) {
    object *players;
    int compressed;
    int uncompressed;
    int ret;
    int ext;
    players = users();
    switch (logins) {
    case WITHOUT_LOGINS_NOT_IN_QUEUE :
        players = filter(players, (: objectp($1) && !$1->query_login_ob() &&
            !$1->query_creator() :)) + query_login_queue();
        break;
    case WITHOUT_LOGIN_QUEUE :
        players -= query_login_queue();
        players = filter(players, (: objectp($1) && !$1->query_creator() :));
        break;
    case WITHOUT_ANY_LOGINS :
        players = filter(players, (: objectp($1) && !$1->query_login_ob() &&
            !$1->query_creator() :));
        ext = _out_q;
        break;
    default :
        players = filter(players, (: objectp($1) && !$1->query_creator() :));
        break;
    }
    if(time() != _q_time){
      ext = 0;
      _out_q = 0;
      _q_time = time();
    }
    compressed = sizeof( filter( players, (: is_compressed_login($1) :) )  ) + ext;
    uncompressed = sizeof( players ) - compressed;
    ret = DISCWORLD_IS_EMPTY;
    if ( compressed >= MAX_COMPRESSED_PLAYERS ) {
        ret |= COMPRESSED_FULL;
    }
    if ( uncompressed >= MAX_UNCOMPRESSED_PLAYERS ) {
        ret |= UNCOMPRESSED_FULL;
    }
    return ret;
}
int is_compressed_full( int logins ) {
    return int_is_discworld_full( logins ) & COMPRESSED_FULL;
}
int is_uncompressed_full( int logins ) {
    return int_is_discworld_full( logins ) & UNCOMPRESSED_FULL;
}
int is_discworld_full(int logins) {
    int ret;
    ret = int_is_discworld_full( logins );
    ret = (ret & COMPRESSED_FULL) && (ret & UNCOMPRESSED_FULL);
    return ret;
}
private void store_user_count() {
    object pl;
    int current_players, current_creators, current_login_q;
    string *logins_n;
    foreach(pl in users()) {
      if (pl && !pl->query_login_ob()) {
        if (pl->query_creator()) {
          current_creators++;
        } else {
          current_players++;
        }
      }
    }
    logins_n = map(LOGIN_HANDLER->query_login_queue(),
      (: $1->query_cap_name() :));
    logins_n = sort_array(logins_n, 1);
    current_login_q = sizeof(logins_n);
    if(current_players + current_login_q > _players + _login_q) {
        _players = current_players;
        _creators = current_creators;
        _login_q = current_login_q;
    }
}
private void log_user_count() {
    log_file("USERS", "%s %d %d %d\n" ,ctime(time()), _creators, _players,
      _login_q);
    _creators = 0;
    _players = 0;
    _login_q = 0;
    _next_user_log = time() + 3601 - (time() % 3600);
}
void write_log(string event, string name, int guest, string other) {
    switch(event) {
    case "Enter":
        enter_log += sprintf( "%s [Enter] %-15s %s%s\n",
          ctime(time())[4..18], name,
          guest?"(guest) ":"",
          other);
        break;
    case "Su":
        enter_log += sprintf( "%s [Su]    %15-s %15-s\n",
          ctime(time())[4..18], name, other);
        break;
    case "Periodic":
        call_out("write_log", BUFFER_TIME, "Periodic", "", 0, "");
        if (sizeof(enter_log) && time() - last_entry > BUFFER_TIME) {
            unguarded((: write_file, "/d/admin/log/ENTER.log", enter_log :));
            enter_log = "";
            last_entry = time();
        }
        return;
    case "Recon":
        enter_log += sprintf( "%s [Recon] %15-s %s\n",
          ctime(time())[4..18], name, other);
        break;
    default:
        enter_log += sprintf("%s %-7s %15-s\n", ctime(time())[4..18],
          "["+event+"]", name);
        break;
    }
    last_entry = time();
    if(sizeof(enter_log) > 1024) {
        unguarded((: write_file, "/d/admin/log/ENTER.log", enter_log :));
        enter_log = "";
    }
}
void dest_me() {
    unguarded((: write_file, "/d/admin/log/ENTER.log", enter_log :));
    enter_log = "";
    destruct(this_object());
}
string get_message(string mess_name) {
    if(!messages)
        messages = ([ ]);
    if(mess_name[0..4] != "/doc/")
        return 0;
    if(!messages[mess_name])
        messages[mess_name] = read_file(mess_name);
    return messages[mess_name];
}
void clear_messages() {
    messages = ([ ]);
}
int site_lockeddown(string ip_addr) {
    if(!lockdowns)
        lockdowns = ([ ]);
    if(lockdowns[ip_addr] &&
      (sizeof(lockdowns[ip_addr]) >= MAX_FAILURES) &&
      (lockdowns[ip_addr][0] > time() - LOCKDOWN_TIME))
        return 1;
    return 0;
}
void failed_login(string ip_addr) {
  int i;
  if(!lockdowns)
    lockdowns = ([ ]);
  if(!lockdowns[ip_addr])
    lockdowns[ip_addr] = ({ time() });
  else {
    for(i=0; i<sizeof(lockdowns[ip_addr]); i++)
      if(lockdowns[ip_addr][i] < time() - LOCKDOWN_TIME) {
        lockdowns[ip_addr] -= ({ lockdowns[ip_addr][i] });
        i--;
      }
    lockdowns[ip_addr] += ({ time() });
    if(sizeof(lockdowns[ip_addr]) > MAX_FAILURES) {
      lockdowns[ip_addr] =
        lockdowns[ip_addr][sizeof(lockdowns[ip_addr])-MAX_FAILURES..];
    }
  }
}
void clean_lockdowns() {
  string ip;
  call_out("clean_lockdowns", 1800);
  foreach(ip in keys(lockdowns)) {
    if(lockdowns[ip][sizeof(lockdowns[ip])-1] < time() - LOCKDOWN_TIME) {
      map_delete(lockdowns, ip);
    }
  }
}
void clear_lockdowns(string ip) {
  if(!ip)
    lockdowns = ([ ]);
  else if(lockdowns[ip])
    map_delete(lockdowns, ip);
}
void query_lockdowns() {
    printf("%O\n", lockdowns);
}
void reset() {
    if (find_call_out(_save_call) == -1) {
        save_users();
    }
}

==================================================
FILE: handlers/mag_eff_handler.c
==================================================

#define BLACK_MASS 1000
#define NUM_POSS 6
#define NUM_USER 20
private mixed *_octonite;
private int _call_out_no;
protected void update_octonite();
protected void schedule_next();
int block( object thing ) {
   if ( !thing->query_closed() )
      return 0;
   return (int)thing->query_property( "enchantment block" );
}
int ambient_enchantment( object thing ) {
   int i, total;
   object *tops;
   tops = ({ thing });
   while ( environment( tops[ 0 ] ) ) {
      tops = ({ environment( tops[ 0 ] ) }) + tops;
   }
   for ( i = 0; i < sizeof( tops ); i++ ) {
      total += (int)tops[ i ]->query_enchant();
      total = ( total * ( 100 - block( tops[ i ] ) ) + 50 ) / 100;
   }
   return total;
}
int *choose_effect( int number ) {
  return ({ number, random( NUM_POSS * number ) / BLACK_MASS });
}
void do_effect( int number, string name, object place ) {
  int i;
  string word;
  object thing, *things;
  switch( number ) {
    case 0:
      tell_room( place, "How curious.\n" );
      break;
    case 1:
      tell_room( place, name +" spins slowly in mid-air, then "+
        "vanishes with a small \"pop!\"\n" );
      break;
    case 2:
      i = random( 4 );
      tell_room( place, name +" sparkles and turns into a small "+
        ({ "yellow", "green", "hairy", "spotted" })[ i ] +" caterpillar.\n" );
      thing = clone_object( "/obj/monster" );
      thing->set_name( "caterpillar" );
      thing->set_short( ({ "yellow", "green", "hairy", "spotted" })[ i ]
        +" caterpillar" );
      thing->add_adjective( ({ "yellow", "green", "hairy", "spotted" })[ i ] );
      thing->set_main_plural( ({ "yellow", "green", "hairy", "spotted" })[ i ]
        +" caterpillars" );
      thing->add_plural( "caterpillars" );
      thing->set_long( "This is a small, common or garden caterpillar.\n" );
      thing->set_race( "caterpillar" );
      thing->set_level( 1 );
      thing->move( place );
      break;
    case 3:
      tell_room( place, name +" vanishes with a sharp \"spang!\"\n"+
        "A moment later, you hear a small thunderclap.\n" );
      break;
    case 4:
      tell_room( place, "Balefire blossoms, and "+ name +" turns into "+
        "a bunch of flowers.\n" );
      thing = clone_object( "/std/object" );
      thing->set_name( "flowers" );
      thing->set_short( "bunch of flowers" );
      thing->set_main_plural( "bunches of flowers" );
      thing->add_adjective( ({ "bunch", "bunches", "of" }) );
      thing->add_plural( "bunches" );
      thing->set_long( "A nice bunch of flowers.\n" );
      thing->set_weight( 10 );
      thing->set_value( 100 );
      thing->move( place );
      break;
    case 5:
      tell_room( place, "With a small gout of flame, "+ name +" begins "+
        "to accelerate.\n" );
      switch( (string)place->query_property( "location" ) ) {
        case "outside":
          tell_room( place, name +" vanishes into the distance.\n" );
          break;
        default:
          tell_room( place, "There is a small puff of burning dust as "+
            name +" passes through a wall.\n" );
      }
      things = users() - all_inventory( place );
      if ( sizeof( things ) > ( i = random( NUM_USER ) ) ) {
        if ( !( thing = environment( things[ i ] ) ) ) break;
        tell_object( find_player( "deutha" ),
            (string)things[ i ]->query_name() +"\n" );
        tell_room( thing, "You hear a high-pitched whine.\n" );
        tell_object( things[ i ], "Something small and very hot zooms past "+
          "you at ear level.\n" );
        if ( ( !( word = (string)things[ i ]->query_short() ) || ( word == "" )
          ) || things[ i ]->query_invis() ) break;
        tell_room( thing, word +" looks shaken.\n", things[ i ] );
      }
      break;
    default:
      tell_room( place, "Something really, really strange happens.\n" );
  }
}
object *query_octonite_crystals() { return _octonite; }
void add_octonite_crystal( object crystal ) {
   int i, when;
   when = time() + roll_MdN( 5, 60 );
   if ( !sizeof( _octonite ) ) {
      _octonite = ({ crystal, when });
      schedule_next();
   } else {
      for ( i = 0; i < sizeof( _octonite ); i += 2 ) {
         if ( when < _octonite[ i + 1 ] ) {
            break;
         }
      }
      if ( i == 0 ) {
         _octonite = ({ crystal, when }) + _octonite;
         schedule_next();
         return;
      }
      if ( i >= sizeof( _octonite ) ) {
         _octonite += ({ crystal, when });
         return;
      }
      _octonite = _octonite[ 0 .. i - 1 ] + ({ crystal, when }) +
            _octonite[ i ..  ];
   }
}
protected void schedule_next() {
   int next;
   remove_call_out(_call_out_no);
   next = _octonite[ 1 ] - time();
   if ( next > 0 ) {
      _call_out_no = call_out( (: update_octonite :), next );
   } else {
      _call_out_no = call_out( (: update_octonite :), 0 );
   }
}
protected void update_octonite() {
   int ambient, weight;
   object crystal;
   crystal = _octonite[ 0 ];
   if ( objectp( crystal ) ) {
      weight = 20 * (int)crystal->query_weight();
      tell_object( find_player( "deutha" ), "Current: "+ weight +".\n" );
      ambient = ambient_enchantment( crystal );
      if ( ambient > weight ) {
         weight += ( ambient - weight ) / 4;
      }
      weight -= ( weight * ( 100 - block( environment( crystal ) ) ) ) / 800;
      if ( random( 20 ) < weight % 20 ) {
         weight += 20;
      }
      weight /= 20;
      if ( !weight )
         crystal->dest_me();
      else {
         crystal->set_weight( weight );
         crystal->set_enchant( ( 7 * (int)crystal->query_max_enchant() ) / 8 );
         crystal->set_value_info( "magic", weight * 10000 );
      }
      _octonite = delete( _octonite, 0, 2 );
      if ( sizeof( _octonite ) ) {
         schedule_next();
      }
      if ( crystal ) {
         add_octonite_crystal( crystal );
      }
   } else {
      _octonite = delete( _octonite, 0, 2 );
      if ( sizeof( _octonite ) ) {
         schedule_next();
      }
   }
}
string extra_look( object thing ) {
   if ( explode( file_name( thing ), "#" )[ 0 ] != "/obj/magic/octonite" ) {
      return "";
   }
   switch ( (int)thing->query_weight() ) {
      case 0 :
         return "";
      case 1 .. 2 :
         return "It is about the size of a pea.\n";
      case 3 .. 6 :
         return "It is about the size of a hazelnut.\n";
      case 7 .. 12 :
         return "It is about the size of a walnut.\n";
      case 13 .. 20 :
         return "It is about the size of an orange.\n";
      case 21 .. 30 :
         return "It is about the size of a grapefruit.\n";
      default :
         return "It is about the size of a pumpkin.\n";
   }
}

==================================================
FILE: handlers/mail_track.c
==================================================

inherit "std/object";
#include <mail.h>
#include <mail_track.h>
#include <player_handler.h>
#define SECURITY if (!master()->query_leader(previous_object(-1))) return 0;
int add_member(string list, string mem);
private void load_me();
private void save_me();
int query_list(string list);
int create_list(string list, string creator);
nosave mixed *our_mailers;
mapping mailing_lists;
void setup() {
   set_name("tracker");
   set_short("mail tracker");
   add_property("determinate", "the ");
   add_property("there", "mounted on one wall");
   add_adjective("mail");
   set_long("This thing tracks mail.   Clever, innit?\n");
   reset_get();
   reset_drop();
   our_mailers = ({ });
   mailing_lists = ([ ]);
   seteuid("Root");
   load_me();
   if (!query_list("postmaster")) {
      create_list("postmaster", "pinkfish");
   }
   move(MAIL_ROOM);
}
int add_mailer(object ob, string str) {
   int i;
   if (!stringp(str) || !objectp(ob)) {
      return 0;
   }
   i = member_array(str, our_mailers);
   if (i == -1) {
      our_mailers += ({ ob, str });
   } else {
      write(i);
      if (our_mailers[i-1]) {
         our_mailers[i-1]->dest_me();
      }
      our_mailers += ({ ob, str });
   }
   return 1;
}
object find_mailer(string str) {
   int i;
   if (!stringp(str)) {
      return 0;
   }
   i = member_array(str, our_mailers);
   if (i == -1) {
      return 0;
   }
   return our_mailers[i-1];
}
int delete_mailer(object ob) {
   int i;
   if (!objectp(ob)) {
      return 0;
   }
   i = member_array(ob, our_mailers);
   if (i == -1) {
      return 0;
   }
   our_mailers = delete(our_mailers, i, 2);
}
void we_are_done(object me) {
   if (objectp(me)) {
      me->dest_me();
   }
}
int mail(string str, string sub) {
   object mailer;
   mailer = clone_object(MAILER);
   mailer->set_do_this_last(({ this_object(), "we_are_done", mailer }));
   mailer->read_mail(str, sub);
   return 2;
}
private void save_me() {
   unguarded((: save_object, "/save/mail_track" :));
}
private void load_me() {
   string *list_names, name;
   mixed *list;
   unguarded((: restore_object, "/save/mail_track" :));
   list_names = keys(mailing_lists);
   if (sizeof(list_names) && !classp(mailing_lists[list_names[0]])) {
      foreach (name, list in mailing_lists) {
         mailing_lists[name] = new(class mailing_list, members : list[0],
                                                controllers : list[1], creator : list[2]);
      }
      save_me();
   }
}
string *query_mailing_lists() {
   return keys(mailing_lists) +
     "/secure/master"->query_domains() +
      ({ "seniors", "lords", "hlords" });
}
int query_list(string list) {
   return member_array(list, query_mailing_lists()) != -1;
}
string *query_members(string list) {
  string *tmp;
  switch (list) {
  case "playtesters" :
    tmp = (string *)"/obj/handlers/playtesters"->query_playtesters();
    return ({ "/d/playtesters/master"->query_lord() }) + sort_array(tmp, 1);
  case "seniors" :
    tmp = (string *)master()->query_all_seniors();
    return tmp;
  case "lords" :
    tmp = (string *)master()->query_all_leaders();
    return tmp;
  case "hlords" :
    tmp = ((string *)master()->query_administrators() -
           ({ "Admin", "Root", "offler" }));
    return tmp;
  default :
  }
  if (file_size("/d/"+ list) == -2) {
    tmp = (string *)("/d/"+ list +"/master")->query_members() +
      ({ (string)("/d/"+ list +"/master")->query_lord() });
  }
  else if (mailing_lists[list]) {
    tmp = copy(mailing_lists[list]->members);
  }
  if(tmp)
    return filter_array(tmp, (: PLAYER_HANDLER->test_active($1, 1) :));
  return ({ });
}
int query_member(string list_name, string name) {
   class mailing_list list;
   list = mailing_lists[list_name];
   if (list) {
      return member_array(name, list->members) != -1;
   }
   if (file_size("/d/" + list_name) == -2) {
      return (int)("/d/" + list_name + "/master")->query_member(name);
   }
   if (list_name == "seniors") {
      return (int)master()->query_senior(name);
   }
   if (list_name == "lords") {
      return (int)master()->query_leader(name);
   }
   if (list_name == "hlords") {
      return (int)master()->query_administrator(name);
   }
}
string *query_controllers(string list) {
   if (file_size("/d/"+ list) == -2) {
      return ({ (string)("/d/"+ list +"/master")->query_lord() });
   }
   if (mailing_lists[list]) {
      return copy(mailing_lists[list]->controllers);
   }
   return ({ });
}
int query_controller(string list_name, string name) {
   class mailing_list list = mailing_lists[list_name];
   if (!list) {
      return 0;
   }
   return member_array(name, list->controllers) != -1;
}
string query_creator(string list_name) {
   class mailing_list list = mailing_lists[list_name];
   if (!classp(list)) {
      return 0;
   }
   return list->creator;
}
int create_list(string list, string creator) {
   SECURITY
   if (mailing_lists[list]) {
      return 0;
   }
   if (file_size("/d/" + list) == -2) {
      return 0;
   }
   if (PLAYER_HANDLER->test_user(list)) {
      return 0;
   }
   mailing_lists[list] = new(class mailing_list, members : ({ creator }),
                                          controllers : ({ creator }), creator : creator);
   save_me();
   return 1;
}
protected int delete_list(string list) {
   if (!mailing_lists[list]) {
      return 0;
   }
   map_delete(mailing_lists, list);
   save_me();
   return 1;
}
int add_controller(string list_name, string mem) {
   class mailing_list list = mailing_lists[list_name];
   SECURITY
   if (!classp(list)) {
      return 0;
   }
   if (member_array(mem, list->controllers) != -1) {
      return 0;
   }
   list->controllers += ({ mem });
   add_member(list_name, mem);
   save_me();
   return 1;
}
int remove_controller(string list_name, string name) {
   int i;
   class mailing_list list = mailing_lists[list_name];
   SECURITY
   if (!classp(list)) {
      return 0;
   }
   if ((i = member_array(name, list->controllers)) == -1) {
      return 0;
   }
   list->controllers = delete(list->controllers, i, 1);
   save_me();
   return 1;
}
int add_member(string list_name, string mem) {
   class mailing_list list = mailing_lists[list_name];
   if (file_name(previous_object()) != MAIL_ROOM) {
      return 0;
   }
   if (!classp(list)) {
      return 0;
   }
   if (member_array(mem, list->members) != -1) {
      return 0;
   }
   list->members += ({ mem });
   save_me();
   return 1;
}
int remove_member(string list_name, string mem) {
   int i;
   class mailing_list list = mailing_lists[list_name];
   if (file_name(previous_object()) != MAIL_ROOM) {
      return 0;
   }
   if (!classp(list)) {
      return 0;
   }
   if ((i = member_array(mem, list->members)) == -1) {
      return 0;
   }
   list->members = delete(list->members, i, 1);
   if (!sizeof(list->members)) {
      delete_list(list_name);
   }
   save_me();
   return 1;
}
int delete_member(string list_name, string mem) {
   class mailing_list list = mailing_lists[list_name];
   SECURITY
   if (!remove_member(list_name, mem)) {
      return 0;
   }
   remove_controller(list_name, mem);
   if (!sizeof(list->members)) {
      delete_list(list_name);
   }
   save_me();
   return 1;
}
