# Total Tokens: 20510
# Total Files Merged: 28
# Total Characters: 68451


==================================================

inherit "/obj/vessel";
nosave string description, actual_drink, actual_glass_size;
void create() {
    do_setup++;
    ::create();
    do_setup--;
    set_name("glass");
    set_weight(1);
    set_value(400);
    set_stuck(1);
    set_leak_rate(0);
    set_material("glass");
    add_property("fragile", 200);
    if (!do_setup) {
        this_object()->setup();
    }
}
void make_glass(string drink, string glass_description, string glass_size,
   int amount, int has_contents)
{
    string *glass_adjectives;
    object contents;
    description = glass_description;
    actual_drink = drink;
    actual_glass_size = glass_size;
    glass_adjectives = explode( glass_size, " " )[0..<2];
    set_short( glass_size );
    set_long( (: this_object()->query_volume() ? description : "This is "
        "a dirty " + actual_glass_size + ", one that used to hold some "
        " " + actual_drink + ".\n" :) );
    glass_adjectives = explode( glass_size, " " );
    if (sizeof(glass_adjectives) > 1)
        add_alias(glass_adjectives[<1..]);
    else
        add_alias(glass_size);
    add_adjective(glass_adjectives);
    set_max_volume(amount);
    if (has_contents) {
        contents = clone_object("/obj/reagents/generic_liquid.ob");
        contents->set_name("drink");
        contents->set_short(drink);
        contents->set_long("This is some delicious looking " + drink + ".\n" );
        contents->add_adjectives(explode(drink, " ")[0..<2]);
        contents->add_alias( explode( drink, " " )[ sizeof(
           explode( drink, " " ) ) - 1 ] );
        contents->set_amount(amount);
        contents->move(this_object());
    }
}
mapping int_query_static_auto_load() {
    return ([
        "::": ::int_query_static_auto_load(),
        "description": description,
        "actual_drink" : actual_drink,
        "actual_glass_size" : actual_glass_size,
    ]);
}
void init_static_arg(mapping map) {
    if (map["::"])
        ::init_static_arg(map["::"]);
    if (!undefinedp(map["description"]))
        description = map["description"];
    if (!undefinedp(map["actual_drink"]))
        actual_drink = map["actual_drink"];
    if (!undefinedp(map["actual_glass_size"]))
        actual_glass_size = map["actual_glass_size"];
    set_long((: this_object()->query_volume() ? description : "This is "
        "a dirty " + actual_glass_size + ", one that used to hold some "
        "sort of " + actual_drink + ".\n" :));
}
mixed query_static_auto_load() {
    if (base_name(this_object()) == "/obj/misc/glass" )
        return int_query_static_auto_load();
    return ([ ]);
}

==================================================
FILE: misc/golem_corpse.c
==================================================

#include <armoury.h>
inherit "/obj/container";
void make_fragments();
void setup() {
    set_name( "rubble" );
    set_short( "heap of clay rubble" );
    add_alias( ({"heap", "clay"}) );
    add_adjective( ({"heap of", "clay"}) );
    set_main_plural( "heaps of clay rubble" );
    add_plural( "heaps" );
    set_weight( 40000 );
    set_max_weight( 50000 );
    set_value( 0 );
    set_stuck( 1 );
    make_fragments();
    add_property( "no recycling", 1 );
}
void make_fragments() {
    int amount = random( 8 );
    int i;
    for( i = 1; i <= amount; i++ )
        switch( random( 11 ) ) {
           case 0..5:
               ARMOURY->request_item( "golem shard", 100 )->
                   move( this_object() );
               break;
           case 6..7:
               ARMOURY->request_item( "golem finger", 100 )->
                   move( this_object() );
               break;
           case 8..9:
               ARMOURY->request_item( "golem toe", 100 )->
                   move( this_object() );
               break;
           case 10:
               ARMOURY->request_item( "golem eye", 100 )->
                   move( this_object() );
               break;
        }
}
string long( string word, int dark ) {
    string inv = query_multiple_short( all_inventory( this_object() ) );
    string tmp = "";
    switch( sizeof( all_inventory( this_object() ) ) ) {
        case 0:
           break;
        case 1:
            tmp = "Something that looks like " + inv + " protrudes from it.  ";
            break;
        default:
            tmp = "It looks like " + inv + " are buried in it.  ";
    }
    return "This is a large heap of shattered clay.  " + tmp + "Whatever this "
        "was before, it is destroyed thouroughly and beyond any means of "
        "repair.\n";
}

==================================================
FILE: misc/golem_eye.c
==================================================

inherit "/std/object";
void setup() {
    set_name( "triangle" );
    set_short( "clay triangle" );
    add_adjective( ({"clay"}) );
    set_long( "This is a cracked piece of clay.  A hole in the shape of a "
       "triangle is in its middle.\n" );
    set_main_plural( "clay triangles" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
}

==================================================
FILE: misc/golem_finger.c
==================================================

inherit "/std/object";
void setup() {
    set_name( "fingertip" );
    set_short( "broken clay fingertip" );
    add_adjective( ({"broken", "clay"}) );
    set_long( "This looks like a crude fingertip made of clay.  It is broken "
       "in the middle.\n" );
    set_main_plural( "broken clay fingertips" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
}

==================================================
FILE: misc/golem_shard.c
==================================================

inherit "/std/object";
void setup() {
    set_name( "shard" );
    set_short( "cracked clay shard" );
    add_adjective( ({"clay"}) );
    set_long( "This is a heavily cracked clay shard." );
    set_main_plural( "cracked clay shards" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
}

==================================================
FILE: misc/golem_toe.c
==================================================

inherit "/std/object";
void setup() {
    set_name( "toe" );
    set_short( "remains of a clay toe" );
    add_adjective( ({"remains", "of", "a", "clay"}) );
    set_long( "This looks part of a toe made of clay.\n" );
    set_main_plural( "remains of clay toes" );
    set_weight( 5 );
    set_value( 0 );
    add_property( "no recycling", 1 );
    add_property( "determinate", "the " );
}

==================================================
FILE: misc/grinder.c
==================================================

#include <move_failures.h>
#define STATE_CHANGE "/obj/handlers/state_change"
inherit "/obj/container";
int test_add(object ob, int flag);
int do_grind( string what );
int do_empty(object *dest, string me, string him, string prep);
void set_max_grindable( int i );
int query_max_grindable();
string long_status();
private int _max_grind = 0;
void setup() {
  set_name( "grinder" );
  set_short( "food grinder" );
  add_adjective( "food" );
  set_main_plural( "food grinders" );
  set_long( "This is a mechanical contraption to grind food into small "
      "pieces.  There is a funnel-type piece at the top, a crank on one "
      "side and on the other a pipe where the ground food comes out and "
      "is caught in a small tray.\n" );
  set_value( 4000 );
  set_weight( 100 );
  set_max_weight( 100 );
}
void init() {
  this_player()->add_command( "grind", this_object(),
      "<string'object'> in <direct:object'" + query_short() + "'>",
      (: do_grind( $4[0] ) :) );
  add_command( "empty", "<direct:object>" );
}
int test_add(object ob, int flag) {
  object stuff = first_inventory();
  if (stuff) {
    add_failed_mess( "There is already some " + stuff->query_short()
      + " in the grinder.  You'll have to empty it first.\n");
    return 0;
  } else return 1;
}
int do_grind( string what ) {
  object *things, thing;
  object ground;
  object contents;
  things = match_objects_for_existence( what, ({ this_object(),
                                                 this_player() }) );
  if( !sizeof( things ) ) {
    add_failed_mess( "You must be holding something or put it in $D in "
                     "order to $V it.\n" );
    return -1;
  }
  thing = things[0];
  if( ( contents = first_inventory() ) && contents != thing ) {
    add_failed_mess( "$D isn't empty.\n" );
    return -1;
  }
  if( query_max_grindable() &&
      ( thing->query_amount() > query_max_grindable() ||
        thing->query_weight() > query_max_grindable() ) ) {
    add_failed_mess( "You cannot grind that much with $D at once.\n" );
    return -1;
  }
  ground = STATE_CHANGE->transform( thing, "grind" );
  if ( !objectp( ground ) ) {
    add_failed_mess( "You cannot $V $I in $D.\n", ({ thing }) );
    return -1;
  }
  thing->move( "/room/rubbish" );
  if( ground->move( this_object() ) != MOVE_OK ) {
    ground->move( environment( this_player() ) );
    add_succeeded_mess( "$N grind$s $I with $D, spilling it onto the " +
        ( environment( this_player() )->query_property( "location" ) ==
        "inside" ? "floor" : "ground" ) + ".\n" );
    return 1;
  }
  this_player()->add_succeeded_mess( this_object(), "$N grind$s $I "
    "in $D.\n", ({ thing }) );
  return 1;
}
int do_empty(object *dest, string me, string him, string prep) {
  object ground = first_inventory( this_object() );
  if( !ground ) {
    add_failed_mess( "There is nothing in $D.\n" );
    return 0;
  }
  if( ground->move( this_player() ) != MOVE_OK ) {
    ground->move( environment( this_player() ) );
    add_succeeded_mess( "$N $V $D onto the " +
        ( environment( this_player() )->query_property( "location" ) ==
        "inside" ? "floor" : "ground" ) + ".\n" );
    return 1;
  }
  return 1;
}
void set_max_grindable( int i ) { _max_grind = i; }
int query_max_grindable() { return _max_grind; }
string long_status() { return ""; }

==================================================
FILE: misc/housing_creator.c
==================================================

inherit "/std/object";
#include <housing.h>
#define ORIENTATION ({ "north", "northeast", "east", "southeast", "south", "southwest", "west", "northwest", "up" })
#define OPP_ORIENTATION ({ "south", "southwest", "west", "northwest", "north", "northeast", "east", "southeast", "down" })
#define PATH "/std/houses/"
int do_create(string type, string orientation, string location, string out,
              string region, string address, int overwrite,
              int test);
string list_plans();
void setup() {
  set_name("ball");
  set_short("small jade ball");
  add_adjective(({"small", "jade"}));
  set_long("This non-descript jade ball can be used to make player houses.\n");
  set_read_mess((: list_plans() :));
  set_weight(1);
  set_value(0);
  seteuid("Room");
}
void init() {
  this_player()->add_command("make", this_object(),
           "<word'floor plan'> <word'orientation'> "
           "<word'location'> <word'outside'> <word'region'> <string:quoted'address'>",
           (: do_create($4[0], $4[1], $4[2], $4[3], $4[4], $4[5], 0, 1) :) );
  this_player()->add_command("makereal", this_object(),
           "<word'floor plan'> <word'orientation'> "
           "<word'location'> <word'outside'> <word'region'> <string:quoted'address'>",
           (: do_create($4[0], $4[1], $4[2], $4[3], $4[4], $4[5], 0, 0) :) );
  this_player()->add_command("maketest", this_object(),
           "<word'floor plan'> <word'orientation'> "
           "<word'location'> <word'outside'> <word'region'> <string:quoted'address'>",
           (: do_create($4[0], $4[1], $4[2], $4[3], $4[4], $4[5], 1, 1) :) );
}
string list_plans() {
  string ret, str;
  string plan;
  ret = "To create a house use:\n"
    "  'make <floor plan> <orientation> <location> <outside> <region>\n"
    "        <address>' where:\n"
    "  'makereal <floor plan> <orientation> <location> <outside> <region>\n"
    "        <address>' where:\n"
    "  'makeforce <floor plan> <orientation> <location> <outside> <region>\n"
    "        <address>' where:\n"
    "  floor plan is one of the standard floor plans\n"
    "  orientation is its orientation (ie. the direction you enter it to)\n"
    "  location is the directory to write the houses files into\n"
    "  address is a the unique address for the house\n"
    "  region is the region of the house\n"
    "The 'makereal' command will add the house into the housing handler, "
    "the 'make' command will do a normal test make and the 'makeforce' "
    "will overwrite any existing housing files.\n\n"
    "Example:\n"
    "$I$5=   makereal twobedhouse south /d/am/fluff/housing OUT+room1 am \"12 Fluff Street\"\n\n$I$0="
    "The following floorplans are available:\n";
  str = "";
  foreach(plan in get_dir(PATH + "*")) {
    if(plan != "." && plan != ".." && file_size(PATH + plan) == -2 )
      str += plan + "\n";
  }
  ret += sprintf("%-#*s", this_player()->query_cols(), str);
  return ret;
}
int do_create(string type, string orientation, string location, string out,
              string region, string address, int overwrite,
              int test) {
  string room;
  string tmp;
  string fname;
  mapping files;
  mapping main_file;
  string number;
  int orient;
  int i;
  if(file_size(PATH+type) != -2) {
    return notify_fail("No such floor plan\n");
  }
  orient = member_array(orientation, ORIENTATION);
  if(orient == -1) {
    return notify_fail("No such orientation.\n");
  }
  if(file_size(location) != -2) {
    return notify_fail("No such location.\n");
  }
  if (address[0] < '0' || address[0] > '9') {
     add_failed_mess("Address must start with a number.\n");
     return 0;
  }
  i = 0;
  do {
     i++;
  } while (address[i] != ' ');
  number = address[0..i-1];
  address = address[i..];
  if (out[0] == '/') {
     if (out[<2..] == ".c") {
        out = out[0..<3];
     }
     out = "\"" + out + "\"";
  } else {
     if (member_array('+', out) == -1) {
        out = "PATH+\"" + out + "\"";
     }
  }
  files = ([ ]);
  main_file = ([ ]);
  if (type[<1] != 'M') {
     main_file[""] = 0;
  }
  foreach(room in get_dir(PATH+type+"

==================================================
FILE: misc/ink_well.c
==================================================

inherit "/obj/container";
void create() {
  ::create();
  set_name("well");
  add_adjective("ink");
  set_short("ink well");
  set_long("A nice, small ink well.\n");
  set_value( 500 );
  set_leak_rate(0);
  set_max_volume(250);
  set_volume(200);
  set_water_volume(200);
  set_ps_coord_quantity((int *)"/std/effects/other/ink"->query_coordinate(), 200);
}

==================================================
FILE: misc/juicer.c
==================================================

#include  <bit.h>
inherit "/obj/vessel";
int juice_bit( object ob, string fn );
mapping juice_funs = ([
  "/std/bit" : (: juice_bit :),
]);
void setup() {
  set_name( "juicer" );
  set_short( "juicer" );
  set_main_plural( "juicers" );
  set_long( "This is a device for extracting the juice or liquid from " +
            "objects.  It has a hole at the top for inserting things, " +
            "and a small bowl at the bottom to catch the juice.  You " +
            "could probably \"juice\" something and then \"pour\" " +
            "the juicer into another container.\n" );
  set_value( 4000 );
  set_weight( 100 );
  set_max_volume( 19200 );
}
void init() {
  ::init();
  this_player()->add_command( "juice", this_object(), "%I 'in' %D" );
}
int do_juice( object *things ) {
  int i, amount, *weight_unit, percent;
  string medium_short, *types, fn;
  mapping amount_types;
  if ( living( environment() ) ) {
    this_player()->add_failed_mess( this_object(), "You have to put down "+
        "$D to use it.\n", ({ }) );
    return 0;
  }
  for ( i = 0; i < sizeof( things ); i++ )
    if ( environment( things[ i ] ) != this_player() ) {
      things = delete( things, i, 1 );
      i--;
    }
  if ( !sizeof( things ) ) {
    this_player()->add_failed_mess( this_object(), "You should be carrying "+
        "whatever you want to $V in $D", ({ }) );
    return 0;
  }
  if ( sizeof( things ) > 1 ) {
    this_player()->add_failed_mess( this_object(), "You should only $V "+
        "one thing at a time in $D in case they get mixed up.\n", ({ }) );
    return 0;
  }
  if ( !function_exists( "query_continuous", things[ 0 ] ) ) {
    if ( fn = things[ 0 ]->query_property("juice")
        && functionp( juice_funs[ fn ] )) {
      return evaluate( juice_funs[ fn ], things[ 0 ], fn );
    }
    fn = explode(file_name(things[ 0 ]), "#")[ 0 ];
    if (functionp( juice_funs[ fn ] )) {
      return evaluate( juice_funs[ fn ], things[ 0 ], fn );
    }
    this_player()->add_failed_mess( this_object(), "You cannot $V $I "+
        "in $D.  Trust me on this.\n", ({ things[ 0 ] }) );
    return 0;
  }
  if ( !(percent = things[ 0 ]->query_property("%liquid")) ) {
    this_player()->add_failed_mess( this_object(), "$I apparently doesn't " +
        "contain much juice.\n", ({ things[ 0 ] }) );
    things[ 0 ]->move("/room/rubbish");
    return 0;
  }
  things[ 0 ]->add_plural( (string)things[ 0 ]->query_name() );
  if ((amount = (int)things[ 0 ]->query_amount()) == 0) {
    weight_unit = (int *)things[ 0 ]->query_weight_unit();
    amount = ( weight_unit[ 1 ] * (int)things[ 0 ]->query_weight() ) /
      weight_unit[ 0 ];
    amount = ( ( 50 + random( 21 ) ) * amount ) / 80;
  }
  things[ 0 ]->set_amount( amount*percent/100 );
  things[ 0 ]->set_weight_per_bite( 0 );
  things[ 0 ]->set_bites_gone( 0 );
  medium_short = (string)things[ 0 ]->query_medium_short();
  if ( !medium_short )
    medium_short = (string)things[ 0 ]->query_short();
  if ( !things[ 0 ]->query_medium_alias() )
    things[ 0 ]->set_medium_alias( "Ground"+ capitalize( medium_short ) );
  amount_types = ([ "drop" : ({ 1, "drops" }), "ounce" :
        ({ 120, "ounces" }), "pint" : ({ 2400, "pints" }) ]);
  things[ 0 ]->set_amount_types( amount_types );
  types = m_indices( amount_types );
  for ( i = 0; i < sizeof( types ); i++ )
    things[ 0 ]->add_adjective( ({ types[ i ],
        amount_types[ types[ i ] ][ 1 ] }) );
  things[ 0 ]->add_adjective( "of" );
  if ( !sizeof( (mixed *)things[ 0 ]->query_pile_types() ) )
    things[ 0 ]->set_pile_types( ({ 50, "small", 2400, "medium", 19200,
        "large", "huge" }) );
  things[ 0 ]->add_property( "determinate", "some " );
  things[ 0 ]->grind();
  things[ 0 ]->move( this_object() );
  this_player()->add_succeeded_mess( this_object(), "$N $V $D to make $I.\n",
      ({ things[ 0 ] }) );
  return 1;
}
int juice_bit( object ob, string fn ) {
    object juice_ob;
    mixed *bit_data;
    string *m, s;
    int i;
    juice_ob = clone_object("/obj/reagents/generic_liquid.ob");
    juice_ob->set_name("juice");
    if (s = ob->query_race_name())
      s = capitalize(s);
    bit_data = ob->query_bit_data();
    m = explode(bit_data[ BIT_NAME ], " ");
    for ( i = 0; i < sizeof(m); i++ )
      s += capitalize(m[i]?m[i]:"");
    juice_ob->set_medium_alias(s+"Juice");
    switch ( bit_data[ BIT_ALIAS ] ) {
      case "eye":
        juice_ob->add_adjective("eye");
        juice_ob->add_alias("ichor");
        juice_ob->set_short("clear liquid");
        juice_ob->set_long("This is a clear liquid, slightly tinged" +
                           "with blood.\n");
        juice_ob->set_amount(10*(int)ob->query_weight() + 10);
        break;
      default:
        juice_ob->set_short("liquid");
        juice_ob->set_long("This is a non-descript liquid.  It's probably " +
                           "useless.\n");
        break;
    }
    juice_ob->move(this_object());
    ob->move("/room/rubbish");
    this_player()->add_succeeded_mess( this_object(), "$N $V $D to make $I.\n",
                                      ({ juice_ob }) );
    return 1;
}

==================================================
FILE: misc/keyring.c
==================================================

inherit "/std/container";
void create() {
   do_setup++;
   container::create();
   set_name( "keyring" );
   set_short( "keyring" );
   add_property( "determinate", "a " );
   set_main_plural( "keyrings" );
   add_property("shop type", "jewellers");
   set_long( "This is a ring of metal that overlaps itself at one point, "
         "allowing keys to be strung onto it and be kept together.  It's "
         "amazing how useful a ring of metal can be.\n" );
   set_weight( 2 );
   set_value( 20 );
   set_max_weight( 1 );
   do_setup--;
   if (!do_setup)
      this_object()->setup();
}
string long( string word, int dark ) {
   return ::long( word, dark ) +
         query_contents( "$C$"+ the_short() +" holds: " );
}
mapping query_properties() {
   object thing;
   mixed arg, *args;
   mapping props, map;
   props = ::query_properties();
   args = copy( keys( props ) );
   foreach ( thing in find_inv_match( "", this_player() ) ) {
      map = (mapping)thing->query_properties();
      foreach ( arg in keys( map ) ) {
         if ( !stringp( arg ) ) {
            continue;
         }
         if ( member_array( arg, args ) != -1 ) {
            continue;
         }
         props[ arg ] = map[ arg ];
         args += ({ arg });
      }
   }
   return props;
}
mixed query_property( string word ) {
   object thing;
   mixed arg;
   arg = ::query_property( word );
   if ( arg ) {
      return arg;
   }
   foreach ( thing in find_inv_match( "", this_player() ) ) {
      arg = (mixed)thing->query_property( word );
      if ( arg ) {
         return arg;
      }
   }
   return 0;
}
int test_add( object thing, int flag ) {
   if ( !thing->id( "key" ) && environment( thing ) ) {
      return 0;
   }
   return 1;
}
int add_weight(int n) {
  int tmp, ret;
  if(sizeof(all_inventory(this_object())) >= 15)
    return 0;
  return ::add_weight(n);
}
mapping query_static_auto_load() {
   if ( explode( file_name(), "#" )[ 0 ] == "/obj/misc/keyring" ) {
      return int_query_static_auto_load();
   }
   return ([ ]);
}

==================================================
FILE: misc/label.c
==================================================

inherit "/std/object";
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_name( "label" );
   set_short( "small label" );
   add_adjective( "small" );
   set_main_plural( "small labels" );
   set_long( "This is a small label made from paper with some sort of "+
         "dried glue smeared on one side.  You could probably \"stick\" "+
         "it onto something.\n" );
   set_value( 100 );
   add_property( "writeable", 1 );
   add_property( "label", 1 );
   set_max_size( 200 );
   if ( !do_setup )
      this_object()->setup();
}
void init() {
   this_player()->add_command( "stick", this_object(),
         "<direct:object:me> to <indirect:object>" );
}
int do_stick( mixed *things ) {
   if ( sizeof( things ) > 1 ) {
      add_failed_mess("You can't stick $D to more than one thing at a time.\n");
      return 0;
   }
   if ( things[ 0 ] == this_object() ) {
      add_failed_mess("You cannott stick $D to itself!\n");
      return 0;
   }
   things[ 0 ]->add_effect( "/std/effects/object/label", this_object() );
   add_succeeded_mess("$N lick$s $D and stick$s it to $I.\n", things[0..0]);
   return 1;
}
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/misc/label" ) {
      return ([ ]);
   }
   return int_query_static_auto_load();
}

==================================================
FILE: misc/lantern.c
==================================================

inherit "/obj/lantern";
void setup() {
   fuel_left = 3600;
   is_lit    = 0;
   set_name( "lantern" );
   set_main_plural( "lanterns");
   set_short( "lantern" );
   add_help_file("torch");
   set_long(function() {
     string str;
     str = "This is a camping lantern, which smells of lamp oil.\n";
     if ( is_lit ) {
       return str + "The wick flickers inside spreading a dull "
         "glow.\n";
     }
     str += "The lantern is not lit, and ";
     if ( !fuel_left )
       return str + "is out of oil.\n";
     return str + "has some oil left in it.\n";
   } );
   set_weight( 60 );
   set_value( 150 );
}

==================================================
FILE: misc/lock.c
==================================================

inherit "/std/object";
#include <move_failures.h>
void create() {
  add_help_file("door_lock");
  do_setup++;
  ::create();
  do_setup--;
  if ( !do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
void init() {
  this_player()->add_command("change", this_object(),
      "[lock in] <indirect:object:here'door or furniture'> for "
                             "<indirect:object:me'lock'>");
}
int do_change(mixed *in_dir, string direct, string indirect, mixed *args,
              string) {
  object lock;
  object ob;
  object item;
  object other;
  string other_id;
  item = in_dir[0][0];
  lock = in_dir[1][0];
  if(function_exists("query_my_room", item) &&
     (query_property("locktype") != "door"))
    return notify_fail("This lock is not suitable for a door.\n");
  if(item->query_furniture()) {
    switch(item->query_pick_skill()) {
    case "covert.lockpick.door":
      if(query_property("locktype") != "furniture")
        return notify_fail("This lock is not suitable for furniture.\n");
    case "covert.lockpick.safes":
      if(query_property("locktype") != "safe")
        return notify_fail("This lock is not suitable for safes.\n");
    }
  }
  if(function_exists("query_my_room", item) &&
     !function_exists("test_occupier", environment(this_player())))
    return notify_fail("You cannot change the locks here.\n");
  if(function_exists("test_occupier", environment(this_player())) &&
     !environment(this_player())->test_occupier(this_player()->query_name())
     && !this_player()->query_creator())
    return notify_fail("Sorry, only the owner of the house can change the "
                       "locks on items in the house.\n");
  if(!function_exists("pick_lock", item))
    return notify_fail("Sorry, that object can't take a lock.\n");
  if(!item->query_unlocked())
    return notify_fail("Sorry, the item must be unlocked in order to change "
                       "its lock.\n");
  if(!lock->query_property("key prop")) {
    this_player()->add_failed_mess(this_object(),
      "$I doesn't appear to have a key.\n", ({ lock }));
    return 0;
  }
  if(!lock->query_property("difficulty")) {
    this_player()->add_failed_mess(this_object(),
      "$I doesn't appear to have a difficulty.\n", ({ lock }));
    return 0;
  }
  item->set_key(lock->query_property("key prop"));
  item->set_difficulty(lock->query_property("difficulty"));
  item->set_lock_owner(environment(this_player())->query_owner());
  item->set_trap_armed(0);
  if(function_exists("query_my_room", item)) {
    other = load_object(item->query_dest());
    other_id = item->query_other_id();
    other->modify_exit(other_id, ({ "key", lock->query_property("key prop")}));
    other->modify_exit(other_id, ({ "difficulty",
                                      lock->query_property("difficulty")}));
    other->modify_exit(other_id, ({ "lock owner",
                                      environment(this_player())->query_owner()
                                      }));
    environment(this_player())->update_doors();
    other->update_doors();
    environment(this_player())->do_save();
    other->do_save();
  }
  ob = clone_object("/std/object");
  ob->set_name("lock");
  ob->set_short("busted lock");
  ob->add_adjective("busted");
  ob->set_main_plural("busted locks");
  ob->set_long("A broken door lock.\n");
  ob->set_value(0);
  ob->set_weight(lock->query_weight());
  ob->move(environment());
  if(lock->move("/room/rubbish") != MOVE_OK)
    lock->dest_me();
  this_player()->add_succeeded_mess(this_object(),
                                    "$N remove$s the existing, and now "
                                    "broken, lock from $I and replace$s it "
                                    "with the new one.\n", ({ item }));
  return 1;
}
mixed query_static_auto_load() {
  if ( base_name(this_object()) + ".c" == __FILE__ )
    return int_query_static_auto_load();
  return ([ ]);
}

==================================================
FILE: misc/mailer_ob.c
==================================================

inherit "/std/object";
int do_mail(string str);
void setup() {
  set_name("mailer");
  set_short( "mailer object" );
  set_long("It is a small black box with pictures of small red demons "
           "painted on "+
           "the front.  Though, some of them look suspicously like frogs.\n");
  set_weight(1);
  reset_drop();
}
void init() {
  add_command("mail", "", (: do_mail(0) :) );
  add_command("mail", "<string>", (: do_mail($4[0]) :) );
}
int do_mail(string str) {
  return (int)"/obj/handlers/mail_track"->mail(str);
}

==================================================
FILE: misc/menu.c
==================================================

inherit "/std/object";
#include <language.h>
object our_pub;
void create() {
  ::create();
  set_name("menu");
  set_long("This is a menu.\n");
  reset_get();
}
void set_pub(object pub) {
  our_pub = pub;
  add_read_mess(our_pub->read(), "printed letters", our_pub->query_language());
}
object query_pub() { return our_pub; }
void init() {
  this_player()->add_command( "list", this_object(), "" );
}
string query_readable_message(object player) {
   string lang;
   string mess;
   mess = our_pub->read();
   lang = our_pub->query_language();
   mess = LANGUAGES->garble_text(lang, mess, this_object(), player);
   return mess;
}
int do_list() {
  write(query_readable_message(this_player()));
  add_succeeded_mess(({ "", "$N read$s $D.\n" }));
  return 1;
}

==================================================
FILE: misc/mortar_pestle.c
==================================================

inherit "/obj/misc/grinder";
void setup() {
  set_name( "pestle" );
  set_short( "mortar and pestle" );
  set_long( "Roughly hewn from stone, the mortar's bowl has been "
      "smoothed from long use.  The stone pestle used for grinding "
      "herbs within the bowl is smooth as well and hangs from a "
      "leather thong tied through a ring in the side of the bowl.\n" );
  set_main_plural( "mortars and pestles" );
  add_adjective( ({ "mortar and", "rough", "stone", "smooth" }) );
  add_alias( ({ "mortar", "pestle", "bowl" }) );
  set_value( 800 );
  set_weight( 44 );
  set_max_grindable( 8 );
  set_max_weight( 8 );
}

==================================================
FILE: misc/newspaper.c
==================================================

inherit "/std/book";
#include <room/newspaper.h>
#define AUTO_LOAD_TAG "newspaper"
private string _paper;
private int _edition;
void setup() {
  set_name("newspaper");
  set_short("newspaper");
  add_alias("paper");
  add_plural("papers");
  set_long("A bunch of nice newspapers.\n");
  set_main_plural("newspapers");
  set_weight(10);
  set_value(10);
  set_ignore_saved_pages(1);
}
int query_binding_force() {
  return 100;
}
void setup_paper() {
   class article* articles;
   class advert* adverts;
   class advert data;
   string* bits;
   int i;
   int j;
   string header;
   string index;
   string fluff;
   int page;
   mixed* stuff;
   object ob;
   if (_paper && _edition) {
      bits = explode(_paper, " ");
      if (bits[0] != "The") {
         set_short("copy of the " + _paper);
         add_adjective( ({ "the" }) );
         set_main_plural("copies of the " + _paper);
      } else {
         set_short("copy of " + _paper);
         set_main_plural("copies of " + _paper);
         add_plural_adjective("copies");
      }
      bits = map(bits, (: lower_case($1) :));
      add_adjective( ({ "copy", "of" }) );
      add_adjective(bits[0..<2]);
      add_alias(lower_case(bits[<1]));
      add_property("determinate", "a ");
      page = query_open_page();
      articles = NEWSPAPER_HANDLER->query_edition_articles(_paper, _edition);
      set_no_pages(sizeof(articles) + 1);
      index = "Edition #" + _edition + " of " + _paper + ".\n%^BOLD%^" +
              NEWSPAPER_HANDLER->query_paper_headline(_paper, _edition) +
              "%^RESET%^\n\n";
      index += sprintf("%2d .... %70-=s\n", 1, "Contents");
      for (i = 0; i < sizeof(articles); i++) {
         set_open_page(i + 2);
         ob = query_current_page();
         ob->set_value(0);
         if (articles[i]->colour) {
            index += "%^" + articles[i]->colour + "%^";
         }
         switch (articles[i]->type) {
         case NEWSPAPER_ARTICLE_TYPE_ADVERTS :
            header = "%^BOLD%^%^CYAN%^'Adverts'%^RESET%^\n\n";
            adverts = NEWSPAPER_HANDLER->query_edition_adverts(_paper, _edition);
            stuff = unique_array(adverts, (: $1->category :) );
            foreach (adverts in stuff) {
               header += "\n$I$0=" + adverts[0]->category + "\n$I$3=   ";
               foreach (data in adverts)  {
                  header += data->text + "\n-- " + data->author + "\n\n";
               }
            }
            index += sprintf("%2d .... %70-=s\n", i + 2, articles[i]->title);
            break;
         case NEWSPAPER_ARTICLE_TYPE_SECTION :
            header = "%^BOLD%^" + articles[i]->title + "'%^RESET%^\n\n";
            for (j = i + 1; j < sizeof(articles); j++) {
               if (articles[j]->type == NEWSPAPER_ARTICLE_TYPE_SECTION) {
                  break;
               }
               header += sprintf("%2d .... %70-=s\n", i + 2, articles[j]->title);
            }
            index += sprintf("%2d -=== %65|=s ===-\n", i + 2, articles[i]->title);
            break;
         case NEWSPAPER_ARTICLE_TYPE_HTML :
         case NEWSPAPER_ARTICLE_TYPE_PLAIN :
            header = "%^BOLD%^%^CYAN%^'" + articles[i]->title + "'%^RESET%^ at " +
                     ctime(articles[i]->date_written)[0..10] + "\n" +
                     "by " + articles[i]->shown_name;
            header += NEWSPAPER_HANDLER->query_article_text_plain(articles[i]);
            index += sprintf("%2d .... %70-=s\n", i + 2, articles[i]->title);
            break;
         }
         if (articles[i]->colour) {
            index += "%^RESET%^";
         }
         set_read_mess( header, NEWSPAPER_HANDLER->query_language_for( _paper ),
             0 );
      }
      set_open_page(1);
      set_read_mess( index, NEWSPAPER_HANDLER->query_language_for( _paper ), 0);
      ob = query_current_page();
      ob->set_value(0);
      fluff = NEWSPAPER_HANDLER->query_paper_long(_paper);
      if (fluff[<1] != '\n') {
         fluff += "\n";
      }
      set_long(fluff + "Edition " + _edition + " of " + _paper + ".\n");
      set_open_page(page);
   }
}
void set_paper(string paper) {
   _paper = paper;
   set_long(NEWSPAPER_HANDLER->query_paper_long(_paper));
   setup_paper();
}
void set_edition(int edition) {
   _edition = edition;
   setup_paper();
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   add_auto_load_value(map, AUTO_LOAD_TAG, "paper", _paper);
   add_auto_load_value(map, AUTO_LOAD_TAG, "edition", _edition);
   return map;
}
void init_dynamic_arg(mapping map, object player) {
   ::init_dynamic_arg(map);
   set_paper(query_auto_load_value(map, AUTO_LOAD_TAG, "paper"));
   set_edition(query_auto_load_value(map, AUTO_LOAD_TAG, "edition"));
}

==================================================
FILE: misc/newspaper_box.c
==================================================

inherit "/std/object";
#include <room/newspaper.h>
#include <money.h>
#include <move_failures.h>
private string _paper;
void setup() {
   set_name("box");
   set_short("newspaper box");
   add_adjective("box");
   add_help_file("newspaper_box");
   reset_get();
}
void set_paper(string paper) {
   int cost;
   string place;
   string* bits;
   _paper = paper;
   place = query_property("place");
   if (!place) {
      if (environment()) {
         place = environment()->query_property("place");
      } else if (previous_object()) {
         place = previous_object()->query_property("place");
      }
   }
   cost = NEWSPAPER_HANDLER->query_paper_cost(paper);
   set_short(_paper + " box");
   set_long("This is a battered looking metal box that is full of copies of " +
            (lower_case(paper)[0..3] == "the "?"":"the ") +
            paper + ".  There is a door on the front you could pull open "
            "beside which is small white writing saying " +
            MONEY_HAND->money_value_string(cost, place) + ".\n");
   if (lower_case(_paper)[0..3] == "the ") {
      add_property("determinate", "");
   }
   bits = explode(lower_case(_paper), " ");
   add_adjective(bits);
}
int do_buy() {
   int cost;
   int edition;
   string place;
   object ob;
   int *editions;
   place = query_property("place");
   if (!place) {
      place = environment()->query_property("place");
   }
   cost = NEWSPAPER_HANDLER->query_paper_cost(_paper);
   edition = NEWSPAPER_HANDLER->query_last_edition_num(_paper);
   if (!edition) {
      add_failed_mess("There is no edition to buy.\n");
      return -1;
   }
   if (this_player()->query_value_in(place) < cost) {
      add_failed_mess("You do not have enough money to pay for " +
                      _paper + ", you need " +
                      MONEY_HAND->money_value_string(cost, place) +
                      ".\n");
      return -1;
   }
   this_player()->pay_money(MONEY_HAND->create_money_array(cost, place), place);
   ob = clone_object("/obj/misc/newspaper");
   ob->set_paper(_paper);
   ob->set_edition(edition);
   if (ob->move(this_player()) != MOVE_OK) {
      ob->move(environment(this_player()));
      write("Unable to move the paper into your inventory, putting it on "
            "the ground.\n");
   }
   editions = this_player()->query_property("Paper " + _paper);
   if (!editions) {
      editions = ({ });
   }
   if (member_array(edition, editions) == -1) {
      editions += ({ edition });
      this_player()->add_property("Paper " + _paper, editions);
      NEWSPAPER_HANDLER->add_edition_paper_sold(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   } else {
      NEWSPAPER_HANDLER->add_edition_revenue(_paper, edition,
                        NEWSPAPER_HANDLER->query_paper_cost(_paper));
   }
   add_succeeded_mess("$N $V a paper from $D.\n");
   return 1;
}
void init() {
   add_command("buy", "paper from <direct:object>", (: do_buy() :));
   add_command("pull", "[door] [on] <direct:object>", (: do_buy() :));
   add_command("pull", "open <direct:object>", (: do_buy() :));
}

==================================================
FILE: misc/nroff_paper.c
==================================================

inherit "/obj/misc/paper";
#include "nroff.h"
private nosave mixed *stuff = ({ });
string file_name = 0;
string language = 0;
void create() {
  seteuid(getuid());
  ::create();
}
void set_file_name(string fname) {
  file_name = fname;
}
string query_file_name() { return file_name; }
void set_language(string lang) { language = lang; }
string query_language() { return language; }
mixed *query_read_mess() {
  string str;
  if(sizeof(stuff) == 0) {
    if (file_name) {
      str = unguarded( (: NROFF_HAND->cat_file(file_name+"_nroff", 1) :) );
      if (!str) {
        unguarded((: NROFF_HAND->create_nroff(file_name, file_name+"_nroff") :));
        str = unguarded( (: NROFF_HAND->cat_file(file_name+"_nroff", 1) :) );
      }
      if(!str)
        return ::query_read_mess() +
          ({ ({ "Unable to nroff file.\n", 0, "common", 0 }) });
      if( language ) {
         return stuff = ({ ({ str, 0, language, 0 }) });
      }
      return stuff = ({ ({ str, 0, "common", 0 }) });
    }
  }
  return stuff + ::query_read_mess();
}
mapping query_dynamic_auto_load() {
   mapping map;
   map = ::query_dynamic_auto_load();
   map["read mess"] = ::query_read_mess();
   return map;
}

==================================================
FILE: misc/paper.c
==================================================

#include <playtesters.h>
#define AUTO_LOAD_TAG "paper"
inherit "/std/object";
int do_uncrumple();
int do_crumple();
int do_eat();
private int _crumpled;
private string _old_short;
void create() {
   do_setup++;
   ::create();
   do_setup--;
   set_name( "paper" );
   set_short( "piece of writing paper" );
   add_adjective( ({ "piece of", "writing" }) );
   set_main_plural( "pieces of writing paper" );
   add_plural( "pieces of writing paper" );
   add_adjective(({ "piece", "pieces", "of", "writing" }));
   set_long( "This is a nice sheet of writing paper.\n" );
   set_value( 25 );
   set_weight( 0 );
   add_property( "writeable", 1 );
   add_property( "paper", 1 );
   set_max_size( 1000 );
   if ( !do_setup ) {
      this_object()->setup();
   }
}
void init() {
   if ( !this_player() ) {
       return;
   }
   add_command( "eat", "<direct:object>", (: do_eat :) );
   add_command( "crumple", "<direct:object>", (: do_crumple :) );
   add_command( "untangle", "<direct:object>", (: do_uncrumple :) );
   add_command( "uncrumple", "<direct:object>", (: do_uncrumple :) );
}
public int query_edible() {
    return 1;
}
public int query_paper() {
   return 1;
}
int do_crumple() {
   if (_crumpled) {
      add_failed_mess("$D is already crumpled.\n");
      return 0;
   }
   _old_short = query_short();
   call_out( (: set_short :), 1, "crumpled up " + query_short() );
   _crumpled = 1;
   return 1;
}
int do_uncrumple() {
    if (!_crumpled) {
        add_failed_mess("$D is already uncrumpled.\n");
        return 0;
    }
    call_out( (: set_short :), 1, _old_short );
   _crumpled = 0;
   return 1;
}
int do_eat() {
   string *flavours = ({ "red ink", "green ink", "black ink",
       "blue ink", "orange", "apple", "cinnamon", "banana",
       "monkey", "cabbage", "hat" });
   add_succeeded_mess( ({ "You open your mouth up widely and pop $D into "
      "your mouth.  After a moment's deliberation, you chew and consume "
      "$D.\n", "$N $V $D.\n" }) );
   call_out( (: tell_object( $1, $2 ) :), 1,
       this_player(), "Mmm! " +
       capitalize( flavours[random( sizeof( flavours ) ) ] ) +
       " flavoured!\n" );
   move( "/room/rubbish" );
   return 1;
}
string query_readable_message(object player, int ignore_labels) {
   if (!_crumpled) {
      return ::query_readable_message(player, ignore_labels);
   }
   return "Only bits of ink can be seen on the crumpled paper.\n";
}
string *parse_command_adjectiv_id_list() {
   if (_crumpled) {
      return ::parse_command_adjectiv_id_list() + ({ "crumpled", "up" });
   }
   return ::parse_command_adjectiv_id_list();
}
mapping query_dynamic_auto_load() {
    mapping map;
    map = ::query_dynamic_auto_load();
    add_auto_load_value( map, AUTO_LOAD_TAG, "crumpled", _crumpled );
    add_auto_load_value( map, AUTO_LOAD_TAG, "old short", _old_short );
    return map;
}
void init_dynamic_arg( mapping map, object ) {
    ::init_dynamic_arg(map);
    if (map) {
        _crumpled = query_auto_load_value( map, AUTO_LOAD_TAG, "crumpled" );
        _old_short = query_auto_load_value( map, AUTO_LOAD_TAG, "old short" );
        if ( map[ "paper - crumpled" ] ) {
            _crumpled = map[ "paper - crumpled" ];
        }
        if ( map[ "paper - short" ] ) {
            _old_short = map[ "paper - short" ];
        }
    }
}
mapping query_static_auto_load() {
   if ( explode( file_name( this_object() ), "#" )[ 0 ] != "/obj/misc/paper" )
      return ([ ]);
   return int_query_static_auto_load();
}

==================================================
FILE: misc/paper_packet.c
==================================================

inherit "/obj/baggage";
void setup() {
   set_name( "packet" );
   set_short( "waxed paper packet" );
   add_adjective( ({ "waxed", "paper" }) );
   set_main_plural( "waxed paper packets" );
   set_long( "This is a small packet, rather like an envelope, of thick "+
         "paper that has been waxed to make it more resilient.\n" );
   set_weight( 1 );
   set_value( 10 );
   set_max_weight( 3 );
   set_transparent();
   add_property("writeable", 1);
}
int test_add( object thing, int flag ) {
   string word;
   object *things;
   if ( !this_player() )
      return ::test_add( thing, flag );
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return ::test_add( thing, flag );
   word = (string)things[ 0 ]->query_medium_alias();
   if ( word == (string)thing->query_medium_alias() )
      return ::test_add( thing, flag );
   write( "You don't want to contaminate "+ ( stringp( word ) ?
         (string)things[ 0 ]->the_short() :
         (string)thing->the_short() ) +", do you?\n" );
   return 0;
}
object query_substance() {
   object *things;
   things = all_inventory( this_object() );
   if ( !sizeof( things ) )
      return 0;
   if ( !stringp( (string)things[ 0 ]->query_medium_alias() ) )
      return 0;
   return things[ 0 ];
}
string short( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::short( dark );
   return ::short( dark ) +" of "+ (string)thing->short( dark );
}
string query_plural( int dark ) {
   object thing = query_substance();
   if ( dark || !objectp( thing ) )
      return ::query_plural( dark );
   return ::query_plural( dark ) +" of "+ (string)thing->short( dark );
}
string *parse_command_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_id_list();
   return ::parse_command_id_list() +
         ({ ::short( 0 ) +" of "+ (string)thing->short( 0 ) });
}
string *parse_command_plural_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_plural_id_list();
   return ::parse_command_plural_id_list() +
         ({ ::query_plural( 0 ) +" of "+ (string)thing->short( 0 ) });
}
string *parse_command_adjectiv_id_list() {
   object thing = query_substance();
   if ( !objectp( thing ) )
      return ::parse_command_adjectiv_id_list();
   return ::parse_command_adjectiv_id_list() +
         (string *)thing->parse_command_adjectiv_id_list() +
         (string *)thing->parse_command_id_list();
}

==================================================
FILE: misc/pawn_receipt.c
==================================================

#include <am_time.h>
#include <armoury.h>
#include <money.h>
#include <move_failures.h>
#include <player.h>
#include <virtual.h>
#define TO this_object()
#define TP this_player()
inherit "/obj/misc/paper" ;
private int    _expired ;
private int    _expired_sold ;
private int    _expiry_time ;
private int    _item_value, _obplural ;
private int    _timestamp;
private mixed  _static_save;
private string _obname, _obpath, _obshort ;
private string _shop_path, _virt_name ;
object do_kiss();
void setup() {
    set_name( "receipt" );
    set_short( "pawned item receipt" ) ;
    add_adjective( ({ "pawned", "item" }) );
    set_long( "This is a small slip of paper, with a black border.\n" );
    set_main_plural( "pawned item receipts" ) ;
    add_plural( "receipts" );
    add_adjective( "pawned" ) ;
    set_value( 0 ) ;
    set_weight( 1 );
    _obname = "unknown object";
    _obpath = "***";
    _timestamp = time();
}
void init() {
    add_command( "reclaim", "<direct:object:me'receipt'>" ) ;
}
void reset() {
    object item ;
    if ( ( ! _expired ) && time() > _expiry_time ) {
        _expired = 1 ;
        set_short( "expired pawned item receipt" ) ;
        add_adjective( "expired" ) ;
        if ( ! _expired_sold ) {
            _expired_sold = 1 ;
            item = do_kiss() ;
            if ( item ) {
                item->move( _shop_path->query_store_room() ) ;
            }
        }
    }
}
void set_obshort( string s ) {
  _obshort = s;
}
string query_obshort() {
  return _obshort;
}
void set_expiry_time( int time ) {
    _expiry_time = time ;
}
int query_expiry_time() {
    return _expiry_time ;
}
void set_item_value( int value ) {
    _item_value = value ;
}
int query_item_value() {
    return _item_value ;
}
void set_shop_path( mixed shop ) {
    if ( objectp( shop ) ) {
        _shop_path = base_name( shop ) ;
        return ;
    }
    _shop_path = shop ;
    return ;
}
string query_shop_path() {
    return _shop_path ;
}
void set_obname( string name ) {
    _obname = name;
}
void set_object( string path ) {
    _obpath = path;
}
void set_virtobname( string name ) {
    _virt_name = name;
}
string query_obname() {
    return _obname;
}
string query_obpath() {
    return _obpath;
}
int query_timestamp() {
    return _timestamp;
}
string query_virt_obname() {
    return _virt_name;
}
mixed query_static_save() {
  return _static_save;
}
int query_pawned_item_receipt() {
    return 1 ;
}
void set_static_save( mixed args ) {
  mixed p;
  _static_save = args;
  if (_obname != "unknown object") {
    return;
  }
  p = args[0];
  while (mapp(p)) {
    if (!undefinedp(p["short"])) {
      _obname = p["short"];
      return;
    }
    p = p["::"];
  }
}
void set_object_plural( object ob ) {
  if ( ob->query_collective() && ob->query_amount() > 1 ) {
    _obplural = 1;
  } else {
    _obplural = 0;
  }
}
int query_object_plural() {
  return _obplural;
}
string query_correct_short( object ob ) {
    if ( ! ob ) {
      return 0;
    }
    set_object_plural( ob );
    if ( _obplural ) {
      return pluralize( ob->query_short() );
    }
    return ob->query_short();
}
void setup_receipt( object ob ) {
   mixed* bits;
   bits = AUTO_LOAD_OB->fragile_auto_str_ob(ob);
   set_obname(ob->query_name());
   set_obshort( query_correct_short( ob ) );
   set_object(bits[1]);
   set_static_save(bits[2]);
}
string pluralize_sentence( string text, int plural ) {
  if ( plural ) {
    return replace( text, ({
      "$o", "them",
      "$r", "they",
      "$ve", "ve"
    }) );
  }
  return replace( text, ({
    "$o", "it",
    "$r", "it",
    "$ve", "s"
  }) );
}
string query_details() {
    if ( _expired ) {
        return pluralize_sentence(
          "This is a receipt for your pawned " + query_obshort() + ".\n"
          "Sadly, you have left it too long to collect $o and $r ha$ve "
          "expired, so the shop will put $o up for sale.  Better hurry to "
          + _shop_path->the_short() + " sharpish and try to buy $o back!",
          _obplural );
    }
    return pluralize_sentence(
      "This is a receipt for your pawned " + query_obshort() + ".\n"
      "You must reclaim $o from " + _shop_path->the_short() + " before "
      + AM_TIME_HANDLER->query_am_time( _expiry_time ) + " or $r will "
      "be sold.", _obplural );
}
mixed *query_read_mess() {
  string lang;
  if ( _shop_path ) {
    lang = _shop_path->query_language();
  } else {
    lang = "general";
  }
  return ::query_read_mess()
    + ({ ({ (: query_details() :), "neat printing", lang, 0 }) });
}
mapping query_dynamic_auto_load()
{
   return ([
     "::"         : ::query_dynamic_auto_load(),
     "obname"     : _obname,
     "obpath"     : _obpath,
     "obvalue"    : value,
     "virt"       : _virt_name,
     "timestamp"  : _timestamp,
     "static"     : _static_save,
     "been sold"  : _expired_sold,
     "expired"    : _expired,
     "expires on" : _expiry_time,
     "item value" : _item_value,
     "item short" : _obshort,
     "item plural": _obplural,
     "shop path"  : _shop_path
  ]);
}
void init_dynamic_arg(mapping arg, object) {
   _obname = arg["obname"];
   if ( stringp( _obname ) ) {
       add_adjective( explode( lower_case( _obname ), " " ) );
   }
   _obpath = arg["obpath"];
   set_value(arg["obvalue"]);
   _virt_name = arg["virt"];
   _timestamp = arg["timestamp"];
   _static_save = arg["static"];
   _expired = arg["expired"] ;
   _expired_sold = arg["been sold"] ;
   _expiry_time = arg["expires on"] ;
   _item_value = arg["item value"] ;
   _obshort = arg["item short"];
   _obplural = arg["item plural"];
   _shop_path = arg["shop path"] ;
   ::init_dynamic_arg(arg["::"]);
   if ( _expired ) {
       set_short( "expired pawned item receipt" ) ;
       add_adjective( "expired" ) ;
       set_main_plural( "expired pawned item receipts" ) ;
       add_plural( "pawned item receipts" ) ;
   }
}
mixed *stats() {
  mixed *stuff;
  stuff = ::stats() + ({
      ({ "obname", _obname }),
      ({ "obpath", _obpath }),
      ({ "timestamp", _timestamp + " (" + ctime(_timestamp) + ")" }),
      ({ "been sold", _expired_sold }),
      ({ "expired", _expired }),
      ({ "expires on", _expiry_time }),
      ({ "item short", _obshort }),
      ({ "item value", _item_value }),
      ({ "item plural", _obplural }),
      ({ "shop path", _shop_path })
   });
  if (_virt_name)
    stuff += ({ ({ "virtname", _virt_name }) });
  return stuff;
}
object do_kiss() {
    object thing;
    if (sizeof(_static_save) < 2) {
        if (this_player()->query_creator()) {
            write("This receipt has no auto-load information, possibly "
                  "because the object was broken when the player logged "
                  "out.  It will have to be replaced by hand.\n");
        } else {
            write("Sorry, but this object is too broken to repair "
                  "with a kiss.  You'll have to contact a creator.\n");
        }
        return 0;
    }
    if (_virt_name) {
       _virt_name = CLONER->other_file( _virt_name );
       if (file_size(_virt_name) <= 0) {
          _virt_name = ARMOURY->remap_file_path(_virt_name);
       }
       if (file_size(_virt_name) <= 0) {
           write("The receipt whispers: Sorry, I'm still broken.  "
                 "Try again some other time, or contact a creator.\n");
           return 0;
       }
    }
    if ( !catch( thing = (object)CLONER->clone( _obpath ) ) ) {
        if ( thing ) {
            thing->init_static_arg(_static_save[0]);
            thing->init_dynamic_arg(_static_save[1]);
            thing->add_property(VIRTUAL_NAME_PROP, _virt_name);
            move("/room/rubbish");
            return thing;
        } else {
            write("The receipt whispers: I'm going to need some "
                  "creator help.\n");
            thing->dest_me();
        }
    } else {
         write("The receipt whispers: Sorry, I'm still broken.  "
               "Try again some other time, or contact a creator.\n");
    }
    return 0;
}
int do_reclaim() {
    int cost, i ;
    object change, item ;
    string change_str, place ;
    if ( ! query_pawned_item_receipt() ) {
        add_failed_mess( "$D is not a pawned item receipt.\n" ) ;
        return 0 ;
    }
    if ( base_name( environment( TP ) ) != _shop_path ) {
        add_failed_mess(
            "This is not the right place for you to reclaim $D.  "
            "Try a pawn shop.\n" ) ;
        return 0 ;
    }
    if ( ! environment( TP )->is_open( TP, 0 ) ) {
        return 0;
    }
    if ( _expired ) {
        add_failed_mess( "Oh dear, your receipt has expired.  With luck, your "
            + query_obshort() + " will be available for sale in the shop.\n" ) ;
        return 0 ;
    }
    place = query_property( "place" ) ;
    if ( ! place || ( place == "" ) ) {
        place = "default" ;
    }
    cost = ( ( 100 + _shop_path->query_pawn_markup() ) * _item_value ) / 100 ;
    debug_printf( "cost = %d, _item_value = %d, markup = %d",
        cost, _item_value, _shop_path->query_pawn_markup() ) ;
    if ( TP->query_value_in( place ) < cost ) {
        add_failed_mess( "You don't have enough money to reclaim $D.  "
            "It would cost you "
            + MONEY_HAND->money_value_string( cost, place ) + "\n" ) ;
        return 0 ;
    }
    change = MONEY_HAND->pay_amount_from( cost, TP, place ) ;
    if ( change ) {
        change->move( TP ) ;
        change_str = change->short() ;
    }
    item = do_kiss();
    if ( ! item ) {
        add_failed_mess(
          "Oh dear, your item doesn't seem to be here any more.  "
          "Please contact a liaison.\n" );
        return 0;
    }
    i = item->move( TP );
    if ( i != MOVE_OK ) {
        tell_object( TP, "You're too heavily burdened to accept "
          + item->the_short() + ", so it is placed on the floor for you.\n" );
        item->move( environment(TP) );
    }
    add_succeeded_mess( ({
        "$N $V " + item->the_short() + " for "
          + MONEY_HAND->money_value_string( cost, place )
          + ( change_str ? " and receive " + change_str + " in change" : "" )
          + ".\n",
        "$N $V $D and receives " + item->the_short() + " in exchange.\n"
    }) ) ;
    return 1 ;
}

==================================================
FILE: misc/perfume_bottle.c
==================================================

#include <move_failures.h>
inherit "/std/object";
inherit "/std/basic/holdable";
int squirts;
string glass, scent, scent_plural;
void create() {
   object::create();
   holdable::create();
}
void setup() {
   set_name( "bottle" );
   set_short( "perfume bottle" );
   add_adjective( "perfume" );
   set_value( 4000 );
   set_weight( 2 );
   squirts = 12;
}
void set_glass( string word ) {
   set_short( word +" perfume bottle" );
   add_adjective( word );
   set_main_plural( word +" perfume bottles" );
   glass = word;
}
void set_scent( string words ) { scent = words; }
void set_scent_plural( string words ) { scent_plural = words; }
string long( string word, int dark ) {
   string words;
   words = "This is a perfume bottle made out of "+ glass +" crystal.  "+
         "It is ";
   switch( squirts ) {
      case 0 :
         return words +"empty.\n";
      case 1 .. 3 :
         words += "about a quarter full";
         break;
      case 4 .. 6 :
         words += "about half full";
         break;
      case 7 .. 9 :
         words += "about three-quarters full";
         break;
      default :
         words += "almost full";
   }
   words += " of "+ scent +" perfume which can be sprayed onto "+
         "someone.\n";
   return words;
}
void init() {
   this_player()->add_command( "spray", this_object(), "<direct:object> at <indirect:object>" );
}
int do_spray( object *things ) {
  if ( query_wielded() != this_player() ) {
    this_player()->add_failed_mess( this_object(), "You must be holding "+
        "$D to use it.\n", ({ }) );
    return 0;
  }
  if ( sizeof( things ) > 1 ) {
    this_player()->add_failed_mess( this_object(), "You can only spray $D "+
        "at one person at a time.\n", ({ }) );
    return 0;
  }
  if ( things[ 0 ] == this_object() ) {
    this_player()->add_failed_mess( this_object(), "You cannot spray $D at "+
        "itself!\n", ({ }) );
    return 0;
  }
  if ( !living( things[ 0 ] ) ) {
    this_player()->add_failed_mess( this_object(), "SI would probably not "+
        "benefit from being sprayed.\n", ({ things[ 0 ] }) );
    return 0;
  }
  if ( !squirts ) {
    this_player()->add_failed_mess( this_object(), "There is no perfume in "+
        "$D to spray at $I.\n", ({ things[ 0 ] }) );
    return 0;
  }
  squirts--;
  things[ 0 ]->add_effect( "/std/effects/other/perfume", ({ 300, scent,
      scent_plural }) );
  this_player()->add_succeeded( things[ 0 ] );
  return 1;
}
mapping query_dynamic_auto_load() {
  return ([
    "::" : ::query_dynamic_auto_load(),
    "squirts" : squirts
  ]);
}
mapping query_static_auto_load() {
  if ( explode( file_name( this_object() ), "#" )[ 0 ] !=
      "/obj/misc/perfume_bottle" )
    return 0;
  return ([
    "::" : int_query_static_auto_load(),
    "glass" : glass,
    "scent" : scent,
    "scent_plural" : scent_plural
  ]);
}
void init_dynamic_arg( mapping map ) {
  if ( map[ "::" ] )
    ::init_dynamic_arg( map[ "::" ] );
  squirts = map[ "squirts" ];
}
void init_static_arg( mapping map ) {
  if ( map[ "::" ] )
    ::init_static_arg( map[ "::" ] );
  if ( map[ "glass" ] )
    set_glass( map[ "glass" ] );
  if ( map[ "scent" ] )
    scent = map[ "scent" ];
  if ( map[ "scent_plural" ] )
    scent_plural = map[ "scent_plural" ];
}
void dest_me() {
   holdable::dest_me();
   object::dest_me();
}
varargs int move( mixed ob, string mess1, string mess2 ) {
   int ret;
   ret = holdable::move(ob);
   if (ret != MOVE_OK) {
      return ret;
   }
   return object::move( ob, mess1, mess2 );
}

==================================================
FILE: misc/plate.c
==================================================

inherit "/std/surface";
void init() {
  this_player()->add_command( "eat", this_object(),
    "<indirect:object:direct-obs> {from|on} <direct:object:me>" );
  this_player()->add_command( "eat", this_object(),
    "from <direct:object:me>" );
}
void create() {
  do_setup++;
  ::create();
  do_setup--;
  set_long( "This is a nice plate for keeping food on.\n" );
  if ( ! do_setup ) {
    this_object()->setup();
    this_object()->reset();
  }
}
int do_eat( object *obs, string dir, string indir, mixed *args ) {
  object ob;
  object *food;
  if( sizeof( obs ) )
    food = copy( obs );
  else
    food = all_inventory();
  if( sizeof( food ) ) {
    food = filter( food, (: $1->query_edible() :) );
  } else {
    this_player()->add_failed_mess( this_object(),
      "There's nothing on $D\n", ({ }) );
    return 0;
  }
  if( !sizeof( food ) ) {
    if( sizeof( obs ) )
      this_player()->add_failed_mess( this_object(),
        "You can't eat $I on $D!\n", obs );
    else
      this_player()->add_failed_mess( this_object(),
        "There's nothing edible on $D\n", ({ }) );
    return 0;
  }
  foreach( ob in food ) {
    ob->do_eat();
  }
  return 1;
}
mapping query_static_auto_load() {
  return int_query_static_auto_load();
}

==================================================
FILE: misc/present.c
==================================================

#include <move_failures.h>
#define PAPER_LONG "This is a lovely big piece of " + _colour + " " + _type + " paper.  It looks like it could be used to wrap up something as a present.  Try \"wrap <objects> in paper\".\n"
#define PRESENT_LONG "This lovely piece of " + _colour + " paper has been used to wrap up something as a present.  Try \"unwrap\".\n"
inherit "/obj/baggage";
int do_wrap( object *things );
int do_unwrap();
private int wrapped;
private string _colour;
private string _type;
void setup() {
   set_name( "wrappingpaper" );
   set_short( "piece of wrapping paper" );
   add_alias( "paper" );
   add_adjective( ({ "piece of", "wrapping" }) );
   set_main_plural( "pieces of wrapping paper" );
   add_plural( ({ "pieces of wrapping paper", "pieces of paper",
                  "papers" }) );
   set_long( PAPER_LONG );
   set_weight( 2 );
   set_max_weight( 225 );
   set_value( 600 );
   set_stuck(1);
   add_property( "writeable", 1 );
   add_property( "paper", 1);
}
void set_colour( string word ) {
   if( _colour ) {
      return;
   }
   _colour = word;
   if (!_colour) {
      return;
   }
   set_short( "piece of " + _colour + " " + _type + " paper" );
   add_adjective( explode( _colour, " " ) );
   set_main_plural( "pieces of " + _colour + " " + _type + " paper" );
   set_long( PAPER_LONG );
}
void set_type( string word ) {
   if( _type ) {
      return;
   }
   _type = word;
   if (!_type) {
      return;
   }
   set_short( "piece of " + _colour + " " + _type + " paper" );
   add_adjective( explode( _type, " " ) );
   set_main_plural( "pieces of " + _colour + " " + _type + " paper" );
   set_long( PAPER_LONG );
}
#ifdef MY_TEST_FUNC
int test_remove( object thing, int flag ) {
   if( ( query_verb() == "get" ) || ( query_verb() == "take" ) ) {
      return !wrapped;
   }
   return 1;
}
int test_add( object thing, int flag ) {
   if( ( query_verb() == "put" ) || ( query_verb() == "give" ) ) {
      return 0;
   }
   return 1;
}
#endif
void init() {
   add_command( "wrap", "<indirect:object:me> in <direct:object'present'>" );
   add_command( "unwrap", "<direct:object:'present'>", (: do_unwrap :) );
   add_command( "open", "<direct:object:'present'>", (: do_unwrap :) );
}
int do_wrap( object *things ) {
   object *valid, *failed;
   things -= ({ this_object() });
   if( wrapped ) {
      add_failed_mess( "The paper has already been used to wrap something.\n" );
      return 0;
   }
   if( !( sizeof( things ) ) ) {
      add_failed_mess( "You must wrap something!\n" );
      return 0;
   }
   valid = filter( things, (: !living( $1 ) &&
                              $1->move( this_object() ) == MOVE_OK :) );
   failed = things - valid;
   if( sizeof( failed ) ) {
      tell_object( this_player(), "You could not wrap " +
         query_multiple_short( failed ) + " in " + the_short() + ".\n" );
   }
   if( sizeof( valid ) ) {
      wrapped = 1;
      remove_alias( "paper" );
      remove_adjective( "piece of" );
      remove_adjective( "wrapping" );
      remove_plural( "pieces of wrapping paper" );
      remove_plural( "pieces of paper" );
      remove_plural( "papers" );
      call_out( "set_short", 1, _colour + " present" );
      add_alias( "present" );
      set_main_plural( _colour + " presents" );
      add_plural( "presents" );
      set_long( PRESENT_LONG );
      add_succeeded_mess( "$N $V $I in $D.\n", valid );
   } else {
      add_succeeded_mess( "" );
   }
   return 1;
}
int do_unwrap() {
   int i;
   object *things;
   if( !wrapped ) {
      write( "There is nothing wrapped in the paper.\n" );
      return 0;
   }
   wrapped = 0;
   things = all_inventory();
   write( "You open the present and find "+ query_multiple_short( things ) +
      " inside.\n" );
   for( i = 0; i < sizeof( things ); i++ ) {
      if( things[ i ]->move( environment() ) ) {
         if( environment( environment() ) ) {
            things[ i ]->move( environment( environment() ) );
            write( "The " + things[ i ]->short() + " falls onto the " +
               "floor as you unwrap the present.\n" );
         }
      }
   }
   remove_alias( "present" );
   remove_plural( "presents" );
   call_out( "set_short", 1, "piece of " + _colour + " " + _type + " paper" );
   add_alias( "paper" );
   add_adjective( ({ "piece of", "wrapping" }) );
   set_main_plural( "pieces of " + _colour + " " + _type + " paper" );
   add_plural( ({ "pieces of " + _type + " paper", "pieces of paper",
                  "papers" }) );
   set_long( PAPER_LONG );
   add_succeeded_mess("$N unwrap$s $D.\n");
   return 1;
}
mixed *stats() {
    return ::stats() + ({
      ({ "colour", _colour }),
      ({ "type", _type }),
      ({ "wrapped", wrapped }),
    });
}
mapping query_static_auto_load() {
    return ([
      "colour": _colour,
      "type": _type,
      "::": ::int_query_static_auto_load(),
    ]);
}
void init_static_arg( mapping args ) {
    _colour = args[ "colour" ];
    ::init_static_arg( args[ "::" ] );
}
mapping query_dynamic_auto_load() {
    return ([
      "colour": _colour,
      "type": _type,
      "wrapped": wrapped,
      "::": ::query_dynamic_auto_load(),
    ]);
}
void init_dynamic_arg( mapping args ) {
    _colour = args[ "colour"  ];
    _type   = args[ "type"    ];
    wrapped = args[ "wrapped" ];
    ::init_dynamic_arg( args[ "::" ] );
    if(!_colour) {
        _colour = "plain";
    }
    if(!_type) {
        _type = "wrapping";
    }
}
int query_closed() {
    return 1;
}
string long_status() {
    return "";
}

==================================================
FILE: misc/press_credentials.c
==================================================

inherit "/obj/clothing";
private string _owner = "someone";
private string _paper;
void set_owner_stuff();
void update_stuff();
void setup() {
   add_property("press credentials",1);
   set_name( "badge" );
   set_short( "press credentials badge" );
   add_adjective( ({ "press", "credentials" }) );
   add_alias( "badge" );
   add_property( "nosteal", 1 );
   add_alias( "credentials" );
   set_type( "badge" );
   setup_clothing( 1000 );
   set_weight( 1 );
   reset_drop();
   set_wear_remove_func(base_name(this_object()), "wear_badge");
}
void init() {
   if( _owner == "someone" ) {
      update_stuff();
   }
   if( this_player()->query_name() == lower_case(_owner) ) {
      add_command( "show", "<direct:object:me'credentials'>");
   }
}
void wear_badge(object ob, object player) {
   if (!ob) {
      if (player) {
         player->remove_title("newspaper");
      }
   } else if (_paper) {
      player->set_title("newspaper", "Reporter for " + _paper);
   }
}
void set_owner_stuff() {
   set_long( "This is a small badge with a hand-drawn picture of " +
     _owner + " on it, underneath the logo of " + _paper + ".  "
     "Emblazoned along the bottom are the words \"Official Reporter\".\n");
   if (query_worn_by()) {
      query_worn_by()->set_title("newspaper", "Reporter for " + _paper);
   }
}
int do_show() {
   add_succeeded_mess( ({ "With a practiced flick of your wrist, you display "
     "your press credentials to the room.\n", "With a practiced flick of $p "
     "wrist, $N whips out $p press credentials for " + _paper +
     " and shows them to "
     "everybody.\n" }) );
   return 1;
}
void set_paper_name(string paper) {
   _paper = paper;
}
string query_paper_name() {
   return _paper;
}
void update_stuff() {
   object ob;
   ob = environment();
   if( ob && living( ob ) ) {
      _owner = ob->query_cap_name();
   }
   set_owner_stuff();
}
mapping query_dynamic_auto_load() {
   return ([
     "::" : ::query_dynamic_auto_load(),
     "cred owner" : _owner,
     "paper" : _paper
   ]);
}
void init_dynamic_arg( mapping map ) {
   _paper = map["paper"];
   _owner = map["cred owner"];
   ::init_dynamic_arg( map[ "::" ] );
   set_owner_stuff();
}

==================================================
FILE: misc/quest_info_utils.c
==================================================

#include <library.h>
string _quest_name;
void set_quest_name(string quest_name)
{
   _quest_name = quest_name;
}
void set_quest_param(mixed player, string key, mixed value)
{
   mixed info;
   if (!stringp(player))
      player = player->query_name();
   info = LIBRARY->query_player_quest_info(player, _quest_name);
   if (!mapp(info))
      info = ([ ]);
   info[key] = value;
   LIBRARY->set_player_quest_info(player, _quest_name, info);
}
mixed query_quest_param(mixed player, string key)
{
   mixed info;
   if (!stringp(player))
      player = player->query_name();
   info = LIBRARY->query_player_quest_info(player, _quest_name);
   if (!mapp(info))
      return 0;
   return info[key];
}
void clear_quest_info(mixed player)
{
   if (!stringp(player))
      player = player->query_name();
   LIBRARY->set_player_quest_info(player, _quest_name, 0);
}
