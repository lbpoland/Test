# Total Tokens: 15588
# Total Files Merged: 5
# Total Characters: 51974

rld_map.c
==================================================

#include <terrain_map.h>
class region {
   mixed* terrains;
   string* features;
   int last_touched;
}
#define SAVE_DIR "/save/world_map/"
#define BOUNDARY TERRAIN_MAP_WORLD_BOUNDARY
#define REGION_SIZE TERRAIN_MAP_WORLD_REGION_SIZE
#define REGION_BOUNDARY TERRAIN_MAP_WORLD_REGION_BOUNDARY
#define OFFSET TERRAIN_MAP_WORLD_OFFSET
#define REGION_WIDTH TERRAIN_MAP_WORLD_REGION_WIDTH
void load_me();
private void generate_main_templates();
private void generate_blocking_templates();
private nosave mixed* _regions;
private nosave mixed* _templates;
private nosave mixed* _blocking_templates;
void create() {
   _regions = allocate(REGION_WIDTH, (: allocate(REGION_WIDTH) :));
   seteuid(getuid());
   generate_main_templates();
   generate_blocking_templates();
}
private void generate_main_templates() {
   int size;
   mixed* last;
   int x;
   int y;
   int u;
   int v;
   int e;
   int i;
   _templates = allocate(12);
   last = ({ ({ 1 }) });
   for (size = 0; size < sizeof(_templates); size++) {
      for (i = 0; i < sizeof(last); i++) {
         last[i] = ({ 0 }) + last[i] + ({ 0 });
      }
      _templates[size] = ({ allocate((size + 1) * 2 + 1) }) + last +
                         ({ allocate((size + 1) * 2 + 1) });
      x = 0;
      y = size + 1;
      u = 1;
      v = 2 * (size + 1) - 1;
      e = 0;
      while (x <= y) {
         _templates[size][size + 1 + x][size + 1 + y] = 1;
         _templates[size][size + 1 + x][size + 1 - y] = 1;
         _templates[size][size + 1 - x][size + 1 + y] = 1;
         _templates[size][size + 1 - x][size + 1 - y] = 1;
         _templates[size][size + 1 + y][size + 1 + x] = 1;
         _templates[size][size + 1 + y][size + 1 - x] = 1;
         _templates[size][size + 1 - y][size + 1 + x] = 1;
         _templates[size][size + 1 - y][size + 1 - x] = 1;
         if (size > 0) {
            _templates[size][size + 1 + x - 1][size + 1 + y] = 1;
            _templates[size][size + 1 + x - 1][size + 1 - y] = 1;
            _templates[size][size + 1 - x + 1][size + 1 + y] = 1;
            _templates[size][size + 1 - x + 1][size + 1 - y] = 1;
            _templates[size][size + 1 + y - 1][size + 1 + x] = 1;
            _templates[size][size + 1 + y - 1][size + 1 - x] = 1;
            _templates[size][size + 1 - y + 1][size + 1 + x] = 1;
            _templates[size][size + 1 - y + 1][size + 1 - x] = 1;
         }
         x++;
         e += u;
         u += 2;
         if (v < 2 * e) {
            y--;
            e -= v;
            v -= 2;
         }
         if (x > y) {
            break;
         }
      }
      last = copy(_templates[size]);
   }
}
mixed* generate_blocking(int x, int y, string* start,
                          string* straight, string* diagonal) {
   int i;
   int dx;
   int ex;
   int dy;
   int balance;
   int sx;
   int sy;
   int blocked;
   int blocked_straight;
   int blocked_diagonal;
   int first_block;
   first_block = -1;
   for (i = 0; i <= sizeof(start); i++) {
      sx = 0;
      sy = 0;
      ex = sizeof(start);
      dx = sizeof(start);
      dy = i;
      dy <<= 1;
      balance = dy - dx;
      dx <<= 1;
      blocked_straight = blocked_diagonal = blocked = 0;
      while (sx != ex) {
         if (blocked) {
            if (first_block == -1) {
               first_block = i;
            }
            start[sy] = start[sy][0..sx-1] + "*" + start[sy][sx+1..];
         } else {
            start[sy] = start[sy][0..sx-1] + " " + start[sy][sx+1..];
         }
         if (blocked_straight) {
            straight[sy] = straight[sy][0..sx-1] + "*" + straight[sy][sx+1..];
         } else {
            straight[sy] = straight[sy][0..sx-1] + " " + straight[sy][sx+1..];
         }
         if (blocked_diagonal) {
            diagonal[sy] = diagonal[sy][0..sx-1] + "*" + diagonal[sy][sx+1..];
         } else {
            diagonal[sy] = diagonal[sy][0..sx-1] + " " + diagonal[sy][sx+1..];
         }
         if (sx == x && sy == y) {
            blocked_diagonal = blocked_straight = blocked = 1;
            diagonal[sy] = diagonal[sy][0..sx-1] + "@" + diagonal[sy][sx+1..];
            start[sy] = start[sy][0..sx-1] + "@" + start[sy][sx+1..];
            straight[sy] = straight[sy][0..sx-1] + "@" + straight[sy][sx+1..];
         }
         if (sx == x && sy == y + 1) {
            blocked_straight = 1;
            straight[sy] = straight[sy][0..sx-1] + "|" + straight[sy][sx+1..];
         }
         if (sx == x + 1 && sy == y + 1) {
            blocked_diagonal = 1;
            diagonal[sy] = diagonal[sy][0..sx-1] + "\\" + diagonal[sy][sx+1..];
         }
         if (balance >= 0) {
            sy++;
            balance -= dx;
         }
         balance += dy;
         sx++;
      }
   }
   if (first_block >= (sizeof(start) / 2)) {
      for (i = sizeof(start); i >= 6; i--) {
         sx = 0;
         sy = 0;
         ex = sizeof(start);
         dx = sizeof(start);
         dy = i;
         dy <<= 1;
         balance = dy - dx;
         dx <<= 1;
         blocked = 0;
         while (sx != ex) {
            start[sy] = start[sy][0..sx-1] + " " + start[sy][sx+1..];
            if (sx == x && sy == y) {
               break;
            }
            if (balance >= 0) {
               sy++;
               balance -= dx;
            }
            balance += dy;
            sx++;
         }
      }
   }
   return ({ start, straight, diagonal });
}
private void generate_blocking_templates() {
   int x;
   int y;
   int size;
   mixed* basic;
   string* start;
   string line;
   basic = _templates[<1];
   size = sizeof(_templates);
   line = "";
   for (x = 0; x < size + 1; x++) {
      line += " ";
   }
   start = allocate(size + 1, line);
   _blocking_templates = allocate(size + 1, ({ }));
   for (x = 0; x < size + 1; x++) {
      _blocking_templates[x] = allocate(size + 1);
   }
   for (x = 0; x < size + 1; x++) {
      for (y = x; y < size + 1; y++) {
         if (basic[x + size][y + size] && (x != 0 || y != 0)) {
            _blocking_templates[x][y] = generate_blocking(y, x, copy(start), copy(start), copy(start));
         }
      }
   }
}
string *query_blocking_template(int x, int y, int type) {
   if (arrayp(_blocking_templates[x][y])) {
      return copy(_blocking_templates[x][y][type]);
   }
   return 0;
}
mixed* query_map_template(int size) {
   return copy(_templates[size - 1]);
}
void load_region(int x, int y) {
   class region region;
   string fname;
   if (_regions[x][y]) {
      _regions[x][y]->last_touched = time();
      return ;
   }
   fname = SAVE_DIR + "region_" + x + "_" + y;
   if (unguarded((: file_size($(fname)) :)) > 0) {
      region = unguarded( (: restore_variable(read_file($(fname), 1)) :));
   } else {
      region = new(class region,
                   terrains : allocate(REGION_SIZE, (: allocate(REGION_SIZE) :)),
                   features : ({ }));
   }
   _regions[x][y] = region;
   _regions[x][y]->last_touched = time();
}
void save_region(int x, int y) {
   string fname;
   class region region;
   if (_regions[x][y]) {
      region = _regions[x][y];
      fname = SAVE_DIR + "region_" + x + "_" + y;
      unguarded( (: write_file($(fname), save_variable($(region)), 1) :));
   }
}
int add_terrain(string path, int x1, int y1, int x2, int y2) {
   int tmp;
   int region_x;
   int region_y;
   if (x1 > x2) {
      tmp = x1;
      x1 = x2;
      x2 = tmp;
   }
   if (y1 > y2) {
      tmp = y1;
      y1 = y2;
      y2 = tmp;
   }
   if (x2 - x1 != BOUNDARY ||
       y2 - y1 != BOUNDARY) {
      debug_printf("Incorrect terrain size (%d x %d): %s\n",
                  x2 - x1, y2 - y1, path);
      return 0;
   }
   if (x1 % BOUNDARY ||
       y1 % BOUNDARY) {
      debug_printf("Incorrect boundary (%d - %d): %s\n",
                  x1 % BOUNDARY, y1 % BOUNDARY, path);
      return 0;
   }
   x1 = ((x1 + OFFSET) / BOUNDARY);
   y1 = ((y1 + OFFSET) / BOUNDARY);
   region_x = x1 / REGION_SIZE;
   region_y = y1 / REGION_SIZE;
   load_region(region_x, region_y);
   x2 = x1 % REGION_SIZE;
   y2 = y1 % REGION_SIZE;
   _regions[region_x][region_y]->terrains[x2][y2] = path;
   save_region(region_x, region_y);
   debug_printf("Added terrain (%d {%d}, %d {%d}) [%d,  %d]: %s\n",
                 x1, x2, y1, y2, region_x, region_y, path);
   return 1;
}
string find_terrain_at(int x, int y) {
   int region_x;
   int region_y;
   x = ((x + OFFSET) / BOUNDARY);
   y = ((y + OFFSET) / BOUNDARY);
   region_x = x / REGION_SIZE;
   region_y = y / REGION_SIZE;
   load_region(region_x, region_y);
   return _regions[region_x][region_y]->terrains[x % REGION_SIZE][y % REGION_SIZE];
}
string find_room_at(int x, int y) {
   string path;
   path = find_terrain_at(x, y);
   if (path) {
      return path->find_room_at_real_coord(x, y);
   }
   return 0;
}
void add_feature(string feature) {
   int x;
   int y;
   for (x = 0; x < REGION_WIDTH; x++) {
      for (y = 0; y < REGION_WIDTH; y++) {
         if (feature->is_inside_region(
                                (x * REGION_WIDTH) * BOUNDARY - OFFSET,
                                (y * REGION_WIDTH) * BOUNDARY - OFFSET,
                                ((x + 1) * REGION_WIDTH) * BOUNDARY - OFFSET,
                                ((y + 1) * REGION_WIDTH) * BOUNDARY - OFFSET)) {
            load_region(x, y);
            _regions[x][y]->features |= ({ feature });
            save_region(x, y);
            debug_printf("Added feature to region %d, %d\n", x, y);
         }
      }
   }
}
void remove_feature(string feature) {
   int x;
   int y;
   for (x = 0; x < REGION_WIDTH; x++) {
      for (y = 0; y < REGION_WIDTH; y++) {
         load_region(x, y);
         if (member_array(feature, _regions[x][y]->features) != -1) {
            _regions[x][y]->features -= ({ feature });
            save_region(x, y);
         }
      }
   }
}
string* query_features_at(int x, int y) {
   int region_x;
   int region_y;
   x = ((x + OFFSET) / BOUNDARY);
   y = ((y + OFFSET) / BOUNDARY);
   region_x = x / REGION_WIDTH;
   region_y = y / REGION_WIDTH;
   load_region(region_x, region_y);
   return _regions[region_x][region_y]->features;
}
string* query_features_in_region(int x1_orig, int y1_orig, int x2_orig, int y2_orig) {
   int region_x;
   int region_y;
   int x1;
   int y1;
   int x2;
   int y2;
   int tmp;
   string* features;
   string feat;
   x1 = ((x1_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   y1 = ((y1_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   x2 = ((x2_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   y2 = ((y2_orig + OFFSET) / BOUNDARY) / REGION_WIDTH;
   if (x1 > x2) {
      tmp = x1;
      x1 = x2;
      x2 = tmp;
   }
   if (y1 > y2) {
      tmp = y1;
      y1 = y2;
      y2 = tmp;
   }
   features = ({ });
   if (x1 < 0) {
      x1 = 0;
   }
   if (y1 < 0) {
      y1 = 0;
   }
   if (x2 >= REGION_WIDTH) {
      x2 = REGION_WIDTH - 1;
   }
   if (y2 >= REGION_WIDTH) {
      y2 = REGION_WIDTH - 1;
   }
   for (region_x = x1; region_x <= x2; region_x++) {
      for (region_y = y1; region_y <= y2; region_y++) {
         load_region(region_x, region_y);
         foreach (feat in _regions[region_x][region_y]->features) {
            if (feat->is_inside_region(x1_orig, y1_orig, x2_orig, y2_orig)) {
               features |= ({ feat });
            }
         }
      }
   }
   return features;
}

==================================================
FILE: handlers/inherit/case_control.c
==================================================

#define NOMIC_SYSTEM_NO_CLASSES
#define NOMIC_SYSTEM_CASE_CLASSES
#include <nomic_system.h>
private mapping _open_cases;
private mapping _recently_closed_cases;
private mapping _closed_cases;
private int _next_case_id;
private int _next_note_id;
void save_me();
void send_council_inform(string area, int only_magistrates,
                         string mess);
void create() {
   _open_cases = ([ ]);
   _closed_cases = ([ ]);
   _recently_closed_cases = ([ ]);
   _next_case_id = 1;
   _next_note_id = 1;
}
void create_area(string area) {
   if (_open_cases[area]) {
      return ;
   }
   _open_cases[area] = ({ });
   _closed_cases[area] = ({ });
   _recently_closed_cases[area] = ({ });
}
int* query_open_cases(string area) {
   return _open_cases[area];
}
int* query_closed_cases(string area) {
   return _closed_cases[area];
}
int* query_recently_closed_cases(string area) {
   return _recently_closed_cases[area];
}
string query_case_file_name(int id) {
   return NOMIC_CASE_SAVE + sprintf("cases/%02d/%d_case", id % 20, id);
}
int query_next_case_id() {
   int next;
   do {
      next = _next_case_id++;
   } while (sizeof(stat(query_case_file_name(next))));
   return next;
}
private void save_case(class nomic_case stuff) {
   string fname;
   string tmp;
   fname = query_case_file_name(stuff->id);
   tmp = save_variable(stuff);
   unguarded((: write_file($(fname), $(tmp), 1) :));
}
string query_note_file_name(int id) {
   return NOMIC_CASE_SAVE + sprintf("notes/%02d/%d_note", id % 20, id);
}
int query_next_note_id() {
   int next;
   do {
      next = _next_note_id++;
   } while (sizeof(stat(query_note_file_name(next))));
   return next;
}
private void save_note(class nomic_case_note stuff) {
   string fname;
   string tmp;
   fname = query_note_file_name(stuff->id);
   tmp = save_variable(stuff);
   unguarded((: write_file($(fname), $(tmp) ) :));
}
private int create_case(string opener, string short, string* people) {
   class nomic_case new_case;
   new_case = new(class nomic_case);
   new_case->id = query_next_case_id();
   new_case->opener = opener;
   new_case->short = short;
   new_case->people = people;
   new_case->notes = ({ });
   new_case->events = ({ });
   new_case->time_opened = time();
   save_case(new_case);
   return new_case->id;
}
private int create_note(string person, string text) {
   class nomic_case_note new_note;
   new_note = new(class nomic_case_note);
   new_note->id = query_next_note_id();
   new_note->person = person;
   new_note->text = text;
   new_note->time_created = time();
   save_note(new_note);
   return new_note->id;
}
private class nomic_case_event create_event(int type, string person,
                                            string mess, mixed data) {
   class nomic_case_event event;
   event = new(class nomic_case_event);
   event->type = type;
   event->mess = mess;
   event->person = person;
   event->event_time = time();
   event->data = data;
   return event;
}
string query_event_name(int type) {
   switch (type) {
   case NOMIC_CASE_EVENT_CLOSE :
      return "closed case";
   case NOMIC_CASE_EVENT_APPEAL :
      return "appealed case";
   case NOMIC_CASE_EVENT_ADD_PERSON :
      return "add person";
   case NOMIC_CASE_EVENT_REMOVE_PERSON :
      return "remove person";
   default :
      return "unknown";
   }
}
class nomic_case query_open_case(string area, int id) {
   string fname;
   string tmp;
   if (!_open_cases[area]) {
      return 0;
   }
   if (member_array(id, _open_cases[area]) == -1) {
      return 0;
   }
   fname = query_case_file_name(id);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
class nomic_case query_recently_closed_case(string area, int id) {
   string fname;
   string tmp;
   if (!_recently_closed_cases[area]) {
      return 0;
   }
   if (member_array(id, _recently_closed_cases[area]) == -1) {
      return 0;
   }
   fname = query_case_file_name(id);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
class nomic_case query_closed_case(string area, int id) {
   string fname;
   string tmp;
   if (!_closed_cases[area]) {
      return 0;
   }
   if (member_array(id, _closed_cases[area]) == -1) {
      return 0;
   }
   fname = query_case_file_name(id);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
class nomic_case_note query_note(int note_num) {
   string fname;
   string tmp;
   fname = query_note_file_name(note_num);
   tmp = unguarded((: read_file($(fname)) :));
   if (tmp) {
      return restore_variable(tmp);
   }
   return 0;
}
int add_new_case(string area, string opener, string short, string* people) {
   int case_id;
   if (!_open_cases[area]) {
      return 0;
   }
   case_id = create_case(opener, short, people);
   _open_cases[area] += ({ case_id });
   save_me();
   send_council_inform(area, 1, opener + " opened a case with " +
                      query_multiple_short(people));
   return case_id;
}
int close_case(string area, int id, string closer, string result,
               mixed data) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_open_case(area, id);
   if (!the_case || !stringp(result)) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_CLOSE, closer, result, data);
   the_case->events += ({ event });
   save_case(the_case);
   _open_cases[area] -= ({ the_case->id });
   _recently_closed_cases[area] += ({ the_case->id });
   save_me();
   send_council_inform(area, 1, closer + " closed a case with " +
                      query_multiple_short(the_case->people));
   return 1;
}
int appeal_case(string area, int id, string appealer, string reason) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_recently_closed_case(area, id);
   if (!the_case || !stringp(reason)) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_APPEAL, appealer, reason, 0);
   the_case->events += ({ event });
   save_case(the_case);
   _recently_closed_cases[area] -= ({ the_case->id });
   _open_cases[area] += ({ the_case->id });
   save_me();
   send_council_inform(area, 1, appealer + " appeals a case with " +
                      query_multiple_short(the_case->people));
   return 1;
}
int add_note_to_case(string area, int id, string person, string text) {
   class nomic_case the_case;
   int note_id;
   the_case = query_open_case(area, id);
   if (!the_case) {
      return 0;
   }
   note_id = create_note(person, text);
   the_case->notes += ({ note_id });
   save_case(the_case);
   save_me();
   return 1;
}
int add_person_to_case(string area, int id, string adder,
                       string person, string text) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_open_case(area, id);
   if (!the_case || !stringp(text) ||
       member_array(person, the_case->people) != -1) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_ADD_PERSON, adder, text, 0);
   the_case->events += ({ event });
   the_case->people += ({ person });
   save_case(the_case);
   return 1;
}
int remove_person_from_case(string area, int id, string remover,
                       string person, string text) {
   class nomic_case the_case;
   class nomic_case_event event;
   the_case = query_open_case(area, id);
   if (!the_case || !stringp(text) ||
       member_array(person, the_case->people) == -1) {
      return 0;
   }
   event = create_event(NOMIC_CASE_EVENT_REMOVE_PERSON, remover, text, 0);
   the_case->events += ({ event });
   the_case->people -= ({ person });
   save_case(the_case);
   return 1;
}
void update_recently_closed_cases() {
   string area;
   int* stuff;
   int id;
   class nomic_case the_case;
   class nomic_case_event event;
   int last_close;
   foreach (area, stuff in _recently_closed_cases) {
      foreach (id in stuff) {
         the_case = query_recently_closed_case(area, id);
         last_close = 0;
         foreach (event in the_case->events) {
            if (event->type == NOMIC_CASE_EVENT_CLOSE) {
               last_close = event->event_time;
            }
         }
         if (last_close < time() - NOMIC_CASE_APPEAL_TIME) {
            _closed_cases[area] += ({ id });
            _recently_closed_cases[area] -= ({ id });
         }
      }
   }
}

==================================================
FILE: handlers/inherit/citizen_elections.c
==================================================

inherit "/obj/handlers/inherit/citizens";
#include <player_handler.h>
#include <player.h>
#include <board.h>
#define NOMIC_SYSTEM_NO_CLASSES
#include <nomic_system.h>
#define CITIZEN_ELECTION_PHASE_NONE       0
#define CITIZEN_ELECTION_PHASE_NOMINATION 1
#define CITIZEN_ELECTION_PHASE_ELECTION   2
#define CITIZEN_ELECTION_PHASE_GRACE      3
#define CITIZEN_ELECTION_PHASE_DISABLED 4
#define CITIZEN_ELECTION_TIME   (20 * (7 * 24 * 60 * 60))
#define CITIZEN_ELECTION_PHASE_TIME      (10 * 24 * 60 * 60)
#define CITIZEN_PHASE_TIME      (14 * 24 * 60 * 60)
#define CITIZEN_GRACE_TIME      (14 * 24 * 60 * 60)
#define CITIZEN_ELECTION_DISABLED_TIME (14 * 24 * 60 * 60)
class election_data {
   int last_election;
   int phase;
   int phase_start;
   mapping nominations;
   mapping votes;
   string* voted;
}
protected void finish_election_phase(string area);
int post_citizen_message(string area, string subject, string message);
private mapping _elections;
private mapping _boards;
void create() {
   _elections = ([ ]);
   _boards = ([ ]);
   citizens::create();
   call_out("do_next_event", 10);
}
void create_area(string area) {
   _elections[area] = new(class election_data);
   _elections[area]->phase = CITIZEN_ELECTION_PHASE_GRACE;
   _elections[area]->phase_start = time();
   _elections[area]->nominations = ([ ]);
   _elections[area]->votes = ([ ]);
   _elections[area]->voted = ({ });
   ::create_area(area);
}
int query_next_election_time(string area) {
   if (!_elections[area]) {
      return 0;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_GRACE) {
      return _elections[area]->phase_start + CITIZEN_GRACE_TIME;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NONE) {
      return _elections[area]->last_election + CITIZEN_ELECTION_TIME;
   }
   return 0;
}
int query_end_of_phase_time(string area) {
   if (!_elections[area]) {
      return 0;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NONE) {
      return 0;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      return _elections[area]->phase_start + CITIZEN_ELECTION_PHASE_TIME;
   }
   return _elections[area]->phase_start + CITIZEN_PHASE_TIME;
}
protected int query_election_phase(string area) {
   if (!_elections[area]) {
      return CITIZEN_ELECTION_PHASE_NONE;
   }
   return _elections[area]->phase;
}
int is_nomination_phase(string area) {
   return query_election_phase(area) == CITIZEN_ELECTION_PHASE_NOMINATION;
}
int is_election_phase(string area) {
   return query_election_phase(area) == CITIZEN_ELECTION_PHASE_ELECTION;
}
int is_grace_phase(string area) {
   return query_election_phase(area) == CITIZEN_ELECTION_PHASE_GRACE;
}
int nominate_magistrate(string area, string person, string nominator) {
   if (!_elections[area] ||
       !is_citizen_of(area, person) ||
       !is_citizen_of(area, nominator)) {
      return 0;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NOMINATION) {
      if (!_elections[area]->nominations[person]) {
         _elections[area]->nominations[person] = ({ });
      } else if (member_array(nominator,
                              _elections[area]->nominations[person]) != -1) {
         return 0;
      }
      _elections[area]->nominations[person] += ({ nominator });
      save_me();
      return 1;
   }
   return 0;
}
string* query_nominated_by(string area, string person) {
   if (!_elections[area]) {
      return ({ });
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NOMINATION) {
      if (_elections[area]->nominations[person]) {
         return copy(_elections[area]->nominations[person]);
      }
   }
   return ({ });
}
string* query_people_nominated(string area) {
   if (!_elections[area]) {
      return ({ });
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NOMINATION) {
      return keys(_elections[area]->nominations);
   }
   return ({ });
}
int is_nomination_accepted(string area, string person) {
   string* nominations;
   nominations = query_nominated_by(area, person);
   if (sizeof(nominations) >= 2 &&
       member_array(person, nominations) != -1) {
      return 1;
   }
   return 0;
}
int has_voted(string area, string person) {
   if (!_elections[area]) {
      return 0;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      return member_array(person, _elections[area]->voted) != -1;
   }
   return 0;
}
int is_eligible_to_vote_for(string area, string person) {
   if (!_elections[area]) {
      return 0;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      return member_array(person, keys(_elections[area]->votes)) != -1;
   }
   return 0;
}
int vote_for_people(string area, string* people, string voter) {
   string person;
   if (!_elections[area] ||
       !is_citizen_of(area, voter)) {
      return 0;
   }
   foreach (person in people) {
      if (!is_citizen_of(area, person)) {
         return 0;
      }
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      if (has_voted(area, voter)) {
         return 0;
      }
      foreach (person in people) {
         if (is_eligible_to_vote_for(area, person)) {
            _elections[area]->votes[person]++;
         }
      }
      _elections[area]->voted += ({ voter });
      save_me();
      return 1;
   }
   return 0;
}
string* query_can_vote_for(string area) {
   if (!_elections[area]) {
      return ({ });
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      return keys(_elections[area]->votes);
   }
   return ({ });
}
protected void start_election(string area) {
   if (!_elections[area]) {
      return ;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NONE ||
       _elections[area]->phase == CITIZEN_ELECTION_PHASE_GRACE) {
      _elections[area]->votes = ([ ]);
      _elections[area]->voted = ({ });
      _elections[area]->nominations = ([ ]);
      _elections[area]->phase_start = time();
      _elections[area]->phase = CITIZEN_ELECTION_PHASE_NOMINATION;
      save_me();
      post_citizen_message(area, "Nomination phase has started.",
                           "Please go to your council offices and "
                           "nominate\nthe magistrates for office.\n");
   }
}
protected void finish_nomination_phase(string area) {
   string person;
   string* nominators;
   if (!_elections[area]) {
      return ;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_NOMINATION) {
      _elections[area]->votes = ([ ]);
      _elections[area]->voted = ({ });
      foreach (person, nominators in _elections[area]->nominations) {
         if (is_citizen_of(area, person) &&
             is_nomination_accepted(area, person) &&
             !PLAYER_HANDLER->test_creator(person)) {
            _elections[area]->votes[person] = 0;
         }
      }
      _elections[area]->phase = CITIZEN_ELECTION_PHASE_ELECTION;
      _elections[area]->phase_start = time();
      _elections[area]->nominations = ([ ]);
      save_me();
      post_citizen_message(area, "Nomination phase finished.",
                           "The people nominated for election are:\n" +
                           implode(map(keys(_elections[area]->votes),
                                       (: "   " + $1 :)), "\n"));
      if (sizeof(keys(_elections[area]->votes)) <=
          query_number_of_magistrates(area)) {
          finish_election_phase(area);
      }
   }
}
protected void finish_election_phase(string area) {
   string* voted;
   string* sorted_voted;
   string high_pk;
   string high_non_pk;
   string person;
   string results;
   int needed;
   int num;
   if (!_elections[area]) {
      return ;
   }
   if (_elections[area]->phase == CITIZEN_ELECTION_PHASE_ELECTION) {
      if (sizeof(keys(_elections[area]->votes)) <=
          query_number_of_magistrates(area)) {
         voted = sort_array(keys(_elections[area]->votes),
                            (: $3[$2] - $3[$1] :), _elections[area]->votes);
         sorted_voted = voted;
      } else {
         voted = sort_array(keys(_elections[area]->votes),
                            (: $3[$2] - $3[$1] :), _elections[area]->votes);
         sorted_voted = voted;
         needed = query_number_of_magistrates(area);
         foreach (person in voted) {
            if (PLAYER_HANDLER->test_player_killer(person)) {
               if (!high_pk) {
                  needed--;
                  high_pk = person;
               }
            } else {
               if (!high_non_pk) {
                  needed--;
                  high_non_pk = person;
               }
            }
            if (high_pk && high_non_pk) {
               break;
            }
         }
         voted -= ({ high_pk, high_non_pk });
         voted = voted[0..needed - 1];
         voted += ({ high_pk, high_non_pk });
         voted -= ({ 0 });
      }
      results = "Votes:\n";
      foreach (person in sorted_voted) {
         results += sprintf("%20s %d\n", capitalize(person),
                            _elections[area]->votes[person]);
      }
      results += "\nElected officals are " + query_multiple_short(voted) + "\n";
      results += "\nNumber of people who voted " +
                 sizeof(_elections[area]->voted);
      num = query_number_of_citizens(area);
      if (num == 0) {
         results += " (100% of the citizens)\n";
      } else {
         results += " (" + (sizeof(_elections[area]->voted) * 100 / num) +
                    "% of the citizens)\n";
      }
      _elections[area]->votes = ([ ]);
      _elections[area]->voted = ({ });
      _elections[area]->phase = CITIZEN_ELECTION_PHASE_NONE;
      _elections[area]->phase_start = time();
      _elections[area]->last_election = time();
      _elections[area]->nominations = ([ ]);
      post_citizen_message(area, "Election results", results);
      setup_magistrates(area, voted);
      save_me();
   }
}
protected void do_next_event() {
   int next_event;
   int time_to_next_event;
   string area;
   class election_data data;
   foreach (area, data in _elections) {
      switch (data->phase) {
      case CITIZEN_ELECTION_PHASE_NONE :
         next_event = (data->last_election - time()) + CITIZEN_ELECTION_TIME;
         if (next_event <= 0) {
            start_election(area);
         }
         break;
      case CITIZEN_ELECTION_PHASE_NOMINATION :
         next_event = (data->phase_start - time()) + CITIZEN_PHASE_TIME;
         if (next_event <= 0) {
            finish_nomination_phase(area);
         }
         break;
      case CITIZEN_ELECTION_PHASE_ELECTION :
         next_event = (data->phase_start - time()) + CITIZEN_ELECTION_PHASE_TIME;
         if (next_event <= 0) {
            finish_election_phase(area);
         }
         break;
      case CITIZEN_ELECTION_PHASE_GRACE :
         next_event = (data->phase_start - time()) + CITIZEN_GRACE_TIME;
         if (next_event <= 0) {
            start_election(area);
         }
         break;
      case CITIZEN_ELECTION_PHASE_DISABLED :
         next_event = (data->phase_start - time()) +
            CITIZEN_ELECTION_DISABLED_TIME;
         if (next_event <= 0) {
             next_event = next_event;
         }
         break;
      }
      if (next_event > 0 &&
          (next_event < time_to_next_event || !time_to_next_event)) {
         time_to_next_event = next_event;
      }
   }
   if(time_to_next_event) {
     call_out("do_next_event", time_to_next_event);
   }
}
void set_citizen_board(string area, string name) {
   if (!pointerp(_boards[area])) {
      _boards[area] = ({ 0, 0 });
   }
   _boards[area][0] = name;
   save_me();
}
string query_magistrate_board(string area) {
   if (pointerp(_boards[area])) {
      return _boards[area][1];
   }
   return 0;
}
void set_magistrate_board(string area, string name) {
   if (!pointerp(_boards[area])) {
      _boards[area] = ({ 0, 0 });
   }
   _boards[area][1] = name;
   save_me();
}
string query_citizen_board(string area) {
   if (pointerp(_boards[area])) {
      return _boards[area][0];
   }
   return 0;
}
int post_citizen_message(string area, string subject, string message) {
   string board;
   board = query_citizen_board(area);
   if (board) {
      return BOARD_HAND->add_message(board,
                           NOMIC_SYSTEM_ADMINISTRATOR_NAME,
                           subject,
                           message);
   }
   return 0;
}
int post_magistrate_message(string area, string subject, string message) {
   string board;
   board = query_magistrate_board(area);
   if (board) {
      return BOARD_HAND->add_message(board,
                           NOMIC_SYSTEM_ADMINISTRATOR_NAME,
                           subject,
                           message);
   }
   return 0;
}
int disable_citizen_election(string area) {
    if (!_elections[area]) {
      return 0;
    }
   _elections[area]->phase = CITIZEN_ELECTION_PHASE_DISABLED;
   _elections[area]->phase_start = time();
   _elections[area]->nominations = ([ ]);
   _elections[area]->votes = ([ ]);
   _elections[area]->voted = ({ });
   save_me();
   return 1;
}

==================================================
FILE: handlers/inherit/citizens.c
==================================================

#include <player_handler.h>
#include <playtesters.h>
#include <player.h>
private mapping _magistrates;
private mapping _citizens;
int is_citizen_of(string area, string citizen);
void save_me();
void create() {
   _citizens = ([ ]);
   _magistrates = ([ ]);
}
int create_area(string area, int num_magistrates) {
   _citizens[area] = ({ });
   _magistrates[area] = allocate(num_magistrates);
   save_me();
}
string* query_citizenship_areas() {
   return keys(_citizens);
}
int remove_citizen(string area, string citizen) {
   int pos;
   if (!_citizens[area]) {
      return 0;
   }
   if (member_array(citizen, _citizens[area]) != -1) {
      _citizens[area] -= ({ citizen });
      if (citizen) {
         pos = member_array(citizen, _magistrates[area]);
         if (pos != -1) {
            _magistrates[area][pos] = 0;
         }
      }
      save_me();
      return 1;
   }
   return 0;
}
int add_magistrate(string area, string magistrate) {
   int pos;
   if (!is_citizen_of(area, magistrate)) {
      return 0;
   }
   pos = member_array(0, _magistrates[area]);
   if (pos == -1) {
      return 0;
   }
   _magistrates[area][pos] = magistrate;
   save_me();
   PLAYER_TITLE_HANDLER->add_title_to_player(magistrate, "magistrate");
   return 1;
}
protected void setup_magistrates(string area, string* magistrates) {
   int i;
   int num;
   string magistrate;
   if (!_magistrates[area]) {
      return ;
   }
   for (i = 0; i < sizeof(_magistrates[area]); i++) {
      _magistrates[area][i] = 0;
   }
   num = sizeof(_magistrates[area]);
   if (num <= sizeof(magistrates)) {
      magistrates = magistrates[0..num];
   } else {
      magistrates += allocate(num - sizeof(magistrates));
   }
   _magistrates[area] = magistrates;
   save_me();
   foreach (magistrate in magistrates) {
      PLAYER_TITLE_HANDLER->add_title_to_player(magistrate, "magistrate");
   }
}
int query_number_of_magistrates(string area) {
   if (!_magistrates[area]) {
      return 0;
   }
   return sizeof(_magistrates[area]);
}
string* query_magistrates(string area) {
   if (!_magistrates[area]) {
      return ({ });
   }
   return _magistrates[area] - ({ 0 });
}
int add_citizen(string area, string citizen) {
   if (!PLAYER_HANDLER->test_user(citizen)) {
      return 0;
   }
   if (!_citizens[area]) {
      return 0;
   }
   _citizens[area] += ({ citizen });
   save_me();
   return 1;
}
int is_citizen_of(string area, string citizen) {
   if (!_citizens[area]) {
      return 0;
   }
   if (master()->query_lord(citizen)) {
      return 1;
   }
   return member_array(citizen, _citizens[area]) != -1;
}
int is_magistrate_of(string area, string magistrate) {
   if (!_magistrates[area]) {
      return 0;
   }
   if (master()->query_lord(magistrate)) {
      return 1;
   }
   return member_array(magistrate, _magistrates[area]) != -1;
}
string query_citizen(string citizen) {
   string bing;
   foreach (bing in query_citizenship_areas()) {
      if (is_citizen_of(bing, citizen)) {
         return bing;
      }
   }
   return 0;
}
int is_magistrate_anywhere(string person) {
   string bing;
   foreach (bing in query_citizenship_areas()) {
      if (is_magistrate_of(bing, person)) {
         return 1;
      }
   }
   return 0;
}
int query_number_of_citizens(string area) {
   return sizeof(_citizens[area]);
}

==================================================
FILE: handlers/inherit/club_basic.c
==================================================

#include <clubs.h>
#include <broadcaster.h>
#include <player_handler.h>
class club_info {
   string actual_name;
   string founder;
   string *recruiters;
   string *members;
   int type;
   mapping accounts;
   int last_paid;
   int last_touched;
   mixed extra_data;
   string description;
   string region;
}
#define CLUB_CACHE_SIZE 20
private mapping _club_names;
private string *_observers;
private nosave int _no_cache_hits;
private nosave int _no_cache_requests;
private nosave int _no_cache_miss;
private nosave int _cache_call_out;
private nosave mapping _cache;
private nosave string *_cache_order;
#define SAVE_FILE_NAME "/save/clubs"
#define SAVE_FILE_DIR "/save/clubs/"
protected void save_club(string name);
protected void load_main();
protected void save_main();
int is_club(string club_name);
int remove_recruiter(string name, string recruiter);
int is_recruiter_of(string name, string recruiter);
int query_club_type(string name);
void check_extra_information(string club_name, string member, int login);
int is_family(string name);
int disband_club(string name);
protected void set_club_changed(string name);
protected void send_broadcast_message(string club,
                                      string message);
protected void send_observer_event(string event_name,
                                   string *args ...);
void create() {
    seteuid(master()->creator_file(file_name()));
   _club_names = ([ ]);
   _cache = ([ ]);
   _cache_order = ({ });
   _observers = ({ });
   load_main();
}
string query_cap_name() {
   return "Club controller";
}
protected void load_main() {
   unguarded( (: restore_object(SAVE_FILE_NAME, 1) :) );
}
protected void save_main() {
   unguarded( (: save_object(SAVE_FILE_NAME, 1) :) );
}
string normalise_name(string name) {
   return replace_string(lower_case(name), " ", "_");
}
private void fixup_cache() {
   int i;
   if (sizeof(_cache_order) > CLUB_CACHE_SIZE) {
      for (i = sizeof(_cache_order) - CLUB_CACHE_SIZE; i >= 0; i--) {
         if (_club_names[_cache_order[i]]) {
            save_club(_cache_order[i]);
         }
         map_delete(_cache, _cache_order[i]);
      }
      _cache_order = _cache_order[sizeof(_cache_order) - CLUB_CACHE_SIZE + 1..];
   }
}
protected class club_info query_club_info(string name) {
   class club_info bing;
   name = normalise_name(name);
   _no_cache_requests++;
   if (_cache[name]) {
      _no_cache_hits++;
      return _cache[name];
   }
   if (unguarded( (: file_size(SAVE_FILE_DIR + $(name)) :)) > 0) {
      _cache[name] = unguarded( (: restore_variable(read_file(SAVE_FILE_DIR +
                                                              $(name))) :) );
      _cache_order += ({ name });
      if (intp(_cache[name]->accounts)) {
         _cache[name]->accounts = ([ CLUB_DEFAULT_ACCOUNT_NAME : _cache[name]->accounts ]);
      }
      if (sizeof(_cache[name]) == 10) {
         bing = new(class club_info);
         bing->actual_name = _cache[name]->actual_name;
         bing->founder = _cache[name]->founder;
         bing->recruiters = _cache[name]->recruiters;
         bing->members = _cache[name]->members;
         bing->type = _cache[name]->type;
         bing->accounts = _cache[name]->accounts;
         bing->last_paid = _cache[name]->last_paid;
         bing->last_touched = _cache[name]->last_touched;
         bing->extra_data = _cache[name]->extra_data;
         bing->description = _cache[name]->description;
         bing->region = "Ankh-Morpork";
         _cache[name] = bing;
         set_club_changed(name);
      }
      fixup_cache();
      return _cache[name];
   }
   _no_cache_miss++;
   return 0;
}
protected void save_club(string name) {
   name = normalise_name(name);
   if (_cache[name]) {
      _club_names[name] = 0;
      unguarded( (: write_file(SAVE_FILE_DIR + $(name),
                               save_variable(_cache[$(name)]),
                               1) :) );
   }
}
protected void save_cache() {
   string name;
   class club_info data;
   foreach (name, data in _cache) {
      if (_club_names[name]) {
         save_club(name);
      }
   }
}
protected void set_club_changed(string name) {
   name = normalise_name(name);
   if (!undefinedp(_club_names[name])) {
      if (find_call_out(_cache_call_out) == -1) {
         _cache_call_out = call_out((: save_cache :), 0);
      }
      _club_names[name] = 1;
   }
}
private void add_club(string name,
                      class club_info data) {
   name = normalise_name(name);
   _cache[name] = data;
   _club_names[name] = 0;
   set_club_changed(name);
}
string the_short() {
   return "Club Control";
}
protected void create_extra_data(string name) {
   class club_info data;
   data = query_club_info(name);
   data->extra_data = 0;
   set_club_changed(name);
}
int create_club(string name, string founder, int type, string region) {
   class club_info info;
   if (!stringp(name) || !stringp(founder)) {
      return 0;
   }
   info = new(class club_info);
   info->actual_name = name;
   if (type != CLUB_FAMILY) {
      info->recruiters = ({ founder });
      info->members = ({ founder });
   } else {
      info->recruiters = ({ });
      info->members = ({ });
   }
   info->founder = founder;
   info->last_touched = time();
   info->type = type;
   info->last_paid = time();
   info->description = 0;
   info->accounts = ([ CLUB_DEFAULT_ACCOUNT_NAME : 0 ]);
   info->region = region;
   add_club(name, info);
   create_extra_data(name);
   set_club_changed(name);
   add_club(name, info);
   save_main();
   return 1;
}
int change_club_type(string name,
                     int type) {
   int club_type;
   class club_info info;
   if (is_club(name)) {
      club_type = query_club_type(name);
      info = query_club_info(name);
      if (club_type != type) {
         info->type = (club_type & CLUB_FLAGS_MASK) | type;
         set_club_changed(name);
         create_extra_data(name);
         return 1;
      }
   }
   return 0;
}
int query_club_type(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      if (!data) {
         disband_club(name);
      } else {
         return data->type & CLUB_TYPE_MASK;
      }
   }
}
int set_club_secret(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      data->type |= CLUB_SECRET_FLAG;
      set_club_changed(name);
      return 1;
   }
   return 0;
}
int reset_club_secret(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      data->type &= ~CLUB_SECRET_FLAG;
      set_club_changed(name);
      return 1;
   }
   return 0;
}
int query_club_secret(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      return (data->type & CLUB_SECRET_FLAG) != 0;
   }
}
string query_club_region(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      return data->region;
   }
   return 0;
}
int disband_club(string name) {
   class club_info data;
   name = normalise_name(name);
   if (is_club(name)) {
      data = query_club_info(name);
      if (data) {
         log_file("CLUB", ctime(time()) + ": disbanded '" +
                       this_object()->query_club_name(name) + "'; balance = " +
                       this_object()->query_balance(name, CLUB_DEFAULT_ACCOUNT_NAME) + "; fees due = " +
                       ctime(this_object()->query_time_fees_due(name)) +
                       "\n");
      } else {
         log_file("CLUB", ctime(time()) + " disbanded '" + name + "' "
                          "which has a bad data file.\n");
      }
      map_delete(_club_names, name);
      map_delete(_cache, name);
      unguarded( (: rm(SAVE_FILE_DIR + $(name)) :) );
      save_main();
      send_observer_event("club_event_disband_club", name);
      return 1;
   }
   return 0;
}
string *query_clubs() {
   return keys(_club_names);
}
string query_insignia_path(string name) {
   return "/obj/misc/club_badge";
}
void touch_club(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      data->last_touched = time();
      set_club_changed(name);
   }
}
string *query_recruiters(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      return data->recruiters;
   }
   return ({ });
}
string query_founder(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      return data->founder;
   }
   return 0;
}
string *query_members(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      return data->members;
   }
   return ({ });
}
int add_recruiter(string name, string recruiter) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      if (member_array(recruiter, data->members) != -1 &&
          member_array(recruiter, data->recruiters) == -1) {
         data->recruiters += ({ recruiter });
         set_club_changed(name);
         touch_club(name);
         if (!is_family(name)) {
            send_broadcast_message(name,
                                   capitalize(recruiter) +
                                   " becomes a recruiter for the club.");
         }
         return 1;
      }
   }
   return 0;
}
int add_member(string name, string member) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      if (member_array(member, data->members) == -1) {
         data->members += ({ member });
         set_club_changed(name);
         touch_club(name);
         if (!is_family(name)) {
            send_broadcast_message(name,
                                   capitalize(member) + " joins the club.");
         }
         return 1;
      }
   }
   return 0;
}
int remove_member(string name, string member) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      if (member_array(member, data->members) != -1) {
         if (is_recruiter_of(name, member)) {
            remove_recruiter(name, member);
         }
         data->members -= ({ member });
         set_club_changed(name);
         check_extra_information(name, member, 0);
         if (!is_family(name)) {
            send_broadcast_message(name,
                                   capitalize(member) + " leaves the club.");
         }
         send_observer_event("club_event_remove_member", name, member);
         return 1;
      }
   }
   return 0;
}
int remove_recruiter(string name, string recruiter) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      if (member_array(recruiter, data->recruiters) != -1) {
         data->recruiters -= ({ recruiter });
         set_club_changed(name);
         if (!is_family(name)) {
            send_broadcast_message(name,
                                   capitalize(recruiter) +
                                   " stops being a recruiter for the club.");
         }
         return 1;
      }
   }
   return 0;
}
string query_club_name(string club_name) {
   class club_info data;
   if (is_club(club_name)) {
      data = query_club_info(club_name);
      if (!data) {
         return club_name;
      }
      return data->actual_name;
   }
   return 0;
}
string query_club_description(string club_name) {
   class club_info data;
   if (is_club(club_name)) {
      data = query_club_info(club_name);
      return data->description;
   }
   return 0;
}
int set_club_description(string club_name, string description) {
   class club_info data;
   if (is_club(club_name)) {
      data = query_club_info(club_name);
      data->description = description;
      set_club_changed(club_name);
      return 1;
   }
   return 0;
}
int query_time_fees_due(string club_name) {
   class club_info data;
   if (is_club(club_name)) {
      data = query_club_info(club_name);
      return data->last_paid + CLUB_PAY_PERIOD;
   }
   return 0;
}
int query_club_cost_per_period(string club_name) {
   if (is_club(club_name)) {
      return CLUB_COST_PER_YEAR +
           sizeof(query_members(club_name)) * CLUB_COST_PER_MEMBER_PER_YEAR;
   }
   return 0;
}
int is_club(string name) {
   name = normalise_name(name);
   if (!undefinedp(_club_names[name])) {
      return 1;
   }
   return 0;
}
int is_elected_club(string name) {
   name = normalise_name(name);
   if (is_club(name)) {
      return query_club_type(name) == CLUB_ELECTED;
   }
   return 0;
}
int is_personal_club(string name) {
   if (is_club(name)) {
      return query_club_type(name) == CLUB_PERSONAL;
   }
   return 0;
}
int is_family(string name) {
   if (is_club(name)) {
      return query_club_type(name) == CLUB_FAMILY;
   }
   return 0;
}
int is_member_of(string name, string member) {
   if (is_club(name)) {
      return member_array(member, query_members(name)) != -1;
   }
   return 0;
}
int is_recruiter_of(string name, string recruiter) {
   if (is_club(name)) {
      return member_array(recruiter, query_recruiters(name)) != -1;
   }
   return 0;
}
int is_founder_of(string name, string founder) {
   name = normalise_name(name);
   if (is_club(name)) {
      return query_founder(name) == founder;
   }
   return 0;
}
int create_account(string name,
                   string account) {
   class club_info data;
   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (is_club(name)) {
      data = query_club_info(name);
      if (undefinedp(data->accounts[account])) {
         data->accounts[account] = 0;
         touch_club(name);
         set_club_changed(name);
         return 1;
      }
   }
   return 0;
}
int add_money(string name,
              int amount,
              int type,
              string person,
              string account) {
   class club_info data;
   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (is_club(name) && amount > 0) {
      data = query_club_info(name);
      if (!undefinedp(data->accounts[account])) {
         data->accounts[account] += amount;
         touch_club(name);
         set_club_changed(name);
         return 1;
      }
   }
   return 0;
}
int remove_money(string name,
                 int amount,
                 int type,
                 string person,
                 string account) {
   class club_info data;
   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (is_club(name) && amount > 0) {
      data = query_club_info(name);
      if (!undefinedp(data->accounts[account])) {
         data->accounts[account] -= amount;
         touch_club(name);
         set_club_changed(name);
         return 1;
      }
   }
   return 0;
}
int query_balance(string name,
                  string account) {
   class club_info data;
   if (!account) {
      account = CLUB_DEFAULT_ACCOUNT_NAME;
   }
   if (is_club(name)) {
      data = query_club_info(name);
      return data->accounts[account];
   }
   return 0;
}
string* query_account_names(string name) {
   class club_info data;
   if (is_club(name)) {
      data = query_club_info(name);
      if (data) {
         return keys(data->accounts);
      }
   }
   return ({ });
}
int is_account_of(string club_name, string account) {
   return member_array(account, query_account_names(club_name)) != -1;
}
int is_creator_club(string club_name) {
   if (is_club(club_name)) {
      if (PLAYER_HANDLER->test_creator(query_founder(club_name))) {
         return 1;
      }
   }
   return 0;
}
int is_observer(string obs) {
   if (member_array(obs, _observers) != -1) {
      return 1;
   }
   return 0;
}
int add_observer(string obs) {
   if (!is_observer(obs) &&
       file_size(obs) > 0) {
      _observers += ({ obs });
      save_main();
      return 1;
   }
   return 0;
}
int remove_observer(string obs) {
   if (is_observer(obs)) {
      _observers -= ({ obs });
      save_main();
      return 1;
   }
   return 0;
}
string *query_observers() {
   return _observers;
}
protected void send_observer_event(string event_name,
                                   string *args ...) {
   string bing;
   foreach (bing in _observers) {
      if (file_size(bing) > 0) {
         call_out((: call_other($1, $2, $3 ...) :),
                  0,
                  event_name,
                  bing,
                  args ...);
      } else {
         remove_observer(bing);
      }
   }
}
protected void send_broadcast_message(string club,
                                      string message) {
   BROADCASTER->broadcast_to_channel(this_object(),
                                     lower_case(query_club_name(club)),
                                     ({ message, 0 }));
}
mixed *stats() {
   return ({
              ({ "cache hits", _no_cache_hits }),
              ({ "cache requests", _no_cache_requests }),
              ({ "cache miss", _no_cache_miss }),
              ({ "percentage", _no_cache_hits * 100 / _no_cache_requests }),
           });
}
